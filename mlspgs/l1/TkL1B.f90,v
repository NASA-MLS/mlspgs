head	2.39;
access;
symbols
	v5-02-NRT-19:2.39
	v6-00:2.39
	v5-02-NRT-18:2.39
	v5-02:2.38
	v5-01-NRT-17:2.38
	v5-01-NRT-16:2.38
	v5-01-NRT-15:2.38
	v5-01-NRT-14:2.38
	neuralnetworks-1-0:2.38.0.10
	cfm-single-freq-0-1:2.38.0.8
	v5-01:2.38
	v5-00:2.38
	v4-23-TA133:2.38.0.6
	mus-emls-1-70:2.38.0.4
	rel-1-0-englocks-work:2.38.0.2
	VUMLS1-00:2.38
	VPL1-00:2.38
	V4-22-NRT-08:2.38
	whdrel10_merged_to_here:2.38
	merge_whdrel10_from_here:2.37.4.2
	TAG_TRUNK_AFTER_PW_CHANGES:2.37
	TAG_TRUNK_BEFORE_PW_CHANGES:2.37
	VAM1-00:2.37
	whd-rel-1-0:2.37.0.4
	V4-21:2.37.0.2
	V4-13:2.35
	V4-12:2.35
	V4-11:2.35
	V4-10:2.35
	V3-43:2.35
	M4-00:2.35
	V3-41:2.35
	V3-40-PlusGM57:2.35.0.2
	V2-24-NRT-04:2.33
	V3-33:2.35
	V2-24:2.33
	V3-31:2.35
	V3-30-NRT-05:2.35
	cfm-01-00:2.35
	V3-30:2.35
	V3-20:2.35
	V3-10:2.35
	V2-23-NRT-02:2.33
	V2-23:2.33
	V2-22-NRT-01:2.33
	V2-22:2.33
	V2-21:2.31
	V2-20:2.31
	V2-11:2.31
	V2-10:2.31
	V2-00:2.31
	V1-51:2.21
	V1-50:2.19
	V1-45:2.18
	V1-44:2.18
	V1-43:2.16
	V1-42:2.15
	V1-41:2.15
	V1-32:2.14
	V1-40:2.15
	V1-31:2.14
	V1-30:2.14
	V1-13:2.11
	V1-12:2.11
	V1-11:2.11
	V1-10:2.11
	newfwm-feb03:2.11.0.2
	V1-04:2.9
	V1-03:2.9
	V1-02:2.9
	V1-00:2.9
	newfwm-sep01:2.1.0.2
	V0-7:2.1
	V0-5-Level2:2.1
	V0-5-SIPS:2.1
	V0_1:1.2;
locks; strict;
comment	@# @;


2.39
date	2023.05.25.22.24.20;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2016.03.15.22.17.59;	author whdaffer;	state Exp;
branches;
next	2.37;

2.37
date	2015.01.23.17.50.17;	author pwagner;	state Exp;
branches
	2.37.4.1;
next	2.36;

2.36
date	2015.01.22.23.34.04;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2009.07.28.18.08.11;	author perun;	state Exp;
branches;
next	2.34;

2.34
date	2009.06.01.14.01.18;	author perun;	state Exp;
branches;
next	2.33;

2.33
date	2007.06.27.14.45.30;	author perun;	state Exp;
branches;
next	2.32;

2.32
date	2007.04.05.13.59.27;	author perun;	state Exp;
branches;
next	2.31;

2.31
date	2006.06.14.13.50.02;	author perun;	state Exp;
branches;
next	2.30;

2.30
date	2006.04.05.18.09.58;	author perun;	state Exp;
branches;
next	2.29;

2.29
date	2006.03.24.15.21.17;	author perun;	state Exp;
branches;
next	2.28;

2.28
date	2005.12.14.17.01.21;	author perun;	state Exp;
branches;
next	2.27;

2.27
date	2005.12.06.19.30.42;	author perun;	state Exp;
branches;
next	2.26;

2.26
date	2005.10.11.16.08.50;	author perun;	state Exp;
branches;
next	2.25;

2.25
date	2005.08.24.15.53.43;	author perun;	state Exp;
branches;
next	2.24;

2.24
date	2005.07.19.16.34.46;	author perun;	state Exp;
branches;
next	2.23;

2.23
date	2005.06.23.18.41.36;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2005.02.14.19.30.48;	author perun;	state Exp;
branches;
next	2.21;

2.21
date	2005.01.28.17.04.05;	author perun;	state Exp;
branches;
next	2.20;

2.20
date	2005.01.25.18.01.06;	author perun;	state Exp;
branches;
next	2.19;

2.19
date	2004.11.10.15.32.05;	author perun;	state Exp;
branches;
next	2.18;

2.18
date	2004.08.12.13.51.51;	author perun;	state Exp;
branches;
next	2.17;

2.17
date	2004.08.03.20.41.14;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2004.05.14.15.59.11;	author perun;	state Exp;
branches;
next	2.15;

2.15
date	2004.01.09.17.46.23;	author perun;	state Exp;
branches;
next	2.14;

2.14
date	2003.09.15.21.50.04;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2003.09.15.17.15.54;	author perun;	state Exp;
branches;
next	2.12;

2.12
date	2003.08.15.14.25.04;	author perun;	state Exp;
branches;
next	2.11;

2.11
date	2002.11.07.21.56.20;	author jdone;	state Exp;
branches;
next	2.10;

2.10
date	2002.09.26.20.52.26;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2002.03.29.20.18.34;	author perun;	state Exp;
branches;
next	2.8;

2.8
date	2001.12.14.01.43.46;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.12.12.19.05.44;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.12.12.03.07.32;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.12.11.00.55.51;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.12.07.00.51.44;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2001.12.06.01.03.46;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2001.10.12.22.11.05;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.23.18.26.11;	author perun;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.55.15;	author ahanzel;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.15.18.48.37;	author nakamura;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.10.17.00.57;	author nakamura;	state Exp;
branches;
next	;

2.37.4.1
date	2015.10.09.10.21.38;	author whdaffer;	state Exp;
branches;
next	2.37.4.2;

2.37.4.2
date	2016.03.03.18.54.53;	author whdaffer;	state Exp;
branches;
next	;


desc
@@


2.39
log
@Trying to make level 1 crash if de200.eos is out-of-date
@
text
@! Copyright 2009, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

MODULE TkL1B

  ! This module contains subroutines for producing the L1BOA records on
  ! a MAF by MAF basis.


  use Constants, only: Deg2Rad, Pi, Rad2Deg
  USE Geometry, ONLY: Omega => W
  USE MLSCommon, ONLY: R8, DEFAULTUNDEFINEDVALUE
  USE MLSL1Common
  USE MLSMessageModule, ONLY: MLSMESSAGE, MLSMSG_Error, MLSMSG_Warning, &
       MLSMSG_Allocate, ReportTKStatus
  USE OUTPUT_M, ONLY: BLANKS, OUTPUT
  USE OutputL1B_DataTypes, ONLY: L1BOAsc_T, L1BOATP_T, L1BOAINDEX_T, LENCOORD, &
       LENG, LENT
  USE OutputL1B, ONLY: OUTPUTL1B_THZ, OUTPUTL1B_SC, OUTPUTL1B_INDEX, &
       OUTPUTL1B_GHZ
  USE Scan, ONLY : Scan_guess, Scan_start
  USE SDPToolkit, only: spacecraftid, earthModel, PGS_TRUE, PGS_S_SUCCESS, &
    & PGSEPH_W_BAD_EPHEM_VALUE, PGSd_SUN, PGSd_MOON
  USE MLSL1Utils, ONLY: Finite

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: L1BOA_MAF, GHz_GeodAlt, GHz_GeodLat, GHz_GeodAngle, GHz_BO_stat, &
       scGeodAngle

  REAL :: GHz_GeodAlt(LENG), GHz_GeodLat(LENG), GHz_GeodAngle(LENG), scGeodAngle
  INTEGER :: GHz_BO_stat(LENG)

  CHARACTER (len=*), PARAMETER :: errmsg = "Check LogStatus file for error(s)"
  LOGICAL, PARAMETER :: ORBINCLINE_IS_CONSTANT = .FALSE.
  REAL, PARAMETER ::    UNDEFINED_VALUE = DEFAULTUNDEFINEDVALUE ! -999.99
  REAL, PARAMETER ::    HUGE_F = HUGE (1.0)

!---------------------------- RCS Module Info ------------------------------
  CHARACTER (len=*), PRIVATE, PARAMETER :: ModuleName= &
       "$RCSfile: TkL1B.f90,v $"
  PRIVATE :: not_used_here 
!---------------------------------------------------------------------------

  ! This module contains subroutines for producing the L1BOA records on
  ! a MAF by MAF basis.

CONTAINS

!=============================================================================
  SUBROUTINE Init_L1BOAsc (sc)
!=============================================================================

    TYPE (L1BOAsc_T) :: sc

    sc%scECI = HUGE_F
    sc%scECR = HUGE_F
    sc%scGeocAlt = HUGE_F
    sc%scGeodAlt = HUGE_F
    sc%scGeocLat = HUGE_F
    sc%scGeodLat = HUGE_F
    sc%scLon = HUGE_F
    sc%scGeodAngle = HUGE_F
    sc%scOrbIncl = HUGE_F
    sc%scVelECI = HUGE_F
    sc%scVelECR = HUGE_F
    sc%ypr = HUGE_F
    sc%yprRate = HUGE_F

  END  SUBROUTINE Init_L1BOAsc

!=============================================================================
  SUBROUTINE Init_L1BOAtp (tp, MIFbad)
!=============================================================================

    TYPE (L1BOAtp_T) :: tp
    LOGICAL, OPTIONAL, INTENT(IN) :: MIFbad(:)

    LOGICAL :: badindx (SIZE(tp%tpLon))  ! Indexes for "bad" MIFs

    IF (PRESENT (MIFbad)) THEN
       badindx = MIFbad
    ELSE
       badindx = .TRUE.
    ENDIF

    WHERE (badindx)
       tp%tpGeodAlt = UNDEFINED_VALUE
       tp%tpGeocAlt = UNDEFINED_VALUE
       tp%tpOrbY = UNDEFINED_VALUE
       tp%tpGeocLat = UNDEFINED_VALUE
       tp%tpGeocAltRate = UNDEFINED_VALUE
       tp%tpGeodLat = UNDEFINED_VALUE
       tp%tpGeodAltRate = UNDEFINED_VALUE
       tp%tpLon = UNDEFINED_VALUE
       tp%tpGeodAngle = UNDEFINED_VALUE
       tp%tpSolarTime = UNDEFINED_VALUE
       tp%tpSolarZenith = UNDEFINED_VALUE
       tp%tpLosAngle = UNDEFINED_VALUE
       tp%tpLosVel = UNDEFINED_VALUE
    ENDWHERE

  END SUBROUTINE Init_L1BOAtp

  !------------------------------------------ TkL1B_sc ---------
  SUBROUTINE TkL1B_sc (numValues, offsets, asciiUTC, mafTAI, sc, ecrtosc, &
       oastat)
    ! This subroutine contains prototype code for creating the desired s/c
    ! record from the EPHEMATTIT output.
    
    ! <whd> This subroutine calculates the rotation matrix from SC
    ! coordinates to ECR coordinates </whd>

    ! Arguments
    TYPE (L1BOAsc_T) :: sc
    CHARACTER (LEN=27), INTENT(IN) :: asciiUTC
    INTEGER, INTENT(IN) :: numValues
    REAL(r8), INTENT(IN) :: offsets(numValues), mafTAI
    REAL, INTENT(OUT) :: ecrtosc(3,3,numValues)
    INTEGER, INTENT(OUT) :: oastat

    ! PDS Toolkit Functions
    INTEGER :: Pgs_csc_eciToECR, Pgs_csc_ecrToGEO, Pgs_eph_ephemAttit

    ! Variables
    CHARACTER (LEN=32) :: mnemonic
    CHARACTER (LEN=480) :: msg, msr
    INTEGER :: i, j, returnStatus
    INTEGER :: qualityFlags(2, numValues)
    REAL(r8) :: ecrVec(3), eulerangles(3,numValues)
    REAL(r8) :: radC(numValues), radD(numValues), radL(numValues)
    REAL(r8), TARGET :: attitQuat(4,numValues)
    REAL(r8) :: eciV(6,numValues), ecrV(6,numValues)
    REAL(r8) :: sctoeci(6,3*numValues), sctoecr(6,3*numValues) 
    REAL(r8) , POINTER :: w(:), x(:), y(:), z(:)
    
    ! <whd> This is defined, but never used.
    !REAL(r8), PARAMETER :: SCtoGHz(3,3) = RESHAPE ((/ &
    !     -0.0000086, -0.4260405, 0.9047041, &
    !      1.0000000,  0.0000000, 0.0000095, &
    !     -0.0000041,  0.9047041, 0.4260405 /), (/ 3, 3 /))

    ! Executable code

    ! Read oa data

    returnStatus = Pgs_eph_ephemAttit (spacecraftId, numValues, asciiUTC,  &
         & offsets, pgs_true, pgs_true, &
         & qualityFlags, sc%scECI, sc%scVelECI, & ! the rest are outputs!
         & eulerangles, sc%yprRate, attitQuat)

! save YPR:

    ! <whd> 
    ! 
    ! Does the following mean that AURAs euler angle order is yaw,
    ! roll, pitch?, i.e. 3,1,2?  Yes, looking at an Attitude file (in
    ! /data/Aura/attitude/year/doy/AURAATTH...) the Vdata Attitude
    ! Header reports the Euler Angle order is 3,1,2
    ! 
    ! It doesn't appear that euler angle is used for anything, it's
    ! just passed along to the output L1BOA file.
    ! 
    ! </whd>

    sc%ypr(1,:) = eulerangles(1,:)
    sc%ypr(2,:) = eulerangles(3,:)
    sc%ypr(3,:) = eulerangles(2,:)

! Trap any bad attitQuat data

    IF (returnStatus == PGS_S_SUCCESS) THEN
       outer: DO j = 1, numValues
          DO i = 1, 4
             IF (.NOT. Finite (REAL(attitQuat(i,j)))) THEN
                returnStatus = PGSEPH_W_BAD_EPHEM_VALUE
                EXIT outer
             ENDIF
          ENDDO
       ENDDO outer
    ENDIF

    oastat = returnStatus

    IF (returnStatus /= PGS_S_SUCCESS) THEN
       CALL Pgs_smf_getMsg (returnStatus, mnemonic, msg)
       msr = 'Routine ephemAttit, ' // mnemonic // ':  ' // msg
       CALL MLSMessage (MLSMSG_Warning, ModuleName, msr)
       ! Initial out values:

       CALL Init_L1BOAsc (sc)
       ecrtosc = HUGE_F

       RETURN
    ENDIF

    ! attitQuat is spacecraft to eci rotation quaternion
    w => attitquat(1,:)
    x => attitquat(2,:)
    y => attitquat(3,:)
    z => attitquat(4,:)

    sctoeci = 0.0

    ! Convert quaternion to matrix (optimized for readability)

    sctoeci(1, 1::3) = w**2 + x**2 - y**2 - z**2
    sctoeci(2, 2::3) = w**2 - x**2 + y**2 - z**2
    sctoeci(3, 3::3) = w**2 - x**2 - y**2 + z**2
    sctoeci(1, 2::3) = 2*x*y - 2*w*z
    sctoeci(2, 1::3) = 2*x*y + 2*w*z
    sctoeci(1, 3::3) = 2*x*z + 2*w*y
    sctoeci(3, 1::3) = 2*x*z - 2*w*y
    sctoeci(2, 3::3) = 2*y*z - 2*w*x
    sctoeci(3, 2::3) = 2*y*z + 2*w*x

    ! rotate the columns of the sctoeci matrix to form ecrtosc matrix columns

    returnStatus = PGS_CSC_ECItoECR (3*numValues, asciiUTC, &
         PACK(SPREAD(offsets,1,3), .TRUE.), sctoeci, sctoecr)
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)

    ! we really prefer the other index to be exposed for matrix multiplication
    ! now we have [ECR x (SC*numValues)] which requires a loop for rotation
    ! SC-->GHz reference (R3,B8)
    
    DO i = 1, numValues    
       ecrtosc(:,:,i) = TRANSPOSE (sctoecr(1:3,3*i-2:3*i))
    ENDDO 

    ! Convert scECI to scECR
    eciV(1:3,:) = sc%scECI
    eciV(4:6,:) = sc%scVelECI    ! was 0.0
    returnStatus = Pgs_csc_eciToECR (numValues, asciiUTC, offsets, eciV, ecrV)
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)
    sc%scECR = ecrV(1:3,:)
    sc%scVelECR = ecrV(4:6,:)

    ! Calculate geocentric/geodetic altitude, latitude & longitude from scECR
    DO i = 1, numValues
       sc%scGeocAlt(i) = SQRT (ecrV(1,i)**2 + ecrV(2,i)**2 + ecrV(3,i)**2)
       radC(i) = ATAN (ecrV(3,i) / SQRT (ecrV(1,i)**2 + ecrV(2,i)**2))
       sc%scGeocLat(i) = Rad2Deg * radC(i)
       ecrVec = ecrV(1:3,i)
       returnStatus = Pgs_csc_ecrToGEO (ecrVec, earthModel, radL(i), &
            radD(i), sc%scGeodAlt(i))
       sc%scGeodLat(i) = Rad2Deg * radD(i)
       sc%scLon(i) = Rad2Deg * radL(i)
       IF (ORBINCLINE_IS_CONSTANT) THEN
          sc%scOrbIncl(i) = orbInclineCrossProd (sc%scECI(:,i), &
               sc%scVelECI(:,i))
       ELSE
          sc%scOrbIncl(i) = orbInclineCalculated (sc%scECR(:,i), &
               sc%scVelECR(:,i), sc%scGeocLat(i), sc%scLon(i))
       ENDIF
       sc%MIF_TAI(i) = mafTAI + offsets(i)
    ENDDO

  END SUBROUTINE TkL1B_sc

  !------------------------------------------------------TkL1B_tp ----
  SUBROUTINE TkL1B_tp (asciiTAI, asciiUTC, lenG, numValues, offsets, posECR, &
    posECI, velECI, scAngle, encoderAngle, tp, ecrtosc, GroundToFlightMounts, &
    ScToGroundMounts, BO_def, BO_angle, BO_Negate, gtindx, MoonToSpaceAngle)
    ! This subroutine fills the tangent point record.

    USE FOV, ONLY: CalcMountsToFOV
    USE SDPToolkit, ONLY: PGS_S_SUCCESS, PGSCSC_W_HIT_EARTH 

    ! Arguments
    TYPE (L1BOAtp_T) :: tp
    CHARACTER (LEN=27), INTENT(IN) :: asciiUTC
    INTEGER, INTENT(IN) :: lenG, numValues, gtindx
    INTEGER, INTENT(IN) :: BO_def(:)
    LOGICAL, INTENT(IN) :: BO_Negate(:)
    REAL, INTENT(IN) :: scAngle(numValues), encoderAngle(numValues)
    REAL(r8), INTENT(IN) :: asciiTAI
    REAL(r8), INTENT(IN) :: offsets(numValues)
    REAL(r8), INTENT(IN) :: posECR(3,numValues), &
         &                  posECI(3,numValues), &
         &                  velECI(3,numValues)
    REAL, INTENT(IN) :: ecrtosc(3,3,numValues), BO_angle(:)
    REAL, INTENT(IN), OPTIONAL :: MoonToSpaceAngle

    REAL(r8), INTENT(IN) :: GroundToFlightMounts(3,3)
    REAL(r8), INTENT(IN) :: ScToGroundMounts(3,3)

    ! Functions
    INTEGER :: Pgs_cbp_sat_cb_vector, Pgs_cbp_solarTimeCoords
    INTEGER :: Pgs_csc_scToOrb, Pgs_csc_scToECI, Pgs_csc_eciToECR
    INTEGER :: Pgs_csc_grazingRay, Pgs_csc_ecrToECI, Pgs_csc_eciToOrb
    INTEGER :: Pgs_td_taiToUTC

    ! Variables
    CHARACTER (LEN=27) :: time
    INTEGER :: flag, flagQ, i, returnStatus, Xnum
    LOGICAL :: MIFbad(lenG)
    REAL(r8) :: declination, deltaAlt, deltaLat, deltaLon
    REAL(r8) :: greenwich, localApparent(lenG), rightAscension, tai
    REAL(r8) :: dot(lenG), latD(lenG), localMean(lenG), lon(lenG), los(lenG)
    REAL(r8) :: ecr_sign(lenG), slantRange(lenG)
    REAL(r8) :: eci(3,lenG), ecr(3,lenG), hECR(3,lenG), nts(3,lenG)
    REAL(r8) :: posSurf(3,lenG), sc_frame_vector(3,lenG), sc_sun(3,lenG)
    REAL(r8) :: sc_tp(3,lenG), tp_sun(3,lenG), tpOrb(3,lenG), unitAlt(3,lenG)
    REAL(r8) :: unitLat(3,lenG), unitLon(3,lenG), vECR(3,lenG)
    REAL(r8) :: fov_sc(3,numValues), fov_orb(3,numValues)
    REAL(r8) :: eciV(6,lenG), ecrV(6,lenG)
    REAL(r8) :: tngtVel(3), los_vec(3,lenG)
    REAL(r8) :: MountsToFOV(3,3), ECRtoFOV(3,3), FOV_eci(3,numValues)
    REAL(r8) :: GroundMountsToFOV(3,3), ScToFOV(3,3)
    CHARACTER (LEN=32) :: mnemonic
    CHARACTER (LEN=480) :: msg, msr

    ! Executable code

    deltaLat = 0.1
    deltaLon = 0.1
    deltaAlt = 1000.0
    tp%encoderAngle = encoderAngle


    !! <whd> Everything labled `fov_sc' is the line-of-sight of the
    !! instrument.  I think that `_sc' is really in the instrument
    !! coordinate system, rather than the 'sc' (spacecraft) coordinate
    !! system. The S/C coordinate system is labeled fov_orb
    !! below. </whd>

    ! Determine ECR to FOV

    !<whd> COB=change-of-basis or coordinate change, or rotation.
    DO i = 1, numValues

      CALL CalcMountsToFOV (scAngle(i), gtindx, MountsToFOV)
      GroundMountsToFOV = MATMUL (MountsToFOV, GroundToFlightMounts)
      ScToFOV = MATMUL (GroundMountsToFOV, ScToGroundMounts)

      !<whd> ScToFOV = mountsToFOV # GroundToFlightMounts #
      ! 
      ECRtoFOV = MATMUL (ScToFOV, ecrtosc(:,:,i))
      
      !<whd> What happens when i > lenG? </whd>
      IF (i <= lenG) tp%tpECRtoFOV(:,i) = RESHAPE (ECRtoFOV, (/ 9 /))
      
      ! <whd> Picking up 3rd row of change of coords matrix. Why?
      ! </whd>
      fov_sc(1,i) = ScToFOV(3,1)
      fov_sc(2,i) = ScToFOV(3,2)
      fov_sc(3,i) = ScToFOV(3,3)
      
      ! Put sc angle. 
      
      ! <whd> This is the angle in the X/Z plane of the look
      ! direction, calculated as 90 - 'angle from Z'. </whd>
      
      
      tp%scAngle(i) = 90.0 - &
           ACOS (MAX (MIN(fov_sc(3,i), 1.0d0), -1.0d0)) * Rad2Deg
    ENDDO

    ! Convert s/c vector to Orb vector/angle/degrees
    
    ! <whd> do change of coordinates of the line-of-sight vector from
    ! the instrument (_sc) orbital coordinates. Rick Cofield says that
    ! the `orb' coordinate system is the local vertical system, Z
    ! points at S/C nadir, X is parallel to the velocity vector (when
    ! pitch=0) and Y completes the triad </whd>

    returnStatus = Pgs_csc_scToOrb (spacecraftId, numValues, asciiUTC, &
      offsets, fov_sc, fov_orb)
    IF (returnStatus /= PGS_S_SUCCESS) THEN
       CALL Pgs_smf_getMsg (returnStatus, mnemonic, msg)
       msr = 'Routine scToOrb, ' // mnemonic // ':  ' // msg
       CALL MLSMessage (MLSMSG_Warning, ModuleName, msr)
 
       ! Initial out values:

       CALL Init_L1BOAtp (tp)
       RETURN
    ENDIF

    ! Do geodetic altitude extension (MIFs after limb views) first:

    Xnum = numValues - lenG   ! extra number of MIFs

    ! <whd> Here we operate on those `excess' MIFs that are in this
    ! MAF. lenG (nominally == 125) is the normal number of MIFs in a
    ! MAF that we expect to get actual data out of. Xnum will be the
    ! excess of that. </whd>

    ! Convert s/c vector to ECR
    returnStatus = Pgs_csc_scToECI (spacecraftId, Xnum, asciiUTC, &
      offsets(lenG+1:), fov_sc(:,lenG+1:), fov_eci(:,1:Xnum))
    eciV(1:3,1:Xnum) = fov_eci(:,1:Xnum)
    eciV(4:6,1:Xnum) = 0.0
    returnStatus = Pgs_csc_eciToECR (xNum, asciiUTC, offsets(lenG+1:), &
         eciV(:,1:Xnum), ecrV(:,1:Xnum))
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)
    ecr(:,1:Xnum) = ecrV(1:3,1:Xnum)

    DO i = 1, Xnum
      returnStatus = Pgs_csc_grazingRay (earthModel, posECR(:,i+lenG), &
           ecr(:,i), latD(i), lon(i), tp%tpGeodAltX(i), &
           slantRange(i), tp%tpECR(:,i), posSurf(:,i))
      IF (returnStatus /= PGS_S_SUCCESS .AND. &
           returnStatus /= PGSCSC_W_HIT_EARTH) tp%tpGeodAltX(i) = 0.0 ! Special?
    ENDDO

    !<whd> tp%scanAngle is the angle away from X (or Z) axis in the
    !spacecraft coordinate system of the line-of-sight vector. This is
    !different from the tp%scAngle, which was the angle of the same
    !vector in the _sc (really the instrument) coordinate system (I think?)
    !</whd>

    tp%scanAngle = 90.0 - ACOS (MAX (MIN (fov_orb(3,:), 1.0d0), -1.0d0)) * &
         Rad2Deg
    tp%scanRate(1) = 0.0
    tp%scanRate(2:) = ABS(tp%scanAngle(2:) - tp%scanAngle(1:(numValues-1))) &
         / offsets(2)
    tp%azimAngle = ATAN2 (fov_orb(2,:), fov_orb(1,:)) * Rad2Deg

    ! Convert s/c vector to ECR
    returnStatus = Pgs_csc_scToECI (spacecraftId, lenG, asciiUTC, &
      offsets(1:lenG), fov_sc(:,1:lenG), fov_eci(:,1:lenG))
    eciV(1:3,:) = fov_eci(:,1:lenG)
    eciV(4:6,:) = 0.0
    returnStatus = Pgs_csc_eciToECR (lenG, asciiUTC, offsets(1:lenG), eciV, &
         ecrV)
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)
    ecr = ecrV(1:3,:)

    ! For each scanning MIF

    MIFbad = .FALSE.
    DO i = 1, lenG

      ! Calculate tangent point (geodetic & ECR)
      returnStatus = Pgs_csc_grazingRay (earthModel, posECR(:,i), ecr(:,i), &
           latD(i), lon(i), tp%tpGeodAlt(i), &
           slantRange(i), tp%tpECR(:,i), posSurf(:,i))

      IF (returnStatus /= PGS_S_SUCCESS .AND. &
           returnStatus /= PGSCSC_W_HIT_EARTH) THEN  ! success or "hit" earth
         latD(i) = 0.0 ! HUGE_F
         lon(i) = 0.0 ! HUGE_F
         tp%tpGeodAlt(i) = 0.0 ! HUGE_F
         slantRange(i) = 0.0 ! HUGE_F
         tp%tpECR(:,i) = 0.0 ! HUGE_F
         posSurf(:,i) = 0.0 ! HUGE_F
         MIFbad(i) = .TRUE.
      ENDIF

      ! Create ECR unit vector quantities -- lat=1, lon=2, alt=3
      flagQ = 1
      CALL Tp_unit (flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaLat, &
           unitLat(:,i), flag)
      IF (flag==-1) THEN
         msg="lat:Failure in Tp_unit: UTC="//asciiUTC
         CALL MLSMessage (MLSMSG_Warning, ModuleName, TRIM(msg))
         PRINT *,TRIM(msg)
      ENDIF

      flagQ = 2
      CALL Tp_unit (flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaLon, &
           unitLon(:,i), flag)
      IF (flag==-1) THEN
         msg="lon:Failure in Tp_unit: UTC="//asciiUTC
         CALL MLSMessage (MLSMSG_Warning, ModuleName, TRIM(msg))
         PRINT *,TRIM(msg)
      ENDIF

      flagQ = 3
      CALL Tp_unit (flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaAlt, &
           unitAlt(:,i), flag)
      IF (flag==-1) THEN
         msg="alt:Failure in Tp_unit: UTC="//asciiUTC
         CALL MLSMessage (MLSMSG_Warning, ModuleName, TRIM(msg))
         PRINT *,TRIM(msg)
      ENDIF


      ! Get local mean solar time from Toolkit
      tai = asciiTAI + (i-1)*offsets(2)
      returnStatus = Pgs_td_taiToUTC (tai, time)
      returnStatus = Pgs_cbp_solarTimeCoords (time, lon(i), greenwich, &
        localMean(i), localApparent(i), rightAscension, declination)

    ENDDO

    tp%tpGeodLat = Rad2Deg * latD
    tp%tpLon = Rad2Deg * lon
    tp%tpSolarTime = localApparent / 3600.0

    ! Calculate solarZenith

    returnStatus = Pgs_cbp_sat_cb_vector (spacecraftId, lenG, asciiUTC, &
         offsets(1:lenG), PGSd_SUN, sc_frame_vector)
    if ( returnStatus /= PGS_S_SUCCESS ) &
      & CALL MLSMessage ( MLSMSG_Error, ModuleName, 'Pgs_cbp_sat_cb_vector' &
      & //' at '//asciiUTC)
    returnStatus = Pgs_csc_scToECI (spacecraftId, lenG, asciiUTC, &
         offsets(1:lenG), sc_frame_vector, eci)
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)
    eciV(1:3,:) = eci
    eciV(4:6,:) = 0.0
    returnStatus = Pgs_csc_eciToECR (lenG, asciiUTC, offsets(1:lenG), eciV, &
         ecrV)
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)

    sc_sun = ecrV(1:3,:)
    DO i = 1, lenG
       sc_tp(:,i) = ecr(:,i) * slantRange(i)
    ENDDO
    tp_sun = sc_sun - sc_tp
    DO i = 1, lenG
       nts(:,i) = tp_sun(:,i) / SQRT (tp_sun(1,i)**2 + tp_sun(2,i)**2 + &
            tp_sun(3,i)**2)
    ENDDO
    dot = nts(1,:)*unitAlt(1,:) + nts(2,:)*unitAlt(2,:) + &
         nts(3,:)*unitAlt(3,:)
    tp%tpSolarZenith = ACOS(MAX(MIN(dot, 1.0d0), -1.0d0)) * Rad2Deg

    ! Calculate losAngle
    DO i = 1, lenG
       vECR(:,i) = ecr(:,i) - (ecr(1,i)*unitAlt(1,i) + &
            ecr(2,i)*unitAlt(2,i) + ecr(3,i)*unitAlt(3,i))
       hECR(:,i) = vECR(:,i) / SQRT(vECR(1,i)**2 + vECR(2,i)**2 + &
            vECR(3,i)**2)
    ENDDO
    los = ACOS(MAX(MIN(hECR(1,:)*unitLat(1,:) + hECR(2,:)*unitLat(2,:) + &
         hECR(3,:)*unitLat(3,:), 1.0d0), -1.0d0))
    ecr_sign = ecr(1,:)*unitLon(1,:) + ecr(2,:)*unitLon(2,:) + &
      ecr(3,:)*unitLon(3,:)
    DO i = 1, lenG
       IF (ecr_sign(i) < 0 ) los(i) = 2*PI - los(i)
    ENDDO
    tp%tpLosAngle = los * Rad2Deg

    ! Convert tpECR to tpECI
    ecrV(1:3,:) = tp%tpECR
    ecrV(4:6,:) = 0.0
    returnStatus = Pgs_csc_ecrToECI (lenG, asciiUTC, offsets(1:lenG), ecrV, &
      eciV)
    tp%tpECI = eciV(1:3,:)

    ! Calculate losVel
    DO i = 1, lenG
      tngtVel = omega * (/ -tp%tpECI(2,i), tp%tpECI(1,i), 0.0_r8 /)
      los_vec(:,i) = tp%tpECI(:,i) - posECI(:,i)
      los_vec(:,i) = los_vec(:,i) / SQRT (SUM (los_vec(:,i)**2))
      tp%tpLosVel(i) = DOT_PRODUCT (tngtVel, los_vec(:,i)) - &
           DOT_PRODUCT (velECI(:,i), los_vec(:,i))
    ENDDO

    ! Convert tpECI to tpOrb
    returnStatus = Pgs_csc_eciToOrb (spacecraftId, lenG, asciiUTC, &
         offsets(1:lenG), tp%tpECI, tpOrb)
    tp%tpOrbY = tpOrb(2,:)

    ! Calculate tp geocentric coordinates
    DO i = 1, lenG
      tp%tpGeocAlt(i) = SQRT( tp%tpECR(1,i)**2 + tp%tpECR(2,i)**2 + &
           tp%tpECR(3,i)**2 )
      tp%tpGeocLat(i) = Rad2Deg * ATAN (tp%tpECR(3,i) &
           / SQRT( tp%tpECR(1,i)**2 + tp%tpECR(2,i)**2))
    ENDDO

    ! Calculate dummy values

    DO i = 2, lenG
      tp%tpGeocAltRate(i-1) = (tp%tpGeocAlt(i) - tp%tpGeocAlt(i-1)) &
           / offsets(2)
      tp%tpGeodAltRate(i-1) = (tp%tpGeodAlt(i) - tp%tpGeodAlt(i-1)) &
           / offsets(2)
    ENDDO
    tp%tpGeocAltRate(lenG) = tp%tpGeocAltRate(lenG-1)
    tp%tpGeodAltRate(lenG) = tp%tpGeodAltRate(lenG-1)

    ! Determine Bright Object status:

    returnStatus = Pgs_csc_scToECI (spacecraftId, numValues, asciiUTC, &
      offsets, fov_sc, fov_eci)
    CALL Set_BO_stat (asciiUTC, offsets, BO_def, BO_angle, BO_Negate, FOV_eci, &
         los_vec, tp%tpGalLat, tp%tpGalLon, tp%tpBO_stat, MoonToSpaceAngle)

    IF (ANY (MIFbad)) THEN
       CALL Init_L1BOAtp (tp, MIFbad)
       PRINT *, 'some bad MIFs...'
    ENDIF

  END SUBROUTINE TkL1B_tp


  !------------------------------------------------- Tp_unit ---------
  SUBROUTINE Tp_unit (flagQ, lon, lat, alt, delta, unitQ, flag)
    ! This subroutine creates unit ECR vector quantities used by TkL1B_tp to
    ! calculate solarZenith and losAngle.

    ! Arguments
    INTEGER, INTENT(IN) :: flagQ
    REAL(r8), INTENT(IN) :: alt, delta, lat, lon
    INTEGER, INTENT(OUT) :: flag
    REAL(r8), INTENT(OUT) :: unitQ(3)

    ! Functions
    INTEGER :: Pgs_csc_geoToECR

    ! Variables
    CHARACTER (LEN=32) :: mnemonic
    CHARACTER (LEN=480) :: msg, msr
    INTEGER :: returnStatus
    REAL(r8) :: del, geoMinus, geoPlus
    REAL(r8) :: ecrMinus(3), ecrPlus(3), vec(3), vecSqrtSum

    ! Exectuable code

    flag = 0

    ! Create unit vector
    IF (flagQ == 2) THEN
      ! longitude
      del = delta * Deg2Rad
      geoPlus  = (lon + del/2)
      geoMinus = (lon - del/2)
      IF (geoPlus  >  PI) geoPlus  = geoPlus  - 2*PI
      IF (geoMinus < -PI) geoMinus = geoMinus + 2*PI
      returnStatus = Pgs_csc_geoToECR (geoPlus, lat, alt, earthModel, &
           ecrPlus)
      returnStatus = Pgs_csc_geoToECR (geoMinus, lat, alt, earthModel, &
           ecrMinus)
    ELSE IF (flagQ == 1) THEN
      ! latitude
      del = delta * Deg2Rad
      geoPlus  = (lat + del/2)
      geoMinus = (lat - del/2)
      returnStatus = Pgs_csc_geoToECR (lon, geoPlus, alt, earthModel, &
           ecrPlus)
      returnStatus = Pgs_csc_geoToECR (lon, geoMinus, alt, earthModel, &
           ecrMinus)
    ELSE
      geoPlus  = (alt + delta/2)
      geoMinus = (alt - delta/2)
      returnStatus = Pgs_csc_geoToECR (lon, lat, geoPlus, earthModel, &
           ecrPlus)
      returnStatus = Pgs_csc_geoToECR (lon, lat, geoMinus, earthModel, &
           ecrMinus)
    ENDIF

    IF (returnStatus /= PGS_S_SUCCESS) THEN
       CALL Pgs_smf_getMsg (returnStatus, mnemonic, msg)
       msr = mnemonic //':  '//msg
       CALL MLSMessage (MLSMSG_Warning, ModuleName, msr)
       PRINT *,TRIM(msr)
       flag = -1
    ENDIF

    vec = ecrPlus - ecrMinus
    vecSqrtSum = SQRT (vec(1)**2 + vec(2)**2 + vec(3)**2)
    IF (vecSqrtSum > 0.0) THEN
       unitQ = vec / vecSqrtSum
    ELSE
       unitQ = 0.0
    ENDIF

  END SUBROUTINE Tp_unit

  !-------------------------------------------------- L1BOA_MAF ----------------
  SUBROUTINE L1BOA_MAF (altG, altT, ascTAI, counterMAF, dscTAI, L1FileHandle, &
       MAFinfo, noMAF, MIFsPerMAF, numOrb, scAngleG, scAngleT, encAngleG, &
       encAngleT, APE_pos_P, TSSM_pos_P)

    ! This subroutine creates the SIDS L1BOA MAF records, and writes them to an
    ! HDF output file.

    USE MLSL1Config, ONLY: L1Config
    USE FOV, ONLY: GroundToFlightMountsGHz, GroundToFlightMountsTHz, &
         ScToGroundMountsGHz,ScToGroundMountsTHz
    USE BrightObjects_m, ONLY: BO_NumGHz, BO_NumTHz, BO_Index_GHz, &
         BO_Index_THz, BO_Angle_GHz, BO_Angle_THz, BO_Negate_GHz, BO_Negate_THz

    ! Arguments
    TYPE (MAFinfo_T) :: MAFinfo
    INTEGER, INTENT(IN) :: L1FileHandle, counterMAF, noMAF, numOrb, MIFsPerMAF
    REAL, INTENT(INOUT) :: scAngleG(:), scAngleT(:)
    REAL, INTENT(IN) :: encAngleG(:), encAngleT(:)  ! encoder Angles
    REAL, DIMENSION(:,:), INTENT(IN) :: APE_pos_P(2,*), TSSM_pos_P(2,*)
    REAL(r8), INTENT(IN) :: altG, altT
    REAL(r8), INTENT(IN) :: ascTAI(:), dscTAI(:)

    ! Functions
    INTEGER :: Pgs_td_taiToUTC

    ! Variables
    TYPE (L1BOAindex_T), SAVE :: index
    TYPE (L1BOAsc_T), SAVE :: sc
    TYPE (L1BOAtp_T), SAVE :: tp
    CHARACTER (LEN=27) :: mafTime
    CHARACTER (LEN=480) :: msr
    INTEGER :: error, i, nV, returnStatus, oastat, gtindx
    REAL(r8) :: mafTAI
    REAL(r8) :: initRay(3), q(3,MAFinfo%MIFsPerMAF)
    REAL(r8) :: offsets(MAFinfo%MIFsPerMAF)
    REAL :: angle_del
    REAL :: ecrtosc(3,3,MAFinfo%MIFsPerMAF)

    ! Calculate time (secs) offsets array

    mafTAI = MAFinfo%startTAI
    nV = MAFinfo%MIFsPerMAF
    DO i = 1, nV 
      offsets(i) = (i-1)*MAFinfo%MIF_dur
    ENDDO

    ! Write "index" information

    returnStatus = Pgs_td_taiToUTC (mafTAI, mafTime)
    index%MAFStartTimeUTC = mafTime
    index%MAFStartTimeTAI = mafTAI
    index%noMIFs = MIFsPerMAF
    index%counterMAF = counterMAF

    CALL OutputL1B_index (noMAF, L1FileHandle, index)

    ! Allocate the MIF variables in the output structures

    IF (.NOT. ASSOCIATED(sc%MIF_TAI)) THEN
       ALLOCATE (sc%MIF_TAI(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  MIF_TAI quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scGeocAlt)) THEN
       ALLOCATE (sc%scGeocAlt(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c  GeocAlt quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scGeocLat)) THEN
       ALLOCATE (sc%scGeocLat(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c  GeocLat quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scGeodAlt)) THEN
       ALLOCATE (sc%scGeodAlt(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c  GeodAlt quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scGeodLat)) THEN
       ALLOCATE (sc%scGeodLat(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c GeodLat  quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scLon)) THEN
       ALLOCATE (sc%scLon(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c Lon quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scGeodAngle)) THEN
       ALLOCATE (sc%scGeodAngle(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c GeodAngle quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scOrbIncl)) THEN
       ALLOCATE (sc%scOrbIncl(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c OrbIncl quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%encoderAngle)) THEN
       ALLOCATE (tp%encoderAngle(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  tp encoder angle quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%scAngle)) THEN
       ALLOCATE (tp%scAngle(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  tp angle quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%scanAngle)) THEN
       ALLOCATE (tp%scanAngle(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  tp scan angle quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%azimAngle)) THEN
       ALLOCATE (tp%azimAngle(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  tp azim angle quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%scanRate)) THEN
       ALLOCATE (tp%scanRate(nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  tp scan rate quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scECI)) THEN
       ALLOCATE (sc%scECI(lenCoord,nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c ECI quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scECR)) THEN
       ALLOCATE (sc%scECR(lenCoord,nV), STAT=error) 
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c ECR quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scVelECI)) THEN
       ALLOCATE (sc%scVelECI(lenCoord,nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c VelECI quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%scVelECR)) THEN
       ALLOCATE (sc%scVelECR(lenCoord,nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c VelECR quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%ypr)) THEN
       ALLOCATE (sc%ypr(lenCoord,nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c ypr quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(sc%yprRate)) THEN
       ALLOCATE (sc%yprRate(lenCoord,nV), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  s/c ypr rate quantities.'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    ! Get oa data

    CALL TkL1B_sc (nV, offsets, mafTime, mafTAI, sc, ecrtosc, oastat)

    IF (oastat == PGS_S_SUCCESS) THEN

    ! Get s/c master coordinate

       CALL Mc_aux (mafTime, offsets, sc%scECR, q)

       CALL TkL1B_mc (ascTAI, dscTAI, sc%scECR, nV, numOrb,  q, mafTAI, &
            offsets, sc%scECR, sc%scVelECR, sc%scOrbIncl, sc%scGeodAngle)

       scGeodAngle = Deg2Rad * sc%scGeodAngle(1)   ! save 1st scGeodAngle

    ENDIF

    ! Write s/c information

    CALL OutputL1B_sc (noMAF, L1FileHandle, sc)

    ! Allocate the output structure

    IF (.NOT. ASSOCIATED(tp%tpECI)) THEN
       ALLOCATE (tp%tpECI(lenCoord,lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: ECI'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpECR)) THEN
       ALLOCATE (tp%tpECR(lenCoord,lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: ECR'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpECRtoFOV)) THEN
       ALLOCATE (tp%tpECRtoFOV(lenCoord*lenCoord,lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: ECRtoFOV'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpPos_P)) THEN
       ALLOCATE (tp%tpPos_P(2,lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: Pos_P'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpOrbY)) THEN
       ALLOCATE (tp%tpOrbY(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: OrbY'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpGeocAlt)) THEN
       ALLOCATE (tp%tpGeocAlt(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: GeocAlt'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpGeocLat)) THEN
       ALLOCATE (tp%tpGeocLat(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: GeocLat'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpGeocAltRate)) THEN
       ALLOCATE (tp%tpGeocAltRate(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: GeocAltRate'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpGeodAlt)) THEN
       ALLOCATE (tp%tpGeodAlt(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: GeodAlt'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpGeodAltX)) THEN   ! GeodAlt extension MIFs 125-147
       ALLOCATE (tp%tpGeodAltX(148-lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: GeodAltX'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpGeodLat)) THEN
       ALLOCATE (tp%tpGeodLat(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: GeodLat'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpGeodAltRate)) THEN
       ALLOCATE (tp%tpGeodAltRate(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: GeodAltRate'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpLon)) THEN
       ALLOCATE (tp%tpLon(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: Lon'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpGeodAngle)) THEN
       ALLOCATE (tp%tpGeodAngle(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: GeodAngle'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpSolarTime)) THEN
       ALLOCATE (tp%tpSolarTime(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: SolarTime'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpSolarZenith)) THEN
       ALLOCATE (tp%tpSolarZenith(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: SolarZenith'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpLosAngle)) THEN
       ALLOCATE (tp%tpLosAngle(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: LosAngle'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpLosVel)) THEN
       ALLOCATE (tp%tpLosVel(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: LosVel'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpBO_stat)) THEN
       ALLOCATE (tp%tpBO_stat(nv), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: BO_stat'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpGalLat)) THEN
       ALLOCATE (tp%tpGalLat(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: GalLat'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (.NOT. ASSOCIATED(tp%tpGalLon)) THEN
       ALLOCATE (tp%tpGalLon(lenG), STAT=error)
       IF (error /= 0) THEN
          msr = MLSMSG_Allocate // '  GHz tp quantities: GalLon'
          CALL MLSMessage (MLSMSG_Error, ModuleName, msr)
       ENDIF
    ENDIF

    IF (oastat == PGS_S_SUCCESS) THEN

    ! Calculate initial guess for look vector in ECR

    CALL Scan_guess (mafTime, initRay)

    ! Find angle, tan pt for start of GHZ scan

    CALL Scan_start (altG, sc%scECR(:,1), mafTime, initRay, tp%scAngle(1) )

    ! Calculate GHZ tan pt record

    gtindx = 1
    CALL TkL1B_tp (mafTAI, mafTime, lenG, nV, offsets, sc%scECR, &
         sc%scECI, sc%scVelECI, scAngleG, encAngleG, tp, &
         ecrtosc, GroundToFlightMountsGHz, ScToGroundMountsGHz, &
         BO_Index_GHz(1:BO_NumGHz), BO_Angle_GHz, BO_Negate_GHz, gtindx, &
         L1Config%Calib%MoonToSpaceAngle)

    IF (L1Config%Globals%SimOA) THEN   ! correct nominal scan angles for sim
       angle_del = tp%tpGeodAlt(1) / 5200.0 * 0.1
       scAngleG = scAngleG + angle_del
       CALL TkL1B_tp (mafTAI, mafTime, lenG, nV, offsets, sc%scECR, &
            sc%scECI, sc%scVelECI, scAngleG, encAngleG, &
            tp, ecrtosc, GroundToFlightMountsGHz, ScToGroundMountsGHz, &
            BO_Index_GHz(1:BO_NumGHz), BO_Angle_GHz, BO_Negate_GHz, gtindx)
       angle_del = tp%tpGeodAlt(1) / 5200.0 * 0.1
       scAngleG = scAngleG + angle_del
       CALL TkL1B_tp (mafTAI, mafTime, lenG, nV, offsets, sc%scECR, &
            sc%scECI, sc%scVelECI, scAngleG, encAngleG, &
            tp, ecrtosc, GroundToFlightMountsGHz, ScToGroundMountsGHz, &
            BO_Index_GHz(1:BO_NumGHz), BO_Angle_GHz, BO_negate_GHz, gtindx)
    ENDIF

    ! Compute GHz master coordinate

    CALL TkL1B_mc (ascTAI, dscTAI, tp%tpECR, lenG, numOrb, q, mafTAI, &
         offsets(1:lenG), sc%scECR, sc%scVelECR, sc%scOrbIncl, tp%tpGeodAngle)

    ! Save info for baseline corrections

    GHz_GeodAlt = tp%tpGeodAlt
    GHz_GeodLat = tp%tpGeodLat
    GHz_GeodAngle = tp%tpGeodAngle

    ! Save for Bright Object testing:

    GHz_BO_stat = tp%tpBO_stat(1:lenG)

    ! Save pos1/pos2 prime data:

    tp%tpPos_P = APE_pos_P(:,1:lenG)

    ELSE

       CALL Init_L1BOAtp (tp)

    ENDIF

    ! Write GHz information

    CALL OutputL1B_GHz (noMAF, L1FileHandle, tp)

    IF (oastat == PGS_S_SUCCESS) THEN

    ! Find angle, tan pt for start of THz scan

    CALL Scan_start (altT, sc%scECR(:,1), mafTime, initRay, tp%scAngle(1))

    ! Calculate THz tan pt record

    gtindx = 2
    CALL TkL1B_tp (mafTAI, mafTime, lenT, nV, offsets, sc%scECR, &
         sc%scECI, sc%scVelECI, scAngleT, encAngleT, tp, &
         ecrtosc, GroundToFlightMountsTHz, ScToGroundMountsTHz, &
         BO_Index_THz(1:BO_NumTHz), BO_Angle_THz, BO_Negate_THz, gtindx)
    IF (L1Config%Globals%SimOA) THEN   ! correct nominal scan angles for sim
       angle_del = tp%tpGeodAlt(1) / 5200.0 * 0.1
       scAngleT = scAngleT + angle_del
       CALL TkL1B_tp (mafTAI, mafTime, lenT, nV, offsets, sc%scECR, &
            sc%scECI, sc%scVelECI, scAngleT, encAngleT, &
            tp, ecrtosc, GroundToFlightMountsTHz, ScToGroundMountsTHz, &
            BO_Index_THz(1:BO_NumTHz), BO_Angle_THz, BO_negate_THz, gtindx)
       angle_del = tp%tpGeodAlt(1) / 5200.0 * 0.1
       scAngleT = scAngleT + angle_del
       CALL TkL1B_tp (mafTAI, mafTime, lenG, nV, offsets, sc%scECR, &
            sc%scECI, sc%scVelECI, scAngleT, encAngleT, &
            tp, ecrtosc, GroundToFlightMountsTHz, ScToGroundMountsTHz, &
            BO_Index_THz(1:BO_NumTHz), BO_Angle_THz, BO_Negate_THz, gtindx)
    ENDIF

    ! Save pos1/pos2 prime data:

    tp%tpPos_P = TSSM_pos_P(:,1:lenG)

    ! Compute THz master coordinate

    CALL TkL1B_mc (ascTAI, dscTAI, tp%tpECR, lenG, numOrb, q, mafTAI, &
         offsets(1:lenG), sc%scECR, sc%scVelECR, sc%scOrbIncl, tp%tpGeodAngle)

    ! Write THZ information

    ELSE

       CALL Init_L1BOAtp (tp)

    ENDIF

    CALL OutputL1B_THz (noMAF, L1FileHandle, tp)

  END SUBROUTINE L1boa_MAF

  !------------------------------------------- Mc_Aux --------
  SUBROUTINE Mc_aux (asciiUTC, offsets, scECR, q)
    ! This subroutine computes q, an auxilliary vector used in the calculation
    ! of the master coordinate.  Q is a vector that points from the center of
    ! the Earth to the ascending node of the orbit in ECI coordinates.  Thus any
    ! point dotted with q can give you the master coordinate.
    ! Arguments
    CHARACTER (LEN=27), INTENT(IN) :: asciiUTC
    REAL(r8), INTENT(in) :: OFFSETS(:)
    REAL(r8), INTENT(IN) :: scECR(:,:)
    REAL(r8), INTENT(OUT) :: q(:,:)

    ! Parameters

    ! Functions
    INTEGER :: Pgs_csc_orbToECI, PGS_CSC_ECItoECR

    ! Variables
    INTEGER :: returnStatus
    INTEGER :: nV
    REAL(r8), DIMENSION(SIZE(offsets)) :: l
    REAL(r8), DIMENSION(SIZE(offsets)) :: DIST1
    REAL(r8), DIMENSION(SIZE(offsets)) :: DIST2
    REAL(r8), DIMENSION(3,SIZE(offsets)) :: AECR
    REAL(r8), DIMENSION(3,SIZE(offsets)) :: AUX1
    REAL(r8), DIMENSION(3,SIZE(offsets)) :: AUX2
    REAL(r8), DIMENSION(6,SIZE(offsets)) :: AUX1ECI
    REAL(r8), DIMENSION(6,SIZE(offsets)) :: AUX2ECI
    REAL(r8), DIMENSION(6,SIZE(offsets)) :: AUX1ECR
    REAL(r8), DIMENSION(6,SIZE(offsets)) :: AUX2ECR
    REAL(r8), DIMENSION(SIZE(offsets)) :: QSIZE
    LOGICAL, DIMENSION(SIZE(offsets)) :: SMALL1
    LOGICAL, DIMENSION(SIZE(offsets)) :: SMALL2

    ! Executable code
    nV = SIZE(offsets)

    ! Construct two auxilliary vectors -- the first pointing directly ahead 
    ! along the s/c orbit, and the second pointing 45 degrees downward.
    aux1(1,:) = 1.0
    aux1(2,:) = 0.0
    aux1(3,:) = 0.0
    aux2(1,:) = 1.0
    aux2(2,:) = 0.0
    aux2(3,:) = 1.0

    ! Transform the auxilliary vectors from orbital to ECI coordinates
    returnStatus = Pgs_csc_orbToECI (spacecraftId, nV, asciiUTC, &
      offsets, aux1, aux1ECI(1:3,:) )
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)
    returnStatus = Pgs_csc_orbToECI (spacecraftId, nV, asciiUTC, &
      offsets, aux2, aux2ECI(1:3,:) )
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)

    ! Transform again to ECI coordinates
    aux1ECI(4:6,:) = 0.0_r8
    aux2ECI(4:6,:) = 0.0_r8
    returnStatus = Pgs_csc_ECItoECR (nV, asciiUTC, offsets, aux1ECI, aux1ECR)
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)
    returnStatus = Pgs_csc_ECItoECR (nV, asciiUTC, offsets, aux2ECI, aux2ECR)
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)

    ! Define l & a, where l is the distance to the equator along the direction
    ! of one of the auxilliary vectors from the s/c, and a is the auxilliary
    ! vector for which l was defined.

    small1 = ABS (aux1ECR(3,:)) < SQRT (TINY(0.0_r8))
    small2 = ABS (aux2ECR(3,:)) < SQRT (TINY(0.0_r8))
    IF (ANY (small1 .AND. small2)) THEN
      CALL MLSMessage (MLSMSG_Error, ModuleName, &
           'Problem computing auxilliary vector for master coordinate')
    END IF

    WHERE ( small1 )
      ! If aux1 has a zero z-component, set l & a for aux2, if its z-component
      !  /= 0
      l = -scECR(3,:)/aux2ECR(3,:)
      aECR(1,:) = aux2ECR(1,:)
      aECR(2,:) = aux2ECR(2,:)
      aECR(3,:) = aux2ECR(3,:)
    ELSEWHERE ( small2 )
      ! If aux1(3) is not zero, but aux2(3) is, then set l & a for aux1
      l = -scECR(3,:)/aux1ECR(3,:)
      aECR(1,:) = aux1ECR(1,:)
      aECR(2,:) = aux1ECR(2,:)
      aECR(3,:) = aux1ECR(3,:)
    ELSEWHERE
      ! If both aux1(3) and aux2(3) are non-zero, choose the one which gives the
      ! minimum absolute value of l.
      dist1 = -scECR(3,:)/aux1ECR(3,:)
      dist2 = -scECR(3,:)/aux2ECR(3,:)
      WHERE ( ABS(dist1) < ABS(dist2) )
        l = dist1
        aECR(1,:) = aux1ECR(1,:)
        aECR(2,:) = aux1ECR(2,:)
        aECR(3,:) = aux1ECR(3,:)
      ELSEWHERE
        l = dist2
        aECR(1,:) = aux2ECR(1,:)
        aECR(2,:) = aux2ECR(2,:)
        aECR(3,:) = aux2ECR(3,:)
      END WHERE
    END WHERE

    ! Define the vector q = scECR + la, such that its z-component = 0
    q(1,:) = scECR(1,:) + l(:)*aECR(1,:)
    q(2,:) = scECR(2,:) + l(:)*aECR(2,:)
    q(3,:) = 0.0

    ! Modify q, depending on which hemisphere the s/c is in, and the sign of l
    WHERE (((scECR(3,:) < 0.0) .AND. (l < 0.0)) .OR. &
         ((scECR(3,:) >= 0.0) .AND. (l >= 0.0)))
      q(1,:) = -q(1,:)
      q(2,:) = -q(2,:)
    END WHERE 

    ! Normalize q
    qSize = SQRT (q(1,:)**2 + q(2,:)**2) 

    q(1,:) = q(1,:) / qSize(:)
    q(2,:) = q(2,:) / qSize(:)

  END SUBROUTINE Mc_aux

  !---------------------------------------orbInclineCalculated -----------------
  FUNCTION orbInclineCalculated (scECR, scVelECR , lambda, mu)
    ! This function computes the orbital inclination angle beta' in degrees
    ! where 90 would mean a perfectly polar orbit in ECR coordinates
    ! Method: let [r] be the vector of the s/c position (in ECR coords)
    ! i.e., [r] = (x, y, z)
    ! also [v] its instantaneous velocity, 
    ! and scalar values include lambda its geocentric latitude
    ! and mu its longitude
    ! then                         (vy cos[mu] - vx sin[mu]
    ! then sin_beta' = cos[lambda] ------------------------
    !                                         |v|
    ! Arguments
    REAL(r8), INTENT(IN) :: scECR(3)             ! s/c pos.
    REAL(r8), INTENT(IN) :: scVelECR(3)          ! s/c vel.
    REAL, INTENT(IN) ::     lambda               ! s/c geocentric latitude
    REAL, INTENT(IN) ::     mu                   ! s/c longitude
    REAL(r8) ::             orbInclineCalculated

    ! Variables
    LOGICAL, PARAMETER :: DEBUG = .FALSE.
    INTEGER, SAVE :: HOWMANYSOFAR=0
    REAL(r8) :: vUnrotated(3)          ! s/c vel.
    REAL(r8) :: v
    REAL :: muRad, lamRad

    ! Executable code
    HOWMANYSOFAR = HOWMANYSOFAR + 1
    vUnrotated(1) = scVelECR(1) - Omega*scECR(2)
    vUnrotated(2) = scVelECR(2) + Omega*scECR(1)
    vUnrotated(3) = scVelECR(3)
    v = SQRT( vUnrotated(1)**2 + vUnrotated(2)**2 + vUnrotated(3)**2 )
    lamRad = (Pi/180)*lambda
    muRad = (Pi/180)*mu
    IF (v == 0.d0) THEN
       orbInclineCalculated = UNDEFINED_VALUE
       RETURN
    ENDIF
    orbInclineCalculated = (180/Pi) * ASIN( &
        COS(lamRad) * (vUnrotated(2)*COS(muRad) - vUnrotated(1)*SIN(muRad)) / v)

    ! Now added contraints: 90 < beta < 180
    orbInclineCalculated = ABS(orbInclineCalculated) + 90
    IF (orbInclineCalculated < 90.d0) THEN
      orbInclineCalculated = 180. - orbInclineCalculated
    ELSEIF (orbInclineCalculated > 180.d0) THEN
      orbInclineCalculated = 360. - orbInclineCalculated
    ENDIF
    
    IF (DEBUG) THEN
      CALL output ('vx, vy, vz ', advance='no')
      CALL blanks (3, advance='no')
      CALL output (scVelECR, advance='yes')
      CALL output ('lambda ', advance='no')
      CALL blanks (3, advance='no')
      CALL output (lambda, advance='no')
      CALL blanks (3, advance='no')
      CALL output ('mu ', advance='no')
      CALL blanks (3, advance='no')
      CALL output (mu, advance='yes')
      CALL output ('orbital inclination ', advance='no')
      CALL blanks (3, advance='no')
      CALL output ((180/Pi) * ASIN( &
           COS(lamRad) * (vUnrotated(2)*COS(muRad) - vUnrotated(1)*SIN(muRad)) &
           / v), advance='no')
      CALL blanks (3, advance='no')
      CALL output (orbInclineCalculated, advance='yes')
      IF (HOWMANYSOFAR > 40 ) STOP
    ENDIF

  END FUNCTION orbInclineCalculated

  !----------------------------------------orbInclineCrossProd -----------------
  FUNCTION orbInclineCrossProd  (scECI, scVelECI)
    ! This function computes the orbital inclination angle beta in degrees
    ! where 90 would mean a perfectly polar orbit
    ! Method: let [r] be the vector of the s/c position (in ECI coords)
    ! i.e., [r] = (x, y, z)
    ! also [v] its instantaneous velocity, [omega] its orbital frequency,
    ! we'll calculate its orbital moment [m]: using 'x' as the cross-product
    ! Then [v] = [omega] x [r]
    ! [p] = [r] x [v] = [omega] r^2 - [r] [omega] . [r]
    ! and if [r] . [omega] = 0
    ! [omega] = [p] / r^2 = omega (sin_beta cos_alfa, sin_beta sin_alfa, 
    ! cos_beta)
    ! Arguments
    REAL(r8), INTENT(IN) :: scECI(3)             ! s/c pos.
    REAL(r8), INTENT(IN) :: scVelECI(3)          ! s/c vel.
    REAL(r8) :: orbInclineCrossProd

    ! Variables
    LOGICAL, PARAMETER :: DEBUG = .FALSE.
    INTEGER, SAVE :: HOWMANYSOFAR=0
    REAL(r8) :: orbMoment(3), OMagnitude

    ! Executable code
    HOWMANYSOFAR = HOWMANYSOFAR + 1
    orbMoment(1) = scECI(2)*scVelECI(3) - scECI(3)*scVelECI(2)
    orbMoment(2) = scECI(3)*scVelECI(1) - scECI(1)*scVelECI(3)
    orbMoment(3) = scECI(1)*scVelECI(2) - scECI(2)*scVelECI(1)
    OMagnitude = SQRT (orbMoment(1)**2 + orbMoment(2)**2 + orbMoment(3)**2)
    IF (OMagnitude == 0.d0) THEN
       orbInclineCrossProd = UNDEFINED_VALUE
       RETURN
    ENDIF
    orbInclineCrossProd = (180/Pi) * ACOS (MAX(MIN(orbMoment(3) / OMagnitude,&
     1.0d0),-1.0d0))

    ! Now added contraints: 90 < beta < 180
    orbInclineCrossProd = ABS(orbInclineCrossProd)
    IF (orbInclineCrossProd < 90.d0) THEN
       orbInclineCrossProd = 180. - orbInclineCrossProd
    ELSEIF (orbInclineCrossProd > 180.d0) THEN
       orbInclineCrossProd = 360. - orbInclineCrossProd
    ENDIF
    
    IF (DEBUG) THEN
       CALL output ('rx, ry, rz ', advance='no')
       CALL blanks (3, advance='no')
       CALL output (scECI, advance='yes')
       CALL output ('vx, vy, vz ', advance='no')
       CALL blanks (3, advance='no')
       CALL output (scVelECI, advance='yes')
       CALL output ('px, py, pz ', advance='no')
       CALL blanks (3, advance='no')
       CALL output (orbMoment, advance='yes')
       CALL output ('orbital inclination ', advance='no')
       CALL blanks (3, advance='no')
       CALL output ((180/Pi) * ACOS( orbMoment(3) / OMagnitude ), advance='no')
       CALL blanks (3, advance='no')
       CALL output (orbInclineCrossProd, advance='yes')
       IF (HOWMANYSOFAR > 40 ) STOP
    ENDIF

  END FUNCTION orbInclineCrossProd

  !---------------------------------------------------TkL1B_mc -----------------
  SUBROUTINE TkL1B_mc (ascTAI, dscTAI, dotVec, nV, numOrb, q, timeTAI, &
       time_offset, scECR, scVelECR, scOrbIncl, geodAngle)
    ! This subroutine computes phi, the master coordinate for the spacecraft and
    ! tangent point records.
    ! Arguments
    INTEGER, INTENT(IN) :: nV, numOrb
    REAL(r8), INTENT(IN) :: timeTAI
    REAL(r8), INTENT(IN) :: q(3,nV)
    REAL(r8), INTENT(IN) :: time_offset(nV)
    REAL(r8), INTENT(IN) :: ascTAI(:), dscTAI(:)
    REAL(r8), INTENT(IN) :: dotVec(3,nV), scECR(3,*), scVelECR(3,*)
    REAL, INTENT(IN) ::     scOrbIncl(nV)
    REAL, INTENT(OUT) ::    geodAngle(nV)

    ! Functions
    INTEGER :: Pgs_csc_getEarthFigure

    ! Variables
    INTEGER :: i, j, returnStatus, scOrb

    REAL(r8) :: a, asciiTAI, b, cSq, equatRad_a, orbRad, polarRad_c
    REAL(r8) :: cosPhi(nV), gamma(nV), phi(nV), sinPhi(nV)
    REAL(r8) :: s(3), velECR(3), qxnew, qynew, qnew(3), qnorm
    REAL(r8) :: orbInclineNow, DvecSqrtSum

    ! Constants:

    REAL(r8), PARAMETER :: vel_corr = 7.292115d-05

    ! Executable code

    ! Read a & b from earthfigure.dat
    returnStatus = Pgs_csc_getEarthFigure (earthModel, equatRad_a, polarRad_c)
    CALL ReportTKStatus (returnStatus, ModuleName, errmsg)
    a = equatRad_a/1000
    b = polarRad_c/1000

    ! Set s = normalized dotVec
    DO i = 1, nV

       orbInclineNow = scOrbIncl(i)
       IF (orbInclineNow == UNDEFINED_VALUE) THEN
          CALL MLSMessage (MLSMSG_Error, ModuleName, &
               'Error in calculating orbital inclination angle')
       ENDIF

       ! Get a unit ECR vector to the point.
       DvecSqrtSum = SQRT(dotVec(1,i)**2 + dotVec(2,i)**2 + &
            dotVec(3,i)**2)
       IF (DvecSqrtSum == 0.0) THEN
          phi(i) = UNDEFINED_VALUE / Rad2Deg
          CYCLE
       ENDIF
       s = dotVec(:,i) / DvecSqrtSum

       ! Determine a "new" Q value:

       velECR = vel_corr * (/ -scECR(2,i), scECR(1,i), 0.0d0 /) + &
            scVelECR(:,i)
       qxnew = dotVec(1,i) * velECR(3) - dotVec(3,i) * velECR(1)
       qynew = dotVec(2,i) * velECR(3) - dotVec(3,i) * velECR(2)
       qnorm = sqrt (qxnew**2 + qynew**2)
       qnew = (/ qxnew/qnorm, qynew/qnorm, 0.0d0 /)

       ! Calculate the geocentric angle as a number of radians between 0 and PI
       !gamma(i) = ACOS(MAX(MIN((q(1,i)*s(1) + q(2,i)*s(2)), 1.0d0),-1.0d0))
       gamma(i) = ACOS(MAX(MIN((qnew(1)*s(1) + qnew(2)*s(2)), 1.0d0),-1.0d0))

       ! Place angle between PI and 2*PI, if in Southern Hemisphere
       IF (dotVec(3,i) < 0.0 ) gamma(i) = 2*PI - gamma(i)

       ! Going to convert this to geodetic, calculate som parameters.
       orbRad= Deg2Rad * (orbInclineNow - 90)
       cSq = (1 + (TAN(orbRad)**2)) * (a**2)*(b**2) / &
            (a**2 + (b**2)*(TAN(orbRad)**2))

       ! If |gamma| <= 45 deg of the equator, calculate phi using the SIN !
       ! equation
       IF ((gamma(i) <= PI/4 ) .OR. ( (gamma(i) >= 3*PI/4) .AND. &
            (gamma(i) <= 5*PI/4) ) .OR. (gamma(i) >= 7*PI/4)) THEN
          sinPhi(i) = SQRT( (a**4)*(SIN(gamma(i))**2)/( (cSq**2)* &
               (COS(gamma(i))**2) + (a**4)*(SIN(gamma(i))**2) ) )
          phi(i) = ASIN(sinPhi(i))
       ELSE
          ! If gamma is within 45 deg of a pole, calculate phi using the COS 
          ! equation
          cosPhi(i) = SQRT( (cSq**2)*(COS(gamma(i))**2)/( (cSq**2)* &
               COS(gamma(i))**2 + (a**4)*(SIN(gamma(i))**2) ) )
          phi(i) = ACOS(MAX(MIN(cosPhi(i), 1.0d0), -1.0d0))
       ENDIF

       ! Place phi in same quadrant as gamma
       IF ((gamma(i) > PI/2) .AND. (gamma(i) <= PI)) phi(i) = PI - phi(i)
       IF ((gamma(i) > PI) .AND. (gamma(i) <= 3*PI/2)) phi(i) = phi(i) + PI
       IF (gamma(i) > 3*PI/2) phi(i) = 2*PI - phi(i)

       ! Make phi cumulative over orbits
       ! First what is the time?
       asciiTAI = timeTAI + time_offset(i)
       scOrb = 0

       ! Now always make our calculation based on some threshold way back in
       ! time, to avoid any ambiguity
       IF ((phi(i) < pi/2) .OR. (phi(i) >= 3*pi/2)) THEN
          ! If in the ascending part of the orbit, base correction
          ! on time of last descending node
          ! MAKE THIS USE HUNT LATER!
          DO j = 1, numOrb
             IF (asciiTAI > dscTAI(j)) scOrb = j
          ENDDO

          ! If we're in the NH we've begun a new orbit, so add one
          IF (phi(i) < pi) scOrb = scOrb + 1
       ELSE
          ! If in descending part of the orbit, base it on the time
          ! of the last ascending node
          ! MAKE THIS USE HUNT LATER!
          DO j = 1, numOrb
             IF (asciiTAI > ascTAI(j)) scOrb = j
          ENDDO

       END IF
       phi(i) = (scOrb-2)*2*PI + phi(i)

    ENDDO

    ! Convert to degrees for output
    geodAngle = Rad2Deg * phi

  END SUBROUTINE TkL1B_mc

!=============================================================================
  SUBROUTINE Set_BO_stat (asciiUTC, offset, BO_def, BO_angle, BO_Negate, &
       FOV_eci, los_FOV, galLat, galLon, BO_stat, MoonToSpaceAngle)
!=============================================================================

    USE BrightObjects_m, ONLY: GC_def

    CHARACTER (LEN=27), INTENT(in) :: asciiUTC
    REAL(r8), INTENT(in) :: offset(:), FOV_eci(3,0:(MAFinfo%MIFsPerMAF-1)), &
         los_FOV(3,0:(lenG-1))
    REAL, INTENT(in) :: BO_angle(:) !ScAngle(0:)
    REAL, INTENT(in), OPTIONAL :: MoonToSpaceAngle
    INTEGER, INTENT(in) :: BO_def(:)
    LOGICAL, INTENT(in) :: BO_Negate(:)
    INTEGER, INTENT(out) :: BO_stat(0:)
    REAL, INTENT(out) :: galLat(0:), galLon(0:)

    INTEGER :: i, j, MIF, returnStatus, nv
    REAL :: limb_angle, space_angle
    REAL(r8) :: sc_frame_vector(3,0:(MAFinfo%MIFsPerMAF-1)), &
         sc_unit_vector(3,0:(MAFinfo%MIFsPerMAF-1)), &
         eci_unit_vector(3,0:(MAFinfo%MIFsPerMAF-1))
    LOGICAL :: HasSpaceView

! Galactic center variables:

    INTEGER, PARAMETER :: Ngal = 5
    REAL(r8) :: FOV_gal(3), thetasum, deltacross, deltadot

    REAL(r8), PARAMETER :: ECItogctr(3,3) = RESHAPE ((/ &
         -0.066990,  0.492699, -0.867620, &
         -0.872758, -0.450355, -0.188358, &
         -0.483540,  0.744601,  0.460174 /), (/ 3, 3 /))

    REAL(r8), PARAMETER :: gal_cone_z = 0.765687153 ! 40.03183702 bounding cone
    REAL(r8), PARAMETER :: gal_fan_y = 0.032 ! Gal.Latitude fan half-width,
                                             ! radians

! Strawman polygon for galactic core  REC 2005.11.09
! x unused:
! revised polygon for galactic core  REC 2005.11.18
! revised polygon for galactic core  REC 2007.06.21 !
! revised polygon for galactic core  REC 2009.03.31: rectangle, per H.Pumphrey
!  telecon messci_080603.pdf

    REAL(r8), PARAMETER :: gal(2:3,Ngal) = RESHAPE ((/ &
         -0.573309, -0.030539, & !0.818770 !
         -0.573555,  0.008727, & !0.819121 !
          0.642763,  0.008727, & !0.766015 !
          0.642488, -0.030539, & !0.765687 !
         -0.573309, -0.030539  & !0.818770 !
          /), (/ 2, Ngal /))

    ! Functions

    INTEGER, EXTERNAL :: PGS_CBP_Sat_CB_Vector, PGS_CSC_SCtoECI

    HasSpaceView = PRESENT (MoonToSpaceAngle)
    nv = MAFinfo%MIFsPerMAF

    BO_stat = 0   ! Nothing in FOV

    DO i = 1, SIZE (BO_def)   ! For each Bright Object

       IF (BO_def(i) /= GC_def) THEN    ! Not Galactic Center BO
          returnStatus = PGS_CBP_Sat_CB_Vector (spacecraftId, nv, asciiUTC, &
               offset(1:nv), BO_def(i), sc_frame_vector)
          IF (returnStatus /= 0) CYCLE
 
          DO MIF = 0, (nv - 1)
             sc_unit_vector(:,MIF) = sc_frame_vector(:,MIF) / &
                  SQRT (sc_frame_vector(1,MIF)**2 + sc_frame_vector(2,MIF)**2 &
                  + sc_frame_vector(3,MIF)**2)
          ENDDO

          returnStatus = PGS_CSC_SCtoECI (spacecraftId, nv, asciiUTC, &
               offset(1:nv), sc_unit_vector, eci_unit_vector)

       ENDIF

       DO MIF = 0, (nv - 1)

    ! Limb port angle check

          IF (BO_def(i) /= GC_def) THEN    ! Not Galactic Center BO

             limb_angle = ACOS (MAX (MIN ( DOT_PRODUCT( &
                  FOV_eci(:,MIF), eci_unit_vector(:,MIF)), 1.0d0), -1.0d0)) * &
                  Rad2Deg

             IF (limb_angle < BO_angle(BO_def(i))) THEN ! Set appropriate Bit No
                BO_stat(MIF) = IBSET (BO_stat(MIF), BO_def(i))
                IF (BO_Negate(i)) &
                     BO_stat(MIF) = IBSET (BO_stat(MIF), (BO_def(i)+16))
             ENDIF

          ELSE ! Check for Galactic center (if requested):

             FOV_gal = MATMUL (ECItogctr, FOV_eci(:,MIF))
             thetasum = 0.0

             IF ((FOV_gal(1) > gal_cone_z) .AND. &
                 (ABS(FOV_gal(3)) < gal_fan_y)) THEN ! Look within bounding cone 

                DO j = 2, Ngal  !  Loop over vertices defining galactic core
                   deltacross = (gal(3,j)-FOV_gal(3))*(gal(2,j-1)-FOV_gal(2)) &
                        -(gal(2,j)-FOV_gal(2))*(gal(3,j-1)-FOV_gal(3))
                   deltadot = (gal(2,j)-FOV_gal(2))*(gal(2,j-1)-FOV_gal(2)) &
                        +(gal(3,j)-FOV_gal(3))*(gal(3,j-1)-FOV_gal(3))

                   thetasum = thetasum + ATAN2(deltacross, deltadot)

                ENDDO

                IF (ABS(thetasum) > PI) THEN  ! Mark galactic center in this MIF
                   BO_stat(MIF) = IBSET (BO_stat(MIF), GC_def)
                ENDIF

             ENDIF
          ENDIF

! Space port angle check (for Moon Only!)

          IF (HasSpaceView .AND. BO_def(i) == PGSd_Moon) THEN

             space_angle = ACOS (MAX (MIN (sc_unit_vector(2,MIF), 1.0d0), &
                  -1.0d0)) * Rad2Deg  ! Y vector
             IF (space_angle < MoonToSpaceAngle) THEN  ! Set bit 0
                BO_stat(MIF) = IBSET (BO_stat(MIF), 0)
             ENDIF
          ENDIF

       ENDDO
   ENDDO

! Calculate galactic center Lat/Long:

   do MIF = 0, (lenG - 1)
 
      FOV_gal = MATMUL (ECItogctr, los_FOV(:,MIF))
      GalLat(MIF) = ASIN (MAX (MIN (FOV_gal(3), 1.0d0), -1.0d0)) * Rad2Deg
      GalLon(MIF) = ATAN2 (FOV_gal(2), FOV_gal(1)) * Rad2Deg
 
   enddo

  END SUBROUTINE Set_BO_stat

  LOGICAL FUNCTION not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (len=*), PARAMETER :: IdParm = &
       "$Id: TkL1B.f90,v 2.38 2016/03/15 22:17:59 whdaffer Exp $"
  CHARACTER (len=LEN(idParm)), SAVE :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  END FUNCTION not_used_here

END MODULE TkL1B

! $Log: TkL1B.f90,v $
! Revision 2.38  2016/03/15 22:17:59  whdaffer
! Merged whd-rel-1-0 back onto main branch. Most changes
! are to comments, but there's some modification to Calibration.f90
! and MLSL1Common to support some new modules: MLSL1Debug and SnoopMLSL1.
!
! Revision 2.37.4.2  2016/03/03 18:54:53  whdaffer
! Comments, reformated some calls to make the code more readible
!
! Revision 2.37.4.1  2015/10/09 10:21:38  whdaffer
! checkin of continuing work on branch whd-rel-1-0
!
! Revision 2.37  2015/01/23 17:50:17  pwagner
! SDPToolkit indispensible for level 1; why not use it instead of Constants?
!
! Revision 2.36  2015/01/22 23:34:04  vsnyder
! Get constants from Constants module instead of SDPToolkit
!
! Revision 2.35  2009/07/28 18:08:11  perun
! New calculation for geodangle
!
! Revision 2.34  2009/06/01 14:01:18  perun
! Update galactic center polygon and save appropriate lat/longs
!
! Revision 2.33  2007/06/27 14:45:30  perun
! Revised vertices of the galactic center polygon
!
! Revision 2.32  2007/04/05 13:59:27  perun
! Protect every ACOS call from crashes
!
! Revision 2.31  2006/06/14 13:50:02  perun
! Save spacecraft Geod Angle to use for stray radiance estimations
!
! Revision 2.30  2006/04/05 18:09:58  perun
! Remove unused variables
!
! Revision 2.29  2006/03/24 15:21:17  perun
! Resized tp arrays to numValues from lenG and add GeodAltX calculation
!
! Revision 2.28  2005/12/14 17:01:21  perun
! Incorporate ReportTKStatus call for reporting errors
!
! Revision 2.27  2005/12/06 19:30:42  perun
! Removed Flag_Bright_Objects routine and added determining BO_stat bits
!
! Revision 2.26  2005/10/11 16:08:50  perun
! Replace local mean time with local apparent time for SolarTime
!
! Revision 2.25  2005/08/24 15:53:43  perun
! Allocate and save pos1/pos2 prime data in the tangent point structures
!
! Revision 2.24  2005/07/19 16:34:46  perun
! Added SAVE to sc and tp structures to prevent memory leaks
!
! Revision 2.23  2005/06/23 18:41:36  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.22  2005/02/14 19:30:48  perun
! Protect acos/asin from crashing.
!
! Revision 2.21  2005/01/28 17:04:05  perun
! Pass in MoonToLimb tolerance instead of getting it from L1Config
!
! Revision 2.20  2005/01/25 18:01:06  perun
! Calculate tangent point scan rates (deg/sec)
!
! Revision 2.19  2004/11/10 15:32:05  perun
! Add encoder values; latest FOVs; correct YPR values order
!
! Revision 2.18  2004/08/12 13:51:51  perun
! Version 1.44 commit
!
! Revision 2.17  2004/08/03 20:41:14  pwagner
! Gets DEFAULTUNDEFINEDVALUE from MLSCommon
!
! Revision 2.16  2004/05/14 15:59:11  perun
! Version 1.43 commit
!
! Revision 2.15  2004/01/09 17:46:23  perun
! Version 1.4 commit
!
! Revision 2.14  2003/09/15 21:50:04  pwagner
! Removed illegal midline continuation--Lahey disapproves
! 
! Revision 2.13  2003/09/15 17:15:54  perun
! Version 1.3 commit
!
! Revision 2.12  2003/08/15 14:25:04  perun
! Version 1.2 commit
!
! Revision 2.11  2002/11/07 21:56:20  jdone
! Added Level 1 output datatypes.
!
! Revision 2.10  2002/09/26 20:52:26  vsnyder
! Get Omega from Geometry instead of Units
!
! Revision 2.9  2002/03/29 20:18:34  perun
! Version 1.0 commit
!
! Revision 2.8  2001/12/14 01:43:46  livesey
! Working version with ECR based master coordinate
!
! Revision 2.7  2001/12/12 19:05:44  livesey
! Fixed bug with master coordinate for very low latitudes.
! However, this version it turns out is basing master coordinate
! on the ECI orbital node, not ECR which I think is what we really
! want. So expect another version soon!
!
! Revision 2.6  2001/12/12 03:07:32  livesey
! Interim version needs debugging more
!
! Revision 2.5  2001/12/11 00:55:51  livesey
! Slightly kludgy fix for problem where occasionally gets
! phi 180 degrees out.
!
! Revision 2.4  2001/12/07 00:51:44  pwagner
! Finally calculates scOrbIncl correctly
!
! Revision 2.3  2001/12/06 01:03:46  pwagner
! Now writes orbit incline angle in ECR
!
! Revision 2.2  2001/10/12 22:11:05  livesey
! Tidied things up a bit, added scVelECR, but not filled yet
!
! Revision 2.1  2001/02/23 18:26:11  perun
! Version 0.5 commit
!
! Revision 2.0  2000/09/05 18:55:15  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.2  2000/02/15 18:48:37  nakamura
! Absorbed module Mc; moved _init subroutine to Orbit; account for parametrization of lenG & lenT.
!
@


2.38
log
@Merged whd-rel-1-0 back onto main branch. Most changes
are to comments, but there's some modification to Calibration.f90
and MLSL1Common to support some new modules: MLSL1Debug and SnoopMLSL1.
@
text
@d507 3
d1732 1
a1732 1
       "$Id: TkL1B.f90,v 2.37.4.2 2016/03/03 18:54:53 whdaffer Exp $"
d1741 5
@


2.37
log
@SDPToolkit indispensible for level 1; why not use it instead of Constants?
@
text
@d14 4
d120 3
d132 1
a132 1
    ! Functions
d146 6
a151 4
    REAL(r8), PARAMETER :: SCtoGHz(3,3) = RESHAPE ((/ &
         -0.0000086, -0.4260405, 0.9047041, &
          1.0000000,  0.0000000, 0.0000095, &
         -0.0000041,  0.9047041, 0.4260405 /), (/ 3, 3 /))
d158 3
a160 2
         offsets, pgs_true, pgs_true, qualityFlags, sc%scECI, sc%scVelECI, &
         eulerangles, sc%yprRate, attitQuat)
d164 12
d217 3
a219 3
    sctoeci(1, 1::3) = w**2 + x**2 - y**2 -z**2
    sctoeci(2, 2::3) = w**2 - x**2 + y**2 -z**2
    sctoeci(3, 3::3) = w**2 - x**2 - y**2 +z**2
d289 3
a291 2
    REAL(r8), INTENT(IN) :: posECR(3,numValues), posECI(3,numValues), &
         velECI(3,numValues)
d331 7
d340 1
d343 25
a367 16
       CALL CalcMountsToFOV (scAngle(i), gtindx, MountsToFOV)

       GroundMountsToFOV = MATMUL (MountsToFOV, GroundToFlightMounts)
       ScToFOV = MATMUL (GroundMountsToFOV, ScToGroundMounts)
       ECRtoFOV = MATMUL (ScToFOV, ecrtosc(:,:,i))

       IF (i <= lenG) tp%tpECRtoFOV(:,i) = RESHAPE (ECRtoFOV, (/ 9 /))
       
       fov_sc(1,i) = ScToFOV(3,1)
       fov_sc(2,i) = ScToFOV(3,2)
       fov_sc(3,i) = ScToFOV(3,3)

    ! Put sc angle

       tp%scAngle(i) = 90.0 - &
            ACOS (MAX (MIN(fov_sc(3,i), 1.0d0), -1.0d0)) * Rad2Deg
d371 6
d395 5
d418 6
d463 9
d475 6
a480 3
      flagQ = 1
      CALL Tp_unit (flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaLat, &
           unitLat(:,i), flag)
d484 6
d599 1
d657 1
a657 1
       msr = mnemonic // ':  ' // msg
d659 1
d1093 1
d1729 1
a1729 1
       "$Id: TkL1B.f90,v 2.36 2015/01/22 23:34:04 vsnyder Exp $"
d1738 9
@


2.37.4.1
log
@checkin of continuing work on branch whd-rel-1-0
@
text
@a13 4
  ! This module contains subroutines for producing the L1BOA records on
  ! a MAF by MAF basis.


a153 12
    ! <whd> 
    ! 
    ! Does this mean that AURAs euler angle order is yaw, roll,
    ! pitch?, i.e. 3,1,2?  Yes, looking at an Attitude file (in
    ! /data/Aura/attitude/year/doy/AURAATTH...) the Vdata Attitude
    ! Header reports the Euler Angle order is 3.1.2
    ! 
    ! It doesn't appear that euler angle is used for anything, it's
    ! just passed along to the output L1BOA file.
    ! 
    ! </whd>

d267 2
a268 3
    REAL(r8), INTENT(IN) :: posECR(3,numValues), &
         &                  posECI(3,numValues), &
         &                  velECI(3,numValues)
d308 3
d312 1
a312 5
    !! <whd> Everything labled `fov_sc' is the line-of-sight of the
    !! instrument.  I think that `_sc' is really in the instrument
    !! coordinate system, rather than the 'sc' (spacecraft) coordinate
    !! system. The S/C coordinate system is labeled fov_orb
    !! below. </whd>
d314 9
a322 1
    ! Determine ECR to FOV
d324 1
a324 2
    !<whd> COB=change-of-basis or coordinate change, or rotation.
    DO i = 1, numValues
d326 2
a327 23
      CALL CalcMountsToFOV (scAngle(i), gtindx, MountsToFOV)
      GroundMountsToFOV = MATMUL (MountsToFOV, GroundToFlightMounts)
      ScToFOV = MATMUL (GroundMountsToFOV, ScToGroundMounts)
      ! 
      ECRtoFOV = MATMUL (ScToFOV, ecrtosc(:,:,i))
      
      !<whd> What happens when i > lenG? </whd>
      IF (i <= lenG) tp%tpECRtoFOV(:,i) = RESHAPE (ECRtoFOV, (/ 9 /))
      
      ! <whd> Picking up 3rd row of change of coords matrix. Why?
      ! </whd>
      fov_sc(1,i) = ScToFOV(3,1)
      fov_sc(2,i) = ScToFOV(3,2)
      fov_sc(3,i) = ScToFOV(3,3)
      
      ! Put sc angle. 
      
      ! <whd> This is the angle in the X/Z plane of the look
      ! direction, calculated as 90 - 'angle from Z'. </whd>
      
      
      tp%scAngle(i) = 90.0 - &
           ACOS (MAX (MIN(fov_sc(3,i), 1.0d0), -1.0d0)) * Rad2Deg
a330 6
    
    ! <whd> do change of coordinates of the line-of-sight vector from
    ! the instrument (_sc) orbital coordinates. Rick Cofield says that
    ! the `orb' coordinate system is the local vertical system, Z
    ! points at S/C nadir, X is parallel to the velocity vector (when
    ! pitch=0) and Y completes the triad </whd>
a348 5
    ! <whd> Here we operate on those `excess' MIFs that are in this
    ! MAF. lenG (nominally == 125) is the normal number of MIFs in a
    ! MAF that we expect to get actual data out of. Xnum will be the
    ! excess of that. </whd>

a366 6
    !<whd> tp%scanAngle is the angle away from X (or Z) axis in the
    !spacecraft coordinate system of the line-of-sight vector. This is
    !different from the tp%scAngle, which was the angle of the same
    !vector in the _sc (really the instrument) coordinate system
    !</whd>

d406 3
a411 15
      IF (flag==-1) THEN
         msg="lat:Failure in Tp_unit: UTC="//asciiUTC
         CALL MLSMessage (MLSMSG_Warning, ModuleName, TRIM(msg))
         PRINT *,TRIM(msg)
      ENDIF

      flagQ = 2
      CALL Tp_unit (flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaLon, &
           unitLon(:,i), flag)
      IF (flag==-1) THEN
         msg="lon:Failure in Tp_unit: UTC="//asciiUTC
         CALL MLSMessage (MLSMSG_Warning, ModuleName, TRIM(msg))
         PRINT *,TRIM(msg)
      ENDIF

a414 6
      IF (flag==-1) THEN
         msg="alt:Failure in Tp_unit: UTC="//asciiUTC
         CALL MLSMessage (MLSMSG_Warning, ModuleName, TRIM(msg))
         PRINT *,TRIM(msg)
      ENDIF

a523 1

d581 1
a581 1
       msr = mnemonic //':  '//msg
a582 1
       PRINT *,TRIM(msr)
a1015 1

d1651 1
a1651 1
       "$Id: TkL1B.f90,v 2.37 2015/01/23 17:50:17 pwagner Exp $"
a1659 3
! Revision 2.37  2015/01/23 17:50:17  pwagner
! SDPToolkit indispensible for level 1; why not use it instead of Constants?
!
@


2.37.4.2
log
@Comments, reformated some calls to make the code more readible
@
text
@a119 3
    
    ! <whd> This subroutine calculates the rotation matrix from SC
    ! coordinates to ECR coordinates </whd>
d129 1
a129 1
    ! PDS Toolkit Functions
d143 4
a146 6
    
    ! <whd> This is defined, but never used.
    !REAL(r8), PARAMETER :: SCtoGHz(3,3) = RESHAPE ((/ &
    !     -0.0000086, -0.4260405, 0.9047041, &
    !      1.0000000,  0.0000000, 0.0000095, &
    !     -0.0000041,  0.9047041, 0.4260405 /), (/ 3, 3 /))
d153 2
a154 3
         & offsets, pgs_true, pgs_true, &
         & qualityFlags, sc%scECI, sc%scVelECI, & ! the rest are outputs!
         & eulerangles, sc%yprRate, attitQuat)
d160 2
a161 2
    ! Does the following mean that AURAs euler angle order is yaw,
    ! roll, pitch?, i.e. 3,1,2?  Yes, looking at an Attitude file (in
d163 1
a163 1
    ! Header reports the Euler Angle order is 3,1,2
d211 3
a213 3
    sctoeci(1, 1::3) = w**2 + x**2 - y**2 - z**2
    sctoeci(2, 2::3) = w**2 - x**2 + y**2 - z**2
    sctoeci(3, 3::3) = w**2 - x**2 - y**2 + z**2
a339 2

      !<whd> ScToFOV = mountsToFOV # GroundToFlightMounts #
d413 1
a413 1
    !vector in the _sc (really the instrument) coordinate system (I think?)
d1721 1
a1721 1
       "$Id: TkL1B.f90,v 2.37.4.1 2015/10/09 10:21:38 whdaffer Exp $"
a1729 3
! Revision 2.37.4.1  2015/10/09 10:21:38  whdaffer
! checkin of continuing work on branch whd-rel-1-0
!
@


2.36
log
@Get constants from Constants module instead of SDPToolkit
@
text
@d26 2
a27 1
  USE SDPToolkit
d1651 1
a1651 1
       "$Id: TkL1B.f90,v 2.35 2009/07/28 18:08:11 perun Exp $"
d1660 3
@


2.35
log
@New calculation for geodangle
@
text
@d14 1
d1650 1
a1650 1
       "$Id: TkL1B.f90,v 2.34 2009/06/01 14:01:18 perun Exp $"
d1659 3
@


2.34
log
@Update galactic center polygon and save appropriate lat/longs
@
text
@d1 1
a1 1
! Copyright 2006, by the California Institute of Technology. ALL
d815 2
a816 2
       CALL TkL1B_mc (ascTAI, dscTAI, sc%scECR, nV, numOrb, &
            q, mafTAI, offsets, sc%scGeodAngle, sc%scOrbIncl)
d1031 2
a1032 2
    CALL TkL1B_mc (ascTAI, dscTAI, tp%tpECR, lenG, numOrb, &
         q, mafTAI, offsets(1:lenG), tp%tpGeodAngle, sc%scOrbIncl)
d1092 2
a1093 2
    CALL TkL1B_mc (ascTAI, dscTAI, tp%tpECR, lenT, numOrb, &
         q, mafTAI, offsets(1:lenT), tp%tpGeodAngle, sc%scOrbIncl)
d1368 2
a1369 2
  SUBROUTINE TkL1B_mc (ascTAI, dscTAI, dotVec, nV, numOrb, &
    q, timeTAI, time_offset, geodAngle, scOrbIncl)
d1378 2
a1379 1
    REAL(r8), INTENT(IN) :: dotVec(3,nV)
a1380 1
    REAL, INTENT(in) ::     scOrbIncl(nV)
d1390 1
a1390 1
    REAL(r8) :: s(3,nV)
d1393 4
d1421 10
a1430 1
       s(:,i) = dotVec(:,i) / DvecSqrtSum
d1433 2
a1434 1
       gamma(i) = ACOS(MAX(MIN((q(1,i)*s(1,i) + q(2,i)*s(2,i)), 1.0d0),-1.0d0))
d1649 1
a1649 1
       "$Id: TkL1B.f90,v 2.33 2007/06/27 14:45:30 perun Exp $"
d1658 3
@


2.33
log
@Revised vertices of the galactic center polygon
@
text
@d293 1
a293 1
    REAL(r8) :: tngtVel(3), los_vec(3)
d478 4
a481 4
      los_vec = tp%tpECI(:,i) - posECI(:,i)
      los_vec = los_vec / SQRT (SUM (los_vec**2))
      tp%tpLosVel(i) = DOT_PRODUCT (tngtVel, los_vec) - &
           DOT_PRODUCT (velECI(:,i), los_vec)
d513 1
a513 1
         tp%tpBO_stat, MoonToSpaceAngle)
d980 16
d1487 1
a1487 1
       FOV_eci, BO_stat, MoonToSpaceAngle)
d1493 2
a1494 1
    REAL(r8), INTENT(in) :: offset(:), FOV_eci(3,0:(MAFinfo%MIFsPerMAF-1))
d1500 1
d1511 1
a1511 1
    INTEGER, PARAMETER :: Ngal = 14
d1519 2
a1520 2
    REAL(r8), PARAMETER :: gal_cone_z = 0.754680843 ! 41.00250964 bounding cone
    REAL(r8), PARAMETER :: gal_fan_y = 0.042 ! Gal.Latitude fan half-width,
d1527 2
d1531 5
a1535 14
         -0.156366,  -0.029666, & !0.987254
         -0.224942,  -0.008727, & !0.974333
         -0.139152,   0.017452, & !0.990117
          0.000000,   0.017452, & !0.999848
          0.045883,   0.024546, & !0.998645
          0.074372,   0.024546, & !0.996928
          0.095836,   0.013962, & !0.995299
          0.656034,   0.008727, & !0.754681
          0.642690,  -0.017452, & !0.765928
          0.095804,  -0.029666, & !0.994958
          0.086660,  -0.038046, & !0.995511
          -0.013098, -0.040886, & !0.999078
          -0.052093, -0.028565, & !0.998234
          -0.156366, -0.029666  & !0.987254
d1620 10
d1635 1
a1635 1
       "$Id: TkL1B.f90,v 2.32 2007/04/05 13:59:27 perun Exp $"
d1644 3
@


2.32
log
@Protect every ACOS call from crashes
@
text
@d1493 1
a1493 1
    INTEGER, PARAMETER :: Ngal = 9
d1501 3
a1503 1
    REAL(r8), PARAMETER :: gal_cone_z = 0.992545 !7 bounding cone TBR
d1508 1
d1511 4
a1514 2
         -0.077649,  -0.017740, & !0.996823
         -0.012147,   0.013177, & !0.999839
d1517 4
a1520 1
          0.121742,  -0.005795, & !0.992545
d1522 3
a1524 3
         -0.013098,  -0.040886, & !0.999078
         -0.052093,  -0.028565, & !0.998234
         -0.077649,  -0.017740  & !0.996823
d1575 2
a1576 1
             IF (FOV_gal(1) > gal_cone_z) THEN ! Look within bounding cone 
d1614 1
a1614 1
       "$Id: TkL1B.f90,v 2.31 2006/06/14 13:50:02 perun Exp $"
d1623 3
@


2.31
log
@Save spacecraft Geod Angle to use for stray radiance estimations
@
text
@d450 1
a450 1
    tp%tpSolarZenith = ACOS(dot) * Rad2Deg
d459 2
a460 2
    los = ACOS(hECR(1,:)*unitLat(1,:) + hECR(2,:)*unitLat(2,:) + &
         hECR(3,:)*unitLat(3,:))
d1320 2
a1321 1
    orbInclineCrossProd = (180/Pi) * ACOS (orbMoment(3) / OMagnitude)
d1404 1
a1404 1
       gamma(i) = ACOS( q(1,i)*s(1,i) + q(2,i)*s(2,i) )
d1426 1
a1426 1
          phi(i) = ACOS(cosPhi(i))
d1605 1
a1605 1
       "$Id: TkL1B.f90,v 2.30 2006/04/05 18:09:58 perun Exp $"
d1614 3
@


2.30
log
@Remove unused variables
@
text
@d32 2
a33 1
  PUBLIC :: L1BOA_MAF, GHz_GeodAlt, GHz_GeodLat, GHz_GeodAngle, GHz_BO_stat
d35 1
a35 1
  REAL :: GHz_GeodAlt(LENG), GHz_GeodLat(LENG), GHz_GeodAngle(LENG)
d818 2
d1604 1
a1604 1
       "$Id: TkL1B.f90,v 2.29 2006/03/24 15:21:17 perun Exp $"
d1613 3
@


2.29
log
@Resized tp arrays to numValues from lenG and add GeodAltX calculation
@
text
@d253 1
a253 1
    USE SDPToolkit, ONLY: PGS_S_SUCCESS, PGSCSC_W_LOOK_AWAY, PGSCSC_W_HIT_EARTH 
a285 1
    REAL(r8) :: angleRad(numValues)
d1601 1
a1601 1
       "$Id: TkL1B.f90,v 2.28 2005/12/14 17:01:21 perun Exp $"
d1610 3
@


2.28
log
@Incorporate ReportTKStatus call for reporting errors
@
text
@d1 1
a1 1
! Copyright 2005, by the California Institute of Technology. ALL
d264 2
a265 1
    REAL(r8), INTENT(IN) :: posECR(3,lenG), posECI(3,lenG), velECI(3,lenG)
d280 1
a280 1
    INTEGER :: flag, flagQ, i, returnStatus
d294 1
a294 1
    REAL(r8) :: MountsToFOV(3,3), ECRtoFOV(3,3), FOV_eci(3,lenG)
d343 22
d368 2
a369 1
    tp%scanRate(2:) = ABS(tp%scanAngle(2:) - tp%scanAngle(1:)) / offsets(2)
d374 2
a375 2
      offsets(1:lenG), fov_sc(:,1:lenG), fov_eci)
    eciV(1:3,:) = fov_eci
d510 2
d898 8
d971 1
a971 1
       ALLOCATE (tp%tpBO_stat(lenG), STAT=error)
d991 2
a992 2
    CALL TkL1B_tp (mafTAI, mafTime, lenG, nV, offsets, sc%scECR(:,1:lenG), &
         sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleG, encAngleG, tp, &
d999 2
a1000 2
       CALL TkL1B_tp (mafTAI, mafTime, lenG, nV, offsets, sc%scECR(:,1:lenG), &
            sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleG, encAngleG, &
d1005 2
a1006 2
       CALL TkL1B_tp (mafTAI, mafTime, lenG, nV, offsets, sc%scECR(:,1:lenG), &
            sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleG, encAngleG, &
d1024 1
a1024 1
    GHz_BO_stat = tp%tpBO_stat
d1049 2
a1050 2
    CALL TkL1B_tp (mafTAI, mafTime, lenT, nV, offsets, sc%scECR(:,1:lenT), &
         sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleT, encAngleT, tp, &
d1056 2
a1057 2
       CALL TkL1B_tp (mafTAI, mafTime, lenT, nV, offsets, sc%scECR(:,1:lenT), &
            sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleT, encAngleT, &
d1062 2
a1063 2
       CALL TkL1B_tp (mafTAI, mafTime, lenG, nV, offsets, sc%scECR(:,1:lenT), &
            sc%scECI(:,1:lenT), sc%scVelECI(:,1:lenT), scAngleT, encAngleT, &
d1474 1
a1474 1
    REAL(r8), INTENT(in) :: offset(:), FOV_eci(3,0:(lenG-1))
d1481 1
a1481 1
    INTEGER :: i, j, MIF, returnStatus
d1483 3
a1485 2
    REAL(r8) :: sc_frame_vector(3,0:(lenG-1))  ! start at MIF 0
    REAL(r8) :: sc_unit_vector(3,0:(lenG-1)), eci_unit_vector(3,0:(lenG-1))
d1521 1
d1528 2
a1529 2
          returnStatus = PGS_CBP_Sat_CB_Vector (spacecraftId, lenG, asciiUTC, &
               offset(1:lenG), BO_def(i), sc_frame_vector)
d1532 1
a1532 1
          DO MIF = 0, (lenG - 1)
d1538 2
a1539 2
          returnStatus = PGS_CSC_SCtoECI (spacecraftId, lenG, asciiUTC, &
               offset(1:lenG), sc_unit_vector, eci_unit_vector)
d1543 1
a1543 1
       DO MIF = 0, (lenG - 1)
d1602 1
a1602 1
       "$Id: TkL1B.f90,v 2.27 2005/12/06 19:30:42 perun Exp $"
d1611 3
@


2.27
log
@Removed Flag_Bright_Objects routine and added determining BO_stat bits
@
text
@d18 1
a18 1
       MLSMSG_Allocate
d37 1
d206 1
d220 1
d355 1
d408 1
d413 1
d1104 1
d1107 1
d1113 1
d1115 1
d1344 1
d1566 1
a1566 1
       "$Id: TkL1B.f90,v 2.26 2005/10/11 16:08:50 perun Exp $"
d1575 3
@


2.26
log
@Replace local mean time with local apparent time for SolarTime
@
text
@d32 1
a32 6
  PUBLIC :: L1BOA_MAF, Flag_Bright_Objects, LOG_ARR1_PTR_T, GHz_GeodAlt, &
       GHz_GeodLat, GHz_GeodAngle

  TYPE LOG_ARR1_PTR_T
     LOGICAL, DIMENSION(:), POINTER :: ptr
  END TYPE LOG_ARR1_PTR_T
d35 1
d42 1
a42 1
  character (len=*), private, parameter :: ModuleName= &
d44 1
a44 1
  private :: not_used_here 
d246 1
a246 1
    ScToGroundMounts, gtindx)
d256 2
d262 2
a263 1
    REAL, INTENT(IN) :: ecrtosc(3,3,numValues)
d290 1
a290 1
    REAL(r8) :: MountsToFOV(3,3), ECRtoFOV(3,3)
d347 2
a348 2
      offsets(1:lenG), fov_sc(:,1:lenG), eci)
    eciV(1:3,:) = eci
d478 5
d485 1
a485 1
       print *, 'some bad MIFs...'
d573 2
d930 8
d953 3
a955 1
         ecrtosc, GroundToFlightMountsGHz, ScToGroundMountsGHz, gtindx)
d961 2
a962 1
            tp, ecrtosc, GroundToFlightMountsGHz, ScToGroundMountsGHz, gtindx)
d967 2
a968 1
            tp, ecrtosc, GroundToFlightMountsGHz, ScToGroundMountsGHz, gtindx)
d982 4
d1011 2
a1012 1
         ecrtosc, GroundToFlightMountsTHz, ScToGroundMountsTHz, gtindx)
d1018 2
a1019 1
            tp, ecrtosc, GroundToFlightMountsTHz, ScToGroundMountsTHz, gtindx)
d1024 2
a1025 1
            tp, ecrtosc, GroundToFlightMountsTHz, ScToGroundMountsTHz, gtindx)
d1209 1
a1209 3
!    sc_velv = [sc_vel(i,j)       - 7.27221d-08*datascecr(1,i,j), $
!               sc_vel(i+mmifs,j) + 7.27221d-08*datascecr(0,i,j), $
!               sc_vel(i+2*mmifs,j)]
a1317 2
!    real(r8), intent(IN) :: scECR(3,nV)             ! s/c pos.
!    real(r8), intent(IN) :: scVelECR(3,nV)          ! s/c vel.
d1422 2
a1423 2
  SUBROUTINE Flag_Bright_Objects (TAI, ScAngle, MoonLimbTol, LimbView, &
       SpaceView)
d1426 1
a1426 1
    USE MLSL1Config, ONLY: L1Config
d1428 7
a1434 4
    REAL(r8) :: TAI(:)
    REAL :: ScAngle(0:), MoonLimbTol
    TYPE (LOG_ARR1_PTR_T) :: LimbView(:)
    TYPE (LOG_ARR1_PTR_T), OPTIONAL :: SpaceView(:)
d1436 1
a1436 3
    CHARACTER (LEN=27) :: asciiUTC
    INTEGER :: i, MIF, returnStatus
    LOGICAL :: HasSpaceView
a1437 1
    REAL(r8) :: offset (SIZE(TAI))
d1439 4
a1442 1
    REAL(r8) :: sc_unit_vector(3)
d1444 25
a1468 5
    INTEGER, PARAMETER :: BO_defs(2) = (/ PGSd_Moon, PGSd_Venus /)
    REAL, PARAMETER :: VenusInSpace = 1.0
    REAL, PARAMETER :: VenusInLimb = 1.0
    REAL :: space_tol(2) = (/ 0.0, VenusInSpace /) ! tolerance for space port
    REAL :: limb_tol(2) = (/ 0.0, VenusInLimb /)   ! tolerance for limb port
d1472 1
a1472 1
    INTEGER, EXTERNAL :: PGS_TD_taiToUTC, PGS_CBP_Sat_CB_Vector
d1474 1
a1474 1
    HasSpaceView = PRESENT (SpaceView)
d1476 1
a1476 1
! Get Moon tolerances from CF inputs:
d1478 1
a1478 3
    space_tol(1) = L1Config%Calib%MoonToSpaceAngle
!    limb_tol(1) = L1Config%Calib%MoonToLimbAngle
    limb_tol(1) = MoonLimbTol
d1480 10
a1489 2
    returnStatus = PGS_TD_taiToUTC (TAI(1), asciiUTC)
    offset = TAI - TAI(1)   ! offset (secs) from start TAI
d1491 4
a1494 6
    DO i = 1, 2
       IF (HasSpaceView) SpaceView(i)%ptr = .FALSE.
       LimbView(i)%ptr = .FALSE.
       returnStatus = PGS_CBP_Sat_CB_Vector (spacecraftId, lenG, asciiUTC, &
            offset(1:lenG), BO_defs(i), sc_frame_vector)
       IF (returnStatus /= 0) CYCLE
a1496 3
          sc_unit_vector = sc_frame_vector(:,MIF) / &
               SQRT (sc_frame_vector(1,MIF)**2 + sc_frame_vector(2,MIF)**2 + &
               sc_frame_vector(3,MIF)**2)
d1498 1
a1498 1
! Space port angle check
d1500 34
a1533 4
          IF (HasSpaceView) THEN
             space_angle = ACOS (MAX (MIN (sc_unit_vector(2), 1.0d0), &
                  -1.0d0)) * Rad2Deg  ! Y vector
             SpaceView(i)%ptr(MIF) = (space_angle < space_tol(i))
d1536 3
a1538 1
! Limb port angle check
d1540 6
a1545 5
          limb_angle = ACOS (MAX (MIN ( DOT_PRODUCT( &
               (/ COS (scAngle(MIF) * Deg2Rad), 0.0, &
               SIN (scAngle(MIF) * Deg2Rad) /), &
               sc_unit_vector), 1.0d0), -1.0d0)) * Rad2Deg
          LimbView(i)%ptr(MIF) = (limb_angle < limb_tol(i))
d1548 1
d1550 1
a1550 3
    ENDDO

  END SUBROUTINE Flag_Bright_Objects
d1552 1
a1552 1
  logical function not_used_here()
d1554 3
a1556 3
  character (len=*), parameter :: IdParm = &
       "$Id: TkL1B.f90,v 2.25 2005/08/24 15:53:43 perun Exp $"
  character (len=len(idParm)), save :: Id = idParm
d1559 2
a1560 1
  end function not_used_here
d1564 3
@


2.25
log
@Allocate and save pos1/pos2 prime data in the tangent point structures
@
text
@d280 1
a280 1
    REAL(r8) :: greenwich, localApparent, rightAscension, tai
d391 2
a392 1
        localMean(i), localApparent, rightAscension, declination)
d397 1
a397 1
    tp%tpSolarTime = localMean / 3600.0
d1478 1
a1478 1
       "$Id: TkL1B.f90,v 2.24 2005/07/19 16:34:46 perun Exp $"
d1486 3
@


2.24
log
@Added SAVE to sc and tp structures to prevent memory leaks
@
text
@d560 1
a560 1
       encAngleT)
d574 1
d811 8
d963 4
d1002 4
d1477 1
a1477 1
       "$Id: TkL1B.f90,v 2.23 2005/06/23 18:41:36 pwagner Exp $"
d1485 3
@


2.23
log
@Reworded Copyright statement, moved rcs id
@
text
@d47 1
a47 1
       "$RCSfile: $"
d581 3
a583 3
    TYPE( L1BOAindex_T ) :: index
    TYPE( L1BOAsc_T ) :: sc
    TYPE( L1BOAtp_T ) :: tp
d1460 1
a1460 1
       "$Id: $"
d1468 3
@


2.22
log
@Protect acos/asin from crashing.
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d45 5
a49 6
  !------------------- RCS Ident Info -----------------------
  CHARACTER(len=*), PARAMETER :: IdParm = &
    & "$Id: TkL1B.f90,v 2.21 2005/01/28 17:04:05 perun Exp $"
  CHARACTER(len=LEN(idParm)) :: Id = idParm
  CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: TkL1B.f90,v $"
  !----------------------------------------------------------
d1457 8
d1468 3
@


2.21
log
@Pass in MoonToLimb tolerance instead of getting it from L1Config
@
text
@d39 1
a39 1
    & "$Id: TkL1B.f90,v 2.20 2005/01/25 18:01:06 perun Exp $"
d1431 2
a1432 1
             space_angle = ACOS (sc_unit_vector(2)) * Rad2Deg  ! Y vector
d1438 1
a1438 1
          limb_angle = ACOS ( DOT_PRODUCT( &
d1441 1
a1441 1
               sc_unit_vector) ) * Rad2Deg
d1453 3
@


2.20
log
@Calculate tangent point scan rates (deg/sec)
@
text
@d39 1
a39 1
    & "$Id: TkL1B.f90,v 2.19 2004/11/10 15:32:05 perun Exp $"
d1376 2
a1377 1
  SUBROUTINE Flag_Bright_Objects (TAI, ScAngle, LimbView, SpaceView)
d1383 1
a1383 1
    REAL :: ScAngle(0:)
d1410 2
a1411 1
    limb_tol(1) = L1Config%Calib%MoonToLimbAngle
d1452 3
@


2.19
log
@Add encoder values; latest FOVs; correct YPR values order
@
text
@d39 1
a39 1
    & "$Id: TkL1B.f90,v 2.18 2004/08/12 13:51:51 perun Exp $"
d335 2
d673 1
a673 1
          msr = MLSMSG_Allocate // '  s/c encoder angle quantities.'
d681 1
a681 1
          msr = MLSMSG_Allocate // '  s/c angle quantities.'
d689 1
a689 1
          msr = MLSMSG_Allocate // '  s/c scan angle quantities.'
d697 1
a697 1
          msr = MLSMSG_Allocate // '  s/c azim angle quantities.'
d705 1
a705 1
          msr = MLSMSG_Allocate // '  s/c scan rate quantities.'
d1450 3
@


2.18
log
@Version 1.44 commit
@
text
@d39 1
a39 1
    & "$Id: TkL1B.f90,v 2.17 2004/08/03 20:41:14 pwagner Exp $"
d72 1
a72 1
  SUBROUTINE Init_L1BOAtp (tp)
d76 1
d78 23
a100 20
    tp%encoderAngle = HUGE_F
    tp%scAngle = HUGE_F
    tp%scanAngle = HUGE_F
    tp%scanRate = HUGE_F
    tp%tpECI = HUGE_F
    tp%tpECR = HUGE_F
    tp%tpECRtoFOV = HUGE_F
    tp%tpGeodAlt = HUGE_F
    tp%tpGeocAlt = HUGE_F
    tp%tpOrbY = HUGE_F
    tp%tpGeocLat = HUGE_F
    tp%tpGeocAltRate = HUGE_F
    tp%tpGeodLat = HUGE_F
    tp%tpGeodAltRate = HUGE_F
    tp%tpLon = HUGE_F
    tp%tpGeodAngle = HUGE_F
    tp%tpSolarTime = HUGE_F
    tp%tpSolarZenith = HUGE_F
    tp%tpLosAngle = HUGE_F
    tp%tpLosVel = HUGE_F
d126 1
a126 1
    REAL(r8) :: ecrVec(3)
d143 7
a149 1
         sc%ypr, sc%yprRate, attitQuat)
d242 2
a243 1
    posECI, velECI, scAngle, tp, ecrtosc)
d247 1
a247 1
    USE SDPToolkit, ONLY: PGSCSC_W_LOOK_AWAY 
d252 2
a253 2
    INTEGER, INTENT(IN) :: lenG, numValues
    REAL, INTENT(IN) :: scAngle(numValues)
d257 4
a260 1
    REAL, INTENT(IN), OPTIONAL :: ecrtosc(3,3,numValues)
d271 1
d281 1
a281 1
    REAL(r8) :: angleSc(3,numValues), angleOrb(3,numValues)
d285 1
d294 17
d314 2
a315 2
    DO i = 1, numvalues
       tp%scAngle(i) = scAngle(i)
d318 1
a318 5
    ! Put angle in s/c coordinates
    angleRad = Deg2Rad * tp%scAngle
    angleSc(1,:) = COS(angleRad)
    angleSc(2,:) = 0.0
    angleSc(3,:) = SIN(angleRad)
a319 1
    ! Convert s/c vector to Orb vector/angle/degrees
d321 1
a321 1
      offsets, angleSc, angleOrb)
d333 3
a335 1
    tp%scanAngle = Rad2Deg * ACOS (angleOrb(1,:))
d339 1
a339 1
      offsets(1:lenG), angleSc(:,1:lenG), eci)
d346 1
a346 6
    ! Determine ECR to FOV, if requested

    IF (PRESENT (ecrtosc)) THEN
       DO i = 1, lenG

          CALL CalcMountsToFOV (scAngle(i), MountsToFOV)
d348 1
a348 8
          ECRtoFOV = MATMUL (MountsToFOV, ecrtosc(:,:,i))
          tp%tpECRtoFOV(:,i) = RESHAPE (ECRtoFOV, (/ 9 /))

       ENDDO

    ENDIF

    ! For each scanning MIF
d356 9
a364 7
      IF (returnStatus == PGSCSC_W_LOOK_AWAY) THEN  ! looking away
         latD(i) = HUGE_F
         lon(i) = HUGE_F
         tp%tpGeodAlt(i) = HUGE_F
         slantRange(i) = HUGE_F
         tp%tpECR(:,i) = HUGE_F
         posSurf(:,i) = HUGE_F
d459 1
a459 1
    tp%encoderAngle = tp%scAngle
d469 5
d495 1
a495 1
    REAL(r8) :: ecrMinus(3), ecrPlus(3), vec(3)
d539 3
a541 2
    IF (SUM (vec) > 0.0) THEN
       unitQ = vec / SQRT (vec(1)**2 + vec(2)**2 + vec(3)**2)
d550 2
a551 1
       MAFinfo, noMAF, numOrb, scAngleG, scAngleT)
d557 2
d562 1
a562 1
    INTEGER, INTENT(IN) :: L1FileHandle, counterMAF, noMAF, numOrb
d564 1
d577 1
a577 1
    INTEGER :: error, i, nV, returnStatus, oastat
d597 1
a597 1
    index%noMIFs = nV
d692 8
d917 1
d919 2
a920 1
         sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleG, tp, ecrtosc)
d925 2
a926 1
            sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleG, tp)
d930 2
a931 1
            sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleG, tp, ecrtosc)
d963 1
d965 2
a966 1
         sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleT, tp)
d971 2
a972 1
            sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleT, tp)
d976 2
a977 1
            sc%scECI(:,1:lenT), sc%scVelECI(:,1:lenT), scAngleT, tp)
d1280 1
a1280 1
    REAL(r8) :: orbInclineNow
d1299 1
a1299 1
       s(:,i) = dotVec(:,i) / SQRT(dotVec(1,i)**2 + dotVec(2,i)**2 + &
d1301 5
d1374 1
a1374 1
  SUBROUTINE Flag_Bright_Objects (TAI, ScAngle, SpaceView, LimbView)
d1381 2
a1382 1
    TYPE (LOG_ARR1_PTR_T) :: SpaceView(:), LimbView(:)
d1386 1
d1402 2
d1413 1
a1413 1
       SpaceView(i)%ptr = .FALSE.
d1426 4
a1429 2
          space_angle = ACOS (sc_unit_vector(2)) * Rad2Deg  ! Y vector
          SpaceView(i)%ptr(MIF) = (space_angle < space_tol(i))
d1448 3
@


2.17
log
@Gets DEFAULTUNDEFINEDVALUE from MLSCommon
@
text
@d39 1
a39 1
    & "$Id: TkL1B.f90,v 2.16 2004/05/14 15:59:11 perun Exp $"
d236 1
d338 9
d880 1
a880 1
         sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleG, tp)
d1391 3
@


2.16
log
@Version 1.43 commit
@
text
@d7 1
a7 1
  USE MLSCommon, ONLY: R8
d34 1
a34 1
  REAL, PARAMETER ::    UNDEFINED_VALUE = -999.99
d39 1
a39 1
    & "$Id: TkL1B.f90,v 2.15 2004/01/09 17:46:23 perun Exp $"
d1381 3
@


2.15
log
@Version 1.4 commit
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 1
d39 1
a39 1
    & "$Id: TkL1B.f90,v 2.14 2003/09/15 21:50:04 pwagner Exp $"
d101 2
a102 1
  SUBROUTINE TkL1B_sc (numValues, offsets, asciiUTC, mafTAI, sc, ecrtosc)
d112 1
d120 1
a120 1
    INTEGER :: i, returnStatus
d140 16
d210 2
a211 2
       sc%scGeocAlt(i) = SQRT( ecrV(1,i)**2 + ecrV(2,i)**2 + ecrV(3,i)**2 )
       radC(i) = ATAN( ecrV(3,i) / SQRT(ecrV(1,i)**2 + ecrV(2,i)**2) )
d334 2
a335 2
        latD(i), lon(i), tp%tpGeodAlt(i), &
        slantRange(i), tp%tpECR(:,i), posSurf(:,i))
d340 1
a340 1
        unitLon(:,i), flag)
d343 1
a343 1
        unitLat(:,i), flag)
d346 1
a346 1
        unitAlt(:,i), flag)
d376 2
a377 2
       nts(:,i) = tp_sun(:,i) / SQRT( tp_sun(1,i)**2 + tp_sun(2,i)**2 + &
            tp_sun(3,i)**2 )
d417 1
a417 1
      offsets(1:lenG), tp%tpECI, tpOrb)
d423 3
a425 3
        &tp%tpECR(3,i)**2 )
      tp%tpGeocLat(i) = Rad2Deg * ATAN( tp%tpECR(3,i) &
        &/ SQRT( tp%tpECR(1,i)**2 + tp%tpECR(2,i)**2 ) )
d431 4
a434 4
      tp%tpGeocAltRate(i-1) = ( tp%tpGeocAlt(i) - tp%tpGeocAlt(i-1) )&
        &/offsets(2)
      tp%tpGeodAltRate(i-1) = ( tp%tpGeodAlt(i) - tp%tpGeodAlt(i-1) )&
        &/offsets(2)
d445 1
d475 1
a475 1
        ecrPlus)
d477 1
a477 1
        ecrMinus)
d484 1
a484 1
        ecrPlus)
d486 1
a486 1
        ecrMinus)
d491 1
a491 1
        ecrPlus)
d493 1
a493 1
        ecrMinus)
d497 4
a500 4
      CALL Pgs_smf_getMsg (returnStatus, mnemonic, msg)
      msr = mnemonic // ':  ' // msg
      CALL MLSMessage (MLSMSG_Warning, ModuleName, msr)
      flag = -1
d505 1
a505 1
       unitQ = vec / SQRT( vec(1)**2 + vec(2)**2 + vec(3)**2 )
d537 1
a537 1
    INTEGER :: error, i, nV, returnStatus
d710 3
a712 1
    CALL TkL1B_sc (nV, offsets, mafTime, mafTAI, sc, ecrtosc)
d716 1
a716 1
    CALL Mc_aux (mafTime, offsets, sc%scECR, q )
d718 4
a721 2
    CALL TkL1B_mc (ascTAI, dscTAI, sc%scECR, nV, numOrb, &
      & q, mafTAI, offsets, sc%scGeodAngle, sc%scOrbIncl)
a726 3
    ! Calculate initial guess for look vector in ECR
    CALL Scan_guess (mafTime, initRay)

d857 6
d870 1
a870 1
      sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleG, tp) !, ecrtosc)
d875 1
a875 1
            sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleG, tp) !, ecrtosc)
d885 1
a885 1
      & q, mafTAI, offsets(1:lenG), tp%tpGeodAngle, sc%scOrbIncl)
d893 6
d903 2
d912 1
a912 1
      sc%scECI(:,1:lenG), sc%scVelECI(:,1:lenG), scAngleT, tp)
d918 1
a918 1
        angle_del = tp%tpGeodAlt(1) / 5200.0 * 0.1
d927 1
a927 1
      & q, mafTAI, offsets(1:lenT), tp%tpGeodAngle, sc%scOrbIncl)
d931 6
d996 2
a997 4
    returnStatus = Pgs_csc_ECItoECR (nV, asciiUTC, offsets, &
      & aux1ECI, aux1ECR )
    returnStatus = Pgs_csc_ECItoECR (nV, asciiUTC, offsets, &
      & aux2ECI, aux2ECR )
d1003 5
a1007 5
    small1 = ABS(aux1ECR(3,:)) < SQRT( TINY(0.0_r8) )
    small2 = ABS(aux2ECR(3,:)) < SQRT( TINY(0.0_r8) )
    IF (ANY ( small1 .AND. small2 )) THEN
      CALL MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Problem computing auxilliary vector for master coordinate' )
d1047 2
a1048 2
    WHERE ( ( (scECR(3,:) < 0.0) .AND. (l < 0.0) ) .OR. &
      &     ( (scECR(3,:) >= 0.0) .AND. (l >= 0.0) ) )
d1054 1
a1054 1
    qSize = SQRT( q(1,:)**2 + q(2,:)**2 ) 
d1096 2
a1097 2
      orbInclineCalculated = UNDEFINED_VALUE
      RETURN
d1126 2
a1127 4
       & COS(lamRad) * (vUnrotated(2)*COS(muRad) - vUnrotated(1)*SIN(muRad)) &
       & / &
       & v &
       & ), advance='no')
d1163 1
a1163 1
    OMagnitude = SQRT( orbMoment(1)**2 + orbMoment(2)**2 + orbMoment(3)**2 )
d1165 2
a1166 2
      orbInclineCrossProd = UNDEFINED_VALUE
      RETURN
d1168 1
a1168 1
    orbInclineCrossProd = (180/Pi) * ACOS( orbMoment(3) / OMagnitude )
d1173 1
a1173 1
      orbInclineCrossProd = 180. - orbInclineCrossProd
d1175 1
a1175 1
      orbInclineCrossProd = 360. - orbInclineCrossProd
d1179 15
a1193 15
      CALL output ('rx, ry, rz ', advance='no')
      CALL blanks (3, advance='no')
      CALL output (scECI, advance='yes')
      CALL output ('vx, vy, vz ', advance='no')
      CALL blanks (3, advance='no')
      CALL output (scVelECI, advance='yes')
      CALL output ('px, py, pz ', advance='no')
      CALL blanks (3, advance='no')
      CALL output (orbMoment, advance='yes')
      CALL output ('orbital inclination ', advance='no')
      CALL blanks (3, advance='no')
      CALL output ((180/Pi) * ACOS( orbMoment(3) / OMagnitude ), advance='no')
      CALL blanks (3, advance='no')
      CALL output (orbInclineCrossProd, advance='yes')
      IF (HOWMANYSOFAR > 40 ) STOP
d1195 1
d1236 65
a1300 65
      orbInclineNow = scOrbIncl(i)
      IF (orbInclineNow == UNDEFINED_VALUE) THEN
        CALL MLSMessage (MLSMSG_Error, ModuleName, &
          & 'Error in calculating orbital inclination angle')
      ENDIF

      ! Get a unit ECR vector to the point.
      s(:,i) = dotVec(:,i) / SQRT(dotVec(1,i)**2 + dotVec(2,i)**2 + &
        & dotVec(3,i)**2)
      
      ! Calculate the geocentric angle as a number of radians between 0 and PI
      gamma(i) = ACOS( q(1,i)*s(1,i) + q(2,i)*s(2,i) )
      
      ! Place angle between PI and 2*PI, if in Southern Hemisphere
      IF (dotVec(3,i) < 0.0 ) gamma(i) = 2*PI - gamma(i)

      ! Going to convert this to geodetic, calculate som parameters.
      orbRad= Deg2Rad * (orbInclineNow - 90)
      cSq = (1 + (TAN(orbRad)**2)) * (a**2)*(b**2) / &
        & ( a**2 + (b**2)*(TAN(orbRad)**2) )

      ! If |gamma| <= 45 deg of the equator, calculate phi using the SIN !
      ! equation
      IF ((gamma(i) <= PI/4 ) .OR. ( (gamma(i) >= 3*PI/4) .AND. &
        & (gamma(i) <= 5*PI/4) ) .OR. (gamma(i) >= 7*PI/4)) THEN
        sinPhi(i) = SQRT( (a**4)*(SIN(gamma(i))**2)/( (cSq**2)*&
          &(COS(gamma(i))**2) + (a**4)*(SIN(gamma(i))**2) ) )
        phi(i) = ASIN(sinPhi(i))
      ELSE
        ! If gamma is within 45 deg of a pole, calculate phi using the COS 
        ! equation
        cosPhi(i) = SQRT( (cSq**2)*(COS(gamma(i))**2)/( (cSq**2)*&
          &COS(gamma(i))**2 + (a**4)*(SIN(gamma(i))**2) ) )
        phi(i) = ACOS(cosPhi(i))
      ENDIF

      ! Place phi in same quadrant as gamma
      IF ((gamma(i) > PI/2) .AND. (gamma(i) <= PI) ) phi(i) = PI - phi(i)
      IF ((gamma(i) > PI) .AND. (gamma(i) <= 3*PI/2) ) phi(i) = phi(i) + PI
      IF (gamma(i) > 3*PI/2 ) phi(i) = 2*PI - phi(i)

      ! Make phi cumulative over orbits
      ! First what is the time?
      asciiTAI = timeTAI + time_offset(i)
      scOrb = 0

      ! Now always make our calculation based on some threshold way back in
      ! time, to avoid any ambiguity
      IF (( phi(i) < pi/2 ) .OR. ( phi(i) >= 3*pi/2 )) THEN
        ! If in the ascending part of the orbit, base correction
        ! on time of last descending node
        ! MAKE THIS USE HUNT LATER!
        DO j = 1, numOrb
          IF (asciiTAI > dscTAI(j) ) scOrb = j
        ENDDO

        ! If we're in the NH we've begun a new orbit, so add one
        IF (phi(i) < pi ) scOrb = scOrb + 1
      ELSE
        ! If in descending part of the orbit, base it on the time
        ! of the last ascending node
        ! MAKE THIS USE HUNT LATER!
        DO j = 1, numOrb
          IF (asciiTAI > ascTAI(j) ) scOrb = j
        ENDDO
d1302 2
a1303 2
      END IF
      phi(i) = (scOrb-2)*2*PI + phi(i)
d1313 1
a1313 1
  SUBROUTINE Flag_Bright_Objects (TAI, SpaceView, LimbView)
d1316 2
d1319 1
d1330 4
a1333 1
    REAL, PARAMETER :: space_tol = 10.0   ! tolerance for space port
d1339 5
d1359 2
d1362 3
a1364 1
          SpaceView(i)%ptr(MIF) = (space_angle < space_tol)
d1366 5
a1370 1
! Need to add limb port angle check here
d1381 3
@


2.14
log
@Removed illegal midline continuation--Lahey disapproves
@
text
@d23 2
a24 1
  PUBLIC :: L1BOA_MAF, Flag_Bright_Objects, LOG_ARR1_PTR_T
d30 2
d38 1
a38 1
    & "$Id: TkL1B.f90,v 2.13 2003/09/15 17:15:54 perun Exp $"
d860 6
d1324 3
@


2.13
log
@Version 1.3 commit
@
text
@d35 1
a35 1
    & "$Id: TkL1B.f90,v 2.12 2003/08/15 14:25:04 perun Exp $"
d1298 1
a1298 1
               SQRT (sc_frame_vector(1,MIF)**2 + & sc_frame_vector(2,MIF)**2 + &
d1315 3
@


2.12
log
@Version 1.2 commit
@
text
@d35 1
a35 1
    & "$Id: TkL1B.f90,v 2.11 2002/11/07 21:56:20 jdone Exp $"
d1273 2
a1274 1
    INTEGER :: i, returnStatus
d1277 1
d1279 2
a1280 1
    INTEGER, PARAMETER :: BO_defs(3) = (/ PGSd_Sun, PGSd_Moon, PGSd_Venus /)
d1289 1
a1289 1
    DO i = 1, 3
d1294 9
d1304 3
a1306 1
! Will need to add figuring out the angles to the limb scan and space port
d1315 3
@


2.11
log
@Added Level 1 output datatypes.
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d4 1
a4 1
module TkL1B
d6 26
a31 18
!!!!!! THIS LINE DOESN'T SEEM TO WORK!!!!!  use MLSNumerics, only: Hunt
  use Dump_0, only: DUMP
  use Geometry, only: Omega => W
  use MLSCommon, only: R8
  use MLSL1Common
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_Error
  use OUTPUT_M, only: BLANKS, OUTPUT
  use OutputL1B_DataTypes, only: L1BOAsc_T, L1BOATP_T, L1BOAINDEX_T, LENCOORD, LENG, LENT
  use OutputL1B, only: OUTPUTL1B_THZ, OUTPUTL1B_SC, OUTPUTL1B_INDEX, OUTPUTL1B_GHZ
  use Scan
  use SDPToolkit

  implicit none
  private

  public :: TKL1B_SC, TKL1B_TP, L1BOA_MAF, MC_AUX, TKL1B_MC
  logical, public, parameter :: ORBINCLINE_IS_CONSTANT = .FALSE.
  real, parameter ::    UNDEFINED_VALUE = -999.99
d34 4
a37 4
  character(len=*), parameter :: IdParm = &
    & "$Id: TkL1B.f90,v 2.10 2002/09/26 20:52:26 vsnyder Exp $"
  character(len=len(idParm)) :: Id = idParm
  character (LEN=*), parameter :: ModuleName="$RCSfile: TkL1B.f90,v $"
d43 52
a94 1
contains
d97 3
a99 3
  subroutine TkL1B_sc(numValues, offsets, asciiUTC, sc)
    ! This subroutine contains prototype code for creating the desired s/c record
    ! from the EPHEMATTIT output.
d102 5
a106 4
    type( L1BOAsc_T ) :: sc
    character (LEN=27), intent(IN) :: asciiUTC
    integer, intent(IN) :: numValues
    real(r8), intent(IN) :: offsets(numValues)
d109 1
a109 1
    integer :: Pgs_csc_eciToECR, Pgs_csc_ecrToGEO, Pgs_eph_ephemAttit
d112 14
a125 8
    character (LEN=32) :: mnemonic
    character (LEN=480) :: msg, msr
    integer :: i, returnStatus
    integer :: qualityFlags(2, numValues)
    real(r8) :: ecrVec(3)
    real(r8) :: radC(numValues), radD(numValues), radL(numValues)
    real(r8) :: attitQuat(4,numValues)
    real(r8) :: eciV(6,numValues), ecrV(6,numValues)
d130 1
d132 46
a177 7
      offsets, pgs_true, pgs_true, qualityFlags, &
      sc%scECI, sc%scVelECI, sc%ypr, sc%yprRate, attitQuat)
    if (returnStatus /= PGS_S_SUCCESS) then
      call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
      msr = 'Routine ephemAttit, ' // mnemonic // ':  ' // msg
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d187 18
a204 17
    do i = 1, numValues
      sc%scGeocAlt(i) = sqrt( ecrV(1,i)**2 + ecrV(2,i)**2 + ecrV(3,i)**2 )
      radC(i) = atan( ecrV(3,i) / sqrt(ecrV(1,i)**2 + ecrV(2,i)**2) )
      sc%scGeocLat(i) = Rad2Deg * radC(i)
      ecrVec = ecrV(1:3, i)
      returnStatus = Pgs_csc_ecrToGEO (ecrVec, earthModel, radL(i), &
        radD(i), sc%scGeodAlt(i))
      sc%scGeodLat(i) = Rad2Deg * radD(i)
      sc%scLon(i) = Rad2Deg * radL(i)
      if ( ORBINCLINE_IS_CONSTANT ) then
        sc%scOrbIncl(i) = orbInclineCrossProd(sc%scECI(:,i), sc%scVelECI(:,i))
      else
        sc%scOrbIncl(i) = orbInclineCalculated(sc%scECR(:,i), sc%scVelECR(:,i), &
        & sc%scGeocLat(i), sc%scLon(i) )
      endif
    enddo

d206 1
a206 1
  end subroutine TkL1B_sc
d209 2
a210 2
  subroutine TkL1B_tp(asciiTAI, asciiUTC, lenG, numValues, offsets, posECR, &
    scRate, startAngle, tp)
d213 2
d216 8
a223 7
    type( L1BOAtp_T ) :: tp
    character (LEN=27), intent(IN) :: asciiUTC
    integer, intent(IN) :: lenG, numValues
    real, intent(IN) :: scRate(lenG)
    real(r8), intent(IN) :: asciiTAI, startAngle
    real(r8), intent(IN) :: offsets(numValues)
    real(r8), intent(IN) :: posECR(3,lenG)
d226 4
a229 4
    integer :: Pgs_cbp_sat_cb_vector, Pgs_cbp_solarTimeCoords
    integer :: Pgs_csc_scToOrb, Pgs_csc_scToECI, Pgs_csc_eciToECR
    integer :: Pgs_csc_grazingRay, Pgs_csc_ecrToECI, Pgs_csc_eciToOrb
    integer :: Pgs_td_taiToUTC
d232 18
a249 13
    character (LEN=27) :: time
    integer :: flag, flagQ, i, returnStatus
    real(r8) :: declination, delAngle, delTime, deltaAlt, deltaLat, deltaLon
    real(r8) :: greenwich, localApparent, rightAscension, tai
    real(r8) :: dot(lenG), latD(lenG), localMean(lenG), lon(lenG), los(lenG)
    real(r8) :: sign(lenG), slantRange(lenG)
    real(r8) :: angleRad(numValues)
    real(r8) :: eci(3,lenG), ecr(3,lenG), hECR(3,lenG), nts(3,lenG)
    real(r8) :: posSurf(3,lenG), sc_frame_vector(3,lenG), sc_sun(3,lenG)
    real(r8) :: sc_tp(3,lenG), tp_sun(3,lenG), tpOrb(3,lenG), unitAlt(3,lenG)
    real(r8) :: unitLat(3,lenG), unitLon(3,lenG), vECR(3,lenG)
    real(r8) :: angleSc(3,numValues), angleOrb(3,numValues)
    real(r8) :: eciV(6,lenG), ecrV(6,lenG)
d256 5
a260 14
    ! Calculate MIF scan angles (in DEGREES)
    tp%scAngle(1) = startAngle
    do i = 2, lenG
      tp%scAngle(i) = tp%scAngle(i-1) - scRate(i)*offsets(2)
    enddo

    ! Calculate retrace angle, rate
    delAngle = tp%scAngle(lenG) - tp%scAngle(1)
    delTime = (numValues - lenG)*offsets(2)
    tp%scanRate(1:lenG) = scRate
    tp%scanRate( (lenG+1):numValues ) = delAngle/delTime
    do i = lenG+1, numvalues
      tp%scAngle(i) = tp%scAngle(i-1) - tp%scanRate(i)*offsets(2)
    enddo
d264 1
a264 1
    angleSc(1,:) = cos(angleRad)
d266 1
a266 1
    angleSc(3,:) = sin(angleRad)
d269 1
a269 1
    returnStatus = Pgs_csc_scToOrb(spacecraftId, numValues, asciiUTC, &
d271 10
d282 1
a282 1
    tp%scanAngle = Rad2Deg * acos( angleOrb(1,:) )
d285 1
a285 1
    returnStatus = Pgs_csc_scToECI(spacecraftId, lenG, asciiUTC, &
d289 2
a290 2
    returnStatus = Pgs_csc_eciToECR(lenG, asciiUTC, offsets(1:lenG), eciV, &
      ecrV)
d293 16
a308 2
    ! For each scanning MIF,
    do i = 1, lenG
d311 1
a311 1
      returnStatus = Pgs_csc_grazingRay(earthModel, posECR(:,i), ecr(:,i), &
d313 1
a313 1
        slantRange(i), tp%tpECR(:,i), posSurf(:,i) )
d317 1
a317 1
      call Tp_unit(flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaLon, &
d320 1
a320 1
      call Tp_unit(flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaLat, &
d323 1
a323 1
      call Tp_unit(flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaAlt, &
d328 2
a329 2
      returnStatus = Pgs_td_taiToUTC(tai, time)
      returnStatus = Pgs_cbp_solarTimeCoords(time, lon(i), greenwich, &
d331 1
a331 1
    enddo
d335 1
a335 1
    tp%tpSolarTime = localMean/3600.0
d338 5
a342 4
    returnStatus = Pgs_cbp_sat_cb_vector(spacecraftId, lenG, asciiUTC, &
      offsets(1:lenG), PGSd_SUN, sc_frame_vector)
    returnStatus = Pgs_csc_scToECI(spacecraftId, lenG, asciiUTC, &
      offsets(1:lenG), sc_frame_vector, eci)
d345 3
a347 2
    returnStatus = Pgs_csc_eciToECR(lenG, asciiUTC, offsets(1:lenG), eciV, &
      ecrV)
d349 3
a351 3
    do i = 1, lenG
      sc_tp(:,i) = ecr(:,i) * slantRange(i)
    enddo
d353 4
a356 4
    do i = 1, lenG
      nts(:,i) = tp_sun(:,i) / sqrt( tp_sun(1,i)**2 + tp_sun(2,i)**2 + &
        &tp_sun(3,i)**2 )
    enddo
d358 2
a359 2
      nts(3,:)*unitAlt(3,:)
    tp%tpSolarZenith = acos(dot) * Rad2Deg
d362 9
a370 9
    do i = 1, lenG
      vECR(:,i) = ecr(:,i) - ( ecr(1,i)*unitAlt(1,i) + &
        &ecr(2,i)*unitAlt(2,i) + ecr(3,i)*unitAlt(3,i) )
      hECR(:,i) = vECR(:,i) / sqrt(vECR(1,i)**2 + vECR(2,i)**2 + &
        &vECR(3,i)**2)
    enddo
    los = acos( hECR(1,:)*unitLat(1,:) + hECR(2,:)*unitLat(2,:) + &
      &hECR(3,:)*unitLat(3,:) )
    sign = ecr(1,:)*unitLon(1,:) + ecr(2,:)*unitLon(2,:) + &
d372 3
a374 3
    do i = 1, lenG
      if (sign(i) < 0 ) los(i) = 2*PI - los(i)
    enddo
d384 9
d394 1
a394 1
    returnStatus = Pgs_csc_eciToOrb(spacecraftId, lenG, asciiUTC, &
d399 2
a400 2
    do i = 1, lenG
      tp%tpGeocAlt(i) = sqrt( tp%tpECR(1,i)**2 + tp%tpECR(2,i)**2 + &
d402 3
a404 3
      tp%tpGeocLat(i) = Rad2Deg * atan( tp%tpECR(3,i) &
        &/ sqrt( tp%tpECR(1,i)**2 + tp%tpECR(2,i)**2 ) )
    enddo
d408 1
a408 1
    do i = 2, lenG
d413 1
a413 1
    enddo
d417 1
a417 1
  end subroutine TkL1B_tp
d420 1
a420 1
  subroutine Tp_unit (flagQ, lon, lat, alt, delta, unitQ, flag)
d424 4
a427 4
    integer, intent(IN) :: flagQ
    real(r8), intent(IN) :: alt, delta, lat, lon
    integer, intent(OUT) :: flag
    real(r8), intent(OUT) :: unitQ(3)
d430 1
a430 1
    integer :: Pgs_csc_geoToECR
d433 5
a437 5
    character (LEN=32) :: mnemonic
    character (LEN=480) :: msg, msr
    integer :: returnStatus
    real(r8) :: del, geoMinus, geoPlus
    real(r8) :: ecrMinus(3), ecrPlus(3), vec(3)
d444 1
a444 1
    if (flagQ == 2) then
d449 3
a451 3
      if (geoPlus  >  PI) geoPlus  = geoPlus  - 2*PI
      if (geoMinus < -PI) geoMinus = geoMinus + 2*PI
      returnStatus = Pgs_csc_geoToECR(geoPlus, lat, alt, earthModel, &
d453 1
a453 1
      returnStatus = Pgs_csc_geoToECR(geoMinus, lat, alt, earthModel, &
d455 1
a455 1
    else if (flagQ == 1) then
d460 1
a460 1
      returnStatus = Pgs_csc_geoToECR(lon, geoPlus, alt, earthModel, &
d462 1
a462 1
      returnStatus = Pgs_csc_geoToECR(lon, geoMinus, alt, earthModel, &
d464 1
a464 1
    else
d467 1
a467 1
      returnStatus = Pgs_csc_geoToECR(lon, lat, geoPlus, earthModel, &
d469 1
a469 1
      returnStatus = Pgs_csc_geoToECR(lon, lat, geoMinus, earthModel, &
d471 1
a471 1
    endif
d473 2
a474 2
    if (returnStatus /= PGS_S_SUCCESS) then
      call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
d476 1
a476 1
      call MLSMessage(MLSMSG_Warning, ModuleName, msr)
d478 1
a478 1
    endif
d481 11
a491 3
    unitQ = vec / sqrt( vec(1)**2 + vec(2)**2 + vec(3)**2 )

  end subroutine Tp_unit
a492 4
  !--------------------------------------------------- L1BOA_MAF ----------------
  subroutine L1boa_MAF(altG, altT, ascTAI, counterMAF, dscTAI, L1FileHandle, &
    MAFinfo, noMAF, numOrb, orbIncline, orbitNumber, &
    scRate, scRateT, L1BFileInfo)
d496 2
d499 5
a503 8
    type (MAFinfo_T) :: MAFinfo
    TYPE (L1BFileInfo_T), intent(inout) :: L1BFileInfo
    integer, intent(IN) :: L1FileHandle, counterMAF, noMAF, numOrb
    integer, intent(IN) :: orbitNumber(:)
    real, intent(IN) :: scRate(:)
    real, intent(IN) :: scRateT(:)
    real(r8), intent(IN) :: altG, altT, orbIncline
    real(r8), intent(IN) :: ascTAI(:), dscTAI(:)
d506 1
a506 1
    integer :: Pgs_td_taiToUTC
d509 13
a521 9
    type( L1BOAindex_T ) :: index
    type( L1BOAsc_T ) :: sc
    type( L1BOAtp_T ) :: tp
    character (LEN=27) :: mafTime
    character (LEN=480) :: msr
    integer :: error, i, nV, returnStatus
    real(r8) :: mafTAI
    real(r8) :: initRay(3), q(3,MAFinfo%MIFsPerMAF)
    real(r8) :: offsets(MAFinfo%MIFsPerMAF)
a522 1
    ! Calculate offsets array
d525 3
a527 3
    do i = 1, nV 
      offsets(i) = (i-1)*MAFinfo%integTime
    enddo
d530 2
a531 1
    returnStatus = Pgs_td_taiToUTC(mafTAI, mafTime)
d537 1
a537 2
    call OutputL1B_index(noMAF, L1FileHandle, index)
!    call OutputL1B_index(L1BFileInfo, noMAF, L1FileHandle, index)
d541 143
a683 101
    allocate(sc%scGeocAlt(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c  GeocAlt quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(sc%scGeocLat(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c  GeocLat quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(sc%scGeodAlt(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c  GeodAlt quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate( sc%scGeodLat(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c GeodLat  quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate( sc%scLon(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c Lon quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(sc%scGeodAngle(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c GeodAngle quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(sc%scOrbIncl(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c OrbIncl quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%encoderAngle(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c encoder angle quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%scAngle(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c angle quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%scanAngle(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c scan angle quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%scanRate(nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c scan rate quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(sc%scECI(lenCoord,nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c ECI quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(sc%scECR(lenCoord,nV), STAT=error) 
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c ECR quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(sc%scVelECI(lenCoord,nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c VelECI quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(sc%scVelECR(lenCoord,nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c VelECR quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(sc%ypr(lenCoord,nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c ypr quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(sc%yprRate(lenCoord,nV), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c ypr rate quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d686 2
a687 1
    call TkL1B_sc(nV, offsets, mafTime, sc)
a689 1
    call Mc_aux(mafTime, offsets, sc%scECR, q )
d691 4
a694 3
    call TkL1B_mc(ascTAI, dscTAI, sc%scECR, nV, numOrb, &
      & orbIncline, orbitNumber, q, mafTAI, offsets, sc%scGeodAngle, &
      & sc%scOrbIncl)
d697 2
a698 2
!    call OutputL1B_sc(L1BFileInfo, noMAF, L1FileHandle, sc)
    call OutputL1B_sc(noMAF, L1FileHandle, sc)
d701 1
a701 1
    call Scan_guess(mafTime, initRay)
d705 127
a831 83
    allocate(tp%tpECI(lenCoord,lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: ECI'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpECR(lenCoord,lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: ECR'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpOrbY(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: OrbY'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeocAlt(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: GeocAlt'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeocLat(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: GeocLat'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeocAltRate(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: GeocAltRate'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeodAlt(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: GeodAlt'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeodLat(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: GeodLat'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeodAltRate(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: GeodAltRate'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpLon(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: Lon'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeodAngle(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: GeodAngle'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpSolarTime(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: SolarTime'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpSolarZenith(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: SolarZenith'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpLosAngle(lenG), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  GHz tp quantities: LosAngle'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d834 2
a835 1
    call Scan_start( altG, sc%scECR(:,1), mafTime, initRay, tp%scAngle(1) )
d838 13
a850 2
    call TkL1B_tp(mafTAI, mafTime, lenG, nV, offsets, sc%scECR(:,1:lenG), &
      scRate, tp%scAngle(1), tp)
d853 3
a855 3
    call TkL1B_mc(ascTAI, dscTAI, tp%tpECR, lenG, numOrb, &
      & orbIncline, orbitNumber, q, mafTAI, offsets(1:lenG), tp%tpGeodAngle, &
      & sc%scOrbIncl)
d859 1
a859 50
!    call OutputL1B_GHz(L1BFileInfo, noMAF, L1FileHandle, tp)
    call OutputL1B_GHz(noMAF, L1FileHandle, tp)

    deallocate(tp%tpECI, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: ECI')

    deallocate(tp%tpECR, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: ECR')

    deallocate(tp%tpOrbY, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: OrbY')

    deallocate(tp%tpGeocAlt, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: GeocAlt')

    deallocate(tp%tpGeocLat, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: GeocLat')

    deallocate(tp%tpGeocAltRate, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: GeocAltRate')

    deallocate(tp%tpGeodAltRate, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: GeodAltRate')

    deallocate(tp%tpLon, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: Lon')

    deallocate(tp%tpGeodAngle, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: GeodAngle')

    deallocate(tp%tpSolarTime, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: SolarTime')

    deallocate(tp%tpSolarZenith, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: SolarZenith')

    deallocate(tp%tpLosAngle, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
      &deallocation of GHz quantities: LosAngle')
d863 1
a863 83
    allocate(tp%tpECI(lenCoord,lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: ECI'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpECR(lenCoord,lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: ECR'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpOrbY(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: OrbY'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeocAlt(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: GeocAlt'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeocLat(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: GeocLat'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeocAltRate(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: GeocAltRate'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeodAlt(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: GeodAlt'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeodLat(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: GeodLat'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeodAltRate(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: GeodAltRate'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpLon(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: Lon'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpGeodAngle(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: GeodAngle'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpSolarTime(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: SolarTime'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpSolarZenith(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: SolarZenith'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    allocate(tp%tpLosAngle(lenT), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  THz tp quantities: LosAngle'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d865 1
a865 2
    ! Find angle, tan pt for start of THz scan
    call Scan_start(altT, sc%scECR(:,1), mafTime, initRay, tp%scAngle(1))
d867 12
a878 3
    ! Calculate THz tan pt record
    call TkL1B_tp(mafTAI, mafTime, lenT, nV, offsets, sc%scECR(:,1:lenT), &
      scRateT, tp%scAngle(1), tp)
d881 3
a883 3
    call TkL1B_mc(ascTAI, dscTAI, tp%tpECR, lenT, numOrb, &
      & orbIncline, orbitNumber, q, mafTAI, offsets(1:lenT), tp%tpGeodAngle, &
      & sc%scOrbIncl)
d887 1
a887 34
!    call OutputL1B_THz(L1BFileInfo, noMAF, L1FileHandle, tp)
    call OutputL1B_THz(noMAF, L1FileHandle, tp)

    deallocate(tp%tpECI, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpECR, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpOrbY, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpGeocAlt, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpGeocLat, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpGeocAltRate, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpGeodAltRate, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpGeodAlt, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')
d889 1
a889 95
    deallocate(tp%tpGeodLat, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpLon, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpGeodAngle, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpSolarTime, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpSolarZenith, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    deallocate(tp%tpLosAngle, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of THz quantities.')

    ! Deallocate the MIF quantities

    deallocate(sc%scECI, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scECI')

    deallocate(sc%scECR, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scECR')

    deallocate(sc%scGeocAlt, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scGeocAlt')

    deallocate(sc%scGeocLat, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scGeocLat')

    deallocate(sc%scGeodAlt, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scGeodAlt')

    deallocate(sc%scGeodLat, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scGeodLat')

    deallocate(sc%scLon, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scLon')

    deallocate(sc%scGeodAngle, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scGeodAngle')

    deallocate(sc%scVelECI, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scVelECI')

    deallocate(sc%scVelECR, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scVelECR')

    deallocate(sc%scOrbIncl, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scOrbIncl')

    deallocate(sc%ypr, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: ypr')

    deallocate(sc%yprRate, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: yprRate')

    deallocate(tp%encoderAngle, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: encoderAngle')

    deallocate(tp%scAngle, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scAngle')

    deallocate(tp%scanAngle, STAT=error)
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scanAngle')

    deallocate(tp%scanRate, STAT=error)   
    if ( error /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed deallocation of MIF quantities: scanRate')

  end subroutine L1boa_MAF
d892 5
a896 5
  subroutine Mc_aux (asciiUTC, offsets, scECR, q)
    ! This subroutine computes q, an auxilliary vector used in the calculation of
    ! the master coordinate.  Q is a vector that points from the center of the Earth
    ! to the ascending node of the orbit in ECI coordinates.  Thus any point
    ! dotted with q can give you the master coordinate.
d898 4
a901 4
    character (LEN=27), intent(IN) :: asciiUTC
    real(r8), intent(in) :: OFFSETS(:)
    real(r8), intent(IN) :: scECR(:,:)
    real(r8), intent(OUT) :: q(:,:)
d906 1
a906 1
    integer :: Pgs_csc_orbToECI, PGS_CSC_ECItoECR
d909 15
a923 15
    integer :: returnStatus
    integer :: nV
    real(r8), dimension(size(offsets)) :: l
    real(r8), dimension(size(offsets)) :: DIST1
    real(r8), dimension(size(offsets)) :: DIST2
    real(r8), dimension(3,size(offsets)) :: AECR
    real(r8), dimension(3,size(offsets)) :: AUX1
    real(r8), dimension(3,size(offsets)) :: AUX2
    real(r8), dimension(6,size(offsets)) :: AUX1ECI
    real(r8), dimension(6,size(offsets)) :: AUX2ECI
    real(r8), dimension(6,size(offsets)) :: AUX1ECR
    real(r8), dimension(6,size(offsets)) :: AUX2ECR
    real(r8), dimension(size(offsets)) :: QSIZE
    logical, dimension(size(offsets)) :: SMALL1
    logical, dimension(size(offsets)) :: SMALL2
d926 1
a926 1
    nV = size(offsets)
d938 1
a938 1
    returnStatus = Pgs_csc_orbToECI(spacecraftId, nV, asciiUTC, &
d940 1
a940 1
    returnStatus = Pgs_csc_orbToECI(spacecraftId, nV, asciiUTC, &
d946 1
a946 1
    returnStatus = Pgs_csc_ECItoECR(nV, asciiUTC, offsets, &
d948 1
a948 1
    returnStatus = Pgs_csc_ECItoECR(nV, asciiUTC, offsets, &
d951 8
a958 8
    ! Define l & a, where l is the distance to the equator along the direction of
    ! one of the auxilliary vectors from the s/c, and a is the auxilliary vector
    ! for which l was defined.

    small1 = abs(aux1ECR(3,:)) < sqrt( tiny(0.0_r8) )
    small2 = abs(aux2ECR(3,:)) < sqrt( tiny(0.0_r8) )
    if ( any ( small1 .and. small2 ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d960 1
a960 1
    end if
d962 3
a964 2
    where ( small1 )
      ! If aux1 has a zero z-component, set l & a for aux2, if its z-component /= 0
d969 1
a969 1
    elsewhere ( small2 )
d975 1
a975 1
    elsewhere
d980 1
a980 1
      where ( abs(dist1) < abs(dist2) )
d985 1
a985 1
      elsewhere
d990 2
a991 2
      end where
    end where
d999 2
a1000 2
    where ( ( (scECR(3,:) < 0.0) .and. (l < 0.0) ) .or. &
      &     ( (scECR(3,:) >= 0.0) .and. (l >= 0.0) ) )
d1003 1
a1003 1
    end where 
d1006 1
a1006 1
    qSize = sqrt( q(1,:)**2 + q(2,:)**2 ) 
d1011 1
a1011 1
  end subroutine Mc_aux
d1013 2
a1014 2
  !----------------------------------------------------orbInclineCalculated -----------------
  function orbInclineCalculated( scECR, scVelECR , lambda, mu)
d1026 5
a1030 5
    real(r8), intent(IN) :: scECR(3)             ! s/c pos.
    real(r8), intent(IN) :: scVelECR(3)          ! s/c vel.
    real, intent(IN) ::     lambda               ! s/c geocentric latitude
    real, intent(IN) ::     mu                   ! s/c longitude
    real(r8) ::             orbInclineCalculated
d1033 5
a1037 5
    logical, parameter :: DEBUG = .FALSE.
    integer, save :: HOWMANYSOFAR=0
    real(r8) :: vUnrotated(3)          ! s/c vel.
    real(r8) :: v
    real :: muRad, lamRad
d1044 1
a1044 1
    v = sqrt( vUnrotated(1)**2 + vUnrotated(2)**2 + vUnrotated(3)**2 )
d1047 1
a1047 1
    if ( v == 0.d0 ) then
d1049 4
a1052 7
      return
    endif
    orbInclineCalculated = (180/Pi) * asin( &
    & cos(lamRad) * (vUnrotated(2)*cos(muRad) - vUnrotated(1)*sin(muRad)) &
    & / &
    & v &
    & )
d1057 2
a1058 2
    orbInclineCalculated = abs(orbInclineCalculated) + 90
    if ( orbInclineCalculated < 90.d0 ) then
d1060 1
a1060 1
    elseif (orbInclineCalculated > 180.d0 ) then
d1062 1
a1062 1
    endif
d1064 15
a1078 15
    if ( DEBUG ) then
      call output('vx, vy, vz ', advance='no')
      call blanks(3, advance='no')
      call output(scVelECR, advance='yes')
      call output('lambda ', advance='no')
      call blanks(3, advance='no')
      call output(lambda, advance='no')
      call blanks(3, advance='no')
      call output('mu ', advance='no')
      call blanks(3, advance='no')
      call output(mu, advance='yes')
      call output('orbital inclination ', advance='no')
      call blanks(3, advance='no')
      call output((180/Pi) * asin( &
       & cos(lamRad) * (vUnrotated(2)*cos(muRad) - vUnrotated(1)*sin(muRad)) &
d1082 4
a1085 4
      call blanks(3, advance='no')
      call output(orbInclineCalculated, advance='yes')
      if ( HOWMANYSOFAR > 40 ) stop
    endif
d1087 1
a1087 1
  end function orbInclineCalculated
d1089 2
a1090 2
  !----------------------------------------------------orbInclineCrossProd -----------------
  function orbInclineCrossProd( scECI, scVelECI )
d1100 2
a1101 1
    ! [omega] = [p] / r^2 = omega (sin_beta cos_alfa, sin_beta sin_alfa, cos_beta)
d1103 3
a1105 3
    real(r8), intent(IN) :: scECI(3)             ! s/c pos.
    real(r8), intent(IN) :: scVelECI(3)          ! s/c vel.
    real(r8) :: orbInclineCrossProd
d1108 3
a1110 3
    logical, parameter :: DEBUG = .FALSE.
    integer, save :: HOWMANYSOFAR=0
    real(r8) :: orbMoment(3), OMagnitude
d1117 2
a1118 2
    OMagnitude = sqrt( orbMoment(1)**2 + orbMoment(2)**2 + orbMoment(3)**2 )
    if ( OMagnitude == 0.d0 ) then
d1120 3
a1122 3
      return
    endif
    orbInclineCrossProd = (180/Pi) * acos( orbMoment(3) / OMagnitude )
d1125 2
a1126 2
    orbInclineCrossProd = abs(orbInclineCrossProd)
    if ( orbInclineCrossProd < 90.d0 ) then
d1128 1
a1128 1
    elseif (orbInclineCrossProd > 180.d0 ) then
d1130 1
a1130 1
    endif
d1132 22
a1153 23
    if ( DEBUG ) then
      call output('rx, ry, rz ', advance='no')
      call blanks(3, advance='no')
      call output(scECI, advance='yes')
      call output('vx, vy, vz ', advance='no')
      call blanks(3, advance='no')
      call output(scVelECI, advance='yes')
      call output('px, py, pz ', advance='no')
      call blanks(3, advance='no')
      call output(orbMoment, advance='yes')
      call output('orbital inclination ', advance='no')
      call blanks(3, advance='no')
      call output((180/Pi) * acos( orbMoment(3) / OMagnitude ), advance='no')
      call blanks(3, advance='no')
      call output(orbInclineCrossProd, advance='yes')
      if ( HOWMANYSOFAR > 40 ) stop
    endif
  end function orbInclineCrossProd

  !----------------------------------------------------TkL1B_mc -----------------
  subroutine TkL1B_mc(ascTAI, dscTAI, dotVec, nV, numOrb, &
    orbIncline, orbitNumber, q, timeTAI, time_offset, geodAngle, &
    & scOrbIncl)
d1157 8
a1164 9
    integer, intent(IN) :: nV, numOrb
    integer, intent(IN) :: orbitNumber(:)
    real(r8), intent(IN) :: orbIncline, timeTAI
    real(r8), intent(IN) :: q(3,nV)
    real(r8), intent(IN) :: time_offset(nV)
    real(r8), intent(IN) :: ascTAI(:), dscTAI(:)
    real(r8), intent(IN) :: dotVec(3,nV)
    real, intent(OUT) ::    geodAngle(nV)
    real, intent(in) ::     scOrbIncl(nV)
d1169 1
a1169 1
    integer :: Pgs_csc_getEarthFigure
d1172 1
a1172 1
    integer :: i, j, returnStatus, scOrb
d1174 4
a1177 4
    real(r8) :: a, asciiTAI, b, cSq, equatRad_a, orbRad, phiMin, polarRad_c
    real(r8) :: cosPhi(nV), gamma(nV), phi(nV), sinPhi(nV)
    real(r8) :: s(3,nV)
    real(r8) :: orbInclineNow
d1182 1
a1182 1
    returnStatus = Pgs_csc_getEarthFigure(earthModel, equatRad_a, polarRad_c)
d1187 1
a1187 1
    do i = 1, nV
d1190 2
a1191 2
      if ( orbInclineNow == UNDEFINED_VALUE ) then
        call MLSMessage(MLSMSG_Error, ModuleName, &
d1193 1
a1193 1
      endif
d1196 1
a1196 1
      s(:,i) = dotVec(:,i) / sqrt(dotVec(1,i)**2 + dotVec(2,i)**2 + &
d1200 1
a1200 1
      gamma(i) = acos( q(1,i)*s(1,i) + q(2,i)*s(2,i) )
d1203 1
a1203 1
      if ( dotVec(3,i) < 0.0 ) gamma(i) = 2*PI - gamma(i)
d1207 2
a1208 2
      cSq = (1 + (tan(orbRad)**2)) * (a**2)*(b**2) / &
        & ( a**2 + (b**2)*(tan(orbRad)**2) )
d1210 14
a1223 12
      ! If |gamma| <= 45 deg of the equator, calculate phi using the SIN equation
      if ( (gamma(i) <= PI/4 ) .or. ( (gamma(i) >= 3*PI/4) .and. &
        & (gamma(i) <= 5*PI/4) ) .or. (gamma(i) >= 7*PI/4) ) then
        sinPhi(i) = sqrt( (a**4)*(sin(gamma(i))**2)/( (cSq**2)*&
          &(cos(gamma(i))**2) + (a**4)*(sin(gamma(i))**2) ) )
        phi(i) = asin(sinPhi(i))
      else
        ! If gamma is within 45 deg of a pole, calculate phi using the COS equation
        cosPhi(i) = sqrt( (cSq**2)*(cos(gamma(i))**2)/( (cSq**2)*&
          &cos(gamma(i))**2 + (a**4)*(sin(gamma(i))**2) ) )
        phi(i) = acos(cosPhi(i))
      endif
d1226 3
a1228 3
      if ( (gamma(i) > PI/2) .and. (gamma(i) <= PI) ) phi(i) = PI - phi(i)
      if ( (gamma(i) > PI) .and. (gamma(i) <= 3*PI/2) ) phi(i) = phi(i) + PI
      if ( gamma(i) > 3*PI/2 ) phi(i) = 2*PI - phi(i)
d1237 1
a1237 1
      if ( ( phi(i) < pi/2 ) .or. ( phi(i) >= 3*pi/2 ) ) then
d1241 4
a1244 3
        do j = 1, numOrb
          if ( asciiTAI > dscTAI(j) ) scOrb = j
        enddo
d1246 2
a1247 2
        if ( phi(i) < pi ) scOrb = scOrb + 1
      else
d1251 5
a1255 4
        do j = 1, numOrb
          if ( asciiTAI > ascTAI(j) ) scOrb = j
        enddo
      end if
d1258 1
a1258 1
    enddo
d1263 15
a1277 1
  end subroutine TkL1B_mc
d1279 20
a1298 1
end module TkL1B
d1301 3
a1343 1

@


2.10
log
@Get Omega from Geometry instead of Units
@
text
@d13 2
a14 2
  use OutputL1B, only: L1BOAsc_T, L1BOATP_T, L1BOAINDEX_T, LENCOORD, &
    OUTPUTL1B_THZ, OUTPUTL1B_SC, OUTPUTL1B_INDEX, OUTPUTL1B_GHZ, LENG, LENT
d27 1
a27 1
    & "$Id: TkL1B.f90,v 2.9 2002/03/29 20:18:34 perun Exp $"
d347 1
a347 1
    scRate, scRateT)
d353 1
d388 1
d390 1
d393 50
a442 7
    allocate(sc%scECI(lenCoord,nV), sc%scECR(lenCoord,nV), &
      sc%scGeocAlt(nV), sc%scGeocLat(nV), sc%scGeodAlt(nV), &
      sc%scGeodLat(nV), sc%scLon(nV), sc%scGeodAngle(nV), sc%scOrbIncl(nV), &
      sc%scVelECI(lenCoord,nV), sc%ypr(lenCoord,nV), sc%yprRate(lenCoord,nV), &
      sc%scVelECR(lenCoord,nV), &
      tp%encoderAngle(nV), tp%scAngle(nV), tp%scanAngle(nV), &
      tp%scanRate(nV), STAT=error)
d444 49
a492 1
      msr = MLSMSG_Allocate // '  s/c quantities.'
d507 1
d515 31
a545 6
    allocate(tp%tpECI(lenCoord,lenG), tp%tpECR(lenCoord,lenG), &
      tp%tpOrbY(lenG), tp%tpGeocAlt(lenG), tp%tpGeocLat(lenG), &
      tp%tpGeocAltRate(lenG), tp%tpGeodAlt(lenG), &
      tp%tpGeodLat(lenG), tp%tpGeodAltRate(lenG), tp%tpLon(lenG), &
      tp%tpGeodAngle(lenG), tp%tpSolarTime(lenG), &
      tp%tpSolarZenith(lenG), tp%tpLosAngle(lenG), STAT=error)
d547 49
a595 1
      msr = MLSMSG_Allocate // '  GHz tp quantities.'
d612 2
d616 29
a644 4
    deallocate(tp%tpECI, tp%tpECR, tp%tpOrbY, tp%tpGeocAlt, tp%tpGeocLat, &
      tp%tpGeocAltRate, tp%tpGeodAlt, tp%tpGeodLat, &
      tp%tpGeodAltRate, tp%tpLon, tp%tpGeodAngle, tp%tpSolarTime, &
      tp%tpSolarZenith, tp%tpLosAngle, STAT=error)
d646 17
a662 1
      &deallocation of GHz quantities.')
d665 20
a684 6
    allocate(tp%tpECI(lenCoord,lenT), tp%tpECR(lenCoord,lenT), &
      tp%tpOrbY(lenT), tp%tpGeocAlt(lenT), tp%tpGeocLat(lenT), &
      tp%tpGeocAltRate(lenT), tp%tpGeodAlt(lenT), &
      tp%tpGeodLat(lenT), tp%tpGeodAltRate(lenT), tp%tpLon(lenT), &
      tp%tpGeodAngle(lenT), tp%tpSolarTime(lenT), &
      tp%tpSolarZenith(lenT), tp%tpLosAngle(lenT), STAT=error)
d686 61
a746 1
      msr = MLSMSG_Allocate // '  THz tp quantities.'
d763 2
d767 53
a819 4
    deallocate(tp%tpECI, tp%tpECR, tp%tpOrbY, tp%tpGeocAlt, tp%tpGeocLat, &
      tp%tpGeocAltRate, tp%tpGeodAlt, tp%tpGeodLat, &
      tp%tpGeodAltRate, tp%tpLon, tp%tpGeodAngle, tp%tpSolarTime, &
      tp%tpSolarZenith, tp%tpLosAngle, STAT=error)
d824 66
a889 4
    deallocate(sc%scECI, sc%scECR, sc%scGeocAlt, sc%scGeocLat, &
      sc%scGeodAlt, sc%scGeodLat, sc%scLon, sc%scGeodAngle, sc%scVelECI, &
      sc%scOrbIncl, sc%ypr, sc%yprRate, tp%encoderAngle, tp%scAngle, &
      tp%scanAngle, tp%scanRate, STAT=error)
d891 1
a891 1
      & 'Failed deallocation of MIF quantities.')
d1271 3
@


2.9
log
@Version 1.0 commit
@
text
@d8 1
d17 1
a17 1
  use units, only: Omega
d26 3
a28 2
  character(LEN=130) :: Id = &
    "$Id: TkL1B.f90,v 2.8 2001/12/14 01:43:46 livesey Exp $"
d873 3
@


2.8
log
@Working version with ECR based master coordinate
@
text
@d26 1
a26 1
    "$Id: TkL1B.f90,v 2.7 2001/12/12 19:05:44 livesey Exp $"
d96 1
d177 1
d610 1
d871 3
@


2.7
log
@Fixed bug with master coordinate for very low latitudes.
However, this version it turns out is basing master coordinate
on the ECI orbital node, not ECR which I think is what we really
want. So expect another version soon!
@
text
@d6 2
d26 1
a26 1
    "$Id: TkL1B.f90,v 2.6 2001/12/12 03:07:32 livesey Exp $"
d367 1
a367 1
    real(r8) :: initRay(3), q(3)
d402 3
a404 2
    call Mc_aux(mafTime, sc%scECI(:,1), q)
    call TkL1B_mc(ascTAI, dscTAI, sc%scECI, nV, numOrb, &
d435 1
a435 1
    call TkL1B_mc(ascTAI, dscTAI, tp%tpECI, lenG, numOrb, &
d469 1
a469 1
    call TkL1B_mc(ascTAI, dscTAI, tp%tpECI, lenT, numOrb, &
d494 1
a494 1
  subroutine Mc_aux (asciiUTC, scECI, q)
d501 3
a503 2
    real(r8), intent(IN) :: scECI(3)
    real(r8), intent(OUT) :: q(3)
a505 2
    integer, parameter :: nV = 1
    real(r8), parameter :: time_offset = 0.0
d508 1
a508 1
    integer :: Pgs_csc_orbToECI
d512 14
a525 3
    real(r8) :: l
    real(r8) :: dist(2)
    real(r8) :: aECI(3), aux1(3), aux1ECI(3), aux2(3), aux2ECI(3)
d528 1
d532 6
a537 6
    aux1(1) = 1.0
    aux1(2) = 0.0
    aux1(3) = 0.0
    aux2(1) = 1.0
    aux2(2) = 0.0
    aux2(3) = 1.0
d541 1
a541 1
      time_offset, aux1, aux1ECI)
d543 9
a551 1
      time_offset, aux2, aux2ECI)
d556 9
a564 1
    if ( abs(aux1ECI(3)) < sqrt( tiny(aux1ECI(3)) ) ) then
d566 5
a570 8
      if ( abs(aux2ECI(3)) > sqrt( tiny(aux2ECI(3)) ) ) then
        l = -scECI(3)/aux2ECI(3)
        aECI = aux2ECI
      else
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Problem computing auxilliary vector for master coordinate' )
      end if
    else if ( abs(aux2ECI(3)) < sqrt( tiny(aux2ECI(3)) ) ) then
d572 5
a576 3
      l = -scECI(3)/aux1ECI(3)
      aECI = aux1ECI
    else
d579 19
a597 14
      dist(1) = -scECI(3)/aux1ECI(3)
      dist(2) = -scECI(3)/aux2ECI(3)
      if ( abs(dist(1)) < abs(dist(2)) ) then
        l = dist(1)
        aECI = aux1ECI
      else
        l = dist(2)
        aECI = aux2ECI
      endif
    endif

    ! Define the vector q = scECI + la, such that its z-component = 0
    q(1:2) = scECI(1:2) + l*aECI(1:2)
    q(3) = 0.0
d600 5
a604 5
    if ( scECI(3) < 0.0 ) then
      if ( l < 0 ) q = -q
    else
      if ( l > 0 ) q = -q
    endif
d607 3
a609 1
    q = q / sqrt( q(1)**2 + q(2)**2 )
d763 1
a763 1
    real(r8), intent(IN) :: q(3)
d804 1
a804 5
      gamma(i) = acos( q(1)*s(1,i) + q(2)*s(2,i) )
      if ( i == 1 ) then
        print*,'q:',q(1),q(2)
        print*,'Gamma: ', gamma(i)
      end if
d811 2
a812 2
      cSq = (1 + (tan(orbRad)**2)) * (a**2)*(b**2)/(a**2 + &
        &(b**2)*(tan(orbRad)**2))
d816 1
a816 1
        &(gamma(i) <= 5*PI/4) ) .or. (gamma(i) >= 7*PI/4) ) then
d833 1
d835 13
a847 6
      do j = 1, numOrb
        if ( asciiTAI > ascTAI(j) ) scOrb = orbitNumber(j)
      enddo
      phi(i) = (scOrb-1)*2*PI + phi(i)
      if ( asciiTAI > dscTAI(scOrb+1) ) then
        phiMin = scOrb*2*PI - PI
d849 9
a857 3
        phiMin = (scOrb-1)*2*PI - PI
      endif
      if ( phi(i) < phiMin ) phi(i) = phi(i) + 2*PI
d868 6
@


2.6
log
@Interim version needs debugging more
@
text
@d24 1
a24 1
    "$Id: TkL1B.f90,v 2.5 2001/12/11 00:55:51 livesey Exp $"
d400 2
a401 2
    call Mc_aux(mafTime, sc%scECI(:,1), sc%scGeocLat(1), q)
    call TkL1B_mc(ascTAI, dscTAI, sc%scECI, sc%scGeocLat, nV, numOrb, &
d432 1
a432 1
    call TkL1B_mc(ascTAI, dscTAI, tp%tpECI, tp%tpGeocLat, lenG, numOrb, &
d466 1
a466 1
    call TkL1B_mc(ascTAI, dscTAI, tp%tpECI, tp%tpGeocLat, lenT, numOrb, &
d491 1
a491 1
  subroutine Mc_aux (asciiUTC, scECI, scGeocLat, q)
d493 3
a495 1
    ! the master coordinate.
a497 1
    real, intent(IN) :: scGeocLat
d534 1
a534 1
    if ( aux1ECI(3) == 0 ) then
d536 1
a536 1
      if ( aux2ECI(3) /= 0 ) then
d539 8
a546 1
      endif
d548 6
a553 4

      ! If aux1(3) is not zero, but aux2(3) is, then set l & a for aux1
      if ( aux2ECI(3) == 0 ) then
        l = -scECI(3)/aux1ECI(3)
d556 2
a557 11
        ! If both aux1(3) and aux2(3) are non-zero, choose the one which gives the
        ! minimum absolute value of l.
        dist(1) = -scECI(3)/aux1ECI(3)
        dist(2) = -scECI(3)/aux2ECI(3)
        if ( abs(dist(1)) < abs(dist(2)) ) then
          l = dist(1)
          aECI = aux1ECI
        else
          l = dist(2)
          aECI = aux2ECI
        endif
d566 1
a566 1
    if ( scGeocLat < 0.0 ) then
d718 1
a718 1
  subroutine TkL1B_mc(ascTAI, dscTAI, dotVec, geocLat, nV, numOrb, &
a725 1
    real, intent(IN) ::    geocLat(nV)
a761 4
      ! Calculate C-squared
      orbRad= Deg2Rad * (orbInclineNow - 90)
      cSq = (1 + (tan(orbRad)**2)) * (a**2)*(b**2)/(a**2 + &
        &(b**2)*(tan(orbRad)**2))
d763 1
d765 2
a766 2
        &dotVec(3,i)**2)

d770 1
a770 1
        print*,'Dot product: ',q(1)*s(1,i) + q(2)*s(2,i)
d773 8
a780 2
      ! Place angle between PI and 2*PI, if lat indicates Southern Hemisphere
      if ( geocLat(i) < 0.0 ) gamma(i) = 2*PI - gamma(i)
d822 3
@


2.5
log
@Slightly kludgy fix for problem where occasionally gets
phi 180 degrees out.
@
text
@d24 1
a24 1
    "$Id: TkL1B.f90,v 2.4 2001/12/07 00:51:44 pwagner Exp $"
d772 3
a774 14
      ! There is a really nasty ambiguity in the case where gamma==0.0, and
      ! believe it it or not, it does actually seem to occur from time to time.
      ! We'll get the information from and adjacent mif
      ! Not sure why, but 1e-6 is too small to catch the case of interest.
      if ( abs(gamma(i)) < 1e-3 ) then 
        if ( i /= 1 ) then
          j = i - 1
        else
          j = i + 2
        end if
        if ( geocLat(j) < 0.0 ) gamma(i) = PI
      else
        ! Place angle between PI and 2*PI, if lat indicates Southern Hemisphere
        if ( geocLat(i) < 0.0 ) gamma(i) = 2*PI - gamma(i)
d776 2
d819 4
@


2.4
log
@Finally calculates scOrbIncl correctly
@
text
@d24 1
a24 1
    "$Id: TkL1B.f90,v 2.3 2001/12/06 01:03:46 pwagner Exp $"
d772 15
a786 3

      ! Place angle between PI and 2*PI, if lat indicates Southern Hemisphere
      if ( geocLat(i) < 0.0 ) gamma(i) = 2*PI - gamma(i)
d802 2
a803 2
      if ( (gamma(i) > PI/2) .and. (gamma(i) < PI) ) phi(i) = PI - phi(i)
      if ( (gamma(i) > PI) .and. (gamma(i) < 3*PI/2) ) phi(i) = phi(i) + PI
d828 3
@


2.3
log
@Now writes orbit incline angle in ECR
@
text
@d14 1
d24 1
a24 1
    "$Id: TkL1B.f90,v 2.2 2001/10/12 22:11:05 livesey Exp $"
d86 6
a91 1
      sc%scOrbIncl(i) = orbInclineCalculated(sc%scECI(:,i), sc%scVelECI(:,i))
d577 80
a656 1
  function orbInclineCalculated( scECR, scVelECR )
d659 1
a659 1
    ! Method: let [r] be the vector of the s/c position (in ECR coords)
d668 5
a672 3
    real(r8), intent(IN) :: scECR(3)             ! s/c pos.
    real(r8), intent(IN) :: scVelECR(3)          ! s/c vel.
    real(r8) :: orbInclineCalculated
a674 3

    ! Variables

d679 3
a681 3
    orbMoment(1) = scECR(2)*scVelECR(3) - scECR(3)*scVelECR(2)
    orbMoment(2) = scECR(3)*scVelECR(1) - scECR(1)*scVelECR(3)
    orbMoment(3) = scECR(1)*scVelECR(2) - scECR(2)*scVelECR(1)
d684 1
a684 1
      orbInclineCalculated = UNDEFINED_VALUE
d687 1
a687 1
    orbInclineCalculated = (180/Pi) * acos( orbMoment(3) / OMagnitude )
d690 5
a694 5
    orbInclineCalculated = abs(orbInclineCalculated)
    if ( orbInclineCalculated < 90.d0 ) then
      orbInclineCalculated = 180. - orbInclineCalculated
    elseif (orbInclineCalculated > 180.d0 ) then
      orbInclineCalculated = 360. - orbInclineCalculated
d700 1
a700 1
      call output(scECR, advance='yes')
d703 1
a703 1
      call output(scVelECR, advance='yes')
d711 1
a711 1
      call output(orbInclineCalculated, advance='yes')
d714 1
a714 1
  end function orbInclineCalculated
d757 1
a757 7
      if ( ORBINCLINE_IS_CONSTANT ) then
        orbInclineNow = orbIncline
      else
!        orbInclineNow = orbInclineCalculated(scECR(:,i), scVelECR(:,i))
        orbInclineNow = scOrbIncl(i)
      endif
      
d816 3
@


2.2
log
@Tidied things up a bit, added scVelECR, but not filled yet
@
text
@d1 1
a1 1
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
d8 2
a9 1
  use MLSMessageModule, only: MLSMESSAGE
d18 2
d23 1
a23 1
    "$Id: TkL1B.f90,v 2.1 2001/02/23 18:26:11 perun Exp $"
a54 1
    real(r8) :: xyDist
d70 1
a70 1
    eciV(4:6,:) = 0.0
d73 1
d85 1
d112 1
a112 1
    integer :: error, flag, flagQ, i, returnStatus
d380 1
a380 1
      sc%scGeodLat(nV), sc%scLon(nV), sc%scGeodAngle(nV), &
d382 1
d396 2
a397 1
      orbIncline, orbitNumber, q, mafTAI, offsets, sc%scGeodAngle)
d427 2
a428 1
      orbIncline, orbitNumber, q, mafTAI, offsets(1:lenG), tp%tpGeodAngle)
d461 2
a462 1
      orbIncline, orbitNumber, q, mafTAI, offsets(1:lenT), tp%tpGeodAngle)
d476 3
a478 3
      sc%scGeodAlt, sc%scGeodLat, sc%scLon, sc%scGeodAngle,  sc%scVelECI, &
      sc%ypr, sc%yprRate, tp%encoderAngle, tp%scAngle, tp%scanAngle, &
      tp%scanRate, STAT=error)
d502 1
a502 1
    integer :: i, returnStatus
d570 62
d634 2
a635 1
    orbIncline, orbitNumber, q, timeTAI, time_offset, geodAngle)
d641 1
a641 1
    real, intent(IN) :: geocLat(nV)
d647 4
a650 1
    real, intent(OUT) :: geodAngle(nV)
d661 1
a669 5
    ! Calculate C-squared
    orbRad= Deg2Rad * (orbIncline - 90)
    cSq = (1 + (tan(orbRad)**2)) * (a**2)*(b**2)/(a**2 + &
      &(b**2)*(tan(orbRad)**2))

d672 17
d738 3
@


2.1
log
@Version 0.5 commit
@
text
@a0 1

d4 1
a4 868
!===============================================================================
MODULE TkL1B
!===============================================================================

   USE MLSCommon
   USE MLSL1Common
   USE MLSMessageModule
   USE OutputL1B, ONLY: L1BOAsc_T, L1BOATP_T, L1BOAINDEX_T, lenCoord, &
        OutputL1B_THz, OutputL1B_SC, OutputL1B_Index, OutputL1B_GHz, lenG, lenT
   USE Scan
   USE SDPToolkit
   IMPLICIT NONE
   PUBLIC

   PRIVATE :: ID, ModuleName

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &
   "$Id: TkL1B.f90,v 2.0 2000/09/05 18:55:15 ahanzel Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: TkL1B.f90,v $"
!----------------------------------------------------------

! Contents:

! Subroutines -- TkL1B_sc
!                TkL1B_tp
!                Tp_unit
!                L1boa_MAF
!                Mc_aux
!                TkL1B_mc

! Remarks:  This module contains subroutines for producing the L1BOA records on
!           a MAF by MAF basis.

CONTAINS

!-------------------------------------------------------
   SUBROUTINE TkL1B_sc(numValues, offsets, asciiUTC, sc)
!-------------------------------------------------------

! Brief description of subroutine
! This subroutine contains prototype code for creating the desired s/c record
! from the EPHEMATTIT output.

! Arguments

      TYPE( L1BOAsc_T ) :: sc

      CHARACTER (LEN=27), INTENT(IN) :: asciiUTC

      INTEGER, INTENT(IN) :: numValues

      REAL(r8), INTENT(IN) :: offsets(numValues)

! Functions

      INTEGER :: Pgs_csc_eciToECR, Pgs_csc_ecrToGEO, Pgs_eph_ephemAttit

! Variables

      CHARACTER (LEN=32) :: mnemonic
      CHARACTER (LEN=480) :: msg, msr

      INTEGER :: i, returnStatus
      INTEGER :: qualityFlags(2, numValues)

      REAL(r8) :: ecrVec(3)
      REAL(r8) :: radC(numValues), radD(numValues), radL(numValues)
      REAL(r8) :: attitQuat(4,numValues)
      REAL(r8) :: eciV(6,numValues), ecrV(6,numValues)

! Read oa data

      returnStatus = Pgs_eph_ephemAttit (spacecraftId, numValues, asciiUTC,  &
                             offsets, pgs_true, pgs_true, qualityFlags, &
                             sc%scECI, sc%scVel, sc%ypr, sc%yprRate, attitQuat)
      IF (returnStatus /= PGS_S_SUCCESS) THEN
         call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
         msr = 'Routine ephemAttit, ' // mnemonic // ':  ' // msg
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Convert scECI to scECR

      eciV(1:3,:) = sc%scECI
      eciV(4:6,:) = 0.0

      returnStatus = Pgs_csc_eciToECR (numValues, asciiUTC, offsets, eciV, ecrV)

      sc%scECR = ecrV(1:3,:)
   
! Calculate geocentric/geodetic altitude, latitude & longitude from scECR

      DO i = 1, numValues

         sc%scGeocAlt(i) = SQRT( ecrV(1,i)**2 + ecrV(2,i)**2 + ecrV(3,i)**2 )

         radC(i) = ATAN( ecrV(3,i) / SQRT(ecrV(1,i)**2 + ecrV(2,i)**2) )
         sc%scGeocLat(i) = Rad2Deg * radC(i)

         ecrVec = ecrV(1:3, i)

         returnStatus = Pgs_csc_ecrToGEO (ecrVec, earthModel, radL(i), &
                                          radD(i), sc%scGeodAlt(i))

         sc%scGeodLat(i) = Rad2Deg * radD(i)
         sc%scLon(i) = Rad2Deg * radL(i)

      ENDDO

!-------------------------
   END SUBROUTINE TkL1B_sc
!-------------------------

!-----------------------------------------------------------------------------
   SUBROUTINE TkL1B_tp(asciiTAI, asciiUTC, lenG, numValues, offsets, posECR, &
                       scRate, startAngle, tp)
!-----------------------------------------------------------------------------

! Brief description of subroutine
! This subroutine fills the tangent point record.

! Arguments

      TYPE( L1BOAtp_T ) :: tp

      CHARACTER (LEN=27), INTENT(IN) :: asciiUTC

      INTEGER, INTENT(IN) :: lenG, numValues

      REAL, INTENT(IN) :: scRate(lenG)

      REAL(r8), INTENT(IN) :: asciiTAI, startAngle
      REAL(r8), INTENT(IN) :: offsets(numValues)
      REAL(r8), INTENT(IN) :: posECR(3,lenG)

! Parameters

! Functions

      INTEGER :: Pgs_cbp_sat_cb_vector, Pgs_cbp_solarTimeCoords
      INTEGER :: Pgs_csc_scToOrb, Pgs_csc_scToECI, Pgs_csc_eciToECR
      INTEGER :: Pgs_csc_grazingRay, Pgs_csc_ecrToECI, Pgs_csc_eciToOrb
      INTEGER :: Pgs_td_taiToUTC

! Variables

      CHARACTER (LEN=27) :: time

      INTEGER :: error, flag, flagQ, i, returnStatus

      REAL(r8) :: declination, delAngle, delTime, deltaAlt, deltaLat, deltaLon
      REAL(r8) :: greenwich, localApparent, rightAscension, tai
      REAL(r8) :: dot(lenG), latD(lenG), localMean(lenG), lon(lenG), los(lenG)
      REAL(r8) :: sign(lenG), slantRange(lenG)
      REAL(r8) :: angleRad(numValues)
      REAL(r8) :: eci(3,lenG), ecr(3,lenG), hECR(3,lenG), nts(3,lenG)
      REAL(r8) :: posSurf(3,lenG), sc_frame_vector(3,lenG), sc_sun(3,lenG)
      REAL(r8) :: sc_tp(3,lenG), tp_sun(3,lenG), tpOrb(3,lenG), unitAlt(3,lenG)
      REAL(r8) :: unitLat(3,lenG), unitLon(3,lenG), vECR(3,lenG)
      REAL(r8) :: angleSc(3,numValues), angleOrb(3,numValues)
      REAL(r8) :: eciV(6,lenG), ecrV(6,lenG)

      deltaLat = 0.1
      deltaLon = 0.1
      deltaAlt = 1000.0

! Calculate MIF scan angles (in DEGREES)

      tp%scAngle(1) = startAngle

      DO i = 2, lenG
         tp%scAngle(i) = tp%scAngle(i-1) - scRate(i)*offsets(2)
      ENDDO

! Calculate retrace angle, rate

      delAngle = tp%scAngle(lenG) - tp%scAngle(1)

      delTime = (numValues - lenG)*offsets(2)

      tp%scanRate(1:lenG) = scRate
      tp%scanRate( (lenG+1):numValues ) = delAngle/delTime

      DO i = lenG+1, numvalues
         tp%scAngle(i) = tp%scAngle(i-1) - tp%scanRate(i)*offsets(2)
      ENDDO
      
! Put angle in s/c coordinates

      angleRad = Deg2Rad * tp%scAngle

      angleSc(1,:) = COS(angleRad)
      angleSc(2,:) = 0.0
      angleSc(3,:) = SIN(angleRad)

! Convert s/c vector to Orb vector/angle/degrees

      returnStatus = Pgs_csc_scToOrb(spacecraftId, numValues, asciiUTC, &
                                     offsets, angleSc, angleOrb)
   
      tp%scanAngle = Rad2Deg * ACOS( angleOrb(1,:) )

! Convert s/c vector to ECR

      returnStatus = Pgs_csc_scToECI(spacecraftId, lenG, asciiUTC, &
                                     offsets(1:lenG), angleSc(:,1:lenG), eci)
  
      eciV(1:3,:) = eci
      eciV(4:6,:) = 0.0

      returnStatus = Pgs_csc_eciToECR(lenG, asciiUTC, offsets(1:lenG), eciV, &
                                      ecrV)

      ecr = ecrV(1:3,:)

! For each scanning MIF,

      DO i = 1, lenG

! Calculate tangent point (geodetic & ECR)

         returnStatus = Pgs_csc_grazingRay(earthModel, posECR(:,i), ecr(:,i), &
                                latD(i), lon(i), tp%tpGeodAlt(i), &
                                slantRange(i), tp%tpECR(:,i), posSurf(:,i) )

! Create ECR unit vector quantities -- lat=1, lon=2, alt=3

         flagQ = 2
         CALL Tp_unit(flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaLon, &
                      unitLon(:,i), flag)

         flagQ = 1
         CALL Tp_unit(flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaLat, &
                      unitLat(:,i), flag)

         flagQ = 3
         CALL Tp_unit(flagQ, lon(i), latD(i), tp%tpGeodAlt(i), deltaAlt, &
                      unitAlt(:,i), flag)

! Get local mean solar time from Toolkit

         tai = asciiTAI + (i-1)*offsets(2)

         returnStatus = Pgs_td_taiToUTC(tai, time)

         returnStatus = Pgs_cbp_solarTimeCoords(time, lon(i), greenwich, &
                      localMean(i), localApparent, rightAscension, declination)

      ENDDO

      tp%tpGeodLat = Rad2Deg * latD
      tp%tpLon = Rad2Deg * lon
      tp%tpSolarTime = localMean/3600.0

! Calculate solarZenith

      returnStatus = Pgs_cbp_sat_cb_vector(spacecraftId, lenG, asciiUTC, &
                                    offsets(1:lenG), PGSd_SUN, sc_frame_vector)

      returnStatus = Pgs_csc_scToECI(spacecraftId, lenG, asciiUTC, &
                                     offsets(1:lenG), sc_frame_vector, eci)

      eciV(1:3,:) = eci
      eciV(4:6,:) = 0.0

      returnStatus = Pgs_csc_eciToECR(lenG, asciiUTC, offsets(1:lenG), eciV, &
                                      ecrV)

      sc_sun = ecrV(1:3,:)
      DO i = 1, lenG
         sc_tp(:,i) = ecr(:,i) * slantRange(i)
      ENDDO
      tp_sun = sc_sun - sc_tp

      DO i = 1, lenG
         nts(:,i) = tp_sun(:,i) / SQRT( tp_sun(1,i)**2 + tp_sun(2,i)**2 + &
                                       &tp_sun(3,i)**2 )
      ENDDO

      dot = nts(1,:)*unitAlt(1,:) + nts(2,:)*unitAlt(2,:) + &
            nts(3,:)*unitAlt(3,:)

      tp%tpSolarZenith = ACOS(dot) * Rad2Deg

! Calculate losAngle

      DO i = 1, lenG
         vECR(:,i) = ecr(:,i) - ( ecr(1,i)*unitAlt(1,i) + &
                               &ecr(2,i)*unitAlt(2,i) + ecr(3,i)*unitAlt(3,i) )
         hECR(:,i) = vECR(:,i) / SQRT(vECR(1,i)**2 + vECR(2,i)**2 + &
                                     &vECR(3,i)**2)
      ENDDO

      los = ACOS( hECR(1,:)*unitLat(1,:) + hECR(2,:)*unitLat(2,:) + &
                 &hECR(3,:)*unitLat(3,:) )

      sign = ecr(1,:)*unitLon(1,:) + ecr(2,:)*unitLon(2,:) + &
             ecr(3,:)*unitLon(3,:)

      DO i = 1, lenG
         IF (sign(i) < 0 ) los(i) = 2*PI - los(i)
      ENDDO

      tp%tpLosAngle = los * Rad2Deg

! Convert tpECR to tpECI

      ecrV(1:3,:) = tp%tpECR
      ecrV(4:6,:) = 0.0

      returnStatus = Pgs_csc_ecrToECI (lenG, asciiUTC, offsets(1:lenG), ecrV, &
                                       eciV)

      tp%tpECI = eciV(1:3,:)

! Convert tpECI to tpOrb

      returnStatus = Pgs_csc_eciToOrb(spacecraftId, lenG, asciiUTC, &
                                      offsets(1:lenG), tp%tpECI, tpOrb)

      tp%tpOrbY = tpOrb(2,:)

! Calculate tp geocentric coordinates

      DO i = 1, lenG

         tp%tpGeocAlt(i) = SQRT( tp%tpECR(1,i)**2 + tp%tpECR(2,i)**2 + &
                                &tp%tpECR(3,i)**2 )

         tp%tpGeocLat(i) = Rad2Deg * ATAN( tp%tpECR(3,i) &
                          &/ SQRT( tp%tpECR(1,i)**2 + tp%tpECR(2,i)**2 ) )

      ENDDO

! Calculate dummy values

      tp%encoderAngle = tp%scAngle

      DO i = 2, lenG
         tp%tpGeocAltRate(i-1) = ( tp%tpGeocAlt(i) - tp%tpGeocAlt(i-1) )&
                                &/offsets(2)
         tp%tpGeodAltRate(i-1) = ( tp%tpGeodAlt(i) - tp%tpGeodAlt(i-1) )&
                                &/offsets(2)
      ENDDO
 
      tp%tpGeocAltRate(lenG) = tp%tpGeocAltRate(lenG-1)
      tp%tpGeodAltRate(lenG) = tp%tpGeodAltRate(lenG-1)

!-------------------------
   END SUBROUTINE TkL1B_tp
!-------------------------

!---------------------------------------------------------------
   SUBROUTINE Tp_unit (flagQ, lon, lat, alt, delta, unitQ, flag)
!---------------------------------------------------------------

      IMPLICIT NONE

! Brief description of subroutine
! This subroutine creates unit ECR vector quantities used by TkL1B_tp to
! calculate solarZenith and losAngle.

! Arguments

      INTEGER, INTENT(IN) :: flagQ

      REAL(r8), INTENT(IN) :: alt, delta, lat, lon
   
      INTEGER, INTENT(OUT) :: flag

      REAL(r8), INTENT(OUT) :: unitQ(3)

! Parameters

! Functions

      INTEGER :: Pgs_csc_geoToECR

! Variables

      CHARACTER (LEN=32) :: mnemonic
      CHARACTER (LEN=480) :: msg, msr

      INTEGER :: returnStatus

      REAL(r8) :: del, geoMinus, geoPlus
      REAL(r8) :: ecrMinus(3), ecrPlus(3), vec(3)

      flag = 0

! Create unit vector

      IF (flagQ == 2) THEN

! longitude

         del = delta * Deg2Rad

         geoPlus  = (lon + del/2)
         geoMinus = (lon - del/2)

         IF (geoPlus  >  PI) geoPlus  = geoPlus  - 2*PI
         IF (geoMinus < -PI) geoMinus = geoMinus + 2*PI
 
         returnStatus = Pgs_csc_geoToECR(geoPlus, lat, alt, earthModel, &
                                         ecrPlus)

         returnStatus = Pgs_csc_geoToECR(geoMinus, lat, alt, earthModel, &
                                         ecrMinus)

      ELSE IF (flagQ == 1) THEN

! latitude

         del = delta * Deg2Rad

         geoPlus  = (lat + del/2)
         geoMinus = (lat - del/2)

         returnStatus = Pgs_csc_geoToECR(lon, geoPlus, alt, earthModel, &
                                         ecrPlus)
  
         returnStatus = Pgs_csc_geoToECR(lon, geoMinus, alt, earthModel, &
                                         ecrMinus)

      ELSE

         geoPlus  = (alt + delta/2)
         geoMinus = (alt - delta/2)

         returnStatus = Pgs_csc_geoToECR(lon, lat, geoPlus, earthModel, &
                                         ecrPlus)
  
         returnStatus = Pgs_csc_geoToECR(lon, lat, geoMinus, earthModel, &
                                         ecrMinus)

      ENDIF

      IF (returnStatus /= PGS_S_SUCCESS) THEN
         call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
         msr = mnemonic // ':  ' // msg
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
         flag = -1
      ENDIF

      vec = ecrPlus - ecrMinus

      unitQ = vec / SQRT( vec(1)**2 + vec(2)**2 + vec(3)**2 )

!------------------------
   END SUBROUTINE Tp_unit
!------------------------

!------------------------------------------------------------------------------
   SUBROUTINE L1boa_MAF(altG, altT, ascTAI, counterMAF, dscTAI, L1FileHandle, &
                        MAFinfo, noMAF, numOrb, orbIncline, orbitNumber, &
                        scRate, scRateT)
!------------------------------------------------------------------------------

! Brief description of subroutine
! This subroutine creates the SIDS L1BOA MAF records, and writes them to an
! HDF output file.

! Arguments

      TYPE (MAFinfo_T) :: MAFinfo

      INTEGER, INTENT(IN) :: L1FileHandle, counterMAF, noMAF, numOrb
      INTEGER, INTENT(IN) :: orbitNumber(:)

      REAL, INTENT(IN) :: scRate(:)
      REAL, INTENT(IN) :: scRateT(:)

      REAL(r8), INTENT(IN) :: altG, altT, orbIncline
      REAL(r8), INTENT(IN) :: ascTAI(:), dscTAI(:)

! Parameters

! Functions

      INTEGER :: Pgs_td_taiToUTC

! Variables

      TYPE( L1BOAindex_T ) :: index
      TYPE( L1BOAsc_T ) :: sc
      TYPE( L1BOAtp_T ) :: tp

      CHARACTER (LEN=27) :: mafTime
      CHARACTER (LEN=480) :: msr

      INTEGER :: error, i, nV, returnStatus

      REAL(r8) :: mafTAI
      REAL(r8) :: initRay(3), q(3)
      REAL(r8) :: offsets(MAFinfo%MIFsPerMAF)

! Calculate offsets array

      mafTAI = MAFinfo%startTAI
      nV = MAFinfo%MIFsPerMAF

      DO i = 1, nV 
         offsets(i) = (i-1)*MAFinfo%integTime
      ENDDO

! Write "index" information

      returnStatus = Pgs_td_taiToUTC(mafTAI, mafTime)
      
      index%MAFStartTimeUTC = mafTime
      index%MAFStartTimeTAI = mafTAI
      index%noMIFs = nV
      index%counterMAF = counterMAF

      CALL OutputL1B_index(noMAF, L1FileHandle, index)

! Allocate the MIF variables in the output structures

      ALLOCATE(sc%scECI(lenCoord,nV), sc%scECR(lenCoord,nV), &
       sc%scGeocAlt(nV), sc%scGeocLat(nV), sc%scGeodAlt(nV), &
       sc%scGeodLat(nV), sc%scLon(nV), sc%scGeodAngle(nV), &
       sc%scVel(lenCoord,nV), sc%ypr(lenCoord,nV), sc%yprRate(lenCoord,nV), &
       tp%encoderAngle(nV), tp%scAngle(nV), tp%scanAngle(nV), &
       tp%scanRate(nV), STAT=error)
      IF ( error /= 0 ) THEN
         msr = MLSMSG_Allocate // '  s/c quantities.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Get oa data

      CALL TkL1B_sc(nV, offsets, mafTime, sc)

! Get s/c master coordinate

      CALL Mc_aux(mafTime, sc%scECI(:,1), sc%scGeocLat(1), q)

      CALL TkL1B_mc(ascTAI, dscTAI, sc%scECI, sc%scGeocLat, nV, numOrb, &
                  orbIncline, orbitNumber, q, mafTAI, offsets, sc%scGeodAngle)

! Write s/c information

      CALL OutputL1B_sc(noMAF, L1FileHandle, sc)

! Calculate initial guess for look vector in ECR

      CALL Scan_guess(mafTime, initRay)

! Allocate the output structure

      ALLOCATE(tp%tpECI(lenCoord,lenG), tp%tpECR(lenCoord,lenG), &
               tp%tpOrbY(lenG), tp%tpGeocAlt(lenG), tp%tpGeocLat(lenG), &
               tp%tpGeocAltRate(lenG), tp%tpGeodAlt(lenG), &
               tp%tpGeodLat(lenG), tp%tpGeodAltRate(lenG), tp%tpLon(lenG), &
               tp%tpGeodAngle(lenG), tp%tpSolarTime(lenG), &
               tp%tpSolarZenith(lenG), tp%tpLosAngle(lenG), STAT=error)
      IF ( error /= 0 ) THEN
         msr = MLSMSG_Allocate // '  GHz tp quantities.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Find angle, tan pt for start of GHZ scan

      CALL Scan_start( altG, sc%scECR(:,1), mafTime, initRay, tp%scAngle(1) )

! Calculate GHZ tan pt record

      CALL TkL1B_tp(mafTAI, mafTime, lenG, nV, offsets, sc%scECR(:,1:lenG), &
                    scRate, tp%scAngle(1), tp)

! Compute GHz master coordinate

      CALL TkL1B_mc(ascTAI, dscTAI, tp%tpECI, tp%tpGeocLat, lenG, numOrb, &
           orbIncline, orbitNumber, q, mafTAI, offsets(1:lenG), tp%tpGeodAngle)

! Write GHz information

      CALL OutputL1B_GHz(noMAF, L1FileHandle, tp)

      DEALLOCATE(tp%tpECI, tp%tpECR, tp%tpOrbY, tp%tpGeocAlt, tp%tpGeocLat, &
                 tp%tpGeocAltRate, tp%tpGeodAlt, tp%tpGeodLat, &
                 tp%tpGeodAltRate, tp%tpLon, tp%tpGeodAngle, tp%tpSolarTime, &
                 tp%tpSolarZenith, tp%tpLosAngle, STAT=error)
      IF ( error /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
                                             &deallocation of GHz quantities.')

! Find angle, tan pt for start of THz scan

      ALLOCATE(tp%tpECI(lenCoord,lenT), tp%tpECR(lenCoord,lenT), &
               tp%tpOrbY(lenT), tp%tpGeocAlt(lenT), tp%tpGeocLat(lenT), &
               tp%tpGeocAltRate(lenT), tp%tpGeodAlt(lenT), &
               tp%tpGeodLat(lenT), tp%tpGeodAltRate(lenT), tp%tpLon(lenT), &
               tp%tpGeodAngle(lenT), tp%tpSolarTime(lenT), &
               tp%tpSolarZenith(lenT), tp%tpLosAngle(lenT), STAT=error)
      IF ( error /= 0 ) THEN
         msr = MLSMSG_Allocate // '  THz tp quantities.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      CALL Scan_start(altT, sc%scECR(:,1), mafTime, initRay, tp%scAngle(1))

! Calculate THz tan pt record

      CALL TkL1B_tp(mafTAI, mafTime, lenT, nV, offsets, sc%scECR(:,1:lenT), &
                    scRateT, tp%scAngle(1), tp)

! Compute THz master coordinate

      CALL TkL1B_mc(ascTAI, dscTAI, tp%tpECI, tp%tpGeocLat, lenT, numOrb, &
           orbIncline, orbitNumber, q, mafTAI, offsets(1:lenT), tp%tpGeodAngle)

! Write THZ information

      CALL OutputL1B_THz(noMAF, L1FileHandle, tp)

      DEALLOCATE(tp%tpECI, tp%tpECR, tp%tpOrbY, tp%tpGeocAlt, tp%tpGeocLat, &
                 tp%tpGeocAltRate, tp%tpGeodAlt, tp%tpGeodLat, &
                 tp%tpGeodAltRate, tp%tpLon, tp%tpGeodAngle, tp%tpSolarTime, &
                 tp%tpSolarZenith, tp%tpLosAngle, STAT=error)
      IF ( error /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
                                         &deallocation of THz quantities.')

! Deallocate the MIF quantities

      DEALLOCATE(sc%scECI, sc%scECR, sc%scGeocAlt, sc%scGeocLat, &
       sc%scGeodAlt, sc%scGeodLat, sc%scLon, sc%scGeodAngle,  sc%scVel, &
       sc%ypr, sc%yprRate, tp%encoderAngle, tp%scAngle, tp%scanAngle, &
       tp%scanRate, STAT=error)
      IF ( error /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
                                             &deallocation of MIF quantities.')

!--------------------------
   END SUBROUTINE L1boa_MAF
!--------------------------

!---------------------------------------------------
   SUBROUTINE Mc_aux (asciiUTC, scECI, scGeocLat, q)
!---------------------------------------------------

! Brief description of subroutine
! This subroutine computes q, an auxilliary vector used in the calculation of
! the master coordinate.

! Arguments

      CHARACTER (LEN=27), INTENT(IN) :: asciiUTC

      REAL, INTENT(IN) :: scGeocLat

      REAL(r8), INTENT(IN) :: scECI(3)

      REAL(r8), INTENT(OUT) :: q(3)

! Parameters

      INTEGER, PARAMETER :: nV = 1

      REAL(r8), PARAMETER :: time_offset = 0.0

! Functions

      INTEGER :: Pgs_csc_orbToECI

! Variables

      INTEGER :: i, returnStatus

      REAL(r8) :: l
      REAL(r8) :: dist(2)
      REAL(r8) :: aECI(3), aux1(3), aux1ECI(3), aux2(3), aux2ECI(3)

! Construct two auxilliary vectors -- the first pointing directly ahead 
! along the s/c orbit, and the second pointing 45 degrees downward.

      aux1(1) = 1.0
      aux1(2) = 0.0
      aux1(3) = 0.0

      aux2(1) = 1.0
      aux2(2) = 0.0
      aux2(3) = 1.0

! Transform the auxilliary vectors from orbital to ECI coordinates

      returnStatus = Pgs_csc_orbToECI(spacecraftId, nV, asciiUTC, &
                                      time_offset, aux1, aux1ECI)

      returnStatus = Pgs_csc_orbToECI(spacecraftId, nV, asciiUTC, &
                                      time_offset, aux2, aux2ECI)

! Define l & a, where l is the distance to the equator along the direction of
! one of the auxilliary vectors from the s/c, and a is the auxilliary vector
! for which l was defined.

      IF ( aux1ECI(3) == 0 ) THEN

! If aux1 has a zero z-component, set l & a for aux2, if its z-component /= 0

         IF ( aux2ECI(3) /= 0 ) THEN
            l = -scECI(3)/aux2ECI(3)
            aECI = aux2ECI
         ENDIF

      ELSE

! If aux1(3) is not zero, but aux2(3) is, then set l & a for aux1

         IF ( aux2ECI(3) == 0 ) THEN

            l = -scECI(3)/aux1ECI(3)
            aECI = aux1ECI

         ELSE

! If both aux1(3) and aux2(3) are non-zero, choose the one which gives the
! minimum absolute value of l.

            dist(1) = -scECI(3)/aux1ECI(3)
            dist(2) = -scECI(3)/aux2ECI(3)

            IF ( ABS(dist(1)) < ABS(dist(2)) ) THEN
               l = dist(1)
               aECI = aux1ECI
            ELSE
               l = dist(2)
               aECI = aux2ECI
            ENDIF

         ENDIF

      ENDIF
   
! Define the vector q = scECI + la, such that its z-component = 0

      q(1:2) = scECI(1:2) + l*aECI(1:2)
      q(3) = 0.0

! Modify q, depending on which hemisphere the s/c is in, and the sign of l

      IF ( scGeocLat < 0.0 ) THEN
         IF ( l < 0 ) q = -q
      ELSE
         IF ( l > 0 ) q = -q
      ENDIF

! Normalize q

      q = q / SQRT( q(1)**2 + q(2)**2 )
 
!-----------------------
   END SUBROUTINE Mc_aux
!-----------------------

!------------------------------------------------------------------------------
   SUBROUTINE TkL1B_mc(ascTAI, dscTAI, dotVec, geocLat, nV, numOrb, &
                   orbIncline, orbitNumber, q, timeTAI, time_offset, geodAngle)
!------------------------------------------------------------------------------

! Brief description of subroutine
! This subroutine computes phi, the master coordinate for the spacecraft and
! tangent point records.

! Arguments

      INTEGER, INTENT(IN) :: nV, numOrb
      INTEGER, INTENT(IN) :: orbitNumber(:)

      REAL, INTENT(IN) :: geocLat(nV)

      REAL(r8), INTENT(IN) :: orbIncline, timeTAI
      REAL(r8), INTENT(IN) :: q(3)
      REAL(r8), INTENT(IN) :: time_offset(nV)
      REAL(r8), INTENT(IN) :: ascTAI(:), dscTAI(:)
      REAL(r8), INTENT(IN) :: dotVec(3,nV)

      REAL, INTENT(OUT) :: geodAngle(nV)

! Parameters

! Functions

      INTEGER :: Pgs_csc_getEarthFigure

! Variables

      INTEGER :: i, j, returnStatus, scOrb

      REAL(r8) :: a, asciiTAI, b, cSq, equatRad_a, orbRad, phiMin, polarRad_c
      REAL(r8) :: cosPhi(nV), gamma(nV), phi(nV), sinPhi(nV)
      REAL(r8) :: s(3,nV)

! Read a & b from earthfigure.dat

      returnStatus = Pgs_csc_getEarthFigure(earthModel, equatRad_a, polarRad_c)

      a = equatRad_a/1000
      b = polarRad_c/1000

! Calculate C-squared

      orbRad= Deg2Rad * (orbIncline - 90)

      cSq = (1 + (TAN(orbRad)**2)) * (a**2)*(b**2)/(a**2 + &
                                                  &(b**2)*(TAN(orbRad)**2))

! Set s = normalized dotVec

      DO i = 1, nV

         s(:,i) = dotVec(:,i) / SQRT(dotVec(1,i)**2 + dotVec(2,i)**2 + &
                                                     &dotVec(3,i)**2)

! Calculate the geocentric angle as a number of radians between 0 and PI

         gamma(i) = ACOS( q(1)*s(1,i) + q(2)*s(2,i) )

! Place angle between PI and 2*PI, if lat indicates Southern Hemisphere

         IF ( geocLat(i) < 0.0 ) gamma(i) = 2*PI - gamma(i)

! If |gamma| <= 45 deg of the equator, calculate phi using the SIN equation

         IF ( (gamma(i) <= PI/4 ) .OR. ( (gamma(i) >= 3*PI/4) .AND. &
              &(gamma(i) <= 5*PI/4) ) .OR. (gamma(i) >= 7*PI/4) ) THEN

            sinPhi(i) = SQRT( (a**4)*(SIN(gamma(i))**2)/( (cSq**2)*&
                             &(COS(gamma(i))**2) + (a**4)*(SIN(gamma(i))**2) ) )

            phi(i) = ASIN(sinPhi(i))

         ELSE

! If gamma is within 45 deg of a pole, calculate phi using the COS equation

            cosPhi(i) = SQRT( (cSq**2)*(COS(gamma(i))**2)/( (cSq**2)*&
                              &COS(gamma(i))**2 + (a**4)*(SIN(gamma(i))**2) ) )

            phi(i) = ACOS(cosPhi(i))

         ENDIF

! Place phi in same quadrant as gamma

         IF ( (gamma(i) > PI/2) .AND. (gamma(i) < PI) ) phi(i) = PI - phi(i)
         IF ( (gamma(i) > PI) .AND. (gamma(i) < 3*PI/2) ) phi(i) = phi(i) + PI
         IF ( gamma(i) > 3*PI/2 ) phi(i) = 2*PI - phi(i)

! Make phi cumulative over orbits

         asciiTAI = timeTAI + time_offset(i)

         DO j = 1, numOrb
            IF ( asciiTAI > ascTAI(j) ) scOrb = orbitNumber(j)
         ENDDO

         phi(i) = (scOrb-1)*2*PI + phi(i)

         IF ( asciiTAI > dscTAI(scOrb+1) ) THEN
            phiMin = scOrb*2*PI - PI
         ELSE
            phiMin = (scOrb-1)*2*PI - PI
         ENDIF

         IF ( phi(i) < phiMin ) phi(i) = phi(i) + 2*PI

      ENDDO
d6 636
a641 1
! Convert to degrees for output
d643 2
a644 1
      geodAngle = Rad2Deg * phi
d646 1
a646 3
!----------------------
END SUBROUTINE TkL1B_mc
!----------------------
d648 1
a648 3
!===============
END MODULE TkL1B
!===============
d651 3
@


2.0
log
@Changing file revision to 2.0.
@
text
@d12 2
a13 1
   USE OutputL1B
d23 1
a23 1
   "$Id: TkL1B.f90,v 1.2 2000/02/15 18:48:37 nakamura Exp $"
d887 3
@


1.2
log
@Absorbed module Mc; moved _init subroutine to Orbit; account for parametrization of lenG & lenT.
@
text
@d22 1
a22 1
   "$Id: TkL1B.f90,v 1.2 2000/02/15 18:48:37 nakamura Exp $"
d886 3
d892 1
a892 3
! Revision 1.1  2000/02/10 17:00:57  nakamura
! Module for producing L1BOA records for each MAF.
!
@


1.1
log
@Module for producing L1BOA records for each MAF.
@
text
@a8 1
   USE Mc
a11 1
   USE Orbit
d22 1
a22 1
   "$Id: TkL1B.f90,v 1.1 2000/02/10 17:00:57 nakamura Exp $"
d32 2
a33 1
!                L1boa_init
d496 1
a496 1
      INTEGER :: error, i, lenG, lenT, nV, returnStatus
d543 1
a543 1
      CALL Mc_phi(ascTAI, dscTAI, sc%scECI, sc%scGeocLat, nV, numOrb, &
a555 2
      lenG = SIZE(scRate)

d569 1
a569 1
      CALL Scan_start( altG, sc%scECR(:, 1), mafTime, initRay, tp%scAngle(1) )
d578 1
a578 1
      CALL Mc_phi(ascTAI, dscTAI, tp%tpECI, tp%tpGeocLat, lenG, numOrb, &
a593 2
      lenT = SIZE(scRateT)

d614 1
a614 1
      CALL Mc_phi(ascTAI, dscTAI, tp%tpECI, tp%tpGeocLat, lenT, numOrb, &
d641 3
a643 4
!-----------------------------------------------------------------------------
   SUBROUTINE L1boa_init(times, UTC_start, altG, altT, ascTAI, dscTAI, &
                         numOrb, orbIncline, orbitNumber, scanRate, scanRateT)
!-----------------------------------------------------------------------------
d645 3
a647 4
! Brief description of subroutine 
! This subroutine defines input parameters for the SIDS L1BOA code and also
! sets up values needed by the production code which won't change while looping
! through the MAFs.
d651 36
a686 1
      TYPE ( TAI93_Range_T ), INTENT(IN) :: times
d688 1
a688 1
      CHARACTER (LEN=27), INTENT(IN) :: UTC_start
d690 2
a691 2
      INTEGER, INTENT(OUT) :: numOrb
      INTEGER, INTENT(OUT) :: orbitNumber(max_orbits)
d693 2
a694 2
      REAL, INTENT(OUT) :: scanRate(120)
      REAL, INTENT(OUT) :: scanRateT(114)
d696 86
a781 2
      REAL(r8), INTENT(OUT) :: altG, altT, orbIncline
      REAL(r8), INTENT(OUT) :: ascTAI(max_orbits), dscTAI(max_orbits)
d787 2
d791 21
a811 1
! Input data
d813 1
a813 2
      altG = 2500.0
      altT = 15000.0
d815 55
a869 6
      scanRate(1) = 0.0
      scanRate(2:63) = 0.0279213
      scanRate(64:120) = 0.0976263
 
      scanRateT(1:54) = 0.030344496
      scanRateT(55:114) = 0.058600044
d871 1
a871 1
      orbIncline = 98.145
d873 1
a873 1
! Get orbit metadata for entire day
d875 1
a875 1
      CALL Orbit_met(UTC_start, times, ascTAI, dscTAI, numOrb, orbitNumber)
d877 3
a879 3
!---------------------------
   END SUBROUTINE L1boa_init
!---------------------------
d886 3
@


