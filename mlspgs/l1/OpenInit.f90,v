head	2.34;
access;
symbols
	v5-02-NRT-19:2.34
	v6-00:2.34
	v5-02-NRT-18:2.34
	v5-02:2.34
	v5-01-NRT-17:2.34
	v5-01-NRT-16:2.34
	v5-01-NRT-15:2.34
	v5-01-NRT-14:2.34
	neuralnetworks-1-0:2.34.0.10
	cfm-single-freq-0-1:2.34.0.8
	v5-01:2.34
	v5-00:2.34
	v4-23-TA133:2.34.0.6
	mus-emls-1-70:2.34.0.4
	rel-1-0-englocks-work:2.34.0.2
	VUMLS1-00:2.33
	VPL1-00:2.33
	V4-22-NRT-08:2.33
	whdrel10_merged_to_here:2.33
	merge_whdrel10_from_here:2.32.2.1
	TAG_TRUNK_AFTER_PW_CHANGES:2.32
	TAG_TRUNK_BEFORE_PW_CHANGES:2.32
	VAM1-00:2.32
	whd-rel-1-0:2.32.0.2
	V4-21:2.31.0.2
	V4-13:2.30
	V4-12:2.30
	V4-11:2.30
	V4-10:2.30
	V3-43:2.30
	M4-00:2.30
	V3-41:2.30
	V3-40-PlusGM57:2.30.0.2
	V2-24-NRT-04:2.30
	V3-33:2.30
	V2-24:2.30
	V3-31:2.30
	V3-30-NRT-05:2.30
	cfm-01-00:2.30
	V3-30:2.30
	V3-20:2.30
	V3-10:2.30
	V2-23-NRT-02:2.30
	V2-23:2.30
	V2-22-NRT-01:2.30
	V2-22:2.30
	V2-21:2.29
	V2-20:2.29
	V2-11:2.29
	V2-10:2.29
	V2-00:2.28
	V1-51:2.18
	V1-50:2.18
	V1-45:2.17
	V1-44:2.17
	V1-43:2.16
	V1-42:2.14
	V1-41:2.14
	V1-32:2.13
	V1-40:2.14
	V1-31:2.13
	V1-30:2.13
	V1-13:2.10
	V1-12:2.10
	V1-11:2.10
	V1-10:2.10
	newfwm-feb03:2.10.0.2
	V1-04:2.5
	V1-03:2.5
	V1-02:2.5
	V1-00:2.5
	newfwm-sep01:2.4.0.2
	V0-7:2.4
	V0-5-Level2:2.4
	V0-5-SIPS:2.4;
locks; strict;
comment	@# @;


2.34
date	2018.04.09.22.18.18;	author whdaffer;	state Exp;
branches;
next	2.33;

2.33
date	2016.03.15.22.17.59;	author whdaffer;	state Exp;
branches;
next	2.32;

2.32
date	2015.04.23.17.46.27;	author whdaffer;	state Exp;
branches
	2.32.2.1;
next	2.31;

2.31
date	2015.01.21.19.31.23;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2007.06.21.21.03.34;	author perun;	state Exp;
branches;
next	2.29;

2.29
date	2006.08.02.18.56.04;	author perun;	state Exp;
branches;
next	2.28;

2.28
date	2006.06.14.13.47.47;	author perun;	state Exp;
branches;
next	2.27;

2.27
date	2006.04.05.18.09.38;	author perun;	state Exp;
branches;
next	2.26;

2.26
date	2006.03.31.16.26.40;	author perun;	state Exp;
branches;
next	2.25;

2.25
date	2006.03.24.15.14.55;	author perun;	state Exp;
branches;
next	2.24;

2.24
date	2005.12.06.19.28.04;	author perun;	state Exp;
branches;
next	2.23;

2.23
date	2005.10.14.15.54.27;	author perun;	state Exp;
branches;
next	2.22;

2.22
date	2005.09.22.23.40.12;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2005.07.12.17.18.15;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2005.06.23.18.41.36;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2005.05.02.16.05.44;	author perun;	state Exp;
branches;
next	2.18;

2.18
date	2004.11.10.15.42.35;	author perun;	state Exp;
branches;
next	2.17;

2.17
date	2004.08.04.23.20.25;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2004.05.14.15.59.11;	author perun;	state Exp;
branches;
next	2.15;

2.15
date	2004.05.06.21.59.23;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2004.01.09.17.46.22;	author perun;	state Exp;
branches;
next	2.13;

2.13
date	2003.09.15.17.15.53;	author perun;	state Exp;
branches;
next	2.12;

2.12
date	2003.08.15.14.25.04;	author perun;	state Exp;
branches;
next	2.11;

2.11
date	2003.06.03.20.43.54;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2003.01.31.18.13.34;	author perun;	state Exp;
branches;
next	2.9;

2.9
date	2002.11.20.16.07.28;	author perun;	state Exp;
branches;
next	2.8;

2.8
date	2002.11.19.21.21.46;	author perun;	state Exp;
branches;
next	2.7;

2.7
date	2002.11.14.21.46.04;	author perun;	state Exp;
branches;
next	2.6;

2.6
date	2002.11.07.21.54.20;	author jdone;	state Exp;
branches;
next	2.5;

2.5
date	2002.03.29.20.18.34;	author perun;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.22.16.46.02;	author perun;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.12.19.36.00;	author perun;	state Exp;
branches;
next	2.2;

2.2
date	2001.03.12.15.59.13;	author perun;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.23.20.54.11;	author perun;	state Exp;
branches;
next	;

2.32.2.1
date	2015.10.09.10.21.38;	author whdaffer;	state Exp;
branches;
next	;


desc
@@


2.34
log
@Print out disagreement between l1cf versions, as that failure has
bitten me several times and I've had to spend *way* to much time
re-figuring it out.
@
text
@! Copyright 2006, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
MODULE OpenInit ! Opens input L0 files and output L1 files
!=============================================================================

  USE SDPToolkit, ONLY: PGS_PC_GetReference, PGS_S_SUCCESS, PGSd_EOS_AURA, &
       PGSd_IO_Gen_RSeqFrm, PGS_IO_Gen_openF, PGS_IO_Gen_closeF
  USE MLSCommon, ONLY: TAI93_Range_T
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_Info, &
       MLSMSG_Warning
  USE MLSL1Common, ONLY: OA_counterMAF, OA_counterIndex

  USE MLSL1DEBUG, ONLY: MLSL1DEBUG_INIT
 
  IMPLICIT NONE

  PRIVATE

  PUBLIC :: OpenAndInitialize, OpenL0File, OpenL0Files, LoadChanDefaults, &
       anTextPCF, anTextCF

  CHARACTER (LEN=1), POINTER :: anTextPCF(:), anTextCF(:)

!---------------------------- RCS Module Info ------------------------------
  CHARACTER (len=*), PRIVATE, PARAMETER :: ModuleName= &
       "$RCSfile: OpenInit.f90,v $"
  PRIVATE :: not_used_here 
!---------------------------------------------------------------------------

CONTAINS

!=============================================================================
  SUBROUTINE OpenAndInitialize
!=============================================================================

    USE MLSL1Debug, ONLY: MLSL1Debug_Init, openMLSL1DebugFiles
    USE MLSL1Config, ONLY: L1Config, GetL1Config
    USE InitPCFs, ONLY: L1PCF, GetPCFParameters
    USE MLSPCF1, ONLY: mlspcf_engtbl_start, mlspcf_nomen_start, &
         mlspcf_pcf_start, mlspcf_l1cf_start, mlspcf_MAF_data_start, &
         mlspcf_defltzeros_start, mlspcf_defltzeros_end, &
         mlspcf_defltgains_start, mlspcf_sidebandfrac_start, &
         mlspcf_spilloverloss_start, mlspcf_defltchi2_start, &
         mlspcf_defltbaselineAC_start, mlspcf_l1b_log_start, &
         mlspcf_bandalts_start, mlspcf_strayrad_start
    USE PCFHdr, ONLY: CreatePCFAnnotation, GlobalAttributes, FillTAI93Attribute
    USE dates_module, ONLY: utc_to_yyyymmdd
    USE L0_sci_tbls, ONLY: InitSciPointers
    USE MLSL1Common, ONLY: L1BFileInfo, deflt_gain, deflt_zero, L1ProgType, &
         THzType, THz_SwMir_Range, THzTol, BandSwitch,FileNameLen
    USE Orbit, ONLY: Orbit_init, altG, altT, ascTAI, dscTAI, numOrb, &
         orbIncline, orbitNumber, scanRate, scanRateT
    USE Calibration, ONLY: InitCalibWindow
    USE EngTbls, ONLY: Load_Eng_tbls
    USE BandTbls, ONLY: Load_Band_tbls, LoadSidebandFracs, LoadSpilloverLoss, &
         LoadDefltChi2, LoadBandAlts, LoadFourierCoeffs
    USE MLSL1Rad, ONLY: InitRad
    USE MLSSignalNomenclature, ONLY: ReadSignalsDatabase
    USE OutputL1B, ONLY: OutputL1BOA_create
    USE FOV, ONLY: InitFOVconsts
    USE SpectralBaseline, ONLY: InitBaseline, LoadBaselineAC
    USE BandSwitches, ONLY: GetBandSwitches

    CHARACTER (LEN=FileNameLen) :: PhysicalFilename

    INTEGER :: ios, lid, noMAFS, returnStatus, version, tbl_unit

    LOGICAL :: THz, exists

    REAL :: MAF_dur

    INTEGER, EXTERNAL :: PGS_TD_UTCtoTAI,  PGS_IO_Gen_Track_LUN

    TYPE (TAI93_Range_T) :: procRange


    !! <whd:debug> Initialize MLSL1DEBUG module
    CALL MLSL1Debug_Init() 
    !! Open any files that might be needed for debugging
    CALL openMLSL1DebugFiles()
    !! </whd:debug>

    !! Call
    THz = L1ProgType .EQ. THzType

!! Open log file:

    !! <whd comment> 
    !!
    !! A word on variables like `mlspcf_l1b_log_start', because you'll be seeing
    !! lots of them in this next part fo the code. 
    !!
    !! The value of this variable is given by a parameter in MLSPCF1.f90. In the
    !! case of this variable, its value is 30006. This is the PCF ID, you'll
    !! find it in the first column of the PCF file, the remainder of that line
    !! of the PCF file gives the name and directory of the log file. You'll see
    !! this again and again, as you peruse the code below, so I'm telling you
    !! how to go about finding which file the code is accessing. It's curious
    !! that a few lines along it asks for the name of the PCF file, when its
    !! actually reading the PCF file to get this information. I don' quite know
    !! how that works, maybe there's an environmental variable being used
    !! somewhere that I don't know about.  
    !!
    !! </whd comment>


    !! Open MLS-Aura_L1BLOG (or whatever is at PCF ID 30006 in the PCF)
    WRITE (PhysicalFilename, "(I5.5)") mlspcf_l1b_log_start
    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_l1b_log_start, version, &
          & PhysicalFilename)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not find file entry for pcf_log_start: " // &
            PhysicalFilename)
    ENDIF

    returnStatus = PGS_IO_Gen_Track_LUN (L1BFileInfo%LogId, 0)

    OPEN (unit=L1BFileInfo%LogId, file=PhysicalFilename, &
         status="OLD", FORM="FORMATTED", ACCESS="SEQUENTIAL", &
         POSITION="APPEND", iostat=ios)

    IF (ios /= 0) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open L1B Log file: " // PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened L1B log file: " // PhysicalFilename)

    L1BFileInfo%LogFilename = PhysicalFilename

    WRITE (L1BFileInfo%LogId, *) ''
    IF (.NOT. THz) THEN
       WRITE (L1BFileInfo%LogId, *) &
            '#################### Begin MLSL1G ###################'
    ELSE
       WRITE (L1BFileInfo%LogId, *) &
            '#################### Begin MLSL1T ###################'
    ENDIF
    WRITE (L1BFileInfo%LogId, *) ''


!! Get PCF and CF filenames:

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_pcf_start, version, &
          & PhysicalFilename)
    L1PCF%PCF_filename = physicalfilename

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_l1cf_start, version, &
          & PhysicalFilename)
    L1PCF%L1CF_filename = physicalfilename

!! Get user parameters from the PCF file

    CALL GetPCFParameters

!! Get annotation from PCF and CF files

    CALL CreatePCFAnnotation (mlspcf_pcf_start, anTextPCF)

    CALL CreatePCFAnnotation (mlspcf_l1cf_start, anTextCF)

!! Get the Level 1 configuration from the L1CF file

    CALL GetL1Config

    IF (.NOT. THz) THEN
       IF (L1Config%Calib%AntOffsetsScale <= 0.0) THEN
          WRITE (L1BFileInfo%LogId, *) &
           'Antenna offsets are DISABLED.'
       ELSE
          WRITE (L1BFileInfo%LogId, *) &
           'Antenna offsets are ENABLED.'
       ENDIF
    ENDIF

!! Check output versions from CF and PCF

    IF (L1Config%Globals%OutputVersionString /= L1PCF%OutputVersion) THEN
       CALL MLSMessage (MLSMSG_Info, ModuleName, &
            & "CF and PCF OutputVersions do not match!")
       CALL MLSMessage (MLSMSG_Info, ModuleName, &
            & "CF version = "//trim(L1Config%Globals%OutputVersionString))
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "L1PCF version = "//trim(L1PCF%OutputVersion))

    ENDIF

!! TAI Processing range

    MAF_dur = L1Config%Calib%MIF_duration * L1Config%Calib%MIFsPerMAF

    returnStatus = PGS_TD_UTCtoTAI (L1PCF%startUTC, procRange%startTime)
    returnStatus = PGS_TD_UTCtoTAI (L1PCF%endUTC, procRange%endTime)

    IF (procRange%startTime .GE. procRange%endTime) THEN 
       CALL MLSMessage(MLSMSG_Error, ModuleName, &
            & "Bad processing range time: start >= end! " // &
            "Check your .PCF!")
    ENDIF
    procRange%startTime = procRange%startTime - MAF_dur * (0.5 + &
         L1Config%Calib%MAFexpandNum)
    procRange%endTime = procRange%endTime +  MAF_dur * (0.5 + &
         L1Config%Calib%MAFexpandNum)

    L1Config%Input_TAI = procRange

!! Store appropriate user inputs as global attributes

    GlobalAttributes%StartUTC = L1PCF%StartUTC
    GlobalAttributes%EndUTC = L1PCF%EndUTC
    GlobalAttributes%ProcessLevel = '1'
    GlobalAttributes%PGEVersion = L1PCF%OutputVersion
    CALL utc_to_yyyymmdd (GlobalAttributes%StartUTC, returnStatus, &
      & GlobalAttributes%GranuleYear, GlobalAttributes%GranuleMonth, &
      & GlobalAttributes%GranuleDay) 
    CALL FillTAI93Attribute

!! Will determine the expanded time later!!!

    L1Config%Expanded_TAI = L1Config%Input_TAI

!! Expand time range!!!

    IF (.NOT. THz) THEN
       L1Config%Expanded_TAI%startTime = L1Config%Expanded_TAI%startTime - 120.0
       L1Config%Expanded_TAI%endTime = L1Config%Expanded_TAI%endTime + 120.0
       noMAFs = ( L1Config%Expanded_TAI%endTime - &
            L1Config%Expanded_TAI%startTime) / MAF_dur
       ALLOCATE (OA_counterMAF(noMAFs))
       OA_counterIndex = 1
    ELSE   ! expand end time for THz (110% MAF_dur)
       L1Config%Expanded_TAI%endTime = L1Config%Expanded_TAI%endTime + &
            MAF_dur*1.1
    ENDIF

!! Init BandSwitches:

    CALL GetBandSwitches (L1Config%Expanded_TAI%startTime, BandSwitch)
    WRITE (L1BFileInfo%LogId, *) 'Initial BandSwitches: ', BandSwitch

!! Init orbit data:

    numOrb = 1

    IF (L1Config%Globals%ProduceL1BOA) THEN

       CALL Orbit_init (procRange, L1PCF%startUTC, altG, altT, ascTAI, &
            dscTAI, numOrb, orbIncline, orbitNumber, scanRate, scanRateT)

    ENDIF

!! Open and initialize eng table: (<whd>: engtlm.tbl, PCF ID 903)

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_engtbl_start, version, &
          & PhysicalFilename)

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_engtbl_start, PGSd_IO_Gen_RSeqFrm, &
         0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open engineering table file: " // PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened engineering table file: " // PhysicalFilename)

    CALL Load_Eng_tbls (tbl_unit, ios)

    returnStatus = PGS_IO_Gen_CloseF (tbl_unit)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading engineering table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close engineering table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed engineering table file")

!! Open and initialize default gains table:

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_defltgains_start, version, &
          & PhysicalFilename)

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_defltgains_start, &
         PGSd_IO_Gen_RSeqFrm, 0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open default gains table file: " // PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened default gains table file: " // PhysicalFilename)

    CALL LoadChanDefaults (tbl_unit, deflt_gain, ios)

    returnStatus = PGS_IO_Gen_CloseF (tbl_unit)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading default gains table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close default gains table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed default gains table file")

!! Open and initialize default zeros table, starting with end:

    version = 1
    lid = mlspcf_defltzeros_end
    returnStatus = PGS_PC_getReference (lid, version, PhysicalFilename)
    INQUIRE (file=PhysicalFilename, exist=exists)
    IF (.NOT. exists) THEN
       version = 1
       lid = mlspcf_defltzeros_start
       returnStatus = PGS_PC_getReference (lid, version, PhysicalFilename)
    ENDIF

    version = 1
    returnStatus = PGS_IO_Gen_openF (lid, PGSd_IO_Gen_RSeqFrm, 0, tbl_unit, &
         version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open default zeros table file: " // PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened default zeros table file: " // PhysicalFilename)

    CALL LoadChanDefaults (tbl_unit, deflt_zero, ios)

    returnStatus = PGS_IO_Gen_CloseF (tbl_unit)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading default zeros table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close default zeros table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed default zeros table file")

!! Open and Read nomenclature file

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_nomen_start, PGSd_IO_Gen_RSeqFrm, &
         0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open nomenclature file")
    ENDIF

    CALL ReadSignalsDatabase (tbl_unit)

    returnStatus = PGS_IO_Gen_closeF (tbl_unit)  ! close unit
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close nomenclature file")
    ENDIF

!! Open L0 files:

    CALL OpenL0Files

!! New L0 open for merged/filtered L0 data:

    WRITE (PhysicalFilename, "(I3.3)") mlspcf_MAF_data_start
    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_MAF_data_start, version, &
          & PhysicalFilename)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not find file entry for pcf_MAF_data_start: " // &
            PhysicalFilename)
    ENDIF

    !<whd>: PCF ID: 922. MAF_data_tmp.dat. This was created by
    !OpenInitLog::OpenAndInitializeLog called from MLSL1log </whd>

    returnStatus = PGS_IO_Gen_Track_LUN (L1BFileInfo%MAF_data_unit, 0)

    OPEN (unit=L1BFileInfo%MAF_data_unit, file=PhysicalFilename, &
         status="OLD", FORM="UNFORMATTED", ACCESS="SEQUENTIAL", &
         ACTION="READ", iostat=ios)

    IF (ios /= 0) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open MAF_data file: " // PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened MAF_data file: " // PhysicalFilename)

!! Read and compare some header info:

    READ (L1BFileInfo%MAF_data_unit) PhysicalFilename

    IF (trim(PhysicalFilename) /= trim(L1PCF%PCF_filename)) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "PCF_filenames do not match: " // trim(PhysicalFilename))
    ENDIF

    READ (L1BFileInfo%MAF_data_unit) PhysicalFilename
    IF (trim(PhysicalFilename) /= trim(L1PCF%L1CF_filename)) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "L1CF_filenames do not match: " // trim(PhysicalFilename))
    ENDIF

!! Adjust THz_SwMir "S" range based on the CF file:

    WHERE (THz_SwMir_Range%pos == "S")
       THz_SwMir_Range%low_angle = L1Config%Calib%THzSpaceAngle - THzTol
       THz_SwMir_Range%high_angle = L1Config%Calib%THzSpaceAngle + THzTol
    ENDWHERE

!! Open L1B output files

    CALL OpenL1BFiles (THz)

!! Initialize the science data pointers:

    CALL InitSciPointers

!! Initialize the calibration window:

    CALL InitCalibWindow

!! Initialize Radiances:

    CALL InitRad (THz)

!! Initialize FOV constants

    IF (.NOT. THz) CALL InitFOVconsts

!! Initialize Baseline

    CALL InitBaseline
          
!! Define the SD structures in the L1BOA output file

    CALL OutputL1BOA_create (L1BFileInfo, THz)

!! Load band tables:

    CALL Load_Band_Tbls

!! Open and initialize SideBand fractions table:

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_sidebandfrac_start, version, &
          & PhysicalFilename)

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_sidebandfrac_start, &
         PGSd_IO_Gen_RSeqFrm, 0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open Sideband fractions table file: " // &
            PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened Sideband Fractions table file: " // PhysicalFilename)

    CALL LoadSidebandFracs (tbl_unit)

    returnStatus = PGS_IO_Gen_CloseF (tbl_unit)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading Sideband Fractions table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close Sideband Fractions table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed Sideband Fractions table file")

!! Open and initialize Spillover Loss table:

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_spilloverloss_start, version, &
          & PhysicalFilename)

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_spilloverloss_start, &
         PGSd_IO_Gen_RSeqFrm, 0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open Spillover Loss table file: " // &
            PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened Spillover Loss table file: " // PhysicalFilename)

    CALL LoadSpilloverLoss (tbl_unit)

    returnStatus = PGS_IO_Gen_CloseF (tbl_unit)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading Spillover Loss table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close Spillover Loss table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed Spillover Loss table file")

!! Open and initialize Fourier Coefficients table:

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_strayrad_start, version, &
          & PhysicalFilename)

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_strayrad_start, &
         PGSd_IO_Gen_RSeqFrm, 0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open Stray Radiance Coefficients table file: " // &
            PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened Stray Radiances Coefficients table file: " // &
         PhysicalFilename)

    CALL LoadFourierCoeffs (tbl_unit, L1PCF%StartUTC)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading Stray Radiances Coefficients table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close Stray Radiances Coefficients table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed Stray Radiances Coefficients table file")

!! Open and initialize Default Chi2 table:

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_defltchi2_start, version, &
          & PhysicalFilename)

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_defltchi2_start, &
         PGSd_IO_Gen_RSeqFrm, 0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open Default Chi2 table file: " // &
            PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened Default Chi2 table file: " // PhysicalFilename)

    CALL LoadDefltChi2 (tbl_unit, ios)

    returnStatus = PGS_IO_Gen_CloseF (tbl_unit)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading Default Chi2 table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close Default Chi2 table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed Default Chi2 table file")

! Load Baseline AC tables:

!! Open and initialize Default BaselineAC table:

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_defltbaselineAC_start, version, &
          & PhysicalFilename)

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_defltbaselineAC_start, &
         PGSd_IO_Gen_RSeqFrm, 0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open Default BaselineAC table file: " // &
            PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened Default BaselineAC table file: " // PhysicalFilename)

    CALL LoadBaselineAC (tbl_unit, ios)

    returnStatus = PGS_IO_Gen_CloseF (tbl_unit)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading Default BaselineAC table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close Default BaselineAC table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed Default BaselineAC table file")

!! Open and initialize Band Altitudes table:

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_bandalts_start, version, &
          & PhysicalFilename)

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_bandalts_start, &
         PGSd_IO_Gen_RSeqFrm, 0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open Band Altitudes table file: " // &
            PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened Band Altitudes table file: " // PhysicalFilename)

    CALL LoadBandAlts (tbl_unit)

    returnStatus = PGS_IO_Gen_CloseF (tbl_unit)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading Band Altitudes table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close Band Altitudes table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed Band Altitudes table file")

  END SUBROUTINE OpenAndInitialize

!=============================================================================
  SUBROUTINE OpenL0File (pcf, unit, filename, filetype, TAI_range)
!=============================================================================

    INTEGER :: pcf, unit
    CHARACTER(LEN=*) :: filename, filetype
    TYPE (TAI93_Range_T), OPTIONAL :: TAI_range

    INTEGER :: returnStatus, version
    CHARACTER(LEN=480) :: msg
    TYPE (TAI93_Range_T) :: TAI

    ! Externals

    INTEGER, EXTERNAL :: PGS_IO_L0_Open

    version = 1
    returnStatus = PGS_PC_getReference (pcf, version, filename)

    IF (returnStatus /= PGS_S_SUCCESS) THEN

       WRITE (msg, "('Error opening ', a, ' file for PCF: ', i5)") filetype, pcf
       CALL MLSMessage (MLSMSG_Error, ModuleName, msg)

    ENDIF

    returnStatus = PGS_IO_L0_Open (pcf, PGSd_EOS_AURA, unit, &
         TAI%startTime, TAI%endTime)
    IF (PRESENT (TAI_range)) THEN
       TAI_range%startTime = TAI%startTime
       TAI_range%endTime = TAI%endTime
    ENDIF

    IF (returnStatus /= PGS_S_SUCCESS) THEN

       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Error opening L0 "//filetype//" file: "//filename)

    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened L0 "//filetype//" file: "//filename)

  END SUBROUTINE OpenL0File

!=============================================================================
  SUBROUTINE OpenL0Files
!=============================================================================

    USE MLSPCF1, ONLY: mlspcf_APID1732_start, mlspcf_APID1734_start, &
         mlspcf_APID1736_start, mlspcf_APID1738_start, mlspcf_APID1740_start, &
         mlspcf_APID1742_start, mlspcf_APID1744_start, mlspcf_APID1746_start
    USE MLSL1Common, ONLY: L0FileInfo
    USE MLSL1Config, ONLY: L1Config

    INTEGER :: i, returnStatus

    TYPE (TAI93_Range_T) :: TAI_range
    INTEGER, EXTERNAL :: PGS_IO_L0_SetStart
    INTEGER, EXTERNAL :: PGS_IO_L0_Close

    ! Init starting PCFs:

    L0FileInfo%eng_pcf(1) = mlspcf_APID1732_start
    L0FileInfo%eng_pcf(2) = mlspcf_APID1734_start
    L0FileInfo%eng_pcf(3) = mlspcf_APID1736_start
    L0FileInfo%eng_pcf(4) = mlspcf_APID1738_start
    L0FileInfo%eng_pcf(5) = mlspcf_APID1740_start
    L0FileInfo%eng_pcf(6) = mlspcf_APID1742_start

    L0FileInfo%sci_pcf(1) = mlspcf_APID1744_start
    L0FileInfo%sci_pcf(2) = mlspcf_APID1746_start

    ! Open L0 Science Files:

    DO i = 1, 2

       DO
          CALL OpenL0File (L0FileInfo%sci_pcf(i), L0FileInfo%sci_unit(i), &
               L0FileInfo%SciFilename(i), "Science", TAI_range)

          !! Check against start time

          IF (L1Config%Expanded_TAI%startTime > TAI_range%endTime) THEN

             returnStatus = PGS_IO_L0_Close (L0FileInfo%sci_unit(i))           
             CALL MLSMessage (MLSMSG_Info, ModuleName, &
                  & 'Closed L0 Science file: '//L0FileInfo%SciFileName(i))
             L0FileInfo%sci_pcf(i) = L0FileInfo%sci_pcf(i) + 1

          ELSE IF (L1Config%Expanded_TAI%startTime < TAI_range%startTime) THEN

             L1Config%Expanded_TAI%startTime = TAI_range%startTime
             CALL MLSMessage (MLSMSG_Warning, ModuleName, &
                  & "Adjusting start time to beginning of first data file")

          ELSE IF (L1Config%Expanded_TAI%startTime < TAI_range%startTime) THEN

             CALL MLSMessage (MLSMSG_Error, ModuleName, &
                  "Requested tart time is before first data file start time")

          ELSE
             EXIT
          ENDIF

       ENDDO

       returnStatus = PGS_IO_L0_SetStart (L0FileInfo%sci_unit(i), &
            L1Config%Expanded_TAI%startTime)

       IF (returnStatus /= PGS_S_SUCCESS) THEN

          CALL MLSMessage (MLSMSG_Error, ModuleName, &
               & "Error positioning L0 file: "//L0FileInfo%SciFilename(i))

       ENDIF

    ENDDO

    ! Open L0 Engineering Files:

    DO i = 1, 6

       DO
          CALL OpenL0File (L0FileInfo%eng_pcf(i), L0FileInfo%eng_unit(i), &
               L0FileInfo%EngFilename(i), "Engineering", TAI_range)

          !! Check against start time

          IF (L1Config%Expanded_TAI%startTime > TAI_range%endTime) THEN

             returnStatus = PGS_IO_L0_Close (L0FileInfo%eng_unit(i))
             CALL MLSMessage (MLSMSG_Info, ModuleName, &
                  & 'Closed L0 Engineering file: '//L0FileInfo%EngFileName(i))
             L0FileInfo%eng_pcf(i) = L0FileInfo%eng_pcf(i) + 1

          ELSE IF (L1Config%Expanded_TAI%startTime < TAI_range%startTime) THEN

             L1Config%Expanded_TAI%startTime = TAI_range%startTime
             CALL MLSMessage (MLSMSG_Warning, ModuleName, &
                  & "Adjusting start time to beginning of first data file")

          ELSE IF (L1Config%Expanded_TAI%startTime < TAI_range%startTime) THEN

             CALL MLSMessage (MLSMSG_Error, ModuleName, &
                  "Requested start time is before first data file start time")

          ELSE
             EXIT
          ENDIF

       ENDDO

       returnStatus = PGS_IO_L0_SetStart (L0FileInfo%eng_unit(i), &
            L1Config%Expanded_TAI%startTime)

       IF (returnStatus /= PGS_S_SUCCESS) THEN

          CALL MLSMessage (MLSMSG_Error, ModuleName, &
               & "Error positioning L0 file: "//L0FileInfo%EngFilename(i))

       ENDIF

    ENDDO

  END SUBROUTINE OpenL0Files

!=============================================================================
  SUBROUTINE OpenL1BFiles (THz)
!=============================================================================

    USE MLSPCF1, ONLY: mlspcf_l1b_radf_start, mlspcf_l1b_radd_start, &
         mlspcf_l1b_oa_start, mlspcf_l1b_diag_start, mlspcf_l1b_radt_start, &
         mlspcf_l1b_diagT_start
    USE MLSL1Common, ONLY: L1BFileInfo, HDFversion, SC_YPR, &
         &THz_GeodAlt, MaxMIFs,FileNameLen
    USE MLSFiles, ONLY: MLS_openFile, MLS_closeFile
    USE MLSHDF5, ONLY: MLS_h5open, GetHDF5Attribute
    USE HDF5, ONLY: H5gOpen_f, H5gClose_f
    USE io_stuff, ONLY: get_lun
    USE L1BData, ONLY: L1BData_T, ReadL1BData, DeallocateL1BData
    USE MLSL1Config, ONLY: MIFsTHz, L1Config
    USE BrightObjects_m, ONLY: THz_BO_stat
    USE DACsUtils, ONLY: TPz

    LOGICAL :: THz

    CHARACTER (LEN=FileNameLen) :: PhysicalFilename
    INTEGER :: error, returnStatus, grp_id, sd_id, version
    INTEGER :: noMAFs, Flag
    INTEGER :: firstMAF = 0
    CHARACTER (LEN=*), PARAMETER :: counterMAFname = "counterMAF"
    CHARACTER (LEN=*), PARAMETER :: BO_stat_name = "/THz/BO_stat"
    CHARACTER (LEN=*), PARAMETER :: ypr_name = "/sc/ypr"
    CHARACTER (LEN=*), PARAMETER :: THz_GeodAlt_name = "/THz/GeodAlt"
    CHARACTER (LEN=*), PARAMETER :: THz_GeodAltX_name = "/THz/GeodAltX"
    TYPE (L1BData_T) :: L1BOAData

    INTEGER, EXTERNAL :: PGS_IO_Gen_Track_LUN

 !! Open the HDF 5 Fortran Interface based on CF file

    error = 0
    CALL MLS_h5open (error)
    IF (error /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         "Fortran HDF 5 API error on opening.")

    ! Initialize IDs

    L1BFileInfo%RADGID = 0
    L1BFileInfo%RADDID = 0
    L1BFileInfo%RADTID = 0
    L1BFileInfo%OAID = 0
    L1BFileInfo%DIAGID = 0
    L1BFileInfo%DIAGTID = 0
    L1BFileInfo%ENGID = -1    ! Non-HDF unit
    call get_lun( L1BFileInfo%EngId )

    ! Open L1BRADT File

    IF (THz) THEN
       version = 1
       returnStatus = PGS_PC_getReference (mlspcf_l1b_radt_start, version, &
            PhysicalFilename)

       IF (returnStatus == PGS_S_SUCCESS) THEN

          ! Open the HDF file and initialize the SD interface

          CALL MLS_openFile (PhysicalFilename, 'create', sd_id, hdfVersion)
          CALL MLSMessage (MLSMSG_Info, &
               & ModuleName, "Opened L1BRADT file: "//PhysicalFilename)
          L1BFileInfo%RADTID = sd_id
          L1BFileInfo%RADTFileName = PhysicalFilename

       ELSE

          CALL MLSMessage (MLSMSG_Error, ModuleName, &
               & "Could not find L1BRADT file entry")

       ENDIF

    ! Open L1BDIAG THz File

       version = 1
       returnStatus = PGS_PC_getReference (mlspcf_l1b_diagT_start, version, &
            PhysicalFilename)

       IF (returnStatus == PGS_S_SUCCESS) THEN

          ! Open the HDF file and initialize the SD interface

          CALL MLS_openFile (PhysicalFilename, 'create', sd_id, hdfVersion)

          CALL MLSMessage (MLSMSG_Info, ModuleName, &
               & "Opened L1B THz diagnostics file: " // PhysicalFilename)

          L1BFileInfo%DiagTFileName = PhysicalFilename
          L1BFileInfo%DiagTID = sd_id

       ELSE

          CALL MLSMessage (MLSMSG_Error, ModuleName, &
               & "Could not find L1BDIAG THz file entry")

       ENDIF

    ! Open L1BOA File for use in start counterMAF

       version = 1
       returnStatus = PGS_PC_getReference (mlspcf_l1b_oa_start, version, &
            PhysicalFilename)

       IF (returnStatus == PGS_S_SUCCESS) THEN

          ! Open the HDF file and read first counterMAF plus BO_stat:

          CALL MLS_openFile (PhysicalFilename, 'readonly', sd_id, hdfVersion)
          CALL MLSMessage (MLSMSG_Info, &
               & ModuleName, "Opened L1BOA file: "//PhysicalFilename)
          L1BFileInfo%OAID = sd_id
          L1BFileInfo%OAFileName = PhysicalFilename

          CALL ReadL1BData (L1BFileInfo%OAid, counterMAFname, L1BOAData, &
               noMAFs, Flag, firstMAF, NeverFail=.TRUE., HDFversion=5)
          ALLOCATE (OA_counterMAF(noMAFs))
          OA_counterIndex = 1
          OA_counterMAF = L1BOAData%IntField(1,1,:)
          CALL DeallocateL1BData (L1BOAData)

          CALL ReadL1BData (L1BFileInfo%OAid, BO_stat_name, L1BOAData, &
               noMAFs, Flag, firstMAF, NeverFail=.TRUE., HDFversion=5)
          ALLOCATE (THz_BO_stat(MIFsTHz,noMAFs))

          THz_BO_stat = L1BOAData%IntField(1,1:MIFsTHz,:)
          CALL DeallocateL1BData (L1BOAData)

          CALL ReadL1BData (L1BFileInfo%OAid, ypr_name, L1BOAData, &
               noMAFs, Flag, firstMAF, NeverFail=.TRUE., HDFversion=5)
          ALLOCATE (SC_YPR(3,0:(MaxMIFs-1),noMAFs))
          SC_YPR(:,0:147,:) = L1BOAData%DpField(:,:,:)
          SC_YPR(:,148,:) = SC_YPR(:,147,:)  ! extend to end MIFs
          SC_YPR(:,149,:) = SC_YPR(:,147,:)
          CALL DeallocateL1BData (L1BOAData)

          CALL ReadL1BData (L1BFileInfo%OAid, THz_GeodAlt_name, L1BOAData, &
               noMAFs, Flag, firstMAF, NeverFail=.TRUE., HDFversion=5)
          ALLOCATE (THz_GeodAlt(0:(MaxMIFs-1),noMAFs))
          THz_GeodAlt(0:124,:) = L1BOAData%DpField(1,:,:)
          CALL DeallocateL1BData (L1BOAData)
          CALL ReadL1BData (L1BFileInfo%OAid, THz_GeodAltX_name, L1BOAData, &
               noMAFs, Flag, firstMAF, NeverFail=.TRUE., HDFversion=5)
          THz_GeodAlt(125:147,:) = L1BOAData%DpField(1,:,:)
          THz_GeodAlt(148,:) = THz_GeodAlt(147,:)  ! extend to end MIFs
          THz_GeodAlt(149,:) = THz_GeodAlt(147,:)  ! extend to end MIFs
          CALL DeallocateL1BData (L1BOAData)

          CALL MLS_closeFile (L1BFileInfo%OAid, HDFversion=HDFversion)
          CALL MLSMessage (MLSMSG_Info, ModuleName, &
               & 'Closed L1BOA file: '//L1BFileInfo%OAFileName)

       ELSE

          OA_counterMAF = 0   ! Nothing available
          CALL MLSMessage (MLSMSG_Warning, ModuleName, &
               & "Could not find L1BOA file entry")

       ENDIF

       RETURN   !! Nothing more to Open

    ENDIF

    ! Open L1BRADD File

    IF (L1Config%Calib%CalibDACS) THEN
       version = 1
       returnStatus = PGS_PC_getReference (mlspcf_l1b_radd_start, version, &
            PhysicalFilename)

       IF (returnStatus == PGS_S_SUCCESS) THEN

          ! Open the HDF file and initialize the SD interface

          CALL MLS_openFile (PhysicalFilename, 'update', sd_id, hdfVersion)
          CALL MLSMessage (MLSMSG_Info, &
               & ModuleName, "Opened L1BRADD file: "//PhysicalFilename)
          L1BFileInfo%RADDID = sd_id
          L1BFileInfo%RADDFileName = PhysicalFilename

          ! Get TPz attribute:

          CALL H5gOpen_f (sd_id, '/', grp_id, returnStatus)
          CALL GetHDF5Attribute (grp_id, 'TPz', TPz)
          CALL H5gClose_f (grp_id, returnStatus )
       ELSE

          CALL MLSMessage (MLSMSG_Error, ModuleName, &
               & "Could not find L1BRADD file entry")

       ENDIF
    ENDIF

    ! Open L1BRADG File

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_l1b_radf_start, version, &
     PhysicalFilename)

    IF (returnStatus == PGS_S_SUCCESS) THEN

       ! Open the HDF file and initialize the SD interface


       CALL MLS_openFile (PhysicalFilename, 'create', sd_id, hdfVersion)
       CALL MLSMessage (MLSMSG_Info, &
            & ModuleName, "Opened L1BRADG file: "//PhysicalFilename)
       L1BFileInfo%RADGID = sd_id
       L1BFileInfo%RADGFileName = PhysicalFilename

    ELSE

       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not find L1BRADG file entry")

    ENDIF

    ! Open L1BOA File

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_l1b_oa_start, version, &
     PhysicalFilename)

    IF (returnStatus == PGS_S_SUCCESS) THEN

       ! Open the HDF file and initialize the SD interface

       CALL MLS_openFile (PhysicalFilename, 'create', sd_id, hdfVersion)
       CALL MLSMessage (MLSMSG_Info, &
            & ModuleName, "Opened L1BOA file: "//PhysicalFilename)
       L1BFileInfo%OAID = sd_id
       L1BFileInfo%OAFileName = PhysicalFilename

    ELSE

       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not find L1BOA file entry")

    ENDIF

    ! Open L1BDIAG File

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_l1b_diag_start, version, &
     PhysicalFilename)

    IF (returnStatus == PGS_S_SUCCESS) THEN

       ! Open the HDF file and initialize the SD interface

       CALL MLS_openFile (PhysicalFilename, 'create', sd_id, hdfVersion)

       CALL MLSMessage (MLSMSG_Info, ModuleName, &
            & "Opened L1B diagnostics file: " // PhysicalFilename)

       L1BFileInfo%DiagFileName = PhysicalFilename
       L1BFileInfo%DiagID = sd_id

    ELSE

       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not find L1BDIAG file entry")

    ENDIF

  END SUBROUTINE OpenL1BFiles

!=============================================================================
  SUBROUTINE LoadChanDefaults (unit, deflt_dat, stat)
!=============================================================================

    ! Used to load the defaults from the default gain and channel zeros files
    ! (typically named IF-zeros.tbl and deflt-gains.tbl, currently residing in
    ! /data/emls/l1cal)

    USE MLSL1Common, ONLY: Chan_R_T, WFNum

    INTEGER :: unit, stat
    TYPE (Chan_R_T), TARGET :: deflt_dat

    CHARACTER(LEN=2) :: chan_type
    CHARACTER(LEN=80) :: line
    INTEGER :: ios, i
    REAL, POINTER, DIMENSION(:,:) :: chan_dat

    stat = 0

! Read comments until start of data

    DO
       READ (unit, '(A)') line
       IF (line(1:6) == "#DATA") EXIT
    ENDDO

! read data

! This routine assumes that the data is arranged as FB in FB number order
! (i.e. all 25 channels for FB 1, followed by all 25 channels for FB 2, ... up
! to FB 19), followed by MB in order, (again all 11 channels for MB 1, then 11
! channels for MB2, etc) followed by the WF. If the file isn't arranged that
! way, the data won't be arranged correctly.

    i = 1
    chan_type = "FB"
    chan_dat => deflt_dat%fb
    DO

       DO
          READ (unit, '(A)', IOSTAT=ios) line
          IF (line(1:1) == "#" .OR. ios /= 0) EXIT
       ENDDO

       IF (ios /= 0) EXIT

       READ (unit, *) chan_dat(:,i)

       i = i + 1

       SELECT CASE (chan_type)

       CASE ("FB")
          IF (I > SIZE (deflt_dat%fb(1,:))) THEN
             i = 1
             chan_dat => deflt_dat%mb
             chan_type = "MB"
          ENDIF
       CASE ("MB")
          IF (I > SIZE (deflt_dat%mb(1,:))) THEN
             i = 1
             chan_dat => deflt_dat%wf
             chan_type = "WF"
          ENDIF
       END SELECT

    ENDDO

    IF (chan_type /= "WF" .AND. i <= WFNum) stat = -1  ! Error!!!

  END SUBROUTINE LoadChanDefaults

!=============================================================================
  LOGICAL FUNCTION not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (len=*), PARAMETER :: IdParm = &
       "$Id: OpenInit.f90,v 2.33 2016/03/15 22:17:59 whdaffer Exp $"
  CHARACTER (len=LEN(idParm)), SAVE :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  END FUNCTION not_used_here
END MODULE OpenInit
!=============================================================================

! $Log: OpenInit.f90,v $
! Revision 2.33  2016/03/15 22:17:59  whdaffer
! Merged whd-rel-1-0 back onto main branch. Most changes
! are to comments, but there's some modification to Calibration.f90
! and MLSL1Common to support some new modules: MLSL1Debug and SnoopMLSL1.
!
! Revision 2.32.2.1  2015/10/09 10:21:38  whdaffer
! checkin of continuing work on branch whd-rel-1-0
!
! Revision 2.32  2015/04/23 17:46:27  whdaffer
! removed Makefile
!
! Revision 2.31  2015/01/21 19:31:23  pwagner
! Fortran unit must not be -1
!
! Revision 2.30  2007/06/21 21:03:34  perun
! Only open RADD file if DACS calibration is enabled
!
! Revision 2.29  2006/08/02 18:56:04  perun
! Open RADD file in update mode and get TPz attribute from it
!
! Revision 2.28  2006/06/14 13:47:47  perun
! Open stray radiance file and read Fourier coefficients
!
! Revision 2.27  2006/04/05 18:09:38  perun
! Remove unused variables
!
! Revision 2.26  2006/03/31 16:26:40  perun
! Remove expanded UTC from Global Attributes
!
! Revision 2.25  2006/03/24 15:14:55  perun
! Expand processing times, init Band Altitudes table, init Band Switches and read SC_YPR and THz GeodAlts
!
! Revision 2.24  2005/12/06 19:28:04  perun
! Added reading BO_stat for use in THz processing
!
! Revision 2.23  2005/10/14 15:54:27  perun
! Expand THz end time to guarantee inclusion of last MAF of day
!
! Revision 2.22  2005/09/22 23:40:12  pwagner
! date conversion procedures and functions all moved into dates module
!
! Revision 2.21  2005/07/12 17:18:15  pwagner
! Dropped global attribute InputVersion
!
! Revision 2.20  2005/06/23 18:41:36  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.19  2005/05/02 16:05:44  perun
! Write out setting for the UseAntOffsets
!
! Revision 2.18  2004/11/10 15:42:35  perun
! Open and init default Chi2 table and baselineAC table; get initial counterMAF
! value from L1BOA file
!
! Revision 2.17  2004/08/04 23:20:25  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.16  2004/05/14 15:59:11  perun
! Version 1.43 commit
!
! Revision 2.15  2004/05/06 21:59:23  pwagner
! Uses mls_h5open/close
!
! Revision 2.14  2004/01/09 17:46:22  perun
! Version 1.4 commit
!
! Revision 2.13  2003/09/15 17:15:53  perun
! Version 1.3 commit
!
! Revision 2.12  2003/08/15 14:25:04  perun
! Version 1.2 commit
!
! Revision 2.11  2003/06/03 20:43:54  pwagner
! Fills global attributes
!
! Revision 2.10  2003/01/31 18:13:34  perun
! Version 1.1 commit
!
! Revision 2.9  2002/11/20 16:07:28  perun
! Always get PCF annotations and moved h5open_f to OpenL1BFiles routine
!
! Revision 2.8  2002/11/19 21:21:46  perun
! Use HDFversion instead of HDFVersionString
!
! Revision 2.7  2002/11/14 21:46:04  perun
! Restored PCF annotations for HDF 4
!
! Revision 2.6  2002/11/07 21:54:20  jdone
! Added HDF4/HDF5 switch.
!
! Revision 2.5  2002/03/29 20:18:34  perun
! Version 1.0 commit
!
! Revision 2.4  2001/03/22 16:46:02  perun
! Check CF and PCF outputVersions
!
! Revision 2.3  2001/03/12 19:36:00  perun
! Read and save CF file as annotation
!
! Revision 2.1  2001/02/23 20:54:11  perun
! Version 0.5 commit
!
@


2.33
log
@Merged whd-rel-1-0 back onto main branch. Most changes
are to comments, but there's some modification to Calibration.f90
and MLSL1Common to support some new modules: MLSL1Debug and SnoopMLSL1.
@
text
@d194 4
d199 2
a200 1
            & "CF and PCF OutputVersions do not match!")
d404 1
a404 1
    !OpenAndInitializeLog called from MLSL1log </whd>
d1189 1
a1189 1
       "$Id: OpenInit.f90,v 2.32.2.1 2015/10/09 10:21:38 whdaffer Exp $"
d1198 5
@


2.32
log
@removed Makefile
@
text
@d23 2
d46 1
d60 1
a60 1
         THzType, THz_SwMir_Range, THzTol, BandSwitch
d74 1
a74 1
    CHARACTER (LEN=132) :: PhysicalFilename
d86 8
d98 20
d205 5
d262 1
a262 1
!! Open and initialize eng table:
d398 3
d419 1
a419 1
    IF (PhysicalFilename /= L1PCF%PCF_filename) THEN
d421 1
a421 1
            & "PCF_filenames do not match: " // PhysicalFilename)
d425 1
a425 1
    IF (PhysicalFilename /= L1PCF%L1CF_filename) THEN
d427 1
a427 1
            & "L1CF_filenames do not match: " // PhysicalFilename)
d844 2
a845 1
    USE MLSL1Common, ONLY: L1BFileInfo, HDFversion, SC_YPR, THz_GeodAlt, MaxMIFs
d857 1
a857 1
    CHARACTER (LEN=132) :: PhysicalFilename
d1184 1
a1184 1
       "$Id: OpenInit.f90,v 2.31 2015/01/21 19:31:23 pwagner Exp $"
d1193 6
@


2.32.2.1
log
@checkin of continuing work on branch whd-rel-1-0
@
text
@a22 2
  USE MLSL1DEBUG, ONLY: MLSL1DEBUG_INIT
 
a43 1
    USE MLSL1Debug, ONLY: MLSL1Debug_Init, openMLSL1DebugFiles
d57 1
a57 1
         THzType, THz_SwMir_Range, THzTol, BandSwitch,FileNameLen
d71 1
a71 1
    CHARACTER (LEN=FileNameLen) :: PhysicalFilename
a82 8

    !! <whd:debug> Initialize MLSL1DEBUG module
    CALL MLSL1Debug_Init() 
    !! Open any files that might be needed for debugging
    CALL openMLSL1DebugFiles()
    !! </whd:debug>

    !! Call
a86 20
    !! <whd comment> 
    !!
    !! A word on variables like `mlspcf_l1b_log_start', because you'll be seeing
    !! lots of them in this next part fo the code. 
    !!
    !! The value of this variable is given by a parameter in MLSPCF1.f90. In the
    !! case of this variable, its value is 30006. This is the PCF ID, you'll
    !! find it in the first column of the PCF file, the remainder of that line
    !! of the PCF file gives the name and directory of the log file. You'll see
    !! this again and again, as you peruse the code below, so I'm telling you
    !! how to go about finding which file the code is accessing. It's curious
    !! that a few lines along it asks for the name of the PCF file, when its
    !! actually reading the PCF file to get this information. I don' quite know
    !! how that works, maybe there's an environmental variable being used
    !! somewhere that I don't know about.  
    !!
    !! </whd comment>


    !! Open MLS-Aura_L1BLOG (or whatever is at PCF ID 30006 in the PCF)
a173 5
    IF (procRange%startTime .GE. procRange%endTime) THEN 
       CALL MLSMessage(MLSMSG_Error, ModuleName, &
            & "Bad processing range time: start >= end! " // &
            "Check your .PCF!")
    ENDIF
d226 1
a226 1
!! Open and initialize eng table: (<whd>: engtlm.tbl, PCF ID 903)
a361 3
    !<whd>: PCF ID: 922. MAF_data_tmp.dat. This was created by
    !OpenAndInitializeLog called from MLSL1log </whd>

d380 1
a380 1
    IF (trim(PhysicalFilename) /= trim(L1PCF%PCF_filename)) THEN
d382 1
a382 1
            & "PCF_filenames do not match: " // trim(PhysicalFilename))
d386 1
a386 1
    IF (trim(PhysicalFilename) /= trim(L1PCF%L1CF_filename)) THEN
d388 1
a388 1
            & "L1CF_filenames do not match: " // trim(PhysicalFilename))
d805 1
a805 2
    USE MLSL1Common, ONLY: L1BFileInfo, HDFversion, SC_YPR, &
         &THz_GeodAlt, MaxMIFs,FileNameLen
d817 1
a817 1
    CHARACTER (LEN=FileNameLen) :: PhysicalFilename
d1144 1
a1144 1
       "$Id: OpenInit.f90,v 2.32 2015/04/23 17:46:27 whdaffer Exp $"
a1152 3
! Revision 2.32  2015/04/23 17:46:27  whdaffer
! removed Makefile
!
@


2.31
log
@Fortran unit must not be -1
@
text
@d1071 4
d1096 6
d1144 1
a1144 1
       "$Id: OpenInit.f90,v 2.30 2007/06/21 21:03:34 perun Exp $"
d1153 3
@


2.30
log
@Only open RADD file if DACS calibration is enabled
@
text
@d809 1
d846 1
d1134 1
a1134 1
       "$Id: OpenInit.f90,v 2.29 2006/08/02 18:56:04 perun Exp $"
d1143 3
@


2.29
log
@Open RADD file in update mode and get TPz attribute from it
@
text
@d810 1
a810 1
    USE MLSL1Config, ONLY: MIFsTHz
d963 4
a966 3
    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_l1b_radd_start, version, &
     PhysicalFilename)
d968 1
a968 1
    IF (returnStatus == PGS_S_SUCCESS) THEN
d970 1
a970 1
       ! Open the HDF file and initialize the SD interface
d972 12
a983 12
       CALL MLS_openFile (PhysicalFilename, 'update', sd_id, hdfVersion)
       CALL MLSMessage (MLSMSG_Info, &
            & ModuleName, "Opened L1BRADD file: "//PhysicalFilename)
       L1BFileInfo%RADDID = sd_id
       L1BFileInfo%RADDFileName = PhysicalFilename

       ! Get TPz attribute:

       CALL H5gOpen_f (sd_id, '/', grp_id, returnStatus)
       CALL GetHDF5Attribute (grp_id, 'TPz', TPz)
       CALL H5gClose_f (grp_id, returnStatus )
    ELSE
d985 2
a986 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not find L1BRADD file entry")
d988 1
d1132 1
a1132 1
       "$Id: OpenInit.f90,v 2.28 2006/06/14 13:47:47 perun Exp $"
d1141 3
@


2.28
log
@Open stray radiance file and read Fourier coefficients
@
text
@d807 2
a808 1
    USE MLSHDF5, ONLY: MLS_h5open
d812 1
d817 1
a817 1
    INTEGER :: error, returnStatus, sd_id, version
d971 1
a971 1
       CALL MLS_openFile (PhysicalFilename, 'create', sd_id, hdfVersion)
d977 5
d1130 1
a1130 1
       "$Id: OpenInit.f90,v 2.27 2006/04/05 18:09:38 perun Exp $"
d1139 3
@


2.27
log
@Remove unused variables
@
text
@d52 1
a52 1
         mlspcf_bandalts_start
d63 1
a63 1
         LoadDefltChi2, LoadBandAlts
d496 32
d1123 1
a1123 1
       "$Id: OpenInit.f90,v 2.26 2006/03/31 16:26:40 perun Exp $"
d1132 3
@


2.26
log
@Remove expanded UTC from Global Attributes
@
text
@d785 1
a785 1
    INTEGER :: firstMAF = 0, lastMAF = 0
d1091 1
a1091 1
       "$Id: OpenInit.f90,v 2.25 2006/03/24 15:14:55 perun Exp $"
d1100 3
@


2.25
log
@Expand processing times, init Band Altitudes table, init Band Switches and read SC_YPR and THz GeodAlts
@
text
@a71 1
    CHARACTER (LEN=28) :: asciiUTC_A
d79 1
a79 2
    INTEGER, EXTERNAL :: PGS_TD_UTCtoTAI,  PGS_TD_TAItoUTC, &
         PGS_TD_ASCIItime_AtoB, PGS_IO_Gen_Track_LUN
a178 5
    returnStatus = PGS_TD_TAItoUTC (procRange%startTime, asciiUTC_A)
    returnStatus = PGS_TD_ASCIItime_AtoB (asciiUTC_A, L1PCF%startUTC)
    returnStatus = PGS_TD_TAItoUTC (procRange%endTime, asciiUTC_A)
    returnStatus = PGS_TD_ASCIItime_AtoB (asciiUTC_A, L1PCF%endUTC)

d1091 1
a1091 1
       "$Id: OpenInit.f90,v 2.24 2005/12/06 19:28:04 perun Exp $"
d1100 3
@


2.24
log
@Added reading BO_stat for use in THz processing
@
text
@d1 1
a1 1
! Copyright 2005, by the California Institute of Technology. ALL
d33 1
a33 1
  character (len=*), private, parameter :: ModuleName= &
d35 1
a35 1
  private :: not_used_here 
d51 2
a52 1
         mlspcf_defltbaselineAC_start, mlspcf_l1b_log_start
d57 1
a57 1
         THzType, THz_SwMir_Range, THzTol
d63 1
a63 1
         LoadDefltChi2
d69 1
d72 1
d80 2
a81 1
    INTEGER, EXTERNAL :: PGS_TD_UTCtoTAI, PGS_IO_Gen_Track_LUN
d171 2
d176 10
a189 1
    ! GlobalAttributes%InputVersion = L1PCF%OutputVersion
a198 2
    MAF_dur = L1Config%Calib%MIF_duration * L1Config%Calib%MIFsPerMAF

d217 5
d571 33
d780 1
a780 1
    USE MLSL1Common, ONLY: L1BFileInfo, HDFversion
d795 3
d894 22
a915 1
          THz_BO_stat = L1BOAData%IntField(1,:,:)
d1095 1
a1095 1
  logical function not_used_here()
d1097 3
a1099 3
  character (len=*), parameter :: IdParm = &
       "$Id: OpenInit.f90,v 2.23 2005/10/14 15:54:27 perun Exp $"
  character (len=len(idParm)), save :: Id = idParm
d1102 1
a1102 1
  end function not_used_here
d1107 3
@


2.23
log
@Expand THz end time to guarantee inclusion of last MAF of day
@
text
@d733 2
a734 1

d743 1
d822 1
a822 1
          ! Open the HDF file and read first counterMAF
d834 7
a840 1
          OA_counterMAF = L1BOAData%IntField(:,1,1)
d1023 1
a1023 1
       "$Id: OpenInit.f90,v 2.22 2005/09/22 23:40:12 pwagner Exp $"
d1032 3
@


2.22
log
@date conversion procedures and functions all moved into dates module
@
text
@d199 3
a201 2
    ELSE   ! expand end time for THz
       L1Config%Expanded_TAI%endTime = L1Config%Expanded_TAI%endTime + MAF_dur
d1015 1
a1015 1
       "$Id: OpenInit.f90,v 2.21 2005/07/12 17:18:15 pwagner Exp $"
d1024 3
@


2.21
log
@Dropped global attribute InputVersion
@
text
@d53 1
a53 1
    USE MLSStringLists, ONLY: utc_to_yyyymmdd
d1014 1
a1014 1
       "$Id: OpenInit.f90,v 2.20 2005/06/23 18:41:36 pwagner Exp $"
d1023 3
@


2.20
log
@Reworded Copyright statement, moved rcs id
@
text
@d34 1
a34 1
       "$RCSfile: $"
d174 1
a174 1
    GlobalAttributes%InputVersion = L1PCF%OutputVersion
d1014 1
a1014 1
       "$Id: $"
d1023 3
@


2.19
log
@Write out setting for the UseAntOffsets
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d32 5
a36 5
  !------------------------------- RCS Ident Info ------------------------------
  CHARACTER(LEN=130) :: id = &
       "$Id: OpenInit.f90,v 2.18 2004/11/10 15:42:35 perun Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: OpenInit.f90,v $"
  !-----------------------------------------------------------------------------
d1011 8
d1023 3
@


2.18
log
@Open and init default Chi2 table and baselineAC table; get initial counterMAF
value from L1BOA file
@
text
@d1 1
a1 1
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
d26 1
a26 1
       "$Id: OpenInit.f90,v 2.17 2004/08/04 23:20:25 pwagner Exp $"
d140 10
d1007 4
@


2.17
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d13 1
d26 1
a26 1
       "$Id: OpenInit.f90,v 2.16 2004/05/14 15:59:11 perun Exp $"
d42 2
a43 1
         mlspcf_spilloverloss_start, mlspcf_l1b_log_start
d53 2
a54 1
    USE BandTbls, ONLY: Load_Band_tbls, LoadSidebandFracs, LoadSpilloverLoss
d59 1
d63 1
a63 1
    INTEGER :: ios, lid, returnStatus, version, tbl_unit
d177 4
d387 4
d466 68
d711 1
a711 1
    USE MLSFiles, ONLY: MLS_openFile
d713 2
d720 4
d793 35
d997 3
@


2.16
log
@Version 1.43 commit
@
text
@d25 1
a25 1
       "$Id: OpenInit.f90,v 2.15 2004/05/06 21:59:23 pwagner Exp $"
d43 1
a43 1
    USE MLSStrings, ONLY: utc_to_yyyymmdd
d876 3
@


2.15
log
@Uses mls_h5open/close
@
text
@d25 1
a25 1
       "$Id: OpenInit.f90,v 2.14 2004/01/09 17:46:22 perun Exp $"
d41 1
a41 1
         mlspcf_spilloverloss_start
d71 39
d259 1
d628 2
a629 1
         mlspcf_l1b_oa_start, mlspcf_l1b_diag_start, mlspcf_l1b_radt_start
d632 1
a632 2
    use MLSHDF5, only: mls_h5open
!    USE H5LIB
d644 1
a644 1
    CALL mls_h5open (error)
d655 1
d682 25
d876 3
@


2.14
log
@Version 1.4 commit
@
text
@d25 1
a25 1
       "$Id: OpenInit.f90,v 2.13 2003/09/15 17:15:53 perun Exp $"
d591 1
d604 1
a604 1
    CALL h5open_f (error)
d810 3
@


2.13
log
@Version 1.3 commit
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 2
a19 1
  PUBLIC :: OpenAndInitialize, OpenL0File, OpenL0Files, anTextPCF, anTextCF
d25 1
a25 1
       "$Id: OpenInit.f90,v 2.12 2003/08/15 14:25:04 perun Exp $"
d37 5
a41 5
    USE MLSPCF1, ONLY: mlspcf_engtbl_start, mlspcf_bwtbl_start, &
         mlspcf_nomen_start, mlspcf_pcf_start, mlspcf_l1cf_start, &
         mlspcf_defltgains_start, mlspcf_defltzeros_start, &
         mlspcf_dacsconst_start, mlspcf_MAF_data_start, &
         mlspcf_sidebandfrac_start, mlspcf_spilloverloss_start
d46 1
a46 1
         THzType
d49 1
a49 1
    USE Calibration !, ONLY: InitCalibWindow
d51 1
d54 1
a54 2
    USE OutputL1B, ONLY: OutputL1B_create
    USE DACSUtils, ONLY: InitDACS_FFT
d59 1
a59 1
    INTEGER :: ios, returnStatus, version, tbl_unit
d61 1
a61 1
    LOGICAL :: THz
d111 1
a111 1
!! Store appropriate user input as global attributes
d117 1
a117 1
    GlobalAttributes%PGEVersion = 'v1.2'  ! L1PCF%PGEVersion
d123 2
d134 2
a137 2
    MAF_dur = L1Config%Calib%MIF_duration * L1Config%Calib%MIFsPerMAF

a180 32
!! Open and initialize bandwidths table:

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_bwtbl_start, version, &
          & PhysicalFilename)

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_bwtbl_start, PGSd_IO_Gen_RSeqFrm, &
         0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open bandwidths table file: " // PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened bandwidths table file: " // PhysicalFilename)

    CALL LoadBandwidths (tbl_unit, ios)

    returnStatus = PGS_IO_Gen_CloseF (tbl_unit)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading bandwidth table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close bandwidths table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed bandwidths table file")

d213 1
a213 1
!! Open and initialize default zeros table:
d216 7
a222 2
    returnStatus = PGS_PC_getReference (mlspcf_defltzeros_start, version, &
          & PhysicalFilename)
d225 2
a226 2
    returnStatus = PGS_IO_Gen_openF (mlspcf_defltzeros_start, &
         PGSd_IO_Gen_RSeqFrm, 0, tbl_unit, version)
a249 32
!! Open and initialize DACS constants table:

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_dacsconst_start, version, &
          & PhysicalFilename)

    version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_dacsconst_start, &
         PGSd_IO_Gen_RSeqFrm, 0, tbl_unit, version)
    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open DACS constants table file: " // PhysicalFilename)
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Opened DACS constants table file: " // PhysicalFilename)

    CALL LoadDACSconsts (tbl_unit, ios)

    returnStatus = PGS_IO_Gen_CloseF (tbl_unit)

    IF (ios /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
         & "Error reading DACS constants table file")

    IF (returnstatus /= PGS_S_SUCCESS) THEN
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close DACS constants table file")
    ENDIF

    CALL MLSMessage (MLSMSG_Info, ModuleName, &
         & "Closed DACS constants table file")

d313 7
a335 4
!! Initialize DACS FFT

    IF (.NOT. THz) CALL InitDACS_FFT

d340 3
a342 1
!! Define the SD structures in the output files
d344 3
a346 1
    CALL OutputL1B_create (L1BFileInfo, THz)
d589 3
a591 3
    USE MLSL1Common, ONLY: L1BFileInfo
    USE MLSFiles, ONLY: MLS_openFile, HDFVERSION_5
    USE MLSL1Config, ONLY: L1Config
d596 2
a597 1
    INTEGER :: ios, error, returnStatus, sd_id, version, hdfVersion
d600 1
a600 3
    hdfVersion = L1Config%Output%HDFversion

!! Open the HDF 5 Fortran Interface based on CF file
d602 4
a605 6
    IF (hdfVersion == HDFVERSION_5) THEN
       error = 0
       CALL h5open_f (error)
       IF (error /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Fortran HDF 5 API error on opening.")
    ENDIF
d613 1
a614 1
    L1BFileInfo%DIAGID = -1   ! Non-HDF unit
a715 1
    WRITE (PhysicalFilename, "(I5.5)") mlspcf_l1b_diag_start
a720 1
       version = 1
d722 1
a722 1
!! This file is NOT an HDF file.
d724 1
a724 10
       returnStatus = PGS_IO_Gen_Track_LUN (L1BFileInfo%DiagId, 0)

       OPEN (unit=L1BFileInfo%DiagId, file=PhysicalFilename, &
            status="REPLACE", FORM="UNFORMATTED", ACCESS="SEQUENTIAL", &
            iostat=ios)

       IF (ios /= 0) THEN
          CALL MLSMessage (MLSMSG_Error, ModuleName, &
               & "Could not open L1B diagnostics file: " // PhysicalFilename)
       ENDIF
d730 1
a741 42
  SUBROUTINE LoadBandwidths (bw_tbl_unit, ios)
!=============================================================================

    USE MLSL1Common, ONLY: FBnum, MBnum, WFnum, BandWidth

    INTEGER :: bw_tbl_unit, ios
    CHARACTER (len=40) :: line
    INTEGER ::  i
    REAL, PARAMETER :: scale = 1.0e6    ! MHz scale factor

    READ (bw_tbl_unit, '(a)', IOSTAT=ios, ERR=999) line      ! Title line
    DO i = 1, FBnum
       READ (bw_tbl_unit, '(a)', IOSTAT=ios, ERR=999) line   ! Blank line
       READ (bw_tbl_unit, '(a)', IOSTAT=ios, ERR=999) line   ! Band
       READ (bw_tbl_unit, *, IOSTAT=ios, ERR=999) BandWidth%FB(:,i)    ! Banks
    ENDDO
    BandWidth%FB = BandWidth%FB * scale

    DO i = 1, MBnum
       READ (bw_tbl_unit, '(a)', IOSTAT=ios, ERR=999) line   ! Blank line
       READ (bw_tbl_unit, '(a)', IOSTAT=ios, ERR=999) line   ! Band
       READ (bw_tbl_unit, *, IOSTAT=ios, ERR=999) BandWidth%MB(:,i)    ! Banks
    ENDDO
    BandWidth%MB = BandWidth%MB * scale

    DO i = 1, WFnum
       READ (bw_tbl_unit, '(a)', IOSTAT=ios, ERR=999) line   ! Blank line
       READ (bw_tbl_unit, '(a)', IOSTAT=ios, ERR=999) line   ! Band
       READ (bw_tbl_unit, *, IOSTAT=ios, ERR=999) BandWidth%WF(:,i)    ! Banks
    ENDDO
    BandWidth%WF = BandWidth%WF * scale

999 CONTINUE

    IF (ios /= 0) THEN
       CALL MLSMessage (MLSMSG_Error, &
            & ModuleName, "Error reading bandwidths file!")
    ENDIF

  END SUBROUTINE LoadBandwidths

!=============================================================================
a804 98
  SUBROUTINE LoadDACSconsts (unit, ios)
!=============================================================================

    USE MLSL1Common, ONLY: DACS_const

    INTEGER :: unit, ios
    CHARACTER (len=80) :: line

! Read comments until start of data

    DO
       READ (unit, '(A)') line
       IF (line(1:6) == "#DATA") EXIT
    ENDDO

! Read data constants

    DO
       READ (unit, '(A)', IOSTAT=ios, ERR=999) line
       IF (line(1:1) == "#" .OR. ios /= 0) EXIT
    ENDDO

    READ (unit, *, IOSTAT=ios, ERR=999) DACS_const%L

    DO
       READ (unit, '(A)', IOSTAT=ios, ERR=999) line
       IF (line(1:1) == "#" .OR. ios /= 0) EXIT
    ENDDO

    READ (unit, *, IOSTAT=ios, ERR=999) DACS_const%A

999 CONTINUE

    IF (ios /= 0) THEN
       CALL MLSMessage (MLSMSG_Error, &
            & ModuleName, "Error reading DACS constants file!")
    ENDIF

   END SUBROUTINE LoadDACSconsts

!=============================================================================
  SUBROUTINE LoadSidebandFracs (unit)
!=============================================================================

    USE MLSL1Rad, ONLY: SideBandFrac

    INTEGER :: unit

    CHARACTER (len=80) :: line
    INTEGER :: i

! Read comments until start of data

    DO
       READ (unit, '(A)') line
       IF (line(1:1) /= ";") EXIT
    ENDDO

    DO i = 1, 34
       READ (unit, '(A)') line
       READ (unit, *) SideBandFrac(i)%lower
       READ (unit, '(A)') line
       READ (unit, *) SideBandFrac(i)%upper
    ENDDO

  END SUBROUTINE LoadSidebandFracs

!=============================================================================
  SUBROUTINE LoadSpilloverLoss (unit)
!=============================================================================

    USE MLSL1Rad, ONLY: SpilloverLoss

    INTEGER :: unit

    CHARACTER (len=80) :: line
    INTEGER :: bandno, chan, ios
    REAL :: h(3)

    READ (unit, '(A)') line

    DO
       READ (unit, '(A)', iostat=ios) line
       IF (ios /= 0) EXIT
       chan = 1
       READ (line(1:2), *) bandno
       READ (line(4:4), *, iostat=ios) chan
       READ (line(25:), *) h
       IF (INDEX (line, "L") /= 0) THEN
          SpilloverLoss(bandno)%lower(:,chan) = h
       ELSE
          SpilloverLoss(bandno)%upper(:,chan) = h
       ENDIF
    ENDDO

  END SUBROUTINE LoadSpilloverLoss

!=============================================================================
d809 3
@


2.12
log
@Version 1.2 commit
@
text
@d24 1
a24 1
       "$Id: OpenInit.f90,v 2.11 2003/06/03 20:43:54 pwagner Exp $"
d661 1
a661 1
    L1BFileInfo%RADFID = 0
d719 1
a719 1
    ! Open L1BRADF File
d732 3
a734 3
            & ModuleName, "Opened L1BRADF file: "//PhysicalFilename)
       L1BFileInfo%RADFID = sd_id
       L1BFileInfo%RADFFileName = PhysicalFilename
d739 1
a739 1
            & "Could not find L1BRADF file entry")
d1011 3
@


2.11
log
@Fills global attributes
@
text
@d9 2
a10 3
       PGSd_IO_Gen_RSeqFrm, PGS_IO_Gen_openF, PGS_IO_Gen_closeF, &
       PGSd_IO_Gen_WSeqUnf, PGSd_IO_Gen_USeqUnf
  USE MLSCommon, ONLY: r8, TAI93_Range_T
d24 1
a24 1
       "$Id: OpenInit.f90,v 2.10 2003/01/31 18:13:34 perun Exp $"
d39 2
a40 1
         mlspcf_dacsconst_start
d42 1
a42 1
    use MLSStrings, only: utc_to_yyyymmdd
d48 1
a48 1
    USE Calibration, ONLY: InitCalibWindow
d54 1
d58 1
a58 8
    INTEGER :: bw_tbl_unit
    INTEGER :: dacs_tbl_unit
    INTEGER :: eng_tbl_unit
    INTEGER :: gains_tbl_unit
    INTEGER :: nomen_unit
    INTEGER :: zeros_tbl_unit
    INTEGER :: errno, ios, lenarg, lenval
    INTEGER :: returnStatus, version
d62 3
a64 1
    INTEGER, EXTERNAL :: PGS_TD_UTCtoTAI
d70 12
d110 2
a111 1
    ! Store appropriate user input as global attributes
d115 1
d117 1
a117 1
    call utc_to_yyyymmdd(GlobalAttributes%StartUTC, returnStatus, &
d120 1
a120 1
    call FillTAI93Attribute
d133 2
d154 1
a154 1
         0, eng_tbl_unit, version)
d163 1
a163 1
    CALL Load_Eng_tbls (eng_tbl_unit, ios)
d165 1
a165 1
    returnStatus = PGS_IO_Gen_CloseF (eng_tbl_unit)
d186 1
a186 1
         0, bw_tbl_unit, version)
d195 1
a195 1
    CALL GetBandwidths (bw_tbl_unit, ios)
d197 1
a197 1
    returnStatus = PGS_IO_Gen_CloseF (bw_tbl_unit)
d218 1
a218 1
         PGSd_IO_Gen_RSeqFrm, 0, gains_tbl_unit, version)
d227 1
a227 1
    CALL GetChanDefaults (gains_tbl_unit, deflt_gain, ios)
d229 1
a229 1
    returnStatus = PGS_IO_Gen_CloseF (gains_tbl_unit)
d250 1
a250 1
         PGSd_IO_Gen_RSeqFrm, 0, zeros_tbl_unit, version)
d259 1
a259 1
    CALL GetChanDefaults (zeros_tbl_unit, deflt_zero, ios)
d261 1
a261 1
    returnStatus = PGS_IO_Gen_CloseF (zeros_tbl_unit)
d282 1
a282 1
         PGSd_IO_Gen_RSeqFrm, 0, dacs_tbl_unit, version)
d291 1
a291 1
    CALL GetDACSconsts (dacs_tbl_unit, ios)
d293 1
a293 1
    returnStatus = PGS_IO_Gen_CloseF (dacs_tbl_unit)
d310 1
a310 1
         0, nomen_unit, version)
d316 1
a316 1
    CALL ReadSignalsDatabase (nomen_unit)
d318 1
a318 1
    returnStatus = PGS_IO_Gen_closeF (nomen_unit)  ! close unit
d328 41
d388 4
d397 66
d637 1
a637 2
         mlspcf_l1b_oa_start, mlspcf_l1b_eng_start, mlspcf_l1b_diag_start, &
         mlspcf_l1b_radt_start
a638 1
    USE EngTbls, ONLY: Eng_tbl, maxtlm
d645 2
a646 1
    INTEGER :: error, returnStatus, sd_id, version, hdfVersion
d665 2
a666 2
    L1BFileInfo%ENGID = 0
    L1BFileInfo%DIAGID = 0
a765 37
    ! Open L1BENG File

    version = 1
    returnStatus = PGS_PC_getReference (mlspcf_l1b_eng_start, version, &
     PhysicalFilename)

    IF (returnStatus == PGS_S_SUCCESS) THEN
       version = 1

       returnStatus = PGS_IO_Gen_openF (mlspcf_l1b_eng_start, &
            PGSd_IO_Gen_WSeqUnf, 0, sd_id, version)
       IF (returnstatus /= PGS_S_SUCCESS) THEN
          returnStatus = PGS_IO_Gen_openF (mlspcf_l1b_eng_start, &
               PGSd_IO_Gen_USeqUnf, 0, sd_id, version)
          IF (returnstatus /= PGS_S_SUCCESS) THEN
             CALL MLSMessage (MLSMSG_Error, ModuleName, &
                  & "Could not open L1B engineering file: " // PhysicalFilename)
          ENDIF
       ENDIF
    
       CALL MLSMessage (MLSMSG_Info, ModuleName, &
            & "Opened L1B engineering file: " // PhysicalFilename)
       L1BFileInfo%EngId = sd_id
       L1BFileInfo%EngFileName = PhysicalFilename

! write header info

       WRITE (sd_id) maxtlm
       WRITE (sd_id) eng_tbl%mnemonic

    ELSE

       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not find L1BENG file entry")

    ENDIF

d768 1
d778 9
a786 9
       returnStatus = PGS_IO_Gen_openF (mlspcf_l1b_diag_start, &
            PGSd_IO_Gen_WSeqUnf, 0, sd_id, version)
       IF (returnstatus /= PGS_S_SUCCESS) THEN
          returnStatus = PGS_IO_Gen_openF (mlspcf_l1b_diag_start, &
               PGSd_IO_Gen_USeqUnf, 0, sd_id, version)
          IF (returnstatus /= PGS_S_SUCCESS) THEN
             CALL MLSMessage (MLSMSG_Error, ModuleName, &
                  & "Could not open L1B diagnostics file: " // PhysicalFilename)
          ENDIF
d788 1
a788 1
    
d791 1
a791 1
       L1BFileInfo%DiagId = sd_id
d804 1
a804 1
  SUBROUTINE GetBandwidths (bw_tbl_unit, ios)
d843 1
a843 1
  END SUBROUTINE GetBandwidths
d845 3
a847 1
  SUBROUTINE GetChanDefaults (unit, deflt_dat, stat)
d906 1
a906 1
  END SUBROUTINE GetChanDefaults
d909 1
a909 1
  SUBROUTINE GetDACSconsts (unit, ios)
a915 1
    INTEGER ::  i
d947 58
a1004 1
   END SUBROUTINE GetDACSconsts
d1011 3
@


2.10
log
@Version 1.1 commit
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d25 1
a25 1
       "$Id: OpenInit.f90,v 2.5 2002/03/29 20:18:34 perun Exp $"
d41 2
a42 1
    USE PCFHdr, ONLY: CreatePCFAnnotation
d102 10
d867 3
@


2.9
log
@Always get PCF annotations and moved h5open_f to OpenL1BFiles routine
@
text
@d17 4
a22 1
  PRIVATE :: Id, ModuleName
d25 1
a25 1
       "$Id: OpenInit.f90,v 2.8 2002/11/19 21:21:46 perun Exp $"
d39 2
a40 1
         mlspcf_defltgains_start, mlspcf_defltzeros_start
d43 2
a44 1
    USE MLSL1Common, ONLY: L1BFileInfo, deflt_gain, deflt_zero
a53 1
    TYPE (TAI93_Range_T) :: procRange
d55 12
a66 2
    INTEGER :: bw_tbl_unit, eng_tbl_unit, gains_tbl_unit, nomen_unit, &
         zeros_tbl_unit, errno, ios, lenarg, lenval, returnStatus, version
d69 4
d105 1
a105 1
!! TEST expansion time!!!
d107 4
a110 2
    L1Config%Expanded_TAI%startTime = L1Config%Expanded_TAI%startTime - 120.0
    L1Config%Expanded_TAI%endTime = L1Config%Expanded_TAI%endTime + 120.0
d112 1
a112 1
!! Init orbit data
d118 2
a119 2
       CALL Orbit_init (procRange, L1PCF%startUTC, altG, altT, ascTAI, dscTAI, &
            numOrb, orbIncline, orbitNumber, scanRate, scanRateT)
d251 32
d307 1
a307 1
    CALL OpenL1BFiles
d319 1
a319 1
    CALL InitRad
d323 1
a323 1
    CALL InitDACS_FFT
d327 1
a327 1
    CALL OutputL1B_create (L1BFileInfo)
d476 1
a476 1
                  "Requested tart time is before first data file start time")
d499 1
a499 1
  SUBROUTINE OpenL1BFiles
d503 2
a504 1
         mlspcf_l1b_oa_start, mlspcf_l1b_eng_start, mlspcf_l1b_diag_start
d507 1
a507 2
    USE Hdf, ONLY: DFACC_CREATE, sfstart
    USE MLSFiles, ONLY: mls_openFile, HDFVERSION_5, HDFVERSION_4
d510 2
a519 1

d524 36
d570 1
d572 7
a578 5
          CALL  mls_openFile(TRIM(PhysicalFilename),'create',sd_id, hdfVersion)
          L1BFileInfo%RADDID = sd_id
          L1BFileInfo%RADDFileName = TRIM(PhysicalFilename)
          CALL MLSMessage (MLSMSG_Info, ModuleName, &
               "Opened L1BRADD file: "//TRIM(PhysicalFilename))
d580 1
d582 2
a583 1
            "Could not find L1BRADD file entry")
a595 1
          CALL  mls_openFile(PhysicalFilename,'create',sd_id, hdfVersion)
d597 5
a601 4
          L1BFileInfo%RADFID = sd_id
          L1BFileInfo%RADFFileName = PhysicalFilename
          CALL MLSMessage (MLSMSG_Info, ModuleName, &
               "Opened L1BRADF file: "//PhysicalFilename)
d620 5
a624 7
       CALL  mls_openFile(PhysicalFilename,'create',sd_id, hdfVersion)

          L1BFileInfo%OAID = sd_id
          L1BFileInfo%OAFileName = PhysicalFilename

          CALL MLSMessage (MLSMSG_Info, ModuleName, &
               "Opened L1BOA file: "//PhysicalFilename)
a641 2
!! Will replace with HDF in a future version!

d810 42
d856 3
@


2.8
log
@Use HDFversion instead of HDFVersionString
@
text
@d22 1
a22 1
       "$Id: OpenInit.f90,v 2.7 2002/11/14 21:46:04 perun Exp $"
a32 1
    USE MLSFiles, ONLY: HDFVERSION_4, HDFVERSION_5
d52 1
a52 2
         zeros_tbl_unit, errno, ios, lenarg, lenval, returnStatus, version, &
         error, hdfVersion
d59 1
a59 1
!! Get the Level 1 configuration from the L1CF file
d61 1
a61 1
    CALL GetL1Config
d63 1
a63 1
!! Open the HDF Fortran Interface based on CF file
d65 1
a65 1
    hdfVersion = L1Config%Output%HDFVersion
d67 1
a67 16
!! Get annotation from PCF and CF files  (ONLY HDF 4!)

    IF (hdfVersion == HDFVERSION_4) THEN

       CALL CreatePCFAnnotation (mlspcf_pcf_start, anTextPCF)

       CALL CreatePCFAnnotation (mlspcf_l1cf_start, anTextCF)

    ELSE       ! Open HDF 5

       error = 0
       CALL h5open_f (error)
       IF (error /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Fortran HDF 5 API error on opening.")

    ENDIF
d459 1
a459 1
    INTEGER :: returnStatus, sd_id, version, hdfVersion
d463 11
d724 3
@


2.7
log
@Restored PCF annotations for HDF 4
@
text
@d22 1
a22 1
       "$Id: OpenInit.f90,v 2.6 2002/11/07 21:54:20 jdone Exp $"
a48 1
    USE MLSStrings, ONLY: lowercase
d65 1
a65 1
!! Open the HDF Fortran Interface
d67 1
a67 15
    error = 0
    SELECT CASE (lowercase(TRIM(L1Config%Output%HDFVersionString))) 
       CASE ('hdf4')
          hdfVersion = HDFVERSION_4
       CASE ('hdf5')
          CALL h5open_f(error)
          hdfVersion = HDFVERSION_5
       CASE default
          hdfVersion = HDFVERSION_4
    END SELECT 

    IF (error /= 0) THEN 
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Fortran API error on opening.")
    ENDIF
a70 1

d77 7
a473 1
    USE MLSStrings, ONLY: lowercase
d478 1
a478 8
    SELECT CASE (lowercase(TRIM(L1Config%Output%HDFVersionString))) 
       CASE ('hdf4')
          hdfVersion = HDFVERSION_4
       CASE ('hdf5')
          hdfVersion = HDFVERSION_5
       CASE default
          hdfVersion = HDFVERSION_4
    END SELECT 
d730 3
@


2.6
log
@Added HDF4/HDF5 switch.
@
text
@d22 1
a22 1
       "$Id: OpenInit.f90,v 2.5 2002/03/29 20:18:34 perun Exp $"
d33 1
a33 1
    USE MLSFiles, Only: HDFVERSION_4, HDFVERSION_5
d53 3
a55 2
    INTEGER :: bw_tbl_unit, eng_tbl_unit, gains_tbl_unit, nomen_unit, zeros_tbl_unit, &
         errno, ios, lenarg, lenval, returnStatus, version, error, hdfVersion
a61 9
!! Get annotation from PCF and CF files
!
!   CreatePCFAnnotation is commented for now due to the 
!   fact that lib/PCFHdr.f90 is HDF4 only.
!
!    CALL CreatePCFAnnotation (mlspcf_pcf_start, anTextPCF)
!
!    CALL CreatePCFAnnotation (mlspcf_l1cf_start, anTextCF)

d69 2
a70 2
    select case (lowercase(trim(L1Config%Output%HDFVersionString))) 
       case ('hdf4')
d72 2
a73 2
       case ('hdf5')
          call h5open_f(error)
d75 1
a75 1
       case default
d77 8
a84 1
    end select 
d86 8
a93 3
    if (error /= 0) then 
       call MLSMessage (MLSMSG_Error, ModuleName, "Fortran API error on opening.")
    endif
d301 1
a301 1
    CALL OutputL1B_create(L1BFileInfo)
d326 1
a326 1
       write (msg, "('Error opening ', a, ' file for PCF: ', i5)") filetype, pcf
d481 1
a481 1
    USE MLSFiles, only: mls_openFile, HDFVERSION_5, HDFVERSION_4
d488 2
a489 2
    select case (lowercase(trim(L1Config%Output%HDFVersionString))) 
       case ('hdf4')
d491 1
a491 1
       case ('hdf5')
d493 1
a493 1
       case default
d495 1
a495 1
    end select 
d505 1
a505 1
          call  mls_openFile(trim(PhysicalFilename),'create',sd_id, hdfVersion)
d507 3
a509 2
          L1BFileInfo%RADDFileName = trim(PhysicalFilename)
          CALL MLSMessage (MLSMSG_Info, ModuleName, "Opened L1BRADD file: "//trim(PhysicalFilename))
d511 2
a512 1
       CALL MLSMessage (MLSMSG_Error, ModuleName,"Could not find L1BRADD file entry")
d525 1
a525 1
          call  mls_openFile(PhysicalFilename,'create',sd_id, hdfVersion)
d529 2
a530 1
          CALL MLSMessage (MLSMSG_Info, ModuleName, "Opened L1BRADF file: "//PhysicalFilename)
d549 1
a549 1
       call  mls_openFile(PhysicalFilename,'create',sd_id, hdfVersion)
d554 2
a555 1
          CALL MLSMessage (MLSMSG_Info, ModuleName, "Opened L1BOA file: "//PhysicalFilename)
d711 1
a711 1
          IF (line(1:1) == "#" .or. ios /= 0) EXIT
d747 3
@


2.5
log
@Version 1.0 commit
@
text
@d22 1
a22 1
       "$Id: OpenInit.f90,v 2.4 2001/03/22 16:46:02 perun Exp $"
d33 1
d49 1
d51 1
d53 2
a54 9

    INTEGER :: bw_tbl_unit
    INTEGER :: eng_tbl_unit
    INTEGER :: gains_tbl_unit
    INTEGER :: nomen_unit
    INTEGER :: zeros_tbl_unit
    INTEGER :: errno, ios, lenarg, lenval
    INTEGER :: returnStatus, version

a56 2
    TYPE (TAI93_Range_T) :: procRange

d62 7
d70 1
a70 1
    CALL CreatePCFAnnotation (mlspcf_pcf_start, anTextPCF)
d72 1
a72 1
    CALL CreatePCFAnnotation (mlspcf_l1cf_start, anTextCF)
d74 1
a74 1
!! Get the Level 1 configuration from the L1CF file
d76 14
a89 1
    CALL GetL1Config
d297 1
a297 1
    CALL OutputL1B_create (L1BFileInfo)
d477 3
d482 10
a491 1
    INTEGER :: returnStatus, sd_id, version
a499 1

d501 1
a501 8

       sd_id = sfstart (PhysicalFilename, DFACC_CREATE)
       IF (sd_id == -1) THEN
          CALL MLSMessage (MLSMSG_Error, &
               & ModuleName, "Error creating L1BRADD file: "//PhysicalFilename)
       ELSE
          CALL MLSMessage (MLSMSG_Info, &
               & ModuleName, "Opened L1BRADD file: "//PhysicalFilename)
d503 2
a504 3
          L1BFileInfo%RADDFileName = PhysicalFilename
       ENDIF

d506 1
a506 4

       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not find L1BRADD file entry")

d519 2
a520 7
       sd_id = sfstart (PhysicalFilename, DFACC_CREATE)
       IF (sd_id == -1) THEN
          CALL MLSMessage (MLSMSG_Error, &
               & ModuleName, "Error creating L1BRADF file: "//PhysicalFilename)
       ELSE
          CALL MLSMessage (MLSMSG_Info, &
               & ModuleName, "Opened L1BRADF file: "//PhysicalFilename)
d523 1
a523 1
       ENDIF
d542 2
a543 7
       sd_id = sfstart (PhysicalFilename, DFACC_CREATE)
       IF (sd_id == -1) THEN
          CALL MLSMessage (MLSMSG_Error, &
               & ModuleName, "Error creating L1BOA file: "//PhysicalFilename)
       ELSE
          CALL MLSMessage (MLSMSG_Info, &
               & ModuleName, "Opened L1BOA file: "//PhysicalFilename)
d546 2
a547 1
       ENDIF
d739 3
@


2.4
log
@Check CF and PCF outputVersions
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d8 3
a10 2
  USE SDPToolkit, ONLY: PGS_PC_GetReference, PGS_S_SUCCESS, PGSd_EOS_PM_GIRD, &
       PGSd_IO_Gen_RSeqFrm, PGS_IO_Gen_openF, PGS_IO_Gen_closeF
a16 3
  INTEGER :: eng_unit = 102
  INTEGER :: eng_recno = 1   ! start with first record

d22 1
a22 1
       "$Id: OpenInit.f90,v 2.3 2001/03/12 19:36:00 perun Exp $"
d35 2
a36 1
         mlspcf_nomen_start, mlspcf_pcf_start, mlspcf_l1cf_start
d39 1
a39 1
    USE MLSL1Common, ONLY: L1BFileInfo
d47 1
a47 2

    CHARACTER (LEN=80) :: eng_file, sci_file, eng_tbl_file, bw_tbl_file
d53 1
d55 1
d102 8
a109 2
    CALL Orbit_init (procRange, L1PCF%startUTC, altG, altT, ascTAI, dscTAI, &
         numOrb, orbIncline, orbitNumber, scanRate, scanRateT)
d122 2
a123 2
            & "Could not open engineering table file" // PhysicalFilename)
    END IF
d126 1
a126 1
         & "Opened engineering table file" // PhysicalFilename)
d138 1
a138 1
    END IF
d154 2
a155 2
            & "Could not open bandwidths table file" // PhysicalFilename)
    END IF
d158 1
a158 1
         & "Opened bandwidths table file" // PhysicalFilename)
d170 1
a170 1
    END IF
d175 64
d247 1
a247 1
    END IF
d255 1
a255 1
    END IF
d276 5
a280 1
             
d282 1
a282 1
          
d311 1
a311 1
    END IF
d313 1
a313 1
    returnStatus = PGS_IO_L0_Open (pcf, PGSd_EOS_PM_GIRD, unit, &
d325 1
a325 1
    END IF
d402 1
a402 1
       END IF
d406 1
a406 1
    ! Open L0 Engineering  Files:
d448 1
a448 1
       END IF
d459 1
a459 1
         mlspcf_l1b_oa_start, mlspcf_l1b_eng_start
d461 1
d467 1
a467 1
    ! Open L1BRADF File
d486 1
a486 1
       END IF
d493 1
a493 1
    END IF
d514 1
a514 1
       END IF
d521 1
a521 1
    END IF
d542 1
a542 1
       END IF
d549 74
a622 1
    END IF
d668 61
d734 3
@


2.3
log
@Read and save CF file as annotation
@
text
@d24 1
a24 1
       "$Id: OpenInit.f90,v 2.1 2001/02/23 20:54:11 perun Exp $"
d77 7
d525 3
@


2.2
log
@Add reading PCF file
@
text
@d19 1
a19 1
  CHARACTER (LEN=1), POINTER :: anText(:)
d37 1
a37 1
         mlspcf_nomen_start, mlspcf_pcf_start
d67 1
a67 1
!! Get annotation from PCF file
d69 3
a71 1
    CALL CreatePCFAnnotation (mlspcf_pcf_start, anText)
@


2.1
log
@Version 0.5 commit
@
text
@d19 2
d24 2
a25 2
       "$Id:$"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile:$"
d37 2
a38 1
         mlspcf_nomen_start
d67 4
d515 4
a518 1
! $Log:$
@

