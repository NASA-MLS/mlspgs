head	2.10;
access;
symbols
	v5-02-NRT-19:2.10
	v6-00:2.10
	v5-02-NRT-18:2.10
	v5-02:2.10
	v5-01-NRT-17:2.10
	v5-01-NRT-16:2.10
	v5-01-NRT-15:2.10
	v5-01-NRT-14:2.10
	neuralnetworks-1-0:2.10.0.10
	cfm-single-freq-0-1:2.10.0.8
	v5-01:2.10
	v5-00:2.10
	v4-23-TA133:2.10.0.6
	mus-emls-1-70:2.10.0.4
	rel-1-0-englocks-work:2.10.0.2
	VUMLS1-00:2.10
	VPL1-00:2.10
	V4-22-NRT-08:2.10
	whdrel10_merged_to_here:2.10
	merge_whdrel10_from_here:2.9.6.1
	TAG_TRUNK_AFTER_PW_CHANGES:2.9
	TAG_TRUNK_BEFORE_PW_CHANGES:2.9
	VAM1-00:2.9
	whd-rel-1-0:2.9.0.6
	V4-21:2.9.0.4
	V4-13:2.9
	V4-12:2.9
	V4-11:2.9
	V4-10:2.9
	V3-43:2.9
	M4-00:2.9
	V3-41:2.9
	V3-40-PlusGM57:2.9.0.2
	V2-24-NRT-04:2.9
	V3-33:2.9
	V2-24:2.9
	V3-31:2.9
	V3-30-NRT-05:2.9
	cfm-01-00:2.9
	V3-30:2.9
	V3-20:2.9
	V3-10:2.9
	V2-23-NRT-02:2.9
	V2-23:2.9
	V2-22-NRT-01:2.9
	V2-22:2.9
	V2-21:2.9
	V2-20:2.9
	V2-11:2.8
	V2-10:2.8
	V2-00:2.8
	V1-51:2.6
	V1-50:2.6
	V1-45:2.6
	V1-44:2.6
	V1-43:2.6
	V1-42:2.6
	V1-41:2.6
	V1-32:2.5
	V1-40:2.6
	V1-31:2.5
	V1-30:2.5
	V1-13:2.3
	V1-12:2.3
	V1-11:2.3
	V1-10:2.3
	newfwm-feb03:2.3.0.2
	V1-04:2.2
	V1-03:2.2
	V1-02:2.2
	V1-00:2.2
	newfwm-sep01:2.1.0.2
	V0-7:2.1
	V0-5-Level2:2.1
	V0-5-SIPS:2.1
	V0_1:1.2;
locks; strict;
comment	@# @;


2.10
date	2016.03.15.22.17.59;	author whdaffer;	state Exp;
branches;
next	2.9;

2.9
date	2006.09.28.16.16.13;	author perun;	state Exp;
branches
	2.9.6.1;
next	2.8;

2.8
date	2006.03.24.15.12.41;	author perun;	state Exp;
branches;
next	2.7;

2.7
date	2005.06.23.18.41.36;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2004.01.09.17.46.22;	author perun;	state Exp;
branches;
next	2.5;

2.5
date	2003.09.15.17.15.53;	author perun;	state Exp;
branches;
next	2.4;

2.4
date	2003.08.15.14.25.04;	author perun;	state Exp;
branches;
next	2.3;

2.3
date	2003.01.31.18.13.34;	author perun;	state Exp;
branches;
next	2.2;

2.2
date	2002.03.29.20.18.34;	author perun;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.23.18.26.11;	author perun;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.55.14;	author ahanzel;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.16.21.41.13;	author perun;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.08.21.26.58;	author perun;	state Exp;
branches;
next	;

2.9.6.1
date	2015.10.09.10.21.38;	author whdaffer;	state Exp;
branches;
next	;


desc
@@


2.10
log
@Merged whd-rel-1-0 back onto main branch. Most changes
are to comments, but there's some modification to Calibration.f90
and MLSL1Common to support some new modules: MLSL1Debug and SnoopMLSL1.
@
text
@! Copyright 2006, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
MODULE MLSL1Rad     ! Radiance data types and routines for the MLSL1 program
!=============================================================================

  USE MLSL1Common, ONLY: FBchans, MBnum, MBchans, WFnum, WFchans, R4, &
       DACSnum, DACSchans, GHzNum, THzNum, THzChans
  USE MLSSignalNomenclature, ONLY: ParseMLSSignalRequest, MLSSignal_T
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_Allocate

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: InitRad, BandToBanks, UpdateRadSignals, RadPwr
  PUBLIC :: Radiance_T, L1Brad, FBrad, MBrad, WFrad, DACSrad, THzRad, Rad_Name

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSL1Rad.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! This module defines the radiance data types and the nominal
  ! nomenclature sets for the MLSL1 program.

  !---------------------------------------------------------------------------

  TYPE Radiance_T
     TYPE (MLSSignal_T) :: signal
     INTEGER :: BandNo
     REAL(r4), DIMENSION (:,:), POINTER :: value, precision, Poffset
     REAL(r4), DIMENSION (:), POINTER :: ModelOffset
  END TYPE Radiance_T

  !<whd>. The 'pointer'ness of the parts of L1Brad declared as pointers isn't
  !used; it could be declared 'allocatable', but I suspect this code was written
  !before the standard allowed that. However, it's automatically allocatable if
  !declared a pointer. </whd>

  TYPE (Radiance_T), DIMENSION(:), POINTER :: L1Brad, FBrad, MBrad, WFrad, &
       DACSrad, THzRad

  CHARACTER(len=26), PARAMETER :: Rad_Name(52) = (/ &
       "R1A:118.B1F:PT.S0.FB25-1  ", "R1A:118.B1F:PT.S3.FB25-8  ", &
       "R2:190.B2F:H2O.S0.FB25-2  ", "R2:190.B2F:H2O.S2.FB25-3  ", &
       "R2:190.B3F:N2O.S2.FB25-3  ", "R2:190.B4F:HNO3.S0.FB25-4 ", &
       "R2:190.B4F:HNO3.S3.FB25-8 ", "R2:190.B5F:CLO.S0.FB25-5  ", &
       "R2:190.B5F:CLO.S2.FB25-3  ", "R2:190.B6F:O3.S0.FB25-6   ", &
       "R2:190.B6F:O3.S2.FB25-3   ", "R3:240.B7F:O3.S0.FB25-7   ", &
       "R3:240.B7F:O3.S3.FB25-8   ", "R3:240.B8F:PT.S3.FB25-8   ", &
       "R3:240.B8F:PT.S2.FB25-3   ", "R3:240.B9F:CO.S0.FB25-9   ", &
       "R3:240.B9F:CO.S2.FB25-3   ", "R4:640.B10F:CLO.S0.FB25-10", &
       "R4:640.B10F:CLO.S4.FB25-12", "R4:640.B11F:BRO.S0.FB25-11", &
       "R4:640.B11F:BRO.S4.FB25-12", "R4:640.B12F:N2O.S4.FB25-12", &
       "R4:640.B13F:HCL.S3.FB25-8 ", "R4:640.B13F:HCL.S0.FB25-13", &
       "R4:640.B14F:O3.S0.FB25-14 ", "R4:640.B14F:O3.S4.FB25-12 ", &
       "R5H:2T5.B15F:OH.S5.FB25-15", "R5H:2T5.B16F:OH.S0.FB25-16", &
       "R5H:2T5.B16F:OH.S5.FB25-15", "R5H:2T5.B17F:PT.S0.FB25-17", &
       "R5H:2T5.B17F:PT.S5.FB25-15", "R5V:2T5.B18F:OH.S0.FB25-18", &
       "R5V:2T5.B18F:OH.S5.FB25-15", "R5V:2T5.B19F:OH.S0.FB25-19", &
       "R5V:2T5.B19F:OH.S5.FB25-15", "R5V:2T5.B20F:PT.S4.FB25-12", &
       "R5V:2T5.B20F:PT.S5.FB25-15", "R1B:118.B21F:PT.S4.FB25-12", &
       "R1B:118.B21F:PT.S3.FB25-8 ", "R1A:118.B22D:PT.S0.DACS-4 ", &
       "R2:190.B23D:H2O.S0.DACS-2 ", "R3:240.B24D:O3.S0.DACS-3  ", &
       "R3:240.B25D:CO.S1.DACS-1  ", "R1B:118.B26D:PT.S1.DACS-1 ", &
       "R2:190.B27M:HCN.S0.MB11-1 ", "R4:640.B28M:HO2.S0.MB11-2 ", &
       "R4:640.B29M:HOCL.S0.MB11-3", "R4:640.B30M:HO2.S0.MB11-4 ", &
       "R4:640.B31M:BRO.S0.MB11-5 ", "R1A:118.B32W:PT.S0.WF4-1  ", &
       "R3:240.B33W:O3.S0.WF4-2   ", "R1B:118.B34W:PT.S0.WF4-3  " /)

CONTAINS

!=============================================================================
  SUBROUTINE InitRad (THz)
!=============================================================================

    USE MLSL1Config, ONLY: MIFsGHz, MIFsTHz
    USE MLSL1Common, ONLY: BandSwitch

    ! Arguments

    LOGICAL :: THz

    ! Local

    INTEGER :: i, status, BandNo, BankNo
    TYPE (MLSSignal_T), DIMENSION(:), POINTER :: signal => NULL()
    CHARACTER (LEN=11) :: request
    INTEGER, PARAMETER :: DACSbandNo(4) = (/ 25, 23, 24, 22 /)

    IF (THz) THEN  ! Allocate for THz
       ALLOCATE (L1Brad(THzNum), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"L1BRad")
       THzRad => L1Brad
       DO i = 1, THzNum

          ALLOCATE (L1Brad(i)%value(THzchans,MIFsTHz), STAT=status)
          IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
               & MLSMSG_Allocate//"FBvalue")
          ALLOCATE (L1Brad(i)%precision(THzchans,MIFsTHz), STAT=status)
          IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
               & MLSMSG_Allocate//"FBprecision")
          ALLOCATE (L1Brad(i)%Poffset(THzchans,MIFsTHz), STAT=status)
          IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
               & MLSMSG_Allocate//"FBpOffset")
          ALLOCATE (L1Brad(i)%ModelOffset(THzchans), STAT=status)
          IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
               & MLSMSG_Allocate//"FBmodelOffset")

          BankNo = i + 14   !start at 15
          SELECT CASE (i)
          CASE (1)
             BandNo = BandSwitch(5)
          CASE (THzNum)
             BandNo = BandSwitch(4)
             BankNo = 12
          CASE DEFAULT
             BandNo = BankNo
          END SELECT

          WRITE (request, '("B",i2.2,".FB25-",i2)') BandNo, BankNo
          request = request(1:9)//ADJUSTL(request(10:11))
          CALL ParseMLSSignalRequest (request, signal, .FALSE.)
          L1Brad(i)%signal = signal(1)
          L1Brad(i)%BandNo = BandNo
          DEALLOCATE (signal)

       END DO

       RETURN  ! Nothing more to do

    ENDIF

    ALLOCATE (L1Brad(GHzNum+MBnum+WFnum+DACSnum), STAT=status)
    IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
         & MLSMSG_Allocate//"L1BRad")

    ! Allocate and initialize for the standard filter banks

    DO i = 1, GHzNum

       ALLOCATE (L1Brad(i)%value(FBchans,MIFsGHz), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"FBvalue")
       ALLOCATE (L1Brad(i)%precision(FBchans,MIFsGHz), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"FBprecision")
       ALLOCATE (L1Brad(i)%Poffset(FBchans,MIFsGHz), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"FBpOffset")
       ALLOCATE (L1Brad(i)%ModelOffset(FBchans), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"FBmodelOffset")


       ! <whd> See extended comment for this case statement in SortQualify,
       ! ~line 898 for the meaning of this obscure code.  </whd>

       SELECT CASE (i)
       CASE (3)
          BandNo = BandSwitch(2)
       CASE (8)
          BandNo = BandSwitch(3)
       CASE (12)
          BandNo = BandSwitch(4)
       CASE DEFAULT
          BandNo = i
       END SELECT

       WRITE (request, '("B",i2.2,".FB25-",i2)') BandNo, i
       request = request(1:9)//ADJUSTL(request(10:11))
       CALL ParseMLSSignalRequest (request, signal, .FALSE.)
       L1Brad(i)%signal = signal(1)
       L1Brad(i)%BandNo = BandNo
       DEALLOCATE (signal)

    END DO ! loop over GHz

    FBrad => L1Brad(1:GHzNum)   ! Point to FB data

    ! Allocate and initialize for the mid-band filter banks

    DO i = 1, MBnum

       ALLOCATE (L1BRad(i+GHzNum)%value(MBchans,MIFsGHz), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"MBvalue")
       ALLOCATE (L1BRad(i+GHzNum)%precision(MBchans,MIFsGHz), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"MBprecision")
       ALLOCATE (L1Brad(i+GHzNum)%Poffset(MBchans,MIFsGHz), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"MBpOffset")
       ALLOCATE (L1Brad(i+GHzNum)%ModelOffset(MBchans), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"MBmodelOffset")
       WRITE (request, '("B",i2.2,".MB11-",i1)') (i+26), i
       CALL ParseMLSSignalRequest (request, signal, .FALSE.)
       L1Brad(i+GHzNum)%signal = signal(1)
       L1Brad(i+GHzNum)%BandNo = i + 26
       DEALLOCATE (signal)

    END DO

    MBrad => L1Brad(GHzNum+1:GHzNum+MBnum)  ! Point to MB data

    ! Allocate and initialize for the wide filter banks

    DO i = 1, WFnum

       ALLOCATE (L1BRad(i+GHzNum+MBnum)%value(WFchans,MIFsGHz), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"WFvalue")
       ALLOCATE (L1BRad(i+GHzNum+MBnum)%precision(WFchans,MIFsGHz), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"WFprecision")
       ALLOCATE (L1Brad(i+GHzNum+MBnum)%Poffset(WFchans,MIFsGHz), STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"WFpOffset")
       ALLOCATE (L1Brad(i+GHzNum+MBnum)%ModelOffset(WFchans), &
            STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"WFmodelOffset")
       WRITE (request, '("B",i2.2,".WF4-",i1)') (i+31), i
       CALL ParseMLSSignalRequest (request, signal, .FALSE.)
       L1Brad(i+GHzNum+MBnum)%signal = signal(1)
       L1Brad(i+GHzNum+MBnum)%BandNo = i + 31
       DEALLOCATE (signal)

    END DO

    WFrad => L1Brad(GHzNum+MBnum+1:GHzNum+MBnum+WFnum)  ! Point to WF data

    ! Allocate and initialize for the DACS filter banks

    DO i = 1, DACSnum

       ALLOCATE (L1BRad(i+GHzNum+MBnum+WFnum)%value(DACSchans,MIFsGHz), &
            STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"DACSvalue")
       ALLOCATE (L1BRad(i+GHzNum+MBnum+WFnum)%precision(DACSchans,MIFsGHz), &
            STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"DACSprecision")
       ALLOCATE (L1Brad(i+GHzNum+MBnum+WFnum)%Poffset(DACSchans,MIFsGHz), &
            STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"DACSpOffset")
       ALLOCATE (L1Brad(i+GHzNum+MBnum+WFnum)%ModelOffset(DACSchans), &
            STAT=status)
       IF (status /= 0) CALL MLSMessage (MLSMSG_Error, ModuleName,&
            & MLSMSG_Allocate//"DACSmodelOffset")
       IF (i == 1) THEN
          BandNo = BandSwitch(1)
       ELSE
          BandNo = DACSbandNo(i)
       ENDIF
       WRITE (request, '("B",i2.2,".DACS-",i1)') BandNo, i
       CALL ParseMLSSignalRequest (request, signal, .FALSE.)
       L1Brad(i+GHzNum+MBnum+WFnum)%signal = signal(1)
       L1Brad(i+GHzNum+MBnum+WFnum)%BandNo = BandNo
       DEALLOCATE (signal)

    END DO

    DACSrad => L1Brad(GHzNum+MBnum+WFnum+1:GHzNum+MBnum+WFnum+DACSnum)

  END SUBROUTINE InitRad

!=============================================================================
  SUBROUTINE UpdateRadSignals (BandSwitch)
!=============================================================================

    USE MLSL1Common, ONLY: SwitchBank

    INTEGER, DIMENSION(:) :: BandSwitch

    TYPE (MLSSignal_T), DIMENSION(:), POINTER :: signal => NULL()
    CHARACTER (LEN=11) :: request
    INTEGER :: i

!! THz first

    IF (SIZE(L1Brad) == THzNum) THEN
       DO i = 4, 5   ! Switches 4 & 5
          IF (BandSwitch(i) > 0) THEN
             WRITE (request, '("B",i2.2,".FB25-",i2)') BandSwitch(i), &
                  SwitchBank(i)
             request = request(1:9)//ADJUSTL(request(10:11))
             CALL ParseMLSSignalRequest (request, signal, .FALSE.)
             IF (i == 5) THEN
                !! Switch 5 is hardware coded to THz module bands.
                L1Brad(1)%signal = signal(1)
                L1Brad(1)%BandNo = BandSwitch(i)
             ELSE
                L1Brad(THzNum)%signal = signal(1)
                L1Brad(THzNum)%BandNo = BandSwitch(i)
             ENDIF
             DEALLOCATE (signal)
          ENDIF
       ENDDO

       RETURN    ! Nothing more

    ENDIF

!! DACS
!! <whd:question>
!!
!! (I guess it's put a location 1+14+5+3 = 23, because switch locations 2-4 can
!! have any value between 1 and 23?)
!!
!! </whd:question>
    IF (BandSwitch(1) > 0) THEN
       WRITE (request, '("B",i2.2,".DACS-1")') BandSwitch(1)
       CALL ParseMLSSignalRequest (request, signal, .FALSE.)
       L1Brad(1+GHzNum+MBnum+WFnum)%signal = signal(1)
       L1Brad(1+GHzNum+MBnum+WFnum)%BandNo = BandSwitch(1)
       DEALLOCATE (signal)
    ENDIF
    
!! FB's next (GHz switches 2,3,4)

    DO i = 2, 4
       IF (BandSwitch(i) > 0) THEN
          WRITE (request, '("B",i2.2,".FB25-",i2)') BandSwitch(i), SwitchBank(i)
          request = request(1:9)//ADJUSTL(request(10:11))
          CALL ParseMLSSignalRequest (request, signal, .FALSE.)
          L1Brad(SwitchBank(i))%signal = signal(1)
          L1Brad(SwitchBank(i))%BandNo = BandSwitch(i)
          DEALLOCATE (signal)
       ENDIF
    ENDDO

  END SUBROUTINE UpdateRadSignals

  SUBROUTINE BandToBanks (band, bank)

    TYPE (MLSSignal_T), DIMENSION(:), POINTER :: signal => NULL()
    INTEGER :: band, bank(2)
    CHARACTER(LEN=3) :: request

    bank = 0   ! nothing yet
    WRITE (request, '("B", i2.2)') band
    CALL ParseMLSSignalRequest (request, signal, .FALSE.)
    bank(1) = minval (signal%spectrometernumber)
    bank(2) = maxval (signal%spectrometernumber)

    DEALLOCATE (signal)

  END SUBROUTINE BandToBanks

  FUNCTION RadPwr (Hz, T) RESULT (P)

    USE MLSL1Common, ONLY: boltz, planck

!! Calculate radiant power per unit bandwidth

    REAL :: Hz    !! frequency in Hz
    REAL :: T     !! temperature in Kelvin
    REAL :: P     !! radiant power

    P = 0.0
    IF (Hz <= 0.0) RETURN

    P = (planck * Hz) / (boltz * (exp ((planck * Hz) / (boltz * T)) - 1.0))

  END FUNCTION RadPwr

!=============================================================================
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: MLSL1Rad.f90,v 2.9.6.1 2015/10/09 10:21:38 whdaffer Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
END MODULE MLSL1Rad
!=============================================================================

!
! $Log: MLSL1Rad.f90,v $
! Revision 2.9.6.1  2015/10/09 10:21:38  whdaffer
! checkin of continuing work on branch whd-rel-1-0
!
! Revision 2.9  2006/09/28 16:16:13  perun
! Resize ModelOffset from Chans by MIFs to just Chans
!
! Revision 2.8  2006/03/24 15:12:41  perun
! Add Poffset and ModelOffset
!
! Revision 2.7  2005/06/23 18:41:36  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.6  2004/01/09 17:46:22  perun
! Version 1.4 commit
!
! Revision 2.5  2003/09/15 17:15:53  perun
! Version 1.3 commit
!
! Revision 2.4  2003/08/15 14:25:04  perun
! Version 1.2 commit
!
! Revision 2.3  2003/01/31 18:13:34  perun
! Version 1.1 commit
!
! Revision 2.2  2002/03/29 20:18:34  perun
! Version 1.0 commit
!
! Revision 2.1  2001/02/23 18:26:11  perun
! Version 0.5 commit
!
! Revision 2.0  2000/09/05 18:55:14  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.2  2000/02/16 21:41:13  perun
! Added calls to MLSSignals routine
!

@


2.9
log
@Resize ModelOffset from Chans by MIFs to just Chans
@
text
@d46 5
d167 4
d189 1
a189 1
    END DO
d305 1
d321 6
a326 1

d335 1
a335 1
!! FB's next
d387 1
a387 1
       "$Id: MLSL1Rad.f90,v 2.8 2006/03/24 15:12:41 perun Exp $"
d397 6
@


2.9.6.1
log
@checkin of continuing work on branch whd-rel-1-0
@
text
@a45 5
  !<whd>. The 'pointer'ness of the parts of L1Brad declared as pointers isn't
  !used; it could be declared 'allocatable', but I suspect this code was written
  !before the standard allowed that. However, it's automatically allocatable if
  !declared a pointer. </whd>

a161 4

       ! <whd> See extended comment for this case statement in SortQualify,
       ! ~line 898 for the meaning of this obscure code.  </whd>

d180 1
a180 1
    END DO ! loop over GHz
a295 1
                !! Switch 5 is hardware coded to THz module bands.
d311 1
a311 6
!! <whd:question>
!!
!! (I guess it's put a location 1+14+5+3 = 23, because switch locations 2-4 can
!! have any value between 1 and 23?)
!!
!! </whd:question>
d320 1
a320 1
!! FB's next (GHz switches 2,3,4)
d372 1
a372 1
       "$Id: MLSL1Rad.f90,v 2.9 2006/09/28 16:16:13 perun Exp $"
a381 3
! Revision 2.9  2006/09/28 16:16:13  perun
! Resize ModelOffset from Chans by MIFs to just Chans
!
@


2.8
log
@Add Poffset and ModelOffset
@
text
@d1 1
a1 1
! Copyright 2005, by the California Institute of Technology. ALL
d42 2
a43 2
     REAL(r4), DIMENSION (:,:), POINTER :: value, precision, &
          Poffset, ModelOffset
d113 1
a113 1
          ALLOCATE (L1Brad(i)%ModelOffset(THzchans,MIFsTHz), STAT=status)
d158 1
a158 1
       ALLOCATE (L1Brad(i)%ModelOffset(FBchans,MIFsGHz), STAT=status)
d197 1
a197 1
       ALLOCATE (L1Brad(i+GHzNum)%ModelOffset(MBchans,MIFsGHz), STAT=status)
d223 1
a223 1
       ALLOCATE (L1Brad(i+GHzNum+MBnum)%ModelOffset(WFchans,MIFsGHz), &
d253 1
a253 1
       ALLOCATE (L1Brad(i+GHzNum+MBnum+WFnum)%ModelOffset(DACSchans,MIFsGHz), &
d372 1
a372 1
       "$Id: MLSL1Rad.f90,v 2.7 2005/06/23 18:41:36 pwagner Exp $"
d382 3
@


2.7
log
@Reworded Copyright statement, moved rcs id
@
text
@d30 1
a30 1
       "$RCSfile: $"
d42 2
a43 1
     REAL(r4), DIMENSION (:,:), POINTER :: value, precision
d110 6
d155 6
d194 6
d220 7
d249 8
d372 1
a372 1
       "$Id: $"
d382 3
@


2.6
log
@Version 1.4 commit
@
text
@d1 10
a10 2
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d28 5
a32 5
  !---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
       "$Id: MLSL1Rad.f90,v 2.5 2003/09/15 17:15:53 perun Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: MLSL1Rad.f90,v $"
  !---------------------------------------------------------------------------
d335 8
d348 3
@


2.5
log
@Version 1.3 commit
@
text
@a18 1
  PUBLIC :: SideBandFrac_T, SideBandFrac, SpilloverLoss_T, SpilloverLoss
d22 1
a22 1
       "$Id: MLSL1Rad.f90,v 2.4 2003/08/15 14:25:04 perun Exp $"
d33 1
a67 24
  TYPE SideBandFrac_T
     REAL(r4), DIMENSION(:), POINTER :: lower, upper
  END TYPE SideBandFrac_T

  TYPE (SideBandFrac_T) :: SideBandFrac(34)

  TYPE SpilloverLoss_T
     REAL(r4), DIMENSION(:,:), POINTER :: lower, upper
  END TYPE SpilloverLoss_T

  TYPE (SpilloverLoss_T) :: SpilloverLoss(34)

  TYPE RadiometerLoss_T
     CHARACTER(len=3) :: Name
     REAL(r4) :: Ohmic, Spillover, Radiance
  END TYPE RadiometerLoss_T

  TYPE (RadiometerLoss_T), PARAMETER :: RadiometerLoss(5) = (/ &
       RadiometerLoss_T ("R1A", 0.9982**3, 0.9987, 150.0), &
       RadiometerLoss_T ("R1B", 0.9982**3, 0.9964, 150.0), &
       RadiometerLoss_T ("R2 ", 0.99736**3, 0.9992, 150.0), &
       RadiometerLoss_T ("R3 ", 0.99449**3, 0.9987, 150.0), &
       RadiometerLoss_T ("R4 ", 0.98819**3, 0.9916, 150.0)  /)

a87 35
!! Allocate Sideband fraction arrays:

    DO i = 1, 21
       ALLOCATE (SideBandFrac(i)%lower(FBchans))
       ALLOCATE (SideBandFrac(i)%upper(FBchans))
    ENDDO
    DO i = 22, 26
       ALLOCATE (SideBandFrac(i)%lower(DACSchans))
       ALLOCATE (SideBandFrac(i)%upper(DACSchans))
    ENDDO
    DO i = 27, 31
       ALLOCATE (SideBandFrac(i)%lower(MBchans))
       ALLOCATE (SideBandFrac(i)%upper(MBchans))
    ENDDO
    DO i = 32, 34
       ALLOCATE (SideBandFrac(i)%lower(WFchans))
       ALLOCATE (SideBandFrac(i)%upper(WFchans))
    ENDDO

!! Allocate and Initialize Spillover Loss

    DO i = 1, 31
       ALLOCATE (SpilloverLoss(i)%lower(3,1))
       ALLOCATE (SpilloverLoss(i)%upper(3,1))
       SpilloverLoss(i)%lower = 0.0
       SpilloverLoss(i)%upper = 0.0
    ENDDO

    DO i = 32, 34
       ALLOCATE (SpilloverLoss(i)%lower(3,4))
       ALLOCATE (SpilloverLoss(i)%upper(3,4))
       SpilloverLoss(i)%lower = 0.0
       SpilloverLoss(i)%upper = 0.0
    ENDDO

a115 1

d117 1
d156 1
d176 1
d196 1
d223 1
d238 1
a238 1
    INTEGER :: BandSwitch(*)
d255 1
d258 1
d274 1
d286 1
d319 3
d332 3
@


2.4
log
@Version 1.2 commit
@
text
@d18 1
a18 1
  PUBLIC :: Radiance_T, L1Brad, FBrad, MBrad, WFrad, DACSrad, THzRad
d23 1
a23 1
       "$Id: MLSL1Rad.f90,v 2.3 2003/01/31 18:13:34 perun Exp $"
d40 28
d80 12
d380 3
@


2.3
log
@Version 1.1 commit
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d8 3
a10 3
  USE MLSL1Common, ONLY: FBnum, FBchans, MBnum, MBchans, WFnum, WFchans, R4, &
       DACSnum, DACSchans, GHzNum, THzNum, THzChans, Chan_R_T
  USE MLSSignalNomenclature !, ONLY: ParseMLSSignalRequest, MLSSignal_T
d19 1
d23 1
a23 1
       "$Id: MLSL1Rad.f90,v 2.2 2002/03/29 20:18:34 perun Exp $"
d40 12
d58 1
a58 1
    USE MLSL1Config, ONLY: L1Config, MIFsGHz, MIFsTHz
d72 35
d340 3
@


2.2
log
@Version 1.0 commit
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d5 1
a5 1
MODULE MLSL1Rad              ! Radiance data types for the MLSL1 program
d9 1
a9 1
       DACSnum, DACSchans, Chan_R_T
d15 5
a19 1
  PRIVATE :: Id, ModuleName
d22 1
a22 1
       "$Id: MLSL1Rad.f90,v 2.1 2001/02/23 18:26:11 perun Exp $"
d33 1
a33 1
     REAL(r4), DIMENSION (:,:), POINTER :: value, PRECISION
d37 1
a37 1
       DACSrad
d42 1
a42 1
  SUBROUTINE InitRad
d50 2
d54 1
a54 1
    INTEGER :: i, status, BandNo, RADMIFs
d59 39
a97 1
    ALLOCATE (L1Brad(FBnum+MBnum+WFnum+DACSnum), STAT=status)
d103 1
a103 1
    DO i = 1, FBnum
d105 1
a105 6
       IF (i < 15) THEN
          RADMIFs = MIFsGHz
       ELSE
          RADMIFs = MIFsTHz
       ENDIF
       ALLOCATE (L1Brad(i)%value(FBchans,RADMIFs), STAT=status)
d108 1
a108 1
       ALLOCATE (L1Brad(i)%precision(FBchans,RADMIFs), STAT=status)
a118 2
       CASE (15)
          BandNo = BandSwitch(5)
d131 1
a131 3
    RADMIFs = MIFsGHz          ! Size for remainder of channels

    FBrad => L1Brad(1:FBnum)   ! Point to FB data
d137 1
a137 1
       ALLOCATE (L1BRad(i+FBnum)%value(MBchans,RADMIFs), STAT=status)
d140 1
a140 1
       ALLOCATE (L1BRad(i+FBnum)%precision(MBchans,RADMIFs), STAT=status)
d145 1
a145 1
       L1Brad(i+FBnum)%signal = signal(1)
d150 1
a150 1
    MBrad => L1Brad(FBnum+1:FBnum+MBnum)  ! Point to MB data
d156 1
a156 1
       ALLOCATE (L1BRad(i+FBnum+MBnum)%value(WFchans,RADMIFs), STAT=status)
d159 1
a159 1
       ALLOCATE (L1BRad(i+FBnum+MBnum)%precision(WFchans,RADMIFs), STAT=status)
d164 1
a164 1
       L1Brad(i+FBnum+MBnum)%signal = signal(1)
d169 1
a169 1
    WFrad => L1Brad(FBnum+MBnum+1:FBnum+MBnum+WFnum)  ! Point to WF data
d175 1
a175 1
       ALLOCATE (L1BRad(i+FBnum+MBnum+WFnum)%value(DACSchans,RADMIFs), &
d179 1
a179 1
       ALLOCATE (L1BRad(i+FBnum+MBnum+WFnum)%precision(DACSchans,RADMIFs), &
d190 1
a190 1
       L1Brad(i+FBnum+MBnum+WFnum)%signal = signal(1)
d195 1
a195 3
    DACSrad => L1Brad(FBnum+MBnum+WFnum+1:FBnum+MBnum+WFnum+DACSnum)

    RETURN
d205 1
a205 1
    INTEGER :: BandSwitch(5)
d211 23
a233 1
!! DACS first
d238 1
a238 1
       L1Brad(1+FBnum+MBnum+WFnum)%signal = signal(1)
d244 1
a244 1
    DO i = 2, 5
d272 14
d292 3
@


2.1
log
@Version 0.5 commit
@
text
@d8 4
a11 4
  USE MLSL1Common
  USE MLSSignalNomenclature
  USE MLSMessageModule
  USE MLSStrings
d18 1
a18 1
       "$Id: MLSL1Rad.f90,v 2.0 2000/09/05 18:55:14 ahanzel Exp $"
d29 1
a29 1
     REAL(r4), DIMENSION (:,:), POINTER :: value, precision
d32 2
a33 1
  TYPE (Radiance_T), DIMENSION(:), POINTER :: L1Brad, FBrad, MBrad, WFrad
d41 2
a42 1
    USE MLSL1Config, ONLY: MIFsGHz, MIFsTHz
d48 1
a48 1
    INTEGER :: i, status,RADMIFs
d50 2
a51 1
    CHARACTER (LEN=3) :: bandNo
d53 1
a53 3
    ! For this version, allocate for only standard and mid-band filter banks

    ALLOCATE (L1Brad(FBnum+MBnum+WFnum), STAT=status)
d72 17
a88 2
       WRITE (bandNo, '("B",i2.2)') i
       CALL ParseMLSSignalRequest (bandNo, signal, .false.)
d108 2
a109 2
       WRITE (bandNo, '("B",i2.2)') (i+26)   ! start at band 27
       CALL ParseMLSSignalRequest (bandNo, signal, .false.)
d127 2
a128 2
       WRITE (bandNo, '("B",i2.2)') (i+31)   ! start at band 32
       CALL ParseMLSSignalRequest (bandNo, signal, .false.)
d136 26
d164 52
a215 1
  END Subroutine InitRad
d223 3
@


2.0
log
@Changing file revision to 2.0.
@
text
@d1 1
a1 1
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 1
a18 1
       "$Id: MLSL1Rad.f90,v 1.2 2000/02/16 21:41:13 perun Exp $"
d32 2
d37 1
a37 1
  SUBROUTINE InitRad (L1Brad)
d40 2
a43 2
    TYPE (Radiance_T), DIMENSION(:), POINTER :: L1Brad

d46 2
a47 2
    INTEGER :: i, status
    TYPE (MLSSignal_T), DIMENSION(:), POINTER :: signal
d52 1
a52 1
    ALLOCATE (L1Brad(FBnum+MBnum), STAT=status)
d60 6
a65 1
       ALLOCATE (L1Brad(i)%value(FBchans,MaxMIFs), STAT=status)
d68 1
a68 1
       ALLOCATE (L1Brad(i)%precision(FBchans,MaxMIFs), STAT=status)
d78 4
d86 1
a86 1
       ALLOCATE (L1BRad(i+FBnum)%value(MBchans,MaxMIFs), STAT=status)
d89 1
a89 1
       ALLOCATE (L1BRad(i+FBnum)%precision(MBchans,MaxMIFs), STAT=status)
d99 21
d130 3
@


1.2
log
@Added calls to MLSSignals routine
@
text
@d18 1
a18 1
       "$Id: MLSL1Rad.f90,v 1.2 2000/02/16 21:41:13 perun Exp $"
d98 3
d104 1
a104 3
! Revision 1.1  2000/02/08 21:26:58  perun
! Initial version
!
@


1.1
log
@Initial version
@
text
@d18 1
a18 1
       "$Id: MLSL1Rad.f90,v 1.1 2000/02/08 21:26:58 perun Exp $"
a31 28
  ! Nominal Radiometer names

  CHARACTER (LEN=7), PARAMETER, DIMENSION(FBnum) :: FB_Radiometer = (/ &
       & "R1A:118", "R2:190 ", "R2:190 ", "R2:190 ", "R2:190 ", "R2:190 ", &
       & "R3:240 ", "R3:240 ", "R3:240 ", "R4:640 ", "R4:640 ", "R4:640 ", &
       & "R4:640 ", "R4:640 ", "R5H:2T5", "R5H:2T5", "R5H:2T5", "R5V:2T5", &
       & "R5V:2T5"  /)
  CHARACTER (LEN=6), PARAMETER, DIMENSION(MBnum) :: MB_Radiometer = (/ &
       & "R2:190", "R4:640", "R4:640", "R4:640", "R4:640" /)

  ! Nominal Bands

  CHARACTER (LEN=8), PARAMETER, DIMENSION(FBnum) :: FB_Band = (/ &
       & "B1F:PT  ", "B2F:H2O ", "B3F:N2O ", "B4F:HNO3", "B5F:CLO ", &
       & "B6F:O3  ", "B7F:O3  ", "B8F:PT  ", "B9F:CO  ", "B10F:CLO", &
       & "B11F:BRO", "B12F:N2O", "B13F:HCL", "B14F:O3 ", "B15F:OH ", &
       & "B16F:OH ", "B17F:PT ", "B18F:OH ", "B19F:OH " /)
  CHARACTER (LEN=9), PARAMETER, DIMENSION(MBnum) :: MB_Band = (/ &
       & "B27M:HCN ", "B28M:HO2 ", "B29M:HOCL", "B30M:HO2 ", "B31M:BRO " /)

  ! Nominal Switch positions

  CHARACTER (LEN=2), PARAMETER, DIMENSION(FBnum) :: FB_Switch = (/ &
       & "S0", "S0", "S2", "S0", "S0", "S0", "S0", "S3", "S0", "S0", &
       & "S0", "S4", "S0", "S0", "S5", "S0", "S0", "S0", "S0"  /)
  CHARACTER (LEN=2), PARAMETER, DIMENSION(MBnum) :: MB_Switch = (/ &
       & "S0", "S0", "S0", "S0", "S0" /)

d45 2
d64 4
a67 7

       L1Brad(i)%signal%radiometerName = FB_Radiometer(i)
       L1Brad(i)%signal%bandName = FB_Band(i)
       L1Brad(i)%signal%switch = FB_Switch(i)
       WRITE (L1Brad(i)%signal%spectrometerName, '("FB25-", i2)') i
       L1Brad(i)%signal%spectrometerName = &
            & CompressString (L1Brad(i)%signal%spectrometerName)
d81 4
a84 5

       L1Brad(i+FBnum)%signal%radiometerName = MB_Radiometer(i)
       L1Brad(i+FBnum)%signal%bandName = MB_Band(i)
       L1Brad(i+FBnum)%signal%switch = MB_Switch(i)
       WRITE (L1Brad(i+FBnum)%signal%spectrometerName, '("MB11-", i1)') i
d98 3
@


