head	2.6;
access;
symbols
	v5-02-NRT-19:2.6
	v6-00:2.6
	v5-02-NRT-18:2.6
	v5-02:2.6
	v5-01-NRT-17:2.6
	v5-01-NRT-16:2.6
	v5-01-NRT-15:2.6
	v5-01-NRT-14:2.6
	neuralnetworks-1-0:2.6.0.16
	cfm-single-freq-0-1:2.6.0.14
	v5-01:2.6
	v5-00:2.6
	v4-23-TA133:2.6.0.12
	mus-emls-1-70:2.6.0.10
	rel-1-0-englocks-work:2.6.0.8
	VUMLS1-00:2.6
	VPL1-00:2.6
	V4-22-NRT-08:2.6
	whdrel10_merged_to_here:2.6
	merge_whdrel10_from_here:2.6
	TAG_TRUNK_AFTER_PW_CHANGES:2.6
	TAG_TRUNK_BEFORE_PW_CHANGES:2.6
	VAM1-00:2.6
	whd-rel-1-0:2.6.0.6
	V4-21:2.6.0.4
	V4-13:2.6
	V4-12:2.6
	V4-11:2.6
	V4-10:2.6
	V3-43:2.6
	M4-00:2.6
	V3-41:2.6
	V3-40-PlusGM57:2.6.0.2
	V2-24-NRT-04:2.6
	V3-33:2.6
	V2-24:2.6
	V3-31:2.6
	V3-30-NRT-05:2.6
	cfm-01-00:2.6
	V3-30:2.6
	V3-20:2.6
	V3-10:2.6
	V2-23-NRT-02:2.6
	V2-23:2.6
	V2-22-NRT-01:2.6
	V2-22:2.6
	V2-21:2.6
	V2-20:2.6
	V2-11:2.6
	V2-10:2.6
	V2-00:2.5
	V1-51:2.3
	V1-50:2.3
	V1-45:2.2
	V1-44:2.2
	V1-43:2.2
	V1-42:2.1
	V1-41:2.1
	V1-40:2.1;
locks; strict;
comment	@# @;


2.6
date	2006.08.02.18.54.08;	author perun;	state Exp;
branches;
next	2.5;

2.5
date	2005.06.23.18.41.35;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2005.05.02.16.02.50;	author perun;	state Exp;
branches;
next	2.3;

2.3
date	2004.11.10.15.35.10;	author perun;	state Exp;
branches;
next	2.2;

2.2
date	2004.05.14.15.59.11;	author perun;	state Exp;
branches;
next	2.1;

2.1
date	2004.01.09.17.46.22;	author perun;	state Exp;
branches;
next	;


desc
@@


2.6
log
@Accumulate latitude bin data in 8 bins instead of 4x2 bins
@
text
@! Copyright 2006, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
MODULE GHzBaseline ! Determine GHz baseline radiance corrections
!=============================================================================

  USE MLSL1Common, ONLY: FBchans, MBchans, L1BFileInfo, NumBands
  USE MLSL1Config, ONLY: MIFsGHz
  USE MLSL1Rad, ONLY: L1Brad
  USE OutputL1B, ONLY: OutputL1B_LatBinData
  USE L1BData, ONLY: L1BData_T, ReadL1BData, DeallocateL1BData

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: LatBinRads, OutputBaselinedRads

!---------------------------- RCS Module Info ------------------------------
  CHARACTER (len=*), PRIVATE, PARAMETER :: ModuleName= &
       "$RCSfile: GHzBaseline.f90,v $"
  PRIVATE :: not_used_here 
!---------------------------------------------------------------------------

  INTEGER, PARAMETER :: NumGHzBands = 20   ! Number of GHz FB+MB bands
  INTEGER, PARAMETER :: NoLatBins = 8

  INTEGER, PARAMETER :: BaselineBandNo(NumGHzBands) = (/ &
       1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 21, 27, 28, 29, 30, 31 /)
  INTEGER :: LatBinNum(FBchans,NumBands,NoLatBins) = 0
  REAL :: LatBinChanAvg(FBchans,NumBands,NoLatBins) = 0.0
  REAL, PARAMETER :: LatBin(2,NoLatBins) = RESHAPE (&
       (/ -90.0, -45.0, -45.0,  0.0,   0.0, 45.0,  45.0,  90.0, &     ! Ascend
           45.0,  90.0,   0.0, 45.0, -45.0,  0.0, -90.0, -45.0 /), &  ! Descend
      (/ 2, NoLatBins /))                                    ! final shape
  REAL :: WeightedRadAvg(NumBands,NoLatBins) = 0.0

  REAL, SAVE :: BaselineAlt(FBchans,NumBands) = 8.0e04   ! initial values

  INTEGER, SAVE :: MAFno = 1

  INTEGER, PARAMETER :: MaxMAFs = 4000   ! more than enough for 24 hours
  INTEGER :: AscDescIndx(MIFsGHz,MaxMAFs), LatBinIndx(MIFsGHz,MaxMAFs)

CONTAINS

!=============================================================================
  SUBROUTINE LatBinRads
!=============================================================================

    USE TkL1B, ONLY: Alt => GHz_GeodAlt, Lat => GHz_GeodLat, &
         Angle => GHz_GeodAngle
    USE SpectralBaseline, ONLY: BaselineInclude, BaselineAC

    INTEGER :: i, bandno, bankno, chan, latno, m, nchans
    INTEGER :: Aindx, Lindx
    REAL :: ModAngle(MIFsGHz)

PRINT *, 'binning rads by lat...'

! Set Baseline Alts, if not already done:

    IF (MAFno == 1) THEN
       DO i = 1, (NumGHzBands - 1)    ! Band 21 is switchable
          bandno = L1Brad(i)%BandNo
          IF (bandno <= 14) THEN
             nchans = FBchans
          ELSE IF (bandno == 21) THEN
             nchans = FBchans
          ELSE
             nchans = MBchans
          ENDIF
          DO chan = 1, nchans
             IF (.NOT. BaselineInclude(bandno)%chan(chan)) &
                  BaselineAlt(chan,bandno) = HUGE (1.0)
          ENDDO
       ENDDO
    ENDIF

! Determine Asc/Desc (1/2) indexes:

    ModAngle = MOD ((Angle + 360.0), 360.0)
    WHERE (ModAngle > 90.0 .AND. ModAngle <= 270.0)
       AscDescIndx(:,MAFno) = 2   ! Descending index
    ELSEWHERE
       AscDescIndx(:,MAFno) = 1   ! Ascending index
    ENDWHERE

! Determine lat bin indexes:

    DO i = 1, MIFsGHz
       IF (AscDescIndx(i,MAFno) == 1) THEN     ! Ascending
          DO latno = 1, NoLatBins/2
             IF (lat(i) <= LatBin(2,latno)) THEN
                LatBinIndx(i,MAFno) = latno
                EXIT
             ENDIF
          ENDDO
       ELSE                                    ! Descending
          DO latno = (NoLatBins/2 + 1), NoLatBins
             IF (lat(i) >= LatBin(1,latno)) THEN
                LatBinIndx(i,MAFno) = latno
                EXIT
             ENDIF
          ENDDO
       ENDIF
    ENDDO

! Accumulate Radiance data:

    DO i = 1, (NumGHzBands - 1)    ! Band 21 is switchable

       bankno = L1Brad(i)%signal%spectrometernumber
       bandno = L1Brad(i)%BandNo
       IF (bandno <= 14) THEN
          nchans = FBchans
       ELSE IF (bandno == 21) THEN
          nchans = FBchans
       ELSE
          nchans = MBchans
          bankno = bankno + 14    ! relative to start of FB data
       ENDIF

       DO m = 1, MIFsGHz
          DO chan = 1, nchans
             IF (Alt(m) > BaselineAlt(chan,bandno) .AND. &
                  L1Brad(bankno)%precision(chan,m) >= 0.0) THEN
                Lindx = LatBinIndx(m,MAFno)
                Aindx = AscDescIndx(m,MAFno)
                IF (Lindx > 0) THEN
                   LatBinNum(chan,bandno,Lindx) = &
                        LatBinNum(chan,bandno,Lindx) + 1
                   LatBinChanAvg(chan,bandno,Lindx) = &
                        LatBinChanAvg(chan,bandno,Lindx) &
                        + L1Brad(bankno)%value(chan,m) - &
                        BaselineAC(bandno)%offset(chan)
                ENDIF
             ENDIF
          ENDDO
       ENDDO

    ENDDO

    CALL OutputL1B_LatBinData (MAFno, L1BFileInfo%RADGid, &
         AscDescIndx=AscDescIndx(:,MAFno), LatBinIndx=LatBinIndx(:,MAFno))

    MAFno = MAFno + 1

  END SUBROUTINE LatBinRads

!=============================================================================
  SUBROUTINE CalcWeightedAvgs
!=============================================================================

    USE MLSL1Common, ONLY: BandWidth

    INTEGER :: bandno, bin, chan, i, nchans, NBWoffset
    REAL :: NoiseBandWidth(FBchans), SumBandWidth, wghtavg(FBchans)

    PRINT *, 'calc wght avgs...'

    NoiseBandWidth = BandWidth%FB(:,1) * 1.0e-06  ! In MHz

    DO bin = 1, NoLatBins
       DO i = 1, NumGHzBands
          bandno = BaselineBandNo(i)
          wghtavg = 0.0
          SumBandWidth = 0.0
          IF (bandno <= 15) THEN
             NBWoffset = 0
             nchans = FBchans
          ELSE
             NBWoffset = 7
             nchans = MBchans
          ENDIF

          DO chan = 1, nchans
             IF (LatBinNum(chan,bandno,bin) > 0) THEN
                LatBinChanAvg(chan,bandno,bin) = &
                     LatBinChanAvg(chan,bandno,bin) / &
                     LatBinNum(chan,bandno,bin)
                wghtavg(chan) = LatBinChanAvg(chan,bandno,bin) * &
                     NoiseBandWidth(chan+NBWoffset)
                SumBandWidth = SumBandWidth + NoiseBandWidth(chan+NBWoffset)
             ENDIF
          ENDDO
          IF (SumBandWidth > 0.0) &
               WeightedRadAvg(bandno,bin) = SUM (wghtavg) / &
               SumBandWidth
          WHERE (LatBinNum(:,bandno,bin) > 0)
             LatBinChanAvg(:,bandno,bin) = &
                  LatBinChanAvg(:,bandno,bin) - &
                  WeightedRadAvg(bandno,bin)
          ENDWHERE
       ENDDO
    ENDDO

    CALL OutputL1B_LatBinData (0, L1BFileInfo%RADGid, &
         LatBinChanAvg=LatBinChanAvg)

    CALL OutputL1B_LatBinData (0, L1BFileInfo%RADGid, BaselineAlt=BaselineAlt)

    CALL OutputL1B_LatBinData (0, L1BFileInfo%RADGid, LatBin=LatBin)

  END SUBROUTINE CalcWeightedAvgs

!=============================================================================
  SUBROUTINE OutputBaselinedRads
!=============================================================================

    USE MLSL1Rad, ONLY: Rad_name
    USE HDF5, ONLY: H5gClose_f, H5gOpen_f
    USE MLSHDF5, ONLY: SaveAsHDF5DS, MakeHDF5Attribute
    USE MLSL1Config, ONLY: L1Config

    REAL, POINTER, DIMENSION(:,:) :: baseline => NULL()
    LOGICAL, POINTER, DIMENSION(:) :: binMinus => NULL()

    CHARACTER(LEN=80) :: name, binnedname
    INTEGER :: i, MAF, MIF, noMAFs, Flag, nchans, grp_id
    INTEGER :: c1, c2, bandno, status

    TYPE (L1BData_T) :: L1BData

    binMinus => L1Config%Output%SubtractBinnedBaseline
 
! Calculate weighted averages first:

    CALL CalcWeightedAvgs

    IF (.NOT. L1Config%Output%RemoveBaseline) RETURN  ! Nothing more

! Get the GHz FB/MB baselines and adjust

    DO i = 1, SIZE (Rad_name)  ! Check all FB25- and MB11- possibilities

       name = TRIM(Rad_name(i)) // ' Baseline'
       binnedname = TRIM(Rad_name(i)) // ' BinnedBaselineAC'
       c1 = INDEX (name, '.B') + 2
       IF (i < 18) THEN
          c2 = c1 
       ELSE
          c2 = c1 + 1
       ENDIF
       READ (name(c1:c2), *) bandno

       IF ((bandno > 14 .AND. bandno < 21) .OR. (bandno > 21 .AND. &
            bandno < 27) .OR. (bandno > 31)) CYCLE   ! nothing for other bands

       CALL ReadL1BData (L1BFileInfo%RADGid, name, L1BData, noMAFs, Flag, &
            NeverFail=.TRUE., HDFversion=5)
       IF (Flag == 0) THEN

          IF (bandno <= 14) THEN
             nchans = FBchans
          ELSE IF (bandno == 21) THEN
             nchans = FBchans
          ELSE
             nchans = MBchans
          ENDIF

          IF (.NOT. ASSOCIATED (baseline)) THEN
             ALLOCATE (baseline(nchans,noMAFs))
          ENDIF

          baseline = L1BData%DpField(1,:,:)
          CALL DeallocateL1BData (L1BData)

          IF (binMinus(bandno)) THEN

! Remove baseline from baseline:

             MIF = 1     ! use start of MAF for index
             DO MAF = 1, noMAFS
                baseline(:,MAF) = baseline(:,MAF) - &
                     LatBinChanAvg(:,bandno,LatBinIndx(MIF,MAF))
             ENDDO

! Write adjusted baselines here:

             CALL SaveAsHDF5DS (L1BFileInfo%RADGid, name, baseline, &
                  adding_to=.TRUE.)

          ENDIF

          DEALLOCATE (baseline, stat=status)

! Write appropriate baseline adjustments:

          CALL OutputL1B_LatBinData (0, L1BFileInfo%RADGid, &
               BinnedBaseline=LatBinChanAvg(1:nchans,bandno,:), &
               Name=binnedname)

       ENDIF

    ENDDO

! Save baseline flags (may want to make as DS with attributes):

    CALL H5gOpen_f (L1BFileInfo%RADGid, '/', grp_id, i)
    CALL MakeHDF5Attribute (grp_id, 'BinnedBaselineSubtracted', &
         binMinus, .TRUE.)
    CALL H5gClose_f (grp_id, i)

  END SUBROUTINE OutputBaselinedRads

!=============================================================================
  LOGICAL FUNCTION not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (len=*), PARAMETER :: IdParm = &
       "$Id: GHzBaseline.f90,v 2.5 2005/06/23 18:41:35 pwagner Exp $"
  CHARACTER (len=LEN(idParm)), SAVE :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  END FUNCTION not_used_here
END MODULE GHzBaseline
!=============================================================================
! $Log: GHzBaseline.f90,v $
! Revision 2.5  2005/06/23 18:41:35  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.4  2005/05/02 16:02:50  perun
! Deallocate last rad and rad_err pointers
!
! Revision 2.3  2004/11/10 15:35:10  perun
! Add call to deallocate L1BData
!
! Revision 2.2  2004/05/14 15:59:11  perun
! Version 1.43 commit
!
!
@


2.5
log
@Reworded Copyright statement, moved rcs id
@
text
@d1 1
a1 1
! Copyright 2005, by the California Institute of Technology. ALL
d16 1
a16 1
  USE MLSL1Common, ONLY: FBchans, L1BFileInfo
d18 1
a18 1
  USE MLSL1Rad, ONLY: FBrad
d29 3
a31 3
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: $"
  private :: not_used_here 
d34 2
a35 2
  INTEGER, PARAMETER :: NumGHzBands = 15   ! Number of GHz FB bands
  INTEGER, PARAMETER :: NoLatBins = 4
d37 9
a45 7
  INTEGER :: LatBinNum(FBchans,NumGHzBands,NoLatBins,2) = 0
  REAL :: LatBinChanAvg(FBchans,NumGHzBands,NoLatBins,2) = 0.0
  REAL :: LatBin(2,NoLatBins,2) = RESHAPE (&
       (/ -90.0, -45.0, -45.0, 0.0, 0.0, 45.0, 45.0, 90.0, &     ! Ascending
          -90.0, -45.0, -45.0, 0.0, 0.0, 45.0, 45.0, 90.0 /), &  ! Descending
       (/ 2, NoLatBins, 2 /))                                    ! final shape
  REAL :: WeightedRadAvg(NumGHzBands,NoLatBins,2) = 0.0
d47 1
a47 1
  REAL, PARAMETER :: BaselineAlt(FBchans,NumGHzBands) = 5.0e04   ! test!!
d62 1
d64 1
a64 1
    INTEGER :: i, bandindx, bankno, chan, latno, m
d68 20
a87 1
print *, 'binning rads by lat...'
d91 1
a91 1
    ModAngle = MOD (ABS(Angle), 360.0)
d101 15
a115 6
       DO latno = 1, NoLatBins
          IF (lat(i) <= LatBin(2,latno,AscDescIndx(i,MAFno))) THEN
             LatBinIndx(i,MAFno) = latno
             EXIT
          ENDIF
       ENDDO
d120 1
a120 1
    DO i = 1, SIZE (FBrad)
d122 10
a131 2
       bandindx = MIN (FBrad(i)%BandNo, NumGHzBands)   ! bandno 21 is last entry
       bankno = FBrad(i)%signal%spectrometernumber
d134 3
a136 3
          DO chan = 1, FBchans
             IF (Alt(m) > BaselineAlt(chan,bandindx) .AND. &
                  FBrad(bankno)%precision(chan,m) >= 0.0) THEN
d139 7
a145 6
                IF (Lindx > 0 .AND. Aindx > 0) THEN
                   LatBinNum(chan,bandindx,Lindx,Aindx) = &
                        LatBinNum(chan,bandindx,Lindx,Aindx) + 1
                   LatBinChanAvg(chan,bandindx,Lindx,Aindx) = &
                        LatBinChanAvg(chan,bandindx,Lindx,Aindx) &
                        + FBrad(bankno)%value(chan,m)
d166 1
a166 1
    INTEGER :: AscDes, band, bin, chan
d169 1
a169 1
    print *, 'calc wght avgs...'
d173 22
a194 20
    DO AscDes = 1, 2
       DO bin = 1, NoLatBins
          DO band = 1, NumGHzBands
             wghtavg = 0.0
             SumBandWidth = 0.0
             DO chan = 1, FBchans
                IF (LatBinNum(chan,band,bin,AscDes) > 0) THEN
                   LatBinChanAvg(chan,band,bin,AscDes) = &
                        LatBinChanAvg(chan,band,bin,AscDes) / &
                        LatBinNum(chan,band,bin,AscDes)
                   wghtavg(chan) = LatBinChanAvg(chan,band,bin,AscDes) * &
                        NoiseBandWidth(chan)
                   SumBandWidth = SumBandWidth + NoiseBandWidth(chan)
                ENDIF
             ENDDO
             IF (SumBandWidth > 0.0) &
                  WeightedRadAvg(band,bin,AscDes) = SUM (wghtavg) / SumBandWidth
             LatBinChanAvg(:,band,bin,AscDes) = &
                  LatBinChanAvg(:,band,bin,AscDes) - &
                  WeightedRadAvg(band,bin,AscDes)
d196 8
d221 2
a222 1
    USE MLSHDF5, ONLY: SaveAsHDF5DS
d225 2
a226 1
    REAL, POINTER, DIMENSION(:,:,:) :: rad => NULL(), rad_err => NULL()
d228 3
a230 4
    CHARACTER(LEN=80) :: name
    INTEGER :: i, MAF, MaxMIFs, MIF, noMAFs, Flag
    INTEGER :: c1, c2, bandno, bandindx, status
    INTEGER, PARAMETER :: dims(3) = (/ FBchans, MIFsGHz, 1 /)
d233 2
d242 3
a244 1
! Get the GHz FB rads and errs and adjust
d246 12
a257 1
    DO i = 1, 39  ! Check all FB25- possibilities
a258 1
       name = Rad_name(i)
a261 1
          print *, 'name: ', L1BData%L1BName
d263 10
a272 9
          c1 = INDEX (name, '.B') + 2
          c2 = INDEX (name, 'F:') - 1
          READ (name(c1:c2), *) bandno
          bandindx = MIN (bandno, NumGHzBands)   ! bandno 21 is last entry

          IF (.NOT. ASSOCIATED (rad)) THEN
             maxMIFs = L1BData%MaxMIFs
             ALLOCATE (rad(FBchans,MaxMIFs,noMAFs))
             ALLOCATE (rad_err(FBchans,MaxMIFs,noMAFs))
d275 1
a275 1
          rad = L1BData%DpField
d278 1
a278 5
          name = TRIM(name) // ' precision'
          CALL ReadL1BData (L1BFileInfo%RADGid, name, L1BData, noMAFs, Flag, &
               NeverFail=.TRUE., HDFversion=5)
          rad_err = L1BData%DpField
          CALL DeallocateL1BData (L1BData)
d280 1
a280 1
! Remove baseline from rads:
d282 4
a285 7
          DO MAF = 1, noMAFS
             DO MIF = 1, MaxMIFs
                WHERE (rad_err(:,MIF,MAF) >= 0.0)
                   rad(:,MIF,MAF) = rad(:,MIF,MAF) - &
                       LatBinChanAvg(:,bandindx,LatBinIndx(MIF,MAF), &
                         AscDescIndx(MIF,MAF))
                ENDWHERE
a286 1
         ENDDO
d288 10
a297 1
! Write adjusted rads here:
d299 3
a301 2
          CALL SaveAsHDF5DS (L1BFileInfo%RADGid, TRIM(Rad_Name(i)), rad, &
               adding_to=.TRUE.)
d307 6
a312 2
    DEALLOCATE (rad, stat=status)
    DEALLOCATE (rad_err, stat=status)
d317 1
a317 1
  logical function not_used_here()
d319 3
a321 3
  character (len=*), parameter :: IdParm = &
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
d324 1
a324 1
  end function not_used_here
d328 3
@


2.4
log
@Deallocate last rad and rad_err pointers
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d28 5
a32 5
  !------------------------------- RCS Ident Info ------------------------------
  CHARACTER(LEN=130) :: id = &
       "$Id: GHzBaseline.f90,v 2.3 2004/11/10 15:35:10 perun Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: GHzBaseline.f90,v $"
  !-----------------------------------------------------------------------------
d246 8
d257 3
@


2.3
log
@Add call to deallocate L1BData
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d22 1
a22 1
       "$Id: GHzBaseline.f90,v 2.2 2004/05/14 15:59:11 perun Exp $"
d170 1
a170 1
    INTEGER :: c1, c2, bandno, bandindx
d232 3
d241 3
@


2.2
log
@Version 1.43 commit
@
text
@d12 1
a12 1
  USE L1BData, ONLY: L1BData_T, ReadL1BData
d22 2
a23 2
       "$Id: $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: $"
d203 1
d209 1
d237 4
a240 1
! $Log: $
@


2.1
log
@Version 1.4 commit
@
text
@@

