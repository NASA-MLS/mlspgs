head	2.34;
access;
symbols
	v5-02-NRT-19:2.34
	v6-00:2.34
	v5-02-NRT-18:2.34
	v5-02:2.33
	v5-01-NRT-17:2.33
	v5-01-NRT-16:2.33
	v5-01-NRT-15:2.33
	v5-01-NRT-14:2.33
	neuralnetworks-1-0:2.33.0.10
	cfm-single-freq-0-1:2.33.0.8
	v5-01:2.33
	v5-00:2.33
	v4-23-TA133:2.33.0.6
	mus-emls-1-70:2.33.0.4
	rel-1-0-englocks-work:2.33.0.2
	VUMLS1-00:2.33
	VPL1-00:2.33
	V4-22-NRT-08:2.33
	whdrel10_merged_to_here:2.32
	merge_whdrel10_from_here:2.32
	TAG_TRUNK_AFTER_PW_CHANGES:2.32
	TAG_TRUNK_BEFORE_PW_CHANGES:2.32
	VAM1-00:2.32
	whd-rel-1-0:2.32.0.6
	V4-21:2.32.0.4
	V4-13:2.32
	V4-12:2.32
	V4-11:2.32
	V4-10:2.32
	V3-43:2.32
	M4-00:2.32
	V3-41:2.32
	V3-40-PlusGM57:2.32.0.2
	V2-24-NRT-04:2.32
	V3-33:2.32
	V2-24:2.32
	V3-31:2.32
	V3-30-NRT-05:2.32
	cfm-01-00:2.32
	V3-30:2.32
	V3-20:2.32
	V3-10:2.32
	V2-23-NRT-02:2.32
	V2-23:2.32
	V2-22-NRT-01:2.31
	V2-22:2.30
	V2-21:2.30
	V2-20:2.29
	V2-11:2.28
	V2-10:2.28
	V2-00:2.27
	V1-51:2.20
	V1-50:2.19
	V1-45:2.17
	V1-44:2.17
	V1-43:2.16
	V1-42:2.15
	V1-41:2.15
	V1-32:2.14
	V1-40:2.15
	V1-31:2.14
	V1-30:2.14
	V1-13:2.13
	V1-12:2.13
	V1-11:2.13
	V1-10:2.13
	newfwm-feb03:2.13.0.2
	V1-04:2.11
	V1-03:2.11
	V1-02:2.11
	V1-00:2.11
	newfwm-sep01:2.10.0.2
	V0-7:2.10
	V0-5-Level2:2.10
	V0-5-SIPS:2.9;
locks; strict;
comment	@# @;


2.34
date	2023.06.06.22.32.12;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2016.05.10.20.42.30;	author mmadatya;	state Exp;
branches;
next	2.32;

2.32
date	2008.03.04.19.59.55;	author perun;	state Exp;
branches;
next	2.31;

2.31
date	2008.01.15.19.53.33;	author perun;	state Exp;
branches;
next	2.30;

2.30
date	2007.02.09.15.04.26;	author perun;	state Exp;
branches;
next	2.29;

2.29
date	2006.09.28.16.15.01;	author perun;	state Exp;
branches;
next	2.28;

2.28
date	2006.08.02.18.54.31;	author perun;	state Exp;
branches;
next	2.27;

2.27
date	2006.06.14.13.45.27;	author perun;	state Exp;
branches;
next	2.26;

2.26
date	2006.04.05.18.09.17;	author perun;	state Exp;
branches;
next	2.25;

2.25
date	2006.03.24.15.07.48;	author perun;	state Exp;
branches;
next	2.24;

2.24
date	2005.12.06.19.23.25;	author perun;	state Exp;
branches;
next	2.23;

2.23
date	2005.10.10.19.05.32;	author perun;	state Exp;
branches;
next	2.22;

2.22
date	2005.06.23.18.41.35;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2005.05.02.16.03.27;	author perun;	state Exp;
branches;
next	2.20;

2.20
date	2005.01.28.16.58.47;	author perun;	state Exp;
branches;
next	2.19;

2.19
date	2004.12.01.17.09.38;	author perun;	state Exp;
branches;
next	2.18;

2.18
date	2004.11.10.15.39.37;	author perun;	state Exp;
branches;
next	2.17;

2.17
date	2004.08.12.13.51.51;	author perun;	state Exp;
branches;
next	2.16;

2.16
date	2004.05.14.15.59.11;	author perun;	state Exp;
branches;
next	2.15;

2.15
date	2004.01.09.17.46.23;	author perun;	state Exp;
branches;
next	2.14;

2.14
date	2003.08.15.14.25.04;	author perun;	state Exp;
branches;
next	2.13;

2.13
date	2002.11.14.16.49.57;	author perun;	state Exp;
branches;
next	2.12;

2.12
date	2002.11.07.21.34.42;	author jdone;	state Exp;
branches;
next	2.11;

2.11
date	2002.03.29.20.18.34;	author perun;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.27.14.01.14;	author perun;	state Exp;
branches;
next	2.9;

2.9
date	2001.04.05.14.43.56;	author perun;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.16.15.13.47;	author perun;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.14.15.59.27;	author perun;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.05.16.46.37;	author perun;	state Exp;
branches;
next	2.5;

2.5
date	2001.02.23.19.05.40;	author perun;	state Exp;
branches;
next	2.4;

2.4
date	2001.02.22.21.55.51;	author pwagner;	state dead;
branches;
next	2.3;

2.3
date	2001.02.12.17.51.47;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.01.17.54.28;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2000.11.15.00.11.27;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.34
log
@Made three params required--to avoid trouble w/ v4.24 and later
@
text
@! Copyright 2006, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

MODULE INIT_TABLES_MODULE

! Preload the string and symbol tables with specification and field
! names.  Preload the tree with definitions of types, lits, fields,
! specifications, sections ....

! Declaring the definitions is handled by the tree walker.

  USE Init_MLSSignals_m ! Everything. Init_MLSSignals, Field_First,
    ! Last_Signal_Field, Spec_First, Last_Signal_Spec, Numerous S_....
  USE INTRINSIC ! Everything. ADD_IDENT, BEGIN, D, F, FIRST_LIT,
    ! FIRST_MOLECULE,  INIT_INTRINSIC, L, L_<several>, LAST_INTRINSIC_LIT,
    ! LAST_MOLECULE, MAKE_TREE, N, NADP, ND, NDP, NP, NR, P, S, T,
    ! T_BOOLEAN, T_FIRST, T_LAST_INTRINSIC, T_NUMERIC, T_NUMERIC_RANGE,
    ! T_STRING and Z are used here, but everything is included so that it
    ! can be gotten by USE INIT_TABLES_MODULE.
  USE BrightObjects_m

  IMPLICIT NONE
  PUBLIC ! This would be a MUCH LONGER list than the list of private
  !        names below.
  PRIVATE :: ADD_IDENT, INIT_INTRINSIC, MAKE_TREE

!---------------------------- RCS Module Info ------------------------------
  CHARACTER (len=*), PRIVATE, PARAMETER :: ModuleName= &
       "$RCSfile: init_tables_module.f90,v $"
  PRIVATE :: not_used_here 
!---------------------------------------------------------------------------

! Enumeration types:

  INTEGER, PARAMETER :: T_USE            = last_BrightObject_type + 1
  INTEGER, PARAMETER :: T_UNITS          = t_use +1 
  INTEGER, PARAMETER :: T_ENABLE         = t_units + 1
  INTEGER, PARAMETER :: T_LAST           = t_enable

! Field indices:

  INTEGER, PARAMETER :: F_MIFS = last_BrightObject_Field + 1
  INTEGER, PARAMETER :: F_USE = f_mifs + 1
  INTEGER, PARAMETER :: F_SECONDARY = f_use + 1
  INTEGER, PARAMETER :: F_BANDNO = f_secondary + 1
  INTEGER, PARAMETER :: F_CHAN = f_bandno + 1
  INTEGER, PARAMETER :: F_YRDOY = f_chan + 1
  INTEGER, PARAMETER :: FIELD_LAST = f_yrdoy + 1

! Enumeration literals:

  INTEGER, PARAMETER :: L_MATCH   =  last_BrightObject_lit + 1
  INTEGER, PARAMETER :: L_OVERRIDE = l_match + 1
  INTEGER, PARAMETER :: LAST_LIT =      l_override + 1

! Section identities:

  INTEGER, PARAMETER :: Z_GLOBALSETTINGS = 1
  INTEGER, PARAMETER :: Z_CALIBRATION = Z_GLOBALSETTINGS + 1
  INTEGER, PARAMETER :: Z_OUTPUT = Z_CALIBRATION + 1
  INTEGER, PARAMETER :: SECTION_FIRST = z_globalSettings, &
                                SECTION_LAST = Z_OUTPUT

! Specification indices:

  INTEGER, PARAMETER :: S_SPACEMIFS = last_BrightObject_Spec + 1
  INTEGER, PARAMETER :: S_TARGETMIFS = s_spaceMIFs + 1
  INTEGER, PARAMETER :: S_LIMBMIFS = s_targetMIFs + 1
  INTEGER, PARAMETER :: S_DISCARDMIFS = s_limbMIFs + 1
  INTEGER, PARAMETER :: S_CHI2ERR = s_discardMIFs + 1
  INTEGER, PARAMETER :: S_MARKCHANBAD = s_chi2err + 1
  INTEGER, PARAMETER :: S_DISABLERADOUT = s_markchanbad + 1
  INTEGER, PARAMETER :: S_SUBTRACTBINNEDBASELINE = s_disableradout + 1
  INTEGER, PARAMETER :: SPEC_LAST = s_subtractbinnedbaseline

! Parameter names:

  ! In GlobalSettings section:

  INTEGER, PARAMETER :: P_OUTPUT_VERSION_STRING = spec_last + 1
  INTEGER, PARAMETER :: P_PRODUCE_L1BOA = p_output_version_string + 1
  INTEGER, PARAMETER :: P_SIMOA = p_produce_l1boa + 1

  ! In Calibration section:

  INTEGER, PARAMETER :: P_CALWINDOW = p_simoa + 1
  INTEGER, PARAMETER :: P_MAFexpandNum = p_calwindow + 1
  INTEGER, PARAMETER :: p_MaxDataGaps = p_MAFexpandNum + 1
  INTEGER, PARAMETER :: p_MaxErroneousCounterMAFs = p_MaxDataGaps + 1
  INTEGER, PARAMETER :: p_DiffBeginEndEng = p_MaxErroneousCounterMAFs + 1   
  INTEGER, PARAMETER :: P_USEDEFAULTGAINS = p_DiffBeginEndEng  + 1
  INTEGER, PARAMETER :: P_CALIBDACS = p_usedefaultgains + 1
  INTEGER, PARAMETER :: P_GHZSPACETEMP = p_calibdacs + 1
  INTEGER, PARAMETER :: P_GHZTARGETTEMP = p_GHzSpaceTemp + 1
  INTEGER, PARAMETER :: P_THZSPACETEMP = p_GHzTargetTemp + 1
  INTEGER, PARAMETER :: P_THZTARGETTEMP = p_THzSpaceTemp + 1
  INTEGER, PARAMETER :: P_THZSpaceAngle = p_THzTargetTemp + 1
  INTEGER, PARAMETER :: P_THZColdCal = p_THzSpaceAngle + 1
  INTEGER, PARAMETER :: P_MIF_DURATION = p_THzColdCal + 1
  INTEGER, PARAMETER :: P_MIF_DEAD_TIME = p_mif_duration + 1
  INTEGER, PARAMETER :: P_MIFsPerMAF = p_mif_dead_time + 1
  INTEGER, PARAMETER :: P_THzMaxBias = p_MIFsPerMAF + 1
  INTEGER, PARAMETER :: P_MoonToSpaceAngle = p_THzMaxBias + 1
  INTEGER, PARAMETER :: P_DACSWINDOW = p_MoonToSpaceAngle + 1
  INTEGER, PARAMETER :: P_TPdigital = p_DACSWINDOW + 1
  INTEGER, PARAMETER :: P_UseAntOffsets = p_TPdigital + 1
  INTEGER, PARAMETER :: P_MinSpaceLimbs = p_UseAntOffsets + 1
  INTEGER, PARAMETER :: P_Do_Slimb = P_MinSpaceLimbs + 1

  ! In Output section:

  INTEGER, PARAMETER :: P_REMOVEBASELINE = P_Do_Slimb + 1
  INTEGER, PARAMETER :: P_DECONVOLVEDACS = P_RemoveBaseline + 1

  INTEGER, PARAMETER :: FIRST_PARM = P_OUTPUT_VERSION_STRING
  INTEGER, PARAMETER :: LAST_PARM = P_DeconvolveDACS

! Table for section ordering:

  INTEGER, PARAMETER :: OK = 1, & ! NO = 0
    SECTION_ORDERING(section_first:section_last, &
                     section_first-1:section_last) = RESHAPE( &
! To: | globalSettings        |
!     |      Calibration      |
!     |            Output     |
! ====|==============================|== From: ==
        (/OK,    0,  0,    & ! Start
           0,   OK,  0,    & ! GlobalSettings
           0,   OK,  OK,   & ! Calibration
           0,    0,  OK /) & ! Output
        , (/ section_last-section_first+1, section_last-section_first+2 /) )

CONTAINS ! =====     Public procedures     =============================
! --------------------------------------------------  INIT_TABLES  -----
  SUBROUTINE INIT_TABLES

    USE TREE_TYPES, ONLY: N_DT_DEF, N_FIELD_TYPE, N_NAME_DEF, N_SECTION, &
     N_SPEC_DEF
    USE Units, ONLY: Init_units

  ! Put intrinsic predefined identifiers into the symbol table.

     CALL init_MLSSignals ( t_last, field_last, last_lit, &
     & first_parm, last_parm, section_last, spec_last )

  ! Put nonintrinsic predefined identifiers into the symbol table.

    ! Put enumeration type names into the symbol table

    data_type_indices(t_use) =              add_ident ( 'use' )
    data_type_indices(t_units) =            add_ident ( 'units' )

    ! Put enumeration literals into the symbol table:

    lit_indices(l_match) =                   add_ident ( 'match' )
    lit_indices(l_override) =                add_ident ( 'override' )

    ! Put field names into the symbol table

    field_indices(f_mifs) =                 add_ident ( 'MIFs' )
    field_indices(f_use) =                  add_ident ( 'use' )
    field_indices(f_secondary) =            add_ident ( 'secondary' )
    field_indices(f_bandno) =               add_ident ( 'bandno' )
    field_indices(f_chan) =                 add_ident ( 'chan' )
    field_indices(f_yrdoy) =                add_ident ( 'yrdoy' )
 
    ! Put parameter names into the symbol table

    parm_indices(p_calwindow)=               add_ident ( 'CalWindow' )
    parm_indices(p_MAFexpandNum)=            add_ident ( 'MAFexpandNum' )
    parm_indices(p_MaxDataGaps)=             add_ident ( 'MaxDataGaps' )
    parm_indices(p_MaxErroneousCounterMAFs)= add_ident ( 'MaxErroneousCounterMAFs' )
    parm_indices(p_DiffBeginEndEng)=        add_ident ( 'DiffBeginEndEng' )   
    parm_indices(p_MinSpaceLimbs)=          add_ident ( 'MinSpaceLimbs' )
    parm_indices(p_usedefaultgains)=        add_ident ( 'UseDefaultGains' )
    parm_indices(p_calibDACS)=              add_ident ( 'CalibDACS' )
    parm_indices(p_GHzSpaceTemp)=           add_ident ( 'GHzSpaceTemp' )
    parm_indices(p_GHzTargetTemp)=          add_ident ( 'GHzTargetTemp' )
    parm_indices(p_THzSpaceTemp)=           add_ident ( 'THzSpaceTemp' )
    parm_indices(p_THzTargetTemp)=          add_ident ( 'THzTargetTemp' )
    parm_indices(p_THzSpaceAngle)=          add_ident ( 'THzSpaceAngle' )
    parm_indices(p_THzColdCal)=             add_ident ( 'THzColdCal' )
    parm_indices(p_THzMaxBias)=             add_ident ( 'THzMaxBias' )
    parm_indices(p_mif_duration)=           add_ident ( 'MIF_Duration' )
    parm_indices(p_mif_dead_time)=          add_ident ( 'MIF_DeadTime' )
    parm_indices(p_mifspermaf)=             add_ident ( 'MIFsPerMAF' )
    parm_indices(p_output_version_string) = add_ident ( 'OutputVersionString' )
    parm_indices(p_produce_l1boa)=          add_ident ( 'ProduceL1BOA' )
    parm_indices(p_simoa)=                  add_ident ( 'SimOA' )
    parm_indices(p_removebaseline)=         add_ident ( 'RemoveBaseline' )
    parm_indices(p_MoonToSpaceAngle)=       add_ident ( 'MoonToSpaceAngle' )
    parm_indices(p_dacswindow)=             add_ident ( 'DACSwindow' )
    parm_indices(p_TPdigital)=              add_ident ( 'TPdigital' )
    parm_indices(p_Do_Slimb)=               add_ident ( 'Do_Slimb' )
    parm_indices(p_UseAntOffsets)=          add_ident ( 'UseAntOffsets' )
    parm_indices(p_DeconvolveDACS)=         add_ident ( 'DeconvolveDACS' )

    ! Put section names into the symbol table

    section_indices(z_calibration) =        add_ident ( 'Calibration' )
    section_indices(z_globalsettings) =     add_ident ( 'GlobalSettings' )
    section_indices(z_output) =             add_ident ( 'Output' )

    ! Put spec names into the symbol table

    spec_indices(s_spaceMIFs) =               add_ident ( 'spaceMIFs' )
    spec_indices(s_targetMIFs) =              add_ident ( 'targetMIFs' )
    spec_indices(s_limbMIFs) =                add_ident ( 'limbMIFs' )
    spec_indices(s_discardMIFs) =             add_ident ( 'discardMIFs' )
    spec_indices(s_chi2err) =                 add_ident ( 'EnableChi2Err' )
    spec_indices(s_markchanbad) =             add_ident ( 'MarkChanBad' )
    spec_indices(s_disableradout) =           add_ident ( 'DisableRadOut' )
    spec_indices(s_subtractbinnedbaseline) =  &
         add_ident ( 'SubtractBinnedBaseline' )

    ! Init Bright Objects symbol table entries:

    CALL Init_BrightObjects

  ! Now initialize the units tables.  Init_Units depends on the lit tables
  ! having been initialized.

    CALL Init_units

  ! Definitions are represented by trees.  The notation in the comments
  ! for the trees is < root first_son ... last_son >.  This is sometimes
  ! called "Cambridge Polish Notation."  It was developed to represent
  ! LISP by McCarthy et. al. at MIT (in Cambridge, MA).

  ! Put the definition trees into the tree space before the parser runs.
  ! After the parsing is done, they're automatically "glued in" to the
  ! "left" of the trees that represent the input.  The tree-walker
  ! stumbles upon them in its normal course of operation, never really
  ! realizing they're special (because by then they're not).

  ! Start with the definitions of types. These are represented by trees of
  ! the form  < n_dt_def t_type_name l_lit ... l_lit >

    ! Define the enumerated types

    CALL make_tree ( (/ &
      begin, t+t_use, l+l_match, l+l_override, n+n_dt_def, &
      begin, t+t_module, l+l_ghz, l+l_thz, n+n_dt_def, &
      begin, t+t_units, l+l_days, l+l_deg, l+l_degrees, &
             l+l_dimensionless, l+l_dimless, l+l_dl, l+l_ghz, &
             l+l_hours, l+l_hpa, l+l_hz, l+l_k, l+l_khz, l+l_km, l+l_logp, &
             l+l_m, l+l_maf, l+l_mafs, l+l_mb, l+l_meters, l+l_mhz, &
             l+l_mif, l+l_mifs, l+l_minutes, l+l_orbits, l+l_pa, l+l_ppbv, &
             l+l_ppmv, l+l_pptv, l+l_rad, l+l_radians, l+l_s, l+l_seconds, &
             l+l_thz, l+l_vmr, l+l_zeta, n+n_dt_def /) )

    ! Define the relations between specs and fields, and the field types
    ! or names of other specifications allowed.  These are represented by
    ! trees of the form
    !  < n_spec_def s_spec_name
    !               < n_field_type f_field_name t_type ... t_type > ...
    !               < n_field_spec f_field_name s_spec ... s_spec > ...
    !               < n_dot f_field_name s_spec f_field_name ... >
    !  >
    ! The n_field_type, n_field_spec, and n_dot subtrees may appear in
    ! any quantity or order.
    ! The n_field_type subtree indicates the type allowed for a field.
    ! The n_field_spec subtree indicates the specifications whose names
    ! are allowed to appear for a field.
    ! The n_dot subtree indicates that the field given by the first
    ! f_field_name  is required to be of the form spec_name.field_name,
    ! where spec_name is required to be a label of a specification of the
    ! type given by the s_spec son, and field_name is required to be
    ! present in the field given by the last f_field_name, which is
    ! required to be in a specification named by the next-to-last
    ! f_field_name ... of the specification named by the spec_name.

    CALL make_tree ( (/ &
      begin, s+s_spaceMIFs, &
             begin, f+f_mifs, t+t_numeric_range, t+t_numeric, n+n_field_type, &
             begin, f+f_use, t+t_use, n+n_field_type, &
             begin, f+f_module, s+s_module, n+n_field_type, &
             nadp+n_spec_def /) )

    CALL make_tree ( (/ &
      begin, s+s_targetMIFs, &
             begin, f+f_mifs, t+t_numeric_range, t+t_numeric, nr+n_field_type, &
             begin, f+f_use, t+t_use, nr+n_field_type, &
             begin, f+f_module, s+s_module, nr+n_field_type, &
             begin, f+f_secondary, t+t_boolean, n+n_field_type, &
             ndp+n_spec_def /) )

    CALL make_tree ( (/ &
      begin, s+s_limbMIFs, &
             begin, f+f_mifs, t+t_numeric_range, t+t_numeric, n+n_field_type, &
             begin, f+f_use, t+t_use, n+n_field_type, &
             begin, f+f_module, s+s_module, n+n_field_type, &
             nadp+n_spec_def /) )

    CALL make_tree ( (/ &
      begin, s+s_discardMIFs, &
             begin, f+f_mifs, t+t_numeric_range, t+t_numeric, n+n_field_type, &
             begin, f+f_use, t+t_use, n+n_field_type, &
             begin, f+f_module, s+s_module, n+n_field_type, &
             nadp+n_spec_def /) )

    CALL make_tree ( (/ &
      begin, s+s_markchanbad, &
             begin, f+f_chan, t+t_numeric, nr+n_field_type, &
             begin, f+f_bandno, t+t_numeric, nr+n_field_type, &
             begin, f+f_yrdoy, t+t_numeric, n+n_field_type, &
             ndp+n_spec_def /) )

    CALL make_tree ( (/ &
      begin, s+s_disableradout, &
             begin, f+f_bandno, t+t_numeric_range, t+t_numeric, &
             n+n_field_type, nadp+n_spec_def /) )

    CALL make_tree ( (/ &
      begin, s+s_subtractbinnedbaseline, &
             begin, f+f_bandno, t+t_numeric, n+n_field_type, &
             nadp+n_spec_def /) )

    CALL make_tree ( (/ &
      begin, s+s_chi2err, &
             begin, f+f_bandno, t+t_numeric_range, t+t_numeric, n+n_field_type,&
             nadp+n_spec_def /) )

    ! Define the relations between sections and specs.  These are
    ! represented by trees of the form
    !  < n_section section_name
    !              < n_name_def p_parameter t_type ... t_type > ...
    !  > or
    !  < n_section section_name s_spec ... s_spec >

    ! Shouldn't more of these be required (i.e., nr+n_name_def)?
    CALL make_tree ( (/ &
      begin, z+z_globalsettings, &
             begin, p+p_output_version_string, t+t_string, n+n_name_def, &
             begin, p+p_produce_l1boa, t+t_boolean, n+n_name_def, &
             begin, p+p_simoa, t+t_boolean, n+n_name_def, &
             n+n_section, &
      begin, z+z_calibration, &
             begin, p+p_calwindow, t+t_numeric, n+n_name_def, &
             begin, p+p_MAFexpandNum, t+t_numeric, n+n_name_def, &
             begin, p+p_MaxDataGaps, t+t_numeric, nr+n_name_def, &
	     begin, p+p_MaxErroneousCounterMAFs, t+t_numeric, nr+n_name_def, &
	     begin, p+p_DiffBeginEndEng, t+t_numeric, nr+n_name_def, &
             begin, p+p_MinSpaceLimbs, t+t_numeric, n+n_name_def, &
             begin, p+p_GHzSpaceTemp, t+t_numeric, n+n_name_def, &
             begin, p+p_GHzTargetTemp, t+t_numeric, n+n_name_def, &
             begin, p+p_THzSpaceTemp, t+t_numeric, n+n_name_def, &
             begin, p+p_THzTargetTemp, t+t_numeric, n+n_name_def, &
             begin, p+p_THzSpaceAngle, t+t_numeric, n+n_name_def, &
             begin, p+p_THzMaxBias, t+t_numeric, n+n_name_def, &
             begin, p+p_MoonToSpaceAngle, t+t_numeric, n+n_name_def, &
             begin, p+p_dacswindow, t+t_numeric, n+n_name_def, &
             begin, p+p_mif_duration, t+t_numeric, n+n_name_def, &
             begin, p+p_mif_dead_time, t+t_numeric, n+n_name_def, &
             begin, p+p_mifspermaf, t+t_numeric, n+n_name_def, &
             begin, p+p_usedefaultgains, t+t_boolean, n+n_name_def, &
             begin, p+p_UseAntOffsets, t+t_boolean, n+n_name_def, &
             begin, p+p_TPdigital, t+t_boolean, n+n_name_def, &
             begin, p+p_calibDACS, t+t_boolean, n+n_name_def, &
             begin, p+p_THzColdCal, t+t_boolean, n+n_name_def, &
             begin, p+p_Do_Slimb, t+t_boolean, n+n_name_def, &
             s+s_spaceMIFs, s+s_targetMIFs, s+s_limbMIFS, s+s_discardMIFs, &
             s+s_markchanbad, s+s_brightobject, n+n_section, &
      begin, z+z_output, &
             begin, p+p_removebaseline, t+t_boolean, n+n_name_def, &
             begin, p+p_DeconvolveDACS, t+t_boolean, n+n_name_def, &
             s+s_subtractbinnedbaseline, s+s_chi2err, s+s_disableradout, &
             n+n_section/) )

  END SUBROUTINE INIT_TABLES
    
  ! --------------------------------------------------  MAKE_TREE  -----
  INCLUDE "make_tree.f9h"

  LOGICAL FUNCTION not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (len=*), PARAMETER :: IdParm = &
       "$Id: init_tables_module.f90,v 2.33 2016/05/10 20:42:30 mmadatya Exp $"
  CHARACTER (len=LEN(idParm)), SAVE :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  END FUNCTION not_used_here
END MODULE INIT_TABLES_MODULE
  
! $Log: init_tables_module.f90,v $
! Revision 2.33  2016/05/10 20:42:30  mmadatya
! To get the error-checking parameters from the l1 configuration file instead of them being hard-coded into the source code
!
! Revision 2.32  2008/03/04 19:59:55  perun
! Add optional YRDOY field to MarkChanBad entry.
!
! Revision 2.31  2008/01/15 19:53:33  perun
! Add DisableRadOut to disable outputting unwanted bands.
!
! Revision 1.1  2008/01/15 19:49:11  perun
! Initial revision
!
! Revision 2.30  2007/02/09 15:04:26  perun
! Added Do_Slimb flag
!
! Revision 2.29  2006/09/28 16:15:01  perun
! Remove WriteDiagOffsets
!
! Revision 2.28  2006/08/02 18:54:31  perun
! Added SubtractBinnedBaseline field
!
! Revision 2.27  2006/06/14 13:45:27  perun
! Add TPdigital parameter
!
! Revision 2.26  2006/04/05 18:09:17  perun
! Remove unused variables
!
! Revision 2.25  2006/03/24 15:07:48  perun
! Add MAFexpandNum, MinSpaceLimbs, THzColdCal, WriteDiagOffsets and remove Switch
!
! Revision 2.24  2005/12/06 19:23:25  perun
! Removed MoonToLimbAngles fields and added Bright Object fields
!
! Revision 2.23  2005/10/10 19:05:32  perun
! Add DeconvolveDACS field
!
! Revision 2.22  2005/06/23 18:41:35  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.21  2005/05/02 16:03:27  perun
! Added UseAntOffsets field
!
! Revision 2.20  2005/01/28 16:58:47  perun
! Split MoonToLimbAngle into GHz and THz
!
! Revision 2.19  2004/12/01 17:09:38  perun
! Remove VersionComment and add DACSwindow
!
! Revision 2.18  2004/11/10 15:39:37  perun
! Add MarkChandBad user input
!
! Revision 2.17  2004/08/12 13:51:51  perun
! Version 1.44 commit
!
! Revision 2.16  2004/05/14 15:59:11  perun
! Version 1.43 commit
!
! Revision 2.15  2004/01/09 17:46:23  perun
! Version 1.4 commit
!
! Revision 2.14  2003/08/15 14:25:04  perun
! Version 1.2 commit
!
! Revision 2.13  2002/11/14 16:49:57  perun
! Split space & target temps between GHz & THz
!
! Revision 2.12  2002/11/07 21:34:42  jdone
! Added HDF4/HDF5 switch.
!
! Revision 2.11  2002/03/29 20:18:34  perun
! Version 1.0 commit
!
! Revision 2.9  2001/04/05 14:43:56  perun
! Another change to init_MLSSignals
!
! Revision 2.8  2001/03/16 15:13:47  perun
! Another change in call to Init_MLSSignals
!
! Revision 2.7  2001/03/14 15:59:27  perun
! Use Van's latest with Init_MLSSignals_m module
!
! Revision 2.6  2001/03/05 16:46:37  perun
! Use Van's include method
!
! Revision 2.5  2001/02/23 19:05:40  perun
! *** empty log message ***
!
! Revision 2.1  2001/02/23 18:57:58  perun
! Version 0.5 commit
!
@


2.33
log
@To get the error-checking parameters from the l1 configuration file instead of them being hard-coded into the source code
@
text
@d339 1
d349 3
a351 3
             begin, p+p_MaxDataGaps, t+t_numeric, n+n_name_def, &
	     begin, p+p_MaxErroneousCounterMAFs, t+t_numeric, n+n_name_def, &
	     begin, p+p_DiffBeginEndEng, t+t_numeric, n+n_name_def, &
d386 1
a386 1
       "$Id: init_tables_module.f90,v 2.32 2008/03/04 19:59:55 perun Exp $"
d394 3
@


2.32
log
@Add optional YRDOY field to MarkChanBad entry.
@
text
@d96 4
a99 1
  INTEGER, PARAMETER :: P_USEDEFAULTGAINS = p_MAFexpandNum + 1
d177 5
a181 2
    parm_indices(p_calwindow)=              add_ident ( 'CalWindow' )
    parm_indices(p_MAFexpandNum)=           add_ident ( 'MAFexpandNum' )
d348 3
d385 1
a385 1
       "$Id: init_tables_module.f90,v 2.31 2008/01/15 19:53:33 perun Exp $"
d393 3
@


2.31
log
@Add DisableRadOut to disable outputting unwanted bands.
@
text
@d55 2
a56 1
  INTEGER, PARAMETER :: FIELD_LAST = f_chan + 1
d170 1
d306 4
a309 3
             begin, f+f_chan, t+t_numeric, n+n_field_type, &
             begin, f+f_bandno, t+t_numeric, n+n_field_type, &
             nadp+n_spec_def /) )
d376 1
a376 1
       "$Id: init_tables_module.f90,v 1.1 2008/01/15 19:49:11 perun Exp $"
d384 3
@


2.30
log
@Added Do_Slimb flag
@
text
@d79 2
a80 1
  INTEGER, PARAMETER :: S_SUBTRACTBINNEDBASELINE = s_markchanbad + 1
d212 1
d309 5
d362 2
a363 1
             s+s_subtractbinnedbaseline, s+s_chi2err, n+n_section/) )
d373 1
a373 1
       "$Id: init_tables_module.f90,v 2.29 2006/09/28 16:15:01 perun Exp $"
d381 6
@


2.29
log
@Remove WriteDiagOffsets
@
text
@d111 1
d115 1
a115 1
  INTEGER, PARAMETER :: P_REMOVEBASELINE = P_MinSpaceLimbs + 1
d193 1
d349 1
d365 1
a365 1
       "$Id: init_tables_module.f90,v 2.28 2006/08/02 18:54:31 perun Exp $"
d373 3
@


2.28
log
@Added SubtractBinnedBaseline field
@
text
@a115 1
  INTEGER, PARAMETER :: P_WriteDiagOffsets = P_DeconvolveDACS + 1
d118 1
a118 1
  INTEGER, PARAMETER :: LAST_PARM = P_WriteDiagOffsets
a193 1
    parm_indices(p_WriteDiagOffsets)=       add_ident ( 'WriteDiagOffsets' )
a351 1
             begin, p+p_WriteDiagOffsets, t+t_boolean, n+n_name_def, &
d362 1
a362 1
       "$Id: init_tables_module.f90,v 2.27 2006/06/14 13:45:27 perun Exp $"
d370 3
a414 40
! $Log: init_tables_module.f90,v $
! Revision 2.27  2006/06/14 13:45:27  perun
! Add TPdigital parameter
!
! Revision 2.26  2006/04/05 18:09:17  perun
! Remove unused variables
!
! Revision 2.25  2006/03/24 15:07:48  perun
! Add MAFexpandNum, MinSpaceLimbs, THzColdCal, WriteDiagOffsets and remove Switch
!
! Revision 2.24  2005/12/06 19:23:25  perun
! Removed MoonToLimbAngles fields and added Bright Object fields
!
! Revision 2.23  2005/10/10 19:05:32  perun
! Add DeconvolveDACS field
!
! Revision 2.22  2005/06/23 18:41:35  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.21  2005/05/02 16:03:27  perun
! Added UseAntOffsets field
!
! Revision 2.20  2005/01/28 16:58:47  perun
! Split MoonToLimbAngle into GHz and THz
!
! Revision 2.19  2004/12/01 17:09:38  perun
! Remove VersionComment and add DACSwindow
!
! Revision 2.18  2004/11/10 15:39:37  perun
! Add MarkChandBad user input
!
! Revision 2.17  2004/08/12 13:51:51  perun
! Version 1.44 commit
!
! Revision 2.16  2004/05/14 15:59:11  perun
! Version 1.43 commit
!
! Revision 2.14  2003/08/15 14:25:04  perun
! Version 1.2 commit
!
@


2.27
log
@Add TPdigital parameter
@
text
@d79 2
a80 1
  INTEGER, PARAMETER :: SPEC_LAST = s_markchanbad
d211 2
d307 5
d355 1
a355 1
             s+s_chi2err, n+n_section/) )
d365 1
a365 1
       "$Id: init_tables_module.f90,v 2.26 2006/04/05 18:09:17 perun Exp $"
d373 3
d416 3
@


2.26
log
@Remove unused variables
@
text
@d107 2
a108 1
  INTEGER, PARAMETER :: P_UseAntOffsets = p_DACSWINDOW + 1
d191 1
d338 1
d357 1
a357 1
       "$Id: init_tables_module.f90,v 2.25 2006/03/24 15:07:48 perun Exp $"
d365 3
d405 3
@


2.25
log
@Add MAFexpandNum, MinSpaceLimbs, THzColdCal, WriteDiagOffsets and remove Switch
@
text
@d138 2
a139 2
    USE TREE_TYPES, ONLY: N_DOT, N_DT_DEF, N_FIELD_SPEC, N_FIELD_TYPE, &
         N_NAME_DEF, N_SECTION, N_SPEC_DEF, N_PLUS
d354 1
a354 1
       "$Id: init_tables_module.f90,v 2.24 2005/12/06 19:23:25 perun Exp $"
d362 3
d399 3
@


2.24
log
@Removed MoonToLimbAngles fields and added Bright Object fields
@
text
@d1 1
a1 1
! Copyright 2005, by the California Institute of Technology. ALL
d36 1
a36 1
  character (len=*), private, parameter :: ModuleName= &
d38 1
a38 1
  private :: not_used_here 
d53 1
a53 2
  INTEGER, PARAMETER :: F_S = f_secondary + 1
  INTEGER, PARAMETER :: F_BANDNO = f_s + 1
d77 1
a77 2
  INTEGER, PARAMETER :: S_SWITCH = s_discardMIFs + 1
  INTEGER, PARAMETER :: S_CHI2ERR = s_switch + 1
d92 2
a93 1
  INTEGER, PARAMETER :: P_USEDEFAULTGAINS = p_calwindow + 1
d100 2
a101 1
  INTEGER, PARAMETER :: P_MIF_DURATION = p_THzSpaceAngle + 1
d108 1
d112 1
a112 1
  INTEGER, PARAMETER :: P_REMOVEBASELINE = P_UseAntOffsets + 1
d114 1
d117 1
a117 1
  INTEGER, PARAMETER :: LAST_PARM = P_DECONVOLVEDACS
a131 1
!       , shape(section_ordering) )
a151 1
!    data_type_indices(t_module) =           add_ident ( 'module' )
a163 1
    field_indices(f_s) =                    add_ident ( 's' )
d170 2
d179 1
d192 1
a205 1
    spec_indices(s_switch) =                  add_ident ( 'switch' )
a295 6
      begin, s+s_switch, &
             begin, f+f_s, t+t_numeric, n+n_field_type, &
             begin, f+f_bandno, t+t_numeric, n+n_field_type, &
             nadp+n_spec_def /) )

    CALL make_tree ( (/ &
d321 2
d337 1
d339 1
a339 1
             s+s_switch, s+s_markchanbad, s+s_brightobject, n+n_section, &
d343 1
d351 1
a351 1
  logical function not_used_here()
d353 3
a355 3
  character (len=*), parameter :: IdParm = &
       "$Id: init_tables_module.f90,v 2.23 2005/10/10 19:05:32 perun Exp $"
  character (len=len(idParm)), save :: Id = idParm
d358 1
a358 1
  end function not_used_here
d362 3
d396 3
@


2.23
log
@Add DeconvolveDACS field
@
text
@d28 1
d43 4
a46 5
  INTEGER, PUBLIC, PARAMETER :: T_USE            = last_signal_type+1
  INTEGER, PUBLIC, PARAMETER :: T_UNITS          = t_use+1
  INTEGER, PUBLIC, PARAMETER :: T_MODULE         = t_units+1
  INTEGER, PUBLIC, PARAMETER :: T_ENABLE         = t_module+1
  INTEGER, PUBLIC, PARAMETER :: T_LAST           = t_enable
d50 7
a56 7
  INTEGER, PUBLIC, PARAMETER :: F_MIFS = last_Signal_Field + 1
  INTEGER, PUBLIC, PARAMETER :: F_USE = f_mifs + 1
  INTEGER, PUBLIC, PARAMETER :: F_SECONDARY = f_use + 1
  INTEGER, PUBLIC, PARAMETER :: F_S = f_secondary + 1
  INTEGER, PUBLIC, PARAMETER :: F_BANDNO = f_s + 1
  INTEGER, PUBLIC, PARAMETER :: F_CHAN = f_bandno + 1
  INTEGER, PUBLIC, PARAMETER :: FIELD_LAST = f_chan + 1
d60 3
a62 3
  INTEGER, PUBLIC, PARAMETER :: L_MATCH   =  last_signal_lit + 1
  INTEGER, PUBLIC, PARAMETER :: L_OVERRIDE = l_match + 1
  INTEGER, PUBLIC, PARAMETER :: LAST_LIT =      l_override + 1
d66 4
a69 4
  INTEGER, PUBLIC, PARAMETER :: Z_GLOBALSETTINGS = 1
  INTEGER, PUBLIC, PARAMETER :: Z_CALIBRATION = Z_GLOBALSETTINGS + 1
  INTEGER, PUBLIC, PARAMETER :: Z_OUTPUT = Z_CALIBRATION + 1
  INTEGER, PUBLIC, PARAMETER :: SECTION_FIRST = z_globalSettings, &
d74 8
a81 8
  INTEGER, PUBLIC, PARAMETER :: S_SPACEMIFS = last_Signal_Spec + 1
  INTEGER, PUBLIC, PARAMETER :: S_TARGETMIFS = s_spaceMIFs + 1
  INTEGER, PUBLIC, PARAMETER :: S_LIMBMIFS = s_targetMIFs + 1
  INTEGER, PUBLIC, PARAMETER :: S_DISCARDMIFS = s_limbMIFs + 1
  INTEGER, PUBLIC, PARAMETER :: S_SWITCH = s_discardMIFs + 1
  INTEGER, PUBLIC, PARAMETER :: S_CHI2ERR = s_switch + 1
  INTEGER, PUBLIC, PARAMETER :: S_MARKCHANBAD = s_chi2err + 1
  INTEGER, PUBLIC, PARAMETER :: SPEC_LAST = s_markchanbad
d87 3
a89 3
  INTEGER, PUBLIC, PARAMETER :: P_OUTPUT_VERSION_STRING = spec_last + 1
  INTEGER, PUBLIC, PARAMETER :: P_PRODUCE_L1BOA = p_output_version_string + 1
  INTEGER, PUBLIC, PARAMETER :: P_SIMOA = p_produce_l1boa + 1
d93 15
a107 17
  INTEGER, PUBLIC, PARAMETER :: P_CALWINDOW = p_simoa + 1
  INTEGER, PUBLIC, PARAMETER :: P_USEDEFAULTGAINS = p_calwindow + 1
  INTEGER, PUBLIC, PARAMETER :: P_CALIBDACS = p_usedefaultgains + 1
  INTEGER, PUBLIC, PARAMETER :: P_GHZSPACETEMP = p_calibdacs + 1
  INTEGER, PUBLIC, PARAMETER :: P_GHZTARGETTEMP = p_GHzSpaceTemp + 1
  INTEGER, PUBLIC, PARAMETER :: P_THZSPACETEMP = p_GHzTargetTemp + 1
  INTEGER, PUBLIC, PARAMETER :: P_THZTARGETTEMP = p_THzSpaceTemp + 1
  INTEGER, PUBLIC, PARAMETER :: P_THZSpaceAngle = p_THzTargetTemp + 1
  INTEGER, PUBLIC, PARAMETER :: P_MIF_DURATION = p_THzSpaceAngle + 1
  INTEGER, PUBLIC, PARAMETER :: P_MIF_DEAD_TIME = p_mif_duration + 1
  INTEGER, PUBLIC, PARAMETER :: P_MIFsPerMAF = p_mif_dead_time + 1
  INTEGER, PUBLIC, PARAMETER :: P_THzMaxBias = p_MIFsPerMAF + 1
  INTEGER, PUBLIC, PARAMETER :: P_MoonToSpaceAngle = p_THzMaxBias + 1
  INTEGER, PUBLIC, PARAMETER :: P_MoonToLimbAngle_GHz = p_MoonToSpaceAngle + 1
  INTEGER, PUBLIC, PARAMETER :: P_MoonToLimbAngle_THz = p_MoonToLimbAngle_GHz + 1
  INTEGER, PUBLIC, PARAMETER :: P_DACSWINDOW = p_MoonToLimbAngle_THz + 1
  INTEGER, PUBLIC, PARAMETER :: P_UseAntOffsets = p_DACSWINDOW + 1
d111 2
a112 2
  INTEGER, PUBLIC, PARAMETER :: P_REMOVEBASELINE = P_UseAntOffsets + 1
  INTEGER, PUBLIC, PARAMETER :: P_DECONVOLVEDACS = P_RemoveBaseline + 1
d114 2
a115 2
  INTEGER, PUBLIC, PARAMETER :: FIRST_PARM = P_OUTPUT_VERSION_STRING
  INTEGER, PUBLIC, PARAMETER :: LAST_PARM = P_DECONVOLVEDACS
d119 1
a119 1
  INTEGER, PUBLIC, PARAMETER :: OK = 1, & ! NO = 0
d139 1
d151 1
a151 1
    data_type_indices(t_module) =           add_ident ( 'module' )
a186 2
    parm_indices(p_MoonToLimbAngle_GHz)=    add_ident ( 'MoonToLimbAngleGHz' )
    parm_indices(p_MoonToLimbAngle_THz)=    add_ident ( 'MoonToLimbAngleTHz' )
d207 9
a331 2
             begin, p+p_MoonToLimbAngle_GHz, t+t_numeric, n+n_name_def, &
             begin, p+p_MoonToLimbAngle_THz, t+t_numeric, n+n_name_def, &
d340 1
a340 1
             s+s_switch, s+s_markchanbad, n+n_section, &
d354 1
a354 1
       "$Id: init_tables_module.f90,v 2.22 2005/06/23 18:41:35 pwagner Exp $"
d362 3
d393 3
@


2.22
log
@Reworded Copyright statement, moved rcs id
@
text
@d36 1
a36 1
       "$RCSfile: $"
d114 1
d117 1
a117 1
  INTEGER, PUBLIC, PARAMETER :: LAST_PARM = P_REMOVEBASELINE
d192 1
d339 1
d350 1
a350 1
       "$Id: $"
d358 3
d386 3
@


2.21
log
@Added UseAntOffsets field
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d34 4
a37 5
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (len=256), PRIVATE :: Id = &
       "$Id: init_tables_module.f90,v 2.20 2005/01/28 16:58:47 perun Exp $"
  CHARACTER (len=*), PRIVATE, PARAMETER :: ModuleName= &
       "$RCSfile: init_tables_module.f90,v $"
d344 8
d355 3
d380 3
@


2.20
log
@Split MoonToLimbAngle into GHz and THz
@
text
@d1 1
a1 1
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.19 2004/12/01 17:09:38 perun Exp $"
d102 1
d106 1
a106 1
  INTEGER, PUBLIC, PARAMETER :: P_REMOVEBASELINE = P_DACSWINDOW + 1
d183 1
d324 1
d340 3
d362 3
@


2.19
log
@Remove VersionComment and add DACSwindow
@
text
@d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.18 2004/11/10 15:39:37 perun Exp $"
d99 3
a101 2
  INTEGER, PUBLIC, PARAMETER :: P_MoonToLimbAngle = p_MoonToSpaceAngle + 1
  INTEGER, PUBLIC, PARAMETER :: P_DACSWINDOW = p_MoonToLimbAngle + 1
d179 2
a180 1
    parm_indices(p_MoonToLimbAngle)=        add_ident ( 'MoonToLimbAngle' )
d315 2
a316 1
             begin, p+p_MoonToLimbAngle, t+t_numeric, n+n_name_def, &
d337 3
d356 3
@


2.18
log
@Add MarkChandBad user input
@
text
@d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.17 2004/08/12 13:51:51 perun Exp $"
d81 1
a81 2
  INTEGER, PUBLIC, PARAMETER :: P_VERSION_COMMENT = p_output_version_string + 1
  INTEGER, PUBLIC, PARAMETER :: P_PRODUCE_L1BOA = p_version_comment + 1
d100 1
d104 1
a104 1
  INTEGER, PUBLIC, PARAMETER :: P_REMOVEBASELINE = P_MoonToLimbAngle + 1
a173 1
    parm_indices(p_version_comment) =       add_ident ( 'VersionComment' )
d179 1
a299 1
             begin, p+p_version_comment, t+t_string, n+n_name_def, &
d314 1
d334 3
d350 3
@


2.17
log
@Version 1.44 commit
@
text
@d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.16 2004/05/14 15:59:11 perun Exp $"
d48 2
a49 1
  INTEGER, PUBLIC, PARAMETER :: FIELD_LAST = f_bandno + 1
d73 2
a74 1
  INTEGER, PUBLIC, PARAMETER :: SPEC_LAST = s_chi2err
d157 1
d195 1
d281 6
d321 1
a321 1
             s+s_switch, n+n_section, &
d334 3
d347 3
@


2.16
log
@Version 1.43 commit
@
text
@d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.15 2004/01/09 17:46:23 perun Exp $"
d38 2
a39 1
  INTEGER, PUBLIC, PARAMETER :: T_LAST           = t_module
d48 1
a48 1
  INTEGER, PUBLIC, PARAMETER :: FIELD_LAST = f_bandno
d52 1
a52 1
  INTEGER, PUBLIC, PARAMETER :: L_MATCH   = last_signal_lit + 1
d54 1
a54 1
  INTEGER, PUBLIC, PARAMETER :: LAST_LIT = l_override
d71 2
a72 1
  INTEGER, PUBLIC, PARAMETER :: SPEC_LAST = s_switch
d191 1
d276 5
d314 1
a314 1
             n+n_section/) )
d324 3
d334 3
@


2.15
log
@Version 1.4 commit
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.14 2003/08/15 14:25:04 perun Exp $"
d95 2
d100 1
a100 1
  INTEGER, PUBLIC, PARAMETER :: P_REMOVEBASELINE = P_THzMaxBias + 1
d173 2
d295 2
d316 3
@


2.14
log
@Version 1.2 commit
@
text
@d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.13 2002/11/14 16:49:57 perun Exp $"
d90 2
a91 1
  INTEGER, PUBLIC, PARAMETER :: P_MIF_DURATION = p_THzTargetTemp + 1
d94 1
d98 1
a98 1
  INTEGER, PUBLIC, PARAMETER :: P_HDF_VERSION_STRING = P_MIFsPerMAF + 1
d101 1
a101 1
  INTEGER, PUBLIC, PARAMETER :: LAST_PARM = P_HDF_VERSION_STRING
d161 2
d169 2
a170 2
    parm_indices(p_simoa)=          add_ident ( 'SimOA' )
    parm_indices(p_hdf_version_string) =    add_ident ( 'HDFVersionString' )
d289 2
d299 1
a299 1
             begin, p+p_hdf_version_string, t+t_string, n+n_name_def, &
d310 3
d314 3
@


2.13
log
@Split space & target temps between GHz & THz
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.12 2002/11/07 21:34:42 jdone Exp $"
d79 1
d83 1
a83 1
  INTEGER, PUBLIC, PARAMETER :: P_CALWINDOW = p_produce_l1boa + 1
d165 1
d277 1
d304 3
a306 5
! Revision 2.12  2002/11/07 21:34:42  jdone
! Added HDF4/HDF5 switch.
!
! Revision 2.11  2002/03/29 20:18:34  perun
! Version 1.0 commit
a307 4
! Revision 2.10  2001/04/27 14:01:14  perun
! For the latest parser version.
!
! $Log: init_tables_module.f90,v $
@


2.12
log
@Added HDF4/HDF5 switch.
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.11 2002/03/29 20:18:34 perun Exp $"
d85 5
a89 3
  INTEGER, PUBLIC, PARAMETER :: P_SPACETEMP = p_calibdacs + 1
  INTEGER, PUBLIC, PARAMETER :: P_TARGETTEMP = p_spacetemp + 1
  INTEGER, PUBLIC, PARAMETER :: P_MIF_DURATION = p_targettemp + 1
d154 4
a157 2
    parm_indices(p_spacetemp)=              add_ident ( 'SpaceTemp' )
    parm_indices(p_targettemp)=             add_ident ( 'TargetTemp' )
d278 4
a281 2
             begin, p+p_spacetemp, t+t_numeric, n+n_name_def, &
             begin, p+p_targettemp, t+t_numeric, n+n_name_def, &
d301 3
d311 3
@


2.11
log
@Version 1.0 commit
@
text
@d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.10 2001/04/27 14:01:14 perun Exp $"
d58 2
a59 1
  INTEGER, PUBLIC, PARAMETER :: Z_CALIBRATION = 2
d61 1
a61 1
                                SECTION_LAST = z_Calibration
d91 4
d96 1
a96 1
  INTEGER, PUBLIC, PARAMETER :: LAST_PARM = P_MIFsPerMAF
d103 3
a105 2
! To: | globalSettings       |
!     |      Calibration     |
d107 4
a110 3
        (/OK,    0,  & ! Start
           0,   OK,  & ! GlobalSettings
           0,   OK/) & ! Calibration
d160 1
d166 1
d282 4
a285 1
             s+s_switch, n+n_section /) )
d295 3
d302 3
@


2.10
log
@For the latest parser version.
@
text
@d4 1
a4 1
module INIT_TABLES_MODULE
d12 1
a12 1
  use Init_MLSSignals_m ! Everything. Init_MLSSignals, Field_First,
d14 1
a14 1
  use INTRINSIC ! Everything. ADD_IDENT, BEGIN, D, F, FIRST_LIT,
d21 2
a22 2
  implicit NONE
  public ! This would be a MUCH LONGER list than the list of private
d24 1
a24 1
  private :: ADD_IDENT, INIT_INTRINSIC, MAKE_TREE
d27 3
a29 3
  character (len=256), private :: Id = &
       "$Id: init_tables_module.f90,v 2.9 2001/04/05 14:43:56 perun Exp $"
  character (len=*), private, parameter :: ModuleName= &
d35 4
a38 3
  integer, public, parameter :: T_USE            = last_signal_type+1
  integer, public, parameter :: T_UNITS          = t_use+1
  integer, public, parameter :: T_LAST           = t_units
d42 6
a47 3
  integer, public, parameter :: F_MIFS = last_Signal_Field + 1
  integer, public, parameter :: F_USE = f_mifs + 1
  integer, public, parameter :: FIELD_LAST = f_use
d51 3
a53 4
  integer, public, parameter :: L_EXPECTED   = last_signal_lit + 1
  integer, public, parameter :: L_MASK = l_expected + 1
  integer, public, parameter :: L_OVERRIDE = l_mask + 1
  integer, public, parameter :: LAST_LIT = l_override
d57 3
a59 3
  integer, public, parameter :: Z_GLOBALSETTINGS = 1
  integer, public, parameter :: Z_CALIBRATION = 2
  integer, public, parameter :: SECTION_FIRST = z_globalSettings, &
d64 6
a69 3
  integer, public, parameter :: S_SPACEMIFS = last_Signal_Spec + 1
  integer, public, parameter :: S_TARGETMIFS = s_spacemifs + 1
  integer, public, parameter :: SPEC_LAST = s_targetMIFs
d75 3
a77 2
  integer, public, parameter :: P_OUTPUT_VERSION_STRING = spec_last + 1
  integer, public, parameter :: P_VERSION_COMMENT = p_output_version_string +1
d81 8
a88 1
  integer, public, parameter :: P_CALWINDOW = p_version_comment + 1
d90 2
a91 2
  integer, public, parameter :: FIRST_PARM = P_OUTPUT_VERSION_STRING
  integer, public, parameter :: LAST_PARM = P_CALWINDOW
d95 1
a95 1
  integer, public, parameter :: OK = 1, & ! NO = 0
d97 1
a97 1
                     section_first-1:section_last) = reshape( &
d107 1
a107 1
contains ! =====     Public procedures     =============================
d109 1
a109 1
  subroutine INIT_TABLES
d111 1
a111 1
    use TREE_TYPES, only: N_DOT, N_DT_DEF, N_FIELD_SPEC, N_FIELD_TYPE, &
d116 1
a116 1
     call init_MLSSignals ( t_last, field_last, last_lit, &
d124 1
d129 1
a129 2
    lit_indices(l_expected) =                add_ident ( 'expected' )
    lit_indices(l_mask) =                    add_ident ( 'mask' )
d136 3
d143 7
d152 1
d163 3
d183 3
a185 2
    call make_tree ( (/ &
      begin, t+t_use, l+l_expected, l+l_mask, l+l_override, n+n_dt_def, &
d215 1
a215 1
    call make_tree ( (/ &
d219 1
d222 1
a222 1
    call make_tree ( (/ &
d224 15
d241 7
d257 1
a257 1
    call make_tree ( (/ &
d261 1
d265 9
a273 1
             s+s_spaceMIFs, s+s_targetMIFs, n+n_section /) )
d275 1
a275 1
  end subroutine INIT_TABLES
d278 1
a278 3
  include "make_tree.f9h"

end module INIT_TABLES_MODULE    
d280 6
@


2.9
log
@Another change to init_MLSSignals
@
text
@d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.8 2001/03/16 15:13:47 perun Exp $"
a37 1
  integer, public :: DATA_TYPE_INDICES(t_first:t_last)
a43 1
  integer, public :: FIELD_INDICES(field_first:field_last)
a50 1
  integer, public :: LIT_INDICES(first_lit:last_lit)
a57 1
  integer, public :: SECTION_INDICES(section_first:section_last)
a63 1
  integer, public :: SPEC_INDICES(spec_first:spec_last)
a77 1
  integer, public :: PARM_INDICES(first_parm:last_parm)
d102 2
a103 2
    call init_MLSSignals (Data_Type_Indices, Field_Indices, Lit_Indices, &
    & Parm_Indices, Section_Indices, Spec_Indices)
d222 3
@


2.8
log
@Another change in call to Init_MLSSignals
@
text
@d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.7 2001/03/14 15:59:27 perun Exp $"
d35 1
a35 1
  integer, public, parameter :: T_USE            = t_last_signal+1
a106 1
    call init_intrinsic ( data_type_indices, lit_indices )
d108 2
a109 2
    call init_MLSSignals (data_type_indices, field_indices, lit_indices, &
      & spec_indices )
d228 3
@


2.7
log
@Use Van's latest with Init_MLSSignals_m module
@
text
@d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.6 2001/03/05 16:46:37 perun Exp $"
d35 1
a35 1
  integer, public, parameter :: T_USE            = t_last_intrinsic+1
d49 1
a49 1
  integer, public, parameter :: L_EXPECTED   = last_intrinsic_lit + 1
d108 3
a110 1
    call init_MLSSignals ( field_indices, spec_indices, data_type_indices )
d229 3
@


2.6
log
@Use Van's include method
@
text
@d12 8
a19 5
  use INTRINSIC ! Everything. FIRST_LIT, INIT_INTRINSIC,
    ! L_FALSE, L_TRUE, LAST_INTRINSIC_LIT, T_BOOLEAN, T_FIRST,
    ! T_LAST_INTRINSIC, T_NUMERIC, T_NUMERIC_RANGE and T_STRING are used
    ! here, but everything is included so that it can be gotten by
    ! USE INIT_TABLES_MODULE.
d28 1
a28 1
       "$Id: init_tables_module.f90,v 2.5 2001/02/23 19:05:40 perun Exp $"
d42 3
a44 3
  integer, public, parameter :: F_MIFS = 1
  integer, public, parameter :: F_USE = 2
  integer, public, parameter :: FIELD_FIRST = f_mifs, FIELD_LAST = f_use
d55 15
d74 2
a75 2
  integer, public, parameter :: P_OUTPUT_VERSION_STRING = 1
  integer, public, parameter :: P_VERSION_COMMENT = 2
d79 1
a79 1
  integer, public, parameter :: P_CALWINDOW = 3
a84 16
! Section identities:

  integer, public, parameter :: Z_GLOBALSETTINGS = 1
  integer, public, parameter :: Z_CALIBRATION = 2
  integer, public, parameter :: SECTION_FIRST = z_globalSettings, &
                                SECTION_LAST = z_Calibration
  integer, public :: SECTION_INDICES(section_first:section_last)

! Specification indices:

  integer, public, parameter :: S_SPACEMIFS = 1
  integer, public, parameter :: S_TARGETMIFS = 2
  integer, public, parameter :: SPEC_FIRST = s_spaceMIFs, &
       SPEC_LAST = s_targetMIFs
  integer, public :: SPEC_INDICES(spec_first:spec_last)

a98 10
  integer, private, parameter :: BEGIN = -1
  integer, private, parameter :: D = 1000000
  integer, private, parameter :: F = 1000, L = 2000, N = 0
  integer, private, parameter :: NADP = n+d*(all_fields+no_dup+no_positional)
  integer, private, parameter :: ND = n+d*no_dup
  integer, private, parameter :: NDP = n+d*(no_dup+no_positional)
  integer, private, parameter :: NP = n+d*no_positional
  integer, private, parameter :: NR = n+d*req_fld
  integer, private, parameter :: P = 3000, S = 4000, T = 5000, Z = 6000

d108 1
a157 7
    ! Define the intrinsic data types

    call make_tree ( (/ &
      begin, t+t_numeric, n+n_dt_def, &
      begin, t+t_numeric_range, n+n_dt_def, &
      begin, t+t_string, n+n_dt_def /) )

a160 1
      begin, t+t_boolean, l+l_true, l+l_false, n+n_dt_def, &
a219 12

! =====     Private procedures     =====================================
  ! --------------------------------------------------  ADD_IDENT  -----

  integer function ADD_IDENT ( TEXT )

    use SYMBOL_TABLE, only: ENTER_TERMINAL 
    use SYMBOL_TYPES, only: T_IDENTIFIER

    character(len=*), intent(in) :: TEXT
    add_ident = enter_terminal ( text, t_identifier )
  end function ADD_IDENT
d227 3
@


2.5
log
@*** empty log message ***
@
text
@a16 5
  use SYMBOL_TABLE, only: ENTER_TERMINAL
  use SYMBOL_TYPES, only: T_IDENTIFIER
  use TREE, only: BUILD_TREE, PUSH_PSEUDO_TERMINAL
  use TREE_TYPES, only: N_DOT, N_DT_DEF, N_FIELD_SPEC, N_FIELD_TYPE, &
                        N_NAME_DEF, N_SECTION, N_SPEC_DEF, N_PLUS
d21 1
a21 4
  private :: ADD_IDENT, BUILD_TREE, ENTER_TERMINAL, INIT_INTRINSIC
  private :: MAKE_TREE, N_DOT, N_DT_DEF, N_FIELD_SPEC, N_FIELD_TYPE
  private :: N_NAME_DEF, N_SECTION, N_SPEC_DEF, PUSH_PSEUDO_TERMINAL
  private :: T_IDENTIFIER
d25 1
a25 1
       "$Id: Init_tables_module.f90,v 2.1 2001/02/23 18:57:58 perun Exp $"
d27 1
a27 1
       "$RCSfile: Init_tables_module.f90,v $"
d110 4
d237 3
a239 56
  ! --------------------------------------------------  MAKE_TREE  -----
  subroutine MAKE_TREE ( IDS )
  ! Build a tree specified by the "ids" array.  "begin" marks the
  ! beginning of a tree.  A tree-node marks the end of the corresponding
  ! tree.  Pseudo-terminals are decorated with their indices.
    integer, intent(in) :: IDS(:)

    integer, save :: CALLNO = 0    ! Which call to Make_Tree -- for error msg.
    integer :: DECOR, I, ID, M, N_IDS, STACK(0:30), STRING, WHICH

    callno = callno + 1
    n_ids = size(ids)
    m = 0
    stack(0) = 0 ! just so it's defined, in case it gets incremented
                 ! after build_tree
    if ( ids(1) >= 0 ) then
      m = 1
      stack(1) = 0
    end if
    do i = 1, n_ids
      if ( ids(i) == begin ) then
        m = m + 1
        stack(m) = 0
      else
        id = mod(ids(i), 1000)
        which = mod(ids(i) / 1000, 1000)
        decor = ids(i) / 1000000
       select case ( which )
       case ( f/1000 ) ! Fields
         string = field_indices(id)
       case ( l/1000 ) ! Enumeration literals
         string = lit_indices(id)
       case ( p/1000 ) ! Parameter names
         string = parm_indices(id)
       case ( s/1000 ) ! Specs
         string = spec_indices(id)
       case ( t/1000 ) ! Intrinsic data types
         string = data_type_indices(id)
       case ( z/1000 ) ! Sections
         string = section_indices(id)
       case ( n/1000 ) ! Tree nodes
         call build_tree ( id, stack(m), decor )
         m = m - 1
         stack(m) = stack(m) + 1
    cycle
       end select
       if ( string == 0 ) then
         print *, 'INIT_TABLES_MODULE%MAKE_TREE-E- The string for element ', &
           & i, ' of a list'
         print *, 'is undefined.  Detected on call ', callno, ' to Make_Tree.'
         stop
       end if
       call push_pseudo_terminal ( string, 0, decor = id )
       stack(m) = stack(m) + 1
      end if
    end do
d241 2
a242 1
  end subroutine MAKE_TREE
a243 1
  integer function ADD_IDENT ( TEXT )
d247 3
d251 1
a251 1
end module INIT_TABLES_MODULE
d253 4
a256 1
! $Log: Init_tables_module.f90,v $
@


2.4
log
@Not needed with level 1
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d12 2
a13 2
  use INTRINSIC ! Everything. FIRST_LIT, FIRST_MOLECULE, INIT_INTRINSIC,
    ! L_<several>, LAST_INTRINSIC_LIT, LAST_MOLECULE, T_BOOLEAN, T_FIRST,
d21 1
a21 1
                        N_NAME_DEF, N_SECTION, N_SPEC_DEF
d33 1
a33 1
       "$Id: init_tables_module.f90,v 2.3 2001/02/12 17:51:47 pwagner Exp $"
d35 1
a35 1
       "$RCSfile: init_tables_module.f90,v $"
d39 4
a42 19
  integer, public, parameter :: T_APRIORISOURCE  = t_last_intrinsic+1
  integer, public, parameter :: T_APRIORITYPE    = t_apriorisource+1
  integer, public, parameter :: T_CRITICALMODULE = t_aprioritype+1
  integer, public, parameter :: T_HGRIDTYPE      = t_criticalmodule+1
  integer, public, parameter :: T_MATRIX         = t_hgridtype+1
  integer, public, parameter :: T_MERGEMETHOD    = t_matrix+1
  integer, public, parameter :: T_METHOD         = t_mergemethod+1
  integer, public, parameter :: T_MERGESOURCE    = t_method+1
  integer, public, parameter :: T_MODULE         = t_mergesource+1
  integer, public, parameter :: T_MOLECULE       = t_module+1
  integer, public, parameter :: T_OUTPUTTYPE     = t_molecule+1
  integer, public, parameter :: T_QUANTITYTYPE   = t_outputtype+1
  integer, public, parameter :: T_RADIOMETER     = t_quantitytype+1
  integer, public, parameter :: T_SCALE          = t_radiometer+1
  integer, public, parameter :: T_SPECIES        = t_scale+1
  integer, public, parameter :: T_UNITS          = t_species+1
  integer, public, parameter :: T_VGRIDCOORD     = t_units+1
  integer, public, parameter :: T_VGRIDTYPE      = t_vgridcoord+1
  integer, public, parameter :: T_LAST           = t_vgridtype
d44 1
d46 4
a49 63
  integer, public, parameter :: F_APRIORI             = 1
  integer, public, parameter :: F_APRIORISCALE        = F_APRIORI + 1
  integer, public, parameter :: F_AUTOFILL            = f_aprioriScale + 1
  integer, public, parameter :: F_BAND                = f_autofill + 1
  integer, public, parameter :: F_CHANNELS            = f_band + 1
  integer, public, parameter :: F_COLUMNS             = f_channels + 1
  integer, public, parameter :: F_COLUMNSCALE         = f_columns + 1
  integer, public, parameter :: F_COMPAREOVERLAPS     = f_columnscale + 1
  integer, public, parameter :: F_COORDINATE          = f_compareOverlaps + 1
  integer, public, parameter :: F_COPY                = f_coordinate + 1
  integer, public, parameter :: F_COVARIANCE          = f_copy + 1
  integer, public, parameter :: F_CRITERIA            = f_covariance + 1
  integer, public, parameter :: F_DIAGONAL            = f_criteria + 1
  integer, public, parameter :: F_FILE                = f_diagonal + 1
  integer, public, parameter :: F_FIRSTINDEXCHANNEL   = f_file + 1
  integer, public, parameter :: F_FRACTION            = f_firstIndexChannel + 1
  integer, public, parameter :: F_FWDMODELIN          = f_fraction + 1
  integer, public, parameter :: F_FWDMODELOUT         = f_fwdModelIn + 1
  integer, public, parameter :: F_GPH                 = f_fwdModelOut + 1
  integer, public, parameter :: F_HDFNAME             = f_GPH + 1
  integer, public, parameter :: F_HEIGHT              = f_hdfname + 1
  integer, public, parameter :: F_HGRID               = f_height + 1
  integer, public, parameter :: F_INTERPOLATIONFACTOR = f_hGrid + 1
  integer, public, parameter :: F_JACOBIAN            = f_interpolationFactor + 1
  integer, public, parameter :: F_LENGTH              = f_jacobian + 1
  integer, public, parameter :: F_MAXITERATIONS       = f_length + 1
  integer, public, parameter :: F_MATRIX              = f_maxIterations + 1
  integer, public, parameter :: F_MEASUREMENTS        = f_matrix + 1
  integer, public, parameter :: F_METHOD              = f_measurements + 1
  integer, public, parameter :: F_MIF                 = f_method + 1
  integer, public, parameter :: F_MODULE              = f_MIF + 1
  integer, public, parameter :: F_MOLECULE            = f_module + 1 
  integer, public, parameter :: F_NUMBER              = f_molecule + 1
  integer, public, parameter :: F_OUTPUTCOVARIANCE    = f_number + 1
  integer, public, parameter :: F_OUTPUTOVERLAPS      = f_outputCovariance + 1
  integer, public, parameter :: F_OVERLAPS            = f_outputOverlaps + 1
  integer, public, parameter :: F_PER_DECADE          = f_overlaps + 1
  integer, public, parameter :: F_QUANTITIES          = f_per_decade + 1
  integer, public, parameter :: F_QUANTITY            = f_quantities + 1
  integer, public, parameter :: F_RADIOMETER          = f_quantity + 1
  integer, public, parameter :: F_RANGE               = f_radiometer + 1
  integer, public, parameter :: F_ROWS                = f_range + 1
  integer, public, parameter :: F_SCALE               = f_rows + 1
  integer, public, parameter :: F_SIGNALS             = f_scale + 1
  integer, public, parameter :: F_SOURCE              = f_signals + 1
  integer, public, parameter :: F_SPECIES             = f_source + 1
  integer, public, parameter :: F_START               = f_species + 1
  integer, public, parameter :: F_STATE               = f_start + 1
  integer, public, parameter :: F_STOP                = f_state + 1
  integer, public, parameter :: F_TEMPERATURE         = f_stop + 1
  integer, public, parameter :: F_TOLERANCEA          = f_temperature + 1
  integer, public, parameter :: F_TOLERANCEF          = f_tolerancea + 1
  integer, public, parameter :: F_TOLERANCER          = f_tolerancef + 1
  integer, public, parameter :: F_VERSIONRANGE        = f_tolerancer + 1
  integer, public, parameter :: F_TEMPLATE            = f_versionRange + 1
  integer, public, parameter :: F_TEST                = f_template + 1
  integer, public, parameter :: F_TYPE                = f_test + 1
  integer, public, parameter :: F_UNIT                = f_type + 1
  integer, public, parameter :: F_UNPACKOUTPUT        = f_unit + 1
  integer, public, parameter :: F_VALUES              = f_unpackOutput + 1
  integer, public, parameter :: F_VGRID               = f_values + 1
  integer, public, parameter :: F_WEIGHT              = f_vGrid + 1
  integer, public, parameter :: FIELD_FIRST = f_Apriori, FIELD_LAST = f_weight
d51 1
d54 4
a57 36
  integer, public, parameter :: L_ANGLE         = last_intrinsic_lit + 1
  integer, public, parameter :: L_APRIORI       = l_angle + 1
  integer, public, parameter :: L_BOTH 	        = l_apriori + 1
  integer, public, parameter :: L_CHOLESKY      = l_both + 1
  integer, public, parameter :: L_CLIMATOLOGY   = l_cholesky+1
  integer, public, parameter :: L_COVARIANCE    = l_climatology + 1
  integer, public, parameter :: L_DAO 	        = l_covariance + 1
  integer, public, parameter :: L_DIRECT        = l_dao + 1
  integer, public, parameter :: L_EITHER        = l_direct + 1
  integer, public, parameter :: L_EXPLICIT      = l_either + 1
  integer, public, parameter :: L_FIXED         = l_explicit + 1
  integer, public, parameter :: L_FRACTIONAL    = l_fixed + 1
  integer, public, parameter :: L_HEIGHT        = l_fractional + 1
  integer, public, parameter :: L_KRONECKER     = l_height + 1
  integer, public, parameter :: L_L2AUX         = l_kronecker + 1
  integer, public, parameter :: L_L2GP 	        = l_l2aux + 1
  integer, public, parameter :: L_LINEAR        = l_l2gp + 1
  integer, public, parameter :: L_LOGARITHMIC   = l_linear + 1
  integer, public, parameter :: L_NCEP 	        = l_logarithmic + 1
  integer, public, parameter :: L_NEITHER       = l_ncep + 1
  integer, public, parameter :: L_NEWTONIAN     = l_neither + 1
  integer, public, parameter :: L_NONE 	        = l_newtonian + 1
  integer, public, parameter :: L_NORM          = l_none + 1
  integer, public, parameter :: L_PLAIN         = l_norm + 1
  integer, public, parameter :: L_PRESSURE      = l_plain + 1
  integer, public, parameter :: L_R1A           = l_pressure + 1
  integer, public, parameter :: L_R1B           = l_r1a + 1
  integer, public, parameter :: L_R2            = l_r1b + 1
  integer, public, parameter :: L_R3            = l_r2 + 1
  integer, public, parameter :: L_R4            = l_r3 + 1
  integer, public, parameter :: L_R5H           = l_r4 + 1
  integer, public, parameter :: L_R5V           = l_r5h + 1
  integer, public, parameter :: L_SPD           = l_r5v + 1
  integer, public, parameter :: L_THETA         = l_spd + 1
  integer, public, parameter :: L_WEIGHTED      = l_theta + 1
  integer, public, parameter :: LAST_LIT        = l_weighted
d59 1
d61 1
d63 10
a72 16
  integer, public, parameter :: P_ALLOW_CLIMATOLOGY_OVERLOADS = 1
  integer, public, parameter :: P_INPUT_VERSION_STRING        = 2
  integer, public, parameter :: P_OUTPUT_VERSION_STRING       = 3
  integer, public, parameter :: P_VERSION_COMMENT             = 4
  ! In ChunkDivide section:
  integer, public, parameter :: P_CRITICAL_BANDS              = 5
  integer, public, parameter :: P_CRITICAL_SCANNING_MODULES   = 6
  integer, public, parameter :: P_HOME_GEOD_ANGLE             = 7
  integer, public, parameter :: P_HOME_MODULE                 = 8
  integer, public, parameter :: P_IDEAL_LENGTH                = 9
  integer, public, parameter :: P_MAX_GAP                     = 10
  integer, public, parameter :: P_OVERLAP                     = 11
  integer, public, parameter :: P_SCAN_LOWER_LIMIT            = 12
  integer, public, parameter :: P_SCAN_UPPER_LIMIT            = 13
  integer, public, parameter :: FIRST_PARM = P_ALLOW_CLIMATOLOGY_OVERLOADS
  integer, public, parameter :: LAST_PARM = P_SCAN_UPPER_LIMIT
d74 3
a76 5
! Section identities (indices are in the order the sections are allowed to
! appear):
  integer, public, parameter :: Z_CHUNKDIVIDE    = 4
  integer, public, parameter :: Z_CONSTRUCT      = 5
  integer, public, parameter :: Z_FILL           = 6
d78 1
a78 5
  integer, public, parameter :: Z_JOIN           = 8
  integer, public, parameter :: Z_MERGEAPRIORI   = 3
  integer, public, parameter :: Z_OUTPUT         = 9
  integer, public, parameter :: Z_READAPRIORI    = 2
  integer, public, parameter :: Z_RETRIEVE       = 7
d80 1
a80 1
                                SECTION_LAST = z_Output
d82 7
a88 22
! Specification indices don't overlap parameter indices, so a section can
! have both parameters and specifications:
  integer, public, parameter :: S_CLIMATOLOGY    = last_parm + 1
  integer, public, parameter :: S_CREATE         = s_climatology + 1
  integer, public, parameter :: S_FILL           = s_create + 1
  integer, public, parameter :: S_FORWARDMODEL   = s_fill + 1
  integer, public, parameter :: S_HGRID          = s_forwardModel + 1
  integer, public, parameter :: S_L2GP           = s_hgrid + 1
  integer, public, parameter :: S_L2AUX          = s_l2gp + 1
  integer, public, parameter :: S_MATRIX         = s_l2aux + 1
  integer, public, parameter :: S_MERGE          = s_matrix + 1
  integer, public, parameter :: S_OUTPUT         = s_merge + 1
  integer, public, parameter :: S_QUANTITY       = s_output + 1
  integer, public, parameter :: S_RETRIEVE       = s_quantity + 1
  integer, public, parameter :: S_SUBSET         = s_retrieve + 1
  integer, public, parameter :: S_TEMPLATE       = s_subset + 1
  integer, public, parameter :: S_TIME           = s_template + 1
  integer, public, parameter :: S_TPFILL         = s_time + 1
  integer, public, parameter :: S_VECTOR         = s_tpfill + 1
  integer, public, parameter :: S_VECTORTEMPLATE = s_vector + 1
  integer, public, parameter :: S_VGRID          = s_vectortemplate + 1
  integer, public, parameter :: SPEC_FIRST = s_Climatology, SPEC_LAST = s_vGrid
d92 1
d96 6
a101 14
! To: | globalSettings    chunkDivide       retrieve             |
!     |       readApriori       construct          join          |
!     |             mergeApriori       fill             output   |
! ====|==========================================================|== From: ==
        (/OK,    0,    0,    0,    0,    0,    0,    0,    0,  & ! Start
           0,   OK,    0,    0,    0,    0,    0,    0,    0,  & ! GlobalSettings
           0,    0,   OK,    0,    0,    0,    0,    0,    0,  & ! readApriori
           0,    0,    0,   OK,    0,    0,    0,    0,    0,  & ! mergeApriori
           0,    0,    0,    0,   OK,   OK,   OK,   OK,   OK,  & ! chunkDivide
           0,    0,    0,    0,   OK,   OK,   OK,   OK,   OK,  & ! Construct
           0,    0,    0,    0,   OK,   OK,   OK,   OK,   OK,  & ! Fill
           0,    0,    0,    0,   OK,   OK,   OK,   OK,   OK,  & ! Retrieve
           0,    0,    0,    0,    0,    0,    0,    0,   OK,  & ! Join
           0,    0,    0,    0,    0,    0,    0,    0,    0/) & ! Output
a104 2
  integer, private, parameter :: F = 1000, L = 2000, N = 0, P = 3000
  integer, private, parameter :: S = 4000, T = 5000, Z = 6000
d106 8
a117 2
    integer :: I ! used only in an array constructor as a DO index

d122 1
d124 4
a127 18
    data_type_indices(t_apriorisource) =   add_ident ( 'aprioriSource' )
    data_type_indices(t_aprioritype) =     add_ident ( 'aprioriType' )
    data_type_indices(t_criticalmodule) =  add_ident ( 'criticalModule' )
    data_type_indices(t_hgridtype) =       add_ident ( 'hGridType' )
    data_type_indices(t_matrix) =          add_ident ( 'matrixType' )
    data_type_indices(t_mergemethod) =     add_ident ( 'mergeMethod' )
    data_type_indices(t_method) =          add_ident ( 'method' )
    data_type_indices(t_mergesource) =     add_ident ( 'mergeSource' )
    data_type_indices(t_module) =          add_ident ( 'module' )
    data_type_indices(t_molecule) =        add_ident ( 'molecule' )
    data_type_indices(t_outputtype) =      add_ident ( 'outputType' )
    data_type_indices(t_quantitytype) =    add_ident ( 'quantityType' )
    data_type_indices(t_radiometer) =      add_ident ( 'radiometer' )
    data_type_indices(t_scale) =           add_ident ( 'scale' )
    data_type_indices(t_species) =         add_ident ( 'species' )
    data_type_indices(t_units) =           add_ident ( 'units' )
    data_type_indices(t_vgridcoord) =      add_ident ( 'vGridCoord' )
    data_type_indices(t_vgridtype) =       add_ident ( 'vGridType' )
d129 5
a133 35
    lit_indices(l_angle) =                 add_ident ( 'angle' )
    lit_indices(l_apriori) =               add_ident ( 'apriori' )
    lit_indices(l_both) =                  add_ident ( 'both' )
    lit_indices(l_cholesky) =              add_ident ( 'cholesky' )
    lit_indices(l_climatology) =           add_ident ( 'climatology' )
    lit_indices(l_covariance) =            add_ident ( 'covariance' )
    lit_indices(l_dao) =                   add_ident ( 'DAO' )
    lit_indices(l_direct) =                add_ident ( 'direct' )
    lit_indices(l_either) =                add_ident ( 'either' )
    lit_indices(l_explicit) =              add_ident ( 'explicit' )
    lit_indices(l_fixed) =                 add_ident ( 'fixed' )
    lit_indices(l_fractional) =            add_ident ( 'fractional' )
    lit_indices(l_height) =                add_ident ( 'height' )
    lit_indices(l_kronecker) =             add_ident ( 'kronecker' )
    lit_indices(l_l2aux) =                 add_ident ( 'l2aux' )
    lit_indices(l_l2gp) =                  add_ident ( 'l2gp' )
    lit_indices(l_linear) =                add_ident ( 'linear' )
    lit_indices(l_logarithmic) =           add_ident ( 'logarithmic' )
    lit_indices(l_ncep) =                  add_ident ( 'NCEP' )
    lit_indices(l_neither) =               add_ident ( 'neither' )
    lit_indices(l_newtonian) =             add_ident ( 'newtonian' )
    lit_indices(l_none) =                  add_ident ( 'none' )
    lit_indices(l_norm) =                  add_ident ( 'norm' )
    lit_indices(l_plain) =                 add_ident ( 'plain' )
    lit_indices(l_pressure) =              add_ident ( 'pressure' )
    lit_indices(l_r1a) =                   add_ident ( 'r1a' )
    lit_indices(l_r1b) =                   add_ident ( 'r1b' )
    lit_indices(l_r2) =                    add_ident ( 'r2' )
    lit_indices(l_r3) =                    add_ident ( 'r3' )
    lit_indices(l_r4) =                    add_ident ( 'r4' )
    lit_indices(l_r5h) =                   add_ident ( 'r5h' )
    lit_indices(l_r5v) =                   add_ident ( 'r5v' )
    lit_indices(l_spd) =                   add_ident ( 'spd' )
    lit_indices(l_theta) =                 add_ident ( 'theta' )
    lit_indices(l_weighted) =              add_ident ( 'weighted' )
d135 4
a138 62
    field_indices(f_apriori) =             add_ident ( 'apriori' )
    field_indices(f_aprioriscale) =        add_ident ( 'aprioriscale' )
    field_indices(f_autofill) =            add_ident ( 'autofill' )
    field_indices(f_band) =                add_ident ( 'band' )
    field_indices(f_channels) =            add_ident ( 'channels' )
    field_indices(f_columns) =             add_ident ( 'columns' )
    field_indices(f_columnscale) =         add_ident ( 'columnscale' )
    field_indices(f_compareOverlaps) =     add_ident ( 'compareoverlaps' )
    field_indices(f_coordinate) =          add_ident ( 'coordinate' )
    field_indices(f_copy) =                add_ident ( 'copy' )
    field_indices(f_covariance) =          add_ident ( 'covariance' )
    field_indices(f_criteria) =            add_ident ( 'criteria' )
    field_indices(f_diagonal) =            add_ident ( 'diagonal' )
    field_indices(f_file) =                add_ident ( 'file' )
    field_indices(f_firstIndexChannel) =   add_ident ( 'f_firstindexchannel' )
    field_indices(f_fraction) =            add_ident ( 'fraction' )
    field_indices(f_fwdModelIn) =          add_ident ( 'fwdmodelin' )
    field_indices(f_fwdModelOut) =         add_ident ( 'fwdmodelout' )
    field_indices(f_gph) =                 add_ident ( 'gph' )
    field_indices(f_hdfname) =             add_ident ( 'hdfname' )
    field_indices(f_height) =              add_ident ( 'height' )
    field_indices(f_hgrid) =               add_ident ( 'hgrid' )
    field_indices(f_interpolationFactor) = add_ident ( 'interpolationfactor' )
    field_indices(f_jacobian) =            add_ident ( 'jacobian' )
    field_indices(f_length) =              add_ident ( 'length' )
    field_indices(f_matrix) =              add_ident ( 'matrix' )
    field_indices(f_maxIterations) =       add_ident ( 'maxiterations' )
    field_indices(f_measurements) =        add_ident ( 'measurements' )
    field_indices(f_method) =              add_ident ( 'method' )
    field_indices(f_mif) =                 add_ident ( 'mif' )
    field_indices(f_module) =              add_ident ( 'module' )
    field_indices(f_molecule) =            add_ident ( 'molecule' )
    field_indices(f_number) =              add_ident ( 'number' )
    field_indices(f_outputCovariance) =    add_ident ( 'outputcovariance' )
    field_indices(f_outputOverlaps) =      add_ident ( 'outputoverlaps' )
    field_indices(f_overlaps) =            add_ident ( 'overlaps' )
    field_indices(f_per_decade) =          add_ident ( 'per_decade' )
    field_indices(f_quantities) =          add_ident ( 'quantities' )
    field_indices(f_quantity) =            add_ident ( 'quantity' )
    field_indices(f_radiometer) =          add_ident ( 'radiometer' )
    field_indices(f_range) =               add_ident ( 'range' )
    field_indices(f_rows) =                add_ident ( 'rows' )
    field_indices(f_scale) =               add_ident ( 'scale' )
    field_indices(f_signals) =             add_ident ( 'signals' )
    field_indices(f_source) =              add_ident ( 'source' )
    field_indices(f_species) =             add_ident ( 'species' )
    field_indices(f_start) =               add_ident ( 'start' )
    field_indices(f_state) =               add_ident ( 'state' )
    field_indices(f_stop) =                add_ident ( 'stop' )
    field_indices(f_temperature) =         add_ident ( 'temperature' )
    field_indices(f_tolerancea) =          add_ident ( 'Atolerance' )
    field_indices(f_tolerancef) =          add_ident ( 'Ftolerance' )
    field_indices(f_tolerancer) =          add_ident ( 'Rtolerance' )
    field_indices(f_versionRange) =        add_ident ( 'versionrange' )
    field_indices(f_template) =            add_ident ( 'template' )
    field_indices(f_test) =                add_ident ( 'test' )
    field_indices(f_type) =                add_ident ( 'type' )
    field_indices(f_unit) =                add_ident ( 'unit' )
    field_indices(f_unpackOutput) =        add_ident ( 'unpackoutput' )
    field_indices(f_values) =              add_ident ( 'values' )
    field_indices(f_vGrid) =               add_ident ( 'vgrid' )
    field_indices(f_weight) =              add_ident ( 'weight' )
d140 5
a144 15
    parm_indices(p_allow_climatology_overloads) = &
                                           add_ident ( 'AllowClimatologyOverloads' )
    parm_indices(p_input_version_string) = add_ident ( 'InputVersionString' )
    parm_indices(p_output_version_string) =add_ident ( 'OutputVersionString' )
    parm_indices(p_version_comment) =      add_ident ( 'VersionComment' )
    parm_indices(p_critical_bands) =       add_ident ( 'CriticalBands' )
    parm_indices(p_critical_scanning_modules) = &
                                           add_ident ( 'CriticalScanningModules' )
    parm_indices(p_home_geod_angle) =      add_ident ( 'HomeGeodAngle' )
    parm_indices(p_home_module) =          add_ident ( 'HomeModule' )
    parm_indices(p_ideal_length) =         add_ident ( 'IdealLength' )
    parm_indices(p_max_gap) =              add_ident ( 'MaxGap' )
    parm_indices(p_overlap) =              add_ident ( 'Overlap' )
    parm_indices(p_scan_lower_limit) =     add_ident ( 'ScanLowerLimit' )
    parm_indices(p_scan_upper_limit) =     add_ident ( 'ScanUpperLimit' )
d146 4
a149 9
    section_indices(z_chunkdivide) =       add_ident ( 'chunkdivide' )
    section_indices(z_construct) =         add_ident ( 'construct' )
    section_indices(z_fill) =              add_ident ( 'fill' )
    section_indices(z_globalsettings) =    add_ident ( 'globalsettings' )
    section_indices(z_join) =              add_ident ( 'join' )
    section_indices(z_mergeapriori) =      add_ident ( 'mergeapriori' )
    section_indices(z_output) =            add_ident ( 'output' )
    section_indices(z_readapriori) =       add_ident ( 'readapriori' )
    section_indices(z_retrieve) =          add_ident ( 'retrieve' )
d151 3
a153 19
    spec_indices(s_climatology) =          add_ident ( 'climatology' )
    spec_indices(s_create) =               add_ident ( 'create' )
    spec_indices(s_fill) =                 add_ident ( 'fill' )
    spec_indices(s_forwardModel) =         add_ident ( 'forwardModel' )
    spec_indices(s_hgrid) =                add_ident ( 'hgrid' )
    spec_indices(s_l2gp) =                 add_ident ( 'l2gp' )
    spec_indices(s_l2aux) =                add_ident ( 'l2aux' )
    spec_indices(s_matrix) =               add_ident ( 'matrix' )
    spec_indices(s_merge) =                add_ident ( 'merge' )
    spec_indices(s_output) =               add_ident ( 'output' )
    spec_indices(s_quantity) =             add_ident ( 'quantity' )
    spec_indices(s_retrieve) =             add_ident ( 'retrieve' )
    spec_indices(s_subset) =               add_ident ( 'subset' )
    spec_indices(s_template) =             add_ident ( 'template' )
    spec_indices(s_time) =                 add_ident ( 'time' )
    spec_indices(s_tpfill) =               add_ident ( 'tpfill' )
    spec_indices(s_vector) =               add_ident ( 'vector' )
    spec_indices(s_vectortemplate) =       add_ident ( 'vectorTemplate' )
    spec_indices(s_vgrid) =                add_ident ( 'vgrid' )
d168 1
d170 1
d175 1
d177 1
a178 5
      begin, t+t_aprioriSource, l+l_clo, l+l_co, l+l_gph, l+l_gph_precision, &
             l+l_h2o, l+l_hcl, l+l_hno3, l+l_n2o, l+l_o3, l+l_temperature, &
             l+l_temperature_prec, n+n_dt_def, &
      begin, t+t_aprioritype, l+l_climatology, l+l_l2gp, l+l_l2aux, &
             n+n_dt_def, &
d180 1
a180 20
      begin, t+t_criticalModule, l+l_both, l+l_either, l+l_ghz, l+l_neither, &
             l+l_thz, n+n_dt_def, &
      begin, t+t_hGridType, l+l_explicit, l+l_fixed, l+l_fractional, &
             l+l_height, l+l_linear, n+n_dt_def, &
      begin, t+t_matrix, l+l_plain, l+l_cholesky, l+l_kronecker, l+l_spd, &
             n+n_dt_def, &
      begin, t+t_mergeMethod, l+l_direct, l+l_weighted, n+n_dt_def, &
      begin, t+t_mergeSource, l+l_dao, l+l_ncep, n+n_dt_def, &
      begin, t+t_module, l+l_ghz, l+l_thz, n+n_dt_def, &
      begin, t+t_molecule, l+(/ (i,i=first_molecule, last_molecule) /), &
             n+n_dt_def, &
      begin, t+t_outputType, l+l_l2aux, l+l_l2gp, n+n_dt_def, &
      begin, t+t_quantityType, l+l_baseline, l+l_extinction, l+l_gph, &
             l+l_ptan, l+l_radiance, l+l_temperature, l+l_vmr, n+n_dt_def, &
      begin, t+t_radiometer, l+l_r1a, l+l_r1b, l+l_r2, l+l_r3, l+l_r4, &
             l+l_r5h, l+l_r5v, n+n_dt_def, &
      begin, t+t_scale, l+l_apriori, & ! l+l_covariance, & !??? Later !???
             l+l_none, l+l_norm, n+n_dt_def, &
      begin, t+t_species, l+l_gph, l+l_gph_precision, l+l_temperature, &
             l+l_temperature_prec, n+n_dt_def, &
d187 2
a188 5
             l+l_thz, l+l_vmr, l+l_zeta, n+n_dt_def, &
      begin, t+t_vgridcoord, l+l_angle, l+l_geodAltitude, l+l_gph, l+l_none, &
             l+l_pressure, l+l_theta, l+l_zeta, n+n_dt_def, &
      begin, t+t_vgridtype, l+l_explicit, l+l_linear, l+l_logarithmic, &
             n+n_dt_def /) )
d209 1
d211 5
a215 21
      begin, s+s_time, n+n_spec_def, &
      begin, s+s_climatology, &
             begin, f+f_type, t+t_aprioriType, n+n_field_type, &
             begin, f+f_source, t+t_aprioriSource, n+n_field_type, &
             begin, f+f_length, t+t_numeric, n+n_field_type, &
             begin, f+f_versionRange, t+t_string, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_create, &
             begin, f+f_template, n+n_field_type, &
             begin, f+f_copy, n+n_field_type, &
             begin, f+f_autofill, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_hGrid, &
             begin, f+f_type, t+t_hGridType, n+n_field_type, &
             begin, f+f_module, t+t_module, n+n_field_type, &
             begin, f+f_fraction, t+t_numeric, n+n_field_type, &
             begin, f+f_height, t+t_numeric, n+n_field_type, &
             begin, f+f_mif, t+t_numeric, n+n_field_type, &
             begin, f+f_interpolationfactor, t+t_numeric, n+n_field_type, &
             begin, f+f_values, n+n_field_type, &
             n+n_spec_def /) )
d217 5
a221 110
      begin, s+s_merge, &  ! Must be AFTER s_climatology
             begin, f+f_apriori, s+s_climatology, n+n_field_spec, &
             begin, f+f_source, t+t_mergeSource, n+n_field_type, &
             begin, f+f_species, t+t_species, n+n_field_type, &
             begin, f+f_range, t+t_numeric_range, n+n_field_type, &
             begin, f+f_height, t+t_numeric, n+n_field_type, &
             begin, f+f_method, t+t_mergeMethod, n+n_field_type, &
             begin, f+f_scale, t+t_numeric, n+n_field_type, &
             n+n_spec_def /) )
    call make_tree ( (/ &
      begin, s+s_template, &
             begin, f+f_copy, n+n_field_type, &
             begin, f+f_apriori, n+n_field_type, &
             begin, f+f_autofill, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_tpfill, &
             begin, f+f_type, n+n_field_type, &
             begin, f+f_temperature, n+n_field_type, &
             begin, f+f_gph, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_vgrid, &
             begin, f+f_type, t+t_vGridType, n+n_field_type, &
             begin, f+f_coordinate, t+t_vGridCoord, n+n_field_type, &
             begin, f+f_number, t+t_numeric, n+n_field_type, &
             begin, f+f_per_decade, t+t_numeric, n+n_field_type, &
             begin, f+f_start, t+t_numeric, n+n_field_type, &
             begin, f+f_stop, t+t_numeric, n+n_field_type, &
             begin, f+f_values, t+t_numeric, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_quantity, & ! Must be AFTER s_hgrid and s_vgrid
             begin, f+f_band, t+t_string, n+n_field_type, &
             begin, f+f_firstindexchannel, t+t_boolean, n+n_field_type, &
             begin, f+f_hGrid, s+s_hgrid, n+n_field_spec, &
             begin, f+f_vGrid, s+s_vgrid, n+n_field_spec, &
             begin, f+f_molecule, t+t_molecule, n+n_field_type, &
             begin, f+f_radiometer, t+t_radiometer, n+n_field_type, &
             begin, f+f_type, t+t_quantityType, n+n_field_type, &
             begin, f+f_unit, t+t_units, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_vectorTemplate, & ! Must be AFTER s_quantity
             begin, f+f_quantities, s+s_quantity, n+n_field_spec, &
             begin, f+f_signals, t+t_string, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_vector, & ! Must be AFTER s_vectorTemplate
             begin, f+f_template, s+s_vectorTemplate, n+n_field_spec, &
             n+n_spec_def /) )
    call make_tree ( (/ &
      begin, s+s_l2gp, &   ! Must be AFTER s_vector
             begin, f+f_source, s+s_vector, f+f_template, f+f_quantities, &
                    n+n_dot, &
             begin, f+f_compareOverlaps, t+t_boolean, n+n_field_type, &
             begin, f+f_outputOverlaps, t+t_boolean, n+n_field_type, &
             begin, f+f_unpackOutput, t+t_boolean, n+n_field_type, &
             begin, f+f_hdfname, t+t_string, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_l2aux, &   ! Must be AFTER s_vector
             begin, f+f_source, s+s_vector, f+f_template, f+f_quantities, &
                    n+n_dot, &
             begin, f+f_compareOverlaps, t+t_boolean, n+n_field_type, &
             begin, f+f_outputOverlaps, t+t_boolean, n+n_field_type, &
             begin, f+f_unpackOutput, t+t_boolean, n+n_field_type, &
             begin, f+f_hdfname, t+t_string, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_matrix, &  ! Must be AFTER s_vector
             begin, f+f_rows, s+s_vector, n+n_field_spec, &
             begin, f+f_columns, s+s_vector, n+n_field_spec, &
             begin, f+f_type, t+t_matrix, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_fill, &    ! Must be AFTER s_vector, s_matrix and s_climatology
             begin, f+f_quantity, s+s_vector, f+f_template, f+f_quantities, &
                    n+n_dot, &
             begin, f+f_matrix, s+s_matrix, n+n_field_spec, &
             begin, f+f_source, t+t_string, s+s_climatology, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_output, &  ! Must be AFTER s_l2aux and s_l2gp
             begin, f+f_type, t+t_outputType, n+n_field_type, &
             begin, f+f_file, t+t_string, n+n_field_type, &
             begin, f+f_quantities, s+s_l2aux, s+s_l2gp, n+n_field_spec, &
             begin, f+f_overlaps, s+s_l2aux, s+s_l2gp, n+n_field_spec, &
             n+n_spec_def /) )
    call make_tree ( (/ &
      begin, s+s_subset, &  ! Must be AFTER s_vector
             begin, f+f_quantity, s+s_vector, f+f_template, f+f_quantities, &
                    n+n_dot, &
             begin, f+f_test, s+s_vector, f+f_template, f+f_quantities, &
                    n+n_dot, &
             begin, f+f_channels, t+t_numeric, n+n_field_type, &
             begin, f+f_criteria, t+t_numeric, n+n_field_type, &
             n+n_spec_def, &
      begin, s+s_forwardModel, & ! Must be AFTER s_vector and s_matrix
             n+n_spec_def, &
      begin, s+s_retrieve, & ! Must be AFTER s_vector and s_matrix
             begin, f+f_apriori, s+s_vector, n+n_field_spec, &
             begin, f+f_aprioriScale, t+t_numeric, n+n_field_type, &
             begin, f+f_columnScale, t+t_scale, n+n_field_type, &
             begin, f+f_covariance, s+s_matrix, n+n_field_spec, &
             begin, f+f_diagonal, t+t_boolean, n+n_field_type, &
             begin, f+f_fwdModelIn, s+s_vector, n+n_field_spec, &
             begin, f+f_fwdModelOut, s+s_vector, n+n_field_spec, &
             begin, f+f_jacobian, s+s_matrix, n+n_field_spec, &
             begin, f+f_maxIterations, t+t_numeric, n+n_field_type, &
             begin, f+f_measurements, s+s_vector, n+n_field_spec, &
             begin, f+f_method, t+t_method, n+n_field_type, &
             begin, f+f_outputCovariance, s+s_matrix, n+n_field_spec, &
             begin, f+f_state, s+s_vector, n+n_field_spec, &
             begin, f+f_toleranceA, t+t_numeric, n+n_field_type, &
             begin, f+f_toleranceF, t+t_numeric, n+n_field_type, &
             begin, f+f_toleranceR, t+t_numeric, n+n_field_type, &
             begin, f+f_weight, s+s_vector, n+n_field_spec, &
             n+n_spec_def /) )
d228 1
a231 1
             begin, p+p_input_version_string, t+t_string, n+n_name_def, &
a232 2
             begin, p+p_allow_climatology_overloads, t+t_boolean, &
                    n+n_name_def, &
d234 4
a237 23
      begin, z+z_readapriori, s+s_time, s+s_climatology, n+n_section, &
      begin, z+z_mergeapriori, s+s_time, s+s_merge, n+n_section, &
      begin, z+z_chunkdivide, &
             begin, p+p_critical_bands, t+t_string, n+n_name_def, &
             begin, p+p_critical_scanning_modules, t+t_criticalModule, &
                    n+n_name_def, &
             begin, p+p_home_geod_angle, t+t_numeric, n+n_name_def, &
             begin, p+p_home_module, t+t_module, n+n_name_def, &
             begin, p+p_ideal_length, t+t_numeric, n+n_name_def, &
             begin, p+p_max_gap, t+t_numeric, n+n_name_def, &
             begin, p+p_overlap, t+t_numeric, n+n_name_def, &
             begin, p+p_scan_lower_limit, t+t_numeric_range, n+n_name_def, &
             begin, p+p_scan_upper_limit, t+t_numeric_range, n+n_name_def, &
             n+n_section, &
      begin, z+z_construct, s+s_time, s+s_vgrid, s+s_hgrid, s+s_quantity, &
             s+s_vectortemplate, n+n_section, &
      begin, z+z_fill, s+s_time, s+s_vector, s+s_tpfill, s+s_create, &
                       s+s_fill, s+s_matrix, &
             n+n_section, &
      begin, z+z_retrieve, s+s_matrix, s+s_forwardModel, s+s_retrieve, &
             s+s_subset, n+n_section, &
      begin, z+z_join, s+s_time, s+s_l2gp, s+s_l2aux, n+n_section, &
      begin, z+z_output, s+s_time, s+s_output, n+n_section /) )
d249 1
a249 1
    integer :: I, ID, M, N_IDS, STACK(0:30), STRING, WHICH
d266 2
a267 1
        which = ids(i) / 1000
d282 1
a282 1
         call build_tree ( id, stack(m) )
d297 1
d307 3
a309 46
! $Log: init_tables_module.f90,v $
! Revision 2.3  2001/02/12 17:51:47  pwagner
! Consistent with l2
!
! Revision 2.12  2001/02/01 20:19:42  vsnyder
! Remove "gph" from the "molecule" type
!
! Revision 2.11  2001/02/01 01:23:36  vsnyder
! Account for the Molecules module
!
! Revision 2.10  2001/01/31 23:32:00  vsnyder
! Moved l_temperature l_temperature_prec l_ptan l_tangentheight l_sidebandratio
! l_scvel l_orbitinclination l_geodaltitude l_radiance l_scanresidual l_gph
! l_gph_precision l_refgph l_baseline l_extinction l_linewidth to
! intrinsic module
!
! Revision 2.9  2001/01/30 00:25:54  livesey
! Added L_REFGPH
!
! Revision 2.8  2001/01/26 19:02:24  vsnyder
! Changes for "retrieve" section.
!
! Revision 2.7  2001/01/18 02:00:35  vsnyder
! Define strings for more field names that were overlooked.  Type checking for
! "fill" is still wrong.
!
! Revision 2.6  2001/01/17 01:29:51  vsnyder
! Define s_subset's string table entry
!
! Revision 2.5  2001/01/10 21:02:44  vsnyder
! Add radiometer names, stuff for "retrieve" and "subset"
!
! Revision 2.4  2000/11/16 01:53:57  vsnyder
! Take timing out of sections that are only parameter settings.
!
! Revision 2.3  2000/11/16 01:46:16  vsnyder
! Revise section numbers so they don't overlap parameter numbers.
!
! Revision 2.2  2000/11/16 01:22:59  vsnyder
! Add a "time" spec to every section.
!
! Revision 2.1  2000/10/12 00:35:57  vsnyder
! Move intrinsic types and literals to "intrinsic" module
!
! Revision 2.0  2000/09/05 18:57:05  ahanzel
! Changing file revision to 2.0.
a310 2
! Revision 1.1  2000/09/02 02:05:04  vsnyder
! Initial entry
@


2.3
log
@Consistent with l2
@
text
@d33 1
a33 1
       "$Id: init_tables_module.f90,v 2.12 2001/02/01 20:19:42 vsnyder Exp $"
d734 3
@


2.2
log
@Replaced with the l2 version
@
text
@d33 1
a33 1
       "$Id: init_tables_module.f90,v 2.11 2001/02/01 01:23:36 vsnyder Exp $"
d455 1
a455 1
             l+l_gph, n+n_dt_def, &
d734 3
@


2.1
log
@First commit
@
text
@a9 5
!       *************************************************
!Warning ... this is the list of preloaded symbols purloined from the level 2
!You must rewrite it to conform with the expected cf format of level 1
!       *************************************************

d12 2
a13 2
  use INTRINSIC ! Everything. FIRST_LIT, INIT_INTRINSIC,
    ! L_FALSE, L_TRUE, LAST_INTRINSIC_LIT, T_BOOLEAN, T_FIRST,
d33 1
a33 1
       "$Id: init_tables_module.f90,v 2.1 2000/10/12 00:35:57 vsnyder Exp $"
d43 4
a46 2
  integer, public, parameter :: T_MERGEMETHOD    = t_hgridtype+1
  integer, public, parameter :: T_MERGESOURCE    = t_mergemethod+1
d51 3
a53 1
  integer, public, parameter :: T_SPECIES        = t_quantitytype+1
d60 63
a122 41
  integer, public, parameter :: F_APRIORI = 1
  integer, public, parameter :: F_AUTOFILL = 2
  integer, public, parameter :: F_BAND = 3
  integer, public, parameter :: F_COMPAREOVERLAPS = 4
  integer, public, parameter :: F_COORDINATE = 5
  integer, public, parameter :: F_COPY = 6
  integer, public, parameter :: F_FILE = 7
  integer, public, parameter :: F_FIRSTINDEXCHANNEL = 8
  integer, public, parameter :: F_FRACTION = 9
  integer, public, parameter :: F_GPH = 10
  integer, public, parameter :: F_HDFNAME = 11
  integer, public, parameter :: F_HEIGHT = 12
  integer, public, parameter :: F_HGRID = 13
  integer, public, parameter :: F_INTERPOLATIONFACTOR = 14
  integer, public, parameter :: F_LENGTH = 15
  integer, public, parameter :: F_METHOD = 16
  integer, public, parameter :: F_MIF = 17
  integer, public, parameter :: F_MODULE = 18
  integer, public, parameter :: F_MOLECULE = 19
  integer, public, parameter :: F_NUMBER = 20
  integer, public, parameter :: F_OUTPUTOVERLAPS = 21
  integer, public, parameter :: F_OVERLAPS = 22
  integer, public, parameter :: F_PER_DECADE = 23
  integer, public, parameter :: F_QUANTITIES = 24
  integer, public, parameter :: F_RADIOMETER = 25
  integer, public, parameter :: F_RANGE = 26
  integer, public, parameter :: F_SCALE = 27
  integer, public, parameter :: F_SIGNALS = 28
  integer, public, parameter :: F_SOURCE = 29
  integer, public, parameter :: F_SPECIES = 30
  integer, public, parameter :: F_START = 31
  integer, public, parameter :: F_STOP = 32
  integer, public, parameter :: F_TEMPERATURE = 33
  integer, public, parameter :: F_VERSIONRANGE = 34
  integer, public, parameter :: F_TEMPLATE = 35
  integer, public, parameter :: F_TYPE = 36
  integer, public, parameter :: F_UNIT = 37
  integer, public, parameter :: F_UNPACKOUTPUT = 38
  integer, public, parameter :: F_VALUES = 39
  integer, public, parameter :: F_VGRID = 40
  integer, public, parameter :: FIELD_FIRST = f_Apriori, FIELD_LAST = f_vGrid
d125 1
d127 6
a132 6
  integer, public, parameter :: L_BASELINE      = l_angle + 1
  integer, public, parameter :: L_BOTH 	        = l_baseline + 1
  integer, public, parameter :: L_CLIMATOLOGY   = l_both + 1
  integer, public, parameter :: L_CLO           = l_climatology + 1
  integer, public, parameter :: L_CO            = l_clo + 1
  integer, public, parameter :: L_DAO 	        = l_co + 1
d136 1
a136 2
  integer, public, parameter :: L_EXTINCTION    = l_explicit + 1
  integer, public, parameter :: L_FIXED         = l_extinction + 1
d138 3
a140 8
  integer, public, parameter :: L_GEODALTITUDE  = l_fractional + 1
  integer, public, parameter :: L_GPH 	        = l_geodaltitude + 1
  integer, public, parameter :: L_GPH_PRECISION = l_gph + 1
  integer, public, parameter :: L_H2O           = l_gph_precision + 1
  integer, public, parameter :: L_HCL           = l_h2o + 1
  integer, public, parameter :: L_HEIGHT        = l_hcl + 1
  integer, public, parameter :: L_HNO3          = l_height + 1
  integer, public, parameter :: L_L2AUX         = l_hno3 + 1
d144 1
a144 2
  integer, public, parameter :: L_N2O           = l_logarithmic + 1
  integer, public, parameter :: L_NCEP 	        = l_n2o + 1
d146 14
a159 8
  integer, public, parameter :: L_NONE 	        = l_neither + 1
  integer, public, parameter :: L_O3            = l_none + 1
  integer, public, parameter :: L_PRESSURE      = l_o3 + 1
  integer, public, parameter :: L_PTAN 	        = l_pressure + 1
  integer, public, parameter :: L_RADIANCE      = l_ptan  + 1
  integer, public, parameter :: L_TEMPERATURE   = l_radiance + 1
  integer, public, parameter :: L_TEMPERATURE_PREC = l_temperature + 1
  integer, public, parameter :: L_THETA         = l_temperature_prec + 1
d166 3
a168 3
  integer, public, parameter :: P_INPUT_VERSION_STRING = 2
  integer, public, parameter :: P_OUTPUT_VERSION_STRING = 3
  integer, public, parameter :: P_VERSION_COMMENT = 4
d170 9
a178 9
  integer, public, parameter :: P_CRITICAL_BANDS = 5
  integer, public, parameter :: P_CRITICAL_SCANNING_MODULES = 6
  integer, public, parameter :: P_HOME_GEOD_ANGLE = 7
  integer, public, parameter :: P_HOME_MODULE = 8
  integer, public, parameter :: P_IDEAL_LENGTH = 9
  integer, public, parameter :: P_MAX_GAP = 10
  integer, public, parameter :: P_OVERLAP = 11
  integer, public, parameter :: P_SCAN_LOWER_LIMIT = 12
  integer, public, parameter :: P_SCAN_UPPER_LIMIT = 13
d182 5
a186 4
! Section identities:
  integer, public, parameter :: Z_CHUNKDIVIDE = 4
  integer, public, parameter :: Z_CONSTRUCT = 5
  integer, public, parameter :: Z_FILL = 6
d188 5
a192 4
  integer, public, parameter :: Z_JOIN = 7
  integer, public, parameter :: Z_MERGEAPRIORI = 3
  integer, public, parameter :: Z_OUTPUT = 8
  integer, public, parameter :: Z_READAPRIORI = 2
d196 21
a216 14
! Specification indices:
  integer, public, parameter :: S_CLIMATOLOGY = 1
  integer, public, parameter :: S_CREATE = 2
  integer, public, parameter :: S_HGRID = 3
  integer, public, parameter :: S_L2GP = 4
  integer, public, parameter :: S_L2AUX = 5
  integer, public, parameter :: S_MERGE = 6
  integer, public, parameter :: S_OUTPUT = 7
  integer, public, parameter :: S_QUANTITY = 8
  integer, public, parameter :: S_TEMPLATE = 9
  integer, public, parameter :: S_TPFILL = 10
  integer, public, parameter :: S_VECTOR = 11
  integer, public, parameter :: S_VECTORTEMPLATE = 12
  integer, public, parameter :: S_VGRID = 13
d224 14
a237 13
! To: | globalSettings    chunkDivide        join          |
!     |       readApriori       construct         output   |
!     |             mergeApriori       fill                |
! ====|====================================================|== From: ==
        (/OK,    0,    0,    0,    0,    0,    0,    0,  & ! Start
           0,   OK,    0,    0,    0,    0,    0,    0,  & ! GlobalSettings
           0,    0,   OK,    0,    0,    0,    0,    0,  & ! readApriori
           0,    0,    0,   OK,    0,    0,    0,    0,  & ! mergeApriori
           0,    0,    0,    0,   OK,   OK,   OK,   OK,  & ! chunkDivide
           0,    0,    0,    0,   OK,   OK,   OK,   OK,  & ! Construct
           0,    0,    0,    0,   OK,   OK,   OK,   OK,  & ! Fill
           0,    0,    0,    0,    0,    0,    0,   OK,  & ! Join
           0,    0,    0,    0,    0,    0,    0,    0/) & ! Output
d248 2
d259 1
d261 1
d267 2
d275 1
a275 1
    lit_indices(l_baseline) =              add_ident ( 'baseline' )
d277 1
d279 1
a279 2
    lit_indices(l_clo) =                   add_ident ( 'clo' )
    lit_indices(l_co) =                    add_ident ( 'co' )
a283 1
    lit_indices(l_extinction) =            add_ident ( 'extinction' )
a285 5
    lit_indices(l_geodaltitude) =          add_ident ( 'geodaltitude' )
    lit_indices(l_gph) =                   add_ident ( 'gph' )
    lit_indices(l_gph_precision) =         add_ident ( 'gph_precision' )
    lit_indices(l_h2o) =                   add_ident ( 'h2o' )
    lit_indices(l_hcl) =                   add_ident ( 'hcl' )
d287 1
a287 1
    lit_indices(l_hno3) =                  add_ident ( 'hno3' )
a291 1
    lit_indices(l_n2o) =                   add_ident ( 'n2o' )
d294 1
d296 2
a297 1
    lit_indices(l_o3) =                    add_ident ( 'o3' )
d299 8
a306 4
    lit_indices(l_ptan) =                  add_ident ( 'ptan' )
    lit_indices(l_radiance) =              add_ident ( 'radiance' )
    lit_indices(l_temperature) =           add_ident ( 'temperature' )
    lit_indices(l_temperature_prec) =      add_ident ( 'temperature_precision' )
d311 1
d314 4
a317 1
    field_indices(f_compareoverlaps) =     add_ident ( 'compareoverlaps' )
d320 3
d324 1
a324 1
    field_indices(f_firstindexchannel) =   add_ident ( 'f_firstindexchannel' )
d326 2
d332 2
a333 1
    field_indices(f_interpolationfactor) = add_ident ( 'interpolationfactor' )
d335 3
d343 2
a344 1
    field_indices(f_outputoverlaps) =      add_ident ( 'outputoverlaps' )
d348 1
d351 1
d357 1
d360 4
a363 1
    field_indices(f_versionrange) =        add_ident ( 'versionrange' )
d365 1
d368 1
a368 1
    field_indices(f_unpackoutput) =        add_ident ( 'unpackoutput' )
d370 2
a371 1
    field_indices(f_vgrid) =               add_ident ( 'vgrid' )
d397 1
d401 2
d406 1
d410 2
d413 1
d416 1
a416 1
    spec_indices(s_vectortemplate) =       add_ident ( 'vectortemplate' )
a432 8

! If reach this line, then you have not rewritten this for level 1
! Therefore, must abort program
         print *, 'The init_tables_module has not yet been rewritten for', &
         & ' level 1--stopping now'
         STOP
!

d449 2
d454 2
a455 2
      begin, t+t_molecule, l+l_clo, l+l_co, l+l_gph, l+l_h2o, &
             l+l_hcl, l+l_hno3, l+l_n2o, l+l_o3, n+n_dt_def, &
d459 4
d497 1
d554 1
a554 1
             begin, f+f_radiometer, t+t_string, n+n_field_type, &
d582 11
d599 30
d643 2
a644 2
      begin, z+z_readapriori, s+s_climatology, n+n_section, &
      begin, z+z_mergeapriori, s+s_merge, n+n_section, &
d657 1
a657 1
      begin, z+z_construct, s+s_vgrid, s+s_hgrid, s+s_quantity, &
d659 7
a665 3
      begin, z+z_fill, s+s_vector, s+s_tpfill, s+s_create, n+n_section, &
      begin, z+z_join, s+s_l2gp, s+s_l2aux, n+n_section, &
      begin, z+z_output, s+s_output, n+n_section /) )
d676 1
d679 1
d715 5
a719 4
         print *, 'INIT_TABLES_MODULE%MAKE_TREE-E- Element ', i, &
           & ' of a list is undefined'
           stop
         end if
d734 39
d774 2
@

