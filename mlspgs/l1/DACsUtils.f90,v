head	2.18;
access;
symbols
	v5-02-NRT-19:2.18
	v6-00:2.18
	v5-02-NRT-18:2.18
	v5-02:2.18
	v5-01-NRT-17:2.18
	v5-01-NRT-16:2.18
	v5-01-NRT-15:2.18
	v5-01-NRT-14:2.18
	neuralnetworks-1-0:2.18.0.10
	cfm-single-freq-0-1:2.18.0.8
	v5-01:2.18
	v5-00:2.18
	v4-23-TA133:2.18.0.6
	mus-emls-1-70:2.18.0.4
	rel-1-0-englocks-work:2.18.0.2
	VUMLS1-00:2.18
	VPL1-00:2.17
	V4-22-NRT-08:2.17
	whdrel10_merged_to_here:2.17
	merge_whdrel10_from_here:2.17
	TAG_TRUNK_AFTER_PW_CHANGES:2.17
	TAG_TRUNK_BEFORE_PW_CHANGES:2.17
	VAM1-00:2.17
	whd-rel-1-0:2.17.0.4
	V4-21:2.17.0.2
	V4-13:2.17
	V4-12:2.17
	V4-11:2.17
	V4-10:2.17
	V3-43:2.16
	M4-00:2.16
	V3-41:2.16
	V3-40-PlusGM57:2.16.0.2
	V2-24-NRT-04:2.15
	V3-33:2.16
	V2-24:2.15
	V3-31:2.16
	V3-30-NRT-05:2.16
	cfm-01-00:2.16
	V3-30:2.16
	V3-20:2.16
	V3-10:2.16
	V2-23-NRT-02:2.15
	V2-23:2.15
	V2-22-NRT-01:2.15
	V2-22:2.15
	V2-21:2.14
	V2-20:2.14
	V2-11:2.14
	V2-10:2.14
	V2-00:2.13
	V1-51:2.8
	V1-50:2.7
	V1-45:2.6
	V1-44:2.6
	V1-43:2.6
	V1-42:2.5
	V1-41:2.5
	V1-32:2.4
	V1-40:2.5
	V1-31:2.4
	V1-30:2.4
	V1-13:2.3
	V1-12:2.2
	V1-11:2.2
	V1-10:2.2
	newfwm-feb03:2.2.0.2
	V1-04:2.1
	V1-03:2.1
	V1-02:2.1
	V1-00:2.1;
locks; strict;
comment	@# @;


2.18
date	2017.01.07.00.14.26;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2014.05.01.15.09.16;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2009.05.13.20.33.05;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2007.06.07.21.56.52;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2006.08.02.18.53.09;	author perun;	state Exp;
branches;
next	2.13;

2.13
date	2006.06.14.13.44.55;	author perun;	state Exp;
branches;
next	2.12;

2.12
date	2006.04.05.18.10.32;	author perun;	state Exp;
branches;
next	2.11;

2.11
date	2005.10.10.19.08.40;	author perun;	state Exp;
branches;
next	2.10;

2.10
date	2005.06.23.18.41.35;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2005.05.02.16.01.50;	author perun;	state Exp;
branches;
next	2.8;

2.8
date	2005.01.25.15.19.20;	author perun;	state Exp;
branches;
next	2.7;

2.7
date	2004.12.01.17.08.56;	author perun;	state Exp;
branches;
next	2.6;

2.6
date	2004.05.14.15.59.11;	author perun;	state Exp;
branches;
next	2.5;

2.5
date	2004.01.09.17.46.22;	author perun;	state Exp;
branches;
next	2.4;

2.4
date	2003.08.15.14.25.04;	author perun;	state Exp;
branches;
next	2.3;

2.3
date	2003.03.25.19.53.54;	author perun;	state Exp;
branches;
next	2.2;

2.2
date	2003.01.31.18.13.34;	author perun;	state Exp;
branches;
next	2.1;

2.1
date	2002.03.29.20.20.16;	author perun;	state Exp;
branches;
next	;


desc
@@


2.18
log
@Avoid arithmetic error when SUM (Avec(1:3,bno)) vanishes
@
text
@! Copyright 2006, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
MODULE DACsUtils
!=============================================================================

  USE MLSL1Utils, ONLY: BigEndianStr
  USE L1BData, ONLY: L1BData_T, ReadL1BData, DeallocateL1BData
  USE MLSL1Common, ONLY: R8, DACSnum

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: ExtractDACSdata, UncompressDACSdata, ProcessDACSdata, InitDACS_FFT
  PUBLIC :: FinalizeDACSdata, TPz

  INTEGER :: plan129
  REAL(r8) :: TPz(DACSnum)

!---------------------------- RCS Module Info ------------------------------
  CHARACTER (len=*), PRIVATE, PARAMETER :: ModuleName= &
       "$RCSfile: DACsUtils.f90,v $"
  PRIVATE :: not_used_here 
!---------------------------------------------------------------------------

CONTAINS

!=============================================================================
  SUBROUTINE InitDACS_FFT
!=============================================================================

! FFTW Parameters

    INTEGER, PARAMETER :: FFTW_FORWARD = -1
    INTEGER, PARAMETER :: FFTW_BACKWARD = 1
    INTEGER, PARAMETER :: FFTW_REAL_TO_COMPLEX = -1
    INTEGER, PARAMETER :: FFTW_COMPLEX_TO_REAL = 1
    INTEGER, PARAMETER :: FFTW_ESTIMATE = 0
    INTEGER, PARAMETER :: FFTW_MEASURE = 1
    INTEGER, PARAMETER :: FFTW_OUT_OF_PLACE = 0
    INTEGER, PARAMETER :: FFTW_IN_PLACE = 8
    INTEGER, PARAMETER :: FFTW_USE_WISDOM = 16

! Set up plan for 129 channel DACS:

    CALL rfftw_f77_create_plan (plan129, 256, FFTW_REAL_TO_COMPLEX, &
         FFTW_MEASURE)

  END SUBROUTINE InitDACS_FFT

!=============================================================================
  SUBROUTINE ExtractDACSdata (rawdata, K, D, TP, DIO, LO)
!=============================================================================

    CHARACTER (LEN=*), DIMENSION(:), INTENT(IN) :: rawdata
    INTEGER, DIMENSION(:), INTENT(OUT) :: K
    INTEGER, INTENT(OUT) :: D(4), TP, DIO, LO

    INTEGER :: i, nchans, offset

    K = 0

    IF (SIZE (rawdata) > 400) THEN   ! contains 129 channels of data
       nchans = 129
    ELSE                             ! truncated DACS data
       nchans = 82
    ENDIF

    DO i = 1, nchans*3, 3            ! every 3 bytes (MSB)
       K(i/3+1) = BigEndianStr (rawdata(i)//rawdata(i+1)//rawdata(i+2))
    ENDDO

    offset = nchans * 3 + 1

    DO i = 1, 4
       D(i) = BigEndianStr (rawdata(offset)//rawdata(offset+1)// &
            rawdata(offset+2))
       offset = offset + 3           ! next 3 bytes
    ENDDO

    TP = BigEndianStr (rawdata(offset)//rawdata(offset+1))

    IF (nchans > 82) THEN
       DIO = BigEndianStr (rawdata(offset+2))
       LO = BigEndianStr (rawdata(offset+3))
    ENDIF

  END SUBROUTINE ExtractDACSdata

!=============================================================================
  SUBROUTINE UncompressDACSdata (rawdata, C, D, TP, DIO, LO, Zlag)
!=============================================================================

    CHARACTER (LEN=*), DIMENSION(:), INTENT(IN) :: rawdata
    INTEGER, DIMENSION(:), INTENT(OUT) :: C
    INTEGER, INTENT(OUT) :: D(4), TP, DIO, Zlag, LO

    INTEGER :: i, i12, i8, rindx

!! Masks for extending sign bits:

    INTEGER :: bitmask7, signmask7, bitmask11, signmask11, upper4bits
    DATA bitmask7 / z'80' /
    DATA signmask7 / z'FFFFFF00' /
    DATA bitmask11 / z'800' /
    DATA signmask11 / z'FFFFF000' /
    DATA upper4bits / z'FFF' /

! Get the 12 bit quantities

    DO i = 1, 31, 2      ! odd indexes
       rindx = i + i / 2
       i12 = BigEndianStr (rawdata(rindx)//rawdata(rindx+1))
       i12 = ISHFT (i12, -4)           ! shift 4 bits to the right
       IF (IAND (i12, bitmask11) /= 0) THEN
          i12 = IOR (i12, signmask11)
       ENDIF
       C(i) = i12
    ENDDO

    DO i = 2, 32, 2      ! even indexes
       rindx = i + (i - 1) / 2
       i12 = BigEndianStr (rawdata(rindx)//rawdata(rindx+1))
       i12 = IAND (i12, upper4bits)        ! mask off upper 4 bits
       IF (IAND (i12, bitmask11) /= 0) THEN
          i12 = IOR (i12, signmask11)
       ENDIF
       C(i) = i12
    ENDDO

! Get the 8 bit quantities

    DO i = 33, 128
       rindx = i + 16
       i8 = BigEndianStr (rawdata(rindx))
       IF (IAND (i8, bitmask7) /= 0) THEN
          i8 = IOR (i8, signmask7)
       ENDIF
       C(i) = i8
    ENDDO

! Get the D array values

    DO i = 1, 4
       rindx = 145 + (i - 1) * 3
       D(i) = BigEndianStr (rawdata(rindx)//rawdata(rindx+1)//rawdata(rindx+2))
    ENDDO

    rindx = rindx + 3
    TP = BigEndianStr (rawdata(rindx)//rawdata(rindx+1))

    IF (SIZE (rawdata) > 158) THEN
       DIO = BigEndianStr (rawdata(rindx+2))
       Zlag = BigEndianStr (rawdata(rindx+3))
       LO = BigEndianStr (rawdata(rindx+4))
    ELSE
       DIO = -1
       Zlag = -1
       LO = -1
    ENDIF

  END SUBROUTINE UncompressDACSdata

!=============================================================================
  SUBROUTINE ProcessDACSdata
!=============================================================================

    USE MLSL1Common, ONLY: DACSnum, DACSchans, MaxMIFs
    USE L0_sci_tbls, ONLY: DACS_MAF, SciMAF

    INTEGER :: DACSno, MIFno, nchans
    LOGICAL :: GoodDACS
    REAL :: R2a(DACSchans)

    CALL FixLostCarryBits  ! fix state counters for the MAF

    DO MIFno = 0, (MaxMIFs - 1)
       DO DACSno = 1, DACSnum
          GoodDACS = (SUM (DACS_MAF(MIFno)%D(:,DACSno)) > 0)
          IF (GoodDACS) THEN
             nchans = 129
             IF ((.NOT. DACS_MAF(MIFno)%Compressed) .AND. &
                  (MOD (DACSno, 2) == 0)) nchans = 82
             CALL UnpackDACSdata (DACS_MAF(MIFno)%C_K(:,DACSno), &
                  DACS_MAF(MIFno)%D(:,DACSno), DACS_MAF(MIFno)%Compressed, &
                  nchans, R2a)
             CALL ProcessUnpackedDACS (DACS_MAF(MIFno)%D(:,DACSno), R2a, &
                  nchans, DACS_MAF(MIFno)%TP(DACSno), &
                  SciMAF(MIFno)%TPdigP(DACSno), SciMAF(MIFno)%TPdigN(DACSno), &
                  SciMAF(MIFno)%DACS(:,DACSno))
             SciMAF(MIFno)%TP(DACSno) = DACS_MAF(MIFno)%TP(DACSno)         
          ENDIF
       ENDDO
    ENDDO

  END SUBROUTINE ProcessDACSdata

!=============================================================================
  SUBROUTINE FixLostCarryBits
!=============================================================================

    USE MLSL1Common, ONLY: DACSnum, MaxMIFs
    USE L0_sci_tbls, ONLY: DACS_MAF
    USE Sort_M

    INTEGER :: DACSno, MIFno, Median, BitNo, IntBit1(4), Ndif(4), NumZmatch
    INTEGER :: i, imin(1), mindx(2)
    INTEGER :: Ntot(0:(MaxMIFs-1)), NtotSort(0:(MaxMIFs-1))
    INTEGER :: E                         ! error from median
    INTEGER :: Ebit, EbitVal             ! error to nearest log 2 (bit & value)
    INTEGER, PARAMETER :: E_thold = 48   ! error threshold

    LOGICAL :: Zmatch(4)

    DO DACSno = 1, DACSnum

! Sum D and find median of sum:

       DO MIFno = 0, (MaxMIFs-1)
          Ntot(MIFno) = SUM (DACS_MAF(MIFno)%D(:,DACSno))
       ENDDO

       NtotSort = Ntot
       CALL Sort (NtotSort, 1, MaxMIFs)
       Median = NtotSort(MaxMIFs/2)

! Find error conditions:

       DO MIFno = 0, (MaxMIFs-1)

          IF (Ntot(MIFno) > 0) THEN
             E = Median - Ntot(MIFno)
             IF (E > E_thold) THEN

                Ebit = NINT (LOG (REAL(E)) / LOG (2.0))
                EbitVal = 2**Ebit

! Check lowest bit number set to 1

                Zmatch = .FALSE.   ! no match of trailing Zeros yet
                DO i = 1, 4
                   BitNo = 0
                   IF (DACS_MAF(MIFno)%D(i,DACSno) /= 0) THEN
                      DO
                         IF (BTEST (DACS_MAF(MIFno)%D(i,DACSno), BitNo)) EXIT
                         BitNo = BitNo + 1
                      ENDDO
                   ENDIF
                   IntBit1(i) = 2**BitNo   ! Value of lowest bit set to 1
                   Zmatch(i) = (IntBit1(i) >= EbitVal)   ! match if error
                ENDDO

                NumZmatch = COUNT (Zmatch)

                IF (NumZmatch == 1) THEN   ! Adjust only one counter

                   WHERE (Zmatch)
                      DACS_MAF(MIFno)%D(:,DACSno) = &
                           DACS_MAF(MIFno)%D(:,DACSno) + EbitVal
                   END WHERE

                ELSE IF (NumZmatch > 1) THEN   ! Adjust when multiple counters

                   IF (MIFno == 0) THEN
                      mindx = (/ 1, 1 /)    ! Can't use previous MIF
                   ELSE
                      mindx = (/ -1, 1 /)   ! Use both previous and next MIF
                   ENDIF

                   Ndif = HUGE (Ndif)     ! Init for comparisons
                   WHERE (Zmatch)
                      Ndif = DACS_MAF(MIFno)%D(:,DACSno) - &
                           (DACS_MAF(MIFno+mindx(1))%D(:,DACSno) + &
                           DACS_MAF(MIFno+mindx(2))%D(:,DACSno)) / 2
                   END WHERE
                   imin = MINLOC (Ndif)
                   DACS_MAF(MIFno)%D(imin(1):,DACSno) = &
                        DACS_MAF(MIFno)%D(imin(1):,DACSno) + EbitVal

                ELSE

                   EbitVal = 2**(Ebit-1)   ! Reset value to previous bit
                   Zmatch = .FALSE.
                   DO i = 1, 4
                      Zmatch(i) = (IntBit1(i) >= EbitVal)   ! match if error
                   ENDDO
                   NumZmatch = COUNT (Zmatch)

                   IF (NumZmatch == 2) THEN  ! Only if exactly 2 match
                      WHERE (Zmatch)
                         DACS_MAF(MIFno)%D(:,DACSno) = &
                              DACS_MAF(MIFno)%D(:,DACSno) + EbitVal
                      END WHERE
                   ELSE
                      DACS_MAF(MIFno)%D(:,DACSno) = 0   ! Clear for discard
                   ENDIF
                ENDIF

             ENDIF
          ENDIF
       ENDDO

    ENDDO


  END SUBROUTINE FixLostCarryBits

!=============================================================================
  SUBROUTINE UnpackDACSdata (C_K, D, Compressed, nchans, R2a)
!=============================================================================

    INTEGER, DIMENSION(:) :: C_K
    INTEGER :: D(4), nchans
    LOGICAL :: Compressed
    REAL, DIMENSION(:) :: R2a

    REAL :: Ntot3

    IF (Compressed) THEN
       CALL UnpackCompDACS (C_K, R2a)  ! C array type
    ELSE
       Ntot3 = SUM(D) * 3.0
       IF (Ntot3 > 0) CALL UnpackUncompDACS (C_K, Ntot3, nchans, R2a)  ! K array
    ENDIF

  END SUBROUTINE UnpackDACSdata

!=============================================================================
  SUBROUTINE UnpackCompDACS (C, R2a)
!=============================================================================

    USE MLSL1Common, ONLY: DACS_const

    INTEGER, DIMENSION(:) :: C
    REAL, DIMENSION(:) :: R2a

    INTEGER :: i
    REAL :: L

    L = DACS_const%L    ! convert to REAL

    R2a(1) = 1.0
    DO i = 2, 129
       R2a(i) = (C(i-1) + DACS_const%A(i-1)) / L
    ENDDO

  END SUBROUTINE UnpackCompDACS

!=============================================================================
  SUBROUTINE UnpackUncompDACS (K, Ntot3, nchans, R2a)
!=============================================================================

    INTEGER, DIMENSION(:) :: K
    INTEGER :: nchans
    REAL, DIMENSION(:) :: R2a
    REAL :: Ntot3

    INTEGER :: i

    R2a(1:129) = 0.0
    IF (K(1) == NINT (Ntot3)) RETURN

    R2a(1) = 1.0
    DO i = 2, nchans
       R2a(i) = (K(i) - Ntot3) / (K(1) - Ntot3)
    ENDDO

  END SUBROUTINE UnpackUncompDACS

!=============================================================================
  SUBROUTINE ProcessUnpackedDACS (D, R2a, nchans, TP, TPdigP, TPdigN, DACS_dat)
!=============================================================================

    USE MLSL1Common, ONLY: r8, DACSchans
    USE MLSSpecialFunctions, ONLY: derfi
    
    REAL, INTENT (IN) :: R2a(DACSchans)
    INTEGER, INTENT (IN) :: D(4), TP, nchans
    real(r8), intent (OUT) :: TPdigP, TPdigN
    REAL, INTENT (OUT) :: DACS_dat(DACSchans)

    INTEGER :: Dtot, i
    REAL(r8) :: rho(DACSchans), P_thold, N_thold, Z_thold
    REAL(r8) :: A, M, R(256), R_FFT(256)
    REAL(r8), PARAMETER :: sqrt2 = 1.41421356237d0
    REAL(r8), PARAMETER :: C(14) = (/ 0.97523849075787, -0.02380608085090, &
         0.02319499998418, 0.00008254427432, -0.13041555636211, &
         0.07971713086422, 0.00585091297055, -0.06240215483141, &
         0.18410829607653, 0.36609324008142, -0.37590450311119, &
         2.65674351163174, 2.53926887918654, 5.41351505425882 /)

    rho = 0.0
    rho(1) = 1.0

    IF (D(1) == 0 .AND. D(4) == 0) THEN
       DACS_dat = 0.0
       RETURN
    ENDIF

    Dtot = SUM (D)
    IF (Dtot > 0.0) THEN
       P_thold = sqrt2 * derfi (1.0d0 - 2.0d0 * D(1) / Dtot)
       TPdigP = 1.0 / (P_thold * P_thold)
       N_thold = sqrt2 * derfi (1.0d0 - 2.0d0 * D(4) / Dtot)
       TPdigN = 1.0 / (N_thold * N_thold)
       Z_thold = sqrt2 * derfi (1.0d0 - 2.0d0 * (D(1) + D(2))/ Dtot)
    ELSE
       P_thold = 0.0
       TPdigP= 0.0
       N_thold = 0.0
       TPdigN = 0.0
       Z_thold = 0.0
    ENDIF
    A = P_thold - N_thold
    M = (P_thold + N_thold) / 2.0 - 0.9

    DO i = 2, nchans
       rho(i) = C(1) * R2a(i) + C(2) * R2a(i)**3 + C(3) * R2a(i)**5 + &
            C(4) * R2a(i)**7 + C(5) * SIN(R2a(i) * C(12)) * M + &
            C(6) * SIN(R2a(i) * C(13)) * M**2 + C(7) * SIN(R2a(i)*C(14)) * M + &
            C(8) * A**2 + C(9) * A**2 * R2a(i) + C(10) * Z_thold**2*R2a(i) + &
            C(11) * Z_thold * A
    ENDDO

! Prepare for FFT

  R(1:129) = rho
  R(130:256) = rho(128:2:-1)

! Do the FFT

  CALL rfftw_f77_one (plan129, R, R_FFT)

  DACS_dat = R_FFT(1:129)   ! Moved scaling to SortQualify routine

  END SUBROUTINE ProcessUnpackedDACS

!=============================================================================
  SUBROUTINE FinalizeDACSdata
!=============================================================================

    USE Constants, ONLY: Pi
    USE HDF5, ONLY: h5gopen_f
    USE HighOutput, ONLY: OutputNamedValue
    USE MatrixModule_0, ONLY: MatrixInversion
    USE MLSAuxData, ONLY: Build_MLSAuxData
    USE MLSKinds, ONLY: RM
    USE MLS_DataProducts, ONLY: DataProducts_T, Deallocate_DataProducts
    USE MLSHDF5, ONLY: IsHDF5DSPresent, MakeHDF5Attribute
    USE MLSL1Common, ONLY: L1BFileInfo, DACSchans
    USE MLSL1Config, ONLY: MIFsGHz, L1Config
    use Output_m, only: Output

    INTEGER :: bno, ch, grp_id, i, Flag, maf, mif, noMAFs, sd_id, status
    INTEGER, PARAMETER :: rch(2) = (/ 10, 100 /)  ! range of channels
    INTEGER, PARAMETER :: Nch = (rch(2) - rch(1) + 1)  ! number of "good" chans
    INTEGER :: Ycount(nch)
    REAL :: Y(nch)  ! will contain average over + prec and within alt range
    REAL, POINTER, DIMENSION(:,:) :: alt, sza
    REAL, POINTER, DIMENSION(:,:,:) :: rad, rad_prec
    REAL, PARAMETER :: MinAlt = 78000, MaxAlt = 100000 ! Altitude ranges (m)
 
! High altitude model parameters:

    REAL, PARAMETER :: cen(24:25) = (/ 48.384, 51.44 /)
    REAL, PARAMETER :: dopp(24:25) = (/ 1.667, 2.2 /)
    REAL, PARAMETER :: spur = (5.0e6 / 7*128 / 1.25e7)
    REAL, PARAMETER :: f(Nch) = (/ ((i-1), i=rch(1),rch(2)) /)
    REAL(rm) :: X(4,Nch), Xinv(4,4), Avec(4,24:25), B(4,Nch)
    REAL :: apod(DACSchans,24:25), spurmag(2,24:25)
    REAL :: NoiseInflationFactor(24:25)
    REAL, PARAMETER :: MaxNoiseInflationFactor = 3.0
    REAL, PARAMETER :: MinSZA(24:25) = (/ 100.0, 0.0 /)

    TYPE (L1BData_T) :: L1BData
    TYPE (DataProducts_T) :: DACsDS  

    CHARACTER(len=26), PARAMETER :: DACS_Name(24:25) = (/ &
         "R3:240.B24D:O3.S0.DACS-3  ", "R3:240.B25D:CO.S1.DACS-1  " /)
    LOGICAL :: deconvolved

!=============================================================================

    IF (.NOT. L1Config%Calib%CalibDACS) RETURN   ! Nothing to do

    PRINT *, 'Finalizing DACS data...'

! Initialize attributes:

    apod = 0.0
    Avec = 0.0
    spurmag = 0.0
    NoiseInflationFactor = 0.0

! Get altitude and SZA (GHz):

    sd_id = L1BFileInfo%OAid

    CALL ReadL1BData (sd_id, '/GHz/GeodAlt', L1BData, noMAFs, Flag, &
         NeverFail=.TRUE., HDFversion=5)
    ALLOCATE (alt(MIFsGHz,noMAFs))
    alt = L1BData%DpField(1,:,:)
    CALL DeallocateL1BData (L1BData)

    CALL ReadL1BData (sd_id, '/GHz/SolarZenith', L1BData, noMAFs, Flag, &
         NeverFail=.TRUE., HDFversion=5)
    ALLOCATE (sza(MIFsGHz,noMAFs))
    sza = L1BData%DpField(1,:,:)
    CALL DeallocateL1BData (L1BData)

! Set up for HDF output:

    CALL Deallocate_DataProducts (DACsDS)
    ALLOCATE (DACsDS%Dimensions(3))
    DACsDS%data_type = 'real'
    DACsDS%Dimensions(1) = 'chanDACS'
    DACsDS%Dimensions(2) = 'GHz.MIF             '
    DACsDS%Dimensions(3) = 'MAF                 '

! get Band 24/25 data:

    sd_id = L1BFileInfo%RADDid

    DO bno = 25, 24, -1

       IF (.NOT. IsHDF5DSPresent (sd_id, TRIM(DACS_Name(bno)))) CYCLE

       CALL ReadL1BData (sd_id, DACS_Name(bno), L1BData, noMAFs, Flag, &
            NeverFail=.TRUE., HDFversion=5)
       ALLOCATE (rad(DACSchans,MIFsGHz,noMAFs))
       rad = L1BData%DpField(:,:,:)
       CALL DeallocateL1BData (L1BData)

       CALL ReadL1BData (sd_id, TRIM(DACS_Name(bno))//' precision', L1BData, &
            noMAFs, Flag, NeverFail=.TRUE., HDFversion=5)
       ALLOCATE (rad_prec(DACSchans,MIFsGHz,noMAFs))
       rad_prec = L1BData%DpField(:,:,:)
       CALL DeallocateL1BData (L1BData)

! Overwrite channels 110:129 with average of channels 100:110:

       DO maf = 1, noMAFs
          DO mif = 1, MIFsGHz
             rad(110:129,mif,maf) = SUM(rad(100:110,mif,maf)) / 11
          ENDDO
       ENDDO
       rad_prec(110:129,:,:) = -1 * ABS(rad_prec(110:129,:,:))  ! Negate precs

! Mean over good, high altitude data:

       Y = 0.0
       Ycount = 0
       DO maf = 1, noMAFs
          DO mif = 1, MIFsGHz
             IF (alt(mif,maf) >= MinAlt .AND. alt(mif,maf) <= MaxAlt .AND. &
                  sza(mif,maf) > MinSZA(bno)) THEN
                DO ch = rch(1), rch(2)  ! channel range
                   IF (rad_prec(ch,mif,maf) > 0.0) THEN
                      i = ch - rch(1) + 1
                      Y(i) = Y(i) + rad(ch,mif,maf)
                      yCount(i) = yCount(i) + 1
                   ENDIF
                ENDDO
             ENDIF
          ENDDO
       ENDDO

       DO ch = 1, Nch
          IF (Ycount(ch) > 0) Y(ch) = Y(ch) / Ycount(ch)
       ENDDO

! High altitude model radiances:

       X(1,:) = 2*EXP(-((f-cen(bno))/dopp(bno))**2/2)
       X(2,:) = EXP(-((f-cen(bno)-spur)/dopp(bno))**2/2) + &
            EXP(-((f-cen(bno)+spur)/dopp(bno))**2/2)
       X(3,:) = EXP(-((f-cen(bno)-2*spur)/dopp(bno))**2/2) + &
            EXP(-((f-cen(bno)+2*spur)/dopp(bno))**2/2)
       X(4,:) = 1.0
       Xinv = MATMUL (X, TRANSPOSE(X))

       CALL MatrixInversion (Xinv)

       B = MATMUL (Xinv, X)
       Avec(:,bno) = MATMUL (B, Y)
       ! Do Avec sum == 0?
       if ( SUM (Avec(1:3,bno)) /= 0. ) then

         spurmag(1,bno) = Avec(2,bno) / SUM (Avec(1:3,bno))
         spurmag(2,bno) = Avec(3,bno) / SUM (Avec(1:3,bno))

         DO i = 1, DACSchans
            apod(i,bno) = 1.0 / (1 + spurmag(1,bno)*(COS(5e6/7*Pi/1.25e7 * &
                 (i-1)) - 1) + spurmag(2,bno)*(COS(2*5e6/7*Pi/1.25e7 * (i-1))-1))
         ENDDO

         NoiseInflationFactor(bno) = SQRT (SUM(apod(:,bno)**2) / 129)
         deconvolved = .FALSE.

         IF (L1Config%Output%DeconvolveDACS) THEN

            IF (NoiseInflationFactor(bno) < MaxNoiseInflationFactor) THEN

  ! Deconvolve:

               CALL DeconvolveRads (rad, apod(:,bno))
               deconvolved = .TRUE.

  ! Scale precisions:

               rad_prec = rad_prec * NoiseInflationFactor(bno)

            ELSE
               rad_prec = -1 * ABS(rad_prec)  ! Negate precs
            ENDIF

         ENDIF
       else
         call output ( 'SUM (Avec(1:3,bno)) vanishes', advance='yes' )
         call outputNamedValue ( 'band no, maf: ', (/ bno, maf /) )
       ENDIF

! Output Band rads:

       DACsDS%name = DACS_Name(bno)
       DO maf = 1, noMAFS
          CALL Build_MLSAuxData (sd_id, DACsDS, rad(:,:,maf), &
               lastIndex=maf, disable_attrib=.TRUE.)
       ENDDO

! Output Band precisions:

       DACsDS%name = TRIM(DACS_Name(bno))//' precision'
       DO maf = 1, noMAFS
          CALL Build_MLSAuxData (sd_id, DACsDS, rad_prec(:,:,maf), &
               lastIndex=maf, disable_attrib=.TRUE.)
       ENDDO

       DEALLOCATE (rad, stat=status)
       DEALLOCATE (rad_prec, stat=status)
    ENDDO

    ! DEALLOCATE (rad, stat=status)
    ! DEALLOCATE (rad_prec, stat=status)

! Output attribute vectors:

    CALL h5gopen_f (sd_id, '/', grp_id, status)
    CALL MakeHDF5Attribute (grp_id, 'apodB24', apod(:,24), .TRUE.)
    CALL MakeHDF5Attribute (grp_id, 'apodB25', apod(:,25), .TRUE.)
    CALL MakeHDF5Attribute (grp_id, 'AvecB24', Avec(:,24), .TRUE.)
    CALL MakeHDF5Attribute (grp_id, 'AvecB25', Avec(:,25), .TRUE.)
    CALL MakeHDF5Attribute (grp_id, 'spurmagB24', spurmag(:,24), .TRUE.)
    CALL MakeHDF5Attribute (grp_id, 'spurmagB25', spurmag(:,25), .TRUE.)
    CALL MakeHDF5Attribute (grp_id, 'NoiseInflationFactorB24', &
         NoiseInflationFactor(24:24), .TRUE.)
    CALL MakeHDF5Attribute (grp_id, 'NoiseInflationFactorB25', &
         NoiseInflationFactor(25:25), .TRUE.)
    CALL MakeHDF5Attribute (grp_id, 'DACsDeconvolved', deconvolved, .TRUE.)

  END SUBROUTINE FinalizeDACSdata

!=============================================================================
  SUBROUTINE DeconvolveRads (rad, apod)
!=============================================================================

    USE MLSCommon, ONLY: r8
    USE DFFT_m, ONLY: DRFT1

    REAL, DIMENSION(:,:,:), INTENT(INOUT) :: rad
    REAL, DIMENSION(:), INTENT(IN) :: apod

    REAL(r8) :: dacs_dat(256), S(256)
    INTEGER :: ms, maf, MAFs, mif, MIFs

    MIFs = SIZE (rad(1,:,1))
    MAFs = SIZE (rad(1,1,:))

    ms = 0
    DO mif = 1, MIFs
       DO maf = 1, MAFs
          dacs_dat(1:129) = rad(:,mif,maf)
          dacs_dat(130:256) = dacs_dat(128:2:-1)

! Analyze:

          CALL DRFT1 (dacs_dat, 'A', 8, ms, S)

! Apodize:

          dacs_dat(1) = dacs_dat(1) * apod(1)
          dacs_dat(2) = dacs_dat(2) * apod(129)
          dacs_dat(3:255:2) = dacs_dat(3:255:2) * apod(2:128)
          dacs_dat(4:256:2) = dacs_dat(4:256:2) * apod(2:128)

! Synthesize:

          CALL DRFT1 (dacs_dat, 'S', 8, ms, S)
          rad(:,mif,maf) = dacs_dat(1:129)

       ENDDO
    ENDDO

  END SUBROUTINE DeconvolveRads

  LOGICAL FUNCTION not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (len=*), PARAMETER :: IdParm = &
       "$Id: DACsUtils.f90,v 2.17 2014/05/01 15:09:16 pwagner Exp $"
  CHARACTER (len=LEN(idParm)), SAVE :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  END FUNCTION not_used_here
END MODULE DACsUtils

! $Log: DACsUtils.f90,v $
! Revision 2.17  2014/05/01 15:09:16  pwagner
! Fixed problem causing hangs with ifort v14
!
! Revision 2.16  2009/05/13 20:33:05  vsnyder
! Get constants from Constants, kinds from MLSKinds
!
! Revision 2.15  2007/06/07 21:56:52  pwagner
! Gets derfi from lib
!
! Revision 2.14  2006/08/02 18:53:09  perun
! Define and make public TPz
!
! Revision 2.13  2006/06/14 13:44:55  perun
! Add TP digital and moved scaling DACS_dat to SortQualify routine
!
! Revision 2.12  2006/04/05 18:10:32  perun
! Remove unused variables
!
! Revision 2.11  2005/10/10 19:08:40  perun
! Test DeconvolveDACS flag and add appropriate attribute to output file
!
! Revision 2.10  2005/06/23 18:41:35  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.9  2005/05/02 16:01:50  perun
! Deallocate last rad and rad_prec pointers
!
! Revision 2.8  2005/01/25 15:19:20  perun
! Add TRIM to remove possible extra blank in precision dataset
!
! Revision 2.7  2004/12/01 17:08:56  perun
! Add routines to deconvolve and remove spurs
!
! Revision 2.6  2004/05/14 15:59:11  perun
! Version 1.43 commit
!
! Revision 2.5  2004/01/09 17:46:22  perun
! Version 1.4 commit
!
! Revision 2.4  2003/08/15 14:25:04  perun
! Version 1.2 commit
!
! Revision 2.3  2003/03/25 19:53:54  perun
! Test D before bit test
!
! Revision 2.2  2003/01/31 18:13:34  perun
! Version 1.1 commit
!
! Revision 2.1  2002/03/29 20:20:16  perun
! Version 1.0 commit
!
!
@


2.17
log
@Fixed problem causing hangs with ifort v14
@
text
@d454 1
d462 1
d596 2
d599 2
a600 2
       spurmag(1,bno) = Avec(2,bno) / SUM (Avec(1:3,bno))
       spurmag(2,bno) = Avec(3,bno) / SUM (Avec(1:3,bno))
d602 4
a605 4
       DO i = 1, DACSchans
          apod(i,bno) = 1.0 / (1 + spurmag(1,bno)*(COS(5e6/7*Pi/1.25e7 * &
               (i-1)) - 1) + spurmag(2,bno)*(COS(2*5e6/7*Pi/1.25e7 * (i-1))-1))
       ENDDO
d607 2
a608 2
       NoiseInflationFactor(bno) = SQRT (SUM(apod(:,bno)**2) / 129)
       deconvolved = .FALSE.
d610 1
a610 1
       IF (L1Config%Output%DeconvolveDACS) THEN
d612 1
a612 1
          IF (NoiseInflationFactor(bno) < MaxNoiseInflationFactor) THEN
d614 1
a614 1
! Deconvolve:
d616 2
a617 2
             CALL DeconvolveRads (rad, apod(:,bno))
             deconvolved = .TRUE.
d619 1
a619 1
! Scale precisions:
d621 1
a621 1
             rad_prec = rad_prec * NoiseInflationFactor(bno)
d623 3
a625 3
          ELSE
             rad_prec = -1 * ABS(rad_prec)  ! Negate precs
          ENDIF
d627 4
d719 1
a719 1
       "$Id: DACsUtils.f90,v 2.16 2009/05/13 20:33:05 vsnyder Exp $"
d727 3
@


2.16
log
@Get constants from Constants, kinds from MLSKinds
@
text
@a535 2
       DEALLOCATE (rad, stat=status)
       DEALLOCATE (rad_prec, stat=status)
d540 2
d641 2
d645 2
a646 2
    DEALLOCATE (rad, stat=status)
    DEALLOCATE (rad_prec, stat=status)
d711 1
a711 1
       "$Id: DACsUtils.f90,v 2.15 2007/06/07 21:56:52 pwagner Exp $"
d719 3
@


2.15
log
@Gets derfi from lib
@
text
@d452 7
a459 1
    USE MLSCommon, ONLY: rm
a460 6
    USE MLS_DataProducts, ONLY: DataProducts_T, Deallocate_DataProducts
    USE MLSAuxData, ONLY: Build_MLSAuxData
    USE MLSHDF5, ONLY: IsHDF5DSPresent, MakeHDF5Attribute
    USE HDF5, ONLY: h5gopen_f
    USE MatrixModule_0, ONLY: MatrixInversion
    USE units, ONLY: Pi
d709 1
a709 1
       "$Id: DACsUtils.f90,v 2.14 2006/08/02 18:53:09 perun Exp $"
d717 3
@


2.14
log
@Define and make public TPz
@
text
@d385 1
a385 1
    USE MathUtils, ONLY: derfi
d709 1
a709 1
       "$Id: DACsUtils.f90,v 2.13 2006/06/14 13:44:55 perun Exp $"
d717 3
@


2.13
log
@Add TP digital and moved scaling DACS_dat to SortQualify routine
@
text
@d18 1
d25 1
a25 1
  PUBLIC :: FinalizeDACSdata
d28 1
d709 1
a709 1
       "$Id: DACsUtils.f90,v 2.12 2006/04/05 18:10:32 perun Exp $"
d717 3
@


2.12
log
@Remove unused variables
@
text
@d1 1
a1 1
! Copyright 2005, by the California Institute of Technology. ALL
d29 1
a29 1
  character (len=*), private, parameter :: ModuleName= &
d31 1
a31 1
  private :: not_used_here 
d197 1
d199 1
d379 1
a379 1
  SUBROUTINE ProcessUnpackedDACS (D, R2a, nchans, TP, DACS_dat)
d385 4
a388 3
    REAL :: R2a(DACSchans)
    INTEGER :: D(4), TP, nchans
    REAL :: DACS_dat(DACSchans)
d411 1
d413 1
d417 1
d419 1
d442 1
a442 1
  DACS_dat = R_FFT(1:129) * TP
d704 1
a704 1
  logical function not_used_here()
d706 3
a708 3
  character (len=*), parameter :: IdParm = &
       "$Id: DACsUtils.f90,v 2.11 2005/10/10 19:08:40 perun Exp $"
  character (len=len(idParm)), save :: Id = idParm
d711 1
a711 1
  end function not_used_here
d715 3
@


2.11
log
@Test DeconvolveDACS flag and add appropriate attribute to output file
@
text
@d443 1
a443 1
    USE MLSL1Common, ONLY: L1BFileInfo, DACSchans, DACSnum
d700 1
a700 1
       "$Id: DACsUtils.f90,v 2.10 2005/06/23 18:41:35 pwagner Exp $"
d708 3
@


2.10
log
@Reworded Copyright statement, moved rcs id
@
text
@d30 1
a30 1
       "$RCSfile: $"
a425 2
! Apodize here?

d479 1
d595 3
d599 1
a599 1
       IF (NoiseInflationFactor(bno) < MaxNoiseInflationFactor) THEN
d603 2
a604 1
          CALL DeconvolveRads (rad, apod(:,bno))
d608 7
a614 1
          rad_prec = rad_prec * NoiseInflationFactor(bno)
d618 5
a622 9
          DACsDS%name = DACS_Name(bno)
          DO maf = 1, noMAFS
             CALL Build_MLSAuxData (sd_id, DACsDS, rad(:,:,maf), &
                  lastIndex=maf, disable_attrib=.TRUE.)
          ENDDO

       ELSE
          rad_prec = -1 * ABS(rad_prec)  ! Negate precs
       ENDIF
d650 1
d700 1
a700 1
       "$Id: $"
d708 3
@


2.9
log
@Deallocate last rad and rad_prec pointers
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d28 5
a32 5
  !------------------------------- RCS Ident Info ------------------------------
  CHARACTER(LEN=130) :: id = &
       "$Id: DACsUtils.f90,v 2.8 2005/01/25 15:19:20 perun Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: DACsUtils.f90,v $"
  !-----------------------------------------------------------------------------
d691 8
d702 3
@


2.8
log
@Add TRIM to remove possible extra blank in precision dataset
@
text
@d22 1
a22 1
       "$Id: DACsUtils.f90,v 2.7 2004/12/01 17:08:56 perun Exp $"
d621 3
d686 3
@


2.7
log
@Add routines to deconvolve and remove spurs
@
text
@d22 1
a22 1
       "$Id: DACsUtils.f90,v 2.6 2004/05/14 15:59:11 perun Exp $"
d613 1
a613 1
       DACsDS%name = DACS_Name(bno)//' precision'
d683 3
@


2.6
log
@Version 1.43 commit
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d9 1
d16 1
d22 1
a22 1
       "$Id: DACsUtils.f90,v 2.5 2004/01/09 17:46:22 perun Exp $"
d433 247
d683 3
@


2.5
log
@Version 1.4 commit
@
text
@d20 1
a20 1
       "$Id: DACsUtils.f90,v 2.4 2003/08/15 14:25:04 perun Exp $"
d390 5
d434 3
@


2.4
log
@Version 1.2 commit
@
text
@d20 1
a20 1
       "$Id: DACsUtils.f90,v 2.3 2003/03/25 19:53:54 perun Exp $"
d93 2
a94 1
    INTEGER, INTENT(OUT) :: C(*), D(4), TP, DIO, Zlag, LO
a294 11
!!$                write (66, *) 'DACSno, mifno, e, ebitvntot, median: ', &
!!$                     DACSno, MIFno, E, EbitVal, Ntot(MIFno), median
!!$                write (66, *) "D(curr): ", DACS_MAF(MIFno)%D(:,DACSno)
!!$                write (66, *) "D(prev): ", DACS_MAF(MIFno-1)%D(:,DACSno)
!!$                write (66, *) "D(next): ", DACS_MAF(MIFno+1)%D(:,DACSno)
!!$                write (66, "(i6, ':', B20)") (DACS_MAF(MIFno)%D(i,DACSno), &
!!$                     DACS_MAF(MIFno)%D(i,DACSno),i=1,4)
!!$                write (66, *) "IntBit1: ", IntBit1
!!$                write (66, *) "Zmatch: ", Zmatch
!!$                write (66, *) "NumZmatch: ", NumZmatch

d308 2
a309 1
    INTEGER :: C_K(*), D(4), nchans
d311 1
a311 1
    REAL :: R2a(*)
d330 2
a331 2
    INTEGER :: C(*)
    REAL :: R2a(*)
d349 4
a352 2
    INTEGER :: K(*), nchans
    REAL :: R2a(*), Ntot3
d429 3
@


2.3
log
@Test D before bit test
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d20 1
a20 1
       "$Id: DACsUtils.f90,v 2.2 2003/01/31 18:13:34 perun Exp $"
d99 1
a99 1
    INTEGER :: bitmask7, signmask7, bitmask11, signmask11
d104 1
d121 1
a121 1
       i12 = IAND (i12, z'FFF')        ! mask off upper 4 bits
d436 3
@


2.2
log
@Version 1.1 commit
@
text
@d20 1
a20 1
       "$Id: DACsUtils.f90,v 2.1 2002/03/29 20:20:16 perun Exp $"
d237 6
a242 4
                   DO
                      IF (BTEST (DACS_MAF(MIFno)%D(i,DACSno), BitNo)) EXIT
                      BitNo = BitNo + 1
                   ENDDO
d435 3
@


2.1
log
@Version 1.0 commit
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d12 4
a17 1
  PRIVATE :: Id, ModuleName
d20 2
a21 2
       "$Id: $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: $"
d26 1
d28 1
d49 3
a51 1
  SUBROUTINE ExtractDACSdata (rawdata, K, D, TP, DIO, LO, nchans)
d55 1
a55 1
    INTEGER, INTENT(OUT) :: D(4), TP, DIO, LO, nchans
d57 1
a57 1
    INTEGER :: i, offset
d88 3
a90 1
  SUBROUTINE UncompressDACSdata (rawdata)
d93 1
a94 1
    INTEGER :: C(128), D(4), TP, DIO, Zlag, LO
d99 5
a103 4
    INTEGER, PARAMETER :: bitmask7 = z'80'
    INTEGER, PARAMETER :: signmask7 = z'FFFFFF00'
    INTEGER, PARAMETER :: bitmask11 = z'800'
    INTEGER, PARAMETER :: signmask11 = z'FFFFF000'
d160 213
a372 1
  SUBROUTINE ProcessDACSdata (D, DACS_K, nchans, TP, DACS_dat)
d377 1
a377 1
    INTEGER :: DACS_K(DACSchans)
d381 2
a382 2
    INTEGER :: Dtot, DIO, LO, i
    REAL(r8) :: lag0, offset, rho_hat, rho(DACSchans), P_thold, N_thold, Z_thold
a390 1
    offset = 3.0 * SUM (D)
a392 1
    lag0 = DACS_K(1) - offset
a398 1
!PRINT *, "P/N/Z_thold: ", REAL(P_thold), REAL(N_thold), REAL(Z_thold)
d408 4
a411 10
       IF (lag0 /= 0.0) THEN
          rho_hat = (DACS_K(i) - offset) / lag0
       ELSE
          rho_hat = 0.0
       ENDIF
       rho(i) = C(1) * rho_hat + C(2) * rho_hat**3 + C(3) * rho_hat**5 + &
            C(4) * rho_hat**7 + C(5) * SIN(rho_hat * C(12)) * M + &
            C(6) * SIN(rho_hat * C(13)) * M**2 &
            + C(7) * SIN(rho_hat * C(14)) * M + C(8) * A**2 + &
            C(9) * A**2 * rho_hat + C(10) * Z_thold**2 * rho_hat + &
a416 4

!  rho = rho * TP
! print *, 'rho: ', rho

a426 3
!!$    if (d(1) == 48303 .and. d(2) == 81510) then
!!$       print *, DACS_dat
!!$    endif
d428 1
a428 1
  END SUBROUTINE ProcessDACSdata
d432 4
a435 1
! $Log: $
@

