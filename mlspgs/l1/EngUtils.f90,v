head	2.16;
access;
symbols
	v5-02-NRT-19:2.16
	v6-00:2.15
	v5-02-NRT-18:2.15
	v5-02:2.15
	v5-01-NRT-17:2.15
	v5-01-NRT-16:2.15
	v5-01-NRT-15:2.15
	v5-01-NRT-14:2.15
	neuralnetworks-1-0:2.15.0.10
	cfm-single-freq-0-1:2.15.0.8
	v5-01:2.15
	v5-00:2.15
	v4-23-TA133:2.15.0.6
	mus-emls-1-70:2.15.0.4
	rel-1-0-englocks-work:2.15.0.2
	VUMLS1-00:2.15
	VPL1-00:2.15
	V4-22-NRT-08:2.15
	whdrel10_merged_to_here:2.15
	merge_whdrel10_from_here:2.14.4.1
	TAG_TRUNK_AFTER_PW_CHANGES:2.14
	TAG_TRUNK_BEFORE_PW_CHANGES:2.14
	VAM1-00:2.14
	whd-rel-1-0:2.14.0.4
	V4-21:2.14.0.2
	V4-13:2.12
	V4-12:2.12
	V4-11:2.12
	V4-10:2.12
	V3-43:2.12
	M4-00:2.12
	V3-41:2.12
	V3-40-PlusGM57:2.12.0.2
	V2-24-NRT-04:2.11
	V3-33:2.12
	V2-24:2.11
	V3-31:2.12
	V3-30-NRT-05:2.12
	cfm-01-00:2.12
	V3-30:2.12
	V3-20:2.12
	V3-10:2.12
	V2-23-NRT-02:2.11
	V2-23:2.11
	V2-22-NRT-01:2.11
	V2-22:2.11
	V2-21:2.11
	V2-20:2.11
	V2-11:2.11
	V2-10:2.11
	V2-00:2.10
	V1-51:2.9
	V1-50:2.9
	V1-45:2.8
	V1-44:2.8
	V1-43:2.8
	V1-42:2.7
	V1-41:2.7
	V1-32:2.6
	V1-40:2.7
	V1-31:2.6
	V1-30:2.6
	V1-13:2.4
	V1-12:2.4
	V1-11:2.4
	V1-10:2.4
	newfwm-feb03:2.4.0.2
	V1-04:2.3
	V1-03:2.3
	V1-02:2.3
	V1-00:2.3
	newfwm-sep01:2.2.0.2
	V0-7:2.2
	V0-5-Level2:2.2
	V0-5-SIPS:2.2;
locks; strict;
comment	@# @;


2.16
date	2024.10.10.20.15.54;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2016.03.15.22.17.59;	author whdaffer;	state Exp;
branches;
next	2.14;

2.14
date	2015.01.21.19.30.19;	author pwagner;	state Exp;
branches
	2.14.4.1;
next	2.13;

2.13
date	2015.01.14.00.32.53;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2008.05.06.15.56.44;	author perun;	state Exp;
branches;
next	2.11;

2.11
date	2006.08.02.18.53.41;	author perun;	state Exp;
branches;
next	2.10;

2.10
date	2005.06.23.18.41.35;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2004.11.10.15.33.40;	author perun;	state Exp;
branches;
next	2.8;

2.8
date	2004.05.14.15.59.11;	author perun;	state Exp;
branches;
next	2.7;

2.7
date	2004.01.09.17.46.22;	author perun;	state Exp;
branches;
next	2.6;

2.6
date	2003.09.15.17.15.53;	author perun;	state Exp;
branches;
next	2.5;

2.5
date	2003.08.15.14.25.04;	author perun;	state Exp;
branches;
next	2.4;

2.4
date	2003.01.31.18.13.34;	author perun;	state Exp;
branches;
next	2.3;

2.3
date	2002.03.29.20.18.34;	author perun;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.23.18.55.17;	author perun;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.23.18.53.47;	author perun;	state Exp;
branches;
next	;

2.14.4.1
date	2015.10.09.10.21.38;	author whdaffer;	state Exp;
branches;
next	;


desc
@@


2.16
log
@Reduce routine messaging
@
text
@! Copyright 2006, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
MODULE EngUtils   ! Engineering utilities
!=============================================================================

  USE MLSCommon, ONLY: r8
  USE MLSL1Utils, ONLY: QNan, BigEndianStr, Finite
  use MLSFillValues, only: isNaN

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: NextEngMAF

!---------------------------- RCS Module Info ------------------------------
  CHARACTER (len=*), PRIVATE, PARAMETER :: ModuleName= &
       "$RCSfile: EngUtils.f90,v $"
  PRIVATE :: not_used_here 
!---------------------------------------------------------------------------

CONTAINS

  FUNCTION Cal_freq (meas_freq, hi_freq, lo_freq, hi_cal, lo_cal) RESULT (freq)

    !! Calibrate the measured frequency against the calibration frequencies and
    !! their corresponding parameter values.  

    !! See Eq. 5.3, sec 5 in the _MLS Level Algorithmic Theoretical Basis_
    !! (ATB) version 2.0)

    !--------Arguments--------!
    INTEGER, INTENT(IN) :: meas_freq  ! measured frequency
    INTEGER, INTENT(IN) :: hi_freq    ! "high" calibration frequency
    INTEGER, INTENT(IN) :: lo_freq    ! "low" calibration frequency
    REAL, INTENT(IN) :: hi_cal        ! "high" calibration parameter
    REAL, INTENT(IN) :: lo_cal        ! "low" calibration parameter

    REAL :: freq                      ! calculated frequency

    IF ((lo_freq == 0) .OR. (hi_freq == 0) .OR. (meas_freq == 0.0) .OR. &
         (hi_freq == lo_freq)) THEN
       freq = QNan()
    ELSE
       freq = (REAL(meas_freq - lo_freq) / (hi_freq - lo_freq)) * &
            & (hi_cal - lo_cal) + lo_cal
    ENDIF

  END FUNCTION Cal_freq

  FUNCTION Therm_temp (rin) RESULT (T)

    !! See Eq.s 5.5, 5.6, Sec 5.1.3, page 49 of the MLS Level 1 ATB document
    !! (rev 2.0)
    !!

    !! Convert thermistor (ohms) to temperature (C) */
    !!
    !! The thermistor is a YSI 44906 in parallel with a 4.99 K ohm resistor.
    !!
    !! input:
    !!         rin: measured thermistor resistance (ohms)
    !! output:
    !!         T:   temperature (C)
    !!

    !--------Arguments--------!
    REAL, INTENT(IN) :: rin
    REAL :: T

    !----------Local vars----------!
    REAL :: rth_log

    !--------Parameters------------!
    REAL(r8), PARAMETER :: a = 1.286212e-3
    REAL(r8), PARAMETER :: b = 2.355213e-4
    REAL(r8), PARAMETER :: c = 9.826046e-8
    REAL(r8), PARAMETER :: d = 8.835732e-8

    REAL, PARAMETER :: abs_zero = -273.16
    REAL, PARAMETER :: rmax = 4990.0

    IF (.NOT. Finite (rin)) THEN  ! Nothing to be done
       T = Qnan()
    ELSE IF (rin >= rmax) THEN  ! over the maximum ohms
       T = -100.0               ! minimum possible temperature
    ELSE IF (rin <= 0.0) THEN   ! under the minimum ohms
       T = 500.0                ! maximum possible temperature
    ELSE
       rth_log = LOG ((rmax * rin) / (rmax - rin)) ! log(Eq 5.5, pg 49)
       T = 1.0 / (a + rth_log * (b + rth_log * (c + rth_log * d))) + abs_zero
    ENDIF

  END FUNCTION Therm_temp

  FUNCTION PRD_temp (rin, r0) RESULT (T)

    !! See Eq. 5.4, Sec 5.1.1, pg 48 of MLS Level 1 ATB (v2.0)
    !!
    !!

    !! Convert PRD (ohms) to temperature (C)
    !! inputs:
    !!         rin: measured PRD resistance (ohms)
    !!         r0:  PRD resistance at 0 C (ohms)
    !! output:
    !!         T:   temperature (C)

    !--------Arguments--------!
    REAL, INTENT(IN) :: rin
    REAL, INTENT(IN) :: r0
    REAL :: T

    !----------Local vars----------!
    REAL(r8), PARAMETER :: a = 0.48945548411
    REAL(r8), PARAMETER :: b = 7.20107099888e-5
    REAL :: r

    r = rin * 500.0 / r0
    T = a * (r - 500.0) / (1.0 - b * r)

  END FUNCTION PRD_temp

  FUNCTION Use_equation (mnemonic, tval) RESULT (val)

    ! Use equation to scale analog telemetry

    ! inputs:
    !          mnemonic: telemetry mnemonic
    !          tval: input telemetry value

    !--------Arguments--------!
    CHARACTER (LEN=*), INTENT(IN) :: mnemonic
    REAL, INTENT(IN)  :: tval

    REAL :: val

    val = tval

    ! check mnemonic for equation to use

    IF (INDEX (mnemonic, "_Bus") /= 0) THEN
       IF (INDEX (mnemonic, "_V") /= 0) THEN
          IF (INDEX (mnemonic, "Quiet") /= 0) THEN
             val = (tval - 0.3113) / 0.1183   ! Quiet Bus Voltage
          ELSE IF (INDEX (mnemonic, "Device") /= 0) THEN
             val = (tval - 0.2638) / 0.1192   ! Device Bus Voltage
          ENDIF
       ELSE IF (INDEX (mnemonic, "_I") /= 0) THEN
          IF (INDEX (mnemonic, "Quiet") /= 0) THEN
             val = (-0.156313 + SQRT (0.156313 * 0.156313 - 4.0 * 0.00026955 * &
                  (0.361124 - tval))) / (2 * 0.00026955)  ! Quiet Bus Current
          ELSE IF (INDEX (mnemonic, "Device") /= 0) THEN
             val = 1.36 * (tval - 0.4852) / (1.3635 - 0.4852) ! Device Bus I
           ENDIF
       ENDIF
    ELSE IF (INDEX (mnemonic, "R4_IF_voltage") /= 0) THEN
       IF (tval > 0.0) THEN
          val = 8.4459 * LOG (tval) - 47.755  ! R4 IF Voltage
       ELSE
          val = QNan()
       ENDIF
    ENDIF

  END FUNCTION Use_equation


  SUBROUTINE ConvertEngCounts (GMAB_ON)

    !! Convert the raw counts into engineering units. The input engineering data
    !! is stored in the module variable EngPkt, which stores one MAF of
    !! Engineering data and is filled in each call to NextEngMaf, which calls
    !! this routine.

    USE EngTbls, ONLY: Eng_tbl, Riu_tbl, EngPkt, last_tlm_pt, temp_cal, &
     & vin_cal1, vin_cal2, prt1_cal1, prt1_cal2, prt2_cal1, prt2_cal2, &
     & ysi_cal1, ysi_cal2, Cal_const

    USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Info,MLSMSG_Warning
    USE SDPToolkit, ONLY: PGS_TD_TAItoUTC
    LOGICAL, DIMENSION(:) :: GMAB_ON

    INTEGER :: i, n, dn, pkt_no, riu_no, byte1,rs
    REAL :: scale

    REAL, PARAMETER :: abs_zero = -273.16
    REAL(r8) TAI93


    LOGICAL :: FoundBadPoints=.FALSE.

    CHARACTER(len=27) :: asciiUTC
    CHARACTER(len=256) :: msg
    INTEGER, EXTERNAL :: PGS_TD_EOSPMGIRDtoTAI
    logical, parameter :: DeeBug = .false.



! Extract the raw counts. For each RIU

    DO i = 1, SIZE(Riu_tbl) ! count RIUs
      
      ! Here 'i' is the RIU number.
      
      pkt_no = Riu_tbl(i)%pkt_no ! pkt for this RIU
      byte1 = Riu_tbl(i)%start_byte ! starting byte for this RIU

      Riu_tbl(i)%id_word = BigEndianStr (EngPkt(pkt_no)(byte1:byte1+1))

      DO n = Riu_tbl(i)%first_pt, Riu_tbl(i)%last_pt
        ! <whd> 
        ! {first,last}_pt are actually the first and last line numbers in the
        ! eng tables file (currently named engtlm.tbl) which mentions RIU(i);
        ! it is *not* a telemetry value!  Their purpose here is just to count
        ! the number of bytes that need to be extracted from this packet for
        ! this RIU

        ! So all that's really important here is the number of lines for this
        ! RIU, i.e.  nLines = Riu_tbl(i)%last_pt - Riu_tbl(i)%first_pt+1

        byte1 = byte1 + 2    ! next word

        ! so the packet is arranged as: (all quantities are 2-byte long)
        ! id 
        ! counts(mnem(1)) 
        ! counts(mnem(2))
        ! counts(mnem(3))
        ! ...
        ! counts(mnem(last_mnem)
        !!
        Eng_tbl(n)%counts = BigEndianStr (EngPkt(pkt_no)(byte1:byte1+1))


        ! <whd> why a special test for GM01_PRT1_Cal1 </whd>

        if ( n == 3 .and. Eng_tbl(n)%counts < 1 .and. DeeBug ) &
             & print *, 'Cal counts is <= 0 for Eng table at n ', n

        ! Save the calibration counts

        ! <whd> 
        ! cal_indx is index into the array EngTbls::Cal_Type_str, so
        ! Riu_tbl%cal_cnts has the same order as that array. Parameters that
        ! hold these indices are also defined in EngTbls ~line 49
        ! </whd>

        IF (Eng_tbl(n)%cal_indx > 0) THEN
          Riu_tbl(i)%Cal_cnts(Eng_tbl(n)%cal_indx) = Eng_tbl(n)%counts
          ! Don't know why ptr1_cal{1,2} also saves ptr2_cal{1,2}.
          IF (Eng_tbl(n)%cal_indx == prt1_cal1) THEN  ! save also as PRT-2's
            Riu_tbl(i)%Cal_cnts(prt2_cal1) = Eng_tbl(n)%counts
          ELSE IF (Eng_tbl(n)%cal_indx == prt1_cal2) THEN
            Riu_tbl(i)%Cal_cnts(prt2_cal2) = Eng_tbl(n)%counts
          ENDIF
        ENDIF

      ENDDO

    ENDDO

! Convert the counts

    ! <whd>
    ! `i' here is basically the lines of the engtlm.tbl file (excluding those in
    ! the `survival table', the file header, and section demarcating lines
    ! (i.e. those consisting of a line of dashes)
    ! </whd>

    DO i = 1, last_tlm_pt

      riu_no = Eng_tbl(i)%riu_no
      scale = Eng_tbl(i)%scale

      Eng_tbl(i)%value = QNan() ! assume the worst

      ! Skip the always bad THz sensor

      IF ((INDEX (Eng_tbl(i)%mnemonic, "THzAmbCalTgt_T2") /= 0) .OR. &
           (INDEX (Eng_tbl(i)%mnemonic, "THzAmbCalTgtRT2") /= 0)) CYCLE

      IF (riu_no >= 1 .AND. riu_no <= 4) THEN
        IF (.NOT. GMAB_ON(riu_no)) CYCLE     ! GMriu_no is NOT ON
        IF (MOD (riu_no, 2) == 0) THEN
          IF (GMAB_ON(riu_no-1)) CYCLE      ! Other related GMriu_no is ON
        ELSE
          IF (GMAB_ON(riu_no+1)) CYCLE      ! Other related GMriu_no is ON
        ENDIF
      ENDIF

      ! <whd>
      ! if id_word == 0, this RIU is off!
      ! Riu_tbl(riu_no)%id_word is the ID for the Riu_tbl(riu_no). The C&DH
      ! handbook (e.g. see pages 30-33, similarly for any fields marked
      ! [GMST]0[1-4]) Eng_tbl(i) the entry on the i-th non-trivial line in the
      ! engineering telemetry table file, currently called
      ! engtlm.tbl. Eng_tbl(i)%counts is read from the telemetry, using the pkt
      ! no and offset stored in Riu_tbl. Riu_tbl is filled in EngTbls.f90
      ! </whd>

      IF (Riu_tbl(riu_no)%id_word /= 0 .AND. &
           Eng_tbl(i)%counts > 0) THEN   
        ! RIU is on and there are non-zero counts: Data available to convert

        SELECT CASE (Eng_tbl(i)%type)

        CASE ("Cal")

          IF (Eng_tbl(i)%cal_indx /= temp_cal) THEN   ! not a temperature
            Eng_tbl(i)%value = Eng_tbl(i)%counts
          ELSE

            Eng_tbl(i)%value = Cal_freq ( Eng_tbl(i)%counts, & !measurement
                 & Riu_tbl(riu_no)%Cal_cnts(vin_cal1), & !high cal cnt
                 & Riu_tbl(riu_no)%Cal_cnts(vin_cal2), & !low cal cnt
                 & Cal_const(riu_no)%volts, & !high value
                 & 0.0) &                     !low value
                 & * 100.0 + abs_zero
          ENDIF

        CASE ("VIN")

          Eng_tbl(i)%value = Cal_freq (Eng_tbl(i)%counts, &
               & Riu_tbl(riu_no)%Cal_cnts(vin_cal1), &
               & Riu_tbl(riu_no)%Cal_cnts(vin_cal2), &
               & Cal_const(riu_no)%volts, 0.0)

          IF (scale /= 0.0) THEN
            Eng_tbl(i)%value = scale * Eng_tbl(i)%value
          ELSE
            Eng_tbl(i)%value = Use_equation (Eng_tbl(i)%mnemonic, &
                 & Eng_tbl(i)%value)
          ENDIF

        CASE ("PRT-1")

          dn = Eng_tbl(i)%counts
          IF (dn > 63000) dn = dn - 65536  ! adjust if DN is too high

          ! calls cal_freq inside PRT_temp. Commented to make that a bit
          ! clearer. Cases PRT-2, YSI-{1,2} are similar.

          Eng_tbl(i)%value = PRD_temp ( &
               & Cal_freq(dn, &
               &          Riu_tbl(riu_no)%Cal_cnts(prt1_cal1), &
               &          Riu_tbl(riu_no)%Cal_cnts(prt1_cal2), &
               &          Cal_const(riu_no)%prt1_hi, &
               &          Cal_const(riu_no)%prt1_low &
               &          ), &
               & scale)

        CASE ("PRT-2")

          Eng_tbl(i)%value = PRD_temp ( &
               Cal_freq( &
               &                       Eng_tbl(i)%counts, &
               &                       Riu_tbl(riu_no)%Cal_cnts(prt2_cal1), &
               &                       Riu_tbl(riu_no)%Cal_cnts(prt2_cal2), &
               &                       Cal_const(riu_no)%prt2_hi, &
               &                       Cal_const(riu_no)%prt2_low &
               &                       ), &
               &                scale)

        CASE ("YSI")

          Eng_tbl(i)%value = Therm_temp (&
               &              Cal_freq(&
               &                 Eng_tbl(i)%counts, &
               &                 Riu_tbl(riu_no)%Cal_cnts(ysi_cal1), &
               &                 Riu_tbl(riu_no)%Cal_cnts(ysi_cal2), &
               &                 Cal_const(riu_no)%therm_hi, Cal_const(riu_no)%therm_low &
               &                 ) &
               &               )

        CASE DEFAULT

          if ( DeeBug ) PRINT *, "Unknown tlm type!"  !! use standard routine here

        END SELECT

      ELSEIF ( i < 307 .or. i > 321 ) THEN
        !<whd:comment> 
!
        ! Riu_tbl(riu_no)%id_word /= 0 .OR.Eng_tbl(i)%counts <= 0, but i < 307
        ! or > 321. Lines 307-320 in engtlm.tbl correspond to GM15 and
        ! SM01. Comment below says those are always NaNs
!
        !</whd:comment> 
        if ( DeeBug ) PRINT *, 'Data not available to convert'
        IF (Eng_tbl(i)%mnemonic .eq. 'Spare') THEN
          if ( DeeBug ) print *,"But it's a `Spare', so we don't really care!"
        ELSE
          if ( DeeBug ) print *,"Mnemonic = ",Eng_tbl(i)%mnemonic
        ENDIF
      ENDIF
      ! Apparently values 307-320 are all NaNs Who wooda guessed!  
!
      ! Line numbers 307-320 in the engtlm.tbl file (not counting lines which
      ! exclude header, comments and section demarcating lines of all dashes)
      ! are for the GigaHertz switch network, which is only turned on and then
      ! immediately turned off, so these are, in a sense, bogus NaNs and are
      ! not reported. Hence their exclusion from the following code block
      IF ( isNaN(Eng_tbl(i)%value) .and. &
           & ( i < 307 .or. i > 321 ) &
           & ) THEN
        FoundBadPoints=.TRUE.
        if ( DeeBug ) then
          print *, i, 'th engineering value is a NaN'
          print *, 'type  ', Eng_tbl(i)%type
          print *, 'riu number ', riu_no
          print *, 'mnemonic ', trim(Eng_tbl(i)%mnemonic)
          if ( riu_no > 0 .and. riu_no < 5 ) print *, 'GMriu on? ', GMAB_ON(riu_no)
          if ( riu_no > 1 .and. riu_no < 6 .and. MOD (riu_no, 2) == 0 ) &
               & print *, 'prev GMriu on? ', GMAB_ON(riu_no-1)
          if ( riu_no > -1 .and. riu_no < 4 .and. MOD (riu_no, 2) /= 0 ) &
               & print *, 'next GMriu on? ', GMAB_ON(riu_no+1)
          print *, 'id_word ', Riu_tbl(riu_no)%id_word
          print *, 'counts ', Eng_tbl(i)%counts
        endif
      ENDIF
      ! So, it's because GMriu_no is NOT ON for these rius? Tell me, where is
      ! any of this documented? Does anyone here know anything? 
!
      ! (<whd> I'm presuming that vince wrote that last comment. As for me
      ! I have to say 'no', apparently no one here knows anything!</whd>)

    ENDDO ! loop over engtlm.tbl lines 

    IF (FoundBadPoints) THEN
       rs = PGS_TD_EOSPMGIRDtoTAI (engpkt(1)(8:15), TAI93)
       asciiUTC="BadTime"
       IF (rs /= 0) THEN 
          print *,"ConvertEngCounts: Can't get engineering packet TAI93 time!"
          CALL MLSMessage(MLSMSG_Warning,ModuleName, &
               &   "ConvertEngCounts: Can't get engineering packet TAI93 time!")          
       ELSE
          rs = PGS_TD_TAItoUTC (TAI93, asciiUTC)
       ENDIF
       write(msg,*) 'ConvertEngCounts: bad data! MIF time: '//trim(asciiUTC)
       print *,trim(msg)
       CALL MLSMessage(MLSMSG_Info,ModuleName, trim(msg))

    ENDIF
  END SUBROUTINE ConvertEngCounts

!=============================================================================
  SUBROUTINE NextEngMAF (more_data)
!=============================================================================

    USE EngTbls, ONLY: EngPkt, EngMAF, Eng_tbl
    USE L0Utils, ONLY: ReadL0Eng

    !! Get the next MAF's engineering data

    LOGICAL, INTENT (OUT) :: more_data

    LOGICAL :: data_OK, GMAB_ON(4)
    INTEGER :: maskbit3, maskbit7
    DATA maskbit3 / z'8' /
    DATA maskbit7 / z'80' /

! Save last A/B side readbacks ("A" side default):

    CHARACTER(len=1), SAVE :: ASE_Side = "A", GSM_Side = "A"

    DO
       CALL ReadL0Eng (EngPkt, EngMAF%MAFno, EngMAF%TotalMAF, &
            EngMAF%MIFsPerMAF, EngMAF%secTAI, data_OK, more_data)
       IF (.NOT. more_data) RETURN   ! nothing more to do
       IF (data_OK) EXIT
    ENDDO

    ! <whd:comment> 0.25 ~= 1.5 MIFs (MIF has a nominal dur of 1/6
    ! secs). Dominick thinks that the time in the engineering packets that goes
    ! with a particular set of science packets has a time tag about 1.5 MIFs
    ! later than the science packets they go with. However, in
    ! CalibWeightsFlags::ProcessMAFdata, the engineering data that's 'paired'
    ! with science data is selected from the previous Eng MAF.  See ~line 185,
    ! at the mention of NINT() </whd:comment>

    EngMAF%secTAI = EngMAF%secTAI - 0.25   ! vp's orig comment: actual time to line up with SCI

    ! Determine GM01 to GM04 A/B ON/OFF states:

    GMAB_ON(1) =(IAND (ICHAR (EngPkt(6)(103:103)), maskbit7) == maskbit7)
    GMAB_ON(2) =(IAND (ICHAR (EngPkt(6)(103:103)), maskbit3) == maskbit3)
    GMAB_ON(3) =(IAND (ICHAR (EngPkt(6)(109:109)), maskbit3) == maskbit3)
    GMAB_ON(4) =(IAND (ICHAR (EngPkt(6)(110:110)), maskbit7) == maskbit7)

    ! Determine which side ASE (GM01/GM02) is on:

    IF (GMAB_ON(1) .AND. .NOT. GMAB_ON(2)) THEN
       EngMAF%ASE_Side = "A"
    ELSE IF (.NOT. GMAB_ON(1) .AND. GMAB_ON(2)) THEN
       EngMAF%ASE_Side = "B"
    ELSE
       EngMAF%ASE_Side = ASE_Side    ! "U" - use previous known position instead
    ENDIF
    ASE_Side = EngMAF%ASE_Side

    ! Determine which side GSM (GM03/GM04) is on:

    IF (GMAB_ON(3) .AND. .NOT. GMAB_ON(4)) THEN
       EngMAF%GSM_Side = "A"
    ELSE IF (.NOT. GMAB_ON(3) .AND. GMAB_ON(4)) THEN
       EngMAF%GSM_Side = "B"
    ELSE
       EngMAF%GSM_Side = GSM_Side    ! "U" - use previous known position instead
    ENDIF
    GSM_Side = EngMAF%GSM_Side

    ! Convert engineering counts

    CALL ConvertEngCounts (GMAB_ON)

    !! Save the required data for later use:

    EngMAF%Eng%value = Eng_tbl%value
    EngMAF%Eng%mnemonic = Eng_tbl%mnemonic

  END SUBROUTINE NextEngMAF

!=============================================================================
  LOGICAL FUNCTION not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (len=*), PARAMETER :: IdParm = &
       "$Id: EngUtils.f90,v 2.15 2016/03/15 22:17:59 whdaffer Exp $"
  CHARACTER (len=LEN(idParm)), SAVE :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  END FUNCTION not_used_here
END MODULE EngUtils
!=============================================================================

! $Log: EngUtils.f90,v $
! Revision 2.15  2016/03/15 22:17:59  whdaffer
! Merged whd-rel-1-0 back onto main branch. Most changes
! are to comments, but there's some modification to Calibration.f90
! and MLSL1Common to support some new modules: MLSL1Debug and SnoopMLSL1.
!
! Revision 2.14.4.1  2015/10/09 10:21:38  whdaffer
! checkin of continuing work on branch whd-rel-1-0
!
! Revision 2.14  2015/01/21 19:30:19  pwagner
! Gets isNaN from MLSFillValues
!
! Revision 2.13  2015/01/14 00:32:53  pwagner
! Added debugging info for Calibration counts dropping to zero
!
! Revision 2.12  2008/05/06 15:56:44  perun
! Read eng packets until data good.
!
! Revision 2.11  2006/08/02 18:53:41  perun
! Define default A/B side reading and use if none available during reading
!
! Revision 2.10  2005/06/23 18:41:35  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.9  2004/11/10 15:33:40  perun
! Adjust TAI time by -0.25 secs; change call to ReadL0Eng with additional flag
!
! Revision 2.8  2004/05/14 15:59:11  perun
! Version 1.43 commit
!
! Revision 2.7  2004/01/09 17:46:22  perun
! Version 1.4 commit
! Revision 2.6  2003/09/15 17:15:53  perun
! Version 1.3 commit
!
! Revision 2.5  2003/08/15 14:25:04  perun
! Version 1.2 commit
!
! Revision 2.4  2003/01/31 18:13:34  perun
! Version 1.1 commit
!
! Revision 2.2  2001/02/23 18:55:17  perun
! Version 0.5 commit
!
@


2.15
log
@Merged whd-rel-1-0 back onto main branch. Most changes
are to comments, but there's some modification to Calibration.f90
and MLSL1Common to support some new modules: MLSL1Debug and SnoopMLSL1.
@
text
@d205 1
d246 1
a246 1
        if ( n == 3 .and. Eng_tbl(n)%counts < 1 ) &
d386 1
a386 1
          PRINT *, "Unknown tlm type!"  !! use standard routine here
d398 1
a398 1
        PRINT *, 'Data not available to convert'
d400 1
a400 1
          print *,"But it's a `Spare', so we don't really care!"
d402 1
a402 1
          print *,"Mnemonic = ",Eng_tbl(i)%mnemonic
d416 13
a428 11
        print *, i, 'th engineering value is a NaN'
        print *, 'type  ', Eng_tbl(i)%type
        print *, 'riu number ', riu_no
        print *, 'mnemonic ', trim(Eng_tbl(i)%mnemonic)
        if ( riu_no > 0 .and. riu_no < 5 ) print *, 'GMriu on? ', GMAB_ON(riu_no)
        if ( riu_no > 1 .and. riu_no < 6 .and. MOD (riu_no, 2) == 0 ) &
             & print *, 'prev GMriu on? ', GMAB_ON(riu_no-1)
        if ( riu_no > -1 .and. riu_no < 4 .and. MOD (riu_no, 2) /= 0 ) &
             & print *, 'next GMriu on? ', GMAB_ON(riu_no+1)
        print *, 'id_word ', Riu_tbl(riu_no)%id_word
        print *, 'counts ', Eng_tbl(i)%counts
d536 1
a536 1
       "$Id: EngUtils.f90,v 2.14.4.1 2015/10/09 10:21:38 whdaffer Exp $"
d545 5
@


2.14
log
@Gets isNaN from MLSFillValues
@
text
@d36 5
a40 2
    !! Calibrate the measured frequency against the calibration frequencies
    !! and their corresponding parameter values
d63 4
d68 1
a68 1

d70 1
a70 1

d75 1
d100 1
a100 1
       rth_log = LOG ((rmax * rin) / (rmax - rin))
d108 4
d180 4
a183 1
    !! Convert the raw counts into engineering units
d189 2
d193 1
a193 1
    INTEGER :: i, n, dn, pkt_no, riu_no, byte1
d197 10
d208 1
a208 1
! Extract the raw counts
d210 6
a215 1
    DO i = 1, SIZE(Riu_tbl)
d217 1
a217 3
       pkt_no = Riu_tbl(i)%pkt_no
       byte1 = Riu_tbl(i)%start_byte
       Riu_tbl(i)%id_word = BigEndianStr (EngPkt(pkt_no)(byte1:byte1+1))
d219 7
a225 1
       DO n = Riu_tbl(i)%first_pt, Riu_tbl(i)%last_pt
d227 2
a228 4
          byte1 = byte1 + 2    ! next word
          Eng_tbl(n)%counts = BigEndianStr (EngPkt(pkt_no)(byte1:byte1+1))
          if ( n == 3 .and. Eng_tbl(n)%counts < 1 ) &
            & print *, 'Cal counts is 0 for Eng table at n ', n
d230 1
a230 1
! Save the calibration counts
d232 9
a240 8
         IF (Eng_tbl(n)%cal_indx > 0) THEN
            Riu_tbl(i)%Cal_cnts(Eng_tbl(n)%cal_indx) = Eng_tbl(n)%counts
            IF (Eng_tbl(n)%cal_indx == prt1_cal1) THEN  ! save also as PRT-2's
               Riu_tbl(i)%Cal_cnts(prt2_cal1) = Eng_tbl(n)%counts
            ELSE IF (Eng_tbl(n)%cal_indx == prt1_cal2) THEN
               Riu_tbl(i)%Cal_cnts(prt2_cal2) = Eng_tbl(n)%counts
            ENDIF
         ENDIF
d242 25
a266 1
       ENDDO
d272 6
d280 2
a281 2
       riu_no = Eng_tbl(i)%riu_no
       scale = Eng_tbl(i)%scale
d283 1
a283 1
       Eng_tbl(i)%value = QNan()
d285 1
a285 1
       ! Skip the always bad THz sensor
d287 25
a311 2
       IF ((INDEX (Eng_tbl(i)%mnemonic, "THzAmbCalTgt_T2") /= 0) .OR. &
            (INDEX (Eng_tbl(i)%mnemonic, "THzAmbCalTgtRT2") /= 0)) CYCLE
d313 1
a313 8
       IF (riu_no >= 1 .AND. riu_no <= 4) THEN
          IF (.NOT. GMAB_ON(riu_no)) CYCLE     ! GMriu_no is NOT ON
          IF (MOD (riu_no, 2) == 0) THEN
             IF (GMAB_ON(riu_no-1)) CYCLE      ! Other related GMriu_no is ON
          ELSE
             IF (GMAB_ON(riu_no+1)) CYCLE      ! Other related GMriu_no is ON
          ENDIF
       ENDIF
d315 1
a315 2
       IF (Riu_tbl(riu_no)%id_word /= 0 .AND. &
            Eng_tbl(i)%counts > 0) THEN   ! Data available to convert
d317 3
a319 1
          SELECT CASE (Eng_tbl(i)%type)
d321 7
a327 1
          CASE ("Cal")
d329 1
a329 8
             IF (Eng_tbl(i)%cal_indx /= temp_cal) THEN   ! not a temperature
                Eng_tbl(i)%value = Eng_tbl(i)%counts
             ELSE
                Eng_tbl(i)%value = Cal_freq (Eng_tbl(i)%counts, &
                     & Riu_tbl(riu_no)%Cal_cnts(vin_cal1), &
                     & Riu_tbl(riu_no)%Cal_cnts(vin_cal2), &
                     & Cal_const(riu_no)%volts, 0.0) * 100.0 + abs_zero
             ENDIF
d331 4
a334 1
          CASE ("VIN")
d336 6
a341 4
             Eng_tbl(i)%value = Cal_freq (Eng_tbl(i)%counts, &
                  & Riu_tbl(riu_no)%Cal_cnts(vin_cal1), &
                  & Riu_tbl(riu_no)%Cal_cnts(vin_cal2), &
                  & Cal_const(riu_no)%volts, 0.0)
d343 1
a343 6
             IF (scale /= 0.0) THEN
                Eng_tbl(i)%value = scale * Eng_tbl(i)%value
             ELSE
                Eng_tbl(i)%value = Use_equation (Eng_tbl(i)%mnemonic, &
                     & Eng_tbl(i)%value)
             ENDIF
d345 2
a346 1
          CASE ("PRT-1")
d348 2
a349 7
             dn = Eng_tbl(i)%counts
             IF (dn > 63000) dn = dn - 65536  ! adjust if DN is too high
             Eng_tbl(i)%value = PRD_temp (Cal_freq(dn, &
                  & Riu_tbl(riu_no)%Cal_cnts(prt1_cal1), &
                  & Riu_tbl(riu_no)%Cal_cnts(prt1_cal2), &
                  & Cal_const(riu_no)%prt1_hi, Cal_const(riu_no)%prt1_low), &
                  & scale)
d351 31
a381 1
          CASE ("PRT-2")
d383 1
a383 5
            Eng_tbl(i)%value = PRD_temp (Cal_freq(Eng_tbl(i)%counts, &
                  & Riu_tbl(riu_no)%Cal_cnts(prt2_cal1), &
                  & Riu_tbl(riu_no)%Cal_cnts(prt2_cal2), &
                  & Cal_const(riu_no)%prt2_hi, Cal_const(riu_no)%prt2_low), &
                  & scale)
d385 1
a385 1
          CASE ("YSI")
d387 1
a387 4
             Eng_tbl(i)%value = Therm_temp (Cal_freq(Eng_tbl(i)%counts, &
                  & Riu_tbl(riu_no)%Cal_cnts(ysi_cal1), &
                  & Riu_tbl(riu_no)%Cal_cnts(ysi_cal2), &
                  & Cal_const(riu_no)%therm_hi, Cal_const(riu_no)%therm_low))
d389 43
a431 1
          CASE DEFAULT
d433 1
a433 1
             PRINT *, "Unknown tlm type!"  !! use standard routine here
d435 9
a443 4
          END SELECT

       elseif ( i < 307 .or. i > 321 ) then
         PRINT *, 'Data not available to convert'
d445 3
a447 21
       ! Apparently values 307-320 are all NaNs
       ! Who wooda guessed!
       if ( isNaN(Eng_tbl(i)%value) .and. &
         & ( i < 307 .or. i > 321 ) &
         & ) then
         print *, i, 'th engineering value is a NaN'
         print *, 'type  ', Eng_tbl(i)%type
         print *, 'riu number ', riu_no
         print *, 'mnemonic ', trim(Eng_tbl(i)%mnemonic)
         if ( riu_no > 0 .and. riu_no < 5 ) print *, 'GMriu on? ', GMAB_ON(riu_no)
         if ( riu_no > 1 .and. riu_no < 6 .and. MOD (riu_no, 2) == 0 ) &
           & print *, 'prev GMriu on? ', GMAB_ON(riu_no-1)
         if ( riu_no > -1 .and. riu_no < 4 .and. MOD (riu_no, 2) /= 0 ) &
           & print *, 'next GMriu on? ', GMAB_ON(riu_no+1)
         print *, 'id_word ', Riu_tbl(riu_no)%id_word
         print *, 'counts ', Eng_tbl(i)%counts
       endif
       ! So, it's because GMriu_no is NOT ON for these rius
       ! Tell me, where is any of this documented? Does anyone here know anything?

    ENDDO
d449 1
d479 9
a487 1
    EngMAF%secTAI = EngMAF%secTAI - 0.25   ! actual time to line up with SCI
d533 1
a533 1
       "$Id: EngUtils.f90,v 2.13 2015/01/14 00:32:53 pwagner Exp $"
d542 6
@


2.14.4.1
log
@checkin of continuing work on branch whd-rel-1-0
@
text
@d36 2
a37 5
    !! Calibrate the measured frequency against the calibration frequencies and
    !! their corresponding parameter values.  

    !! See Eq. 5.3, sec 5 in the _MLS Level Algorithmic Theoretical Basis_
    !! (ATB) version 2.0)
d60 1
a60 3
    !! See Eq.s 5.5, 5.6, Sec 5.1.3, page 49 of the MLS Level 1 ATB document
    !! (rev 2.0)
    !!
a61 2
    !! Convert thermistor (ohms) to temperature (C) */
    !!
d63 1
a63 1
    !!
a67 1
    !!
d92 1
a92 1
       rth_log = LOG ((rmax * rin) / (rmax - rin)) ! log(Eq 5.5, pg 49)
a99 4
    !! See Eq. 5.4, Sec 5.1.1, pg 48 of MLS Level 1 ATB (v2.0)
    !!
    !!

d168 1
a168 4
    !! Convert the raw counts into engineering units. The input engineering data
    !! is stored in the module variable EngPkt, which stores one MAF of
    !! Engineering data and is filled in each call to NextEngMaf, which calls
    !! this routine.
a173 2
    USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Info,MLSMSG_Warning
    USE SDPToolkit, ONLY: PGS_TD_TAItoUTC
d176 1
a176 1
    INTEGER :: i, n, dn, pkt_no, riu_no, byte1,rs
a179 9
    REAL(r8) TAI93


    LOGICAL :: FoundBadPoints=.FALSE.

    CHARACTER(len=27) :: asciiUTC
    CHARACTER(len=256) :: msg
    INTEGER, EXTERNAL :: PGS_TD_EOSPMGIRDtoTAI

d181 1
d183 1
a183 1
! Extract the raw counts. For each RIU
d185 3
a187 6
    DO i = 1, SIZE(Riu_tbl) ! count RIUs
      
      ! Here 'i' is the RIU number.
      
      pkt_no = Riu_tbl(i)%pkt_no ! pkt for this RIU
      byte1 = Riu_tbl(i)%start_byte ! starting byte for this RIU
d189 1
a189 1
      Riu_tbl(i)%id_word = BigEndianStr (EngPkt(pkt_no)(byte1:byte1+1))
d191 4
a194 7
      DO n = Riu_tbl(i)%first_pt, Riu_tbl(i)%last_pt
        ! <whd> 
        ! {first,last}_pt are actually the first and last line numbers in the
        ! eng tables file (currently named engtlm.tbl) which mentions RIU(i);
        ! it is *not* a telemetry value!  Their purpose here is just to count
        ! the number of bytes that need to be extracted from this packet for
        ! this RIU
d196 1
a196 2
        ! So all that's really important here is the number of lines for this
        ! RIU, i.e.  nLines = Riu_tbl(i)%last_pt - Riu_tbl(i)%first_pt+1
d198 8
a205 1
        byte1 = byte1 + 2    ! next word
d207 1
a207 35
        ! so the packet is arranged as: (all quantities are 2-byte long)
        ! id 
        ! counts(mnem(1)) 
        ! counts(mnem(2))
        ! counts(mnem(3))
        ! ...
        ! counts(mnem(last_mnem)
        !!
        Eng_tbl(n)%counts = BigEndianStr (EngPkt(pkt_no)(byte1:byte1+1))


        ! <whd> why a special test for GM01_PRT1_Cal1 </whd>

        if ( n == 3 .and. Eng_tbl(n)%counts < 1 ) &
             & print *, 'Cal counts is <= 0 for Eng table at n ', n

        ! Save the calibration counts

        ! <whd> 
        ! cal_indx is index into the array EngTbls::Cal_Type_str, so
        ! Riu_tbl%cal_cnts has the same order as that array. Parameters that
        ! hold these indices are also defined in EngTbls ~line 49
        ! </whd>

        IF (Eng_tbl(n)%cal_indx > 0) THEN
          Riu_tbl(i)%Cal_cnts(Eng_tbl(n)%cal_indx) = Eng_tbl(n)%counts
          ! Don't know why ptr1_cal{1,2} also saves ptr2_cal{1,2}.
          IF (Eng_tbl(n)%cal_indx == prt1_cal1) THEN  ! save also as PRT-2's
            Riu_tbl(i)%Cal_cnts(prt2_cal1) = Eng_tbl(n)%counts
          ELSE IF (Eng_tbl(n)%cal_indx == prt1_cal2) THEN
            Riu_tbl(i)%Cal_cnts(prt2_cal2) = Eng_tbl(n)%counts
          ENDIF
        ENDIF

      ENDDO
d213 1
a213 5
    ! <whd>
    ! `i' here is basically the lines of the engtlm.tbl file (excluding those in
    ! the `survival table', the file header, and section demarcating lines
    ! (i.e. those consisting of a line of dashes)
    ! </whd>
d215 2
a216 1
    DO i = 1, last_tlm_pt
d218 1
a218 2
      riu_no = Eng_tbl(i)%riu_no
      scale = Eng_tbl(i)%scale
d220 1
a220 1
      Eng_tbl(i)%value = QNan() ! assume the worst
d222 2
a223 1
      ! Skip the always bad THz sensor
d225 8
a232 25
      IF ((INDEX (Eng_tbl(i)%mnemonic, "THzAmbCalTgt_T2") /= 0) .OR. &
           (INDEX (Eng_tbl(i)%mnemonic, "THzAmbCalTgtRT2") /= 0)) CYCLE

      IF (riu_no >= 1 .AND. riu_no <= 4) THEN
        IF (.NOT. GMAB_ON(riu_no)) CYCLE     ! GMriu_no is NOT ON
        IF (MOD (riu_no, 2) == 0) THEN
          IF (GMAB_ON(riu_no-1)) CYCLE      ! Other related GMriu_no is ON
        ELSE
          IF (GMAB_ON(riu_no+1)) CYCLE      ! Other related GMriu_no is ON
        ENDIF
      ENDIF

      ! <whd>
      ! if id_word == 0, this RIU is off!
      ! Riu_tbl(riu_no)%id_word is the ID for the Riu_tbl(riu_no). The C&DH
      ! handbook (e.g. see pages 30-33, similarly for any fields marked
      ! [GMST]0[1-4]) Eng_tbl(i) the entry on the i-th non-trivial line in the
      ! engineering telemetry table file, currently called
      ! engtlm.tbl. Eng_tbl(i)%counts is read from the telemetry, using the pkt
      ! no and offset stored in Riu_tbl. Riu_tbl is filled in EngTbls.f90
      ! </whd>

      IF (Riu_tbl(riu_no)%id_word /= 0 .AND. &
           Eng_tbl(i)%counts > 0) THEN   
        ! RIU is on and there are non-zero counts: Data available to convert
d234 2
a235 1
        SELECT CASE (Eng_tbl(i)%type)
d237 1
a237 1
        CASE ("Cal")
d239 1
a239 3
          IF (Eng_tbl(i)%cal_indx /= temp_cal) THEN   ! not a temperature
            Eng_tbl(i)%value = Eng_tbl(i)%counts
          ELSE
d241 8
a248 7
            Eng_tbl(i)%value = Cal_freq ( Eng_tbl(i)%counts, & !measurement
                 & Riu_tbl(riu_no)%Cal_cnts(vin_cal1), & !high cal cnt
                 & Riu_tbl(riu_no)%Cal_cnts(vin_cal2), & !low cal cnt
                 & Cal_const(riu_no)%volts, & !high value
                 & 0.0) &                     !low value
                 & * 100.0 + abs_zero
          ENDIF
d250 1
a250 1
        CASE ("VIN")
d252 4
a255 4
          Eng_tbl(i)%value = Cal_freq (Eng_tbl(i)%counts, &
               & Riu_tbl(riu_no)%Cal_cnts(vin_cal1), &
               & Riu_tbl(riu_no)%Cal_cnts(vin_cal2), &
               & Cal_const(riu_no)%volts, 0.0)
d257 6
a262 6
          IF (scale /= 0.0) THEN
            Eng_tbl(i)%value = scale * Eng_tbl(i)%value
          ELSE
            Eng_tbl(i)%value = Use_equation (Eng_tbl(i)%mnemonic, &
                 & Eng_tbl(i)%value)
          ENDIF
d264 1
a264 1
        CASE ("PRT-1")
d266 7
a272 2
          dn = Eng_tbl(i)%counts
          IF (dn > 63000) dn = dn - 65536  ! adjust if DN is too high
d274 1
a274 2
          ! calls cal_freq inside PRT_temp. Commented to make that a bit
          ! clearer. Cases PRT-2, YSI-{1,2} are similar.
d276 5
a280 31
          Eng_tbl(i)%value = PRD_temp ( &
               & Cal_freq(dn, &
               &          Riu_tbl(riu_no)%Cal_cnts(prt1_cal1), &
               &          Riu_tbl(riu_no)%Cal_cnts(prt1_cal2), &
               &          Cal_const(riu_no)%prt1_hi, &
               &          Cal_const(riu_no)%prt1_low &
               &          ), &
               & scale)

        CASE ("PRT-2")

          Eng_tbl(i)%value = PRD_temp ( &
               Cal_freq( &
               &                       Eng_tbl(i)%counts, &
               &                       Riu_tbl(riu_no)%Cal_cnts(prt2_cal1), &
               &                       Riu_tbl(riu_no)%Cal_cnts(prt2_cal2), &
               &                       Cal_const(riu_no)%prt2_hi, &
               &                       Cal_const(riu_no)%prt2_low &
               &                       ), &
               &                scale)

        CASE ("YSI")

          Eng_tbl(i)%value = Therm_temp (&
               &              Cal_freq(&
               &                 Eng_tbl(i)%counts, &
               &                 Riu_tbl(riu_no)%Cal_cnts(ysi_cal1), &
               &                 Riu_tbl(riu_no)%Cal_cnts(ysi_cal2), &
               &                 Cal_const(riu_no)%therm_hi, Cal_const(riu_no)%therm_low &
               &                 ) &
               &               )
d282 1
a282 1
        CASE DEFAULT
d284 4
a287 1
          PRINT *, "Unknown tlm type!"  !! use standard routine here
d289 1
a289 1
        END SELECT
d291 1
a291 43
      ELSEIF ( i < 307 .or. i > 321 ) THEN
        !<whd:comment> 
!
        ! Riu_tbl(riu_no)%id_word /= 0 .OR.Eng_tbl(i)%counts <= 0, but i < 307
        ! or > 321. Lines 307-320 in engtlm.tbl correspond to GM15 and
        ! SM01. Comment below says those are always NaNs
!
        !</whd:comment> 
        PRINT *, 'Data not available to convert'
        IF (Eng_tbl(i)%mnemonic .eq. 'Spare') THEN
          print *,"But it's a `Spare', so we don't really care!"
        ELSE
          print *,"Mnemonic = ",Eng_tbl(i)%mnemonic
        ENDIF
      ENDIF
      ! Apparently values 307-320 are all NaNs Who wooda guessed!  
!
      ! Line numbers 307-320 in the engtlm.tbl file (not counting lines which
      ! exclude header, comments and section demarcating lines of all dashes)
      ! are for the GigaHertz switch network, which is only turned on and then
      ! immediately turned off, so these are, in a sense, bogus NaNs and are
      ! not reported. Hence their exclusion from the following code block
      IF ( isNaN(Eng_tbl(i)%value) .and. &
           & ( i < 307 .or. i > 321 ) &
           & ) THEN
        FoundBadPoints=.TRUE.
        print *, i, 'th engineering value is a NaN'
        print *, 'type  ', Eng_tbl(i)%type
        print *, 'riu number ', riu_no
        print *, 'mnemonic ', trim(Eng_tbl(i)%mnemonic)
        if ( riu_no > 0 .and. riu_no < 5 ) print *, 'GMriu on? ', GMAB_ON(riu_no)
        if ( riu_no > 1 .and. riu_no < 6 .and. MOD (riu_no, 2) == 0 ) &
             & print *, 'prev GMriu on? ', GMAB_ON(riu_no-1)
        if ( riu_no > -1 .and. riu_no < 4 .and. MOD (riu_no, 2) /= 0 ) &
             & print *, 'next GMriu on? ', GMAB_ON(riu_no+1)
        print *, 'id_word ', Riu_tbl(riu_no)%id_word
        print *, 'counts ', Eng_tbl(i)%counts
      ENDIF
      ! So, it's because GMriu_no is NOT ON for these rius? Tell me, where is
      ! any of this documented? Does anyone here know anything? 
!
      ! (<whd> I'm presuming that vince wrote that last comment. As for me
      ! I have to say 'no', apparently no one here knows anything!</whd>)
d293 1
a293 1
    ENDDO ! loop over engtlm.tbl lines 
d295 2
a296 9
    IF (FoundBadPoints) THEN
       rs = PGS_TD_EOSPMGIRDtoTAI (engpkt(1)(8:15), TAI93)
       asciiUTC="BadTime"
       IF (rs /= 0) THEN 
          print *,"ConvertEngCounts: Can't get engineering packet TAI93 time!"
          CALL MLSMessage(MLSMSG_Warning,ModuleName, &
               &   "ConvertEngCounts: Can't get engineering packet TAI93 time!")          
       ELSE
          rs = PGS_TD_TAItoUTC (TAI93, asciiUTC)
d298 21
a318 3
       write(msg,*) 'ConvertEngCounts: bad data! MIF time: '//trim(asciiUTC)
       print *,trim(msg)
       CALL MLSMessage(MLSMSG_Info,ModuleName, trim(msg))
a319 1
    ENDIF
d349 1
a349 9
    ! <whd:comment> 0.25 ~= 1.5 MIFs (MIF has a nominal dur of 1/6
    ! secs). Dominick thinks that the time in the engineering packets that goes
    ! with a particular set of science packets has a time tag about 1.5 MIFs
    ! later than the science packets they go with. However, in
    ! CalibWeightsFlags::ProcessMAFdata, the engineering data that's 'paired'
    ! with science data is selected from the previous Eng MAF.  See ~line 185,
    ! at the mention of NINT() </whd:comment>

    EngMAF%secTAI = EngMAF%secTAI - 0.25   ! vp's orig comment: actual time to line up with SCI
d395 1
a395 1
       "$Id: EngUtils.f90,v 2.14 2015/01/21 19:30:19 pwagner Exp $"
a403 3
! Revision 2.14  2015/01/21 19:30:19  pwagner
! Gets isNaN from MLSFillValues
!
@


2.13
log
@Added debugging info for Calibration counts dropping to zero
@
text
@d18 1
d395 1
a395 1
       "$Id: EngUtils.f90,v 2.12 2008/05/06 15:56:44 perun Exp $"
d404 3
@


2.12
log
@Read eng packets until data good.
@
text
@d192 2
d294 2
d297 19
d394 1
a394 1
       "$Id: EngUtils.f90,v 2.11 2006/08/02 18:53:41 perun Exp $"
d403 3
@


2.11
log
@Define default A/B side reading and use if none available during reading
@
text
@d318 6
a323 4
    CALL ReadL0Eng (EngPkt, EngMAF%MAFno, EngMAF%TotalMAF, &
         EngMAF%MIFsPerMAF, EngMAF%secTAI, data_OK, more_data)

    IF (.NOT. more_data) RETURN   ! nothing more to do
d371 1
a371 1
       "$Id: EngUtils.f90,v 2.10 2005/06/23 18:41:35 pwagner Exp $"
d380 3
@


2.10
log
@Reworded Copyright statement, moved rcs id
@
text
@d1 1
a1 1
! Copyright 2005, by the California Institute of Technology. ALL
d26 3
a28 3
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: $"
  private :: not_used_here 
d91 1
a91 1
       rth_log = log ((rmax * rin) / (rmax - rin))
d156 1
a156 1
          val = 8.4459 * log (tval) - 47.755  ! R4 IF Voltage
d288 1
a288 1
             print *, "Unknown tlm type!"  !! use standard routine here
d314 4
d339 1
a339 1
       EngMAF%ASE_Side = "U"
d341 1
d350 1
a350 1
       EngMAF%GSM_Side = "U"
d352 1
d366 1
a366 1
  logical function not_used_here()
d368 3
a370 3
  character (len=*), parameter :: IdParm = &
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
d373 1
a373 1
  end function not_used_here
d378 3
@


2.9
log
@Adjust TAI time by -0.25 secs; change call to ReadL0Eng with additional flag
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d25 5
a29 5
  !------------------------------- RCS Ident Info ------------------------------
  CHARACTER(LEN=130) :: id = &
       "$Id: EngUtils.f90,v 2.8 2004/05/14 15:59:11 perun Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: EngUtils.f90,v $"
  !-----------------------------------------------------------------------------
d360 8
d372 3
@


2.8
log
@Version 1.43 commit
@
text
@d19 1
a19 1
       "$Id: EngUtils.f90,v 2.7 2004/01/09 17:46:22 perun Exp $"
d301 1
a301 1
    LOGICAL :: OK, GMAB_ON(4)
d306 2
a307 1
    more_data = .TRUE.
d309 1
a309 2
    CALL ReadL0Eng (EngPkt, EngMAF%MAFno, EngMAF%TotalMAF, EngMAF%MIFsPerMAF, &
         EngMAF%secTAI, OK)
d311 1
a311 1
    IF (OK) THEN
d313 1
a313 1
       ! Determine GM01 to GM04 A/B ON/OFF states:
d315 4
a318 4
       GMAB_ON(1) =(IAND (ICHAR (EngPkt(6)(103:103)), maskbit7) == maskbit7)
       GMAB_ON(2) =(IAND (ICHAR (EngPkt(6)(103:103)), maskbit3) == maskbit3)
       GMAB_ON(3) =(IAND (ICHAR (EngPkt(6)(109:109)), maskbit3) == maskbit3)
       GMAB_ON(4) =(IAND (ICHAR (EngPkt(6)(110:110)), maskbit7) == maskbit7)
d320 1
a320 1
       ! Determine which side ASE (GM01/GM02) is on:
d322 7
a328 7
       IF (GMAB_ON(1) .AND. .NOT. GMAB_ON(2)) THEN
          EngMAF%ASE_Side = "A"
       ELSE IF (.NOT. GMAB_ON(1) .AND. GMAB_ON(2)) THEN
          EngMAF%ASE_Side = "B"
       ELSE
          EngMAF%ASE_Side = "U"
       ENDIF
d330 1
a330 1
       ! Determine which side GSM (GM03/GM04) is on:
d332 7
a338 9
       IF (GMAB_ON(3) .AND. .NOT. GMAB_ON(4)) THEN
          EngMAF%GSM_Side = "A"
       ELSE IF (.NOT. GMAB_ON(3) .AND. GMAB_ON(4)) THEN
          EngMAF%GSM_Side = "B"
       ELSE
          EngMAF%GSM_Side = "U"
       ENDIF

       ! Convert engineering counts
d340 1
a340 1
       CALL ConvertEngCounts (GMAB_ON)
d342 1
a342 1
       !! Write eng data to file:
d344 1
a344 17
!!$       WRITE (L1BFileInfo%EngId, iostat=ios) EngPkt
!!$       WRITE (L1BFileInfo%EngId, iostat=ios) eng_tbl%value

       !! Save the required data for later use:

       EngMAF%Eng%value = Eng_tbl%value
       EngMAF%Eng%mnemonic = Eng_tbl%mnemonic

       !! Already have the current MIFsPerMAF

       !! EngMAF%MIFsPerMAF = L1Config%Calib%MIFsPerMAF

    ELSE

       more_data = .FALSE.

    ENDIF
d346 2
d356 3
@


2.7
log
@Version 1.4 commit
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d19 1
a19 1
       "$Id: EngUtils.f90,v 2.6 2003/09/15 17:15:53 perun Exp $"
d39 2
a40 1
    IF ((lo_freq == 0) .OR. (hi_freq == 0) .OR. (hi_freq == lo_freq)) THEN
d372 2
@


2.6
log
@Version 1.3 commit
@
text
@d19 1
a19 1
       "$Id: EngUtils.f90,v 2.5 2003/08/15 14:25:04 perun Exp $"
d164 1
a164 1
    LOGICAL :: GMAB_ON(*)
d166 1
a166 1
    INTEGER :: i, n, pkt_no, riu_no, byte1
d188 5
d254 3
a256 1
             Eng_tbl(i)%value = PRD_temp (Cal_freq(Eng_tbl(i)%counts, &
d264 1
a264 1
             Eng_tbl(i)%value = PRD_temp (Cal_freq(Eng_tbl(i)%counts, &
d371 3
@


2.5
log
@Version 1.2 commit
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d19 1
a19 1
       "$Id: EngUtils.f90,v 2.4 2003/01/31 18:13:34 perun Exp $"
a287 1
    USE MLSL1Common, ONLY: L1BFileInfo
a293 1
    INTEGER :: ios
d338 2
a339 2
       WRITE (L1BFileInfo%EngId, iostat=ios) EngMAF%MAFno
       WRITE (L1BFileInfo%EngId, iostat=ios) eng_tbl%value
d364 3
@


2.4
log
@Version 1.1 commit
@
text
@d19 1
a19 1
       "$Id: EngUtils.f90,v 2.2 2001/02/23 18:55:17 perun Exp $"
d139 2
a140 1
             val = (tval - 0.317) / 0.162    ! Quiet Bus Current
d142 2
a143 2
             val = (tval - 0.228) / 1.691    ! Device Bus Current
          ENDIF
d286 1
a286 1
    USE EngTbls, ONLY: ConvEngPkt, EngPkt, EngMAF, Eng_tbl
a287 1
    USE MLSL1Config, ONLY: L1Config
d296 3
a298 1
    INTEGER, PARAMETER :: maskbit3 = z'8', maskbit7 = z'80'
d314 10
d366 3
@


2.3
log
@Version 1.0 commit
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d13 4
a16 1
  PRIVATE :: Id, ModuleName
d133 1
a133 1
             val = (tval - 0.3979) / 0.1172   ! Quiet Bus Voltage
d135 1
a135 1
             val = (tval - 0.3979) / 0.1172   ! Device Bus Voltage
d139 1
a139 1
             val = (tval - 0.3848) / 0.1583   ! Quiet Bus Current
d141 1
a141 1
             val = (tval - 0.2431) / 0.639    ! Device Bus Current
d144 1
a144 3
    ELSE IF (INDEX (mnemonic, "R4_RFE_Tripler_I") /= 0) THEN
       val = (2.5 - tval) / 49.9              ! Tripler Current
    ELSE IF (INDEX (mnemonic, "R4_HarmMixer_V") /= 0) THEN
d146 1
a146 1
          val = 8.7225 * log (tval) - 29.277  ! Harmonic Mixer Voltage
a151 3
    ! will need to add equation for R4_RFE_Gunn_I later:
    !  24231 * V3out - 16822 * V2out + 4597 * Vout - 291.58

d295 1
d301 1
a301 1
         OK)
d326 1
a326 1
       !! Write eng data to file (will use HDF later!!!)
d328 2
a329 2
       WRITE (L1BFileInfo%EngId) EngMAF%MAFno
       WRITE (L1BFileInfo%EngId) eng_tbl%value
@


2.2
log
@Version 0.5 commit
@
text
@d16 1
a16 1
       "$Id: EngUtils.f90,v 2.1 2001/02/23 18:53:47 perun Exp $"
d104 1
a104 1
    r = rin * 500.0 / r0;
d130 1
a130 1
             val = (tval - 0.3113) / 0.1183;   ! Quiet Bus Voltage
d132 1
a132 1
             val = (tval - 0.2638) / 0.1192;   ! Device Bus Voltage
d136 1
a136 1
             val = (tval - 0.317) / 0.162;   ! Quiet Bus Current
d138 1
a138 1
             val = (tval - 0.228) / 1.691;   ! Device Bus Current
d142 1
a142 1
       val = (2.5 - tval) / 49.9;   ! Tripler Current
d145 1
a145 1
          val = 8.7225 * log (tval) - 29.277;   ! Harmonic Mixer Voltage
d157 1
a157 1
  SUBROUTINE ConvertEngCounts
d165 2
d203 15
d234 1
a234 1
          CASE ("Analog")
d264 1
a264 1
          CASE ("Therm")
a283 23
  FUNCTION GetEngPkt () RESULT (OK)
!=============================================================================

    USE EngTbls, ONLY: ConvEngPkt
    USE OpenInit, ONLY: eng_unit, eng_recno

    LOGICAL OK
    INTEGER :: i, ios

    READ (eng_unit, rec=eng_recno, iostat=ios) ConvEngPkt

    IF (ios /= 0) THEN
       OK = .FALSE.
       RETURN         ! Nothing more to get
    ENDIF

    eng_recno = eng_recno + 1            ! position for next record

    OK = .TRUE.

  END FUNCTION GetEngPkt

!=============================================================================
d289 2
d296 2
a297 1
    LOGICAL :: OK
d301 4
d306 1
a306 1
    CALL ReadL0Eng (EngPkt, EngMAF%MAFno, OK)
d308 20
a327 1
    IF (OK) THEN
d329 2
a330 1
       CALL ConvertEngCounts
d337 1
a337 1
       !! Will Get the MIFs per MAF from 2.5 and later!!!
d339 1
a339 1
       EngMAF%MIFsPerMAF = 148
d354 4
a357 1
! $Log: $
@


2.1
log
@Version 0.5 commit
@
text
@d16 2
a17 2
       "$Id: $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: $"
d333 1
a333 1
! $Log $
@

