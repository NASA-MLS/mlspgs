head	1.23;
access;
symbols
	v5-02-NRT-19:1.23
	v6-00:1.23
	v5-02-NRT-18:1.23
	v5-02:1.23
	v5-01-NRT-17:1.23
	v5-01-NRT-16:1.23
	v5-01-NRT-15:1.23
	v5-01-NRT-14:1.23
	neuralnetworks-1-0:1.23.0.14
	cfm-single-freq-0-1:1.23.0.12
	v5-01:1.23
	v5-00:1.23
	v4-23-TA133:1.23.0.10
	mus-emls-1-70:1.23.0.8
	rel-1-0-englocks-work:1.23.0.6
	VUMLS1-00:1.23
	VPL1-00:1.23
	V4-22-NRT-08:1.23
	VAM1-00:1.23
	V4-21:1.23.0.4
	V4-13:1.23
	V4-12:1.23
	V4-11:1.23
	V4-10:1.23
	V3-43:1.23
	M4-00:1.23
	V3-41:1.23
	V3-40-PlusGM57:1.23.0.2
	V2-24-NRT-04:1.23
	V3-33:1.23
	V2-24:1.23
	V3-31:1.23
	V3-30-NRT-05:1.23
	cfm-01-00:1.23
	V3-30:1.23
	V3-20:1.23
	V3-10:1.23
	V2-23-NRT-02:1.23
	V2-23:1.23
	V2-22-NRT-01:1.23
	V2-22:1.23
	V2-21:1.23
	V2-20:1.23
	V2-11:1.22
	V2-10:1.22
	V2-00:1.22
	V1-51:1.19
	V1-50:1.18
	V1-45:1.16
	V1-44:1.16
	V1-43:1.16
	V1-42:1.15
	V1-41:1.15
	V1-32:1.14
	V1-40:1.15
	V1-31:1.14
	V1-30:1.14
	V1-13:1.6
	V1-12:1.6
	V1-11:1.6
	V1-10:1.5
	newfwm-feb03:1.5.0.2
	V1-04:1.5
	V1-03:1.5
	V1-02:1.5
	V1-00:1.5
	newfwm-sep01:1.1.0.2
	V0-7:1.1;
locks; strict;
comment	@# @;


1.23
date	2006.09.26.15.03.02;	author cvuu;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.03.14.40.51;	author cvuu;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.28.20.36.33;	author cvuu;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.23.19.17.58;	author pwagner;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.27.00.35.06;	author pwagner;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.16.15.00.49;	author cvuu;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.13.17.41.26;	author cvuu;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.04.15.57.20;	author cvuu;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.08.21.21.36;	author cvuu;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.16.16.35.21;	author cvuu;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.15.18.27.23;	author cvuu;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.11.23.26.37;	author cvuu;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.08.00.17.46;	author pwagner;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.45.15;	author pwagner;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.30.23.54.07;	author pwagner;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.30.18.16.29;	author pwagner;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.06.02.25.50;	author jdone;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.15.00.20.02;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.12.17.46.30;	author nakamura;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.12.20.25.50;	author nakamura;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.04.18.25.04;	author nakamura;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.26.19.47.03;	author nakamura;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.18.15.42.09;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Rename the dataset to SolarZenithAngle, add dashes in title, and remove spaces in soft link
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!==============================================================================
MODULE L3MZData
!==============================================================================

   USE HDF, ONLY: DFACC_RDWR, DFACC_WRITE, DFNT_FLOAT32, DFNT_INT32, & 
        & DFNT_FLOAT64
   USE Intrinsic, ONLY: l_hdfeos, l_swath
   USE MLSCommon, ONLY: r8
   USE MLSFiles, ONLY: MLS_SFSTART, MLS_SFEND, mls_inqswath, & 
        & HDFVERSION_4, HDFVERSION_5
   USE MLSL3Common, ONLY: GridNameLen, DIMR_NAME, DIMT_NAME, DIM_NAME2, &
        & DIML_NAME, SZ_ERR, DAT_ERR, GEO_ERR, SW_ERR, DG_FIELD1, DG_FIELD2, &
        & DIMLL_NAME, DATE_LEN, INVENTORYMETADATA, OutputFiles_T, &
        & GEO_FIELD1, GEO_FIELD3, GEO_FIELD4, GEO_FIELD9, GEO_FIELD11, & 
        & GEO_FIELD5, &
        & HDFE_NOMERGE, DIM_ERR, MIN_MAX, DIMRL_NAME, WR_ERR, METAWR_ERR, &
        & FILENAMELEN, FILEATTR_ERR
   USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_Fileopen, &
        & MLSMSG_Info, MLSMSG_WARNING, MLSMSG_Allocate, MLSMSG_DeAllocate
   USE MLSPCF3, ONLY: MLSPCF_L2DG_START, MLSPCF_L2GP_START
   USE mon_Open, ONLY: PCFMData_T
   USE OUTPUT_M, ONLY: output
   USE PCFModule, ONLY: SearchPCFDates, ExpandFileTemplate
   USE PCFHdr, only: GlobalAttributes
   USE SDPToolkit, only: WARNIFCANTPGSMETREMOVE, PGSD_MET_NUM_OF_GROUPS, &
        & PGSD_MET_GROUP_NAME_L, PGSMET_E_MAND_NOT_SET, PGS_S_SUCCESS, &
	& max_orbits
   ! USE SWAPI
   ! USE HE5_SWAPI

   IMPLICIT NONE
   private
   PUBLIC :: L3MZData_T, &
     & OutputL3MZ, WriteMetaL3MZ, AllocateL3MZ, DeallocateL3MZ


!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: L3MZData.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! Contents:

! Definition -- L3MZData_T
! Subroutines -- OutputL3MZ
!                WriteMetaL3MZ
!                WriteAttributeMZ
!                SetAliasMZ
!                AllocateL3MZ
!                DeallocateL3MZ

! Remarks:  This module contains the definition of the L3MZData type, as well
!           as any routines pertaining to it.

! Parameters

   CHARACTER (LEN=*), PARAMETER :: DATA_FIELDV = 'L3mzValue'
   CHARACTER (LEN=*), PARAMETER :: DATA_FIELDP = 'L3mzPrecision'
   CHARACTER (LEN=*), PARAMETER :: DATA_STDDEV = 'L3mzStdDeviation'
   CHARACTER (LEN=*), PARAMETER :: DATA_COUNT = 'L3mzDataCount'

! This data type is used to store the l3 monthly zonal mean data.

  TYPE L3MZData_T

     CHARACTER (LEN=GridNameLen) :: name	! name for the output quantity

     REAL(r8), DIMENSION(:,:), POINTER :: localSolarTime
     REAL(r8), DIMENSION(:,:), POINTER :: SolarZenithAngle
	! dimensioned as (2, nLats)

     ! Now the data fields:

     REAL(r8), DIMENSION(:,:), POINTER :: l3mzValue	! Field value
     REAL(r8), DIMENSION(:,:), POINTER :: l3mzPrecision	! Field precision
     INTEGER, DIMENSION(:,:), POINTER :: dataCount
        ! dimensioned as (nLevels, nLats)

     ! Now the diagnostic fields:

     REAL(r8), DIMENSION(:,:), POINTER :: latRss
	! Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)

     ! Now we store the geolocation fields.  First, the vertical one:

     REAL(r8), DIMENSION(:), POINTER :: pressure	! dimensioned (nLevels)

     ! Now the horizontal geolocation information and time:

     REAL(r8), DIMENSION(:), POINTER :: latitude	! dimensioned (nLats)

     REAL(r8) :: startTime	! start time of L2 data used in the analysis
     REAL(r8) :: endTime 	! end time of L2 data used in the analysis

     INTEGER, DIMENSION(:,:), POINTER :: perMisPoints
	! Missing points (percentage), dimensioned (nLevels, nLats)

     INTEGER :: nLevels				! Total number of surfaces
     INTEGER :: nLats				! Total number of latitudes

   END TYPE L3MZData_T

CONTAINS

!----------------------------------------------
   SUBROUTINE OutputL3MZ (file, mz, createFlag, hdfVersion)
!----------------------------------------------

! Brief description of subroutine
! This subroutine creates and writes to the swaths in an l3mz file.

! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: file

      TYPE( L3MZData_T ), INTENT(IN) :: mz

      LOGICAL, INTENT(INOUT) :: createFlag

      INTEGER, INTENT(IN) :: hdfVersion

      IF (hdfVersion == HDFVERSION_5) THEN 
         CALL OutputL3MZ_HE5 (file, mz, createFlag)
      ELSE
         CALL MLSMessage(MLSMSG_Error, ModuleName, 'Wrong hdfVersion')
      ENDIF

!----------------------------------------------
    END SUBROUTINE OutputL3MZ
!----------------------------------------------

!----------------------------------------------
   SUBROUTINE OutputL3MZ_HE5 (file, mz, creationFlag)
!----------------------------------------------
   USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC, HE5T_NATIVE_CHAR

! Brief description of subroutine
! This subroutine creates and writes to the swath in an l3mz file.
! Change to Zonal Average format instead of swath format

! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: file

      TYPE( L3MZData_T ), INTENT(IN) :: mz

      LOGICAL, INTENT(INOUT) :: creationFlag
 
! Parameters

! Functions

      INTEGER, EXTERNAL :: he5_zaattach, he5_zaclose, he5_zacreate, & 
           & he5_zadefine, he5_zadefdim, &
           & he5_zadetach, he5_zaopen, he5_zawrite

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: start(2), stride(2), edge(2)
      INTEGER :: status, swfID, swID

! Open the file for appending a zonal

      IF (.not. creationFlag) THEN
         swfID = he5_zaopen(trim(file), HE5F_ACC_TRUNC)
      ELSE
         swfID = he5_zaopen(trim(file), HE5F_ACC_RDWR)
      ENDIF

      IF (swfID == -1) THEN
         msr = MLSMSG_Fileopen // trim(file)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Create a zonal  of the appropriate name

      swID = he5_zacreate(swfID, mz%name)
      IF (swID == -1) THEN
         msr = 'Failed to create zonal ' // trim(mz%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Define the zonal dimensions

      status = he5_zadefdim(swID, DIMR_NAME, MIN_MAX)
      IF (status == -1) THEN
         msr = DIM_ERR // DIMR_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefdim(swID, DIM_NAME2, mz%nLevels)
      IF (status == -1) THEN
         msr = DIM_ERR // DIM_NAME2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefdim(swID, DIML_NAME, mz%nLats)
      IF (status == -1) THEN
         msr = DIM_ERR // DIML_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Define the zonal geolocation fields using the above dimensions

      status = he5_zadefine(swID, GEO_FIELD3, DIMR_NAME, "", HE5T_NATIVE_DOUBLE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefine(swID, GEO_FIELD9, DIM_NAME2, "", HE5T_NATIVE_FLOAT)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD9
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefine(swID, GEO_FIELD1, DIML_NAME, "", HE5T_NATIVE_FLOAT)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefine(swID, GEO_FIELD4, DIMRL_NAME, "", HE5T_NATIVE_FLOAT)
     IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD4
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefine(swID, GEO_FIELD5, DIMRL_NAME, "", HE5T_NATIVE_FLOAT)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD5
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Define the he5_zonal data fields using the above dimensions

      status = he5_zadefine(swID, DATA_FIELDV, DIMLL_NAME, "", HE5T_NATIVE_FLOAT)
      IF (status == -1) THEN
         msr = DAT_ERR // DATA_FIELDV
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefine(swID, DATA_FIELDP, DIMLL_NAME, "", HE5T_NATIVE_FLOAT)
      IF (status == -1) THEN
         msr = DAT_ERR // DATA_FIELDP
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefine(swID, DATA_STDDEV, DIMLL_NAME, "", HE5T_NATIVE_FLOAT)
      IF (status == -1) THEN
         msr = DAT_ERR // DATA_STDDEV
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefine(swID, DATA_COUNT, DIMLL_NAME, "", HE5T_NATIVE_INT)
      IF (status == -1) THEN
         msr = DAT_ERR // DATA_COUNT
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefine(swID, DG_FIELD2, DIMLL_NAME, "", HE5T_NATIVE_INT)
      IF (status == -1) THEN
         msr = DAT_ERR // DG_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Write the data

      start = 0
      stride = 1
      edge(1) = mz%nLevels
      edge(2) = mz%nLats

! Geolocation fields

      status = he5_zawrite(swID, GEO_FIELD3, start(1), stride(1), stride(1), &
           & mz%startTime)
      IF (status == -1) THEN
          msr = WR_ERR // GEO_FIELD3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrite(swID, GEO_FIELD3, stride(1), stride(1), stride(1), &
           & mz%endTime)
      IF (status == -1) THEN
          msr = WR_ERR // GEO_FIELD3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrite( swID, GEO_FIELD9, start(1), stride(1), edge(1), &
           & REAL(mz%pressure) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD9
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrite( swID, GEO_FIELD1, start(2), stride(2), edge(2), &
           & REAL(mz%latitude) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      edge(1) = MIN_MAX
      status = he5_zawrite( swID, GEO_FIELD4, start, stride, edge, &
           & REAL(mz%localSolarTime) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD4
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrite( swID, GEO_FIELD5, start, stride, edge, &
           & REAL(mz%SolarZenithAngle) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD5
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Data fields

      edge(1) = mz%nLevels
      status = he5_zawrite( swID, DATA_FIELDV, start, stride, edge, & 
           & REAL(mz%l3mzValue) )
      IF (status == -1) THEN
         msr = WR_ERR // DATA_FIELDV
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrite( swID, DATA_FIELDP, start, stride, edge, & 
           & REAL(mz%l3mzPrecision) )
      IF (status == -1) THEN
         msr = WR_ERR // DATA_FIELDP
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrite( swID, DATA_STDDEV, start, stride, edge, & 
           & REAL(mz%latRss) )
      IF (status == -1) THEN
         msr = WR_ERR // DATA_STDDEV
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrite( swID, DATA_COUNT, start, stride, edge, & 
           & mz%dataCount )
      IF (status == -1) THEN
         msr = WR_ERR // DATA_COUNT
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrite( swID, DG_FIELD2, start, stride, edge, & 
           & mz%perMisPoints )
      IF (status == -1) THEN
         msr = WR_ERR // DG_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! After writing, detach from zonal interface

      status = he5_zadetach(swID)
      IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
           & 'Failed to detach from zonal interface after writing.')

      msr = 'Zonal ' // TRIM(mz%name) // ' successfully written to file ' & 
           & // trim(file)
      CALL MLSMessage(MLSMSG_Info, ModuleName, msr)

! Close the file

      status = he5_zaclose(swfID)
      IF (status == -1) THEN
         msr = 'Failed to close file ' // trim(file) // ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      creationFlag = .TRUE.

! Write local attribute and set alias
                                                                                
      CALL WriteAttributeMZ(file, mz)
                                                                                
      CALL SetAliasMZ(file, mz)
                                                                                
!---------------------------
   END SUBROUTINE OutputL3MZ_HE5
!---------------------------

!----------------------------------------------
   SUBROUTINE SetAliasMZ(file, mz)
!----------------------------------------------
    USE HDF5, ONLY: HID_T
    USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC, MLS_charType
    USE SDPToolkit, ONLY: PGS_S_SUCCESS
                                                                        
    ! Brief description of subroutine
    ! This subroutine writes attributes to each zonal field
                                                                        
    ! Arguments
                                                                        
      CHARACTER (LEN=*), INTENT(IN) :: file
                                                                        
      TYPE (L3MZData_T), INTENT(IN) :: mz
                                                                        
    ! Functions
                                                                        
      INTEGER, EXTERNAL :: &
        & he5_zaattach, he5_zaclose, he5_zadetach, he5_zaopen, &
        & he5_zasetalias
                                                                        
    ! Parameters
                                                                        
      CHARACTER (len=*), parameter :: L3VALUE = 'L3mzValue'
      CHARACTER (len=*), parameter :: L3PREC = 'L3mzPrecision'
      CHARACTER (len=*), parameter :: L3STDDEV = 'L3mzStdDeviation'
      CHARACTER (len=*), parameter :: L3DCount = 'L3mzDataCount'
      CHARACTER (LEN=480) :: msr
      INTEGER (HID_T) :: zafID, zaId
      INTEGER :: status, n, m, field
                                                                        
      zafID = he5_zaopen(trim(file), HE5F_ACC_RDWR)
                                                                        
      IF (zafID == -1) THEN
         msr = MLSMSG_Fileopen // trim(file) //' for writing zonal'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                        
      zaId = he5_zaattach(zafID, mz%name)
      IF (zaId == -1) THEN
         msr = 'Failed to attach to zonal ' // trim(mz%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zasetalias(zaId, L3VALUE, trim(mz%name))
      if (status /= PGS_S_SUCCESS) then
         msr = 'Failed to alias l3Value' // trim(mz%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      endif
                                                                        
      status = he5_zasetalias(zaId, L3PREC, trim(mz%name)//'Precision')
      if (status /= PGS_S_SUCCESS) then
         msr = 'Failed to alias l3Precision' // trim(mz%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      endif
                                                                        
      status = he5_zasetalias(zaId, L3STDDEV, trim(mz%name)//'StdDeviation')
      if (status /= PGS_S_SUCCESS) then
         msr = 'Failed to alias l3StdDeviation' // trim(mz%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      endif
                                                                        
      status = he5_zasetalias(zaId, L3DCOUNT, trim(mz%name)//'DataCount')
      if (status /= PGS_S_SUCCESS) then
         msr = 'Failed to alias l3DataCount' // trim(mz%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      endif
                                                                        
      status = he5_zadetach(zaID)
      IF (status == -1) THEN
         msr = 'Failed to deattach to zonal ' // trim(mz%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zaclose(zafID)
      IF (status == -1) THEN
          msr = 'Failed to close file ' // trim(file) // ' after writing.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
                                                                        
!-----------------------------
  END SUBROUTINE SetAliasMZ
!----------------------------
                                                                        
!----------------------------------------------
  SUBROUTINE WriteAttributeMZ(file, mz)
!----------------------------------------------
    USE HDF5, ONLY: HID_T
    USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC, MLS_charType
    USE MLSStrings, only: lowercase
    USE MLSStringLists, only: list2array
                                                                        
    ! Brief description of subroutine
    ! This subroutine writes attributes to each grid field
                                                                        
    ! Arguments
      CHARACTER (LEN=*), INTENT(IN) :: file
                                                                        
      TYPE (L3MZData_T), INTENT(IN) :: mz 
                                                                        
      ! Parameters
                                                                        
      integer, parameter :: CHARATTRLEN = 255
      integer, parameter :: NumOfZonalFields = 5
      integer, parameter :: NumOfDataFields = 5
      character (len=*), parameter :: ZonalFieldTitles = &
        & 'Latitude,Pressure,Time,LocalSolarTime,SolarZenithAngle'
      character (len=*), parameter :: ZonalDataTitles = &
        & 'L3mzStdDeviation,L3mzValue,L3mzPrecision,L3mzDataCount,PerMisPoints'
      character(len=CHARATTRLEN), dimension(NumOfZonalFields) :: theTitles
      character(len=CHARATTRLEN), dimension(NumOfDataFields) :: dataTitles
      character(len=CHARATTRLEN) :: units_name, field_name
      real, parameter    :: UNDEFINED_VALUE =  -999.999
                                                                        
      ! Variables
                                                                        
      CHARACTER (LEN=480) :: msr
      CHARACTER (len=*), parameter :: AURA_FIELD = 'Aura-shared '
      CHARACTER (len=*), parameter :: MLS_SHARED_FIELD = 'HIRDL-MLS-TES-shared '
      CHARACTER (len=*), parameter :: MLS_FIELD = 'MLS-Specific '
      CHARACTER (len=*), parameter :: COORDINATE = 'VerticalCoordinate'
      CHARACTER (len=*), parameter :: ZONAL_SPACING = 'ZonalSpacing'
      CHARACTER (len=*), parameter :: ZSPACING_VALUE = '2'
      CHARACTER (len=*), parameter :: ZONAL_SPACING_UNIT = 'ZonalSpacingUnit'
      CHARACTER (len=*), parameter :: ZSPACINGUNIT_VALUE = 'Degree'
      CHARACTER (len=*), parameter :: PRESSURE = 'Pressure'
      INTEGER (HID_T) :: zafID, zaId
      INTEGER :: status, n, m, field
                                                                        
      ! Functions
        
     INTEGER, EXTERNAL :: he5_zaattach, he5_zaclose, he5_zadetach, &
	& he5_zaopen, he5_zawrlattr, he5_zawrattr
                                                                
      call List2Array(ZonalFieldTitles, theTitles, .true.)
      call List2Array(ZonalDataTitles, dataTitles, .true.)

      zafID = he5_zaopen(trim(file), HE5F_ACC_RDWR)
      IF (zafID == -1) THEN
         msr = MLSMSG_Fileopen // trim(file) //' for writing zonal'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                        
      zaId = he5_zaattach(zafID, mz%name)
      IF (zaID == -1) THEN
         msr = 'Failed to attach to zonal ' // trim(mz%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Write File Level Attributes

      status = he5_zawrattr(zaId, COORDINATE, MLS_CHARTYPE, &
           &  len_trim(PRESSURE), PRESSURE)
      IF (status /= 0) THEN
         msr = FILEATTR_ERR // COORDINATE 
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrattr(zaId, 'Pressure', HE5T_NATIVE_FLOAT, mz%nLevels, &
	  & REAL(mz%Pressure))
      IF (status /= 0) THEN
         msr = FILEATTR_ERR // 'Pressure' 
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrattr(zaId, ZONAL_SPACING, MLS_CHARTYPE, &
           &  len_trim(ZSPACING_VALUE), ZSPACING_VALUE)
      IF (status /= 0) THEN
         msr = FILEATTR_ERR // ZONAL_SPACING 
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrattr(zaId, ZONAL_SPACING_UNIT, MLS_CHARTYPE, &
           &  len_trim(ZSPACINGUNIT_VALUE), ZSPACINGUNIT_VALUE)
      IF (status /= 0) THEN
         msr = FILEATTR_ERR // ZONAL_SPACING_UNIT 
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                        
      ! Write attributes for zonal (geolocation) fields
                                                                        
      do field=1, NumOfZonalFields
        status = he5_zawrlattr(zaId, theTitles(field), 'Missing Value', &
           & HE5T_NATIVE_FLOAT, 1, UNDEFINED_VALUE)
        status = he5_zawrlattr(zaId, theTitles(field), 'Title', &
           & MLS_CHARTYPE, len_trim(theTitles(field)), theTitles(field))
        if (theTitles(field) == 'Pressure') then
           status = he5_zawrlattr(zaId, theTitles(field), 'Unit', &
             & MLS_CHARTYPE, 3, 'hPa')
           status = he5_zawrlattr(zaId, theTitles(field), &
             & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(AURA_FIELD), &
             & AURA_FIELD)
        else if (theTitles(field) == 'LocalSolarTime') then
           status = he5_zawrlattr(zaId, theTitles(field), 'Unit', &
             & MLS_CHARTYPE, 1, 'h')
           status = he5_zawrlattr(zaId, theTitles(field), &
             & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(MLS_FIELD), &
             & MLS_FIELD)
        else
           status = he5_zawrlattr(zaId, theTitles(field), 'Unit', &
             & MLS_CHARTYPE, 3, 'deg')
           status = he5_zawrlattr(zaId, theTitles(field), &
             & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(MLS_SHARED_FIELD), &
             & MLS_SHARED_FIELD)
        endif
      enddo
                                                                        
      ! Write attributes for data fields
                                                                        
        select case (trim(lowercase(mz%name(1:3))))
        case ('tem')
           units_name = 'K'
        case ('gph')
           units_name = 'm'
        case ('rhi')
           units_name = '%rhi'
        case default
           units_name = 'vmr'
        end select
                                                                        
      do field=1, NumOfDataFields
        field_name = trim(mz%name)//'-'//dataTitles(field)
        status = he5_zawrlattr(zaId, dataTitles(field), 'Missing Value', &
           & HE5T_NATIVE_FLOAT, 1, UNDEFINED_VALUE)
        status = he5_zawrlattr(zaId, dataTitles(field), 'Title', &
           & MLS_CHARTYPE, len_trim(field_name), field_name)
        if ((dataTitles(field) == 'L3mzDataCount') .or. &
           & (dataTitles(field) == 'PerMisPoints')) then
           status = he5_zawrlattr(zaId, dataTitles(field), 'Unit', &
              & MLS_CHARTYPE, 7, 'NoUnits' )
	else
           status = he5_zawrlattr(zaId, dataTitles(field), 'Unit', &
              & MLS_CHARTYPE, len_trim(units_name), units_name )
        endif
        status = he5_zawrlattr(zaId, dataTitles(field), &
           & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(MLS_FIELD), &
             & MLS_FIELD)
      enddo
                                                                        
      status = he5_zadetach(zaID)
      IF (status == -1) THEN
         msr = 'Failed to deattach to zonal ' // trim(mz%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zaclose(zafID)
      IF (status == -1) THEN
          msr = 'Failed to close file ' // trim(file) // ' after writing.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
                                                                        
!----------------------------------------------
  END SUBROUTINE WriteAttributeMZ
!----------------------------------------------
                                                                        
!----------------------------------------------------------
   SUBROUTINE WriteMetaL3MZ (fileName, mcfNum, pcf, anText, nFiles, hdfVersion)
!----------------------------------------------------------
   USE PCFHdr, ONLY: WritePCF2Hdr, WriteInputPointer, he5_writeglobalattr, &
	& GlobalAttributes
   USE HDFEOS5, ONLY: HE5F_ACC_RDWR, HE5_GDCLOSE, HE5_GDOPEN
   USE output_m, only: output

! Brief description of subroutine
! This routine writes the metadata for an l3mz file, and annotates it with the
! PCF.

! Arguments

      TYPE( PCFMData_T ), INTENT(IN) :: pcf

      CHARACTER(LEN=*), INTENT(IN) :: fileName

      INTEGER, INTENT(IN) :: mcfNum

      CHARACTER (LEN=1), POINTER :: anText(:)

      INTEGER, INTENT(IN) :: hdfVersion

      INTEGER, INTENT(IN) :: nFiles

! Parameters

! Functions

      INTEGER, EXTERNAL :: pgs_met_init, pgs_met_remove, pgs_met_setAttr_d, &
      & pgs_met_setAttr_i,pgs_met_setAttr_s, pgs_met_write, & 
      & pgs_pc_getUniversalRef, he5_zainqza, he5_zaopen, he5_zaclose

! Variables

      CHARACTER (LEN=6000) :: list
      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
      CHARACTER (LEN=98) :: inpt(31)
      CHARACTER (LEN=GridNameLen) :: zonalName
      CHARACTER (LEN=FileNameLen) :: sval
      CHARACTER (LEN=45) :: attrName, lvid
      CHARACTER (LEN=3)  :: cNum
      ! CHARACTER (LEN=2)  :: fileType
      integer :: fileType

      REAL(r8) :: dval

      INTEGER :: dg, hdfReturn, i, indx, len, numZonal, pNum, &
           & result, returnStatus, sdid, version
      INTEGER :: daysNum = 1

! calculate the daysNum

     daysNum = nFiles + 1 
     !call output('daysNum = ', advance='no')
     !call output(daysNum, advance='yes')

! Check to see whether this is the Diagnostic files

      dg = 0

      IF ( INDEX(fileName,'Diagnostic') /= 0 ) dg = 1

! Initialize the fileType

      fileType = l_swath

! Initialize the MCF

      result = pgs_met_init(mcfNum, groups)
      IF (result /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, ModuleName, &
           & 'Initialization error.  See LogStatus for details.')

! Open the HDF file and initialize the SD interface

      sdid = mls_sfstart(trim(fileName), DFACC_RDWR, hdfVersion=hdfVersion, & 
           &  addingMetaData=.TRUE.)
      IF (sdid == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
           & 'Failed to open the HDF file for metadata writing.')

! Set PGE values -- ECSDataGranule

      attrName = 'ReprocessingPlanned'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
           & 'further update anticipated using enhanced PGE')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'LocalGranuleID'
      indx = INDEX(fileName, '/', .TRUE.)
      sval = fileName(indx+1:)
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, sval)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'DayNightFlag'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, 'Both')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'LocalVersionID'
      CALL ExpandFileTemplate('$cycle', lvid, cycle=pcf%cycle)
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, lvid)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! MeasuredParameterContainer -- find the number of swaths in the file

      numZonal = 0
      numZonal = he5_zainqza(trim(fileName), list, len) 

!      call output(trim(list), advance='yes')
!      call output('In L3MZ: len = ', advance='no')
!      call output(len, advance='yes')
!      call output('In L3MZ: numZonal = ', advance='no')
!      call output(numZonal, advance='yes')
      IF (numZonal .LE. 0) THEN
         msr = 'No zonal found in file ' // TRIM(fileName) // &
              & ' while attempting to write its metadata.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      pNum = 0

! For each zonal in the file

      DO i = 1, numZonal

! Extract its name

         indx = INDEX(list, ',')
         IF (indx /= 0) THEN
            zonalName = list(:indx-1)
            list = list(indx+1:)
         ELSE
            zonalName = list
         ENDIF

!         call output('zonalName =', advance='no')
!         call output(trim(zonalName), advance='yes')

! If this is a diagnostic zonal, skip to the next one

         IF ( INDEX(zonalName, 'Diagnostics') /= 0) CYCLE

! Append a class suffix to ParameterName, and write the grid name as its value

         pNum = pNum + 1

         IF (pNum < 10) THEN
            WRITE( cNum, '(I1)' ) pNum
         ELSE IF ( (pNum >= 10) .AND. (pNum < 100) ) THEN
            WRITE( cNum, '(I2)' ) pNum
         ELSE
            WRITE( cNum, '(I3)' ) pNum
         ENDIF

         attrName = 'ParameterName' // '.' // cNum
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, & 
              & zonalName)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! QAStats Group

         attrName = 'QAPercentInterpolatedData' // '.' // cNum
         result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 0)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         attrName = 'QAPercentMissingData' // '.' // cNum
         result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 0)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         attrName = 'QAPercentOutofBoundsData' // '.' // cNum
         result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 0)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      ENDDO

! OrbitCalculatedSpatialDomainContainer

      ! This changes confirm James Johnson suggestion on 6/12/03
      ! Use 99999 for invalid value for now

      !attrName = 'OrbitNumber' // '.1'
      !result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
      !IF (result /= PGS_S_SUCCESS) THEN
      !   msr = METAWR_ERR // attrName
      !   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      !ENDIF

      attrName = 'StartOrbitNumber' // '.1'
      !result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
      !result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 99999)
      IF (GlobalAttributes%OrbNumDays(1,daysNum) == -1) THEN
           result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), &
                & attrName, 99999)
      ELSE
           result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), &
                & attrName, GlobalAttributes%OrbNumDays(1,daysNum))
      ENDIF
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'StopOrbitNumber' // '.1'
      !result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
      !result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 99999)
      IF (maxval(GlobalAttributes%OrbNumDays(:,daysNum)) == -1) then
           result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), &
                & attrName, 99999)
      ELSE 
           result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), &
                & attrName, maxval(GlobalAttributes%OrbNumDays(:,daysNum)))
      END IF 
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'EquatorCrossingLongitude' // '.1'
      dval = 0.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), attrName, dval)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      attrName = 'EquatorCrossingTime' // '.1'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, & 
           & '00:00:00')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      attrName = 'EquatorCrossingDate' // '.1'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, & 
              & pcf%startDay )
              ! & '1899-04-29')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! InputPointer
      
      attrName = 'InputPointer'
! >       inpt = ''
! >       IF (dg == 1) THEN
! >          indx = mlspcf_l2dg_start
! >       ELSE
! >          indx = mlspcf_l2gp_start
! >       ENDIF
! >       DO i = 1, 31
! >          version = 1
! >          returnStatus = pgs_pc_getUniversalRef(indx, version, sval)
! >          IF (returnStatus == PGS_S_SUCCESS) THEN
! >             inpt(i) = sval
! >             indx = indx + 1
! >          ENDIF
! >       ENDDO
      
      ! result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, inpt)
      result = WriteInputPointer(groups(INVENTORYMETADATA), attrName, &
        & fileType=l_hdfeos)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Locality Value

      attrName = 'LocalityValue'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, 'Limb')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! VerticalSpatialDomain Product-Specific Attribute
      
      attrName = 'VerticalSpatialDomainType' // '.1'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
           & 'Atmosphere Layer')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      attrName = 'VerticalSpatialDomainValue' // '.1'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
           & 'Atmosphere Profile')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! HorizontalSpatialDomainContainer

      attrName = 'ZoneIdentifier'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
           & 'Other Grid System')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'WestBoundingCoordinate'
      dval = -180.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), attrName, dval)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'NorthBoundingCoordinate'
      dval = 90.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), attrName, dval)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'EastBoundingCoordinate'
      dval = 180.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), attrName, dval)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'SouthBoundingCoordinate'
      dval = -90.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), attrName, dval)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! RangeDateTime Group

      attrName = 'RangeBeginningDate'
      result = pgs_met_setAttr_s( groups(INVENTORYMETADATA), attrName, &
           & pcf%startDay)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'RangeBeginningTime'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
           & '00:00:00.000000')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      attrName = 'RangeEndingDate'
      result = pgs_met_setAttr_s( groups(INVENTORYMETADATA), attrName, &
           & pcf%endDay )
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      attrName = 'RangeEndingTime'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
           & '23:59:59.999999')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! PGEVersion

      attrName = 'PGEVersion'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
           & pcf%outputVersion)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Write the metadata and their values to HDF attributes
   
      result = pgs_met_write(groups(INVENTORYMETADATA), "coremetadata", sdid)
      IF (result /= PGS_S_SUCCESS) THEN
         IF (result == PGSMET_E_MAND_NOT_SET) THEN
            CALL MLSMessage(MLSMSG_Error, ModuleName, & 
                 & 'Some of the mandatory metadata parameters were not set.')
         ELSE
            CALL MLSMessage(MLSMSG_Error, ModuleName, & 
                   & 'Metadata write failed.')
         ENDIF
      ENDIF

! Terminate access to the SD interface and close the file

      hdfReturn = mls_sfend(sdid, hdfVersion=hdfVersion, & 
           &  addingMetaData=.TRUE.)
      IF (hdfReturn /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, &
           & 'Error closing HDF file after writing metadata.')

! Annotate the file with the PCF

      ! Write global attributes
      if ( HDFVersion == HDFVERSION_5 ) then
        sdid = he5_zaopen (fileName, HE5F_ACC_RDWR)
	if (sdid == -1) then 
            msr = 'Failed to open file before writting global attribute' &
	 	& // trim(fileName)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        end if
        call he5_writeglobalattr(sdid,daysNum)
        result = he5_zaclose (sdid)
	if (result == -1) then 
            msr = 'Failed to close file after write global attribute' &
		& // trim(fileName)
            CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
        end if
      endif
                                                                            
      CALL WritePCF2Hdr(fileName, anText, hdfVersion=hdfVersion, & 
           & fileType=fileType)

      result = pgs_met_remove()
      if (result /= PGS_S_SUCCESS .and. WARNIFCANTPGSMETREMOVE) THEN 
         write(msr, *) result
         CALL MLSMessage (MLSMSG_Warning, ModuleName, &
             & "Calling pgs_met_remove() failed with value " // trim(msr) )
      endif

!------------------------------
   END SUBROUTINE WriteMetaL3MZ
!------------------------------

!--------------------------------------------
   SUBROUTINE AllocateL3MZ (nlev, nlat, l3mz)
!--------------------------------------------

! Brief description of subroutine
! This subroutine allocates the internal field pointers of the L3MZData_T
! derived type.

! Arguments

      INTEGER, INTENT(IN) :: nlev, nlat

      TYPE( L3MZData_T ), INTENT(INOUT) :: l3mz

! Parameters

! Functions

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: err

! Store the sizes of the dimensions

      l3mz%nLevels = nlev
      l3mz%nLats = nlat

! Allocate the vertical geolocation field

      ALLOCATE(l3mz%pressure(l3mz%nLevels), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' pressure pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Horizontal geolocation field

      ALLOCATE(l3mz%latitude(l3mz%nLats), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' latitude pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Ancillary data fields

      ALLOCATE(l3mz%localSolarTime(MIN_MAX,l3mz%nLats), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' local solar time pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE(l3mz%SolarZenithAngle(MIN_MAX,l3mz%nLats), &
               STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' Solar zenith angle pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Data fields

      ALLOCATE(l3mz%l3mzValue(l3mz%nLevels,l3mz%nLats), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' l3mzValue pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE(l3mz%l3mzPrecision(l3mz%nLevels,l3mz%nLats), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' l3mzPrecision pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE(l3mz%dataCount(l3mz%nLevels,l3mz%nLats), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' l3mzDataCount pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Diagnostic fields

      ALLOCATE(l3mz%latRss(l3mz%nLevels,l3mz%nLats), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' latRss pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE(l3mz%perMisPoints(l3mz%nLevels,l3mz%nLats), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' perMisPoints pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

!-----------------------------
   END SUBROUTINE AllocateL3MZ
!-----------------------------

!----------------------------------
   SUBROUTINE DeallocateL3MZ (l3mz)
!----------------------------------

! Brief description of subroutine
! This subroutine deallocates the internal field pointers of the L3MZData_T
! derived type, after the calling program has finished with the data.

! Arguments

      TYPE( L3MZData_T ), INTENT(INOUT) :: l3mz

! Parameters

! Functions

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: err

! Vertical geolocation field

      IF ( ASSOCIATED(l3mz%pressure) ) THEN
         DEALLOCATE (l3mz%pressure, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  pressure pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

! Horizontal geolocation field

      IF ( ASSOCIATED(l3mz%latitude) ) THEN
         DEALLOCATE (l3mz%latitude, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  latitude pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

! Ancillary data fields

      IF ( ASSOCIATED(l3mz%localSolarTime) ) THEN
         DEALLOCATE (l3mz%localSolarTime, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  local solar time pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

      IF ( ASSOCIATED(l3mz%SolarZenithAngle) ) THEN
         DEALLOCATE (l3mz%SolarZenithAngle, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  Solar zenith angle pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

! Data fields

      IF ( ASSOCIATED(l3mz%l3mzValue) ) THEN
         DEALLOCATE (l3mz%l3mzValue, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3mzValue pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

      IF ( ASSOCIATED(l3mz%l3mzPrecision) ) THEN
         DEALLOCATE (l3mz%l3mzPrecision, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3mzPrecision pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

      IF ( ASSOCIATED(l3mz%dataCount) ) THEN
         DEALLOCATE (l3mz%dataCount, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3mzDataCount pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

! Diagnostic fields

      IF ( ASSOCIATED(l3mz%latRss) ) THEN
         DEALLOCATE (l3mz%latRss, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  latRss pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

      IF ( ASSOCIATED(l3mz%perMisPoints) ) THEN
         DEALLOCATE (l3mz%perMisPoints, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  perMisPoints pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

!-------------------------------
   END SUBROUTINE DeallocateL3MZ
!-------------------------------

!==================
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: L3MZData.f90,v 1.22 2006/05/03 14:40:51 cvuu Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
END MODULE L3MZData
!==================

! $Log: L3MZData.f90,v $
! Revision 1.22  2006/05/03 14:40:51  cvuu
! Remove subroutine OutputMZDiag, move datasets from Swath group to Zonal Means group
!
! Revision 1.21  2006/02/28 20:36:33  cvuu
! V2.00 commit
!
! Revision 1.20  2005/06/23 19:17:58  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.19  2005/01/27 00:35:06  pwagner
! ReprocessingActual field dropped from product metadata
!
! Revision 1.18  2004/12/16 15:00:49  cvuu
! v1.5: Change value of ReprocessingActual to unknown in metadata file
!
! Revision 1.17  2004/12/13 17:41:26  cvuu
! remove writing QA flags to meta file, use the ones in MCF v1.5
!
! Revision 1.16  2004/05/04 15:57:20  cvuu
! Fixed bug
!
! Revision 1.15  2004/01/08 21:21:36  cvuu
! version 1.4 commit
!
! Revision 1.14  2003/09/16 16:35:21  cvuu
! Add new parameter nFiles to the subroutine WriteMetaL3MZ
!
! Revision 1.13  2003/09/15 18:27:23  cvuu
! Output OrbitNumber and OrbitPeriod in the global attribute
!
! Revision 1.12  2003/08/11 23:26:37  cvuu
! brought closer to James Johnson want to
!
! Revision 1.11  2003/07/08 00:17:46  pwagner
! fileType now a lit_name instead of a char string
!
! Revision 1.10  2003/06/02 23:45:15  pwagner
! metadata chnages: OrbitNumber now -1; equatorCrossingDate now utc start date
!
! Revision 1.9  2003/05/30 23:54:07  pwagner
! Relies on lib/PCFHdr to WriteInputPointer
!
! Revision 1.8  2003/04/30 18:16:29  pwagner
! Work-around for LF95 infinite compile-time bug
!
! Revision 1.7  2003/04/06 02:25:50  jdone
! added HDFEOS5 capability
!
! Revision 1.6  2003/03/15 00:20:02  pwagner
! May warn if pgs_met_remove returns non-zero value
!
! Revision 1.5  2001/12/12 17:46:30  nakamura
! Added dg fields; removed unused subroutine DestroyL3MZDatabase.
!
! Revision 1.4  2001/11/12 20:25:50  nakamura
! Added L3MZDiag_T.
!
! Revision 1.3  2001/10/04 18:25:04  nakamura
! Removed lev as dim for local solar fields.
!
! Revision 1.2  2001/09/26 19:47:03  nakamura
! Added local solar ancillary fields.
!
! Revision 1.1  2001/07/18 15:42:09  nakamura
! Module for the L3MZ data type.
!
@


1.22
log
@Remove subroutine OutputMZDiag, move datasets from Swath group to Zonal Means group
@
text
@d26 1
a26 1
        & GEO_FIELD12, &
d81 1
a81 1
     REAL(r8), DIMENSION(:,:), POINTER :: localSolarZenithAngle
d244 1
a244 1
      status = he5_zadefine(swID, GEO_FIELD12, DIMRL_NAME, "", HE5T_NATIVE_FLOAT)
d246 1
a246 1
         msr = GEO_ERR // GEO_FIELD12
d327 2
a328 2
      status = he5_zawrite( swID, GEO_FIELD12, start, stride, edge, &
           & REAL(mz%localSolarZenithAngle) )
d330 1
a330 1
         msr = WR_ERR // GEO_FIELD12
d448 1
a448 1
      status = he5_zasetalias(zaId, L3VALUE, trim(mz%name//'Value'))
d454 1
a454 1
      status = he5_zasetalias(zaId, L3PREC, trim(mz%name//'Precision'))
d460 1
a460 1
      status = he5_zasetalias(zaId, L3STDDEV, trim(mz%name//'StdDeviation'))
d466 1
a466 1
      status = he5_zasetalias(zaId, L3DCOUNT, trim(mz%name//'DataCount'))
d511 1
a511 1
        & 'Latitude,Pressure,Time,LocalSolarTime,LocalSolarZenithAngle'
d626 1
a626 1
        field_name = trim(mz%name)//dataTitles(field)
d1172 1
a1172 1
      ALLOCATE(l3mz%localSolarZenithAngle(MIN_MAX,l3mz%nLats), &
d1175 1
a1175 1
         msr = MLSMSG_Allocate // ' local solar zenith angle pointer.'
d1269 2
a1270 2
      IF ( ASSOCIATED(l3mz%localSolarZenithAngle) ) THEN
         DEALLOCATE (l3mz%localSolarZenithAngle, STAT=err)
d1272 1
a1272 1
            msr = MLSMSG_DeAllocate // '  local solar zenith angle pointer.'
d1329 1
a1329 1
       "$Id: L3MZData.f90,v 1.21 2006/02/28 20:36:33 cvuu Exp $"
d1338 3
@


1.21
log
@V2.00 commit
@
text
@a57 1
!                OutputMZDiag
d276 6
d365 7
a381 4
! Create & write the diagnostic zonal

      CALL OutputMZDiag_HE5(file, swfID, mz)

d509 1
a509 1
      integer, parameter :: NumOfDataFields = 4
d513 1
a513 1
        & 'L3mzStdDeviation,L3mzValue,L3mzPrecision,L3mzDataCount'
d597 6
d631 8
a638 2
        status = he5_zawrlattr(zaId, dataTitles(field), 'Unit', &
           & MLS_CHARTYPE, len_trim(units_name), units_name )
a659 165
!-------------------------------------------
   SUBROUTINE OutputMZDiag_HE5 (file, swfID, mz)
!-------------------------------------------
   USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC, HE5T_NATIVE_CHAR

! Brief description of subroutine
! This subroutine creates and writes to the diagnostic swaths in an l3mz file.

! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: file

      INTEGER, INTENT(IN) :: swfID

      TYPE( L3MZData_T ), INTENT(IN) :: mz

! Parameters

! Functions

      INTEGER, EXTERNAL :: he5_zaattach, he5_zacreate, he5_zadefine, & 
           & he5_zadefdim, he5_zadetach, he5_zawrite

! Variables

      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=GridNameLen) :: dgName

      INTEGER :: start(2), stride(2), edge(2)
      INTEGER :: status, swID

! Create a zonal of the appropriate name

      dgName = TRIM(mz%name) // 'Diagnostics'

      swID = he5_zacreate(swfID, trim(dgName) )
      IF (swID == -1) THEN
         msr = 'Failed to create zonal ' // trim(dgName)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Define the zonal dimensions

      status = he5_zadefdim(swID, DIMR_NAME, MIN_MAX)
      IF (status == -1) THEN
         msr = DIM_ERR // DIMR_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefdim(swID, DIM_NAME2, mz%nLevels)
      IF (status == -1) THEN
         msr = DIM_ERR // DIM_NAME2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefdim(swID, DIML_NAME, mz%nLats)
      IF (status == -1) THEN
         msr = DIM_ERR // DIML_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Define the swath geolocation fields using the above dimensions

      status = he5_zadefine(swID, GEO_FIELD3, DIMR_NAME, "", HE5T_NATIVE_DOUBLE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

!      status = he5_zadefine(swID, GEO_FIELD9, DIM_NAME2, "", HE5T_NATIVE_FLOAT)
!      IF (status == -1) THEN
!         msr = GEO_ERR // GEO_FIELD9
!         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
!      ENDIF

!      status = he5_zadefine(swID, GEO_FIELD1, DIML_NAME, "", HE5T_NATIVE_FLOAT)
!      IF (status == -1) THEN
!         msr = GEO_ERR // GEO_FIELD1
!         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
!      ENDIF

! Define the zonal data fields using the above dimensions

      status = he5_zadefine(swID, DG_FIELD1, DIMLL_NAME, "", HE5T_NATIVE_FLOAT)
      IF (status == -1) THEN
         msr = DAT_ERR // DG_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zadefine(swID, DG_FIELD2, DIMLL_NAME, "", HE5T_NATIVE_INT)
      IF (status == -1) THEN
         msr = DAT_ERR // DG_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Write the data

      start = 0
      stride = 1
      edge(1) = mz%nLevels
      edge(2) = mz%nLats

! Geolocation fields

      status = he5_zawrite(swID, GEO_FIELD3, start(1), stride(1), stride(1), &
           & mz%startTime)
      IF (status == -1) THEN
          msr = WR_ERR // GEO_FIELD3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrite(swID, GEO_FIELD3, stride(1), stride(1), stride(1), &
           & mz%endTime)
      IF (status == -1) THEN
          msr = WR_ERR // GEO_FIELD3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

!      status = he5_zawrite( swID, GEO_FIELD9, start(1), stride(1), edge(1), &
!           & REAL(mz%pressure) )
!      IF (status == -1) THEN
!         msr = WR_ERR // GEO_FIELD9
!         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
!      ENDIF

!      status = he5_zawrite( swID, GEO_FIELD1, start(2), stride(2), edge(2), &
!           & REAL(mz%latitude) )
!      IF (status == -1) THEN
!         msr = WR_ERR // GEO_FIELD1
!         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
!      ENDIF

! Data fields

      status = he5_zawrite( swID, DG_FIELD1, start, stride, edge, & 
           & REAL(mz%latRss) )
      IF (status == -1) THEN
         msr = WR_ERR // DG_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_zawrite( swID, DG_FIELD2, start, stride, edge, & 
           & mz%perMisPoints)
      IF (status == -1) THEN
         msr = WR_ERR // DG_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! After writing, detach from zonal interface

      status = he5_zadetach(swID)
      IF (status /= 0) THEN
          msr = SW_ERR // TRIM(dgName) // ' after writing.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      msr = 'Zonal '// TRIM(dgName) // ' successfully written to file ' // & 
           & trim(file)
      CALL MLSMessage(MLSMSG_Info, ModuleName, msr)

!-----------------------------
   END SUBROUTINE OutputMZDiag_HE5
!-----------------------------

d1329 1
a1329 1
       "$Id: L3MZData.f90,v 1.20 2005/06/23 19:17:58 pwagner Exp $"
d1338 3
@


1.20
log
@Reworded Copyright statement, moved rcs id
@
text
@d28 1
a28 1
        & FILENAMELEN
d50 1
a50 1
       "$RCSfile: $"
d60 2
d72 2
d89 1
d135 1
a135 3
      IF (hdfVersion == HDFVERSION_4) THEN 
         CALL OutputL3MZ_HE2 (file, mz, createFlag)
      ELSE IF (hdfVersion == HDFVERSION_5) THEN 
d137 2
a145 229
   SUBROUTINE OutputL3MZ_HE2 (file, mz, createFlag)
!----------------------------------------------

! Brief description of subroutine
! This subroutine creates and writes to the swaths in an l3mz file.

! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: file

      TYPE( L3MZData_T ), INTENT(IN) :: mz

      LOGICAL, INTENT(INOUT) :: createFlag

! Parameters

! Functions

      INTEGER, EXTERNAL :: swattach, swclose, swcreate, swdefdfld, swdefdim, &
           & swdefgfld, swdetach, swopen, swwrfld

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: start(2), stride(2), edge(2)
      INTEGER :: status, swfID, swID

! Open the file for appending a swath

      swfID = swopen(file, DFACC_RDWR)
      IF (swfID == -1) THEN
         msr = MLSMSG_Fileopen // trim(file)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Create a swath of the appropriate name

      swID = swcreate(swfID, mz%name)
      IF (swID == -1) THEN
         msr = 'Failed to create swath ' // trim(mz%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Define the swath dimensions

      status = swdefdim(swID, DIMR_NAME, MIN_MAX)
      IF (status == -1) THEN
         msr = DIM_ERR // DIMR_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefdim(swID, DIM_NAME2, mz%nLevels)
      IF (status == -1) THEN
         msr = DIM_ERR // DIM_NAME2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefdim(swID, DIML_NAME, mz%nLats)
      IF (status == -1) THEN
         msr = DIM_ERR // DIML_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Define the swath geolocation fields using the above dimensions

      status = swdefgfld(swID, GEO_FIELD3, DIMR_NAME, DFNT_FLOAT64, & 
           & HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swID, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD9
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swID, GEO_FIELD1, DIML_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swID, GEO_FIELD4, DIMRL_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD4
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swID, GEO_FIELD12, DIMRL_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD12
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Define the swath data fields using the above dimensions

      status = swdefdfld(swID, DATA_FIELDV, DIMLL_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = DAT_ERR // DATA_FIELDV
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefdfld(swID, DATA_FIELDP, DIMLL_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = DAT_ERR // DATA_FIELDP
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Detach from the swath interface after definition

      status = swdetach(swID)
      IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
           & 'Failed to detach from swath interface after L3DZ definition.')

! Re-attach to the swath for writing

      swID = swattach(swfID, mz%name)
      IF (swID == -1) THEN
         msr = 'Failed to re-attach to swath '//TRIM(mz%name)// ' for writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Write the data

      start = 0
      stride = 1
      edge(1) = mz%nLevels
      edge(2) = mz%nLats

! Geolocation fields

      status = swwrfld(swID, GEO_FIELD3, start(1), stride(1), stride(1), &
           & mz%startTime)
      IF (status == -1) THEN
          msr = WR_ERR // GEO_FIELD3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld(swID, GEO_FIELD3, stride(1), stride(1), stride(1), &
           & mz%endTime)
      IF (status == -1) THEN
          msr = WR_ERR // GEO_FIELD3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swID, GEO_FIELD9, start(1), stride(1), edge(1), &
           & REAL(mz%pressure) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD9
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swID, GEO_FIELD1, start(2), stride(2), edge(2), &
           & REAL(mz%latitude) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      edge(1) = MIN_MAX
      status = swwrfld( swID, GEO_FIELD4, start, stride, edge, &
           & REAL(mz%localSolarTime) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD4
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swID, GEO_FIELD12, start, stride, edge, &
           & REAL(mz%localSolarZenithAngle) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD12
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Data fields

      edge(1) = mz%nLevels
      status = swwrfld( swID, DATA_FIELDV, start, stride, edge, & 
           & REAL(mz%l3mzValue) )
      IF (status == -1) THEN
         msr = WR_ERR // DATA_FIELDV
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swID, DATA_FIELDP, start, stride, edge, &
           & REAL(mz%l3mzPrecision) )
      IF (status == -1) THEN
         msr = WR_ERR // DATA_FIELDP
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! After writing, detach from swath interface

      status = swdetach(swID)
      IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
           & 'Failed to detach from swath interface after writing.')

      msr = 'Zonal ' // TRIM(mz%name) // ' successfully written to file ' & 
           & // trim(file)
      CALL MLSMessage(MLSMSG_Info, ModuleName, msr)

! Create & write the diagnostic swath

      CALL OutputMZDiag_HE2(file, swfID, mz)

! Close the file

      status = swclose(swfID)
      IF (status == -1) THEN
         msr = 'Failed to close file ' // trim(file) // ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      createFlag = .TRUE.

!---------------------------
   END SUBROUTINE OutputL3MZ_HE2
!---------------------------

!----------------------------------------------
d265 12
d339 1
a339 1
      status = he5_zawrite( swID, DATA_FIELDP, start, stride, edge, &
d346 14
d384 6
d394 13
a406 9
!-------------------------------------------
   SUBROUTINE OutputMZDiag_HE2 (file, swfID, mz)
!-------------------------------------------

! Brief description of subroutine
! This subroutine creates and writes to the diagnostic swaths in an l3mz file.

! Arguments

d408 15
a422 14

      INTEGER, INTENT(IN) :: swfID

      TYPE( L3MZData_T ), INTENT(IN) :: mz

! Parameters

! Functions

      INTEGER, EXTERNAL :: swattach, swcreate, swdefdfld, swdefdim, swdefgfld,&
           & swdetach, swwrfld

! Variables

d424 7
a430 12
      CHARACTER (LEN=GridNameLen) :: dgName

      INTEGER :: start(2), stride(2), edge(2)
      INTEGER :: status, swID

! Create a swath of the appropriate name

      dgName = TRIM(mz%name) // 'Diagnostics'

      swID = swcreate(swfID, dgName)
      IF (swID == -1) THEN
         msr = 'Failed to create swath ' // trim(dgName)
d433 4
a436 6

! Define the swath dimensions

      status = swdefdim(swID, DIMR_NAME, MIN_MAX)
      IF (status == -1) THEN
         msr = DIM_ERR // DIMR_NAME
d440 9
a448 3
      status = swdefdim(swID, DIM_NAME2, mz%nLevels)
      IF (status == -1) THEN
         msr = DIM_ERR // DIM_NAME2
d450 5
a454 5
      ENDIF

      status = swdefdim(swID, DIML_NAME, mz%nLats)
      IF (status == -1) THEN
         msr = DIM_ERR // DIML_NAME
d456 5
a460 8
      ENDIF

! Define the swath geolocation fields using the above dimensions

      status = swdefgfld(swID, GEO_FIELD3, DIMR_NAME, DFNT_FLOAT64, & 
           & HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD3
d462 3
a464 4
      ENDIF

      status = swdefgfld(swID, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
d466 1
a466 1
         msr = GEO_ERR // GEO_FIELD9
d470 1
a470 2
      status = swdefgfld(swID, GEO_FIELD1, DIML_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
d472 71
a542 1
         msr = GEO_ERR // GEO_FIELD1
d546 1
a546 1
! Define the swath data fields using the above dimensions
d548 4
a551 4
      status = swdefdfld(swID, DG_FIELD1, DIMLL_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = DAT_ERR // DG_FIELD1
d555 4
a558 3
      status = swdefdfld(swID, DG_FIELD2, DIMLL_NAME, DFNT_INT32, HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = DAT_ERR // DG_FIELD2
d562 2
a563 3
! Detach from the swath interface after definition

      status = swdetach(swID)
d565 1
a565 9
          msr = SW_ERR // TRIM(dgName) // ' after L3MZ dg definition.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Re-attach to the swath for writing

      swID = swattach(swfID, dgName)
      IF (swID == -1) THEN
         msr = 'Failed to re-attach to swath '// TRIM(dgName) //' for writing.'
d569 4
a572 27
! Write the data

      start = 0
      stride = 1
      edge(1) = mz%nLevels
      edge(2) = mz%nLats

! Geolocation fields

      status = swwrfld(swID, GEO_FIELD3, start(1), stride(1), stride(1), &
           & mz%startTime)
      IF (status == -1) THEN
          msr = WR_ERR // GEO_FIELD3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld(swID, GEO_FIELD3, stride(1), stride(1), stride(1), &
           & mz%endTime)
      IF (status == -1) THEN
          msr = WR_ERR // GEO_FIELD3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swID, GEO_FIELD9, start(1), stride(1), edge(1), &
           & REAL(mz%pressure) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD9
d575 50
a624 3

      status = swwrfld( swID, GEO_FIELD1, start(2), stride(2), edge(2), &
           & REAL(mz%latitude) )
d626 1
a626 1
         msr = WR_ERR // GEO_FIELD1
d630 1
a630 3
! Data fields

      status = swwrfld( swID, DG_FIELD1, start, stride, edge, REAL(mz%latRss) )
d632 1
a632 15
         msr = WR_ERR // DG_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swID, DG_FIELD2, start, stride, edge, mz%perMisPoints)
      IF (status == -1) THEN
         msr = WR_ERR // DG_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! After writing, detach from swath interface

      status = swdetach(swID)
      IF (status /= 0) THEN
          msr = SW_ERR // TRIM(dgName) // ' after writing.'
d634 6
a639 10
      ENDIF

      msr = 'Swath '// TRIM(dgName) // ' successfully written to file ' // & 
           & trim(file)
      CALL MLSMessage(MLSMSG_Info, ModuleName, msr)

!-----------------------------
   END SUBROUTINE OutputMZDiag_HE2
!-----------------------------

a1234 1
        !print *, 'write global attributes'
d1338 6
d1440 8
d1474 1
a1474 1
       "$Id: $"
d1483 3
@


1.19
log
@ReprocessingActual field dropped from product metadata
@
text
@d1 10
a10 2
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a46 1
   PRIVATE :: ID, ModuleName
d48 5
a52 5
!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &
   "$Id: L3MZData.f90,v 1.18 2004/12/16 15:00:49 cvuu Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: L3MZData.f90,v $"
!----------------------------------------------------------
d1585 8
d1597 3
@


1.18
log
@v1.5: Change value of ReprocessingActual to unknown in metadata file
@
text
@d43 1
a43 1
   "$Id: L3MZData.f90,v 1.17 2004/12/13 17:41:26 cvuu Exp $"
a1016 8
      attrName = 'ReprocessingActual'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
           & 'unknown')
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

d1582 3
@


1.17
log
@remove writing QA flags to meta file, use the ones in MCF v1.5
@
text
@d43 1
a43 1
   "$Id: L3MZData.f90,v 1.16 2004/05/04 15:57:20 cvuu Exp $"
d1019 1
a1019 1
           & 'processed once')
d1590 3
@


1.16
log
@Fixed bug
@
text
@d43 1
a43 1
   "$Id: L3MZData.f90,v 1.15 2004/01/08 21:21:36 cvuu Exp $"
a1107 34
! QAFlags Group

         attrName = 'AutomaticQualityFlag' // '.' // cNum
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, & 
              & 'Passed')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         attrName = 'AutomaticQualityFlagExplanation' // '.' // cNum
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & 'pending algorithm update')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         attrName = 'OperationalQualityFlag' // '.' // cNum
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & 'Not Investigated')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         attrName = 'OperationalQualityFlagExplanation' // '.' // cNum
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & 'Not Investigated')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

d1590 3
@


1.15
log
@version 1.4 commit
@
text
@d43 1
a43 1
   "$Id: L3MZData.f90,v 1.14 2003/09/16 16:35:21 cvuu Exp $"
d107 1
a107 1
   SUBROUTINE OutputL3MZ (file, mz, createFlag, hdfVersion, prodCount)
d121 1
a121 1
      INTEGER, INTENT(IN) :: hdfVersion, prodCount
d126 1
a126 1
         CALL OutputL3MZ_HE5 (file, mz, createFlag, prodCount)
d363 1
a363 1
   SUBROUTINE OutputL3MZ_HE5 (file, mz, createFlag, prodCount)
d378 1
a378 1
      LOGICAL, INTENT(INOUT) :: createFlag
a379 2
      INTEGER, INTENT(IN) :: prodCount

d397 1
a397 1
      IF (prodCount == 1) THEN
a481 14
! Detach from the zonal interface after definition

      status = he5_zadetach(swID)
      IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
           & 'Failed to detach from zonal interface after L3DZ definition.')

! Re-attach to the zonal for writing

      swID = he5_zaattach(swfID, mz%name)
      IF (swID == -1) THEN
         msr = 'Failed to re-attach to zonal '//TRIM(mz%name)// ' for writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

d573 1
a573 1
      createFlag = .TRUE.
a855 16
! Detach from the zonal interface after definition

      status = he5_zadetach(swID)
      IF (status /= 0) THEN
          msr = SW_ERR // TRIM(dgName) // ' after L3MZ dg definition.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Re-attach to the zonal for writing

      swID = he5_zaattach(swfID, trim(dgName) )
      IF (swID == -1) THEN
         msr = 'Failed to re-attach to zonal '// TRIM(dgName) //' for writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

d1624 3
@


1.14
log
@Add new parameter nFiles to the subroutine WriteMetaL3MZ
@
text
@d25 1
d43 1
a43 1
   "$Id: L3MZData.f90,v 1.13 2003/09/15 18:27:23 cvuu Exp $"
d107 1
a107 1
   SUBROUTINE OutputL3MZ (file, mz, createFlag, hdfVersion)
d121 1
a121 1
      INTEGER, INTENT(IN) :: hdfVersion
d126 1
a126 1
         CALL OutputL3MZ_HE5 (file, mz, createFlag)
d340 1
a340 1
      msr = 'Swath ' // TRIM(mz%name) // ' successfully written to file ' & 
d363 1
a363 1
   SUBROUTINE OutputL3MZ_HE5 (file, mz, createFlag)
d369 2
a370 1
! This subroutine creates and writes to the swaths in an l3mz file.
d379 2
d386 3
a388 3
      INTEGER, EXTERNAL :: he5_swattach, he5_swclose, he5_swcreate, & 
           & he5_swdefdfld, he5_swdefdim, &
           & he5_swdefgfld, he5_swdetach, he5_swopen, he5_swwrfld
d397 7
a403 1
! Open the file for appending a swath
a404 1
      swfID = he5_swopen(trim(file), HE5F_ACC_TRUNC)
d410 1
a410 1
! Create a swath of the appropriate name
d412 1
a412 1
      swID = he5_swcreate(swfID, mz%name)
d414 1
a414 1
         msr = 'Failed to create swath ' // trim(mz%name)
d418 1
a418 1
! Define the swath dimensions
d420 1
a420 1
      status = he5_swdefdim(swID, DIMR_NAME, MIN_MAX)
d426 1
a426 1
      status = he5_swdefdim(swID, DIM_NAME2, mz%nLevels)
d432 1
a432 1
      status = he5_swdefdim(swID, DIML_NAME, mz%nLats)
d438 1
a438 1
! Define the swath geolocation fields using the above dimensions
d440 1
a440 2
      status = he5_swdefgfld(swID, GEO_FIELD3, DIMR_NAME, "",&
           & HE5T_NATIVE_DOUBLE, HDFE_NOMERGE)
d446 1
a446 2
      status = he5_swdefgfld(swID, GEO_FIELD9, DIM_NAME2, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
d452 1
a452 2
      status = he5_swdefgfld(swID, GEO_FIELD1, DIML_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
d458 2
a459 3
      status = he5_swdefgfld(swID, GEO_FIELD4, DIMRL_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status == -1) THEN
d464 1
a464 2
      status = he5_swdefgfld(swID, GEO_FIELD12, DIMRL_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
d470 1
a470 1
! Define the he5_swath data fields using the above dimensions
d472 1
a472 2
      status = he5_swdefdfld(swID, DATA_FIELDV, DIMLL_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
d478 1
a478 2
      status = he5_swdefdfld(swID, DATA_FIELDP, DIMLL_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
d484 1
a484 1
! Detach from the swath interface after definition
d486 1
a486 1
      status = he5_swdetach(swID)
d488 1
a488 1
           & 'Failed to detach from swath interface after L3DZ definition.')
d490 1
a490 1
! Re-attach to the swath for writing
d492 1
a492 1
      swID = he5_swattach(swfID, mz%name)
d494 1
a494 1
         msr = 'Failed to re-attach to swath '//TRIM(mz%name)// ' for writing.'
d507 1
a507 1
      status = he5_swwrfld(swID, GEO_FIELD3, start(1), stride(1), stride(1), &
d514 1
a514 1
      status = he5_swwrfld(swID, GEO_FIELD3, stride(1), stride(1), stride(1), &
d521 1
a521 1
      status = he5_swwrfld( swID, GEO_FIELD9, start(1), stride(1), edge(1), &
d528 1
a528 1
      status = he5_swwrfld( swID, GEO_FIELD1, start(2), stride(2), edge(2), &
d536 1
a536 1
      status = he5_swwrfld( swID, GEO_FIELD4, start, stride, edge, &
d543 1
a543 1
      status = he5_swwrfld( swID, GEO_FIELD12, start, stride, edge, &
d553 1
a553 1
      status = he5_swwrfld( swID, DATA_FIELDV, start, stride, edge, & 
d560 1
a560 1
      status = he5_swwrfld( swID, DATA_FIELDP, start, stride, edge, &
d567 1
a567 1
! After writing, detach from swath interface
d569 1
a569 1
      status = he5_swdetach(swID)
d571 1
a571 1
           & 'Failed to detach from swath interface after writing.')
d573 1
a573 1
      msr = 'Swath ' // TRIM(mz%name) // ' successfully written to file ' & 
d577 1
a577 1
! Create & write the diagnostic swath
d583 1
a583 1
      status = he5_swclose(swfID)
d797 2
a798 2
      INTEGER, EXTERNAL :: he5_swattach, he5_swcreate, he5_swdefdfld, & 
           & he5_swdefdim, he5_swdefgfld, he5_swdetach, he5_swwrfld
d808 1
a808 1
! Create a swath of the appropriate name
d812 1
a812 1
      swID = he5_swcreate(swfID, trim(dgName) )
d814 1
a814 1
         msr = 'Failed to create swath ' // trim(dgName)
d818 1
a818 1
! Define the swath dimensions
d820 1
a820 1
      status = he5_swdefdim(swID, DIMR_NAME, MIN_MAX)
d826 1
a826 1
      status = he5_swdefdim(swID, DIM_NAME2, mz%nLevels)
d832 1
a832 1
      status = he5_swdefdim(swID, DIML_NAME, mz%nLats)
d840 1
a840 2
      status = he5_swdefgfld(swID, GEO_FIELD3, DIMR_NAME, "", & 
           & HE5T_NATIVE_DOUBLE, HDFE_NOMERGE)
d846 11
a856 13
      status = he5_swdefgfld(swID, GEO_FIELD9, DIM_NAME2, "", &
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD9
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_swdefgfld(swID, GEO_FIELD1, DIML_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d858 1
a858 1
! Define the swath data fields using the above dimensions
d860 1
a860 2
      status = he5_swdefdfld(swID, DG_FIELD1, DIMLL_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
d866 1
a866 2
      status = he5_swdefdfld(swID, DG_FIELD2, DIMLL_NAME, "", & 
           & HE5T_NATIVE_INT, HDFE_NOMERGE)
d872 1
a872 1
! Detach from the swath interface after definition
d874 1
a874 1
      status = he5_swdetach(swID)
d880 1
a880 1
! Re-attach to the swath for writing
d882 1
a882 1
      swID = he5_swattach(swfID, trim(dgName) )
d884 1
a884 1
         msr = 'Failed to re-attach to swath '// TRIM(dgName) //' for writing.'
d897 1
a897 1
      status = he5_swwrfld(swID, GEO_FIELD3, start(1), stride(1), stride(1), &
d904 1
a904 1
      status = he5_swwrfld(swID, GEO_FIELD3, stride(1), stride(1), stride(1), &
d911 13
a923 13
      status = he5_swwrfld( swID, GEO_FIELD9, start(1), stride(1), edge(1), &
           & REAL(mz%pressure) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD9
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_swwrfld( swID, GEO_FIELD1, start(2), stride(2), edge(2), &
           & REAL(mz%latitude) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d927 1
a927 1
      status = he5_swwrfld( swID, DG_FIELD1, start, stride, edge, & 
d934 1
a934 1
      status = he5_swwrfld( swID, DG_FIELD2, start, stride, edge, & 
d941 1
a941 1
! After writing, detach from swath interface
d943 1
a943 1
      status = he5_swdetach(swID)
d949 1
a949 1
      msr = 'Swath '// TRIM(dgName) // ' successfully written to file ' // & 
d989 1
a989 1
      & pgs_pc_getUniversalRef
d997 1
a997 1
      CHARACTER (LEN=GridNameLen) :: swathName
d1006 1
a1006 1
      INTEGER :: dg, hdfReturn, i, indx, len, numSwaths, pNum, &
a1010 1
     call output('start WriteL3MZData', advance='yes')
d1013 2
a1014 2
     call output('daysNum = ', advance='no')
     call output(daysNum, advance='yes')
d1083 2
a1084 3
      numSwaths = 0
      numSwaths = mls_inqswath(trim(fileName), list, len, & 
           & hdfVersion=hdfVersion)
d1086 7
a1092 2
      IF (numSwaths .LE. 0) THEN
         msr = 'No swaths found in file ' // TRIM(fileName) // &
d1099 1
a1099 1
! For each swath in the file
d1101 1
a1101 1
      DO i = 1, numSwaths
d1107 1
a1107 1
            swathName = list(:indx-1)
d1110 1
a1110 1
            swathName = list
d1113 2
a1114 1
! If this is a diagnostic swath, skip to the next one
d1116 3
a1118 1
         IF ( INDEX(swathName, 'Diagnostics') /= 0) CYCLE
d1134 1
a1134 1
              & swathName)
d1406 1
a1406 1

d1429 7
a1435 2
        print *, 'write global attributes'
        sdid = he5_gdopen (fileName, HE5F_ACC_RDWR)
d1437 6
a1442 1
        result = he5_gdclose (sdid)
d1656 3
@


1.13
log
@Output OrbitNumber and OrbitPeriod in the global attribute
@
text
@d42 1
a42 1
   "$Id: L3MZData.f90,v 1.12 2003/08/11 23:26:37 cvuu Exp $"
d961 1
a961 1
   SUBROUTINE WriteMetaL3MZ (fileName, mcfNum, pcf, anText, hdfVersion)
d966 1
d984 2
d1011 8
a1018 1
      INTEGER :: l3StartDay, l3EndDay, daysNum
d1211 1
a1211 1
      IF (GlobalAttributes%OrbNumDays(1,i) == -1) THEN
d1216 1
a1216 1
                & attrName, GlobalAttributes%OrbNumDays(1,i))
d1226 1
a1226 1
      IF (maxval(GlobalAttributes%OrbNumDays(:,i)) == -1) then
d1231 1
a1231 1
                & attrName, maxval(GlobalAttributes%OrbNumDays(:,i)))
d1426 1
a1427 5
        write (l3StartDay, '(I5)') pcf%startDay
        write (l3EndDay, '(I5)') pcf%endDay
        daysNum = l3EndDay - l3StartDay + 2
        print *, 'daysNum'
        print *, daysNum
d1643 3
@


1.12
log
@brought closer to James Johnson want to
@
text
@d26 1
d28 2
a29 1
        & PGSD_MET_GROUP_NAME_L, PGSMET_E_MAND_NOT_SET, PGS_S_SUCCESS
d42 1
a42 1
   "$Id: L3MZData.f90,v 1.11 2003/07/08 00:17:46 pwagner Exp $"
d963 4
a966 1
   USE PCFHdr, ONLY: WritePCF2Hdr, WriteInputPointer
d1008 1
d1200 8
a1207 1
      result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 99999)
d1215 8
a1222 1
      result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 99999)
d1414 12
d1637 3
@


1.11
log
@fileType now a lit_name instead of a char string
@
text
@d40 1
a40 1
   "$Id: L3MZData.f90,v 1.10 2003/06/02 23:45:15 pwagner Exp $"
d1182 9
a1190 6
      attrName = 'OrbitNumber' // '.1'
      result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
      IF (result /= PGS_S_SUCCESS) THEN
         msr = METAWR_ERR // attrName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1193 2
a1194 1
      result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
d1201 2
a1202 1
      result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
d1605 3
@


1.10
log
@metadata chnages: OrbitNumber now -1; equatorCrossingDate now utc start date
@
text
@d10 1
d40 1
a40 1
   "$Id: L3MZData.f90,v 1.9 2003/05/30 23:54:07 pwagner Exp $"
d996 2
a997 1
      CHARACTER (LEN=2)  :: fileType
d1012 1
a1012 1
      fileType = 'sw'
d1248 1
a1248 1
        & fileType='hdfeos')
d1600 3
@


1.9
log
@Relies on lib/PCFHdr to WriteInputPointer
@
text
@d39 1
a39 1
   "$Id: L3MZData.f90,v 1.8 2003/04/30 18:16:29 pwagner Exp $"
d1181 1
a1181 1
      result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 999)
d1219 2
a1220 1
           & '1899-04-29')
d1598 3
@


1.8
log
@Work-around for LF95 infinite compile-time bug
@
text
@a0 1

a23 1
   USE PCFHdr, ONLY: WritePCF2Hdr
d39 1
a39 1
   "$Id: L3MZData.f90,v 1.7 2003/04/06 02:25:50 jdone Exp $"
d960 1
a960 1

d1228 14
a1241 14
      inpt = ''
      IF (dg == 1) THEN
         indx = mlspcf_l2dg_start
      ELSE
         indx = mlspcf_l2gp_start
      ENDIF
      DO i = 1, 31
         version = 1
         returnStatus = pgs_pc_getUniversalRef(indx, version, sval)
         IF (returnStatus == PGS_S_SUCCESS) THEN
            inpt(i) = sval
            indx = indx + 1
         ENDIF
      ENDDO
d1243 3
a1245 1
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, inpt)
d1597 3
@


1.7
log
@added HDFEOS5 capability
@
text
@a10 2
   USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC, HE5T_NATIVE_CHAR
d29 2
a30 2
   USE SWAPI
   USE HE5_SWAPI
d33 3
a35 1
   PUBLIC
d41 1
a41 1
   "$Id: L3MZData.f90,v 1.6 2003/03/15 00:20:02 pwagner Exp $"
d363 2
d776 2
d1597 3
@


1.6
log
@May warn if pgs_met_remove returns non-zero value
@
text
@d5 1
a5 1
!===============================================================================
d7 26
a32 1
!===============================================================================
a33 8
   USE Hdf
   USE MLSCommon
   USE MLSL3Common
   USE MLSMessageModule
   USE mon_Open
   USE PCFHdr
   USE PCFModule
   USE SDPToolkit, only: WARNIFCANTPGSMETREMOVE
d41 1
a41 1
   "$Id: L3MZData.f90,v 1.5 2001/12/12 17:46:30 nakamura Exp $"
a67 11
     INTEGER :: nLevels				! Total number of surfaces
     INTEGER :: nLats				! Total number of latitudes

     ! Now we store the geolocation fields.  First, the vertical one:

     REAL(r8), DIMENSION(:), POINTER :: pressure	! dimensioned (nLevels)

     ! Now the horizontal geolocation information and time:

     REAL(r8), DIMENSION(:), POINTER :: latitude	! dimensioned (nLats)

a71 3
     REAL(r8) :: startTime	! start time of L2 data used in the analysis
     REAL(r8) :: endTime 	! end time of L2 data used in the analysis

d74 2
a75 2
     REAL(r8), DIMENSION(:,:), POINTER :: l3mzValue		! Field value
     REAL(r8), DIMENSION(:,:), POINTER :: l3mzPrecision		! Field precision
d83 11
d97 3
d105 28
a132 1
   SUBROUTINE OutputL3MZ (file, mz, createFlag)
d150 2
a151 2
      INTEGER, EXTERNAL :: swattach, swclose, swcreate, swdefdfld, swdefdim
      INTEGER, EXTERNAL :: swdefgfld, swdetach, swopen, swwrfld
d157 1
a158 1
      INTEGER :: start(2), stride(2), edge(2)
d164 1
a164 1
         msr = MLSMSG_Fileopen // file
d172 1
a172 1
         msr = 'Failed to create swath ' // mz%name
d198 2
a199 1
      status = swdefgfld(swID, GEO_FIELD3, DIMR_NAME, DFNT_FLOAT64, HDFE_NOMERGE)
d205 2
a206 1
      status = swdefgfld(swID, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, HDFE_NOMERGE)
d212 2
a213 1
      status = swdefgfld(swID, GEO_FIELD1, DIML_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d219 2
a220 1
      status = swdefgfld(swID, GEO_FIELD4, DIMRL_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d226 2
a227 1
      status = swdefgfld(swID, GEO_FIELD12, DIMRL_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d235 2
a236 1
      status = swdefdfld(swID, DATA_FIELDV, DIMLL_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d242 2
a243 1
      status = swdefdfld(swID, DATA_FIELDP, DIMLL_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d252 2
a253 2
      IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
                              &detach from swath interface after L3DZ definition.')
d259 1
a259 1
         msr = 'Failed to re-attach to swath ' // TRIM(mz%name) // ' for writing.'
d273 1
a273 1
                       mz%startTime)
d280 1
a280 1
                       mz%endTime)
d287 1
a287 1
                        REAL(mz%pressure) )
d294 1
a294 1
                        REAL(mz%latitude) )
d302 1
a302 1
                        REAL(mz%localSolarTime) )
d309 1
a309 1
                        REAL(mz%localSolarZenithAngle) )
d318 2
a319 1
      status = swwrfld( swID, DATA_FIELDV, start, stride, edge, REAL(mz%l3mzValue) )
d326 1
a326 1
                        REAL(mz%l3mzPrecision) )
d335 2
a336 2
      IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
                                 &detach from swath interface after writing.')
d338 2
a339 1
      msr = 'Swath ' // TRIM(mz%name) // ' successfully written to file ' // file
d344 1
a344 1
      CALL OutputMZDiag(file, swfID, mz)
d350 1
a350 1
         msr = 'Failed to close file ' // file // ' after writing.'
d357 231
a587 1
   END SUBROUTINE OutputL3MZ
d591 1
a591 1
   SUBROUTINE OutputMZDiag (file, swfID, mz)
d609 2
a610 2
      INTEGER, EXTERNAL :: swattach, swcreate, swdefdfld, swdefdim, swdefgfld
      INTEGER, EXTERNAL :: swdetach, swwrfld
d617 1
a618 1
      INTEGER :: start(2), stride(2), edge(2)
d626 1
a626 1
         msr = 'Failed to create swath ' // dgName
d652 2
a653 1
      status = swdefgfld(swID, GEO_FIELD3, DIMR_NAME, DFNT_FLOAT64, HDFE_NOMERGE)
d659 2
a660 1
      status = swdefgfld(swID, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, HDFE_NOMERGE)
d666 2
a667 1
      status = swdefgfld(swID, GEO_FIELD1, DIML_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d675 2
a676 1
      status = swdefdfld(swID, DG_FIELD1, DIMLL_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d700 1
a700 1
         msr = 'Failed to re-attach to swath ' // TRIM(dgName) // ' for writing.'
d714 1
a714 1
                       mz%startTime)
d721 1
a721 1
                       mz%endTime)
d728 1
a728 1
                        REAL(mz%pressure) )
d735 1
a735 1
                        REAL(mz%latitude) )
d763 186
a948 1
      msr = 'Swath ' // TRIM(dgName) // ' successfully written to file ' // file
d952 1
a952 1
   END SUBROUTINE OutputMZDiag
d956 1
a956 1
   SUBROUTINE WriteMetaL3MZ (fileName, mcfNum, pcf, anText)
d973 2
d979 3
a981 3
      INTEGER, EXTERNAL :: pgs_met_init, pgs_met_remove, pgs_met_setAttr_d
      INTEGER, EXTERNAL :: pgs_met_setAttr_i,pgs_met_setAttr_s, pgs_met_write
      INTEGER, EXTERNAL :: swinqswath, pgs_pc_getUniversalRef
d985 1
a985 2
      CHARACTER (LEN=3) :: cNum
      CHARACTER (LEN=45) :: attrName, lvid
d987 3
a989 1
      CHARACTER (LEN=6000) :: list
d991 3
a993 3
      CHARACTER (LEN=GridNameLen) :: swathName
      CHARACTER (LEN=98) :: inpt(31)
      CHARACTER (LEN=PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
d995 1
a995 2
      INTEGER :: dg, hdfReturn, i, indx, len, numSwaths, pNum
      INTEGER :: result, returnStatus, sdid, version
d997 2
a998 1
      REAL(r8) :: dval
d1006 4
d1014 1
a1014 1
                           'Initialization error.  See LogStatus for details.')
d1018 4
a1021 3
      sdid = sfstart(fileName, DFACC_WRITE)
      IF (sdid == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
                                       &open the HDF file for metadata writing.')
d1027 1
a1027 1
                           'further update anticipated using enhanced PGE')
d1035 1
a1035 1
                                 'processed once')
d1067 5
a1071 2
      numSwaths = swinqswath(fileName, list, len)
      IF (numSwaths == -1) THEN
d1073 1
a1073 1
               ' while attempting to write its metadata.'
d1110 2
a1111 1
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, swathName)
d1120 2
a1121 1
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, 'Passed')
d1129 1
a1129 1
                                    'pending algorithm update')
d1137 1
a1137 1
                                    'Not Investigated')
d1145 1
a1145 1
                                    'Not Investigated')
d1206 1
a1206 1

d1208 2
a1209 1
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, '00:00:00')
d1214 1
a1214 1

d1216 2
a1217 1
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, '1899-04-29')
d1224 1
a1224 1

d1240 1
a1240 1

d1257 1
a1257 1

d1260 1
a1260 1
                                 'Atmosphere Layer')
d1265 1
a1265 1

d1268 1
a1268 1
                                 'Atmosphere Profile')
d1278 1
a1278 1
                                 'Other Grid System')
d1320 1
a1320 1
                                  pcf%startDay)
d1328 1
a1328 1
                                 '00:00:00.000000')
d1333 1
a1333 1

d1336 1
a1336 1
                                  pcf%endDay )
d1344 1
a1344 1
                                 '23:59:59.999999')
d1354 1
a1354 1
                                 pcf%outputVersion)
d1360 1
a1360 1
! Write the metadata and their values to HDF attributes
d1365 2
a1366 2
            CALL MLSMessage(MLSMSG_Error, ModuleName, 'Some of the mandatory &
                                                &metadata parameters were not set.')
d1368 2
a1369 1
              CALL MLSMessage(MLSMSG_Error, ModuleName, 'Metadata write failed.')
d1375 2
a1376 1
      hdfReturn = sfend(sdid)
d1378 1
a1378 1
                                   'Error closing HDF file after writing metadata.')
d1382 2
a1383 1
      CALL WritePCF2Hdr(fileName, anText)
d1387 4
a1390 4
        write(msr, *) result
        CALL MLSMessage (MLSMSG_Warning, ModuleName, &
              "Calling pgs_met_remove() failed with value " // trim(msr) )
      endif          
d1593 3
@


1.5
log
@Added dg fields; removed unused subroutine DestroyL3MZDatabase.
@
text
@d2 1
a2 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d16 1
a16 1
   USE SDPToolkit
d24 1
a24 1
   "$Id: L3MZData.f90,v 1.4 2001/11/12 20:25:50 nakamura Exp $"
d896 5
d1103 3
@


1.4
log
@Added L3MZDiag_T.
@
text
@d24 1
a24 1
   "$Id: L3MZData.f90,v 1.3 2001/10/04 18:25:04 nakamura Exp $"
d30 1
a30 2
! Definitions -- L3MZData_T
!                L3MZDiag_T
d32 1
a35 1
!                DestroyL3MZDatabase
d75 1
a75 20
   END TYPE L3MZData_T

! This data type is used to store the l3 monthly zonal mean diagnostics.

   TYPE L3MZDiag_T

     CHARACTER (LEN=GridNameLen) :: name        ! name for the output quantity

     INTEGER :: nLevels         ! Total number of surfaces
     INTEGER :: nLats           ! Total number of latitudes

     ! Now we store the geolocation fields.  First, the vertical one:

     REAL(r8), DIMENSION(:), POINTER :: pressure        ! dimensioned (nLevels)

     ! Now the horizontal geolocation information and time:

     REAL(r8), DIMENSION(:), POINTER :: latitude        ! dimensioned (nLats)

     ! Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
d78 1
a78 2

     ! Missing points (percentage), dimensioned (nLevels, nLats)
d81 1
d83 1
a83 1
   END TYPE L3MZDiag_T
d92 1
a92 1
! This subroutine creates and writes to the swaths in an l3dz file.
d289 4
d307 176
d520 2
a521 2
      INTEGER :: dg, hdfReturn, i, indx, len, numSwaths, result, returnStatus, sdid
      INTEGER :: version
d594 2
d610 4
d616 6
a621 4
         IF (i < 10) THEN
            WRITE( cNum, '(I1)' ) i
         ELSE IF ( (i >= 10) .AND. (i < 100) ) THEN
            WRITE( cNum, '(I2)' ) i
d623 1
a623 1
            WRITE( cNum, '(I3)' ) i
d934 1
a934 1
         msr = MLSMSG_Allocate // ' L3MZData_T pressure pointer.'
d942 1
a942 1
         msr = MLSMSG_Allocate // ' L3MZData_T latitude pointer.'
d975 14
d1020 1
a1020 1
            msr = MLSMSG_DeAllocate // '  l3mz pressure pointer.'
d1030 1
a1030 1
            msr = MLSMSG_DeAllocate // '  l3mz latitude pointer.'
d1040 1
a1040 1
            msr = MLSMSG_DeAllocate // '  l3mz local solar time pointer.'
d1048 1
a1048 1
            msr = MLSMSG_DeAllocate // '  l3mz local solar zenith angle pointer.'
d1071 1
a1071 3
!-------------------------------
   END SUBROUTINE DeallocateL3MZ
!-------------------------------
d1073 7
a1079 18
!---------------------------------------
   SUBROUTINE DestroyL3MZDatabase (mzdb)
!---------------------------------------

! Brief description of subroutine
! This subroutine deallocates the internal structures of an l3mz database, and
! then database itself


! Arguments

      TYPE (L3MZData_T), DIMENSION(:), POINTER :: mzdb

! Parameters

! Functions

! Variables
d1081 2
a1082 17
      CHARACTER (LEN=480) :: msr

      INTEGER :: err, i

! Check the status of the input pointer

      IF ( ASSOCIATED(mzdb) ) THEN

! If it's associated, then deallocate the internal structures

         DO i = 1, SIZE(mzdb)
            CALL DeallocateL3MZ( mzdb(i) )
         ENDDO

! Deallocate the database itself

         DEALLOCATE (mzdb, STAT=err)
d1084 2
a1085 2
            msr = MLSMSG_DeAllocate // '  l3mz database'
            CALL MLSMessage ( MLSMSG_Error, ModuleName, msr)
a1086 1

d1089 3
a1091 3
!------------------------------------
   END SUBROUTINE DestroyL3MZDatabase
!------------------------------------
d1098 3
@


1.3
log
@Removed lev as dim for local solar fields.
@
text
@d24 1
a24 1
   "$Id: L3MZData.f90,v 1.2 2001/09/26 19:47:03 nakamura Exp $"
d30 2
a31 1
! Definition -- L3MZData_T
d57 1
a57 1
     REAL(r8), DIMENSION(:), POINTER :: pressure   ! dimensioned (nLevels)
d61 1
a61 1
     REAL(r8), DIMENSION(:), POINTER :: latitude    ! dimensioned (nLats)
d72 2
a73 2
     REAL(r8), DIMENSION(:,:), POINTER :: l3mzValue       ! Field value
     REAL(r8), DIMENSION(:,:), POINTER :: l3mzPrecision   ! Field precision
d78 27
d945 3
@


1.2
log
@Added local solar ancillary fields.
@
text
@d24 1
a24 1
   "$Id: L3MZData.f90,v 1.1 2001/07/20 16:59:02 nakamura Exp nakamura $"
d62 3
a64 3
     REAL(r8), DIMENSION(:,:,:), POINTER :: localSolarTime
     REAL(r8), DIMENSION(:,:,:), POINTER :: localSolarZenithAngle
	! dimensioned as (2,nLevels,nLats)
d106 1
a106 1
      INTEGER :: start(3), stride(3), edge(3)
d164 1
a164 1
      status = swdefgfld(swID, GEO_FIELD4, DIMRLL_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d170 1
a170 1
      status = swdefgfld(swID, GEO_FIELD12, DIMRLL_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d208 2
a209 3
      edge(1) = MIN_MAX
      edge(2) = mz%nLevels
      edge(3) = mz%nLats
d227 1
a227 1
      status = swwrfld( swID, GEO_FIELD9, start(2), stride(2), edge(2), &
d234 1
a234 1
      status = swwrfld( swID, GEO_FIELD1, start(3), stride(3), edge(3), &
d241 1
d258 2
a259 2
      status = swwrfld( swID, DATA_FIELDV, start(2:3), stride(2:3), edge(2:3), &
                        REAL(mz%l3mzValue) )
d265 1
a265 1
      status = swwrfld( swID, DATA_FIELDP, start(2:3), stride(2:3), edge(2:3), &
d752 1
a752 1
      ALLOCATE(l3mz%localSolarTime(MIN_MAX,l3mz%nLevels,l3mz%nLats), STAT=err)
d758 1
a758 1
      ALLOCATE(l3mz%localSolarZenithAngle(MIN_MAX,l3mz%nLevels,l3mz%nLats), &
d917 3
@


1.1
log
@Module for the L3MZ data type.
@
text
@d24 1
a24 1
   "$Id: L3DZData.f90,v 1.3 2001/02/13 15:39:34 nakamura Exp nakamura $"
d62 4
d106 1
a106 1
      INTEGER :: start(2), stride(2), edge(2)
d126 1
a126 1
      status = swdefdim(swID, DIMT_NAME, 2)
d128 1
a128 1
         msr = DIM_ERR // DIMT_NAME
d146 1
a146 1
      status = swdefgfld(swID, GEO_FIELD3, DIMT_NAME, DFNT_FLOAT64, HDFE_NOMERGE)
d164 12
d208 3
a210 2
      edge(1) = mz%nLevels
      edge(2) = mz%nLats
d228 1
a228 1
      status = swwrfld( swID, GEO_FIELD9, start(1), stride(1), edge(1), &
d235 1
a235 1
      status = swwrfld( swID, GEO_FIELD1, start(2), stride(2), edge(2), &
d242 14
d258 2
a259 1
      status = swwrfld( swID, DATA_FIELDV, start, stride, edge, REAL(mz%l3mzValue) )
d265 1
a265 1
      status = swwrfld( swID, DATA_FIELDP, start, stride, edge, &
d750 15
d805 10
d825 9
a833 1
! Vertical geolocation field
d835 2
a836 2
      IF ( ASSOCIATED(l3mz%pressure) ) THEN
         DEALLOCATE (l3mz%pressure, STAT=err)
d838 1
a838 1
            msr = MLSMSG_DeAllocate // '  l3mz pressure pointer.'
d916 4
a919 2
!# $Log: $
!#
@

