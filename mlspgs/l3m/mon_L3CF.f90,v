head	1.5;
access;
symbols
	v5-02-NRT-19:1.5
	v6-00:1.5
	v5-02-NRT-18:1.5
	v5-02:1.5
	v5-01-NRT-17:1.5
	v5-01-NRT-16:1.5
	v5-01-NRT-15:1.5
	v5-01-NRT-14:1.5
	neuralnetworks-1-0:1.5.0.14
	cfm-single-freq-0-1:1.5.0.12
	v5-01:1.5
	v5-00:1.5
	v4-23-TA133:1.5.0.10
	mus-emls-1-70:1.5.0.8
	rel-1-0-englocks-work:1.5.0.6
	VUMLS1-00:1.5
	VPL1-00:1.5
	V4-22-NRT-08:1.5
	VAM1-00:1.5
	V4-21:1.5.0.4
	V4-13:1.5
	V4-12:1.5
	V4-11:1.5
	V4-10:1.5
	V3-43:1.5
	M4-00:1.5
	V3-41:1.5
	V3-40-PlusGM57:1.5.0.2
	V2-24-NRT-04:1.5
	V3-33:1.5
	V2-24:1.5
	V3-31:1.5
	V3-30-NRT-05:1.5
	cfm-01-00:1.5
	V3-30:1.5
	V3-20:1.5
	V3-10:1.5
	V2-23-NRT-02:1.5
	V2-23:1.5
	V2-22-NRT-01:1.5
	V2-22:1.5
	V2-21:1.5
	V2-20:1.5
	V2-11:1.5
	V2-10:1.5
	V2-00:1.5
	V1-51:1.4
	V1-50:1.4
	V1-45:1.4
	V1-44:1.4
	V1-43:1.4
	V1-42:1.4
	V1-41:1.4
	V1-32:1.4
	V1-40:1.4
	V1-31:1.4
	V1-30:1.4
	V1-13:1.2
	V1-12:1.2
	V1-11:1.2
	V1-10:1.2
	newfwm-feb03:1.2.0.2
	V1-04:1.2
	V1-03:1.2
	V1-02:1.2
	V1-00:1.2
	newfwm-sep01:1.1.0.2
	V0-7:1.1;
locks; strict;
comment	@# @;


1.5
date	2005.06.23.19.17.58;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.30.18.16.29;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.06.02.29.02;	author jdone;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.06.18.50.02;	author nakamura;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.18.15.45.08;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Reworded Copyright statement, moved rcs id
@
text
@
! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!==============================================================================
MODULE mon_L3CF
!==============================================================================

  USE MLSCommon, ONLY: FileNameLen, r8
  USE MLSL3Common, ONLY: maxGridPoints, GridNameLen
  IMPLICIT NONE
  private
  PUBLIC :: L3CFMDef_T, L3CFMProd_T, FillL3CFM


!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! Contents:

  ! Definitions -- L3CFMDef_T
  !                L3CFMProd_T
  ! Subroutines -- FillL3CFM

  ! Remarks:  This module defines a data type to hold L3CF input and contains
  !           subroutines used to process these data into forms used by L3.

  ! Parameters

  ! This data type is used to store global definitions from the monthly l3cf.

  TYPE L3CFMDef_T

     CHARACTER (LEN=FileNameLen) :: l2dgType
	! template for the l2 diagnostics input file name

     CHARACTER (LEN=FileNameLen) :: stdType
	! template for the l3dz file for Standard products

     CHARACTER (LEN=FileNameLen) :: dgType
	! template for the l3dz file for Diagnostic products

     CHARACTER (LEN=3) :: intpMethod	! method of interpolation (lin/csp)

     REAL(r8), DIMENSION(maxGridPoints) :: l2nomLats	! dimensioned (nNom)

     INTEGER :: nNom	! number of points in the L2 nominal latitude grid

     INTEGER :: minDays
        ! # of days of input data needed to process an l3 product

     INTEGER :: hdfVersion

   END TYPE L3CFMDef_T

   ! This data type is used to store product-dependent cf input.

   TYPE L3CFMProd_T

      ! Output section

      CHARACTER (LEN=FileNameLen) :: fileTemplate ! file template for prod

      ! Standard section

      CHARACTER (LEN=GridNameLen) :: l3prodName
      ! name of product processed at l3

      CHARACTER (LEN=3) :: mode		! asc/des/com/all/ado

      REAL(r8), DIMENSION(maxGridPoints) :: latGridMap    ! dimensioned (nLats)

      REAL(r8), DIMENSION(maxGridPoints) :: longGrid      ! dimensioned (nLons)

      REAL(r8), DIMENSION(2) :: l3presLvl  !min, max pressure levels, combined

      REAL(r8), DIMENSION(2) :: ascPresLvl !min, max pressure levels,ascending

      REAL(r8), DIMENSION(2) :: desPresLvl !min, max pressure levels,descending

      INTEGER :: nLats 			! number of points in latitude grid

      INTEGER :: nLons			! number of points in longitude grid

   END TYPE L3CFMProd_T

 CONTAINS

!---------------------------------------------------------
   SUBROUTINE FillL3CFM (cf, pcfL3Ver, cfStd, cfDg, cfDef)
!---------------------------------------------------------
  USE MLSFiles, ONLY: HDFVERSION_4, HDFVERSION_5
  USE L3CF, ONLY: CalculateArray
  USE MLSCF, ONLY: Mlscf_T
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_Allocate, &
       & MLSMSG_Warning
  USE MLSStrings, ONLY: LinearSearchStringArray

     ! Brief description of subroutine
     ! This subroutine checks the parser output 
     ! and fills L3CFMProd_T & L3CFMDef_T.

     ! Arguments

     TYPE( Mlscf_T ), INTENT(IN) :: cf

     CHARACTER (LEN=*), INTENT(IN) :: pcfL3Ver

     TYPE( L3CFMDef_T ), INTENT(OUT) :: cfDef

     TYPE( L3CFMProd_T ), POINTER  :: cfDg(:), cfStd(:)

     ! Parameters

     ! Functions

     ! Variables

     CHARACTER (LEN=480) :: msr
     CHARACTER (LEN=10) :: l3Ver, label

     REAL(r8) :: latGrid(maxGridPoints), non(maxGridPoints)
     REAL(r8) :: start, end, delta

     INTEGER :: err, i,iDg, iGlob, iLab, iMap, iOut, indx, nLat, nNon, numProds

! Find the section indices in the CF

     iGlob = LinearSearchStringArray(cf%Sections%MlscfSectionName, &
          & 'GlobalSettings')
     IF (iGlob == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'GLOBALSETTINGS section missing from the CF.')
     iMap = LinearSearchStringArray(cf%Sections%MlscfSectionName, 'Standard')
     IF (iMap == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'STANDARD section missing from the CF.')
     iDg = LinearSearchStringArray(cf%Sections%MlscfSectionName, 'Diagnostic')
     IF (iDg == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'DIAGNOSTIC section missing from the CF.')
     iOut = LinearSearchStringArray(cf%Sections%MlscfSectionName, 'Output')
     IF (iOut == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'OUTPUT section missing from the CF.')

     ! Check that the version number given in the CF will match PCF file names

     indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, &
          & 'OutputVersionString')
     IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
          & 'No entry in the CF for OutputVersionString.')
     l3Ver = cf%Sections(iGlob)%Cells(indx)%CharValue
     IF (l3Ver /= pcfL3Ver) CALL MLSMessage(MLSMSG_Error, ModuleName, &
          & 'Output versions in the CF and PCF differ.')

     ! Check the HDFOutputVersionString. Default is HDFEOS2.

     indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, &
          & 'HDFOutputVersionString')
     IF (indx == 0) THEN 
        CALL MLSMessage(MLSMSG_Warning, ModuleName, &
          & 'No entry in the CF for HDFOutputVersionString.')
        cfDef%hdfVersion = HDFVERSION_4
     ELSE
        IF (cf%Sections(iGlob)%Cells(indx)%CharValue=='hdfeos5') THEN
           cfDef%hdfVersion = HDFVERSION_5
        ELSE
           cfDef%hdfVersion = HDFVERSION_4
        ENDIF
     ENDIF

     ! Find the non-negative values for the L2 nominal latitude grid in the
     ! GlobalSettings section of the cf; add mirror-image negative values and 
     ! save them in L3CFMDef_T

     indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, &
          & 'l2nomLats')
     IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'No entry in the CF for l2nomLats.')

     DO i = 1, maxGridPoints
        non(i) = cf%Sections(iGlob)%Cells(indx)%RealValue
        IF (cf%Sections(iGlob)%Cells(indx)%More == 0) EXIT
        indx = indx + 1
     ENDDO
     nNon = i
     cfDef%nNom = 2*nNon - 1
     cfDef%l2nomLats = 0.0
     cfDef%l2nomLats(nNon:cfDef%nNom) = non(:nNon)

     DO i = 1, nNon-1
        cfDef%l2nomLats(i) = -non( nNon-(i-1) )
     ENDDO

     ! Find/save the l2dg type from the GlobalSettings section of the cf

     indx =LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword,'L2dgType')
     IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'No entry in the CF for L2dgType.')
     cfDef%l2dgType = cf%Sections(iGlob)%Cells(indx)%CharValue

     ! Find/save the l3dz std type

     indx = LinearSearchStringArray( &
          & cf%Sections(iGlob)%Cells%Keyword, 'stdType')
     IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'No entry in the CF for stdType.')
     cfDef%stdType = cf%Sections(iGlob)%Cells(indx)%CharValue

     ! Find/save the l3dz dg type

     indx = LinearSearchStringArray( &
          & cf%Sections(iGlob)%Cells%Keyword, 'dgType')
     IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'No entry in the CF for dgType.')
     cfDef%dgType = cf%Sections(iGlob)%Cells(indx)%CharValue

     ! Find/save minDays from the GlobalSettings section of the cf

     indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword,'MinDays')
     IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
          & 'No entry in the CF for MinDays.')
     cfDef%minDays = cf%Sections(iGlob)%Cells(indx)%RealValue

     ! Find/save the interpolation method

     indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, & 
          & 'intpMethod')
     IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'No entry in the CF for intpMethod.')
     cfDef%intpMethod = cf%Sections(iGlob)%Cells(indx)%CharValue
     
     ! Find the boundaries of the latitude grid

     indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, & 
          & 'latGridMap')
     IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'No entry in the CF for latGridMap.')
     start = cf%Sections(iGlob)%Cells(indx)%RealValue
     end   = cf%Sections(iGlob)%Cells(indx)%RangeUpperBound

     ! Find the increment of the latitude grid

     indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, 'dLat')
     IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
          & 'No entry in the CF for dLat.')
     delta = cf%Sections(iGlob)%Cells(indx)%RealValue

     ! Calculate the array containing the latitude grid

     CALL CalculateArray(start, end, delta, latGrid, nLat)

     ! Find number of standard products for which L3 processing was requested

     numProds = cf%Sections(iMap)%NoSectionEntries

     ALLOCATE (cfStd(numProds), STAT=err)
     IF ( err /= 0 ) THEN
        msr = MLSMSG_Allocate // ' array of L3CFMProd_T pointers.'
        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
     ENDIF

     ! Fill L3CFMProd_T from the Standard & Output sections of the cf

     DO i = 1, numProds

        ! Find/save the product name

        indx = LinearSearchStringArray( &
             & cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'l3prodName')
        IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
             & 'Missing keyword L3PRODNAME in Standard section of the l3cf.')
        cfStd(i)%l3prodName = & 
             & cf%Sections(iMap)%Entries(i)%Cells(indx)%CharValue

        ! Find/save mode

        indx = LinearSearchStringArray( &
             & cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'mode')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Missing keyword MODE in the Standard section of the l3cf.')
         cfStd(i)%mode = cf%Sections(iMap)%Entries(i)%Cells(indx)%CharValue

         ! Save the latitude grid quantities

         cfStd(i)%latGridMap = latGrid
         cfStd(i)%nLats = nLat

         ! Find the boundaries of the longitude grid

         indx = LinearSearchStringArray( &
              & cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'longGrid')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Missing keyword LONGGRID in Standard section of the l3cf.')
         start = cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue
         end   = cf%Sections(iMap)%Entries(i)%Cells(indx)%RangeUpperBound

         ! Find the increment of the longitude grid

         indx = LinearSearchStringArray( &
              & cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'dLon')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Missing keyword DLON in the Standard section of the l3cf.')
         delta = cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue

         ! Calculate the array containing the longitude grid

         CALL CalculateArray(start, end, delta, cfStd(i)%longGrid, & 
              & cfStd(i)%nLons)

         ! Find/save the min & max for the pressure levels

         indx = LinearSearchStringArray( &
              & cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'l3presLvl')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Missing keyword L3PRESLVL in Standard section of the l3cf.')
         cfStd(i)%l3presLvl(1) = & 
              & cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue
         cfStd(i)%l3presLvl(2) = &
              & cf%Sections(iMap)%Entries(i)%Cells(indx)%RangeUpperBound

         indx = LinearSearchStringArray( &
              & cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'ascPresLvl')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Missing keyword ASCPRESLVL in Standard section of the l3cf.')
         cfStd(i)%ascPresLvl(1) = & 
              cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue

         cfStd(i)%ascPresLvl(2) = &
              & cf%Sections(iMap)%Entries(i)%Cells(indx)%RangeUpperBound

         indx = LinearSearchStringArray( &
              & cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'desPresLvl')

         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Missing keyword DESPRESLVL in Standard section of the l3cf.')
         cfStd(i)%desPresLvl(1) = & 
              cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue
         cfStd(i)%desPresLvl(2) = &
              & cf%Sections(iMap)%Entries(i)%Cells(indx)%RangeUpperBound

         ! Find the label in the Standard section

         indx = LinearSearchStringArray( &
              & cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'label')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Missing keyword LABEL in the Standard section of the l3cf.')
         label = cf%Sections(iMap)%Entries(i)%Cells(indx)%CharValue

         ! Match it to one in the Output section

         iLab = LinearSearchStringArray( & 
              cf%Sections(iOut)%Entries%MlscfLabelName, TRIM(label) )
         IF (iLab == 0) THEN
            msr = 'Missing l3cf Output specification for ' // label
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         ! Find the file template from Output; save it in L3CFMProd_T

         indx = LinearSearchStringArray( &
              & cf%Sections(iOut)%Entries(iLab)%Cells%Keyword, 'file')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Missing keyword FILE in the Output section of the l3cf.') 
         cfStd(i)%fileTemplate = &
              & cf%Sections(iOut)%Entries(iLab)%Cells(indx)%CharValue

      ENDDO

      ! Find the number of diagnostic products

      numProds = cf%Sections(iDg)%NoSectionEntries

      ALLOCATE (cfDg(numProds), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' array of L3CFDg_T pointers.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Fill L3CFDg_T from the Diagnostic section of the cf

      DO i = 1, numProds

         ! Set the unused fields to default values

         cfDg(i)%mode = 'com'
         cfDg(i)%latGridMap = latGrid
         cfDg(i)%nLats = nLat

         ! Find/save the product name

         indx = LinearSearchStringArray( &
              & cf%Sections(iDg)%Entries(i)%Cells%Keyword, 'l3prodName')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
              & 'Missing keyword L3PRODNAME in Diagnostic section of l3cf.')
         cfDg(i)%l3prodName = cf%Sections(iDg)%Entries(i)%Cells(indx)%CharValue
         
         ! Find/save the min & max of the pressure levels

         indx = LinearSearchStringArray( &
              & cf%Sections(iDg)%Entries(i)%Cells%Keyword, 'l3presLvl')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
              'Missing keyword L3PRESLVL in Diagnostic section of l3cf.')
         cfDg(i)%l3presLvl(1) = & 
              & cf%Sections(iDg)%Entries(i)%Cells(indx)%RealValue
         cfDg(i)%l3presLvl(2) = & 
              & cf%Sections(iDg)%Entries(i)%Cells(indx)%RangeUpperBound
         cfDg(i)%ascPresLvl = cfDg(i)%l3PresLvl
         cfDg(i)%desPresLvl = cfDg(i)%l3PresLvl

         ! Find the boundaries of the longitude grid

         indx = LinearSearchStringArray( &
              & cf%Sections(iDg)%Entries(i)%Cells%Keyword, 'longGrid')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Missing keyword LONGGRID in Diagnostic section of l3cf.')
         start = cf%Sections(iDg)%Entries(i)%Cells(indx)%RealValue
         end   = cf%Sections(iDg)%Entries(i)%Cells(indx)%RangeUpperBound

         ! Find the increment of the longitude grid

         indx = LinearSearchStringArray( &
              & cf%Sections(iDg)%Entries(i)%Cells%Keyword, 'dLon')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Missing keyword DLON in the Diagnostic section of the l3cf.')
         delta = cf%Sections(iDg)%Entries(i)%Cells(indx)%RealValue

         ! Calculate the array containing the longitude grid

         CALL CalculateArray(start,end, delta, cfDg(i)%longGrid, cfDg(i)%nLons)

      ENDDO

!--------------------------
    END SUBROUTINE FillL3CFM
!--------------------------

!==================
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
  END MODULE mon_L3CF
!==================

! $Log: mon_L3CF.f90,v $
! Revision 1.4  2003/04/30 18:16:29  pwagner
! Work-around for LF95 infinite compile-time bug
!
! Revision 1.3  2003/04/06 02:29:02  jdone
! added HDFVersionString
!
! Revision 1.2  2001/09/06 18:50:02  nakamura
! Modified so that dg products use the same data type as std prods.
!
! Revision 1.1  2001/07/18 15:45:08  nakamura
! Module for customizing the CF parser output to the L3 Monthly program.
!
!
@


1.4
log
@Work-around for LF95 infinite compile-time bug
@
text
@d2 10
a11 2
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a22 1
  PRIVATE :: ID, ModuleName
d24 5
a28 5
  !------------------- RCS Ident Info -----------------------
  CHARACTER(LEN=130) :: Id = &
       "$Id: mon_L3CF.f90,v 1.3 2003/04/06 02:29:02 jdone Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: mon_L3CF.f90,v $"
  !----------------------------------------------------------
d447 8
d459 3
@


1.3
log
@added HDFVersionString
@
text
@a8 2
  USE L3CF, ONLY: CalculateArray
  USE MLSCF, ONLY: Mlscf_T
a9 1
  USE MLSFiles, ONLY: HDFVERSION_4, HDFVERSION_5
a10 3
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_Allocate, &
       & MLSMSG_Warning
  USE MLSStrings, ONLY: LinearSearchStringArray
d12 2
a13 1
  PUBLIC
d19 1
a19 1
       "$Id: mon_L3CF.f90,v 1.2 2001/09/06 18:50:02 nakamura Exp $"
d96 6
d444 3
@


1.2
log
@Modified so that dg products use the same data type as std prods.
@
text
@d5 1
a5 1
!===============================================================================
d7 1
a7 1
!===============================================================================
d9 10
a18 8
   USE L3CF, ONLY: CalculateArray
   USE MLSCF
   USE MLSCommon
   USE MLSL3Common
   USE MLSMessageModule
   USE MLSStrings
   IMPLICIT NONE
   PUBLIC
d20 1
a20 1
   PRIVATE :: ID, ModuleName
d22 5
a26 5
!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &
   "$Id: mon_L3CF.f90,v 1.1 2001/07/18 15:45:08 nakamura Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: mon_L3CF.f90,v $"
!----------------------------------------------------------
d28 1
a28 1
! Contents:
d30 3
a32 3
! Definitions -- L3CFMDef_T
!                L3CFMProd_T
! Subroutines -- FillL3CFM
d34 2
a35 2
! Remarks:  This module defines a data type to hold L3CF input and contains
!           subroutines used to process these data into forms used by L3.
d37 1
a37 1
! Parameters
d39 1
a39 1
! This data type is used to store global definitions from the monthly l3cf.
d41 1
a41 10
   TYPE L3CFMDef_T

     INTEGER :: nNom		! number of points in the L2 nominal latitude grid

     REAL(r8), DIMENSION(maxGridPoints) :: l2nomLats		! dimensioned (nNom)

     INTEGER :: minDays
        ! # of days of input data needed to process an l3 product

     CHARACTER (LEN=3) :: intpMethod		! method of interpolation (lin/csp)
d52 11
d65 1
a65 1
! This data type is used to store product-dependent cf input.
d69 1
a69 1
     ! Standard section
d71 1
a71 2
     CHARACTER (LEN=GridNameLen) :: l3prodName
	! name of product processed at l3
d73 1
a73 1
     CHARACTER (LEN=3) :: mode		! asc/des/com/all/ado
d75 2
a76 1
     INTEGER :: nLats 			! number of points in latitude grid
d78 1
a78 1
     REAL(r8), DIMENSION(maxGridPoints) :: latGridMap      ! dimensioned (nLats)
d80 1
a80 1
     INTEGER :: nLons			! number of points in longitude grid
d82 1
a82 1
     REAL(r8), DIMENSION(maxGridPoints) :: longGrid        ! dimensioned (nLons)
d84 1
a84 1
     REAL(r8), DIMENSION(2) :: l3presLvl      ! min, max pressure levels, combined
d86 1
a86 1
     REAL(r8), DIMENSION(2) :: ascPresLvl     ! min, max pressure levels, ascending
d88 1
a88 1
     REAL(r8), DIMENSION(2) :: desPresLvl     ! min, max pressure levels, descending
d90 1
a90 1
     ! Output section
d92 1
a92 1
     CHARACTER (LEN=FileNameLen) :: fileTemplate	! file template for prod
d96 1
a96 1
CONTAINS
d102 3
a104 2
! Brief description of subroutine
! This subroutine checks the parser output and fills L3CFMProd_T & L3CFMDef_T.
d106 1
a106 1
! Arguments
d108 1
a108 1
      TYPE( Mlscf_T ), INTENT(IN) :: cf
d110 1
a110 1
      CHARACTER (LEN=*), INTENT(IN) :: pcfL3Ver
d112 1
a112 1
      TYPE( L3CFMDef_T ), INTENT(OUT) :: cfDef
d114 1
a114 1
      TYPE( L3CFMProd_T ), POINTER  :: cfDg(:), cfStd(:)
d116 1
a116 1
! Parameters
d118 1
a118 1
! Functions
d120 1
a120 1
! Variables
d122 2
a123 2
      CHARACTER (LEN=10) :: l3Ver, label
      CHARACTER (LEN=480) :: msr
d125 2
a126 1
      INTEGER :: err, i,iDg, iGlob, iLab, iMap, iOut, indx, nLat, nNon, numProds
d128 1
a128 2
      REAL(r8) :: start, end, delta
      REAL(r8) :: latGrid(maxGridPoints), non(maxGridPoints)
d132 130
a261 46
      iGlob = LinearSearchStringArray(cf%Sections%MlscfSectionName, &
                                      'GlobalSettings')
      IF (iGlob == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'GLOBALSETTINGS &
                                                     &section missing from the CF.')
      iMap = LinearSearchStringArray(cf%Sections%MlscfSectionName, 'Standard')
      IF (iMap == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'STANDARD section &
                                                             &missing from the CF.')
      iDg = LinearSearchStringArray(cf%Sections%MlscfSectionName, 'Diagnostic')
      IF (iDg == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'DIAGNOSTIC section &
                                                             &missing from the CF.')
      iOut = LinearSearchStringArray(cf%Sections%MlscfSectionName, 'Output')
      IF (iOut == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'OUTPUT section &
                                                             &missing from the CF.')

! Check that the version number given in the CF will match the PCF file names

      indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, &
                                     'OutputVersionString')
      IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
                                    'No entry in the CF for OutputVersionString.')
      l3Ver = cf%Sections(iGlob)%Cells(indx)%CharValue
      IF (l3Ver /= pcfL3Ver) CALL MLSMessage(MLSMSG_Error, ModuleName, &
                                      'Output versions in the CF and PCF differ.')

! Find the non-negative values for the L2 nominal latitude grid in the
! GlobalSettings section of the cf; add mirror-image negative values and save them
! in L3CFMDef_T

      indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, &
                                     'l2nomLats')
      IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'No entry in &
                                     &the CF for l2nomLats.')

      DO i = 1, maxGridPoints
         non(i) = cf%Sections(iGlob)%Cells(indx)%RealValue
         IF (cf%Sections(iGlob)%Cells(indx)%More == 0) EXIT
         indx = indx + 1
      ENDDO
      nNon = i
      cfDef%nNom = 2*nNon - 1
      cfDef%l2nomLats = 0.0
      cfDef%l2nomLats(nNon:cfDef%nNom) = non(:nNon)

      DO i = 1, nNon-1
         cfDef%l2nomLats(i) = -non( nNon-(i-1) )
      ENDDO
d263 1
a263 1
! Find/save the l2dg type from the GlobalSettings section of the cf
d265 1
a265 4
      indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword,'L2dgType')
      IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'No entry in &
                                    &the CF for L2dgType.')
      cfDef%l2dgType = cf%Sections(iGlob)%Cells(indx)%CharValue
d267 1
a267 1
! Find/save the l3dz std type
d269 6
a274 5
      indx = LinearSearchStringArray( &
                              cf%Sections(iGlob)%Cells%Keyword, 'stdType')
      IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'No entry in the CF &
                            &for stdType.')
      cfDef%stdType = cf%Sections(iGlob)%Cells(indx)%CharValue
d276 1
a276 1
! Find/save the l3dz dg type
d278 2
a279 65
      indx = LinearSearchStringArray( &
                              cf%Sections(iGlob)%Cells%Keyword, 'dgType')
      IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'No entry in the CF &
                            &for dgType.')
      cfDef%dgType = cf%Sections(iGlob)%Cells(indx)%CharValue

! Find/save minDays from the GlobalSettings section of the cf

      indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword,'MinDays')
      IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
                                    'No entry in the CF for MinDays.')
      cfDef%minDays = cf%Sections(iGlob)%Cells(indx)%RealValue

! Find/save the interpolation method

      indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, 'intpMethod')
      IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'No entry in the CF &
                                     &for intpMethod.')
      cfDef%intpMethod = cf%Sections(iGlob)%Cells(indx)%CharValue

! Find the boundaries of the latitude grid

      indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, 'latGridMap')
      IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'No entry in the CF &
                     &for latGridMap.')
      start = cf%Sections(iGlob)%Cells(indx)%RealValue
      end = cf%Sections(iGlob)%Cells(indx)%RangeUpperBound

! Find the increment of the latitude grid

      indx = LinearSearchStringArray(cf%Sections(iGlob)%Cells%Keyword, 'dLat')
      IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'No entry in the CF &
                                     &for dLat.')
      delta = cf%Sections(iGlob)%Cells(indx)%RealValue

! Calculate the array containing the latitude grid

      CALL CalculateArray(start, end, delta, latGrid, nLat)

! Find the number of standard products for which L3 processing was requested

      numProds = cf%Sections(iMap)%NoSectionEntries

      ALLOCATE (cfStd(numProds), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' array of L3CFMProd_T pointers.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Fill L3CFMProd_T from the Standard & Output sections of the cf

      DO i = 1, numProds

! Find/save the product name

         indx = LinearSearchStringArray( &
                           cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'l3prodName')
         IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
             'Missing keyword L3PRODNAME in the Standard section of the l3cf.')
         cfStd(i)%l3prodName = cf%Sections(iMap)%Entries(i)%Cells(indx)%CharValue

! Find/save mode

         indx = LinearSearchStringArray( &
                                 cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'mode')
d281 1
a281 1
                    'Missing keyword MODE in the Standard section of the l3cf.')
d284 1
a284 1
! Save the latitude grid quantities
d289 1
a289 1
! Find the boundaries of the longitude grid
d292 1
a292 1
                             cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'longGrid')
d294 1
a294 1
                'Missing keyword LONGGRID in the Standard section of the l3cf.')
d296 1
a296 1
         end = cf%Sections(iMap)%Entries(i)%Cells(indx)%RangeUpperBound
d298 1
a298 1
! Find the increment of the longitude grid
d301 1
a301 1
                                 cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'dLon')
d303 1
a303 1
                    'Missing keyword DLON in the Standard section of the l3cf.')
d306 1
a306 1
! Calculate the array containing the longitude grid
d308 2
a309 1
         CALL CalculateArray(start, end, delta, cfStd(i)%longGrid, cfStd(i)%nLons)
d311 1
a311 1
! Find/save the min & max for the pressure levels
d314 1
a314 1
                            cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'l3presLvl')
d316 3
a318 2
                  'Missing keyword L3PRESLVL in the Standard section of the l3cf.')
         cfStd(i)%l3presLvl(1) = cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue
d320 1
a320 1
                            cf%Sections(iMap)%Entries(i)%Cells(indx)%RangeUpperBound
d323 1
a323 1
                           cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'ascPresLvl')
d325 4
a328 2
              'Missing keyword ASCPRESLVL in the Standard section of the l3cf.')
         cfStd(i)%ascPresLvl(1) = cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue
d330 1
a330 1
                            cf%Sections(iMap)%Entries(i)%Cells(indx)%RangeUpperBound
d333 2
a334 1
                           cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'desPresLvl')
d336 3
a338 2
                  'Missing keyword DESPRESLVL in the Standard section of the l3cf.')
         cfStd(i)%desPresLvl(1) = cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue
d340 1
a340 1
                            cf%Sections(iMap)%Entries(i)%Cells(indx)%RangeUpperBound
d342 1
a342 1
! Find the label in the Standard section
d345 1
a345 1
                             cf%Sections(iMap)%Entries(i)%Cells%Keyword, 'label')
d347 1
a347 1
                   'Missing keyword LABEL in the Standard section of the l3cf.')
d350 1
a350 1
! Match it to one in the Output section
d352 2
a353 2
         iLab = LinearSearchStringArray( cf%Sections(iOut)%Entries%MlscfLabelName, &
                                         TRIM(label) )
d359 1
a359 1
! Find the file template from Output; save it in L3CFMProd_T
d362 1
a362 1
                         cf%Sections(iOut)%Entries(iLab)%Cells%Keyword, 'file')
d364 1
a364 1
                    'Missing keyword FILE in the Output section of the l3cf.') 
d366 1
a366 1
                               cf%Sections(iOut)%Entries(iLab)%Cells(indx)%CharValue
d370 1
a370 1
! Find the number of diagnostic products
d380 1
a380 1
! Fill L3CFDg_T from the Diagnostic section of the cf
d384 1
a384 1
! Set the unused fields to default values
d390 1
a390 1
! Find/save the product name
d392 7
a398 5
        indx = LinearSearchStringArray( &
                            cf%Sections(iDg)%Entries(i)%Cells%Keyword, 'l3prodName')
        IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Missing &
                        &keyword L3PRODNAME in the Diagnostic section of the l3cf.')
        cfDg(i)%l3prodName = cf%Sections(iDg)%Entries(i)%Cells(indx)%CharValue
d400 10
a409 1
! Find/save the min & max of the pressure levels
d411 1
a411 8
        indx = LinearSearchStringArray( &
                            cf%Sections(iDg)%Entries(i)%Cells%Keyword, 'l3presLvl')
        IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Missing &
                        &keyword L3PRESLVL in the Diagnostic section of the l3cf.')
        cfDg(i)%l3presLvl(1) = cf%Sections(iDg)%Entries(i)%Cells(indx)%RealValue
        cfDg(i)%l3presLvl(2) = cf%Sections(iDg)%Entries(i)%Cells(indx)%RangeUpperBound
        cfDg(i)%ascPresLvl = cfDg(i)%l3PresLvl
        cfDg(i)%desPresLvl = cfDg(i)%l3PresLvl
d413 6
a418 1
! Find the boundaries of the longitude grid
d420 1
a420 6
        indx = LinearSearchStringArray( &
                            cf%Sections(iDg)%Entries(i)%Cells%Keyword, 'longGrid')
        IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
                 'Missing keyword LONGGRID in the Diagnostic section of the l3cf.')
        start = cf%Sections(iDg)%Entries(i)%Cells(indx)%RealValue
        end = cf%Sections(iDg)%Entries(i)%Cells(indx)%RangeUpperBound
d422 5
a426 7
! Find the increment of the longitude grid

        indx = LinearSearchStringArray( &
                                  cf%Sections(iDg)%Entries(i)%Cells%Keyword, 'dLon')
        IF (indx == 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
                      'Missing keyword DLON in the Diagnostic section of the l3cf.')
        delta = cf%Sections(iDg)%Entries(i)%Cells(indx)%RealValue
d428 1
a428 1
! Calculate the array containing the longitude grid
d430 1
a430 1
        CALL CalculateArray(start, end, delta, cfDg(i)%longGrid, cfDg(i)%nLons)
d435 1
a435 1
   END SUBROUTINE FillL3CFM
d439 1
a439 1
END MODULE mon_L3CF
d443 3
@


1.1
log
@Module for customizing the CF parser output to the L3 Monthly program.
@
text
@d22 1
a22 1
   "$Id: mon_L3CF.f90,v 1.2 2001/06/26 18:15:51 nakamura Exp nakamura $"
a29 1
!                L3CFDg_T
a91 16
! This data type stores information related to diagnostic product processing.

   TYPE L3CFDg_T

     CHARACTER (LEN=GridNameLen) :: prodName		! diagnostic product name

     REAL(r8):: minPresLvl				! min pressure level

     REAL(r8):: maxPresLvl				! max pressure level

     INTEGER :: nLon			! number of points in longitude grid

     REAL(r8), DIMENSION(maxGridPoints) :: lonGrid	! dimensioned (nLons)

   END TYPE L3CFDg_T

d94 3
a96 3
!--------------------------------------------------------
   SUBROUTINE FillL3CFM (cf, pcfL3Ver, l3cf, cfDef, cfDg)
!--------------------------------------------------------
d109 1
a109 3
      TYPE( L3CFDg_T ), POINTER :: cfDg(:)

      TYPE( L3CFMProd_T ), POINTER  :: l3cf(:)
d167 1
d234 1
a234 1
      ALLOCATE (l3cf(numProds), STAT=err)
d250 1
a250 1
         l3cf(i)%l3prodName = cf%Sections(iMap)%Entries(i)%Cells(indx)%CharValue
d258 1
a258 1
         l3cf(i)%mode = cf%Sections(iMap)%Entries(i)%Cells(indx)%CharValue
d262 2
a263 2
         l3cf(i)%latGridMap = latGrid
         l3cf(i)%nLats = nLat
d284 1
a284 1
         CALL CalculateArray(start, end, delta, l3cf(i)%longGrid, l3cf(i)%nLons)
d292 2
a293 2
         l3cf(i)%l3presLvl(1) = cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue
         l3cf(i)%l3presLvl(2) = &
d300 2
a301 2
         l3cf(i)%ascPresLvl(1) = cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue
         l3cf(i)%ascPresLvl(2) = &
d308 2
a309 2
         l3cf(i)%desPresLvl(1) = cf%Sections(iMap)%Entries(i)%Cells(indx)%RealValue
         l3cf(i)%desPresLvl(2) = &
d335 1
a335 1
         l3cf(i)%fileTemplate = &
d354 6
d366 1
a366 1
        cfDg(i)%prodName = cf%Sections(iDg)%Entries(i)%Cells(indx)%CharValue
d374 4
a377 2
        cfDg(i)%minPresLvl = cf%Sections(iDg)%Entries(i)%Cells(indx)%RealValue
        cfDg(i)%maxPresLvl = cf%Sections(iDg)%Entries(i)%Cells(indx)%RangeUpperBound
d398 1
a398 1
        CALL CalculateArray(start, end, delta, cfDg(i)%lonGrid, cfDg(i)%nLon)
d410 4
a413 1
! $Log: $
@

