head	1.19;
access;
symbols
	v5-02-NRT-19:1.19
	v6-00:1.19
	v5-02-NRT-18:1.19
	v5-02:1.19
	v5-01-NRT-17:1.19
	v5-01-NRT-16:1.19
	v5-01-NRT-15:1.19
	v5-01-NRT-14:1.19
	neuralnetworks-1-0:1.19.0.14
	cfm-single-freq-0-1:1.19.0.12
	v5-01:1.19
	v5-00:1.19
	v4-23-TA133:1.19.0.10
	mus-emls-1-70:1.19.0.8
	rel-1-0-englocks-work:1.19.0.6
	VUMLS1-00:1.19
	VPL1-00:1.19
	V4-22-NRT-08:1.19
	VAM1-00:1.19
	V4-21:1.19.0.4
	V4-13:1.19
	V4-12:1.19
	V4-11:1.19
	V4-10:1.19
	V3-43:1.19
	M4-00:1.19
	V3-41:1.19
	V3-40-PlusGM57:1.19.0.2
	V2-24-NRT-04:1.19
	V3-33:1.19
	V2-24:1.19
	V3-31:1.19
	V3-30-NRT-05:1.19
	cfm-01-00:1.19
	V3-30:1.19
	V3-20:1.19
	V3-10:1.19
	V2-23-NRT-02:1.19
	V2-23:1.19
	V2-22-NRT-01:1.19
	V2-22:1.19
	V2-21:1.19
	V2-20:1.19
	V2-11:1.19
	V2-10:1.19
	V2-00:1.19
	V1-51:1.17
	V1-50:1.17
	V1-45:1.17
	V1-44:1.17
	V1-43:1.17
	V1-42:1.15
	V1-41:1.15
	V1-32:1.14
	V1-40:1.15
	V1-31:1.14
	V1-30:1.13
	V1-13:1.12
	V1-12:1.12
	V1-11:1.12
	V1-10:1.12
	newfwm-feb03:1.12.0.2
	V1-04:1.11
	V1-03:1.11
	V1-02:1.11
	V1-00:1.11
	newfwm-sep01:1.5.0.2
	V0-7:1.5;
locks; strict;
comment	@# @;


1.19
date	2006.02.28.20.39.04;	author cvuu;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.23.19.17.58;	author pwagner;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.12.21.49.58;	author pwagner;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.04.15.55.00;	author cvuu;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.08.21.21.37;	author cvuu;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.29.00.07.17;	author pwagner;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.06.02.25.59;	author jdone;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.22.23.33.05;	author pwagner;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.03.21.42.01;	author pwagner;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.28.21.54.02;	author ybj;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.27.23.27.14;	author ybj;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.12.17.48.03;	author nakamura;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.26.19.48.28;	author nakamura;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.06.18.48.39;	author nakamura;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.08.19.27.47;	author nakamura;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.02.23.35.52;	author ybj;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.01.18.28.56;	author nakamura;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.20.19.30.29;	author nakamura;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.18.15.42.48;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.19
log
@V2.00 commit
@
text
@
! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!==============================================
PROGRAM MLSL3M ! MLS Level 3 Monthly subprogram
!==============================================

  USE Allocate_Deallocate, ONLY: DEALLOCATE_TEST
  USE L2GPData, ONLY: L2GPData_T, DestroyL2GPDatabase
  USE L2Interface, ONLY: GetL2GPfromPCF, ReadL2DGData, ReadL2GPProd
  USE L3DZData, ONLY: L3DZData_T
  USE L3MMData, ONLY: L3MMData_T
  USE L3MZData, ONLY: L3MZData_T
  USE MLSCF, ONLY: Mlscf_T
  USE MLSL3Common, ONLY: OutputFiles_T, maxWindow, DATE_LEN, FILENAMELEN
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_Warning, &
       & MLSMSG_Info, MLSMessageExit
  USE MLSPCF3
  USE mon_L3CF, ONLY: L3CFMDef_T, L3CFMProd_T
  USE mon_Open, ONLY: PCFMData_T, OpenMON
  USE mon_Out, ONLY: CreateFlags_T, OutputDg, OutputStd, OutputMON
  USE MonthlyProcessModule, ONLY: MonthlyCoreProcessing
  USE PCFHdr, ONLY: GlobalAttributes
!  USE H5LIB, ONLY: h5open_f, h5close_f
  use MLSHDF5, only: mls_h5open, mls_h5close
  IMPLICIT NONE


!---------------------------- RCS Ident Info ------------------------------
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: MLSL3M.f90,v $"
  character (len=*), parameter :: IdParm = &
       "$Id: MLSL3M.f90,v 1.18 2005/06/23 19:17:58 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
!---------------------------------------------------------------------------

  ! Brief description of program
  ! This is the MLS Level 3 Monthly subprogram.

  ! Parameters

  ! Functions

  ! Variables

  TYPE( CreateFlags_T ) :: flag
  TYPE( L3CFMDef_T )    :: cfDef
  TYPE( L3MMData_T )    :: mm, mmA, mmD
  TYPE( L3MZData_T )    :: mzA, mzD
  TYPE( Mlscf_T )       :: cf
  TYPE( PCFMData_T )    :: pcf
  TYPE( L2GPData_T ),  POINTER :: l2gp(:)
  TYPE( L3CFMProd_T ), POINTER :: cfStd(:), cfDg(:)
  TYPE( L3DZData_T ),  POINTER :: dzA(:), dzD(:)
  TYPE( OutputFiles_T ) :: dFiles, sFiles

  CHARACTER (LEN=480) :: msr
  CHARACTER (LEN=FileNameLen) :: pcfNames(maxWindow)
  CHARACTER (LEN=1), POINTER  :: anText(:)

  INTEGER :: i, l2Days, numFiles, mis_l2Days, error, hdfVersion
  INTEGER, PARAMETER :: NORMAL_EXIT_STATUS = 2
  INTEGER :: mis_Days(maxWindow)

  ! Initializations
  call mls_h5open(error)
  if (error /= 0) then
     call MLSMessage ( MLSMSG_Error, moduleName, "Unable to h5_open_f" )
  endif

  sFiles%nFiles = 0
  dFiles%nFiles = 0
  sFiles%name   = ''
  dFiles%name   = ''
  sFiles%date   = ''
  dFiles%date   = ''

  flag%createMS = .FALSE.
  flag%createMD = .FALSE.
  flag%createZS = .FALSE.
  flag%createZD = .FALSE.

  CALL MLSMessage (MLSMSG_Info, ModuleName, &
       & 'EOS MLS Level 3 Monthly data processing started')

  ! Fill structures with input data from the PCF and L3CF.

  CALL OpenMON(pcf, cf, cfStd, cfDg, cfDef, anText)
  hdfVersion = cfDef%hdfVersion

  ! For each Standard product requested in the cf,

  DO i = 1, SIZE(cfStd)

     ! Read all available data in the input window

     CALL ReadL2GPProd(cfStd(i)%l3prodName, cfStd(i)%fileTemplate, &
          & pcf%startDay, pcf%endDay, l2Days, mis_l2Days, mis_Days, l2gp)

     ! If no data found, go on to the next product

     IF (l2Days < 1) THEN
        msr = 'No data found for ' // TRIM(cfStd(i)%l3prodName) // &
             &'.Skipping Monthly processing and moving on to the next product.'
        CALL MLSMessage (MLSMSG_Warning, ModuleName, msr)
        CYCLE
     ELSE
        msr = 'Input data successfully read; begin processing data for ' // &
             & trim(cfStd(i)%l3prodName)
        CALL MLSMessage (MLSMSG_Info, ModuleName, msr)
     ENDIF
     
     ! Core processing for Standard products
     
     CALL MonthlyCoreProcessing(cfStd(i), pcf, cfDef, l2Days, l2gp, mm, mmA, & 
          & mmD, mzA, mzD, dzA, dzD, mis_Days, mis_l2Days)

     msr = 'CORE processing completed for ' // TRIM(cfStd(i)%l3prodName) &
          & // '; starting Output task ...'
     CALL MLSMessage (MLSMSG_Info, ModuleName, msr)

     ! Deallocate the L2GP database

     CALL DestroyL2GPDatabase(l2gp)

     ! Output and Close for the product

     CALL OutputStd(pcf, cfDef%stdType, cfStd(i)%mode, dzA, dzD, mzA, mzD, &
          & mm, mmA, mmD, sFiles, flag, hdfVersion)

  ENDDO

  ! Begin Diagnostic processing

  msr = 'Standard product loop completed; beginning Diagnostic product loop .'
  CALL MLSMessage (MLSMSG_Info, ModuleName, msr)

  ! Get the names of any L2GP Diagnostics files from the PCF
  CALL GetL2GPfromPCF(mlspcf_l2dg_start, mlspcf_l2dg_end, cfDef%l2dgType, &
       & pcf%startDay, pcf%EndDay, numFiles, pcfNames, mis_l2Days, mis_Days)

  ! If no files are found, skip to Output/Close

  IF (numFiles < 1) THEN

     CALL MLSMessage (MLSMSG_Warning, ModuleName, & 
          & 'No L2GP Diagnostics files found in the PCF' // & 
          & 'for the given day range.')

  ELSE
      
     ! For each product in the Diagnostic section of the cf,

     DO i = 1, SIZE(cfDg)
        
        ! Read all the l2gp data which exist in input window for that product

        CALL ReadL2DGData(cfDg(i)%l3prodName, numFiles, pcfNames, l2Days, l2gp)

        ! If insufficient data found, go on to the next product

        IF (l2Days < 1) THEN
           msr = 'No data found for ' // TRIM(cfDg(i)%l3prodName) &
                & // '.  Skipping CORE processing and moving on' //  & 
                & 'to the next product.'
           CALL MLSMessage (MLSMSG_Warning, ModuleName, msr)
           CYCLE
        ELSE
           msr = 'Input data successfully read for ' //  &
                & TRIM(cfDg(i)%l3prodName) // '; CORE processing started ..'
           CALL MLSMessage (MLSMSG_Info, ModuleName, msr)
        ENDIF

        ! Monthly Core processing

        CALL MonthlyCoreProcessing(cfDg(i), pcf, cfDef, l2Days, l2gp, &
             & mm, mmA, mmD, mzA, mzD, dzA, dzD, mis_Days, mis_l2Days)

        msr = 'CORE processing completed for ' // TRIM(cfDg(i)%l3prodName) &
             & // '; starting Output task ...'
        CALL MLSMessage (MLSMSG_Info, ModuleName, msr)

        ! Deallocate the L2GP database
         
        CALL DestroyL2GPDatabase(l2gp)

        ! Output and Close for the product

        CALL OutputDg(pcf, cfDef%dgType, dzA, dzD, mzA, mzD, mm, mmA, mmD, &
             & dFiles, flag, hdfVersion)

     ENDDO

  ENDIF

  ! Perform final Output & Close tasks outside of the product processing loop.

  CALL MLSMessage (MLSMSG_Info, ModuleName, &
       & 'Product processing completed; beginning Output/Close task ... ')
 
  CALL OutputMON(sFiles, dFiles, flag, pcf, cfStd, cfDg, cf, anText, &
	& hdfVersion)

  ! deallocate memory
  CALL Deallocate_test(GlobalAttributes%OrbNumDays, &
       & 'GlobalAttributes%OrbNumDays', ModuleName)
  CALL Deallocate_test(GlobalAttributes%OrbPeriodDays, &
       & 'GlobalAttributes%OrbPeriodDays', ModuleName)

  CALL MLSMessage (MLSMSG_Info, ModuleName, &
       & 'EOS MLS Level 3 Monthly data processing successfully completed!')
  call mls_h5close(error)                            
  if (error /= 0) then                             
     call MLSMessage ( MLSMSG_Error, moduleName, "Unable to h5_close_f" )
  endif
  call MLSMessageExit(NORMAL_EXIT_STATUS)

!=================
END PROGRAM MLSL3M
!=================

! $Log: MLSL3M.f90,v $
! Revision 1.18  2005/06/23 19:17:58  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.17  2004/05/12 21:49:58  pwagner
! Uses mls_h5open/close
!
! Revision 1.16  2004/05/04 15:55:00  cvuu
! Use int array instead of charstring for mis_days, move globalattributes%processLevel to mon_Open.f90
!
! Revision 1.15  2004/01/08 21:21:37  cvuu
! version 1.4 commit
!
! Revision 1.14  2003/10/29 00:07:17  pwagner
! GlobalAttributes%ProcessLevel assigned appropriate value
!
! Revision 1.13  2003/04/06 02:25:59  jdone
! added HDFEOS5 capability
!
! Revision 1.12  2002/08/22 23:33:05  pwagner
! Made ready for hdf5
!
! Revision 1.11  2002/04/03 21:42:01  pwagner
! Sets status on normal exit to 2
!
! Revision 1.10  2002/03/28 21:54:02  ybj
! MLSL3M.f90
!
! Revision 1.9  2002/03/27 23:27:14  ybj
! MonthlyProcessModule.f90
!
! Revision 1.8  2001/12/12 17:48:03  nakamura
! Removed unused dz & mz arguments.
!
! Revision 1.7  2001/09/26 19:48:28  nakamura
! Removed com ZM output; added cfDg deallocate.
!
! Revision 1.6  2001/09/06 18:48:39  nakamura
! Modified so that dg products are processed with the same Core as std prods.
!
! Revision 1.5  2001/08/08 19:27:47  nakamura
! Added cfDef to MonthlyCoreProcessing args; added comments delineating CORE from I/O.
!
! Revision 1.4  2001/08/02 23:35:52  ybj
! Fix interface call to MonthlyCoreProcessing
!
! Revision 1.3  2001/08/01 18:28:56  nakamura
! I/O-Core interface switched back to Daily paradigm.
!
! Revision 1.2  2001/07/20 19:30:29  nakamura
! Commented out sample CALLs to Core routines.
!
! Revision 1.1  2001/07/18 15:42:48  nakamura
! MLS Level 3 Monthly program.
!
@


1.18
log
@Reworded Copyright statement, moved rcs id
@
text
@d40 1
a40 1
       "$RCSfile: MLSL2.f90,v $"
d42 1
a42 1
       "$Id: MLSL2.f90,v 2.138 2005/06/22 18:57:02 pwagner Exp $"
a226 3
   ! Detailed description of program
   ! The program is a prototype for the MLS Level 3 Monthly subprogram.

d232 3
@


1.17
log
@Uses mls_h5open/close
@
text
@d2 10
a11 2
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d38 7
a44 5
  !------------------- RCS Ident Info -----------------------
  CHARACTER(LEN=130) :: Id = &                                                 
       "$Id: MLSL3M.f90,v 1.16 2004/05/04 15:55:00 cvuu Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: MLSL3M.f90,v $"
  !----------------------------------------------------------
d235 3
@


1.16
log
@Use int array instead of charstring for mis_days, move globalattributes%processLevel to mon_Open.f90
@
text
@d25 2
a26 1
  USE H5LIB, ONLY: h5open_f, h5close_f
d32 1
a32 1
       "$Id: MLSL3M.f90,v 1.15 2004/01/08 21:21:37 cvuu Exp $"
d65 1
a65 1
  call h5open_f(error)
d211 1
a211 1
  call h5close_f(error)                            
d225 3
@


1.15
log
@version 1.4 commit
@
text
@d25 1
a25 1
!  USE H5LIB, ONLY: h5open_f, h5close_f
d31 1
a31 1
       "$Id: MLSL3M.f90,v 1.14 2003/10/29 00:07:17 pwagner Exp $"
a56 1
  CHARACTER (LEN=DATE_LEN)    :: mis_Days(maxWindow)
d61 1
a83 1
   GlobalAttributes%ProcessLevel = '3-monthly'
d92 1
a92 1
     
d114 1
a114 1
          & mmD, mzA, mzD, dzA, dzD, mis_Days)
d127 1
a127 1
          & mm, mmA, mmD, sFiles, flag, hdfVersion, i)
d175 1
a175 1
             & mm, mmA, mmD, mzA, mzD, dzA, dzD, mis_Days)
d188 1
a188 1
             & dFiles, flag, hdfVersion, i)
a207 1

d224 3
@


1.14
log
@GlobalAttributes%ProcessLevel assigned appropriate value
@
text
@d9 1
d25 2
a27 1
  IMPLICIT NONE
d31 1
a31 1
       "$Id: MLSL3M.f90,v 1.13 2003/04/06 02:25:59 jdone Exp $"
a92 1
     print *, i,  SIZE(cfStd)
d128 1
a128 1
          & mm, mmA, mmD, sFiles, flag, hdfVersion)
a137 1

a153 1
	print *, 'Diagnostic=', i,  SIZE(cfDg)
d189 1
a189 1
             & dFiles, flag, hdfVersion)
d199 10
a208 2
  
  CALL OutputMON(sFiles, dFiles, flag, pcf, cfStd, cfDg, cf, anText,hdfVersion)
d226 3
@


1.13
log
@added HDFEOS5 capability
@
text
@d23 1
d29 1
a29 1
       "$Id: MLSL3M.f90,v 1.12 2002/08/22 23:33:05 pwagner Exp $"
d82 1
d219 3
@


1.12
log
@Made ready for hdf5
@
text
@d9 141
a149 14
   USE L2GPData, ONLY: L2GPData_T, DestroyL2GPDatabase
   USE L2Interface
   USE L3DZData
   USE L3MMData
   USE L3MZData
   USE MLSCF
   USE MLSCommon
   USE MLSL3Common
   USE MLSMessageModule
   USE MLSPCF3
   USE mon_L3CF
   USE mon_Open
   USE mon_Out
   USE MonthlyProcessModule
d151 1
a151 128
   IMPLICIT NONE

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &                                                    
   "$Id: MLSL3M.f90,v 1.11 2002/04/03 21:42:01 pwagner Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: MLSL3M.f90,v $"
!----------------------------------------------------------

! Brief description of program
! This is the MLS Level 3 Monthly subprogram.

! Parameters

! Functions

! Variables

   TYPE( CreateFlags_T ) :: flag
   TYPE( L3CFMDef_T ) :: cfDef
   TYPE( L3MMData_T ) :: mm, mmA, mmD
   TYPE( L3MZData_T ) :: mzA, mzD
   TYPE( Mlscf_T ) :: cf
   TYPE( PCFMData_T ) :: pcf
   TYPE( L2GPData_T ), POINTER :: l2gp(:)
   TYPE( L3CFMProd_T ), POINTER :: cfStd(:), cfDg(:)
   TYPE( L3DZData_T ), POINTER :: dzA(:), dzD(:)
   TYPE( OutputFiles_T ) :: dFiles, sFiles

   CHARACTER (LEN=480) :: msr
   CHARACTER (LEN=FileNameLen) :: pcfNames(maxWindow)
   CHARACTER (LEN=1), POINTER :: anText(:)

   CHARACTER (LEN=DATE_LEN) :: mis_Days(maxWindow)

   INTEGER :: i, l2Days, numFiles, mis_l2Days, error
   integer, parameter :: NORMAL_EXIT_STATUS = 2

! Initializations
   call h5open_f(error)
   if (error /= 0) then
       call MLSMessage ( MLSMSG_Error, moduleName, &
         & "Unable to h5_open_f" )
   endif    

   sFiles%nFiles = 0
   dFiles%nFiles = 0
   sFiles%name = ''
   dFiles%name = ''
   sFiles%date = ''
   dFiles%date = ''

   flag%createMS = .FALSE.
   flag%createMD = .FALSE.
   flag%createZS = .FALSE.
   flag%createZD = .FALSE.

   CALL MLSMessage (MLSMSG_Info, ModuleName, &
                                 'EOS MLS Level 3 Monthly data processing started')

! Fill structures with input data from the PCF and L3CF.

   CALL OpenMON(pcf, cf, cfStd, cfDg, cfDef, anText)

! For each Standard product requested in the cf,

   DO i = 1, SIZE(cfStd)
	print *, i,  SIZE(cfStd)

! Read all available data in the input window

      CALL ReadL2GPProd(cfStd(i)%l3prodName, cfStd(i)%fileTemplate, &
                        pcf%startDay, pcf%endDay, l2Days, mis_l2Days, mis_Days, l2gp)

! If no data found, go on to the next product

      IF (l2Days < 1) THEN
         msr = 'No data found for ' // TRIM(cfStd(i)%l3prodName) // &
               '.  Skipping Monthly processing and moving on to the next product.'
         CALL MLSMessage (MLSMSG_Warning, ModuleName, msr)
         CYCLE
      ELSE
         msr = 'Input data successfully read; begin processing data for ' // &
               cfStd(i)%l3prodName
         CALL MLSMessage (MLSMSG_Info, ModuleName, msr)
      ENDIF

! Core processing for Standard products

      CALL MonthlyCoreProcessing(cfStd(i), pcf, cfDef, l2Days, l2gp, mm, mmA, mmD, &
                                 mzA, mzD, dzA, dzD, mis_l2Days, mis_Days)

      msr = 'CORE processing completed for ' // TRIM(cfStd(i)%l3prodName) &
            // '; starting Output task ...'
      CALL MLSMessage (MLSMSG_Info, ModuleName, msr)

! Deallocate the L2GP database

      CALL DestroyL2GPDatabase(l2gp)

! Output and Close for the product

      CALL OutputStd(pcf, cfDef%stdType, cfStd(i)%mode, dzA, dzD, mzA, mzD, &
                     mm, mmA, mmD, sFiles, flag)

   ENDDO

! Begin Diagnostic processing

   msr = 'Standard product loop completed; beginning Diagnostic product loop ...'
   CALL MLSMessage (MLSMSG_Info, ModuleName, msr)

! Get the names of any L2GP Diagnostics files from the PCF

   CALL GetL2GPfromPCF(mlspcf_l2dg_start, mlspcf_l2dg_end, cfDef%l2dgType, &
                       pcf%startDay, pcf%EndDay, numFiles, pcfNames, mis_l2Days, mis_Days)

! If no files are found, skip to Output/Close

   IF (numFiles < 1) THEN

      CALL MLSMessage (MLSMSG_Warning, ModuleName, 'No L2GP Diagnostics files &
                      &found in the PCF for the given day range.')

   ELSE

! For each product in the Diagnostic section of the cf,

      DO i = 1, SIZE(cfDg)
d153 2
d156 1
a156 16
! Read all the l2gp data which exist in the input window for that product

         CALL ReadL2DGData(cfDg(i)%l3prodName, numFiles, pcfNames, l2Days, l2gp)

! If insufficient data found, go on to the next product

         IF (l2Days < 1) THEN
            msr = 'No data found for ' // TRIM(cfDg(i)%l3prodName) &
               // '.  Skipping CORE processing and moving on to the next product.'
            CALL MLSMessage (MLSMSG_Warning, ModuleName, msr)
            CYCLE
         ELSE
            msr = 'Input data successfully read for ' //  &
                   TRIM(cfDg(i)%l3prodName) // '; CORE processing started ...'
            CALL MLSMessage (MLSMSG_Info, ModuleName, msr)
         ENDIF
d158 1
a158 1
! Monthly Core processing
d160 11
a170 2
         CALL MonthlyCoreProcessing(cfDg(i), pcf, cfDef, l2Days, l2gp, &
                                    mm, mmA, mmD, mzA, mzD, dzA, dzD, mis_l2Days, mis_Days)
d172 1
a172 3
         msr = 'CORE processing completed for ' // TRIM(cfDg(i)%l3prodName) &
               // '; starting Output task ...'
         CALL MLSMessage (MLSMSG_Info, ModuleName, msr)
d174 2
a175 1
! Deallocate the L2GP database
d177 3
a179 1
         CALL DestroyL2GPDatabase(l2gp)
d181 3
a183 1
! Output and Close for the product
d185 1
a185 2
         CALL OutputDg(pcf, cfDef%dgType, dzA, dzD, mzA, mzD, mm, mmA, mmD, &
                       dFiles, flag)
d187 2
a188 1
      ENDDO
d190 1
a190 1
   ENDIF
d192 1
a192 1
! Perform final Output & Close tasks outside of the product processing loop.
d194 1
a194 2
   CALL MLSMessage (MLSMSG_Info, ModuleName, &
            'Product processing completed; beginning Output/Close task ... ')
d196 4
a199 1
   CALL OutputMON(sFiles, dFiles, flag, pcf, cfStd, cfDg, cf, anText)
d201 7
a207 8
   CALL MLSMessage (MLSMSG_Info, ModuleName, &
    'EOS MLS Level 3 Monthly data processing successfully completed!')
   call h5close_f(error)                            
   if (error /= 0) then                             
     call MLSMessage ( MLSMSG_Error, moduleName, &  
      & "Unable to h5_close_f" )                    
   endif                                            
   call MLSMessageExit(NORMAL_EXIT_STATUS)
d209 2
a210 2
! Detailed description of program
! The program is a prototype for the MLS Level 3 Monthly subprogram.
d217 3
@


1.11
log
@Sets status on normal exit to 2
@
text
@d28 1
a28 1
   "$Id: MLSL3M.f90,v 1.10 2002/03/28 21:54:02 ybj Exp $"
d58 1
a58 1
   INTEGER :: i, l2Days, numFiles, mis_l2Days
d62 5
d202 5
d217 3
@


1.10
log
@MLSL3M.f90
@
text
@d28 1
a28 1
   "$Id: MLSL3M.f90,v 1.9 2002/03/27 23:27:14 ybj Exp $"
d59 1
d197 1
d207 3
@


1.9
log
@MonthlyProcessModule.f90
@
text
@d28 1
a28 1
   "$Id: MLSL3M.f90,v 1.8 2001/12/12 17:48:03 nakamura Exp $"
d83 1
a83 2
   !DO i = 1, SIZE(cfStd)
      DO i = 1, 1 
a105 2
	print *, 'Before MonthlyCoreProcessing'
 
a112 1
	print *, 'After MonthlyCoreProcessing'
d145 1
a145 3
	print *, ''

      DO i = 6, SIZE(cfDg)
a149 1
	print *, 'ReadL2DGData 1'
a150 1
	print *, 'ReadL2DGData 2'
d205 3
@


1.8
log
@Removed unused dz & mz arguments.
@
text
@d28 1
a28 1
   "$Id: MLSL3M.f90,v 1.7 2001/09/26 19:48:28 nakamura Exp $"
d56 3
a58 1
   INTEGER :: i, l2Days, numFiles
d83 3
a85 1
   DO i = 1, SIZE(cfStd)
d90 1
a90 1
                        pcf%startDay, pcf%endDay, l2Days, l2gp)
d107 2
d110 1
a110 1
                                 mzA, mzD, dzA, dzD)
d116 1
d136 1
a136 1
                       pcf%startDay, pcf%EndDay, numFiles, pcfNames)
d149 4
a152 1
      DO i = 1, SIZE(cfDg)
d156 1
d158 1
d176 1
a176 1
                                    mm, mmA, mmD, mzA, mzD, dzA, dzD)
d213 3
@


1.7
log
@Removed com ZM output; added cfDg deallocate.
@
text
@d28 1
a28 1
   "$Id: MLSL3M.f90,v 1.6 2001/09/06 18:48:39 nakamura Exp $"
d44 1
a44 1
   TYPE( L3MZData_T ) :: mz, mzA, mzD
d49 1
a49 1
   TYPE( L3DZData_T ), POINTER :: dz(:), dzA(:), dzD(:)
d104 2
a105 2
                                 mz, mzA, mzD, dz, dzA, dzD)
      
a113 3
      CALL DestroyL3DZDatabase(dz)
      CALL DeallocateL3MZ(mz)

d164 1
a164 1
                                    mm, mmA, mmD, mz, mzA, mzD, dz, dzA, dzD)
a173 3
         CALL DestroyL3DZDatabase(dz)
         CALL DeallocateL3MZ(mz)

d201 3
@


1.6
log
@Modified so that dg products are processed with the same Core as std prods.
@
text
@d9 1
a9 1
   USE L2GPData
d28 1
a28 1
   "$Id: MLSL3M.f90,v 1.5 2001/08/08 19:53:47 nakamura Exp nakamura $"
d114 3
d119 1
a119 1
      CALL OutputStd(pcf, cfDef%stdType, cfStd(i)%mode, dz, dzA, dzD, mz, mzA, mzD, &
d124 2
a128 2
   numFiles = 0

d166 2
a167 2
         CALL MonthlyCoreProcessing(cfDg(i), pcf, cfDef, l2Days, l2gp, mm, mmA, mmD, &
                                    mz, mzA, mzD, dz, dzA, dzD)
d177 3
d182 1
a182 1
         CALL OutputDg(pcf, cfDef%dgType, dz, dzA, dzD, mz, mzA, mzD, mm, mmA, mmD, &
d194 1
a194 1
   CALL OutputMON(sFiles, dFiles, flag, pcf, cfStd, cf, anText)
d207 3
@


1.5
log
@Added cfDef to MonthlyCoreProcessing args; added comments delineating CORE from I/O.
@
text
@d28 1
a28 1
   "$Id: MLSL3M.f90,v 1.4 2001/08/02 23:35:52 ybj Exp $"
d48 1
a48 2
   TYPE( L3CFDg_T ), POINTER :: cfDg(:)
   TYPE( L3CFMProd_T ), POINTER :: cfProd(:)
d77 1
a77 1
   CALL OpenMON(pcf, cf, cfProd, cfDef, cfDg, anText)
d81 1
a81 1
   DO i = 1, SIZE(cfProd)
d85 1
a85 1
      CALL ReadL2GPProd(cfProd(i)%l3prodName, cfProd(i)%fileTemplate, &
d91 1
a91 1
         msr = 'No data found for ' // TRIM(cfProd(i)%l3prodName) // &
d97 1
a97 1
               cfProd(i)%l3prodName
d103 1
a103 1
      CALL MonthlyCoreProcessing(cfProd(i), pcf, cfDef, l2Days, l2gp, mm, mmA, mmD, &
d105 2
a106 2

      msr = 'CORE processing completed for ' // TRIM(cfProd(i)%l3prodName) &
d110 4
d116 1
a116 1
      CALL OutputStd(pcf, cfDef%stdType, cfProd(i)%mode, dz, dzA, dzD, mz, mzA, mzD, &
a118 16
! Deallocate the databases passed between CORE & the I/O shell

      CALL DeallocateL3MM(mm)
      CALL DeallocateL3MM(mmA)
      CALL DeallocateL3MM(mmD)

      CALL DeallocateL3MZ(mz)
      CALL DeallocateL3MZ(mzA)
      CALL DeallocateL3MZ(mzD)

      CALL DestroyL3DZDatabase(dz)
      CALL DestroyL3DZDatabase(dzA)
      CALL DestroyL3DZDatabase(dzD)

      CALL DestroyL2GPDatabase(l2gp)

d146 1
a146 1
         CALL ReadL2DGData(cfDg(i)%prodName, numFiles, pcfNames, l2Days, l2gp)
d151 1
a151 1
            msr = 'No data found for ' // TRIM(cfDg(i)%prodName) &
d157 1
a157 1
                   TRIM(cfDg(i)%prodName) // '; CORE processing started ...'
d163 2
a164 2
!        CALL MonthlyDgProcessing(pcf, cfDef, cfDg(i), latGrid, lonGrid, l2gp, mz, &
!                                 mzA, mzD, dz, dzA, dzD, mm)
d166 1
a166 1
         msr = 'CORE processing completed for ' // TRIM(cfDg(i)%prodName) &
d170 1
a170 1
! Output and Close for the product
d172 1
a172 2
!        CALL OutputDg(pcf, cfDef, cfDg(i), dz, dzA, dzD, mz, mzA, mzD, mm, &
!                      dFiles, flag)
d174 1
a174 7
! Deallocate the databases passed between CORE & the I/O shell

         CALL DeallocateL3MM(mm)

         CALL DeallocateL3MZ(mz)
         CALL DeallocateL3MZ(mzA)
         CALL DeallocateL3MZ(mzD)
d176 2
a177 5
         CALL DestroyL3DZDatabase(dz)
         CALL DestroyL3DZDatabase(dzA)
         CALL DestroyL3DZDatabase(dzD)

         CALL DestroyL2GPDatabase(l2gp)
d188 1
a188 1
   CALL OutputMON(sFiles, dFiles, flag, pcf, cfProd, cf, anText)
d201 3
a214 1
!
@


1.4
log
@Fix interface call to MonthlyCoreProcessing
@
text
@d28 1
a28 1
   "$Id: MLSL3M.f90,v 1.3 2001/08/01 18:28:56 nakamura Exp $"
d97 1
a97 1
         msr = 'Input data successfully read; begin sorting data for ' // &
d104 6
a109 1
     CALL MonthlyCoreProcessing(cfProd(i), pcf, l2Days, l2gp, mm, mmA, mmD, mz, mzA, mzD, dz, dzA, dzD)
d177 5
a181 1
!                                 mzA, mzD, dz, dzA, dzD, mm, mmA, mmD)
d185 1
a185 1
!        CALL OutputDg(pcf, cfDef, cfDg(i), dz, dzA, dzD, mz, mzA, mzD, mm, mmA, mmD, &
a190 2
         CALL DeallocateL3MM(mmA)
         CALL DeallocateL3MM(mmD)
d224 3
@


1.3
log
@I/O-Core interface switched back to Daily paradigm.
@
text
@d22 1
a22 1
!  USE MonthlyProcessModule
d28 1
a28 1
   "$Id: MLSL3M.f90,v 1.2 2001/07/20 19:30:29 nakamura Exp $"
d104 1
a104 2
!     CALL MonthlyCoreProcessing(pcf, cfDef, cfProd(i), l2gp, mz, mzA, mzD, dz, dzA, &
!                                dzD, mm, mmA, mmD)
d217 3
@


1.2
log
@Commented out sample CALL to Core routine.
@
text
@d22 1
d28 1
a28 1
   "$Id: MLSL3M.f90,v 1.1 2001/07/18 15:42:48 nakamura Exp $"
d43 2
a44 2
   TYPE( L3MMData_T ) :: mm
   TYPE( L3MZData_T ) :: mz
d50 1
a50 1
   TYPE( L3DZData_T ), POINTER :: dz(:)
d57 1
a57 3
   INTEGER :: first, i, l2Days, last, nlev, numFiles

   LOGICAL :: writel3dz
a67 1
   writel3dz = .FALSE.
d102 1
a102 19
! For combined mode, sort the L2GP data according to the desired pressure levels.

!     CALL Sort (cfProd(i)%l3presLvl(1), cfProd(i)%l3presLvl(2), l2gp(1), first, &
!                last, nlev)

! Process & output the daily zonal means

!     CALL DailyZonalMean(pcf, cfDef, cfProd(i)%l3prodName, 'com', l2gp(1), first, &
!                         last, nlev, dz, writel3dz)
      IF (writel3dz) THEN
         CALL OutputL3DZ(cfDef%stdType, dz, sFiles)
      ELSE
         msr = TRIM(cfProd(i)%l3prodName) // ' DZ combined' // NOOUT_ERR
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
      ENDIF
      CALL DestroyL3DZDatabase(dz)
      writel3dz = .FALSE.

! Process & output the monthly zonal means
d104 2
a105 4
!     CALL MonthlyZonalMean(cfProd(i)%l3prodName, cfDef, l2gp, 'com', first, last, &
!                           nlev, mz)
      CALL OutputL3MZ(pcf%zsName, mz, flag%createZS)
      CALL DeallocateL3MZ(mz)
d107 1
a107 1
! If required for this mode, process & output the monthly map
d109 2
a110 7
      IF ( (cfProd(i)%mode == 'com') .OR. (cfProd(i)%mode == 'all') ) THEN
!        CALL MonthlyMap (cfProd(i)%l3prodName, cfProd(i)%latGridMap, &
!                         cfProd(i)%nLats, cfProd(i)%longGrid, cfProd(i)%nLons, &
!                         l2gp, 'com', first, last, nlev, mm)
         CALL OutputMMGrids(pcf%msName, mm, flag%createMS)
         CALL DeallocateL3MM(mm)
      ENDIF
d112 1
a112 1
! Ascending -- sort, dz, mz, mm
d114 3
a116 13
!     CALL Sort (cfProd(i)%ascPresLvl(1), cfProd(i)%ascPresLvl(2), l2gp(1), first, &
!                last, nlev)

!     CALL DailyZonalMean(pcf, cfDef, cfProd(i)%l3prodName, 'asc', l2gp(1), first, &
!                         last, nlev, dz, writel3dz)
      IF (writel3dz) THEN
         CALL OutputL3DZ(cfDef%stdType, dz, sFiles)
      ELSE
         msr = TRIM(cfProd(i)%l3prodName) // ' DZ asc' // NOOUT_ERR
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
      ENDIF
      CALL DestroyL3DZDatabase(dz)
      writel3dz = .FALSE.
a117 3
!     CALL MonthlyZonalMean(cfProd(i)%l3prodName, cfDef, l2gp, 'asc', first, last, &
!                           nlev, mz)
      CALL OutputL3MZ(pcf%zsName, mz, flag%createZS)
d119 2
a121 21
      IF ( INDEX(cfProd(i)%mode,'a') /= 0) THEN
!        CALL MonthlyMap (cfProd(i)%l3prodName, cfProd(i)%latGridMap, &
!                         cfProd(i)%nLats, cfProd(i)%longGrid, cfProd(i)%nLons, &
!                         l2gp, 'asc', first, last, nlev, mm)
         CALL OutputMMGrids(pcf%msName, mm, flag%createMS)
         CALL DeallocateL3MM(mm)
      ENDIF

! Descending

!     CALL Sort (cfProd(i)%desPresLvl(1), cfProd(i)%desPresLvl(2), l2gp(1), first, &
!                last, nlev)

!     CALL DailyZonalMean(pcf, cfDef, cfProd(i)%l3prodName, 'des', l2gp(1), first, &
!                         last, nlev, dz, writel3dz)
      IF (writel3dz) THEN
         CALL OutputL3DZ(cfDef%stdType, dz, sFiles)
      ELSE
         msr = TRIM(cfProd(i)%l3prodName) // ' DZ des' // NOOUT_ERR
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
      ENDIF
d123 2
a124 16
      writel3dz = .FALSE.

!     CALL MonthlyZonalMean(cfProd(i)%l3prodName, cfDef, l2gp, 'des', first, last, &
!                           nlev, mz)
      CALL OutputL3MZ(pcf%zsName, mz, flag%createZS)
      CALL DeallocateL3MZ(mz)

      IF ( (INDEX(cfProd(i)%mode,'d') /= 0) .OR. (cfProd(i)%mode == 'all') )THEN
!        CALL MonthlyMap (cfProd(i)%l3prodName, cfProd(i)%latGridMap, &
!                         cfProd(i)%nLats, cfProd(i)%longGrid, cfProd(i)%nLons, &
!                         l2gp, 'des', first, last, nlev, mm)
         CALL OutputMMGrids(pcf%msName, mm, flag%createMS)
         CALL DeallocateL3MM(mm)
      ENDIF

! Deallocate the l2gp database for the product
a148 2
      writel3dz = .FALSE.

d170 1
a170 21
! Sort the data into desired pressure levels for the product

!        CALL Sort(cfDg(i)%minPresLvl, cfDg(i)%maxPresLvl, l2gp(1), first, last, &
!                  nlev)

! Combined mode processing -- DZ

!        CALL DailyZonalMean(pcf, cfDef, cfDg(i)%prodName, 'com', l2gp(1), first, &
!                            last, nlev, dz, writel3dz)

! If data are flagged for output, write them to L3DZ Diagnostic files; keep track of
! which files have been created for later metadata annotation

         IF (writel3dz) THEN
             CALL OutputL3DZ(cfDef%dgType, dz, dFiles)
         ELSE
             msr = TRIM(cfDg(i)%prodName) // ' DZ ' // NOOUT_ERR
             CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
         ENDIF

! Re-initialize for next mode
d172 2
a173 2
         CALL DestroyL3DZDatabase(dz)
         writel3dz = .FALSE.
d175 1
a175 1
! Monthly ZM
d177 2
a178 4
!        CALL MonthlyZonalMean(cfDg(i)%prodName, cfDef, l2gp, 'com', first, last, &
!                              nlev, mz)
         CALL OutputL3MZ(pcf%zdName, mz, flag%createZD)
         CALL DeallocateL3MZ(mz)
d180 1
a180 1
! MM
a181 3
!        CALL MonthlyMap (cfDg(i)%prodName, cfProd(1)%latGridMap, cfProd(1)%nLats, &
!              cfDg(i)%lonGrid, cfDg(i)%nLon, l2gp, 'com', first, last, nlev, mm)
         CALL OutputMMGrids(pcf%mdName, mm, flag%createMD)
d183 2
a185 20
! Ascending processing -- DZ

!        CALL DailyZonalMean(pcf, cfDef, cfDg(i)%prodName, 'asc', l2gp(1), first, &
!                            last, nlev, dz, writel3dz)

         IF (writel3dz) THEN
            CALL OutputL3DZ(cfDef%dgType, dz, dFiles)
         ELSE
            msr = TRIM(cfDg(i)%prodName) // 'Ascending DZ' // NOOUT_ERR
            CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
         ENDIF

         CALL DestroyL3DZDatabase(dz)
         writel3dz = .FALSE.

! Monthly ZM

!        CALL MonthlyZonalMean(cfDg(i)%prodName, cfDef, l2gp, 'asc', first, last, &
!                              nlev, mz)
         CALL OutputL3MZ(pcf%zdName, mz, flag%createZD)
d187 2
a188 12

! Descending

!        CALL DailyZonalMean(pcf, cfDef, cfDg(i)%prodName, 'des', l2gp(1), first, &
!                            last, nlev, dz, writel3dz)

         IF (writel3dz) THEN
            CALL OutputL3DZ(cfDef%dgType, dz, dFiles)
         ELSE
            msr = TRIM(cfDg(i)%prodName) // 'Descending DZ' // NOOUT_ERR
            CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
         ENDIF
d191 2
a192 8
         writel3dz = .FALSE.

!        CALL MonthlyZonalMean(cfDg(i)%prodName, cfDef, l2gp, 'des', first, last, &
!                              nlev, mz)
         CALL OutputL3MZ(pcf%zdName, mz, flag%createZD)
         CALL DeallocateL3MZ(mz)

! Deallocate the L2GP database for this product
d218 3
@


1.1
log
@MLS Level 3 Monthly program.
@
text
@d27 1
a27 1
   "$Id: mon_MLSL3.f90,v 1.2 2001/06/26 18:21:47 nakamura Exp nakamura $"
d161 3
a163 3
         CALL MonthlyMap (cfProd(i)%l3prodName, cfProd(i)%latGridMap, &
                          cfProd(i)%nLats, cfProd(i)%longGrid, cfProd(i)%nLons, &
                          l2gp, 'asc', first, last, nlev, mm)
d351 4
a354 1
! $Log: $
@

