head	2.133;
access;
symbols
	v5-02-NRT-19:2.133
	v6-00:2.133
	v5-02-NRT-18:2.133
	v5-02:2.133
	v5-01-NRT-17:2.133
	v5-01-NRT-16:2.133
	v5-01-NRT-15:2.133
	v5-01-NRT-14:2.133
	neuralnetworks-1-0:2.133.0.8
	cfm-single-freq-0-1:2.133.0.6
	v5-01:2.133
	v5-00:2.133
	v4-23-TA133:2.133.0.4
	mus-emls-1-70:2.133.0.2
	rel-1-0-englocks-work:2.132.0.2
	VUMLS1-00:2.132
	VPL1-00:2.132
	V4-22-NRT-08:2.132
	VAM1-00:2.132
	V4-21:2.128.0.2
	V4-13:2.128
	V4-12:2.127
	V4-11:2.127
	V4-10:2.127
	V3-43:2.87
	M4-00:2.121
	V3-41:2.87
	V3-40-PlusGM57:2.87.0.2
	V2-24-NRT-04:2.80
	V3-33:2.110
	V2-24:2.80
	V3-31:2.110
	V3-30-NRT-05:2.104
	cfm-01-00:2.98
	V3-30:2.87
	V3-20:2.87
	V3-10:2.85
	V2-23-NRT-02:2.80
	V2-23:2.80
	V2-22-NRT-01:2.80
	V2-22:2.80
	V2-21:2.78
	V2-20:2.78
	V2-11:2.75
	V2-10:2.75
	V2-00:2.75
	V1-51:2.73
	V1-50:2.73
	V1-45:2.73
	V1-44:2.73
	V1-43:2.72
	V1-42:2.66
	V1-41:2.66
	V1-32:2.66
	V1-40:2.66
	V1-31:2.66
	V1-30:2.65
	V1-13:2.60
	V1-12:2.60
	V1-11:2.60
	V1-10:2.60
	newfwm-feb03:2.60.0.2
	V1-04:2.31
	V1-03:2.31
	V1-02:2.31
	V1-00:2.31
	newfwm-sep01:2.21.0.2
	V0-7:2.21
	V0-5-Level2:2.18;
locks; strict;
comment	@# @;


2.133
date	2018.04.19.02.00.36;	author vsnyder;	state Exp;
branches;
next	2.132;

2.132
date	2015.07.14.23.23.52;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2015.06.30.18.38.12;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2015.04.28.23.59.52;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2015.03.28.01.10.03;	author vsnyder;	state Exp;
branches;
next	2.128;

2.128
date	2014.09.04.23.48.52;	author vsnyder;	state Exp;
branches;
next	2.127;

2.127
date	2014.01.09.18.15.42;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2014.01.08.18.31.48;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2013.08.30.03.56.01;	author vsnyder;	state Exp;
branches;
next	2.123;

2.123
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2013.06.12.02.10.47;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2012.02.17.00.21.05;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2012.02.13.23.27.27;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2012.02.02.01.17.03;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2011.11.11.00.32.29;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2011.11.09.17.41.02;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2011.11.04.23.38.47;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2011.08.20.02.04.03;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2011.08.09.23.17.43;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2011.07.28.18.03.37;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2011.05.05.15.20.04;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2011.04.15.00.20.32;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2011.02.18.17.56.16;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2010.11.25.01.19.27;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2010.11.19.23.58.19;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2010.11.05.00.31.10;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2010.11.03.18.30.41;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2010.09.25.01.14.34;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2010.09.17.00.02.57;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2010.08.31.02.05.38;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2010.08.27.21.55.35;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2010.08.20.23.19.50;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2010.08.13.22.22.59;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2010.08.06.22.58.40;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2010.06.28.17.00.49;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2010.05.20.00.51.50;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2010.05.19.17.51.41;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2010.05.19.00.32.06;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2010.05.13.23.45.14;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2010.04.30.22.55.32;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2010.04.17.01.43.35;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2010.03.24.20.48.55;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2010.03.19.20.18.47;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2010.03.17.20.59.10;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2010.02.25.18.04.45;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2009.11.17.23.43.51;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2008.12.18.21.31.18;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2008.09.30.22.28.03;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2008.06.06.01.55.29;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2008.05.03.01.49.55;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2007.10.03.23.58.46;	author vsnyder;	state Exp;
branches;
next	2.79;

2.79
date	2007.04.26.20.30.32;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2006.08.05.02.11.58;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2006.08.04.01.53.43;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2006.08.03.01.10.06;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2005.06.29.00.42.35;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2005.06.22.17.25.49;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2004.06.10.00.57.47;	author vsnyder;	state Exp;
branches;
next	2.72;

2.72
date	2004.02.11.01.08.44;	author livesey;	state Exp;
branches;
next	2.71;

2.71
date	2004.01.30.23.27.32;	author livesey;	state Exp;
branches;
next	2.70;

2.70
date	2004.01.24.01.44.36;	author livesey;	state Exp;
branches;
next	2.69;

2.69
date	2004.01.24.01.01.22;	author livesey;	state Exp;
branches;
next	2.68;

2.68
date	2004.01.23.19.07.49;	author livesey;	state Exp;
branches;
next	2.67;

2.67
date	2004.01.23.05.37.34;	author livesey;	state Exp;
branches;
next	2.66;

2.66
date	2003.09.15.17.45.03;	author livesey;	state Exp;
branches;
next	2.65;

2.65
date	2003.08.14.20.24.23;	author livesey;	state Exp;
branches;
next	2.64;

2.64
date	2003.08.13.00.47.34;	author livesey;	state Exp;
branches;
next	2.63;

2.63
date	2003.08.08.23.04.45;	author livesey;	state Exp;
branches;
next	2.62;

2.62
date	2003.06.20.19.31.39;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2003.05.13.04.46.24;	author livesey;	state Exp;
branches;
next	2.60;

2.60
date	2003.02.06.01.37.12;	author livesey;	state Exp;
branches;
next	2.59;

2.59
date	2003.02.06.01.34.21;	author livesey;	state Exp;
branches;
next	2.58;

2.58
date	2003.02.06.00.45.37;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2003.02.05.21.55.45;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2003.01.28.02.41.10;	author livesey;	state Exp;
branches;
next	2.55;

2.55
date	2003.01.13.19.28.20;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2002.11.25.11.47.34;	author mjf;	state Exp;
branches;
next	2.53;

2.53
date	2002.11.22.12.47.47;	author mjf;	state Exp;
branches;
next	2.52;

2.52
date	2002.11.20.21.06.25;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2002.10.08.00.09.10;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2002.10.05.00.42.31;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2002.10.02.23.20.19;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2002.09.11.17.43.38;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2002.08.28.21.43.38;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2002.08.28.20.42.39;	author livesey;	state Exp;
branches;
next	2.45;

2.45
date	2002.08.28.01.12.20;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2002.08.23.01.23.44;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2002.08.21.23.10.11;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2002.08.20.21.01.40;	author livesey;	state Exp;
branches;
next	2.41;

2.41
date	2002.08.07.00.05.14;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2002.07.25.15.53.40;	author mjf;	state Exp;
branches;
next	2.39;

2.39
date	2002.07.22.03.29.23;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2002.07.22.03.25.23;	author livesey;	state Exp;
branches;
next	2.37;

2.37
date	2002.07.17.06.00.21;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2002.07.11.22.21.00;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2002.07.01.23.48.56;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2002.06.22.23.12.07;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2002.06.12.18.00.12;	author livesey;	state Exp;
branches;
next	2.32;

2.32
date	2002.05.21.01.13.24;	author livesey;	state Exp;
branches;
next	2.31;

2.31
date	2002.03.15.21.22.42;	author livesey;	state Exp;
branches
	2.31.2.1;
next	2.30;

2.30
date	2002.03.13.22.00.53;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2002.03.13.01.28.48;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2002.02.08.22.51.28;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2002.02.05.04.14.26;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2002.01.23.00.50.50;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2002.01.22.18.14.29;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2002.01.21.23.11.49;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2002.01.21.21.13.42;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2002.01.18.00.34.23;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.06.21.22.45.43;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.06.06.17.27.29;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2001.05.23.22.00.59;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.05.02.20.24.03;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2001.05.02.20.23.10;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2001.04.28.01.38.36;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.04.28.01.26.50;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.04.27.17.36.33;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.27.07.24.50;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.27.07.05.28;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.26.23.55.17;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.26.22.32.04;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.04.26.22.12.21;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.04.26.22.08.39;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.04.26.20.02.26;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.04.26.19.33.03;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.04.26.02.48.08;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.04.26.00.06.33;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.04.25.20.32.42;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.04.24.20.20.48;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.04.24.20.07.44;	author livesey;	state Exp;
branches;
next	;

2.31.2.1
date	2002.05.22.23.23.22;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.133
log
@Compute address for allocate/deallocate tracking.  Remove USE statements for
unused names.
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module L2PC_m
  !=============================================================================

  ! This module contains data types etc. for dealing with the new EMLS L2PC
  ! files.  The first version dealt with ascii files, but later versions
  ! must be HDF5.

  use Allocate_deallocate, only: allocate_test, deallocate_test
  use Dump_0, only: dump
  use HessianModule_0, only: hessianElement_t, &
    & H_absent, h_sparse, h_full, h_unknown, &
    & Createblock, destroyblock
  use HessianModule_1, only: hessian_t, &
    & Copyhessianvalue, createblock, createemptyhessian, destroyhessian
  use Highoutput, only: outputnamedvalue
  use Intrinsic, only: l_adopted, l_channel, l_geodaltitude, l_none, l_vmr, &
    & L_radiance, l_none, l_intermediatefrequency, l_latitude, l_fieldazimuth, &
    & L_rows, l_columns, l_columnabundance, l_temperature, l_tscat, &
    & L_isotoperatio, l_calsidebandfraction, l_limbsidebandfraction, &
    & L_opticaldepth, l_elevoffset, &
    & Lit_indices, &
    & Phyq_colmabundance, phyq_dimensionless, phyq_pctrhi, &
    & Phyq_temperature, phyq_vmr
  use Manipulatevectorquantities, only: dovectorsmatch
  use MatrixModule_0, only: m_absent, m_banded, m_column_sparse, m_full, &
    & MatrixElement_t, m_unknown, destroyblock
  use MatrixModule_1, only: matrix_t, matrix_database_t, &
    & CopyMatrixValue, createBlock, createEmptyMatrix, &
    & DestroyMatrix, dump, dump_struct, &
    & FindBlock, getActualMatrixFromDatabase
  use MLSCommon, only: MLSFile_t
  use MLSFiles, only: dumpMLSFile => dump
  use MLSKinds, only: r8, r4
  use MLSMessagemodule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
  use MLSFinds, only: findfirst
  use MLSSignals_m, only: getsignalname
  use MLSStringlists, only: optiondetail, switchdetail
  use MLSStrings, only: writeintstochars
  use Molecules, only: isextinction, l_rhi
  use Moretree, only: getlitindexfromstring, getstringindexfromstring
  use Output_m, only: newline, output
  use Parse_signal_m, only: parse_signal
  use Quantitytemplates, only: quantitytemplate_t, &
    & Addquantitytemplatetodatabase, copyquantitytemplate, &
    & Destroyquantitytemplatecontents, inflatequantitytemplatedatabase, &
    & Nullifyquantitytemplate, setupnewquantitytemplate
  use String_table, only: display_string, getString => get_string, &
    & isStringInTable
  use Toggles, only: switches
  use Tree, only: decoration, nsons, subtree
  use Vectorsmodule, only: vectortemplate_t, vector_t, &
    & Assignment(=), addvectortemplatetodatabase, &
    & Addvectortodatabase, constructvectortemplate, copyvector, createvector, &
    & Destroyvectorinfo, dump, nullifyvectortemplate

  implicit none
  private

  public :: AddBinSelectorToDatabase, AddL2PCToDatabase, AdoptVectorTemplate, &
    & binSelector_T, BinSelectors, CreateDefaultBinSelectors, &
    & DefaultSelector_FieldAzimuth, DefaultSelector_Latitude, &
    & DestroyL2PC, DestroyL2PCDatabase, DestroyBinSelectorDatabase, &
    & Diff, Dump, FlushL2PCBins, L2PC_T, &
    & LoadHessian, LoadMatrix, LoadVector, OutputHDF5L2PC, &
    & PopulateL2PCBin, PopulateL2PCBinByName, &
    & ReadCompleteHDF5L2PCFile

  interface DIFF
    module procedure DiffL2PCFiles, DiffL2PCs
  end interface

  interface DUMP
    module procedure DUMPONEL2PC, DUMPL2PCDATABASE, DUMPL2PCFILE
  end interface

  interface DUMP_PRIVATE
    module procedure DUMPONEL2PC, DUMPL2PCDATABASE, DUMPL2PCFILE, DUMPL2PCINFO
  end interface
  ! This is an update to the L2PCs where we can store both Jacobians and Hessians
  ! Previously the L2PC's were just Matrix_Ts, now they're more diversified
  ! As this contains pointers to vector_T's and so on, I maintain a private
  ! set of databases of these in this module.  We can't use the main databases,
  ! as these would get destroyed at the end of each chunk.

  ! The supporting databases
  integer, dimension(:), pointer, public, save :: FileIDDatabase => NULL()
  type(QuantityTemplate_T), dimension(:), pointer, save :: L2PCQTS => NULL()
  type(VectorTemplate_T), dimension(:), pointer, save :: L2PCVTS => NULL()
  type(Vector_T), dimension(:), pointer, save :: L2PCVS => NULL()

  logical :: verbose
  logical :: verboser

  ! This type holds an l2pc sometimes called a "bin"
  type L2PC_T
    integer :: NAME                     ! The name of the L2PC bin
    type(Matrix_T) :: J                 ! The Jacobian
    logical :: GOTH                     ! Set true if also have Hessian Info
    type(Hessian_T) :: H                ! The Hessian
  end type L2PC_T

  ! The L2PC database
  ! We could create much-needed flexibility if we allowed the user to maintain
  ! a separate database or multiple databases
  ! The same goes for binSelector and L2PCInfo databases
  type(L2PC_T), dimension(:), pointer, public, save :: L2PCDatabase => NULL()

  ! This datatype describes a selection rule for l2pc bins.
  type BinSelector_T
    integer :: selectorType             ! What quantity type does this apply to
    integer :: molecule                 ! What molecule does it apply to
    integer :: nameFragment             ! A possible name fragment
    logical :: exact                    ! We require an exact numeric match for this selector
    real(r8), dimension(2) :: heightRange ! The height range for this selector
    real(r8) :: cost                    ! The cost for that range
  end type BinSelector_T

  type(BinSelector_T), dimension(:), pointer, save :: BINSELECTORS => NULL()

  type L2PCInfo_T
    integer :: fileID     ! What is the HDF5 file ID
    integer :: binID      ! What is the groupID for the bin
    integer :: blocksID   ! What is the groupID for the blocks
    integer :: hBlocksID  ! What is the groupID for the hessian blocks
    integer, dimension(:,:), pointer :: BLOCKID => NULL()
    character(len=64) :: matrixName
  end type L2PCINFO_T
  type(L2PCInfo_T), dimension(:), pointer, save :: L2PCINFO => NULL()

  ! Default bin selectors (see CreateDefaultBinSelectors below)
  logical, parameter :: DEEBUG = .false.
  integer, parameter :: DEFAULTSELECTOR_LATITUDE = 1
  integer, parameter :: DEFAULTSELECTOR_FIELDAZIMUTH = 2
  
  logical, parameter :: DIEIFDESTROYFAILS = .false.
  integer, parameter :: MAXNBINS          = 200 ! max nBins in a file

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: L2PC_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains ! ============= Public Procedures ==========================

  subroutine get_string ( STRING, STRING_TEXT, CAP, STRIP, NOERROR, IERR, &
    & START, END )
  ! because get_string has the pernicious habit of bombing 
  ! if presented with 0 as its arg
  ! Args
    integer, intent(in) :: STRING
    character(len=*), intent(out) :: STRING_TEXT
    logical, intent(in), optional :: CAP
    logical, intent(in), optional :: STRIP
    logical, intent(in), optional :: NOERROR
    integer, intent(out), optional :: IERR
    integer, intent(in), optional :: START
    integer, intent(in), optional :: END
  string_text = 'undefined'
  if ( isStringInTable(string) ) &
    & call getString( STRING, STRING_TEXT, CAP, STRIP, NOERROR, IERR, &
    & START, END )
  end subroutine get_string

  ! ------------------------------------ AddBinSelectorToDatabase --
  integer function AddBinSelectorToDatabase ( database, item )

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    type (BinSelector_T), dimension(:), pointer :: DATABASE
    type (BinSelector_T) :: item
    ! Local variables
    type (BinSelector_T), dimension(:), pointer :: TEMPDATABASE

    include "addItemToDatabase.f9h"
    AddBinSelectorToDatabase = newSize
  end function AddBinSelectorToDatabase

  ! ------------------------------------  Add fileID to database ----
  integer function AddFileIDToDatabase ( Database, Item )

    ! This function simply adds a fileID  to a database of this type

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    integer, dimension(:), pointer :: Database
    integer :: Item

    integer, dimension(:), pointer :: TempDatabase

    include "addItemToDatabase.f9h"

    AddFileIDToDatabase = newSize
  end function AddFileIDToDatabase

  ! ------------------------------------  Add l2pc to database ----
  integer function AddL2PCToDatabase ( Database, Item )

    ! This function simply adds an l2pc  to a database of said l2pc s.

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    type(L2PC_T), dimension(:), pointer :: Database
    type(L2PC_T) :: Item

    type(L2PC_T), dimension(:), pointer :: TempDatabase

    include "addItemToDatabase.f9h"

    AddL2PCToDatabase = newSize
  end function AddL2PCToDatabase

  ! ----------------------------------- AdoptVectorTemplate --
  type (VectorTemplate_T) function AdoptVectorTemplate ( bin, name, quantityTemplates, source, message ) &
    & result ( vectorTemplate )
    ! This function is used to import a vector template from our private l2pc database
    ! into the mainstream database.  It also adopts the individual quantities into
    ! the mainstream quantity template database.

    ! Dummy arguments
    integer, intent(in) :: BIN          ! Name of MATRIX
    integer, intent(in) :: NAME         ! Name for new vector template
    type(QuantityTemplate_T), dimension(:), pointer :: QUANTITYTEMPLATES ! Mainstream database
    integer, intent(in) :: SOURCE       ! L_COLUMNS, L_ROWS
    character (len=*), intent(out) :: MESSAGE ! Error message

    ! Local variables
    integer :: I                        ! Array index
    type(VectorTemplate_T), pointer :: SOURCETEMPLATE ! Sought vector template
    type(Matrix_T), pointer :: M        ! The matrix
    integer :: QTY                      ! Loop counter
    type(QuantityTemplate_T) :: QT      ! A template

    ! Executable code
    message = ''
    call NullifyVectorTemplate ( vectorTemplate )

    i = FindFirst ( l2pcDatabase%name, bin )
    if ( i == 0 ) then
      message = 'No such l2pc bin found'
      return
    end if

    m => l2pcDatabase(i)%j
    if ( source == l_rows ) then
      sourceTemplate => m%row%vec%template
    else
      sourceTemplate => m%col%vec%template
    end if

    vectorTemplate = sourceTemplate
    vectorTemplate%name = name
    ! We need our own quantities array to point to the mainstream database
    nullify ( vectorTemplate%quantities )
    call Allocate_test ( vectorTemplate%quantities, vectorTemplate%noQuantities, &
      & 'adopted vectorTemplate%quantities', ModuleName )
    ! Copy each quantity from the l2pc database into the mainstream one
    do qty = 1, vectorTemplate%noQuantities
      call CopyQuantityTemplate ( qt, l2pcQTs ( sourceTemplate%quantities(qty) ) )
      i = FindFirst ( quantityTemplates%name, qt%name )
      if ( i /= 0 ) then
        ! Found this quantity already. Is it marked as one to be adopted
        if ( quantityTemplates(i)%quantityType == l_adopted ) then
          vectorTemplate%quantities(qty) = i
          ! Shallow copy this into the database over the 'adopted' placeholder,
          ! Destroy old placeholder first.
          call DestroyQuantityTemplateContents ( quantityTemplates(i) )
          quantityTemplates(i) = qt
        else
          call get_string ( qt%name, message, strip=.true. )
          message = 'Quantity ' // trim(message) // ' already exist, cannot adopt'
        end if
      else
        vectorTemplate%quantities(qty) = AddQuantityTemplateToDatabase ( quantityTemplates, qt )
      end if
      call NullifyQuantityTemplate ( qt ) ! To avoid treading on one in database
    end do
  end function AdoptVectorTemplate

  ! -------------------------------------- CreateDefaultBinSelectors --
  subroutine CreateDefaultBinSelectors
    ! This routine creates two bin selectors we know we need even
    ! if the user doesn't supply them in the l2cf.  If you add more
    ! here please make sure to also add DefaultSelector_... parmeters
    ! above.
    ! Local variables
    type (BinSelector_T) :: SEL
    integer :: DUMMY
    ! Executable code
    ! Create a latitude based one.  This is the one used by default if no
    ! other is supplied
    sel%selectorType = l_latitude
    sel%molecule = 0
    sel%nameFragment = 0
    sel%exact = .false.
    sel%heightRange = 0.0_r8
    sel%cost = 1.0_r8
    dummy = AddBinSelectorToDatabase ( binSelectors, sel )

    ! Create a template for a field_azimith one for the polarLinear model
    sel%selectorType = l_fieldAzimuth
    sel%molecule = 0
    sel%nameFragment = 0
    sel%exact = .true.
    sel%heightRange = 0.0_r8
    sel%cost = 1.0
    dummy = AddBinSelectorToDatabase ( binSelectors, sel )

  end subroutine CreateDefaultBinSelectors

  ! -------------------------------------- DestroyBinSelectorDatabase
  subroutine DestroyBinSelectorDatabase
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    ! Local variables
    integer(c_intptr_t) :: Addr            ! For tracing
    integer :: S, STATUS                   ! Flag from deallocate
    ! Executable code
    if ( .not. associated ( binSelectors ) ) return
    s = size(binSelectors) * storage_size(binSelectors) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(binSelectors(1)), addr)
    deallocate ( binSelectors, stat=status )
    call test_deallocate ( status, ModuleName, "binSelectors", s, address=addr )
  end subroutine DestroyBinSelectorDatabase

  ! ----------------------------------------------- DestroyL2PC ----
  subroutine DestroyL2PC ( l2pc )
    ! Dummy arguments
    type (L2pc_t), intent(inout), target :: L2PC

    integer :: QUANTITY                 ! Loop index
    integer :: VECTOR                   ! Loop index
    integer :: JH                       ! Loop index

    type (Vector_T), pointer :: V       ! Temporary pointer
    integer, parameter :: jacobians = 1
    integer, parameter :: hessians = jacobians + 1
    integer, parameter :: rows = 1
    integer, parameter :: cols = rows + 1

    ! Executable code
    verbose = switchDetail( switches, 'l2pc') > -1
    do jh = jacobians, hessians
      if ( jh == hessians .and. .not. l2pc%gotH ) cycle
      if ( verbose ) &
        & call outputNamedValue( ' About to destroy 1 (j) or 2 (h)', jh )
      if ( jh == hessians ) then
        call output( 'Unable to destroy hessian quantity templates yet', advance='yes' )
        cycle
      endif
      do vector = rows, cols
        if ( verbose ) &
          & call outputNamedValue( ' About to destroy 1 (rows) or 2 (cols)', vector )
        if ( vector == cols ) then
          if ( jh == jacobians ) then
            v => l2pc%j%col%vec
          else
            v => l2pc%h%col%vec
          end if
        else
          if ( jh == jacobians ) then
            v => l2pc%j%row%vec
          else
            v => l2pc%h%row%vec
          end if
        end if
        if ( .not. associated(v) ) cycle
        if ( .not. associated(v%quantities) ) cycle
        if ( verbose ) then
          call output( ' About to destroy vectors', advance='yes' )
          call outputNamedValue( ' Num quantities', size(v%quantities) )
        endif
        do quantity = 1, size(v%quantities)
          call DestroyQuantityTemplateContents (v%quantities(quantity)%template )
        end do
        call DestroyVectorInfo ( v )
      end do
    end do

    ! Destroy kStar
    if ( verbose ) &
      & call output( ' About to destroy matrix', advance='yes' )
    call DestroyMatrix ( l2pc%j )
    if ( verbose ) &
      & call output( ' About to destroy hessian', advance='yes' )
    if ( l2pc%goth ) call DestroyHessian ( l2pc%h )

  end subroutine DestroyL2PC

  ! ------------------------------------------- DestroyL2PCDatabase ---
  subroutine DestroyL2PCDatabase

    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: I, S, Status

    verbose = switchDetail( switches, 'l2pc') > -1
    if ( .not. associated(l2pcDatabase) ) then
      if ( verbose ) &
        & call output( 'l2pc database empty' )
    else
      do i = 1, size(l2pcDatabase)
        if ( verbose ) &
          & call outputNamedValue( 'Destroying l2pc db entry number ', i )
        call DestroyL2PC ( l2pcDatabase(i) )
      end do
      s = size(l2pcDatabase) * storage_size(l2pcDatabase) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(l2pcDatabase(1)), addr)
      deallocate ( l2pcDatabase, stat=status )
      call test_deallocate ( status, ModuleName, "l2pcDatabase", s, address=addr )
    end if

    ! Also destroy the info database (i.e. close files)
    call DestroyL2PCInfoDatabase
  end subroutine DestroyL2PCDatabase

  ! --------------------------------------- DiffL2PCFiles ---------------
  subroutine DiffL2PCFiles ( L2PCFile1, L2PCFile2, details, options )
    ! This subroutine Diffs an l2pc to stdout
    ! assuming it was read already
    use output_m, only: output

    ! Dummy arguments
    type (MLSFile_T), intent(inout) :: L2PCFile1, L2PCFile2
    integer, intent(in), optional :: DETAILS ! <=0 => Don't Diff multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but size
    !                                        ! >0 Diff even multi-dim arrays
    !                                        ! Default 0
    character(len=*), intent(in), optional :: options ! any of {jh*b[]}
                                             ! D: read files before Diffing
                                             ! j: Diff only matrices
                                             ! h: Diff only hessians
                                             ! *: Diff matrices and hessians
                                             ! b[HCN]: Diff only HCN blocks
                                             ! default is *
    ! Local variables
    logical :: different
    integer :: i
    integer, dimension(MAXNBINS) :: indices1
    integer, dimension(MAXNBINS) :: indices2
    logical :: mustRead
    integer :: nBins1
    integer :: nBins2
    logical :: silent
    logical :: verbose
    ! Executable
    mustRead = (optionDetail(options, 'D' ) == 'yes' )
    verbose = (optionDetail(options, 'v' ) == 'yes' )
    silent = (optionDetail(options, 'm' ) == 'yes' )
    if ( verbose ) call outputNamedValue( 'options', options )
    if ( verbose ) call outputNamedValue( 'mustRead', mustRead )
    if ( mustRead ) then
      call ReadCompleteHDF5L2PCFile ( L2PCFile1, 0, shallow=.true. )
      call ReadCompleteHDF5L2PCFile ( L2PCFile2, 0, shallow=.true. )
      if ( .not. associated(L2PCDataBase) ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Sorry-l2pc database still empty' )
      endif
      do i=1, size(L2PCDataBase)
        if ( any( &
          & (/ L2PCFile1%FileID%f_id, L2PCFile2%FileID%f_id /) &
          & == fileIDDataBase(i) ) ) &
          & call PopulateL2PCBin( i )
      enddo
    endif
    call getNBinsInFile ( L2PCFile1, indices1, nBins1 )
    call getNBinsInFile ( L2PCFile2, indices2, nBins2 )
    if ( verbose ) call outputNamedValue( 'nBins1', nBins1 )
    if ( verbose ) call outputNamedValue( 'indices1', indices1 )
    if ( verbose ) call outputNamedValue( 'nBins2', nBins2 )
    if ( verbose ) call outputNamedValue( 'indices2', indices2 )
    different = .false.
    do i=1, min( nBins1, nBins2 )
      if ( .not. silent ) call newline
      if ( verbose ) call outputNamedValue( 'file index', i )
      call DiffL2PCs( L2PCDataBase(indices1(i)), L2PCDataBase(indices2(i)), &
        & details, options, different )
    enddo
    if ( different ) then
      call output( 'These L2PC files differ', advance='yes' )
    elseif ( silent ) then
      call output( 'These L2PC files do not differ', advance='yes' )
    endif
  end subroutine DiffL2PCFiles

  ! --------------------------------------- DiffL2PCs ---------------
  subroutine DiffL2PCs ( L2pc1, L2pc2, details, options, different )
    ! This subroutine diffs two l2pcs

    use hessianModule_1, only: Diff
    use matrixModule_1, only: Diff
    use MLSStrings, only: Delete

    ! Dummy arguments
    type (l2pc_t), intent(inout) :: L2pc1, l2pc2
    integer, intent(in), optional :: DETAILS ! passed to Vector and Matrix dumps
    character(len=*), intent(in), optional :: options ! any of {jh*b[]}
                                             ! j: dump only matrices
                                             ! h: dump only hessians
                                             ! *: dump matrices and hessians
                                             ! b[HCN]: dump only HCN blocks
                                             ! default is *
    logical, intent(inout), optional :: different ! Are matrices different?
    ! Local variables
    character(len=16) :: audible
    logical :: dumpHessians
    logical :: dumpJacobians
    logical :: itsDifferent
    integer :: myDetails
    logical :: silent                        ! if opttions contain 'm'
    logical :: verbose                       ! if opttions contain 'b'
    ! Executable code
    myDetails = 0
    if ( present(details) ) myDetails = details
    dumpHessians = .true.
    dumpJacobians = .true.
    verbose = .false.
    silent = .false.
    audible = ' '
    if ( present(options) ) then
      dumpHessians = optionDetail( options, 'h' ) == 'yes'
      dumpJacobians = optionDetail( options, 'j' ) == 'yes'
      verbose = (optionDetail(options, 'v' ) == 'yes' )
      silent = (optionDetail(options, 'm' ) == 'yes' )
      audible = Delete ( options, 'm' )
      if ( verbose ) then
        call outputNamedValue( 'options', trim(options) )
        call outputNamedValue( 'dumpJacobians', dumpJacobians )
        call outputNamedValue( 'dumpHessians', dumpHessians )
      endif
    endif
    if ( verbose ) call outputNamedValue( 'myDetails', myDetails )
    if ( .not. silent ) then
      call output( '- Diffing L2PCs -', advance='yes' )
      call NameThoseBins
      if ( verbose ) call outputNamedValue( 'l2pc1%goth', l2pc1%goth )
      if ( verbose ) call outputNamedValue( 'l2pc2%goth', l2pc2%goth )
    endif
    itsDifferent = .false.
    if ( dumpJacobians ) then
      call diff ( l2pc1%j, l2pc2%j, &
        & details, options=options, different=itsDifferent )
      if ( silent .and. itsDifferent ) &
        & call diff ( l2pc1%j, l2pc2%j, details, options=audible )
    endif

    if ( l2pc1%goth .and. dumpHessians ) &
      & call diff ( l2pc1%h, l2pc2%h, details, options=options )
    if ( present(different) ) different = different .or. itsDifferent
    if ( silent .and. .not. itsDifferent ) then
      call NameThoseBins
      call output( 'These L2PC bins do not differ', advance='yes' )
    endif
  contains
    subroutine NameThoseBins
      if ( l2pc1%name > 0 ) then
        call display_string ( l2pc1%name, before='name: ' )
        call output ( l2pc1%name, before=' (', after=')', advance='yes' )
      else
        call output( '*** Uh-oh, name not found in string table', advance='yes' )
      endif
      if ( l2pc2%name > 0 ) then
        call display_string ( l2pc2%name, before='name: ' )
        call output ( l2pc2%name, before=' (', after=')', advance='yes' )
      else
        call output( '*** Uh-oh, name not found in string table', advance='yes' )
      endif

    end subroutine NameThoseBins
  end subroutine DiffL2PCs

  ! --------------------------------------- DumpL2PCDatabase ---------------
  subroutine DumpL2PCDatabase ( L2pcDB, details, onlytheseblocks, options )
    ! This subroutine dumps an l2pc to stdout

    ! Dummy arguments
    type (l2pc_t), dimension(:), intent(in), target :: L2pcDB
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but size
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 0
    character(len=*), dimension(3), intent(in), optional :: ONLYTHESEBLOCKS ! passed to Vector and Matrix dumps
    character(len=*), intent(in), optional :: options ! any of {mh*b[]}
                                             ! m: dump only matrices
                                             ! h: dump only hessians
                                             ! v: dump only x*, y* vectors
                                             ! *: dump everything
                                             ! b[HCN]: dump only HCN blocks
                                             ! default is *
    ! Local variables
    integer :: i
    ! Executable
    do i=1, size(L2PCDB)
      call DumpOneL2PC( L2PCDB(i), details, ONLYTHESEBLOCKS, options )
    enddo
  end subroutine DumpL2PCDatabase

  ! --------------------------------------- DumpL2PCFile ---------------
  subroutine DumpL2PCFile ( L2PCFile, details, onlytheseblocks, options )
    ! This subroutine dumps an l2pc to stdout
    ! assuming it was read already

    ! Dummy arguments
    type (MLSFile_T), intent(inout) :: L2PCFile
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but size
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 0
    character(len=*), dimension(3), intent(in), optional :: ONLYTHESEBLOCKS ! passed to Vector and Matrix dumps
    character(len=*), intent(in), optional :: options ! any of {mh*b[]}
                                             ! r: read file before dumping
                                             ! m: dump only matrices
                                             ! h: dump only hessians
                                             ! v: dump only x*, y* vectors
                                             ! *: dump everything
                                             ! b[HCN]: dump only HCN blocks
                                             ! default is *
    ! Local variables
    integer :: i
    logical :: mustRead
    ! Executable
    mustRead = .false.
    if ( present(options) ) mustRead = (optionDetail(options, 'r' ) == 'yes' )
    if ( mustRead ) then
      call ReadCompleteHDF5L2PCFile ( L2PCFile, 0, shallow=.true. )
      do i=1, size(L2PCDataBase)
        if ( L2PCFile%FileID%f_id == fileIDDataBase(i) ) &
          & call PopulateL2PCBin( i )
      enddo
    endif
    call dumpMLSFile( L2PCFile, details=1 )
    call dump ( fileIDDataBase, 'file id database', format='(i10)' )
    do i=1, size(L2PCDataBase)
      if ( L2PCFile%FileID%f_id /= fileIDDataBase(i) ) cycle
      call newline
      call outputNamedValue( 'db index', i )
      call DumpOneL2PC( L2PCDataBase(i), details, onlytheseblocks, options )
    enddo
  end subroutine DumpL2PCFile

  ! --------------------------------------- DumpOneL2PC ---------------
  subroutine DumpOneL2PC ( L2pc, details, ONLYTHESEBLOCKS, options )
    ! This subroutine dumps an l2pc to stdout

    use hessianModule_1, only: dump, dump_layout
    use MatrixModule_1, only: dump_layout

    ! Dummy arguments
    type (l2pc_t), intent(in), target :: L2pc
    integer, intent(in), optional :: DETAILS ! passed to Vector and Matrix dumps
    character(len=*), dimension(3), intent(in), optional :: ONLYTHESEBLOCKS ! passed to Vector and Matrix dumps
    character(len=*), intent(in), optional :: options ! any of {Lmh*b[]d[]}
                                             ! L: Just show the top level layouts
                                             ! m: dump only matrices
                                             ! h: dump only hessians
                                             ! v: dump only x*, y* vectors
                                             ! *: dump everything
                                             ! b[HCN]: dump only HCN blocks
                                             ! d[dopts]: pass dopts when dumping arrays
                                             ! default is *
    ! Local variables
    logical :: dumpHessians
    logical :: dumpJacobians
    logical :: dumpVectors
    integer :: i
    logical :: LayoutOnly
    integer :: myDetails
    ! character(len=128) :: myMolecules

    ! Executable code
    myDetails = 0
    if ( present(details) ) myDetails = details
    dumpHessians = .true.
    dumpJacobians = .true.
    dumpVectors = .true.
    if ( present(options) ) then
      dumpHessians = optionDetail( options, 'h' ) == 'yes'
      dumpJacobians = optionDetail( options, 'm' ) == 'yes'
      dumpVectors = optionDetail( options, 'v' ) == 'yes'
      LayoutOnly = optionDetail( options, 'L' ) == 'yes'
    endif
    ! call outputNamedValue( 'myDetails', myDetails )
    call output( '- Dump of L2PC -', advance='yes' )
    if ( l2pc%name > 0 ) then
      call display_string ( l2pc%name, before='name: ' )
      call output ( l2pc%name, before=' (', after=')', advance='yes' )
    else
      call output( "(name not found in string table)", advance='yes' )
    endif
    ! First dump the xStar and yStar
    if ( dumpVectors ) then
      if ( LayoutOnly ) then
        call output ('Layout(xStar)', advance='yes' )
        do i=1, size(l2pc%j%col%vec%quantities)
          call display_string ( l2pc%j%col%vec%quantities(i)%template%name, &
          & strip=.true., advance='yes' )
        enddo
        call output ('Layout(yStar)', advance='yes' )
        do i=1, size(l2pc%j%row%vec%quantities)
          call display_string ( l2pc%j%row%vec%quantities(i)%template%name, &
          & strip=.true., advance='yes' )
        enddo
      else
        call dump ( l2pc%j%col%vec, details=details, name='xStar' )
        call dump ( l2pc%j%row%vec, details=details, name='yStar' )
      endif
    endif

    if ( dumpJacobians ) then
      ! Now dump kStar
      if ( LayoutOnly ) then
        call dump_layout( l2pc%j, 'kStar' )
      else
        call dump ( l2pc%j, 'kStar', details )
      endif
    endif

    ! Now dump the Hessian
    if ( l2pc%goth .and. dumpHessians ) then
      if ( layoutOnly ) then
        call dump_layout( l2pc%h, 'hStar' )
      else
        call dump ( l2pc%h, 'hStar', details, onlyTheseBlocks, options )
      endif
    endif
  end subroutine DumpOneL2PC

  ! --------------------------------------- DumpL2PCInfo ---------------
  subroutine DumpL2PCInfo ( L2PCInfo, details )
    ! This subroutine dumps an l2pc to stdout

    ! Dummy arguments
    type (L2PCInfo_T), intent(in) :: L2PCInfo
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but size
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 0
    ! Local variables
    integer :: myDetails
    ! Executable
    myDetails = 0
    if ( present(details) ) myDetails = details
    call outputNamedValue ( 'fileID', L2PCInfo%fileID )
    call outputNamedValue ( 'binID', L2PCInfo%binID )
    call outputNamedValue ( 'blocksID', L2PCInfo%blocksID )
    call outputNamedValue ( 'hblocksID', L2PCInfo%hBlocksID )
    call outputNamedValue ( 'matrixName', trim(L2PCInfo%matrixName) )
    if ( myDetails > 0 ) call dump( L2PCInfo%blockID, 'BlockID' )
  end subroutine DumpL2PCInfo

  ! ------------------------------------ FlushL2PCBins -------------
  subroutine FlushL2PCBins
    ! Local variables
    integer :: BIN              ! Loop counter
    integer :: BLOCKROW         ! Loop counter
    integer :: BLOCKCOL         ! Loop counter
    integer :: I, J, K

    type ( L2PC_T ), pointer          :: L2PC
    type ( MatrixElement_T), pointer  :: M0
    type ( HessianElement_T), pointer :: H0

    ! Executable code
    if ( .not. associated ( l2pcDatabase ) ) return
    do bin = 1, size ( l2pcDatabase )
      l2pc => l2pcDatabase ( bin )
      do blockRow = 1, l2pc%j%row%NB
        do blockCol = 1, l2pc%j%col%NB
          m0 => l2pc%j%block ( blockRow, blockCol )
          if ( m0%kind /= m_absent ) then
            call DestroyBlock ( m0 )
            m0%kind = M_Unknown
          end if
        end do
      end do
    end do
    if ( l2pc%goth ) then
      do i = 1, l2pc%h%row%NB
        do j = 1, l2pc%h%col%NB
          do k = 1, l2pc%h%col%NB
            h0 => l2pc%h%block(i,j,k)
            if ( h0%kind /= h_absent ) then
              call DestroyBlock ( h0 )
              h0%kind = h_unknown
            end if
          end do
        end do
      end do
    endif
  end subroutine FlushL2PCBins

  ! ---------------------------------- LoadHessian ----------
  subroutine LoadHessian ( Hessian, name, message )
    ! This function copies the Hessian from the l2pc database into the
    ! given Hessian (presumably from the main dabase)

    ! Dummy arguments
    type(Hessian_T), intent(inout) :: Hessian
    integer, intent(in) :: NAME
    character (len=*), intent(out) :: MESSAGE

    ! Local variables
    integer :: I                        ! Index
    type(Hessian_T), pointer :: SOURCE

    ! Executable code
    message = ''
    i = FindFirst ( l2pcDatabase%name, name )
    call outputNamedValue( 'l2pcdatabase names', l2pcDatabase%name )
    call outputNamedValue( 'bin name', name )
    call outputNamedValue( 'i', i )
    if ( i == 0 ) then
      message = 'No such l2pc Hessian with your name'
      call display_string( name, advance='yes' )
      return
    end if
    if ( .not. l2pcDatabase(i)%goth ) then
      message = 'This bin has no Hessian to copy'
      return
    endif
    call PopulateL2PCBin ( i, ignoreHessian=.false. )
    source => l2pcDatabase(i)%h
    if ( .not. DoVectorsMatch ( Hessian%row%vec, source%row%vec, verbose=.true. ) ) then
      message = 'Rows do not match for loading'
      call output( 'Hessian row vector', advance='yes' )
      call dump( Hessian%row%vec, details=0 )
      call output( 'source row vector', advance='yes' )
      call dump( source%row%vec, details=0 )
      return
    endif
    if ( .not. DoVectorsMatch ( Hessian%col%vec, source%col%vec ) ) then
      message = 'Columns do not match for loading'
      return
    endif
    call CopyHessianValue ( Hessian, source, allowNameMismatch=.true. )
  end subroutine LoadHessian

  ! ---------------------------------- LoadMatrix ----------
  subroutine LoadMatrix ( matrix, name, message, IgnoreHessian )
    ! This function copies from source in the l2pc database into a
    ! specified matrix
    ! It checks that they are compatible according to many criteria (too many?)

    ! Dummy arguments
    type(Matrix_T), intent(inout) :: MATRIX
    integer, intent(in) :: NAME
    character (len=*), intent(out) :: MESSAGE
    logical, intent(in), optional :: IgnoreHessian

    ! Local variables
    integer :: I                        ! Index
    type(Matrix_T), pointer :: SOURCE

    ! Executable code
    verbose = switchDetail( switches, 'l2pc') > -1
    message = ''
    i = FindFirst ( l2pcDatabase%name, name )
    call outputNamedValue( 'l2pcdatabase names', l2pcDatabase%name )
    call outputNamedValue( 'bin name', name )
    call outputNamedValue( 'i', i )
    if ( i == 0 ) then
      message = 'No such l2pc matrix'
      return
    end if
    call PopulateL2PCBin ( i, ignoreHessian )
    source => l2pcDatabase(i)%j
    if ( .not. DoVectorsMatch ( matrix%row%vec, source%row%vec, verbose ) ) then
      message = 'Rows do not match for loading'
      call output( 'matrix row vector', advance='yes' )
      call dump( matrix%row%vec, details=0 )
      call output( 'source row vector', advance='yes' )
      call dump( source%row%vec, details=0 )
      return
    endif
    if ( .not. DoVectorsMatch ( matrix%col%vec, source%col%vec, verbose ) ) then
      message = 'Columns do not match for loading'
      call output( 'matrix col vector', advance='yes' )
      call dump( matrix%col%vec, details=0 )
      call output( 'source col vector', advance='yes' )
      call dump( source%col%vec, details=0 )
      return
    endif
    call CopyMatrixValue ( matrix, source, allowNameMismatch=.true. )
  end subroutine LoadMatrix

  ! ---------------------------------- LoadVector ----------
  subroutine LoadVector ( vector, name, source, message, IgnoreHessian )
    ! This function copies the matrix from the l2pc database into the
    ! given matrix (presumably from the main dabase)

    ! Dummy arguments
    type(Vector_T), intent(inout) :: VECTOR
    integer, intent(in) :: NAME
    integer, intent(in) :: SOURCE       ! l_rows or l_columns
    character (len=*), intent(out) :: MESSAGE
    logical, intent(in), optional :: IgnoreHessian

    ! Local variables
    integer :: I                        ! Index
    type(Matrix_T), pointer :: MATRIX
    type(Vector_T), pointer :: SOURCEVECTOR

    ! Executable code
    message = ''
    i = FindFirst ( l2pcDatabase%name, name )
    if ( i == 0 ) then
      message = 'No such l2pc matrix'
      return
    end if
    call PopulateL2PCBin ( i, ignoreHessian )
    matrix => l2pcDatabase(i)%j
    select case ( source )
    case ( l_rows )
      sourceVector => matrix%row%vec
    case ( l_columns )
      sourceVector => matrix%col%vec
    end select
    if ( .not. DoVectorsMatch ( vector, sourceVector ) ) then
      message = 'Vector does not match for loading'
      return
    endif
    ! Use the clone option to avoid fussyness with vector templates
    call CopyVector ( vector, sourceVector, allowNameMismatch=.true. )
  end subroutine LoadVector

  ! --------------------------------------------- OutputHDF5L2PC
  subroutine OutputHDF5L2PC ( filename, matrices, hessians, &
    & quantitiesNode, secondDerivNode, packed, dontPack )
  use hdf5, only: h5fcreate_f, h5fclose_f, h5f_acc_trunc_f
  use MLSSTringLists, only: catLists
  use tree, only: sub_rosa
    character (len=*), intent(in) :: FILENAME
    type (Matrix_Database_T), dimension(:), pointer :: MATRICES
    type (Hessian_T), dimension(:), pointer :: HESSIANS
    integer, intent(in) :: QUANTITIESNODE
    integer, intent(in) :: SECONDDERIVNODE
    logical, intent(in) :: PACKED
    integer, dimension(:), pointer :: DONTPACK

    ! Local variables
    integer :: DB_INDEX                 ! Index of matrix
    integer :: FIELD                    ! Node index
    integer :: FILEID                   ! ID of file
    logical :: GOTH                     ! True if there is a Hessian
    logical :: GOTM                     ! True if there is a Jacobian
    integer :: J
    integer :: NXT_INDEX                ! Index of next matrix (Hessian?)
    integer :: STATUS                   ! From HDF
    integer :: THISMOLECULE
    character(len=32) :: moleculeName
    character(len=32), dimension(3) :: ONLYTHESEBLOCKS ! passed to Vector and Matrix dumps
    type (Matrix_T), pointer :: tmpMatrix
    type (Hessian_T), pointer :: tmpHessian

    ! Executable code
    call H5FCreate_F ( trim(filename), H5F_ACC_TRUNC_F, fileID, &
      & status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open hdf5 l2pc file for output.' )
    ONLYTHESEBLOCKS = '*'
    if ( SECONDDERIVNODE > 0 ) then
      ONLYTHESEBLOCKS(2) = ' '
      do j = 2, nsons(secondDerivNode)
        thisMolecule = decoration( subtree( j, secondDerivNode ) )
        call get_string( sub_rosa(thisMolecule), moleculeName )
        onlyTheseBlocks(2) = catLists( onlyTheseBlocks(2), thisMolecule )
      end do
      onlyTheseBlocks(3) = onlyTheseBlocks(2)
    endif
    nullify ( tmpMatrix, tmpHessian )
    field = 2
    do
      if ( field > nsons(quantitiesNode) ) exit
      db_index = decoration(decoration(subtree(field, quantitiesNode )))
      if ( associated(matrices) ) then
        call GetActualMatrixFromDatabase ( matrices(db_index), tmpMatrix )
        gotm = .true.
      endif
      goth = .false.
      if ( field < nsons(quantitiesNode) ) then
        nxt_index = decoration(decoration(subtree(field+1, quantitiesNode )))
        if ( nxt_index < 0 ) then
          tmpHessian => hessians ( -nxt_index )
          goth = .true.
          field = field + 1
        end if
      end if
      if ( goth ) then
        call writeOneHDF5L2PC ( tmpMatrix, fileID, packed, dontPack, &
          & hessian=tmpHessian, onlyTheseBlocks=onlyTheseBlocks )
      elseif ( gotm ) then
        call writeOneHDF5L2PC ( tmpMatrix, fileID, packed, dontPack )
      else
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Unable to write any Jacobians or Hessians to this l2pc file.' )
      end if
      field = field + 1
    end do ! Loop over fields
    call H5FClose_F ( fileID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
      & 'Unable to close hdf5 l2pc file.' )

  end subroutine OutputHDF5L2PC

  ! --------------------------------------- WriteOneHDF5L2PC -----------
  subroutine WriteOneHDF5L2PC ( JACOBIAN, fileID, packed, dontPack, &
    & hessian, onlyTheseBlocks )
    use hessianModule_0, only: optimizeBlock
    use HDF5, only: h5gclose_f, h5gcreate_f
    use MLSKinds, only: rm
    use MLSHdf5, only: makeHDF5Attribute, saveAsHDF5DS
    ! This subroutine writes an l2pc to a file in hdf5 format

    ! Dummy arguments
    type (matrix_T), intent(in), target :: JACOBIAN
    integer, intent(in) :: fileID
    logical, intent(in) :: PACKED
    integer, dimension(:), pointer :: DONTPACK
    type (Hessian_T), intent(in), optional :: HESSIAN
    character(len=*), dimension(3), intent(in), optional :: ONLYTHESEBLOCKS ! passed to Vector and Matrix dumps

    ! Local variables
    integer :: I, J, K                  ! Loop index (row, col, col)
    integer :: BlocksGID                ! ID of group containing all blocks
    integer :: BlockGID                 ! ID of this block group
    integer :: matrixID                 ! ID of hdf5 group containing matrix
    integer :: STATUS                   ! Error flag

    integer, dimension(jacobian%row%nb) :: ROWBLOCKMAP
    integer, dimension(jacobian%col%nb) :: COLBLOCKMAP
    logical, dimension(jacobian%row%vec%template%noQuantities), target :: ROWPACK
    logical, dimension(jacobian%col%vec%template%noQuantities), target :: COLPACK

    character ( len=32 ) :: NAME        ! A name for output

    type (MatrixElement_T), pointer :: M0 ! A Matrix_0 within kStar
    type (HessianElement_T), pointer :: H0 ! A Hessian_0 within hStar
    logical :: verbose

    ! Executable code
    verbose = ( switchDetail(switches, 'hess') > -1 ) .or. DEEBUG
    ! If we have a Hessian, make sure it matches the jacobian
    if ( present ( hessian ) ) then
      if ( jacobian%row%vec%name /= hessian%row%vec%name ) call MLSMessage ( &
        & MLSMSG_Error, ModuleName, 'Rows of Jacobian and Hessian do not match' )
      if ( jacobian%col%vec%name /= hessian%col%vec%name ) call MLSMessage ( &
        & MLSMSG_Error, ModuleName, 'Columns of Jacobian and Hessian do not match' )
      if ( jacobian%row%instFirst .neqv. hessian%row%instFirst ) call MLSMessage ( &
        & MLSMSG_Error, ModuleName, 'Row order of Jacobian and Hessian do not match' )
      if ( jacobian%col%instFirst .neqv. hessian%col%instFirst ) call MLSMessage ( &
        & MLSMSG_Error, ModuleName, 'Column order of Jacobian and Hessian do not match' )
      if ( verbose ) then
        call get_string ( hessian%name, name, strip=.true., cap=.true. )
        call output( 'Writing Hessian named: ' // trim(name), advance='yes' )
        call outputNamedValue( 'Hesssian optimized already', hessian%optimizedAlready )
      endif
    end if

    ! Work out which quantities we can skip
    if ( packed ) then
      call MakeMatrixPackMap ( jacobian, rowPack, colPack, rowBlockMap, colBlockMap, dontPack, hessian )
    else
      rowPack = .true.
      colPack = .true.
      do i = 1, jacobian%row%nb
        rowBlockMap(i) = i
      end do
      do j = 1, jacobian%col%nb
        colBlockMap(j) = j
      end do
    end if

    ! First create the group for this.
    call get_string ( jacobian%name, name, strip=.true., cap=.true. )
    call h5gCreate_f ( fileID, trim(name), matrixID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create group for l2pc matrix' )

    ! Now dump the vectors
    call WriteVectorAsHDF5L2PC ( matrixID, jacobian%col%vec, 'Columns', colPack )
    call WriteVectorAsHDF5L2PC ( matrixID, jacobian%row%vec, 'Rows', rowPack )

    ! Now create a group for the blocks
    call h5gCreate_f ( matrixID, 'Blocks', blocksGID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create group for all l2pc matrix blocks' )

    ! Make the flags
    call MakeHDF5Attribute ( blocksGID, 'rowInstanceFirst', jacobian%row%instFirst )
    call MakeHDF5Attribute ( blocksGID, 'colInstanceFirst', jacobian%col%instFirst )

    ! Now loop over the blocks and write them.
    do i = 1, jacobian%row%NB
      do j = 1, jacobian%col%NB
        ! Do we write this block?
        if ( rowPack(jacobian%row%quant(i)) .and. &
          &  colPack(jacobian%col%quant(j)) ) then
          ! Identify the block
          m0 => jacobian%block(i, j)
          ! Get a name for this group for the block
          ! write ( name, * ) 'Block', rowBlockMap(i), colBlockMap(j)
          call CreateBlockName ( rowBlockMap(i), colBlockMap(j), 0, name )
          ! Create a grop for this block
          call h5gCreate_f ( blocksGID, trim(name), blockGID, status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to create group for jacobian matrix block' )
          ! Stick some attributes on it
          call get_string ( &
            & jacobian%row%vec%quantities(&
            &    jacobian%row%quant(i))%template%name, name )
          call MakeHDF5Attribute ( blockGID, 'rowQuantity', trim(name) )
          call get_string ( &
            & jacobian%col%vec%quantities(&
            &    jacobian%col%quant(j))%template%name, name )
          call MakeHDF5Attribute ( blockGID, 'colQuantity', trim(name) )
          call MakeHDF5Attribute ( blockGID, 'rowInstance', jacobian%row%inst(i) )
          call MakeHDF5Attribute ( blockGID, 'colInstance', jacobian%col%inst(j) )
          call MakeHDF5Attribute ( blockGID, 'kind', m0%kind )
          ! Write the datasets
          if ( m0%kind /= m_absent ) then
            call SaveAsHDF5DS ( blockGID, 'values', real ( m0%values, r4 ) )
            if ( m0%kind /= m_full ) then
              call MakeHDF5Attribute ( blockGID, 'noValues', size(m0%values) )
              call SaveAsHDF5DS ( blockGID, 'r1', m0%r1 )
              call SaveAsHDF5DS ( blockGID, 'r2', m0%r2 )
            end if                      ! Not sparse or banded
          end if                        ! Not absent
          ! Close group for block
          call h5gClose_f ( blockGID, status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to close group for l2pc matrix block' )
        end if                          ! Do this block
      end do
    end do

    ! Now close blocks group
    call h5gClose_f ( blocksGID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close qroup for all l2pc matrix blocks' )

    ! Create a group for the Hessian blocks if any
    if ( present ( hessian ) ) then
      call h5gCreate_f ( matrixID, 'HessianBlocks', blocksGID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create group for all l2pc matrix hessian blocks' )

      ! Make the flags
      call MakeHDF5Attribute ( blocksGID, 'rowInstanceFirst', hessian%row%instFirst )
      call MakeHDF5Attribute ( blocksGID, 'colInstanceFirst', hessian%col%instFirst )

      ! Now loop over the blocks and write them.
      do i = 1, hessian%row%NB
        do j = 1, hessian%col%NB
          do k = 1, hessian%col%NB
            ! Do we write this block?
            if ( rowPack(hessian%row%quant(i)) .and. &
              &  colPack(hessian%col%quant(j)) .and. &
              &  colPack(hessian%col%quant(k)) ) then
              ! Identify the block
              h0 => hessian%block ( i, j, k )
              if ( verbose ) then
                call outputNamedValue( 'block optimized already?', h0%optimizedAlready )
              endif
              call optimizeBlock ( h0 )
              ! Change kind of Hessian to absent if number of nonzero values is 0
              if ( h0%kind == h_sparse .and. &
                & (h0%tuplesFilled < 1 .or. .not. associated(h0%tuples) ) &
                & ) &
                & h0%kind = h_absent
              if ( h0%kind == h_full ) then
                if ( associated(h0%values) ) then
                  if ( count(h0%values /= 0._rm) < 1 ) h0%kind = h_absent
                else
                  h0%kind = h_absent
                endif
              endif
              ! Get a name for this group for the block
              call CreateBlockName ( rowBlockMap(i), colBlockMap(j), colBlockMap(k), name )
              if ( switchDetail( switches, 'hess' ) > -1 ) &
                & call outputNamedValue( 'Block name', trim(name) )
              ! Create a group for this block
              call h5gCreate_f ( blocksGID, trim(name), blockGID, status )
              if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Unable to create group for hessian matrix block' )
              ! Stick some attributes on it
              ! Row name
              call get_string ( &
                & hessian%row%vec%quantities(&
                &    hessian%row%quant(i))%template%name, name )
              call MakeHDF5Attribute ( blockGID, 'rowQuantity', trim(name) )
              call MakeHDF5Attribute ( blockGID, 'rowInstance', hessian%row%inst(i) )
              if ( switchDetail( switches, 'hess' ) > -1 ) &
                & call outputNamedValue( 'Row name', trim(name) )
              ! First column name
              call get_string ( &
                & hessian%col%vec%quantities(&
                &    hessian%col%quant(j))%template%name, name )
              call MakeHDF5Attribute ( blockGID, 'col1Quantity', trim(name) )
              call MakeHDF5Attribute ( blockGID, 'col1Instance', hessian%col%inst(j) )
              if ( switchDetail( switches, 'hess' ) > -1 ) &
                & call outputNamedValue( '1st column name', trim(name) )
              ! Second column name
              call get_string ( &
                & hessian%col%vec%quantities(&
                &    hessian%col%quant(k))%template%name, name )
              call MakeHDF5Attribute ( blockGID, 'col2Quantity', trim(name) )
              call MakeHDF5Attribute ( blockGID, 'col2Instance', hessian%col%inst(j) )

              call MakeHDF5Attribute ( blockGID, 'kind', h0%kind )
              if ( switchDetail( switches, 'hess' ) > -1 ) &
                & call outputNamedValue( '2nd column name', trim(name) )
              ! Write the datasets
              select case ( h0%kind )
              case ( h_full )
                call SaveAsHDF5DS ( blockGID, 'values', real ( h0%values, r4 ) )
              case ( h_sparse )
                call MakeHDF5Attribute ( blockGID, 'noValues', h0%tuplesFilled )
                call SaveAsHDF5DS ( blockGID, 'i', h0%tuples(1:h0%tuplesFilled)%i )
                call SaveAsHDF5DS ( blockGID, 'j', h0%tuples(1:h0%tuplesFilled)%j )
                call SaveAsHDF5DS ( blockGID, 'k', h0%tuples(1:h0%tuplesFilled)%k )
                call SaveAsHDF5DS ( blockGID, 'h', h0%tuples(1:h0%tuplesFilled)%h )
                if ( switchDetail( switches, 'hess' ) > 0 ) then
                  call outputNamedValue( 'noValues', h0%tuplesFilled )
                  call dump( h0%tuples(1:h0%tuplesFilled)%h, 'h)%tuple values' )
                end if
              end select
              ! Close group for block
              call h5gClose_f ( blockGID, status )
              if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Unable to close group for l2pc matrix block' )
            end if                          ! Do this block
          end do
        end do
      end do

      ! Now close blocks group
      call h5gClose_f ( blocksGID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close qroup for all l2pc matrix blocks' )
    end if

    ! Close matrix group
    call h5gClose_f ( matrixID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close group for l2pc matrix' ) 
 end subroutine WriteOneHDF5L2PC

  ! ======================================= PRIVATE PROCEDURES ====================

  ! ------------------------------------ AddL2PCInfoToDatabase --
  integer function AddL2PCInfoToDatabase ( database, item )

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    type (L2PCInfo_T), dimension(:), pointer :: DATABASE
    type (L2PCInfo_T) :: item
    ! Local variables
    type (L2PCInfo_T), dimension(:), pointer :: TEMPDATABASE

    include "addItemToDatabase.f9h"
    AddL2PCInfoToDatabase = newSize
  end function AddL2PCInfoToDatabase

  ! ------------------------------------ DestroyL2PCInfoDatabase ----
  subroutine DestroyL2PCInfoDatabase

    use Allocate_Deallocate, only: Test_Deallocate
    use HDF5, only: H5FClose_f, H5GClose_f, H5ESet_Auto_f
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    ! Local variables
    integer(c_intptr_t) :: Addr ! For tracing
    integer :: I                ! Loop counter
    integer :: S                ! Size in bytes of an object to deallocate
    integer :: STATUS           ! Flag from HDF

    ! Executable code
    verbose = switchDetail( switches, 'l2pc') > -1
    if ( .not. associated(l2pcInfo) ) then
      if ( verbose ) &
        & call output( 'l2pcinfo database empty' )
      return
    endif
    call h5eSet_auto_f ( 0, status )
    do i = 1, size ( l2pcInfo )
      if ( verbose ) &
        & call outputNamedValue( 'Destroying l2pcinfo db entry number ', i )
      call h5gClose_f ( l2pcInfo(i)%blocksID, status )
      if ( status /= 0 .and. DIEIFDESTROYFAILS ) then
        call dump_private( l2pcInfo(i) )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close Blocks group for preserved input l2pc' )
      endif
      if ( l2pcInfo(i)%hblocksID /= 0 ) then
        call h5gClose_f ( l2pcInfo(i)%hblocksID, status )
        if ( status /= 0 .and. DIEIFDESTROYFAILS ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to close Hessian Blocks group for preserved input l2pc' )
      end if
      call h5gClose_f ( l2pcInfo(i)%binID, status )
      if ( status /= 0 .and. DIEIFDESTROYFAILS ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close matrix group for preserved input l2pc' )
      ! Close the file?
      if ( count ( l2pcInfo%fileID == l2pcInfo(i)%fileID ) == 1 .and. &
        & all(l2pcInfo%fileID > 0 ) ) then
        ! We're the only one (left?) with this file, close it.
        if ( verbose ) &
          & call outputNamedValue('Closing hdf5 fileID', l2pcInfo(i)%fileID )
        call h5fClose_f ( l2pcInfo(i)%fileID, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to close hdf5 preserved input l2pc file' )
      end if
      l2pcInfo(i)%fileID = 0
    end do
    call h5eSet_auto_f ( 1, status )
    s = size(l2pcInfo) * storage_size(l2pcInfo) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(l2pcInfo(1)), addr)
    deallocate ( l2pcInfo, stat=i )
    call test_deallocate ( i, ModuleName, 'l2pcInfo', s, address=addr )

  end subroutine DestroyL2PCInfoDatabase

  ! ----------------------------------- MakeMatrixPackMap -----------
  subroutine MakeMatrixPackMap ( j, rowPack, colPack, rowBlockMap, colBlockMap, dontpack, h )
    ! This subroutine fills the boolean arrays rowPack, colPack
    ! (each length row/col%noQuantities) with a flag set true
    ! if the quantity has any derivatives at all

    ! Dummy arguments
    type (Matrix_t), intent(in) :: J
    logical, intent(out), dimension(J%row%vec%template%noQuantities) :: ROWPACK
    logical, intent(out), dimension(J%col%vec%template%noQuantities) :: COLPACK
    integer, intent(out), dimension(J%row%NB) :: ROWBLOCKMAP
    integer, intent(out), dimension(J%col%NB) :: COLBLOCKMAP
    integer, dimension(:), pointer :: DONTPACK ! Quantities not to pack
    type (Hessian_T), intent(in), optional :: H ! A hessian to consider also

    ! Local variables
    integer :: ROWQ                     ! Loop counter
    integer :: COLQ                     ! Loop counter
    integer :: COLQ1                    ! Loop counter
    integer :: COLQ2                    ! Loop counter
    integer :: ROWI                     ! Loop counter
    integer :: COLI                     ! Loop counter
    integer :: COLI1                    ! Loop counter
    integer :: COLI2                    ! Loop counter
    integer :: ROWBLOCK                 ! Block index
    integer :: COLBLOCK                 ! Block index
    integer :: COLBLOCK1                ! Block index
    integer :: COLBLOCK2                ! Block index
    logical, dimension(J%row%NB) :: ROWBLOCKFLAG ! Flags per row block
    logical, dimension(J%col%NB) :: COLBLOCKFLAG ! Flags per row block

    ! Executable code
    rowPack = .false.
    colPack = .false.

    ! Do a nested loop over cols/rows
    ! I tried to be fancy with cycles etc. but the code got really messy.
    ! This simple approach is probably the clearest.
    do rowQ = 1, j%row%vec%template%noQuantities
      do rowI = 1, j%row%vec%quantities(rowQ)%template%noInstances
        rowBlock = FindBlock ( j%row, rowQ, rowI )
        do colQ = 1, j%col%vec%template%noQuantities
          do colI = 1, j%col%vec%quantities(colQ)%template%noInstances
            colBlock = FindBlock ( j%col, colQ, colI )
            if ( j%block ( rowBlock, colBlock ) % kind /= M_Absent ) then
              rowPack ( rowQ ) = .true.
              colPack ( colQ ) = .true.
            end if
          end do
        end do
      end do
    end do

    ! Do the same thing for any hessian supplied
    if ( present ( h ) ) then
      do rowQ = 1, h%row%vec%template%noQuantities
        do rowI = 1, h%row%vec%quantities(rowQ)%template%noInstances
          rowBlock = FindBlock ( h%row, rowQ, rowI )
          do colQ1 = 1, h%col%vec%template%noQuantities
            do colI1 = 1, h%col%vec%quantities(colQ1)%template%noInstances
              colBlock1 = FindBlock ( h%col, colQ1, colI1 )
              do colQ2 = 1, h%col%vec%template%noQuantities
                do colI2 = 1, h%col%vec%quantities(colQ2)%template%noInstances
                  colBlock2 = FindBlock ( h%col, colQ2, colI2 )
                  if ( h%block ( rowBlock, colBlock1, colBlock2 ) % kind /= H_Absent ) then
                    rowPack ( rowQ ) = .true.
                    colPack ( colQ1 ) = .true.
                    colPack ( colQ2 ) = .true.
                  end if
                end do
              end do
            end do
          end do
        end do
      end do
    end if

    ! Go back and set to true any we know we want to keep
    if ( associated ( dontPack ) ) then
      do colQ = 1, j%col%vec%template%noQuantities
        if ( any ( dontPack == j%col%vec%template%quantities(colQ) ) ) &
          & colPack ( colQ ) = .true.
      end do
      do rowQ = 1, j%row%vec%template%noQuantities
        if ( any ( dontPack == j%row%vec%template%quantities(rowQ) ) ) &
          & rowPack ( rowQ ) = .true.
      end do
    end if

    ! Now work out the block mappings
    rowBlockFlag = rowPack ( j%row%quant )
    do rowBlock = 1, j%row%nb
      rowBlockMap ( rowBlock ) = count ( rowBlockFlag ( 1:rowBlock ) )
    end do
    colBlockFlag = colPack ( j%col%quant )
    do colBlock = 1, j%col%nb
      colBlockMap ( colBlock ) = count ( colBlockFlag ( 1:colBlock ) )
    end do

  end subroutine MakeMatrixPackMap

  ! --------------------------------------- PopulateL2PCBinByName ---
  subroutine PopulateL2PCBinByName ( name, IgnoreHessian )
    integer, intent(in) :: NAME         ! Name index
    logical, intent(in), optional :: IgnoreHessian
    integer :: INDEX
    ! Executable code
    index = FindFirst ( l2pcDatabase%name, name )
    if ( index /= 0 ) call PopulateL2PCBin ( index, ignoreHessian )
  end subroutine PopulateL2PCBinByName

  ! --------------------------------------- Populate L2PCBin --------
  subroutine PopulateL2PCBin ( bin, IgnoreHessian )
    use HDF5, only: hsize_t, h5gclose_f, h5gopen_f, h5gget_obj_info_idx_f, &
        & h5gn_members_f
    use MLSHDF5, only: getHDF5Attribute, getHDF5DSDims, loadFromHDF5DS

    integer, intent(in) :: BIN ! The bin index to populate
    logical, intent(in), optional :: IgnoreHessian

    ! Local variables
    type(L2pc_t), pointer :: L2PC  ! This l2pc
    type(L2PCInfo_T), pointer :: INFO ! Info for this l2pc
    type(HessianElement_T), pointer :: H0 
    type(MatrixElement_T), pointer :: M0 
    integer :: BLOCKCOL  ! Loop counter
    character ( len=64 ) :: NAME ! Name of a block
    integer :: BLOCKID   ! Group ID for a block
    integer :: BLOCKLAYER  ! Loop counter
    integer :: BLOCKROW  ! Loop counter
    integer :: BLOCKSID  ! Group ID for all the (non-)Hessian blocks
    integer, dimension(3) :: DIMS
    integer(kind=hSize_t), dimension(3) :: HDIMS ! dimensions for l2pc%h%values
    integer :: KIND      ! Kind for this block
    logical :: NoHessian ! Don't try to get the Hessian
    integer :: NOVALUES  ! Number of values for this block
    integer :: STATUS    ! Flag from HDF5
    integer :: i, nmembers, objtype
    ! Executable code
    verbose = switchDetail( switches, 'l2pc') > -1
    verboser = switchDetail( switches, 'l2pc' ) > 0
    l2pc => l2pcDatabase ( bin )
    if ( verbose ) then
      call output( 'Populating l2pc', advance='yes' )
      call outputNamedValue( 'size(l2pcDatabase)', size(l2pcDatabase) )
      call outputNamedValue( 'size(l2pcInfo)', size(l2pcInfo) )
      call outputNamedValue( 'm_unknown', m_unknown )
      call dump( l2pc%j%block%kind, 'l2pc%j%block%kind' )
      call outputNamedValue( 'any ( l2pc%j%block%kind == m_unknown )', any ( l2pc%j%block%kind == m_unknown ) )
    endif
    if ( .not. any ( l2pc%j%block%kind == m_unknown ) ) return
    info => l2pcInfo ( bin )

    call h5gn_members_f( info%binID, 'Blocks', nmembers, status )
    if ( verbose ) then
      call outputNamedValue ( 'nmembers under ' // 'Blocks', nmembers )
      do i=0, nmembers-1
        call h5gget_obj_info_idx_f( info%binID, 'Blocks', i, &
                                           name, objtype, status )
        call outputNamedValue ( 'member name: ', trim(name) )
      enddo
    endif

    call h5gOpen_f ( info%binId, 'Blocks', blocksId, status )
    if ( status /= 0 ) then
      call outputNamedValue( 'binID', info%binID )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open Blocks group for l2pc matrix block '//&
        & trim(info%matrixName) )
    endif
    do blockRow = 1, l2pc%j%row%NB
      do blockCol = 1, l2pc%j%col%NB
        ! Skip blocks we know about or are absent
        m0 => l2pc%j%block ( blockRow, blockCol )
        if ( m0%kind /= m_unknown ) cycle
        ! Access this block
        ! write ( name, * ) 'Block', blockRow, blockCol
        call CreateBlockName ( blockRow, blockCol, 0, name )
        ! This doesn't work any more (Why not?)
        ! call h5gOpen_f ( info%blocksId, trim(name), blockId, status )
        info%blocksId = blocksID ! When did these diverge?
        call h5gOpen_f ( blocksId, trim(name), blockId, status )
        if ( status /= 0 ) then
          call outputNamedValue( 'Block name', trim(name) )
          call outputNamedValue( 'Blocks ID', info%blocksId )
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to open group for l2pc matrix block '//trim(name) )
        elseif ( verboser ) then
          call outputNamedValue( 'Block name', trim(name) )
          call outputNamedValue( 'Blocks ID', info%blocksId )
          call outputNamedValue( 'Block ID', blockId )
        endif
        ! Get kind of block
        call GetHDF5Attribute ( blockID, 'kind', kind )

        ! Read the block
        if ( kind == m_banded .or. kind == m_column_sparse ) then
          call GetHDF5Attribute ( blockID, 'noValues', noValues )
          call CreateBlock ( l2pc%j, blockRow, blockCol, kind, noValues )
          m0 => l2pc%j%block ( blockRow, blockCol )
          call LoadFromHDF5DS ( blockId, 'r1', m0%r1 )
          call LoadFromHDF5DS ( blockId, 'r2', m0%r2 )
        else
          call CreateBlock ( l2pc%j, blockRow, blockCol, kind )
          m0 => l2pc%j%block ( blockRow, blockCol )
        end if
        if ( kind /= m_absent ) &
          call LoadFromHDF5DS ( blockID, 'values', m0%values )
        call h5gClose_f ( blockId, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to close group for l2pc matrix block '//trim(name) )
      end do
    end do
    call h5gClose_f ( blocksId, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close Blocks group for l2pc matrix '//trim(info%matrixName) )

    noHessian = .false. ! Assume we want the Hessian
    if ( present(ignoreHessian) ) noHessian = ignoreHessian
    if ( l2pc%goth .and. .not. noHessian ) then
      call h5gOpen_f ( info%binId, 'HessianBlocks', blocksId, status )
      if ( status /= 0 ) then
        call outputNamedValue( 'binID', info%binID )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to open HessianBlocks group for l2pc matrix block '//&
          & trim(info%matrixName) )
      endif
      ! Now loop over the blocks and read them.
      do blockRow = 1, l2pc%h%row%NB
        do blockCol = 1, l2pc%h%col%NB
          do blockLayer = 1, l2pc%h%col%NB
            ! Skip blocks we know about or are absent
            h0 => l2pc%h%block ( blockRow, blockCol, blockLayer )
            if ( h0%kind /= h_unknown ) cycle
            call CreateBlockName ( blockRow, blockCol, blockLayer, name )
            call h5gOpen_f ( blocksId, trim(name), blockId, status )
            if ( status /= 0 ) then
              call outputNamedValue( 'Block name', trim(name) )
              call outputNamedValue( 'Blocks ID', blocksId )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Unable to open group for l2pc Hessian block '//trim(name) )
            elseif ( verboser ) then
              call outputNamedValue( 'Block name', trim(name) )
              call outputNamedValue( 'Block ID', blockId )
              call outputNamedValue( 'HessianBlocks ID', blocksId )
            endif
            call GetHDF5Attribute ( blockID, 'kind', kind )
            if ( DEEBUG .or. verboser ) &
              & call outputNamedValue( 'kind', kind )
            select case (kind)
            case (h_absent)
              call CreateBlock ( l2pc%h, blockRow, blockCol, blockLayer, kind )
              h0 => l2pc%h%block ( blockRow, blockCol, blockLayer )
              ! call LoadFromHDF5DS ( blockId, 'i', h0%values )
            case (h_full)
              call CreateBlock ( l2pc%h, blockRow, blockCol, blockLayer, kind )
              h0 => l2pc%h%block ( blockRow, blockCol, blockLayer )
              if ( any(shape(h0%values) == 0) ) then
                call GetHDF5DSDims ( blockId, 'values', HDIMS )
                dims = hdims
                call DeAllocate_test ( h0%values, &
                  & 'h0%values', moduleName // 'PopulateOneL2PC' )
                call Allocate_test ( h0%values, dims(1), dims(2), dims(3),&
                  & 'h0%values', moduleName // 'PopulateOneL2PC' )
              endif
              call LoadFromHDF5DS ( blockId, 'values', h0%values )
            case (h_sparse)
              call GetHDF5Attribute ( blockID, 'noValues', noValues )
              if ( DEEBUG ) call outputNamedValue( 'noValues', noValues )
              call CreateBlock ( l2pc%h, blockRow, blockCol, blockLayer, kind, noValues )
              h0 => l2pc%h%block ( blockRow, blockCol, blockLayer )
              call LoadFromHDF5DS ( blockId, 'i', h0%tuples(1:h0%tuplesFilled)%i )
              call LoadFromHDF5DS ( blockId, 'j', h0%tuples(1:h0%tuplesFilled)%j )
              call LoadFromHDF5DS ( blockId, 'k', h0%tuples(1:h0%tuplesFilled)%k )
              call LoadFromHDF5DS ( blockId, 'h', h0%tuples(1:h0%tuplesFilled)%h )
            case default
              call outputNamedValue( 'h_full', h_full )
              call outputNamedValue( 'h_sparse', h_sparse )
              call outputNamedValue( 'h_unknown', h_unknown )
              call outputNamedValue( 'kind', kind )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Unexpected kind for l2pc Hessian block '//trim(name) )
            end select
            call h5gClose_f ( blockId, status )
            if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unable to close group for l2pc Hessian matrix block '//trim(name) )
          end do
        end do
      end do
      call h5gClose_f ( blocksId, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close HessianBlocks group for l2pc matrix '//trim(info%matrixName) )
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & 'Fully populating L2PC Bin when we have a Hessian matrix is untested' )
      !!! stop !!! CODE HERE
    endif

    if ( switchdetail ( switches, 'spa' ) > -1 ) call dump_struct ( l2pc%j, 'Populated l2pc bin' )

  end subroutine PopulateL2PCBin

  ! --------------------------------------- ReadCompleteHDF5L2PCFile -------
  subroutine ReadCompleteHDF5L2PCFile ( MLSFile, Where, Shallow )
    use HDF, only: DFAcc_rdonly
    use HDF5, only: H5GN_Members_f
    use intrinsic, only: l_hdf
    use MLSFiles, only: HDFVersion_5, MLS_Openfile
    use Trace_M, only: trace_begin, trace_end
    use Toggles, only: toggle, gen
    type (MLSFile_T), intent(inout)   :: MLSFile
    integer, intent(in) :: Where ! In the L2CF tree, for tracing
    logical, optional   :: Shallow
    ! character (len=*), intent(in) :: FILENAME

    ! Local variables
    integer :: BIN             ! Loop counter
    integer :: DUMMY           ! Ignored return from AddToDatabase
    integer :: FILEID          ! From hdf5
    type (L2PCInfo_T) :: INFO  ! Info for one bin
    type (L2pc_t) :: L2PC      ! The l2pc read from one bin
    integer :: Me = -1         ! String index for trace
    logical :: MYSHALLOW       ! Value of shallow
    integer :: NOBINS          ! Number of bins
    integer :: STATUS          ! Flag from HDF5

    ! Executable code
    verbose = switchDetail( switches, 'l2pc') > -1
    if ( verbose ) &
      & call output ( 'Reading complete l2pc file ', advance='yes' )
    myShallow = .true.
    if ( present ( shallow ) ) myShallow = shallow

    call trace_begin ( me, "ReadCompleteHDF5L2PCFile", where, cond=toggle (gen) )
    MLSFile%content = 'l2pc'
    MLSFile%access = DFACC_RDONLY
    MLSFile%HDFVersion = HDFVERSION_5
    MLSFile%type = l_hdf
    status = 0
    if ( .not. MLSFile%stillOpen ) call mls_openFile( MLSFile, status )
    fileID = MLSFile%FileID%f_id
    ! call h5fopen_f ( MLSFile%name, H5F_ACC_RDONLY_F, fileID, status )
    ! MLSFile%FileID%f_id = fileID
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open hdf5 l2pc file for input:'//trim(MLSFile%name), &
      & MLSFile=MLSFile )

    ! Get the number of bins
    call h5gn_members_f ( fileID, '/', noBins, status ) 
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get number of bins from input l2pc file:'//trim(MLSFile%name), &
      & MLSFile=MLSFile )

    if ( verbose ) then
      call output ( 'Reading l2pc ' )
      call output ( trim(MLSFile%name), advance='yes' )
      call output ( 'Number of bins: ' )
      call output ( noBins, advance='yes' )
    endif

    ! Don't forget HDF5 numbers things from zero
    do bin = 0, noBins-1
      call ReadOneHDF5L2PCRecord ( L2PC, MLSFile, bin, &
        & shallow=myShallow, info=Info )
      dummy = AddL2PCToDatabase ( l2pcDatabase, L2PC )
      dummy = AddFileIDToDatabase ( fileIDDatabase, MLSFile%fileID%f_id )
      if ( switchDetail ( switches, 'spa' ) > -1 ) call Dump_struct ( l2pc%j, 'One l2pc bin' ) 

      ! Now nullify the pointers in l2pc so we don't clobber the one we've written
      nullify ( l2pc%j%block )
      nullify ( l2pc%j%row%nelts, l2pc%j%row%inst, l2pc%j%row%quant )
      nullify ( l2pc%j%col%nelts, l2pc%j%col%inst, l2pc%j%col%quant )
      nullify ( l2pc%j%row%vec%template%quantities, l2pc%j%col%vec%template%quantities )
      nullify ( l2pc%j%row%vec%quantities, l2pc%j%col%vec%quantities )

      nullify ( l2pc%h%block )
      nullify ( l2pc%h%row%nelts, l2pc%h%row%inst, l2pc%h%row%quant )
      nullify ( l2pc%h%col%nelts, l2pc%h%col%inst, l2pc%h%col%quant )
      nullify ( l2pc%h%row%vec%template%quantities, l2pc%h%col%vec%template%quantities )
      nullify ( l2pc%h%row%vec%quantities, l2pc%h%col%vec%quantities )
      dummy = AddL2PCInfoToDatabase ( l2pcInfo, Info )
    end do

    ! Don't close the file, we're keeping it open to read blocks from it later
    call trace_end ( "ReadCompleteHDF5L2PCFile", cond=toggle (gen) )
  end subroutine ReadCompleteHDF5L2PCFile

  ! --------------------------------------- ReadOneHDF5L2PCRecord ------------
  subroutine ReadOneHDF5L2PCRecord ( l2pc, MLSFile, l2pcIndex, shallow, info )
    use HDF5, only: H5GClose_f, h5gopen_f, h5gget_obj_info_idx_f, &
      & h5gn_members_f
    use MLSHDF5, only: GetHDF5Attribute, loadFromHDF5DS
    type ( L2pc_t ), intent(out), target :: L2PC
    type (MLSFile_T), intent(inout)   :: MLSFile
    ! integer, intent(in) :: FILEID       ! HDF5 ID of input file
    integer, intent(in) :: L2PCINDEX        ! Index of l2pc entry to read
    logical, optional, intent(in) :: SHALLOW ! Don't read blocks
    type(L2PCInfo_T), intent(out), optional :: INFO ! Information output

    ! Local variables
    integer :: BLOCKID                  ! Id of block group (one block at a time)
    integer :: BLOCKSID                 ! Id of blocks group
    integer :: HBLOCKSID                ! Id of HessianBlocks group
    integer :: I, J, K                  ! Block loop indices
    integer :: KIND                     ! Kind of block (absent, etc.)
    integer :: MATRIXID                 ! HDF5 for matrix group
    integer :: NMEMBERS
    integer :: NOVALUES                 ! For banded or column sparse cases
    integer :: OBJTYPE                  ! From HDF5
    integer :: STATUS                   ! Flag from HDF5
    integer :: STRINGINDEX              ! Index of string
    integer :: XSTAR                    ! Linearisation state vector index
    integer :: YSTAR                    ! Radiances for xStar vector index

    logical :: COLINSTANCEFIRST         ! Flag for matrix
    logical :: ROWINSTANCEFIRST         ! Flag for matrix
    logical :: MYSHALLOW                ! Value of shallow

    type (MatrixElement_T), pointer :: M0 ! A Matrix block within kStar
    type (HessianElement_T), pointer :: H0 ! A Hessian block within kStar
    character ( len=64 ) :: MATRIXNAME  ! Name for matrix
    character ( len=64 ) :: NAME        ! Name for block group


    ! Executable code
    verbose = switchDetail( switches, 'l2pc') > -1
    verboser = switchDetail( switches, 'l2pc' ) > 0
    myShallow = .false.
    if ( present ( shallow ) ) myShallow = shallow

    if ( verbose ) &
      & call output ( 'Reading bin from l2pc file', advance='yes' )

    call h5gGet_obj_info_idx_f ( MLSFile%fileID%f_id, '/', l2pcIndex, matrixName, &
      & objType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get information on matrix in input l2pc file', &
      & MLSFile=MLSFile )
    if ( verbose ) &
      & call outputNamedValue ( 'Reading matrix', matrixName )
    call h5gOpen_f ( MLSFile%fileID%f_id, trim(matrixName), matrixId, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open matrix in input l2pc file' , &
      & MLSFile=MLSFile )
    ! Read the row and column vectors
    MLSFile%fileID%grp_id = matrixId
    call ReadOneVectorFromHDF5 ( MLSFile, 'Columns', xStar )
    call ReadOneVectorFromHDF5 ( MLSFile, 'Rows', yStar )
    if ( verbose ) then
      call output( 'x* vector', advance='yes' )
      call dump( L2PCVS(xStar) )
      call output( 'y* vector', advance='yes' )
      call dump( L2PCVS(yStar) )
    endif

    ! Get the instance first information
    call h5gOpen_f ( matrixID, 'Blocks', blocksID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to access Blocks group of input l2pc matrix' , &
      & MLSFile=MLSFile )
    ! This next is inelegant: grp_id should be a linked list
    MLSFile%fileID%sd_id = blocksID
    call GetHDF5Attribute ( MLSFile, 'rowInstanceFirst', rowInstanceFirst )
    call GetHDF5Attribute ( MLSFile, 'colInstanceFirst', colInstanceFirst )

    stringIndex = GetStringIndexFromString ( "'"//trim(matrixName)//"'" )

    ! Create the matrix
    call CreateEmptyMatrix ( l2pc%j, stringIndex, l2pcVs(yStar), l2pcVs(xStar), &
      & row_quan_first = .not. rowInstanceFirst,&
      & col_quan_first = .not. colInstanceFirst )

    ! Must *not* forget to name l2pc 
    ! (l2pc%name will itself never be used beyond this point)
    l2pc%name = l2pc%j%name

    ! Fill up the information
    if ( present ( info ) ) then
      info%fileID = MLSFile%fileID%f_id
      info%binID = matrixID
      info%blocksID = blocksID
      info%matrixName = matrixName
    end if

    if ( verboser ) then
      do i = 1, l2pc%j%row%NB
        do j = 1, l2pc%j%col%NB
          call CreateBlockName ( i, j, 0, name )
          call h5gOpen_f ( blocksId, trim(name), blockId, status )
          if ( status /= 0 ) then
            call outputNamedValue( 'Block name', trim(name) )
            call outputNamedValue( 'Blocks ID', blocksId )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unable to open group for l2pc matrix block '//trim(name) , &
              & MLSFile=MLSFile )
          elseif ( verboser ) then
            call outputNamedValue( 'Block name', trim(name) )
            call outputNamedValue( 'Blocks ID', blocksId )
            call outputNamedValue( 'Block ID', blockId )
          endif
          call h5gClose_f ( blockId, status )
        enddo
      enddo
    endif
    ! Loop over blocks and read them
    if ( .not. myShallow ) then
      do i = 1, l2pc%j%row%NB
        do j = 1, l2pc%j%col%NB
          ! Access this block
          call CreateBlockName ( i, j, 0, name )
          call h5gOpen_f ( blocksId, trim(name), blockId, status )
          if ( status /= 0 ) then
            call outputNamedValue( 'Block name', trim(name) )
            call outputNamedValue( 'Blocks ID', blocksId )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unable to open group for l2pc matrix block '//trim(name) , &
              & MLSFile=MLSFile )
          elseif ( verboser ) then
            call outputNamedValue( 'Block name', trim(name) )
            call outputNamedValue( 'Blocks ID', blocksId )
            call outputNamedValue( 'Block ID', blockId )
          endif
          ! Could check it's the block we're expecting but I think I'll be lazy
          ! This next is inelegant: grp_id should be a linked list
          MLSFile%fileID%sd_id = blockID
          call GetHDF5Attribute ( MLSFile, 'kind', kind )
          if ( kind == m_banded .or. kind == m_column_sparse ) then
            call GetHDF5Attribute ( MLSFile, 'noValues', noValues )
            call CreateBlock ( l2pc%j, i, j, kind, noValues )
            m0 => l2pc%j%block ( i, j )
            call LoadFromHDF5DS ( MLSFile, 'r1', m0%r1 )
            call LoadFromHDF5DS ( MLSFile, 'r2', m0%r2 )
          else
            call CreateBlock ( l2pc%j, i, j, kind )
            m0 => l2pc%j%block ( i, j )
          end if
          if ( kind /= m_absent ) &
            call LoadFromHDF5DS ( MLSFile, 'values', m0%values )
          call h5gClose_f ( blockId, status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to close group for input l2pc matrix block '//trim(name) , &
            & MLSFile=MLSFile )
        end do
      end do
    else
      ! Otherwise, flag the whole matrix as unknown
      do i = 1, l2pc%j%row%NB
        do j = 1, l2pc%j%col%NB
          call CreateBlock ( l2pc%j, i, j, m_unknown )
        end do
      end do
    end if

    call h5gClose_f ( blocksId, status )
    ! Look for any Hessian blocks
    ! We begin by assuming there are none
    call h5gn_members_f( MLSFile%fileID%f_id, trim(matrixName), nmembers, status )
    if ( verbose ) then
      call outputNamedValue ( 'nmembers under ' // trim(matrixName), nmembers )
      do i=0, nmembers-1
        call h5gget_obj_info_idx_f( MLSFile%fileID%f_id, trim(matrixName), i, &
                                           name, objtype, status )
        call outputNamedValue ( 'member name: ', trim(name) )
      enddo
    endif
    status = 1
    if ( nmembers > 3 ) call h5gOpen_f ( matrixID, 'HessianBlocks', hBlocksID, status )
    l2pc%goth = status == 0 .and. nmembers > 3 ! Got Hessian?
    if ( switchDetail( switches, 'hess' ) > -1 ) &
                & call outputNamedValue( 'got hessian?', l2pc%goth )
    if ( l2pc%goth ) then
      ! This next is inelegant: grp_id should be a linked list
      MLSFile%fileID%sd_id = hblocksID

      l2pc%h = CreateEmptyHessian ( stringIndex, l2pcVs(yStar), l2pcVs(xStar) )
      if ( switchDetail( switches, 'hess' ) > -1 ) &
                & call output( 'Creating empty hessian', advance='yes' )
      if ( present ( info ) ) info%hBlocksID = hBlocksID

      ! Loop over blocks and read them
      if ( .not. myShallow ) then
        if ( switchDetail( switches, 'hess' ) > -1 ) then
          call output( 'trying to read this hessian block', advance='yes' )
          call outputNamedValue( 'l2pc%h%row%NB', l2pc%h%row%NB )
          call outputNamedValue( 'l2pc%h%col%NB', l2pc%h%col%NB )
          call outputNamedValue( 'hblocksId', hblocksId )
        endif
        do i = 1, l2pc%h%row%NB
          do j = 1, l2pc%h%col%NB
            do k = 1, l2pc%h%col%NB
              ! Access this block
              call CreateBlockName ( i, j, k, name )
              call h5gOpen_f ( hblocksId, trim(name), blockId, status )
              if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Unable to open group for l2pc hessian block '//trim(name) , &
                & MLSFile=MLSFile )
              ! Could check it's the block we're expecting but I think I'll be lazy
              ! This next is inelegant: grp_id should be a linked list
              MLSFile%fileID%sd_id = blockID
              call GetHDF5Attribute ( MLSFile, 'kind', kind )
              if ( switchDetail( switches, 'hess' ) > 1 ) &
                & call outputNamedValue( 'kind', kind )

              select case ( kind )
              case ( h_absent )
                call CreateBlock ( l2pc%h, i, j, k, kind, noValues )
                h0 => l2pc%h%block ( i, j, k )
              case ( h_sparse )
                call GetHDF5Attribute ( MLSFile, 'noValues', noValues )
                call CreateBlock ( l2pc%h, i, j, k, kind, noValues )
                h0 => l2pc%h%block ( i, j, k )
                call LoadFromHDF5DS ( MLSFile, 'i', h0%tuples%i )
                call LoadFromHDF5DS ( MLSFile, 'j', h0%tuples%j )
                call LoadFromHDF5DS ( MLSFile, 'k', h0%tuples%k )
                call LoadFromHDF5DS ( MLSFile, 'h', h0%tuples%h )
              case ( h_full )
                call CreateBlock ( l2pc%h, i, j, k, kind )
                h0 => l2pc%h%block ( i, j, k )                
                call LoadFromHDF5DS ( MLSFile, 'values', h0%values )
              case default
                 call MLSMessage ( MLSMSG_Warning, ModuleName, &
                & 'Read unexpected Hessian kind '//trim(name) )
              end select
              call h5gClose_f ( blockId, status )
              if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Unable to close group for input l2pc Hessian block '//trim(name) , &
                & MLSFile=MLSFile )
            end do
          end do
        end do
      else
        if ( switchDetail( switches, 'hess' ) > -1 ) &
                  & call output( 'flagging hessian as unknown', advance='yes' )
        ! Otherwise, flag the whole hessian as unknown
        do i = 1, l2pc%h%row%NB
          do j = 1, l2pc%h%col%NB
            do k = 1, l2pc%h%col%NB
              call CreateBlock ( l2pc%h, i, j, k, h_unknown )
            end do
          end do
        end do
      end if
    end if                              ! Looking for Hessians

    ! finish up, though if in shallow mode, then keep the groups open
    if ( .not. myShallow ) then
      if ( l2pc%goth ) then
        call h5gClose_f ( hblocksID, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to close Blocks group for input l2pc' , &
          & MLSFile=MLSFile )
      endif
      call h5gClose_f ( matrixID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close matrix group for input l2pc' , &
        & MLSFile=MLSFile )
    endif
    i = switchDetail( switches, 'l2pc' )
    if ( i >= 0 ) then
      call dump ( l2pc, details=i-1 )
      call output ( 'Done reading bin from l2pc file', advance='yes' )
    end if

  end subroutine ReadOneHDF5L2PCRecord

  ! --------------------------------------- ReadOneVectorFromHDF5 ------
  subroutine ReadOneVectorFromHDF5 ( MLSFile, name, vector )
    use HDF5, only: H5GClose_f, h5gopen_f, h5gget_obj_info_idx_f
    use MLSHDF5, only: GETHDF5Attribute, isHDF5AttributePresent, &
      & isHDF5DSPresent, loadFromHDF5DS
    use MLSSignals_m, only: radiometers, signals
    ! Read a vector from an l2pc HDF5 and adds it to internal databases.
    ! Dummy arguments
    type (MLSFile_T) :: MLSFile
    character (len=*), intent(in) :: NAME ! Name of vector
    integer, intent(out) :: VECTOR      ! Index of vector read in L2PCVectors

    ! Local variables
    integer :: FREQUENCYCOORDINATE      ! Enumeration
    integer :: I                        ! Index into various arrays
    integer :: MOLECULE                 ! Enumeration
    integer :: NAMEINDEX                ! Quantity name
    integer :: NOCHANS                  ! Dimension
    integer :: NOINSTANCES              ! Dimension
    integer :: NOQUANTITIES             ! Number of quantities in vector
    integer :: NOSURFS                  ! Dimension
    integer :: OBJTYPE                  ! Irrelevant argument to HDF5
    integer :: QID                      ! HDF5 ID of quantity group
    integer :: QT0                      ! Offset into l2pc quantity templates database
    integer :: QTINDEXOFFSET            ! First free index in quantity template database
    integer :: QUANTITY                 ! Loop inductor
    integer :: QUANTITYTYPE             ! Enumerated
    integer :: RADIOMETER               ! Enumerated
    integer :: SIDEBAND                 ! Sideband -1,0,1
    integer :: SIGNAL                   ! Index
    integer :: STATUS                   ! Flag from HDF
    integer :: STRINGINDEX              ! A string index
    integer :: UNIT                     ! Units for quantity
    integer :: VERTICALCOORDINATE       ! Enumeratire
    integer :: VID                      ! HDF5 ID of vector group
    integer :: VTINDEX                  ! Index of vector template
    character (len=64) :: THISNAME      ! Name of this quantity
    character (len=64) :: WORD          ! General string

    logical :: COHERENT                 ! Flag
    logical :: DEBUG                    ! Flag
    logical :: STACKED                  ! Flag
    logical :: LOGBASIS                 ! Flag

    integer, dimension(:), pointer :: SIGINDS  ! Index into signals database
    integer, dimension(:), pointer :: QTINDS   ! Quantity indices

    character (len=64), pointer, dimension(:) :: QUANTITYNAMES ! Names of quantities
    type ( QuantityTemplate_T), pointer :: QT    ! Template for the quantity
    type ( VectorTemplate_T) :: VT    ! Template for the vector
    type ( Vector_T ) :: V              ! The vector

    ! Executable code
    verbose = switchDetail( switches, 'l2pc') > -1
    debug = switchDetail( switches, 'debug') > -1
    nullify ( sigInds, qtInds )

    if ( verbose ) then
      call output ( 'Reading ' )
      call output ( trim(name) )
      call output ( ' vector from l2pc', advance='yes' )
    end if
    ! Open the vector group
    call h5gOpen_f ( MLSFile%fileID%grp_id, name, vId, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open group for vector '//trim(name), &
      & MLSFile=MLSFile )

    ! Get the number of quantities
    MLSFile%fileID%sd_id = vID
    call GetHDF5Attribute ( MLSFile, 'noQuantities', noQuantities )
    call allocate_test ( qtInds, noQuantities, 'qtInds', ModuleName )
    ! Work out the order of the quantities
    nullify ( quantityNames )
    call Allocate_test ( quantityNames, noQuantities, 'quantityNames', ModuleName )
    do quantity = 1, noQuantities
      if ( verbose) &
        & call output ( quantity, before='Identifying quantity ', advance='yes' )
      call h5gget_obj_info_idx_f ( MLSFile%fileID%grp_id, name, quantity-1, thisName, &
        & objType, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to access a quantity within '//trim(name) , &
      & MLSFile=MLSFile )
      call h5gOpen_f ( vId, trim(thisName), qId, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open quantity '//trim(thisName)//' in vector '//trim(name), &
        & MLSFile=MLSFile )
      MLSFile%fileID%sd_id = qID
      call GetHDF5Attribute ( MLSFile, 'index', i )
      quantityNames ( i ) = thisName
      call h5gClose_f ( qId, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close quantity '//trim(thisName)//' in vector '//trim(name), &
        & MLSFile=MLSFile )
    end do

    qtIndexOffset = InflateQuantityTemplateDatabase ( l2pcQTs, noQuantities )
    if ( debug ) then
      call outputNamedValue( 'noQuantities', noQuantities )
      call outputNamedValue( 'qt0', qt0 )
    endif
    qt0 = size ( l2pcQTs ) - noQuantities

    ! Now go through quantities in order
    do quantity = 1, noQuantities
      qt => l2pcQTs ( qtIndexOffset + quantity - 1 )
      if ( verbose ) then
        call output ( quantity, before='Reading quantity ' )
        call output ( ': ' )
        call output ( trim(quantityNames(quantity)), advance='yes' )
      end if

      ! Point to this quantity
      call h5gOpen_f ( vId, trim(quantityNames(quantity)), qId, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open quantity '//trim(quantityNames(quantity))// &
        & ' in vector '//trim(name) , &
        & MLSFile=MLSFile )

      ! Store the name
      stringIndex = GetStringIndexFromString ( quantityNames(quantity) )
      nameIndex = stringIndex

      ! Get the quantity type
      MLSFile%fileID%sd_id = qID
      call GetHDF5Attribute ( MLSFile, 'type', word )
      quantityType = GetLitIndexFromString ( word )

      ! Get other info as appropriate
      signal = 0
      sideband = 0
      molecule = 0
      radiometer = 0
      frequencyCoordinate = l_none
      unit = phyq_dimensionless
      select case ( quantityType )
      case ( l_rhi )
        word = 'H2O'
        molecule = GetLitIndexFromString ( word )
        unit = phyq_pctrhi
      case ( l_columnAbundance )
        call GetHDF5Attribute ( MLSFile, 'molecule', word )
        molecule = GetLitIndexFromString ( word )
        unit = phyq_colmabundance
      case ( l_isotopeRatio )
        call GetHDF5Attribute ( MLSFile, 'molecule', word )
        molecule = GetLitIndexFromString ( word )
      case ( l_vmr )
        call GetHDF5Attribute ( MLSFile, 'molecule', word )
        molecule = GetLitIndexFromString ( word )
        if ( isExtinction(molecule) ) then
          if ( IsHDF5AttributePresent ( MLSFile, 'radiometer' ) ) then
            call GetHDF5Attribute ( MLSFile, 'radiometer', word )
            stringIndex = GetStringIndexFromString ( word )
            radiometer = FindFirst ( Radiometers%prefix, stringIndex )
          else
            radiometer = 0
          endif
          frequencyCoordinate = l_intermediateFrequency
        else
          frequencyCoordinate = l_none
        end if
        unit = phyq_vmr
      case ( l_radiance, l_TScat, l_calsidebandfraction, l_limbsidebandfraction, &
        & l_opticalDepth, l_elevOffset)
        call GetHDF5Attribute ( MLSFile, 'signal', word )
        if ( quantityType /= l_TScat ) then
          call Parse_Signal ( word, sigInds, sideband=sideband )
        else ! TScat
          call Parse_Signal ( word, sigInds, sideband=sideband, channels=qt%channels )
          call allocate_test ( qt%chanInds, count(qt%channels), 'qt%chanInds', moduleName )
          qt%chanInds = pack( (/ ( i, i=lbound(qt%channels,1), ubound(qt%channels,1) ) /), &
                            & qt%channels ) ! Indices of true channels
          call allocate_test ( qt%frequencies, size(qt%chanInds), 'qt%frequencies', moduleName )
          qt%frequencies = signals(sigInds(1))%frequencies(qt%chanInds)
        end if
        signal = sigInds(1)
        verticalCoordinate = l_geodAltitude
        frequencyCoordinate = l_channel
        call deallocate_test(sigInds,'sigInds',ModuleName)
        unit = phyq_temperature
      case ( l_temperature )
        unit = phyq_temperature
      case default
      end select

      ! Now read the dimensions for the quantity
      call GetHDF5Attribute ( MLSFile, 'noChans', noChans )
      call GetHDF5Attribute ( MLSFile, 'noInstances', noInstances )
      call GetHDF5Attribute ( MLSFile, 'noSurfs', noSurfs )
      call GetHDF5Attribute ( MLSFile, 'verticalCoordinate', word )
      verticalCoordinate = GetLitIndexFromString ( word )
      ! Look for frequency coordinate (optional for backwards compatability with
      ! older l2pc files.
      if ( IsHDF5AttributePresent ( qID, 'frequencyCoordinate' ) ) then
        call GetHDF5Attribute ( MLSFile, 'frequencyCoordinate', word )
        frequencyCoordinate = GetLitIndexFromString ( trim(word) )
      end if
      call GetHDF5Attribute ( MLSFile, 'logBasis', logBasis )
      call GetHDF5Attribute ( MLSFile, 'coherent', coherent )
      call GetHDF5Attribute ( MLSFile, 'stacked', stacked )

      qt%name = nameIndex
      call SetupNewQuantityTemplate ( qt, &
        & noInstances=noInstances, noSurfs=noSurfs, noChans=noChans, &
        & coherent=coherent, stacked=stacked )

      qt%quantityType = quantityType
      qt%logBasis = logBasis
      qt%molecule = molecule
      qt%radiometer = radiometer
      qt%signal = signal
      qt%sideband = sideband
      qt%verticalCoordinate = verticalCoordinate
      qt%frequencyCoordinate = frequencyCoordinate
      qt%unit = unit
      if ( debug ) then
        call outputNamedValue( 'quantity', quantity )
        call outputNamedValue( 'quantityType', quantityType )
        call outputNamedValue( 'logBasis', logBasis )
        call outputNamedValue( 'molecule', molecule )
        call outputNamedValue( 'radiometer', radiometer )
        call outputNamedValue( 'qtIndexOffset', qtIndexOffset )
        call outputNamedValue( 'index', qtIndexOffset + quantity - 1 )
      endif

      ! Get the surfaces and phis
      call LoadFromHDF5DS ( MLSFile, 'surfs', qt%surfs )
      call LoadFromHDF5DS ( MLSFile, 'phi', qt%phi )
      if ( IsHDF5DSPresent ( qId, 'solarZenith' ) ) then
        call LoadFromHDF5DS ( MLSFile, 'solarZenith', qt%solarZenith )
      else
        qt%solarZenith = 0.0
      endif
      ! Try to get the frequencies
      if ( IsHDF5DSPresent ( qId, 'frequencies' ) ) then
        call Allocate_test( qt%frequencies, qt%noChans, &
          & 'qt%frequencies', ModuleName )
        call LoadFromHDF5DS ( MLSFile, 'frequencies', qt%frequencies )
      end if

      ! Now record the index for this quantity template
      qtInds ( quantity ) = quantity + qt0

      ! For the moment, close the quantity. We'll come back to it later to fill
      ! up the values for the vector
      call h5gClose_f ( qId, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close quantity '//trim(thisName)//' in vector '//trim(name), &
        & MLSFile=MLSFile )
    end do

    ! Now create a vector template with these quantities
    call ConstructVectorTemplate ( 0, l2pcQTs, qtInds, vt, forWhom=moduleName )
    vtIndex = AddVectorTemplateToDatabase ( l2pcVTs, vt )

    call deallocate_test ( qtInds, 'qtInds', ModuleName )

    ! Now create a vector for this vector template
    if ( verbose ) &
      & call output ( 'Creating vector', advance='yes' )
    v = CreateVector ( 0, l2pcVTs(vtIndex), l2pcQTs, vectorNameText='_v_'//name )
    if ( verbose ) &
      & call output ( 'Adding vector to database', advance='yes' )
    vector = AddVectorToDatabase ( l2pcVs, v )

    ! Now go through the quantities again and read the values
    do quantity = 1, noQuantities
      if ( verbose ) then
        call output ( 'Reading values for ' )
        call output ( trim(quantityNames(quantity)), advance='yes' )
      end if
      call h5gOpen_f ( vId, trim(quantityNames(quantity)), qId, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open quantity '//trim(quantityNames(quantity))// &
        & ' in vector '//trim(name), &
        & MLSFile=MLSFile )
      MLSFile%fileID%sd_id = qID
      call LoadFromHDF5DS ( MLSFile, 'values', &
        & l2pcVs(vector)%quantities(quantity)%values )
      call h5gClose_f ( qId, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close quantity '//trim(thisName)//' in vector '//trim(name), &
        & MLSFile=MLSFile )
    end do

    call Deallocate_test ( quantityNames, 'quantityNames', ModuleName )

  end subroutine ReadOneVectorFromHDF5

  ! --------------------------------------- WriteVectorAsHDF5L2PC ----------
  subroutine WriteVectorAsHDF5L2PC ( location, vector, name, packInfo )
    use HDF5, only: H5GClose_f, h5gcreate_f
    use MLSHDF5, only: MakeHDF5Attribute, saveasHDF5DS
    use mlssignals_m, only: radiometers
    integer, intent(in) :: LOCATION     ! The HDF5 location for the vector
    type (Vector_T), intent(in), target :: VECTOR ! The vector to write
    character(len=*), intent(in) :: NAME ! Name for vector
    logical, dimension(:), intent(in) :: PACKINFO ! Pack vector if set

    ! Local variables
    character ( len=132 ) :: LINE       ! A line of text
    character ( len=32 ) :: QNAME       ! Name of quantity
    integer :: QID                      ! HDF5 ID for quantity group
    integer :: QINDEX                   ! Quantity index
    integer :: QUANTITY                 ! Index
    integer :: STATUS                   ! Flag from HDF5
    integer :: VID                      ! HDF5 ID for vector group
    type (QuantityTemplate_T), pointer :: QT ! The template

    ! Executable code
    ! Create a group for the vector
    call h5gCreate_f ( location, trim(name), vID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create group for vector ' // trim(name) )
    call MakeHDF5Attribute ( vID, 'noQuantities', count(packInfo) )
    qIndex = 0
    do quantity = 1, size ( vector%quantities )
      if ( packInfo(quantity) ) then
        qIndex = qIndex + 1
        qt => vector%quantities(quantity)%template
        ! Create a group for the quantity
        call get_string ( qt%name, qName )
        call h5gCreate_f ( vID, trim(qName), qID, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to create group for quantity ' // trim(qName) )

        ! Write quantity type and index
        call MakeHDF5Attribute ( qID, 'index', qIndex )
        call get_string ( lit_indices(qt%quantityType), line )
        call MakeHDF5Attribute ( qID, 'type', trim(line) )
        ! Write other info as appropriate
        select case ( qt%quantityType )
        case (l_vmr, l_columnAbundance, l_rhi, l_isotopeRatio)
          call get_string ( lit_indices(qt%molecule), line )
          call MakeHDF5Attribute ( qID, 'molecule', trim(line) )
          if ( isExtinction(qt%molecule) ) then
            line = 'none'
            if ( qt%radiometer /= 0 ) &
              & call get_string ( radiometers(qt%radiometer)%prefix, line )
            call MakeHDF5Attribute ( qID, 'radiometer', trim(line) )
          end if
        case (l_radiance, l_calsidebandfraction, l_limbsidebandfraction, &
          & l_opticalDepth, l_elevOffset)
          call GetSignalName ( qt%signal, line, sideband=qt%sideband )
          call MakeHDF5Attribute ( qID, 'signal', trim(line) )
        case (l_TScat)
          call GetSignalName ( qt%signal, line, sideband=qt%sideband, &
            & otherChannels=qt%channels )
          call MakeHDF5Attribute ( qID, 'signal', trim(line) )
        end select
        ! Write out the dimensions for the quantity
        call MakeHDF5Attribute ( qID, 'noChans', qt%noChans )
        call MakeHDF5Attribute ( qID, 'noInstances', qt%noInstances )
        call MakeHDF5Attribute ( qID, 'noSurfs', qt%noSurfs )
        call get_string ( lit_indices(qt%verticalCoordinate), line )
        call MakeHDF5Attribute ( qID, 'verticalCoordinate', trim(line) )
        call get_string ( lit_indices(qt%frequencyCoordinate), line )
        call MakeHDF5Attribute ( qID, 'frequencyCoordinate', trim(line) )
        call get_string ( lit_indices(qt%unit), line )
        call MakeHDF5Attribute ( qID, 'unit', trim(line) )
        call MakeHDF5Attribute ( qID, 'logBasis', qt%logBasis )
        call MakeHDF5Attribute ( qID, 'coherent', qt%coherent )
        call MakeHDF5Attribute ( qID, 'stacked', qt%stacked )
        ! Write out important coordinates
        call SaveAsHDF5DS ( qID, 'phi', qt%phi )
        call SaveAsHDF5DS ( qID, 'surfs', qt%surfs )
        call SaveAsHDF5DS ( qID, 'solarZenith', qt%solarZenith )
        if ( associated ( qt%frequencies ) ) &
          & call SaveAsHDF5DS ( qID, 'frequencies', qt%frequencies )
        ! Write out the values
        if ( .not. associated(vector%quantities(quantity)%values) ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'values field not associated for this block'  // trim(qName) )
        else
          call SaveAsHDF5DS ( qID, 'values', vector%quantities(quantity)%values )
        endif
        ! Close the group
        call h5gClose_f ( qID, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to close quantity group for ' // trim(qName) )
      end if
    end do

    ! Finish off
    call h5gClose_f ( vID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close vector group for ' // trim(name) )

  end subroutine WriteVectorAsHDF5L2PC

  subroutine CreateBlockName ( row, column1, column2, name )
    ! Because the Intel compiler produces a different result from
    ! write(str, *) int
    ! Args
    integer, intent(in)           :: row, column1, column2
    character(len=*), intent(out) :: name
    ! Internal variables
    character(len=16), dimension(3) :: strs
    ! Executable
    call writeIntsToChars( (/row, column1, column2/), strs )
    name = ' Block' // ' ' // trim(adjustl(strs(1))) // ' ' // trim(adjustl(strs(2)))
    if ( column2 > 0 ) name = trim ( name ) // ' ' // trim(adjustl(strs(3)))
  end subroutine CreateBlockName

  ! ----------------- getNBinsInFile
  ! find indices of the entries in the fileIDDatabase for a given L2PCFile
  subroutine getNBinsInFile( L2PCFile, indices, nBins )
    ! Args:
    type (MLSFile_T), intent(in)       :: L2PCFile
    integer, dimension(:), intent(out) :: indices
    integer, intent(out)               :: nBins
    ! Internal variables
    integer :: i
    ! Executable
    indices = 0
    nBins = 0
    if ( .not. associated(L2PCDataBase) ) return
    call outputNamedValue( 'size(L2PCDataBase)', size(L2PCDataBase) )
    do i=1, size(L2PCDataBase)
      if ( L2PCFile%FileID%f_id /= fileIDDataBase(i) ) cycle
      nBins = nBins + 1
      if ( nBins <= size(indices) ) indices(nBins) = i
    enddo
  end subroutine getNBinsInFile

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: L2PC_m.f90,v 2.132 2015/07/14 23:23:52 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module L2PC_m

! $Log: L2PC_m.f90,v $
! Revision 2.132  2015/07/14 23:23:52  pwagner
! Use more robust isStringInTable
!
! Revision 2.131  2015/06/30 18:38:12  pwagner
! Should not crash just because some string not in table
!
! Revision 2.130  2015/04/28 23:59:52  pwagner
! Diffs made more manageable
!
! Revision 2.129  2015/03/28 01:10:03  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.128  2014/09/04 23:48:52  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.127  2014/01/09 18:15:42  pwagner
! Fixed bug in preventing crashes when qt%radiometer is 0
!
! Revision 2.126  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.125  2014/01/08 18:31:48  pwagner
! Fixed crash on gettting extinction radiometer prefix
!
! Revision 2.124  2013/08/30 03:56:01  vsnyder
! Revise use of trace_begin and trace_end
!
! Revision 2.123  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.122  2013/06/12 02:10:47  vsnyder
! Cruft removal
!
! Revision 2.121  2012/02/17 00:21:05  pwagner
! May dump layout of l2pc only with 'L' option
!
! Revision 2.120  2012/02/13 23:27:27  pwagner
! Fixed more bugs in read/write of quantities in xstar,ystar
!
! Revision 2.119  2012/02/02 01:17:03  pwagner
! Added LoadHessian; fixed errors that cause crashes
!
! Revision 2.118  2011/11/11 00:32:29  vsnyder
! Use IsExtinction array from Molecules module
!
! Revision 2.117  2011/11/09 17:41:02  pwagner
! Fixed bug added with last commit
!
! Revision 2.116  2011/11/04 23:38:47  pwagner
! Made consistent with MLSFile interface to MLSHDF5
!
! Revision 2.115  2011/08/20 02:04:03  vsnyder
! Remove unused use name
!
! Revision 2.114  2011/08/09 23:17:43  pwagner
! Tries to flush hessian bins, too
!
! Revision 2.113  2011/07/28 18:03:37  pwagner
! Fixed bug in FlushL2PCBins added in rev. 2.88
!
! Revision 2.112  2011/05/05 15:20:04  pwagner
! Fixed bugs in writing, reading radiometer attribute for extinctionv2
!
! Revision 2.111  2011/04/15 00:20:32  pwagner
! Protect against unlikely case where there is no Jacobian to output to file
!
! Revision 2.110  2011/02/18 17:56:16  pwagner
! Prevented crashes when run w/o l2cf
!
! Revision 2.109  2010/11/25 01:19:27  pwagner
! Fixed bugs in PopulateL2PCBin with Hessians
!
! Revision 2.108  2010/11/19 23:58:19  pwagner
! Added Diff
!
! Revision 2.107  2010/11/05 00:31:10  pwagner
! Too few args to DumpOneL2PC
!
! Revision 2.106  2010/11/03 18:30:41  pwagner
! Dumps now take option to say whether to dump hessians, matrices, and which blocks
!
! Revision 2.105  2010/09/25 01:14:34  vsnyder
! Add some TScat support, and some cannonball polishing
!
! Revision 2.104  2010/09/17 00:02:57  pwagner
! Can constrain which blocks dumped by name
!
! Revision 2.103  2010/08/31 02:05:38  vsnyder
! Don't nullufy qt%channels before allocating, to avoid leaking memory
!
! Revision 2.102  2010/08/27 21:55:35  pwagner
! WIll not try to write empty Hessian blocks
!
! Revision 2.101  2010/08/20 23:19:50  pwagner
! May specify which blocks to dump by name; dont dump empty blocks
!
! Revision 2.100  2010/08/13 22:22:59  pwagner
! details now can choose between matrices, hessians; fixed a bug in reading HessianBlocks
!
! Revision 2.99  2010/08/06 22:58:40  pwagner
! Added new 'hess' switch; using only switchDetail now
!
! Revision 2.98  2010/06/28 17:00:49  pwagner
! Fixed a few bugs
!
! Revision 2.97  2010/05/20 00:51:50  pwagner
! Can populate Hessians; untested
!
! Revision 2.96  2010/05/19 17:51:41  pwagner
! Details now used to dump or not L2PCInfo%blockID
!
! Revision 2.95  2010/05/19 00:32:06  vsnyder
! Pass IgnoreHessian into PopulateL2PCBin
!
! Revision 2.94  2010/05/13 23:45:14  pwagner
! Temporary expedients for l2pc files with Hessians; needs more code
!
! Revision 2.93  2010/04/30 22:55:32  vsnyder
! Give more meaningful names to vectors
!
! Revision 2.92  2010/04/17 01:43:35  vsnyder
! Simplify dump.  Set l2pc%goth if there is a Hessian block.
!
! Revision 2.91  2010/03/24 20:48:55  vsnyder
! Replace 'continue' by 'cycle'.  Call OptimizeBlock from WriteOneHDF5L2PC
! when writing a Hessian, to avoid trying to write empty arrays.  Add some
! comments.  Fix a wrong-subscript bug.
!
! Revision 2.90  2010/03/19 20:18:47  pwagner
! Moved DumpL2PCInfo out of public scope to appease ifort v10 which crashed the goldbrick
!
! Revision 2.89  2010/03/17 20:59:10  pwagner
! Code around bombs in DestroyL2PCInfoDatabase
!
! Revision 2.88  2010/02/25 18:04:45  pwagner
! l2pc type can now hold matrix and Hessian types
!
! Revision 2.87  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.86  2009/11/17 23:43:51  vsnyder
! Add ability to output TScat
!
! Revision 2.85  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.84  2008/12/18 21:31:18  pwagner
! May now dump an l2pc or allL2PCs (use with caution)
!
! Revision 2.83  2008/09/30 22:28:03  vsnyder
! Remove AuxGrids -- didn't need them after all
!
! Revision 2.82  2008/06/06 01:55:29  vsnyder
! Process AuxGrids field of vector quantities
!
! Revision 2.81  2008/05/03 01:49:55  vsnyder
! Repair a comment
!
! Revision 2.80  2007/10/03 23:58:46  vsnyder
! Add 'where' for tracing
!
! Revision 2.79  2007/04/26 20:30:32  pwagner
! Bugfix for way ifc writes ints to strings
!
! Revision 2.78  2006/08/05 02:11:58  vsnyder
! Add ForWhom argument to ConstructVectorTemplate
!
! Revision 2.77  2006/08/04 01:53:43  vsnyder
! Need to set the name, not quantityType before SetupNewQuantityTemplate
!
! Revision 2.76  2006/08/03 01:10:06  vsnyder
! Put l2cf names in leak track database
!
! Revision 2.75  2005/06/29 00:42:35  pwagner
! Passes MLSFiles to GetHDF5Attribute, LoadFromHDF5DS
!
! Revision 2.74  2005/06/22 17:25:49  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.73  2004/06/10 00:57:47  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.72  2004/02/11 01:08:44  livesey
! Removed print statement.
!
! Revision 2.71  2004/01/30 23:27:32  livesey
! Capitalized the names of the bins on output
!
! Revision 2.70  2004/01/24 01:44:36  livesey
! Removed print statement
!
! Revision 2.69  2004/01/24 01:01:22  livesey
! Improvements to the adoption stuff
!
! Revision 2.68  2004/01/23 19:07:49  livesey
! More on adoption / loading
!
! Revision 2.67  2004/01/23 05:37:34  livesey
! Added the adoption stuff
!
! Revision 2.66  2003/09/15 17:45:03  livesey
! Added target declaration for fussy intel compiler
!
! Revision 2.65  2003/08/14 20:24:23  livesey
! Added the exact bin selector stuff
!
! Revision 2.64  2003/08/13 00:47:34  livesey
! Added the default bin selectors stuff
!
! Revision 2.63  2003/08/08 23:04:45  livesey
! Added the dontPack stuff for output.
!
! Revision 2.62  2003/06/20 19:31:39  pwagner
! Changes to allow direct writing of products
!
! Revision 2.61  2003/05/13 04:46:24  livesey
! Renamed a routine to avoid conflict with VectorHDF5
!
! Revision 2.60  2003/02/06 01:37:12  livesey
! Set solarZenith to zero if reading from hdf5 and not present
!
! Revision 2.59  2003/02/06 01:34:21  livesey
! Added writing of solarZenith, and reading if it is present.
!
! Revision 2.58  2003/02/06 00:45:37  livesey
! Added name fragment to binSelector_t
!
! Revision 2.57  2003/02/05 21:55:45  livesey
! Bin selectors don't contain signal information anymore.
!
! Revision 2.56  2003/01/28 02:41:10  livesey
! Bug fix in writing matrix, now gets right element from database in all
! cases.
!
! Revision 2.55  2003/01/13 19:28:20  pwagner
! Moved several uses to speed Lahey buggs compiler
!
! Revision 2.54  2002/11/25 11:47:34  mjf
! Put SaveAsHDF5DS back to writing r4 reals.
!
! Revision 2.53  2002/11/22 12:47:47  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.52  2002/11/20 21:06:25  livesey
! Various bug fixes to make the packed storage work.
!
! Revision 2.51  2002/10/08 00:09:10  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.50  2002/10/05 00:42:31  livesey
! Modified to use new pack/unpack literals/strings
!
! Revision 2.49  2002/10/02 23:20:19  livesey
! Added radiometer and saving as single precision
!
! Revision 2.48  2002/09/11 17:43:38  pwagner
! Began changes needed to conform with matrix%values type move to rm from r8
!
! Revision 2.47  2002/08/28 21:43:38  livesey
! Cosmetic changes
!
! Revision 2.46  2002/08/28 20:42:39  livesey
! Now uses inflateQuantityTemplateDatabase, much much faster on reading
! l2pcs.
!
! Revision 2.45  2002/08/28 01:12:20  livesey
! Bug fix in frequency coordinate.
!
! Revision 2.44  2002/08/23 01:23:44  livesey
! Now optionally reads frequency coordinate and frequencies
!
! Revision 2.43  2002/08/21 23:10:11  livesey
! No longer scans each bin for blocks
!
! Revision 2.42  2002/08/20 21:01:40  livesey
! Bug fix in DestroyL2PCInfoDatabase
!
! Revision 2.41  2002/08/07 00:05:14  livesey
! Moved H5Open/Close_F into tree walker.  Made some error messages more
! informative.
!
! Revision 2.40  2002/07/25 15:53:40  mjf
! Initialised some elements of qt in ReadOneVectorFromASCII (already
! done in ReadOneVectorFromHDF5)
!
! Revision 2.39  2002/07/22 03:29:23  livesey
! Bug fix
!
! Revision 2.38  2002/07/22 03:25:23  livesey
! Bug fix and rework of loading vectors.
!
! Revision 2.37  2002/07/17 06:00:21  livesey
! Got hdf5 l2pc reading stuff working
!
! Revision 2.36  2002/07/11 22:21:00  pwagner
! These hdf5-savvy versions transferred from he5lib
!
! Revision 1.3  2002/07/09 17:38:17  livesey
! Added logBasis attribute
!
! Revision 1.2  2002/06/22 23:12:13  livesey
! Added sparsity dump
!
! Revision 1.1  2002/06/12 17:59:53  livesey
! Work on HDF5 stuff
!
! Revision 2.32  2002/05/21 01:13:24  livesey
! New file format includes name for reading into IDL
!
! Revision 2.31  2002/03/15 21:22:42  livesey
! Slight modification to binSelectors stuff
!
! Revision 2.30  2002/03/13 22:00:53  livesey
! Added output of vertical coordinate for xStar/yStar.
! Note reading routine deduces value I think.
!
! Revision 2.29  2002/03/13 01:28:48  livesey
! Commented out an error message I think I don't need
!
! Revision 2.28  2002/02/08 22:51:28  livesey
! Minor changes and tidy up
!
! Revision 2.27  2002/02/05 04:14:26  livesey
! Bug fix, still problems with packed write
!
! Revision 2.26  2002/01/23 00:50:50  pwagner
! Initialize binselectors to null
!
! Revision 2.25  2002/01/22 18:14:29  livesey
! Fixed typo.
!
! Revision 2.24  2002/01/21 23:11:49  livesey
! Completed BinSelectors support
!
! Revision 2.23  2002/01/21 21:13:42  livesey
! Added BinSelector definitions and support
!
! Revision 2.22  2002/01/18 00:34:23  livesey
! Added packed option to writeonel2pc, with supporting code.
!
! Revision 2.21  2001/06/21 22:45:43  livesey
! Found another one of those `clobbering the latest database item' gotchas in the code.
!
! Revision 2.20  2001/06/06 17:27:29  pwagner
! DEBUG parameter; checks on some more reads
!
! Revision 2.19  2001/05/23 22:00:59  livesey
! Changed counter start to avoid conflict with L2Parallel
!
! Revision 2.18  2001/05/02 20:24:03  livesey
! Removed some unused variables.
!
! Revision 2.17  2001/05/02 20:23:10  vsnyder
! Specify a name for a created vector
!
! Revision 2.16  2001/04/28 01:38:36  livesey
! Now maintains proper IDs for its own quantity and vector templates
!
! Revision 2.15  2001/04/28 01:26:50  livesey
! This one seems to work!
!
! Revision 2.14  2001/04/27 17:36:33  livesey
! An interim version
!
! Revision 2.13  2001/04/27 07:24:50  livesey
! Interim version.  Still loosing parts of kStar on add to database.
! Might this be a compiler bug?
!
! Revision 2.12  2001/04/27 07:05:28  livesey
! Not sure what happened, needed to restore the use statements.
!
! Revision 2.11  2001/04/26 23:55:17  livesey
! Interim version
!
! Revision 2.10  2001/04/26 22:32:04  vsnyder
! Alphabetize USEs and declarations
!
! Revision 2.9  2001/04/26 22:12:21  livesey
! Fixed, gets l_zeta, l_none
!
! Revision 2.8  2001/04/26 22:08:39  livesey
! Add check on vertical coordinates
!
! Revision 2.7  2001/04/26 20:02:26  livesey
! Made l2pc database a saved array in L2PC_m
!
! Revision 2.6  2001/04/26 19:33:03  livesey
! Working version, reads and writes, (but no arithmetic :-) )
!
! Revision 2.5  2001/04/26 02:48:08  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.4  2001/04/26 00:06:33  livesey
! Many changes. Working towards a working read routine
!
! Revision 2.3  2001/04/25 20:32:42  livesey
! Interim version, tidied up write
!
! Revision 2.2  2001/04/24 20:20:48  livesey
! Word bin dropped from various places e.g. type
!
! Revision 2.1  2001/04/24 20:07:44  livesey
! Moved in from l2
!

@


2.132
log
@Use more robust isStringInTable
@
text
@a180 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a195 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a212 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a1273 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d2435 1
a2435 1
       "$Id: L2PC_m.f90,v 2.131 2015/06/30 18:38:12 pwagner Exp $"
d2445 3
@


2.131
log
@Should not crash just because some string not in table
@
text
@d59 2
a60 1
  use String_table, only: display_string, getString => get_string
d172 1
a172 1
  if ( string > 0 ) &
d2439 1
a2439 1
       "$Id: L2PC_m.f90,v 2.130 2015/04/28 23:59:52 pwagner Exp $"
d2449 3
@


2.130
log
@Diffs made more manageable
@
text
@d20 25
a44 25
  use allocate_deallocate, only: allocate_test, deallocate_test
  use dump_0, only: dump
  use hessianmodule_0, only: hessianelement_t, &
    & h_absent, h_sparse, h_full, h_unknown, &
    & createblock, destroyblock
  use hessianmodule_1, only: hessian_t, &
    & copyhessianvalue, createblock, createemptyhessian, destroyhessian
  use highoutput, only: outputnamedvalue
  use intrinsic, only: l_adopted, l_channel, l_geodaltitude, l_none, l_vmr, &
    & l_radiance, l_none, l_intermediatefrequency, l_latitude, l_fieldazimuth, &
    & l_rows, l_columns, l_columnabundance, l_temperature, l_tscat, &
    & l_isotoperatio, l_calsidebandfraction, l_limbsidebandfraction, &
    & l_opticaldepth, l_elevoffset, &
    & lit_indices, &
    & phyq_colmabundance, phyq_dimensionless, phyq_pctrhi, &
    & phyq_temperature, phyq_vmr
  use manipulatevectorquantities, only: dovectorsmatch
  use matrixmodule_0, only: m_absent, m_banded, m_column_sparse, m_full, &
    & matrixelement_t, m_unknown, destroyblock
  use matrixmodule_1, only: matrix_t, matrix_database_t, &
    & copymatrixvalue, createblock, createemptymatrix, &
    & destroymatrix, dump, dump_struct, &
    & findblock, getactualmatrixfromdatabase
  use MLSCommon, only: mlsfile_t
  use MLSFiles, only: dumpmlsfile => dump
d51 15
a65 15
  use molecules, only: isextinction, l_rhi
  use moretree, only: getlitindexfromstring, getstringindexfromstring
  use output_m, only: newline, output
  use parse_signal_m, only: parse_signal
  use quantitytemplates, only: quantitytemplate_t, &
    & addquantitytemplatetodatabase, copyquantitytemplate, &
    & destroyquantitytemplatecontents, inflatequantitytemplatedatabase, &
    & nullifyquantitytemplate, setupnewquantitytemplate
  use string_table, only: display_string, get_string
  use toggles, only: switches
  use tree, only: decoration, nsons, subtree
  use vectorsmodule, only: vectortemplate_t, vector_t, &
    & assignment(=), addvectortemplatetodatabase, &
    & addvectortodatabase, constructvectortemplate, copyvector, createvector, &
    & destroyvectorinfo, dump, nullifyvectortemplate
d157 19
d2380 6
a2385 1
        call SaveAsHDF5DS ( qID, 'values', vector%quantities(quantity)%values )
d2438 1
a2438 1
       "$Id: L2PC_m.f90,v 2.129 2015/03/28 01:10:03 vsnyder Exp $"
d2448 3
@


2.129
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d20 46
a65 46
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only: DUMP
  use HESSIANMODULE_0, only: HESSIANELEMENT_T, &
    & H_ABSENT, H_SPARSE, H_FULL, H_UNKNOWN, &
    & CREATEBLOCK, DESTROYBLOCK
  use HESSIANMODULE_1, only: HESSIAN_T, &
    & COPYHESSIANVALUE, CREATEBLOCK, CREATEEMPTYHESSIAN, DESTROYHESSIAN
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use INTRINSIC, only: L_ADOPTED, L_CHANNEL, L_GEODALTITUDE, L_NONE, L_VMR, &
    & L_RADIANCE, L_NONE, L_INTERMEDIATEFREQUENCY, L_LATITUDE, L_FIELDAZIMUTH, &
    & L_ROWS, L_COLUMNS, L_COLUMNABUNDANCE, L_TEMPERATURE, L_TSCAT, &
    & L_ISOTOPERATIO, L_CALSIDEBANDFRACTION, L_LIMBSIDEBANDFRACTION, &
    & L_OPTICALDEPTH, L_ELEVOFFSET, &
    & LIT_INDICES, &
    & PHYQ_COLMABUNDANCE, PHYQ_DIMENSIONLESS, PHYQ_PCTRHI, &
    & PHYQ_TEMPERATURE, PHYQ_VMR
  use MANIPULATEVECTORQUANTITIES, only: DOVECTORSMATCH
  use MATRIXMODULE_0, only: M_ABSENT, M_BANDED, M_COLUMN_SPARSE, M_FULL, &
    & MATRIXELEMENT_T, M_UNKNOWN, DESTROYBLOCK
  use MATRIXMODULE_1, only: MATRIX_T, MATRIX_DATABASE_T, &
    & COPYMATRIXVALUE, CREATEBLOCK, CREATEEMPTYMATRIX, &
    & DESTROYMATRIX, DUMP, DUMP_STRUCT, &
    & FINDBLOCK, GETACTUALMATRIXFROMDATABASE
  use MLSCOMMON, only: MLSFILE_T
  use MLSFILES, only: DUMPMLSFILE => DUMP
  use MLSKINDS, only: R8, R4
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
  use MLSFINDS, only: FINDFIRST
  use MLSSIGNALS_M, only: GETSIGNALNAME
  use MLSSTRINGLISTS, only: OPTIONDETAIL, SWITCHDETAIL
  use MLSSTRINGS, only: WRITEINTSTOCHARS
  use MOLECULES, only: ISEXTINCTION, L_RHI
  use MORETREE, only: GETLITINDEXFROMSTRING, GETSTRINGINDEXFROMSTRING
  use OUTPUT_M, only: NEWLINE, OUTPUT
  use PARSE_SIGNAL_M, only: PARSE_SIGNAL
  use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, &
    & ADDQUANTITYTEMPLATETODATABASE, COPYQUANTITYTEMPLATE, &
    & DESTROYQUANTITYTEMPLATECONTENTS, INFLATEQUANTITYTEMPLATEDATABASE, &
    & NULLIFYQUANTITYTEMPLATE, SETUPNEWQUANTITYTEMPLATE
  use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
  use TOGGLES, only: SWITCHES
  use TREE, only: DECORATION, NSONS, SUBTREE
  use VECTORSMODULE, only: VECTORTEMPLATE_T, VECTOR_T, &
    & ASSIGNMENT(=), ADDVECTORTEMPLATETODATABASE, &
    & ADDVECTORTODATABASE, CONSTRUCTVECTORTEMPLATE, COPYVECTOR, CREATEVECTOR, &
    & DESTROYVECTORINFO, DUMP, NULLIFYVECTORTEMPLATE
d420 1
d429 1
a429 1
    character(len=*), intent(in), optional :: options ! any of {mh*b[]}
d431 1
a431 1
                                             ! m: Diff only matrices
d437 1
d444 1
d447 3
a449 6
    mustRead = .false.
    verbose = .false.
    if ( present(options) ) then
      mustRead = (optionDetail(options, 'D' ) == 'yes' )
      verbose = (optionDetail(options, 'v' ) == 'yes' )
    endif
d469 1
d471 2
d474 1
a474 1
      call newline
d477 1
a477 1
        & details, options )
d479 5
d487 1
a487 1
  subroutine DiffL2PCs ( L2pc1, L2pc2, details, options )
d490 3
a492 2
    use HESSIANMODULE_1, only: DIFF
    use MATRIXMODULE_1, only: DIFF
d497 2
a498 2
    character(len=*), intent(in), optional :: options ! any of {mh*b[]}
                                             ! m: dump only matrices
d503 1
d505 1
d508 1
d510 2
a511 1
    logical :: verbose
d518 2
d522 1
a522 1
      dumpJacobians = optionDetail( options, 'm' ) == 'yes'
d524 2
d533 5
a537 6
    call output( '- Diffing L2PCs -', advance='yes' )
    if ( l2pc1%name > 0 ) then
      call display_string ( l2pc1%name, before='name: ' )
      call output ( l2pc1%name, before=' (', after=')', advance='yes' )
    else
      call output( '*** Uh-oh, name not found in string table', advance='yes' )
d539 6
a544 5
    if ( l2pc2%name > 0 ) then
      call display_string ( l2pc2%name, before='name: ' )
      call output ( l2pc2%name, before=' (', after=')', advance='yes' )
    else
      call output( '*** Uh-oh, name not found in string table', advance='yes' )
a545 5
    
    if ( verbose ) call outputNamedValue( 'l2pc1%goth', l2pc1%goth )
    if ( verbose ) call outputNamedValue( 'l2pc2%goth', l2pc2%goth )
    if ( dumpJacobians ) &
      & call diff ( l2pc1%j, l2pc2%j, details )
d548 20
a567 1
      & call diff ( l2pc1%h, l2pc2%h, details, options )
d569 1
d647 2
a648 2
    use HESSIANMODULE_1, only: DUMP, DUMP_LAYOUT
    use MatrixModule_1, only: DUMP_LAYOUT
d932 3
a934 3
  use HDF5, only: H5FCREATE_F, H5FCLOSE_F, H5F_ACC_TRUNC_F
  use MLSSTRINGLISTS, only: CATLISTS
  use TREE, only: SUB_ROSA
d1011 4
a1014 4
    use HESSIANMODULE_0, only: OPTIMIZEBLOCK
    use HDF5, only: H5GCLOSE_F, H5GCREATE_F
    use MLSKINDS, only: RM
    use MLSHDF5, only: MAKEHDF5ATTRIBUTE, SAVEASHDF5DS
d1271 1
a1271 1
    use HDF5, only: H5FCLOSE_F, H5GCLOSE_F, H5ESET_AUTO_F
d1439 3
a1441 3
    use HDF5, only: HSIZE_T, H5GCLOSE_F, H5GOPEN_F, H5GGET_OBJ_INFO_IDX_F, &
        & H5GN_MEMBERS_F
    use MLSHDF5, only: GETHDF5ATTRIBUTE, GETHDF5DSDIMS, LOADFROMHDF5DS
d1629 6
a1634 6
    use HDF, only: DFACC_RDONLY
    use HDF5, only: H5GN_MEMBERS_F
    use INTRINSIC, only: L_HDF
    use MLSFILES, only: HDFVERSION_5, MLS_OPENFILE
    use Trace_M, only: TRACE_BEGIN, TRACE_END
    use Toggles, only: TOGGLE, GEN
d1714 3
a1716 3
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F, H5GGET_OBJ_INFO_IDX_F, &
      & H5GN_MEMBERS_F
    use MLSHDF5, only: GETHDF5ATTRIBUTE, LOADFROMHDF5DS
d1992 4
a1995 4
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F, H5GGET_OBJ_INFO_IDX_F
    use MLSHDF5, only: GETHDF5ATTRIBUTE, ISHDF5ATTRIBUTEPRESENT, &
      & ISHDF5DSPRESENT, LOADFROMHDF5DS
    use MLSSIGNALS_M, only: RADIOMETERS, SIGNALS
d2282 3
a2284 3
    use HDF5, only: H5GCLOSE_F, H5GCREATE_F
    use MLSHDF5, only: MAKEHDF5ATTRIBUTE, SAVEASHDF5DS
    use MLSSIGNALS_M, only: RADIOMETERS
d2414 1
a2414 1
       "$Id: L2PC_m.f90,v 2.128 2014/09/04 23:48:52 vsnyder Exp $"
d2424 3
@


2.128
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d161 1
d177 1
d195 1
d308 1
d310 1
d315 2
d318 1
a318 1
    call test_deallocate ( status, ModuleName, "binSelectors", s )
d389 1
d392 1
d406 2
d409 1
a409 1
      call test_deallocate ( status, ModuleName, "l2pcDatabase", s )
d1225 1
d1240 1
d1243 1
d1287 2
d1290 1
a1290 1
    call test_deallocate ( i, ModuleName, 'l2pcInfo', s )
d2382 1
a2382 1
       "$Id: L2PC_m.f90,v 2.127 2014/01/09 18:15:42 pwagner Exp $"
d2392 3
@


2.127
log
@Fixed bug in preventing crashes when qt%radiometer is 0
@
text
@d41 1
a41 1
    & DESTROYMATRIX, DUMP, DUMP_LAYOUT, DUMP_STRUCT, &
d46 1
a46 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, &
    & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMSG_ERROR, MLSMSG_WARNING
d159 2
d175 2
d192 2
d303 2
a304 1
  subroutine DestroyBinSelectorDatabase 
d306 1
a306 1
    integer :: STATUS                   ! Flag from deallocate
d309 1
d311 1
a311 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//"bin selectors binSelectors" )
d381 2
d384 1
a384 1
    integer :: I, Status
d396 1
d398 1
a398 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_deallocate // "l2pcDatabase" )
d605 1
d1212 2
d1225 4
a1228 1
  use HDF5, only: H5FCLOSE_F, H5GCLOSE_F, H5ESET_AUTO_F
d1231 1
d1272 1
d1274 2
a1275 2
    if ( i /= 0 .and. DIEIFDESTROYFAILS ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'l2pcInfo' )
d2366 1
a2366 1
       "$Id: L2PC_m.f90,v 2.126 2014/01/09 00:24:29 pwagner Exp $"
d2376 3
@


2.126
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d2264 1
a2264 1
            if ( radiometers(qt%radiometer)%prefix /= 0 ) &
d2350 1
a2350 1
       "$Id: L2PC_m.f90,v 2.125 2014/01/08 18:31:48 pwagner Exp $"
d2360 3
@


2.125
log
@Fixed crash on gettting extinction radiometer prefix
@
text
@d27 1
d54 1
a54 1
  use OUTPUT_M, only: NEWLINE, OUTPUT, OUTPUTNAMEDVALUE
d2350 1
a2350 1
       "$Id: L2PC_m.f90,v 2.124 2013/08/30 03:56:01 vsnyder Exp $"
d2360 3
@


2.124
log
@Revise use of trace_begin and trace_end
@
text
@d2262 3
a2264 1
            call get_string ( radiometers(qt%radiometer)%prefix, line )
d2349 1
a2349 1
       "$Id: L2PC_m.f90,v 2.123 2013/08/12 23:47:25 pwagner Exp $"
d2359 3
@


2.123
log
@FindSomethings moved to MLSFinds module
@
text
@d1580 3
a1582 2
    type (L2pc_t) :: L2PC    ! The l2pc read from one bin
    logical :: MYSHALLOW                ! Value of shallow
d1593 1
a1593 1
    if ( toggle (gen) ) call trace_begin ( "ReadCompleteHDF5L2PCFile", where )
d1644 1
a1644 1
    if ( toggle (gen) ) call trace_end ( "ReadCompleteHDF5L2PCFile" )
d2347 1
a2347 1
       "$Id: L2PC_m.f90,v 2.122 2013/06/12 02:10:47 vsnyder Exp $"
d2357 3
@


2.122
log
@Cruft removal
@
text
@d47 1
a47 1
  use MLSSETS, only: FINDFIRST
a1942 1
    integer :: NOINSTANCESOR1           ! Dimension
a1944 1
    integer :: NOSURFSOR1               ! Dimension
a2149 11
      if (qt%coherent) then
        noInstancesOr1 = 1
      else
        noInstancesOr1 = qt%noInstances
      endif
      if (qt%stacked) then
        noSurfsOr1 = 1
      else
        noSurfsOr1 = qt%noSurfs
      endif

d2346 1
a2346 1
       "$Id: L2PC_m.f90,v 2.121 2012/02/17 00:21:05 pwagner Exp $"
d2356 3
@


2.121
log
@May dump layout of l2pc only with 'L' option
@
text
@a101 2
  integer :: counterStart
  parameter ( counterStart = huge (0) / 4 )
d2359 1
a2359 1
       "$Id: L2PC_m.f90,v 2.120 2012/02/13 23:27:27 pwagner Exp $"
d2369 3
@


2.120
log
@Fixed more bugs in read/write of quantities in xstar,ystar
@
text
@d40 2
a41 1
    & DESTROYMATRIX, DUMP, DUMP_STRUCT, FINDBLOCK, GETACTUALMATRIXFROMDATABASE
d597 1
a597 1
    use HESSIANMODULE_1, only: DUMP
d603 2
a604 1
    character(len=*), intent(in), optional :: options ! any of {mh*b[]d[]}
d616 2
d631 1
d633 1
a633 1
    call outputNamedValue( 'myDetails', myDetails )
d639 1
a639 1
      call output( '*** Uh-oh, name not found in string table', advance='yes' )
d643 15
a657 2
      call dump ( l2pc%j%col%vec, details=details, name='xStar' )
      call dump ( l2pc%j%row%vec, details=details, name='yStar' )
d662 5
a666 1
      call dump ( l2pc%j, 'kStar', details )
d670 7
a676 3
    if ( l2pc%goth .and. dumpHessians ) &
      & call dump ( l2pc%h, 'hStar', details, onlyTheseBlocks, options )

d2361 1
a2361 1
       "$Id: L2PC_m.f90,v 2.119 2012/02/02 01:17:03 pwagner Exp $"
d2371 3
@


2.119
log
@Added LoadHessian; fixed errors that cause crashes
@
text
@d27 1
a27 1
  use INTRINSIC, only: L_CHANNEL, L_GEODALTITUDE, L_NONE, L_VMR, &
d29 6
a34 2
    & L_ROWS, L_COLUMNS, L_ADOPTED, L_TEMPERATURE, L_TSCAT, LIT_INDICES, &
    & PHYQ_DIMENSIONLESS, PHYQ_TEMPERATURE, PHYQ_VMR
d50 1
a50 1
  use MOLECULES, only: IsExtinction
d766 3
a768 2
    ! This function copies the matrix from the l2pc database into the
    ! given matrix (presumably from the main dabase)
d781 1
d793 1
a793 1
    if ( .not. DoVectorsMatch ( matrix%row%vec, source%row%vec, verbose=.true. ) ) then
d801 1
a801 1
    if ( .not. DoVectorsMatch ( matrix%col%vec, source%col%vec ) ) then
d803 4
d1683 6
d1942 1
d1956 1
d1999 4
d2038 11
d2065 2
a2066 1
      case ( l_radiance, l_TScat )
d2068 1
a2068 1
        if ( quantityType == l_radiance ) then
d2118 9
d2246 1
a2246 1
        case (l_vmr)
d2253 2
a2254 1
        case (l_radiance)
d2335 1
a2335 1
       "$Id: L2PC_m.f90,v 2.118 2011/11/11 00:32:29 vsnyder Exp $"
d2345 3
@


2.118
log
@Use IsExtinction array from Molecules module
@
text
@d26 1
a26 1
    & CREATEBLOCK, CREATEEMPTYHESSIAN, DESTROYHESSIAN
d70 1
a70 1
    & LoadMatrix, LoadVector, OutputHDF5L2PC, &
d374 5
a378 1
    if (associated(l2pcDatabase)) then
d380 2
d714 46
d778 3
d787 1
a787 1
    if ( .not. DoVectorsMatch ( matrix%row%vec, source%row%vec ) ) then
d789 4
d1186 5
a1190 1
    if ( .not. associated(l2pcInfo) ) return
d1194 1
a1194 1
        & call outputNamedValue( 'Destroying l2pc db entry number ', i )
d1865 6
a1870 4
      call h5gClose_f ( hblocksID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close Blocks group for input l2pc' , &
        & MLSFile=MLSFile )
d2076 1
d2226 2
d2291 1
a2291 1
       "$Id: L2PC_m.f90,v 2.117 2011/11/09 17:41:02 pwagner Exp $"
d2301 3
@


2.117
log
@Fixed bug added with last commit
@
text
@d46 1
a46 1
  use MOLECULES, only: L_EXTINCTION, L_EXTINCTIONV2
d1954 1
a1954 1
        if ( any(molecule == (/l_extinction, l_extinctionv2/) ) ) then
d2140 1
a2140 1
          if ( any(qt%molecule == (/l_extinction, l_extinctionv2/) ) ) then
d2223 1
a2223 1
       "$Id: L2PC_m.f90,v 2.116 2011/11/04 23:38:47 pwagner Exp $"
d2233 3
@


2.116
log
@Made consistent with MLSFile interface to MLSHDF5
@
text
@d1500 2
a1501 1
    call mls_openFile( MLSFile, status )
d2223 1
a2223 1
       "$Id: L2PC_m.f90,v 2.115 2011/08/20 02:04:03 vsnyder Exp $"
d2233 3
@


2.115
log
@Remove unused use name
@
text
@d895 1
d898 1
d909 5
d1018 3
d1467 4
a1470 1
    use HDF5, only: H5F_ACC_RDONLY_F, H5FOPEN_F, H5GN_MEMBERS_F
d1495 9
a1503 3
    if ( toggle (gen) ) call trace_begin ( "ReadCompleteHDF5L2PC", where )
    call h5fopen_f ( MLSFile%name, H5F_ACC_RDONLY_F, fileID, status )
    MLSFile%FileID%f_id = fileID
d1545 1
a1545 1
    if ( toggle (gen) ) call trace_end ( "ReadCompleteHDF5L2PC" )
d1615 1
d1678 1
d1726 1
d1752 1
d2222 1
a2222 1
       "$Id: L2PC_m.f90,v 2.114 2011/08/09 23:17:43 pwagner Exp $"
d2232 3
@


2.114
log
@Tries to flush hessian bins, too
@
text
@d45 1
a45 1
  use MLSSTRINGS, only: LOWERCASE, WRITEINTSTOCHARS
d695 2
a696 2
 	do j = 1, l2pc%h%col%NB
 	  do k = 1, l2pc%h%col%NB
d701 1
a701 1
            endif
d2199 1
a2199 1
       "$Id: L2PC_m.f90,v 2.113 2011/07/28 18:03:37 pwagner Exp $"
d2209 3
@


2.113
log
@Fixed bug in FlushL2PCBins added in rev. 2.88
@
text
@d673 1
d675 3
a677 2
    type ( L2PC_T ), pointer :: L2PC
    type ( MatrixElement_T), pointer :: M0
d693 13
d2199 1
a2199 1
       "$Id: L2PC_m.f90,v 2.112 2011/05/05 15:20:04 pwagner Exp $"
d2209 3
@


2.112
log
@Fixed bugs in writing, reading radiometer attribute for extinctionv2
@
text
@d20 8
a27 6
  use Allocate_Deallocate, only: Allocate_test, Deallocate_test
  use dump_0, only: dump
  use HessianModule_0, only: CreateBlock, HessianElement_T, &
    & H_Absent, H_Sparse, H_Full, H_Unknown, DestroyBlock
  use HessianModule_1, only: Hessian_T, CreateBlock, DestroyHessian, CreateEmptyHessian
  use Intrinsic, only: L_CHANNEL, L_GEODALTITUDE, L_NONE, L_VMR, &
d29 1
a29 1
    & L_ROWS, L_COLUMNS, L_ADOPTED, L_TEMPERATURE, L_TSCAT, Lit_Indices, &
d31 2
a32 2
  use ManipulateVectorQuantities, only: DOVECTORSMATCH
  use MatrixModule_0, only: M_ABSENT, M_BANDED, M_COLUMN_SPARSE, M_FULL, &
d34 7
a40 6
  use MatrixModule_1, only: COPYMATRIXVALUE, CREATEBLOCK, CREATEEMPTYMATRIX, &
    & DESTROYMATRIX, DUMP, DUMP_STRUCT, FINDBLOCK, GETACTUALMATRIXFROMDATABASE, &
    & MATRIX_T, MATRIX_DATABASE_T
  use MLSCommon, only: R8, R4, MLSFile_T
  use MLSFiles, only: DumpMLSFile => Dump
  use MLSMessageModule, only: MLSMESSAGE, &
d42 13
a54 13
  use MLSSets, only: FindFirst
  use MLSSignals_m, only: GETSIGNALNAME
  use MLSStringLists, only: SWITCHDETAIL
  use MLSStrings, only: writeIntsToChars
  use Molecules, only: L_EXTINCTION, L_EXTINCTIONV2
  use MoreTree, only: GetStringIndexFromString, GetLitIndexFromString
  use Output_m, only: newLine, output, outputNamedValue
  use Parse_Signal_m, only: Parse_Signal
  use QuantityTemplates, only: ADDQUANTITYTEMPLATETODATABASE, QUANTITYTEMPLATE_T, &
    & SETUPNEWQUANTITYTEMPLATE, INFLATEQUANTITYTEMPLATEDATABASE, &
    & DESTROYQUANTITYTEMPLATECONTENTS, COPYQUANTITYTEMPLATE, NULLIFYQUANTITYTEMPLATE, &
    & COPYQUANTITYTEMPLATE
  use String_Table, only: DISPLAY_STRING, GET_STRING
d56 3
a58 2
  use Tree, only: DECORATION, NSONS, SUBTREE
  use VectorsModule, only: assignment(=), ADDVECTORTEMPLATETODATABASE, &
d60 1
a60 1
    & DESTROYVECTORINFO, DUMP, NULLIFYVECTORTEMPLATE, VECTORTEMPLATE_T, VECTOR_T
a388 1
    use MLSStringLists, only: optionDetail
d453 2
a454 4
    use HessianModule_1, only: Diff
    use MatrixModule_1, only: Diff
    use MLSStringLists, only: optionDetail
    use MLSStrings, only: lowercase
a539 1
    use MLSStringLists, only: optionDetail
d586 1
a586 3
    use HessianModule_1, only: Dump
    use MLSStringLists, only: optionDetail
    use MLSStrings, only: lowercase
d670 3
a672 2
    integer :: BIN                      ! Loop counter
    integer :: I,J,K                    ! Loop counters
d674 2
a675 1
    type ( L2pc_t ), pointer :: L2PC
d681 7
a687 3
      do i = 1, l2pc%j%row%NB
        do j = 1, l2pc%j%col%NB
          call DestroyBlock ( l2pc%j%block(i,j) )
a689 9
      if ( l2pc%goth ) then
        do i = 1, l2pc%h%row%NB
          do j = 1, l2pc%h%col%NB
            do k = 1, l2pc%h%col%NB
              call DestroyBlock ( l2pc%h%block(i,j,k) )
            end do
          end do
        end do
      end if
d771 3
a773 3
  use HDF5, only: H5FCREATE_F, H5FClose_F, H5F_ACC_TRUNC_F
  use MLSStringLists, only: catLists
  use tree, only: sub_rosa
d850 1
a850 1
    use HessianModule_0, only: OptimizeBlock
d852 2
a853 2
    use MLSCOMMON, only: RM
    use MLSHDF5, only: MakeHDF5Attribute, SaveAsHDF5DS
d1054 1
a1054 1
                if ( switchDetail( switches, 'hess' ) > -1 ) then
d1095 1
a1095 1
  use HDF5, only: H5FClose_F, H5GCLOSE_F, H5ESET_AUTO_F
d1254 1
a1254 1
    use MLSHDF5, only: GetHDF5Attribute, GetHDF5DSDims, LoadFromHDF5DS
d1442 3
a1444 3
    use HDF5, only: H5F_ACC_RDONLY_F, h5fopen_f, H5GN_MEMBERS_F
    use Trace_M, only: Trace_begin, Trace_end
    use Toggles, only: Toggle, gen
d1518 1
a1518 1
    use MLSHDF5, only: GetHDF5Attribute, LoadFromHDF5DS
d1783 3
a1785 3
    use MLSHDF5, only: GetHDF5Attribute, IsHDF5AttributePresent, &
      & IsHDF5DSPresent, LoadFromHDF5DS
    use MLSSignals_m, only: Radiometers, Signals
d2057 3
a2059 3
  use HDF5, only: H5GCLOSE_F, H5GCREATE_F
  use MLSHDF5, only: MakeHDF5Attribute, SaveAsHDF5DS
    use MLSSignals_m, only: Radiometers
d2184 1
a2184 1
       "$Id: L2PC_m.f90,v 2.111 2011/04/15 00:20:32 pwagner Exp $"
d2194 3
@


2.111
log
@Protect against unlikely case where there is no Jacobian to output to file
@
text
@d43 1
a43 1
  use Molecules, only: L_EXTINCTION
d75 1
a75 1
    module procedure DUMPONEL2PC, DumpL2PCDatabase, DumpL2PCFile
d79 1
a79 1
    module procedure DUMPONEL2PC, DumpL2PCDatabase, DumpL2PCFile, DumpL2PCInfo
d525 2
a526 1
                                             ! *: dump matrices and hessians
d555 2
a556 1
                                             ! *: dump matrices and hessians
d597 2
a598 1
                                             ! *: dump matrices and hessians
d605 1
d614 1
a614 1
    ! mymolecules = '*'
d618 1
a618 2
      ! myMolecules = lowercase( optionDetail( options, 'b' ) )
      ! if ( myMolecules == 'no' ) myMolecules = '*'
d629 1
a629 1
    if ( dumpJacobians ) then
d632 1
d634 1
d1920 8
a1927 4
        if ( molecule == l_extinction ) then
          call GetHDF5Attribute ( MLSFile, 'radiometer', word )
          stringIndex = GetStringIndexFromString ( word )
          radiometer = FindFirst ( Radiometers%prefix, stringIndex )
d2106 1
a2106 1
          if ( qt%molecule == l_extinction ) then
d2189 1
a2189 1
       "$Id: L2PC_m.f90,v 2.110 2011/02/18 17:56:16 pwagner Exp $"
d2199 3
@


2.110
log
@Prevented crashes when run w/o l2cf
@
text
@d787 1
d812 1
d817 4
a820 1
      call GetActualMatrixFromDatabase ( matrices(db_index), tmpMatrix )
d833 2
d836 2
a837 1
        call writeOneHDF5L2PC ( tmpMatrix, fileID, packed, dontPack )
d2180 1
a2180 1
       "$Id: L2PC_m.f90,v 2.109 2010/11/25 01:19:27 pwagner Exp $"
d2190 3
@


2.109
log
@Fixed bugs in PopulateL2PCBin with Hessians
@
text
@d95 2
d310 4
d315 15
a329 6
    ! Exectuable code
    do jh = 1, 2
      if ( jh == 2 .and. .not. l2pc%gotH ) cycle
      do vector = 1, 2
        if ( vector == 1 ) then
          if ( jh == 1 ) then
d335 1
a335 1
          if ( jh == 1 ) then
d343 4
a346 3
        if ( switchDetail( switches, 'l2pc') > -1 ) &
          & call output( ' About to destroy vectors', advance='yes' )

d354 2
a355 2
    ! Destory kStar
    if ( switchDetail( switches, 'l2pc') > -1 ) &
d358 1
a358 1
    if ( switchDetail( switches, 'l2pc') > -1 ) &
d592 1
a592 1
    character(len=*), intent(in), optional :: options ! any of {mh*b[]}
d597 1
d1093 1
a1093 1

d1097 1
a1097 1
      if ( switchDetail ( switches, 'l2pc' ) > -1 ) &
d1117 1
a1117 1
        if ( switchDetail( switches, 'l2pc' ) > -1 ) &
d1270 2
d1273 1
a1273 1
    if ( switchDetail ( switches, 'l2pc' ) > -1 ) then
d1285 1
a1285 1
    if ( switchDetail ( switches, 'l2pc' ) > -1 ) then
d1318 1
a1318 1
        elseif ( switchDetail( switches, 'l2pc' ) > 0 ) then
d1372 1
a1372 1
            elseif ( switchDetail( switches, 'l2pc' ) > 0 ) then
d1378 1
a1378 1
            if ( DEEBUG .or. switchDetail( switches, 'l2pc' ) > 0 ) &
d1453 2
a1454 1
    if ( switchDetail( switches, 'l2pc' ) > -1 ) &
d1472 1
a1472 1
    if ( switchDetail ( switches, 'l2pc' ) > -1 ) then
d1544 2
d1549 1
a1549 1
    if ( switchDetail ( switches, 'l2pc' ) > -1 ) &
d1557 1
a1557 1
    if ( switchDetail ( switches, 'l2pc' ) > -1 ) &
d1596 1
a1596 1
    if ( switchDetail( switches, 'l2pc' ) > 0 ) then
d1607 1
a1607 1
          elseif ( switchDetail( switches, 'l2pc' ) > 0 ) then
d1629 1
a1629 1
          elseif ( switchDetail( switches, 'l2pc' ) > 0 ) then
d1668 1
a1668 1
    if ( switchDetail ( switches, 'l2pc' ) > -1 ) then
d1826 1
d1829 1
a1829 1
    if ( switchDetail ( switches, 'l2pc' ) > -1 ) then
d1848 1
a1848 1
      if ( switchDetail (switches, 'l2pc' ) > -1) &
d1874 1
a1874 1
      if ( switchDetail (switches, 'l2pc' ) > -1 ) then
d2012 1
a2012 1
    if ( switchDetail (switches, 'l2pc' ) > -1 ) &
d2015 1
a2015 1
    if ( switchDetail (switches, 'l2pc' ) > -1 ) &
d2021 1
a2021 1
      if ( switchDetail (switches, 'l2pc' ) > -1 ) then
d2172 1
a2172 1
       "$Id: L2PC_m.f90,v 2.108 2010/11/19 23:58:19 pwagner Exp $"
d2182 3
@


2.108
log
@Added Diff
@
text
@d394 1
d397 7
a403 1
    if ( present(options) ) mustRead = (optionDetail(options, 'D' ) == 'yes' )
d407 4
d420 2
d424 1
a424 1
      call outputNamedValue( 'file index', i )
d452 1
a452 1

d458 1
a458 1
    ! mymolecules = '*'
d462 6
a467 2
      ! myMolecules = lowercase( optionDetail( options, 'b' ) )
      ! if ( myMolecules == 'no' ) myMolecules = '*'
d469 1
a469 1
    call outputNamedValue( 'myDetails', myDetails )
d483 3
a1252 1

d1254 8
d1359 2
a1360 1
            if ( DEEBUG ) call outputNamedValue( 'kind', kind )
d1363 1
a1363 1
              call CreateBlock ( l2pc%h, blockRow, blockCol, blockLayer, h0%kind )
d1367 1
a1367 1
              call CreateBlock ( l2pc%h, blockRow, blockCol, blockLayer, h0%kind )
d1434 2
a1540 1

d1706 3
d1712 1
a1712 1
                & 'Unable to close group for input l2pc matrix block '//trim(name) , &
d1857 1
a1857 1
      ! Point to this quanity
d2138 1
d2149 1
a2149 1
       "$Id: L2PC_m.f90,v 2.107 2010/11/05 00:31:10 pwagner Exp $"
d2159 3
@


2.107
log
@Too few args to DumpOneL2PC
@
text
@d65 1
a65 1
    & Dump, FlushL2PCBins, L2PC_T, &
d70 4
d96 1
a96 1
  ! This type holds an l2pc
d105 3
d138 1
d367 107
d502 1
d504 1
d507 1
a507 1
    type (MLSFile_T), intent(in) :: L2PCFile
d515 1
d523 1
d525 9
d540 1
a540 1
      call DumpOneL2PC( L2PCDataBase(i), details )
d1390 1
a1390 1
    type (MLSFile_T), pointer   :: MLSFile
d1462 1
a1462 1
    type (MLSFile_T), pointer   :: MLSFile
d2093 20
d2116 1
a2116 1
       "$Id: L2PC_m.f90,v 2.106 2010/11/03 18:30:41 pwagner Exp $"
d2126 3
@


2.106
log
@Dumps now take option to say whether to dump hessians, matrices, and which blocks
@
text
@d381 1
a381 1
      call DumpOneL2PC( L2PCDB(i), details, options )
d438 1
a438 1
    character(len=128) :: myMolecules
d445 1
a445 1
    mymolecules = '*'
d449 2
a450 2
      myMolecules = lowercase( optionDetail( options, 'b' ) )
      if ( myMolecules == 'no' ) myMolecules = '*'
d471 1
a471 1
      & call dump ( l2pc%h, 'hStar', details, onlyTheseBlocks, myMolecules )
d1968 1
a1968 1
       "$Id: L2PC_m.f90,v 2.105 2010/09/25 01:14:34 vsnyder Exp $"
d1978 3
@


2.105
log
@Add some TScat support, and some cannonball polishing
@
text
@a180 187
  ! --------------------------------------- DumpL2PCDatabase ---------------
  subroutine DumpL2PCDatabase ( L2pcDB, details )
    ! This subroutine dumps an l2pc to stdout

    ! Dummy arguments
    type (l2pc_t), dimension(:), intent(in), target :: L2pcDB
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but size
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! 1 matrices only
    !                                        ! 2 hessians only
    !                                        ! 3 both matrices and hessians
    !                                        ! Default 0
    ! Local variables
    integer :: i
    ! Executable
    do i=1, size(L2PCDB)
      call DumpOneL2PC( L2PCDB(i), details )
    enddo
  end subroutine DumpL2PCDatabase

  ! --------------------------------------- DumpL2PCFile ---------------
  subroutine DumpL2PCFile ( L2PCFile, details )
    ! This subroutine dumps an l2pc to stdout

    ! Dummy arguments
    type (MLSFile_T), intent(in) :: L2PCFile
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but size
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! 1 matrices only
    !                                        ! 2 hessians only
    !                                        ! 3 both matrices and hessians
    !                                        ! Default 0
    ! Local variables
    integer :: i
    ! Executable
    call dumpMLSFile( L2PCFile, details=1 )
    call dump ( fileIDDataBase, 'file id database', format='(i10)' )
    do i=1, size(L2PCDataBase)
      if ( L2PCFile%FileID%f_id /= fileIDDataBase(i) ) cycle
      call newline
      call outputNamedValue( 'db index', i )
      call DumpOneL2PC( L2PCDataBase(i), details )
    enddo
  end subroutine DumpL2PCFile

  ! --------------------------------------- DumpOneL2PC ---------------
  subroutine DumpOneL2PC ( L2pc, details, onlyTheseBlocks )
    ! This subroutine dumps an l2pc to stdout

    use HessianModule_1, only: Dump

    ! Dummy arguments
    type (l2pc_t), intent(in), target :: L2pc
    integer, intent(in), optional :: DETAILS ! passed to Vector and Matrix dumps
    character(len=*), dimension(3), intent(in), optional :: ONLYTHESEBLOCKS ! passed to Vector and Matrix dumps
    ! Local variables
    integer :: myDetails

    ! Executable code
    myDetails = 0
    if ( present(details) ) myDetails = details
    call outputNamedValue( 'myDetails', myDetails )
    call output( '- Dump of L2PC -', advance='yes' )
    if ( l2pc%name > 0 ) then
      call display_string ( l2pc%name, before='name: ' )
      call output ( l2pc%name, before=' (', after=')', advance='yes' )
    else
      call output( '*** Uh-oh, name not found in string table', advance='yes' )
    endif
    ! First dump the xStar and yStar
    if ( myDetails == 1 .or. myDetails > 2 ) then
      call dump ( l2pc%j%col%vec, details=details, name='xStar' )
      call dump ( l2pc%j%row%vec, details=details, name='yStar' )

      ! Now dump kStar
      call dump ( l2pc%j, 'kStar', details )
    endif

    ! Now dump the Hessian
    if ( l2pc%goth .and. myDetails > 1 ) &
      & call dump ( l2pc%h, 'hStar', details, onlyTheseBlocks )

  end subroutine DumpOneL2PC

  ! --------------------------------------- DumpL2PCInfo ---------------
  subroutine DumpL2PCInfo ( L2PCInfo, details )
    ! This subroutine dumps an l2pc to stdout

    ! Dummy arguments
    type (L2PCInfo_T), intent(in) :: L2PCInfo
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but size
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 0
    ! Local variables
    integer :: myDetails
    ! Executable
    myDetails = 0
    if ( present(details) ) myDetails = details
    call outputNamedValue ( 'fileID', L2PCInfo%fileID )
    call outputNamedValue ( 'binID', L2PCInfo%binID )
    call outputNamedValue ( 'blocksID', L2PCInfo%blocksID )
    call outputNamedValue ( 'hblocksID', L2PCInfo%hBlocksID )
    call outputNamedValue ( 'matrixName', trim(L2PCInfo%matrixName) )
    if ( myDetails > 0 ) call dump( L2PCInfo%blockID, 'BlockID' )
  end subroutine DumpL2PCInfo

  ! ---------------------------------- LoadMatrix ----------
  subroutine LoadMatrix ( matrix, name, message, IgnoreHessian )
    ! This function copies the matrix from the l2pc database into the
    ! given matrix (presumably from the main dabase)

    ! Dummy arguments
    type(Matrix_T), intent(inout) :: MATRIX
    integer, intent(in) :: NAME
    character (len=*), intent(out) :: MESSAGE
    logical, intent(in), optional :: IgnoreHessian

    ! Local variables
    integer :: I                        ! Index
    type(Matrix_T), pointer :: SOURCE

    ! Executable code
    message = ''
    i = FindFirst ( l2pcDatabase%name, name )
    if ( i == 0 ) then
      message = 'No such l2pc matrix'
      return
    end if
    call PopulateL2PCBin ( i, ignoreHessian )
    source => l2pcDatabase(i)%j
    if ( .not. DoVectorsMatch ( matrix%row%vec, source%row%vec ) ) then
      message = 'Rows do not match for loading'
      return
    endif
    if ( .not. DoVectorsMatch ( matrix%col%vec, source%col%vec ) ) then
      message = 'Columns do not match for loading'
      return
    endif
    call CopyMatrixValue ( matrix, source, allowNameMismatch=.true. )
  end subroutine LoadMatrix

  ! ---------------------------------- LoadVector ----------
  subroutine LoadVector ( vector, name, source, message, IgnoreHessian )
    ! This function copies the matrix from the l2pc database into the
    ! given matrix (presumably from the main dabase)

    ! Dummy arguments
    type(Vector_T), intent(inout) :: VECTOR
    integer, intent(in) :: NAME
    integer, intent(in) :: SOURCE       ! l_rows or l_columns
    character (len=*), intent(out) :: MESSAGE
    logical, intent(in), optional :: IgnoreHessian

    ! Local variables
    integer :: I                        ! Index
    type(Matrix_T), pointer :: MATRIX
    type(Vector_T), pointer :: SOURCEVECTOR

    ! Executable code
    message = ''
    i = FindFirst ( l2pcDatabase%name, name )
    if ( i == 0 ) then
      message = 'No such l2pc matrix'
      return
    end if
    call PopulateL2PCBin ( i, ignoreHessian )
    matrix => l2pcDatabase(i)%j
    select case ( source )
    case ( l_rows )
      sourceVector => matrix%row%vec
    case ( l_columns )
      sourceVector => matrix%col%vec
    end select
    if ( .not. DoVectorsMatch ( vector, sourceVector ) ) then
      message = 'Vector does not match for loading'
      return
    endif
    ! Use the clone option to avoid fussyness with vector templates
    call CopyVector ( vector, sourceVector, allowNameMismatch=.true. )
  end subroutine LoadVector

d359 140
d528 75
d1968 1
a1968 1
       "$Id: L2PC_m.f90,v 2.104 2010/09/17 00:02:57 pwagner Exp $"
d1978 3
@


2.104
log
@Can constrain which blocks dumped by name
@
text
@d1567 1
a1567 1
    use MLSSignals_m, only: Radiometers
d1709 1
a1709 1
        else
d1711 5
d1940 1
a1940 1
       "$Id: L2PC_m.f90,v 2.103 2010/08/31 02:05:38 vsnyder Exp $"
d1950 3
@


2.103
log
@Don't nullufy qt%channels before allocating, to avoid leaking memory
@
text
@d576 2
a577 1
  subroutine OutputHDF5L2PC ( filename, matrices, hessians, quantitiesNode, packed, dontPack )
d579 2
d585 1
d590 2
d593 3
d597 3
a599 4
    integer :: FIELD                    ! Node index
    integer :: DB_INDEX                 ! Index of matrix
    integer :: NXT_INDEX                ! Index of next matrix (Hessian?)
    logical :: GOTH                     ! True if there is a Hessian
d608 10
d633 2
a634 1
        call writeOneHDF5L2PC ( tmpMatrix, fileID, packed, dontPack, hessian=tmpHessian )
d647 2
a648 1
  subroutine WriteOneHDF5L2PC ( JACOBIAN, fileID, packed, dontPack, hessian )
d661 1
d1935 1
a1935 1
       "$Id: L2PC_m.f90,v 2.102 2010/08/27 21:55:35 pwagner Exp $"
d1945 3
@


2.102
log
@WIll not try to write empty Hessian blocks
@
text
@a1688 1
          nullify ( qt%channels )
d1914 1
a1914 1
       "$Id: L2PC_m.f90,v 2.101 2010/08/20 23:19:50 pwagner Exp $"
d1924 3
@


2.101
log
@May specify which blocks to dump by name; dont dump empty blocks
@
text
@d22 3
a28 3
  use HessianModule_0, only: CreateBlock, HessianElement_T, &
    & H_Absent, H_Sparse, H_Full, H_Unknown, DestroyBlock
  use HessianModule_1, only: Hessian_T, CreateBlock, DestroyHessian, CreateEmptyHessian
d41 1
a41 1
  use MLSStringLists, only: switchDetail
d58 1
a58 1
  implicit NONE
d240 2
d244 3
d255 1
a255 1
    if ( details == 1 .or. details > 2 ) then
d264 1
a264 1
    if ( l2pc%goth .and. details > 1 ) &
d505 4
d518 2
d521 2
d631 1
d775 1
d780 7
d823 2
a824 2

              if ( h0%kind == h_full ) then
d826 1
a826 2
              end if
              if ( h0%kind == h_sparse ) then
d836 1
a836 1
              end if
d1030 1
a1030 1
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F, H5GGET_OBJ_INFO_IDX_F, &
d1032 1
a1032 1
    use MLSHDF5, only: GetHDF5Attribute, LoadFromHDF5DS
d1048 2
d1164 9
a1172 1
              call LoadFromHDF5DS ( blockId, 'i', h0%values )
d1915 1
a1915 1
       "$Id: L2PC_m.f90,v 2.100 2010/08/13 22:22:59 pwagner Exp $"
d1925 3
@


2.100
log
@details now can choose between matrices, hessians; fixed a bug in reading HessianBlocks
@
text
@d231 1
a231 1
  subroutine DumpOneL2PC ( L2pc, details )
d239 1
d259 2
a260 1
    if ( l2pc%goth .and. details > 1 ) call dump ( l2pc%h, 'hStar', details )
d761 4
a764 2
              ! Skip the absent ones in order to make life simpler
!             if ( h0%kind == h_absent ) cycle
d879 2
a880 1
      if ( count ( l2pcInfo%fileID == l2pcInfo(i)%fileID ) == 1 ) then
d882 2
d1433 1
a1433 1
          call output( 'trying to read this hessian blodk', advance='yes' )
d1450 1
a1450 1
              if ( switchDetail( switches, 'hess' ) > -1 ) &
d1884 1
a1884 1
       "$Id: L2PC_m.f90,v 2.99 2010/08/06 22:58:40 pwagner Exp $"
d1894 3
@


2.99
log
@Added new 'hess' switch; using only switchDetail now
@
text
@d191 3
d213 3
d249 3
a251 2
    call dump ( l2pc%j%col%vec, details=details, name='xStar' )
    call dump ( l2pc%j%row%vec, details=details, name='yStar' )
d253 3
a255 2
    ! Now dump kStar
    call dump ( l2pc%j, 'kStar', details )
d258 1
a258 1
    if ( l2pc%goth ) call dump ( l2pc%h, 'hStar', details )
d1170 2
a1171 2
  ! --------------------------------------- ReadCompleteHDF5L2PC -------
  subroutine ReadCompleteHDF5L2PCFile ( MLSFile, Where )
d1177 1
d1181 2
d1186 2
a1188 3
    integer :: NOBINS          ! Number of bins
    integer :: BIN             ! Loop counter
    integer :: DUMMY           ! Ignored return from AddToDatabase
d1191 2
d1217 1
a1217 1
        & shallow=.true., info=Info )
d1413 2
d1416 1
a1416 1
      MLSFile%fileID%sd_id = blocksID
d1419 2
d1425 6
d1436 1
a1436 1
              call h5gOpen_f ( blocksId, trim(name), blockId, status )
d1438 1
a1438 1
                & 'Unable to open group for l2pc matrix block '//trim(name) , &
d1443 2
d1471 3
a1473 1
        ! Otherwise, flag the whole matrix as unknown
d1486 1
a1486 1
      call h5gClose_f ( blocksID, status )
d1877 1
a1877 1
       "$Id: L2PC_m.f90,v 2.98 2010/06/28 17:00:49 pwagner Exp $"
d1887 3
@


2.98
log
@Fixed a few bugs
@
text
@d755 2
d768 2
d776 2
d786 2
d799 4
d850 1
a850 1
      if ( index ( switches, 'l2pc' ) > 0 ) &
d1024 1
a1024 1
    if ( index ( switches, 'l2pc' ) > 0 ) then
d1158 1
a1158 1
    if ( index ( switches, 'spa' ) /= 0 ) call dump_struct ( l2pc%j, 'Populated l2pc bin' )
d1195 1
a1195 1
    if ( index ( switches, 'l2pc' ) /= 0 ) then
d1208 1
a1208 1
      if ( index ( switches, 'spa' ) /= 0 ) call Dump_struct ( l2pc%j, 'One l2pc bin' ) 
d1270 1
a1270 1
    if ( index ( switches, 'l2pc' ) /= 0 ) &
d1278 1
a1278 1
    if ( index ( switches, 'l2pc' ) /= 0 ) &
d1390 1
a1390 1
    if ( index ( switches, 'l2pc' ) > 0 ) then
d1533 1
a1533 1
    if ( index ( switches, 'l2pc' ) /= 0 ) then
d1552 1
a1552 1
      if ( index ( switches, 'l2pc' ) /= 0) &
d1578 1
a1578 1
      if ( index ( switches, 'l2pc' ) /= 0 ) then
d1712 1
a1712 1
    if ( index ( switches, 'l2pc' ) /= 0 ) &
d1715 1
a1715 1
    if ( index ( switches, 'l2pc' ) /= 0 ) &
d1721 1
a1721 1
      if ( index ( switches, 'l2pc' ) /= 0 ) then
d1851 1
a1851 1
       "$Id: L2PC_m.f90,v 2.97 2010/05/20 00:51:50 pwagner Exp $"
d1861 3
@


2.97
log
@Can populate Hessians; untested
@
text
@d126 1
d1104 7
a1110 1
            select case (h0%kind)
d1117 1
d1125 4
d1130 1
a1130 1
                & 'Unrecognized kind for l2pc Hessian block '//trim(name) )
d1413 1
d1839 1
a1839 1
       "$Id: L2PC_m.f90,v 2.96 2010/05/19 17:51:41 pwagner Exp $"
d1849 3
@


2.96
log
@Details now used to dump or not L2PCInfo%blockID
@
text
@d38 1
a38 1
    & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMSG_ERROR
d991 1
a992 1
    integer :: BLOCKROW  ! Loop counter
d996 3
a998 1
    integer :: BLOCKSID  ! Group ID for all the non-Hessian blocks
d1024 2
a1025 1
        & 'Unable to open Blocks group for l2pc matrix block '//trim(info%matrixName) )
d1077 54
a1130 2
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to fully populate L2PC Bin when we have a Hessian matrix' )
d1826 1
a1826 1
       "$Id: L2PC_m.f90,v 2.95 2010/05/19 00:32:06 vsnyder Exp $"
d1836 3
@


2.95
log
@Pass IgnoreHessian into PopulateL2PCBin
@
text
@d22 1
a22 1
  use Intrinsic, only: L_CHANNEL, L_GEODALTITUDE, L_ZETA, L_NONE, L_VMR, &
a28 1
  use machine, only: io_error
d265 1
a265 1
    integer :: i
d267 2
d274 1
a528 1
    type ( MatrixElement_T), pointer :: M0
d1771 1
a1771 1
       "$Id: L2PC_m.f90,v 2.94 2010/05/13 23:45:14 pwagner Exp $"
d1781 3
@


2.94
log
@Temporary expedients for l2pc files with Hessians; needs more code
@
text
@d276 1
a276 1
  subroutine LoadMatrix ( matrix, name, message )
d284 1
d297 1
a297 1
    call PopulateL2PCBin ( i )
d311 1
a311 1
  subroutine LoadVector ( vector, name, source, message )
d320 1
d334 1
a334 1
    call PopulateL2PCBin ( i )
d969 1
a969 1
  subroutine PopulateL2PCBinByName ( name )
d971 1
d975 1
a975 1
    if ( index /= 0 ) call PopulateL2PCBin ( index )
d979 1
a979 1
  subroutine PopulateL2PCBin ( bin )
d985 1
a995 1
    integer :: STATUS    ! Flag from HDF5
d997 1
d999 1
d1070 3
a1072 1
    if ( l2pc%goth ) then
d1770 1
a1770 1
       "$Id: L2PC_m.f90,v 2.93 2010/04/30 22:55:32 vsnyder Exp $"
d1780 3
@


2.93
log
@Give more meaningful names to vectors
@
text
@d28 1
a28 1
  use HessianModule_1, only: Hessian_T, DestroyHessian, CreateEmptyHessian
d1066 3
a1068 1
      stop !!! CODE HERE
d1337 1
a1337 1
                call CreateBlock ( l2pc%j, i, j, k, kind, noValues )
d1340 1
a1340 1
                call CreateBlock ( l2pc%j, i, j, k, kind, noValues )
d1347 1
a1347 1
                call CreateBlock ( l2pc%j, i, j, k, kind )
d1363 1
a1363 1
              call CreateBlock ( l2pc%j, i, j, k, h_unknown )
d1763 1
a1763 1
       "$Id: L2PC_m.f90,v 2.92 2010/04/17 01:43:35 vsnyder Exp $"
d1773 3
@


2.92
log
@Simplify dump.  Set l2pc%goth if there is a Hessian block.
@
text
@d1624 1
a1624 1
    v = CreateVector ( 0, l2pcVTs(vtIndex), l2pcQTs, vectorNameText='_v' )
d1761 1
a1761 1
       "$Id: L2PC_m.f90,v 2.91 2010/03/24 20:48:55 vsnyder Exp $"
d1771 3
@


2.91
log
@Replace 'continue' by 'cycle'.  Call OptimizeBlock from WriteOneHDF5L2PC
when writing a Hessian, to avoid trying to write empty arrays.  Add some
comments.  Fix a wrong-subscript bug.
@
text
@d33 3
a35 3
  use MatrixModule_1, only: CREATEBLOCK, CREATEEMPTYMATRIX, &
    & DESTROYMATRIX, MATRIX_T, DUMP, FINDBLOCK, MATRIX_DATABASE_T, &
    & GETACTUALMATRIXFROMDATABASE, DUMP_STRUCT, COPYMATRIXVALUE
d52 1
a52 1
  use String_Table, only: GET_STRING
d55 3
a57 3
  use VectorsModule, only: assignment(=), DESTROYVECTORINFO, COPYVECTOR, &
    & VECTORTEMPLATE_T, VECTOR_T, CREATEVECTOR, ADDVECTORTODATABASE, &
    & ADDVECTORTEMPLATETODATABASE, CONSTRUCTVECTORTEMPLATE, NULLIFYVECTORTEMPLATE
d228 2
d232 1
a232 24
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but size
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 0

    ! Local parameters
    character (len=*), parameter :: rFmt = "(4(2x,1pg15.8))"
    character (len=*), parameter :: iFmt = "(8(2x,i6))"

    ! Local variables
    integer :: AdjustedIndex            ! Index into quantities not skipped
    integer :: BlockCol                 ! Index
    integer :: BlockRow                 ! Index
    integer :: myDetails
    integer :: Quantity                 ! Loop counter
    integer :: Vector                   ! Loop counter


    character (len=132) :: Line, Word1, Word2 ! Line of text

    type (MatrixElement_T), pointer :: M0 ! A Matrix0 within kStar
    type (QuantityTemplate_T), pointer :: Qt  ! Temporary pointers
    type (Vector_T), pointer :: V       ! Temporary pointer
a234 3
    myDetails = 0
    if ( present(details) ) myDetails = details

a235 1
    call outputNamedValue( 'name as index in string table', l2pc%name )
d237 2
a238 2
      call get_string ( l2pc%name, line )
      call outputNamedValue( 'name', trim(line) )
d243 2
a244 9
    do vector = 1, 2
      ! Identify vector
      if ( vector == 1 ) then
        call output( 'xStar', advance='yes' )
        v => l2pc%j%col%vec
      else
        call output( 'yStar', advance='yes' )
        v => l2pc%j%row%vec
      end if
d246 2
a247 46
      call outputNamedValue( 'size', size(v%quantities) )
      if ( myDetails < -1 ) return
      ! Loop over quantities
      do quantity = 1, size(v%quantities)
          qt => v%quantities(quantity)%template

          ! Write quantity name - will be ignored on the read (at least by
          ! fortran, IDL pays attention
          call get_string ( qt%name, line )
          call outputNamedValue( 'quantity name', trim(line) )

          ! Write quantity type
          call get_string ( lit_indices(qt%quantityType), line )
          call outputNamedValue( 'quantity type', trim(line) )

          ! Write other info associated with type
          select case ( qt%quantityType )
          case (l_vmr)
            call get_string ( lit_indices(qt%molecule), line )
            call outputNamedValue( 'molecule', trim(line) )
          case (l_radiance)
            call GetSignalName ( qt%signal, line, sideband=qt%sideband )
            call outputNamedValue( 'signal', trim(line) )
          end select

          ! Write out the dimensions for the quantity and the edges
          call outputNamedValue( 'noChans', qt%noChans )
          call outputNamedValue( 'noSurfs', qt%noSurfs )
          call outputNamedValue( 'noInstances', qt%noInstances )
          call outputNamedValue( 'coherent', qt%coherent )
          call outputNamedValue( 'stacked', qt%stacked )
          call get_string ( lit_indices(qt%verticalCoordinate), line )
          call outputNamedValue( 'vertical coordinate', trim(line) )
          if ( myDetails < 0 ) cycle
          call dump( qt%surfs, 'surfs' )
          call dump( qt%phi, 'phi' )

      end do                            ! First loop over quantities
      if ( myDetails < 1 ) return
      ! Now do a second loop and write the values
      adjustedIndex = 1
      do quantity = 1, size ( v%quantities )
          call dump( v%quantities(quantity)%values, 'values' )
      end do                            ! Second loop over quantities

    end do                              ! Loop over xStar/yStar
d249 2
a250 31
    ! Now dump kStar
    call output( 'kStar', advance='yes' )
    call outputNamedValue( 'row instances first', l2pc%j%row%instFirst )
    call outputNamedValue( 'column instances first', l2pc%j%col%instFirst )
    do blockRow = 1, l2pc%j%row%NB
      do blockCol = 1, l2pc%j%col%NB
        ! Print the type of the matrix
          m0 => l2pc%j%block(blockRow, blockCol)
          call outputNamedValue( 'row', blockRow )
          call outputNamedValue( 'col', blockCol )
          call outputNamedValue( 'kind', m0%kind )
          call get_string ( &
            & l2pc%j%row%vec%quantities(&
            &    l2pc%j%row%quant(blockRow))%template%name, word1 )
          call get_string ( &
            & l2pc%j%col%vec%quantities(&
            &    l2pc%j%col%quant(blockCol))%template%name, word2 )
          call outputNamedValue( trim(word1), l2pc%j%row%inst(blockRow) )
          call outputNamedValue( trim(word2), l2pc%j%col%inst(blockRow) )
          select case (m0%kind)
          case (M_Absent)
          case (M_Banded, M_Column_sparse)
            call outputNamedValue( 'no value', size(m0%values) )
            call dump( m0%R1, 'R1' )
            call dump( m0%R2, 'R2' )
            call dump( m0%values, 'values' )
          case (M_Full)
            call dump( m0%values, 'values' )
          end select
      end do
    end do
d977 4
a980 3
  use HDF5, only: H5GCLOSE_F, H5GOPEN_F, H5GGET_OBJ_INFO_IDX_F, &
      & H5GN_MEMBERS_F
  use MLSHDF5, only: GetHDF5Attribute, LoadFromHDF5DS
d1311 2
a1312 1
    if ( status == 0 .and. nmembers > 3 ) then
d1379 5
a1383 6
    if ( switchDetail( switches, 'l2pc' ) > 0 ) then
      call dump_struct (l2pc%j)
      call dump (l2pc)
    endif
    if ( index ( switches, 'l2pc' ) /= 0 ) &
      & call output ( 'Done reading bin from l2pc file', advance='yes' )
d1462 2
a1463 4
      if ( index ( switches, 'l2pc' ) /= 0) then
        call output ( 'Identifying quantity ' )
        call output ( quantity, advance='yes' )
      end if
d1489 1
a1489 2
        call output ( 'Reading quantity ' )
        call output ( quantity )
d1761 1
a1761 1
       "$Id: L2PC_m.f90,v 2.90 2010/03/19 20:18:47 pwagner Exp $"
d1771 5
@


2.90
log
@Moved DumpL2PCInfo out of public scope to appease ifort v10 which crashed the goldbrick
@
text
@d38 2
a39 2
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, &
    & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE
d61 1
a61 1
  
d153 1
a153 1
    
d155 1
a155 1
    
d158 1
a158 1
    
d168 1
a168 1
    
d170 1
a170 1
    
d173 1
a173 1
    
d288 1
a288 1
          
d292 1
a292 1
          
d302 1
a302 1
          
d324 1
a324 1
    
d548 1
a548 1
    
d575 1
a575 1
      if ( jh == 2 .and. .not. l2pc%gotH ) continue
d590 1
a590 1
        
d597 1
a597 1
      
d601 1
a601 1
    
d707 3
a709 2
  use HDF5, only: H5GCLOSE_F, H5GCREATE_F
  use MLSHDF5, only: MakeHDF5Attribute, SaveAsHDF5DS
d836 1
a836 1
      
d851 1
d853 1
a853 1
              if ( h0%kind == h_absent ) continue
d861 1
d867 1
a867 1
              
d873 1
a873 1
              
d876 1
a876 1
                &    hessian%col%quant(j))%template%name, name )
d879 1
a879 1
              
d882 1
a882 1
              
d901 1
a901 1
    
d913 1
a913 1
  
d975 1
a975 1
    
d1046 1
a1046 1
    
d1068 1
a1068 1
    
d1146 1
a1146 1
        
d1216 1
a1216 1
    
d1239 1
a1239 1
    
d1324 1
a1324 1
    
d1470 1
a1470 1
    
d1488 1
a1488 1
    
d1684 1
a1684 1
      
d1695 1
a1695 1
      
d1725 1
a1725 1
    
d1727 1
a1727 1
    
d1735 1
a1735 1
    
d1757 1
a1757 1
      
d1868 1
a1868 1
       "$Id: L2PC_m.f90,v 2.89 2010/03/17 20:59:10 pwagner Exp $"
d1878 3
@


2.89
log
@Code around bombs in DestroyL2PCInfoDatabase
@
text
@d72 4
d940 1
a940 1
        call dump( l2pcInfo(i) )
d1865 1
a1865 1
       "$Id: L2PC_m.f90,v 2.88 2010/02/25 18:04:45 pwagner Exp $"
d1875 3
@


2.88
log
@l2pc type can now hold matrix and Hessian types
@
text
@d72 1
a72 1
    module procedure DUMPONEL2PC, DumpL2PCDatabase, DumpL2PCFile
d125 2
d355 21
d922 1
a922 1
  use HDF5, only: H5FClose_F, H5GCLOSE_F
d930 1
d932 2
d935 3
a937 1
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d939 1
d942 1
a942 1
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d946 1
a946 1
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d957 1
d959 1
a959 1
    if ( i /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1125 1
d1861 1
a1861 1
       "$Id: L2PC_m.f90,v 2.87 2010/02/04 23:08:00 vsnyder Exp $"
d1871 3
@


2.87
log
@Remove USE or declaration for unused names
@
text
@d26 3
d42 1
d63 1
a63 1
    & binSelector_T, BinSelectors, close_l2pc_file, CreateDefaultBinSelectors, &
d66 2
a67 2
    & Dump, FlushL2PCBins, &
    & LoadMatrix, LoadVector, Open_l2pc_file, OutputHDF5L2PC, &
d69 1
a69 2
    & read_l2pc_file, ReadCompleteHDF5L2PCFile, &
    & WriteOneL2PC
d74 2
a75 1
  ! This is the third attempt to do this.  An l2pc is simply a Matrix_T.
d80 1
a80 1
  ! The l2pc database and supporting databases
a84 1
  type(Matrix_T), dimension(:), pointer, public, save :: L2PCDatabase => NULL()
d89 11
d116 1
d118 1
d120 1
a120 1
  type ( L2PCInfo_T), dimension(:), pointer, save :: L2PCINFO => NULL()
d165 2
a166 2
    type(Matrix_T), dimension(:), pointer :: Database
    type(Matrix_T) :: Item
d168 1
a168 1
    type(Matrix_T), dimension(:), pointer :: TempDatabase
d180 1
a180 1
    type (matrix_T), dimension(:), intent(in), target :: L2pcDB
d223 1
a223 1
    type (matrix_T), intent(in), target :: L2pc
d253 8
a261 1
    call output( '- Dump of L2PC -', advance='yes' )
d266 1
a266 1
        v => l2pc%col%vec
d269 1
a269 1
        v => l2pc%row%vec
d321 4
a324 4
    call outputNamedValue( 'row instances first', l2pc%row%instFirst )
    call outputNamedValue( 'column instances first', l2pc%col%instFirst )
    do blockRow = 1, l2pc%row%NB
      do blockCol = 1, l2pc%col%NB
d326 1
a326 1
          m0 => l2pc%block(blockRow, blockCol)
d331 2
a332 2
            & l2pc%row%vec%quantities(&
            &    l2pc%row%quant(blockRow))%template%name, word1 )
d334 4
a337 4
            & l2pc%col%vec%quantities(&
            &    l2pc%col%quant(blockCol))%template%name, word2 )
          call outputNamedValue( trim(word1), l2pc%row%inst(blockRow) )
          call outputNamedValue( trim(word2), l2pc%col%inst(blockRow) )
d375 1
a375 1
    source => l2pcDatabase(i)
d411 1
a411 1
    matrix => l2pcDatabase(i)
d457 1
a457 1
    m => l2pcDatabase(i)
a492 6
  ! -----------------------------------  Close_L2PC_File  -----
  subroutine Close_L2PC_File ( Lun )
    integer, intent(in) :: lun
    close ( lun )
  end subroutine Close_L2PC_File

d538 1
a538 1
    type (Matrix_T), intent(inout), target :: L2PC
d542 1
d547 21
a567 9
    do vector = 1, 2
      if ( vector == 1 ) then
        v => l2pc%col%vec
      else
        v => l2pc%row%vec
      end if
      
      do quantity = 1, size(v%quantities)
        call DestroyQuantityTemplateContents (v%quantities(quantity)%template )
a568 1
      call DestroyVectorInfo ( v )
d570 1
a570 1
    
d572 2
a573 1
    call DestroyMatrix ( l2pc )
d599 2
a600 3
    integer :: BIN              ! Loop counter
    integer :: BLOCKROW         ! Loop counter
    integer :: BLOCKCOL         ! Loop counter
d602 1
a602 1
    type ( Matrix_T ), pointer :: L2PC
d609 3
a611 7
      do blockRow = 1, l2pc%row%NB
        do blockCol = 1, l2pc%col%NB
          m0 => l2pc%block ( blockRow, blockCol )
          if ( m0%kind /= m_absent ) then
            call DestroyBlock ( m0 )
            m0%kind = M_Unknown
          end if
d614 9
a625 21
  ! ------------------------------------ open_l2pc_file ------------
  subroutine Open_L2PC_File ( Filename, Lun )

    character(len=*), intent(in) :: Filename ! Name of the antenna pattern file
    integer, intent(out) :: Lun              ! Logical unit number to read it

    logical :: Exist, Opened
    integer :: Status

    do lun = 20, 99
      inquire ( unit=lun, exist=exist, opened=opened )
      if ( exist .and. .not. opened ) exit
    end do
    if ( opened .or. .not. exist ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "No logical unit numbers available" )
    open ( unit=lun, file=filename, status='old', form='formatted', &
      & access='sequential', iostat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "Unable to open l2pc file " // Filename )
  end subroutine Open_L2PC_File

d627 1
a627 1
  subroutine OutputHDF5L2PC ( filename, matrices, quantitiesNode, packed, dontPack )
d631 1
d641 2
d644 1
d651 3
a653 1
    do field = 2, nsons(quantitiesNode)
d656 16
a671 2
      call writeOneHDF5L2PC ( tmpMatrix, fileID, packed, dontPack )
    end do ! in_field_no = 2, nsons(gson)
a677 36
  ! ------------------------------------- Read_l2pc_file ------
  subroutine Read_l2pc_file ( Lun, Where )
    use Trace_M, only: Trace_begin, Trace_end
    use Toggles, only: Toggle, gen
    ! Read all the bins in an l2pc file
    integer, intent(in) :: lun
    integer, intent(in) :: Where ! In the L2CF tree, for tracing

    ! Local variables
    type (Matrix_T) :: L2pc
    integer :: Dummy
    logical :: Eof

    ! Executable code
    if ( toggle (gen) ) call trace_begin ( "Read_l2pc_file", where )
    eof = .false.
    do while (.not. eof )
      call ReadOneASCIIL2PC ( l2pc, lun, eof )
      if (.not. eof) then
        dummy = AddL2PCToDatabase ( l2pcDatabase, l2pc )
        dummy = AddFileIDToDatabase ( fileIDDatabase, lun )
      endif
      if ( index ( switches, 'spa' ) /= 0 ) call Dump_struct ( l2pc, 'One l2pc bin' ) 

      ! Now nullify the pointers in l2pc so we don't clobber the one we've written
      nullify ( l2pc%block )
      nullify ( l2pc%row%nelts, l2pc%row%inst, l2pc%row%quant )
      nullify ( l2pc%col%nelts, l2pc%col%inst, l2pc%col%quant )
      nullify ( l2pc%row%vec%template%quantities, l2pc%col%vec%template%quantities )
      nullify ( l2pc%row%vec%quantities, l2pc%col%vec%quantities )
      
    end do

    if ( toggle (gen) ) call trace_end ( "Read_l2pc_file" )
  end subroutine Read_l2pc_file

d679 1
a679 1
  subroutine WriteOneHDF5L2PC ( L2pc, fileID, packed, dontPack )
d685 1
a685 1
    type (matrix_T), intent(in), target :: L2PC
d689 1
d692 3
a694 4
    integer :: BlockCol                 ! Index
    integer :: BlockRow                 ! Index
    integer :: BlocksGroupID            ! ID of group containing all blocks
    integer :: BlockGroupID             ! ID of this block group
d698 4
a701 4
    integer, dimension(l2pc%row%nb) :: ROWBLOCKMAP
    integer, dimension(l2pc%col%nb) :: COLBLOCKMAP
    logical, dimension(l2pc%row%vec%template%noQuantities), target :: ROWPACK
    logical, dimension(l2pc%col%vec%template%noQuantities), target :: COLPACK
d705 2
a706 1
    type (MatrixElement_T), pointer :: M0 ! A Matrix0 within kStar
d709 11
d723 1
a723 1
      call MakeMatrixPackMap ( l2pc, rowPack, colPack, rowBlockMap, colBlockMap, dontPack )
d727 2
a728 2
      do blockRow = 1, l2pc%row%nb
        rowBlockMap(blockRow) = blockRow
d730 2
a731 2
      do blockCol = 1, l2pc%col%nb
        colBlockMap(blockCol) = blockCol
d736 1
a736 1
    call get_string ( l2pc%name, name, strip=.true., cap=.true. )
d742 2
a743 2
    call WriteVectorAsHDF5L2PC ( matrixID, l2pc%col%vec, 'Columns', colPack )
    call WriteVectorAsHDF5L2PC ( matrixID, l2pc%row%vec, 'Rows', rowPack )
d746 1
a746 1
    call h5gCreate_f ( matrixID, 'Blocks', blocksGroupID, status )
d751 2
a752 2
    call MakeHDF5Attribute ( blocksGroupID, 'rowInstanceFirst', l2pc%row%instFirst )
    call MakeHDF5Attribute ( blocksGroupID, 'colInstanceFirst', l2pc%col%instFirst )
d755 2
a756 2
    do blockRow = 1, l2pc%row%NB
      do blockCol = 1, l2pc%col%NB
d758 2
a759 2
        if ( rowPack(l2pc%row%quant(blockRow)) .and. &
          &  colPack(l2pc%col%quant(blockCol)) ) then
d761 1
a761 1
          m0 => l2pc%block(blockRow, blockCol)
d763 2
a764 2
          ! write ( name, * ) 'Block', rowBlockMap(blockRow), colBlockMap(blockCol)
          call CreateBlockName( rowBlockMap(blockRow), colBlockMap(blockCol), name )
d766 1
a766 1
          call h5gCreate_f ( blocksGroupID, trim(name), blockGroupID, status )
d768 1
a768 1
            & 'Unable to create group for l2pc matrix block' )
d771 3
a773 3
            & l2pc%row%vec%quantities(&
            &    l2pc%row%quant(blockRow))%template%name, name )
          call MakeHDF5Attribute ( blockGroupID, 'rowQuantity', trim(name) )
d775 6
a780 6
            & l2pc%col%vec%quantities(&
            &    l2pc%col%quant(blockCol))%template%name, name )
          call MakeHDF5Attribute ( blockGroupID, 'colQuantity', trim(name) )
          call MakeHDF5Attribute ( blockGroupID, 'rowInstance', l2pc%row%inst(blockRow) )
          call MakeHDF5Attribute ( blockGroupID, 'colInstance', l2pc%col%inst(blockCol) )
          call MakeHDF5Attribute ( blockGroupID, 'kind', m0%kind )
d783 1
a783 1
            call SaveAsHDF5DS ( blockGroupID, 'values', real ( m0%values, r4 ) )
d785 3
a787 3
              call MakeHDF5Attribute ( blockGroupID, 'noValues', size(m0%values) )
              call SaveAsHDF5DS ( blockGroupID, 'r1', m0%r1 )
              call SaveAsHDF5DS ( blockGroupID, 'r2', m0%r2 )
d791 1
a791 1
          call h5gClose_f ( blockGroupID, status )
d799 1
a799 1
    call h5gClose_f ( blocksGroupID, status )
d803 75
a883 150
  ! --------------------------------------- WriteOneL2PC ---------------
  subroutine WriteOneL2PC ( L2pc, Unit, packed )
    ! This subroutine writes an l2pc to a file
    ! Currently this file is ascii, later it will be
    ! some kind of HDF file

    ! Dummy arguments
    type (matrix_T), intent(in), target :: L2pc
    integer, intent(in) :: Unit
    logical, intent(in) :: PACKED

    ! Local parameters
    character (len=*), parameter :: rFmt = "(4(2x,1pg15.8))"
    character (len=*), parameter :: iFmt = "(8(2x,i6))"

    ! Local variables
    integer :: AdjustedIndex            ! Index into quantities not skipped
    integer :: BlockCol                 ! Index
    integer :: BlockRow                 ! Index
    integer :: Quantity                 ! Loop counter
    integer :: Vector                   ! Loop counter

    logical, dimension(l2pc%row%vec%template%noQuantities), target :: ROWPACK
    logical, dimension(l2pc%col%vec%template%noQuantities), target :: COLPACK
    logical, dimension(:), pointer :: THISPACK

    character (len=132) :: Line, Word1, Word2 ! Line of text

    type (MatrixElement_T), pointer :: M0 ! A Matrix0 within kStar
    type (QuantityTemplate_T), pointer :: Qt  ! Temporary pointers
    type (Vector_T), pointer :: V       ! Temporary pointer

    ! Executable code

    ! Work out which quantities we can skip
    if ( packed ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Cannot pack ASCII L2PC files any more (never worked anyway!)' ) 
      ! call MakeMatrixPackMap ( l2pc, rowPack, colPack )
    else
      rowPack = .true.
      colPack = .true.
    end if

    ! First dump the xStar and yStar
    do vector = 1, 2
      ! Identify vector
      if ( vector == 1 ) then
        write (unit,*) 'xStar'
        v => l2pc%col%vec
        thisPack => colPack
      else
        write (unit,*) 'yStar'
        v => l2pc%row%vec
        thisPack => rowPack
      end if

      write (unit,*) count ( thisPack )
      ! Loop over quantities
      do quantity = 1, size(v%quantities)
        if ( thisPack(quantity) ) then
          qt => v%quantities(quantity)%template

          ! Write quantity name - will be ignored on the read (at least by
          ! fortran, IDL pays attention
          call get_string ( qt%name, line )
          write (unit,*) trim(line)
          
          ! Write quantity type
          call get_string ( lit_indices(qt%quantityType), line )
          write (unit,*) trim(line)
          
          ! Write other info associated with type
          select case ( qt%quantityType )
          case (l_vmr)
            call get_string ( lit_indices(qt%molecule), line )
            write (unit,*) trim(line)
          case (l_radiance)
            call GetSignalName ( qt%signal, line, sideband=qt%sideband )
            write (unit,*) trim(line)
          end select
          
          ! Write out the dimensions for the quantity and the edges
          write (unit,*) qt%noChans, qt%noSurfs, qt%noInstances, &
            &  'noChans, noSurfs, noInstances'
          call get_string ( lit_indices(qt%verticalCoordinate), line )
          write (unit,*) qt%coherent, qt%stacked, trim(line), &
            &  ' coherent, stacked, verticalCoordinate'
!           if ( all (qt%verticalCoordinate /= (/ l_none, l_zeta /)) &
!             & .and. (vector==1) .and. (qt%quantityType /= l_ptan) ) &
!             &   call MLSMessage(MLSMSG_Error,ModuleName, &
!             &     "Only zeta coordinates allowed (or none) for xStar.")
          write (unit,*) 'surfs'
          write (unit, rFmt) qt%surfs
          write (unit,*) 'phi'
          write (unit, rFmt) qt%phi

        end if
      end do                            ! First loop over quantities

      ! Now do a second loop and write the values
      adjustedIndex = 1
      do quantity = 1, count ( thisPack )
        if ( thisPack(quantity) ) then
          write (unit,*) 'values', adjustedIndex
          write (unit,rFmt) v%quantities(quantity)%values
          adjustedIndex = adjustedIndex + 1
        end if
      end do                            ! Second loop over quantities

    end do                              ! Loop over xStar/yStar
    
    ! Now dump kStar
    write (unit,*) 'kStar'
    write (unit,*) l2pc%row%instFirst, l2pc%col%instFirst, 'Instances first'
    do blockRow = 1, l2pc%row%NB
      do blockCol = 1, l2pc%col%NB
        ! Print the type of the matrix
        if ( rowPack(l2pc%row%quant(blockRow)) .and. &
          &  colPack(l2pc%col%quant(blockCol)) ) then
          m0 => l2pc%block(blockRow, blockCol)
          write (unit,*) blockRow, blockCol, m0%kind,&
            & 'row, col, kind'
          call get_string ( &
            & l2pc%row%vec%quantities(&
            &    l2pc%row%quant(blockRow))%template%name, word1 )
          call get_string ( &
            & l2pc%col%vec%quantities(&
            &    l2pc%col%quant(blockCol))%template%name, word2 )
          write (unit,*) trim(word1), l2pc%row%inst(blockRow), ' , ',&
            &            trim(word2), l2pc%col%inst(blockCol)
          select case (m0%kind)
          case (M_Absent)
          case (M_Banded, M_Column_sparse)
            write (unit,*) size(m0%values), ' no values'
            write (unit,*) 'R1'
            write (unit,iFmt) m0%R1
            write (unit,*) 'R2'
            write (unit,iFmt) m0%R2
            write (unit,*) 'values'
            write (unit,rFmt) m0%values
          case (M_Full)
            write (unit,rFmt) m0%values
          end select
        end if
      end do
    end do

  end subroutine WriteOneL2PC

d886 1
a886 1
  ! ------------------------------------ AddBinSelectorToDatabase --
d911 5
d934 1
a934 1
  subroutine MakeMatrixPackMap ( m, rowPack, colPack, rowBlockMap, colBlockMap, dontpack )
d940 5
a944 5
    type (Matrix_T), intent(in) :: M
    logical, intent(out), dimension(M%row%vec%template%noQuantities) :: ROWPACK
    logical, intent(out), dimension(M%col%vec%template%noQuantities) :: COLPACK
    integer, intent(out), dimension(M%row%NB) :: ROWBLOCKMAP
    integer, intent(out), dimension(M%col%NB) :: COLBLOCKMAP
d946 1
d951 2
d955 2
d959 4
a962 2
    logical, dimension(M%row%NB) :: ROWBLOCKFLAG ! Flags per row block
    logical, dimension(M%col%NB) :: COLBLOCKFLAG ! Flags per row block
a964 1

d971 7
a977 7
    do colQ = 1, m%col%vec%template%noQuantities
      do colI = 1, m%col%vec%quantities(colQ)%template%noInstances
        colBlock = FindBlock ( m%col, colQ, colI )
        do rowQ = 1, m%row%vec%template%noQuantities
          do rowI = 1, m%row%vec%quantities(rowQ)%template%noInstances
            rowBlock = FindBlock ( m%row, rowQ, rowI )
            if ( m%block ( rowBlock, colBlock ) % kind /= M_Absent ) then
d986 24
d1012 2
a1013 2
      do colQ = 1, m%col%vec%template%noQuantities
        if ( any ( dontPack == m%col%vec%template%quantities(colQ) ) ) &
d1016 2
a1017 2
      do rowQ = 1, m%row%vec%template%noQuantities
        if ( any ( dontPack == m%row%vec%template%quantities(rowQ) ) ) &
d1023 2
a1024 2
    rowBlockFlag = rowPack ( m%row%quant )
    do rowBlock = 1, m%row%nb
d1027 2
a1028 2
    colBlockFlag = colPack ( m%col%quant )
    do colBlock = 1, m%col%nb
d1045 2
a1046 1
  use HDF5, only: H5GCLOSE_F, H5GOPEN_F
d1051 3
a1053 3
    type ( Matrix_T ), pointer :: L2PC  ! This l2pc
    type ( L2PCInfo_T ), pointer :: INFO ! Info for this l2pc
    type ( MatrixElement_T ), pointer :: M0 
d1058 1
d1062 1
d1066 1
a1066 1
    if ( .not. any ( l2pc%block%kind == m_unknown ) ) return
d1069 18
a1086 2
    do blockRow = 1, l2pc%row%NB
      do blockCol = 1, l2pc%col%NB
d1088 1
a1088 1
        m0 => l2pc%block ( blockRow, blockCol )
d1092 14
a1105 5
        call CreateBlockName( blockRow, blockCol, name )
        call h5gOpen_f ( info%blocksId, trim(name), blockId, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to open group for l2pc matrix block '//trim(name) )

d1108 2
d1112 2
a1113 2
          call CreateBlock ( l2pc, blockRow, blockCol, kind, noValues )
          m0 => l2pc%block ( blockRow, blockCol )
d1117 2
a1118 2
          call CreateBlock ( l2pc, blockRow, blockCol, kind )
          m0 => l2pc%block ( blockRow, blockCol )
d1127 3
a1129 5
    if ( index ( switches, 'spa' ) /= 0 ) call dump_struct ( l2pc, 'Populated l2pc bin' )
!     if ( .not. CheckIntegrity ( l2pc ) ) then
!       call MLSMessage ( MLSMSG_Error, ModuleName, &
!         & 'L2PC failed integrity test' )
!     end if
d1131 3
a1133 1
  end subroutine PopulateL2PCBin
d1135 1
a1135 5
  ! -------------------------------------------  ReadOneASCIIL2PC  -----
  subroutine ReadOneASCIIL2PC ( L2pc, Unit, Eof )
    ! This subroutine writes an l2pc to a file
    ! Currently this file is ascii, later it will be
    ! some kind of HDF file
d1137 1
a1137 263
    ! Dummy arguments
    type (Matrix_T), intent(out), target :: L2pc
    integer, intent(in) :: Unit
    logical, intent(inout) :: Eof

    ! Local variables
    integer :: BLOCKCOL                 ! Index
    integer :: BLOCKKIND                ! Kind of matrix block
    integer :: BLOCKROW                 ! Index
    integer :: NOVALUES                 ! For banded/sparse matrices
    integer :: TESTBLOCKROW             ! Test index
    integer :: TESTBLOCKCOL             ! Test index

    logical :: COLINSTFIRST             ! Matrix order
    logical :: ROWINSTFIRST             ! Matrix order

    character (len=132) :: Line         ! Line of text

    type (MatrixElement_T), pointer :: M0 ! A Matrix0 within kStar
    integer :: XSTAR                    ! Linearisation state vector index
    integer :: YSTAR                    ! Radiances for xStar vector index

    ! executable code

    ! First read the xStar and yStar
    call ReadOneVectorFromASCII ( unit, xStar, eof )
    if ( eof ) return

    call ReadOneVectorFromASCII ( unit, yStar, eof )
    if ( eof ) return

    ! Now read kStar
    read (unit,*) line                  ! Line saying kStar
    read (unit,*) rowInstFirst, colInstFirst ! Flags
    call CreateEmptyMatrix ( l2pc, 0, l2pcVs(yStar), l2pcVs(xStar), &
      & row_quan_first = .not. rowInstFirst,&
      & col_quan_first = .not. colInstFirst )

    ! Loop over blocks and read them
    do blockRow = 1, l2pc%row%NB
      do blockCol = 1, l2pc%col%NB
        ! Read the type of the matrix and a set of test indices
        read (unit,*) testBlockRow, testBlockCol, blockKind
        if (testBlockRow /= blockRow) call MLSMessage(MLSMSG_Error,ModuleName,&
          & 'Bad row number for kStar')
        if (testBlockCol /= blockCol) call MLSMessage(MLSMSG_Error,ModuleName,&
          & 'Bad col number for kStar')
        read (unit,*) line              ! String giving info, we can ignore.
        select case (blockKind)
        case (M_Absent)
          call CreateBlock ( l2pc, blockRow, blockCol, blockKind )
        case (M_Banded, M_Column_sparse)
          read (unit,*) noValues
          call CreateBlock ( l2pc, blockRow, blockCol, blockKind, noValues )
          m0 => l2pc%block ( blockRow, blockCol )
          read (unit,*) line ! 'R1'
          read (unit,*) m0%R1
          read (unit,*) line ! 'R2'
          read (unit,*) m0%R2
          read (unit,*) line ! 'values'
          read (unit,*) m0%values
        case (M_Full)
          call CreateBlock ( l2pc, blockRow, blockCol, blockKind )
          m0 => l2pc%block ( blockRow, blockCol )
          read (unit,*) m0%values
        end select
      end do
    end do
  end subroutine ReadOneASCIIL2PC

  ! ------------------------------------------ ReadOneVectorFromASCII ----
  subroutine ReadOneVectorFromASCII ( unit, vector, eof )
    ! Reads a vector from l2pc file and adds it to internal databases. This
    ! is internal as having it inside the above routine screws up databases.

    ! Dummy arguments
    integer, intent(in) :: UNIT         ! File unit
    integer, intent(out) :: VECTOR      ! Index of Vector read in L2PCVs
    logical, intent(out) :: EOF         ! Flag

    ! Local variables
    integer :: NOINSTANCESOR1           ! For allocates
    integer :: NOQUANTITIES             ! Number of quantities in a vector
    integer :: NOSURFSOR1               ! For allocates
    integer :: QUANTITY                 ! Loop counter
    integer :: SIDEBAND                 ! From parse signal
    integer :: STATUS                   ! Flag
    integer :: VTINDEX                  ! Index for this vector template

    integer, dimension(:), pointer :: SIGINDS ! Result of parse signal
    integer, dimension(:), pointer :: QTINDS  ! Quantity indices
    
    character (len=132) :: Line       ! Line of text
    
    type (QuantityTemplate_T) :: QT     ! Temporary quantity template
    type (VectorTemplate_T) :: VT       ! Temporary template for vector
    type (Vector_T) :: V                ! Temporary vector
    
    ! Executable code
    
    eof = .false. 
    nullify ( sigInds, qtInds )
    read (unit,*, IOSTAT=status) line
    if (status == -1 ) then
      eof = .true.
      return
    end if
    
    ! Note we fill this later
    read (unit,*) noQuantities
    call allocate_test ( qtInds, noQuantities, 'qtInds', ModuleName )
    
    ! Loop over quantities
    do quantity = 1, noQuantities
      
      ! Nullify stuff so we don't clobber arrays now in databases
      nullify ( qt%surfs, qt%phi )

      ! Read and ignore the name, we're going on the type, at least for the
      ! moment.
      read (unit,*, IOSTAT=status) line
      
      ! Read quantity type
      read (unit,*, IOSTAT=status) line
      if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of line for quantity type', status)
        call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'An io-error occured' )
      end if
      qt%quantityType = GetLitIndexFromString ( line, qt%name )

      ! Set defaults for coordinates, radiance is the later exception
      qt%verticalCoordinate = l_zeta
      qt%frequencyCoordinate = l_none
      qt%noInstancesLowerOverlap = 0
      qt%noInstancesUpperOverlap = 0
      qt%regular = .true.

      ! Read other info associated with type
      select case ( qt%quantityType )
      case (l_vmr)
        read (unit,*, IOSTAT=status) line
        if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of line for l_vmr', status)
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'An io-error occured' )
        end if
        qt%molecule = GetLitIndexFromString ( line, qt%name )
      case (l_radiance)
        read (unit,*, IOSTAT=status) line
        if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of line for radiance', status)
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'An io-error occured' )
        end if
        call Parse_Signal (line, sigInds, sideband=sideband)
        qt%signal = sigInds(1)
        qt%sideband = sideband
        qt%frequencyCoordinate = l_channel
        qt%verticalCoordinate = l_geodAltitude
        call deallocate_test(sigInds,'sigInds',ModuleName)
      case default
      end select
      
      ! Next read the dimensions for the quantity
      read (unit,*, IOSTAT=status) qt%noChans, qt%noSurfs, qt%noInstances
      if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of noChans, noSurfs, noInstances', status)
          print *, 'Quantity: ', quantity
          print *, 'QuantityName: ', qt%name
          print *, 'QuantityType: ', qt%quantityType
          print *, 'l_vmr: ', l_vmr
          print *, 'last literal read: ', trim(line)
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'An io-error occured' )
      end if
      qt%instanceLen = qt%noChans * qt%noSurfs
      read (unit,*, IOSTAT=status) qt%coherent, qt%stacked
      if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of coherent, stacked', status)
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'An io-error occured' )
      end if
      
      if (qt%coherent) then
        noInstancesOr1 = 1
      else
        noInstancesOr1 = qt%noInstances
      endif
      if (qt%stacked) then
        noSurfsOr1 = 1
      else
        noSurfsOr1 = qt%noSurfs
      endif

      call Allocate_test ( qt%surfs, qt%noSurfs, noInstancesOr1, 'qt%surfs', ModuleName )
      call Allocate_test ( qt%phi, noSurfsOr1, qt%noInstances, 'qt%phi', ModuleName )
      
      read (unit,*, IOSTAT=status) line              ! Line saying surfs
      if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of line saying surfs', status)
        call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'An io-error occured' )
      end if
      read (unit,*, IOSTAT=status) qt%surfs
      if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of surfs', status)
        call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'An io-error occured' )
      end if
      read (unit,*, IOSTAT=status) line              ! Line saying phi
      if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of line saying phi', status)
        call MLSMessage ( MLSMSG_Error, ModuleName, 'An io-error occured' )
      end if
      read (unit,*, IOSTAT=status) qt%phi
      if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of phi', status)
        call MLSMessage ( MLSMSG_Error, ModuleName, 'An io-error occured' )
      end if

      ! Now add this template to our private database 
      qtInds(quantity) = AddQuantityTemplateToDatabase ( l2pcQTs, qt )
      
    end do                            ! First Loop over quantities
    
    ! Now create a vector template with these quantities
    call ConstructVectorTemplate ( 0, l2pcQTs, qtInds, vt, forWhom=moduleName )
    vtIndex = AddVectorTemplateToDatabase ( l2pcVTs, vt )
    
    call deallocate_test ( qtInds, 'qtInds', ModuleName )
    
    ! Now create a vector for this vector template
    v = CreateVector ( 0, l2pcVTs(vtIndex), l2pcQTs, vectorNameText='_v' )
    vector = AddVectorToDatabase ( l2pcVs, v )
    
    ! Now go through the quantities again and read the values
    do quantity = 1, noQuantities
      read (unit,*, IOSTAT=status) line              ! Just a comment line
      if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of comment in loop of quantities', status)
        call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'An io-error occured' )
      end if
      read (unit,*, IOSTAT=status) l2pcVs(vector)%quantities(quantity)%values
      if (status /= 0 ) then
        call io_error('io error in L2PC_m: ReadOneVector' // &
          & ' Fortran read of quantities', status)
        call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'An io-error occured' )
      end if
    end do
  end subroutine ReadOneVectorFromASCII
d1151 1
a1151 1
    type (Matrix_T) :: L2PC    ! The l2pc read from one bin
d1185 1
a1185 1
      if ( index ( switches, 'spa' ) /= 0 ) call Dump_struct ( l2pc, 'One l2pc bin' ) 
d1188 11
a1198 5
      nullify ( l2pc%block )
      nullify ( l2pc%row%nelts, l2pc%row%inst, l2pc%row%quant )
      nullify ( l2pc%col%nelts, l2pc%col%inst, l2pc%col%quant )
      nullify ( l2pc%row%vec%template%quantities, l2pc%col%vec%template%quantities )
      nullify ( l2pc%row%vec%quantities, l2pc%col%vec%quantities )
d1208 4
a1211 3
  use HDF5, only: H5GCLOSE_F, H5GOPEN_F, H5GGET_OBJ_INFO_IDX_F
  use MLSHDF5, only: GetHDF5Attribute, LoadFromHDF5DS
    type ( Matrix_T ), intent(out), target :: L2PC
d1216 1
a1216 1
    type ( L2PCInfo_T), intent(out), optional :: INFO ! Information output
a1218 1
    integer :: BLOCKCOL                 ! Loop counter
a1219 1
    integer :: BLOCKROW                 ! Loop counter
d1221 2
d1225 1
d1237 2
a1238 1
    type (MatrixElement_T), pointer :: M0 ! A Matrix0 within kStar
d1255 2
d1279 1
a1279 1
    call CreateEmptyMatrix ( l2pc, stringIndex, l2pcVs(yStar), l2pcVs(xStar), &
d1283 4
d1292 1
d1295 20
d1317 2
a1318 2
      do blockRow = 1, l2pc%row%NB
        do blockCol = 1, l2pc%col%NB
d1320 1
a1320 2
          ! write ( name, * ) 'Block', blockRow, blockCol
          call CreateBlockName( blockRow, blockCol, name )
d1322 11
a1332 3
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to open group for l2pc matrix block '//trim(name) , &
            & MLSFile=MLSFile )
d1338 2
a1339 2
            call CreateBlock ( l2pc, blockRow, blockCol, kind, noValues )
            m0 => l2pc%block ( blockRow, blockCol )
d1343 2
a1344 2
            call CreateBlock ( l2pc, blockRow, blockCol, kind )
            m0 => l2pc%block ( blockRow, blockCol )
d1356 3
a1358 3
      do blockRow = 1, l2pc%row%NB
        do blockCol = 1, l2pc%col%NB
          call CreateBlock ( l2pc, blockRow, blockCol, m_unknown )
d1362 72
a1433 2
        
    ! Finish up, though if in shallow mode, then keep the groups open
d1444 4
a1447 1

d1450 1
a1450 1

d1813 1
a1813 1
  subroutine CreateBlockName ( row, column, name )
d1817 1
a1817 1
    integer, intent(in)           :: row, column
d1820 1
a1820 1
    character(len=16), dimension(2) :: strs
d1822 1
a1822 1
    call writeIntsToChars( (/row, column/), strs )
d1824 1
d1830 1
a1830 1
       "$Id: L2PC_m.f90,v 2.86 2009/11/17 23:43:51 vsnyder Exp $"
d1840 3
@


2.86
log
@Add ability to output TScat
@
text
@a1650 1
    logical, dimension(:), pointer :: CHANNELS ! From Parse_Signal
d1980 1
a1980 1
       "$Id: L2PC_m.f90,v 2.85 2009/06/23 18:25:42 pwagner Exp $"
d1990 3
@


2.85
log
@Prevent Intel from optimizing ident string away
@
text
@d24 1
a24 1
    & L_ROWS, L_COLUMNS, L_ADOPTED, L_TEMPERATURE, Lit_Indices, &
d112 1
a112 1
       "$RCSfile: $"
d1649 3
a1651 2
    integer, dimension(:), pointer :: SIGINDS ! Index into signals database
    integer, dimension(:), pointer :: QTINDS ! Quantity indices
d1751 1
a1751 1
      case ( l_radiance )
d1753 6
a1758 1
        call Parse_Signal ( word, sigInds, sideband=sideband)
d1927 4
d1981 1
a1981 1
       "$Id: read_apriori.f90 is it here $"
d1991 3
@


2.84
log
@May now dump an l2pc or allL2PCs (use with caution)
@
text
@d112 1
a112 1
       "$RCSfile: L2PC_m.f90,v $"
d1968 1
a1969 1
!---------------------------- RCS Ident Info -------------------------------
d1971 2
a1972 3
       "$Id: L2PC_m.f90,v 2.83 2008/09/30 22:28:03 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1974 1
a1974 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1976 1
d1981 3
@


2.83
log
@Remove AuxGrids -- didn't need them after all
@
text
@d21 5
a25 3
  use Intrinsic, only: Lit_Indices, L_CHANNEL, L_GEODALTITUDE, L_ZETA, L_NONE, L_VMR, &
    & L_RADIANCE, L_PTAN, L_NONE, L_INTERMEDIATEFREQUENCY, L_LATITUDE, L_FIELDAZIMUTH, &
    & L_ROWS, L_COLUMNS, L_ADOPTED, L_TEMPERATURE, PHYQ_DIMENSIONLESS, PHYQ_TEMPERATURE, PHYQ_VMR
d33 2
a34 1
  use MLSCommon, only: R8, RM, R4, MLSFile_T
d42 1
a42 1
  use Output_m, only: output
d49 1
a49 1
  use TOGGLES, only: TAB, TOGGLE, SWITCHES
d52 1
a52 1
    & VECTORTEMPLATE_T, VECTOR_T, VECTORVALUE_T, CREATEVECTOR, ADDVECTORTODATABASE, &
d62 1
a62 1
    & FlushL2PCBins, &
d68 3
d77 1
d129 15
d159 171
a413 1
    type(VectorTemplate_T), dimension(:), pointer :: VECTORTEMPLATES ! Mainstream database
a509 1
    integer :: I                        ! Loop counter
d663 4
a666 1
      if (.not. eof) dummy = AddL2PCToDatabase ( l2pcDatabase, l2pc )
a698 3
    integer :: Quantity                 ! Loop counter
    integer :: Vector                   ! Loop counter
    integer :: AdjustedIndex            ! Index into quantities not skipped
a704 1
    logical, dimension(:), pointer :: THISPACK
a708 2
    type (QuantityTemplate_T), pointer :: Qt  ! Temporary pointers
    type (Vector_T), pointer :: V       ! Temporary pointer
d816 1
a818 1
    integer :: Grid                     ! Loop counter
a820 1
    integer :: AdjustedIndex            ! Index into quantities not skipped
a1216 2
    use Allocate_Deallocate, only: Test_Allocate

a1222 1
    integer :: GRID                     ! Loop counter
a1228 1
    integer :: STRINGINDEX              ! Index of string
a1406 1
  ! subroutine ReadCompleteHDF5L2PCFile ( filename )
a1447 1
      ! call ReadOneHDF5L2PCRecord ( L2PC, fileID, bin, &
d1451 1
d1467 1
a1467 2
  ! --------------------------------------- ReadOneHDF5L2PC ------------
  ! subroutine ReadOneHDF5L2PCRecord ( l2pc, fileID, l2pcIndex, shallow, info )
a1470 1
  use Symbol_types, only: T_STRING
a1519 2
    ! call ReadOneVectorFromHDF5 ( matrixId, 'Columns', xStar )
    ! call ReadOneVectorFromHDF5 ( matrixId, 'Rows', yStar )
a1527 2
    ! call GetHDF5Attribute ( blocksID, 'rowInstanceFirst', rowInstanceFirst )
    ! call GetHDF5Attribute ( blocksID, 'colInstanceFirst', colInstanceFirst )
a1557 1
          ! call GetHDF5Attribute ( blockID, 'kind', kind )
a1558 1
          ! call GetHDF5Attribute ( blockID, 'kind', kind )
a1560 1
            ! call GetHDF5Attribute ( blockID, 'noValues', noValues )
a1563 2
            ! call LoadFromHDF5DS ( blockId, 'r1', m0%r1 )
            ! call LoadFromHDF5DS ( blockId, 'r2', m0%r2 )
a1570 1
            ! call LoadFromHDF5DS ( blockID, 'values', m0%values )
a1604 1
  ! subroutine ReadOneVectorFromHDF5 ( location, name, vector )
a1605 1
    use Allocate_Deallocate, only: Test_Allocate
d1608 1
a1608 1
      & IsHDF5DSPresent, IsHDF5GroupPresent, LoadFromHDF5DS, LoadPtrFromHDF5DS
a1612 1
    ! integer, intent(in) :: LOCATION     ! Node in HDF5
a1617 2
    integer :: GID                      ! HDF5 ID of a grid  group
    integer :: GRID                     ! Loop counter
a1671 1
    ! call GetHDF5Attribute ( vId, 'noQuantities', noQuantities )
a1691 1
      ! call GetHDF5Attribute ( qId, 'index', i )
a1725 1
      ! call GetHDF5Attribute ( qId, 'type', word )
a1738 1
        ! call GetHDF5Attribute ( qID, 'molecule', word )
a1741 1
          ! call GetHDF5Attribute ( qID, 'radiometer', word )
a1750 1
        ! call GetHDF5Attribute ( qID, 'signal', word )
a1763 4
      ! call GetHDF5Attribute ( qID, 'noInstances', noInstances )
      ! call GetHDF5Attribute ( qID, 'noSurfs', noSurfs )
      ! call GetHDF5Attribute ( qID, 'noChans', noChans )
      ! call GetHDF5Attribute ( qId, 'verticalCoordinate', word )
a1771 1
        ! call GetHDF5Attribute ( qId, 'frequencyCoordinate', word )
a1774 3
      ! call GetHDF5Attribute ( qId, 'logBasis', logBasis )
      ! call GetHDF5Attribute ( qId, 'coherent', coherent )
      ! call GetHDF5Attribute ( qId, 'stacked', stacked )
a1804 2
      ! call LoadFromHDF5DS ( qId, 'surfs', qt%surfs )
      ! call LoadFromHDF5DS ( qId, 'phi', qt%phi )
a1807 1
        ! call LoadFromHDF5DS ( qId, 'solarZenith', qt%solarZenith )
a1815 1
        ! call LoadFromHDF5DS ( qId, 'frequencies', qt%frequencies )
a1855 1
      ! call LoadFromHDF5DS ( qId, 'values', &
a1879 1
    character ( len=32 ) :: GNAME       ! Name of grid
a1880 2
    integer :: GID                      ! HDF5 ID for one grid group
    integer :: GRID                     ! Loop counter
d1971 1
a1971 1
       "$Id: L2PC_m.f90,v 2.82 2008/06/06 01:55:29 vsnyder Exp $"
d1981 3
@


2.82
log
@Process AuxGrids field of vector quantities
@
text
@d696 2
a697 2
          write (unit,*) qt%noAux, qt%noChans, qt%noSurfs, qt%noInstances, &
            &  'noAux, noChans, noSurfs, noInstances'
a709 15
          ! Write the aux grids if any
          if ( associated(qt%auxGrids) ) then
            write (unit,*) size(qt%auxGrids), 'size(qt%auxGrids)'
            do grid = 1, size(qt%auxGrids)
              call get_string ( lit_indices(qt%auxGrids(grid)%name), line )
              write (unit,*) trim(line) ! grid name
              call get_string ( lit_indices(qt%auxGrids(grid)%verticalCoordinate), &
                & line )
              write (unit,*) trim(line),' verticalCoordinate'
              write (unit,*) size(qt%auxGrids(grid)%surfs), ' surfs'
              write (unit, rFmt) qt%auxGrids(grid)%surfs
            end do
          else
            write (unit,*) 0, 'size(qt%auxGrids)'
          end if
a1038 1
    integer :: NOAUX                    ! Number of aux grids in a quantity
d1127 1
a1127 1
      read (unit,*, IOSTAT=status) qt%noAux, qt%noChans, qt%noSurfs, qt%noInstances
d1130 1
a1130 1
          & ' Fortran read of NoChans, noSurfs, noInstances', status)
d1139 1
a1139 1
      qt%instanceLen = qt%noChans* qt%noSurfs
d1158 3
a1160 3
      
      call Allocate_test( qt%surfs, qt%noSurfs, noInstancesOr1, 'qt%surfs', ModuleName)
      call Allocate_test( qt%phi, noSurfsOr1, qt%noInstances, 'qt%phi', ModuleName)
a1188 20
      ! Read the auxiliary grids
      read (unit,*, IOSTAT=status) noAux, line       ! line saying # size(aux)
      if ( noAux > 0 ) then
        allocate ( qt%auxGrids(noAux), stat=status )
        call test_allocate ( status, moduleName, 'qty%auxGrids', (/ 1 /), &
          & (/ noAux /) )
        do grid = 1, noAux
          read (unit,*) line ! Grid name
          qt%auxGrids(grid)%name = GetStringIndexFromString (line)
          read (unit,*) line ! Vertical coordinate
          qt%auxGrids(grid)%verticalCoordinate = getLitIndexFromString(line)
          read (unit,*) qt%auxGrids(grid)%noSurfs
          call allocate_test ( qt%auxGrids(grid)%surfs, &
            & qt%auxGrids(grid)%noSurfs, 1, 'qt%auxGrids(grid)%surfs', 'L2PC_m' )
          read (unit,*) qt%auxGrids(grid)%surfs
        end do
      else
        nullify ( qt%auxGrids )
      end if

a1449 1
    integer :: AID                      ! HDF5 ID of aux grids group
a1455 1
    integer :: NOAUX                    ! Number of aux grids
a1476 1
    character (len=64) :: THISGRID      ! Name of this aux grid
d1609 1
a1611 1
      call GetHDF5Attribute ( MLSFile, 'noChans', noChans )
a1671 40
      ! Try to get the aux grids
      if ( IsHDF5GroupPresent ( qId, 'auxGrids' ) ) then
        call h5gOpen_f ( qId, 'auxGrids', aId, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to open aux grids group in '//trim(quantityNames(quantity))// &
          & ' in vector '//trim(name) , &
          & MLSFile=MLSFile )
        call GetHDF5Attribute ( qId, 'noAuxGrids', noAux )
        allocate ( qt%auxGrids(noAux), stat=status )
        call test_allocate ( status, moduleName, 'qt%auxGrids', (/ 1 /), &
          & (/ noAux /) )
        do grid = 1, noAux
          call h5gget_obj_info_idx_f ( aId, 'auxGrids', grid-1, thisGrid, &
            & objType, status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to access an aux grid within quantity ' // &
            & trim(quantityNames(quantity))//' in vector '//trim(name) , &
            & MLSFile=MLSFile )
          call h5gOpen_f ( aId, trim(thisGrid), gId, status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to open aux grid group '//trim(thisGrid)//' in quantity ' // &
            & trim(quantityNames(quantity))//' in vector '//trim(name), &
            & MLSFile=MLSFile )
          qt%auxGrids(grid)%name = GetStringIndexFromString ( thisGrid )
          call getHDF5Attribute ( gID, 'verticalCoordinate', word )
          qt%auxGrids(grid)%verticalCoordinate = GetLitIndexFromString ( word )
          call loadPtrFromHDF5DS ( gID, 'surfs', qt%auxGrids(grid)%surfs )
          call h5gClose_f ( gID, status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to close aux grid group '//trim(thisGrid)//' in quantity '// &
            & trim(quantityNames(quantity))//' in vector '//trim(name), &
            & MLSFile=MLSFile )
        end do ! grid
        call h5gClose_f ( aID, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to close aux grids group for ' // &
          & trim(quantityNames(quantity))//' in vector '//trim(name), &
          & MLSFile=MLSFile )
      end if

a1735 1
    integer :: AID                      ! HDF5 ID for aux grids group
a1779 1
        call MakeHDF5Attribute ( qID, 'noAux',   qt%noAux )
d1781 1
a1782 1
        call MakeHDF5Attribute ( qID, 'noInstances', qt%noInstances )
a1795 22
        ! Write out aux grids
        if ( associated(qt%auxGrids) ) then
          call h5gCreate_f ( qID, 'auxGrids', aID, status )
          call MakeHDF5Attribute ( qID, 'noAuxGrids', size(qt%auxGrids) )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to create group for aux grids ' // trim(gName) )
          do grid = 1, size(qt%auxGrids)
            call get_string ( qt%auxGrids(grid)%name, gName )
            call h5gCreate_f ( aID, trim(gName), gID, status )
            if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unable to create group for grid ' // trim(gName) )
            call get_string ( lit_indices(qt%auxGrids(grid)%verticalCoordinate), line )
            call MakeHDF5Attribute ( gID, 'verticalCoordinate', trim(line) )
            call SaveAsHDF5DS ( gID, 'surfs', qt%auxGrids(grid)%surfs )
            call h5gClose_f ( gID, status )
            if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unable to close grid group for ' // trim(gName) )
          end do
          call h5gClose_f ( aID, status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to close aux grids group' )
        end if
d1828 1
a1828 1
       "$Id: L2PC_m.f90,v 2.81 2008/05/03 01:49:55 vsnyder Exp $"
d1832 1
d1838 3
@


2.81
log
@Repair a comment
@
text
@d630 1
d696 2
a697 2
          write (unit,*) qt%noChans, qt%noSurfs, qt%noInstances,&
            &  'noChans, noSurfs, noInstances'
d709 16
d1044 3
a1046 1
    
d1053 5
a1061 3
    integer :: NOQUANTITIES             ! Number of quantities in a vector
    integer :: NOINSTANCESOR1           ! For allocates
    integer :: NOSURFSOR1               ! For allocates
d1063 1
a1063 1
    
d1143 1
a1143 1
      read (unit,*, IOSTAT=status) qt%noChans, qt%noSurfs, qt%noInstances
d1196 1
a1196 2
        call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'An io-error occured' )
d1202 21
a1222 2
        call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'An io-error occured' )
d1224 1
a1224 1
      
d1473 5
a1477 5
  use HDF5, only: H5GCLOSE_F, H5GOPEN_F, H5GGET_OBJ_INFO_IDX_F
  use MLSHDF5, only: GetHDF5Attribute, IsHDF5AttributePresent, &
    & IsHDF5DSPresent, LoadFromHDF5DS
  use MLSSignals_m, only: Radiometers, Radiometer_T
  use Symbol_types, only: T_IDENTIFIER
d1480 1
a1480 1
    type (MLSFile_T), pointer   :: MLSFile
d1486 1
d1488 2
d1493 1
d1515 1
d1711 40
d1805 1
a1805 1
    use MLSSignals_m, only: Radiometers, Radiometer_T
d1813 1
d1815 6
a1821 3
    integer :: QUANTITY                 ! Index
    integer :: QINDEX                   ! Quantity index
    integer :: QID                      ! HDF5 ID for quantity group
d1860 1
d1877 22
d1931 1
a1931 1
       "$Id: L2PC_m.f90,v 2.80 2007/10/03 23:58:46 vsnyder Exp $"
d1940 3
@


2.80
log
@Add 'where' for tracing
@
text
@d947 1
a947 1
  ! --------------------------------------- WriteL2PC ---------------
d1820 1
a1820 1
       "$Id: L2PC_m.f90,v 2.79 2007/04/26 20:30:32 pwagner Exp $"
d1829 3
@


2.79
log
@Bugfix for way ifc writes ints to strings
@
text
@d455 1
a455 1
  subroutine Read_l2pc_file ( Lun )
d460 1
d468 1
a468 1
    if ( toggle (gen) ) call trace_begin ( "Read_l2pc_file" )
d1222 4
a1225 2
  subroutine ReadCompleteHDF5L2PCFile ( MLSFile )
  use HDF5, only: H5F_ACC_RDONLY_F, h5fopen_f, H5GN_MEMBERS_F
d1227 1
d1241 1
d1279 1
d1820 1
a1820 1
       "$Id: L2PC_m.f90,v 2.78 2006/08/05 02:11:58 vsnyder Exp $"
d1829 3
@


2.78
log
@Add ForWhom argument to ConstructVectorTemplate
@
text
@d36 1
d565 2
a566 1
          write ( name, * ) 'Block', rowBlockMap(blockRow), colBlockMap(blockCol)
d913 2
a914 1
        write ( name, * ) 'Block', blockRow, blockCol
d1366 2
a1367 1
          write ( name, * ) 'Block', blockRow, blockCol
d1798 13
d1814 1
a1814 1
       "$Id: L2PC_m.f90,v 2.77 2006/08/04 01:53:43 vsnyder Exp $"
d1823 3
@


2.77
log
@Need to set the name, not quantityType before SetupNewQuantityTemplate
@
text
@d1188 1
a1188 1
    call ConstructVectorTemplate ( 0, l2pcQTs, qtInds, vt )
d1669 1
a1669 1
    call ConstructVectorTemplate ( 0, l2pcQTs, qtInds, vt )
d1797 1
a1797 1
       "$Id: L2PC_m.f90,v 2.76 2006/08/03 01:10:06 vsnyder Exp $"
d1806 3
@


2.76
log
@Put l2cf names in leak track database
@
text
@d1613 1
a1613 1
      qt%quantityType = quantityType
d1618 1
a1618 1
      qt%name = nameIndex
d1797 1
a1797 1
       "$Id: L2PC_m.f90,v 2.75 2005/06/29 00:42:35 pwagner Exp $"
d1806 3
@


2.75
log
@Passes MLSFiles to GetHDF5Attribute, LoadFromHDF5DS
@
text
@d1613 1
a1617 1
      qt%quantityType = quantityType
d1797 1
a1797 1
       "$Id: L2PC_m.f90,v 2.74 2005/06/22 17:25:49 pwagner Exp $"
d1806 3
@


2.74
log
@Reworded Copyright statement, moved rcs id
@
text
@d31 1
a31 1
  use MLSCommon, only: R8, RM, R4
d54 9
a62 7
  public :: AdoptVectorTemplate, LoadMatrix, LoadVector
  public :: AddL2PCToDatabase, DestroyL2PC, DestroyL2PCDatabase, WriteOneL2PC
  public :: Open_l2pc_file, read_l2pc_file, close_l2pc_file, binSelector_T
  public :: BinSelectors, DestroyBinSelectorDatabase,  AddBinSelectorToDatabase
  public :: OutputHDF5L2PC, ReadCompleteHDF5L2PCFile, PopulateL2PCBin, FlushL2PCBins
  public :: PopulateL2PCBinByName
  public :: CreateDefaultBinSelectors, DefaultSelector_Latitude, DefaultSelector_FieldAzimuth
d104 1
a104 1
       "$RCSfile: $"
d1217 2
a1218 1
  subroutine ReadCompleteHDF5L2PCFile ( filename )
d1220 2
a1221 1
    character (len=*), intent(in) :: FILENAME
d1234 2
a1235 1
    call h5fopen_f ( filename, H5F_ACC_RDONLY_F, fileID, status )
d1237 2
a1238 1
      & 'Unable to open hdf5 l2pc file for input:'//trim(filename) )
d1243 2
a1244 1
      & 'Unable to get number of bins from input l2pc file:'//trim(filename) )
d1248 1
a1248 1
      call output ( trim(filename), advance='yes' )
d1255 2
a1256 1
      call ReadOneHDF5L2PCRecord ( L2PC, fileID, bin, &
d1274 2
a1275 1
  subroutine ReadOneHDF5L2PCRecord ( l2pc, fileID, l2pcIndex, shallow, info )
d1280 2
a1281 1
    integer, intent(in) :: FILEID       ! HDF5 ID of input file
d1316 1
a1316 1
    call h5gGet_obj_info_idx_f ( fileID, '/', l2pcIndex, matrixName, &
d1319 3
a1321 2
      & 'Unable to get information on matrix in input l2pc file' )
    call h5gOpen_f ( fileID, trim(matrixName), matrixId, status )
d1323 2
a1324 1
      & 'Unable to open matrix in input l2pc file' )
d1327 5
a1331 2
    call ReadOneVectorFromHDF5 ( matrixId, 'Columns', xStar )
    call ReadOneVectorFromHDF5 ( matrixId, 'Rows', yStar )
d1336 7
a1342 3
      & 'Unable to access Blocks group of input l2pc matrix' )
    call GetHDF5Attribute ( blocksID, 'rowInstanceFirst', rowInstanceFirst )
    call GetHDF5Attribute ( blocksID, 'colInstanceFirst', colInstanceFirst )
d1353 1
a1353 1
      info%fileID = fileID
d1366 2
a1367 1
            & 'Unable to open group for l2pc matrix block '//trim(name) )
d1369 4
a1372 1
          call GetHDF5Attribute ( blockID, 'kind', kind )
d1374 2
a1375 1
            call GetHDF5Attribute ( blockID, 'noValues', noValues )
d1378 4
a1381 2
            call LoadFromHDF5DS ( blockId, 'r1', m0%r1 )
            call LoadFromHDF5DS ( blockId, 'r2', m0%r2 )
d1387 2
a1388 1
            call LoadFromHDF5DS ( blockID, 'values', m0%values )
d1391 2
a1392 1
            & 'Unable to close group for input l2pc matrix block '//trim(name) )
d1408 2
a1409 1
        & 'Unable to close Blocks group for input l2pc' )
d1412 2
a1413 1
        & 'Unable to close matrix group for input l2pc' )
d1422 2
a1423 1
  subroutine ReadOneVectorFromHDF5 ( location, name, vector )
d1431 2
a1432 1
    integer, intent(in) :: LOCATION     ! Node in HDF5
d1486 1
a1486 1
    call h5gOpen_f ( location, name, vId, status )
d1488 2
a1489 1
      & 'Unable to open group for vector '//trim(name) )
d1492 3
a1494 1
    call GetHDF5Attribute ( vId, 'noQuantities', noQuantities )
d1504 1
a1504 1
      call h5gget_obj_info_idx_f ( location, name, quantity-1, thisName, &
d1507 2
a1508 1
        & 'Unable to acces a quantity within '//trim(name) )
d1511 5
a1515 2
        & 'Unable to open quantity '//trim(thisName)//' in vector '//trim(name) )
      call GetHDF5Attribute ( qId, 'index', i )
d1519 2
a1520 1
        & 'Unable to close quantity '//trim(thisName)//' in vector '//trim(name) )
d1540 2
a1541 1
        & ' in vector '//trim(name) )
d1548 3
a1550 1
      call GetHDF5Attribute ( qId, 'type', word )
d1562 2
a1563 1
        call GetHDF5Attribute ( qID, 'molecule', word )
d1566 2
a1567 1
          call GetHDF5Attribute ( qID, 'radiometer', word )
d1576 2
a1577 1
        call GetHDF5Attribute ( qID, 'signal', word )
d1590 8
a1597 4
      call GetHDF5Attribute ( qID, 'noInstances', noInstances )
      call GetHDF5Attribute ( qID, 'noSurfs', noSurfs )
      call GetHDF5Attribute ( qID, 'noChans', noChans )
      call GetHDF5Attribute ( qId, 'verticalCoordinate', word )
d1602 2
a1603 1
        call GetHDF5Attribute ( qId, 'frequencyCoordinate', word )
d1606 6
a1611 3
      call GetHDF5Attribute ( qId, 'logBasis', logBasis )
      call GetHDF5Attribute ( qId, 'coherent', coherent )
      call GetHDF5Attribute ( qId, 'stacked', stacked )
d1639 4
a1642 2
      call LoadFromHDF5DS ( qId, 'surfs', qt%surfs )
      call LoadFromHDF5DS ( qId, 'phi', qt%phi )
d1644 2
a1645 1
        call LoadFromHDF5DS ( qId, 'solarZenith', qt%solarZenith )
d1653 2
a1654 1
        call LoadFromHDF5DS ( qId, 'frequencies', qt%frequencies )
d1664 2
a1665 1
        & 'Unable to close quantity '//trim(thisName)//' in vector '//trim(name) )
d1691 5
a1695 2
        & ' in vector '//trim(name) )
      call LoadFromHDF5DS ( qId, 'values', &
d1699 2
a1700 1
        & 'Unable to close quantity '//trim(thisName)//' in vector '//trim(name) )
d1797 1
a1797 1
       "$Id: $"
d1806 3
@


2.73
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d100 1
a100 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: L2PC_m.f90,v 2.72 2004/02/11 01:08:44 livesey Exp $"
  character (len=len(idParm)), private :: Id = idParm
d102 1
a102 1
       "$RCSfile: L2PC_m.f90,v $"
d1732 5
d1743 3
@


2.72
log
@Removed print statement.
@
text
@a16 4
  use MLSCommon, only: R8, RM, R4, FindFirst
  use VectorsModule, only: assignment(=), DESTROYVECTORINFO, COPYVECTOR, &
    & VECTORTEMPLATE_T, VECTOR_T, VECTORVALUE_T, CREATEVECTOR, ADDVECTORTODATABASE, &
    & ADDVECTORTEMPLATETODATABASE, CONSTRUCTVECTORTEMPLATE, NULLIFYVECTORTEMPLATE
d18 2
d23 1
a23 2
  use MatrixModule_0, only: M_ABSENT, M_BANDED, M_COLUMN_SPARSE, M_FULL, &
    & MATRIXELEMENT_T, M_UNKNOWN, DESTROYBLOCK
d26 1
d39 3
d94 1
a94 1
       "$Id: L2PC_m.f90,v 2.71 2004/01/30 23:27:32 livesey Exp $"
d145 1
a145 1
    i = FindFirst ( l2pcDatabase%name == name )
d181 1
a181 1
    i = FindFirst ( l2pcDatabase%name == name )
d228 1
a228 1
    i = FindFirst ( l2pcDatabase%name == bin )
d250 1
a250 1
      i = FindFirst ( quantityTemplates%name == qt%name )
d871 1
a871 1
    index = FindFirst ( l2pcDatabase%name == name )
d1519 1
a1519 1
          radiometer = FindFirst ( stringIndex == Radiometers%prefix )
d1733 3
@


2.71
log
@Capitalized the names of the bins on output
@
text
@d93 1
a93 1
       "$Id: L2PC_m.f90,v 2.70 2004/01/24 01:44:36 livesey Exp $"
a842 1
      print*,'Doing the dont pack stuff'
d1732 3
@


2.70
log
@Removed print statement
@
text
@d93 1
a93 1
       "$Id: L2PC_m.f90,v 2.69 2004/01/24 01:01:22 livesey Exp $"
d529 1
a529 1
    call get_string ( l2pc%name, name, strip=.true. )
d1733 3
@


2.69
log
@Improvements to the adoption stuff
@
text
@d93 1
a93 1
       "$Id: L2PC_m.f90,v 2.68 2004/01/23 19:07:49 livesey Exp $"
a266 1
    print*,'Quantities:', vectorTemplate%quantities
d1733 3
@


2.68
log
@More on adoption / loading
@
text
@d15 1
a15 1
    & L_ROWS, L_COLUMNS
d35 3
a37 1
    & SETUPNEWQUANTITYTEMPLATE, INFLATEQUANTITYTEMPLATEDATABASE
d93 1
a93 1
       "$Id: L2PC_m.f90,v 2.67 2004/01/23 05:37:34 livesey Exp $"
d198 1
a198 1
    call CopyVector ( vector, sourceVector, clone=.true. )
d202 1
a202 1
  type (VectorTemplate_T) function AdoptVectorTemplate ( name, quantityTemplates, source ) &
d206 1
a206 3
    ! the mainstream quantity template database.  Note that the quantities are shallow
    ! copied, so be very careful with the chunk loop which will deallocate things in a nasty way.
    use String_Table, only: Display_STRING
d209 2
a210 1
    integer, intent(in) :: NAME         ! Name of MATRIX (not vector tempalte!)
d214 1
d221 1
d224 1
d227 5
a231 2
    i = FindFirst ( l2pcDatabase%name == name )
    if ( i == 0 ) return
d241 1
d248 18
a265 2
      vectorTemplate%quantities(qty) = AddQuantityTemplateToDatabase ( quantityTemplates, &
        & l2pcQTs ( sourceTemplate%quantities(qty) ) )
d267 1
a326 1
    type (QuantityTemplate_T), pointer :: Qt ! Temporary pointer
d338 1
a338 5
        qt => v%quantities(quantity)%template
        call deallocate_test (qt%surfs, 'qt%surfs', ModuleName)
        call deallocate_test (qt%phi, 'qt%phi', ModuleName)
        call deallocate_test (v%quantities(quantity)%values, 'q%values',&
          & ModuleName)
d340 1
a340 1
      deallocate (v%quantities)
d1422 1
d1512 1
d1525 1
d1533 3
d1567 1
d1734 3
@


2.67
log
@Added the adoption stuff
@
text
@d18 2
a19 2
  use VectorsModule, only: assignment(=), DESTROYVECTORINFO, &
    & VECTORTEMPLATE_T, VECTOR_T, VECTORVALUE_T, CREATEVECTOR, ADDVECTORTODATABASE,&
d43 1
a43 1
  public :: AdoptVectorTemplate, AdoptMatrix
a61 11
  ! Now it is possible to adopt L2PC quantity templates, vector
  ! templates, vectors and matrices into the main 'namespace' as it were.
  ! These integers keep track of that information
  type L2PCAdoptionInfo_T
    integer, dimension(:), pointer :: QUANTITYTEMPLATES
    integer, dimension(:), pointer :: ROWTEMPLATES
    integer, dimension(:), pointer :: COLTEMPLATES
  end type L2PCAdoptionInfo_T

  type(L2PCAdoptionInfo_T), save :: ADOPTIONS

d91 1
a91 1
       "$Id: L2PC_m.f90,v 2.66 2003/09/15 17:45:03 livesey Exp $"
d126 2
a127 2
  ! ---------------------------------- AdoptMatrix ----------
  subroutine AdoptMatrix ( matrix, name, message )
d150 1
a150 1
      message = 'Rows do not match for adoption'
d154 1
a154 1
      message = 'Columns do not match for adoption'
d158 40
a197 1
  end subroutine AdoptMatrix
d1707 3
@


2.66
log
@Added target declaration for fussy intel compiler
@
text
@d14 2
a15 1
    & L_RADIANCE, L_PTAN, L_NONE, L_INTERMEDIATEFREQUENCY, L_LATITUDE, L_FIELDAZIMUTH
d20 2
a21 1
    & ADDVECTORTEMPLATETODATABASE, CONSTRUCTVECTORTEMPLATE
d24 1
a24 1
    & GETACTUALMATRIXFROMDATABASE, DUMP_STRUCT
d43 1
d48 1
d62 11
d102 1
a102 1
       "$Id: L2PC_m.f90,v 2.65 2003/08/14 20:24:23 livesey Exp $"
d122 1
a122 1
  ! ------------------------------------  Add l2pc  to database ----
d137 80
d819 9
d1217 1
d1273 1
a1273 1
    stringIndex = GetStringIndexFromString ( matrixName )
d1344 2
a1345 1
    use MLSSignals_m, only: Radiometers, Radiometer_T
d1495 1
a1495 1
        frequencyCoordinate = GetLitIndexFromString ( word )
d1679 3
@


2.65
log
@Added the exact bin selector stuff
@
text
@d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.64 2003/08/13 00:47:34 livesey Exp $"
d1485 1
a1485 1
    type (Vector_T), intent(in) :: VECTOR ! The vector to write
d1573 3
@


2.64
log
@Added the default bin selectors stuff
@
text
@d66 1
d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.63 2003/08/08 23:04:45 livesey Exp $"
d143 1
d152 1
d154 1
a154 1
    sel%cost = sqrt ( huge ( 0.0_r8 ) )
d1573 3
@


2.63
log
@Added the dontPack stuff for output.
@
text
@d14 1
a14 1
    & L_RADIANCE, L_PTAN, L_NONE, L_INTERMEDIATEFREQUENCY
d45 1
d80 4
d86 1
a86 1
       "$Id: L2PC_m.f90,v 2.62 2003/06/20 19:31:39 pwagner Exp $"
d127 29
d1570 3
@


2.62
log
@Changes to allow direct writing of products
@
text
@d81 1
a81 1
       "$Id: L2PC_m.f90,v 2.61 2003/05/13 04:46:24 livesey Exp $"
d235 1
a235 1
  subroutine OutputHDF5L2PC ( filename, matrices, quantitiesNode, packed )
d241 1
d258 1
a258 1
      call writeOneHDF5L2PC ( tmpMatrix, fileID, packed )
d299 1
a299 1
  subroutine WriteOneHDF5L2PC ( L2pc, fileID, packed )
d307 2
a308 1
    logical, intent(in), optional :: PACKED
a325 1
    logical :: MYPACKED
a334 3
    myPacked = .false.
    if ( present ( packed ) ) myPacked = packed

d336 2
a337 2
    if ( myPacked ) then
      call MakeMatrixPackMap ( l2pc, rowPack, colPack, rowBlockMap, colBlockMap )
d431 1
a431 1
    logical, intent(in), optional :: PACKED
a446 1
    logical :: MYPACKED
a455 3
    myPacked = .false.
    if ( present ( packed ) ) myPacked = packed

d457 1
a457 1
    if ( myPacked ) then
d616 1
a616 1
  subroutine MakeMatrixPackMap ( m, rowPack, colPack, rowBlockMap, colBlockMap )
d627 1
d662 13
d1536 3
@


2.61
log
@Renamed a routine to avoid conflict with VectorHDF5
@
text
@d81 1
a81 1
       "$Id: L2PC_m.f90,v 2.60 2003/02/06 01:37:12 livesey Exp $"
a87 4
  ! Local saved variables - these keep track of the l2pc vector/quantity databases
  integer, save :: L2PCQTCOUNTER = CounterStart ! To place in qt%id
  integer, save :: L2PCVTCOUNTER = CounterStart ! To place in vt%id
    
a979 2
      qt%id = l2pcQTCounter
      l2pcQTCounter = l2pcQtCounter + 1
a985 2
    vt%id = l2pcVTCounter
    l2pcVtCounter = l2pcVtCounter + 1
d1214 1
d1280 1
a1353 2
      qt%noInstancesLowerOverlap = 0
      qt%noInstancesUpperOverlap = 0
a1361 2
      qt%regular = .true.
      qt%instanceLen = qt%noChans* qt%noSurfs
d1390 1
a1390 2
      qt%id = qtIndexOffset + quantity - 1
      qtInds ( quantity ) = qt%id
a1400 2
    vt%id = l2pcVTCounter
    l2pcVtCounter = l2pcVtCounter + 1
d1528 3
@


2.60
log
@Set solarZenith to zero if reading from hdf5 and not present
@
text
@d81 1
a81 1
       "$Id: L2PC_m.f90,v 2.59 2003/02/06 01:34:21 livesey Exp $"
d362 2
a363 2
    call WriteVectorAsHDF5 ( matrixID, l2pc%col%vec, 'Columns', colPack )
    call WriteVectorAsHDF5 ( matrixID, l2pc%row%vec, 'Rows', rowPack )
d1447 2
a1448 2
  ! --------------------------------------- WriteVectorAsHDF5 ----------
  subroutine WriteVectorAsHDF5 ( location, vector, name, packInfo )
d1532 1
a1532 1
  end subroutine WriteVectorAsHDF5
d1541 3
@


2.59
log
@Added writing of solarZenith, and reading if it is present.
@
text
@d81 1
a81 1
       "$Id: L2PC_m.f90,v 2.58 2003/02/06 00:45:37 livesey Exp $"
d1387 5
a1391 2
      if ( IsHDF5DSPresent ( qId, 'solarZenith' ) ) &
        & call LoadFromHDF5DS ( qId, 'solarZenith', qt%solarZenith )
d1541 3
@


2.58
log
@Added name fragment to binSelector_t
@
text
@d81 1
a81 1
       "$Id: L2PC_m.f90,v 2.57 2003/02/05 21:55:45 livesey Exp $"
d1387 2
d1512 1
d1538 3
@


2.57
log
@Bin selectors don't contain signal information anymore.
@
text
@d64 1
d81 1
a81 1
       "$Id: L2PC_m.f90,v 2.56 2003/01/28 02:41:10 livesey Exp $"
d1535 3
@


2.56
log
@Bug fix in writing matrix, now gets right element from database in all
cases.
@
text
@a43 1
  public :: NullifyBinSelector
a63 2
    integer, dimension(:), pointer :: signals => NULL() ! What signals does this apply to
    integer, dimension(:), pointer :: sidebands => NULL() ! What sidebands
d80 1
a80 1
       "$Id: L2PC_m.f90,v 2.55 2003/01/13 19:28:20 pwagner Exp $"
a131 6
    do i = 1, size(binSelectors)
      call Deallocate_test ( binSelectors(i)%signals, &
        & 'binSelectors%signals', ModuleName )
      call Deallocate_test ( binSelectors(i)%sidebands, &
        & 'binSelectors%sidebands', ModuleName )
    end do
a681 10
  ! ----------------------------------------NullifyBinSelector -----
  subroutine NullifyBinSelector ( B )
    ! Given a bin selector, nullify all the pointers associated with it
    type ( BinSelector_T ), intent(out) :: B

    ! Executable code
    nullify ( b%signals )
    nullify ( b%sidebands )
  end subroutine NullifyBinSelector

d1534 4
@


2.55
log
@Moved several uses to speed Lahey buggs compiler
@
text
@d21 2
a22 2
    & DESTROYMATRIX, MATRIX_T, DUMP, FINDBLOCK, MATRIX_DATABASE_T, GETFROMMATRIXDATABASE, &
    & DUMP_STRUCT
d83 1
a83 1
       "$Id: L2PC_m.f90,v 2.54 2002/11/25 11:47:34 mjf Exp $"
d268 1
a268 1
      call GetFromMatrixDatabase ( matrices(db_index), tmpMatrix )
d1553 3
@


2.54
log
@Put SaveAsHDF5DS back to writing r4 reals.
@
text
@a24 5
  use MLSHDF5, only: MakeHDF5Attribute, GetHDF5Attribute, &
    & IsHDF5AttributePresent, IsHDF5DSPresent, SaveAsHDF5DS, LoadFromHDF5DS
  use HDF5, only: H5FCREATE_F, H5FCLOSE_F, H5F_ACC_TRUNC_F, H5F_ACC_RDONLY_F, &
    & H5FOPEN_F, H5GCLOSE_F, H5GCREATE_F, H5GOPEN_F, H5GGET_OBJ_INFO_IDX_F, &
    & H5GN_MEMBERS_F
d83 1
a83 1
       "$Id: L2PC_m.f90,v 2.53 2002/11/22 12:47:47 mjf Exp $"
d248 1
d311 2
d604 1
d703 2
d1041 1
d1092 2
d1217 3
d1462 2
d1553 3
@


2.53
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d88 1
a88 1
       "$Id: L2PC_m.f90,v 2.52 2002/11/20 21:06:25 livesey Exp $"
d412 1
a412 1
            call SaveAsHDF5DS ( blockGroupID, 'values', m0%values )
d1544 4
@


2.52
log
@Various bug fixes to make the packed storage work.
@
text
@d49 1
d88 1
a88 1
       "$Id: L2PC_m.f90,v 2.51 2002/10/08 00:09:10 pwagner Exp $"
d412 1
a412 1
            call SaveAsHDF5DS ( blockGroupID, 'values', real ( m0%values, r4 ) )
d692 10
d1544 3
@


2.51
log
@Added idents to survive zealous Lahey optimizer
@
text
@d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.50 2002/10/05 00:42:31 livesey Exp $"
d332 2
d352 1
a352 1
      call MakeMatrixPackMap ( l2pc, rowPack, colPack )
d356 6
d392 1
a392 1
          write ( name, * ) 'Block', blockRow, blockCol
d477 3
a479 1
      call MakeMatrixPackMap ( l2pc, rowPack, colPack )
d634 1
a634 1
  subroutine MakeMatrixPackMap ( m, rowPack, colPack )
d643 2
d653 2
d678 11
d1164 1
a1164 1
            call LoadFromHDF5DS ( blockId, 'r1', m0%r2 )
d1455 1
d1466 1
d1469 1
d1478 1
a1478 1
        call MakeHDF5Attribute ( qID, 'index', quantity )
d1533 3
@


2.50
log
@Modified to use new pack/unpack literals/strings
@
text
@d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.49 2002/10/02 23:20:19 livesey Exp $"
d91 1
d1498 4
d1505 3
@


2.49
log
@Added radiometer and saving as single precision
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
a12 1
  use Declaration_Table, only: DECLS, ENUM_VALUE, GET_DECL, DUMP_DECL
d34 1
a39 2
  use Symbol_Table, only: ENTER_TERMINAL, DUMP_SYMBOL_CLASS
  use Symbol_Types, only: T_IDENTIFIER
d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.48 2002/09/11 17:43:38 pwagner Exp $"
a827 1
    type (Decls) :: Decl                ! From tree
d861 1
a861 4
      stringIndex = enter_terminal ( trim(line), t_identifier )
      decl = get_decl ( stringIndex, type=enum_value )
      qt%quantityType = decl%units
      qt%name = stringIndex
d880 1
a880 4
        stringIndex = enter_terminal ( trim(line), t_identifier )
        decl = get_decl ( stringIndex, type=enum_value )
        qt%molecule = decl%units
        qt%name = stringIndex
a1079 1
    type (Decls) :: Decl                ! From tree
d1108 1
a1108 2
    stringIndex = enter_terminal ( trim(matrixName), t_identifier )
    decl = get_decl ( stringIndex, type=enum_value )
a1220 1
    type ( Decls ) :: DECL              ! From tree
d1279 1
a1279 1
      stringIndex = enter_terminal ( trim(quantityNames(quantity)), t_identifier ) 
d1284 1
a1284 3
      stringIndex = enter_terminal ( trim(word), t_identifier ) 
      decl = get_decl ( stringIndex, type=enum_value )
      quantityType = decl%units
d1295 1
a1295 3
        stringIndex = enter_terminal ( trim(word), t_identifier ) 
        decl = get_decl ( stringIndex, type=enum_value )
        molecule = decl%units
d1298 1
a1298 1
          stringIndex = enter_terminal ( trim(word), t_identifier ) 
d1319 1
a1319 3
      stringIndex = enter_terminal ( trim(word), t_identifier ) 
      decl = get_decl ( stringIndex, type=enum_value )
      verticalCoordinate = decl%units
d1324 1
a1324 3
        stringIndex = enter_terminal ( trim(word), t_identifier ) 
        decl = get_decl ( stringIndex, type=enum_value )
        frequencyCoordinate = decl%units
d1500 3
@


2.48
log
@Began changes needed to conform with matrix%values type move to rm from r8
@
text
@d15 1
a15 1
    & L_RADIANCE, L_PTAN, L_NONE
d17 1
a17 1
  use MLSCommon, only: R8, RM
d34 1
d89 1
a89 1
       "$Id: L2PC_m.f90,v 2.47 2002/08/28 21:43:38 livesey Exp $"
d404 1
a404 1
            call SaveAsHDF5DS ( blockGroupID, 'values', m0%values )
d1187 1
d1210 1
d1281 1
a1281 1
        call output ( trim(name), advance='yes' )
d1304 1
d1312 8
a1319 1
        frequencyCoordinate = l_none
d1359 1
d1438 1
d1477 4
d1520 3
@


2.47
log
@Cosmetic changes
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d9 2
a10 2
  ! files.  The first version will deal with ascii files, but later versions
  ! will probably be HDF.
d17 1
a17 1
  use MLSCommon, only: R8
d21 1
a21 1
  use MatrixModule_1, only: CHECKINTEGRITY, CREATEBLOCK, CREATEEMPTYMATRIX, &
d88 1
a88 1
       "$Id: L2PC_m.f90,v 2.46 2002/08/28 20:42:39 livesey Exp $"
d1503 3
@


2.46
log
@Now uses inflateQuantityTemplateDatabase, much much faster on reading
l2pcs.
@
text
@d88 1
a88 1
       "$Id: L2PC_m.f90,v 2.45 2002/08/28 01:12:20 livesey Exp $"
d1269 1
a1269 1
    QTINDEXOFFSET = InflateQuantityTemplateDatabase ( l2pcQTs, noQuantities )
d1273 1
a1273 1
      qt => l2pcQTs ( QTINDEXOFFSET + quantity - 1 )
d1377 1
a1377 1
      qt%id = QTINDEXOFFSET + quantity - 1
d1503 4
@


2.45
log
@Bug fix in frequency coordinate.
@
text
@d37 1
a37 1
    & SETUPNEWQUANTITYTEMPLATE
d88 1
a88 1
       "$Id: L2PC_m.f90,v 2.44 2002/08/23 01:23:44 livesey Exp $"
d1032 7
a1043 4
!       if ( .not. CheckIntegrity ( l2pc ) ) then
!         call MLSMessage ( MLSMSG_Error, ModuleName, &
!           & 'L2PC failed integrity test' )
!       end if
d1060 1
a1060 1
  subroutine ReadOneHDF5L2PCRecord ( l2pc, fileID, index, shallow, info )
d1063 1
a1063 1
    integer, intent(in) :: INDEX        ! Index of l2pc entry to read
d1095 4
a1098 1
    call h5gGet_obj_info_idx_f ( fileID, '/', index, matrixName, &
d1179 3
d1194 1
a1194 1
    integer :: INDEX                    ! Index into various arrays
d1205 1
d1226 1
a1226 1
    type ( QuantityTemplate_T) :: QT    ! Template for the quantity
d1234 5
d1251 4
d1262 2
a1263 2
      call GetHDF5Attribute ( qId, 'index', index )
      quantityNames ( index ) = thisName
d1269 2
d1273 7
d1376 3
a1378 10
      ! Now add this template to our private database 
      qt%id = l2pcQTCounter
      l2pcQTCounter = l2pcQtCounter + 1
      qtInds(quantity) = AddQuantityTemplateToDatabase ( l2pcQTs, qt )

      ! Now nullify the arrays in qt so we don't clobber them later
      nullify ( qt%surfs )
      nullify ( qt%phi, qt%geodLat, qt%lon, qt%time, qt%solarTime )
      nullify ( qt%solarZenith, qt%losAngle, qt%mafIndex, qt%mafCounter )
      nullify ( qt%frequencies )
d1396 2
d1399 2
d1405 4
d1503 3
@


2.44
log
@Now optionally reads frequency coordinate and frequencies
@
text
@d88 1
a88 1
       "$Id: L2PC_m.f90,v 2.43 2002/08/21 23:10:11 livesey Exp $"
d1273 1
d1474 3
@


2.43
log
@No longer scans each bin for blocks
@
text
@d26 2
a27 1
  use MLSHDF5, only: MakeHDF5Attribute, GetHDF5Attribute, SaveAsHDF5DS, LoadFromHDF5DS
d88 1
a88 1
       "$Id: L2PC_m.f90,v 2.42 2002/08/20 21:01:40 livesey Exp $"
a1272 1
      frequencyCoordinate = l_none
d1279 1
d1284 1
a1285 1
        verticalCoordinate = l_geodAltitude
d1298 8
d1340 6
d1444 2
d1452 2
d1473 3
@


2.42
log
@Bug fix in DestroyL2PCInfoDatabase
@
text
@d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.41 2002/08/07 00:05:14 livesey Exp $"
d1126 10
a1135 13
    do blockRow = 1, l2pc%row%NB
      do blockCol = 1, l2pc%col%NB
        ! Access this block
        write ( name, * ) 'Block', blockRow, blockCol
        call h5gOpen_f ( blocksId, trim(name), blockId, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to open group for l2pc matrix block '//trim(name) )
        ! Could check it's the block we're expecting but I think I'll be lazy
        call GetHDF5Attribute ( blockID, 'kind', kind )
        if ( myShallow .or. kind == m_absent ) then
          if ( kind /= m_absent ) kind = m_unknown
          call CreateBlock ( l2pc, blockRow, blockCol, kind )
        else
a1150 1
        end if
d1152 10
a1161 2
    end do
    
d1454 3
@


2.41
log
@Moved H5Open/Close_F into tree walker.  Made some error messages more
informative.
@
text
@d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.40 2002/07/25 15:53:40 mjf Exp $"
d613 1
a613 3
          & 'Unable to hdf5 preserved input l2pc file' )
      else
        l2pcInfo(i)%fileID = 0
d615 1
d1450 4
@


2.40
log
@Initialised some elements of qt in ReadOneVectorFromASCII (already
done in ReadOneVectorFromHDF5)
@
text
@d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.39 2002/07/22 03:29:23 livesey Exp $"
a263 3
    call H5Open_F ( status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open hdf5 system' )
a275 3
    call H5Close_F ( status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close hdf5 system' )
d604 1
a604 1
        & 'Unable to close Blocks group' )
d607 1
a607 1
        & 'Unable to close matrix group' )
d613 1
a613 1
          & 'Unable to hdf5 l2pc file' )
a1022 3
    call H5Open_F ( status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open hdf5 system' )
d1026 1
a1026 1
      & 'Unable to open hdf5 l2pc file:'//trim(filename) )
d1031 1
a1031 1
      & 'Unable to get number of bins from file:'//trim(filename) )
d1095 1
a1095 1
      & 'Unable to get information on matrix in l2pc file' )
d1098 1
a1098 1
      & 'Unable to open matrix in l2pc file' )
d1107 1
a1107 1
      & 'Unable to access Blocks group of matrix' )
d1154 1
a1154 1
            & 'Unable to close group for l2pc matrix block '//trim(name) )
d1163 1
a1163 1
        & 'Unable to close Blocks group' )
d1166 1
a1166 1
        & 'Unable to close matrix group' )
d1451 4
@


2.39
log
@Bug fix
@
text
@d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.38 2002/07/22 03:25:23 livesey Exp $"
d877 3
d1460 3
@


2.38
log
@Bug fix and rework of loading vectors.
@
text
@d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.37 2002/07/17 06:00:21 livesey Exp $"
d727 1
a727 1
    end if
d1457 3
@


2.37
log
@Got hdf5 l2pc reading stuff working
@
text
@d15 1
a15 1
    & L_RADIANCE, L_PTAN
d21 1
a21 1
  use MatrixModule_1, only: CREATEBLOCK, CREATEEMPTYMATRIX, &
d35 2
a36 1
  use QuantityTemplates, only: ADDQUANTITYTEMPLATETODATABASE, QUANTITYTEMPLATE_T
d87 1
a87 1
       "$Id: L2PC_m.f90,v 2.36 2002/07/11 22:21:00 pwagner Exp $"
d711 1
a711 1
          call LoadFromHDF5DS ( blockId, 'r1', m0%r2 )
d724 5
d1043 4
d1186 7
a1192 1
    integer :: QUANTITY                 ! Loop inductor
d1194 3
a1196 1
    integer :: VID                      ! HDF5 ID of vector group
d1198 4
a1201 2
    integer :: OBJTYPE                  ! Irrelevant argument to HDF5
    integer :: INDEX                    ! Index into various arrays
d1204 2
a1205 3
    integer :: SIDEBAND                 ! Sideband -1,0,1
    integer :: NOSURFSOR1               ! Dimension
    integer :: NOINSTANCESOR1           ! Dimension
d1210 4
a1253 2
      ! Nullify stuff so we don't clobber our databases
      nullify ( qt%surfs, qt%phi )
d1263 1
a1263 1
      qt%name = stringIndex
d1269 1
a1269 1
      qt%quantityType = decl%units
d1272 5
a1276 1
      select case ( qt%quantityType )
d1281 1
a1281 1
        qt%molecule = decl%units
d1285 3
a1287 4
        qt%signal = sigInds(1)
        qt%sideband = sideband
        qt%frequencyCoordinate = l_channel
        qt%verticalCoordinate = l_geodAltitude
d1293 3
a1295 3
      call GetHDF5Attribute ( qID, 'noInstances', qt%noInstances )
      call GetHDF5Attribute ( qID, 'noSurfs', qt%noSurfs )
      call GetHDF5Attribute ( qID, 'noChans', qt%noChans )
d1299 18
a1316 8
      qt%verticalCoordinate = decl%units
      call GetHDF5Attribute ( qId, 'logBasis', qt%logBasis )
      call GetHDF5Attribute ( qId, 'coherent', qt%coherent )
      call GetHDF5Attribute ( qId, 'stacked', qt%stacked )

      ! This creates a rather minimal quantity template, it seems to be, but
      ! I'm modeling it after the ASCII version.  I wonder why I didn't use
      ! ConstructQuantityTemplate?
a1330 3
      call Allocate_test( qt%surfs, qt%noSurfs, noInstancesOr1, 'qt%surfs', ModuleName)
      call Allocate_test( qt%phi, noSurfsOr1, qt%noInstances, 'qt%phi', ModuleName)

d1340 6
d1457 3
@


2.36
log
@These hdf5-savvy versions transferred from he5lib
@
text
@d25 1
a25 1
    & MATRIXELEMENT_T
d27 3
a29 2
  use HDF5, only: H5FCREATE_F, H5FCLOSE_F, H5F_ACC_TRUNC_F, &
    & H5GCLOSE_F, H5GCREATE_F, H5GOPEN_F, H5GGET_OBJ_INFO_IDX_F
d48 1
a48 1
  public :: OutputHDF5L2PC
d76 8
d86 1
a86 1
       "$Id: L2PC_m.f90,v 1.3 2002/07/09 17:38:17 livesey Exp $"
d196 3
d201 26
d586 42
d671 54
d1006 46
d1053 1
a1053 1
  subroutine ReadOneHDF5L2PCRecord ( l2pc, fileID, index )
d1057 2
d1070 1
d1076 1
d1081 2
d1085 3
d1107 3
d1111 1
a1111 1
    call CreateEmptyMatrix ( l2pc, 0, l2pcVs(yStar), l2pcVs(xStar), &
d1115 7
d1132 3
a1134 7
        if ( kind == m_banded .or. kind == m_column_sparse ) then
          call GetHDF5Attribute ( blockID, 'noValues', noValues )
          call CreateBlock ( l2pc, blockRow, blockCol, kind, noValues )
          m0 => l2pc%block ( blockRow, blockCol )
          call LoadFromHDF5DS ( blockId, 'r1', m0%r1 )
          call LoadFromHDF5DS ( blockId, 'r1', m0%r2 )

d1136 15
a1150 2
          call CreateBlock ( l2pc, blockRow, blockCol, kind )
          m0 => l2pc%block ( blockRow, blockCol )
d1152 1
a1152 6
        if ( kind /= m_absent ) &
          call LoadFromHDF5DS ( blockID, 'values', m0%values )
        call h5gClose_f ( blockId, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to close group for l2pc matrix block '//trim(name) )
      end do
d1155 9
a1163 7
    ! Finish up
    call h5gClose_f ( blocksID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close Blocks group' )
    call h5gClose_f ( matrixID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close matrix group' )
a1199 1

d1210 1
d1215 1
a1215 1
      call h5gget_obj_info_idx_f ( location, name, quantity, thisName, &
d1268 1
a1268 1
      ! Now read the dimensions fo rhte quantity
d1282 3
a1284 1
      ! ConstructQuantityTemplte? 
d1367 1
a1367 1
    do quantity = 1, size(vector%quantities )
a1416 1

d1420 3
@


2.35
log
@Cosmetic changes
@
text
@d22 1
a22 1
    & DESTROYMATRIX, MATRIX_T, DUMP, FINDBLOCK, MATRIX_DATABASE_T, &
d26 3
d77 1
a77 1
       "$Id: L2PC_m.f90,v 2.34 2002/06/22 23:12:07 livesey Exp $"
d83 5
a87 1
contains ! ============= Public Procedures =============================
d89 1
a89 1
  ! -----------------------------------  AddBinSelectorToDatabase  -----
d100 1
a100 1
  ! ---------------------------------------  Add l2pc to database  -----
d115 1
a115 1
  ! --------------------------------------------  Close_L2PC_File  -----
d121 1
a121 1
  ! ---------------------------------  DestroyBinSelectorDatabase  -----
d139 1
a139 1
  ! ------------------------------------------------  DestroyL2PC  -----
d173 1
a173 1
  ! ----------------------------------------  DestroyL2PCDatabase  -----
d189 1
a189 1
  ! ---------------------------------------------  Open_L2PC_File  -----
d210 37
a246 1
  ! ---------------------------------------------- Read_l2pc_file  -----
d262 2
a263 1
      call ReadOneL2PC ( l2pc, lun, eof )
a264 1
      if (.not. eof) dummy = AddL2PCToDatabase ( l2pcDatabase, l2pc )
d278 118
a395 1
  ! -----------------------------------------------  WriteOneL2PC  -----
d507 1
a507 1

d548 1
a548 1
  ! ------------------------------------------  MakeMatrixPackMap  -----
d591 2
a592 13
  ! ---------------------------------------------  OutputHDF5L2PC  -----
  subroutine OutputHDF5L2PC ( filename, matrices, quantitiesNode, packed )
    character (len=*), intent(in) :: FILENAME
    type (Matrix_Database_T), dimension(:), pointer :: MATRICES
    integer, intent(in) :: QUANTITIESNODE
    logical, intent(in) :: PACKED

    call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Wrong version of L2PC_m used, no HDF5 support here' )
  end subroutine OutputHDF5L2PC

  ! ------------------------------------------------  ReadOneL2PC  -----
  subroutine ReadOneL2PC ( L2pc, Unit, Eof )
a619 4
!   Don't do the following.  The caller puts the associated actual argument
!   into a database using a shallow copy.  Destroying l2pc would clobber a
!   database item's fields.
!   call destroyMatrix ( l2pc ) ! Avoid memory leaks
d622 1
a622 1
    call ReadOneVector ( unit, xStar, eof )
d625 1
a625 1
    call ReadOneVector ( unit, yStar, eof )
d665 1
a665 1
  end subroutine ReadOneL2PC
d667 2
a668 2
  ! ----------------------------------------------  ReadOneVector  -----
  subroutine ReadOneVector ( unit, vector, eof )
a676 4
    ! Local saved variables
    integer, save :: L2PCQTCOUNTER = CounterStart ! To place in qt%id
    integer, save :: L2PCVTCOUNTER = CounterStart ! To place in vt%id
    
d870 340
a1209 1
  end subroutine ReadOneVector
d1214 4
a1217 1
! Revision 2.34  2002/06/22 23:12:07  livesey
d1220 2
a1221 2
! Revision 2.33  2002/06/12 18:00:12  livesey
! Stubs for HDF5 stuff
@


2.34
log
@Added sparsity dump
@
text
@d74 1
a74 1
       "$Id: L2PC_m.f90,v 2.33 2002/06/12 18:00:12 livesey Exp $"
d80 1
a80 1
contains ! ============= Public Procedures ==========================
d82 1
a82 1
  ! ------------------------------------ AddBinSelectorToDatabase --
d93 1
a93 1
  ! ------------------------------------  Add l2pc  to database ----
d108 1
a108 1
  ! -----------------------------------  Close_L2PC_File  -----
d114 1
a114 1
  ! -------------------------------------- DestroyBinSelectorDatabase
d132 1
a132 1
  ! ----------------------------------------------- DestroyL2PC ----
d166 1
a166 1
  ! ------------------------------------------- DestroyL2PCDatabase ---
d182 1
a182 1
  ! ------------------------------------ open_l2pc_file ------------
d203 1
a203 1
  ! ------------------------------------- Read_l2pc_file ------
d235 1
a235 1
  ! --------------------------------------- WriteOneL2PC ---------------
d388 1
a388 1
  ! ----------------------------------- MakeMatrixPackMap -----------
d431 1
a431 1
  ! --------------------------------------------- OutputHDF5L2PC
d442 1
a442 1
  ! --------------------------------------- WriteL2PC ---------------
d471 4
d522 1
a522 1
  ! ------------------------------------------ ReadOneVector ----------------
d734 3
@


2.33
log
@Stubs for HDF5 stuff
@
text
@d22 2
a23 1
    & DESTROYMATRIX, MATRIX_T, DUMP, FINDBLOCK, MATRIX_DATABASE_T
d35 1
a35 1
  use TOGGLES, only: TAB, TOGGLE
d74 1
a74 1
       "$Id: L2PC_m.f90,v 2.32 2002/05/21 01:13:24 livesey Exp $"
d220 1
d730 3
@


2.32
log
@New file format includes name for reading into IDL
@
text
@d22 1
a22 1
    & DESTROYMATRIX, MATRIX_T, DUMP, FINDBLOCK
d43 1
d73 1
a73 1
       "$Id: L2PC_m.f90,v 2.31 2002/03/15 21:22:42 livesey Exp $"
d429 11
d728 3
@


2.31
log
@Slight modification to binSelectors stuff
@
text
@d72 1
a72 1
       "$Id: L2PC_m.f90,v 2.30 2002/03/13 22:00:53 livesey Exp $"
d296 5
d557 4
d716 3
@


2.31.2.1
log
@*** empty log message ***
@
text
@d72 1
a72 1
       "$Id: L2PC_m.f90,v 2.32 2002/05/21 01:13:24 livesey Exp $"
a295 5

          ! Write quantity name - will be ignored on the read (at least by
          ! fortran, IDL pays attention
          call get_string ( qt%name, line )
          write (unit,*) trim(line)
a551 4

      ! Read and ignore the name, we're going on the type, at least for the
      ! moment.
      read (unit,*, IOSTAT=status) line
a706 6
! Revision 2.32  2002/05/21 01:13:24  livesey
! New file format includes name for reading into IDL
!
! Revision 2.31  2002/03/15 21:22:42  livesey
! Slight modification to binSelectors stuff
!
@


2.30
log
@Added output of vertical coordinate for xStar/yStar.
Note reading routine deduces value I think.
@
text
@d60 1
a60 1
    integer :: quantityType             ! What quantity type does this apply to
d72 1
a72 1
       "$Id: L2PC_m.f90,v 2.29 2002/03/13 01:28:48 livesey Exp $"
d707 4
@


2.29
log
@Commented out an error message I think I don't need
@
text
@d72 1
a72 1
       "$Id: L2PC_m.f90,v 2.28 2002/02/08 22:51:28 livesey Exp $"
d314 3
a316 2
          write (unit,*) qt%coherent, qt%stacked, &
            &  'coherent, stacked'
a531 1
    logical, parameter :: DEBUG=.false.
a536 1
      toggle(tab) = DEBUG
a546 16
    if(DEBUG) then
          print *, 'unit: ', unit
          print *, 'noQuantities: ', noQuantities
!          CALL output('Declaration table:', advance='yes')
!          call DUMP_DECL
!          CALL output('Symbol table:', advance='yes')
!          call DUMP_SYMBOL_CLASS(t_identifier)
          stringIndex = enter_terminal ( 'vmr', t_identifier, DEBUG )
          decl = get_decl ( stringIndex, type=enum_value )
          print *, 'Test of enter_terminal and get_decl parser functions'
          print *, 'literal: ', 'vmr'
          print *, 'decl%type: ', decl%type
          print *, 'decl%units: ', decl%units
          print *, 'decl%tree: ', decl%tree
          print *, 'decl%prior: ', decl%prior
    endif
d561 1
a561 1
      stringIndex = enter_terminal ( trim(line), t_identifier, DEBUG )
d707 3
@


2.28
log
@Minor changes and tidy up
@
text
@d72 1
a72 1
       "$Id: L2PC_m.f90,v 2.27 2002/02/05 04:14:26 livesey Exp $"
d316 4
a319 4
          if ( all (qt%verticalCoordinate /= (/ l_none, l_zeta /)) &
            & .and. (vector==1) .and. (qt%quantityType /= l_ptan) ) &
            &   call MLSMessage(MLSMSG_Error,ModuleName, &
            &     "Only zeta coordinates allowed (or none) for xStar.")
d724 3
@


2.27
log
@Bug fix, still problems with packed write
@
text
@d14 2
a15 1
  use Intrinsic, only: Lit_Indices, L_ZETA, L_NONE, L_VMR, L_RADIANCE, L_PTAN
d42 1
a42 1
  public :: BinSelectors, DestroyBinSelectorDatabase
d72 1
a72 1
       "$Id: L2PC_m.f90,v 2.26 2002/01/23 00:50:50 pwagner Exp $"
d582 4
a585 10
      if(DEBUG) then
          print *, 'Quantity: ', quantity
          print *, 'literal: ', trim(line)
          print *, 'decl%type: ', decl%type
          print *, 'decl%units: ', decl%units
          print *, 'decl%tree: ', decl%tree
          print *, 'decl%prior: ', decl%prior
          print *, 'QuantityName: ', qt%name
          print *, 'QuantityType: ', qt%quantityType
      endif
d612 2
d724 3
@


2.26
log
@Initialize binselectors to null
@
text
@d71 1
a71 1
       "$Id: L2PC_m.f90,v 2.25 2002/01/22 18:14:29 livesey Exp $"
d344 27
a370 24
        m0 => l2pc%block(blockRow, blockCol)
        write (unit,*) blockRow, blockCol, m0%kind,&
          & 'row, col, kind'
        call get_string ( &
          & l2pc%row%vec%quantities(&
          &    l2pc%row%quant(blockRow))%template%name, word1 )
        call get_string ( &
          & l2pc%col%vec%quantities(&
          &    l2pc%col%quant(blockCol))%template%name, word2 )
        write (unit,*) trim(word1), l2pc%row%inst(blockRow), ' , ',&
          &            trim(word2), l2pc%col%inst(blockCol)
        select case (m0%kind)
        case (M_Absent)
        case (M_Banded, M_Column_sparse)
          write (unit,*) size(m0%values), ' no values'
          write (unit,*) 'R1'
          write (unit,iFmt) m0%R1
          write (unit,*) 'R2'
          write (unit,iFmt) m0%R2
          write (unit,*) 'values'
          write (unit,rFmt) m0%values
        case (M_Full)
          write (unit,rFmt) m0%values
        end select
a536 1
    
d727 3
@


2.25
log
@Fixed typo.
@
text
@d67 1
a67 1
  type(BinSelector_T), dimension(:), pointer, save :: BINSELECTORS
d71 1
a71 1
       "$Id: L2PC_m.f90,v 2.24 2002/01/21 23:11:49 livesey Exp $"
d725 3
@


2.24
log
@Completed BinSelectors support
@
text
@d41 1
a41 1
  public :: BinSelectors
d71 1
a71 1
       "$Id: L2PC_m.f90,v 2.23 2002/01/21 21:13:42 livesey Exp $"
d725 3
@


2.23
log
@Added BinSelector definitions and support
@
text
@d41 1
d71 1
a71 1
       "$Id: L2PC_m.f90,v 2.22 2002/01/18 00:34:23 livesey Exp $"
d112 1
a112 2
  subroutine DestroyBinSelectorDatabase ( database )
    type (BinSelector_T), dimension(:), pointer :: DATABASE
d117 6
a122 6
    if ( .not. associated ( database ) ) return
    do i = 1, size(database)
      call Deallocate_test ( database(i)%signals, &
        & 'database%signals', ModuleName )
      call Deallocate_test ( database(i)%sidebands, &
        & 'database%sidebands', ModuleName )
d124 1
a124 1
    deallocate ( database, stat=status )
d126 1
a126 1
      & MLSMSG_Deallocate//"bin selectors database" )
d725 3
@


2.22
log
@Added packed option to writeonel2pc, with supporting code.
@
text
@d34 1
a34 1
  use Tree, only: DECORATION
d40 1
a40 1
  public :: Open_l2pc_file, read_l2pc_file, close_l2pc_file
d56 12
d70 1
a70 1
       "$Id: L2PC_m.f90,v 2.21 2001/06/21 22:45:43 livesey Exp $"
d78 11
d110 19
d725 3
@


2.21
log
@Found another one of those `clobbering the latest database item' gotchas in the code.
@
text
@d21 1
a21 1
    & DESTROYMATRIX, MATRIX_T, DUMP
d58 1
a58 1
       "$Id: L2PC_m.f90,v 2.20 2001/06/06 17:27:29 pwagner Exp $"
d66 123
d190 1
a190 1
  subroutine WriteOneL2PC ( L2pc, Unit )
d198 1
a203 1

d209 6
d222 12
a233 1
    ! executable code
d241 1
d245 1
d248 1
a248 1
      write (unit,*) size(v%quantities)
d251 5
a255 10
        qt => v%quantities(quantity)%template

        ! Write quantity type
        call get_string ( lit_indices(qt%quantityType), line )
        write (unit,*) trim(line)
        
        ! Write other info associated with type
        select case ( qt%quantityType )
        case (l_vmr)
          call get_string ( lit_indices(qt%molecule), line )
d257 25
a281 19
        case (l_radiance)
          call GetSignalName ( qt%signal, line, sideband=qt%sideband )
          write (unit,*) trim(line)
        end select

        ! Write out the dimensions for the quantity and the edges
        write (unit,*) qt%noChans, qt%noSurfs, qt%noInstances,&
          &  'noChans, noSurfs, noInstances'
        write (unit,*) qt%coherent, qt%stacked, &
          &  'coherent, stacked'
        if ( all (qt%verticalCoordinate /= (/ l_none, l_zeta /)) &
          & .and. (vector==1) .and. (qt%quantityType /= l_ptan) ) &
          &   call MLSMessage(MLSMSG_Error,ModuleName, &
          &     "Only zeta coordinates allowed (or none) for xStar.")
        write (unit,*) 'surfs'
        write (unit, rFmt) qt%surfs
        write (unit,*) 'phi'
        write (unit, rFmt) qt%phi

d285 7
a291 3
      do quantity = 1, size(v%quantities)
        write (unit,*) 'values', quantity
        write (unit,rFmt) v%quantities(quantity)%values
d330 46
a375 1
  
a679 123
  ! ------------------------------------ open_l2pc_file ------------
  subroutine Open_L2PC_File ( Filename, Lun )

    character(len=*), intent(in) :: Filename ! Name of the antenna pattern file
    integer, intent(out) :: Lun              ! Logical unit number to read it

    logical :: Exist, Opened
    integer :: Status

    do lun = 20, 99
      inquire ( unit=lun, exist=exist, opened=opened )
      if ( exist .and. .not. opened ) exit
    end do
    if ( opened .or. .not. exist ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "No logical unit numbers available" )
    open ( unit=lun, file=filename, status='old', form='formatted', &
      & access='sequential', iostat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "Unable to open l2pc file " // Filename )
  end subroutine Open_L2PC_File

  ! -----------------------------------  Close_L2PC_File  -----
  subroutine Close_L2PC_File ( Lun )
    integer, intent(in) :: lun
    close ( lun )
  end subroutine Close_L2PC_File

  ! ------------------------------------- Read_l2pc_file ------
  subroutine Read_l2pc_file ( Lun )
    use Trace_M, only: Trace_begin, Trace_end
    use Toggles, only: Toggle, gen
    ! Read all the bins in an l2pc file
    integer, intent(in) :: lun

    ! Local variables
    type (Matrix_T) :: L2pc
    integer :: Dummy
    logical :: Eof

    ! Executable code
    if ( toggle (gen) ) call trace_begin ( "Read_l2pc_file" )
    eof = .false.
    do while (.not. eof )
      call ReadOneL2PC ( l2pc, lun, eof )
      if (.not. eof) dummy = AddL2PCToDatabase ( l2pcDatabase, l2pc )

      ! Now nullify the pointers in l2pc so we don't clobber the one we've written
      nullify ( l2pc%block )
      nullify ( l2pc%row%nelts, l2pc%row%inst, l2pc%row%quant )
      nullify ( l2pc%col%nelts, l2pc%col%inst, l2pc%col%quant )
      nullify ( l2pc%row%vec%template%quantities, l2pc%col%vec%template%quantities )
      nullify ( l2pc%row%vec%quantities, l2pc%col%vec%quantities )
      
    end do

    if ( toggle (gen) ) call trace_end ( "Read_l2pc_file" )
  end subroutine Read_l2pc_file

  ! ------------------------------------  Add l2pc  to database ----
  integer function AddL2PCToDatabase ( Database, Item )
    
    ! This function simply adds an l2pc  to a database of said l2pc s.
    
    type(Matrix_T), dimension(:), pointer :: Database
    type(Matrix_T) :: Item
    
    type(Matrix_T), dimension(:), pointer :: TempDatabase

    include "addItemToDatabase.f9h"

    AddL2PCToDatabase = newSize
  end function AddL2PCToDatabase

  ! ----------------------------------------------- DestroyL2PC ----
  subroutine DestroyL2PC ( l2pc )
    ! Dummy arguments
    type (Matrix_T), intent(inout), target :: L2PC

    integer :: QUANTITY                 ! Loop index
    integer :: VECTOR                   ! Loop index

    type (QuantityTemplate_T), pointer :: Qt ! Temporary pointer
    type (Vector_T), pointer :: V       ! Temporary pointer

    ! Exectuable code
    do vector = 1, 2
      if ( vector == 1 ) then
        v => l2pc%col%vec
      else
        v => l2pc%row%vec
      end if
      
      do quantity = 1, size(v%quantities)
        qt => v%quantities(quantity)%template
        call deallocate_test (qt%surfs, 'qt%surfs', ModuleName)
        call deallocate_test (qt%phi, 'qt%phi', ModuleName)
        call deallocate_test (v%quantities(quantity)%values, 'q%values',&
          & ModuleName)
      end do
      deallocate (v%quantities)
    end do
    
    ! Destory kStar
    call DestroyMatrix ( l2pc )
    
  end subroutine DestroyL2PC

  ! ------------------------------------------- DestroyL2PCDatabase ---
  subroutine DestroyL2PCDatabase

    ! Local variables
    integer :: I, Status

    if (associated(l2pcDatabase)) then
      do i = 1, size(l2pcDatabase)
        call DestroyL2PC ( l2pcDatabase(i) )
      end do
      deallocate ( l2pcDatabase, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_deallocate // "l2pcDatabase" )
    end if
  end subroutine DestroyL2PCDatabase

d683 3
@


2.20
log
@DEBUG parameter; checks on some more reads
@
text
@d58 1
a58 1
       "$Id: L2PC_m.f90,v 2.19 2001/05/23 22:00:59 livesey Exp $"
d533 8
d614 3
@


2.19
log
@Changed counter start to avoid conflict with L2Parallel
@
text
@d13 1
a13 1
  use Declaration_Table, only: DECLS, ENUM_VALUE, GET_DECL
d15 1
d27 1
d31 1
a31 1
  use Symbol_Table, only: ENTER_TERMINAL
d33 1
d58 1
a58 1
       "$Id: L2PC_m.f90,v 2.18 2001/05/02 20:24:03 livesey Exp $"
d293 1
d299 1
d311 16
d334 8
a341 2
      read (unit,*) line
      stringIndex = enter_terminal ( trim(line), t_identifier )
d345 10
d359 7
a365 1
        read (unit,*) line
d371 7
a377 1
        read (unit,*) line
d386 12
a397 1
      read (unit,*) qt%noChans, qt%noSurfs, qt%noInstances
d399 7
a405 1
      read (unit,*) qt%coherent, qt%stacked
d421 28
a448 4
      read (unit,*) line              ! Line saying surfs
      read (unit,*) qt%surfs
      read (unit,*) line              ! Line saying phi
      read (unit,*) qt%phi
d471 14
a484 2
      read (unit,*) line              ! Just a comment line
      read (unit,*) l2pcVs(vector)%quantities(quantity)%values
d606 3
@


2.18
log
@Removed some unused variables.
@
text
@d51 1
a51 1
  parameter ( counterStart = huge (0) / 2 )
d55 1
a55 1
       "$Id: L2PC_m.f90,v 2.17 2001/05/02 20:23:10 vsnyder Exp $"
d504 3
@


2.17
log
@Specify a name for a created vector
@
text
@d55 1
a55 1
       "$Id: L2PC_m.f90,v 2.16 2001/04/28 01:38:36 livesey Exp $"
a80 1
    integer :: Instance                 ! Loop counter
a199 2
    integer :: I                        ! Test inex

a208 2
    type (QuantityTemplate_T), pointer :: TMP

a276 1
    integer :: INSTANCE                 ! Loop counter
d504 3
@


2.16
log
@Now maintains proper IDs for its own quantity and vector templates
@
text
@d55 1
a55 1
       "$Id: L2PC_m.f90,v 2.15 2001/04/28 01:26:50 livesey Exp $"
d382 1
a382 1
    v = CreateVector ( 0, l2pcVTs(vtIndex), l2pcQTs )
d510 3
@


2.15
log
@This one seems to work!
@
text
@d50 3
d55 1
a55 1
       "$Id: L2PC_m.f90,v 2.14 2001/04/27 17:36:33 livesey Exp $"
d271 4
d366 3
a368 1
      ! Now add this template to our private database
d375 2
d510 3
@


2.14
log
@An interim version
@
text
@d17 2
a18 1
    & VECTORTEMPLATE_T, VECTOR_T, VECTORVALUE_T
d27 2
a28 2
  use QuantityTemplates, only: QUANTITYTEMPLATE_T
  use String_Table, only: GET_STRING, DISPLAY_STRING
d39 10
a48 14
  ! Public types
  type, public :: l2pc_T
    logical :: readFromFile=.false.     ! See below
    type (Vector_T) :: xStar            ! The linearisation x
    type (Vector_T) :: yStar            ! The corresponding y
    type (Matrix_T) :: kStar            ! The jacobian matrix
  end type l2pc_T
  ! The read from file stuff is needed, because if it was created by hand the
  ! software will deallocate all the arrays associated with xStar, yStar and
  ! kStar when destory vectors etc. are called.  If on the other hand it was
  ! read from a file, we'll have to destroy these ourselves

  ! The l2pc database
  type(l2pc_T), dimension(:), pointer, public :: L2PCDatabase => NULL()
d52 1
a52 1
       "$Id: L2PC_m.f90,v 2.13 2001/04/27 07:24:50 livesey Exp $"
d67 1
a67 1
    type (l2pc_T), intent(in), target :: L2pc
d95 1
a95 1
        v => l2pc%xStar
d98 1
a98 1
        v => l2pc%yStar
d134 5
a138 2
        ! Write the values
        write (unit,*) 'values'
d140 1
a141 1
      end do                            ! Loop over quantities
d146 3
a148 3
    write (unit,*) l2pc%kStar%row%instFirst, l2pc%kStar%col%instFirst, 'Instances first'
    do blockRow = 1, l2pc%kStar%row%NB
      do blockCol = 1, l2pc%kStar%col%NB
d150 1
a150 1
        m0 => l2pc%kStar%block(blockRow, blockCol)
d154 2
a155 2
          & l2pc%kStar%row%vec%quantities(&
          &    l2pc%kStar%row%quant(blockRow))%template%name, word1 )
d157 4
a160 4
          & l2pc%kStar%col%vec%quantities(&
          &    l2pc%kStar%col%quant(blockCol))%template%name, word2 )
        write (unit,*) trim(word1), l2pc%kStar%row%inst(blockRow), ' , ',&
          &            trim(word2), l2pc%kStar%col%inst(blockCol)
d186 1
a186 1
    type (l2pc_T), intent(out), target :: L2pc
a193 4
    integer :: INSTANCE                 ! Loop counter
    integer :: NOINSTANCESOR1           ! For allocates
    integer :: NOSURFSOR1               ! For allocates
    integer :: NOQUANTITIES             ! Number of quantities in a vector
a194 4
    integer :: QUANTITY                 ! Loop counter
    integer :: SIDEBAND                 ! From parse signal
    integer :: STATUS                   ! Flag
    integer :: STRINGINDEX              ! Index of string
a196 1
    integer :: VECTOR                   ! Loop counter
d198 1
a198 1
    integer, dimension(:), pointer :: SIGINDS ! Result of parse signal
a204 1
    type (Decls) :: Decl                ! From the declaration table
d206 4
a209 3
    type (QuantityTemplate_T), pointer :: Qt  ! Temporary pointers
    type (VectorValue_T), pointer :: Vv ! Temporary pointer
    type (Vector_T), pointer :: V       ! Temporary pointer
a212 3
    nullify ( sigInds )
    l2pc%readFromFile = .true.

d214 2
a215 23
    do vector = 1, 2
      ! Identify vector
      if ( vector == 1 ) then
        read (unit,*, IOSTAT=status) line              ! Comment line
        if (status == -1 ) then
          eof = .true.
          return
        end if
        v => l2pc%xStar
      else
        read (unit,*) line              ! Comment line
        v => l2pc%yStar
      end if

      ! Note we fill this later

      read (unit,*) noQuantities
      allocate (v%quantities(noQuantities), STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName,&
        & MLSMSG_Allocate//"v%quantities")

      ! Loop over quantities
      do quantity = 1, noQuantities
d217 2
a218 80
        ! Create a template for this quantity
        allocate (v%quantities(quantity)%template, STAT=status)
        if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName,&
          & MLSMSG_Allocate//"v%quantities(:)%template")
        vv => v%quantities(quantity)
        qt => vv%template

        ! Read quantity type
        read (unit,*) line
        stringIndex = enter_terminal ( trim(line), t_identifier )
        decl = get_decl ( stringIndex, type=enum_value )
        qt%quantityType = decl%units
        qt%name = decl%units

        ! Write other info associated with type
        select case ( qt%quantityType )
        case (l_vmr)
          read (unit,*) line
          stringIndex = enter_terminal ( trim(line), t_identifier )
          decl = get_decl ( stringIndex, type=enum_value )
          qt%molecule = decl%units
          qt%name = decl%units
        case (l_radiance)
          read (unit,*) line
          call Parse_Signal (line, sigInds, sideband=sideband)
          qt%signal = sigInds(1)
          qt%sideband = sideband
          call deallocate_test(sigInds,'sigInds',ModuleName)
        case default
        end select

        ! Next read the dimensions for the quantity
        read (unit,*) qt%noChans, qt%noSurfs, qt%noInstances
        qt%instanceLen = qt%noChans* qt%noSurfs
        read (unit,*) qt%coherent, qt%stacked

        if (qt%coherent) then
          noInstancesOr1 = 1
        else
          noInstancesOr1 = qt%noInstances
        endif
        if (qt%stacked) then
          noSurfsOr1 = 1
        else
          noSurfsOr1 = qt%noSurfs
        endif

        call Allocate_test( qt%surfs, qt%noSurfs, noInstancesOr1, 'qt%surfs', ModuleName)
        call Allocate_test( qt%phi, noSurfsOr1, qt%noInstances, 'qt%phi', ModuleName)
        call Allocate_test( vv%values, qt%instanceLen, qt%noInstances,&
          & 'vv%values', ModuleName )

        read (unit,*) line              ! Line saying surfs
        read (unit,*) qt%surfs
        read (unit,*) line              ! Line saying phi
        read (unit,*) qt%phi

        ! Read the values
        read (unit,*) line              ! Line saying values
        read (unit,*) vv%values

      end do                            ! Loop over quantities

      ! Create a dummy template for this vector
      allocate (v%template, STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName,&
        & MLSMSG_Allocate//"v%template")
      v%template%noQuantities = noQuantities
      v%template%totalInstances = 0
      v%template%totalElements = 0
      do quantity = 1, noQuantities
        v%template%totalInstances = v%template%totalInstances + &
          & v%quantities(quantity)%template%noInstances
        v%template%totalElements = v%template%totalElements + &
          & v%quantities(quantity)%template%noInstances * &
          & v%quantities(quantity)%template%instanceLen
      end do
      ! Ignore the quantities stuff for the moment.
      ! If later versions need it we'll put something here
    end do                              ! Loop over xStar/yStar
d223 1
a223 1
    call CreateEmptyMatrix ( l2pc%kStar, 0, l2pc%yStar, l2pc%xStar,&
d226 1
d228 2
a229 2
    do blockRow = 1, l2pc%kStar%row%NB
      do blockCol = 1, l2pc%kStar%col%NB
d239 1
d242 2
a243 2
          call CreateBlock ( l2pc%kStar, blockRow, blockCol, blockKind, noValues )
          m0 => l2pc%kStar%block ( blockRow, blockCol )
d251 2
a252 2
          call CreateBlock ( l2pc%kStar, blockRow, blockCol, blockKind )
          m0 => l2pc%kStar%block ( blockRow, blockCol )
a256 1
!    call dump ( l2pc%kStar, details = 2)
d259 122
d416 1
a416 1
    type (l2pc_T) :: L2pc
a419 2
    type (VectorTemplate_T), pointer :: tmpX, tmpY

d425 1
a425 8
      if (.not. eof) then
        tmpX => l2pc%xStar%template
        tmpY => l2pc%yStar%template
        print*,'Testing after read:',&
          & associated(l2pc%xStar%template, l2pc%kStar%col%vec%template), &
          & associated(l2pc%yStar%template, l2pc%kStar%row%vec%template)
        dummy = AddL2PCToDatabase ( l2pcDatabase, l2pc )
      end if
a426 14
    print*,'Testing after add:',size(l2pcDatabase), &
      & associated(l2pcDatabase(1)%xStar%template, l2pcDatabase(1)%kStar%col%vec%template), &
      & associated(l2pcDatabase(1)%yStar%template, l2pcDatabase(1)%kStar%row%vec%template)
    print*,'Also:', &
      & associated(l2pcDatabase(1)%xStar%template, tmpX), &
      & associated(l2pcDatabase(1)%yStar%template, tmpY)
    print*,'And further more:', &
      & associated(l2pcDatabase(1)%kStar%col%vec%template), &
      & associated(l2pcDatabase(1)%kStar%row%vec%template)
    l2pcDatabase(1)%kStar%col%vec%template => tmpX
    l2pcDatabase(1)%kStar%row%vec%template => tmpY
    print*,'But having fixed it:',size(l2pcDatabase), &
      & associated(l2pcDatabase(1)%xStar%template, l2pcDatabase(1)%kStar%col%vec%template), &
      & associated(l2pcDatabase(1)%yStar%template, l2pcDatabase(1)%kStar%row%vec%template)
d436 2
a437 4
    type(l2pc_T), dimension(:), pointer :: Database
    type(l2pc_T) :: Item
    
    type(l2pc_T), dimension(:), pointer :: TempDatabase
d439 2
d449 1
a449 1
    type (l2pc_T), intent(inout), target :: L2PC
d458 13
a470 20
    ! If this wasn't created from a file we don't have to do anything,
    ! as the main program will call destroy vector info etc.
    ! if we did read it from a file, we need to do a bit of work but not much
    if ( l2pc%readFromFile ) then
      do vector = 1, 2
        if ( vector == 1 ) then
          v => l2pc%xStar
        else
          v => l2pc%yStar
        end if
        
        do quantity = 1, size(v%quantities)
          qt => v%quantities(quantity)%template
          call deallocate_test (qt%surfs, 'qt%surfs', ModuleName)
          call deallocate_test (qt%phi, 'qt%phi', ModuleName)
          call deallocate_test (v%quantities(quantity)%values, 'q%values',&
            & ModuleName)
        end do
        deallocate (v%template)
        deallocate (v%quantities)
d472 6
a477 5
      
      ! Destory kStar
      call DestroyMatrix ( l2pc%kStar)

    end if
d499 3
@


2.13
log
@Interim version.  Still loosing parts of kStar on add to database.
Might this be a compiler bug?
@
text
@d18 2
a19 1
  use MatrixModule_1, only: CREATEBLOCK, CREATEEMPTYMATRIX, DESTROYMATRIX, MATRIX_T
d55 1
a55 1
       "$Id: L2PC_m.f90,v 2.12 2001/04/27 07:05:28 livesey Exp $"
d262 1
d271 1
d366 1
a366 1

d433 5
d516 4
@


2.12
log
@Not sure what happened, needed to restore the use statements.
@
text
@d16 2
a17 1
  use VectorsModule, only: assignment(=), DESTROYVECTORINFO, VECTOR_T, VECTORVALUE_T
d54 1
a54 1
       "$Id: L2PC_m.f90,v 2.11 2001/04/26 23:55:17 livesey Exp $"
d405 2
d413 5
d421 1
a421 1
    print*,'Testing after add:',&
d424 6
d508 3
@


2.11
log
@Interim version
@
text
@d14 1
a14 1
  use Intrinsic, only: Lit_Indices, l_zeta, l_none
a19 2
  use MatrixModule_1, only: CREATEBLOCK, CREATEEMPTYMATRIX, DESTROYMATRIX, MATRIX_T
  use MLSCommon, only: R8
a28 1
  use VectorsModule, only: DESTROYVECTORINFO, VECTOR_T, VECTORVALUE_T
d53 1
a53 1
       "$Id: L2PC_m.f90,v 2.10 2001/04/26 22:32:04 vsnyder Exp $"
d494 3
@


2.10
log
@Alphabetize USEs and declarations
@
text
@d14 4
a17 2
  use Intrinsic, only: Lit_Indices, L_NONE, L_RADIANCE, L_TEMPERATURE, &
    & L_VMR, L_ZETA
d56 1
a56 1
       "$Id: L2PC_m.f90,v 2.9 2001/04/26 22:12:21 livesey Exp $"
d129 4
a132 4
        if ( any (qt%verticalCoordinate /= (/ l_none, l_zeta /)) &
          & .and. (vector==1) ) &
          & call MLSMessage(MLSMSG_Error,ModuleName, &
          & "Only zeta coordinates allowed (or none) for xStar.")
d412 3
a414 1
      dummy = AddL2PCToDatabase ( l2pcDatabase, l2pc )
d416 4
d497 3
@


2.9
log
@Fixed, gets l_zeta, l_none
@
text
@d14 2
a15 4
  use Intrinsic, only: Lit_Indices, l_zeta, l_none
  use MLSCommon, only: R8
  use VectorsModule, only: DESTROYVECTORINFO, VECTOR_T, VECTORVALUE_T
  use MatrixModule_1, only: CREATEBLOCK, CREATEEMPTYMATRIX, DESTROYMATRIX, MATRIX_T
d18 2
d22 1
a24 1
  use Intrinsic, only: L_RADIANCE, L_TEMPERATURE, L_VMR
d26 2
a27 3
  use MLSSignals_m, only: GETSIGNALNAME
  use SYMBOL_TABLE, only: ENTER_TERMINAL
  use SYMBOL_TYPES, only: T_IDENTIFIER
d29 1
d54 1
a54 1
       "$Id: L2PC_m.f90,v 2.8 2001/04/26 22:08:39 livesey Exp $"
d63 1
a63 1
  subroutine WriteOneL2PC ( l2pc, unit )
d69 2
a70 2
    type (l2pc_T), intent(in), target :: l2pc
    integer, intent(in) :: unit
d78 11
a88 11
    integer :: blockRow                 ! Index
    integer :: blockCol                 ! Index
    integer :: quantity                 ! Loop counter
    integer :: instance                 ! Loop counter
    integer :: vector                   ! Loop counter

    type (QuantityTemplate_T), pointer :: qt  ! Temporary pointers
    type (Vector_T), pointer :: v       ! Temporary pointer
    type (MatrixElement_T), pointer :: m0 ! A Matrix0 within kStar

    character (len=132) :: line,word1,word2 ! Line of text
d179 1
a179 1
  subroutine ReadOneL2PC ( l2pc, unit, eof )
d185 3
a187 3
    type (l2pc_T), intent(out), target :: l2pc
    integer, intent(in) :: unit
    logical, intent(inout) :: eof
d191 1
a192 1
    integer :: BLOCKKIND                ! Kind of matrix block
d208 1
a209 1
    logical :: COLINSTFIRST             ! Matrix order
d211 1
a211 5
    type (QuantityTemplate_T), pointer :: qt  ! Temporary pointers
    type (VectorValue_T), pointer :: vv ! Temporary pointer
    type (Vector_T), pointer :: v       ! Temporary pointer
    type (MatrixElement_T), pointer :: m0 ! A Matrix0 within kStar
    type (Decls) :: decl                ! From the declaration table
d213 5
a217 1
    character (len=132) :: line         ! Line of text
d394 1
a394 1
  subroutine Read_l2pc_file ( lun )
d401 3
a403 3
    type (l2pc_T) :: l2pc
    integer :: dummy
    logical :: eof
d438 2
a439 2
    type (Vector_T), pointer :: v       ! Temporary pointer
    type (QuantityTemplate_T), pointer :: qt ! Temporary pointer
d474 1
a474 1
    integer :: i, status
d489 3
@


2.8
log
@Add check on vertical coordinates
@
text
@d14 1
a14 1
  use Intrinsic, only: Lit_Indices
d54 1
a54 1
       "$Id: L2PC_m.f90,v 2.7 2001/04/26 20:02:26 livesey Exp $"
d489 3
@


2.7
log
@Made l2pc database a saved array in L2PC_m
@
text
@d54 1
a54 1
       "$Id: L2PC_m.f90,v 2.6 2001/04/26 19:33:03 livesey Exp $"
d127 4
d489 3
@


2.6
log
@Working version, reads and writes, (but no arithmetic :-) )
@
text
@d49 3
d54 1
a54 1
       "$Id: L2PC_m.f90,v 2.5 2001/04/26 02:48:08 vsnyder Exp $"
d390 1
a390 1
  subroutine Read_l2pc_file ( lun, l2pcDatabase )
a394 1
    type (l2pc_T), dimension(:), pointer :: l2pcDatabase
d467 1
a467 3
  subroutine DestroyL2PCDatabase (l2pcDatabase )
    ! Dummy arguments
    type (l2pc_T), dimension(:), pointer :: l2pcDatabase
d485 3
@


2.5
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d12 1
d17 1
a17 1
  use MatrixModule_1, only: DESTROYMATRIX, MATRIX_T
d22 1
d39 1
d44 4
d51 1
a51 1
       "$Id: $"
d54 1
a54 1
       "$RCSfile: $"
d115 1
a115 1
          call GetSignalName ( qt%signal, line )
d120 4
a123 2
        write (unit,*) qt%noSurfs, qt%noInstances, qt%noChans,&
          &  'noSurfs, noInstances, noChans'
a135 1

d138 1
d156 1
d185 1
d187 2
d190 1
d192 1
d195 2
d199 5
d205 1
d214 3
d246 2
a247 1
        qt => v%quantities(quantity)%template
d264 5
a268 1
!          call Parse_Signal (line, sigInds, 
d271 29
a299 11
!         ! Write out the dimensions for the quantity and the edges
!         write (unit,*) qt%noSurfs, qt%noInstances, qt%noChans,&
!           &  'noSurfs, noInstances, noChans'
!         write (unit,*) 'surfs'
!         write (unit, rFmt) qt%surfs
!         write (unit,*) 'phi'
!         write (unit, rFmt) qt%phi

!         ! Write the values
!         write (unit,*) 'values'
!         write (unit,rFmt) v%quantities(quantity)%values
d308 9
a316 3
!      v%template%totalInstances = sum(v%quantities%template%noInstances)
!      v%template%totalElements = sum(v%quantities%template%noInstances *&
!        & v%quantities%template%instanceLen)
d321 35
a355 30
!     ! Now dump kStar
!     write (unit,*) 'kStar'
!     do blockRow = 1, l2pc%kStar%row%NB
!       do blockCol = 1, l2pc%kStar%col%NB
!         ! Print the type of the matrix
!         m0 => l2pc%kStar%block(blockRow, blockCol)
!         write (unit,*) blockRow, blockCol, m0%kind,&
!           & 'row, col, kind'
!         call get_string ( &
!           & l2pc%kStar%row%vec%quantities(&
!           &    l2pc%kStar%row%quant(blockRow))%template%name, word1 )
!         call get_string ( &
!           & l2pc%kStar%col%vec%quantities(&
!           &    l2pc%kStar%col%quant(blockCol))%template%name, word2 )
!         write (unit,*) trim(word1), l2pc%kStar%row%inst(blockRow), ' , ',&
!           &            trim(word2), l2pc%kStar%col%inst(blockCol)
!         select case (m0%kind)
!         case (M_Absent)
!         case (M_Banded, M_Column_sparse)
!           write (unit,*) 'R1'
!           write (unit,iFmt) m0%R1
!           write (unit,*) 'R2'
!           write (unit,iFmt) m0%R2
!           write (unit,*) 'values'
!           write (unit,rFmt) m0%values
!         case (M_Full)
!           write (unit,rFmt) m0%values
!         end select
!       end do
!     end do
d388 2
d400 1
d406 1
d427 7
a433 1
    type (l2pc_T), intent(inout) :: L2PC
d436 24
a459 3
    call DestroyVectorInfo ( l2pc%xStar )
    call DestroyVectorInfo ( l2pc%yStar )
    call DestroyMatrix ( l2pc%kStar )
d461 1
d485 3
@


2.4
log
@Many changes. Working towards a working read routine
@
text
@d13 1
d42 7
a48 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=256), private :: Id = &
    & "$Id: L2PC_m.f90,v 2.3 2001/04/25 20:32:42 livesey Exp $"
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: L2PC_m.f90,v $"
  !---------------------------------------------------------------------------
d53 1
a53 1
  subroutine WriteOneL2PC ( l2pc, unit, lit_indices )
a60 1
    integer, intent(in), dimension(:) :: lit_indices
d162 1
a162 1
  subroutine ReadOneL2PC ( l2pc, unit, lit_indices, eof )
a169 1
    integer, dimension(:), intent(in) :: lit_indices
d327 1
a327 1
  subroutine Read_l2pc_file ( lun, lit_indices, l2pcDatabase )
a329 1
    integer, intent(in), dimension(:) :: lit_indices
d340 1
a340 1
      call ReadOneL2PC ( l2pc, lun, lit_indices, eof )
d393 3
@


2.3
log
@Interim version, tidied up write
@
text
@d12 1
d22 1
a22 1
  use String_Table, only: GET_STRING
d24 3
d32 1
d43 1
a43 1
    & "$Id: L2PC_m.f90,v 2.2 2001/04/24 20:20:48 livesey Exp $"
d61 5
d77 1
a77 1
    character (len=132) :: line         ! Line of text
d85 1
d88 1
d112 6
a117 3
        write (unit,*) qt%noSurfs, qt%noInstances, qt%noChans
        write (unit, 900) qt%surfs
        write (unit, 900) qt%phi
d120 2
a121 1
        write (unit,900) v%quantities(quantity)%values
a125 1
900 format (4(2x,1pg15.8))
d128 1
d130 1
a130 1
      do blockCol = 1, l2pc%kStar%row%NB
d133 10
a142 1
        write (unit,*) m0%kind
d146 6
a151 3
          write (unit,*) m0%R1
          write (unit,*) m0%R2
          write (unit,*) m0%values
d153 1
a153 1
          write (unit,*) m0%values
d161 1
a161 1
  subroutine ReadOneL2PC ( l2pc, unit )
d169 2
d173 8
a180 5
    integer :: blockRow                 ! Index
    integer :: blockCol                 ! Index
    integer :: quantity                 ! Loop counter
    integer :: instance                 ! Loop counter
    integer :: vector                   ! Loop counter
d185 1
d192 47
a238 25
!     do vector = 1, 2
!       ! Identify vector
!       if ( vector == 1 ) then
!         v => l2pc%xStar
!       else
!         v => l2pc%yStar
!       end if

!       ! Loop over quantities
!       do quantity = 1, size(v%quantities)
!         qt => v%quantities(quantity)%template

!         ! Write quantity type
!         call get_string ( qt%quantityType, line )
!         write (unit,*) trim(line)
        
!         ! Write other info associated with type
!         select case ( qt%quantityType )
!         case (l_vmr)
!           call get_string ( qt%molecule, line )
!           write (unit,*) trim(line)
!         case (l_radiance)
!           call GetSignalName ( qt%signal, line )
!           write (unit,*) trim(line)
!         end select
d241 6
a246 3
!         write (unit,*) qt%noSurfs, qt%noInstances, qt%noChans
!         write (unit,*) qt%surfs
!         write (unit,*) qt%phi
d249 2
a250 1
!         write (unit,*) v%quantities(quantity)%values
d252 13
a264 2
!       end do                            ! Loop over quantities
!     end do                              ! Loop over xStar/yStar
d267 1
d269 1
a269 1
!       do blockCol = 1, l2pc%kStar%row%NB
d272 10
a281 1
!         write (unit,*) m0%kind
d285 6
a290 3
!           write (unit,*) m0%R1
!           write (unit,*) m0%R2
!           write (unit,*) m0%values
d292 1
a292 1
!           write (unit,*) m0%values
d298 48
a345 1
  
d394 3
@


2.2
log
@Word bin dropped from various places e.g. type
@
text
@d27 1
a27 1
  public :: AddL2PCToDatabase, DestroyL2PC, DestroyL2PCDatabase
d38 1
a38 1
    & "$Id: L2PC_m.f90,v 2.1 2001/04/24 20:07:44 livesey Exp $"
d46 1
a46 1
  subroutine WriteOneL2PC ( l2pc, unit )
d54 1
d80 1
d86 1
a86 1
        call get_string ( qt%quantityType, line )
d92 1
a92 1
          call get_string ( qt%molecule, line )
d101 2
a102 2
        write (unit,*) qt%surfs
        write (unit,*) qt%phi
d105 1
a105 1
        write (unit,*) v%quantities(quantity)%values
d110 2
d263 3
@


2.1
log
@Moved in from l2
@
text
@d20 1
a20 1
  use Init_Tables_Module, only: L_RADIANCE, L_TEMPERATURE, L_VMR
d27 1
a27 1
  public :: AddL2PCBinToDatabase, DestroyL2PCBin
d30 1
a30 1
  type, public :: l2pcBin_T
d34 1
a34 1
  end type l2pcBin_T
d38 1
a38 1
    & "$Id: L2PC_m.f90,v 2.2 2001/04/24 20:05:22 livesey Exp $"
d45 3
a47 3
  ! --------------------------------------- WriteL2PCBin ---------------
  subroutine WriteL2PCBin ( l2pcBin, unit )
    ! This subroutine writes an l2pc bin to a file
d52 1
a52 1
    type (l2pcBin_T), intent(in), target :: l2pcBin
d74 1
a74 1
        v => l2pcBin%xStar
d76 1
a76 1
        v => l2pcBin%yStar
d109 2
a110 2
    do blockRow = 1, l2pcBin%kStar%row%NB
      do blockCol = 1, l2pcBin%kStar%row%NB
d112 1
a112 1
        m0 => l2pcBin%kStar%block(blockRow, blockCol)
d126 1
a126 1
  end subroutine WriteL2PCBin
d128 3
a130 3
  ! --------------------------------------- WriteL2PCBin ---------------
  subroutine ReadL2PCBin ( l2pcBin, unit )
    ! This subroutine writes an l2pc bin to a file
d135 1
a135 1
    type (l2pcBin_T), intent(out), target :: l2pcBin
d157 1
a157 1
!         v => l2pcBin%xStar
d159 1
a159 1
!         v => l2pcBin%yStar
d192 2
a193 2
!     do blockRow = 1, l2pcBin%kStar%row%NB
!       do blockCol = 1, l2pcBin%kStar%row%NB
d195 1
a195 1
!         m0 => l2pcBin%kStar%block(blockRow, blockCol)
d209 1
a209 1
  end subroutine ReadL2PCBin
d211 2
a212 2
  ! ------------------------------------  Add l2pc bin to database ----
  integer function AddL2PCBinToDatabase ( Database, Item )
d214 1
a214 1
    ! This function simply adds an l2pc bin to a database of said l2pc bins.
d216 2
a217 2
    type(l2pcBin_T), dimension(:), pointer :: Database
    type(l2pcBin_T) :: Item
d219 1
a219 1
    type(l2pcBin_T), dimension(:), pointer :: TempDatabase
d223 2
a224 2
    AddL2PCBinToDatabase = newSize
  end function AddL2PCBinToDatabase
d226 2
a227 2
  ! ----------------------------------------------- DestroyL2PCBin ----
  subroutine DestroyL2PCBin ( l2pcBin )
d229 1
a229 1
    type (l2pcBin_T), intent(inout) :: L2PCBIN
d232 3
a234 3
    call DestroyVectorInfo ( l2pcBin%xStar )
    call DestroyVectorInfo ( l2pcBin%yStar )
    call DestroyMatrix ( l2pcBin%kStar )
d236 19
a254 1
  end subroutine DestroyL2PCBin
d258 4
a261 1
! $Log$
@

