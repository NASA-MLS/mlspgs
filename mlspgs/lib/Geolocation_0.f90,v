head	2.17;
access;
symbols
	v5-02-NRT-19:2.17
	v6-00:2.17
	v5-02-NRT-18:2.17
	v5-02:2.17
	v5-01-NRT-17:2.17
	v5-01-NRT-16:2.17
	v5-01-NRT-15:2.17
	v5-01-NRT-14:2.17
	neuralnetworks-1-0:2.17.0.10
	cfm-single-freq-0-1:2.17.0.8
	v5-01:2.17
	v5-00:2.17
	v4-23-TA133:2.17.0.6
	mus-emls-1-70:2.17.0.4
	rel-1-0-englocks-work:2.17.0.2
	VUMLS1-00:2.17
	VPL1-00:2.10
	V4-22-NRT-08:2.10;
locks; strict;
comment	@# @;


2.17
date	2016.12.08.02.00.57;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2016.11.04.22.50.53;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2016.11.03.20.40.28;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2016.10.17.23.06.56;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2016.09.24.02.08.11;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2016.09.23.01.34.03;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2016.09.22.20.32.11;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2016.04.16.02.02.48;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2016.03.25.00.24.29;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2016.03.02.21.48.02;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2016.03.02.19.23.49;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2016.02.25.21.15.55;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2016.02.24.01.18.21;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2016.01.23.02.46.21;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2015.12.31.00.04.14;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2015.12.01.21.05.03;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2015.11.14.18.02.36;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.17
log
@Correct F***ingcd ../lib! units mistake (degrees vs. radians)
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module Geolocation_0
!=============================================================================

  ! Define types used in geolocation modules.

  use Constants, only: Deg2Rad, Rad2Deg
  use Earth_Constants, only: Earth_Axis_Ratio, Earth_Axis_Ratio_Squared, &
    & EarthRadA, EarthRadB, Eccentricity_Sq, RP
  use MLSKinds, only: RG => R8 ! Kind of REAL geolocation variables

  implicit NONE

  public

  ! Users should get these from their original definitions, not from here
  private :: Deg2Rad, Rad2Deg
  private :: Earth_Axis_Ratio, Earth_Axis_Ratio_Squared, &
    & EarthRadA, EarthRadB, Eccentricity_Sq, RP

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Geolocation_0.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

  type, abstract :: Lat_t ! For latitude; can't instantiate it
    real(rg) :: D       ! Degrees
  contains
    procedure :: Geoc => Lat_t_to_GeocLat_t  ! Simple type conversion only
    procedure :: Geod => Lat_t_to_GeodLat_t  ! Simple type conversion only
  end type Lat_t

  type, extends(lat_t) :: GeocLat_t
  ! real(rg) :: D       ! Geocentric latitude, degrees
  contains
    procedure :: Geod => Geoc_To_Geod_Lat
  end type GeocLat_t

  type, extends(lat_t) :: GeodLat_t
  ! real(rg) :: D       ! Geodetic latitude, degrees
  contains
    procedure :: Geoc => Geod_To_Geoc_Lat
  end type GeodLat_t

  type :: Lon_t         ! Longitude, degrees
    real(rg) :: D       ! Degrees
  end type Lon_t

  type :: H_t           ! For horizontal (lon/lat) grids, geoc/geod unspecified
    type(lon_t) :: Lon  ! Degrees
    real(rg) :: Lat     ! Degrees
  contains
    procedure :: ECR => H_t_To_ECR_Surf ! at the Earth's surface
    procedure, pass(geo) :: From_ECR => Surf_H_t_From_ECR ! useful because the
                                        ! desired dynamic result type (H_t) of
                                        ! ECR_to_Geoc cannot be used for
                                        ! dispatch
    procedure :: Geoc => H_t_to_H_Geoc  ! Simple type conversion only
    procedure :: Geod => H_t_to_H_Geod  ! Simple type conversion only
    procedure :: H_t_fields             ! A nonpolymorphic "self" component
                                        ! to avoid a defined output subroutine
    procedure :: Surf_ECR => H_t_To_ECR_Surf ! at the Earth's surface
  end type H_t

  type, extends(h_t) :: H_Geoc
  !  type(lon_t) :: Lon ! Longitude, degrees
  !  real(rg) :: Lat    ! Geocentric latitude, degrees
  contains
    procedure :: Geod => Geoc_To_Geod
  end type H_Geoc

  type, extends(h_t) :: H_Geod
  !  type(lon_t) :: Lon ! Longitude, degrees
  !  real(rg) :: Lat    ! Geodetic latitude, degrees
  contains
    procedure :: ECR => H_Geod_To_ECR_Surf
    procedure :: Geoc => Geod_To_Geoc
    procedure, pass(geo) :: From_ECR => Surf_Geod_From_ECR ! useful because the
                                        ! desired dynamic result type (H_geod)
                                        ! of ECR_to_Geod cannot be used for
                                        ! dispatch
    procedure, pass(geo) :: Surf_ECR => H_Geod_To_ECR_Surf
  end type H_Geod

  type :: V_t           ! For vertical grids of unspecified type
    real(rg) :: V       ! Geocentric (meters), geodetic (meters), or zeta
  end type V_t

  type, extends(v_t) :: V_geoc
  ! real(rg) :: V       ! geocentric height (meters from the Earth center)
  end type V_geoc

  type, extends(v_t) :: V_geod
  ! real(rg) :: V       ! geodetic height (meters above mean geoid)
  end type V_geod

  type, extends(v_t) :: V_zeta
  ! real(rg) :: V       ! Zeta -- geocentric latitude doesn't make sense if
                        ! the coordinate system is stacked
  end type V_zeta

  ! For irregular grids, or lines of sight, where H and V are expected to
  ! have the same extents
  type, extends(h_t) :: H_V_t
  ! type(lon_t) :: Lon  ! Degrees
  ! real(rg) :: Lat     ! Degrees
    real(rg) :: V       ! Meters or zeta
  contains
    procedure :: H_v_t_fields           ! A nonpolymorphic "self" component
                                        ! to avoid a defined output subroutine
    procedure, pass(geo) :: Surf_From_ECR => Surf_H_v_t_From_ECR ! useful
                        ! because the desired dynamic result type (H_t) of
                        ! ECR_to_Geoc cannot be used for dispatch
    procedure, pass(geo) :: Surf_ECR => H_V_t_To_ECR_Surf ! At the Earth's surface
  end type H_V_t

  type, extends(h_v_t) :: H_Geoc_V_Geod
  ! type(lon_t) :: Lon  ! Degrees
  ! real(rg) :: Lat     ! Degrees Geocentric
  ! real(rg) :: V       ! geodetic height (meters above mean geoid)
  contains
    procedure :: ECR => Geoc_Geod_To_ECR
  end type H_Geoc_V_Geod

  type, extends(h_v_t) :: H_V_Geoc
  ! type(lon_t) :: Lon  ! Degrees
  ! real(rg) :: Lat     ! Degrees Geocentric
  ! real(rg) :: V       ! geocentric height (meters from the Earth center)
  contains
    procedure :: ECR => Geoc_To_ECR
    procedure :: GeodV => GeocV_To_GeodV  ! Would be nice to call this Geod,
                        ! but the result type of the one it would override is
                        ! H_Geoc and we don't want to make the results
                        ! polymorphic
    procedure, pass(geo) :: From_ECR => Geoc_From_ECR ! useful because the
                        ! desired dynamic result type (H_v_geoc) of ECR_to_Geoc
                        ! cannot be used for dispatch
  end type H_V_Geoc

  type, extends(h_v_t) :: H_V_Geod
  ! type(lon_t) :: Lon  ! Degrees
  ! real(rg) :: Lat     ! Degrees Geodetic
  ! real(rg) :: V       ! geodetic height (meters above mean geoid)
  contains
    procedure :: ECR => Geod_To_ECR
    procedure :: GeocV => GeodV_To_GeocV  ! Would be nice to call this Geoc,
                        ! but the result type of the one it would override is
                        ! H_Geoc and we don't want to make the results
                        ! polymorphic
    procedure, pass(geo) :: From_ECR => Geod_From_ECR ! useful because the
                        ! desired dynamic result type (H_v_geod) of ECR_to_Geod
                        ! cannot be used for dispatch
    procedure, pass(geo) :: Surf_ECR => H_V_Geod_To_ECR_Surf ! ECR at the surface
    procedure, pass(geo) :: Surf_From_ECR => Surf_H_v_Geod_From_ECR ! useful
                        ! because the desired dynamic result type (H_geod) of
                        ! ECR_to_Geod cannot be used for dispatch
  end type H_V_Geod

  type, extends(h_v_t) :: H_V_Zeta
  ! type(lon_t) :: Lon  ! Degrees
  ! real(rg) :: Lat     ! Degrees
  ! real(rg) :: V       ! Zeta
  end type H_V_Zeta

  type :: ECR_t
    real(rg) :: XYZ(3)  ! Cartesian ECR, meters, or a unit vector
  contains
    procedure :: Add => ECR_add
    generic :: operator(+) => Add
    procedure :: Cross_Norm => ECR_Cross_Norm ! Unit length
    generic :: operator(.CROSSNORM.) => Cross_Norm
    procedure :: Cross_Product => ECR_Cross
    generic :: operator(.CROSS.) => Cross_Product
    procedure :: Dot_Product => ECR_Dot
    generic :: operator(.DOT.) => Dot_Product
    procedure :: Div => ECR_Divide ! All components by the same value
    procedure :: Div_Components => ECR_Divide_Components ! Separately
    generic :: operator(/) => Div, Div_Components
    procedure :: Geoc => ECR_to_Geoc
    procedure :: Geod => ECR_To_Geod_Fukushima
    procedure :: Geod_Surf => ECR_To_Geod_Surface
    generic :: Grad => Grad_Ellipsoid ! Unit gradient at surface
    generic :: Grad => Grad_Geoid     ! Unit gradient at surface
    procedure, pass(where) :: Grad_Ellipsoid => Ellipsoid_Gradient_RG
    procedure :: Grad_Geoid => Earth_Geoid_Gradient
    procedure :: Negate => ECR_Negate
    procedure :: Norm2 => ECR_Norm2
    procedure, pass(B) :: Scale_L => ECR_Scale_L
    procedure :: Scale_R => ECR_Scale_R
    procedure :: Subtract => ECR_Subtract
    generic :: operator(-) => Negate, Subtract
    generic :: operator(*) => Scale_L, Scale_R
  end type ECR_t

  type :: S_t        ! Descriptors of points along a line
    real(rg) :: S    ! Distance along Line(1) in the direction of Line(2)
  contains
    generic :: operator (*) => Scaled_Line_L, Scaled_Line_R
    procedure :: Scaled_Line_L            ! S_t%s * ECR_t => ECR_t
    procedure, pass(S) :: Scaled_Line_R   ! ECR_t * S_t%s => ECR_t
  end type S_t

  interface Cross
    module procedure ECR_Cross_Norm_Opt
  end interface

  interface Dot_Product
    module procedure ECR_Dot
  end interface

  interface Norm2
    module procedure ECR_Norm2
  end interface

! Uncomment these when we get past ifort 14 and 15

!   interface H_Geoc ! Construct H_Geoc object from an H_t one
!     module procedure H_t_to_H_Geoc
!   end interface
! 
!   interface H_Geod ! Construct H_Geod object from an H_t one
!     module procedure H_t_to_H_Geod
!   end interface

! *****     Private Constants     **************************************

! AQUAD   Square of major half axis for earth ellipsoid
! BQUAD   Square of minor half axis for earth ellipsoid

  real(rg), parameter, private :: AQUAD = EarthRadA**2 ! m**2
  real(rg), parameter, private :: BQUAD = EarthRadB**2 ! m**2

! *****     Procedures     *********************************************

contains

  pure elemental type(ECR_t) function Earth_Geoid_Gradient ( Where ) result ( Grad )
    class(ECR_t), intent(in) :: Where ! Where on the Geoid the gradient is desired
    real(rp), parameter :: A = EarthRadA, B = EarthRadB
    grad = ECR_t ( where%xyz / [ A, A, B ]**2 )
    grad = grad / grad%norm2()
  end function Earth_Geoid_Gradient

  pure type(ECR_t) function Ellipsoid_Gradient_RG ( Axes, Center, Where ) &
    & result ( Grad )
    real(rg), intent(in) :: Axes(3)    ! Semi-minor axes in same units as Center
    type(ECR_t), intent(in) :: Center  ! Center of the ellipsoid
    class(ECR_t), intent(in) :: Where  ! Where on the Geoid the gradient is desired
    grad = ECR_t ( ( where%xyz - center%xyz ) / axes**2 )
    grad = grad / grad%norm2()
  end function Ellipsoid_Gradient_RG

  pure elemental type(ECR_t) function ECR_Add ( A, B )
    class(ECR_t), intent(in) :: A, B
    ECR_Add = ECR_t ( a%xyz + b%xyz )
  end function ECR_Add

  pure elemental type(ECR_t) function ECR_Cross ( A, B )
    use Cross_m, only: Cross
    class(ECR_t), intent(in) :: A, B
    ECR_Cross%xyz = cross(a%xyz,b%xyz)
  end function ECR_Cross

  pure elemental type(ECR_t) function ECR_Negate ( A )
    class(ECR_t), intent(in) :: A
    ECR_Negate%xyz = -A%xyz
  end function ECR_Negate

  pure elemental type(ECR_t) function ECR_Cross_Norm ( A, B ) result ( ECR_Cross )
    use Cross_m, only: Cross
    class(ECR_t), intent(in) :: A, B
    ECR_Cross%xyz = cross(a%xyz,b%xyz,norm=.true.)
  end function ECR_Cross_Norm

  pure elemental type(ECR_t) function ECR_Cross_Norm_Opt ( A, B, Norm ) result ( ECR_Cross )
    use Cross_m, only: Cross
    class(ECR_t), intent(in) :: A, B
    logical, intent(in), optional :: Norm
    ECR_Cross%xyz = cross(a%xyz,b%xyz,norm)
  end function ECR_Cross_Norm_Opt

  ! Divide all the elements of the component by the same value
  pure elemental type(ECR_t) function ECR_Divide ( A, B )
    class(ECR_t), intent(in) :: A
    real(rg), intent(in) :: B
    ECR_Divide = ECR_t ( a%xyz / b )
  end function ECR_Divide

  ! Divide each element of the component by a different value
  pure type(ECR_t) function ECR_Divide_Components ( A, B )
    class(ECR_t), intent(in) :: A
    real(rg), intent(in) :: B(3)
    ECR_Divide_Components = ECR_t ( a%xyz / b )
  end function ECR_Divide_Components

  pure elemental real(rg) function ECR_Dot ( A, B )
    class(ECR_t), intent(in) :: A, B
    ECR_Dot = dot_product ( a%xyz, b%xyz )
  end function ECR_Dot

  pure elemental real(rg) function ECR_Norm2 ( A )
    class(ECR_t), intent(in) :: A
    ECR_Norm2 = norm2(a%xyz)
  end function ECR_Norm2

  pure elemental type(ECR_t) function ECR_Scale_L ( A, B )
    real(rg), intent(in) :: A
    class(ECR_t), intent(in) :: B
    ECR_Scale_L = ECR_t ( a * b%xyz )
  end function ECR_Scale_L

  pure elemental type(ECR_t) function ECR_Scale_R ( A, B )
    class(ECR_t), intent(in) :: A
    real(rg), intent(in) :: B
    ECR_Scale_R = ECR_t ( a%xyz * b )
  end function ECR_Scale_R

  pure elemental type(ECR_t) function ECR_Subtract ( A, B )
    class(ECR_t), intent(in) :: A, B
    ECR_subtract = ECR_t ( a%xyz - b%xyz )
  end function ECR_Subtract

  pure elemental type(h_v_geoc) function ECR_To_Geoc ( ECR ) result ( Geoc )
    class(ECR_t), intent(in) :: ECR
    real(rg) :: Rho, Rho2
    rho2 = ECR%xyz(1)**2 + ECR%xyz(2)**2
    rho = sqrt(rho2)
    geoc%lon%d = rad2deg * atan2(ECR%xyz(2), ECR%xyz(1))
    geoc%lat = rad2deg * asin(ECR%xyz(3)/rho)
    geoc%v = sqrt(rho2 + ECR%xyz(3)**2)
  end function ECR_To_Geoc

  pure elemental type(h_v_geod) function ECR_To_Geod_Fukushima ( ECR ) result ( Geod )
    class(ECR_t), intent(in) :: ECR

    real(rg), parameter :: A = EarthRadA, B = EarthRadB
    real(rg), parameter :: Ec = Earth_Axis_Ratio ! b/a
    ! Square of first eccentricity = 1 - a^2/b^2
    real(rg), parameter :: E2 = Eccentricity_Sq
    real(rg), parameter :: Tol = tiny(1.0_rg)**(1.0/3.0) / A
    integer, parameter :: MaxIt = 1  ! Maximum number of iterations.  In Journal
                                     ! of Geodesy (2006) 79: 689-693, Fukushima
                                     ! says one iteration gets within a few micro
                                     ! arcseconds for heights below 30,000 km.

    real(rg) :: An, An3, Ap, Bn, Dn, Fn  ! Terms in the iteration
    real(rg) :: Cc                       ! Ec * Cn
    real(rg) :: Cn, Cp                   ! Cosine-like iterate, previous value
    integer :: I
    real(rg) :: P                        ! S / a
    real(rg) :: S                        ! sqrt ( x**2 + y**2 )
    real(rg) :: Sn, Sp                   ! Sine-like iterate, previous value
    real(rg) :: Z                        ! Ec * |z| / a

    ! Computing longitude is easy
    geod%lon%d = rad2deg * atan2 ( ECR%xyz(2), ECR%xyz(1) )

    s = sqrt ( ECR%xyz(1)**2 + ECR%xyz(2)**2 )
    if ( s < sqrt(tiny(1.0_rg)) ) then ! Too near the poles
      geod%lat = sign(90.0_rg,ECR%xyz(3))
      geod%v = abs(ECR%xyz(3)) - b
      return
    end if

    ! Now the Fukushima iteration for latitude
    P = s / a
    Z = abs(ECR%xyz(3)) * Ec / a
    Sp = Z
    Cp = Ec * P
    Ap = sqrt ( Sp**2 + Cp**2 )
    Bn = 1.5_rg * E2**2 * P * Sp**2 * Cp**2 * ( Ap - Ec )
    i = 1
    do
      An3 = Ap ** 3
      Dn = Z * An3 + E2 * Sp**3
      Fn = P * An3 - E2 * Cp**3
      Sn = Dn * Fn - Bn * Sp
      Cn = Fn**2 - Bn * Cp
      An = sqrt ( Sn**2 + Cn**2 )
      if ( i >= maxIt ) exit
      i = i + 1
      if ( abs(Cn-Cp) < tol * abs(p) .or. abs(Sn-Sp) < tol * Z ) exit
      Ap = An
      Bn = 1.5_rg * E2 * Sn * Cn**2 * ( ( P * Sn - Z * Cn ) * Ap - &
         & E2 * Sn * Cn )
      Cp = Cn
      Sp = Sn
    end do
    Cc = Ec * Cn
    ! Compute geodetic latitude
    geod%lat = sign ( rad2deg * atan2(Sn,Cc), ECR%xyz(3) )
    ! Compute geodetic height
    geod%v = ( s * Cc + abs(ECR%xyz(3)) * Sn - b * An ) / sqrt ( Cc**2 + Sn**2 )

  end function ECR_To_Geod_Fukushima

  pure elemental function ECR_To_Geod_Surface ( ECR ) result ( Geo )
    class(ECR_t), intent(in) :: ECR
    type(h_geod) :: Geo
    type(h_v_geoc) :: Geoc
    geoc = ecr%geoc()
    geo = geoc%geod()
  end function ECR_To_Geod_Surface

  pure elemental subroutine Geoc_From_ECR ( ECR, Geo )
    class(ECR_t), intent(in) :: ECR
    class(h_v_geoc), intent(inout) :: Geo ! intent(out) is prohibited
    type(h_v_geoc) :: MyGeo ! Needed because assignment to polymorphic Geo is
                            ! prohibited
    myGeo = ECR%geoc()
    geo%lon = myGeo%lon
    geo%lat = myGeo%lat
    geo%v = myGeo%v
  end subroutine Geoc_From_ECR

  pure elemental type(ECR_t) function Geoc_Geod_To_ECR ( Geo, Norm ) &
    & result ( ECR )
    ! Convert geocentric coordinates at the Earth surface plus geodetic
    ! height to ECR
    class(h_geoc_v_geod), intent(in) :: Geo
    logical, intent(in), optional :: Norm ! Compute normalized ECR
    type(ECR_t) :: Surf
    surf = geo%h_t%ECR() ! ECR coordinates of geocentric coordinates at the
                         ! Earth geoid surface
    ECR = surf + geo%v * surf%grad()
    if ( present(norm) ) then
      if ( norm ) ECR = ECR/norm2(ECR)
    end if
  end function Geoc_Geod_To_ECR

  pure elemental type(ECR_t) function Geoc_To_ECR ( Geo, Norm ) result ( ECR )
    ! Convert geocentric coordinates to ECR coordinates in meters
    class(h_v_geoc), intent(in) :: Geo
    logical, intent(in), optional :: Norm ! Compute normalized ECR
    real(rg) :: CosLat, Lat, Lon
    logical MyNorm
    myNorm = .false.
    if ( present(norm) ) myNorm = norm
    lat = geo%lat * deg2rad
    lon = geo%lon%d * deg2rad
    cosLat = cos(lat)
    ECR%xyz(1) = cosLat * cos(lon)
    ECR%xyz(2) = cosLat * sin(lon)
    ECR%xyz(3) = sin(lat)
    if ( .not. myNorm ) ECR = ECR * geo%v
  end function Geoc_To_ECR

  pure elemental function Geoc_To_Geod ( Geo ) result ( Geod )
    class(h_geoc), intent(in) :: Geo
    type(h_geod) :: Geod
    real(rp), parameter :: F2 = Earth_Axis_Ratio_Squared ! (b/a)**2
    real(rg) :: Lat
    geod%lon = geo%lon
    lat = geo%lat * deg2rad
    geod%lat = atan2 ( sin(lat), f2 * cos(lat) ) * rad2deg
  end function Geoc_To_Geod

  pure elemental function Geoc_To_Geod_Lat ( Geo ) result ( Geod )
    class(geocLat_t), intent(in) :: Geo
    type(geodLat_t) :: Geod
    real(rp), parameter :: F2 = Earth_Axis_Ratio_Squared ! (b/a)**2
    real(rg) :: Lat
    lat = geo%d * deg2rad
    geod%d = atan2 ( sin(lat), f2 * cos(lat) ) * rad2deg
  end function Geoc_To_Geod_Lat

  pure elemental type(h_v_geod) function GeocV_To_GeodV ( Geo ) result ( Geod )
    class(h_v_geoc), intent(in) :: Geo
    type(ECR_t) :: ECR
  ! geod = geoc%ECR()%geod()   ! Prohibited (why?)
    ECR = geo%ECR()
    geod = ECR%geod()
  end function GeocV_To_GeodV

  pure elemental subroutine Geod_From_ECR ( ECR, Geo )
    class(ECR_t), intent(in) :: ECR
    class(h_v_geod), intent(inout) :: Geo ! intent(out) is prohibited
    type(h_v_geod) :: MyGeo ! Needed because assignment to polymorphic Geo is
                            ! prohibited
    myGeo = ECR%geod()
    geo%lon = myGeo%lon
    geo%lat = myGeo%lat
    geo%v = myGeo%v
  end subroutine Geod_From_ECR

  pure elemental type(ECR_t) function Geod_To_ECR ( Geo, Norm ) result ( ECR )
    ! Convert geodetic coordinates to ECR coordinates in meters
    class(h_v_geod), intent(in) :: Geo
    logical, intent(in), optional :: Norm
    real(rg) :: MyLon
    real(rg) :: Rho
    call h_v_geod_to_geoc_support ( geo, ECR%xyz(3), rho )
    myLon = geo%lon%d * deg2rad
    ECR%xyz(1) = rho * cos(myLon)
    ECR%xyz(2) = rho * sin(myLon)
    if ( present(norm) ) then
      if ( norm ) ECR = ECR / norm2(ECR)
    end if
  end function Geod_To_ECR

  pure elemental type(h_geoc) function Geod_To_Geoc ( Geo ) result ( Geoc )
    class(h_geod), intent(in) :: Geo
    real(rp), parameter :: F2 = Earth_Axis_Ratio_Squared ! (b/a)**2
    real(rg) :: Lat
    geoc%lon = geo%lon
    lat = geo%lat * deg2rad
    geoc%lat = atan2 ( f2 * sin(lat), cos(lat) ) * rad2deg
  end function Geod_To_Geoc

  pure elemental type(GeocLat_t) function Geod_To_Geoc_Lat ( Geo ) result ( Geoc )
    class(GeodLat_t), intent(in) :: Geo
    real(rp), parameter :: F2 = Earth_Axis_Ratio_Squared ! (b/a)**2
    real(rg) :: Lat
    lat = geo%d * deg2rad
    geoc%d = atan2 ( f2 * sin(lat), cos(lat) ) * rad2deg
  end function Geod_To_Geoc_Lat

  pure elemental type(h_v_geoc) function GeodV_To_GeocV ( Geo ) result ( Geoc )
    ! Convert geodetic coordinates to Geocentric coordinates, including heights
    class(h_v_geod), intent(in) :: Geo
    real(rg) :: Rho
    real(rg) :: Z    ! Would be Z coordinate of ECR
    call h_v_geod_to_geoc_support ( geo, z, rho )
    geoc%lon = geo%lon
    geoc%lat = atan2 ( z, rho ) * rad2deg
    geoc%v = sqrt ( rho**2 + z**2 ) ! geocentric height
  end function GeodV_To_GeocV

  pure elemental type(ECR_t) function H_Geod_To_ECR_Surf ( Geo, Norm ) result ( ECR )
    ! Convert geodetic coordinates at the Earth surface to ECR coordinates
    class(h_geod), intent(in) :: Geo
    logical, intent(in), optional :: Norm
    ECR = geod_to_ECR_surf ( geo%lon%d, geo%lat, norm )
  end function H_Geod_To_ECR_Surf

  ! Nonpolymorphic result; useful to avoid writing a defined output routine
  pure elemental type(h_t) function H_t_Fields ( Geo )
    class(h_t), intent(in) :: Geo
    h_t_fields = h_t(lon=geo%lon, lat=geo%lat)
  end function H_t_Fields

  pure elemental type(ECR_t) function H_t_To_ECR_Surf ( Geo, Norm ) result ( ECR )
    ! Convert geocentric coordinates at the Earth surface to ECR coordinates
    class(h_t), intent(in) :: Geo
    logical, intent(in), optional :: Norm
    ECR = geoc_to_ECR_surf ( geo%lon%d, geo%lat, norm )
  end function H_t_To_ECR_Surf

  ! Construct an H_Geoc object from an H_t one
  pure elemental type(h_geoc) function H_t_to_H_Geoc ( Geo ) result ( G )
    class(h_t), intent(in) :: Geo
    g = h_geoc(geo%lon,geo%lat)
  end function H_t_to_H_Geoc

  ! Construct an H_Geod object from an H_t one
  pure elemental type(h_geod) function H_t_to_H_Geod ( Geo ) result ( G )
    class(h_t), intent(in) :: Geo
    g = h_geod(geo%lon,geo%lat)
  end function H_t_to_H_Geod

  pure elemental type(ECR_t) function H_V_Geod_To_ECR_Surf ( Geo, Norm ) result ( ECR )
    ! Convert geodetic coordinates at the Earth surface to ECR coordinates
    class(h_v_geod), intent(in) :: Geo
    logical, intent(in), optional :: Norm
    ECR = geod_to_ECR_surf ( geo%lon%d, geo%lat, norm )
  end function H_V_Geod_To_ECR_Surf

  ! Nonpolymorphic result; useful to avoid writing a defined output routine
  pure elemental type(h_v_t) function H_v_t_Fields ( Geo )
    class(h_v_t), intent(in) :: Geo
    h_v_t_fields = h_v_t(lon=geo%lon, lat=geo%lat, v=geo%v)
  end function H_v_t_Fields

  pure elemental type(ECR_t) function H_V_t_To_ECR_Surf ( Geo, Norm ) result ( ECR )
    ! Convert geodetic coordinates at the Earth surface to ECR coordinates
    class(h_v_t), intent(in) :: Geo
    logical, intent(in), optional :: Norm
    ECR = geoc_to_ECR_surf ( geo%lon%d, geo%lat, norm )
  end function H_V_t_To_ECR_Surf

  pure elemental type (GeocLat_t) function Lat_t_to_GeocLat_t ( Geo ) result ( G )
    class(lat_t), intent(in) :: Geo
    g = GeocLat_t(geo%d)
  end function Lat_t_to_GeocLat_t

  pure elemental type (GeodLat_t) function Lat_t_to_GeodLat_t ( Geo ) result ( G )
    class(lat_t), intent(in) :: Geo
    g = GeodLat_t(geo%d)
  end function Lat_t_to_GeodLat_t

  pure elemental function Scaled_Line_L ( S, Line ) result ( R )
    class(S_t), intent(in) :: S
    type(ECR_t), intent(in) :: Line
    type(ECR_t) :: R ! ifort 16.0.2 rejects type decl in the function header
    r = s%s * line
  end function Scaled_Line_L

  pure elemental function Scaled_Line_R ( Line, S ) result ( R )
    type(ECR_t), intent(in) :: Line
    class(S_t), intent(in) :: S
    type(ECR_t) :: R ! ifort 16.0.2 rejects type decl in the function header
    r = line * s%s
  end function Scaled_Line_R

  pure elemental subroutine Surf_Geod_From_ECR ( ECR, Geo )
    class(ECR_t), intent(in) :: ECR
    class(h_geod), intent(inout) :: Geo ! intent(out) is prohibited
    type(h_v_geod) :: MyGeo
    myGeo = ECR%geod()
    geo%lon = myGeo%lon
    geo%lat = myGeo%lat
  end subroutine Surf_Geod_From_ECR

  pure elemental subroutine Surf_H_t_From_ECR ( ECR, Geo )
    class(ECR_t), intent(in) :: ECR
    class(h_t), intent(inout) :: Geo ! intent(out) is prohibited
    geo%lon%d = rad2deg * atan2(ECR%xyz(2), ECR%xyz(1))
    geo%lat = rad2deg * asin(ECR%xyz(3)/sqrt(ECR%xyz(1)**2 + ECR%xyz(2)**2))
  end subroutine Surf_H_t_From_ECR

  pure elemental subroutine Surf_H_v_Geod_From_ECR ( ECR, Geo )
    class(ECR_t), intent(in) :: ECR
    class(h_v_geod), intent(inout) :: Geo ! intent(out) is prohibited
    type(h_v_geod) :: MyGeo
    myGeo = ECR%geod()
    geo%lon = myGeo%lon
    geo%lat = myGeo%lat
    geo%v = 0
  end subroutine Surf_H_v_Geod_From_ECR

  pure elemental subroutine Surf_H_v_t_From_ECR ( ECR, Geo )
    class(ECR_t), intent(in) :: ECR
    class(h_v_t), intent(inout) :: Geo ! intent(out) is prohibited
    call geo%h_t%from_ECR ( ECR )
    geo%v = 0
  end subroutine Surf_H_v_t_From_ECR

!  =====     Private Procedures     ====================================

  pure elemental type(ECR_t) function Geoc_To_ECR_Surf ( Lon, Lat, Norm ) result ( ECR )
    ! Convert geocentric coordinates at the Earth surface to ECR coordinates
    real(rg), intent(in) :: Lon, Lat ! Degrees
    logical, intent(in), optional :: Norm
    real(rp), parameter :: E2 = Eccentricity_Sq
    real(rg) :: MyLat, MyLon, R, Rho, ST
    myLat = lat * deg2rad
    myLon = lon * deg2rad
    st = sin(myLat)
    ! Geocentric radius at geocentric latitude
    ! r = ab / sqrt ( a^2 cos^2(myLat) + b^2 sin^2(myLat) )
    r = earthRadB / sqrt( 1 - e2 * st * st )
    rho = r * cos(myLat)
    ECR%xyz(1) = rho * cos(myLon)
    ECR%xyz(2) = rho * sin(myLon)
    ECR%xyz(3) = r * st
    if ( present(norm) ) then
      if ( norm ) ECR = ECR / norm2(ECR)
    end if
  end function Geoc_To_ECR_Surf

  pure elemental type(ECR_t) function Geod_To_ECR_Surf ( Lon, Lat, Norm ) result ( ECR )
    ! Convert geodetic coordinates at the Earth surface to ECR coordinates
    real(rg), intent(in) :: Lon, Lat ! Degrees
    logical, intent(in), optional :: Norm
    real(rg) :: D      ! sqrt(a^2 ct^2 + b^2 st^2)
    real(rg) :: MyLon  ! longitude in radians
    real(rg) :: Rho    ! a^2/d cos(lat)
    real(rg) :: ST     ! sin(lat)
    call geod_to_geoc_support ( lat, d, rho, st )
    myLon = lon * deg2rad
    ecr%xyz(1) = rho * cos(myLon)
    ecr%xyz(2) = rho * sin(myLon)
    ecr%xyz(3) = bquad * d * st
    if ( present(norm) ) then
      if ( norm ) ECR = ECR / norm2(ECR)
    end if
  end function Geod_To_ECR_Surf

  pure elemental subroutine Geod_To_Geoc_Support ( Lat, D, Rho, St )
    real(rg), intent(in) :: Lat   ! Geodetic latitude, degrees
    real(rg), intent(out) :: D
    real(rg), intent(out) :: Rho  ! sqrt(X^2+Y^2) of ECR
    real(rg), intent(out) :: St   ! Sin(myLat)
    real(rg) :: Ct    ! cos(myLat)
    real(rg) :: MyLat ! Geodetic latitude, radians
    myLat = lat * deg2rad
    st = sin(myLat)
    ct = cos(myLat)
    d = 1.0_rg / sqrt(aquad*ct*ct + bquad*st*st)
!   d = 1.0_rg / sqrt(aquad-(aquad-bquad)*st*st)
    rho = aquad * d * ct
  end subroutine Geod_To_Geoc_Support

  pure elemental subroutine H_V_Geod_To_Geoc_Support ( Geod, Z, Rho )
    class(h_v_geod), intent(in) :: Geod
    real(rg), intent(out) :: Z    ! Z coordinate of ECR
    real(rg), intent(out) :: Rho  ! sqrt(X^2+Y^2) of ECR
    real(rg) :: Ct   ! cos(lat)
    real(rg) :: D
    real(rg) :: Lat
    real(rg) :: St   ! Sin(lat)
    lat = geod%lat * deg2rad
    st = sin(lat)
    ct = cos(lat)
    d = 1.0_rg / sqrt(aquad*ct*ct + bquad*st*st)
!   d = 1.0_rg / sqrt(aquad-(aquad-bquad)*st*st)
    z = ( geod%v + bquad * d ) * st
    rho = ( geod%v + aquad * d ) * ct
  end subroutine H_V_Geod_To_Geoc_Support

!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Geolocation_0.f90,v 2.16 2016/11/04 22:50:53 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Geolocation_0

! $Log: Geolocation_0.f90,v $
! Revision 2.16  2016/11/04 22:50:53  vsnyder
! Make as many type-bound procedures as possible elemental
!
! Revision 2.15  2016/11/03 20:40:28  vsnyder
! Add ECR_To_Geod_Surface
!
! Revision 2.14  2016/10/17 23:06:56  vsnyder
! Intent(OUT) polymorphic dummy argument of pure subroutine is prohibited
!
! Revision 2.13  2016/09/24 02:08:11  vsnyder
! Add Surf_ECR to H_t, H_V_t, and extensions other than H_V_Zeta
!
! Revision 2.12  2016/09/23 01:34:03  vsnyder
! Add H_v_t_fields to H_v_t, for the same reason as adding H_t_fields
!
! Revision 2.11  2016/09/22 20:32:11  vsnyder
! Add H_t_fields to type H_t.  This is a subterfuge to access essentially
! the entire object from a polymorphic version of it, so we don't need to
! write defined I/O subroutines.  Ugh.
!
! Revision 2.10  2016/04/16 02:02:48  vsnyder
! Add Negate, type to represent position on a line
!
! Revision 2.9  2016/03/25 00:24:29  vsnyder
! Change type of Lon component from real(rg) to type(lon_t).  Add
! Div_Components binding to ECR_t and add it to Operator(/) generic.
! Change the Cross generic to ECR_Cross_Norm_Opt because operator
! generics cannot have optional arguments.  Add Norm option to
! Geoc_Geod_To_ECR, Geoc_to_ECR, Geod_To_ECR, Geod_To_ECR_Surf, and
! H_t_To_ECR_Surf.
!
! Revision 2.8  2016/03/02 21:48:02  vsnyder
! Add H_Geoc_V_Geod and ellipsoid gradient functions
!
! Revision 2.7  2016/03/02 19:23:49  vsnyder
! Add From_ECR bindings to H_t, H_Geod, and H_V_Geod -- H_Geoc inherits from
! H_t.  Add Surf_From_ECR bindings to H_V_t and H_V_Geod.  Add NORM2 binding
! to ECR_t.  Add NORM2 generic interface.  Make ECR_Divide, ECR_Scale_L, and
! ECR_Scale_R elemental.
!
! Revision 2.6  2016/02/25 21:15:55  vsnyder
! Comment out generics for H_Geoc and H_Geod because ifort 15 doesn't like
! them.  Add a bunch of type-conversion bindings.  Move some USE statements.
! Make stuff used from Constants Earth_Constants private.
!
! Revision 2.5  2016/02/24 01:18:21  vsnyder
! Add more coordinate conversions, add arithmetic for ECR.
!
! Revision 2.4  2016/01/23 02:46:21  vsnyder
! Add type-bound coordinate conversions
!
! Revision 2.3  2015/12/31 00:04:14  vsnyder
! Make V_t and H_V_t nonabstract
!
! Revision 2.2  2015/12/01 21:05:03  vsnyder
! Make H_t non-abstract
!
! Revision 2.1  2015/11/14 18:02:36  vsnyder
! Initial commit
!
@


2.16
log
@Make as many type-bound procedures as possible elemental
@
text
@d657 4
a660 2
    real(rg) :: R, Rho, ST
    st = sin(lat)
d662 1
a662 1
    ! r = ab / sqrt ( a^2 cos^2(lat) + b^2 sin^2(lat) )
d664 3
a666 3
    rho = r * cos(lat)
    ECR%xyz(1) = rho * cos(lon)
    ECR%xyz(2) = rho * sin(lon)
d727 1
a727 1
       "$Id: Geolocation_0.f90,v 2.15 2016/11/03 20:40:28 vsnyder Exp $"
d737 3
@


2.15
log
@Add ECR_To_Geod_Surface
@
text
@d245 2
d249 1
a249 1
  pure type(ECR_t) function Earth_Geoid_Gradient ( Where ) result ( Grad )
d270 1
a270 1
  pure type(ECR_t) function ECR_Cross ( A, B )
d276 1
a276 1
  pure type(ECR_t) function ECR_Negate ( A )
d281 1
a281 1
  pure type(ECR_t) function ECR_Cross_Norm ( A, B ) result ( ECR_Cross )
d287 1
a287 1
  pure type(ECR_t) function ECR_Cross_Norm_Opt ( A, B, Norm ) result ( ECR_Cross )
d308 1
a308 1
  pure real(rg) function ECR_Dot ( A, B )
d725 1
a725 1
       "$Id: Geolocation_0.f90,v 2.14 2016/10/17 23:06:56 vsnyder Exp $"
d735 3
@


2.14
log
@Intent(OUT) polymorphic dummy argument of pure subroutine is prohibited
@
text
@d193 1
d407 8
d723 1
a723 1
       "$Id: Geolocation_0.f90,v 2.13 2016/09/24 02:08:11 vsnyder Exp $"
d733 3
@


2.13
log
@Add Surf_ECR to H_t, H_V_t, and extensions other than H_V_Zeta
@
text
@d408 1
a408 1
    class(h_v_geoc), intent(out) :: Geo
d478 1
a478 1
    class(h_v_geod), intent(out) :: Geo
d608 1
a608 1
    class(h_geod), intent(out) :: Geo
d617 1
a617 1
    class(h_t), intent(out) :: Geo
d624 1
a624 1
    class(h_v_geod), intent(out) :: Geo
d634 1
a634 1
    class(h_v_t), intent(out) :: Geo
d714 1
a714 1
       "$Id: Geolocation_0.f90,v 2.12 2016/09/23 01:34:03 vsnyder Exp $"
d724 3
@


2.12
log
@Add H_v_t_fields to H_v_t, for the same reason as adding H_t_fields
@
text
@d74 1
d88 1
a88 1
    procedure :: ECR => Geod_To_ECR_Surf
d94 1
d126 1
d165 1
d493 1
a493 1
    call geod_to_geoc_support ( geo, ECR%xyz(3), rho )
a501 24
  pure elemental type(ECR_t) function Geod_To_ECR_Surf ( Geo, Norm ) result ( ECR )
    ! Convert geodetic coordinates at the Earth surface to ECR coordinates
    class(h_geod), intent(in) :: Geo
    logical, intent(in), optional :: Norm
    real(rg) :: CT   ! cos(lat)
    real(rg) :: D    ! sqrt(a^2 ct^2 + b^2 st^2)
    real(rg) :: Lat  ! geodetic latitude in radians
    real(rg) :: Lon  ! longitude in radians
    real(rg) :: Rho  ! a^2/d cos(lat)
    real(rg) :: ST   ! sin(lat)
    lat = geo%lat * deg2rad
    ct = cos(lat)
    st = sin(lat)
    d = 1.0 / sqrt(aquad*ct*ct + bquad*st*st)
    rho = aquad * d * ct
    lon = geo%lon%d * deg2rad
    ecr%xyz(1) = rho * cos(lon)
    ecr%xyz(2) = rho * sin(lon)
    ecr%xyz(3) = bquad * d * st
    if ( present(norm) ) then
      if ( norm ) ECR = ECR / norm2(ECR)
    end if
  end function Geod_To_ECR_Surf

d524 1
a524 1
    call geod_to_geoc_support ( geo, z, rho )
d530 7
d547 1
a547 15
    real(rp), parameter :: E2 = Eccentricity_Sq
    real(rg) :: Lat, Lon, R, Rho, ST
    lat = geo%lat * deg2rad
    st = sin(lat)
    ! Geocentric radius at geocentric latitude
    ! r = ab / sqrt ( a^2 cos^2(lat) + b^2 sin^2(lat) )
    r = earthRadB / sqrt( 1 - e2 * st * st )
    lon = geo%lon%d * deg2rad
    rho = r * cos(lat)
    ECR%xyz(1) = rho * cos(lon)
    ECR%xyz(2) = rho * sin(lon)
    ECR%xyz(3) = r * st
    if ( present(norm) ) then
      if ( norm ) ECR = ECR / norm2(ECR)
    end if
d562 7
d575 7
d641 53
a693 1
  pure elemental subroutine Geod_To_Geoc_Support ( Geod, Z, Rho )
d708 1
a708 1
  end subroutine Geod_To_Geoc_Support
d714 1
a714 1
       "$Id: Geolocation_0.f90,v 2.11 2016/09/22 20:32:11 vsnyder Exp $"
d724 3
@


2.11
log
@Add H_t_fields to type H_t.  This is a subterfuge to access essentially
the entire object from a polymorphic version of it, so we don't need to
write defined I/O subroutines.  Ugh.
@
text
@d61 1
a61 1
  type :: H_t           ! For horizontal (lat/lon) grids, geoc/geod unspecified
d72 2
a73 1
    procedure :: H_t_fields             ! A "self" component
d119 2
d550 2
a551 1
  pure elemental type(h_t) function H_t_fields ( Geo )
d554 1
a554 1
  end function H_t_fields
d589 6
d675 1
a675 1
       "$Id: Geolocation_0.f90,v 2.10 2016/04/16 02:02:48 vsnyder Exp $"
d685 5
@


2.10
log
@Add Negate, type to represent position on a line
@
text
@a65 2
    procedure :: Geoc => H_t_to_H_Geoc  ! Simple type conversion only
    procedure :: Geod => H_t_to_H_Geod  ! Simple type conversion only
d70 3
d547 5
d665 1
a665 1
       "$Id: Geolocation_0.f90,v 2.9 2016/03/25 00:24:29 vsnyder Exp $"
d675 3
@


2.9
log
@Change type of Lon component from real(rg) to type(lon_t).  Add
Div_Components binding to ECR_t and add it to Operator(/) generic.
Change the Cross generic to ECR_Cross_Norm_Opt because operator
generics cannot have optional arguments.  Add Norm option to
Geoc_Geod_To_ECR, Geoc_to_ECR, Geod_To_ECR, Geod_To_ECR_Surf, and
H_t_To_ECR_Surf.
@
text
@d189 1
d194 1
a194 1
    generic :: operator(-) => Subtract
d198 8
d265 5
d589 14
d659 1
a659 1
       "$Id: Geolocation_0.f90,v 2.8 2016/03/02 21:48:02 vsnyder Exp $"
d669 8
@


2.8
log
@Add H_Geoc_V_Geod and ellipsoid gradient functions
@
text
@a18 1
  use MLSKinds, only: RG => R8 ! Kind of REAL geolocation variables
d21 1
d38 23
d62 1
a62 1
    real(rg) :: Lon     ! Degrees
d75 1
a75 1
  !  real(rg) :: Lon    ! Longitude, degrees
d82 1
a82 1
  !  real(rg) :: Lon    ! Longitude, degrees
a92 23
  type, abstract :: Lat_t ! For latitude; can't instantiate it
    real(rg) :: D       ! Degrees
  contains
    procedure :: Geoc => Lat_t_to_GeocLat_t  ! Simple type conversion only
    procedure :: Geod => Lat_t_to_GeodLat_t  ! Simple type conversion only
  end type Lat_t

  type, extends(lat_t) :: GeocLat_t
  ! real(rg) :: D       ! Geocentric latitude, degrees
  contains
    procedure :: Geod => Geoc_To_Geod_Lat
  end type GeocLat_t

  type, extends(lat_t) :: GeodLat_t
  ! real(rg) :: D       ! Geodetic latitude, degrees
  contains
    procedure :: Geoc => Geod_To_Geoc_Lat
  end type GeodLat_t

  type :: Lon_t         ! Longitude, degrees
    real(rg) :: D       ! Degrees
  end type Lon_t

d113 1
a113 1
  ! real(rg) :: Lon     ! Degrees
d123 1
a123 1
  ! real(rg) :: Lon     ! Degrees
d131 1
a131 1
  ! real(rg) :: Lon     ! Degrees
d146 1
a146 1
  ! real(rg) :: Lon     ! Degrees
d164 1
a164 1
  ! real(rg) :: Lon     ! Degrees
d174 2
d180 3
a182 2
    procedure :: Div => ECR_Divide
    generic :: operator(/) => Div
d198 1
a198 1
    module procedure ECR_Cross
d256 14
d276 7
d315 1
a315 1
    geoc%lon = rad2deg * atan2(ECR%xyz(2), ECR%xyz(1))
d343 1
a343 1
    geod%lon = rad2deg * atan2 ( ECR%xyz(2), ECR%xyz(1) )
d348 1
a348 1
      geod%v = ECR%xyz(3) - b
d395 2
a396 1
  pure elemental type(ECR_t) function Geoc_Geod_To_ECR ( Geo ) result ( ECR )
d400 1
d405 3
d410 1
a410 1
  pure elemental type(ECR_t) function Geoc_To_ECR ( Geo ) result ( ECR )
d413 5
a417 1
    real(rg) :: Lat, Lon, Rho
d419 6
a424 5
    lon = geo%lon * deg2rad
    rho = geo%v * cos(lat)
    ECR%xyz(1) = rho * cos(lon)
    ECR%xyz(2) = rho * sin(lon)
    ECR%xyz(3) = geo%v * sin(lat)
d465 1
a465 1
  pure elemental type(ECR_t) function Geod_To_ECR ( Geo ) result ( ECR )
d468 1
d472 1
a472 1
    myLon = geo%lon * deg2rad
d475 3
d480 1
a480 1
  pure elemental type(ECR_t) function Geod_To_ECR_Surf ( Geo ) result ( ECR )
d483 1
d495 1
a495 1
    lon = geo%lon * deg2rad
d499 3
d532 1
a532 1
  pure elemental type(ECR_t) function H_t_To_ECR_Surf ( Geo ) result ( ECR )
d535 1
d543 1
a543 1
    lon = geo%lon * deg2rad
d548 3
d587 1
a587 1
    geo%lon = rad2deg * atan2(ECR%xyz(2), ECR%xyz(1))
d631 1
a631 1
       "$Id: Geolocation_0.f90,v 2.7 2016/03/02 19:23:49 vsnyder Exp $"
d641 3
@


2.7
log
@Add From_ECR bindings to H_t, H_Geod, and H_V_Geod -- H_Geoc inherits from
H_t.  Add Surf_From_ECR bindings to H_V_t and H_V_Geod.  Add NORM2 binding
to ECR_t.  Add NORM2 generic interface.  Make ECR_Divide, ECR_Scale_L, and
ECR_Scale_R elemental.
@
text
@d102 1
a102 1
  ! real(rg) :: V       ! geodetic height (meters above sea level)
d122 8
d132 1
a132 1
  ! real(rg) :: Lat     ! Degrees
d147 2
a148 2
  ! real(rg) :: Lat     ! Degrees
  ! real(rg) :: V       ! geodetic height (meters above sea level)
d182 4
d226 16
d371 10
d585 1
a585 1
       "$Id: Geolocation_0.f90,v 2.6 2016/02/25 21:15:55 vsnyder Exp $"
d595 6
@


2.6
log
@Comment out generics for H_Geoc and H_Geod because ifort 15 doesn't like
them.  Add a bunch of type-conversion bindings.  Move some USE statements.
Make stuff used from Constants Earth_Constants private.
@
text
@d45 4
d64 4
d116 4
d122 1
a122 1
  type, extends(h_geoc) :: H_V_Geoc
d125 1
a125 1
    real(rg) :: V       ! geocentric height (meters from the Earth center)
d132 3
d137 1
a137 1
  type, extends(h_geod) :: H_V_Geod
d140 1
a140 1
    real(rg) :: V       ! geodetic height (meters above sea level)
d147 6
d155 1
a155 1
  type, extends(h_geod) :: H_V_Zeta
d158 1
a158 1
    real(rg) :: V       ! Zeta
d174 1
d190 4
d225 1
a225 1
  pure type(ECR_t) function ECR_Divide ( A, B )
d236 6
a241 1
  pure type(ECR_t) function ECR_Scale_L ( A, B )
d247 1
a247 1
  pure type(ECR_t) function ECR_Scale_R ( A, B )
d332 11
d346 1
a346 1
    real(rg) ::Lat, Lon, Rho
d382 11
d491 33
d547 1
a547 1
       "$Id: Geolocation_0.f90,v 2.5 2016/02/24 01:18:21 vsnyder Exp $"
d557 5
@


2.5
log
@Add more coordinate conversions, add arithmetic for ECR.
@
text
@d18 1
d20 2
a21 2
  use Earth_Constants, only: Earth_Axis_Ratio, EarthRadA, EarthRadB, &
    & Eccentricity_Sq
d27 5
d43 2
d64 3
d116 4
a119 2
  ! procedure :: ECR_Unit => Geod_To_ECR_Unit ! Inherited from H_t via H_Geoc
    procedure :: GeodV => GeocV_To_GeodV
d128 4
a131 2
  ! procedure :: ECR_Unit => Geod_To_ECR_Unit ! Inherited from H_t via H_Geod
    procedure :: GeocV => GeodV_To_GeocV
d145 4
a148 4
    procedure :: Cross => ECR_Cross
    generic :: operator(.CROSS.) => Cross
    procedure :: Dot => ECR_Dot
    generic :: operator(.DOT.) => Dot
d168 1
a168 3
  interface H_Geoc ! Construct H_Geoc object from an H_t one
    module procedure H_t_to_H_Geoc
  end interface
d170 7
a176 3
  interface H_Geod ! Construct H_Geod object from an H_t one
    module procedure H_t_to_H_Geod
  end interface
d183 2
a184 2
  real(rg), parameter :: AQUAD = EarthRadA**2 ! m**2
  real(rg), parameter :: BQUAD = EarthRadB**2 ! m**2
a227 1
    use Constants, only: rad2deg
a237 1
    use Constants, only: rad2deg
a302 1
    use Constants, only: deg2rad
d313 2
a314 4
  pure elemental function Geoc_To_Geod ( Geoc ) result ( Geod )
    use Constants, only: deg2rad, rad2deg
    use Earth_Constants, only: F2 => Earth_Axis_Ratio_Squared ! (b/a)**2
    class(h_geoc), intent(in) :: Geoc
d316 1
d318 2
a319 2
    geod%lon = geoc%lon
    lat = geoc%lat * deg2rad
d323 2
a324 4
  pure elemental function Geoc_To_Geod_Lat ( Geoc ) result ( Geod )
    use Constants, only: deg2rad, rad2deg
    use Earth_Constants, only: F2 => Earth_Axis_Ratio_Squared ! (b/a)**2
    class(geocLat_t), intent(in) :: Geoc
d326 1
d328 1
a328 1
    lat = geoc%d * deg2rad
d332 2
a333 2
  pure elemental type(h_v_geod) function GeocV_To_GeodV ( Geoc ) result ( Geod )
    class(h_v_geoc), intent(in) :: Geoc
d336 1
a336 1
    ECR = geoc%ECR()
a341 1
    use Constants, only: deg2rad
a352 1
    use Constants, only: deg2rad
d371 3
a373 11
  pure elemental type(ECR_t) function Geod_To_ECR_Unit ( Geod ) result ( ECR )
    ! Convert geodetic coordinates to unit ECR coordinates
    class(h_v_geod), intent(in) :: Geod
    ECR = geod%ECR()
    ECR%xyz = ECR%xyz / norm2(ECR%xyz)
  end function Geod_To_ECR_Unit

  pure elemental type(h_geoc) function Geod_To_Geoc ( Geod ) result ( Geoc )
    use Constants, only: deg2rad, rad2deg
    use Earth_Constants, only: F2 => Earth_Axis_Ratio_Squared ! (b/a)**2
    class(h_geod), intent(in) :: Geod
d375 2
a376 2
    geoc%lon = geod%lon
    lat = geod%lat * deg2rad
d380 3
a382 4
  pure elemental type(GeocLat_t) function Geod_To_Geoc_Lat ( Geod ) result ( Geoc )
    use Constants, only: deg2rad, rad2deg
    use Earth_Constants, only: F2 => Earth_Axis_Ratio_Squared ! (b/a)**2
    class(GeodLat_t), intent(in) :: Geod
d384 1
a384 1
    lat = geod%d * deg2rad
d388 1
a388 1
  pure elemental type(h_v_geoc) function GeodV_To_GeocV ( Geod ) result ( Geoc )
d390 1
a390 2
    use Constants, only: rad2deg
    class(h_v_geod), intent(in) :: Geod
d393 2
a394 2
    call geod_to_geoc_support ( geod, z, rho )
    geoc%lon = geod%lon
a400 2
    use Constants, only: deg2rad
    use Earth_Constants, only: E2 => Eccentricity_Sq
d402 1
d416 23
a438 1
!  -----     Private Procedures     ------------------------------------
a440 1
    use Constants, only: deg2rad
a456 12
  ! Construct an H_Geoc object from an H_t one
  pure elemental type(h_geoc) function H_t_to_H_Geoc ( H ) result ( G )
    type(h_t), intent(in) :: H
    g = h_geoc(h%lon,h%lat)
  end function H_t_to_H_Geoc

  ! Construct an H_Geod object from an H_t one
  pure elemental type(h_geod) function H_t_to_H_Geod ( H ) result ( G )
    type(h_t), intent(in) :: H
    g = h_geod(h%lon,h%lat)
  end function H_t_to_H_Geod

d461 1
a461 1
       "$Id: Geolocation_0.f90,v 2.4 2016/01/23 02:46:21 vsnyder Exp $"
d471 3
@


2.4
log
@Add type-bound coordinate conversions
@
text
@d35 2
a42 1
    procedure :: ECR => Geoc_To_ECR_Unit
d50 1
d60 2
d66 2
d106 1
a106 3
    procedure :: Geod => GeocV_To_GeodV          ! class(h_geod) result with
                                                 ! dynamic type(h_v_geod)
    procedure :: GeodV => GeocV_To_GeodV_nonPoly ! Non-polymorphic result
d116 1
a116 3
    procedure :: Geoc => GeodV_To_GeocV          ! class(h_geoc) result with
                                                 ! dynamic type(h_v_geoc)
    procedure :: GeocV => GeodV_To_GeocV_nonPoly ! Non-polymorphic result
d128 8
d138 5
d145 16
d171 40
a210 1
  pure type(h_v_geoc) function ECR_To_Geoc ( ECR ) result ( Geoc )
d221 1
a221 1
  pure type(h_v_geod) function ECR_To_Geod_Fukushima ( ECR ) result ( Geod )
d286 1
a286 1
  pure type(ECR_t) function Geoc_To_ECR ( Geoc ) result ( ECR )
d289 1
a289 1
    class(h_v_geoc), intent(in) :: Geoc
d291 3
a293 3
    lat = geoc%lat * deg2rad
    lon = geoc%lon * deg2rad
    rho = geoc%v * cos(lat)
d296 1
a296 1
    ECR%xyz(3) = geoc%v * sin(lat)
d299 1
a299 14
  pure type(ECR_t) function Geoc_To_ECR_Unit ( Geoc ) result ( ECR )
    ! Convert geocentric coordinates to unit ECR coordinates
    use Constants, only: deg2rad
    class(h_geoc), intent(in) :: Geoc
    real(rg) :: Lat, Lon, Rho
    lat = geoc%lat * deg2rad
    lon = geoc%lon * deg2rad
    rho = cos(lat)
    ECR%xyz(1) = rho * cos(lon)
    ECR%xyz(2) = rho * sin(lon)
    ECR%xyz(3) = sin(lat)
  end function Geoc_To_ECR_Unit

  pure function Geoc_To_Geod ( Geoc ) result ( Geod )
d303 1
a303 2
    class(h_geod), allocatable :: Geod ! Result has to be polymorphic and
                                       ! allocatable because overriding one is
a304 1
    allocate ( h_geod :: geod )
d310 9
a318 9
  pure function GeocV_To_GeodV ( Geoc ) result ( Geod )
    class(h_v_geoc), intent(in) :: Geoc
    class(h_geod), allocatable :: Geod
    allocate ( h_v_geod :: geod )
    select type ( geod )
    type is ( h_v_geod ) ! We know this is the only type
      geod = geoc%geodV()
    end select
  end function GeocV_To_GeodV
d320 1
a320 1
  pure type(h_v_geod) function GeocV_To_GeodV_nonPoly ( Geoc ) result ( Geod )
d326 1
a326 1
  end function GeocV_To_GeodV_nonPoly
d328 1
a328 1
  pure type(ECR_t) function Geod_To_ECR ( Geod ) result ( ECR )
d331 1
a331 1
    class(h_v_geod), intent(in) :: Geod
d334 2
a335 2
    call geod_to_geoc_support ( geod, ECR%xyz(3), rho )
    myLon = geod%lon * deg2rad
d340 22
a361 1
  pure type(ECR_t) function Geod_To_ECR_Unit ( Geod ) result ( ECR )
d368 1
a368 1
  pure function Geod_To_Geoc ( Geod ) result ( Geoc )
a371 2
    class(h_geoc), allocatable :: Geoc ! Result has to be polymorphic and
                                       ! allocatable because overriding one is
a372 1
    allocate ( h_geoc :: geoc )
d378 8
a385 10
  pure function GeodV_To_GeocV ( Geod ) result ( Geoc )
    ! Convert geodetic coordinates to Geocentric coordinates, including heights
    class(h_v_geod), intent(in) :: Geod
    class(h_geoc), allocatable :: Geoc
    allocate ( h_v_geoc :: geoc )
    select type ( geoc )
    type is ( h_v_geoc ) ! We know this is the only case
      geoc = geod%geocv()
    end select
  end function GeodV_To_GeocV
d387 1
a387 1
  pure type(h_v_geoc) function GeodV_To_GeocV_NonPoly ( Geod ) result ( Geoc )
d397 19
a415 1
  end function GeodV_To_GeocV_NonPoly
d419 1
a419 1
  pure subroutine Geod_To_Geoc_Support ( Geod, Z, Rho )
d437 12
d453 1
a453 1
       "$Id: Geolocation_0.f90,v 2.3 2015/12/31 00:04:14 vsnyder Exp $"
d463 3
@


2.3
log
@Make V_t and H_V_t nonabstract
@
text
@d19 2
d35 1
a35 1
  end type H_t 
d40 3
d48 2
d93 1
a93 1
  type, extends(h_v_t) :: H_V_Geoc
d96 7
a102 1
  ! real(rg) :: V       ! geocentric height (meters from the Earth center)
d105 1
a105 1
  type, extends(h_v_t) :: H_V_Geod
d108 7
a114 1
  ! real(rg) :: V       ! geodetic height (meters above sea level)
d117 1
a117 1
  type, extends(h_v_t) :: H_V_Zeta
d120 1
a120 1
  ! real(rg) :: V       ! Zeta
d124 4
a127 1
    real(rg) :: XYZ(3)  ! Cartesian ECR, meters
d130 8
d140 208
d352 1
a352 1
       "$Id: Geolocation_0.f90,v 2.2 2015/12/01 21:05:03 vsnyder Exp $"
d362 3
@


2.2
log
@Make H_t non-abstract
@
text
@d61 1
a61 1
  type, abstract :: V_t ! For vertical grids; can't instantiate it
d78 5
a82 4
  ! For irregular grids, where H and V are expected to have the same extents
  type, abstract :: H_V_t
    real(rg) :: Lon     ! Degrees
    real(rg) :: Lat     ! Degrees
d114 1
a114 1
       "$Id: Geolocation_0.f90,v 2.1 2015/11/14 18:02:36 vsnyder Exp $"
d124 3
@


2.1
log
@Initial commit
@
text
@d26 1
a26 1
       "$RCSfile: $"
d30 1
a30 1
  type, abstract :: H_t ! For horizontal (lat/lon) grids; can't instantiate it
d113 1
a113 1
       "$Id: $"
d122 4
a125 1
! $Log: $
@

