head	2.2;
access;
symbols
	v5-02-NRT-19:2.2
	v6-00:2.2
	v5-02-NRT-18:2.2
	v5-02:2.2
	v5-01-NRT-17:2.2
	v5-01-NRT-16:2.2
	v5-01-NRT-15:2.2
	v5-01-NRT-14:2.2
	neuralnetworks-1-0:2.2.0.12
	cfm-single-freq-0-1:2.2.0.10
	v5-01:2.2
	v5-00:2.2
	v4-23-TA133:2.2.0.8
	mus-emls-1-70:2.2.0.6
	rel-1-0-englocks-work:2.2.0.4
	VUMLS1-00:2.2
	VPL1-00:2.2
	V4-22-NRT-08:2.2
	VAM1-00:2.2
	V4-21:2.2.0.2
	V4-13:2.2
	V4-12:2.2
	V4-11:2.2
	V4-10:2.2
	V3-43:2.1
	M4-00:2.2
	V3-41:2.1
	V3-40-PlusGM57:2.1.0.2
	V3-33:2.2
	V3-31:2.2
	V3-30-NRT-05:2.2
	cfm-01-00:2.2
	V3-30:2.1
	V3-20:2.1
	V3-10:2.1;
locks; strict;
comment	@# @;


2.2
date	2010.06.23.20.42.21;	author honghanh;	state Exp;
branches;
next	2.1;

2.1
date	2009.06.16.17.05.27;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.2
log
@Change readAnIntFromChars to only read the first number in the string
if there are many numbers separated by ignored characters.
Update comment of the method.
@
text
@! Copyright 2009, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id: ReadANumFromChars.f9h,v 2.1 2009/06/16 17:05:27 pwagner Exp $
!  subroutine readAnIntFromChars (str, num, forbiddens, ignore)
!    !--------Argument--------!
!    CHARACTER (LEN=*), INTENT(in) ::   str
!    integer, intent(out)          ::   num
    character (len=*), intent(in), optional     ::   forbiddens
    character (len=*), intent(in), optional     ::   ignore

    !----------local vars----------!
    integer :: j, k, status
    logical :: leave_undef
    character(len=40)                           ::   myForbiddens
    character(len=40)                           ::   myIgnore
    character(len=len(str))                     ::   myStr
    !----------Executable part----------!
   status = 0
   ! Check that all is well (if not returns STRINGCONTAINSFORBIDDENS)
   num = STRINGCONTAINSFORBIDDENS
   if ( present(forbiddens) ) then
     myForbiddens = adjustl(forbiddens)
   else
     myForbiddens = ' '
   endif
   if ( present(ignore) ) then
     myignore = adjustl(ignore)
   else
     myignore = ' '
   endif
   leave_undef = (str == ' ')
   if ( myForbiddens /= ' ' ) then
     do j=1, len(trim(myForbiddens))
        leave_undef = leave_undef &
         & .or. &
         & ( &
         &    index(str, myForbiddens(j:j)) > 0 &
         &  .and. &
         &    myForbiddens(j:j) /= ' ' &
         & )
     enddo
   endif
   if ( leave_undef ) then
     return
   elseif (  myIgnore == "" ) then
     read( str, *, iostat=status, err=100 ) num
     if ( status /= 0 ) num = STRINGCONTAINSFORBIDDENS
   elseif (  index(myIgnore, "*") /= 0 ) then
     ! Read the first number, and stop when an ignorable
     ! is found after a digit
     num = 0  ! a str made up entirely of ignorables means "0"
     k = 1
     myStr = ""
     ! First, ignore the first sequence of ignorables
     do j = 1, len(str)
       if ( .not. isAlphabet(str(j:j)) .and. &
         & index(myIgnore, str(j:j)) < 1 ) then
         exit
       endif
     end do 
     ! Collect digits of the first number in the string
     do j = j, len(str)
       if ( .not. isAlphabet(str(j:j)) .and. &
         & index(myIgnore, str(j:j)) < 1 ) then
         myStr(k:k) = str(j:j)
         k = k + 1
       else
         exit
       endif
     enddo
     if ( myStr /= "" ) read( mystr, *, iostat=status, err=100 ) num
   else
     ! Read the first number, and stop when an ignorable
     ! is found after a digit
     num = 0  ! a str made up entirely of ignorables means "0"
     k = 1
     myStr = ""
     ! First, ignore the first sequence of ignorables
     do j = 1, len(str)
       if ( index(myIgnore, str(j:j)) < 1 ) then
         exit
       endif
     end do 
     ! Collect digits of the first number in the string
     do j = 1, len(str)
       if ( index(myIgnore, str(j:j)) < 1 ) then
         myStr(k:k) = str(j:j)
         k = k + 1
       else
         exit
       endif
     enddo
     if ( myStr /= "" ) read( mystr, *, iostat=status, err=100 ) num
   endif
   if ( status /= 0 ) num = STRINGCONTAINSFORBIDDENS
   return
100   num = STRINGCONTAINSFORBIDDENS
!  end subroutine readAnIntFromChars
! $Log: ReadANumFromChars.f9h,v $
! Revision 2.1  2009/06/16 17:05:27  pwagner
! First commit
!
@


2.1
log
@First commit
@
text
@d12 1
a12 1
! $Id: ReadANumFromChars.f9h,v 2.1 2007/10/18 23:36:53 pwagner Exp $
d58 2
d63 1
d67 7
d76 2
d82 2
d87 7
d98 2
d108 4
a111 1
! $Log: dumpTable.f9h,v $
@

