head	1.10;
access;
symbols;
locks; strict;
comment	@# @;


1.10
date	99.12.16.18.30.16;	author livesey;	state dead;
branches;
next	1.9;

1.9
date	99.12.16.01.28.02;	author livesey;	state Exp;
branches;
next	1.8;

1.8
date	99.12.14.00.55.29;	author livesey;	state Exp;
branches;
next	1.7;

1.7
date	99.12.04.00.26.33;	author livesey;	state Exp;
branches;
next	1.6;

1.6
date	99.12.03.22.27.08;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	99.12.03.21.57.34;	author livesey;	state Exp;
branches;
next	1.4;

1.4
date	99.12.01.23.01.41;	author livesey;	state Exp;
branches;
next	1.3;

1.3
date	99.12.01.05.03.56;	author livesey;	state Exp;
branches;
next	1.2;

1.2
date	99.11.30.04.03.51;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	99.11.24.23.06.33;	author livesey;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Renamed to QuantityTemplates
@
text
@! Copyright (c) 1999, California Institute of Technology. ALL RIGHTS RESERVED.
! U.S. Government sponsorship under NASA Contract NAS7407 is acknowledged.

!=============================================================================
MODULE VectorQuantities         ! Quantities within vectors
!=============================================================================

  USE MLSCommon
  USE MLSMessageModule
  USE MLSSignalNomenclature
  USE VGrid

  IMPLICIT NONE
  PUBLIC

  PRIVATE :: Id,ModuleName
  !------------------------------- RCS Ident Info ------------------------------
  CHARACTER(LEN=130) :: id = & 
       "$Id: VectorQuantities.f90,v 1.9 1999/12/16 01:28:02 livesey Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: VectorQuantities.f90,v $"
  !-----------------------------------------------------------------------------

  ! This module defines the `quantities' that make up vectors and their
  ! template information.

  ! First we'll define some global parameters and data types.

  INTEGER, PARAMETER :: QtyNameLen=20

  ! This data type defines a quantity template

  TYPE QuantityTemplate_T

     ! First some administrative stuff

     CHARACTER (LEN=QtyNameLen) :: name ! Simple name for quantity
     INTEGER :: id              ! Id code for quantity (for checking stuff)

     ! Now the dimensions of this quantity

     INTEGER :: noSubVectors    ! Number of subVectors in this quantity
     INTEGER :: noSurfs         ! Number of surfaces per subvector 
     INTEGER :: noChans         ! Number of channels

     ! Now some flags describing the quantity

     LOGICAL :: coherent        ! Do subvectors have same vertical coordiantes?
     LOGICAL :: stacked         ! Are subvectors true vertical profiles?
     LOGICAL :: regular         ! Are all channels/heights represented

     ! Now the vertical coordinate

     INTEGER :: verticalCoordinate ! The vertical coordinate used

     ! Now some misc. information

     REAL(r8) :: badValue ! Value used to flag bad/missing data
     REAL(r8) :: scaleFactor ! Scale factor used when printing etc.

     ! Now, for regular quantities the number of elements each subvector is
     ! simply noSurfs*noChans.  For irregular ones it is less, but it is
     ! constant from subvector to subvector, this is that number

     INTEGER :: subVectorLen

     ! Now we define how the data in each subvector is stored whether by
     ! surface or channels (regular quantities only).

     INTEGER :: surfStride, chanStride

     ! Now we give the vertical coordinates

     REAL(r8), DIMENSION(:,:), POINTER :: surfs

     ! This is dimensioned (noSurfs,1) for regular quantities and (noSurfs
     !,noSubVectors) for irregular ones.

     ! Now the horizontal coordinates

     REAL(r8), DIMENSION(:,:), POINTER :: phi

     ! This is dimensioned (1,noSubVectors) for stacked quantities and (noSurfs
     !,noSubVectors) for unstacked ones.  These other coordinates are
     ! dimensioned in the same manner.

     REAL(r8), DIMENSION(:,:), POINTER :: geodLat,lon,time, &
          & solarTime,solarZenith,losAngle

     ! This integer array can be used to tie subVectors to say l2gp profile
     ! numbers or to MAF indices

     INTEGER, DIMENSION(:), POINTER :: subVectorIndex

     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     ! For quantities containing `channels' the following information may or
     ! may not be useful.

     ! Some quantities are on abritrary freqency grids, these quantities refer
     ! to those.

     INTEGER :: frequencyCoordinate ! An enumerated type, explains next fields

     REAL(r8), DIMENSION(:), POINTER :: frequencies 
     ! List of frequencies (noChans)

     REAL(r8) :: lo     ! Local oscillator (optional)

     ! Other quantities refer to a particular MLS signal designation

     TYPE (MLSSignal_T), DIMENSION(:), POINTER :: signal ! Signal (optional)
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

     ! Now for irregular quantities, instead of using the stride information,
     ! we have these arrays to help us navigate around the quantity.

     INTEGER, DIMENSION(:,:), POINTER :: surfIndex
     INTEGER, DIMENSION(:,:), POINTER :: chanIndex
     ! These are actually dimensioned (subVectorLen,noSubVectors)
  END TYPE QuantityTemplate_T

  ! This incrementing counter is used to set the id field of a quantity template

  INTEGER, PRIVATE :: quantityTemplateCounter=0

  ! --------------------------------------------------------------------------

  CONTAINS

  ! Now we have some subroutines to deal with these quantitites

  ! This first routine sets up a new quantity template according to the user
  ! input.  This may be based on a previously supplied template (with possible
  ! modifications), or created from scratch.

  SUBROUTINE SetupNewQuantityTemplate(qty, source, noSubVectors, noSurfs, &
       & noChans, coherent, stacked, regular, subVectorLen, storeByChannel)

    ! Dummy arguments
    TYPE (QuantityTemplate_T), INTENT(OUT) :: qty ! Result

    TYPE (QuantityTemplate_T), OPTIONAL, INTENT(IN) :: source ! Template
    INTEGER, INTENT(IN), OPTIONAL :: noSubVectors
    INTEGER, INTENT(IN), OPTIONAL :: noSurfs
    INTEGER, INTENT(IN), OPTIONAL :: noChans
    LOGICAL, INTENT(IN), OPTIONAL :: coherent
    LOGICAL, INTENT(IN), OPTIONAL :: stacked
    LOGICAL, INTENT(IN), OPTIONAL :: regular
    INTEGER, INTENT(IN), OPTIONAL :: subVectorLen
    LOGICAL, INTENT(IN), OPTIONAL :: storeByChannel

    ! Local variables
    INTEGER :: status           ! Status from allocates etc.
    LOGICAL :: useStoreByChannel ! Copy of store by channel
    INTEGER :: noSurfsToAllocate ! For allocations
    INTEGER :: noSubVectorsToAllocate ! For allocations

    ! Executable code

    ! First, if we have a template setup according to that
    IF (PRESENT(source)) THEN
       qty%noSubVectors=source%noSubVectors
       qty%noSurfs=source%noSurfs
       qty%noChans=source%noChans
       qty%coherent=source%coherent
       qty%stacked=source%stacked
       qty%regular=source%regular
       qty%subVectorLen=source%subVectorLen
    ELSE ! We have no template, setup a very bare quantity
       qty%noSubVectors=1
       qty%noSurfs=1
       qty%noChans=1
       qty%coherent=.TRUE.
       qty%stacked=.TRUE.
       qty%regular=.TRUE.
       qty%subVectorLen=1
    ENDIF

    ! Now, see if the user asked for modifications to this
    IF (PRESENT(noSubVectors)) qty%noSubVectors=noSubVectors
    IF (PRESENT(noSurfs)) qty%noSurfs=noSurfs
    IF (PRESENT(noChans)) qty%noChans=noChans
    IF (PRESENT(coherent)) qty%coherent=coherent
    IF (PRESENT(stacked)) qty%stacked=stacked
    IF (PRESENT(regular)) qty%regular=regular

    ! Now think about subVectorLen
    IF ((.NOT. qty%regular).AND.(PRESENT(subVectorLen))) THEN
       qty%subVectorLen=subVectorLen
    ELSE
       qty%subVectorLen=qty%noSurfs*qty%noChans
    ENDIF

    ! Deal with the storeByChannel argument
    useStoreByChannel=.FALSE.
    IF (PRESENT(storeByChannel)) useStoreByChannel=storeByChannel

    ! Now think about strides
    IF (qty%regular) THEN
       IF (useStoreByChannel) THEN
          qty%surfStride=qty%noChans
          qty%chanStride=1
       ELSE
          qty%chanStride=qty%noSurfs
          qty%surfStride=1
       ENDIF
    ELSE
       qty%surfStride=0
       qty%chanStride=0
    ENDIF

    ! Now we allocate all the arrays we're going to need

    IF (qty%coherent) THEN 
       noSubVectorsToAllocate=1
    ELSE
       noSubVectorsToAllocate=qty%noSubVectors
    ENDIF

    IF (qty%stacked) THEN
       noSurfsToAllocate=1
    ELSE
       noSurfsToAllocate=qty%noSurfs
    ENDIF

    ! First the vertical coordinates

    ALLOCATE (qty%surfs(qty%noSurfs,noSubVectorsToAllocate),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"surfs")

    ! Now the horizontal coordinates

    ALLOCATE (qty%phi(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"phi")

    ALLOCATE (qty%geodLat(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"geodLat")

    ALLOCATE (qty%lon(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"lon")

    ALLOCATE (qty%time(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"time")

    ALLOCATE (qty%solarTime(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"solarTime")

    ALLOCATE (qty%solarZenith(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"solarZenith")

    ALLOCATE (qty%losAngle(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"losAngle")

    ! Now some other stuff to allocate
    ALLOCATE (qty%subVectorIndex(qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"subVectorIndex")

    IF (.NOT. qty%regular) THEN
       ALLOCATE (qty%surfIndex(qty%subVectorLen,qty%noSubVectors),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"surfIndex")

       ALLOCATE (qty%chanIndex(qty%subVectorLen,qty%noSubVectors),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"chanIndex")
    ENDIF

    ! Se the id field and increment the counter
    qty%id=quantityTemplateCounter
    quantityTemplateCounter=quantityTemplateCounter+1
  END SUBROUTINE SetupNewQuantityTemplate

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a quantity template

  SUBROUTINE DestroyQuantityTemplateContents(qty)

    ! Dummy argument
    TYPE (QuantityTemplate_T), INTENT(INOUT) :: qty

    ! Executable code

    DEALLOCATE (qty%surfs)
    DEALLOCATE (qty%phi)
    DEALLOCATE (qty%geodLat)
    DEALLOCATE (qty%lon)
    DEALLOCATE (qty%time)
    DEALLOCATE (qty%solarTime)
    DEALLOCATE (qty%solarZenith)
    DEALLOCATE (qty%losAngle)
    DEALLOCATE (qty%subVectorIndex)
    
    IF (.NOT. qty%regular) THEN
       DEALLOCATE (qty%surfIndex)
       DEALLOCATE (qty%chanIndex)
    ENDIF

  END SUBROUTINE DestroyQuantityTemplateContents

  ! --------------------------------------------------------------------------

  ! This subroutine adds a quantity template to a database, or creates the
  ! database if it doesn't yet exist

  SUBROUTINE AddQuantityTemplateToDatabase(database,qty)

    ! Dummy arguments
    TYPE (QuantityTemplate_T), DIMENSION(:), POINTER :: database
    TYPE (QuantityTemplate_T), INTENT(IN) :: qty

    ! Local variables
    TYPE (QuantityTemplate_T), DIMENSION(:), POINTER :: tempDatabase
    INTEGER :: newSize,status

    ! Executable code

    IF (ASSOCIATED(database)) THEN
       newSize=SIZE(database)+1
    ELSE
       newSize=1
    ENDIF

    ALLOCATE(tempDatabase(newSize),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Allocation failed for tempDatabase")

    IF (newSize>1) tempDatabase(1:newSize-1)=database
    tempDatabase(newSize)=qty
    DEALLOCATE(database)
    database=>tempDatabase
  END SUBROUTINE AddQuantityTemplateToDatabase

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a quantity template database

  SUBROUTINE DestroyQuantityTemplateDatabase(database)

    ! Dummy argument
    TYPE (QuantityTemplate_T), DIMENSION(:), POINTER :: database

    ! Local variables
    INTEGER :: qtyIndex

    IF (ASSOCIATED(database)) THEN
       DO qtyIndex=1,SIZE(database)
          CALL DestroyQuantityTemplateContents(database(qtyIndex))
       ENDDO
       DEALLOCATE(database)
    ENDIF
  END SUBROUTINE DestroyQuantityTemplateDatabase

  ! --------------------------------------------------------------------------

  ! This subroutine creates a new quantity template from the l2cf information

!   SUBROUTINE CreateQtyTemplateFromMLSCFInfo(qty,cfInfo,&
!        & vGridDatabase,hGridDatabase)
!   END SUBROUTINE CreateQtyTemplateFromMLSCFInfo

!=============================================================================
END MODULE VectorQuantities
!=============================================================================

!
! $Log: VectorQuantities.f90,v $
! Revision 1.9  1999/12/16 01:28:02  livesey
! Routine checkin
!
! Revision 1.8  1999/12/14 00:55:29  livesey
! Changed DOUBLE PRECISION to REAL(r8)
!
! Revision 1.7  1999/12/04 00:26:33  livesey
! Added a few comments.
!
! Revision 1.6  1999/12/03 22:27:08  livesey
! Tidied up some of the INTENT stuff
!
! Revision 1.5  1999/12/03 21:57:34  livesey
! Added the code to set the id field with an incrementing counter
!
! Revision 1.4  1999/12/01 23:01:41  livesey
! Before renaming things to upper/lower case
!
! Revision 1.3  1999/12/01 05:03:56  livesey
! Nightly checkin
!
! Revision 1.2  1999/11/30 04:03:51  livesey
! Bug fix
!
! Revision 1.1  1999/11/24 23:06:33  livesey
! First simple version.
!
!

@


1.9
log
@Routine checkin
@
text
@d19 1
a19 1
       "$Id: VectorQuantities.f90,v 1.8 1999/12/14 00:55:29 livesey Exp $"
d376 3
@


1.8
log
@Changed DOUBLE PRECISION to REAL(r8)
@
text
@d11 1
d19 1
a19 1
       "$Id: VectorQuantities.f90,v 1.7 1999/12/04 00:26:33 livesey Exp $"
d362 8
d376 3
@


1.7
log
@Added a few comments.
@
text
@d8 1
d18 1
a18 1
       "$Id: VectorQuantities.f90,v 1.6 1999/12/03 22:27:08 livesey Exp $"
d56 2
a57 2
     DOUBLE PRECISION :: badValue ! Value used to flag bad/missing data
     DOUBLE PRECISION :: scaleFactor ! Scale factor used when printing etc.
d72 1
a72 1
     DOUBLE PRECISION, DIMENSION(:,:), POINTER :: surfs
d79 1
a79 1
     DOUBLE PRECISION, DIMENSION(:,:), POINTER :: phi
d85 1
a85 1
     DOUBLE PRECISION, DIMENSION(:,:), POINTER :: geodLat,lon,time, &
d102 1
a102 1
     DOUBLE PRECISION, DIMENSION(:), POINTER :: frequencies 
d105 1
a105 1
     DOUBLE PRECISION :: lo     ! Local oscillator (optional)
d367 3
@


1.6
log
@Tidied up some of the INTENT stuff
@
text
@d17 1
a17 1
       "$Id: VectorQuantities.f90,v 1.5 1999/12/03 21:57:34 livesey Exp $"
d119 2
d366 3
@


1.5
log
@Added the code to set the id field with an incrementing counter
@
text
@d17 1
a17 1
       "$Id: VectorQuantities.f90,v 1.4 1999/12/01 23:01:41 livesey Exp $"
d284 1
a284 1
    TYPE (QuantityTemplate_T) :: qty
d314 1
a314 1
    TYPE (QuantityTemplate_T) :: qty
d364 3
@


1.4
log
@Before renaming things to upper/lower case
@
text
@d17 2
a18 2
       "$Id: vectorquantities.f90,v 1.3 1999/12/01 05:03:56 livesey Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile$"
d119 2
d271 4
d363 4
a366 1
! $Log: vectorquantities.f90,v $
@


1.3
log
@Nightly checkin
@
text
@d8 1
d14 1
a14 2
  PRIVATE :: id

d17 2
a18 1
       "$Id: vectorquantities.f90,v 1.2 1999/11/30 04:03:51 livesey Exp $"
a144 4
    ! Local parameters
    CHARACTER (LEN=*), PARAMETER :: AllocateMessage= &
         & "Allocation failed for "

d222 2
a223 1
    IF (status /= 0) CALL MLSMessage(AllocateMessage//"surfs",error=.TRUE.)
d228 2
a229 1
    IF (status /= 0) CALL MLSMessage(AllocateMessage//"phi",error=.TRUE.)
d232 2
a233 1
    IF (status /= 0) CALL MLSMessage(AllocateMessage//"geodLat",error=.TRUE.)
d236 2
a237 1
    IF (status /= 0) CALL MLSMessage(AllocateMessage//"lon",error=.TRUE.)
d240 2
a241 1
    IF (status /= 0) CALL MLSMessage(AllocateMessage//"time",error=.TRUE.)
d244 2
a245 1
    IF (status /= 0) CALL MLSMessage(AllocateMessage//"solarTime",error=.TRUE.)
d248 2
a249 1
    IF (status /= 0) CALL MLSMessage(AllocateMessage//"solarZenith",error=.TRUE.)
d252 2
a253 1
    IF (status /= 0) CALL MLSMessage(AllocateMessage//"losAngle",error=.TRUE.)
d257 2
a258 2
    IF (status /= 0) CALL MLSMessage(AllocateMessage//"subVectorIndex", &
         & error=.TRUE.)
d262 2
a263 2
       IF (status /= 0) CALL MLSMessage(AllocateMessage//"surfIndex", &
         & error=.TRUE.)
d266 2
a267 2
       IF (status /= 0) CALL MLSMessage(AllocateMessage//"chanIndex", &
         & error=.TRUE.)
d323 2
a324 2
    IF (status/=0) CALL MLSMessage("Allocation failed for tempDatabase", &
         & error=.TRUE.)
d358 3
@


1.2
log
@Bug fix
@
text
@d17 1
a17 1
       "$Id: vectorquantities.f90,v 1.1 1999/11/24 23:06:33 livesey Exp $"
d272 1
a272 1
    ! Parameters
d294 53
d353 3
@


1.1
log
@First simple version.
@
text
@d17 1
a17 1
       "$Id: mlssignalnomenclature.f90,v 1.7 1999/11/12 01:05:09 livesey Exp $"
d264 1
a264 1
  END SUBROUTINE CreateNewQuantityTemplate
a285 1
    DEALLOCATE (qty%subVectorLen)
d299 4
a302 1
! $Log$
@

