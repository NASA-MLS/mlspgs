head	1.16;
access;
symbols
	V0_1:1.15;
locks; strict;
comment	@# @;


1.16
date	2000.09.05.17.19.22;	author dcuddy;	state dead;
branches;
next	1.15;

1.15
date	2000.06.30.00.20.03;	author lungu;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.19.22.53.15;	author lungu;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.17.23.19.07;	author lungu;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.16.20.20.38;	author livesey;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.16.19.58.58;	author livesey;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.02.15.58.48;	author livesey;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.20.22.03.13;	author livesey;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.20.01.29.03;	author livesey;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.18.21.34.23;	author livesey;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.18.21.30.57;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.18.00.10.29;	author livesey;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.12.21.44.05;	author livesey;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.11.22.51.34;	author livesey;	state Exp;
branches;
next	1.2;

1.2
date	99.12.18.01.07.00;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	99.12.18.00.35.40;	author livesey;	state Exp;
branches;
next	;


desc
@@


1.16
log
@moved to mlspgs/l2
@
text
@! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

!=============================================================================
MODULE ConstructQuantityTemplates ! Construct templates from user supplied info
!=============================================================================

  USE MLSCommon
  USE MLSMessageModule
  USE QuantityTemplates
  USE MLSCF
  USE VGrid
  USE HGrid
  USE VerticalCoordinate
  USE Units
  USE MLSSignalNomenclature

  IMPLICIT NONE

  PRIVATE :: Id, ModuleName
  !---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
       "$Id: ConstructQuantityTemplates.f90,v 1.15 2000/06/30 00:20:03 lungu Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: ConstructQuantityTemplates.f90,v $"
  !---------------------------------------------------------------------------

  ! This module has various functionality for constructing quantity templates.

CONTAINS
  
  ! First we have some general support routines

  ! --------------------------------------------------------------------------

  ! This routine copies HGrid information into an already defined quantity

  SUBROUTINE CopyHGridInfoIntoQuantity(hGrid,qty)

    ! Dummy arguments
    TYPE (hGrid_T), INTENT(IN) :: hGrid
    TYPE (QuantityTemplate_T), INTENT(INOUT) :: qty

    ! Executable code

    IF (qty%noSubVectors/=hGrid%noProfs) CALL MLSMessage(MLSMSG_Error,&
         & ModuleName,"Size of HGrid not compatible with size of quantity")

    IF (.NOT. qty%stacked) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Cannot copy hGrids into unstacked quantities")

    qty%phi(1,:)=hGrid%phi
    qty%geodLat(1,:)=hGrid%geodLat
    qty%lon(1,:)=hGrid%lon
    qty%time(1,:)=hGrid%time
    qty%solarTime(1,:)=hGrid%solarTime
    qty%solarZenith(1,:)=hGrid%solarZenith
    qty%losAngle(1,:)=hGrid%losAngle
    qty%noSubVectorsLowerOverlap=hGrid%noProfsLowerOverlap
    qty%noSubVectorsUpperOverlap=hGrid%noProfsUpperOverlap

  END SUBROUTINE CopyHGridInfoIntoQuantity
    
  ! --------------------------------------------------------------------------

  ! This similar routine copies VGrid information into an already 
  ! defined quantity

  SUBROUTINE CopyVGridInfoIntoQuantity(vGrid,qty)

    ! Dummy arguments
    TYPE (VGrid_T), INTENT(IN) :: vGrid
    TYPE (QuantityTemplate_T), INTENT(INOUT) :: qty

    ! Executable code

    IF (vGrid%noSurfs/=qty%noSurfs) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & "Size of vGrid not compatible with size of quantity")

    IF (.NOT. qty%coherent) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Cannot copy vGrid information into incoherent quantities")

    qty%verticalCoordinate=vGrid%verticalCoordinate
    qty%surfs(:,1)=vGrid%surfs

  END SUBROUTINE CopyVGridInfoIntoQuantity

  ! --------------------------------------------------------------------------

  ! This routine constructs a minor frame based quantity.

  SUBROUTINE ConstructMinorFrameQuantity(l1bInfo,chunk,instrumentModule,qty,&
       & noChans,regular,subVectorLen,firstIndexChannel,mifGeolocation)

    ! Dummy arguments
    TYPE (L1BInfo_T), INTENT(IN) :: l1bInfo ! File handles for l1bdata
    TYPE (MLSChunk_T), INTENT(IN) :: chunk ! The chunk under consideration
    INTEGER, INTENT(IN) :: instrumentModule ! THz or GHz?
    TYPE (QuantityTemplate_T), INTENT(OUT) :: qty ! Resulting quantity
    INTEGER, INTENT(IN), OPTIONAL :: noChans
    LOGICAL, INTENT(IN), OPTIONAL :: regular
    INTEGER, INTENT(IN), OPTIONAL :: subVectorLen
    LOGICAL, INTENT(IN), OPTIONAL :: firstIndexChannel
    TYPE (QuantityTemplate_T), INTENT(IN), DIMENSION(:), OPTIONAL :: &
         & mifGeolocation

    ! Local parameters, note the similarity to CreateHGridFromMLSCFInfo
    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! IF MODIFYING THIS SECTION PLEASE TAKE CARE, SEE BELOW!
    INTEGER, PARAMETER :: NoL1BItemsToRead=7
    CHARACTER (LEN=15), DIMENSION(NoL1BItemsToRead), &
         &   PARAMETER :: L1bItemsToRead=&
         & (/"MAFStartTimeTAI","tpGeodLat      ","tpLon          ",&
         &   "tpGeodAngle    ","tpSolarZenith  ","tpSolarTime    ",&
         &   "tpLosAngle     "/)
    INTEGER, PARAMETER :: TransitionToModularItems=2
    ! Entries in the above array below TransitionToModularItems are prefixed
    ! with either GHz or THz.  The layout of the above array is critically
    ! bound to the SELECT CASE(l1bItem) code below.  So TAKE CARE! when
    ! modifing it.
    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    ! Local variables

    TYPE (L1BData_T) :: l1bField
    CHARACTER (LEN=NameLen) :: l1bItemName

    INTEGER :: noMAFs,l1bFlag,l1bItem,mafIndex,mifIndex
    CHARACTER (LEN=3),  DIMENSION(MLSInstrumentNoModules) :: &
       & MLSInstrumentModuleNames= (/ &
       & "GHz", &
       & "THz"/)

     MLSInstrumentModuleNames(1) = "GHz"
     MLSInstrumentModuleNames(2) ="THz"
     qty%frequencyCoordinate=FG_None

    ! Executable code. There are basically two cases here. If we have a
    ! MIFGeolocation argument this conveys all the geolocation for this
    ! quantity.  Otherwise, we have to read it all from the l1boa file
    ! ourselves.

    IF (PRESENT(mifGeolocation)) THEN

       ! We have geolocation information, setup the quantity as a clone of that.

       CALL SetupNewQuantityTemplate(qty,&
            & source=mifGeolocation(instrumentModule), &
            & noChans=noChans, regular=regular,subVectorLen=subVectorLen,&
            & firstIndexChannel=firstIndexChannel)

       ! Now we're going to deal with a VGrid for this quantity

       qty%verticalCoordinate=VC_Altitude
       qty%surfs=>mifGeolocation(instrumentModule)%surfs

       ! Now we're going to fill in the hGrid information

       qty%time=>       MIFGeolocation(instrumentModule)%time
       qty%geodLat=>    MIFGeolocation(instrumentModule)%geodLat
       qty%lon=>        MIFGeolocation(instrumentModule)%lon
       qty%phi=>        MIFGeolocation(instrumentModule)%phi
       qty%solarZenith=>MIFGeolocation(instrumentModule)%solarZenith
       qty%solarTime=>  MIFGeolocation(instrumentModule)%solarTime
       qty%losAngle=>   MIFGeolocation(instrumentModule)%losAngle
       qty%MAFCounter=> MIFGeolocation(instrumentModule)%mafCounter
       qty%mafIndex=>   MIFGeolocation(instrumentModule)%mafIndex
       qty%noSubVectorsLowerOverlap= &
            & MIFGeolocation(instrumentModule)%noSubVectorsLowerOverlap
       qty%noSubVectorsUpperOverlap= &
            & MIFGeolocation(instrumentModule)%noSubVectorsUpperOverlap
    ELSE
       ! We have no geolocation information, we have to read it ourselves
       ! from the l1boa file.

       ! First we read tpGeodalt to get the size of the quantity.

       l1bItemName=TRIM(MLSInstrumentModuleNames(instrumentModule))//"."//"tpGeodAlt"
       CALL ReadL1BData(l1bInfo%l1boaid,l1bItemName,l1bField,noMAFs,l1bFlag, &
            & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex)
       IF (l1bFlag==-1) CALL MLSMessage(MLSMSG_Error,ModuleName,&
            & MLSMSG_L1BRead//l1bItemName)

       ! Now noMAFs qty%noSubVectors, l1bField%maxMIFs is no surfs.

       CALL SetupNewQuantityTemplate(qty,noSubVectors=noMAFs, &
            & noSurfs=l1bField%maxMIFs, noChans=noChans, coherent=.FALSE.,&
            & stacked=.FALSE.,regular=regular,subVectorLen=subVectorLen,&
            & firstIndexChannel=firstIndexChannel,minorFrame=.TRUE.)

       qty%noSubVectorsLowerOverlap=chunk%noMAFsLowerOverlap
       qty%noSubVectorsUpperOverlap=chunk%noMAFsUpperOverlap

       ! Now we're going to deal with a VGrid for this quantity

       qty%verticalCoordinate=VC_Altitude
       qty%surfs=l1bField%dpField(1,:,:)  ! Vert coord is tpGeodAlt read above.
       qty%mafCounter=l1bField%counterMAF
       DO mafIndex=chunk%firstMAFIndex,chunk%lastMAFIndex
          qty%mafIndex(mafIndex-chunk%firstMAFIndex+1)=mafIndex
       END DO

       ! Now we're going to fill in the hGrid information

       DO l1bItem=1,NoL1BItemsToRead
          ! Get the name of the item to read
          l1bItemName=l1bItemsToRead(l1bItem)
          IF (l1bItem>=TransitionToModularItems) l1bItemName=&
               & MLSInstrumentModuleNames(instrumentModule)//'.'//l1bItemName

          ! Read it from the l1boa file
          CALL ReadL1BData(l1bInfo%l1boaid,l1bItemName,l1bField,noMAFs, &
               & l1bFlag,firstMAF=chunk%firstMafIndex,&
               & lastMAF=chunk%lastMafIndex)
          IF (l1bFlag==-1) CALL MLSMessage(MLSMSG_Error,ModuleName,&
               & MLSMSG_L1BRead//l1bItemName)

          ! Now we have to save this field in the quantity data.
          ! This is rather a
          ! kludgy way of doing it but this worked out the least boring way to
          ! write the code.  See the definition of L1BItemsToRead above for
          ! reference.

          SELECT CASE(l1bItem)
          CASE(1)
             ! For time we have to do something a little more complicated.
             ! ******* This is a real kludge, and we have to find a way
             ! to do it better in 0.5. Probably simply have time as a minor
             ! frame quantity in L1, or MIF duration.
             !
             DO mafIndex=1,noMAFs
                DO mifIndex=1,l1bField%maxMIFs
                   qty%time(mifIndex,mafIndex)=&
                        & l1bField%dpField(1,1,mafIndex)+&
                        & (mifIndex-1)*0.166666666666667D0
                END DO
             END DO
          CASE(2)
             qty%geodLat=l1bField%dpField(1,:,:)
          CASE(3)
             qty%lon=l1bField%dpField(1,:,:)
          CASE(4)
             qty%phi=l1bField%dpField(1,:,:)
          CASE(5)
             qty%solarZenith=l1bField%dpField(1,:,:)
          CASE(6)
             qty%solarTime=l1bField%dpField(1,:,:)
          CASE(7)
             qty%losAngle=l1bField%dpField(1,:,:)
          END SELECT
       END DO                      ! Loop over l1b quantities
    ENDIF
    qty%name=MLSInstrumentModuleNames(InstrumentModule)
    ! In later versions we'll probably need to think about FILL_VALUEs and
    ! setting things to the badData flag.

  END SUBROUTINE ConstructMinorFrameQuantity

  ! --------------------------------------------------------------------------

  ! This routine constructs a vector quantity template based on instructions
  ! passed in an mlscf line.
  
  SUBROUTINE CreateQtyTemplateFromMLSCFInfo(qty,cfInfo,hGrids,vGrids, &
       & l1bInfo,chunk,mifGeolocation)

    ! Dummy arguments
    TYPE (QuantityTemplate_T), INTENT(OUT) :: qty
    TYPE (MLSCFEntry_T), INTENT(IN) :: cfInfo
    TYPE (HGrid_T), DIMENSION(:), INTENT(IN) :: hGrids
    TYPE (VGrid_T), DIMENSION(:), INTENT(IN) :: vGrids
    TYPE (l1bInfo_T), INTENT(IN) :: l1bInfo
    TYPE (MLSChunk_T), INTENT(IN) :: chunk
    TYPE (QuantityTemplate_T), DIMENSION(:), INTENT(IN), OPTIONAL :: &
         & mifGeolocation

    ! Local parameters
    CHARACTER (LEN=*), PARAMETER :: BadUnitMessage = &
         & "Unexpected or absent unit for "

    ! Local variables

    INTEGER :: quantityType=QTY_Invalid
    CHARACTER (LEN=NameLen) :: name
    INTEGER :: family=PHYQ_Invalid
    REAL(r8) :: scaleFactor
    INTEGER :: hGridIndex=0,vGridIndex=0
    CHARACTER (LEN=NameLen) :: molecule="",radiometer="", band=""
    TYPE (MLSCFCell_T) :: cell
    INTEGER :: keyNo            ! Loop counter
    LOGICAL :: needVHGrids, badUnit
    TYPE(MLSSignal_T), DIMENSION(:), POINTER :: signals => null()
    INTEGER :: instrumentModule
    INTEGER :: noChans=1
    LOGICAL :: firstIndexChannel=.FALSE.

    ! Executable code

    ! First we'll loop over the mlscf keys and parse them.
    
    hGridIndex=0
    vGridIndex=0  
    DO keyNo=1,cfInfo%mlscfEntryNoKeys
  
       cell=cfInfo%cells(keyNo)
       SELECT CASE(TRIM(cell%keyword))
       CASE ("NAME")
          name=cell%charValue
       CASE ("HGRID")
          hGridIndex=LinearSearchStringArray(hGrids%name,cell%charValue,&
               & caseInsensitive=.TRUE.)
          IF (hGridIndex==0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
               & "Unknown hGrid: "//cell%charValue)
       CASE ("VGRID")
          vGridIndex=LinearSearchStringArray(vGrids%name,cell%charValue,&
               & caseInsensitive=.TRUE.)
          IF (vGridIndex==0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
               & "Unknown vGrid: "//cell%charValue)
       CASE ("TYPE")
          quantityType=LinearSearchStringArray(QTYTypeNames,cell%charValue,&
               & caseInsensitive=.TRUE.)
          IF (quantityType==QTY_Invalid) &
               & CALL MLSMessage(MLSMSG_Error,ModuleName,&
               &   "No such quantity type: "//cell%charValue)
       CASE ("UNIT")
          CALL ParseUnitName(cell%charValue,family,scaleFactor)
          IF (family==PHYQ_Invalid) CALL MLSMessage(MLSMSG_Error,ModuleName,&
               & "Unrecognised unit: "//cell%charValue)
       CASE("MOLECULE")
          molecule=cell%charValue
       CASE("RADIOMETER")
          radiometer=cell%charValue
       CASE("BAND")
          band=cell%charValue
       CASE("FIRSTINDEXCHANNEL")
          firstIndexChannel=(cell%intValue==1)
       END SELECT
    END DO

    ! Now we know what the user asked for, try to make sense of it.
    ! First see that the `type' has been defined

    IF (LEN_TRIM(name) == 0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & "No name given for quantity template")
    IF (quantityType==QTY_Invalid) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & "No type specified for "//name)

    ! Now, depending on the type, check out stuff and see if's ok to first
    ! order.

    badUnit=.FALSE.
    SELECT CASE(quantityType)
    CASE(QTY_Temperature)
       needVHGrids=.TRUE.
       IF (family/=PHYQ_Temperature) badUnit=.TRUE.
    CASE(QTY_Vmr)
       needVHGrids=.TRUE.
       IF (family/=PHYQ_vmr) badUnit=.TRUE.
    CASE(QTY_Radiance)
       needVHGrids=.FALSE.
       IF (family/=PHYQ_Temperature) badUnit=.TRUE.
    CASE(QTY_Ptan)
       IF (family/=PHYQ_Zeta ) badUnit=.TRUE.
       needVHGrids=.FALSE.
    CASE(QTY_Baseline)
       IF (family/=PHYQ_Temperature) badUnit=.TRUE.
       needVHGrids=.FALSE.
    CASE(QTY_Extinction)
       ! Need to think about a family here
       needVHGrids=.TRUE.
    CASE(QTY_Gph)
      ! Need to think about a family here
       needVHGrids=.TRUE.
    CASE DEFAULT
       CALL MLSMessage(MLSMSG_Error,ModuleName,"Unknown quantityType")
    END SELECT
    IF (badUnit) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & "Incorrect/absent unit for "//name)

    ! Here the code diverges.  In the case where vGrids and hGrids are required
    ! we set them up.  Where they're not we assume it's a minor frame quantity
    ! and work from there.

    IF (needVHGrids) THEN
       ! This is not a minor frame quantity, set it up from VGrids and HGrids
       IF ((hGridIndex==0).OR.(vGridIndex==0)) CALL MLSMessage(MLSMSG_Error,&
            & ModuleName, "Quantity "//TRIM(name)//&
            & " needs a vGrid and/or an hGrid")

       CALL SetupNewQuantityTemplate(qty, &
            & noSubVectors=hGrids(hGridIndex)%noProfs, &
            & noSurfs=vGrids(vGridIndex)%noSurfs, &
            & coherent=.TRUE.,stacked=.TRUE.,regular=.TRUE.)
       ! Note in later versions we'll need to think about channels here
       CALL CopyHGridInfoIntoQuantity(hGrids(hGridIndex),qty)
       CALL CopyVGridInfoIntoQuantity(vGrids(vGridIndex),qty)

    ELSE
       ! This is a minor frame type quantity.
       IF ((hGridIndex/=0).OR.(vGridIndex/=0)) CALL MLSMessage(MLSMSG_Error,&
            & ModuleName, "Quantity "//TRIM(name)//&
            & " has an unnecessary vGrid and/or hGrid")

       SELECT CASE(quantityType)
       CASE(QTY_Ptan)
          CALL ParseMLSSignalRequest(radiometer,signals)
          instrumentModule = signals(1)%instrumentModule
          CALL DestroyMLSSignalsInfo(signals)

       CASE (QTY_Radiance)
          CALL ParseMLSSignalRequest(band,signals)
          IF (SIZE(signals)>1) CALL MLSMessage(MLSMSG_Error,ModuleName,&
               & "Only one matching signal allowed: "//band)
          noChans=signals(1)%noChannelsInBand
       CASE DEFAULT
          CALL MLSMessage(MLSMSG_Error,ModuleName, &
               & "Inappropriate quantity for this version")
       END SELECT
       
       ! Construct an empty quantity
       CALL ConstructMinorFrameQuantity(l1bInfo,chunk,instrumentModule,qty, &
            & noChans=noChans,firstIndexChannel=firstIndexChannel, &
            & mifGeolocation=mifGeolocation)

       ! Fill what information we can

       IF (quantityType==QTY_Radiance) THEN
          qty%signal=signals(1)
          CALL DestroyMLSSignalsInfo(signals)
       END IF

    ENDIF

    ! Now fill up the remaining items, e.g. name etc.

    qty%name=name
    qty%quantityType=quantityType
    qty%scaleFactor=scaleFactor
    ! Add a unit name field here probably.

  END SUBROUTINE CreateQtyTemplateFromMLSCFInfo

!=============================================================================
END MODULE ConstructQuantityTemplates
!=============================================================================

!
! $Log: ConstructQuantityTemplates.f90,v $
! Revision 1.15  2000/06/30 00:20:03  lungu
! Initialized signals => null().
!
! Revision 1.14  2000/06/19 22:53:15  lungu
! Fixed the weird qty%name=MLSInstrumentModuleNames(InstrumentModule) problem.
!
! Revision 1.13  2000/05/17 23:19:07  lungu
! Added "." between MLSInstrumentModuleNames and l1bItemName.
! Made hGridIndex=0 and vGridIndex=0 upon entry, so it does not "inherit" attributes from previous call.
! Made caseInsensitive=.TRUE. for all searches.
! Added type for QTY_Gph.
! Made stacked=.TRUE. so that CopyHGridInfoIntoQuantity works.
!
! Revision 1.12  2000/05/16 20:20:38  livesey
! Another attempt to fix the `time' problem.
!
! Revision 1.11  2000/05/16 19:58:58  livesey
! Added stuff to deal with `time' correctly.
!
! Revision 1.10  2000/05/02 15:58:48  livesey
! Fixed a typo
!
! Revision 1.9  2000/01/20 22:03:13  livesey
! Dealt with replacement of subVectorIndex with mafCounter and mafIndex
!
! Revision 1.8  2000/01/20 01:29:03  livesey
! Replaced storeByChannel with firstIndexChannel, removed stride stuff.
!
! Revision 1.7  2000/01/18 21:34:23  livesey
! Removed reference to obsolete hGrid%profileIndices.
! Other typo fixes.
!
! Revision 1.6  2000/01/18 21:30:57  livesey
! Made sure that noSubVectors(Upper/Lower)Overlap are filled
! appropriately.  This is done right for l2gp and minor frame
! quantities.  More complex quantities may need more thought later.
!
! Revision 1.5  2000/01/18 00:10:29  livesey
! Interim version transfered home.  Need to think more about subVectorIndex
! as it applies to l2aux quantities, and is not used in l2gp.
!
! Revision 1.4  2000/01/12 21:44:05  livesey
! Modified to include the handling of the minorFrame flag.
!
! Revision 1.3  2000/01/11 22:51:34  livesey
! Dealt with ramifications of change from read_parse_l2cf to MLSCF
!
! Revision 1.2  1999/12/18 01:07:00  livesey
! Change vGrids and hGrids from pointer to intent(in)
!
! Revision 1.1  1999/12/18 00:35:40  livesey
! First version
!
!
@


1.15
log
@Initialized signals => null().
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.14 2000/06/19 22:53:15 lungu Exp $"
d448 3
@


1.14
log
@Fixed the weird qty%name=MLSInstrumentModuleNames(InstrumentModule) problem.
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.13 2000/05/17 23:19:07 lungu Exp $"
d128 4
d291 1
a291 1
    TYPE(MLSSignal_T), DIMENSION(:), POINTER :: signals
a304 1

a375 1

d406 1
a406 1
          instrumentModule=signals(1)%instrumentModule
d448 3
@


1.13
log
@Added "." between MLSInstrumentModuleNames and l1bItemName.
Made hGridIndex=0 and vGridIndex=0 upon entry, so it does not "inherit" attributes from previous call.
Made caseInsensitive=.TRUE. for all searches.
Added type for QTY_Gph.
Made stacked=.TRUE. so that CopyHGridInfoIntoQuantity works.
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.12 2000/05/16 20:20:38 livesey Exp $"
d131 1
a131 1

d248 1
a248 1

a391 1
      
d406 1
a417 1

d446 7
@


1.12
log
@Another attempt to fix the `time' problem.
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.11 2000/05/16 19:58:58 livesey Exp $"
d129 4
d173 1
a173 1
       l1bItemName=TRIM(MLSInstrumentModuleNames(instrumentModule))//"tpGeodAlt"
d204 1
a204 1
               & MLSInstrumentModuleNames(instrumentModule)//l1bItemName
d295 3
a297 1

d299 1
d301 1
d307 1
a307 1
               & caseInsensitive=.FALSE.)
d312 1
a312 1
               & caseInsensitive=.FALSE.)
d317 1
a317 1
               & caseInsensitive=.FALSE.)
d359 1
a359 1
       IF (family/=PHYQ_Zeta) badUnit=.TRUE.
d367 3
d390 1
a390 1
            & coherent=.TRUE.,stacked=.FALSE.,regular=.TRUE.)
d392 1
a392 1

d447 3
@


1.11
log
@Added stuff to deal with `time' correctly.
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.10 2000/05/02 15:58:48 livesey Exp $"
a86 37
  ! -------------------------------------------------------------------------

  ! This function populates an array with the MIF times for each MIF in a MAF
  ! given an array of MAF start times.
  
  SUBROUTINE GetMIFTimesFromMAFTimes(mafStartTimeTAI,mifTimeTAI)  

    ! Dummy arguments
    REAL(r8), DIMENSION(:), INTENT(IN) :: mafStartTimeTAI ! (MAF)
    REAL(r8), DIMENSION(:,:), INTENT(OUT) :: mifTimeTAI   ! (MIF,MAF)

    ! Parameters
    REAL(r8), PARAMETER :: mifDuration=0.166666666666666666666666666666667
    ! This is a real kludge. In later versions we'll need some way in the L1
    ! file to denote the length of a MIF

    ! Local variables
    INTEGER :: noMAFs,noMIFs
    INTEGER :: mif,maf          ! Loop counters

    ! Executable code

    noMAFs=SIZE(mifTimeTAI,2)
    noMIFs=SIZE(mifTimeTAI,1)
    
    IF (SIZE(mafStartTimeTAI) /= noMAFs) CALL MLSMessage(&
         & MLSMSG_Error,ModuleName,&
         & "Argument mismatch in GetMIFTimesFrom MAFTimes")

    DO maf=1,noMAFs
       DO mif=1,noMIFs
          mifTimeTAI(mif,maf)=mafStartTimeTAI(maf)+(mif-1)*mifDuration
       END DO
    END DO

  END SUBROUTINE GetMIFTimesFromMAFTimes

d127 1
a127 1
    INTEGER :: noMAFs,l1bFlag,l1bItem,mafIndex
d217 12
a228 2
             CALL GetMIFStartTimesFromMAFTimes(l1bField%dpField(1,:,:),&
                  & qty%time)
d436 3
@


1.10
log
@Fixed a typo
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.9 2000/01/20 22:03:13 livesey Exp $"
d87 37
d149 1
a149 1
         & (/"time           ","tpGeodLat      ","tpLon          ",&
d254 2
a255 1
             qty%time=l1bField%dpField(1,:,:)
d463 3
@


1.9
log
@Dealt with replacement of subVectorIndex with mafCounter and mafIndex
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.8 2000/01/20 01:29:03 livesey Exp $"
d309 1
a309 1
          molecule=cell%charValue
d425 3
@


1.8
log
@Replaced storeByChannel with firstIndexChannel, removed stride stuff.
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.7 2000/01/18 21:34:23 livesey Exp $"
a57 1
    qty%subVectorIndex=0
d157 2
a158 1
       qty%subVectorIndex=> MIFGeolocation(instrumentModule)%subVectorIndex
d189 1
d191 1
a191 1
          qty%subVectorIndex(mafIndex-chunk%firstMAFIndex+1)=mafIndex
d425 3
@


1.7
log
@Removed reference to obsolete hGrid%profileIndices.
Other typo fixes.
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.6 2000/01/18 21:30:57 livesey Exp $"
d93 1
a93 1
       & noChans,regular,subVectorLen,storeByChannel,mifGeolocation)
d103 1
a103 1
    LOGICAL, INTENT(IN), OPTIONAL :: storeByChannel
d142 1
a142 1
            & storeByChannel=storeByChannel)
d180 1
a180 1
            & storeByChannel=storeByChannel,minorFrame=.TRUE.)
d274 1
a274 1
    LOGICAL :: storeByChannel=.FALSE.
d311 2
a312 2
       CASE("STOREBYCHANNEL")
          storeByChannel=(cell%intValue==1)
d397 1
a397 1
            & noChans=noChans,storeByChannel=storeByChannel, &
d424 4
@


1.6
log
@Made sure that noSubVectors(Upper/Lower)Overlap are filled
appropriately.  This is done right for l2gp and minor frame
quantities.  More complex quantities may need more thought later.
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.5 2000/01/18 00:10:29 livesey Exp $"
d58 1
a58 1
    qty%subVectorIndex=hGrid%profileIndices
d159 1
a159 1
       qty%noSubVectorsLowerOverlap=> &
d161 1
a161 1
       qty%noSubVectorsUpperOverlap=> &
d424 5
@


1.5
log
@Interim version transfered home.  Need to think more about subVectorIndex
as it applies to l2aux quantities, and is not used in l2gp.
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.4 2000/01/12 21:44:05 livesey Exp $"
d59 2
d159 4
d182 3
d424 4
@


1.4
log
@Modified to include the handling of the minorFrame flag.
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.3 2000/01/11 22:51:34 livesey Exp $"
d58 1
d126 1
a126 1
    INTEGER :: noMAFs,l1bFlag,l1bItem
d156 1
d180 3
d415 3
@


1.3
log
@Dealt with ramifications of change from read_parse_l2cf to MLSCF
@
text
@d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.2 1999/12/18 01:07:00 livesey Exp $"
d172 1
a172 1
            & storeByChannel=storeByChannel)
d230 1
a230 1
       & l1bInfo,chunk,mlsSignalsDatabase,mifGeolocation)
a238 1
    TYPE (MLSSignalsDatabase_T), INTENT(IN) :: mlsSignalsDatabase
d367 1
a367 1
          CALL ParseMLSSignalRequest(radiometer,mlsSignalsDatabase,signals)
d371 1
a371 1
          CALL ParseMLSSignalRequest(band,mlsSignalsDatabase,signals)
d410 3
@


1.2
log
@Change vGrids and hGrids from pointer to intent(in)
@
text
@d5 1
a5 1
MODULE ConstructQuantityTemplates ! Construct templates from l2cf info
d11 1
a11 1
  USE Temporary_Types
d23 1
a23 1
       "$Id: ConstructQuantityTemplates.f90,v 1.1 1999/12/18 00:35:40 livesey Exp $"
d227 1
a227 1
  ! passed in an l2cf line.
d230 1
a230 1
       & l1bInfo,chunk,mlsSignalsDatabase)
d234 1
a234 1
    TYPE (L2CFEntry), INTENT(IN) :: cfInfo
d240 2
d255 1
a255 1
    TYPE (L2CFCell) :: cell
d265 1
a265 1
    ! First we'll loop over the l2cf keys and parse them.
d267 1
a267 1
    DO keyNo=1,cfInfo%l2cfEntryNoKeys
d383 3
a385 2
       CALL ConstructMinorFrameQuantity(l1bInfo,chunk,instrumentModule,qty,&
            & noChans=noChans,storeByChannel=storeByChannel)
d411 3
@


1.1
log
@First version
@
text
@d23 2
a24 2
       "$Id: $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile$"
d101 2
a102 1
    TYPE (QuantityTemplate_T), INTENT(IN), DIMENSION(:) :: mifGeolocation
d144 1
a144 1
       qty%surfs=l1bField=>mifGeolocation(instrumentModule)%surfs
d235 2
a236 2
    TYPE (HGrid_T), DIMENSION(:), POINTER :: hGrids
    TYPE (VGrid_T), DIMENSION(:), POINTER :: vGrids
d407 4
a410 1
! $Log$
@

