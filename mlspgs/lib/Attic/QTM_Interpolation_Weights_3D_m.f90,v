head	2.15;
access;
symbols
	mus-emls-1-70:2.14.0.2
	rel-1-0-englocks-work:2.13.0.2
	VUMLS1-00:2.12
	VPL1-00:2.5
	V4-22-NRT-08:2.5;
locks; strict;
comment	@# @;


2.15
date	2018.08.20.23.39.07;	author vsnyder;	state dead;
branches;
next	2.14;

2.14
date	2018.05.14.23.25.29;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2017.08.28.20.27.47;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2016.11.23.00.11.21;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2016.11.12.01.37.02;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2016.11.02.22.55.53;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2016.10.25.18.23.48;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2016.10.18.00.44.28;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2016.10.05.23.28.22;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2016.09.14.20.46.21;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2016.04.28.23.09.50;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2016.04.16.02.04.06;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2016.03.30.01.42.02;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2016.01.26.02.30.32;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2015.12.31.00.56.47;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.15
log
@No longer used
@
text
@! Copyright 2015, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module QTM_Interpolation_Weights_3D_m
!=============================================================================

  use Geolocation_0, only: RG, S_t
  use QTM_Interpolation_Weights_m, only: QTM_Interpolation_Weights, &
    & Value_QTM_1D_List_t, Value_QTM_2D_List_t, Value_QTM_2D_t
  use Weight_1D_m, only: Weight_1D

  implicit NONE
  private

  ! Use QTM_Interpolation_Weights to get weights in 2D, and linear
  ! interpolation to get weights in 3D.  It is assumed that the 3D
  ! grid is stacked and coherent.

  ! Type that represents a path through a QTM, with horizontal interpolation
  ! coefficients.
  type, extends(S_t), public :: S_QTM_t ! Descriptors of points along a line
                     ! through a stacked but not necessarily coherent 3D grid
                     ! built atop a QTM surface grid.  The grid consists of
                     ! triangular prisms resting upon the QTM.  The horizontal
                     ! boundaries of the prisms are spherical caps.  One
                     ! vertical face is a latitude cone; the other two are
                     ! planes.
  ! real(rg) :: S    ! Distance along Line(1) in the direction of Line(2);
                     ! Inherited from parent type.
!     type(value_QTM_1D_List_t(rg)) :: Coeff = value_QTM_1D_List_t(rg)()
    type(value_QTM_1D_List_t) :: Coeff = value_QTM_1D_List_t()
                     ! Horizontal interpolation coefficients, along with the
                     ! indices of the QTM, or an extract of it adjacent to
                     ! the path, to which the coefficients apply.  This is just
                     ! a temp used by Metrics_3D to store up to three
                     ! coefficients per path point.
    integer :: Face  ! Cone_Face => latitude cone face, bounded horizontally
                     !      by two non-polar vertices of facet QID.
                     ! X_face => vertical face bounded horizontally by the
                     !      polar vertex and the X-node vertex of facet QID.
                     ! Y_face => vertical face bounded horizontally by the
                     !      polar vertex and the Y-node vertex of facet QID.
                     ! Top_Face => horizontal face of facet QID at height
                     !      indexed by H.
                     ! Inside_Prism => The intersection is inside a prism
                     !      resting on the surface QTM instead of with one
                     !      of its faces.
                     ! If the point is outside the QTM, this will be the
                     ! negative of one of the above values, other than
                     ! Inside_Prism; it will be whatever face the extrapolated
                     ! line intersects.  The coordinates indexed by Coeff%v%n
                     ! are those where the line intersects the QTM, not where
                     ! it intersects a surface of a height equal to one of the
                     ! heights in the intersection of all heights in the state
                     ! vector.  The H component probably isn't useful.
    integer :: Facet = 0 ! Index in Grid%QTM_Tree of QTM facet intersected at
                     ! the point.
    real(rg) :: H    ! Height at which the point intersects a face.  This is
                     ! the height where the extrapolated line intersects a face
                     ! of the QTM for points outside the QTM.
    integer :: H_ind = 0 ! Index in height grid.  If |Face| /= Top_Face, H_Ind
                     ! is the index of the next lower height surface.  If
                     ! |Face| == Top_Face but the point is below the first
                     ! element of the height grid, H_ind is zero.  This could
                     ! happen if the ray is an Earth-reflecting ray and the
                     ! minimum height in the height-reference array is above
                     ! the Earth surface.
  end type S_QTM_t

  integer, parameter, public :: Cone_Face = 1
  integer, parameter, public :: X_face = cone_face + 1
  integer, parameter, public :: Y_face = x_face + 1
  integer, parameter, public :: Top_Face = y_face + 1
  integer, parameter, public :: Inside_Prism = top_face + 1

  public :: QTM_Interpolation_Weights

  interface QTM_Interpolation_Weights
    module procedure &
      & QTM_Interpolation_Weights_Geo_3D, &
      & QTM_Interpolation_Weights_Geo_3D_Incoherent, &
      & QTM_Interpolation_Weights_Geo_3D_Incoherent_Line, &
      & QTM_Interpolation_Weights_Geo_3D_Incoherent_List, &
      & QTM_Interpolation_Weights_Geo_3D_Line, &
      & QTM_Interpolation_Weights_Geo_3D_List
  end interface QTM_Interpolation_Weights

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: QTM_Interpolation_Weights_3D_m.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

contains

  subroutine QTM_Interpolation_Weights_Geo_3D ( QTM_Tree, Heights, Point, &
                                              & Weights, Facet, Stack, Used )

    ! Construct interpolation weights and positions for a point in a 3D grid
    ! for which the horizontal grid is QTM.  The 3D grid is assumed to be
    ! stacked and coherent.  Weights%N are QTM vertex serial numbers.

    use Generate_QTM_m, only: QTM_Tree_t
    use Geolocation_0, only: H_t, H_V_t !, RG
    use Hunt_m, only: Hunt
    use QTM_m, only: Stack_t

    type(QTM_tree_t), intent(in) :: QTM_Tree
    real(rg), intent(in) :: Heights(:)   ! Assume Heights (meters, zeta) are
    class(h_v_t), intent(in) :: Point    !   the same units as for Point%V
!     type(value_QTM_2D_list_t(rg)), intent(out) :: Weights
    type(value_QTM_2D_list_t), intent(out) :: Weights
    integer, intent(in), optional :: Facet
    type(stack_t), intent(inout), optional :: Stack
    class(h_t), intent(out), optional :: Used ! Horizontal coordinates of the
                                         !   point used for interpolation

    real(rg) :: dH       ! Difference in Heights coordinates
    integer :: Index, J
    real(rg) :: W        ! Weight in the vertical direction for the lower level

    ! Get horizontal interpolation coefficients and serial numbers
    call QTM_Interpolation_Weights ( QTM_Tree, Point, Weights, Facet, &
      & Stack, Used )

    ! Get vertical interpolation coefficients
    call hunt ( heights, point%v, index, &
              & allowTopValue=.true., allowBelowValue = .true. )

    ! Combine horizontal and vertical interpolation coefficients
    if ( index == 0 ) then
      weights%v(4:6)%j = 0 ! Constant vertical extrapolation below Heights(:)
    else if ( index >= size(heights) ) then
      do j = 1, 3
        weights%v(j)%jz = size(heights)
      end do
      weights%v(4:6)%j = 0 ! Constant vertical extrapolation above Heights(:)
    else
      dH = heights(index+1) - heights(index)
      if ( dH == 0 ) then ! shouldn't happen if Heights(:) are distinct
        weights%v(4:6)%j = 0 ! Don't use points other than at Height Index
      else
        w = ( heights(index+1) - point%v ) / dh
        if ( w == 1.0_rg ) then
          do j = 1, 3
            weights%v(j)%jz = index
          end do
          weights%v(4:6)%j = 0 ! Don't use points other than at Height Index
        else if ( w == 0.0_rg ) then
          do j = 1, 3
            weights%v(j)%jz = index + 1
          end do
          weights%v(4:6)%j = 0 ! Don't use points other than at Height Index + 1
        else
          weights%v(4:6)%v = weights%v(1:3)%v * ( 1.0_rg - w )
          weights%v(1:3)%v = weights%v(1:3)%v * w
          do j = 1, 3
            weights%v(j+3)%jz = index + 1
            weights%v(j)%jz = index
          end do
        end if
      end if
    end if

    where ( weights%v%v == 0 ) weights%v%j = 0
    weights%n = count ( weights%v%j /= 0 ) 
    weights%v = pack ( weights%v,weights%v%j /= 0 )
!     weights%v(weights%n+1:) = value_QTM_2D_t(rg)(0,0,0,0)
    weights%v(weights%n+1:) = value_QTM_2D_t(0,0,0,0)

  end subroutine QTM_Interpolation_Weights_Geo_3D

  subroutine QTM_Interpolation_Weights_Geo_3D_Incoherent ( QTM_Tree, Heights, &
                                     & Point, Weights, Facet, Stack, Used )

    ! Construct interpolation weights and positions for a point in a 3D grid
    ! for which the horizontal grid is QTM.  The 3D grid is assumed to be
    ! stacked but not necessarily coherent.  Weights%N are array element
    ! order positions, which can be converted to 2D subscripts (QTM serial
    ! number, height) by the Subscripts function in the Array_Stuff module.

    use Generate_QTM_m, only: QTM_Tree_t
    use Geolocation_0, only: H_t, H_V_t
    use Hunt_m, only: Hunt
    use QTM_m, only: Stack_t

    type(QTM_tree_t), intent(in) :: QTM_Tree
    real(rg), intent(in) :: Heights(:,:) ! from which to interpolate, extents
                                         ! are (# heights, # vertices near path)
                                         ! Assume Heights (meters, zeta) are
    class(h_v_t), intent(in) :: Point    !   the same units as for Point%V
!     type(Value_QTM_2D_List_t(rg)), intent(out) :: Weights
    type(Value_QTM_2D_List_t), intent(out) :: Weights
    integer, intent(in), optional :: Facet
    type(stack_t), intent(inout), optional :: Stack
    class(h_t), intent(out), optional :: Used ! Horizontal coordinates of the
                                         !   point used for interpolation

    real(rg) :: dH       ! Difference in Heights coordinates
    integer :: Index
    integer :: P         ! Index of a corner of a facet
    integer :: S         ! Serial number of a point in the QTM
    real(rg) :: W        ! Weight in the vertical direction for the lower level

    if ( size(heights,2) == 1 ) then ! Coherent heights
      call QTM_Interpolation_Weights ( QTM_Tree, Heights(:,1), &
                                     & Point, Weights, Facet, Stack, Used )
      weights%v%jp = 1
      return
    end if

    ! Get horizontal interpolation coefficients and serial numbers
    call QTM_Interpolation_Weights ( QTM_Tree, Point, Weights, Facet, &
      & Stack, Used )

    ! Default is constant vertical extrapolation outside range of Heights(:)
    weights%v(4:6)%j = 0
    ! Get vertical interpolation coefficients
    do p = 1, 3
      index = 0
      s = weights%v(p)%j
      if ( s /= 0 ) then
        s = QTM_tree%path_vertices(s)
        weights%v(p)%jp = s
        call hunt ( heights(:,s), point%v, index, &
                  & allowTopValue=.true., allowBelowValue = .true. )
      end if

      ! Combine horizontal and vertical interpolation coefficients
      if ( index /= 0 ) then
        dH = heights(index+1,s) - heights(index,s)
        if ( dH == 0 ) then ! shouldn't happen if Heights(:) are distinct
          weights%v(p+3)%j = 0 ! Don't use points other than at Height Index
          weights%v(p+3)%jz = 0
        else
          w = ( heights(index+1,p) - point%v ) / dh
          if ( w == 1.0_rg ) then
            weights%v(p)%jz = index
          else if ( w == 0.0_rg ) then
            weights%v(p)%jz = index+1
          else
            ! Same horizontal coefficients at both levels
            weights%v(p+3)%j = weights%v(p)%j
            weights%v(p+3)%jp = weights%v(p)%jp
            weights%v(p+3)%v = weights%v(p)%v * ( 1.0_rg - w )
            weights%v(p)%v = weights%v(p)%v * w
            weights%v(p+3)%jz = index + 1
            weights%v(p)%jz =index
          end if
        end if
      end if

    end do ! p

    where ( weights%v%v == 0 ) weights%v%j = 0 ! Don't use zero weights
    weights%n = count ( weights%v%j /= 0 )
    weights%v = pack ( weights%v,weights%v%j /= 0 )
!     weights%v(weights%n+1:) = value_QTM_2D_t(rg)(0,0,0,0)
    weights%v(weights%n+1:) = value_QTM_2D_t(0,0,0,0)

  end subroutine QTM_Interpolation_Weights_Geo_3D_Incoherent

  subroutine QTM_Interpolation_Weights_Geo_3D_Incoherent_Line ( QTM_Tree, &
                         & Heights, Line, Points, Weights )

    ! Construct interpolation weights and positions for a point in a 3D grid
    ! for which the horizontal grid is QTM.  The 3D grid is assumed to be
    ! stacked but not necessarily coherent.  Weights%N are array element
    ! order positions, which can be converted to 2D subscripts (QTM serial
    ! number, height) by the Subscripts function in the Array_Stuff module.
    ! The points are described by Line, which consists of a vector in ECR to
    ! a point on a line and an unit vector along the line, and Points, which
    ! describe distances along that line and how the line intersects a prism
    ! of a QTM-based grid (or not).

    use Generate_QTM_m, only: QTM_Tree_t
    use Geolocation_0, only: ECR_t, H_V_Geod

    type(QTM_tree_t), intent(in) :: QTM_Tree
    real(rg), intent(in) :: Heights(:,:) ! from which to interpolate.  Extents
                                         ! are (# heights, # points near path).
    type(ECR_t), intent(in) :: Line(2)   ! Vector to a point on the line,
                                         ! vector along the line.
    type(S_QTM_t), intent(in) :: Points(:) ! Points along Line
!     type(Value_QTM_2D_List_t(rg)), intent(out) :: Weights(size(points))
    type(Value_QTM_2D_List_t), intent(out) :: Weights(size(points))

    type(H_V_Geod) :: G                  ! Geodetic coordinate of Points(i)
    integer :: I, J
    integer :: Jlo, Jhi                  ! Indices of H[pxy] in Heights
    integer :: Nh                        ! Number of heights
    integer :: NP(3)                     ! Second subscripts of Heights
    type(ECR_t) :: P                     ! ECR coordinate of Points(i)
    real(rg) :: W(2,2)                   ! Interpolation weights

    if ( size(heights,2) == 1 ) then ! Coherent heights
      call QTM_Interpolation_Weights ( QTM_Tree, Heights(:,1), &
                                     & Line, Points, Weights )
      return
    end if

    nh = size(heights,1)

    do i = 1, size(points)
      p = line(1) + points(i)*line(2)
      g = p%geod()
      select case ( abs(points(i)%face) )
      case ( cone_face, X_face, Y_face )
        ! Interpolate in height at the X and Y, X and P, or Y and P nodes
        ! of the QTM.
        jlo = 1; jhi = nh
        np(1:2) = QTM_tree%path_vertices(points(i)%coeff%v(1:2)%j)
        call weight_1d ( heights(:,np(1)), g%v, jlo, jhi, w(:,1) )
        call weight_1d ( heights(:,np(2)), g%v, jlo, jhi, w(:,2) )
        ! Assume that it's extremely rare to hit a vertex, so compute four
        ! weights.
        weights(i)%v%v = [ w(:,1)*points(i)%coeff%v(1)%v, &
                         & w(:,2)*points(i)%coeff%v(2)%v, &
                         & 0.0_rg, 0.0_rg ]
        weights(i)%v%j = &
          & [ points(i)%coeff%v(1)%j, points(i)%coeff%v(1)%j, &
            & points(i)%coeff%v(2)%j, points(i)%coeff%v(2)%j, 0, 0 ]
        weights(i)%v%jp = [ np(1), np(1), np(2), np(2), 0, 0 ]
        weights(i)%v%jz = [ jlo, jhi, jlo, jhi, 0, 0 ]

      case ( inside_prism ) ! Use the general method
        call QTM_interpolation_weights ( QTM_tree, heights, g, weights(i) )
      case ( top_face )
        ! Get the two vertical interpolation weights
        do j = 1, 3
          jlo = 1; jhi = nh
          np(j) = QTM_tree%path_vertices(points(i)%coeff%v(j)%j)
          call weight_1d ( heights(:,np(j)), points(i)%h, jlo, jhi, w(:,1) )
          ! Compute the outer product of the vertical and horizontal
          ! interpolation coefficients
          weights(i)%v(2*j-1:2*j)%v = w(:,1)*points(i)%coeff%v(j)%v
          weights(i)%v(2*j-1:2*j)%j = points(i)%coeff%v(j)%j
          weights(i)%v(2*j-1:2*j)%jp = np(j)
          weights(i)%v(2*j-1:2*j)%jz = [ jlo, jhi ]
        end do
      end select

      where ( weights(i)%v%v == 0 ) weights(i)%v%j = 0 ! Don't use zero weights(i)
      weights(i)%n = count ( weights(i)%v%j /= 0 )
      weights(i)%v = pack ( weights(i)%v,weights(i)%v%j /= 0 )
!       weights(i)%v(weights(i)%n+1:) = value_QTM_2D_t(rg)(0,0,0,0)
      weights(i)%v(weights(i)%n+1:) = value_QTM_2D_t(0,0,0,0)

    end do

  end subroutine QTM_Interpolation_Weights_Geo_3D_Incoherent_Line

  subroutine QTM_Interpolation_Weights_Geo_3D_Incoherent_List ( QTM_Tree, &
                         & Heights, Points, Path_Heights, Weights )

    ! Construct interpolation weights and positions for a point in a 3D grid
    ! for which the horizontal grid is QTM.  The 3D grid is assumed to be
    ! stacked but not necessarily coherent.  Weights%N are array element
    ! order positions, which can be converted to 2D subscripts (height, QTM
    ! serial number) by the Subscripts function in the Array_Stuff module.

    use Generate_QTM_m, only: QTM_Tree_t
    use Hunt_m, only: Hunt

    type(QTM_tree_t), intent(in) :: QTM_Tree
    real(rg), intent(in) :: Heights(:,:)  ! from which to interpolate.  Extents
                                          ! are (heights, QTM_Tree%N_In).
    class(s_QTM_t), intent(in) :: Points(:) ! horizontal interpolation coefficients
                                          ! are here
    real(rg), intent(in) :: Path_Heights(:) ! to which to interpolate; same units
                                          ! as heights, same size as Points
!     type(Value_QTM_2D_List_t(rg)), intent(out) :: Weights(size(points))
    type(Value_QTM_2D_List_t), intent(out) :: Weights(size(points))

    real(rg) :: dH       ! Difference in Heights coordinates
    integer :: I, Index
    integer :: NP        ! Second subscript of Heights
    integer :: P         ! Index of a corner of a facet
    integer :: S         ! Serial number of a point in the QTM
    real(rg) :: V        ! Horizontal interpolation coefficient temp
    real(rg) :: W        ! Weight in the vertical direction for the lower level

    if ( size(heights,2) == 1 ) then ! Coherent heights
      call QTM_Interpolation_Weights ( QTM_Tree, heights(:,1), &
                                     & points, path_heights, weights )
      return
    end if

    do i = 1, size(points)
      ! Get horizontal interpolation weights; serial numbers are gotten later
      weights(i)%v(1:3)%v = points(i)%coeff%v%v
      ! Default is constant vertical extrapolation outside range of Heights(:)
      weights(i)%v(4:6)%j = 0
      do p = 1, 3
        index = 0
        s = weights(i)%v(p)%j
        if ( s /= 0 ) then
          np = QTM_tree%path_vertices(s)
          weights(i)%v(p)%jp = np
          weights(i)%v(p+3)%jp = np
          ! Get vertical interpolation indices
          call hunt ( heights(:,np), path_heights(i), index, &             
                    & allowTopValue=.true., allowBelowValue = .true. )
        end if
        ! Combine horizontal and vertical interpolation coefficients
        if ( index == 0 ) then !   below range of Heights(:)
          weights(i)%v(p)%jz = 1 ! Constant vertical extrapolation
        else if ( index >= size(heights,1) ) then
          weights(i)%v(p)%jz = size(heights,1) ! Constant vertical extrapolation
        else
          dH = heights(index+1,np) - heights(index,np)
          if ( dH == 0 ) then ! shouldn't happen if Heights(:) are distinct
            weights(i)%v(p)%jz = index
          else
            w = ( heights(index+1,np) - path_heights(i) ) / dh
            if ( w == 1.0_rg ) then
              weights(i)%v(p)%jz = index
            else if ( w == 0.0_rg ) then
              weights(i)%v(p)%jz = index+1
            else
              v = weights(i)%v(p)%v
              weights(i)%v(p) = &
!                 & value_QTM_2D_t(rg) ( n = points(i)%coeff%v(p)%n, np = np, &
                & value_QTM_2D_t ( j = points(i)%coeff%v(p)%j, jp = np, &
                                     & jz = index, &
                                     & v = v * ( 1.0_rg - w ) )
              weights(i)%v(p+3) = &
!                 & value_QTM_2D_t(rg) ( n = points(i)%coeff%v(p)%n, np = np, &
                & value_QTM_2D_t ( j = points(i)%coeff%v(p)%j, jp = np, &
                                     & jz = index + 1, v = v * w )
            end if
          end if
        end if

      end do ! p

      where ( weights(i)%v%v == 0 ) weights(i)%v%j = 0
      weights(i)%n = count ( weights(i)%v%j /= 0 ) 
      weights(i)%v = pack ( weights(i)%v,weights(i)%v%j /= 0 )
!       weights(i)%v(weights(i)%n+1:6) = value_QTM_2D_t(rg)(0,0,0,0)
      weights(i)%v(weights(i)%n+1:6) = value_QTM_2D_t(0,0,0,0)

    end do ! i

  end subroutine QTM_Interpolation_Weights_Geo_3D_Incoherent_List

  subroutine QTM_Interpolation_Weights_Geo_3D_Line ( QTM_Tree, &
                         & Heights, Line, Points, Weights )

    ! Construct interpolation weights and positions for a point in a 3D grid
    ! for which the horizontal grid is QTM.  The 3D grid is assumed to be
    ! stacked and coherent.  Weights%N are array element order positions,
    ! which can be converted to 2D subscripts (height, QTM serial number) by
    ! the Subscripts function in the Array_Stuff module. The points are
    ! described by Line, which consists of a vector in ECR to a point on a
    ! line and an unit vector along the line, and Points, which describe
    ! distances along that line and how the line intersects a prism of a
    ! QTM-based grid (or not).

    use Generate_QTM_m, only: QTM_Tree_t
    use Geolocation_0, only: ECR_t, H_V_Geod

    type(QTM_tree_t), intent(in) :: QTM_Tree
    real(rg), intent(in) :: Heights(:)   ! from which to interpolate.  Coherent.
    type(ECR_t), intent(in) :: Line(2)   ! Vector to a point on the line,
                                         ! vector along the line.
    type(S_QTM_t), intent(in) :: Points(:) ! Points along Line
!     type(Value_QTM_2D_List_t(rg)), intent(out) :: Weights(size(points))
    type(Value_QTM_2D_List_t), intent(out) :: Weights(size(points))

    type(h_v_geod) :: G                  ! Geodetic coordinate of Points(i)
    integer :: I
    integer :: Jlo, Jhi                  ! Indices of H[pxy] in Heights
    integer :: Nh                        ! Number of heights
    type(ECR_t) :: P                     ! ECR coordinate of Points(i)
    real(rg) :: W(2)                     ! Interpolation weights

    nh = size(heights,1)

    do i = 1, size(points)
      p = line(1) + points(i)*line(2)
      g = p%geod()
      select case ( abs(points(i)%face) )
      case ( cone_face, X_face, Y_face )
        ! Interpolate in height at the X and Y, X and P, or Y and P nodes
        ! of the QTM.
        ! Get the two vertical interpolation weights
        jlo = 1; jhi = nh
        call weight_1d ( heights, g%v, jlo, jhi, w )
        ! Assume that it's extremely rare to hit a vertex, so compute four
        ! weights.
        weights(i)%n = 4
        ! Compute the outer product of the vertical and horizontal
        ! interpolation coefficients
        weights(i)%v(1:6)%v = [ w*points(i)%coeff%v(1)%v, &
                              & w*points(i)%coeff%v(2)%v, 0.0_rg, 0.0_rg ]
        weights(i)%v(1:6)%j = &
          & [ points(i)%coeff%v(1)%j, points(i)%coeff%v(1)%j, &
            & points(i)%coeff%v(2)%j, points(i)%coeff%v(2)%j, 0, 0 ]
        weights(i)%v(1:6)%jp = [ QTM_tree%path_vertices(weights(i)%v(1:4)%j), 0, 0 ]
        weights(i)%v(1:6)%jz = [ jlo, jhi, jlo, jhi, 0, 0 ]
      case ( inside_prism ) ! Use the general method
        call QTM_interpolation_weights ( QTM_tree, heights, g, weights(i) )
      case ( top_face )
        ! Get the two vertical interpolation weights
        jlo = 1; jhi = nh
        call weight_1d ( heights, g%v, jlo, jhi, w )
        weights(i)%n = 6
        ! Compute the outer product of the vertical and horizontal
        ! interpolation coefficients
        weights(i)%v(1:6)%v = [ w*points(i)%coeff%v(1)%v, &
                              & w*points(i)%coeff%v(2)%v, &
                              & w*points(i)%coeff%v(3)%v ]
        weights(i)%v(1:6)%j = &
          & [ points(i)%coeff%v(1)%j, points(i)%coeff%v(1)%j, &
            & points(i)%coeff%v(2)%j, points(i)%coeff%v(2)%j, &
            & points(i)%coeff%v(3)%j, points(i)%coeff%v(3)%j ]
        weights(i)%v(1:6)%jp = QTM_tree%path_vertices(weights(i)%v(1:6)%j)
        weights(i)%v(1:6)%jz = [ jlo, jhi, jlo, jhi, jlo, jhi ]
      end select

      where ( weights(i)%v%v == 0 ) weights(i)%v%j = 0
      weights(i)%n = count ( weights(i)%v%j /= 0 ) 
      weights(i)%v = pack ( weights(i)%v,weights(i)%v%j /= 0 )
!       weights(i)%v(weights(i)%j+1:6) = value_QTM_2D_t(rg)(0,0,0,0)
      weights(i)%v(weights(i)%n+1:6) = value_QTM_2D_t(0,0,0,0)

    end do

  end subroutine QTM_Interpolation_Weights_Geo_3D_Line

  subroutine QTM_Interpolation_Weights_Geo_3D_List ( QTM_Tree, Heights, Points, &
                                                   & Path_Heights, Weights )

    ! Construct interpolation weights and positions for a point in a 3D grid
    ! for which the horizontal grid is QTM.  The 3D grid is assumed to be
    ! stacked and coherent.  Weights%W%J are array element order positions,
    ! which can be converted to 2D subscripts (height, QTM serial number)
    ! by the Subscripts function in the Array_Stuff module.

    use Generate_QTM_m, only: QTM_Tree_t
    use Hunt_m, only: Hunt

    type(QTM_tree_t), intent(in) :: QTM_Tree
    real(rg), intent(in) :: Heights(:)    ! from which to interpolate.  Coherent
    class(s_QTM_t), intent(in) :: Points(:) ! horizontal interpolation coefficients
                                          ! are here
    real(rg), intent(in) :: Path_Heights(:) ! to which to interpolate; same units
                                          ! as heights, same size as Points
!     type(Value_QTM_2D_List_t(rg)), intent(out) :: Weights(size(points))
    type(Value_QTM_2D_List_t), intent(out) :: Weights(size(points))

    real(rg) :: dH       ! Difference in Heights coordinates
    integer :: I, Index, Indices(size(points)), J
    real(rg) :: W        ! Weight in the vertical direction for the lower level

    ! Get vertical interpolation indices
    call hunt ( heights, path_heights, indices, &
              & allowTopValue=.true., allowBelowValue = .true. )

    ! Combine horizontal and vertical interpolation coefficients
    do i = 1, size(points)
      ! Get horizontal interpolation weights; serial numbers are gotten later
      weights(i)%v(1:3)%j = points(i)%coeff%v%j
      where ( weights(i)%v(1:3)%j /= 0 ) &
        & weights(i)%v(1:3)%jp = QTM_tree%path_vertices(weights(i)%v(1:3)%j)
      weights(i)%v(1:3)%v = points(i)%coeff%v%v
      index = indices(i)
      if ( index == 0 ) then
        weights(i)%v(4:)%j = 0  ! Constant vertical extrapolation
                                !   below range of Heights(:)
      else if ( index >= size(heights,1) ) then
        do j = 1, 3
          weights(i)%v(j)%j = points(i)%coeff%v(j)%j
          weights(i)%v(j)%jz = size(heights,1)
        end do
        weights(i)%v(4:)%j = 0  ! Constant vertical extrapolation
                                !   above range of Heights(:)
      else
        dH = heights(index+1) - heights(index)
        if ( dH == 0 ) then ! shouldn't happen if Heights(:) are distinct
          weights(i)%v(4:6)%j = 0 ! Don't use points other than at Height Index
        else
          w = ( heights(index+1) - path_heights(i) ) / dh
          if ( w == 1.0_rg ) then
            weights(i)%v(1:3)%jz = index
            weights(i)%v(4:)%j = 0 ! Don't use points other than at Height Index
          else if ( w == 0.0_rg ) then
            weights(i)%v(j)%jz = index + 1
            weights(i)%v(4:)%j = 0 ! Don't use points other than at Height Index
          else
            weights(i)%v(4:6)%v = weights(i)%v(1:3)%v * ( 1.0_rg - w )
            weights(i)%v(1:3)%v = weights(i)%v(1:3)%v * w
            weights(i)%v(4:6)%j = weights(i)%v(1:3)%j
            weights(i)%v(4:6)%jp = weights(i)%v(1:3)%jp
            weights(i)%v(1:6)%jz = [ index, index+1, index, index+1, index, index+1 ]
          end if
        end if
      end if

      where ( weights(i)%v%v == 0 ) weights(i)%v%j = 0
      weights(i)%n = count ( weights(i)%v%j /= 0 ) 
      weights(i)%v = pack ( weights(i)%v,weights(i)%v%j /= 0 )
!       weights(i)%v(weights(i)%j+1:) = value_QTM_2D_t(rg)(0,0,0,0)
      weights(i)%v(weights(i)%n+1:) = value_QTM_2D_t(0,0,0,0)

    end do ! i

  end subroutine QTM_Interpolation_Weights_Geo_3D_List

!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.14 2018/05/14 23:25:29 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module QTM_Interpolation_Weights_3D_m

! $Log: QTM_Interpolation_Weights_3D_m.f90,v $
! Revision 2.14  2018/05/14 23:25:29  vsnyder
! Change to sparse eta representation
!
! Revision 2.13  2017/08/28 20:27:47  livesey
! Changed the n,nf,np,nz elements to j,jf,...
!
! Revision 2.12  2016/11/23 00:11:21  vsnyder
! Delete Weights_ZQ_t.  Use types from Indexed_Values_m.
!
! Revision 2.11  2016/11/12 01:37:02  vsnyder
! Add PV component in case somebody wants to store the path subscript for a
! QTM serial number.  Add Facet argument to routines with scalar Point, in
! case somebody already knows it.  Compute NP and NZ indices newly added
! to Value_t, instead of conflating 2-D subscript into N.
!
! Revision 2.10  2016/11/02 22:55:53  vsnyder
! Use Value_t from Path_Representation_m instead of Weight_t from
! QTM_Interpolation_Weights_m.
!
! Revision 2.9  2016/10/25 18:23:48  vsnyder
! Inching toward 3D-QTM forward model support
!
! Revision 2.8  2016/10/18 00:44:28  vsnyder
! Correct some comments
!
! Revision 2.7  2016/10/05 23:28:22  vsnyder
! Replace ZOT_n component name with Ser because it's a serial number for
! more than just the ZOT coordinates.
!
! Revision 2.6  2016/09/14 20:46:21  vsnyder
! Add H_Ind component, move Weight_1D to Weight_1D_m
!
! Revision 2.5  2016/04/28 23:09:50  vsnyder
! Interpret negative face number as the index of the face intersected by a
! line segment outside the QTM.  Alphabetize components of S_QTM_t.
!
! Revision 2.4  2016/04/16 02:04:06  vsnyder
! Add S_QTM_t, routines for using positions on a line
!
! Revision 2.3  2016/03/30 01:42:02  vsnyder
! Detect and exploit coherent heights in incoherent routine
!
! Revision 2.2  2016/01/26 02:30:32  vsnyder
! Add QTM_Interpolation_Weights_Geo_3D_Incoherent_List to generic
! QTM_Interpolation_Weights.
!
! Revision 2.1  2015/12/31 00:56:47  vsnyder
! Initial commit
!
@


2.14
log
@Change to sparse eta representation
@
text
@d624 1
a624 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.13 2017/08/28 20:27:47 livesey Exp $"
d634 3
@


2.13
log
@Changed the n,nf,np,nz elements to j,jf,...
@
text
@d17 2
a18 3
  use QTM_Interpolation_Weights_m, only: QTM_Interpolation_Weights
  use Indexed_Values_m, only: Value_QTM_1D_List_t, Value_QTM_2D_List_t, &
    & Value_QTM_2D_t
d43 3
a45 1
                     ! the path, to which the coefficients apply.
d624 1
a624 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.12 2016/11/23 00:11:21 vsnyder Exp $"
d634 3
@


2.12
log
@Delete Weights_ZQ_t.  Use types from Indexed_Values_m.
@
text
@d140 1
a140 1
      weights%v(4:6)%n = 0 ! Constant vertical extrapolation below Heights(:)
d143 1
a143 1
        weights%v(j)%nz = size(heights)
d145 1
a145 1
      weights%v(4:6)%n = 0 ! Constant vertical extrapolation above Heights(:)
d149 1
a149 1
        weights%v(4:6)%n = 0 ! Don't use points other than at Height Index
d154 1
a154 1
            weights%v(j)%nz = index
d156 1
a156 1
          weights%v(4:6)%n = 0 ! Don't use points other than at Height Index
d159 1
a159 1
            weights%v(j)%nz = index + 1
d161 1
a161 1
          weights%v(4:6)%n = 0 ! Don't use points other than at Height Index + 1
d166 2
a167 2
            weights%v(j+3)%nz = index + 1
            weights%v(j)%nz = index
d173 3
a175 3
    where ( weights%v%v == 0 ) weights%v%n = 0
    weights%n = count ( weights%v%n /= 0 ) 
    weights%v = pack ( weights%v,weights%v%n /= 0 )
d216 1
a216 1
      weights%v%np = 1
d225 1
a225 1
    weights%v(4:6)%n = 0
d229 1
a229 1
      s = weights%v(p)%n
d232 1
a232 1
        weights%v(p)%np = s
d241 2
a242 2
          weights%v(p+3)%n = 0 ! Don't use points other than at Height Index
          weights%v(p+3)%nz = 0
d246 1
a246 1
            weights%v(p)%nz = index
d248 1
a248 1
            weights%v(p)%nz = index+1
d251 2
a252 2
            weights%v(p+3)%n = weights%v(p)%n
            weights%v(p+3)%np = weights%v(p)%np
d255 2
a256 2
            weights%v(p+3)%nz = index + 1
            weights%v(p)%nz =index
d263 3
a265 3
    where ( weights%v%v == 0 ) weights%v%n = 0 ! Don't use zero weights
    weights%n = count ( weights%v%n /= 0 )
    weights%v = pack ( weights%v,weights%v%n /= 0 )
d320 1
a320 1
        np(1:2) = QTM_tree%path_vertices(points(i)%coeff%v(1:2)%n)
d328 5
a332 5
        weights(i)%v%n = &
          & [ points(i)%coeff%v(1)%n, points(i)%coeff%v(1)%n, &
            & points(i)%coeff%v(2)%n, points(i)%coeff%v(2)%n, 0, 0 ]
        weights(i)%v%np = [ np(1), np(1), np(2), np(2), 0, 0 ]
        weights(i)%v%nz = [ jlo, jhi, jlo, jhi, 0, 0 ]
d340 1
a340 1
          np(j) = QTM_tree%path_vertices(points(i)%coeff%v(j)%n)
d345 3
a347 3
          weights(i)%v(2*j-1:2*j)%n = points(i)%coeff%v(j)%n
          weights(i)%v(2*j-1:2*j)%np = np(j)
          weights(i)%v(2*j-1:2*j)%nz = [ jlo, jhi ]
d351 3
a353 3
      where ( weights(i)%v%v == 0 ) weights(i)%v%n = 0 ! Don't use zero weights(i)
      weights(i)%n = count ( weights(i)%v%n /= 0 )
      weights(i)%v = pack ( weights(i)%v,weights(i)%v%n /= 0 )
d401 1
a401 1
      weights(i)%v(4:6)%n = 0
d404 1
a404 1
        s = weights(i)%v(p)%n
d407 2
a408 2
          weights(i)%v(p)%np = np
          weights(i)%v(p+3)%np = np
d415 1
a415 1
          weights(i)%v(p)%nz = 1 ! Constant vertical extrapolation
d417 1
a417 1
          weights(i)%v(p)%nz = size(heights,1) ! Constant vertical extrapolation
d421 1
a421 1
            weights(i)%v(p)%nz = index
d425 1
a425 1
              weights(i)%v(p)%nz = index
d427 1
a427 1
              weights(i)%v(p)%nz = index+1
d432 2
a433 2
                & value_QTM_2D_t ( n = points(i)%coeff%v(p)%n, np = np, &
                                     & nz = index, &
d437 2
a438 2
                & value_QTM_2D_t ( n = points(i)%coeff%v(p)%n, np = np, &
                                     & nz = index + 1, v = v * w )
d445 3
a447 3
      where ( weights(i)%v%v == 0 ) weights(i)%v%n = 0
      weights(i)%n = count ( weights(i)%v%n /= 0 ) 
      weights(i)%v = pack ( weights(i)%v,weights(i)%v%n /= 0 )
d505 5
a509 5
        weights(i)%v(1:6)%n = &
          & [ points(i)%coeff%v(1)%n, points(i)%coeff%v(1)%n, &
            & points(i)%coeff%v(2)%n, points(i)%coeff%v(2)%n, 0, 0 ]
        weights(i)%v(1:6)%np = [ QTM_tree%path_vertices(weights(i)%v(1:4)%n), 0, 0 ]
        weights(i)%v(1:6)%nz = [ jlo, jhi, jlo, jhi, 0, 0 ]
d522 6
a527 6
        weights(i)%v(1:6)%n = &
          & [ points(i)%coeff%v(1)%n, points(i)%coeff%v(1)%n, &
            & points(i)%coeff%v(2)%n, points(i)%coeff%v(2)%n, &
            & points(i)%coeff%v(3)%n, points(i)%coeff%v(3)%n ]
        weights(i)%v(1:6)%np = QTM_tree%path_vertices(weights(i)%v(1:6)%n)
        weights(i)%v(1:6)%nz = [ jlo, jhi, jlo, jhi, jlo, jhi ]
d530 4
a533 4
      where ( weights(i)%v%v == 0 ) weights(i)%v%n = 0
      weights(i)%n = count ( weights(i)%v%n /= 0 ) 
      weights(i)%v = pack ( weights(i)%v,weights(i)%v%n /= 0 )
!       weights(i)%v(weights(i)%n+1:6) = value_QTM_2D_t(rg)(0,0,0,0)
d545 1
a545 1
    ! stacked and coherent.  Weights%W%N are array element order positions,
d572 3
a574 3
      weights(i)%v(1:3)%n = points(i)%coeff%v%n
      where ( weights(i)%v(1:3)%n /= 0 ) &
        & weights(i)%v(1:3)%np = QTM_tree%path_vertices(weights(i)%v(1:3)%n)
d578 1
a578 1
        weights(i)%v(4:)%n = 0  ! Constant vertical extrapolation
d582 2
a583 2
          weights(i)%v(j)%n = points(i)%coeff%v(j)%n
          weights(i)%v(j)%nz = size(heights,1)
d585 1
a585 1
        weights(i)%v(4:)%n = 0  ! Constant vertical extrapolation
d590 1
a590 1
          weights(i)%v(4:6)%n = 0 ! Don't use points other than at Height Index
d594 2
a595 2
            weights(i)%v(1:3)%nz = index
            weights(i)%v(4:)%n = 0 ! Don't use points other than at Height Index
d597 2
a598 2
            weights(i)%v(j)%nz = index + 1
            weights(i)%v(4:)%n = 0 ! Don't use points other than at Height Index
d602 3
a604 3
            weights(i)%v(4:6)%n = weights(i)%v(1:3)%n
            weights(i)%v(4:6)%np = weights(i)%v(1:3)%np
            weights(i)%v(1:6)%nz = [ index, index+1, index, index+1, index, index+1 ]
d609 4
a612 4
      where ( weights(i)%v%v == 0 ) weights(i)%v%n = 0
      weights(i)%n = count ( weights(i)%v%n /= 0 ) 
      weights(i)%v = pack ( weights(i)%v,weights(i)%v%n /= 0 )
!       weights(i)%v(weights(i)%n+1:) = value_QTM_2D_t(rg)(0,0,0,0)
d623 1
a623 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.11 2016/11/12 01:37:02 vsnyder Exp $"
d633 3
@


2.11
log
@Add PV component in case somebody wants to store the path subscript for a
QTM serial number.  Add Facet argument to routines with scalar Point, in
case somebody already knows it.  Compute NP and NZ indices newly added
to Value_t, instead of conflating 2-D subscript into N.
@
text
@d18 2
a19 1
  use Path_Representation_m, only: Value_t
d29 2
d40 5
a44 1
    real(rg) :: Coeff(3) = 0.0_rg ! Horizontal interpolation coefficients.
d59 3
a61 3
                     ! line intersects.  The coordinates indexed by Ser are
                     ! those where the line intersects the QTM, not where it
                     ! intersects a surface of a height equal to one of the
a75 5
    integer :: N_Coeff = 0 ! How many elements of Coeff and Ser are used.
    integer :: PV(3) = 0   ! Indices of vertices near path, from 
                     ! QTM%path_vertices(ser), second subscript for heights.
    integer :: Ser(3) = 0  ! Serial numbers of facet coordinates, see QTM_Node_t
                     ! in the Generate_QTM_m module.
a77 9
  integer, parameter, public :: MaxCoeff = 6 ! First dimension of Weights arguments

  ! Interpolation coefficients within a 3D grid that has a QTM horizontal grid
  type, public :: Weight_ZQ_t
    integer :: N                  ! count(w%v /= 0), <= MaxCoeff
    type(value_t) :: W(maxCoeff)  ! Weights, and array element positions in
                                  ! the state vector or at points near the path
  end type Weight_ZQ_t

d112 1
a112 1
    use Geolocation_0, only: H_t, H_V_t
d114 1
a114 1
    use QTM_m, only: QK, Stack_t
d119 2
a120 1
    type(weight_ZQ_t), intent(out) :: Weights
a127 2
    integer(qk) :: N_QTM ! Number of vertices of QTM within or adjacent to
                         ! the polygon
a129 2
    n_QTM = QTM_Tree%n_in

d131 1
a131 1
    call QTM_Interpolation_Weights ( QTM_Tree, Point, Weights%w(1:3), Facet, &
d140 1
a140 2
      weights%w(4:6)%n = 0 ! Constant vertical extrapolation outside
                           !   below of Heights(:)
d143 1
a143 1
        weights%w(j)%nz = size(heights)
d145 1
a145 2
      weights%w(4:6)%n = 0 ! Constant vertical extrapolation outside
                           !   above of Heights(:)
d149 1
a149 1
        weights%w(4:6)%n = 0 ! Don't use points other than at Height Index
d154 1
a154 1
            weights%w(j)%nz = index
d156 1
a156 1
          weights%w(4:6)%n = 0 ! Don't use points other than at Height Index
d159 1
a159 1
            weights%w(j)%nz = index + 1
d161 1
a161 1
          weights%w(4:6)%n = 0 ! Don't use points other than at Height Index + 1
d163 2
a164 2
          weights%w(4:6)%v = weights%w(1:3)%v * ( 1.0_rg - w )
          weights%w(1:3)%v = weights%w(1:3)%v * w
d166 2
a167 2
            weights%w(j+3)%nz = index + 1
            weights%w(j)%nz = index
d173 5
a177 4
    where ( weights%w%v == 0 ) weights%w%n = 0
    weights%n = count ( weights%w%n /= 0 ) 
    weights%w = pack ( weights%w,weights%w%n /= 0 )
    weights%w(weights%n+1:) = value_t(0,0,0,0)
d193 1
a193 1
    use QTM_m, only: QK, Stack_t
d200 2
a201 1
    type(weight_ZQ_t), intent(out) :: Weights
a208 2
    integer(qk) :: N_QTM ! Number of vertices of QTM within or adjacent to
                         ! the polygon
d216 1
a216 1
      weights%w%np = 1
a219 2
    n_QTM = QTM_Tree%n_in

d221 1
a221 1
    call QTM_Interpolation_Weights ( QTM_Tree, Point, Weights%w(1:3), Facet, &
d225 1
a225 1
    weights%w(4:6)%n = 0
d229 1
a229 1
      s = weights%w(p)%n
d232 1
a232 1
        weights%w(p)%np = s
d241 2
a242 2
          weights%w(p+3)%n = 0 ! Don't use points other than at Height Index
          weights%w(p+3)%nz = 0
d246 1
a246 1
            weights%w(p)%nz = index
d248 1
a248 1
            weights%w(p)%nz = index+1
d251 6
a256 6
            weights%w(p+3)%n = weights%w(p)%n
            weights%w(p+3)%np = weights%w(p)%np
            weights%w(p+3)%v = weights%w(p)%v * ( 1.0_rg - w )
            weights%w(p)%v = weights%w(p)%v * w
            weights%w(p+3)%nz = index + 1
            weights%w(p)%nz =index
d263 5
a267 4
    where ( weights%w%v == 0 ) weights%w%n = 0 ! Don't use zero weights
    weights%n = count ( weights%w%n /= 0 )
    weights%w = pack ( weights%w,weights%w%n /= 0 )
    weights%w(weights%n+1:) = value_t(0,0,0,0)
d293 2
a294 1
    type(weight_ZQ_t), intent(out) :: Weights(size(points))
d320 1
a320 1
        np(1:2) = QTM_tree%path_vertices(points(i)%ser(1:2))
d325 8
a332 9
        weights(i)%n = 4
        weights(i)%w(1:maxCoeff)%v = [ w(:,1)*points(i)%coeff(1), &
                                     & w(:,2)*points(i)%coeff(2), &
                                     & 0.0_rg, 0.0_rg ]
        weights(i)%w(1:maxCoeff)%n = &
          & [ points(i)%ser(1), points(i)%ser(1), &
            & points(i)%ser(2), points(i)%ser(2), 0, 0 ]
        weights(i)%w(1:maxCoeff)%np = [ np(1), np(1), np(2), np(2), 0, 0 ]
        weights(i)%w(1:maxCoeff)%nz = [ jlo, jhi, jlo, jhi, 0, 0 ]
d340 1
a340 1
          np(j) = QTM_tree%path_vertices(points(i)%ser(j))
a341 1
          weights(i)%n = 6
d344 4
a347 4
          weights(i)%w(2*j-1:2*j)%v = w(:,1)*points(i)%coeff(j)
          weights(i)%w(2*j-1:2*j)%n = points(i)%ser(j)
          weights(i)%w(2*j-1:2*j)%np = np(j)
          weights(i)%w(2*j-1:2*j)%nz = [ jlo, jhi ]
d351 5
a355 4
      where ( weights(i)%w%v == 0 ) weights(i)%w%n = 0 ! Don't use zero weights(i)
      weights(i)%n = count ( weights(i)%w%n /= 0 )
      weights(i)%w = pack ( weights(i)%w,weights(i)%w%n /= 0 )
      weights(i)%w(weights(i)%n+1:) = value_t(0,0,0,0)
a371 1
    use QTM_m, only: QK
d380 2
a381 1
    type(weight_ZQ_t), intent(out) :: Weights(size(points))
a384 2
    integer(qk) :: N_QTM ! Number of vertices of QTM within or adjacent to
                         ! the polygon
a396 2
    n_QTM = QTM_Tree%n_in

d399 1
a399 1
      weights(i)%w(1:3)%v = points(i)%coeff
d401 1
a401 1
      weights(i)%w(4:6)%n = 0
d404 1
a404 1
        s = weights(i)%w(p)%n
d407 2
a408 2
          weights(i)%w(p)%np = np
          weights(i)%w(p+3)%np = np
d415 1
a415 1
          weights(i)%w(p)%nz = 1 ! Constant vertical extrapolation
d417 1
a417 1
          weights(i)%w(p)%nz = size(heights,1) ! Constant vertical extrapolation
d421 1
a421 1
            weights(i)%w(p)%nz = index
d425 1
a425 1
              weights(i)%w(p)%nz = index
d427 1
a427 1
              weights(i)%w(p)%nz = index+1
d429 10
a438 6
              v = weights(i)%w(p)%v
              weights(i)%w(p) = value_t ( n = points(i)%ser(p), np = np, &
                                        & nz = index, &
                                        & v = v * ( 1.0_rg - w ) )
              weights(i)%w(p+3) = value_t ( n = points(i)%ser(p), np = np, &
                                        & nz = index + 1, v = v * w )
d445 5
a449 4
      where ( weights(i)%w%v == 0 ) weights(i)%w%n = 0
      weights(i)%n = count ( weights(i)%w%n /= 0 ) 
      weights(i)%w = pack ( weights(i)%w,weights(i)%w%n /= 0 )
      weights(i)%w(weights(i)%n+1:6) = value_t(0,0,0,0)
d476 2
a477 1
    type(weight_ZQ_t), intent(out) :: Weights(size(points))
d503 7
a509 7
        weights(i)%w(1:6)%v = [ w*points(i)%coeff(1), &
                              & w*points(i)%coeff(2), 0.0_rg, 0.0_rg ]
        weights(i)%w(1:6)%n = &
          & [ points(i)%ser(1), points(i)%ser(1), &
            & points(i)%ser(2), points(i)%ser(2), 0, 0 ]
        weights(i)%w(1:6)%np = [ QTM_tree%path_vertices(weights(i)%w(1:4)%n), 0, 0 ]
        weights(i)%w(1:6)%nz = [ jlo, jhi, jlo, jhi, 0, 0 ]
d519 9
a527 9
        weights(i)%w(1:6)%v = [ w*points(i)%coeff(1), &
                              & w*points(i)%coeff(2), &
                              & w*points(i)%coeff(3) ]
        weights(i)%w(1:6)%n = &
          & [ points(i)%ser(1),points(i)%ser(1), &
            & points(i)%ser(2),points(i)%ser(2), &
            & points(i)%ser(3),points(i)%ser(3) ]
        weights(i)%w(1:6)%np = QTM_tree%path_vertices(weights(i)%w(1:6)%n)
        weights(i)%w(1:6)%nz = [ jlo, jhi, jlo, jhi, jlo, jhi ]
d530 5
a534 4
      where ( weights(i)%w%v == 0 ) weights(i)%w%n = 0
      weights(i)%n = count ( weights(i)%w%n /= 0 ) 
      weights(i)%w = pack ( weights(i)%w,weights(i)%w%n /= 0 )
      weights(i)%w(weights(i)%n+1:6) = value_t(0,0,0,0)
a550 1
    use QTM_m, only: QK
d558 2
a559 1
    type(weight_ZQ_t), intent(out) :: Weights(size(points))
d572 4
a575 4
      weights(i)%w(1:3)%n = points(i)%ser
      where ( weights(i)%w(1:3)%n /= 0 ) &
        & weights(i)%w(1:3)%np = QTM_tree%path_vertices(weights(i)%w(1:3)%n)
      weights(i)%w(1:3)%v = points(i)%coeff
d578 2
a579 2
        weights(i)%w(4:maxCoeff)%n = 0  ! Constant vertical extrapolation
                                        !   below range of Heights(:)
d582 2
a583 2
          weights(i)%w(j)%n = points(i)%ser(j)
          weights(i)%w(j)%nz = size(heights,1)
d585 2
a586 2
        weights(i)%w(4:maxCoeff)%n = 0  ! Constant vertical extrapolation
                                        !   above range of Heights(:)
d590 1
a590 1
          weights(i)%w(4:6)%n = 0 ! Don't use points other than at Height Index
d594 2
a595 2
            weights(i)%w(1:3)%nz = index
            weights(i)%w(4:maxCoeff)%n = 0 ! Don't use points other than at Height Index
d597 2
a598 2
            weights(i)%w(j)%nz = index + 1
            weights(i)%w(4:maxCoeff)%n = 0 ! Don't use points other than at Height Index
d600 5
a604 5
            weights(i)%w(4:6)%v = weights(i)%w(1:3)%v * ( 1.0_rg - w )
            weights(i)%w(1:3)%v = weights(i)%w(1:3)%v * w
            weights(i)%w(4:6)%n = weights(i)%w(1:3)%n
            weights(i)%w(4:6)%np = weights(i)%w(1:3)%np
            weights(i)%w(1:6)%nz = [ index, index+1, index, index+1, index, index+1 ]
d609 5
a613 4
      where ( weights(i)%w%v == 0 ) weights(i)%w%n = 0
      weights(i)%n = count ( weights(i)%w%n /= 0 ) 
      weights(i)%w = pack ( weights(i)%w,weights(i)%w%n /= 0 )
      weights(i)%w(weights(i)%n+1:maxCoeff) = value_t(0,0,0,0)
d623 1
a623 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.10 2016/11/02 22:55:53 vsnyder Exp $"
d633 6
@


2.10
log
@Use Value_t from Path_Representation_m instead of Weight_t from
QTM_Interpolation_Weights_m.
@
text
@d70 2
d82 1
a82 3
                                  ! 1-D view of the state vector, a conflation
                                  ! of (height, QTM) indices using
                                  ! Element_Position from Array_Stuff
d112 1
a112 1
                                              & Weights, Stack, Used )
d116 1
a116 3
    ! stacked and coherent.  Weights%N are array element order positions,
    ! which can be converted to 2D subscripts (height, QTM serial number) by
    ! the Subscripts function in the Array_Stuff module.
a117 1
    use Array_Stuff, only: Element_Position
d127 1
d141 2
a142 1
    call QTM_Interpolation_Weights ( QTM_Tree, Point, Weights%w(1:3), Stack, Used )
d151 1
a151 1
                           !   range of Heights(:)
d154 1
a154 2
        weights%w(j)%n = element_position ( [ weights%w(j)%n, size(heights) ], &
                                            & [ n_QTM, size(heights) ] )
d157 1
a157 1
                           !   range of Heights(:)
d166 1
a166 2
            weights%w(j)%n = element_position ( [ weights%w(j)%n, index ], &
                                              & [ n_QTM, size(heights) ] )
d171 1
a171 2
            weights%w(j)%n = element_position ( [ weights%w(j)%n, index+1 ], &
                                              & [ n_QTM, size(heights) ] )
d178 2
a179 4
            weights%w(j+3)%n = element_position ( [ weights%w(j)%n, index+1 ], &
                                                & [ n_QTM, size(heights) ] )
            weights%w(j)%n = element_position ( [ weights%w(j)%n, index ], &
                                              & [ n_QTM, size(heights) ] )
d184 1
a184 1
    weights%n = count ( weights%w%v /= 0 ) 
d186 1
d188 1
a188 1
    weights%w(weights%n+1:) = value_t(0,0)
d193 1
a193 1
                                     & Point, Weights, Stack, Used )
a200 1
    use Array_Stuff, only: Element_Position
d207 2
a208 1
    real(rg), intent(in) :: Heights(:,:) ! Extents are (heights, QTM_Tree%N_In)
d212 1
d227 2
a228 1
                                     & Point, Weights, Stack, Used )
d235 2
a236 1
    call QTM_Interpolation_Weights ( QTM_Tree, Point, Weights%w(1:3), Stack, Used )
d245 2
d252 1
a252 5
      if ( index == 0 ) then
      else if ( index >= size(heights) ) then
        weights%w(p)%n = element_position ( [ weights%w(p)%n, size(heights,1) ], &
                                          & [ n_QTM, size(heights,1) ] )
      else
d255 2
a256 1
          weights%w(4:6)%n = 0 ! Don't use points other than at Height Index
d260 1
a260 2
            weights%w(p)%n = element_position ( [ weights%w(p)%n, index ], &
                                              & [ n_QTM, size(heights,1) ] )
d262 1
a262 2
            weights%w(p)%n = element_position ( [ weights%w(p)%n, index+1 ], &
                                              & [ n_QTM, size(heights,1) ] )
d264 3
d269 2
a270 4
            weights%w(p+3)%n = element_position ( [ weights%w(p)%n, index+1 ], &
                                                & [ n_QTM, size(heights,1) ] )
            weights%w(p)%n = element_position ( [ weights%w(p)%n, index ], &
                                              & [ n_QTM, size(heights,1) ] )
d277 2
a278 2
    weights%n = count ( weights%w%v /= 0 ) 
    where ( weights%w%v == 0 ) weights%w%n = 0
d280 1
a280 1
    weights%w(weights%n+1:maxCoeff) = value_t(0,0)
a296 1
    use Array_Stuff, only: Element_Position
d301 2
a302 2
    real(rg), intent(in) :: Heights(:,:) ! to which to interpolate.  Extents are
                                         ! (heights, QTM_Tree%N_In).
d312 1
a312 1
    integer :: NQ                        ! Number of QTM vertices
a322 1
    nq = size(QTM_Tree%q)
d332 3
a334 2
        call weight_1d ( heights(:,points(i)%ser(1)), g%v, jlo, jhi, w(:,1) )
        call weight_1d ( heights(:,points(i)%ser(2)), g%v, jlo, jhi, w(:,2) )
d342 5
a346 4
          & [ element_position([jlo,points(i)%ser(1)], [nh,nq]), &
            & element_position([jhi,points(i)%ser(1)], [nh,nq]), &
            & element_position([jlo,points(i)%ser(2)], [nh,nq]), &
            & element_position([jhi,points(i)%ser(2)], [nh,nq]), 0, 0 ]
d352 3
a354 3
        jlo = 1; jhi = nh
          call weight_1d ( heights(:,points(i)%ser(j)), points(i)%h, jlo, jhi, &
                         & w(:,1) )
d359 3
a361 3
          weights(i)%w(2*j-1:2*j)%n = &
            & [ element_position([jlo,points(i)%ser(j)], [nh,nq]), &
              & element_position([jhi,points(i)%ser(j)], [nh,nq]) ]
d364 6
a382 1
    use Array_Stuff, only: Element_Position
d388 1
a388 1
    real(rg), intent(in) :: Heights(:,:)  ! to which to interpolate.  Extents
d400 1
d403 1
d423 3
d427 1
a427 1
          call hunt ( heights(:,s), path_heights(i), index, &             
d431 4
a434 5
        if ( index == 0 ) then !   outside range of Heights(:)
          weights(i)%w(p+3)%n = 0 ! Constant vertical extrapolation
        else if ( index >= size(heights) ) then
          weights(i)%w(p)%n = element_position ( [ points(i)%ser, size(heights,1) ], &
                                               & [ n_QTM, size(heights,1) ] )
d436 1
a436 1
          dH = heights(index+1,s) - heights(index,s)
d438 1
a438 1
            weights(i)%w(p)%n = 0 ! Don't use points other than at Height Index
d440 1
a440 1
            w = ( heights(index+1,s) - path_heights(i) ) / dh
d442 1
a442 2
              weights(i)%w(p)%n = element_position ( [ points(i)%ser, index ], &
                                                   & [ n_QTM, size(heights,1) ] )
d444 1
a444 2
              weights(i)%w(p)%n = element_position ( [ points(i)%ser, index+1 ], &
                                                   & [ n_QTM, size(heights,1) ] )
d446 6
a451 6
              weights(i)%w(3)%v = weights(i)%w(p)%v * ( 1.0_rg - w )
              weights(i)%w(p+3)%v = weights(i)%w(p)%v * w
              weights(i)%w(p)%n = element_position ( [ points(i)%ser, index ], &
                                                   & [ n_QTM, size(heights,1) ] )
              weights(i)%w(p+3)%n = element_position ( [ points(i)%ser, index+1 ], &
                                                     & [ n_QTM, size(heights,1) ] )
a457 1
      weights(i)%n = count ( weights(i)%w%v /= 0 ) 
d459 1
d461 2
a462 1
      weights(i)%w(weights(i)%n+1:6) = value_t(0,0)
a479 1
    use Array_Stuff, only: Element_Position
d484 1
a484 2
    real(rg), intent(in) :: Heights(:)   ! to which to interpolate.  Extents
                                         ! are (heights, QTM_Tree%N_In).
a493 1
    integer :: NQ                        ! Number of QTM vertices
a497 1
    nq = size(QTM_Tree%q)
d517 4
a520 4
          & [ element_position([jlo,points(i)%ser(1)], [nh,nq]), &
            & element_position([jhi,points(i)%ser(1)], [nh,nq]), &
            & element_position([jlo,points(i)%ser(2)], [nh,nq]), &
            & element_position([jhi,points(i)%ser(2)], [nh,nq]), 0, 0 ]
d534 5
a538 6
          & [ element_position([jlo,points(i)%ser(1)], [nh,nq]), &
            & element_position([jhi,points(i)%ser(1)], [nh,nq]), &
            & element_position([jlo,points(i)%ser(2)], [nh,nq]), &
            & element_position([jhi,points(i)%ser(2)], [nh,nq]), &
            & element_position([jlo,points(i)%ser(3)], [nh,nq]), &
            & element_position([jhi,points(i)%ser(3)], [nh,nq]) ]
d540 6
a558 1
    use Array_Stuff, only: Element_Position
d564 1
a564 2
    real(rg), intent(in) :: Heights(:)    ! from which to interpolate.  Extents
                                          ! are (heights, QTM_Tree%N_In).
a572 2
    integer(qk) :: N_QTM ! Number of vertices of QTM within or adjacent to
                         ! the polygon
a574 2
    n_QTM = QTM_Tree%n_in

d582 3
d588 3
a590 3
        weights(i)%w(4:maxCoeff)%n = 0 ! Constant vertical extrapolation
                                       !   outside range of Heights(:)
      else if ( index >= size(heights) ) then
d592 2
a593 2
          weights(i)%w(j)%n = element_position ( [ points(i)%ser, size(heights) ], &
                                               & [ n_QTM, size(heights) ] )
d595 2
a596 2
        weights(i)%w(4:maxCoeff)%n = 0 ! Constant vertical extrapolation
                                       !   outside range of Heights(:)
d604 1
a604 4
            do j = 1, 3
              weights(i)%w(j)%n = element_position ( [ points(i)%ser, index ], &
                                                   & [ n_QTM, size(heights) ] )
            end do
d607 1
a607 4
            do j = 1, 3
              weights(i)%w(j)%n = element_position ( [ points(i)%ser, index+1 ], &
                                                   & [ n_QTM, size(heights) ] )
            end do
d612 3
a614 6
            do j = 1, 3
              weights(i)%w(j)%n = element_position ( [ points(i)%ser, index ], &
                                                   & [ n_QTM, size(heights) ] )
              weights(i)%w(j+3)%n = element_position ( [ points(i)%ser, index+1 ], &
                                                     & [ n_QTM, size(heights) ] )
            end do
d618 1
a618 1
      weights(i)%n = count ( weights(i)%w%v /= 0 ) 
d620 1
d622 2
a623 1
      weights(i)%w(weights(i)%n+1:maxCoeff) = value_t(0,0)
d632 1
a632 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.9 2016/10/25 18:23:48 vsnyder Exp $"
d642 4
@


2.9
log
@Inching toward 3D-QTM forward model support
@
text
@d17 2
a18 1
  use QTM_Interpolation_Weights_m, only: QTM_Interpolation_Weights, Weight_t
d78 2
a79 2
    integer :: N                  ! count(w%weight/=0), <= MaxCoeff
    type(weight_t) :: W(maxCoeff) ! Weights, and array element positions in
d116 1
a116 1
    ! stacked and coherent.  Weights%Which are array element order positions,
d151 2
a152 2
      weights%w(4:6)%which = 0 ! Constant vertical extrapolation outside
                               !   range of Heights(:)
d155 2
a156 2
        weights%w(j)%which = element_position ( [ weights%w(j)%which, size(heights) ], &
                                              & [ n_QTM, size(heights) ] )
d158 2
a159 2
      weights%w(4:6)%which = 0 ! Constant vertical extrapolation outside
                               !   range of Heights(:)
d163 1
a163 1
        weights%w(4:6)%which = 0 ! Don't use points other than at Height Index
d168 2
a169 2
            weights%w(j)%which = element_position ( [ weights%w(j)%which, index ], &
                                                  & [ n_QTM, size(heights) ] )
d171 1
a171 1
          weights%w(4:6)%which = 0 ! Don't use points other than at Height Index
d174 2
a175 2
            weights%w(j)%which = element_position ( [ weights%w(j)%which, index+1 ], &
                                                  & [ n_QTM, size(heights) ] )
d177 1
a177 1
          weights%w(4:6)%which = 0 ! Don't use points other than at Height Index + 1
d179 2
a180 2
          weights%w(4:6)%weight = weights%w(1:3)%weight * ( 1.0_rg - w )
          weights%w(1:3)%weight = weights%w(1:3)%weight * w
d182 4
a185 4
            weights%w(j+3)%which = element_position ( [ weights%w(j)%which, index+1 ], &
                                                    & [ n_QTM, size(heights) ] )
            weights%w(j)%which = element_position ( [ weights%w(j)%which, index ], &
                                                  & [ n_QTM, size(heights) ] )
d190 4
a193 4
    weights%n = count ( weights%w%weight /= 0 ) 
    where ( weights%w%weight == 0 ) weights%w%which = 0
    weights%w = pack ( weights%w,weights%w%which /= 0 )
    weights%w(weights%n+1:) = weight_t(0,0)
d202 1
a202 1
    ! stacked but not necessarily coherent.  Weights%Which are array element
d241 1
a241 1
    weights%w(4:6)%which = 0
d245 1
a245 1
      s = weights%w(p)%which
d254 2
a255 2
        weights%w(p)%which = element_position ( [ weights%w(p)%which, size(heights,1) ], &
                                              & [ n_QTM, size(heights,1) ] )
d259 1
a259 1
          weights%w(4:6)%which = 0 ! Don't use points other than at Height Index
d263 2
a264 2
            weights%w(p)%which = element_position ( [ weights%w(p)%which, index ], &
                                                  & [ n_QTM, size(heights,1) ] )
d266 2
a267 2
            weights%w(p)%which = element_position ( [ weights%w(p)%which, index+1 ], &
                                                  & [ n_QTM, size(heights,1) ] )
d269 6
a274 6
            weights%w(p+3)%weight = weights%w(p)%weight * ( 1.0_rg - w )
            weights%w(p)%weight = weights%w(p)%weight * w
            weights%w(p+3)%which = element_position ( [ weights%w(p)%which, index+1 ], &
                                                    & [ n_QTM, size(heights,1) ] )
            weights%w(p)%which = element_position ( [ weights%w(p)%which, index ], &
                                                  & [ n_QTM, size(heights,1) ] )
d281 4
a284 4
    weights%n = count ( weights%w%weight /= 0 ) 
    where ( weights%w%weight == 0 ) weights%w%which = 0
    weights%w = pack ( weights%w,weights%w%which /= 0 )
    weights%w(weights%n+1:maxCoeff) = weight_t(0,0)
d293 1
a293 1
    ! stacked but not necessarily coherent.  Weights%Which are array element
d343 4
a346 4
        weights(i)%w(1:maxCoeff)%weight = [ w(:,1)*points(i)%coeff(1), &
                                          & w(:,2)*points(i)%coeff(2), &
                                          & 0.0_rg, 0.0_rg ]
        weights(i)%w(1:maxCoeff)%which = &
d362 2
a363 2
          weights(i)%w(2*j-1:2*j)%weight = w(:,1)*points(i)%coeff(j)
          weights(i)%w(2*j-1:2*j)%which = &
d373 1
a373 1
                         & Heights, Points, Weights )
d377 1
a377 1
    ! stacked but not necessarily coherent.  Weights%Which are array element
a382 1
    use Geolocation_0, only: H_V_t
d384 1
a384 1
    use QTM_m, only: QK, Stack_t
d389 4
a392 1
    class(h_v_t), intent(in) :: Points(:) ! same units as for Heights
a400 1
    type(stack_t) :: Stack
d404 2
a405 2
      call QTM_Interpolation_Weights ( QTM_Tree, Heights(:,1), &
                                     & Points, Weights )
d412 2
a413 3
      ! Get horizontal interpolation coefficients and serial numbers
      call QTM_Interpolation_Weights ( QTM_Tree, Points(i), Weights(i)%w(1:3), &
                                     & stack )
d415 1
a415 2
      weights(i)%w(4:6)%which = 0
      ! Get vertical interpolation coefficients
d418 1
a418 1
        s = weights(i)%w(p)%which
d420 2
a421 1
          call hunt ( heights(:,s), points(i)%v, index, &             
d425 5
a429 3
        if ( index >= size(heights) ) then
          weights(i)%w(p)%which = element_position ( [ weights(i)%w(i)%which, size(heights,1) ], &
                                                   & [ n_QTM, size(heights,1) ] )
d433 1
a433 1
            weights(i)%w(p)%which = 0 ! Don't use points other than at Height Index
d435 1
a435 1
            w = ( heights(index+1,p) - points(i)%v ) / dh
d437 2
a438 3
              weights(i)%w(p)%which = element_position ( [ weights(i)%w(p)%which, &
                                                       &   index ], &
                                                       & [ n_QTM, size(heights,1) ] )
d440 2
a441 3
              weights(i)%w(p)%which = element_position ( [ weights(i)%w(p)%which, &
                                                       &   index+1 ], &
                                                       & [ n_QTM, size(heights,1) ] )
d443 6
a448 8
              weights(i)%w(3)%weight = weights(i)%w(p)%weight * ( 1.0_rg - w )
              weights(i)%w(p+3)%weight = weights(i)%w(p)%weight * w
              weights(i)%w(p)%which = element_position ( [ weights(i)%w(p)%which, &
                                                       &   index ], &
                                                       & [ n_QTM, size(heights,1) ] )
              weights(i)%w(p+3)%which = element_position ( [ weights(i)%w(p)%which, &
                                                         &   index+1 ], &
                                                         & [ n_QTM, size(heights,1) ] )
d455 4
a458 4
      weights(i)%n = count ( weights(i)%w%weight /= 0 ) 
      where ( weights(i)%w%weight == 0 ) weights(i)%w%which = 0
      weights(i)%w = pack ( weights(i)%w,weights(i)%w%which /= 0 )
      weights(i)%w(weights(i)%n+1:6) = weight_t(0,0)
d468 1
a468 1
    ! stacked and coherent.  Weights%Which are array element order positions,
d514 3
a516 3
        weights(i)%w(1:6)%weight = [ w*points(i)%coeff(1), &
                                   & w*points(i)%coeff(2), 0.0_rg, 0.0_rg ]
        weights(i)%w(1:6)%which = &
d530 4
a533 4
        weights(i)%w(1:6)%weight = [ w*points(i)%coeff(1), &
                                   & w*points(i)%coeff(2), &
                                   & w*points(i)%coeff(3) ]
        weights(i)%w(1:6)%which = &
d546 1
a546 1
                                                   & Weights )
d550 1
a550 1
    ! stacked and coherent.  Weights%Which are array element order positions,
a555 1
    use Geolocation_0, only: H_V_t
d557 1
a557 1
    use QTM_m, only: QK, Stack_t
d562 4
a565 1
    class(h_v_t), intent(in) :: Points(:) ! Points%V are same units as Heights
a571 1
    type(stack_t) :: Stack
d577 1
a577 1
    call hunt ( heights, points%v, indices, &
d582 2
a583 2
      ! Get horizontal interpolation coefficients and serial numbers
      call QTM_Interpolation_Weights ( QTM_Tree, Points(i), Weights(i)%w(1:3), stack )
d586 2
a587 2
        weights(i)%w(4:maxCoeff)%which = 0 ! Constant vertical extrapolation
                                    !   outside range of Heights(:)
d590 2
a591 3
          weights(i)%w(j)%which = element_position ( [ weights(i)%w(j)%which, &
                                                   &   size(heights) ], &
                                                   & [ n_QTM, size(heights) ] )
d593 2
a594 2
        weights(i)%w(4:maxCoeff)%which = 0 ! Constant vertical extrapolation
                               !   outside range of Heights(:)
d598 1
a598 1
          weights(i)%w(4:6)%which = 0 ! Don't use points other than at Height Index
d600 1
a600 1
          w = ( heights(index+1) - points(i)%v ) / dh
d603 2
a604 3
              weights(i)%w(j)%which = element_position ( [ weights(i)%w(j)%which, &
                                                       &   index ], &
                                                       & [ n_QTM, size(heights) ] )
d606 1
a606 1
            weights(i)%w(4:maxCoeff)%which = 0 ! Don't use points other than at Height Index
d609 2
a610 3
              weights(i)%w(j)%which = element_position ( [ weights(i)%w(j)%which, &
                                                       &   index+1 ], &
                                                       & [ n_QTM, size(heights) ] )
d612 1
a612 1
            weights(i)%w(4:maxCoeff)%which = 0 ! Don't use points other than at Height Index
d614 2
a615 2
            weights(i)%w(4:6)%weight = weights(i)%w(1:3)%weight * ( 1.0_rg - w )
            weights(i)%w(1:3)%weight = weights(i)%w(1:3)%weight * w
d617 4
a620 6
              weights(i)%w(j)%which = element_position ( [ weights(i)%w(j)%which, &
                                                       &   index ], &
                                                       & [ n_QTM, size(heights) ] )
              weights(i)%w(j+3)%which = element_position ( [ weights(i)%w(j)%which, &
                                                         &   index+1 ], &
                                                         & [ n_QTM, size(heights) ] )
d625 4
a628 4
      weights(i)%n = count ( weights(i)%w%weight /= 0 ) 
      where ( weights(i)%w%weight == 0 ) weights(i)%w%which = 0
      weights(i)%w = pack ( weights(i)%w,weights(i)%w%which /= 0 )
      weights(i)%w(weights(i)%n+1:maxCoeff) = weight_t(0,0)
d637 1
a637 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.8 2016/10/18 00:44:28 vsnyder Exp $"
d647 3
@


2.8
log
@Correct some comments
@
text
@d73 11
d90 1
a90 1
  public :: QTM_Interpolation_Weights, Weight_t
d111 1
a111 1
                                              & Weights, N_Weights, Stack, Used )
d115 3
a117 3
    ! stacked and coherent.  The positions are array element order positions,
    ! which can be converted to 2D subscripts (QTM serial number, height)
    ! by the Subscripts function in the Array_Stuff module.
d128 1
a128 2
    type(weight_t), intent(out) :: Weights(6)
    integer :: N_Weights                 ! Number of nonzero weights
d142 1
a142 1
    call QTM_Interpolation_Weights ( QTM_Tree, Point, Weights(1:3), Stack, Used )
d150 2
a151 2
      weights(4:6)%which = 0 ! Constant vertical extrapolation outside
                             !   range of Heights(:)
d154 2
a155 2
        weights(j)%which = element_position ( [ weights(j)%which, size(heights) ], &
                                            & [ n_QTM, size(heights) ] )
d157 2
a158 2
      weights(4:6)%which = 0 ! Constant vertical extrapolation outside
                             !   range of Heights(:)
d162 1
a162 1
        weights(4:6)%which = 0 ! Don't use points other than at Height Index
d167 2
a168 2
            weights(j)%which = element_position ( [ weights(j)%which, index ], &
                                                & [ n_QTM, size(heights) ] )
d170 1
a170 1
          weights(4:6)%which = 0 ! Don't use points other than at Height Index
d173 2
a174 2
            weights(j)%which = element_position ( [ weights(j)%which, index+1 ], &
                                                & [ n_QTM, size(heights) ] )
d176 1
a176 1
          weights(4:6)%which = 0 ! Don't use points other than at Height Index + 1
d178 2
a179 2
          weights(4:6)%weight = weights(1:3)%weight * ( 1.0_rg - w )
          weights(1:3)%weight = weights(1:3)%weight * w
d181 3
a183 1
            weights(j+3)%which = element_position ( [ weights(j)%which, index+1 ], &
a184 2
            weights(j)%which = element_position ( [ weights(j)%which, index ], &
                                                & [ n_QTM, size(heights) ] )
d189 4
a192 4
    n_weights = count ( weights%weight /= 0 ) 
    where ( weights%weight == 0 ) weights%which = 0
    weights = pack ( weights,weights%which /= 0 )
    weights(n_weights+1:6) = weight_t(0,0)
d197 1
a197 1
                                     & Point, Weights, N_Weights, Stack, Used )
d201 1
a201 1
    ! stacked but not necessarily coherent.  The positions are array element
d215 1
a215 2
    type(weight_t), intent(out) :: Weights(6)
    integer :: N_Weights                 ! Number of nonzero weights
d230 1
a230 1
                                & Point, Weights, N_Weights, Stack, Used )
d237 1
a237 1
    call QTM_Interpolation_Weights ( QTM_Tree, Point, Weights(1:3), Stack, Used )
d239 2
d244 1
a244 1
      s = weights(p)%which
a251 2
        weights(4:6)%which = 0 ! Constant vertical extrapolation outside
                               !   range of Heights(:)
d253 2
a254 4
        weights(p)%which = element_position ( [ weights(p)%which, size(heights,1) ], &
          & [ n_QTM, size(heights,1) ] )
        weights(4:6)%which = 0 ! Constant vertical extrapolation outside
                               !   range of Heights(:)
d258 1
a258 1
          weights(4:6)%which = 0 ! Don't use points other than at Height Index
d262 2
a263 3
            weights(p)%which = element_position ( [ weights(p)%which, index ], &
                                                & [ n_QTM, size(heights,1) ] )
            weights(4:6)%which = 0 ! Don't use points other than at Height Index
d265 2
a266 3
            weights(p)%which = element_position ( [ weights(p)%which, index+1 ], &
                                                & [ n_QTM, size(heights,1) ] )
            weights(4:6)%which = 0 ! Don't use points other than at Height Index + 1
d268 5
a272 3
            weights(4:6)%weight = weights(1:3)%weight * ( 1.0_rg - w )
            weights(1:3)%weight = weights(1:3)%weight * w
            weights(p+3)%which = element_position ( [ weights(p)%which, index+1 ], &
a273 2
            weights(p)%which = element_position ( [ weights(p)%which, index ], &
                                                & [ n_QTM, size(heights,1) ] )
d280 4
a283 4
    n_weights = count ( weights%weight /= 0 ) 
    where ( weights%weight == 0 ) weights%which = 0
    weights = pack ( weights,weights%which /= 0 )
    weights(n_weights+1:6) = weight_t(0,0)
d288 1
a288 1
                         & Heights, Line, Points, Weights, N_Weights )
d292 1
a292 1
    ! stacked but not necessarily coherent.  The positions are array element
a302 1
    use Pure_Hunt_m, only: PureHunt
d305 2
a306 4
    real(rg), intent(in) :: Heights(:,:) ! Extents are (heights, QTM_Tree%N_In)
                                         ! Assume Heights and QTM_Tree came from
                                         ! the same Geolocation_t structure
                                         ! (see Geolocation_m).
d310 1
a310 2
    type(weight_t), intent(out) :: Weights(6,size(points))
    integer, intent(out) :: N_Weights(size(points)) ! Number of nonzero weights
d322 1
a322 1
                                     & Line, Points, Weights, N_Weights )
d341 5
a345 5
        n_weights(i) = 4
        weights(1:4,i)%weight = [ w(:,1)*points(i)%coeff(1), &
                                & w(:,2)*points(i)%coeff(2) ]
        weights(5:6,i)%weight = 0
        weights(1:4,i)%which = &
d349 1
a349 2
            & element_position([jhi,points(i)%ser(2)], [nh,nq]) ]
        weights(5:6,i)%which = 0
d351 1
a351 2
        call QTM_interpolation_weights ( QTM_tree, heights, g, weights(:,i), &
                                       & n_weights(i) )
d353 1
a353 6
        ! Don't need height interpolation, but we do need to find the index
        ! in the heights array, because the heights array here might be a
        ! subset of the heights array given to Metrics_3D.
        n_weights(i) = 3
        weights(1:3,i)%weight = points(i)%coeff(1:3)
        weights(4:6,i)%weight = 0
d355 10
a364 4
          call purehunt ( points(i)%h, heights(:,points(i)%ser(j)), &
                        & nh, jlo, jhi )
          weights(j,i)%which = &
            & element_position([jlo,points(i)%ser(j)], [nh,nq])
a365 1
        weights(4:6,i)%which = 0
d372 1
a372 1
                         & Heights, Points, Weights, N_Weights )
d376 3
a378 3
    ! stacked but not necessarily coherent.  The positions are array element
    ! order positions, which can be converted to 2D subscripts (QTM serial
    ! number, height) by the Subscripts function in the Array_Stuff module.
d384 1
a384 1
    use QTM_m, only: QK
d387 4
a390 5
    real(rg), intent(in) :: Heights(:,:) ! Extents are (heights, QTM_Tree%N_In)
                                         ! Assume Heights (meters, zeta) are
    class(h_v_t), intent(in) :: Points(:) !   the same units as for Points%V
    type(weight_t), intent(out) :: Weights(6,size(points))
    integer :: N_Weights(size(points))   ! Number of nonzero weights
d398 1
d403 1
a403 1
                                & Points, Weights, N_Weights )
a408 4
    ! Get horizontal interpolation coefficients and serial numbers
    call QTM_Interpolation_Weights ( QTM_Tree, Points, Weights(1:3,:) )

    ! Get vertical interpolation coefficients
d410 6
d418 1
a418 1
        s = weights(p,i)%which
d420 1
a420 1
          call hunt ( heights(:,s), points(i)%v, index, &
a422 1

d424 3
a426 8
        if ( index == 0 ) then
          weights(4:6,i)%which = 0 ! Constant vertical extrapolation outside
                                   !   range of Heights(:)
        else if ( index >= size(heights) ) then
          weights(p,i)%which = element_position ( [ weights(p,i)%which, size(heights,1) ], &
                                                & [ n_QTM, size(heights,1) ] )
          weights(4:6,i)%which = 0 ! Constant vertical extrapolation outside
                                   !   range of Heights(:)
d430 1
a430 1
            weights(4:6,i)%which = 0 ! Don't use points other than at Height Index
d434 3
a436 3
              weights(p,i)%which = element_position ( [ weights(p,i)%which, index ], &
                                                    & [ n_QTM, size(heights,1) ] )
              weights(4:6,i)%which = 0 ! Don't use points other than at Height Index
d438 3
a440 3
              weights(p,i)%which = element_position ( [ weights(p,i)%which, index+1 ], &
                                                    & [ n_QTM, size(heights,1) ] )
              weights(4:6,i)%which = 0 ! Don't use points other than at Height Index + 1
d442 8
a449 6
              weights(4:6,i)%weight = weights(1:3,i)%weight * ( 1.0_rg - w )
              weights(1:3,i)%weight = weights(1:3,i)%weight * w
              weights(p+3,i)%which = element_position ( [ weights(p,i)%which, index+1 ], &
                                                      & [ n_QTM, size(heights,1) ] )
              weights(p,i)%which = element_position ( [ weights(p,i)%which, index ], &
                                                    & [ n_QTM, size(heights,1) ] )
d456 4
a459 4
      n_weights(i) = count ( weights(:,i)%weight /= 0 ) 
      where ( weights(:,i)%weight == 0 ) weights(:,i)%which = 0
      weights(:,i) = pack ( weights(:,i),weights(:,i)%which /= 0 )
      weights(n_weights(i)+1:6,i) = weight_t(0,0)
d465 1
a465 1
                         & Heights, Line, Points, Weights, N_Weights )
d469 2
a470 2
    ! stacked and coherent.  The positions are array element order positions,
    ! which can be converted to 2D subscripts (QTM serial number, height) by
a479 1
    use Hunt_m, only: PureHunt
d482 2
a483 3
    real(rg), intent(in) :: Heights(:)   ! Assume Heights and QTM_Tree came from
                                         ! the same Geolocation_t structure
                                         ! (see Geolocation_m).
d487 1
a487 2
    type(weight_t), intent(out) :: Weights(6,size(points))
    integer, intent(out) :: N_Weights(size(points)) ! Number of nonzero weights
d490 1
a490 1
    integer :: I, J
d507 1
d512 6
a517 5
        n_weights(i) = 4
        weights(1:4,i)%weight = [ w*points(i)%coeff(1), &
                                & w*points(i)%coeff(2) ]
        weights(5:6,i)%weight = 0
        weights(1:4,i)%which = &
d521 1
a521 2
            & element_position([jhi,points(i)%ser(2)], [nh,nq]) ]
        weights(5:6,i)%which = 0
d523 1
a523 2
        call QTM_interpolation_weights ( QTM_tree, heights, g, weights(:,i), &
                                       & n_weights(i) )
d525 16
a540 12
        ! Don't need height interpolation, but we do need to find the index
        ! in the heights array, because the heights array here might be a
        ! subset of the heights array given to Metrics_3D.
        n_weights(i) = 3
        weights(1:3,i)%weight = points(i)%coeff(1:3)
        weights(4:6,i)%weight = 0
        do j = 1, 3
          call purehunt ( points(i)%h, heights, nh, jlo, jhi )
          weights(j,i)%which = &
            & element_position([jlo,points(i)%ser(j)], [nh,nq])
        end do
        weights(4:6,i)%which = 0
d547 1
a547 1
                                                   & Weights, N_Weights )
d551 2
a552 2
    ! stacked and coherent.  The positions are array element order positions,
    ! which can be converted to 2D subscripts (QTM serial number, height)
d559 1
a559 1
    use QTM_m, only: QK
d562 4
a565 4
    real(rg), intent(in) :: Heights(:)    ! Assume Heights (meters, zeta) are
    class(h_v_t), intent(in) :: Points(:) !   the same units as for Points%V
    type(weight_t), intent(out) :: Weights(6,size(points))
    integer :: N_Weights(size(points))    ! Number of nonzero weights
d571 1
d576 1
a576 4
    ! Get horizontal interpolation coefficients and serial numbers
    call QTM_Interpolation_Weights ( QTM_Tree, Points, Weights(1:3,:) )

    ! Get vertical interpolation coefficients
d582 2
d586 2
a587 2
        weights(4:6,i)%which = 0 ! Constant vertical extrapolation outside
                               !   range of Heights(:)
d590 3
a592 2
          weights(j,i)%which = element_position ( [ weights(j,i)%which, size(heights) ], &
            & [ n_QTM, size(heights) ] )
d594 2
a595 2
        weights(4:6,i)%which = 0 ! Constant vertical extrapolation outside
                               !   range of Heights(:)
d599 1
a599 1
          weights(4:6,i)%which = 0 ! Don't use points other than at Height Index
d604 3
a606 2
              weights(j,i)%which = element_position ( [ weights(j,i)%which, index ], &
                                                    & [ n_QTM, size(heights) ] )
d608 1
a608 1
            weights(4:6,i)%which = 0 ! Don't use points other than at Height Index
d611 3
a613 2
              weights(j,i)%which = element_position ( [ weights(j,i)%which, index+1 ], &
                                                    & [ n_QTM, size(heights) ] )
d615 1
a615 1
            weights(4:6,i)%which = 0 ! Don't use points other than at Height Index + 1
d617 2
a618 2
            weights(4:6,i)%weight = weights(1:3,i)%weight * ( 1.0_rg - w )
            weights(1:3,i)%weight = weights(1:3,i)%weight * w
d620 6
a625 4
              weights(j,i+3)%which = element_position ( [ weights(j,i)%which, index+1 ], &
                                                      & [ n_QTM, size(heights) ] )
              weights(j,i)%which = element_position ( [ weights(j,i)%which, index ], &
                                                    & [ n_QTM, size(heights) ] )
d630 4
a633 4
      n_weights(i) = count ( weights(:,i)%weight /= 0 ) 
      where ( weights(:,i)%weight == 0 ) weights(:,i)%which = 0
      weights(:,i) = pack ( weights(:,i),weights(:,i)%which /= 0 )
      weights(n_weights(i)+1:6,i) = weight_t(0,0)
d642 1
a642 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.7 2016/10/05 23:28:22 vsnyder Exp $"
d652 3
@


2.7
log
@Replace ZOT_n component name with Ser because it's a serial number for
more than just the ZOT coordinates.
@
text
@d45 3
a47 3
                     ! Inside_Prism => The intersection is not with a face of a
                     !      prism resting on the surface QTM; it is inside a
                     !      prism resting on the surface QTM.
d61 9
a69 5
    integer :: H_ind = 0 ! Index in height grid.  If the intersection is not
                     ! with a horizontal boundary within the QTM, H_Ind is the
                     ! index of the next lower height surface.
    integer :: N_Coeff = 0  ! How many elements of Coeff and Ser are used.
    integer :: Ser(3) = 0   ! Serial numbers of coordinates, see QTM_Node_t
d639 1
a639 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.6 2016/09/14 20:46:21 vsnyder Exp $"
d649 4
@


2.6
log
@Add H_Ind component, move Weight_1D to Weight_1D_m
@
text
@d51 1
a51 1
                     ! line intersects.  The coordinates indexed by ZOT_N are
d64 2
a65 2
    integer :: N_Coeff = 0  ! How many elements of Coeff and ZOT_N are used.
    integer :: ZOT_N(3) = 0 ! Serial numbers of ZOT coordinates, see QTM_Node_t
d332 2
a333 2
        call weight_1d ( heights(:,points(i)%ZOT_n(1)), g%v, jlo, jhi, w(:,1) )
        call weight_1d ( heights(:,points(i)%ZOT_n(2)), g%v, jlo, jhi, w(:,2) )
d341 4
a344 4
          & [ element_position([jlo,points(i)%ZOT_n(1)], [nh,nq]), &
            & element_position([jhi,points(i)%ZOT_n(1)], [nh,nq]), &
            & element_position([jlo,points(i)%ZOT_n(2)], [nh,nq]), &
            & element_position([jhi,points(i)%ZOT_n(2)], [nh,nq]) ]
d357 1
a357 1
          call purehunt ( points(i)%h, heights(:,points(i)%ZOT_n(j)), &
d360 1
a360 1
            & element_position([jlo,points(i)%ZOT_n(j)], [nh,nq])
d518 4
a521 4
          & [ element_position([jlo,points(i)%ZOT_n(1)], [nh,nq]), &
            & element_position([jhi,points(i)%ZOT_n(1)], [nh,nq]), &
            & element_position([jlo,points(i)%ZOT_n(2)], [nh,nq]), &
            & element_position([jhi,points(i)%ZOT_n(2)], [nh,nq]) ]
d536 1
a536 1
            & element_position([jlo,points(i)%ZOT_n(j)], [nh,nq])
d635 1
a635 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.5 2016/04/28 23:09:50 vsnyder Exp $"
d645 3
@


2.5
log
@Interpret negative face number as the index of the face intersected by a
line segment outside the QTM.  Alphabetize components of S_QTM_t.
@
text
@d18 1
d61 3
d294 1
a630 15
!  =====     Private Procedures     ====================================

  subroutine Weight_1D ( Heights, Height, Jlo, Jhi, Weights )
    ! Interpolate Height in Heights to calculate Weight
    use Hunt_m, only: PureHunt
    real(rg), intent(in) :: Heights(:)  ! Array in which to interpolate
    real(rg), intent(in) :: Height      ! Value to which to interpolate
    integer, intent(inout) :: Jlo, Jhi  ! Which array elements used
    real(rg), intent(out) :: Weights(2) ! Interpolation coefficients
    call purehunt ( height, heights, size(heights), jlo, jhi )
    weights(1) = ( heights(jhi) - height ) / &
               & ( heights(jhi) - heights(jlo) )
    weights(2) = 1 - weights(1)
  end subroutine Weight_1D

d635 1
a635 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.4 2016/04/16 02:04:06 vsnyder Exp $"
d645 4
@


2.4
log
@Add S_QTM_t, routines for using positions on a line
@
text
@a35 5
    integer :: Facet = 0 ! Index in Grid%QTM_Tree of QTM facet intersected at
                     ! the point.
    real(rg) :: H    ! Height at which the point intersects a face.  This is
                     ! the height where the extrapolated line intersects a face
                     ! of the QTM for points outside the QTM.
d47 2
a48 1
                     ! If the point is outside the QTM, this will not be
d50 10
a59 1
                     ! line intersects.
d65 1
a65 1
  integer, parameter, public :: Cone_Face = 0
d322 1
a322 1
      select case ( points(i)%face )
d500 1
a500 1
      select case ( points(i)%face )
d645 1
a645 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.3 2016/03/30 01:42:02 vsnyder Exp $"
d655 3
@


2.3
log
@Detect and exploit coherent heights in incoherent routine
@
text
@d16 1
d26 40
d72 1
d74 1
d97 1
a97 1
    use Geolocation_0, only: H_t, H_V_t, RG
d184 1
a184 1
    use Geolocation_0, only: H_t, H_V_t, RG
d269 89
d369 1
a369 1
    use Geolocation_0, only: H_V_t, RG
d378 1
a378 1
    integer :: N_Weights                 ! Number of nonzero weights
d445 1
a445 1
      n_weights = count ( weights(:,i)%weight /= 0 ) 
d448 1
a448 1
      weights(n_weights+1:6,i) = weight_t(0,0)
d453 81
d545 1
a545 1
    use Geolocation_0, only: H_V_t, RG
d553 1
a553 1
    integer :: N_Weights                  ! Number of nonzero weights
d613 1
a613 1
      n_weights = count ( weights(:,i)%weight /= 0 ) 
d616 1
a616 1
      weights(n_weights+1:6,i) = weight_t(0,0)
d621 15
d640 1
a640 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.2 2016/01/26 02:30:32 vsnyder Exp $"
d650 3
@


2.2
log
@Add QTM_Interpolation_Weights_Geo_3D_Incoherent_List to generic
QTM_Interpolation_Weights.
@
text
@d135 3
a137 3
    ! stacked and coherent.  The positions are array element order positions,
    ! which can be converted to 2D subscripts (QTM serial number, height)
    ! by the Subscripts function in the Array_Stuff module.
d163 6
d231 3
a233 3
    ! stacked and coherent.  The positions are array element order positions,
    ! which can be converted to 2D subscripts (QTM serial number, height)
    ! by the Subscripts function in the Array_Stuff module.
d256 6
d412 1
a412 1
       "$Id: QTM_Interpolation_Weights_3D_m.f90,v 2.1 2015/12/31 00:56:47 vsnyder Exp $"
d422 4
@


2.1
log
@Initial commit
@
text
@d30 2
d37 1
a37 1
       "$RCSfile: QTM_Interpolation_Weights_m.f90,v $"
d89 1
a89 1
          & [ n_QTM, size(heights) ] )
d102 1
a102 1
              & [ n_QTM, size(heights) ] )
d108 1
a108 1
              & [ n_QTM, size(heights) ] )
d116 1
a116 1
              & [ n_QTM, size(heights) ] )
d118 1
a118 1
              & [ n_QTM, size(heights) ] )
d130 179
d326 1
a326 1
    class(h_v_t), intent(in) :: Points(:) !   the same units as for Point%V
d367 1
a367 1
                & [ n_QTM, size(heights) ] )
d373 1
a373 1
                & [ n_QTM, size(heights) ] )
d381 1
a381 1
                & [ n_QTM, size(heights) ] )
d383 1
a383 1
                & [ n_QTM, size(heights) ] )
d392 1
a392 1
    end do
d400 1
a400 1
       "$Id: QTM_Interpolation_Weights_m.f90,v 2.1 2015/12/31 00:05:02 vsnyder Exp $"
d409 4
a412 1
! $Log: QTM_Interpolation_Weights_m.f90,v $
@

