head	1.9;
access;
symbols;
locks; strict;
comment	@# @;


1.9
date	2000.01.11.22.51.35;	author livesey;	state dead;
branches;
next	1.8;

1.8
date	2000.01.07.23.53.35;	author livesey;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.07.19.30.04;	author lungu;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.06.23.39.00;	author lungu;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.06.02.37.22;	author lungu;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.04.19.46.23;	author lungu;	state Exp;
branches;
next	1.3;

1.3
date	99.12.27.23.45.02;	author lungu;	state Exp;
branches;
next	1.2;

1.2
date	99.12.22.23.27.30;	author lungu;	state Exp;
branches;
next	1.1;

1.1
date	99.12.17.01.00.27;	author lungu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Dealt with ramifications of change from read_parse_l2cf to MLSCF
@
text
@

! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.


!=============================================================================
MODULE ReadParseL2cf         ! Read and Parse the l2 Configuration File
!=============================================================================

USE SDPToolkit
USE Hdf
USE MLSMessageModule
USE MLSStrings


IMPLICIT NONE
PUBLIC


PRIVATE :: Id, ModuleName


!------------------- RCS Ident Info -----------------------
CHARACTER(LEN=130) :: Id = &                                                    
"$Id: read_parse_l2cf.f90,v 1.8 2000/01/07 23:53:35 livesey Exp $"
CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: read_parse_l2cf.f90,v $"
!----------------------------------------------------------
 
INTEGER, PARAMETER :: MaxKeyLen = 25
INTEGER, PARAMETER :: MaxTypeLen = 6
INTEGER, PARAMETER :: MaxNOL2cfKeys = 20
INTEGER, PARAMETER :: MaxCharValueLen =25
INTEGER, PARAMETER :: UnitsLen = 10
INTEGER, PARAMETER :: L2cfEntryLen = 25
INTEGER, PARAMETER :: MaxNoKeysPerEntry = 10
INTEGER, PARAMETER :: MaxNoEntriesPerSection = 15

TYPE l2cfKey
  CHARACTER (len=MaxKeyLen) :: Keyword
  CHARACTER (len=MaxTypeLen):: TYPE
  INTEGER :: Keylen
END TYPE l2cfKey



TYPE L2cfCell

   ! This datatype defines a L2cf "cell", i.e. a contruction of type:
   ! "keyword=value" or "keyword=LowerBound..UpperBound[units]"

   ! First the "keyword" holder:

   CHARACTER (len=MaxKeyLen) :: Keyword
   ! Value holder for "real" type

   DOUBLE PRECISION :: RealValue

   ! Value holder for integer type

   INTEGER :: IntValue

   ! Value holder for "character" type

   CHARACTER (len= MaxCharValueLen) :: CharValue

   ! Value holder for "units" field

   CHARACTER (len=UnitsLen) :: Units

   ! Value holder for upper and lower bounds fields

   DOUBLE PRECISION :: RangeLowerBound
   DOUBLE PRECISION :: RangeUpperBound


END TYPE L2cfCell


TYPE L2cfEntry

   ! This datatype defines am L2cf entry, i.e. a name followed by
   ! a list of "keyword=value" cells
 
   ! Entry name, e.g. aprioriTemp

   CHARACTER (len=L2cfEntryLen) L2cfEntryName

   ! Number of "keyword=value" cells

   INTEGER L2cfEntryNoKeys

   !Cells holder 

   TYPE (L2cfCell), DIMENSION(MaxNoKeysPerEntry) :: Cells

END TYPE L2cfEntry


TYPE L2cfSection


   ! For each section:
   ! Name, Number of entries within section
   CHARACTER (len=L2cfEntryLen) L2cfSectionName
   INTEGER NoSectionEntries

   ! The actual entries:

   TYPE (L2cfEntry), DIMENSION(MaxNoEntriesPerSection) :: Entries ! (NoSectionEntries)


END TYPE L2cfSection




TYPE L2cf

! This datatype defines the l2cf as an array of L2cfSections

  INTEGER NoSections

  TYPE (L2cfSection), POINTER, DIMENSION (:) :: Sections ! (NoSections) 

END TYPE l2cf



! --------------------------------------------------------------------------

CONTAINS


! This function extracts a named section from the l2cf

!========================================
FUNCTION GetL2CFSection(l2cfInfo,sectionName)
!========================================

  ! Dummy arguments
  TYPE (l2cf), INTENT(IN) :: l2cfInfo
  CHARACTER (LEN=*), INTENT(IN) :: sectionName

  ! Function result
  TYPE (l2cfSection) :: GetL2CFSection

  ! Local variables
  INTEGER :: index

  ! Executable code

  index=LinearSearchStringArray(l2cfInfo%sections%l2cfSectionName,sectionName,&
       & caseInsensitive=.TRUE.)
  IF (index==0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
       & "No such l2cf section:"//sectionName)

  GetL2CFSection=l2cfInfo%sections(index)
END FUNCTION GetL2CFSection
  
!========================================
SUBROUTINE Strip_Blanks (line, nc, ncnb)
!========================================
 

CHARACTER (LEN=*) :: line
INTEGER :: nc, ncnb
INTEGER :: i, ncc

LOGICAL :: done = .FALSE.

ncc = nc

! check for blank line
line = TRIM(line)
IF (LEN(line) .EQ.  0)THEN
  ncnb = 0
  RETURN
END IF


! ignore trailing comments

i= INDEX(line, ';')
IF(  i /= 0)THEN
  ncc = i-1
END IF

! replace double blanks by single ones

DO WHILE (.NOT. done)
  i = INDEX(line(1:ncc), '  ')
  IF (i .EQ. 0)THEN
    done =.TRUE.
    ncnb = ncc
  ELSE 
    line(i:ncc-1)= line (i+1:ncc)
    ncc = ncc-1
  END IF
END DO

RETURN
END SUBROUTINE Strip_Blanks


!===================================
SUBROUTINE read_parse_l2cf (L2CFUnit, L2cf_data) 
!===================================

! This subroutine reads and parses L2CF and does some preliminary checking on 
! tokens.

! Arguments

INTEGER, INTENT (IN):: L2CFUnit 
TYPE (l2cf), INTENT (OUT) :: L2cf_data






! Parameters


CHARACTER (LEN=*), PARAMETER :: lineFmt = "(q,<nc>a1)"



! Functions


! Variables

INTEGER ::  returnStatus

TYPE (l2cfKey), DIMENSION(MaxNoL2cfKeys) :: L2cfTable

CHARACTER (LEN=256) :: line
CHARACTER (LEN=256) :: msg
CHARACTER (LEN=2048) :: buff
CHARACTER (LEN=L2cfEntryLen) :: mnemonic, section, AnEntry
CHARACTER (LEN=maxKeyLen) :: key
CHARACTER (LEN=MaxCharValueLen)Value
INTEGER :: nc, ncnb, ncb, version, isection, i, ib, ie, igs, ios, j, k, processL2CF
INTEGER :: CellIndex, ValueLen, keyLen
REAL :: tmp
LOGICAL :: eof = .FALSE.
LOGICAL :: found = .FALSE.
LOGICAL :: flag_section = .FALSE.

L2cfTable(1)%Keyword = 'InputVersionString       '
L2cfTable(1)%Type = 'string'
L2cfTable(1)%Keylen =  18
L2cfTable(2)%Keyword = 'OutputVersionString      '
L2cfTable(2)%Type = 'string'
L2cfTable(2)%Keylen =  19
L2cfTable(3)%Keyword = 'AllowClimatologyOverloads'
L2cfTable(3)%Type = 'string'
L2cfTable(3)%Keylen =  25
L2cfTable(4)%Keyword = 'source                   '
L2cfTable(4)%Type = 'string'
L2cfTable(4)%Keylen =  6
L2cfTable(5)%Keyword = 'length                   '
L2cfTable(5)%Type = 'real  '
L2cfTable(5)%Keylen =  6
L2cfTable(6)%Keyword = 'versionRange             '
L2cfTable(6)%Type = 'string'
L2cfTable(6)%Keylen =  12
L2cfTable(7)%Keyword = 'species                  '
L2cfTable(7)%Type = 'string'
L2cfTable(7)%Keylen =  7
L2cfTable(8)%Keyword = 'range                    '
L2cfTable(8)%Type = 'range '
L2cfTable(8)%Keylen =  5
L2cfTable(9)%Keyword = 'method                   '
L2cfTable(9)%Type = 'string'
L2cfTable(9)%Keylen =  6
L2cfTable(10)%Keyword = 'scale                    '
L2cfTable(10)%Type = 'real  '
L2cfTable(10)%Keylen =  5
L2cfTable(11)%Keyword ='height                   '
L2cfTable(11)%Type ='real  '
L2cfTable(11)%Keylen = 6
L2cfTable(12)%Keyword ='Overlap                  '
L2cfTable(12)%Type ='int   '
L2cfTable(12)%Keylen = 7
L2cfTable(13)%Keyword ='IdealLength              '
L2cfTable(13)%Type ='real  '
L2cfTable(13)%Keylen = 11
L2cfTable(14)%Keyword ='HomeLatitude             '
L2cfTable(14)%Type ='real  '
L2cfTable(14)%Keylen = 12
L2cfTable(15)%Keyword ='CriticalScanningModules  '
L2cfTable(15)%Type ='string'
L2cfTable(15)%Keylen = 23
L2cfTable(16)%Keyword ='CriticalBands            '
L2cfTable(16)%Type = 'string'
L2cfTable(16)%Keylen = 13
L2cfTable(17)%Keyword ='MaxGap                   '
L2cfTable(17)%Type ='real  '
L2cfTable(17)%Keylen = 6
L2cfTable(18)%Keyword = 'type                    '
L2cfTable(18)%Type ='string' 
L2cfTable(18)%Keylen = 4
L2cfTable(19)%Keyword ='fraction                 '
L2cfTable(19)%Type ='real  '
L2cfTable(19)%Keylen = 8
L2cfTable(20)%Keyword ='interpolationfactor      '
L2cfTable(20)%Type ='real  '
L2cfTable(20)%Keylen = 19

version = 1
isection = 0
igs=0
! Open the L2CF as a generic file for reading

returnStatus = Pgs_io_gen_openF (L2CFUnit, PGSd_IO_Gen_RSeqFrm, 0, &
                                processL2CF, version)

IF (returnStatus /= PGS_S_SUCCESS) THEN

  CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
  CALL MLSMessage (MLSMSG_Error, &
                  ModuleName, "Error opening L2CF:  "//mnemonic//" "//msg)

ENDIF

! Read  input
DO WHILE (.NOT. eof)

  READ(UNIT=processL2CF, IOSTAT=ios, FMT=lineFmt) nc, line
  IF (ios .eq. 0) THEN

! strip leading, trailing and multiple blanks from line
 
    CALL Strip_Blanks(line, nc, ncnb)

    IF (INDEX(line, 'BEGIN' ) /= 0 ) THEN
! Is this a BEGIN Section Line?
       isection = isection + 1
       section(1:) = line (7:ncnb)
       flag_section =.false.
    ELSE IF (isection .eq. 0 .and. ncnb .gt. 0)Then
! If not and there was no BEGIN before and this is not a comment line, log error and exit
        CALL MLSMessage (MLSMSG_Error, ModuleName, 'Missing BEGIN')
     
    END IF

    ib = 1
    READ(UNIT=processL2CF, IOSTAT=ios, FMT=lineFmt) nc, line
    
    IF (ios .eq.  0) THEN

      CALL Strip_Blanks(line, nc, ncnb)

! ignore comment lines

      IF(INDEX(line, ';' ) /= 1) THEN

        IF(INDEX(line, 'END') /= 1) THEN

          buff(ib:ib+ncnb-1) = line(1:ncnb)
          ib = ib + ncnb

! copy continuation lines into buff

          DO WHILE (line(ncnb:ncnb) .eq. '$')
            ib = ib- 1

            READ(UNIT=processL2CF, IOSTAT=ios, FMT=lineFmt) nc, line
            IF (ios /= 0) THEN

              CALL Strip_Blanks(line, nc, ncnb)
              buff(ib:ib+ncnb-1) = line(1:ncnb)
              ib = ib+ncnb
            ELSE
              eof = .TRUE.
            END IF

          END DO
          ncb = ib

! Proces l2cf entry

          AnEntry(1:L2cfEntryLen) =' '
          ib = INDEX(buff, ',')

          IF (ib .eq.  0) THEN
            CALL MLSMessage (MLSMSG_Error, ModuleName, "Comma expected, : "//buff(1:ncb))
          END IF          

          AnEntry(1:ib-1)=buff(1:ib-1)
          ib = ib + 1
          igs = igs + 1
          L2cf_data%Sections(isection)%Entries(igs)%L2cfEntryName = AnEntry
          CellIndex = 1

! Process keyword = value pairs

          DO WHILE (ib < ncb)
            ie = INDEX(buff(ib:ncb), '=')

            IF (ie .eq. 0) THEN
              CALL MLSMessage (MLSMSG_Error, ModuleName, "= expected, : "//buff(1:ncb))
            END IF
 
            key(1:maxKeyLen) = ' '
            Key = buff(ib: ie-1) 
            keyLen = ie-ib
            ib = ie + 1
            ie = INDEX(buff(ib:ncb), ',')

            IF (ie .eq. 0) THEN
              CALL MLSMessage (MLSMSG_Error, ModuleName, "Comma expected, : "//buff(ib:ncb))
            END IF 

            Value (1:MaxCharValueLen) = ' '
            Value = buff(ib: ie-1)
            ValueLen = ie-ib
            ib = ie + 1

            found = .FALSE.
            i = 1

            DO WHILE ((.NOT. found) .AND. (i <= MaxNoL2cfKeys))

              IF(key(1:KeyLen) .EQ. l2cfTable(i)%Keyword(1:l2cfTable(i)%Keylen))THEN
                found = .TRUE.
              ELSE
                i = i + 1
              END IF
            END DO

            IF(found) THEN

                
               L2cf_data%Sections(isection)%Entries(igs)%L2cfEntryNoKeys = &
               L2cf_data%Sections(isection)%Entries(igs)%L2cfEntryNoKeys + 1
               L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%Keyword= Key(1:Keylen)

               IF(l2cfTable(i)%Type .eq. 'real')THEN
                 j = 1     
                 DO WHILE((j <= ValueLen) .and. (Value(j:j) /= ' '))
                   j = j + 1
                 END DO
                 READ (unit=Value(1:j-1), fmt=*)L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RealValue
                 L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%units=Value(j:ValueLen)
               ELSE IF(l2cfTable(i)%Type .eq. 'int')THEN
                 j = 1     
                 DO WHILE((j <= ValueLen) .AND. (Value(j:j) /= ' '))
                   j = j + 1
                 END DO
                 READ (unit=Value(1:j-1), fmt=*)L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%IntValue
                 L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%units=Value(j:ValueLen)
               ELSE IF(l2cfTable(i)%Type .eq. 'range')THEN
                 j = INDEX(Value, '..')
                 IF (j > 0)THEN
                   READ (unit=Value(1:j-1), fmt=*) &
                   L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RangeLowerBound
                   k=j+2

                   DO WHILE((k <= ValueLen) .AND. (Value(k:k) /= ' '))
                    k = k + 1
                   END DO  
            
                   READ (unit=Value(1:j-1), fmt=*) &
                   L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RangeUpperBound
                   L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%units=Value(k:ValueLen)

                   IF(L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RangeUpperBound < &
                      L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RangeUpperBound)THEN

                     tmp = L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RangeUpperBound
                     L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RangeUpperBound = &
                     L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RangeLowerBound
                     L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RangeLowerBound = tmp

                   END IF ! (L2cf_data%Sections(isection)%Entries
                 ELSE
                   CALL MLSMessage (MLSMSG_Error, ModuleName, "Range expected, : "//Value)
                 END IF ! (j > 0)

               ELSE IF(l2cfTable(i)%Type .EQ. 'string')THEN

                 j = INDEX(Value, '"')
                 IF(j > 0)THEN
                   k = INDEX(Value(j+1:ValueLen), '"')
                   IF(k > 0)THEN
                      L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%CharValue=Value(j:k)
                   ELSE
                     CALL MLSMessage (MLSMSG_Error, ModuleName, "Quote expected, : "//Value(1:ValueLen))
                   END IF
                 ELSE
                   CALL MLSMessage (MLSMSG_Error, ModuleName, "Quote expected, : "//Value(1:ValueLen))
                 END IF ! j > 0
    
               END IF ! l2cfTable(i)%Type

            ELSE            
              CALL MLSMessage (MLSMSG_Error, ModuleName, "Illegal Keyword : " //key(1:KeyLen))
            END IF ! (found)                      
            CellIndex = CellIndex + 1  
          END DO ! ib < ncb
          igs = igs + 1
        ELSE
          if (  L2cf_data%Sections(isection)%Entries(igs)%L2cfEntryName .ne. line(5:ncnb))THEN
             CALL MLSMessage (MLSMSG_Warning, ModuleName, "BEGIN and END Section Names don't match " // &
                              L2cf_data%Sections(isection)%Entries(igs)%L2cfEntryName//' , '//line(5:ncnb))
          end if
          isection = isection + 1
          flag_section = .true.
! Check whether END Section matches BEGIN
        END IF !INDEX(line, 'END') /= 1  
      ELSE
        eof = .TRUE.
      END IF ! (INDEX(line, ';' ) /= 1)
    ELSE

      eof = .true.
      if(.not. flag_section) then
        CALL MLSMessage (MLSMSG_Warning, ModuleName, 'Premature EOF encountered')
      end if
    END IF ! (ios .eq.  0)

  ELSE

    eof = .true.
    if(.not. flag_section) then
       CALL MLSMessage (MLSMSG_Warning, ModuleName, 'Premature EOF encountered')
    end if
  END IF ! (ios .eq.  0)
 

END DO ! (.not. eof)

! Close L2CF

returnStatus = Pgs_io_gen_closeF (processL2CF)

IF (returnStatus /= PGS_S_SUCCESS) THEN
  CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
  CALL MLSMessage (MLSMSG_Error, ModuleName, 'Error closing L2CF:  '//mnemonic//' '//msg)
 
ENDIF




!==============================
END SUBROUTINE  read_parse_l2cf
!==============================

!=======================
END MODULE ReadParseL2cf
!=======================

! $Log: read_parse_l2cf.f90,v $
! Revision 1.8  2000/01/07 23:53:35  livesey
! Nearly integrated, just a few tweaks.
!
! Revision 1.7  2000/01/07 19:30:04  lungu
! Revoved returnStatus from argument list.
!
! Revision 1.6  2000/01/06 23:39:00  lungu
! Finalized error handling.
!
! Revision 1.5  2000/01/06 02:37:22  lungu
! Made a module out of read_parse_l2cf, strip_blanks and data structures.
!
! Revision 1.4  2000/01/04 19:46:23  lungu
! Changed error handling using MLSMessage
!
@


1.8
log
@Nearly integrated, just a few tweaks.
@
text
@d26 1
a26 1
"$Id: read_parse_l2cf.f90,v 1.7 2000/01/07 19:30:04 lungu Exp $"
d559 3
@


1.7
log
@Revoved returnStatus from argument list.
@
text
@d14 1
d26 1
a26 1
"$Id: read_parse_l2cf.f90,v 1.6 2000/01/06 23:39:00 lungu Exp $"
d135 26
d559 3
@


1.6
log
@Finalized error handling.
@
text
@d25 1
a25 1
"$Id: read_parse_l2cf.f90,v 1.5 2000/01/06 02:37:22 lungu Exp $"
d180 1
a180 1
SUBROUTINE read_parse_l2cf (L2CFUnit, L2cf_data, returnStatus) 
a189 1
INTEGER, INTENT (OUT) ::  returnStatus
d191 2
a192 1
TYPE (l2cfKey), DIMENSION(MaxNoL2cfKeys) :: L2cfTable
a204 1
INTEGER, EXTERNAL :: Pgs_io_gen_openF, Pgs_io_gen_closeF
d208 3
d532 3
@


1.5
log
@Made a module out of read_parse_l2cf, strip_blanks and data structures.
@
text
@d1 2
d10 6
a15 1
  
d19 1
d25 1
a25 1
"$Id: read_parse_l2cf.f90,v 1.4 2000/01/04 19:46:23 lungu Exp $"
d29 14
a42 14
integer, parameter :: MaxKeyLen = 25
integer, parameter :: MaxTypeLen = 6
integer, parameter :: MaxNOL2cfKeys = 20
integer, parameter :: MaxCharValueLen =25
integer, parameter :: UnitsLen = 10
integer, parameter :: L2cfEntryLen = 25
integer, parameter :: MaxNoKeysPerEntry = 10
integer, parameter :: MaxNoEntriesPerSection = 15

type l2cfKey
  character (len=MaxKeyLen) :: Keyword
  character (len=MaxTypeLen):: Type
  integer :: Keylen
end type l2cfKey
d148 2
a149 2
CALL TRIM(line)
IF (LEN(line) .eq.  0)THEN
d166 1
a166 1
  IF (i .eq. 0)THEN
d180 1
a180 1
SUBROUTINE read_parse_l2cf (L2cf_data, returnStatus) 
d188 1
d190 1
d192 1
a192 1
type (l2cfKey), dimension(MaxNoL2cfKeys) :: L2cfTable
d201 1
a201 1
INTEGER, PARAMETER :: L2CFUnit = 3000
d213 6
a218 5



INTEGER :: nc, returnStatus, version, isection, igs

d220 2
d272 1
a272 1
L2cfTable(17)%Type = 'real  '
d277 1
a277 1
L2cfTable(19)%Keyword = 'fraction                 '
d280 1
a280 1
L2cfTable(20)%Keyword = 'interpolationfactor      '
d289 1
a289 1
returnStatus = Pgs_io_gen_openF (L2CF, PGSd_IO_Gen_RSeqFrm, 0, &
d295 1
a295 1
  CALL MSMessage (MLSMSG_Error, &
d304 1
a304 1
  IF (ios /= 0) THEN
d310 2
a311 1
    IF (INDEX(line, 'BEGIN') /= 0) THEN
d314 5
d323 2
a324 1
    IF (ios /= 0) THEN
d339 1
a339 1
          DO WHILE (line(ncnb:ncnb) = '$')
d360 2
a361 2
          IF (ib = 0) THEN
            CALL MSMessage (MLSMSG_Error, ModuleName, "Comma expected, : "//buff(1:ncb))
d367 1
a367 1
          L2cf_data%Sections(isection)%Section(igs)%L2cfEntryName = AnEntry
d375 2
a376 2
            IF (ie = 0) THEN
              CALL MSMessage (MLSMSG_Error, ModuleName, "= expected, : "//buff(1:ncb))
d380 1
a380 1
            Key = buff(ib, ie-1) 
d385 2
a386 2
            IF (ie = 0) THEN
              CALL MSMessage (MLSMSG_Error, ModuleName, "Comma expected, : "//buff(ib:ncb))
d390 1
a390 1
            Value = buff(ib, ie-1)
d410 1
a410 1
               L2cf_data%Section(isection)%Entries(igs)%L2cfEntryNoKeys + 1
d413 1
a413 1
               IF(l2cfTable(i)%Type = "real")THEN
d415 1
a415 1
                 DO WHILE((j <= ValueLen) = (Value(j:j) /= ' '))
d418 1
a418 1
                 READ (unit=Value(1:j-1), fmt='*') L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RealValue
d420 1
a420 1
               ELSE IF(l2cfTable(i)%Type = "int")THEN
d425 1
a425 1
                 READ (unit=Value(1:j-1), fmt='*') L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%IntValue
d427 1
a427 1
               ELSE IF(l2cfTable(i)%Type = "range")THEN
d430 1
a430 1
                   READ (unit=Value(1:j-1), fmt='*') &
d433 1
d436 3
a438 2
                   END DO              
                   READ (unit=Value(1:j-1), fmt='*') &
d446 1
a446 1
                     L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RangeUpperBound = 
d450 1
a450 1
                   END IF
d452 2
a453 2
                   CALL MSMessage (MLSMSG_Error, ModuleName, "Range expected, : "//Value
                 END IF
d459 1
a459 1
                   k = INDEX(Value(j+1:ValueLen)
d463 1
a463 1
                     CALL MSMessage (MLSMSG_Error, ModuleName, "Quote expected, : "//Value(1:ValueLen))
d466 2
a467 2
                   CALL MSMessage (MLSMSG_Error, ModuleName, "Quote expected, : "//Value(1:ValueLen))
                 END IF
d469 15
a483 6
               END IF
               
                                  
               
         END DO
       ELSE
d485 20
a504 4
       END IF  
     ELSE
       eof = .TRUE.
     END IF
d506 1
a506 5
   END IF
  END IF
 END IF

END DO
d514 1
a514 1
  CALL MSMessage (MLSMSG_Error, ModuleName, 'Error closing L2CF:  ', mnemonic//' '//msg)
d530 3
d534 1
a534 1
! Changed error handling using MSMessage
@


1.4
log
@Changed error handling using MSMessage
@
text
@d5 6
a10 3
!===================================
SUBROUTINE read_parse_l2cf (L2cf_data, returnStatus) 
!===================================
d12 1
a12 4
USE l2cf
USE MLSMessageModule

IMPLICIT NONE
d17 2
a18 2
"$Id: read_parse_l2cf.f90,v 1.3 1999/12/27 23:45:02 lungu Exp $"
CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile$"
d20 154
a174 1
! Brief description of program
d181 5
d191 1
a191 1
INTEGER, PARAMETER :: L2CF = 3000
d210 61
d282 2
a283 2
  CALL MSMessage (MLSMSG_Error,
         & ModuleName, "Error opening L2CF:  "//mnemonic//" "//msg)
d460 1
a460 1

d478 7
a484 3
!===================
END subroutine  read_parse_l2cf
!===================
d487 3
@


1.3
log
@Added MLSMessage capabilities
@
text
@d6 1
a6 1
SUBROUTINE read_l2cf (l2cf_data, returnStatus) 
d9 2
d12 1
a13 1
IMPLICIT NONE
a14 2
USE l2cf
USE MLSMessageModule
d17 2
a18 2
"$Id: read_parse_l2cf.f90,v 1.2 1999/12/22 23:27:30 lungu Exp $"
CHARACTER (LEN=*), PARAMETER :: ModuleName= 
d27 1
a27 1
TYPE (l2cf), INTENT = output :: L2cf_data
d42 3
a44 3
CHARACTER (LEN=80) :: line
CHARACTER (LEN=500) :: msg
CHARACTER (LEN=1000) :: buff
d76 1
a76 1
    CALL STRIP_BLANKS(line, nc, ncnb)
d87 1
a87 1
      CALL STRIP_BLANKS(line, nc, ncnb)
d91 1
a91 1
      IF(INDEX(line, ';' /= 1) THEN
d93 1
a93 1
        IF(INDEX(line, 'END' /= 1) THEN
d106 1
a106 1
              CALL STRIP_BLANKS(line, nc, ncnb)
d120 5
d135 5
d145 5
d154 1
d157 3
a159 1
            DO WHILE (.NOT. found .AND. i <= MaxNoL2cfKeys)
d173 2
a174 1
               IF(l2cfTable(i)%Type .EQ. "real")THEN
d176 1
a176 1
                 DO WHILE(j <= ValueLen .AND. Value(j:j) /= ' ')
d181 1
a181 1
               ELSE IF(l2cfTable(i)%Type .EQ. "int")THEN
d183 1
a183 1
                 DO WHILE(j <= ValueLen .AND. Value(j:j) /= ' ')
d188 1
a188 1
               ELSE IF(l2cfTable(i)%Type .EQ. "range")THEN
d194 2
a195 2
                   DO WHILE(k <= ValueLen .AND. Value(k:k) /= ' ')
                    j = j + 1
d201 1
a201 1
                   IF(L2cf_data%Sections(isection)%Entries(igs)%Cells(CellIndex)%RangeUpperBound .LT. &
d252 2
a253 2
  PRINT *, 'Error closing L2CF:  ', mnemonic
  PRINT *, msg
d260 1
a260 1
END subroutine  read_l2cf
d263 1
a263 1

@


1.2
log
@Changed L2cf to an array from a named multisection structure.
@
text
@d9 1
a9 1
USE l2cf
d13 2
a14 1

d17 2
a18 1
"$Id: read_parse_l2cf.f90,v 1.1 1999/12/17 01:00:27 lungu Exp $"
d51 1
d61 1
d63 3
a65 2
  PRINT *, 'Error opening L2CF:  ', mnemonic
  PRINT *, msg
d97 3
d115 1
d117 1
d125 1
d127 1
d192 1
a192 1
                   PRINT, *, 'Range expected, :', Value
d203 1
a203 1
                      PRINT, *, 'Quote expected', Value(1:ValueLen)
d206 1
a206 1
                   PRINT, *, 'Quote expected', Value(1:ValueLen)
d241 1
a241 1
END PROGRAM read_l2cf
@


1.1
log
@Obsolete and unstable version
@
text
@d16 1
a16 1
"$Id: $"
d25 1
a25 1
TYPE (l2cf), intent = output :: L2cf_data
d46 1
a46 1
INTEGER :: nc, returnStatus, version
d50 2
a51 1

d58 3
a60 3
  call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
  print *, 'Error opening L2CF:  ', mnemonic
  print *, msg
d67 1
a67 1
  IF (ios /= 0) then
d70 2
d73 2
a74 4
    call STRIP_BLANKS(line, nc, ncnb)

    IF (index(line, 'BEGIN') /= 0) THEN

d78 3
a80 3
   ib = 1
   READ(UNIT=processL2CF, IOSTAT=ios, FMT=lineFmt) nc, line
   IF (ios /= 0) THEN
d82 1
a82 1
     call STRIP_BLANKS(line, nc, ncnb)
d86 1
a86 1
     IF(index(line, ';' /= 1) THEN
d88 1
a88 1
       IF(index(line, 'END' /= 1) THEN
d90 14
a103 14
         buff(ib:ib+ncnb-1) = line(1:ncnb)
         ib = ib + ncnb
         DO WHILE (line(ncnb:ncnb) = '$')
           ib = ib- 1

           READ(UNIT=processL2CF, IOSTAT=ios, FMT=lineFmt) nc, line
           IF (ios /= 0) THEN

             call STRIP_BLANKS(line, nc, ncnb)
             buff(ib:ib+ncnb-1) = line(1:ncnb)
             ib = ib+ncnb
           ELSE
             eof = .TRUE.
           END IF
d105 2
a106 2
         END DO
         ncb = ib
d108 7
a114 7
         AnEntry(1:L2cfEntryLen) =' '
         ib = index(buff, ',')
         AnEntry(1:ib-1)=buff(1:ib-1)
         ib = ib + 1
         igs = igs + 1
         L2cf_data%GlobalSettings(igs)%L2cfEntryName = AnEntry
         CellIndex = 1
d116 80
a195 79
         DO WHILE (ib < ncb)
           ie = index(buff(ib:ncb), '=')
           key(1:maxKeyLen) = ' '
           Key = buff(ib, ie-1) 
           keyLen = ie-ib
           ib = ie + 1
           ie = index(buff(ib:ncb), ',')
           Value (1:MaxCharValueLen) = ' '
           Value = buff(ib, ie-1)
           ValueLen = ie-ib
           ib = ie + 1
           found = .FALSE.
           i = 1
           do while (.not. found .and. i <= MaxNoL2cfKeys)
             if(key(1:KeyLen) .eq. l2cfTable(i)%Keyword(1:l2cfTable(i)%Keylen))then
               found = .true.
             else
               i = i + 1
             end if
           end do
           if(found) then
             if(section .eq. 'GlobalSettings')then
                
               L2cf_data%GlobalSettings(igs)%L2cfEntryNoKeys = &
               L2cf_data%GlobalSettings(igs)%L2cfEntryNoKeys + 1
               L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%Keyword= Key(1:Keylen)
               if(l2cfTable(i)%Type .eq. "real")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%RealValue
                 L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "int")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%IntValue
                 L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "range")then
                 j = index(Value, '..')
                 if (j > 0)then
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%RangeLowerBound
                   k=j+2
                   do while(k <= ValueLen .and. Value(k:k) /= ' ')
                    j = j + 1
                   end do              
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%RangeUpperBound
                   L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%units=Value(k:ValueLen)

                   if(L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%RangeUpperBound .lt. &
                      L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%RangeUpperBound)then

                     tmp = L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%RangeUpperBound
                     L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%RangeUpperBound = 
                     L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%RangeLowerBound
                     L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%RangeLowerBound = tmp

                   end if
                 else
                   print, *, 'Range expected, :', Value
                 end if

               else if(l2cfTable(i)%Type .eq. 'string')then

                 j = index(Value, '"')
                 if(j > 0)then
                   k = index(Value(j+1:ValueLen)
                   if(k > 0)then
                      L2cf_data%GlobalSettings(igs)%Cells(CellIndex)%CharValue=Value(j:k)
                   else
                      print, *, 'Quote expected', Value(1:ValueLen)
                   end if
                 else
                   print, *, 'Quote expected', Value(1:ValueLen)
                 end if
d197 1
a197 1
               end if
d199 1
a199 477
             else if(section .eq. 'ReadApriori')then
                
               L2cf_data%ReadApriori(ira)%L2cfEntryNoKeys = &
               L2cf_data%ReadApriori(ira)%L2cfEntryNoKeys + 1
               L2cf_data%ReadApriori(ira)%Cells(CellIndex)%Keyword= Key(1:Keylen)
               if(l2cfTable(i)%Type .eq. "real")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%ReadApriori(ira)%Cells(CellIndex)%RealValue
                 L2cf_data%ReadApriori(ira)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "int")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%ReadApriori(ira)%Cells(CellIndex)%IntValue
                 L2cf_data%ReadApriori(ira)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "range")then
                 j = index(Value, '..')
                 if (j > 0)then
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%ReadApriori(ira)%Cells(CellIndex)%RangeLowerBound
                   k=j+2
                   do while(k <= ValueLen .and. Value(k:k) /= ' ')
                    j = j + 1
                   end do              
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%ReadApriori(ira)%Cells(CellIndex)%RangeUpperBound
                   L2cf_data%ReadApriori(ira)%Cells(CellIndex)%units=Value(k:ValueLen)

                   if(L2cf_data%ReadApriori(ira)%Cells(CellIndex)%RangeUpperBound .lt. &
                      L2cf_data%ReadApriori(ira)%Cells(CellIndex)%RangeUpperBound)then

                     tmp = L2cf_data%ReadApriori(ira)%Cells(CellIndex)%RangeUpperBound
                     L2cf_data%ReadApriori(ira)%Cells(CellIndex)%RangeUpperBound = 
                     L2cf_data%ReadApriori(ira)%Cells(CellIndex)%RangeLowerBound
                     L2cf_data%ReadApriori(ira)%Cells(CellIndex)%RangeLowerBound = tmp

                   end if
                 else
                   print, *, 'Range expected, :', Value
                 end if
               else if(l2cfTable(i)%Type .eq. 'string')then

                 j = index(Value, '"')
                 if(j > 0)then
                   k = index(Value(j+1:ValueLen)
                   if(k > 0)then
                      L2cf_data%ReadApriori(ira)%Cells(CellIndex)%CharValue=Value(j:k)
                   else
                      print, *, 'Quote expected', Value(1:ValueLen)
                   end if
                 else
                   print, *, 'Quote expected', Value(1:ValueLen)
                 end if
               end if
  
             else if(section .eq. 'MergeApriori')then
                
               L2cf_data%MergeApriori(ima)%L2cfEntryNoKeys = &
               L2cf_data%MergeApriori(ima)%L2cfEntryNoKeys + 1
               L2cf_data%MergeApriori(ima)%Cells(CellIndex)%Keyword= Key(1:Keylen)
               if(l2cfTable(i)%Type .eq. "real")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%MergeApriori(ima)%Cells(CellIndex)%RealValue
                 L2cf_data%MergeApriori(ima)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "int")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%MergeApriori(ima)%Cells(CellIndex)%IntValue
                 L2cf_data%MergeApriori(ima)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "range")then
                 j = index(Value, '..')
                 if (j > 0)then
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%MergeApriori(ima)%Cells(CellIndex)%RangeLowerBound
                   k=j+2
                   do while(k <= ValueLen .and. Value(k:k) /= ' ')
                    j = j + 1
                   end do              
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%MergeApriori(ima)%Cells(CellIndex)%RangeUpperBound
                   L2cf_data%MergeApriori(ima)%Cells(CellIndex)%units=Value(k:ValueLen)

                   if(L2cf_data%MergeApriori(ima)%Cells(CellIndex)%RangeUpperBound .lt. &
                      L2cf_data%MergeApriori(ima)%Cells(CellIndex)%RangeUpperBound)then

                     tmp = L2cf_data%MergeApriori(ima)%Cells(CellIndex)%RangeUpperBound
                     L2cf_data%MergeApriori(ima)%Cells(CellIndex)%RangeUpperBound = 
                     L2cf_data%MergeApriori(ima)%Cells(CellIndex)%RangeLowerBound
                     L2cf_data%MergeApriori(ima)%Cells(CellIndex)%RangeLowerBound = tmp

                   end if
                 else
                   print, *, 'Range expected, :', Value
                 end if

               else if(l2cfTable(i)%Type .eq. 'string')then

                 j = index(Value, '"')
                 if(j > 0)then
                   k = index(Value(j+1:ValueLen), '"')
                   if(k > 0)then
                      L2cf_data%MergeAprioir(ima)%Cells(CellIndex)%CharValue=Value(j:k)
                   else
                      print, *, 'Quote expected', Value(1:ValueLen)
                   end if
                 else
                   print, *, 'Quote expected', Value(1:ValueLen)
                 end if
               end if
 
             else if(section .eq. 'ChunkDivide')then
                
               L2cf_data%ChunkDivide(icd)%L2cfEntryNoKeys = &
               L2cf_data%ChunkDivide(icd)%L2cfEntryNoKeys + 1
               L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%Keyword= Key(1:Keylen)
               if(l2cfTable(i)%Type .eq. "real")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%RealValue
                 L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "int")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%IntValue
                 L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "range")then
                 j = index(Value, '..')
                 if (j > 0)then
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%RangeLowerBound
                   k=j+2
                   do while(k <= ValueLen .and. Value(k:k) /= ' ')
                    j = j + 1
                   end do              
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%RangeUpperBound
                   L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%units=trim(Value(k:ValueLen))

                   if(L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%RangeUpperBound .lt. &
                      L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%RangeUpperBound)then

                     tmp = L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%RangeUpperBound
                     L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%RangeUpperBound = 
                     L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%RangeLowerBound
                     L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%RangeLowerBound = tmp

                   end if
                 else
                   print, *, 'Range expected, :', Value
                 end if
               else if(l2cfTable(i)%Type .eq. 'string')then

                 j = index(Value, '"')
                 if(j > 0)then
                   k = index(Value(j+1:ValueLen)
                   if(k > 0)then
                      L2cf_data%ChunkDivide(icd)%Cells(CellIndex)%CharValue=Value(j:k)
                   else
                      print, *, 'Quote expected', Value(1:ValueLen)
                   end if
                 else
                   print, *, 'Quote expected', Value(1:ValueLen)
                 end if
               end if

             else if(section .eq. 'ProfileLayout')then
                
               L2cf_data%ProfileLayout(ipl)%L2cfEntryNoKeys = &
               L2cf_data%ProfileLayout(ipl)%L2cfEntryNoKeys + 1
               L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%Keyword= trim(Key(1:Keylen))
               if(l2cfTable(i)%Type .eq. "real")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%RealValue
                 L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%units=trim(Value(j+1:ValueLen))
               else if(l2cfTable(i)%Type .eq. "int")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%IntValue
                 L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%units=trim(Value(j:ValueLen))
               else if(l2cfTable(i)%Type .eq. "range")then
                 j = index(Value, '..')
                 if (j > 0)then
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%RangeLowerBound
                   k=j+2
                   do while(k <= ValueLen .and. Value(k:k) /= ' ')
                    j = j + 1
                   end do              
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%RangeUpperBound
                   L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%units=trim(Value(k:ValueLen))

                   if(L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%RangeUpperBound .lt. &
                      L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%RangeUpperBound)then

                     tmp = L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%RangeUpperBound
                     L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%RangeUpperBound = 
                     L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%RangeLowerBound
                     L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%RangeLowerBound = tmp

                   end if
                 else
                   print, *, 'Range expected, :', Value
                 end if
               else if(l2cfTable(i)%Type .eq. 'string')then

                 j = index(Value, '"')
                 if(j > 0)then
                   k = index(Value(j+1:ValueLen)
                   if(k > 0)then
                      L2cf_data%ProfileLayout(ipl)%Cells(CellIndex)%CharValue=Value(j:k)
                   else
                      print, *, 'Quote expected', Value(1:ValueLen)
                   end if
                 else
                   print, *, 'Quote expected', Value(1:ValueLen)
                 end if

               end if

             else if(section .eq. 'Construct')then
                
               L2cf_data%Construct(ic)%L2cfEntryNoKeys = &
               L2cf_data%Construct(ic)%L2cfEntryNoKeys + 1
               L2cf_data%Construct(ic)%Cells(CellIndex)%Keyword= Key(1:Keylen)
               if(l2cfTable(i)%Type .eq. "real")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%Construct(ic)%Cells(CellIndex)%RealValue
                 L2cf_data%Construct(ic)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "int")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%Construct(ic)%Cells(CellIndex)%IntValue
                 L2cf_data%Construct(ic)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "range")then
                 j = index(Value, '..')
                 if (j > 0)then
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%Construct(ic)%Cells(CellIndex)%RangeLowerBound
                   k=j+2
                   do while(k <= ValueLen .and. Value(k:k) /= ' ')
                    j = j + 1
                   end do              
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%Construct(ic)%Cells(CellIndex)%RangeUpperBound
                   L2cf_data%Construct(ic)%Cells(CellIndex)%units=Value(k:ValueLen)

                   if(L2cf_data%Construct(ic)%Cells(CellIndex)%RangeUpperBound .lt. &
                      L2cf_data%Construct(ic)%Cells(CellIndex)%RangeUpperBound)then

                     tmp = L2cf_data%Construct(ic)%Cells(CellIndex)%RangeUpperBound
                     L2cf_data%Construct(ic)%Cells(CellIndex)%RangeUpperBound = 
                     L2cf_data%Construct(ic)%Cells(CellIndex)%RangeLowerBound
                     L2cf_data%Construct(ic)%Cells(CellIndex)%RangeLowerBound = tmp

                   end if
                 else
                   print, *, 'Range expected, :', Value
                 end if

               else if(l2cfTable(i)%Type .eq. 'string')then

                 j = index(Value, '"')
                 if(j > 0)then
                   k = index(Value(j+1:ValueLen)
                   if(k > 0)then
                      L2cf_data%Construct(ic)%Cells(CellIndex)%CharValue=Value(j:k)
                   else
                      print, *, 'Quote expected', Value(1:ValueLen)
                   end if
                 else
                   print, *, 'Quote expected', Value(1:ValueLen)
                 end if

               end if

             else if(section .eq. 'Fill')then
                
               L2cf_data%Fill(if)%L2cfEntryNoKeys = &
               L2cf_data%Fill(if)%L2cfEntryNoKeys + 1
               L2cf_data%Fill(if)%Cells(CellIndex)%Keyword= trim(Key(1:Keylen))
               if(l2cfTable(i)%Type .eq. "real")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%Fill(if)%Cells(CellIndex)%RealValue
                 L2cf_data%Fill(if)%Cells(CellIndex)%units=trim(Value(j:ValueLen))
               else if(l2cfTable(i)%Type .eq. "int")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%Fill(if)%Cells(CellIndex)%IntValue
                 L2cf_data%Fill(if)%Cells(CellIndex)%units=trim(Value(j:ValueLen))
               else if(l2cfTable(i)%Type .eq. "range")then
                 j = index(Value, '..')
                 if (j > 0)then
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%Fill(if)%Cells(CellIndex)%RangeLowerBound
                   k=j+2
                   do while(k <= ValueLen .and. Value(k:k) /= ' ')
                    j = j + 1
                   end do              
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%Fill(if)%Cells(CellIndex)%RangeUpperBound
                   L2cf_data%Fill(if)%Cells(CellIndex)%units=trim(Value(k:ValueLen))

                   if(L2cf_data%Fill(if)%Cells(CellIndex)%RangeUpperBound .lt. &
                      L2cf_data%Fill(if)%Cells(CellIndex)%RangeUpperBound)then

                     tmp = L2cf_data%Fill(if)%Cells(CellIndex)%RangeUpperBound
                     L2cf_data%Fill(if)%Cells(CellIndex)%RangeUpperBound = 
                     L2cf_data%Fill(if)%Cells(CellIndex)%RangeLowerBound
                     L2cf_data%Fill(if)%Cells(CellIndex)%RangeLowerBound = tmp

                   end if
                 else
                   print, *, 'Range expected, :', Value
                 end if
               else if(l2cfTable(i)%Type .eq. 'string')then

                 j = index(Value, '"')
                 if(j > 0)then
                   k = index(Value(j+1:ValueLen)
                   if(k > 0)then
                      L2cf_data%Fill(if)%Cells(CellIndex)%CharValue=Value(j:k)
                   else
                      print, *, 'Quote expected', Value(1:ValueLen)
                   end if
                 else
                   print, *, 'Quote expected', Value(1:ValueLen)
                 end if

               end if
           
             else if(section .eq. 'Join')then
                
               L2cf_data%Join(ij)%L2cfEntryNoKeys = &
               L2cf_data%Join(ij)%L2cfEntryNoKeys + 1
               L2cf_data%Join(ij)%Cells(CellIndex)%Keyword= Key(1:Keylen)
               if(l2cfTable(i)%Type .eq. "real")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%Join(ij)%Cells(CellIndex)%RealValue
                 L2cf_data%Join(ij)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "int")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%Join(ij)%Cells(CellIndex)%IntValue
                 L2cf_data%Join(ij)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "range")then
                 j = index(Value, '..')
                 if (j > 0)then
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%Join(ij)%Cells(CellIndex)%RangeLowerBound
                   k=j+2
                   do while(k <= ValueLen .and. Value(k:k) /= ' ')
                    j = j + 1
                   end do              
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%Join(ij)%Cells(CellIndex)%RangeUpperBound
                   L2cf_data%Join(ij)%Cells(CellIndex)%units=Value(k:ValueLen)

                   if(L2cf_data%Join(ij)%Cells(CellIndex)%RangeUpperBound .lt. &
                      L2cf_data%Join(ij)%Cells(CellIndex)%RangeUpperBound)then

                     tmp = L2cf_data%Join(ij)%Cells(CellIndex)%RangeUpperBound
                     L2cf_data%Join(ij)%Cells(CellIndex)%RangeUpperBound = 
                     L2cf_data%Join(ij)%Cells(CellIndex)%RangeLowerBound
                     L2cf_data%Join(ij)%Cells(CellIndex)%RangeLowerBound = tmp

                   end if
                 else
                   print, *, 'Range expected, :', Value
                 end if
               else if(l2cfTable(i)%Type .eq. 'string')then

                 j = index(Value, '"')
                 if(j > 0)then
                   k = index(Value(j+1:ValueLen)
                   if(k > 0)then
                      L2cf_data%join(ij)%Cells(CellIndex)%CharValue=Value(j:k)
                   else
                      print, *, 'Quote expected', Value(1:ValueLen)
                   end if
                 else
                   print, *, 'Quote expected', Value(1:ValueLen)
                 end if
               end if
              
             else if(section .eq. 'Output')then
                
               L2cf_data%Output(io)%L2cfEntryNoKeys = &
               L2cf_data%Output(io)%L2cfEntryNoKeys + 1
               L2cf_data%Output(io)%Cells(CellIndex)%Keyword= Key(1:Keylen)
               if(l2cfTable(i)%Type .eq. "real")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%Output(io)%Cells(CellIndex)%RealValue
                 L2cf_data%Output(io)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "int")then
                 j = 1     
                 do while(j <= ValueLen .and. Value(j:j) /= ' ')
                   j = j + 1
                 end do
                 read (unit=Value(1:j-1), fmt='*') L2cf_data%Output(io)%Cells(CellIndex)%IntValue
                 L2cf_data%Output(io)%Cells(CellIndex)%units=Value(j:ValueLen)
               else if(l2cfTable(i)%Type .eq. "range")then
                 j = index(Value, '..')
                 if (j > 0)then
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%Output(io)%Cells(CellIndex)%RangeLowerBound
                   k=j+2
                   do while(k <= ValueLen .and. Value(k:k) /= ' ')
                    j = j + 1
                   end do              
                   read (unit=Value(1:j-1), fmt='*') &
                   L2cf_data%Output(io)%Cells(CellIndex)%RangeUpperBound
                   L2cf_data%Output(io)%Cells(CellIndex)%units=Value(k:ValueLen)

                   if(L2cf_data%Output(io)%Cells(CellIndex)%RangeUpperBound .lt. &
                      L2cf_data%Output(io)%Cells(CellIndex)%RangeUpperBound)then

                     tmp = L2cf_data%Output(io)%Cells(CellIndex)%RangeUpperBound
                     L2cf_data%Output(io)%Cells(CellIndex)%RangeUpperBound = 
                     L2cf_data%Output(io)%Cells(CellIndex)%RangeLowerBound
                     L2cf_data%Output(io)%Cells(CellIndex)%RangeLowerBound = tmp

                   end if
                 else
                   print, *, 'Range expected, :', Value(1:ValueLen)
                 end if
               else if(l2cfTable(i)%Type .eq. 'string')then

                 j = index(Value, '"')
                 if(j > 0)then
                   k = index(Value(j+1:ValueLen)
                   if(k > 0)then
                      L2cf_data%Output(io)%Cells(CellIndex)%CharValue=Value(j:k)
                   else
                      print, *, 'Quote expected', Value(1:ValueLen)
                   end if
                 else
                   print, *, 'Quote expected', Value(1:ValueLen)
                 end if
               end if
             end if                                  
d208 6
a213 2
end
end
d220 3
a222 3
  call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
  print *, 'Error closing L2CF:  ', mnemonic
  print *, msg
a224 1
! Display the read data for verification.
a226 4
! Detailed description of program
! This program uses the Toolkit to open the L2CF as a
! generic input file.  It reads the data and parses it, storing the tokens
! into the L2cf symbol table.
a231 1
!# $Log: $
@

