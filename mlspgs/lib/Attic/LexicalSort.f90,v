head	2.2;
access;
symbols;
locks; strict;
comment	@# @;


2.2
date	2017.12.07.22.05.08;	author pwagner;	state dead;
branches;
next	2.1;

2.1
date	2017.08.23.16.42.29;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.2
log
@Using sort_m instead
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module LexicalSort                   ! Module to sort string arrays
!=============================================================================
!
	implicit none
!
        private
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: LexicalSort.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
	public :: sort
!
	integer, dimension (:), allocatable, private :: indexarray
	logical, private :: CaseSensitive
!
contains
!-----------------------------------------------------------------------
!  Subroutine sort uses the quicksort algorithm.
!  On input, StringArray is a one-dimensional array of character strings
!  to be sorted in ascending lexical order.
!  On output, StringArray is the sorted array.
!  If the optional argument CaseInsensitive is present and .true.,
!  the sort is case-insensitive. If CaseInsensitive is absent or
!  if it is .false., the sort is case-sensitive.
!  The characters of the elements of the string array are not modified,
!  so that if blanks or punctuation characters are to be ignored,
!  for instance, this needs to be done before calling sort.
!-----------------------------------------------------------------------
	subroutine sort( StringArray, CaseInsensitive, indices )
!
	character (len = *), dimension (:), intent (inout) :: StringArray
	logical, intent (in), optional :: CaseInsensitive
	integer, dimension (:), intent (out), optional :: indices
	integer :: low, high, ios, k
!
	if (present(CaseInsensitive)) then
      CaseSensitive = .not. CaseInsensitive
	else
      CaseSensitive = .true.
	endif
!
	low = 1
	high = size(StringArray)
!
	allocate(indexarray(high), stat = ios)
!
	if (ios /= 0) then
      print *, "Error allocating indexarray in LexicalSort::sort"
      stop
	endif
!
	indexarray = (/ (k, k = low, high) /)
!
	call quicksort(StringArray, low, high)
	StringArray = StringArray(indexarray)
        if ( present(indices) ) indices(1:high) = indexarray
!
	deallocate(indexarray, stat = ios)
	if (ios /= 0) then
      print *, "Error deallocating indexarray in LexicalSort::sort"
      stop
	endif
!
	return
	end subroutine
!---------------------------------------------------
	recursive subroutine quicksort(StringArray, low, high)
	character (len = *), dimension (:), intent (inout) :: StringArray
	integer, intent (in) :: low, high
	integer :: pivotlocation
!
	if (low < high) then
      call partition(StringArray, low, high, pivotlocation)
      call quicksort(StringArray, low, pivotlocation - 1)
      call quicksort(StringArray, pivotlocation + 1, high)
	endif
!
	return
	end subroutine
!---------------------------------------------------
	subroutine partition(StringArray, low, high, pivotlocation)
	character (len = *), dimension (:), intent (inout) :: StringArray
	integer, intent (in) :: low, high
	integer, intent (out) :: pivotlocation
	integer :: k, lastsmall
!
	call swap(indexarray(low), indexarray((low + high)/2))
	lastsmall = low
	do k = low + 1, high
      if (stringComp(StringArray(indexarray(k)), StringArray(indexarray(low)))) then
        lastsmall = lastsmall + 1
        call swap(indexarray(lastsmall), indexarray(k))
      endif
	enddo
	call swap(indexarray(low), indexarray(lastsmall))
	pivotlocation = lastsmall
!
	return
	end subroutine
!---------------------------------------------------
	subroutine swap(m, n)
	integer, intent (inout) :: m, n
	integer :: temp
!
	temp = m
	m = n
	n = temp
!
	return
	end subroutine
!----------------------------------------------------
	function stringComp(p, q) result(lexicalLess)
	character (len = *), intent (in) :: p, q
	logical :: lexicalLess
	integer :: kq, k
!
	if (CaseSensitive) then
      lexicalLess = p < q
	else
      kq = 1
      do k = 1, max(len_trim(p), len_trim(q))
        if (UpperCase(p(k:k)) == UpperCase(q(k:k)) ) then
          cycle
        else
          kq = k
          exit
        endif
      enddo
      lexicalLess = UpperCase(p(kq:kq)) < UpperCase(q(kq:kq))
	endif
!
	return
	end function
!---------------------------------------------------
	function UpperCase(letter) result(L)
	character (len = *), intent (in) :: letter
	character (len = 1) :: L
	character (len = 26), parameter :: Lower = "abcdefghijklmnopqrstuvwxyz"
        character (len = 26), parameter :: Upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	integer :: k
!
	k = index(Lower, letter)
	if (k > 0) then
      L = Upper(k:k)
	else
      L = letter
	endif
!
	return
	end function
!----------------------------------------------------
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: LexicalSort.f90,v 2.1 2017/08/23 16:42:29 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module LexicalSort 
!=============================================================================

! $Log: LexicalSort.f90,v $
! Revision 2.1  2017/08/23 16:42:29  pwagner
! First commit
!
@


2.1
log
@First commit
@
text
@d21 1
a21 1
       "$RCSfile: MLSStringLists.f90,v $"
d168 1
a168 1
       "$Id: MLSStringLists.f90,v 2.74 2017/01/25 21:12:36 pwagner Exp $"
d178 4
a181 1
! $Log: MLSStringLists.f90,v $
@

