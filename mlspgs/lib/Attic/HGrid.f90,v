head	1.12;
access;
symbols
	V0_1:1.11;
locks; strict;
comment	@# @;


1.12
date	2000.09.05.17.19.22;	author dcuddy;	state dead;
branches;
next	1.11;

1.11
date	2000.06.30.00.22.24;	author lungu;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.19.23.50.51;	author lungu;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.17.23.33.51;	author lungu;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.17.18.15.23;	author livesey;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.16.19.59.37;	author livesey;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.18.00.14.51;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.11.22.51.34;	author livesey;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.07.23.53.34;	author livesey;	state Exp;
branches;
next	1.3;

1.3
date	99.12.17.21.39.34;	author livesey;	state Exp;
branches;
next	1.2;

1.2
date	99.12.16.18.23.20;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	99.12.16.01.26.46;	author livesey;	state Exp;
branches;
next	;


desc
@@


1.12
log
@moved to mlspgs/l2
@
text
@! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

!=============================================================================
MODULE HGrid                    ! Horizontal grid information
!=============================================================================

  USE MLSCommon
  USE MLSCF
  USE MLSMessageModule
  USE MLSStrings
  USE L1BData
  USE MLSNumerics
  USE Units

  IMPLICIT NONE

  PRIVATE :: Id, ModuleName
  !---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
       "$Id: HGrid.f90,v 1.11 2000/06/30 00:22:24 lungu Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: HGrid.f90,v $"
  ! ---------------------------------------------------------------------------

  ! This module contains datatypes and routines for handling HGrid information
  ! HGrids are the horizontal gridding information that get into vector
  ! quantities.

  ! This is the main datatype, an HGrid.

  TYPE HGrid_T
     CHARACTER (LEN=NameLen) :: name ! Name for HGrid
     INTEGER :: noProfs         ! Number of profiles in this grid
     INTEGER :: noProfsLowerOverlap ! Number of profiles in the lower overlap
     INTEGER :: noProfsUpperOverlap ! Number of profiles in the upper overlap

     ! Now the various coordinates in the HGrid, all dimensioned (noProfs)
     REAL(r8), DIMENSION(:), POINTER :: phi, geodLat, lon, time, &
          & solarTime,solarZenith,losAngle
  END TYPE HGrid_T

  CONTAINS

  ! ---------------------------------------------------------------------------

  ! This routine creates an empty HGrid

  SUBROUTINE SetupEmptyHGrid(hGrid,noProfs)
    
    ! Dummy arguments
    TYPE(HGrid_T), INTENT(OUT) :: hGrid
    INTEGER, INTENT(IN) :: noProfs

    ! Local variables
    INTEGER :: status

    ! Executable code

    hGrid%noProfs=noProfs
    ALLOCATE(hGrid%phi(noProfs), hGrid%geodLat(noProfs), hGrid%lon(noProfs), &
         & hGrid%time(noProfs), hGrid%solarTime(noProfs), &
         & hGrid%solarZenith(noProfs), hGrid%losAngle(noProfs), &
         & STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,"hGrid information")

    hGrid%noProfsLowerOverlap=0
    hGrid%noProfsUpperOverlap=0
  END SUBROUTINE SetupEmptyHGrid


  ! --------------------------------------------------------------------------

  ! This routine creates an hGrid based on the user requests.
  
  SUBROUTINE CreateHGridFromMLSCFInfo(hGrid,cfInfo,l1bInfo,chunk)

    ! Dummy arguments
    TYPE (hGrid_T), INTENT(OUT) :: hGrid ! HGrid to create
    TYPE (MLSCFEntry_T), INTENT(IN) :: cfInfo ! Instructions for its creation
    TYPE (L1BInfo_T), INTENT(IN) :: l1bInfo ! File handles for l1b data
    TYPE (MLSChunk_T), INTENT(IN) :: chunk ! This chunk

    ! Local parameters
    INTEGER, PARAMETER :: HG_Invalid=0
    INTEGER, PARAMETER :: HG_Height=1
    INTEGER, PARAMETER :: HG_Fractional=2

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! IF MODIFYING THIS SECTION PLEASE TAKE CARE, SEE BELOW!
    INTEGER, PARAMETER :: NoL1BItemsToRead=7
    CHARACTER (LEN=15), DIMENSION(NoL1BItemsToRead), &
         &   PARAMETER :: L1bItemsToRead=&
         & (/"MAFStartTimeTAI","tpGeodLat      ","tpLon          ",&
         &   "tpGeodAngle    ","tpSolarZenith  ","tpSolarTime    ",&
         &   "tpLosAngle     "/)
    INTEGER, PARAMETER :: TransitionToModularItems=2
    ! Entries in the above array below TransitionToModularItems are prefixed
    ! with either GHz or THz.  The layout of the above array is critically
    ! bound to the SELECT CASE(l1bItem) code below.  So TAKE CARE! when
    ! modifing it.
    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    ! Local variables
    INTEGER :: hGridType=HG_Invalid
    REAL(r8) :: interpolationFactor=1.0
    INTEGER :: instrumentModule=MLSInstrumentModule_Invalid
    REAL(r8) :: fraction= -1e10, height= -1e10

    INTEGER :: keyNo            ! Entry in the mlscf line
    TYPE (MLSCFCell_T) :: cell  ! Part of the mlscf information

    TYPE (L1BData_T) :: l1bField ! L1B data
    REAL(r8), DIMENSION(:,:,:), POINTER :: tpGeodAngle,tpGeodAlt

    REAL(r8) :: minAngle,maxAngle,desiredAngle

    INTEGER :: noMAFs           ! Number of MAFs of L1B data read
    INTEGER :: noProfs          ! Number of profiles in output hGrid
    INTEGER :: maf,l1bItem,prof ! Loop counters
    INTEGER :: family           ! For parsing `height'
    REAL(r8) :: scale           ! For putting `height' into the right units
    INTEGER, DIMENSION(:), ALLOCATABLE :: defaultMIFs
    ! MIFs it would choose in the non over/undersampled case
    REAL(r8), DIMENSION(:), ALLOCATABLE :: defaultField,interpolatedField
    REAL(r8), DIMENSION(:), ALLOCATABLE :: intermediateField

    INTEGER :: status,l1bFlag   ! Flags

    CHARACTER (LEN=NameLen) :: l1bItemName
    CHARACTER (LEN=3),  DIMENSION(MLSInstrumentNoModules) :: &
       & MLSInstrumentModuleNames= (/ &
       & "GHz", &
       & "THz"/)

    ! Executable code

    DO keyNo=1,cfInfo%mlscfEntryNoKeys
       cell=cfInfo%cells(keyNo)
       SELECT CASE(TRIM(cell%keyword))
       CASE("NAME")
          hGrid%name=cell%charValue
       CASE("TYPE")
          SELECT CASE(TRIM(Capitalize(cell%charValue)))
          CASE ("HEIGHT")
             hGridType=HG_Height
          CASE ("FRACTIONAL")
             hGridType=HG_Fractional
          CASE DEFAULT
             CALL MLSMessage(MLSMSG_Error,ModuleName,&
                  & "Unrecognised hGrid type: "//TRIM(cell%charValue))
          END SELECT
       CASE("MODULE")
          SELECT CASE(TRIM(Capitalize(cell%charValue)))
          CASE("GHZ")
             instrumentModule=MLSInstrumentModule_GHz
          CASE("THZ")
             instrumentModule=MLSInstrumentModule_THz
          CASE DEFAULT
             CALL MLSMessage(MLSMSG_Error,ModuleName,&
                  & "Unrecognised instrument module: "//TRIM(cell%charValue))
          END SELECT
       CASE("HEIGHT")
          height=cell%realValue
          CALL ParseUnitName(cell%units,family,scale)
          IF (family /= PHYQ_Length) CALL MLSMessage(MLSMSG_Error,ModuleName,&
               & "height must be specified as a length (e.g. km)")
          height=height*scale
       CASE("FRACTION")
          fraction=cell%realValue
       CASE("INTERPOLATIONFACTOR")
          interpolationFactor=cell%realValue
       CASE DEFAULT
          CALL MLSMessage(MLSMSG_Error,ModuleName,&
               & MLSMSG_Keyword//TRIM(cell%keyword))
       END SELECT
    END DO

    ! Now check the sanity of what we have

    IF (LEN_TRIM(hGrid%name)==0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Invalid or absent hGrid name")
    IF (hGridType==HG_Invalid) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "No type specified for hGrid "//TRIM(hGrid%name))
    IF ((hGridType==HG_Height).AND.(height<-1e9)) CALL MLSMessage(&
         & MLSMSG_Error,ModuleName,"No height specified for hGrid "//&
         & TRIM(hGrid%name))
    IF ((hGridType==HG_Fractional).AND.(fraction<-1e9)) CALL MLSMessage(&
         & MLSMSG_Error,ModuleName,"No fraction specified for hGrid "//&
         & TRIM(hGrid%name))
    IF (instrumentModule==MLSInstrumentModule_Invalid) CALL MLSMessage(&
         & MLSMSG_Error,ModuleName,"Must specifiy module=GHz/THz")

    ! This is where we will start reading the l1bdata get the name to read

    l1bItemName=MLSInstrumentModuleNames(instrumentModule)
    SELECT CASE(hGridType)
    CASE (HG_Fractional)
       l1bItemName=TRIM(l1bItemName)//"."//"tpGeodAngle"
    CASE (HG_Height)
       l1bItemName=TRIM(l1bItemName)//"."//"tpGeodAlt"
    END SELECT

    ! Read the data

    CALL ReadL1BData(l1bInfo%l1boaid,l1bItemName,l1bField,noMAFs,l1bFlag, &
         & firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex)
    IF (l1bFlag==-1) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & MLSMSG_L1BRead//l1bItemName)

    ! Allocate default MIFs

    ALLOCATE(defaultMIFs(noMAFs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & MLSMSG_Allocate//"defaultMIFs")
   
    ! Work out which MIF should have the profile for each MAF.

    IF (hGridType==HG_Fractional) THEN
       ! A fractional hGrid, we need to read the tangent point phi
       tpGeodAngle=>l1bField%dpField

       ! Loop over the MAFs
       DO maf=1,noMAFs
          ! Think about missing data here! ***
          ! Probably need to do a pack on tpGeodAngle and then unpack on
          ! defaultMIFs

          minAngle=MINVAL(tpGeodAngle(1,:,maf))
          maxAngle=MAXVAL(tpGeodAngle(1,:,maf))

          CALL Hunt(tpGeodAngle(1,:,maf),minAngle+&
               & fraction*(maxAngle-minAngle),defaultMIFs(maf))
       END DO
    ELSE
       tpGeodAlt=>l1bField%dpField

       ! Loop over the MAFs
       DO maf=1,noMAFs
          ! Think about missing data here! ***
          ! Probably need to do a pack on tpGeodAngle and then unpack on
          ! defaultMIFs

          CALL Hunt(tpGeodAlt(1,:,maf),height,defaultMIFs(maf))
       END DO
    ENDIF

    ! Done with this piece of l1b data for the moment
    CALL DeallocateL1BData(l1bField,l1bFlag)

    ! Now we have a default MIFs array, this is a list of the `standard'
    ! MIFs we would choose in the interpolationFactor=1 case.
    ! Work out how many profiles this is going to be

    noProfs=NINT(noMAFs*interpolationFactor)
    CALL SetupEmptyHgrid(hGrid,noProfs)

    ! Setup some arrays
    ALLOCATE(defaultField(noMAFs),interpolatedField(noProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "defaultField and/or interpolatedField")

    ! Now we go through all the important geolocation quantities, read them
    ! in, interpolate them if required and store the result in the hGrid

    DO l1bItem=1,NoL1BItemsToRead
       ! Get the name of the item to read
       l1bItemName=l1bItemsToRead(l1bItem)
       IF (l1bItem>=TransitionToModularItems) l1bItemName=&
            & MLSInstrumentModuleNames(instrumentModule)//"."//l1bItemName
       
       ! Read it from the l1boa file
       CALL ReadL1BData(l1bInfo%l1boaid,l1bItemName,l1bField,noMAFs, &
            & l1bFlag,firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex)
       IF (l1bFlag==-1) CALL MLSMessage(MLSMSG_Error,ModuleName,&
            & MLSMSG_L1BRead//l1bItemName)

       IF (l1bItem==1) THEN     ! Do something special for time
          DO maf=1,noMAFs
             defaultField(maf)=l1bField%dpField(1,1,maf)+&
                  & (defaultMIFs(maf)-1)*0.166666666666666666666667D0
          END DO
       ELSE                     ! Otherwise this is fairly easy.
          DO maf=1,noMAFs
             defaultField(maf)=l1bField%dpField(1,defaultMIFs(maf),maf)
          END DO
       END IF

       IF (interpolationFactor==1.0) THEN
          interpolatedField=defaultField
       ELSE
          ! Some interpolation is wanted.  I'm going to hold off writing this
          ! because we certaintly don't need it for 0.1 and probably won't till
          ! 1.0.  For the sake of getting things down I'll state here what I
          ! think would be implemented.  One would simply interpolate from the
          ! defaultField to the interpolatedField, using linear or spline I
          ! imagine.  However, there are issues with roll overs for quantities
          ! such as longitude and solarTime.  This is why I have chosen to
          ! defer this piece of code.
          ! NJL - 16 December 1999
          CALL MLSMessage(MLSMSG_Error,ModuleName, &
               & "Sorry interpolation of hGrids is not yet supported")
       ENDIF

       ! Now we have to save this field in the hGrid data.  This is rather a
       ! kludgy way of doing it but this worked out the least boring way to
       ! write the code.  See the definition of L1BItemsToRead above for
       ! reference.

       SELECT CASE(l1bItem)
       CASE(1)
          hGrid%time=interpolatedField
       CASE(2)
          hGrid%geodLat=interpolatedField
       CASE(3)
          hGrid%lon=interpolatedField
       CASE(4)
          hGrid%phi=interpolatedField
       CASE(5)
          hGrid%solarZenith=interpolatedField
       CASE(6)
          hGrid%solarTime=interpolatedField
       CASE(7)
          hGrid%losAngle=interpolatedField
       END SELECT
    END DO

    DEALLOCATE (defaultMIFs, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"defaultMIFs")
    DEALLOCATE (defaultField, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"defaultField")
    DEALLOCATE (interpolatedField, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"interpolatedField")

    ! This calculation may need attention! ***
    hGrid%noProfsLowerOverlap=NINT(chunk%noMAFsLowerOverlap*interpolationFactor)
    hGrid%noProfsUpperOverlap=NINT(chunk%noMAFsUpperOverlap*interpolationFactor)
    
  END SUBROUTINE CreateHGridFromMLSCFInfo

  ! ---------------------------------------------------------------------------

  ! This routine destroys the information associated with an hGrid

  SUBROUTINE DestroyHGridContents(hGrid)

    ! Dummy arguments
    TYPE (HGrid_T), INTENT(OUT) :: hGrid
    !Local variables
    INTEGER:: status
    ! Executable code
    DEALLOCATE(hGrid%phi, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Warning,ModuleName, &
         & MLSMSG_DeAllocate//"hGrid%phi")


    DEALLOCATE(hGrid%geodLat, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Warning,ModuleName, &
         & MLSMSG_DeAllocate//"hGrid%geodLat")

    DEALLOCATE(hGrid%lon,  stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Warning,ModuleName, &
         & MLSMSG_DeAllocate//"hGrid%lon")

    DEALLOCATE(hGrid%time, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Warning,ModuleName, &
         & MLSMSG_DeAllocate//"hGrid%time")

    DEALLOCATE(hGrid%solarTime, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Warning,ModuleName, &
         & MLSMSG_DeAllocate//"hGrid%solarTime")

    DEALLOCATE(hGrid%solarZenith, stat=status) 
    IF (status /= 0) CALL MLSMessage(MLSMSG_Warning,ModuleName, &
         & MLSMSG_DeAllocate//"hGrid%solarZenith")

    DEALLOCATE(hGrid%losAngle, stat=status)   
    IF (status /= 0) CALL MLSMessage(MLSMSG_Warning,ModuleName, &
         & MLSMSG_DeAllocate//"hGrid%losAngle")


    hGrid%noProfs=0
    hGrid%name=""
  END SUBROUTINE DestroyHGridContents

  ! ---------------------------------------------------------------------------

  SUBROUTINE AddHGridToDatabase(database,hGrid)

    ! Dummy arguments
    TYPE (HGrid_T), DIMENSION(:), POINTER :: database
    TYPE (HGrid_T), INTENT(IN) :: hGrid

    ! Local variables
    TYPE (HGrid_T), DIMENSION(:), POINTER :: tempDatabase
    INTEGER :: newSize,status

    ! Executable code

    IF (ASSOCIATED(database)) THEN
       ! Check we don't already have one of this name
       IF (LinearSearchStringArray(database%name,hGrid%name, &
            & caseInsensitive=.TRUE.)/=0) CALL MLSMessage(MLSMSG_Error,&
            & ModuleName,MLSMSG_Duplicate//hGrid%name)
       newSize=SIZE(database)+1
    ELSE
       newSize=1
    ENDIF

    ALLOCATE(tempDatabase(newSize),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Allocation failed for tempDatabase")

    IF (newSize>1) tempDatabase(1:newSize-1)=database
    tempDatabase(newSize)=hGrid
    IF (ASSOCIATED(database))DEALLOCATE(database, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"database")
    database=>tempDatabase
  END SUBROUTINE AddHGridToDatabase

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a quantity template database

  SUBROUTINE DestroyHGridDatabase(database)

    ! Dummy argument
    TYPE (HGrid_T), DIMENSION(:), POINTER :: database

    ! Local variables
    INTEGER :: hGridIndex, status

    IF (ASSOCIATED(database)) THEN
       DO hGridIndex=1,SIZE(database)
          CALL DestroyHGridContents(database(hGridIndex))
       ENDDO
       DEALLOCATE(database, stat=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Warning,ModuleName, &
         & MLSMSG_DeAllocate//"database") 
    ENDIF
  END SUBROUTINE DestroyHGridDatabase

!=============================================================================
END MODULE HGrid
!=============================================================================

!
! $Log: HGrid.f90,v $
! Revision 1.11  2000/06/30 00:22:24  lungu
! Downgraded deallocation errors to warnings.
!
! Revision 1.10  2000/06/19 23:50:51  lungu
! Added status check after each DEALLOCATE.
!
! Revision 1.9  2000/05/17 23:33:51  lungu
! Added dots between MLSInstrumentModuleName and l1bItemName so that is consistent with L1BOA file.
! Added check "IF (ASSOCIATED(database))DEALLOCATE(database)" so it doesn't chrash trying to dealocate
! an "empty" database.
!
! Revision 1.8  2000/05/17 18:15:23  livesey
! Finished off interaction with l2cf.
!
! Revision 1.7  2000/05/16 19:59:37  livesey
! Added stuff to deal with `time' correctly.
!
! Revision 1.6  2000/01/18 00:14:51  livesey
! Removed profileIndices etc. No longer relevant, as Join deals with this stuff
! for l2gp quantities.
!
! Revision 1.5  2000/01/11 22:51:34  livesey
! Dealt with ramifications of change from read_parse_l2cf to MLSCF
!
! Revision 1.4  2000/01/07 23:53:34  livesey
! Nearly integrated, just a few tweaks.
!
! Revision 1.3  1999/12/17 21:39:34  livesey
! Added check for duplicate name in database.
!
! Revision 1.2  1999/12/16 18:23:20  livesey
! First version that compiles.
!
! Revision 1.1  1999/12/16 01:26:46  livesey
! Nightly checkin
!
!
@


1.11
log
@Downgraded deallocation errors to warnings.
@
text
@d21 1
a21 1
       "$Id: HGrid.f90,v 1.10 2000/06/19 23:50:51 lungu Exp $"
d452 3
@


1.10
log
@Added status check after each DEALLOCATE.
@
text
@d21 1
a21 1
       "$Id: HGrid.f90,v 1.9 2000/05/17 23:33:51 lungu Exp $"
d130 4
a353 1

d355 1
a355 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d359 2
a360 2
    DEALLOCATE(hGrid%geodLat, stat=status)                              
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d363 2
a364 2
    DEALLOCATE(hGrid%lon,  stat=status)                              
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d367 2
a368 2
    DEALLOCATE(hGrid%time, stat=status)                              
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d371 2
a372 2
    DEALLOCATE(hGrid%solarTime, stat=status)                              
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d375 2
a376 2
    DEALLOCATE(hGrid%solarZenith, stat=status)                              
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d379 2
a380 2
    DEALLOCATE(hGrid%losAngle, stat=status)                              
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d441 1
a441 1
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d452 3
@


1.9
log
@Added dots between MLSInstrumentModuleName and l1bItemName so that is consistent with L1BOA file.
Added check "IF (ASSOCIATED(database))DEALLOCATE(database)" so it doesn't chrash trying to dealocate
an "empty" database.
@
text
@d21 1
a21 1
       "$Id: HGrid.f90,v 1.8 2000/05/17 18:15:23 livesey Exp $"
d323 9
a331 2
    DEALLOCATE (defaultMIFs)
    DEALLOCATE (defaultField,interpolatedField)
d347 3
d351 28
a378 1
    ! Executable code
a379 2
    DEALLOCATE(hGrid%phi, hGrid%geodLat, hGrid%lon, hGrid%time, &
         & hGrid%solarTime, hGrid%solarZenith, hGrid%losAngle)
d415 3
a417 1
    IF (ASSOCIATED(database))DEALLOCATE(database)
d431 1
a431 1
    INTEGER :: hGridIndex
d437 3
a439 1
       DEALLOCATE(database)
d449 5
@


1.8
log
@Finished off interaction with l2cf.
@
text
@d21 1
a21 1
       "$Id: HGrid.f90,v 1.7 2000/05/16 19:59:37 livesey Exp $"
d194 1
a194 1
       l1bItemName=TRIM(l1bItemName)//"tpGeodAngle"
d196 1
a196 1
       l1bItemName=TRIM(l1bItemName)//"tpGeodAlt"
d265 1
a265 1
            & MLSInstrumentModuleNames(instrumentModule)//l1bItemName
d380 1
a380 1
    DEALLOCATE(database)
d410 3
@


1.7
log
@Added stuff to deal with `time' correctly.
@
text
@d14 1
d21 1
a21 1
       "$Id: HGrid.f90,v 1.6 2000/01/18 00:14:51 livesey Exp $"
d120 2
d159 5
a163 1
          ! Code needed here when mlscf finalized ***
d165 1
a165 1
          ! Code needed here when mlscf finalized ***
d167 1
a167 1
          ! Code needed here when mlscf finalized ***
d410 3
@


1.6
log
@Removed profileIndices etc. No longer relevant, as Join deals with this stuff
for l2gp quantities.
@
text
@d20 1
a20 1
       "$Id: HGrid.f90,v 1.5 2000/01/11 22:51:34 livesey Exp $"
d92 1
a92 1
         & (/"time           ","tpGeodLat      ","tpLon          ",&
d120 1
d122 1
a122 1
    ! MIFs it would choose in the non over/undersampled case
d266 10
a275 3
       DO maf=1,noMAFs
          defaultField(maf)=l1bField%dpField(1,maf,defaultMIFs(maf))
       END DO
d403 4
@


1.5
log
@Dealt with ramifications of change from read_parse_l2cf to MLSCF
@
text
@d20 1
a20 1
       "$Id: HGrid.f90,v 1.4 2000/01/07 23:53:34 livesey Exp $"
a38 3
   
     ! This is an array of profiles numbers to go into l2gp etc. data
     INTEGER, DIMENSION(:), POINTER :: profileIndices ! Dimensioned (noProfs)
d62 1
a62 1
         & hGrid%profileIndices(noProfs),STAT=status)
a117 1
    INTEGER :: profileOffset    ! Number of first profile in this chunk
d311 1
a311 2
    ! Now we need to work out the profile indices for this hGrid. This
    ! calculation may need attention! ***
a313 6
    profileOffset=NINT(chunk%accumulatedMAFs*interpolationFactor)-&
         & hGrid%noProfsLowerOverlap
    ! Note that profiles are numbered from 0:n-1 in HDF-EOS, hence the -1
    DO prof=1,noProfs
       hGrid%profileIndices(prof)=prof+profileOffset-1
    END DO
d329 1
a329 2
         & hGrid%solarTime, hGrid%solarZenith, hGrid%losAngle, &
         & hGrid%profileIndices)
d395 3
@


1.4
log
@Nearly integrated, just a few tweaks.
@
text
@d9 1
a9 1
  USE ReadParseL2CF
d20 1
a20 1
       "$Id: HGrid.f90,v 1.3 1999/12/17 21:39:34 livesey Exp $"
d81 1
a81 1
    TYPE (L2CFEntry), INTENT(IN) :: cfInfo ! Instructions for its creation
d111 2
a112 2
    INTEGER :: keyNo            ! Entry in the l2cf line
    TYPE (L2CFCell) :: cell     ! Part of the l2cf information
d133 1
a133 1
    DO keyNo=1,cfInfo%l2cfEntryNoKeys
d159 1
a159 1
          ! Code needed here when l2cf finalized ***
d161 1
a161 1
          ! Code needed here when l2cf finalized ***
d163 1
a163 1
          ! Code needed here when l2cf finalized ***
d407 3
@


1.3
log
@Added check for duplicate name in database.
@
text
@d9 1
a9 1
  USE Temporary_Types
d20 1
a20 1
       "$Id: HGrid.f90,v 1.2 1999/12/16 18:23:20 livesey Exp $"
d407 3
@


1.2
log
@First version that compiles.
@
text
@d20 1
a20 1
       "$Id: HGrid.f90,v 1.1 1999/12/16 01:26:46 livesey Exp $"
d362 4
d407 3
@


1.1
log
@Nightly checkin
@
text
@d10 1
a10 1
  USE MLSMessage
d13 1
d20 2
a21 2
       "$Id: $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile$"
d33 2
d67 3
d83 1
a83 1
    TYPE (Chunk_T), INTENT(IN) :: chunk ! This chunk
d90 3
a92 1
    INTEGER, PARAMETER :: NoL1BItemsToRead=8
d97 1
a97 1
         &   "tpSolarTime    ","tpLosAngle     "/)
d100 4
a103 2
    ! with either GHz or THz

d107 1
a107 1
    INTEGER :: sampled=1.0
d114 1
a114 1
    TYPE (L1BData_T) :: l1bItem ! L1B data
d120 3
a122 1
    INTEGER :: maf,l1bItem      ! Loop counters
d124 1
d127 1
a127 1
    INTEGER :: status
d162 1
a162 1
       CASE("SAMPLED")
d182 1
a182 1
    IF (instrumentModule==MLSModule_Invalid) CALL MLSMessage(&
d197 2
a198 2
    CALL ReadL1BData(l1bInfo%l1boaid,l1bItemName,noMAFs,l1bFlag,l1bField, &
         &firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex)
d201 9
a209 1
 
a213 4
       ALLOCATE(defaultMIFs(noMAFs),STAT=status)
       IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
            & MLSMSG_Allocate//"defaultMIFs")

d223 2
a224 2
          defaultMIFs(maf)=Hunt(tpGeodAngle(1,:,maf),minAngle+&
               & fraction*(maxAngle-minAngle))
a228 4
       ALLOCATE(defaultMIFs(noMAFs),STAT=status)
       IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
            & MLSMSG_Allocate//"defaultMIFs")

d235 1
a235 1
          defaultMIFs(maf)=Hunt(tpGeodAlt(1,:,maf),height)
d240 1
a240 1
    CALL DeallocateL1BData(tpGeodAltData,flag)
d243 1
a243 1
    ! MIFs we would choose in the sampled=1 case.
d246 1
a246 1
    noProfs=NINT(noMAFs*sampled)
d249 5
d261 1
a261 1
            & MLSIntrumentModuleNames(instrumentModule)//l1bItemName
d264 2
a265 3
       CALL ReadL1BData(l1bInfo%l1boaid,l1bItemName,noMAFsl, &
            & l1bFlag,l1bField, &
            & firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex)
d269 41
a309 1
       ! Got to here ******************************
d312 13
d402 4
a405 1
! $Log$
@

