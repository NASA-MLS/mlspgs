head	2.112;
access;
symbols
	V2-21:2.111
	V2-20:2.111
	V2-11:2.111
	V2-10:2.111
	V2-00:2.109
	V1-51:2.104
	V1-50:2.104
	V1-45:2.103
	V1-44:2.103
	V1-43:2.101
	V1-42:2.97
	V1-41:2.97
	V1-32:2.97
	V1-40:2.97
	V1-31:2.97
	V1-30:2.96
	V1-13:2.93
	V1-12:2.93
	V1-11:2.93
	V1-10:2.91
	newfwm-feb03:2.91.0.2
	V1-04:2.69
	V1-03:2.69
	V1-02:2.69
	V1-00:2.69
	newfwm-sep01:2.44.0.2
	V0-7:2.44
	V0-5-Level2:2.21
	V0-5-SIPS:2.13;
locks; strict;
comment	@# @;


2.112
date	2007.06.08.22.09.53;	author vsnyder;	state dead;
branches;
next	2.111;

2.111
date	2006.08.01.03.18.27;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2006.08.01.02.49.08;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2006.05.23.22.37.25;	author vsnyder;	state Exp;
branches;
next	2.108;

2.108
date	2006.05.23.21.43.34;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2005.06.22.20.45.29;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2005.06.22.17.25.49;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2005.06.21.23.57.13;	author livesey;	state Exp;
branches;
next	2.104;

2.104
date	2004.10.14.04.54.06;	author livesey;	state Exp;
branches;
next	2.103;

2.103
date	2004.07.07.19.34.30;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2004.05.17.22.06.35;	author livesey;	state Exp;
branches;
next	2.101;

2.101
date	2004.01.30.23.19.24;	author livesey;	state Exp;
branches;
next	2.100;

2.100
date	2004.01.29.03.31.18;	author livesey;	state Exp;
branches;
next	2.99;

2.99
date	2004.01.28.01.56.48;	author livesey;	state Exp;
branches;
next	2.98;

2.98
date	2004.01.24.01.02.12;	author livesey;	state Exp;
branches;
next	2.97;

2.97
date	2003.10.09.22.15.46;	author livesey;	state Exp;
branches;
next	2.96;

2.96
date	2003.08.05.19.32.12;	author livesey;	state Exp;
branches;
next	2.95;

2.95
date	2003.06.30.20.21.40;	author livesey;	state Exp;
branches;
next	2.94;

2.94
date	2003.06.03.19.21.08;	author livesey;	state Exp;
branches;
next	2.93;

2.93
date	2003.02.22.00.41.54;	author livesey;	state Exp;
branches;
next	2.92;

2.92
date	2003.02.21.04.06.14;	author livesey;	state Exp;
branches;
next	2.91;

2.91
date	2003.02.07.11.25.28;	author mjf;	state Exp;
branches;
next	2.90;

2.90
date	2003.01.10.02.47.06;	author livesey;	state Exp;
branches;
next	2.89;

2.89
date	2003.01.09.01.21.27;	author livesey;	state Exp;
branches;
next	2.88;

2.88
date	2003.01.08.23.51.12;	author livesey;	state Exp;
branches;
next	2.87;

2.87
date	2003.01.08.21.32.29;	author livesey;	state Exp;
branches;
next	2.86;

2.86
date	2002.11.22.12.52.50;	author mjf;	state Exp;
branches;
next	2.85;

2.85
date	2002.10.07.23.24.43;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2002.09.23.23.18.59;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2002.09.13.18.08.12;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2002.09.11.17.43.38;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2002.09.06.15.45.54;	author mjf;	state Exp;
branches;
next	2.80;

2.80
date	2002.09.02.22.56.45;	author livesey;	state Exp;
branches;
next	2.79;

2.79
date	2002.08.29.21.35.34;	author livesey;	state Exp;
branches;
next	2.78;

2.78
date	2002.08.29.04.44.53;	author livesey;	state Exp;
branches;
next	2.77;

2.77
date	2002.08.19.20.50.56;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2002.08.15.22.12.47;	author livesey;	state Exp;
branches;
next	2.75;

2.75
date	2002.08.06.02.15.10;	author livesey;	state Exp;
branches;
next	2.74;

2.74
date	2002.07.22.03.26.25;	author livesey;	state Exp;
branches;
next	2.73;

2.73
date	2002.07.17.06.00.55;	author livesey;	state Exp;
branches;
next	2.72;

2.72
date	2002.07.01.23.49.47;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2002.06.18.01.21.18;	author vsnyder;	state Exp;
branches;
next	2.70;

2.70
date	2002.06.15.00.41.20;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2002.03.12.01.38.33;	author vsnyder;	state Exp;
branches;
next	2.68;

2.68
date	2002.03.05.23.16.35;	author livesey;	state Exp;
branches;
next	2.67;

2.67
date	2002.02.23.02.59.51;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2002.02.23.02.34.10;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2002.02.23.02.13.16;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2002.02.22.20.11.45;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2002.02.22.01.17.41;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2002.02.09.21.27.12;	author livesey;	state Exp;
branches;
next	2.61;

2.61
date	2002.02.05.02.39.59;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2001.12.01.01.02.52;	author livesey;	state Exp;
branches;
next	2.59;

2.59
date	2001.11.14.01.00.07;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2001.11.09.18.12.09;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2001.11.09.02.03.47;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2001.11.08.02.08.04;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2001.10.26.18.08.57;	author livesey;	state Exp;
branches;
next	2.54;

2.54
date	2001.10.20.01.21.02;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2001.10.16.19.28.31;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2001.10.04.23.49.57;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2001.10.03.17.33.11;	author dwu;	state Exp;
branches;
next	2.50;

2.50
date	2001.10.01.23.35.38;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2001.10.01.20.32.27;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2001.09.29.00.25.51;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2001.09.28.17.56.10;	author dwu;	state Exp;
branches;
next	2.46;

2.46
date	2001.09.27.18.41.21;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2001.09.24.23.01.11;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2001.07.19.17.54.59;	author vsnyder;	state Exp;
branches;
next	2.43;

2.43
date	2001.07.16.20.36.49;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2001.07.11.22.07.57;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2001.06.28.01.05.59;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2001.06.27.01.15.10;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2001.06.26.23.56.04;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2001.06.26.20.40.33;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2001.06.04.22.41.37;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2001.06.01.01.03.39;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2001.05.30.21.53.16;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2001.05.30.20.18.01;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2001.05.24.23.15.24;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2001.05.24.18.13.28;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2001.05.22.19.09.13;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2001.05.19.00.13.43;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2001.05.17.20.17.56;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2001.05.12.01.05.23;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2001.05.11.22.02.06;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2001.05.10.22.53.36;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2001.05.10.02.14.11;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2001.05.09.19.45.37;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2001.05.09.01.58.12;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2001.05.08.20.29.40;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2001.05.03.02.10.26;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2001.04.30.23.44.25;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2001.04.30.17.47.18;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.04.28.07.03.21;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2001.04.28.05.04.16;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2001.04.28.04.40.17;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.04.28.01.33.02;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.04.25.00.50.09;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.11.22.43.54;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.02.22.01.55.06;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.02.09.18.37.16;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.01.26.19.00.01;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.01.19.23.50.45;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2000.11.23.01.09.19;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2000.11.15.00.18.26;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2000.11.10.00.28.13;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2000.11.09.01.22.43;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2000.10.13.22.22.48;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2000.10.12.20.10.08;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2000.10.10.23.11.34;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.04.20.24.45;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.112
log
@Replaced by .F90 version
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!OCL INDEPENDENT (dot) ! For LF95 auto-parallelization

!=============================================================================
module MatrixModule_0          ! Low-level Matrices in the MLS PGS suite
!=============================================================================

! This module provides the elementary matrix type.  Blocks of this
! type are used to compose block matrices.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use DOT_M, only: DOT
  use DUMP_0, only: DUMP
  use Gemm_M, only: GEMM
  use Gemv_M, only: GEMV
  use MLSCommon, only: RM, RV, R4, R8
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
  use OUTPUT_M, only: OUTPUT
  use VectorsModule, only: M_LinAlg

  implicit NONE
  private
  public :: Add_Matrix_Blocks, CheckBlocks, CheckIntegrity, CheckForSimpleBandedLayout
  public :: Assignment(=), CholeskyFactor
  public :: CholeskyFactor_0, ClearLower, ClearLower_0, ClearRows, ClearRows_0, CloneBlock, ColumnScale
  public :: Col_L1, CopyBlock, CreateBlock, CreateBlock_0, CyclicJacobi
  public :: DenseCholesky, DenseCyclicJacobi, Densify, DestroyBlock, DestroyBlock_0, Dump
  public :: FrobeniusNorm, GetDiagonal, GetMatrixElement, GetMatrixElement_0
  public :: GetVectorFromColumn
  public :: InvertCholesky, InvertCholesky_0
  public :: InvertDenseCholesky, InvertDenseCholesky_0
  public :: M_Absent, M_Banded, M_Column_Sparse, M_Full, M_Unknown
  public :: MatrixInversion, MatrixInversion_0, MatrixElement_T
  public :: MaxAbsVal, MaxAbsVal_0, MinDiag, MinDiag_0
  public :: Multiply, MultiplyMatrix_XY, MultiplyMatrix_XY_0
  public :: MultiplyMatrix_XY_T, MultiplyMatrix_XY_T_0
  public :: MultiplyMatrix_XTY, MultiplyMatrix_XTY_0
  public :: MultiplyMatrixVector
  public :: MultiplyMatrixVectorNoT
  public :: NullifyMatrix, NullifyMatrix_0
  public :: operator(+), ReflectMatrix, RowScale
  public :: ScaleBlock, SolveCholesky, SolveCholeskyM_0
  public :: Sparsify, Spill, Spill_0, SubBlockLength
  public :: TransposeMatrix, UpdateDiagonal

! =====     Defined Operators and Generic Identifiers     ==============

  interface Assignment(=)
    module procedure AssignBlock
  end interface

  interface CheckIntegrity
    module procedure CheckIntegrity_0
  end interface

  interface CholeskyFactor
    module procedure CholeskyFactor_0
  end interface

  interface CyclicJacobi
    module procedure CyclicJacobi_0
  end interface

  interface ClearLower
    module procedure ClearLower_0
  end interface

  interface ClearRows
    module procedure ClearRows_0
  end interface

  interface ColumnScale
    module procedure ColumnScale_0_r4, ColumnScale_0_r8
  end interface

  interface CreateBlock
    module procedure CreateBlock_0
  end interface

  interface Densify
    module procedure DensifyA, DensifyB
  end interface

  interface DestroyBlock
    module procedure DestroyBlock_0
  end interface

  interface DUMP
    module procedure DUMP_MATRIX_BLOCK
  end interface

  interface FrobeniusNorm
    module procedure FrobeniusNorm_0
  end interface

  interface GetDiagonal
    module procedure GetDiagonal_0_r4, GetDiagonal_0_r8
  end interface

  interface GetMatrixElement
    module procedure GetMatrixElement_0
  end interface

  interface GetVectorFromColumn
    module procedure GetVectorFromColumn_0_r4, GetVectorFromColumn_0_r8
  end interface

  interface InvertCholesky
    module procedure InvertCholesky_0, InvertDenseCholesky_0
  end interface

  interface InvertDenseCholesky
    module procedure InvertDenseCholesky_0
  end interface

  interface MatrixInversion
    module procedure MatrixInversion_0
  end interface

  interface MaxAbsVal
    module procedure MaxAbsVal_0
  end interface

  interface MinDiag
    module procedure MinDiag_0
  end interface

  interface Multiply
    module procedure MultiplyMatrix_XTY_0, &
      & MultiplyMatrixVector_0_r4, MultiplyMatrixVector_0_r8
  end interface

  interface MultiplyMatrixVector ! A^T V
    module procedure MultiplyMatrixVector_0_r4, MultiplyMatrixVector_0_r8
  end interface

  interface MultiplyMatrixVectorNoT ! A V
    module procedure MultiplyMatrixVectorNoT_0_r4, MultiplyMatrixVectorNoT_0_r8
  end interface

  interface MultiplyMatrix_XY
    module procedure MultiplyMatrix_XY_0
  end interface

  interface MultiplyMatrix_XY_T
    module procedure MultiplyMatrix_XY_T_0
  end interface

  interface MultiplyMatrix_XTY
    module procedure MultiplyMatrix_XTY_0
  end interface

  interface NullifyMatrix
    module procedure NullifyMatrix_0
  end interface

  interface operator (+)
    module procedure Add_Matrix_Blocks_Unscaled
  end interface

  interface ReflectMatrix
    module procedure ReflectMatrix_0
  end interface

  interface RowScale
    module procedure RowScale_0_r4, RowScale_0_r8
  end interface

  interface SolveCholesky
    module procedure SolveCholeskyM_0, SolveCholeskyV_0_r4, SolveCholeskyV_0_r8, &
      & SolveCholeskyA_0_r4, SolveCholeskyA_0_r8
  end interface

  interface Sparsify
    module procedure SparsifyA, SparsifyB
  end interface

  interface Spill
    module procedure Spill_0
  end interface

  interface TransposeMatrix
    module procedure TransposeMatrix_0
  end interface

  interface UpdateDiagonal
    module procedure UpdateDiagonal_0_r8, UpdateDiagonalVec_0_r8, &
      & UpdateDiagonal_0_r4, UpdateDiagonalVec_0_r4
  end interface

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MatrixModule_0.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! Parameters for the KIND component of objects of type(MatrixElement_T):
  integer, parameter :: M_Absent = 0         ! An absent block -- assumed zero
  integer, parameter :: M_Banded = 1         ! A banded matrix.  The nonzero
    ! values in each column are assumed to be in a contiguous sequence.  For
    ! column I, R1(I) gives the row of the first nonzero value, and the
    ! nonzero elements are VALUES(R2(I-1)+1:R2(I)).
  integer, parameter :: M_Column_sparse = 2  ! A sparse block in column-sparse
    ! representation.  Only the non-zero values are stored.  For column(I),
    ! R1(I) gives the index in R2 and VALUES for the last stored value.  The
    ! rows of the nonzero values are R2(R1(I-1)+1:R1(I)), and their values are
    ! VALUES(R1(I-1)+1:R1(I)).  R1(0) = 0.
  integer, parameter :: M_Full = 3           ! A non-sparse block
  integer, parameter :: M_Unknown = 4        ! We don't know yet
    ! This is used for reading l2pc files where we don't want to load the block
    ! into memory until we know we need it.  The MatrixModule_0 code doesn't
    ! understand such blocks, so use them with care.

  type MatrixElement_T
    integer :: KIND = M_Absent               ! Kind of block -- one of the
      !                                        M_... parameters above
    integer :: nRows = 0, nCols = 0          ! Numbers of rows and columns
    integer, pointer, dimension(:) :: R1 => NULL()     ! Indexed by the column
      ! number. Used for the first column number if KIND = M_Banded, as
      ! described above for M_Column_sparse if KIND = M_Column_sparse, and not
      ! used otherwise.
    integer, pointer, dimension(:) :: R2 => NULL()     ! Indexed by the
      ! column number if KIND = M_Banded, by elements of R1 if KIND =
      ! M_Column_sparse, and not used otherwise.  See M_Banded and
      ! M_Column_sparse above.
    real(rm), pointer, dimension(:,:) :: VALUES => NULL()   ! Values of the
      ! matrix elements.  Indexed by row and column indices if KIND == M_Full,
      ! by elements in the range of values of R1 if KIND == M_Banded, and by
      ! elements of R2 if KIND == M_Column_sparse.
  end type MatrixElement_T

  ! - - -  Private data     - - - - - - - - - - - - - - - - - - - - - -
  real, parameter, private :: COL_SPARSITY = 0.0  ! If more than this
    ! fraction of the elements between the first and last nonzero in a
    ! column are nonzero, use M_Banded, otherwise use M_Column_Sparse.
  real, parameter, private :: SPARSITY = 0.33     ! If a full matrix has
    ! a greater fraction of nonzeroes than specified by this number, there's
    ! no point in making it sparse.
  logical, save :: CHECKBLOCKS = .false.
  integer, save :: SUBBLOCKLENGTH = 32768

contains ! =====     Public Procedures     =============================

  ! ------------------------------------------  Add_Matrix_Blocks  -----
  function Add_Matrix_Blocks ( XB, YB, SCALE ) result ( ZB )
  ! ZB = XB + [SCALE *] YB
    type(MatrixElement_T), intent(in), target :: XB, YB
    real(r8), intent(in), optional :: SCALE
    type(MatrixElement_T) :: ZB

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyBlock using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignBlock.
  ! !!!!! ===== END NOTE ===== !!!!! 

    integer :: K
!   integer :: I, J, L, N
    real(r8) :: S                            ! My copy of Scale
    type(MatrixElement_T), pointer :: X, Y
    real(kind(zb%values)), pointer :: Z(:,:) ! May be used if Y is col-sparse/banded
    real(kind(zb%values)), pointer :: W(:,:) ! May be used if X is banded
    real(rm), dimension(:,:), pointer :: XD, YD ! For testing
    logical :: OK                       ! For testing

    call nullifyMatrix ( zb ) ! for Sun's still useless compiler
    s = 1.0
    if ( present(scale) ) s = scale

    if ( xb%kind <= yb%kind ) then
      x => xb
      y => yb
    else
      x => yb
      y => xb
    end if
    ! The structure of cases-within-cases below depends on the order of
    ! the M_... parameters, because order of the KIND field values is
    ! used to determine whether to commute the operands.  The M_...
    ! parameters are declared in alphabetical order, and their values
    ! are in the same order as their declarations.  The kind of the XB
    ! operand is less than or equal to the kind of the YB operand.
    if ( x%kind == M_Absent ) then
      call copyBlock ( zb, y )                   ! Zb = y
      return
    end if
    if ( xb%nRows /= yb%nRows .or. xb%nCols /= yb%nCols ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Matrix sizes incompatible in Add_Matrix_Blocks" )
    select case ( x%kind )
    case ( M_Banded )
      select case ( y%kind )
      case ( M_Banded )                          ! X banded, Y banded
        ! Used to be intelligent (below), but didn't work. 
        ! Now we'll compromise, if the structures are identical then
        ! do it quickly, otherwise do it slowly
        if ( all ( x%r1 == y%r1 ) .and. all ( x%r2 == y%r2 ) ) then
          call cloneBlock ( zb, x, "Add_Matrix_Blocks" )
          zb%values = x%values + s * y%values
        else
          ! Do it the slow way for now.
          nullify ( z, w )
          call allocate_test ( z, x%nRows, x%nCols, 'Z in Add_Matrix_Blocks', &
            & ModuleName )
          call allocate_test ( w, y%nRows, y%nCols, 'W in Add_Matrix_Blocks', &
            & ModuleName )
          call densify ( z, x )
          call densify ( w, y )
          z = z + s * w
          call sparsify ( z, zb, 'Z in Add_matrix_block', ModuleName )
          call Deallocate_test ( w, 'W in Add_Matrix_Blocks', ModuleName )
        end if
        
! OLD CODE THAT DIDN'T WORK
!         call allocate_test ( zb%r1, zb%ncols, "zb%r1", ModuleName )
!         zb%r1 = min(x%r1, y%r1)                  ! First nonzero row
!         call allocate_test ( zb%r2, zb%ncols, "zb%r2", ModuleName, lowBound=0 )
!         zb%r2(0) = 0
!         do k = 1, size(x%r1)                     ! Calculate size of Values
!           zb%r2(k) = zb%r2(k-1) + &
!             & max( x%r2(k)-x%r2(k-1)+x%r1(k), y%r2(k)-y%r2(k-1)+y%r1(k) ) - &
!             & zb%r1(k) + 1
!         end do
!         call allocate_test ( zb%values, zb%r2(size(x%r1)), 1, "zb%values", &
!           & ModuleName )
!         zb%values = 0.0_rm ! ??? Improve this by only filling
!         !                    ??? values that don't get set below
!         do k = 1, size(x%r1)
!           i = 1; j = 1; l = 1
!           n = y%r1(k) - x%r1(k)
!           if ( n > 0 ) then ! Copy rows in X that are not in Y
!             zb%values(zb%r2(k-1)+l:zb%r2(k-1)+l-1+n, 1) = &
!               & x%values(x%r2(k-1)+i:x%r2(k-1)+i-1+n, 1)
!             i = i + n
!           else if ( n < 0 ) then ! Copy rows in Y that are not in X
!             n = - n
!             zb%values(zb%r2(k-1)+l:zb%r2(k-1)+l-1+n, 1) = &
!               & y%values(y%r2(k-1)+j:y%r2(k-1)+j-1+n, 1)
!             j = j + n
!           end if
!           l = l + n
!           n = min( x%r1(k) + x%r2(k) - x%r2(k-1) - 1, &
!             &      y%r1(k) + y%r2(k) - y%r2(k-1) - 1 ) - &
!             &      max( x%r1(k), y%r1(k) )
!           zb%values(zb%r2(k-1)+l:zb%r2(k-1)+l-1+n, 1) = &
!             & x%values(x%r2(k-1)+i:x%r2(k-1)+i-1+n, 1) + &
!             & y%values(y%r2(k-1)+j:y%r2(k-1)+j-1+n, 1)
!           i = i + n; j = j + n; l = l + n
!           n = y%r1(k) + y%r2(k) - y%r2(k-1) - &
!             & ( x%r1(k) + x%r2(k) - x%r2(k-1) )
!           if ( n > 0 ) then ! Copy rows of Y that are not in X
!             zb%values(zb%r2(k-1)+l:zb%r2(k-1)+l-1+n, 1) = &
!               & y%values(y%r2(k-1)+j:y%r2(k-1)+j-1+n, 1)
!           else if ( n < 0 ) then ! Copy rows in X that are not in Y
!             n = - n
!             zb%values(zb%r2(k-1)+l:zb%r2(k-1)+l-1+n, 1) = &
!               & x%values(x%r2(k-1)+i:x%r2(k-1)+i-1+n, 1)
!           end if
!         end do
      case ( M_Column_sparse )                   ! X banded, Y col sparse
        ! Make a full matrix, then sparsify it.  There _must_ be a better
        ! way ???
        call allocate_test ( z, y%nRows, y%nCols, "Z in Add_Matrix_Blocks", &
          & ModuleName )
        call densify ( z, y )                    ! z = y%values
        if ( present(scale) ) z = s * z
        do k = 1, x%nCols
          z(x%r1(k): x%r1(k) + x%r2(k) - x%r2(k-1) - 1, k) = &
            & z(x%r1(k): x%r1(k) + x%r2(k) - x%r2(k-1) - 1, k) + &
              & x%values(x%r2(k-1)+1:x%r2(k), 1)
        end do
        call sparsify ( z, zb, "Z in Add_Matrix_Blocks", ModuleName ) ! Zb = Z
      case ( M_Full )                            ! X banded, Y full
        call CopyBlock ( zb, y )                 ! Zb = y
        if ( present(scale) ) zb%values = s * zb%values
        do k = 1, x%nCols
          zb%values(x%r1(k): x%r1(k) + x%r2(k) - x%r2(k-1) - 1, k) = &
            & zb%values(x%r1(k): x%r1(k) + x%r2(k) - x%r2(k-1) - 1, k) + &
              & x%values(x%r2(k-1)+1:x%r2(k), 1)
        end do
      end select
    case ( M_Column_sparse )
      select case ( y%kind )
!     case ( M_Banded )        ! Not needed because of commuted arguments
      case ( M_Column_sparse )                   ! X col sparse, Y col sparse
        ! In the case where the blocks are identical in structure, add it the quick way
        if ( all ( x%r1 == y%r1 ) .and. all ( x%r2 == y%r2 ) ) then
          call cloneBlock ( zb, x, "Add_Matrix_Blocks" )
          zb%values = x%values + s* y%values
        else
          ! Make a full matrix, then sparsify it.  There _must_ be a better
          ! way ???
          call allocate_test ( z, y%nRows, y%nCols, "Z in Add_Matrix_Blocks", &
            & ModuleName )
          call densify ( z, y )                    ! z = y%values
          if ( present(scale) ) z = s * z
          do k = 1, x%nCols
            z(x%r2(x%r1(k-1)+1:x%r1(k)), k) = &
              & z(x%r2(x%r1(k-1)+1:x%r1(k)), k) + &
              & x%values(x%r1(k-1)+1:x%r1(k),1)
          end do
          call sparsify ( z, zb, "Z in Add_Matrix_Blocks", ModuleName ) ! Zb = Z
        end if
      case ( M_Full )                            ! X col sparse, Y full
        call CopyBlock ( zb, y )                 ! Zb = y
        if ( present(scale) ) zb%values = s * zb%values

         do k = 1, x%nCols
           zb%values(x%r2(x%r1(k-1)+1:x%r1(k)), k) = &
             & zb%values(x%r2(x%r1(k-1)+1:x%r1(k)), k) + &
               & x%values(x%r1(k-1)+1:x%r1(k),1)
         end do
      end select
    case ( M_Full )
      select case ( y%kind )
!     case ( M_Banded )        ! Not needed because of commuted arguments
!     case ( M_Column_sparse ) ! Not needed because of commuted arguments
      case ( M_Full )                            ! X full, Y full
        call CloneBlock ( zb, y, "Add_Matrix_Blocks") ! Zb = y, except the values
        zb%values = x%values + s * y%values
      end select
    end select

    if ( checkBlocks ) then
      nullify ( xd, yd )
      call Allocate_test ( xd, xb%nRows, xb%nCols, 'xd', ModuleName )
      call Allocate_test ( yd, yb%nRows, yb%nCols, 'yd', ModuleName )
      call Densify ( xd, xb )
      call Densify ( yd, yb )
      call TestBlock ( zb, xd+yd, ok, 'Add_Matrix_Blocks', xb%kind, yb%kind )
      if ( .not. ok ) then
        call dump ( xb, name='xb', details=2 )
        call dump ( yb, name='yb', details=2 )
      end if
      call Deallocate_test ( xd, 'xd', ModuleName )
      call Deallocate_test ( yd, 'yd', ModuleName )
    end if
  end function Add_Matrix_Blocks

  ! ---------------------------------  Add_Matrix_Blocks_Unscaled  -----
  function Add_Matrix_Blocks_Unscaled ( XB, YB ) result ( ZB ) ! ZB = XB + YB
    type(MatrixElement_T), intent(in), target :: XB, YB
    type(MatrixElement_T) :: ZB

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyBlock using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignBlock.
  ! !!!!! ===== END NOTE ===== !!!!! 

    call nullifyMatrix ( zb ) ! for Sun's still useless compiler
                         ! not sure it's needed here
    zb = add_matrix_blocks ( xb, yb )

  end function Add_Matrix_Blocks_Unscaled 

  ! ------------------------------------------------  AssignBlock  -----
  subroutine AssignBlock ( Z, X )
  ! Destroy Z, then copy X to it, using pointer assignment for pointer
  ! components.  Other than the "Destroy Z" part, the semantics are the
  ! same as for intrinsic assignment.  If one has Z = X in a loop, it
  ! is therefore necessary only to destroy Z after the loop.  Notice
  ! that CopyBlock does a deep copy.
    type(MatrixElement_T), intent(inout) :: Z
    type(MatrixElement_T), intent(in) :: X
    call destroyBlock ( z )
    z%kind = x%kind
    z%nRows = x%nRows; z%nCols = x%nCols
    z%r1 => x%r1
    z%r2 => x%r2
    z%values => x%values
  end subroutine AssignBlock

  ! ------------------------------------------- CheckForSimpleBandedLayout --
  subroutine CheckForSimpleBandedLayout ( z, bandHeight, location )
    type ( MatrixElement_T), intent(in) :: Z
    integer, intent(in) :: BANDHEIGHT
    character(len=*), intent(in) :: LOCATION
    ! Local variables
    integer :: I
    logical :: FLAGS(z%nCols)
    ! Executable code
    if ( mod ( size ( z%values, 1 ), bandHeight ) /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Inappropriate banded size for ' // &
      & trim(location) )
    do i = 1, z%nCols
      flags(i) = ( z%r2(i) /= i*bandHeight ) .or. &
        & ( z%r1(i) /= 1 + z%r2(i) - bandHeight )
    end do
    if ( any(flags) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Inappropriate format for ' // trim(location) )
  end subroutine CheckForSimpleBandedLayout

  ! ------------------------------------------- CheckIntegrity_0 -------
  logical function CheckIntegrity_0 ( block, noError )
    use IEEE_Arithmetic, only: IEEE_IS_NAN
    type ( MatrixElement_T), intent(in) :: BLOCK
    logical, optional, intent(in) :: NOERROR

    ! Local variables
    integer :: MESSAGETYPE
    integer :: I                        ! Loop counter
    integer :: N                        ! No entries in a column
    character(len=80) :: CLAUSE         ! Part of error/warning message
    
    ! Executable code

    messageType = MLSMSG_Error
    if ( present ( noError ) ) then
      if ( noError ) messageType = MLSMSG_Warning
    end if

    checkIntegrity_0 = .true.

    ! Check dimensions
    if ( block%nRows < 0 ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Block is negative nRows' )
      checkIntegrity_0 = .false.
    end if
    if ( block%nCols < 0 ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Block is negative nCols' )
      checkIntegrity_0 = .false.
    end if

    ! Check associated stuff
    if ( block%kind == m_absent .or. block%kind == m_unknown ) then
      if ( associated ( block%values ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block is absent/unknown yet has values associated' )
        checkIntegrity_0 = .false.
      end if
    else
      if ( .not. associated ( block%values ) ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Block has no values associted, but not absent/unkown')
        checkIntegrity_0 = .false.
      end if
      if ( any ( lbound ( block%values ) /= (/1,1/) ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block is had bad lbound on values.' )
        checkIntegrity_0 = .false.
      end if
    end if
    if ( any ( block%kind == (/ m_absent, m_unknown /) ) ) then
      if ( associated ( block%R1 ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block is absent/unknown yet has R1 associated' )
        checkIntegrity_0 = .false.
      end if
      if ( associated ( block%R2 ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block is absent/unknown yet has R2 associated' )
        checkIntegrity_0 = .false.
      end if
    end if
    if ( block%kind == m_full ) then
      if ( size ( block%R1 ) /= 0 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block is full yet has non zero R1 allocated' )
        checkIntegrity_0 = .false.
      end if
      if ( size ( block%R2 ) /= 0 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block is full yet has non zero R2 allocted' )
        checkIntegrity_0 = .false.
      end if
    end if

    if ( block%kind == m_banded .or. block%kind == m_column_sparse ) then
      if ( .not. associated ( block%r1 ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block is banded/sparse yet has no R1 associated' )
        checkIntegrity_0 = .false.
      end if
      if ( .not. associated ( block%r2 ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block is banded/sparse yet has no R2 associated' )
        checkIntegrity_0 = .false.
      end if
    end if

    if ( block%kind == m_banded ) then
      ! Check lbound
      if ( lbound ( block%r1,1 ) /= 1 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Banded block has bad lbound on R1' )
        checkIntegrity_0 = .false.
      end if
      if ( lbound ( block%r2,1 ) /= 0 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Banded block has bad lbound on R2' )
        checkIntegrity_0 = .false.
      end if
      ! Check ubound
      if ( ubound ( block%r1,1 ) /= block%nCols ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Banded block has bad ubound on R1' )
        checkIntegrity_0 = .false.
      end if
      if ( ubound ( block%r2,1 ) /= block%nCols ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Banded block has bad ubound on R2' )
        checkIntegrity_0 = .false.
      end if
      ! Check values
      if ( block%r2(0) /= 0 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Banded block has bad first value in R2' )
        checkIntegrity_0 = .false.
      end if
      if ( any ( (/ block%r1(:), block%r2(:) /) < 0 ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Banded block has -ve value(s) in R1/R2' )
        checkIntegrity_0 = .false.
      end if
      if ( any ( (/ block%r2(:) /) > ubound ( block%values,1 ) ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Banded block has too large value(s) in R2' )
        checkIntegrity_0 = .false.
      end if
      do i = 1, block%nCols
        write ( clause, * ) i
        clause = ' column ' // adjustl ( clause )
        n =  block%r2(i) - block%r2(i-1)
        if ( n < 0 ) then
          call MLSMessage ( messageType, ModuleName, &
            & 'Banded block has too small a delta in R2 for' // trim(clause) )
          checkIntegrity_0 = .false.
        end if
        if ( n > 0 ) then
          if ( block%r1(i) + n > block%nRows ) then
            call MLSMessage ( messageType, ModuleName, &
              & 'Banded block has too large a delta in R2 or value for R1 for' // &
              & trim(clause) )
            checkIntegrity_0 = .false.
          end if
          if ( block%r1(i) == 0 ) then
            call MLSMessage ( messageType, ModuleName, &
              & 'Banded block contains 0 for R1 in non empty column for' // &
              & trim(clause) )
          end if
        end if
      end do
      if ( ubound(block%values,2) /= 1 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Banded block has bad ubound(2) for values' )
        checkIntegrity_0 = .false.
      end if
    end if

    if ( block%kind == m_column_sparse ) then
      ! Check lbound
      if ( lbound ( block%r1,1 ) /= 0 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Column sparse block has bad lbound on R1' )
        checkIntegrity_0 = .false.
      end if
      if ( lbound ( block%r2,1 ) /= 1 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Column sparse block has bad lbound on R2' )
        checkIntegrity_0 = .false.
      end if
      ! Check ubound
      if ( ubound ( block%r1,1 ) /= block%nCols ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Column sparse block has bad ubound on R1' )
        checkIntegrity_0 = .false.
      end if
      if ( ubound ( block%r2,1 ) /= ubound(block%values,1) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Column sparse block has bad ubound on R2' )
        checkIntegrity_0 = .false.
      end if
      ! Check values
      if ( block%r1(0) /= 0 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Column sparse block has bad first value in R1' )
        checkIntegrity_0 = .false.
      end if
      if ( any ( (/ block%r1(1:), block%r2(:) /) < 1 ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Column sparse block has 0/-ve value(s) in R1/R2' )
        checkIntegrity_0 = .false.
      end if
      if ( any ( (/ block%r1(1:) /) > ubound(block%r2,1) ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Column sparse block has too large value(s) in R1' )
        checkIntegrity_0 = .false.
      end if
      if ( any ( (/ block%r2(:) /) > block%nRows ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Column sparse block has too large value(s) in R2' )
        checkIntegrity_0 = .false.
      end if
      do i = 1, block%nCols
        write ( clause, * ) i
        clause = ' column ' // adjustl ( clause )
        n =  block%r1(i) - block%r1(i-1) - 1
        if ( n < 0 ) then
          call MLSMessage ( messageType, ModuleName, &
            & 'Column sparse block has too small a delta in R1 for ' // &
            & trim(clause) )
          checkIntegrity_0 = .false.
        end if
        if ( block%r1(i) + n > ubound ( block%r2, 1 ) ) then
          call MLSMessage ( messageType, ModuleName, &
            & 'Column sparse block has too large a delta in R1 for ' // &
            & trim(clause) )
          checkIntegrity_0 = .false.
        end if
      end do
      if ( ubound(block%values,2) /= 1 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Column sparse block has bad ubound(2) for values' )
        checkIntegrity_0 = .false.
      end if
    end if

    if ( block%kind == m_full ) then 
      if ( ubound ( block%values,1 ) /= block%nRows ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block nRows inconsistent with dimensions of values' )
        checkIntegrity_0 = .false.
      end if
      if ( ubound ( block%values,2 ) /= block%nCols ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block nCols inconsistent with dimensions of values' )
        checkIntegrity_0 = .false.
      end if
    end if

    ! Check the values themselves
    if ( all ( block%kind /= (/ m_absent, m_unknown /) ) ) then
      if ( any ( ieee_is_nan ( block%values ) ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Block has invalid number(s) in values' )
        checkIntegrity_0 = .false.
      end if
    end if

  end function CheckIntegrity_0

  ! -------------------------------------------  CholeskyFactor_0  -----
  subroutine CholeskyFactor_0 ( Z, XOPT, STATUS )
  ! If XOPT is present compute Z such that Z^T Z = XOPT and Z is upper-
  ! triangular. Otherwise, replace Z such that Z(output)^T Z(output) =
  ! Z(input) and Z(output) is upper-triangular.
    type(MatrixElement_T), target, intent(inout) :: Z
    type(MatrixElement_T), target, intent(in), optional :: XOPT
    integer, intent(out), optional :: STATUS

    real(rm) :: D             ! Diagonal(I,I) element of Z
    real(rm) :: G             ! X(I,J) - dot_product(X(1:i-1,i),X(1:i-1,j))
    integer :: I, J           ! Subscripts and loop inductors
    integer :: II, IJ         ! Subscripts in VALUES for I,I and I,J components
    !                           in the case of M_Banded
    integer :: NC             ! Number of columns
    integer, pointer, dimension(:) :: R1      ! First nonzero row of Z (Banded)
    integer :: RZ             ! Starting row in Z for inner product (Banded)
    real(rm), save :: TOL = -1.0_rm
    real(rm), pointer, dimension(:,:) :: XIN  ! A pointer to the input,
    !                           data, or a densified copy of it
    type(MatrixElement_T), pointer :: X       ! XOPT or Z, depending on whether
    !                           XOPT is present or absent, respectively.
    real(rm), pointer, dimension(:,:) :: ZT   ! A local full result that is
    !                           sparsified at the end.
    real(rm), pointer, dimension(:,:) :: TST1, TST2 ! When using checkblock
    logical :: OK                       ! For testing

    if ( tol < 0.0_rm ) tol = sqrt(tiny(0.0_rm))
    nullify ( r1, xin, zt )
    x => z
    if ( present(xopt) ) x => xopt
    nc = x%nCols
    if ( nc /= x%nRows )&
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Cannot CholeskyFactor a non-square block" )
    select case ( x%kind )
    case ( M_Absent )
      if ( present(status) ) then
        status = 1
        return
      end if
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Cannot CholeskyFactor an empty block" )
    case ( M_Banded )
      call allocate_test ( zt, nc, nc, "ZT in CholeskyFactor", &
        & ModuleName )
      call allocate_test ( r1, nc, "R1 in CholeskyFactor", ModuleName )
      do i = 1, nc
        r1(i) = i             ! We know the diagonal will get a value
      end do
      do i = 1, nc
        ii = i - x%r1(i)      ! Offset in VALUES of (I,I) element
        if ( ii < 0 .or. ii > x%r2(i) - x%r2(i-1) ) then
          if ( present(status) ) then
            status = i
            return
          end if
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Matrix in CholeskyFactor is not positive-definite." )
        end if
        zt(i,1:i-1) = 0.0_rm  ! Clear left from the diagonal (helps Sparsify!)
        g = x%values(ii+x%r2(i-1)+1,1) - &
            & dot( i-r1(i), zt(r1(i),i), 1, zt(r1(i),i), 1 )
!       g = x%values(ii+x%r2(i-1)+1,1) - &
!           & dot_product( zt(r1(i):i-1,i), zt(r1(i):i-1,i) )
        if ( g <= tol .and. i < nc ) then
          if ( present(status) ) then
            status = i
            return
          end if
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Matrix in CholeskyFactor is not positive-definite." )
        end if
        d = sqrt(g)
        zt(i,i) = d
!$OMP PARALLEL DO private ( ij, rz, g )
        do j = i+1, nc
          ij = i - x%r1(j)    ! Offset in VALUES of (I,J) element
          rz = max(r1(i),r1(j))
          if ( i <= rz ) then
            g = 0.0
          else
            g = - dot( i-rz, zt(rz,i), 1, zt(rz,j), 1 )
!           g = - dot_product( zt(rz:i-1,i), zt(rz:i-1,j) )
          end if
          if ( ij >= 0 .and. ij <= x%r2(j) - x%r2(j-1) ) &
            & g = x%values(ij+x%r2(j-1)+1,1) + g
          zt(i,j) = g / d
          if ( abs(zt(i,j)) >= tiny(0.0_rm) ) r1(j) = min( r1(j), i )
        end do ! j
!$OMP END PARALLEL DO
      end do ! i
      ! Sparsify the result.  We do it here because Sparsify is slow, and
      ! we know something about the structure: the first and last nonzero
      ! rows in each column.
      j = 1 ! number of nonzeroes
      do i = 2, nc
        j = j + i + 1 - r1(i)
      end do
      call createBlock ( z, nc, nc, M_Banded, j, forWhom="CholeskyFactor_0" )
      z%r1 = r1
      do i = 1, nc
        z%r2(i) = z%r2(i-1) + i + 1 - r1(i)
        z%values(z%r2(i-1)+1:z%r2(i),1) = zt(r1(i):i,i)
      end do ! i
      call deallocate_test ( r1, "R1 in CholeskyFactor", ModuleName )
      call deallocate_test ( zt, "ZT in CholeskyFactor", ModuleName )
      if ( present ( status ) ) status = 0
    case ( M_Column_Sparse )
      call allocate_test ( zt, nc, nc, "ZT for CholeskyFactor", ModuleName )
      call allocate_test ( xin, nc, nc, "XIN for CholeskyFactor", ModuleName )
      ! ??? Densify and then compute Cholesky decomposition of dense block.
      ! ??? If necessary, improve this in level 1.0 by working directly
      ! ??? with sparse input.
      call densify ( xin, x )
      call denseCholesky ( zt, xin, status )
      if ( present ( status ) ) then
        if ( status /= 0 ) return
      end if
      call sparsify ( zt, z, "ZT in CholeskyFactor", ModuleName ) ! Z := Zt
      call deallocate_test ( xin, "XIN in CholeskyFactor", ModuleName )
    case ( M_Full )
      if ( .not. associated(x,z) ) then
        call createBlock ( z, nc, nc, M_Full, forWhom="CholeskyFactor_0" )
      end if
      call denseCholesky ( z%values, x%values, status )
    end select

    if ( checkBlocks ) then
      nullify ( tst1, tst2 )
      call Allocate_test ( tst1, z%nRows, z%nCols, 'tst1', ModuleName )
      call Allocate_test ( tst2, z%nRows, z%nCols, 'tst2', ModuleName )
      call densify ( tst1, x )
      call denseCholesky ( tst2, tst1 )
      call testBlock ( z, tst2, ok, 'CholeskyFactor', z%kind )
      if ( .not. ok ) then
        call dump ( z, name='z', details=2 )
      end if
      call Deallocate_test ( tst1, 'tst1', ModuleName )
      call Deallocate_test ( tst2, 'tst2', ModuleName )
    end if
  end subroutine CholeskyFactor_0

  ! ------------------------------------------------  ClearLower_0 -----
  subroutine ClearLower_0 ( X )
    ! Clear the loewr triangle of X
    type ( MatrixElement_T ), intent(inout) :: X
    ! Local variables
    integer :: I,J                      ! Subscripts
    integer :: KIND                     ! Original matrix kind
    ! Executable code
    kind = x%kind
    ! For sparse matrices, simplest just to densify and then resparsify
    if ( kind == m_Banded .or. kind == m_Column_sparse ) &
      & call Densify ( X )
    do i = 2, x%nRows
      do j = 1, i - 1
        x%values ( i, j ) = 0.0_rm
      end do
    end do
    if ( kind == m_Banded .or. kind == m_column_sparse ) &
      & call Sparsify ( X )
  end subroutine ClearLower_0

  ! ------------------------------------------------  ClearRows_0  -----
  subroutine ClearRows_0 ( X, MASK )
  ! Clear the rows of X for which MASK has a nonzero M_LinAlg bit.
    type(MatrixElement_T), intent(inout) :: X
    character, dimension(1:), intent(in) :: MASK
    integer :: I, J                ! Subscripts and row indices
    select case ( x%kind )
    case ( M_Absent )
    case ( M_Banded )              ! ??? Adjust the sparsity representation ???
      do j = 1, x%nCols
        do i = x%r1(j), x%r1(j) + x%r2(j) - x%r2(j-1) - 1 ! row numbers
          if ( iand( ichar(mask(i)), m_LinAlg ) /= 0 ) &
            & x%values(x%r2(j-1) + i - x%r1(j) + 1, 1) = 0.0_rm
        end do ! i
      end do ! j = 1, x%nCols
    case ( M_Column_Sparse )       ! ??? Adjust the sparsity representation ???
!       call Dump ( x, details=2 )
!       if ( .not. CheckIntegrity ( x, noError=.true. ) ) then
!         call Dump ( x, details=2 )
!         stop
!       end if
      do j = 1, x%nCols
        do i = x%r1(j-1)+1, x%r1(j)
          if ( iand( ichar(mask(x%r2(i))), m_LinAlg ) /= 0 ) &
            & x%values(x%r2(i),1) = 0.0_rm
        end do ! i
      end do ! j = 1, x%nCols
    case ( M_Full )
      do i = lbound(mask,1), ubound(mask,1)
        if ( i > x%nRows ) return
        if ( iand( ichar(mask(i)), m_LinAlg ) /= 0 ) &
          & x%values(i,:) = 0.0_rm
      end do ! i = lbound(mask,1), ubound(mask,1)
    end select
  end subroutine ClearRows_0

  ! -------------------------------------------------  CloneBlock  -----
  subroutine CloneBlock ( Z, X, ForWhom ) ! Z = X, except the values
  ! Duplicate a matrix block, including copying all of its structural
  ! descriptive information, but not its values.
    type(MatrixElement_T), intent(inout) :: Z ! intent(inout) so that
      !                            destroyBlock gets a chance to clean up surds
    type(MatrixElement_T), intent(in) :: X
    character(len=*), intent(in) :: ForWhom
    call destroyBlock ( z )
    if ( x%kind == M_absent ) then
      call CreateEmptyBlock ( z )
    else
      z%kind = x%kind
      call allocate_test ( z%r1, ubound(x%r1,1), "z%r1", ModuleName, &
        & lowBound=lbound(x%r1,1) )
      z%r1 = x%r1
      call allocate_test ( z%r2, ubound(x%r2,1), "z%r2", ModuleName, &
        lowBound=lbound(x%r2,1) )
      z%r2 = x%r2
      call allocate_test ( z%values, size(x%values,1), size(x%values,2), &
        & "z%values for " // trim(forWhom), ModuleName )
    end if
    z%nRows = x%nRows; z%nCols = x%nCols
  end subroutine CloneBlock

  ! -------------------------------------------------  ColumnScale_0_r4  -----
  subroutine ColumnScale_0_r4 ( X, V, NEWX ) ! Z = X V where V is a diagonal
  !                                         matrix represented by a vector
  !                                         and Z is either X or NEWX.
    type(MatrixElement_T), intent(inout), target :: X
    real(r4), intent(in), dimension(:) :: V
    type(MatrixElement_T), intent(inout), target, optional :: NEWX ! intent(inout)
      !                            so that the destroyBlock in cloneBlock
      !                            gets a chance to clean up surds
    type(MatrixElement_T), pointer :: Z
    integer :: I

    include "columnscale_0.f9h"
  end subroutine ColumnScale_0_r4

  ! -------------------------------------------------  ColumnScale_0_r8  -----
  subroutine ColumnScale_0_r8 ( X, V, NEWX ) ! Z = X V where V is a diagonal
  !                                         matrix represented by a vector
  !                                         and Z is either X or NEWX.
    type(MatrixElement_T), intent(inout), target :: X
    real(r8), intent(in), dimension(:) :: V
    type(MatrixElement_T), intent(inout), target, optional :: NEWX ! intent(inout)
      !                            so that the destroyBlock in cloneBlock
      !                            gets a chance to clean up surds
    type(MatrixElement_T), pointer :: Z

    integer :: I
    include "columnscale_0.f9h"
  end subroutine ColumnScale_0_r8

  ! -----------------------------------------------------  Col_L1  -----
  real(rm) function Col_L1 ( X, N )
  ! Return the L1 norm of column N of X
    type(MatrixElement_T), intent(in) :: X
    integer, intent(in) :: N
    integer :: I
    col_l1 = 0.0_rm
    select case ( x%kind )
    case ( M_Absent )
    case ( M_Banded )
      do i = x%r2(n-1)+1, x%r2(n)
        col_l1 = col_l1 + abs(x%values(i,1))
      end do
    case ( M_Column_Sparse )
      do i = x%r1(n-1)+1, x%r1(n)
        col_l1 = col_l1 + abs(x%values(i,1))
      end do
    case ( M_Full )
      do i = 1, x%nRows
        col_l1 = col_l1 + abs(x%values(i,n))
      end do
    end select
  end function Col_L1

  ! --------------------------------------------------  CopyBlock  -----
  subroutine CopyBlock ( Z, X ) ! Destroy Z, deep Z = X, including the values
    type(MatrixElement_T), intent(inout) :: Z ! intent(inout) so that the
      !                            destroyBlock in cloneBlock gets a chance
      !                            to clean up surds
    type(MatrixElement_T), intent(in) :: X
    call CloneBlock ( Z, X, "CopyBlock" )
    if ( x%kind /= m_absent ) z%values = x%values
  end subroutine CopyBlock

  ! ----------------------------------------------  CreateBlock_0  -----
  subroutine CreateBlock_0 ( Z, nRows, nCols, Kind, NumberNonzero, NoValues, &
    & BandHeight, Init, ForWhom )
  ! Create a matrix block, but don't fill any elements or structural
  ! information, except if the Values field is created and Init is present,
  ! Values is filled from Init.  The "NumberNonzero" is required if and only
  ! if the "Kind" argument has the value M_Banded or M_Column_Sparse. The
  ! block is first destroyed, so as not to have a memory leak. If NoValues is
  ! present and true, the values component is not allocated.  If Kind ==
  ! M_Banded and BandHeight is present, the band height is assumed to be
  ! uniform, and the R1 and R2 components are filled to reflect that
  ! assumption.

  ! Filling the block after it's created depends on the kind.
  !  M_Absent: Do nothing
  !  M_Banded: The arrays R1 and R2 are indexed by the column number (c).
  !   R1(c) gives the index of the first nonzero row.  R2(c) gives the
  !   subscript in the first dimension of VALUES for the last nonzero element
  !   in the column.  The second dimension of VALUES has shape (1:1).  The
  !   subscript for the first nonzero element is R2(c-1)+1 (R2(0)==0 is set
  !   here).  The number of nonzero elements is R2(c) - R2(c-1).  The index
  !   of the last nonzero row is R1(c) + R2(c) - R2(c-1) - 1.
  !  M_Column_Sparse:  The array R1 is indexed by the column number (c). It
  !   gives the subscripts in R2 and the first dimension of VALUES for
  !   the last entry in the column.  The first one is in R2(R1(c-1)+1)
  !   (R1(0)==0). The number of nonzero entries in a column is R1(c) -
  !   R1(c-1).  The row number of the k'th nonzero in column c is
  !   R2(R1(c-1)+k), and its value is VALUES(R1(c-1)+k),1).
  !  M_Full: R1 and R2 are not used (they are allocated with zero extent).
  !   The value of the (i,j) element of the block is VALUES(i,j).

    type(MatrixElement_T), intent(inout) :: Z
    integer, intent(in) :: nRows, nCols, Kind
    integer, intent(in), optional :: NumberNonzero ! Only for M_Banded and
                                                   ! M_Column_Sparse
    logical, intent(in), optional :: NoValues
    integer, intent(in), optional :: BandHeight
    real(rm), intent(in), optional :: Init         ! Initial value for z%values
    character(len=*), intent(in), optional :: ForWhom ! for allocation

    integer :: I
    logical :: Values
    character(len=63) :: What

    values = .true.
    if ( present(noValues) ) values = .not. noValues
    what = "z%values"
    if ( present(forWhom) ) what = "z%values for " // forWhom
    call destroyBlock ( z )
    select case ( kind )
    case ( M_Absent, M_Unknown )
      call CreateEmptyBlock ( z )
    case ( M_Banded )
      call allocate_test ( z%r1, nCols, "z%r1", ModuleName )
      call allocate_test ( z%r2, nCols, "z%r2", ModuleName, lowBound=0 )
      z%r2(0) = 0
      if ( present(bandHeight) ) then
        do i = 1, nCols
          z%r2(i) = i * bandHeight
          z%r1(i) = 1 + z%r2(i) - bandHeight
        end do
      end if
      if ( values ) &
        & call allocate_test ( z%values, numberNonzero, 1, what, ModuleName )
    case ( M_Column_sparse )
      call allocate_test ( z%r1, nCols, "z%r1", ModuleName, lowBound=0 )
      z%r1(0) = 0
      call allocate_test ( z%r2, numberNonzero, "z%r2", ModuleName )
      if ( values ) &
        & call allocate_test ( z%values, NumberNonzero, 1, what, ModuleName )
    case ( M_Full )
      call allocate_test ( z%r1, 0, "z%r1", ModuleName )
      call allocate_test ( z%r2, 0, "z%r2", ModuleName )
      if ( values ) &
        & call allocate_test ( z%values, nRows, nCols, what, ModuleName )
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Invalid matrix block kind in CreateBlock" )
    end select
    z%nRows = nRows
    z%nCols = nCols
    z%kind = kind
    if ( present(init) .and. values ) z%values = init
  end subroutine CreateBlock_0

  ! ----------------------------------------------  CyclicJacobi_0 -----
  subroutine CyclicJacobi_0 ( MPP, MQP, MPQ, MQQ, VPP, VQP, VPQ, VQQ, V, EPS, TOL )
    ! This rather complicated routine does a 2x2 Block Cyclic Jacobi
    ! This implements part of the algorithm outlined in section 8.4.8 of 
    ! Golub and Van Loan (3rd Edition).
    ! 
    ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
    ! This does rather underhand things with pointers, so be very careful when
    ! using it.  The key is that the Vxx's return pointing to parts of V
    ! it is V that should be deallocated not the Vxxs
    ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
    type(MatrixElement_T), intent(in) :: MPP, MQP, MPQ, MQQ ! Input matrices
    type(MatrixElement_T), intent(out) :: VPP, VQP, VPQ, VQQ ! Eigen vector matrices
    real(rm), dimension(:,:), pointer :: V ! The real array that has the V's information.
    real(rm), intent(in), optional :: EPS ! Convergence tolerance passed to dense routine
    real(rm), intent(in), optional :: TOL ! Convergence tolerance passed to dense routine
    ! Local variables
    real(rm), dimension(:,:), pointer :: M
    integer :: N,N1,N2                  ! Size of matrix and of blocks

    ! Executable code
    n1 = mpp%nRows
    n2 = mqq%nRows
    n = n1 + n2
    ! Could do lots of checking here, that it's square etc, however the calls
    ! to densify below should catch it.
    nullify ( M, V )
    call Allocate_test ( M, n, n, 'M in CyclicJacobi_1', ModuleName )
    call Allocate_test ( V, n, n, 'V in CyclicJacobi_1', ModuleName )
    ! Densify the blocks into M this involves a copy, but I see no way round it.
    call Densify ( M ( :n1,   :n1  ), MPP )
    call Densify ( M ( n1+1:, :n1  ), MQP )
    call Densify ( M ( :n1,   n1+1: ), MPQ )
    call Densify ( M ( n1+1:, n1+1: ), MQQ )
    ! Now call the dense cyclic jacobi routine
    call DenseCyclicJacobi ( M, V, eps=eps, tol=tol )
    ! Now do nasty things with pointers to make the V's point to the right things
    ! Set up the blocks
    vpp%nRows = n1 ; vpp%nCols = n1
    vqp%nRows = n2 ; vqp%nCols = n1
    vpq%nRows = n1 ; vpq%nCols = n2
    vqq%nRows = n2 ; vqq%nCols = n2
    vpp%kind = m_full ; vqp%kind = m_full ; vpq%kind = m_full ; vqq%kind = m_full
    ! Do the pointer assignments
    vpp%values => V ( :n1   , :n1   )
    vqp%values => V ( n1+1: , :n1   )
    vpq%values => V ( :n1   , n1+1: )
    vqq%values => V ( n1+1: , n1+1: )
  end subroutine CyclicJacobi_0

  ! ----------------------------------------------  DenseCholesky  -----
  subroutine DenseCholesky ( ZT, XIN, Status )
  ! Do the Cholesky decomposition of XIN giving ZT.
    real(rm), intent(inout) :: ZT(:,:) ! Inout in case it's associated with XIN
    real(rm), intent(inout) :: XIN(:,:) ! Inout in case it's associated with Z
    integer, intent(out), optional :: Status

    real(rm) :: D
    real(rm), save :: TOL = -1.0_rm
    integer :: I, J, NC

    nc = size(xin,2)
    if ( tol < 0.0_rm ) tol = sqrt(tiny(0.0_rm))
    do i = 1, nc
      zt(i+1:nc,i) = 0.0_rm ! Clear below the diagonal (helps Sparsify!)
      d = xin(i,i) - dot( i-1, zt(1,i), 1, zt(1,i), 1 )
!     d = xin(i,i) - dot_product( zt(1:i-1,i), zt(1:i-1,i) )
      if ( (d <= tol .and. i < nc) .or. (d < 0.0) ) then
        if ( present(status ) ) then
          status = i
          return
        end if
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Matrix in DenseCholesky is not positive-definite." )
      end if
      d = sqrt(d)
      zt(i,i) = d
!$OMP PARALLEL DO
      do j = i+1, nc
        zt(i,j) = ( xin(i,j) - dot( i-1, zt(1,i), 1, zt(1,j), 1 ) ) / d
!       zt(i,j) = ( xin(i,j) - dot_product( zt(1:i-1,i), zt(1:i-1,j) ) ) / d
      end do ! j
!$OMP END PARALLEL DO
    end do ! i
    if ( present(status) ) status = 0
  end subroutine DenseCholesky

  ! ----------------------------------------------  DenseCyclicJacobi --
  subroutine DenseCyclicJacobi ( A, V, eps, tol )
    ! Implements the cyclic Jacobi algoritm (Golub and VanLoan 3rd ed.
    ! Section 8.4.3).  Note that while the matrix is expected to be
    ! symmetric, we do need to have both halves stored.
    real(rm), dimension(:,:), intent(inout) :: A ! Matrix to diagonalize, 
              ! returned with eigen values on diagonal, ~0 off diagonal.
    real(rm), dimension(:,:), intent(out) :: V ! Eigen vector matrix output
    real(rm), optional, intent(in) :: EPS ! Smallest value to go for
    real(rm), optional, intent(in) :: TOL ! Or as fraction of norm
    ! Local variables
    integer :: P, Q                     ! Row indices
    integer :: N                        ! Size of A
    real(rm) :: C, S, T                 ! Sine, Cosine and Tangent terms.
    real(rm) :: myEps, myTol            ! Potential copies of eps and tol
    real(rm) :: norm                    ! Norm to compute
    real(rm), dimension(size(a,1)) :: TMP1, TMP2 ! Workspaces
    ! Executable code
    ! Do some setup
    if ( present ( eps ) ) then
      myEps = eps
    else
      myTol = epsilon ( 0.0_rm )
      if ( present ( tol ) ) myTol = tol
      myEps = myTol * sum ( A ** 2 )
    endif
    n = size ( a, 1 )
    ! Setup V
    V = 0.0_rm
    do p = 1, n
      V ( p, p ) = 1.0_rm
    end do
    ! Now loop through the `sweeps'
    do
      ! call output ( '    Dense pass ' )
      norm = 0.0
      do q = 1, n
        norm = norm + &
          & sum ( A ( q, :q-1 ) ** 2 ) + &
          & sum ( A ( q, q+1: ) ** 2 )
      end do
      ! call output ( norm )
      ! call output ( ' / ' )
      ! call output ( myEps, advance='yes' )
      ! Get out if sufficiently diagonal
      if ( norm <= myEps ) exit
      ! Otherwise walk through matrix
      do p = 1, n-1
        do q = p+1, n
          ! We're going to construct a notional J matrix
          ! which is the identity except that it has
          !   c s
          !  -s c
          ! embedded in it a rows/cols p and q
          ! We then rotate A to A = J^T A J, also change V to VJ
          ! Note that this only affects rows and columns p and q of A and V
          ! So code specially to take advantage of that.
          call SymSchur2 ( A, p, q, c, s, t )
          ! Update A with J^T A J
          ! First do A -> J^T A
          tmp1 = A(p,:)
          tmp2 = A(q,:)
          A(p,:) = c * tmp1 - s * tmp2
          A(q,:) = s * tmp1 + c * tmp2
          ! Now do A -> A J
          tmp1 = A(:,p)
          tmp2 = A(:,q)
          A(:,p) = c * tmp1 - s * tmp2
          A(:,q) = s * tmp1 + c * tmp2
          ! Now do V -> V J
          tmp1 = V(:,p)
          tmp2 = V(:,q)
          V(:,p) = c * tmp1 - s * tmp2
          V(:,q) = s * tmp1 + c * tmp2
        end do
      end do
    end do
  end subroutine DenseCyclicJacobi

  ! ----------------------------------------------------  DensifyA  -----
  subroutine DensifyA ( Z, B )
  ! Given a matrix block B, produce a full matrix Z, even if the matrix
  ! block had a sparse representation.
    real(rm), intent(out) :: Z(:,:)          ! Full matrix to produce
    type(MatrixElement_T), intent(in) :: B   ! Input matrix block
    integer :: I                             ! Column index

    if ( size(z,1) /= b%nRows .or. size(z,2) /= b%nCols ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Incompatible shapes in Densify" )
    end if
    select case ( b%kind )
    case ( M_Absent )
      z = 0.0_rm
    case ( M_Banded )
      z = 0.0_rm
      do i = 1, b%nCols
        z(b%r1(i):b%r1(i)+b%r2(i)-b%r2(i-1)-1,i) = &
          & b%values(b%r2(i-1)+1:b%r2(i),1)
      end do ! i
    case ( M_Column_Sparse )
      z = 0.0_rm
      do i = 1, b%nCols
        z(b%r2(b%r1(i-1)+1:b%r1(i)),i) = b%values(b%r1(i-1)+1:b%r1(i),1)
      end do ! i
    case ( M_Full )
      z = b%values
    end select
  end subroutine DensifyA

  ! ---------------------------------------------  DensifyB ------------
  subroutine DensifyB ( B )
    ! Densify a block 'in place'
    type ( MatrixElement_T ), intent(inout) :: B
    ! Local variables
    real(rm), dimension(:,:), pointer :: Z
    ! Executable code
    if ( b%kind == m_banded .or. b%kind == m_column_sparse ) then
      nullify ( z )
      call Allocate_test ( z, b%nRows, b%nCols, 'Z', ModuleName )
      call Densify ( z, b )
      call Deallocate_test ( b%values, 'b%values', ModuleName )
      call Deallocate_test ( b%r1, 'b%r1', ModuleName )
      call Deallocate_test ( b%r2, 'b%r2', ModuleName )
      b%values => z
      b%kind = m_full
    end if
  end subroutine DensifyB

  ! ---------------------------------------------  DestroyBlock_0  -----
  subroutine DestroyBlock_0 ( B )
    ! Deallocate the pointer components of the matrix block B.  Change
    ! its kind to M_Absent.  Don't clobber b%nRows and b%nCols.
    type(MatrixElement_T), intent(inout) :: B
    ! Don't bother to destroy absent blocks
    if (b%kind /= M_Absent) then
      call deallocate_test ( b%r1, "b%r1", ModuleName )
      call deallocate_test ( b%r2, "b%r2", ModuleName )
      call deallocate_test ( b%values, "b%values", ModuleName )
      b%kind = m_absent
    end if
  end subroutine DestroyBlock_0

  ! ----------------------------------------------  FrobeniusNorm_0 -------
  real(rm) function FrobeniusNorm_0 ( B, lowerOff )
    ! Compute the Frobenius Norm of a matrix (sum of square of elements
    ! possibly only consider the elements below the diagonal )
    type(MatrixElement_T), intent(in) :: B
    logical, optional, intent(in) :: LOWEROFF
    ! Local variables
    logical :: MYLOWEROFF
    integer :: I, J, R, C               ! Indicies etc.
    ! Executable code
    myLowerOff = .false.
    if ( present ( lowerOff ) ) myLowerOff = lowerOff
    ! LowerOff case is more complex
    if ( myLowerOff ) then
      FrobeniusNorm_0 = 0.0
      select case ( b%kind )
      case ( m_absent )
      case ( m_full )
        do c = 1, b%nCols - 1
          FrobeniusNorm_0 = FrobeniusNorm_0 + sum ( b%values ( c+1:b%nRows, c ) ** 2 )
        end do
      case ( m_banded )
        do c = 1, b%nCols - 1
          r = b%r1(c)
          i = b%r2(c-1) + 1
          j = b%r2(c)
          ! Now skip points at and above the diagonal
          if ( r <= c ) i = i + c - r + 1
          FrobeniusNorm_0 = FrobeniusNorm_0 + sum ( b%values ( i:j, 1 ) ** 2 )
        end do
      case ( m_column_sparse )
        do c = 1, b%nCols - 1
          do i = b%r1(c-1) + 1, b%r1(c)
            if ( b%r2(i) > c ) FrobeniusNorm_0 = FrobeniusNorm_0 + b%values(i,1) ** 2
          end do
        end do
      end select
    else
      if ( b%kind == m_absent ) then
        FrobeniusNorm_0 = 0.0
      else
        FrobeniusNorm_0 = sum ( b%values ** 2 )
      end if
    end if
      
  end function FrobeniusNorm_0

  ! ----------------------------------------------  GetDiagonal_0_r4  -----
  subroutine GetDiagonal_0_r4 ( B, X, SquareRoot, Invert, ZeroOK )
  ! Get the diagonal elements of B into X.  Return the square root of the
  ! diagonal elements if SquareRoot is present and true.
    type(MatrixElement_T), intent(in) :: B
    real(r4), dimension(:), intent(out) :: X
    logical, intent(in), optional :: SquareRoot
    logical, intent(in), optional :: Invert
    logical, intent(in), optional :: ZeroOK
    integer :: I, J, N
    logical :: MyZeroOK
 
    include "getdiagonal_0.f9h"
  end subroutine GetDiagonal_0_r4

  ! ----------------------------------------------  GetDiagonal_0_r8  -----
  subroutine GetDiagonal_0_r8 ( B, X, SquareRoot, Invert, ZeroOK )
  ! Get the diagonal elements of B into X.  Return the square root of the
  ! diagonal elements if SquareRoot is present and true.
    type(MatrixElement_T), intent(in) :: B
    real(r8), dimension(:), intent(out) :: X
    logical, intent(in), optional :: SquareRoot
    logical, intent(in), optional :: Invert
    logical, intent(in), optional :: ZeroOK
    integer :: I, J, N
    logical :: MyZeroOK

    include "getdiagonal_0.f9h"
  end subroutine GetDiagonal_0_r8

  ! -----------------------------------------  GetMatrixElement_0  -----
  real(rm) function GetMatrixElement_0 ( Matrix, Row, Col )
  ! Get the (row,col) element of Matrix
    type(matrixElement_T), intent(in) :: Matrix
    integer, intent(in) :: Row, Col
    integer :: J
    select case ( matrix%kind )
    case ( m_absent )
      getMatrixElement_0 = 0.0_rm
    case ( m_banded )
      if ( row < matrix%r1(col) .or. &
        &  row >= matrix%r1(col) + matrix%r2(col)-matrix%r2(col-1) ) then
        getMatrixElement_0 = 0.0_rm
      else
        getMatrixElement_0 = matrix%values(row - matrix%r1(col) + &
          &                                  matrix%r2(col-1) +1, 1)
      end if
    case ( m_column_sparse )
      do j = matrix%r1(col-1)+1, matrix%r1(col)
        if ( row == matrix%r2(j) ) then
          getMatrixElement_0 = matrix%values(j,1)
          return
        end if
      end do
      getMatrixElement_0 = 0.0_rm
    case ( m_full )
      getMatrixElement_0 = matrix%values(row,col)
    end select
  end function GetMatrixElement_0

  ! --------------------------------------  GetVectorFromColumn_0_r4  -----
  subroutine GetVectorFromColumn_0_r4 ( B, Column, X )
  ! Fill the vector X from "Column" of B.
    type(MatrixElement_T), intent(in) :: B
    integer, intent(in) :: Column
    real(r4), dimension(:), intent(out) :: X

    include "getvectorfromcolumn_0.f9h"
  end subroutine GetVectorFromColumn_0_r4

  ! --------------------------------------  GetVectorFromColumn_0_r8  -----
  subroutine GetVectorFromColumn_0_r8 ( B, Column, X )
  ! Fill the vector X from "Column" of B.
    type(MatrixElement_T), intent(in) :: B
    integer, intent(in) :: Column
    real(r8), dimension(:), intent(out) :: X

    include "getvectorfromcolumn_0.f9h"
  end subroutine GetVectorFromColumn_0_r8

  ! -------------------------------------------  InvertCholesky_0  -----
  subroutine InvertCholesky_0 ( U, UI, Square, Status )
  ! Given the upper-triangular matrix U, produce its inverse in UI.
  ! If Square is present and > 0, compute UI = (U**T U)**-1 = U**-1 U**-T.
  ! If Square is present and < 0, compute UI = diag((U**T U)**-1 = U**-1 U**-T).
    type(MatrixElement_T), intent(inout) :: U  ! inout to use InvertDenseCholesky
    type(MatrixElement_T), intent(inout) :: UI ! inout to look at nRows etc.
    integer, intent(in), optional :: Square  ! 0 => nothing special
                                             ! >0 => UI := U**-1 U**-T
                                             ! <0 => UI := diag(U**-1 U**-T)
    integer, intent(out), optional :: Status ! -1 if the kind is M_Absent, else
    !                                   ! Index of zero diagonal, else 0

    integer :: MySquare, MyStatus
    real(rm), pointer, dimension(:,:) :: myUI

    mySquare = 0
    if ( present(square) ) mySquare = square
    myStatus = 0
    nullify ( myUI )
    select case ( u%kind )
    case ( M_Absent )
      myStatus = -1
    case ( M_Banded )
      call allocate_test ( myUI, u%nRows, u%nCols, "myUI in InvertCholesky_0", &
        & moduleName )
      call densify ( myUI, U )
      call invertDenseCholesky ( myUI, myUI, square, .true., myStatus )
      if ( myStatus == 0 ) then
        if ( mySquare < 0 ) then
          call storeDiag
        else
          call sparsify ( myUI, UI, "myUI in InvertCholesky_0", moduleName )
        end if
      end if
    case ( M_Column_Sparse )
      call allocate_test ( myUI, u%nRows, u%nCols, "myUI in InvertCholesky_0", &
        & moduleName )
      call invertDenseCholesky ( myUI, myUI, square, .true., myStatus )
      if ( myStatus == 0 ) then
        if ( mySquare < 0 ) then
          call storeDiag
        else
          call sparsify ( myUI, UI, "myUI in InvertCholesky_0", moduleName )
        end if
      end if
    case ( M_Full )
      if ( UI%kind /= M_Full .or. &
        & UI%nRows /= u%nRows .or. UI%nCols /= u%nCols ) then
        call createBlock ( UI, u%nRows, u%nCols, M_Full, forWhom="InvertCholesky_0" )
      end if
      call invertDenseCholesky ( u%values, UI%values, square, .true., myStatus )
      if ( myStatus == 0 .and. mySquare < 0 ) then ! just computing the diagonal
        myUI => UI%values
        nullify ( UI%values )
        call storeDiag
      end if
    end select

    call deallocate_test ( myUI, "myUI in InvertCholesky_0", moduleName )
    if ( present(status) ) status = myStatus

  contains
    subroutine StoreDiag
      integer :: I
      call createBlock ( UI, u%nRows, u%nCols, M_banded, &
        & numberNonzero = u%nRows, bandHeight = 1, forWhom="InvertCholesky_0" )
      do i = 1, u%nRows
        ui%values(i,1) = myUI(i,i)
      end do
    end subroutine StoreDiag
  end subroutine InvertCholesky_0

  ! --------------------------------------  InvertDenseCholesky_0  -----
  subroutine InvertDenseCholesky_0 ( U, UI, Square, Clear, Status )
  ! Given the upper-triangular matrix U, produce its inverse, UI.  It's OK
  ! if UI and U are the same matrix (see the algorithm description below).
  ! If Square is present and > 0, compute UI = (U**T U)**-1 = U**-1 U**-T.
  ! If Square is present and < 0, compute UI = diag((U**T U)**-1 = U**-1 U**-T).
  ! If Clear is present and true, clear below the diagonal.
    real(rm), intent(inout) :: U(:,:)   ! inout in case U and UI have the
    real(rm), intent(inout) :: UI(:,:)  ! same associated actual argument
    integer, intent(in), optional :: Square  ! 0 => nothing special
                                             ! >0 => UI := U**-1 U**-T
                                             ! <0 => UI := diag(U**-1 U**-T)
    logical, intent(in), optional :: Clear   ! Clear below diagonal
    integer, intent(out), optional :: Status ! Index of zero diagonal, else 0

  !{Let $u_{ij}$ be an element of $\bf U$ and $t_{ij}$ be an element of
  ! ${\bf U}^{-1}$. To invert $\bf U$, solve $\sum_{l=i}^j t_{il} u_{lj} =
  ! \delta_{ij}$ for $t_{ij}$.  (The index of summation $l$ runs from $i$ to
  ! $j$ instead of from $1$ to $n$ because we know that $\bf U$ and ${\bf
  ! U}^{-1}$ are triangular.)  This gives $t_{ii} = u_{ii}^{-1}$ (for $i =
  ! j$) and  $t_{ij} = - \left ( \sum_{l=i}^{j-1} t_{il} u_{lj} \right )
  ! u_{jj}^{-1}$ (for $i < j$).  We compute the diagonal elements of
  ! $U^{-1}$ first, giving the following algorithm:
  !
  ! \hspace*{0.5in}$t_{ii} := u_{ii}^{-1}~~ i = 1,~ \dots,~ n$\\
  ! \hspace*{0.5in}$\left \{ t_{ij} := -\left ( \sum_{l=i}^{j-1} t_{il} u_{lj}
  !   \right ) t_{jj}~~ j = i+1,~ \dots,~ n \right \}~~ i = 1,~ \dots,~ n-1$

    integer :: I, J, N
    character(len=6) :: Where ! for an output message

    ! Check dimensions
    if ( any(shape(u) /= shape(ui)) ) call MLSMessage ( MLSMSG_Error, &
      & moduleName, 'Matrices in InvertCholesky_0 are not the same shape' )

    if ( present(status) ) status = 0

    ! Invert the diagonal elements
    n = size(u,1)
    do j = 1, n
      if ( abs(U(j,j)) <= tiny(0.0_rm) ) then
        if ( present(status) ) then
          status = j
          return
        end if
        write ( where, * ) j
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Matrix in InvertCholesky_0 is singular at ' // &
          & trim(adjustl(where)))
        exit
      end if
      UI(j,j) = 1.0_rm / U(j,j)
    end do

    ! Finish inverting the rest of the matrix.
    do i = 1, n-1
      do j = i+1, n
        UI(i,j) = -dot(j-i, UI(i,i), n, U(i,j), 1) * UI(j,j)
!       UI(i,j) = -dot_product(UI(i,i:j-1),U(i:j-1,j)) * UI(j,j)
      end do
    end do

    if ( present(clear) ) then
      if ( clear ) then            ! Clear below the diagonal
        do j = 1, n
          ui(j+1:,j) = 0.0_rm
        end do
      end if
    end if

    if ( .not. present(square) ) return
    select case ( square )
    case ( 1: )
      ! Replace the upper triangle of UI with the upper triangle of UI * UI**T
      do i = 1, n
        do j = i, n
          UI(i,j) = dot(n-j+1, UI(i,j), n, UI(j,j), n)
!         UI(i,j) = dot_product(UI(i,j:n),UI(j,j:n))
        end do
      end do
    case ( :-1 )
      ! Replace the diagonal of UI with diag(UI * UI**T) and clear the
      ! rest of it.
      do i = 1, n
        ui(i,i) = dot(n-i+1, UI(i,i), n, UI(i,i), n)
!       ui(i,i) = dot_product(UI(i,i:n),ui(i,i:n))
        ui(i,i+1:) = 0.0_rm
      end do
    end select

  end subroutine InvertDenseCholesky_0

  ! ------------------------------------------------  MaxAbsVal_0  -----
  real(rm) function MaxAbsVal_0 ( B )
  ! Return the magnitude of the element in B that has the largest magnitude.
    type(MatrixElement_T), intent(in) :: B
    if ( b%kind == m_absent ) then
      maxAbsVal_0 = 0.0_rm
    else
      maxAbsVal_0 = maxval(abs(b%values))
    end if
  end function MaxAbsVal_0

!---------------------------------------------  MatrixInversion_0  -----
  subroutine MatrixInversion_0 ( A, Upper )
  ! Invert the symmetric positive-definite matrix A in place. If Upper
  ! is present and true, compute only the upper triangle of the inverse.

  real (rm), dimension(:,:),intent(inout) :: A
  logical, intent(in), optional :: Upper

! real (rm), dimension(:,:), pointer :: U
! real (rm), dimension(:), pointer :: b
! real (rm), dimension(:), pointer :: x
  logical :: MyUpper  
! integer :: I, J, N
  integer :: I, N

  myUpper = .false.
  if ( present ( upper) ) myUpper = upper
  n = size(A,2)

  call denseCholesky ( a, a )           ! Replace A by its Cholesky factor
  call invertDenseCholesky ( a, a, square=1 )     ! Replace A by (A^T A)^{-1}

  if ( myUpper ) return

  ! Fill in the lower triangle from the upper one
  do i = 2, n
    a(i,:i-1) = a(:i-1,i)
  end do

! nullify ( x, b, u )
! call allocate_Test ( x, n, "X in MatrixInversion_0", moduleName )
! call allocate_Test ( b, n, "B in MatrixInversion_0", moduleName )
! call allocate_Test ( u, n, n, "U in MatrixInversion_0", moduleName )

! call DenseCholesky (U, A)

! if ( .not. myUpper ) j = n
! do i = 1, n
!   b = 0.0_rm
!   b(i) = 1.0_rm
!   call SolveCholeskyA_0 ( U, x, b, transpose=.true. )
!   b = x
!   call SolveCholeskyA_0 ( U, x, b, transpose=.false. )
!   if ( myUpper ) j = i
!   A(1:j,i) = x(1:j)
! end do

! call deallocate_Test ( x, "X in MatrixInversion_0", moduleName )
! call deallocate_Test ( b, "B in MatrixInversion_0", moduleName )
! call deallocate_Test ( u, "U in MatrixInversion_0", moduleName )

  end subroutine MatrixInversion_0

  ! --------------------------------------------------  MinDiag_0  -----
  real(rm) function MinDiag_0 ( B )
  ! Return the magnitude of the element on the diagonal of B that has the
  ! smallest magnitude.
    type(MatrixElement_T), intent(in) :: B
    integer :: I, J
    select case ( b%kind )
    case ( M_Absent )
      minDiag_0 = 0.0_rm
    case ( M_Banded )
      minDiag_0 = huge(0.0_rm)
      do i = 1, min(b%nRows,b%nCols)
        if ( b%r1(i) <= i .and. b%r1(i) + b%r2(i) - b%r2(i-1) > i ) &
          & minDiag_0 = min(minDiag_0, abs(b%values(b%r2(i-1)+i-b%r1(i)+1,1)))
      end do ! i
    case ( M_Column_Sparse )
      minDiag_0 = huge(0.0_rm)
      do i = 1, min(b%nRows,b%nCols)
        do j = b%r1(i-1)+1, b%r1(i)
          if ( b%r2(j) == i ) then
            minDiag_0 = min(minDiag_0, abs(b%values(j,1)))
            exit ! j loop
          end if
          if ( b%r2(j) > i ) exit ! j loop
        end do ! j
      end do ! i
    case ( M_Full )
      minDiag_0 = abs(b%values(1,1))
      do i = 2, min(b%nRows,b%nCols)
        minDiag_0 = min(minDiag_0, abs(b%values(i,i)))
      end do ! i
    end select
  end function MinDiag_0

  ! ----------------------------------------  MultiplyMatrix_XY_0  -----
  subroutine MultiplyMatrix_XY_0 ( XB, YB, ZB, Update, Subtract )
  ! If Update is absent or false, ZB = +/- XB YB.
  ! Otherwise, ZB = ZB +/- XB YB
  ! The +/- is + unless subtract is present and true.
  !??? Someday, do sparse multiplies in the non-M_Full cases.
    type(MatrixElement_T), intent(in) :: XB, YB
    type(MatrixElement_T), intent(inout) :: ZB
    logical, intent(in), optional :: Update, Subtract

    real(rm) :: Alpha                   ! -1 or 1 depending on subtract
    real(rm) :: Beta                    ! 0 or 1, depending on Update
    logical :: MyX, MyY                 ! Did X or Y result from densify?
    real(rm), pointer, dimension(:,:) :: X, Y, Z  ! Dense matrices

    alpha = 1.0_rm
    if ( present(subtract) ) then
      if ( subtract ) alpha = -1.0_rm
    end if

    beta = 0.0_rm
    if ( present(update) ) then
      if ( update ) beta = 1.0_rm
    end if
    
    if ( xb%kind == M_Absent .or. yb%kind == M_Absent ) then
      if ( abs(beta) < 0.5_rm ) &
        & call createBlock ( zb, xb%nRows, yb%nCols, M_Absent, forWhom="MultiplyMatrix_XY_0" )
      return
    end if

    if ( xb%nCols /= yb%nRows ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "XB and YB Matrix sizes incompatible in MultiplyMatrix_XY_0" )

    nullify ( z )
    call allocate_test ( z, xb%nRows, yb%nCols, 'Z in MultiplyMatrix_XY_0', &
      & moduleName )
    if ( abs(beta) < 0.5_rm ) then
      z = 0.0_rm
    else
      call densify ( z, zb )
    end if

    myX = xb%kind /= M_Full
    if ( .not. myX ) then
      x => xb%values
    else
      nullify ( x )
      call allocate_test ( x, xb%nRows, xb%nCols, 'X in MultiplyMatrix_XY_0', &
        & moduleName )
      call densify ( x, xb )
    end if

    myY = yb%kind /= M_Full
    if ( .not. myY ) then
      y => yb%values
    else
      nullify ( y )
      call allocate_test ( y, yb%nRows, yb%nCols, 'Y in MultiplyMatrix_XY_0', &
        & moduleName )
      call densify ( y, yb )
    end if

    ! zb%noRows/zb%noCols undefined here, so avoid using them.
    call gemm ( 'N', 'N', xb%nRows, yb%nCols, xb%nCols, alpha, &
      & x, xb%nRows, y, yb%nRows, beta, z, xb%nRows )

    if ( myX .and. myY ) then
      call sparsify ( z, zb, 'Z in MultiplyMatrix_XY_0', moduleName ) ! Zb := Z
    else
      call createBlock ( zb, xb%nRows, yb%nCols, m_full, noValues=.true., &
        & forWhom="MultiplyMatrix_XY_0" )
      zb%values => z
    end if
    if ( myX ) call deallocate_test ( x, 'X in MultiplyMatrix_XY_0', moduleName )
    if ( myY ) call deallocate_test ( y, 'Y in MultiplyMatrix_XY_0', moduleName )

  end subroutine MultiplyMatrix_XY_0

  ! --------------------------------------  MultiplyMatrix_XY_T_0  -----
  subroutine MultiplyMatrix_XY_T_0 ( XB, YB, ZB, Update, Subtract )
  ! If Update is absent or false, ZB = +/- XB YB^T.
  ! Otherwise, ZB = ZB +/- XB YB^T.
  ! The +/- is + unless subtract is present and true.
  !??? Someday, do sparse multiplies in the non-M_Full cases.
    type(MatrixElement_T), intent(in) :: XB, YB
    type(MatrixElement_T), intent(inout) :: ZB
    logical, intent(in), optional :: Update, Subtract

    real(rm) :: Alpha                   ! -1 or 1 depending on subtract
    real(rm) :: Beta                    ! 0 or 1, depending on Update
    logical :: MyX, MyY                 ! Did X or Y result from densify?
    real(rm), pointer, dimension(:,:) :: X, Y, Z  ! Dense matrices


    alpha = 1.0_rm
    if ( present(subtract) ) then
      if ( subtract ) alpha = -1.0_rm
    end if

    beta = 0.0_rm
    if ( present(update) ) then
      if ( update ) beta = 1.0_rm
    end if
    
    if ( xb%kind == M_Absent .or. yb%kind == M_Absent ) then
      if ( abs(beta) < 0.5_rm ) &
        & call createBlock ( zb, xb%nRows, yb%nRows, M_Absent, forWhom="MultiplyMatrix_XY_T_0" )
      return
    end if

    if ( xb%nCols /= yb%nCols ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "XB and YB Matrix sizes incompatible in MultiplyMatrix_XY_T_0" )

    nullify ( z )
    call allocate_test ( z, xb%nRows, yb%nRows, 'Z in MultiplyMatrix_XY_T_0', &
      & moduleName )
    if ( abs(beta) < 0.5_rm ) then
      z = 0.0_rm
    else
      call densify ( z, zb )
    end if

    myX = xb%kind /= M_Full
    if ( .not. myX ) then
      x => xb%values
    else
      nullify ( x )
      call allocate_test ( x, xb%nRows, xb%nCols, 'X in MultiplyMatrix_XY_T_0', &
        & moduleName )
      call densify ( x, xb )
    end if

    myY = yb%kind /= M_Full
    if ( .not. myY ) then
      y => yb%values
    else
      nullify ( y )
      call allocate_test ( y, yb%nRows, yb%nCols, 'Y in MultiplyMatrix_XY_T_0', &
        & moduleName )
      call densify ( y, yb )
    end if

    ! zb%nRows/zb%nCols undefined here, so don't use them.
    call gemm ( 'N', 'T', xb%nRows, yb%nRows, xb%nCols, alpha, &
      & x, xb%nRows, y, yb%nRows, beta, z, xb%nRows )

    if ( myX .and. myY ) then
      call sparsify ( z, zb, 'Z in MultiplyMatrix_XY_T_0', moduleName ) ! Zb := Z
    else
      call createBlock ( zb, xb%nRows, yb%nRows, M_Full, noValues=.true., &
        & forWhom="MultiplyMatrix_XY_T_0" )
      zb%values => z
    endif
    if ( myX ) call deallocate_test ( x, 'X in MultiplyMatrix_XY_T_0', moduleName )
    if ( myY ) call deallocate_test ( y, 'Y in MultiplyMatrix_XY_T_0', moduleName )

  end subroutine MultiplyMatrix_XY_T_0

  ! ---------------------------------------  MultiplyMatrix_XTY_0  -----
  subroutine MultiplyMatrix_XTY_0 ( XB, YB, ZB, UPDATE, SUBTRACT, XMASK, YMASK, &
    &                               UPPER )
  ! ZB = XB^T YB if UPDATE is absent or false and SUBTRACT is absent or false;
  ! ZB = -XB^T YB if UPDATE is absent or false and SUBTRACT is present and
  !      true;
  ! ZB = ZB + XB^T YB if UPDATE is present and true and  SUBTRACT is absent
  !      or false;
  ! ZB = ZB - XB^T YB if UPDATE is present and true and  SUBTRACT is present
  !      and true;
  ! If XMASK (resp. YMASK) is present and associated, ignore columns of XB
  ! (resp. YB) that correspond to elements with a nonzero M_LinAlg bit of
  ! XMASK (resp. YMASK).
  ! If UPPER is present and true, compute only the upper triangle of ZB.
    type(MatrixElement_T), intent(in) :: XB, YB
    type(MatrixElement_T), intent(inout) :: ZB
    logical, intent(in), optional :: UPDATE
    logical, intent(in), optional :: SUBTRACT
    character, optional, pointer, dimension(:) :: XMASK, YMASK ! intent(in)
    logical, intent(in), optional :: UPPER

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! If UPDATE is absent or false, it is important to invoke DestroyBlock
  ! for ZB after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignBlock.
  ! !!!!! ===== END NOTE ===== !!!!! 

    integer :: I, J, K, L, M, MZ, N
    integer :: XI_1, XI_N, XR_1, XR_N, YI_1, YI_N, YR_1, YR_N, CR_1, CR_N, C_N
    integer :: RS, R0, R1, RN           ! Row indicies used for 'blocking' full/full
    logical :: MY_SUB, MY_UPD, MY_UPPER
    real(rm) :: S                            ! Sign, subtract => -1 else +1
    integer :: XD, YD
    character, pointer, dimension(:) :: XM, YM
    real(rm) :: XY                           ! Product of columns of X and Y
    real(rm), pointer, dimension(:,:) :: Z   ! Temp for sparse * sparse

    real(rm), pointer, dimension(:,:) :: XDNS, YDNS, ZDNS, ZDNS2 ! For checking

    character(len=132) :: LINE          ! A message
    logical :: OK                       ! For testing

    nullify ( xm, ym, z )
    my_upd = .false.
    if ( present(update) ) my_upd = update

    my_sub = .false.
    if ( present(subtract) ) my_sub = subtract
    s = 1.0_rm
    if ( my_sub ) s = -1.0_rm
    if ( present(xmask) ) xm => xmask
    if ( present(ymask) ) ym => ymask
    my_upper = .false.
    if ( present(upper) ) my_upper = upper

    if ( xb%nRows /= yb%nRows ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "XB and YB Matrix sizes incompatible in MultiplyMatrix_XTY_0" )

    if ( xb%kind == M_Absent .or. yb%kind == M_Absent ) then
      if ( .not. my_upd) &
        & call createBlock ( zb, xb%nCols, yb%nCols, M_Absent, forWhom="MultiplyMatrix_XTY_0" )
      return
    end if

    if ( my_upd ) then
      if ( zb%kind /= m_absent ) then
        if ( xb%nCols /= zb%nRows .or. yb%nCols /= zb%nCols ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "ZB Matrix size incompatible in MultiplyMatrix_XTY_0" )
      else
        zb%nRows = xb%nCols
        zb%nCols = yb%nCols
      end if
    else
      zb%nRows = xb%nCols
      zb%nCols = yb%nCols
    end if

    ! Now stuff for checkBlocks
    if ( checkBlocks ) then
      nullify ( zDns, zDns2 )
      call Allocate_test ( zDns, xb%nCols, yb%nCols, 'zDns', ModuleName )
      if ( my_upd ) then
        call Densify ( zDns, zb )
      else
        zDns = 0.0_rm
      end if
      if ( my_upper ) then
        call Allocate_test ( zDns2, xb%nCols, yb%nCols, 'zDns2', ModuleName )
        zDns2=zDns            ! Save lower triangle
      end if
    end if

    select case ( xb%kind )
    case ( M_Banded )
      select case ( yb%kind )
      case ( M_Banded )       ! XB banded, YB banded
        ! ??? Make a full matrix, then sparsify it.  There _must_ be a
        ! ??? better way
        call allocate_test ( z, zb%nRows, zb%nCols, &
          & "Z for banded X banded in MultiplyMatrix_XTY_0", ModuleName )
        if ( my_upd .and. zb%kind /= m_absent ) then
          call densify ( z, zb )
        else
          z = 0.0_rm
        end if
        do j = 1, zb%nCols    ! Columns of Z = columns of YB
          if ( associated(ym) ) then
            if ( iand(ichar(ym(j)),m_LinAlg) /= 0 ) cycle
          end if
          yi_1 = yb%r2(j-1)+1   ! index of 1st /=0 el. in this col of yb
          yi_n = yb%r2(j)       ! index of last /=0 el. in this col of yb
          yr_1 = yb%r1(j)       ! first row index of yb
          yr_n = yr_1 + yi_n - yi_1 ! last row index of yb
          mz = zb%nRows
          if ( my_upper ) mz = j
!$OMP PARALLEL DO private ( xi_1, xi_n, xr_1, xr_n, cr_1, cr_n, c_n, xd, yd, xy )
          do i = 1, mz       ! Rows of Z = columns of XB
            ! Inner product of column I of XB with column J of YB
            if ( associated(xm) ) then
              if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) cycle
            end if
            xi_1 = xb%r2(i-1)+1  ! index of 1st /=0 el. in this col of xb
            xi_n = xb%r2(i)      ! index of last /=0 el. in this col of xb
            xr_1 = xb%r1(i)      ! first row index of xb
            xr_n = xr_1 + xi_n - xi_1   ! last row index of xb

            ! Now work out what they have in common
            cr_1 = max ( xr_1, yr_1 )
            cr_n = min ( xr_n, yr_n )
            c_n = cr_n - cr_1 + 1
            if ( c_n <= 0 ) cycle

            ! Now make xd and yd point to the starts of the common parts
            xd = xi_1 + cr_1 - xr_1
            yd = yi_1 + cr_1 - yr_1

            xy = dot( c_n, xb%values(xd,1), 1, &
              &            yb%values(yd,1), 1 )
!           xy = dot_product( xb%values(xd:xd+c_n-1,1), &
!             &               yb%values(yd:yd+c_n-1,1) )
            z(i,j) = z(i,j) + s * xy
          end do ! i
!$OMP END PARALLEL DO
        end do ! j
        call sparsify ( z, zb, & ! Zb := Z
          & "Z for banded X banded in MultiplyMatrix_XTY_0", ModuleName )
      case ( M_Column_sparse ) ! XB banded, YB column-sparse
        ! ??? Make a full matrix, then sparsify it.  There _must_ be a
        ! ??? better way
        call allocate_test ( z, xb%nCols, yb%nCols, &
          & "Z for banded X sparse in MultiplyMatrix_XTY_0", ModuleName )
        if ( my_upd .and. zb%kind /= m_absent ) then
          call densify ( z, zb )
        else
          z = 0.0_rm
        end if
        do j = 1, zb%nCols    ! Columns of Z
          if ( associated(ym) ) then
            if ( iand(ichar(ym(j)),m_LinAlg) /= 0 ) cycle
          end if
          mz = zb%nRows
          if ( my_upper ) mz = j
!$OMP PARALLEL DO private ( k, l, m, n )
          do i = 1, mz  ! Rows of Z = columns of XB
            if ( associated(xm) ) then
              if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) cycle
            end if
            k = xb%r1(i)      ! Row subscript of first nonzero in XB's column I
            l = xb%r2(i-1)+1  ! Position in XB%VALUES of it
            n = yb%r1(j-1)+1  ! Position in YB%R2 of row subscript in YB
            if ( n > ubound (yb%r2,1) ) cycle
            m = yb%r2(n)      ! Row subscript of nonzero in YB's column J
            do while ( l <= xb%r2(i) .and. n <= yb%r1(j) )
              if ( k < m ) then
                l = l + 1
                k = k + 1
              else if ( k > m ) then
                n = n + 1
                if ( n > yb%r1(j) ) exit
                m = yb%r2(n)
              else
                ! Multiplying by S is faster than testing my_sub
                z(i,j) = z(i,j) + s * xb%values(l,1) * yb%values(n,1)
                l = l + 1
                k = k + 1
                n = n + 1
                if ( n > yb%r1(j) ) exit
                m = yb%r2(n)
              end if
            end do
          end do ! i
!$OMP END PARALLEL DO
        end do ! j
        call sparsify ( z, zb, & ! Zb := Z
          & "Z for banded X banded in MultiplyMatrix_XTY_0", ModuleName )
      case ( M_Full )         ! XB banded, YB full
        if ( zb%kind /= m_full ) then
          call allocate_test ( z, xb%nCols, yb%nCols, &
            & "Z for banded X full in MultiplyMatrix_XTY_0", ModuleName )
          if ( my_upd ) call densify ( z, zb )
          call createBlock ( zb, xb%nCols, yb%nCols, M_Full, novalues=.true., &
            & forWhom="MultiplyMatrix_XTY_0" )
          zb%values => z
        end if
        if ( .not. my_upd ) zb%values = 0.0_rm
        do i = 1, xb%nCols    ! Rows of ZB
          if ( associated(xm) ) then
            if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) cycle
          end if
          m = xb%r1(i)        ! Index of first row of XB with nonzero value
          k = xb%r2(i-1) + 1
          l = xb%r2(i)
          if ( l < k ) cycle  ! Empty column in XB
          mz = 1
          if ( my_upper ) mz = i
!$OMP PARALLEL DO private ( xy )
          do j = mz, yb%nCols  ! Columns of ZB
            if ( associated(ym) ) then
              if ( iand(ichar(ym(j)),m_LinAlg) /= 0 ) cycle
            end if
            if ( l < k ) cycle
            ! Inner product of column I of XB with column J of YB
            xy = dot( l-k+1, xb%values(k,1), 1, yb%values(m,j), 1 )
!           xy = dot_product( xb%values(k:l,1), yb%values(m:m+l-k,j) )
            zb%values(i,j) = zb%values(i,j) + s * xy
          end do ! j
!$OMP END PARALLEL DO
        end do ! i
      end select
    case ( M_Column_sparse )
      select case ( yb%kind )
      case ( M_Banded )       ! XB column-sparse, YB banded
        ! ??? Make a full matrix, then sparsify it.  There _must_ be a
        ! ??? better way
        call allocate_test ( z, xb%nCols, yb%nCols, &
          & "Z for sparse X banded in MultiplyMatrix_XTY_0", ModuleName )
        if ( my_upd .and. zb%kind /= m_absent ) then
          call densify ( z, zb )
        else
          z = 0.0_rm
        end if
        do j = 1, zb%nCols    ! Columns of Z
          if ( associated(ym) ) then
            if ( iand(ichar(ym(j)),m_LinAlg) /= 0 ) cycle
          end if
          mz = zb%nRows
          if ( my_upper ) mz = j
!$OMP PARALLEL DO private ( k, l, m, n )
          do i = 1, mz  ! Rows of Z = columns of XB
            if ( associated(xm) ) then
              if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) cycle
            end if
            l = xb%r1(i-1)+1  ! Position in XB%R2 of row subscript in XB
            if ( l > ubound (xb%r2,1) ) cycle
            k = xb%r2(l)      ! Row subscript of nonzero in XB's column I
            m = yb%r1(j)      ! Row subscript of first nonzero in YB's column J
            n = yb%r2(j-1)+1  ! Position in YB%VALUES of it
            do while ( l <= xb%r1(i) .and. n <= yb%r2(j) )
              if ( k < m ) then
                l = l + 1
                if ( l > xb%r1(i) ) exit
                k = xb%r2(l)
              else if ( k > m ) then
                n = n + 1
                m = m + 1
              else
                ! Multiplying by S is faster than testing my_sub
                z(i,j) = z(i,j) + s * xb%values(l,1) * yb%values(n,1)
                l = l + 1
                if ( l > xb%r1(i) ) exit
                k = xb%r2(l)
                n = n + 1
                m = m + 1
              end if
            end do
          end do ! i
!$OMP END PARALLEL DO
        end do ! j
        call sparsify ( z, zb, & ! Zb := Z
          & "Z for banded X banded in MultiplyMatrix_XTY_0", ModuleName )
      case ( M_Column_sparse ) ! XB column-sparse, YB column-sparse
        ! ??? Make a full matrix, then sparsify it.  There _must_ be a
        ! ??? better way
        call allocate_test ( z, xb%nCols, yb%nCols, &
          & "Z for sparse X sparse in MultiplyMatrix_XTY_0", ModuleName )
        if ( my_upd .and. zb%kind /= m_absent ) then
          call densify ( z, zb )
        else
          z = 0.0_rm
        end if
        do j = 1, zb%nCols    ! Columns of Z
          if ( associated(ym) ) then
            if ( iand(ichar(ym(j)),m_LinAlg) /= 0 ) cycle
          end if
          mz = zb%nRows
          if ( my_upper ) mz = j
!$OMP PARALLEL DO private ( k, l, m, n )
          do i = 1, mz  ! Rows of Z = columns of XB
            if ( associated(xm) ) then
              if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) cycle
            end if
            l = xb%r1(i-1)+1  ! Position in XB%R2 of row subscript in XB
            if ( l > ubound(xb%r2,1) ) cycle
            k = xb%r2(l)      ! Row subscript of nonzero in XB's column I
            n = yb%r1(j-1)+1  ! Position in YB%R2 of row subscript in YB
            if ( n > ubound(yb%r2,1) ) cycle
            m = yb%r2(n)      ! Row subscript of nonzero in YB's column J
            ! z(i,j) = 0.0_rm
            do while ( l <= xb%r1(i) .and. n <= yb%r1(j) )
              if ( k < m ) then
                l = l + 1
                if ( l > xb%r1(i) ) exit
                k = xb%r2(l)
              else if ( k > m ) then
                n = n + 1
                if ( n > yb%r1(j) ) exit
                m = yb%r2(n)
              else
                ! Multiplying by S is faster than testing my_sub
                z(i,j) = z(i,j) + s * xb%values(l,1) * yb%values(n,1)
                l = l + 1
                if ( l > xb%r1(i) ) exit
                k = xb%r2(l)
                n = n + 1
                if ( n > yb%r1(j) ) exit
                m = yb%r2(n)
              end if
            end do
          end do ! i
!$OMP END PARALLEL DO
        end do ! j
        call sparsify ( z, zb, & ! Zb := Z
          & "Z for banded X banded in MultiplyMatrix_XTY_0", ModuleName )
      case ( M_Full )         ! XB column-sparse, YB full
        if ( zb%kind /= m_full ) then
          call allocate_test ( z, xb%nCols, yb%nCols, &
            & "Z for sparse X full in MultiplyMatrix_XTY_0", ModuleName )
          if ( my_upd ) call densify ( z, zb )
          call createBlock ( zb, xb%nCols, yb%nCols, M_Full, novalues=.true., &
            & forWhom="MultiplyMatrix_XTY_0" )
          zb%values => z
        end if
        if ( .not. my_upd ) zb%values = 0.0_rm
        do j = 1, zb%nCols    ! Columns of ZB
          if ( associated(ym) ) then
            if ( iand(ichar(ym(j)),m_LinAlg) /= 0 ) cycle
          end if
          mz = zb%nRows
          if ( my_upper ) mz = j
!$OMP PARALLEL DO private ( k, l, xy )
          do i = 1, mz  ! Rows of Z = columns of XB
            if ( associated(xm) ) then
              if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) cycle
            end if
            k = xb%r1(i-1)+1
            l = xb%r1(i)
            if ( l < k ) cycle
            ! Inner product of column I of XB with column J of YB
            ! Can't productively use DOT because there's a vector subscript
            xy = dot_product( xb%values(k:l,1), yb%values(xb%r2(k:l),j) )
            zb%values(i,j) = zb%values(i,j) + s * xy
          end do ! i
!$OMP END PARALLEL DO
        end do ! j
      end select
    case ( M_Full )
      if ( zb%kind /= m_full ) then
        call allocate_test ( z, xb%nCols, yb%nCols, &
          & "Z for full X <anything> in MultiplyMatrix_XTY_0", ModuleName )
        if ( my_upd ) call densify ( z, zb )
        call createBlock ( zb, xb%nCols, yb%nCols, M_Full, novalues=.true., &
          & forWhom="MultiplyMatrix_XTY_0" )
        zb%values => z
      end if
      if ( .not. my_upd ) zb%values = 0.0_rm
      select case ( yb%kind )
      case ( M_Banded )       ! XB full, YB banded
        do j = 1, zb%nCols    ! Columns of ZB
          if ( associated(ym) ) then
            if ( iand(ichar(ym(j)),m_LinAlg) /= 0 ) cycle
          end if
          m = yb%r1(j)        ! Index of first row of YB with nonzero value
          k = yb%r2(j-1)+1    ! K and L are indices of YB
          l = yb%r2(j)
          mz = zb%nRows
          if ( my_upper ) mz = j
!$OMP PARALLEL DO private ( xy )
          do i = 1, mz  ! Rows of Z = columns of XB
            if ( associated(xm) ) then
              if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) cycle
            end if
            if ( l < k ) cycle
            ! Inner product of column I of XB with column J of YB
            xy = dot( l-k+1, xb%values(m,i), 1, yb%values(k,1), 1 )
!           xy = dot_product( xb%values(m:m+l-k,i), yb%values(k:l,1) )
            zb%values(i,j) = zb%values(i,j) + s * xy
          end do ! i
!$OMP END PARALLEL DO
        end do ! j
      case ( M_Column_sparse ) ! XB full, YB column-sparse
        do j = 1, zb%nCols    ! Columns of ZB
          if ( associated(ym) ) then
            if ( iand(ichar(ym(j)),m_LinAlg) /= 0 ) cycle
          end if
          k = yb%r1(j-1)+1    ! K and L are indices of YB
          l = yb%r1(j)
          mz = zb%nRows
          if ( my_upper ) mz = j
!$OMP PARALLEL DO private ( xy )
          do i = 1, mz  ! Rows of Z = columns of XB
            if ( associated(xm) ) then
              if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) cycle
            end if
            ! Inner product of column I of XB with column J of YB
            ! Can't productively use DOT because there's a vector subscript
            xy = dot_product( xb%values(yb%r2(k:l),i), yb%values(k:l,1) )
            zb%values(i,j) = zb%values(i,j) + s * xy
          end do ! i
!$OMP END PARALLEL DO
        end do ! j
      case ( M_Full )         ! XB full, YB full
        if ( associated(xm) .or. associated(ym) ) then
          rs = max ( subBlockLength / xb%nCols, 1 )
          do r0 = 1, xb%nRows, rs
            r1 = min ( r0 + rs - 1, xb%nRows )
            rn = r1 - r0 + 1
            do j = 1, zb%nCols  ! Columns of ZB
              if ( associated(ym) ) then
                if ( iand(ichar(ym(j)),m_LinAlg) /= 0 ) then
                  cycle
                end if
              end if
              mz = zb%nRows
              if ( my_upper ) mz = j
!$OMP PARALLEL DO private ( xy )
              do i = 1, mz      ! Rows of Z = columns of XB
                if ( associated(xm) ) then
                  if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) then
                    cycle
                  end if
                end if
                xy = dot( rn, xb%values(r0,i), 1, &
                  &           yb%values(r0,j), 1 )
!               xy = dot_product( xb%values(r0:r1,i), &
!                 &               yb%values(r0:r1,j) )
                zb%values(i,j) = zb%values(i,j) + s * xy
              end do ! i = 1, xb%nCols
!$OMP END PARALLEL DO
            end do ! j = 1, yb%nCols
          end do ! r0
        else if ( my_upper ) then
          rs = max ( subBlockLength / xb%nCols, 1 )
          do r0 = 1, xb%nRows, rs
            r1 = min ( r0 + rs - 1, xb%nRows )
            rn = r1 - r0 + 1
            do j = 1, zb%nCols  ! Columns of ZB
!$OMP PARALLEL DO private ( xy )
              do i = 1, j       ! Rows of Z = columns of XB
                xy = dot( rn, xb%values(r0,i), 1, &
                  &           yb%values(r0,j), 1 )
!               xy = dot_product( xb%values(r0:r1,i), &
!                 &               yb%values(r0:r1,j) )
                zb%values(i,j) = zb%values(i,j) + s * xy
              end do ! i
!$OMP END PARALLEL DO
            end do ! j
          end do ! r0
        else
          call gemm ( 'T', 'N', xb%nCols, yb%nCols, xb%nRows, s, &
            & xb%values, xb%nRows, yb%values, yb%nRows, 1.0_rm, &
            & zb%values, zb%nRows )
          ! Same as the following, but the above could use Atlas:
          ! zb%values = zb%values + s * matmul(transpose(xb%values),yb%values)
        end if
      end select
    end select

    if ( checkBlocks ) then
      nullify ( xDns, yDns )
      line = 'MultiplyMatrix_XTY_0'
      call Allocate_test ( xDns, xb%nRows, xb%nCols, 'xDns', ModuleName )
      call Allocate_test ( yDns, yb%nRows, yb%nCols, 'yDns', ModuleName )
      call Densify ( xDns, xb )
      call Densify ( yDns, yb )
      if ( my_upd ) then
        line = trim(line) // ' Update'
      end if
      if ( associated(xm) ) then
        line = trim(line) // ' xMasked'
        do i = 1, xb%nCols
          if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) xDns(:,i)=0.0
        end do
      end if
      if ( associated(ym) ) then
        line = trim(line) // ' yMasked'
        do i = 1, yb%nCols
          if ( iand(ichar(ym(i)),m_LinAlg) /= 0 ) yDns(:,i)=0.0
        end do
      end if
      if ( my_sub ) then
        call gemm ( 'T', 'N', size(xDns,2), size(yDns,2), size(xDns,1), -1.0_rm, &
          & xDns, size(xDns,1), yDns, size(yDns,1), 1.0_rm, &
          & zDns, size(zDns,1) )
!       zDns = zDns - matmul(transpose(xDns), yDns)
        line = trim(line) // ' Subtract'
      else
        call gemm ( 'T', 'N', size(xDns,2), size(yDns,2), size(xDns,1), +1.0_rm, &
          & xDns, size(xDns,1), yDns, size(yDns,1), 1.0_rm, &
          & zDns, size(zDns,1) )
!       zDns = zDns + matmul(transpose(xDns), yDns)
      end if
      if ( my_upper ) then
        line = trim(line) // ' Upper'
        do j = 1, zb%nCols
          zDns(j+1:zb%nRows,j) = zDns2(j+1:zb%nRows,j)
        end do
      end if
      call TestBlock ( zb, zDns, ok, line, xb%kind, yb%kind )
      if ( .not. ok ) then
        call dump ( xb, name='xb', details=2 )
        call dump ( yb, name='yb', details=2 )
      end if
      call Deallocate_test ( xDns, 'xDns', ModuleName )
      call Deallocate_test ( yDns, 'yDns', ModuleName )
      call Deallocate_test ( zDns, 'zDns', ModuleName )
      if ( my_upper ) then
        call Deallocate_test ( zDns2, 'zDns2', ModuleName )
      end if
    end if
  end subroutine MultiplyMatrix_XTY_0

  ! -------------------------------------  MultiplyMatrixVector_0_r4  -----
  subroutine MultiplyMatrixVector_0_r4 ( A, V, P, UPDATE, SUBTRACT, MASK )
  ! P = A^T V if UPDATE is absent or false.
  ! P = P + A^T V if UPDATE is present and true and SUBTRACT is absent or false.
  ! P = P - A^T V if UPDATE is present and true and SUBTRACT is present and true.
  ! If MASK is present and associated, columns of A that correspond to elements
  ! of MASK that have a nonzero M_LinAlg bit are not multiplied.
    type(MatrixElement_T), intent(in) :: A
    real(r4), dimension(:), intent(in) :: V
    real(r4), dimension(:), intent(inout) :: P
    logical, optional, intent(in) :: UPDATE
    logical, optional, intent(in) :: SUBTRACT
    character, optional, pointer, dimension(:) :: MASK ! intent(in)

    real(r8) :: AV                 ! Product of a column of A and the vector V
    integer :: I, M, N             ! Subscripts and loop inductors
    character, pointer, dimension(:) :: MY_MASK
    logical :: My_Sub, My_update
    real(rm) :: S                  ! SUBTRACT => -1 else +1
    integer :: V1                  ! Subscripts and loop inductors

    include "multiplymatrixvector_0.f9h"
  end subroutine MultiplyMatrixVector_0_r4

  ! -------------------------------------  MultiplyMatrixVector_0_r8  -----
  subroutine MultiplyMatrixVector_0_r8 ( A, V, P, UPDATE, SUBTRACT, MASK )
  ! P = A^T V if UPDATE is absent or false.
  ! P = P + A^T V if UPDATE is present and true and SUBTRACT is absent or false.
  ! P = P - A^T V if UPDATE is present and true and SUBTRACT is present and true.
  ! If MASK is present and associated, columns of A that correspond to elements
  ! of MASK that have a nonzero M_LinAlg bit are not multiplied.
    type(MatrixElement_T), intent(in) :: A
    real(r8), dimension(:), intent(in) :: V
    real(r8), dimension(:), intent(inout) :: P
    logical, optional, intent(in) :: UPDATE
    logical, optional, intent(in) :: SUBTRACT
    character, optional, pointer, dimension(:) :: MASK ! intent(in)

    real(r8) :: AV                 ! Product of a column of A and the vector V
    integer :: I, M, N             ! Subscripts and loop inductors
    character, pointer, dimension(:) :: MY_MASK
    logical :: My_Sub, My_update
    real(rm) :: S                  ! SUBTRACT => -1 else +1
    integer :: V1                  ! Subscripts and loop inductors

    include "multiplymatrixvector_0.f9h"
  end subroutine MultiplyMatrixVector_0_r8

  ! ----------------------------------  MultiplyMatrixVectorNoT_0_r4  -----
  subroutine MultiplyMatrixVectorNoT_0_r4 ( B, V, P, UPDATE, DoDiag, SUBTRACT )
  ! P = B V if UPDATE is absent or false.
  ! P = P + B V if UPDATE is present and true and SUBTRACT is absent or false
  ! P = P - B V if UPDATE is present and true and SUBTRACT is present and true
  ! Don't multiply by the diagonal element if doDiag (default true) is
  ! present and false.
    type(MatrixElement_T), intent(in) :: B
    real(r4), dimension(:), intent(in) :: V
    real(r4), dimension(:), intent(inout) :: P
    logical, optional, intent(in) :: UPDATE, DoDiag, SUBTRACT

    integer :: I, J, M, N          ! Subscripts and loop inductors
    logical :: My_diag, My_sub, My_update
    real(rm) :: SIGN               ! Multiplying by sign is faster than testing
    integer :: V1                  ! Subscripts and loop inductors

    include "multiplymatrixvectornot_0.f9h"
  end subroutine MultiplyMatrixVectorNoT_0_r4

  ! ----------------------------------  MultiplyMatrixVectorNoT_0_r8  -----
  subroutine MultiplyMatrixVectorNoT_0_r8 ( B, V, P, UPDATE, DoDiag, SUBTRACT )
  ! P = B V if UPDATE is absent or false.
  ! P = P + B V if UPDATE is present and true and SUBTRACT is absent or false
  ! P = P - B V if UPDATE is present and true and SUBTRACT is present and true
  ! Don't multiply by the diagonal element if doDiag (default true) is
  ! present and false.
    type(MatrixElement_T), intent(in) :: B
    real(r8), dimension(:), intent(in) :: V
    real(r8), dimension(:), intent(inout) :: P
    logical, optional, intent(in) :: UPDATE, DoDiag, SUBTRACT

    integer :: I, J, M, N          ! Subscripts and loop inductors
    logical :: My_diag, My_sub, My_update
    real(rm) :: SIGN               ! Multiplying by sign is faster than testing
    integer :: V1                  ! Subscripts and loop inductors

    include "multiplymatrixvectornot_0.f9h"
  end subroutine MultiplyMatrixVectorNoT_0_r8

  ! -------------------------------------  NewMultiplyMatrix_XTY_0  ----
  function NewMultiplyMatrix_XTY_0 ( X, Y ) result ( Z ) ! Z = X^T Y
    type(MatrixElement_T), intent(in) :: X, Y
    type(MatrixElement_T) :: Z

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyBlock using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignBlock.
  ! !!!!! ===== END NOTE ===== !!!!! 

    call nullifyMatrix ( z ) ! for Sun's still useless compiler
    call MultiplyMatrix_XTY_0 ( x, y, z )
  end function NewMultiplyMatrix_XTY_0

  ! -----------------------------------  NewMultiplyMatrixVector_0_r4  ----
  function NewMultiplyMatrixVector_0_r4 ( B, V ) result ( P ) ! P = B^T V
    type(MatrixElement_T), intent(in) :: B
    real(r4), dimension(:), intent(in) :: V
    real(r4), dimension(size(v)) :: P
    call MultiplyMatrixVector ( b, v, p, .false. )
  end function NewMultiplyMatrixVector_0_r4

  ! -----------------------------------  NewMultiplyMatrixVector_0_r8  ----
  function NewMultiplyMatrixVector_0_r8 ( B, V ) result ( P ) ! P = B^T V
    type(MatrixElement_T), intent(in) :: B
    real(r8), dimension(:), intent(in) :: V
    real(r8), dimension(size(v)) :: P
    call MultiplyMatrixVector ( b, v, p, .false. )
  end function NewMultiplyMatrixVector_0_r8

  ! ---------------------------------------------- NullifyMatrix_0 -----
  subroutine NullifyMatrix_0 ( M )
    ! Given a matrix, nullify all the pointers associated with it
    type ( MatrixElement_T ), intent(out) :: M

    ! Executable code
    m%KIND = M_Absent
    m%nRows = 0
    m%nCols = 0
    nullify ( m%r1 )
    nullify ( m%r2 )
    nullify ( m%values )
  end subroutine NullifyMatrix_0

  ! -------------------------------------------------  ReflectMatrix_0 --
  subroutine ReflectMatrix_0 ( M )
    ! Given the matrix M copy the upper triangle into the lower
    type ( MatrixElement_T ), intent(inout) :: M ! Matrix
    ! Local variables
    real (rm), dimension(:,:), pointer :: V ! Matrix values
    integer :: I, J             ! Loop counters
    ! executable code
    select case ( m%kind )
    case ( m_absent )
      return
    case ( m_full )
      V => m%values
    case ( m_banded, m_column_sparse )
      nullify ( V )
      call Allocate_test ( V, m%nRows, m%nCols, 'V', ModuleName )
      call Densify ( v, m )
    end select

    ! Do the reflection
    do i = 1, m%nRows
      do j = i + 1, m%nCols
        v ( j, i ) = v ( i, j )
      end do
    end do

    ! Sparsify again if appropriate
    if ( m%kind ==  m_banded .or. m%kind == m_column_sparse ) &
      & call Sparsify ( V, M, 'V in Reflect_0', ModuleName )
  end subroutine ReflectMatrix_0
      
  ! -------------------------------------------------  RowScale_0_r4  -----
  subroutine RowScale_0_r4 ( V, X, NEWX ) ! Z = V X where V is a diagonal
  !                                     matrix represented by a vector and
  !                                     Z is either X or NEWX.
    real(r4), intent(in), dimension(:) :: V
    type(MatrixElement_T), intent(inout), target :: X
    type(MatrixElement_T), intent(inout), target, optional :: NEWX ! intent(inout)
      !                            so that the destroyBlock in cloneBlock
      !                            gets a chance to clean up surds
    type(MatrixElement_T), pointer :: Z

    integer :: I

    include "rowscale_0.f9h"
  end subroutine RowScale_0_r4

  ! -------------------------------------------------  RowScale_0_r8  -----
  subroutine RowScale_0_r8 ( V, X, NEWX ) ! Z = V X where V is a diagonal
  !                                     matrix represented by a vector and
  !                                     Z is either X or NEWX.
    real(r8), intent(in), dimension(:) :: V
    type(MatrixElement_T), intent(inout), target :: X
    type(MatrixElement_T), intent(inout), target, optional :: NEWX ! intent(inout)
      !                            so that the destroyBlock in cloneBlock
      !                            gets a chance to clean up surds
    type(MatrixElement_T), pointer :: Z

    integer :: I

    include "rowscale_0.f9h"
  end subroutine RowScale_0_r8

  ! -------------------------------------------------  ScaleBlock  -----
  subroutine ScaleBlock ( Z, A )        ! Z := A * Z, where A is scalar
    type(matrixElement_T), intent(inout) :: Z
    real(r8), intent(in) :: A
    if ( z%kind /= m_absent ) z%values = a * z%values
  end subroutine ScaleBlock

  ! -------------------------------------------  SolveCholeskyA_0_r4  -----  
  subroutine SolveCholeskyA_0_r4 ( U, X, B, TRANSPOSE, STATUS )
  ! Solve the system U X = B or U^T X = B for X, depending on TRANSPOSE,
  ! where U is known to be upper-triangular Array.  X may be the same as B.
  ! B may be absent, in which case the right-hand side is in X on input,
  ! and the solution replaces it on output.  The arrays X and B are
  ! one-dimensional arrays.

    real (r4), dimension(:), intent(inout), target :: X
    real (r4), dimension(:), intent(in), target, optional :: B
    logical, intent(in), optional :: TRANSPOSE    ! Solve U^T X = B if
    !                                               present and true.
    integer, intent(out), optional :: STATUS ! Optional status flag

    real (rm) :: D        ! Diagonal element of U
    integer :: I          ! Subscripts and loop inductors
    real (r4), dimension(:), pointer :: MY_B   ! B if B is present, else X
    logical :: MY_T      ! FALSE if TRANSPOSE is absent, else TRANSPOSE
    integer :: N         ! Size of U matrix, which must be square
    real (rm), parameter :: TOL = tiny(0.0)
    real (rm), dimension(:,:), intent(in) :: U 

    include "solvecholeskya_0.f9h"
  end subroutine SolveCholeskyA_0_r4

  ! -------------------------------------------  SolveCholeskyA_0_r8  -----  
  subroutine SolveCholeskyA_0_r8 ( U, X, B, TRANSPOSE, STATUS )
  ! Solve the system U X = B or U^T X = B for X, depending on TRANSPOSE,
  ! where U is known to be upper-triangular Array.  X may be the same as B.
  ! B may be absent, in which case the right-hand side is in X on input,
  ! and the solution replaces it on output.  The arrays X and B are
  ! one-dimensional arrays.

    real (r8), dimension(:), intent(inout), target :: X
    real (r8), dimension(:), intent(in), target, optional :: B
    logical, intent(in), optional :: TRANSPOSE    ! Solve U^T X = B if
    !                                               present and true.
    integer, intent(out), optional :: STATUS ! Optional status flag

    real (rm) :: D        ! Diagonal element of U
    integer :: I          ! Subscripts and loop inductors
    real (r8), dimension(:), pointer :: MY_B   ! B if B is present, else X
    logical :: MY_T      ! FALSE if TRANSPOSE is absent, else TRANSPOSE
    integer :: N         ! Size of U matrix, which must be square
    real (rm), parameter :: TOL = tiny(0.0)
    real (rm), dimension(:,:), intent(in) :: U 

    include "solvecholeskya_0.f9h"
  end subroutine SolveCholeskyA_0_r8

  ! -------------------------------------------  SolveCholeskyM_0  -----
  subroutine SolveCholeskyM_0 ( U, X, B, TRANSPOSE, STATUS )
  ! Solve the system U X = B or U^T X = B for X, depending on TRANSPOSE,
  ! where U is known to be upper-triangular.  X may be the same as B.
  ! B may be absent, in which case the right-hand side is in X on input,
  ! and the solution replaces it on output.
    type(MatrixElement_T), intent(in) :: U        ! Must be square
    type(MatrixElement_T), intent(inout), target :: X
    type(MatrixElement_T), intent(in), target, optional :: B
    logical, intent(in), optional :: TRANSPOSE    ! Solve U^T X = B if
    !                                               present and true.
    integer, intent(out), optional :: STATUS

    real(rm) :: D        ! Diagonal element of U
    integer :: I, J, K   ! Subscripts and loop inductors
    type(MatrixElement_T), pointer :: MY_B   ! B if B is present, else X
    logical :: MY_T      ! FALSE if TRANSPOSE is absent, else TRANSPOSE
    integer :: N         ! Size of U matrix, which must be square
    integer :: NC        ! Number of columns in B, not necessarily == N
    real(rm), parameter :: TOL = tiny(0.0_rm)
    real(rm), pointer, dimension(:,:) :: XS  ! The solution, dense
    real(rm), pointer, dimension(:,:) :: UD  ! U, densified

    nullify ( ud, xs )
    n = u%nRows
    if ( n /= u%nCols ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "U matrix in SolveCholeskyM_0 must be square" )
    my_b => x
    if ( present(b) ) my_b => b
    if ( n /= my_b%nRows ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "B matrix not compatible with U matrix in SolveCholeskyM_0" )
    my_t = .false.
    if ( present(transpose) ) my_t = transpose
    nc = my_b%nCols

    call allocate_test ( xs, my_b%nRows, my_b%nCols, "XS in SolveCholeskyM_0", &
      & ModuleName )
    call densify ( xs, my_b )
    if ( my_t ) then ! solve U^T X = B for X
      select case ( u%kind )
      case ( M_Absent )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "U matrix in SolveCholeskyM_0 must not be absent" )
      case ( M_Banded )
        do i = 1, n
          if ( u%r1(i) + u%r2(i) - u%r2(i-1) - 1 /= i ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyM_0 is not triangular" )
          d = u%values(u%r2(i),1)
          if ( abs(d) < tol ) then
            if ( present ( status ) ) then
              status = i
              return
            else
              call dump ( u, 'Guilty party', details=2 )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & "U matrix in SolveCholeskyM_0 is singular" )
            end if
          end if
!$OMP PARALLEL DO
          do j = 1, nc
            xs(i,j) = ( xs(i,j) - &
                    &   dot( u%r2(i)-u%r2(i-1)-1, u%values(u%r2(i-1)+1,1), 1, &
                    &                             xs(u%r1(i),j), 1 ) ) / d
!           xs(i,j) = ( xs(i,j) - &
!                   &   dot_product( u%values(u%r2(i-1)+1:u%r2(i)-1,1), &
!                   &                xs(u%r1(i):i-1,j) ) ) / d
          end do ! j = 1, nc
!$OMP END PARALLEL DO
        end do ! i = 1, n
      case ( M_Column_Sparse )
        do i = 1, n
          if ( u%r2(u%r1(i)) /= i ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyM_0 is not triangular" )
          d = u%values(u%r1(i),1)
          if ( abs(d) < tol ) then
            if ( present ( status ) ) then
              status = i
              return
            else
              call dump ( u, 'Guilty party', details=2 )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & "U matrix in SolveCholeskyM_0 is singular" )
            end if
          end if
          do j = 1, nc
            do k = u%r1(i-1)+1, u%r1(i)-1
              xs(i,j) = xs(i,j) - u%values(k,1) * xs(u%r2(k),j)
            end do ! k = u%r1(i-1)+1, u%r1(i)-1
            xs(i,j) = xs(i,j) / d
          end do ! j = 1, nc
        end do ! i = 1, n
      case ( M_Full )
        d = u%values(1,1)
        if ( abs(d) < tol ) then
          if ( present ( status ) ) then
            status = 1
            return
          else
            call dump ( u, 'Guilty party', details=2 )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyM_0 is singular" )
          end if
        end if
        xs(1,1:nc) = xs(1,1:nc) / d
        do i = 2, n
          d = u%values(i,i)
          if ( abs(d) < tol ) then
            if ( present ( status ) ) then
              status = i
              return
            else
              call dump ( u, 'Guilty party', details=2 )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & "U matrix in SolveCholeskyM_0 is singular" )
            end if
          end if
!$OMP PARALLEL DO
          do j = 1, nc
            xs(i,j) = ( xs(i,j) - &
                    &   dot( i-1, u%values(1,i), 1, xs(1,j), 1) ) / d
!           xs(i,j) = ( xs(i,j) - &
!                   &   dot_product( u%values(1:i-1,i), xs(1:i-1,j)) ) / d
          end do ! j = 1, nc
!$OMP END PARALLEL DO
        end do ! i = 2, n
      end select
    else             ! solve U X = B for X
      if ( u%kind == M_full ) then
        ud => u%values
      else
        call allocate_test ( ud, n, n, "UD in SolveCholeskyM_0", ModuleName )
        call densify ( ud, u )
      end if
      d = ud(n,n)
      if ( abs(d) < tol ) then
        if ( present ( status ) ) then
          status = n
          return
        else
          call dump ( u, 'Guilty party', details=2 )
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "U matrix in SolveCholeskyM_0 is singular" )
        end if
      end if
      xs(n,1:nc) = xs(n,1:nc) / d
      do i = n-1, 1, -1
        d = ud(i,i)
        if ( abs(d) < tol ) then
          if ( present ( status ) ) then
            status = i
            return
          else
            call dump ( u, 'Guilty party', details=2 )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyM_0 is singular" )
          end if
        end if
!$OMP PARALLEL DO
        do j = 1, nc
          xs(i,j) = ( xs(i,j) - &
                  &   dot( n-i, ud(i,i+1), size(ud,1), xs(i+1,j), 1 ) ) / d
!                 &   dot_product(ud(i,i+1:n), xs(i+1:n,j)) ) / d
        end do ! j = 1, nc
!$OMP END PARALLEL DO
      end do ! i = 1, n
      if ( u%kind /= M_Full ) &
        & call deallocate_test ( ud, "UD in SolveCholeskyM_0", ModuleName )
    end if ! my_t
    call sparsify ( xs, x, "XS in SolveCholeskyM_0", ModuleName ) ! X := Xs
    if ( present ( status ) ) status = 0
  end subroutine SolveCholeskyM_0

  ! -------------------------------------------  SolveCholeskyV_0_r4  -----
  subroutine SolveCholeskyV_0_r4 ( U, X, B, TRANSPOSE, STATUS )
  ! Solve the system U X = B or U^T X = B for X, depending on TRANSPOSE,
  ! where U is known to be upper-triangular.  X may be the same as B.
  ! B may be absent, in which case the right-hand side is in X on input,
  ! and the solution replaces it on output.  The arrays X and B are
  ! two-dimensional sections of subvectors of objects of type Vector_T.
  ! Their elements are taken to correspond to the rows of U in array
  ! element order.
    type(MatrixElement_T), intent(in) :: U        ! Must be square
    real(r4), dimension(:), intent(inout), target :: X
    real(r4), dimension(:), intent(in), target, optional :: B
    logical, intent(in), optional :: TRANSPOSE    ! Solve U^T X = B if
    !                                               present and true.
    integer, intent(out), optional :: STATUS ! Optional status flag

    real(rm) :: D        ! Diagonal element of U
    integer :: H, I      ! Subscripts and loop inductors
    real(r4), dimension(:), pointer :: MY_B   ! B if B is present, else X
    logical :: MY_T      ! FALSE if TRANSPOSE is absent, else TRANSPOSE
    integer :: N         ! Size of U matrix, which must be square
    real(rm), parameter :: TOL = tiny(0.0_rm)
    real(rm), dimension(:,:), pointer :: UD  ! U, densified

    include "solvecholeskyv_0.f9h"
  end subroutine SolveCholeskyV_0_r4

  ! -------------------------------------------  SolveCholeskyV_0_r8  -----
  subroutine SolveCholeskyV_0_r8 ( U, X, B, TRANSPOSE, STATUS )
  ! Solve the system U X = B or U^T X = B for X, depending on TRANSPOSE,
  ! where U is known to be upper-triangular.  X may be the same as B.
  ! B may be absent, in which case the right-hand side is in X on input,
  ! and the solution replaces it on output.  The arrays X and B are
  ! two-dimensional sections of subvectors of objects of type Vector_T.
  ! Their elements are taken to correspond to the rows of U in array
  ! element order.
    type(MatrixElement_T), intent(in) :: U        ! Must be square
    real(r8), dimension(:), intent(inout), target :: X
    real(r8), dimension(:), intent(in), target, optional :: B
    logical, intent(in), optional :: TRANSPOSE    ! Solve U^T X = B if
    !                                               present and true.
    integer, intent(out), optional :: STATUS ! Optional status flag

    real(rm) :: D        ! Diagonal element of U
    integer :: H, I      ! Subscripts and loop inductors
    real(r8), dimension(:), pointer :: MY_B   ! B if B is present, else X
    logical :: MY_T      ! FALSE if TRANSPOSE is absent, else TRANSPOSE
    integer :: N         ! Size of U matrix, which must be square
    real(rm), parameter :: TOL = tiny(0.0_rm)
    real(rm), dimension(:,:), pointer :: UD  ! U, densified

    include "solvecholeskyv_0.f9h"
  end subroutine SolveCholeskyV_0_r8

  ! ---------------------------------------------------  SparsifyA  -----
  subroutine SparsifyA ( Z, B, Why, CallingModule )
  ! Given an array Z, compute its sparse representation and store it
  ! in the matrix block B.
    real(rm), pointer :: Z(:,:)              ! Full array of values
    type(MatrixElement_T), intent(inout) :: B     ! Z as a block, maybe sparse
    ! B is intent(inout) so that createBlock gets a chance to clean up surds
    character(len=*), intent(in), optional :: Why
    character(len=*), intent(in), optional :: CallingModule
    ! If either Why or CallingModule is present, Z is deallocated using
    ! Deallocate_Test

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyBlock using the B argument of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignBlock.
  ! !!!!! ===== END NOTE ===== !!!!! 

    integer :: I1, I2              ! Row indices in Z
    integer :: J                   ! Column index in Z
    integer :: KIND                ! Representation to use for B
    integer :: NNZ                 ! Number of nonzeroes in Z
    integer :: NNZC(size(z,2))     ! Number of nonzeroes in a column of Z
    integer :: R1(size(z,2))       ! Row number of first nonzero in a column
    real(rm), save :: SQ_EPS = -1.0_rm  ! sqrt(epsilon(1.0_rm))
    real(r4) :: ZT(size(z,2))      ! Maximum value in a column of Z, then
      ! max(sqrt(sq_eps*zt),tiny(1.0_rm)).  Elements less than this threshold
      ! in magnitude are considered to be zero.

    if ( sq_eps < 0.0_rm ) sq_eps = sqrt(epsilon(1.0_rm))
    do j = 1, size(z,2)
    ! zt(j) = maxval(abs(z(:,j)))
    ! zt(j) = max(sq_eps*zt(j), sqrt(tiny(1.0_rm)))
    ! nnzc(j) = count(abs(z(:,j)) < zt(j))
      zt(j) = 0.0_rm
!     do i1 = 1, size(z,1)
!       zt(j) = max(zt(j),abs(z(i1,j)))
!     end do ! i1
!     zt(j) = max(sq_eps*zt(j), sqrt(tiny(1.0_rm)))
      nnzc(j) = 0
      do i1 = 1, size(z,1)
        if ( abs(z(i1,j)) > zt(j) ) nnzc(j) = nnzc(j) + 1
      end do ! i1
    end do ! j
    nnz = sum(nnzc)
    if ( nnz == 0 ) then ! Empty
      call createBlock ( b, size(z,1), size(z,2), M_Absent, forWhom="SparsifyA" )
    else if ( nnz <= int(sparsity * size(z)) ) then ! sparse
      kind = M_Banded
      do j = 1, size(z,2)
        do i1 = 1, size(z,1)       ! Find row number of first nonzero
          if ( abs(z(i1,j)) > zt(j) ) exit
        end do
        r1(j) = i1
        do i2 = size(z,1), 1, -1   ! Find row number of last nonzero
          if ( abs(z(i2,j)) > zt(j) ) exit
        end do
        if ( int(col_sparsity*(i2 - i1)) > nnzc(j) ) then
          kind = M_Column_Sparse
!!$          do i1 = 1, j-1 ! I1 is a column number in this case
!!$            nnzc(i1) = count(abs(z(:,i1)) <= zt(i1))
!!$          end do ! i1
          exit
        end if
        nnzc(j) = max(i2 - i1 + 1,0)
      end do ! j
      if ( kind == M_Banded ) then
        call createBlock ( b, size(z,1), size(z,2), M_Banded, sum(nnzc), &
          & forWhom="SparsifyA" )
        b%r1 = r1        ! Row number of first nonzero in the column
        do j = 1, size(z,2)
          b%r2(j) = nnzc(j) + b%r2(j-1) ! Subscript of last nonzero in the
                                        ! column
          b%values(b%r2(j-1)+1:b%r2(j),1) = &
            & z(b%r1(j):b%r1(j)+b%r2(j)-b%r2(j-1)-1,j)
        end do
      else
        call createBlock ( b, size(z,1), size(z,2), M_Column_Sparse, nnz, &
          & forWhom="SparsifyA" )
        i1 = 0
        do j = 1, size(z,2)
          do i2 = 1, size(z,1)
            if ( abs(z(i2,j)) > zt(j) ) then
              i1 = i1 + 1
              b%values(i1,1) = z(i2,j)
              b%r2(i1) = i2
            end if
            b%r1(j) = i1
          end do ! i2
        end do ! j
      end if
    else ! full
      if ( present(why) .or. present(callingModule) ) then
        ! Don't worry, create block still deallocates b%values even with noValues set
        call createBlock ( b, size(z,1), size(z,2), M_Full, noValues=.true., &
          & forWhom="SparsifyA" )
        b%values => z
        nullify ( z )
      else
        call createBlock ( b, size(z,1), size(z,2), M_Full, forWhom="SparsifyA" )
        b%values = z
      end if
    end if
    if ( present(why) ) then
      if ( present(callingModule) ) then
        call deallocate_test ( z, why, callingModule )
      else
        call deallocate_test ( z, why, "No module specified" )
      end if
    else if ( present(callingModule) ) then
      call deallocate_test ( z, "No variable specified", callingModule )
    end if
  end subroutine SparsifyA

  ! ----------------------------------------------- Sparsify_0 ---------
  subroutine SparsifyB ( B )
    ! Sparsify a block in place
    type (MatrixElement_T), intent(inout) :: B
    ! Local variable
    real(rm), dimension(:,:), pointer :: Z
    ! Executable code
    if ( b%kind /= M_Full ) return
    z => b%values
    nullify ( b%values )
    call Sparsify ( z, b, 'z', ModuleName )
  end subroutine SparsifyB

  ! ----------------------------------------------------  Spill_0  -----
  subroutine Spill_0 ( A, Unit )
  ! Spill the matrix block A to Fortran Unit, which is presumed to be
  ! open for unformatted output.  The order of output is:
  ! An integer that is zero if the block is empty and 3 if it is not.
  ! If this integer is zero, there is no further output.
  ! Two integers, giving the number of rows and columns.
  ! The values of the matrix block elements, in column major order.
    type(MatrixElement_T), intent(in) :: A
    integer, intent(in) :: Unit

    real(rm), pointer :: D(:,:)              ! Densified block, if necessary

    write ( unit ) a%kind, a%nRows, a%nCols
    if ( a%kind == m_absent ) return
    if ( a%kind == m_full ) then
      write ( unit ) a%values
      return
    end if
    nullify ( d )
    call allocate_test ( d, a%nRows, a%nCols, "D in Spill_0", ModuleName )
    call densify ( d, a )
    write ( unit ) d
    call deallocate_test ( d, "D in Spill_0", ModuleName )
  end subroutine Spill_0

  ! -------------------------------------------  SymSchur2 -------------
  subroutine SymSchur2 ( A, p, q, c, s, t )
    ! This subroutine works out the cosine(c) and sine(s) coefficients for a Jacobi
    ! rotation of rows p and q of (1<=p<q<=n) of matrix A.  For more information see
    ! Section 8.4.2 of Golub and VanLoan (3rd edition)
    ! Dummy arguments.
    real(rm), dimension(:,:), intent(in) :: A ! Symmetric matrix (lower triangle only)
    integer, intent(in) :: P            ! First row to consider
    integer, intent(in) :: Q            ! Second row to consider
    real(rm), intent(out) :: C          ! Cosine term
    real(rm), intent(out) :: S          ! Sine term
    real(rm), intent(out) :: T          ! Tangent term
    ! Local variables
    real(rm) :: TAU                     ! Workspace
    real(rm) :: TNY                     ! sqrt(tiny)
    ! Executable code
    ! Note that we only store the lower triangle of A, so sometimes Golub and VanLoan's
    ! indices have been reversed
    tau =  A(q,q) - A(p,p) 
    tny = tiny ( 0.0_rm ) * 10.0
    if ( tny * abs ( tau ) < abs ( A(q,p) ) ) then
!       call output ( 'A terms: ' )
!       call output ( A(q,q) )
!       call output ( ', ' )
!       call output ( A(p,p) )
!       call output ( ', ' )
!       call output ( A(q,p), advance='yes' )
!       call output ( 'Numerator = ' )
!       call output ( tau )
!       call output ( 'Times tiny = ' )
!       call output ( tny * abs(tau), advance='yes' )
      tau = tau / ( 2.0_rm * A(q,p) )
!       call output ( 'tau = ' )
!       call output ( tau, advance='yes' )
      if ( tau >= 0.0_rm ) then
        t =  1.0_rm / (  tau + sqrt ( 1.0_rm + tau**2 ) )
!         call output ( 't = ' )
!         call output ( t, advance='yes' )
      else
        t = -1.0_rm / ( -tau + sqrt ( 1.0_rm + tau**2 ) )
!         call output ( 't = ' )
!         call output ( t, advance='yes' )
      end if
      c = 1.0_rm / sqrt ( 1.0_rm + t**2 )
      s = t * c
    else
      c = 1.0_rm
      s = 0.0_rm
      t = 0.0_rm
    end if
  end subroutine SymSchur2

  ! -------------------------------------------  TransposeMatrix_0 -----
  subroutine TransposeMatrix_0 ( Z, A )
    ! Given the matrix A, compute Z=M^T
    type ( MatrixElement_T), intent(inout) :: Z ! Output matrix
    type ( MatrixElement_T), intent(in) :: A ! Input matrix
    ! Local variables
    real (rm), dimension(:,:), pointer :: D ! Dense form of matrix
    real (rm), dimension(:,:), pointer :: DT ! Transpose of D

    ! Executable code
    call DestroyBlock ( Z )
    select case ( a%kind )
    case ( m_absent )
    case ( m_full )
      call CreateBlock ( z, a%nCols, a%nRows, m_full, forWhom="TransposeMatrix_0" )
      z%values = transpose ( a%values )
    case ( m_banded, m_column_sparse )
      nullify ( D, DT )
      call Allocate_test ( D, a%nRows, a%nCols, 'D', ModuleName )
      call Allocate_test ( DT, a%nCols, a%nRows, 'DT', ModuleName )
      call Densify ( D, A )
      DT = transpose ( D )
      call Sparsify ( DT, Z, 'DT in TransposeMatrix_0', ModuleName )
      call Deallocate_test ( D, 'D', ModuleName )
    end select
  end subroutine TransposeMatrix_0
  
  ! -------------------------------------------  UpdateDiagonal_0_r8  -----
  subroutine UpdateDiagonal_0_r8 ( A, LAMBDA )
  ! Add LAMBDA to the diagonal of A
    type(MatrixElement_T), intent(inout) :: A
    real(r8), intent(in) :: LAMBDA

    integer :: I, J                          ! Subscripts and loop inductors
    integer :: N                             ! min(a%nCols,a%nRows)
    integer :: nCols, nRows                  ! Copies of a%...
    real(rm), dimension(:,:), pointer :: T   ! A temporary dense matrix

    include "updatediagonal_0.f9h"

  contains
    subroutine UpdateDenseDiagonal ( T, LAMBDA, START )
      real(rm), intent(inout) :: T(:,:)
      real(r8), intent(in) :: LAMBDA
      integer, intent(in) :: START
      integer :: I
      do i = start, n
        t(i,i) = t(i,i) + lambda
      end do
    end subroutine UpdateDenseDiagonal

  end subroutine UpdateDiagonal_0_r8

  ! -------------------------------------------  UpdateDiagonal_0_r4  -----
  subroutine UpdateDiagonal_0_r4 ( A, LAMBDA )
  ! Add LAMBDA to the diagonal of A
    type(MatrixElement_T), intent(inout) :: A
    real(r4), intent(in) :: LAMBDA

    integer :: I, J                          ! Subscripts and loop inductors
    integer :: N                             ! min(a%nCols,a%nRows)
    integer :: nCols, nRows                  ! Copies of a%...
    real(rm), dimension(:,:), pointer :: T   ! A temporary dense matrix

    include "updatediagonal_0.f9h"

  contains
    subroutine UpdateDenseDiagonal ( T, LAMBDA, START )
      real(rm), intent(inout) :: T(:,:)
      real(r4), intent(in) :: LAMBDA
      integer, intent(in) :: START
      integer :: I
      do i = start, n
        t(i,i) = t(i,i) + lambda
      end do
    end subroutine UpdateDenseDiagonal

  end subroutine UpdateDiagonal_0_r4

  ! ----------------------------------------  UpdateDiagonalVec_0_r8  -----
  subroutine UpdateDiagonalVec_0_r8 ( A, X, SUBTRACT, INVERT, FORGIVEZEROS )
  ! Add X to the diagonal of A if SUBTRACT is absent or false.
  ! Subtract X from the diatonal of A if SUBTRACT is present and true.
  ! If INVERT is present and true, use the inverses of the elements of X.
    type(MatrixElement_T), intent(inout) :: A
    real(r8), intent(in) :: X(:)
    logical, intent(in), optional :: SUBTRACT
    logical, intent(in), optional :: INVERT  ! Update with inverse of X
    logical, intent(in), optional :: FORGIVEZEROS ! Allow zeros in invert case

    integer :: I, J                          ! Subscripts and loop inductors
    logical :: MyInvert
    logical :: MyForgive
    integer :: N                             ! min(a%nCols,a%nRows)
    integer :: M                             ! max(a%nCols,a%nRows) / n
    integer :: nCols, nRows                  ! Copies of a%...
    real(rm) :: S                            ! Sign to use for X, +1 or -1
    real(rm), dimension(:,:), pointer :: T   ! A temporary dense matrix
    real(rm) :: V                            ! The value to update.  Either
    !                                          S*X or S/X.
    MyForgive = .false.
    if ( present(ForgiveZeros) ) MyForgive = ForgiveZeros
    include "updatediagonalvec_0.f9h"

  contains
    subroutine UpdateDenseDiagonal ( T, X, S, START )
      real(rm), intent(inout) :: T(:,:) ! Matrix element to update
      real(r8), intent(in) :: X(:)      ! Vector update diagonal
      real(rm), intent(in) :: S         ! Sign for X, +1 or -1.
      integer, intent(in) :: START      ! Where to start
      integer :: I
      do i = start, n
        if ( myInvert ) then
          if ( abs(x(i)) <= tiny(0.0_r8) ) then
            if ( myForgive ) then
              v = 0.0_r8
            else
              call MLSMessage ( MLSMSG_Error, moduleName, &
                & "Cannot update with inverse of zero in UpdateDiagonalVec_0" )
            end if
          else
            v = s / x(i)
          end if
        else
          v = s * x(i)
        end if
        t(i,i) = t(i,i) + v
      end do
    end subroutine UpdateDenseDiagonal
  end subroutine UpdateDiagonalVec_0_r8

  ! ----------------------------------------  UpdateDiagonalVec_0_r4  -----
  subroutine UpdateDiagonalVec_0_r4 ( A, X, SUBTRACT, INVERT, FORGIVEZEROS )
  ! Add X to the diagonal of A if SUBTRACT is absent or false.
  ! Subtract X from the diatonal of A if SUBTRACT is present and true.
  ! If INVERT is present and true, use the inverses of the elements of X.
    type(MatrixElement_T), intent(inout) :: A
    real(r4), intent(in) :: X(:)
    logical, intent(in), optional :: SUBTRACT
    logical, intent(in), optional :: INVERT  ! Update with inverse of X
    logical, intent(in), optional :: FORGIVEZEROS ! Allow zeros in invert case

    integer :: I, J                          ! Subscripts and loop inductors
    logical :: MyInvert
    logical :: MyForgive
    integer :: N                             ! min(a%nCols,a%nRows)
    integer :: M                             ! max(a%nCols,a%nRows) / n
    integer :: nCols, nRows                  ! Copies of a%...
    real(rm) :: S                            ! Sign to use for X, +1 or -1
    real(rm), dimension(:,:), pointer :: T   ! A temporary dense matrix
    real(rm) :: V                            ! The value to update.  Either
    !                                          S*X or S/X.
    MyForgive = .false.
    if ( present(ForgiveZeros) ) MyForgive = ForgiveZeros
    include "updatediagonalvec_0.f9h"

  contains
    subroutine UpdateDenseDiagonal ( T, X, S, START )
      real(rm), intent(inout) :: T(:,:) ! Matrix element to update
      real(r4), intent(in) :: X(:)      ! Vector update diagonal
      real(rm), intent(in) :: S         ! Sign for X, +1 or -1.
      integer, intent(in) :: START      ! Where to start
      integer :: I
      do i = start, n
        if ( myInvert ) then
          if ( abs(x(i)) <= tiny(0.0_r4) ) then
            if ( myForgive ) then
              v = 0.0_r4
            else
              call MLSMessage ( MLSMSG_Error, moduleName, &
                & "Cannot update with inverse of zero in UpdateDiagonalVec_0" )
            end if
          else
            v = s / x(i)
          end if
        else
          v = s * x(i)
        end if
        t(i,i) = t(i,i) + v
      end do
    end subroutine UpdateDenseDiagonal
  end subroutine UpdateDiagonalVec_0_r4

! =====     Private Procedures     =====================================

  ! -------------------------------------------  CreateEmptyBlock  -----
  subroutine CreateEmptyBlock ( EmptyBlock )
    type(MatrixElement_T), intent(inout) :: EmptyBlock
    ! EmptyBlock is intent(inout) so that destroyBlock will have a chance
    ! to clean up surds.  Default initialization for intent(out) would
    ! nullify the pointers before destroyBlock had a chance to deallocate
    ! them.
    call destroyBlock ( emptyBlock )
  end subroutine CreateEmptyBlock

  ! ------------------------------------------  DUMP_MATRIX_BLOCK  -----
  subroutine DUMP_MATRIX_BLOCK ( MATRIX_BLOCK, NAME, DETAILS, BOUNDS, CLEAN )
    type(MatrixElement_T), intent(in) :: MATRIX_BLOCK
    character(len=*), intent(in), optional :: NAME
    integer, intent(in), optional :: DETAILS   ! Print details, 0 => minimal,
                                               !  1 => structure, 2 => values
                                               !  default 1.
    integer, intent(in), optional :: BOUNDS(4) ! Dump only Bounds(1):Bounds(2)
                                               !        X  Bounds(3):Bounds(4)
    logical, intent(in), optional :: CLEAN     ! print \size
    integer :: MY_DETAILS
    logical :: My_Clean
    my_details = 1
    if ( present(details) ) my_details = details
    my_clean = .false.
    if ( present(clean) ) my_clean = clean
    if ( present(name) ) call output ( name, advance='yes' )
    call output ( '  ' )
    call output ( matrix_block%nRows ); call output ( " Rows, " )
    call output ( matrix_block%nCols ); call output ( " Columns, " )
    select case ( matrix_block%kind )
    case ( m_banded )
      call output ( 'Banded' )
      if ( my_details > 0 ) then
        call output ( ' First-nonzero-rows =', advance='yes' )
        call dump ( matrix_block%r1(1:) )
        call output ( '  Last-value-in-column =', advance='yes' )
        call dump ( matrix_block%r2(1:) )
      end if
    case ( m_column_sparse )
      call output ( 'Column-sparse' )
      if ( my_details > 0 ) then
        call output ( ' Last-in-column =', advance='yes' )
        call dump ( matrix_block%r1(1:) )
        call output ( '  Rows =', advance='yes' )
        call dump ( matrix_block%r2(1:) )
      end if
    case ( m_full )
      call output ( 'Full' )
    end select
    if ( matrix_block%kind == M_Absent ) then
      call output ( 'Absent', advance='yes' )
    else if ( my_details > 1 ) then
      call output ( ' Values =', advance='yes' )
      if ( my_clean )  call output ( trim(" \ ") )
      if ( present(bounds) ) then
        if ( my_clean ) &
          & call output ( (bounds(2)-bounds(1))*(bounds(4)-bounds(3)), advance='yes' )
        call dump ( matrix_block%values(bounds(1):bounds(2),bounds(3):bounds(4)), &
          & clean=clean )
      else
        if ( my_clean ) &
          & call output ( size(matrix_block%values), advance='yes' )
        call dump ( matrix_block%values, clean=clean )
      end if
    else
      call output ( ' ' )
      call output ( size(matrix_block%values) )
      call output ( ' values.', advance='yes' )
    end if
  end subroutine DUMP_MATRIX_BLOCK

  ! -------------------------------------------------- TestBlock -----
  subroutine TestBlock ( B, M, OK, NAME, KINDA, KINDB )
    ! Given the block B, densify it and compare it to M
    ! Any differences above a certain threshold are reported
    ! This is typically used to report the results of tests
    type(MatrixElement_T), intent(in) :: B ! Block
    real(rm), dimension(:,:), intent(in) :: M ! Matrix to compare it to
    logical, intent(out) :: OK          ! Set if they are OK
    character (len=*), optional :: NAME ! Name of operation being tested
    integer, intent(in), optional :: KINDA ! Kind for one part of expression
    integer, intent(in), optional :: KINDB ! Kind for other part of expression
    
    ! Local parameters
    character (len=*), parameter, dimension(0:3) :: KINDNAMES = &
      & (/'Absent', 'Banded','Sparse','Full  '/)
    ! Local variables
    real(rm), dimension(:,:), pointer :: BM ! B dense
    real(rm) :: D, E = -1.0_rm, EMAX
    integer :: I, IMAX, J, JMAX             ! Subscripts, loop inductors
    real(rm), parameter :: T = tiny(1.0_rm)

    ! Executable code
    if ( e < 0.0_rm ) e = sqrt(epsilon(1.0_rm))
    ok = .true.
    nullify ( bm )
    call Allocate_test ( bm, b%nRows, b%nCols, 'bm', ModuleName )
    call Densify ( bm, b )

    emax = -1.0_rm
  o:do j = 1, ubound(m,2)
      do i = 1, ubound(m,1)
        d = abs(bm(i,j)-m(i,j))
        if ( d > 1.0e3_rm * max(t,e*(abs(bm(i,j))+abs(m(i,j)))) ) then
          if ( d > emax ) then
            emax = d
            imax = i
            jmax = j
          end if
          if ( ok ) then ! Don't print twice
            call output ( 'Matrix algebra failed', advance='yes' )
            call dump ( bm, name='L2 Result')
            call dump ( m, name='Slow result')
            call output ( 'Matrix algebra failed' )
            if (present(name)) call output ( ' for '//trim(name) )
            if (present(kinda) .or. present(kindb)) then
              call output ( ' case' )
              if (present(kindA)) call output ( ' '//kindNames(kindA) )
              if (present(kindB)) call output ( ' '//kindNames(kindB) )
            end if
            call output ( '', advance='yes' )
            call output ( 'First error at i = ' )
            call output ( i )
            call output ( ', j = ' )
            call output ( j )
            call output ( ' bm(i,j) = ' )
            call output ( bm(i,j) )
            call output ( ', m(i,j) = ' )
            call output ( m(i,j), advance='yes' )
            ok = .false.
          end if
        end if
      end do
    end do o
    if ( .not. ok ) then
      call output ( 'Maximum absolute error = ' )
      call output ( emax )
      call output ( ' at (' )
      call output ( imax )
      call output ( ',' )
      call output ( jmax )
      call output ( ')', advance='yes' )
    end if
    call deallocate_test ( bm, 'bm', ModuleName )
  end subroutine TestBlock

  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: MatrixModule_0.f90,v 2.111 2006/08/01 03:18:27 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
end module MatrixModule_0

! $Log: MatrixModule_0.f90,v $
! Revision 2.111  2006/08/01 03:18:27  vsnyder
! Add ForWhom argument to CreateBlock for leak checking
!
! Revision 2.110  2006/08/01 02:49:08  vsnyder
! Remove unused .TX. defined operator, which leaks memory anyway
!
! Revision 2.109  2006/05/23 22:37:25  vsnyder
! Dump the block size only if CLEAN
!
! Revision 2.108  2006/05/23 21:43:34  vsnyder
! Add CLEAR option to some dumps
!
! Revision 2.107  2005/06/22 20:45:29  pwagner
! Use optional arg FORGIVEZEROS to UpdateDiagonalVec
!
! Revision 2.106  2005/06/22 17:25:49  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.105  2005/06/21 23:57:13  livesey
! Added forgiveZeros in UpdateDiagonal (invert)
!
! Revision 2.104  2004/10/14 04:54:06  livesey
! Added ClearLower_0
!
! Revision 2.103  2004/07/07 19:34:30  vsnyder
! Add Init argument to CreateBlock
!
! Revision 2.102  2004/05/17 22:06:35  livesey
! Added check for valid numbers in CheckIntegrity_0
!
! Revision 2.101  2004/01/30 23:19:24  livesey
! Changed tiny to epsilon in DenseCyclicJacobi
!
! Revision 2.100  2004/01/29 03:31:18  livesey
! Got a working DenseCyclicJacobi and added FrobeniusNorm
!
! Revision 2.99  2004/01/28 01:56:48  livesey
! Added the Cyclic Jacobi code.
!
! Revision 2.98  2004/01/24 01:02:12  livesey
! Changed order of arguments in TransposeMatrix_0
!
! Revision 2.97  2003/10/09 22:15:46  livesey
! Added more intelligence in the sparse/spase and banded/banded adds, so
! if blocks have same layout just add the values.  Also added the
! CheckForSimpleBandedLayout routine.
!
! Revision 2.96  2003/08/05 19:32:12  livesey
! Temporarily suppress column_sparse blocks
!
! Revision 2.95  2003/06/30 20:21:40  livesey
! Made it more reslient to being asked to Cholesky Factor an empty block.
!
! Revision 2.94  2003/06/03 19:21:08  livesey
! Added status options to SolveCholesky, and invert option to GetDiagonal
!
! Revision 2.93  2003/02/22 00:41:54  livesey
! Fixed inconsequential bug in Sparse/Banded and Banded/Sparse multiplies
!
! Revision 2.92  2003/02/21 04:06:14  livesey
! Fixed up the OpenMP stuff, seems to work now
!
! Revision 2.91  2003/02/07 11:25:28  mjf
! Small change to Add_Matrix_Blocks to correct m_column_sparse handling.  Unused code removed from SparsifyA.
!
! Revision 2.90  2003/01/10 02:47:06  livesey
! Added quasi in-place densify, and brought sparsify back into the fold.
!
! Revision 2.89  2003/01/09 01:21:27  livesey
! Fixed bugs in column sparse representation, turned it back on.
!
! Revision 2.88  2003/01/08 23:51:12  livesey
! Added sparsify_0
!
! Revision 2.87  2003/01/08 21:32:29  livesey
! Split off _r4, _r8 routines into generic includes where sensible
!
! Revision 2.86  2002/11/22 12:52:50  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.85  2002/10/07 23:24:43  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.84  2002/09/23 23:18:59  vsnyder
! Comment out declarations used by commented-out broken code in Add_Matrix_Blocks
!
! Revision 2.83  2002/09/13 18:08:12  pwagner
! May change matrix precision rm from r8
!
! Revision 2.82  2002/09/11 17:43:38  pwagner
! Began changes needed to conform with matrix%values type move to rm from r8
!
! Revision 2.81  2002/09/06 15:45:54  mjf
! In ReflectMatrix_0 need to Densify sparse matrices to do the
! reflection.
!
! Revision 2.80  2002/09/02 22:56:45  livesey
! Embarassing bug fix.
!
! Revision 2.79  2002/08/29 21:35:34  livesey
! New 'blocking' approach to MultiplyMatrix_XTY_0
!
! Revision 2.78  2002/08/29 04:44:53  livesey
! Made the MultiplyMatrix_XY and XT_T slightly more efficient.
!
! Revision 2.77  2002/08/19 20:50:56  vsnyder
! Add Add_Matrix_Blocks_Unscaled, clean up x(i) == 0.0_rm
!
! Revision 2.76  2002/08/15 22:12:47  livesey
! Bug work around in Add_Matrix_Blocks and fix in TransposeMatrix_0
!
! Revision 2.75  2002/08/06 02:15:10  livesey
! Added TransposeMatrix_0 and ReflectMatrix_0
!
! Revision 2.74  2002/07/22 03:26:25  livesey
! Added checkIntegrity
!
! Revision 2.73  2002/07/17 06:00:55  livesey
! Added M_Unknown
!
! Revision 2.72  2002/07/01 23:49:47  vsnyder
! Plug memory leaks
!
! Revision 2.71  2002/06/18 01:21:18  vsnyder
! SolveCholeskyM_0 wasn't solving for the first row in the dense-block /
! transpose=.true. case.
!
! Revision 2.70  2002/06/15 00:41:20  vsnyder
! 1.  Fix some comments.  2.  Fix dimensions for result of MultiplyMatrix_XY_T_0.
! 3.  Fix some references to optional arguments not protected by present().
! 4.  Add Spill_0 subroutine.
!
! Revision 2.69  2002/03/12 01:38:33  vsnyder
! Fix typo in a comment
!
! Revision 2.68  2002/03/05 23:16:35  livesey
! Fixed various bugs in MultiplyMatrix_XY_0 and MultiplyMatrix_XY_T_0
!
! Revision 2.67  2002/02/23 02:59:51  vsnyder
! Correct tests for 'don't update, don't subtract; fix LaTeX
!
! Revision 2.66  2002/02/23 02:34:10  vsnyder
! Fix the LaTeX for InvertDenseCholesky
!
! Revision 2.65  2002/02/23 02:13:16  vsnyder
! Check for absent blocks before checking shapes
!
! Revision 2.64  2002/02/22 20:11:45  vsnyder
! Fix the LaTeX in InvertDenseCholesky_0
!
! Revision 2.63  2002/02/22 01:17:41  vsnyder
! Added InvertCholesky_0, InvertDenseCholesky_0, MultiplyMatrix_XY_0 and
! MultiplyMatrix_XY_T_0.  Changed the name MultiplyMatrixBlocks_0 to
! MultiplyMatrix_XTY_0.  Changed the name of MatrixInversion to
! MatrixInversion_0.  Added generics.  Revised MatrixInversion_0 to use
! InvertDenseCholesky.
!
! Revision 2.62  2002/02/09 21:27:12  livesey
! Added nullification in MatrixInversion
!
! Revision 2.61  2002/02/05 02:39:59  vsnyder
! Change mask from 1-bit per to 8-bits per (using character)
!
! Revision 2.60  2001/12/01 01:02:52  livesey
! Tidied up erroneous handling of status in DenseCholesky/CholeskyFactor_0
!
! Revision 2.59  2001/11/14 01:00:07  vsnyder
! Use LAPACK GEMV interface for dense matrix-vector multiply
!
! Revision 2.58  2001/11/09 18:12:09  livesey
! Change checkBlocks to default to false.
!
! Revision 2.57  2001/11/09 02:03:47  vsnyder
! Corrected procedure name in character literals in calls to allocate_test
! Corrected some comments.  Put some if's around references to dot, in case
! N = 0 but a subscript is out of bounds.
!
! Revision 2.56  2001/11/08 02:08:04  vsnyder
! Moved interfaces for DOT to dot_external
! Added OpenMP comments
! Improved double-checking code for sparse algebra
!
! Revision 2.55  2001/10/26 18:08:57  livesey
! Added upper argument to MatrixInversion
!
! Revision 2.54  2001/10/20 01:21:02  vsnyder
! Inserted OpenMP comments in MultiplyMatrixBlocks_0, CholeskyFactor_0 and DenseCholesky
!
! Revision 2.53  2001/10/16 19:28:31  vsnyder
! Repair comment about 'details' argument of 'Dump_Matrix_Block'
!
! Revision 2.52  2001/10/04 23:49:57  livesey
! Added checking code, and temporarily suppressed sparse
!
! Revision 2.51  2001/10/03 17:33:11  dwu
! modified MatrixInversion
!
! Revision 2.50  2001/10/01 23:35:38  vsnyder
! Correct blunder in ClearRows_0
!
! Revision 2.49  2001/10/01 20:32:27  vsnyder
! Handle word and bit indexing in mask consistently
!
! Revision 2.48  2001/09/29 00:25:51  vsnyder
! Correct word indexing for mask operations
!
! Revision 2.47  2001/09/28 17:56:10  dwu
! add MatrixInversion, SolveCholeskyA_0
!
! Revision 2.46  2001/09/27 18:41:21  vsnyder
! Apply mask in matrix-vector multiply
!
! Revision 2.45  2001/09/24 23:01:11  vsnyder
! Make consistent/correct lower bound calculation for MASK array
!
! Revision 2.44  2001/07/19 17:54:59  vsnyder
! Correct blunders in banded matrix*matrix and matrix*vector.
! Handle "subtract" argument differently.
!
! Revision 2.43  2001/07/16 20:36:49  livesey
! Added fix for empty columns in banded MatrixVector multiply
!
! Revision 2.42  2001/07/11 22:07:57  vsnyder
! Interim commit -- may still be broken
!
! Revision 2.41  2001/06/28 01:05:59  vsnyder
! Allow last diagonal element in Cholesky factor to be tiny
!
! Revision 2.40  2001/06/27 01:15:10  vsnyder
! XMASK and YMASK arguments of MultiplyMatrixBlocks need to be pointers
! because they might not be associated in the caller.  Therefore they
! cannot have specified lower bounds.  Therefore we need to use i/b+1
! (j/b+1) for subscripts of xm (ym).
!
! Revision 2.39  2001/06/26 23:56:04  vsnyder
! Make [XY]MASK 'target' instead of 'pointer' so they can have lower bound
!
! Revision 2.38  2001/06/26 20:40:33  vsnyder
! Simplify by using zero for lower bound for first dimension of mask
!
! Revision 2.37  2001/06/04 22:41:37  livesey
! Various bug fixes associated with m_banded.  Some still remain to be
! solved though
!
! Revision 2.36  2001/06/01 01:03:39  vsnyder
! Add 'sqrt' option to 'GetDiagonal_0'; add 'Multiply' generic
!
! Revision 2.35  2001/05/30 21:53:16  vsnyder
! Finish? 'invert' argument in 'UpdateDiagonalVec_0'
!
! Revision 2.34  2001/05/30 20:18:01  vsnyder
! Add 'invert' argument to 'UpdateDiagonal'
!
! Revision 2.33  2001/05/24 23:15:24  vsnyder
! Don't scale absent blocks -- their VALUES pointer isn't associated
!
! Revision 2.32  2001/05/24 18:13:28  vsnyder
! Make DenseCholesky public instead of internal; cosmetic changes
!
! Revision 2.31  2001/05/22 19:09:13  vsnyder
! Implement Col_L1
!
! Revision 2.30  2001/05/19 00:13:43  vsnyder
! Correct SolveCholesky*_0
!
! Revision 2.29  2001/05/17 20:17:56  vsnyder
! Implement GetMatrixElement.  Change handling of mask in MultiplyMatrixBlocks.
!
! Revision 2.28  2001/05/12 01:05:23  vsnyder
! Change 'details' argumet of 'dump_matrix_block' to integer
!
! Revision 2.27  2001/05/11 22:02:06  vsnyder
! Correct errors in SolveCholeskyV_0
!
! Revision 2.26  2001/05/10 22:53:36  vsnyder
! Handle empty block creation differently.  Add Update and Subtact to
! MultiplyMatrixVector* where it wasn't before.  Get CholeskyFactor_1 to work.
!
! Revision 2.25  2001/05/10 02:14:11  vsnyder
! Repair CloneBlock, MaxAbsVal, MultiplyMatrixBlocks
!
! Revision 2.24  2001/05/09 19:45:37  vsnyder
! More work correcting blunders in sparse matrix code.  Add BandHeight
! argument to CreateBlock.  Correct loss of lower bounds in CloneBlock.
!
! Revision 2.23  2001/05/09 01:58:12  vsnyder
! Improper intent(out) -> intent(inout), don't access an absent optional dummy
!
! Revision 2.22  2001/05/08 20:29:40  vsnyder
! Periodic commit -- workong on sparse matrix blunders
!
! Revision 2.21  2001/05/03 02:10:26  vsnyder
! Nullify a bunch of pointers that should have been but weren't.  Use a
! disassociated VALUES array instead of a zero-size one for absent blocks.
!
! Revision 2.20  2001/04/30 23:44:25  vsnyder
! Correct/remove some incorrect size tests in MultiplyMatrixVectorNoT
!
! Revision 2.19  2001/04/30 17:47:18  livesey
! Reverted to original size of R2, the problem must be somewhere else.
!
! Revision 2.18  2001/04/28 07:03:21  livesey
! Removed a print statement
!
! Revision 2.17  2001/04/28 05:04:16  livesey
! Temporarily changed dot to dot_product in MultiplyMatrixVectorNoT, to
! avoid run time error I don't understand.
!
! Revision 2.16  2001/04/28 04:40:17  livesey
! Some tidying up, removing unnecessary(?) tests for square matrices
! in multiplyMatrixVector and its relatives.  Also changing allocation
! of r2 for m_banded, as it needs an extra element.
!
! Revision 2.15  2001/04/28 01:33:02  livesey
! Now DestroyBlock doesn't destroy absent blocks as they all point to the same place.
!
! Revision 2.14  2001/04/25 00:50:09  vsnyder
! Make MultiplyMatrixNoT generic
!
! Revision 2.13  2001/04/11 22:43:54  vsnyder
! Fold Deallocate_test into sparsify
!
! Revision 2.12  2001/02/22 01:55:06  vsnyder
! Add code to invert a Cholesky factor
!
! Revision 2.11  2001/02/09 18:37:16  pwagner
! Commented-out statements that offended NAG v4.0
!
! Revision 2.10  2001/01/26 19:00:01  vsnyder
! Periodic commit
!
! Revision 2.9  2001/01/19 23:50:45  vsnyder
! Periodic commit
!
! Revision 2.8  2000/11/23 01:09:19  vsnyder
! Add provision to ignore specified columns during matrix-matrix multiply
!
! Revision 2.7  2000/11/15 00:18:26  vsnyder
! Added assignment(=) interface, row scale, column scale
!
! Revision 2.6  2000/11/10 00:28:13  vsnyder
! Added multiply untransposed matrix * vector
!
! Revision 2.5  2000/11/09 01:22:43  vsnyder
! Periodic commit -- still under construction
!
! Revision 2.4  2000/10/13 22:22:48  vsnyder
! Change name of multiply operator from .XT. to .TX.
!
! Revision 2.3  2000/10/12 20:10:08  vsnyder
! Make default accessibility private
!
! Revision 2.2  2000/10/10 23:11:34  vsnyder
! Correct number of rows and columns for zero matrix.
!
! Revision 2.1  2000/10/04 20:24:45  vsnyder
! Initial entry
!
@


2.111
log
@Add ForWhom argument to CreateBlock for leak checking
@
text
@d3464 1
a3464 1
       "$Id: MatrixModule_0.f90,v 2.110 2006/08/01 02:49:08 vsnyder Exp $"
d3472 3
@


2.110
log
@Remove unused .TX. defined operator, which leaks memory anyway
@
text
@d854 1
a854 1
      call createBlock ( z, nc, nc, M_Banded, j )
d878 1
a878 1
        call createBlock ( z, nc, nc, M_Full )
d1046 1
a1046 1
    & BandHeight, Init )
d1082 1
d1086 1
d1090 2
d1107 1
a1107 1
        & call allocate_test ( z%values, numberNonzero, 1, "z%values", ModuleName )
d1113 1
a1113 1
        & call allocate_test ( z%values, NumberNonzero, 1, "z%values", ModuleName )
d1118 1
a1118 1
        & call allocate_test ( z%values, nRows, nCols, "z%values", ModuleName )
d1535 1
a1535 1
        call createBlock ( UI, u%nRows, u%nCols, M_Full )
d1552 1
a1552 1
        & numberNonzero = u%nRows, bandHeight = 1 )
d1775 2
a1776 1
      if ( abs(beta) < 0.5_rm ) call createBlock ( zb, xb%nRows, yb%nCols, M_Absent )
d1820 2
a1821 1
      call createBlock ( zb, xb%nRows, yb%nCols, m_full, noValues=.true. )
d1856 2
a1857 1
      if ( abs(beta) < 0.5_rm ) call createBlock ( zb, xb%nRows, yb%nRows, M_Absent )
d1901 2
a1902 1
      call createBlock ( zb, xb%nRows, yb%nRows, M_Full, noValues=.true. )
d1970 2
a1971 1
      if ( .not. my_upd) call createBlock ( zb, xb%nCols, yb%nCols, M_Absent )
d2112 2
a2113 1
          call createBlock ( zb, xb%nCols, yb%nCols, M_Full, novalues=.true. )
d2250 2
a2251 1
          call createBlock ( zb, xb%nCols, yb%nCols, M_Full, novalues=.true. )
d2282 2
a2283 1
        call createBlock ( zb, xb%nCols, yb%nCols, M_Full, novalues=.true. )
d2970 1
a2970 1
      call createBlock ( b, size(z,1), size(z,2), M_Absent )
d2991 2
a2992 1
        call createBlock ( b, size(z,1), size(z,2), M_Banded, sum(nnzc) )
d3001 2
a3002 1
        call createBlock ( b, size(z,1), size(z,2), M_Column_Sparse, nnz )
d3018 2
a3019 1
        call createBlock ( b, size(z,1), size(z,2), M_Full, noValues=.true. )
d3023 1
a3023 1
        call createBlock ( b, size(z,1), size(z,2), M_Full )
d3143 1
a3143 1
      call CreateBlock ( z, a%nCols, a%nRows, m_full )
d3464 1
a3464 1
       "$Id: MatrixModule_0.f90,v 2.109 2006/05/23 22:37:25 vsnyder Exp $"
d3472 3
@


2.109
log
@Dump the block size only if CLEAN
@
text
@d51 1
a51 1
  public :: operator(+), operator(.TX.), ReflectMatrix, RowScale
a162 4
  interface NewMultiplyMatrixVector_0 ! (see .tx. below)
    module procedure NewMultiplyMatrixVector_0_r4, NewMultiplyMatrixVector_0_r8
  end interface

a170 5
  interface operator ( .TX. ) ! A^T * B
    module procedure NewMultiplyMatrix_XTY_0, &
      & NewMultiplyMatrixVector_0_r4, NewMultiplyMatrixVector_0_r8
  end interface

d308 1
a308 1
          call cloneBlock ( zb, x )
d398 1
a398 1
          call cloneBlock ( zb, x )
d429 1
a429 1
        call CloneBlock ( zb, y )                ! Zb = y, except the values
d956 1
a956 1
  subroutine CloneBlock ( Z, X ) ! Z = X, except the values
d962 1
d975 1
a975 1
        & "z%values", ModuleName )
d1040 1
a1040 1
    call CloneBlock ( Z, X )
d3449 1
a3449 1
       "$Id: MatrixModule_0.f90,v 2.108 2006/05/23 21:43:34 vsnyder Exp $"
d3457 3
@


2.108
log
@Add CLEAR option to some dumps
@
text
@d3368 2
a3369 1
        call output ( size(matrix_block%values), advance='yes' )
d3457 1
a3457 1
       "$Id: MatrixModule_0.f90,v 2.107 2005/06/22 20:45:29 pwagner Exp $"
d3465 3
@


2.107
log
@Use optional arg FORGIVEZEROS to UpdateDiagonalVec
@
text
@d3318 1
a3318 1
  subroutine DUMP_MATRIX_BLOCK ( MATRIX_BLOCK, NAME, DETAILS, BOUNDS )
d3326 1
d3328 1
d3331 2
d3361 1
d3363 4
a3366 1
        call dump ( matrix_block%values(bounds(1):bounds(2),bounds(3):bounds(4)) )
d3368 2
a3369 1
        call dump ( matrix_block%values )
d3456 1
a3456 1
       "$Id: MatrixModule_0.f90,v 2.106 2005/06/22 17:25:49 pwagner Exp $"
d3464 3
@


2.106
log
@Reworded Copyright statement, moved rcs id
@
text
@d212 1
a212 1
       "$RCSfile: $"
d3222 2
a3223 1

d3254 1
a3254 1
  subroutine UpdateDiagonalVec_0_r4 ( A, X, SUBTRACT, INVERT )
d3262 1
d3274 2
a3275 1

d3447 1
a3447 1
       "$Id: $"
d3455 3
@


2.105
log
@Added forgiveZeros in UpdateDiagonal (invert)
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d210 1
a210 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: MatrixModule_0.f90,v 2.104 2004/10/14 04:54:06 livesey Exp $"
  character (len=len(idParm)), private :: Id = idParm
d212 2
a213 2
       "$RCSfile: MatrixModule_0.f90,v $"
  private not_used_here
d3442 5
d3452 3
@


2.104
log
@Added ClearLower_0
@
text
@d204 1
a204 1
       "$Id: MatrixModule_0.f90,v 2.103 2004/07/07 19:34:30 vsnyder Exp $"
d3197 1
a3197 1
  subroutine UpdateDiagonalVec_0_r8 ( A, X, SUBTRACT, INVERT )
d3205 1
d3209 1
d3229 10
a3238 4
          if ( abs(x(i)) <= tiny(0.0_r8) ) call MLSMessage ( &
            & MLSMSG_Error, moduleName, &
            & "Cannot update with inverse of zero in UpdateDiagonalVec_0" )
          v = s / x(i)
a3244 1

d3259 1
d3279 10
a3288 4
          if ( abs(x(i)) <= tiny(0.0_r8) ) call MLSMessage ( &
            & MLSMSG_Error, moduleName, &
            & "Cannot update with inverse of zero in UpdateDiagonalVec_0" )
          v = s / x(i)
d3442 3
@


2.103
log
@Add Init argument to CreateBlock
@
text
@d27 1
a27 1
  public :: CholeskyFactor_0, ClearRows, ClearRows_0, CloneBlock, ColumnScale
d66 4
d204 1
a204 1
       "$Id: MatrixModule_0.f90,v 2.102 2004/05/17 22:06:35 livesey Exp $"
d902 21
d3428 3
@


2.102
log
@Added check for valid numbers in CheckIntegrity_0
@
text
@d200 1
a200 1
       "$Id: MatrixModule_0.f90,v 2.101 2004/01/30 23:19:24 livesey Exp $"
d1024 1
a1024 1
    & BandHeight )
d1026 8
a1033 7
  ! information.  The "NumberNonzero" is required if and only if the
  ! "Kind" argument has the value M_Banded or M_Column_Sparse.
  ! The block is first destroyed, so as not to have a memory leak.
  ! If NoValues is present and true, the values component is not allocated
  ! If Kind == M_Banded and BandHeight is present, the band height is
  !   assumed to be uniform, and the R1 and R2 components are filled to
  !   reflect that assumption.
d1059 1
d1100 1
d3403 3
@


2.101
log
@Changed tiny to epsilon in DenseCyclicJacobi
@
text
@d200 1
a200 1
       "$Id: MatrixModule_0.f90,v 2.100 2004/01/29 03:31:18 livesey Exp $"
d506 1
d639 1
a639 1
            & 'Banded block has too small a delta in R2 for ' // trim(clause) )
d645 1
a645 1
              & 'Banded block has too large a delta in R2 or R1 value for ' // &
d744 9
d3400 3
@


2.100
log
@Got a working DenseCyclicJacobi and added FrobeniusNorm
@
text
@d200 1
a200 1
       "$Id: MatrixModule_0.f90,v 2.99 2004/01/28 01:56:48 livesey Exp $"
d1199 1
a1199 1
      myTol = sqrt ( tiny ( 0.0_rm ) )
d3390 3
@


2.99
log
@Added the Cyclic Jacobi code.
@
text
@d28 3
a30 3
  public :: Col_L1, CopyBlock, CreateBlock, CreateBlock_0
  public :: DenseCholesky, Densify, DestroyBlock, DestroyBlock_0, Dump
  public :: GetDiagonal, GetMatrixElement, GetMatrixElement_0
d39 1
a39 1
  public :: MultiplyMatrix_XTY_0
d62 4
d90 4
d200 1
a200 1
       "$Id: MatrixModule_0.f90,v 2.98 2004/01/24 01:02:12 livesey Exp $"
d1090 50
d1180 2
a1181 2
    ! Section 8.4.3).  Note that as we only store the lower triangle of A
    ! some of the indices have been reversed from the above reference
d1193 1
d1211 1
d1213 4
a1216 2
      do q = 2, n
        norm = norm + sum ( a ( q, 1:q-1 ) ** 2 )
d1218 3
d1224 2
a1225 2
      do q = 2, n
        do p = 1, q-1
d1231 3
a1233 2
          ! We then rotate A to A = J^T A J which makes Aqp=0 and
          ! updates the diagonal of A.  Also change V to VJ
d1235 16
a1250 8
          ! Update A
          t = t * A(q,p)
          A(p,p) = A(p,p) - t
          A(q,q) = A(q,q) + t
          A(q,p) = 0.0_rm
          ! Update V
          V(p,:) =  V(p,:) * c + V(q,:) * s
          V(q,:) = -V(p,:) * s + V(q,:) * c
d1320 47
d3041 1
d3045 16
a3060 2
    if ( A ( q, p ) /= 0.0_rm ) then 
      tau =  ( A(q,q) - A(p,p)) / ( 2.0_rm * A(q,p) )
d3063 2
d3067 2
d3390 3
@


2.98
log
@Changed order of arguments in TransposeMatrix_0
@
text
@d192 1
a192 1
       "$Id: MatrixModule_0.f90,v 2.97 2003/10/09 22:15:46 livesey Exp $"
d1119 63
d2906 33
d3250 3
@


2.97
log
@Added more intelligence in the sparse/spase and banded/banded adds, so
if blocks have same layout just add the values.  Also added the
CheckForSimpleBandedLayout routine.
@
text
@d192 1
a192 1
       "$Id: MatrixModule_0.f90,v 2.96 2003/08/05 19:32:12 livesey Exp $"
d2844 4
a2847 4
  subroutine TransposeMatrix_0 ( M, MT )
    ! Given the matrix M, compute MT
    type ( MatrixElement_T), intent(in) :: M ! Input matrix
    type ( MatrixElement_T), intent(inout) :: MT ! Output matrix
d2853 2
a2854 2
    call DestroyBlock ( MT )
    select case ( m%kind )
d2857 2
a2858 2
      call CreateBlock ( mt, m%nCols, m%nRows, m_full )
      mt%values = transpose ( m%values )
d2861 3
a2863 3
      call Allocate_test ( D, m%nRows, m%nCols, 'D', ModuleName )
      call Allocate_test ( DT, m%nCols, m%nRows, 'DT', ModuleName )
      call Densify ( D, M )
d2865 1
a2865 1
      call Sparsify ( DT, MT, 'DT in TransposeMatrix_0', ModuleName )
d3154 5
@


2.96
log
@Temporarily suppress column_sparse blocks
@
text
@d25 2
a26 1
  public :: Add_Matrix_Blocks, CheckBlocks, CheckIntegrity, Assignment(=), CholeskyFactor
d192 1
a192 1
       "$Id: MatrixModule_0.f90,v 2.95 2003/06/30 20:21:40 livesey Exp $"
d297 18
a314 11
        ! Do it the slow way for now.
        nullify ( z, w )
        call allocate_test ( z, x%nRows, x%nCols, 'Z in Add_Matrix_Blocks', &
          & ModuleName )
        call allocate_test ( w, y%nRows, y%nCols, 'W in Add_Matrix_Blocks', &
          & ModuleName )
        call densify ( z, x )
        call densify ( w, y )
        z = z + s * w
        call sparsify ( z, zb, 'Z in Add_matrix_block', ModuleName )
        call Deallocate_test ( w, 'W in Add_Matrix_Blocks', ModuleName )
d388 14
a401 9
        ! Make a full matrix, then sparsify it.  There _must_ be a better
        ! way ???
        call allocate_test ( z, y%nRows, y%nCols, "Z in Add_Matrix_Blocks", &
          & ModuleName )
        call densify ( z, y )                    ! z = y%values
        if ( present(scale) ) z = s * z
        do k = 1, x%nCols
          z(x%r2(x%r1(k-1)+1:x%r1(k)), k) = &
            & z(x%r2(x%r1(k-1)+1:x%r1(k)), k) + &
d403 3
a405 2
        end do
        call sparsify ( z, zb, "Z in Add_Matrix_Blocks", ModuleName ) ! Zb = Z
a409 1
! Commented-out on account of internal NAG v4.0 bug
d476 20
d3154 3
@


2.95
log
@Made it more reslient to being asked to Cholesky Factor an empty block.
@
text
@d191 1
a191 1
       "$Id: MatrixModule_0.f90,v 2.94 2003/06/03 19:21:08 livesey Exp $"
d234 1
a234 1
  real, parameter, private :: COL_SPARSITY = 0.5  ! If more than this
d472 1
d592 2
d597 1
a597 1
            & 'Banded block has too small a delta in R2' )
d603 2
a604 1
              & 'Banded block has too large a delta in R2 or R1 value' )
d609 2
a610 1
              'Banded block contains 0 for R1 in non empty column' )
d666 2
d671 2
a672 1
            & 'Column sparse block has too small a delta in R1' )
d677 2
a678 1
            & 'Column sparse block has too large a delta in R1' )
d863 5
d871 1
a871 1
            & x%values(j,1) = 0.0_rm
d3121 3
@


2.94
log
@Added status options to SolveCholesky, and invert option to GetDiagonal
@
text
@d191 1
a191 1
       "$Id: MatrixModule_0.f90,v 2.93 2003/02/22 00:41:54 livesey Exp $"
d732 4
d737 1
a737 1
      & "Cannot CholeskyFactor an empty block" )
d3107 3
@


2.93
log
@Fixed inconsequential bug in Sparse/Banded and Banded/Sparse multiplies
@
text
@d191 1
a191 1
       "$Id: MatrixModule_0.f90,v 2.92 2003/02/21 04:06:14 livesey Exp $"
d1133 1
a1133 1
  subroutine GetDiagonal_0_r4 ( B, X, SquareRoot )
d1139 2
d1142 1
d1148 1
a1148 1
  subroutine GetDiagonal_0_r8 ( B, X, SquareRoot )
d1154 2
d1157 1
d2365 1
a2365 1
  subroutine SolveCholeskyA_0_r4 ( U, X, B, TRANSPOSE )
d2376 1
d2390 1
a2390 1
  subroutine SolveCholeskyA_0_r8 ( U, X, B, TRANSPOSE )
d2401 1
d2415 1
a2415 1
  subroutine SolveCholeskyM_0 ( U, X, B, TRANSPOSE )
d2425 1
d2464 8
a2471 3
            call dump ( u, 'Guilty party', details=2 )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyM_0 is singular" )
d2491 8
a2498 3
            call dump ( u, 'Guilty party', details=2 )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyM_0 is singular" )
d2510 8
a2517 3
          call dump ( u, 'Guilty party', details=2 )
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "U matrix in SolveCholeskyM_0 is singular" )
d2523 8
a2530 3
            call dump ( u, 'Guilty party', details=2 )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyM_0 is singular" )
d2551 8
a2558 3
        call dump ( u, 'Guilty party', details=2 )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "U matrix in SolveCholeskyM_0 is singular" )
d2564 8
a2571 3
          call dump ( u, 'Guilty party', details=2 )
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "U matrix in SolveCholeskyM_0 is singular" )
d2585 1
d2589 1
a2589 1
  subroutine SolveCholeskyV_0_r4 ( U, X, B, TRANSPOSE )
d2602 1
d2616 1
a2616 1
  subroutine SolveCholeskyV_0_r8 ( U, X, B, TRANSPOSE )
d2629 1
d3103 3
@


2.92
log
@Fixed up the OpenMP stuff, seems to work now
@
text
@d191 1
a191 1
       "$Id: MatrixModule_0.f90,v 2.91 2003/02/07 11:25:28 mjf Exp $"
d1797 1
d1879 1
d3061 3
@


2.91
log
@Small change to Add_Matrix_Blocks to correct m_column_sparse handling.  Unused code removed from SparsifyA.
@
text
@d191 1
a191 1
       "$Id: MatrixModule_0.f90,v 2.90 2003/01/10 02:47:06 livesey Exp $"
d766 1
a766 1
!$OMP PARALLEL DO private ( ij, rz, g)
d1742 1
a1742 1
!$OMP PARALLEL DO private ( xi_1, xi_n, xr_1, xr_n, cr_1, cr_n, c_n, xd, yd, xy)
d2086 1
a2087 1
!$OMP END PARALLEL DO
a2493 1
!$OMP PARALLEL DO private ( d )
d2501 1
d2508 1
a2509 1
!$OMP END PARALLEL DO
d3059 3
@


2.90
log
@Added quasi in-place densify, and brought sparsify back into the fold.
@
text
@d191 1
a191 1
       "$Id: MatrixModule_0.f90,v 2.89 2003/01/09 01:21:27 livesey Exp $"
d361 1
a361 1
        do k = 1, size(x%r1)
d370 1
a370 1
        do k = 1, size(x%r1)
d386 1
a386 1
        do k = 1, size(x%r1)
d397 1
a397 1
         do k = 1, size(x%r1)
d2657 3
a2659 3
          do i1 = 1, j-1 ! I1 is a column number in this case
            nnzc(i1) = count(abs(z(:,i1)) <= zt(i1))
          end do ! i1
d3059 3
@


2.89
log
@Fixed bugs in column sparse representation, turned it back on.
@
text
@d73 4
d173 1
a173 1
    module procedure Sparsify_r4, Sparsify_r8, Sparsify_0
d191 1
a191 1
       "$Id: MatrixModule_0.f90,v 2.88 2003/01/08 23:51:12 livesey Exp $"
d580 1
a580 1
      if ( any ( (/ block%r1(:), block%r2(1:) /) < 1 ) ) then
d582 1
a582 6
          & 'Banded block has 0/-ve value(s) in R1/R2' )
        checkIntegrity_0 = .false.
      end if
      if ( any ( (/ block%r1(:) /) > block%nRows ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Banded block has too large value(s) in R1' )
d591 1
a591 1
        n =  block%r2(i) - block%r2(i-1) - 1
d597 10
a606 4
        if ( block%r1(i) + n > block%nRows ) then
          call MLSMessage ( messageType, ModuleName, &
            & 'Banded block has too large a delta in R2' )
          checkIntegrity_0 = .false.
d1068 2
a1069 2
  ! ----------------------------------------------------  Densify  -----
  subroutine Densify ( Z, B )
d1097 20
a1116 1
  end subroutine DENSIFY
d2598 2
a2599 2
  ! ---------------------------------------------------  Sparsify_r4  -----
  subroutine Sparsify_r4 ( Z, B, Why, CallingModule )
d2602 1
a2602 1
    real(r4), pointer :: Z(:,:)              ! Full array of values
d2627 81
a2707 34
    include "sparsify.f9h"
  end subroutine Sparsify_r4

  ! ---------------------------------------------------  Sparsify_r8  -----
  subroutine Sparsify_r8 ( Z, B, Why, CallingModule )
  ! Given an array Z, compute its sparse representation and store it
  ! in the matrix block B.
    real(r8), pointer :: Z(:,:)              ! Full array of values
    type(MatrixElement_T), intent(inout) :: B     ! Z as a block, maybe sparse
    ! B is intent(inout) so that createBlock gets a chance to clean up surds
    character(len=*), intent(in), optional :: Why
    character(len=*), intent(in), optional :: CallingModule
    ! If either Why or CallingModule is present, Z is deallocated using
    ! Deallocate_Test

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyBlock using the B argument of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignBlock.
  ! !!!!! ===== END NOTE ===== !!!!! 

    integer :: I1, I2              ! Row indices in Z
    integer :: J                   ! Column index in Z
    integer :: KIND                ! Representation to use for B
    integer :: NNZ                 ! Number of nonzeroes in Z
    integer :: NNZC(size(z,2))     ! Number of nonzeroes in a column of Z
    integer :: R1(size(z,2))       ! Row number of first nonzero in a column
    real(rm), save :: SQ_EPS = -1.0_rm  ! sqrt(epsilon(1.0_rm))
    real(r8) :: ZT(size(z,2))      ! Maximum value in a column of Z, then
      ! max(sqrt(sq_eps*zt),tiny(1.0_rm)).  Elements less than this threshold
      ! in magnitude are considered to be zero.

    include "sparsify.f9h"
  end subroutine Sparsify_r8
d2710 1
a2710 1
  subroutine Sparsify_0 ( B )
d2720 1
a2720 1
  end subroutine Sparsify_0
d3059 3
@


2.88
log
@Added sparsify_0
@
text
@d187 1
a187 1
       "$Id: MatrixModule_0.f90,v 2.87 2003/01/08 21:32:29 livesey Exp $"
d230 1
a230 1
  real, parameter, private :: COL_SPARSITY = 0.0!0.5  ! If more than this
d612 61
a672 3
      call MLSMessage ( messageType, ModuleName, &
        & 'Block is column sparse.  I thought these were suppressed!' )
      checkIntegrity_0 = .false.
d1857 1
a1857 1
            do while ( l <= xb%r2(i) .and. n <= yb%r1(j) )
d1908 1
a1908 1
            do while ( l <= xb%r2(i) .and. n <= yb%r1(j) )
d1957 2
a1958 2
            xy = dot( l-k+1, xb%values(k,1), 1, yb%values(xb%r2(k),j), 1 )
!           xy = dot_product( xb%values(k:l,1), yb%values(xb%r2(k:l),j) )
d2646 2
a2647 3
    nullify ( z )
    call Allocate_test ( z, b%nRows, b%nCols, 'z', ModuleName )
    z = b%values
d2988 3
@


2.87
log
@Split off _r4, _r8 routines into generic includes where sensible
@
text
@d169 1
a169 1
    module procedure Sparsify_r4, Sparsify_r8
d187 1
a187 1
       "$Id: MatrixModule_0.f90,v 2.86 2002/11/22 12:52:50 mjf Exp $"
d2580 14
d2931 3
@


2.86
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d187 1
a187 1
       "$Id: MatrixModule_0.f90,v 2.85 2002/10/07 23:24:43 pwagner Exp $"
a835 1

d838 1
a838 21
    if ( present(newx) ) then
      z => newx
      call copyBlock ( z, x )
    else
      z => x
    end if
    select case ( z%kind )
    case ( M_Absent )
    case ( M_Banded )
      do i = 1, z%nCols
        z%values(z%r2(i-1)+1:z%r2(i),1) = x%values(z%r2(i-1)+1:z%r2(i),1) * v(i)
      end do
    case ( M_Column_Sparse )
      do i = 1, z%nCols
        z%values(z%r1(i-1)+1:z%r1(i),1) = x%values(z%r1(i-1)+1:z%r1(i),1) * v(i)
      end do
    case ( M_Full )
      do i = 1, z%nCols
        z%values(:,i) = x%values(:,i) * v(i)
      end do
    end select
d853 1
a853 22

    if ( present(newx) ) then
      z => newx
      call copyBlock ( z, x )
    else
      z => x
    end if
    select case ( z%kind )
    case ( M_Absent )
    case ( M_Banded )
      do i = 1, z%nCols
        z%values(z%r2(i-1)+1:z%r2(i),1) = x%values(z%r2(i-1)+1:z%r2(i),1) * v(i)
      end do
    case ( M_Column_Sparse )
      do i = 1, z%nCols
        z%values(z%r1(i-1)+1:z%r1(i),1) = x%values(z%r1(i-1)+1:z%r1(i),1) * v(i)
      end do
    case ( M_Full )
      do i = 1, z%nCols
        z%values(:,i) = x%values(:,i) * v(i)
      end do
    end select
a1056 1

d1058 2
a1059 38

    n = min(b%nRows,b%nCols)
    if ( n > size(x) ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & 'Array "X" to small in GetDiagonal_0' )
    select case ( b%kind )
    case ( M_Absent )
      x = 0.0_r4
    case ( M_Banded )
      do i = 1, n
        if ( b%r1(i) <= i .and. b%r1(i) + b%r2(i) - b%r2(i-1) > i ) then
          x(i) = b%values(b%r2(i-1)+i-b%r1(i)+1,1)
        else
          x(i) = 0.0_r4
        end if
      end do
    case ( M_Column_Sparse )
      x = 0.0_rm
      do j = b%r1(i-1)+1, b%r1(i)
        if ( b%r2(j) == i ) then
          x(i) = b%values(j,1)
          exit ! j loop
        end if
        if ( b%r2(j) > i ) exit ! j loop
      end do ! j
    case ( M_Full )
      do i = 1, n
        x(i) = b%values(i,i)
      end do
    end select
    if ( present(squareRoot) ) then
      if ( squareRoot ) then
        do i = 1, n
          if ( x(i) < 0.0_r4 ) call MLSMessage ( MLSMSG_Error, moduleName, &
            & "Negative diagonal element in GetDiagonal_0 and SquareRoot is true" )
          x(i) = sqrt(x(i))
        end do
      end if
    end if
a1068 1

d1071 1
a1071 37
    n = min(b%nRows,b%nCols)
    if ( n > size(x) ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & 'Array "X" to small in GetDiagonal_0' )
    select case ( b%kind )
    case ( M_Absent )
      x = 0.0_r8
    case ( M_Banded )
      do i = 1, n
        if ( b%r1(i) <= i .and. b%r1(i) + b%r2(i) - b%r2(i-1) > i ) then
          x(i) = b%values(b%r2(i-1)+i-b%r1(i)+1,1)
        else
          x(i) = 0.0_r8
        end if
      end do
    case ( M_Column_Sparse )
      x = 0.0_r8
      do j = b%r1(i-1)+1, b%r1(i)
        if ( b%r2(j) == i ) then
          x(i) = b%values(j,1)
          exit ! j loop
        end if
        if ( b%r2(j) > i ) exit ! j loop
      end do ! j
    case ( M_Full )
      do i = 1, n
        x(i) = b%values(i,i)
      end do
    end select
    if ( present(squareRoot) ) then
      if ( squareRoot ) then
        do i = 1, n
          if ( x(i) < 0.0_r8 ) call MLSMessage ( MLSMSG_Error, moduleName, &
            & "Negative diagonal element in GetDiagonal_0 and SquareRoot is true" )
          x(i) = sqrt(x(i))
        end do
      end if
    end if
d1111 1
a1111 18
    if ( column < 1 .or. column > b%nCols ) call MLSMessage ( MLSMSG_Error, &
      & moduleName, '"Column" is out-of-range in GetVectorFromColumn_0' )
    if ( size(x) < b%nRows )  call MLSMessage ( MLSMSG_Error, &
      & moduleName, '"X" is too small in GetVectorFromColumn_0' )
    select case ( b%kind )
    case ( M_Absent )
      x = 0.0_r4
    case ( M_Banded )
      x = 0.0_r4
      x(b%r1(column):b%r1(column)+b%r2(column)-b%r2(column-1)-1) = &
        b%values(b%r2(column-1)+1:b%r2(column),column)
    case ( M_Column_Sparse )
      x = 0.0_r4
      x(b%r2(b%r1(column-1)+1:b%r1(column))) = &
        b%values(b%r1(column-1)+1:b%r1(column),column)
    case ( M_Full )
      x(1:b%nRows) = b%values(1:b%nRows,column)
    end select
d1121 1
a1121 18
    if ( column < 1 .or. column > b%nCols ) call MLSMessage ( MLSMSG_Error, &
      & moduleName, '"Column" is out-of-range in GetVectorFromColumn_0' )
    if ( size(x) < b%nRows )  call MLSMessage ( MLSMSG_Error, &
      & moduleName, '"X" is too small in GetVectorFromColumn_0' )
    select case ( b%kind )
    case ( M_Absent )
      x = 0.0_r8
    case ( M_Banded )
      x = 0.0_r8
      x(b%r1(column):b%r1(column)+b%r2(column)-b%r2(column-1)-1) = &
        b%values(b%r2(column-1)+1:b%r2(column),column)
    case ( M_Column_Sparse )
      x = 0.0_r8
      x(b%r2(b%r1(column-1)+1:b%r1(column))) = &
        b%values(b%r1(column-1)+1:b%r1(column),column)
    case ( M_Full )
      x(1:b%nRows) = b%values(1:b%nRows,column)
    end select
d2092 1
a2092 59
    if ( a%nRows /= size(v) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and vector not compatible in MultiplyMatrixVector_0" )
    if ( a%nCols /= size(p) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and result not compatible in MultiplyMatrixVector_0" )
    my_update = .false.
    if ( present(update) ) my_update = update
    my_sub = .false.
    if ( present(subtract) ) my_sub = subtract
    nullify ( my_Mask )
    if ( present(mask) ) my_mask => mask
    s = 1.0_rm
    if ( my_sub ) s = -1.0_rm
    if ( .not. my_update ) p = 0.0_r4
    select case ( a%kind )
    case ( M_Absent )
    case ( M_Banded )
!$OMP PARALLEL DO private ( v1, n, m, av )
      do i = 1, size(p)
        if ( associated(my_mask) ) then
          if ( iand(ichar(my_mask(i)),m_LinAlg) /= 0 ) &
      cycle
        end if
        v1 = a%r2(i-1)             ! starting position in A%VALUES - 1
        n = a%r2(i) - v1           ! how many values
        if ( n <= 0 ) cycle
        m = a%r1(i)                ! starting position in V
        av = dot(n, a%values(v1+1,1), 1, v(m), 1)
!       av = dot_product( a%values(v1+1:v1+n,1), v(m:m+n-1) )
        p(i) = p(i) + s * av
      end do ! i
!$OMP END PARALLEL DO
     case ( M_Column_Sparse )
      do i = 1, size(p)
        if ( associated(my_mask) ) then
          if ( iand(ichar(my_mask(i)),m_LinAlg) /= 0 ) &
      cycle
        end if
        av = 0.0_r8
        do n = a%r1(i-1)+1, a%r1(i)
          av = av + a%values(n,1) * v(a%r2(n))
        end do ! n
        p(i) = p(i) + s * av
      end do ! i
    case ( M_Full )
      if ( associated(my_mask) ) then
!$OMP PARALLEL DO
        do i = 1, size(p)
          if ( iand(ichar(my_mask(i)),m_LinAlg) /= 0 ) &
        cycle
          p(i) = p(i) + s * dot(size(v), a%values(1,i), 1, v(1), 1)
!         p(i) = p(i) + s * dot_product( a%values(:,i), v)
        end do ! i
!$OMP END PARALLEL DO
      else
        call gemv ( 't', size(a%values,1), size(a%values,2), s, a%values, &
          & size(a%values,1), v, 1, 1.0_rm, p, 1 )
!       p = p + s * matmul(transpose(a%values),v)
      end if
    end select
d2116 1
a2116 59
    if ( a%nRows /= size(v) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and vector not compatible in MultiplyMatrixVector_0" )
    if ( a%nCols /= size(p) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and result not compatible in MultiplyMatrixVector_0" )
    my_update = .false.
    if ( present(update) ) my_update = update
    my_sub = .false.
    if ( present(subtract) ) my_sub = subtract
    nullify ( my_Mask )
    if ( present(mask) ) my_mask => mask
    s = 1.0_rm
    if ( my_sub ) s = -1.0_rm
    if ( .not. my_update ) p = 0.0_r8
    select case ( a%kind )
    case ( M_Absent )
    case ( M_Banded )
!$OMP PARALLEL DO private ( v1, n, m, av )
      do i = 1, size(p)
        if ( associated(my_mask) ) then
          if ( iand(ichar(my_mask(i)),m_LinAlg) /= 0 ) &
      cycle
        end if
        v1 = a%r2(i-1)             ! starting position in A%VALUES - 1
        n = a%r2(i) - v1           ! how many values
        if ( n <= 0 ) cycle
        m = a%r1(i)                ! starting position in V
        av = dot(n, a%values(v1+1,1), 1, v(m), 1)
!       av = dot_product( a%values(v1+1:v1+n,1), v(m:m+n-1) )
        p(i) = p(i) + s * av
      end do ! i
!$OMP END PARALLEL DO
     case ( M_Column_Sparse )
      do i = 1, size(p)
        if ( associated(my_mask) ) then
          if ( iand(ichar(my_mask(i)),m_LinAlg) /= 0 ) &
      cycle
        end if
        av = 0.0_r8
        do n = a%r1(i-1)+1, a%r1(i)
          av = av + a%values(n,1) * v(a%r2(n))
        end do ! n
        p(i) = p(i) + s * av
      end do ! i
    case ( M_Full )
      if ( associated(my_mask) ) then
!$OMP PARALLEL DO
        do i = 1, size(p)
          if ( iand(ichar(my_mask(i)),m_LinAlg) /= 0 ) &
        cycle
          p(i) = p(i) + s * dot(size(v), a%values(1,i), 1, v(1), 1)
!         p(i) = p(i) + s * dot_product( a%values(:,i), v)
        end do ! i
!$OMP END PARALLEL DO
      else
        call gemv ( 't', size(a%values,1), size(a%values,2), s, a%values, &
          & size(a%values,1), v, 1, 1.0_rm, p, 1 )
!       p = p + s * matmul(transpose(a%values),v)
      end if
    end select
d2136 1
a2136 63
    if ( b%nCols /= size(v) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and vector not compatible in MultiplyMatrixVectorNoT_0" )
    if ( b%nRows /= size(p) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and result not compatible in MultiplyMatrixVectorNoT_0" )
    my_update = .false.
    if ( present(update) ) my_update = update
    my_diag = .true.
    if ( present(doDiag) ) my_diag = doDiag
    my_sub = .false.
    if ( present(subtract) ) my_sub = subtract
    sign = 1.0_rm
    if ( my_sub ) sign = -1.0_rm
    if ( .not. my_update ) p = 0.0_r4
    select case ( b%kind )
    case ( M_Absent )
    case ( M_Banded )
      do j = 1, size(v)            ! columns
        v1 = b%r2(j-1)             ! (starting position in B%VALUES) - 1
        n = b%r2(j) - v1           ! how many values
        m = b%r1(j)                ! starting row subscript in B%VALUES
        if ( my_diag ) then        ! do the whole matrix
          do i = m, m+n-1          ! rows
            p(i) = p(i) + sign * b%values(v1+i-m+1,1) * v(j)
          end do ! i = 1, n
        else                       ! skip the diagonal
          do i = m, min(m+n-1,j-1) ! rows
            p(i) = p(i) + sign * b%values(v1+i-m+1,1) * v(j)
          end do ! i = m, min(m+n-1,j-1)
          do i = max(m,j+1), m+n-1 ! rows
            p(i) = p(i) + sign * b%values(v1+i-m+1,1) * v(j)
          end do ! i = m, min(m,n-1,j-1)
        end if
      end do ! j
     case ( M_Column_Sparse )
      do j = 1, size(p)            ! columns
        do n = b%r1(j-1)+1, b%r1(j)! rows
          i = b%r2(n)              ! row number
          if ( i/=j .or. my_diag ) &
            & p(i) = p(i) + sign * b%values(n,1) * v(j)
        end do ! n
      end do ! j
    case ( M_Full )
      if ( my_diag ) then          ! do the whole matrix
        call gemv ( 'n', size(b%values,1), size(b%values,2), sign, b%values, &
          & size(b%values,1), v, 1, 1.0_rm, p, 1 )
!       p = p + sign * matmul(b%values,v)
!       do i = 1, size(p)
!         p(i) = p(i) + sign * dot(size(v), b%values(i,1), size(b%values,1), v(1), 1)
!         p(i) = p(i) + sign * dot_product( b%values(i,:), v )
!       end do ! i
      else                         ! skip the diagonal
!$OMP PARALLEL DO
        do i = 1, size(p)
          if ( i > 1 ) p(i) = p(i) + &
            & sign * dot(i-1, b%values(i,1), size(b%values,1), v(1), 1)
!           & sign * dot_product(b%values(i,1:i-1), v(1:i-1))
          if ( i < size(v) ) p(i) = p(i) + &
            & sign * dot(size(v)-i, b%values(i,i+1), size(b%values,1), v(i+1), 1)
!           & sign * dot_product(b%values(i,i+1:), v(i+1:))
        end do ! i
!$OMP END PARALLEL DO
      end if
    end select
d2156 1
a2156 63
    if ( b%nCols /= size(v) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and vector not compatible in MultiplyMatrixVectorNoT_0" )
    if ( b%nRows /= size(p) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and result not compatible in MultiplyMatrixVectorNoT_0" )
    my_update = .false.
    if ( present(update) ) my_update = update
    my_diag = .true.
    if ( present(doDiag) ) my_diag = doDiag
    my_sub = .false.
    if ( present(subtract) ) my_sub = subtract
    sign = 1.0_rm
    if ( my_sub ) sign = -1.0_rm
    if ( .not. my_update ) p = 0.0_r8
    select case ( b%kind )
    case ( M_Absent )
    case ( M_Banded )
      do j = 1, size(v)            ! columns
        v1 = b%r2(j-1)             ! (starting position in B%VALUES) - 1
        n = b%r2(j) - v1           ! how many values
        m = b%r1(j)                ! starting row subscript in B%VALUES
        if ( my_diag ) then        ! do the whole matrix
          do i = m, m+n-1          ! rows
            p(i) = p(i) + sign * b%values(v1+i-m+1,1) * v(j)
          end do ! i = 1, n
        else                       ! skip the diagonal
          do i = m, min(m+n-1,j-1) ! rows
            p(i) = p(i) + sign * b%values(v1+i-m+1,1) * v(j)
          end do ! i = m, min(m+n-1,j-1)
          do i = max(m,j+1), m+n-1 ! rows
            p(i) = p(i) + sign * b%values(v1+i-m+1,1) * v(j)
          end do ! i = m, min(m,n-1,j-1)
        end if
      end do ! j
     case ( M_Column_Sparse )
      do j = 1, size(p)            ! columns
        do n = b%r1(j-1)+1, b%r1(j)! rows
          i = b%r2(n)              ! row number
          if ( i/=j .or. my_diag ) &
            & p(i) = p(i) + sign * b%values(n,1) * v(j)
        end do ! n
      end do ! j
    case ( M_Full )
      if ( my_diag ) then          ! do the whole matrix
        call gemv ( 'n', size(b%values,1), size(b%values,2), sign, b%values, &
          & size(b%values,1), v, 1, 1.0_rm, p, 1 )
!       p = p + sign * matmul(b%values,v)
!       do i = 1, size(p)
!         p(i) = p(i) + sign * dot(size(v), b%values(i,1), size(b%values,1), v(1), 1)
!         p(i) = p(i) + sign * dot_product( b%values(i,:), v )
!       end do ! i
      else                         ! skip the diagonal
!$OMP PARALLEL DO
        do i = 1, size(p)
          if ( i > 1 ) p(i) = p(i) + &
            & sign * dot(i-1, b%values(i,1), size(b%values,1), v(1), 1)
!           & sign * dot_product(b%values(i,1:i-1), v(1:i-1))
          if ( i < size(v) ) p(i) = p(i) + &
            & sign * dot(size(v)-i, b%values(i,i+1), size(b%values,1), v(i+1), 1)
!           & sign * dot_product(b%values(i,i+1:), v(i+1:))
        end do ! i
!$OMP END PARALLEL DO
      end if
    end select
d2248 1
a2248 24
    if ( present(newx) ) then
      z => newx
      call copyBlock ( z, x )
    else
      z => x
    end if
    select case ( z%kind )
    case ( M_Absent )
    case ( M_Banded )
      do i = 1, z%nCols
        z%values(z%r2(i-1)+1:z%r2(i),1) = &
          & v(z%r1(i):z%r1(i)+z%r2(i)-z%r2(i-1)-1) * &
          & x%values(z%r2(i-1)+1:z%r2(i),1)
      end do
    case ( M_Column_Sparse )
      do i = 1, z%nCols
        z%values(z%r1(i-1)+1:z%r1(i),1) = v(z%r2(z%r1(i-1)+1:z%r1(i))) * &
          & x%values(z%r1(i-1)+1:z%r1(i),1)
      end do
    case ( M_Full )
      do i = 1, z%nRows
        z%values(i,:) = v(i) * x%values(i,:)
      end do
    end select
d2264 1
a2264 24
    if ( present(newx) ) then
      z => newx
      call copyBlock ( z, x )
    else
      z => x
    end if
    select case ( z%kind )
    case ( M_Absent )
    case ( M_Banded )
      do i = 1, z%nCols
        z%values(z%r2(i-1)+1:z%r2(i),1) = &
          & v(z%r1(i):z%r1(i)+z%r2(i)-z%r2(i-1)-1) * &
          & x%values(z%r2(i-1)+1:z%r2(i),1)
      end do
    case ( M_Column_Sparse )
      do i = 1, z%nCols
        z%values(z%r1(i-1)+1:z%r1(i),1) = v(z%r2(z%r1(i-1)+1:z%r1(i))) * &
          & x%values(z%r1(i-1)+1:z%r1(i),1)
      end do
    case ( M_Full )
      do i = 1, z%nRows
        z%values(i,:) = v(i) * x%values(i,:)
      end do
    end select
d2295 1
a2295 32
    n = size(x)
    
    my_b => x
    if ( present(b) ) my_b => b
    my_t = .false.
    if ( present(transpose) ) my_t = transpose

    if ( my_t ) then ! solve U^T X = B for X
      d = u(1,1)                                                           
      if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &    
          & "U matrix in SolveCholeskyA_0 is singular" )                   
      x(1) = my_b(1) / d                                                   
      do i = 2, n                                                          
        d = u(i,i)                                                         
        if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &  
            & "U matrix in SolveCholeskyA_0 is singular" )                 
        x(i) = ( my_b(i) - dot(i-1, u(1,i), 1, x(1), 1) ) / d              
!       x(i) = ( my_b(i) - dot_product( u(:i-1,i), x(:i-1)) ) / d          
      end do ! i = 2, n                                                    
    else             ! solve U X = B for X
      d = u(n,n)
      if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyA_0 is singular" )
      x(n) = my_b(n) / d
      do i = n-1, 1, -1
        d = u(i,i)
        if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyA_0 is singular" )
        x(i) = ( my_b(i) - dot(n-i, u(i,i+1), size(u,1), x(i+1), 1) ) / d
!       x(i) = ( my_b(i) - dot_product(u(i,i+1:n), x(i+1:n)) ) / d
      end do ! i = n-1, 1, -1
    end if ! my_t
d2319 1
a2319 32
    n = size(x)
    
    my_b => x
    if ( present(b) ) my_b => b
    my_t = .false.
    if ( present(transpose) ) my_t = transpose

    if ( my_t ) then ! solve U^T X = B for X
      d = u(1,1)                                                           
      if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &    
          & "U matrix in SolveCholeskyA_0 is singular" )                   
      x(1) = my_b(1) / d                                                   
      do i = 2, n                                                          
        d = u(i,i)                                                         
        if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &  
            & "U matrix in SolveCholeskyA_0 is singular" )                 
        x(i) = ( my_b(i) - dot(i-1, u(1,i), 1, x(1), 1) ) / d              
!       x(i) = ( my_b(i) - dot_product( u(:i-1,i), x(:i-1)) ) / d          
      end do ! i = 2, n                                                    
    else             ! solve U X = B for X
      d = u(n,n)
      if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyA_0 is singular" )
      x(n) = my_b(n) / d
      do i = n-1, 1, -1
        d = u(i,i)
        if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyA_0 is singular" )
        x(i) = ( my_b(i) - dot(n-i, u(i,i+1), size(u,1), x(i+1), 1) ) / d
!       x(i) = ( my_b(i) - dot_product(u(i,i+1:n), x(i+1:n)) ) / d
      end do ! i = n-1, 1, -1
    end if ! my_t
d2487 1
a2487 74
    n = u%nRows
    if ( n /= u%nCols ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "U matrix in SolveCholeskyV_0 must be square" )
    my_b => x
    if ( present(b) ) my_b => b
    if ( n /= size(my_b) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "B matrix not compatible with U matrix in SolveCholeskyV_0" )
    my_t = .false.
    if ( present(transpose) ) my_t = transpose

    if ( my_t ) then ! solve U^T X = B for X
      select case ( u%kind )
      case ( M_Absent )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "U matrix in SolveCholeskyV_0 must not be absent" )
      case ( M_Banded )
        do i = 1, n
          if ( u%r1(i) + u%r2(i) - u%r2(i-1) - 1 /= i ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyV_0 is not triangular" )
          d = u%values(u%r2(i),1)
          if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyV_0 is singular" )
          x(i) = ( my_b(i) - dot(u%r2(i)-u%r2(i-1)-1, &
            &      u%values(u%r2(i-1)+1,1), 1, &
            &      my_b(u%r1(i)), 1) ) / d
!         x(i) = ( my_b(i) - dot_product ( &
!           &      u%values(u%r2(i-1)+1:u%r2(i)-1,1), &
!           &      my_b(u%r1(i):i-1)) ) / d
        end do ! i = 1, n
      case ( M_Column_Sparse )
        do i = 1, n
          if ( u%r2(u%r1(i)) /= i ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyV_0 is not triangular" )
          d = u%values(u%r1(i),1)
          if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyV_0 is singular" )
          do h = u%r1(i-1)+1, u%r1(i)-1
            x(i) = my_b(i) - u%values(h,1) * my_b(u%r2(h))
          end do ! h = u%r1(i-1)+1, u%r1(i)-1
          x(i) = x(i) / d
        end do ! i = 1, n
      case ( M_Full )
        do i = 1, n
          d = u%values(i,i)
          if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyV_0 is singular" )
          x(i) = ( my_b(i) - dot(i-1, u%values(1,i), 1, x(1), 1) ) / d
!         x(i) = ( my_b(i) - dot_product( u%values(1:i-1,i), x(1:i-1)) ) / d
        end do ! i = 1, n
      end select
    else             ! solve U X = B for X
      if ( u%kind == M_full ) then
        ud => u%values
      else
        nullify ( ud )
        call allocate_test ( ud, n, n, "UD in SolveCholeskyV_0", ModuleName )
        call densify ( ud, u )
      end if
      d = ud(n,n)
      if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "U matrix in SolveCholeskyV_0 is singular" )
      x(n) = my_b(n) / d
      do i = n-1, 1, -1
        d = ud(i,i)
        if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "U matrix in SolveCholeskyV_0 is singular" )
!       x(i) = ( my_b(i) - dot(n-i, ud(i,i+1), size(ud,1), x(i+1), 1) ) / d
        x(i) = ( my_b(i) - dot_product(ud(i,i+1:n), x(i+1:n)) ) / d
      end do ! i = 1, n
      if ( u%kind /= M_Full ) &
        & call deallocate_test ( ud, "UD in SolveCholeskyV_0", ModuleName )
    end if ! my_t
d2513 1
a2513 74
    n = u%nRows
    if ( n /= u%nCols ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "U matrix in SolveCholeskyV_0 must be square" )
    my_b => x
    if ( present(b) ) my_b => b
    if ( n /= size(my_b) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "B matrix not compatible with U matrix in SolveCholeskyV_0" )
    my_t = .false.
    if ( present(transpose) ) my_t = transpose

    if ( my_t ) then ! solve U^T X = B for X
      select case ( u%kind )
      case ( M_Absent )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "U matrix in SolveCholeskyV_0 must not be absent" )
      case ( M_Banded )
        do i = 1, n
          if ( u%r1(i) + u%r2(i) - u%r2(i-1) - 1 /= i ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyV_0 is not triangular" )
          d = u%values(u%r2(i),1)
          if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyV_0 is singular" )
          x(i) = ( my_b(i) - dot(u%r2(i)-u%r2(i-1)-1, &
            &      u%values(u%r2(i-1)+1,1), 1, &
            &      my_b(u%r1(i)), 1) ) / d
!         x(i) = ( my_b(i) - dot_product ( &
!           &      u%values(u%r2(i-1)+1:u%r2(i)-1,1), &
!           &      my_b(u%r1(i):i-1)) ) / d
        end do ! i = 1, n
      case ( M_Column_Sparse )
        do i = 1, n
          if ( u%r2(u%r1(i)) /= i ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyV_0 is not triangular" )
          d = u%values(u%r1(i),1)
          if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyV_0 is singular" )
          do h = u%r1(i-1)+1, u%r1(i)-1
            x(i) = my_b(i) - u%values(h,1) * my_b(u%r2(h))
          end do ! h = u%r1(i-1)+1, u%r1(i)-1
          x(i) = x(i) / d
        end do ! i = 1, n
      case ( M_Full )
        do i = 1, n
          d = u%values(i,i)
          if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyV_0 is singular" )
          x(i) = ( my_b(i) - dot(i-1, u%values(1,i), 1, x(1), 1) ) / d
!         x(i) = ( my_b(i) - dot_product( u%values(1:i-1,i), x(1:i-1)) ) / d
        end do ! i = 1, n
      end select
    else             ! solve U X = B for X
      if ( u%kind == M_full ) then
        ud => u%values
      else
        nullify ( ud )
        call allocate_test ( ud, n, n, "UD in SolveCholeskyV_0", ModuleName )
        call densify ( ud, u )
      end if
      d = ud(n,n)
      if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "U matrix in SolveCholeskyV_0 is singular" )
      x(n) = my_b(n) / d
      do i = n-1, 1, -1
        d = ud(i,i)
        if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "U matrix in SolveCholeskyV_0 is singular" )
!       x(i) = ( my_b(i) - dot(n-i, ud(i,i+1), size(ud,1), x(i+1), 1) ) / d
        x(i) = ( my_b(i) - dot_product(ud(i,i+1:n), x(i+1:n)) ) / d
      end do ! i = 1, n
      if ( u%kind /= M_Full ) &
        & call deallocate_test ( ud, "UD in SolveCholeskyV_0", ModuleName )
    end if ! my_t
d2545 1
a2545 73
    if ( sq_eps < 0.0_rm ) sq_eps = sqrt(epsilon(1.0_rm))
    do j = 1, size(z,2)
    ! zt(j) = maxval(abs(z(:,j)))
    ! zt(j) = max(sq_eps*zt(j), sqrt(tiny(1.0_rm)))
    ! nnzc(j) = count(abs(z(:,j)) < zt(j))
      zt(j) = 0.0_rm
!     do i1 = 1, size(z,1)
!       zt(j) = max(zt(j),abs(z(i1,j)))
!     end do ! i1
!     zt(j) = max(sq_eps*zt(j), sqrt(tiny(1.0_rm)))
      nnzc(j) = 0
      do i1 = 1, size(z,1)
        if ( abs(z(i1,j)) > zt(j) ) nnzc(j) = nnzc(j) + 1
      end do ! i1
    end do ! j
    nnz = sum(nnzc)
    if ( nnz == 0 ) then ! Empty
      call createBlock ( b, size(z,1), size(z,2), M_Absent )
    else if ( nnz <= int(sparsity * size(z)) ) then ! sparse
      kind = M_Banded
      do j = 1, size(z,2)
        do i1 = 1, size(z,1)       ! Find row number of first nonzero
          if ( abs(z(i1,j)) > zt(j) ) exit
        end do
        r1(j) = i1
        do i2 = size(z,1), 1, -1   ! Find row number of last nonzero
          if ( abs(z(i2,j)) > zt(j) ) exit
        end do
        if ( int(col_sparsity*(i2 - i1)) > nnzc(j) ) then
          kind = M_Column_Sparse
          do i1 = 1, j-1 ! I1 is a column number in this case
            nnzc(i1) = count(abs(z(:,i1)) <= zt(i1))
          end do ! i1
          exit
        end if
        nnzc(j) = max(i2 - i1 + 1,0)
      end do ! j
      if ( kind == M_Banded ) then
        call createBlock ( b, size(z,1), size(z,2), M_Banded, sum(nnzc) )
        b%r1 = r1        ! Row number of first nonzero in the column
        do j = 1, size(z,2)
          b%r2(j) = nnzc(j) + b%r2(j-1) ! Subscript of last nonzero in the
                                        ! column
          b%values(b%r2(j-1)+1:b%r2(j),1) = &
            & z(b%r1(j):b%r1(j)+b%r2(j)-b%r2(j-1)-1,j)
        end do
      else
        call createBlock ( b, size(z,1), size(z,2), M_Column_Sparse, nnz )
        i1 = 0
        do j = 1, size(z,2)
          do i2 = 1, size(z,1)
            if ( abs(z(i2,j)) > zt(j) ) then
              i1 = i1 + 1
              b%values(i1,1) = z(i2,j)
              b%r2(i1) = i2
            end if
            b%r1(j) = i1
          end do ! i2
        end do ! j
      end if
    else ! full
      call createBlock ( b, size(z,1), size(z,2), M_Full )
      b%values = z
    end if
    if ( present(why) ) then
      if ( present(callingModule) ) then
        call deallocate_test ( z, why, callingModule )
      else
        call deallocate_test ( z, why, "No module specified" )
      end if
    else if ( present(callingModule) ) then
      call deallocate_test ( z, "No variable specified", callingModule )
    end if
d2577 1
a2577 73
    if ( sq_eps < 0.0_rm ) sq_eps = sqrt(epsilon(1.0_rm))
    do j = 1, size(z,2)
    ! zt(j) = maxval(abs(z(:,j)))
    ! zt(j) = max(sq_eps*zt(j), sqrt(tiny(1.0_rm)))
    ! nnzc(j) = count(abs(z(:,j)) < zt(j))
      zt(j) = 0.0_rm
!     do i1 = 1, size(z,1)
!       zt(j) = max(zt(j),abs(z(i1,j)))
!     end do ! i1
!     zt(j) = max(sq_eps*zt(j), sqrt(tiny(1.0_rm)))
      nnzc(j) = 0
      do i1 = 1, size(z,1)
        if ( abs(z(i1,j)) > zt(j) ) nnzc(j) = nnzc(j) + 1
      end do ! i1
    end do ! j
    nnz = sum(nnzc)
    if ( nnz == 0 ) then ! Empty
      call createBlock ( b, size(z,1), size(z,2), M_Absent )
    else if ( nnz <= int(sparsity * size(z)) ) then ! sparse
      kind = M_Banded
      do j = 1, size(z,2)
        do i1 = 1, size(z,1)       ! Find row number of first nonzero
          if ( abs(z(i1,j)) > zt(j) ) exit
        end do
        r1(j) = i1
        do i2 = size(z,1), 1, -1   ! Find row number of last nonzero
          if ( abs(z(i2,j)) > zt(j) ) exit
        end do
        if ( int(col_sparsity*(i2 - i1)) > nnzc(j) ) then
          kind = M_Column_Sparse
          do i1 = 1, j-1 ! I1 is a column number in this case
            nnzc(i1) = count(abs(z(:,i1)) <= zt(i1))
          end do ! i1
          exit
        end if
        nnzc(j) = max(i2 - i1 + 1,0)
      end do ! j
      if ( kind == M_Banded ) then
        call createBlock ( b, size(z,1), size(z,2), M_Banded, sum(nnzc) )
        b%r1 = r1        ! Row number of first nonzero in the column
        do j = 1, size(z,2)
          b%r2(j) = nnzc(j) + b%r2(j-1) ! Subscript of last nonzero in the
                                        ! column
          b%values(b%r2(j-1)+1:b%r2(j),1) = &
            & z(b%r1(j):b%r1(j)+b%r2(j)-b%r2(j-1)-1,j)
        end do
      else
        call createBlock ( b, size(z,1), size(z,2), M_Column_Sparse, nnz )
        i1 = 0
        do j = 1, size(z,2)
          do i2 = 1, size(z,1)
            if ( abs(z(i2,j)) > zt(j) ) then
              i1 = i1 + 1
              b%values(i1,1) = z(i2,j)
              b%r2(i1) = i2
            end if
            b%r1(j) = i1
          end do ! i2
        end do ! j
      end if
    else ! full
      call createBlock ( b, size(z,1), size(z,2), M_Full )
      b%values = z
    end if
    if ( present(why) ) then
      if ( present(callingModule) ) then
        call deallocate_test ( z, why, callingModule )
      else
        call deallocate_test ( z, why, "No module specified" )
      end if
    else if ( present(callingModule) ) then
      call deallocate_test ( z, "No variable specified", callingModule )
    end if
d2644 1
a2644 47
    nullify ( t )
    n = min(a%nCols,a%nRows)
    select case ( a%kind )
    case ( m_absent )
      nCols = a%nCols ! because createBlock destroys A before re-creating it
      nRows = a%nRows
      call createBlock ( a, nRows, nCols, m_banded, n )
      do i = 1, n
        a%r1(i) = i
        a%r2(i) = i
        a%values(i,1) = lambda
      end do
    case ( m_banded )
      do i = 1, n
        if ( i < a%r1(i) .or. i > a%r1(i) + a%r2(i) - a%r2(i-1) - 1 ) then
          ! No diagonal element.  Make room for one by densify-update-sparsify
          call allocate_test ( t, a%nRows, a%nCols, "T in UpdateDiagonal_0", &
            & ModuleName )
          call densify ( t, a )
          call updateDenseDiagonal ( t, lambda, i )
          call sparsify ( t, a, "T in UpdateDiagonal_0", ModuleName ) ! A := T
          call deallocate_test ( t, "T in UpdateDiagonal_0", ModuleName )
          return
        end if
        a%values(a%r2(i-1)+i-a%r1(i)+1,1) = &
          & a%values(a%r2(i-1)+i-a%r1(i)+1,1) + lambda
      end do
    case ( m_column_sparse )
      do i = 1, n
        do j = a%r1(i-1)+1, a%r1(i) ! hunt for the diagonal subscript
          if ( a%r2(j) == i ) then
            a%values(j,1) = a%values(j,1) + lambda
          else if ( a%r2(j) > i ) then
            ! No diagonal element.  Make room for one by densify-update-sparsify
            call allocate_test ( t, a%nRows, a%nCols, "T in UpdateDiagonal_0", &
              & ModuleName )
            call densify ( t, a )
            call updateDenseDiagonal ( t, lambda, i )
            call sparsify ( t, a, "T in UpdateDiagonal_0", ModuleName ) ! A := T
            call deallocate_test ( t, "T in UpdateDiagonal_0", ModuleName )
            return
          end if
        end do
      end do
    case ( m_full )
      call updateDenseDiagonal ( a%values, lambda, 1 )
    end select
d2656 1
d2670 1
a2670 47
    nullify ( t )
    n = min(a%nCols,a%nRows)
    select case ( a%kind )
    case ( m_absent )
      nCols = a%nCols ! because createBlock destroys A before re-creating it
      nRows = a%nRows
      call createBlock ( a, nRows, nCols, m_banded, n )
      do i = 1, n
        a%r1(i) = i
        a%r2(i) = i
        a%values(i,1) = lambda
      end do
    case ( m_banded )
      do i = 1, n
        if ( i < a%r1(i) .or. i > a%r1(i) + a%r2(i) - a%r2(i-1) - 1 ) then
          ! No diagonal element.  Make room for one by densify-update-sparsify
          call allocate_test ( t, a%nRows, a%nCols, "T in UpdateDiagonal_0", &
            & ModuleName )
          call densify ( t, a )
          call updateDenseDiagonal ( t, lambda, i )
          call sparsify ( t, a, "T in UpdateDiagonal_0", ModuleName ) ! A := T
          call deallocate_test ( t, "T in UpdateDiagonal_0", ModuleName )
          return
        end if
        a%values(a%r2(i-1)+i-a%r1(i)+1,1) = &
          & a%values(a%r2(i-1)+i-a%r1(i)+1,1) + lambda
      end do
    case ( m_column_sparse )
      do i = 1, n
        do j = a%r1(i-1)+1, a%r1(i) ! hunt for the diagonal subscript
          if ( a%r2(j) == i ) then
            a%values(j,1) = a%values(j,1) + lambda
          else if ( a%r2(j) > i ) then
            ! No diagonal element.  Make room for one by densify-update-sparsify
            call allocate_test ( t, a%nRows, a%nCols, "T in UpdateDiagonal_0", &
              & ModuleName )
            call densify ( t, a )
            call updateDenseDiagonal ( t, lambda, i )
            call sparsify ( t, a, "T in UpdateDiagonal_0", ModuleName ) ! A := T
            call deallocate_test ( t, "T in UpdateDiagonal_0", ModuleName )
            return
          end if
        end do
      end do
    case ( m_full )
      call updateDenseDiagonal ( a%values, lambda, 1 )
    end select
d2682 1
d2705 1
a2705 80
    nullify ( t )
    s = 1.0_rm
    if ( present(subtract) ) then
      if ( subtract ) s = -1.0_rm
    end if
    myInvert = .false.
    if ( present(invert) ) myInvert = invert
    n = min(a%nCols,a%nRows)
    m = max(a%nCols,a%nRows) / n
    select case ( a%kind )
    case ( m_absent )
      nCols = a%nCols ! because the createBlock destroys A before re-creating it
      nRows = a%nRows
      call createBlock ( a, nRows, nCols, m_banded, m*n )
      do i = 1, n                       ! Loop over shorter side
        j = 1 + m*(i-1)                 ! Index into longer side
        a%r1(i) = j
        a%r2(i) = j + m - 1
        if ( myInvert ) then
          if ( abs(x(i)) <= tiny(0.0_r8) ) call MLSMessage ( &
            & MLSMSG_Error, moduleName, &
            & "Cannot update with inverse of zero in UpdateDiagonalVec_0" )
          ! Don't misinterpret the use of r1 and r2 here, it does make sense
          ! see their assignment above.
          a%values(a%r1(i):a%r2(i),1) = s / x(a%r1(i):a%r2(i))
        else
          a%values(a%r1(i):a%r2(i),1) = s * x(a%r1(i):a%r2(i))
        end if
      end do
    case ( m_banded )
      do i = 1, n
        if ( i < a%r1(i) .or. i > a%r1(i) + a%r2(i) - a%r2(i-1) - 1 ) then
          ! No diagonal element.  Make room for one by densify-update-sparsify
          call allocate_test ( t, a%nRows, a%nCols, "T in UpdateDiagonal_0", &
            & ModuleName )
          call densify ( t, a )
          call updateDenseDiagonal ( t, x, s, i )
          call sparsify ( t, a, "T in UpdateDiagonal_0", ModuleName ) ! A := T
          call deallocate_test ( t, "T in UpdateDiagonal_0", ModuleName )
          return
        end if
        if ( myInvert ) then
          if ( abs(x(i)) <= tiny(0.0_r8) ) call MLSMessage ( &
            & MLSMSG_Error, moduleName, &
            & "Cannot update with inverse of zero in UpdateDiagonalVec_0" )
          v = s / x(i)
        else
          v = s * x(i)
        end if
        a%values(a%r2(i-1)+i-a%r1(i)+1,1) = &
          & a%values(a%r2(i-1)+i-a%r1(i)+1,1) + v
      end do
    case ( m_column_sparse )
      do i = 1, n
        do j = a%r1(i-1)+1, a%r1(i) ! hunt for the diagonal subscript
          if ( a%r2(j) == i ) then
            if ( myInvert ) then
              if ( abs(x(i)) <= tiny(0.0_r8) ) call MLSMessage ( &
                & MLSMSG_Error, moduleName, &
                & "Cannot update with inverse of zero in UpdateDiagonalVec_0" )
              v = s / x(i)
            else
              v = s * x(i)
            end if
            a%values(j,1) = a%values(j,1) + v
          else if ( a%r2(j) > i ) then
            ! No diagonal element.  Make room for one by densify-update-sparsify
            call allocate_test ( t, a%nRows, a%nCols, "T in UpdateDiagonal_0", &
              & ModuleName )
            call densify ( t, a )
            call updateDenseDiagonal ( t, x, s, i )
            call sparsify ( t, a, "T in UpdateDiagonal_0", moduleName ) ! A := T
            call deallocate_test ( t, "T in UpdateDiagonal_0", moduleName )
            return
          end if
        end do
      end do
    case ( m_full )
      call updateDenseDiagonal ( a%values, x, s, 1 )
    end select
d2726 1
d2749 1
a2749 80
    nullify ( t )
    s = 1.0_rm
    if ( present(subtract) ) then
      if ( subtract ) s = -1.0_rm
    end if
    myInvert = .false.
    if ( present(invert) ) myInvert = invert
    n = min(a%nCols,a%nRows)
    m = max(a%nCols,a%nRows) / n
    select case ( a%kind )
    case ( m_absent )
      nCols = a%nCols ! because the createBlock destroys A before re-creating it
      nRows = a%nRows
      call createBlock ( a, nRows, nCols, m_banded, m*n )
      do i = 1, n                       ! Loop over shorter side
        j = 1 + m*(i-1)                 ! Index into longer side
        a%r1(i) = j
        a%r2(i) = j + m - 1
        if ( myInvert ) then
          if ( abs(x(i)) <= tiny(0.0_r4) ) call MLSMessage ( &
            & MLSMSG_Error, moduleName, &
            & "Cannot update with inverse of zero in UpdateDiagonalVec_0" )
          ! Don't misinterpret the use of r1 and r2 here, it does make sense
          ! see their assignment above.
          a%values(a%r1(i):a%r2(i),1) = s / x(a%r1(i):a%r2(i))
        else
          a%values(a%r1(i):a%r2(i),1) = s * x(a%r1(i):a%r2(i))
        end if
      end do
    case ( m_banded )
      do i = 1, n
        if ( i < a%r1(i) .or. i > a%r1(i) + a%r2(i) - a%r2(i-1) - 1 ) then
          ! No diagonal element.  Make room for one by densify-update-sparsify
          call allocate_test ( t, a%nRows, a%nCols, "T in UpdateDiagonal_0", &
            & ModuleName )
          call densify ( t, a )
          call updateDenseDiagonal ( t, x, s, i )
          call sparsify ( t, a, "T in UpdateDiagonal_0", ModuleName ) ! A := T
          call deallocate_test ( t, "T in UpdateDiagonal_0", ModuleName )
          return
        end if
        if ( myInvert ) then
          if ( abs(x(i)) <= tiny(0.0_r4) ) call MLSMessage ( &
            & MLSMSG_Error, moduleName, &
            & "Cannot update with inverse of zero in UpdateDiagonalVec_0" )
          v = s / x(i)
        else
          v = s * x(i)
        end if
        a%values(a%r2(i-1)+i-a%r1(i)+1,1) = &
          & a%values(a%r2(i-1)+i-a%r1(i)+1,1) + v
      end do
    case ( m_column_sparse )
      do i = 1, n
        do j = a%r1(i-1)+1, a%r1(i) ! hunt for the diagonal subscript
          if ( a%r2(j) == i ) then
            if ( myInvert ) then
              if ( abs(x(i)) <= tiny(0.0_r4) ) call MLSMessage ( &
                & MLSMSG_Error, moduleName, &
                & "Cannot update with inverse of zero in UpdateDiagonalVec_0" )
              v = s / x(i)
            else
              v = s * x(i)
            end if
            a%values(j,1) = a%values(j,1) + v
          else if ( a%r2(j) > i ) then
            ! No diagonal element.  Make room for one by densify-update-sparsify
            call allocate_test ( t, a%nRows, a%nCols, "T in UpdateDiagonal_0", &
              & ModuleName )
            call densify ( t, a )
            call updateDenseDiagonal ( t, x, s, i )
            call sparsify ( t, a, "T in UpdateDiagonal_0", moduleName ) ! A := T
            call deallocate_test ( t, "T in UpdateDiagonal_0", moduleName )
            return
          end if
        end do
      end do
    case ( m_full )
      call updateDenseDiagonal ( a%values, x, s, 1 )
    end select
d2760 1
a2760 1
          if ( abs(x(i)) <= tiny(0.0_r4) ) call MLSMessage ( &
d2917 4
@


2.85
log
@Added idents to survive zealous Lahey optimizer
@
text
@d41 1
d142 4
d187 1
a187 1
       "$Id: MatrixModule_0.f90,v 2.84 2002/09/23 23:18:59 vsnyder Exp $"
d263 1
d436 2
d2560 1
d2580 14
d3952 3
@


2.84
log
@Comment out declarations used by commented-out broken code in Add_Matrix_Blocks
@
text
@d182 1
a182 1
       "$Id: MatrixModule_0.f90,v 2.83 2002/09/13 18:08:12 pwagner Exp $"
d186 1
d3923 3
d3929 3
@


2.83
log
@May change matrix precision rm from r8
@
text
@d182 1
a182 1
       "$Id: MatrixModule_0.f90,v 2.82 2002/09/11 17:43:38 pwagner Exp $"
d248 2
a249 1
    integer :: I, J, K, L, N
d3925 3
@


2.82
log
@Began changes needed to conform with matrix%values type move to rm from r8
@
text
@d18 1
a18 1
  use MLSCommon, only: RM
d27 1
a27 1
  public :: ColumnScale_0, Col_L1, CopyBlock, CreateBlock, CreateBlock_0
d29 2
a30 2
  public :: GetDiagonal, GetDiagonal_0, GetMatrixElement, GetMatrixElement_0
  public :: GetVectorFromColumn, GetVectorFromColumn_0
d39 2
a40 2
  public :: MultiplyMatrixVector, MultiplyMatrixVector_0
  public :: MultiplyMatrixVectorNoT, MultiplyMatrixVectorNoT_0
d42 3
a44 4
  public :: RowScale_0, ScaleBlock, SolveCholesky, SolveCholeskyM_0
  public :: SolveCholeskyV_0, Sparsify, Spill, Spill_0, SubBlockLength
  public :: TransposeMatrix, UpdateDiagonal, UpdateDiagonal_0
  public :: UpdateDiagonalVec_0
d65 1
a65 1
    module procedure ColumnScale_0
d81 1
a81 1
    module procedure GetDiagonal_0
d89 1
a89 1
    module procedure GetVectorFromColumn_0
d113 2
a114 1
    module procedure MultiplyMatrix_XTY_0, MultiplyMatrixVector_0
d118 1
a118 1
    module procedure MultiplyMatrixVector_0
d122 1
a122 1
    module procedure MultiplyMatrixVectorNoT_0
d137 4
d146 2
a147 1
    module procedure NewMultiplyMatrix_XTY_0, NewMultiplyMatrixVector_0
d155 1
a155 1
    module procedure RowScale_0
d159 6
a164 1
    module procedure SolveCholeskyM_0, SolveCholeskyV_0, SolveCholeskyA_0
d176 2
a177 1
    module procedure UpdateDiagonal_0, UpdateDiagonalVec_0
d182 1
a182 1
       "$Id: MatrixModule_0.f90,v 2.81 2002/09/06 15:45:54 mjf Exp $"
d239 1
a239 1
    real(rm), intent(in), optional :: SCALE
d249 1
a249 1
    real(rm) :: S                            ! My copy of Scale
d816 38
a853 2
  ! -------------------------------------------------  ColumnScale_0  -----
  subroutine ColumnScale_0 ( X, V, NEWX ) ! Z = X V where V is a diagonal
d857 1
a857 1
    real(rm), intent(in), dimension(:) :: V
d886 1
a886 1
  end subroutine ColumnScale_0
d1082 2
a1083 2
  ! ----------------------------------------------  GetDiagonal_0  -----
  subroutine GetDiagonal_0 ( B, X, SquareRoot )
d1087 1
a1087 1
    real(rm), dimension(:), intent(out) :: X
d1097 10
d1108 39
d1152 1
a1152 1
          x(i) = 0.0_rm
d1156 1
a1156 1
      x = 0.0_rm
d1172 1
a1172 1
          if ( x(i) < 0.0_rm ) call MLSMessage ( MLSMSG_Error, moduleName, &
d1178 1
a1178 1
  end subroutine GetDiagonal_0
d1210 29
a1238 2
  ! --------------------------------------  GetVectorFromColumn_0  -----
  subroutine GetVectorFromColumn_0 ( B, Column, X )
d1242 1
a1242 1
    real(rm), dimension(:), intent(out) :: X
d1250 1
a1250 1
      x = 0.0_rm
d1252 1
a1252 1
      x = 0.0_rm
d1256 1
a1256 1
      x = 0.0_rm
d1262 1
a1262 1
  end subroutine GetVectorFromColumn_0
d1434 1
a1434 1
      maxAbsVal_0 = 0.0
d2211 84
a2294 2
  ! -------------------------------------  MultiplyMatrixVector_0  -----
  subroutine MultiplyMatrixVector_0 ( A, V, P, UPDATE, SUBTRACT, MASK )
d2301 2
a2302 2
    real(rm), dimension(:), intent(in) :: V
    real(rm), dimension(:), intent(inout) :: P
d2307 1
a2307 1
    real(rm) :: AV                 ! Product of a column of A and the vector V
d2326 1
a2326 1
    if ( .not. my_update ) p = 0.0_rm
d2351 1
a2351 1
        av = 0.0_rm
d2373 83
a2455 1
  end subroutine MultiplyMatrixVector_0
d2457 2
a2458 2
  ! ----------------------------------  MultiplyMatrixVectorNoT_0  -----
  subroutine MultiplyMatrixVectorNoT_0 ( B, V, P, UPDATE, DoDiag, SUBTRACT )
d2465 2
a2466 2
    real(rm), dimension(:), intent(in) :: V
    real(rm), dimension(:), intent(inout) :: P
d2486 1
a2486 1
    if ( .not. my_update ) p = 0.0_rm
d2537 1
a2537 1
  end subroutine MultiplyMatrixVectorNoT_0
d2553 10
a2562 2
  ! -----------------------------------  NewMultiplyMatrixVector_0  ----
  function NewMultiplyMatrixVector_0 ( B, V ) result ( P ) ! P = B^T V
d2564 2
a2565 2
    real(rm), dimension(:), intent(in) :: V
    real(rm), dimension(size(v)) :: P
d2567 1
a2567 1
  end function NewMultiplyMatrixVector_0
d2600 2
a2601 2
  ! -------------------------------------------------  RowScale_0  -----
  subroutine RowScale_0 ( V, X, NEWX ) ! Z = V X where V is a diagonal
d2604 1
a2604 1
    real(rm), intent(in), dimension(:) :: V
d2637 40
a2676 1
  end subroutine RowScale_0
d2681 1
a2681 1
    real(rm), intent(in) :: A
d2685 57
a2741 2
  ! -------------------------------------------  SolveCholeskyA_0  -----  
  subroutine SolveCholeskyA_0 ( U, X, B, TRANSPOSE )
d2748 2
a2749 2
    real (rm), dimension(:), intent(inout), target :: X
    real (rm), dimension(:), intent(in), target, optional :: B
d2755 1
a2755 1
    real (rm), dimension(:), pointer :: MY_B   ! B if B is present, else X
d2793 1
a2793 1
  end subroutine SolveCholeskyA_0
d2937 2
a2938 2
  ! -------------------------------------------  SolveCholeskyV_0  -----
  subroutine SolveCholeskyV_0 ( U, X, B, TRANSPOSE )
d2947 2
a2948 2
    real(rm), dimension(:), intent(inout), target :: X
    real(rm), dimension(:), intent(in), target, optional :: B
d2954 1
a2954 1
    real(rm), dimension(:), pointer :: MY_B   ! B if B is present, else X
d3034 1
a3034 1
  end subroutine SolveCholeskyV_0
d3036 101
a3136 2
  ! ---------------------------------------------------  Sparsify  -----
  subroutine Sparsify ( Z, B, Why, CallingModule )
d3139 1
a3139 1
    real(rm), pointer :: Z(:,:)              ! Full array of values
d3160 1
a3160 1
    real(rm) :: ZT(size(z,2))      ! Maximum value in a column of Z, then
d3237 105
a3341 1
  end subroutine Sparsify
d3396 73
a3468 2
  ! -------------------------------------------  UpdateDiagonal_0  -----
  subroutine UpdateDiagonal_0 ( A, LAMBDA )
d3471 1
a3471 1
    real(rm), intent(in) :: LAMBDA
d3529 1
a3529 1
      real(rm), intent(in) :: LAMBDA
d3536 123
a3658 1
  end subroutine UpdateDiagonal_0
d3660 2
a3661 2
  ! ----------------------------------------  UpdateDiagonalVec_0  -----
  subroutine UpdateDiagonalVec_0 ( A, X, SUBTRACT, INVERT )
d3666 1
a3666 1
    real(rm), intent(in) :: X(:)
d3699 1
a3699 1
          if ( abs(x(i)) <= tiny(0.0_rm) ) call MLSMessage ( &
d3722 1
a3722 1
          if ( abs(x(i)) <= tiny(0.0_rm) ) call MLSMessage ( &
d3737 1
a3737 1
              if ( abs(x(i)) <= tiny(0.0_rm) ) call MLSMessage ( &
d3764 1
a3764 1
      real(rm), intent(in) :: X(:)      ! Vector update diagonal
d3770 1
a3770 1
          if ( abs(x(i)) <= tiny(0.0_rm) ) call MLSMessage ( &
d3780 1
a3780 1
  end subroutine UpdateDiagonalVec_0
d3924 3
@


2.81
log
@In ReflectMatrix_0 need to Densify sparse matrices to do the
reflection.
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 1
a18 1
  use MLSCommon, only: R8
d171 1
a171 1
       "$Id: MatrixModule_0.f90,v 2.80 2002/09/02 22:56:45 livesey Exp $"
d206 1
a206 1
    real(r8), pointer, dimension(:,:) :: VALUES => NULL()   ! Values of the
d228 1
a228 1
    real(r8), intent(in), optional :: SCALE
d238 1
a238 1
    real(r8) :: S                            ! My copy of Scale
d242 1
a242 1
    real(r8), dimension(:,:), pointer :: XD, YD ! For testing
d297 1
a297 1
!         zb%values = 0.0_r8 ! ??? Improve this by only filling
d620 2
a621 2
    real(r8) :: D             ! Diagonal(I,I) element of Z
    real(r8) :: G             ! X(I,J) - dot_product(X(1:i-1,i),X(1:i-1,j))
d628 2
a629 2
    real(r8), save :: TOL = -1.0_r8
    real(r8), pointer, dimension(:,:) :: XIN  ! A pointer to the input,
d633 1
a633 1
    real(r8), pointer, dimension(:,:) :: ZT   ! A local full result that is
d635 1
a635 1
    real(r8), pointer, dimension(:,:) :: TST1, TST2 ! When using checkblock
d638 1
a638 1
    if ( tol < 0.0_r8 ) tol = sqrt(tiny(0.0_r8))
d667 1
a667 1
        zt(i,1:i-1) = 0.0_r8  ! Clear left from the diagonal (helps Sparsify!)
d695 1
a695 1
          if ( abs(zt(i,j)) >= tiny(0.0_r8) ) r1(j) = min( r1(j), i )
d762 1
a762 1
            & x%values(x%r2(j-1) + i - x%r1(j) + 1, 1) = 0.0_r8
d769 1
a769 1
            & x%values(j,1) = 0.0_r8
d776 1
a776 1
          & x%values(i,:) = 0.0_r8
d810 1
a810 1
    real(r8), intent(in), dimension(:) :: V
d842 1
a842 1
  real(r8) function Col_L1 ( X, N )
d847 1
a847 1
    col_l1 = 0.0_r8
d956 2
a957 2
    real(r8), intent(inout) :: ZT(:,:) ! Inout in case it's associated with XIN
    real(r8), intent(inout) :: XIN(:,:) ! Inout in case it's associated with Z
d960 2
a961 2
    real(r8) :: D
    real(r8), save :: TOL = -1.0_r8
d965 1
a965 1
    if ( tol < 0.0_r8 ) tol = sqrt(tiny(0.0_r8))
d967 1
a967 1
      zt(i+1:nc,i) = 0.0_r8 ! Clear below the diagonal (helps Sparsify!)
d994 1
a994 1
    real(r8), intent(out) :: Z(:,:)          ! Full matrix to produce
d1004 1
a1004 1
      z = 0.0_r8
d1006 1
a1006 1
      z = 0.0_r8
d1012 1
a1012 1
      z = 0.0_r8
d1040 1
a1040 1
    real(r8), dimension(:), intent(out) :: X
d1050 1
a1050 1
      x = 0.0_r8
d1056 1
a1056 1
          x(i) = 0.0_r8
d1060 1
a1060 1
      x = 0.0_r8
d1076 1
a1076 1
          if ( x(i) < 0.0_r8 ) call MLSMessage ( MLSMSG_Error, moduleName, &
d1085 1
a1085 1
  real(r8) function GetMatrixElement_0 ( Matrix, Row, Col )
d1092 1
a1092 1
      getMatrixElement_0 = 0.0_r8
d1096 1
a1096 1
        getMatrixElement_0 = 0.0_r8
d1108 1
a1108 1
      getMatrixElement_0 = 0.0_r8
d1119 1
a1119 1
    real(r8), dimension(:), intent(out) :: X
d1127 1
a1127 1
      x = 0.0_r8
d1129 1
a1129 1
      x = 0.0_r8
d1133 1
a1133 1
      x = 0.0_r8
d1155 1
a1155 1
    real(r8), pointer, dimension(:,:) :: myUI
d1221 2
a1222 2
    real(r8), intent(inout) :: U(:,:)   ! inout in case U and UI have the
    real(r8), intent(inout) :: UI(:,:)  ! same associated actual argument
d1254 1
a1254 1
      if ( abs(U(j,j)) <= tiny(0.0_r8) ) then
d1265 1
a1265 1
      UI(j,j) = 1.0_r8 / U(j,j)
d1279 1
a1279 1
          ui(j+1:,j) = 0.0_r8
d1300 1
a1300 1
        ui(i,i+1:) = 0.0_r8
d1307 1
a1307 1
  real(r8) function MaxAbsVal_0 ( B )
d1322 1
a1322 1
  real (r8), dimension(:,:),intent(inout) :: A
d1325 3
a1327 3
! real (r8), dimension(:,:), pointer :: U
! real (r8), dimension(:), pointer :: b
! real (r8), dimension(:), pointer :: x
d1355 2
a1356 2
!   b = 0.0_r8
!   b(i) = 1.0_r8
d1371 1
a1371 1
  real(r8) function MinDiag_0 ( B )
d1378 1
a1378 1
      minDiag_0 = 0.0_r8
d1380 1
a1380 1
      minDiag_0 = huge(0.0_r8)
d1386 1
a1386 1
      minDiag_0 = huge(0.0_r8)
d1414 2
a1415 2
    real(r8) :: Alpha                   ! -1 or 1 depending on subtract
    real(r8) :: Beta                    ! 0 or 1, depending on Update
d1417 1
a1417 1
    real(r8), pointer, dimension(:,:) :: X, Y, Z  ! Dense matrices
d1419 1
a1419 1
    alpha = 1.0_r8
d1421 1
a1421 1
      if ( subtract ) alpha = -1.0_r8
d1424 1
a1424 1
    beta = 0.0_r8
d1426 1
a1426 1
      if ( update ) beta = 1.0_r8
d1430 1
a1430 1
      if ( abs(beta) < 0.5_r8 ) call createBlock ( zb, xb%nRows, yb%nCols, M_Absent )
d1441 2
a1442 2
    if ( abs(beta) < 0.5_r8 ) then
      z = 0.0_r8
d1492 2
a1493 2
    real(r8) :: Alpha                   ! -1 or 1 depending on subtract
    real(r8) :: Beta                    ! 0 or 1, depending on Update
d1495 1
a1495 1
    real(r8), pointer, dimension(:,:) :: X, Y, Z  ! Dense matrices
d1498 1
a1498 1
    alpha = 1.0_r8
d1500 1
a1500 1
      if ( subtract ) alpha = -1.0_r8
d1503 1
a1503 1
    beta = 0.0_r8
d1505 1
a1505 1
      if ( update ) beta = 1.0_r8
d1509 1
a1509 1
      if ( abs(beta) < 0.5_r8 ) call createBlock ( zb, xb%nRows, yb%nRows, M_Absent )
d1520 2
a1521 2
    if ( abs(beta) < 0.5_r8 ) then
      z = 0.0_r8
d1592 1
a1592 1
    real(r8) :: S                            ! Sign, subtract => -1 else +1
d1595 2
a1596 2
    real(r8) :: XY                           ! Product of columns of X and Y
    real(r8), pointer, dimension(:,:) :: Z   ! Temp for sparse * sparse
d1598 1
a1598 1
    real(r8), pointer, dimension(:,:) :: XDNS, YDNS, ZDNS, ZDNS2 ! For checking
d1609 2
a1610 2
    s = 1.0_r8
    if ( my_sub ) s = -1.0_r8
d1646 1
a1646 1
        zDns = 0.0_r8
d1665 1
a1665 1
          z = 0.0_r8
d1716 1
a1716 1
          z = 0.0_r8
d1764 1
a1764 1
        if ( .not. my_upd ) zb%values = 0.0_r8
d1799 1
a1799 1
          z = 0.0_r8
d1847 1
a1847 1
          z = 0.0_r8
d1866 1
a1866 1
            ! z(i,j) = 0.0_r8
d1900 1
a1900 1
        if ( .not. my_upd ) zb%values = 0.0_r8
d1931 1
a1931 1
      if ( .not. my_upd ) zb%values = 0.0_r8
d2026 1
a2026 1
            & xb%values, xb%nRows, yb%values, yb%nRows, 1.0_r8, &
d2057 2
a2058 2
        call gemm ( 'T', 'N', size(xDns,2), size(yDns,2), size(xDns,1), -1.0_r8, &
          & xDns, size(xDns,1), yDns, size(yDns,1), 1.0_r8, &
d2063 2
a2064 2
        call gemm ( 'T', 'N', size(xDns,2), size(yDns,2), size(xDns,1), +1.0_r8, &
          & xDns, size(xDns,1), yDns, size(yDns,1), 1.0_r8, &
d2096 2
a2097 2
    real(r8), dimension(:), intent(in) :: V
    real(r8), dimension(:), intent(inout) :: P
d2102 1
a2102 1
    real(r8) :: AV                 ! Product of a column of A and the vector V
d2106 1
a2106 1
    real(r8) :: S                  ! SUBTRACT => -1 else +1
d2119 3
a2121 3
    s = 1.0_r8
    if ( my_sub ) s = -1.0_r8
    if ( .not. my_update ) p = 0.0_r8
d2146 1
a2146 1
        av = 0.0_r8
d2164 1
a2164 1
          & size(a%values,1), v, 1, 1.0_r8, p, 1 )
d2178 2
a2179 2
    real(r8), dimension(:), intent(in) :: V
    real(r8), dimension(:), intent(inout) :: P
d2184 1
a2184 1
    real(r8) :: SIGN               ! Multiplying by sign is faster than testing
d2197 3
a2199 3
    sign = 1.0_r8
    if ( my_sub ) sign = -1.0_r8
    if ( .not. my_update ) p = 0.0_r8
d2231 1
a2231 1
          & size(b%values,1), v, 1, 1.0_r8, p, 1 )
d2269 2
a2270 2
    real(r8), dimension(:), intent(in) :: V
    real(r8), dimension(size(v)) :: P
d2279 1
a2279 1
    real (r8), dimension(:,:), pointer :: V ! Matrix values
d2309 1
a2309 1
    real(r8), intent(in), dimension(:) :: V
d2347 1
a2347 1
    real(r8), intent(in) :: A
d2359 2
a2360 2
    real (r8), dimension(:), intent(inout), target :: X
    real (r8), dimension(:), intent(in), target, optional :: B
d2364 1
a2364 1
    real (r8) :: D        ! Diagonal element of U
d2366 1
a2366 1
    real (r8), dimension(:), pointer :: MY_B   ! B if B is present, else X
d2369 2
a2370 2
    real (r8), parameter :: TOL = tiny(0.0)
    real (r8), dimension(:,:), intent(in) :: U 
d2418 1
a2418 1
    real(r8) :: D        ! Diagonal element of U
d2424 3
a2426 3
    real(r8), parameter :: TOL = tiny(0.0_r8)
    real(r8), pointer, dimension(:,:) :: XS  ! The solution, dense
    real(r8), pointer, dimension(:,:) :: UD  ! U, densified
d2558 2
a2559 2
    real(r8), dimension(:), intent(inout), target :: X
    real(r8), dimension(:), intent(in), target, optional :: B
d2563 1
a2563 1
    real(r8) :: D        ! Diagonal element of U
d2565 1
a2565 1
    real(r8), dimension(:), pointer :: MY_B   ! B if B is present, else X
d2568 2
a2569 2
    real(r8), parameter :: TOL = tiny(0.0_r8)
    real(r8), dimension(:,:), pointer :: UD  ! U, densified
d2651 1
a2651 1
    real(r8), pointer :: Z(:,:)              ! Full array of values
d2671 3
a2673 3
    real(r8), save :: SQ_EPS = -1.0_r8  ! sqrt(epsilon(1.0_r8))
    real(r8) :: ZT(size(z,2))      ! Maximum value in a column of Z, then
      ! max(sqrt(sq_eps*zt),tiny(1.0_r8)).  Elements less than this threshold
d2676 1
a2676 1
    if ( sq_eps < 0.0_r8 ) sq_eps = sqrt(epsilon(1.0_r8))
d2679 1
a2679 1
    ! zt(j) = max(sq_eps*zt(j), sqrt(tiny(1.0_r8)))
d2681 1
a2681 1
      zt(j) = 0.0_r8
d2685 1
a2685 1
!     zt(j) = max(sq_eps*zt(j), sqrt(tiny(1.0_r8)))
d2762 1
a2762 1
    real(r8), pointer :: D(:,:)              ! Densified block, if necessary
d2783 2
a2784 2
    real (r8), dimension(:,:), pointer :: D ! Dense form of matrix
    real (r8), dimension(:,:), pointer :: DT ! Transpose of D
d2808 1
a2808 1
    real(r8), intent(in) :: LAMBDA
d2813 1
a2813 1
    real(r8), dimension(:,:), pointer :: T   ! A temporary dense matrix
d2865 2
a2866 2
      real(r8), intent(inout) :: T(:,:)
      real(r8), intent(in) :: LAMBDA
d2881 1
a2881 1
    real(r8), intent(in) :: X(:)
d2890 3
a2892 3
    real(r8) :: S                            ! Sign to use for X, +1 or -1
    real(r8), dimension(:,:), pointer :: T   ! A temporary dense matrix
    real(r8) :: V                            ! The value to update.  Either
d2896 1
a2896 1
    s = 1.0_r8
d2898 1
a2898 1
      if ( subtract ) s = -1.0_r8
d2914 1
a2914 1
          if ( abs(x(i)) <= tiny(0.0_r8) ) call MLSMessage ( &
d2937 1
a2937 1
          if ( abs(x(i)) <= tiny(0.0_r8) ) call MLSMessage ( &
d2952 1
a2952 1
              if ( abs(x(i)) <= tiny(0.0_r8) ) call MLSMessage ( &
d2978 3
a2980 3
      real(r8), intent(inout) :: T(:,:) ! Matrix element to update
      real(r8), intent(in) :: X(:)      ! Vector update diagonal
      real(r8), intent(in) :: S         ! Sign for X, +1 or -1.
d2985 1
a2985 1
          if ( abs(x(i)) <= tiny(0.0_r8) ) call MLSMessage ( &
d3067 1
a3067 1
    real(r8), dimension(:,:), intent(in) :: M ! Matrix to compare it to
d3077 2
a3078 2
    real(r8), dimension(:,:), pointer :: BM ! B dense
    real(r8) :: D, E = -1.0_r8, EMAX
d3080 1
a3080 1
    real(r8), parameter :: T = tiny(1.0_r8)
d3083 1
a3083 1
    if ( e < 0.0_r8 ) e = sqrt(epsilon(1.0_r8))
d3089 1
a3089 1
    emax = -1.0_r8
d3093 1
a3093 1
        if ( d > 1.0e3_r8 * max(t,e*(abs(bm(i,j))+abs(m(i,j)))) ) then
d3139 4
d3153 1
a3153 1
! Add Add_Matrix_Blocks_Unscaled, clean up x(i) == 0.0_r8
@


2.80
log
@Embarassing bug fix.
@
text
@d171 1
a171 1
       "$Id: MatrixModule_0.f90,v 2.79 2002/08/29 21:35:34 livesey Exp $"
d2290 1
d3139 3
@


2.79
log
@New 'blocking' approach to MultiplyMatrix_XTY_0
@
text
@d171 1
a171 1
       "$Id: MatrixModule_0.f90,v 2.78 2002/08/29 04:44:53 livesey Exp $"
d2008 1
d3138 3
@


2.78
log
@Made the MultiplyMatrix_XY and XT_T slightly more efficient.
@
text
@d43 1
a43 1
  public :: SolveCholeskyV_0, Sparsify, Spill, Spill_0
d171 1
a171 1
       "$Id: MatrixModule_0.f90,v 2.77 2002/08/19 20:50:56 vsnyder Exp $"
d220 1
d1590 1
d1979 9
a1987 4
          do j = 1, zb%nCols  ! Columns of ZB
            if ( associated(ym) ) then
              if ( iand(ichar(ym(j)),m_LinAlg) /= 0 ) then
          cycle
d1989 2
a1990 3
            end if
            mz = zb%nRows
            if ( my_upper ) mz = j
d1992 5
a1996 4
            do i = 1, mz      ! Rows of Z = columns of XB
              if ( associated(xm) ) then
                if ( iand(ichar(xm(i)),m_LinAlg) /= 0 ) then
            cycle
d1998 6
a2003 7
              end if
              xy = dot( xb%nRows, xb%values(1,i), 1, &
                &                 yb%values(1,j), 1 )
!             xy = dot_product( xb%values(1:xb%nRows,i), &
!               &               yb%values(1:xb%nRows,j) )
              zb%values(i,j) = zb%values(i,j) + s * xy
            end do ! i = 1, xb%nCols
d2005 2
a2006 1
          end do ! j = 1, yb%nCols
d2008 4
a2011 1
          do j = 1, zb%nCols  ! Columns of ZB
d2013 8
a2020 7
            do i = 1, j       ! Rows of Z = columns of XB
              xy = dot(xb%nRows, xb%values(1,i), 1, &
                &                yb%values(1,j), 1 )
!             xy = dot_product( xb%values(1:xb%nRows,i), &
!               &               yb%values(1:xb%nRows,j) )
              zb%values(i,j) = zb%values(i,j) + s * xy
            end do ! i
d2022 1
a2022 1
          end do ! j
d3137 3
@


2.77
log
@Add Add_Matrix_Blocks_Unscaled, clean up x(i) == 0.0_r8
@
text
@d171 1
a171 1
       "$Id: MatrixModule_0.f90,v 2.76 2002/08/15 22:12:47 livesey Exp $"
d1470 6
a1475 2
    call sparsify ( z, zb, 'Z in MultiplyMatrix_XY_0', moduleName ) ! Zb := Z

a1477 1
    call deallocate_test ( z, 'Z in MultiplyMatrix_XY_0', moduleName )
d1549 6
a1554 2
    call sparsify ( z, zb, 'Z in MultiplyMatrix_XY_T_0', moduleName ) ! Zb := Z

a1556 1
    call deallocate_test ( z, 'Z in MultiplyMatrix_XY_T_0', moduleName )
d3126 3
@


2.76
log
@Bug work around in Add_Matrix_Blocks and fix in TransposeMatrix_0
@
text
@d138 1
a138 1
    module procedure Add_Matrix_Blocks
d171 1
a171 1
       "$Id: MatrixModule_0.f90,v 2.75 2002/08/06 02:15:10 livesey Exp $"
d224 2
a225 1
  function Add_Matrix_Blocks ( XB, YB ) result ( ZB ) ! ZB = XB + YB
d227 1
d237 1
d243 4
d280 1
a280 1
        z = z + w
d336 1
d345 1
d361 1
d370 1
d385 1
a385 1
        zb%values = x%values + y%values
d405 15
d1253 1
a1253 1
      if ( U(j,j) == 0.0_r8 ) then
d2895 2
a2896 1
          if ( x(i) == 0.0_r8 ) call MLSMessage ( MLSMSG_Error, moduleName, &
d2918 2
a2919 1
          if ( x(i) == 0.0_r8 ) call MLSMessage ( MLSMSG_Error, moduleName, &
d2933 2
a2934 1
              if ( x(i) == 0.0_r8 ) call MLSMessage ( MLSMSG_Error, moduleName, &
d2966 2
a2967 1
          if ( x(i) == 0.0_r8 ) call MLSMessage ( MLSMSG_Error, moduleName, &
d3120 3
@


2.75
log
@Added TransposeMatrix_0 and ReflectMatrix_0
@
text
@d171 1
a171 1
       "$Id: MatrixModule_0.f90,v 2.74 2002/07/22 03:26:25 livesey Exp $"
d236 2
a237 1
    real(kind(zb%values)), pointer :: Z(:,:) ! May be used if Y is col-sparse
d264 6
a269 10
        call allocate_test ( zb%r1, size(x%r1), "zb%r1", ModuleName )
        zb%r1 = min(x%r1, y%r1)                  ! First nonzero row
        call allocate_test ( zb%r2, size(x%r2), "zb%r2", ModuleName, lowBound=0 )
        zb%r2(0) = 0
        do k = 1, size(x%r1)                     ! Calculate size of Values
          zb%r2(k) = zb%r2(k-1) + &
            & max( x%r2(k)-x%r2(k-1)+x%r1(k), y%r2(k)-y%r2(k-1)+y%r1(k) ) - &
            & zb%r1(k) + 1
        end do
        call allocate_test ( zb%values, zb%r2(size(x%r1)), 1, "zb%values", &
d271 52
a322 34
        zb%values = 0.0_r8 ! ??? Improve this by only filling
        !                    ??? values that don't get set below
        do k = 1, size(x%r1)
          i = 1; j = 1; l = 1
          n = y%r1(k) - x%r1(k)
          if ( n > 0 ) then ! Copy rows in X that are not in Y
            zb%values(zb%r2(k-1)+l:zb%r2(k-1)+l-1+n, 1) = &
              & x%values(x%r2(k-1)+i:x%r2(k-1)+i-1+n, 1)
            i = i + n
          else if ( n < 0 ) then ! Copy rows in Y that are not in X
            n = - n
            zb%values(zb%r2(k-1)+l:zb%r2(k-1)+l-1+n, 1) = &
              & y%values(y%r2(k-1)+j:y%r2(k-1)+j-1+n, 1)
            j = j + n
          end if
          l = l + n
          n = min( x%r1(k) + x%r2(k) - x%r2(k-1) - 1, &
            &      y%r1(k) + y%r2(k) - y%r2(k-1) - 1 ) - &
            &      max( x%r1(k), y%r1(k) )
          zb%values(zb%r2(k-1)+l:zb%r2(k-1)+l-1+n, 1) = &
            & x%values(x%r2(k-1)+i:x%r2(k-1)+i-1+n, 1) + &
            & y%values(y%r2(k-1)+j:y%r2(k-1)+j-1+n, 1)
          i = i + n; j = j + n; l = l + n
          n = y%r1(k) + y%r2(k) - y%r2(k-1) - &
            & ( x%r1(k) + x%r2(k) - x%r2(k-1) )
          if ( n > 0 ) then ! Copy rows of Y that are not in X
            zb%values(zb%r2(k-1)+l:zb%r2(k-1)+l-1+n, 1) = &
              & y%values(y%r2(k-1)+j:y%r2(k-1)+j-1+n, 1)
          else if ( n < 0 ) then ! Copy rows in X that are not in Y
            n = - n
            zb%values(zb%r2(k-1)+l:zb%r2(k-1)+l-1+n, 1) = &
              & x%values(x%r2(k-1)+i:x%r2(k-1)+i-1+n, 1)
          end if
        end do
d2749 1
a2749 1
      nullify ( D )
d3090 3
@


2.74
log
@Added checkIntegrity
@
text
@d41 1
a41 1
  public :: operator(+), operator(.TX.), RowScale
d44 2
a45 1
  public :: UpdateDiagonal, UpdateDiagonal_0, UpdateDiagonalVec_0
d145 4
d161 4
d171 1
a171 1
       "$Id: MatrixModule_0.f90,v 2.73 2002/07/17 06:00:55 livesey Exp $"
d2215 30
d2717 27
d3075 3
@


2.73
log
@Added M_Unknown
@
text
@d19 1
a19 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d25 1
a25 1
  public :: Add_Matrix_Blocks, CheckBlocks, Assignment(=), CholeskyFactor
d52 4
d162 1
a162 1
       "$Id: MatrixModule_0.f90,v 2.72 2002/07/01 23:49:47 vsnyder Exp $"
d387 173
d3009 3
@


2.72
log
@Plug memory leaks
@
text
@d33 1
a33 1
  public :: M_Absent, M_Banded, M_Column_Sparse, M_Full
d158 1
a158 1
       "$Id: MatrixModule_0.f90,v 2.71 2002/06/18 01:21:18 vsnyder Exp $"
d176 4
d691 1
a691 1
    case ( M_Absent )
d2832 3
@


2.71
log
@SolveCholeskyM_0 wasn't solving for the first row in the dense-block /
transpose=.true. case.
@
text
@d158 1
a158 1
       "$Id: MatrixModule_0.f90,v 2.70 2002/06/15 00:41:20 vsnyder Exp $"
d553 2
a554 1
    type(MatrixElement_T), intent(out) :: Z
d579 3
a581 1
    type(MatrixElement_T), intent(out), target, optional :: NEWX
d635 3
a637 1
    type(MatrixElement_T), intent(out) :: Z
d2031 3
a2033 1
    type(MatrixElement_T), intent(out), target, optional :: NEWX
d2216 1
a2216 1
!$OMP PARALLEL DO
d2372 2
a2373 1
    type(MatrixElement_T), intent(out) :: B  ! Z as a block, maybe sparse
d2512 1
a2512 1
      nCols = a%nCols ! because the first argument of CreateBlock is intent(out)
d2599 1
a2599 1
      nCols = a%nCols ! because the first argument of CreateBlock is intent(out)
d2690 6
a2695 2
    type(MatrixElement_T), intent(out) :: EmptyBlock
    ! Default initialization does the rest, because of intent(out)
d2828 4
@


2.70
log
@1.  Fix some comments.  2.  Fix dimensions for result of MultiplyMatrix_XY_T_0.
3.  Fix some references to optional arguments not protected by present().
4.  Add Spill_0 subroutine.
@
text
@d158 1
a158 1
       "$Id: MatrixModule_0.f90,v 2.69 2002/03/12 01:38:33 vsnyder Exp $"
a733 3
print *, 'In DenseCholesky at diagonal element', i, ' D =', d
print *, 'XIN(i,i) =', xin(i,i)
call dump ( zt(1:i-1,i), name='zt(1:i-1,i)' )
d1306 1
a1306 1
    ! zb%nRows/zb%nCols undefined here, so don't them.
d2202 8
d2224 1
d2816 5
@


2.69
log
@Fix typo in a comment
@
text
@d43 2
a44 2
  public :: SolveCholeskyV_0, Sparsify, UpdateDiagonal, UpdateDiagonal_0
  public :: UpdateDiagonalVec_0
d148 4
d158 1
a158 1
       "$Id: MatrixModule_0.f90,v 2.68 2002/03/05 23:16:35 livesey Exp $"
d366 3
a368 3
  ! same as for intrinsic assignment.  Notice that CopyBlock does a deep
  ! copy.  If one has Z = X in a loop, it is therefore necessary only to
  ! destroy Z after the loop.
d734 3
d1272 1
a1272 1
      if ( abs(beta) < 0.5_r8 ) call createBlock ( zb, xb%nRows, yb%nCols, M_Absent )
d1281 1
a1281 1
    call allocate_test ( z, xb%nRows, yb%nCols, 'Z in MultiplyMatrix_XY_T_0', &
d1309 1
a1309 1
    ! zb%noRows/zb%noCols undefined here, so avoid using them.
d1421 1
a1421 1
        if ( update .and. zb%kind /= m_absent ) then
d1472 1
a1472 1
        if ( update .and. zb%kind /= m_absent ) then
d1555 1
a1555 1
        if ( update .and. zb%kind /= m_absent ) then
d1603 1
a1603 1
        if ( update .and. zb%kind /= m_absent ) then
d1777 1
a1777 1
          ! Same as the following, but could use Atlas:
d2306 1
a2306 1
!           &      my_b(u%r1(i):u%r1(i)+u%r2(i)-u%r2(i-1)-1)) ) / d
d2457 26
d2810 3
@


2.68
log
@Fixed various bugs in MultiplyMatrix_XY_0 and MultiplyMatrix_XY_T_0
@
text
@d154 1
a154 1
       "$Id: MatrixModule_0.f90,v 2.67 2002/02/23 02:59:51 vsnyder Exp $"
d1165 3
a1167 2
  ! If Update is absent or false, ZB = +/- XB YB.  Otherwise, ZB = ZB +/- XB YB
  ! The +/- is + unless subtract is present and true
d1240 3
a1242 2
  ! If Update is absent or false, ZB = +/- XB YB^T.  Otherwise, ZB = ZB +/ XB YB^T.
  ! The +/- is + unless subtract is present and true
d2777 3
@


2.67
log
@Correct tests for 'don't update, don't subtract; fix LaTeX
@
text
@d154 1
a154 1
       "$Id: MatrixModule_0.f90,v 2.66 2002/02/23 02:34:10 vsnyder Exp $"
d1165 2
a1166 2
  ! If Update is absent or false, ZB = XB YB.  Otherwise, if Subtract is
  ! absent or false, ZB = ZB + XB YB.  Otherwise ZB = ZB - XB YB
d1172 1
d1177 5
a1184 3
      if ( present(subtract) ) then
        if ( subtract ) beta = -1.0_r8
      end if
d1186 1
a1186 1

d1196 1
d1209 1
d1219 1
d1225 3
a1227 2
    call gemm ( 'N', 'N', xb%nRows, yb%nCols, xb%nCols, 1.0_r8, &
      & x, xb%nRows, y, yb%nRows, beta, z, zb%nRows )
d1239 2
a1240 2
  ! If Update is absent or false, ZB = XB YB^T.  Otherwise, if Subtract is
  ! absent or false, ZB = ZB + XB YB^T.  Otherwise ZB = ZB - XB YB^T
d1246 1
d1251 6
a1259 3
      if ( present(subtract) ) then
        if ( subtract ) beta = -1.0_r8
      end if
d1261 1
a1261 1

d1271 1
d1284 1
d1294 1
d1300 3
a1302 2
    call gemm ( 'N', 'T', xb%nRows, yb%nRows, xb%nCols, 1.0_r8, &
      & x, xb%nRows, y, yb%nRows, beta, z, zb%nRows )
d2775 3
@


2.66
log
@Fix the LaTeX for InvertDenseCholesky
@
text
@d154 1
a154 1
       "$Id: MatrixModule_0.f90,v 2.65 2002/02/23 02:13:16 vsnyder Exp $"
d1195 1
a1195 1
    if ( beta < 0.5_r8 ) then
d1262 1
a1262 1
    if ( beta < 0.5_r8 ) then
d2760 3
@


2.65
log
@Check for absent blocks before checking shapes
@
text
@d154 1
a154 1
       "$Id: MatrixModule_0.f90,v 2.64 2002/02/22 20:11:45 vsnyder Exp $"
d988 8
a995 8
  !{Let $u_{ij}$ be an element of $U$ and $t_{ij}$ be an element of $U^{-1}$.
  ! To invert $U$, solve $\sum_{l=i}^j t_{il} u_{lj} = \delta_{ij}$ for
  ! $t_{ij}$.  (The index of summation $l$ runs from $i$ to $j$ instead of
  ! from $1$ to $n$ because we know that $U$ and $U^{-1}$ are triangular.) 
  ! This gives $t_{ii} = u_{ii}^{-1}$ (for $i = j$) and  $t_{ij} = - \left (
  ! \sum_{l=i}^{j-1} t_{il} u_{lj} \right ) u_{jj}^{-1}$ (for $i < j$).  We
  ! compute the diagonal elements of $U^{-1}$ first, giving the following
  ! algorithm:
d2760 3
@


2.64
log
@Fix the LaTeX in InvertDenseCholesky_0
@
text
@d154 1
a154 1
       "$Id: MatrixModule_0.f90,v 2.63 2002/02/22 01:17:41 vsnyder Exp $"
d994 1
a994 1
  ! compute the diagonal elements of $t$ first, giving the following
a1175 4
    if ( xb%nCols /= yb%nRows ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "XB and YB Matrix sizes incompatible in MultiplyMatrix_XY_0" )

d1185 1
a1185 1
      if ( beta < 0.5_r8 ) call createBlock ( zb, xb%nRows, yb%nCols, M_Absent )
d1189 4
a1242 4
    if ( xb%nCols /= yb%nCols ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "XB and YB Matrix sizes incompatible in MultiplyMatrix_XY_T_0" )

d1252 1
a1252 1
      if ( beta < 0.5_r8 ) call createBlock ( zb, xb%nRows, yb%nCols, M_Absent )
d1256 4
d2760 3
@


2.63
log
@Added InvertCholesky_0, InvertDenseCholesky_0, MultiplyMatrix_XY_0 and
MultiplyMatrix_XY_T_0.  Changed the name MultiplyMatrixBlocks_0 to
MultiplyMatrix_XTY_0.  Changed the name of MatrixInversion to
MatrixInversion_0.  Added generics.  Revised MatrixInversion_0 to use
InvertDenseCholesky.
@
text
@d154 1
a154 1
       "$Id: MatrixModule_0.f90,v 2.62 2002/02/09 21:27:12 livesey Exp $"
d993 1
a993 1
  ! \sum_{l=i}^{j-1} t_{il} u_{lj} \right ) u_{ii}^{-1}$ (for $i < j$).  We
d999 1
a999 1
  !   \right ) t_{ii}~~ j = i+1,~ \dots,~ n \right \}~~ i = 1,~ \dots,~ n-1$
d2760 7
@


2.62
log
@Added nullification in MatrixInversion
@
text
@d29 13
a41 8
  public :: GetDiagonal, GetDiagonal_0
  public :: GetMatrixElement, GetMatrixElement_0, GetVectorFromColumn
  public :: GetVectorFromColumn_0, M_Absent, M_Banded, M_Column_Sparse, M_Full
  public :: MatrixInversion
  public :: MatrixElement_T, MaxAbsVal, MaxAbsVal_0, MinDiag, MinDiag_0
  public :: Multiply, MultiplyMatrixBlocks, MultiplyMatrixVector
  public :: MultiplyMatrixVector_0, MultiplyMatrixVectorNoT
  public :: MultiplyMatrixVectorNoT_0, operator(+), operator(.TX.), RowScale
d88 12
d109 1
a109 1
    module procedure MultiplyMatrixBlocks, MultiplyMatrixVector_0
d120 12
d137 1
a137 1
    module procedure NewMultiplyMatrixBlocks, NewMultiplyMatrixVector_0
d154 1
a154 1
       "$Id: MatrixModule_0.f90,v 2.61 2002/02/05 02:39:59 vsnyder Exp $"
d176 1
a176 1
    integer :: NROWS = 0, NCOLS = 0          ! Numbers of rows and columns
d235 1
a235 1
    if ( xb%nrows /= yb%nrows .or. xb%ncols /= yb%ncols ) &
d290 1
a290 1
        call allocate_test ( z, y%nrows, y%ncols, "Z in Add_Matrix_Blocks", &
d313 1
a313 1
        call allocate_test ( z, y%nrows, y%ncols, "Z in Add_Matrix_Blocks", &
d406 2
a407 2
    nc = x%ncols
    if ( nc /= x%nrows )&
d523 1
a523 1
      do j = 1, x%ncols
d528 1
a528 1
      end do ! j = 1, x%ncols
d530 1
a530 1
      do j = 1, x%ncols
d535 1
a535 1
      end do ! j = 1, x%ncols
d538 1
a538 1
        if ( i > x%nrows ) return
d588 1
a588 1
      do i = 1, z%ncols
d592 1
a592 1
      do i = 1, z%ncols
d596 1
a596 1
      do i = 1, z%ncols
d620 1
a620 1
      do i = 1, x%nrows
a757 1
      print*,size(z,1),b%nRows, size(z,2), b%nCols
d783 1
a783 1
    ! its kind to M_Absent.  Don't clobber b%nrows and b%ncols.
d804 1
a804 1
    n = min(b%nrows,b%ncols)
d880 1
a880 1
    if ( column < 1 .or. column > b%ncols ) call MLSMessage ( MLSMSG_Error, &
d882 1
a882 1
    if ( size(x) < b%nrows )  call MLSMessage ( MLSMSG_Error, &
d896 1
a896 1
      x(1:b%nrows) = b%values(1:b%nrows,column)
d900 165
d1076 4
a1079 2
!-----------------------------------------------  MatrixInversion  -----
  subroutine MatrixInversion ( A, Upper )
d1082 1
a1082 1
  logical, intent(in), optional :: upper
d1084 6
a1089 5
  real (r8), dimension(:,:), pointer :: U
  real (r8), dimension(:), pointer :: b
  real (r8), dimension(:), pointer :: x
  logical :: myUpper  
  integer :: i, j, n
d1095 8
a1102 16
  nullify ( x, b, u )
  call allocate_Test ( x, n, "X", moduleName//"%MatrixInversion" )
  call allocate_Test ( b, n, "B", moduleName//"%MatrixInversion" )
  call allocate_Test ( u, n, n, "U", moduleName//"%MatrixInversion" )

  call DenseCholesky (U, A)

  if ( .not. myUpper ) j = n
  do i = 1, n
    b = 0.0_r8
    b(i) = 1.0_r8
    call SolveCholeskyA_0 ( U, x, b, transpose=.true. )
    b = x
    call SolveCholeskyA_0 ( U, x, b, transpose=.false. )
    if ( myUpper ) j = i
    A(1:j,i) = x(1:j)
d1105 21
a1125 3
  call deallocate_Test ( x, "X", moduleName//"%MatrixInversion" )
  call deallocate_Test ( b, "B", moduleName//"%MatrixInversion" )
  call deallocate_Test ( u, "U", moduleName//"%MatrixInversion" )
d1127 1
a1127 1
  end subroutine MatrixInversion
d1140 1
a1140 1
      do i = 1, min(b%nrows,b%ncols)
d1146 1
a1146 1
      do i = 1, min(b%nrows,b%ncols)
d1157 1
a1157 1
      do i = 2, min(b%nrows,b%ncols)
d1163 136
a1298 2
  ! ---------------------------------------  MultiplyMatrixBlocks  -----
  subroutine MultiplyMatrixBlocks ( XB, YB, ZB, UPDATE, SUBTRACT, XMASK, YMASK, &
d1351 4
a1359 3
    if ( xb%nrows /= yb%nrows ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "XB and YB Matrix sizes incompatible in MultiplyMatrixBlocks" )
d1362 1
a1362 1
        if ( xb%ncols /= zb%nrows .or. yb%ncols /= zb%ncols ) &
d1364 1
a1364 1
            & "ZB Matrix size incompatible in MultiplyMatrixBlocks" )
d1366 2
a1367 2
        zb%nrows = xb%ncols
        zb%ncols = yb%ncols
d1370 2
a1371 2
      zb%nrows = xb%ncols
      zb%ncols = yb%ncols
d1395 2
a1396 2
        call allocate_test ( z, zb%nrows, zb%ncols, &
          & "Z for banded X banded in MultiplyMatrixBlocks", ModuleName )
d1402 1
a1402 1
        do j = 1, zb%ncols    ! Columns of Z = columns of YB
d1410 1
a1410 1
          mz = zb%nrows
d1442 1
a1442 1
          & "Z for banded X banded in MultiplyMatrixBlocks", ModuleName )
d1446 2
a1447 2
        call allocate_test ( z, xb%ncols, yb%ncols, &
          & "Z for banded X sparse in MultiplyMatrixBlocks", ModuleName )
d1453 1
a1453 1
        do j = 1, zb%ncols    ! Columns of Z
d1457 1
a1457 1
          mz = zb%nrows
d1490 1
a1490 1
          & "Z for banded X banded in MultiplyMatrixBlocks", ModuleName )
d1493 2
a1494 2
          call allocate_test ( z, xb%ncols, yb%ncols, &
            & "Z for banded X full in MultiplyMatrixBlocks", ModuleName )
d1496 1
a1496 1
          call createBlock ( zb, xb%ncols, yb%ncols, M_Full, novalues=.true. )
d1500 1
a1500 1
        do i = 1, xb%ncols    ! Rows of ZB
d1511 1
a1511 1
          do j = mz, yb%ncols  ! Columns of ZB
d1529 2
a1530 2
        call allocate_test ( z, xb%ncols, yb%ncols, &
          & "Z for sparse X banded in MultiplyMatrixBlocks", ModuleName )
d1536 1
a1536 1
        do j = 1, zb%ncols    ! Columns of Z
d1540 1
a1540 1
          mz = zb%nrows
d1573 1
a1573 1
          & "Z for banded X banded in MultiplyMatrixBlocks", ModuleName )
d1577 2
a1578 2
        call allocate_test ( z, xb%ncols, yb%ncols, &
          & "Z for sparse X sparse in MultiplyMatrixBlocks", ModuleName )
d1584 1
a1584 1
        do j = 1, zb%ncols    ! Columns of Z
d1588 1
a1588 1
          mz = zb%nrows
d1626 1
a1626 1
          & "Z for banded X banded in MultiplyMatrixBlocks", ModuleName )
d1629 2
a1630 2
          call allocate_test ( z, xb%ncols, yb%ncols, &
            & "Z for sparse X full in MultiplyMatrixBlocks", ModuleName )
d1632 1
a1632 1
          call createBlock ( zb, xb%ncols, yb%ncols, M_Full, novalues=.true. )
d1636 1
a1636 1
        do j = 1, zb%ncols    ! Columns of ZB
d1640 1
a1640 1
          mz = zb%nrows
d1660 2
a1661 2
        call allocate_test ( z, xb%ncols, yb%ncols, &
          & "Z for full X <anything> in MultiplyMatrixBlocks", ModuleName )
d1663 1
a1663 1
        call createBlock ( zb, xb%ncols, yb%ncols, M_Full, novalues=.true. )
d1669 1
a1669 1
        do j = 1, zb%ncols    ! Columns of ZB
d1676 1
a1676 1
          mz = zb%nrows
d1692 1
a1692 1
        do j = 1, zb%ncols    ! Columns of ZB
d1698 1
a1698 1
          mz = zb%nrows
d1714 1
a1714 1
          do j = 1, zb%ncols  ! Columns of ZB
d1720 1
a1720 1
            mz = zb%nrows
d1729 1
a1729 1
              xy = dot( xb%nrows, xb%values(1,i), 1, &
d1731 2
a1732 2
!             xy = dot_product( xb%values(1:xb%nrows,i), &
!               &               yb%values(1:xb%nrows,j) )
d1734 1
a1734 1
            end do ! i = 1, xb%ncols
d1736 1
a1736 1
          end do ! j = 1, yb%ncols
d1738 1
a1738 1
          do j = 1, zb%ncols  ! Columns of ZB
d1741 1
a1741 1
              xy = dot(xb%nrows, xb%values(1,i), 1, &
d1743 2
a1744 2
!             xy = dot_product( xb%values(1:xb%nrows,i), &
!               &               yb%values(1:xb%nrows,j) )
d1750 3
a1752 3
          call gemm ( 'T', 'N', xb%ncols, yb%ncols, xb%nrows, s, &
            & xb%values, xb%nrows, yb%values, yb%nrows, 1.0_r8, &
            & zb%values, zb%nrows )
d1761 1
a1761 1
      line = 'MultiplyMatrixBlocks'
d1811 1
a1811 1
  end subroutine MultiplyMatrixBlocks
d1834 1
a1834 1
    if ( a%nrows /= size(v) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1836 1
a1836 1
    if ( a%ncols /= size(p) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1912 1
a1912 1
    if ( b%ncols /= size(v) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1914 1
a1914 1
    if ( b%nrows /= size(p) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1977 2
a1978 2
  ! -------------------------------------  NewMultiplyMatrixBlocks  ----
  function NewMultiplyMatrixBlocks ( X, Y ) result ( Z ) ! Z = X^T Y
d1988 2
a1989 2
    call MultiplyMatrixBlocks ( x, y, z )
  end function NewMultiplyMatrixBlocks
d2019 1
a2019 1
      do i = 1, z%ncols
d2025 1
a2025 1
      do i = 1, z%ncols
d2030 1
a2030 1
      do i = 1, z%nrows
d2043 55
d2121 1
a2121 1
    n = u%nrows
d2126 1
a2126 1
    if ( n /= my_b%nrows ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d2254 1
a2254 1
    n = u%nrows
a2329 55
  ! -------------------------------------------  SolveCholeskyA_0  -----  
  subroutine SolveCholeskyA_0 ( U, X, B, TRANSPOSE )
  ! Solve the system U X = B or U^T X = B for X, depending on TRANSPOSE,
  ! where U is known to be upper-triangular Array.  X may be the same as B.
  ! B may be absent, in which case the right-hand side is in X on input,
  ! and the solution replaces it on output.  The arrays X and B are
  ! one-dimensional arrays.

    real (r8), dimension(:), intent(inout), target :: X
    real (r8), dimension(:), intent(in), target, optional :: B
    logical, intent(in), optional :: TRANSPOSE    ! Solve U^T X = B if
    !                                               present and true.

    real (r8) :: D        ! Diagonal element of U
    integer :: I          ! Subscripts and loop inductors
    real (r8), dimension(:), pointer :: MY_B   ! B if B is present, else X
    logical :: MY_T      ! FALSE if TRANSPOSE is absent, else TRANSPOSE
    integer :: N         ! Size of U matrix, which must be square
    real (r8), parameter :: TOL = tiny(0.0)
    real (r8), dimension(:,:), intent(in) :: U 

    n = size(x)
    
    my_b => x
    if ( present(b) ) my_b => b
    my_t = .false.
    if ( present(transpose) ) my_t = transpose

    if ( my_t ) then ! solve U^T X = B for X
        d = u(1,1)
        if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "U matrix in SolveCholeskyA_0 is singular" )
        x(1) = my_b(1) / d
        do i = 2, n
          d = u(i,i)
          if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyA_0 is singular" )
          x(i) = ( my_b(i) - dot(i-1, u(1,i), 1, x(1), 1) ) / d
!         x(i) = ( my_b(i) - dot_product( u(:i-1,i), x(:i-1)) ) / d
        end do ! i = 1, n
    else             ! solve U X = B for X
      d = u(n,n)
      if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyA_0 is singular" )
      x(n) = my_b(n) / d
      do i = n-1, 1, -1
        d = u(i,i)
        if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "U matrix in SolveCholeskyA_0 is singular" )
        x(i) = ( my_b(i) - dot(n-i, u(i,i+1), size(u,1), x(i+1), 1) ) / d
!       x(i) = ( my_b(i) - dot_product(u(i,i+1:n), x(i+1:n)) ) / d
      end do ! i = 1, n
    end if ! my_t
  end subroutine SolveCholeskyA_0

d2440 2
a2441 2
    integer :: N                             ! min(a%ncols,a%nrows)
    integer :: NCols, NRows                  ! Copies of a%...
d2445 1
a2445 1
    n = min(a%ncols,a%nrows)
d2448 2
a2449 2
      ncols = a%nCols ! because the first argument of CreateBlock is intent(out)
      nrows = a%nRows
d2516 3
a2518 3
    integer :: N                             ! min(a%ncols,a%nrows)
    integer :: M                             ! max(a%ncols,a%nrows) / n
    integer :: NCols, NRows                  ! Copies of a%...
d2531 2
a2532 2
    n = min(a%ncols,a%nrows)
    m = max(a%ncols,a%nrows) / n
d2535 2
a2536 2
      ncols = a%ncols ! because the first argument of CreateBlock is intent(out)
      nrows = a%nrows
d2644 2
a2645 2
    call output ( matrix_block%nrows ); call output ( " Rows, " )
    call output ( matrix_block%ncols ); call output ( " Columns, " )
d2760 3
@


2.61
log
@Change mask from 1-bit per to 8-bits per (using character)
@
text
@d125 1
a125 1
       "$Id: MatrixModule_0.f90,v 2.60 2001/12/01 01:02:52 livesey Exp $"
d899 1
d2419 3
@


2.60
log
@Tidied up erroneous handling of status in DenseCholesky/CholeskyFactor_0
@
text
@d21 1
d125 1
a125 1
       "$Id: MatrixModule_0.f90,v 2.59 2001/11/14 01:00:07 vsnyder Exp $"
a162 1
  integer, parameter, private :: B = bit_size(0) ! can't use "bit_size(b)"
d487 1
a487 1
  ! Clear the rows of X for which MASK has nonzero bits.
d489 1
a489 1
    integer, dimension(1:), intent(in) :: MASK
a490 1
    integer :: NB, NW              ! Indices of bit and word in MASK
d496 1
a496 1
          if ( btest( mask((i-1)/b+1), mod((i-1),b) ) ) &
d503 1
a503 1
          if ( btest( mask((x%r2(i)-1)/b+1), mod(x%r2(i)-1,b) ) ) &
d508 5
a512 10
      i = 0
      do nw = lbound(mask,1), ubound(mask,1)
        do nb = 0, b-1
          i = i + 1
          if ( i > x%nrows ) return
          if ( btest( mask(nw), nb ) ) then
              x%values(i,:) = 0.0_r8
          end if
        end do ! nb = 0, b-1
      end do ! nw = lbound(mask,1), ubound(mask,1)
d883 3
a885 3
!---------------------------------------------Matrix Inversion for Array --
  subroutine MatrixInversion(A,upper)
  
d889 3
a891 4
  real (r8), dimension(:,:), allocatable :: U
  logical :: TRANSPOSE1
  real (r8), dimension(:), allocatable :: b
  real (r8), dimension(:), allocatable :: x
d894 1
a894 1
  
d898 4
a901 4
    
  allocate(x(n))
  allocate(b(n))
  allocate(u(n,n))
d904 1
a904 1
  
d906 1
a906 1
  do i=1,n
d909 1
a909 2
    TRANSPOSE1 = .true.  
    call SolveCholeskyA_0 ( U, x, b, TRANSPOSE1 )
d911 1
a911 2
    TRANSPOSE1 = .false.  
    call SolveCholeskyA_0 ( U, x, b, TRANSPOSE1 )
d915 5
a919 5
  
  deallocate(x)
  deallocate(b)
  deallocate(u)  
  
a920 1
   
d967 2
a968 1
  ! (resp. YB) that correspond to nonzero bits of XMASK (resp. YMASK).
d974 1
a974 1
    integer, optional, pointer, dimension(:) :: XMASK, YMASK ! intent(in)
d988 1
a988 1
    integer, pointer, dimension(:) :: XM, YM
d1062 1
a1062 1
            if ( btest(ym((j-1)/b+1),mod(j-1,b)) ) cycle
d1074 1
a1074 1
              if ( btest(xm((i-1)/b+1),mod(i-1,b)) ) cycle
d1113 1
a1113 1
            if ( btest(ym((j-1)/b+1),mod(j-1,b)) ) cycle
d1120 1
a1120 1
              if ( btest(xm((i-1)/b+1),mod(i-1,b)) ) cycle
d1160 1
a1160 1
            if ( btest(xm((i-1)/b+1),mod(i-1,b)) ) cycle
d1171 1
a1171 1
              if ( btest(ym((j-1)/b+1),mod(j-1,b)) ) cycle
d1196 1
a1196 1
            if ( btest(ym((j-1)/b+1),mod(j-1,b)) ) cycle
d1203 1
a1203 1
              if ( btest(xm((i-1)/b+1),mod(i-1,b)) ) cycle
d1244 1
a1244 1
            if ( btest(ym((j-1)/b+1),mod(j-1,b)) ) cycle
d1251 1
a1251 1
              if ( btest(xm((i-1)/b+1),mod(i-1,b)) ) cycle
d1296 1
a1296 1
            if ( btest(ym((j-1)/b+1),mod(j-1,b)) ) cycle
d1303 1
a1303 1
              if ( btest(xm((i-1)/b+1),mod(i-1,b)) ) cycle
d1329 1
a1329 1
            if ( btest(ym((j-1)/b+1),mod(j-1,b)) ) cycle
d1339 1
a1339 1
              if ( btest(xm((i-1)/b+1),mod(i-1,b)) ) cycle
d1352 1
a1352 1
            if ( btest(ym((j-1)/b+1),mod(j-1,b)) ) cycle
d1361 1
a1361 1
              if ( btest(xm((i-1)/b+1),mod(i-1,b)) ) cycle
d1374 1
a1374 1
              if ( btest(ym((j-1)/b+1),mod(j-1,b)) ) then
d1383 1
a1383 1
                if ( btest(xm((i-1)/b+1),mod(i-1,b)) ) then
d1430 1
a1430 1
          if ( btest(xm((i-1)/b+1),mod(i-1,b))) xDns(:,i)=0.0
d1436 1
a1436 1
          if ( btest(ym((i-1)/b+1),mod(i-1,b))) yDns(:,i)=0.0
d1476 2
a1477 1
  ! If MASK is present and associated, use it to suppress multiplying columns of A.
d1483 1
a1483 1
    integer, optional, pointer, dimension(:) :: MASK ! intent(in)
d1487 1
a1487 1
    integer, pointer, dimension(:) :: MY_MASK
d1511 1
a1511 1
          if ( btest(my_mask((i-1)/b+1),mod(i-1,b)) ) &
d1526 1
a1526 1
          if ( btest(my_mask((i-1)/b+1),mod(i-1,b)) ) &
d1539 1
a1539 1
          if ( btest(my_mask((i-1)/b+1),mod(i-1,b)) ) &
d2418 3
@


2.59
log
@Use LAPACK GEMV interface for dense matrix-vector multiply
@
text
@d124 1
a124 1
       "$Id: MatrixModule_0.f90,v 2.58 2001/11/09 18:12:09 livesey Exp $"
d449 1
d458 3
a460 1
      if ( status /= 0 ) return
d706 1
a706 1
      if ( d <= tol .and. i < nc ) then
d1757 3
a1759 1
          if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1761 1
d1779 3
a1781 1
          if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1783 1
d1794 3
a1796 1
          if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1798 1
d1815 3
a1817 1
      if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1819 1
d1823 3
a1825 1
        if ( abs(d) < tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1827 1
d2426 3
@


2.58
log
@Change checkBlocks to default to false.
@
text
@d17 1
d124 1
a124 1
       "$Id: MatrixModule_0.f90,v 2.57 2001/11/09 02:03:47 vsnyder Exp $"
d1541 1
d1543 1
a1543 2
      do i = 1, size(p)
        if ( associated(my_mask) ) then
d1545 4
a1548 5
      cycle
        end if
        p(i) = p(i) + s * dot(size(v), a%values(1,i), 1, v(1), 1)
!       p(i) = p(i) + s * dot_product( a%values(:,i), v)
      end do ! i
d1550 5
d1618 5
a1622 3
!$OMP PARALLEL DO
        do i = 1, size(p)
          p(i) = p(i) + sign * dot(size(v), b%values(i,1), size(b%values,1), v(1), 1)
d1624 1
a1624 2
        end do ! i
!$OMP END PARALLEL DO
d2408 3
@


2.57
log
@Corrected procedure name in character literals in calls to allocate_test
Corrected some comments.  Put some if's around references to dot, in case
N = 0 but a subscript is out of bounds.
@
text
@d123 1
a123 1
       "$Id: MatrixModule_0.f90,v 2.56 2001/11/08 02:08:04 vsnyder Exp $"
d168 1
a168 1
  logical, save :: CHECKBLOCKS = .true.
d2402 5
@


2.56
log
@Moved interfaces for DOT to dot_external
Added OpenMP comments
Improved double-checking code for sparse algebra
@
text
@d4 2
d123 1
a123 1
       "$Id: MatrixModule_0.f90,v 2.55 2001/10/26 18:08:57 livesey Exp $"
d420 6
a425 2
          g = - dot( i-rz, zt(rz,i), 1, zt(rz,j), 1 )
!         g = - dot_product( zt(rz:i-1,i), zt(rz:i-1,j) )
d1022 1
a1022 1
        & "XB and YB Matrix sizes incompatible in Multiply_Matrix_Blocks" )
d1027 1
a1027 1
            & "ZB Matrix size incompatible in Multiply_Matrix_Blocks" )
d1059 1
a1059 1
          & "Z for banded X banded in Multiply_Matrix_Blocks", ModuleName )
d1076 1
a1076 1
          do i = 1, mz  ! Rows of Z = columns of XB
d1105 1
a1105 1
          & "Z for banded X banded in Multiply_Matrix_Blocks", ModuleName )
d1110 1
a1110 1
          & "Z for banded X sparse in Multiply_Matrix_Blocks", ModuleName )
d1153 1
a1153 1
          & "Z for banded X banded in Multiply_Matrix_Blocks", ModuleName )
d1157 1
a1157 1
            & "Z for banded X full in Multiply_Matrix_Blocks", ModuleName )
d1178 1
d1193 1
a1193 1
          & "Z for sparse X banded in Multiply_Matrix_Blocks", ModuleName )
d1236 1
a1236 1
          & "Z for banded X banded in Multiply_Matrix_Blocks", ModuleName )
d1241 1
a1241 1
          & "Z for sparse X sparse in Multiply_Matrix_Blocks", ModuleName )
d1289 1
a1289 1
          & "Z for banded X banded in Multiply_Matrix_Blocks", ModuleName )
d1293 1
a1293 1
            & "Z for sparse X full in Multiply_Matrix_Blocks", ModuleName )
d1312 1
d1324 1
a1324 1
          & "Z for full X <anything> in Multiply_Matrix_Blocks", ModuleName )
d1346 1
d1445 4
a1448 1
        zDns = zDns - matmul(transpose(xDns), yDns)
d1451 4
a1454 1
        zDns = zDns + matmul(transpose(xDns), yDns)
d1520 2
a1521 1
        m = a%r1(i)              ! starting position in V
d1622 1
a1622 1
          p(i) = p(i) + &
d1625 1
a1625 1
          p(i) = p(i) + &
d1777 1
a1777 1
        do i = 1, n
d1787 1
a1787 1
        end do ! i = 1, n
d2341 2
a2342 2
    real(r8) :: E = -1.0_r8
    integer :: I, J                         ! Subscripts, loop inductors
d2352 1
d2355 28
a2382 11
        if ( abs(bm(i,j)-m(i,j)) > 1.0e3_r8 * max(t,e*(abs(bm(i,j))+abs(m(i,j)))) ) then
          ok = .false.
          call output ( 'Matrix algebra failed', advance='yes' )
          call dump ( bm, name='L2 Result')
          call dump ( m, name='Slow result')
          call output ( 'Matrix algebra failed' )
          if (present(name)) call output ( ' for '//trim(name) )
          if (present(kinda) .or. present(kindb)) then
            call output ( ' case' )
            if (present(kindA)) call output ( ' '//kindNames(kindA) )
            if (present(kindB)) call output ( ' '//kindNames(kindB) )
a2383 10
          call output ( '', advance='yes' )
          call output ( 'First error at i = ' )
          call output ( i )
          call output ( ', j = ' )
          call output ( j )
          call output ( ' bm(i,j) = ' )
          call output ( bm(i,j) )
          call output ( ', m(i,j) = ' )
          call output ( m(i,j), advance='yes' )
    exit o
d2387 9
d2402 5
@


2.55
log
@Added upper argument to MatrixInversion
@
text
@d12 1
d14 1
d121 1
a121 1
       "$Id: MatrixModule_0.f90,v 2.54 2001/10/20 01:21:02 vsnyder Exp $"
d166 1
a166 16
  logical, save :: CHECKBLOCKS = .false.

  ! It is important to lie about the interface for the Y argument for *DOT.
  ! We pass an element of a rank-2 object to it, and assume the subsequent
  ! elements are consecutive in memory with stride INCY.  *DOT then treats
  ! this as a rank-1 stride INCY vector.
  interface DOT
    real function SDOT ( N, X, INCX, Y, INCY )
      integer, intent(in) :: N, INCX, INCY
      real, intent(in) :: X, Y
    end function SDOT
    double precision function DDOT ( N, X, INCX, Y, INCY )
      integer, intent(in) :: N, INCX, INCY
      double precision, intent(in) :: X, Y
    end function DDOT
  end interface
d323 1
a323 1
    endif
d395 1
a395 1
          endif
a399 2
!       g = x%values(ii+x%r2(i-1)+1,1) - &
!           & dot_product(zt(r1(i):i-1,i),zt(r1(i):i-1,i))
d402 2
d408 1
a408 1
          endif
d414 1
a414 1
!$OMP PARALLEL DO
a417 1
!         g = - dot_product(zt(rz:i-1,i),zt(rz:i-1,j))
d419 1
d472 1
a472 1
    endif
a693 1
!     d = xin(i,i) - dot_product(zt(1:i-1,i),zt(1:i-1,i))
d695 1
a707 1
!       zt(i,j) = ( xin(i,j) - dot_product(zt(1:i-1,i),zt(1:i-1,j)) ) / d
d709 1
d728 1
a728 1
    endif
d759 1
a759 1
    endif
d1069 1
a1069 1
!$OMP PARALLEL DO
d1090 4
a1093 3
!           xy = dot_product ( xb%values(xd:xd+c_n-1,1), &
!                          &   yb%values(yd:yd+c_n-1,1) )
            xy = dot( c_n, xb%values(xd,1), 1, yb%values(yd,1), 1 )
d1116 1
a1116 1
!$OMP PARALLEL DO
d1167 1
a1167 1
!$OMP PARALLEL DO
d1173 1
a1174 1
            xy = dot( l-k+1, xb%values(k,1), 1, yb%values(m,j), 1 )
d1198 1
a1198 1
!$OMP PARALLEL DO
d1246 1
a1246 1
!$OMP PARALLEL DO
d1298 1
a1298 1
!$OMP PARALLEL DO
d1306 1
a1307 1
            xy = dot( l-k+1, xb%values(k,1), 1, yb%values(xb%r2(k),j), 1 )
d1333 1
a1333 1
!$OMP PARALLEL DO
d1339 3
a1341 5
!           xy = dot_product( xb%values(m:m+l-k,i), yb%values(k:l,1))
            if ( l-k+1 > 0 ) then
              xy = dot( l-k+1, xb%values(m,i), 1, yb%values(k,1), 1 )
              zb%values(i,j) = zb%values(i,j) + s * xy
            endif
d1354 1
a1354 1
!$OMP PARALLEL DO
d1360 1
d1376 1
a1376 1
!$OMP PARALLEL DO
d1383 4
a1386 2
!             xy = dot_product(xb%values(1:xb%nrows,i), yb%values(1:xb%nrows,j))
              xy = dot( xb%nrows, xb%values(1,i), 1, yb%values(1,j), 1 )
d1393 1
a1393 1
!$OMP PARALLEL DO
d1395 4
a1398 2
!             xy = dot_product(xb%values(1:xb%nrows,i), yb%values(1:xb%nrows,j))
              xy = dot(xb%nrows, xb%values(1,i), 1, yb%values(1,j), 1 )
d1404 5
a1408 1
          zb%values = zb%values + s * matmul(transpose(xb%values),yb%values)
d1422 1
a1422 1
      endif
d1444 1
a1444 3
          do i = j+1, zb%nRows
            zDns(i,j) = zDns2(i,j)
          end do
d1497 1
d1505 4
a1508 7
        if ( n > 0 ) then          ! Because v1+1 will be out-of-range if
                                   ! there is a final zero-size column
          m = a%r1(i)              ! starting position in V
!         av = dot_product(a%values(v1+1:v1+n,1), v(m:m+n-1))
          av = dot(n, a%values(v1+1,1), 1, v(m), 1)
          p(i) = p(i) + s * av
        end if
d1510 1
d1524 1
d1530 2
a1531 2
        av = dot(size(v), a%values(1,i), 1, v(1), 1)
        p(i) = p(i) + s * av
d1533 1
d1597 1
d1599 2
a1600 2
!           p(i) = p(i) + dot(size(v), b%values(i,1), size(b%values,1), v(1), 1)
          p(i) = p(i) + sign * dot_product ( b%values(i,:), v )
d1602 1
d1604 1
d1606 6
a1611 5
!           p(i) = p(i) + dot(i-1, b%values(i,1), size(b%values,1), v(1), 1)
!           p(i) = p(i) + &
!             & dot(size(v)-i, b%values(i,i+1), size(b%values,1), v(i+1), 1)
          p(i) = p(i) + sign * dot_product ( b%values(i, 1:i-1), v(1:i-1) ) + &
            & sign * dot_product ( b%values( i, i+1:), v(i+1:) )
d1613 1
d1734 1
a1735 3
!           xs(i,j) = ( xs(i,j) - &
!                   &   dot_product(u%values(u%r2(i-1)+1:u%r2(i)-1,1), &
!                   &               xs(u%r1(i):i-1,j) ) ) / d
d1738 4
a1741 1
                    &               xs(u%r1(i),j), 1 ) ) / d
d1743 1
a1765 2
!           xs(i,j) = ( xs(i,j) - &
!                   &   dot_product(u%values(1:i-1,i),xs(1:i-1,j) ) ) / d
d1768 2
d1788 1
a1789 2
!         xs(i,j) = ( xs(i,j) - &
!                 &   dot_product(ud(i,i+1:n),xs(i+1:n,j) ) ) / d
d1792 1
d1794 1
a1847 2
          ! dot_product( u%values(u%r2(i-1)+1:u%r2(i)-1,1), &
          ! &            b(u%r1(i):u%r1(i)+u%r2(i)-u%r2(i-1)-1) )
d1849 5
a1853 1
            &      u%values(u%r2(i-1)+1,1), 1, my_b(u%r1(i)), 1) ) / d
a1872 1
          ! dot_product( u%values(1:i-1,i), my_b(1:i-1) )
d1874 1
d1893 2
a1894 2
        ! dot_product( ud(i,i+1:n), my_b(i+1:n) )
        x(i) = ( my_b(i) - dot(n-i, ud(i,i+1), size(ud,1), x(i+1), 1) ) / d
d1930 5
a1934 1
        do i = 1, n
d1939 1
d1951 1
d1990 4
a1993 4
      do i1 = 1, size(z,1)
        zt(j) = max(zt(j),abs(z(i1,j)))
      end do ! i1
      zt(j) = max(sq_eps*zt(j), sqrt(tiny(1.0_r8)))
d1996 1
a1996 1
        if ( abs(z(i1,j)) >= zt(j) ) nnzc(j) = nnzc(j) + 1
d2325 3
a2327 1
    character(len=132) :: LINE          ! Error message
d2330 1
d2335 29
a2363 15
    
    if (any( abs(bm-m) > 1e3*max(tiny(m(1,1)), epsilon(m(1,1))*(abs(bm+m))) )) then
      ok = .false.
      call output ( 'Matrix algebra failed', advance='yes' )
      call dump ( bm, name='L2 Result')
      call dump ( m, name='Slow result')
      call output ( 'Matrix algebra failed' )
      if (present(name)) call output ( ' for '//trim(name) )
      if (present(kinda) .or. present(kindb)) then
        call output ( 'case' )
        if (present(kindA)) call output ( ' '//kindNames(kindA) )
        if (present(kindB)) call output ( ' '//kindNames(kindB) )
      endif
      call output ( '', advance='yes' )
    endif
d2369 3
@


2.54
log
@Inserted OpenMP comments in MultiplyMatrixBlocks_0, CholeskyFactor_0 and DenseCholesky
@
text
@d119 1
a119 1
       "$Id: MatrixModule_0.f90,v 2.53 2001/10/16 19:28:31 vsnyder Exp $"
d893 1
a893 1
  subroutine MatrixInversion(A)
d896 2
d902 2
d905 2
a906 2
  integer :: i, n
  
d913 3
a915 2
   call DenseCholesky (U, A)

d917 9
a925 8
   b = 0._r8
   b(i)=1._r8
   TRANSPOSE1 = .true.  
   call SolveCholeskyA_0 ( U, x, b, TRANSPOSE1 )
   b = x
   TRANSPOSE1 = .false.  
   call SolveCholeskyA_0 ( U, x, b, TRANSPOSE1 )
   A(:,i) = x
d2342 3
@


2.53
log
@Repair comment about 'details' argument of 'Dump_Matrix_Block'
@
text
@d119 1
a119 1
       "$Id: MatrixModule_0.f90,v 2.52 2001/10/04 23:49:57 livesey Exp $"
d427 1
d438 1
d719 1
d724 1
d1050 2
a1051 2
      endif
    endif
d1076 1
d1102 1
d1122 1
d1150 1
d1173 1
d1183 1
d1204 1
d1232 1
d1252 1
d1285 1
d1304 1
d1316 1
d1339 1
d1351 1
d1362 1
d1371 1
d1383 1
d1394 1
d1398 1
d1403 3
a1405 2
            end do
          end do
d1426 2
a1427 2
        enddo
      endif
d1432 2
a1433 2
        enddo
      endif
d1439 1
a1439 1
      endif
d1447 1
a1447 1
      endif
d1458 2
a1459 2
      endif
    endif
d2336 3
@


2.52
log
@Added checking code, and temporarily suppressed sparse
@
text
@d119 1
a119 1
       "$Id: MatrixModule_0.f90,v 2.51 2001/10/03 17:33:11 dwu Exp $"
d2220 3
a2222 1
    integer, intent(in), optional :: DETAILS   ! Print details, default true
d2312 3
@


2.51
log
@modified MatrixInversion
@
text
@d19 1
a19 1
  public :: Add_Matrix_Blocks, Assignment(=), CholeskyFactor
d119 1
a119 1
       "$Id: MatrixModule_0.f90,v 2.50 2001/10/01 23:35:38 vsnyder Exp $"
d158 1
a158 1
  real, parameter, private :: COL_SPARSITY = 0.5  ! If more than this
d164 1
d197 2
d322 15
d357 1
a357 1
  subroutine CholeskyFactor_0 ( Z, XOPT )
d363 1
d380 2
d405 4
d418 4
d460 2
a461 1
      call denseCholesky ( zt, xin )
d468 1
a468 1
      call denseCholesky ( z%values, x%values )
d470 14
d733 2
a734 1
    if ( size(z,1) /= b%nRows .or. size(z,2) /= b%nCols ) &
d737 1
d994 5
d1002 1
d1011 1
d1016 1
d1033 16
d1245 1
d1248 1
d1250 1
a1250 1
            z(i,j) = 0.0_r8
d1329 4
a1332 2
            xy = dot( l-k+1, xb%values(m,i), 1, yb%values(k,1), 1 )
            zb%values(i,j) = zb%values(i,j) + s * xy
d1387 49
d2266 41
d2310 3
@


2.50
log
@Correct blunder in ClearRows_0
@
text
@d119 1
a119 1
       "$Id: MatrixModule_0.f90,v 2.49 2001/10/01 20:32:27 vsnyder Exp $"
d843 1
a843 1
  subroutine MatrixInversion(Ain, Aout)
d845 1
a845 2
  real (r8), dimension(:,:) :: Ain
  real (r8), dimension(:,:) :: Aout
d853 1
a853 1
  n = size(Ain,2)
d859 1
a859 1
   call DenseCholesky (U, Ain)
d869 1
a869 1
   Aout(:,i) = x
d2146 3
@


2.49
log
@Handle word and bit indexing in mask consistently
@
text
@d119 1
a119 1
       "$Id: MatrixModule_0.f90,v 2.48 2001/09/29 00:25:51 vsnyder Exp $"
a467 2
        i = i + 1
        if ( i > x%nrows ) return
d469 2
d2147 3
@


2.48
log
@Correct word indexing for mask operations
@
text
@d119 1
a119 1
       "$Id: MatrixModule_0.f90,v 2.47 2001/09/28 17:56:10 dwu Exp $"
d1354 1
a1354 1
          if ( btest(my_mask(i/b+1),mod(i,b)) ) &
d1370 1
a1370 1
          if ( btest(my_mask(i/b+1),mod(i,b)) ) &
d1382 1
a1382 1
          if ( btest(my_mask(i/b+1),mod(i,b)) ) &
d2147 3
@


2.47
log
@add MatrixInversion, SolveCholeskyA_0
@
text
@d119 1
a119 1
       "$Id: MatrixModule_0.f90,v 2.46 2001/09/27 18:41:21 vsnyder Exp $"
d454 1
a454 1
          if ( btest( mask(i/b+1), mod(i,b) ) ) &
d461 1
a461 1
          if ( btest( mask(x%r2(i)/b+1), mod(x%r2(i),b) ) ) &
d995 1
a995 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1006 1
a1006 1
              if ( btest(xm(i/b+1),mod(i,b)) ) cycle
d1043 1
a1043 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1049 1
a1049 1
              if ( btest(xm(i/b+1),mod(i,b)) ) cycle
d1088 1
a1088 1
            if ( btest(xm(i/b+1),mod(i,b)) ) cycle
d1098 1
a1098 1
              if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1121 1
a1121 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1127 1
a1127 1
              if ( btest(xm(i/b+1),mod(i,b)) ) cycle
d1167 1
a1167 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1173 1
a1173 1
              if ( btest(xm(i/b+1),mod(i,b)) ) cycle
d1215 1
a1215 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1221 1
a1221 1
              if ( btest(xm(i/b+1),mod(i,b)) ) cycle
d1245 1
a1245 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1254 1
a1254 1
              if ( btest(xm(i/b+1),mod(i,b)) ) cycle
d1265 1
a1265 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1273 1
a1273 1
              if ( btest(xm(i/b+1),mod(i,b)) ) cycle
d1284 1
a1284 1
              if ( btest(ym(j/b+1),mod(j,b)) ) then
d1292 1
a1292 1
                if ( btest(xm(i/b+1),mod(i,b)) ) then
d2147 3
@


2.46
log
@Apply mask in matrix-vector multiply
@
text
@d26 1
d110 1
a110 1
    module procedure SolveCholeskyM_0, SolveCholeskyV_0
d119 1
a119 1
       "$Id: MatrixModule_0.f90,v 2.45 2001/09/24 23:01:11 vsnyder Exp $"
d842 38
d1745 49
d2147 3
@


2.45
log
@Make consistent/correct lower bound calculation for MASK array
@
text
@d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.44 2001/07/19 17:54:59 vsnyder Exp $"
d156 1
a156 2
  integer, parameter, private :: B_sizer = 0
  integer, parameter, private :: B = bit_size(b_sizer) ! can't use "bit_size(b)"
d1245 3
a1247 1
              if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1253 3
a1255 1
                if ( btest(xm(i/b+1),mod(i,b)) ) cycle
d1278 6
a1283 5
  subroutine MultiplyMatrixVector_0 ( B, V, P, UPDATE, SUBTRACT )
  ! P = B^T V if UPDATE is absent or false.
  ! P = P + B^T V if UPDATE is present and true and SUBTRACT is absent or false.
  ! P = P - B^T V if UPDATE is present and true and SUBTRACT is present and true.
    type(MatrixElement_T), intent(in) :: B
d1288 1
d1290 1
a1290 1
    real(r8) :: BV                 ! Product of a column of B and the vector V
d1292 1
d1297 1
a1297 1
    if ( b%nrows /= size(v) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1299 1
a1299 1
    if ( b%ncols /= size(p) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1305 2
d1310 1
a1310 1
    select case ( b%kind )
d1314 6
a1319 2
        v1 = b%r2(i-1)             ! starting position in B%VALUES - 1
        n = b%r2(i) - v1           ! how many values
d1322 4
a1325 4
          m = b%r1(i)              ! starting position in V
!         bv = dot_product(b%values(v1+1:v1+n,1), v(m:m+n-1))
          bv = dot(n, b%values(v1+1,1), 1, v(m), 1)
          p(i) = p(i) + s * bv
d1330 7
a1336 3
        bv = 0.0_r8
        do n = b%r1(i-1)+1, b%r1(i)
          bv = bv + b%values(n,1) * v(b%r2(n))
d1338 1
a1338 1
        p(i) = p(i) + s * bv
d1342 6
a1347 2
        bv = dot(size(v), b%values(1,i), 1, v(1), 1)
        p(i) = p(i) + s * bv
d2059 3
@


2.44
log
@Correct blunders in banded matrix*matrix and matrix*vector.
Handle "subtract" argument differently.
@
text
@d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.43 2001/07/16 20:36:49 livesey Exp $"
d446 1
a446 1
    integer, dimension(0:), intent(in) :: MASK
d454 1
a454 1
          if ( btest( mask(i/b), mod(i,b) ) ) &
d461 1
a461 1
          if ( btest( mask(x%r2(i)/b), mod(x%r2(i),b) ) ) &
d2039 4
@


2.43
log
@Added fix for empty columns in banded MatrixVector multiply
@
text
@d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.42 2001/07/11 22:07:57 vsnyder Exp $"
a373 10
    case ( M_Column_Sparse )
      call allocate_test ( zt, nc, nc, "ZT for CholeskyFactor", ModuleName )
      call allocate_test ( xin, nc, nc, "XIN for CholeskyFactor", ModuleName )
      ! ??? Densify and then compute Cholesky decomposition of dense block.
      ! ??? If necessary, improve this in level 1.0 by working directly
      ! ??? with sparse input.
      call densify ( xin, x )
      call denseCholesky ( zt, xin )
      call sparsify ( zt, z, "ZT in CholeskyFactor", ModuleName ) ! Z := Zt
      call deallocate_test ( xin, "XIN in CholeskyFactor", ModuleName )
d424 10
d904 2
a906 1
    logical :: MY_SUB, MY_UPD, MY_UPPER
d908 1
d916 2
d973 1
a973 1
            xr_n = xr_1 + xi_n - yi_n   ! last row index of xb
d981 8
a988 17
            ! Now modify xi_1 and yi_1 to point to the start of the common part
            xd = cr_1 - xr_1
            yd = cr_1 - yr_1

            if ( .not. my_sub ) then
!             z(i,j) = z(i,j) + &
!                      & dot_product ( xb%values(xi_1+xd:xi_1+xd+c_n-1,1), &
!                      &   yb%values(yi_1+yd:yi_1+yd+c_n-1,1) )
              z(i,j) = z(i,j) + &
                       & dot( c_n, xb%values(xi_1+xd,1), 1, yb%values(yi_1+yd,1), 1 )
            else
!             z(i,j) = z(i,j) - &
!                      & dot_product ( xb%values(xi_1:xi_1+c_n-1,1), &
!                      &   yb%values(yi_1:yi_1+c_n-1,1) )
              z(i,j) = z(i,j) - &
                       & dot( c_n, xb%values(xi_1,1), 1, yb%values(yi_1,1), 1 )
            end if
d1026 2
a1027 5
                if ( .not. my_sub ) then
                  z(i,j) = z(i,j) + xb%values(l,1) * yb%values(n,1)
                else
                  z(i,j) = z(i,j) - xb%values(l,1) * yb%values(n,1)
                end if
d1063 3
a1065 11
            if ( .not. my_sub ) then
!             zb%values(i,j) = zb%values(i,j) + dot_product( &
!               & xb%values(k:l,1), yb%values(m:m+l-k,j) )
              zb%values(i,j) = zb%values(i,j) + dot( l-k+1, &
                & xb%values(k,1), 1, yb%values(m,j), 1 )
            else
!             zb%values(i,j) = zb%values(i,j) - dot_product( &
!               & xb%values(k:l,1), yb%values(m:m+l-k,j) )
              zb%values(i,j) = zb%values(i,j) - dot( l-k+1, &
                & xb%values(k,1), 1, yb%values(m,j), 1 )
            end if
d1104 2
a1105 5
                if ( .not. my_sub ) then
                  z(i,j) = z(i,j) + xb%values(l,1) * yb%values(n,1)
                else
                  z(i,j) = z(i,j) - xb%values(l,1) * yb%values(n,1)
                end if
d1152 2
a1153 5
                if ( .not. my_sub ) then
                  z(i,j) = z(i,j) + xb%values(l,1) * yb%values(n,1)
                else
                  z(i,j) = z(i,j) - xb%values(l,1) * yb%values(n,1)
                end if
d1188 3
a1190 11
            if ( .not. my_sub ) then
!             zb%values(i,j) = zb%values(i,j) + dot_product( &
!               & xb%values(k:l,1), yb%values(xb%r2(k:l),j) )
              zb%values(i,j) = zb%values(i,j) + dot( l-k+1, &
                & xb%values(k,1), 1, yb%values(xb%r2(k),j), 1 )
            else
!             zb%values(i,j) = zb%values(i,j) - dot_product( &
!               & xb%values(k:l,1), yb%values(xb%r2(k:l),j) )
              zb%values(i,j) = zb%values(i,j) - dot( l-k+1, &
                & xb%values(k,1), 1, yb%values(xb%r2(k),j), 1 )
            end if
d1219 3
a1221 11
            if ( .not. my_sub ) then
!             zb%values(i,j) = zb%values(i,j) + dot_product( &
!               & xb%values(m:m+l-k,i), yb%values(k:l,1))
              zb%values(i,j) = zb%values(i,j) + dot( l-k+1, &
                & xb%values(m,i), 1, yb%values(k,1), 1 )
            else
!             zb%values(i,j) = zb%values(i,j) - dot_product( &
!               & xb%values(m:m+l-k,i), yb%values(k:l,1))
              zb%values(i,j) = zb%values(i,j) - dot( l-k+1, &
                & xb%values(m,i), 1, yb%values(k,1), 1 )
            end if
d1238 2
a1239 7
            if ( .not. my_sub ) then
              zb%values(i,j) = zb%values(i,j) + dot_product( &
                & xb%values(yb%r2(k:l),i), yb%values(k:l,1) )
            else
              zb%values(i,j) = zb%values(i,j) - dot_product( &
                & xb%values(yb%r2(k:l),i), yb%values(k:l,1) )
            end if
d1254 3
a1256 7
              if ( .not. my_sub ) then
                zb%values(i,j) = zb%values(i,j) + dot( xb%nrows, &
                                 & xb%values(1,i), 1, yb%values(1,j), 1 )
              else
                zb%values(i,j) = zb%values(i,j) - dot( xb%nrows, &
                                 & xb%values(1,i), 1, yb%values(1,j), 1 )
              end if
d1262 3
a1264 7
              if ( .not. my_sub ) then
                zb%values(i,j) = zb%values(i,j) + dot(xb%nrows, &
                                 & xb%values(1,i), 1, yb%values(1,j), 1 )
              else
                zb%values(i,j) = zb%values(i,j) - dot( xb%nrows, &
                                 & xb%values(1,i), 1, yb%values(1,j), 1 )
              end if
d1268 1
a1268 5
          if ( .not. my_sub ) then
            zb%values = zb%values + matmul(transpose(xb%values),yb%values)
          else
            zb%values = zb%values - matmul(transpose(xb%values),yb%values)
          end if
d1285 1
d1288 1
a1288 1
    real(r8) :: SUM                ! Dot product in the column-sparse case
d1299 2
d1308 6
a1313 6
        m = b%r1(i)                ! starting position in V
        if (n == 0) cycle
        if ( my_sub ) then
          p(i) = p(i) - dot(n, b%values(v1+1,1), 1, v(m), 1)
        else
          p(i) = p(i) + dot(n, b%values(v1+1,1), 1, v(m), 1)
d1318 1
a1318 1
        sum = 0.0_r8
d1320 1
a1320 1
          sum = sum + b%values(n,1) * v(b%r2(n))
d1322 1
a1322 5
        if ( my_sub ) then
          p(i) = p(i) - sum
        else
          p(i) = p(i) + sum
        end if
d1326 2
a1327 5
        if ( my_sub ) then
          p(i) = p(i) - dot(size(v), b%values(1,i), 1, v(1), 1)
        else
          p(i) = p(i) + dot(size(v), b%values(1,i), 1, v(1), 1)
        end if
d1637 1
a1637 1
          x(i) = ( my_b(i) - dot(u%r2(i)-u%r2(i-1), &
d2039 3
@


2.42
log
@Interim commit -- may still be broken
@
text
@d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.41 2001/06/28 01:05:59 vsnyder Exp $"
d1361 1
d2098 3
@


2.41
log
@Allow last diagonal element in Cholesky factor to be tiny
@
text
@d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.40 2001/06/27 01:15:10 vsnyder Exp $"
d1717 1
a1717 1
          x(i) = ( my_b(i) - dot(i-1, u%values(1,i), 1, my_b(1), 1) ) / d
d1737 1
a1737 1
        x(i) = ( my_b(i) - dot(n-i, ud(i,i+1), size(ud,1), my_b(i+1), 1) ) / d
d2097 3
@


2.40
log
@XMASK and YMASK arguments of MultiplyMatrixBlocks need to be pointers
because they might not be associated in the caller.  Therefore they
cannot have specified lower bounds.  Therefore we need to use i/b+1
(j/b+1) for subscripts of xm (ym).
@
text
@d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.39 2001/06/26 23:56:04 vsnyder Exp $"
d231 1
a231 1
        zb%values = 0.0_r8 ! ??? Improve this in level 1.0 by only filling
d402 1
a402 1
        if ( g <= tol ) then
d647 1
a647 1
  subroutine DenseCholesky ( zt, xin, status )
d663 1
a663 1
      if ( d <= tol ) then
d669 1
a669 1
          & "Matrix in CholeskyFactor is not positive-definite." )
d1063 1
d1408 1
a1408 1
      & "Matrix block and vector not compatible in MultiplyMatrixVector_0" )
d1410 1
a1410 1
      & "Matrix block and result not compatible in MultiplyMatrixVector_0" )
d2097 6
@


2.39
log
@Make [XY]MASK 'target' instead of 'pointer' so they can have lower bound
@
text
@d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.38 2001/06/26 20:40:33 vsnyder Exp $"
d893 1
a893 1
    integer, optional, target, intent(in), dimension(0:) :: XMASK, YMASK
d953 1
a953 1
            if ( btest(ym(j/b),mod(j,b)) ) cycle
d964 1
a964 1
              if ( btest(xm(i/b),mod(i,b)) ) cycle
d1010 1
a1010 1
            if ( btest(ym(j/b),mod(j,b)) ) cycle
d1016 1
a1016 1
              if ( btest(xm(i/b),mod(i,b)) ) cycle
d1058 1
a1058 1
            if ( btest(xm(i/b),mod(i,b)) ) cycle
d1067 1
a1067 1
              if ( btest(ym(j/b),mod(j,b)) ) cycle
d1098 1
a1098 1
            if ( btest(ym(j/b),mod(j,b)) ) cycle
d1104 1
a1104 1
              if ( btest(xm(i/b),mod(i,b)) ) cycle
d1147 1
a1147 1
            if ( btest(ym(j/b),mod(j,b)) ) cycle
d1153 1
a1153 1
              if ( btest(xm(i/b),mod(i,b)) ) cycle
d1198 1
a1198 1
            if ( btest(ym(j/b),mod(j,b)) ) cycle
d1204 1
a1204 1
              if ( btest(xm(i/b),mod(i,b)) ) cycle
d1236 1
a1236 1
            if ( btest(ym(j/b),mod(j,b)) ) cycle
d1245 1
a1245 1
              if ( btest(xm(i/b),mod(i,b)) ) cycle
d1264 1
a1264 1
            if ( btest(ym(j/b),mod(j,b)) ) cycle
d1272 1
a1272 1
              if ( btest(xm(i/b),mod(i,b)) ) cycle
d1288 1
a1288 1
              if ( btest(ym(j/b),mod(j,b)) ) cycle
d1294 1
a1294 1
                if ( btest(xm(i/b),mod(i,b)) ) cycle
d2096 3
@


2.38
log
@Simplify by using zero for lower bound for first dimension of mask
@
text
@d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.37 2001/06/04 22:41:37 livesey Exp $"
d893 1
a893 1
    integer, optional, pointer, dimension(0:) :: XMASK, YMASK ! Intent(in)
d2096 3
@


2.37
log
@Various bug fixes associated with m_banded.  Some still remain to be
solved though
@
text
@d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.36 2001/06/01 01:03:39 vsnyder Exp $"
d893 1
a893 1
    integer, optional, pointer, dimension(:) :: XMASK, YMASK ! Intent(in)
d902 1
a902 1
    integer :: I, J, K, L, M, MZ, N, P, R
d1010 1
a1010 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1067 1
a1067 1
              if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1098 1
a1098 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1147 1
a1147 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1198 1
a1198 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1236 1
a1236 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1264 1
a1264 1
            if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d1288 1
a1288 1
              if ( btest(ym(j/b+1),mod(j,b)) ) cycle
d2096 4
@


2.36
log
@Add 'sqrt' option to 'GetDiagonal_0'; add 'Multiply' generic
@
text
@d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.35 2001/05/30 21:53:16 vsnyder Exp $"
d903 2
d955 4
a958 4
          p = yb%r2(j-1)+1
          k = yb%r1(j)        ! k,l = row indices of YB
          l = k+yb%r2(j)-p
          p = p-k
d966 15
a980 4
            m = xb%r1(i)
            r = xb%r2(i-1)+1-m
            m = max(k,m)      ! m,n = row indices of intersection of XB and YB
            n = min(l,xb%r2(i)-r)
d983 2
a984 1
!                      & dot_product ( xb%values(r+m:r+n,1), yb%values(p+m:p+n,1) )
d986 1
a986 1
                       & dot( n-m+1, xb%values(r+m,1), 1, yb%values(p+m,1), 1 )
d989 2
a990 1
!                      & dot_product ( xb%values(r+m:r+n,1), yb%values(p+m:p+n,1) )
d992 1
a992 1
                       & dot( n-m+1, xb%values(r+m,1), 1, yb%values(p+m,1), 1 )
d1930 1
d1945 1
d1950 5
a1954 4
      call createBlock ( a, nRows, nCols, m_banded, n )
      do i = 1, n
        a%r1(i) = i
        a%r2(i) = i
d1958 3
a1960 1
          a%values(i,1) = s / x(i)
d1962 1
a1962 1
          a%values(i,1) = s * x(i)
d2096 3
@


2.35
log
@Finish? 'invert' argument in 'UpdateDiagonalVec_0'
@
text
@d27 6
a32 5
  public :: MultiplyMatrixBlocks, MultiplyMatrixVector, MultiplyMatrixVector_0
  public :: MultiplyMatrixVectorNoT, MultiplyMatrixVectorNoT_0, operator(+)
  public :: operator(.TX.), RowScale, RowScale_0, ScaleBlock, SolveCholesky
  public :: SolveCholeskyM_0, SolveCholeskyV_0, Sparsify, UpdateDiagonal
  public :: UpdateDiagonal_0, UpdateDiagonalVec_0
d84 4
d118 1
a118 1
       "$Id: MatrixModule_0.f90,v 2.34 2001/05/30 20:18:01 vsnyder Exp $"
d726 3
a728 2
  subroutine GetDiagonal_0 ( B, X )
  ! Get the diagonal elements of B into X
d731 1
d763 9
d2076 3
@


2.34
log
@Add 'invert' argument to 'UpdateDiagonal'
@
text
@d113 1
a113 1
       "$Id: MatrixModule_0.f90,v 2.33 2001/05/24 23:15:24 vsnyder Exp $"
d1921 7
a1927 1
        a%values(i,1) = s*x(i)
d2060 3
@


2.33
log
@Don't scale absent blocks -- their VALUES pointer isn't associated
@
text
@d113 1
a113 1
       "$Id: MatrixModule_0.f90,v 2.32 2001/05/24 18:13:28 vsnyder Exp $"
d1887 1
a1887 1
  subroutine UpdateDiagonalVec_0 ( A, X, SUBTRACT )
d1890 1
d1894 1
d1897 1
d1902 2
d1910 2
d1935 7
d1943 1
a1943 1
          & a%values(a%r2(i-1)+i-a%r1(i)+1,1) + s*x(i)
d1949 8
a1956 1
            a%values(j,1) = a%values(j,1) + s*x(i)
d1963 2
a1964 2
            call sparsify ( t, a, "T in UpdateDiagonal_0", ModuleName ) ! A := T
            call deallocate_test ( t, "T in UpdateDiagonal_0", ModuleName )
d1981 8
a1988 1
        t(i,i) = t(i,i) + s*x(i)
d2054 3
@


2.32
log
@Make DenseCholesky public instead of internal; cosmetic changes
@
text
@d113 1
a113 1
       "$Id: MatrixModule_0.f90,v 2.31 2001/05/22 19:09:13 vsnyder Exp $"
d1497 1
a1497 1
    z%values = a * z%values
d2026 3
@


2.31
log
@Implement Col_L1
@
text
@d22 1
a22 1
  public :: Densify, DestroyBlock, DestroyBlock_0, Dump
d113 1
a113 1
       "$Id: MatrixModule_0.f90,v 2.30 2001/05/19 00:13:43 vsnyder Exp $"
d349 1
d357 1
d397 1
a397 1
        if ( g <= sqrt(tiny(0.0_r8)) ) then
a434 21

  contains
    subroutine DenseCholesky ( zt, xin )
    ! Do the Cholesky decomposition of XIN giving ZT.
      real(r8) :: ZT(:,:), XIN(:,:)
      real(r8), save :: TOL = -1.0_r8
      if ( tol < 0.0_r8 ) tol = sqrt(tiny(0.0_r8))
      do i = 1, nc
        zt(i+1:nc,i) = 0.0_r8 ! Clear below the diagonal (helps Sparsify!)
!       g = xin(i,i) - dot_product(zt(1:i-1,i),zt(1:i-1,i))
        g = xin(i,i) - dot( i-1, zt(1,i), 1, zt(1,i), 1 )
        if ( g <= tol ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Matrix in CholeskyFactor is not positive-definite." )
        d = sqrt(g)
        zt(i,i) = d
        do j = i+1, nc
!         zt(i,j) = ( xin(i,j) - dot_product(zt(1:i-1,i),zt(1:i-1,j)) ) / d
          zt(i,j) = ( xin(i,j) - dot( i-1, zt(1,i), 1, zt(1,j), 1 ) ) / d
        end do ! j
      end do ! i
    end subroutine DenseCholesky
d641 35
d769 1
a769 1
        &  row > matrix%r1(col) + matrix%r2(col)-matrix%r2(col-1) ) then
d1518 1
d1548 1
a1548 2
          if ( abs(d) < tiny(0.0_r8) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1565 1
a1565 2
          if ( abs(d) < tiny(0.0_r8) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1577 1
a1577 2
          if ( abs(d) < tiny(0.0_r8) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1595 1
a1595 2
      if ( abs(d) < tiny(0.0_r8) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1600 1
a1600 2
        if ( abs(d) < tiny(0.0_r8) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1635 1
d1659 1
a1659 2
          if ( abs(d) < tiny(0.0_r8) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1672 1
a1672 2
          if ( abs(d) < tiny(0.0_r8) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1682 1
a1682 2
          if ( abs(d) < tiny(0.0_r8) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1697 1
a1697 2
      if ( abs(d) < tiny(0.0_r8) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1702 1
a1702 2
        if ( abs(d) < tiny(0.0_r8) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
d2026 3
@


2.30
log
@Correct SolveCholesky*_0
@
text
@d21 3
a23 2
  public :: ColumnScale_0, CopyBlock, CreateBlock, CreateBlock_0, Densify
  public :: DestroyBlock, DestroyBlock_0, Dump, GetDiagonal, GetDiagonal_0
d113 1
a113 1
       "$Id: MatrixModule_0.f90,v 2.29 2001/05/17 20:17:56 vsnyder Exp $"
d550 24
d2018 3
@


2.29
log
@Implement GetMatrixElement.  Change handling of mask in MultiplyMatrixBlocks.
@
text
@d112 1
a112 1
       "$Id: MatrixModule_0.f90,v 2.28 2001/05/12 01:05:23 vsnyder Exp $"
d1555 6
a1560 1
      do i = n, 1, -1
d1626 2
a1627 2
          x(i) = my_b(i) - dot(u%r2(i)-u%r2(i-1), &
            &                  u%values(u%r2(i-1)+1,1), 1, my_b(u%r1(i)), 1) / d
d1650 1
a1650 1
          x(i) = my_b(i) - dot(i-1, u%values(1,i), 1, my_b(1), 1) / d
d1661 6
a1666 1
      do i = n, 1, -1
d1672 1
a1672 1
        x(i) = my_b(i) - dot(n-i, ud(i,i+1), size(ud,1), my_b(i+1), 1) / d
d1993 3
@


2.28
log
@Change 'details' argumet of 'dump_matrix_block' to integer
@
text
@d19 12
a30 12
  public :: Add_Matrix_Blocks, Assignment(=), CholeskyFactor, &
    & CholeskyFactor_0, ClearRows, ClearRows_0, CloneBlock, ColumnScale, &
    & ColumnScale_0, CopyBlock, CreateBlock, CreateBlock_0, Densify, &
    & DestroyBlock, DestroyBlock_0, Dump, GetDiagonal, GetDiagonal_0, &
    & GetVectorFromColumn, GetVectorFromColumn_0,  M_Absent, M_Banded, &
    & M_Column_Sparse, M_Full, MatrixElement_T, MaxAbsVal, MaxAbsVal_0, &
    & MinDiag, MinDiag_0, MultiplyMatrixBlocks, MultiplyMatrixVector, &
    & MultiplyMatrixVector_0, MultiplyMatrixVectorNoT, &
    & MultiplyMatrixVectorNoT_0, operator(+), operator(.TX.), RowScale, &
    & RowScale_0, ScaleBlock, SolveCholesky, SolveCholeskyM_0, &
    & SolveCholeskyV_0, Sparsify, UpdateDiagonal, UpdateDiagonal_0, &
    & UpdateDiagonalVec_0
d66 4
d112 1
a112 1
       "$Id: MatrixModule_0.f90,v 2.27 2001/05/11 22:02:06 vsnyder Exp $"
d717 30
d820 2
a821 1
  subroutine MultiplyMatrixBlocks ( XB, YB, ZB, UPDATE, SUBTRACT, XMASK, YMASK )
d829 3
a831 2
  ! If XMASK (resp. YMASK) is present, ignore columns of XB (resp. YB)
  ! that correspond to nonzero bits of XMASK (resp. YMASK).
d836 2
a837 1
    integer, intent(in), optional, dimension(0:) :: XMASK, YMASK
d845 3
a847 2
    integer :: I, J, K, L, M, N, P, R
    logical :: MY_SUB, MY_UPD
d850 3
a852 1
    nullify ( z )
d855 4
a858 2
    my_upd = .false.
    if ( present(update) ) my_upd = update
d893 2
a894 2
          if ( present(ymask) ) then
            if ( btest(ymask(j/b),mod(j,b)) ) cycle
d900 3
a902 1
          do i = 1, zb%nrows  ! Rows of Z = columns of XB
d904 2
a905 2
            if ( present(xmask) ) then
              if ( btest(xmask(i/b),mod(i,b)) ) cycle
d936 3
a938 3
        do j = 1, yb%ncols    ! Columns of Z
          if ( present(ymask) ) then
            if ( btest(ymask(j/b+1),mod(j,b)) ) cycle
d940 5
a944 3
          do i = 1, xb%ncols  ! Rows of Z
            if ( present(xmask) ) then
              if ( btest(xmask(i/b),mod(i,b)) ) cycle
d985 2
a986 2
          if ( present(xmask) ) then
            if ( btest(xmask(i/b),mod(i,b)) ) cycle
d991 5
a995 3
          do j = 1, yb%ncols  ! Columns of ZB
            if ( present(ymask) ) then
              if ( btest(ymask(j/b+1),mod(j,b)) ) cycle
d1024 3
a1026 3
        do j = 1, yb%ncols    ! Columns of Z
          if ( present(ymask) ) then
            if ( btest(ymask(j/b+1),mod(j,b)) ) cycle
d1028 5
a1032 3
          do i = 1, xb%ncols  ! Rows of Z
            if ( present(xmask) ) then
              if ( btest(xmask(i/b),mod(i,b)) ) cycle
d1073 3
a1075 3
        do j = 1, yb%ncols    ! Columns of Z
          if ( present(ymask) ) then
            if ( btest(ymask(j/b+1),mod(j,b)) ) cycle
d1077 5
a1081 3
          do i = 1, xb%ncols  ! Rows of Z
            if ( present(xmask) ) then
              if ( btest(xmask(i/b),mod(i,b)) ) cycle
d1124 3
a1126 3
        do j = 1, yb%ncols    ! Columns of ZB
          if ( present(ymask) ) then
            if ( btest(ymask(j/b+1),mod(j,b)) ) cycle
d1128 5
a1132 3
          do i = 1, xb%ncols  ! Rows of ZB
            if ( present(xmask) ) then
              if ( btest(xmask(i/b),mod(i,b)) ) cycle
d1162 3
a1164 3
        do j = 1, yb%ncols    ! Columns of ZB
          if ( present(ymask) ) then
            if ( btest(ymask(j/b+1),mod(j,b)) ) cycle
d1169 5
a1173 3
          do i = 1, xb%ncols  ! Rows of ZB
            if ( present(xmask) ) then
              if ( btest(xmask(i/b),mod(i,b)) ) cycle
d1190 3
a1192 3
        do j = 1, yb%ncols    ! Columns of ZB
          if ( present(ymask) ) then
            if ( btest(ymask(j/b+1),mod(j,b)) ) cycle
d1196 5
a1200 3
          do i = 1, xb%ncols  ! Rows of ZB
            if ( present(xmask) ) then
              if ( btest(xmask(i/b),mod(i,b)) ) cycle
d1213 10
a1222 8
        if ( present(xmask) .or. present(ymask) ) then
          do j = 1, yb%ncols    ! Columns of ZB
          if ( present(ymask) ) then
            if ( btest(ymask(j/b+1),mod(j,b)) ) cycle
          end if
            do i = 1, xb%ncols  ! Rows of ZB
              if ( present(xmask) ) then
                if ( btest(xmask(i/b),mod(i,b)) ) cycle
d1233 12
d1983 3
@


2.27
log
@Correct errors in SolveCholeskyV_0
@
text
@d108 1
a108 1
       "$Id: MatrixModule_0.f90,v 2.26 2001/05/10 22:53:36 vsnyder Exp $"
d691 1
a691 1
        if ( b%r1(i) <= i .and. b%r1(i) + b%r2(i+1) - b%r2(i) > i ) then
d1862 1
a1862 1
    logical, intent(in), optional :: DETAILS   ! Print details, default true
d1865 2
a1866 2
    logical :: MY_DETAILS
    my_details = .true.
d1875 1
a1875 1
      if ( my_details ) then
d1883 1
a1883 1
      if ( my_details ) then
d1894 1
a1894 1
    else if ( my_details ) then
d1911 3
@


2.26
log
@Handle empty block creation differently.  Add Update and Subtact to
MultiplyMatrixVector* where it wasn't before.  Get CholeskyFactor_1 to work.
@
text
@d108 1
a108 1
       "$Id: MatrixModule_0.f90,v 2.25 2001/05/10 02:14:11 vsnyder Exp $"
d1549 2
a1550 2
          my_b(i) = my_b(i) - dot(u%r2(i)-u%r2(i-1), &
            &                     u%values(u%r2(i-1)+1,1), 1, my_b(u%r1(i)), 1)
d1562 1
a1562 1
            my_b(i) = my_b(i) - u%values(h,1) * my_b(u%r2(h))
d1564 1
d1573 1
a1573 1
          my_b(i) = my_b(i) - dot(i-1, u%values(1,i), 1, my_b(1), 1)
d1590 1
a1590 1
        my_b(i) = my_b(i) - dot(n-i, ud(i,i+1), size(ud,1), my_b(i+1), 1)
d1911 4
@


2.25
log
@Repair CloneBlock, MaxAbsVal, MultiplyMatrixBlocks
@
text
@d108 1
a108 1
       "$Id: MatrixModule_0.f90,v 2.24 2001/05/09 19:45:37 vsnyder Exp $"
a150 5
  type(MatrixElement_T), save, private :: EmptyBlock     ! To fill the blocks.
    ! It will have zero-size arrays instead of nullified ones, so that we
    ! can copy the components without looking at the block kind if one
    ! operand is absent during an operation.
  logical, save, private :: FIRST = .true.        ! to create EmptyBlock
d314 4
a317 3
  ! components.  Notice that CopyBlock does a deep copy.  If one has
  ! Z = X in a loop, it is therefore necessary only to destroy Z after
  ! the loop.
d423 1
a423 1
      if ( present(xopt) ) then
a493 1
    if ( first ) call CreateEmptyBlock
d496 1
a496 1
      z = emptyBlock
d598 1
a598 2
      if ( first ) call CreateEmptyBlock
      z = emptyBlock
d1185 1
a1185 1
  subroutine MultiplyMatrixVector_0 ( B, V, P, UPDATE )
d1187 2
a1188 1
  ! P = P + B^T V if UPDATE is present and true.
d1193 1
d1196 2
a1197 1
    logical :: My_update
d1206 2
d1216 5
a1220 1
        p(i) = p(i) + dot(n, b%values(v1+1,1), 1, v(m), 1)
d1224 1
d1226 1
a1226 1
          p(i) = p(i) + b%values(n,1) * v(b%r2(n))
d1228 5
d1236 5
a1240 1
        p(i) = p(i) + dot(size(v), b%values(1,i), 1, v(1), 1)
d1246 1
a1246 1
  subroutine MultiplyMatrixVectorNoT_0 ( B, V, P, UPDATE, DoDiag )
d1248 2
a1249 1
  ! P = P + B V if UPDATE is present and true.
d1255 1
a1255 1
    logical, optional, intent(in) :: UPDATE, DoDiag
d1258 2
a1259 1
    logical :: My_diag, My_update
d1270 4
d1284 1
a1284 1
            p(i) = p(i) + b%values(v1+i-m+1,1) * v(j)
d1288 1
a1288 1
            p(i) = p(i) + b%values(v1+i-m+1,1) * v(j)
d1291 1
a1291 1
            p(i) = p(i) + b%values(v1+i-m+1,1) * v(j)
d1300 1
a1300 1
            & p(i) = p(i) + b%values(n,1) * v(j)
d1307 1
a1307 1
          p(i) = p(i) + dot_product ( b%values(i,:), v )
d1314 2
a1315 2
          p(i) = p(i) + dot_product ( b%values(i, 1:i-1), v(1:i-1) ) + &
            & dot_product ( b%values( i, i+1:), v(i+1:) )
d1852 3
a1854 7
  subroutine CreateEmptyBlock
  ! Create the empty block if necessary
    if ( .not. first ) return
    first = .false.
    emptyBlock%kind = M_absent
    emptyBlock%nRows = 0; emptyBlock%nCols = 0 ! just so they're defined
  ! allocate ( emptyBlock%r1(0), emptyBlock%r2(0), emptyBlock%values(0,0) )
d1910 3
@


2.24
log
@More work correcting blunders in sparse matrix code.  Add BandHeight
argument to CreateBlock.  Correct loss of lower bounds in CloneBlock.
@
text
@d108 1
a108 1
       "$Id: MatrixModule_0.f90,v 2.23 2001/05/09 01:58:12 vsnyder Exp $"
d502 10
a511 1
      return
a512 1
    z%kind = x%kind
a513 8
    call allocate_test ( z%r1, ubound(x%r1,1), "z%r1", ModuleName, &
      & lowBound=lbound(x%r1,1) )
    z%r1 = x%r1
    call allocate_test ( z%r2, ubound(x%r2,1), "z%r2", ModuleName, &
      lowBound=lbound(x%r2,1) )
    z%r2 = x%r2
    call allocate_test ( z%values, size(x%values,1), size(x%values,2), &
      & "z%values", ModuleName )
d750 5
a754 1
    maxAbsVal_0 = maxval(abs(b%values))
d1180 5
a1184 1
          zb%values = zb%values + matmul(transpose(xb%values),yb%values)
d1895 4
@


2.23
log
@Improper intent(out) -> intent(inout), don't access an absent optional dummy
@
text
@d108 1
a108 1
       "$Id: MatrixModule_0.f90,v 2.22 2001/05/08 20:29:40 vsnyder Exp $"
d299 5
a303 5
!        do k = 1, size(x%r1)
!          zb%values(x%r2(x%r1(k-1)+1:x%r1(k)), k) = &
!            & zb%values(x%r2(x%r1(k-1)+1:x%r1(k)), k) + &
!              & x%values(x%r1(k-1)+1:x%r1(k),1)
!        end do
d506 2
a507 1
    call allocate_test ( z%r1, size(x%r1), "z%r1", ModuleName )
d509 2
a510 1
    call allocate_test ( z%r2, size(x%r2), "z%r2", ModuleName )
d518 2
a519 2
  !                                     matrix represented by a vector and
  !                                     Z is either X or NEWX.
d559 2
a560 1
  subroutine CreateBlock_0 ( Z, nRows, nCols, Kind, NumberNonzero, NoValues )
d566 3
d593 1
d595 1
d609 6
d669 2
a670 1
    ! Deallocate the pointer components of the matrix block B
a676 2
      ! Don't clobber b%nrows and b%ncols: They may be arguments to a
      ! caller of DestroyBlock_0.
d1887 3
@


2.22
log
@Periodic commit -- workong on sparse matrix blunders
@
text
@d108 1
a108 1
       "$Id: MatrixModule_0.f90,v 2.21 2001/05/03 02:10:26 vsnyder Exp $"
a383 1
        zt(i,1:i-1) = 0.0_r8  ! Clear left from the diagonal (helps Sparsify!)
d389 1
d582 1
a582 1
    type(MatrixElement_T), intent(out) :: Z
a951 1
        zb%values => z
d1378 1
a1378 1
    nc = b%nCols
d1874 3
@


2.21
log
@Nullify a bunch of pointers that should have been but weren't.  Use a
disassociated VALUES array instead of a zero-size one for absent blocks.
@
text
@d108 1
a108 1
       "$Id: $"
d111 1
a111 1
       "$RCSfile: $"
d335 1
a335 1
  ! triangular. Otherwise, replace Z such that Z(output) = Z(input)^T
d553 1
a553 1
    z%values = x%values
d557 1
a557 1
  subroutine CreateBlock_0 ( Z, nRows, nCols, Kind, NumberNonzero )
d562 1
d586 1
d588 4
d601 2
a602 1
      call allocate_test ( z%values, NumberNonzero, 1, "z%values", ModuleName )
d607 2
a608 1
      call allocate_test ( z%values, NumberNonzero, 1, "z%values", ModuleName )
d611 3
a613 2
      call allocate_test ( z%r2, 0, "z%r1", ModuleName )
      call allocate_test ( z%values, nRows, nCols, "z%values", ModuleName )
d657 1
a657 1
    ! Don't destroy absent blocks, as they all point to the same place
d662 3
a664 2
      b%nrows = 0
      b%ncols = 0
d803 1
a803 1
    if ( present(subtract) ) my_sub = my_sub
d807 1
a807 1
      if ( my_upd) call createBlock ( zb, xb%nCols, yb%nCols, M_Absent )
d814 8
a821 3
      if ( xb%ncols /= zb%nrows .or. yb%ncols /= zb%ncols ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "ZB Matrix size incompatible in Multiply_Matrix_Blocks" )
d834 1
a834 1
        if ( update ) then
a861 1
            end if
d866 1
d876 1
a876 1
        if ( update ) then
d919 6
a924 3
        if ( .not. my_upd ) then
          call createBlock ( zb, xb%ncols, yb%ncols, M_Full )
          zb%values = 0.0_r8
d926 1
d952 1
d961 1
a961 1
        if ( update ) then
d1008 1
a1008 1
        if ( update ) then
d1054 6
a1059 3
        if ( .not. my_upd ) then
          call createBlock ( zb, xb%ncols, yb%ncols, M_Full )
          zb%values = 0.0_r8
d1061 1
d1088 6
a1093 3
      if ( .not. my_upd ) then
        call createBlock ( zb, xb%ncols, yb%ncols, M_Full )
        zb%values = 0.0_r8
d1095 1
d1668 1
d1675 3
a1677 1
      call createBlock ( a, a%nRows, a%nCols, m_banded, n )
d1741 1
d1753 3
a1755 1
      call createBlock ( a, a%nRows, a%nCols, m_banded, n )
d1833 1
d1838 1
a1838 1
      call output ( ' Banded' )
d1846 1
a1846 1
      call output ( ' Column-sparse' )
d1857 1
a1857 1
      call output ( ' Absent', advance='yes' )
d1875 4
@


2.20
log
@Correct/remove some incorrect size tests in MultiplyMatrixVectorNoT
@
text
@d106 7
a112 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=256), private :: Id = &
    & "$Id: MatrixModule_0.f90,v 2.19 2001/04/30 17:47:18 livesey Exp $"
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: MatrixModule_0.f90,v $"
  !---------------------------------------------------------------------------
d130 1
a130 1
    integer :: NROWS, NCOLS                  ! Numbers of rows and columns
d355 1
d653 2
a654 1
      b%kind = M_Absent
d791 1
d1341 1
d1504 2
a1505 2
          ! dot_product( ud(1:i-1,i), my_b(1:i-1) )
          my_b(i) = my_b(i) - dot(i-1, ud(1,i), 1, my_b(1), 1)
d1512 1
d1642 1
d1661 1
d1679 1
d1713 1
d1736 1
d1754 1
d1785 1
a1785 1
    allocate ( emptyBlock%r1(0), emptyBlock%r2(0), emptyBlock%values(0,0) )
d1840 3
@


2.19
log
@Reverted to original size of R2, the problem must be somewhere else.
@
text
@d108 1
a108 1
    & "$Id: MatrixModule_0.f90,v 2.18 2001/04/28 07:03:21 livesey Exp $"
a1154 2
    if ( any(shape(v) /= shape(p)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Vectors not compatible in MultiplyMatrixVector_0" )
a1198 3
! Why is this here?
!     if ( any(shape(v) /= shape(p)) ) call MLSMessage ( MLSMSG_Error, &
!       & ModuleName, "Vectors not compatible in MultiplyMatrixVector_0" )
d1211 1
a1211 1
        if ( my_diag ) then        ! do the whome matrix
d1828 3
@


2.18
log
@Removed a print statement
@
text
@d108 1
a108 1
    & "$Id: MatrixModule_0.f90,v 2.17 2001/04/28 05:04:16 livesey Exp $"
d216 1
a216 1
        call allocate_test ( zb%r2, size(x%r2)+1, "zb%r2", ModuleName, lowBound=0 )
d591 1
a591 1
      call allocate_test ( z%r2, nCols+1, "z%r2", ModuleName, lowBound=0 )
d1833 3
@


2.17
log
@Temporarily changed dot to dot_product in MultiplyMatrixVectorNoT, to
avoid run time error I don't understand.
@
text
@d108 1
a108 1
    & "$Id: MatrixModule_0.f90,v 2.16 2001/04/28 04:40:17 livesey Exp $"
a1196 1
    print*,'In MMVNOT:',b%nCols, size(v), b%nrows, size(p)
d1833 4
@


2.16
log
@Some tidying up, removing unnecessary(?) tests for square matrices
in multiplyMatrixVector and its relatives.  Also changing allocation
of r2 for m_banded, as it needs an extra element.
@
text
@d108 1
a108 1
    & "$Id: MatrixModule_0.f90,v 2.15 2001/04/28 01:33:02 livesey Exp $"
d1213 1
a1213 1
      do j = 1, size(p)            ! columns
d1241 2
a1242 1
          p(i) = p(i) + dot(size(v), b%values(i,1), size(b%values,1), v(1), 1)
d1246 5
a1250 3
          p(i) = p(i) + dot(i-1, b%values(i,1), size(b%values,1), v(1), 1)
          p(i) = p(i) + &
            & dot(size(v)-i, b%values(i,i+1), size(b%values,1), v(i+1), 1)
d1834 5
@


2.15
log
@Now DestroyBlock doesn't destroy absent blocks as they all point to the same place.
@
text
@d108 1
a108 1
    & "$Id: MatrixModule_0.f90,v 2.14 2001/04/25 00:50:09 vsnyder Exp $"
d216 1
a216 1
        call allocate_test ( zb%r2, size(x%r2), "zb%r2", ModuleName )
d591 1
a591 1
      call allocate_test ( z%r2, nCols, "z%r2", ModuleName, lowBound=0 )
d1197 2
a1198 1
    if ( b%nrows /= size(v) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1200 1
a1200 1
    if ( b%ncols /= size(p) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1202 3
a1204 2
    if ( any(shape(v) /= shape(p)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Vectors not compatible in MultiplyMatrixVector_0" )
d1831 3
@


2.14
log
@Make MultiplyMatrixNoT generic
@
text
@d108 1
a108 1
    & "$Id: MatrixModule_0.f90,v 2.13 2001/04/11 22:43:54 vsnyder Exp $"
d644 1
a644 1
  ! Deallocate the pointer components of the matrix block B
d646 7
a652 4
    call deallocate_test ( b%r1, "b%r1", ModuleName )
    call deallocate_test ( b%r2, "b%r2", ModuleName )
    call deallocate_test ( b%values, "b%values", ModuleName )
    b%kind = M_Absent
d1829 3
@


2.13
log
@Fold Deallocate_test into sparsify
@
text
@d26 5
a30 4
    & MultiplyMatrixVectorNoT, MultiplyMatrixVector_0, operator(+), &
    & operator(.TX.), RowScale, RowScale_0, ScaleBlock, SolveCholesky, &
    & SolveCholeskyM_0, SolveCholeskyV_0, Sparsify, UpdateDiagonal, &
    & UpdateDiagonal_0, UpdateDiagonalVec_0
d78 1
a78 1
  interface MultiplyMatrixVector
d82 4
d108 1
a108 1
    & "$Id: MatrixModule_0.f90,v 2.12 2001/02/22 01:55:06 vsnyder Exp $"
d1179 2
a1180 2
  ! ------------------------------------  MultiplyMatrixVectorNoT  -----
  subroutine MultiplyMatrixVectorNoT ( B, V, P, UPDATE, DoDiag )
d1246 1
a1246 1
  end subroutine MultiplyMatrixVectorNoT
d1826 3
@


2.12
log
@Add code to invert a Cholesky factor
@
text
@d103 1
a103 1
    & "$Id: MatrixModule_0.f90,v 2.11 2001/02/09 18:37:16 pwagner Exp $"
d265 1
a265 2
        call sparsify ( z, zb )                  ! Zb = Z
        call deallocate_test ( z, "Z in Add_Matrix_Blocks", ModuleName )
d288 1
a288 2
        call sparsify ( z, zb )                  ! Zb = Z
        call deallocate_test ( z, "Z in Add_Matrix_Blocks", ModuleName )
d367 1
a367 2
      call sparsify ( zt, z )
      call deallocate_test ( zt, "ZT in CholeskyFactor", ModuleName )
d842 1
a842 2
        call sparsify ( z, zb )
        call deallocate_test ( z, &
d889 1
a889 2
        call sparsify ( z, zb )
        call deallocate_test ( z, &
d969 1
a969 2
        call sparsify ( z, zb )
        call deallocate_test ( z, &
d1019 1
a1019 2
        call sparsify ( z, zb )
        call deallocate_test ( z, &
d1419 1
a1419 2
    call sparsify ( xs, x )
    call deallocate_test ( xs, "XS in SolveCholeskyM_0", ModuleName )
d1517 1
a1517 1
  subroutine Sparsify ( Z, B )
d1520 1
a1520 1
    real(r8), intent(in) :: Z(:,:)           ! Full array of values
d1522 4
d1608 9
d1646 1
a1646 1
          call sparsify ( t, a )
d1663 1
a1663 1
            call sparsify ( t, a )
d1718 1
a1718 1
          call sparsify ( t, a )
d1735 1
a1735 1
            call sparsify ( t, a )
d1821 3
@


2.11
log
@Commented-out statements that offended NAG v4.0
@
text
@d29 1
a29 1
    & UpdateDiagonal_0
d98 1
a98 1
    module procedure UpdateDiagonal_0
d103 1
a103 1
    & "$Id: MatrixModule_0.f90,v 2.10 2001/01/26 19:00:01 vsnyder Exp $"
d757 8
a764 3
  subroutine MultiplyMatrixBlocks ( XB, YB, ZB, UPDATE, XMASK, YMASK )
  ! ZB = XB^T YB if UPDATE is absent or false;
  ! ZB = ZB + XB^T YB if UPDATE is present and true.
d770 1
d775 2
a776 2
  ! using the result of this function after it is no longer needed.
  ! Otherwise, a memory leak will result.  Also see AssignBlock.
d780 1
a780 1
    logical :: MY_UPD
d783 2
a794 3
      zb%nrows = xb%ncols
      zb%ncols = yb%ncols
    else
d798 3
d832 11
a842 4
!           z(i,j) = z(i,j) + &
!                    & dot_product ( xb%values(r+m:r+n,1), yb%values(p+m:p+n,1) )
            z(i,j) = z(i,j) + &
                     & dot( n-m+1, xb%values(r+m,1), 1, yb%values(p+m,1), 1 )
d879 5
a883 1
                z(i,j) = z(i,j) + xb%values(l,1) * yb%values(n,1)
d913 11
a923 4
!           zb%values(i,j) = zb%values(i,j) + dot_product( &
!             & xb%values(k:l,1), yb%values(m:m+l-k,j) )
            zb%values(i,j) = zb%values(i,j) + dot( l-k+1, &
              & xb%values(k,1), 1, yb%values(m,j), 1 )
d960 5
a964 1
                z(i,j) = z(i,j) + xb%values(l,1) * yb%values(n,1)
d1010 5
a1014 1
                z(i,j) = z(i,j) + xb%values(l,1) * yb%values(n,1)
d1044 11
a1054 4
!           zb%values(i,j) = zb%values(i,j) + dot_product( &
!             & xb%values(k:l,1), yb%values(xb%r2(k:l),j) )
            zb%values(i,j) = zb%values(i,j) + dot( l-k+1, &
              & xb%values(k,1), 1, yb%values(xb%r2(k),j), 1 )
d1077 11
a1087 4
!           zb%values(i,j) = zb%values(i,j) + dot_product( &
!             & xb%values(m:m+l-k,i), yb%values(k:l,1))
            zb%values(i,j) = zb%values(i,j) + dot( l-k+1, &
              & xb%values(m,i), 1, yb%values(k,1), 1 )
d1102 7
a1108 2
            zb%values(i,j) = zb%values(i,j) + dot_product( &
              & xb%values(yb%r2(k:l),i), yb%values(k:l,1) )
d1121 7
a1127 2
              zb%values(i,j) = zb%values(i,j) + dot( xb%nrows, xb%values(1,i), &
                               & 1, yb%values(1,j), 1 )
d1261 1
a1261 1
    call MultiplyMatrixBlocks ( x, y, z, .false. )
d1679 73
d1816 3
@


2.10
log
@Periodic commit
@
text
@d103 1
a103 1
    & "$Id: MatrixModule_0.f90,v 2.9 2001/01/19 23:50:45 vsnyder Exp $"
d293 7
a299 5
        do k = 1, size(x%r1)
          zb%values(x%r2(x%r1(k-1)+1:x%r1(k)), k) = &
            & zb%values(x%r2(x%r1(k-1)+1:x%r1(k)), k) + &
              & x%values(x%r1(k-1)+1:x%r1(k),1)
        end do
d1685 3
@


2.9
log
@Periodic commit
@
text
@d22 8
a29 6
    & DestroyBlock, Dump, M_Absent, M_Banded, M_Column_Sparse, M_Full, &
    & MatrixElement_T, MaxAbsVal, MaxAbsVal_0, MinDiag, MinDiag_0, &
    & MultiplyMatrixBlocks, MultiplyMatrixVector, MultiplyMatrixVectorNoT, &
    & MultiplyMatrixVector_0, operator(+), operator(.TX.), RowScale, &
    & RowScale_0, SolveCholesky, SolveCholeskyM_0, SolveCholeskyV_0, &
    & Sparsify, UpdateDiagonal, UpdateDiagonal_0
d53 4
d61 8
d103 1
a103 1
    & "$Id: MatrixModule_0.f90,v 2.8 2000/11/23 01:09:19 vsnyder Exp $"
d638 2
a639 2
  ! -----------------------------------------------  DestroyBlock  -----
  subroutine DestroyBlock ( B )
d646 66
a711 1
  end subroutine DestroyBlock
d1249 7
d1683 3
@


2.8
log
@Add provision to ignore specified columns during matrix-matrix multiply
@
text
@d23 5
a27 4
    & MatrixElement_T, MultiplyMatrixBlocks, MultiplyMatrixVector, &
    & MultiplyMatrixVectorNoT, MultiplyMatrixVector_0, operator(+), &
    & operator(.TX.), RowScale, RowScale_0, SolveCholesky, SolveCholeskyM_0, &
    & SolveCholeskyV_0, Sparsify, UpdateDiagonal, UpdateDiagonal_0
d55 8
d89 1
a89 1
    & "$Id: MatrixModule_0.f90,v 2.7 2000/11/15 00:18:26 vsnyder Exp $"
d634 41
d1597 3
@


2.7
log
@Added assignment(=) interface, row scale, column scale
@
text
@d20 7
a26 7
    & CholeskyFactor_0, CloneBlock, ColumnScale, ColumnScale_0, CopyBlock, &
    & CreateBlock, CreateBlock_0, Densify, DestroyBlock, Dump, M_Absent, &
    & M_Banded, M_Column_Sparse, M_Full, MatrixElement_T, &
    & Multiply_Matrix_Blocks, MultiplyMatrixVector, MultiplyMatrixVectorNoT, &
    & MultiplyMatrixVector_0, operator(+), operator(.TX.), RowScale, &
    & RowScale_0, SolveCholesky, SolveCholeskyM_0, SolveCholeskyV_0, &
    & Sparsify, UpdateDiagonal, UpdateDiagonal_0
d38 4
d63 1
a63 1
    module procedure Multiply_Matrix_Blocks, NewMultiplyMatrixVector_0
d80 1
a80 1
    & "$Id: MatrixModule_0.f90,v 2.6 2000/11/10 00:28:13 vsnyder Exp $"
d117 2
d171 1
a171 1
    ! used determine whether to commute the operands.  The M_...
d426 37
d625 6
a630 3
  ! -------------------------------------  Multiply_Matrix_Blocks  -----
  function Multiply_Matrix_Blocks ( XB, YB ) result ( ZB ) ! ZB = XB^T * YB
  ! Compute the matrix product of XB^T and YB.
d632 3
a634 1
    type(MatrixElement_T) :: ZB
d637 3
a639 3
  ! It is important to invoke DestroyBlock using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignBlock.
d643 1
d646 2
d649 1
a649 1
      call createBlock ( zb, xb%nCols, yb%nCols, M_Absent )
d653 10
a662 4
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Matrix sizes incompatible in Multiply_Matrix_Blocks" )
    zb%nrows = xb%ncols
    zb%ncols = yb%ncols
d670 6
a675 1
          & "Z for banded * banded in Multiply_Matrix_Blocks", ModuleName )
d677 3
d686 3
d693 4
a696 2
!           z(i,j) = dot_product ( xb%values(r+m:r+n,1), yb%values(p+m:p+n,1) )
            z(i,j) = dot( n-m+1, xb%values(r+m,1), 1, yb%values(p+m,1), 1 )
d706 6
a711 1
          & "Z for banded X banded in Multiply_Matrix_Blocks", ModuleName )
d713 3
d717 3
a723 1
            z(i,j) = 0.0_r8
d747 4
a750 1
        call createBlock ( zb, xb%ncols, yb%ncols, M_Full )
d752 3
d759 3
d763 1
a763 1
!           zb%values(i,j) = dot_product( &
d765 1
a765 1
            zb%values(i,j) = dot( l-k+1, &
d776 6
a781 1
          & "Z for banded X banded in Multiply_Matrix_Blocks", ModuleName )
d783 3
d787 3
a793 1
            z(i,j) = 0.0_r8
d820 6
a825 1
          & "Z for banded X banded in Multiply_Matrix_Blocks", ModuleName )
d827 3
d831 3
d864 4
a867 1
        call createBlock ( zb, xb%ncols, yb%ncols, M_Full )
d869 3
d873 3
d879 1
a879 1
!           zb%values(i,j) = dot_product( &
d881 1
a881 1
            zb%values(i,j) = dot( l-k+1, &
d887 4
a890 1
      call createBlock ( zb, xb%ncols, yb%ncols, M_Full )
d894 3
d901 3
d905 1
a905 1
!           zb%values(i,j) = dot_product( &
d907 1
a907 1
            zb%values(i,j) = dot( l-k+1, &
d913 3
d919 3
d923 1
a923 1
            zb%values(i,j) = dot_product( &
d928 16
a943 1
        zb%values = matmul(transpose(xb%values),yb%values)
d946 1
a946 1
  end function Multiply_Matrix_Blocks
d1061 14
d1547 3
@


2.6
log
@Added multiply untransposed matrix * vector
@
text
@d19 8
a26 7
  public :: Add_Matrix_Blocks, CholeskyFactor, CholeskyFactor_0, CloneBlock, &
    & ColumnScale, ColumnScale_0, CopyBlock, CreateBlock, CreateBlock_0, &
    & Densify, DestroyBlock, Dump, M_Absent, M_Banded, M_Column_Sparse, &
    & M_Full, MatrixElement_T, Multiply_Matrix_Blocks, MultiplyMatrixVector, &
    & MultiplyMatrixVectorNoT, MultiplyMatrixVector_0, operator(+), &
    & operator(.TX.), RowScale, RowScale_0, SolveCholesky, SolveCholeskyM_0, &
    & SolveCholeskyV_0, Sparsify, UpdateDiagonal, UpdateDiagonal_0
d30 4
d76 1
a76 1
    & "$Id: MatrixModule_0.f90,v 2.5 2000/11/09 01:22:43 vsnyder Exp $"
d150 1
a150 1
  ! result.
d281 16
d427 1
d442 5
a446 4
  ! ----------------------------------------------  ColumnScale_0  -----
  function ColumnScale_0 ( X, V ) result ( Z ) ! Z = X V where V is a diagonal
  !                                     matrix represented by a vector.
    type(MatrixElement_T), intent(in) :: X
d448 2
a449 7
    type(MatrixElement_T) :: Z

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyBlock using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.
  ! !!!!! ===== END NOTE ===== !!!!! 
d453 6
a458 1
    call copyBlock ( z, x )
d463 1
a463 1
        z%values(z%r2(i-1)+1:z%r2(i),1) = z%values(z%r2(i-1)+1:z%r2(i),1) * v(i)
d467 1
a467 1
        z%values(z%r1(i-1)+1:z%r1(i),1) = z%values(z%r1(i-1)+1:z%r1(i),1) * v(i)
d471 1
a471 1
        z%values(:,i) = z%values(:,i) * v(i)
d474 1
a474 1
  end function ColumnScale_0
d477 1
a477 1
  subroutine CopyBlock ( Z, X ) ! Z = X, including the values
d591 1
a591 1
  ! result.
d921 3
a923 2
  function RowScale_0 ( V, X ) result ( Z ) ! Z = V X where V is a diagonal
  !                                     matrix represented by a vector.
d925 3
a927 8
    type(MatrixElement_T), intent(in) :: X
    type(MatrixElement_T) :: Z

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyBlock using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.
  ! !!!!! ===== END NOTE ===== !!!!! 
d931 6
a936 1
    call copyBlock ( z, x )
d943 1
a943 1
          & z%values(z%r2(i-1)+1:z%r2(i),1)
d948 1
a948 1
          & z%values(z%r1(i-1)+1:z%r1(i),1)
d952 1
a952 1
        z%values(i,:) = v(i) * z%values(i,:)
d955 1
a955 1
  end function RowScale_0
d1175 1
a1175 1
  ! result.
d1384 3
@


2.5
log
@Periodic commit -- still under construction
@
text
@d23 3
a25 3
    & MultiplyMatrixVector_0, operator(+), operator(.TX.), RowScale, &
    & RowScale_0, SolveCholesky, SolveCholeskyM_0, SolveCholeskyV_0, &
    & Sparsify, UpdateDiagonal, UpdateDiagonal_0
d71 1
a71 1
    & "$Id: MatrixModule_0.f90,v 2.4 2000/10/13 22:22:48 vsnyder Exp $"
d820 69
d1360 3
@


2.4
log
@Change name of multiply operator from .XT. to .TX.
@
text
@d19 7
a25 3
  public :: Add_Matrix_Blocks, CloneBlock, CopyBlock, CreateBlock, Densify
  public :: DestroyBlock, Dump, MatrixElement_T, Multiply_Matrix_Blocks
  public :: operator(+), operator(.TX.), Sparsify
d29 12
d45 4
d53 14
a66 2
  interface operator ( .TX. ) ! A transpose * B
    module procedure Multiply_Matrix_Blocks
d71 1
a71 1
    & "$Id: MatrixModule_0.f90,v 2.3 2000/10/12 20:10:08 vsnyder Exp $"
d90 2
a91 1
    integer :: KIND      ! Kind of block -- one of the M_... parameters above
d93 12
a104 11
    integer, pointer, dimension(:) :: R1     ! Indexed by the column number.
      ! Used for the first column number if KIND = M_Banded, as described
      ! above for M_Column_sparse if KIND = M_Column_sparse, and not used
      ! otherwise.
    integer, pointer, dimension(:) :: R2     ! Indexed by the column number if
      ! KIND = M_Banded, by elements of R1 if KIND = M_Column_sparse, and
      ! not used otherwise.  See M_Banded and M_Column_sparse above.
    real(r8), pointer, dimension(:,:) :: VALUES   ! Values of the matrix
      ! elements.  Indexed by row and column indices if KIND == M_Full, by
      ! elements in the range of values of R1 and R2 if KIND == M_Banded,
      ! and by elements of R2 if KIND == M_Column_sparse.
d116 1
a116 1
  real, parameter, private :: SPARSITY = 0.25     ! If a full matrix has
d120 15
d141 7
d165 1
a165 1
      call CopyBlock ( zb, y )                   ! Zb = y
d178 1
a178 1
        zb%r2 = max(x%r2, y%r2)                  ! Last nonzero row
d180 3
a182 1
          zb%r2(k) = zb%r2(k-1) + zb%r2(k) - zb%r1(k) + 1 ! Last entry in Values
d186 2
d276 123
d420 33
d461 2
a462 2
  ! ------------------------------------------------  CreateBlock  -----
  subroutine CreateBlock ( Z, nRows, nCols, Kind, NumberNonzero )
d466 1
d472 5
a476 5
  !   subscript in the first dimension of VALUES for the last nonzero
  !   element in the column.  The second dimension of VALUES has shape
  !   (1:1).  The subscript for the first nonzero element is R2(c-1)+1
  !   (R2(0)==0).  The number of nonzero elements is R2(c) - R2(c-1).  The
  !   index of the last nonzero row is R1(c) + R2(c) - R2(c-1) - 1.
d491 1
d517 1
a517 1
  end subroutine CreateBlock
d526 1
d556 1
d562 1
a562 1
    type(MatrixElement_T), intent(in), target :: XB, YB
d565 6
d587 3
a589 3
        ! Make a full matrix, then sparsify it.  There _must_ be a better
        ! way ???
        call allocate_test ( z, xb%ncols, yb%ncols, &
d591 1
a591 1
        do j = 1, yb%ncols    ! Columns of Z
d596 1
a596 1
          do i = 1, xb%ncols  ! Rows of Z
d602 2
a603 1
            z(i,j) = dot_product ( xb%values(r+m:r+n,1), yb%values(p+m:p+n,1) )
d610 2
a611 2
        ! Make a full matrix, then sparsify it.  There _must_ be a better
        ! way ???
d651 4
a654 2
            zb%values(i,j) = dot_product( &
              & xb%values(k:l,1), yb%values(m:m+l-k,j) )
d661 2
a662 2
        ! Make a full matrix, then sparsify it.  There _must_ be a better
        ! way ???
d695 2
a696 2
        ! Make a full matrix, then sparsify it.  There _must_ be a better
        ! way ???
d737 4
a740 2
            zb%values(i,j) = dot_product( &
              & xb%values(k:l,1), yb%values(xb%r2(k:l),j) )
d754 4
a757 2
            zb%values(i,j) = dot_product( &
              & xb%values(m:m+l-k,i), yb%values(k:l,1))
d776 296
d1079 6
d1162 65
d1240 1
a1240 1
  subroutine DUMP_MATRIX_BLOCK ( MATRIX_BLOCK, NAME )
d1243 6
d1254 7
a1260 4
      call output ( ' Banded First-Rows =', advance='yes' )
      call dump ( matrix_block%r1 )
      call output ( '  Last-Row-values =', advance='yes' )
      call dump ( matrix_block%r2 )
d1262 7
a1268 4
      call output ( ' Column-sparse Row-map =', advance='yes' )
      call dump ( matrix_block%r1 )
      call output ( '  Rows =', advance='yes' )
      call dump ( matrix_block%r2 )
d1274 7
d1282 3
a1284 2
      call output ( '  Values =', advance='yes' )
      call dump ( matrix_block%values )
d1291 3
@


2.3
log
@Make default accessibility private
@
text
@d21 1
a21 1
  public :: operator(+), operator(.XT.), Sparsify
d33 1
a33 1
  interface operator ( .XT. ) ! A transpose * B
d39 1
a39 1
    & "$Id: MatrixModule_0.f90,v 2.2 2000/10/10 23:11:34 vsnyder Exp $"
d671 3
@


2.2
log
@Correct number of rows and columns for zero matrix.
@
text
@d18 4
a21 3
  private :: Dump_Matrix_Block
  public :: Add_Matrix_Blocks, CloneBlock, CopyBlock, Dump, MatrixElement_T
  public :: Multiply_Matrix_Blocks, operator(+), operator(.XT.), Sparsify
d39 1
a39 1
    & "$Id: MatrixModule_0.f90,v 2.1 2000/10/04 20:24:45 vsnyder Exp $"
d671 3
@


2.1
log
@Initial entry
@
text
@d38 1
a38 1
    & "$Id: MatrixModule.f90,v 2.0 2000/09/05 18:57:03 ahanzel Exp $"
d40 1
a40 1
    & "$RCSfile: MatrixModule.f90,v $"
d348 1
a348 1
      call CopyBlock ( zb, emptyBlock )
d669 4
a672 1
! $Log: $
@

