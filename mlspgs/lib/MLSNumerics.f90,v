head	2.101;
access;
symbols
	v5-02-NRT-19:2.101
	v6-00:2.101
	v5-02-NRT-18:2.101
	v5-02:2.100
	v5-01-NRT-17:2.101
	v5-01-NRT-16:2.101
	v5-01-NRT-15:2.100
	v5-01-NRT-14:2.100
	neuralnetworks-1-0:2.100.0.6
	cfm-single-freq-0-1:2.100.0.4
	v5-01:2.100
	v5-00:2.100
	v4-23-TA133:2.100.0.2
	mus-emls-1-70:2.98.0.4
	rel-1-0-englocks-work:2.98.0.2
	VUMLS1-00:2.92
	VPL1-00:2.91
	V4-22-NRT-08:2.88
	VAM1-00:2.88
	V4-21:2.82.0.2
	V4-13:2.82
	V4-12:2.82
	V4-11:2.82
	V4-10:2.82
	V3-43:2.64
	M4-00:2.76
	V3-41:2.64
	V3-40-PlusGM57:2.64.0.2
	V2-24-NRT-04:2.56
	V3-33:2.65
	V2-24:2.56
	V3-31:2.65
	V3-30-NRT-05:2.65
	cfm-01-00:2.65
	V3-30:2.64
	V3-20:2.64
	V3-10:2.62
	V2-23-NRT-02:2.56
	V2-23:2.56
	V2-22-NRT-01:2.56
	V2-22:2.56
	V2-21:2.46
	V2-20:2.46
	V2-11:2.43
	V2-10:2.43
	V2-00:2.43
	V1-51:2.32
	V1-50:2.31
	V1-45:2.29
	V1-44:2.29
	V1-43:2.29
	V1-42:2.29
	V1-41:2.29
	V1-32:2.29
	V1-40:2.29
	V1-31:2.29
	V1-30:2.28
	V1-13:2.27
	V1-12:2.27
	V1-11:2.27
	V1-10:2.27
	newfwm-feb03:2.27.0.2
	V1-04:2.18
	V1-03:2.18
	V1-02:2.18
	V1-00:2.18
	newfwm-sep01:2.13.0.2
	V0-7:2.13
	V0-5-Level2:2.9
	V0-5-SIPS:2.5
	V0_1:1.13;
locks; strict;
comment	@# @;


2.101
date	2022.03.24.21.43.07;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2018.12.05.01.00.46;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2018.12.03.23.19.58;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2017.12.07.02.22.11;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2017.11.03.23.34.06;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2017.11.03.19.56.36;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2017.11.02.00.09.38;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2017.10.31.23.46.29;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2017.10.17.23.41.31;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2016.09.14.20.13.19;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2016.08.23.20.27.40;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2016.07.28.01.40.24;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2016.06.02.02.11.51;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2015.07.29.00.24.05;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2015.05.27.22.42.15;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2015.04.29.00.53.01;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2015.04.11.01.28.25;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2015.04.07.02.47.30;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2015.03.28.01.49.22;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2013.08.13.00.58.43;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2013.05.31.23.30.37;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2013.05.31.02.37.11;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2013.04.12.00.35.56;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2013.02.11.17.19.04;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2012.12.20.01.06.15;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2012.06.12.18.10.00;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2012.05.25.20.53.21;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2012.04.20.23.55.22;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2011.11.18.02.42.35;	author vsnyder;	state Exp;
branches;
next	2.70;

2.70
date	2011.08.26.17.52.49;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2011.08.26.00.23.56;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2011.08.20.00.47.14;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2011.08.17.00.48.57;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2011.03.22.23.37.56;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2010.06.07.23.31.49;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2009.12.08.21.43.14;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2009.11.17.23.34.38;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2009.06.20.02.32.58;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2009.06.13.02.27.39;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2008.09.03.20.43.48;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2008.06.06.22.52.21;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2008.05.02.00.41.42;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2008.01.07.21.36.33;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2007.08.20.22.03.31;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2007.08.13.17.28.46;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2007.08.07.23.55.02;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2007.07.31.22.48.27;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2007.07.25.20.09.25;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2007.07.23.23.18.26;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2007.06.21.00.49.52;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2007.04.02.22.53.26;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2007.03.14.23.58.05;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2007.03.02.18.21.14;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2006.10.04.03.20.08;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2006.08.05.02.36.36;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2006.08.03.01.57.22;	author vsnyder;	state Exp;
branches;
next	2.43;

2.43
date	2006.01.14.00.53.05;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2006.01.05.03.46.47;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2006.01.05.00.56.03;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2005.12.16.00.02.05;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2005.11.04.18.47.34;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2005.08.15.20.35.37;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2005.08.06.01.36.30;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2005.08.05.20.34.47;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2005.08.03.16.36.46;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2005.05.12.20.47.56;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2005.01.19.17.16.48;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2004.09.28.23.14.24;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2004.09.10.23.52.29;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2003.09.11.23.09.18;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2003.04.04.00.10.08;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2002.11.25.18.51.19;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2002.11.23.00.01.00;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2002.10.08.00.09.12;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2002.10.04.16.40.30;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2002.10.04.01.48.27;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2002.10.04.00.48.05;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2002.09.13.18.08.12;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2002.09.11.17.43.38;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2002.05.24.17.00.55;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.12.01.01.03.07;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2001.11.14.01.47.40;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2001.10.19.23.41.43;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.09.24.17.27.50;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2001.09.20.20.54.55;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2001.07.10.17.55.23;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.07.06.18.44.40;	author dwu;	state Exp;
branches;
next	2.11;

2.11
date	2001.06.07.21.59.41;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.05.08.23.25.58;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.05.03.23.13.28;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.05.03.21.54.49;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.04.28.19.42.48;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.04.28.07.05.05;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.04.11.22.43.19;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.06.00.35.23;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.05.01.20.36;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.22.01.59.52;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.09.00.38.55;	author livesey;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.17.41.06;	author dcuddy;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.23.01.08.48;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	99.11.29.23.14.14;	author livesey;	state Exp;
branches;
next	;


desc
@@


2.101
log
@Added AGM function; renamed UDF dummy arg LkUpTable
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module MLSNumerics              ! Some low level numerical stuff
!=============================================================================

 use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
 use HyperSlabs, only: Rerank
 use Dump_0, Only : Dump
 use HighOutput, only: OutputNamedValue
 use Hunt_M, only: Hunt, Huntbox, Huntrange
 use MatrixModule_0, only: Createblock, M_Absent, MatrixElement_T, Sparsify
 use MLSFillValues, only: IsfillValue
 use MLSKinds, only: I4, R4, R8, Rm
 use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, &
   & MLSMessage
 use MLSFinds, only: Findfirst, Findlast
 use MLSStrings, only: Capitalize, Trim_Safe
 use Optional_M, only: Default
 use Output_M, only: Blanks, Output
 use Pure_Hunt_M, only: Purehunt
 use Symm_Tri, only: Factor_Symm_Tri, Solve_Factored_Symm_Tri

  implicit none

  private
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSNumerics.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! This module contains some low level numerical stuff, hunting, interpolating,
  ! approximating roots, derivatives, integrals, and some stray functions
  ! An area of focus is approximating functions that are expensive to evaluate
  ! by assembling a lookup table of precomputed values
  ! (a) Using an array of its values at regularly spaced arguments
  ! (b) Using an array of its values at an array of specified arguments
  ! (c) Like (a) but using a user-defined datatype, the LookUpTable_0
  !
! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (parameters and datatypes)
! Coefficients_nprec       Coefficients to speed up interpolation
!                            (See InterpolateArraySetup)
! LookUpTable_0_nprec    Look Up Table
!                            y(x[i]) where x[i+1] - x[i] = constant

!         Functions, operations, routines
! AGM                      Return the arithmetic-geometric mean of two numbers
! Average                  Compute the average of a rank-one real array
! Battleship               By ever-widening evaluations find integer root
!                             or floating root to within a given tolerance
!                             (Generalized Binary Search)
! ClosestElement           Find index(es) in array closest to test value
!                           (array may be multidimensional, non-monotonic)
! Destroy                  Deallocate y values in LookUpTable_0
! d2Fdx2Approximate        Compute 2nd derivative using LookUpTable_0
! dFdxApproximate          Compute derivative using LookUpTable_0
! Dump                     Dump Coefficients structure
! Dump                     Dump uniform discrete function structure
! F_Of_X                   Use any recognized method to approximate f
! FApproximate             Use Uniformly Discretized Fn as an approximation
! FInvApproximate          Use it to invert a function (may not be unique)
! FillLookUpTable          Fill table with evaluations at regularly-spaced args
!                            to be used in place of later, frequent evaluations;
!                            reversing role of (table, xtable) => function^(-1)
! FindInRange              Finds indices of array elements for which values
!                            lie within a range
!                            (list need not be monotonic)
! Hunt                     Finds index of item(s) in list closest to prey
!                           (list must be monotonic)
! HuntBox                  Finds indices of n-dimensional box enclosing coords
! HuntRange                Finds index range between which
!                           all item(s) in list lie within range of values
! IFApproximate            Compute integral using LookUpTable_0
! InterpolateArraySetup    Compute coefficients for InterpolateUsingSetup
! InterpolateArrayTeardown Deallocate tables created by InterpolateArraySetup
! InterpolateExtrapolate   Like InterpolateValues, but extrapolate using
!                            average slope instead of slope at the end.
! Interpolate_Regular_To_Irregular 2D - to - 2D interpolation using composite
!                          1D interpolation
! InterpolateValues        Interpolate for new y value(s):
!                            given old (x,y), new (x), method
! Interpolate_2D_Composite 2D - to - 2D interpolation using composite 1D
!                          interpolation
! LinearInterpolate        Do a single linear interpolation in n dimensions
! PureHunt                 Like Hunt, but may be quicker due to optimization
! ReadLookUpTable          Read a LookUpTable from a text file
! Setup                    Fill y values in LookUpTable
! Simpsons                 Apply Simpson's rule to integrate--function form
! SimpsonsSub              Apply Simpson's rule to integrate--a subroutine
! UseLookUpTable           Use LookUpTable to approximate function
!                            (or its derivatives or its integral)
! WriteLookUpTable         Write a LookUpTable to a text file
! === (end of toc) ===

! === (start of api) ===
! nprec  AGM ( nprec x, nprec y )
! nprec  Average ( nprec A(:) )
! Battleship( int extern fun, int root, [int n1], [int maxPhase1], [int ns(:)], &
!    [int b], [char* options], [int status] )
! Battleship( log extern fun, int root, [int n1], [int maxPhase1], [int ns(:)], &
!    [log b], [char* options], [int status] )
! Battleship( nprec extern fun, nprec root, nprec arg1, nprec delta, &
!    [int maxPhase1], [int ns(:)], [int status] )
! BivariateLinearInterpolation ( real X_Basis(:), real Y_Basis(:),
!    real Table_2d(:,:), real X_Grid(:), real Y_Grid(:), real Out(:) )
! ClosestElement ( nprec test, nprec array, int indices, [char* options] )
! Destroy ( LookUpTable_0_nprec LkUpTable )
! nprec  dFdxApproximate ( nprec x, LookUpTable_0_nprec LkUpTable )
! nprec  d2Fdx2Approximate ( nprec x, LookUpTable_0_nprec LkUpTable )
! Dump ( coefficients_nprec Coeffs )
! Dump ( LookUpTable_0_nprec LkUpTable, [int Details] )
! nprec  F_Of_X
!         (see FApproximate and UseLookupTable)
! nprec  FApproximate ( nprec x, LookUpTable_0_nprec LkUpTable )
! nprec  FInvApproximate ( nprec y, LookUpTable_0_nprec LkUpTable, &
!     [nprec xS], [nprec xE] )
! FillLookUpTable ( nprec extern fun, nprec table(:), nprec x1, nprec x2, &
!   [int N], [nprec xtable(:)] )
! FindInRange ( num list(:), num vrange(2), int which(:), [how_many], [options] )
! FindInRange_2d ( num list(:,:), num vrange(2), int which(:,:), [how_many], [options] )
! Hunt ( nprec list, nprec values, int indices(:), &
!   [int start], [log allowTopValue], [log allowBelowValue], &
!   [log nearest], [log logSpace], [log fail] )
! HuntBox ( nprec gridPoints, int MGridPoints(:), nprec coords, int indices(:), &
!   [nprec vertices] )
! HuntRange ( num list(:), num vrange(2), int irange(2), options )
! nprec  IFApproximate ( LookUpTable_0_nprec LkUpTable, &
!     [nprec xS], [nprec xE] )
! InterpolateValues ( nprec oldX(:), nprec oldY(:), &
!   nprec newX(:), nprec newY(:), char* method, [char* extrapolate], &
!   [nprec badValue], [nprec rangeofperiod(2)], [log missingRegions], &
!   [nprec dyByDx(:), log skipNewY], [nprec IntYdX(:)] )
! InterpolateValues ( nprec oldX(:), nprec oldY(:,:), &
!   nprec newX(:), nprec newY(:,:), char* method, [char* extrapolate], &
!   [nprec badValue], [log missingRegions], [nprec dyByDx(:,:)], &
!   [MatrixElement_T dNewByDOld], [log skipNewY], [nprec IntYdX(:,:)] )
! Interpolate_2d_Composite ( XOld, YOld, ZOld, XNew, YNew, ZNew, &
!   XMethod, YMethod, [XExtrapolate], [YExtrapolate] )
! Interpolate_Regular_To_Irregular ( XOld, YOld, ZOld, &
!   XYNew, ZNew, XMethod, YMethod, [XExtrapolate], [YExtrapolate] )
! InterpolateArraySetup ( nprec OldX(:), nprec NewX(:), char* Method, &
!   coefficients_nprec Coeffs, &[log Extrapolate], [int Width], [log DyByDx],
!   [matrixElement_T dNewByDOld], [log IntYdX] )
! InterpolateArrayTeardown ( Coefficients_nprec Coeffs )
! nprec LinearInterpolate ( nprec values(:,:,..,:), nprec coords(:), &
!    nprec verts(:,:,..,:) )
! PureHunt ( nprec element, nprec array, int n, int jlo, int jhi )
! ReadLookUpTable ( char* filename, int n, nprec x(:), nprec y(:) )
! Setup ( LookUpTable_0_nprec LkUpTable, int N, nprec x1, nprec x2, [ nprec y(:)], &
!    [char* BC], [nprec yLeft], [nprec yRight], [extern nprec fun] )
! nprec Simpsons ( int n, nprec h, nprec y(:) )
! SimpsonsSub ( nprec y(:), nprec h, int n, nprec r )
! nprec UseLookUpTable ( nprec x, nprec table(:), [nprec x1], [nprec x2], &
!    [nprec xtable(:), [nprec missingValue], [char* options], &
!    [nprec xS], [nprec xE] )
! WriteLookUpTable ( char* filename, int n, nprec x(:), nprec y(:) )

! In the above types, "nprec" can be either r4 or r8. num can be any of
! int, r4, or r8. A, B, Precision, and array can be any 
! multidimensional arrays up to rank 3. In a scalar context A and B may be scalars
! === (end of api) ===

  public :: AGM, Average, Battleship, BivariateLinearInterpolation
  public :: ClosestElement
  public :: Destroy, dFdXApproximate, d2FdX2Approximate, Dump
  public :: F_Of_X, FApproximate, FindInRange, FinvApproximate
  public :: Hunt, HuntBox, HuntRange, IfApproximate
  public :: InterpolateArraySetup, InterpolateArrayTeardown
  public :: InterpolateExtrapolate
  public :: InterpolateExtrapolate_d, InterpolateExtrapolate_s
  public :: InterpolateScalar_r4, InterpolateScalar_r8
  public :: InterpolateValues
  public :: Interpolate_Regular_To_Irregular, Interpolate_2D_Composite
  public :: LinearInterpolate
  public :: PureHunt
  public :: Setup, Simpsons, SimpsonsSub, SolveQuadratic
  public :: FillLookupTable, ReadLookupTable, UseLookupTable, WriteLookupTable

  type, public :: Coefficients ( RK )
    integer, kind :: RK
    private
    !{ Coefficients for linear interpolation:  Let $\{x\} =$ {\tt oldX} and
    !  $\{\chi\} =$ {\tt newX}.  Then
    !  {\tt Gap(j)} $= g_j = x_{i+1}-x_i$, $A_j = \frac{x_{i+1}-\chi_j}{g_j}$,    
    !                                  and $B_j = 1-A_j = \frac{\chi_j-x_i}{g_j}$,
    !  where $i$ is such that $x_i \leq \chi_j < x_{i+1}$ for $1 \leq j \leq$
    !  {\tt size(newX)}.
    !  {\tt lowerInds} = $\{i\, |\, x_i \leq \chi_j < x_{i+1},\,1 \leq j \leq$
    !  {\tt size(newX)}$\}$.
    !  $|\{g\}| = |\{A\}| = |\{B\}|$, and
    !  others that depend upon them, $=|\{\chi\}|$ = {\tt size(newX)}.
    !  Coefficients for differentiation in the linear case (and of the linear
    !  terms in the spline case) are just $-1$ and $+1$, so they're not
    !  computed here.
    integer, allocatable :: LowerInds(:)
    real(rk), allocatable :: A(:), B(:), Gap(:)
    !{ Coefficients for spline interpolation:
    !  $C = (A^3-A) \frac{g^2}6$.  $D = (B^3-B) \frac{g^2}6$.
    real(rk), allocatable :: C(:), D(:)
    !{ {\tt dX(i)} $= \delta_i = x_i-x_{i-1}$ for $1 < i \leq$ {\tt size(oldX)} and
    !  $\Delta_i = x_{i+1}-x_{i-1} = \delta_i + \delta_{i+1}$ for $1 < i <$
    !  {\tt size(oldX)}.
    !  {\tt P(i)} $= p_i = \frac1{\delta_i o_{i-1} + 2 \Delta_i}$ and
    !  {\tt O(i)} $= o_i = -\delta_{i+1} p_i$
    !  for $1 < i <$ {\tt size(oldX)} and zero at the ends.
    !  $p_i$ is the inverse of the diagonal of $L$ in the $LU$ factorization
    !  of the symmetric tridiagonal linear system for splines, $\delta_i$ is
    !  the subdiagonal of $L$, and $o_i$ is the negative of the
    !  superdiagonal of $U$.  The nonzero part of each row of the original
    !  system is of the form $[\delta_{i-1},\, 2 \Delta_i ,\, \delta_i]$.
    !  See wvs-086.
    real(rk), allocatable :: dX(:), P(:), O(:)
    !{ In the periodic continuity case, {\tt Col} is the rightmost column of
    !  $U$ and {\tt Row} is the bottom row of $L$.  During the backsolve, the
    !  last element of {\tt Col} is used instead of the last element of $o$,
    !  and the last element of {\tt Row} is used instead of the last element
    !  of $\delta$.
    real(rk), allocatable :: Col(:), Row(:)
    !{ Coefficients for spline derivatives:
    !  $E = \frac{\text{d}C}{\text{d}A} = \frac6g \frac{\text{d}C}{\text{d}x}
    !     = 3 A^2 - 1$.
    !  $F = \frac{\text{d}D}{\text{d}A} = \frac6g \frac{\text{d}D}{\text{d}x}
    !     = 3 B^2 - 1$.
    real(rk), allocatable :: E(:), F(:)
    !{ Coefficients for integration:
    !  $\int A \text{d}x =  \frac{x(x_{i+1}-\frac{x}2)}g$.
    !  $\int B \text{d}x = -\frac{x(x_i    -\frac{x}2)}g
    !                    = x - \int A \text{d}x$.\\
    !  $\int C \text{d}x = -\frac{g^2}6
    !                      \left( \int A \text{d}x + \frac{g A^4}4 \right)$.
    !  $\int D \text{d}x = -\frac{g^2}6
    !                      \left( \int B \text{d}x - \frac{g B^4}4 \right)$.
    real(rk), allocatable :: AI(:), BI(:), &
      &                  CI(:), DI(:)
    ! Stuff for extrapolation == "B"ad
    logical, allocatable :: BadValue(:)
  end type Coefficients

  ! This is a family of datatypes, the Look Up Table:
  ! a list of function values y[i]
  ! evaluated over uniformly-spaced x-values x[i] ( = x1 + (i-1) dx )
  ! which some call a look up table
  ! (although that name unfairly limits its suggested use)
  ! In our usage it is an efficient alternative to the *LookupTable procedures
  ! implemented in this module, for they are not limited by requiring
  ! that the x-values be uniformly spaced (or even monotonic)
  
  ! By default when we use one of these datatypes to approximate the
  ! actual function at some x we 
  ! choose the corresponding y at the xi closest to x
  ! This behavior may be modified by the "method" field which may be one of
  ! ' '   choose whichever xi is closest to x          (default)
  ! 'l'   choose the lower of two xis closest to x
  ! 'u'   choose the upper of two xis closest to x
  ! 'i'   interpolate between two xis closest to x
  ! 'q'   quadratic interpolation (Simpson's rule)
  ! 's'   (cubic) splines (not efficiently implemented)

  ! Note that points outside the range of xi (i.e. less than the smallest
  ! or greater than the largest) are treated according to "BC" which may be
  ! 'clamped'   use y at the nearest xi                (default)                        
  ! 'cyclic'    assume y is cyclic with period (x2-x1) (how would we know?)          
  ! 'scyclic'   assume y is signed cyclic 
  !                    with half period (x2-x1)        (same question)          
  ! 'express'   use yLeft or yRight                    (of doubtful utility)                

  ! In cases where a conflict seems to arise between the actions
  ! dictated by "method" and "BC", "BC" will prevail

  ! Notes and limitations:
  ! Another family of datatypes may someday be needed,
  !    which would utilize non-uniformly spaced x values
  ! Another BC type may someday be needed,
  !    which would permit extrapolating x values outside [x1, x2] range

  type, public :: LookUpTable_0 ( RK )
    integer, kind :: RK
    integer :: N = 0                               ! The number of values xi
    character(len=8) :: BC = 'clamped'             ! boundary conditions
    character(len=1) :: method = ' '               ! which of closest xi to use
    real(rk) :: x1                                 ! x1 <= xi <= x2
    real(rk) :: x2
    real(rk) :: yLeft  = 0.                        ! Assume all x < x1 are this
    real(rk) :: yRight = 0.                        ! Assume all x > x2 are this
    real(rk), dimension(:), allocatable :: y       ! y(xi)
    ! type(Coefficients(rk)) :: Coeffs             ! in case we'll use splines
  contains
    procedure :: DestroyLookUpTable_0_r4
    procedure :: DestroyLookUpTable_0_r8
    generic   :: Destroy => destroyLookUpTable_0_r4, destroyLookUpTable_0_r8
    procedure :: DumpLookUpTable_0_r4
    procedure :: DumpLookUpTable_0_r8
    generic   :: Dump => DumpLookUpTable_0_r4, DumpLookUpTable_0_r8
    procedure :: setUpLookUpTable_0_r4
    procedure :: setUpLookUpTable_0_r8
    generic   :: Setup => setUpLookUpTable_0_r4, setUpLookUpTable_0_r8
  end type LookUpTable_0

  ! No need yet for a class member of this datatype yet
  ! type(LookUpTable_0(r8)), save :: MLSLkUpTable

  ! This data type
  ! (1) Relaxes the requirement that the x values are uniformly spaced
  !     although they must be sorted from smallest to largest
  ! (2) Includes optional polynomial interpolation via
  ! y[x] = a_0 + a_1 x + a_2 x^2 + .. + a_P x^P
  ! which is used only if P > 1
  
  ! However, we must decide, if N > P, among options (a) or (b)
  ! (a) choose only the P closest x values to uniquely determine a
  ! each time we are givin a new x
  ! (b) do a least squares over all y and x to cakculate a
  ! While similar in spirit to how we might imagine generalizing linear
  ! interpolation, (a) would be costly and sems to offer little value
  ! which (b) says we can calculate a just once and then go to town
  type, public, extends(LookUpTable_0) :: LookUpTable_1
    integer :: P = 0                               ! The degree of the polynomial
    real(rk), dimension(:), allocatable :: x       ! the x values
    real(rk), dimension(:), allocatable :: a       ! the a values
  end type LookUpTable_1


  interface AGM
    module procedure AGM_D, AGM_S
  end interface

  interface Average
    module procedure Average_D, Average_S
  end interface

  interface Battleship
    module procedure Battleship_int, Battleship_log, Battleship_r4, Battleship_r8
  end interface

  interface BivariateLinearInterpolation
    module procedure BivariateLinearInterp_D_D, BivariateLinearInterp_D_S
    module procedure BivariateLinearInterp_S_S
  end interface

  interface ClosestElement
    module procedure ClosestElement_r4_1d, ClosestElement_r8_1d
    module procedure ClosestElement_r4_2d, ClosestElement_r8_2d
    module procedure ClosestElement_r4_3d, ClosestElement_r8_3d
  end interface

  interface CreateXArray
    module procedure CreateXArray_r4, CreateXArray_r8
  end interface

  interface CSpline
    module procedure D_CSpline, S_CSpline
  end interface

  interface Destroy
    module procedure destroyLookUpTable_0_r4, destroyLookUpTable_0_r8
  end interface

  interface d2Fdx2Approximate
    module procedure d2Fdx2Approximate_r4, d2Fdx2Approximate_r8
  end interface

  interface dFdxApproximate
    module procedure dFdxApproximate_r4, dFdxApproximate_r8
  end interface

  interface Dump
    module procedure DumpCoefficients_r4, DumpCoefficients_r8
    module procedure DumpLookUpTable_0_r4, DumpLookUpTable_0_r8
  end interface

  interface F_Of_X
    module procedure FApproximate_r4, FApproximate_r8
    module procedure FLookup_r4, FLookup_r8
    module procedure FXYLookup_r4, FXYLookup_r8
  end interface

  interface FApproximate
    module procedure FApproximate_r4, FApproximate_r8
  end interface

  interface FInvApproximate
    module procedure FInvApproximate_r4, FInvApproximate_r8
  end interface

  interface FillLookUpTable
    module procedure FillLookUpTable_r4, FillLookUpTable_r8
  end interface

  interface FindInRange
    module procedure FindInRange_int, FindInRange_r4, FindInRange_r8
    module procedure FindInRange_2d_int, FindInRange_2d_r4, FindInRange_2d_r8
  end interface

  interface IFApproximate
    module procedure IFApproximate_r4, IFApproximate_r8
  end interface

  interface InterpolateArraySetup
    module procedure InterpolateArraySetup_r4, InterpolateArraySetup_r8
  end interface

  interface InterpolateExtrapolate
    module procedure InterpolateExtrapolate_d, InterpolateExtrapolate_d_1
    module procedure InterpolateExtrapolate_s, InterpolateExtrapolate_s_1
  end interface

  interface Interpolate_Regular_To_Irregular
    module procedure Interpolate_Regular_To_Irregular_r4, &
                     Interpolate_Regular_To_Irregular_r8
  end interface

  interface InterpolateArrayTeardown
    module procedure InterpolateArrayTeardown_r4, InterpolateArrayTeardown_r8
  end interface

  interface InterpolateValues
    module procedure InterpolateArray_r4, InterpolateArray_r8
    module procedure InterpolateScalar_r4, InterpolateScalar_r8
    module procedure InterpolateUsingSetup_r4, InterpolateUsingSetup_r8
    module procedure InterpolateScalarUsingSetup_r4, InterpolateScalarUsingSetup_r8
    module procedure Interp_Bilinear_2d_1d_r4, Interp_Bilinear_2d_1d_r8
  end interface

  interface Interpolate_2d_Composite
    module procedure Interpolate_2d_Composite_r4, Interpolate_2d_Composite_r8
  end interface

  interface LinearInterpolate
    module procedure LinearInterpolate_1d_r4, LinearInterpolate_1d_r8
    module procedure LinearInterpolate_2d_r4, LinearInterpolate_2d_r8
    module procedure LinearInterpolate_3d_r4, LinearInterpolate_3d_r8
    module procedure LinearInterpolate_4d_r4, LinearInterpolate_4d_r8
  end interface

  interface pcspl
    module procedure D_PCSPL, S_PCSPL
  end interface

  interface psimpsons
    module procedure psimpsons_r4, psimpsons_r8
  end interface

  interface reposit
    module procedure reposit_r4, reposit_r8
  end interface

  interface ReadLookUpTable
    module procedure ReadLookUpTable_r4, ReadLookUpTable_r8
  end interface
  
  interface SetUp
    module procedure InterpolateArraySetup_r4, InterpolateArraySetup_r8
    module procedure setUpLookUpTable_0_r4, setUpLookUpTable_0_r8
  end interface

  interface Simpsons
    module procedure Simpsons_r4, Simpsons_r8
  end interface

  interface SimpsonsSub
    module procedure Simps_r4, Simps_r8
  end interface

  interface SolveQuadratic
    module procedure SolveQuadratic_r4, SolveQuadratic_r8
  end interface

  interface UseLookUpTable
    module procedure UseLookUpTable_r4, UseLookUpTable_r8
  end interface
  
  interface WriteLookUpTable
    module procedure WriteLookUpTable_r4, WriteLookUpTable_r8
  end interface

  ! These are arrays in name only used when implementing cubic splines
  real, private, dimension(1) :: newYr4, newdYr4
  double precision, private, dimension(1) :: newYr8, newdYr8
  
  ! Parameters used in the AGM functions
  integer, parameter                      :: MAXITER = 20

contains

! -------------------------------------------------  AGM  -----
! Return the arithmetic-geometric mean
! Given two numbers, form the sequences
! a_n, g_n
! a[0] = x
! g[0] = y
! a[i+1] = (a[i]+g[i])/2
! g[i+1] = sqrt(a[i]*g[i])
! Find the limit as i -> Inf
  double precision function AGM_D ( x, y ) result ( R )
    double precision, intent(in) :: x, y
    ! Internal variables
    integer                      :: i
    double precision             :: a0, g0, ai, gi, eps
    include 'AGM.f9h'
  end function AGM_D

  real function AGM_S ( x, y ) result ( R )
    real, intent(in)             :: x, y
    ! Internal variables
    integer                      :: i
    real                         :: a0, g0, ai, gi, eps
    include 'AGM.f9h'
  end function AGM_S

! -------------------------------------------------  Average  -----
! Return the arithmetic mean
! If you want the geometric mean instead, you can use this formula
!   geom_mean = exp ( Average( Log (a) ) )
! Assuming all a > 0
  double precision function Average_D ( A ) result ( R )
    double precision, intent(in) :: A(:)
    r = sum(a) / size(a)
  end function Average_D

  real function Average_S ( A ) result ( R )
    real, intent(in) :: A(:)
    r = sum(a) / size(a)
  end function Average_S

! -------------------------------------------------  Battleship  -----

  ! This family of routines finds a root of a function
  ! by repeatedly evaluating it. Each evaluation is a "shot". What we consider
  ! a "hit" depends on the options parameter (see below).
  ! Warning--the default behavior is not the usual root-finder's
  ! (+ve on one side, -ve on the other)
  ! Instead what we do is this:
  !
  ! A returned value
  ! of "0" (or the optional parameter b) is short. Any other value is long.
  ! The root is the longest argument that is still short.
  ! (If you instead wish the shortest argument still long just add 1
  ! or utilize the options string)

  ! Example: a direct-access read of n chars from a file where the iostatus
  ! is 0 if we don't try to read too many chars, but non-zero if we do
  ! Create your own function that takes the number of chars to be read
  ! as its sole argument and that returns the iostat as its value
  ! Battleship will then calculate the exact number characters in the file
  ! (which NAG cares about; Lahey doesn't care)

  ! If you wish to do the usual root-finder where the returned values change
  ! sign, set the options appropriately to "-x"

  ! Method:
  ! We take shots during 2 phases:
  ! (1) outbound: ever-widening circles of radius 1 2 4 8 .. (n) (2n) ..
  !     or else prescribed shots in array ns[:]
  ! (2) inbound: once root is crossed, ever narowing circles around it
  !     (until "You sank my battleship!")

  ! The options string (if supplied) modifies how this search operates
  !  options            search goal
  !  -------            -----------
  !    -s (default)     largest root for which fun(root) = 0 (or b)
  !                      (useful for io status)
  !    -r               reverse of "-s"
  !                       i.e., all tests return non-zero below root
  !    -x               root where f(root) crosses 0 (or b)
  !                      (assumes (fun(n)-b) changes sign at n=root)

  ! It can also be used with a logical-valued function
  ! in this case we shoot until we encounter TRUE
  ! similar to integer-value version if we make the mapping
  ! 0 -> FALSE
  ! 1 -> TRUE
  ! -r option or b can be used to reverse the sense

  ! A version for use with real-valued functions can be
  ! operated as a root-finder where the root is
  ! desired to be found within a tolerance of delta
  ! The real-valued version won't be as precise or as efficient
  ! as, say, the Zero subroutine in the Zero_m module
  
  ! A generalization of the Binary Search Algorithm to
  ! two phases (outbound to first bracket the target, then inbound)

  subroutine Battleship_int( fun, root, n1, maxPhase1, ns, b, options, status )
    ! Args
    integer, external                          :: fun
    integer, optional, intent(in)              :: n1 ! 1st circle
    integer, optional, intent(in)              :: maxPhase1 ! max phase1 shots
    integer, optional, dimension(:), intent(in):: ns ! array of phase1 shots
    integer, intent(out)                       :: root ! root
    integer, optional, intent(in)              :: b ! is short
    character(len=*), optional, intent(in)     :: options
    integer, optional, intent(out)             :: status ! /= 0 if failed
    ! Internal variables
    integer :: flast
    integer :: fnext
    integer :: isShort
    character(len=8) :: myOptions
    integer :: shot
    integer :: x0
    integer :: x1
    integer :: x2
    ! Executable
    isShort = 0
    if ( present(b) ) isShort = b
    myOptions = '-s'
    if ( present(options) ) myOptions = options
    root = -1 ! in case we can't find root
    if ( present(status) ) status = 1
    ! Phase 1
    ! Some error checks
    if ( present(maxPhase1) ) then
      if ( (index(myOptions, 's') > 0 .and. fun(n1) /= isShort) ) return
      if ( (index(myOptions, 'r') > 0 .and. fun(n1) == isShort) ) return
      if ( maxPhase1 < 1 ) return
      if ( .not. present(n1) ) return
      x2 = n1 ! Initialize things
      fnext = fun(x2)
      do shot = 1, maxPhase1
        x1 = x2
        x2 = 2*x1
        flast = fnext
        fnext = fun(x2)
        if ( index(myOptions, 's') > 0 ) then
          if ( fnext /= isShort ) exit
        elseif ( index(myOptions, 'r') > 0 ) then
          if ( fnext == isShort ) exit
        else
          if ( (fnext-isShort)*(flast-isShort) <= 0 ) exit
        end if
      enddo
      if ( shot > maxPhase1 ) return ! No shot was long enough
    else
      if ( .not. present(ns) ) return
      x2 = ns(1) ! Initialize things
      fnext = fun(x2)
      if ( (index(myOptions, 's') > 0 .and. fnext /= isShort) ) return
      if ( (index(myOptions, 'r') > 0 .and. fnext == isShort) ) return
      do shot = 2, size(ns)
        x1 = x2
        x2 = ns(shot)
        flast = fnext
        fnext = fun(x2)
        if ( index(myOptions, 's') > 0 ) then
          if ( fnext /= isShort ) exit
        elseif ( index(myOptions, 'r') > 0 ) then
          if ( fnext == isShort ) exit
        else
          if ( (fnext-isShort)*(flast-isShort) <= 0 ) exit
        end if
      enddo
      if ( shot > size(ns) ) return ! No shot was long enough
    end if
    ! Phase 2
    if ( present(status) ) status = 0
    ! Narrow the spashes, always keeping root between x0 and x2
    x0 = x1
    do
      x1 = (x0 + x2) / 2
      ! This test should prevent us from looping endlessly
      if ( x1 == x0 ) then
        ! apparently x0 = x2 - 1, so we've found our root
        if ( index(myOptions, 's') > 0 .or. index(myOptions, 'r') > 0 ) then
          root = x1
        else
          if ( fun(x1) == isShort ) then
            root = x1
          elseif ( fun(x2) == isShort ) then
            root = x2
          else
            root = -1
          end if
        end if
        return
      end if
      if ( index(myOptions, 's') > 0 ) then
        if ( fun(x1) == isShort ) then
          x0 = x1
          ! x2 = x2
        else
          ! x0 = x0
          x2 = x1
        end if
      elseif ( index(myOptions, 'r') > 0 ) then
        if ( fun(x1) == isShort ) then
          ! x0 = x0
          x2 = x1
        else
          x0 = x1
          ! x2 = x2
        end if
      else
        if ( (fun(x2)-isShort)*(fun(x1)-isShort) == 0 ) then
          if ( fun(x2) == isShort ) then
            root = x2
          else
            root = x1
          end if
          return
        elseif ( (fun(x2)-isShort)*(fun(x1)-isShort) < 0 ) then
          x0 = x1
        else
          x2 = x1
        end if
      end if
    enddo
  end subroutine Battleship_int

  subroutine Battleship_log( fun, root, n1, maxPhase1, ns, b, options, status )
    ! Args
    logical, external                          :: fun
    integer, optional, intent(in)              :: n1 ! 1st circle
    integer, optional, intent(in)              :: maxPhase1 ! max phase1 shots
    integer, optional, dimension(:), intent(in):: ns ! array of phase1 shots
    integer, intent(out)                       :: root ! root
    logical, optional, intent(in)              :: b ! is short
    character(len=*), optional, intent(in)     :: options
    integer, optional, intent(out)             :: status ! /= 0 if failed
    ! Internal variables
    logical :: flast
    logical :: fnext
    logical :: isShort
    character(len=8) :: myOptions
    integer :: shot
    integer :: x0
    integer :: x1
    integer :: x2
    ! Executable
    isShort = .FALSE.
    if ( present(b) ) isShort = b
    myOptions = '-s'
    if ( present(options) ) myOptions = options
    root = -1 ! in case we can't find root
    if ( present(status) ) status = 1
    ! Phase 1
    ! Some error checks
    if ( present(maxPhase1) ) then
      if ( (index(myOptions, 's') > 0 .and. ( fun(n1) .neqv. isShort) ) ) return
      if ( (index(myOptions, 'r') > 0 .and. ( fun(n1) .eqv. isShort) ) ) return
      if ( maxPhase1 < 1 ) return
      if ( .not. present(n1) ) return
      x2 = n1 ! Initialize things
      fnext = fun(x2)
      do shot = 1, maxPhase1
        x1 = x2
        x2 = 2*x1
        flast = fnext
        fnext = fun(x2)
        if ( index(myOptions, 's') > 0 ) then
          if ( fnext .neqv. isShort ) exit
        elseif ( index(myOptions, 'r') > 0 ) then
          if ( fnext .eqv. isShort ) exit
        else
          if ( fnext .neqv. flast ) exit
        end if
      enddo
      if ( shot > maxPhase1 ) return ! No shot was long enough
    else
      if ( .not. present(ns) ) return
      x2 = ns(1) ! Initialize things
      fnext = fun(x2)
      if ( (index(myOptions, 's') > 0 .and. ( fnext .neqv. isShort ) ) ) return
      if ( (index(myOptions, 'r') > 0 .and. ( fnext .eqv. isShort) ) ) return
      do shot = 2, size(ns)
        x1 = x2
        x2 = ns(shot)
        flast = fnext
        fnext = fun(x2)
        if ( index(myOptions, 's') > 0 ) then
          if ( fnext .neqv. isShort ) exit
        elseif ( index(myOptions, 'r') > 0 ) then
          if ( fnext .eqv. isShort ) exit
        else
          if ( fnext .neqv. flast ) exit
        end if
      end do
      if ( shot > size(ns) ) return ! No shot was long enough
    end if
    ! Phase 2
    if ( present(status) ) status = 0
    ! Narrow the spashes, always keeping root between x0 and x2
    x0 = x1
    do
      x1 = (x0 + x2) / 2
      ! This test should prevent us from looping endlessly
      if ( x1 == x0 ) then
        ! apparently x0 = x2 - 1, so we've found our root
        if ( index(myOptions, 's') > 0 .or. index(myOptions, 'r') > 0 ) then
          root = x1
        else
          if ( fun(x1) .eqv. isShort ) then
            root = x1
          elseif ( fun(x2) .eqv. isShort ) then
            root = x2
          else
            root = -1
          end if
        end if
        return
      end if
      if ( index(myOptions, 's') > 0 ) then
        if ( fun(x1) .eqv. isShort ) then
          x0 = x1
          ! x2 = x2
        else
          ! x0 = x0
          x2 = x1
        end if
      elseif ( index(myOptions, 'r') > 0 ) then
        if ( fun(x1) .eqv. isShort ) then
          ! x0 = x0
          x2 = x1
        else
          x0 = x1
          ! x2 = x2
        end if
      else
        if ( (fun(x2) .eqv. isShort) .or. (fun(x1) .eqv. isShort) ) then
          if ( fun(x2) .eqv. isShort ) then
            root = x2
          else
            root = x1
          end if
          return
        elseif ( fun(x2) .neqv. fun(x1) ) then
          x0 = x1
        else
          x2 = x1
        end if
      end if
    enddo
  end subroutine Battleship_log

  subroutine Battleship_r4( fun, root, arg1, delta, maxPhase1, ns, status )
    integer, parameter :: RK = kind(0.0e0)
      include "Battleship.f9h"
  end subroutine Battleship_r4

  subroutine Battleship_r8( fun, root, arg1, delta, maxPhase1, ns, status )
    integer, parameter :: RK = kind(0.0d0)
      include "Battleship.f9h"
  end subroutine Battleship_r8

! ------------------------------------  BivariateLinearInterp_D_D  -----
  subroutine BivariateLinearInterp_D_D ( X_Basis, Y_Basis, Table_2d, &
      & X_Grid, Y_Grid, Out )

      ! Interpolate linearly in Table_2d whose coordinates are (X_Basis,Y_Basis),
      ! which are assumed to be sorted, to Out at each (X_Grid,Y_Grid), which
      ! are not necessarily sorted.  The Hunt routine assumes X_Grid and Y_Grid
      ! change slowly and smoothly.

      integer, parameter :: KT = kind(0.0d0) ! Kind for table and basis
      integer, parameter :: KO = kind(0.0d0) ! Kind for out and grids

      ! Extents for Table_2d are (size(X_basis,1),size(Y_Basis,1))
      real(kt), intent(in) :: X_Basis(:), Y_Basis(:), Table_2D(:,:)

      ! Extents for X_Grid, Y_Grid, Out are all the same.
      real(ko), intent(in) :: X_Grid(:), Y_Grid(:)
      real(ko), intent(out) :: Out(:)

      include "BivariateLinearInterpolation.f9h"

    end subroutine BivariateLinearInterp_D_D

! ------------------------------------  BivariateLinearInterp_D_S  -----
  subroutine BivariateLinearInterp_D_S ( X_Basis, Y_Basis, Table_2d, &
      & X_Grid, Y_Grid, Out )

      ! Interpolate linearly in Table_2d whose coordinates are (X_Basis,Y_Basis),
      ! which are assumed to be sorted, to Out at each (X_Grid,Y_Grid), which
      ! are not necessarily sorted.  The Hunt routine assumes X_Grid and Y_Grid
      ! change slowly and smoothly.

      integer, parameter :: KT = kind(0.0d0) ! Kind for table and basis
      integer, parameter :: KO = kind(0.0e0) ! Kind for out and grids

      ! Extents for Table_2d are (size(X_basis,1),size(Y_Basis,1))
      real(kt), intent(in) :: X_Basis(:), Y_Basis(:), Table_2D(:,:)

      ! Extents for X_Grid, Y_Grid, Out are all the same.
      real(ko), intent(in) :: X_Grid(:), Y_Grid(:)
      real(ko), intent(out) :: Out(:)

      include "BivariateLinearInterpolation.f9h"

    end subroutine BivariateLinearInterp_D_S

! ------------------------------------  BivariateLinearInterp_S_S  -----
  subroutine BivariateLinearInterp_S_S ( X_Basis, Y_Basis, Table_2d, &
      & X_Grid, Y_Grid, Out )

      ! Interpolate linearly in Table_2d whose coordinates are (X_Basis,Y_Basis),
      ! which are assumed to be sorted, to Out at each (X_Grid,Y_Grid), which
      ! are not necessarily sorted.  The Hunt routine assumes X_Grid and Y_Grid
      ! change slowly and smoothly.

      integer, parameter :: KT = kind(0.0e0) ! Kind for table and basis
      integer, parameter :: KO = kind(0.0e0) ! Kind for out and grids

      ! Extents for Table_2d are (size(X_basis,1),size(Y_Basis,1))
      real(kt), intent(in) :: X_Basis(:), Y_Basis(:), Table_2D(:,:)

      ! Extents for X_Grid, Y_Grid, Out are all the same.
      real(ko), intent(in) :: X_Grid(:), Y_Grid(:)
      real(ko), intent(out) :: Out(:)

      include "BivariateLinearInterpolation.f9h"

    end subroutine BivariateLinearInterp_S_S

! -----------------------------------------------  ClosestElement  -----

  ! This family of routines finds the element within a multidimensional
  ! array nearest a test value
  ! The array of indices locate that nearest element
  ! The following options really make sense only for 1-d searches
  ! and so are ignored for arrays of rank 2 or higher

  ! options  none, one, or more of the following:
  ! (default)   choose pt in array closest to x
  !   l         always choose lower of two closest x's in array
  !   u         always choose upper of two closest x's in array
  !   p         assume array is presorted so array[i] < array[i+1]
  !              (greatly speeds up search)

  subroutine ClosestElement_r4_1d ( test, array, indices, options )
    integer, parameter :: RK = kind(0.0e0)

    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    include "ClosestElement.f9h"

  end subroutine ClosestElement_r4_1d

  subroutine ClosestElement_r8_1d ( test, array, indices, options )
    integer, parameter :: RK = R8

    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    include "ClosestElement.f9h"

  end subroutine ClosestElement_r8_1d

  subroutine ClosestElement_r4_2d ( test, array, indices, options )
    integer, parameter :: RK = R4

    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:,:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    integer, dimension(1)              :: indices_1d ! Result
    call ClosestElement( test, &
      & reshape(array, (/ size(array,1)*size(array,2) /) ), &
      & indices_1d )
    call rerank( indices_1d(1), shape(array), indices )
  end subroutine ClosestElement_r4_2d

  subroutine ClosestElement_r8_2d ( test, array, indices, options )
    integer, parameter :: RK = kind(0.0d0)

    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:,:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    integer, dimension(1)              :: indices_1d ! Result
    call ClosestElement( test, &
      & reshape(array, (/ size(array,1)*size(array,2) /) ), &
      & indices_1d )
    call rerank( indices_1d(1), shape(array), indices )
  end subroutine ClosestElement_r8_2d

  subroutine ClosestElement_r4_3d ( test, array, indices, options )
    integer, parameter :: RK = kind(0.0e0)

    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:,:,:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    integer, dimension(1)              :: indices_1d ! Result
    call ClosestElement( test, &
      & reshape(array, (/ size(array,1)*size(array,2)*size(array,3) /) ), &
      & indices_1d )
    call rerank( indices_1d(1), shape(array), indices )
  end subroutine ClosestElement_r4_3d

  subroutine ClosestElement_r8_3d ( test, array, indices, options )
    integer, parameter :: RK = kind(0.0d0)

    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:,:,:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    integer, dimension(1)              :: indices_1d ! Result
    call ClosestElement( test, &
      & reshape(array, (/ size(array,1)*size(array,2)*size(array,3) /) ), &
      & indices_1d )
    call rerank( indices_1d(1), shape(array), indices )
  end subroutine ClosestElement_r8_3d

! ------------------------------------------------------  Destroy  -----

  ! This family of routines deallocates a LookUpTable's arrays
  ! We ought to do this for both _0 and _1 levels
  subroutine destroyLookUpTable_0_r4 ( LkUpTable )
    ! Args
    class(LookUpTable_0(r4)) :: LkUpTable ! Intent(out) would clobber retainable values
    ! Executable
    LkUpTable%N       = 0
    call deallocate_test ( LkUpTable%y, "LkUpTable%y", ModuleName )
  end subroutine destroyLookUpTable_0_r4

  subroutine destroyLookUpTable_0_r8 ( LkUpTable )
    ! Args
    class(LookUpTable_0(r8)) :: LkUpTable ! Intent(out) would clobber retainable values
    ! Executable
    LkUpTable%N       = 0
    call deallocate_test ( LkUpTable%y, "LkUpTable%y", ModuleName )
  end subroutine destroyLookUpTable_0_r8

! --------------------------------------------  d2Fdx2Approximate  -----

  ! This family of routines use a LookUpTable to approximate a 
  ! function's 2nd derivative

  ! Args: (* means optional)
  ! x        pt at which to evaluate
  ! LkUpTable      the Look Up Table type

  function d2Fdx2Approximate_r4 ( x, LkUpTable ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    ! Args
    real(rk), intent(in)                 :: x
    type(LookUpTable_0(r4)), intent(in)       :: LkUpTable
    real(rk)                             :: value
    ! Internal variables
    real(rk) :: arg
    integer  :: itsSign
    character :: options
    real(rk), dimension(:), pointer      :: xArray => null()
    ! Executable
    call reposit( x, LkUpTable, arg, itsSign )
    options = LkUpTable%method
    if ( options == 'q' ) options = '2'
    if ( arg < LkUpTable%x1 ) then
      value = 0.
    elseif ( arg > LkUpTable%x2 ) then
      value = 0.
    elseif ( options == '/s/' ) then ! How to calculate spline's 2nd der?
      call createXArray( xArray, LkUpTable )
      call InterpolateValues( xArray, LkUpTable%y, (/arg/), newYr4, dyByDx=newdYr4, &
        & method='S' )
      value = newdYr4(1)
      call deallocate_test( xArray, 'xArray (r4)', ModuleName )
    else
      value = UseLookUpTable ( arg, LkUpTable%y, LkUpTable%x1, LkUpTable%x2, options=options // '2' )
    end if
    value = itsSign*value
  end function d2Fdx2Approximate_r4

  function d2Fdx2Approximate_r8 ( x, LkUpTable ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    ! Args
    real(rk), intent(in)                 :: x
    type(LookUpTable_0(r8)), intent(in)       :: LkUpTable
    real(rk)                             :: value
    ! Internal variables
    real(rk) :: arg
    integer  :: itsSign
    character :: options
    real(rk), dimension(:), pointer      :: xArray => null()
    ! Executable
    call reposit( x, LkUpTable, arg, itsSign )
    options = LkUpTable%method
    if ( options == 'q' ) options = '2'
    if ( arg < LkUpTable%x1 ) then
      value = 0.
    elseif ( arg > LkUpTable%x2 ) then
      value = 0.
    elseif ( options == '/s/' ) then ! How to calculate spline's 2nd der?
      call createXArray( xArray, LkUpTable )
      call InterpolateValues( xArray, LkUpTable%y, (/arg/), newYr8, dyByDx=newdYr8, &
        & method='S' )
      value = newdYr8(1)
      call deallocate_test( xArray, 'xArray (r8)', ModuleName )
    else
      value = UseLookUpTable ( arg, LkUpTable%y, LkUpTable%x1, LkUpTable%x2, options=options // '2' )
    end if
    value = itsSign*value
  end function d2Fdx2Approximate_r8

! ----------------------------------------------  dFdxApproximate  -----

  ! This family of routines use a LookUpTable to approximate a 
  ! function's derivative

  ! Args: (* means optional)
  ! x        pt at which to evaluate
  ! LkUpTable      the Look Up Table type

  function dFdxApproximate_r4 ( x, LkUpTable ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    ! Args
    real(rk), intent(in)                 :: x
    type(LookUpTable_0(r4)), intent(in)       :: LkUpTable
    real(rk)                             :: value
    ! Internal variables
    real(rk) :: arg
    integer  :: itsSign
    character :: options
    real(rk), dimension(:), pointer      :: xArray => null()
    ! Executable
    call reposit( x, LkUpTable, arg, itsSign )
    options = LkUpTable%method
    if ( options == 'q' ) options = '1'
    if ( arg < LkUpTable%x1 ) then
      value = 0.
    elseif ( arg > LkUpTable%x2 ) then
      value = 0.
    elseif ( options == 's' ) then
      call createXArray( xArray, LkUpTable )
      call InterpolateValues( xArray, LkUpTable%y, (/arg/), newYr4, dyByDx=newdYr4, &
        & method='S' )
      value = newdYr4(1)
      call deallocate_test( xArray, 'xArray (r4)', ModuleName )
    else
      value = UseLookUpTable ( arg, LkUpTable%y, LkUpTable%x1, LkUpTable%x2, options=options // '1' )
    end if
    value = itsSign*value
  end function dFdxApproximate_r4

  function dFdxApproximate_r8 ( x, LkUpTable ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    ! Args
    real(rk), intent(in)                 :: x
    type(LookUpTable_0(r8)), intent(in)       :: LkUpTable
    real(rk)                             :: value
    ! Internal variables
    real(rk) :: arg
    integer  :: itsSign
    character :: options
    real(rk), dimension(:), pointer      :: xArray => null()
    ! Executable
    call reposit( x, LkUpTable, arg, itsSign )
    options = LkUpTable%method
    if ( options == 'q' ) options = '1'
    if ( arg < LkUpTable%x1 ) then
      value = 0.
    elseif ( arg > LkUpTable%x2 ) then
      value = 0.
    elseif ( options == 's' ) then
      call createXArray( xArray, LkUpTable )
      call InterpolateValues( xArray, LkUpTable%y, (/arg/), newYr8, dyByDx=newdYr8, &
        & method='S' )
      value = newdYr8(1)
      call deallocate_test( xArray, 'xArray (r8)', ModuleName )
    else
      value = UseLookUpTable ( arg, LkUpTable%y, LkUpTable%x1, LkUpTable%x2, options=options // '1' )
    end if
    value = itsSign*value
  end function dFdxApproximate_r8

! ---------------------------------------------------------  Dump  -----
  subroutine DumpCoefficients_r4 ( Coeffs, Name )
    type(coefficients(r4)), intent(in) :: Coeffs
    character(len=*), optional, intent(in) :: Name
    include 'DumpCoefficients.f9h'
  end subroutine DumpCoefficients_r4

  subroutine DumpCoefficients_r8 ( Coeffs, Name )
    type(coefficients(r8)), intent(in) :: Coeffs
    character(len=*), optional, intent(in) :: Name
    include 'DumpCoefficients.f9h'
  end subroutine DumpCoefficients_r8

  ! We ought to do this for both _0 and _1 levels
  subroutine DumpLookUpTable_0_r4 ( LkUpTable, name, details )
    ! Args
    class(LookUpTable_0(r4)) :: LkUpTable ! Intent(out) would clobber retainable values
    character(len=*), optional, intent(in) :: name
    integer, optional, intent(in) :: details
    ! Internal variables
    integer :: myDetails
    ! Executable
    myDetails = 0
    if ( present(details) ) myDetails = details
    if ( present(name) ) call output( trim(name) // ' ', advance='no' )
    call output( 'uniform discrete function (r4)', advance='yes' )
    call blanks( 32, fillchar='-', advance='yes' )
    call outputNamedValue( 'N           ', LkUpTable%N             )
    call outputNamedValue( 'x1          ', LkUpTable%x1            )
    call outputNamedValue( 'x2          ', LkUpTable%x2            )
    call outputNamedValue( 'BC          ', LkUpTable%BC            )
    call outputNamedValue( 'method      ', LkUpTable%method        )
    call outputNamedValue( 'yLeft       ', LkUpTable%yLeft         )
    call outputNamedValue( 'yRight      ', LkUpTable%yRight        )
    if ( .not. allocated(LkUpTable%y) ) then
      call output( '(y values not associated)', advance='yes' )
      return
    end if
    if ( myDetails < 1 ) then
      call outputNamedValue( 'min(y)           ', minval(LkUpTable%y) )
      call outputNamedValue( 'max(y)           ', maxval(LkUpTable%y) )
      return
    end if
    call dump ( LkUpTable%y, name='y' )
  end subroutine DumpLookUpTable_0_r4

  subroutine DumpLookUpTable_0_r8 ( LkUpTable, name, details )
    ! Args
    class(LookUpTable_0(r8)) :: LkUpTable ! Intent(out) would clobber retainable values
    character(len=*), optional, intent(in) :: name
    integer, optional, intent(in) :: details
    ! Internal variables
    integer :: myDetails
    ! Executable
    myDetails = 0
    if ( present(details) ) myDetails = details
    if ( present(name) ) call output( trim(name) // ' ', advance='no' )
    call output( 'uniform discrete function (r8)', advance='yes' )
    call blanks( 32, fillchar='-', advance='yes' )
    call outputNamedValue( 'N           ', LkUpTable%N             )
    call outputNamedValue( 'x1          ', LkUpTable%x1            )
    call outputNamedValue( 'x2          ', LkUpTable%x2            )
    call outputNamedValue( 'BC          ', LkUpTable%BC            )
    call outputNamedValue( 'method      ', LkUpTable%method        )
    call outputNamedValue( 'yLeft       ', LkUpTable%yLeft         )
    call outputNamedValue( 'yRight      ', LkUpTable%yRight        )
    if ( .not. allocated(LkUpTable%y) ) then
      call output( '(y values not associated)', advance='yes' )
      return
    end if
    if ( myDetails < 1 ) then
      call outputNamedValue( 'min(y)           ', minval(LkUpTable%y) )
      call outputNamedValue( 'max(y)           ', maxval(LkUpTable%y) )
      return
    end if
    call dump ( LkUpTable%y, name='y' )
  end subroutine DumpLookUpTable_0_r8
! -------------------------------------------------  FLookup_r4  -----

  ! This family of routines uses lookup tables to approximate F

  ! Args: (* means optional)
  ! x        pt at which to evaluate
  ! x1, x2   (if present) lower, upper bounds of x range
  ! xtable   (if present) x values (should be monotonic)
  ! ytable   y values

  function FLookup_r4 ( x, x1, x2, ytable, options ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    ! Args
    real(rk), intent(in)                        :: x
    real(rk), dimension(:), intent(in)          :: ytable
    real(rk), intent(in)                        :: x1
    real(rk), intent(in)                        :: x2
    character(len=*), optional, intent(in)      :: options
    real(rk)                                    :: value    ! x are presorted
    value = UseLookUpTable_r4 ( x, ytable, x1, x2, options=options )
  end function FLookup_r4

  function FLookup_r8 ( x, x1, x2, ytable, options ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    ! Args
    real(rk), intent(in)                        :: x
    real(rk), dimension(:), intent(in)          :: ytable
    real(rk), intent(in)                        :: x1
    real(rk), intent(in)                        :: x2
    character(len=*), optional, intent(in)      :: options
    real(rk)                                    :: value    ! x are presorted
    value = UseLookUpTable_r8 ( x, ytable, x1, x2, options=options )
  end function FLookup_r8

  function FXYLookup_r4 ( x, xtable, ytable, options ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    ! Args
    real(rk), intent(in)                        :: x
    real(rk), dimension(:), intent(in)          :: xtable
    real(rk), dimension(:), intent(in)          :: ytable
    character(len=*), optional, intent(in)      :: options
    real(rk)                                    :: value    ! x are presorted
    value = UseLookUpTable_r4 ( x, ytable, xtable=xtable, &
      & options=Default(options, '-p', additional=.true.) )
  end function FXYLookup_r4

  function FXYLookup_r8 ( x, xtable, ytable, options ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    ! Args
    real(rk), intent(in)                        :: x
    real(rk), dimension(:), intent(in)          :: xtable
    real(rk), dimension(:), intent(in)          :: ytable
    character(len=*), optional, intent(in)      :: options
    real(rk)                                    :: value    ! x are presorted
    value = UseLookUpTable_r8 ( x, ytable, xtable=xtable, &
      & options=Default(options, '-p', additional=.true.) )
  end function FXYLookup_r8
    
! -------------------------------------------------  FApproximate  -----

  ! This family of routines use a LookUpTable to approximate a 
  ! (costly-to-evaluate) function based on its values at a set of points

  ! Args: (* means optional)
  ! x        pt at which to evaluate
  ! LkUpTable      the Look Up Table type

  function FApproximate_r4 ( x, LkUpTable ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    ! Args
    real(rk), intent(in)                 :: x
    type(LookUpTable_0(r4)), intent(in)       :: LkUpTable
    real(rk)                             :: value
    ! Internal variables
    real(rk) :: arg
    integer  :: itsSign
    character :: options
    real(rk), dimension(:), pointer      :: xArray => null()
    ! Executable
    call reposit( x, LkUpTable, arg, itsSign )
    ! call outputNamedValue( 'x', x )
    ! call outputNamedValue( 'arg', arg )
    ! call outputNamedValue( 'itsSign', itsSign )
    options = LkUpTable%method
    if ( options == 'q' ) options = '0'
    if ( arg < LkUpTable%x1 ) then
      value = LkUpTable%yLeft
    elseif ( arg == LkUpTable%x1 ) then
      value = LkUpTable%y(1)
    elseif ( arg == LkUpTable%x2 ) then
      value = LkUpTable%y(LkUpTable%N)
    elseif ( arg > LkUpTable%x2 ) then
      value = LkUpTable%yRight
    elseif ( options == 's' ) then
      call createXArray( xArray, LkUpTable )
      call InterpolateValues( xArray, LkUpTable%y, (/arg/), newYr4, method='S' )
      value = newYr4(1)
      call deallocate_test( xArray, 'xArray (r4)', ModuleName )
    else
      ! call outputNamedValue( 'options', options )
      value = UseLookUpTable ( arg, LkUpTable%y, LkUpTable%x1, LkUpTable%x2, options=options )
    end if
    value = itsSign*value
  end function FApproximate_r4

  function FApproximate_r8 ( x, LkUpTable ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    ! Args
    real(rk), intent(in)                 :: x
    type(LookUpTable_0(r8)), intent(in)       :: LkUpTable
    real(rk)                             :: value
    ! Internal variables
    real(rk) :: arg
    integer  :: itsSign
    character :: options
    real(rk), dimension(:), pointer      :: xArray => null()
    ! Executable
    call reposit( x, LkUpTable, arg, itsSign )
    ! call outputNamedValue( 'x', x )
    ! call outputNamedValue( 'arg', arg )
    ! call outputNamedValue( 'itsSign', itsSign )
    options = LkUpTable%method
    if ( options == 'q' ) options = '0'
    if ( arg < LkUpTable%x1 ) then
      value = LkUpTable%yLeft
    elseif ( arg == LkUpTable%x1 ) then
      value = LkUpTable%y(1)
    elseif ( arg == LkUpTable%x2 ) then
      value = LkUpTable%y(LkUpTable%N)
    elseif ( arg > LkUpTable%x2 ) then
      value = LkUpTable%yRight
    elseif ( options == 's' ) then
      call createXArray( xArray, LkUpTable )
      call InterpolateValues( xArray, LkUpTable%y, (/arg/), newYr8, method='S' )
      value = newYr8(1)
      call deallocate_test( xArray, 'xArray (r8)', ModuleName )
    else
      ! call outputNamedValue( 'options', options )
      value = UseLookUpTable ( arg, LkUpTable%y, LkUpTable%x1, LkUpTable%x2, options=options )
    end if
    value = itsSign*value
  end function FApproximate_r8

! ----------------------------------------------  FInvApproximate  -----

  ! This family of routines use a LookUpTable to approximately invert 
  ! a function possibly restricting the search to a range [xS, xE]

  ! Args: (* means optional)
  ! y        y value to invert
  ! LkUpTable      the Look Up Table type
  ! [xS,xE]  range in which to search (otherwise [LkUpTable%x1, LkUpTable%x2])

  ! Will return x such that y[x] is approximately y

  function FInvApproximate_r4 ( y, LkUpTable, xS, xE ) result(x)
    integer, parameter :: RK = kind(0.0e0)
    ! Args
    real(rk), intent(in)                 :: y
    type(LookUpTable_0(r4)), intent(in)  :: LkUpTable
    real(rk), optional, intent(in)       :: xS
    real(rk), optional, intent(in)       :: xE
    real(rk)                             :: x
    ! Internal variables
    real(rk), dimension(:), pointer      :: xArray => null()
    ! Executable
    call createXArray( xArray, LkUpTable )
    x = UseLookUpTable( y, xArray, xtable=LkUpTable%y, yBottom=xS, yTop=xE )
    call deallocate_test( xArray, 'xArray (r4)', ModuleName )
  end function FInvApproximate_r4

  function FInvApproximate_r8 ( y, LkUpTable, xS, xE ) result(x)
    integer, parameter :: RK = kind(0.0d0)
    ! Args
    real(rk), intent(in)                 :: y
    type(LookUpTable_0(r8)), intent(in)  :: LkUpTable
    real(rk), optional, intent(in)       :: xS
    real(rk), optional, intent(in)       :: xE
    real(rk)                             :: x
    ! Internal variables
    real(rk), dimension(:), pointer      :: xArray => null()
    ! Executable
    call createXArray( xArray, LkUpTable )
    x = UseLookUpTable( y, xArray, xtable=LkUpTable%y, yBottom=xS, yTop=xE )
    call deallocate_test( xArray, 'xArray (r8)', ModuleName )
  end function FInvApproximate_r8

! ----------------------------------------------  FillLookUpTable  -----

  ! This family of routines fills a table with evaluations of a function
  ! at regularly-spaced points
  ! Subsequently, instead of evaluating the function you can address the
  ! array at the index of its closest element

  ! This only makes sense if you're going to evaluate the function many more
  ! times than takes to fill the table and you're willing 
  ! to accept whatever error may result from using the ClosestValue
  ! Of course that error could be large if you will evaluate the function
  ! outside the range [x1, x2]

  subroutine FillLookUpTable_r4 ( fun, table, x1, x2, N, xtable )
    integer, parameter :: RK = kind(0.0e0)
    include 'FillLookUpTable.f9h'
  end subroutine FillLookUpTable_r4 

  subroutine FillLookUpTable_r8 ( fun, table, x1, x2, N, xtable )
    integer, parameter :: RK = kind(0.0d0)
    include 'FillLookUpTable.f9h'
  end subroutine FillLookUpTable_r8

! --------------------------------------------------  FindInRange  -----
! This family of subroutines search not for a single index
! but for all at which the corresponding elements
! lie within a range of values, inclusive
! If none, return (/ 0, .., 0 /)
! Special interpretation: inclusive means
! if vrange(1) == vrange(2), any values of list also == vrange
! are within that range
! Unlike Hunt, list need not be monotonic
! options may include any of the following characters
!    character            meaning
!    ---------            -------
!       a                 ignore sign
!       r                 reverse sense (i.e. find outside range)
!       c                 modulo 360 degress
  subroutine FindInRange_int ( list, vrange, which, how_many, options )
    integer, parameter :: RK = kind(0.0e0)
    ! Dummy args
    integer, dimension(:) :: list
    integer, dimension(2) :: vrange
    include 'FindInRange.f9h'
  end subroutine FindInRange_int

  subroutine FindInRange_r4 ( list, vrange, which, how_many, options )
    integer, parameter :: RK = kind(0.0e0)
    ! Dummy args
    real(rk), dimension(:) :: list
    real(rk), dimension(2) :: vrange
    include 'FindInRange.f9h'
  end subroutine FindInRange_r4

  subroutine FindInRange_r8 ( list, vrange, which, how_many, options )
    integer, parameter :: RK = kind(0.0d0)
    ! Dummy args
    real(rk), dimension(:) :: list
    real(rk), dimension(2) :: vrange
    include 'FindInRange.f9h'
  end subroutine FindInRange_r8

  subroutine FindInRange_2d_int ( list, vrange, which, how_many, options )
    ! Dummy args
    integer, dimension(:,:) :: list
    integer, dimension(2) :: vrange
    include 'FindInRange_2d.f9h'
  end subroutine FindInRange_2d_int

  subroutine FindInRange_2d_r4 ( list, vrange, which, how_many, options )
    integer, parameter :: RK = kind(0.0e0)
    ! Dummy args
    real(rk), dimension(:,:) :: list
    real(rk), dimension(2) :: vrange
    include 'FindInRange_2d.f9h'
  end subroutine FindInRange_2d_r4

  subroutine FindInRange_2d_r8 ( list, vrange, which, how_many, options )
    integer, parameter :: RK = kind(0.0d0)
    ! Dummy args
    real(rk), dimension(:,:) :: list
    real(rk), dimension(2) :: vrange
    include 'FindInRange_2d.f9h'
  end subroutine FindInRange_2d_r8

! ------------------------------------------------  IFApproximate  -----

  ! This family of routines use a LookUpTable to approximate a 
  ! function's integral

  ! Args: (* means optional)
  ! LkUpTable      the Look Up Table type
  ! [xS,xE]  range over which to integrate (otherwise [LkUpTable%x1, LkUpTable%x2])

  function IFApproximate_r4 ( LkUpTable, xS, xE ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    ! Args
    type(LookUpTable_0(r4)), intent(in)  :: LkUpTable
    real(rk), optional, intent(in)       :: xS
    real(rk), optional, intent(in)       :: xE
    real(rk)                             :: value
    ! Internal variables
    character :: options
    real(rk), dimension(:), pointer      :: xArray => null()
    real(rk) :: x1, x2
    ! Executable
    x1 = LkUpTable%x1
    x2 = LkUpTable%x2
    if ( present(xS) ) x1 = xS
    if ( present(xE) ) x2 = xE
    options = LkUpTable%method
    if ( options == 'q' ) options = 'S'
    if ( x2 < LkUpTable%x1 ) then
      value = 0.
    elseif ( x1 > LkUpTable%x2 ) then
      value = 0.
    elseif ( options == '/s/' ) then ! We'll just use our standard integration
      call createXArray( xArray, LkUpTable )
      call MLSMessage &
      & ( MLSMSG_Warning, ModuleName, "Unable to integrate with cubic spline")
      call deallocate_test( xArray, 'xArray (r4)', ModuleName )
    else
      value = UseLookUpTable ( x2, LkUpTable%y, LkUpTable%x1, LkUpTable%x2, options=options // 'S' ) &
           & - &
           &  UseLookUpTable ( x1, LkUpTable%y, LkUpTable%x1, LkUpTable%x2, options=options // 'S' )
    end if
  end function IFApproximate_r4

  function IFApproximate_r8 ( LkUpTable, xS, xE ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    ! Args
    type(LookUpTable_0(r8)), intent(in)  :: LkUpTable
    real(rk), optional, intent(in)       :: xS
    real(rk), optional, intent(in)       :: xE
    real(rk)                             :: value
    ! Internal variables
    character :: options
    real(rk), dimension(:), pointer      :: xArray => null()
    real(rk) :: x1, x2
    ! Executable
    x1 = LkUpTable%x1
    x2 = LkUpTable%x2
    if ( present(xS) ) x1 = xS
    if ( present(xE) ) x2 = xE
    options = LkUpTable%method
    if ( options == 'q' ) options = 'S'
    if ( x2 < LkUpTable%x1 ) then
      value = 0.
    elseif ( x1 > LkUpTable%x2 ) then
      value = 0.
    elseif ( options == '/s/' ) then ! We'll just use our standard integration
      call createXArray( xArray, LkUpTable )
      call MLSMessage &
      & ( MLSMSG_Warning, ModuleName, "Unable to integrate with cubic spline")
      call deallocate_test( xArray, 'xArray (r8)', ModuleName )
    else
      value = UseLookUpTable ( x2, LkUpTable%y, LkUpTable%x1, LkUpTable%x2, options=options // 'S' ) &
           & - &
           &  UseLookUpTable ( x1, LkUpTable%y, LkUpTable%x1, LkUpTable%x2, options=options // 'S' )
    end if
  end function IFApproximate_r8

! ------------------------------------------  InterpolateArray_r4  -----

  ! This next subroutine is a workhorse interpolation routine, loosely based on
  ! my (Nathaniel) IDL routine of the same name.

  ! Method is one of 'L'inear, 'C'spline, or 'S'pline
  !                                (Numerical Recipes, more later no doubt)
  ! Extrapolate is one of 'A'llow, 'C'onstant, 'B'ad or 'P'eriodic (Spline only)

  ! The 'C' spline was simply moved here from the fwdmdl directory
  ! it appears similar to the 'S'pline except constraining the newY values
  ! that exceed either
  ! (a) 125% of the value that would result from linear interpolation; or
  ! (b) the hard bounds set by the optional parameters [yMin, ymax]

  ! Notes:
  !   oldX must be monotonically increasing or decreasing
  !   newX can be in any order
  !   one can't ask for spline interpolation with missing regions.
  !   missingRegions will probably slow the code down, as will extrapolate=B

  subroutine InterpolateArray_r4 ( oldX, oldY, newX, newY, method, extrapolate, &
    & badValue, missingRegions, dyByDx, dNewByDOld, skipNewY, IntYdX, Second )
    integer, parameter :: RK = kind(0.0e0)

    ! Dummy arguments
    real(rk), dimension(:), intent(IN) :: oldX
    real(rk), dimension(:,:), intent(IN) :: oldY   ! See Second argument below
    real(rk), dimension(:), intent(IN) :: newX
    real(rk), dimension(:,:), intent(OUT) :: newY  ! See Second argument below

    character (len=*), intent(in) :: method ! See comments above
    character (len=*), optional, intent(in) :: extrapolate ! See comments above
    real(rk), optional, intent(in) :: badvalue
    logical, optional, intent(in) :: missingRegions ! Allow missing regions
    real(rk), dimension(:,:), optional, intent(out) :: dyByDx
    type (matrixElement_T), intent(out), optional :: dNewByDOld ! Derivatives
    logical, optional, intent(in) :: SKIPNEWY ! Don't compute newY
    real(rk), dimension(:,:), optional, intent(out) :: IntYdX ! Antiderivative
                                              ! of Y at X
    logical, optional, intent(in) :: Second   ! Interpolate on the second
                                              ! dimension of OldY, NewY, default
                                              ! false.

    type(coefficients(r4)) :: Coeffs

    include "InterpolateArray.f9h"

  end subroutine InterpolateArray_r4

! ------------------------------------------  InterpolateArray_r8  -----

  subroutine InterpolateArray_r8 ( oldX, oldY, newX, newY, method, extrapolate, &
    & badValue, missingRegions, dyByDx, dNewByDOld, skipNewY, IntYdX, Second )
    integer, parameter :: RK = kind(0.0d0)

    ! Dummy arguments
    real(rk), dimension(:), intent(IN) :: oldX
    real(rk), dimension(:,:), intent(IN) :: oldY   ! See Second argument below
    real(rk), dimension(:), intent(IN) :: newX
    real(rk), dimension(:,:), intent(OUT) :: newY  ! See Second argument below

    character (len=*), intent(in) :: method ! See comments above
    character (len=*), optional, intent(in) :: extrapolate ! See comments above
    real(rk), optional, intent(in) :: badvalue
    logical, optional, intent(in) :: missingRegions ! Allow missing regions
    real(rk), dimension(:,:), optional, intent(out) :: dyByDx
    type (matrixElement_T), intent(OUT), optional :: dNewByDOld ! Derivatives
    logical, optional, intent(in) :: SKIPNEWY ! Don't compute newY
    real(rk), dimension(:,:), optional, intent(out) :: IntYdX ! Antiderivative
                                              ! of Y at X
    logical, optional, intent(in) :: Second   ! Interpolate on the second
                                              ! dimension of OldY, NewY, default
                                              ! false.

    type(coefficients(r8)) :: Coeffs

    include "InterpolateArray.f9h"

  end subroutine InterpolateArray_r8

! -------------------------------------  InterpolateArraySetup_r4  -----

  subroutine InterpolateArraySetup_r4 ( OldX, NewX, Method, Coeffs, &
    & Extrapolate, Width, DyByDx, dNewByDOld, IntYdX, fail )

    integer, parameter :: RK = kind(0.0e0)

    real(rk), intent(in) :: OldX(:), NewX(:)
    character(len=*), intent(in) :: Method
    type(coefficients(r4)), intent(out) :: Coeffs
    character(len=*), intent(in), optional :: Extrapolate ! See comments above
    integer, intent(in), optional :: Width ! Second dimension for OldY when
                                           ! interpolations get done
    logical, optional, intent(in) :: DyByDx ! just a signal to
                                           ! compute more coeffs for splines
    type (matrixElement_T), intent(inout), optional :: dNewByDOld ! Derivatives
                                           ! inout so createBlock can clean up
                                           ! after an old one
    logical, optional, intent(in) :: IntYdX ! just a signal to
                                           ! compute more coeffs for splines
    logical, optional, intent(out) :: Fail    ! True for failure

    include "InterpolateArraySetup.f9h"

  end subroutine InterpolateArraySetup_r4

! -------------------------------------  InterpolateArraySetup_r8  -----

  subroutine InterpolateArraySetup_r8 ( OldX, NewX, Method, Coeffs, &
    & Extrapolate, Width, DyByDx, dNewByDOld, IntYdX, fail )

    integer, parameter :: RK = kind(0.0d0)

    real(rk), intent(in) :: OldX(:), NewX(:)
    character(len=*), intent(in) :: Method
    type(coefficients(r8)), intent(out) :: Coeffs
    character(len=*), intent(in), optional :: Extrapolate ! See comments above
    integer, intent(in), optional :: Width ! Second dimension for OldY when
                                           ! interpolations get done
    logical, optional, intent(in) :: DyByDx ! just a signal to
                                           ! compute more coeffs for splines
    type (matrixElement_T), intent(inout), optional :: dNewByDOld ! Derivatives
                                           ! inout so createBlock can clean up
                                           ! after an old one
    logical, optional, intent(in) :: IntYdX ! just a signal to
                                           ! compute more coeffs for splines
    logical, optional, intent(out) :: Fail    ! True for failure

    include "InterpolateArraySetup.f9h"

  end subroutine InterpolateArraySetup_r8

! ----------------------------------  InterpolateArrayTeardown_r4  -----

  subroutine InterpolateArrayTeardown_r4 ( Coeffs )

    type(coefficients(r4)), intent(inout) :: Coeffs

    include "InterpolateArrayTeardown.f9h"

  end subroutine InterpolateArrayTeardown_r4

! ----------------------------------  InterpolateArrayTeardown_r8  -----

  subroutine InterpolateArrayTeardown_r8 ( Coeffs )

    type(coefficients(r8)), intent(inout) :: Coeffs

    include "InterpolateArrayTeardown.f9h"

  end subroutine InterpolateArrayTeardown_r8

! -------------------------------------  InterpolateExtrapolate_d  -----

  subroutine InterpolateExtrapolate_d ( OldX, OldY, NewX, NewY, Second )

    ! Interpolate ( OldX(:), OldY(:,:) ) to ( NewX(:), NewY(:,:) ), where
    ! the dimension upon which to interpolate is merge(2,1,second).
    ! Extrapolate outside the range of OldX using the average slope, not
    ! the slope nearest the end where NewX is outside the range of OldX.

    integer, parameter :: RK = kind(0.0d0)
    real(rk), intent(in) :: OldX(:), OldY(:,:), NewX(:)
    real(rk), intent(out) :: NewY(:,:)
    logical, intent(in) :: Second
    type(coefficients(r8)) :: Coeffs

    include 'InterpolateExtrapolate.f9h'

  end subroutine InterpolateExtrapolate_d

! -----------------------------------  InterpolateExtrapolate_d_1  -----

  subroutine InterpolateExtrapolate_d_1 ( OldX, OldY, NewX, NewY, Second )

    ! Interpolate ( OldX(:), OldY(:) ) to ( NewX(:), NewY(:) ).
    ! Extrapolate outside the range of OldX using the average slope, not
    ! the slope nearest the end where NewX is outside the range of OldX.

    integer, parameter :: RK = kind(0.0d0)
    real(rk), intent(in) :: OldX(:), OldY(:), NewX(:)
    real(rk), intent(out) :: NewY(:)
    logical, intent(in) :: Second
    type(coefficients(r8)) :: Coeffs

    include 'InterpolateExtrapolate_1.f9h'

  end subroutine InterpolateExtrapolate_d_1

! -------------------------------------  InterpolateExtrapolate_s  -----

  subroutine InterpolateExtrapolate_s ( OldX, OldY, NewX, NewY, Second )

    ! Interpolate ( OldX(:), OldY(:,:) ) to ( NewX(:), NewY(:,:) ), where
    ! the dimension upon which to interpolate is merge(2,1,second).
    ! Extrapolate outside the range of OldX using the average slope, not
    ! the slope nearest the end where NewX is outside the range of OldX.

    integer, parameter :: RK = kind(0.0e0)
    real(rk), intent(in) :: OldX(:), OldY(:,:), NewX(:)
    real(rk), intent(out) :: NewY(:,:)
    logical, intent(in) :: Second
    type(coefficients(r4)) :: Coeffs

    include 'InterpolateExtrapolate.f9h'

  end subroutine InterpolateExtrapolate_s

! -----------------------------------  InterpolateExtrapolate_s_1  -----

  subroutine InterpolateExtrapolate_s_1 ( OldX, OldY, NewX, NewY, Second )

    ! Interpolate ( OldX(:), OldY(:) ) to ( NewX(:), NewY(:) ).
    ! Extrapolate outside the range of OldX using the average slope, not
    ! the slope nearest the end where NewX is outside the range of OldX.

    integer, parameter :: RK = kind(0.0e0)
    real(rk), intent(in) :: OldX(:), OldY(:), NewX(:)
    real(rk), intent(out) :: NewY(:)
    logical, intent(in) :: Second
    type(coefficients(r4)) :: Coeffs

    include 'InterpolateExtrapolate_1.f9h'

  end subroutine InterpolateExtrapolate_s_1

! -----------------------------------------  InterpolateScalar_r4  -----

! This subroutine is a scalar wrapper for the array one.

  subroutine InterpolateScalar_r4 ( oldX, oldY, newX, newY, method, extrapolate, &
    & badValue, missingRegions, dyByDx, RangeOfPeriod, skipNewY, IntYdX, YMIN, YMAX )
    integer, parameter :: RK = kind(0.0e0)

    ! Dummy arguments
    real(rk), dimension(:), intent(in) :: oldX
    real(rk), dimension(:), intent(in) :: oldY
    real(rk), dimension(:), intent(in) :: newX
    real(rk), dimension(:), intent(out) :: newY

    character (len=*), intent(in) :: method ! See comments above
    character (len=*), optional, intent(in) :: extrapolate ! See comments above
    real(rk), optional, intent(in) :: badValue
    real(rk), dimension(:), optional, intent(out) :: dyByDx
    real(rk), dimension(2), optional, intent(in) :: rangeofperiod   ! for periodic data
    logical, optional, intent(in) :: missingRegions ! Allow missing regions
    logical, optional, intent(in) :: SKIPNEWY ! Don't compute newY
    real(rk), dimension(:), optional, intent(out) :: IntYdX ! Antiderivative
                                              ! of Y at X
    real(rk), optional, intent(in) :: YMIN, YMAX

    include "InterpolateScalar.f9h"
  end subroutine InterpolateScalar_r4

! -----------------------------------------  InterpolateScalar_r8  -----

  subroutine InterpolateScalar_r8 ( oldX, oldY, newX, newY, method, extrapolate, &
    & badValue, missingRegions, dyByDx, RangeOfPeriod, skipNewY, IntYdX, YMIN, YMAX )
    integer, parameter :: RK = kind(0.0d0)

    ! Dummy arguments
    real(rk), dimension(:), intent(in) :: oldX
    real(rk), dimension(:), intent(in) :: oldY
    real(rk), dimension(:), intent(in) :: newX
    real(rk), dimension(:), intent(out) :: newY

    character (len=*), intent(in) :: method ! See comments above
    character (len=*), optional, intent(in) :: extrapolate ! See comments above
    real(rk), optional, intent(in) :: badValue
    logical, optional, intent(in) :: missingRegions ! Allow missing regions
    real(rk), dimension(:), optional, intent(out) :: dyByDx
    real(rk), dimension(2), optional, intent(in) :: rangeofperiod   ! for periodic data
    logical, optional, intent(in) :: SKIPNEWY ! Don't compute newY
    real(rk), dimension(:), optional, intent(out) :: IntYdX ! Antiderivative
                                              ! of Y at X
    real(rk), optional, intent(in) :: YMIN, YMAX

    include "InterpolateScalar.f9h"
  end subroutine InterpolateScalar_r8

! -------------------------------  InterpolateScalarUsingSetup_r4  -----

  subroutine InterpolateScalarUsingSetup_r4 ( coeffs, oldX, oldY, newX, newY, &
    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY, IntYdX )
    integer, parameter :: RK = kind(0.0e0)

    ! Dummy arguments
    type(coefficients(r4)), intent(in) :: Coeffs
    real(rk), dimension(:), intent(in) :: oldX
    real(rk), dimension(:), intent(in) :: oldY
    real(rk), dimension(:), intent(in) :: newX
    real(rk), dimension(:), intent(out) :: newY

    character (len=*), intent(in) :: method ! See comments above
    character (len=*), optional, intent(in) :: extrapolate ! See comments above
    real(rk), optional, intent(in) :: badvalue
    logical, optional, intent(in) :: missingRegions ! Allow missing regions
    real(rk), dimension(:), optional, intent(out) :: dyByDx
    logical, optional, intent(in) :: SKIPNEWY ! Don't compute newY
    real(rk), dimension(:), optional, intent(out) :: IntYdX ! Antiderivative
                                              ! of Y at X

    include "InterpolateScalarUsingSetup.f9h"

  end subroutine InterpolateScalarUsingSetup_r4

! -------------------------------  InterpolateScalarUsingSetup_r8  -----

  subroutine InterpolateScalarUsingSetup_r8 ( coeffs, oldX, oldY, newX, newY, &
    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY, IntYdX )
    integer, parameter :: RK = kind(0.0d0)

    ! Dummy arguments
    type(coefficients(r8)), intent(in) :: Coeffs
    real(rk), dimension(:), intent(in) :: oldX
    real(rk), dimension(:), intent(in) :: oldY
    real(rk), dimension(:), intent(in) :: newX
    real(rk), dimension(:), intent(out) :: newY

    character (len=*), intent(in) :: method ! See comments above
    character (len=*), optional, intent(in) :: extrapolate ! See comments above
    real(rk), optional, intent(in) :: badvalue
    logical, optional, intent(in) :: missingRegions ! Allow missing regions
    real(rk), dimension(:), optional, intent(out) :: dyByDx
    logical, optional, intent(in) :: SKIPNEWY ! Don't compute newY
    real(rk), dimension(:), optional, intent(out) :: IntYdX ! Antiderivative
                                              ! of Y at X

    include "InterpolateScalarUsingSetup.f9h"

  end subroutine InterpolateScalarUsingSetup_r8

! -------------------------------------  InterpolateUsingSetup_r4  -----

  subroutine InterpolateUsingSetup_r4 ( coeffs, oldX, oldY, newX, newY, &
    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY, IntYdX, &
    & Second )
    integer, parameter :: RK = kind(0.0e0)

    ! Dummy arguments
    type(coefficients(r4)), intent(in) :: Coeffs
    real(rk), dimension(:), intent(in) :: oldX
    real(rk), dimension(:,:), intent(in) :: oldY   ! See Second argument below
    real(rk), dimension(:), intent(in) :: newX
    real(rk), dimension(:,:), intent(out) :: newY  ! See Second argument below

    character (len=*), intent(in) :: method ! See comments above
    character (len=*), optional, intent(in) :: extrapolate ! See comments above
    real(rk), optional, intent(in) :: badvalue
    logical, optional, intent(in) :: missingRegions ! Allow missing regions
    real(rk), dimension(:,:), optional, intent(out) :: dyByDx
    logical, optional, intent(in) :: SKIPNEWY ! Don't compute newY
    real(rk), dimension(:,:), optional, intent(out) :: IntYdX ! Antiderivative
                                              ! of Y at X
    logical, optional, intent(in) :: Second   ! Interpolate on the second
                                              ! dimension of OldY, NewY, default
                                              ! false.

    include "InterpolateUsingSetup.f9h"

  end subroutine InterpolateUsingSetup_r4

! -------------------------------------  InterpolateUsingSetup_r8  -----

  subroutine InterpolateUsingSetup_r8 ( coeffs, oldX, oldY, newX, newY, &
    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY, IntYdX, &
    & Second )
    integer, parameter :: RK = kind(0.0d0)

    ! Dummy arguments
    type(coefficients(r8)), intent(in) :: Coeffs
    real(rk), dimension(:), intent(in) :: oldX
    real(rk), dimension(:,:), intent(in) :: oldY   ! See Second argument below
    real(rk), dimension(:), intent(in) :: newX
    real(rk), dimension(:,:), intent(out) :: newY  ! See Second argument below

    character (len=*), intent(in) :: method ! See comments above
    character (len=*), optional, intent(in) :: extrapolate ! See comments above
    real(rk), optional, intent(in) :: badvalue
    logical, optional, intent(in) :: missingRegions ! Allow missing regions
    real(rk), dimension(:,:), optional, intent(out) :: dyByDx
    logical, optional, intent(in) :: SKIPNEWY ! Don't compute newY
    real(rk), dimension(:,:), optional, intent(out) :: IntYdX ! Antiderivative
                                              ! of Y at X
    logical, optional, intent(in) :: Second   ! Interpolate on the second
                                              ! dimension of OldY, NewY, default
                                              ! false.

    include "InterpolateUsingSetup.f9h"

  end subroutine InterpolateUsingSetup_r8

  ! -----------------------------------  Interp_Bilinear_2d_1d_r4  -----
  subroutine Interp_Bilinear_2d_1d_r4 ( XOld, XNew, YOld, YNew, Zold, Znew, &
    & Update )

    ! Given ZOld on coordinates (XOld x YOld), interpolate to (XNew,YNew)
    ! to give ZNew.  ZOld must have shape (size(xOld),size(yOld)), while
    ! XNew, YNew and ZNew must have the same shapes.

    integer, parameter :: RK = kind(1.0e0)
    real(rk), intent(in) :: XOld(:)
    real(rk), intent(in) :: XNew(:)
    real(rk), intent(in) :: YOld(:)
    real(rk), intent(in) :: YNew(:)
    real(rk), intent(in) :: ZOld(:,:)
    real(rk), intent(inout) :: ZNew(:)
    logical, intent(in), optional :: Update ! Add interpolate to Znew
    include 'Interp_Bilinear_2d_1d.f9h'

  end subroutine Interp_Bilinear_2d_1d_r4

  ! -----------------------------------  Interp_Bilinear_2d_1d_r8  -----
  subroutine Interp_Bilinear_2d_1d_r8 ( XOld, XNew, YOld, YNew, Zold, Znew, &
    & Update )

    ! Given ZOld on coordinates (XOld x YOld), interpolate to (XNew,YNew)
    ! to give ZNew.  ZOld must have shape (size(xOld),size(yOld)), while
    ! XNew, YNew and ZNew must have the same shapes.

    integer, parameter :: RK = kind(1.0d0)
    real(rk), intent(in) :: XOld(:)
    real(rk), intent(in) :: XNew(:)
    real(rk), intent(in) :: YOld(:)
    real(rk), intent(in) :: YNew(:)
    real(rk), intent(in) :: ZOld(:,:)
    real(rk), intent(inout) :: ZNew(:)
    logical, intent(in), optional :: Update ! Add interpolate to Znew
    include 'Interp_Bilinear_2d_1d.f9h'

  end subroutine Interp_Bilinear_2d_1d_r8

  ! ------------------------  Interpolate_Regular_To_Irregular_r4  -----
  subroutine Interpolate_Regular_To_Irregular_r4 ( XOld, YOld, ZOld, &
    & XNew, YNew, ZNew )
    ! Given XOld, YOld, ZOld, XYNew, interpolate to ZNew.
    ! The shape of ZOld must be (size(xOld),size(yOld)).
    ! The shape of ZNew must be the same as Xnew and YNew.
    ! The only method supported is linear with constant extrapolation.
    integer, parameter :: RK = kind(1.0e0)
    real(rk), intent(in) :: XOld(:)
    real(rk), intent(in) :: YOld(:)
    real(rk), intent(in) :: ZOld(:,:)
    real(rk), intent(in) :: XNew(:,:), YNew(:,:)
    real(rk), intent(out) :: ZNew(:,:)
    include 'Interpolate_Regular_To_Irregular.f9h'
   end subroutine Interpolate_Regular_To_Irregular_r4

  ! ------------------------  Interpolate_Regular_To_Irregular_r8  -----
  subroutine Interpolate_Regular_To_Irregular_r8 ( XOld, YOld, ZOld, &
    & XNew, YNew, ZNew )
    ! Given XOld, YOld, ZOld, XYNew, interpolate to ZNew.
    ! The shape of ZOld must be (size(xOld),size(yOld)).
    ! The shape of ZNew must be the same as Xnew and YNew.
    ! The only method supported is linear with constant extrapolation.
    integer, parameter :: RK = kind(1.0d0)
    real(rk), intent(in) :: XOld(:)
    real(rk), intent(in) :: YOld(:)
    real(rk), intent(in) :: ZOld(:,:)
    real(rk), intent(in) :: XNew(:,:), YNew(:,:)
    real(rk), intent(out) :: ZNew(:,:)
    include 'Interpolate_Regular_To_Irregular.f9h'
   end subroutine Interpolate_Regular_To_Irregular_r8

  ! --------------------------------  Interpolate_2d_Composite_r4  -----
  subroutine Interpolate_2d_Composite_r4 ( XOld, YOld, ZOld, XNew, YNew, ZNew, &
    & XMethod, YMethod, XExtrapolate, YExtrapolate )
    ! Given XOld, YOld, ZOld, XNew and YNew, interpolate to ZNew.
    ! The shape of ZOld must be (size(xOld),size(yOld)).
    ! The shape of ZNew must be (size(xNew),size(yNew)).
    ! Interpolation is first done in the X direction using XMethod to produce
    ! a temporary variable with shape (size(xNew),size(yOld)).  Then
    ! interpolation is done in the Y direction, from that temporary variable,
    ! using YMethod, to produce ZNew.
    integer, parameter :: RK = kind(1.0e0)
    real(rk), intent(in) :: XOld(:)
    real(rk), intent(in) :: YOld(:)
    real(rk), intent(in) :: ZOld(:,:)
    real(rk), intent(in) :: XNew(:)
    real(rk), intent(in) :: YNew(:)
    real(rk), intent(out) :: ZNew(:,:)
    character (len=*), intent(in) :: XMethod, YMethod ! See comments above
    character (len=*), optional, intent(in) :: XExtrapolate, YExtrapolate ! See comments above
    type(coefficients(r4)) :: XCoeffs, YCoeffs
    include 'Interpolate_2d_Composite.f9h'
  end subroutine Interpolate_2d_Composite_r4

  ! --------------------------------  Interpolate_2d_Composite_r8  -----
  subroutine Interpolate_2d_Composite_r8 ( XOld, YOld, ZOld, XNew, YNew, ZNew, &
    & XMethod, YMethod, XExtrapolate, YExtrapolate )
    ! Given XOld, YOld, ZOld, XNew and YNew, interpolate to ZNew.
    ! The shape of ZOld must be (size(xOld),size(yOld)).
    ! The shape of ZNew must be (size(xNew),size(yNew)).
    ! Interpolation is first done in the X direction using XMethod to produce
    ! a temporary variable with shape (size(xNew),size(yOld)).  Then
    ! interpolation is done in the Y direction, from that temporary variable,
    ! using YMethod, to produce ZNew.
    integer, parameter :: RK = kind(1.0d0)
    real(rk), intent(in) :: XOld(:)
    real(rk), intent(in) :: YOld(:)
    real(rk), intent(in) :: ZOld(:,:)
    real(rk), intent(in) :: XNew(:)
    real(rk), intent(in) :: YNew(:)
    real(rk), intent(out) :: ZNew(:,:)
    character (len=*), intent(in) :: XMethod, YMethod ! See comments above
    character (len=*), optional, intent(in) :: XExtrapolate, YExtrapolate ! See comments above
    type(coefficients(r8)) :: XCoeffs, YCoeffs
    include 'Interpolate_2d_Composite.f9h'
  end subroutine Interpolate_2d_Composite_r8

! --------------------------------------------  LinearInterpolate  -----

  ! This family of functions return a value interpolated across
  ! multiple dimensions

  ! Args: (* means optional)
  ! values   the 2^n values at the hypercube's vertices
  ! coords   2*n vertices coordinates

  function LinearInterpolate_1d_r4 ( values, coords, vertices ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    include "LinearInterpolate_1d.f9h"
  end function LinearInterpolate_1d_r4

  function LinearInterpolate_1d_r8 ( values, coords, vertices ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    include "LinearInterpolate_1d.f9h"
  end function LinearInterpolate_1d_r8

  function LinearInterpolate_2d_r4 ( values, coords, vertices ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    include "LinearInterpolate_2d.f9h"
  end function LinearInterpolate_2d_r4

  function LinearInterpolate_2d_r8 ( values, coords, vertices ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    include "LinearInterpolate_2d.f9h"
  end function LinearInterpolate_2d_r8

  function LinearInterpolate_3d_r4 ( values, coords, vertices ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    include "LinearInterpolate_3d.f9h"
  end function LinearInterpolate_3d_r4

  function LinearInterpolate_3d_r8 ( values, coords, vertices ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    include "LinearInterpolate_3d.f9h"
  end function LinearInterpolate_3d_r8

  function LinearInterpolate_4d_r4 ( values, coords, vertices ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    include "LinearInterpolate_4d.f9h"
  end function LinearInterpolate_4d_r4

  function LinearInterpolate_4d_r8 ( values, coords, vertices ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    include "LinearInterpolate_4d.f9h"
  end function LinearInterpolate_4d_r8

! ----------------------------------------------  ReadLookUpTable  -----

  ! This family of routines Reads a table from a file where it is stored
  ! Something like this (although without the "!")
  ! Celsius2Fahrenheit.txt
  ! file of Celsius Fahrenheit conversions
  ! C        F
  ! -40.   -40.
  !  0.     32.
  ! 1.e2   212
  !
  ! Returning
  ! N = 3
  ! x = (-40., 0., 1.e2)
  ! y = (-40., 32., 212.)
  ! Note:
  ! We ignore lines with non-numerical values
  ! You may use the resulting x and y arrays as args to UseLookUpTable
  ! where
  !       x -> xtable
  !       y -> table
  subroutine ReadLookUpTable_r4 ( filename, N, x, y )
    integer, parameter :: RK = kind(0.0e0)
    include 'ReadLookUpTable.f9h'
  end subroutine ReadLookUpTable_r4

  subroutine ReadLookUpTable_r8 ( filename, N, x, y )
    integer, parameter :: RK = kind(0.0d0)
    include 'ReadLookUpTable.f9h'
  end subroutine ReadLookUpTable_r8

! --------------------------------------------------------  SetUp  -----

  ! This family of routines sets up a LookUpTable of the appropriate type
  ! We ought to do this for both _0 and _1 levels
  subroutine setUpLookUpTable_0_r4 ( LkUpTable, N, x1, x2, &
    & y, BC, method, yLeft, yRight, fun )
    integer, parameter :: RK = kind(0.0e0)
    ! Args
    class(LookUpTable_0(r4)) :: LkUpTable ! Intent(out) would clobber defaults
    integer, intent(in)  :: N
    real(rk), intent(in) :: x1
    real(rk), intent(in) :: x2
    real(rk), dimension(:), optional, intent(in) :: y
    character(len=*), optional, intent(in) :: BC
    character(len=*), optional, intent(in) :: method
    real(rk), optional, intent(in) :: yLeft
    real(rk), optional, intent(in) :: yRight
    real(rk), optional, external :: fun
    ! Internal args
    integer :: i
    ! Executable
    LkUpTable%N       = N
    LkUpTable%x1      = x1
    LkUpTable%x2      = x2
    call allocate_test ( LkUpTable%y, N, "LkUpTable%y", ModuleName )
    if ( present(y        ) ) LkUpTable%y           = y
    if ( present(BC       ) ) LkUpTable%BC          = BC
    if ( present(method   ) ) LkUpTable%method      = method
    if ( present(yLeft    ) ) LkUpTable%yLeft       = yLeft
    if ( present(yRight   ) ) LkUpTable%yRight      = yRight
    if ( .not. present(fun) ) return
    do i=1, N
      LkUpTable%y(i) = fun( x1 + (i-1)*(x2-x1)/(N-1) )
    enddo
  end subroutine setUpLookUpTable_0_r4

  subroutine setUpLookUpTable_0_r8 ( LkUpTable, N, x1, x2, &
    & y, BC, method, yLeft, yRight, fun )
    integer, parameter :: RK = kind(0.0d0)
    ! Args
    class(LookUpTable_0(r8)) :: LkUpTable ! Intent(out) would clobber defaults
    integer, intent(in)  :: N
    real(rk), intent(in) :: x1
    real(rk), intent(in) :: x2
    real(rk), dimension(:), optional, intent(in) :: y
    character(len=*), optional, intent(in) :: BC
    character(len=*), optional, intent(in) :: method
    real(rk), optional, intent(in) :: yLeft
    real(rk), optional, intent(in) :: yRight
    real(rk), optional, external :: fun
    ! Internal args
    integer :: i
    ! Executable
    LkUpTable%N       = N
    LkUpTable%x1      = x1
    LkUpTable%x2      = x2
    call allocate_test ( LkUpTable%y, N, "LkUpTable%y", ModuleName )
    if ( present(y        ) ) LkUpTable%y           = y
    if ( present(BC       ) ) LkUpTable%BC          = BC
    if ( present(method   ) ) LkUpTable%method      = method
    if ( present(yLeft    ) ) LkUpTable%yLeft       = yLeft
    if ( present(yRight   ) ) LkUpTable%yRight      = yRight
    if ( .not. present(fun) ) return
    do i=1, N
      LkUpTable%y(i) = fun( x1 + (i-1)*(x2-x1)/(N-1) )
    enddo
  end subroutine setUpLookUpTable_0_r8

! ------------------------------------------------  SimSubroutine  -----
  ! This family provides subroutine apis to integration by Simpson's rule
  subroutine Simps_r4 ( F, DX, N, R )
!  Simpson's Integration of discrete equal spacing
    integer, parameter :: RK = kind(0.0e0)
    include 'simpson.f9h'
  end subroutine Simps_r4

  subroutine Simps_r8 ( F, DX, N, R )
!  Simpson's Integration of discrete equal spacing
    integer, parameter :: RK = kind(0.0d0)
    include 'simpson.f9h'
  end subroutine Simps_r8

! -----------------------------------------------  SolveQuadratic  -----
   ! Solve

   ! a x^2 + b x + c = 0

   ! for x = r1 + i imPart, and x = r2 - i imPart
   ! where i^2 = -1

   ! Of course because a, b, and c are all purely real
   ! if imPart /= 0, r1 = r2

   ! We bother with this to avoid truncation that would result
   ! from taking a difference between like-signed quantities
   ! b and + or - sqrt(disc)

   ! Special cases (which you may prefer to intercept yourself)
   ! If a = 0, we return the same root in both r1 and r2
   ! If a = b = 0, we divide c by zero

  subroutine SolveQuadratic_r4 ( A, B, C, R1, R2, ImPart )
   integer, parameter :: RK = kind(0.0e0)
   real(rk), intent(in)  :: A, B, C
   real(rk), intent(out) :: R1, R2, ImPart
   include 'SolveQuadratic.f9h'
 end subroutine SolveQuadratic_r4

  subroutine SolveQuadratic_r8 ( A, B, C, R1, R2, ImPart )
   integer, parameter :: RK = kind(0.0d0)
   real(rk), intent(in)  :: A, B, C
   real(rk), intent(out) :: R1, R2, ImPart
   include 'SolveQuadratic.f9h'
 end subroutine SolveQuadratic_r8

! -----------------------------------------------  UseLookUpTable  -----

  ! This family of routines use a LookUpTable to approximate a costly-to-evaluate
  ! function based on its values at a set of points
  ! They are workhorse functions used by the more specialized functions
  ! that approximate derivatives, integrals, etc.

  ! Args:       (* means optional)
  ! x              pt at which to evaluate
  ! table          table of function values
  ! x1,x2          * range of equally-spaced argument values represented in table
  ! xtable         * table of argument values
  ! xS,xE          * range of x-values in which to search
  ! yBottom, yTop  * range of y-values in which to search
  !                 (ignored if xtable is sorted)

  ! options  * none, one, or more of the following:
  ! (default)   choose pt in xtable closest to x
  !    p        xtable is sorted (necessary for the other options)
  !    l        always choose lower of two closest x's in xtable
  !    u        always choose upper of two closest x's in xtable
  !    i        interpolate among two closest, but never extrapolate
  !    0        use quadratic interpolation
  !    1        return 1st derivative instead
  !    2        return 2nd derivative (at nearest pt)
  !    S        return definite integral from x1 to x
  !    C        return definite integral from x to x2

  ! notes:
  ! (1) You should supply either xtable or the range (x1,x2)
  !      (but not both)
  ! (2) If you supply xtable, and that xtable is sorted so that
  !     xtable[i] < xtable[i+1] include 'p' among the options
  ! (3) If you supply (x1,x2) the resulting x values will be automatically
  !     sorted, so you may omit 'p' from among the options
  ! (4) An unsorted xtable is incompatible with any of the options
  !      i.e., you may not integrate, differentiate, interpolate, etc.
  ! (5) The range yBottom, yTop is incompatible with a sorted xtable

  function UseLookUpTable_r4 ( x, table, x1, x2, xtable, &
    & missingValue, options, xS, xE, yBottom, yTop ) result(value)
    integer, parameter :: RK = kind(0.0e0)
    include 'UseLookUpTable.f9h'
  end function UseLookUpTable_r4 

  function UseLookUpTable_r8 ( x, table, x1, x2, xtable, &
    & missingValue, options, xS, xE, yBottom, yTop ) result(value)
    integer, parameter :: RK = kind(0.0d0)
    include 'UseLookUpTable.f9h'
  end function UseLookUpTable_r8 

! ----------------------------------------------  WriteLookUpTable  -----

  ! This family of routines Writes a table to a file where it is stored
  ! Something like this (although without the "!")
  ! Celsius2Fahrenheit.txt
  ! file of Celsius Fahrenheit conversions
  ! C        F
  ! -40.   -40.
  !  0.     32.
  ! 1.e2   212
  !
  ! Given the input
  ! N = 3
  ! x = (-40., 0., 1.e2)
  ! y = (-40., 32., 212.)
  subroutine WriteLookUpTable_r4 ( filename, N, x, y )
    integer, parameter :: RK = kind(0.0e0)
    include 'WriteLookUpTable.f9h'
  end subroutine WriteLookUpTable_r4

  subroutine WriteLookUpTable_r8 ( filename, N, x, y )
    integer, parameter :: RK = kind(0.0d0)
    include 'WriteLookUpTable.f9h'
  end subroutine WriteLookUpTable_r8

!==================== Private Procedures ===============================
! ...........................................  BattleRealToInt_r4  .....
  ! This is a utility function to convert a real-valued function into the 
  ! integer-valued function Battleship expects
  function BattleRealToInt_r4 ( arg, arg1, delta, setUp ) result( iarg )
    integer, parameter :: RK = R4
    ! Args
    real(rk), intent(in)           :: arg
    real(rk), optional, intent(in) :: arg1, delta
    logical, optional, intent(in)  :: setUp
    integer                        :: iarg
    ! Internal variables
    logical                        :: mySetup
    real(rk), save                 :: x1, eps
    ! Executable
    mySetup = .false.
    if ( present(setUp) ) mySetup = setUp
    if ( mySetUp ) then
      x1 = arg1
      eps = delta
    else
      iarg = int( (arg - x1) / eps ) + 1
    endif
  end function BattleRealToInt_r4

! ...........................................  BattleRealToInt_r8  .....
  function BattleRealToInt_r8 ( arg, arg1, delta, setUp ) result( iarg )
    integer, parameter :: RK = r8
    ! Args
    real(rk), intent(in)           :: arg
    real(rk), optional, intent(in) :: arg1, delta
    logical, optional, intent(in)  :: setUp
    integer                        :: iarg
    ! Internal variables
    logical                        :: mySetup
    real(rk), save                 :: x1, eps
    ! Executable
    mySetup = .false.
    if ( present(setUp) ) mySetup = setUp
    if ( mySetUp ) then
      x1 = arg1
      eps = delta
    else
      iarg = int( (arg - x1) / eps ) + 1
    endif
  end function BattleRealToInt_r8

! ..............................................  createXArray_r4  .....
  ! This family creates an array of x values appropriate
  ! for the LkUpTable
  subroutine CreateXArray_r4( xArray, LkUpTable )
    integer, parameter :: RK = R4
    ! Args
    real(rk), dimension(:), pointer      :: xArray
    type(LookUpTable_0(r4)), intent(in)       :: LkUpTable
    ! Internal variables
    integer :: i
    ! Executable
    call allocate_test( xArray, LkUpTable%N, 'xArray (r4)', ModuleName )
    do i=1, LkUpTable%N
      xArray(i) = LkUpTable%x1 + (i-1)*(LkUpTable%x2-LkUpTable%x1)/(LkUpTable%N-1)
    enddo
  end subroutine CreateXArray_r4

! ..............................................  createXArray_r8  .....
  subroutine CreateXArray_r8( xArray, LkUpTable )
    integer, parameter :: RK = R8
    ! Args
    real(rk), dimension(:), pointer      :: xArray
    type(LookUpTable_0(r8)), intent(in)       :: LkUpTable
    ! Internal variables
    integer :: i
    ! Executable
    call allocate_test( xArray, LkUpTable%N, 'xArray (r8)', ModuleName )
    do i=1, LkUpTable%N
      xArray(i) = LkUpTable%x1 + (i-1)*(LkUpTable%x2-LkUpTable%x1)/(LkUpTable%N-1)
    enddo
  end subroutine CreateXArray_r8

! .................................................  psimpsons_r4  .....
  ! This family of functions performs a part of asimpson's rule integration
  ! from x1 to x
  function Psimpsons_r4 ( x, x1, x2, h, y ) result (sum)
    integer, parameter :: RK = R4
    ! Args
    real(rk), intent(in)               :: x
    real(rk), intent(in)               :: x1
    real(rk), intent(in)               :: x2
    real(rk), intent(in)               :: h
    real(rk), dimension(:), intent(in) :: y
    real(rk)                           :: sum
    ! Internal variables
    integer :: i
    integer, dimension(2) :: indices
    integer :: n
    real(rk), dimension(size(y))      :: xArray
    real(rk)                           :: yofx
    ! Executable
    sum = 0.
    if ( size(y) < 2 ) return
    n = (x2 - x1) / h + 1.5
    do i=1, n
      xArray(i) = x1 + (i-1)*h
    enddo
    ! 1st--we need to find how many intervals, n, are to the left of x
    call ClosestElement( x, xArray, indices, 'l' )
    n = indices(1)
    sum = simpsons( n, h, y )
    yofx = UseLookUpTable ( x, y, x1, x2, xArray )
    ! Now integrate over the distance from x[n] to x
    ! using, less accurately, a trapezoidal quadrature
    sum = sum + ( (x - xArray(n))/2 * ( y(n) + yofx ) )
  end function Psimpsons_r4

! .................................................  psimpsons_r8  .....
  function Psimpsons_r8 ( x, x1, x2, h, y ) result (sum)
    integer, parameter :: RK = R8
    ! Args
    real(rk), intent(in)               :: x
    real(rk), intent(in)               :: x1
    real(rk), intent(in)               :: x2
    real(rk), intent(in)               :: h
    real(rk), dimension(:), intent(in) :: y
    real(rk)                           :: sum
    ! Internal variables
    integer :: i
    integer, dimension(2) :: indices
    integer :: n
    real(rk), dimension(size(y))      :: xArray
    real(rk)                           :: yofx
    ! Executable
    sum = 0.
    if ( size(y) < 2 ) return
    n = (x2 - x1) / h + 1.5
    do i=1, n
      xArray(i) = x1 + (i-1)*h
    enddo
    ! 1st--we need to find how many intervals, n, are to the left of x
    call ClosestElement( x, xArray, indices, 'l' )
    n = indices(1)
    sum = simpsons( n, h, y )
    yofx = UseLookUpTable ( x, y, x1, x2, xArray )
    ! Now integrate over the distance from x[n] to x
    ! using, less accurately, a trapezoidal quadrature
    sum = sum + ( (x - xArray(n))/2 * ( y(n) + yofx ) )
  end function Psimpsons_r8

! ...................................................  reposit_r4  .....
  ! This family repositions x if it is outside [x1, x2]
  ! considering the type of BC determined by the LkUpTable
  subroutine Reposit_r4 ( x, LkUpTable, p, itsSign )
    integer, parameter :: RK = R4
    ! Args
    real(rk), intent(in)                 :: x ! Given this x
    type(LookUpTable_0(r4)), intent(in)       :: LkUpTable
    real(rk), intent(out)                :: p ! reposition it here
    integer, intent(out)                 :: itsSign
    ! Internal variables
    real(rk) :: d
    real(rk) :: Period ! The "period"
    integer :: k ! How many periods between home and x
    ! Executable
    p = x
    itsSign = 1
    if (  LkUpTable%x1 <= x .and. x <= LkUpTable%x2 ) return
    select case ( LkUpTable%BC )
    case ( 'cyclic', 'scyclic' )
      ! How far from "home" are we?
      ! We'll attempt to write this as k*Period + p
      d = max( LkUpTable%x1 - x, x - LkUpTable%x2 )
      Period = LkUpTable%x2 - LkUpTable%x1
      k = d / Period + 0.9999
      if ( x < LkUpTable%x1 ) then
        p = x + k*Period
      else
        p = x - k*Period
      end if
      ! Now if signed cyclic (any non-trig examples of such a beast?)
      ! we also need to know if k is even or odd
      ! if even, we're still the same sign as home
      ! if odd, need to reverse sign
      k = abs(k)
      if ( mod(k, 2) /= 0 .and. LkUpTable%BC == 'scyclic' ) itsSign = -1
    case ( 'express' )
      ! The caller will utilize LkUpTable%y(Left)(Right)
    case default
    ! case ( 'clamped' )
      p = max( p, LkUpTable%x1 )
      p = min( p, LkUpTable%x2 )
    end select
  end subroutine Reposit_r4

! ...................................................  reposit_r8  .....
  subroutine Reposit_r8( x, LkUpTable, p, itsSign )
    integer, parameter :: RK = R8
    ! Args
    real(rk), intent(in)                 :: x ! Given this x
    type(LookUpTable_0(r8)), intent(in)       :: LkUpTable
    real(rk), intent(out)                :: p ! reposition it here
    integer, intent(out)                 :: itsSign
    ! Internal variables
    real(rk) :: d
    real(rk) :: Period ! The "period"
    integer :: k ! How many periods between home and x
    ! Executable
    p = x
    itsSign = 1
    if (  LkUpTable%x1 <= x .and. x <= LkUpTable%x2 ) return
    select case ( LkUpTable%BC )
    case ( 'cyclic', 'scyclic' )
      ! How far from "home" are we?
      ! We'll attempt to write this as k*Period + p
      d = max( LkUpTable%x1 - x, x - LkUpTable%x2 )
      Period = LkUpTable%x2 - LkUpTable%x1
      k = d / Period + 0.9999
      if ( x < LkUpTable%x1 ) then
        p = x + k*Period
      else
        p = x - k*Period
      end if
      ! Now if signed cyclic (any non-trig examples of such a beast?)
      ! we also need to know if k is even or odd
      ! if even, we're still the same sign as home
      ! if odd, need to reverse sign
      k = abs(k)
      if ( mod(k, 2) /= 0 .and. LkUpTable%BC == 'scyclic' ) itsSign = -1
    case ( 'express' )
      ! The caller will utilize LkUpTable%y(Left)(Right)
    case default
    ! case ( 'clamped' )
      p = max( p, LkUpTable%x1 )
      p = min( p, LkUpTable%x2 )
    end select
  end subroutine Reposit_r8

! ..................................................  simpsons_r4  .....
  ! This family of functions performs simpson's rule integrations
  ! for either even or odd n
  function Simpsons_r4 ( n, h, y ) result (sum)
    integer, parameter :: RK = R4
    ! Args
    integer, intent(in)                :: n
    real(rk), intent(in)               :: h
    real(rk), dimension(:), intent(in) :: y
    real(rk)                           :: sum
    call SimpsonsSub( y, h, n, sum )
  end function Simpsons_r4

! ..................................................  simpsons_r8  .....
  function Simpsons_r8 ( n, h, y ) result (sum)
    integer, parameter :: RK = R8
    ! Args
    integer, intent(in)                :: n
    real(rk), intent(in)               :: h
    real(rk), dimension(:), intent(in) :: y
    real(rk)                           :: sum
    call SimpsonsSub( y, h, n, sum )
  end function Simpsons_r8

! ....................................................  D_CSpline  .....
  ! This family was moved here from fwdmdl
  subroutine D_CSpline (xin, xout, yin, yout, nin, nout, ymin, ymax)
    integer, parameter :: rk = kind(0.0d0)
    include 'cspline.f9h'
  end subroutine D_CSpline

! ....................................................  s_cspline  .....
  subroutine S_CSpline (xin, xout, yin, yout, nin, nout, ymin, ymax)
    integer, parameter :: rk = kind(0.0e0)
    include 'cspline.f9h'
  end subroutine S_CSpline

! ......................................................  D_PCSPL  .....
  subroutine D_PCSpl ( tau, c, n, ibcbeg, ibcend )
    integer, parameter :: RK = kind(0.0d0)
    include 'pcspl.f9h'
  end subroutine D_PCSPL

! ......................................................  S_PCSPL  .....
  subroutine S_PCSPL ( TAU, C, N, IBCBEG, IBCEND )
    integer, parameter :: RK = kind(0.0e0)
    include 'pcspl.f9h'
  end subroutine S_PCSPL

  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: MLSNumerics.f90,v 2.100 2018/12/05 01:00:46 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, id ! .mod files sometimes change if PRINT is added
  end function not_used_here

end module MLSNumerics
!=============================================================================

!
! $Log: MLSNumerics.f90,v $
! Revision 2.100  2018/12/05 01:00:46  pwagner
! Made Destroy, Dump, and SetUp typebound procedures
!
! Revision 2.99  2018/12/03 23:19:58  pwagner
! Changed name of datatype to more natural LookUpTable
!
! Revision 2.98  2017/12/07 02:22:11  vsnyder
! Remove unused parameter declaration
!
! Revision 2.97  2017/11/03 23:34:06  pwagner
! Fixed error where we omitted module procedure FindInRange_2d versions
!
! Revision 2.96  2017/11/03 19:56:36  pwagner
! Most array gymnastics moved from MLSFillValues to HyperSlabs module
!
! Revision 2.95  2017/11/02 00:09:38  pwagner
! Added Read,WriteLookupTable, 2d versions of FindInRange, and F_Of_X
!
! Revision 2.94  2017/10/31 23:46:29  vsnyder
! Make Coefficients and LookUpTable_0 parameterized types
!
! Revision 2.93  2017/10/17 23:41:31  pwagner
! Removed unused stuff
!
! Revision 2.92  2016/09/14 20:13:19  vsnyder
! Get PureHunt from Pure_Hunt_m
!
! Revision 2.91  2016/08/23 20:27:40  pwagner
! InterpolateArraySetup may return after failure if optional arg fail present
!
! Revision 2.90  2016/07/28 01:40:24  vsnyder
! Remove unused USE
!
! Revision 2.89  2016/06/02 02:11:51  vsnyder
! Add Average function
!
! Revision 2.88  2015/07/29 00:24:05  vsnyder
! Add InterpolateExtrapolate_[sd]_1
!
! Revision 2.87  2015/05/27 22:42:15  vsnyder
! Move Hunt-related stuff to Hunt_m to eliminate circular dependence
!
! Revision 2.86  2015/04/29 00:53:01  vsnyder
! Make some specific procedures public
!
! Revision 2.85  2015/04/11 01:28:25  vsnyder
! Add 'Second' argument to several routines
!
! Revision 2.84  2015/04/07 02:47:30  vsnyder
! Add InterpolateExtrapolate
!
! Revision 2.83  2015/03/28 01:49:22  vsnyder
! Moved Cross to Cross_m module
!
! Revision 2.82  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.81  2013/08/13 00:58:43  vsnyder
! Move SolveQuadratic into MLSNumerics
!
! Revision 2.80  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.79  2013/05/31 23:30:37  vsnyder
! Add two-argument cross product routines
!
! Revision 2.78  2013/05/31 02:37:11  vsnyder
! Add cross product
!
! Revision 2.77  2013/04/12 00:35:56  vsnyder
! Describe 'index' argument of Hunt more precisely
!
! Revision 2.76  2013/02/11 17:19:04  pwagner
! Battleship returns status if cant find root
!
! Revision 2.75  2012/12/20 01:06:15  vsnyder
! Add Interpolate_Regular_To_Irregular
!
! Revision 2.74  2012/06/12 18:10:00  pwagner
! Battleship can now find non-integer roots
!
! Revision 2.73  2012/05/25 20:53:21  pwagner
! Added multidimensional LinearInterpolate and HuntBox
!
! Revision 2.72  2012/04/20 23:55:22  pwagner
! Remove unused code, misleading comments
!
! Revision 2.71  2011/11/18 02:42:35  vsnyder
! Add Interpolate_2d_Composite
!
! Revision 2.70  2011/08/26 17:52:49  pwagner
! purehunt recovers optimized functionality of fwdmdls own hunt
!
! Revision 2.69  2011/08/26 00:23:56  pwagner
! Moved Simpson and CSpline functionality here from fwdmdl
!
! Revision 2.68  2011/08/20 00:47:14  vsnyder
! use IEEE_Arithmetic to get IEEE_Is_NaN
!
! Revision 2.67  2011/08/17 00:48:57  pwagner
! Fixed bug in Simpsons; made it public
!
! Revision 2.66  2011/03/22 23:37:56  pwagner
! Rerank now taken from MLSFillValues module
!
! Revision 2.65  2010/06/07 23:31:49  vsnyder
! Add BivariateLinearInterpolation
!
! Revision 2.64  2009/12/08 21:43:14  vsnyder
! Get Symm_Tri
!
! Revision 2.63  2009/11/17 23:34:38  vsnyder
! Alphabetize public procedure names, add components for periodic continuity
! to Coefficients_R* types, add Name argument to DumpCoefficients_r*
!
! Revision 2.62  2009/06/20 02:32:58  vsnyder
! Precompute more stuff, handle identical abscissae, in spline case
!
! Revision 2.61  2009/06/13 02:27:39  vsnyder
! Several coefficients_R8 should have been coefficients_R4
!
! Revision 2.60  2008/09/03 20:43:48  pwagner
! Added FindInRange
!
! Revision 2.59  2008/06/06 22:52:21  pwagner
! EssentiallyEqual moved to MLSFillValues
!
! Revision 2.58  2008/05/02 00:41:42  vsnyder
! Delete unused symbol
!
! Revision 2.57  2008/01/07 21:36:33  pwagner
! Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
!
! Revision 2.56  2007/08/20 22:03:31  pwagner
! Fixed another bug in HuntRange
!
! Revision 2.55  2007/08/13 17:28:46  pwagner
! Fixed obvious bugs in HuntRange
!
! Revision 2.54  2007/08/07 23:55:02  pwagner
! Added new data type, functions for approximating
!
! Revision 2.53  2007/07/31 22:48:27  pwagner
! UseLookUpTable can now differentiate, integrate
!
! Revision 2.52  2007/07/25 20:09:25  vsnyder
! Delete USE for unused entity
!
! Revision 2.51  2007/07/23 23:18:26  pwagner
! Battleship may be used with logical-valued function
!
! Revision 2.50  2007/06/21 00:49:52  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.49  2007/04/02 22:53:26  pwagner
! Added Battleship integer rootfinder
!
! Revision 2.48  2007/03/14 23:58:05  pwagner
! Improved precision when interpolating
!
! Revision 2.47  2007/03/02 18:21:14  pwagner
! Added LookUpTable routines
!
! Revision 2.46  2006/10/04 03:20:08  vsnyder
! Better comments for HUNT results
!
! Revision 2.45  2006/08/05 02:36:36  vsnyder
! Delete unused symbols
!
! Revision 2.44  2006/08/03 01:57:22  vsnyder
! Return an optional status flag from Hunt
!
! Revision 2.43  2006/01/14 00:53:05  pwagner
! Added HuntRange
!
! Revision 2.42  2006/01/05 03:46:47  vsnyder
! Add Interp_Bilinear_2d_1d_r*
!
! Revision 2.41  2006/01/05 00:56:03  pwagner
! Added ClosestElement for multidimensional, non-monotonic Hunting
!
! Revision 2.40  2005/12/16 00:02:05  pwagner
! FillValue-related stuff moved to new MLSFillValues module
!
! Revision 2.39  2005/11/04 18:47:34  pwagner
! Added IsMonotonic; Monotonize made public
!
! Revision 2.38  2005/08/15 20:35:37  pwagner
! Added Monotonize interfaces
!
! Revision 2.37  2005/08/06 01:36:30  vsnyder
! Add Dump for interpolation coefficients
!
! Revision 2.36  2005/08/05 20:34:47  pwagner
! ReplaceFillValues can now to interpolate to bridge across MissingValues
!
! Revision 2.35  2005/08/03 16:36:46  pwagner
! antiderivatives; added replaceFillValues
!
! Revision 2.34  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.33  2005/05/12 20:47:56  pwagner
! Added new versions of EssentaillyEqual discounting Fills, NaNs
!
! Revision 2.32  2005/01/19 17:16:48  pwagner
! Now gets dump from dump_0
!
! Revision 2.31  2004/09/28 23:14:24  pwagner
! Added isFillValue function
!
! Revision 2.30  2004/09/10 23:52:29  livesey
! Added the logSpace options for Hunt (not actually needed but never
! mind).
!
! Revision 2.29  2003/09/11 23:09:18  livesey
! Added skipNewY argument
!
! Revision 2.28  2003/04/04 00:10:08  livesey
! Added EssentiallyEqual
!
! Revision 2.27  2002/11/25 18:51:19  vsnyder
! More interfaces
!
! Revision 2.26  2002/11/23 00:01:00  vsnyder
! Modify interpolation to separate setup and teardown
!
! Revision 2.25  2002/10/08 00:09:12  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.24  2002/10/04 16:40:30  pwagner
! Fixed missing close quotes on include lines
!
! Revision 2.23  2002/10/04 01:48:27  vsnyder
! Get rid of a local variable
!
! Revision 2.22  2002/10/04 00:48:05  vsnyder
! Move declarations of local variables to includes.  Use generic
! InterpolateValues in InterpolateScalar routines.  Move guts of
! InterpolateScalar routines to an include file.
!
! Revision 2.21  2002/09/13 18:08:12  pwagner
! May change matrix precision rm from r8
!
! Revision 2.20  2002/09/11 17:43:38  pwagner
! Began changes needed to conform with matrix%values type move to rm from r8
!
! Revision 2.19  2002/05/24 17:00:55  livesey
! Fixed bug with interpolation with only one oldX value
!
! Revision 2.18  2001/12/01 01:03:07  livesey
! Bug fix with derivatives.
!
! Revision 2.17  2001/11/14 01:47:40  livesey
! Added nearest option to Hunt
!
! Revision 2.16  2001/10/19 23:41:43  livesey
! Fixed bug with dyByDx extrapolation
!
! Revision 2.15  2001/09/24 17:27:50  pwagner
! Removed random number things
!
! Revision 2.14  2001/09/20 20:54:55  pwagner
! Added random number stuff from MATH77
!
! Revision 2.13  2001/07/10 17:55:23  livesey
! Cosmetic changes only
!
! Revision 2.12  2001/07/06 18:44:40  dwu
! Add a feature in InterpolateScaler to handle periodic data
!
! Revision 2.11  2001/06/07 21:59:41  pwagner
! Added Copyright statement
!
! Revision 2.10  2001/05/08 23:25:58  livesey
! Added a nullify for oldSecond (how did I miss that?)
!
! Revision 2.9  2001/05/03 23:13:28  livesey
! Made Van's changes compile with NAG
!
! Revision 2.8  2001/05/03 21:54:49  vsnyder
! Added some nullify's, did some cosmetic changes
!
! Revision 2.7  2001/04/28 19:42:48  livesey
! Hunt now correctly handles cases where list is of size one.
! Changed to lower case keywords and reformatted.
!
! Revision 2.6  2001/04/28 07:05:05  livesey
! Minor bug fix in spline
!
! Revision 2.5  2001/04/11 22:43:19  vsnyder
! Let sparsify do the deallocate_test
!
! Revision 2.4  2001/03/06 00:35:23  livesey
! Missed one pointer nullification
!
! Revision 2.3  2001/03/05 01:20:36  livesey
! Nullified pointers
!
! Revision 2.2  2001/02/22 01:59:52  vsnyder
! Remove declarations for unused variables and parameters
!
! Revision 2.1  2001/02/09 00:38:55  livesey
! Various changes
!
! Revision 2.0  2000/09/05 17:41:06  dcuddy
! Change revision to 2.0
!
! Revision 1.13  2000/06/23 01:08:48  vsnyder
! Delete unused variables (except ID) to keep NAG f95 happy
!
@


2.100
log
@Made Destroy, Dump, and SetUp typebound procedures
@
text
@d57 1
a57 1
! LookUpTable_0_nprec    Uniformly discretized function
d61 1
d110 1
d121 3
a123 3
! Destroy ( LookUpTable_0_nprec UDF )
! nprec  dFdxApproximate ( nprec x, LookUpTable_0_nprec UDF )
! nprec  d2Fdx2Approximate ( nprec x, LookUpTable_0_nprec UDF )
d125 1
a125 1
! Dump ( LookUpTable_0_nprec UDF, [int Details] )
d128 2
a129 2
! nprec  FApproximate ( nprec x, LookUpTable_0_nprec UDF )
! nprec  FInvApproximate ( nprec y, LookUpTable_0_nprec UDF, &
d141 1
a141 1
! nprec  IFApproximate ( LookUpTable_0_nprec UDF, &
d163 1
a163 1
! Setup ( LookUpTable_0_nprec UDF, int N, nprec x1, nprec x2, [ nprec y(:)], &
d177 1
a177 1
  public :: Average, Battleship, BivariateLinearInterpolation
d253 1
a253 1
  ! This is a family of datatypes, the uniformly discretized function:
d258 1
a258 1
  ! In our usage it is an alternative to the *LookupTable procedures
d314 1
a314 1
  ! type(LookUpTable_0(r8)), save :: MLSUDF
d336 5
d493 3
d499 30
d1029 1
a1029 1
  subroutine destroyLookUpTable_0_r4 ( UDF )
d1031 1
a1031 1
    class(LookUpTable_0(r4)) :: UDF ! Intent(out) would clobber retainable values
d1033 2
a1034 2
    UDF%N       = 0
    call deallocate_test ( UDF%y, "UDF%y", ModuleName )
d1037 1
a1037 1
  subroutine destroyLookUpTable_0_r8 ( UDF )
d1039 1
a1039 1
    class(LookUpTable_0(r8)) :: UDF ! Intent(out) would clobber retainable values
d1041 2
a1042 2
    UDF%N       = 0
    call deallocate_test ( UDF%y, "UDF%y", ModuleName )
d1052 1
a1052 1
  ! UDF      the uniformly discretized function type
d1054 1
a1054 1
  function d2Fdx2Approximate_r4 ( x, UDF ) result(value)
d1058 1
a1058 1
    type(LookUpTable_0(r4)), intent(in)       :: UDF
d1066 2
a1067 2
    call reposit( x, UDF, arg, itsSign )
    options = UDF%method
d1069 1
a1069 1
    if ( arg < UDF%x1 ) then
d1071 1
a1071 1
    elseif ( arg > UDF%x2 ) then
d1074 2
a1075 2
      call createXArray( xArray, UDF )
      call InterpolateValues( xArray, UDF%y, (/arg/), newYr4, dyByDx=newdYr4, &
d1080 1
a1080 1
      value = UseLookUpTable ( arg, UDF%y, UDF%x1, UDF%x2, options=options // '2' )
d1085 1
a1085 1
  function d2Fdx2Approximate_r8 ( x, UDF ) result(value)
d1089 1
a1089 1
    type(LookUpTable_0(r8)), intent(in)       :: UDF
d1097 2
a1098 2
    call reposit( x, UDF, arg, itsSign )
    options = UDF%method
d1100 1
a1100 1
    if ( arg < UDF%x1 ) then
d1102 1
a1102 1
    elseif ( arg > UDF%x2 ) then
d1105 2
a1106 2
      call createXArray( xArray, UDF )
      call InterpolateValues( xArray, UDF%y, (/arg/), newYr8, dyByDx=newdYr8, &
d1111 1
a1111 1
      value = UseLookUpTable ( arg, UDF%y, UDF%x1, UDF%x2, options=options // '2' )
d1123 1
a1123 1
  ! UDF      the uniformly discretized function type
d1125 1
a1125 1
  function dFdxApproximate_r4 ( x, UDF ) result(value)
d1129 1
a1129 1
    type(LookUpTable_0(r4)), intent(in)       :: UDF
d1137 2
a1138 2
    call reposit( x, UDF, arg, itsSign )
    options = UDF%method
d1140 1
a1140 1
    if ( arg < UDF%x1 ) then
d1142 1
a1142 1
    elseif ( arg > UDF%x2 ) then
d1145 2
a1146 2
      call createXArray( xArray, UDF )
      call InterpolateValues( xArray, UDF%y, (/arg/), newYr4, dyByDx=newdYr4, &
d1151 1
a1151 1
      value = UseLookUpTable ( arg, UDF%y, UDF%x1, UDF%x2, options=options // '1' )
d1156 1
a1156 1
  function dFdxApproximate_r8 ( x, UDF ) result(value)
d1160 1
a1160 1
    type(LookUpTable_0(r8)), intent(in)       :: UDF
d1168 2
a1169 2
    call reposit( x, UDF, arg, itsSign )
    options = UDF%method
d1171 1
a1171 1
    if ( arg < UDF%x1 ) then
d1173 1
a1173 1
    elseif ( arg > UDF%x2 ) then
d1176 2
a1177 2
      call createXArray( xArray, UDF )
      call InterpolateValues( xArray, UDF%y, (/arg/), newYr8, dyByDx=newdYr8, &
d1182 1
a1182 1
      value = UseLookUpTable ( arg, UDF%y, UDF%x1, UDF%x2, options=options // '1' )
d1201 1
a1201 1
  subroutine DumpLookUpTable_0_r4 ( UDF, name, details )
d1203 1
a1203 1
    class(LookUpTable_0(r4)) :: UDF ! Intent(out) would clobber retainable values
d1214 8
a1221 8
    call outputNamedValue( 'N           ', UDF%N             )
    call outputNamedValue( 'x1          ', UDF%x1            )
    call outputNamedValue( 'x2          ', UDF%x2            )
    call outputNamedValue( 'BC          ', UDF%BC            )
    call outputNamedValue( 'method      ', UDF%method        )
    call outputNamedValue( 'yLeft       ', UDF%yLeft         )
    call outputNamedValue( 'yRight      ', UDF%yRight        )
    if ( .not. allocated(UDF%y) ) then
d1226 2
a1227 2
      call outputNamedValue( 'min(y)           ', minval(UDF%y) )
      call outputNamedValue( 'max(y)           ', maxval(UDF%y) )
d1230 1
a1230 1
    call dump ( UDF%y, name='y' )
d1233 1
a1233 1
  subroutine DumpLookUpTable_0_r8 ( UDF, name, details )
d1235 1
a1235 1
    class(LookUpTable_0(r8)) :: UDF ! Intent(out) would clobber retainable values
d1246 8
a1253 8
    call outputNamedValue( 'N           ', UDF%N             )
    call outputNamedValue( 'x1          ', UDF%x1            )
    call outputNamedValue( 'x2          ', UDF%x2            )
    call outputNamedValue( 'BC          ', UDF%BC            )
    call outputNamedValue( 'method      ', UDF%method        )
    call outputNamedValue( 'yLeft       ', UDF%yLeft         )
    call outputNamedValue( 'yRight      ', UDF%yRight        )
    if ( .not. allocated(UDF%y) ) then
d1258 2
a1259 2
      call outputNamedValue( 'min(y)           ', minval(UDF%y) )
      call outputNamedValue( 'max(y)           ', maxval(UDF%y) )
d1262 1
a1262 1
    call dump ( UDF%y, name='y' )
d1329 1
a1329 1
  ! UDF      the uniformly discretized function type
d1331 1
a1331 1
  function FApproximate_r4 ( x, UDF ) result(value)
d1335 1
a1335 1
    type(LookUpTable_0(r4)), intent(in)       :: UDF
d1343 1
a1343 1
    call reposit( x, UDF, arg, itsSign )
d1347 1
a1347 1
    options = UDF%method
d1349 8
a1356 8
    if ( arg < UDF%x1 ) then
      value = UDF%yLeft
    elseif ( arg == UDF%x1 ) then
      value = UDF%y(1)
    elseif ( arg == UDF%x2 ) then
      value = UDF%y(UDF%N)
    elseif ( arg > UDF%x2 ) then
      value = UDF%yRight
d1358 2
a1359 2
      call createXArray( xArray, UDF )
      call InterpolateValues( xArray, UDF%y, (/arg/), newYr4, method='S' )
d1364 1
a1364 1
      value = UseLookUpTable ( arg, UDF%y, UDF%x1, UDF%x2, options=options )
d1369 1
a1369 1
  function FApproximate_r8 ( x, UDF ) result(value)
d1373 1
a1373 1
    type(LookUpTable_0(r8)), intent(in)       :: UDF
d1381 1
a1381 1
    call reposit( x, UDF, arg, itsSign )
d1385 1
a1385 1
    options = UDF%method
d1387 8
a1394 8
    if ( arg < UDF%x1 ) then
      value = UDF%yLeft
    elseif ( arg == UDF%x1 ) then
      value = UDF%y(1)
    elseif ( arg == UDF%x2 ) then
      value = UDF%y(UDF%N)
    elseif ( arg > UDF%x2 ) then
      value = UDF%yRight
d1396 2
a1397 2
      call createXArray( xArray, UDF )
      call InterpolateValues( xArray, UDF%y, (/arg/), newYr8, method='S' )
d1402 1
a1402 1
      value = UseLookUpTable ( arg, UDF%y, UDF%x1, UDF%x2, options=options )
d1414 2
a1415 2
  ! UDF      the uniformly discretized function type
  ! [xS,xE]  range in which to search (otherwise [UDF%x1, UDF%x2])
d1419 1
a1419 1
  function FInvApproximate_r4 ( y, UDF, xS, xE ) result(x)
d1423 1
a1423 1
    type(LookUpTable_0(r4)), intent(in)  :: UDF
d1430 2
a1431 2
    call createXArray( xArray, UDF )
    x = UseLookUpTable( y, xArray, xtable=UDF%y, yBottom=xS, yTop=xE )
d1435 1
a1435 1
  function FInvApproximate_r8 ( y, UDF, xS, xE ) result(x)
d1439 1
a1439 1
    type(LookUpTable_0(r8)), intent(in)  :: UDF
d1446 2
a1447 2
    call createXArray( xArray, UDF )
    x = UseLookUpTable( y, xArray, xtable=UDF%y, yBottom=xS, yTop=xE )
d1542 2
a1543 2
  ! UDF      the uniformly discretized function type
  ! [xS,xE]  range over which to integrate (otherwise [UDF%x1, UDF%x2])
d1545 1
a1545 1
  function IFApproximate_r4 ( UDF, xS, xE ) result(value)
d1548 1
a1548 1
    type(LookUpTable_0(r4)), intent(in)  :: UDF
d1557 2
a1558 2
    x1 = UDF%x1
    x2 = UDF%x2
d1561 1
a1561 1
    options = UDF%method
d1563 1
a1563 1
    if ( x2 < UDF%x1 ) then
d1565 1
a1565 1
    elseif ( x1 > UDF%x2 ) then
d1568 1
a1568 1
      call createXArray( xArray, UDF )
d1573 1
a1573 1
      value = UseLookUpTable ( x2, UDF%y, UDF%x1, UDF%x2, options=options // 'S' ) &
d1575 1
a1575 1
           &  UseLookUpTable ( x1, UDF%y, UDF%x1, UDF%x2, options=options // 'S' )
d1579 1
a1579 1
  function IFApproximate_r8 ( UDF, xS, xE ) result(value)
d1582 1
a1582 1
    type(LookUpTable_0(r8)), intent(in)  :: UDF
d1591 2
a1592 2
    x1 = UDF%x1
    x2 = UDF%x2
d1595 1
a1595 1
    options = UDF%method
d1597 1
a1597 1
    if ( x2 < UDF%x1 ) then
d1599 1
a1599 1
    elseif ( x1 > UDF%x2 ) then
d1602 1
a1602 1
      call createXArray( xArray, UDF )
d1607 1
a1607 1
      value = UseLookUpTable ( x2, UDF%y, UDF%x1, UDF%x2, options=options // 'S' ) &
d1609 1
a1609 1
           &  UseLookUpTable ( x1, UDF%y, UDF%x1, UDF%x2, options=options // 'S' )
d2208 1
a2208 1
  subroutine setUpLookUpTable_0_r4 ( UDF, N, x1, x2, &
d2212 1
a2212 1
    class(LookUpTable_0(r4)) :: UDF ! Intent(out) would clobber defaults
d2225 9
a2233 9
    UDF%N       = N
    UDF%x1      = x1
    UDF%x2      = x2
    call allocate_test ( UDF%y, N, "UDF%y", ModuleName )
    if ( present(y        ) ) UDF%y           = y
    if ( present(BC       ) ) UDF%BC          = BC
    if ( present(method   ) ) UDF%method      = method
    if ( present(yLeft    ) ) UDF%yLeft       = yLeft
    if ( present(yRight   ) ) UDF%yRight      = yRight
d2236 1
a2236 1
      UDF%y(i) = fun( x1 + (i-1)*(x2-x1)/(N-1) )
d2240 1
a2240 1
  subroutine setUpLookUpTable_0_r8 ( UDF, N, x1, x2, &
d2244 1
a2244 1
    class(LookUpTable_0(r8)) :: UDF ! Intent(out) would clobber defaults
d2257 9
a2265 9
    UDF%N       = N
    UDF%x1      = x1
    UDF%x2      = x2
    call allocate_test ( UDF%y, N, "UDF%y", ModuleName )
    if ( present(y        ) ) UDF%y           = y
    if ( present(BC       ) ) UDF%BC          = BC
    if ( present(method   ) ) UDF%method      = method
    if ( present(yLeft    ) ) UDF%yLeft       = yLeft
    if ( present(yRight   ) ) UDF%yRight      = yRight
d2268 1
a2268 1
      UDF%y(i) = fun( x1 + (i-1)*(x2-x1)/(N-1) )
d2444 2
a2445 2
  ! for the UDF
  subroutine CreateXArray_r4( xArray, UDF )
d2449 1
a2449 1
    type(LookUpTable_0(r4)), intent(in)       :: UDF
d2453 3
a2455 3
    call allocate_test( xArray, UDF%N, 'xArray (r4)', ModuleName )
    do i=1, UDF%N
      xArray(i) = UDF%x1 + (i-1)*(UDF%x2-UDF%x1)/(UDF%N-1)
d2460 1
a2460 1
  subroutine CreateXArray_r8( xArray, UDF )
d2464 1
a2464 1
    type(LookUpTable_0(r8)), intent(in)       :: UDF
d2468 3
a2470 3
    call allocate_test( xArray, UDF%N, 'xArray (r8)', ModuleName )
    do i=1, UDF%N
      xArray(i) = UDF%x1 + (i-1)*(UDF%x2-UDF%x1)/(UDF%N-1)
d2544 2
a2545 2
  ! considering the type of BC determined by the UDF
  subroutine Reposit_r4 ( x, UDF, p, itsSign )
d2549 1
a2549 1
    type(LookUpTable_0(r4)), intent(in)       :: UDF
d2559 2
a2560 2
    if (  UDF%x1 <= x .and. x <= UDF%x2 ) return
    select case ( UDF%BC )
d2564 2
a2565 2
      d = max( UDF%x1 - x, x - UDF%x2 )
      Period = UDF%x2 - UDF%x1
d2567 1
a2567 1
      if ( x < UDF%x1 ) then
d2577 1
a2577 1
      if ( mod(k, 2) /= 0 .and. UDF%BC == 'scyclic' ) itsSign = -1
d2579 1
a2579 1
      ! The caller will utilize UDF%y(Left)(Right)
d2582 2
a2583 2
      p = max( p, UDF%x1 )
      p = min( p, UDF%x2 )
d2588 1
a2588 1
  subroutine Reposit_r8( x, UDF, p, itsSign )
d2592 1
a2592 1
    type(LookUpTable_0(r8)), intent(in)       :: UDF
d2602 2
a2603 2
    if (  UDF%x1 <= x .and. x <= UDF%x2 ) return
    select case ( UDF%BC )
d2607 2
a2608 2
      d = max( UDF%x1 - x, x - UDF%x2 )
      Period = UDF%x2 - UDF%x1
d2610 1
a2610 1
      if ( x < UDF%x1 ) then
d2620 1
a2620 1
      if ( mod(k, 2) /= 0 .and. UDF%BC == 'scyclic' ) itsSign = -1
d2622 1
a2622 1
      ! The caller will utilize UDF%y(Left)(Right)
d2625 2
a2626 2
      p = max( p, UDF%x1 )
      p = min( p, UDF%x2 )
d2682 1
a2682 1
       "$Id: MLSNumerics.f90,v 2.99 2018/12/03 23:19:58 pwagner Exp $"
d2694 3
@


2.99
log
@Changed name of datatype to more natural LookUpTable
@
text
@d100 1
a100 1
! Setup                    Fill y values in UniDiscFunction
d297 12
a308 2
    real(rk), dimension(:), pointer :: y => null() ! y(xi)
    ! type(Coefficients(rk)) :: Coeffs                ! in case we'll use splines
d315 1
a315 1
  ! (1) Relaxes the rquirement that the x values are uniformly spaced
d330 2
a331 2
    real(rk), dimension(:), pointer :: x => null() ! the x values
    real(rk), dimension(:), pointer :: a => null() ! the a values
d987 2
a988 1
  ! This family of routines deallocates a uniDiscFunction's arrays
d991 1
a991 1
    type(LookUpTable_0(r4)) :: UDF ! Intent(out) would clobber retainable values
d999 1
a999 1
    type(LookUpTable_0(r8)) :: UDF ! Intent(out) would clobber retainable values
d1007 1
a1007 1
  ! This family of routines use a uniDiscFunction to approximate a 
d1078 1
a1078 1
  ! This family of routines use a uniDiscFunction to approximate a 
d1160 1
d1163 1
a1163 1
    type(LookUpTable_0(r4)) :: UDF ! Intent(out) would clobber retainable values
d1181 1
a1181 1
    if ( .not. associated(UDF%y) ) then
d1195 1
a1195 1
    type(LookUpTable_0(r8)) :: UDF ! Intent(out) would clobber retainable values
d1213 1
a1213 1
    if ( .not. associated(UDF%y) ) then
d1284 1
a1284 1
  ! This family of routines use a uniDiscFunction to approximate a 
d1369 1
a1369 1
  ! This family of routines use a uniDiscFunction to approximately invert 
d1498 1
a1498 1
  ! This family of routines use a uniDiscFunction to approximate a 
d2166 2
a2167 1
  ! This family of routines sets up a uniDiscFunction of the appropriate type
d2172 1
a2172 1
    type(LookUpTable_0(r4)) :: UDF ! Intent(out) would clobber defaults
d2204 1
a2204 1
    type(LookUpTable_0(r8)) :: UDF ! Intent(out) would clobber defaults
d2642 1
a2642 1
       "$Id: MLSNumerics.f90,v 2.98 2017/12/07 02:22:11 vsnyder Exp $"
d2654 3
@


2.98
log
@Remove unused parameter declaration
@
text
@d48 1
a48 1
  ! (c) Like (a) but using a user-defined datatype, the UnifDiscreteFn
d57 1
a57 1
! UnifDiscreteFn_nprec    Uniformly discretized function
d64 1
d67 3
a69 3
! Destroy                  Deallocate y values in UnifDiscreteFn
! d2Fdx2Approximate        Compute 2nd derivative using UnifDiscreteFn
! dFdxApproximate          Compute derivative using UnifDiscreteFn
d86 1
a86 1
! IFApproximate            Compute integral using UnifDiscreteFn
d119 3
a121 3
! Destroy ( UnifDiscreteFn_nprec UDF )
! nprec  dFdxApproximate ( nprec x, UnifDiscreteFn_nprec UDF )
! nprec  d2Fdx2Approximate ( nprec x, UnifDiscreteFn_nprec UDF )
d123 1
a123 1
! Dump ( UnifDiscreteFn_nprec UDF, [int Details] )
d126 2
a127 2
! nprec  FApproximate ( nprec x, UnifDiscreteFn_nprec UDF )
! nprec  FInvApproximate ( nprec y, UnifDiscreteFn_nprec UDF, &
d139 1
a139 1
! nprec  IFApproximate ( UnifDiscreteFn_nprec UDF, &
d161 1
a161 1
! Setup ( UnifDiscreteFn_nprec UDF, int N, nprec x1, nprec x2, [ nprec y(:)], &
d288 1
a288 1
  type, public :: UnifDiscreteFn ( RK )
d299 1
a299 1
  end type UnifDiscreteFn
d301 22
a322 2
  ! No use for a class member of this datatype yet
  ! type(UnifDiscreteFn(r8)), save :: MLSUDF
d347 2
a348 2
  interface CSPLINE
    module procedure D_CSPLINE, S_CSPLINE
d352 1
a352 1
    module procedure destroyUnifDiscreteFn_r4, destroyUnifDiscreteFn_r8
d365 1
a365 1
    module procedure DumpUnifDiscreteFn_r4, DumpUnifDiscreteFn_r8
d450 1
a450 1
    module procedure setUpUnifDiscreteFn_r4, setUpUnifDiscreteFn_r8
d543 3
d978 1
a978 1
  subroutine destroyUnifDiscreteFn_r4 ( UDF )
d980 1
a980 1
    type(UnifDiscreteFn(r4)) :: UDF ! Intent(out) would clobber retainable values
d984 1
a984 1
  end subroutine destroyUnifDiscreteFn_r4
d986 1
a986 1
  subroutine destroyUnifDiscreteFn_r8 ( UDF )
d988 1
a988 1
    type(UnifDiscreteFn(r8)) :: UDF ! Intent(out) would clobber retainable values
d992 1
a992 1
  end subroutine destroyUnifDiscreteFn_r8
d1007 1
a1007 1
    type(UnifDiscreteFn(r4)), intent(in)       :: UDF
d1038 1
a1038 1
    type(UnifDiscreteFn(r8)), intent(in)       :: UDF
d1078 1
a1078 1
    type(UnifDiscreteFn(r4)), intent(in)       :: UDF
d1109 1
a1109 1
    type(UnifDiscreteFn(r8)), intent(in)       :: UDF
d1149 1
a1149 1
  subroutine DumpUnifDiscreteFn_r4 ( UDF, name, details )
d1151 1
a1151 1
    type(UnifDiscreteFn(r4)) :: UDF ! Intent(out) would clobber retainable values
d1179 1
a1179 1
  end subroutine DumpUnifDiscreteFn_r4
d1181 1
a1181 1
  subroutine DumpUnifDiscreteFn_r8 ( UDF, name, details )
d1183 1
a1183 1
    type(UnifDiscreteFn(r8)) :: UDF ! Intent(out) would clobber retainable values
d1211 1
a1211 1
  end subroutine DumpUnifDiscreteFn_r8
d1283 1
a1283 1
    type(UnifDiscreteFn(r4)), intent(in)       :: UDF
d1321 1
a1321 1
    type(UnifDiscreteFn(r8)), intent(in)       :: UDF
d1371 1
a1371 1
    type(UnifDiscreteFn(r4)), intent(in)  :: UDF
d1387 1
a1387 1
    type(UnifDiscreteFn(r8)), intent(in)  :: UDF
d1496 1
a1496 1
    type(UnifDiscreteFn(r4)), intent(in)  :: UDF
d1530 1
a1530 1
    type(UnifDiscreteFn(r8)), intent(in)  :: UDF
d2155 1
a2155 1
  subroutine setUpUnifDiscreteFn_r4 ( UDF, N, x1, x2, &
d2159 1
a2159 1
    type(UnifDiscreteFn(r4)) :: UDF ! Intent(out) would clobber defaults
d2185 1
a2185 1
  end subroutine setUpUnifDiscreteFn_r4
d2187 1
a2187 1
  subroutine setUpUnifDiscreteFn_r8 ( UDF, N, x1, x2, &
d2191 1
a2191 1
    type(UnifDiscreteFn(r8)) :: UDF ! Intent(out) would clobber defaults
d2217 1
a2217 1
  end subroutine setUpUnifDiscreteFn_r8
d2396 1
a2396 1
    type(UnifDiscreteFn(r4)), intent(in)       :: UDF
d2411 1
a2411 1
    type(UnifDiscreteFn(r8)), intent(in)       :: UDF
d2496 1
a2496 1
    type(UnifDiscreteFn(r4)), intent(in)       :: UDF
d2539 1
a2539 1
    type(UnifDiscreteFn(r8)), intent(in)       :: UDF
d2601 1
a2601 1
! ....................................................  D_CSPLINE  .....
d2603 2
a2604 2
  subroutine D_CSPLINE (XIN, XOUT, YIN, YOUT, NIN, NOUT, YMIN, YMAX)
    integer, parameter :: RK = kind(0.0d0)
d2606 1
a2606 1
  end subroutine D_CSPLINE
d2608 3
a2610 3
! ....................................................  S_CSPLINE  .....
  subroutine S_CSPLINE (XIN, XOUT, YIN, YOUT, NIN, NOUT, YMIN, YMAX)
    integer, parameter :: RK = kind(0.0e0)
d2612 1
a2612 1
  end subroutine S_CSPLINE
d2615 1
a2615 1
  subroutine D_PCSPL ( TAU, C, N, IBCBEG, IBCEND )
d2629 1
a2629 1
       "$Id: MLSNumerics.f90,v 2.97 2017/11/03 23:34:06 pwagner Exp $"
d2641 3
d2654 1
a2654 1
! Make Coefficients and UnifDiscreteFn parameterized types
@


2.97
log
@Fixed error where we omitted module procedure FindInRange_2d versions
@
text
@a1437 1
    integer, parameter :: RK = kind(0.0e0)
d2605 1
a2605 1
       "$Id: MLSNumerics.f90,v 2.96 2017/11/03 19:56:36 pwagner Exp $"
d2617 3
@


2.96
log
@Most array gymnastics moved from MLSFillValues to HyperSlabs module
@
text
@d367 1
d2606 1
a2606 1
       "$Id: MLSNumerics.f90,v 2.95 2017/11/02 00:09:38 pwagner Exp $"
d2618 3
@


2.95
log
@Added Read,WriteLookupTable, 2d versions of FindInRange, and F_Of_X
@
text
@d17 1
d22 1
a22 1
 use MLSFillValues, only: IsfillValue, Rerank
d2605 1
a2605 1
       "$Id: MLSNumerics.f90,v 2.94 2017/10/31 23:46:29 vsnyder Exp $"
d2617 3
@


2.94
log
@Make Coefficients and UnifDiscreteFn parameterized types
@
text
@d27 1
d43 6
d70 1
d97 1
d102 2
a103 1
!                            (or its derivatives or integral)
d122 2
d130 1
d152 1
a152 1
!   coefficients_nprec Coeffs, &[log Extrapolate], [int Width], [log DyByDx], 
d158 1
d166 2
d176 1
a176 1
  public :: FApproximate, FillLookupTable, FindInRange, FinvApproximate
d187 1
a187 1
  public :: UseLookupTable
d252 1
a252 1
  ! called sometimes a look up table
d254 4
a257 1

d280 5
a284 2
  ! Another family of datatypes may someday be implemented,
  ! which would utilize non-uniformly spaced x values
d346 6
d421 4
d445 4
d1186 33
d1220 24
d1435 24
d2096 31
d2292 25
d2604 1
a2604 1
       "$Id: MLSNumerics.f90,v 2.93 2017/10/17 23:41:31 pwagner Exp $"
d2616 3
@


2.93
log
@Removed unused stuff
@
text
@d173 2
a174 1
  type, public :: Coefficients_R4
d189 2
a190 2
    integer, pointer :: LowerInds(:) => NULL()
    real(r4), pointer :: A(:) => NULL(), B(:) => NULL(), Gap(:) => NULL()
d193 1
a193 1
    real(r4), pointer :: C(:) => NULL(), D(:) => NULL()
d206 1
a206 1
    real(r4), pointer :: dX(:) => NULL(), P(:) => NULL(), O(:) => NULL()
d212 1
a212 1
    real(r4), pointer :: Col(:) => NULL(), Row(:) => NULL()
d218 1
a218 1
    real(r4), pointer :: E(:) => NULL(), F(:) => NULL()
d227 2
a228 2
    real(r4), pointer :: AI(:) => NULL(), BI(:) => NULL(), &
      &                  CI(:) => NULL(), DI(:) => NULL()
d230 2
a231 61
    logical, pointer :: BadValue(:) => NULL()
  end type Coefficients_R4

  type, public :: Coefficients_R8
    private
    !{ Coefficients for linear interpolation:  Let $\{x\} =$ {\tt oldX} and
    !  $\{\chi\} =$ {\tt newX}.  Then
    !  {\tt Gap(j)} $= g_j = x_{i+1}-x_i$, $A_j = \frac{x_{i+1}-\chi_j}{g_j}$,    
    !                                  and $B_j = 1-A_j = \frac{\chi_j-x_i}{g_j}$,
    !  where $i$ is such that $x_i \leq \chi_j < x_{i+1}$ for $1 \leq j \leq$
    !  {\tt size(newX)}.
    !  {\tt lowerInds} = $\{i\, |\, x_i \leq \chi_j < x_{i+1},\,1 \leq j \leq$
    !  {\tt size(newX)}$\}$.
    !  $|\{g\}| = |\{A\}| = |\{B\}|$, and
    !  others that depend upon them, $=|\{\chi\}|$ = {\tt size(newX)}.
    !  Coefficients for differentiation in the linear case (and of the linear
    !  terms in the spline case) are just $-1$ and $+1$, so they're not
    !  computed here.
    integer, pointer :: LowerInds(:) => NULL()
    real(r8), pointer :: A(:) => NULL(), B(:) => NULL(), Gap(:) => NULL()
    !{ Coefficients for spline interpolation:
    !  $C = (A^3-A) \frac{g^2}6$.  $D = (B^3-B) \frac{g^2}6$.
    real(r8), pointer :: C(:) => NULL(), D(:) => NULL()
    !{ {\tt dX(i)} $= \delta_i = x_i-x_{i-1}$ for $1 < i \leq$ {\tt size(oldX)} and
    !  $\Delta_i = x_{i+1}-x_{i-1} = \delta_i + \delta_{i+1}$ for $1 < i <$
    !  {\tt size(oldX)}.
    !  {\tt P(i)} $= p_i = \frac1{\delta_i o_{i-1} + 2 \Delta_i}$ and
    !  {\tt O(i)} $= o_i = -\delta_{i+1} p_i$
    !  for $1 < i <$ {\tt size(oldX)} and zero at the ends.
    !  $p_i$ is the inverse of the diagonal of $L$ in the $LU$ factorization
    !  of the symmetric tridiagonal linear system for splines, $\delta_i$ is
    !  the subdiagonal of $L$, and $o_i$ is the negative of the
    !  superdiagonal of $U$.  The nonzero part of each row of the original
    !  system is of the form $[\delta_{i-1},\, 2 \Delta_i ,\, \delta_i]$.
    !  See wvs-086.
    real(r8), pointer :: dX(:) => NULL(), P(:) => NULL(), O(:) => NULL()
    !{ In the periodic continuity case, {\tt Col} is the rightmost column of
    !  $U$ and {\tt Row} is the bottom row of $L$.  During the backsolve, the
    !  last element of {\tt Col} is used instead of the last element of $o$,
    !  and the last element of {\tt Row} is used instead of the last element
    !  of $\delta$.
    real(r8), pointer :: Col(:) => NULL(), Row(:) => NULL()
    !{ Coefficients for spline derivatives:
    !  $E = \frac{\text{d}C}{\text{d}A} = \frac6g \frac{\text{d}C}{\text{d}x}
    !     = 3 A^2 - 1$.
    !  $F = \frac{\text{d}D}{\text{d}A} = \frac6g \frac{\text{d}D}{\text{d}x}
    !     = 3 B^2 - 1$.
    real(r8), pointer :: E(:) => NULL(), F(:) => NULL()
    !{ Coefficients for integration:
    !  $\int A \text{d}x =  \frac{x(x_{i+1}-\frac{x}2)}g$.
    !  $\int B \text{d}x = -\frac{x(x_i    -\frac{x}2)}g
    !                    = x - \int A \text{d}x$.\\
    !  $\int C \text{d}x = -\frac{g^2}6
    !                      \left( \int A \text{d}x + \frac{g A^4}4 \right)$.
    !  $\int D \text{d}x = -\frac{g^2}6
    !                      \left( \int B \text{d}x - \frac{g B^4}4 \right)$.
    real(r8), pointer :: AI(:) => NULL(), BI(:) => NULL(), &
      &                  CI(:) => NULL(), DI(:) => NULL()
    ! Stuff for extrapolation == "B"ad
    logical, pointer :: BadValue(:) => NULL()
  end type Coefficients_R8
d264 2
a265 13
  type, public :: UnifDiscreteFn_r4
    integer :: N = 0                               ! The number of values xi
    character(len=8) :: BC = 'clamped'             ! boundary conditions
    character(len=1) :: method = ' '               ! which of closest xi to use
    real(r4) :: x1                                 ! x1 <= xi <= x2
    real(r4) :: x2
    real(r4) :: yLeft  = 0.                        ! Assume all x < x1 are this
    real(r4) :: yRight = 0.                        ! Assume all x > x2 are this
    real(r4), dimension(:), pointer :: y => null() ! y(xi)
    ! type(Coefficients_R4) :: Coeffs                ! in case we'll use splines
  end type UnifDiscreteFn_r4

  type, public :: UnifDiscreteFn_r8
d269 7
a275 7
    real(r8) :: x1                                 ! x1 <= xi <= x2
    real(r8) :: x2
    real(r8) :: yLeft  = 0.                        ! Assume all y < x1 are this
    real(r8) :: yRight = 0.                        ! Assume all y > x2 are this
    real(r8), dimension(:), pointer :: y => null() ! y(xi)
    ! type(Coefficients_R8) :: Coeffs                ! in case we'll use splines
  end type UnifDiscreteFn_r8
d278 1
a278 1
  ! type(UnifDiscreteFn_r8), save :: MLSUDF
d918 1
a918 1
    type(UnifDiscreteFn_r4) :: UDF ! Intent(out) would clobber retainable values
d926 1
a926 1
    type(UnifDiscreteFn_r8) :: UDF ! Intent(out) would clobber retainable values
d945 1
a945 1
    type(UnifDiscreteFn_r4), intent(in)       :: UDF
d976 1
a976 1
    type(UnifDiscreteFn_r8), intent(in)       :: UDF
d1016 1
a1016 1
    type(UnifDiscreteFn_r4), intent(in)       :: UDF
d1047 1
a1047 1
    type(UnifDiscreteFn_r8), intent(in)       :: UDF
d1076 1
a1076 1
    type(coefficients_r4), intent(in) :: Coeffs
d1082 1
a1082 1
    type(coefficients_r8), intent(in) :: Coeffs
d1089 1
a1089 1
    type(UnifDiscreteFn_r4) :: UDF ! Intent(out) would clobber retainable values
d1121 1
a1121 1
    type(UnifDiscreteFn_r8) :: UDF ! Intent(out) would clobber retainable values
d1164 1
a1164 1
    type(UnifDiscreteFn_r4), intent(in)       :: UDF
d1202 1
a1202 1
    type(UnifDiscreteFn_r8), intent(in)       :: UDF
d1252 1
a1252 1
    type(UnifDiscreteFn_r4), intent(in)  :: UDF
d1268 1
a1268 1
    type(UnifDiscreteFn_r8), intent(in)  :: UDF
d1354 1
a1354 1
    type(UnifDiscreteFn_r4), intent(in)  :: UDF
d1388 1
a1388 1
    type(UnifDiscreteFn_r8), intent(in)  :: UDF
d1463 1
a1463 1
    type(coefficients_r4) :: Coeffs
d1494 1
a1494 1
    type(coefficients_r8) :: Coeffs
d1509 1
a1509 1
    type(coefficients_R4), intent(out) :: Coeffs
d1535 1
a1535 1
    type(coefficients_R8), intent(out) :: Coeffs
d1556 1
a1556 1
    type(coefficients_R4), intent(inout) :: Coeffs
d1566 1
a1566 1
    type(coefficients_R8), intent(inout) :: Coeffs
d1585 1
a1585 1
    type(coefficients_r8) :: Coeffs
d1603 1
a1603 1
    type(coefficients_r8) :: Coeffs
d1622 1
a1622 1
    type(coefficients_r4) :: Coeffs
d1640 1
a1640 1
    type(coefficients_r4) :: Coeffs
d1707 1
a1707 1
    type(coefficients_r4), intent(in) :: Coeffs
d1733 1
a1733 1
    type(coefficients_r8), intent(in) :: Coeffs
d1760 1
a1760 1
    type(coefficients_r4), intent(in) :: Coeffs
d1790 1
a1790 1
    type(coefficients_r8), intent(in) :: Coeffs
d1903 1
a1903 1
    type(coefficients_r4) :: XCoeffs, YCoeffs
d1926 1
a1926 1
    type(coefficients_r8) :: XCoeffs, YCoeffs
d1986 1
a1986 1
    type(UnifDiscreteFn_r4) :: UDF ! Intent(out) would clobber defaults
d2018 1
a2018 1
    type(UnifDiscreteFn_r8) :: UDF ! Intent(out) would clobber defaults
d2198 1
a2198 1
    type(UnifDiscreteFn_r4), intent(in)       :: UDF
d2213 1
a2213 1
    type(UnifDiscreteFn_r8), intent(in)       :: UDF
d2298 1
a2298 1
    type(UnifDiscreteFn_r4), intent(in)       :: UDF
d2341 1
a2341 1
    type(UnifDiscreteFn_r8), intent(in)       :: UDF
d2431 1
a2431 1
       "$Id: MLSNumerics.f90,v 2.92 2016/09/14 20:13:19 vsnyder Exp $"
d2443 3
@


2.92
log
@Get PureHunt from Pure_Hunt_m
@
text
@d16 14
a29 14
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only : DUMP
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use Hunt_M, only: Hunt, HuntBox, HuntRange
  use MATRIXMODULE_0, only: CREATEBLOCK, M_ABSENT, MATRIXELEMENT_T, SPARSIFY
  use MLSFILLVALUES, only: ISFILLVALUE, RERANK
  use MLSKINDS, only: I4, R4, R8, RM
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING, &
    & MLSMESSAGE
  use MLSFINDS, only: FINDFIRST, FINDLAST
  use MLSSTRINGS, only: CAPITALIZE, TRIM_SAFE
  use OUTPUT_M, only: BLANKS, OUTPUT
  use Pure_Hunt_m, only: PureHunt
  use SYMM_TRI, only: FACTOR_SYMM_TRI, SOLVE_FACTORED_SYMM_TRI
d97 1
a1144 2
    use Dump_0, only: Dump
    use Output_m, only: Output
a1150 2
    use Dump_0, only: Dump
    use Output_m, only: Output
a2474 2
    ! use D_HUNT_M, only: HUNT
    ! use D_PCSPL_M, only: PCSPL
a2480 2
    ! use S_HUNT_M, only: HUNT
    ! use S_PCSPL_M, only: PCSPL
d2500 1
a2500 1
       "$Id: MLSNumerics.f90,v 2.91 2016/08/23 20:27:40 pwagner Exp $"
d2512 3
@


2.91
log
@InterpolateArraySetup may return after failure if optional arg fail present
@
text
@d19 1
a19 1
  use Hunt_M, only: Hunt, HuntBox, HuntRange, PureHunt
d28 1
d2507 1
a2507 1
       "$Id: MLSNumerics.f90,v 2.90 2016/07/28 01:40:24 vsnyder Exp $"
d2519 3
@


2.90
log
@Remove unused USE
@
text
@d1574 1
a1574 1
    & Extrapolate, Width, DyByDx, dNewByDOld, IntYdX )
d1591 1
d1600 1
a1600 1
    & Extrapolate, Width, DyByDx, dNewByDOld, IntYdX )
d1617 1
d2506 1
a2506 1
       "$Id: MLSNumerics.f90,v 2.89 2016/06/02 02:11:51 vsnyder Exp $"
d2518 3
@


2.89
log
@Add Average function
@
text
@d17 1
a17 1
  use DUMP_0, only : DUMP, SELFDIFF
d21 1
a21 2
  use MLSCOMMON, only : UNDEFINEDVALUE
  use MLSFILLVALUES, only: ISFILLVALUE, REPLACEFILLVALUES, RERANK
d2504 1
a2504 1
       "$Id: MLSNumerics.f90,v 2.88 2015/07/29 00:24:05 vsnyder Exp $"
d2516 3
@


2.88
log
@Add InterpolateExtrapolate_[sd]_1
@
text
@d53 1
d156 1
a156 1
  public :: Battleship, BivariateLinearInterpolation
d295 1
a295 1
  
d306 1
a306 1
  
d320 1
a320 1
  
d332 1
a332 1
  
d344 1
a344 1
  
d347 5
a351 1
  
d488 10
d519 1
a519 1
  
d522 1
a522 1
  
d529 1
a529 1
  
d889 1
a889 1
  
d1004 1
a1004 1
  
d1008 1
a1008 1
  
d1075 1
a1075 1
  
d1079 1
a1079 1
  
d1227 1
a1227 1
  
d1231 1
a1231 1
  
d1312 1
a1312 1
  
d1317 1
a1317 1
  
d1319 1
a1319 1
  
d1358 1
a1358 1
  
d1418 1
a1418 1
  
d1422 1
a1422 1
  
d2004 1
a2004 1
  
d2008 1
a2008 1
  
d2169 1
a2169 1
  
d2178 1
a2178 1
  
d2190 1
a2190 1
  
d2505 1
a2505 1
       "$Id: MLSNumerics.f90,v 2.87 2015/05/27 22:42:15 vsnyder Exp $"
d2517 3
@


2.87
log
@Move Hunt-related stuff to Hunt_m to eliminate circular dependence
@
text
@d412 2
a413 1
    module procedure InterpolateExtrapolate_d, InterpolateExtrapolate_s
d1632 1
a1632 1
    ! the dimension upon which to interpolate is merge(2,1,second)
d1646 18
d1669 1
a1669 1
    ! the dimension upon which to interpolate is merge(2,1,second)
d1683 18
d2490 1
a2490 1
       "$Id: MLSNumerics.f90,v 2.86 2015/04/29 00:53:01 vsnyder Exp $"
d2502 3
@


2.86
log
@Make some specific procedures public
@
text
@d19 1
a402 13
  interface Hunt
    module procedure HuntArray_r8, HuntArray_r4
    module procedure HuntScalar_r8, HuntScalar_r4
  end interface

  interface HuntBox
    module procedure HuntBox_r4, HuntBox_r8
  end interface

  interface HuntRange
    module procedure HuntRange_int, HuntRange_r4, HuntRange_r8
  end interface

a450 4
  interface purehunt
    module procedure purehunt_r4, purehunt_r8
  end interface

a1397 149
! -------------------------------------------------  HuntArray_r4  -----

  ! This routine does the classic hunt the value kind of thing.  This
  ! does the hunt/bisect implemention a la Numerical Recipes.  List must
  ! be monotonically increasing or decreasing. There is no such
  ! requirement for values.

  subroutine HuntArray_r4 ( list, values, indices, start, allowTopValue, &
    & allowBelowValue, nearest, logSpace, fail )
    use ieee_arithmetic, only: IEEE_Is_NaN
    integer, parameter :: RK = kind(0.0e0)

    ! Dummy arguments
    real(rk), dimension(:), intent(in) :: list ! List to search
    real(rk), dimension(:), intent(in) :: values ! Values to search for
    integer, dimension(:), intent(out) :: indices ! list(indices) <= values
      !                                               <= list(indices+1)
      !                                      1 <= indices < N unless
      !                                      allowTopValue or allowBelowValue
    integer, optional, intent(in) :: start ! Optional start index
    logical, optional, intent(in) :: allowTopValue ! Can return N
    logical, optional, intent(in) :: allowBelowValue ! Can return 0
    logical, optional, intent(in) :: nearest ! Choose nearest value not one below
    logical, optional, intent(in) :: logSpace ! Choose nearest based on log space
    logical, optional, intent(out) :: Fail    ! True for failure

    include "HuntArray.f9h"
  end subroutine HuntArray_r4

! -------------------------------------------------  HuntArray_r8  -----

  subroutine HuntArray_r8 ( list, values, indices, start, allowTopValue, &
    & allowBelowValue, nearest, logSpace, fail )
    use ieee_arithmetic, only: IEEE_Is_NaN
    integer, parameter :: RK = kind(0.0d0)

    ! Dummy arguments
    real(rk), dimension(:), intent(in) :: list ! List to search
    real(rk), dimension(:), intent(in) :: values ! Values to search for
    integer, dimension(:), intent(out) :: indices ! list(indices) <= values
      !                                               <= list(indices+1)
    integer, optional, intent(in) :: start ! Optional start index
    logical, optional, intent(in) :: allowTopValue ! Can return N
    logical, optional, intent(in) :: allowBelowValue ! Can return 0
    logical, optional, intent(in) :: nearest ! Choose nearest value not one below
    logical, optional, intent(in) :: logSpace ! Choose nearest based on log space
    logical, optional, intent(out) :: Fail    ! True for failure

    include "HuntArray.f9h"
  end subroutine HuntArray_r8

! ------------------------------------------------  HuntScalar_r4  -----

  ! This routine is a scalar wrapper for the above one

  subroutine HuntScalar_r4 (list, value, index, start, allowTopValue, &
    & allowBelowValue, nearest, logSpace )
    integer, parameter :: RK = kind(0.0e0)

    ! Dummy arguments
    real(rk), dimension(:), intent(in) :: list ! List to search
    real(rk), intent(in) :: value ! Value to search for
    integer, intent(out) :: index ! list(index) <= value <= list(index+1)
    integer, intent(in), optional :: start ! Optional start index
    logical, optional, intent(in) :: allowTopValue ! Can return N
    logical, optional, intent(in) :: allowBelowValue ! Can return 0
    logical, optional, intent(in) :: nearest ! Choose nearest value instead
    logical, optional, intent(in) :: logSpace ! Choose nearest based on log space

    ! Local variables

    integer, dimension(1) :: indices ! To pass to HuntArray

    call Hunt ( list, (/ value /), indices, start, &
      & allowTopValue, allowBelowValue, nearest, logSpace )
    index = indices(1)
  end subroutine HuntScalar_r4

! ------------------------------------------------  HuntScalar_r8  -----

  subroutine HuntScalar_r8 (list, value, index, start, allowTopValue, &
    & allowBelowValue, nearest, logSpace )
    integer, parameter :: RK = kind(0.0d0)

    ! Dummy arguments
    real(rk), dimension(:), intent(in) :: list ! List to search
    real(rk), intent(in) :: value ! Value to search for
    integer, intent(out) :: index ! list(index) <= value <= list(index+1)
    integer, intent(in), optional :: start ! Optional start index
    logical, optional, intent(in) :: allowTopValue ! Can return N
    logical, optional, intent(in) :: allowBelowValue ! Can return 0
    logical, optional, intent(in) :: nearest ! Choose nearest value instead
    logical, optional, intent(in) :: logSpace ! Choose nearest based on log space

    ! Local variables

    integer, dimension(1) :: indices ! To pass to HuntArray

    call Hunt ( list, (/ value /), indices, start, &
      & allowTopValue, allowBelowValue, nearest, logSpace )
    index = indices(1)
  end subroutine HuntScalar_r8

  ! ----------------------------------------------------  HuntBox  -----
  ! A binary search routine with a hunt procedure, to start from last known
  ! location (if 0 < JLO < N) or from the begining otherwise.
  subroutine HuntBox_r4 ( GRIDPOINTS, MGRIDPOINTS, COORDS, INDICES, VERTICES )
    integer, parameter :: RK = kind(0.0e0)
    include 'HuntBox.f9h'
  end subroutine HuntBox_r4

  subroutine HuntBox_r8 ( GRIDPOINTS, MGRIDPOINTS, COORDS, INDICES, VERTICES )
    integer, parameter :: RK = kind(0.0d0)
    include 'HuntBox.f9h'
  end subroutine HuntBox_r8

! ----------------------------------------------------  HuntRange  -----
! This family of subroutines search not for a single index
! but for a range within which all list elements
! lie within a range of values, inclusive
! If none, return (/ 0, 0 /)
! Special interpretation: inclusive means
! if vrange(1) == vrange(2), any values of list also == vrange
! are within that range
! As with other Hunts, list must be monotonic
  subroutine HuntRange_int ( list, vrange, irange, options )
    integer, parameter :: RK = kind(0.0e0)
    ! Dummy args
    integer, dimension(:) :: list
    integer, dimension(2) :: vrange
    include 'HuntRange.f9h'
  end subroutine HuntRange_int

  subroutine HuntRange_r4 ( list, vrange, irange, options )
    integer, parameter :: RK = kind(0.0e0)
    ! Dummy args
    real(rk), dimension(:) :: list
    real(rk), dimension(2) :: vrange
    include 'HuntRange.f9h'
  end subroutine HuntRange_r4

  subroutine HuntRange_r8 ( list, vrange, irange, options )
    integer, parameter :: RK = kind(0.0d0)
    ! Dummy args
    real(rk), dimension(:) :: list
    real(rk), dimension(2) :: vrange
    include 'HuntRange.f9h'
  end subroutine HuntRange_r8

a1996 13
  ! ---------------------------------------------------  PureHunt  -----
  ! A binary search routine with a hunt procedure, to start from last known
  ! location (if 0 < JLO < N) or from the begining otherwise.
  pure subroutine purehunt_r4 ( ELEMENT, ARRAY, N, JLO, JHI )
    integer, parameter :: RK = kind(0.0e0)
    include 'hunt.f9h'
  end subroutine purehunt_r4

  pure subroutine purehunt_r8 ( ELEMENT, ARRAY, N, JLO, JHI )
    integer, parameter :: RK = kind(0.0d0)
    include 'hunt.f9h'
  end subroutine purehunt_r8

d2453 1
a2453 1
       "$Id: MLSNumerics.f90,v 2.85 2015/04/11 01:28:25 vsnyder Exp $"
d2465 3
@


2.85
log
@Add 'Second' argument to several routines
@
text
@d160 4
a163 1
  public :: InterpolateExtrapolate, InterpolateValues
d2631 1
a2631 1
       "$Id: MLSNumerics.f90,v 2.84 2015/04/07 02:47:30 vsnyder Exp $"
d2643 3
@


2.84
log
@Add InterpolateExtrapolate
@
text
@d1659 1
a1659 1
    & badValue, missingRegions, dyByDx, dNewByDOld, skipNewY, IntYdX )
d1664 1
a1664 1
    real(rk), dimension(:,:), intent(IN) :: oldY
d1666 1
a1666 1
    real(rk), dimension(:,:), intent(OUT) :: newY
d1677 3
d1690 1
a1690 1
    & badValue, missingRegions, dyByDx, dNewByDOld, skipNewY, IntYdX )
d1695 1
a1695 1
    real(rk), dimension(:,:), intent(IN) :: oldY
d1697 1
a1697 1
    real(rk), dimension(:,:), intent(OUT) :: newY
d1708 3
d1935 2
a1936 1
    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY, IntYdX )
d1942 1
a1942 1
    real(rk), dimension(:,:), intent(in) :: oldY
d1944 1
a1944 1
    real(rk), dimension(:,:), intent(out) :: newY
d1954 3
d1965 2
a1966 1
    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY, IntYdX )
d1972 1
a1972 1
    real(rk), dimension(:,:), intent(in) :: oldY
d1974 1
a1974 1
    real(rk), dimension(:,:), intent(out) :: newY
d1984 3
d1998 1
a1998 1
    ! XNew, YNew and ZNew must have the same shape.
d2018 1
a2018 1
    ! XNew, YNew and ZNew must have the same shape.
d2628 1
a2628 1
       "$Id: MLSNumerics.f90,v 2.83 2015/03/28 01:49:22 vsnyder Exp $"
d2640 3
@


2.83
log
@Moved Cross to Cross_m module
@
text
@d77 2
d154 12
a165 11
  public :: BATTLESHIP, BIVARIATELINEARINTERPOLATION
  public :: CLOSESTELEMENT
  public :: DESTROY, DFDXAPPROXIMATE, D2FDX2APPROXIMATE, DUMP
  public :: FAPPROXIMATE, FILLLOOKUPTABLE, FINDINRANGE, FINVAPPROXIMATE
  public :: HUNT, HUNTBOX, HUNTRANGE, IFAPPROXIMATE
  public :: INTERPOLATEARRAYSETUP, INTERPOLATEARRAYTEARDOWN, INTERPOLATEVALUES
  public :: Interpolate_Regular_To_Irregular, INTERPOLATE_2D_COMPOSITE
  public :: LINEARINTERPOLATE
  public :: PUREHUNT
  public :: SETUP, SIMPSONS, SIMPSONSSUB, SolveQuadratic
  public :: USELOOKUPTABLE
d420 4
d1782 38
d2614 1
a2614 1
       "$Id: MLSNumerics.f90,v 2.82 2014/01/09 00:24:29 pwagner Exp $"
d2626 3
@


2.82
log
@Some procedures formerly in output_m now got from highOutput
@
text
@a55 1
! Cross                    Cross product of two 3-vectors
d153 1
a153 1
  public :: CLOSESTELEMENT, CROSS
a354 4
  interface Cross
    module procedure Cross_r4, Cross_r8, Cross2_r4, Cross2_r8
  end interface

a970 36
! --------------------------------------------------------  Cross  -----

  ! Cross product of two three-vectors
  pure function Cross_r4 ( XYZ ) result ( Cross )
    real, intent(in) :: XYZ(3,2)
    real :: Cross(3)
    cross = (/ xyz(2,1)*xyz(3,2) - xyz(3,1)*xyz(2,2), &
               xyz(1,1)*xyz(3,2) - xyz(3,1)*xyz(1,2), &
               xyz(1,1)*xyz(2,2) - xyz(2,1)*xyz(1,2) /)
  end function Cross_r4

  pure function Cross_r8 ( XYZ ) result ( Cross )
    double precision, intent(in) :: XYZ(3,2)
    double precision :: Cross(3)
    cross = (/ xyz(2,1)*xyz(3,2) - xyz(3,1)*xyz(2,2), &
               xyz(1,1)*xyz(3,2) - xyz(3,1)*xyz(1,2), &
               xyz(1,1)*xyz(2,2) - xyz(2,1)*xyz(1,2) /)
  end function Cross_r8

  pure function Cross2_r4 ( A, B ) result ( Cross )
    real, intent(in) :: A(3), B(3)
    real :: Cross(3)
    cross = (/ a(2)*b(3) - a(3)*b(2), &
               a(1)*b(3) - a(3)*b(1), &
               a(1)*b(2) - a(2)*b(1) /)
  end function Cross2_r4


  pure function Cross2_r8 ( A, B ) result ( Cross )
    double precision, intent(in) :: A(3), B(3)
    double precision :: Cross(3)
    cross = (/ a(2)*b(3) - a(3)*b(2), &
               a(1)*b(3) - a(3)*b(1), &
               a(1)*b(2) - a(2)*b(1) /)
  end function Cross2_r8

d2569 1
a2569 1
       "$Id: MLSNumerics.f90,v 2.81 2013/08/13 00:58:43 vsnyder Exp $"
d2581 3
@


2.81
log
@Move SolveQuadratic into MLSNumerics
@
text
@d18 1
d27 1
a27 1
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE
d2610 1
a2610 1
       "$Id: MLSNumerics.f90,v 2.80 2013/08/12 23:47:25 pwagner Exp $"
d2622 3
@


2.80
log
@FindSomethings moved to MLSFinds module
@
text
@d161 1
a161 1
  public :: SETUP, SIMPSONS, SIMPSONSSUB
d470 2
a471 2
  interface simpsons
    module procedure simpsons_r4, simpsons_r8
d475 5
a479 1
    module procedure simps_r4, simps_r8
d487 2
a488 2
  real(r4), private, dimension(1) :: newYr4, newdYr4
  real(r8), private, dimension(1) :: newYr8, newdYr8
d739 1
a739 1
      enddo
d798 1
a798 1
    integer, parameter :: RK = r4
d803 1
a803 1
    integer, parameter :: RK = r8
d892 1
a892 1
    integer, parameter :: RK = R4
d931 1
a931 1
    integer, parameter :: RK = R8
d946 1
a946 1
    integer, parameter :: RK = R4
d961 1
a961 1
    integer, parameter :: RK = R8
d1040 1
a1040 1
    integer, parameter :: RK = R4
d1071 1
a1071 1
    integer, parameter :: RK = R8
d1111 1
a1111 1
    integer, parameter :: RK = R4
d1142 1
a1142 1
    integer, parameter :: RK = R8
d1263 1
a1263 1
    integer, parameter :: RK = R4
d1301 1
a1301 1
    integer, parameter :: RK = R8
d1351 1
a1351 1
    integer, parameter :: RK = R4
d1367 1
a1367 1
    integer, parameter :: RK = R8
d1396 1
a1396 1
    integer, parameter :: RK = R4
d1401 1
a1401 1
    integer, parameter :: RK = R8
d1421 1
a1421 1
    integer, parameter :: RK = R4
d1429 1
a1429 1
    integer, parameter :: RK = R4
d1437 1
a1437 1
    integer, parameter :: RK = R8
d1454 1
a1454 1
    integer, parameter :: RK = R4
d1478 1
a1478 1
    integer, parameter :: RK = R8
d1501 1
a1501 1
    integer, parameter :: RK = R4
d1526 1
a1526 1
    integer, parameter :: RK = R8
d1570 1
a1570 1
    integer, parameter :: RK = R4
d1578 1
a1578 1
    integer, parameter :: RK = R4
d1586 1
a1586 1
    integer, parameter :: RK = R8
d1603 1
a1603 1
    integer, parameter :: RK = R4
d1637 1
a1637 1
    integer, parameter :: RK = r8
d1693 1
a1693 1
    integer, parameter :: RK = R4
d1721 1
a1721 1
    integer, parameter :: RK = R8
d1750 1
a1750 1
    integer, parameter :: RK = R4
d1775 1
a1775 1
    integer, parameter :: RK = R8
d1821 1
a1821 1
    integer, parameter :: RK = R4
d1847 1
a1847 1
    integer, parameter :: RK = R8
d1873 1
a1873 1
    integer, parameter :: RK = R4
d1899 1
a1899 1
    integer, parameter :: RK = R8
d1925 1
a1925 1
    integer, parameter :: RK = R4
d1951 1
a1951 1
    integer, parameter :: RK = R8
d2020 1
a2020 1
    integer, parameter :: RK = kind(1.0d0)
d2036 1
a2036 1
    integer, parameter :: RK = kind(1.0e0)
d2101 1
a2101 1
    integer, parameter :: RK = R4
d2106 1
a2106 1
    integer, parameter :: RK = R8
d2111 1
a2111 1
    integer, parameter :: RK = R4
d2116 1
a2116 1
    integer, parameter :: RK = R8
d2121 1
a2121 1
    integer, parameter :: RK = R4
d2126 1
a2126 1
    integer, parameter :: RK = R8
d2131 1
a2131 1
    integer, parameter :: RK = R4
d2136 1
a2136 1
    integer, parameter :: RK = R8
d2158 1
a2158 1
    integer, parameter :: RK = R4
d2190 1
a2190 1
    integer, parameter :: RK = R8
d2224 1
a2224 1
    integer, parameter :: RK = r4
d2230 1
a2230 1
    integer, parameter :: RK = r8
d2234 33
d2308 1
a2308 1
    integer, parameter :: RK = R4
d2314 1
a2314 1
    integer, parameter :: RK = R8
d2368 1
a2368 1
  subroutine createXArray_r4( xArray, UDF )
d2380 1
a2380 1
  end subroutine createXArray_r4
d2383 1
a2383 1
  subroutine createXArray_r8( xArray, UDF )
d2395 1
a2395 1
  end subroutine createXArray_r8
d2400 1
a2400 1
  function psimpsons_r4 ( x, x1, x2, h, y ) result (sum)
d2430 1
a2430 1
  end function psimpsons_r4
d2433 1
a2433 1
  function psimpsons_r8 ( x, x1, x2, h, y ) result (sum)
d2463 1
a2463 1
  end function psimpsons_r8
d2468 1
a2468 1
  subroutine reposit_r4 ( x, UDF, p, itsSign )
d2508 1
a2508 1
  end subroutine reposit_r4
d2511 1
a2511 1
  subroutine reposit_r8( x, UDF, p, itsSign )
d2551 1
a2551 1
  end subroutine reposit_r8
d2556 1
a2556 1
  function simpsons_r4 ( n, h, y ) result (sum)
d2564 1
a2564 1
  end function simpsons_r4
d2567 1
a2567 1
  function simpsons_r8 ( n, h, y ) result (sum)
d2575 1
a2575 1
  end function simpsons_r8
d2609 1
a2609 1
       "$Id: MLSNumerics.f90,v 2.79 2013/05/31 23:30:37 vsnyder Exp $"
d2621 3
@


2.79
log
@Add two-argument cross product routines
@
text
@d24 1
a24 1
  use MLSSETS, only: FINDFIRST, FINDLAST
d38 2
a39 2
  ! This module contains some low level numerical stuff, hunting, interpolating
  ! etc.
d1009 1
a1009 1
  ! This family of routines sets up a uniDiscFunction of the appropriate type
d2234 2
d2572 1
a2572 1
       "$Id: MLSNumerics.f90,v 2.78 2013/05/31 02:37:11 vsnyder Exp $"
d2584 3
@


2.78
log
@Add cross product
@
text
@d356 1
a356 1
    module procedure Cross_r4, Cross_r8
d990 17
d2570 1
a2570 1
       "$Id: MLSNumerics.f90,v 2.77 2013/04/12 00:35:56 vsnyder Exp $"
d2582 3
@


2.77
log
@Describe 'index' argument of Hunt more precisely
@
text
@d55 1
d153 1
a153 1
  public :: CLOSESTELEMENT
d355 4
d971 20
a990 1
! -------------------------------------------------  Destroy  -----
d1009 1
a1009 1
! -------------------------------------------------  d2Fdx2Approximate  -----
d1080 1
a1080 1
! -------------------------------------------------  dFdxApproximate  -----
d1317 1
a1317 1
! -------------------------------------------------  FInvApproximate  -----
d1361 1
a1361 1
! -------------------------------------------------  FillLookUpTable  -----
d1384 1
a1384 1
! ------------------------------------------------  FindInRange  -----
d1526 1
a1526 1
  ! ---------------------------------------------------  HuntBox  -----
d1539 1
a1539 1
! ------------------------------------------------  HuntRange  -----
d1572 1
a1572 1
! -------------------------------------------------  IFApproximate  -----
d2070 1
a2070 1
! -------------------------------------------------  LinearInterpolate  -----
d2132 1
a2132 1
! -------------------------------------------------  SetUp  -----
d2199 1
a2199 1
! -------------------------------------------------  SimSubroutine  -----
d2213 1
a2213 1
! -------------------------------------------------  UseLookUpTable  -----
d2262 2
a2263 1
!-------------------- Private Procedures -----------------------------------
d2287 1
d2309 1
d2326 1
d2341 1
d2344 1
a2344 1
  function psimpsons_r4( x, x1, x2, h, y ) result (sum)
d2376 2
a2377 1
  function psimpsons_r8( x, x1, x2, h, y ) result (sum)
d2409 1
d2412 1
a2412 1
  subroutine reposit_r4( x, UDF, p, itsSign )
d2454 1
d2497 1
d2500 1
a2500 1
  function simpsons_r4( n, h, y ) result (sum)
d2510 2
a2511 1
  function simpsons_r8( n, h, y ) result (sum)
d2521 1
d2530 1
d2538 1
d2544 1
d2553 1
a2553 1
       "$Id: MLSNumerics.f90,v 2.76 2013/02/11 17:19:04 pwagner Exp $"
d2565 3
@


2.76
log
@Battleship returns status if cant find root
@
text
@d1401 4
a1404 4
  ! This routine does the classic hunt the value kind of thing.  This does the
  ! hunt/bisect implemention a la Numerical Recipes.  List must be
  ! monotonically increasing or decreasing. There is no such requirements for
  ! values.
d1416 2
d2515 1
a2515 1
       "$Id: MLSNumerics.f90,v 2.75 2012/12/20 01:06:15 vsnyder Exp $"
d2527 3
@


2.75
log
@Add Interpolate_Regular_To_Irregular
@
text
@d51 1
a51 1
! Battleship               By wise-ranging evaluations find integer root
d93 1
a93 1
!    [int b], [char* options] )
d95 1
a95 1
!    [log b], [char* options] )
d97 1
a97 1
!    [int maxPhase1], [int ns(:)] )
d485 2
a486 2
  ! This family of routines finds an integer root of a function
  ! by evaluating it. Each evaluation is a "shot". What we consider
d508 1
d535 2
d538 1
a538 1
  subroutine Battleship_int( fun, root, n1, maxPhase1, ns, b, options )
d547 1
d563 1
d609 1
d663 1
a663 1
  subroutine Battleship_log( fun, root, n1, maxPhase1, ns, b, options )
d672 1
d688 1
d734 1
d788 1
a788 1
  subroutine Battleship_r4( fun, root, arg1, delta, maxPhase1, ns )
d793 1
a793 1
  subroutine Battleship_r8( fun, root, arg1, delta, maxPhase1, ns )
d2513 1
a2513 1
       "$Id: MLSNumerics.f90,v 2.74 2012/06/12 18:10:00 pwagner Exp $"
d2525 3
@


2.74
log
@Battleship can now find non-integer roots
@
text
@d76 2
d128 4
d157 2
a158 1
  public :: INTERPOLATE_2D_COMPOSITE, LINEARINTERPOLATE
d416 5
d1957 32
d2504 1
a2504 1
       "$Id: MLSNumerics.f90,v 2.73 2012/05/25 20:53:21 pwagner Exp $"
d2516 3
@


2.73
log
@Added multidimensional LinearInterpolate and HuntBox
@
text
@d52 1
d94 2
d333 1
a333 1
    module procedure Battleship_int, Battleship_log
d474 7
a480 1
  ! by evaluating it. Each evaluation is a "shot". A returned value
d493 3
d519 4
d767 10
d2184 43
d2460 1
a2460 1
       "$Id: MLSNumerics.f90,v 2.72 2012/04/20 23:55:22 pwagner Exp $"
d2472 3
@


2.72
log
@Remove unused code, misleading comments
@
text
@d64 1
a64 1
! FindInRange                Finds indices of array elements for which values
d69 1
d79 1
d110 2
d127 2
d142 10
a151 10
  public :: Battleship, BivariateLinearInterpolation
  public :: ClosestElement
  public :: Destroy, dFdxApproximate, d2Fdx2Approximate, Dump
  public :: FApproximate, FillLookUpTable, FindInRange, FInvApproximate
  public :: Hunt, HuntRange, IFApproximate
  public :: InterpolateArraySetup, InterpolateArrayTeardown, InterpolateValues
  public :: Interpolate_2d_Composite
  public :: PureHunt
  public :: SetUp, Simpsons, SimpsonsSub
  public :: UseLookUpTable
d390 4
d422 7
d1453 13
d1965 49
d2391 1
a2391 1
       "$Id: MLSNumerics.f90,v 2.71 2011/11/18 02:42:35 vsnyder Exp $"
d2403 3
@


2.71
log
@Add Interpolate_2d_Composite
@
text
@d302 2
a303 2
    real(r4) :: yLeft  = 0.                        ! Assume all y < x1 are this
    real(r4) :: yRight= 0.                         ! Assume all y > x2 are this
d315 1
a315 1
    real(r8) :: yRight= 0.                         ! Assume all y > x2 are this
a2283 66
  function simpsons_r4_old( n, h, y ) result (sum)
    integer, parameter :: RK = R4
    ! Args
    integer, intent(in)                :: n
    real(rk), intent(in)               :: h
    real(rk), dimension(:), intent(in) :: y
    real(rk)                           :: sum
    ! Internal variables
    integer :: i
    integer :: n1
    ! Executable
    sum = 0.
    if ( n < 2 .or. size(y) < 2 ) return ! Sorry, too few points
    if ( n == 2 ) then
      ! Still too few for anything better than trapezoid
      sum = (h/2)*( y(1) + y(2) )
      return
    end if
    ! Do we have an even number of intervals, or odd?
    if ( mod(n-1, 2) == 1 ) then
      ! Odd--therefore start with Simpson's 3/8 rule
      ! (See Abramowitz and Stegun 25.4.13)
      sum = (3*h/8) * ( y(1) + 3*y(2) + 3*y(3) + y(4) )
      n1 = 4
    else
      ! Even--therefore stick with Simpson's
      n1 = 1
    end if
    do i=n1, n-2, 2
      sum = sum + (h/3)*( y(i) + 4*y(i+1) + y(i+2) )
    enddo
  end function simpsons_r4_old

  function simpsons_r8_old( n, h, y ) result (sum)
    integer, parameter :: RK = R8
    ! Args
    integer, intent(in)                :: n
    real(rk), intent(in)               :: h
    real(rk), dimension(:), intent(in) :: y
    real(rk)                           :: sum
    ! Internal variables
    integer :: i
    integer :: n1
    ! Executable
    sum = 0.
    if ( n < 2 .or. size(y) < 2 ) return ! Sorry, too few points
    if ( n == 2 ) then
      ! Still too few for anything better than trapezoid
      sum = (h/2)*( y(1) + y(2) )
      return
    end if
    ! Do we have an even number of intervals, or odd?
    if ( mod(n-1, 2) == 1 ) then
      ! Odd--therefore start with Simpson's 3/8 rule
      ! (See Abramowitz and Stegun 25.4.13)
      sum = (3*h/8) * ( y(1) + 3*y(2) + 3*y(3) + y(4) )
      n1 = 4
    else
      ! Even--therefore stick with Simpson's
      n1 = 1
    end if
    do i=n1, n-2, 2
      sum = sum + (h/3)*( y(i) + 4*y(i+1) + y(i+2) )
    enddo
  end function simpsons_r8_old

d2312 1
a2312 1
       "$Id: MLSNumerics.f90,v 2.70 2011/08/26 17:52:49 pwagner Exp $"
d2324 3
@


2.70
log
@purehunt recovers optimized functionality of fwdmdls own hunt
@
text
@d76 2
d142 1
d408 4
d1631 1
a1631 1
    character(len=*), intent(in), optional :: Extrapolate
d1656 1
a1656 1
    character(len=*), intent(in), optional :: Extrapolate
d1850 1
a1850 1
  subroutine Interp_Bilinear_2d_1d_r4 ( XOld, Xnew, YOld, YNew, Zold, Znew, &
d1870 1
a1870 1
  subroutine Interp_Bilinear_2d_1d_r8 ( XOld, Xnew, YOld, YNew, Zold, Znew, &
d1889 49
a1937 3
! -------------------------------------------------  PureHunt  -----
! A binary search routine with a hunt procedure, to start from last known
! location (if 0 < JLO < N) or from the begining otherwise.
d2378 1
a2378 1
       "$Id: MLSNumerics.f90,v 2.69 2011/08/26 00:23:56 pwagner Exp $"
d2390 3
@


2.69
log
@Moved Simpson and CSpline functionality here from fwdmdl
@
text
@d76 1
d121 1
d140 1
d413 4
d1882 13
d2325 1
a2325 1
       "$Id: MLSNumerics.f90,v 2.68 2011/08/20 00:47:14 vsnyder Exp $"
d2337 3
@


2.68
log
@use IEEE_Arithmetic to get IEEE_Is_NaN
@
text
@d16 1
a16 1
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
d18 10
a27 10
  use MatrixModule_0, only: CreateBlock, M_Absent, MatrixElement_T, Sparsify
  use MLSCommon, only : UndefinedValue
  use MLSFillValues, only: IsFillValue, ReplaceFillValues, Rerank
  use MLSKinds, only: R4, R8, Rm
  use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, &
    & MLSMessage
  use MLSSets, only: FindFirst, FindLast
  use MLSStrings, only: Capitalize, Trim_safe
  use Output_m, only: Blanks, Output, OutputNamedValue
  use Symm_Tri, only: Factor_Symm_Tri, Solve_Factored_Symm_Tri
d77 2
a78 1
! Simpsons                 Apply Simpson's rule to calculate -- ooh, donuts
d123 1
d138 1
a138 1
  public :: SetUp, Simpsons
d336 4
d402 4
d423 4
d1537 1
a1537 1
  ! Method is one of 'L'inear, or 'S'pline
d1541 6
d1682 1
a1682 1
    & badValue, missingRegions, dyByDx, RangeOfPeriod, skipNewY, IntYdX )
d1700 1
d1708 1
a1708 1
    & badValue, missingRegions, dyByDx, RangeOfPeriod, skipNewY, IntYdX )
d1726 1
d1942 14
d2198 20
d2242 1
a2242 1
  end function simpsons_r4
d2244 1
a2244 1
  function simpsons_r8( n, h, y ) result (sum)
d2275 26
a2300 1
  end function simpsons_r8
d2305 1
a2305 1
       "$Id: MLSNumerics.f90,v 2.67 2011/08/17 00:48:57 pwagner Exp $"
d2317 3
@


2.67
log
@Fixed bug in Simpsons; made it public
@
text
@d1316 1
d1338 1
d1376 1
a1376 1
    integer, dimension(1) :: indices ! To pass to HuntScalar
d1379 1
a1379 1
      & allowTopValue, allowBelowValue, nearest )
d1401 1
a1401 1
    integer, dimension(1) :: indices ! To pass to HuntScalar
d1404 1
a1404 1
      & allowTopValue, allowBelowValue, nearest )
d2224 1
a2224 1
       "$Id: MLSNumerics.f90,v 2.66 2011/03/22 23:37:56 pwagner Exp $"
d2236 3
@


2.66
log
@Rerank now taken from MLSFillValues module
@
text
@d77 1
d121 1
d136 1
a136 1
  public :: SetUp
d2166 1
a2166 1
    if ( n == 3 ) then
d2199 1
a2199 1
    if ( n == 3 ) then
d2222 1
a2222 1
       "$Id: MLSNumerics.f90,v 2.65 2010/06/07 23:31:49 vsnyder Exp $"
d2234 3
@


2.65
log
@Add BivariateLinearInterpolation
@
text
@d20 1
a20 1
  use MLSFillValues, only: IsFillValue, ReplaceFillValues
a2148 58
  subroutine rerank( address, shp, indices )
    ! Find multidimensional set of indices in an array
    ! with shape shp corresponding to 1-d address
    !
    ! We shall assume that the first index is the fastest, then the 2nd, ..
    ! Our method is the following:
    ! Let the size of the kth index be s[k]
    ! Then we seek the array i[k] such that
    ! address = i[1] + s[1] ( i[2] + s[2] ( i[3] + .. + i[N] ) .. )
    ! (Where we assume 0-based indexing, like c, 
    !   rather than 1-based, as Fortran uses)
    ! We can build this by parts as follows
    ! a[N]   = i[N]
    ! a[N-1] = i[N-1] + s[N-1] i[N]
    ! a[N-2] = i[N-2] + s[N-2] ( i[N-1] + s[N-1] i[N] )
    ! .   .   .
    ! a[1] = address
    ! Where N is the rank of the array
    ! Note then that the recurrences hold
    ! a[N-1] - a[N] s[N-1]   = i[N-1]
    ! a[N-2] - a[N-1] s[N-2] = i[N-2]
    ! .   .   .
    ! a[1] - a[2] s[1]       = i[1]
    !
    ! From this last we realize that
    ! i[1] = a[1] mod(s[1])
    ! Solve it for i[1], then a[2] = ( a[1] - i[1] ) / s[1]
    ! Then for succeeding values of k
    ! i[k] = a[k] mod(s[k])
    
    ! Remember to modify each of these if we wish to use
    ! Fortran-style indexes which start at 1, not 0, as follows
    !
    ! i'[k] = i[k] + 1, k > 1
    ! i'[1] = i[1]
    ! address = i'[1] + s[1] ( i'[2] - 1 + s[2] ( i[3] - 1 + .. + i[N] ) .. )
    integer, intent(in)                :: address
    integer, dimension(:), intent(in)  :: shp
    integer, dimension(:), intent(out) :: indices
    ! Local variables
    integer :: aofk
    integer :: k
    integer :: N
    integer, parameter :: OFFSET = 1 ! at what index do arrays start?
    !
    N = size(shp)
    if ( N < 2 ) then
      indices(1) = address
      return
    end if
    aofk = address - OFFSET
    do k=1, N
      indices(k) = MOD(aofk, shp(k))
      aofk = ( aofk - indices(k) ) / shp(k)
    enddo
    indices = indices + OFFSET ! Converting to Fortran-style, beginning with 1
  end subroutine rerank
  
d2220 1
a2220 1
       "$Id: MLSNumerics.f90,v 2.64 2009/12/08 21:43:14 vsnyder Exp $"
d2232 3
@


2.64
log
@Get Symm_Tri
@
text
@d86 2
d128 1
a128 1
  public :: Battleship
d317 5
d704 70
a773 1
! -------------------------------------------------  ClosestElement  -----
d2278 1
a2278 1
       "$Id: MLSNumerics.f90,v 2.63 2009/11/17 23:34:38 vsnyder Exp $"
d2290 3
@


2.63
log
@Alphabetize public procedure names, add components for periodic continuity
to Coefficients_R* types, add Name argument to DumpCoefficients_r*
@
text
@d19 1
a19 1
  use MLSCommon, only : undefinedValue
d25 3
a27 2
  use MLSStrings, only: Capitalize, trim_safe
  use OUTPUT_M, only: blanks, output, outputNamedValue
d2202 1
a2202 1
       "$Id: MLSNumerics.f90,v 2.62 2009/06/20 02:32:58 vsnyder Exp $"
d2214 4
@


2.62
log
@Precompute more stuff, handle identical abscissae, in spline case
@
text
@d19 3
a21 2
  use MLSCommon, only : undefinedValue, R4, R8, Rm
  use MLSFillValues, only: filterValues, IsFillValue, ReplaceFillValues
d116 1
a116 1
!    [char* BC], [nprec yLeft], [nprec yRight], [extern nprec fun] ) )
d127 3
a129 3
  public :: dFdxApproximate, d2Fdx2Approximate
  public :: FApproximate, FInvApproximate, IFApproximate
  public :: Destroy, Dump, FindInRange, Hunt, HuntRange
a130 1
  public :: FillLookUpTable, UseLookUpTable
d132 1
a132 1
  public :: UnifDiscreteFn_r4, UnifDiscreteFn_r8
a135 1
    integer, pointer :: LowerInds(:) => NULL()
d141 4
a144 1
    !  {\tt size(newX)}.  $|\{g\}| = |\{A\}| = |\{B\}|$, and
d149 1
d155 1
a155 1
    !  $\Delta_i = x_{i+1}-x_{i-1}$ for $1 < i <$
d160 6
d167 6
a194 1
    integer, pointer :: LowerInds(:) => NULL()
d200 4
a203 1
    !  {\tt size(newX)}.  $|\{g\}| = |\{A\}| = |\{B\}|$, and
d208 1
d214 1
a214 1
    !  $\Delta_i = x_{i+1}-x_{i-1}$ for $1 < i <$
d219 6
d226 6
d283 1
a283 1
  type UnifDiscreteFn_r4
d295 1
a295 1
  type UnifDiscreteFn_r8
d496 1
a496 1
        endif
d516 1
a516 1
        endif
d519 1
a519 1
    endif
d537 2
a538 2
          endif
        endif
d540 1
a540 1
      endif
d548 1
a548 1
        endif
d556 1
a556 1
        endif
d563 1
a563 1
          endif
d569 2
a570 2
        endif
      endif
d618 1
a618 1
        endif
d638 1
a638 1
        endif
d641 1
a641 1
    endif
d659 2
a660 2
          endif
        endif
d662 1
a662 1
      endif
d670 1
a670 1
        endif
d678 1
a678 1
        endif
d685 1
a685 1
          endif
d691 2
a692 2
        endif
      endif
d850 1
a850 1
    endif
d881 1
a881 1
    endif
d921 1
a921 1
    endif
d952 1
a952 1
    endif
d957 1
a957 1
  subroutine DumpCoefficients_r4 ( Coeffs )
d959 1
d961 1
d965 1
a965 1
  subroutine DumpCoefficients_r8 ( Coeffs )
d967 1
d969 1
d996 1
a996 1
    endif
d1001 1
a1001 1
    endif
d1028 1
a1028 1
    endif
d1033 1
a1033 1
    endif
d1080 1
a1080 1
    endif
d1118 1
a1118 1
    endif
d1400 1
a1400 1
    endif
d1434 1
a1434 1
    endif
d1444 1
a1444 1
  ! Extrapolate is one of 'A'llow, 'C'onstant or 'B'ad
d2014 1
a2014 1
      endif
d2056 1
a2056 1
      endif
d2121 1
a2121 1
    endif
d2149 1
a2149 1
    endif
d2159 1
a2159 1
    endif
d2182 1
a2182 1
    endif
d2192 1
a2192 1
    endif
d2201 1
a2201 1
       "$Id: MLSNumerics.f90,v 2.61 2009/06/13 02:27:39 vsnyder Exp $"
d2213 3
@


2.61
log
@Several coefficients_R8 should have been coefficients_R4
@
text
@d136 8
a143 4
    integer, pointer :: LowerInds(:) => NULL(), UpperInds(:) => NULL()
    !{ Coefficients for linear interpolation:
    !  {\tt Gap} $= g = x_{i+1}-x_i$.  $A = \frac{x_{i+1}-x}g$.
    !                                  $B = 1-A = \frac{x-x_i}g$.
d151 7
a157 1
    real(r4), pointer :: Sig(:) => NULL() ! for second derivative guesser
d180 8
a187 4
    integer, pointer :: LowerInds(:) => NULL(), UpperInds(:) => NULL()
    !{ Coefficients for linear interpolation:
    !  {\tt Gap} $= g = x_{i+1}-x_i$.  $A = \frac{x_{i+1}-x}g$.
    !                                  $B = 1-A = \frac{x-x_i}g$.
d195 7
a201 1
    real(r8), pointer :: Sig(:) => NULL() ! for second derivative guesser
d2167 1
a2167 1
       "$Id: MLSNumerics.f90,v 2.60 2008/09/03 20:43:48 pwagner Exp $"
d2171 1
d2179 3
@


2.60
log
@Added FindInRange
@
text
@d242 1
a242 1
    ! type(Coefficients_R8) :: Coeffs                ! in case we'll use splines
d1418 1
a1418 1
    type(coefficients_r8) :: Coeffs
d1461 1
a1461 1
    type(coefficients_R8), intent(out) :: Coeffs
d1581 1
a1581 1
    type(coefficients_r8), intent(in) :: Coeffs
d1633 1
a1633 1
    type(coefficients_r8), intent(in) :: Coeffs
d2147 1
a2147 1
       "$Id: MLSNumerics.f90,v 2.59 2008/06/06 22:52:21 pwagner Exp $"
d2158 3
@


2.59
log
@EssentiallyEqual moved to MLSFillValues
@
text
@d62 3
d95 1
d128 1
a128 1
  public :: Destroy, Dump, Hunt, HuntRange
d303 4
d1135 39
d2147 1
a2147 1
       "$Id: MLSNumerics.f90,v 2.58 2008/05/02 00:41:42 vsnyder Exp $"
d2158 3
@


2.58
log
@Delete unused symbol
@
text
@a56 3
! EssentiallyEqual         Returns true if two real arguments 'close enough'
!                            (See comments below for interpretation
!                             of array versions)
a86 2
! log EssentiallyEqual ( nprec A, nprec B, &
!   [nprec FillValue], [nprec Precision] )
d124 1
a124 1
  public :: Destroy, Dump, EssentiallyEqual, Hunt, HuntRange
a298 7
  interface EssentiallyEqual
    module procedure EssentiallyEqual_r4, EssentiallyEqual_r8
    module procedure EssentiallyEqual_r4_1d, EssentiallyEqual_r8_1d
    module procedure EssentiallyEqual_r4_2d, EssentiallyEqual_r8_2d
    module procedure EssentiallyEqual_r4_3d, EssentiallyEqual_r8_3d
  end interface

a974 167
! ---------------------------------------------  EssentiallyEqual  -----

  ! This family of routines checks to see if two reals are essentially
  ! the same.
  elemental logical function EssentiallyEqual_r4 ( A, B )
    real(r4), intent(in) :: A
    real(r4) ,intent(in) :: B
    EssentiallyEqual_r4 = &
      & a >= nearest ( b, -1.0_r4 ) .and. a <= nearest ( b, 1.0_r4 )
  end function EssentiallyEqual_r4

  elemental logical function EssentiallyEqual_r8 ( A, B )
    real(r8), intent(in) :: A
    real(r8) ,intent(in) :: B
    EssentiallyEqual_r8 = &
      & a >= nearest ( b, -1.0_r8 ) .and. a <= nearest ( b, 1.0_r8 )
  end function EssentiallyEqual_r8

  function EssentiallyEqual_r4_1d ( A, B, FillValue, Precision ) &
    & result(equal)
  ! This function is slightly different:
  ! A scalar logical testing that every element of two arrays are equal
  ! You may filter out values in either array equal to the FillValue
  ! or for which the corresponding Precision array is negative
  ! or where either element is not finite
  ! Warn if an element of one array is finite while the other is not
    real(r4), dimension(:), intent(in)             :: A
    real(r4), dimension(:), intent(in)             :: B
    real(r4), intent(in)                           :: fillValue
    real(r4), dimension(:), optional, intent(in)   :: precision
    logical                                        :: equal
    real(r4), dimension(size(A))                   :: atab
    real(r4), dimension(size(B))                   :: btab
    logical                                        :: warn
    equal = .false.
    call filterValues(A, ATAB, B, BTAB, warn, fillValue, precision)
    if ( .not. warn ) equal = all( &
      & a >= nearest ( b, -1.0_r4 ) .and. a <= nearest ( b, 1.0_r4 ) &
      & )
  end function EssentiallyEqual_r4_1d

  function EssentiallyEqual_r8_1d ( A, B, FillValue, Precision ) &
    & result(equal)
  ! This function is slightly different:
  ! A scalar logical testing that every element of two arrays are equal
  ! You may filter out values in either array equal to the FillValue
  ! or for which the corresponding Precision array is negative
  ! or where either element is not finite
    real(r8), dimension(:), intent(in)             :: A
    real(r8), dimension(:), intent(in)             :: B
    real(r8), intent(in)                           :: fillValue
    real(r8), dimension(:), optional, intent(in)   :: precision
    logical                                        :: equal
    real(r8), dimension(size(A))                   :: atab
    real(r8), dimension(size(B))                   :: btab
    logical                                        :: warn
    equal = .false.
    call filterValues(A, ATAB, B, BTAB, warn, fillValue, precision)
    if ( .not. warn ) equal = all( &
      & a >= nearest ( b, -1.0_r8 ) .and. a <= nearest ( b, 1.0_r8 ) &
      & )
  end function EssentiallyEqual_r8_1d

  function EssentiallyEqual_r4_2d ( A, B, FillValue, Precision ) &
    & result(equal)
  ! This function is slightly different:
  ! A scalar logical testing that every element of two arrays are equal
  ! You may filter out values in either array equal to the FillValue
  ! or for which the corresponding Precision array is negative
  ! or where either element is not finite
    real(r4), dimension(:,:), intent(in)             :: A
    real(r4), dimension(:,:), intent(in)             :: B
    real(r4), intent(in)                             :: fillValue
    real(r4), dimension(:,:), optional, intent(in)   :: precision
    logical                                        :: equal
    ! Internal variables
    integer, dimension(2)                          :: shp
    shp =shape(a)
    if ( present(Precision) ) then
      equal = EssentiallyEqual_r4_1d(reshape(a, (/shp(1)*shp(2)/)), &
        & reshape(b, (/shp(1)*shp(2)/)), &
        & FillValue, reshape(Precision, (/shp(1)*shp(2)/)) )
    else
      equal = EssentiallyEqual_r4_1d(reshape(a, (/shp(1)*shp(2)/)), &
        & reshape(b, (/shp(1)*shp(2)/)), FillValue )
    endif
      
  end function EssentiallyEqual_r4_2d

  function EssentiallyEqual_r8_2d ( A, B, FillValue, Precision ) &
    & result(equal)
  ! This function is slightly different:
  ! A scalar logical testing that every element of two arrays are equal
  ! You may filter out values in either array equal to the FillValue
  ! or for which the corresponding Precision array is negative
  ! or where either element is not finite
    real(r8), dimension(:,:), intent(in)             :: A
    real(r8), dimension(:,:), intent(in)             :: B
    real(r8), intent(in)                             :: fillValue
    real(r8), dimension(:,:), optional, intent(in)   :: precision
    logical                                        :: equal
    ! Internal variables
    integer, dimension(2)                          :: shp
    shp =shape(a)
    if ( present(Precision) ) then
      equal = EssentiallyEqual_r8_1d(reshape(a, (/shp(1)*shp(2)/)), &
        & reshape(b, (/shp(1)*shp(2)/)), &
        & FillValue, reshape(Precision, (/shp(1)*shp(2)/)) )
    else
      equal = EssentiallyEqual_r8_1d(reshape(a, (/shp(1)*shp(2)/)), &
        & reshape(b, (/shp(1)*shp(2)/)), FillValue )
    endif
      
  end function EssentiallyEqual_r8_2d

  function EssentiallyEqual_r4_3d ( A, B, FillValue, Precision ) &
    & result(equal)
  ! This function is slightly different:
  ! A scalar logical testing that every element of two arrays are equal
  ! You may filter out values in either array equal to the FillValue
  ! or for which the corresponding Precision array is negative
  ! or where either element is not finite
    real(r4), dimension(:,:,:), intent(in)             :: A
    real(r4), dimension(:,:,:), intent(in)             :: B
    real(r4), intent(in)                               :: fillValue
    real(r4), dimension(:,:,:), optional, intent(in)   :: precision
    logical                                        :: equal
    ! Internal variables
    integer, dimension(3)                          :: shp
    shp =shape(a)
    if ( present(Precision) ) then
      equal = EssentiallyEqual_r4_1d(reshape(a, (/shp(1)*shp(2)*shp(3)/)), &
        & reshape(b, (/shp(1)*shp(2)*shp(3)/)), &
        & FillValue, reshape(Precision, (/shp(1)*shp(2)*shp(3)/)) )
    else
      equal = EssentiallyEqual_r4_1d(reshape(a, (/shp(1)*shp(2)*shp(3)/)), &
        & reshape(b, (/shp(1)*shp(2)*shp(3)/)), FillValue )
    endif
      
  end function EssentiallyEqual_r4_3d

  function EssentiallyEqual_r8_3d ( A, B, FillValue, Precision ) &
    & result(equal)
  ! This function is slightly different:
  ! A scalar logical testing that every element of two arrays are equal
  ! You may filter out values in either array equal to the FillValue
  ! or for which the corresponding Precision array is negative
  ! or where either element is not finite
    real(r8), dimension(:,:,:), intent(in)             :: A
    real(r8), dimension(:,:,:), intent(in)             :: B
    real(r8), intent(in)                               :: fillValue
    real(r8), dimension(:,:,:), optional, intent(in)   :: precision
    logical                                        :: equal
    ! Internal variables
    integer, dimension(3)                          :: shp
    shp =shape(a)
    if ( present(Precision) ) then
      equal = EssentiallyEqual_r8_1d(reshape(a, (/shp(1)*shp(2)*shp(3)/)), &
        & reshape(b, (/shp(1)*shp(2)*shp(3)/)), &
        & FillValue, reshape(Precision, (/shp(1)*shp(2)*shp(3)/)) )
    else
      equal = EssentiallyEqual_r8_1d(reshape(a, (/shp(1)*shp(2)*shp(3)/)), &
        & reshape(b, (/shp(1)*shp(2)*shp(3)/)), FillValue )
    endif
      
  end function EssentiallyEqual_r8_3d

d2100 1
a2100 1
       "$Id: MLSNumerics.f90,v 2.57 2008/01/07 21:36:33 pwagner Exp $"
d2111 3
@


2.57
log
@Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
@
text
@d22 1
a22 1
    & MLSMessage, MLSMessageCalls
d2279 1
a2279 1
       "$Id: MLSNumerics.f90,v 2.56 2007/08/20 22:03:31 pwagner Exp $"
d2290 3
@


2.56
log
@Fixed another bug in HuntRange
@
text
@d19 1
a19 1
  use MLSCommon, only : DEFAULTUNDEFINEDVALUE, R4, R8, Rm
d2279 1
a2279 1
       "$Id: MLSNumerics.f90,v 2.55 2007/08/13 17:28:46 pwagner Exp $"
d2290 3
@


2.55
log
@Fixed obvious bugs in HuntRange
@
text
@d20 1
a20 1
  use MLSFillValues, only: filterValues, IsFillValue
d2279 1
a2279 1
       "$Id: MLSNumerics.f90,v 2.54 2007/08/07 23:55:02 pwagner Exp $"
d2290 3
@


2.54
log
@Added new data type, functions for approximating
@
text
@d21 2
a22 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d100 1
a100 1
! HuntRange ( num list(:), num vrange(2), int irange(2) )
d1414 1
a1414 1
  subroutine HuntRange_int ( list, vrange, irange )
d1422 1
a1422 1
  subroutine HuntRange_r4 ( list, vrange, irange )
d1430 1
a1430 1
  subroutine HuntRange_r8 ( list, vrange, irange )
d2279 1
a2279 1
       "$Id: MLSNumerics.f90,v 2.53 2007/07/31 22:48:27 pwagner Exp $"
d2290 3
@


2.53
log
@UseLookUpTable can now differentiate, integrate
@
text
@d19 1
a19 1
  use MLSCommon, only : R4, R8, Rm
d23 2
a24 1
  use MLSStrings, only: Capitalize
d44 2
d48 1
d51 5
a55 1
! Dump                     Dump coefficients structure
d59 5
d68 1
d73 1
a73 4
! Battleship               By wise-ranging evaluations find integer root
! FillLookUpTable          Fill table with evaluations at regularly-spaced args
!                            to be used in place of later, frequent evaluations;
!                            reversing role of (table, xtable) => function^(-1)
d84 3
d88 1
d91 3
d100 2
d114 5
a118 2
! nprec UseLookUpTable_r4 ( nprec x, nprec table(:), [nprec x1], [nprec x2], &
!    [nprec xtable(:), [nprec missingValue], [char* options] )
d126 4
a129 2
  public :: Dump, EssentiallyEqual, Hunt, HuntRange, InterpolateArraySetup
  public :: InterpolateArrayTeardown, InterpolateValues
d131 2
d202 58
d264 22
d288 13
d319 4
d339 11
a349 4
  interface ClosestElement
    module procedure ClosestElement_r4_1d, ClosestElement_r8_1d
    module procedure ClosestElement_r4_2d, ClosestElement_r8_2d
    module procedure ClosestElement_r4_3d, ClosestElement_r8_3d
d352 2
a353 2
  interface FillLookUpTable
    module procedure FillLookUpTable_r4, FillLookUpTable_r8
d360 4
d366 1
a366 6
! ---------------------------------------------------------  Dump  -----
  subroutine DumpCoefficients_r4 ( Coeffs )
    use Dump_0, only: Dump
    type(coefficients_r4), intent(in) :: Coeffs
    include 'DumpCoefficients.f9h'
  end subroutine DumpCoefficients_r4
d368 6
a373 5
  subroutine DumpCoefficients_r8 ( Coeffs )
    use Dump_0, only: Dump
    type(coefficients_r8), intent(in) :: Coeffs
    include 'DumpCoefficients.f9h'
  end subroutine DumpCoefficients_r8
d375 22
a396 1
! ---------------------------------------------  EssentiallyEqual  -----
d398 6
a403 8
  ! This family of routines checks to see if two reals are essentially
  ! the same.
  elemental logical function EssentiallyEqual_r4 ( A, B )
    real(r4), intent(in) :: A
    real(r4) ,intent(in) :: B
    EssentiallyEqual_r4 = &
      & a >= nearest ( b, -1.0_r4 ) .and. a <= nearest ( b, 1.0_r4 )
  end function EssentiallyEqual_r4
d405 9
a413 64
  elemental logical function EssentiallyEqual_r8 ( A, B )
    real(r8), intent(in) :: A
    real(r8) ,intent(in) :: B
    EssentiallyEqual_r8 = &
      & a >= nearest ( b, -1.0_r8 ) .and. a <= nearest ( b, 1.0_r8 )
  end function EssentiallyEqual_r8

  function EssentiallyEqual_r4_1d ( A, B, FillValue, Precision ) &
    & result(equal)
  ! This function is slightly different:
  ! A scalar logical testing that every element of two arrays are equal
  ! You may filter out values in either array equal to the FillValue
  ! or for which the corresponding Precision array is negative
  ! or where either element is not finite
  ! Warn if an element of one array is finite while the other is not
    real(r4), dimension(:), intent(in)             :: A
    real(r4), dimension(:), intent(in)             :: B
    real(r4), intent(in)                           :: fillValue
    real(r4), dimension(:), optional, intent(in)   :: precision
    logical                                        :: equal
    real(r4), dimension(size(A))                   :: atab
    real(r4), dimension(size(B))                   :: btab
    logical                                        :: warn
    equal = .false.
    call filterValues(A, ATAB, B, BTAB, warn, fillValue, precision)
    if ( .not. warn ) equal = all( &
      & a >= nearest ( b, -1.0_r4 ) .and. a <= nearest ( b, 1.0_r4 ) &
      & )
  end function EssentiallyEqual_r4_1d

  function EssentiallyEqual_r8_1d ( A, B, FillValue, Precision ) &
    & result(equal)
  ! This function is slightly different:
  ! A scalar logical testing that every element of two arrays are equal
  ! You may filter out values in either array equal to the FillValue
  ! or for which the corresponding Precision array is negative
  ! or where either element is not finite
    real(r8), dimension(:), intent(in)             :: A
    real(r8), dimension(:), intent(in)             :: B
    real(r8), intent(in)                           :: fillValue
    real(r8), dimension(:), optional, intent(in)   :: precision
    logical                                        :: equal
    real(r8), dimension(size(A))                   :: atab
    real(r8), dimension(size(B))                   :: btab
    logical                                        :: warn
    equal = .false.
    call filterValues(A, ATAB, B, BTAB, warn, fillValue, precision)
    if ( .not. warn ) equal = all( &
      & a >= nearest ( b, -1.0_r8 ) .and. a <= nearest ( b, 1.0_r8 ) &
      & )
  end function EssentiallyEqual_r8_1d

  function EssentiallyEqual_r4_2d ( A, B, FillValue, Precision ) &
    & result(equal)
  ! This function is slightly different:
  ! A scalar logical testing that every element of two arrays are equal
  ! You may filter out values in either array equal to the FillValue
  ! or for which the corresponding Precision array is negative
  ! or where either element is not finite
    real(r4), dimension(:,:), intent(in)             :: A
    real(r4), dimension(:,:), intent(in)             :: B
    real(r4), intent(in)                             :: fillValue
    real(r4), dimension(:,:), optional, intent(in)   :: precision
    logical                                        :: equal
d415 37
a451 6
    integer, dimension(2)                          :: shp
    shp =shape(a)
    if ( present(Precision) ) then
      equal = EssentiallyEqual_r4_1d(reshape(a, (/shp(1)*shp(2)/)), &
        & reshape(b, (/shp(1)*shp(2)/)), &
        & FillValue, reshape(Precision, (/shp(1)*shp(2)/)) )
d453 618
a1070 2
      equal = EssentiallyEqual_r4_1d(reshape(a, (/shp(1)*shp(2)/)), &
        & reshape(b, (/shp(1)*shp(2)/)), FillValue )
d1134 72
a1205 5
    real(r8), dimension(:,:,:), intent(in)             :: A
    real(r8), dimension(:,:,:), intent(in)             :: B
    real(r8), intent(in)                               :: fillValue
    real(r8), dimension(:,:,:), optional, intent(in)   :: precision
    logical                                        :: equal
d1207 24
a1230 6
    integer, dimension(3)                          :: shp
    shp =shape(a)
    if ( present(Precision) ) then
      equal = EssentiallyEqual_r8_1d(reshape(a, (/shp(1)*shp(2)*shp(3)/)), &
        & reshape(b, (/shp(1)*shp(2)*shp(3)/)), &
        & FillValue, reshape(Precision, (/shp(1)*shp(2)*shp(3)/)) )
d1232 2
a1233 2
      equal = EssentiallyEqual_r8_1d(reshape(a, (/shp(1)*shp(2)*shp(3)/)), &
        & reshape(b, (/shp(1)*shp(2)*shp(3)/)), FillValue )
d1235 69
a1303 2
      
  end function EssentiallyEqual_r8_3d
d1437 77
d1847 1
a1847 286
  end subroutine Interp_Bilinear_2d_1d_r8

! -------------------------------------------------  Battleship  -----

  ! This family of routines finds an integer root of a function
  ! by evaluating it. Each evaluation is a "shot". A returned value
  ! of "0" (or the optional parameter b) is short. Any other value is long.
  ! The root is the longest argument that is still short.
  ! (If you instead wish the shortest argument still long just add 1
  ! or utilize the options string)

  ! Example: a direct-access read of n chars from a file where the iostatus
  ! is 0 if we don't try to read too many chars, but non-zero if we do
  ! Create your own function that takes the number of chars to be read
  ! as its sole argument and that returns the iostat as its value
  ! Battleship will then calculate the exact number characters in the file
  ! (which NAG cares about; Lahey doesn't care)
  
  ! We take shots during 2 phases:
  ! (1) outbound: ever-widening circles of radius 1 2 4 8 .. (n) (2n) ..
  !     or else prescribed shots in array ns[:]
  ! (2) inbound: once root is crossed, ever narowing circles around it
  !     (until "You sank my battleship!")
  
  ! The options string (if supplied) modifies how this search operates
  !  options            search goal
  !  -------            -----------
  !    -s (default)     largest root for which fun(root) = 0 (or b)
  !                      (useful for io status)
  !    -r               reverse of "-s"
  !                       i.e., all tests return non-zero below root
  !    -x               root where f(root) crosses 0 (or b)
  !                      (assumes (fun(n)-b) changes sign at n=root)

  ! It can also be used with a logical-valued function
  ! in this case we shoot until we encounter TRUE
  ! similar to integer-value version if we make the mapping
  ! 0 -> FALSE
  ! 1 -> TRUE
  ! -r option or b can be used to reverse the sense

  subroutine Battleship_int( fun, root, n1, maxPhase1, ns, b, options )
    ! Args
    integer, external                          :: fun
    integer, optional, intent(in)              :: n1 ! 1st circle
    integer, optional, intent(in)              :: maxPhase1 ! max phase1 shots
    integer, optional, dimension(:), intent(in):: ns ! array of phase1 shots
    integer, intent(out)                       :: root ! root
    integer, optional, intent(in)              :: b ! is short
    character(len=*), optional, intent(in)     :: options
    ! Internal variables
    integer :: flast
    integer :: fnext
    integer :: isShort
    character(len=8) :: myOptions
    integer :: shot
    integer :: x0
    integer :: x1
    integer :: x2
    ! Executable
    isShort = 0
    if ( present(b) ) isShort = b
    myOptions = '-s'
    if ( present(options) ) myOptions = options
    root = -1 ! in case we can't find root
    ! Phase 1
    ! Some error checks
    if ( present(maxPhase1) ) then
      if ( (index(myOptions, 's') > 0 .and. fun(n1) /= isShort) ) return
      if ( (index(myOptions, 'r') > 0 .and. fun(n1) == isShort) ) return
      if ( maxPhase1 < 1 ) return
      if ( .not. present(n1) ) return
      x2 = n1 ! Initialize things
      fnext = fun(x2)
      do shot = 1, maxPhase1
        x1 = x2
        x2 = 2*x1
        flast = fnext
        fnext = fun(x2)
        if ( index(myOptions, 's') > 0 ) then
          if ( fnext /= isShort ) exit
        elseif ( index(myOptions, 'r') > 0 ) then
          if ( fnext == isShort ) exit
        else
          if ( (fnext-isShort)*(flast-isShort) <= 0 ) exit
        endif
      enddo
      if ( shot > maxPhase1 ) return ! No shot was long enough
    else
      if ( .not. present(ns) ) return
      x2 = ns(1) ! Initialize things
      fnext = fun(x2)
      if ( (index(myOptions, 's') > 0 .and. fnext /= isShort) ) return
      if ( (index(myOptions, 'r') > 0 .and. fnext == isShort) ) return
      do shot = 2, size(ns)
        x1 = x2
        x2 = ns(shot)
        flast = fnext
        fnext = fun(x2)
        if ( index(myOptions, 's') > 0 ) then
          if ( fnext /= isShort ) exit
        elseif ( index(myOptions, 'r') > 0 ) then
          if ( fnext == isShort ) exit
        else
          if ( (fnext-isShort)*(flast-isShort) <= 0 ) exit
        endif
      enddo
      if ( shot > size(ns) ) return ! No shot was long enough
    endif
    ! Phase 2
    ! Narrow the spashes, always keeping root between x0 and x2
    x0 = x1
    do
      x1 = (x0 + x2) / 2
      ! This test should prevent us from looping endlessly
      if ( x1 == x0 ) then
        ! apparently x0 = x2 - 1, so we've found our root
        if ( index(myOptions, 's') > 0 .or. index(myOptions, 'r') > 0 ) then
          root = x1
        else
          if ( fun(x1) == isShort ) then
            root = x1
          elseif ( fun(x2) == isShort ) then
            root = x2
          else
            root = -1
          endif
        endif
        return
      endif
      if ( index(myOptions, 's') > 0 ) then
        if ( fun(x1) == isShort ) then
          x0 = x1
          ! x2 = x2
        else
          ! x0 = x0
          x2 = x1
        endif
      elseif ( index(myOptions, 'r') > 0 ) then
        if ( fun(x1) == isShort ) then
          ! x0 = x0
          x2 = x1
        else
          x0 = x1
          ! x2 = x2
        endif
      else
        if ( (fun(x2)-isShort)*(fun(x1)-isShort) == 0 ) then
          if ( fun(x2) == isShort ) then
            root = x2
          else
            root = x1
          endif
          return
        elseif ( (fun(x2)-isShort)*(fun(x1)-isShort) < 0 ) then
          x0 = x1
        else
          x2 = x1
        endif
      endif
    enddo
  end subroutine Battleship_int

  subroutine Battleship_log( fun, root, n1, maxPhase1, ns, b, options )
    ! Args
    logical, external                          :: fun
    integer, optional, intent(in)              :: n1 ! 1st circle
    integer, optional, intent(in)              :: maxPhase1 ! max phase1 shots
    integer, optional, dimension(:), intent(in):: ns ! array of phase1 shots
    integer, intent(out)                       :: root ! root
    logical, optional, intent(in)              :: b ! is short
    character(len=*), optional, intent(in)     :: options
    ! Internal variables
    logical :: flast
    logical :: fnext
    logical :: isShort
    character(len=8) :: myOptions
    integer :: shot
    integer :: x0
    integer :: x1
    integer :: x2
    ! Executable
    isShort = .FALSE.
    if ( present(b) ) isShort = b
    myOptions = '-s'
    if ( present(options) ) myOptions = options
    root = -1 ! in case we can't find root
    ! Phase 1
    ! Some error checks
    if ( present(maxPhase1) ) then
      if ( (index(myOptions, 's') > 0 .and. ( fun(n1) .neqv. isShort) ) ) return
      if ( (index(myOptions, 'r') > 0 .and. ( fun(n1) .eqv. isShort) ) ) return
      if ( maxPhase1 < 1 ) return
      if ( .not. present(n1) ) return
      x2 = n1 ! Initialize things
      fnext = fun(x2)
      do shot = 1, maxPhase1
        x1 = x2
        x2 = 2*x1
        flast = fnext
        fnext = fun(x2)
        if ( index(myOptions, 's') > 0 ) then
          if ( fnext .neqv. isShort ) exit
        elseif ( index(myOptions, 'r') > 0 ) then
          if ( fnext .eqv. isShort ) exit
        else
          if ( fnext .neqv. flast ) exit
        endif
      enddo
      if ( shot > maxPhase1 ) return ! No shot was long enough
    else
      if ( .not. present(ns) ) return
      x2 = ns(1) ! Initialize things
      fnext = fun(x2)
      if ( (index(myOptions, 's') > 0 .and. ( fnext .neqv. isShort ) ) ) return
      if ( (index(myOptions, 'r') > 0 .and. ( fnext .eqv. isShort) ) ) return
      do shot = 2, size(ns)
        x1 = x2
        x2 = ns(shot)
        flast = fnext
        fnext = fun(x2)
        if ( index(myOptions, 's') > 0 ) then
          if ( fnext .neqv. isShort ) exit
        elseif ( index(myOptions, 'r') > 0 ) then
          if ( fnext .eqv. isShort ) exit
        else
          if ( fnext .neqv. flast ) exit
        endif
      enddo
      if ( shot > size(ns) ) return ! No shot was long enough
    endif
    ! Phase 2
    ! Narrow the spashes, always keeping root between x0 and x2
    x0 = x1
    do
      x1 = (x0 + x2) / 2
      ! This test should prevent us from looping endlessly
      if ( x1 == x0 ) then
        ! apparently x0 = x2 - 1, so we've found our root
        if ( index(myOptions, 's') > 0 .or. index(myOptions, 'r') > 0 ) then
          root = x1
        else
          if ( fun(x1) .eqv. isShort ) then
            root = x1
          elseif ( fun(x2) .eqv. isShort ) then
            root = x2
          else
            root = -1
          endif
        endif
        return
      endif
      if ( index(myOptions, 's') > 0 ) then
        if ( fun(x1) .eqv. isShort ) then
          x0 = x1
          ! x2 = x2
        else
          ! x0 = x0
          x2 = x1
        endif
      elseif ( index(myOptions, 'r') > 0 ) then
        if ( fun(x1) .eqv. isShort ) then
          ! x0 = x0
          x2 = x1
        else
          x0 = x1
          ! x2 = x2
        endif
      else
        if ( (fun(x2) .eqv. isShort) .or. (fun(x1) .eqv. isShort) ) then
          if ( fun(x2) .eqv. isShort ) then
            root = x2
          else
            root = x1
          endif
          return
        elseif ( fun(x2) .neqv. fun(x1) ) then
          x0 = x1
        else
          x2 = x1
        endif
      endif
    enddo
  end subroutine Battleship_log

! -------------------------------------------------  FillLookUpTable  -----
d1849 1
a1849 10
  ! This family of routines fills a table with evaluations of a function
  ! at regularly-spaced points
  ! Subsequently, instead of evaluating the function you can address the
  ! array at the index of its closest element
  
  ! This only makes sense if you're going to evaluate the function many more
  ! times than takes to fill the table and you're willing 
  ! to accept whatever error may result from using the ClosestValue
  ! Of course that error could be large if you will evaluate the function
  ! outside the range [x1, x2]
d1851 3
a1853 1
  subroutine FillLookUpTable_r4 ( fun, table, x1, x2, N, xtable )
d1855 28
a1882 2
    include 'FillLookUpTable.f9h'
  end subroutine FillLookUpTable_r4 
d1884 2
a1885 1
  subroutine FillLookUpTable_r8 ( fun, table, x1, x2, N, xtable )
d1887 28
a1914 2
    include 'FillLookUpTable.f9h'
  end subroutine FillLookUpTable_r8
d1921 9
a1929 5
  ! Args: (* means optional)
  ! x        pt at which to evaluate
  ! table    table of function values
  ! x1,x2    * range of equally-spaced argument values represented in table
  ! xtable   * table of argument values
d1931 10
a1940 8
  ! (none)   choose pt in xtable closest to x
  ! l        always choose lower of two closest x's in xtable
  ! u        always choose upper of two closest x's in xtable
  ! i        interpolate among two closest, but never extrapolate
  ! 1        return 1st derivative instead
  ! 2        return 2nd derivative (at nearest pt)
  ! S        return definite integral from x1 to x
  ! C        return definite integral from x to x2
d1942 11
d1954 1
a1954 1
    & missingValue, options ) result(value)
d1960 1
a1960 1
    & missingValue, options ) result(value)
d1965 1
a1965 9
! -------------------------------------------------  ClosestElement  -----

  ! This family of routines finds the element within a multidimensional
  ! array nearest a test value
  ! The array of indices locate that nearest element
  ! options  none, one, or more of the following:
  ! (none)   choose pt in array closest to x
  ! l        always choose lower of two closest x's in array
  ! u        always choose upper of two closest x's in array
d1967 3
a1969 1
  subroutine ClosestElement_r4_1d ( test, array, indices, options )
d1971 11
d1983 1
a1983 10
    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    include "ClosestElement.f9h"

  end subroutine ClosestElement_r4_1d

  subroutine ClosestElement_r8_1d ( test, array, indices, options )
d1985 11
d1997 3
a1999 10
    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    include "ClosestElement.f9h"

  end subroutine ClosestElement_r8_1d

  subroutine ClosestElement_r4_2d ( test, array, indices, options )
d2001 29
d2031 1
a2031 13
    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:,:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    integer, dimension(1)              :: indices_1d ! Result
    call ClosestElement( test, &
      & reshape(array, (/ size(array,1)*size(array,2) /) ), &
      & indices_1d )
    call rerank( indices_1d(1), shape(array), indices )
  end subroutine ClosestElement_r4_2d

  subroutine ClosestElement_r8_2d ( test, array, indices, options )
d2033 33
a2065 14

    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:,:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    integer, dimension(1)              :: indices_1d ! Result
    call ClosestElement( test, &
      & reshape(array, (/ size(array,1)*size(array,2) /) ), &
      & indices_1d )
    call rerank( indices_1d(1), shape(array), indices )
  end subroutine ClosestElement_r8_2d

  subroutine ClosestElement_r4_3d ( test, array, indices, options )
d2067 39
d2107 1
a2107 13
    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:,:,:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    integer, dimension(1)              :: indices_1d ! Result
    call ClosestElement( test, &
      & reshape(array, (/ size(array,1)*size(array,2)*size(array,3) /) ), &
      & indices_1d )
    call rerank( indices_1d(1), shape(array), indices )
  end subroutine ClosestElement_r4_3d

  subroutine ClosestElement_r8_3d ( test, array, indices, options )
d2109 39
a2148 13
    ! Dummy arguments
    real(rk), intent(in)               :: test
    real(rk), dimension(:,:,:), intent(in) :: array
    integer, dimension(:), intent(out) :: indices ! Result
    character(len=*), optional, intent(in)      :: options
    integer, dimension(1)              :: indices_1d ! Result
    call ClosestElement( test, &
      & reshape(array, (/ size(array,1)*size(array,2)*size(array,3) /) ), &
      & indices_1d )
    call rerank( indices_1d(1), shape(array), indices )
  end subroutine ClosestElement_r8_3d

!-------------------- Private Procedures -----------------------------------
d2206 68
d2278 1
a2278 1
       "$Id: MLSNumerics.f90,v 2.52 2007/07/25 20:09:25 vsnyder Exp $"
d2289 3
@


2.52
log
@Delete USE for unused entity
@
text
@d28 73
a174 34
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSNumerics.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! This module contains some low level numerical stuff, hunting, interpolating
  ! etc.
!     c o n t e n t s
!     - - - - - - - -

!         Functions, operations, routines
! ClosestElement           Find index(es) in array closest to test value
!                           (array may be multidimensional, non-monotonic)
! Dump                     Dump coefficients structure
! EssentiallyEqual         Returns true if two real arguments 'close enough'
!                            (See comments below for interpretation
!                             of array versions)
! Hunt                     Finds index of item(s) in list closest to prey
!                           (list must be monotonic)
! HuntArray                Hunts for multiple items
! HuntScalar               Hunts for just one
! HuntRange                Finds index range between which
!                           all item(s) in list lie within range of values
! InterpolateArraySetup    Compute coefficients for InterpolateUsingSetup
! InterpolateArrayTeardown Deallocate tables created by InterpolateArraySetup
! InterpolateValues        Interpolate for new y value(s):
!                            given old (x,y), new (x), method
! Battleship               By wise-ranging evaluations find integer root
! FillLookUpTable          Fill table with evaluations at regularly-spaced args
!                            to be used in place of later, frequent evaluations;
!                            reversing role of (table, xtable) => function^(-1)
! UseLookUpTable           Use LookUpTable to approximate function

d1199 4
d1372 1
a1372 1
       "$Id: MLSNumerics.f90,v 2.51 2007/07/23 23:18:26 pwagner Exp $"
d1383 3
@


2.51
log
@Battleship may be used with logical-valued function
@
text
@a23 1
  use Output_M, only: Output
d1329 1
a1329 1
       "$Id: MLSNumerics.f90,v 2.50 2007/06/21 00:49:52 vsnyder Exp $"
d1340 3
@


2.50
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d137 4
d872 8
a879 1
  subroutine Battleship( fun, root, n1, maxPhase1, ns, b, options )
d999 124
a1122 1
  end subroutine Battleship
d1330 1
a1330 1
       "$Id: MLSNumerics.f90,v 2.49 2007/04/02 22:53:26 pwagner Exp $"
d1341 3
@


2.49
log
@Added Battleship integer rootfinder
@
text
@d658 1
a658 1
    real(rk), dimension(2), optional, intent(in) :: rangeofperiod	  ! for periodic data
d684 1
a684 1
    real(rk), dimension(2), optional, intent(in) :: rangeofperiod	  ! for periodic data
d1196 1
a1196 1
       "$Id: MLSNumerics.f90,v 2.48 2007/03/14 23:58:05 pwagner Exp $"
d1207 3
@


2.48
log
@Improved precision when interpolating
@
text
@d29 1
d131 1
d836 153
d1196 1
a1196 1
       "$Id: MLSNumerics.f90,v 2.47 2007/03/02 18:21:14 pwagner Exp $"
d1207 3
@


2.47
log
@Added LookUpTable routines
@
text
@d24 1
d534 1
a534 1
    type(coefficients_r4) :: Coeffs
d577 1
a577 1
    type(coefficients_R4), intent(out) :: Coeffs
d697 1
a697 1
    type(coefficients_r4), intent(in) :: Coeffs
d749 1
a749 1
    type(coefficients_r4), intent(in) :: Coeffs
d873 2
a874 1
  function UseLookUpTable_r4 ( x, table, x1, x2, xtable, options ) result(value)
d879 2
a880 1
  function UseLookUpTable_r8 ( x, table, x1, x2, xtable, options ) result(value)
d1041 1
a1041 1
       "$Id: MLSNumerics.f90,v 2.46 2006/10/04 03:20:08 vsnyder Exp $"
d1052 3
@


2.46
log
@Better comments for HUNT results
@
text
@d31 1
d129 4
d176 8
d833 49
d887 4
d892 1
a892 1
  subroutine ClosestElement_r4_1d ( test, array, indices )
d899 1
d904 1
a904 1
  subroutine ClosestElement_r8_1d ( test, array, indices )
d911 1
d916 1
a916 1
  subroutine ClosestElement_r4_2d ( test, array, indices )
d923 1
d931 1
a931 1
  subroutine ClosestElement_r8_2d ( test, array, indices )
d938 1
d946 1
a946 1
  subroutine ClosestElement_r4_3d ( test, array, indices )
d953 1
d961 1
a961 1
  subroutine ClosestElement_r8_3d ( test, array, indices )
d968 1
d1038 1
a1038 1
       "$Id: MLSNumerics.f90,v 2.45 2006/08/05 02:36:36 vsnyder Exp $"
d1049 3
@


2.45
log
@Delete unused symbols
@
text
@d367 2
a368 1
    integer, dimension(:), intent(out) :: indices ! Result
d388 2
a389 1
    integer, dimension(:), intent(out) :: indices ! Result
d411 1
a411 1
    integer, intent(out) :: index ! Resulting index
d436 1
a436 1
    integer, intent(out) :: index ! Resulting index
d966 1
a966 1
       "$Id: MLSNumerics.f90,v 2.44 2006/08/03 01:57:22 vsnyder Exp $"
d977 3
@


2.44
log
@Return an optional status flag from Hunt
@
text
@d19 1
a19 1
  use MLSCommon, only : DEFAULTUNDEFINEDVALUE, R4, R8, Rm
d23 1
a23 1
  use MLSStrings, only: Capitalize, lowercase
a946 1
    integer :: targ
d964 1
a964 1
       "$Id: MLSNumerics.f90,v 2.43 2006/01/14 00:53:05 pwagner Exp $"
d975 3
@


2.43
log
@Added HuntRange
@
text
@d21 1
a21 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d361 1
a361 1
    & allowBelowValue, nearest, logSpace )
d373 1
d380 2
a381 2
  subroutine HuntArray_r8 ( list, values, indices, start, allowTopValue, allowBelowValue, &
    & nearest, logSpace )
d393 1
d965 1
a965 1
       "$Id: MLSNumerics.f90,v 2.42 2006/01/05 03:46:47 vsnyder Exp $"
d976 3
@


2.42
log
@Add Interp_Bilinear_2d_1d_r*
@
text
@d22 1
a22 1
  use MLSSets, only: FindFirst
d28 2
a29 1
  public :: Dump, EssentiallyEqual, Hunt, InterpolateArraySetup
a30 1
  public :: ClosestElement
d122 2
d145 4
d448 33
d963 1
a963 1
       "$Id: MLSNumerics.f90,v 2.41 2006/01/05 00:56:03 pwagner Exp $"
d974 3
@


2.41
log
@Added ClosestElement for multidimensional, non-monotonic Hunting
@
text
@d156 1
d737 40
d924 1
a924 1
       "$Id: MLSNumerics.f90,v 2.40 2005/12/16 00:02:05 pwagner Exp $"
d935 3
@


2.40
log
@FillValue-related stuff moved to new MLSFillValues module
@
text
@d22 1
d30 1
d112 14
a125 10
! Dump                         Dump coefficients structure
! EssentiallyEqual             Returns true if two real arguments 'close enough'
!                                (See comments below for interpretation
!                                 of array versions)
! Hunt                         Finds index of item(s) in list closest to prey
! HuntArray                    Hunts for multiple items
! HuntScalar                   Hunts for just one
! InterpolateArraySetup        Compute coefficients for InterpolateUsingSetup
! InterpolateArrayTeardown     Deallocate tables created by InterpolateArraySetup
! InterpolateValues            Interpolate for new y value(s): given old (x,y), new (x), method
d158 6
d736 144
d883 1
a883 1
       "$Id: MLSNumerics.f90,v 2.39 2005/11/04 18:47:34 pwagner Exp $"
d894 3
@


2.39
log
@Added IsMonotonic; Monotonize made public
@
text
@d19 2
a20 2
  use MLSCommon, only : DEFAULTUNDEFINEDVALUE, R4, R8, Rm, &
    & filterValues
a28 1
  public :: IsFillValue, IsMonotonic, Monotonize, ReplaceFillValues
a119 8
! IsFillValue                  Returns true if argument is FillValue
! ReplaceFillValues            Replaces FillValue entries in an array

  interface BridgeMissingValues
    module procedure BridgeMissingValues_1dr4, BridgeMissingValues_1dr8, BridgeMissingValues_1dint
    module procedure BridgeMissingValues_2dr4, BridgeMissingValues_2dr8, BridgeMissingValues_2dint
    module procedure BridgeMissingValues_3dr4, BridgeMissingValues_3dr8, BridgeMissingValues_3dint
  end interface
a151 22
  interface IsFillValue
    module procedure IsFillValue_r4, IsFillValue_r8, IsFillValue_int
  end interface

  interface IsMonotonic
    module procedure IsMonotonic_r4, IsMonotonic_r8, IsMonotonic_int
  end interface

  interface Monotonize
    module procedure Monotonize_1dr4, Monotonize_1dr8, Monotonize_1dint
    module procedure Monotonize_2dr4, Monotonize_2dr8, Monotonize_2dint
    module procedure Monotonize_3dr4, Monotonize_3dr8, Monotonize_3dint
  end interface

  interface ReplaceFillValues
    module procedure ReplaceFill1d_r4, ReplaceFill1d_r8, ReplaceFill1d_int
    module procedure ReplaceFill2d_r4, ReplaceFill2d_r8, ReplaceFill2d_int
    module procedure ReplaceFill3d_r4, ReplaceFill3d_r8, ReplaceFill3d_int
  end interface

  real, parameter, private :: FILLVALUETOLERANCE = 0.2 ! Poss. could make it 1

a723 469
! -------------------------------------  ReplaceFillValues  -----

  ! This family of routines replaces entries in an array
  ! based on whether they
  ! (1) are equal to FillValue; or
  ! (2) other criteria set by options
  ! The replacement values are supplied either by 
  ! newvalues, newFill, or according to options (e.g., you may interpolate)
  ! Note:
  ! When interpolating arrays with rank > 1, the interpolated-against
  ! index is the last one
  ! Thus we don't do true multi-dimensional interpolation
  ! If you wish to interpolate against another index, you must reshape

  subroutine ReplaceFill1d_int ( values, FillValue, newValues, newFill, options )
    integer, dimension(:), intent(inout) :: values
    integer, intent(in) :: FillValue
    integer, dimension(:), optional, intent(in) :: newvalues
    integer, optional, intent(in) :: newFill
    character(len=*), optional, intent(in) :: options
    !
    ! Local variables
    ! More local variables and executable
    include 'ReplaceFillValues.f9h'
  end subroutine ReplaceFill1d_int

  subroutine ReplaceFill1d_r4 ( values, FillValue, newValues, newFill, options )
    real(r4), dimension(:), intent(inout) :: values
    real(r4), intent(in) :: FillValue
    real(r4), dimension(:), optional, intent(in) :: newvalues
    real(r4), optional, intent(in) :: newFill
    character(len=*), optional, intent(in) :: options
    !
    ! Local variables
    ! More local variables and executable
    include 'ReplaceFillValues.f9h'
  end subroutine ReplaceFill1d_r4

  subroutine ReplaceFill1d_r8 ( values, FillValue, newValues, newFill, options )
    real(r8), dimension(:), intent(inout) :: values
    real(r8), intent(in) :: FillValue
    real(r8), dimension(:), optional, intent(in) :: newvalues
    real(r8), optional, intent(in) :: newFill
    character(len=*), optional, intent(in) :: options
    !
    ! Local variables
    ! More local variables and executable
    include 'ReplaceFillValues.f9h'
  end subroutine ReplaceFill1d_r8

  subroutine ReplaceFill2d_int ( values, FillValue, newValues, newFill, options )
    integer, dimension(:, :), intent(inout) :: values
    integer, intent(in) :: FillValue
    integer, dimension(:, :), optional, intent(in) :: newvalues
    integer, optional, intent(in) :: newFill
    character(len=*), optional, intent(in) :: options
    !
    ! Local variables
    ! More local variables and executable
    include 'ReplaceFillValues.f9h'
  end subroutine ReplaceFill2d_int

  subroutine ReplaceFill2d_r4 ( values, FillValue, newValues, newFill, options )
    real(r4), dimension(:, :), intent(inout) :: values
    real(r4), intent(in) :: FillValue
    real(r4), dimension(:, :), optional, intent(in) :: newvalues
    real(r4), optional, intent(in) :: newFill
    character(len=*), optional, intent(in) :: options
    !
    ! Local variables
    ! More local variables and executable
    include 'ReplaceFillValues.f9h'
  end subroutine ReplaceFill2d_r4

  subroutine ReplaceFill2d_r8 ( values, FillValue, newValues, newFill, options )
    real(r8), dimension(:, :), intent(inout) :: values
    real(r8), intent(in) :: FillValue
    real(r8), dimension(:, :), optional, intent(in) :: newvalues
    real(r8), optional, intent(in) :: newFill
    character(len=*), optional, intent(in) :: options
    !
    ! Local variables
    ! More local variables and executable
    include 'ReplaceFillValues.f9h'
  end subroutine ReplaceFill2d_r8

  subroutine ReplaceFill3d_int ( values, FillValue, newValues, newFill, options )
    integer, dimension(:, :, :), intent(inout) :: values
    integer, intent(in) :: FillValue
    integer, dimension(:, :, :), optional, intent(in) :: newvalues
    integer, optional, intent(in) :: newFill
    character(len=*), optional, intent(in) :: options
    !
    ! Local variables
    ! More local variables and executable
    include 'ReplaceFillValues.f9h'
  end subroutine ReplaceFill3d_int

  subroutine ReplaceFill3d_r4 ( values, FillValue, newValues, newFill, options )
    real(r4), dimension(:, :, :), intent(inout) :: values
    real(r4), intent(in) :: FillValue
    real(r4), dimension(:, :, :), optional, intent(in) :: newvalues
    real(r4), optional, intent(in) :: newFill
    character(len=*), optional, intent(in) :: options
    !
    ! Local variables
    ! More local variables and executable
    include 'ReplaceFillValues.f9h'
  end subroutine ReplaceFill3d_r4

  subroutine ReplaceFill3d_r8 ( values, FillValue, newValues, newFill, options )
    real(r8), dimension(:, :, :), intent(inout) :: values
    real(r8), intent(in) :: FillValue
    real(r8), dimension(:, :, :), optional, intent(in) :: newvalues
    real(r8), optional, intent(in) :: newFill
    character(len=*), optional, intent(in) :: options
    !
    ! Local variables
    ! More local variables and executable
    include 'ReplaceFillValues.f9h'
  end subroutine ReplaceFill3d_r8

! ------------------------------------------------- IsFillValue ---

  ! This family of routines checks to see if an arg is a fillValue
  elemental logical function IsFillValue_int ( A, FILLVALUE )
    integer, intent(in) :: A
    integer ,intent(in), optional :: FILLVALUE
    integer  :: MYFILLVALUE
    myFillValue = int(DEFAULTUNDEFINEDVALUE)
    if ( present(fillValue) ) myFillValue = fillValue
    IsFillValue_int = &
      & abs(a - myFillValue) < 1 ! FILLVALUETOLERANCE
  end function IsFillValue_int

  elemental logical function IsFillValue_r4 ( A, FILLVALUE )
    real(r4), intent(in) :: A
    real(r4) ,intent(in), optional :: FILLVALUE
    real(r4)  :: MYFILLVALUE
    myFillValue = DEFAULTUNDEFINEDVALUE
    if ( present(fillValue) ) myFillValue = fillValue
    IsFillValue_r4 = &
      & abs(a - myFillValue) < FILLVALUETOLERANCE
  end function IsFillValue_r4

  elemental logical function IsFillValue_r8 ( A, FILLVALUE )
    real(r8), intent(in) :: A
    real(r8) ,intent(in), optional :: FILLVALUE
    real(r8)  :: MYFILLVALUE
    myFillValue = DEFAULTUNDEFINEDVALUE
    if ( present(fillValue) ) myFillValue = fillValue
    IsFillValue_r8 = &
      & abs(a - myFillValue) < Real(FILLVALUETOLERANCE, r8)
  end function IsFillValue_r8

! ------------------------------------------------- IsMonotonic ---

  ! This family of routines checks to see if an array monotonically increases
  ! By default it returns TRUE if either monotonic increasing or decreasing
  ! If optional DIRECTION is supplied and '+', TRUE means increasing
  ! if '-', TRUE means drecreasing
  ! We are strict in the sense that any "stalling" produces FALSE
  ! Thus {0, 1, 2, 2, 3} is not monotonic
  !
  ! If you would like to know instead whether an array is "never falling"
  ! or "never rising" that's a different though related condition
  logical function IsMonotonic_int ( ARRAY, DIRECTION ) result(sooDesu)
    integer, dimension(:), intent(in) :: ARRAY
    character(len=*), intent(in), optional :: DIRECTION
    ! Internal variables
    character(len=1) :: MYDIRECTION
    integer :: i
    integer, dimension(size(array)-1) :: increment
    integer :: incMax
    integer :: incMin
    integer, parameter :: ZERO = 0
    ! Executable
    myDirection = '0' ! Either direction is OK, as long as monotonic
    if ( present(direction) ) myDirection = direction
    if ( size(array) < 2 ) then
      sooDesu = .true.
      return
    endif
    do i=2, size(array)
      increment(i-1) = array(i) - array(i-1)
    enddo
    incMin = minval(increment)
    incMax = maxval(increment)
    select case (myDirection)
    case ('+') ! Must be increasing monotonic
      sooDesu = ( incMin > zero )
    case ('-') ! Must be decreasing monotonic
      sooDesu = ( incMax < zero )
    case default ! either will do
      sooDesu = ( incMin > zero ) .or. ( incMax < zero )
    end select
  end function IsMonotonic_int

  logical function IsMonotonic_r4 ( ARRAY, DIRECTION ) result(sooDesu)
    real(r4), dimension(:), intent(in) :: ARRAY
    character(len=*), intent(in), optional :: DIRECTION
    ! Internal variables
    character(len=1) :: MYDIRECTION
    integer :: i
    real(r4), dimension(size(array)-1) :: increment
    real(r4) :: incMax
    real(r4) :: incMin
    real(r4), parameter :: ZERO = 0._r4
    ! Executable
    myDirection = '0' ! Either direction is OK, as long as monotonic
    if ( present(direction) ) myDirection = direction
    if ( size(array) < 2 ) then
      sooDesu = .true.
      return
    endif
    do i=2, size(array)
      increment(i-1) = array(i) - array(i-1)
    enddo
    incMin = minval(increment)
    incMax = maxval(increment)
    select case (myDirection)
    case ('+') ! Must be increasing monotonic
      sooDesu = ( incMin > zero )
    case ('-') ! Must be decreasing monotonic
      sooDesu = ( incMax < zero )
    case default ! either will do
      sooDesu = ( incMin > zero ) .or. ( incMax < zero )
    end select
  end function IsMonotonic_r4

  logical function IsMonotonic_r8 ( ARRAY, DIRECTION ) result(sooDesu)
    real(r8), dimension(:), intent(in) :: ARRAY
    character(len=*), intent(in), optional :: DIRECTION
    ! Internal variables
    character(len=1) :: MYDIRECTION
    integer :: i
    real(r8), dimension(size(array)-1) :: increment
    real(r8) :: incMax
    real(r8) :: incMin
    real(r8), parameter :: ZERO = 0._r8
    ! Executable
    myDirection = '0' ! Either direction is OK, as long as monotonic
    if ( present(direction) ) myDirection = direction
    if ( size(array) < 2 ) then
      sooDesu = .true.
      return
    endif
    do i=2, size(array)
      increment(i-1) = array(i) - array(i-1)
    enddo
    incMin = minval(increment)
    incMax = maxval(increment)
    select case (myDirection)
    case ('+') ! Must be increasing monotonic
      sooDesu = ( incMin > zero )
    case ('-') ! Must be decreasing monotonic
      sooDesu = ( incMax < zero )
    case default ! either will do
      sooDesu = ( incMin > zero ) .or. ( incMax < zero )
    end select
  end function IsMonotonic_r8

! ============================================================================
  ! This family of subroutines bridges missing values by interpolation
  subroutine BridgeMissingValues_1dint(values, MissingValue)
    ! Args
    integer, dimension(:), intent(inout) :: values
    integer, intent(in), optional        :: missingValue
    ! Internal variables
    integer :: dx
    integer :: myMissingValue
    integer :: x1
    integer :: x2
    include 'BridgeMissingValues.f9h'
  end subroutine BridgeMissingValues_1dint

  subroutine BridgeMissingValues_1dr4(values, MissingValue)
    ! Args
    real(r4), dimension(:), intent(inout) :: values
    real(r4), intent(in), optional        :: missingValue
    ! Internal variables
    real(r4) :: dx
    real(r4) :: myMissingValue
    real(r4) :: x1
    real(r4) :: x2
    include 'BridgeMissingValues.f9h'
  end subroutine BridgeMissingValues_1dr4

  subroutine BridgeMissingValues_1dr8(values, MissingValue)
    ! Args
    real(r8), dimension(:), intent(inout) :: values
    real(r8), intent(in), optional        :: missingValue
    ! Internal variables
    real(r8) :: dx
    real(r8) :: myMissingValue
    real(r8) :: x1
    real(r8) :: x2
    include 'BridgeMissingValues.f9h'
  end subroutine BridgeMissingValues_1dr8

  subroutine BridgeMissingValues_2dint(values, MissingValue)
    ! Args
    integer, dimension(:,:), intent(inout) :: values
    integer, intent(in), optional          :: missingValue
    ! Internal variables
    integer :: i
    do i=1, size(values, 1)
      call BridgeMissingValues(values(i,:), MissingValue)
    enddo
  end subroutine BridgeMissingValues_2dint

  subroutine BridgeMissingValues_2dr4(values, MissingValue)
    ! Args
    real(r4), dimension(:,:), intent(inout) :: values
    real(r4), intent(in), optional          :: missingValue
    ! Internal variables
    integer :: i
    do i=1, size(values, 1)
      call BridgeMissingValues(values(i,:), MissingValue)
    enddo
  end subroutine BridgeMissingValues_2dr4

  subroutine BridgeMissingValues_2dr8(values, MissingValue)
    ! Args
    real(r8), dimension(:,:), intent(inout) :: values
    real(r8), intent(in), optional          :: missingValue
    ! Internal variables
    integer :: i
    do i=1, size(values, 1)
      call BridgeMissingValues(values(i,:), MissingValue)
    enddo
  end subroutine BridgeMissingValues_2dr8

  subroutine BridgeMissingValues_3dint(values, MissingValue)
    ! Args
    integer, dimension(:,:,:), intent(inout) :: values
    integer, intent(in), optional            :: missingValue
    ! Internal variables
    integer :: i, j
    do j=1, size(values, 2)
      do i=1, size(values, 1)
        call BridgeMissingValues(values(i,j,:), MissingValue)
      enddo
    enddo
  end subroutine BridgeMissingValues_3dint

  subroutine BridgeMissingValues_3dr4(values, MissingValue)
    ! Args
    real(r4), dimension(:,:,:), intent(inout) :: values
    real(r4), intent(in), optional            :: missingValue
    ! Internal variables
    integer :: i, j
    do j=1, size(values, 2)
      do i=1, size(values, 1)
        call BridgeMissingValues(values(i,j,:), MissingValue)
      enddo
    enddo
  end subroutine BridgeMissingValues_3dr4

  subroutine BridgeMissingValues_3dr8(values, MissingValue)
    ! Args
    real(r8), dimension(:,:,:), intent(inout) :: values
    real(r8), intent(in), optional            :: missingValue
    ! Internal variables
    integer :: i, j
    do j=1, size(values, 2)
      do i=1, size(values, 1)
        call BridgeMissingValues(values(i,j,:), MissingValue)
      enddo
    enddo
  end subroutine BridgeMissingValues_3dr8

  ! This family of subroutines makes arrays of values monotonically (increasing)
  subroutine Monotonize_1dint(values)
    ! Args
    integer, dimension(:), intent(inout) :: values
    ! Internal variables
    integer :: dx
    integer :: x1
    integer :: x2
    include 'Monotonize.f9h'
  end subroutine Monotonize_1dint

  subroutine Monotonize_1dr4(values)
    ! Args
    real(r4), dimension(:), intent(inout) :: values
    ! Internal variables
    real(r4) :: dx
    real(r4) :: x1
    real(r4) :: x2
    include 'Monotonize.f9h'
  end subroutine Monotonize_1dr4

  subroutine Monotonize_1dr8(values)
    ! Args
    real(r8), dimension(:), intent(inout) :: values
    ! Internal variables
    real(r8) :: dx
    real(r8) :: x1
    real(r8) :: x2
    include 'Monotonize.f9h'
  end subroutine Monotonize_1dr8

  subroutine Monotonize_2dint(values)
    ! Args
    integer, dimension(:,:), intent(inout) :: values
    ! Internal variables
    integer :: i
    do i=1, size(values, 1)
      call Monotonize(values(i,:))
    enddo
  end subroutine Monotonize_2dint

  subroutine Monotonize_2dr4(values)
    ! Args
    real(r4), dimension(:,:), intent(inout) :: values
    ! Internal variables
    integer :: i
    do i=1, size(values, 1)
      call Monotonize(values(i,:))
    enddo
  end subroutine Monotonize_2dr4

  subroutine Monotonize_2dr8(values)
    ! Args
    real(r8), dimension(:,:), intent(inout) :: values
    ! Internal variables
    integer :: i
    do i=1, size(values, 1)
      call Monotonize(values(i,:))
    enddo
  end subroutine Monotonize_2dr8

  subroutine Monotonize_3dint(values)
    ! Args
    integer, dimension(:,:,:), intent(inout) :: values
    ! Internal variables
    integer :: i, j
    do j=1, size(values, 2)
      do i=1, size(values, 1)
        call Monotonize(values(i,j,:))
      enddo
    enddo
  end subroutine Monotonize_3dint

  subroutine Monotonize_3dr4(values)
    ! Args
    real(r4), dimension(:,:,:), intent(inout) :: values
    ! Internal variables
    integer :: i, j
    do j=1, size(values, 2)
      do i=1, size(values, 1)
        call Monotonize(values(i,j,:))
      enddo
    enddo
  end subroutine Monotonize_3dr4

  subroutine Monotonize_3dr8(values)
    ! Args
    real(r8), dimension(:,:,:), intent(inout) :: values
    ! Internal variables
    integer :: i, j
    do j=1, size(values, 2)
      do i=1, size(values, 1)
        call Monotonize(values(i,j,:))
      enddo
    enddo
  end subroutine Monotonize_3dr8

d727 1
a727 1
       "$Id: MLSNumerics.f90,v 2.38 2005/08/15 20:35:37 pwagner Exp $"
d738 3
@


2.38
log
@Added Monotonize interfaces
@
text
@d17 1
a17 1
  use DUMP_0, only : DUMP
d29 1
a29 1
  public :: IsFillValue, ReplaceFillValues
d165 4
a879 1
  ! This family of routines checks to see if an arg is a fillValue
d910 107
d1227 1
a1227 1
       "$Id: MLSNumerics.f90,v 2.37 2005/08/06 01:36:30 vsnyder Exp $"
d1238 3
@


2.37
log
@Add Dump for interpolation coefficients
@
text
@d165 6
d1017 97
d1117 1
a1117 1
       "$Id: MLSNumerics.f90,v 2.36 2005/08/05 20:34:47 pwagner Exp $"
d1128 3
@


2.36
log
@ReplaceFillValues can now to interpolate to bridge across MissingValues
@
text
@d14 1
a14 1
  !=============================================================================
d27 1
a27 1
  public :: EssentiallyEqual, Hunt, InterpolateArraySetup
d53 2
a54 1
    !  $\int B \text{d}x = -\frac{x(x_i    +\frac{x}2)}g$.\\
d56 1
a56 1
    !                      \left( \int A \text{d}x + \frac{g a^4}4 \right)$.
d58 1
a58 1
    !                      \left( \int B \text{d}x - \frac{g b^4}4 \right)$.
d87 2
a88 1
    !  $\int B \text{d}x = -\frac{x(x_i    +\frac{x}2)}g$.\\
d90 1
a90 1
    !                      \left( \int A \text{d}x + \frac{g a^4}4 \right)$.
d92 1
a92 1
    !                      \left( \int B \text{d}x - \frac{g b^4}4 \right)$.
d111 1
d118 2
a120 2
! InterpolateArray             Interpolates for multiple values
! InterpolateScalar            Interpolates for just one
d123 1
a123 1
  
d130 4
d175 14
a188 1
! ------------------------------------------------- EssentiallyEqual ---
d1014 1
a1014 1
       "$Id: MLSNumerics.f90,v 2.35 2005/08/03 16:36:46 pwagner Exp $"
d1025 3
@


2.35
log
@antiderivatives; added replaceFillValues
@
text
@d121 6
d163 1
d728 1
a728 1
  ! based on whethet they
d733 5
d882 109
d994 1
a994 1
       "$Id: MLSNumerics.f90,v 2.34 2005/06/22 17:25:50 pwagner Exp $"
d1005 3
@


2.34
log
@Reworded Copyright statement, moved rcs id
@
text
@d22 1
a22 1
  use MLSStrings, only: Capitalize
d29 1
a29 1
  public :: IsFillValue
d33 7
a39 1
    ! Stuff for linear
d41 2
a42 2
    integer, pointer :: LowerInds(:) => NULL(), UpperInds(:) => NULL()
    ! Stuff for spline
a43 1
    real(r4), pointer :: E(:) => NULL(), F(:) => NULL(), Gap2(:) => NULL()
d45 15
d66 7
a72 1
    ! Stuff for linear
d74 2
a75 2
    integer, pointer :: LowerInds(:) => NULL(), UpperInds(:) => NULL()
    ! Stuff for spline
a76 1
    real(r8), pointer :: E(:) => NULL(), F(:) => NULL(), Gap2(:) => NULL()
d78 15
d99 1
a99 1
       "$RCSfile: $"
d119 1
a119 1

d149 7
a155 1
    module procedure IsFillValue_r4, IsFillValue_r8
a156 1
  
d439 1
a439 1
    & badValue, missingRegions, dyByDx, dNewByDOld, skipNewY )
d455 2
d467 1
a467 1
    & badValue, missingRegions, dyByDx, dNewByDOld, skipNewY )
d483 2
d495 1
a495 1
    & Extrapolate, Width, DyByDx, dNewByDOld )
d510 2
d520 1
a520 1
    & Extrapolate, Width, DyByDx, dNewByDOld )
d535 2
d567 1
a567 1
    & badValue, missingRegions, dyByDx, RangeOfPeriod, skipNewY )
d583 2
d592 1
a592 1
    & badValue, missingRegions, dyByDx, RangeOfPeriod, skipNewY )
d608 2
d617 1
a617 1
    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY )
d633 2
d643 1
a643 1
    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY )
d659 2
d669 1
a669 1
    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY )
d685 2
d695 1
a695 1
    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY )
d711 2
d718 117
d838 11
d873 1
a873 1
       "$Id: $"
d884 3
@


2.33
log
@Added new versions of EssentaillyEqual discounting Fills, NaNs
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d57 1
a57 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: MLSNumerics.f90,v 2.32 2005/01/19 17:16:48 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d59 1
a59 1
       "$RCSfile: MLSNumerics.f90,v $"
d678 5
d691 3
@


2.32
log
@Now gets dump from dump_0
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d8 1
a8 1
  use Allocate_Deallocate, only : Allocate_test, Deallocate_test
d11 2
a12 1
  use MLSCommon, only : DEFAULTUNDEFINEDVALUE, R4, R8, Rm
d51 1
a51 1
       "$Id: MLSNumerics.f90,v 2.31 2004/09/28 23:14:24 pwagner Exp $"
d65 2
d78 3
d129 149
d671 1
a671 1
!=============================================================================
d681 3
@


2.31
log
@Added isFillValue function
@
text
@d9 1
d50 1
a50 1
       "$Id: MLSNumerics.f90,v 2.30 2004/09/10 23:52:29 livesey Exp $"
d526 3
@


2.30
log
@Added the logSpace options for Hunt (not actually needed but never
mind).
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d10 1
a10 1
  use MLSCommon, only : R4, R8, Rm
d19 1
d49 1
a49 1
       "$Id: MLSNumerics.f90,v 2.29 2003/09/11 23:09:18 livesey Exp $"
d69 1
d96 6
d492 23
d525 4
@


2.29
log
@Added skipNewY argument
@
text
@d48 1
a48 1
       "$Id: MLSNumerics.f90,v 2.28 2003/04/04 00:10:08 livesey Exp $"
d122 1
a122 1
    & allowBelowValue, nearest )
d133 1
d141 1
a141 1
    & nearest )
d152 1
d162 1
a162 1
    & allowBelowValue, nearest )
d173 1
d187 1
a187 1
    & allowBelowValue, nearest )
d198 1
d494 3
@


2.28
log
@Added EssentiallyEqual
@
text
@d48 1
a48 1
       "$Id: MLSNumerics.f90,v 2.27 2002/11/25 18:51:19 vsnyder Exp $"
d221 1
a221 1
    & badValue, missingRegions, dyByDx, dNewByDOld )
d236 1
d247 1
a247 1
    & badValue, missingRegions, dyByDx, dNewByDOld )
d262 1
d341 1
a341 1
    & badValue, missingRegions, dyByDx, RangeOfPeriod )
d356 1
d364 1
a364 1
    & badValue, missingRegions, dyByDx, RangeOfPeriod )
d379 1
d387 1
a387 1
    & method, extrapolate, badValue, missingRegions, dyByDx )
d402 1
d411 1
a411 1
    & method, extrapolate, badValue, missingRegions, dyByDx )
d426 1
d435 1
a435 1
    & method, extrapolate, badValue, missingRegions, dyByDx )
d450 1
d459 1
a459 1
    & method, extrapolate, badValue, missingRegions, dyByDx )
d474 1
d490 3
@


2.27
log
@More interfaces
@
text
@d17 2
a18 2
  public :: Hunt, InterpolateArraySetup, InterpolateArrayTeardown
  public :: InterpolateValues
d48 1
a48 1
       "$Id: MLSNumerics.f90,v 2.26 2002/11/23 00:01:00 vsnyder Exp $"
d61 1
d69 4
d96 18
d482 3
@


2.26
log
@Modify interpolation to separate setup and teardown
@
text
@d48 1
a48 1
       "$Id: MLSNumerics.f90,v 2.25 2002/10/08 00:09:12 pwagner Exp $"
d86 1
d258 2
a262 2
    real(rk), dimension(:,:), optional, intent(in) :: DyByDx ! just a signal to
                                           ! compute more coeffs for splines
d281 2
a285 2
    real(rk), dimension(:,:), optional, intent(in) :: DyByDx ! just a signal to
                                           ! compute more coeffs for splines
d357 46
d459 3
@


2.25
log
@Added idents to survive zealous Lahey optimizer
@
text
@d9 3
a11 4
  use MatrixModule_0, only: CreateBlock, M_Absent, M_Column_Sparse, &
    & MatrixElement_T, Sparsify
  use MLSCommon, only : r8, rm, r4
  use MLSMessageModule, only: MLSMessage,MLSMSG_Error
d17 28
a44 1
  public :: Hunt, InterpolateValues
d48 1
a48 1
       "$Id: MLSNumerics.f90,v 2.24 2002/10/04 16:40:30 pwagner Exp $"
d74 8
d85 1
d90 2
d97 2
a98 2
  subroutine HuntArray_r4 ( list, values, indices, start, allowTopValue, allowBelowValue, &
    & nearest )
d113 2
d131 1
a131 1
  ! ---------------------------------------------------------------------------
d157 2
d181 1
a181 1
  ! ---------------------------------------------------------------------------
d212 3
d219 2
d238 2
d244 67
a310 1
! --------------------------------------------------------------------------
d334 2
d356 46
d412 3
@


2.24
log
@Fixed missing close quotes on include lines
@
text
@d22 1
a22 1
       "$Id: MLSNumerics.f90,v 2.23 2002/10/04 01:48:27 vsnyder Exp $"
d26 1
d241 4
d250 3
@


2.23
log
@Get rid of a local variable
@
text
@d22 1
a22 1
       "$Id: MLSNumerics.f90,v 2.22 2002/10/04 00:48:05 vsnyder Exp $"
d216 1
a216 1
    include "InterpolateScalar.f9h
d236 1
a236 1
    include "InterpolateScalar.f9h
d245 3
@


2.22
log
@Move declarations of local variables to includes.  Use generic
InterpolateValues in InterpolateScalar routines.  Move guts of
InterpolateScalar routines to an include file.
@
text
@d22 1
a22 1
       "$Id: MLSNumerics.f90,v 2.21 2002/09/13 18:08:12 pwagner Exp $"
d97 1
d100 2
a101 2
    real(r4), dimension(:), intent(in) :: list ! List to search
    real(r4), intent(in) :: value ! Value to search for
a109 1
    real(r4), dimension(1) :: values ! To pass to HuntArray
d112 1
a112 2
    values(1) = value
    call Hunt ( list, values, indices, start, &
d119 1
d122 2
a123 2
    real(r8), dimension(:), intent(in) :: list ! List to search
    real(r8), intent(in) :: value ! Value to search for
a131 1
    real(r8), dimension(1) :: values ! To pass to HuntArray
d134 1
a134 2
    values(1) = value
    call Hunt ( list, values, indices, start, &
d245 5
@


2.21
log
@May change matrix precision rm from r8
@
text
@d8 3
a13 2
  use MatrixModule_0, only: MatrixElement_T,CreateBlock_0,M_Column_Sparse,M_Absent,Sparsify
  use Allocate_Deallocate, only : Allocate_test, Deallocate_test
d22 1
a22 1
       "$Id: MLSNumerics.f90,v 2.20 2002/09/11 17:43:38 pwagner Exp $"
d59 1
a59 1
  subroutine HuntArray_r8 ( list, values, indices, start, allowTopValue, allowBelowValue, &
d61 1
d64 2
a65 2
    real(r8), dimension(:), intent(in) :: list ! List to search
    real(r8), dimension(:), intent(in) :: values ! Values to search for
a71 2
    ! Local variables
    real(r8) :: thisValue
d73 1
a73 1
  end subroutine HuntArray_r8
d75 1
a75 1
  subroutine HuntArray_r4 ( list, values, indices, start, allowTopValue, allowBelowValue, &
d77 1
d80 2
a81 2
    real(r4), dimension(:), intent(in) :: list ! List to search
    real(r4), dimension(:), intent(in) :: values ! Values to search for
a87 2
    ! Local variables
    real(r4) :: thisValue
d89 1
a89 1
  end subroutine HuntArray_r4
d95 1
a95 1
  subroutine HuntScalar_r8 (list, value, index, start, allowTopValue, &
d99 2
a100 2
    real(r8), dimension(:), intent(in) :: list ! List to search
    real(r8), intent(in) :: value ! Value to search for
d109 1
a109 1
    real(r8), dimension(1) :: values ! To pass to HuntArray
d113 1
a113 1
    call HuntArray_r8 ( list, values, indices, start, &
d116 1
a116 1
  end subroutine HuntScalar_r8
d118 1
a118 1
  subroutine HuntScalar_r4 (list, value, index, start, allowTopValue, &
d122 2
a123 2
    real(r4), dimension(:), intent(in) :: list ! List to search
    real(r4), intent(in) :: value ! Value to search for
d132 1
a132 1
    real(r4), dimension(1) :: values ! To pass to HuntArray
d136 1
a136 1
    call HuntArray_r4 ( list, values, indices, start, &
d139 1
a139 1
  end subroutine HuntScalar_r4
d156 1
a156 1
  subroutine InterpolateArray_r8 ( oldX, oldY, newX, newY, method, extrapolate, &
d158 1
d161 4
a164 4
    real(r8), dimension(:), intent(IN) :: oldX
    real(r8), dimension(:,:), intent(IN) :: oldY
    real(r8), dimension(:), intent(IN) :: newX
    real(r8), dimension(:,:), intent(OUT) :: newY
d168 1
a168 2
    real(r8), optional, intent(in) :: badvalue
    real(r8), dimension(:,:), optional, intent(out) :: dyByDx
d170 2
a171 27
    type (matrixElement_T), intent(OUT), optional :: dNewByDOld ! Derivatives

    ! Local variables
    real(r8), dimension(:),   pointer :: A
    real(r8), dimension(:,:), pointer :: AA
    real(r8), dimension(:),   pointer :: B
    real(r8), dimension(:,:), pointer :: BB
    real(r8), dimension(:),   pointer :: C
    real(r8), dimension(:,:), pointer :: CC
    real(r8), dimension(:),   pointer :: D ! Coefficients
    real(r8), dimension(:,:), pointer :: DD ! Spread coefs.
    real(r8), dimension(:),   pointer :: gap
    real(r8), dimension(:),   pointer :: gap2
    integer, dimension(:),    pointer :: lowerInds
    real(r8), dimension(:),   pointer :: maskVector
    real(r8), dimension(:,:), pointer :: oldSecond
    real(r8), dimension(:,:), pointer :: oldSecondLower
    real(r8), dimension(:,:), pointer :: oldSecondUpper
    real(r8), dimension(:,:), pointer :: oldYlower
    real(r8), dimension(:,:), pointer :: oldYupper
    real(r8), dimension(:),   pointer :: p ! For 2nd der. guess
    real(r8), dimension(:,:), pointer :: spreadGap
    real(r8), dimension(:,:), pointer :: temp ! For 2nd der. guess
    real(rm), dimension(:,:), pointer :: tempDNewByDOld ! Dense version.
    integer, dimension(:),    pointer :: upperInds
    real(r8) :: sig       ! For second derivative guesser
    real(r8) :: dyByDxFill              ! Fill value for dyByDx
d174 1
a174 1
end subroutine InterpolateArray_r8
d176 1
a176 1
  subroutine InterpolateArray_r4 ( oldX, oldY, newX, newY, method, extrapolate, &
d178 1
d181 4
a184 4
    real(r4), dimension(:), intent(IN) :: oldX
    real(r4), dimension(:,:), intent(IN) :: oldY
    real(r4), dimension(:), intent(IN) :: newX
    real(r4), dimension(:,:), intent(OUT) :: newY
d188 1
a188 2
    real(r4), optional, intent(in) :: badvalue
    real(r4), dimension(:,:), optional, intent(out) :: dyByDx
d190 1
a192 25
    ! Local variables
    real(r4), dimension(:),   pointer :: A
    real(r4), dimension(:,:), pointer :: AA
    real(r4), dimension(:),   pointer :: B
    real(r4), dimension(:,:), pointer :: BB
    real(r4), dimension(:),   pointer :: C
    real(r4), dimension(:,:), pointer :: CC
    real(r4), dimension(:),   pointer :: D ! Coefficients
    real(r4), dimension(:,:), pointer :: DD ! Spread coefs.
    real(r4), dimension(:),   pointer :: gap
    real(r4), dimension(:),   pointer :: gap2
    integer, dimension(:),    pointer :: lowerInds
    real(r4), dimension(:),   pointer :: maskVector
    real(r4), dimension(:,:), pointer :: oldSecond
    real(r4), dimension(:,:), pointer :: oldSecondLower
    real(r4), dimension(:,:), pointer :: oldSecondUpper
    real(r4), dimension(:,:), pointer :: oldYlower
    real(r4), dimension(:,:), pointer :: oldYupper
    real(r4), dimension(:),   pointer :: p ! For 2nd der. guess
    real(r4), dimension(:,:), pointer :: spreadGap
    real(r4), dimension(:,:), pointer :: temp ! For 2nd der. guess
    real(rm), dimension(:,:), pointer :: tempDNewByDOld ! Dense version.
    integer, dimension(:),    pointer :: upperInds
    real(r4) :: sig       ! For second derivative guesser
    real(r4) :: dyByDxFill              ! Fill value for dyByDx
d195 1
a195 1
end subroutine InterpolateArray_r4
d199 5
a203 1
! This subroutine is a scalar wrapper for the first one.
d205 19
a223 2
subroutine InterpolateScalar_r8 ( oldX, oldY, newX, newY, method, extrapolate, &
  & badValue, missingRegions, dyByDx, RangeOfPeriod )
d225 15
a239 138
  ! Dummy arguments
  real(r8), dimension(:), intent(in) :: oldX
  real(r8), dimension(:), intent(in) :: oldY
  real(r8), dimension(:), intent(in) :: newX
  real(r8), dimension(:), intent(out) :: newY

  character (len=*), intent(in) :: method ! See comments above
  character (len=*), optional, intent(in) :: extrapolate ! See comments above
  real(r8), optional, intent(in) :: badValue
  real(r8), dimension(:), optional, intent(out) :: dyByDx
  real(r8), dimension(2), optional, intent(in) :: rangeofperiod	  ! for periodic data
  logical, optional, intent(in) :: missingRegions ! Allow missing regions

! local working space
  real(r8), dimension(:,:), pointer :: tempDerivative
  real(r8), dimension(size(newX), 1) :: tempResult
  real(r8), dimension(size(oldY)) :: tempY
  real(r8) period
  integer jump, j

  ! Executable code

  tempY = oldY

  if ( present(rangeofperiod) ) then
	period  = rangeofPeriod(2)-rangeofPeriod(1)
	jump = -1
	do j =1, size(oldY)-1
		if(abs(tempY(j+1)-tempY(j)) > period/2. ) jump = j 
	enddo
	if(jump /= -1) then
	   if(tempY(jump+1) > tempY(jump)) then
		tempY(jump+1:) = tempY(jump+1:) - period
	   else 
		tempY(jump+1:) = tempY(jump+1:) + period
	   end if
	end if
  end if

  nullify ( tempDerivative )

  if ( present(dyByDx) ) then
    call Allocate_Test ( tempDerivative, size(newX), 1, &
      & "tempDerivative", ModuleName )

    call InterpolateArray_r8 ( oldX, spread(tempY,2,1), newX, tempResult, method, &
      & extrapolate=extrapolate, badValue=badValue, &
      & missingRegions=missingRegions, dyByDx=tempDerivative )
    dyByDx = tempDerivative(:,1)

    call Deallocate_Test ( tempDerivative, "tempDerivative", ModuleName )
  else
    call InterpolateArray_r8 ( oldX, spread(tempY,2,1), newX, tempResult, method, &
      & extrapolate=extrapolate, badValue=badValue, &
      & missingRegions=missingRegions )
  end if
  newY = tempResult(:,1)

  if ( present(rangeofperiod) ) then
	period  = rangeofPeriod(2)-rangeofPeriod(1)
	where (newY > rangeofperiod(2)) 
	  newY = newY - period
	elsewhere (newY < rangeofperiod(1)) 
	  newY = newY + period
	end where
  end if
end subroutine InterpolateScalar_r8

subroutine InterpolateScalar_r4 ( oldX, oldY, newX, newY, method, extrapolate, &
  & badValue, missingRegions, dyByDx, RangeOfPeriod )

  ! Dummy arguments
  real(r4), dimension(:), intent(in) :: oldX
  real(r4), dimension(:), intent(in) :: oldY
  real(r4), dimension(:), intent(in) :: newX
  real(r4), dimension(:), intent(out) :: newY

  character (len=*), intent(in) :: method ! See comments above
  character (len=*), optional, intent(in) :: extrapolate ! See comments above
  real(r4), optional, intent(in) :: badValue
  real(r4), dimension(:), optional, intent(out) :: dyByDx
  real(r4), dimension(2), optional, intent(in) :: rangeofperiod	  ! for periodic data
  logical, optional, intent(in) :: missingRegions ! Allow missing regions

! local working space
  real(r4), dimension(:,:), pointer :: tempDerivative
  real(r4), dimension(size(newX), 1) :: tempResult
  real(r4), dimension(size(oldY)) :: tempY
  real(r4) period
  integer jump, j

  ! Executable code

  tempY = oldY

  if ( present(rangeofperiod) ) then
	period  = rangeofPeriod(2)-rangeofPeriod(1)
	jump = -1
	do j =1, size(oldY)-1
		if(abs(tempY(j+1)-tempY(j)) > period/2. ) jump = j 
	enddo
	if(jump /= -1) then
	   if(tempY(jump+1) > tempY(jump)) then
		tempY(jump+1:) = tempY(jump+1:) - period
	   else 
		tempY(jump+1:) = tempY(jump+1:) + period
	   end if
	end if
  end if

  nullify ( tempDerivative )

  if ( present(dyByDx) ) then
    call Allocate_Test ( tempDerivative, size(newX), 1, &
      & "tempDerivative", ModuleName )

    call InterpolateArray_r4 ( oldX, spread(tempY,2,1), newX, tempResult, method, &
      & extrapolate=extrapolate, badValue=badValue, &
      & missingRegions=missingRegions, dyByDx=tempDerivative )
    dyByDx = tempDerivative(:,1)

    call Deallocate_Test ( tempDerivative, "tempDerivative", ModuleName )
  else
    call InterpolateArray_r4 ( oldX, spread(tempY,2,1), newX, tempResult, method, &
      & extrapolate=extrapolate, badValue=badValue, &
      & missingRegions=missingRegions )
  end if
  newY = tempResult(:,1)

  if ( present(rangeofperiod) ) then
	period  = rangeofPeriod(2)-rangeofPeriod(1)
	where (newY > rangeofperiod(2)) 
	  newY = newY - period
	elsewhere (newY < rangeofperiod(1)) 
	  newY = newY + period
	end where
  end if
end subroutine InterpolateScalar_r4
d247 3
@


2.20
log
@Began changes needed to conform with matrix%values type move to rm from r8
@
text
@d8 1
a8 1
  use MLSCommon, only : r8, rm
d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.19 2002/05/24 17:00:55 livesey Exp $"
d42 2
a43 2
    module procedure HuntArray
    module procedure HuntScalar
d47 2
a48 2
    module procedure InterpolateArray
    module procedure InterpolateScalar
d58 1
a58 1
  subroutine HuntArray ( list, values, indices, start, allowTopValue, allowBelowValue, &
a70 18
    integer :: listLen, valuesLen       ! Array sizes
    integer :: valueIndex               ! Loop counters
    integer :: index                    ! Temporary result
    integer :: alternativeIndex         ! Used in 'nearest' case
    integer :: originalIndex            ! Used in 'nearest' case

    logical :: useAllowTopValue, useAllowBelowValue, useNearest
    integer :: useStart
    integer :: upperLimit       ! Highest value that can be returned
    integer :: stride           ! Value to step by
    logical :: expanding        ! Whether we're expanding or reducing our search
    logical :: lowerBelow       ! Flag
    logical :: upperAbove       ! Another flag

    integer :: listDirection    ! +1 if list ascends, -1 descends
    integer :: searchDirection  ! (in index space) 
    integer :: oldSearchDirection ! Previous value of above

d72 2
d75 2
a76 1
    ! Executable code
d78 13
a90 147
    if ( present(allowTopValue) ) then
      useAllowTopValue = allowTopValue
    else
      useAllowTopValue = .false.
    end if

    if ( present(allowBelowValue) ) then
      useAllowBelowValue = allowBelowValue
    else
      useAllowBelowValue = .false.
    end if

    if ( present(nearest) ) then
      useNearest = nearest
    else
      useNearest = .false.
    end if

    if ( present(start) ) then
      useStart = start
    else
      useStart = 1
    end if

    if ( useNearest .and. useAllowBelowValue ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Can't set nearest and allowBelowValue in Hunt" )

    listLen = size(list)
    valuesLen = size(values)
    if ( size(indices) < valuesLen ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Result array is too small" )

    ! Try to work out the direction, also skip if there's only one value

    if ( size(list) == 1 ) then
      indices = 1
      if ( useAllowBelowValue ) then
        where ( values < list(1) )
          indices = 0
        end where
      end if
      return
    else
      if ( list(size(list)) >= list(1) ) then
        listDirection = 1
      else
        listDirection = -1
      end if
    end if

    ! Some last bits of setup before we get going.

    if ( useAllowTopValue ) then
      upperLimit = listLen
    else
      upperLimit = listLen-1
    end if

    ! Now we're ready to hit the road, loop over all the values to hunt for

    index = max(1,min(useStart,upperLimit))
    do valueIndex = 1, valuesLen
      thisValue = values(valueIndex)
      expanding = .true.
      searchDirection = 0
      stride = 1
      HuntLoop: do
        lowerBelow= (thisValue-list(index))*listDirection >= 0.0
        if ( index<listLen ) then 
          upperAbove = (list(index+1)-thisValue)*listDirection > 0.0
        else ! We're off the end of the list
          upperAbove = .true.   
        end if

        ! Now we know what the state of play is, what does it mean?

        ! First see if we've found the place
        if ( lowerBelow.and.upperAbove ) exit HuntLoop

        ! The other cases are a little more complex
        oldSearchDirection = searchDirection

        if ( lowerBelow.and. (.not. upperAbove) ) then
          ! If we're at the end, get out
          if ( index == upperLimit ) exit HuntLoop
          ! We're too low, keep looking upwards
          index = index+stride
          searchDirection = 1
        end if

        if ( (.not. lowerBelow).and.upperAbove ) then
          ! If we're at the begning, get out
          if ( index == 1 ) exit HuntLoop

          ! We're too high but not at begining, look back downwards
          index = index-stride
          searchDirection = -1
        end if

        ! Now the very first change of direction is the end of hte
        ! `expanding' phase

        if ( (searchDirection /= oldSearchDirection) .and. &
          & (oldSearchDirection /= 0) .and. (expanding) ) &
          & expanding = .false.

        if ( expanding ) then
          stride = min(stride*2,listLen/2)
        else
          stride = max(stride/2,1)
        end if

        ! Make sure we don't fall off an end

        index = min(max(index,1),upperLimit)
      end do HuntLoop

      ! If user asked for nearest then check to see if one above is closer
      originalIndex = index
      if ( useNearest ) then
        alternativeIndex = index
        ! Look for the next higher value
        nearestLoop: do
          if ( alternativeIndex >= upperLimit ) exit nearestLoop
          alternativeIndex = alternativeIndex + 1
          if ( list(alternativeIndex) > list(index) ) exit nearestLoop
        end do nearestLoop
        ! If this is higher, use it
        if ( abs ( list(alternativeIndex) - thisValue ) < &
          &  abs ( list(index) - thisValue ) ) then
          index = alternativeIndex
        end if
      end if

      ! Final check for off the bottom of the list

      if ( useAllowBelowValue ) then
        if ( (thisValue-list(index))*listDirection<0.0D0) index = 0
      end if

      indices(valueIndex) = index

      ! In the 'nearest' case it might make sense to check from the
      ! originalIndex
      index = originalIndex
    end do
  end subroutine HuntArray
d96 1
a96 1
  subroutine HuntScalar (list, value, index, start, allowTopValue, &
d114 1
a114 1
    call HuntArray ( list, values, indices, start, &
d117 24
a140 1
  end subroutine HuntScalar
d157 1
a157 1
  subroutine InterpolateArray ( oldX, oldY, newX, newY, method, extrapolate, &
a173 6
    integer :: noOld, noNew, width ! Dimensions
    logical :: spline              ! Flag
    logical :: useMissingRegions   ! Copy of missing regions
    integer :: ind, newInd         ! Loop counters
    logical :: computeDNewByDOld   ! Set if dNewByDOld is present

d198 1
d200 1
a200 1
    character :: extrapolateMethod ! Tidy copy of extrapolate parameter
d202 2
a203 1
    ! Executable code
d205 5
a209 169
    nullify ( a, aa, b, bb, c, cc, d, dd, gap, gap2, lowerInds, maskVector, &
      &       oldSecond, oldSecondLower, oldSecondUpper, oldYlower, oldYupper, p, &
      &       spreadGap, temp, tempDNewByDOld, upperInds )

    ! Size the problem, check sanity, set up arrays etc.

    noOld=size(oldX,1)
    noNew=size(newX,1)
    width=size(oldY,2)

    spline=(Capitalize(method(1:1))=="S")

    extrapolateMethod="A"
    if ( present(extrapolate)) extrapolateMethod=Capitalize(extrapolate(1:1))

    useMissingRegions=.false.
    if ( present(missingRegions)) useMissingRegions=missingRegions

    computeDNewByDOld=present(dNewByDOld)

    if ( useMissingRegions.and.spline ) call MLSMessage &
      & ( MLSMSG_Error, ModuleName, "Cannot use missing regions with spline")

    if ( computeDNewByDOld .and. spline ) call MLSMessage &
      & ( MLSMSG_Error, ModuleName, "Cannot get dNewBydOld from spline")

    ! Special case where only one input point
    if ( noOld == 1 ) then
      ! If extrapolating allowed or clamped, out values same as in
      if ( extrapolateMethod=="A" .or. extrapolateMethod=="C" ) then
        do ind = 1, noNew
          newY(ind,:) =oldY(1,:)
        end do
        ! Note these next two aren't totally gracefull with respect to 
        ! the missingRegions flag.
        if ( present(dyByDx) ) dyByDx = 0.0
      else
        ! Else extrapolation forbidden
        do ind = 1, noNew
          if ( newX(ind) == oldX(1) ) then
            newY(ind,:) = oldY(1,:)
            if ( present(dyByDx) ) dyByDx = 0.0
          else
            newY(ind,:) = badValue
            if ( present(dyByDx) ) dyByDx = badValue
          end if
        end do
      end if
      if ( computeDNewByDOld ) call CreateBlock_0 ( dNewByDOld, &
        & noNew*width, noOld*width, M_Absent )
      return
    end if

    call Allocate_Test ( lowerInds, noNew, "lowerInds", ModuleName )
    call Allocate_Test ( upperInds, noNew, "upperInds", ModuleName )
    call Allocate_Test ( gap, noNew, "gap", ModuleName )
    call Allocate_Test ( A, noNew, "A", ModuleName )
    call Allocate_Test ( B, noNew, "B", ModuleName )
    call Allocate_Test ( AA, noNew, width, "AA", ModuleName )
    call Allocate_Test ( BB, noNew, width, "BB", ModuleName )
    call Allocate_Test ( oldYlower, noNew, width, "oldYlower", ModuleName )
    call Allocate_Test ( oldYupper, noNew, width, "oldYupper", ModuleName )

    ! Setup arrays needed if dyByDx is requested

    if ( present(dyByDx)) call Allocate_Test(spreadGap,noNew,width,&
      "spreadGap",ModuleName)

    ! Setup Matrix block needed if DNewByDOld is needed.
    if ( computeDNewByDOld ) then
      call CreateBlock_0 ( dNewByDOld, noNew*width, noOld*width, &
        M_Column_Sparse, NumberNonZero=2*noNew*width )
    end if

    ! Do special stuff for the case of spline, allocate arrays, find 2nd
    ! derivatives etc.

    if ( spline ) then
      call Allocate_Test ( oldSecond, noOld, width, "oldSecond", ModuleName )
      call Allocate_Test ( C, noNew, "C", ModuleName )
      call Allocate_Test ( D, noNew, "D", ModuleName )
      call Allocate_Test ( CC, noNew, width, "CC", ModuleName )
      call Allocate_Test ( DD, noNew, width, "DD", ModuleName )
      call Allocate_Test ( oldSecondlower, noNew, width, "oldSecondlower", ModuleName )
      call Allocate_Test ( oldSecondupper, noNew, width, "oldSecondupper", ModuleName )
      call Allocate_Test ( gap2, noNew, "gap2", ModuleName )
      call Allocate_Test ( temp, noOld, width, "temp", ModuleName )
      call Allocate_Test ( p, width, "p", ModuleName )

      ! Here we have to solve the a tridiagonal equation
      ! This is a straight copy of my idl code
      oldSecond(1,:) = 0.0
      temp(1,:) = 0.0
      do ind = 2, noOld-1
        sig = (oldX(ind)-oldX(ind-1))/(oldX(ind+1)-oldX(ind-1))
        p = sig*oldSecond(ind-1,:)+2.0
        oldSecond(ind,:) = (sig-1.0)/p
        temp(ind,:) = (oldY(ind+1,:)-oldY(ind,:))/(oldX(ind+1)-oldX(ind)) - &
          & (oldY(ind,:)-oldY(ind-1,:))/(oldX(ind)-oldX(ind-1))
        temp(ind,:) = (6.0*temp(ind,:)/ &
          & (oldX(ind+1)-oldX(ind-1))-sig*temp(ind-1,:))/p
      end do
      oldSecond(noOld,:) = 0.0

      ! Now do the back substitution
      do ind = noOld-1, 1, -1
        oldSecond(ind,:) = oldSecond(ind,:)*oldSecond(ind+1,:)+temp(ind,:)
      end do

      call Deallocate_test ( temp, "Temp", ModuleName ) 
      call Deallocate_test ( p, "p", ModuleName )
    end if

    ! Now we're ready to begin the real work.

    ! Clear the result array(s)
    newY = 0.0
    if ( present(dyByDx) ) dyByDx = 0.0

    ! Now hunt for the indices

    call Hunt ( oldX, newX, lowerInds )
    upperInds = lowerInds+1
    gap = oldX(upperInds)-oldX(lowerInds)
    if ( present(dyByDx) ) spreadGap = spread(gap,2,width)

    A = (oldX(upperInds)-newX)/gap

    ! If extrapolate is "C"onstant, deal with that
    if ( extrapolateMethod=="C" ) A = max(min(A,1.0_r8),0.0_r8)

    B=1.0_r8-A

    ! If extrapolate mode is "B"ad, deal with that
    if ( extrapolateMethod=="B" ) then
      call Allocate_Test ( maskVector, noNew, "maskVector", ModuleName )
      maskVector = 0.0
      where ( (A<0.0) .or. (A>1.0) )
        maskVector = badValue
        A = 0.0
        B = 0.0
      end where
      newY = spread(maskVector,2,width)
      if ( present(dyByDx) ) dyByDx = newY
      call Deallocate_Test ( maskVector, "maskVector", ModuleName )
    end if

    ! Now spread out the coefficients
    AA = spread(A,2,width)
    BB = spread(B,2,width)
    oldYlower = oldY(lowerInds,:)
    oldYupper = oldY(upperInds,:)

    ! Now worry about the missing regions flag
    if ( useMissingRegions ) then
      where( (oldYlower==badValue) .or. (oldYupper==badValue))
        newY = badValue
        AA = 0.0
        BB = 0.0
      end where
      if ( present(dyByDx) ) then
        where( (oldYlower==badValue) .or. &
          & (oldYupper==badValue) )
        dyByDx = badValue
        oldYlower = 0.0      ! Only way to guarentee bad derivative
        oldYupper = 0.0      ! But don't need to worry about spline
      end where
    end if
  end if
d211 6
a216 21
  ! Now do the linear interpolation calculation
  newY = newY+AA*oldYlower+BB*oldYupper
  if ( present(dyByDx) ) dyByDx = (oldYupper-oldYlower)/spreadGap

  ! Write the output derivative matrix if needed
  if ( computeDNewByDOld ) then
    ! While the matrix is ideally suited to row sparse, our storage method
    ! is column sparse, so to be lazy we'll create it full and then sparsify
    ! it.

    call Allocate_Test ( tempDNewByDOld, noNew*width, noOld*width, &
      & "tempDNewByDOld", ModuleName )
    do newInd = 1, noNew
      do ind = 1, width
        tempDNewByDOld(newInd+ind*noNew,lowerInds(newInd)+ind*noOld) = A(newInd)
        tempDNewByDOld(newInd+ind*noNew,upperInds(newInd)+ind*noOld) = B(newInd)
      end do
    end do
    call Sparsify ( tempDNewByDOld, dNewbyDOld, &
      & "tempDNewByDOld", ModuleName ) ! dNewbyDOld := tempDNewByDOld
  end if
d218 26
a243 57
  ! Now do the spline calculation
  if ( spline ) then
    gap2 = gap**2
    C = (A**3-A)*gap2/6.0    ! Note the extrapolate bad case is covered as..
    D = (B**3-B)*gap2/6.0    !   A=B=0.0

    ! Spread out the coefficients etc.
    CC = spread(C,2,width)
    DD = spread(D,2,width)
    oldSecondLower = oldSecond(lowerInds,:)
    oldSecondUpper = oldSecond(upperInds,:)

    newY = newY+CC*oldSecondLower+DD*oldSecondUpper
    if ( present(dyByDx)) dyByDx=dyByDx+(spreadGap/6.0)*( &
      & (3.0*BB**2-1.0)*oldSecondUpper- &
      & (3.0*AA**2-1.0)*oldSecondLower)
  end if

  ! Now make sure the dyByDX's are correct for extrapolated regions
  if ( present ( dyByDx ) .and. scan(extrapolateMethod(1:1),"BC") > 0) then
    select case ( extrapolateMethod(1:1) )
    case ( "C" )
      dyByDxFill = 0.0
    case ( "B" )
      dyByDxFill = badValue
    end select
    do ind = 1, noNew
      if ( ( newX(ind) >= oldX(noOld) ) .or. ( newX(ind) < oldX(1) ) ) &
        & dyByDx ( ind, : ) = dyByDXFill
    end do
  end if

  ! Tidy up
  call Deallocate_Test ( lowerInds, "lowerInds", ModuleName )
  call Deallocate_Test ( upperInds, "upperInds", ModuleName )
  call Deallocate_Test ( gap, "gap", ModuleName )
  call Deallocate_Test ( A, "A", ModuleName )
  call Deallocate_Test ( B, "B", ModuleName )
  call Deallocate_Test ( AA, "AA", ModuleName )
  call Deallocate_Test ( BB, "BB", ModuleName )
  call Deallocate_Test ( oldYlower, "oldYlower", ModuleName )
  call Deallocate_Test ( oldYupper, "oldYupper", ModuleName )

  if ( spline ) then
    call Deallocate_Test( oldSecond, "oldSecond", ModuleName )
    call Deallocate_Test( C, "C", ModuleName )
    call Deallocate_Test( D, "D", ModuleName )
    call Deallocate_Test( CC, "CC", ModuleName )
    call Deallocate_Test( DD, "DD", ModuleName )
    call Deallocate_Test( oldSecondlower, "oldSecondlower", ModuleName )
    call Deallocate_Test( oldSecondupper, "oldSecondupper", ModuleName )
    call Deallocate_Test( gap2, "gap2", ModuleName )
    call Deallocate_Test( temp, "temp", ModuleName )
    call Deallocate_Test( p, "p", ModuleName )
  end if
  if ( present(dyByDx) ) &
    & call Deallocate_Test ( spreadGap, "spreadGap", ModuleName )
d245 1
a245 1
end subroutine InterpolateArray
d251 1
a251 1
subroutine InterpolateScalar ( oldX, oldY, newX, newY, method, extrapolate, &
d299 72
a370 1
    call InterpolateArray ( oldX, spread(tempY,2,1), newX, tempResult, method, &
d377 1
a377 1
    call InterpolateArray ( oldX, spread(tempY,2,1), newX, tempResult, method, &
d391 1
a391 1
end subroutine InterpolateScalar
d399 3
@


2.19
log
@Fixed bug with interpolation with only one oldX value
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d8 1
a8 1
  use MLSCommon, only : r8
d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.18 2001/12/01 01:03:07 livesey Exp $"
d326 1
a326 1
    real(r8), dimension(:,:), pointer :: tempDNewByDOld ! Dense version.
d668 3
@


2.18
log
@Bug fix with derivatives.
@
text
@d11 1
a11 1
  use MatrixModule_0, only: MatrixElement_T,CreateBlock_0,M_Column_Sparse, Sparsify
d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.17 2001/11/14 01:47:40 livesey Exp $"
d361 27
d668 3
@


2.17
log
@Added nearest option to Hunt
@
text
@d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.16 2001/10/19 23:41:43 livesey Exp $"
d519 2
a520 2
  if ( present ( dyByDx ) ) then
    select case ( extrapolateMethod )
d641 3
@


2.16
log
@Fixed bug with dyByDx extrapolation
@
text
@d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.15 2001/09/24 17:27:50 pwagner Exp $"
d58 2
a59 1
  subroutine HuntArray ( list, values, indices, start, allowTopValue, allowBelowValue )
d68 1
d71 5
a75 3
    integer :: listLen, valuesLen ! Array sizes
    integer :: valueIndex       ! Loop counters
    integer :: index            ! Temporary result
d77 1
a77 1
    logical :: useAllowTopValue, useAllowBelowValue
d105 6
d117 3
d210 17
d234 4
d245 2
a246 1
  subroutine HuntScalar (list, value, index, start, allowTopValue, allowBelowValue )
d255 1
d263 2
a264 1
    call HuntArray ( list, values, indices, start, allowTopValue, allowBelowValue )
d641 3
@


2.15
log
@Removed random number things
@
text
@d8 1
a8 1
  use MLSCommon, only : R8
d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.14 2001/09/20 20:54:55 pwagner Exp $"
d223 1
a223 1
    real(R8), dimension(1) :: values ! To pass to HuntArray
d250 4
a253 4
    real(R8), dimension(:), intent(IN) :: oldX
    real(R8), dimension(:,:), intent(IN) :: oldY
    real(R8), dimension(:), intent(IN) :: newX
    real(R8), dimension(:,:), intent(OUT) :: newY
d269 10
a278 10
    real(R8), dimension(:),   pointer :: A
    real(R8), dimension(:,:), pointer :: AA
    real(R8), dimension(:),   pointer :: B
    real(R8), dimension(:,:), pointer :: BB
    real(R8), dimension(:),   pointer :: C
    real(R8), dimension(:,:), pointer :: CC
    real(R8), dimension(:),   pointer :: D ! Coefficients
    real(R8), dimension(:,:), pointer :: DD ! Spread coefs.
    real(R8), dimension(:),   pointer :: gap
    real(R8), dimension(:),   pointer :: gap2
d280 10
a289 10
    real(R8), dimension(:),   pointer :: maskVector
    real(R8), dimension(:,:), pointer :: oldSecond
    real(R8), dimension(:,:), pointer :: oldSecondLower
    real(R8), dimension(:,:), pointer :: oldSecondUpper
    real(R8), dimension(:,:), pointer :: oldYlower
    real(R8), dimension(:,:), pointer :: oldYupper
    real(R8), dimension(:),   pointer :: p ! For 2nd der. guess
    real(R8), dimension(:,:), pointer :: spreadGap
    real(R8), dimension(:,:), pointer :: temp ! For 2nd der. guess
    real(R8), dimension(:,:), pointer :: tempDNewByDOld ! Dense version.
d291 2
a292 1
    real(R8) :: sig       ! For second derivative guesser
d436 1
a436 1
        oldYupper  =0.0      ! But don't need to worry about spline
d481 15
d604 3
@


2.14
log
@Added random number stuff from MATH77
@
text
@d17 1
a17 1
  public :: Hunt, InterpolateValues, srang, drang
d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.13 2001/07/10 17:55:23 livesey Exp $"
a38 2
! drang                        Returns a gauss. dis. dbl.pr. num. 0 mean, 1 s.d.
! srang                        Returns a gauss. dis. sngl..pr. num. 0 mean, 1 s.d.
a581 968
!------------------------------------------------------------------
!   Random number routines from MATH77 libraries
! ../l2:69% ls *.f
!  drang.f  ranpk1.f  ranpk2.f  srang.f
!  ../l2:71% cat *.f > stuff.sed
!  ../l2:72% sed 's/^[Cc]/\!/' stuff.sed > sed.out
! plus a small amount of subsequent editing
!------------------------------------------------------------------
      double precision function  DRANG ()
!     .  Copyright (C) 1989, California Institute of Technology.
!     .  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.
!>> 1996-04-16 DRANG WVS SQRT(abs(TWO*log(U3))) avoids sqrt(-0.0)
!>> 1994-10-20 DRANG Krogh  Changes to use M77CON
!>> 1994-06-24 DRANG CLL Changed common to use RANC[D/S]1 & RANC[D/S]2.
!>> 1992-03-16 DRANG CLL
!>> 1991-11-26 DRANG CLL Reorganized common. Using RANCM[A/D/S].
!>> 1991-11-22 DRANG CLL Added call to RAN0, and DGFLAG in common.
!>> 1991-01-15 DRANG CLL Reordered common contents for efficiency.
!>> 1990-01-23 DRANG CLL Making names in common same in all subprogams.
!>> 1987-06-09 DRANG CLLawson  Initial code.
!
!     Returns one pseudorandom number from the Gausian (Normal)
!     distribution with zero mean and unit standard deviation.
!     Method taken from Algorithm 334, Comm. ACM, July 1968, p. 498.
!     Implemented at JPL in Univac Fortran V in 1969 by Wiley R. Bunton
!     of JPL and Stephen L. Richie of Heliodyne Corp.
!
!     Adapted to Fortran 77 for the MATH 77 library by C. L. Lawson and
!     S. Y. Chiu, JPL, April 1987, 6/9/87.
!     ------------------------------------------------------------------
!--D replaces "?": ?RANG, ?RANUA, RANC?1, RANC?2, ?PTR, ?NUMS, ?GFLAG
!     RANCD1 and RANCD2 are common blocks.
!     Uses intrinsic functions, log and sqrt.
!     Calls DRANUA to obtain an array of uniform random numbers.
!     Calls RAN0 to initialize DPTR and DGFLAG.
!     ------------------------------------------------------------------
!                        Important common variables
!
!     DPTR [integer] and DGFLAG [logical]
!
!          Will be set to DPTR = 1 and DGFLAG = .false.
!          when RAN0 is called from this subr if this
!          is the first call to RAN0.  Also set to these values when
!          RAN1 or RANPUT is called by a user.
!
!          DGFLAG will be set true on return from this subr when the
!          algorithm has values that it can save to reduce the amount
!          of computation needed the next time this function is
!          referenced.  Will be set false in the contrary case.
!
!          DPTR is the index of the last location used in the
!          common array DNUMS().  This index is counted down.
!
!     DNUMS() [floating point]  Buffer of previously computed uniform
!          random numbers.
!     ------------------------------------------------------------------
      integer M
      parameter(M = 97)
      double precision    ONE, TWO
      parameter(ONE = 1.0D0, TWO = 2.0D0)
      double precision    DNUMS(M), R, S, U3, X, XX, Y, YY
      logical FIRST
      common/RANCD2/DNUMS
      integer DPTR
      logical DGFLAG
      common/RANCD1/DPTR, DGFLAG
      save  /RANCD1/, /RANCD2/, FIRST
      save    R, X, Y
      data  FIRST/.true./
!     ------------------------------------------------------------------
      if(FIRST) then
         FIRST = .false.
         call RAN0
      endif
!
      if (.not. DGFLAG .or. DPTR .eq. 1) then
!
!     Use the Von Neuman rejection method for choosing a random point
!     (X,Y) in the unit circle, X**2 + Y**2 .le. 1.0.
!     Then the angle Theta = arctan(Y/X) is random, uniform in
!     (-Pi/2, Pi/2), and Phi = 2*Theta is random, uniform in (-Pi, Pi).
!     Define S = X**2 + Y**2, then
!     sin(Theta) = Y/sqrt(S),    cos(Theta) = X/sqrt(S),
!     sin(Phi) = 2*X*Y/S,    and cos(Phi) = (X**2 - Y**2)/S.
!
   10    continue
!                              Set X = random, uniform in [0., 1.]
      DPTR = DPTR - 1
      if(DPTR .eq. 0) then
         call DRANUA(DNUMS, M)
         DPTR = M
      endif
            X = DNUMS(DPTR)
!                              Set Y = random, uniform in [-1., 1.]
            DPTR = DPTR - 1
            if(DPTR .eq. 0) then
               call DRANUA(DNUMS,M)
               DPTR = M
            endif
            Y = TWO*DNUMS(DPTR) - ONE
!
            XX=X*X
            YY=Y*Y
            S=XX+YY
         if(S .gt. ONE) go to 10
!
!     Choose R randomly from Chi-squared distribution and
!     normalize with S.
!
!                              Set U3 = random, uniform in [0., 1.]
         DPTR = DPTR - 1
         if(DPTR .eq. 0) then
            call DRANUA(DNUMS,M)
            DPTR = M
         endif
         U3 = DNUMS(DPTR)
!        Changed -TWO*log(U3) to abs(TWO*log(U3)) because Lahey LF90
!        2.00 on a pentium produced -0.0 for -TWO*log(1.0), then got a
!        floating point exception on sqrt(-0.0).
         R = sqrt(abs(TWO*(log(U3))))/S
!
!                                Compute result as  R*Sin(PHI)
!
         DRANG = (XX-YY)*R
         DGFLAG = .true.
         return
      endif
!     -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!        Come here when DGFLAG is true and DPTR is not 1.
!
!                                Compute result as  R*Cos(PHI)
      DRANG = TWO*X*Y*R
      DGFLAG=.false.
      return
      end function  DRANG
      subroutine RAN1
!     .  Copyright (C) 1989, California Institute of Technology.
!     .  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.
!                            Program unit: RANPK1
!>> 1995-11-21 RAMPK1 Krogh Removed multiple entries.
!>> 1994-06-24 CLL Reorganized common. Using RANC[D/S]1 & RANC[D/S]2.
!>> 1992-03-13 CLL Fixed error in RAN0
!>> 1991-11-26 CLL Reorganized common. Using RANCM[A/D/S].
!>> 1991-11-22 CLL Added Entry RAN0 and common variables SGFLAG,DGFLAG
!>> 1991-01-15 CLL Reordered common contents for efficiency.
!>> 1990-01-23 CLL Corrected type stmt for SNUMS in common.
!>> 1987-04-22 RANPK1 Lawson  Initial code.
!
!        This program unit, RANPK1, along with RANPK2,
!     supports random number generation.
!
!        This prog unit has entries RAN1, RAN0, and RANPUT.
!     The library user can call RAN1 to initialize random number
!     generation at a standard initial seed,
!     or call RANPUT(KSEED) to initialize random number generation
!     at a seed value provided by the integer array, KSEED().
!
!     Other higher level random number subrs call RAN0 on their first
!     time flags to be sure the package is initialized.
!
!     As a result of any of these entries this subroutine will
!     set the pointers in the COMMON arrays to 1, indicating to higher
!     level random number subprograms that these buffer arrays are
!     empty.  It also sets SGFLAG and DGFLAG to .false. to indicate to
!     Gaussian generators that they have no internal saved value.
!
!     The user can determine the appropriate dimension for the array,
!     KSEED() by first calling the entry RANSIZ in prog unit RANPK2.
!
!     The user can retrieve the current seed value by calling entry,
!     RANGET in prog unit RANPK2.  This will be the seed that will be
!     used the next time a batch of random numbers are computed.  This
!     is not necessarily the seed associated with the next number that
!     will be returned.
!     C. L. Lawson, F. T. Krogh, & S. Y. Chiu, JPL, Apr 1987.
!     ------------------------------------------------------------------
!
      integer DPTR, SPTR
      logical DGFLAG, SGFLAG
      common/RANCD1/DPTR, DGFLAG
      common/RANCS1/SPTR, SGFLAG
      save  /RANCD1/, /RANCS1/
!     ------------------------------------------------------------------
!                      For use by library users: CALL RAN1
      call RN1
      DPTR = 1
      SPTR = 1
      DGFLAG = .false.
      SGFLAG = .false.
      return
      end subroutine RAN1
!     ------------------------------------------------------------------
!                      For use by other library subprograms: CALL RAN0
      subroutine RAN0
      integer DPTR, SPTR
      logical DGFLAG, SGFLAG
      common/RANCD1/DPTR, DGFLAG
      common/RANCS1/SPTR, SGFLAG
      save  /RANCD1/, /RANCS1/
      logical FIRST
      save FIRST
      data FIRST / .true. /
!
      if(FIRST) then
         FIRST = .false.
         DPTR = 1
         SPTR = 1
         DGFLAG = .false.
         SGFLAG = .false.
      end if
      return
      end subroutine RAN0
!     ------------------------------------------------------------------
!                         For use by library users: CALL RANPUT(KSEED)
      subroutine RANPUT(KSEED)
      integer KSEED(*)
      integer DPTR, SPTR
      logical DGFLAG, SGFLAG
      common/RANCD1/DPTR, DGFLAG
      common/RANCS1/SPTR, SGFLAG
      save  /RANCD1/, /RANCS1/
!
      call   RNPUT(KSEED)
      DPTR = 1
      SPTR = 1
      DGFLAG = .false.
      SGFLAG = .false.
      return
      end subroutine RANPUT
      subroutine RN1
!     .  Copyright (C) 1989, California Institute of Technology.
!     .  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.
!>> 1997-12-17 RANPK2 Krogh Removed unreferenced labels
!>> 1995-11-22 RANPK2 Krogh Removed multiple entries.
!>> 1992-03-17 CLL Moved SAVE stmt ahead of DATA stmts.
!>> 1992-03-09 CLL Removed "save FIRST" because FIRST is not used.
!>> 1992-03-02 CLL Fix error: Set MODE = 1 in data stmt.
!>> 1991-11-21 CLL Add MODE with values 1, 2, 3, & 4.
!>> 1989-09-11 CLL Multiversion file. RANPK2 or RANPK3
!>> 1987-05-05 RANPK2 Lawson  Initial code.
!
!        This program unit, along with RANPK1, supports random number
!     generation.
!
!     The functionality of this random number package was modeled on the
!     specifications of the random number routines RANDOM and RANDOMSEED
!     in the February, 1987 working draft of the Fortran 8x language
!     standard.  This functionality remains similar to the later draft,
!     Fortran 90, S8.115, June 1990, in which the routine names have
!     been changed to RANDOM_MUMBER and RANDOM_SEED.  This should
!     facilitate replacement of use of this package by Fortran intrinsic
!     when and if Fortran 90 compilers come into widespread use.
!
!     The library user may call RANSIZ or RANGET in this prog unit,
!     or RAN1 or RANPUT in RANPK1 to obtain the functionality of
!     RANDOM_SEED of Fortran 90.  This relates to setting or fetching
!     the seed.
!        Entries RN1 and RNPUT in this prog unit should not be called by
!     library users.  They are intended only to be called from RANPK1.
!        Entry RN2 returns the value of MODE.  This is a convenience in
!     case one is interested in knowing the value of MODE the package
!     has selected.
!        Entries SRANUA and DRANUA (s.p. and d.p. respectively)
!     generate arrays of pseudorandom numbers from the uniform
!     distribution in the range [0., 1.].  These may be called by users
!     and are called by other library routines.
!        Entries SRANUS and DRANUA (s.p. and d.p. respectively)
!     generate arrays of pseudorandom numbers from the uniform
!     distribution in the range [0., 1.] and then transformed to
!     A + B*U.  These are intended for direct use by users.
!     ------------------------------------------------------------------
!              Algorithm for generating pseudorandom numbers
!                     from the uniform distribution.
!
!  The current integer value in the random integer sequence is XCUR,
!  and the next is defined mathematically by the statement:
!
!                 XCUR = mod(AFAC * XCUR,  MDIV)
!  where
!                 MDIV = m = 6_87194_76503 = 2**36 - 233
!  and
!                 AFAC = a = 612_662 = (approx.) 0.58 * 2**20
!
!  XCUR may be any integer value in the range from 1 to m-1, and all
!  integer values in this range will be generated before the sequence
!  cycles.
!
!  We call the above computational algorithm for XCUR the "short"
!  algorithm.  There is also a "long" algorithm that produces exactly
!  the same sequence of values of XCUR:
!                  Q = aint(XCUR/B)
!                  R = XCUR - Q * B
!                  XCUR = AFAC * R - C * Q
!                  do while(XCUR .lt. 0.0)
!                     XCUR = XCUR + MDIV
!                  end do
!  where B and C are constants related to MDIV and AFAC by
!            MDIV = B * AFAC + C
!  We use B = 112165 and C = 243273.  The average number of executions
!  of the statement XCUR = XCUR + MDIV is 1.09 and the maximum number of
!  executions is 3.
!
!  The largest number that must be handled in the "short" algorithm
!  is the product of AFAC  with the max value of XCUR, i.e.,
!    612_662 * 6_87194_76502 = 42_10181_19126_68324 ~= 0.58 * 2**56.
!  Thus this algorithm requires arithmetic exact to at least 56 bits.
!
!  The largest number that must be handled in the "long" algorithm
!  is the product of C with the max value of aint(XCUR/B), i.e.,
!               243273 * 612664 ~= 0.14904e12 ~= 0.54 * 2**38.
!  Thus this algorithm requires arithmetic exact to at least 38 bits.
!
!  To accommodate different compiler/computer systems this program unit
!  contains code for 3 different ways of computing the new XCUR from the
!  old XCUR, each producing exactly the same sequence of of XCUR.
!
!  Initially we have MODE = 1.  When MODE = 1 the code does tests to
!  see which of three implementation methods will be used, and sets
!  MODE = 2, 3, or 4 to indicate the choice.
!
!  Mode 2 will be used in machines such as the Cray that have at
!  least a 38 bit significand in SP arithmetic.  XCUR will be advanced
!  using the "long" algorithm in SP arithmetic.
!
!  Mode 3 will be used on machines that don't meet the Mode 2 test,
!  but can maintain at least a 56 bits exactly in computing
!  mod(AFAC*XCUR, MDIV) in DP arithmetic.  This includes VAX, UNISYS,
!  IBM 30xx, and some IEEE machines that have clever compilers that
!  keep an extended precision representation of the product AFAC*XCUR
!  within the math processor for use in the division by MDIV.  XCUR will
!  be advanced using the "short" algorithm in DP arithmetic.
!
!  Mode 4 will be used on machines that don't meet the Mode 2 or 3
!  tests, but have at least a 38 bit significand in DP arithmetic.
!  This includes IEEE machines that have not-so-clever compilers.
!  XCUR is advanced using the "long" algorithm in DP arithmetic.
!  ---------------------------------------------------------------------
!               Properties of the generated sequence.
!
!        This m is one of the prime numbers cited in
!     Table 1, Page 390, of Knuth, Seminumerical Algorithms, Second
!     edition, 1981, Addison-Wesley.
!     The prime factorization of m-1 is
!           m-1 = p1 * p2 * p3 = 2 * 43801 * 784_451
!     The complementary factors are
!           q(1) = 3_43597_38251, q(2) = 15_68902, and q(3) = 87602.
!
!     The value a is a primitive root of m as is verified by
!     computing a**q(i) mod m for i = 1,3, and finding these values are
!     not 1.  These values are m-1, 2_49653_21011, and 1_44431_31136.
!     The fact that a is a primitive root of m assures that the period
!     of the generator is m-1, i.e. starting with any integer from 1
!     through m-1, all integers in this range will be produced.
!
!     The value a has relatively large values of the measures nu and mu
!     computed for the Spectral Test as described in Knuth, pp. 89-105.
!        (Log10(nu(i)), i=2,6) = 5.4, 3.6,  2.6,  2.2,  1.8
!        (mu(i), i=2,6)        = 3.0, 3.05, 3.39, 4.55, 6.01
!     This assures that the generated sequence will have relatively low
!     autocorrelation.
!     ------------------------------------------------------------------
!                          Alternative algorithm
!
!  An alternative set of constants that has been used widely in
!  commercial and public domain software packages is
!               m = 21474_83647 = 2**31 - 1
!               a = 16807       = 7**5 = (approx.) 0.513 * 2**15
!
!  The largest product that must be handled exactly is approximately
!  0.513 * 2**46 which is approximately  0.36E14.  This is within the
!  double-precision capability of most computer systems.
!
!  The sequence can be started with any integer from 1 through m-1
!  and will generate all integers in this range.  The autocorrelation
!  properties of the whole sequence will not be as good as with the
!  larger values for m and a.
!     ------------------------------------------------------------------
!     C. L. Lawson, F. T. Krogh & S. Chiu, JPL, July 1986, Apr 1987.
!     ------------------------------------------------------------------
!                    Common Block
      integer MODE
      real XCURSP
      double precision XCURDP
      common / RANCOM / XCURDP, XCURSP, MODE
!              These same parameters are also defined below in RANMOD.
      double precision X1DP
      real             X1SP
      parameter( X1DP=123456789.0D0, X1SP=123456789.0e0 )
!     ------------------------------------------------------------------
!                         Entered using CALL RN1
!              This entry should not be called by general users.
!              User should call RAN1 in RANPK1.
!
         XCURDP = X1DP
         XCURSP = X1SP
         return
         end subroutine RN1
!     ------------------------------------------------------------------
      subroutine RANSIZ(KSIZE)
         integer KSIZE
         KSIZE = 2
         return
         end subroutine RANSIZ
!     ------------------------------------------------------------------
!                         Entered using CALL RNPUT(KSEED)
!              This entry should not be called by general users.
!              User should call RANPUT(KSEED) in RANPK1.
!
      subroutine RNPUT(KSEED)
      integer KSEED(2)
!                    Common Block
      integer MODE
      real XCURSP
      double precision XCURDP
      common / RANCOM / XCURDP, XCURSP, MODE
!
      double precision MDIVDP, SCALDP
      real             MDIVSP, SCALSP
      parameter( MDIVDP=68719476503.0D0, MDIVSP=68719476503.0e0 )
      parameter( SCALDP=100000.0D0, SCALSP=100000.0e0 )
      logical FIRST
      save FIRST
      data FIRST / .true. /
!
      if (FIRST) then
         FIRST = .false.
         call RANMOD
      end if
      if(MODE .eq. 2) then
         XCURSP = SCALSP * real(abs(KSEED(1))) + real(abs(KSEED(2)))
         XCURSP = max(1.e0, min(XCURSP, MDIVSP - 1.0e0))
      else
!                            Here for MODE = 3 or 4
         XCURDP = SCALDP * dble(abs(KSEED(1))) + dble(abs(KSEED(2)))
         XCURDP = max(1.D0, min(XCURDP, MDIVDP - 1.0D0))
      end if
      return
      end subroutine RNPUT
!     ------------------------------------------------------------------
      subroutine RANGET(KSEED)
      integer KSEED(2)
!                    Common Block
      integer MODE
      real XCURSP
      double precision XCURDP
      common / RANCOM / XCURDP, XCURSP, MODE
!
      double precision SCALDP
      real             SCALSP
      parameter( SCALDP=100000.0D0, SCALSP=100000.0e0 )
      logical FIRST
      save FIRST
      data FIRST / .true. /
!
      if (FIRST) then
         FIRST = .false.
         call RANMOD
      end if
      if(MODE .eq. 2) then
         KSEED(1) = int(XCURSP/SCALSP)
         KSEED(2) = int(XCURSP - SCALSP * real(KSEED(1)))
      else
!                            Here for MODE = 3 or 4
!
         KSEED(1) = int(XCURDP/SCALDP)
         KSEED(2) = int(XCURDP - SCALDP * dble(KSEED(1)))
      end if
      return
      end subroutine RANGET
!     ------------------------------------------------------------------
      subroutine RN2(MODE1)
      integer MODE1
!                    Common Block
      integer MODE
      real XCURSP
      double precision XCURDP
      common / RANCOM / XCURDP, XCURSP, MODE
!
      logical FIRST
      save FIRST
      data FIRST / .true. /
!
      if (FIRST) then
         FIRST = .false.
         call RANMOD
      end if
      MODE1 = MODE
      return
      end subroutine RN2
!     ------------------------------------------------------------------
      subroutine SRANUA(USP, N)
      integer N
      real USP(N)
!                    Common Block
      integer MODE
      real XCURSP
      double precision XCURDP
      common / RANCOM / XCURDP, XCURSP, MODE
!
      integer I
      double precision AFACDP, BFACDP, C2DP, MDIVDP, QDP, RDP
      real             AFACSP, BFACSP, C2SP, MDIVSP, QSP, RSP
      parameter( AFACDP=612662.0D0, BFACDP=112165.0d0, &
     &   C2DP=243273.0d0, MDIVDP=68719476503.0D0 )
      parameter( AFACSP=612662.0e0, BFACSP=112165.0e0, &
     &   C2SP=243273.0e0, MDIVSP=68719476503.0e0 )
      logical FIRST
      save FIRST
      data FIRST / .true. /
!
      if (FIRST) then
         FIRST = .false.
         call RANMOD
      end if
      go to (310, 320, 330, 340), MODE
  310 stop'In file RANPK2, subroutine SRANUA -- Ivalid value for MODE'
!                                         Mode 2.
  320   continue
      do 325 I = 1,N
         QSP = aint(XCURSP / BFACSP)
         RSP = XCURSP - QSP * BFACSP
         XCURSP = AFACSP * RSP - C2SP * QSP
  322    if(XCURSP .lt. 0.0e0) then
            XCURSP = XCURSP + MDIVSP
            go to 322
         end if
         USP(I) =  XCURSP/MDIVSP
  325 continue
      go to 350
!                                         Mode 3.
  330   continue
      do 335 I = 1,N
         XCURDP = mod(AFACDP * XCURDP,  MDIVDP)
         USP(I) = real( XCURDP)/MDIVSP
  335 continue
      go to 350
!                                         Mode 4.
  340   continue
      do 345 I = 1,N
         QDP = aint(XCURDP / BFACDP)
         RDP = XCURDP - QDP * BFACDP
         XCURDP = AFACDP * RDP - C2DP * QDP
  342    if(XCURDP .lt. 0.0d0) then
            XCURDP = XCURDP + MDIVDP
            go to 342
         end if
         USP(I) = real( XCURDP)/MDIVSP
  345 continue
  350 continue
      return
      end subroutine SRANUA
!     ------------------------------------------------------------------
      subroutine DRANUA(UDP, N)
      integer N
      double precision UDP(N)
!                    Common Block
      integer MODE
      real XCURSP
      double precision XCURDP
      common / RANCOM / XCURDP, XCURSP, MODE
!
      integer I
      double precision AFACDP, BFACDP, C2DP, MDIVDP, QDP, RDP
      real             AFACSP, BFACSP, C2SP, MDIVSP, QSP, RSP
      parameter( AFACDP=612662.0D0, BFACDP=112165.0d0, &
     &   C2DP=243273.0d0, MDIVDP=68719476503.0D0 )
      parameter( AFACSP=612662.0e0, BFACSP=112165.0e0, &
     &   C2SP=243273.0e0, MDIVSP=68719476503.0e0 )
      logical FIRST
      save FIRST
      data FIRST / .true. /
!
      if (FIRST) then
         FIRST = .false.
         call RANMOD
      end if
      go to (410, 420, 430, 440), MODE
  410 stop'In file RANPK2, subroutine DRANUA -- Ivalid value for MODE'
!                                         Mode 2.
  420   continue
      do 425 I = 1,N
         QSP = aint(XCURSP / BFACSP)
         RSP = XCURSP - QSP * BFACSP
         XCURSP = AFACSP * RSP - C2SP * QSP
  422    if(XCURSP .lt. 0.0e0) then
            XCURSP = XCURSP + MDIVSP
            go to 422
         end if
         UDP(I) = dble(XCURSP) / MDIVDP
  425 continue
      go to 450
!                                         Mode 3.
  430   continue
      do 435 I = 1,N
         XCURDP = mod(AFACDP * XCURDP,  MDIVDP)
         UDP(I) =  XCURDP/MDIVDP
  435 continue
      go to 450
!                                         Mode 4.
  440   continue
      do 445 I = 1,N
         QDP = aint(XCURDP / BFACDP)
         RDP = XCURDP - QDP * BFACDP
         XCURDP = AFACDP * RDP - C2DP * QDP
  442    if(XCURDP .lt. 0.0d0) then
            XCURDP = XCURDP + MDIVDP
            go to 442
         end if
         UDP(I) =  XCURDP/MDIVDP
  445 continue
  450 continue
      return
      end subroutine DRANUA
!     ------------------------------------------------------------------
      subroutine SRANUS(USP, N, ASP, BSP)
      integer N
      real ASP, BSP, USP(N)
!                    Common Block
      integer MODE
      real XCURSP
      double precision XCURDP
      common / RANCOM / XCURDP, XCURSP, MODE
!
      integer I
      double precision AFACDP, BFACDP, C2DP, MDIVDP, QDP, RDP
      real             AFACSP, BFACSP, C2SP, MDIVSP, QSP, RSP
      parameter( AFACDP=612662.0D0, BFACDP=112165.0d0, &
     &   C2DP=243273.0d0, MDIVDP=68719476503.0D0 )
      parameter( AFACSP=612662.0e0, BFACSP=112165.0e0, &
     &   C2SP=243273.0e0, MDIVSP=68719476503.0e0 )
      logical FIRST
      save FIRST
      data FIRST / .true. /
!
      if (FIRST) then
         FIRST = .false.
         call RANMOD
      end if
      go to (510, 520, 530, 540), MODE
  510 stop'In file RANPK2, subroutine SRANUS -- Ivalid value for MODE'
!                                         Mode 2.
  520   continue
      do 525 I = 1,N
         QSP = aint(XCURSP / BFACSP)
         RSP = XCURSP - QSP * BFACSP
         XCURSP = AFACSP * RSP - C2SP * QSP
  522    if(XCURSP .lt. 0.0e0) then
            XCURSP = XCURSP + MDIVSP
            go to 522
         end if
         USP(I) = ASP + BSP * XCURSP/MDIVSP
  525 continue
      go to 550
!                                         Mode 3.
  530   continue
      do 535 I = 1,N
         XCURDP = mod(AFACDP * XCURDP,  MDIVDP)
         USP(I) = ASP + BSP * real( XCURDP)/MDIVSP
  535 continue
      go to 550
!                                         Mode 4.
  540   continue
      do 545 I = 1,N
         QDP = aint(XCURDP / BFACDP)
         RDP = XCURDP - QDP * BFACDP
         XCURDP = AFACDP * RDP - C2DP * QDP
  542    if(XCURDP .lt. 0.0d0) then
            XCURDP = XCURDP + MDIVDP
            go to 542
         end if
         USP(I) = ASP + BSP * real( XCURDP)/MDIVSP
  545 continue
  550 continue
      return
      end subroutine SRANUS
!     ------------------------------------------------------------------
      subroutine DRANUS(UDP, N, ADP, BDP)
      integer N
      double precision ADP, BDP, UDP(N)
!                    Common Block
      integer MODE
      real XCURSP
      double precision XCURDP
      common / RANCOM / XCURDP, XCURSP, MODE
!
      integer I
      double precision AFACDP, BFACDP, C2DP, MDIVDP, QDP, RDP
      real             AFACSP, BFACSP, C2SP, MDIVSP, QSP, RSP
      parameter( AFACDP=612662.0D0, BFACDP=112165.0d0, &
     &   C2DP=243273.0d0, MDIVDP=68719476503.0D0 )
      parameter( AFACSP=612662.0e0, BFACSP=112165.0e0, &
     &   C2SP=243273.0e0, MDIVSP=68719476503.0e0 )
      logical FIRST
      save FIRST
      data FIRST / .true. /
!
      if (FIRST) then
         FIRST = .false.
         call RANMOD
      end if
      go to (610, 620, 630, 640), MODE
  610 stop'In file RANPK2, subroutine DRANUS -- Ivalid value for MODE'
!                                         Mode 2.
  620   continue
      do 625 I = 1,N
         QSP = aint(XCURSP / BFACSP)
         RSP = XCURSP - QSP * BFACSP
         XCURSP = AFACSP * RSP - C2SP * QSP
  622    if(XCURSP .lt. 0.0e0) then
            XCURSP = XCURSP + MDIVSP
            go to 622
         end if
         UDP(I) = ADP + BDP * dble(XCURSP) / MDIVDP
  625 continue
      go to 650
!                                         Mode 3.
  630   continue
      do 635 I = 1,N
         XCURDP = mod(AFACDP * XCURDP,  MDIVDP)
         UDP(I) = ADP + BDP * XCURDP/MDIVDP
  635 continue
      go to 650
!                                         Mode 4.
  640   continue
      do 645 I = 1,N
         QDP = aint(XCURDP / BFACDP)
         RDP = XCURDP - QDP * BFACDP
         XCURDP = AFACDP * RDP - C2DP * QDP
  642    if(XCURDP .lt. 0.0d0) then
            XCURDP = XCURDP + MDIVDP
            go to 642
         end if
         UDP(I) = ADP + BDP * XCURDP/MDIVDP
  645 continue
  650 continue
      return
      end subroutine DRANUS
!     ------------------------------------------------------------------
      subroutine RANMOD
!
!     Do tests to decide whether to set the MODE = 2, 3, or 4.
!     Outcome will depend on precision of SP and DP floating point
!     arithmetic on the host system.
!                    Common Block
      integer MODE
      real XCURSP
      double precision XCURDP
      common / RANCOM / XCURDP, XCURSP, MODE
!
      integer I, J, K
      double precision TEST(0:3,0:1), DIFF
      double precision QDP, RDP, XTSTDP
      double precision AFACDP, BFACDP, C2DP, MDIVDP, X1DP
      real             QSP, RSP, XTSTSP
      real             AFACSP, BFACSP, C2SP, MDIVSP, X1SP
      parameter( AFACDP=612662.0D0, MDIVDP=68719476503.0D0, &
     & X1DP=123456789.0D0, BFACDP=112165.0d0, C2DP=243273.0d0)
      parameter( AFACSP=612662.0e0, MDIVSP=68719476503.0e0, &
     &  X1SP=123456789.0e0, BFACSP=112165.0e0, C2SP=243273.0e0)
      logical DONE
      save DONE
!
      data DONE / .false. /
      data TEST / 24997965550.0d0, 68719476502.0d0, &
     &            68718863841.0d0, 36962132774.0d0, &
     &            43721510953.0d0,           1.0d0, &
     &                 612662.0d0, 31757343729.0d0/
!
      if (DONE) return
      DONE = .true.
      do 880 MODE = 2, 4
         do 870 J = 0,1
            XTSTDP = TEST(0,J)
            XTSTSP = real(XTSTDP)
            do 860 I = 1,3
               go to (820, 830, 840),MODE-1
!                                                Test of MODE 2
  820          continue
                  QSP = aint(XTSTSP / BFACSP)
                  RSP = XTSTSP - QSP * BFACSP
                  XTSTSP = AFACSP * RSP - C2SP * QSP
                  do 822 K = 1,3
                     if(XTSTSP .ge. 0.0e0) go to 825
                       XTSTSP = XTSTSP + MDIVSP
  822               continue
  825               continue
                  DIFF = dble(XTSTSP) - TEST(I,J)
               go to 850
!                                                Test of MODE 3
  830          continue
                  XTSTDP = mod(AFACDP * XTSTDP,  MDIVDP)
                  DIFF = XTSTDP - TEST(I,J)
               go to 850
!                                                Test of MODE 4
  840          continue
                  QDP = aint(XTSTDP / BFACDP)
                  RDP = XTSTDP - QDP * BFACDP
                  XTSTDP = AFACDP * RDP - C2DP * QDP
                  do 842 K = 1,3
                     if(XTSTDP .ge. 0.0d0) go to 845
                     XTSTDP = XTSTDP + MDIVDP
  842             continue
  845             continue
                  DIFF = XTSTDP - TEST(I,J)
  850          continue
!*              print'(1x,a,3i3,g11.3)', 'RANPK2.. MODE,J,I,DIFF=',
!*    *         MODE,J,I,DIFF                !****** For Testing ******
              print *, 'RANPK2.. MODE,J,I,DIFF'
              print *, MODE,J,I,DIFF
               if(DIFF .ne. 0.0d0) go to 880
!                            Following line ends I loop.
  860         continue
!                            Following line ends J loop.
  870      continue
!
!        Here the computations using the current value of MODE have
!        passed all tests, so we accept this value of MODE.
         XCURDP = X1DP
         XCURSP = X1SP
         return
!
!*        print*,'From RANPK2.. MODE =',MODE  !***** For Testing *****
          print*, 'From RANPK2.. MODE =',MODE  !***** For Testing *****
!                            Following line ends MODE loop.
  880 continue
!        The computations were unsuccessful for all values of MODE.
!        This means this random number package will not work on the
!        current host system.  ****** Fatal Error Stop ******
!
!      call ERMSG('RANPK2',1, 2,
!     *'This random no. code will not work on this computer system.','.')
      print *, '***RANPK2 wishes to report the following error'
      print *, 'This rnc will not work on this computer system.'
      return
      end subroutine RANMOD

      real             function  SRANG ()
!     .  Copyright (C) 1989, California Institute of Technology.
!     .  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.
!>> 1996-04-16 SRANG WVS SQRT(abs(TWO*log(U3))) avoids sqrt(-0.0)
!>> 1994-10-20 SRANG Krogh  Changes to use M77CON
!>> 1994-06-24 SRANG CLL Changed common to use RANC[D/S]1 & RANC[D/S]2.
!>> 1992-03-16 SRANG CLL
!>> 1991-11-26 SRANG CLL Reorganized common. Using RANCM[A/D/S].
!>> 1991-11-22 SRANG CLL Added call to RAN0, and SGFLAG in common.
!>> 1991-01-15 SRANG CLL Reordered common contents for efficiency.
!>> 1990-01-23 SRANG CLL Making names in common same in all subprogams.
!>> 1987-06-09 SRANG CLLawson  Initial code.
!
!     Returns one pseudorandom number from the Gausian (Normal)
!     distribution with zero mean and unit standard deviation.
!     Method taken from Algorithm 334, Comm. ACM, July 1968, p. 498.
!     Implemented at JPL in Univac Fortran V in 1969 by Wiley R. Bunton
!     of JPL and Stephen L. Richie of Heliodyne Corp.
!
!     Adapted to Fortran 77 for the MATH 77 library by C. L. Lawson and
!     S. Y. Chiu, JPL, April 1987, 6/9/87.
!     ------------------------------------------------------------------
!--S replaces "?": ?RANG, ?RANUA, RANC?1, RANC?2, ?PTR, ?NUMS, ?GFLAG
!     RANCS1 and RANCS2 are common blocks.
!     Uses intrinsic functions, log and sqrt.
!     Calls SRANUA to obtain an array of uniform random numbers.
!     Calls RAN0 to initialize SPTR and SGFLAG.
!     ------------------------------------------------------------------
!                        Important common variables
!
!     SPTR [integer] and SGFLAG [logical]
!
!          Will be set to SPTR = 1 and SGFLAG = .false.
!          when RAN0 is called from this subr if this
!          is the first call to RAN0.  Also set to these values when
!          RAN1 or RANPUT is called by a user.
!
!          SGFLAG will be set true on return from this subr when the
!          algorithm has values that it can save to reduce the amount
!          of computation needed the next time this function is
!          referenced.  Will be set false in the contrary case.
!
!          SPTR is the index of the last location used in the
!          common array SNUMS().  This index is counted down.
!
!     SNUMS() [floating point]  Buffer of previously computed uniform
!          random numbers.
!     ------------------------------------------------------------------
      integer M
      parameter(M = 97)
      real                ONE, TWO
      parameter(ONE = 1.0E0, TWO = 2.0E0)
      real                SNUMS(M), R, S, U3, X, XX, Y, YY
      logical FIRST
      common/RANCS2/SNUMS
      integer SPTR
      logical SGFLAG
      common/RANCS1/SPTR, SGFLAG
      save  /RANCS1/, /RANCS2/, FIRST
      save    R, X, Y
      data  FIRST/.true./
!     ------------------------------------------------------------------
      if(FIRST) then
         FIRST = .false.
         call RAN0
      endif
!
      if (.not. SGFLAG .or. SPTR .eq. 1) then
!
!     Use the Von Neuman rejection method for choosing a random point
!     (X,Y) in the unit circle, X**2 + Y**2 .le. 1.0.
!     Then the angle Theta = arctan(Y/X) is random, uniform in
!     (-Pi/2, Pi/2), and Phi = 2*Theta is random, uniform in (-Pi, Pi).
!     Define S = X**2 + Y**2, then
!     sin(Theta) = Y/sqrt(S),    cos(Theta) = X/sqrt(S),
!     sin(Phi) = 2*X*Y/S,    and cos(Phi) = (X**2 - Y**2)/S.
!
9910    continue
!                              Set X = random, uniform in [0., 1.]
      SPTR = SPTR - 1
      if(SPTR .eq. 0) then
         call SRANUA(SNUMS, M)
         SPTR = M
      endif
            X = SNUMS(SPTR)
!                              Set Y = random, uniform in [-1., 1.]
            SPTR = SPTR - 1
            if(SPTR .eq. 0) then
               call SRANUA(SNUMS,M)
               SPTR = M
            endif
            Y = TWO*SNUMS(SPTR) - ONE
!
            XX=X*X
            YY=Y*Y
            S=XX+YY
         if(S .gt. ONE) go to 9910
!
!     Choose R randomly from Chi-squared distribution and
!     normalize with S.
!
!                              Set U3 = random, uniform in [0., 1.]
         SPTR = SPTR - 1
         if(SPTR .eq. 0) then
            call SRANUA(SNUMS,M)
            SPTR = M
         endif
         U3 = SNUMS(SPTR)
!        Changed -TWO*log(U3) to abs(TWO*log(U3)) because Lahey LF90
!        2.00 on a pentium produced -0.0 for -TWO*log(1.0), then got a
!        floating point exception on sqrt(-0.0).
         R = sqrt(abs(TWO*(log(U3))))/S
!
!                                Compute result as  R*Sin(PHI)
!
         SRANG = (XX-YY)*R
         SGFLAG = .true.
         return
      endif
!     -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!        Come here when SGFLAG is true and SPTR is not 1.
!
!                                Compute result as  R*Cos(PHI)
      SRANG = TWO*X*Y*R
      SGFLAG=.false.
      return
      end function  SRANG

d588 3
@


2.13
log
@Cosmetic changes only
@
text
@d17 1
a17 1
  public :: Hunt, InterpolateValues
d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.12 2001/07/06 18:44:40 dwu Exp $"
d29 12
d584 968
d1558 3
@


2.12
log
@Add a feature in InterpolateScaler to handle periodic data
@
text
@d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.11 2001/06/07 21:59:41 pwagner Exp $"
d267 1
a268 1
    real(R8), dimension(:),   pointer :: gap =>NULL()
d287 1
a287 1
    nullify ( a, aa, b, bb, c, cc, d, dd, gap2, gap, lowerInds, maskVector, &
d578 3
@


2.11
log
@Added Copyright statement
@
text
@d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.10 2001/05/08 23:25:58 livesey Exp $"
d502 1
a502 1
  & badValue, missingRegions, dyByDx )
d514 1
d517 1
d520 3
d526 17
d544 1
d549 1
a549 1
    call InterpolateArray ( oldX, spread(oldY,2,1), newX, tempResult, method, &
d556 1
a556 1
    call InterpolateArray ( oldX, spread(oldY,2,1), newX, tempResult, method, &
d561 9
d578 3
@


2.10
log
@Added a nullify for oldSecond (how did I miss that?)
@
text
@d1 3
d21 1
a21 1
       "$Id: MLSNumerics.f90,v 2.9 2001/05/03 23:13:28 livesey Exp $"
d546 3
@


2.9
log
@Made Van's changes compile with NAG
@
text
@d18 1
a18 1
       "$Id: MLSNumerics.f90,v 2.8 2001/05/03 21:54:49 vsnyder Exp $"
d285 1
a285 1
      &       oldSecondLower, oldSecondUpper, oldYlower, oldYupper, p, &
d543 3
@


2.8
log
@Added some nullify's, did some cosmetic changes
@
text
@d18 1
a18 1
       "$Id: $"
d21 1
a21 1
       "$RCSfile: $"
d386 1
a386 1
    if ( extrapolateMethod=="C" ) A = max(min(A,1.0D0),0.0)
d388 1
a388 1
    B=1.0-A
d543 3
@


2.7
log
@Hunt now correctly handles cases where list is of size one.
Changed to lower case keywords and reformatted.
@
text
@d13 2
a14 1
  public
d16 7
a22 6
  private :: Id,ModuleName
  !------------------------------- RCS Ident Info ----------------------------
  character(LEN=256) :: Id = & 
    "$Id: MLSNumerics.f90,v 2.6 2001/04/28 07:05:05 livesey Exp $"
  character(LEN=*), parameter :: ModuleName= "$RCSfile: MLSNumerics.f90,v $"
  !---------------------------------------------------------------------------
a23 1
!
d26 1
a26 1
!
a37 2
  private :: InterpolateArray, InterpolateScalar, HuntArray, HuntScalar

d45 1
a45 1
  subroutine HuntArray(list,values,indices,start,allowTopValue,allowBelowValue)
d48 6
a53 6
    real(R8), dimension(:), intent(IN) :: list ! List to search
    real(R8), dimension(:), intent(IN) :: values ! Values to search for
    integer, dimension(:), intent(OUT) :: indices ! Result
    integer, optional, intent(IN) :: start ! Optional start index
    logical, optional, intent(IN) :: allowTopValue ! Can return N
    logical, optional, intent(IN) :: allowBelowValue ! Can return 0
d72 1
a72 1
    real(R8) :: thisValue
d76 2
a77 2
    if (present(allowTopValue)) then
      useAllowTopValue=allowTopValue
d79 2
a80 2
      useAllowTopValue=.false.
    endif
d82 2
a83 2
    if (present(allowBelowValue)) then
      useAllowBelowValue=allowBelowValue
d85 2
a86 2
      useAllowBelowValue=.false.
    endif
d88 2
a89 2
    if (present(start)) then
      useStart=start
d91 2
a92 2
      useStart=1
    endif
d94 4
a97 4
    listLen=size(list)
    valuesLen=size(values)
    if (size(indices) < valuesLen) call MLSMessage(MLSMSG_Error,ModuleName, &
      & "Result array is too small")
d110 2
a111 2
      if (list(size(list)) >= list(1)) then
        listDirection=1
d113 3
a115 3
        listDirection=-1
      endif
    endif
d119 2
a120 2
    if (useAllowTopValue) then
      upperLimit=listLen
d122 2
a123 2
      upperLimit=listLen-1
    endif
d127 6
a132 6
    index=max(1,min(useStart,upperLimit))
    do valueIndex=1,valuesLen
      thisValue=values(valueIndex)
      expanding=.true.
      searchDirection=0
      stride=1
d134 3
a136 3
        lowerBelow= (thisValue-list(index))*listDirection >= 0.0D0
        if (index<listLen) then 
          upperAbove= (list(index+1)-thisValue)*listDirection > 0.0D0
d138 2
a139 2
          upperAbove=.true.   
        endif
d144 1
a144 1
        if (lowerBelow.and.upperAbove) exit HuntLoop
d147 1
a147 1
        oldSearchDirection=searchDirection
d149 1
a149 1
        if (lowerBelow.and. (.not. upperAbove)) then
d151 1
a151 1
          if (index==upperLimit) exit HuntLoop
d153 3
a155 3
          index=index+stride
          searchDirection=1
        endif
d157 1
a157 1
        if ((.not. lowerBelow).and.upperAbove) then
d159 1
a159 1
          if (index==1) exit HuntLoop
d162 3
a164 3
          index=index-stride
          searchDirection=-1
        endif
d170 2
a171 2
          & (oldSearchDirection /= 0) .and. (expanding)) &
          & expanding=.false.
d173 2
a174 2
        if (expanding) then
          stride=min(stride*2,listLen/2)
d176 2
a177 2
          stride=max(stride/2,1)
        endif
d181 1
a181 1
        index=min(max(index,1),upperLimit)
d186 3
a188 3
      if (useAllowBelowValue) then
        if ((thisValue-list(index))*listDirection<0.0D0) index=0
      endif
d190 2
a191 2
      indices(valueIndex)=index
    enddo
d198 1
a198 1
  subroutine HuntScalar(list,value,index,start,allowTopValue,allowBelowValue)
d201 6
a206 6
    real(R8), dimension(:), intent(IN) :: list ! List to search
    real(R8), intent(IN) :: value ! Value to search for
    integer, intent(OUT) :: index ! Resulting index
    integer, intent(IN), optional :: start ! Optional start index
    logical, optional, intent(IN) :: allowTopValue ! Can return N
    logical, optional, intent(IN) :: allowBelowValue ! Can return 0
d213 3
a215 3
    values(1)=value
    call HuntArray(list,values,indices,start,allowTopValue,allowBelowValue)
    index=indices(1)
d233 2
a234 2
  subroutine InterpolateArray(oldX,oldY,newX,newY,method,extrapolate, &
    & badValue,missingRegions,dyByDx,dNewByDOld)
d242 6
a247 6
    character (LEN=*), intent(IN) :: method ! See comments above
    character (LEN=*), optional, intent(IN) :: extrapolate ! See comments above
    real(R8), optional, intent(IN) :: badValue
    real(R8), dimension(:,:), optional, intent(OUT) :: dyByDx
    logical, optional, intent(IN) :: missingRegions ! Allow missing regions
    type (MatrixElement_T), intent(OUT), optional :: dNewByDOld ! Derivatives
d250 4
a253 4
    integer :: noOld,noNew,width ! Dimensions
    logical :: spline           ! Flag
    logical :: useMissingRegions ! Copy of missing regions
    integer :: ind,newInd       ! Loop counters
d256 22
a277 22
    integer, dimension(:),    pointer :: lowerInds=> NULL()
    integer, dimension(:),    pointer :: upperInds=> NULL()
    real(R8), dimension(:),   pointer :: maskVector=> NULL()
    real(R8), dimension(:),   pointer :: gap=>NULL()
    real(R8), dimension(:),   pointer :: gap2=> NULL()
    real(R8), dimension(:,:), pointer :: spreadGap=> NULL()
    real(R8), dimension(:,:), pointer :: oldSecond=> NULL()
    real(R8), dimension(:,:), pointer :: oldYupper=> NULL()
    real(R8), dimension(:,:), pointer :: oldYlower=> NULL()
    real(R8), dimension(:,:), pointer :: oldSecondLower=> NULL()
    real(R8), dimension(:,:), pointer :: oldSecondUpper=> NULL()
    real(R8), dimension(:),   pointer :: A=> NULL()
    real(R8), dimension(:),   pointer :: B=> NULL()
    real(R8), dimension(:),   pointer :: C=> NULL()
    real(R8), dimension(:),   pointer :: D=> NULL() ! Coefficients
    real(R8), dimension(:,:), pointer :: AA=> NULL()
    real(R8), dimension(:,:), pointer :: BB=> NULL()
    real(R8), dimension(:,:), pointer :: CC=> NULL()
    real(R8), dimension(:,:), pointer :: DD=> NULL() ! Spread coefs.
    real(R8), dimension(:,:), pointer :: temp=> NULL() ! For 2nd der. guess
    real(R8), dimension(:),   pointer :: p=> NULL() ! For 2nd der. guess
    real(R8), dimension(:,:), pointer :: tempDNewByDOld=> NULL() ! Dense version.
d284 4
d297 1
a297 1
    if (present(extrapolate)) extrapolateMethod=Capitalize(extrapolate(1:1))
d300 1
a300 1
    if (present(missingRegions)) useMissingRegions=missingRegions
d304 2
a305 2
    if (useMissingRegions.and.spline) call MLSMessage(MLSMSG_Error,ModuleName, &
      & "Cannot use missing regions with spline")
d307 2
a308 2
    if (computeDNewByDOld .and. spline) call MLSMessage(MLSMSG_Error,ModuleName,&
      "Cannont get dNewBydOld from spline")
d310 9
a318 9
    call Allocate_Test(lowerInds,noNew,"lowerInds",ModuleName)
    call Allocate_Test(upperInds,noNew,"upperInds",ModuleName)
    call Allocate_Test(gap,noNew,"gap",ModuleName)
    call Allocate_Test(A,noNew,"A",ModuleName)
    call Allocate_Test(B,noNew,"B",ModuleName)
    call Allocate_Test(AA,noNew,width,"AA",ModuleName)
    call Allocate_Test(BB,noNew,width,"BB",ModuleName)
    call Allocate_Test(oldYlower,noNew,width,"oldYlower",ModuleName)
    call Allocate_Test(oldYupper,noNew,width,"oldYupper",ModuleName)
d322 1
a322 1
    if (present(dyByDx)) call Allocate_Test(spreadGap,noNew,width,&
d326 4
a329 4
    if (computeDNewByDOld) then
      call CreateBlock_0(dNewByDOld,noNew*width,noOld*width,M_Column_Sparse,&
        NumberNonZero=2*noNew*width)
    endif
d334 11
a344 11
    if (spline) then
      call Allocate_Test(oldSecond,noOld,width,"oldSecond",ModuleName)
      call Allocate_Test(C,noNew,"C",ModuleName)
      call Allocate_Test(D,noNew,"D",ModuleName)
      call Allocate_Test(CC,noNew,width,"CC",ModuleName)
      call Allocate_Test(DD,noNew,width,"DD",ModuleName)
      call Allocate_Test(oldSecondlower,noNew,width,"oldSecondlower",ModuleName)
      call Allocate_Test(oldSecondupper,noNew,width,"oldSecondupper",ModuleName)
      call Allocate_Test(gap2,noNew,"gap2",ModuleName)
      call Allocate_Test(temp,noOld,width,"temp",ModuleName)
      call Allocate_Test(p,width,"p",ModuleName)
d348 7
a354 7
      oldSecond(1,:)=0.0D0
      temp(1,:)=0.0D0
      do ind=2,noOld-1
        sig=(oldX(ind)-oldX(ind-1))/(oldX(ind+1)-oldX(ind-1))
        p=sig*oldSecond(ind-1,:)+2.0D0
        oldSecond(ind,:)=(sig-1.0D0)/p
        temp(ind,:)=(oldY(ind+1,:)-oldY(ind,:))/(oldX(ind+1)-oldX(ind)) - &
d356 1
a356 1
        temp(ind,:)=(6.0D0*temp(ind,:)/ &
d358 2
a359 2
      enddo
      oldSecond(noOld,:)=0.0D0
d362 7
a368 7
      do ind=noOld-1,1,-1
        oldSecond(ind,:)=oldSecond(ind,:)*oldSecond(ind+1,:)+temp(ind,:)
      enddo

      call Deallocate_test(temp,"Temp",ModuleName) 
      call Deallocate_test(p,"p",ModuleName)
    endif
d373 2
a374 2
    newY=0.0D0
    if (present(dyByDx)) dyByDx=0.0D0
d378 4
a381 4
    call Hunt(oldX,newX,lowerInds)
    upperInds=lowerInds+1
    gap=oldX(upperInds)-oldX(lowerInds)
    if (present(dyByDx)) spreadGap=spread(gap,2,width)
d383 1
a383 1
    A=(oldX(upperInds)-newX)/gap
d386 1
a386 1
    if (extrapolateMethod=="C") A=max(min(A,1.0D0),0.0D0)
d388 1
a388 1
    B=1.0D0-A
d391 7
a397 7
    if (extrapolateMethod=="B") then
      call Allocate_Test(maskVector,noNew,"maskVector",ModuleName)
      maskVector=0.0D0
      where ((A<0.0D0).or.(A>1.0D0))
        maskVector=badValue
        A=0.0D0
        B=0.0D0
d399 4
a402 4
      newY=spread(maskVector,2,width)
      if (present(dyByDx)) dyByDx=newY
      call Deallocate_Test(maskVector,"maskVector",ModuleName)
    endif
d405 4
a408 4
    AA=spread(A,2,width)
    BB=spread(B,2,width)
    oldYlower=oldY(lowerInds,:)
    oldYupper=oldY(upperInds,:)
d411 1
a411 1
    if (useMissingRegions) then
d413 3
a415 3
        newY=badValue
        AA=0.0D0
        BB=0.0D0
d417 1
a417 1
      if (present(dyByDx)) then
d419 7
a425 7
          & (oldYupper==badValue))
        dyByDx=badValue
        oldYlower=0.0      ! Only way to guarentee bad derivative
        oldYupper=0.0      ! But don't need to worry about spline
      ENDWHERE
    endif
  endif
d428 2
a429 2
  newY=newY+AA*oldYlower+BB*oldYupper
  if (present(dyByDx)) dyByDx=(oldYupper-oldYlower)/spreadGap
d432 1
a432 1
  if (computeDNewByDOld) then
d436 9
a444 9
!
    call Allocate_Test(tempDNewByDOld,noNew*width,noOld*width,&
      "tempDNewByDOld",ModuleName)
    do newInd=1,noNew
      do ind=1,width
        tempDNewByDOld(newInd+ind*noNew,lowerInds(newInd)+ind*noOld)=A(newInd)
        tempDNewByDOld(newInd+ind*noNew,upperInds(newInd)+ind*noOld)=B(newInd)
      enddo
    enddo
d447 1
a447 1
  endif
d450 4
a453 4
  if (spline) then
    gap2=gap**2
    C=(A**3-A)*gap2/6.0D0    ! Note the extrapolate bad case is covered as..
    D=(B**3-B)*gap2/6.0D0    !   A=B=0.0D0
d456 35
a490 34
    CC=spread(C,2,width)
    DD=spread(D,2,width)
    oldSecondLower=oldSecond(lowerInds,:)
    oldSecondUpper=oldSecond(upperInds,:)

    newY=newY+CC*oldSecondLower+DD*oldSecondUpper
    if (present(dyByDx)) dyByDx=dyByDx+(spreadGap/6.0D0)*( &
      & (3.0D0*BB**2-1.0D0)*oldSecondUpper- &
      & (3.0D0*AA**2-1.0D0)*oldSecondLower)
  endif

  call Deallocate_Test(lowerInds,"lowerInds",ModuleName)
  call Deallocate_Test(upperInds,"upperInds",ModuleName)
  call Deallocate_Test(gap,"gap",ModuleName)
  call Deallocate_Test(A,"A",ModuleName)
  call Deallocate_Test(B,"B",ModuleName)
  call Deallocate_Test(AA,"AA",ModuleName)
  call Deallocate_Test(BB,"BB",ModuleName)
  call Deallocate_Test(oldYlower,"oldYlower",ModuleName)
  call Deallocate_Test(oldYupper,"oldYupper",ModuleName)

  if (spline) then
    call Deallocate_Test(oldSecond,"oldSecond",ModuleName)
    call Deallocate_Test(C,"C",ModuleName)
    call Deallocate_Test(D,"D",ModuleName)
    call Deallocate_Test(CC,"CC",ModuleName)
    call Deallocate_Test(DD,"DD",ModuleName)
    call Deallocate_Test(oldSecondlower,"oldSecondlower",ModuleName)
    call Deallocate_Test(oldSecondupper,"oldSecondupper",ModuleName)
    call Deallocate_Test(gap2,"gap2",ModuleName)
    call Deallocate_Test(temp,"temp",ModuleName)
    call Deallocate_Test(p,"p",ModuleName)
  endif
  if (present(dyByDx)) call Deallocate_Test(spreadGap,"spreadGap",ModuleName)
d498 2
a499 2
subroutine InterpolateScalar(oldX,oldY,newX,newY,method,extrapolate, &
  & badValue,missingRegions,dyByDx)
d502 10
a511 10
  real(R8), dimension(:), intent(IN) :: oldX
  real(R8), dimension(:), intent(IN) :: oldY
  real(R8), dimension(:), intent(IN) :: newX
  real(R8), dimension(:), intent(OUT) :: newY

  character (LEN=*), intent(IN) :: method ! See comments above
  character (LEN=*), optional, intent(IN) :: extrapolate ! See comments above
  real(R8), optional, intent(IN) :: badValue
  real(R8), dimension(:), optional, intent(OUT) :: dyByDx
  logical, optional, intent(IN) :: missingRegions ! Allow missing regions
d513 2
a514 2
  real(R8), dimension(:,:), pointer :: tempResult => NULL()
  real(R8), dimension(:,:), pointer :: tempDerivative => NULL()
d518 4
a521 3
  call Allocate_Test(tempResult,size(newX),1,"tempResult",ModuleName)
  if (present(dyByDx)) then
    call Allocate_Test(tempDerivative,size(newX),1,"tempDerivative",ModuleName)
d523 1
a523 1
    call InterpolateArray(oldX,spread(oldY,2,1),newX,tempResult,method, &
d525 2
a526 2
      & missingRegions=missingRegions, dyByDx=tempDerivative)
    dyByDx=reshape(tempDerivative,shape(newX))
d528 1
a528 1
    call Deallocate_Test(tempDerivative,"tempDerivative",ModuleName)
d530 1
a530 1
    call InterpolateArray(oldX,spread(oldY,2,1),newX,tempResult,method, &
d532 3
a534 4
      & missingRegions=missingRegions)
  endif
  newY=reshape(tempResult,shape(newX))
  call Deallocate_test(tempResult,"tempResult",ModuleName)
d543 4
@


2.6
log
@Minor bug fix in spline
@
text
@d2 10
a11 2
MODULE MLSNumerics              ! Some low level numerical stuff
!=============================================================================
d13 1
a13 9
  UsE MLSCommon, ONLY : R8
  USE MLSMessageModule, ONLY: MLSMessage,MLSMSG_Error
  USE MLSStrings, ONLY: Capitalize
  USE MatrixModule_0, ONLY: MatrixElement_T,CreateBlock_0,M_Column_Sparse, Sparsify
  USE Allocate_Deallocate, ONLY : Allocate_test, Deallocate_test

  IMPLICIT NONE
  
  PUBLIC
d15 1
a15 1
  PRIVATE :: Id,ModuleName
d17 3
a19 3
  CHARACTER(LEN=256) :: Id = & 
       "$Id: MLSNumerics.f90,v 2.5 2001/04/11 22:43:19 vsnyder Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName= "$RCSfile: MLSNumerics.f90,v $"
d23 2
a24 2
! This module contains some low level numerical stuff, hunting, interpolating
! etc.
d27 9
a35 9
  INTERFACE Hunt
     MODULE PROCEDURE HuntArray
     MODULE PROCEDURE HuntScalar
  END INTERFACE

  INTERFACE InterpolateValues
     MODULE PROCEDURE InterpolateArray
     MODULE PROCEDURE InterpolateScalar
  END INTERFACE
d37 1
a37 1
  PRIVATE :: InterpolateArray, InterpolateScalar, HuntArray, HuntScalar
d39 1
a39 1
CONTAINS
d46 1
a46 1
  SUBROUTINE HuntArray(list,values,indices,start,allowTopValue,allowBelowValue)
d49 6
a54 6
    REAL(R8), DIMENSION(:), INTENT(IN) :: list ! List to search
    REAL(R8), DIMENSION(:), INTENT(IN) :: values ! Values to search for
    INTEGER, DIMENSION(:), INTENT(OUT) :: indices ! Result
    INTEGER, OPTIONAL, INTENT(IN) :: start ! Optional start index
    LOGICAL, OPTIONAL, INTENT(IN) :: allowTopValue ! Can return N
    LOGICAL, OPTIONAL, INTENT(IN) :: allowBelowValue ! Can return 0
d57 15
a71 15
    INTEGER :: listLen, valuesLen ! Array sizes
    INTEGER :: valueIndex       ! Loop counters
    INTEGER :: index            ! Temporary result

    LOGICAL :: useAllowTopValue, useAllowBelowValue
    INTEGER :: useStart
    INTEGER :: upperLimit       ! Highest value that can be returned
    INTEGER :: stride           ! Value to step by
    LOGICAL :: expanding        ! Whether we're expanding or reducing our search
    LOGICAL :: lowerBelow       ! Flag
    LOGICAL :: upperAbove       ! Another flag

    INTEGER :: listDirection    ! +1 if list ascends, -1 descends
    INTEGER :: searchDirection  ! (in index space) 
    INTEGER :: oldSearchDirection ! Previous value of above
d73 1
a73 1
    REAL(R8) :: thisValue
d77 40
a116 33
    IF (PRESENT(allowTopValue)) THEN
       useAllowTopValue=allowTopValue
    ELSE
       useAllowTopValue=.FALSE.
    ENDIF

    IF (PRESENT(allowBelowValue)) THEN
       useAllowBelowValue=allowBelowValue
    ELSE
       useAllowBelowValue=.FALSE.
    ENDIF

    IF (PRESENT(start)) THEN
       useStart=start
    ELSE
       useStart=1
    ENDIF

    listLen=SIZE(list)
    valuesLen=SIZE(values)
    IF (SIZE(indices) < valuesLen) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Result array is too small")

    ! Note that this next bit makes two assumptions:
    !   1 - list(1)/=list(2)
    !   2 SIZE(list) > 1
    ! We might want to be more clever with this later

    IF (list(2) >= list(1)) THEN
       listDirection=1
    ELSE
       listDirection=-1
    ENDIF
d120 5
a124 5
    IF (useAllowTopValue) THEN
       upperLimit=listLen
    ELSE
       upperLimit=listLen-1
    ENDIF
d128 66
a193 66
    index=MAX(1,MIN(useStart,upperLimit))
    DO valueIndex=1,valuesLen
       thisValue=values(valueIndex)
       expanding=.TRUE.
       searchDirection=0
       stride=1
       HuntLoop: DO
          lowerBelow= (thisValue-list(index))*listDirection >= 0.0D0
          IF (index<listLen) THEN 
             upperAbove= (list(index+1)-thisValue)*listDirection > 0.0D0
          ELSE ! We're off the end of the list
             upperAbove=.TRUE.   
          ENDIF

          ! Now we know what the state of play is, what does it mean?

          ! First see if we've found the place
          IF (lowerBelow.AND.upperAbove) EXIT HuntLoop

          ! The other cases are a little more complex
          oldSearchDirection=searchDirection

          IF (lowerBelow.AND. (.NOT. upperAbove)) THEN
             ! If we're at the end, get out
             IF (index==upperLimit) EXIT HuntLoop
             ! We're too low, keep looking upwards
             index=index+stride
             searchDirection=1
          ENDIF

          IF ((.NOT. lowerBelow).AND.upperAbove) THEN
             ! If we're at the begning, get out
             IF (index==1) EXIT HuntLoop

             ! We're too high but not at begining, look back downwards
             index=index-stride
             searchDirection=-1
          ENDIF

          ! Now the very first change of direction is the end of hte
          ! `expanding' phase

          IF ( (searchDirection /= oldSearchDirection) .AND. &
               & (oldSearchDirection /= 0) .AND. (expanding)) &
               & expanding=.FALSE.

          IF (expanding) THEN
             stride=MIN(stride*2,listLen/2)
          ELSE
             stride=MAX(stride/2,1)
          ENDIF

          ! Make sure we don't fall off an end

          index=MIN(MAX(index,1),upperLimit)
       END DO HuntLoop

       ! Final check for off the bottom of the list

       IF (useAllowBelowValue) THEN
          IF ((thisValue-list(index))*listDirection<0.0D0) index=0
       ENDIF

       indices(valueIndex)=index
    ENDDO
  END SUBROUTINE HuntArray
d199 2
a200 2
  SUBROUTINE HuntScalar(list,value,index,start,allowTopValue,allowBelowValue)
    
d202 6
a207 6
    REAL(R8), DIMENSION(:), INTENT(IN) :: list ! List to search
    REAL(R8), INTENT(IN) :: value ! Value to search for
    INTEGER, INTENT(OUT) :: index ! Resulting index
    INTEGER, INTENT(IN), OPTIONAL :: start ! Optional start index
    LOGICAL, OPTIONAL, INTENT(IN) :: allowTopValue ! Can return N
    LOGICAL, OPTIONAL, INTENT(IN) :: allowBelowValue ! Can return 0
d211 2
a212 2
    REAL(R8), DIMENSION(1) :: values ! To pass to HuntArray
    INTEGER, DIMENSION(1) :: indices ! To pass to HuntScalar
d215 1
a215 1
    CALL HuntArray(list,values,indices,start,allowTopValue,allowBelowValue)
d217 1
a217 1
  END SUBROUTINE HuntScalar
d234 2
a235 2
  SUBROUTINE InterpolateArray(oldX,oldY,newX,newY,method,extrapolate, &
       & badValue,missingRegions,dyByDx,dNewByDOld)
d238 11
a248 11
    REAL(R8), DIMENSION(:), INTENT(IN) :: oldX
    REAL(R8), DIMENSION(:,:), INTENT(IN) :: oldY
    REAL(R8), DIMENSION(:), INTENT(IN) :: newX
    REAL(R8), DIMENSION(:,:), INTENT(OUT) :: newY

    CHARACTER (LEN=*), INTENT(IN) :: method ! See comments above
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN) :: extrapolate ! See comments above
    REAL(R8), OPTIONAL, INTENT(IN) :: badValue
    REAL(R8), DIMENSION(:,:), OPTIONAL, INTENT(OUT) :: dyByDx
    LOGICAL, OPTIONAL, INTENT(IN) :: missingRegions ! Allow missing regions
    TYPE (MatrixElement_T), INTENT(OUT), OPTIONAL :: dNewByDOld ! Derivatives
d251 31
a281 31
    INTEGER :: noOld,noNew,width ! Dimensions
    LOGICAL :: spline           ! Flag
    LOGICAL :: useMissingRegions ! Copy of missing regions
    INTEGER :: ind,newInd       ! Loop counters
    LOGICAL :: computeDNewByDOld   ! Set if dNewByDOld is present

    INTEGER, DIMENSION(:),    POINTER :: lowerInds=> NULL()
    INTEGER, DIMENSION(:),    POINTER :: upperInds=> NULL()
    REAL(R8), DIMENSION(:),   POINTER :: maskVector=> NULL()
    REAL(R8), DIMENSION(:),   POINTER :: gap=>NULL()
    REAL(R8), DIMENSION(:),   POINTER :: gap2=> NULL()
    REAL(R8), DIMENSION(:,:), POINTER :: spreadGap=> NULL()
    REAL(R8), DIMENSION(:,:), POINTER :: oldSecond=> NULL()
    REAL(R8), DIMENSION(:,:), POINTER :: oldYupper=> NULL()
    REAL(R8), DIMENSION(:,:), POINTER :: oldYlower=> NULL()
    REAL(R8), DIMENSION(:,:), POINTER :: oldSecondLower=> NULL()
    REAL(R8), DIMENSION(:,:), POINTER :: oldSecondUpper=> NULL()
    REAL(R8), DIMENSION(:),   POINTER :: A=> NULL()
    REAL(R8), DIMENSION(:),   POINTER :: B=> NULL()
    REAL(R8), DIMENSION(:),   POINTER :: C=> NULL()
    REAL(R8), DIMENSION(:),   POINTER :: D=> NULL() ! Coefficients
    REAL(R8), DIMENSION(:,:), POINTER :: AA=> NULL()
    REAL(R8), DIMENSION(:,:), POINTER :: BB=> NULL()
    REAL(R8), DIMENSION(:,:), POINTER :: CC=> NULL()
    REAL(R8), DIMENSION(:,:), POINTER :: DD=> NULL() ! Spread coefs.
    REAL(R8), DIMENSION(:,:), POINTER :: temp=> NULL() ! For 2nd der. guess
    REAL(R8), DIMENSION(:),   POINTER :: p=> NULL() ! For 2nd der. guess
    REAL(R8), DIMENSION(:,:), POINTER :: tempDNewByDOld=> NULL() ! Dense version.
    REAL(R8) :: sig       ! For second derivative guesser
    
    CHARACTER :: extrapolateMethod ! Tidy copy of extrapolate parameter
d287 3
a289 3
    noOld=SIZE(oldX,1)
    noNew=SIZE(newX,1)
    width=SIZE(oldY,2)
d294 1
a294 1
    IF (PRESENT(extrapolate)) extrapolateMethod=Capitalize(extrapolate(1:1))
d296 2
a297 2
       useMissingRegions=.FALSE.
    IF (PRESENT(missingRegions)) useMissingRegions=missingRegions
d299 1
a299 1
    computeDNewByDOld=PRESENT(dNewByDOld)
d301 15
a315 15
    IF (useMissingRegions.AND.spline) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Cannot use missing regions with spline")

    IF (computeDNewByDOld .AND. spline) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         "Cannont get dNewBydOld from spline")

    CALL Allocate_Test(lowerInds,noNew,"lowerInds",ModuleName)
    CALL Allocate_Test(upperInds,noNew,"upperInds",ModuleName)
    CALL Allocate_Test(gap,noNew,"gap",ModuleName)
    CALL Allocate_Test(A,noNew,"A",ModuleName)
    CALL Allocate_Test(B,noNew,"B",ModuleName)
    CALL Allocate_Test(AA,noNew,width,"AA",ModuleName)
    CALL Allocate_Test(BB,noNew,width,"BB",ModuleName)
    CALL Allocate_Test(oldYlower,noNew,width,"oldYlower",ModuleName)
    CALL Allocate_Test(oldYupper,noNew,width,"oldYupper",ModuleName)
d319 2
a320 2
    IF (PRESENT(dyByDx)) CALL Allocate_Test(spreadGap,noNew,width,&
         "spreadGap",ModuleName)
d323 4
a326 4
    IF (computeDNewByDOld) THEN
       CALL CreateBlock_0(dNewByDOld,noNew*width,noOld*width,M_Column_Sparse,&
            NumberNonZero=2*noNew*width)
    ENDIF
d331 35
a365 35
    IF (spline) THEN
       CALL Allocate_Test(oldSecond,noOld,width,"oldSecond",ModuleName)
       CALL Allocate_Test(C,noNew,"C",ModuleName)
       CALL Allocate_Test(D,noNew,"D",ModuleName)
       CALL Allocate_Test(CC,noNew,width,"CC",ModuleName)
       CALL Allocate_Test(DD,noNew,width,"DD",ModuleName)
       CALL Allocate_Test(oldSecondlower,noNew,width,"oldSecondlower",ModuleName)
       CALL Allocate_Test(oldSecondupper,noNew,width,"oldSecondupper",ModuleName)
       CALL Allocate_Test(gap2,noNew,"gap2",ModuleName)
       CALL Allocate_Test(temp,noOld,width,"temp",ModuleName)
       CALL Allocate_Test(p,width,"p",ModuleName)

       ! Here we have to solve the a tridiagonal equation
       ! This is a straight copy of my idl code
       oldSecond(1,:)=0.0D0
       temp(1,:)=0.0D0
       DO ind=2,noOld-1
          sig=(oldX(ind)-oldX(ind-1))/(oldX(ind+1)-oldX(ind-1))
          p=sig*oldSecond(ind-1,:)+2.0D0
          oldSecond(ind,:)=(sig-1.0D0)/p
          temp(ind,:)=(oldY(ind+1,:)-oldY(ind,:))/(oldX(ind+1)-oldX(ind)) - &
               & (oldY(ind,:)-oldY(ind-1,:))/(oldX(ind)-oldX(ind-1))
          temp(ind,:)=(6.0D0*temp(ind,:)/ &
               & (oldX(ind+1)-oldX(ind-1))-sig*temp(ind-1,:))/p
       ENDDO
       oldSecond(noOld,:)=0.0D0
       
       ! Now do the back substitution
       DO ind=noOld-1,1,-1
          oldSecond(ind,:)=oldSecond(ind,:)*oldSecond(ind+1,:)+temp(ind,:)
       ENDDO

       CALL Deallocate_test(temp,"Temp",ModuleName) 
       CALL Deallocate_test(p,"p",ModuleName)
    ENDIF
d371 1
a371 1
    IF (PRESENT(dyByDx)) dyByDx=0.0D0
d375 1
a375 1
    CALL Hunt(oldX,newX,lowerInds)
d378 1
a378 1
    IF (PRESENT(dyByDx)) spreadGap=SPREAD(gap,2,width)
d383 1
a383 1
    IF (extrapolateMethod=="C") A=MAX(MIN(A,1.0D0),0.0D0)
d388 12
a399 12
    IF (extrapolateMethod=="B") THEN
       CALL Allocate_Test(maskVector,noNew,"maskVector",ModuleName)
       maskVector=0.0D0
       WHERE ((A<0.0D0).OR.(A>1.0D0))
          maskVector=badValue
          A=0.0D0
          B=0.0D0
       END WHERE
       newY=SPREAD(maskVector,2,width)
       IF (PRESENT(dyByDx)) dyByDx=newY
       CALL Deallocate_Test(maskVector,"maskVector",ModuleName)
    ENDIF
d402 2
a403 2
    AA=SPREAD(A,2,width)
    BB=SPREAD(B,2,width)
d408 124
a531 83
    IF (useMissingRegions) THEN
       WHERE( (oldYlower==badValue) .OR. (oldYupper==badValue))
          newY=badValue
          AA=0.0D0
          BB=0.0D0
       END WHERE
       IF (PRESENT(dyByDx)) THEN
          WHERE( (oldYlower==badValue) .OR. &
               & (oldYupper==badValue))
             dyByDx=badValue
             oldYlower=0.0      ! Only way to guarentee bad derivative
             oldYupper=0.0      ! But don't need to worry about spline
          ENDWHERE
       ENDIF
    ENDIF

    ! Now do the linear interpolation calculation
    newY=newY+AA*oldYlower+BB*oldYupper
    IF (PRESENT(dyByDx)) dyByDx=(oldYupper-oldYlower)/spreadGap

    ! Write the output derivative matrix if needed
    IF (computeDNewByDOld) THEN
       ! While the matrix is ideally suited to row sparse, our storage method
       ! is column sparse, so to be lazy we'll create it full and then sparsify
       ! it.
       !
       CALL Allocate_Test(tempDNewByDOld,noNew*width,noOld*width,&
            "tempDNewByDOld",ModuleName)
       DO newInd=1,noNew
          DO ind=1,width
             tempDNewByDOld(newInd+ind*noNew,lowerInds(newInd)+ind*noOld)=A(newInd)
             tempDNewByDOld(newInd+ind*noNew,upperInds(newInd)+ind*noOld)=B(newInd)
          ENDDO
       ENDDO
       CALL Sparsify ( tempDNewByDOld, dNewbyDOld, &
         & "tempDNewByDOld", ModuleName ) ! dNewbyDOld := tempDNewByDOld
    ENDIF

    ! Now do the spline calculation
    IF (spline) THEN
       gap2=gap**2
       C=(A**3-A)*gap2/6.0D0    ! Note the extrapolate bad case is covered as..
       D=(B**3-B)*gap2/6.0D0    !   A=B=0.0D0

       ! Spread out the coefficients etc.
       CC=SPREAD(C,2,width)
       DD=SPREAD(D,2,width)
       oldSecondLower=oldSecond(lowerInds,:)
       oldSecondUpper=oldSecond(upperInds,:)
       
       newY=newY+CC*oldSecondLower+DD*oldSecondUpper
       IF (PRESENT(dyByDx)) dyByDx=dyByDx+(spreadGap/6.0D0)*( &
            & (3.0D0*BB**2-1.0D0)*oldSecondUpper- &
            & (3.0D0*AA**2-1.0D0)*oldSecondLower)
    ENDIF

    CALL Deallocate_Test(lowerInds,"lowerInds",ModuleName)
    CALL Deallocate_Test(upperInds,"upperInds",ModuleName)
    CALL Deallocate_Test(gap,"gap",ModuleName)
    CALL Deallocate_Test(A,"A",ModuleName)
    CALL Deallocate_Test(B,"B",ModuleName)
    CALL Deallocate_Test(AA,"AA",ModuleName)
    CALL Deallocate_Test(BB,"BB",ModuleName)
    CALL Deallocate_Test(oldYlower,"oldYlower",ModuleName)
    CALL Deallocate_Test(oldYupper,"oldYupper",ModuleName)

    IF (spline) THEN
       CALL Deallocate_Test(oldSecond,"oldSecond",ModuleName)
       CALL Deallocate_Test(C,"C",ModuleName)
       CALL Deallocate_Test(D,"D",ModuleName)
       CALL Deallocate_Test(CC,"CC",ModuleName)
       CALL Deallocate_Test(DD,"DD",ModuleName)
       CALL Deallocate_Test(oldSecondlower,"oldSecondlower",ModuleName)
       CALL Deallocate_Test(oldSecondupper,"oldSecondupper",ModuleName)
       CALL Deallocate_Test(gap2,"gap2",ModuleName)
       CALL Deallocate_Test(temp,"temp",ModuleName)
       CALL Deallocate_Test(p,"p",ModuleName)
    ENDIF
    IF (PRESENT(dyByDx)) CALL Deallocate_Test(spreadGap,"spreadGap",ModuleName)

  END SUBROUTINE InterpolateArray

  ! --------------------------------------------------------------------------
a532 41
  ! This subroutine is a scalar wrapper for the first one.

  SUBROUTINE InterpolateScalar(oldX,oldY,newX,newY,method,extrapolate, &
       & badValue,missingRegions,dyByDx)

    ! Dummy arguments
    REAL(R8), DIMENSION(:), INTENT(IN) :: oldX
    REAL(R8), DIMENSION(:), INTENT(IN) :: oldY
    REAL(R8), DIMENSION(:), INTENT(IN) :: newX
    REAL(R8), DIMENSION(:), INTENT(OUT) :: newY

    CHARACTER (LEN=*), INTENT(IN) :: method ! See comments above
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN) :: extrapolate ! See comments above
    REAL(R8), OPTIONAL, INTENT(IN) :: badValue
    REAL(R8), DIMENSION(:), OPTIONAL, INTENT(OUT) :: dyByDx
    LOGICAL, OPTIONAL, INTENT(IN) :: missingRegions ! Allow missing regions

    REAL(R8), DIMENSION(:,:), POINTER :: tempResult => NULL()
    REAL(R8), DIMENSION(:,:), POINTER :: tempDerivative => NULL()

    ! Executable code

    CALL Allocate_Test(tempResult,SIZE(newX),1,"tempResult",ModuleName)
    IF (PRESENT(dyByDx)) THEN
       CALL Allocate_Test(tempDerivative,SIZE(newX),1,"tempDerivative",ModuleName)

       CALL InterpolateArray(oldX,SPREAD(oldY,2,1),newX,tempResult,method, &
            & extrapolate=extrapolate, badValue=badValue, &
            & missingRegions=missingRegions, dyByDx=tempDerivative)
       dyByDx=RESHAPE(tempDerivative,SHAPE(newX))

       CALL Deallocate_Test(tempDerivative,"tempDerivative",ModuleName)
    ELSE
       CALL InterpolateArray(oldX,SPREAD(oldY,2,1),newX,tempResult,method, &
            & extrapolate=extrapolate, badValue=badValue, &
            & missingRegions=missingRegions)
    ENDIF
    newY=RESHAPE(tempResult,SHAPE(newX))
    CALL Deallocate_test(tempResult,"tempResult",ModuleName)
  END SUBROUTINE InterpolateScalar
    
d534 1
a534 1
END MODULE MLSNumerics
d539 3
@


2.5
log
@Let sparsify do the deallocate_test
@
text
@d18 1
a18 1
       "$Id: MLSNumerics.f90,v 2.4 2001/03/06 00:35:23 livesey Exp $"
d352 1
a352 1
       DO ind=noOld,1,-1
d532 3
@


2.4
log
@Missed one pointer nullification
@
text
@d18 1
a18 1
       "$Id: MLSNumerics.f90,v 2.3 2001/03/05 01:20:36 livesey Exp $"
d435 2
a436 2
       CALL Sparsify(tempDNewByDOld,dNewbyDOld)
       CALL Deallocate_test(tempDNewByDOld,"tempDNewByDOld",ModuleName)
d532 3
@


2.3
log
@Nullified pointers
@
text
@d18 1
a18 1
       "$Id: MLSNumerics.f90,v 2.2 2001/02/22 01:59:52 vsnyder Exp $"
d253 2
a254 1
    REAL(R8), DIMENSION(:),   POINTER :: gap,gap2=> NULL()
d532 3
@


2.2
log
@Remove declarations for unused variables and parameters
@
text
@d18 1
a18 1
       "$Id: MLSNumerics.f90,v 2.1 2001/02/09 00:38:55 livesey Exp $"
d250 21
a270 13
    INTEGER, DIMENSION(:), POINTER :: lowerInds,upperInds
    REAL(R8), DIMENSION(:),   POINTER :: maskVector
    REAL(R8), DIMENSION(:),   POINTER :: gap,gap2
    REAL(R8), DIMENSION(:,:), POINTER :: spreadGap
    REAL(R8), DIMENSION(:,:), POINTER :: oldSecond
    REAL(R8), DIMENSION(:,:), POINTER :: oldYupper,oldYlower
    REAL(R8), DIMENSION(:,:), POINTER :: oldSecondLower
    REAL(R8), DIMENSION(:,:), POINTER :: oldSecondUpper
    REAL(R8), DIMENSION(:),   POINTER :: A,B,C,D ! Coefficients
    REAL(R8), DIMENSION(:,:), POINTER :: AA,BB,CC,DD ! Spread coefs.
    REAL(R8), DIMENSION(:,:), POINTER :: temp ! For 2nd der. guess
    REAL(R8), DIMENSION(:),   POINTER :: p ! For 2nd der. guess
    REAL(R8), DIMENSION(:,:), POINTER :: tempDNewByDOld ! Dense version.
d501 2
a502 2
    REAL(R8), DIMENSION(:,:), POINTER :: tempResult
    REAL(R8), DIMENSION(:,:), POINTER :: tempDerivative
d531 3
@


2.1
log
@Various changes
@
text
@d18 1
a18 1
       "$Id: MLSNumerics.f90,v 2.0 2000/09/05 17:41:06 dcuddy Exp $"
a242 3
    ! Local parameters
    CHARACTER (LEN=*), PARAMETER :: MLSMSG_Allocate="Allocation failed for "

a247 1
    INTEGER :: status           ! From Allocate
a492 6
    ! Local parameters
    CHARACTER (LEN=*), PARAMETER :: MLSMSG_Allocate="Allocation failed for "

    ! Local variables
    INTEGER :: status

d523 3
@


2.0
log
@Change revision to 2.0
@
text
@d5 5
a9 3
  UsE MLSCommon
  USE MLSMessageModule
  USE MLSStrings
d18 1
a18 1
       "$Id: MLSNumerics.f90,v 1.13 2000/06/23 01:08:48 vsnyder Exp $"
d228 1
a228 1
       & badValue,missingRegions,dyByDx)
d241 1
d250 1
a250 1
    INTEGER :: ind           ! Loop counter
d252 1
d254 13
a266 12
    INTEGER, DIMENSION(:), ALLOCATABLE :: lowerInds,upperInds
    REAL(R8), DIMENSION(:),   ALLOCATABLE :: maskVector
    REAL(R8), DIMENSION(:),   ALLOCATABLE :: gap,gap2
    REAL(R8), DIMENSION(:,:), ALLOCATABLE :: spreadGap
    REAL(R8), DIMENSION(:,:), ALLOCATABLE :: oldSecond
    REAL(R8), DIMENSION(:,:), ALLOCATABLE :: oldYupper,oldYlower
    REAL(R8), DIMENSION(:,:), ALLOCATABLE :: oldSecondLower
    REAL(R8), DIMENSION(:,:), ALLOCATABLE :: oldSecondUpper
    REAL(R8), DIMENSION(:),   ALLOCATABLE :: A,B,C,D ! Coefficients
    REAL(R8), DIMENSION(:,:), ALLOCATABLE :: AA,BB,CC,DD ! Spread coefs.
    REAL(R8), DIMENSION(:,:), ALLOCATABLE :: temp ! For 2nd der. guess
    REAL(R8), DIMENSION(:),   ALLOCATABLE :: p ! For 2nd der. guess
d281 2
a282 5
    IF (PRESENT(extrapolate)) THEN
       extrapolateMethod=Capitalize(extrapolate(1:1))
    ELSE
       extrapolateMethod="A"
    ENDIF
a283 3
    IF (PRESENT(missingRegions)) THEN
       useMissingRegions=missingRegions
    ELSE
d285 3
a287 1
    ENDIF
d292 12
a303 19
    ALLOCATE(lowerInds(noNew),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"lowerInds")
    ALLOCATE(upperInds(noNew),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"upperInds")
    ALLOCATE(gap(noNew),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"gap")

    ALLOCATE(A(noNew),B(noNew),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"A or B")
    ALLOCATE(AA(noNew,width),BB(noNew,width),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"AA or BB")
    ALLOCATE(oldYlower(noNew,width),oldYupper(noNew,width),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"oldYupper or oldYlower")
d307 7
a313 4
    IF (PRESENT(dyByDx)) THEN
       ALLOCATE(spreadGap(noNew,width),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            MLSMSG_Allocate//"spreadGap")
d320 10
a329 23
       ALLOCATE(oldSecond(noOld,width),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            MLSMSG_Allocate//"oldSecond")
       ALLOCATE(C(noNew),D(noNew),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"C or D")
       ALLOCATE(CC(noNew,width),DD(noNew,width),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"CC or DD")
       ALLOCATE(oldSecondLower(noNew,width),&
            & oldSecondUpper(noNew,width),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"oldSecondLower or oldSecondUpper")
       ALLOCATE(gap2(noNew),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"gap2")

       ALLOCATE(temp(noOld,width),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"temp")
       ALLOCATE(p(width),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"p")
d351 2
a352 3
       DEALLOCATE(temp,p, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp p")
d377 1
a377 3
       ALLOCATE(maskVector(noNew),STAT=status)
       IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"maskVector")
d386 1
a386 3
       DEALLOCATE(maskVector, stat=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"maskVector")
d416 18
d452 23
a474 10
    DEALLOCATE (lowerInds,upperInds,gap,A,B,AA,BB,oldYlower,oldYupper, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"lowerInds")
    IF (spline) DEALLOCATE(gap2,oldSecond,C,D,CC,DD, &
         & oldSecondLower,oldSecondUpper, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"gap2")
    IF (PRESENT(dyByDx)) DEALLOCATE(spreadGap, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"spreadGap")
d503 2
a504 2
    REAL(R8), DIMENSION(:,:), ALLOCATABLE :: tempResult
    REAL(R8), DIMENSION(:,:), ALLOCATABLE :: tempDerivative
d508 1
a508 4
    ALLOCATE(tempResult(SIZE(newX),1),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         MLSMSG_Allocate//"tempResult")

d510 1
a510 3
       ALLOCATE(tempDerivative(SIZE(newX),1),STAT=status)
       IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            MLSMSG_Allocate//"tempDerivative")
d516 2
a517 3
       DEALLOCATE(tempDerivative, stat=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"tempDerivative")
d524 1
a524 3
    DEALLOCATE(tempResult, stat=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"tempResult")
d533 3
@


1.13
log
@Delete unused variables (except ID) to keep NAG f95 happy
@
text
@d16 1
a16 1
       "$Id: MLSNumerics.f90,v 1.13 2000/06/23 01:08:48 vsnyder Exp $"
d531 3
a535 37
!
! Revision 1.12  2000/06/19 23:55:23  lungu
! Added status check after each DEALLOCATE.
!
! Revision 1.11  1999/12/16 17:40:53  livesey
! Whoops, fix to make it complile, subroutine name mismatch.
!
! Revision 1.10  1999/12/16 00:53:57  livesey
! Added HuntScalar and generic interface
!
! Revision 1.9  1999/12/14 01:01:33  livesey
! Changed DOUBLE PRECISION to REAL(r8)
!
! Revision 1.8  1999/12/01 23:01:40  livesey
! Before renaming things to upper/lower case
!
! Revision 1.7  1999/12/01 00:27:47  livesey
! Added a few more comments
!
! Revision 1.6  1999/12/01 00:22:04  livesey
! A stable version.
!
! Revision 1.5  1999/11/30 21:14:28  livesey
! Almost ready, still need to complete the spline part.
!
! Revision 1.4  1999/11/30 19:01:57  livesey
! Before we tried to vectorise things
!
! Revision 1.3  1999/11/30 04:00:28  livesey
! Tidied up some of the loop ordering
!
! Revision 1.2  1999/11/30 03:51:15  livesey
! Skeleton version of InterpolateValues (linear only, no derivatives)
!
! Revision 1.1  1999/11/29 23:14:14  livesey
! First version of hunt
!
@


1.1
log
@First version of hunt
@
text
@d5 4
d10 1
d13 6
a18 5
  PRIVATE :: id
!------------------------------- RCS Ident Info ------------------------------
CHARACTER(LEN=130) :: id = & 
   "$Id: MLSNumerics.f90,v 1.1 1999/11/29 23:14:14 livesey Exp $"
!-----------------------------------------------------------------------------
d25 12
d40 3
a42 1
  ! hunt/bisect implemention a la Numerical Recipes
d44 1
a44 1
  SUBROUTINE Hunt(list,values,indices,start,allowTopValue,allowBelowValue)
d47 2
a48 2
    DOUBLE PRECISION, DIMENSION(:), INTENT(IN) :: list ! List to search
    DOUBLE PRECISION, DIMENSION(:), INTENT(IN) :: values ! Values to search for
d55 2
a56 2
    INTEGER :: listLen,valuesLen ! Array sizes
    INTEGER :: valueIndex,listIndex ! Loop counters
d64 2
d69 1
d71 1
a71 1
    DOUBLE PRECISION :: thisValue
d95 2
a96 2
    IF (SIZE(indices) < valuesLen) CALL MLSMessage("Result array is too small",&
         & error=.TRUE.)
d119 1
a119 1
    index=useStart
d124 1
d126 3
a128 3
          lowerBelow= (thisValue-list(index))*direction <= 0.0
          IF (index LT listLen) THEN 
             upperAbove= (thisValue-list(index+1))*direction > 0.0
d142 2
d151 1
a151 1
             IF (index EQ 1) EXIT HuntLoop
d179 1
a179 1
          IF ((thisValue-list(index))*direction<0.0) index=0
d184 270
a453 1
  END SUBROUTINE Hunt
d455 37
d493 32
d531 36
@


