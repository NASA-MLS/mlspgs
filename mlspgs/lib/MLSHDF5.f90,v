head	2.151;
access;
symbols
	v5-02-NRT-19:2.151
	v6-00:2.150
	v5-02-NRT-18:2.150
	v5-02:2.148
	v5-01-NRT-17:2.150
	v5-01-NRT-16:2.150
	v5-01-NRT-15:2.150
	v5-01-NRT-14:2.150
	neuralnetworks-1-0:2.148.0.4
	cfm-single-freq-0-1:2.148.0.2
	v5-01:2.148
	v5-00:2.148
	v4-23-TA133:2.146.0.2
	mus-emls-1-70:2.145.0.2
	rel-1-0-englocks-work:2.142.0.2
	VUMLS1-00:2.139
	VPL1-00:2.138
	V4-22-NRT-08:2.134
	VAM1-00:2.132
	V4-21:2.131.0.2
	V4-13:2.129
	V4-12:2.128
	V4-11:2.127
	V4-10:2.127
	V3-43:2.111.2.1
	M4-00:2.119
	V3-41:2.111.2.1
	V3-40-PlusGM57:2.111.0.2
	V2-24-NRT-04:2.75
	V3-33:2.103
	V2-24:2.75
	V3-31:2.103
	V3-30-NRT-05:2.100
	cfm-01-00:2.99
	V3-30:2.99
	V3-20:2.99
	V3-10:2.92
	V2-23-NRT-02:2.75
	V2-23:2.75
	V2-22-NRT-01:2.75
	V2-22:2.75
	V2-21:2.72
	V2-20:2.69
	V2-11:2.67
	V2-10:2.67
	V2-00:2.64
	V1-51:2.46
	V1-50:2.46
	V1-45:2.44
	V1-44:2.44
	V1-43:2.38
	V1-42:2.34
	V1-41:2.34
	V1-32:2.35
	V1-40:2.34
	V1-31:2.34
	V1-30:2.32
	V1-13:2.21
	V1-12:2.21
	V1-11:2.20
	V1-10:2.18
	newfwm-feb03:2.19.0.2;
locks; strict;
comment	@# @;


2.151
date	2024.06.03.20.39.45;	author pwagner;	state Exp;
branches;
next	2.150;

2.150
date	2021.04.01.23.50.02;	author pwagner;	state Exp;
branches;
next	2.149;

2.149
date	2021.02.05.05.13.15;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2019.06.26.22.56.10;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2019.06.06.23.50.31;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2018.11.12.23.12.27;	author pwagner;	state Exp;
branches;
next	2.145;

2.145
date	2018.05.15.03.16.59;	author vsnyder;	state Exp;
branches;
next	2.144;

2.144
date	2018.05.11.21.29.52;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2018.04.13.00.15.41;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2017.08.10.22.42.23;	author pwagner;	state Exp;
branches;
next	2.141;

2.141
date	2017.08.04.19.42.14;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2017.07.25.22.30.34;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2017.02.09.23.45.48;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2016.08.09.18.12.16;	author pwagner;	state Exp;
branches;
next	2.137;

2.137
date	2016.07.28.19.24.37;	author pwagner;	state Exp;
branches;
next	2.136;

2.136
date	2016.07.28.01.42.27;	author vsnyder;	state Exp;
branches;
next	2.135;

2.135
date	2016.07.27.22.14.06;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2016.04.05.23.53.51;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2016.01.20.00.23.09;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2015.07.14.23.17.17;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2014.12.09.01.25.30;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2014.10.27.23.04.06;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2014.09.05.00.05.14;	author vsnyder;	state Exp;
branches;
next	2.128;

2.128
date	2014.07.18.21.59.17;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2014.04.29.17.10.12;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2014.03.07.19.13.47;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2013.11.01.00.05.13;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2013.09.14.00.37.20;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2013.08.31.01.24.53;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2013.08.20.00.30.38;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2012.05.17.20.19.07;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2012.05.08.01.15.42;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2012.01.25.01.12.07;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2012.01.13.01.10.14;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2011.11.04.23.41.16;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2011.11.03.23.48.10;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2011.11.01.21.01.34;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2011.10.25.17.56.09;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2011.08.04.17.38.18;	author pwagner;	state Exp;
branches
	2.111.2.1;
next	2.110;

2.110
date	2011.08.04.16.57.35;	author honghanh;	state Exp;
branches;
next	2.109;

2.109
date	2011.08.04.16.45.06;	author honghanh;	state Exp;
branches;
next	2.108;

2.108
date	2011.08.02.16.53.00;	author honghanh;	state Exp;
branches;
next	2.107;

2.107
date	2011.07.15.23.33.11;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2011.05.06.00.35.33;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2011.05.05.15.14.45;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2011.03.16.18.19.47;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2011.02.05.01.35.34;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2011.01.12.18.08.33;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2010.11.23.01.11.07;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2010.08.27.20.59.06;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2010.01.11.18.33.57;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2009.11.16.21.55.55;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2009.11.10.00.31.43;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2009.10.05.23.38.59;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2009.09.29.23.31.24;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2009.08.04.20.44.08;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2009.06.16.17.14.24;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2009.05.08.00.42.04;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2009.04.01.23.27.27;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2008.06.18.20.56.55;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2008.05.24.00.54.46;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2008.05.24.00.34.05;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2008.05.22.01.06.42;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2008.05.20.01.59.28;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2008.05.10.01.14.04;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2008.05.02.00.05.19;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2008.04.25.22.51.23;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2008.04.22.17.17.38;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2008.04.18.16.29.06;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2008.03.07.01.35.47;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2008.02.22.21.29.13;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2008.01.04.01.00.13;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2007.10.04.20.43.36;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2007.10.03.23.51.53;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2007.08.17.00.27.48;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2007.01.31.00.07.23;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2007.01.26.23.59.13;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2007.01.12.00.29.28;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2006.08.23.18.04.23;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2006.08.22.20.41.23;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2006.07.11.00.24.36;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2006.06.29.20.38.20;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2006.06.27.23.59.05;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2006.04.12.20.51.24;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2006.01.25.00.57.39;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2005.11.17.20.09.24;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2005.11.11.21.36.00;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2005.10.28.23.13.42;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2005.10.19.20.46.05;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2005.10.18.23.01.43;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2005.10.11.17.35.00;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2005.07.12.17.12.50;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2005.06.29.00.40.48;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2005.06.22.17.25.49;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2005.04.29.21.55.17;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2005.01.12.03.04.15;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2005.01.07.01.57.53;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2005.01.07.01.14.26;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2005.01.07.01.04.37;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2005.01.07.00.38.17;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2004.12.31.02.38.53;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2004.12.13.20.26.53;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2004.09.23.23.00.10;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2004.08.04.23.19.01;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2004.08.03.18.00.28;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2004.07.22.20.37.11;	author cvuu;	state Exp;
branches;
next	2.41;

2.41
date	2004.06.29.00.07.00;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2004.06.08.18.59.59;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2004.05.25.20.35.53;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2004.05.19.19.08.05;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2004.03.25.18.38.13;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2004.03.24.23.50.27;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2004.02.26.21.59.09;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2003.10.02.23.09.47;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2003.09.30.18.29.41;	author perun;	state Exp;
branches;
next	2.32;

2.32
date	2003.09.12.16.40.27;	author cvuu;	state Exp;
branches;
next	2.31;

2.31
date	2003.08.07.15.44.19;	author perun;	state Exp;
branches;
next	2.30;

2.30
date	2003.07.24.22.10.45;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2003.07.21.23.30.23;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2003.07.18.16.04.19;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2003.07.15.23.37.57;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2003.05.19.22.06.31;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2003.05.13.04.46.42;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2003.05.12.18.08.10;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2003.05.12.16.51.20;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2003.04.28.23.08.20;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2003.03.20.19.21.11;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2003.02.21.23.41.02;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2003.02.12.21.38.14;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2003.01.30.00.56.01;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2003.01.27.21.38.44;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2003.01.23.23.30.49;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2002.12.07.00.24.40;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2002.12.02.23.35.57;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2002.10.29.01.01.05;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2002.10.11.23.42.04;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2002.10.10.23.51.57;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2002.10.08.00.09.11;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2002.10.04.22.22.52;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2002.10.02.23.20.07;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2002.09.27.23.39.26;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2002.09.26.23.56.15;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2002.09.13.18.08.12;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2002.08.26.16.42.09;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2002.08.23.01.23.21;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2002.07.17.06.00.21;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2002.07.11.22.18.26;	author pwagner;	state Exp;
branches;
next	;

2.111.2.1
date	2011.11.16.23.33.51;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.151
log
@Dont reference optional arg error
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module MLSHDF5

  ! This module contains MLS specific routines to do lowish level common HDF5
  ! tasks.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Dump_Options, only: Dopt_Laconic, Dopt_RMS, Dopt_Stats, Dopt_Verbose, &
    & NameOnEachLine
  use Dump_0, only: Dump
  use Dump_1, only: DumpNamedValues
  use Hdf, only: DFACC_RDOnly
  use HighOutput, only: OutputNamedValue
  use Intrinsic, only: L_Hdf
  use Machine, only: Crash_Burn
  use MLSCommon, only: MLSFile_T
  use MLSDataInfo, only: MLSDataInfo_T, Query_MLSData
  use MLSFiles, only: HDFVersion_5, &
    & Dump, InitializeMLSFile, MLS_CloseFile, MLS_OpenFile
  use MLSKinds, only: R8
  use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Info, MLSMSG_Warning, &
    & MLSMessage
  use MLSFinds, only: FindFirst
  use MLSStringLists, only: CatLists, IsInList, &
    & GetStringElement, Intersection, NumStringElements, StringElement
  use MLSStrings, only: Indexes, Lowercase, Replace, Trim_Safe
  use Optional_M, only: Print_Default
  use Output_M, only: Newline, Output
  use Trace_M, only: Trace_Begin, Trace_End
  ! Let's Break Down Our Use, Parameters First
  use HDF5, only: H5f_Acc_Rdonly_F, H5f_Acc_Rdwr_F, &
    & H5G_Group_F, H5p_Dataset_Create_F, &
    & H5sis_Simple_F, & ! H5soffset_Simple_F, &
    & H5s_Scalar_F, H5s_Select_Set_F, H5s_Unlimited_F, &
    & H5t_Ieee_F32le, H5t_Ieee_F64le, H5t_Ieee_F64le, &
    & H5t_Native_Double, H5t_Native_Real, H5t_Std_I32le, &
    & H5t_Native_Character, H5t_Native_Integer, H5t_String, H5t_String_F, &
    & Hid_T, Hsize_T, Size_T
  ! Now Routines
  use HDF5, only: H5aclose_F, H5acreate_F, &
    & H5aget_Name_F, H5aget_Num_Attrs_F, &
    & H5aget_Space_F, H5aget_Type_F, H5aopen_Idx_F, H5aopen_Name_F, &
    & H5aread_F, H5awrite_F, H5adelete_F, &
    & H5dcreate_F, H5dextend_F, H5dget_Space_F, H5dget_Type_F, H5dopen_F, &
    & H5dread_F, H5dwrite_F, H5dclose_F, H5dget_Create_Plist_F, &
    & H5eSet_Auto_F, &
    & H5fopen_F, H5fclose_F, &
    & H5gopen_F, H5gclose_F, h5gCreate_f, &
    & H5gn_Members_F, H5gget_Obj_Info_Idx_F, &
    & H5pcreate_F, H5pset_Chunk_F, H5pset_Fill_Value_F, &
    & H5pget_Chunk_F, H5pget_Fill_Value_F, &
    & H5sclose_F, &
    & H5screate_F, H5screate_Simple_F, H5sget_Simple_Extent_Ndims_F, &
    & H5sget_Simple_Extent_Dims_F, H5sselect_Hyperslab_F, &
    & H5tclose_F, H5tcopy_F, H5tequal_F, H5tget_Class_F, H5tget_Size_F, &
    & H5tset_Size_F

  implicit none
  private

  public :: CpHDF5Attribute, CpHDF5GlAttribute, &
    & DumpHDF5Attributes, DumpHDF5DS, &
    & GetAllHDF5AttrNames, GetAllHDF5DSNames, GetAllHDF5GroupNames, &
    & GetHDF5Attribute, GetHDF5AttributePtr, GetHDF5AttrDims, &
    & GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType, &
    & IsHDF5AttributeInFile, IsHDF5AttributePresent, IsHDF5DSInFile, &
    & IsHDF5DSPresent, IsHDF5GroupPresent, IsHDF5ItemPresent, &
    & LoadAllocFromHDF5DS, LoadFromHDF5DS, LoadPtrFromHDF5DS, &
    & MakeHDF5Attribute, MakeNestedGroups, MatchHDF5Attributes, &
    & MLS_H5Open, MLS_H5Close, ReadHDF5Attribute, &
    & ReadLitIndexFromHDF5Attr, ReadStringIndexFromHDF5Attr, SaveAsHDF5DS, &
    & WriteLitIndexAsHDF5Attribute, WriteStringIndexAsHDF5Attribute

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSHDF5.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

! CpHDF5Attribute      Copies an attribute
! CpHDF5GlAttribute    Copies a global attribute
! DumpHDF5Attributes   Dumps attributes
! DumpHDF5DS           Dumps datasets
! GetAllHDF5AttrNames  Retrieves names of all attributes under itemID
! GetAllHDF5DSNames    Retrieves names of all DS in file (under group name)
! GetAllHDF5GroupNames Retrieves names of all groups in file (under group name)
! GetHDF5Attribute     Retrieves an attribute
! GetHDF5AttributePtr  Allocates an array for an attribute and retrieves it
! GetHDF5DSRank        How many dimensions in dataset
! GetHDF5DSDims        Size of the dimensions in dataset
! GetHDF5DSQType       What datatype is dataset?
! IsHDF5...Present     Is the (attribute, DS) in the locid?
! IsHDF5...InFile      Is the (attribute, DS) in the named file?
! LoadFromHDF5DS       Retrieves a dataset
! LoadPtrFromHDF5DS    Allocates an array and retrieves a dataset
! MakeHDF5Attribute    Turns an arg into an attribute
! MakeNestedGroups     Create a nested sequence of groups; e.g. a/b/c/../z
! MatchHDF5Attributes  Finds a dataset with matching attributes
! mls_h5close          Closes interface to hdf5; call once at end of run
! mls_h5open           Opens interface to hdf5; call once at start of run
! SaveAsHDF5DS         Turns an array into a dataset
! === (end of toc) ===

! === (start of api) ===
! CpHDF5Attribute (int fromitemID, int toitemID, char name,
!    [log skip_if_already_there])
! CpHDF5GlAttribute (char fromFile, char toFile, char name,
!    [log skip_if_already_there])
! DumpHDF5Attributes (int locID, [char names], [char groupName], [char DSName],
!    [char options])
! DumpHDF5DS (int locID, char groupame, [char names],
!    [real fillValue], [char options])
! GetAllHDF5AttrNames (int itemID, char DSNames)
! GetAllHDF5DSNames (file, char gname, char DSNames)
!     file can be one of:
!    {char* filename, int fileID}
! GetHDF5Attribute (int itemID, char name, value)
! GetHDF5AttributePtr (int itemID, char name, *value)
! GetHDF5DSDims (int FileID, char name, hsize_t dims(:), [hsize_t maxdims(:)])
! GetHDF5DSRank (int FileID, char name, int rank)
! GetHDF5DSQType (int FileID, char name, char QType)
! log IsHDF5AttributeInFile (char filename, char DSname, char name)
! log IsHDF5AttributeInFile (char filename, char name)
! log IsHDF5DSInFile (char filename, char name)
! log IsHDF5AttributePresent (int setid, char name)
! log IsHDF5AttributePresent (int fileid, char DSname, char name)
! log IsHDF5DSPresent (int locID, char name, [options])
! log IsHDF5GroupPresent (int locID, char name)
! log IsHDF5ItemPresent (int locID, char name, [options])
! LoadAllocFromHDF5DS (int locID, char name, *value [, lowBound] )
!       lowBound only for rank-1 arrays
! LoadFromHDF5DS (int locID, char name, value,
!       [int start(:), int count(:), [int stride(:), int block(:)] ] )
! LoadPtrFromHDF5DS (int locID, char name, *value [, lowBound] )
!       lowBound only for rank-1 arrays
! MakeHDF5Attribute ( int itemID, char name, value,
!       [log skip_if_already_there] )
! MakeNestedGroups ( int itemID, char groupnames(:) )
! MatchHDF5Attributes ( MLSFile_T MLSFile, char attrnames, char attrvalues,
!       char name )
! SaveAsHDF5DS ( int locID, char name, value,
!       [int start(:), int count(:), [int stride(:), int block(:)] ] )
!     value can be one of:
!    {char* value, int value, real value, double precision value,
!     int value(:),
!     real value(:), real value(:,:), real value(:,:,:), real value(:,:,:,:),
!     double precision value(:), double precision value(:,:),
!     double precision value(:,:,:)}

! Some of these may also be called with the int itemID or locID arg replaced
! by a MLSFile_T; e.g.
! GetHDF5Attribute ( MLSFile_T MLSFile, char name, value )
!        The attribute will be assumed to be an attribute of
!         MLSFile%FileID%sd_id
!         unless that component is zero, when it will try ..%grp_id
! LoadFromHDF5DS ( MLSFile_T MLSFile, char name, value,
!       [int start(:), int count(:), [int stride(:), int block(:)] ] )

! One standard is the character flag "options" which affects how loosely
! string matches may be interpreted
! it may include any of the following (poss. in combination, e.g. "-wc")
! w    Wildcard * which allows 'a*' to equal 'abcd'
! c    case insensitive which allows 'ABCD' to equal 'abcd'
! f    flush left which allows 'abcd' to equal '  abcd'
! In functions with "ITEM" in the title; for these expanded use allows
! a    Search for matches among attributes
! d    Search for matches among datasets
! g    Search for matches among groups
! (Don't confuse this use of options with the one below: here options
! affects how loosely strings may match; the one below affects how much
! and what details appear in dumps)

! The meaning of options has replaced the older logical arguments in Dumps
! if the options is present and contains the following characters:
!   character         meaning
!      ---            -------
!       c              Clean
!       L              Laconic
!       r              RMS       
!       s              Stats     
!       u              Unique    
!       w              WholeArray
! etc. (see dump_0 module)

! Note that when an argument is of type "char" and holds multiple items,
! e.g., DSnames in  GetAllHDF5DSNames or attrNames in MatchHDF5Attributes,
! it will be a comma-separated string list, as described in the module
! MLSStringLists
!
! Bugs and Gotchas:
! (1) How do we know where the wildcard "*" can appear in a field 
!    and where it is forbidden?
! (2) For which procedures can the arg be an MLSFile_T? Shouldn't you make it
!    all of them?
! (3) Beware that start uses the c position that array indexes start at 0, not 1.
!    It might be better named "offset". As it is, start is an unfortunate
!    misnomer that will probably continue to confuse.
!                      
! === (end of api) ===
  interface CpHDF5Attribute
    ! module procedure CpHDF5Attribute_int, CpHDF5Attribute_logical
    module procedure CpHDF5Attribute_string
    ! module procedure CpHDF5Attribute_sngl, CpHDF5Attribute_dbl
    ! module procedure CpHDF5Attribute_snglarr1, CpHDF5Attribute_intarr1
    ! module procedure CpHDF5Attribut _dblarr1, CpHDF5Attribute_stringarr1
  end interface

  interface CpHDF5GlAttribute
    module procedure CpHDF5GlAttribute_string
  end interface

  interface GetAllHDF5DSNames
    module procedure GetAllHDF5DSNames_fileID, GetAllHDF5DSNames_filename
    module procedure GetAllHDF5DSNames_MLSFile
  end interface

  interface GetHDF5Attribute
    module procedure GetHDF5Attribute_int, GetHDF5Attribute_logical, &
      & GetHDF5Attribute_logicalarr1, &
      & GetHDF5Attribute_string, GetHDF5Attribute_sngl, GetHDF5Attribute_dbl, &
      & GetHDF5Attribute_snglarr1, GetHDF5Attribute_intarr1, &
      & GetHDF5Attribute_dblarr1, GetHDF5Attribute_stringarr1
    module procedure GetHDF5Attr_ID_int, GetHDF5Attr_ID_logical, &
      & GetHDF5Attr_ID_logicalarr1, &
      & GetHDF5Attr_ID_string, GetHDF5Attr_ID_sngl, GetHDF5Attr_ID_dbl, &
      & GetHDF5Attr_ID_snglarr1, GetHDF5Attr_ID_intarr1, &
      & GetHDF5Attr_ID_dblarr1, GetHDF5Attr_ID_stringarr1
  end interface

  interface GetHDF5AttributePtr
      module procedure GetHDF5AttributePtr_snglarr1, GetHDF5AttributePtr_intarr1, &
          & GetHDF5AttributePtr_dblarr1, GetHDF5AttributePtr_stringarr1, &
          & GetHDF5AttributePtr_logicalarr1
  end interface

  interface ReadHDF5Attribute
      module procedure ReadHDF5Attr_FID_int, ReadHDF5Attr_FID_string
  end interface

  interface IsHDF5AttributeInFile
      module procedure IsHDF5AttributeInFile_DS, IsHDF5AttributeInFile_Grp
  end interface

  interface GetHDF5DSDims
    module procedure GetHDF5DSDims_ID, GetHDF5DSDims_MLSFile
  end interface

  interface GetHDF5DSRank
    module procedure GetHDF5DSRank_ID, GetHDF5DSRank_MLSFile
  end interface

  interface IsHDF5DSPresent
    module procedure IsHDF5DSPresent_in_fID, IsHDF5DSPresent_in_MLSFile
  end interface

  interface IsHDF5AttributePresent
    module procedure IsHDF5AttributePresent_in_fID, &
      & IsHDF5AttributePresent_in_MLSFile, &
      & IsHDF5AttributePresent_in_DSID, IsHDF5AttributePresent_in_grp
  end interface

  interface LoadAllocFromHDF5DS
    module procedure LoadAllocFromHDF5DS_chararr1, LoadAllocFromHDF5DS_chararr2, &
      & LoadAllocFromHDF5DS_intarr1, LoadAllocFromHDF5DS_intarr2, &
      & LoadAllocFromHDF5DS_intarr3, LoadAllocFromHDF5DS_intarr4, &
      & LoadAllocFromHDF5DS_logarr1, &
      & LoadAllocFromHDF5DS_dblarr1, LoadAllocFromHDF5DS_dblarr2, &
      & LoadAllocFromHDF5DS_dblarr3, LoadAllocFromHDF5DS_dblarr4, &
      & LoadAllocFromHDF5DS_snglarr1, LoadAllocFromHDF5DS_snglarr2, &
      & LoadAllocFromHDF5DS_snglarr3, LoadAllocFromHDF5DS_snglarr4
  end interface

  interface LoadFromHDF5DS
    module procedure LdFrmHDF5DS_ID_intarr1, LdFrmHDF5DS_ID_intarr2, &
      & LdFrmHDF5DS_ID_intarr3, LdFrmHDF5DS_ID_intarr4, &
      & LdFrmHDF5DS_ID_logarr1, &
      & LdFrmHDF5DS_ID_dblarr1, LdFrmHDF5DS_ID_dblarr2, &
      & LdFrmHDF5DS_ID_dblarr3, LdFrmHDF5DS_ID_dblarr4, &
      & LdFrmHDF5DS_ID_snglarr1, LdFrmHDF5DS_ID_snglarr2, &
      & LdFrmHDF5DS_ID_snglarr3, LdFrmHDF5DS_ID_snglarr4, &
      & LdFrmHDF5DS_ID_chararr1, LdFrmHDF5DS_ID_chararr2, &
      & LdFrmHDF5DS_ID_chararr3, LdFrmHDF5DS_ID_charscalar
    module procedure LoadFromHDF5DS_intarr1, LoadFromHDF5DS_intarr2, &
      & LoadFromHDF5DS_intarr3, LoadFromHDF5DS_intarr4, &
      & LoadFromHDF5DS_logarr1, &
      & LoadFromHDF5DS_dblarr1, LoadFromHDF5DS_dblarr2, &
      & LoadFromHDF5DS_dblarr3, LoadFromHDF5DS_dblarr4, &
      & LoadFromHDF5DS_snglarr1, LoadFromHDF5DS_snglarr2, &
      & LoadFromHDF5DS_snglarr3, LoadFromHDF5DS_snglarr4, &
      & LoadFromHDF5DS_chararr1, LoadFromHDF5DS_chararr2, &
      & LoadFromHDF5DS_chararr3, LoadFromHDF5DS_charscalar
  end interface

  interface LoadPtrFromHDF5DS
    module procedure LoadPtrFromHDF5DS_chararr1, LoadPtrFromHDF5DS_chararr2, &
      & LoadPtrFromHDF5DS_intarr1, LoadPtrFromHDF5DS_intarr2, &
      & LoadPtrFromHDF5DS_intarr3, LoadPtrFromHDF5DS_intarr4, &
      & LoadPtrFromHDF5DS_logarr1, &
      & LoadPtrFromHDF5DS_dblarr1, LoadPtrFromHDF5DS_dblarr2, &
      & LoadPtrFromHDF5DS_dblarr3, LoadPtrFromHDF5DS_dblarr4, &
      & LoadPtrFromHDF5DS_snglarr1, LoadPtrFromHDF5DS_snglarr2, &
      & LoadPtrFromHDF5DS_snglarr3, LoadPtrFromHDF5DS_snglarr4
  end interface

  interface MakeHDF5Attribute
    module procedure MakeHDF5Attribute_dbl, MakeHDF5Attribute_sngl, &
      & MakeHDF5Attribute_int, MakeHDF5Attribute_logical, &
      & MakeHDF5Attribute_logicalarr1, &
      & MakeHDF5Attribute_string, MakeHDF5Attribute_snglarr1, &
      & MakeHDF5Attribute_dblarr1, MakeHDF5Attribute_stringarr1, &
      & MakeHDF5Attribute_intarr1, MakeHDF5AttributeDSN_int, &
      & MakeHDF5AttributeDSN_string, MakeHDF5AttributeDSN_snglarr1, &
      & MakeHDF5AttributeDSN_st_arr1, MakeHDF5AttributeDSN_dblarr1, &
      & MakeHDF5AttributeDSN_single, MakeHDF5AttributeDSN_double, &
      & MakeHDF5Attribute_textFile
  end interface

  interface SaveAsHDF5DS
    module procedure &
      & SaveAsHDF5DS_intarr1, SaveAsHDF5DS_intarr2, SaveAsHDF5DS_intarr3, &
      & SaveAsHDF5DS_intarr4, &
      & SaveAsHDF5DS_logarr1, &
      & SaveAsHDF5DS_dblarr1, SaveAsHDF5DS_dblarr2, SaveAsHDF5DS_dblarr3, &
      & SaveAsHDF5DS_dblarr4, &
      & SaveAsHDF5DS_snglarr1, SaveAsHDF5DS_snglarr2, SaveAsHDF5DS_snglarr3, &
      & SaveAsHDF5DS_snglarr4, &
      & SaveAsHDF5DS_charsclr, SaveAsHDF5DS_chararr1, SaveAsHDF5DS_chararr2, &
      & SaveAsHDF5DS_textfile
  end interface

  integer, public, parameter :: MAXCHFIELDLENGTH = 2000000 ! max number of chars in l2cf
  integer, public, parameter :: MAXCHATTRLENGTH  =   40000 ! max number in attr
  integer, public, parameter :: MAXNDSNAMES = 20000   ! max number of DS names in a file

  ! Local parameters
  character, parameter :: Digits(7) = (/ '1', '2', '3', '4', '5', '6', '7' /)
  integer(hsize_t), dimension(7) :: ones = (/1,1,1,1,1,1,1/)
  logical, parameter :: countEmpty = .true.
  logical, parameter :: DEEBUG = .false.
  integer, save      :: cantGetDataspaceDims = 0
  integer, parameter :: DFLTMAXLINELENGTH = 1024
  integer, parameter :: MAXNUMWARNS = 40
  integer, parameter :: MAXATTRIBUTESIZE =   40000
  integer, parameter :: MAXTEXTSIZE      = 2000000
  integer, parameter :: MAXNAMELEN = 64
  logical, public    :: hdfVerbose = .false.
  ! logical, public    :: MayCrash = .false.
  character(len=*), dimension(2), parameter :: DONTDUMPTHESEDSNAMES = (/ &
    & 'wtfcoremetadata', 'wtfxmlmetadata ' /)
  ! Local variables
  integer(hid_t) :: cparms

contains ! ======================= Public Procedures =========================

  ! ------------------------------------------------  MLS_h5close  -----
  subroutine MLS_h5close ( error )
    ! Arguments
  ! To switch to/from hdfeos5.1.6(+) uncomment next line
    use H5Lib, only: H5Close_f
    integer, intent(out) :: error          ! Trouble if /= 0
    error = 0
    call h5close_f ( error )
  end subroutine MLS_h5close

  ! -------------------------------------------------  MLS_h5open  -----
  subroutine MLS_h5open ( error )
    ! Arguments
  ! To switch to/from hdfeos5.1.6(+) uncomment next line
    use H5Lib, only: H5Open_f
    integer, intent(out) :: error          ! Trouble if /= 0
    error = 0
    call h5open_f ( error )
  end subroutine MLS_h5open

  ! -------------------------------------  CpHDF5Attribute_string  -----
  subroutine CpHDF5Attribute_string ( fromitemID, toitemID, name, &
   & skip_if_already_there )
    integer, intent(in)           :: FROMITEMID ! Group etc. to Cp attr from
    integer, intent(in)           :: TOITEMID   ! Group etc. to Cp attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    logical, intent(in), optional :: skip_if_already_there ! Or if not in fromItemID

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_skip
    logical :: is_present
    character (len=4096) :: value1

    ! Executable code
    call trace_begin ( me, 'CpHDF5Attribute_string', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip = skip_if_already_there
    is_present = IsHDF5AttributePresent_in_DSID( fromitemID, name )
    if ( my_skip .and. .not. is_present ) go to 9
    if ( .not. is_present ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to cp: attribute not found ' // trim(name) )
    is_present = IsHDF5AttributePresent_in_DSID(toitemID, name)
    if ( my_skip .and. is_present ) go to 9
    call GetHDF5Attribute ( fromitemID, name, value1 )
    call MakeHDF5Attribute ( toitemID, name, trim(value1), &
      & skip_if_already_there )
  9 call trace_end ( cond=.false. )
  end subroutine CpHDF5Attribute_string

  ! -----------------------------------  CpHDF5GlAttribute_string  -----
  subroutine CpHDF5GlAttribute_string ( fromFileName, toFileName, name, &
   & skip_if_already_there )
    character (len=*), intent(in) :: FROMFILENAME     ! file name
    character (len=*), intent(in) :: TOFILENAME       ! file name
    character (len=*), intent(in) :: NAME ! Name of attribute
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: fromfileID
    integer :: fromgrpID
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag
    integer :: tofileID
    integer :: togrpID

    ! Executable code
    call trace_begin ( me, 'CpHDFGlAttribute_string', cond=.false. )
    call h5fopen_f ( trim(fromFilename), H5F_ACC_RDONLY_F, fromFileID, status )
    call h5fopen_f ( trim(toFilename), H5F_ACC_RDWR_F, toFileID, status )
    call h5gopen_f ( fromFileID, '/', fromgrpid, status )
    call h5gopen_f ( toFileID, '/', togrpid, status )
    call CpHDF5Attribute_string ( fromgrpID, togrpID, name, &
      & skip_if_already_there )
    call h5gclose_f ( fromgrpid, status )
    call h5gclose_f ( togrpid, status )
    call h5fclose_f ( fromFileID, status )
    call h5fclose_f ( toFileID, status )
    call trace_end ( 'CpHDFGlAttribute_string', cond=.false. )
  end subroutine CpHDF5GlAttribute_string

  ! -------------------------------  DumpHDF5Attributes  -----
  subroutine DumpHDF5Attributes ( locID, names, groupName, DSName, options )
    ! Dump attributes of locID (possibly followed by a group or DS name)
    ! All of them or only those in names string list
    integer, intent(in)                     :: locID ! attributes of what
    character (len=*), intent(in), optional :: NAMES  ! only these names
    character(len=*), intent(in), optional  :: groupName
    character(len=*), intent(in), optional  :: DSName
    character(len=*), intent(in), optional :: options

    ! Local variables
    integer :: attrID
    integer :: classID
    character(len=MAXCHFIELDLENGTH) :: chValue ! 1024; len may become MAXCHFIELDLENGTH
    ! logical, parameter :: DEEBUG = .true.
    integer, dimension(7) :: dims
    double precision, dimension(1024) :: dValue
    integer(kind=hSize_t), dimension(7) :: hdims
    integer :: i
    integer :: itemID
    integer, dimension(1024) :: iValue
    integer(kind=hSize_t), dimension(:), allocatable :: maxdims_ptr
    integer :: Me = -1                  ! String index for trace cacheing
    character(len=MAXNDSNAMES*MAXNAMELEN) :: myNames
    character(len=128) :: name
    integer :: numAttrs
    character(len=16) :: Qtype
    integer :: rank
    integer :: spaceID
    integer :: status
    integer :: type_id
    integer(kind=Size_t) :: type_size
    ! Executable
    call trace_begin ( me, 'DumpHDF5Attributes', cond=.false. )
    myNames = '*' ! Wildcard means 'all'
    if ( present(names) ) myNames = names
    if ( present(groupName) ) then
      ! call h5gOpen_f ( locID, '/', itemID, status )
      call h5gOpen_f ( locID, trim(groupName), itemID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open group' // trim(groupName) // &
        & ' while dumping its attributes' )
      if ( DEEBUG ) call outputNamedValue ( 'groupName', groupName )
    elseif(present(DSName) ) then
      call h5dOpen_f ( locID, trim(DSname), itemID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open dataset' // trim(DSName) // &
        & ' while dumping its attributes' )
      if ( DEEBUG ) call outputNamedValue ( 'DSName', DSName )
    else
      itemID = locID
      if ( DEEBUG ) call outputNamedValue ( 'locID', locID )
    endif
    if ( myNames == '*' ) then
      if ( present(groupName) ) then
        call GetAllHDF5AttrNames ( locID, myNames, groupname=groupName )
      else
        call GetAllHDF5AttrNames ( itemID, myNames )
      endif
    endif
    numAttrs = NumStringElements ( myNames, countEmpty )
    if ( DEEBUG ) call outputNamedValue ( 'myNames', myNames )
    if ( DEEBUG ) call outputNamedValue ( 'numAttrs', numAttrs )
    do i = 1, numAttrs
      if ( DEEBUG ) call outputNamedValue ( 'i', i )
      ! name = StringElement(myNames, i, countEmpty)
      call GetStringElement( myNames, name, i, countEmpty )
      if ( DEEBUG ) call outputNamedValue ( 'name', name )
      call h5aopen_name_f ( itemID, trim(name), attrID, status )
      if ( status /= 0 ) then
        call output ( trim(name), advance='no' )
        call output ( '  (not found)', advance='yes' )
        cycle
      endif
      call h5aGet_type_f ( attrID, type_id, status )
      call h5tGet_size_f ( type_id, type_size, status )
      call h5tget_class_f ( type_id, classID, status )
      call h5aget_space_f ( attrID, spaceID, status )
      call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
      allocate ( maxdims_ptr(rank) )
      call h5sget_simple_extent_dims_f ( spaceID, hdims(1:rank), &
           maxdims_ptr, status )
      if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get dims for attr ' // trim(name) )
      hdims(1:rank) = maxdims_ptr
      deallocate ( maxdims_ptr )
      if ( DEEBUG ) then
        call outputNamedValue ( 'name', name )
        call outputNamedValue ( 'attrID', attrID )
        call outputNamedValue ( 'type_id', type_id )
        call outputNamedValue ( 'type_size', int(type_size) )
        call outputNamedValue ( 'classID', classID )
        call outputNamedValue ( 'H5T_STRING_F', H5T_STRING_F )
        call outputNamedValue ( 'spaceID', spaceID )
        call outputNamedValue ( 'rank', rank )
        call outputNamedValue ( 'hdims', int(hdims, kind(status)) )
      end if
      call h5aClose_f ( attrID, status )
      call GetHDF5AttrDims ( itemID, name, hdims )
      dims = hdims
      Qtype = WhatTypeAmI ( type_id )
      if ( Qtype == 'unknown' .and. classID == H5T_STRING_F ) QType='character'
      if ( DEEBUG ) then
        call outputNamedValue ( 'dims', dims )
        call outputNamedValue ( 'Qtype', Qtype )
      end if
      dims(1) = max(dims(1), 1)
      select case ( QType )
      case ( 'integer' )
        call GetHDF5Attribute ( itemID, name, iValue(1:dims(1)) )
        call dump ( iValue(1:dims(1)), trim(name), options=options )
      case ( 'double', 'real' )
        call GetHDF5Attribute ( itemID, name, dValue(1:dims(1)) )
        call dump ( dValue(1:dims(1)), trim(name), options=options )
      case ( 'character' )
        call GetHDF5Attribute ( itemID, name, chValue )
        call output( 'Dump of ' // trim(name), advance='yes' )
        call output( trim(chValue) )
        call newLine
      case default
        call output ( trim(name), advance='no' )
        call output ( '  (unrecognized type)', advance='yes' )
      end select
      
    enddo
    if ( present(groupName) ) then
      call h5gClose_f ( itemID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close group' // trim(groupName) // &
        & ' while dumping its attributes' )
    elseif(present(DSName) ) then
      call h5dClose_f ( itemID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open dataset' // trim(DSName) // &
        & ' while dumping its attributes' )
    endif
    call trace_end ( 'DumpHDF5Attributes', cond=.false. )
  end subroutine DumpHDF5Attributes
  
  ! -------------------------------------------------  DumpHDF5DS  -----
  subroutine DumpHDF5DS ( locID, groupName, &
    & names, fillValue, options )
    ! Dump datasets in groupID
    ! All of them or only those in names string list
    integer, intent(in)                     :: locID ! file or groupID
    character(len=*), intent(in)            :: groupName ! datasets in group
    character (len=*), intent(in), optional :: NAMES   ! only these names
    real, intent(in), optional              :: fillValue ! Show % = fill
    character(len=*), intent(in), optional  :: options

    ! Local variables
    logical :: addnameOnEachLine
    integer :: ch
    character(len=MAXCHFIELDLENGTH), dimension(1) :: chValue
    character(len=MAXCHFIELDLENGTH), dimension(:), pointer :: ch1dArray => null()
    character(len=1), dimension(:,:,:), pointer :: chArray => null()
    character(len=1), dimension(:), pointer :: charsArray  => null()
    character(len=80), dimension(:), pointer :: chLongArray => null()
    integer :: classID
    ! logical, parameter :: DEEBUG = .false.
    integer, parameter :: LONGCHARARRAYTHRSHLD = 10 ! was 999
    integer, dimension(7) :: dims
    logical :: dontPrintName
    double precision, dimension(:,:,:,:), pointer :: d4Value => null()
    double precision, dimension(:,:,:), pointer :: dValue => null()
    integer :: groupID
    integer(kind=hSize_t), dimension(7) :: hdims
    integer :: i
    integer :: ItemID
    integer, dimension(:,:,:), pointer :: iValue => null()
    integer :: k
    integer :: m
    integer :: Me = -1                  ! String index for trace cacheing
    character(len=MAXNDSNAMES*MAXNAMELEN) :: myNames
    character(len=128) :: name
    character(len=128) :: namePrinted
    integer :: Np1
    integer :: numDS
    character(len=16) :: Qtype
    integer :: rank
    character(len=MAXNDSNAMES*MAXNAMELEN) :: sdNames
    logical :: skipCharValues
    integer :: spaceID
    integer :: status
    integer, dimension(size(DONTDUMPTHESEDSNAMES) ) :: theIndexes
    integer :: type_id
    integer(kind=Size_t) :: type_size
    ! logical, parameter :: DEEBUG = .true.

    ! Executable
    call trace_begin ( me, 'DumpHDF5DS', cond=.false. )
    if ( present(options) .and. DEEBUG ) call outputNamedValue( 'options', options )
    skipCharValues = .false.
    if ( present(options) ) &
      & skipCharValues = any( indexes(options, (/dopt_rms, dopt_stats/)) > 0 )
    myNames = '*' ! Wildcard means 'all'
    if ( present(names) ) myNames = names
    call GetAllHDF5DSNames ( locID, groupName, sdNames )
    ! Did we ask for any datasets by name? With wildcard?
    ! print *, 'sdNames: ', trim(sdNames)
    ! print *, 'Names:   ', trim(Names)
    if ( myNames == '*' ) then
      myNames = sdNames
    elseif( index( myNames, '*') > 0 ) then
      myNames = Intersection( sdNames, myNames, options='-w' )
    endif
    ! print *, 'Intersection:   ', trim(myNames)
    dontPrintName = .false.
    if ( present(options) ) dontPrintName = index(options, dopt_laconic) > 0
    addnameOnEachLine = .false.
    if ( present(options) ) addnameOnEachLine = index(options, dopt_verbose ) > 0
    numDS = NumStringElements ( myNames, countEmpty )
    call h5gOpen_f ( locid, trim(groupName), groupID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open group' // trim(groupName) // &
      & ' while dumping its datasets' )
    do i = 1, numDS
      name = StringElement(myNames, i, countEmpty)
      if ( name == ',' .or. len_trim(name) < 1 ) cycle
      theIndexes = indexes( name, DONTDUMPTHESEDSNAMES )
      if ( any( theIndexes > 0 ) ) cycle
      namePrinted = name
      if ( dontPrintName ) namePrinted = ' '
      if ( addnameOnEachLine ) nameOnEachLine = namePrinted
      call h5dopen_f ( groupID, trim(name), ItemID, status )
      if ( status /= 0 ) then
        call output ( trim(name), advance='no' )
        call output ( '  (not found)', advance='yes' )
        cycle
      endif
      call h5dGet_type_f ( ItemID, type_id, status )
      call h5tGet_size_f ( type_id, type_size, status )
      call h5tget_class_f ( type_id, classID, status )
      call h5dget_space_f ( itemID, spaceID, status )
      call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
      if ( DEEBUG ) then
        call outputNamedValue ( 'name', name )
        call outputNamedValue ( 'ItemID', ItemID )
        call outputNamedValue ( 'type_id', type_id )
        call outputNamedValue ( 'type_size', int(type_size) )
        call outputNamedValue ( 'classID', classID )
        call outputNamedValue ( 'H5T_STRING_F', H5T_STRING_F )
        call outputNamedValue ( 'spaceID', spaceID )
        call outputNamedValue ( 'rank', rank )
      endif
      call h5dClose_f ( ItemID, status )
      call GetHDF5DSDims ( groupID, name, hdims )
      dims = hdims
      dims(1) = max(dims(1), 1)
      Qtype = WhatTypeAmI ( type_id )
      if ( Qtype == 'unknown' .and. classID == H5T_STRING_F ) QType='character'
      if ( DEEBUG ) then
        call outputNamedValue ( 'dims', dims )
        call outputNamedValue ( 'Qtype', Qtype )
      endif
      if ( QType == 'character' .and. skipCharValues ) cycle
      select case ( QType )
      case ( 'integer' )
        select case ( rank )
        case ( 3 )
          call allocate_test( iValue, dims(1), dims(2), dims(3), name, ModuleName )
          call LoadFromHDF5DS ( groupID, name, iValue )
          if ( present(fillvalue) ) then
            call dump ( iValue, trim(namePrinted), fillValue=int(fillvalue), &
              & options=options )
          else
            call dump ( iValue, trim(namePrinted), options=options )
          endif
          call deallocate_test( iValue, name, ModuleName )
        case ( 2 )
          call allocate_test( iValue, dims(1), dims(2), 1, name, ModuleName )
          call LoadFromHDF5DS ( groupID, name, iValue(:,:,1) )
          if ( present(fillvalue) ) then
            call dump ( iValue(:,:,1), trim(namePrinted), fillValue=int(fillvalue), &
              & options=options )
          else
            call dump ( iValue(:,:,1), trim(namePrinted), options=options )
          endif
          call deallocate_test( iValue, name, ModuleName )
        case default
          call allocate_test( iValue, dims(1), 1, 1, name, ModuleName )
          call LoadFromHDF5DS ( groupID, name, iValue(:,1,1) )
          if ( present(fillvalue) ) then
            call dump ( iValue(:,1,1), trim(namePrinted), fillValue=int(fillvalue), &
              & options=options )
          else
            call dump ( iValue(:,1,1), trim(namePrinted), options=options )
          endif
          call deallocate_test( iValue, name, ModuleName )
         end select
      case ( 'double', 'real' )
        select case ( rank )
        case ( 4 )
          call outputNamedValue( 'dims', dims )
          call output( '(Presently we only dump a 3-d slice of 4-d arrays)', &
            & advance='yes' )
          call allocate_test( d4Value, dims(1), dims(2), dims(3), dims(4), &
            & name, ModuleName )
          call LoadFromHDF5DS ( groupID, name, d4Value )
          if ( present(fillvalue) ) then
            if ( present(options) .and. DEEBUG ) &
              & call outputNamedValue( 'options', options )
            call dump ( d4Value(:,:,:,:), trim(namePrinted), fillValue=real(fillvalue, r8), &
              & options=options )
          else
            if ( present(options) .and. DEEBUG ) &
              & call outputNamedValue( 'options', options )
            call dump ( d4Value(:,:,:,:), trim(namePrinted), options=options )
          endif
          call deallocate_test( d4Value, name, ModuleName )
        case ( 3 )
          call allocate_test( dValue, dims(1), dims(2), dims(3), name, ModuleName )
          call LoadFromHDF5DS ( groupID, name, dValue )
          if ( present(fillvalue) ) then
            if ( present(options) .and. DEEBUG ) &
              & call outputNamedValue( 'options', options )
            call dump ( dValue, trim(namePrinted), fillValue=real(fillvalue, r8), &
              & options=options )
          else
            if ( present(options) .and. DEEBUG ) &
              & call outputNamedValue( 'options', options )
            call dump ( dValue, trim(namePrinted), options=options )
          endif
          call deallocate_test( dValue, name, ModuleName )
        case ( 2 )
          call allocate_test( dValue, dims(1), dims(2), 1, name, ModuleName )
          call LoadFromHDF5DS ( groupID, name, dValue(:,:,1) )
          if ( present(fillvalue) ) then
            call dump ( dValue(:,:,1), trim(namePrinted), &
              & fillValue=real(fillvalue, r8), options=options )
          else
            call dump ( dValue(:,:,1), trim(namePrinted), options=options )
          endif
          call deallocate_test( dValue, name, ModuleName )
        case default
          call allocate_test( dValue, dims(1), 1, 1, name, ModuleName )
          call LoadFromHDF5DS ( groupID, name, dValue(:,1,1) )
          if ( present(fillvalue) ) then
            call dump ( dValue(:,1,1), trim(namePrinted), fillValue=real(fillvalue, r8), &
              & options=options )
          else
            call dump ( dValue(:,1,1), trim(namePrinted), options=options )
          endif
          call deallocate_test( dValue, name, ModuleName )
         end select
      case ( 'character' )
        ! call outputNamedValue( 'type', QType )
        ! call outputNamedValue( 'rank', rank )
        select case ( rank )
        case ( 3 )
          call allocate_test( chArray, dims(1), dims(2), dims(3), 'chArray', ModuleName )
          call LoadFromHDF5DS ( groupID, name, chArray )
          call dump ( chArray, trim(namePrinted) )
          call deallocate_test( chArray, 'chArray', ModuleName )
        case ( 2 )
          call allocate_test( chArray, dims(1), dims(2), 1, 'chArray', ModuleName )
          call LoadFromHDF5DS ( groupID, name, chArray(:,:,1) )
          call dump ( chArray(:,:,1), trim(namePrinted) )
          call deallocate_test( chArray, 'chArray', ModuleName )
        case ( 0 )
          chvalue = ' ' ! 
          call LoadFromHDF5DS ( groupID, Name, chvalue(1) )
          if ( len_trim(namePrinted) > 0 ) call output( 'name: ' // trim(name), advance='yes' )
          call output( trim(chValue(1)), advance='yes' )
        case default
          if ( dims(1) < 2 ) then
            ! In case we have a very long dataset, e.g. the l2cf
            chvalue = ' ' ! 
            call LoadFromHDF5DS ( groupID, Name, chvalue )
            ! call outputNamedValue ( 'len before replacing nulls', len_trim(chvalue(1)) )
            ! Unfortunately, a lot of null characters sneak into this
            ! chValue(1) = Replace( chValue(1), char(0), char(32) ) ! Replace null with space
            ! call outputNamedValue ( 'len after replacing nulls', len_trim(chvalue(1)) )
            ! call dump ( trim(chValue(1)), trim(namePrinted) )
            if ( len_trim(namePrinted) > 0 ) call output( 'name: ' // trim(name), advance='yes' )
            call output( trim(chValue(1)), advance='yes' )
          elseif ( dims(1) > LONGCHARARRAYTHRSHLD ) then
            ! In case we have a very long array, e.g. dates
            if ( DEEBUG ) call outputNamedValue( 'dims', dims )
            call allocate_test( charsArray, 80*dims(1), 'charsArray', ModuleName )
            call allocate_test( chLongArray, dims(1), 'chLongArray', ModuleName )
            chLongArray = repeat( ACHAR(0), 80 )
            call LoadFromHDF5DS ( groupID, name, chLongArray )
            charsArray = ACHAR(0)
            m = 80
            do k=1, dims(1)
              do ch=1, m
                charsArray(ch + m*(k-1)) = chLongArray(k)(ch:ch)
              enddo
            enddo
            Np1 = FindFirst( charsArray, ACHAR(0) )
            m = Np1 / dims(1)
            chLongArray = ' '
            do k=1, dims(1)
              do ch=1, m
                chLongArray(k)(ch:ch) = charsArray(ch + m*(k-1))
              enddo
            enddo
            if ( DEEBUG ) call outputNamedValue( 'Np1', Np1 )
            if ( DEEBUG ) call outputNamedValue( 'm', m )
            call dump ( chLongArray, trim(namePrinted) )
            call deallocate_test( chLongArray, 'chLongArray', ModuleName )
            call deallocate_test( charsArray, 'charsArray', ModuleName )
          else
            call allocate_test( ch1dArray, dims(1), 'ch1dArray', ModuleName )
            call LoadFromHDF5DS ( groupID, name, ch1dArray )
            call dump ( ch1dArray, trim(namePrinted) )
            call deallocate_test( ch1dArray, 'ch1dArray', ModuleName )
          endif
         end select
      case default
        call output ( trim(name), advance='no' )
        call output ( '  (unrecognized type)', advance='yes' )
      end select
      
    enddo
    call h5gClose_f ( groupID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close group' // trim(groupName) // &
      & ' while dumping its datasets' )
    call trace_end ( 'DumpHDF5DS', cond=.false. )
  end subroutine DumpHDF5DS

  ! -------------------------------  GetAllHDF5AttrNames  -----
  subroutine GetAllHDF5AttrNames ( locID, names, groupName, DSName )
    ! Get all attribute names attributes of locID 
    ! (possibly followed by a group or DS name)
    ! returns string list names
    integer, intent(in)            :: locID ! attributes of what
    character (len=*), intent(out) :: NAMES ! Names of attribute
    character(len=*), intent(in), optional  :: groupName
    character(len=*), intent(in), optional  :: DSName

    ! Local variables
    integer :: attr_id
    integer :: i
    integer :: itemID
    integer :: Me = -1                  ! String index for trace cacheing
    character(len=128) :: name
    integer(kind=Size_t) :: namelength
    integer :: num
    integer :: status
    character(len=len(names)) :: tempnames

    ! Executable code
    call trace_begin ( me, 'GetAllHDF5AttrNames', cond=.false. )
    namelength = len(name)
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for all attr names' )
    if ( present(groupName) ) then
      call h5gOpen_f ( locID, trim(groupName), itemID, status )
      ! call outputNamedValue( 'groupName ', groupName )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open group' // trim(groupName) // &
        & ' while looking for all its attr names' )
    elseif(present(DSName) ) then
      call h5dOpen_f ( locID, trim(DSname), itemID, status )
      ! call outputNamedValue( 'DSname ', DSname )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open DS ' // trim(DSname) // &
        & ' while looking for all its attr names' )
    else
      itemID = locID
    endif
    Names = ' '
    ! call output( 'About to read num of attributes', advance='yes' )
    call h5aget_num_attrs_f( itemID, num, status )
    if ( status /= 0 ) go to 9
    ! call outputNamedValue( 'num ', num )
    do i=1, num
      call h5aopen_idx_f( itemid, i-1, attr_id, status )
      ! print *, 'attr_id, status ', attr_id, status
      if ( status == -1 .or. attr_id < 1 ) cycle
      call h5aget_name_f( attr_id, namelength, name, status )
      ! print *, 'name ', trim(name)
      if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to determine attr name' )
      ! print *, 'len(name) ', len_trim(name), status
      tempnames = catLists( names, name )
      names = tempnames
      call h5aclose_f( attr_id, status )
    enddo
    if ( present(groupName) ) then
      call h5gClose_f ( itemID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close group' // trim(groupName) // &
        & ' while looking for all its attr names' )
    elseif(present(DSName) ) then
      call h5dClose_f ( itemID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close DS' // trim(DSname) // &
        & ' while looking for all its attr names' )
    endif
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for all attr names' )
  9 call trace_end ( 'GetAllHDF5AttrNames', cond=.false. )
  end subroutine GetAllHDF5AttrNames

  ! -----------------------------------  GetAllHDF5DSNames_fileID  -----
  subroutine GetAllHDF5DSNames_fileID ( FileID, gname, DSNames, andSlash )
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    integer, intent(in) :: FILEID          ! fileID
    character (len=*), intent(in) :: GNAME ! Name of group; e.g. '/'
    character (len=*), intent(out) :: DSNames ! Names of DS in file (,-separated)
    logical, optional, intent(in) :: andSlash ! Keep leading '/' if TRUE

    ! Local variables
    integer :: i                        ! loop counter
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: omitSlash
    integer :: STATUS                   ! Flag
    type(MLSDataInfo_T) :: dataset_info

    ! Executable code
    call trace_begin ( me, 'GetAllHDF5DSNames_fileID', cond=.false. )
    omitSlash = .true.
    if ( present(andSlash) ) omitSlash = .not. andSlash
    ! Initializing values returned if there was trouble
    DSNames = ''
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before getting DSNames' )
! The structure, dataset_info, is initialized below.
!
    nullify(dataset_info%name)
    call allocate_test ( dataset_info%name, MAXNDSNAMES, 'dataset_info%name', &
      & moduleName )
    dataset_info%name = ''
    dataset_info%number_of_entries = 0
    call Query_MLSData ( fileid, trim(gname), dataset_info )
    if ( dataset_info%number_of_entries < 0 ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & 'Unable to get DSNames' )
    else if ( dataset_info%number_of_entries == 1 ) then
      if ( omitSlash .and. dataset_info%name(1)(1:1) == '/' ) &
        & dataset_info%name(1) = dataset_info%name(1)(2:)
      DSNames = dataset_info%name(1)
    else if ( dataset_info%number_of_entries > 1 ) then
      ! DSNames = dataset_info%name(1)
      do i = 1, dataset_info%number_of_entries
        if ( omitSlash .and. dataset_info%name(i)(1:1) == '/' ) &
          & dataset_info%name(i) = dataset_info%name(i)(2:)
        DSNames = catLists(trim(DSNames), dataset_info%name(i))
      end do
    end if
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after getting DSNames' )
    call deallocate_test ( dataset_info%name, 'dataset_info%name', moduleName )
    call trace_end ( cond=.false. )
  end subroutine GetAllHDF5DSNames_fileID

  ! ---------------------------------  GetAllHDF5DSNames_filename  -----
  subroutine GetAllHDF5DSNames_filename ( FileName, gname, DSNames, andSlash )
    character (len=*), intent(in) :: FILENAME       ! file name
    character (len=*), intent(in) :: GNAME ! Name of group; e.g. '/'
    character (len=*), intent(out) :: DSNames ! Names of DS in file (,-separated)
    logical, optional, intent(in) :: andSlash ! Keep leading '/' if TRUE

    ! Local variables
    integer :: fileID
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'GetAllHDF5DSNames_filename', cond=.false. )
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before getting DSNames ' // trim(filename) )
    call h5fopen_f ( trim(filename), H5F_ACC_RDONLY_F, fileID, status )
    if ( status == 0 ) then
      call mls_eSet_auto ( 1, status )
      call GetAllHDF5DSNames_fileID ( fileID, gname, DSNames, andSlash )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open file for getting DSNames ' // trim(filename) )
    end if
    call mls_eSet_auto ( 0, status )
    call h5fclose_f ( fileID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close file after getting DSNames ' // trim(filename) )
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after getting DSNames ' // trim(filename) )
    call trace_end ( cond=.false. )
  end subroutine GetAllHDF5DSNames_filename

  ! ---------------------------------  GetAllHDF5DSNames_MLSFile  -----
  subroutine GetAllHDF5DSNames_MLSFile ( MLSFile, DSNames, andSlash )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(out) :: DSNames ! Names of DS in file (,-separated)
    logical, optional, intent(in) :: andSlash ! Keep leading '/' if TRUE

    ! Local variables
    character, parameter :: gname = '/'
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'GetAllHDF5DSNames_MLSFile', cond=.false. )
    if ( .not. MLSFile%stillOpen ) then
      call GetAllHDF5DSNames( MLSFile%Name, gname, DSNames, andSlash )
    elseif( MLSFile%FileId%grp_id > 0 ) then
      call GetAllHDF5DSNames( MLSFile%FileId%grp_id, gname, DSNames, andSlash )
    elseif( MLSFile%FileId%f_id > 0 ) then
      call GetAllHDF5DSNames( MLSFile%FileId%f_id, gname, DSNames, andSlash )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'all fields of MLSFile%Fileid are 0', MLSFile=MLSFile )
    endif
    call trace_end ( cond=.false. )
  end subroutine GetAllHDF5DSNames_MLSFile

  ! --------------------------------------  MakeHDF5Attribute_dbl  -----
  subroutine MakeHDF5Attribute_dbl ( itemID, name, value, &
   & skip_if_already_there )
    integer, intent(in) :: ITEMID         ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    double precision, intent(in) :: VALUE ! Value of attribute
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: DSID                     ! ID for dataspace
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_dbl', cond=.false. )
    ! (Maybe) create the attribute
    if ( startMakeAttrib ( itemId, name, H5T_NATIVE_DOUBLE, dsID, attrID &
      &, skip_if_already_there ) ) then
      ! Write it
      call h5aWrite_f ( attrID, H5T_NATIVE_DOUBLE, value, ones, status )
      call finishMakeAttrib ( name, status, attrID, dsID )
    end if
    call trace_end ( cond=.false. )
  end subroutine MakeHDF5Attribute_dbl

  ! -------------------------------------  MakeHDF5Attribute_sngl  -----
  subroutine MakeHDF5Attribute_sngl ( itemID, name, value, &
   & skip_if_already_there )
    integer, intent(in) :: ITEMID         ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    real, intent(in) :: VALUE             ! Value of attribute
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: DSID                     ! ID for dataspace
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_sngl', cond=.false. )
    ! (Maybe) create the attribute
    if ( startMakeAttrib ( itemId, name, H5T_NATIVE_REAL, dsID, attrID, &
      & skip_if_already_there ) ) then
      ! Write
      call h5aWrite_f ( attrID, H5T_NATIVE_REAL, value, ones, status )
      call finishMakeAttrib ( name, status, attrID, dsID )
    end if
    call trace_end ( cond=.false. )
  end subroutine MakeHDF5Attribute_sngl

  ! --------------------------------------  MakeHDF5Attribute_int  -----
  subroutine MakeHDF5Attribute_int ( itemID, name, value, &
   & skip_if_already_there )
    integer, intent(in) :: ITEMID         ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    integer, intent(in) :: VALUE          ! Value of attribute
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: DSID                     ! ID for dataspace
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_int', cond=.false. )
    ! (Maybe) create the attribute
    if ( startMakeAttrib ( itemId, name, H5T_NATIVE_INTEGER, dsID, attrID, &
      & skip_if_already_there ) ) then
      ! Write
      call h5aWrite_f ( attrID, H5T_NATIVE_INTEGER, value, ones, status )
      call finishMakeAttrib ( name, status, attrID, dsID )
    end if
    call trace_end ( cond=.false. )
  end subroutine MakeHDF5Attribute_int

  ! ----------------------------------  MakeHDF5Attribute_logical  -----
  subroutine MakeHDF5Attribute_logical ( itemID, name, value, &
   & skip_if_already_there )
    integer, intent(in) :: ITEMID       ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    logical, intent(in) :: VALUE        ! Value of attribute
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: IVALUE                   ! Value as integer
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_logical', cond=.false. )
    iValue = 0
    if ( value ) iValue = 1
    call MakeHDF5Attribute ( itemID, name, iValue, skip_if_already_there )
    call trace_end ( cond=.false. )
  end subroutine MakeHDF5Attribute_logical

  ! ------------------------------  MakeHDF5Attribute_logicalarr1  -----
  subroutine MakeHDF5Attribute_logicalarr1 ( itemID, name, value , &
   & skip_if_already_there )
    integer, intent(in) :: ITEMID         ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    logical, intent(in) :: VALUE(:)       ! The attribute array itself
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: IValue(size(value))      ! 1 for true, 0 for false
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_logicalarr1', cond=.false. )
    where ( value )
      iValue = 1
    elsewhere
      iValue = 0
    end where
    call MakeHDF5Attribute ( itemID, name, iValue, skip_if_already_there )
    call trace_end ( cond=.false. )
  end subroutine MakeHDF5Attribute_logicalarr1

  ! -----------------------------------  MakeHDF5Attribute_string  -----
  subroutine MakeHDF5Attribute_string ( itemID, name, value , &
   & skip_if_already_there, DONT_TRIM )
    integer, intent(in) :: ITEMID       ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    character (len=*), intent(in) :: VALUE ! Value of attribute
    logical, intent(in), optional :: SKIP_IF_ALREADY_THERE
    logical, intent(in), optional :: DONT_TRIM

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: DSID                     ! ID for dataspace
    integer :: STATUS                   ! Flag from HDF5
    integer :: STRINGTYPE               ! Type for string
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_dont_trim
    logical :: my_skip
    logical :: is_present
    logical, parameter :: NEVERDELETE = .false. ! .true.

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_string', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    my_dont_trim = .false.
    if ( present(DONT_TRIM) ) my_dont_trim=DONT_TRIM
    is_present = IsHDF5AttributePresent_in_DSID(itemID, name)
    if ( my_skip .and. is_present ) go to 9
    ! Setup
    ! Create a data type for this string
    call h5tcopy_f ( H5T_NATIVE_CHARACTER, stringtype, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create stringtype ' // trim(name) )
    if ( my_dont_trim) then
      call h5tset_size_f(stringtype, int(max(len(value), 1), size_t), status )
    else
      call h5tset_size_f(stringtype, int(max(len_trim(value), 1), size_t), status )
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to set size for stringtype ' // trim(name) )
    ! Create dataspace and attribute
    !call h5sCreate_F ( h5s_scalar_f, dsID, status )
    !if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !  & 'Unable to create dataspace for attribute ' // trim(name) )
    if ( is_present .and. .not. NEVERDELETE ) then
      ! print *, 'Deleting ' // trim(name)
      call h5adelete_f(itemID, trim(name), status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to delete ' )
    end if
    call h5sCreate_F ( h5s_scalar_f, dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for attribute ' // trim(name) )
    ! print *, 'itemID: ', itemID
    ! print *, 'stringtype: ', stringtype
    ! print *, 'dsID: ', dsID
    ! print *, 'name: ', trim(name)
    ! print *, 'was there: ', is_present
    ! print *, 'value: ', trim(value)
    if ( .not. ( is_present .and. NEVERDELETE ) ) then
      call h5aCreate_f ( itemID, trim(name), stringtype, dsID, attrID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create attribute ' // trim(name) )
    else
      call h5aopen_name_f ( itemID, trim(name), attrID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open attribute ' // trim(name) )
    endif
    ! print *, 'attrID: ', attrID
    ! print *, 'status: ', status
    ! Write
    if ( my_dont_trim) then
      call h5aWrite_f ( attrID, stringtype, value, ones, status )
    else
      call h5aWrite_f ( attrID, stringtype, trim_safe(value), ones, status )
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write attribute ' // trim(name) )
    ! Finish off
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name) )
    if ( .not. is_present .or. .true. ) then
      call h5sClose_f ( dsID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close attribute dataspace ' // trim(name) )
    end if
    call h5tClose_f ( stringtype, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close stringtype ' // trim(name) )
  9 call trace_end ( 'MakeHDF5Attribute_string', cond=.false. )
  end subroutine MakeHDF5Attribute_string

  ! -----------------------------------  MakeHDF5Attribute_textFile  -----
  subroutine MakeHDF5Attribute_textFile ( textFile, itemID, name , &
   & skip_if_already_there, maxLineLen )
    use IO_Stuff, only: Read_TextFile
    integer, intent(in) :: ITEMID       ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    character (len=*), intent(in) :: TEXTFILE ! name of textfile
    logical, intent(in), optional :: SKIP_IF_ALREADY_THERE
    integer, optional, intent(in) :: maxLineLen

    ! Local variables
    logical, parameter :: NEVERDELETE = .true.
    integer :: ATTRID                   ! ID for attribute
    character(len=3) :: blockChar
    integer :: DSID                     ! ID for dataspace
    integer :: firstChar, lastChar
    integer :: iblock, nblocks
    logical :: is_present
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: myMaxLineLen
    character(len=len(name)+3) :: newname
    integer :: STATUS                   ! Flag from HDF5
    integer :: STRINGTYPE               ! Type for string
    logical :: my_skip
    character(LEN=MAXTEXTSIZE)              :: value

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_textFile', cond=.false. )
    myMaxLineLen = DFLTMAXLINELENGTH
    if ( present(maxLineLen) ) myMaxLineLen = maxLineLen
    ! Try to read the textfile
    value = ' '
    call read_textFile( trim(textFile), value, myMaxLineLen )
    status = 0
    if ( status /= 0 ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to write attribute--failed to read textfile' )
      goto 9
    endif
    ! Unfortunately, a lot of null characters sneak into this
    value = Replace( value, char(0), char(32) ) ! Replace null with space
    
    ! Be careful lest the attribute is too large
    if ( len_trim(value) > MAXATTRIBUTESIZE ) then
      nblocks = 1 + ( len_trim(value) - 1 ) / MAXATTRIBUTESIZE
      lastChar = 0
      do iblock=1, nblocks
        firstChar = lastChar + 1
        lastChar  = min( lastChar + MAXATTRIBUTESIZE, len_trim(value) )
        write(blockChar, '(i1)' ) iblock
        if ( iblock > 9 ) write(blockChar, '(i2)' ) iblock
        newName = trim(name) // adjustl(blockChar)
        call MakeHDF5Attribute( itemID, newName, value(firstChar:lastChar) )
      enddo
      goto 9
    endif

    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    is_present = IsHDF5AttributePresent_in_DSID(itemID, name)
    if ( my_skip .and. is_present ) go to 9
    ! Setup
    ! Create a data type for this string
    call h5tcopy_f ( H5T_NATIVE_CHARACTER, stringtype, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create stringtype ' // trim(name) )
    call h5tset_size_f(stringtype, int(max(len(value), 1), size_t), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to set size for stringtype ' // trim(name) )
    ! Create dataspace and attribute
    if ( is_present .and. .not. NEVERDELETE ) then
      print *, 'Deleting ' // trim(name)
      call h5adelete_f(itemID, trim(name), status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to delete ' )
    end if
    call h5sCreate_F ( h5s_scalar_f, dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for attribute ' // trim(name) )
    ! print *, 'itemID: ', itemID
    ! print *, 'stringtype: ', stringtype
    ! print *, 'dsID: ', dsID
    ! print *, 'name: ', trim(name)
    ! print *, 'was there: ', is_present
    ! print *, 'value: ', trim(value)
    if ( .not. ( is_present .and. NEVERDELETE ) ) then
      call h5aCreate_f ( itemID, trim(name), stringtype, dsID, attrID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create attribute ' // trim(name) )
    else
      call h5aopen_name_f ( itemID, trim(name), attrID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open attribute ' // trim(name) )
    endif
    ! print *, 'attrID: ', attrID
    ! print *, 'status: ', status
    ! Write
    call h5aWrite_f ( attrID, stringtype, trim(value), ones, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write attribute ' // trim(name) )
    ! Finish off
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name) )
    if ( .not. is_present .or. .true. ) then
      call h5sClose_f ( dsID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close attribute dataspace ' // trim(name) )
    end if
    call h5tClose_f ( stringtype, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close stringtype ' // trim(name) )
  9 call trace_end ( 'MakeHDF5Attribute_textFile', cond=.false. )
  end subroutine MakeHDF5Attribute_textFile

  ! -------------------------------  MakeHDF5Attribute_stringarr1  -----
  subroutine MakeHDF5Attribute_stringarr1 ( itemID, name, value , &
   & skip_if_already_there )
    integer, intent(in) :: ITEMID         ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    character (len=*), dimension(:), intent(in) :: VALUE ! Value of attribute
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: DSID                     ! ID for dataspace
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag from HDF5
    integer :: STRINGTYPE               ! Type for string
    logical :: my_skip
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_stringarr1', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip = skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) go to 9
    end if
    ! Setup
    shp = shape(value)
    ! Create a data type for this string
    call h5tcopy_f ( H5T_NATIVE_CHARACTER, stringtype, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create stringtype for array' // trim(name) )
    call h5tset_size_f ( stringtype, int(len(value(1)), size_t), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to set size for stringtype ' // trim(name) )
    ! Create dataspace and attribute
    ! call h5sCreate_F ( h5s_simple_f, dsID, status )
    call h5sCreate_simple_f ( 1, int(shp, hSize_T), dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for attribute ' // trim(name) )
    call h5aCreate_f ( itemID, trim(name), stringtype, dsID, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create attribute ' // trim(name) )
    ! Write
    call h5aWrite_f ( attrID, stringtype, value, &
      & ones, status )
    call finishMakeAttrib ( name, status, attrID, dsID, stringType )
  9 call trace_end ( cond=.false. )
  end subroutine MakeHDF5Attribute_stringarr1

  ! ---------------------------------  MakeHDF5Attribute_snglarr1  -----
  subroutine MakeHDF5Attribute_snglarr1 ( itemID, name, value , &
   & skip_if_already_there )
    integer, intent(in) :: ITEMID         ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    real, intent(in) :: VALUE(:)          ! The attribute array itself
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: spaceID                  ! ID for dataspace
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_snglarr1', cond=.false. )
    ! (Maybe) create the attribute
    shp = shape(value)
    if ( startMakeAttrib ( itemId, name, H5T_NATIVE_REAL, spaceID, &
      & attrID, skip_if_already_there, shp ) ) then
      ! Write
      call h5aWrite_f ( attrID, H5T_NATIVE_REAL, value, &
        & int ( (/ shp, ones(1:6) /), hsize_t ), status )
      call finishMakeAttrib ( name, status, attrID, spaceID )
    end if
    call trace_end ( cond=.false. )
  end subroutine MakeHDF5Attribute_snglarr1

  ! ----------------------------------  MakeHDF5Attribute_dblarr1  -----
  subroutine MakeHDF5Attribute_dblarr1 ( itemID, name, value , &
   & skip_if_already_there )
    integer, intent(in) :: ITEMID            ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME    ! Name of attribute
    double precision, intent(in) :: VALUE(:) ! The attribute array itself
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: spaceID                  ! ID for dataspace
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_dblarr1', cond=.false. )
    ! (Maybe) create the attribute
    shp = shape(value)
    if ( startMakeAttrib ( itemId, name, H5T_NATIVE_DOUBLE, spaceID, &
      & attrID, skip_if_already_there, shp ) ) then
      ! Write
      call h5aWrite_f ( attrID, H5T_NATIVE_DOUBLE, value, &
        & int ( (/ shp, ones(1:6) /), hsize_t ), status )
      call finishMakeAttrib ( name, status, attrID, spaceID )
    end if
    call trace_end ( cond=.false. )
  end subroutine MakeHDF5Attribute_dblarr1

  ! ----------------------------------  MakeHDF5Attribute_intarr1  -----
  subroutine MakeHDF5Attribute_intarr1 ( itemID, name, value , &
   & skip_if_already_there )
    integer, intent(in) :: ITEMID         ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    integer, intent(in) :: VALUE(:)       ! The attribute array itself
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: spaceID                  ! ID for dataspace
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape

    ! Executable code
    call trace_begin ( me, 'MakeHDF5Attribute_intarr1', cond=.false. )
    ! (Maybe) create the attribute
    shp = shape(value)
    if ( startMakeAttrib ( itemId, name, H5T_NATIVE_INTEGER, spaceID, &
      & attrID, skip_if_already_there, shp ) ) then
      ! Write
      call h5aWrite_f ( attrID, H5T_NATIVE_INTEGER, value, &
        & int ( (/ shp, ones(1:6) /), hsize_t ), status )
      call finishMakeAttrib ( name, status, attrID, spaceID )
    end if
    call trace_end ( cond=.false. )
  end subroutine MakeHDF5Attribute_intarr1

  ! -----------------------------------  MakeHDF5AttributeDSN_int  -----
  subroutine MakeHDF5AttributeDSN_int ( fileID, dataName, attrName, value, &
   & skip_if_already_there )
    integer, intent(in) :: FILEID       ! FIle where to find them
    character (len=*), intent(in) :: DATANAME ! Name of data set
    character (len=*), intent(in) :: ATTRNAME ! Name of attribute
    integer, intent(in) :: VALUE        ! Value of attribute
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: dataID                   ! ID for dataspace
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag from HDF5
    logical :: my_skip

    ! Executable code
    call trace_begin ( me, 'MakeHDF5AttributeDSN_int', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) go to 9
    end if
    dataID = name_to_dataID( fileID, dataName )
    call MakeHDF5Attribute_int ( dataID, attrName, value )
    call h5dclose_f ( dataID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close data ' // trim(dataName) )

  9 call trace_end ( cond=.false. )
  end subroutine MakeHDF5AttributeDSN_int

  ! -------------------------------  MakeHDF5AttributeDSN_logical  -----
  ! Sorry--this could not be made part of MakeHDF5Attribute
  ! it conflicts with MakeHDF5Attribute_string generic
  ! all because of the skip_if_already_there optional argument
  subroutine MakeHDF5AttributeDSN_logical ( fileID, dataName, attrName, value, &
   & skip_if_already_there )
    integer, intent(in) :: FILEID       ! FIle where to find them
    character (len=*), intent(in) :: DATANAME ! Name of data set
    character (len=*), intent(in) :: ATTRNAME ! Name of attribute
    logical, intent(in) :: VALUE        ! Value of attribute
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: dataID                   ! ID for data
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag from HDF5
    logical :: my_skip

    ! Executable code
    call trace_begin ( me, 'MakeHDF5AttributeDSN_logical', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) go to 9
    end if
    dataID = name_to_dataID( fileID, dataName)
    call MakeHDF5Attribute_logical ( dataID, attrName, value )
    call h5dclose_f ( dataID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close data ' // trim(dataName) )

  9 call trace_end ( cond=.false. )
  end subroutine MakeHDF5AttributeDSN_logical

  ! --------------------------------  MakeHDF5AttributeDSN_string  -----
  subroutine MakeHDF5AttributeDSN_string ( fileID, dataName, attrName, value, &
   & skip_if_already_there )
    integer, intent(in) :: FILEID       ! FIle where to find them
    character (len=*), intent(in) :: DATANAME ! Name of data set
    character (len=*), intent(in) :: ATTRNAME ! Name of attribute
    character (len=*), intent(in) :: VALUE ! Value of attribute
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: dataID                   ! ID for data
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_skip
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'MakeHDF5AttributeDSN_string', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) go to 9
    end if
    dataID = name_to_dataID( fileID, dataName)
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_DSID( dataID, attrName ) ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Inconsistency between file/dataName for attribute ' // trim(attrName) )
      end if
    end if
    call MakeHDF5Attribute_string ( dataID, attrName, value )
    call h5dclose_f ( dataID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close data ' // trim(dataName) )

  9 call trace_end ( cond=.false. )
  end subroutine MakeHDF5AttributeDSN_string

  ! -------------------------------  MakeHDF5AttributeDSN_st_arr1  -----
  subroutine MakeHDF5AttributeDSN_st_arr1 ( fileID, dataName, attrName, value, &
   & skip_if_already_there )
    integer, intent(in) :: FILEID       ! FIle where to find them
    character (len=*), intent(in) :: DATANAME ! Name of data set
    character (len=*), intent(in) :: ATTRNAME ! Name of attribute
    character (len=*), dimension(:), intent(in) :: VALUE ! Value of attribute
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: dataID                   ! ID for data
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_skip
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'MakeHDF5AttributeDSN_st_arr1', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) go to 9
    end if
    dataID = name_to_dataID( fileID, dataName)
    call MakeHDF5Attribute ( dataID, attrName, value )
    call h5dclose_f(dataID, status)
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close data ' // trim(dataName) )

  9 call trace_end ( cond=.false. )
  end subroutine MakeHDF5AttributeDSN_st_arr1

  ! ------------------------------  MakeHDF5AttributeDSN_single  -----
  subroutine MakeHDF5AttributeDSN_single ( fileID, dataName, attrName, value, &
   & skip_if_already_there )
    integer, intent(in) :: FILEID       ! FIle where to find them
    character (len=*), intent(in) :: DATANAME ! Name of data set
    character (len=*), intent(in) :: ATTRNAME ! Name of attribute
    real, intent(in) :: VALUE        ! The attribute value itself
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: dataID                   ! ID for data
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_skip
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'MakeHDF5AttributeDSN_single', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) go to 9
    end if
    dataID = name_to_dataID( fileID, dataName)
    call MakeHDF5Attribute ( dataID, attrName, value )
    call h5dclose_f ( dataID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close data ' // trim(dataName) )
 9  call trace_end ( cond=.false. )

  end subroutine MakeHDF5AttributeDSN_single

  ! ------------------------------  MakeHDF5AttributeDSN_snglarr1  -----
  subroutine MakeHDF5AttributeDSN_snglarr1 ( fileID, dataName, attrName, value, &
   & skip_if_already_there )
    integer, intent(in) :: FILEID       ! FIle where to find them
    character (len=*), intent(in) :: DATANAME ! Name of data set
    character (len=*), intent(in) :: ATTRNAME ! Name of attribute
    real, intent(in) :: VALUE(:)        ! The attribute array itself
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: dataID                   ! ID for data
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_skip
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'MakeHDF5AttributeDSN_snglarr1', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) go to 9
    end if
    dataID = name_to_dataID( fileID, dataName)
    call MakeHDF5Attribute ( dataID, attrName, value )
    call h5dclose_f ( dataID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close data ' // trim(dataName) )
 9  call trace_end ( cond=.false. )

  end subroutine MakeHDF5AttributeDSN_snglarr1

  ! --------------------------------  MakeHDF5AttributeDSN_double  -----
  subroutine MakeHDF5AttributeDSN_double ( fileID, dataName, attrName, value, &
   & skip_if_already_there )
    integer, intent(in) :: FILEID       ! FIle where to find them
    character (len=*), intent(in) :: DATANAME ! Name of data set
    character (len=*), intent(in) :: ATTRNAME ! Name of attribute
    double precision, intent(in) :: VALUE  ! The attribute value itself
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: dataID                   ! ID for data
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_skip
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'MakeHDF5AttributeDSN_double', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) go to 9
    end if
    dataID = name_to_dataID( fileID, dataName)
    call MakeHDF5Attribute ( dataID, attrName, value )
    call h5dclose_f ( dataID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close data ' // trim(dataName) )
  9 call trace_end ( cond=.false. )

  end subroutine MakeHDF5AttributeDSN_double

  ! -------------------------------  MakeHDF5AttributeDSN_dblarr1  -----
  subroutine MakeHDF5AttributeDSN_dblarr1 ( fileID, dataName, attrName, value, &
   & skip_if_already_there )
    integer, intent(in) :: FILEID       ! FIle where to find them
    character (len=*), intent(in) :: DATANAME ! Name of data set
    character (len=*), intent(in) :: ATTRNAME ! Name of attribute
    double precision, intent(in) :: VALUE(:)  ! The attribute array itself
    logical, intent(in), optional :: skip_if_already_there

    ! Local variables
    integer :: dataID                   ! ID for data
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_skip
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'MakeHDF5AttributeDSN_dblarr1', cond=.false. )
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) go to 9
    end if
    dataID = name_to_dataID( fileID, dataName)
    call MakeHDF5Attribute ( dataID, attrName, value )
    call h5dclose_f ( dataID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close data ' // trim(dataName) )
  9 call trace_end ( cond=.false. )

  end subroutine MakeHDF5AttributeDSN_dblarr1

  ! --------------------------------------  MakeNestedGroups  -----
  ! Make a nested set of groups, beginning with groupNames(1)
  ! and ending with groupNames(n)
  ! If innermostID present, it will contain grpID(n)
  ! Otherwise, we'll close all the grpIDs
  subroutine MakeNestedGroups ( locID, groupNames, innermostID )
    integer, intent(in)                         :: locID  ! Where to base groups at
    character (len=*), intent(in), dimension(:) :: groupNames
    integer, intent(out), optional              :: innermostID ! grpID(n)

    ! Local variables
    integer :: containerID              ! ID for container
    integer :: grpID                    ! ID for new group
    integer :: i
    integer, dimension(size(groupNames)) :: IDs
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'MakeNestedGroups', cond=.false. )
    containerID = locID
    ! call dump( groupNames, 'groupNames' )
    ! call outputNamedValue( 'size(groupNames)', size(groupNames) )
    do i=1, size(groupNames)
      ! call outputNamedValue( 'groupName(i)', trim(groupnames(i)) )
      if ( len_trim(groupnames(i)) < 1 ) then
        iDs(i) = -1
        cycle
      elseif ( .not. IsHDF5GroupPresent ( containerID, trim(groupnames(i))) ) then
        !  Must create this group
        call h5gCreate_f ( containerID, trim(groupnames(i)), grpID, status )
      else
        ! Must open this group
        call h5gopen_f ( containerID, trim(groupnames(i)), grpID, status )
      endif
      containerID = grpID
      iDs(i) = grpID
    enddo
    if ( present(innermostID) ) then
      innermostID = containerID
    else
      do i=1, size(groupNames)
        if ( IDs(i) > 0 ) call h5gclose_f ( IDs(i), status )
      enddo
    endif
    call trace_end ( cond=.false. )
  end subroutine MakeNestedGroups

  ! ---------------------------------------  GetHDF5Attribute_int  -----
  subroutine GetHDF5Attribute_int ( MLSFile, name, value )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name of attribute
    integer, intent(out) :: VALUE         ! Result

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attribute_int', cond=.false. )
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%grp_ID, name, attrID, status )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'no valid sd_id or grp_id to get attribute', MLSFile=MLSFile)
      go to 9
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name), &
      & MLSFile=MLSFile )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read an array into our one value.
    call h5aread_f ( attrID, H5T_NATIVE_INTEGER, value, ones, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name), &
      & MLSFile=MLSFile )
  9 call trace_end ( cond=.false. )
  end subroutine GetHDF5Attribute_int

  ! -----------------------------------  GetHDF5Attribute_intarr1  -----
  subroutine GetHDF5Attribute_intarr1 ( MLSFile, name, value )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name of attribute
    integer, intent(out) :: VALUE(:)      ! Result

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: Me = -1                  ! String index for trace cacheing
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attribute_intarr1', cond=.false. )
    shp = shape(value)
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%grp_ID, name, attrID, status )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'no valid sd_id or grp_id to get attribute', MLSFile=MLSFile)
      go to 9
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name), &
      & MLSFile=MLSFile )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read an array into our one value.
    call h5aread_f ( attrID, H5T_NATIVE_INTEGER, value, &
      & int ( (/ shp, ones(1:6) /), hsize_t ), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name), &
      & MLSFile=MLSFile )
  9 call trace_end ( cond=.false. )
  end subroutine GetHDF5Attribute_intarr1

  ! ------------------------------------  GetHDF5Attribute_string  -----
  subroutine GetHDF5Attribute_string ( MLSFile, name, value )
    use HDF5, only: H5TIs_Variable_Str_F, H5SGet_Simple_Extent_NPoints_F
    use, intrinsic :: Iso_C_Binding
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME   ! Name of attribute
    character (len=*), intent(out) :: VALUE ! Result

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    ! logical, parameter :: DEEBUG = .true.
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: VarLenStr                ! Is the string length variable?
    integer :: dspace_id
    integer(kind=Size_t) :: n_pts
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer :: STRINGTYPE               ! String type

    ! Executable code
    value = ''
    call trace_begin ( me, 'GetHDF5Attribute_string', cond=.false. )
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%grp_ID, name, attrID, status )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'no valid sd_id or grp_id to get attribute', MLSFile=MLSFile)
      go to 9
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5aGet_type_f ( attrID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5tis_variable_str_f ( stringType, VarLenStr, Status )
    if ( DEEBug ) then
      call outputnamedvalue ( 'string length variable?', VarLenStr )
      call h5aget_space_f ( attrID, dspace_id, status )
      call outputnamedvalue ( 'dspace_id', dspace_id )
      call h5sget_simple_extent_npoints_f ( dspace_id, n_pts, status )
      call outputnamedvalue ( 'n_pts', int(n_pts) )
    endif
    if ( stringSize > len(value) ) then
      call outputnamedValue( 'stringSize', int(stringSize) )
      call outputnamedValue( 'len(value)', len(value) )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Value too long to fit in space given for attribute ' // trim(name), &
        & MLSFile=MLSFile )
    elseif( DEEBUG ) then
      call outputnamedValue( 'stringSize', int(stringSize) )
      call outputnamedValue( 'len(value)', len(value) )
    endif

    ! Now actually read the data!
    if ( VarLenStr ) then
      call VariableStringLength
    else
      call FixedStringLength
    endif
    if( DEEBUG ) print *, trim(value)
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5tClose_f ( stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close string type for attribute ' // trim(name), &
      & MLSFile=MLSFile )
  9 call trace_end ( cond=.false. )
  contains
    subroutine FixedStringLength
      call h5aread_f ( attrID, stringType, value, ones, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to read attribute ' // trim(name), &
        & MLSFile=MLSFile )
      ! In case there are any nulls, we will replace them with blanks
      status = FindFirst( value, achar(0) )
      if ( status > 0 ) value( status: ) = ' '
    end subroutine FixedStringLength
    subroutine VariableStringLength
      integer, parameter :: max_len = 132
      character(len=max_len, kind=c_char), pointer :: cdata ! A pointer to a Fortran string
      integer(hsize_t), dimension(1:1) :: dims = (/1/)
      type(c_ptr) :: f_ptr
      integer :: length
      integer :: i
      integer(hsize_t), dimension(1:1) :: maxdims
      integer :: mem_space_id
      type(c_ptr), dimension(:), allocatable, target :: rdata ! Read buffer
      call h5aget_space_f ( attrID, mem_space_id, status )
      call h5sget_simple_extent_dims_f ( mem_space_id, dims, maxdims, status )

      allocate(rdata(1:dims(1)))
      !
      ! Read the data.
      !
      f_ptr = C_LOC( rdata(1) )
      CALL H5aread_f( attrID, H5T_STRING, f_ptr, status )
      !
      ! Output the variable-length data to the screen.
      !
      do i = 1, dims(1)
         call c_f_pointer( rdata(i), cdata )
         length = 0
         do while( cdata(length+1:length+1) .ne. c_null_char )
            length = length + 1
            value(length:length) = cdata(length:length)
         enddo
         if( DEEBUG ) write( *,'(a)' ) cdata( 1:length )
      end do
      !
      ! Close and release resources.
      !
      call h5sclose_f( mem_space_id, status )

    end subroutine VariableStringLength
  end subroutine GetHDF5Attribute_string

  ! --------------------------------  GetHDF5Attribute_stringarr1  -----
  subroutine GetHDF5Attribute_stringarr1 ( MLSFile, name, value )
    use HDF5, only: H5TIs_Variable_Str_F
    use, intrinsic :: Iso_C_Binding
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name of attribute
    character (len=*), intent(out) :: VALUE(:) ! Result

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    logical :: VarLenStr                ! Is the string length variable?
    integer :: Me = -1                  ! String index for trace cacheing
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer :: STRINGTYPE               ! String type

    ! Executable code
    value = ''
    call trace_begin ( me, 'GetHDF5Attribute_stringarr1', cond=.false. )
    shp = shape(value)
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%grp_ID, name, attrID, status )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'no valid sd_id or grp_id to get attribute', MLSFile=MLSFile)
      go to 9
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5aGet_type_f ( attrID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 1-d string attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for 1-d string attribute ' // trim(name), &
      & MLSFile=MLSFile )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for attribute ' // trim(name), &
      & MLSFile=MLSFile )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read an array into our one value.
    call h5tis_variable_str_f ( stringType, VarLenStr, Status )

    ! Now actually read the data!
    if ( VarLenStr ) then
      call VariableStringLength
    else
      call FixedStringLength
    endif
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5tClose_f ( stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close string type for attribute ' // trim(name), &
      & MLSFile=MLSFile )
  9 call trace_end ( cond=.false. )
  contains
    subroutine FixedStringLength
      call h5aread_f ( attrID, stringType, value, &
        & int ( (/ shp, ones(1:6) /), hsize_t ), status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to read attribute ' // trim(name), &
        & MLSFile=MLSFile )
    end subroutine FixedStringLength
    subroutine VariableStringLength
      integer, parameter :: max_len = 132
      character(len=max_len, kind=c_char), pointer :: cdata ! A pointer to a Fortran string
      integer(hsize_t), dimension(1:1) :: dims = (/1/)
      type(c_ptr) :: f_ptr
      integer :: length
      integer :: i
      integer(hsize_t), dimension(1:1) :: maxdims
      integer :: mem_space_id
      type(c_ptr), dimension(:), allocatable, target :: rdata ! Read buffer
      call h5aget_space_f ( attrID, mem_space_id, status )
      call h5sget_simple_extent_dims_f ( mem_space_id, dims, maxdims, status )

      allocate(rdata(1:dims(1)))
      !
      ! Read the data.
      !
      f_ptr = C_LOC( rdata(1) )
      CALL H5aread_f( attrID, H5T_STRING, f_ptr, status )
      !
      ! Output the variable-length data to the screen.
      !
      do i = 1, dims(1)
         call c_f_pointer( rdata(i), cdata )
         length = 0
         do while( cdata(length+1:length+1) .ne. c_null_char )
            length = length + 1
            value(length) = cdata(length:length)
         enddo
         if( DEEBUG ) write( *,'(a)' ) cdata( 1:length )
      end do
      !
      ! Close and release resources.
      !
      call h5sclose_f( mem_space_id, status )

    end subroutine VariableStringLength
  end subroutine GetHDF5Attribute_stringarr1

  ! -----------------------------------  GetHDF5Attribute_logical  -----
  subroutine GetHDF5Attribute_logical ( MLSFile, name, value )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name of attribute
    logical, intent(out) :: VALUE         ! Value of attribute

    ! Local variables
    integer :: IVALUE                     ! Value as integer
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attribute_logical', cond=.false. )
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call GetHDF5Attribute ( MLSFile%fileID%sd_ID, name, iValue )
      if ( DEEBUG ) call outputNamedValue( 'MLSFile%fileID%sd_ID', MLSFile%fileID%sd_ID )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call GetHDF5Attribute ( MLSFile%fileID%grp_ID, name, iValue )
      if ( DEEBUG ) call outputNamedValue( 'MLSFile%fileID%grp_ID', MLSFile%fileID%sd_ID )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'no valid sd_id or grp_id to get attribute', MLSFile=MLSFile)
      go to 9
    endif

    if ( DEEBUG ) call outputNamedValue( 'ivalue', ivalue )
    value = ( iValue == 1 )
  9 call trace_end ( cond=.false. )
  end subroutine GetHDF5Attribute_logical

  ! -------------------------------  GetHDF5Attribute_logicalarr1  -----
  subroutine GetHDF5Attribute_logicalarr1 ( MLSFile, name, value )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name of attribute
    logical, intent(out) :: VALUE(:)      ! Value of attribute

    ! Local variables
    integer :: IVALUE(size(VALUE,1))      ! Value as integer
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attribute_logicalarr1', cond=.false. )
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call GetHDF5Attribute ( MLSFile%fileID%sd_ID, name, iValue )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call GetHDF5Attribute ( MLSFile%fileID%grp_ID, name, iValue )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'no valid sd_id or grp_id to get attribute', MLSFile=MLSFile)
      go to 9
    endif
    value = ( iValue == 1 )
  9 call trace_end ( cond=.false. )
  end subroutine GetHDF5Attribute_logicalarr1

  ! ----------------------------------  GetHDF5Attribute_snglarr1  -----
  subroutine GetHDF5Attribute_snglarr1 ( MLSFile, name, value )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name of attribute
    real, intent(out) :: VALUE(:)       ! The attribute array result

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: Me = -1                  ! String index for trace cacheing
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attribute_snglarr1', cond=.false. )
    shp = shape(value)
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%grp_ID, name, attrID, status )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'no valid sd_id or grp_id to get attribute', MLSFile=MLSFile)
      go to 9
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name), &
      & MLSFile=MLSFile )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read too big array into ours.
    call h5aread_f ( attrID, H5T_NATIVE_REAL, value, &
      & int ( (/ shp, ones(1:6) /), hsize_t ), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read 1d attribute array ' // trim(name), &
      & MLSFile=MLSFile )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close 1d attribute array  ' // trim(name), &
      & MLSFile=MLSFile )
  9 call trace_end ( cond=.false. )
  end subroutine GetHDF5Attribute_snglarr1

  ! --------------------------------------  GetHDF5Attribute_sngl  -----
  subroutine GetHDF5Attribute_sngl ( MLSFile, name, value )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name of attribute
    real, intent(out) :: VALUE          ! The attribute result

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attribute_sngl', cond=.false. )
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%grp_ID, name, attrID, status )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'no valid sd_id or grp_id to get attribute', MLSFile=MLSFile)
      go to 9
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name), &
      & MLSFile=MLSFile )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read too big array into ours.
    call h5aread_f ( attrID, H5T_NATIVE_REAL, value, &
      & ones, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read sngl attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close sngl attribute  ' // trim(name) )
  9 call trace_end ( cond=.false. )
  end subroutine GetHDF5Attribute_sngl

  ! ---------------------------------------  GetHDF5Attribute_dbl  -----
  subroutine GetHDF5Attribute_dbl ( MLSFile, name, value )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME  ! Name of attribute
    double precision, intent(out) :: VALUE ! The attribute result

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attribute_dbl', cond=.false. )
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%grp_ID, name, attrID, status )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'no valid sd_id or grp_id to get attribute', MLSFile=MLSFile)
      go to 9
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name), &
      & MLSFile=MLSFile )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read too big array into ours.
    call h5aread_f ( attrID, H5T_NATIVE_DOUBLE, value, ones, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read dble attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dble attribute  ' // trim(name), &
      & MLSFile=MLSFile )
  9 call trace_end ( cond=.false. )
  end subroutine GetHDF5Attribute_dbl

  ! -----------------------------------  GetHDF5Attribute_dblarr1  -----
  subroutine GetHDF5Attribute_dblarr1 ( MLSFile, name, value )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME     ! Name of attribute
    double precision, intent(out) :: VALUE(:) ! The attribute result

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: Me = -1                  ! String index for trace cacheing
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attribute_dblarr1', cond=.false. )
    shp = shape(value)
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%grp_ID, name, attrID, status )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'no valid sd_id or grp_id to get attribute', MLSFile=MLSFile)
      go to 9
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name), &
      & MLSFile=MLSFile )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read too big array into ours.
    call h5aread_f ( attrID, H5T_NATIVE_DOUBLE, value, &
      & int ( (/ shp, ones(1:6) /), hsize_t ), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read dblarr1 attribute ' // trim(name), &
      & MLSFile=MLSFile )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dblarr1 attribute  ' // trim(name), &
      & MLSFile=MLSFile )
  9 call trace_end ( cond=.false. )
  end subroutine GetHDF5Attribute_dblarr1

  ! ---------------------------------------  GetHDF5Attr_ID_int  -----
  subroutine GetHDF5Attr_ID_int ( itemID, name, value )
    integer, intent(in) :: ITEMID         ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    integer, intent(out) :: VALUE         ! Result

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attr_ID_int', cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = itemID
    MLSFile%stillOpen = .true.
    call GetHDF5Attribute ( MLSFile, name, value )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5Attr_ID_int

  ! -----------------------------------  GetHDF5Attr_ID_intarr1  -----
  subroutine GetHDF5Attr_ID_intarr1 ( itemID, name, value )
    integer, intent(in) :: ITEMID         ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    integer, intent(out) :: VALUE(:)      ! Result

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attr_ID_intarr1', cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = itemID
    MLSFile%stillOpen = .true.
    call GetHDF5Attribute ( MLSFile, name, value )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5Attr_ID_intarr1

  ! ------------------------------------  GetHDF5Attr_ID_string  -----
  subroutine GetHDF5Attr_ID_string ( itemID, name, value )
    integer, intent(in) :: ITEMID           ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME   ! Name of attribute
    character (len=*), intent(out) :: VALUE ! Result

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attr_ID_string', cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = itemID
    MLSFile%stillOpen = .true.
    call GetHDF5Attribute ( MLSFile, name, value )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5Attr_ID_string

  ! --------------------------------  GetHDF5Attr_ID_stringarr1  -----
  subroutine GetHDF5Attr_ID_stringarr1 ( itemID, name, value )
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    character (len=*), intent(out) :: VALUE(:) ! Result

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attr_ID_stringarr1', cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = itemID
    MLSFile%stillOpen = .true.
    call GetHDF5Attribute ( MLSFile, name, value )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5Attr_ID_stringarr1

  ! -----------------------------------  GetHDF5Attr_ID_logical  -----
  subroutine GetHDF5Attr_ID_logical ( itemID, name, value )
    integer, intent(in) :: ITEMID         ! Group etc. to get attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    logical, intent(out) :: VALUE         ! Value of attribute

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attr_ID_logical', cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = itemID
    MLSFile%stillOpen = .true.
    call GetHDF5Attribute ( MLSFile, name, value )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5Attr_ID_logical

  ! -------------------------------  GetHDF5Attr_ID_logicalarr1  -----
  subroutine GetHDF5Attr_ID_logicalarr1 ( itemID, name, value )
    integer, intent(in) :: ITEMID         ! Group etc. to get attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    logical, intent(out) :: VALUE(:)      ! Value of attribute

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attr_ID_logicalarr1', cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = itemID
    MLSFile%stillOpen = .true.
    call GetHDF5Attribute ( MLSFile, name, value )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5Attr_ID_logicalarr1

  ! ----------------------------------  GetHDF5Attr_ID_snglarr1  -----
  subroutine GetHDF5Attr_ID_snglarr1 ( itemID, name, value )
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    real, intent(out) :: VALUE(:)       ! The attribute array result

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attr_ID_snglarr1', cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = itemID
    MLSFile%stillOpen = .true.
    call GetHDF5Attribute ( MLSFile, name, value )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5Attr_ID_snglarr1

  ! --------------------------------------  GetHDF5Attr_ID_sngl  -----
  subroutine GetHDF5Attr_ID_sngl ( itemID, name, value )
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    real, intent(out) :: VALUE          ! The attribute result

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attr_ID_sngl', cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = itemID
    MLSFile%stillOpen = .true.
    call GetHDF5Attribute ( MLSFile, name, value )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5Attr_ID_sngl

  ! ---------------------------------------  GetHDF5Attr_ID_dbl  -----
  subroutine GetHDF5Attr_ID_dbl ( itemID, name, value )
    integer, intent(in) :: ITEMID          ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME  ! Name of attribute
    double precision, intent(out) :: VALUE ! The attribute result

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attr_ID_dbl', cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = itemID
    MLSFile%stillOpen = .true.
    call GetHDF5Attribute ( MLSFile, name, value )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5Attr_ID_dbl

  ! -------------------------------------  GetHDF5Attr_ID_dblarr1  -----
  subroutine GetHDF5Attr_ID_dblarr1 ( itemID, name, value )
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME     ! Name of attribute
    double precision, intent(out) :: VALUE(:) ! The attribute result

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5Attr_ID_dblarr1', cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = itemID
    MLSFile%stillOpen = .true.
    call GetHDF5Attribute ( MLSFile, name, value )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5Attr_ID_dblarr1

  ! --------------------------------  GetHDF5AttributePtr_intarr1  -----
  subroutine GetHDF5AttributePtr_intarr1 ( itemID, name, value, LowBound )
    ! Allocate Value and read attribute Name into it
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: ITEMID         ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    integer, pointer :: VALUE(:)          ! Result
    integer, intent(in), optional :: LowBound ! of allocated value, else 1

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: LB                       ! 1, else LowBound
    integer :: Me = -1                  ! String index for trace cacheing
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP  ! Shape
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5AttributePtr_intarr1', cond=.false. )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    call GetHDF5AttrDims ( itemID, trim(name), shp, maxShp )
    call allocate_test ( value, int(lb-1+maxShp(1)), name, moduleName )
    call h5aOpen_name_f ( itemID, name, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name) )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read an array into our one value.
    call h5aread_f ( attrID, H5T_NATIVE_INTEGER, value, &
      & (/ shp, ones(1:6) /), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read attribute ' // trim(name) )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name) )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5AttributePtr_intarr1

  ! -----------------------------  GetHDF5AttributePtr_stringarr1  -----
  subroutine GetHDF5AttributePtr_stringarr1 ( itemID, name, value, LowBound )
    ! Allocate Value and read attribute Name into it
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: ITEMID          ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME  ! Name of attribute
    character (len=*), pointer :: VALUE(:) ! Result
    integer, intent(in), optional :: LowBound ! of allocated value, else 1

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: LB                       ! 1, else LowBound
    integer :: Me = -1                  ! String index for trace cacheing
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP ! Shape
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer :: STRINGTYPE               ! String type

    ! Executable code
    call trace_begin ( me, 'GetHDF5AttributePtr_stringarr1', cond=.false. )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    call GetHDF5AttrDims ( itemID, trim(name), shp, maxShp )
    call allocate_test ( value, int(lb-1+maxShp(1)), name, moduleName )
    call h5aOpen_name_f ( itemID, name, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name) )
    call h5aGet_type_f ( attrID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 1-d string attribute ' // trim(name) )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for 1-d string attribute ' // trim(name) )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for attribute ' // trim(name) )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read an array into our one value.
    call h5aread_f ( attrID, stringType, value, &
      & (/ shp, ones(1:6) /), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read attribute ' // trim(name) )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name) )
    call h5tClose_f ( stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close string type for attribute ' // trim(name) )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5AttributePtr_stringarr1

  ! ----------------------------  GetHDF5AttributePtr_logicalarr1  -----
  subroutine GetHDF5AttributePtr_logicalarr1 ( itemID, name, value, LowBound )
    use Allocate_Deallocate, only: Deallocate_Test
    integer, intent(in) :: ITEMID         ! Group etc. to get attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    logical, pointer :: VALUE(:)          ! Value of attribute
    integer, intent(in), optional :: LowBound ! of allocated value, else 1

    ! Local variables
    integer, pointer :: IVALUE(:)         ! Value as integer
    integer :: Me = -1                    ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'GetHDF5AttributePtr_logicalarr1', cond=.false. )
    nullify ( ivalue )
    call GetHDF5AttributePtr ( itemID, name, iValue, lowBound )
    value = ( iValue == 1 )
    call deallocate_test ( ivalue, name, moduleName )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5AttributePtr_logicalarr1

  ! -------------------------------  GetHDF5AttributePtr_snglarr1  -----
  subroutine GetHDF5AttributePtr_snglarr1 ( itemID, name, value, LowBound )
    ! Allocate Value and read attribute Name into it
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: ITEMID         ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    real, pointer :: VALUE(:)             ! The attribute array result
    integer, intent(in), optional :: LowBound ! of allocated value, else 1

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: LB                       ! 1, else LowBound
    integer :: Me = -1                  ! String index for trace cacheing
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP  ! Shape
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5AttributePtr_snglarr1', cond=.false. )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    call GetHDF5AttrDims ( itemID, trim(name), shp, maxShp )
    call allocate_test ( value, int(lb-1+maxShp(1)), name, moduleName )
    call h5aOpen_name_f ( itemID, name, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name) )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read too big array into ours.
    call h5aread_f ( attrID, H5T_NATIVE_REAL, value, &
      & (/ shp, int(ones(1:6), hsize_t) /), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read 1d attribute array ' // trim(name) )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close 1d attribute array  ' // trim(name) )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5AttributePtr_snglarr1

  ! ---------------------------------  GetHDF5AttributePtr_dblarr1  -----
  subroutine GetHDF5AttributePtr_dblarr1 ( itemID, name, value, LowBound )
    ! Allocate Value and read attribute Name into it
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: ITEMID         ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    double precision, pointer :: VALUE(:) ! The attribute result
    integer, intent(in), optional :: LowBound ! of allocated value, else 1

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: LB                       ! 1, else LowBound
    integer :: Me = -1                  ! String index for trace cacheing
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP  ! Shape
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'GetHDF5AttributePtr_dblarr1', cond=.false. )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    call GetHDF5AttrDims ( itemID, trim(name), shp, maxShp )
    call allocate_test ( value, int(lb-1+maxShp(1)), name, moduleName )
    call h5aOpen_name_f ( itemID, name, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name) )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read too big array into ours.
    call h5aread_f ( attrID, H5T_NATIVE_DOUBLE, value, &
      & (/ shp, int(ones(1:6), hsize_t) /), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read dblarr1 attribute ' // trim(name) )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dblarr1 attribute  ' // trim(name) )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5AttributePtr_dblarr1

  ! -----------------------------------  GetAllHDF5GroupNames  -----
  subroutine GetAllHDF5GroupNames ( FileID, GroupNames )
    integer, intent(in) :: FILEID          ! fileID
    character (len=*), intent(out) :: GroupNames ! Names of Group in file (,-separated)

    ! Local variables
    integer :: h5error
    integer :: i                        ! loop counter
    character(len=32) :: objName
    integer :: objType
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag
    integer :: nsubmembers
    logical, parameter :: DeeBug = .false.
    ! Executable code
    call trace_begin ( me, 'GetAllHDF5GroupNames', cond=.false. )
    GroupNames = ' '
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for all grp names' )
    call h5gn_members_f( FileID, '/', nsubmembers, h5error )
    if ( DeeBug ) call outputNamedValue ( 'nsubmembers', nsubmembers )
    ! This number is actually greater than it should be--
    ! another nasty hdf5 gotcha
    do i = 0, nsubmembers-1
      call h5gget_obj_info_idx_f( FileID, '/', i, &
        & objName, objType, h5error )
      if ( DeeBug ) call outputNamedValue ( 'objName', trim(objName) )
      if ( DeeBug ) call outputNamedValue ( 'objType', objType )
      if ( h5error /= 0 ) exit
      if ( objType /= H5G_Group_F ) cycle
      if ( len_trim( GroupNames ) < 1 ) then
        GroupNames = objName
      else
        GroupNames = trim(GroupNames) // ',' // objName
      endif
    enddo
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for all grp names' )
    call trace_end ( cond=.false. )
  end subroutine GetAllHDF5GroupNames

  ! ---------------------------------  MatchHDF5Attributes  -----
  subroutine MatchHDF5Attributes ( MLSFile, attrNames, attrValues, name )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: attrNames ! Names of attrs matched (,-separated)
    character (len=*), intent(in) :: attrValues ! Corresponding values (,-separated)
    character (len=*), intent(out) :: name ! DS name with matching attributes

    ! Local variables
    integer, parameter :: MAXATTRNAMELEN = 128
    logical, parameter :: DEEBUG = .false.
    integer :: attr
    character(len=MAXATTRNAMELEN) :: AttrName
    integer :: ds
    character(len=MAXATTRNAMELEN) :: DSName
    character(len=MAXNAMELEN*MAXNDSNAMES) :: DSNames
    integer :: error
    integer :: numattrs
    character(len=MAXATTRNAMELEN) :: status
    character(len=MAXATTRNAMELEN) :: value

    ! Executable code
    name = ' '
    numAttrs = NumStringElements ( attrNames, countEmpty )
    if ( DEEBUG ) call outputNamedValue( 'numAttrs', numAttrs )
    ! Do we have any FileID fields?
    If ( .not. MLSFile%stillOpen .or. all( &
      & (/ MLSFile%FileId%f_id, MLSFile%FileId%grp_id, MLSFile%FileId%sd_id /) &
      & == 0 ) ) then
      call mls_OpenFile( MLSFile, error )
      if ( error /= 0 ) then
        if ( DEEBUG ) call outputNamedValue( 'error in MatchHDF5Attributes', error )
      return
      endif
    endif
    call GetAllHDF5DSNames( MLSFile, DSNames )
    if ( NumStringElements( DSNames, countEmpty ) < 1 ) return
    allnames: do ds=1, NumStringElements( DSNames, countEmpty )
      DSName = StringElement(DSNames, ds, countEmpty)
      if ( DEEBUG ) call outputNamedValue( 'DS name', trim(DSName) )
      do attr=1, numAttrs
        attrname = StringElement(attrNames, attr, countEmpty)
        if( .not. ReadHDF5Attribute( MLSFile%fileID%f_id, &
          & trim(DSName), trim(attrName), &
          & value, status ) )  then
          if ( DEEBUG ) call outputNamedValue( 'status', status )
          cycle allnames
        endif
        if ( DEEBUG ) then
          call outputNamedValue( 'attr name', StringElement(attrNames, attr, countEmpty) )
          call outputNamedValue( 'its attr value', value )
          call outputNamedValue( 'compared with', StringElement(attrValues, attr, countEmpty) )
        endif
        if ( lowercase(value) /= &
          & lowercase(StringElement(attrValues, attr, countEmpty) ) &
          & ) cycle allnames
      end do
      ! If we survived this long, we must have a match
      name = StringElement(DSNames, ds, countEmpty)
      return
    end do allnames
  end subroutine MatchHDF5Attributes

  !---------------------- ReadHDF5Attr_FID_int ---------------------
  function ReadHDF5Attr_FID_int (fileid, dsName, attrName, value, error) &
    & result(success)
      integer, intent(in) :: fileid
      character(len=*), intent(in) :: dsName
      character(len=*), intent(in) :: attrName
      integer, intent(out) :: value
      character(len=*), optional, intent(out) :: error
      logical :: success

      integer :: setid, attrid, stat, minlen
      character(len=256) :: myerror ! our error message should not exceed 256 characters

      myerror = ' '
      if ( present(error) ) minlen = min(len(error), len(myerror))
      call h5dopen_f (fileid, dsName, setid, stat)
      if (stat /= 0) then
          success = .false.
          if  (present(error)) then
              myerror = 'Cannot open dataset ' // dsName
              error = myerror(1:minlen)
              return
          endif
      endif

      call h5aopen_name_f(setid, attrName, attrid, stat)
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Cannot open attribute ' // attrName // ' of dataset ' // dsName
              error = myerror(1:minlen)
              return
          endif
      endif

      call h5aread_f (attrid, H5T_NATIVE_INTEGER, value, ones, stat)
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Cannot read attribute ' // attrName // ' of dataset ' // dsName
              error = myerror(1:minlen)
              return
          endif
      endif

      call h5aClose_f ( attrID, stat )
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Cannot close attribute ' // attrName // ' of dataset ' // dsName
              error = myerror(1:minlen)
              return
          endif
      endif

      call h5dclose_f (setid, stat)
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Cannot close dataset ' // dsName
              error = myerror(1:minlen)
              return
          endif
      endif
      success = .true.
  end function

  !--------------------- ReadHDF5Attr_FID_string --------------------
  function ReadHDF5Attr_FID_string (fileid, dsName, attrName, value, error) &
    & result(success)
      integer, intent(in) :: fileid
      character(len=*), intent(in) :: dsName
      character(len=*), intent(in) :: attrName
      character(len=*), intent(out) :: value
      character(len=*), optional, intent(out) :: error
      logical :: success

      integer :: setid, attrid, stat, stringtype, minlen
      integer(kind=size_t) :: stringsize
      character(len=256) :: myerror ! error message shouldn't exceed 256 characters

      myerror = ' '
      value = ' '
      if ( present(error) ) minlen = min(len(error), len(myerror))
      call h5dopen_f (fileid, dsName, setid, stat)
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Cannot open dataset ' // dsName
              error = myerror (1:minlen)
              return
          endif
      endif

      call h5aopen_name_f(setid, attrName, attrid, stat)
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Cannot open attribute ' // attrName // ' of dataset ' &
                & // dsName
              error = myerror(1:minlen)
              return
          endif
      endif

      call h5aGet_type_f ( attrID, stringType, stat )
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Unable to find type info for ' // attrName // &
                & ' of dataset ' // dsname
              error = myerror(1:minlen)
              return
          endif
      endif

      call h5tGet_size_f ( stringType, stringSize, stat )
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Unable to find size info for ' // attrName // &
                & ' of dataset ' // dsname
              error = myerror(1:minlen)
              return
          endif
      endif

      if (stringsize > len(value)) then
          success = .false.
          if (present(error)) then
              myerror = 'String is not long enough to store attribute ' // &
                & attrName // ' of dataset ' // dsname
              error = myerror(1:minlen)
              return
          endif
      endif

      call h5aread_f ( attrID, stringType, value(1:stringSize), ones, stat)
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Cannot read attribute ' // attrName // ' of dataset ' &
                & // dsname
              error = myerror(1:minlen)
              return
          endif
      endif

      call h5tClose_f(stringtype, stat)
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Cannot close type for attribute ' // attrName // ' of dataset ' // dsname
              error = myerror(1:minlen)
              return
          endif
      endif

      call h5aClose_f ( attrID, stat )
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Cannot close attribute ' // attrName // ' of dataset ' // dsName
              error = myerror(1:minlen)
              return
          endif
      endif

      call h5dclose_f (setid, stat)
      if (stat /= 0) then
          success = .false.
          if (present(error)) then
              myerror = 'Cannot close dataset ' // dsName
              error = myerror(1:minlen)
              return
          endif
      endif

      success = .true.
  end function

  ! --------------------------------------------  GetHDF5AttrDims  -----
  subroutine GetHDF5AttrDims ( ItemID, name, DIMS, maxDims )
    integer, intent(in) :: ItemID         ! ItemID
    character (len=*), intent(in) :: NAME ! Name of DS
    integer(kind=hSize_t), dimension(:), intent(out) :: DIMS ! Values of dimensions
    integer(kind=hSize_t), dimension(:), optional, intent(out) :: MAXDIMS ! max Values

    ! Local variables
    ! logical, parameter :: DEEBUG = .true.
    integer :: AttrID                   ! ID for Attr
    integer :: classID
    integer :: dspace_id                ! spaceID for Attr
    integer(kind=hSize_t), dimension(:), allocatable :: maxdims_ptr
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: my_rank, rank
    integer :: STATUS                   ! Flag
    integer :: type_id
    integer(kind=Size_t) :: type_size

    ! Executable code
    call trace_begin ( me, 'GetHDF5AttrDims', cond=.false. )
    ! Initializing values returned if there was trouble
    dims = -1
    if ( present(maxDims)) maxDims = -1
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before getting dims of ' // trim(name) )
    call h5aOpen_name_f ( itemID, trim(name), attrID, status )
    call h5aGet_type_f ( attrID, type_id, status )
    call h5tGet_size_f ( type_id, type_size, status )
    call h5tget_class_f ( type_id, classID, status )
    call h5aget_space_f ( attrID, dspace_id, status )
    if ( status /= 0 ) call outputNamedValue ( 'h5dget_space_f status', status )
    call h5sget_simple_extent_ndims_f ( dspace_id, rank, status )
    if ( status /= 0 ) call outputNamedValue ( 'h5sget_simple_extent_ndims_f status', status )
    my_rank = min(rank, size(dims))
    allocate ( maxdims_ptr(my_rank) )
    call h5sget_simple_extent_dims_f ( dspace_id, dims(1:my_rank), &
         maxdims_ptr, status )
    if ( status /= my_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dims for attr ' // trim(name) )
    if ( DEEBUG ) then
      call outputNamedValue ( 'name', name )
      call outputNamedValue ( 'attrID', attrID )
      call outputNamedValue ( 'type_id', type_id )
      call outputNamedValue ( 'type_size', int(type_size) )
      call outputNamedValue ( 'classID', classID )
      call outputNamedValue ( 'dspaceID', dspace_ID )
      call outputNamedValue ( 'rank', rank )
      call outputNamedValue ( 'my_rank', my_rank )
      call outputNamedValue ( 'dims', int(dims, kind(status)) )
      call outputNamedValue ( 'maxdims_ptr', int(maxdims_ptr, kind(status)) )
    endif
    call h5aClose_f ( attrID, status )
    if ( present(maxDims) ) maxdims = maxdims_ptr(1:my_rank)
    deallocate ( maxdims_ptr )
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after getting dims of ' // trim(name) )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5AttrDims

  ! ----------------------------------------------  GetHDF5DSDims  -----
  subroutine GetHDF5DSDims_ID ( FileID, name, DIMS, maxDims )
    integer, intent(in) :: FILEID         ! fileID
    character (len=*), intent(in) :: NAME ! Name of DS
    integer(kind=hSize_t), dimension(:), intent(out) :: DIMS ! Values of dimensions
    integer(kind=hSize_t), dimension(:), optional, intent(out) :: MAXDIMS ! max Values

    ! Local variables
    integer :: dspace_id                ! spaceID for DS
    integer(kind=hSize_t), dimension(:), pointer :: maxdims_ptr
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: my_rank, rank
    integer :: SETID                    ! ID for DS
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'GetHDF5DSDims', cond=.false. )
    ! Initializing values returned if there was trouble
    dims = -1
    if ( present(maxDims)) maxDims = -1
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before getting dims ' // trim(name) )
    call h5dOpen_f ( FileID, trim(name), setID, status )
    call h5dget_space_f ( setID, dspace_id, status )
    call h5sget_simple_extent_ndims_f ( dspace_id, rank, status )
    my_rank = min(rank, size(dims))
    allocate ( maxdims_ptr(my_rank) )
    call h5sget_simple_extent_dims_f ( dspace_id, dims(1:my_rank), &
         maxdims_ptr, status )
    if ( status /= my_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dims for datset ' // trim(name) )
    call h5dClose_f ( setID, status )
    if ( present(maxDims) ) maxdims = maxdims_ptr
    deallocate ( maxdims_ptr )
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after getting dims ' // trim(name) )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5DSDims_ID

  subroutine GetHDF5DSDims_MLSFile ( MLSFile, name, DIMS, maxDims )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name of DS
    integer(kind=hSize_t), dimension(:), intent(out) :: DIMS ! Values of dimensions
    integer(kind=hSize_t), dimension(:), optional, intent(out) :: MAXDIMS ! max Values

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'GetHDF5DSDims_MLSFile', cond=.false. )
    ! Do we have any FileID fields?
    If ( .not. MLSFile%stillOpen .or. all( &
      & (/ MLSFile%FileId%f_id, MLSFile%FileId%grp_id, MLSFile%FileId%sd_id /) &
      & == 0 ) ) then
      call h5fopen_f ( trim(MLSFile%name), H5F_ACC_RDONLY_F, MLSFile%fileID%f_id, status )
      call GetHDF5DSDims( MLSFile%fileID%f_id, name, DIMS, maxDims )
      call h5fclose_f ( MLSFile%fileID%f_id, status )
      MLSFile%fileID%f_id = 0
    elseif( MLSFile%FileId%grp_id > 0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'How can we read Dimensions from a group?', MLSFile=MLSFile )
      ! call GetHDF5DSDims( MLSFile%fileID%grp_id, name, DIMS, maxDims )
    elseif( MLSFile%FileId%f_id > 0 ) then
      call GetHDF5DSDims( MLSFile%fileID%f_id, name, DIMS, maxDims )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'all fields of MLSFile%Fileid are 0', MLSFile=MLSFile )
    endif
    call trace_end ( cond=.false. )
  end subroutine GetHDF5DSDims_MLSFile

  ! ----------------------------------------------  GetHDF5DSRank  -----
  subroutine GetHDF5DSRank_MLSFile ( MLSFile, name, rank )
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name of DS
    integer, intent(out) :: rank        ! How many dimensions

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'GetHDF5DSRank_MLSFile', cond=.false. )
    ! Do we have any FileID fields?
    If ( .not. MLSFile%stillOpen .or. all( &
      & (/ MLSFile%FileId%f_id, MLSFile%FileId%grp_id, MLSFile%FileId%sd_id /) &
      & == 0 ) ) then
      call h5fopen_f ( trim(MLSFile%name), H5F_ACC_RDONLY_F, MLSFile%fileID%f_id, status )
      call GetHDF5DSRank_ID( MLSFile%fileID%f_id, name, rank )
      call h5fclose_f ( MLSFile%fileID%f_id, status )
      MLSFile%fileID%f_id = 0
    elseif( MLSFile%FileId%grp_id > 0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'How can we read rank from a group?', MLSFile=MLSFile )
      ! call GetHDF5DSRank_ID( MLSFile%fileID%grp_id, name, rank )
    elseif( MLSFile%FileId%f_id > 0 ) then
      call GetHDF5DSRank_ID( MLSFile%fileID%f_id, name, rank )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'all fields of MLSFile%Fileid are 0', MLSFile=MLSFile )
    endif
    call trace_end ( cond=.false. )
  end subroutine GetHDF5DSRank_MLSFile

  subroutine GetHDF5DSRank_ID ( FileID, name, rank )
    integer, intent(in) :: FILEID       ! fileID
    character (len=*), intent(in) :: NAME ! Name of DS
    integer, intent(out) :: rank        ! How many dimensions

    ! Local variables
    integer :: dspace_id                ! spaceID for DS
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID for DS
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'GetHDF5DSRank', cond=.false. )
    rank = -1                           ! means trouble
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before getting rank ' // trim(name) )
    call h5dOpen_f ( FileID, trim(name), setID, status )
    call h5dget_space_f(setID,dspace_id,status)
    call h5sget_simple_extent_ndims_f(dspace_id,rank,status)
    call h5dClose_f ( setID, status )
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after getting rank ' // trim(name) )
    call trace_end ( cond=.false. )
  end subroutine GetHDF5DSRank_ID

  ! ---------------------------------------------  GetHDF5DSQType  -----
  subroutine GetHDF5DSQType ( FileID, name, Qtype )
    integer, intent(in) :: FILEID       ! fileID
    character (len=*), intent(in) :: NAME ! Name of DS
    character (len=*), intent(out) :: Qtype    ! 'real' or 'integer' or ..

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID for DS
    integer :: STATUS                   ! Flag
    integer :: type_id                  ! typeID for DS

    ! Executable code
    call trace_begin ( me, 'GetHDF5DSQType', cond=.false. )
    Qtype = 'unknown'                   ! means trouble
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before getting datatype of ' // trim(name) )
    call h5dOpen_f ( FileID, trim(name), setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open before getting datatype of ' // trim(name) )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get datatype ' // trim(name) )
    call h5dget_type_f( setID, type_id, status )
    Qtype = WhatTypeAmI ( type_id )
    call h5dClose_f ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close after datatype ' // trim(name) )
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after getting rank ' // trim(name))
    call trace_end ( cond=.false. )
  end subroutine GetHDF5DSQType

  ! --------------------------------------  IsHDF5AttributeInFile_DS  -----
  function IsHDF5AttributeInFile_DS ( filename, DSname, name ) &
    & result(SooDesu)
    ! This routine returns true if the given HDF5 DS is present
    ! Possible refiements:
    ! Add interface for MLSFile type
    character (len=*), intent(in) :: FILENAME ! Where to look
    character (len=*), intent(in) :: DSNAME ! Name for the dataset
    character (len=*), intent(in) :: NAME ! Name for the attribute
    logical                       :: SOODESU

    ! Local variables
    integer :: ATTRID                   ! ID for attribute if present
    integer :: fileID                   ! Where to look
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID for DS if present
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'IsHDF5AttributeInFile_DS', cond=.false. )
    SooDesu = .false.
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for attribute ' // trim(name) )
    call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, fileID, status)
    if ( status == 0 ) then
      call h5dOpen_f ( fileid, trim(DSname), setID, status )
      if ( status == 0 ) then
        call h5aopen_name_f(setID, trim(name), attrid, status)
        if ( status == 0 ) then
          SooDesu = .true.
          call h5aclose_f(attrid, status)
        end if
        call h5dClose_f ( setID, status )
      end if
      call h5fclose_f(fileID, status)
    end if
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for attribute ' // trim(name) )
    call trace_end ( cond=.false. )
  end function IsHDF5AttributeInFile_DS

  ! --------------------------------------  IsHDF5AttributeInFile_Grp  -----
  function IsHDF5AttributeInFile_Grp ( filename, name ) &
    & result(SooDesu)
    ! This routine returns true if the given HDF5 DS is present in group '/'
    ! Possible refiements:
    ! Check for attributes to other groups beside root
    ! Add interface for MLSFile type
    character (len=*), intent(in) :: FILENAME ! Where to look
    character (len=*), intent(in) :: NAME ! Name for the attribute
    logical                       :: SOODESU
    ! Local variables
    integer :: ATTRID                   ! ID for attribute if present
    integer :: fileID                   ! Where to look
    integer :: GRPID                    ! ID for group if present
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'IsHDF5AttributeInFile_Grp', cond=.false. )
    SooDesu = .false.
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for attribute ' // trim(name) )
    call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, fileID, status)
    if ( status == 0 ) then
      call h5gOpen_f ( fileid, '/', grpID, status )
      if ( status == 0 ) then
        call h5aopen_name_f(grpID, trim(name), attrid, status)
        if ( status == 0 ) then
          SooDesu = .true.
          call h5aclose_f(attrid, status)
        end if
        call h5gClose_f ( grpID, status )
      end if
      call h5fclose_f(fileID, status)
    end if
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for attribute ' // trim(name) )
    call trace_end ( cond=.false. )
  end function IsHDF5AttributeInFile_Grp

  ! ---------------------------------------------  IsHDF5DSInFile  -----
  logical function IsHDF5DSInFile ( filename, name )
    ! This routine returns true if the given HDF5 DS is present
    character (len=*), intent(in) :: FILENAME ! Where to look
    character (len=*), intent(in) :: NAME ! Name for the dataset

    ! Local variables
    integer :: FILEID                   ! Where to look
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID for DS if present
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'IsHDF5DSInFile', cond=.false. )
    IsHDF5DSInFile = .false.
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for DS ' // trim(name) )
    call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, fileID, status)
    if ( status == 0 ) then
      call h5dOpen_f ( fileid, trim(name), setID, status )
      if ( status == 0 ) then
        IsHDF5DSInFile = .true.
        call h5dClose_f ( setID, status )
      end if
      call h5fclose_f(fileID, status)
    end if
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for DS ' // trim(name) )
    call trace_end ( cond=.false. )
  end function IsHDF5DSInFile

  ! -----------------------------  IsHDF5AttributePresent_in_DSID  -----
  logical function IsHDF5AttributePresent_in_DSID ( SETID, name )
    ! This routine returns true if the given HDF5 attribute is present
    integer, intent(in) :: SETID        ! Dataset ID--Where to look
    character (len=*), intent(in) :: NAME ! Name for the attribute

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: ATTRID                   ! ID for attribute if present
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'IsHDF5AttributePresent_in_DSID', cond=.false. )
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for attribute ' // trim(name) )
    call h5aOpen_name_f ( SETID, name, attrID, status )
    if ( status /= 0 ) then
      IsHDF5AttributePresent_in_DSID = .false.
    else
      IsHDF5AttributePresent_in_DSID = .true.
      call h5aClose_f ( attrID, status )
    end if
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for attribute ' // trim(name) )
    call trace_end ( cond=.false. )
  end function IsHDF5AttributePresent_in_DSID

  ! ------------------------------  IsHDF5AttributePresent_in_fID  -----
  logical function IsHDF5AttributePresent_in_fID ( fileID, DSname, name, &
    & is_grpattr )
    ! This routine returns true if the given HDF5 attribute is present
    ! If present it would be as an attribute either of the dataset DSname
    ! or, if is_grpattr is TRUE, of the group DSname
    integer, intent(in) :: fileID        ! file ID--Where to look
    character (len=*), intent(in) :: DSNAME ! Name for the dataset
    character (len=*), intent(in) :: NAME ! Name for the attribute
    logical, optional, intent(in) :: is_grpattr ! DSNAME is a group name

    ! Local variables
    integer :: ATTRID                   ! ID for attribute if present
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_grpattr
    integer :: SETID                    ! ID for dataset if present
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'IsHDF5AttributePresent_in_fID', cond=.false. )
    my_grpattr = .false.
    if ( present(is_grpattr) ) my_grpattr = is_grpattr
    if ( my_grpattr ) then
      IsHDF5AttributePresent_in_fID = IsHDF5AttributePresent_in_grp ( &
        & DSname, fileID, name)
      go to 9
    end if
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for attribute ' // trim(name) )
    call h5dOpen_f ( fileid, trim(DSname), setID, status )
    if ( status /= 0 ) then
      IsHDF5AttributePresent_in_fID = .false.
    else
      call h5aOpen_name_f ( SETID, name, attrID, status )
      if ( status /= 0 ) then
        IsHDF5AttributePresent_in_fID = .false.
      else
        IsHDF5AttributePresent_in_fID = .true.
        call h5aClose_f ( attrID, status )
      end if
      call h5dClose_f ( setID, status )
    end if
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for attribute ' // trim(name) )
  9 call trace_end ( cond=.false. )
  end function IsHDF5AttributePresent_in_fID

  ! ------------------------------  IsHDF5AttributePresent_in_grp  -----
  logical function IsHDF5AttributePresent_in_grp ( grpName, fileID, name )
    ! This routine returns true if the given HDF5 attribute is present
    ! (Note the unusual ordering of args--to make unambiguous)
    integer, intent(in) :: fileID        ! file ID--Where to look
    character (len=*), intent(in) :: grpName ! Name for the group
    character (len=*), intent(in) :: NAME ! Name for the attribute

    ! Local variables
    integer :: ATTRID                   ! ID for attribute if present
    integer :: GRPID                    ! ID for group if present
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'IsHDF5AttributePresent_in_grp', cond=.false. )
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for attribute ' // trim(name) )
    call h5gopen_f(fileID, trim(grpName), grpid, status)
    if ( status /= 0 ) then
      IsHDF5AttributePresent_in_grp = .false.
    else
      call h5aOpen_name_f ( GRPID, name, attrID, status )
      if ( status /= 0 ) then
        IsHDF5AttributePresent_in_grp = .false.
      else
        IsHDF5AttributePresent_in_grp = .true.
        call h5aClose_f ( attrID, status )
      end if
      call h5gclose_f(grpid, status)
    end if
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for attribute ' // trim(name) )
    call trace_end ( cond=.false. )
  end function IsHDF5AttributePresent_in_grp

  ! ------------------------------  IsHDF5AttributePresent_in_MLSFile  -----
  logical function IsHDF5AttributePresent_in_MLSFile ( MLSFile, name )
    ! This routine returns true if the given HDF5 attribute is present
    ! somewhere under the MLSFile tree
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for the attribute

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'IsHDF5AttributePresent_in_MLSFile', cond=.false. )
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for attribute ' // trim(name) )
    if ( MLSFile%fileID%sd_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
    elseif ( MLSFile%fileID%grp_ID > 0 ) then
      call h5aOpen_name_f ( MLSFile%fileID%grp_ID, name, attrID, status )
    else
      status = -1
    endif
    IsHDF5AttributePresent_in_MLSFile = ( status == 0 )
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for attribute ' // trim(name) )
    call trace_end ( cond=.false. )
  end function IsHDF5AttributePresent_in_MLSFile

  ! --------------------------------------------  IsHDF5DSPresent_in_MLSFile  -----
  logical function IsHDF5DSPresent_in_MLSFile ( MLSFile, name, options )
    ! This routine returns true if the given HDF5 DS is present
    ! options such as "-cw" are explained in notes above
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for the dataset
    character (len=*), optional, intent(in) :: options ! E.g., -c

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: STATUS                   ! Flag
    ! logical, parameter :: DEEBUG = .true.

    ! Executable code
    IsHDF5DSPresent_in_MLSFile = .false.
    call trace_begin ( me, 'IsHDF5DSPresent_in_MLSFile', cond=.false. )
    ! if ( .not. MLSFile%stillOpen .or. all( &
    !   & (/ MLSFile%FileId%f_id, MLSFile%FileId%grp_id, MLSFile%FileId%sd_id /) &
    !   & == 0 ) ) then
    if ( .not. MLSFile%stillOpen ) then
      call MLS_Openfile ( MLSFile, status )
      if ( status /= 0 ) then
        if ( DEEBUG ) &
          & call outputNamedValue( 'error in IsHDF5DSPresent_in_MLSFile', status )
      return
      endif
    endif
    if ( MLSFile%fileID%grp_ID > 0 ) then
      IsHDF5DSPresent_in_MLSFile = &
        & IsHDF5DSPresent_in_fID ( MLSFile%fileID%grp_ID, name, options )
    elseif ( MLSFile%FileID%f_id > 0 ) then
      IsHDF5DSPresent_in_MLSFile = &
        & IsHDF5DSPresent_in_fID ( MLSFile%FileID%f_id, name, options )
    else
      status = -1
    endif
    if ( DEEBUG .and.  .not. IsHDF5DSPresent_in_MLSFile ) &
      & call Dump( MLSFile, details=2 )
    call trace_end ( cond=.false. )
  end function IsHDF5DSPresent_in_MLSFile

  logical function IsHDF5DSPresent_in_fID ( locID, name, options )
    ! This routine returns true if the given HDF5 DS is present
    ! options such as "-cw" are explained in notes above
    integer, intent(in) :: LOCID        ! Where to look
    character (len=*), intent(in) :: NAME ! Name for the dataset
    character (len=*), optional, intent(in) :: options ! E.g., -c
    ! Local variables
    character (len=MAXNDSNAMES*MAXNAMELEN) :: DSNames ! Names of DS in file (,-separated)
    character(len=8) :: myOptions

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID for DS if present
    integer :: STATUS                   ! Flag
    logical, parameter :: DEEBUG = .false.

    ! Executable code
    IsHDF5DSPresent_in_fID = .false.
    call trace_begin ( me, 'IsHDF5DSPresent_in_fID', cond=.false. )
    myOptions = ' ' ! By default, match name exactly
    if (present(options)) myOptions = options
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for DS ' // trim(name) )
    if ( myOptions == ' ' ) then
      call h5dOpen_f ( locID, name, setID, status )
      IsHDF5DSPresent_in_fID = ( status == 0 )
      if ( IsHDF5DSPresent_in_fID ) then
        call h5dClose_f ( setID, status )
      elseif ( DEEBUG ) then
        call MLSMessage ( MLSMSG_Info, ModuleName, &
          & 'Unable to open DS ' // trim(name) )
      endif
    elseif ( index(myOptions, 'a') < 1 ) then
      call GetAllHDF5DSNames_fileID ( locID, '/', DSNames )
      IsHDF5DSPresent_in_fID = IsInList( DSNames, name, options )
    else
      call GetAllHDF5AttrNames( locID, DSNames )
      IsHDF5DSPresent_in_fID = IsInList( DSNames, name, options )
    endif
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for DS ' // trim(name) )
    call trace_end ( cond=.false. )
  end function IsHDF5DSPresent_in_fID

  ! -----------------------------------------  IsHDF5GroupPresent  -----
  logical function IsHDF5GroupPresent ( locID, name )
    ! This routine returns true if the given HDF5 Group is present
    integer, intent(in) :: LOCID        ! Where to look
    character (len=*), intent(in) :: NAME ! Name for the dataset

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID for DS if present
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'IsHDF5GroupPresent', cond=.false. )
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for Group ' // trim(name) )
    call h5GOpen_f ( locID, name, setID, status )
    IsHDF5groupPresent = status == 0
    if ( IsHDF5groupPresent ) call h5GClose_f ( setID, status )
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for Group ' // trim(name) )
    call trace_end ( cond=.false. )
  end function IsHDF5GroupPresent

  ! --------------------------------------------  IsHDF5ItemPresent  -----
  logical function IsHDF5ItemPresent ( locID, name, options )
    ! This routine returns true if the given HDF5 itemis present
    ! options such as "-cw" are explained in notes above
    ! with additional options specifying the item type as follows
    ! d => DS, g => group, a => attribute
    integer, intent(in) :: LOCID        ! Where to look
    character (len=*), intent(in) :: NAME ! Name for the dataset
    character (len=*), optional, intent(in) :: options ! E.g., -c

    ! Local variables
    character (len=MAXNDSNAMES*MAXNAMELEN) :: DSNames ! Names of DS in file (,-separated)
    integer :: Me = -1                  ! String index for trace cacheing
    character(len=8) :: myOptions
    integer :: SETID                    ! ID for DS if present
    integer :: STATUS                   ! Flag

    ! Executable code
    call trace_begin ( me, 'IsHDF5ItemPresent', cond=.false. )
    myOptions = ' ' ! By default, match name exactly, search for sd names
    if (present(options)) myOptions = options
    call mls_eSet_auto ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for item ' // trim(name) )
    if ( myOptions == ' ' .or. myOptions == '-d' ) then
      call h5dOpen_f ( locID, name, setID, status )
      IsHDF5ItemPresent = ( status == 0 )
      if ( IsHDF5ItemPresent ) call h5dClose_f ( setID, status )
    elseif ( index(myOptions, 'g') > 0 ) then
      IsHDF5ItemPresent = IsHDF5GroupPresent (locID, name)
    elseif ( index(myOptions, 'a') < 1 ) then
      call GetAllHDF5DSNames_fileID ( locID, '/', DSNames )
      IsHDF5ItemPresent = IsInList( DSNames, name, options )
      ! print *, 'DSNames ', trim(DSNames)
    else
      call GetAllHDF5AttrNames( locID, DSNames )
      IsHDF5ItemPresent = IsInList( DSNames, name, options )
      ! print *, 'attr Names ', trim(DSNames)
    endif
    call mls_eSet_auto ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for item ' // trim(name) )
    call trace_end ( cond=.false. )
  end function IsHDF5ItemPresent

  ! --------------------------------------  SaveAsHDF5DS_charsclr  -----
  subroutine SaveAsHDF5DS_charsclr ( locID, name, value, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID           ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME  ! Name for this dataset
    character (len=*), intent(in) :: VALUE ! The scalar char string
    logical, optional, intent(in)     :: adding_to

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: myAddingTo
    integer :: nsubmembers
    integer (HID_T) :: setID            ! ID for dataset
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
    integer :: spaceID                  ! ID for dataspace
    integer :: status                   ! Flag from HDF5
    integer(hid_t) :: s_type_id
    integer(hid_t) :: type_id

    ! Executable code
    call trace_begin ( me, 'SaveAsHDF5DS_charsclr', cond=.false. )
    ! Create the dataspace
    myAddingTo = .false.
    if ( present(adding_to) ) myAddingTo = adding_to
    shp = 1
    call h5sCreate_simple_f ( 1, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for scalar character ' // trim(name) )
    type_id = H5T_NATIVE_CHARACTER
    call h5tcopy_f ( type_id, s_type_id, status )
    call h5tset_size_f ( s_type_id, int(len(value), size_t), status )
    ! Create the dataset
    if ( myAddingTo ) then
      call h5dOpen_f ( locID, trim(name), setID, status )
    else
      call h5dCreate_f ( locID, trim(name), s_type_id, spaceID, setID, &
        & status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataset for scalar character ' // trim(name) )
    endif
    ! Write the data
    call h5dWrite_f ( setID, s_type_id, value, &
      & int ( (/ shp, ones(1:6) /), hsize_t ), status )
    call finishSaveDS ( Name, status, setID, spaceID )
    call trace_end ( cond=.false. )
  end subroutine SaveAsHDF5DS_charsclr

  ! --------------------------------------  SaveAsHDF5DS_chararr1  -----
  subroutine SaveAsHDF5DS_chararr1 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(in) :: VALUE(:)     ! The array itself
    character (len=*), optional, intent(in) :: FILLVALUE
    integer, dimension(1), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to

    include 'SaveAsHDF5DS_chararr.f9h'

  end subroutine SaveAsHDF5DS_chararr1

  ! --------------------------------------  SaveAsHDF5DS_chararr2  -----
  subroutine SaveAsHDF5DS_chararr2 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(in) :: VALUE(:,:)     ! The array itself
    character (len=*), optional, intent(in) :: FILLVALUE
    integer, dimension(2), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to

    include 'SaveAsHDF5DS_chararr.f9h'

  end subroutine SaveAsHDF5DS_chararr2

  ! --------------------------------------  SaveAsHDF5DS_textFile  -----
  subroutine SaveAsHDF5DS_textFile ( textFile, locID, name, &
    & maxLineLen, fromNull, adding_to, cr2lf )
    use IO_Stuff, only: Read_TextFile
    ! This routine writes the contents of a textfile as a char-valued dataset
    integer, intent(in) :: LOCID           ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME  ! Name for this dataset
    character (len=*), intent(in) :: textFile ! Name of the textfile
    integer, optional, intent(in) :: maxLineLen
    character(len=1), optional, intent(in) :: fromNull
    logical, optional, intent(in)     :: adding_to ! name may already exits
    logical, optional, intent(in)     :: cr2lf ! convert <cr> to <lf>

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: myAddingTo
    logical :: myConvertCR
    integer :: myMaxLineLen
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
    integer(hid_t) :: s_type_id
    integer(hid_t) :: type_id
    character(LEN=MAXTEXTSIZE)              :: value
    character(len=1) :: wasNull

    ! Executable code
    call trace_begin ( me, 'SaveAsHDF5DS_textFile', cond=.false. )
    myMaxLineLen = DFLTMAXLINELENGTH
    if ( present(maxLineLen) ) myMaxLineLen = maxLineLen
    wasNull = char(32) ! blank space
    if ( present(fromNull) ) wasNull = fromNull
    myAddingTo = .false.
    if ( present(adding_to) ) myAddingTo = adding_to
    myConvertCR = .false.
    if ( present(cr2lf) ) myConvertCR = cr2lf
    ! Try to read the textfile
    value = ' '
    call read_textFile( trim(textFile), value, myMaxLineLen )
    ! Unfortunately, a lot of null characters sneak into this
    value = Replace( value, char(0), wasNull ) ! Replace null with wasNull
    if ( myConvertCR ) &
      & value = Replace( value, char(13), char(10) ) ! Replace null with wasNull
    
    ! Create the dataspace
    shp = 1
    call h5sCreate_simple_f ( 1, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for scalar character ' // trim(name) )
    type_id = H5T_NATIVE_CHARACTER
    call h5tcopy_f ( type_id, s_type_id, status )
    call h5tset_size_f ( s_type_id, int(len_trim(value), size_t), status )

    if ( myAddingTo ) then
      call h5dOpen_f ( locID, trim(name), setID, status )
    else
      ! Create the dataset
      call h5dCreate_f ( locID, trim(name), s_type_id, spaceID, setID, &
        & status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataset for scalar character ' // trim(name) )
    endif
    ! Write the data
    call h5dWrite_f ( setID, s_type_id, trim(value), &
      & int ( (/ shp, ones(1:6) /), hsize_t ), status )
    call finishSaveDS ( name, status, setID, spaceID )
    call trace_end ( cond=.false. )
  end subroutine SaveAsHDF5DS_textFile

  ! ---------------------------------------  SaveAsHDF5DS_intarr1  -----
  subroutine SaveAsHDF5DS_intarr1 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(in) :: VALUE(:)     ! The array itself
    integer, optional, intent(in) :: FILLVALUE
    integer, dimension(1), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to

    include 'SaveAsHDF5DS_intarr.f9h'

  end subroutine SaveAsHDF5DS_intarr1

  ! ---------------------------------------  SaveAsHDF5DS_intarr2  -----
  subroutine SaveAsHDF5DS_intarr2 ( locID, name, value, &
    & fillValue, finalShape, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(in) :: VALUE(:,:)     ! The array itself
    integer, optional, intent(in) :: FILLVALUE
    integer, dimension(2), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to

    include 'SaveAsHDF5DS_intarr.f9h'

  end subroutine SaveAsHDF5DS_intarr2

  ! ---------------------------------------  SaveAsHDF5DS_intarr3  -----
  subroutine SaveAsHDF5DS_intarr3 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(in) :: VALUE(:,:,:)     ! The array itself
    integer, optional, intent(in) :: FILLVALUE
    integer, dimension(3), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to

    include 'SaveAsHDF5DS_intarr.f9h'

  end subroutine SaveAsHDF5DS_intarr3

  ! ---------------------------------------  SaveAsHDF5DS_intarr4  -----
  subroutine SaveAsHDF5DS_intarr4 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(in) :: VALUE(:,:,:,:) ! The array itself
    integer, optional, intent(in) :: FILLVALUE
    integer, dimension(4), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to

    include 'SaveAsHDF5DS_intarr.f9h'

  end subroutine SaveAsHDF5DS_intarr4

  ! ---------------------------------------  SaveAsHDF5DS_logarr1  -----
  subroutine SaveAsHDF5DS_logarr1 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    logical, intent(in) :: VALUE(:)     ! The array itself
    logical, optional, intent(in) :: FILLVALUE
    integer, dimension(1), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    character :: MyFillValue, MyValue(size(value))   ! T = true, F = false

    ! Executable code
    call trace_begin ( me, 'SaveAsHDF5DS_logarr1', cond=.false. )
    ! Turn fillValue into a character
    myFillValue = 'F'
    if ( present(fillValue) ) then
      if ( fillValue ) myFillValue = 'T'
    end if
    ! Turn value into a character
    where ( value )
      myValue = 'T'
    elsewhere
      myValue = 'F'
    endwhere
    ! write ( myValue, '(L1)' ) value
    call saveAsHDF5DS ( locID, name, myValue, finalShape, myFillValue, adding_to )
    call trace_end ( cond=.false. )
  end subroutine SaveAsHDF5DS_logarr1

  ! ---------------------------------------  SaveAsHDF5DS_dblarr1  -----
  subroutine SaveAsHDF5DS_dblarr1 ( locID, name, value, &
    & start, count, stride, block, may_add_to, adding_to, fillValue )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, intent(in) :: VALUE(:)     ! The array itself
    double precision, optional, intent(in) :: FILLVALUE

    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, optional, intent(in)               :: may_add_to
                                 ! May call again to add to same dataset
    logical, optional, intent(in)               :: adding_to
                                 ! Calling again to add to same dataset
    include 'SaveAsHDF5DS_dblarr.f9h'

  end subroutine SaveAsHDF5DS_dblarr1

  ! ---------------------------------------  SaveAsHDF5DS_dblarr2  -----
  subroutine SaveAsHDF5DS_dblarr2 ( locID, name, value, &
    & start, count, stride, block, may_add_to, adding_to, fillValue )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, intent(in) :: VALUE(:,:)  ! The array itself
    double precision, optional, intent(in) :: FILLVALUE

    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, optional, intent(in)               :: may_add_to
                                 ! May call again to add to same dataset
    logical, optional, intent(in)               :: adding_to
                                 ! Calling again to add to same dataset
    include 'SaveAsHDF5DS_dblarr.f9h'

  end subroutine SaveAsHDF5DS_dblarr2

  ! ---------------------------------------  SaveAsHDF5DS_dblarr3  -----
  subroutine SaveAsHDF5DS_dblarr3 ( locID, name, value, &
    & start, count, stride, block, may_add_to, adding_to, fillValue )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, intent(in) :: VALUE(:,:,:)  ! The array itself
    double precision, optional, intent(in) :: FILLVALUE

    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, optional, intent(in)               :: may_add_to
                                 ! May call again to add to same dataset
    logical, optional, intent(in)               :: adding_to
                                 ! Calling again to add to same dataset
    include 'SaveAsHDF5DS_dblarr.f9h'

  end subroutine SaveAsHDF5DS_dblarr3

  ! ---------------------------------------  SaveAsHDF5DS_dblarr4  -----
  subroutine SaveAsHDF5DS_dblarr4 ( locID, name, value, &
    & start, count, stride, block, may_add_to, adding_to, fillValue )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, intent(in) :: VALUE(:,:,:,:)  ! The array itself
    double precision, optional, intent(in) :: FILLVALUE

    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, optional, intent(in)               :: may_add_to
                                 ! May call again to add to same dataset
    logical, optional, intent(in)               :: adding_to
                                 ! Calling again to add to same dataset
    include 'SaveAsHDF5DS_dblarr.f9h'

  end subroutine SaveAsHDF5DS_dblarr4

  ! --------------------------------------  SaveAsHDF5DS_snglarr1  -----
  subroutine SaveAsHDF5DS_snglarr1 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(in) :: VALUE(:)        ! The array itself
    real, optional, intent(in) :: FILLVALUE
    integer, dimension(1), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer (HID_T) :: setID            ! ID for dataset
    integer(kind=hsize_t), dimension(1) :: SHP, MAXDIMS        ! Shape
    integer :: spaceID                  ! ID for dataspace
    integer :: status                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'SaveAsHDF5DS_snglarr1', cond=.false. )
    shp = shape(value)
    maxdims=shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_REAL, &
      & spaceID, setID, status, adding_to, rFill=fillValue )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 1D real array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
      & int ( (/ shp, ones(1:6) /), hsize_t ), status )
    call finishSaveDS ( name, status, setID, spaceID )
    call trace_end ( cond=.false. )
  end subroutine SaveAsHDF5DS_snglarr1

  ! --------------------------------------  SaveAsHDF5DS_snglarr2  -----
  subroutine SaveAsHDF5DS_snglarr2 ( locID, name, value, &
    & start, count, stride, block, may_add_to, adding_to, fillValue )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(in) :: VALUE(:,:)      ! The array itself
    real, optional, intent(in) :: FILLVALUE

    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, optional, intent(in)               :: may_add_to
                                 ! May call again to add to same dataset
    logical, optional, intent(in)               :: adding_to
                                 ! Calling again to add to same dataset

    include 'SaveAsHDF5DS_snglarr.f9h'

  end subroutine SaveAsHDF5DS_snglarr2

  ! --------------------------------------  SaveAsHDF5DS_snglarr3  -----
  subroutine SaveAsHDF5DS_snglarr3 ( locID, name, value, &
    & start, count, stride, block, may_add_to, adding_to, fillValue )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(in) :: VALUE(:,:,:)    ! The array itself
    real, optional, intent(in) :: FILLVALUE
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, optional, intent(in)               :: may_add_to
                                 ! May call again to add to same dataset
    logical, optional, intent(in)               :: adding_to
                                 ! Calling again to add to same dataset

    include 'SaveAsHDF5DS_snglarr.f9h'

  end subroutine SaveAsHDF5DS_snglarr3

  ! --------------------------------------  SaveAsHDF5DS_snglarr4  -----
  subroutine SaveAsHDF5DS_snglarr4 ( locID, name, value, &
    & start, count, stride, block, may_add_to, adding_to, fillValue )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(in) :: VALUE(:,:,:,:)  ! The array itself
    real, optional, intent(in) :: FILLVALUE
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, optional, intent(in)               :: may_add_to
                                 ! May call again to add to same dataset
    logical, optional, intent(in)               :: adding_to
                                 ! Calling again to add to same dataset

    include 'SaveAsHDF5DS_snglarr.f9h'

  end subroutine SaveAsHDF5DS_snglarr4

  ! ------------------------------------  LdFrmHDF5DS_ID_charscalar  -----
  subroutine LdFrmHDF5DS_ID_charscalar ( locID, name, value )
    ! This routine loads a scalar with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(out) :: VALUE    ! The scalar itself

    character(len=*), parameter :: Sfx = 'charscalar'

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    type (MLSFile_T)   :: MLSFile
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'LdFromHDF5DS_ID_'//sfx , cond=.false. )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value )
    call trace_end ( cond=.false. )

  end subroutine LdFrmHDF5DS_ID_charscalar

  ! ------------------------------------  LdFrmHDF5DS_ID_chararr1  -----
  subroutine LdFrmHDF5DS_ID_chararr1 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(out) :: VALUE(:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinates of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'chararr1'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_chararr1

  ! ------------------------------------  LdFrmHDF5DS_ID_chararr2  -----
  subroutine LdFrmHDF5DS_ID_chararr2 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(out) :: VALUE(:,:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'chararr2'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_chararr2

  ! ------------------------------------  LdFrmHDF5DS_ID_chararr3  -----
  subroutine LdFrmHDF5DS_ID_chararr3 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(out) :: VALUE(:,:,:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'chararr3'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_chararr3

  ! -------------------------------------  LdFrmHDF5DS_ID_intarr1  -----
  subroutine LdFrmHDF5DS_ID_intarr1 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(out) :: VALUE(:)      ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'intarr1'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_intarr1

  ! -------------------------------------  LdFrmHDF5DS_ID_intarr2  -----
  subroutine LdFrmHDF5DS_ID_intarr2 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(out) :: VALUE(:,:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'intarr2'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_intarr2

  ! -------------------------------------  LdFrmHDF5DS_ID_intarr3  -----
  subroutine LdFrmHDF5DS_ID_intarr3 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(out) :: VALUE(:,:,:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'intarr3'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_intarr3

  ! -------------------------------------  LdFrmHDF5DS_ID_intarr4  -----
  subroutine LdFrmHDF5DS_ID_intarr4 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID           ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME  ! Name for this dataset
    integer, intent(out) :: VALUE(:,:,:,:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'intarr4'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_intarr4

  ! -------------------------------------  LdFrmHDF5DS_ID_logarr1  -----
  subroutine LdFrmHDF5DS_ID_logarr1 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    logical, intent(out) :: VALUE(:)      ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    character :: MyValue(size(value))   ! 'F' = false, 'T' = true

    ! Executable code
    call trace_begin ( me, 'LdFromHDF5DS_ID_logarr1', cond=.false. )
    call LoadFromHDF5DS ( locID, name, myValue, start, count, stride, block )
    value = myValue == 'T'
    call trace_end ( cond=.false. )
  end subroutine LdFrmHDF5DS_ID_logarr1

  ! -------------------------------------  LdFrmHDF5DS_ID_dblarr1  -----
  subroutine LdFrmHDF5DS_ID_dblarr1 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME     ! Name for this dataset
    double precision, intent(out) :: VALUE(:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'dblarr1'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_dblarr1

  ! -------------------------------------  LdFrmHDF5DS_ID_dblarr2  -----
  subroutine LdFrmHDF5DS_ID_dblarr2 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME       ! Name for this dataset
    double precision, intent(out) :: VALUE(:,:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'dblarr2'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_dblarr2

  ! -------------------------------------  LdFrmHDF5DS_ID_dblarr3  -----
  subroutine LdFrmHDF5DS_ID_dblarr3 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, intent(out) :: VALUE(:,:,:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'dblarr3'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_dblarr3

  ! -------------------------------------  LdFrmHDF5DS_ID_dblarr4  -----
  subroutine LdFrmHDF5DS_ID_dblarr4 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, intent(out) :: VALUE(:,:,:,:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'dblarr4'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_dblarr4

  ! ------------------------------------  LdFrmHDF5DS_ID_snglarr1  -----
  subroutine LdFrmHDF5DS_ID_snglarr1 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:)         ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'snglarr1'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_snglarr1

  ! ------------------------------------  LdFrmHDF5DS_ID_snglarr2  -----
  subroutine LdFrmHDF5DS_ID_snglarr2 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:,:)       ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'snglarr2'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_snglarr2

  ! ------------------------------------  LdFrmHDF5DS_ID_snglarr3  -----
  subroutine LdFrmHDF5DS_ID_snglarr3 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:,:,:)     ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'snglarr3'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_snglarr3

  ! ------------------------------------  LdFrmHDF5DS_ID_snglarr4  -----
  subroutine LdFrmHDF5DS_ID_snglarr4 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:,:,:,:)   ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    character(len=*), parameter :: Sfx = 'snglarr4'

    include 'LdFrmHDF5DS_ID.f9h'

  end subroutine LdFrmHDF5DS_ID_snglarr4

  ! ------------------------------------  LoadFromHDF5DS_charscalar  -----
  subroutine LoadFromHDF5DS_charscalar ( MLSFile, name, value )
    ! This routine loads a scalar with values from a DS
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(out) :: VALUE    ! The scalar itself

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer :: SPACEID                  ! ID of dataspace
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer :: STRINGTYPE               ! String type

    value = ' '
    call trace_begin ( me, 'LoadFromHDF5DS_charscalar', cond=.false. )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dGet_type_f ( setID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for scalar ' // trim(name), &
      & MLSFile=MLSFile )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for scalar ' // trim(name), &
      & MLSFile=MLSFile )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for scalar ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dread_f ( setID, stringtype, value, ones(1:7), status )
    ! In case there are any nulls, we will replace them with blanks
    status = FindFirst( value, achar(0) )
    if ( status > 0 ) value( status: ) = ' '
    call h5dClose_f ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call trace_end ( cond=.false. )

  end subroutine LoadFromHDF5DS_charscalar

  ! ------------------------------------  LoadFromHDF5DS_chararr1  -----
  subroutine LoadFromHDF5DS_chararr1 ( MLSFile, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(out) :: VALUE(:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinates of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    include 'LoadFromHDF5DS_chararr.f9h'

  end subroutine LoadFromHDF5DS_chararr1

  ! ------------------------------------  LoadFromHDF5DS_chararr2  -----
  subroutine LoadFromHDF5DS_chararr2 ( MLSFile, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(out) :: VALUE(:,:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    include 'LoadFromHDF5DS_chararr.f9h'

  end subroutine LoadFromHDF5DS_chararr2

  ! ------------------------------------  LoadFromHDF5DS_chararr3  -----
  subroutine LoadFromHDF5DS_chararr3 ( MLSFile, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(out) :: VALUE(:,:,:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    include 'LoadFromHDF5DS_chararr.f9h'

  end subroutine LoadFromHDF5DS_chararr3

  ! -------------------------------------  LoadFromHDF5DS_intarr1  -----
  subroutine LoadFromHDF5DS_intarr1 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Integer ! HDF type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(out) :: VALUE(:)      ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'intarr1' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_intarr1

  ! -------------------------------------  LoadFromHDF5DS_intarr2  -----
  subroutine LoadFromHDF5DS_intarr2 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Integer ! HDF type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(out) :: VALUE(:,:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'intarr2' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_intarr2

  ! -------------------------------------  LoadFromHDF5DS_intarr3  -----
  subroutine LoadFromHDF5DS_intarr3 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Integer ! HDF type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(out) :: VALUE(:,:,:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'intarr3' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_intarr3

  ! -------------------------------------  LoadFromHDF5DS_intarr4  -----
  subroutine LoadFromHDF5DS_intarr4 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Integer ! HDF type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME  ! Name for this dataset
    integer, intent(out) :: VALUE(:,:,:,:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'intarr4' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_intarr4

  ! -------------------------------------  LoadFromHDF5DS_logarr1  -----
  subroutine LoadFromHDF5DS_logarr1 ( MLSFile, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    logical, intent(out) :: VALUE(:)      ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    character :: MyValue(size(value))   ! 'F' = false, 'T' = true

    ! Executable code
    call trace_begin ( me, 'LoadFromHDF5DS_logarr1', cond=.false. )
    call LoadFromHDF5DS ( MLSFile, name, myValue, start, count, stride, block )
    value = myValue == 'T'
    call trace_end ( cond=.false. )
  end subroutine LoadFromHDF5DS_logarr1

  ! -------------------------------------  LoadFromHDF5DS_dblarr1  -----
  subroutine LoadFromHDF5DS_dblarr1 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Double ! hdf type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME     ! Name for this dataset
    double precision, intent(out) :: VALUE(:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'dblarr1' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_dblarr1

  ! -------------------------------------  LoadFromHDF5DS_dblarr2  -----
  subroutine LoadFromHDF5DS_dblarr2 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Double ! hdf type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME       ! Name for this dataset
    double precision, intent(out) :: VALUE(:,:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'dblarr2' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_dblarr2

  ! -------------------------------------  LoadFromHDF5DS_dblarr3  -----
  subroutine LoadFromHDF5DS_dblarr3 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Double ! hdf type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, intent(out) :: VALUE(:,:,:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'dblarr3' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_dblarr3

  ! -------------------------------------  LoadFromHDF5DS_dblarr4  -----
  subroutine LoadFromHDF5DS_dblarr4 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Double ! hdf type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, intent(out) :: VALUE(:,:,:,:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'dblarr4' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_dblarr4

  ! ------------------------------------  LoadFromHDF5DS_snglarr1  -----
  subroutine LoadFromHDF5DS_snglarr1 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Real ! hdf type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:)         ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'snglarr1' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_snglarr1

  ! ------------------------------------  LoadFromHDF5DS_snglarr2  -----
  subroutine LoadFromHDF5DS_snglarr2 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Real ! hdf type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:,:)       ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'snglarr2' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_snglarr2

  ! ------------------------------------  LoadFromHDF5DS_snglarr3  -----
  subroutine LoadFromHDF5DS_snglarr3 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Real ! hdf type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:,:,:)     ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'snglarr3' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_snglarr3

  ! ------------------------------------  LoadFromHDF5DS_snglarr4  -----
  subroutine LoadFromHDF5DS_snglarr4 ( MLSFile, name, value, &
    & start, count, stride, block, MissingOK )
    ! This routine loads a predefined array with values from a DS
    use H5Global, only: H5T =>  H5T_Native_Real ! hdf type
    type (MLSFile_T)   :: MLSFile
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:,:,:,:)   ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, intent(in), optional :: MissingOK

    character(len=*), parameter :: Sfx = 'snglarr4' ! Type and rank in subr name

    include 'LoadFromHDF5DS.f9h'

  end subroutine LoadFromHDF5DS_snglarr4

  ! ---------------------------------  LoadAllocFromHDF5DS_chararr1  -----
  subroutine LoadAllocFromHDF5DS_chararr1 ( locID, name, value, lowBound )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), allocatable :: VALUE(:) ! The array itself
    integer, intent(in), optional :: LowBound

    ! Local variables
    integer :: LB, UB
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer(hsize_t) :: SHP(1)          ! Shape of value
    integer :: STATUS                   ! Flag from HDF5
    integer :: SPACEID                  ! ID of dataspace
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer :: STRINGTYPE               ! String type

    ! Executable code
    call trace_begin ( me, 'LoadAllocFromHDF5DS_chararr1', cond=.false. )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dGet_type_f ( setID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 1D char array ' // trim(name) )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get string size for 1D char array ' // trim(name) )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 1D char array ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_DS_shape ( spaceID, shp, name )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    ub = lb - 1 + shp(1)
    call allocate_test ( value, ub, name, moduleName, lowBound=lb )
    call h5dread_f ( setID, stringtype, value, (/ shp(1), ones(1:6) /), status )
    call finishLoad ( name, status, spaceID, setID, stringType=stringType )
    call trace_end ( cond=.false. )
  end subroutine LoadAllocFromHDF5DS_chararr1

  ! ---------------------------------  LoadAllocFromHDF5DS_chararr2  -----
  subroutine LoadAllocFromHDF5DS_chararr2 ( locID, name, value )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), allocatable :: VALUE(:,:) ! The array itself

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer(hsize_t) :: SHP(2)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer :: STRINGTYPE               ! String type

    ! Executable code
    call trace_begin ( me, 'LoadAllocFromHDF5DS_chararr2', cond=.false. )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dGet_type_f ( setID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 1D char array ' // trim(name) )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for 1D char array ' // trim(name) )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 1D char array ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_DS_shape ( spaceID, shp, name )
    call allocate_test ( value, int(shp(1)), int(shp(2)), name, moduleName )
    call h5dread_f ( setID, stringtype, value, (/ shp, ones(1:5) /), status )
    call finishLoad ( name, status, spaceID, setID, stringType=stringType )
    call trace_end ( cond=.false. )
  end subroutine LoadAllocFromHDF5DS_chararr2

  ! ----------------------------------  LoadAllocFromHDF5DS_intarr1  -----
  subroutine LoadAllocFromHDF5DS_intarr1 ( locID, name, value, lowBound )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, allocatable :: VALUE(:)          ! The array itself
    integer, intent(in), optional :: LowBound

    ! Local variables
    integer :: LB, UB
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer(hsize_t) :: SHP(1)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'LoadAllocFromHDF5DS_intarr1', cond=.false. )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    ub = lb - 1 + shp(1)
    call allocate_test ( value, ub, name, moduleName, lowBound=lb )
    call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
      & (/ shp, ones(1:6) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call trace_end ( cond=.false. )
  end subroutine LoadAllocFromHDF5DS_intarr1

  ! ----------------------------------  LoadAllocFromHDF5DS_intarr2  -----
  subroutine LoadAllocFromHDF5DS_intarr2 ( locID, name, value )
    ! This routine allocates a allocatable array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Integer ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, allocatable :: VALUE(:,:)        ! The array itself
    character(len=*), parameter :: Sfx = 'intarr2'

    include 'LoadAllocFromHDF5DS.f9h'

  end subroutine LoadAllocFromHDF5DS_intarr2

  ! ----------------------------------  LoadAllocFromHDF5DS_intarr3  -----
  subroutine LoadAllocFromHDF5DS_intarr3 ( locID, name, value )
    ! This routine allocates a allocatable array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Integer ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, allocatable :: VALUE(:,:,:)      ! The array itself
    character(len=*), parameter :: Sfx = 'intarr3'

    include 'LoadAllocFromHDF5DS.f9h'

  end subroutine LoadAllocFromHDF5DS_intarr3

  ! ----------------------------------  LoadAllocFromHDF5DS_intarr4  -----
  subroutine LoadAllocFromHDF5DS_intarr4 ( locID, name, value )
    ! This routine allocates a allocatable array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Integer ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, allocatable :: VALUE(:,:,:,:)    ! The array itself
    character(len=*), parameter :: Sfx = 'intarr4'

    include 'LoadAllocFromHDF5DS.f9h'

  end subroutine LoadAllocFromHDF5DS_intarr4

  ! ----------------------------------  LoadAllocFromHDF5DS_logarr1  -----
  subroutine LoadAllocFromHDF5DS_logarr1 ( locID, name, value, lowBound )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test, DeAllocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    logical, allocatable :: VALUE(:)          ! The array itself
    integer, intent(in), optional :: LowBound

    ! Local variables
    integer :: LB, UB
    integer :: Me = -1                  ! String index for trace cacheing
    character, allocatable :: MyValue(:)      ! 'F' = false, 'T' = true

    ! Executable code
    call trace_begin ( me, 'LoadAllocFromHDF5DS_logarr1', cond=.false. )
    call LoadAllocFromHDF5DS ( locID, name, myValue )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    ub = lb - 1 + size(myValue)
    call allocate_test ( value, ub, name, moduleName, lowBound=lb )
    value = myValue == 'T'
    call deallocate_test ( myValue, name, moduleName )
    call trace_end ( cond=.false. )
  end subroutine LoadAllocFromHDF5DS_logarr1

  ! ----------------------------------  LoadAllocFromHDF5DS_dblarr1  -----
  subroutine LoadAllocFromHDF5DS_dblarr1 ( locID, name, value, lowBound )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, allocatable :: VALUE(:) ! The array itself
    integer, intent(in), optional :: LowBound

    ! Local variables
    integer :: LB, UB
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer(hsize_t) :: SHP(1)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'LoadAllocFromHDF5DS_dblarr1', cond=.false. )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    ub = lb - 1 + shp(1)
    call allocate_test ( value, ub, name, moduleName, lowBound=lb )
    call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & (/ shp, ones(1:6) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call trace_end ( cond=.false. )
  end subroutine LoadAllocFromHDF5DS_dblarr1

  ! ----------------------------------  LoadAllocFromHDF5DS_dblarr2  -----
  subroutine LoadAllocFromHDF5DS_dblarr2 ( locID, name, value )
    ! This routine allocates a allocatable array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Double ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, allocatable :: VALUE(:,:) ! The array itself
    character(len=*), parameter :: Sfx = 'dblarr2'

    include 'LoadAllocFromHDF5DS.f9h'

  end subroutine LoadAllocFromHDF5DS_dblarr2

  ! ----------------------------------  LoadAllocFromHDF5DS_dblarr3  -----
  subroutine LoadAllocFromHDF5DS_dblarr3 ( locID, name, value )
    ! This routine allocates a allocatable array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Double ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, allocatable :: VALUE(:,:,:) ! The array itself
    character(len=*), parameter :: Sfx = 'dblarr3'

    include 'LoadAllocFromHDF5DS.f9h'

  end subroutine LoadAllocFromHDF5DS_dblarr3

  ! ----------------------------------  LoadAllocFromHDF5DS_dblarr4  -----
  subroutine LoadAllocFromHDF5DS_dblarr4 ( locID, name, value )
    ! This routine allocates a allocatable array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Double ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, allocatable :: VALUE(:,:,:,:) ! The array itself
    character(len=*), parameter :: Sfx = 'dblarr4'

    include 'LoadAllocFromHDF5DS.f9h'

  end subroutine LoadAllocFromHDF5DS_dblarr4

  ! ---------------------------------  LoadAllocFromHDF5DS_snglarr1  -----
  subroutine LoadAllocFromHDF5DS_snglarr1 ( locID, name, value, lowBound )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, allocatable :: VALUE(:)             ! The array itself
    integer, intent(in), optional :: LowBound

    ! Local variables
    integer :: LB, UB
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer(hsize_t) :: SHP(1)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'LoadAllocFromHDF5DS_snglarr1', cond=.false. )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    ub = lb - 1 + shp(1)
    call allocate_test ( value, ub, name, moduleName, lowBound=lb )
    call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
      & (/ shp, ones(1:6) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call trace_end ( cond=.false. )
  end subroutine LoadAllocFromHDF5DS_snglarr1

  ! ---------------------------------  LoadAllocFromHDF5DS_snglarr2  -----
  subroutine LoadAllocFromHDF5DS_snglarr2 ( locID, name, value )
    ! This routine allocates a allocatable array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Real ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, allocatable :: VALUE(:,:)           ! The array itself
    character(len=*), parameter :: Sfx = 'snglarr2'

    include 'LoadAllocFromHDF5DS.f9h'

  end subroutine LoadAllocFromHDF5DS_snglarr2

  ! ---------------------------------  LoadAllocFromHDF5DS_snglarr3  -----
  subroutine LoadAllocFromHDF5DS_snglarr3 ( locID, name, value )
    ! This routine allocates a allocatable array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Real ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, allocatable :: VALUE(:,:,:)         ! The array itself
    character(len=*), parameter :: Sfx = 'snglarr3'

    include 'LoadAllocFromHDF5DS.f9h'

  end subroutine LoadAllocFromHDF5DS_snglarr3

  ! ---------------------------------  LoadAllocFromHDF5DS_snglarr4  -----
  subroutine LoadAllocFromHDF5DS_snglarr4 ( locID, name, value )
    ! This routine allocates a allocatable array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Real ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, allocatable :: VALUE(:,:,:,:)       ! The array itself
    character(len=*), parameter :: Sfx = 'snglarr4'

    include 'LoadAllocFromHDF5DS.f9h'

  end subroutine LoadAllocFromHDF5DS_snglarr4

  ! ---------------------------------  LoadPtrFromHDF5DS_chararr1  -----
  subroutine LoadPtrFromHDF5DS_chararr1 ( locID, name, value, lowBound )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), pointer :: VALUE(:) ! The array itself
    integer, intent(in), optional :: LowBound

    ! Local variables
    integer :: LB, UB
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer(hsize_t) :: SHP(1)          ! Shape of value
    integer :: STATUS                   ! Flag from HDF5
    integer :: SPACEID                  ! ID of dataspace
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer :: STRINGTYPE               ! String type

    ! Executable code
    call trace_begin ( me, 'LoadPtrFromHDF5DS_chararr1', cond=.false. )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dGet_type_f ( setID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 1D char array ' // trim(name) )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get string size for 1D char array ' // trim(name) )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 1D char array ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_DS_shape ( spaceID, shp, name )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    ub = lb - 1 + shp(1)
    call allocate_test ( value, ub, name, moduleName, lowBound=lb )
    call h5dread_f ( setID, stringtype, value, (/ shp(1), ones(1:6) /), status )
    call finishLoad ( name, status, spaceID, setID, stringType=stringType )
    call trace_end ( cond=.false. )
  end subroutine LoadPtrFromHDF5DS_chararr1

  ! ---------------------------------  LoadPtrFromHDF5DS_chararr2  -----
  subroutine LoadPtrFromHDF5DS_chararr2 ( locID, name, value )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), pointer :: VALUE(:,:) ! The array itself

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer(hsize_t) :: SHP(2)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer :: STRINGTYPE               ! String type

    ! Executable code
    call trace_begin ( me, 'LoadPtrFromHDF5DS_chararr2', cond=.false. )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dGet_type_f ( setID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 1D char array ' // trim(name) )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for 1D char array ' // trim(name) )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 1D char array ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_DS_shape ( spaceID, shp, name )
    call allocate_test ( value, int(shp(1)), int(shp(2)), name, moduleName )
    call h5dread_f ( setID, stringtype, value, (/ shp, ones(1:5) /), status )
    call finishLoad ( name, status, spaceID, setID, stringType=stringType )
    call trace_end ( cond=.false. )
  end subroutine LoadPtrFromHDF5DS_chararr2

  ! ----------------------------------  LoadPtrFromHDF5DS_intarr1  -----
  subroutine LoadPtrFromHDF5DS_intarr1 ( locID, name, value, lowBound )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, pointer :: VALUE(:)          ! The array itself
    integer, intent(in), optional :: LowBound

    ! Local variables
    integer :: LB, UB
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer(hsize_t) :: SHP(1)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'LoadPtrFromHDF5DS_intarr1', cond=.false. )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    ub = lb - 1 + shp(1)
    call allocate_test ( value, ub, name, moduleName, lowBound=lb )
    call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
      & (/ shp, ones(1:6) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call trace_end ( cond=.false. )
  end subroutine LoadPtrFromHDF5DS_intarr1

  ! ----------------------------------  LoadPtrFromHDF5DS_intarr2  -----
  subroutine LoadPtrFromHDF5DS_intarr2 ( locID, name, value )
    ! This routine allocates a pointer array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Integer ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, pointer :: VALUE(:,:)        ! The array itself
    character(len=*), parameter :: Sfx = 'intarr2'

    include 'LoadPtrFromHDF5DS.f9h'

  end subroutine LoadPtrFromHDF5DS_intarr2

  ! ----------------------------------  LoadPtrFromHDF5DS_intarr3  -----
  subroutine LoadPtrFromHDF5DS_intarr3 ( locID, name, value )
    ! This routine allocates a pointer array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Integer ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, pointer :: VALUE(:,:,:)      ! The array itself
    character(len=*), parameter :: Sfx = 'intarr3'

    include 'LoadPtrFromHDF5DS.f9h'

  end subroutine LoadPtrFromHDF5DS_intarr3

  ! ----------------------------------  LoadPtrFromHDF5DS_intarr4  -----
  subroutine LoadPtrFromHDF5DS_intarr4 ( locID, name, value )
    ! This routine allocates a pointer array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Integer ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, pointer :: VALUE(:,:,:,:)    ! The array itself
    character(len=*), parameter :: Sfx = 'intarr4'

    include 'LoadPtrFromHDF5DS.f9h'

  end subroutine LoadPtrFromHDF5DS_intarr4

  ! ----------------------------------  LoadPtrFromHDF5DS_logarr1  -----
  subroutine LoadPtrFromHDF5DS_logarr1 ( locID, name, value, lowBound )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test, DeAllocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    logical, pointer :: VALUE(:)          ! The array itself
    integer, intent(in), optional :: LowBound

    ! Local variables
    integer :: LB, UB
    integer :: Me = -1                  ! String index for trace cacheing
    character, pointer :: MyValue(:)      ! 'F' = false, 'T' = true

    ! Executable code
    call trace_begin ( me, 'LoadPtrFromHDF5DS_logarr1', cond=.false. )
    nullify ( myValue )
    call LoadPtrFromHDF5DS ( locID, name, myValue )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    ub = lb - 1 + size(myValue)
    call allocate_test ( value, ub, name, moduleName, lowBound=lb )
    value = myValue == 'T'
    call deallocate_test ( myValue, name, moduleName )
    call trace_end ( cond=.false. )
  end subroutine LoadPtrFromHDF5DS_logarr1

  ! ----------------------------------  LoadPtrFromHDF5DS_dblarr1  -----
  subroutine LoadPtrFromHDF5DS_dblarr1 ( locID, name, value, lowBound )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, pointer :: VALUE(:) ! The array itself
    integer, intent(in), optional :: LowBound

    ! Local variables
    integer :: LB, UB
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer(hsize_t) :: SHP(1)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'LoadPtrFromHDF5DS_dblarr1', cond=.false. )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    ub = lb - 1 + shp(1)
    call allocate_test ( value, ub, name, moduleName, lowBound=lb )
    call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & (/ shp, ones(1:6) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call trace_end ( cond=.false. )
  end subroutine LoadPtrFromHDF5DS_dblarr1

  ! ----------------------------------  LoadPtrFromHDF5DS_dblarr2  -----
  subroutine LoadPtrFromHDF5DS_dblarr2 ( locID, name, value )
    ! This routine allocates a pointer array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Double ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, pointer :: VALUE(:,:) ! The array itself
    character(len=*), parameter :: Sfx = 'dblarr2'

    include 'LoadPtrFromHDF5DS.f9h'

  end subroutine LoadPtrFromHDF5DS_dblarr2

  ! ----------------------------------  LoadPtrFromHDF5DS_dblarr3  -----
  subroutine LoadPtrFromHDF5DS_dblarr3 ( locID, name, value )
    ! This routine allocates a pointer array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Double ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, pointer :: VALUE(:,:,:) ! The array itself
    character(len=*), parameter :: Sfx = 'dblarr3'

    include 'LoadPtrFromHDF5DS.f9h'

  end subroutine LoadPtrFromHDF5DS_dblarr3

  ! ----------------------------------  LoadPtrFromHDF5DS_dblarr4  -----
  subroutine LoadPtrFromHDF5DS_dblarr4 ( locID, name, value )
    ! This routine allocates a pointer array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Double ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, pointer :: VALUE(:,:,:,:) ! The array itself
    character(len=*), parameter :: Sfx = 'dblarr4'

    include 'LoadPtrFromHDF5DS.f9h'

  end subroutine LoadPtrFromHDF5DS_dblarr4

  ! ---------------------------------  LoadPtrFromHDF5DS_snglarr1  -----
  subroutine LoadPtrFromHDF5DS_snglarr1 ( locID, name, value, lowBound )
    ! This routine allocates an array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, pointer :: VALUE(:)             ! The array itself
    integer, intent(in), optional :: LowBound

    ! Local variables
    integer :: LB, UB
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: SETID                    ! ID of dataset
    integer(hsize_t) :: SHP(1)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: STATUS                   ! Flag from HDF5

    ! Executable code
    call trace_begin ( me, 'LoadPtrFromHDF5DS_snglarr1', cond=.false. )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    ub = lb - 1 + shp(1)
    call allocate_test ( value, ub, name, moduleName, lowBound=lb )
    call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
      & (/ shp, ones(1:6) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call trace_end ( cond=.false. )
  end subroutine LoadPtrFromHDF5DS_snglarr1

  ! ---------------------------------  LoadPtrFromHDF5DS_snglarr2  -----
  subroutine LoadPtrFromHDF5DS_snglarr2 ( locID, name, value )
    ! This routine allocates a pointer array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Real ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, pointer :: VALUE(:,:)           ! The array itself
    character(len=*), parameter :: Sfx = 'snglarr2'

    include 'LoadPtrFromHDF5DS.f9h'

  end subroutine LoadPtrFromHDF5DS_snglarr2

  ! ---------------------------------  LoadPtrFromHDF5DS_snglarr3  -----
  subroutine LoadPtrFromHDF5DS_snglarr3 ( locID, name, value )
    ! This routine allocates a pointer array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Real ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, pointer :: VALUE(:,:,:)         ! The array itself
    character(len=*), parameter :: Sfx = 'snglarr3'

    include 'LoadPtrFromHDF5DS.f9h'

  end subroutine LoadPtrFromHDF5DS_snglarr3

  ! ---------------------------------  LoadPtrFromHDF5DS_snglarr4  -----
  subroutine LoadPtrFromHDF5DS_snglarr4 ( locID, name, value )
    ! This routine allocates a pointer array and loads it with values from a DS
    use Allocate_Deallocate, only: Allocate_Test
    use H5Global, only: H5T =>  H5T_Native_Real ! hdf type
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, pointer :: VALUE(:,:,:,:)       ! The array itself
    character(len=*), parameter :: Sfx = 'snglarr4'

    include 'LoadPtrFromHDF5DS.f9h'

  end subroutine LoadPtrFromHDF5DS_snglarr4

  ! -----------------------------------  ReadLitIndexFromHDF5Attr  -----
  subroutine ReadLitIndexFromHDF5Attr ( itemID, name, index )
    use MoreTree, only: GetLitIndexFromString
    ! Dummy arguments
    integer, intent(in) :: ITEMID        ! Group etc. to make attr. for
    character(len=*), intent(in) :: NAME ! Name of attribute
    integer, intent(out) :: INDEX        ! String index

    ! Local variables
    character (len=1024) :: LINE
    integer :: L
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'ReadLitIndexFromHDF5Attr', cond=.false. )
    call GetHDF5Attribute ( itemID, name, line )
    l = len_trim(line)
    if ( l > 0 ) then
      index = GetLitIndexFromString ( line(:l) )
    else
      index = 0
    end if
    call trace_end ( cond=.false. )
  end subroutine ReadLitIndexFromHDF5Attr

  ! --------------------------------  ReadStringIndexFromHDF5Attr  -----
  subroutine ReadStringIndexFromHDF5Attr ( itemID, name, index )
    use MoreTree, only: GetStringIndexFromString
    ! Dummy arguments
    integer, intent(in) :: ITEMID        ! Group etc. to make attr. for
    character(len=*), intent(in) :: NAME ! Name of attribute
    integer, intent(out) :: INDEX        ! String index

    ! Local variables
    character (len=1024) :: LINE
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'ReadStringIndexFromHDF5Attr', cond=.false. )
    call GetHDF5Attribute ( itemID, name, line )
    if ( len_trim ( line ) > 0 ) then
      index = GetStringIndexFromString ( trim(line) )
    else
      index = 0
    end if
    call trace_end ( cond=.false. )
  end subroutine ReadStringIndexFromHDF5Attr

  ! -------------------------------  WriteLitIndexAsHDF5Attribute  -----
  subroutine WriteLitIndexAsHDF5Attribute ( itemID, name, index )
    use Intrinsic, only: Lit_Indices
    integer, intent(in) :: ITEMID        ! Group etc. to make attr. for
    character(len=*), intent(in) :: NAME ! Name of attribute
    integer, intent(in) :: INDEX         ! String index

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'WriteLitIndexAsHDF5Attribute', cond=.false. )
    if ( index == 0 ) then
      call MakeHDF5Attribute ( itemID, name, '' )
    else
      call WriteStringIndexAsHDF5Attribute ( itemID, name, lit_indices ( index ) )
    end if
    call trace_end ( cond=.false. )
  end subroutine WriteLitIndexAsHDF5Attribute

  ! ----------------------------  WriteStringIndexAsHDF5Attribute  -----
  subroutine WriteStringIndexAsHDF5Attribute ( itemID, name, index )
    use String_table, only: Get_string
    integer, intent(in) :: ITEMID        ! Group etc. to make attr. for
    character(len=*), intent(in) :: NAME ! Name of attribute
    integer, intent(in) :: INDEX         ! String index

    ! Local variables
    character(len=1024) :: LINE
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'WriteStringIndexAsHDF5Attribute', cond=.false. )
    if ( index == 0 ) then
      call MakeHDF5Attribute ( itemID, name, '' )
    else
      call get_string ( index, line, strip=.true., noError=.true. )
      call MakeHDF5Attribute ( itemID, name, trim(line) )
    end if
    call trace_end ( cond=.false. )
  end subroutine WriteStringIndexAsHDF5Attribute

! ======================= Private Procedures ===========================
! --------------------------------------------  AreThe2TypesEqual  -----
  logical function AreThe2TypesEqual ( type1, type2 )
    ! This routine returns true if the two datatypes are "the same"
    integer, intent(in) :: type1
    integer, intent(in) :: type2
    ! Local variables
    integer :: status
    ! Initialize in case something goes wrong with hdf5 routine
    AreThe2TypesEqual = .false.
    call h5tEqual_f ( type1, type2, AreThe2TypesEqual, status )
    if ( status /= 0 ) AreThe2TypesEqual = .false.
  end function AreThe2TypesEqual

! ------------------------------------------------  Check_for_fit  -----
  subroutine Check_for_fit ( spaceID, value_dims, name )
  ! Checks that dataspace will fit into values before LoadFromHDF5DS
    integer, intent(in)               :: spaceID
    integer(hsize_t), dimension(:), intent(in) :: value_dims
    character (len=*), intent(in)     :: NAME ! Name for this dataset
    integer(hsize_t), dimension(size(value_dims)) :: dims
    integer                           :: i
    call get_ds_shape ( spaceID, dims, name )
    if ( any ( dims > value_dims ) ) &
      & call my_message ( MLSMSG_Error, ModuleName // '%Check_for_fit', &
      & 'Dataspace too large for destination value of ' // trim(name) , &
      & 'dims(space), dims(value)', (/ (int(dims(i)), int(value_dims(i)), i=1, size(dims)) /), &
      & no_pairs=.true. )
  end subroutine Check_for_fit

! -----------------------------------------------  CreateSpaceSet  -----
  subroutine CreateSpaceSet ( locID, name, maxdims, datatype, &
    & spaceID, setID, status, adding_to, cFill, dFill, iFill, rFill, chunk_dims )
  ! Creates or optionally attaches dataspace and dataset
    integer, intent(in)               :: locID
    character (len=*), intent(in)     :: NAME ! Name for this dataset
    integer(hsize_t), dimension(:), intent(in) :: maxdims
    integer, intent(in)               :: datatype
    integer, intent(out)              :: spaceID
    integer, intent(out)              :: setID
    integer, intent(out)              :: status
    logical, optional, intent(in)     :: adding_to
    character(len=*), optional, intent(in) :: cFill
    double precision, optional, intent(in) :: dFill
    integer, optional, intent(in)     :: iFill
    real, optional, intent(in)        :: rFill
    integer, dimension(:), optional, intent(in) :: chunk_dims

    ! Internal variables
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_adding_to
    logical :: my_fill
    integer(hsize_t), dimension(size(maxdims,1)) :: my_chunkdims, my_maxdims
    integer :: Rank
    character(len=1) :: cFilled
    double precision :: dFilled
    integer :: iFilled
    real :: rFilled

    ! Executable
    call trace_begin ( me, 'CreateSpaceSet', cond=.false. )
    my_adding_to = .false.
    if ( present(adding_to) ) my_adding_to = adding_to
    my_chunkdims = maxdims
    rank = size(maxdims,1)
    my_chunkdims(rank) = 1
    if ( present(chunk_dims) ) my_chunkdims = chunk_dims
    my_fill = present(cFill) .or. present(dFill) .or. present(iFill) .or. &
      & present(rFill) .or. present(chunk_dims)
    if ( my_adding_to ) then
      call h5dopen_f ( locID, trim(name), setID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open dataset for ' // trim(name) )
      call h5dget_space_f ( setID, spaceID, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get dataspace for ' // trim(name) )
      if ( my_fill ) then
        ! print *, 'dataspace before extending ', spaceID
        my_maxdims = maxdims
        call h5dextend_f ( setID, my_maxdims, status )
        call h5dget_space_f ( setID, spaceID, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to get dataspace for ' // trim(name) )
        ! print *, 'dataspace after extending ', spaceID
        call h5dget_create_plist_f ( setID, cparms, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to get property list for ' // trim(name) )
        call h5pget_chunk_f ( cparms, rank, my_chunkdims, status )
        ! print *, '(read) rank, my_chunkdims, status'
        ! print *, rank, my_chunkdims, status
        if ( present(cFill) ) then
          call h5pget_fill_value_f ( cparms, H5T_NATIVE_CHARACTER, cFilled, status )
        else if ( present(dFill) ) then
          call h5pget_fill_value_f ( cparms, datatype, dFilled, status )
        else if ( present(iFill) ) then
          call h5pget_fill_value_f ( cparms, datatype, iFilled, status )
          ! print *, 'cparms, datatype, iFilled, status'
          ! print *, cparms, datatype, iFilled, status
        else if ( present(rFill) ) then
          call h5pget_fill_value_f ( cparms, datatype, rFilled, status )
        end if
      end if
    else
      ! Create the dataset
      if ( my_fill ) then
        my_maxdims = maxdims
        my_maxdims(rank) = H5S_UNLIMITED_F
        call h5sCreate_simple_f ( rank, int(maxdims,hSize_T), spaceID, status, &
          & my_maxdims )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to create extensible dataspace ' // trim(name) )
        call h5pcreate_f ( H5P_DATASET_CREATE_F, cparms, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to create property list for ' // trim(name) )
        call h5pset_chunk_f ( cparms, rank, my_chunkdims, status )
        ! print *, 'rank, my_chunkdims, status'
        ! print *, rank, my_chunkdims, status
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to set chunking for ' // trim(name) )
        if ( present(cFill) ) then
          call h5pset_fill_value_f ( cparms, H5T_NATIVE_CHARACTER, cFill, status )
        else if ( present(dFill) ) then
          call h5pset_fill_value_f ( cparms, datatype, dFill, status )
        else if ( present(iFill) ) then
          call h5pset_fill_value_f ( cparms, datatype, iFill, status )
          ! print *, 'cparms, datatype, iFill, status'
          ! print *, cparms, datatype, iFill, status
        else if ( present(rFill) ) then
          call h5pset_fill_value_f (cparms, datatype, rFill, status)
        end if
        if ( status /= 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
          &  "Unable to set Fill value for " // trim (name) )
        call h5dCreate_f ( locID, trim(name), datatype, spaceID, setID, &
          & status, cparms )
        call h5dextend_f ( setID, int(maxdims,hSize_T), status )
        call h5dget_space_f( setID, spaceID, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to get dataspace for ' // trim(name) )
      else
        call h5sCreate_simple_f ( rank, int(maxdims,hSize_T), spaceID, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to create dataspace ' // trim(name) )
        call h5dCreate_f ( locID, trim(name), datatype, spaceID, setID, &
          & status )
      end if
    end if
    call trace_end ( cond=.false. )
  end subroutine CreateSpaceSet

! ---------------------------------------------------  Dump_space  -----
  subroutine Dump_space ( spaceID )
  ! Dumps dataspace info
    integer, intent(in)               :: spaceID
    integer                           :: rank
    integer(hsize_t), dimension(7)    :: dims, maxdims
    integer                           :: status
    logical                           :: is_simple
    call h5sis_simple_f ( spaceID, is_simple, status )
    if ( DEEBUG ) print *, 'is_simple ', is_simple
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( DEEBUG ) print *, 'rank ', rank
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), &
      &  status )
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dims for dumping space' )
    if ( DEEBUG ) print *, 'dims ', dims(1:rank)
    if ( DEEBUG ) print *, 'maxdims ', maxdims(1:rank)
    ! call h5soffset_simple_f ( spaceID, offset(1:rank), &
    !  &  status )
    ! print *, 'offset ', offset(1:rank)
  end subroutine Dump_space

! ---------------------------------------------------  FinishLoad  -----
  subroutine FinishLoad ( Name, Status, SpaceID, SetID, &
    & MemspaceID, StringType, MLSFile )
    ! Checks status and closes stuff to finish Load...
    character(len=*), intent(in) :: Name    ! of the dataset
    integer, intent(inout) :: Status        ! from last read operation
    integer, intent(in) :: SpaceID          ! dataspace ID
    integer, intent(in) :: SetID            ! dataset ID
    integer, intent(in), optional :: MemspaceID ! dataspace ID
    integer, intent(in), optional :: StringType ! stringtype ID
    type (MLSFile_T), optional   :: MLSFile

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable
    call trace_begin ( me, 'FinishLoad', cond=.false. )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5sClose_f ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(memspaceID) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset ' // trim(name), &
        & MLSFile=MLSFile )
    end if
    call h5dClose_f ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(stringType) ) then
      call h5tClose_f ( stringType, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close string type for ' // trim(name), &
        & MLSFile=MLSFile )
    end if
    call trace_end ( cond=.false. )
  end subroutine FinishLoad

! ---------------------------------------------  FinishMakeAttrib  -----
  subroutine FinishMakeAttrib ( Name, Status, AttrID, DSID, StringType )
  ! Check status and close stuff for MakeHDF5Attribute_....
    character(len=*), intent(in) :: Name        ! of the attrib
    integer, intent(inout) :: Status            ! from writing the attrib
    integer, intent(in) :: AttrID               ! attrib ID
    integer, intent(in) :: DSID                 ! dataset ID
    integer, intent(in), optional :: StringType ! stringType ID

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable
    call trace_begin ( me, 'FinishMakeHDF5Attrib', cond=.false. )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write attribute ' // trim(name) )
    ! Finish off
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name) )
    call h5sClose_f ( dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute dataspace ' // trim(name) )
    if ( present(stringType) ) then
      call h5tClose_f ( stringType, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close stringType ' // trim(name) )
    end if
    call trace_end ( cond=.false. )
  end subroutine FinishMakeAttrib

! -------------------------------------------------  FinishSaveDS  -----
  subroutine FinishSaveDS ( Name, Status, SetID, SpaceID, StringType, &
    & MemspaceID )
  ! Check status and close stuff for SaveAsHDF5DS_...
    character(len=*), intent(in) :: Name        ! of the DS
    integer, intent(inout) :: Status            ! from writing the DS
    integer, intent(in) :: SetID                ! dataset ID
    integer, intent(in) :: SpaceID              ! dataspace ID
    integer, intent(in), optional :: StringType ! stringtype ID
    integer, intent(in), optional :: MemspaceID ! arrayspace ID

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable
    call trace_begin ( me, 'FinishSaveDS', cond=.false. )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for ' // trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for ' // trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for ' // trim(name) )
    if ( present(memspaceID) ) then
      call h5sClose_F ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close mem dataspace for ' // trim(name) )
    end if
    if ( present(stringType) ) then
      call h5tClose_f ( stringtype, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close stringtype for ' // trim(name) )
    end if
    call trace_end ( cond=.false. )
  end subroutine FinishSaveDS

! -------------------------------------------------  Get_DS_Shape  -----
  subroutine Get_DS_Shape ( spaceID, dims, name )
  ! Checks that dataspace has the same rank as size(dims), then gets
  ! its dimensions.
    integer, intent(in)               :: spaceID
    integer(hsize_t), dimension(:), intent(out) :: dims
    character (len=*), intent(in)     :: NAME ! Name for this dataset
    integer                           :: rank
    integer                           :: value_rank
    integer(hsize_t)                  :: maxdims(size(dims))
    integer                           :: status

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable
    call trace_begin ( me, 'Get_DS_Shape', cond=.false. )
    value_rank = size(dims)
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( status /= 0 )  call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset ' // trim(name) )
    if ( rank /= value_rank ) call my_message ( MLSMSG_Error, ModuleName, &
      & 'Inconsistent rank for dataset ' // trim(name) , &
      & 'rank(space), rank(values)', (/rank, value_rank/) )
    call h5sget_simple_extent_dims_f ( spaceID, dims, maxdims, status )
    if ( status /= rank ) call my_message ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset ' // trim(name) , &
      & 'rank(space), h5s status', (/rank, status/) )
    call trace_end ( cond=.false. )
  end subroutine Get_DS_Shape

! ---------------------------------------------------  MLS_eSet_auto  -----
  subroutine MLS_eSet_auto ( value, status )
  ! Calls h5eSet_auto_f to turn on (if value==1) or off (if value==0)
  ! error messages printed by the hdf5 library
  ! Unless hdfVerbose, in which case always print
    integer, intent(in)                 :: value
    integer, intent(out)                :: status
    !
    integer                             :: myValue
    ! Executable
    myValue = value
    if ( hdfVerbose ) myValue = 1
    call h5eSet_auto_f ( myvalue, status )
  end subroutine MLS_eSet_auto

! ---------------------------------------------------  MLS_extend  -----
  subroutine MLS_extend ( setID, newCount, start, dataSpaceID )
  ! Checks whether we need to extend setID to accommodate newDims
  ! plus any offsets in start array
  ! Does the extending if necessary
    integer, intent(in)                :: setID
    integer(hsize_t), dimension(:), intent(in)  :: newCount
    integer, dimension(:), optional, intent(in) :: start
    integer, optional, intent(inout) :: dataSpaceID
                                 ! Starting coordinatess of hyperslab
  ! Local variables
    integer(hsize_t), dimension(7)    :: dims, maxdims, my_start
    integer                           :: i
    logical                           :: is_simple
    logical                           :: itFits
    integer :: Me = -1                ! String index for trace cacheing
    integer                           :: rank
    integer                           :: spaceID
    integer                           :: status

  ! Executable code
    call trace_begin ( me, 'MLS_extend', cond=.false. )
    my_start = 0
    dims = 0
    if ( present(start) ) my_start(1:size(start)) = start
    if ( present(dataSpaceID) ) then
      spaceID = dataSpaceID
    else
      call h5dget_space_f(setID, spaceID, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get data space ID to extend data set' )
    end if
    if ( DEEBUG ) print *, 'spaceID ', spaceID
    call h5sis_simple_f ( spaceID, is_simple, status )
    if ( DEEBUG ) print *, 'is simple? ', is_simple
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get data space rank to extend data set' )
    if ( DEEBUG ) print *, 'rank ', rank
    call h5sget_simple_extent_dims_f ( spaceID, dims, maxdims, status )
    if ( status /= rank .and. cantGetDataspaceDims <= MAXNUMWARNS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Unable to get data space dims to extend data set' )
      cantGetDataspaceDims = cantGetDataspaceDims + 1
      if ( cantGetDataspaceDims > MAXNUMWARNS ) &
        & call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Max no. of warnings reached--suppressing further ones')
    end if
    if ( DEEBUG ) print *, 'dims ', dims(1:rank)
    if ( DEEBUG ) print *, 'maxdims ', maxdims(1:rank)
    if ( DEEBUG ) print *, 'status ', status
    itFits = .true.
    do i = 1, min(rank, size(newCount))
      if ( my_start(i) + newCount(i) > dims(i) ) then
        itFits = .false.
        dims(i) = my_start(i) + newCount(i)
      end if
    enddo
    if ( itFits ) go to 9
    if ( DEEBUG ) print *, 'Need to extend dataset'
    if ( DEEBUG ) print *, '(New dims) ', dims
    call h5dextend_f ( setID, dims, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to extend data set in mls_extend' )
    if ( present(dataspaceID) ) then
      call h5dget_space_f ( setID, dataspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get return dataspaceID in mls_extend' )
    end if
  9 call trace_end ( cond=.false. )
  end subroutine MLS_extend

! ------------------------------------------------  MLS_hyperslab  -----
  subroutine MLS_hyperslab ( spaceID, value_dims, name, memspaceID, &
    & start, count, stride, block )
  ! Sits between LoadFromHDF5DS and h5sselect_hyperslab_f
  ! Restriction:
  ! The optional parameters must be present in 1 of the two patterns below
  ! pattern(1): start, count)
  ! pattern(2): start, count, stride, block)
    integer, intent(in)                :: spaceID
    integer, intent(out)               :: memspaceID
    integer(hsize_t), dimension(:), intent(in)  :: value_dims
    character (len=*), intent(in)     :: NAME ! Name for this dataset
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    integer                           :: value_rank, rank
    integer(hsize_t), dimension(7)    :: dims, maxdims
    integer                           :: status
                                 ! Starting coordinatess of hyperslab
    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    ! logical, parameter :: DeeBug = .true.

    ! Begin execution
    call trace_begin ( me, 'MLS_hyperslab', cond=.false. )
    ! Check that pattern 1 or pattern 2 is satisfied
    status = 0
    if ( present(start) ) status = status + 1
    if ( present(count) ) status = status + 2
    if ( present(stride) ) status = status + 4
    if ( present(block) ) status = status + 8
    if ( status /= 3 .and. status /= 15 ) call my_message ( MLSMSG_Error, ModuleName, &
      & 'Impossible optional parameters pattern for dataset ' // trim(name), &
      & 'status', (/status/) )
    value_rank = size(value_dims)
    if ( DEEBUG ) print *, 'value_rank: ', value_rank
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( DEEBUG ) print *, 'dataspace rank: ', rank
    if ( status /= 0 )  call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset ' // trim(name) )
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), &
      &  status )
    if ( DEEBUG ) print *, 'dataspace dims: ', dims(1:rank)
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset ' // trim(name) )
    call h5screate_simple_f(value_rank, &
      & int(value_dims(1:value_rank), hsize_t), memspaceID, &
      & status)
    if ( DEEBUG ) print *, 'memspace id: ', memspaceID
    if ( status /= 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create memspace for dataset ' // trim(name) )
    if ( present(stride) ) then
     if ( DEEBUG ) print *, 'trying to select hyperslab: ', &
       & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t), &
       & int(stride(1:rank), hsize_t), int(block(1:rank), hsize_t)
      if ( rank > size(start) ) then
        print *, 'Error in selecting hyperslab--rank too big for size(start)'
        print *, 'rank   ', rank
        print *, 'start  ', start 
        print *, 'count  ', count 
        print *, 'stride ', stride
        print *, 'block  ', block 
      endif
      call h5sselect_hyperslab_f ( spaceID, H5S_SELECT_SET_F, &
        & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t), status, &
        & int(stride(1:rank), hsize_t), int(block(1:rank), hsize_t) )
    else
      if ( DEEBUG ) print *, 'trying to select hyperslab: ', &
        & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t)
      call h5sselect_hyperslab_f ( spaceID, H5S_SELECT_SET_F, &
        & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t), status )
    end if
    if ( status /= 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to set hyperslab for dataset ' // trim(name) )
    if ( DEEBUG ) print *, 'Returning memspaceID ', memspaceID
    call trace_end ( cond=.false. )
  end subroutine MLS_hyperslab

! -------------------------------------------  MLS_hyperslab_save  -----
  subroutine MLS_hyperslab_save ( spaceID, start, count, stride, block )
  ! Sits between SaveAsHDF5DS and h5sselect_hyperslab_f
  ! Restriction:
  ! The optional parameters must be present in 1 of the two patterns below
  ! pattern(1): start, count)
  ! pattern(2): start, count, stride, block)
    integer, intent(in)                :: spaceID
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    integer                           :: rank
    integer(hsize_t), dimension(7)    :: dims, maxdims
    integer                           :: status
    character(len=*), parameter :: name = 'mls_hyperslab_save'
                                 ! Starting coordinatess of hyperslab
    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing

    ! Begin execution
    call trace_begin ( me, 'MLS_hyperslab_save', cond=.false. )
    ! Check that pattern 1 or pattern 2 is satisfied
    status = 0
    if ( present(start) ) status = status + 1
    if ( present(count) ) status = status + 2
    if ( present(stride) ) status = status + 4
    if ( present(block) ) status = status + 8
    if ( status /= 3 .and. status /= 15 ) call my_message ( MLSMSG_Error, ModuleName, &
      & 'Impossible optional parameters pattern for dataset ' // trim(name), &
      & 'status', (/status/) )
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( DEEBUG ) print *, 'dataspace rank: ', rank
    if ( status /= 0 )  call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset ' // trim(name) )
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), &
      &  status )
    if ( DEEBUG ) print *, 'dataspace dims: ', dims(1:rank)
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset ' // trim(name) )
    if ( present(stride) ) then
     if ( DEEBUG ) print *, 'trying to select hyperslab: ', &
       & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t), &
       & int(stride(1:rank), hsize_t), int(block(1:rank), hsize_t)
      call h5sselect_hyperslab_f ( spaceID, H5S_SELECT_SET_F, &
        & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t), status, &
        & int(stride(1:rank), hsize_t), int(block(1:rank), hsize_t) )
    else
      if ( DEEBUG ) print *, 'trying to select hyperslab: ', &
        & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t)
      call h5sselect_hyperslab_f ( spaceID, H5S_SELECT_SET_F, &
        & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t), status )
    end if
    if ( status /= 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to set hyperslab for dataset ' // trim(name) )
    call trace_end ( cond=.false. )
  end subroutine MLS_hyperslab_save

! ---------------------------------------------------  My_message  -----
  subroutine My_message ( severity, ModuleNameIn, Message, &
    & names, ints, reals, doubles, no_pairs )
    ! Take opportunity to dump a diagnostic table of values before stopping.
    ! Dummy arguments:
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text
    character (len=*), intent(in) :: names   ! comma-separated list of names
    integer, dimension(:), optional, intent(in)          :: ints
    real, dimension(:), optional, intent(in)             :: reals
    double precision, dimension(:), optional, intent(in) :: doubles
    logical, optional, intent(in)                        :: no_pairs
    ! Local variables
    character(len=*), parameter :: int_format = '(i12)'
    character(len=*), parameter :: dbl_format = '(1pd12.2)'
    character(len=*), parameter :: real_format = '(1pe12.2)'
    integer, parameter          :: width = 2
    logical                     :: my_no_pairs
    my_no_pairs = .false.
    if ( present(no_pairs) ) my_no_pairs = no_pairs
    if ( my_no_pairs ) then
      if ( present(ints) ) then
        call dump ( ints, names, &
          & format=int_format, width=width )
      else if ( present(reals) ) then
        call dump ( reals, names )
      else if ( present(doubles) ) then
        call dump ( doubles, names )
      end if
    else
      if ( present(ints) ) then
        call dumpNamedValues ( ints, names, &
          & format=int_format, width=width )
      else if ( present(reals) ) then
        call dumpNamedValues ( reals, names, &
          & format=real_format, width=width )
      else if ( present(doubles) ) then
        call dumpNamedValues ( doubles, names, &
          & format=dbl_format, width=width )
      end if
    end if
    call MLSMessage ( severity, ModuleNameIn, message )
  end subroutine My_message

! -----------------------------------------------  Name_to_attrID  -----
  function Name_to_attrID ( fileID, dataName, attrName, dont_close ) &
   & result(attrID)
  ! Given a file, dataname, attribute name, return attribute ID of that name
  ! unless not there, when return -1
  ! Note that by default both attrName and dataname are left open
  ! (otherwise the returned number becomes invalid for closed names)
  ! (But how will we know what object number to close afterward?
  !  This is a bug.)
    integer, intent(in)               :: fileID
    character (len=*), intent(in)     :: dataNAME ! Name for this dataset
    character (len=*), intent(in)     :: attrNAME ! Name for this attribute
    logical, optional, intent(in)     :: dont_close ! default is TRUE
    integer                           :: attrID
    ! Local variables
    integer :: STATUS                   ! Flag
    integer                           :: dataID
    logical :: my_dont_close
    ! Executable code
    my_dont_close = .TRUE.
    if ( present(dont_close) ) my_dont_close = dont_close
    dataID = -1
    call h5dOpen_f ( fileID, dataName, dataID, status )
    if ( status /= 0 ) then
      attrID = -1
    else
      call h5aOpen_name_f ( dataID, attrName, attrID, status )
      if ( status /= 0 ) then
        attrID = -1
      else
        if ( .not. my_dont_close ) call h5aClose_f ( attrID, status )
      end if
      if ( .not. my_dont_close ) call h5dClose_f ( dataID, status )
    end if
  end function Name_to_attrID

! -----------------------------------------------  Name_to_dataID  -----
  function Name_to_dataID ( fileID, name, dont_close ) result(dataID)
  ! Given a file, dataname, return dataID of that name
  ! unless not there, when return -1
  ! Note that by default the dataname is left open
  ! (otherwise the returned number becomes invalid for a closed dataname)
    integer, intent(in)               :: fileID
    character (len=*), intent(in)     :: NAME ! Name for this dataset
    integer                           :: dataID
    logical, optional, intent(in)     :: dont_close ! default is TRUE
    ! Local variables
    integer :: STATUS                   ! Flag
    logical :: my_dont_close
    ! Executable code
    my_dont_close = .TRUE.
    if ( present(dont_close) ) my_dont_close = dont_close
    call h5dOpen_f ( fileID, name, dataID, status )
    if ( status /= 0 ) then
      dataID = -1
    else
      if ( .not. my_dont_close ) call h5dClose_f ( dataID, status )
    end if
  end function name_to_dataID

! ----------------------------------------------  StartMakeAttrib  -----
  logical function StartMakeAttrib ( ItemID, Name, Type, SpaceID, AttrID, &
    & Skip_if_already_there, Shp )
    ! Start up an attribute.  Return false if present(skip_if_already_there)
    ! and skip_if_already_there and the attribute is already there.
    integer, intent(in) :: ItemID         ! Group etc. to make attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    integer(hid_t), intent(in) :: Type    ! Data type of attrib
    integer, intent(out) :: SpaceID       ! Dataspace ID
    integer, intent(out) :: AttrId        ! Attrib ID
    logical, intent(in), optional :: Skip_if_already_there ! Duh...
    integer(kind=hsize_t), intent(in), optional :: Shp(:) ! Shape of array attrib, else scalar

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    logical :: my_skip
    integer :: STATUS                   ! Flag from HDF5
    ! Executable
    call trace_begin ( me, 'StartMakeAttrib', cond=.false. )
    startMakeAttrib = .false.
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip = skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_dsID(itemID, name) ) go to 9
    end if
    startMakeAttrib = .true.
    if ( present(shp) ) then
      call h5sCreate_simple_f ( size(shp,1), int(shp,hSize_T), spaceID, status )
    else
      call h5sCreate_F ( h5s_scalar_f, spaceID, status )
    end if
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for attribute ' // trim(name) )
    ! Now create the attribute
    call h5aCreate_f ( itemID, trim(name), type, spaceID, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create attribute ' // trim(name) )
  9 call trace_end ( cond=.false. )
  end function StartMakeAttrib

! --------------------------------------------  WhatTypeAmI  -----
  function WhatTypeAmI ( me ) result ( Qtype )
    ! This routine returns the type of a type_id
    ! as an easily-recognized string
    ! E.g., 'character', 'real', 'double', or 'integer'
    integer, intent(in) :: me
    character(len=16)   :: Qtype
    ! Initialize in case something goes wrong with hdf5 routines
    Qtype = 'unknown'
    if ( AreThe2TypesEqual(me, H5T_NATIVE_INTEGER) .or. &
      &  AreThe2TypesEqual(me, H5T_STD_I32LE) ) then
      Qtype = 'integer'
    else if ( AreThe2TypesEqual(me, H5T_NATIVE_CHARACTER) ) then
      Qtype = 'character'
    else if ( AreThe2TypesEqual(me, H5T_STRING) ) then
      Qtype = 'character'
    else if ( AreThe2TypesEqual(me, H5T_NATIVE_REAL) .or. &
      &      AreThe2TypesEqual(me, H5T_IEEE_F32LE) ) then
      Qtype = 'real'
    else if ( AreThe2TypesEqual(me, H5T_NATIVE_DOUBLE) .or. &
      &      AreThe2TypesEqual(me, H5T_IEEE_F64LE) ) then
      Qtype = 'double'
    end if
  end function WhatTypeAmI

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSHDF5.f90,v 2.150 2021/04/01 23:50:02 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MLSHDF5

! $Log: MLSHDF5.f90,v $
! Revision 2.150  2021/04/01 23:50:02  pwagner
! Strong words now warn of mis-named 'start' array
!
! Revision 2.149  2021/02/05 05:13:15  pwagner
! Prints more if rank too large
!
! Revision 2.148  2019/06/26 22:56:10  pwagner
! Needed H5SGet_Simple_Extent_NPoints_F to fix sometime link error
!
! Revision 2.147  2019/06/06 23:50:31  pwagner
! Can now read string-valued attributes with variable lengths
!
! Revision 2.146  2018/11/12 23:12:27  pwagner
! Added arg to convert carriagereturns to linefeeds
!
! Revision 2.145  2018/05/15 03:16:59  vsnyder
! Add LoadAllocFromHDF5DS
!
! Revision 2.144  2018/05/11 21:29:52  pwagner
! May be adding_to during SaveAsHDF5DS_textFile; if hdfVerbose print all warnings and quibbles
!
! Revision 2.143  2018/04/13 00:15:41  pwagner
! Added MLSFile_T api for GetHDF5DSRank; improved comments
!
! Revision 2.142  2017/08/10 22:42:23  pwagner
! Make apis for d.p. SaveAsHDF5DS like s.p.
!
! Revision 2.141  2017/08/04 19:42:14  pwagner
! Fixed case when groupName starts with /
!
! Revision 2.140  2017/07/25 22:30:34  pwagner
! Added MakeNestedGroups
!
! Revision 2.139  2017/02/09 23:45:48  pwagner
! Made more uses CamelCase
!
! Revision 2.138  2016/08/09 18:12:16  pwagner
! Made IsHDF5DSPresent generic
!
! Revision 2.137  2016/07/28 19:24:37  pwagner
! Fixed error in GetAllHDF5GroupNames
!
! Revision 2.136  2016/07/28 01:42:27  vsnyder
! Refactoring dump and diff
!
! Revision 2.135  2016/07/27 22:14:06  pwagner
! Added GetAllHDF5GroupNames
!
! Revision 2.134  2016/04/05 23:53:51  pwagner
! If -v option present, DumpHDF5DS will print DSName on each line
!
! Revision 2.133  2016/01/20 00:23:09  pwagner
! Added wildcard matches to DumpHDF5DS
!
! Revision 2.132  2015/07/14 23:17:17  pwagner
! May specify how to replace nulls in text file saved as DS
!
! Revision 2.131  2014/12/09 01:25:30  pwagner
! Comment-out a debugging print
!
! Revision 2.130  2014/10/27 23:04:06  pwagner
! needed to extend existing hdf attributes
!
! Revision 2.129  2014/09/05 00:05:14  vsnyder
! Convert some local pointer temps to allocatable
!
! Revision 2.128  2014/07/18 21:59:17  pwagner
! Pass item name to allocate_test
!
! Revision 2.127  2014/04/29 17:10:12  pwagner
! UFixed bugs regarding my_dont_trim in MakeHDF5Attribute_string
!
! Revision 2.126  2014/03/07 19:13:47  pwagner
! Increased MAXNDSNAMES; should there even be a limit?
!
! Revision 2.125  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.124  2013/11/01 00:05:13  pwagner
! Match trace_begin, _end in MakeHDF5Attribute_textFile
!
! Revision 2.123  2013/09/14 00:37:20  pwagner
! Corrected erroneous double call to trace_begin
!
! Revision 2.122  2013/08/31 01:24:53  vsnyder
! Replace MLSMessageCalls with trace_begin and trace_end
!
! Revision 2.121  2013/08/20 00:30:38  pwagner
! May also skip if attribute not where we cp from
!
! Revision 2.120  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.119  2012/05/17 20:19:07  pwagner
! Fixed bug preventing cleanly dumping MAFStartTimeUTC
!
! Revision 2.118  2012/05/08 01:15:42  vsnyder
! Option allows numeric DS silently to be absent
!
! Revision 2.117  2012/01/25 01:12:07  pwagner
! Fixed most of the bugs in MatchHDF5Attributes
!
! Revision 2.116  2012/01/13 01:10:14  pwagner
! Added MatchHDF5Attributes; untested yet
!
! Revision 2.115  2011/11/04 23:41:16  pwagner
! Removed unused items
!
! Revision 2.114  2011/11/03 23:48:10  pwagner
! Added MLSFile api for GetHDF5DSDims
!
! Revision 2.113  2011/11/01 21:01:34  pwagner
! GetAllHDF5DSNames now accepts MLSFile as arg
!
! Revision 2.112  2011/10/25 17:56:09  pwagner
! May make scalar real and d.p.-valued attributes
!
! Revision 2.111  2011/08/04 17:38:18  pwagner
! Corrected choice of kind for stringsize
!
! Revision 2.110  2011/08/04 16:57:35  honghanh
! Revert the previous bug fix
! because the issue is with toolkit
!
! Revision 2.109  2011/08/04 16:45:06  honghanh
! Fix a bug in the new read attribute function
!
! Revision 2.108  2011/08/02 16:53:00  honghanh
! Add ReadHDF5Attr_FID_string and ReadHDF5Attr_FID_int functions
!
! Revision 2.107  2011/07/15 23:33:11  pwagner
! Can now dump rank 4 datasets
!
! Revision 2.106  2011/05/06 00:35:33  pwagner
! Fixed bug in IsHDF5AttributePresent
!
! Revision 2.105  2011/05/05 15:14:45  pwagner
! Added MLSFile api to IsHDF5AttributePresent
!
! Revision 2.104  2011/03/16 18:19:47  pwagner
! Workaround for bug in Intel v12.0.0-2011.1.107
!
! Revision 2.103  2011/02/05 01:35:34  pwagner
! Consistent with new dopt_ dump options
!
! Revision 2.102  2011/01/12 18:08:33  pwagner
! Wont truncate dumped long string attributes
!
! Revision 2.101  2010/11/23 01:11:07  pwagner
! Improved dumps of character arrays with many elements
!
! Revision 2.100  2010/08/27 20:59:06  pwagner
! Reduced character length array name chLongArray for long arrays so we dont exhaust memory
!
! Revision 2.99  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.98  2010/01/11 18:33:57  pwagner
! Fixed bug in dumping array-valued attributes
!
! Revision 2.97  2009/11/16 21:55:55  pwagner
! orked around lack of generic outputnamedValue for longint
!
! Revision 2.96  2009/11/10 00:31:43  pwagner
! Raised character string size in CpHDF5Attribute_string consistent with PCFHdr%MiscNotesLENGTH
!
! Revision 2.95  2009/10/05 23:38:59  pwagner
! Moved use h5lib statements from module scope to speedup Lahey; this is the last time we do that
!
! Revision 2.94  2009/09/29 23:31:24  pwagner
! Changes needed by 64-bit build
!
! Revision 2.93  2009/08/04 20:44:08  pwagner
! Now able to dump character scalar ds
!
! Revision 2.92  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.91  2009/06/16 17:14:24  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.90  2009/05/08 00:42:04  pwagner
! New optional arg laconic to prevent DumpHDF5DS from printing names
!
! Revision 2.89  2009/04/01 23:27:27  pwagner
! Worked around bug in saving logical array
!
! Revision 2.88  2008/06/18 20:56:55  pwagner
! New optional arg 'unique' dumps print unique elements, counts only
!
! Revision 2.87  2008/05/24 00:54:46  vsnyder
! Remove unused declarations
!
! Revision 2.86  2008/05/24 00:34:05  pwagner
! Removed scraps from older reading of text files
!
! Revision 2.85  2008/05/22 01:06:42  vsnyder
! Use new allocate_test to simplify LoadPtrFromDS_*
!
! Revision 2.84  2008/05/20 01:59:28  vsnyder
! Add 4d integer, real, double
!
! Revision 2.83  2008/05/10 01:14:04  vsnyder
! Use includes to generate multiple-rank routines
!
! Revision 2.82  2008/05/02 00:05:19  pwagner
! Reads textFile using io stuff
!
! Revision 2.81  2008/04/25 22:51:23  pwagner
! Passes optional arg maxLineLen through to textFile_to_Chars
!
! Revision 2.80  2008/04/22 17:17:38  pwagner
! Should not print extra debugging stuff
!
! Revision 2.79  2008/04/18 16:29:06  pwagner
! Now works properly with NAG, Lahey, and Intel
!
! Revision 2.78  2008/03/07 01:35:47  pwagner
! Will subdivide attributes into blocks if too large
!
! Revision 2.77  2008/02/22 21:29:13  pwagner
! Can now save entire textfile as attribute or dataset
!
! Revision 2.76  2008/01/04 01:00:13  pwagner
! More successful at dumping l1b files
!
! Revision 2.75  2007/10/04 20:43:36  vsnyder
! Remove unused symbols
!
! Revision 2.74  2007/10/03 23:51:53  vsnyder
! Don't overflow MLSCallStack
!
! Revision 2.73  2007/08/17 00:27:48  pwagner
! push more procedures onto MLSCallStack
!
! Revision 2.72  2007/01/31 00:07:23  pwagner
! Compatible with renamed dumpNamedValues
!
! Revision 2.71  2007/01/26 23:59:13  pwagner
! Added more unused debugging
!
! Revision 2.70  2007/01/12 00:29:28  pwagner
! Renamed routine outputNamedValue
!
! Revision 2.69  2006/08/23 18:04:23  pwagner
! NAG hates splitting /) operator
!
! Revision 2.68  2006/08/22 20:41:23  pwagner
! Fixed a bug in DumpHDF5Attributes
!
! Revision 2.67  2006/07/11 00:24:36  pwagner
! use fillValue properly when computing rms etc.
!
! Revision 2.66  2006/06/29 20:38:20  pwagner
! Added a few extra error checks
!
! Revision 2.65  2006/06/27 23:59:05  pwagner
! May dump attributes, datasets
!
! Revision 2.64  2006/04/12 20:51:24  pwagner
! Attempts to work around hdf5-1.6.5 bugs rewriting string attributes
!
! Revision 2.63  2006/01/25 00:57:39  pwagner
! Removed some troublesome, superfluous calls from IsHDF5ItemPresent
!
! Revision 2.62  2005/11/17 20:09:24  pwagner
! LoadFromHDF5DS can now read 3d integer arrays
!
! Revision 2.61  2005/11/11 21:36:00  pwagner
! Added new interface for IsHDF5AttributeInFile when attached to grp, not dataset
!
! Revision 2.60  2005/10/28 23:13:42  pwagner
! Prevent ref to undefined num in GetAllHDF5AttrNames
!
! Revision 2.59  2005/10/19 20:46:05  pwagner
! GetAllHDF5DSNames will omit leading slashes by default
!
! Revision 2.58  2005/10/18 23:01:43  pwagner
! Added GetAllHDF5AttrNames, IsHDF5ItemPresent; introduced options
!
! Revision 2.57  2005/10/11 17:35:00  pwagner
! MLSFile interface to GetHDF5Attribute can get attribute from grp_id component if sd_id is 0
!
! Revision 2.56  2005/07/12 17:12:50  pwagner
! New hdf5 library will drop integer dimension interfaces
!
! Revision 2.55  2005/06/29 00:40:48  pwagner
! New interfaces for GetHDF5Attribute and LoadFromHDF5DS accept MLSFiles
!
! Revision 2.54  2005/06/22 17:25:49  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.53  2005/04/29 21:55:17  pwagner
! Nullified name component of data_set info before allocating
!
! Revision 2.52  2005/01/12 03:04:15  vsnyder
! Use correct data type in MakeHDF5Attribute_sngl, some cannonball polishing
!
! Revision 2.51  2005/01/07 01:57:53  vsnyder
! Don't try to get DS dims from an Attrib
!
! Revision 2.50  2005/01/07 01:14:26  vsnyder
! Allocate the correct upper bound in LoadPtrFromHDF5DS_logarr1
!
! Revision 2.49  2005/01/07 01:04:37  vsnyder
! Use generics for some internal references
!
! Revision 2.48  2005/01/07 00:38:17  vsnyder
! Add IsHDF5GroupPresent, simplify some stuff, delete unused stuff
!
! Revision 2.47  2004/12/31 02:38:53  vsnyder
! Added LoadPtrFromHDF5DS, simplified a lot of stuff
!
! Revision 2.46  2004/12/13 20:26:53  vsnyder
! Added MakeHDF5Attribute_sngl.  Change specifics for generics to use Real
! and Double Precision instead of r4 (which isn't guaranteed to be default
! real) and r8 (which isn't guaranteed to be different from default real).
! Changed a few references to specifics to refer to generics.
!
! Revision 2.45  2004/09/23 23:00:10  pwagner
! Added CpHDF5GlAttribute, CpHDF5Attribute
!
! Revision 2.44  2004/08/04 23:19:01  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.43  2004/08/03 18:00:28  pwagner
! Optionally sets fill value for some datasets
!
! Revision 2.42  2004/07/22 20:37:11  cvuu
! Change in MakeHDF5Attribute_string to allow re-write the char string in the file attribute
!
! Revision 2.41  2004/06/29 00:07:00  pwagner
! Exploit catlist function
!
! Revision 2.40  2004/06/08 18:59:59  pwagner
! Another break with old toolkit; this time may be correct
!
! Revision 2.39  2004/05/25 20:35:53  pwagner
! Reverted to older hdf5; temporarily we hope
!
! Revision 2.38  2004/05/19 19:08:05  pwagner
! After hdf5-1.6.2, h5open_f, h5close_f become module procedures
!
! Revision 2.37  2004/03/25 18:38:13  pwagner
! May save 3d integer and double dsets
!
! Revision 2.36  2004/03/24 23:50:27  pwagner
! Added mls_h5open/close
!
! Revision 2.35  2004/02/26 21:59:09  pwagner
! Added GetAllHDF5DSNames
!
! Revision 2.34  2003/10/02 23:09:47  pwagner
! Some small fixes; can get string array attribute
!
! Revision 2.33  2003/09/30 18:29:41  perun
! Change len_trim to len in MakeHDF5Attribute_string_arr1.
!
! Revision 2.32  2003/09/12 16:40:27  cvuu
! Add subroutines to get L1BOA attributes
!
! Revision 2.31  2003/08/07 15:44:19  perun
! Add MakeHDF5Attribute_intarr1
!
! Revision 2.30  2003/07/24 22:10:45  pwagner
! Fixed another bug preventing multiple chunks from writing to same dataset
!
! Revision 2.29  2003/07/21 23:30:23  pwagner
! Check on returnstatus from h5sget_simple_extent_dims_f being rank (marking success)
!
! Revision 2.28  2003/07/18 16:04:19  pwagner
! Fixed some bugs in DirectWriting 3-d datasets
!
! Revision 2.27  2003/07/15 23:37:57  pwagner
! No changes I can see, but cvs says so, so ..
!
! Revision 2.26  2003/05/19 22:06:31  pwagner
! Shortened names to Read..IndexFromHDF5Attr to comply with namelength standard
!
! Revision 2.25  2003/05/13 04:46:42  livesey
! Bug fix, added more specifics to generic
!
! Revision 2.24  2003/05/12 18:08:10  pwagner
! Added 1d, 2d char array dsets, 2d int dset, gets of sngl, dbl scalar attrs
!
! Revision 2.23  2003/05/12 16:51:20  livesey
! Added the lit and string index stuff
!
! Revision 2.22  2003/04/28 23:08:20  pwagner
! Added ability to Load, Save rank4 s.p. arrays
!
! Revision 2.21  2003/03/20 19:21:11  pwagner
! Fixed simple bug in saving 3d arrays
!
! Revision 2.20  2003/02/21 23:41:02  pwagner
! Additional MakeHDF5Attribute interface
!
! Revision 2.19  2003/02/12 21:38:14  pwagner
! May make dbl scalar and array attributes; find if name is an attribute of a group
!
! Revision 2.18  2003/01/30 00:56:01  pwagner
! Added string arrays as possible attributes (untested)
!
! Revision 2.17  2003/01/27 21:38:44  pwagner
! May make 1d s.p. array attributes; may make attributes with sdname attrname call
!
! Revision 2.16  2003/01/23 23:30:49  pwagner
! May add to same 2d, 3d single-precision datasets
!
! Revision 2.15  2002/12/07 00:24:40  pwagner
! Added SaveAsHDF5DS_snglarr3
!
! Revision 2.14  2002/12/02 23:35:57  pwagner
! Should provide more info when something goes awry
!
! Revision 2.13  2002/10/29 01:01:05  pwagner
! Can save a char scalar as a DS
!
! Revision 2.12  2002/10/11 23:42:04  pwagner
! Remembered to close hyperslab memspaceID if created one
!
! Revision 2.11  2002/10/10 23:51:57  pwagner
! Optional hyperslab args to LoadFromHDF5DS
!
! Revision 2.10  2002/10/08 00:09:11  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.9  2002/10/04 22:22:52  pwagner
! Fixed bug in GetHDF5DSQType; can retrieve rank3 datasets
!
! Revision 2.8  2002/10/02 23:20:07  livesey
! Bug fix in single precision stuff
!
! Revision 2.7  2002/09/27 23:39:26  pwagner
! Added GetHDF5DSQType
!
! Revision 2.6  2002/09/26 23:56:15  pwagner
! Added some things for MLSAux and l1bdata
!
! Revision 2.5  2002/09/13 18:08:12  pwagner
! May change matrix precision rm from r8
!
! Revision 2.4  2002/08/26 16:42:09  livesey
! Bug fix with error messages in IsHDF5DSPresent
!
! Revision 2.3  2002/08/23 01:23:21  livesey
! Added IsHDF5DSPresent and IsHDF5AttributePresent
!
! Revision 2.2  2002/07/17 06:00:21  livesey
! Got hdf5 l2pc reading stuff working
!
! Revision 2.1  2002/07/11 22:18:26  pwagner
! First commit in this directory--welcome old friendshe5*.f90
!
! Revision 1.1  2002/06/18 21:57:09  livesey
! First version
!
@


2.150
log
@Strong words now warn of mis-named 'start' array
@
text
@d2882 1
a2882 1
      minlen = min(len(error), len(myerror))
d2951 1
a2951 1
      minlen = min(len(error), len(myerror))
d6456 1
a6456 1
       "$Id: MLSHDF5.f90,v 2.149 2021/02/05 05:13:15 pwagner Exp $"
d6466 3
@


2.149
log
@Prints more if rank too large
@
text
@d205 3
a207 3
! How do we know where the wildcard "*" can appear in a field 
!    and where it is forrbidden?
! For which procedures can the arg be an MLSFile_T? Shouldn't you make it
d209 3
d6164 1
d6456 1
a6456 1
       "$Id: MLSHDF5.f90,v 2.148 2019/06/26 22:56:10 pwagner Exp $"
d6466 3
@


2.148
log
@Needed H5SGet_Simple_Extent_NPoints_F to fix sometime link error
@
text
@d37 1
d6194 8
d6452 1
a6452 1
       "$Id: MLSHDF5.f90,v 2.147 2019/06/06 23:50:31 pwagner Exp $"
d6462 3
@


2.147
log
@Can now read string-valued attributes with variable lengths
@
text
@d1912 1
a1912 1
    use HDF5, only: H5TIs_Variable_Str_F
d6443 1
a6443 1
       "$Id: MLSHDF5.f90,v 2.146 2018/11/12 23:12:27 pwagner Exp $"
d6453 3
@


2.146
log
@Added arg to convert carriagereturns to linefeeds
@
text
@d460 1
a460 1
    ! logical, parameter :: DEEBUG = .false.
d1912 2
d1922 3
d1930 1
d1952 8
d1972 6
a1977 5
    value = ''
    call h5aread_f ( attrID, stringType, value(1:stringSize), ones, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read attribute ' // trim(name), &
      & MLSFile=MLSFile )
d1987 47
d2038 2
d2046 1
d2054 1
d2083 8
a2090 5
    call h5aread_f ( attrID, stringType, value, &
      & int ( (/ shp, ones(1:6) /), hsize_t ), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read attribute ' // trim(name), &
      & MLSFile=MLSFile )
d2100 45
d6443 1
a6443 1
       "$Id: MLSHDF5.f90,v 2.145 2018/05/15 03:16:59 vsnyder Exp $"
d6453 3
@


2.145
log
@Add LoadAllocFromHDF5DS
@
text
@d3662 1
a3662 1
    & maxLineLen, fromNull, adding_to )
d3670 2
a3671 1
    logical, optional, intent(in)     :: adding_to
d3676 1
d3695 2
d3702 2
d6329 1
a6329 1
       "$Id: MLSHDF5.f90,v 2.144 2018/05/11 21:29:52 pwagner Exp $"
d6339 3
@


2.144
log
@May be adding_to during SaveAsHDF5DS_textFile; if hdfVerbose print all warnings and quibbles
@
text
@d77 1
a77 1
    & LoadFromHDF5DS, LoadPtrFromHDF5DS, &
d143 2
d272 11
d4831 345
d6323 1
a6323 1
       "$Id: MLSHDF5.f90,v 2.143 2018/04/13 00:15:41 pwagner Exp $"
d6333 3
@


2.143
log
@Added MLSFile_T api for GetHDF5DSRank; improved comments
@
text
@d25 1
d28 2
a29 1
  use MLSFiles, only: HDFVersion_5, Dump, InitializeMLSFile, MLS_Openfile
d55 1
a55 1
    & H5eset_Auto_F, &
d343 2
d880 1
a880 1
    call h5eSet_auto_f ( 0, status )
d927 1
a927 1
    call h5eSet_auto_f ( 1, status )
d954 1
a954 1
    call h5eSet_auto_f ( 0, status )
a963 2
    ! call outputNamedValue( 'fileid', fileid )
    ! call output('About to check on ' // trim(gname), advance='yes' )
d980 1
a980 1
    call h5eSet_auto_f ( 1, status )
d1001 1
a1001 1
    call h5eSet_auto_f ( 0, status )
d1006 1
a1006 1
      call h5eSet_auto_f ( 1, status )
d1012 1
a1012 1
    call h5eSet_auto_f ( 0, status )
d1016 1
a1016 1
    call h5eSet_auto_f ( 1, status )
a1033 4
    ! Do we have any FileID fields?
    ! If ( .not. MLSFile%stillOpen .or. all( &
    !  & (/ MLSFile%FileId%f_id, MLSFile%FileId%grp_id, MLSFile%FileId%sd_id /) &
    !   & == 0 ) ) then
d2649 1
a2649 1
    call h5eSet_auto_f ( 0, status )
d2669 1
a2669 1
    call h5eSet_auto_f ( 1, status )
d2942 1
a2942 1
    call h5eSet_auto_f ( 0, status )
d2974 1
a2974 1
    call h5eSet_auto_f ( 1, status )
d3000 1
a3000 1
    call h5eSet_auto_f ( 0, status )
d3015 1
a3015 1
    call h5eSet_auto_f ( 1, status )
d3032 1
a3032 1
    call trace_begin ( me, 'GetHDF5DSDims_ID', cond=.false. )
d3042 3
a3044 1
      call GetHDF5DSDims( MLSFile%fileID%grp_id, name, DIMS, maxDims )
d3065 1
a3065 1
    call trace_begin ( me, 'GetHDF5DSRank_ID', cond=.false. )
d3075 3
a3077 1
      call GetHDF5DSRank_ID( MLSFile%fileID%grp_id, name, rank )
d3101 1
a3101 1
    call h5eSet_auto_f ( 0, status )
d3108 1
a3108 1
    call h5eSet_auto_f ( 1, status )
d3129 1
a3129 1
    call h5eSet_auto_f ( 0, status )
d3142 1
a3142 1
    call h5eSet_auto_f ( 1, status )
d3169 1
a3169 1
    call h5eSet_auto_f ( 0, status )
d3185 1
a3185 1
    call h5eSet_auto_f ( 1, status )
d3211 1
a3211 1
    call h5eSet_auto_f ( 0, status )
d3227 1
a3227 1
    call h5eSet_auto_f ( 1, status )
d3248 1
a3248 1
    call h5eSet_auto_f ( 0, status )
d3260 1
a3260 1
    call h5eSet_auto_f ( 1, status )
d3279 1
a3279 1
    call h5eSet_auto_f ( 0, status )
d3289 1
a3289 1
    call h5eSet_auto_f ( 1, status )
d3322 1
a3322 1
    call h5eSet_auto_f ( 0, status )
d3338 1
a3338 1
    call h5eSet_auto_f ( 1, status )
d3360 1
a3360 1
    call h5eSet_auto_f ( 0, status )
d3376 1
a3376 1
    call h5eSet_auto_f ( 1, status )
d3396 1
a3396 1
    call h5eSet_auto_f ( 0, status )
d3407 1
a3407 1
    call h5eSet_auto_f ( 1, status )
d3475 1
a3475 1
    call h5eSet_auto_f ( 0, status )
d3494 1
a3494 1
    call h5eSet_auto_f ( 1, status )
d3513 1
a3513 1
    call h5eSet_auto_f ( 0, status )
d3519 1
a3519 1
    call h5eSet_auto_f ( 1, status )
d3546 1
a3546 1
    call h5eSet_auto_f ( 0, status )
d3564 1
a3564 1
    call h5eSet_auto_f ( 1, status )
d3571 1
a3571 1
  subroutine SaveAsHDF5DS_charsclr ( locID, name, value )
d3576 1
d3580 2
d3592 2
d3602 8
a3609 4
    call h5dCreate_f ( locID, trim(name), s_type_id, spaceID, setID, &
      & status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for scalar character ' // trim(name) )
d3613 1
a3613 1
    call finishSaveDS ( name, status, setID, spaceID )
d3649 1
a3649 1
    & maxLineLen, fromNull )
d3657 1
d3661 1
d3678 2
d3694 10
a3703 5
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), s_type_id, spaceID, setID, &
      & status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for scalar character ' // trim(name) )
d5569 15
d5965 1
a5965 1
       "$Id: MLSHDF5.f90,v 2.142 2017/08/10 22:42:23 pwagner Exp $"
d5975 3
@


2.142
log
@Make apis for d.p. SaveAsHDF5DS like s.p.
@
text
@a16 9
  ! Usage note: due to idiosyncrasy (euphemism for bug) in Lahey f95 compiler,
  ! don't put a "USE MLSHDF5" statement at module level in any modules that
  ! will use this. Instead bury each "USE MLSHDF5" down inside the
  ! procedures that need them. Otherwise, Lahey will take nearly forever
  ! to finish compiling the highest modules.
  
  ! This note, like the Lahey compiler, is deprecated in our current
  ! software. We will resume alphabetizing the used module names.

d65 1
a65 1
  implicit NONE
d145 7
a151 6
! MakeHDF5Attribute (int itemID, char name, value,
!       [log skip_if_already_there])
! MakeNestedGroups (int itemID, char groupnames(:))
! MatchHDF5Attributes (MLSFile_T MLSFile, char attrnames, char attrvalues,
!       char name)
! SaveAsHDF5DS (int locID, char name, value)
d159 3
a161 3
! The following may also be called with the int itemID or locID arg replaced
! by a MLSFile_T
! GetHDF5Attribute (MLSFile_T MLSFile, char name, value)
d165 1
a165 1
! LoadFromHDF5DS (MLSFile_T MLSFile, char name, value,
d198 6
d254 4
d3055 31
a3085 1
  subroutine GetHDF5DSRank ( FileID, name, rank )
d3110 1
a3110 1
  end subroutine GetHDF5DSRank
d5930 1
a5930 1
       "$Id: MLSHDF5.f90,v 2.141 2017/08/04 19:42:14 pwagner Exp $"
d5940 3
@


2.141
log
@Fixed case when groupName starts with /
@
text
@d3754 1
a3754 1
    & finalShape, fillValue, adding_to )
a3759 2
    integer, dimension(1), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d3761 12
d3779 1
a3779 1
    & finalShape, fillValue, adding_to )
a3784 2
    integer, dimension(2), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d3786 12
d3804 1
a3804 1
    & finalShape, fillValue, adding_to )
a3809 2
    integer, dimension(3), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d3811 12
d3829 1
a3829 1
    & finalShape, fillValue, adding_to )
a3834 2
    integer, dimension(4), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d3836 12
d5898 1
a5898 1
       "$Id: MLSHDF5.f90,v 2.140 2017/07/25 22:30:34 pwagner Exp $"
d5908 3
@


2.140
log
@Added MakeNestedGroups
@
text
@d117 1
a117 1
! MakeNestedGroups       Create a nested sequence of groups; e.g. a/b/c/../z
d1793 4
a1796 1
      if ( .not. IsHDF5GroupPresent ( containerID, trim(groupnames(i))) ) then
d1810 1
a1810 1
        call h5gclose_f ( IDs(i), status )
d5858 1
a5858 1
       "$Id: MLSHDF5.f90,v 2.139 2017/02/09 23:45:48 pwagner Exp $"
d5868 3
@


2.139
log
@Made more uses CamelCase
@
text
@d64 1
a64 1
    & H5gopen_F, H5gclose_F, &
d85 1
a85 1
    & MakeHDF5Attribute, MatchHDF5Attributes, &
d117 1
d156 1
d1768 45
d5855 1
a5855 1
       "$Id: MLSHDF5.f90,v 2.138 2016/08/09 18:12:16 pwagner Exp $"
d5865 3
@


2.138
log
@Made IsHDF5DSPresent generic
@
text
@d32 6
a37 6
  use HighOutput, only: outputNamedValue
  use Intrinsic, only: l_hdf
  use MLSCommon, only: MLSFile_t
  use MLSDataInfo, only: MLSDataInfo_t, query_mlsdata
  use MLSFiles, only: HDFVersion_5, Dump, initializeMLSFile, MLS_Openfile
  use MLSKinds, only: r8
d40 33
a72 33
  use MLSFinds, only: findFirst
  use MLSStringLists, only: catLists, isInList, &
    & GetStringElement, Intersection, numStringElements, stringElement
  use MLSStrings, only: indexes, lowercase, replace, trim_safe
  use Output_m, only: newline, output
  use Trace_m, only: trace_begin, trace_end
  ! Let's break down our use, parameters first
  use HDF5, only: h5f_acc_rdonly_f, h5f_acc_rdwr_f, &
    & H5G_Group_f, H5p_dataset_create_f, &
    & H5sis_simple_f, & ! h5soffset_simple_f, &
    & H5s_scalar_f, h5s_select_set_f, h5s_unlimited_f, &
    & H5t_ieee_f32le, h5t_ieee_f64le, h5t_ieee_f64le, &
    & H5t_native_double, h5t_native_real, h5t_std_i32le, &
    & H5t_native_character, h5t_native_integer, h5t_string, h5t_string_f, &
    & Hid_t, hsize_t, size_t
  ! Now routines
  use HDF5, only: h5aclose_f, h5acreate_f, &
    & H5aget_name_f, h5aget_num_attrs_f, &
    & H5aget_space_f, h5aget_type_f, h5aopen_idx_f, h5aopen_name_f, &
    & H5aread_f, h5awrite_f, h5adelete_f, &
    & H5dcreate_f, h5dextend_f, h5dget_space_f, h5dget_type_f, h5dopen_f, &
    & H5dread_f, h5dwrite_f, h5dclose_f, h5dget_create_plist_f, &
    & H5eset_auto_f, &
    & H5fopen_f, h5fclose_f, &
    & H5gopen_f, h5gclose_f, &
    & h5gn_members_f, h5gget_obj_info_idx_f, &
    & H5pcreate_f, h5pset_chunk_f, h5pset_fill_value_f, &
    & H5pget_chunk_f, h5pget_fill_value_f, &
    & H5sclose_f, &
    & H5screate_f, h5screate_simple_f, h5sget_simple_extent_ndims_f, &
    & H5sget_simple_extent_dims_f, h5sselect_hyperslab_f, &
    & H5tclose_f, h5tcopy_f, h5tequal_f, h5tget_class_f, h5tget_size_f, &
    & H5tset_size_f
d348 1
a348 1
    use H5LIB, only: H5CLOSE_F
d358 1
a358 1
    use H5LIB, only: H5OPEN_F
d1262 1
a1262 1
    use IO_STUFF, only: read_textFile
d3557 1
a3557 1
    use IO_STUFF, only: read_textFile
d4366 1
a4366 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_INTEGER ! HDF type
d4390 1
a4390 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_INTEGER ! HDF type
d4414 1
a4414 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_INTEGER ! HDF type
d4438 1
a4438 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_INTEGER ! HDF type
d4488 1
a4488 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_DOUBLE ! HDF type
d4512 1
a4512 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_DOUBLE ! HDF type
d4536 1
a4536 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_DOUBLE ! HDF type
d4560 1
a4560 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_DOUBLE ! HDF type
d4584 1
a4584 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_REAL ! HDF type
d4608 1
a4608 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_REAL ! HDF type
d4632 1
a4632 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_REAL ! HDF type
d4656 1
a4656 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_REAL ! HDF type
d4801 1
a4801 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_INTEGER ! HDF type
d4815 1
a4815 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_INTEGER ! HDF type
d4829 1
a4829 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_INTEGER ! HDF type
d4906 1
a4906 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_DOUBLE ! HDF type
d4920 1
a4920 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_DOUBLE ! HDF type
d4934 1
a4934 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_DOUBLE ! HDF type
d4984 1
a4984 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_REAL ! HDF type
d4998 1
a4998 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_REAL ! HDF type
d5012 1
a5012 1
    use H5GLOBAL, only: H5T =>  H5T_NATIVE_REAL ! HDF type
d5072 1
a5072 1
    use Intrinsic, only: LIT_INDICES
d5092 1
a5092 1
    use String_table, only: GET_STRING
d5808 1
a5808 1
       "$Id: MLSHDF5.f90,v 2.137 2016/07/28 19:24:37 pwagner Exp $"
d5818 3
@


2.137
log
@Fixed error in GetAllHDF5GroupNames
@
text
@d36 1
a36 1
  use MLSFiles, only: HDFVersion_5, initializeMLSFile, MLS_Openfile
d38 2
a39 1
  use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, MLSMessage
d42 1
a42 1
    & Getstringelement, Intersection, numStringElements, stringElement
d254 4
d1029 4
a1032 3
    If ( .not. MLSFile%stillOpen .or. all( &
      & (/ MLSFile%FileId%f_id, MLSFile%FileId%grp_id, MLSFile%FileId%sd_id /) &
      & == 0 ) ) then
a2592 1
    logical :: omitSlash
d3329 42
a3370 2
  ! --------------------------------------------  IsHDF5DSPresent  -----
  logical function IsHDF5DSPresent ( locID, name, options )
d3384 1
d3387 2
a3388 1
    call trace_begin ( me, 'IsHDF5DSPresent', cond=.false. )
d3396 7
a3402 2
      IsHDF5DSPresent = ( status == 0 )
      if ( IsHDF5DSPresent ) call h5dClose_f ( setID, status )
d3405 1
a3405 1
      IsHDF5DSPresent = IsInList( DSNames, name, options )
d3408 1
a3408 1
      IsHDF5DSPresent = IsInList( DSNames, name, options )
d3414 1
a3414 1
  end function IsHDF5DSPresent
d5808 1
a5808 1
       "$Id: MLSHDF5.f90,v 2.136 2016/07/28 01:42:27 vsnyder Exp $"
d5818 3
@


2.136
log
@Refactoring dump and diff
@
text
@d2601 1
a2601 1
    do i = 1, nsubmembers
d2604 2
a2607 1
      if ( DeeBug ) call outputNamedValue ( 'objName', trim(objName) )
d5756 1
a5756 1
       "$Id: MLSHDF5.f90,v 2.135 2016/07/27 22:14:06 pwagner Exp $"
d5766 3
@


2.135
log
@Added GetAllHDF5GroupNames
@
text
@d26 5
a30 3
  use Allocate_deallocate, only: allocate_test, deallocate_test
  use Dump_0, only: dopt_laconic, dopt_rms, dopt_stats, dopt_verbose, &
    & Dump, dumpNamedValues, nameOnEachLine
d42 1
a42 1
  use Mlsstrings, only: indexes, lowercase, replace, trim_safe
d45 3
a47 3
  ! leTs break down our use, parameters first
  use Hdf5, only: h5f_acc_rdonly_f, h5f_acc_rdwr_f, &
    & H5G_Group_F, H5p_dataset_create_f, &
d54 2
a55 2
  ! noW routines
  use Hdf5, only: h5aclose_f, h5acreate_f, &
d73 1
a73 1
  implicit none
d559 1
a559 1
  ! -------------------------------  DumpHDF5DS  -----
a592 1
    character(len=MAXNDSNAMES*MAXNAMELEN) :: matches
d5755 1
a5755 1
       "$Id: MLSHDF5.f90,v 2.134 2016/04/05 23:53:51 pwagner Exp $"
d5765 3
@


2.134
log
@If -v option present, DumpHDF5DS will print DSName on each line
@
text
@d45 1
a45 1
    & H5p_dataset_create_f, &
d62 1
d76 1
a76 1
    & GetAllHDF5AttrNames, GetAllHDF5DSNames, &
d103 1
d2575 43
d3364 1
a3364 1
    ! This routine returns true if the given HDF5 DS is present
d5754 1
a5754 1
       "$Id: MLSHDF5.f90,v 2.133 2016/01/20 00:23:09 pwagner Exp $"
d5764 3
@


2.133
log
@Added wildcard matches to DumpHDF5DS
@
text
@d27 3
a29 3
  use Dump_0, only: dopt_laconic, dopt_rms, dopt_stats, &
    & Dump, dumpnamedvalues
  use Hdf, only: dfacc_rdonly
d32 3
a34 3
  use MLSCommon, only: mlsfile_t
  use MLSDataInfo, only: mlsdatainfo_t, query_mlsdata
  use MLSFiles, only: hdfversion_5, initializemlsfile, mls_openfile
d567 1
d626 2
d640 1
d5709 1
a5709 1
       "$Id: MLSHDF5.f90,v 2.132 2015/07/14 23:17:17 pwagner Exp $"
d5719 3
@


2.132
log
@May specify how to replace nulls in text file saved as DS
@
text
@d26 43
a68 43
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only: DOPT_LACONIC, DOPT_RMS, DOPT_STATS, &
    & DUMP, DUMPNAMEDVALUES
  use HDF, only: DFACC_RDONLY
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use INTRINSIC, only: L_HDF
  use MLSCOMMON, only: MLSFILE_T
  use MLSDATAINFO, only: MLSDATAINFO_T, QUERY_MLSDATA
  use MLSFILES, only: HDFVERSION_5, INITIALIZEMLSFILE, MLS_OPENFILE
  use MLSKINDS, only: R8
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING, MLSMESSAGE
  use MLSFINDS, only: FINDFIRST
  use MLSSTRINGLISTS, only: CATLISTS, ISINLIST, &
    & GETSTRINGELEMENT, NUMSTRINGELEMENTS, STRINGELEMENT
  use MLSStrings, only: indexes, lowerCase, replace, trim_safe
  use OUTPUT_M, only: NEWLINE, OUTPUT
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  ! LETS BREAK DOWN OUR use, PARAMETERS FIRST
  use HDF5, only: H5F_ACC_RDonly_F, H5F_ACC_RDWR_F, &
    & H5P_DATASET_CREATE_F, &
    & H5SIS_SIMPLE_F, & ! H5SOFFSET_SIMPLE_F, &
    & H5S_SCALAR_F, H5S_SELECT_SET_F, H5S_UNLIMITED_F, &
    & H5T_IEEE_F32LE, H5T_IEEE_F64LE, H5T_IEEE_F64LE, &
    & H5T_NATIVE_DOUBLE, H5T_NATIVE_REAL, H5T_STD_I32LE, &
    & H5T_NATIVE_CHARACTER, H5T_NATIVE_INTEGER, H5T_STRING, H5T_STRING_F, &
    & HID_T, HSIZE_T, SIZE_T
  ! NOW ROUTINES
  use HDF5, only: H5ACLOSE_F, H5ACREATE_F, &
    & H5AGET_NAME_F, H5AGET_NUM_ATTRS_F, &
    & H5AGET_SPACE_F, H5AGET_TYPE_F, H5AOPEN_IDX_F, H5AOPEN_NAME_F, &
    & H5AREAD_F, H5AWRITE_F, H5ADELETE_F, &
    & H5DCREATE_F, H5DEXTEND_F, H5DGET_SPACE_F, H5DGET_TYPE_F, H5DOPEN_F, &
    & H5DREAD_F, H5DWRITE_F, H5DCLOSE_F, H5DGET_CREATE_PLIST_F, &
    & H5ESET_AUTO_F, &
    & H5FOPEN_F, H5FCLOSE_F, &
    & H5GOPEN_F, H5GCLOSE_F, &
    & H5PCREATE_F, H5PSET_CHUNK_F, H5PSET_FILL_VALUE_F, &
    & H5PGET_CHUNK_F, H5PGET_FILL_VALUE_F, &
    & H5SCLOSE_F, &
    & H5SCREATE_F, H5SCREATE_SIMPLE_F, H5SGET_SIMPLE_EXTENT_NDIMS_F, &
    & H5SGET_SIMPLE_EXTENT_DIMS_F, H5SSELECT_HYPERSLAB_F, &
    & H5TCLOSE_F, H5TCOPY_F, H5TEQUAL_F, H5TGET_CLASS_F, H5TGET_SIZE_F, &
    & H5TSET_SIZE_F
d70 1
a70 1
  implicit NONE
d564 1
a564 1
    character(len=*), intent(in), optional :: options
d588 1
d596 1
d613 10
a622 1
    if ( myNames == '*' ) call GetAllHDF5DSNames ( locID, groupName, myNames )
d5705 1
a5705 1
       "$Id: MLSHDF5.f90,v 2.131 2014/12/09 01:25:30 pwagner Exp $"
d5715 3
@


2.131
log
@Comment-out a debugging print
@
text
@d3441 2
a3442 1
  subroutine SaveAsHDF5DS_textFile ( textFile, locID, name, maxLineLen )
d3449 1
d3461 1
d3467 2
d3473 1
a3473 1
    value = Replace( value, char(0), char(32) ) ! Replace null with space
d5694 1
a5694 1
       "$Id: MLSHDF5.f90,v 2.130 2014/10/27 23:04:06 pwagner Exp $"
d5704 3
@


2.130
log
@needed to extend existing hdf attributes
@
text
@d1187 1
a1187 1
      print *, 'Deleting ' // trim(name)
d5689 1
a5689 1
       "$Id: MLSHDF5.f90,v 2.129 2014/09/05 00:05:14 vsnyder Exp $"
d5699 3
@


2.129
log
@Convert some local pointer temps to allocatable
@
text
@d1160 1
a1160 1
    logical, parameter :: NEVERDELETE = .true.
d5689 1
a5689 1
       "$Id: MLSHDF5.f90,v 2.128 2014/07/18 21:59:17 pwagner Exp $"
d5699 3
@


2.128
log
@Pass item name to allocate_test
@
text
@d437 1
a437 1
    integer(kind=hSize_t), dimension(:), pointer :: maxdims_ptr
d512 1
a512 1
      endif
d521 1
a521 1
      endif
d2813 1
a2813 1
    integer(kind=hSize_t), dimension(:), pointer :: maxdims_ptr
d5689 1
a5689 1
       "$Id: MLSHDF5.f90,v 2.127 2014/04/29 17:10:12 pwagner Exp $"
d5699 3
@


2.127
log
@UFixed bugs regarding my_dont_trim in MakeHDF5Attribute_string
@
text
@d662 1
a662 1
          call allocate_test( iValue, dims(1), dims(2), dims(3), 'iValue', ModuleName )
d670 1
a670 1
          call deallocate_test( iValue, 'iValue', ModuleName )
d672 1
a672 1
          call allocate_test( iValue, dims(1), dims(2), 1, 'iValue', ModuleName )
d680 1
a680 1
          call deallocate_test( iValue, 'iValue', ModuleName )
d682 1
a682 1
          call allocate_test( iValue, dims(1), 1, 1, 'iValue', ModuleName )
d690 1
a690 1
          call deallocate_test( iValue, 'iValue', ModuleName )
d699 1
a699 1
            & 'd4Value', ModuleName )
d711 1
a711 1
          call deallocate_test( d4Value, 'd4Value', ModuleName )
d713 1
a713 1
          call allocate_test( dValue, dims(1), dims(2), dims(3), 'dValue', ModuleName )
d725 1
a725 1
          call deallocate_test( dValue, 'dValue', ModuleName )
d727 1
a727 1
          call allocate_test( dValue, dims(1), dims(2), 1, 'dValue', ModuleName )
d735 1
a735 1
          call deallocate_test( dValue, 'dValue', ModuleName )
d737 1
a737 1
          call allocate_test( dValue, dims(1), 1, 1, 'dValue', ModuleName )
d745 1
a745 1
          call deallocate_test( dValue, 'dValue', ModuleName )
d2393 1
a2393 1
    call allocate_test ( value, int(lb-1+maxShp(1)), 'Value', moduleName )
d2433 1
a2433 1
    call allocate_test ( value, int(lb-1+maxShp(1)), 'Value', moduleName )
d2478 1
a2478 1
    call deallocate_test ( ivalue, 'IValue', moduleName )
d2503 1
a2503 1
    call allocate_test ( value, int(lb-1+maxShp(1)), 'Value', moduleName )
d2541 1
a2541 1
    call allocate_test ( value, int(lb-1+maxShp(1)), 'Value', moduleName )
d4596 1
a4596 1
    call allocate_test ( value, ub, 'Value', moduleName, lowBound=lb )
d4636 1
a4636 1
    call allocate_test ( value, int(shp(1)), int(shp(2)), 'Value', moduleName )
d4671 1
a4671 1
    call allocate_test ( value, ub, 'Value', moduleName, lowBound=lb )
d4741 1
a4741 1
    call allocate_test ( value, ub, 'Value', moduleName, lowBound=lb )
d4743 1
a4743 1
    call deallocate_test ( myValue, 'myValue', moduleName )
d4776 1
a4776 1
    call allocate_test ( value, ub, 'Value', moduleName, lowBound=lb )
d4854 1
a4854 1
    call allocate_test ( value, ub, 'Value', moduleName, lowBound=lb )
d5689 1
a5689 1
       "$Id: MLSHDF5.f90,v 2.126 2014/03/07 19:13:47 pwagner Exp $"
d5699 3
@


2.126
log
@Increased MAXNDSNAMES; should there even be a limit?
@
text
@d40 1
a40 1
  use MLSSTRINGS, only: INDEXES, LOWERCASE, REPLACE
d1178 1
a1178 1
      call h5tset_size_f(stringtype, int(max(len(value), 1), size_t), status )
d1213 5
a1217 1
    call h5aWrite_f ( attrID, stringtype, value, ones, status )
d5689 1
a5689 1
       "$Id: MLSHDF5.f90,v 2.125 2014/01/09 00:24:29 pwagner Exp $"
d5699 3
@


2.125
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d315 1
a324 1
  integer, parameter :: MAXNDSNAMES = 1000   ! max number of DS names in a file
d327 1
d439 1
a439 1
    character(len=MAXNDSNAMES*32) :: myNames
d588 1
a588 1
    character(len=MAXNDSNAMES*32) :: myNames
d2568 1
a2568 1
    character(len=32*MAXNDSNAMES) :: DSNames
d3266 1
a3266 1
    character (len=MAXNDSNAMES*32) :: DSNames ! Names of DS in file (,-separated)
d3334 1
a3334 1
    character (len=MAXNDSNAMES*32) :: DSNames ! Names of DS in file (,-separated)
a5525 1
    logical, parameter          :: clean=.false.
d5685 1
a5685 1
       "$Id: MLSHDF5.f90,v 2.124 2013/11/01 00:05:13 pwagner Exp $"
d5695 3
@


2.124
log
@Match trace_begin, _end in MakeHDF5Attribute_textFile
@
text
@d29 2
a30 1
  use HDF, only: DFACC_RDonly
d41 1
a41 1
  use OUTPUT_M, only: NEWLINE, OUTPUT, OUTPUTNAMEDVALUE
d5685 1
a5685 1
       "$Id: MLSHDF5.f90,v 2.123 2013/09/14 00:37:20 pwagner Exp $"
d5695 3
@


2.123
log
@Corrected erroneous double call to trace_begin
@
text
@d1266 1
a1266 1
      return
d1283 1
a1283 1
      return
d5684 1
a5684 1
       "$Id: MLSHDF5.f90,v 2.122 2013/08/31 01:24:53 vsnyder Exp $"
d5694 3
@


2.122
log
@Replace MLSMessageCalls with trace_begin and trace_end
@
text
@d411 1
a411 1
    call trace_begin ( 'CpHDFGlAttribute_string', cond=.false. )
d5684 1
a5684 1
       "$Id: MLSHDF5.f90,v 2.121 2013/08/20 00:30:38 pwagner Exp $"
d5694 3
@


2.121
log
@May also skip if attribute not where we cp from
@
text
@d35 1
a35 2
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING, &
    & MLSMESSAGE, MLSMESSAGECALLS
d41 1
d362 1
d368 1
a368 1
    call MLSMessageCalls( 'push', constantName='CpHDF5Attribute_string' )
d380 1
a380 1
  9 call MLSMessageCalls( 'pop' )
d394 1
d400 1
a400 1
    call MLSMessageCalls( 'push', constantName='CpHDFGlAttribute_string' )
d411 1
a411 1
    call MLSMessageCalls( 'pop' )
d436 1
d447 1
a447 1
    call MLSMessageCalls( 'push', constantName='DumpHDF5Attributes' )
d550 1
a550 1
    call MLSMessageCalls( 'pop' )
d585 1
d600 1
d602 1
a603 1
    call MLSMessageCalls( 'push', constantName='DumpHDF5DS' )
d820 1
a820 1
    call MLSMessageCalls( 'pop' )
d837 1
d845 1
a845 1
    call MLSMessageCalls( 'push', constantName='GetAllHDF5AttrNames' )
d897 1
a897 1
  9 call MLSMessageCalls( 'pop' )
d910 1
d916 1
a916 1
    call MLSMessageCalls( 'push', constantName='GetAllHDF5DSNames_fileID' )
d953 1
a953 1
    call MLSMessageCalls( 'pop' )
d965 1
d969 1
a969 1
    call MLSMessageCalls( 'push', constantName='GetAllHDF5DSNames_filename' )
d988 1
a988 1
    call MLSMessageCalls( 'pop' )
d999 1
d1002 1
a1002 1
    call MLSMessageCalls( 'push', constantName='GetAllHDF5DSNames_MLSFile' )
d1016 1
a1016 1
    call MLSMessageCalls( 'pop' )
d1030 1
d1034 1
a1034 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_dbl' )
d1042 1
a1042 1
    call MLSMessageCalls( 'pop' )
d1056 1
d1060 1
a1060 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_sngl' )
d1068 1
a1068 1
    call MLSMessageCalls( 'pop' )
d1082 1
d1086 1
a1086 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_int' )
d1094 1
a1094 1
    call MLSMessageCalls( 'pop' )
d1107 1
d1110 1
a1110 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_logical' )
d1114 1
a1114 1
    call MLSMessageCalls( 'pop' )
d1127 1
d1130 1
a1130 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_logicalarr1' )
d1137 1
a1137 1
    call MLSMessageCalls( 'pop' )
d1154 1
d1161 1
a1161 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_string' )
d1226 1
a1226 1
  9 call MLSMessageCalls( 'pop' )
d1247 1
d1256 1
a1256 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_textFile' )
d1341 1
a1341 1
  9 call MLSMessageCalls( 'pop' )
d1355 1
d1362 1
a1362 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_stringarr1' )
d1389 1
a1389 1
  9 call MLSMessageCalls( 'pop' )
d1402 1
d1408 1
a1408 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_snglarr1' )
d1418 1
a1418 1
    call MLSMessageCalls( 'pop' )
d1431 1
d1437 1
a1437 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_dblarr1' )
d1447 1
a1447 1
    call MLSMessageCalls( 'pop' )
d1460 1
d1466 1
a1466 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5Attribute_intarr1' )
d1476 1
a1476 1
    call MLSMessageCalls( 'pop' )
d1490 1
d1495 1
a1495 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5AttributeDSN_int' )
d1507 1
a1507 1
  9 call MLSMessageCalls( 'pop' )
d1524 1
d1529 1
a1529 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5AttributeDSN_logical' )
d1541 1
a1541 1
  9 call MLSMessageCalls( 'pop' )
d1555 2
a1557 1
    logical :: my_skip
d1560 1
a1560 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5AttributeDSN_string' )
d1578 1
a1578 1
  9 call MLSMessageCalls( 'pop' )
d1592 2
a1594 1
    logical :: my_skip
d1597 1
a1597 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5AttributeDSN_st_arr1' )
d1609 1
a1609 1
  9 call MLSMessageCalls( 'pop' )
d1623 2
a1625 1
    logical :: my_skip
d1628 1
a1628 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5AttributeDSN_single' )
d1639 1
a1639 1
 9  call MLSMessageCalls( 'pop' )
d1654 2
a1656 1
    logical :: my_skip
d1659 1
a1659 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5AttributeDSN_snglarr1' )
d1670 1
a1670 1
 9  call MLSMessageCalls( 'pop' )
d1674 1
a1674 1
  ! -------------------------------  MakeHDF5AttributeDSN_double  -----
d1685 2
a1687 1
    logical :: my_skip
d1690 1
a1690 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5AttributeDSN_double' )
d1701 1
a1701 1
  9 call MLSMessageCalls( 'pop' )
d1716 2
a1718 1
    logical :: my_skip
d1721 1
a1721 1
    call MLSMessageCalls( 'push', constantName='MakeHDF5AttributeDSN_dblarr1' )
d1732 1
a1732 1
  9 call MLSMessageCalls( 'pop' )
d1744 1
d1748 1
a1748 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attribute_int' )
d1772 1
a1772 1
  9 call MLSMessageCalls( 'pop' )
d1783 2
a1785 1
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
d1788 1
a1788 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attribute_intarr1' )
d1814 1
a1814 1
  9 call MLSMessageCalls( 'pop' )
d1826 1
d1828 1
a1829 1
    integer(kind=Size_t) :: STRINGSIZE               ! String size
d1832 1
a1832 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attribute_string' )
d1878 1
a1878 1
  9 call MLSMessageCalls( 'pop' )
d1889 2
d1892 1
a1893 2
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
d1896 1
a1896 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attribute_stringarr1' )
d1937 1
a1937 1
  9 call MLSMessageCalls( 'pop' )
d1948 1
d1951 1
a1951 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attribute_logical' )
d1966 1
a1966 1
  9 call MLSMessageCalls( 'pop' )
d1977 1
d1980 1
a1980 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attribute_logicalarr1' )
d1991 1
a1991 1
  9 call MLSMessageCalls( 'pop' )
d2002 2
a2004 1
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
d2007 1
a2007 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attribute_snglarr1' )
d2033 1
a2033 1
  9 call MLSMessageCalls( 'pop' )
d2044 1
d2048 1
a2048 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attribute_sngl' )
d2072 1
a2072 1
  9 call MLSMessageCalls( 'pop' )
d2083 1
d2087 1
a2087 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attribute_dbl' )
d2111 1
a2111 1
  9 call MLSMessageCalls( 'pop' )
d2122 2
a2124 1
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
d2127 1
a2127 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attribute_dblarr1' )
d2153 1
a2153 1
  9 call MLSMessageCalls( 'pop' )
d2163 2
a2165 1
    type (MLSFile_T)   :: MLSFile
d2168 1
a2168 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attr_ID_int' )
d2174 1
a2174 1
    call MLSMessageCalls( 'pop' )
d2184 2
a2186 1
    type (MLSFile_T)   :: MLSFile
d2189 1
a2189 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attr_ID_intarr1' )
d2195 1
a2195 1
    call MLSMessageCalls( 'pop' )
d2205 2
a2207 1
    type (MLSFile_T)   :: MLSFile
d2210 1
a2210 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attr_ID_string' )
d2216 1
a2216 1
    call MLSMessageCalls( 'pop' )
d2226 2
a2228 1
    type (MLSFile_T)   :: MLSFile
d2231 1
a2231 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attr_ID_stringarr1' )
d2237 1
a2237 1
    call MLSMessageCalls( 'pop' )
d2247 2
a2249 1
    type (MLSFile_T)   :: MLSFile
d2252 1
a2252 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attr_ID_logical' )
d2258 1
a2258 1
    call MLSMessageCalls( 'pop' )
d2268 2
a2270 1
    type (MLSFile_T)   :: MLSFile
d2273 1
a2273 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attr_ID_logicalarr1' )
d2279 1
a2279 1
    call MLSMessageCalls( 'pop' )
d2289 2
a2291 1
    type (MLSFile_T)   :: MLSFile
d2294 1
a2294 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attr_ID_snglarr1' )
d2300 1
a2300 1
    call MLSMessageCalls( 'pop' )
d2310 2
a2312 1
    type (MLSFile_T)   :: MLSFile
d2315 1
a2315 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attr_ID_sngl' )
d2321 1
a2321 1
    call MLSMessageCalls( 'pop' )
d2331 2
a2333 1
    type (MLSFile_T)   :: MLSFile
d2336 1
a2336 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attr_ID_dbl' )
d2342 1
a2342 1
    call MLSMessageCalls( 'pop' )
d2345 1
a2345 1
  ! -----------------------------------  GetHDF5Attr_ID_dblarr1  -----
d2352 2
a2354 1
    type (MLSFile_T)   :: MLSFile
d2357 1
a2357 1
    call MLSMessageCalls( 'push', constantName='GetHDF5Attr_ID_dblarr1' )
d2363 1
a2363 1
    call MLSMessageCalls( 'pop' )
d2378 2
a2380 1
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP  ! Shape
d2383 1
a2383 1
    call MLSMessageCalls( 'push', constantName='GetHDF5AttributePtr_intarr1' )
d2401 1
a2401 1
    call MLSMessageCalls( 'pop' )
d2416 2
d2419 1
a2420 2
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP ! Shape
d2423 1
a2423 1
    call MLSMessageCalls( 'push', constantName='GetHDF5AttributePtr_stringarr1' )
d2452 1
a2452 1
    call MLSMessageCalls( 'pop' )
d2465 1
d2468 1
a2468 1
    call MLSMessageCalls( 'push', constantName='GetHDF5AttributePtr_logicalarr1' )
d2473 1
a2473 1
    call MLSMessageCalls( 'pop' )
d2488 2
a2490 1
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP  ! Shape
d2493 1
a2493 1
    call MLSMessageCalls( 'push', constantName='GetHDF5AttributePtr_snglarr1' )
d2511 1
a2511 1
    call MLSMessageCalls( 'pop' )
d2526 2
a2528 1
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP  ! Shape
d2531 1
a2531 1
    call MLSMessageCalls( 'push', constantName='GetHDF5AttributePtr_dblarr1' )
d2549 1
a2549 1
    call MLSMessageCalls( 'pop' )
d2804 2
d2808 1
a2809 2
    integer :: AttrID                   ! ID for Attr
    integer :: classID
d2815 1
a2815 1
    call MLSMessageCalls( 'push', constantName='GetHDF5AttrDims' )
d2854 1
a2854 1
    call MLSMessageCalls( 'pop' )
d2867 1
d2873 1
a2873 1
    call MLSMessageCalls( 'push', constantName='GetHDF5DSDims' )
d2895 1
a2895 1
    call MLSMessageCalls( 'pop' )
d2903 1
d2905 1
d2909 1
a2909 1
    call MLSMessageCalls( 'push', constantName='GetHDF5DSDims_ID' )
d2926 1
a2926 1
    call MLSMessageCalls( 'pop' )
d2937 1
d2942 1
a2942 1
    call MLSMessageCalls( 'push', constantName='GetHDF5DSRank' )
d2954 1
a2954 1
    call MLSMessageCalls( 'pop' )
d2964 1
a2964 1
    integer :: type_id                  ! typeID for DS
d2967 1
d2970 1
a2970 1
    call MLSMessageCalls( 'push', constantName='GetHDF5DSQType' )
d2988 1
a2988 1
    call MLSMessageCalls( 'pop' )
d3001 1
d3003 1
d3005 1
a3005 1
    integer :: ATTRID                   ! ID for attribute if present
d3010 1
a3010 1
    call MLSMessageCalls( 'push', constantName='IsHDF5AttributeInFile_DS' )
d3031 1
a3031 1
    call MLSMessageCalls( 'pop' )
d3045 1
a3046 1
    integer :: ATTRID                   ! ID for attribute if present
d3048 1
d3052 1
a3052 1
    call MLSMessageCalls( 'push', constantName='IsHDF5AttributeInFile_Grp' )
d3073 1
a3073 1
    call MLSMessageCalls( 'pop' )
d3081 1
d3084 1
d3089 1
a3089 1
    call MLSMessageCalls( 'push', constantName='IsHDF5DSInFile' )
d3106 1
a3106 1
    call MLSMessageCalls( 'pop' )
d3114 1
d3116 1
d3121 1
a3121 1
    call MLSMessageCalls( 'push', constantName='IsHDF5AttributePresent_in_DSID' )
d3135 1
a3135 1
    call MLSMessageCalls( 'pop' )
d3148 5
a3153 1
    integer :: ATTRID                   ! ID for attribute if present
a3154 1
    logical :: my_grpattr
d3157 1
a3157 1
    call MLSMessageCalls( 'push', constantName='IsHDF5AttributePresent_in_fID' )
d3184 1
a3184 1
  9 call MLSMessageCalls( 'pop' )
d3194 3
d3198 1
a3198 1
    integer :: ATTRID                   ! ID for attribute if present
d3202 1
a3202 1
    call MLSMessageCalls( 'push', constantName='IsHDF5AttributePresent_in_grp' )
d3222 1
a3222 1
    call MLSMessageCalls( 'pop' )
d3231 2
d3234 1
d3238 1
a3238 1
    call MLSMessageCalls( 'push', constantName='IsHDF5AttributePresent_in_MLSFile' )
d3253 1
a3253 1
    call MLSMessageCalls( 'pop' )
d3266 3
d3273 1
a3273 1
    call MLSMessageCalls( 'push', constantName='IsHDF5DSPresent' )
d3293 1
a3293 1
    call MLSMessageCalls( 'pop' )
d3301 1
d3303 1
d3308 1
a3308 1
    call MLSMessageCalls( 'push', constantName='IsHDF5GroupPresent' )
d3318 1
a3318 1
    call MLSMessageCalls( 'pop' )
d3330 1
d3333 1
d3339 1
a3339 1
    call MLSMessageCalls( 'push', constantName='IsHDF5ItemPresent' )
d3363 1
a3363 1
    call MLSMessageCalls( 'pop' )
d3374 3
a3377 1
    integer (HID_T) :: setID            ! ID for dataset
a3378 1
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape
d3383 1
a3383 1
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_charsclr' )
d3401 1
a3401 1
    call MLSMessageCalls( 'pop' )
d3444 1
d3455 1
a3455 1
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_textFile' )
d3481 1
a3481 1
    call MLSMessageCalls( 'pop' )
d3556 1
d3560 1
a3560 1
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_logarr1' )
d3574 1
a3574 1
    call MLSMessageCalls( 'pop' )
d3649 3
a3652 1
    integer (HID_T) :: setID            ! ID for dataset
a3653 1
    integer(kind=hsize_t), dimension(1) :: SHP, MAXDIMS        ! Shape
d3656 1
a3656 1
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_snglarr1' )
d3669 1
a3669 1
    call MLSMessageCalls( 'pop' )
d3758 2
a3760 1
    type (MLSFile_T)   :: MLSFile
d3763 1
a3763 1
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_'//sfx )
d3769 1
a3769 1
    call MLSMessageCalls( 'pop' )
d3943 1
d3947 1
a3947 1
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_logarr1' )
d3950 1
a3950 1
    call MLSMessageCalls( 'pop' )
d4137 3
d4141 1
a4141 2
    integer :: SPACEID                  ! ID of dataspace
    integer :: SETID                    ! ID of dataset
d4143 1
a4143 1
    integer(kind=Size_t) :: STRINGSIZE               ! String size
d4145 1
a4145 1
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_charscalar' )
d4173 1
a4173 1
    call MLSMessageCalls( 'pop' )
d4349 1
d4353 1
a4353 1
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_logarr1' )
d4356 1
a4356 1
    call MLSMessageCalls( 'pop' )
d4561 4
a4565 1
    integer(hsize_t) :: SHP(1)          ! Shape of value
d4567 1
a4567 1
    integer :: SETID                    ! ID of dataset
a4568 2
    integer(kind=Size_t) :: STRINGSIZE               ! String size
    integer :: LB, UB
d4571 1
a4571 1
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_chararr1' )
d4593 1
a4593 1
    call MLSMessageCalls( 'pop' )
d4605 2
a4606 1
    integer :: STATUS                   ! Flag from HDF5
d4609 2
a4610 1
    integer :: SETID                    ! ID of dataset
a4611 1
    integer(kind=Size_t) :: STRINGSIZE               ! String size
d4614 1
a4614 1
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_chararr2' )
d4633 1
a4633 1
    call MLSMessageCalls( 'pop' )
d4646 3
a4648 1
    integer :: STATUS                   ! Flag from HDF5
d4651 1
a4651 2
    integer :: SETID                    ! ID of dataset
    integer :: LB, UB
d4654 1
a4654 1
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_intarr1' )
d4669 1
a4669 1
    call MLSMessageCalls( 'pop' )
d4724 2
a4726 1
    integer :: LB, UB
d4729 1
a4729 1
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_logarr1' )
d4738 1
a4738 1
    call MLSMessageCalls( 'pop' )
d4751 3
a4753 1
    integer :: STATUS                   ! Flag from HDF5
d4756 1
a4756 2
    integer :: SETID                    ! ID of dataset
    integer :: LB, UB
d4759 1
a4759 1
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_dblarr1' )
d4774 1
a4774 1
    call MLSMessageCalls( 'pop' )
d4829 3
a4831 1
    integer :: STATUS                   ! Flag from HDF5
d4834 1
a4834 2
    integer :: SETID                    ! ID of dataset
    integer :: LB, UB
d4837 1
a4837 1
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_snglarr1' )
d4852 1
a4852 1
    call MLSMessageCalls( 'pop' )
d4904 1
d4908 2
d4911 1
a4911 1
    call MLSMessageCalls( 'push', constantName='ReadLitIndexFromHDF5Attr' )
d4919 1
a4919 1
    call MLSMessageCalls( 'pop' )
d4929 1
d4932 2
d4935 1
a4935 1
    call MLSMessageCalls( 'push', constantName='ReadStringIndexFromHDF5Attr' )
d4942 1
a4942 1
    call MLSMessageCalls( 'pop' )
d4951 4
d4956 1
a4956 1
    call MLSMessageCalls( 'push', constantName='WriteLitIndexAsHDF5Attribute' )
d4962 1
a4962 1
    call MLSMessageCalls( 'pop' )
d4971 1
d4974 2
d4977 1
a4977 1
    call MLSMessageCalls( 'push', constantName='WriteStringIndexAsHDF5Attribute' )
d4984 1
a4984 1
    call MLSMessageCalls( 'pop' )
d5034 1
d5036 1
d5045 1
d5047 1
a5047 1
    call MLSMessageCalls( 'push', constantName='CreateSpaceSet' )
d5133 1
a5133 1
    call MLSMessageCalls( 'pop' )
d5170 4
d5175 1
a5175 1
    call MLSMessageCalls( 'push', constantName='FinishLoad' )
d5199 1
a5199 1
    call MLSMessageCalls( 'pop' )
d5210 4
d5215 1
a5215 1
    call MLSMessageCalls( 'push', constantName='FinishMakeHDF5Attrib' )
d5230 1
a5230 1
    call MLSMessageCalls( 'pop' )
d5243 4
d5248 1
a5248 1
    call MLSMessageCalls( 'push', constantName='FinishSaveDS' )
d5268 1
a5268 1
    call MLSMessageCalls( 'pop' )
d5282 4
d5287 1
a5287 1
    call MLSMessageCalls( 'push', constantName='Get_DS_Shape' )
d5299 1
a5299 1
    call MLSMessageCalls( 'pop' )
a5312 2
    integer                           :: spaceID
    integer                           :: rank
a5313 1
    integer                           :: status
d5315 1
d5317 5
a5321 1
    logical                           :: is_simple
d5323 1
a5323 1
    call MLSMessageCalls( 'push', constantName='MLS_extend' )
d5371 1
a5371 1
  9 call MLSMessageCalls( 'pop' )
d5397 3
d5402 1
a5402 1
    call MLSMessageCalls( 'push', constantName='MLS_hyperslab' )
d5445 1
a5445 1
    call MLSMessageCalls( 'pop' )
d5468 3
d5473 1
a5473 1
    call MLSMessageCalls( 'push', constantName='MLS_hyperslab_save' )
d5507 1
a5507 1
    call MLSMessageCalls( 'pop' )
d5628 1
d5630 1
d5634 1
a5634 1
    call MLSMessageCalls( 'push', constantName='StartMakeAttrib' )
d5653 1
a5653 1
  9 call MLSMessageCalls( 'pop' )
d5684 1
a5684 1
       "$Id: MLSHDF5.f90,v 2.120 2013/08/12 23:47:25 pwagner Exp $"
d5694 3
@


2.120
log
@FindSomethings moved to MLSFinds module
@
text
@d359 1
a359 1
    logical, intent(in), optional :: skip_if_already_there
d370 2
a371 1
    is_present = IsHDF5AttributePresent_in_DSID(fromitemID, name)
d5545 1
a5545 1
       "$Id: MLSHDF5.f90,v 2.119 2012/05/17 20:19:07 pwagner Exp $"
d5555 3
@


2.119
log
@Fixed bug preventing cleanly dumping MAFStartTimeUTC
@
text
@d37 1
a37 1
  use MLSSETS, only: FINDFIRST
d5544 1
a5544 1
       "$Id: MLSHDF5.f90,v 2.118 2012/05/08 01:15:42 vsnyder Exp $"
d5554 3
@


2.118
log
@Option allows numeric DS silently to be absent
@
text
@d569 1
d770 1
a770 1
          elseif ( dims(1) > 999 ) then
d775 1
d777 1
d5544 1
a5544 1
       "$Id: MLSHDF5.f90,v 2.117 2012/01/25 01:12:07 pwagner Exp $"
d5554 3
@


2.117
log
@Fixed most of the bugs in MatchHDF5Attributes
@
text
@d4145 1
a4145 1
    & start, count, stride, block )
d4159 1
d4169 1
a4169 1
    & start, count, stride, block )
d4183 1
d4193 1
a4193 1
    & start, count, stride, block )
d4207 1
d4217 1
a4217 1
    & start, count, stride, block )
d4231 1
d4266 1
a4266 1
    & start, count, stride, block )
d4280 1
d4290 1
a4290 1
    & start, count, stride, block )
d4304 1
d4314 1
a4314 1
    & start, count, stride, block )
d4328 1
d4338 1
a4338 1
    & start, count, stride, block )
d4352 1
d4362 1
a4362 1
    & start, count, stride, block )
d4376 1
a4376 1
                                 ! Size of element block
d4386 1
a4386 1
    & start, count, stride, block )
d4400 1
d4410 1
a4410 1
    & start, count, stride, block )
d4424 1
d4434 1
a4434 1
    & start, count, stride, block )
d4448 1
d5541 1
a5541 1
       "$Id: MLSHDF5.f90,v 2.116 2012/01/13 01:10:14 pwagner Exp $"
d5551 3
@


2.116
log
@Added MatchHDF5Attributes; untested yet
@
text
@d149 1
a149 1
! MatchHDF5Attribute (MLSFile_T MLSFile, char attrnames(:), char attrvalues(:),
d193 5
d2503 2
d2506 1
d2508 1
d2510 1
d2512 2
a2513 2
    character(len=64) :: status
    character(len=32) :: value
d2518 11
d2532 2
d2535 1
d2537 10
a2546 3
          & StringElement(DSNames, ds, countEmpty), &
          & StringElement(attrNames, attr, countEmpty), &
          & value, status ) )  cycle allnames
d2639 1
d5530 1
a5530 1
       "$Id: MLSHDF5.f90,v 2.115 2011/11/04 23:41:16 pwagner Exp $"
d5540 3
@


2.115
log
@Removed unused items
@
text
@d22 3
d40 1
a40 1
  use MLSSTRINGS, only: INDEXES, REPLACE
d79 2
a80 1
    & LoadFromHDF5DS, LoadPtrFromHDF5DS, MakeHDF5Attribute, &
d111 1
d149 2
d225 13
a237 13
    interface GetHDF5AttributePtr
        module procedure GetHDF5AttributePtr_snglarr1, GetHDF5AttributePtr_intarr1, &
            & GetHDF5AttributePtr_dblarr1, GetHDF5AttributePtr_stringarr1, &
            & GetHDF5AttributePtr_logicalarr1
    end interface

    interface ReadHDF5Attribute
        module procedure ReadHDF5Attr_FID_int, ReadHDF5Attr_FID_string
    end interface

    interface IsHDF5AttributeInFile
        module procedure IsHDF5AttributeInFile_DS, IsHDF5AttributeInFile_Grp
    end interface
d2490 182
a2671 169
    !---------------------- ReadHDF5Attr_FID_int ---------------------
    function ReadHDF5Attr_FID_int (fileid, dsName, attrName, value, error) result(success)
        integer, intent(in) :: fileid
        character(len=*), intent(in) :: dsName
        character(len=*), intent(in) :: attrName
        integer, intent(out) :: value
        character(len=*), optional, intent(out) :: error
        logical :: success

        integer :: setid, attrid, stat, minlen
        character(len=256) :: myerror ! our error message should not exceed 256 characters

        myerror = ' '
        minlen = min(len(error), len(myerror))
        call h5dopen_f (fileid, dsName, setid, stat)
        if (stat /= 0) then
            success = .false.
            if  (present(error)) then
                myerror = 'Cannot open dataset ' // dsName
                error = myerror(1:minlen)
                return
            endif
        endif

        call h5aopen_name_f(setid, attrName, attrid, stat)
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Cannot open attribute ' // attrName // ' of dataset ' // dsName
                error = myerror(1:minlen)
                return
            endif
        endif

        call h5aread_f (attrid, H5T_NATIVE_INTEGER, value, ones, stat)
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Cannot read attribute ' // attrName // ' of dataset ' // dsName
                error = myerror(1:minlen)
                return
            endif
        endif

        call h5aClose_f ( attrID, stat )
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Cannot close attribute ' // attrName // ' of dataset ' // dsName
                error = myerror(1:minlen)
                return
            endif
        endif

        call h5dclose_f (setid, stat)
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Cannot close dataset ' // dsName
                error = myerror(1:minlen)
                return
            endif
        endif
        success = .true.
    end function

    !--------------------- ReadHDF5Attr_FID_string --------------------
    function ReadHDF5Attr_FID_string (fileid, dsName, attrName, value, error) result(success)
        integer, intent(in) :: fileid
        character(len=*), intent(in) :: dsName
        character(len=*), intent(in) :: attrName
        character(len=*), intent(out) :: value
        character(len=*), optional, intent(out) :: error
        logical :: success

        integer :: setid, attrid, stat, stringtype, minlen
        integer(kind=size_t) :: stringsize
        character(len=256) :: myerror ! error message shouldn't exceed 256 characters

        myerror = ' '
        minlen = min(len(error), len(myerror))
        call h5dopen_f (fileid, dsName, setid, stat)
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Cannot open dataset ' // dsName
                error = myerror (1:minlen)
                return
            endif
        endif

        call h5aopen_name_f(setid, attrName, attrid, stat)
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Cannot open attribute ' // attrName // ' of dataset ' // dsName
                error = myerror(1:minlen)
                return
            endif
        endif

        call h5aGet_type_f ( attrID, stringType, stat )
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Unable to find type info for ' // attrName // ' of dataset ' // dsname
                error = myerror(1:minlen)
                return
            endif
        endif

        call h5tGet_size_f ( stringType, stringSize, stat )
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Unable to find size info for ' // attrName // ' of dataset ' // dsname
                error = myerror(1:minlen)
                return
            endif
        endif

        if (stringsize > len(value)) then
            success = .false.
            if (present(error)) then
                myerror = 'String is not long enough to store attribute ' // attrName // ' of dataset ' // dsname
                error = myerror(1:minlen)
                return
            endif
        endif

        call h5aread_f ( attrID, stringType, value(1:stringSize), ones, stat)
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Cannot read attribute ' // attrName // ' of dataset ' // dsname
                error = myerror(1:minlen)
                return
            endif
        endif

        call h5tClose_f(stringtype, stat)
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Cannot close type for attribute ' // attrName // ' of dataset ' // dsname
                error = myerror(1:minlen)
                return
            endif
        endif

        call h5aClose_f ( attrID, stat )
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Cannot close attribute ' // attrName // ' of dataset ' // dsName
                error = myerror(1:minlen)
                return
            endif
        endif

        call h5dclose_f (setid, stat)
        if (stat /= 0) then
            success = .false.
            if (present(error)) then
                myerror = 'Cannot close dataset ' // dsName
                error = myerror(1:minlen)
                return
            endif
        endif
d2673 32
a2704 2
        success = .true.
    end function
d5498 1
a5498 1
       "$Id: MLSHDF5.f90,v 2.114 2011/11/03 23:48:10 pwagner Exp $"
d5508 3
@


2.114
log
@Added MLSFile api for GetHDF5DSDims
@
text
@a973 1
    integer :: fileID
a974 1
    integer :: STATUS                   ! Flag
d5448 1
a5448 1
       "$Id: MLSHDF5.f90,v 2.113 2011/11/01 21:01:34 pwagner Exp $"
d5458 3
@


2.113
log
@GetAllHDF5DSNames now accepts MLSFile as arg
@
text
@d30 1
a30 1
  use MLSFILES, only: HDFVERSION_5, INITIALIZEMLSFILE
d232 4
d2720 1
a2720 1
  subroutine GetHDF5DSDims ( FileID, name, DIMS, maxDims )
d2757 30
a2786 1
  end subroutine GetHDF5DSDims
d5450 1
a5450 1
       "$Id: MLSHDF5.f90,v 2.112 2011/10/25 17:56:09 pwagner Exp $"
d5460 3
@


2.112
log
@May make scalar real and d.p.-valued attributes
@
text
@d202 1
d963 29
d5417 1
a5417 1
       "$Id: MLSHDF5.f90,v 2.111 2011/08/04 17:38:18 pwagner Exp $"
d5427 3
@


2.111
log
@Corrected choice of kind for stringsize
@
text
@d278 1
d1540 30
d1600 30
d5387 1
a5387 1
       "$Id: MLSHDF5.f90,v 2.110 2011/08/04 16:57:35 honghanh Exp $"
d5397 3
@


2.111.2.1
log
@Can Read GEOS5.7.2 meteorology; based on v3.33
@
text
@d677 1
a677 1
            call dump ( d4Value(:,:,:,1), trim(namePrinted), fillValue=real(fillvalue, r8), &
d682 1
a682 1
            call dump ( d4Value(:,:,:,1), trim(namePrinted), options=options )
d5326 1
a5326 1
       "$Id: MLSHDF5.f90,v 2.111 2011/08/04 17:38:18 pwagner Exp $"
a5335 3
! Revision 2.111  2011/08/04 17:38:18  pwagner
! Corrected choice of kind for stringsize
!
@


2.110
log
@Revert the previous bug fix
because the issue is with toolkit
@
text
@d2466 1
a2466 1
        integer(kind=hsize_t) :: stringsize
d5326 1
a5326 1
       "$Id: MLSHDF5.f90,v 2.109 2011/08/04 16:45:06 honghanh Exp $"
d5336 4
@


2.109
log
@Fix a bug in the new read attribute function
@
text
@d2466 1
a2466 1
        integer :: stringsize
d5326 1
a5326 1
       "$Id: MLSHDF5.f90,v 2.108 2011/08/02 16:53:00 honghanh Exp $"
d5336 3
@


2.108
log
@Add ReadHDF5Attr_FID_string and ReadHDF5Attr_FID_int functions
@
text
@d2466 1
a2466 1
        integer(kind=hsize_t) :: stringsize
a2520 1
        print *, "value ", value(1:stringsize)
d5326 1
a5326 1
       "$Id: MLSHDF5.f90,v 2.107 2011/07/15 23:33:11 pwagner Exp $"
d5336 3
@


2.107
log
@Can now dump rank 4 datasets
@
text
@d77 1
a77 1
    & MLS_H5Open, MLS_H5Close, &
d217 13
a229 10
  interface GetHDF5AttributePtr
    module procedure GetHDF5AttributePtr_snglarr1, GetHDF5AttributePtr_intarr1, &
      & GetHDF5AttributePtr_dblarr1, GetHDF5AttributePtr_stringarr1, &
      & GetHDF5AttributePtr_logicalarr1
  end interface

  interface IsHDF5AttributeInFile
    module procedure IsHDF5AttributeInFile_DS, &
      & IsHDF5AttributeInFile_Grp
  end interface
d2390 174
d5327 1
a5327 1
       "$Id: MLSHDF5.f90,v 2.106 2011/05/06 00:35:33 pwagner Exp $"
d5337 3
@


2.106
log
@Fixed bug in IsHDF5AttributePresent
@
text
@d550 1
d664 18
d2531 1
a2531 1
      & 'Unable to turn error messages off before getting rank ' // trim(name) )
d2533 5
a2537 1
    call h5dget_type_f(setID,type_id,status)
d2540 2
d5150 1
a5150 1
       "$Id: MLSHDF5.f90,v 2.105 2011/05/05 15:14:45 pwagner Exp $"
d5160 3
@


2.105
log
@Added MLSFile api to IsHDF5AttributePresent
@
text
@d23 9
a31 9
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only: dopt_laconic, dopt_rms, dopt_stats, &
    & DUMP, dumpNamedValues
  use hdf, only: DFACC_RDONLY
  use intrinsic, only: l_hdf
  use MLSCommon, only: MLSFile_T
  use MLSDataInfo, only: MLSDataInfo_T, Query_MLSData
  use MLSFiles, only: HDFVERSION_5, INITIALIZEMLSFILE
  use MLSKinds, only: r8
d34 7
a40 7
  use MLSSets, only: FindFirst
  use MLSStringLists, only: catLists, IsInList, &
    & GetStringElement, NumStringElements, StringElement
  use MLSStrings, only: indexes, Replace
  use output_m, only: newLine, output, outputNamedValue
  ! Lets break down our use, parameters first
  use HDF5, only: H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, &
d48 1
a48 1
  ! Now routines
d316 1
a316 1
    use H5LIB, ONLY: h5close_f
d326 1
a326 1
    use H5LIB, ONLY: h5open_f
d2765 1
a2765 1
    IsHDF5AttributePresent_in_MLSFile = ( status == 1 )
d5125 1
a5125 1
       "$Id: MLSHDF5.f90,v 2.104 2011/03/16 18:19:47 pwagner Exp $"
d5135 3
@


2.104
log
@Workaround for bug in Intel v12.0.0-2011.1.107
@
text
@d230 1
d2744 28
d5125 1
a5125 1
       "$Id: MLSHDF5.f90,v 2.103 2011/02/05 01:35:34 pwagner Exp $"
d5135 3
@


2.103
log
@Consistent with new dopt_ dump options
@
text
@d3713 1
a3713 1
    use HDF5, only: H5T => H5T_NATIVE_INTEGER ! HDF type
d3736 1
a3736 1
    use HDF5, only: H5T => H5T_NATIVE_INTEGER ! HDF type
d3759 1
a3759 1
    use HDF5, only: H5T => H5T_NATIVE_INTEGER ! HDF type
d3782 1
a3782 1
    use HDF5, only: H5T => H5T_NATIVE_INTEGER ! HDF type
d3830 1
a3830 1
    use HDF5, only: H5T => H5T_NATIVE_DOUBLE ! HDF type
d3853 1
a3853 1
    use HDF5, only: H5T => H5T_NATIVE_DOUBLE ! HDF type
d3876 1
a3876 1
    use HDF5, only: H5T => H5T_NATIVE_DOUBLE ! HDF type
d3899 1
a3899 1
    use HDF5, only: H5T => H5T_NATIVE_DOUBLE ! HDF type
d3922 1
a3922 1
    use HDF5, only: H5T => H5T_NATIVE_REAL ! HDF type
d3946 1
a3946 1
    use HDF5, only: H5T => H5T_NATIVE_REAL ! HDF type
d3969 1
a3969 1
    use HDF5, only: H5T => H5T_NATIVE_REAL ! HDF type
d3992 1
a3992 1
    use HDF5, only: H5T => H5T_NATIVE_REAL ! HDF type
d4133 1
a4133 1
    use HDF5, only: H5T => H5T_NATIVE_INTEGER ! HDF type
d4147 1
a4147 1
    use HDF5, only: H5T => H5T_NATIVE_INTEGER ! HDF type
d4161 1
a4161 1
    use HDF5, only: H5T => H5T_NATIVE_INTEGER ! HDF type
d4236 1
a4236 1
    use HDF5, only: H5T => H5T_NATIVE_DOUBLE ! HDF type
d4250 1
a4250 1
    use HDF5, only: H5T => H5T_NATIVE_DOUBLE ! HDF type
d4264 1
a4264 1
    use HDF5, only: H5T => H5T_NATIVE_DOUBLE ! HDF type
d4313 1
a4313 1
    use HDF5, only: H5T => H5T_NATIVE_REAL ! HDF type
d4327 1
a4327 1
    use HDF5, only: H5T => H5T_NATIVE_REAL ! HDF type
d4341 1
a4341 1
    use HDF5, only: H5T => H5T_NATIVE_REAL ! HDF type
d5096 1
a5096 1
       "$Id: MLSHDF5.f90,v 2.102 2011/01/12 18:08:33 pwagner Exp $"
d5106 3
@


2.102
log
@Wont truncate dumped long string attributes
@
text
@d24 2
a25 1
  use DUMP_0, only: DUMP, dumpNamedValues
d180 1
a180 1
!       l              Laconic
d185 1
d576 1
a576 1
      & skipCharValues = any( indexes(options, (/'r','s'/)) > 0 )
d581 1
a581 1
    if ( present(options) ) dontPrintName = index(options, 'l') > 0
d5096 1
a5096 1
       "$Id: MLSHDF5.f90,v 2.101 2010/11/23 01:11:07 pwagner Exp $"
d5106 3
@


2.101
log
@Improved dumps of character arrays with many elements
@
text
@d31 2
d37 1
a63 3
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING, &
    & MLSMESSAGE, MLSMESSAGECALLS
  use output_m, only: output, outputNamedValue
d170 3
d294 3
a296 3
  logical, parameter    :: countEmpty = .true.
  logical, parameter    :: DEEBUG = .false.
  integer, save :: cantGetDataspaceDims = 0
d300 2
a301 2
  integer, parameter                      :: MAXATTRIBUTESIZE =   40000
  integer, parameter                      :: MAXTEXTSIZE      = 2000000
a417 1
    ! logical, parameter :: DEEBUG = .true.
d502 3
a504 1
        call dump ( (/ trim(chValue) /), trim(name) )
d1661 1
d1694 3
d1698 1
d5094 1
a5094 1
       "$Id: MLSHDF5.f90,v 2.100 2010/08/27 20:59:06 pwagner Exp $"
d5104 3
@


2.100
log
@Reduced character length array name chLongArray for long arrays so we dont exhaust memory
@
text
@d533 6
a539 4
    character(len=MAXCHFIELDLENGTH), dimension(1) :: chValue
    character(len=MAXCHFIELDLENGTH), dimension(:), pointer :: ch1dArray
    character(len=1), dimension(:,:,:), pointer :: chArray
    character(len=80), dimension(:), pointer :: chLongArray
d549 2
d554 1
d564 1
d724 2
d728 16
d746 1
d5085 1
a5085 1
       "$Id: MLSHDF5.f90,v 2.99 2010/02/04 23:08:00 vsnyder Exp $"
d5095 3
@


2.99
log
@Remove USE or declaration for unused names
@
text
@d537 1
d716 6
d5060 1
a5060 1
       "$Id: MLSHDF5.f90,v 2.98 2010/01/11 18:33:57 pwagner Exp $"
d5070 3
@


2.98
log
@Fixed bug in dumping array-valued attributes
@
text
@d43 1
a43 1
    & HID_T, HSIZE_T, HSSIZE_T, SIZE_T
d310 1
a310 1
  use H5LIB, ONLY: h5open_f, h5close_f
d320 1
a320 1
  use H5LIB, ONLY: h5open_f, h5close_f
a3569 1
    integer :: MEMSPACEID               ! ID of dataspace
d5053 1
a5053 1
       "$Id: MLSHDF5.f90,v 2.97 2009/11/16 21:55:55 pwagner Exp $"
d5063 3
@


2.97
log
@orked around lack of generic outputnamedValue for longint
@
text
@d415 1
d2332 1
a2332 1
    logical, parameter :: DEEBUG = .true.
d2354 2
a2355 1
    call h5dget_space_f ( attrID, dspace_id, status )
d2357 1
d5054 1
a5054 1
       "$Id: MLSHDF5.f90,v 2.96 2009/11/10 00:31:43 pwagner Exp $"
d5064 3
@


2.96
log
@Raised character string size in CpHDF5Attribute_string consistent with PCFHdr%MiscNotesLENGTH
@
text
@d558 1
d652 2
d657 2
d1651 1
a1651 1
      call outputnamedValue( 'stringSize', stringSize )
d5051 1
a5051 1
       "$Id: MLSHDF5.f90,v 2.95 2009/10/05 23:38:59 pwagner Exp $"
d5061 3
@


2.95
log
@Moved use h5lib statements from module scope to speedup Lahey; this is the last time we do that
@
text
@d337 1
a337 1
    character (len=2000) :: value1
d1645 7
a1651 3
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for attribute ' // trim(name), &
      & MLSFile=MLSFile )
d5046 1
a5046 1
       "$Id: MLSHDF5.f90,v 2.94 2009/09/29 23:31:24 pwagner Exp $"
d5056 3
@


2.94
log
@Changes needed by 64-bit build
@
text
@a34 2
  ! To switch to/from hdfeos5.1.6(+) uncomment next line
  use H5LIB, ONLY: h5open_f, h5close_f
d309 2
d319 2
d5042 1
a5042 1
       "$Id: MLSHDF5.f90,v 2.93 2009/08/04 20:44:08 pwagner Exp $"
d5052 3
@


2.93
log
@Now able to dump character scalar ds
@
text
@d45 1
a45 1
    & HID_T, HSIZE_T ! , HSSIZE_T
d412 1
a412 1
    integer :: type_size
d471 1
a471 1
        call outputNamedValue ( 'type_size', type_size )
d554 1
a554 1
    integer :: type_size
d592 1
a592 1
        call outputNamedValue ( 'type_size', type_size )
d742 1
a742 1
    integer :: namelength
d1041 1
a1041 1
      call h5tset_size_f(stringtype, max(len(value), 1), status )
d1043 1
a1043 1
      call h5tset_size_f(stringtype, max(len_trim(value), 1), status )
d1161 1
a1161 1
    call h5tset_size_f(stringtype, max(len_trim(value), 1), status )
d1239 1
a1239 1
    call h5tset_size_f ( stringtype, len(value(1)), status )
d1619 1
a1619 1
    integer :: STRINGSIZE               ! String size
d1673 1
a1673 1
    integer :: STRINGSIZE               ! String size
d2182 1
a2182 1
    integer :: STRINGSIZE               ! String size
d2328 1
a2328 1
    integer :: type_size
d2354 1
a2354 1
      call outputNamedValue ( 'type_size', type_size )
d2813 1
a2813 1
    call h5tset_size_f ( s_type_id, len(value), status )
d2892 1
a2892 1
    call h5tset_size_f ( s_type_id, len_trim(value), status )
d3559 1
a3559 1
    integer :: STRINGSIZE               ! String size
d3970 1
a3970 1
    integer :: STRINGSIZE               ! String size
d4013 1
a4013 1
    integer :: STRINGSIZE               ! String size
d5040 1
a5040 1
       "$Id: MLSHDF5.f90,v 2.92 2009/06/23 18:25:42 pwagner Exp $"
d5050 3
@


2.92
log
@Prevent Intel from optimizing ident string away
@
text
@d31 1
d84 1
a84 1
       "$RCSfile: $"
d238 2
a239 1
      & LdFrmHDF5DS_ID_chararr1, LdFrmHDF5DS_ID_chararr2, LdFrmHDF5DS_ID_chararr3
d247 2
a248 1
      & LoadFromHDF5DS_chararr1, LoadFromHDF5DS_chararr2, LoadFromHDF5DS_chararr3
d301 2
a302 2
  character(len=*), dimension(1), parameter :: DONTDUMPTHESEDSNAMES = (/ &
    & 'coremetadata' /)
d690 5
d3167 24
d3546 47
d5040 1
a5040 1
       "$Id: read_apriori.f90 is it here $"
d5050 3
@


2.91
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d83 1
a83 1
       "$RCSfile: MLSHDF5.f90,v $"
d4958 1
a4959 1
!---------------------------- RCS Ident Info -------------------------------
d4961 2
a4962 3
       "$Id: MLSHDF5.f90,v 2.90 2009/05/08 00:42:04 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d4964 1
a4964 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d4966 1
d4971 3
@


2.90
log
@New optional arg laconic to prevent DumpHDF5DS from printing names
@
text
@d118 1
a118 1
!    [log stats], [log rms])
d120 1
a120 1
!    [real fillValue], [log stats], [log rms], [log unique], [log laconic])
d172 11
d380 1
a380 1
  subroutine DumpHDF5Attributes ( locID, names, groupName, DSName, stats, rms )
d387 1
a387 2
    logical, intent(in), optional           :: stats ! Show % = fill
    logical, intent(in), optional           :: rms ! Show rms, min, max
d488 1
a488 1
        call dump ( iValue(1:dims(1)), trim(name), stats=stats, rms=rms )
d491 1
a491 1
        call dump ( dValue(1:dims(1)), trim(name), stats=stats, rms=rms )
d517 1
a517 1
    & names, fillValue, stats, rms, unique, laconic )
d524 1
a524 4
    logical, intent(in), optional           :: stats ! Show % = fill
    logical, intent(in), optional           :: rms ! Show rms, min, max
    logical, intent(in), optional           :: unique ! Show unique values, count
    logical, intent(in), optional           :: laconic ! Don't print names
d555 2
a556 2
    if ( present(rms) ) skipCharValues = skipCharValues .or. rms
    if ( present(stats) ) skipCharValues = skipCharValues .or. stats
d561 1
a561 1
    if ( present(laconic) ) dontPrintName = laconic
d614 1
a614 1
              & stats=stats, rms=rms, unique=unique )
d616 1
a616 1
            call dump ( iValue, trim(namePrinted), stats=stats, rms=rms, unique=unique )
d624 1
a624 1
              & stats=stats, rms=rms, unique=unique )
d626 1
a626 1
            call dump ( iValue(:,:,1), trim(namePrinted), stats=stats, rms=rms, unique=unique )
d633 2
a634 2
            call dump ( iValue(:,1,1), trim(namePrinted), fillValue=int(fillvalue), stats=stats, &
              & rms=rms, unique=unique )
d636 1
a636 1
            call dump ( iValue(:,1,1), trim(namePrinted), stats=stats, rms=rms, unique=unique )
d647 1
a647 1
              & stats=stats, rms=rms, unique=unique )
d649 1
a649 1
            call dump ( dValue, trim(namePrinted), stats=stats, rms=rms, unique=unique )
d657 1
a657 1
              & fillValue=real(fillvalue, r8), stats=stats, rms=rms, unique=unique )
d659 1
a659 1
            call dump ( dValue(:,:,1), trim(namePrinted), stats=stats, rms=rms, unique=unique )
d667 1
a667 1
              & stats=stats, rms=rms, unique=unique )
d669 1
a669 1
            call dump ( dValue(:,1,1), trim(namePrinted), stats=stats, rms=rms, unique=unique )
d4814 1
a4814 1
          & clean=clean, format=int_format, width=width )
d4816 1
a4816 1
        call dump ( reals, names, clean=clean )
d4818 1
a4818 1
        call dump ( doubles, names, clean=clean )
d4823 1
a4823 1
          & clean=clean, format=int_format, width=width )
d4826 1
a4826 1
          & clean=clean, format=real_format, width=width )
d4829 1
a4829 1
          & clean=clean, format=dbl_format, width=width )
d4961 1
a4961 1
       "$Id: MLSHDF5.f90,v 2.89 2009/04/01 23:27:27 pwagner Exp $"
d4971 3
@


2.89
log
@Worked around bug in saving logical array
@
text
@d120 1
a120 1
!    [real fillValue], [log stats], [log rms], [log unique])
d506 2
a507 1
  subroutine DumpHDF5DS ( locID, groupName, names, fillValue, stats, rms, unique )
d517 1
d526 1
d535 1
d553 2
d565 2
d606 1
a606 1
            call dump ( iValue, trim(name), fillValue=int(fillvalue), &
d609 1
a609 1
            call dump ( iValue, trim(name), stats=stats, rms=rms, unique=unique )
d616 1
a616 1
            call dump ( iValue(:,:,1), trim(name), fillValue=int(fillvalue), &
d619 1
a619 1
            call dump ( iValue(:,:,1), trim(name), stats=stats, rms=rms, unique=unique )
d626 1
a626 1
            call dump ( iValue(:,1,1), trim(name), fillValue=int(fillvalue), stats=stats, &
d629 1
a629 1
            call dump ( iValue(:,1,1), trim(name), stats=stats, rms=rms, unique=unique )
d639 1
a639 1
            call dump ( dValue, trim(name), fillValue=real(fillvalue, r8), &
d642 1
a642 1
            call dump ( dValue, trim(name), stats=stats, rms=rms, unique=unique )
d649 1
a649 1
            call dump ( dValue(:,:,1), trim(name), &
d652 1
a652 1
            call dump ( dValue(:,:,1), trim(name), stats=stats, rms=rms, unique=unique )
d659 1
a659 1
            call dump ( dValue(:,1,1), trim(name), fillValue=real(fillvalue, r8), &
d662 1
a662 1
            call dump ( dValue(:,1,1), trim(name), stats=stats, rms=rms, unique=unique )
a670 2
          !call MLSMessage ( MLSMSG_Error, ModuleName, &
          !   & 'Unable to dump 3d character-valued DS ' // trim(name) )
d673 1
a673 1
          call dump ( chArray, trim(name) )
d678 1
a678 1
          call dump ( chArray(:,:,1), trim(name) )
d689 2
a690 2
            ! call dump ( trim(chValue(1)), trim(name) )
            call output( 'name: ' // trim(name), advance='yes' )
d695 1
a695 1
            call dump ( ch1dArray, trim(name) )
d4954 1
a4954 1
       "$Id: MLSHDF5.f90,v 2.88 2008/06/18 20:56:55 pwagner Exp $"
d4964 3
@


2.88
log
@New optional arg 'unique' dumps print unique elements, counts only
@
text
@d2966 6
a2971 1
    write ( myValue, '(L1)' ) value
d4948 1
a4948 1
       "$Id: MLSHDF5.f90,v 2.87 2008/05/24 00:54:46 vsnyder Exp $"
d4952 1
d4958 3
@


2.87
log
@Remove unused declarations
@
text
@d120 1
a120 1
!    [real fillValue], [log stats], [log rms])
d506 1
a506 1
  subroutine DumpHDF5DS ( locID, groupName, names, fillValue, stats, rms )
d515 1
d598 2
a599 1
            call dump ( iValue, trim(name), fillValue=int(fillvalue), stats=stats, rms=rms )
d601 1
a601 1
            call dump ( iValue, trim(name), stats=stats, rms=rms )
d608 2
a609 1
            call dump ( iValue(:,:,1), trim(name), fillValue=int(fillvalue), stats=stats, rms=rms )
d611 1
a611 1
            call dump ( iValue(:,:,1), trim(name), stats=stats, rms=rms )
d618 2
a619 1
            call dump ( iValue(:,1,1), trim(name), fillValue=int(fillvalue), stats=stats, rms=rms )
d621 1
a621 1
            call dump ( iValue(:,1,1), trim(name), stats=stats, rms=rms )
d631 2
a632 1
            call dump ( dValue, trim(name), fillValue=real(fillvalue, r8), stats=stats, rms=rms )
d634 1
a634 1
            call dump ( dValue, trim(name), stats=stats, rms=rms )
d641 2
a642 1
            call dump ( dValue(:,:,1), trim(name), fillValue=real(fillvalue, r8), stats=stats, rms=rms )
d644 1
a644 1
            call dump ( dValue(:,:,1), trim(name), stats=stats, rms=rms )
d651 2
a652 1
            call dump ( dValue(:,1,1), trim(name), fillValue=real(fillvalue, r8), stats=stats, rms=rms )
d654 1
a654 1
            call dump ( dValue(:,1,1), trim(name), stats=stats, rms=rms )
d4943 1
a4943 1
       "$Id: MLSHDF5.f90,v 2.86 2008/05/24 00:34:05 pwagner Exp $"
d4952 3
@


2.86
log
@Removed scraps from older reading of text files
@
text
@a2948 1
    integer :: I
d4936 1
a4936 1
       "$Id: MLSHDF5.f90,v 2.85 2008/05/22 01:06:42 vsnyder Exp $"
d4945 3
@


2.85
log
@Use new allocate_test to simplify LoadPtrFromDS_*
@
text
@a1085 1
    integer :: lun
a1107 1
    close( UNIT=lun, iostat=status )
a2837 1
    integer :: lun
a2855 1
    close( UNIT=lun, iostat=status )
d4937 1
a4937 1
       "$Id: MLSHDF5.f90,v 2.84 2008/05/20 01:59:28 vsnyder Exp $"
d4946 3
@


2.84
log
@Add 4d integer, real, double
@
text
@d220 2
a221 1
      & LdFrmHDF5DS_ID_intarr3, LdFrmHDF5DS_ID_logarr1, &
d228 2
a229 1
      & LoadFromHDF5DS_intarr3, LoadFromHDF5DS_logarr1, &
d240 4
a243 2
      & LoadPtrFromHDF5DS_logarr1, LoadPtrFromHDF5DS_dblarr1, &
      & LoadPtrFromHDF5DS_dblarr2, LoadPtrFromHDF5DS_dblarr3, &
d263 1
d2926 15
d3271 22
d3623 23
d3976 1
a3976 1
    ! This routine allocates an array and loads it with values from a DS
d3978 1
d3982 1
d3984 1
a3984 5
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(hsize_t) :: SHP(2)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a3985 14
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_intarr2' )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    call allocate_test ( value, int(shp(1)), int(shp(2)), 'Value', moduleName )
    call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
      & (/ shp, ones(1:5) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call MLSMessageCalls( 'pop' )
d3988 28
d4079 1
a4079 1
    ! This routine allocates an array and loads it with values from a DS
d4081 1
d4085 1
d4087 1
a4087 5
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(hsize_t) :: SHP(2)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a4088 14
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_dblarr2' )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    call allocate_test ( value, int(shp(1)), int(shp(2)), 'Value', moduleName )
    call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & (/ shp, ones(1:5) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call MLSMessageCalls( 'pop' )
d4093 1
a4093 1
    ! This routine allocates an array and loads it with values from a DS
d4095 1
d4099 1
d4101 1
a4101 5
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(hsize_t) :: SHP(3)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a4102 15
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_dblarr3' )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    call allocate_test ( value, int(shp(1)), int(shp(2)), int(shp(3)), 'Value', &
      & moduleName )
    call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & (/ shp, ones(1:4) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call MLSMessageCalls( 'pop' )
d4107 1
a4107 1
    ! This routine allocates an array and loads it with values from a DS
d4109 1
d4113 1
d4115 1
a4115 5
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(hsize_t) :: SHP(4)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a4116 15
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_dblarr3' )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    call allocate_test ( value, int(shp(1)), int(shp(2)), int(shp(3)), int(shp(4)), 'Value', &
      & moduleName )
    call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & (/ shp, ones(1:4) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call MLSMessageCalls( 'pop' )
d4156 1
a4156 1
    ! This routine allocates an array and loads it with values from a DS
d4158 1
d4162 1
d4164 1
a4164 5
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(hsize_t) :: SHP(2)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a4165 14
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_snglarr2' )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    call allocate_test ( value, int(shp(1)), int(shp(2)), 'Value', moduleName )
    call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
      & (/ shp, ones(1:5) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call MLSMessageCalls( 'pop' )
d4170 1
a4170 1
    ! This routine allocates an array and loads it with values from a DS
d4172 1
d4176 1
d4178 1
a4178 5
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(hsize_t) :: SHP(3)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a4179 15
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_snglarr3' )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    call allocate_test ( value, int(shp(1)), int(shp(2)), int(shp(3)), 'Value', &
      & moduleName )
    call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
      & (/ shp, ones(1:4) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call MLSMessageCalls( 'pop' )
d4184 3
a4186 2
    ! This routine allocates an array and loads it with values from a DS
    use MLSMessageModule, only: MLSMSG_Allocate
d4190 1
d4192 1
a4192 5
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(hsize_t) :: SHP(4)          ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a4193 16
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadPtrFromHDF5DS_snglarr4' )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    call get_ds_shape ( spaceID, shp, name )
    allocate ( value(shp(1),shp(2),shp(3),shp(4)), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Allocate // 'Value' )
    call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
      & (/ shp, ones(1:3) /), status )
    call finishLoad ( name, status, spaceID, setID )
    call MLSMessageCalls( 'pop' )
d4941 1
a4941 1
       "$Id: MLSHDF5.f90,v 2.83 2008/05/10 01:14:04 vsnyder Exp $"
d4950 3
@


2.83
log
@Use includes to generate multiple-rank routines
@
text
@d221 2
a222 1
      & LdFrmHDF5DS_ID_dblarr1, LdFrmHDF5DS_ID_dblarr2, LdFrmHDF5DS_ID_dblarr3, &
d228 2
a229 1
      & LoadFromHDF5DS_dblarr1, LoadFromHDF5DS_dblarr2, LoadFromHDF5DS_dblarr3, &
d261 1
d2994 15
d3342 22
d3675 23
d4061 31
d4965 1
a4965 1
       "$Id: MLSHDF5.f90,v 2.82 2008/05/02 00:05:19 pwagner Exp $"
d4974 3
@


2.82
log
@Reads textFile using io stuff
@
text
@d269 2
a270 1
  integer(kind=hsize_t), dimension(7) :: ones = (/1,1,1,1,1,1,1/)
d1063 1
a1063 1
    use IO_STUFF, only: get_lun, read_textFile
d2803 1
a2803 6
    ! Local variables
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP, MAXDIMS        ! Shape
    integer :: STRINGTYPE               ! Type for string
a2804 22
    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_chararr1' )
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create a data type for this string
    call h5tcopy_f ( H5T_NATIVE_CHARACTER, stringtype, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create stringtype for array' // trim(name) )
    call h5tset_size_f ( stringtype, max(len(value(1)), 1), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to set size for stringtype ' // trim(name) )
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, stringtype, &
      & spaceID, setID, status, adding_to, cFill=FillValue)
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 1D char array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, stringtype, value, &
      & int ( (/ shp, ones(1:6) /), hsize_t ), status )
    call finishSaveDS ( name, status, setID, spaceID, stringType )
    call MLSMessageCalls( 'pop' )
d2818 1
a2818 6
    ! Local variables
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(2) :: SHP, MAXDIMS        ! Shape
    integer :: STRINGTYPE               ! Type for string
a2819 22
    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_chararr2' )
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create a data type for this string
    call h5tcopy_f ( H5T_NATIVE_CHARACTER, stringtype, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create stringtype for array' // trim(name) )
    call h5tset_size_f ( stringtype, max(len(value(1,1)), 1), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to set size for stringtype ' // trim(name) )
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, stringtype, &
      & spaceID, setID, status, adding_to, cFill=fillValue)
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 2D char array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, stringtype, value, &
      & int ( (/ shp, ones(1:5) /), hsize_t ), status )
    call finishSaveDS ( name, status, setID, spaceID, stringType )
    call MLSMessageCalls( 'pop' )
d2824 1
a2824 1
    use IO_STUFF, only: get_lun, read_textFile
d2884 1
a2884 5
    ! Local variables
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP, MAXDIMS        ! Shape
a2885 15
    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_intarr1' )
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_INTEGER, &
      & spaceID, setID, status, adding_to, iFill=fillValue)
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 1D integer array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_INTEGER, value, &
      & int ( (/ shp, ones(1:6) /), hsize_t ), status )
    call finishSaveDS ( name, status, setID, spaceID )
    call MLSMessageCalls( 'pop' )
d2899 1
a2899 5
    ! Local variables
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(2) :: SHP, MAXDIMS        ! Shape
a2900 15
    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_intarr2' )
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_INTEGER, &
      & spaceID, setID, status, adding_to, iFill=fillValue)
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 2D integer array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_INTEGER, value, &
      & int ( (/ shp, ones(1:5) /), hsize_t ), status )
    call finishSaveDS ( name, status, setID, spaceID )
    call MLSMessageCalls( 'pop' )
d2914 1
a2914 5
    ! Local variables
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(3) :: SHP, MAXDIMS        ! Shape
a2915 15
    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_intarr3' )
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_INTEGER, &
      & spaceID, setID, status, adding_to, iFill=fillValue )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 3D integer array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_INTEGER, value, &
      & int ( (/ shp, ones(1:4) /), hsize_t ), status )
    call finishSaveDS ( name, status, setID, spaceID )
    call MLSMessageCalls( 'pop' )
d2941 1
a2941 4
    do i = 1, size(value)
      myValue(i) = 'F'
      if ( value(i) ) myValue(i) = 'T'
    end do
d2957 1
a2957 5
    ! Local variables
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP, MAXDIMS        ! Shape
a2958 15
    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_dblarr1' )
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_DOUBLE, &
      & spaceID, setID, status, adding_to, dFill=fillValue )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 1D double array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & int ( (/ shp, ones(1:6) /), hsize_t ), status )
    call finishSaveDS ( name, status, setID, spaceID )
    call MLSMessageCalls( 'pop' )
d2972 1
a2972 5
    ! Local variables
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(2) :: SHP, MAXDIMS        ! Shape
a2973 15
    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_dblarr2' )
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_DOUBLE, &
      & spaceID, setID, status, adding_to, dFill=fillValue )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 2D double array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & int ( (/ shp, ones(1:5) /), hsize_t ), status )
    call finishSaveDS ( name, status, setID, spaceID )
    call MLSMessageCalls( 'pop' )
d2987 1
a2987 5
    ! Local variables
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(3) :: SHP, MAXDIMS        ! Shape
a2988 15
    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_dblarr3' )
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_DOUBLE, &
      & spaceID, setID, status, adding_to, dFill=fillValue )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 3D double array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & int ( (/ shp, ones(1:4) /), hsize_t ), status )
    call finishSaveDS ( name, status, setID, spaceID )
    call MLSMessageCalls( 'pop' )
d2997 1
a2997 1
    real, intent(in) :: VALUE(:)     ! The array itself
d3017 1
a3017 1
      & 'Unable to create dataset for 1D double array ' // trim(name) )
a3045 9
    ! Local variables
    integer(hsize_t), dimension(2) :: chunk_dims, dims, maxdims
    integer :: spaceID                  ! ID for filespace
    integer :: memSpaceID               ! ID for arrayspace
    integer :: filespaceID              ! ID for filespace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(2) :: SHP        ! Shape
    integer :: style   ! fixed static (0), dynamic 1st (1), adding to (2)
d3047 1
a3047 10
    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_snglarr2' )
    style = 0  ! The default
    if ( present(may_add_to) ) then
      if ( may_add_to ) style = 1
    end if
    if ( present(adding_to) ) then
      if ( adding_to ) style = 2
    end if
    if ( DEEBUG ) print *, 'style:   ', style
a3048 107
    ! Create the dataspace
    shp = shape(value)
    maxdims = shp
    dims = shp
    chunk_dims = shp
    ! Create the dataset
    if ( style == 0 ) then
     ! print *, 'Creating a static data space'
      call h5sCreate_simple_f ( 2, int(shp,hSize_T), spaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataspace for 2D real array ' // trim(name) )
      if ( present(fillValue) ) then
        call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to create property list for 2D real array ' // trim(name) )
        call h5pset_fill_value_f (cparms, H5T_NATIVE_REAL, fillValue, status)
        if ( status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
          &  "Unable to set Fill value for 2D real array " // trim (name))
        call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
          & status, cparms )
      else
        call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
          & status )
      end if
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataset for 2D real array ' // trim(name) )
      memspaceID = spaceID
      filespaceID = spaceID
    else if ( style == 1 ) then
     ! print *, 'Creating a dynamic data space'
      maxdims(2) = H5S_UNLIMITED_F
      dims(2) = max(int(1, hsize_T), shp(2))
      chunk_dims(2) = 1
      if ( DEEBUG ) print *, 'shape ', shp
      if ( DEEBUG ) print *, 'maxdims ', maxdims
      if ( DEEBUG ) print *, 'dims ', dims
      if ( DEEBUG ) print *, 'chunk_dims ', chunk_dims
      call h5screate_simple_f ( 2, dims, memspaceID, status, maxdims )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create memspace for 2D real array ' // trim(name) )
      spaceID = memspaceID
      call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create property list for 2D real array ' // trim(name) )
      call h5pset_chunk_f(cparms, 2, chunk_dims, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to set chunking 2D real array ' // trim(name) )
      if ( present(fillValue) ) then
        call h5pset_fill_value_f (cparms, H5T_NATIVE_REAL, fillValue, status)
        if ( status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
          &  "Unable to set Fill value for 2D real array " // trim (name))
      end if
      call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
        & status, cparms )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataset for 2D real array ' // trim(name) )
      call h5dextend_f ( setID, dims, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to extend dataset creating 2D real array ' // trim(name) )
      call h5dget_space_f(setID, filespaceID, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get filespaceID creating 2D real array ' // trim(name) )
      if ( DEEBUG ) print *, 'filespaceID ', filespaceID
      if ( DEEBUG ) print *, 'memspaceID ', memspaceID
      if ( DEEBUG ) print *, 'cparms ', cparms
      if ( DEEBUG ) print *, 'locID ', locID
      if ( DEEBUG ) print *, 'setID ', setID
    else
     ! print *, 'Reopening/extending a dynamic data space'
      call h5dopen_f ( locID, trim(name), setID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open dataset for 2D real array ' // trim(name) )
     ! print *, 'setID:   ', setID
      call h5dget_space_f ( setID, spaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get dataspace for 2D real array ' // trim(name) )
      if ( .not. present(start) ) &
        & call mls_extend ( setID, shp )
      memspaceID = spaceID
      call h5dget_space_f( setID, filespaceID, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get dataspace for 2D real array ' // trim(name) )
     ! print *, 'new spaceID             : ', spaceID
    end if
    if ( present(start) ) then
     ! print *, 'start ', start
      call mls_extend ( setID, int(Count, hsize_T), start, filespaceID )
      call mls_hyperslab_save ( filespaceID, start, count, stride, block )
!     Check before actually writing
      if ( style == 2 ) &
        & call h5screate_simple_f(2, dims, memspaceID, status, maxdims)
      call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
        & int ( (/ shp, ones(1:5) /), hsize_t ), status, &
        & memspaceID, filespaceID )
     ! print *, 'After writing mem space ', memspaceID
      spaceID = filespaceID
    else
      ! Write the data
      call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
        & int ( (/ shp, ones(1:5) /), hsize_t ), status )
    end if
    if ( present(start) ) then
      call finishSaveDS ( name, status, setID, spaceID, memspaceID=memspaceID )
    else
      call finishSaveDS ( name, status, setID, spaceID )
    end if
    call MLSMessageCalls( 'pop' )
d3072 1
a3072 9
    ! Local variables
    integer(hsize_t), dimension(3) :: chunk_dims, dims, maxdims
    integer :: spaceID                  ! ID for filespace
    integer :: filespaceID              ! ID for filespace
    integer :: memSpaceID               ! ID for arrayspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(3) :: SHP        ! Shape
    integer :: style   ! fixed static (0), dynamic 1st (1), adding to (2)
a3073 117
    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_snglarr3' )
    style = 0  ! The default
    if ( present(may_add_to) ) then
      if ( may_add_to ) style = 1
    end if
    if ( present(adding_to) ) then
      if ( adding_to ) style = 2
    end if

    if ( DEEBUG ) print *, 'style:   ', style
    ! Create the dataspace
    shp = shape(value)
    maxdims = shp
    dims = shp
    chunk_dims = shp
    ! Create the dataset
    if ( style == 0 ) then
      call h5sCreate_simple_f ( 3, int(shp,hSize_T), spaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataspace for 3D real array ' // trim(name) )
      ! Create the dataset
      if ( present(fillValue) ) then
        call h5pcreate_f ( H5P_DATASET_CREATE_F, cparms, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to create property list for 3D real array ' // trim(name) )
        call h5pset_fill_value_f ( cparms, H5T_NATIVE_REAL, fillValue, status)
        if ( status /= 0 ) call MLSMessage (MLSMSG_Error, ModuleName, &
          &  "Unable to set Fill value for 3D real array " // trim (name))
        call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
          & status, cparms )
      else
        call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
          & status )
      end if
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataset for 3D real array ' // trim(name) )
      memspaceID = spaceID
      filespaceID = spaceID
    else if ( style == 1 ) then
      maxdims(3) = H5S_UNLIMITED_F
      dims(3) = max(int(1, hsize_T), shp(3))
      chunk_dims(3) = 1
      if ( DEEBUG ) print *, 'shape ', shp
      if ( DEEBUG ) print *, 'maxdims ', maxdims
      if ( DEEBUG ) print *, 'dims ', dims
      if ( DEEBUG ) print *, 'chunk_dims ', chunk_dims
      call h5screate_simple_f ( 3, dims, memspaceID, status, maxdims )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create memspace for 3D real array ' // trim(name) )
      spaceID = memspaceID
      call h5pcreate_f ( H5P_DATASET_CREATE_F, cparms, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create property list for 3D real array ' // trim(name) )
      call h5pset_chunk_f(cparms, 3, chunk_dims, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to set chunking 3D real array ' // trim(name) )
      if ( present(fillValue) ) then
        call h5pset_fill_value_f ( cparms, H5T_NATIVE_REAL, fillValue, status )
        if ( status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
          &  "Unable to set Fill value for 3D real array " // trim (name))
      end if
      call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, &
        & setID, status, cparms )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataset for 3D real array ' // trim(name) )
      call h5dextend_f ( setID, dims, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to extend dataset creating 3D real array ' // trim(name) )
      call h5dget_space_f(setID, filespaceID, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get filespaceID creating 3D real array ' // trim(name) )
      if ( DEEBUG ) print *, 'filespaceID ', filespaceID
      if ( DEEBUG ) print *, 'memspaceID ', memspaceID
      if ( DEEBUG ) print *, 'cparms ', cparms
      if ( DEEBUG ) print *, 'locID ', locID
      if ( DEEBUG ) print *, 'setID ', setID
    else
      call h5dopen_f ( locID, trim(name), setID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open dataset for 3D real array ' // trim(name) )
      call h5dget_space_f ( setID, spaceID, status)
      if ( .not. present(start) ) &
        & call mls_extend ( setID, shp )
      memspaceID = spaceID
      call h5dget_space_f ( setID, filespaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get dataspace for 3D real array ' // trim(name) )
    end if
    if ( present(start) ) then
      if ( DEEBUG ) print *, 'name ', name
      if ( DEEBUG ) print *, 'shape(value) ', shp
      if ( DEEBUG ) print *, 'start ', start
      if ( DEEBUG ) print *, 'count ', count
      call mls_extend ( setID, int(Count, hsize_T), start, filespaceID )
      call mls_hyperslab_save ( filespaceID, start, count, stride, block )
      if ( style == 2 ) &
        & call h5screate_simple_f(3, dims, memspaceID, status, maxdims)
      if ( DEEBUG ) print *, 'filespaceID ', filespaceID
      call dump_space(filespaceID)
      if ( DEEBUG ) print *, 'memspaceID ', memspaceID
      call dump_space(memspaceID)
      call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
        & int ( (/ shp, ones(1:4) /), hsize_t ), status, &
        & memspaceID, filespaceID )
      spaceID = filespaceID
    else
      ! Write the data
      call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
        & int ( (/ shp, ones(1:4) /), hsize_t ), status )
    end if
    if ( present(start) ) then
      call finishSaveDS ( name, status, setID, spaceID, memspaceID=memspaceID )
    else
      call finishSaveDS ( name, status, setID, spaceID )
    end if
    call MLSMessageCalls( 'pop' )
d3097 1
a3097 19
    ! Local variables
    integer(hsize_t), dimension(4) :: chunk_dims, dims, maxdims
    integer :: spaceID                  ! ID for filespace
    integer :: filespaceID              ! ID for filespace
    integer :: memSpaceID               ! ID for arrayspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(4) :: SHP        ! Shape
    integer :: style   ! fixed static (0), dynamic 1st (1), adding to (2)

    ! Executable code
    call MLSMessageCalls( 'push', constantName='SaveAsHDF5DS_snglarr4' )
    style = 0  ! The default
    if ( present(may_add_to) ) then
      if ( may_add_to ) style = 1
    end if
    if ( present(adding_to) ) then
      if ( adding_to ) style = 2
    end if
a3098 106
    if ( DEEBUG ) print *, 'style:   ', style
    ! Create the dataspace
    shp = shape(value)
    maxdims = shp
    dims = shp
    chunk_dims = shp
    ! Create the dataset
    if ( style == 0 ) then
      call h5sCreate_simple_f ( 4, int(shp,hSize_T), spaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataspace for 4D real array ' // trim(name) )
      ! Create the dataset
      if ( present(fillValue) ) then
        call h5pcreate_f ( H5P_DATASET_CREATE_F, cparms, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to create property list for 4D real array ' // trim(name) )
        call h5pset_fill_value_f ( cparms, H5T_NATIVE_REAL, fillValue, status )
        if ( status /= 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
          &  "Unable to set Fill value for 4D real array " // trim (name) )
        call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
          & status, cparms )
      else
        call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
        & status )
      end if
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataset for 4D real array ' // trim(name) )
      memspaceID = spaceID
      filespaceID = spaceID
    else if ( style == 1 ) then
      maxdims(4) = H5S_UNLIMITED_F
      dims(4) = max(int(1, hsize_T), shp(4))
      chunk_dims(4) = 1
      if ( DEEBUG ) print *, 'shape ', shp
      if ( DEEBUG ) print *, 'maxdims ', maxdims
      if ( DEEBUG ) print *, 'dims ', dims
      if ( DEEBUG ) print *, 'chunk_dims ', chunk_dims
      call h5screate_simple_f ( 4, dims, memspaceID, status, maxdims )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create memspace for 4D real array ' // trim(name) )
      spaceID = memspaceID
      call h5pcreate_f ( H5P_DATASET_CREATE_F, cparms, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create property list for 4D real array ' // trim(name) )
      call h5pset_chunk_f ( cparms, 4, chunk_dims, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to set chunking 4D real array ' // trim(name) )
      if ( present(fillValue) ) then
        call h5pset_fill_value_f ( cparms, H5T_NATIVE_REAL, fillValue, status )
        if ( status /= 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
          &  "Unable to set Fill value for 4D real array " // trim (name) )
      end if
      call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, &
        & setID, status, cparms )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to create dataset for 4D real array ' // trim(name) )
      call h5dextend_f ( setID, dims, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to extend dataset creating 4D real array ' // trim(name) )
      call h5dget_space_f ( setID, filespaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get filespaceID creating 4D real array ' // trim(name) )
      if ( DEEBUG ) print *, 'filespaceID ', filespaceID
      if ( DEEBUG ) print *, 'memspaceID ', memspaceID
      if ( DEEBUG ) print *, 'cparms ', cparms
      if ( DEEBUG ) print *, 'locID ', locID
      if ( DEEBUG ) print *, 'setID ', setID
    else
      call h5dopen_f ( locID, trim(name), setID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open dataset for 4D real array ' // trim(name) )
      call h5dget_space_f ( setID, spaceID, status )
      if ( .not. present(start) ) call mls_extend ( setID, shp )
      memspaceID = spaceID
      call h5dget_space_f ( setID, filespaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get dataspace for 4D real array ' // trim(name) )
    end if
    if ( present(start) ) then
      if ( DEEBUG ) print *, 'name ', name
      if ( DEEBUG ) print *, 'shape(value) ', shp
      if ( DEEBUG ) print *, 'start ', start
      if ( DEEBUG ) print *, 'count ', count
      call mls_extend ( setID, int(Count, hsize_T), start, filespaceID )
      call mls_hyperslab_save ( filespaceID, start, count, stride, block )
      if ( style == 2 ) &
        & call h5screate_simple_f(4, dims, memspaceID, status, maxdims)
      if ( DEEBUG ) print *, 'filespaceID ', filespaceID
      call dump_space ( filespaceID )
      if ( DEEBUG ) print *, 'memspaceID ', memspaceID
      call dump_space ( memspaceID )
      call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
        & int ( (/ shp, ones(1:3) /), hsize_t ), status, &
        & memspaceID, filespaceID )
      spaceID = filespaceID
    else
      ! Write the data
      call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
        & int ( (/ shp, ones(1:3) /), hsize_t ), status )
    end if
    if ( present(start) ) then
      call finishSaveDS ( name, status, setID, spaceID, memspaceID=memspaceID )
    else
      call finishSaveDS ( name, status, setID, spaceID )
    end if
    call MLSMessageCalls( 'pop' )
d3117 3
a3119 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3120 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_chararr1' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3139 3
a3141 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3142 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_chararr12' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3161 3
a3163 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3164 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_chararr3' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3183 3
a3185 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3186 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_intarr1' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
a3203 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
d3205 4
a3208 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_intarr2' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
a3225 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
d3227 4
a3230 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_intarr3' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3274 3
a3276 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3277 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_dblarr1' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3296 3
a3298 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3299 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_dblarr2' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3318 3
a3320 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3321 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_dblarr3' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3340 3
a3342 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3343 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_snglarr1' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3362 3
a3364 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3365 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_snglarr2' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3384 3
a3386 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3387 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_snglarr3' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3406 3
a3408 3
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    type (MLSFile_T)   :: MLSFile
a3409 9
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LdFromHDF5DS_ID_snglarr4' )
    status = InitializeMLSFile ( MLSFile, type=l_hdf, access=DFACC_RDONLY, &
      & name='unknown', shortName='unknown', HDFVersion=HDFVERSION_5 )
    MLSFile%fileID%sd_id = locID
    MLSFile%stillOpen = .true.
    call LoadFromHDF5DS ( MLSFile, name, value, &
    & start, count, stride, block )
    call MLSMessageCalls( 'pop' )
d3428 1
a3428 8
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
    integer :: STRINGTYPE               ! String type
    integer :: STRINGSIZE               ! String size
a3429 36
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_chararr1' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dGet_type_f ( setID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 1D char array ' // trim(name), &
      & MLSFile=MLSFile )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for 1D char array ' // trim(name), &
      & MLSFile=MLSFile )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 1D char array ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, stringtype, value, &
        & (/ shp, ones(1:6) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, &
        & memspaceID, stringType, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, stringtype, value, (/ shp, ones(1:6) /), status )
      call finishLoad ( name, status, spaceID, setID, &
        & stringType=stringType, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3448 1
a3448 8
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(2) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
    integer :: STRINGTYPE               ! String type
    integer :: STRINGSIZE               ! String size
a3449 36
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_chararr2' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dGet_type_f ( setID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 2D char array ' // trim(name), &
      & MLSFile=MLSFile )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for 2D char array ' // trim(name), &
      & MLSFile=MLSFile )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 2D char array ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, stringtype, value, &
        & (/ shp, ones(1:5) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, &
        & memspaceID, stringType, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, stringtype, value, (/ shp, ones(1:5) /), status )
      call finishLoad ( name, status, spaceID, setID, &
        & stringType=stringType, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3468 1
a3468 8
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(3) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
    integer :: STRINGTYPE               ! String type
    integer :: STRINGSIZE               ! String size
a3469 36
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_chararr3' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dGet_type_f ( setID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 3D char array ' // trim(name), &
      & MLSFile=MLSFile )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for 3D char array ' // trim(name), &
      & MLSFile=MLSFile )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 3D char array ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, stringtype, value, &
        & (/ shp, ones(1:4) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, &
        & memspaceID, stringType, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, stringtype, value, (/ shp, ones(1:4) /), status )
      call finishLoad ( name, status, spaceID, setID, &
        & stringType=stringType, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3476 1
d3489 3
a3491 6
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a3492 24
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_intarr1' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
        & (/ shp, ones(1:6) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
        & (/ shp, ones(1:6) /), status )
      call finishLoad ( name, status, spaceID, setID, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3499 1
a3510 6
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(2) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
d3512 4
a3515 24
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_intarr2' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
        & (/ shp, ones(1:5) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
        & (/ shp, ones(1:5) /), status )
      call finishLoad ( name, status, spaceID, setID, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3522 1
a3533 6
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(3) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
d3535 4
a3538 24
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_intarr3' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
        & (/ shp, ones(1:4) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
        & (/ shp, ones(1:4) /), status )
      call finishLoad ( name, status, spaceID, setID, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3570 1
d3583 3
a3585 6
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a3586 24
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_dblarr1' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f(setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:6) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:6) /), status )
      call finishLoad ( name, status, spaceID, setID, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3593 1
d3606 3
a3608 6
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(2) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a3609 24
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_dblarr2' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:5) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:5) /), status )
      call finishLoad ( name, status, spaceID, setID, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3616 1
d3629 3
a3631 6
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(3) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a3632 24
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_dblarr3' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:4) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:4) /), status )
      call finishLoad ( name, status, spaceID, setID, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3639 1
d3651 1
d3653 3
a3655 6
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(1) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a3656 24
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_snglarr1' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:6) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:6) /), status )
      call finishLoad ( name, status, spaceID, setID, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3663 1
d3676 3
a3678 6
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(2) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a3679 24
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_snglarr2' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:5) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:5) /), status )
      call finishLoad ( name, status, spaceID, setID, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3686 1
d3699 3
a3701 6
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(3) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a3702 24
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_snglarr3' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:4) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:4) /), status )
      call finishLoad ( name, status, spaceID, setID, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3709 1
d3722 3
a3724 6
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hsize_t), dimension(4) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
a3725 24
    ! Executable code
    call MLSMessageCalls( 'push', constantName='LoadFromHDF5DS_snglarr4' )
    shp = shape ( value )
    call h5dOpen_f ( MLSFile%fileID%sd_id, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name), &
      & MLSFile=MLSFile )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name), &
      & MLSFile=MLSFile )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:3) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, MLSFile=MLSFile )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:3) /), status )
      call finishLoad ( name, status, spaceID, setID, MLSFile=MLSFile )
    end if
    call MLSMessageCalls( 'pop' )
d3804 4
a3807 4
   call get_DS_shape ( spaceID, shp, name )
   call allocate_test ( value, int(shp(1)), int(shp(2)), 'Value', moduleName )
   call h5dread_f ( setID, stringtype, value, (/ shp, ones(1:5) /), status )
   call finishLoad ( name, status, spaceID, setID, stringType=stringType )
d4871 1
a4871 1
       "$Id: MLSHDF5.f90,v 2.81 2008/04/25 22:51:23 pwagner Exp $"
d4880 3
@


2.81
log
@Passes optional arg maxLineLen through to textFile_to_Chars
@
text
@d273 1
d1062 1
a1062 1
    use MLSFiles, only: textFile_to_Chars
d1070 1
d1072 1
d1076 3
a1078 1
    character(len=3) :: blockChar
a1082 2
    logical :: is_present
    logical, parameter :: NEVERDELETE = .true.
a1083 1
    integer :: lun
d1087 2
d1090 2
a1091 1
    call textFile_to_Chars( trim(textFile), value, maxLineLen )
d2877 1
a2877 1
    use MLSFiles, only: textFile_to_Chars
d2885 2
a2893 1
    integer :: lun
d2897 2
d2900 2
a2901 1
    call textFile_to_Chars( trim(textFile), value, maxLineLen )
d5916 1
a5916 1
       "$Id: MLSHDF5.f90,v 2.80 2008/04/22 17:17:38 pwagner Exp $"
d5925 3
@


2.80
log
@Should not print extra debugging stuff
@
text
@a26 1
  use IO_STUFF, only: get_lun
d1060 1
a1060 1
   & skip_if_already_there )
d1066 1
a1068 1
    logical, parameter :: USINGDIRECTACCESS = .false.
d1086 2
a1087 14
    if ( USINGDIRECTACCESS ) then
      call GET_LUN ( LUN )
      open(UNIT=lun, access='direct', recl=MAXTEXTSIZE, &
        & file=trim(textFile), status='old', iostat=status )
      if ( status /= 0 ) then
        call MLSMessage(MLSMSG_Warning, ModuleName, &
          & 'Unable to write attribute--failed to open textfile' )
        return
      endif
      read(UNIT=lun, REC=1, IOSTAT=status) value
    else
      call textFile_to_Chars( trim(textFile), value )
      status = 0
    endif
d2871 1
a2871 1
  subroutine SaveAsHDF5DS_textFile ( textFile, locID, name )
d2877 1
a2879 1
    logical, parameter :: USINGDIRECTACCESS = .false.
d2892 1
a2892 19
    if ( USINGDIRECTACCESS ) then
      call GET_LUN ( LUN )
      open(UNIT=lun, access='direct', recl=MAXTEXTSIZE, &
        & file=trim(textFile), status='old', iostat=status )
      if ( status /= 0 ) then
        call MLSMessage(MLSMSG_Warning, ModuleName, &
          & 'Unable to write dataset--failed to open textfile' )
        return
      endif
      read(UNIT=lun, REC=1, IOSTAT=status) value
    else
      call textFile_to_Chars( trim(textFile), value )
      status = 0
    endif
    if ( status /= 0 ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to read textfile' )
      return
    endif
d5907 1
a5907 1
       "$Id: MLSHDF5.f90,v 2.79 2008/04/18 16:29:06 pwagner Exp $"
d5916 3
@


2.79
log
@Now works properly with NAG, Lahey, and Intel
@
text
@d374 1
a374 1
    logical, parameter :: DEEBUG = .true.
d5938 1
a5938 1
       "$Id: MLSHDF5.f90,v 2.78 2008/03/07 01:35:47 pwagner Exp $"
d5947 3
@


2.78
log
@Will subdivide attributes into blocks if too large
@
text
@d1062 1
d1069 1
d1087 13
a1099 7
    call GET_LUN ( LUN )
    open(UNIT=lun, access='direct', recl=MAXTEXTSIZE, &
      & file=trim(textFile), status='old', iostat=status )
    if ( status /= 0 ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to write attribute--failed to open textfile' )
      return
a1100 1
    read(UNIT=lun, REC=1, IOSTAT=status) value
d2885 1
d2892 1
d2905 13
a2917 7
    call GET_LUN ( LUN )
    open(UNIT=lun, access='direct', recl=MAXTEXTSIZE, &
      & file=trim(textFile), status='old', iostat=status )
    if ( status /= 0 ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to write dataset--failed to open textfile' )
      return
a2918 1
    read(UNIT=lun, REC=1, IOSTAT=status) value
d5938 1
a5938 1
       "$Id: MLSHDF5.f90,v 2.77 2008/02/22 21:29:13 pwagner Exp $"
d5947 3
@


2.77
log
@Can now save entire textfile as attribute or dataset
@
text
@d267 1
d276 2
a277 1
  integer, parameter                      :: MAXTEXTSIZE = 2000000
d1070 4
d1102 15
d5924 1
a5924 1
       "$Id: MLSHDF5.f90,v 2.76 2008/01/04 01:00:13 pwagner Exp $"
d5933 3
@


2.76
log
@More successful at dumping l1b files
@
text
@d27 1
d34 1
a34 1
  use MLSStrings, only: indexes
d251 2
a252 1
      & MakeHDF5AttributeDSN_st_arr1, MakeHDF5AttributeDSN_dblarr1
d262 2
a263 1
      & SaveAsHDF5DS_charsclr, SaveAsHDF5DS_chararr1, SaveAsHDF5DS_chararr2
d266 2
d275 1
a275 1
  integer, parameter :: MAXCHFIELDLENGTH = 2000000 ! max number of chars in l2cf
d372 1
a372 1
    ! logical, parameter :: DEEBUG = .true.
d379 1
d436 7
d452 1
d455 1
a455 1
      call GetHDF5AttrDims ( ItemID, name, hdims )
a456 1
      dims(1) = max(dims(1), 1)
d463 1
d641 2
d659 1
d661 4
d1057 98
d2265 1
d2270 1
d2272 2
d2284 3
d2294 13
a2306 1
      & 'Unable to get dims for datset ' // trim(name) )
d2855 58
d5903 1
a5903 1
       "$Id: MLSHDF5.f90,v 2.75 2007/10/04 20:43:36 vsnyder Exp $"
d5912 3
@


2.75
log
@Remove unused symbols
@
text
@d31 3
a33 1
  use MLSStringLists, only: GetStringElement, NumStringElements, StringElement
a63 1
  use MLSStringLists, only: catLists, IsInList
d224 1
a224 1
      & LdFrmHDF5DS_ID_chararr1, LdFrmHDF5DS_ID_chararr2
d230 1
a230 1
      & LoadFromHDF5DS_chararr1, LoadFromHDF5DS_chararr2
d271 2
d374 1
a374 1
    character(len=1024) :: myNames
d494 1
d504 1
a504 1
    character(len=1024) :: myNames
d509 1
d512 1
d517 3
d530 3
d564 1
d629 6
a634 6
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to dump 3d character-valued DS ' // trim(name) )
          !call allocate_test( chArray, dims(1), dims(2), dims(3), 'chArray', ModuleName )
          !call LoadFromHDF5DS ( groupID, name, chArray )
          !call dump ( chArray, trim(name) )
          !call deallocate_test( chArray, 'chArray', ModuleName )
d648 4
a651 4
            call allocate_test( chArray, dims(1), 1, 1, 'chArray', ModuleName )
            call LoadFromHDF5DS ( groupID, name, chArray(:,1,1) )
            call dump ( chArray(:,1,1), trim(name) )
            call deallocate_test( chArray, 'chArray', ModuleName )
d3498 31
d3988 63
d5707 1
a5707 1
       "$Id: MLSHDF5.f90,v 2.74 2007/10/03 23:51:53 vsnyder Exp $"
d5716 3
@


2.74
log
@Don't overflow MLSCallStack
@
text
@a5578 2
    ! Local variables
    integer :: status
d5600 1
a5600 1
       "$Id: MLSHDF5.f90,v 2.73 2007/08/17 00:27:48 pwagner Exp $"
d5609 3
@


2.73
log
@push more procedures onto MLSCallStack
@
text
@d312 1
a312 1
    if ( my_skip .and. is_present ) return
d316 1
a316 1
    call MLSMessageCalls( 'pop' )
d698 1
a698 1
    if ( status /= 0 ) return
d727 1
a727 1
    call MLSMessageCalls( 'pop' )
d729 1
a729 1
  
d961 1
a961 1
    if ( my_skip .and. is_present ) return
d1020 1
a1020 1
    call MLSMessageCalls( 'pop' )
d1044 1
a1044 1
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
d1067 1
a1067 1
    call MLSMessageCalls( 'pop' )
d1173 1
a1173 1
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) return
d1181 1
a1181 1
    call MLSMessageCalls( 'pop' )
d1206 1
a1206 1
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) return
d1214 1
a1214 1
    call MLSMessageCalls( 'pop' )
d1236 1
a1236 1
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) return
d1250 1
a1250 1
    call MLSMessageCalls( 'pop' )
d1272 1
a1272 1
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) return
d1280 1
a1280 1
    call MLSMessageCalls( 'pop' )
d1302 1
a1302 1
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) return
d1309 1
a1309 1
    call MLSMessageCalls( 'pop' )
d1332 1
a1332 1
      if ( IsHDF5AttributePresent_in_fID( fileID, dataName, attrName ) ) return
d1339 1
a1339 1
    call MLSMessageCalls( 'pop' )
d1362 1
a1362 1
      return
d1378 1
a1378 1
    call MLSMessageCalls( 'pop' )
d1402 1
a1402 1
      return
d1419 1
a1419 1
    call MLSMessageCalls( 'pop' )
d1443 1
a1443 1
      return
d1473 1
a1473 1
    call MLSMessageCalls( 'pop' )
d1499 1
a1499 1
      return
d1531 1
a1531 1
    call MLSMessageCalls( 'pop' )
d1554 1
a1554 1
      return
d1559 1
a1559 1
    call MLSMessageCalls( 'pop' )
d1580 1
a1580 1
      return
d1583 1
a1583 1
    call MLSMessageCalls( 'pop' )
d1607 1
a1607 1
      return
d1624 1
a1624 1
    call MLSMessageCalls( 'pop' )
d1646 1
a1646 1
      return
d1662 1
a1662 1
    call MLSMessageCalls( 'pop' )
d1684 1
a1684 1
      return
d1700 1
a1700 1
    call MLSMessageCalls( 'pop' )
d1724 1
a1724 1
      return
d1741 1
a1741 1
    call MLSMessageCalls( 'pop' )
d2421 1
a2421 1
      return
d2442 1
a2442 1
    call MLSMessageCalls( 'pop' )
d5284 1
a5284 1
    if ( itFits ) return
d5295 1
a5295 1
    call MLSMessageCalls( 'pop' )
d5555 1
a5555 1
      if ( IsHDF5AttributePresent_in_dsID(itemID, name) ) return
d5569 1
a5569 1
    call MLSMessageCalls( 'pop' )
d5602 1
a5602 1
       "$Id: MLSHDF5.f90,v 2.72 2007/01/31 00:07:23 pwagner Exp $"
d5611 3
@


2.72
log
@Compatible with renamed dumpNamedValues
@
text
@d60 2
a61 1
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
d305 1
d316 1
d335 1
d346 1
d381 1
d474 1
d510 1
d651 1
d675 1
d727 1
d745 1
d782 1
d797 1
d816 1
d833 1
d841 1
d858 1
d866 1
d883 1
d891 1
d906 1
d910 1
d925 1
d932 1
d955 1
d1020 1
d1040 1
d1067 1
d1085 1
d1095 1
d1113 1
d1123 1
d1141 1
d1151 1
d1169 1
d1181 1
d1202 1
d1214 1
d1232 1
d1250 1
d1268 1
d1280 1
d1298 1
d1309 1
d1328 1
d1339 1
d1354 1
d1378 1
d1393 1
d1419 1
d1435 1
d1473 1
d1490 1
d1531 1
d1544 1
d1559 1
d1572 1
d1583 1
d1598 1
d1624 1
d1638 1
d1662 1
d1676 1
d1700 1
d1715 1
d1741 1
d1755 1
d1761 1
d1775 1
d1781 1
d1795 1
d1801 1
d1815 1
d1821 1
d1835 1
d1841 1
d1855 1
d1861 1
d1875 1
d1881 1
d1895 1
d1901 1
d1915 1
d1921 1
d1935 1
d1941 1
d1960 1
d1978 1
d1999 1
d2028 1
d2043 1
d2048 1
d2067 1
d2085 1
d2104 1
d2122 1
d2140 1
d2162 1
d2180 1
d2202 1
d2217 1
d2229 1
d2244 1
d2256 1
d2276 1
d2297 1
d2317 1
d2338 1
d2352 1
d2369 1
d2382 1
d2396 1
d2415 1
d2442 1
d2457 1
d2477 1
d2494 1
d2514 1
d2527 1
d2537 1
d2556 1
d2580 1
d2599 1
d2617 1
d2639 1
a2650 17
 !    call h5sCreate_simple_f ( 1, int(maxdims,hSize_T), spaceID, status )
 !    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
 !      & 'Unable to create dataspace for 1D char array ' // trim(name) )
 !      ! Create the dataset
 !    if ( present(fillValue) ) then
 !      call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
 !      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
 !        & 'Unable to create property list for 1D char array ' // trim(name) )
 !      call h5pset_fill_value_f (cparms, H5T_NATIVE_CHARACTER, fillValue, status)
 !      if ( status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
 !        &  "Unable to set Fill value for 1D char array " // trim (name))
 !      call h5dCreate_f ( locID, trim(name), stringtype, spaceID, setID, &
 !        & status, cparms )
 !    else
 !      call h5dCreate_f ( locID, trim(name), stringtype, spaceID, setID, &
 !        & status )
 !    end if
d2659 1
d2681 1
a2692 17
 !    call h5sCreate_simple_f ( 2, int(maxdims,hSize_T), spaceID, status )
 !    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
 !      & 'Unable to create dataspace for 2D char array ' // trim(name) )
 !    ! Create the dataset
 !    if ( present(fillValue) ) then
 !      call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
 !      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
 !        & 'Unable to create property list for 2D char array ' // trim(name) )
 !      call h5pset_fill_value_f (cparms, H5T_NATIVE_CHARACTER, fillValue, status)
 !      if ( status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
 !        &  "Unable to set Fill value for 2D charr array " // trim (name))
 !      call h5dCreate_f ( locID, trim(name), stringtype, spaceID, setID, &
 !        & status, cparms )
 !    else
 !      call h5dCreate_f ( locID, trim(name), stringtype, spaceID, setID, &
 !        & status )
 !    end if
d2701 1
d2722 1
d2735 1
d2756 1
d2769 1
d2790 1
d2803 1
d2822 1
d2834 1
d2855 1
d2868 1
d2889 1
d2902 1
d2923 1
d2936 1
d2957 1
d2970 1
a3002 4
    ! integer :: test_rank
    ! integer(hsize_t), dimension(7) :: test_dims, test_maxdims
    ! integer(hssize_t), dimension(7) :: test_offset
    ! logical :: test_issimple
d3005 1
a3090 18
     ! print *, 'spaceID:   ', spaceID
      ! call h5sget_simple_extent_ndims_f ( spaceID, test_rank, status )
      ! if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      !  & 'Unable to get space rank for 2D real array ' // trim(name) )
     ! print *, 'rank:   ', test_rank
      ! call h5sget_simple_extent_dims_f ( spaceID, test_dims(1:test_rank), &
      ! &  test_maxdims(1:test_rank), status )
      ! if ( status /= test_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      ! & 'Unable to get dims for datset ' // trim(name) )
     ! print *, 'status                  : ', status
     ! print *, 'dims (before extending) : ', test_dims(1:test_rank)
     ! print *, 'max_dims                : ', test_maxdims(1:test_rank)
      ! Can't test on status--it's set to the test_rank
      ! test_dims(2) = test_dims(2) + shp(2)
     ! print *, 'dims (sfter extending)  : ', test_dims(1:test_rank)
      ! call h5dextend_f( setID, test_dims, status)
      ! if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      !  & 'Unable to extend dims for 2D real array ' // trim(name) )
a3103 3
     ! print *, 'About to write'
      ! space defined for data
     ! print *, 'We received mem space (defined for data)', memspaceID
a3105 26
     ! call h5sis_simple_f ( memspaceID, test_issimple, status )
     ! call h5sget_simple_extent_ndims_f ( memspaceID, test_rank, status )
     ! call h5sget_simple_extent_dims_f ( memspaceID, test_dims(1:test_rank), &
     !   &  test_maxdims(1:test_rank), status )
     ! if ( status /= test_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
     !   & 'Unable to get dims for datset ' // trim(name) )
     ! call h5soffset_simple_f( memspaceID, test_offset(1:test_rank), status)
     ! print *, 'Is simple? ', test_issimple
     ! print *, 'rank    : ', test_rank
     ! print *, 'dims    : ', test_dims(1:test_rank)
     ! print *, 'max_dims: ', test_maxdims(1:test_rank)
     ! print *, 'offsets : ', test_offset(1:test_rank)
      ! space defined for file
     ! print *, 'We received file space', spaceID
     ! call h5sis_simple_f ( spaceID, test_issimple, status )
     ! call h5sget_simple_extent_ndims_f ( spaceID, test_rank, status )
     ! call h5sget_simple_extent_dims_f ( spaceID, test_dims(1:test_rank), &
     !   &  test_maxdims(1:test_rank), status )
     ! if ( status /= test_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
     !   & 'Unable to get dims for datset ' // trim(name) )
     ! call h5soffset_simple_f( spaceID, test_offset(1:test_rank), status)
     ! print *, 'Is simple? ', test_issimple
     ! print *, 'rank    : ', test_rank
     ! print *, 'dims    : ', test_dims(1:test_rank)
     ! print *, 'max_dims: ', test_maxdims(1:test_rank)
     ! print *, 'offsets : ', test_offset(1:test_rank)
d3121 1
a3153 4
    ! integer :: test_rank
    ! integer(hsize_t), dimension(7) :: test_dims, test_maxdims
    ! integer(hssize_t), dimension(7) :: test_offset
    ! logical :: test_issimple
d3156 1
a3201 3
      ! call h5screate_simple_f(3, dims, filespaceID, status, maxdims)
      ! if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      !  & 'Unable to create filespace for 3D real array ' // trim(name) )
a3236 12
      ! if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      !   & 'Unable to get dataspace for 3D real array ' // trim(name) )
      ! call h5sget_simple_extent_ndims_f ( spaceID, test_rank, status )
      ! if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      !   & 'Unable to get space rank for 3D real array ' // trim(name) )
      ! call h5sget_simple_extent_dims_f ( spaceID, test_dims(1:test_rank), &
      !  &  test_maxdims(1:test_rank), status )
      ! Can't test on status--it's set to the test_rank
      ! test_dims(test_rank) = test_dims(test_rank) + shp(test_rank)
      ! call h5dextend_f( setID, test_dims, status)
      ! if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      !   & 'Unable to extend dims for 3D real array ' // trim(name) )
d3271 1
d3306 1
d3420 1
d3444 1
d3451 1
d3475 1
d3482 1
d3506 1
d3513 1
d3536 1
d3543 1
d3566 1
d3573 1
d3595 1
d3598 1
d3622 1
d3629 1
d3653 1
d3660 1
d3684 1
d3691 1
d3715 1
d3722 1
d3746 1
d3753 1
d3777 1
d3784 1
d3808 1
d3815 1
d3844 1
d3878 1
d3907 1
d3941 1
d3968 1
d3990 1
d4016 1
d4038 1
d4064 1
d4086 1
d4108 1
d4111 1
d4138 1
d4160 1
d4187 1
d4209 1
d4236 1
d4258 1
d4285 1
d4307 1
d4334 1
d4356 1
d4383 1
d4405 1
d4432 1
d4454 1
d4476 1
d4498 1
d4518 1
d4537 1
d4557 1
d4572 1
d4590 1
d4602 1
d4619 1
d4628 1
d4648 1
d4663 1
d4681 1
d4693 1
d4711 1
d4724 1
d4744 1
d4759 1
d4777 1
d4789 1
d4807 1
d4820 1
d4838 1
d4852 1
d4866 1
d4874 1
d4887 1
d4894 1
d4904 1
d4910 1
d4922 1
d4929 1
d4956 1
a4956 1
      & call my_message ( MLSMSG_Error, ModuleName, &
d4989 1
d5075 1
d5112 2
d5137 1
d5148 2
d5164 1
d5177 2
d5198 1
d5212 2
d5225 1
d5247 1
d5295 1
d5323 1
d5366 1
d5391 1
d5425 1
d5549 2
d5569 1
d5602 1
a5602 1
       "$Id: MLSHDF5.f90,v 2.71 2007/01/26 23:59:13 pwagner Exp $"
d5611 3
@


2.71
log
@Added more unused debugging
@
text
@d24 1
a24 1
  use DUMP_0, only: DUMP, DUMP_NAME_V_PAIRS
d5310 1
a5310 1
        call dump_name_v_pairs ( ints, names, &
d5313 1
a5313 1
        call dump_name_v_pairs ( reals, names, &
d5316 1
a5316 1
        call dump_name_v_pairs ( doubles, names, &
d5448 1
a5448 1
       "$Id: MLSHDF5.f90,v 2.70 2007/01/12 00:29:28 pwagner Exp $"
d5457 3
@


2.70
log
@Renamed routine outputNamedValue
@
text
@a301 1
    ! character (len=*), intent(in) :: VALUE ! Value of attribute
d1491 1
d1494 1
d1501 1
d5448 1
a5448 1
       "$Id: MLSHDF5.f90,v 2.69 2006/08/23 18:04:23 pwagner Exp $"
d5457 3
@


2.69
log
@NAG hates splitting /) operator
@
text
@d62 1
a62 1
  use output_m, only: output, OUTPUT_NAME_V_PAIR
d385 1
a385 1
      if ( DEEBUG ) call output_name_v_pair ( 'groupName', groupName )
d391 1
a391 1
      if ( DEEBUG ) call output_name_v_pair ( 'DSName', DSName )
d394 1
a394 1
      if ( DEEBUG ) call output_name_v_pair ( 'locID', locID )
d404 2
a405 2
    if ( DEEBUG ) call output_name_v_pair ( 'myNames', myNames )
    if ( DEEBUG ) call output_name_v_pair ( 'numAttrs', numAttrs )
d407 1
a407 1
      if ( DEEBUG ) call output_name_v_pair ( 'i', i )
d410 1
a410 1
      if ( DEEBUG ) call output_name_v_pair ( 'name', name )
d423 8
a430 8
        call output_name_v_pair ( 'name', name )
        call output_name_v_pair ( 'attrID', attrID )
        call output_name_v_pair ( 'type_id', type_id )
        call output_name_v_pair ( 'type_size', type_size )
        call output_name_v_pair ( 'classID', classID )
        call output_name_v_pair ( 'H5T_STRING_F', H5T_STRING_F )
        call output_name_v_pair ( 'spaceID', spaceID )
        call output_name_v_pair ( 'rank', rank )
d439 2
a440 2
        call output_name_v_pair ( 'dims', dims )
        call output_name_v_pair ( 'Qtype', Qtype )
d526 8
a533 8
        call output_name_v_pair ( 'name', name )
        call output_name_v_pair ( 'ItemID', ItemID )
        call output_name_v_pair ( 'type_id', type_id )
        call output_name_v_pair ( 'type_size', type_size )
        call output_name_v_pair ( 'classID', classID )
        call output_name_v_pair ( 'H5T_STRING_F', H5T_STRING_F )
        call output_name_v_pair ( 'spaceID', spaceID )
        call output_name_v_pair ( 'rank', rank )
d542 2
a543 2
        call output_name_v_pair ( 'dims', dims )
        call output_name_v_pair ( 'Qtype', Qtype )
d673 1
a673 1
      ! call output_name_v_pair( 'groupName ', groupName )
d679 1
a679 1
      ! call output_name_v_pair( 'DSname ', DSname )
d690 1
a690 1
    ! call output_name_v_pair( 'num ', num )
d749 1
a749 1
    ! call output_name_v_pair( 'fileid', fileid )
d5446 1
a5446 1
       "$Id: MLSHDF5.f90,v 2.68 2006/08/22 20:41:23 pwagner Exp $"
d5455 3
@


2.68
log
@Fixed a bug in DumpHDF5Attributes
@
text
@d451 1
a451 1
        call dump ( (/ trim(chValue)/ ), trim(name) )
d5446 1
a5446 1
       "$Id: MLSHDF5.f90,v 2.67 2006/07/11 00:24:36 pwagner Exp $"
d5455 3
@


2.67
log
@use fillValue properly when computing rms etc.
@
text
@d31 1
a31 1
  use MLSStringLists, only: NumStringElements, StringElement
d359 2
a360 2
    character(len=1024) :: chValue ! len may become MAXCHFIELDLENGTH
    ! logical, parameter :: DEEBUG = .false.
d380 2
a381 1
      call h5gOpen_f ( locID, '/', itemID, status )
d385 1
d391 1
d394 8
a402 1
    if ( myNames == '*' ) call GetAllHDF5AttrNames ( itemID, myNames )
d404 2
d407 4
a410 1
      name = StringElement(myNames, i, countEmpty)
d451 1
a451 1
        call dump ( trim(chValue), trim(name) )
d5446 1
a5446 1
       "$Id: MLSHDF5.f90,v 2.66 2006/06/29 20:38:20 pwagner Exp $"
d5455 3
@


2.66
log
@Added a few extra error checks
@
text
@d30 1
d118 1
a118 1
!    [log stats], [log rms])
d457 1
a457 1
  subroutine DumpHDF5DS ( locID, groupName, names, stats, rms )
d463 1
d536 5
a540 1
          call dump ( iValue, trim(name), stats=stats, rms=rms )
d545 5
a549 1
          call dump ( iValue(:,:,1), trim(name), stats=stats, rms=rms )
d554 5
a558 1
          call dump ( iValue(:,1,1), trim(name), stats=stats, rms=rms )
d566 5
a570 1
          call dump ( dValue, trim(name), stats=stats, rms=rms )
d575 5
a579 1
          call dump ( dValue(:,:,1), trim(name), stats=stats, rms=rms )
d584 5
a588 1
          call dump ( dValue(:,1,1), trim(name), stats=stats, rms=rms )
d5431 1
a5431 1
       "$Id: MLSHDF5.f90,v 2.65 2006/06/27 23:59:05 pwagner Exp $"
d5440 3
@


2.65
log
@May dump attributes, datasets
@
text
@d380 3
d385 3
d444 3
d449 3
d491 4
a494 1
    call h5gOpen_f ( locid, '/', groupID, status )
d600 3
d631 5
a635 1
      call h5gOpen_f ( locID, '/', itemID, status )
d638 4
d646 1
a646 1
    ! print *, 'About to read num of attributes'
d649 1
a649 1
    ! print *, 'num ', num
d665 3
d670 3
d708 2
d5405 1
a5405 1
       "$Id: MLSHDF5.f90,v 2.64 2006/04/12 20:51:24 pwagner Exp $"
d5414 3
@


2.64
log
@Attempts to work around hdf5-1.6.5 bugs rewriting string attributes
@
text
@d23 1
d30 1
d38 1
a38 1
    & H5T_IEEE_F32LE, H5T_IEEE_F64LE, &
d40 1
a40 1
    & H5T_NATIVE_CHARACTER, H5T_NATIVE_INTEGER, H5T_STRING, &
d45 1
a45 1
    & H5AGET_TYPE_F, H5AOPEN_IDX_F, H5AOPEN_NAME_F, &
d57 2
a58 1
    & H5TCLOSE_F, H5TCOPY_F, H5TEQUAL_F, H5TGET_SIZE_F, H5TSET_SIZE_F
d61 1
d67 1
d90 2
d114 4
d262 1
d267 1
d344 243
d588 3
a590 2
  subroutine GetAllHDF5AttrNames ( itemID, names )
    ! Get all attribute names attributes of itemID
d592 1
a592 1
    integer, intent(in)            :: itemID ! attributes of what
d594 2
d600 1
d612 7
d637 5
d646 1
a646 1

d2070 1
a2070 14
    if ( AreThe2TypesEqual(type_id, H5T_STD_I32LE) .or. &
      &  AreThe2TypesEqual(type_id, H5T_STD_I32LE) ) then
      Qtype = 'integer'
    else if ( AreThe2TypesEqual(type_id, H5T_NATIVE_CHARACTER) ) then
      Qtype = 'character'
    else if ( AreThe2TypesEqual(type_id, H5T_STRING) ) then
      Qtype = 'character'
    else if ( AreThe2TypesEqual(type_id, H5T_NATIVE_REAL) .or. &
      &      AreThe2TypesEqual(type_id, H5T_IEEE_F32LE) ) then
      Qtype = 'real'
    else if ( AreThe2TypesEqual(type_id, H5T_NATIVE_DOUBLE) .or. &
      &      AreThe2TypesEqual(type_id, H5T_IEEE_F64LE) ) then
      Qtype = 'double'
    end if
d5341 27
d5371 1
a5371 1
       "$Id: MLSHDF5.f90,v 2.63 2006/01/25 00:57:39 pwagner Exp $"
d5380 3
@


2.63
log
@Removed some troublesome, superfluous calls from IsHDF5ItemPresent
@
text
@d566 1
a566 1
   & skip_if_already_there )
d570 2
a571 1
    logical, intent(in), optional :: skip_if_already_there
d578 1
d581 1
d586 2
d595 5
a599 1
    call h5tset_size_f(stringtype, max(len_trim(value), 1), status )
d606 2
a607 5
    ! print *, 'itemID: ', itemID
    ! print *, 'stringtype: ', stringtype
    ! print *, 'dsID: ', dsID
    ! print *, 'name: ', trim(name)
    if ( is_present ) then
d615 15
a629 3
    call h5aCreate_f ( itemID, trim(name), stringtype, dsID, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create attribute ' // trim(name) )
d640 1
a640 1
    if ( .not. is_present ) then
d5085 1
a5085 1
       "$Id: MLSHDF5.f90,v 2.62 2005/11/17 20:09:24 pwagner Exp $"
d5094 3
@


2.62
log
@LoadFromHDF5DS can now read 3d integer arrays
@
text
@a2085 1
    ! print *, 'myOptions ', myOptions
a2089 2
      call GetAllHDF5DSNames_fileID ( locID, '/', DSNames )
      ! print *, 'DSNames ', trim(DSNames)
d5067 1
a5067 1
       "$Id: MLSHDF5.f90,v 2.61 2005/11/11 21:36:00 pwagner Exp $"
d5076 3
@


2.61
log
@Added new interface for IsHDF5AttributeInFile when attached to grp, not dataset
@
text
@d38 1
a38 1
    & H5T_NATIVE_CHARACTER, H5T_NATIVE_INTEGER, &
d206 1
a206 1
      & LdFrmHDF5DS_ID_logarr1, &
d212 1
a212 1
      & LoadFromHDF5DS_logarr1, &
d1785 2
d3140 28
d3609 46
d5070 1
a5070 1
       "$Id: MLSHDF5.f90,v 2.60 2005/10/28 23:13:42 pwagner Exp $"
d5079 3
@


2.60
log
@Prevent ref to undefined num in GetAllHDF5AttrNames
@
text
@d117 1
d159 12
a174 11
  interface MakeHDF5Attribute
    module procedure MakeHDF5Attribute_dbl, MakeHDF5Attribute_sngl, &
      & MakeHDF5Attribute_int, MakeHDF5Attribute_logical, &
      & MakeHDF5Attribute_logicalarr1, &
      & MakeHDF5Attribute_string, MakeHDF5Attribute_snglarr1, &
      & MakeHDF5Attribute_dblarr1, MakeHDF5Attribute_stringarr1, &
      & MakeHDF5Attribute_intarr1, MakeHDF5AttributeDSN_int, &
      & MakeHDF5AttributeDSN_string, MakeHDF5AttributeDSN_snglarr1, &
      & MakeHDF5AttributeDSN_st_arr1, MakeHDF5AttributeDSN_dblarr1
  end interface

d194 3
a196 10
  interface CpHDF5Attribute
    ! module procedure CpHDF5Attribute_int, CpHDF5Attribute_logical
    module procedure CpHDF5Attribute_string
    ! module procedure CpHDF5Attribute_sngl, CpHDF5Attribute_dbl
    ! module procedure CpHDF5Attribute_snglarr1, CpHDF5Attribute_intarr1
    ! module procedure CpHDF5Attribut _dblarr1, CpHDF5Attribute_stringarr1
  end interface

  interface CpHDF5GlAttribute
    module procedure CpHDF5GlAttribute_string
a203 10
  interface SaveAsHDF5DS
    module procedure &
      & SaveAsHDF5DS_intarr1, SaveAsHDF5DS_intarr2, SaveAsHDF5DS_intarr3, &
      & SaveAsHDF5DS_logarr1, &
      & SaveAsHDF5DS_dblarr1, SaveAsHDF5DS_dblarr2, SaveAsHDF5DS_dblarr3, &
      & SaveAsHDF5DS_snglarr1, SaveAsHDF5DS_snglarr2, SaveAsHDF5DS_snglarr3, &
      & SaveAsHDF5DS_snglarr4, &
      & SaveAsHDF5DS_charsclr, SaveAsHDF5DS_chararr1, SaveAsHDF5DS_chararr2
  end interface

d228 21
d1798 3
a1800 2
  ! --------------------------------------  IsHDF5AttributeInFile  -----
  logical function IsHDF5AttributeInFile ( filename, DSname, name )
d1802 2
d1807 1
d1815 1
a1815 1
    IsHDF5AttributeInFile = .false.
d1825 1
a1825 1
          IsHDF5AttributeInFile = .true.
d1835 40
a1874 1
  end function IsHDF5AttributeInFile
d4994 1
a4994 1
       "$Id: MLSHDF5.f90,v 2.59 2005/10/19 20:46:05 pwagner Exp $"
d5003 3
@


2.59
log
@GetAllHDF5DSNames will omit leading slashes by default
@
text
@d349 1
d4945 1
a4945 1
       "$Id: MLSHDF5.f90,v 2.58 2005/10/18 23:01:43 pwagner Exp $"
d4954 3
@


2.58
log
@Added GetAllHDF5AttrNames, IsHDF5ItemPresent; introduced options
@
text
@d369 1
a369 1
  subroutine GetAllHDF5DSNames_fileID ( FileID, gname, DSNames )
d374 1
d378 1
d383 2
d402 2
d408 2
d420 1
a420 1
  subroutine GetAllHDF5DSNames_filename ( FileName, gname, DSNames )
d424 1
d437 1
a437 1
      call GetAllHDF5DSNames_fileID ( fileID, gname, DSNames )
d2035 1
a2035 1
    if ( myOptions == ' ' ) then
d2039 2
d4944 1
a4944 1
       "$Id: MLSHDF5.f90,v 2.57 2005/10/11 17:35:00 pwagner Exp $"
d4953 3
@


2.57
log
@MLSFile interface to GetHDF5Attribute can get attribute from grp_id component if sd_id is 0
@
text
@d41 3
a43 1
  use HDF5, only: H5ACLOSE_F, H5ACREATE_F, H5AGET_TYPE_F, H5AOPEN_NAME_F, &
d57 1
a57 1
  use MLSStringLists, only: catLists
d63 1
d65 1
a65 1
    & GetAllHDF5DSNames, GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType, &
d67 1
a67 1
    & IsHDF5DSPresent, IsHDF5GroupPresent, &
d85 1
d107 1
d120 1
a120 1
! log IsHDF5DSPresent (int locID, char name)
d122 1
d146 11
d325 43
d1949 1
a1949 1
  logical function IsHDF5DSPresent ( locID, name )
d1951 1
d1954 1
d1956 2
d1962 2
d1967 11
a1977 3
    call h5dOpen_f ( locID, name, setID, status )
    IsHDF5DSPresent = status == 0
    if ( IsHDF5DSPresent ) call h5dClose_f ( setID, status )
d2004 42
d4933 1
a4933 1
       "$Id: MLSHDF5.f90,v 2.56 2005/07/12 17:12:50 pwagner Exp $"
d4942 3
@


2.56
log
@New hdf5 library will drop integer dimension interfaces
@
text
@d32 1
a32 1
  use HDF5, only: H5F_ACC_RDONLY_F, &
d131 1
a131 1
! The following may alsso be called with the int itemID or locID arg replaced
d134 3
d297 1
a297 1
    call h5fopen_f ( trim(toFilename), H5F_ACC_RDONLY_F, toFileID, status )
d867 9
a875 1
    call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
d905 9
a913 1
    call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
d944 9
a952 1
    call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
d998 9
a1006 1
    call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
d1049 10
a1058 1
    call GetHDF5Attribute ( MLSFile%fileID%sd_ID, name, iValue )
d1072 9
a1080 1
    call GetHDF5Attribute ( MLSFile%fileID%sd_ID, name, iValue )
d1097 9
a1105 1
    call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
d1134 9
a1142 1
    call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
d1170 9
a1178 1
    call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
d1208 9
a1216 1
    call h5aOpen_name_f ( MLSFile%fileID%sd_ID, name, attrID, status )
d4817 1
a4817 1
       "$Id: MLSHDF5.f90,v 2.55 2005/06/29 00:40:48 pwagner Exp $"
d4826 3
@


2.55
log
@New interfaces for GetHDF5Attribute and LoadFromHDF5DS accept MLSFiles
@
text
@d224 1
a224 1
  integer, dimension(7) :: ones = (/1,1,1,1,1,1,1/)
d567 1
a567 1
    integer, dimension(1) :: SHP        ! Shape
d610 1
a610 1
    integer, dimension(1) :: SHP        ! Shape
d619 1
a619 1
        & int ( (/ shp, ones(1:6) /), hID_T ), status )
d636 1
a636 1
    integer, dimension(1) :: SHP        ! Shape
d645 1
a645 1
        & int ( (/ shp, ones(1:6) /), hID_T ), status )
d662 1
a662 1
    integer, dimension(1) :: SHP        ! Shape
d671 1
a671 1
        & int ( (/ shp, ones(1:6) /), hID_T ), status )
d890 1
a890 1
    integer, dimension(1) :: SHP        ! Shape
d902 1
a902 1
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
d967 1
a967 1
    integer, dimension(1) :: SHP        ! Shape
d990 1
a990 1
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
d1041 1
a1041 1
    integer, dimension(1) :: SHP        ! Shape
d1053 1
a1053 1
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
d1128 1
a1128 1
    integer, dimension(1) :: SHP        ! Shape
d1140 1
a1140 1
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
d1357 1
a1357 1
      & (/ int(shp,hid_t), int(ones(1:6),hid_t) /), status )
d1402 1
a1402 1
      & (/ int(shp,hid_t), int(ones(1:6),hid_t) /), status )
d1458 1
a1458 1
      & (/ int(shp,hid_t), int(ones(1:6),hid_t) /), status )
d1493 1
a1493 1
      & (/ int(shp,hid_t), int(ones(1:6),hid_t) /), status )
d1857 1
a1857 1
    integer, dimension(1) :: SHP        ! Shape
d1877 1
a1877 1
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
d1896 1
a1896 1
    integer, dimension(1) :: SHP, MAXDIMS        ! Shape
d1934 1
a1934 1
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
d1953 1
a1953 1
    integer, dimension(2) :: SHP, MAXDIMS        ! Shape
d1991 1
a1991 1
      & int ( (/ shp, ones(1:5) /), hID_T ), status )
d2010 1
a2010 1
    integer, dimension(1) :: SHP, MAXDIMS        ! Shape
d2023 1
a2023 1
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
d2042 1
a2042 1
    integer, dimension(2) :: SHP, MAXDIMS        ! Shape
d2055 1
a2055 1
      & int ( (/ shp, ones(1:5) /), hID_T ), status )
d2074 1
a2074 1
    integer, dimension(3) :: SHP, MAXDIMS        ! Shape
d2087 1
a2087 1
      & int ( (/ shp, ones(1:4) /), hID_T ), status )
d2135 1
a2135 1
    integer, dimension(1) :: SHP, MAXDIMS        ! Shape
d2148 1
a2148 1
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
d2167 1
a2167 1
    integer, dimension(2) :: SHP, MAXDIMS        ! Shape
d2180 1
a2180 1
      & int ( (/ shp, ones(1:5) /), hID_T ), status )
d2199 1
a2199 1
    integer, dimension(3) :: SHP, MAXDIMS        ! Shape
d2212 1
a2212 1
      & int ( (/ shp, ones(1:4) /), hID_T ), status )
d2231 1
a2231 1
    integer, dimension(1) :: SHP, MAXDIMS        ! Shape
d2244 1
a2244 1
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
d2276 1
a2276 1
    integer, dimension(2) :: SHP        ! Shape
d2324 1
a2324 1
      dims(2) = max(1, shp(2))
d2397 1
a2397 1
      call mls_extend ( setID, Count, start, filespaceID )
d2432 1
a2432 1
        & int ( (/ shp, ones(1:5) /), hID_T ), status, &
d2439 1
a2439 1
        & int ( (/ shp, ones(1:5) /), hID_T ), status )
d2476 1
a2476 1
    integer, dimension(3) :: SHP        ! Shape
d2523 1
a2523 1
      dims(3) = max(1, shp(3))
d2591 1
a2591 1
      call mls_extend ( setID, Count, start, filespaceID )
d2600 1
a2600 1
        & int ( (/ shp, ones(1:4) /), hID_T ), status, &
d2606 1
a2606 1
        & int ( (/ shp, ones(1:4) /), hID_T ), status )
d2643 1
a2643 1
    integer, dimension(4) :: SHP        ! Shape
d2686 1
a2686 1
      dims(4) = max(1, shp(4))
d2738 1
a2738 1
      call mls_extend ( setID, Count, start, filespaceID )
d2747 1
a2747 1
        & int ( (/ shp, ones(1:3) /), hID_T ), status, &
d2753 1
a2753 1
        & int ( (/ shp, ones(1:3) /), hID_T ), status )
d3121 1
a3121 1
    integer, dimension(1) :: SHP        ! Shape of value
d3182 1
a3182 1
    integer, dimension(2) :: SHP        ! Shape of value
d3243 1
a3243 1
    integer, dimension(1) :: SHP        ! Shape of value
d3289 1
a3289 1
    integer, dimension(2) :: SHP        ! Shape of value
d3359 1
a3359 1
    integer, dimension(1) :: SHP        ! Shape of value
d3406 1
a3406 1
    integer, dimension(2) :: SHP        ! Shape of value
d3453 1
a3453 1
    integer, dimension(3) :: SHP        ! Shape of value
d3500 1
a3500 1
    integer, dimension(1) :: SHP        ! Shape of value
d3547 1
a3547 1
    integer, dimension(2) :: SHP        ! Shape of value
d3594 1
a3594 1
    integer, dimension(3) :: SHP        ! Shape of value
d3641 1
a3641 1
    integer, dimension(4) :: SHP        ! Shape of value
d3708 1
a3708 1
    call h5dread_f ( setID, stringtype, value, (/ int(shp(1)), ones(1:6) /), status )
d3745 1
a3745 1
   call h5dread_f ( setID, stringtype, value, (/ int(shp), ones(1:5) /), status )
d3778 1
a3778 1
      & (/ int(shp), ones(1:6) /), status )
d3806 1
a3806 1
      & (/ int(shp), ones(1:5) /), status )
d3863 1
a3863 1
      & (/ int(shp), ones(1:6) /), status )
d3891 1
a3891 1
      & (/ int(shp), ones(1:5) /), status )
d3920 1
a3920 1
      & (/ int(shp), ones(1:4) /), status )
d3953 1
a3953 1
      & (/ int(shp), ones(1:6) /), status )
d3981 1
a3981 1
      & (/ int(shp), ones(1:5) /), status )
d4010 1
a4010 1
      & (/ int(shp), ones(1:4) /), status )
d4040 1
a4040 1
      & (/ int(shp), ones(1:3) /), status )
d4131 1
a4131 1
    integer, dimension(:), intent(in) :: value_dims
d4139 1
a4139 1
      & 'dims(space), dims(value)', (/ (int(dims(i)), value_dims(i), i=1, size(dims)) /), &
d4149 1
a4149 1
    integer, dimension(:), intent(in) :: maxdims
d4401 1
a4401 1
    integer, dimension(:), intent(in)  :: newCount
d4473 1
a4473 1
    integer, dimension(:), intent(in)  :: value_dims
d4706 1
a4706 1
    integer, intent(in), optional :: Shp(:) ! Shape of array attrib, else scalar
d4733 1
a4733 1
       "$Id: MLSHDF5.f90,v 2.54 2005/06/22 17:25:49 pwagner Exp $"
d4742 3
@


2.54
log
@Reworded Copyright statement, moved rcs id
@
text
@d24 3
d28 1
d72 1
a72 1
       "$RCSfile: $"
d130 7
d159 5
d200 6
d854 2
a855 2
  subroutine GetHDF5Attribute_int ( itemID, name, value )
    integer, intent(in) :: ITEMID         ! Group etc. to get attribute from
d864 1
a864 1
    call h5aOpen_name_f ( itemID, name, attrID, status )
d866 2
a867 1
      & 'Unable to open attribute ' // trim(name) )
d873 2
a874 1
      & 'Unable to read attribute ' // trim(name) )
d877 2
a878 1
      & 'Unable to close attribute ' // trim(name) )
d882 2
a883 2
  subroutine GetHDF5Attribute_intarr1 ( itemID, name, value )
    integer, intent(in) :: ITEMID         ! Group etc. to get attribute from
d894 1
a894 1
    call h5aOpen_name_f ( itemID, name, attrID, status )
d896 2
a897 1
      & 'Unable to open attribute ' // trim(name) )
d904 2
a905 1
      & 'Unable to read attribute ' // trim(name) )
d908 2
a909 1
      & 'Unable to close attribute ' // trim(name) )
a911 35
  ! --------------------------------  GetHDF5AttributePtr_intarr1  -----
  subroutine GetHDF5AttributePtr_intarr1 ( itemID, name, value, LowBound )
    ! Allocate Value and read attribute Name into it
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: ITEMID         ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    integer, pointer :: VALUE(:)          ! Result
    integer, intent(in), optional :: LowBound ! of allocated value, else 1

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: LB                       ! 1, else LowBound
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP  ! Shape

    ! Executable code
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    call GetHDF5AttrDims ( itemID, trim(name), shp, maxShp )
    call allocate_test ( value, int(lb-1+maxShp(1)), 'Value', moduleName )
    call h5aOpen_name_f ( itemID, name, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name) )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read an array into our one value.
    call h5aread_f ( attrID, H5T_NATIVE_INTEGER, value, &
      & (/ int(shp,hid_t), int(ones(1:6),hid_t) /), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read attribute ' // trim(name) )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name) )
  end subroutine GetHDF5AttributePtr_intarr1

d913 2
a914 2
  subroutine GetHDF5Attribute_string ( itemID, name, value )
    integer, intent(in) :: ITEMID           ! Group etc. to get attribute from
d925 1
a925 1
    call h5aOpen_name_f ( itemID, name, attrID, status )
d927 2
a928 1
      & 'Unable to open attribute ' // trim(name) )
d931 2
a932 1
      & 'Unable to get type for attribute ' // trim(name) )
d935 2
a936 1
      & 'Unable to get size for attribute ' // trim(name) )
d938 2
a939 1
      & 'Value too long to fit in space given for attribute ' // trim(name) )
d944 2
a945 1
      & 'Unable to read attribute ' // trim(name) )
d948 2
a949 1
      & 'Unable to close attribute ' // trim(name) )
d952 2
a953 1
      & 'Unable to close string type for attribute ' // trim(name) )
d957 2
a958 2
  subroutine GetHDF5Attribute_stringarr1 ( itemID, name, value )
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
d971 1
a971 1
    call h5aOpen_name_f ( itemID, name, attrID, status )
d973 2
a974 1
      & 'Unable to open attribute ' // trim(name) )
d977 2
a978 1
      & 'Unable to get type for 1-d string attribute ' // trim(name) )
d981 2
a982 1
      & 'Unable to get size for 1-d string attribute ' // trim(name) )
d984 2
a985 1
      & 'Value too long to fit in space given for attribute ' // trim(name) )
d992 2
a993 1
      & 'Unable to read attribute ' // trim(name) )
d996 2
a997 1
      & 'Unable to close attribute ' // trim(name) )
d1000 2
a1001 1
      & 'Unable to close string type for attribute ' // trim(name) )
a1003 48
  ! -----------------------------  GetHDF5AttributePtr_stringarr1  -----
  subroutine GetHDF5AttributePtr_stringarr1 ( itemID, name, value, LowBound )
    ! Allocate Value and read attribute Name into it
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: ITEMID          ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME  ! Name of attribute
    character (len=*), pointer :: VALUE(:) ! Result
    integer, intent(in), optional :: LowBound ! of allocated value, else 1

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: LB                       ! 1, else LowBound
    integer :: STATUS                   ! Flag from HDF5
    integer :: STRINGTYPE               ! String type
    integer :: STRINGSIZE               ! String size
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP ! Shape

    ! Executable code
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    call GetHDF5AttrDims ( itemID, trim(name), shp, maxShp )
    call allocate_test ( value, int(lb-1+maxShp(1)), 'Value', moduleName )
    call h5aOpen_name_f ( itemID, name, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name) )
    call h5aGet_type_f ( attrID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 1-d string attribute ' // trim(name) )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for 1-d string attribute ' // trim(name) )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for attribute ' // trim(name) )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read an array into our one value.
    call h5aread_f ( attrID, stringType, value, &
      & (/ int(shp,hid_t), int(ones(1:6),hid_t) /), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read attribute ' // trim(name) )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute ' // trim(name) )
    call h5tClose_f ( stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close string type for attribute ' // trim(name) )
  end subroutine GetHDF5AttributePtr_stringarr1

d1005 2
a1006 2
  subroutine GetHDF5Attribute_logical ( itemID, name, value )
    integer, intent(in) :: ITEMID         ! Group etc. to get attr to.
d1014 1
a1014 1
    call GetHDF5Attribute ( itemID, name, iValue )
d1019 2
a1020 2
  subroutine GetHDF5Attribute_logicalarr1 ( itemID, name, value )
    integer, intent(in) :: ITEMID         ! Group etc. to get attr to.
d1028 1
a1028 1
    call GetHDF5Attribute ( itemID, name, iValue )
a1031 18
  ! ----------------------------  GetHDF5AttributePtr_logicalarr1  -----
  subroutine GetHDF5AttributePtr_logicalarr1 ( itemID, name, value, LowBound )
    use Allocate_Deallocate, only: Deallocate_Test
    integer, intent(in) :: ITEMID         ! Group etc. to get attr to.
    character (len=*), intent(in) :: NAME ! Name of attribute
    logical, pointer :: VALUE(:)          ! Value of attribute
    integer, intent(in), optional :: LowBound ! of allocated value, else 1

    ! Local variables
    integer, pointer :: IVALUE(:)         ! Value as integer

    ! Executable code
    nullify ( ivalue )
    call GetHDF5AttributePtr ( itemID, name, iValue, lowBound )
    value = ( iValue == 1 )
    call deallocate_test ( ivalue, 'IValue', moduleName )
  end subroutine GetHDF5AttributePtr_logicalarr1

d1033 2
a1034 2
  subroutine GetHDF5Attribute_snglarr1 ( itemID, name, value )
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
d1045 1
a1045 1
    call h5aOpen_name_f ( itemID, name, attrID, status )
d1047 2
a1048 1
      & 'Unable to open attribute ' // trim(name) )
d1055 2
a1056 1
      & 'Unable to read 1d attribute array ' // trim(name) )
d1059 2
a1060 1
      & 'Unable to close 1d attribute array  ' // trim(name) )
a1062 35
  ! -------------------------------  GetHDF5AttributePtr_snglarr1  -----
  subroutine GetHDF5AttributePtr_snglarr1 ( itemID, name, value, LowBound )
    ! Allocate Value and read attribute Name into it
    use Allocate_Deallocate, only: Allocate_Test
    integer, intent(in) :: ITEMID         ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    real, pointer :: VALUE(:)             ! The attribute array result
    integer, intent(in), optional :: LowBound ! of allocated value, else 1

    ! Local variables
    integer :: ATTRID                   ! ID for attribute
    integer :: LB                       ! 1, else LowBound
    integer :: STATUS                   ! Flag from HDF5
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP  ! Shape

    ! Executable code
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    call GetHDF5AttrDims ( itemID, trim(name), shp, maxShp )
    call allocate_test ( value, int(lb-1+maxShp(1)), 'Value', moduleName )
    call h5aOpen_name_f ( itemID, name, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name) )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read too big array into ours.
    call h5aread_f ( attrID, H5T_NATIVE_REAL, value, &
      & (/ int(shp,hid_t), int(ones(1:6),hid_t) /), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read 1d attribute array ' // trim(name) )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close 1d attribute array  ' // trim(name) )
  end subroutine GetHDF5AttributePtr_snglarr1

d1064 2
a1065 2
  subroutine GetHDF5Attribute_sngl ( itemID, name, value )
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
d1074 1
a1074 1
    call h5aOpen_name_f ( itemID, name, attrID, status )
d1076 2
a1077 1
      & 'Unable to open attribute ' // trim(name) )
d1084 2
a1085 1
      & 'Unable to read sngl attribute ' // trim(name) )
d1092 2
a1093 2
  subroutine GetHDF5Attribute_dbl ( itemID, name, value )
    integer, intent(in) :: ITEMID          ! Group etc. to get attribute from
d1102 1
a1102 1
    call h5aOpen_name_f ( itemID, name, attrID, status )
d1104 2
a1105 1
      & 'Unable to open attribute ' // trim(name) )
d1111 2
a1112 1
      & 'Unable to read dble attribute ' // trim(name) )
d1115 2
a1116 1
      & 'Unable to close dble attribute  ' // trim(name) )
d1120 2
a1121 2
  subroutine GetHDF5Attribute_dblarr1 ( itemID, name, value )
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
d1132 1
a1132 1
    call h5aOpen_name_f ( itemID, name, attrID, status )
d1134 2
a1135 1
      & 'Unable to open attribute ' // trim(name) )
d1142 2
a1143 1
      & 'Unable to read dblarr1 attribute ' // trim(name) )
d1146 2
a1147 1
      & 'Unable to close dblarr1 attribute  ' // trim(name) )
d1150 2
a1151 4
  ! ---------------------------------  GetHDF5AttributePtr_dblarr1  -----
  subroutine GetHDF5AttributePtr_dblarr1 ( itemID, name, value, LowBound )
    ! Allocate Value and read attribute Name into it
    use Allocate_Deallocate, only: Allocate_Test
d1154 1
a1154 2
    double precision, pointer :: VALUE(:) ! The attribute result
    integer, intent(in), optional :: LowBound ! of allocated value, else 1
a1156 2
    integer :: ATTRID                   ! ID for attribute
    integer :: LB                       ! 1, else LowBound
d1158 1
a1158 1
    integer(kind=hSize_t), dimension(1) :: MaxShp, SHP  ! Shape
d1161 6
a1166 18
    lb = 1
    if ( present(lowBound) ) lb = lowBound
    call GetHDF5AttrDims ( itemID, trim(name), shp, maxShp )
    call allocate_test ( value, int(lb-1+maxShp(1)), 'Value', moduleName )
    call h5aOpen_name_f ( itemID, name, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open attribute ' // trim(name) )
    ! Note we're going to assume here that the attribute indeed represents the
    ! right type, and that we won't overflow memory etc. by accidentally trying
    ! to read too big array into ours.
    call h5aread_f ( attrID, H5T_NATIVE_DOUBLE, value, &
      & (/ int(shp,hid_t), int(ones(1:6),hid_t) /), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read dblarr1 attribute ' // trim(name) )
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dblarr1 attribute  ' // trim(name) )
  end subroutine GetHDF5AttributePtr_dblarr1
d1168 5
a1172 6
  ! --------------------------------------------  GetHDF5AttrDims  -----
  subroutine GetHDF5AttrDims ( ItemID, name, DIMS, maxDims )
    integer, intent(in) :: ItemID         ! ItemID
    character (len=*), intent(in) :: NAME ! Name of DS
    integer(kind=hSize_t), dimension(:), intent(out) :: DIMS ! Values of dimensions
    integer(kind=hSize_t), dimension(:), optional, intent(out) :: MAXDIMS ! max Values
d1175 2
a1176 5
    integer :: dspace_id                ! spaceID for Attr
    integer(kind=hSize_t), dimension(:), pointer :: maxdims_ptr
    integer :: my_rank, rank
    integer :: AttrID                   ! ID for Attr
    integer :: STATUS                   ! Flag
d1179 16
a1194 22
    ! Initializing values returned if there was trouble
    dims = -1
    if ( present(maxDims)) maxDims = -1
    call h5eSet_auto_f ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before getting dims of ' // trim(name) )
    call h5aOpen_name_f ( itemID, trim(name), attrID, status )
    call h5dget_space_f ( attrID, dspace_id, status )
    call h5sget_simple_extent_ndims_f ( dspace_id, rank, status )
    my_rank = min(rank, size(dims))
    allocate ( maxdims_ptr(my_rank) )
    call h5sget_simple_extent_dims_f ( dspace_id, dims(1:my_rank), &
         maxdims_ptr, status )
    if ( status /= my_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dims for datset ' // trim(name) )
    call h5aClose_f ( attrID, status )
    if ( present(maxDims) ) maxdims = maxdims_ptr(1:my_rank)
    deallocate ( maxdims_ptr )
    call h5eSet_auto_f ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after getting dims of ' // trim(name) )
  end subroutine GetHDF5AttrDims
d1196 13
a1208 6
  ! ----------------------------------------------  GetHDF5DSDims  -----
  subroutine GetHDF5DSDims ( FileID, name, DIMS, maxDims )
    integer, intent(in) :: FILEID         ! fileID
    character (len=*), intent(in) :: NAME ! Name of DS
    integer(kind=hSize_t), dimension(:), intent(out) :: DIMS ! Values of dimensions
    integer(kind=hSize_t), dimension(:), optional, intent(out) :: MAXDIMS ! max Values
d1211 2
a1212 5
    integer :: dspace_id                ! spaceID for DS
    integer(kind=hSize_t), dimension(:), pointer :: maxdims_ptr
    integer :: my_rank, rank
    integer :: SETID                    ! ID for DS
    integer :: STATUS                   ! Flag
d1215 6
a1220 22
    ! Initializing values returned if there was trouble
    dims = -1
    if ( present(maxDims)) maxDims = -1
    call h5eSet_auto_f ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before getting dims ' // trim(name) )
    call h5dOpen_f ( FileID, trim(name), setID, status )
    call h5dget_space_f ( setID, dspace_id, status )
    call h5sget_simple_extent_ndims_f ( dspace_id, rank, status )
    my_rank = min(rank, size(dims))
    allocate ( maxdims_ptr(my_rank) )
    call h5sget_simple_extent_dims_f ( dspace_id, dims(1:my_rank), &
         maxdims_ptr, status )
    if ( status /= my_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dims for datset ' // trim(name) )
    call h5dClose_f ( setID, status )
    if ( present(maxDims) ) maxdims = maxdims_ptr
    deallocate ( maxdims_ptr )
    call h5eSet_auto_f ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after getting dims ' // trim(name) )
  end subroutine GetHDF5DSDims
d1222 5
a1226 5
  ! ----------------------------------------------  GetHDF5DSRank  -----
  subroutine GetHDF5DSRank ( FileID, name, rank )
    integer, intent(in) :: FILEID       ! fileID
    character (len=*), intent(in) :: NAME ! Name of DS
    integer, intent(out) :: rank        ! How many dimensions
d1229 2
a1230 3
    integer :: dspace_id                ! spaceID for DS
    integer :: SETID                    ! ID for DS
    integer :: STATUS                   ! Flag
d1233 6
a1238 12
    rank = -1                           ! means trouble
    call h5eSet_auto_f ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before getting rank ' // trim(name) )
    call h5dOpen_f ( FileID, trim(name), setID, status )
    call h5dget_space_f(setID,dspace_id,status)
    call h5sget_simple_extent_ndims_f(dspace_id,rank,status)
    call h5dClose_f ( setID, status )
    call h5eSet_auto_f ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after getting rank ' // trim(name) )
  end subroutine GetHDF5DSRank
d1240 5
a1244 5
  ! ---------------------------------------------  GetHDF5DSQType  -----
  subroutine GetHDF5DSQType ( FileID, name, Qtype )
    integer, intent(in) :: FILEID       ! fileID
    character (len=*), intent(in) :: NAME ! Name of DS
    character (len=*), intent(out) :: Qtype    ! 'real' or 'integer' or ..
d1247 2
a1248 3
    integer :: type_id                  ! typeID for DS
    integer :: SETID                    ! ID for DS
    integer :: STATUS                   ! Flag
d1251 12
a1262 23
    Qtype = 'unknown'                   ! means trouble
    call h5eSet_auto_f ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before getting rank ' // trim(name) )
    call h5dOpen_f ( FileID, trim(name), setID, status )
    call h5dget_type_f(setID,type_id,status)
    if ( AreThe2TypesEqual(type_id, H5T_STD_I32LE) .or. &
      &  AreThe2TypesEqual(type_id, H5T_STD_I32LE) ) then
      Qtype = 'integer'
    else if ( AreThe2TypesEqual(type_id, H5T_NATIVE_CHARACTER) ) then
      Qtype = 'character'
    else if ( AreThe2TypesEqual(type_id, H5T_NATIVE_REAL) .or. &
      &      AreThe2TypesEqual(type_id, H5T_IEEE_F32LE) ) then
      Qtype = 'real'
    else if ( AreThe2TypesEqual(type_id, H5T_NATIVE_DOUBLE) .or. &
      &      AreThe2TypesEqual(type_id, H5T_IEEE_F64LE) ) then
      Qtype = 'double'
    end if
    call h5dClose_f ( setID, status )
    call h5eSet_auto_f ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after getting rank ' // trim(name))
  end subroutine GetHDF5DSQType
a1263 6
  ! --------------------------------------  IsHDF5AttributeInFile  -----
  logical function IsHDF5AttributeInFile ( filename, DSname, name )
    ! This routine returns true if the given HDF5 DS is present
    character (len=*), intent(in) :: FILENAME ! Where to look
    character (len=*), intent(in) :: DSNAME ! Name for the dataset
    character (len=*), intent(in) :: NAME ! Name for the attribute
d1265 2
a1266 4
    integer :: fileID                   ! Where to look
    integer :: ATTRID                   ! ID for attribute if present
    integer :: SETID                    ! ID for DS if present
    integer :: STATUS                   ! Flag
d1269 12
a1280 21
    IsHDF5AttributeInFile = .false.
    call h5eSet_auto_f ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for attribute ' // trim(name) )
    call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, fileID, status)
    if ( status == 0 ) then
      call h5dOpen_f ( fileid, trim(DSname), setID, status )
      if ( status == 0 ) then
        call h5aopen_name_f(setID, trim(name), attrid, status)
        if ( status == 0 ) then
          IsHDF5AttributeInFile = .true.
          call h5aclose_f(attrid, status)
        end if
        call h5dClose_f ( setID, status )
      end if
      call h5fclose_f(fileID, status)
    end if
    call h5eSet_auto_f ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for attribute ' // trim(name) )
  end function IsHDF5AttributeInFile
a1281 5
  ! ---------------------------------------------  IsHDF5DSInFile  -----
  logical function IsHDF5DSInFile ( filename, name )
    ! This routine returns true if the given HDF5 DS is present
    character (len=*), intent(in) :: FILENAME ! Where to look
    character (len=*), intent(in) :: NAME ! Name for the dataset
d1283 2
a1284 3
    integer :: FILEID                   ! Where to look
    integer :: SETID                    ! ID for DS if present
    integer :: STATUS                   ! Flag
d1287 12
a1298 17
    IsHDF5DSInFile = .false.
    call h5eSet_auto_f ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for DS ' // trim(name) )
    call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, fileID, status)
    if ( status == 0 ) then
      call h5dOpen_f ( fileid, trim(name), setID, status )
      if ( status == 0 ) then
        IsHDF5DSInFile = .true.
        call h5dClose_f ( setID, status )
      end if
      call h5fclose_f(fileID, status)
    end if
    call h5eSet_auto_f ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for DS ' // trim(name) )
  end function IsHDF5DSInFile
a1299 5
  ! -----------------------------  IsHDF5AttributePresent_in_DSID  -----
  logical function IsHDF5AttributePresent_in_DSID ( SETID, name )
    ! This routine returns true if the given HDF5 attribute is present
    integer, intent(in) :: SETID        ! Dataset ID--Where to look
    character (len=*), intent(in) :: NAME ! Name for the attribute
d1301 2
a1302 2
    integer :: ATTRID                   ! ID for attribute if present
    integer :: STATUS                   ! Flag
d1305 12
a1316 14
    call h5eSet_auto_f ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for attribute ' // trim(name) )
    call h5aOpen_name_f ( SETID, name, attrID, status )
    if ( status /= 0 ) then
      IsHDF5AttributePresent_in_DSID = .false.
    else
      IsHDF5AttributePresent_in_DSID = .true.
      call h5aClose_f ( attrID, status )
    end if
    call h5eSet_auto_f ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for attribute ' // trim(name) )
  end function IsHDF5AttributePresent_in_DSID
d1318 3
a1320 14
  ! ------------------------------  IsHDF5AttributePresent_in_fID  -----
  logical function IsHDF5AttributePresent_in_fID ( fileID, DSname, name, &
    & is_grpattr )
    ! This routine returns true if the given HDF5 attribute is present
    ! If present it would be as an attribute either of the dataset DSname
    ! or, if is_grpattr is TRUE, of the group DSname
    integer, intent(in) :: fileID        ! file ID--Where to look
    character (len=*), intent(in) :: DSNAME ! Name for the dataset
    character (len=*), intent(in) :: NAME ! Name for the attribute
    logical, optional, intent(in) :: is_grpattr ! DSNAME is a group name
    integer :: SETID                    ! ID for dataset if present
    integer :: ATTRID                   ! ID for attribute if present
    integer :: STATUS                   ! Flag
    logical :: my_grpattr
d1323 6
a1328 27
    my_grpattr = .false.
    if ( present(is_grpattr) ) my_grpattr = is_grpattr
    if ( my_grpattr ) then
      IsHDF5AttributePresent_in_fID = IsHDF5AttributePresent_in_grp ( &
        & DSname, fileID, name)
      return
    end if
    call h5eSet_auto_f ( 0, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages off before looking for attribute ' // trim(name) )
    call h5dOpen_f ( fileid, trim(DSname), setID, status )
    if ( status /= 0 ) then
      IsHDF5AttributePresent_in_fID = .false.
    else
      call h5aOpen_name_f ( SETID, name, attrID, status )
      if ( status /= 0 ) then
        IsHDF5AttributePresent_in_fID = .false.
      else
        IsHDF5AttributePresent_in_fID = .true.
        call h5aClose_f ( attrID, status )
      end if
      call h5dClose_f ( setID, status )
    end if
    call h5eSet_auto_f ( 1, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to turn error messages back on after looking for attribute ' // trim(name) )
  end function IsHDF5AttributePresent_in_fID
d1330 14
a1343 10
  ! ------------------------------  IsHDF5AttributePresent_in_grp  -----
  logical function IsHDF5AttributePresent_in_grp ( grpName, fileID, name )
    ! This routine returns true if the given HDF5 attribute is present
    ! (Note the unusual ordering of args--to make unambiguous)
    integer, intent(in) :: fileID        ! file ID--Where to look
    character (len=*), intent(in) :: grpName ! Name for the group
    character (len=*), intent(in) :: NAME ! Name for the attribute
    integer :: GRPID                    ! ID for group if present
    integer :: ATTRID                   ! ID for attribute if present
    integer :: STATUS                   ! Flag
d1346 12
a1357 1
    call h5eSet_auto_f ( 0, status )
d1359 2
a1360 15
      & 'Unable to turn error messages off before looking for attribute ' // trim(name) )
    call h5gopen_f(fileID, trim(grpName), grpid, status)
    if ( status /= 0 ) then
      IsHDF5AttributePresent_in_grp = .false.
    else
      call h5aOpen_name_f ( GRPID, name, attrID, status )
      if ( status /= 0 ) then
        IsHDF5AttributePresent_in_grp = .false.
      else
        IsHDF5AttributePresent_in_grp = .true.
        call h5aClose_f ( attrID, status )
      end if
      call h5gclose_f(grpid, status)
    end if
    call h5eSet_auto_f ( 1, status )
d1362 11
a1372 2
      & 'Unable to turn error messages back on after looking for attribute ' // trim(name) )
  end function IsHDF5AttributePresent_in_grp
a1373 5
  ! --------------------------------------------  IsHDF5DSPresent  -----
  logical function IsHDF5DSPresent ( locID, name )
    ! This routine returns true if the given HDF5 DS is present
    integer, intent(in) :: LOCID        ! Where to look
    character (len=*), intent(in) :: NAME ! Name for the dataset
d1375 6
a1380 2
    integer :: SETID                    ! ID for DS if present
    integer :: STATUS                   ! Flag
d1383 23
a1405 1
    call h5eSet_auto_f ( 0, status )
d1407 2
a1408 5
      & 'Unable to turn error messages off before looking for DS ' // trim(name) )
    call h5dOpen_f ( locID, name, setID, status )
    IsHDF5DSPresent = status == 0
    if ( IsHDF5DSPresent ) call h5dClose_f ( setID, status )
    call h5eSet_auto_f ( 1, status )
d1410 29
a1438 2
      & 'Unable to turn error messages back on after looking for DS ' // trim(name) )
  end function IsHDF5DSPresent
a1439 5
  ! -----------------------------------------  IsHDF5GroupPresent  -----
  logical function IsHDF5GroupPresent ( locID, name )
    ! This routine returns true if the given HDF5 DS is present
    integer, intent(in) :: LOCID        ! Where to look
    character (len=*), intent(in) :: NAME ! Name for the dataset
d1441 4
a1444 2
    integer :: SETID                    ! ID for DS if present
    integer :: STATUS                   ! Flag
d1447 12
a1458 1
    call h5eSet_auto_f ( 0, status )
d1460 2
a1461 5
      & 'Unable to turn error messages off before looking for Group ' // trim(name) )
    call h5GOpen_f ( locID, name, setID, status )
    IsHDF5groupPresent = status == 0
    if ( IsHDF5groupPresent ) call h5GClose_f ( setID, status )
    call h5eSet_auto_f ( 1, status )
d1463 2
a1464 2
      & 'Unable to turn error messages back on after looking for Group ' // trim(name) )
  end function IsHDF5GroupPresent
d1466 8
a1473 6
  ! --------------------------------------  SaveAsHDF5DS_charsclr  -----
  subroutine SaveAsHDF5DS_charsclr ( locID, name, value )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID           ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME  ! Name for this dataset
    character (len=*), intent(in) :: VALUE ! The scalar char string
d1476 4
a1479 6
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer, dimension(1) :: SHP        ! Shape
    integer(hid_t) :: s_type_id
    integer(hid_t) :: type_id
d1482 12
a1493 3
    ! Create the dataspace
    shp = 1
    call h5sCreate_simple_f ( 1, int(shp,hSize_T), spaceID, status )
d1495 2
a1496 7
      & 'Unable to create dataspace for scalar character ' // trim(name) )
    type_id = H5T_NATIVE_CHARACTER
    call h5tcopy_f ( type_id, s_type_id, status )
    call h5tset_size_f ( s_type_id, len(value), status )
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), s_type_id, spaceID, setID, &
      & status )
d1498 2
a1499 6
      & 'Unable to create dataset for scalar character ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, s_type_id, value, &
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
    call finishSaveDS ( name, status, setID, spaceID )
  end subroutine SaveAsHDF5DS_charsclr
d1501 6
a1506 10
  ! --------------------------------------  SaveAsHDF5DS_chararr1  -----
  subroutine SaveAsHDF5DS_chararr1 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(in) :: VALUE(:)     ! The array itself
    character (len=*), optional, intent(in) :: FILLVALUE
    integer, dimension(1), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d1509 5
a1513 5
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer, dimension(1) :: SHP, MAXDIMS        ! Shape
    integer :: STRINGTYPE               ! Type for string
d1516 4
a1519 5
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create a data type for this string
    call h5tcopy_f ( H5T_NATIVE_CHARACTER, stringtype, status )
d1521 14
a1534 2
      & 'Unable to create stringtype for array' // trim(name) )
    call h5tset_size_f ( stringtype, max(len(value(1)), 1), status )
d1536 2
a1537 28
      & 'Unable to set size for stringtype ' // trim(name) )
    ! Create the dataspace
 !    call h5sCreate_simple_f ( 1, int(maxdims,hSize_T), spaceID, status )
 !    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
 !      & 'Unable to create dataspace for 1D char array ' // trim(name) )
 !      ! Create the dataset
 !    if ( present(fillValue) ) then
 !      call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
 !      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
 !        & 'Unable to create property list for 1D char array ' // trim(name) )
 !      call h5pset_fill_value_f (cparms, H5T_NATIVE_CHARACTER, fillValue, status)
 !      if ( status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
 !        &  "Unable to set Fill value for 1D char array " // trim (name))
 !      call h5dCreate_f ( locID, trim(name), stringtype, spaceID, setID, &
 !        & status, cparms )
 !    else
 !      call h5dCreate_f ( locID, trim(name), stringtype, spaceID, setID, &
 !        & status )
 !    end if
    call createSpaceSet ( locID, name, maxdims, stringtype, &
      & spaceID, setID, status, adding_to, cFill=FillValue)
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 1D char array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, stringtype, value, &
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
    call finishSaveDS ( name, status, setID, spaceID, stringType )
  end subroutine SaveAsHDF5DS_chararr1
d1539 6
a1544 10
  ! --------------------------------------  SaveAsHDF5DS_chararr2  -----
  subroutine SaveAsHDF5DS_chararr2 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(in) :: VALUE(:,:)     ! The array itself
    character (len=*), optional, intent(in) :: FILLVALUE
    integer, dimension(2), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d1547 5
a1551 5
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer, dimension(2) :: SHP, MAXDIMS        ! Shape
    integer :: STRINGTYPE               ! Type for string
d1554 4
a1557 5
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create a data type for this string
    call h5tcopy_f ( H5T_NATIVE_CHARACTER, stringtype, status )
d1559 14
a1572 2
      & 'Unable to create stringtype for array' // trim(name) )
    call h5tset_size_f ( stringtype, max(len(value(1,1)), 1), status )
d1574 2
a1575 28
      & 'Unable to set size for stringtype ' // trim(name) )
    ! Create the dataspace
 !    call h5sCreate_simple_f ( 2, int(maxdims,hSize_T), spaceID, status )
 !    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
 !      & 'Unable to create dataspace for 2D char array ' // trim(name) )
 !    ! Create the dataset
 !    if ( present(fillValue) ) then
 !      call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
 !      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
 !        & 'Unable to create property list for 2D char array ' // trim(name) )
 !      call h5pset_fill_value_f (cparms, H5T_NATIVE_CHARACTER, fillValue, status)
 !      if ( status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
 !        &  "Unable to set Fill value for 2D charr array " // trim (name))
 !      call h5dCreate_f ( locID, trim(name), stringtype, spaceID, setID, &
 !        & status, cparms )
 !    else
 !      call h5dCreate_f ( locID, trim(name), stringtype, spaceID, setID, &
 !        & status )
 !    end if
    call createSpaceSet ( locID, name, maxdims, stringtype, &
      & spaceID, setID, status, adding_to, cFill=fillValue)
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataset for 2D char array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, stringtype, value, &
      & int ( (/ shp, ones(1:5) /), hID_T ), status )
    call finishSaveDS ( name, status, setID, spaceID, stringType )
  end subroutine SaveAsHDF5DS_chararr2
d1577 5
a1581 10
  ! ---------------------------------------  SaveAsHDF5DS_intarr1  -----
  subroutine SaveAsHDF5DS_intarr1 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(in) :: VALUE(:)     ! The array itself
    integer, optional, intent(in) :: FILLVALUE
    integer, dimension(1), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d1584 3
a1586 4
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer, dimension(1) :: SHP, MAXDIMS        ! Shape
d1589 9
a1597 6
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_INTEGER, &
      & spaceID, setID, status, adding_to, iFill=fillValue)
d1599 2
a1600 6
      & 'Unable to create dataset for 1D integer array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_INTEGER, value, &
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
    call finishSaveDS ( name, status, setID, spaceID )
  end subroutine SaveAsHDF5DS_intarr1
d1602 5
a1606 10
  ! ---------------------------------------  SaveAsHDF5DS_intarr2  -----
  subroutine SaveAsHDF5DS_intarr2 ( locID, name, value, &
    & fillValue, finalShape, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(in) :: VALUE(:,:)     ! The array itself
    integer, optional, intent(in) :: FILLVALUE
    integer, dimension(2), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d1609 3
a1611 4
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer, dimension(2) :: SHP, MAXDIMS        ! Shape
d1614 20
a1633 6
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_INTEGER, &
      & spaceID, setID, status, adding_to, iFill=fillValue)
d1635 2
a1636 17
      & 'Unable to create dataset for 2D integer array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_INTEGER, value, &
      & int ( (/ shp, ones(1:5) /), hID_T ), status )
    call finishSaveDS ( name, status, setID, spaceID )
  end subroutine SaveAsHDF5DS_intarr2

  ! ---------------------------------------  SaveAsHDF5DS_intarr3  -----
  subroutine SaveAsHDF5DS_intarr3 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(in) :: VALUE(:,:,:)     ! The array itself
    integer, optional, intent(in) :: FILLVALUE
    integer, dimension(3), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d1638 6
d1645 4
a1648 4
    integer :: spaceID                  ! ID for dataspace
    integer (HID_T) :: setID            ! ID for dataset
    integer :: status                   ! Flag from HDF5
    integer, dimension(3) :: SHP, MAXDIMS        ! Shape
d1651 2
a1652 6
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
    ! Create the dataspace
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_INTEGER, &
      & spaceID, setID, status, adding_to, iFill=fillValue )
d1654 28
a1681 6
      & 'Unable to create dataset for 3D integer array ' // trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_INTEGER, value, &
      & int ( (/ shp, ones(1:4) /), hID_T ), status )
    call finishSaveDS ( name, status, setID, spaceID )
  end subroutine SaveAsHDF5DS_intarr3
d1683 18
a1700 10
  ! ---------------------------------------  SaveAsHDF5DS_logarr1  -----
  subroutine SaveAsHDF5DS_logarr1 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
    ! This routine does the initial work of creating a dataset
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    logical, intent(in) :: VALUE(:)     ! The array itself
    logical, optional, intent(in) :: FILLVALUE
    integer, dimension(1), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d1702 5
d1708 73
a1780 2
    integer :: I
    character :: MyFillValue, MyValue(size(value))   ! T = true, F = false
d1783 15
a1797 4
    ! Turn fillValue into a character
    myFillValue = 'F'
    if ( present(fillValue) ) then
      if ( fillValue ) myFillValue = 'T'
d1799 46
a1844 7
    ! Turn value into a character
    do i = 1, size(value)
      myValue(i) = 'F'
      if ( value(i) ) myValue(i) = 'T'
    end do
    call saveAsHDF5DS ( locID, name, myValue, finalShape, myFillValue, adding_to )
  end subroutine SaveAsHDF5DS_logarr1
d1846 2
a1847 3
  ! ---------------------------------------  SaveAsHDF5DS_dblarr1  -----
  subroutine SaveAsHDF5DS_dblarr1 ( locID, name, value, &
    & finalShape, fillValue, adding_to )
d1849 3
a1851 6
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, intent(in) :: VALUE(:)     ! The array itself
    double precision, optional, intent(in) :: FILLVALUE
    integer, dimension(1), optional, intent(in) :: FINALSHAPE
    logical, optional, intent(in)     :: adding_to
d1857 3
a1859 1
    integer, dimension(1) :: SHP, MAXDIMS        ! Shape
a1861 3
    shp = shape(value)
    maxdims = shp
    if ( present(finalShape) ) maxdims = finalShape
d1863 10
a1872 2
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_DOUBLE, &
      & spaceID, setID, status, adding_to, dFill=fillValue )
d1874 1
a1874 1
      & 'Unable to create dataset for 1D double array ' // trim(name) )
d1876 1
a1876 1
    call h5dWrite_f ( setID, H5T_NATIVE_DOUBLE, value, &
d1879 1
a1879 1
  end subroutine SaveAsHDF5DS_dblarr1
d1881 2
a1882 2
  ! ---------------------------------------  SaveAsHDF5DS_dblarr2  -----
  subroutine SaveAsHDF5DS_dblarr2 ( locID, name, value, &
d1887 148
a2034 2
    double precision, intent(in) :: VALUE(:,:)  ! The array itself
    double precision, optional, intent(in) :: FILLVALUE
d2049 2
a2050 2
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_DOUBLE, &
      & spaceID, setID, status, adding_to, dFill=fillValue )
d2052 1
a2052 1
      & 'Unable to create dataset for 2D double array ' // trim(name) )
d2054 1
a2054 1
    call h5dWrite_f ( setID, H5T_NATIVE_DOUBLE, value, &
d2057 1
a2057 1
  end subroutine SaveAsHDF5DS_dblarr2
d2059 2
a2060 2
  ! ---------------------------------------  SaveAsHDF5DS_dblarr3  -----
  subroutine SaveAsHDF5DS_dblarr3 ( locID, name, value, &
d2063 1
a2063 1
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
d2065 2
a2066 2
    double precision, intent(in) :: VALUE(:,:,:)  ! The array itself
    double precision, optional, intent(in) :: FILLVALUE
d2081 2
a2082 2
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_DOUBLE, &
      & spaceID, setID, status, adding_to, dFill=fillValue )
d2084 1
a2084 1
      & 'Unable to create dataset for 3D double array ' // trim(name) )
d2086 1
a2086 1
    call h5dWrite_f ( setID, H5T_NATIVE_DOUBLE, value, &
d2089 1
a2089 1
  end subroutine SaveAsHDF5DS_dblarr3
d2091 2
a2092 2
  ! --------------------------------------  SaveAsHDF5DS_snglarr1  -----
  subroutine SaveAsHDF5DS_snglarr1 ( locID, name, value, &
d2097 31
a2127 2
    real, intent(in) :: VALUE(:)     ! The array itself
    real, optional, intent(in) :: FILLVALUE
d2139 1
a2139 1
    maxdims=shp
d2142 2
a2143 2
    call createSpaceSet ( locID, name, maxdims, H5T_NATIVE_REAL, &
      & spaceID, setID, status, adding_to, rFill=fillValue )
d2147 1
a2147 1
    call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
d2150 1
a2150 1
  end subroutine SaveAsHDF5DS_snglarr1
d2152 3
a2154 3
  ! --------------------------------------  SaveAsHDF5DS_snglarr2  -----
  subroutine SaveAsHDF5DS_snglarr2 ( locID, name, value, &
    & start, count, stride, block, may_add_to, adding_to, fillValue )
d2156 1
a2156 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d2158 4
a2161 2
    real, intent(in) :: VALUE(:,:)      ! The array itself
    real, optional, intent(in) :: FILLVALUE
a2162 12
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    logical, optional, intent(in)               :: may_add_to
                                 ! May call again to add to same dataset
    logical, optional, intent(in)               :: adding_to
                                 ! Calling again to add to same dataset
d2164 110
a2273 4
    integer(hsize_t), dimension(2) :: chunk_dims, dims, maxdims
    integer :: spaceID                  ! ID for filespace
    integer :: memSpaceID               ! ID for arrayspace
    integer :: filespaceID              ! ID for filespace
d2734 881
a3614 16
      if ( DEEBUG ) print *, 'name ', name
      if ( DEEBUG ) print *, 'shape(value) ', shp
      if ( DEEBUG ) print *, 'start ', start
      if ( DEEBUG ) print *, 'count ', count
      call mls_extend ( setID, Count, start, filespaceID )
      call mls_hyperslab_save ( filespaceID, start, count, stride, block )
      if ( style == 2 ) &
        & call h5screate_simple_f(4, dims, memspaceID, status, maxdims)
      if ( DEEBUG ) print *, 'filespaceID ', filespaceID
      call dump_space ( filespaceID )
      if ( DEEBUG ) print *, 'memspaceID ', memspaceID
      call dump_space ( memspaceID )
      call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
        & int ( (/ shp, ones(1:3) /), hID_T ), status, &
        & memspaceID, filespaceID )
      spaceID = filespaceID
d3616 4
a3619 3
      ! Write the data
      call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
        & int ( (/ shp, ones(1:3) /), hID_T ), status )
d3621 1
a3621 6
    if ( present(start) ) then
      call finishSaveDS ( name, status, setID, spaceID, memspaceID=memspaceID )
    else
      call finishSaveDS ( name, status, setID, spaceID )
    end if
  end subroutine SaveAsHDF5DS_snglarr4
d3623 2
a3624 2
  ! ------------------------------------  LoadFromHDF5DS_chararr1  -----
  subroutine LoadFromHDF5DS_chararr1 ( locID, name, value, &
d3627 1
a3627 1
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
d3629 1
a3629 1
    character (len=*), intent(out) :: VALUE(:)    ! The array itself
d3631 1
a3631 1
                                 ! Starting coordinates of hyperslab
d3641 1
a3641 1
    integer, dimension(1) :: SHP        ! Shape of value
a3644 2
    integer :: STRINGTYPE               ! String type
    integer :: STRINGSIZE               ! String size
d3648 1
a3648 4
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dGet_type_f ( setID, stringType, status )
d3650 2
a3651 6
      & 'Unable to get type for 1D char array ' // trim(name) )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for 1D char array ' // trim(name) )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 1D char array ' // trim(name) )
d3654 2
a3655 1
      & 'Unable to open dataspace for dataset ' // trim(name) )
d3659 3
a3661 3
      call h5dread_f ( setID, stringtype, value, &
        & (/ shp, ones(1:6) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, stringType )
d3664 3
a3666 2
      call h5dread_f ( setID, stringtype, value, (/ shp, ones(1:6) /), status )
      call finishLoad ( name, status, spaceID, setID, stringType=stringType )
d3668 1
a3668 1
  end subroutine LoadFromHDF5DS_chararr1
a3711 54
  ! ------------------------------------  LoadFromHDF5DS_chararr2  -----
  subroutine LoadFromHDF5DS_chararr2 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(out) :: VALUE(:,:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer, dimension(2) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset
    integer :: STRINGTYPE               ! String type
    integer :: STRINGSIZE               ! String size

    ! Executable code
    shp = shape ( value )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dGet_type_f ( setID, stringType, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get type for 2D char array ' // trim(name) )
    call h5tGet_size_f ( stringType, stringSize, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get size for 2D char array ' // trim(name) )
    if ( stringSize > len(value) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 2D char array ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, stringtype, value, &
        & (/ shp, ones(1:5) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID, stringType )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, stringtype, value, (/ shp, ones(1:5) /), status )
      call finishLoad ( name, status, spaceID, setID, stringType=stringType )
    end if
  end subroutine LoadFromHDF5DS_chararr2

a3748 45
  ! -------------------------------------  LoadFromHDF5DS_intarr1  -----
  subroutine LoadFromHDF5DS_intarr1 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(out) :: VALUE(:)      ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer, dimension(1) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset

    ! Executable code
    shp = shape ( value )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
        & (/ shp, ones(1:6) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
        & (/ shp, ones(1:6) /), status )
      call finishLoad ( name, status, spaceID, setID )
    end if
  end subroutine LoadFromHDF5DS_intarr1

a3781 44
  ! -------------------------------------  LoadFromHDF5DS_intarr2  -----
  subroutine LoadFromHDF5DS_intarr2 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    integer, intent(out) :: VALUE(:,:)    ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer, dimension(2) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset

    ! Executable code
    shp = shape ( value )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
        & (/ shp, ones(1:5) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
        & (/ shp, ones(1:5) /), status )
      call finishLoad ( name, status, spaceID, setID )
    end if
  end subroutine LoadFromHDF5DS_intarr2

a3809 23
  ! -------------------------------------  LoadFromHDF5DS_logarr1  -----
  subroutine LoadFromHDF5DS_logarr1 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    logical, intent(out) :: VALUE(:)      ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block
    ! Local variables
    character :: MyValue(size(value))   ! 'F' = false, 'T' = true

    ! Executable code
    call LoadFromHDF5DS ( locID, name, myValue, start, count, stride, block )
    value = myValue == 'T'
  end subroutine LoadFromHDF5DS_logarr1

a3833 45
  ! -------------------------------------  LoadFromHDF5DS_dblarr1  -----
  subroutine LoadFromHDF5DS_dblarr1 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME     ! Name for this dataset
    double precision, intent(out) :: VALUE(:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer, dimension(1) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset

    ! Executable code
    shp = shape ( value )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f(setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:6) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:6) /), status )
      call finishLoad ( name, status, spaceID, setID )
    end if
  end subroutine LoadFromHDF5DS_dblarr1

a3866 45
  ! -------------------------------------  LoadFromHDF5DS_dblarr2  -----
  subroutine LoadFromHDF5DS_dblarr2 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME       ! Name for this dataset
    double precision, intent(out) :: VALUE(:,:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer, dimension(2) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset

    ! Executable code
    shp = shape ( value )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:5) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:5) /), status )
      call finishLoad ( name, status, spaceID, setID )
    end if
  end subroutine LoadFromHDF5DS_dblarr2

a3894 45
  ! -------------------------------------  LoadFromHDF5DS_dblarr3  -----
  subroutine LoadFromHDF5DS_dblarr3 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    double precision, intent(out) :: VALUE(:,:,:) ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer, dimension(3) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset

    ! Executable code
    shp = shape ( value )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:4) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shp, ones(1:4) /), status )
      call finishLoad ( name, status, spaceID, setID )
    end if
  end subroutine LoadFromHDF5DS_dblarr3

a3923 45
  ! ------------------------------------  LoadFromHDF5DS_snglarr1  -----
  subroutine LoadFromHDF5DS_snglarr1 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:)         ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer, dimension(1) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset

    ! Executable code
    shp = shape ( value )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:6) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:6) /), status )
      call finishLoad ( name, status, spaceID, setID )
    end if
  end subroutine LoadFromHDF5DS_snglarr1

a3956 45
  ! ------------------------------------  LoadFromHDF5DS_snglarr2  -----
  subroutine LoadFromHDF5DS_snglarr2 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:,:)       ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer, dimension(2) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset

    ! Executable code
    shp = shape ( value )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:5) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:5) /), status )
      call finishLoad ( name, status, spaceID, setID )
    end if
  end subroutine LoadFromHDF5DS_snglarr2

a3984 45
  ! ------------------------------------  LoadFromHDF5DS_snglarr3  -----
  subroutine LoadFromHDF5DS_snglarr3 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:,:,:)     ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer, dimension(3) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset

    ! Executable code
    shp = shape ( value )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:4) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:4) /), status )
      call finishLoad ( name, status, spaceID, setID )
    end if
  end subroutine LoadFromHDF5DS_snglarr3

a4013 45
  ! ------------------------------------  LoadFromHDF5DS_snglarr4  -----
  subroutine LoadFromHDF5DS_snglarr4 ( locID, name, value, &
    & start, count, stride, block )
    ! This routine loads a predefined array with values from a DS
    integer, intent(in) :: LOCID          ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real, intent(out) :: VALUE(:,:,:,:)   ! The array itself
    integer, dimension(:), optional, intent(in) :: start
                                 ! Starting coordinatess of hyperslab
    integer, dimension(:), optional, intent(in) :: count
                                 ! Num of blocks to select from dataspace
    integer, dimension(:), optional, intent(in) :: stride
                                 ! How many elements to move in each direction
    integer, dimension(:), optional, intent(in) :: block
                                 ! Size of element block

    ! Local variables
    integer :: STATUS                   ! Flag from HDF5
    integer, dimension(4) :: SHP        ! Shape of value
    integer :: SPACEID                  ! ID of dataspace
    integer :: MEMSPACEID               ! ID of dataspace
    integer :: SETID                    ! ID of dataset

    ! Executable code
    shp = shape ( value )
    call h5dOpen_f ( locID, name, setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataset ' // trim(name) )
    call h5dget_space_f ( setID, spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open dataspace for dataset ' // trim(name) )
    if ( present(start) ) then
      call mls_hyperslab ( spaceID, shp, name, memspaceID, &
        & start, count, stride, block )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:3) /), status, memspaceID, spaceID )
      call finishLoad ( name, status, spaceID, setID, memspaceID )
    else
      call check_for_fit ( spaceID, shp, name )
      call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
        & (/ shp, ones(1:3) /), status )
      call finishLoad ( name, status, spaceID, setID )
    end if
  end subroutine LoadFromHDF5DS_snglarr4

d4281 2
a4282 1
  subroutine FinishLoad ( Name, Status, SpaceID, SetID, MemspaceID, StringType )
d4290 1
d4292 2
a4293 1
      & 'Unable to read dataset ' // trim(name) )
d4296 2
a4297 1
      & 'Unable to close dataspace for dataset ' // trim(name) )
d4301 2
a4302 1
        & 'Unable to close hyperslab dataspace for dataset ' // trim(name) )
d4306 2
a4307 1
      & 'Unable to close dataset ' // trim(name) )
d4311 2
a4312 1
        & 'Unable to close string type for ' // trim(name) )
d4733 1
a4733 1
       "$Id: $"
d4742 3
@


2.53
log
@Nullified name component of data_set info before allocating
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d66 1
a66 4
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: MLSHDF5.f90,v 2.52 2005/01/12 03:04:15 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d68 3
a70 3
       "$RCSfile: MLSHDF5.f90,v $"
  private :: not_used_here
  !---------------------------------------------------------------------------
d4118 5
d4129 3
@


2.52
log
@Use correct data type in MakeHDF5Attribute_sngl, some cannonball polishing
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d60 1
a60 1
       "$Id: MLSHDF5.f90,v 2.51 2005/01/07 01:57:53 vsnyder Exp $"
d298 1
d4119 3
@


2.51
log
@Don't try to get DS dims from an Attrib
@
text
@d60 1
a60 1
       "$Id: MLSHDF5.f90,v 2.50 2005/01/07 01:14:26 vsnyder Exp $"
d389 1
a389 3
    ! ???? Shouldn't the type be H5T_NATIVE_REAL ????
    ! ???? It is for MakeHDF5Attribute_snglarr1 ????
    if ( startMakeAttrib ( itemId, name, H5T_NATIVE_DOUBLE, dsID, attrID, &
d392 1
a392 1
      call h5aWrite_f ( attrID, H5T_NATIVE_DOUBLE, value, ones, status )
d543 1
a543 1
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
d1282 1
a1282 1
      & 'Unable to turn error messages off before getting dims ' // trim(name) )
d1284 2
a1285 2
    call h5dget_space_f(attrID,dspace_id,status)
    call h5sget_simple_extent_ndims_f(dspace_id,rank,status)
d1287 3
a1289 3
    allocate(maxdims_ptr(my_rank))
    call h5sget_simple_extent_dims_f(dspace_id,dims(1:my_rank),&
         maxdims_ptr(1:my_rank),status)
d1294 1
a1294 1
    deallocate(maxdims_ptr)
d1297 1
a1297 1
      & 'Unable to turn error messages back on after getting dims ' // trim(name) )
d1325 1
a1325 1
    allocate(maxdims_ptr(my_rank))
d1332 1
a1332 1
    deallocate(maxdims_ptr)
d2604 1
a2604 1
      & 'Unable to get size for 1D char array ' // trim(name) )
d3714 2
a3715 2
    if ( present(stringTYpe) ) then
      call h5tClose_f ( stringtype, status )
d3717 1
a3717 1
        & 'Unable to close stringtype ' // trim(name) )
d4118 3
@


2.50
log
@Allocate the correct upper bound in LoadPtrFromHDF5DS_logarr1
@
text
@d60 1
a60 1
       "$Id: MLSHDF5.f90,v 2.49 2005/01/07 01:04:37 vsnyder Exp $"
d898 1
a898 1
    call getHDF5DSDims ( itemID, trim(name), shp, maxShp )
d1013 1
a1013 1
    call getHDF5DSDims ( itemID, trim(name), shp, maxShp )
d1133 1
a1133 1
    call getHDF5DSDims ( itemID, trim(name), shp, maxShp )
d1247 1
a1247 1
    call getHDF5DSDims ( itemID, trim(name), shp, maxShp )
d4120 3
@


2.49
log
@Use generics for some internal references
@
text
@d60 1
a60 1
       "$Id: MLSHDF5.f90,v 2.47 2004/12/31 02:38:53 vsnyder Exp $"
d2904 1
a2904 1
    call allocate_test ( value, size(myValue), 'Value', moduleName, lowBound=lb )
d4120 3
@


2.48
log
@Add IsHDF5GroupPresent, simplify some stuff, delete unused stuff
@
text
@d245 2
a246 2
    call GetHDF5Attribute_string ( fromitemID, name, value1 )
    call MakeHDF5Attribute_string ( toitemID, name, trim(value1), &
d4120 3
@


2.47
log
@Added LoadPtrFromHDF5DS, simplified a lot of stuff
@
text
@d22 1
a22 1
    & H5SIS_SIMPLE_F, H5SOFFSET_SIMPLE_F, &
d27 1
a27 1
    & HID_T, HSIZE_T, HSSIZE_T
d51 2
a52 2
    & IsHDF5AttributePresent, IsHDF5DSPresent, &
    & IsHDF5DSInFile, IsHDF5AttributeInFile, &
d60 1
a60 1
       "$Id: MLSHDF5.f90,v 2.46 2004/12/13 20:26:53 vsnyder Exp $"
d107 1
d1567 1
a1567 1
  ! -------------------------------------------  IsHDF5DSPresent  -----
d1581 2
a1582 6
    if ( status /= 0 ) then
      IsHDF5DSPresent = .false.
    else
      IsHDF5DSPresent = .true.
      call h5dClose_f ( setID, status )
    end if
d1588 21
d4120 3
@


2.46
log
@Added MakeHDF5Attribute_sngl.  Change specifics for generics to use Real
and Double Precision instead of r4 (which isn't guaranteed to be default
real) and r8 (which isn't guaranteed to be different from default real).
Changed a few references to specifics to refer to generics.
@
text
@d8 1
a8 1
  
d20 1
a20 1
  use HDF5, only: H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, &
d48 2
a49 1
  public :: CpHDF5Attribute, CpHDF5GlAttribute, GetHDF5Attribute, &
d53 2
a54 1
    & LoadFromHDF5DS, MakeHDF5Attribute, mls_h5open, mls_h5close, &
d60 1
a60 1
       "$Id: MLSHDF5.f90,v 2.45 2004/09/23 23:00:10 pwagner Exp $"
d64 1
a64 1
  private :: not_used_here 
d75 1
d82 1
d90 5
a94 5
! CpHDF5Attribute (int fromitemID, int toitemID, char name, 
!    [log skip_if_already_there]) 
! CpHDF5GlAttribute (char fromFile, char toFile, char name, 
!    [log skip_if_already_there]) 
! GetAllHDF5DSNames (file, char gname, char DSNames) 
d97 14
a110 11
! GetHDF5Attribute (int itemID, char name, value) 
! GetHDF5DSDims (int FileID, char name, hsize_t dims(:), [hsize_t maxdims(:)]) 
! GetHDF5DSRank (int FileID, char name, int rank) 
! GetHDF5DSQType (int FileID, char name, char QType) 
! log IsHDF5AttributeInFile (char filename, char DSname, char name) 
! log IsHDF5DSInFile (char filename, char name) 
! log IsHDF5AttributePresent (int setid, char name) 
! log IsHDF5AttributePresent (int fileid, char DSname, char name) 
! log IsHDF5DSPresent (int locID, char name) 
! LoadFromHDF5DS (int locID, char name, value,  
!       [int start(:), int count(:), [int stride(:), int block(:)] ] ) 
d112 2
a113 2
!       [log skip_if_already_there]) 
! SaveAsHDF5DS (int locID, char name, value) 
d115 1
a115 1
!    {char* value, int value, real value, double precision value, 
d118 1
a118 1
!     double precision value(:), double precision value(:,:), 
d128 1
d130 1
a130 1
      & MakeHDF5Attribute_dblarr1, MakeHDF5Attribute_string_arr1, &
d138 1
d141 7
a147 1
      & GetHDF5Attribute_dblarr1, GetHDF5Attribute_string_arr1
d155 1
a155 1
    ! module procedure CpHDF5Attribut _dblarr1, CpHDF5Attribute_string_arr1
d170 1
d179 1
d186 9
d206 2
a207 2
  ! ------------------------------------- mls_h5close
  subroutine mls_h5close ( error )
d211 2
a212 2
    call h5close_f (error)
  end subroutine mls_h5close
d214 2
a215 2
  ! ------------------------------------- mls_h5open
  subroutine mls_h5open ( error )
d219 2
a220 2
    call h5open_f (error)
  end subroutine mls_h5open
d222 1
a222 1
  ! ------------------------------------- CpHDF5Attribute_string
d225 1
a225 1
    integer, intent(in)           :: FROMITEMID   ! Group etc. to Cp attr from
a230 4
    integer :: ATTRID                   ! ID for attribute
    integer :: DSID                     ! ID for dataspace
    integer :: STATUS                   ! Flag from HDF5
    integer :: STRINGTYPE               ! Type for string
d235 1
a235 1
 
d238 1
a238 1
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
d241 3
a243 3
      & 'Unable to cp: attribute not found '//trim(name) )
    is_present = IsHDF5AttributePresent_in_DSID(toitemID, name) 
    if ( my_skip .and. is_present) return
d249 1
a249 1
  ! ------------------------------------- CpHDF5GlAttribute_string
d252 1
a252 1
    character (len=*), intent(in) :: FROMFILENAME       ! file name
d263 1
a263 1
    
d265 4
a268 4
    call h5fopen_f(trim(fromFilename), H5F_ACC_RDONLY_F, fromFileID, status)
    call h5fopen_f(trim(toFilename), H5F_ACC_RDONLY_F, toFileID, status)
    call h5gopen_f(fromFileID, '/', fromgrpid, status)
    call h5gopen_f(toFileID, '/', togrpid, status)
d271 4
a274 4
    call h5gclose_f(fromgrpid, status)
    call h5gclose_f(togrpid, status)
    call h5fclose_f(fromFileID, status)
    call h5fclose_f(toFileID, status)
d277 1
a277 1
  ! ------------------------------------- GetAllHDF5DSNames_fileID
d279 2
a280 1
    integer, intent(in) :: FILEID       ! fileID
d297 2
a298 3
    allocate( dataset_info%name(1:MAXNDSNAMES), stat=status)             
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to allocate name array before getting DSNames' )
d301 1
a301 1
    call Query_MLSData(fileid, trim(gname), dataset_info)
d305 1
a305 1
    elseif ( dataset_info%number_of_entries == 1 ) then
d307 1
a307 1
    elseif ( dataset_info%number_of_entries > 1 ) then
d309 1
a309 1
      do i=1, dataset_info%number_of_entries
d311 2
a312 2
      enddo
    endif
d316 1
a316 3
    deallocate(dataset_info%name, stat=status)
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to deallocate name array after getting DSNames' )
d319 1
a319 1
  ! ------------------------------------- GetAllHDF5DSNames_filename
d331 3
a333 1
    call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, fileID, status)
d336 1
a336 1
      call GetAllHDF5DSNames_fileID(fileID, gname, DSNames)
d339 2
a340 2
      & 'Unable to open file for getting DSNames '//trim(filename) )
    endif
d342 1
a342 1
    call h5fclose_f(fileID, status)
d344 1
a344 1
      & 'Unable to close file after getting DSNames '//trim(filename) )
d347 1
a347 1
      & 'Unable to turn error messages back on after getting DSNames '//trim(filename) )
d350 1
a350 1
  ! ------------------------------------- MakeHDF5Attribute_dbl
d353 1
a353 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr to.
a361 1
    logical :: my_skip
d364 7
a370 23
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
    endif
    call h5sCreate_F ( h5s_scalar_f, dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for attribute '//trim(name) )
    ! Now create the attribute
    call h5aCreate_f ( itemID, trim(name), H5T_NATIVE_DOUBLE, dsID, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create attribute '//trim(name) )
    ! Write
    call h5aWrite_f ( attrID, H5T_NATIVE_DOUBLE, value, ones, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write attribute '//trim(name) )
    ! Finish off
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute '//trim(name) )
    call h5sClose_f ( dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute dataspace '//trim(name) )
d373 1
a373 1
  ! ------------------------------------- MakeHDF5Attribute_sngl
d376 1
a376 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr to.
d378 1
a378 1
    real, intent(in) :: VALUE           ! Value of attribute
a384 1
    logical :: my_skip
d387 9
a395 23
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
    endif
    call h5sCreate_F ( h5s_scalar_f, dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for attribute '//trim(name) )
    ! Now create the attribute
    call h5aCreate_f ( itemID, trim(name), H5T_NATIVE_DOUBLE, dsID, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create attribute '//trim(name) )
    ! Write
    call h5aWrite_f ( attrID, H5T_NATIVE_DOUBLE, value, ones, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write attribute '//trim(name) )
    ! Finish off
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute '//trim(name) )
    call h5sClose_f ( dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute dataspace '//trim(name) )
d398 1
a398 1
  ! ------------------------------------- MakeHDF5Attribute_int
d401 1
a401 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr to.
d403 1
a403 1
    integer, intent(in) :: VALUE        ! Value of attribute
a409 1
    logical :: my_skip
d412 7
a418 23
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
    endif
    call h5sCreate_F ( h5s_scalar_f, dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for attribute '//trim(name) )
    ! Now create the attribute
    call h5aCreate_f ( itemID, trim(name), H5T_NATIVE_INTEGER, dsID, attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create attribute '//trim(name) )
    ! Write
    call h5aWrite_f ( attrID, H5T_NATIVE_INTEGER, value, ones, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write attribute '//trim(name) )
    ! Finish off
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute '//trim(name) )
    call h5sClose_f ( dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute dataspace '//trim(name) )
d421 2
a422 2
  ! ------------------------------------- MakeHDF5Attribute_logical
  subroutine MakeHDF5Attribute_logical ( itemID, name, value , &
a430 1
    logical :: my_skip
a432 5
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
    endif
d435 1
a435 1
    call MakeHDF5Attribute ( itemID, name, iValue )
d438 21
a458 1
  ! ------------------------------------- MakeHDF5Attribute_string
d473 1
a473 2
    character (len=2000) :: value1
 
d477 2
a478 2
    is_present = IsHDF5AttributePresent_in_DSID(itemID, name) 
    if ( my_skip .and. is_present) return
d481 1
a481 1
    call h5tcopy_f( H5T_NATIVE_CHARACTER, stringtype, status ) 
d483 1
a483 1
      & 'Unable to create stringtype '//trim(name) )
d486 1
a486 1
      & 'Unable to set size for stringtype '//trim(name) )
d490 1
a490 1
    !  & 'Unable to create dataspace for attribute '//trim(name) )
d496 4
a499 4
        call h5adelete_f(itemID, trim(name), status)
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to delete ' )
    endif
d502 1
a502 1
          & 'Unable to create dataspace for attribute '//trim(name) )
d505 1
a505 1
          & 'Unable to create attribute '//trim(name) )
d509 1
a509 2
    call h5aWrite_f ( attrID, stringtype, value, &
      & ones, status )
d511 1
a511 1
      & 'Unable to write attribute '//trim(name) )
d515 6
a520 6
      & 'Unable to close attribute '//trim(name) )
    if (.not. is_present) then 
        call h5sClose_f ( dsID, status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
           & 'Unable to close attribute dataspace '//trim(name) )
    endif
d523 1
a523 1
         & 'Unable to close stringtype '//trim(name) )
d526 2
a527 2
  ! ------------------------------------- MakeHDF5Attribute_string_arr1
  subroutine MakeHDF5Attribute_string_arr1 ( itemID, name, value , &
d529 1
a529 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr to.
d546 2
a547 2
       if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
    endif
d551 1
a551 1
    call h5tcopy_f( H5T_NATIVE_CHARACTER, stringtype, status ) 
d553 2
a554 2
      & 'Unable to create stringtype for array'//trim(name) )
    call h5tset_size_f(stringtype, len(value(1)), status )
d556 1
a556 1
      & 'Unable to set size for stringtype '//trim(name) )
d561 1
a561 1
      & 'Unable to create dataspace for attribute '//trim(name) )
d564 1
a564 1
      & 'Unable to create attribute '//trim(name) )
d568 2
a569 13
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write attribute '//trim(name) )
    ! Finish off
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute '//trim(name) )
    call h5sClose_f ( dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute dataspace '//trim(name) )
    call h5tClose_f ( stringtype, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close stringtype '//trim(name) )
  end subroutine MakeHDF5Attribute_string_arr1
d571 1
a571 1
  ! ------------------------------------- MakeHDF5Attribute_snglarr1
d574 1
a574 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr to.
d576 1
a576 1
    real, intent(in) :: VALUE(:)        ! The attribute array itself
a583 1
    logical :: my_skip
d586 1
a586 5
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
    endif
d588 7
a594 20
    call h5sCreate_simple_f ( 1, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 1D attribute array '//trim(name) )
    ! Now create the attribute
    call h5aCreate_f ( itemID, trim(name), H5T_NATIVE_REAL, spaceID, &
      & attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create 1d attribute array '//trim(name) )
    ! Write
    call h5aWrite_f ( attrID, H5T_NATIVE_REAL, value, &
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write 1d attribute array '//trim(name) )
    ! Finish off
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close 1d attribute array'//trim(name) )
    call h5sClose_f ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close 1d attribute array dataspace '//trim(name) )
d597 1
a597 1
  ! ------------------------------------- MakeHDF5Attribute_dblarr1
d600 1
a600 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr to.
a609 1
    logical :: my_skip
d612 1
a612 5
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
    endif
d614 7
a620 20
    call h5sCreate_simple_f ( 1, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 1D attribute array '//trim(name) )
    ! Now create the attribute
    call h5aCreate_f ( itemID, trim(name), H5T_NATIVE_DOUBLE, spaceID, &
      & attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create 1d attribute array '//trim(name) )
    ! Write
    call h5aWrite_f ( attrID, H5T_NATIVE_DOUBLE, value, &
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write 1d attribute array '//trim(name) )
    ! Finish off
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close 1d attribute array'//trim(name) )
    call h5sClose_f ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close 1d attribute array dataspace '//trim(name) )
d623 1
a623 1
  ! ------------------------------------- MakeHDF5Attribute_intarr1
d626 1
a626 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr to.
d628 1
a628 1
    integer, intent(in) :: VALUE(:)     ! The attribute array itself
a635 1
    logical :: my_skip
d638 1
a638 5
    my_skip = .false.
    if ( present(skip_if_already_there) ) my_skip=skip_if_already_there
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
    endif
d640 7
a646 20
    call h5sCreate_simple_f ( 1, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 1D attribute array '//trim(name) )
    ! Now create the attribute
    call h5aCreate_f ( itemID, trim(name), H5T_NATIVE_INTEGER, spaceID, &
      & attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create 1d attribute array '//trim(name) )
    ! Write
    call h5aWrite_f ( attrID, H5T_NATIVE_INTEGER, value, &
      & int ( (/ shp, ones(1:6) /), hID_T ), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write 1d attribute array '//trim(name) )
    ! Finish off
    call h5aClose_f ( attrID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close 1d attribute array'//trim(name) )
    call h5sClose_f ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close 1d attribute array dataspace '//trim(name) )
d649 3
a651 3
  ! ------------------------------------- MakeHDF5AttributeDSN_int
  subroutine MakeHDF5AttributeDSN_int ( fileID, &
   & dataName, attrName, value, skip_if_already_there )
d655 1
a655 1
    integer, intent(in) :: VALUE        ! Value of attribut
d668 4
a671 5
    endif
    dataID = name_to_dataID( fileID, dataName)
    call MakeHDF5Attribute_int( &
     & dataID, attrName, value )
    call h5dclose_f(dataID, status)
d673 1
a673 1
      & 'Unable to close data '//trim(dataName) )
d677 1
a677 1
  ! ------------------------------------- MakeHDF5AttributeDSN_logical
d680 3
a682 3
  ! all becuase of the skip_if_already_there optional argument
  subroutine MakeHDF5AttributeDSN_logical ( fileID, &
   & dataName, attrName, value, skip_if_already_there )
d699 1
a699 1
    endif
d701 2
a702 3
    call MakeHDF5Attribute_logical( &
     & dataID, attrName, value )
    call h5dclose_f(dataID, status)
d704 1
a704 1
      & 'Unable to close data '//trim(dataName) )
d708 3
a710 3
  ! ------------------------------------- MakeHDF5AttributeDSN_string
  subroutine MakeHDF5AttributeDSN_string ( fileID, &
   & dataName, attrName, value, skip_if_already_there )
d727 1
a727 1
    endif
d732 5
a736 6
      & 'Inconsistency between file/dataName for attribute '//trim(attrName) )
      endif
    endif
    call MakeHDF5Attribute_string( &
     & dataID, attrName, value )
    call h5dclose_f(dataID, status)
d738 1
a738 1
      & 'Unable to close data '//trim(dataName) )
d742 3
a744 3
  ! ------------------------------------- MakeHDF5AttributeDSN_st_arr1
  subroutine MakeHDF5AttributeDSN_st_arr1 ( fileID, &
   & dataName, attrName, value, skip_if_already_there )
d761 1
a761 1
    endif
d763 1
a763 2
    call MakeHDF5Attribute_string_arr1( &
     & dataID, attrName, value )
d766 1
a766 1
      & 'Unable to close data '//trim(dataName) )
d770 3
a772 3
  ! ------------------------------------- MakeHDF5AttributeDSN_snglarr1
  subroutine MakeHDF5AttributeDSN_snglarr1 ( fileID, &
   & dataName, attrName, value, skip_if_already_there )
d789 1
a789 1
    endif
d792 1
a792 1
    call h5dclose_f(dataID, status)
d794 1
a794 1
      & 'Unable to close data '//trim(dataName) )
d798 3
a800 3
  ! ------------------------------------- MakeHDF5AttributeDSN_dblarr1
  subroutine MakeHDF5AttributeDSN_dblarr1 ( fileID, &
   & dataName, attrName, value, skip_if_already_there )
d817 1
a817 1
    endif
d820 1
a820 1
    call h5dclose_f(dataID, status)
d822 1
a822 1
      & 'Unable to close data '//trim(dataName) )
d826 1
a826 1
  ! ------------------------------------------- GetHDF5Attribute_int
d828 1
a828 1
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
d830 1
a830 1
    integer, intent(out) :: VALUE       ! Result
d839 1
a839 1
      & 'Unable to open attribute '//trim(name) )
d845 1
a845 1
      & 'Unable to read attribute '//trim(name) )
d848 1
a848 1
      & 'Unable to close attribute '//trim(name) )
d850 2
a851 2
   
  ! ------------------------------------------- GetHDF5Attribute_intarr1
d853 1
a853 1
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
d855 1
a855 1
    integer, intent(out) :: VALUE(:)       ! Result
d866 1
a866 1
      & 'Unable to open attribute '//trim(name) )
d870 1
a870 1
    call h5aread_f ( attrID, H5T_NATIVE_INTEGER, value, & 
d873 1
a873 1
      & 'Unable to read attribute '//trim(name) )
d876 1
a876 1
      & 'Unable to close attribute '//trim(name) )
d879 36
a914 1
  ! ------------------------------------------- GetHDF5Attribute_string
d916 2
a917 2
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
d929 1
a929 1
      & 'Unable to open attribute '//trim(name) )
d932 1
a932 1
      & 'Unable to get type for attribute '//trim(name) )
d935 1
a935 1
      & 'Unable to get size for attribute '//trim(name) )
d937 1
a937 1
      & 'Value too long to fit in space given for attribute '//trim(name) )
d942 1
a942 1
      & 'Unable to read attribute '//trim(name) )
d945 1
a945 1
      & 'Unable to close attribute '//trim(name) )
d948 1
a948 1
      & 'Unable to close string type for attribute '//trim(name) )
d950 3
a952 3
   
  ! ------------------------------------------- GetHDF5Attribute_string_arr1
  subroutine GetHDF5Attribute_string_arr1 ( itemID, name, value )
d968 1
a968 1
      & 'Unable to open attribute '//trim(name) )
d971 1
a971 1
      & 'Unable to get type for 1-d string attribute '//trim(name) )
d974 3
a976 3
      & 'Unable to get size for 1-d string attribute '//trim(name) )
    if ( stringSize > len(value(1)) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for attribute '//trim(name) )
d980 1
a980 1
    call h5aread_f ( attrID, stringType, value, & 
d983 49
a1031 1
      & 'Unable to read attribute '//trim(name) )
d1034 1
a1034 1
      & 'Unable to close attribute '//trim(name) )
d1037 4
a1040 4
      & 'Unable to close string type for attribute '//trim(name) )
  end subroutine GetHDF5Attribute_string_arr1
   
  ! ------------------------------------- GetHDF5Attribute_logical
d1042 1
a1042 1
    integer, intent(in) :: ITEMID       ! Group etc. to get attr to.
d1044 1
a1044 1
    logical, intent(out) :: VALUE        ! Value of attribute
d1047 1
a1047 1
    integer :: IVALUE                   ! Value as integer
d1054 33
a1086 1
  ! ------------------------------------------- GetHDF5Attribute_snglarr1
d1101 1
a1101 1
      & 'Unable to open attribute '//trim(name) )
d1108 1
a1108 1
      & 'Unable to read 1d attribute array '//trim(name) )
d1111 1
a1111 1
      & 'Unable to close 1d attribute array  '//trim(name) )
d1113 37
a1149 2
   
  ! ------------------------------------------- GetHDF5Attribute_sngl
d1162 1
a1162 1
      & 'Unable to open attribute '//trim(name) )
d1169 1
a1169 1
      & 'Unable to read sngl attribute '//trim(name) )
d1172 1
a1172 1
      & 'Unable to close sngl attribute  '//trim(name) )
d1174 2
a1175 2
   
  ! ------------------------------------------- GetHDF5Attribute_dbl
d1188 1
a1188 1
      & 'Unable to open attribute '//trim(name) )
d1192 1
a1192 2
    call h5aread_f ( attrID, H5T_NATIVE_DOUBLE, value, &
      & ones, status )
d1194 1
a1194 1
      & 'Unable to read dble attribute '//trim(name) )
d1197 1
a1197 1
      & 'Unable to close dble attribute  '//trim(name) )
d1199 2
a1200 2
   
  ! ------------------------------------------- GetHDF5Attribute_dblarr1
d1215 1
a1215 1
      & 'Unable to open attribute '//trim(name) )
d1222 1
a1222 1
      & 'Unable to read dblarr1 attribute '//trim(name) )
d1225 1
a1225 1
      & 'Unable to close dblarr1 attribute  '//trim(name) )
d1228 74
a1301 1
  ! ------------------------------------- GetHDF5DSDims
d1303 1
a1303 1
    integer, intent(in) :: FILEID       ! fileID
d1305 1
a1305 1
    integer(kind=hSize_t), dimension(:), intent(out) :: DIMS        ! Values of dimensions
d1318 1
a1318 1
    if (present(maxDims)) maxDims = -1
d1321 4
a1324 4
      & 'Unable to turn error messages off before getting dims '//trim(name) )
    call h5dOpen_f ( FileID, trim(name), setID, status ) 
    call h5dget_space_f(setID,dspace_id,status)
    call h5sget_simple_extent_ndims_f(dspace_id,rank,status)
d1327 2
a1328 2
    call h5sget_simple_extent_dims_f(dspace_id,dims(1:my_rank),&
         maxdims_ptr(1:my_rank),status)
d1330 1
a1330 1
      & 'Unable to get dims for datset '//trim(name) )
d1332 1
a1332 3
    if ( present(maxDims) ) then
      maxdims = maxdims_ptr(1:my_rank)
    endif
d1336 1
a1336 1
      & 'Unable to turn error messages back on after getting dims '//trim(name) )
d1339 1
a1339 1
  ! ------------------------------------- GetHDF5DSRank
d1351 1
a1351 1
    rank = -1                          ! means trouble
d1354 2
a1355 2
      & 'Unable to turn error messages off before getting rank '//trim(name) )
    call h5dOpen_f ( FileID, trim(name), setID, status ) 
d1361 1
a1361 1
      & 'Unable to turn error messages back on after getting rank '//trim(name) )
d1364 1
a1364 1
  ! ------------------------------------- GetHDF5DSQType
d1371 1
a1371 1
    integer :: type_id                 ! typeID for DS
d1376 1
a1376 1
    Qtype = 'unknown'                          ! means trouble
d1379 2
a1380 2
      & 'Unable to turn error messages off before getting rank '//trim(name) )
    call h5dOpen_f ( FileID, trim(name), setID, status ) 
d1384 4
a1387 4
      Qtype = 'integer'                                        
    elseif ( AreThe2TypesEqual(type_id, H5T_NATIVE_CHARACTER) ) then
      Qtype = 'character'                                      
    elseif ( AreThe2TypesEqual(type_id, H5T_NATIVE_REAL) .or. &
d1389 2
a1390 2
      Qtype = 'real'                                           
    elseif ( AreThe2TypesEqual(type_id, H5T_NATIVE_DOUBLE) .or. &
d1392 2
a1393 2
      Qtype = 'double'                                         
    endif                                                               
d1397 1
a1397 1
      & 'Unable to turn error messages back on after getting rank '//trim(name))
d1400 1
a1400 1
  ! --------------------------------------------- IsHDF5AttributeInFile ---
d1411 1
a1411 1
    
d1416 1
a1416 1
      & 'Unable to turn error messages off before looking for attribute '//trim(name) )
d1425 1
a1425 1
        endif
d1432 1
a1432 1
      & 'Unable to turn error messages back on after looking for attribute '//trim(name) )
d1435 1
a1435 1
  ! --------------------------------------------- IsHDF5DSInFile ---
d1444 1
a1444 1
    
d1449 1
a1449 1
      & 'Unable to turn error messages off before looking for DS '//trim(name) )
d1461 1
a1461 1
      & 'Unable to turn error messages back on after looking for DS '//trim(name) )
d1464 1
a1464 1
  ! -------------------------------- IsHDF5AttributePresent_in_DSID ---
d1472 1
a1472 1
    
d1476 2
a1477 2
      & 'Unable to turn error messages off before looking for attribute '//trim(name) )
    call h5aOpen_name_f ( SETID, name, attrID, status ) 
d1486 1
a1486 1
      & 'Unable to turn error messages back on after looking for attribute '//trim(name) )
d1489 1
a1489 1
  ! -------------------------------- IsHDF5AttributePresent_in_fID ---
d1503 1
a1503 1
    
d1511 1
a1511 1
    endif
d1514 1
a1514 1
      & 'Unable to turn error messages off before looking for attribute '//trim(name) )
d1527 1
a1527 1
    endif
d1530 1
a1530 1
      & 'Unable to turn error messages back on after looking for attribute '//trim(name) )
d1533 1
a1533 1
  ! -------------------------------- IsHDF5AttributePresent_in_grp ---
d1543 1
a1543 1
    
d1547 1
a1547 1
      & 'Unable to turn error messages off before looking for attribute '//trim(name) )
d1560 1
a1560 1
    endif
d1563 1
a1563 1
      & 'Unable to turn error messages back on after looking for attribute '//trim(name) )
d1566 1
a1566 1
  ! --------------------------------------------- IsHDF5DSPresent ---
d1574 1
a1574 1
    
d1578 2
a1579 2
      & 'Unable to turn error messages off before looking for DS '//trim(name) )
    call h5dOpen_f ( locID, name, setID, status ) 
d1588 1
a1588 1
      & 'Unable to turn error messages back on after looking for DS '//trim(name) )
d1591 1
a1591 1
  ! --------------------------------------------- SaveAsHDF5DS_charsclr
d1594 3
a1596 3
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
    character (len=*), intent(in) :: NAME ! Name for this dataset
    character (len=*), intent(in) :: VALUE     ! The scalar char string
d1611 1
a1611 1
      & 'Unable to create dataspace for 1D integer array '//trim(name) )
d1613 2
a1614 2
    call h5tcopy_f(type_id, s_type_id, status)
    call h5tset_size_f(s_type_id, len(value), status)
d1619 1
a1619 1
      & 'Unable to create dataset for 1D integer array '//trim(name) )
d1623 1
a1623 9
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 1D integer array '//trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 1D integer array '//trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 1D integer array '//trim(name) )
d1626 1
a1626 1
  ! --------------------------------------------- SaveAsHDF5DS_chararr1
d1630 1
a1630 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d1646 1
a1646 1
    maxdims=shp
d1649 1
a1649 1
    call h5tcopy_f( H5T_NATIVE_CHARACTER, stringtype, status ) 
d1651 2
a1652 2
      & 'Unable to create stringtype for array'//trim(name) )
    call h5tset_size_f(stringtype, max(len(value(1)), 1), status )
d1654 1
a1654 1
      & 'Unable to set size for stringtype '//trim(name) )
d1658 1
a1658 1
 !      & 'Unable to create dataspace for 1D char array '//trim(name) )
d1663 1
a1663 1
 !        & 'Unable to create property list for 1D char array '//trim(name) )
d1665 1
a1665 1
 !      if (status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
d1672 3
a1674 3
 !    endif
    call createSpaceSet(locID, name, 1, maxdims, stringtype, &
    & spaceID, setID, status, adding_to, cFill=FillValue)
d1676 1
a1676 1
      & 'Unable to create dataset for 1D char array '//trim(name) )
d1680 1
a1680 12
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 1D char array '//trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 1D char array '//trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 1D char array '//trim(name) )
    call h5tClose_f ( stringtype, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close stringtype '//trim(name) )
d1683 1
a1683 1
  ! --------------------------------------------- SaveAsHDF5DS_chararr2
d1687 1
a1687 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d1703 1
a1703 1
    maxdims=shp
d1706 1
a1706 1
    call h5tcopy_f( H5T_NATIVE_CHARACTER, stringtype, status ) 
d1708 2
a1709 2
      & 'Unable to create stringtype for array'//trim(name) )
    call h5tset_size_f(stringtype, max(len(value(1,1)), 1), status )
d1711 1
a1711 1
      & 'Unable to set size for stringtype '//trim(name) )
d1715 1
a1715 1
 !      & 'Unable to create dataspace for 2D char array '//trim(name) )
d1720 1
a1720 1
 !        & 'Unable to create property list for 2D char array '//trim(name) )
d1722 1
a1722 1
 !      if (status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
d1729 3
a1731 3
 !    endif
    call createSpaceSet(locID, name, 2, maxdims, stringtype, &
    & spaceID, setID, status, adding_to, cFill=fillValue)
d1733 1
a1733 1
      & 'Unable to create dataset for 2D char array '//trim(name) )
d1737 1
a1737 12
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 2D char array '//trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 2D char array '//trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 2D char array '//trim(name) )
    call h5tClose_f ( stringtype, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close stringtype '//trim(name) )
d1740 1
a1740 1
  ! --------------------------------------------- SaveAsHDF5DS_intarr1
d1759 1
a1759 1
    maxdims=shp
d1762 1
a1762 1
    call createSpaceSet(locID, name, 1, maxdims, H5T_NATIVE_INTEGER, &
d1765 1
a1765 1
      & 'Unable to create dataset for 1D integer array '//trim(name) )
d1769 1
a1769 9
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 1D integer array '//trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 1D integer array '//trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 1D integer array '//trim(name) )
d1772 1
a1772 1
  ! --------------------------------------------- SaveAsHDF5DS_intarr2
d1776 1
a1776 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d1791 1
a1791 1
    maxdims=shp
d1794 1
a1794 1
    call createSpaceSet(locID, name, 2, maxdims, H5T_NATIVE_INTEGER, &
d1797 1
a1797 1
      & 'Unable to create dataset for 2D integer array '//trim(name) )
d1801 1
a1801 9
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 2D integer array '//trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 2D integer array '//trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 2D integer array '//trim(name) )
d1804 1
a1804 1
  ! --------------------------------------------- SaveAsHDF5DS_intarr3
d1823 1
a1823 1
    maxdims=shp
d1826 2
a1827 2
    call createSpaceSet(locID, name, 3, maxdims, H5T_NATIVE_INTEGER, &
      & spaceID, setID, status, adding_to, iFill=fillValue)
d1829 1
a1829 1
      & 'Unable to create dataset for 3D integer array '//trim(name) )
d1833 1
a1833 9
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 3D integer array '//trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 3D integer array '//trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 3D integer array '//trim(name) )
d1836 30
a1865 1
  ! --------------------------------------------- SaveAsHDF5DS_dblarr1
d1869 1
a1869 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d1884 1
a1884 1
    maxdims=shp
d1887 2
a1888 2
    call createSpaceSet(locID, name, 1, maxdims, H5T_NATIVE_DOUBLE, &
      & spaceID, setID, status, adding_to, dFill=fillValue)
d1890 1
a1890 1
      & 'Unable to create dataset for 1D double array '//trim(name) )
d1894 1
a1894 9
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 1D double array '//trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 1D double array '//trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 1D double array '//trim(name) )
d1897 1
a1897 1
  ! --------------------------------------------- SaveAsHDF5DS_dblarr2
d1901 1
a1901 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d1916 1
a1916 1
    maxdims=shp
d1919 2
a1920 2
    call createSpaceSet(locID, name, 2, maxdims, H5T_NATIVE_DOUBLE, &
      & spaceID, setID, status, adding_to, dFill=fillValue)
d1922 1
a1922 1
      & 'Unable to create dataset for 2D double array '//trim(name) )
d1926 1
a1926 9
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 2D double array '//trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 2D double array '//trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 2D double array '//trim(name) )
d1929 1
a1929 1
  ! --------------------------------------------- SaveAsHDF5DS_dblarr3
d1933 1
a1933 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d1948 1
a1948 1
    maxdims=shp
d1951 2
a1952 2
    call createSpaceSet(locID, name, 3, maxdims, H5T_NATIVE_DOUBLE, &
      & spaceID, setID, status, adding_to, dFill=fillValue)
d1954 1
a1954 1
      & 'Unable to create dataset for 3D double array '//trim(name) )
d1958 1
a1958 9
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 3D double array '//trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 3D double array '//trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 3D double array '//trim(name) )
d1961 1
a1961 1
  ! --------------------------------------------- SaveAsHDF5DS_snglarr1
d1983 2
a1984 2
    call createSpaceSet(locID, name, 1, maxdims, H5T_NATIVE_REAL, &
      & spaceID, setID, status, adding_to, rFill=fillValue)
d1986 1
a1986 1
      & 'Unable to create dataset for 1D double array '//trim(name) )
d1990 1
a1990 9
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 1D double array '//trim(name) )
    ! Close things
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 1D double array '//trim(name) )
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 1D double array '//trim(name) )
d1993 1
a1993 1
  ! --------------------------------------------- SaveAsHDF5DS_snglarr2
d2032 1
a2032 1
    endif
d2035 1
a2035 1
    endif
d2037 1
a2037 1
      
d2044 1
a2044 1
    if (style == 0) then
d2048 1
a2048 1
        & 'Unable to create dataspace for 2D real array '//trim(name) )
d2052 1
a2052 1
          & 'Unable to create property list for 2D real array '//trim(name) )
d2054 1
a2054 1
        if (status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
d2061 1
a2061 1
      endif
d2063 1
a2063 1
        & 'Unable to create dataset for 2D real array '//trim(name) )
d2066 1
a2066 1
    elseif (style == 1) then
d2075 1
a2075 1
      call h5screate_simple_f(2, dims, memspaceID, status, maxdims)
d2077 1
a2077 1
        & 'Unable to create memspace for 2D real array '//trim(name) )
d2081 1
a2081 1
        & 'Unable to create property list for 2D real array '//trim(name) )
d2084 1
a2084 1
        & 'Unable to set chunking 2D real array '//trim(name) )
d2087 1
a2087 1
        if (status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
d2089 1
a2089 1
      endif
d2093 1
a2093 1
        & 'Unable to create dataset for 2D real array '//trim(name) )
d2096 1
a2096 1
        & 'Unable to extend dataset creating 2D real array '//trim(name) )
d2099 1
a2099 1
        & 'Unable to get filespaceID creating 2D real array '//trim(name) )
d2109 1
a2109 1
        & 'Unable to open dataset for 2D real array '//trim(name) )
d2111 1
a2111 1
      call h5dget_space_f( setID, spaceID, status)
d2113 1
a2113 1
        & 'Unable to get dataspace for 2D real array '//trim(name) )
d2117 1
a2117 1
      !  & 'Unable to get space rank for 2D real array '//trim(name) )
d2122 1
a2122 1
      ! & 'Unable to get dims for datset '//trim(name) )
d2131 1
a2131 1
      !  & 'Unable to extend dims for 2D real array '//trim(name) )
d2137 1
a2137 1
        & 'Unable to get dataspace for 2D real array '//trim(name) )
d2139 1
a2139 1
    endif
d2143 1
a2143 2
      call mls_hyperslab_save(filespaceID, &
        & start, count, stride, block)
d2148 2
a2149 3
      if ( style == 2 ) then
        call h5screate_simple_f(2, dims, memspaceID, status, maxdims)
      endif
d2155 1
a2155 1
     !   & 'Unable to get dims for datset '//trim(name) )
d2169 1
a2169 1
     !   & 'Unable to get dims for datset '//trim(name) )
d2185 1
a2185 9
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &   
      & 'Unable to write to dataset for 2D real array '//trim(name) )  
    ! Close things
   ! print *, 'Before closing other, mem space ', memspaceID
   ! print *, 'Attempting to close data space ', spaceID
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 2D real array '//trim(name) )
d2187 4
a2190 8
     ! print *, 'Attempting to close mem space ', memspaceID
      call h5sClose_F ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close mem dataspace for 2D real array '//trim(name) )
    endif
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 2D real array '//trim(name) )
d2193 1
a2193 1
  ! --------------------------------------------- SaveAsHDF5DS_snglarr3
d2232 1
a2232 1
    endif
d2235 1
a2235 1
    endif
d2244 1
a2244 1
    if (style == 0) then
d2247 1
a2247 1
        & 'Unable to create dataspace for 3D real array '//trim(name) )
d2250 1
a2250 1
        call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
d2252 3
a2254 3
          & 'Unable to create property list for 3D real array '//trim(name) )
        call h5pset_fill_value_f (cparms, H5T_NATIVE_REAL, fillValue, status)
        if (status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
d2261 1
a2261 1
      endif
d2263 1
a2263 1
        & 'Unable to create dataset for 3D real array '//trim(name) )
d2266 1
a2266 1
    elseif (style == 1) then
d2276 2
a2277 2
      !  & 'Unable to create filespace for 3D real array '//trim(name) )
      call h5screate_simple_f(3, dims, memspaceID, status, maxdims)
d2279 1
a2279 1
        & 'Unable to create memspace for 3D real array '//trim(name) )
d2281 1
a2281 1
      call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
d2283 1
a2283 1
        & 'Unable to create property list for 3D real array '//trim(name) )
d2286 1
a2286 1
        & 'Unable to set chunking 3D real array '//trim(name) )
d2288 2
a2289 2
        call h5pset_fill_value_f (cparms, H5T_NATIVE_REAL, fillValue, status)
        if (status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
d2291 1
a2291 1
      endif
d2295 1
a2295 1
        & 'Unable to create dataset for 3D real array '//trim(name) )
d2298 1
a2298 1
        & 'Unable to extend dataset creating 3D real array '//trim(name) )
d2301 1
a2301 1
        & 'Unable to get filespaceID creating 3D real array '//trim(name) )
d2310 2
a2311 2
        & 'Unable to open dataset for 3D real array '//trim(name) )
      call h5dget_space_f( setID, spaceID, status)
d2313 1
a2313 1
      !   & 'Unable to get dataspace for 3D real array '//trim(name) )
d2316 1
a2316 1
      !   & 'Unable to get space rank for 3D real array '//trim(name) )
d2323 1
a2323 1
      !   & 'Unable to extend dims for 3D real array '//trim(name) )
d2327 1
a2327 1
      call h5dget_space_f( setID, filespaceID, status)
d2329 2
a2330 2
        & 'Unable to get dataspace for 3D real array '//trim(name) )
    endif
d2333 1
a2333 1
      if ( DEEBUG ) print *, 'shape(value) ', shape(value)
d2337 3
a2339 5
      call mls_hyperslab_save(filespaceID, &
        & start, count, stride, block)
      if ( style == 2 ) then
        call h5screate_simple_f(3, dims, memspaceID, status, maxdims)
      endif
d2352 1
a2352 7
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &   
      & 'Unable to write to dataset for 3D real array '//trim(name) )  
    ! Close things
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 3D real array '//trim(name) )
d2354 4
a2357 7
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 3D real array '//trim(name) )
d2360 1
a2360 1
  ! --------------------------------------------- SaveAsHDF5DS_snglarr4
d2395 1
a2395 1
    endif
d2398 1
a2398 1
    endif
d2407 1
a2407 1
    if (style == 0) then
d2410 1
a2410 1
        & 'Unable to create dataspace for 4D real array '//trim(name) )
d2413 1
a2413 1
        call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
d2415 4
a2418 4
          & 'Unable to create property list for 4D real array '//trim(name) )
        call h5pset_fill_value_f (cparms, H5T_NATIVE_REAL, fillValue, status)
        if (status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
          &  "Unable to set Fill value for 4D real array " // trim (name))
d2424 1
a2424 1
      endif
d2426 1
a2426 1
        & 'Unable to create dataset for 4D real array '//trim(name) )
d2429 1
a2429 1
    elseif (style == 1) then
d2437 1
a2437 1
      call h5screate_simple_f(4, dims, memspaceID, status, maxdims)
d2439 1
a2439 1
        & 'Unable to create memspace for 4D real array '//trim(name) )
d2441 1
a2441 1
      call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
d2443 2
a2444 2
        & 'Unable to create property list for 4D real array '//trim(name) )
      call h5pset_chunk_f(cparms, 4, chunk_dims, status)
d2446 1
a2446 1
        & 'Unable to set chunking 4D real array '//trim(name) )
d2448 4
a2451 4
        call h5pset_fill_value_f (cparms, H5T_NATIVE_REAL, fillValue, status)
        if (status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
          &  "Unable to set Fill value for 4D real array " // trim (name))
      endif
d2455 1
a2455 1
        & 'Unable to create dataset for 4D real array '//trim(name) )
d2458 2
a2459 2
        & 'Unable to extend dataset creating 4D real array '//trim(name) )
      call h5dget_space_f(setID, filespaceID, status)
d2461 1
a2461 1
        & 'Unable to get filespaceID creating 4D real array '//trim(name) )
d2470 3
a2472 4
        & 'Unable to open dataset for 4D real array '//trim(name) )
      call h5dget_space_f( setID, spaceID, status)
      if ( .not. present(start) ) &
        & call mls_extend ( setID, shp )
d2474 1
a2474 1
      call h5dget_space_f( setID, filespaceID, status)
d2476 2
a2477 2
        & 'Unable to get dataspace for 4D real array '//trim(name) )
    endif
d2480 1
a2480 1
      if ( DEEBUG ) print *, 'shape(value) ', shape(value)
d2484 3
a2486 5
      call mls_hyperslab_save(filespaceID, &
        & start, count, stride, block)
      if ( style == 2 ) then
        call h5screate_simple_f(4, dims, memspaceID, status, maxdims)
      endif
d2488 1
a2488 1
      call dump_space(filespaceID)
d2490 1
a2490 1
      call dump_space(memspaceID)
d2499 1
a2499 7
    endif
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &   
      & 'Unable to write to dataset for 4D real array '//trim(name) )  
    ! Close things
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 4D real array '//trim(name) )
d2501 4
a2504 7
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_F ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset for 4D real array '//trim(name) )
d2507 1
a2507 1
  ! ----------------------------------- LoadFromHDF5DS_chararr1
d2511 1
a2511 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d2515 1
a2515 1
                                 ! Starting coordinatess of hyperslab
a2521 2
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7
d2527 1
a2527 1
    integer :: MEMSPACEID                  ! ID of dataspace
d2536 1
a2536 1
      & 'Unable to open dataset '//trim(name) )
d2539 1
a2539 1
      & 'Unable to get type for 1D char array '//trim(name) )
d2542 3
a2544 3
      & 'Unable to get size for 1D char array '//trim(name) )
    if ( stringSize > len(value(1)) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 1D car array '//trim(name) )
d2547 1
a2547 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d2549 5
a2553 4
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
      call h5dread_f(setID, stringtype, value, &
        & (/ shape(value), ones(1:6) /), status, memspaceID, spaceID )
d2555 26
a2580 4
      call check_for_fit(spaceID, shape(value), name)
      call h5dread_f ( setID, stringtype, value, &
        & (/ shape(value), ones(1:6) /), status )
    endif
d2582 2
a2583 3
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
d2585 2
a2586 7
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
d2588 4
a2591 2
      & 'Unable to close dataset '//trim(name) )
    call h5tClose_f ( stringType, status )
d2593 9
a2601 2
      & 'Unable to close string type for 1D char array '//trim(name) )
  end subroutine LoadFromHDF5DS_chararr1
d2603 1
a2603 1
  ! ----------------------------------- LoadFromHDF5DS_chararr2
d2607 1
a2607 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
a2617 2
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7
d2623 1
a2623 1
    integer :: MEMSPACEID                  ! ID of dataspace
d2632 1
a2632 1
      & 'Unable to open dataset '//trim(name) )
d2635 1
a2635 1
      & 'Unable to get type for 2D char array '//trim(name) )
d2638 3
a2640 3
      & 'Unable to get size for 2D char array '//trim(name) )
    if ( stringSize > len(value(1,1)) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Value too long to fit in space given for 2D char array '//trim(name) )
d2643 1
a2643 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d2645 5
a2649 4
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
      call h5dread_f(setID, stringtype, value, &
        & (/ shape(value), ones(1:5) /), status, memspaceID, spaceID )
d2651 24
a2674 4
      call check_for_fit(spaceID, shape(value), name)
      call h5dread_f ( setID, stringtype, value, &
        & (/ shape(value), ones(1:5) /), status )
    endif
d2676 2
a2677 3
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
d2679 2
a2680 7
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
d2682 4
a2685 2
      & 'Unable to close dataset '//trim(name) )
    call h5tClose_f ( stringType, status )
d2687 6
a2692 2
      & 'Unable to close string type for 2D char array '//trim(name) )
  end subroutine LoadFromHDF5DS_chararr2
d2694 1
a2694 1
  ! ----------------------------------- LoadFromHDF5DS_intarr1
d2698 1
a2698 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d2700 1
a2700 1
    integer, intent(out) :: VALUE(:)    ! The array itself
a2708 2
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7
d2714 1
a2714 1
    integer :: MEMSPACEID                  ! ID of dataspace
d2721 1
a2721 1
      & 'Unable to open dataset '//trim(name) )
d2724 1
a2724 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d2726 5
a2730 4
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
      call h5dread_f(setID, H5T_NATIVE_INTEGER, value, &
        & (/ shape(value), ones(1:6) /), status, memspaceID, spaceID )
d2732 1
a2732 1
      call check_for_fit(spaceID, shape(value), name)
d2734 23
a2756 2
        & (/ shape(value), ones(1:6) /), status )
    endif
d2758 2
a2759 3
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
d2761 10
a2770 10
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset '//trim(name) )
  end subroutine LoadFromHDF5DS_intarr1
d2772 1
a2772 1
  ! ----------------------------------- LoadFromHDF5DS_intarr2
d2776 1
a2776 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
a2786 3
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7

d2791 1
a2791 1
    integer :: MEMSPACEID                  ! ID of dataspace
d2798 1
a2798 1
      & 'Unable to open dataset '//trim(name) )
d2801 1
a2801 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d2803 5
a2807 4
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
      call h5dread_f(setID, H5T_NATIVE_INTEGER, value, &
        & (/ shape(value), ones(1:5) /), status, memspaceID, spaceID )
d2809 1
a2809 1
      call check_for_fit(spaceID, shape(value), name)
d2811 21
a2831 2
        & (/ shape(value), ones(1:5) /), status )
    endif
d2833 2
a2834 3
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
d2836 54
a2889 10
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset '//trim(name) )
  end subroutine LoadFromHDF5DS_intarr2
d2891 1
a2891 1
  ! ----------------------------------- LoadFromHDF5DS_dblarr1
a2906 3
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7

d2911 1
a2911 1
    integer :: MEMSPACEID                  ! ID of dataspace
d2918 1
a2918 1
      & 'Unable to open dataset '//trim(name) )
d2921 1
a2921 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d2923 2
a2924 2
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
d2926 2
a2927 1
        & (/ shape(value), ones(1:6) /), status, memspaceID, spaceID )
d2929 1
a2929 1
      call check_for_fit(spaceID, shape(value), name)
d2931 23
a2953 3
        & (/ shape(value), ones(1:6) /), status )
    endif
    ! Now, (at last!) read the data
d2955 2
a2956 11
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
d2958 10
a2967 2
      & 'Unable to close dataset '//trim(name) )
  end subroutine LoadFromHDF5DS_dblarr1
d2969 1
a2969 1
  ! ----------------------------------- LoadFromHDF5DS_dblarr2
a2984 3
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7

d2989 1
a2989 1
    integer :: MEMSPACEID                  ! ID of dataspace
d2996 1
a2996 1
      & 'Unable to open dataset '//trim(name) )
d2999 1
a2999 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d3001 5
a3005 4
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
      call h5dread_f(setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shape(value), ones(1:5) /), status, memspaceID, spaceID )
d3007 1
a3007 1
      call check_for_fit(spaceID, shape(value), name)
d3009 21
a3029 2
        & (/ shape(value), ones(1:5) /), status )
    endif
d3031 2
a3032 3
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
d3034 7
a3040 10
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset '//trim(name) )
  end subroutine LoadFromHDF5DS_dblarr2
d3042 1
a3042 1
  ! ----------------------------------- LoadFromHDF5DS_dblarr3
a3057 3
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7

d3062 1
a3062 1
    integer :: MEMSPACEID                  ! ID of dataspace
d3069 1
a3069 1
      & 'Unable to open dataset '//trim(name) )
d3072 1
a3072 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d3074 5
a3078 4
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
      call h5dread_f(setID, H5T_NATIVE_DOUBLE, value, &
        & (/ shape(value), ones(1:4) /), status, memspaceID, spaceID )
d3080 1
a3080 1
      call check_for_fit(spaceID, shape(value), name)
d3082 21
a3102 2
        & (/ shape(value), ones(1:4) /), status )
    endif
d3104 2
a3105 3
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
d3107 8
a3114 10
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataset '//trim(name) )
  end subroutine LoadFromHDF5DS_dblarr3
d3116 1
a3116 1
  ! ----------------------------------- LoadFromHDF5DS_snglarr1
d3120 1
a3120 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d3122 1
a3122 1
    real, intent(out) :: VALUE(:)       ! The array itself
a3131 3
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7

d3136 1
a3136 1
    integer :: MEMSPACEID                  ! ID of dataspace
d3143 1
a3143 1
      & 'Unable to open dataset '//trim(name) )
d3146 1
a3146 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d3148 5
a3152 4
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
      call h5dread_f(setID, H5T_NATIVE_REAL, value, &
        & (/ shape(value), ones(1:6) /), status, memspaceID, spaceID )
d3154 1
a3154 1
      call check_for_fit(spaceID, shape(value), name)
d3156 23
a3178 2
        & (/ shape(value), ones(1:6) /), status )
    endif
d3180 2
a3181 11
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
d3183 10
a3192 2
      & 'Unable to close dataset '//trim(name) )
  end subroutine LoadFromHDF5DS_snglarr1
d3194 1
a3194 1
  ! ----------------------------------- LoadFromHDF5DS_snglarr2
d3198 1
a3198 1
    integer, intent(in) :: LOCID        ! Where to place it (group/file)
d3200 1
a3200 1
    real, intent(out) :: VALUE(:,:)     ! The array itself
a3209 3
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7

d3214 1
a3214 1
    integer :: MEMSPACEID                  ! ID of dataspace
d3221 1
a3221 1
      & 'Unable to open dataset '//trim(name) )
d3224 1
a3224 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d3226 5
a3230 4
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
      call h5dread_f(setID, H5T_NATIVE_REAL, value, &
        & (/ shape(value), ones(1:5) /), status, memspaceID, spaceID )
d3232 1
a3232 1
      call check_for_fit(spaceID, shape(value), name)
d3234 21
a3254 2
        & (/ shape(value), ones(1:5) /), status )
    endif
d3256 2
a3257 11
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
d3259 7
a3265 2
      & 'Unable to close dataset '//trim(name) )
  end subroutine LoadFromHDF5DS_snglarr2
d3267 1
a3267 1
  ! ----------------------------------- LoadFromHDF5DS_snglarr3
a3282 3
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7

d3287 1
a3287 1
    integer :: MEMSPACEID                  ! ID of dataspace
d3294 1
a3294 1
      & 'Unable to open dataset '//trim(name) )
d3297 1
a3297 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d3299 5
a3303 4
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
      call h5dread_f(setID, H5T_NATIVE_REAL, value, &
        & (/ shape(value), ones(1:4) /), status, memspaceID, spaceID )
d3305 1
a3305 1
      call check_for_fit(spaceID, shape(value), name)
d3307 21
a3327 2
        & (/ shape(value), ones(1:4) /), status )
    endif
d3329 2
a3330 11
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
d3332 8
a3339 2
      & 'Unable to close dataset '//trim(name) )
  end subroutine LoadFromHDF5DS_snglarr3
d3341 1
a3341 1
  ! ----------------------------------- LoadFromHDF5DS_snglarr4
a3356 3
    ! Local parameters
    integer, parameter :: MAXDIMENSIONS = 7

d3361 1
a3361 1
    integer :: MEMSPACEID                  ! ID of dataspace
d3368 1
a3368 1
      & 'Unable to open dataset '//trim(name) )
d3371 1
a3371 1
      & 'Unable to open dataspace for dataset '//trim(name) )
d3373 5
a3377 4
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
        & start, count, stride, block)
      call h5dread_f(setID, H5T_NATIVE_REAL, value, &
        & (/ shape(value), ones(1:3) /), status, memspaceID, spaceID )
d3379 1
a3379 1
      call check_for_fit(spaceID, shape(value), name)
d3381 21
a3401 2
        & (/ shape(value), ones(1:3) /), status )
    endif
d3403 2
a3404 11
      & 'Unable to read dataset '//trim(name) )
    ! Close up
    call h5sClose_f ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for dataset '//trim(name) )
    if ( present(start) ) then
      call h5sClose_f ( memspaceID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to close hyperslab dataspace for dataset '//trim(name) )
    endif
    call h5dClose_f ( setID, status )
d3406 9
a3414 2
      & 'Unable to close dataset '//trim(name) )
  end subroutine LoadFromHDF5DS_snglarr4
d3416 1
a3416 1
  ! ------------------------------------------ ReadLitIndexFromHDF5Attr ---
d3420 1
a3420 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr. for
d3425 1
d3428 3
a3430 2
    if ( len_trim ( line ) > 0 ) then
      index = GetLitIndexFromString ( trim(line) )
d3436 1
a3436 1
  ! ------------------------------------------ ReadStringIndexFromHDF5Attr ---
d3440 1
a3440 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr. for
d3454 1
a3454 1
  ! --------------------------------------- WriteStringIndexAsHDF5Attribute
d3457 1
a3457 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr. for
d3459 1
a3459 1
    integer, intent(in) :: INDEX        ! String index
d3468 1
a3468 1
  ! --------------------------------------- WriteStringIndexAsHDF5Attribute
d3471 1
a3471 1
    integer, intent(in) :: ITEMID       ! Group etc. to make attr. for
d3473 1
a3473 1
    integer, intent(in) :: INDEX        ! String index
d3485 2
a3486 2
! ======================= Private Procedures =========================  
! --------------------------------------------- AreThe2TypesEqual ---
d3495 2
a3496 2
    call h5tEqual_f(type1, type2, AreThe2TypesEqual, status)
    if (status /= 0 ) AreThe2TypesEqual = .false.
d3499 2
a3500 1
  subroutine check_for_fit(spaceID, value_dims, name)
d3502 1
a3502 1
    integer, intent(in)               :: spaceID 
d3505 4
a3508 18
    integer                           :: rank
    integer                           :: value_rank
    integer(hsize_t), dimension(7)    :: dims, maxdims
    integer                           :: status  
    integer                           :: i  
    value_rank = size(value_dims)
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( status /= 0 )  call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset '//trim(name) )
    if ( rank /= value_rank ) call my_message ( MLSMSG_Error, ModuleName, &
      & 'Inconsistant rank for dataset '//trim(name) , &
      & 'rank(space),rank(values)', (/rank, value_rank/) )
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), &
      &  status )
    if ( status /= rank ) call my_message ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset '//trim(name) , &
      & 'rank(space),h5s status', (/rank, status/) )
    if ( any ( dims(1:rank) > value_dims ) ) &
d3510 2
a3511 2
      & 'Dataspace too large for destination value of '//trim(name) , &
      & 'dims(space), dims(value)', (/ (int(dims(i)), value_dims(i), i=1, rank) /), &
d3513 1
a3513 1
  end subroutine check_for_fit
d3515 3
a3517 2
  subroutine createSpaceSet(locID, name, rank, maxdims, datatype, &
    & spaceID, setID, status, adding_to, cFill, dFill, iFill, rFill, chunk_dims)
d3519 1
a3519 1
    integer, intent(in)               :: locID 
a3520 1
    integer, intent(in)               :: rank 
d3522 3
a3524 3
    integer, intent(in)               :: datatype 
    integer, intent(out)              :: spaceID 
    integer, intent(out)              :: setID 
d3535 2
a3536 1
    integer(hsize_t), dimension(rank) :: my_chunkdims, my_maxdims
d3545 1
d3548 1
a3548 1
    my_fill = present(cFill) .or. present(dFill) .or. present(iFill) .or. & 
d3550 1
a3550 1
    if (my_adding_to) then
d3553 2
a3554 2
        & 'Unable to open dataset for '//trim(name) )
      call h5dget_space_f( setID, spaceID, status)
d3556 1
a3556 1
        & 'Unable to get dataspace for '//trim(name) )
d3561 1
a3561 1
        call h5dget_space_f( setID, spaceID, status)
d3563 1
a3563 1
          & 'Unable to get dataspace for '//trim(name) )
d3565 1
a3565 1
        call h5dget_create_plist_f(setID, cparms, status)
d3567 2
a3568 2
          & 'Unable to get property list for '//trim(name) )
        call h5pget_chunk_f(cparms, rank, my_chunkdims, status)
d3572 5
a3576 5
          call h5pget_fill_value_f (cparms, H5T_NATIVE_CHARACTER, cFilled, status)
        elseif ( present(dFill) ) then
          call h5pget_fill_value_f (cparms, datatype, dFilled, status)
        elseif ( present(iFill) ) then
          call h5pget_fill_value_f (cparms, datatype, iFilled, status)
d3579 4
a3582 4
        elseif ( present(rFill) ) then
          call h5pget_fill_value_f (cparms, datatype, rFilled, status)
        endif
      endif
d3591 2
a3592 2
          & 'Unable to create extensible dataspace '//trim(name) )
        call h5pcreate_f(H5P_DATASET_CREATE_F, cparms, status)
d3594 2
a3595 2
          & 'Unable to create property list for '//trim(name) )
        call h5pset_chunk_f(cparms, rank, my_chunkdims, status)
d3599 1
a3599 1
          & 'Unable to set chunking for '//trim(name) )
d3601 5
a3605 5
          call h5pset_fill_value_f (cparms, H5T_NATIVE_CHARACTER, cFill, status)
        elseif ( present(dFill) ) then
          call h5pset_fill_value_f (cparms, datatype, dFill, status)
        elseif ( present(iFill) ) then
          call h5pset_fill_value_f (cparms, datatype, iFill, status)
d3608 1
a3608 1
        elseif ( present(rFill) ) then
d3610 3
a3612 3
        endif
        if (status /= 0) call MLSMessage (MLSMSG_Error, ModuleName, &
          &  "Unable to set Fill value for " // trim (name))
d3616 1
a3616 1
        call h5dget_space_f( setID, spaceID, status)
d3618 1
a3618 1
          & 'Unable to get dataspace for '//trim(name) )
d3622 1
a3622 1
          & 'Unable to create dataspace '//trim(name) )
d3625 3
a3627 3
      endif
    endif
  end subroutine createSpaceSet
d3629 2
a3630 1
  subroutine dump_space(spaceID)
d3632 1
a3632 1
    integer, intent(in)               :: spaceID 
d3635 1
a3635 1
    integer                           :: status  
d3650 109
a3758 1
  end subroutine dump_space
d3760 2
a3761 1
  subroutine mls_extend ( setID, newCount, start, dataSpaceID )
d3765 1
a3765 1
    integer, intent(in)                :: setID 
d3771 1
a3771 1
    integer                           :: spaceID 
d3788 1
a3788 1
    endif
d3792 1
a3792 1
    call h5sget_simple_extent_ndims_f(spaceID, rank, status)
d3796 1
a3796 2
    call h5sget_simple_extent_dims_f(spaceID, dims,&
         maxdims, status)
d3804 1
a3804 1
    endif
d3813 1
a3813 1
      endif
d3818 1
a3818 1
    call h5dextend_f(setID, dims, status)
d3822 1
a3822 1
      call h5dget_space_f(setID, dataspaceID, status)
d3825 2
a3826 2
    endif
  end subroutine mls_extend
d3828 2
a3829 1
  subroutine mls_hyperslab ( spaceID, value_dims, name, memspaceID, &
d3836 2
a3837 2
    integer, intent(in)                :: spaceID 
    integer, intent(out)               :: memspaceID 
d3850 1
a3850 1
    integer                           :: status  
d3860 1
a3860 1
      & 'Impossible optional parameters pattern for dataset '//trim(name), &
d3867 1
a3867 1
      & 'Unable to get rank for dataset '//trim(name) )
d3872 1
a3872 1
      & 'Unable to get dimension information for dataset '//trim(name) )
d3877 2
a3878 2
    if (status /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      & 'Unable to create memspace for dataset '//trim(name) )
d3891 3
a3893 3
    endif
    if (status /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      & 'Unable to set hyperslab for dataset '//trim(name) )
d3895 1
a3895 1
  end subroutine mls_hyperslab
d3897 2
a3898 2
  subroutine mls_hyperslab_save ( spaceID, &
    & start, count, stride, block )
d3904 1
a3904 1
    integer, intent(in)                :: spaceID 
d3926 1
a3926 1
      & 'Impossible optional parameters pattern for dataset '//trim(name), &
d3931 1
a3931 1
      & 'Unable to get rank for dataset '//trim(name) )
d3936 1
a3936 1
      & 'Unable to get dimension information for dataset '//trim(name) )
d3949 10
a3958 9
    endif
    if (status /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      & 'Unable to set hyperslab for dataset '//trim(name) )
  end subroutine mls_hyperslab_save

  subroutine my_message(severity, ModuleNameIn, Message, &
    & names, ints, reals, doubles, no_pairs)
    ! Take opportunity to dump a diagnostic table of values before stopping
    ! Dummy arguments
d3978 7
a3984 7
        call dump(ints, names, &
          & clean=clean, format=int_format, width=width)
      elseif ( present(reals) ) then
        call dump(reals, names, clean=clean)
      elseif ( present(doubles) ) then
        call dump(doubles, names, clean=clean)
      endif
d3987 12
a3998 13
        call dump_name_v_pairs(ints, names, &
          & clean=clean, format=int_format, width=width)
      elseif ( present(reals) ) then
        call dump_name_v_pairs(reals, names, &
          & clean=clean, format=real_format, width=width)
      elseif ( present(doubles) ) then
        call dump_name_v_pairs(doubles, names, &
          & clean=clean, format=dbl_format, width=width)
      endif
    endif
    call MLSMessage ( severity, ModuleNameIn, &
      & message )
  end subroutine my_message
d4000 2
a4001 1
  function name_to_attrID(fileID, dataName, attrName, dont_close) &
d4009 1
a4009 1
    integer, intent(in)               :: fileID 
d4022 1
a4022 1
    call h5dOpen_f ( fileID, dataName, dataID, status ) 
d4024 1
a4024 1
      dataID = -1
d4030 1
a4030 1
        if (.not. my_dont_close) call h5aClose_f ( attrID, status )
d4032 1
a4032 1
      if (.not. my_dont_close) call h5dClose_f ( dataID, status )
d4034 1
a4034 1
  end function name_to_attrID
d4036 2
a4037 1
  function name_to_dataID(fileID, name, dont_close) result(dataID)
d4042 1
a4042 1
    integer, intent(in)               :: fileID 
d4052 1
a4052 1
    call h5dOpen_f ( fileID, name, dataID, status ) 
d4056 1
a4056 1
      if (.not. my_dont_close) call h5dClose_f ( dataID, status )
d4060 35
d4102 6
a4245 1
 
@


2.45
log
@Added CpHDF5GlAttribute, CpHDF5Attribute
@
text
@a41 1
  use MLSCommon, only: r4, r8
d58 1
a58 1
       "$Id: MLSHDF5.f90,v 2.44 2004/08/04 23:19:01 pwagner Exp $"
d108 1
a108 1
!    {char* value, int value, r4 value, r8 value, 
d110 3
a112 2
!     r4 value(:), r4 value(:,:), r4 value(:,:,:),
!     r8 value(:), r8 value(:,:), r8 value(:,:,:)}
d119 1
a119 1
    module procedure MakeHDF5Attribute_dbl, &
d333 1
a333 1
    real(r8), intent(in) :: VALUE        ! Value of attribute
d368 40
d602 1
a602 1
    real(r4), intent(in) :: VALUE(:)     ! The attribute array itself
d645 2
a646 2
    character (len=*), intent(in) :: NAME ! Name of attribute
    real(r8), intent(in) :: VALUE(:)     ! The attribute array itself
d860 1
a860 1
    real(r4), intent(in) :: VALUE(:)     ! The attribute array itself
d875 1
a875 2
    call MakeHDF5Attribute_snglarr1( &
     & dataID, attrName, value )
d888 1
a888 1
    real(r8), intent(in) :: VALUE(:)     ! The attribute array itself
d903 1
a903 2
    call MakeHDF5Attribute_dblarr1( &
     & dataID, attrName, value )
d1059 1
a1059 1
    real(r4), intent(out) :: VALUE(:)     ! The attribute array result
d1087 1
a1087 1
    real(r4), intent(out) :: VALUE     ! The attribute result
d1111 3
a1113 3
    integer, intent(in) :: ITEMID       ! Group etc. to get attribute from
    character (len=*), intent(in) :: NAME ! Name of attribute
    real(r8), intent(out) :: VALUE     ! The attribute result
d1138 2
a1139 2
    character (len=*), intent(in) :: NAME ! Name of attribute
    real(r8), intent(out) :: VALUE(:)     ! The attribute result
d1760 2
a1761 2
    real(r8), intent(in) :: VALUE(:)     ! The array itself
    real(r8), optional, intent(in) :: FILLVALUE
d1800 2
a1801 2
    real(r8), intent(in) :: VALUE(:,:)  ! The array itself
    real(r8), optional, intent(in) :: FILLVALUE
d1840 2
a1841 2
    real(r8), intent(in) :: VALUE(:,:,:)  ! The array itself
    real(r8), optional, intent(in) :: FILLVALUE
d1880 2
a1881 2
    real(r4), intent(in) :: VALUE(:)     ! The array itself
    real(r4), optional, intent(in) :: FILLVALUE
d1920 2
a1921 2
    real(r4), intent(in) :: VALUE(:,:)  ! The array itself
    real(r4), optional, intent(in) :: FILLVALUE
d2134 2
a2135 2
    real(r4), intent(in) :: VALUE(:,:,:)  ! The array itself
    real(r4), optional, intent(in) :: FILLVALUE
d2312 2
a2313 2
    real(r4), intent(in) :: VALUE(:,:,:,:)  ! The array itself
    real(r4), optional, intent(in) :: FILLVALUE
d2732 2
a2733 2
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real(r8), intent(out) :: VALUE(:)    ! The array itself
d2793 2
a2794 2
    character (len=*), intent(in) :: NAME ! Name for this dataset
    real(r8), intent(out) :: VALUE(:,:) ! The array itself
d2854 1
a2854 1
    real(r8), intent(out) :: VALUE(:,:,:) ! The array itself
d2914 1
a2914 1
    real(r4), intent(out) :: VALUE(:)    ! The array itself
d2974 1
a2974 1
    real(r4), intent(out) :: VALUE(:,:) ! The array itself
d3034 1
a3034 1
    real(r4), intent(out) :: VALUE(:,:,:) ! The array itself
d3094 1
a3094 1
    real(r4), intent(out) :: VALUE(:,:,:,:) ! The array itself
d3271 1
a3271 1
    real(r8), optional, intent(in)    :: dFill
d3273 1
a3273 1
    real(r4), optional, intent(in)    :: rFill
d3280 1
a3280 1
    real(r8) :: dFilled
d3282 1
a3282 1
    real(r4) :: rFilled
d3595 1
a3595 1
    real(r8), dimension(:), optional, intent(in)         :: doubles
d3696 3
@


2.44
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d20 1
a20 1
  use HDF5, only: H5F_ACC_RDONLY_F, &
d49 3
a51 2
  public :: MakeHDF5Attribute, SaveAsHDF5DS, IsHDF5AttributePresent, &
    & IsHDF5DSPresent, GetHDF5Attribute, LoadFromHDF5DS, &
d53 2
a54 3
    & GetAllHDF5DSNames, GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType, &
    & mls_h5open, mls_h5close, &
    & ReadLitIndexFromHDF5Attr, ReadStringIndexFromHDF5Attr, &
d59 1
a59 1
       "$Id: MLSHDF5.f90,v 2.43 2004/08/03 18:00:28 pwagner Exp $"
d70 2
d87 4
d105 2
a106 1
! MakeHDF5Attribute (int itemID, char name, value) 
d135 12
d196 59
d3658 3
@


2.43
log
@Optionally sets fill value for some datasets
@
text
@d44 1
a44 1
  use MLSStrings, only: catLists
d59 1
a59 1
       "$Id: MLSHDF5.f90,v 2.42 2004/07/22 20:37:11 cvuu Exp $"
d3580 3
@


2.42
log
@Change in MakeHDF5Attribute_string to allow re-write the char string in the file attribute
@
text
@d32 1
a32 1
    & H5DREAD_F, H5DWRITE_F, H5DCLOSE_F, &
d36 2
a37 1
    & H5PCREATE_F, H5PSET_CHUNK_F, &
d59 1
a59 1
       "$Id: MLSHDF5.f90,v 2.41 2004/06/29 00:07:00 pwagner Exp $"
d156 2
d1383 2
a1384 1
  subroutine SaveAsHDF5DS_chararr1 ( locID, name, value )
d1389 3
d1397 1
a1397 1
    integer, dimension(1) :: SHP        ! Shape
d1402 2
d1412 19
a1430 6
    call h5sCreate_simple_f ( 1, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 1D char array '//trim(name) )
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), stringtype, spaceID, setID, &
      & status )
d1451 2
a1452 1
  subroutine SaveAsHDF5DS_chararr2 ( locID, name, value )
d1457 3
d1465 1
a1465 1
    integer, dimension(2) :: SHP        ! Shape
d1470 2
d1480 19
a1498 6
    call h5sCreate_simple_f ( 2, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 2D char array '//trim(name) )
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), stringtype, spaceID, setID, &
      & status )
d1519 2
a1520 1
  subroutine SaveAsHDF5DS_intarr1 ( locID, name, value )
d1525 3
d1533 1
a1533 1
    integer, dimension(1) :: SHP        ! Shape
d1536 3
d1540 2
a1541 7
    shp = shape(value)
    call h5sCreate_simple_f ( 1, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 1D integer array '//trim(name) )
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_INTEGER, spaceID, setID, &
      & status )
d1559 2
a1560 1
  subroutine SaveAsHDF5DS_intarr2 ( locID, name, value )
d1565 3
d1573 1
a1573 1
    integer, dimension(2) :: SHP        ! Shape
d1576 3
d1580 2
a1581 7
    shp = shape(value)
    call h5sCreate_simple_f ( 2, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 2D integer array '//trim(name) )
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_INTEGER, spaceID, setID, &
      & status )
d1599 2
a1600 1
  subroutine SaveAsHDF5DS_intarr3 ( locID, name, value )
d1605 3
d1613 1
a1613 1
    integer, dimension(3) :: SHP        ! Shape
d1616 3
d1620 2
a1621 7
    shp = shape(value)
    call h5sCreate_simple_f ( 3, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 3D integer array '//trim(name) )
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_INTEGER, spaceID, setID, &
      & status )
d1639 2
a1640 1
  subroutine SaveAsHDF5DS_dblarr1 ( locID, name, value )
d1645 3
d1653 1
a1653 1
    integer, dimension(1) :: SHP        ! Shape
d1656 3
d1660 2
a1661 7
    shp = shape(value)
    call h5sCreate_simple_f ( 1, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 1D double array '//trim(name) )
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_DOUBLE, spaceID, setID, &
      & status )
d1679 2
a1680 1
  subroutine SaveAsHDF5DS_dblarr2 ( locID, name, value )
d1685 3
d1693 1
a1693 1
    integer, dimension(2) :: SHP        ! Shape
d1696 3
d1700 2
a1701 7
    shp = shape(value)
    call h5sCreate_simple_f ( 2, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 2D double array '//trim(name) )
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_DOUBLE, spaceID, setID, &
      & status )
d1719 2
a1720 1
  subroutine SaveAsHDF5DS_dblarr3 ( locID, name, value )
d1725 3
d1733 1
a1733 1
    integer, dimension(3) :: SHP        ! Shape
d1736 3
d1740 2
a1741 7
    shp = shape(value)
    call h5sCreate_simple_f ( 3, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 3D double array '//trim(name) )
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_DOUBLE, spaceID, setID, &
      & status )
d1759 2
a1760 1
  subroutine SaveAsHDF5DS_snglarr1 ( locID, name, value )
d1765 3
d1773 1
a1773 1
    integer, dimension(1) :: SHP        ! Shape
d1776 3
d1780 2
a1781 7
    shp = shape(value)
    call h5sCreate_simple_f ( 1, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 1D double array '//trim(name) )
    ! Create the dataset
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
      & status )
d1799 2
a1800 2
  subroutine SaveAsHDF5DS_snglarr2 ( locID, name, value , &
    & start, count, stride, block, may_add_to, adding_to )
d1805 1
a1819 1
    integer(hid_t) :: cparms
d1854 13
a1866 2
      call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
        & status )
d1890 5
d2014 1
a2014 1
    & start, count, stride, block, may_add_to, adding_to )
d2019 1
a2033 1
    integer(hid_t) :: cparms
d2068 13
a2080 2
      call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
        & status )
d2106 5
d2192 1
a2192 1
    & start, count, stride, block, may_add_to, adding_to )
d2197 1
a2211 1
    integer(hid_t) :: cparms
d2242 11
a2252 1
      call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
d2254 1
d2277 5
d3142 111
d3580 3
@


2.41
log
@Exploit catlist function
@
text
@d30 1
a30 1
    & H5AREAD_F, H5AWRITE_F, &
d58 1
a58 1
       "$Id: MLSHDF5.f90,v 2.40 2004/06/08 18:59:59 pwagner Exp $"
d364 3
a366 1

d370 2
a371 3
    if ( my_skip ) then
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
    endif
d381 3
a383 3
    call h5sCreate_F ( h5s_scalar_f, dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for attribute '//trim(name) )
d388 8
d397 2
a400 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create attribute '//trim(name) )
d410 5
a414 3
    call h5sClose_f ( dsID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close attribute dataspace '//trim(name) )
d417 1
a417 1
      & 'Unable to close stringtype '//trim(name) )
d440 1
a440 1
      if ( IsHDF5AttributePresent_in_DSID(itemID, name) ) return
d3366 3
@


2.40
log
@Another break with old toolkit; this time may be correct
@
text
@d43 1
d58 1
a58 1
       "$Id: MLSHDF5.f90,v 2.39 2004/05/25 20:35:53 pwagner Exp $"
d205 3
a207 3
      DSNames = dataset_info%name(1)
      do i=2, dataset_info%number_of_entries
        DSNames = trim(DSNames) // ',' // dataset_info%name(i)
d3355 3
@


2.39
log
@Reverted to older hdf5; temporarily we hope
@
text
@d18 1
a18 1
  ! use H5LIB, ONLY: h5open_f, h5close_f
d57 1
a57 1
       "$Id: MLSHDF5.f90,v 2.38 2004/05/19 19:08:05 pwagner Exp $"
d3354 3
@


2.38
log
@After hdf5-1.6.2, h5open_f, h5close_f become module procedures
@
text
@d18 1
a18 1
  use H5LIB, ONLY: h5open_f, h5close_f
d57 1
a57 1
       "$Id: MLSHDF5.f90,v 2.37 2004/03/25 18:38:13 pwagner Exp $"
d3354 3
@


2.37
log
@May save 3d integer and double dsets
@
text
@d18 1
a18 1
  ! use H5LIB, ONLY: h5open_f, h5close_f
d57 1
a57 1
       "$Id: MLSHDF5.f90,v 2.36 2004/03/24 23:50:27 pwagner Exp $"
d3354 3
@


2.36
log
@Added mls_h5open/close
@
text
@d57 1
a57 1
       "$Id: MLSHDF5.f90,v 2.35 2004/02/26 21:59:09 pwagner Exp $"
d132 3
a134 2
    module procedure SaveAsHDF5DS_intarr1, SaveAsHDF5DS_intarr2, &
      & SaveAsHDF5DS_dblarr1, SaveAsHDF5DS_dblarr2, &
d1541 38
d1635 1
a1635 1
      & 'Unable to create dataspace for 2D integer array '//trim(name) )
d1640 1
a1640 1
      & 'Unable to create dataset for 2D integer array '//trim(name) )
d1645 1
a1645 1
      & 'Unable to write to dataset for 2D integer array '//trim(name) )
d1649 1
a1649 1
      & 'Unable to close dataset for 2D integer array '//trim(name) )
d1652 1
a1652 1
      & 'Unable to close dataspace for 2D integer array '//trim(name) )
d1655 38
d3354 3
@


2.35
log
@Added GetAllHDF5DSNames
@
text
@d17 2
d51 1
d57 1
a57 1
       "$Id: MLSHDF5.f90,v 2.34 2003/10/02 23:09:47 pwagner Exp $"
d77 2
d156 15
d3277 3
@


2.34
log
@Some small fixes; can get string array attribute
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d16 1
d48 1
a48 1
    & GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType, &
d54 1
a54 1
       "$Id: MLSHDF5.f90,v 2.33 2003/09/30 18:29:41 perun Exp $"
d65 1
d78 3
d100 4
d147 1
d151 74
d3257 3
@


2.33
log
@Change len_trim to len in MakeHDF5Attribute_string_arr1.
@
text
@d53 1
a53 1
       "$Id: MLSHDF5.f90,v 2.32 2003/09/12 16:40:27 cvuu Exp $"
d109 1
a109 1
      & GetHDF5Attribute_dblarr1
d573 6
d764 41
d1133 1
a1133 1
    my_grpattr = .true.
d1282 1
a1282 1
    call h5tset_size_f(stringtype, max(len_trim(value(1)), 1), status )
d1331 1
a1331 1
    call h5tset_size_f(stringtype, max(len_trim(value(1,1)), 1), status )
d3173 3
@


2.32
log
@Add subroutines to get L1BOA attributes
@
text
@d53 1
a53 1
       "$Id: MLSHDF5.f90,v 2.31 2003/08/07 15:44:19 perun Exp $"
d331 1
a331 1
    call h5tset_size_f(stringtype, max(len_trim(value(1)), 1), status )
d3126 3
@


2.31
log
@Add MakeHDF5Attribute_intarr1
@
text
@d53 1
a53 1
       "$Id: MLSHDF5.f90,v 2.30 2003/07/24 22:10:45 pwagner Exp $"
d108 2
a109 1
      & GetHDF5Attribute_snglarr1
d693 28
d852 28
d3126 3
@


2.30
log
@Fixed another bug preventing multiple chunks from writing to same dataset
@
text
@d53 1
a53 1
       "$Id: MLSHDF5.f90,v 2.29 2003/07/21 23:30:23 pwagner Exp $"
d100 1
a100 1
      & MakeHDF5AttributeDSN_int, &
d446 44
d3069 3
@


2.29
log
@Check on returnstatus from h5sget_simple_extent_dims_f being rank (marking success)
@
text
@d53 1
a53 1
       "$Id: MLSHDF5.f90,v 2.28 2003/07/18 16:04:19 pwagner Exp $"
d1427 1
d1432 4
a1435 4
    integer :: test_rank
    integer(hsize_t), dimension(7) :: test_dims, test_maxdims
    integer(hssize_t), dimension(7) :: test_offset
    logical :: test_issimple
d1445 1
a1445 1
   ! print *, 'style:   ', style
d1462 2
d1469 5
a1473 1
      call h5screate_simple_f(2, dims, spaceID, status, maxdims)
d1475 2
a1476 1
        & 'Unable to create dataspace for 2D real array '//trim(name) )
d1487 11
d1508 3
a1510 3
      call h5sget_simple_extent_ndims_f ( spaceID, test_rank, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get space rank for 2D real array '//trim(name) )
d1512 4
a1515 4
      call h5sget_simple_extent_dims_f ( spaceID, test_dims(1:test_rank), &
       &  test_maxdims(1:test_rank), status )
      if ( status /= test_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
       & 'Unable to get dims for datset '//trim(name) )
d1520 1
a1520 1
      test_dims(2) = test_dims(2) + shp(2)
d1522 7
a1528 4
      call h5dextend_f( setID, test_dims, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to extend dims for 2D real array '//trim(name) )
      call h5dget_space_f( setID, spaceID, status)
d1535 2
a1536 1
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
d1542 10
a1551 7
      call h5sis_simple_f ( memspaceID, test_issimple, status )
      call h5sget_simple_extent_ndims_f ( memspaceID, test_rank, status )
      call h5sget_simple_extent_dims_f ( memspaceID, test_dims(1:test_rank), &
        &  test_maxdims(1:test_rank), status )
      if ( status /= test_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get dims for datset '//trim(name) )
      call h5soffset_simple_f( memspaceID, test_offset(1:test_rank), status)
d1559 7
a1565 7
      call h5sis_simple_f ( spaceID, test_issimple, status )
      call h5sget_simple_extent_ndims_f ( spaceID, test_rank, status )
      call h5sget_simple_extent_dims_f ( spaceID, test_dims(1:test_rank), &
        &  test_maxdims(1:test_rank), status )
      if ( status /= test_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get dims for datset '//trim(name) )
      call h5soffset_simple_f( spaceID, test_offset(1:test_rank), status)
d1573 1
a1573 1
        & memspaceID, spaceID )
d1575 1
d1730 3
d1786 1
a1791 2
    integer :: test_rank
    integer(hsize_t), dimension(7) :: test_dims, test_maxdims
d1802 1
d1818 2
d1824 5
a1828 1
      call h5screate_simple_f(4, dims, spaceID, status, maxdims)
d1830 2
a1831 1
        & 'Unable to create dataspace for 4D real array '//trim(name) )
d1838 2
a1839 2
      call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
        & status, cparms )
d1842 11
d1858 4
a1861 15
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get dataspace for 4D real array '//trim(name) )
      call h5sget_simple_extent_ndims_f ( spaceID, test_rank, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get space rank for 4D real array '//trim(name) )
      call h5sget_simple_extent_dims_f ( spaceID, test_dims(1:test_rank), &
       &  test_maxdims(1:test_rank), status )
      ! Can't test on status--it's set to the test_rank
      if ( status /= test_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
       & 'Unable to get dims for datset '//trim(name) )
      test_dims(test_rank) = test_dims(test_rank) + shp(test_rank)
      call h5dextend_f( setID, test_dims, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to extend dims for 4D real array '//trim(name) )
      call h5dget_space_f( setID, spaceID, status)
d1866 6
a1871 1
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
d1873 7
d1882 2
a1883 1
        & memspaceID, spaceID )
d3025 3
@


2.28
log
@Fixed some bugs in DirectWriting 3-d datasets
@
text
@d53 1
a53 1
       "$Id: MLSHDF5.f90,v 2.27 2003/07/15 23:37:57 pwagner Exp $"
d807 2
d1495 2
d1523 2
d1537 2
a1538 2
      !if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      !  & 'Unable to get space dims for 2D real array '//trim(name) )
d1818 2
d2662 2
d2708 1
a2708 1
    if ( status /= 0 .and. cantGetDataspaceDims <= MAXNUMWARNS ) then
d2975 3
@


2.27
log
@No changes I can see, but cvs says so, so ..
@
text
@d39 1
a39 1
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
d53 1
a53 1
       "$Id: MLSHDF5.f90,v 2.26 2003/05/19 22:06:31 pwagner Exp $"
d134 3
a455 1
    integer :: ATTRID                   ! ID for attribute
a457 1
    integer, dimension(1) :: SHP        ! Shape
a487 1
    integer :: ATTRID                   ! ID for attribute
a489 1
    integer, dimension(1) :: SHP        ! Shape
a516 1
    integer :: ATTRID                   ! ID for attribute
a518 1
    integer, dimension(1) :: SHP        ! Shape
a545 1
    integer :: ATTRID                   ! ID for attribute
a547 1
    integer, dimension(1) :: SHP        ! Shape
a574 1
    integer :: ATTRID                   ! ID for attribute
a576 1
    integer, dimension(1) :: SHP        ! Shape
a603 1
    integer :: ATTRID                   ! ID for attribute
a605 1
    integer, dimension(1) :: SHP        ! Shape
d1423 2
a1424 2
    integer :: spaceID                  ! ID for dataspace
    integer :: memSpaceID               ! ID for dataspace
d1590 3
a1592 2
    integer :: spaceID                  ! ID for dataspace
    integer :: memSpaceID               ! ID for dataspace
d1597 4
a1600 4
    integer :: test_rank
    integer(hsize_t), dimension(7) :: test_dims, test_maxdims
    integer(hssize_t), dimension(7) :: test_offset
    logical :: test_issimple
d1611 1
d1627 2
d1633 8
a1640 5
      ! print *, 'shape ', shp
      ! print *, 'maxdims ', maxdims
      ! print *, 'dims ', dims
      ! print *, 'chunk_dims ', chunk_dims
      call h5screate_simple_f(3, dims, spaceID, status, maxdims)
d1642 2
a1643 1
        & 'Unable to create dataspace for 3D real array '//trim(name) )
d1650 2
a1651 2
      call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
        & status, cparms )
d1654 11
a1664 3
      ! print *, 'spaceID ', spaceID
      ! print *, 'cparms ', cparms
      ! print *, 'locID ', locID
d1670 7
a1676 7
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get dataspace for 3D real array '//trim(name) )
      call h5sget_simple_extent_ndims_f ( spaceID, test_rank, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to get space rank for 3D real array '//trim(name) )
      call h5sget_simple_extent_dims_f ( spaceID, test_dims(1:test_rank), &
       &  test_maxdims(1:test_rank), status )
d1678 8
a1685 5
      test_dims(test_rank) = test_dims(test_rank) + shp(test_rank)
      call h5dextend_f( setID, test_dims, status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to extend dims for 3D real array '//trim(name) )
      call h5dget_space_f( setID, spaceID, status)
d1690 6
a1695 5
      ! print *, 'name ', name
      ! print *, 'shape(value) ', shape(value)
      ! print *, 'start ', start
      ! print *, 'count ', count
      call mls_hyperslab(spaceID, shape(value), name, memspaceID, &
d1697 4
a1700 2
      ! print *, 'memspaceID ', memspaceID
      ! print *, 'spaceID ', spaceID
d1703 2
a1704 1
        & memspaceID, spaceID )
d1749 2
a1750 2
    integer :: spaceID                  ! ID for dataspace
    integer :: memSpaceID               ! ID for dataspace
a1756 2
    integer(hssize_t), dimension(7) :: test_offset
    logical :: test_issimple
a1870 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
a1942 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
a2014 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
a2073 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
a2133 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
a2194 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
a2254 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
a2314 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
a2374 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
a2434 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
a2494 2
    integer :: RANK                     ! Rank in file
    integer (kind=hSize_t) , dimension(maxDimensions) :: DIMS, MAXDIMS ! Dimensions in file
d2640 89
d2763 1
a2763 1
   ! print *, 'value_rank: ', value_rank
d2765 1
a2765 1
   ! print *, 'dataspace rank: ', rank
d2770 1
a2770 1
   ! print *, 'dataspace dims: ', dims(1:rank)
d2776 1
a2776 1
   ! print *, 'memspace id: ', memspaceID
d2780 3
a2782 3
     ! print *, 'trying to select hyperslab: ', &
     !  & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t), &
     !  & int(stride(1:rank), hsize_t), int(block(1:rank), hsize_t)
d2787 2
a2788 2
     ! print *, 'trying to select hyperslab: ', &
     !   & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t)
d2794 1
a2794 1
   ! print *, 'Returning memspaceID ', memspaceID
d2797 57
d2965 3
@


2.26
log
@Shortened names to Read..IndexFromHDF5Attr to comply with namelength standard
@
text
@d53 1
a53 1
       "$Id: MLSHDF5.f90,v 2.25 2003/05/13 04:46:42 livesey Exp $"
d1451 1
d1460 1
d1469 1
d1487 1
d1491 1
a1491 1
      ! print *, 'setID:   ', setID
d1495 1
a1495 1
      ! print *, 'spaceID:   ', spaceID
d1499 1
a1499 1
      ! print *, 'rank:   ', test_rank
d1502 3
a1504 3
      ! print *, 'status                  : ', status
      ! print *, 'dims (before extending) : ', test_dims(1:test_rank)
      ! print *, 'max_dims                : ', test_maxdims(1:test_rank)
d1507 1
a1507 1
      ! print *, 'dims (sfter extending)  : ', test_dims(1:test_rank)
d1514 1
a1514 1
      ! print *, 'new spaceID             : ', spaceID
d1517 1
d1521 1
a1521 1
      ! print *, 'About to write'
d1523 1
a1523 1
      ! print *, 'We received mem space (defined for data)', memspaceID
d1529 5
a1533 5
      ! print *, 'Is simple? ', test_issimple
      ! print *, 'rank    : ', test_rank
      ! print *, 'dims    : ', test_dims(1:test_rank)
      ! print *, 'max_dims: ', test_maxdims(1:test_rank)
      ! print *, 'offsets : ', test_offset(1:test_rank)
d1535 1
a1535 1
      ! print *, 'We received file space', spaceID
d1543 5
a1547 5
      ! print *, 'Is simple? ', test_issimple
      ! print *, 'rank    : ', test_rank
      ! print *, 'dims    : ', test_dims(1:test_rank)
      ! print *, 'max_dims: ', test_maxdims(1:test_rank)
      ! print *, 'offsets : ', test_offset(1:test_rank)
d1551 1
a1551 1
      ! print *, 'After writing mem space ', memspaceID
d1560 2
a1561 2
    ! print *, 'Before closing other, mem space ', memspaceID
    ! print *, 'Attempting to close data space ', spaceID
d1566 1
a1566 1
      ! print *, 'Attempting to close mem space ', memspaceID
d2684 1
a2684 1
    ! print *, 'value_rank: ', value_rank
d2686 1
a2686 1
    ! print *, 'dataspace rank: ', rank
d2691 1
a2691 1
    ! print *, 'dataspace dims: ', dims(1:rank)
d2697 1
a2697 1
    ! print *, 'memspace id: ', memspaceID
d2701 3
a2703 3
      ! print *, 'trying to select hyperslab: ', &
      ! & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t), &
      !  & int(stride(1:rank), hsize_t), int(block(1:rank), hsize_t)
d2708 2
a2709 2
      ! print *, 'trying to select hyperslab: ', &
      !  & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t)
d2715 1
a2715 1
    ! print *, 'Returning memspaceID ', memspaceID
d2829 3
@


2.25
log
@Bug fix, added more specifics to generic
@
text
@d7 7
a13 2
  ! tasks.  Initially mainly to do with simple attributes, but more will no
  ! doubt be added.
d48 1
a48 1
    & ReadLitIndexFromHDF5Attribute, ReadStringIndexFromHDF5Attribute, &
d53 1
a53 1
       "$Id: MLSHDF5.f90,v 2.24 2003/05/12 18:08:10 pwagner Exp $"
d2535 2
a2536 2
  ! ------------------------------------------ ReadLitIndexFromHDF5Attribute ---
  subroutine ReadLitIndexFromHDF5Attribute ( itemID, name, index )
d2551 1
a2551 1
  end subroutine ReadLitIndexFromHDF5Attribute
d2553 2
a2554 2
  ! ------------------------------------------ ReadStringIndexFromHDF5Attribute ---
  subroutine ReadStringIndexFromHDF5Attribute ( itemID, name, index )
d2569 1
a2569 1
  end subroutine ReadStringIndexFromHDF5Attribute
d2824 3
@


2.24
log
@Added 1d, 2d char array dsets, 2d int dset, gets of sngl, dbl scalar attrs
@
text
@d48 1
a48 1
       "$Id: MLSHDF5.f90,v 2.22 2003/04/28 23:08:20 pwagner Exp $"
d121 2
a122 2
      LoadFromHDF5DS_dblarr1, LoadFromHDF5DS_dblarr2, LoadFromHDF5DS_dblarr3, &
      LoadFromHDF5DS_snglarr1, LoadFromHDF5DS_snglarr2, &
d124 1
a124 1
      & LoadFromHDF5DS_chararr1
d2819 3
@


2.23
log
@Added the lit and string index stuff
@
text
@d102 2
a103 1
      & GetHDF5Attribute_string, GetHDF5Attribute_snglarr1
d112 1
a112 1
    module procedure SaveAsHDF5DS_intarr1, &
d115 2
a116 1
      & SaveAsHDF5DS_snglarr4, SaveAsHDF5DS_charsclr
d120 1
a120 1
    module procedure LoadFromHDF5DS_intarr1, &
d123 2
a124 1
      & LoadFromHDF5DS_snglarr3, LoadFromHDF5DS_snglarr4
d731 52
d1116 98
d1252 38
d1825 148
d2034 61
d2718 1
a2718 1
    double precision, dimension(:), optional, intent(in) :: doubles
d2819 3
@


2.22
log
@Added ability to Load, Save rank4 s.p. arrays
@
text
@d42 3
a44 1
    & GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType
d48 1
a48 1
       "$Id: MLSHDF5.f90,v 2.21 2003/03/20 19:21:11 pwagner Exp $"
d2130 67
d2419 3
@


2.21
log
@Fixed simple bug in saving 3d arrays
@
text
@d46 1
a46 1
       "$Id: MLSHDF5.f90,v 2.20 2003/02/21 23:41:02 pwagner Exp $"
d110 3
a112 3
      SaveAsHDF5DS_dblarr1, SaveAsHDF5DS_dblarr2, &
      SaveAsHDF5DS_snglarr1, SaveAsHDF5DS_snglarr2, SaveAsHDF5DS_snglarr3, &
      SaveAsHDF5DS_charsclr
d118 2
a119 1
      LoadFromHDF5DS_snglarr1, LoadFromHDF5DS_snglarr2, LoadFromHDF5DS_snglarr3
d1509 123
d2066 62
d2350 3
@


2.20
log
@Additional MakeHDF5Attribute interface
@
text
@d46 1
a46 1
       "$Id: MLSHDF5.f90,v 2.19 2003/02/12 21:38:14 pwagner Exp $"
d1432 1
a1432 1
      dims(2) = max(1, shp(3))
d1434 4
d1451 3
d1476 4
d1482 2
d2164 3
@


2.19
log
@May make dbl scalar and array attributes; find if name is an attribute of a group
@
text
@d46 1
a46 1
       "$Id: MLSHDF5.f90,v 2.18 2003/01/30 00:56:01 pwagner Exp $"
d95 1
a95 1
      & MakeHDF5AttributeDSN_st_arr1
d590 31
d2151 3
@


2.18
log
@Added string arrays as possible attributes (untested)
@
text
@d27 1
d46 1
a46 1
       "$Id: MLSHDF5.f90,v 2.17 2003/01/27 21:38:44 pwagner Exp $"
d89 2
a90 1
    module procedure MakeHDF5Attribute_int, MakeHDF5Attribute_logical, &
d92 1
a92 1
      & MakeHDF5Attribute_string_arr1, &
d105 1
a105 1
      & IsHDF5AttributePresent_in_DSID
d126 40
d255 1
a255 1
    call h5tset_size_f(stringtype, len_trim(value), status )
d316 1
a316 1
    call h5tset_size_f(stringtype, len_trim(value(1)), status )
d388 44
d883 2
a884 1
  logical function IsHDF5AttributePresent_in_fID ( fileID, DSname, name )
d886 2
d891 2
a892 1
    integer :: SETID                    ! ID for attribute if present
d895 1
d898 7
d926 33
d2120 3
@


2.17
log
@May make 1d s.p. array attributes; may make attributes with sdname attrname call
@
text
@d45 1
a45 1
       "$Id: MLSHDF5.f90,v 2.16 2003/01/23 23:30:49 pwagner Exp $"
d90 1
d92 2
a93 1
      & MakeHDF5AttributeDSN_string, MakeHDF5AttributeDSN_snglarr1
d220 4
a223 4
    print *, 'itemID: ', itemID
    print *, 'stringtype: ', stringtype
    print *, 'dsID: ', dsID
    print *, 'name: ', trim(name)
d225 2
a226 2
    print *, 'attrID: ', attrID
    print *, 'status: ', status
d246 56
d442 31
d1989 3
@


2.16
log
@May add to same 2d, 3d single-precision datasets
@
text
@d45 1
a45 1
       "$Id: MLSHDF5.f90,v 2.15 2002/12/07 00:24:40 pwagner Exp $"
d89 3
a91 1
      & MakeHDF5Attribute_string
d96 1
a96 1
      & GetHDF5Attribute_string
d123 2
a124 1
  subroutine MakeHDF5Attribute_int ( itemID, name, value )
d127 2
a128 1
    integer, intent(in) :: VALUE        ! Value of attribut
d134 1
d137 5
d163 2
a164 1
  subroutine MakeHDF5Attribute_logical ( itemID, name, value )
d168 1
d172 1
d175 5
d186 2
a187 1
  subroutine MakeHDF5Attribute_string ( itemID, name, value )
d191 1
d198 1
d201 5
d218 4
d223 2
d244 171
d491 28
d1835 58
d1900 3
@


2.15
log
@Added SaveAsHDF5DS_snglarr3
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d13 3
a15 1
    & H5S_SCALAR_F, H5S_SELECT_SET_F, &
d19 1
a19 1
    & HID_T, HSIZE_T
d23 1
a23 1
    & H5DCREATE_F, H5DGET_SPACE_F, H5DGET_TYPE_F, H5DOPEN_F, &
d27 1
d45 1
a45 1
       "$Id: MLSHDF5.f90,v 2.14 2002/12/02 23:35:57 pwagner Exp $"
d729 2
a730 1
  subroutine SaveAsHDF5DS_snglarr2 ( locID, name, value )
d736 12
d749 2
d752 1
d756 5
d763 8
d773 3
a775 3
    call h5sCreate_simple_f ( 2, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 2D real array '//trim(name) )
d777 100
a876 2
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
      & status )
d878 7
a884 7
      & 'Unable to create dataset for 2D real array '//trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
      & int ( (/ shp, ones(1:5) /), hID_T ), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 2D real array '//trim(name) )
    ! Close things
a887 3
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 2D real array '//trim(name) )
d891 2
a892 1
  subroutine SaveAsHDF5DS_snglarr3 ( locID, name, value )
d897 12
d911 2
d914 1
d918 5
d925 8
d935 3
a937 3
    call h5sCreate_simple_f ( 3, int(shp,hSize_T), spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to create dataspace for 3D real array '//trim(name) )
d939 62
a1000 2
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_REAL, spaceID, setID, &
      & status )
d1002 6
a1007 7
      & 'Unable to create dataset for 3D real array '//trim(name) )
    ! Write the data
    call h5dWrite_f ( setID, H5T_NATIVE_REAL, value, &
      & int ( (/ shp, ones(1:4) /), hID_T ), status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to write to dataset for 3D real array '//trim(name) )
    ! Close things
a1010 3
    call h5sClose_F ( spaceID, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to close dataspace for 3D real array '//trim(name) )
d1524 1
a1524 1
!    print *, 'value_rank: ', value_rank
d1526 1
a1526 1
!    print *, 'dataspace rank: ', rank
d1531 1
a1531 1
!    print *, 'dataspace dims: ', dims(1:rank)
d1537 1
a1537 1
!    print *, 'memspace id: ', memspaceID
d1541 3
a1543 3
!      print *, 'trying to select hyperslab: ', &
!        & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t), &
!        & int(stride(1:rank), hsize_t), int(block(1:rank), hsize_t)
d1548 2
a1549 2
!      print *, 'trying to select hyperslab: ', &
!        & int(start(1:rank), hsize_t), int(count(1:rank), hsize_t)
d1555 1
a1555 1

d1611 3
@


2.14
log
@Should provide more info when something goes awry
@
text
@d42 1
a42 1
       "$Id: MLSHDF5.f90,v 2.13 2002/10/29 01:01:05 pwagner Exp $"
d102 1
a102 1
      SaveAsHDF5DS_snglarr1, SaveAsHDF5DS_snglarr2, &
d743 1
a743 1
      & 'Unable to create dataspace for 2D integer array '//trim(name) )
d748 1
a748 1
      & 'Unable to create dataset for 2D integer array '//trim(name) )
d753 1
a753 1
      & 'Unable to write to dataset for 2D integer array '//trim(name) )
d757 1
a757 1
      & 'Unable to close dataset for 2D integer array '//trim(name) )
d760 1
a760 1
      & 'Unable to close dataspace for 2D integer array '//trim(name) )
d763 38
d1399 3
@


2.13
log
@Can save a char scalar as a DS
@
text
@d10 1
d42 1
a42 1
       "$Id: MLSHDF5.f90,v 2.12 2002/10/11 23:42:04 pwagner Exp $"
d1220 1
d1225 3
a1227 2
    if ( rank /= value_rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Inconsistant rank for dataset '//trim(name) )
d1230 3
a1232 2
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset '//trim(name) )
d1234 4
a1237 2
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Dataspace too large for destination value of '//trim(name) )
d1270 3
a1272 2
    if ( status /= 3 .and. status /= 15 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Impossible optional parameters pattern for dataset '//trim(name) )
d1308 46
d1361 3
@


2.12
log
@Remembered to close hyperslab memspaceID if created one
@
text
@d41 1
a41 1
       "$Id: MLSHDF5.f90,v 2.11 2002/10/10 23:51:57 pwagner Exp $"
d101 2
a102 1
      SaveAsHDF5DS_snglarr1, SaveAsHDF5DS_snglarr2
d529 43
d1308 3
@


2.11
log
@Optional hyperslab args to LoadFromHDF5DS
@
text
@d41 1
a41 1
       "$Id: MLSHDF5.f90,v 2.10 2002/10/08 00:09:11 pwagner Exp $"
d769 5
d832 5
d894 5
d956 5
d1018 5
d1080 5
d1142 5
d1264 3
@


2.10
log
@Added idents to survive zealous Lahey optimizer
@
text
@d11 6
a16 4
  use HDF5, only: H5S_SCALAR_F, H5T_NATIVE_INTEGER, H5T_NATIVE_CHARACTER, &
    & H5T_NATIVE_DOUBLE, H5T_NATIVE_REAL, HID_T, HSIZE_T, &
    & H5T_STD_I32LE, H5T_IEEE_F32LE, H5T_IEEE_F64LE, &
    & H5F_ACC_RDONLY_F
d18 2
a19 2
  use HDF5, only: H5ACREATE_F, H5AGET_TYPE_F, H5AOPEN_NAME_F, H5AREAD_F, &
    & H5AWRITE_F, H5ACLOSE_F, &
d22 1
d24 4
a27 4
    & H5SCREATE_F, H5SCREATE_SIMPLE_F, H5SCLOSE_F, &
    & H5SGET_SIMPLE_EXTENT_NDIMS_F, H5SGET_SIMPLE_EXTENT_DIMS_F, &
    & H5TCLOSE_F, H5TCOPY_F, H5TGET_SIZE_F, H5TSET_SIZE_F, H5TEQUAL_F, &
    & H5ESET_AUTO_F
d41 1
a41 1
       "$Id: MLSHDF5.f90,v 2.9 2002/10/04 22:22:52 pwagner Exp $"
d63 20
d719 2
a720 1
  subroutine LoadFromHDF5DS_intarr1 ( locID, name, value )
d725 8
a732 1

d740 1
d753 10
a762 15
    ! Check that dimensions are all ok.
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset '//trim(name) )
    if ( rank /= 1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Inconsistant rank for dataset '//trim(name) )
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), status )
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset '//trim(name) )
    if ( any ( dims(1:rank) > shape(value) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Dataspace too large for destination value of '//trim(name) )
    ! Now, (at last!) read the data
    call h5dread_f ( setID, H5T_NATIVE_INTEGER, value, &
      & (/ shape(value), ones(1:6) /), status )
d775 2
a776 1
  subroutine LoadFromHDF5DS_dblarr1 ( locID, name, value )
d781 8
d797 1
d810 10
a819 12
    ! Check that dimensions are all ok.
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset '//trim(name) )
    if ( rank /= 1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Inconsistant rank for dataset '//trim(name) )
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), status )
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset '//trim(name) )
    if ( any ( dims(1:rank) > shape(value) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Dataspace too large for destination value of '//trim(name) )
a820 2
    call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & (/ shape(value), ones(1:6) /), status )
d833 2
a834 1
  subroutine LoadFromHDF5DS_dblarr2 ( locID, name, value )
d839 8
d855 1
d868 10
a877 15
    ! Check that dimensions are all ok.
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset '//trim(name) )
    if ( rank /= 2 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Inconsistant rank for dataset '//trim(name) )
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), status )
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset '//trim(name) )
    if ( any ( dims(1:rank) > shape(value) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Dataspace too large for destination value of '//trim(name) )
    ! Now, (at last!) read the data
    call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & (/ shape(value), ones(1:5) /), status )
d890 2
a891 1
  subroutine LoadFromHDF5DS_dblarr3 ( locID, name, value )
d896 8
d912 1
d925 10
a934 15
    ! Check that dimensions are all ok.
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset '//trim(name) )
    if ( rank /= 3 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Inconsistant rank for dataset '//trim(name) )
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), status )
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset '//trim(name) )
    if ( any ( dims(1:rank) > shape(value) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Dataspace too large for destination value of '//trim(name) )
    ! Now, (at last!) read the data
    call h5dread_f ( setID, H5T_NATIVE_DOUBLE, value, &
      & (/ shape(value), ones(1:4) /), status )
d947 2
a948 1
  subroutine LoadFromHDF5DS_snglarr1 ( locID, name, value )
d953 8
d969 1
d982 10
a991 15
    ! Check that dimensions are all ok.
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset '//trim(name) )
    if ( rank /= 1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Inconsistant rank for dataset '//trim(name) )
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), status )
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset '//trim(name) )
    if ( any ( dims(1:rank) > shape(value) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Dataspace too large for destination value of '//trim(name) )
    ! Now, (at last!) read the data
    call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
      & (/ shape(value), ones(1:6) /), status )
d1004 2
a1005 1
  subroutine LoadFromHDF5DS_snglarr2 ( locID, name, value )
d1010 8
d1026 1
d1039 10
a1048 15
    ! Check that dimensions are all ok.
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset '//trim(name) )
    if ( rank /= 2 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Inconsistant rank for dataset '//trim(name) )
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), status )
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset '//trim(name) )
    if ( any ( dims(1:rank) > shape(value) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Dataspace too large for destination value of '//trim(name) )
    ! Now, (at last!) read the data
    call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
      & (/ shape(value), ones(1:5) /), status )
d1061 2
a1062 1
  subroutine LoadFromHDF5DS_snglarr3 ( locID, name, value )
d1067 8
d1083 1
d1096 10
a1105 15
    ! Check that dimensions are all ok.
    call h5sget_simple_extent_ndims_f ( spaceID, rank, status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get rank for dataset '//trim(name) )
    if ( rank /= 3 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Inconsistant rank for dataset '//trim(name) )
    call h5sget_simple_extent_dims_f ( spaceID, dims(1:rank), maxdims(1:rank), status )
    if ( status /= rank ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to get dimension information for dataset '//trim(name) )
    if ( any ( dims(1:rank) > shape(value) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Dataspace too large for destination value of '//trim(name) )
    ! Now, (at last!) read the data
    call h5dread_f ( setID, H5T_NATIVE_REAL, value, &
      & (/ shape(value), ones(1:4) /), status )
d1130 92
d1229 3
@


2.9
log
@Fixed bug in GetHDF5DSQType; can retrieve rank3 datasets
@
text
@d38 1
a38 1
       "$Id: MLSHDF5.f90,v 2.8 2002/10/02 23:20:07 livesey Exp $"
d42 1
d1072 4
d1079 3
@


2.8
log
@Bug fix in single precision stuff
@
text
@d23 1
a23 1
    & H5TCLOSE_F, H5TCOPY_F, H5TGET_SIZE_F, H5TSET_SIZE_F, &
d38 1
a38 1
       "$Id: MLSHDF5.f90,v 2.7 2002/09/27 23:39:26 pwagner Exp $"
d69 5
d82 2
a83 2
      LoadFromHDF5DS_dblarr1, LoadFromHDF5DS_dblarr2, &
      LoadFromHDF5DS_snglarr1, LoadFromHDF5DS_snglarr2
d340 2
a341 6
  ! While case select seemed most natural here, these H5T_..
  ! unfortunately are not initialization expressions; therefore
  ! must use clunky old if elseif blocks
  !  select case (type_id)                   
  !  case (H5T_STD_I32LE, H5T_NATIVE_INTEGER)
    if ( type_id == H5T_STD_I32LE .or. type_id == H5T_STD_I32LE ) then
d343 1
a343 2
  !  case (H5T_NATIVE_CHARACTER)
    elseif ( type_id == H5T_NATIVE_CHARACTER ) then
d345 2
a346 2
  !  case (H5T_NATIVE_REAL, H5T_IEEE_F32LE)
    elseif ( type_id == H5T_NATIVE_REAL .or. type_id == H5T_IEEE_F32LE ) then
d348 2
a349 2
  !  case (H5T_NATIVE_DOUBLE, H5T_IEEE_F64LE)
    elseif ( type_id == H5T_NATIVE_DOUBLE .or. type_id == H5T_IEEE_F64LE ) then
a350 5
  !  case default
  !  else      
  !    error = 1
  !    return   
  !  end select 
d422 2
a423 2
  ! --------------------------------------------- IsHDF5AttributePresent ---
  logical function IsHDF5AttributePresent ( locID, name )
d425 1
a425 1
    integer, intent(in) :: LOCID        ! Where to look
d435 1
a435 1
    call h5aOpen_name_f ( locID, name, attrID, status ) 
d437 1
a437 1
      IsHDF5AttributePresent = .false.
d439 1
a439 1
      IsHDF5AttributePresent = .true.
d445 33
a477 1
  end function IsHDF5AttributePresent
d850 52
d1006 65
d1074 3
@


2.7
log
@Added GetHDF5DSQType
@
text
@d38 1
a38 1
       "$Id: MLSHDF5.f90,v 2.6 2002/09/26 23:56:15 pwagner Exp $"
d611 1
a611 1
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_DOUBLE, spaceID, setID, &
d649 1
a649 1
    call h5dCreate_f ( locID, trim(name), H5T_NATIVE_DOUBLE, spaceID, setID, &
d930 3
@


2.6
log
@Added some things for MLSAux and l1bdata
@
text
@d13 1
d18 1
a18 1
    & H5DCREATE_F, H5DGET_SPACE_F, H5DOPEN_F, &
d34 1
a34 1
    & GetHDF5DSRank, GetHDF5DSDims
d38 1
a38 1
       "$Id: MLSHDF5.f90,v 2.5 2002/09/13 18:08:12 pwagner Exp $"
d44 15
d269 3
d304 1
d317 46
d930 3
@


2.5
log
@May change matrix precision rm from r8
@
text
@d12 2
a13 1
    & H5T_NATIVE_DOUBLE, H5T_NATIVE_REAL, HID_T, HSIZE_T
d19 1
d31 3
a33 1
    & IsHDF5DSPresent, GetHDF5Attribute, LoadFromHDF5DS
d37 1
a37 1
       "$Id: MLSHDF5.f90,v 2.4 2002/08/26 16:42:09 livesey Exp $"
d238 123
d363 1
a363 1
    ! This routine returns true if the given HDF5 DS is present
d365 1
a365 1
    character (len=*), intent(in) :: NAME ! Name for the dataset
d367 1
a367 1
    integer :: ATTRID                   ! ID for DS if present
d373 1
a373 1
      & 'Unable to turn error messages off before looking for DS '//trim(name) )
d383 1
a383 1
      & 'Unable to turn error messages back on after looking for DS '//trim(name) )
d398 1
a398 1
      & 'Unable to turn error messages off before looking for attribute '//trim(name) )
d408 1
a408 1
      & 'Unable to turn error messages back on after looking for attribute '//trim(name) )
d864 3
@


2.4
log
@Bug fix with error messages in IsHDF5DSPresent
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d12 1
a12 1
    & H5T_NATIVE_DOUBLE, HID_T, HSIZE_T
d33 1
a33 1
       "$Id: MLSHDF5.f90,v 2.3 2002/08/23 01:23:21 livesey Exp $"
d51 2
a52 1
      SaveAsHDF5DS_dblarr1, SaveAsHDF5DS_dblarr2
d57 2
a58 1
      LoadFromHDF5DS_dblarr1, LoadFromHDF5DS_dblarr2
d398 76
d630 104
d737 3
@


2.3
log
@Added IsHDF5DSPresent and IsHDF5AttributePresent
@
text
@d33 1
a33 1
       "$Id: MLSHDF5.f90,v 2.2 2002/07/17 06:00:21 livesey Exp $"
a272 1
      return
a275 1
      return
d555 3
@


2.2
log
@Got hdf5 l2pc reading stuff working
@
text
@d20 2
a21 1
    & H5TCLOSE_F, H5TCOPY_F, H5TGET_SIZE_F, H5TSET_SIZE_F
d28 2
a29 1
  public :: MakeHDF5Attribute, SaveAsHDF5DS, GetHDF5Attribute, LoadFromHDF5DS
d33 1
a33 1
       "$Id: MLSHDF5.f90,v 2.1 2002/07/11 22:18:26 pwagner Exp $"
d232 52
d557 3
d566 1
@


2.1
log
@First commit in this directory--welcome old friendshe5*.f90
@
text
@d31 1
a31 1
       "$Id: MLSHDF5.f90,v 1.1 2002/06/18 21:57:09 livesey Exp $"
d204 2
a205 1
    call h5aread_f ( attrID, H5T_NATIVE_INTEGER, value, ones, status )
d377 1
a377 1
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d429 1
a429 1
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d481 1
a481 1
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
a499 1

d503 3
@

