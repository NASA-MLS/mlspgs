head	2.122;
access;
symbols
	v5-02-NRT-19:2.122
	v6-00:2.122
	v5-02-NRT-18:2.122
	v5-02:2.122
	v5-01-NRT-17:2.122
	v5-01-NRT-16:2.122
	v5-01-NRT-15:2.122
	v5-01-NRT-14:2.122
	neuralnetworks-1-0:2.122.0.8
	cfm-single-freq-0-1:2.122.0.6
	v5-01:2.122
	v5-00:2.122
	v4-23-TA133:2.122.0.4
	mus-emls-1-70:2.122.0.2
	rel-1-0-englocks-work:2.120.0.2
	VUMLS1-00:2.118
	VPL1-00:2.115
	V4-22-NRT-08:2.112
	VAM1-00:2.107
	V4-21:2.88.0.2
	V4-13:2.87
	V4-12:2.82
	V4-11:2.82
	V4-10:2.82
	V3-43:2.55
	M4-00:2.73
	V3-41:2.55
	V3-40-PlusGM57:2.55.0.2
	V2-24-NRT-04:2.49
	V3-33:2.59
	V2-24:2.49
	V3-31:2.59
	V3-30-NRT-05:2.57
	cfm-01-00:2.55
	V3-30:2.55
	V3-20:2.55
	V3-10:2.53
	V2-23-NRT-02:2.49
	V2-23:2.49
	V2-22-NRT-01:2.49
	V2-22:2.49
	V2-21:2.47
	V2-20:2.47
	V2-11:2.44
	V2-10:2.44
	V2-00:2.44
	V1-51:2.39
	V1-50:2.39
	V1-45:2.38
	V1-44:2.38
	V1-43:2.37
	V1-42:2.34
	V1-41:2.34
	V1-32:2.34
	V1-40:2.34
	V1-31:2.34
	V1-30:2.34
	V1-13:2.31
	V1-12:2.31
	V1-11:2.31
	V1-10:2.31
	newfwm-feb03:2.31.0.2
	V1-04:2.22
	V1-03:2.22
	V1-02:2.22
	V1-00:2.22
	newfwm-sep01:2.17.0.2
	V0-7:2.17
	V0-5-Level2:2.13
	V0-5-SIPS:2.11
	V0_1:1.12;
locks; strict;
comment	@# @;


2.122
date	2018.05.24.03.18.54;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2018.04.19.02.00.36;	author vsnyder;	state Exp;
branches;
next	2.120;

2.120
date	2017.11.03.19.57.01;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2017.09.18.19.30.41;	author vsnyder;	state Exp;
branches;
next	2.118;

2.118
date	2017.01.25.17.19.26;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2016.10.01.01.37.28;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2016.08.30.20.27.24;	author vsnyder;	state Exp;
branches;
next	2.115;

2.115
date	2016.08.23.00.42.43;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2016.07.28.01.36.34;	author vsnyder;	state Exp;
branches;
next	2.113;

2.113
date	2016.05.25.00.21.01;	author vsnyder;	state Exp;
branches;
next	2.112;

2.112
date	2016.05.24.01.24.53;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2016.05.19.23.28.07;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2016.05.18.01.34.37;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2016.05.12.15.22.46;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2016.05.04.18.34.16;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2015.09.25.02.12.25;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2015.09.23.22.39.09;	author vsnyder;	state Exp;
branches;
next	2.105;

2.105
date	2015.09.22.23.15.01;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2015.08.31.17.26.04;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2015.08.26.01.08.17;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2015.08.25.18.36.03;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2015.08.21.01.00.47;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2015.07.31.20.42.22;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2015.07.29.00.27.28;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2015.07.23.23.45.57;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2015.06.04.03.13.16;	author vsnyder;	state Exp;
branches;
next	2.96;

2.96
date	2015.06.03.23.09.00;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2015.06.02.23.53.00;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2015.05.28.20.32.40;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2015.05.27.22.41.46;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2015.05.01.02.09.28;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2015.04.29.00.53.28;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2015.04.07.02.51.50;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2015.03.28.01.40.45;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2014.10.29.23.04.29;	author vsnyder;	state Exp;
branches
	2.88.2.1;
next	2.87;

2.87
date	2014.09.05.00.17.16;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2014.08.19.00.28.33;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2014.08.07.22.45.15;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2014.08.06.23.23.02;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2014.08.06.23.22.28;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2014.04.24.23.49.25;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2014.03.20.01.39.47;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2013.12.12.01.57.17;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2013.09.19.23.31.08;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2013.08.16.02.27.04;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2013.07.12.23.57.42;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2013.06.12.02.13.40;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2012.10.30.22.06.14;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2012.10.29.17.41.16;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2012.08.08.20.00.21;	author vsnyder;	state Exp;
branches;
next	2.70;

2.70
date	2012.07.10.03.53.49;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2012.02.24.21.11.50;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2012.02.23.00.08.35;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2012.02.13.23.22.31;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2012.01.05.01.17.50;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2011.10.25.18.07.02;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2011.05.09.17.26.03;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2011.03.31.18.30.02;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2011.03.23.00.42.08;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2011.03.22.23.39.50;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2011.03.15.22.43.52;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2011.02.18.17.54.49;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2010.09.25.01.16.35;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2010.09.17.00.04.54;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2010.08.31.02.05.10;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2009.09.25.02.42.07;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2008.09.30.22.28.03;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2008.06.06.01.54.08;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2008.06.05.02.05.53;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2007.09.12.00.16.12;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2007.03.23.00.11.52;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2006.08.04.20.54.09;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2006.08.04.01.54.16;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2006.08.03.01.10.06;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2006.03.22.23.49.20;	author vsnyder;	state Exp;
branches;
next	2.43;

2.43
date	2006.03.22.02.15.18;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2006.01.05.03.47.28;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2005.08.04.02.57.27;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2004.08.26.18.54.49;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2004.08.16.17.07.11;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2004.05.01.04.07.44;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2004.04.15.20.51.51;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2004.01.24.01.02.43;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2003.07.01.19.29.00;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2003.06.20.19.33.53;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2003.05.29.16.36.41;	author livesey;	state Exp;
branches;
next	2.31;

2.31
date	2003.01.14.21.35.53;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2003.01.08.21.39.55;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2002.11.27.01.06.26;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2002.11.22.12.54.34;	author mjf;	state Exp;
branches;
next	2.27;

2.27
date	2002.10.08.00.09.13;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2002.09.24.21.36.42;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2002.08.28.20.42.11;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2002.07.22.03.26.05;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2002.07.01.23.51.07;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2001.10.12.23.09.25;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2001.10.03.17.42.27;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2001.10.02.23.12.50;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2001.09.17.21.59.26;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.09.13.19.59.43;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2001.07.31.23.39.12;	author dwu;	state Exp;
branches;
next	2.16;

2.16
date	2001.07.11.21.41.16;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.07.02.17.25.30;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.05.23.20.38.35;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.23.23.52.16;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.23.23.50.41;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.12.21.43.06;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.10.22.37.49;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.03.24.00.31.12;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.17.02.23.18;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.15.20.20.59;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.02.01.34.03;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.02.23.17.47.01;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.02.14.00.12.34;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.09.00.38.56;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2000.12.04.23.43.59;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.13.00.00.37;	author vsnyder;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.05.17.21.16;	author dcuddy;	state dead;
branches;
next	1.12;

1.12
date	2000.06.19.23.57.41;	author lungu;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.17.23.49.14;	author lungu;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.15.22.52.35;	author livesey;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.20.21.59.28;	author livesey;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.20.01.28.21;	author livesey;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.18.21.27.00;	author livesey;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.12.20.55.49;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.07.23.53.35;	author livesey;	state Exp;
branches;
next	1.4;

1.4
date	99.12.17.21.42.16;	author livesey;	state Exp;
branches;
next	1.3;

1.3
date	99.12.16.23.46.35;	author livesey;	state Exp;
branches;
next	1.2;

1.2
date	99.12.16.23.12.09;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	99.12.16.18.31.43;	author livesey;	state Exp;
branches;
next	;

2.88.2.1
date	2015.04.14.22.43.02;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.122
log
@Cannonball polishing
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module QuantityTemplates         ! Quantities within vectors
!=============================================================================

  ! This module defines the `quantities' that make up vectors and their
  ! template information.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use HyperSlabs, only: Rerank
  use Dump_0, only: Dump
  use Expr_M, only: Expr_Check
  use HGridsDatabase, only: HGrid_T, Dump
  use HighOutput, only: OutputNamedValue
  use Intrinsic, only: L_Geodetic, L_GeodAltitude, L_None, L_Phitan, &
    & L_VMR, L_QTM, Lit_Indices, Phyq_Angle, Phyq_Dimensionless, &
    & Phyq_Frequency, Phyq_Indices, Phyq_Time, Phyq_Vmr
  use MLSKinds, only: Rt => R8 ! Rt Is "kind Of Real Components Of Template"
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
  use MLSFillValues, only: NaNFunction
  use MLSFinds, only: FindFirst
  use MLSStringLists, only: SwitchDetail
  use MLSStrings, only: Lowercase, WriteIntsToChars
  use Output_M, only: Output
  use String_Table, only: IsStringInTable
  use Toggles, only: Switches
  use Tree, only: Nsons, Subtree

  implicit NONE
  private

  public :: Epoch, QuantityTemplate_T, RT
  public :: AddQuantityTemplateToDatabase, InflateQuantityTemplateDatabase
  public :: CheckIntegrity, CopyQuantityTemplate, CreateGeolocationFields, &
    & CreateLatitudeFields, CreateLongitudeFields, &
    & DestroyGeolocationFields, DestroyQuantityTemplateContents, &
    & DestroyQuantityTemplateDatabase, Dump, GetHGridFromQuantity, &
    & ModifyQuantityTemplate, &
    & NullifyQuantityTemplate, PointQuantityToHGrid, QuantitiesAreCompatible, &
    & SetupNewQuantityTemplate, WriteAttributes

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: QuantityTemplates.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

  ! Define some global parameters and data types.

  real(rt), parameter :: Epoch = 1993.0 ! Starting point for time references

  type QuantityTemplate_T

    ! Some administrative stuff

    integer :: Name = 0        ! Sub-rosa index of quantity name

    ! This integer is of an enumerated type describing what kind of
    ! quantity this is -- one of the l_lits of type t_quantityType
    ! in Init_Tables_Module, e.g. l_Temperature.

    integer :: QuantityType

    ! The dimensions of this quantity

    integer :: NoInstances     ! Number of along-track horizontal instances in
                               ! this quantity
    integer :: NoSurfs         ! Number of surfaces per instance
    integer :: NoChans = 1     ! Number of channels
    integer :: NoCrossTrack = 1! Number of cross-track horizontal instances in
                               ! this quantity (from xGrid)

    ! Flags describing the quantity

    logical :: Coherent        ! Do instances have same vertical coordinates?
    logical :: Stacked         ! Are instances true vertical profiles?
    logical :: Regular         ! Are all channels/heights represented

    ! This next one allows software using the vector quantities to be somewhat
    ! lazy and, for example, avoid interpolation.  Minor frame quantities are
    ! incoherent and unstacked, but may be regular or irregular.  However, not
    ! all incoherent unstacked quantities are minor frame quantities.

    logical :: MinorFrame      ! Is this a minor frame quantity.
    logical :: MajorFrame      ! Is this a major frame quantity.

    ! This one indicates whether log or linear interpolation should be used
    logical :: LogBasis                 ! If set use log
    real(rt) :: MinValue                ! Minimum value to consider if using log

    ! This information describes how much of the data is in the overlap
    ! regions if any.

    integer :: NoInstancesLowerOverlap
    integer :: NoInstancesUpperOverlap

    ! Misc. information
    real(rt) :: BadValue       ! Value used to flag bad/missing data
    integer :: Unit = PHYQ_VMR ! Unit quantity is in when scaled as below,
                               ! an l_lit of the type t_units.  Units are
                               ! defined in units.f90, but their names are
                               ! declared in intrinsic.f90, and their membership
                               ! in the type t_units is defined in init_tables_module.

    ! For regular quantities the number of elements of each instance
    ! is simply noSurfs*noChans.  For irregular ones it is less, but it is
    ! constant from instance to instance; this is that number.
    integer :: InstanceLen

    ! Vertical coordinate
    integer :: VerticalCoordinate=l_geodAltitude ! The vertical coordinate
                                  ! used.  These are l_lits of the type
                                  ! t_VGridCoord defined in Init_Tables_Module.
    logical :: SharedVGrid        ! Set if surfs is a pointer not a copy
    integer :: VGridIndex         ! Index of any vGrid used

    ! Surfs is dimensioned (noSurfs,noCrossTrack) for coherent quantities and
    ! (noSurfs, noInstances*noCrossTrack) for incoherent ones.  Pretending the
    ! values are dimensioned (noChans, noSurfs, noInstances), or
    ! (noChans, noSurfs, noInstances, noCrossTrack), the SURFS coordinate
    ! for the (:,i,j,:) values is surfs(i,1) for a coherent quantity or
    ! surfs(i,j) for an incoherent one.
    ! Surfs is allocatable instead of a pointer because the quantity template
    ! is copied into the vector value, not targeted therein.  If the VGrid
    ! is shared, deallocating a pointer would result in a dangling pointer.
    ! If noCrossTrack > 1, use the Surfs3 function to access it.
    real(rt), allocatable :: Surfs(:,:) ! zeta or meters, depending on verticalCoordinate

    ! Horizontal coordinates in the orbit plane.
    integer :: HorizontalCoordinate = l_phiTan ! The horizontal coordinate used.
                                        ! Either l_phiTan or l_time
    integer :: GrandTotalInstances      ! Total number of instances in destination output file
    ! for example MAF index, or profile index.
    integer :: hGridIndex               ! Index of any hGrid used
    type(hGrid_t), pointer :: The_HGrid => NULL()
    integer :: InstanceOffset           ! Ind of 1st non overlapped instance in output
    integer :: XGridIndex = 0           ! Index of any xGrid used

    ! First subscript values for GeoLocation component
    integer :: OrbitCoordinateIndex = 1 ! For spacecraft position
    integer :: LOSCoordinateIndex = 2   ! For line of sight
    real(rt), dimension(:,:,:), pointer :: Geolocation => NULL()

    ! Geolocation is dimensioned (*, 1, noInstances) for stacked quantities and
    ! (*, noSurfs, noInstances) for unstacked ones.  The Geolocation coordinate
    ! for the (*,i,j) value is geolocation(*,1,j) for a stacked quantity and
    ! geolocation(*,i,j) for an unstacked one.  The "*" is taken from either
    ! the OrbitCoordinateIndex or LOSCoordinateIndex component.

    real(rt), allocatable :: ECR(:,:,:) ! Meters

    ! ECR is dimensioned (3,1,noInstances*noCrossTrack) for stacked quantities
    ! and (3, noSurfs, noInstances*noCrossTrack) for unstacked ones.

    real(rt), allocatable :: Phi(:,:)   ! Degrees

    ! Phi is dimensioned (1, noInstances*noCrossTrack) for stacked quantities
    ! and (noSurfs, noInstances*noCrossTrack) for unstacked ones.  The PHI
    ! coordinate for the (i,j) value is phi(1,j) for a stacked quantity and
    ! phi(i,j) for an unstacked one.  Phi is either taken from or derived from
    ! Geolocation.  If noCrossTrack > 1, use the Phi3 function to access it.

    ! These other coordinates are dimensioned in the same manner as Phi.
    ! GeodLat and Lon are allocatable instead of pointers because the
    ! quantity template is copied into the vector value, not targeted
    ! therein.  If geolocations are computed, as for the magnetic field,
    ! if they were pointers the result would be dangling pointers.
    real(rt), allocatable :: GeodLat(:,:)            ! Degrees
    real(rt), allocatable :: Lon(:,:)                ! Degrees
    real(rt), pointer :: Time(:,:) => NULL()         ! Seconds since EPOCH
    real(rt), pointer :: SolarTime(:,:) => NULL()
    real(rt), pointer :: SolarZenith(:,:) => NULL()  ! Degrees
    real(rt), pointer :: LosAngle(:,:) => NULL()     ! Degrees

    ! Notwithstanding that the name of the latitude coordinate is GeodLat,
    ! it is sometimes geocentric latitude.  LatitudeCoordinate is either
    ! L_Geocentric or L_Geodetic.

    integer :: LatitudeCoordinate = L_Geodetic

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! For quantities having cross-track extent other than one, CrossAngles
    ! gives the angles from Phi, in the direction of the instrument.  Positive
    ! values are away from the instrument, negative values are toward the
    ! instrument.  The values come from the quantity's xGrid, which is
    ! reqired to be an explicit hGrid.
    real(rt), dimension(:), pointer :: CrossAngles => NULL()   ! Degrees

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! For quantities containing `channels' the following information may or
    ! may not be useful.

    ! Some quantities are on arbitrary freqency grids; these quantities refer
    ! to those.
    integer, pointer :: ChanInds(:) => NULL() ! Indices of values of Channels
                                        ! that are true
    logical, pointer :: Channels(:) => NULL() ! If /keepChannels is set
    integer :: fGridIndex               ! Index of any fGrid Index used
    real(rt), dimension(:), pointer :: frequencies => NULL() ! List of frequencies
                                        ! for Channels(ChanInds)
    integer :: FrequencyCoordinate      ! An enumerated type, e.g. FG_USBFreq
    real(rt) :: Lo                      ! Local oscillator frequency, MHz
    logical :: SharedFGrid              ! Set of frequencies are a pointer not a copy
    integer :: Sideband                 ! Associated sideband -1, 0, +1
    integer :: Signal                   ! Index into signals database

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! Some families of quantities require special additional information.
    ! This is given here if needed.

    integer :: InstrumentModule ! Index in the Modules database in MLSSignals_m
    integer :: Radiometer       ! For ptan etc., index into radiometers database
    integer :: Reflector        ! For reflector efficiency etc. terms
    integer :: Molecule ! What molecule does this refer to? (One of the l_...
                        ! lits of type t_molecule in Molecules.)

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    ! For irregular quantities, we have these arrays to
    ! help us navigate around the quantity.

    integer, dimension(:,:), pointer :: SurfIndex => NULL()
    integer, dimension(:,:), pointer :: ChanIndex => NULL()
    ! These are actually dimensioned (instanceLen, noInstances)
  contains
    procedure :: GeocLat => GetGeocLat
    procedure :: GeocLat3 => GetGeocLat3
    procedure :: GeodLat3 => GetLat3
    procedure :: IsQTM
    procedure :: Lon3 => GetLon3
    procedure :: Phi3 => GetPhi3
    procedure :: PutGeocLat
    procedure :: PutGeocLat3
    procedure :: PutLat
    procedure :: PutLat3
    procedure :: PutLon3
    procedure :: PutPhi3
    procedure :: PutSurfs3
    procedure :: Surfs3 => GetSurfs3
  end type QuantityTemplate_T

  interface Dump
    module procedure Dump_Quantity_Template, Dump_Quantity_Templates
  end interface

  interface ModifyQuantityTemplate
    module procedure ModifyQuantityTemplate_allocate
    module procedure ModifyQuantityTemplate_array, ModifyQuantityTemplate_sca
  end interface

  interface ReadAttributes
    module procedure ReadAttributes_QuantityTemplate
  end interface

  interface WriteAttributes
    module procedure WriteAttributes_QuantityTemplate
  end interface

  interface CHECKINTEGRITY
    module procedure CheckIntegrity_QuantityTemplate
  end interface

  ! Local procedures
  interface myValuesToField
    module procedure myValuesToField_2d_real
    module procedure myValuesToField_1d_dble
    module procedure myValuesToField_2d_dble
  end interface

  integer, parameter :: NUMMODS = 9
  character(*), dimension(NUMMODS), parameter :: MODIFIABLEFIELDS = (/&
    & 'surfs      ', &
    & 'phi        ', &
    & 'geodlat    ', &
    & 'lon        ', &
    & 'time       ', &
    & 'solartime  ', &
    & 'solarzenith', &
    & 'losangle   ', &
    & 'frequencies' &
    & /)

contains

 ! =====     Public Procedures     =============================

  ! Subroutines to deal with these quantitites

  ! ------------------------------  AddQuantityTemplateToDatabase  -----
  integer function AddQuantityTemplateToDatabase ( database, item )

  ! Add a quantity template to a database, or create the database if it
  ! doesn't yet exist

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type (QuantityTemplate_T), dimension(:), pointer :: database
    type (QuantityTemplate_T), intent(in) :: item

    ! Local variables
    type (QuantityTemplate_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddQuantityTemplateToDatabase = newSize
  end function AddQuantityTemplateToDatabase

  ! ----------------------------  CopyQuantityTemplate  -----
  subroutine CopyQuantityTemplate ( Z, A, dontDestroy )
    ! This routine does a 'deep' copy of a quantity template.
    ! We don't need to do if often as typically only a shallow copy
    ! is required.  Note that this also follows any 'links' to h/v/xGrids
    ! and expands them too.
    use DeepCopy_m, only: DeepCopy
    type (QuantityTemplate_T), intent(inout) :: Z
    type (QuantityTemplate_T), intent(in)    :: A
    logical, optional, intent(in)            :: dontDestroy
    ! Internal variables
    logical                                  :: mustDestroy
    ! Executable code
    mustDestroy = .true.
    if ( present(dontDestroy) ) mustDestroy = .not. dontDestroy
    ! Destroy result
    if ( mustDestroy ) then
      call DestroyQuantityTemplateContents ( z )
    else
      nullify( z%the_HGrid )
    endif
    ! Setup result
    z%name = a%name
    call SetupNewQuantityTemplate ( z, noInstances=a%noInstances, &
      & noSurfs=a%noSurfs, noChans=a%noChans, noCrossTrack=a%noCrossTrack, &
      & coherent=a%coherent, stacked=a%stacked, regular=a%regular, &
      & instanceLen=a%instanceLen, minorFrame=a%minorFrame, &
      & majorFrame=a%majorFrame )
    ! Copy each other component -- tedious, but a shallow copy
    ! would lose newly allocated arrays
    ! 1st, scalars
    z%name                         = a%name
    z%quantityType                 = a%quantityType
    z%noInstances                  = a%noInstances            
    z%noSurfs                      = a%noSurfs                
    z%noChans                      = a%noChans                
    z%coherent                     = a%coherent               
    z%stacked                      = a%stacked                
    z%regular                      = a%regular                
    z%minorFrame                   = a%minorFrame             
    z%majorFrame                   = a%majorFrame             
    z%logBasis                     = a%logBasis               
    z%minValue                     = a%minValue               
    z%noInstancesLowerOverlap      = a%noInstancesLowerOverlap
    z%noInstancesUpperOverlap      = a%noInstancesUpperOverlap
    z%badValue                     = a%badValue               
    z%unit                         = a%unit                   
    z%instanceLen                  = a%instanceLen
    z%verticalCoordinate           = a%verticalCoordinate     
    z%sharedVGrid                  = a%sharedVGrid            
    z%vGridIndex                   = a%vGridIndex             
    z%xGridIndex                   = a%xGridIndex             
    z%horizontalCoordinate         = a%horizontalCoordinate             
    z%hGridIndex                   = a%hGridIndex              
    z%instanceOffset               = a%instanceOffset                    
    z%grandTotalInstances          = a%grandTotalInstances               
    z%fGridIndex                   = a%fGridIndex                
    z%frequencyCoordinate          = a%frequencyCoordinate             
    z%lo                           = a%lo                              
    z%sharedFGrid                  = a%sharedFGrid                     
    z%sideband                     = a%sideband                        
    z%signal                       = a%signal                          
    z%instrumentModule             = a%instrumentModule
    z%radiometer                   = a%radiometer      
    z%reflector                    = a%reflector       
    z%molecule                     = a%molecule        
    if ( associated(a%the_HGrid) ) &
  & z%the_HGrid                    => a%the_HGrid        

    ! Next, arrays
    if ( allocated(z%surfs)        .and. allocated(a%surfs) )        z%surfs =       a%surfs
    if ( allocated(z%phi)          .and. allocated(a%phi) )          z%phi =         a%phi
    if ( allocated(z%geodLat)      .and. allocated(a%geodLat) )      z%geodLat =     a%geodLat
    if ( allocated(z%lon)          .and. allocated(a%lon) )          z%lon =         a%lon
    if ( associated(z%time)        .and. associated(a%time) )        z%time =        a%time
    if ( associated(z%solarTime)   .and. associated(a%solarTime) )   z%solarTime =   a%solarTime
    if ( associated(z%solarZenith) .and. associated(a%solarZenith) ) z%solarZenith = a%solarZenith
    if ( associated(z%losAngle)    .and. associated(a%losAngle) )    z%losAngle =    a%losAngle
    if ( associated(z%chanInds)    .and. associated(a%chanInds) )    z%chanInds =    a%chanInds
    if ( associated(z%channels)    .and. associated(a%channels) )    z%channels =    a%channels
    call deepCopy ( z%frequencies, a%frequencies )
    if ( .not. z%regular ) then
      z%surfIndex = a%surfIndex
      z%chanIndex = a%chanIndex
    end if

  end subroutine CopyQuantityTemplate

  ! ------------------------------------  CreateGeolocationFields  -----
  subroutine CreateGeolocationFields ( Qty, NoSurfsToAllocate, What, Phi )
    ! Allocate Qty%GeodLat and Qty%Lon.

    type (QuantityTemplate_T), intent(inout) :: QTY
    integer, intent(in) :: NoSurfsToAllocate
    character(len=*), intent(in) :: What
    logical, intent(in), optional :: Phi

    call createLatitudeFields ( Qty, NoSurfsToAllocate, What )
    Qty%geodLat = NaNFunction(0._rt)
    call createLongitudeFields ( Qty, NoSurfsToAllocate, What )
    Qty%Lon = NaNFunction(0._rt)
    call createSurfsFields ( Qty, What )
    if ( present(phi) ) then
      if ( phi ) call createPhiFields ( Qty, What )
      Qty%phi = NaNFunction(0._rt)
    end if

  end subroutine CreateGeolocationFields

  ! ---------------------------------------  CreateLatitudeFields  -----
  subroutine CreateLatitudeFields ( Qty, NoSurfsToAllocate, What )
    ! Allocate Qty%GeodLat.

    type (QuantityTemplate_T), intent(inout) :: QTY
    integer, intent(in) :: NoSurfsToAllocate
    character(len=*), intent(in) :: What

    integer :: NumAlloc

    numAlloc = qty%noInstances * qty%noCrossTrack
    call allocate_test ( qty%geodLat, noSurfsToAllocate, numAlloc, trim(what) // "%geodLat", &
      & moduleName )

  end subroutine CreateLatitudeFields

  ! --------------------------------------  CreateLongitudeFields  -----
  subroutine CreateLongitudeFields ( Qty, NoSurfsToAllocate, What )
    ! Allocate Qty%Lon.

    type (QuantityTemplate_T), intent(inout) :: QTY
    integer, intent(in) :: NoSurfsToAllocate
    character(len=*), intent(in) :: What

    integer :: NumAlloc

    numAlloc = qty%noInstances * qty%noCrossTrack
    call allocate_test ( qty%lon, noSurfsToAllocate, numAlloc, trim(what) // "%lon", &
      & moduleName )

  end subroutine CreateLongitudeFields

  ! ------------------------------------------  CreatePhiFields  -----
  subroutine CreatePhiFields ( Qty, What )
    ! Allocate Qty%Phi

    type (QuantityTemplate_T), intent(inout) :: QTY
    character(len=*), intent(in) :: What

    call allocate_test ( qty%phi, merge(1,qty%noSurfs,qty%stacked), &
      & qty%noInstances*qty%noCrossTrack, moduleName, trim(what) // "%Phi" )

  end subroutine CreatePhiFields

  ! ------------------------------------------  CreateSurfsFields  -----
  subroutine CreateSurfsFields ( Qty, What )
    ! Allocate Qty%Surfs

    type (QuantityTemplate_T), intent(inout) :: QTY
    character(len=*), intent(in) :: What

    call allocate_test ( qty%surfs, qty%noSurfs, &
      & merge(1,qty%noInstances,qty%coherent), moduleName, &
      & trim(what) // "%surfs" )

  end subroutine CreateSurfsFields

  ! -----------------------------------  DestroyGeolocationFields  -----
  subroutine DestroyGeolocationFields ( Qty )
    ! Deallocate the latitude and longitude fields.  They are no longer
    ! shared with corresponding fields of HGrids, so we don't need to worry
    ! about shared HGrids here.
    use Allocate_Deallocate, only: Deallocate_Test
    ! Args
    type (QuantityTemplate_T), intent(inout) :: QTY
    ! Executable
    call deallocate_test ( qty%geodLat, 'Qty%GeodLat', moduleName )
    call deallocate_test ( qty%lon, 'Qty%Lon', moduleName )

  end subroutine DestroyGeolocationFields

  ! ----------------------------  DestroyQuantityTemplateContents  -----
  subroutine DestroyQuantityTemplateContents ( qty )
    use String_Table, only: Get_String
    ! Dummy argument
    type (QuantityTemplate_T), intent(inout) :: QTY
    ! Local variables
    character (len=80) :: typeStr
    logical :: Verbose
    character(63) :: What

    ! Executable code
    verbose = ( switchDetail(switches, 'qtmp' ) > -1 .or. switchDetail(switches, 'destroy' ) > -1 )
    ! May not destroy GeoLocations (until we discover why not)
    if ( qty%quantityType < 1 .or. qty%quantityType > size(lit_indices) ) return
    call get_string( lit_indices(qty%quantityType), typeStr )
    if ( lowercase( typeStr ) == 'geolocation' ) then
      call output( 'Unable to destroy this geoLocation quantity', advance='yes' )
      return
    elseif ( lowercase( typeStr ) == 'lostransfunc' ) then
      call output( 'Unable to destroy this LOSTransFunc quantity', advance='yes' )
      return
    endif
    if ( verbose ) then
      call dump( qty )
      call output( 'About to destroy this quantity', advance='yes' )
    end if
    if ( qty%name == 0 ) then
      what = "qty"
    else if ( verbose ) then
      call myGetString ( qty%name, what )
    else
      what = ''
    end if
    if ( index( lowercase( what ), 'phitan' ) > 0 .or. &
      & index( lowercase( what ), 'mif' ) > 0 ) then
      call output( 'Unable to destroy this particular quantity', advance='yes' )
      return
    endif

    if ( .not. qty%sharedVGrid ) then
      if ( verbose ) call output( 'About to deallocate surfs', advance='yes' )
      call deallocate_test ( qty%surfs, trim(what) // "%surfs", ModuleName )
    end if

    nullify ( qty%the_hGrid )

    ! If not stacked, there is no Phi.
    if ( qty%stacked ) then
      if ( verbose ) call output( 'About to deallocate stacked phi', advance='yes' )
      call deallocate_test ( qty%phi, trim(what) // '%phi', ModuleName )
    end if
    if ( verbose ) call output( 'About to deallocate geosdlat', advance='yes' )
    call deallocate_test ( qty%geodLat, trim(what) // '%geodLat', ModuleName )
    if ( verbose ) call output( 'About to deallocate lons', advance='yes' )
    call deallocate_test ( qty%lon, trim(what) // '%lon', ModuleName )
    if ( verbose ) call output( 'About to deallocate times', advance='yes' )
    call deallocate_test ( qty%time, trim(what) // '%time', ModuleName )
    if ( verbose ) call output( 'About to deallocate solartime', advance='yes' )
    call deallocate_test ( qty%solarTime, trim(what) // '%solarTime', ModuleName )
    if ( verbose ) call output( 'About to deallocate solarzenits', advance='yes' )
    call deallocate_test ( qty%solarZenith, trim(what) // '%solarZenith', ModuleName )
    if ( verbose ) call output( 'About to deallocate losangle', advance='yes' )
    call deallocate_test ( qty%losAngle, trim(what) // '%losAngle', ModuleName )
    if ( verbose ) call output( 'About to deallocate crossAngles', advance='yes' )
    call deallocate_test ( qty%crossAngles, trim(what) // '%crossAngles', ModuleName )

    if ( .not. qty%sharedFGrid ) then
      if ( verbose ) call output( 'About to deallocate chanInds', advance='yes' )
      call deallocate_test ( qty%chanInds, trim(what) // "%chanInds", ModuleName )
      if ( verbose ) call output( 'About to deallocate channels', advance='yes' )
      call deallocate_test ( qty%channels, trim(what) // "%channels", ModuleName )
      if ( verbose ) call output( 'About to deallocate freqs', advance='yes' )
      call deallocate_test ( qty%frequencies, trim(what) // "%frequencies", ModuleName )
    else
      nullify ( qty%chanInds, qty%channels, qty%frequencies )
    end if

    if ( .not. qty%regular ) then
      if ( verbose ) call output( 'About to deallocate surfindex', advance='yes' )
      call deallocate_test ( qty%surfIndex, trim(what) // "%surfIndex", ModuleName )
      if ( verbose ) call output( 'About to deallocate chanindex', advance='yes' )
      call deallocate_test ( qty%chanIndex, trim(what) // '%chanIndex', ModuleName )
    else
      nullify ( qty%surfIndex, qty%chanIndex )
    end if

  end subroutine DestroyQuantityTemplateContents

  ! ----------------------------  DestroyQuantityTemplateDatabase  -----
  subroutine DestroyQuantityTemplateDatabase ( database )
    use Output_m, only: Blanks
    ! Dummy argument

    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    type (QuantityTemplate_T), dimension(:), pointer :: DATABASE
    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: qtyIndex, s, status
    logical :: verbose

    ! Executable code
    verbose = ( switchDetail(switches, 'qtmp' ) > -1 .or. switchDetail(switches, 'destroy' ) > -1 )
    if ( associated(database) ) then
      if ( verbose ) call outputNamedValue( 'size(qty db)', size ( database ) )
      do qtyIndex = 1, size ( database )
        if ( verbose ) then
          call blanks ( 9, FillChar = '-' )
          call output ( ' Quantity index ' )
          call output ( qtyIndex )
          call blanks ( 1 )
          call blanks ( 9, FillChar = '-', advance='yes' )
        endif
        call DestroyQuantityTemplateContents ( database(qtyIndex) )
      end do
      s = size(database) * storage_size(database) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(database(1)), addr)
      deallocate ( database, stat=status )
      call test_deallocate ( status, ModuleName, "database", s, address=addr )
    end if
  end subroutine DestroyQuantityTemplateDatabase

  ! -------------------------------------  Dump_Quantity_Template  -----
  subroutine Dump_Quantity_Template ( Qty, Details, NoL2CF, What )

    use MLSSignals_M, only: Signals, Dump, GetRadiometerName, GetModuleName
    use Output_M, only: Blanks, NewLine
    use VGridsDatabase, only: Dump

    type(QuantityTemplate_T), intent(in) :: Qty
    integer, intent(in), optional :: Details ! <= 0 => Don't dump arrays
                                             ! >0   => Do signal, phi, surfs
                                             !         and frequency
                                             ! >1   => Dump all arrays
                                             ! Default 1
    logical, intent(in), optional :: NoL2CF  ! if TRUE => Don't dump L2-specific
                                             !  stuff
    character(*), intent(in), optional :: What ! In case you want to label it
    ! Local variables
    integer :: MyDetails
    logical :: myNoL2CF
    character (len=80) :: Str

    myDetails = 1
    if ( present(details) ) myDetails = details
    myNoL2CF = switchDetail(switches, 'nl2cf') > -1 ! .false.
    if ( present(NoL2CF) ) myNoL2CF = NoL2CF
    call output ( ' Name = ' )
    if ( isStringInTable( qty%name ) ) &
          & call myDisplayString ( qty%name )
    if ( .not. myNoL2CF .and. qty%quantityType > 0 ) then
      call output ( ' quantityType = ' )
      if ( isStringInTable(qty%quantityType, lit_indices) ) &
        &  call myDisplayString ( lit_indices(qty%quantityType) )
    else
      call output ( ' unknown quantityType' )
    end if
    if ( present(what) ) call output ( ' ' // trim(what) )
    call newline
    call Blanks( 5 )
    call output ( qty%noChans,              before=' NoChans = ' )
    call output ( qty%noSurfs,              before=' NoSurfs = ' )
    call output ( qty%noInstances,          before=' NoInstances = ' )
    call output ( qty%grandtotalinstances,  before=' grandtotalinstances = ' )
    call output ( qty%noCrossTrack,         before=' NoCrossTrack = ' )
    call newLine
    call blanks( 6 )
    call output ( trim(merge('  ','in',qty%coherent)) // 'coherent ' )
    call output ( trim(merge('   ','non',qty%stacked)) // 'stacked ' )
    call output ( trim(merge('  ','ir',qty%regular)) // 'regular ' )
    call output ( trim(merge('log-   ','linear-',qty%logBasis)) // 'basis ' )
    call output ( trim(merge('   ','non',qty%minorFrame)) // 'minorFrame ' )
    call output ( trim(merge('   ','non',qty%majorFrame)) // 'majorFrame', &
      & advance='yes' )
    call output ( '      NoInstancesLowerOverlap = ' )
    call output ( qty%noInstancesLowerOverlap )
    call output ( ' NoInstancesUpperOverlap = ' )
    call output ( qty%noInstancesUpperOverlap, advance='yes' )
    if ( .not. myNoL2CF .and. isStringInTable( qty%unit, phyq_indices) ) then
      call myDisplayString ( phyq_indices(qty%unit), before='      Unit = ' )
    else
      call blanks ( 5 )
    end if
    call output ( qty%badValue, before=' BadValue = ' )
    call output ( qty%InstanceLen, before=' InstanceLen = ', advance='yes' )
    if ( .not. myNoL2CF .and. &
      & isStringInTable( qty%horizontalCoordinate, lit_indices) ) &
      & call myDisplayString ( lit_indices(qty%horizontalCoordinate), &
      & before=   '      horizontal coordinate = ' )
    if ( isStringInTable( qty%horizontalCoordinate, lit_indices ) ) &
      & call myDisplayString ( lit_indices(qty%horizontalCoordinate), &
      & before=' latitude coordinate = ', advance='yes' )
    call output ( qty%hGridIndex, before='      hGridIndex = ' )
    call output ( qty%xGridIndex, before=' xGridIndex = ' )
    call newline
    call output ( qty%sharedVGrid, before='      sharedVGrid = ' )
    if ( qty%sharedVGrid ) then
      call output ( ' vGridIndex = ' )
      call output ( qty%vGridIndex )
    end if
    if ( .not. myNoL2CF .and. &
      & isStringInTable( qty%verticalCoordinate, lit_indices ) ) &
      & call myDisplayString ( lit_indices(qty%verticalCoordinate), &
      & before=' vertical coordinate = ' )
    call newLine
    call output ( qty%sharedFGrid, before='      sharedFGrid = ' )
    if ( qty%sharedFGrid ) then
      call output ( ' fGridIndex = ' )
      call output ( qty%fGridIndex )
    end if
    if ( isStringInTable( qty%frequencyCoordinate, lit_indices ) ) &
      & call myDisplayString ( lit_indices(qty%frequencyCoordinate), &
      & before=   ' frequency coordinate = ', advance='yes' )
    if ( qty%radiometer /= 0 .and. .not. myNoL2CF ) then
      call output ( '      Radiometer = ' )
      call GetRadiometerName ( qty%radiometer, str )
      call output ( trim(str), advance='yes' )
    end if
    if ( .not. myNoL2CF ) then
      if ( qty%quantityType == l_vmr .or. qty%instrumentModule /= 0 ) &
        & call output ( '     ' )
      if ( qty%quantityType == l_vmr ) then
        call output ( ' Molecule = ' )
        if ( isStringInTable( qty%molecule, lit_indices ) ) &
          & call myDisplayString ( lit_indices(qty%molecule) )
      end if
      if ( qty%instrumentModule /= 0 ) then
        call output ( ' Instrument Module = ' )
        call GetModuleName ( qty%instrumentModule, str )
        call output ( trim(str) )
      end if
      if ( qty%quantityType == l_vmr .or. qty%instrumentModule /= 0 ) &
        & call newLine
    end if

    if ( associated (qty%the_HGrid) ) then
      call Dump( qty%the_HGrid )
    else
      call output ( '      No The_HGrid', advance='yes' )
    end if
    if ( myDetails > 0 ) then
      if ( qty%signal /= 0 ) then
        call output ( '      Signal ' )
        call output ( qty%signal )
        call output ( ':', advance='yes' )
        if ( associated(qty%channels) ) then
          call dump ( signals(qty%signal), &
            & otherChannels=qty%channels )
        else
          call dump ( signals(qty%signal) )
        end if
      end if
      if ( allocated(qty%phi) ) then
        if ( qty%noCrossTrack == 1 ) then
          call dump ( reshape ( qty%phi, &
            & [ size(qty%geodLat,1),qty%noInstances] ), &
            & '      Phi' )
        else
          call dump ( reshape ( qty%phi, &
            & [ size(qty%geodLat,1),qty%noInstances,qty%noCrossTrack] ), &
            & '      Phi' )
        end if
      else
        call output ( '      No Phi' )
      end if

      if ( allocated(qty%surfs) ) then
        call dump ( qty%surfs, '      Surfs' )
      else
        call output ( '      No Surfs' )
      end if
      if ( myDetails > 1 ) then
        call maybe_dump_2_I ( qty%surfIndex, 'SurfIndex' )
        call maybe_dump_2_I ( qty%chanIndex, 'ChanIndex' )
        if ( allocated(qty%geodlat) ) then
          call dump ( reshape ( qty%geodlat, &
            & [ size(qty%geodLat,1),qty%noInstances,qty%noCrossTrack] ), &
            & '      GeodLat' )
        else
          call output ( '      No GeodLat' )
        end if
        if ( allocated(qty%lon) ) then
          call dump ( reshape ( qty%lon, &
            & [ size(qty%geodlat,1),qty%noInstances,qty%noCrossTrack] ), &
            & '      Lon' )
        else
          call output ( '      No Lon' )
        end if
        call maybe_dump_2_rt ( qty%time, 'Time' )
        call maybe_dump_2_rt ( qty%solarTime, 'SolarTime' )
        call maybe_dump_2_rt ( qty%solarZenith, 'SolarZenith' )
        call maybe_dump_2_rt ( qty%losAngle, 'LosAngle' )
        call maybe_dump_1_rt ( qty%crossAngles, 'CrossAngles' )
      end if
      if ( associated(qty%frequencies)  .and. .not. myNoL2CF ) then
        if ( isStringInTable( qty%frequencyCoordinate, lit_indices ) ) &
          & call myDisplayString ( lit_indices(qty%frequencyCoordinate), &
          & before='      FrequencyCoordinate = ', advance='yes' )
        call dump ( qty%frequencies, ' Frequencies ' )
      end if
    else
      if ( associated(qty%frequencies)  .and. .not. myNoL2CF .and. &
        & isStringInTable( qty%frequencyCoordinate, lit_indices ) ) &
        & call myDisplayString ( lit_indices(qty%frequencyCoordinate), &
        & before='      FrequencyCoordinate = ', advance='yes' )
    end if
  
  contains
  
    subroutine Maybe_Dump_2_I ( Array, Name )
      integer, intent(in), pointer :: Array(:,:)
      character(*), intent(in) :: Name
      if ( associated(array) ) then
        call dump ( array, '      ' // trim(name) // ' = ' )
      else
        call output ( '      No ' // trim(name), advance='yes' )
      end if
    end subroutine Maybe_Dump_2_I

    subroutine Maybe_Dump_1_RT ( Array, Name )
      real(rt), intent(in), pointer :: Array(:)
      character(*), intent(in) :: Name
      if ( associated(array) ) then
        call dump ( array, '      ' // trim(name) // ' = ' )
      else
        call output ( '      No ' // trim(name), advance='yes' )
      end if
    end subroutine Maybe_Dump_1_RT

    subroutine Maybe_Dump_2_RT ( Array, Name )
      real(rt), intent(in), pointer :: Array(:,:)
      character(*), intent(in) :: Name
      if ( associated(array) ) then
        call dump ( array, '      ' // trim(name) )
      else
        call output ( '      No ' // trim(name), advance='yes' )
      end if
    end subroutine Maybe_Dump_2_RT

  end subroutine Dump_Quantity_Template

  ! ------------------------------------  Dump_Quantity_Templates  -----
  subroutine Dump_Quantity_Templates ( Quantity_Templates, Details, NoL2CF, What )

    type(QuantityTemplate_T), intent(in) :: Quantity_Templates(:)
    integer, intent(in), optional :: Details ! <= 0 => Don't dump arrays
    !                                        ! >0   => Do dump arrays
    !                                        ! Default 1
    logical, intent(in), optional :: NoL2CF  ! if TRUE => Don't dump l2-specific
    character(*), intent(in), optional :: What ! In case you want to label it

    integer :: I

    call output ( size(quantity_templates), &
                & before='Quantity_Templates: SIZE = ', advance='yes' )
    do i = 1, size(quantity_templates)
      call output ( i, 4 )
      call output ( ':' )
      call dump_quantity_template ( quantity_templates(i), details, nol2cf, What )
    end do

  end subroutine Dump_Quantity_Templates

  ! ------------------------------ InflateQuantityTemplateDatabase -----
  integer function InflateQuantityTemplateDatabase ( database, extra )
    ! Make a quantity template database bigger by extra
    ! Return index of first new element

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type (QuantityTemplate_T), dimension(:), pointer :: DATABASE
    integer, intent(in) :: EXTRA

    ! Local variables
    type (QuantityTemplate_T), dimension(:), pointer :: TEMPDATABASE

    include "inflateDatabase.f9h"
    InflateQuantityTemplateDatabase = firstNewItem
  end function InflateQuantityTemplateDatabase

! --------------------------------------------------------  IsQTM  -----
  pure logical function IsQTM ( Qty )
    class(QuantityTemplate_T), intent(in) :: Qty
    IsQTM = associated(qty%the_Hgrid)
    if ( IsQTM ) IsQTM = qty%the_Hgrid%type == L_QTM
    if ( isQTM ) IsQTM = allocated ( qty%the_Hgrid%QTM_Tree )
  end function IsQTM

  ! ------------------------------------  ModifyQuantityTemplate   -----
  ! This family modifies a quantity template's fields according to
  ! specified input
  ! This is something of a hack: normally we create a quantity template
  ! and its fields are filled according to its type and any vgrids,
  ! hgrids, and fgrids specified at that time
  ! However, in order to reverse-engineer an l2cf we may wish to
  ! go back later and override these fields by a Fill command

  subroutine ModifyQuantityTemplate_allocate  ( Z, FIELD, SHP, VALUESNODE, &
    & spread )
    ! This routine modifies any field whose name matches the field
    ! so that it takes the new values supplied by the source array
    
    ! Note that we assume the destination field is large enough
    ! to accomodate the source array
    
    ! How would you go about changing integer or l_ -valued fields?
    type (QuantityTemplate_T), intent(inout) :: Z
    character(len=*), intent(in)             :: field
    integer, dimension(:), intent(in)        :: SHP
    integer, intent(in)                      :: VALUESNODE   ! Tree node for values
    logical, intent(in)                      :: spread
    ! Executable
    if ( findFirst(MODIFIABLEFIELDS, lowercase(field)) < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName // &
        & 'ModifyQuantityTemplate_allocate', &
        & trim(field) // " not a modifiable field" )
    end if
    select case(lowercase(field))
    case ( 'surfs' )
      if ( any(shape(z%surfs) /= shp) ) then
        call deallocate_test( z%surfs, 'template surfs', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        call allocate_test ( z%surfs, shp(1), shp(2), &
          & "template surfs", &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
      end if
      call myValuesToField( z%surfs, SHP, VALUESNODE, spread, PHYQ_Dimensionless )
    case ( 'phi' )
      if ( any(shape(z%phi) /= shp) ) then
        call deallocate_test( z%phi, 'template phi', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        call allocate_test ( z%phi, shp(1), shp(2), &
          & "template phi", &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
      end if
      call myValuesToField( z%phi, SHP, VALUESNODE, spread, phyq_angle )
    case ( 'geodlat' )
      if ( any(shape(z%geodlat) /= shp) ) then
        call deallocate_test( z%geodLat, 'template geodLat', &
          & ModuleName // '%ModifyQuantityTemplate_allocate' )
        call createLatitudeFields ( z, size(z%the_hGrid%geodLat,1), &
          & 'ModifyQuantityTemplate' )
      end if
      call myValuesToField( z%geodLat, SHP, VALUESNODE, spread, phyq_angle )
    case ( 'lon' )
      if ( any(shape(z%lon) /= shp) ) then
        call deallocate_test( z%lon, 'template lon', &
          & ModuleName // '%ModifyQuantityTemplate_allocate' )
        call createLongitudeFields ( z, size(z%the_hGrid%Lon,1), &
          & 'ModifyQuantityTemplate' )
      end if
      call myValuesToField( z%lon, SHP, VALUESNODE, spread, phyq_angle )
    case ( 'time' )
      if ( any(shape(z%time) /= shp) ) then
        call deallocate_test( z%time, 'template time', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        call allocate_test ( z%time, shp(1), shp(2), &
          & "template time", &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
      end if
      call myValuesToField( z%time, SHP, VALUESNODE, spread, phyq_time )
    case ( 'solartime' )
      if ( any(shape(z%solartime) /= shp) ) then
        call deallocate_test( z%solartime, 'template solartime', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        call allocate_test ( z%solartime, shp(1), shp(2), &
          & "template solartime", &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
      end if
      call myValuesToField( z%solartime, SHP, VALUESNODE, spread, phyq_time )
    case ( 'solarzenith' )
      if ( any(shape(z%solarzenith) /= shp) ) then
        call deallocate_test( z%solarzenith, 'template solarzenith', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        call allocate_test ( z%solarzenith, shp(1), shp(2), &
          & "template solarzenith", &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
      end if
      call myValuesToField( z%solarzenith, SHP, VALUESNODE, spread, phyq_angle )
    case ( 'losangle' )
      if ( any(shape(z%losangle) /= shp) ) then
        call deallocate_test( z%losangle, 'template losangle', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        call allocate_test ( z%losangle, shp(1), shp(2), &
          & "template losangle", &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
      end if
      call myValuesToField( z%losangle, SHP, VALUESNODE, spread, phyq_angle )
    case ( 'frequencies' )
      if ( .not. associated(z%frequencies) ) then
        call allocate_test ( z%frequencies, shp(1), &
          & "template frequencies", &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
      else if ( size(z%frequencies) /= shp(1) ) then
        call deallocate_test( z%frequencies, 'template frequencies', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        call allocate_test ( z%frequencies, shp(1), &
          & "template frequencies", &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
      end if
      call myValuesToField( z%frequencies, VALUESNODE, spread, phyq_frequency )
    case default
    end select
    if ( lowercase(field) == 'surfs' ) then
      z%NoSurfs = shp(1)
      if ( .not. z%coherent ) z%noInstances = shp(2)
    else if ( lowercase(field) == 'frequencies' ) then
      z%NoChans = shp(1)
    else
      z%noInstances = shp(2)
      if ( .not. z%stacked ) z%NoSurfs = shp(1)
    end if
  end subroutine ModifyQuantityTemplate_allocate

  subroutine ModifyQuantityTemplate_array  ( Z, FIELD, array, spread )
    ! This routine modifies any field whose name matches the field
    ! so that it takes the new values supplied by the source array
    
    ! Note that we assume the destination field is large enough
    ! to accomodate the source array
    
    ! How would you go about changing integer or l_ -valued fields?
    type (QuantityTemplate_T), intent(inout) :: Z
    character(len=*), intent(in)             :: field
    real(rt), dimension(:,:), intent(in)     :: array
    logical, intent(in)                      :: spread
    ! Local variables
    integer :: shp(2)
    ! Executable
    if ( findFirst(MODIFIABLEFIELDS, lowercase(field)) < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName // &
        & 'ModifyQuantityTemplate_allocate', &
        & trim(field) // " not a modifiable field" )
    end if
    shp = shape(array)
    if ( spread .and. shp(1) == 1 ) then
      select case(lowercase(field))
      case ( 'surfs' )
        z%surfs(:,1:shp(2)) = array
      case ( 'phi' )
        z%phi(:,1:shp(2)) = array
      case ( 'geodlat' )
        z%geodLat(:,1:shp(2)) = array
      case ( 'lon' )
        z%lon(:,1:shp(2)) = array
      case ( 'time' )
        z%time(:,1:shp(2)) = array
      case ( 'solartime' )
        z%solartime(:,1:shp(2)) = array
      case ( 'solarzenith' )
        z%solarzenith(:,1:shp(2)) = array
      case ( 'losangle' )
        z%losangle(:,1:shp(2)) = array
      case ( 'frequencies' )
        z%frequencies(:) = array(1,1)
      case default
      end select
    else if ( spread .and. shp(2) == 1 ) then
      select case(lowercase(field))
      case ( 'surfs' )
        z%surfs(1:shp(1),:) = array
      case ( 'phi' )
        z%phi(1:shp(1),:) = array
      case ( 'geodlat' )
        z%geodLat(1:shp(1),:) = array
      case ( 'lon' )
        z%lon(1:shp(1),:) = array
      case ( 'time' )
        z%time(1:shp(1),:) = array
      case ( 'solartime' )
        z%solartime(1:shp(1),:) = array
      case ( 'solarzenith' )
        z%solarzenith(1:shp(1),:) = array
      case ( 'losangle' )
        z%losangle(1:shp(1),:) = array
      case ( 'frequencies' )
        z%frequencies(:) = array(1,1)
      case default
      end select
    else
      select case(lowercase(field))
      case ( 'surfs' )
        z%surfs(1:shp(1),1:shp(2)) = array
      case ( 'phi' )
        z%phi(1:shp(1),1:shp(2)) = array
      case ( 'geodlat' )
        z%geodLat(1:shp(1),1:shp(2)) = array
      case ( 'lon' )
        z%lon(1:shp(1),1:shp(2)) = array
      case ( 'time' )
        z%time(1:shp(1),1:shp(2)) = array
      case ( 'solartime' )
        z%solartime(1:shp(1),1:shp(2)) = array
      case ( 'solarzenith' )
        z%solarzenith(1:shp(1),1:shp(2)) = array
      case ( 'losangle' )
        z%losangle(1:shp(1),1:shp(2)) = array
      case ( 'frequencies' )
        z%frequencies(1:shp(1)) = array(:,1)
      case default
      end select
    end if
  end subroutine ModifyQuantityTemplate_array

  subroutine ModifyQuantityTemplate_sca  ( Z, FIELD, NEWVALUE )
    ! This routine modifies any field whose name matches the field
    ! so that it takes the new value
    
    ! How would you go about changing integer or l_ -valued fields?
    type (QuantityTemplate_T), intent(inout) :: Z
    character(len=*), intent(in)             :: field
    real(rt), intent(in)                     :: newvalue
    if ( findFirst(MODIFIABLEFIELDS, lowercase(field)) < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName // &
        & 'ModifyQuantityTemplate_allocate', &
        & trim(field) // " not a modifiable field" )
    end if
    select case(lowercase(field))
    case ( 'surfs' )
      z%surfs = newvalue
    case ( 'phi' )
      z%phi = newvalue
    case ( 'geodlat' )
      z%geodLat = newvalue
    case ( 'lon' )
      z%lon = newvalue
    case ( 'time' )
      z%time = newvalue
    case ( 'solartime' )
      z%solartime = newvalue
    case ( 'solarzenith' )
      z%solarzenith = newvalue
    case ( 'losangle' )
      z%losangle = newvalue
    case ( 'frequencies' )
      z%frequencies = newvalue
    case default
    end select
  end subroutine ModifyQuantityTemplate_sca

  ! ------------------------------------  NullifyQuantityTemplate  -----
  subroutine NullifyQuantityTemplate ( IntentionallyNotUsed )
    ! Given a quantity template, nullify all the pointers within it
    type ( QuantityTemplate_T ), intent(out) :: IntentionallyNotUsed

    ! Executable code not needed because IntentionallyNotUsed is intent(out),
    ! and therefore undergoes default initialization as a consequence of
    ! argument association. Since all pointers within it have default
    ! initialization, they therefore become nullified.

    ! All non-pointer components of course become undefined and so must
    ! be explicitly defined after the call.

  end subroutine NullifyQuantityTemplate

  ! ---------------------------------------  GetHGridFromQuantity  -----
  subroutine GetHGridFromQuantity ( Qty )

  ! This routine associates HGrid information from an already defined quantity,
  ! except that if Qty%NoCrossTrack > 1, it creates a copy.

    use HGridsDatabase, only: HGrid_T, CreateEmptyHGrid
    use Toggles, only: Gen, Levels, Toggle
    use Trace_m, only: Trace_Begin, Trace_End

    ! Dummy argument
    type (QuantityTemplate_T), intent(inout) :: Qty

    ! Local variables
    integer :: Me = -1                  ! String index for trace
    type (hGrid_T), pointer :: HGrid

    ! Executable code

    call trace_begin ( me, "GetHGridFromQuantity", &
      & cond=toggle(gen) .and. levels(gen) > 2 )
    nullify ( HGrid )
    qty%the_hGrid             => HGrid              
    HGrid%noProfs             = qty%noInstances     
    HGrid%noProfsLowerOverlap = qty%noInstancesLowerOverlap
    HGrid%noProfsUpperOverlap = qty%noInstancesUpperOverlap
    call CreateEmptyHGrid ( hGrid )
    HGrid%time                => qty%time              
    HGrid%solarTime           => qty%solarTime         
    HGrid%solarZenith         => qty%solarZenith       
    HGrid%losAngle            => qty%losAngle          
    call trace_end ( "GetHGridFromQuantity", &
      & cond=toggle(gen) .and. levels(gen) > 2 )

  end subroutine GetHGridFromQuantity

  ! ---------------------------------------  PointQuantityToHGrid  -----
  subroutine PointQuantityToHGrid ( Qty )

  ! This routine associates HGrid information into an already defined quantity,
  ! except that if Qty%NoCrossTrack > 1, it creates a copy.

    use HGridsDatabase, only: HGrid_T
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MoreMessage, only: MLSMessage
    use Toggles, only: Gen, Levels, Toggle
    use Trace_m, only: Trace_Begin, Trace_End

    ! Dummy argument
    type (QuantityTemplate_T), intent(inout) :: Qty

    ! Local variables
    integer :: I, J, K
    integer :: Me = -1                  ! String index for trace
    type (hGrid_T), pointer :: HGrid

    ! Executable code

    call trace_begin ( me, "PointQuantityToHGrid", &
      & cond=toggle(gen) .and. levels(gen) > 2 )

    hGrid => qty%the_hGrid

    if ( qty%noInstances/=hGrid%noProfs ) call MLSMessage ( MLSMSG_Error,&
      & ModuleName, "Size of HGrid not compatible with size of quantity" )

    call allocate_test ( qty%phi, merge(1,qty%noSurfs, qty%stacked), &
      & qty%noInstances*qty%noCrossTrack, 'qty%phi', ModuleName )
    if ( qty%stacked ) then
      if ( qty%noCrossTrack == 1 ) then
        qty%phi(:,:) = hGrid%phi
      else
        do k = 1, qty%noCrossTrack
          do j = 1, size(hGrid%phi,2)
            do i = 1, size(hGrid%phi,1)
              call qty%putPhi3 ( i, j, k, hGrid%phi(i,j) )
            end do
          end do
        end do
      end if
      call CreateGeolocationFields ( qty, size(hGrid%geodLat,1), 'Qty' )
      do k = 1, qty%noCrossTrack
        do j = 1, qty%noInstances ! size(qty%geodLat,2) would include cross-track
          do i = 1, size(qty%geodLat,1)
            call qty%putLat3 ( i, j, k, real(hGrid%geodLat(i,j),rt) )
            call qty%putLon3 ( i, j, k, real(hGrid%lon(i,j),rt) )
          end do
        end do
      end do
    else
      call CreateGeolocationFields ( qty, qty%noSurfs, 'Qty' )
      if ( qty%name /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & "Cannot copy hGrids into unstacked quantity %S" // &
        & "; assume Lat, Lon, Phi computed somehow.", qty%name)
      else
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & "Cannot copy hGrids into unstacked quantities " // &
          & "; assume Lat, Lon, Phi computed somehow.")
      end if
    end if
    qty%time                    => hGrid%time
    qty%solarTime               => hGrid%solarTime
    qty%solarZenith             => hGrid%solarZenith
    qty%losAngle                => hGrid%losAngle
    qty%noInstancesLowerOverlap = hGrid%noProfsLowerOverlap
    qty%noInstancesUpperOverlap = hGrid%noProfsUpperOverlap

    call trace_end ( "PointQuantityToHGrid", &
      & cond=toggle(gen) .and. levels(gen) > 2 )

  end subroutine PointQuantityToHGrid

  ! ------------------------------------  QuantitiesAreCompatible  -----
  logical function QuantitiesAreCompatible ( Qty_1, Qty_2, DifferentTypeOK, &
                                           & DifferentChansOK )
    use Intrinsic, only: L_QTM
    type(quantityTemplate_t), intent(in) :: Qty_1, Qty_2
    logical, intent(in), optional :: DifferentTypeOK ! Quantity, not hGrid, type
    logical, intent(in), optional :: DifferentChansOK

    QuantitiesAreCompatible = qty_1%quantityType == qty_2%quantityType
    if ( present(differentTypeOK) ) then
      if ( differentTypeOK ) QuantitiesAreCompatible = .true.
    end if
    if ( .not. QuantitiesAreCompatible ) return
    QuantitiesAreCompatible = associated(qty_1%the_hGrid) .eqv. &
                            & associated(qty_2%the_hGrid)
    if ( .not. QuantitiesAreCompatible ) return
    if ( associated(qty_1%the_hGrid) ) then
      QuantitiesAreCompatible = qty_1%the_hGrid%type == qty_2%the_hGrid%type
      if ( .not. QuantitiesAreCompatible ) return
      if ( qty_1%the_hGrid%type .eq. l_QTM ) then
        QuantitiesAreCompatible = allocated(qty_1%the_hGrid%QTM_tree%ZOT_in) .and. &
                                & allocated(qty_2%the_hGrid%QTM_tree%ZOT_in)
        if ( QuantitiesAreCompatible ) &
          & QuantitiesAreCompatible = size(qty_1%the_hGrid%QTM_tree%ZOT_in) == &
                                    & size(qty_2%the_hGrid%QTM_tree%ZOT_in)
      else
        QuantitiesAreCompatible = .not. allocated(qty_1%the_hGrid%QTM_tree%ZOT_in) .and. &
                                & .not. allocated(qty_2%the_hGrid%QTM_tree%ZOT_in)
      end if
    end if
    if ( .not. QuantitiesAreCompatible ) return
    QuantitiesAreCompatible = qty_1%noChans == qty_2%noChans
    if ( present(differentChansOK) ) then
      if ( differentChansOK ) QuantitiesAreCompatible = .true.
    end if
    if ( .not. QuantitiesAreCompatible ) return

    QuantitiesAreCompatible = &
      & qty_1%noInstances == qty_2%noInstances .and. &
      & qty_1%noSurfs == qty_2%noSurfs .and. &
      & qty_1%noCrossTrack == qty_2%noCrossTrack .and. &
      & qty_1%coherent .eqv. qty_2%coherent .and. &
      & qty_1%stacked .eqv. qty_2%stacked .and. &
      & qty_1%regular .eqv. qty_2%regular .and. &
      & qty_1%minorFrame .eqv. qty_2%minorFrame .and. &
      & qty_1%majorFrame .eqv. qty_2%majorFrame .and. &
      & qty_1%logBasis .eqv. qty_2%logBasis .and. &
      & qty_1%instanceLen == qty_2%instanceLen .and. &
      & qty_1%verticalCoordinate == qty_2%verticalCoordinate .and. &
      & qty_1%grandTotalInstances == qty_2%grandTotalInstances .and. &
      & qty_1%frequencyCoordinate == qty_2%frequencyCoordinate

  end function QuantitiesAreCompatible

  ! ----------------------------  ReadAttributes_QuantityTemplate  -----
  subroutine ReadAttributes_QuantityTemplate ( dsID, QT )
    ! Note:
    ! Most or all of the character-valued attributes are to be stored in the 
    ! quantity template as string table indexes or other indexes, e.g. signals
    ! Therefore we must do a bit of table lookups
    use Declaration_Table, only: Decls, Get_Decl, Phys_Unit_Name
    use Intrinsic, only: L_Dimensionless
    use MLSHDF5, only: GetHDF5Attribute
    use MLSSignals_m, only: GetRadiometerIndex, GetModuleIndex, &
      & GetSignalIndex

    ! Arguments
    integer, intent(in) :: dsID
    type(QuantityTemplate_T), intent(inout) :: qt

    type(decls) :: Decl
    character (len=80) :: Str
    ! Executable
    call GetHDF5AttrAsStrID ( dsID, 'TemplateName', qt%name )
    call GetHDF5AttrAsLitID ( dsID, 'tempQtyType', qt%quantityType )
    call GetHDF5Attribute ( dsID, 'noInstances', qt%noInstances )
    call GetHDF5Attribute ( dsID, 'noChans    ', qt%noChans     )
    call GetHDF5Attribute ( dsID, 'noSurfs    ', qt%noSurfs     )
    call GetHDF5Attribute ( dsID, 'coherent   ', qt%coherent     )
    call GetHDF5Attribute ( dsID, 'stacked    ', qt%stacked     )
    call GetHDF5Attribute ( dsID, 'regular    ', qt%regular     )
    call GetHDF5Attribute ( dsID, 'logBasis    ', qt%logBasis     )
    call GetHDF5Attribute ( dsID, 'minorFrame    ', qt%minorFrame     )
    call GetHDF5Attribute ( dsID, 'badValue    ', qt%badValue     )
    call GetHDF5Attribute ( dsID, 'tempQtyUnit', str )
    decl = get_decl ( str, phys_unit_name )
    if ( decl%type == phys_unit_name ) then
      qt%unit = decl%tree
    else ! ??? Should we emit an error message here ???
      qt%unit = l_dimensionless
    end if
    call GetHDF5Attribute ( dsID, 'instanceLen    ', qt%instanceLen     )
    call GetHDF5AttrAsLitID ( dsID, 'verticalCoordinate', qt%verticalCoordinate )
    call GetHDF5Attribute ( dsID, 'radiometer', str )
    call GetRadiometerIndex ( str, qt%radiometer )
    call GetHDF5AttrAsLitID ( dsID, 'molecule', qt%molecule )
    call GetHDF5Attribute ( dsID, 'instrumentModule', str )
    call GetModuleIndex ( str, qt%instrumentModule )
    call GetHDF5Attribute ( dsID, 'signal', str )
    call GetSignalIndex( str, qt%signal )
  end subroutine ReadAttributes_QuantityTemplate

  ! -----------------------------------  SetupNewQuantityTemplate  -----
  subroutine SetupNewQuantityTemplate ( qty, noInstances, noSurfs, &
    & noChans, coherent, stacked, regular, instanceLen, noCrossTrack, &
    & minorFrame, majorFrame, &
    & sharedVGrid, sharedFGrid, badValue, verticalCoordinate )

    use Intrinsic, only: L_Dimensionless

  ! Set up a new quantity template according to the user input.  This may
  ! be based on a previously supplied template (with possible
  ! modifications), or created from scratch.  The name isn't set here; the
  ! caller is expected to do it.

    ! Dummy arguments
    type (QuantityTemplate_T), intent(inout) :: qty ! Result

    integer, intent(in), optional :: noInstances
    integer, intent(in), optional :: noSurfs
    integer, intent(in), optional :: noChans
    logical, intent(in), optional :: coherent
    logical, intent(in), optional :: stacked
    logical, intent(in), optional :: regular
    integer, intent(in), optional :: instanceLen
    integer, intent(in), optional :: noCrossTrack
    logical, intent(in), optional :: minorFrame
    logical, intent(in), optional :: majorFrame
    logical, intent(in), optional :: sharedVGrid
    logical, intent(in), optional :: sharedFGrid
    real(rt), intent(in), optional :: badValue
    integer, intent(in), optional, value :: verticalCoordinate ! VALUE in case
                                        ! actual arg is qty%verticalCoordinate

    ! Local variables
    integer :: noSurfsToAllocate        ! For allocations
    integer :: noInstancesToAllocate    ! For allocations
    logical :: Verbose
    logical :: Verboser
    character(63) :: What

    ! Executable code
    if ( qty%name > 0 ) then
      call mygetString ( qty%name, what )
    else
      what = "qty"
    end if
    verbose = ( switchDetail(switches, 'qtmp' ) > -1 )
    verboser = ( switchDetail(switches, 'qtmp' ) > 0 )
    qty%quantityType = 0
    qty%noChans = 1
    qty%noInstances = 1
    qty%noSurfs = 1
    qty%noCrossTrack = 1
    qty%coherent = .true.
    qty%stacked = .true.
    qty%regular = .true.
    qty%minorFrame = .false.
    qty%majorFrame = .false.
    qty%logBasis = .false.
    qty%minValue = - huge ( 0.0_rt )
    qty%noInstancesLowerOverlap = 0
    qty%noInstancesUpperOverlap = 0
    qty%badValue = huge ( 0.0_rt )
    qty%unit = l_dimensionless
    qty%instanceLen = 1
    qty%verticalCoordinate = l_none
    qty%sharedVGrid = .false.
    qty%vGridIndex = 0
    qty%xGridIndex = 0
    qty%horizontalCoordinate = l_phiTan
    qty%hGridIndex = 0
    qty%instanceOffset = 0
    qty%frequencyCoordinate = l_none
    qty%sharedFGrid = .false.
    qty%fGridIndex = 0
    qty%lo = 0.0_rt
    qty%signal = 0
    qty%sideband = 0
    qty%instrumentModule = 0
    qty%radiometer = 0
    qty%reflector = 0
    qty%molecule = 0

    ! Now, see if the user asked for modifications to this
    if ( present (noChans) )            qty%noChans = noChans
    if ( present (noInstances) )        qty%noInstances = noInstances
    if ( present (noSurfs) )            qty%noSurfs = noSurfs
    if ( present (noCrossTrack) )       qty%noCrossTrack = noCrossTrack
    if ( present (regular) )            qty%regular = regular
    if ( present (minorFrame) )         qty%minorFrame = minorFrame
    if ( present (majorFrame) )         qty%majorFrame = majorFrame
    if ( present (sharedVGrid) )        qty%sharedVGrid = sharedVGrid
    if ( present (sharedFGrid) )        qty%sharedFGrid = sharedFGrid
    if ( present (badValue) )           qty%badValue = badValue
    if ( present (verticalCoordinate) ) qty%verticalCoordinate = verticalCoordinate

    if ( qty%minorFrame ) then
      if ( present(coherent) ) then
        if ( coherent ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Minor frame quantities must be incoherent" )
      end if
      qty%coherent = .FALSE.
      if ( present(stacked) ) then
        if ( stacked ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Minor frame quantities must be unstacked" )
      end if
      qty%stacked = .FALSE.
    else
      if ( present(coherent) ) qty%coherent = coherent
      if ( present(stacked) ) qty%stacked = stacked
    end if

    ! Now think about instanceLen
    if ( .not. qty%regular ) then
      if ( present(instanceLen) ) then
        qty%instanceLen = instanceLen
      else
        qty%instanceLen = 0
      end if
    else
      qty%instanceLen = qty%noSurfs * qty%noChans * qty%noCrossTrack
    end if

    ! Now we allocate all the arrays we're going to need if necessary
    if ( qty%coherent ) then
      noInstancesToAllocate = 1
    else
      noInstancesToAllocate = qty%noInstances
    end if

    if ( qty%stacked ) then
      noSurfsToAllocate = 1
    else
      noSurfsToAllocate = qty%noSurfs
    end if

    ! First the vertical coordinates
    if ( .not. qty%sharedVGrid ) then
      what = trim(what) // "%surfs"
      call allocate_test ( qty%surfs, qty%noSurfs, noInstancesToAllocate, &
        & what(1:len_trim(what)), ModuleName )
    end if

    ! Now the horizontal coordinates

    call allocate_test ( qty%crossAngles, qty%noCrossTrack, &
      & trim(what) // "%crossAngles", ModuleName )
    qty%crossAngles = 0.0 ! In case there actually is no xGrid
    call allocate_test ( qty%phi, noSurfsToAllocate, qty%noInstances, &
      & trim(what) // "%phi", ModuleName )
    ! Create GeodLat and Lon fields.
    call createGeolocationFields ( qty, noSurfsToAllocate, what )
    call allocate_test ( qty%time, noSurfsToAllocate, qty%noInstances, &
      & trim(what) // "%time", ModuleName )
    call allocate_test ( qty%solarTime, noSurfsToAllocate, qty%noInstances, &
      & trim(what) // "%solarTime", ModuleName )
    call allocate_test ( qty%solarZenith, noSurfsToAllocate, qty%noInstances, &
      & trim(what) // "%solarZenith", ModuleName )
    call allocate_test ( qty%losAngle, noSurfsToAllocate, qty%noInstances, &
      & trim(what) // "%losAngle", ModuleName )

    if ( .not. qty%regular ) then        !
      call allocate_test ( qty%surfIndex, qty%instanceLen, qty%noInstances, &
        & trim(what) // "%surfIndex", ModuleName )
      call allocate_test ( qty%chanIndex, qty%instanceLen, qty%noInstances, &
        & trim(what) // "%chanIndex", ModuleName )
    else
      nullify ( qty%surfIndex, qty%chanIndex )
    end if
    if ( verbose ) &
      & call outputnamedvalue ( 'grandTotalInstances (from setup)', qty%grandTotalInstances )

    if ( verboser )  call dump(qty, details=0, noL2CF=.true.)
  end subroutine SetupNewQuantityTemplate

  ! ---------------------------  WriteAttributes_QuantityTemplate  -----
  subroutine WriteAttributes_QuantityTemplate ( dsID, NAME, &
    & QT, NOL2CF )

    use MLSHDF5, only: MakeHDF5Attribute
    use MLSSignals_m, only: GetRadiometerName, GetModuleName, &
      & GetSignalName

    ! Arguments
    integer, intent(in) :: dsID
    character(len=*), intent(in) :: name
    type(QuantityTemplate_T), intent(in) :: qt
    logical, intent(in), optional :: NOL2CF  ! if TRUE => Skip l2cf-dependent
                                             ! attributes
    character (len=80) :: Str
    logical :: myNoL2CF
    ! Executable
    myNoL2CF = switchDetail(switches, 'nl2cf') > -1 ! .false.
    if ( present(NoL2CF) ) myNoL2CF = NoL2CF
    call myGetString ( qt%name, str, strip=.true. )
    call MakeHDF5Attribute ( dsID, name, 'TemplateName', str )
    if ( .not. myNoL2CF ) then
      call myGetString ( lit_indices(qt%quantityType), str, strip=.true. )
      call MakeHDF5Attribute ( dsID, name, 'tempQtyType', str )
    end if
    call MakeHDF5Attribute ( dsID, name, 'noInstances', qt%noInstances )
    call MakeHDF5Attribute ( dsID, name, 'noChans    ', qt%noChans     )
    call MakeHDF5Attribute ( dsID, name, 'noSurfs    ', qt%noSurfs     )
    call MakeHDF5Attribute ( dsID, name, 'coherent   ', qt%coherent     )
    call MakeHDF5Attribute ( dsID, name, 'stacked    ', qt%stacked     )
    call MakeHDF5Attribute ( dsID, name, 'regular    ', qt%regular     )
    call MakeHDF5Attribute ( dsID, name, 'logBasis    ', qt%logBasis     )
    call MakeHDF5Attribute ( dsID, name, 'minorFrame    ', qt%minorFrame     )
    call MakeHDF5Attribute ( dsID, name, 'badValue    ', qt%badValue     )
    if ( .not. myNoL2CF ) then
      call myGetString ( lit_indices(qt%unit), str, strip=.true. )
      call MakeHDF5Attribute ( dsID, name, 'tempQtyUnit', str )
    end if
    call MakeHDF5Attribute ( dsID, name, 'instanceLen    ', qt%instanceLen     )
    if ( .not. myNoL2CF ) then
      call myGetString ( lit_indices(qt%verticalCoordinate), str, strip=.true. )
      call MakeHDF5Attribute ( dsID, name, 'verticalCoordinate', str )
    end if
    if ( qt%radiometer /= 0 .and. .not. myNoL2CF ) then
      call GetRadiometerName ( qt%radiometer, str )
      call MakeHDF5Attribute ( dsID, name, 'radiometer', str )
    end if
    if ( qt%molecule + &
      &  qt%instrumentModule /= 0 .and. .not. myNoL2CF ) then
      if ( qt%molecule /= 0 ) then
        call myGetString ( lit_indices(qt%molecule), str, strip=.true. )
        call MakeHDF5Attribute ( dsID, name, 'molecule', str )
      end if
      if ( qt%instrumentModule /= 0 ) then
        call GetModuleName ( qt%instrumentModule, str )
        call MakeHDF5Attribute ( dsID, name, 'tempQtyInstrumentModule', str )
      end if
    end if
    if ( qt%signal /= 0 ) then
      call GetSignalName ( qt%signal, str )
      call MakeHDF5Attribute ( dsID, name, 'signal', str )
    end if
    ! Should we always write these, or only when specifically requested?
    if ( allocated(qt%surfs) ) &
      & call MakeHDF5Attribute ( dsID, name, 'surfs', qt%surfs(:,1) )
  end subroutine WriteAttributes_QuantityTemplate

  ! =====      Private procedures     ==================================

  ! ----------------------------  CheckIntegrity_QuantityTemplate  -----
  logical function CheckIntegrity_QuantityTemplate ( qty, noError )
    type (QuantityTemplate_T), intent(in) :: QTY
    logical, intent(in), optional :: NOERROR

    ! Local variables
    integer :: NOINSTANCESOR1           ! Test value
    integer :: NOSURFSOR1               ! Test value

    integer :: MESSAGETYPE
    character ( len=132 ) :: NAME

    ! Executable code
    messageType = MLSMSG_Error
    if ( present ( noError ) ) then
      if ( noError ) messageType = MLSMSG_Warning
    end if

    ! Now check the integrity of the template
    if ( qty%coherent ) then
      noInstancesOr1 = 1
    else
      noInstancesOr1 = qty%noInstances
    end if

    if ( qty%stacked ) then
      noSurfsOr1 = 1
    else
      noSurfsOr1 = qty%noSurfs
    end if

    if ( qty%name > 0 ) then
      call myGetString ( qty%name, name, strip=.true. )
    else
      name = '<no name>'
    end if

    CheckIntegrity_QuantityTemplate = .true.

    ! Check the instances / overlap stuff
    if ( qty%noInstances < 0 ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad noInstances for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( ( qty%noInstancesLowerOverlap < 0 ) .or. &
      &  ( qty%noInstancesLowerOverlap > qty%noInstances ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Inappropriate noInstancesLowerOverlap for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( ( qty%noInstancesUpperOverlap < 0 ) .or. &
      &  ( qty%noInstancesUpperOverlap > qty%noInstances ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Inappropriate noInstancesUpperOverlap for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( qty%noInstancesLowerOverlap + qty%noInstancesUpperOverlap > &
      & qty%noInstances ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Too much overlap for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the surfaces stuff
    if ( qty%noSurfs < 0 ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad noSurfs for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the channels stuff
    if ( qty%noChans < 0 ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad noChans for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the instanceLen
    if ( qty%regular .and. &
      & qty%InstanceLen /= qty%noSurfs * qty%noChans ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The quantity template '//trim(name)//' does not have the right instanceLen' )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the arrays are associated.  Note these have to be errors, as later
    ! tests will fail otherwise.
    if ( .not. allocated ( qty%surfs ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have surfs associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( .not. allocated ( qty%phi ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have phi allocated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( .not. allocated ( qty%geodLat ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have geodLat associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( .not. allocated ( qty%lon ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have lon associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( .not. associated ( qty%time ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have time associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( .not. associated ( qty%solarTime ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have solarTime associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( .not. associated ( qty%solarZenith ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have solarZenith associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( .not. associated ( qty%losAngle ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have losAngle associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the array lower bounds
    if ( any ( lbound ( qty%surfs ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for surfs array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( any ( lbound ( qty%phi ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for phi array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( any ( lbound ( qty%geodLat ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for geodLat array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( lbound ( qty%lon ) /= (/1,1/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for lon array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( lbound ( qty%time ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for time array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( lbound ( qty%solarTime ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for solarTime array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( lbound ( qty%solarZenith ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for solarZenith array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( lbound ( qty%losAngle ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for losAngle array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the array upper bounds
    if ( any ( ubound ( qty%surfs ) /= (/qty%noSurfs, noInstancesOr1/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for surfs array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( any ( ubound ( qty%phi ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for phi array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( any ( ubound ( qty%geodLat ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for geodLat array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( ubound ( qty%lon ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for lon array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( ubound ( qty%time ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for time array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( ubound ( qty%solarTime ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for solarTime array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( ubound ( qty%solarZenith ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for solarZenith array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( ubound ( qty%losAngle ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for losAngle array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check irregular stuff
    if ( .not. qty%regular ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The quantity '//trim(name)//' appears to be irregular' )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Could check channels stuff here, but not sure what to do.

  end function CheckIntegrity_QuantityTemplate

  ! -----------------------------------------  GetHDF5AttrAsLitID  -----
  subroutine GetHDF5AttrAsLitID ( dsID, attrName, LitID )
    ! Given a DS, File or GroupID, find the character-valued attribute
    ! for the attribute named attrName of the dataset name
    ! Look up its id in the lit indices and return that id as LitID
    use Intrinsic, only: First_Lit, Last_Auto_Lit
    use MLSHDF5, only: GetHDF5Attribute
    use String_Table, only: Add_Char, Lookup
    ! Args
    integer, intent(in)           :: dsID      ! dataset, file or group ID
    character(len=*), intent(in)  :: attrName  ! attribute name
    integer, intent(out)          :: LitID     ! where to find attr's value
    ! Internal variables
    logical :: found
    character(len=64) :: str
    integer :: strID
    ! litID = -1 ! meaning not found
    call GetHDF5Attribute ( dsID, attrname, str )
    call add_char( trim(str) )
    call lookup ( strID, found, caseless=.true., debug=0 )
    do litID=first_lit, Last_auto_lit
      if ( lit_indices(litID) == strID ) return
    end do
    litID = -1 ! Still not found
  end subroutine GetHDF5AttrAsLitID

  ! -----------------------------------------  GetHDF5AttrAsStrID  -----
  subroutine GetHDF5AttrAsStrID ( dsID, attrName, strID )
    ! Given a DS, File or GroupID, find the character-valued attribute
    ! for the attribute named attrName of the dataset name
    ! Look up its id in the string table and return that id as strID
    use MLSHDF5, only: GetHDF5Attribute
    use String_Table, only: Add_Char, Lookup
    use Tree_Types, only: Add_Char
    ! Args
    integer, intent(in)           :: dsID      ! dataset, file or group ID
    character(len=*), intent(in)  :: attrName  ! attribute name
    integer, intent(out)          :: strID     ! where to find attr's value
    ! Internal variables
    logical :: found
    character(len=64) :: str
    strID = -1 ! meaning not found
    call GetHDF5Attribute ( dsID, attrname, str )
    call add_char( trim(str) )
    call lookup ( strID, found, caseless=.true., debug=0 )
    
  end subroutine GetHDF5AttrAsStrID

  ! -------------------------------------------------  GetGeocLat  -----
  pure real(rt) function GetGeocLat ( Qty, Surf, Inst )
    ! Return the geocentric latitude in degrees.
    ! This is intended to be used only as a type-bound function with a
    ! binding named GeocLat.  It's OK to use a surface index without
    ! checking whether the quantity is stacked -- it's checked here.
    use Constants, only: Rad2Deg
    use Geometry, only: GeodToGeocLat
    class(quantityTemplate_t), intent(in) :: Qty
    integer, intent(in) :: Surf, Inst
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    if ( qty%latitudeCoordinate == l_geodetic ) then
      getGeocLat = geodToGeocLat ( qty%geodlat(surfOr1, inst ) ) * rad2deg
    else
      getGeocLat = qty%geodlat(surfOr1, inst )
    end if
  end function GetGeocLat

  ! ------------------------------------------------  GetGeocLat3  -----
  pure real(rt) function GetGeocLat3 ( Qty, Surf, Inst, CrossIndex )
    ! Return the geocentric latitude in degrees.
    ! This is intended to be used only as a type-bound function with a
    ! binding named GeocLat.  It's OK to use a surface index without
    ! checking whether the quantity is stacked -- it's checked here.
    use Constants, only: Rad2Deg
    use Geometry, only: GeodToGeocLat
    class(quantityTemplate_t), intent(in) :: Qty
    integer, intent(in) :: Surf, Inst, CrossIndex
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    if ( qty%latitudeCoordinate == l_geodetic ) then
      getGeocLat3 = geodToGeocLat ( qty%geodlat(surfOr1, &
        & inst + qty%noInstances * ( crossIndex - 1 ) ) ) * rad2deg
    else
      getGeocLat3 = qty%geodlat(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) )
    end if
  end function GetGeocLat3

  ! ----------------------------------------------------  GetLat3  -----
  pure real(rt) function GetLat3 ( Qty, Surf, Inst, CrossIndex )
    ! Return the geodetic latitude in degrees.
    ! This is intended to be used only as a type-bound function with a
    ! binding named GeodLat3.  It's OK to use a surface index without
    ! checking whether the quantity is stacked -- it's checked here.
    use Geometry, only: GeocToGeodLat
    class(quantityTemplate_t), intent(in) :: Qty
    integer, intent(in) :: Surf, Inst, CrossIndex
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    if ( qty%latitudeCoordinate == l_geodetic ) then
      getLat3 = qty%geodlat(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) )
    else
      getLat3 = geocToGeodLat ( qty%geodlat(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) ) )
    end if
  end function GetLat3

  ! ----------------------------------------------------  GetLon3  -----
  pure real(rt) function GetLon3 ( Qty, Surf, Inst, CrossIndex )
    ! This is intended to be used only as a type-bound function with a
    ! binding named Lon3.  It's OK to use a surface index without
    ! checking whether the quantity is stacked -- it's checked here.
    class(quantityTemplate_t), intent(in) :: Qty
    integer, intent(in) :: Surf, Inst, CrossIndex
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    getLon3 = qty%lon(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) )
  end function GetLon3

  ! ----------------------------------------------------  GetPhi3  -----
  pure real(rt) function GetPhi3 ( Qty, Surf, Inst, CrossIndex )
    ! This is intended to be used only as a type-bound function with a
    ! binding named Phi3.  It's OK to use a surface index without
    ! checking whether the quantity is stacked -- it's checked here.
    class(quantityTemplate_t), intent(in) :: Qty
    integer, intent(in) :: Surf, Inst, CrossIndex
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    getPhi3 = qty%phi(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) )
  end function GetPhi3

  ! --------------------------------------------------  GetSurfs3  -----
  pure real(rt) function GetSurfs3 ( Qty, Surf, Inst, CrossIndex )
    ! This is intended to be used only as a type-bound function with a
    ! binding named Surfs3.  It's OK to use a surface index without
    ! checking whether the quantity is stacked -- it's checked here.
    class(quantityTemplate_t), intent(in) :: Qty
    integer, intent(in) :: Surf, Inst, CrossIndex
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    getSurfs3 = qty%Surfs(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) )
  end function GetSurfs3

  ! --------------------------------------------  myDisplayString  -----
  subroutine myDisplayString ( index, advance, before )
    ! Given a string index, display the string or an error message
    use String_Table, only: Display_String, How_Many_Strings
    integer, intent(in) :: index
    character(len=*), intent(in), optional :: advance
    character(len=*), intent(in), optional :: before

    ! Executable code
    if ( present(before) ) call output ( before )
    if ( index < 1 ) then
      call output ( '(string index < 1)', advance=advance )
    else if ( index > how_many_strings() ) then ! How can an integer be a NaN ?????
      call output ( how_many_strings(), before='(string index > ', after=')', &
        & advance=advance )
    else
      call display_string ( index, advance )
    end if
  end subroutine myDisplayString

  ! ------------------------------------------------  myGetString  -----
  subroutine myGetString ( index, what, strip )
    ! Given a string index, Get the string or an error message
    use String_Table, only: Get_String, How_Many_Strings
    integer, intent(in)           :: index
    character(len=*), intent(out) :: what
    logical, intent(in), optional :: strip

    ! Executable code
    if ( index < 1 ) then
      what = '(string index < 1)'
    else if ( index > how_many_strings() ) then
      call writeIntsToChars( how_many_strings(), what )
      what = '(string index >' // trim(what) // ')'
    else
      call get_string ( index, what, strip )
    end if
  end subroutine myGetString

  ! --------------------------------------------  myValuesToField  -----
  ! This family of subroutines assigns from the values field
  ! explicitly to the template's own field
  ! Unless spread is TRUE, we assume there are exactly enough values
  subroutine myValuesToField_1d_dble ( TFIELD, VALUESNODE, SPREAD, TESTUNIT )
    double precision, dimension(:), intent(out)        :: tField ! Template's own field
    integer, intent(in)                      :: VALUESNODE   ! Tree node for values
    logical, intent(in)                      :: spread
    integer, intent(in) :: TestUnit                 ! Unit to use
    ! Internal variables
    integer :: k
    integer :: noValues
    integer, dimension(2) :: unitAsArray ! Unit for value given
    logical :: UNITSERROR               ! From expr
    real (rt), dimension(2) :: valueAsArray ! Value given
    ! Executable code
    if ( valuesNode < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'illegal valuesNode in template field modify' )
    end if
    noValues = nsons(valuesNode) - 1
    if ( noValues < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Too few values in template field modify' )
    end if
    do k = 1, noValues
      call expr_check ( subtree(k+1,valuesNode) , unitAsArray, valueAsArray, &
        & (/testUnit, PHYQ_Dimensionless/), unitsError )
      if ( unitsError ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'No units allowed for values in template field modify' )
      if ( spread ) then
        tField = valueAsArray(1)
        return
      else
        if ( k < size(tField) ) &
          & tField( k ) = valueAsArray(1)
      end if
    end do
  end subroutine myValuesToField_1d_dble

  subroutine myValuesToField_2d_real ( TFIELD, SHP, VALUESNODE, SPREAD, TESTUNIT )
    real, dimension(:,:), intent(out)        :: tField ! Template's own field
    integer, dimension(:), intent(in)        :: SHP
    integer, intent(in)                      :: VALUESNODE   ! Tree node for values
    logical, intent(in)                      :: spread
    integer, intent(in) :: TestUnit                 ! Unit to use
    ! Internal variables
    integer, dimension(2) :: indices
    integer :: k
    integer :: noValues
    integer, dimension(2) :: unitAsArray ! Unit for value given
    logical :: UNITSERROR               ! From expr
    real (rt), dimension(2) :: valueAsArray ! Value given

    ! Executable code
    if ( valuesNode < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'illegal valuesNode in template field modify' )
    end if
    noValues = nsons(valuesNode) - 1
    if ( noValues < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Too few values in template field modify' )
    end if
    ! call outputNamedValue( 'Number of values', NoValues )
    do k = 1, noValues
      call expr_check ( subtree(k+1,valuesNode) , unitAsArray, valueAsArray, &
        & (/testUnit, PHYQ_Dimensionless/), unitsError )
      if ( unitsError ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'No units allowed for values in template field modify' )
      ! call outputNamedValue( 'value', valueAsArray(1) )
      if ( spread ) then
        tField = valueAsArray(1)
        return
      else
        call rerank( k, shp, indices )
        ! call outputNamedValue( 'indices', indices )
        if ( any( indices < 1 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to rerank values in template field modify' )
        if ( all(indices < shp) ) &
          & tField( indices(1), indices(2) ) = valueAsArray(1)
      end if
    end do
  end subroutine myValuesToField_2d_real

  subroutine myValuesToField_2d_dble ( TFIELD, SHP, VALUESNODE, SPREAD, TESTUNIT )
    double precision, dimension(:,:), intent(out)        :: tField ! Template's own field
    integer, dimension(:), intent(in)        :: SHP
    integer, intent(in)                      :: VALUESNODE   ! Tree node for values
    logical, intent(in)                      :: spread
    integer, intent(in) :: TestUnit                 ! Unit to use
    ! Internal variables
    integer, dimension(2) :: indices
    integer :: k
    integer :: noValues
    integer, dimension(2) :: unitAsArray ! Unit for value given
    logical :: UNITSERROR               ! From expr
    real (rt), dimension(2) :: valueAsArray ! Value given

    ! Executable code
    if ( valuesNode < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'illegal valuesNode in template field modify' )
    end if
    noValues = nsons(valuesNode) - 1
    if ( noValues < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Too few values in template field modify' )
    end if
    ! call outputNamedValue( 'Number of values', NoValues )
    do k = 1, noValues
      call expr_check ( subtree(k+1,valuesNode) , unitAsArray, valueAsArray, &
        & (/testUnit, PHYQ_Dimensionless/), unitsError )
      if ( unitsError ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'No units allowed for values in template field modify' )
      ! call outputNamedValue( 'value', valueAsArray(1) )
      if ( spread ) then
        tField = valueAsArray(1)
        return
      else
        call rerank( k, shp, indices )
        ! call outputNamedValue( 'indices', indices )
        if ( any( indices < 1 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to rerank values in template field modify' )
        if ( all(indices <= shp) ) &
          & tField( indices(1), indices(2) ) = valueAsArray(1)
      end if
    end do
  end subroutine myValuesToField_2d_dble

  ! -------------------------------------------------  PutGeocLat  -----
  pure subroutine PutGeocLat ( Qty, Surf, Inst, Lat )
    ! Store a geocentric latitude as if the GeodLat component were a rank-3
    ! array with extents (surfs,insts,cross).  It's OK to use a surface index
    ! without checking whether the quantity is stacked -- it's checked here.
    use Geometry, only: GeocToGeodLat
    class(quantityTemplate_t), intent(inout) :: Qty
    integer, intent(in) :: Surf, Inst
    real(rt), intent(in) :: Lat ! geocentric, degrees
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    if ( qty%latitudeCoordinate == l_geodetic ) then
      qty%geodlat(surfOr1, inst ) = geocToGeodLat ( lat )
    else
      qty%geodlat(surfOr1, inst ) = lat
    end if
  end subroutine PutGeocLat

  ! ------------------------------------------------  PutGeocLat3  -----
  pure subroutine PutGeocLat3 ( Qty, Surf, Inst, CrossIndex, Lat )
    ! Store a geocentric latitude as if the GeodLat component were a rank-3
    ! array with extents (surfs,insts,cross).  It's OK to use a surface index
    ! without checking whether the quantity is stacked -- it's checked here.
    use Geometry, only: GeocToGeodLat
    class(quantityTemplate_t), intent(inout) :: Qty
    integer, intent(in) :: Surf, Inst, CrossIndex
    real(rt), intent(in) :: Lat ! geocentric, degrees
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    if ( qty%latitudeCoordinate == l_geodetic ) then
      qty%geodlat(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) ) = &
        & geocToGeodLat ( lat )
    else
      qty%geodlat(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) ) = lat
    end if
  end subroutine PutGeocLat3

  ! -----------------------------------------------------  PutLat  -----
  pure subroutine PutLat ( Qty, Surf, Inst, Lat )
    ! Store a geodetic latitude as if the GeodLat component were a rank-3 array
    ! with extents (surfs,insts,cross).  It's OK to use a surface index
    ! without checking whether the quantity is stacked -- it's checked here.
    use Constants, only: Rad2Deg
    use Geometry, only: GeocToGeodLat
    class(quantityTemplate_t), intent(inout) :: Qty
    integer, intent(in) :: Surf, Inst
    real(rt), intent(in) :: Lat ! degrees
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    if ( qty%latitudeCoordinate == l_geodetic ) then
      qty%geodlat(surfOr1, inst ) = lat
    else
      qty%geodlat(surfOr1, inst ) = geocToGeodLat ( lat ) * rad2deg
    end if
  end subroutine PutLat

  ! ----------------------------------------------------  PutLat3  -----
  pure subroutine PutLat3 ( Qty, Surf, Inst, CrossIndex, Lat )
    ! Store a geodetic latitude as if the GeodLat component were a rank-3 array
    ! with extents (surfs,insts,cross).  It's OK to use a surface index
    ! without checking whether the quantity is stacked -- it's checked here.
    use Constants, only: Rad2Deg
    use Geometry, only: GeocToGeodLat
    class(quantityTemplate_t), intent(inout) :: Qty
    integer, intent(in) :: Surf, Inst, CrossIndex
    real(rt), intent(in) :: Lat ! degrees
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    if ( qty%latitudeCoordinate == l_geodetic ) then
      qty%geodlat(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) ) = lat
    else
      qty%geodlat(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) ) = &
        & geocToGeodLat ( lat ) * rad2deg
    end if
  end subroutine PutLat3

  ! ----------------------------------------------------  PutLon3  -----
  pure subroutine PutLon3 ( Qty, Surf, Inst, CrossIndex, Lon )
    ! Store a Lonitude as if the Lon component were a rank-3 array
    ! with extents (surfs,insts,cross).  It's OK to use a surface index
    ! without checking whether the quantity is stacked -- it's checked here.
    class(quantityTemplate_t), intent(inout) :: Qty
    integer, intent(in) :: Surf, Inst, CrossIndex
    real(rt), intent(in) :: Lon
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    qty%lon(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) ) = lon
  end subroutine PutLon3

  ! ----------------------------------------------------  PutPhi3  -----
  pure subroutine PutPhi3 ( Qty, Surf, Inst, CrossIndex, Phi )
    ! Store a Phi angle as if the Phi component were a rank-3 array
    ! with extents (surfs,insts,cross).  It's OK to use a surface index
    ! without checking whether the quantity is stacked -- it's checked here.
    class(quantityTemplate_t), intent(inout) :: Qty
    integer, intent(in) :: Surf, Inst, CrossIndex
    real(rt), intent(in) :: Phi
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    qty%phi(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) ) = phi
  end subroutine PutPhi3

  ! ----------------------------------------------------  PutSurfs3  -----
  pure subroutine PutSurfs3 ( Qty, Surf, Inst, CrossIndex, SurfValue )
    ! Store a Surfs angle as if the Surfs component were a rank-3 array
    ! with extents (surfs,insts,cross).  It's OK to use a surface index
    ! without checking whether the quantity is stacked -- it's checked here.
    class(quantityTemplate_t), intent(inout) :: Qty
    integer, intent(in) :: Surf, Inst, CrossIndex
    real(rt), intent(in) :: SurfValue
    integer :: SurfOr1
    surfOr1 = merge(1,surf,qty%stacked)
    qty%surfs(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) ) = surfValue
  end subroutine PutSurfs3

!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: QuantityTemplates.f90,v 2.121 2018/04/19 02:00:36 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module QuantityTemplates
!=============================================================================

!
! $Log: QuantityTemplates.f90,v $
! Revision 2.121  2018/04/19 02:00:36  vsnyder
! Compute address for allocate/deallocate tracking.  Remove USE statements for
! unused names.
!
! Revision 2.120  2017/11/03 19:57:01  pwagner
! Most array gymnastics moved from MLSFillValues to HyperSlabs module
!
! Revision 2.119  2017/09/18 19:30:41  vsnyder
! Spiff the dump
!
! Revision 2.118  2017/01/25 17:19:26  pwagner
! Now require setting verboser for some Dumps
!
! Revision 2.117  2016/10/01 01:37:28  vsnyder
! Make QTM_Tree component of HGrid_t allocatable
!
! Revision 2.116  2016/08/30 20:27:24  vsnyder
! Add IsQTM type-bound function
!
! Revision 2.115  2016/08/23 00:42:43  vsnyder
! Components within or adjacent to the polygon are now within the QTM_Tree_t
! structure instead of the HGrid_t structure.
!
! Revision 2.114  2016/07/28 01:36:34  vsnyder
! Remove unreferenced USE and local variables
!
! Revision 2.113  2016/05/25 00:21:01  vsnyder
! Optionally allow different numbers of channels in QuantitiesAreCompatible.
! Check that HGrids are the same type in QuantitiesAreCompatible.
!
! Revision 2.112  2016/05/24 01:24:53  vsnyder
! Add checking for hGrid associated and of same type to QuantitiesAreCompatibie
!
! Revision 2.111  2016/05/19 23:28:07  pwagner
! Try harder not to crash on invalid strings; CopyQuantityTemplate takes optional arg dontDestroy
!
! Revision 2.110  2016/05/18 01:34:37  vsnyder
! HGridsDatabase.f90
!
! Revision 2.109  2016/05/12 15:22:46  pwagner
! Added GetHGridFromQuantity
!
! Revision 2.108  2016/05/04 18:34:16  pwagner
! Changed default unit to a valid phyq; some misunderstandings still remain however
!
! Revision 2.107  2015/09/25 02:12:25  vsnyder
! Add an optional verticalCoordinate argument to SetupNewQuantityTemplate.
! It has the VALUE attribute so qty%verticalCoordinate can be the actual
! argument without violating the standard, and without getting clobbered
! before it's needed.
!
! Revision 2.106  2015/09/23 22:39:09  vsnyder
! Add type-bound procedures to access and store latitude as either
! geocentric or geodetic latitude, except for the rank-2 GeodLat
! component.  Whether the latter is geocentric or geodetic still depends
! upon the value of the LatitudeCoordinate component, which users are
! expected to examine.
!
! Revision 2.105  2015/09/22 23:15:01  vsnyder
! Add 3D Phi and Surfs, spiff the dump
!
! Revision 2.104  2015/08/31 17:26:04  pwagner
! Fixed error in displaying qty%unit
!
! Revision 2.103  2015/08/26 01:08:17  vsnyder
! Yet more dump spiffing
!
! Revision 2.102  2015/08/25 18:36:03  vsnyder
! More dump spiffing
!
! Revision 2.101  2015/08/21 01:00:47  vsnyder
! Spiff a dump
!
! Revision 2.100  2015/07/31 20:42:22  pwagner
! Improved Dump
!
! Revision 2.99  2015/07/29 00:27:28  vsnyder
! Convert Phi from pointer to allocated
!
! Revision 2.98  2015/07/23 23:45:57  vsnyder
! qty%unit should be index in phyq_indices, not in lit_indices
!
! Revision 2.97  2015/06/04 03:13:16  vsnyder
! Make Surfs component of quantity template allocatable
!
! Revision 2.96  2015/06/03 23:09:00  pwagner
! Tried to prevent end-of-run crashes
!
! Revision 2.95  2015/06/02 23:53:00  vsnyder
! Add type-bound procedures to do rank-3 reference and update for latitude
! and longitude, instead of using rank-remapped pointers.
!
! Revision 2.94  2015/05/28 20:32:40  vsnyder
! Deallocate the correct component in DestroyGeolocationFields
!
! Revision 2.93  2015/05/27 22:41:46  vsnyder
! Move PointQuantityToHGrid here from HGridDatabase.  Eliminate shared
! HGrids.
!
! Revision 2.92  2015/05/01 02:09:28  vsnyder
! Spiff a dump
!
! Revision 2.91  2015/04/29 00:53:28  vsnyder
! Spiff the dump
!
! Revision 2.90  2015/04/07 02:51:50  vsnyder
! Remove CONTIGUOUS attribute from 2-D geolocation components.  Non-
! contiguous sections of them are targets in ConstructMajorFrameQuantity in
! ConstructQuantityTemplates.
!
! Revision 2.89  2015/03/28 01:40:45  vsnyder
! Added NoCrossTrack.  Added Unit (for values).  Added xGridIndex.  Added
! 1-d and 3-d geolocation quantities; made them contiguous.  Added
! LatitudeCoordinate (geocentric or geodetic).  Added CrossAngles.  Checked
! pointer components before copying them in CopyQuantityTemplate.  Added
! CreateGeolocationFields.  Fiddled with shared HGrids, but probably didn't
! improve anything.  Spiffed a dump, dump units, dump CrossAngles, dump
! LatitudeCorrdinate.  Adjusted QuantitiesAreCompatible to allow different
! types if requested.  Added NoCrossTrack to SetupNewQuantityTemplate.
! Added stuff to trace allocate/deallocate addresses -- some commented out
! because NAG build 1017 doesn't yet allow arrays as arguments to C_LOC.
!
! Revision 2.88  2014/10/29 23:04:29  vsnyder
! Specified units of several components
!
! Revision 2.87  2014/09/05 00:17:16  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.86  2014/08/19 00:28:33  vsnyder
! Make sure 'what' is always defined in DestroyQuantityTemplate
!
! Revision 2.85  2014/08/07 22:45:15  vsnyder
! Default HorizontalCoordinate to L_Phi_Tan instead of undefined
!
! Revision 2.84  2014/08/06 23:23:02  vsnyder
! Forgot to save from editor before commiting last time
!
! Revision 2.83  2014/08/06 23:22:28  vsnyder
! Combine several USE statements for the same module.  Remove declaration
! of unused parameter DEEBUG.
!
! Revision 2.82  2014/04/24 23:49:25  pwagner
! Added horizontalCoordinate component
!
! Revision 2.81  2014/03/20 01:39:47  vsnyder
! Unified types in Intrinsic
!
! Revision 2.80  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.79  2013/12/12 01:57:17  vsnyder
! Change type of debug from logical to integer
!
! Revision 2.78  2013/09/19 23:31:08  vsnyder
! Use MyDisplayString more, add QuantitiesAreCompatible
!
! Revision 2.77  2013/08/16 02:27:04  vsnyder
! Declare RT named constant = R8, and use it for REAL components
!
! Revision 2.76  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.75  2013/07/12 23:57:42  vsnyder
! Added Geolocation component
!
! Revision 2.74  2013/06/12 02:13:40  vsnyder
! Cruft removal
!
! Revision 2.73  2012/10/30 22:06:14  pwagner
! Fixed some obscure bugs when modifying templates
!
! Revision 2.72  2012/10/29 17:41:16  pwagner
! Attempted a more complete CopyQuantityTemplate
!
! Revision 2.71  2012/08/08 20:00:21  vsnyder
! Honest! I only changed some comments!
!
! Revision 2.70  2012/07/10 03:53:49  vsnyder
! Use DeepCopy
!
! Revision 2.69  2012/02/24 21:11:50  pwagner
! Include surfs when writing quantity attributes
!
! Revision 2.68  2012/02/23 00:08:35  vsnyder
! Don't dump molecule names if quantity type is not vmr
!
! Revision 2.67  2012/02/13 23:22:31  pwagner
! Print moleccule when dumping template
!
! Revision 2.66  2012/01/05 01:17:50  pwagner
! Added ReadAttributes; improved WriteAttributes
!
! Revision 2.65  2011/10/25 18:07:02  pwagner
! Added WriteAttributes to attach qty template attributes when writing datasets
!
! Revision 2.64  2011/05/09 17:26:03  pwagner
! Converted to using switchDetail
!
! Revision 2.63  2011/03/31 18:30:02  pwagner
! Corrected spelling in MODIFIABLEFIELDS
!
! Revision 2.62  2011/03/23 00:42:08  pwagner
! Tried to fix some of the more obvious bugs in ModifyQuantityTemplate_allocate
!
! Revision 2.61  2011/03/22 23:39:50  pwagner
! May now change both shape and values of qtytemplate field
!
! Revision 2.60  2011/03/15 22:43:52  pwagner
! Added ModifyQuantityTemplate; defaults to private
!
! Revision 2.59  2011/02/18 17:54:49  pwagner
! Prevented crashes when run w/o l2cf
!
! Revision 2.58  2010/09/25 01:16:35  vsnyder
! Add ChanInds component, some cannonball polishing
!
! Revision 2.57  2010/09/17 00:04:54  pwagner
! Workaround for obscure crashes when called from outside mlsl2
!
! Revision 2.56  2010/08/31 02:05:10  vsnyder
! Deallocate channels component in DestroyQuantityTemplateContents
!
! Revision 2.55  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.54  2009/09/25 02:42:07  vsnyder
! Added badValue to SetupNewQuantityTemplate, dump channels field of
! quantity if it's associated.
!
! Revision 2.53  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.52  2008/09/30 22:28:03  vsnyder
! Remove AuxGrids -- didn't need them after all
!
! Revision 2.51  2008/06/06 01:54:08  vsnyder
! Aux grids have to be vGrids, not indices in vGridsDatabase, else clients
! will have to have the database.
! Make sure to deallocate the auxGrids.  Dump auxGrids.
!
! Revision 2.50  2008/06/05 02:05:53  vsnyder
! Added Aux grids
!
! Revision 2.49  2007/09/12 00:16:12  vsnyder
! Default initialize name component of QuantityTemplate_T to zero
!
! Revision 2.48  2007/03/23 00:11:52  pwagner
! qtmp switch now warns while destroying quantitytemplates
!
! Revision 2.47  2006/08/04 20:54:09  pwagner
! get_string for quantity name only if positive
!
! Revision 2.46  2006/08/04 01:54:16  vsnyder
! Use >0 instead of ==0 to test the name string
!
! Revision 2.45  2006/08/03 01:10:06  vsnyder
! Put l2cf names in leak track database
!
! Revision 2.44  2006/03/22 23:49:20  vsnyder
! Change the name of a dummy argument, add some comments
!
! Revision 2.43  2006/03/22 02:15:18  vsnyder
! Spiff up a dump
!
! Revision 2.42  2006/01/05 03:47:28  vsnyder
! Add some stuff to the dump
!
! Revision 2.41  2005/08/04 02:57:27  vsnyder
! Cannonball polishing
!
! Revision 2.40  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.39  2004/08/26 18:54:49  pwagner
! qtmp switch now dumps in CreateQtyTemplateFromMLSCFInfo, not setup..
!
! Revision 2.38  2004/08/16 17:07:11  pwagner
! qtmp switch dumps quantity template after setup
!
! Revision 2.37  2004/05/01 04:07:44  vsnyder
! Rearranged some dumping stuff
!
! Revision 2.36  2004/04/15 20:51:51  pwagner
! Added DUMP_QUANTITY_TEMPLATES (found in l2/dumper)
!
! Revision 2.35  2004/01/24 01:02:43  livesey
! Added CopyQuantityTemplate
!
! Revision 2.34  2003/07/01 19:29:00  livesey
! Added grandTotalInstances
!
! Revision 2.33  2003/06/20 19:33:53  pwagner
! Quanities now share grids stored separately in databses
!
! Revision 2.32  2003/05/29 16:36:41  livesey
! Added the reflector item
!
! Revision 2.31  2003/01/14 21:35:53  vsnyder
! Add EPOCH and a comment about it in 'time' component
!
! Revision 2.30  2003/01/08 21:39:55  livesey
! Minor change in irregular quantity handling
!
! Revision 2.29  2002/11/27 01:06:26  livesey
! Better handling of major frame quantities
!
! Revision 2.28  2002/11/22 12:54:34  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.27  2002/10/08 00:09:13  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.26  2002/09/24 21:36:42  livesey
! Added minValue
!
! Revision 2.25  2002/08/28 20:42:11  livesey
! Added InflateQuantityTemplateDatabase
!
! Revision 2.24  2002/07/22 03:26:05  livesey
! Added checkIntegrity
!
! Revision 2.23  2002/07/01 23:51:07  vsnyder
! Plug a memory leak
!
! Revision 2.22  2001/10/12 23:09:25  pwagner
! More debugging statements
!
! Revision 2.21  2001/10/03 17:42:27  pwagner
! reset DEEBUG to FALSE
!
! Revision 2.20  2001/10/02 23:12:50  pwagner
! More chi^2 fixes
!
! Revision 2.19  2001/09/17 21:59:26  livesey
! Removed allocate of frequencies, it's deferred to later in the code
!
! Revision 2.18  2001/09/13 19:59:43  pwagner
! Added majorframe as possible quantity type
!
! Revision 2.17  2001/07/31 23:39:12  dwu
! allocate and deallocate qty%frequencies
!
! Revision 2.16  2001/07/11 21:41:16  livesey
! Made quantityTemplateCounter public
!
! Revision 2.15  2001/07/02 17:25:30  livesey
! Some changes to comments, following walk through
!
! Revision 2.14  2001/05/23 20:38:35  livesey
! Updated a comment
!
! Revision 2.13  2001/04/23 23:52:16  livesey
! Sorry, should have put comment in one below.  Now has optional ignoreMinorFrame
! argument to DestroyQuantityTemplateDatabase
!
! Revision 2.12  2001/04/23 23:50:41  livesey
! *** empty log message ***
!
! Revision 2.11  2001/04/12 21:43:06  livesey
! Added sideband field
!
! Revision 2.10  2001/04/10 22:37:49  vsnyder
! Fix a type
!
! Revision 2.9  2001/03/24 00:31:12  pwagner
! USEs output in case we replace MLSMessage with output in additem..
!
! Revision 2.8  2001/03/17 02:23:18  livesey
! Added log basis field
!
! Revision 2.7  2001/03/15 20:20:59  vsnyder
! Correct the description of 'InstrumentModule'
!
! Revision 2.6  2001/03/02 01:34:03  livesey
! New signals stuff
!
! Revision 2.5  2001/02/23 17:47:01  livesey
! Nullified pointers.
!
! Revision 2.4  2001/02/14 00:12:34  livesey
! Removed firstIndexChannel
!
! Revision 2.3  2001/02/09 00:38:56  livesey
! Various changes
!
! Revision 2.2  2000/12/04 23:43:59  vsnyder
! Move more of addItemToDatabase into the include
!
! Revision 2.1  2000/10/13 00:00:37  vsnyder
! Moved from mlspgs/l2 to mlspgs/lib
!
! Revision 2.0  2000/09/05 18:57:04  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.1  2000/09/02 02:05:04  vsnyder
! Initial entry
!
@


2.121
log
@Compute address for allocate/deallocate tracking.  Remove USE statements for
unused names.
@
text
@d1511 1
a1511 1
        & trim(what), ModuleName )
d2277 1
a2277 1
       "$Id: QuantityTemplates.f90,v 2.120 2017/11/03 19:57:01 pwagner Exp $"
d2289 4
@


2.120
log
@Most array gymnastics moved from MLSFillValues to HyperSlabs module
@
text
@a305 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a869 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d1509 1
d1511 1
a1511 1
        & trim(what) // "%surfs", ModuleName )
d2277 1
a2277 1
       "$Id: QuantityTemplates.f90,v 2.119 2017/09/18 19:30:41 vsnyder Exp $"
d2289 3
@


2.119
log
@Spiff the dump
@
text
@d20 1
a27 1
  use MLSFillValues, only: Rerank
d31 1
a31 1
  use MLSFinds, only: Findfirst
d502 1
a502 1
    use string_table, only: get_string
d2278 1
a2278 1
       "$Id: QuantityTemplates.f90,v 2.118 2017/01/25 17:19:26 pwagner Exp $"
d2290 3
@


2.118
log
@Now require setting verboser for some Dumps
@
text
@d668 1
a668 1
    call Blanks( 6 )
d682 2
d686 1
a686 2
    call output ( ' InstanceLen = ' )
    call output ( qty%InstanceLen, advance='yes' )
d721 2
a722 1
      call output ( '     ' )
d733 2
a734 1
      call newLine
d736 3
a738 3
    
    if ( .not. associated (qty%the_HGrid) ) then
      call output ( 'qty%the_HGrid not associated', advance='yes' )
d740 2
a741 2
      call Dump( qty%the_HGrid )
    endif
d758 1
a758 1
            & '      Phi = ' )
d762 1
a762 1
            & '      Phi = ' )
d769 1
a769 1
        call dump ( qty%surfs, '      Surfs = ' )
d779 1
a779 1
            & '      GeodLat = ' )
d785 2
a786 2
            & [ size(qty%geodLat,1),qty%noInstances,qty%noCrossTrack] ), &
            & '      Lon = ' )
d800 1
a800 1
        call dump ( qty%frequencies, ' Frequencies = ' )
d835 1
a835 1
        call dump ( array, '      ' // trim(name) // ' = ' )
d2278 1
a2278 1
       "$Id: QuantityTemplates.f90,v 2.117 2016/10/01 01:37:28 vsnyder Exp $"
d2290 3
@


2.117
log
@Make QTM_Tree component of HGrid_t allocatable
@
text
@d19 1
a19 1
  use Allocate_deallocate, only: allocate_test, deallocate_test
d21 8
a28 8
  use Expr_m, only: Expr_check
  use HGridsDatabase, only: HGrid_t, Dump
  use HighOutput, only: outputNamedValue
  use Intrinsic, only: L_geodetic, L_geodAltitude, L_none, L_phitan, &
    & L_VMR, L_QTM, lit_indices, Phyq_angle, Phyq_dimensionless, &
    & Phyq_frequency, Phyq_indices, Phyq_time, Phyq_vmr
  use MLSFillValues, only: rerank
  use MLSKinds, only: rt => r8 ! rt is "kind of real components of template"
d30 8
a37 7
  use MLSFinds, only: findfirst
  use MLSStringLists, only: switchDetail
  use MLSStrings, only: lowercase, writeIntsToChars
  use Output_m, only: output
  use String_table, only: isStringInTable
  use Toggles, only: switches
  use Tree, only: nsons, subtree
d418 1
d420 1
d424 1
d590 1
a590 1
    use output_m, only: blanks
d627 3
a629 3
    use MLSSignals_m, only: signals, dump, getRadiometerName, getModuleName
    use Output_m, only: blanks, newLine
    use vGridsDatabase, only: dump
d1331 3
a1333 3
    use MLSHDF5, only: getHDF5Attribute
    use MLSSignals_m, only: getRadiometerIndex, getModuleIndex, &
      & getSignalIndex
d1406 2
a1407 1

d1416 2
a1417 1

d1538 2
d1541 1
a1541 1
    ! if ( switchDetail(switches, 'qtmp') > -1 ) call dump(qty, details=0, noL2CF=.true.)
d1548 3
a1550 3
    use MLSHDF5, only: makeHDF5Attribute
    use MLSSignals_m, only: getRadiometerName, getModuleName, &
      & getSignalName
d1851 3
a1853 3
    use intrinsic, only: first_lit, last_auto_lit
    use MLSHDF5, only: getHDF5Attribute
    use string_table, only: add_char, lookup
d1877 3
a1879 3
    use MLSHDF5, only: getHDF5Attribute
    use string_table, only: add_char, lookup
    use tree_types, only: add_char
d1990 1
a1990 1
    use String_Table, only: display_string, how_many_strings
d2010 1
a2010 1
    use string_table, only: get_string, how_many_strings
d2275 1
a2275 1
       "$Id: QuantityTemplates.f90,v 2.116 2016/08/30 20:27:24 vsnyder Exp $"
d2287 3
@


2.116
log
@Add IsQTM type-bound function
@
text
@d882 1
d2267 1
a2267 1
       "$Id: QuantityTemplates.f90,v 2.115 2016/08/23 00:42:43 vsnyder Exp $"
d2279 3
@


2.115
log
@Components within or adjacent to the polygon are now within the QTM_Tree_t
structure instead of the HGrid_t structure.
@
text
@d25 2
a26 2
    & L_vmr, lit_indices, Phyq_angle, Phyq_dimensionless, Phyq_frequency, &
    & Phyq_indices, Phyq_time, Phyq_vmr
d159 5
d238 1
d620 2
a621 2
  ! -------------------------------------  DUMP_QUANTITY_TEMPLATE  -----
  subroutine DUMP_QUANTITY_TEMPLATE ( Qty, DETAILS, NOL2CF, What )
d628 1
a628 1
    integer, intent(in), optional :: DETAILS ! <= 0 => Don't dump arrays
d633 1
a633 1
    logical, intent(in), optional :: NOL2CF  ! if TRUE => Don't dump L2-specific
d834 1
a834 1
  end subroutine DUMP_QUANTITY_TEMPLATE
d836 2
a837 2
  ! ------------------------------------  DUMP_QUANTITY_TEMPLATES  -----
  subroutine DUMP_QUANTITY_TEMPLATES ( QUANTITY_TEMPLATES, DETAILS, NOL2CF, What )
d839 2
a840 2
    type(QuantityTemplate_T), intent(in) :: QUANTITY_TEMPLATES(:)
    integer, intent(in), optional :: DETAILS ! <= 0 => Don't dump arrays
d843 1
a843 1
    logical, intent(in), optional :: NOL2CF  ! if TRUE => Don't dump l2-specific
d848 2
a849 2
    call output ( 'QUANTITY_TEMPLATES: SIZE = ' )
    call output ( size(quantity_templates), advance='yes' )
d856 1
a856 1
  end subroutine DUMP_QUANTITY_TEMPLATES
d877 7
d2266 1
a2266 1
       "$Id: QuantityTemplates.f90,v 2.114 2016/07/28 01:36:34 vsnyder Exp $"
d2278 4
@


2.114
log
@Remove unreferenced USE and local variables
@
text
@d1271 2
a1272 2
        QuantitiesAreCompatible = allocated(qty_1%the_hGrid%QTM_ZOT) .and. &
                                & allocated(qty_2%the_hGrid%QTM_ZOT)
d1274 2
a1275 2
          & QuantitiesAreCompatible = size(qty_1%the_hGrid%QTM_ZOT) == &
                                    & size(qty_2%the_hGrid%QTM_ZOT)
d1277 2
a1278 2
        QuantitiesAreCompatible = .not. allocated(qty_1%the_hGrid%QTM_ZOT) .and. &
                                & .not. allocated(qty_2%the_hGrid%QTM_ZOT)
d2253 1
a2253 1
       "$Id: QuantityTemplates.f90,v 2.113 2016/05/25 00:21:01 vsnyder Exp $"
d2265 3
@


2.113
log
@Optionally allow different numbers of channels in QuantitiesAreCompatible.
Check that HGrids are the same type in QuantitiesAreCompatible.
@
text
@d19 8
a26 8
  use allocate_deallocate, only: allocate_test, deallocate_test
  use dump_0, only: dump
  use expr_m, only: expr_check
  use hGridsDatabase, only: HGrid_t, Dump
  use highOutput, only: outputNamedValue
  use intrinsic, only: l_dl, l_geodetic, l_geodAltitude, l_none, l_phitan, &
    & l_vmr, lit_indices, phyq_angle, phyq_dimensionless, phyq_frequency, &
    & phyq_indices, phyq_time, phyq_vmr
d33 4
a36 4
  use output_m, only: output
  use string_table, only: isStringInTable
  use toggles, only: switches
  use tree, only: nsons, subtree
d38 1
a38 1
  implicit none
d41 1
a41 1
  public :: EPOCH, QuantityTemplate_T, RT
d59 1
a59 1
  real(rt), parameter :: EPOCH = 1993.0 ! Starting point for time references
d65 1
a65 1
    integer :: name = 0        ! Sub-rosa index of quantity name
d84 3
a86 3
    logical :: coherent        ! Do instances have same vertical coordinates?
    logical :: stacked         ! Are instances true vertical profiles?
    logical :: regular         ! Are all channels/heights represented
d93 2
a94 2
    logical :: minorFrame      ! Is this a minor frame quantity.
    logical :: majorFrame      ! Is this a major frame quantity.
d97 2
a98 2
    logical :: logBasis                 ! If set use log
    real(rt) :: minValue                ! Minimum value to consider if using log
d103 2
a104 2
    integer :: noInstancesLowerOverlap
    integer :: noInstancesUpperOverlap
d107 2
a108 2
    real(rt) :: badValue       ! Value used to flag bad/missing data
    integer :: unit = PHYQ_VMR ! Unit quantity is in when scaled as below,
d117 1
a117 1
    integer :: instanceLen
d120 1
a120 1
    integer :: verticalCoordinate=l_geodAltitude ! The vertical coordinate
d123 2
a124 2
    logical :: sharedVGrid        ! Set if surfs is a pointer not a copy
    integer :: vGridIndex         ! Index of any vGrid used
d139 1
a139 1
    integer :: horizontalCoordinate = l_phiTan ! The horizontal coordinate used.
d141 1
a141 1
    integer :: grandTotalInstances      ! Total number of instances in destination output file
d145 2
a146 2
    integer :: instanceOffset           ! Ind of 1st non overlapped instance in output
    integer :: xGridIndex = 0           ! Index of any xGrid used
d205 5
a209 5
    integer :: frequencyCoordinate      ! An enumerated type, e.g. FG_USBFreq
    real(rt) :: lo                      ! Local oscillator frequency, MHz
    logical :: sharedFGrid              ! Set of frequencies are a pointer not a copy
    integer :: sideband                 ! Associated sideband -1, 0, +1
    integer :: signal                   ! Index into signals database
d215 4
a218 4
    integer :: instrumentModule ! Index in the Modules database in MLSSignals_m
    integer :: radiometer       ! For ptan etc., index into radiometers database
    integer :: reflector        ! For reflector efficiency etc. terms
    integer :: molecule ! What molecule does this refer to? (One of the l_...
d226 2
a227 2
    integer, dimension(:,:), pointer :: surfIndex => NULL()
    integer, dimension(:,:), pointer :: chanIndex => NULL()
d245 1
a245 1
  interface DUMP
d249 1
a249 1
  interface MODIFYQUANTITYTEMPLATE
a1144 2
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MoreMessage, only: MLSMessage
a1151 1
    integer :: I, J, K
d1171 1
a1173 1

d2253 1
a2253 1
       "$Id: QuantityTemplates.f90,v 2.112 2016/05/24 01:24:53 vsnyder Exp $"
d2265 4
@


2.112
log
@Add checking for hGrid associated and of same type to QuantitiesAreCompatibie
@
text
@d1255 2
a1256 1
  logical function QuantitiesAreCompatible ( Qty_1, Qty_2, DifferentTypeOK )
d1259 2
a1260 1
    logical, intent(in), optional :: DifferentTypeOK ! present implies true
d1271 2
a1272 1
      QuantitiesAreCompatible = qty_1%the_hGrid%type == qty_1%the_hGrid%type
d1279 3
d1285 5
a1293 1
      & qty_1%noChans == qty_2%noChans .and. &
d2256 1
a2256 1
       "$Id: QuantityTemplates.f90,v 2.111 2016/05/19 23:28:07 pwagner Exp $"
d2268 3
@


2.111
log
@Try harder not to crash on invalid strings; CopyQuantityTemplate takes optional arg dontDestroy
@
text
@d1256 1
d1258 3
a1260 3
    logical, intent(in), optional :: DifferentTypeOK
    logical :: TypeCheck
    typeCheck = qty_1%quantityType == qty_2%quantityType
d1262 15
a1276 1
      if ( differentTypeOK ) typeCheck = .true.
d1278 2
a1280 1
      & typeCheck .and. &
d1295 1
d2246 1
a2246 1
       "$Id: QuantityTemplates.f90,v 2.109 2016/05/12 15:22:46 pwagner Exp $"
d2258 3
@


2.110
log
@HGridsDatabase.f90
@
text
@d34 1
d314 1
a314 1
  subroutine CopyQuantityTemplate ( Z, A )
d321 4
a324 2
    type (QuantityTemplate_T), intent(in) :: A

d326 2
d329 5
a333 1
    call DestroyQuantityTemplateContents ( z )
d379 2
d503 1
a503 1
    if ( qty%quantityType < 1 ) return
d640 2
a641 1
    call myDisplayString ( qty%name )
d644 2
a645 1
      call myDisplayString ( lit_indices(qty%quantityType) )
d670 1
a670 1
    if ( .not. myNoL2CF .and. qty%unit > 0 ) then
d676 2
a677 1
    if ( .not. myNoL2CF .and. qty%horizontalCoordinate > 0 ) &
d680 2
a681 1
    call myDisplayString ( lit_indices(qty%latitudeCoordinate), &
d691 2
a692 1
    if ( .not. myNoL2CF .and. qty%verticalCoordinate > 0 ) &
d701 2
a702 1
    call myDisplayString ( lit_indices(qty%frequencyCoordinate), &
d713 2
a714 1
        call myDisplayString ( lit_indices(qty%molecule) )
d727 1
a727 1
      call Dump( qty%the_HGrid, myDetails )
d784 2
a785 1
        call myDisplayString ( lit_indices(qty%frequencyCoordinate), &
d790 2
a791 1
      if ( associated(qty%frequencies)  .and. .not. myNoL2CF ) &
d793 1
a793 1
          & before='      FrequencyCoordinate = ', advance='yes' )
d2241 3
@


2.109
log
@Added GetHGridFromQuantity
@
text
@d135 1
a135 1
    real(rt), allocatable :: Surfs(:,:)
d2209 1
a2209 1
       "$Id: QuantityTemplates.f90,v 2.108 2016/05/04 18:34:16 pwagner Exp $"
d2221 3
@


2.108
log
@Changed default unit to a valid phyq; some misunderstandings still remain however
@
text
@d22 1
a22 1
  use hGridsDatabase, only: hgrid_t
d45 2
a46 1
    & DestroyQuantityTemplateDatabase, Dump, ModifyQuantityTemplate, &
d705 6
d1118 39
d1222 4
a1225 4
    qty%time => hGrid%time
    qty%solarTime => hGrid%solarTime
    qty%solarZenith => hGrid%solarZenith
    qty%losAngle => hGrid%losAngle
d2209 1
a2209 1
       "$Id: QuantityTemplates.f90,v 2.107 2015/09/25 02:12:25 vsnyder Exp $"
d2221 3
@


2.107
log
@Add an optional verticalCoordinate argument to SetupNewQuantityTemplate.
It has the VALUE attribute so qty%verticalCoordinate can be the actual
argument without violating the standard, and without getting clobbered
before it's needed.
@
text
@d26 1
a26 1
    & phyq_indices, phyq_time
d105 6
a110 6
    real(rt) :: badValue      ! Value used to flag bad/missing data
    integer :: unit = l_dl    ! Unit quantity is in when scaled as below,
                              ! an l_lit of the type t_units.  Units are
                              ! defined in units.f90, but their names are
                              ! declared in intrinsic.f90, and their membership
                              ! in the type t_units is defined in init_tables_module.
d2163 1
a2163 1
       "$Id: QuantityTemplates.f90,v 2.106 2015/09/23 22:39:09 vsnyder Exp $"
d2175 6
@


2.106
log
@Add type-bound procedures to access and store latitude as either
geocentric or geodetic latitude, except for the rank-2 GeodLat
component.  Whether the latter is geocentric or geodetic still depends
upon the value of the LatitudeCoordinate component, which users are
expected to examine.
@
text
@d24 3
a26 2
  use intrinsic, only: l_dl, l_geodetic, l_none, l_phitan, l_vmr, lit_indices, &
    & phyq_angle, phyq_dimensionless, phyq_frequency, phyq_indices, phyq_time
d118 3
a120 3
    integer :: verticalCoordinate ! The vertical coordinate used.  These
                                  ! are l_lits of the type t_VGridCoord
                                  ! defined in Init_Tables_Module.
d1267 1
a1267 1
    & sharedVGrid, sharedFGrid, badValue )
d1292 2
d1344 11
a1354 10
    if ( present (noChans) )      qty%noChans = noChans
    if ( present (noInstances) )  qty%noInstances = noInstances
    if ( present (noSurfs) )      qty%noSurfs = noSurfs
    if ( present (noCrossTrack) ) qty%noCrossTrack = noCrossTrack
    if ( present (regular) )      qty%regular = regular
    if ( present (minorFrame) )   qty%minorFrame = minorFrame
    if ( present (majorFrame) )   qty%majorFrame = majorFrame
    if ( present (sharedVGrid) )  qty%sharedVGrid = sharedVGrid
    if ( present (sharedFGrid) )  qty%sharedFGrid = sharedFGrid
    if ( present (badValue) )     qty%badValue = badValue
d2163 1
a2163 1
       "$Id: QuantityTemplates.f90,v 2.105 2015/09/22 23:15:01 vsnyder Exp $"
d2175 7
@


2.105
log
@Add 3D Phi and Surfs, spiff the dump
@
text
@d227 2
d232 3
d1778 39
d1819 1
d1822 2
a1823 1
    ! checking whether the quantity is stacked -- it's done here.
d1828 5
a1832 1
    getLat3 = qty%geodlat(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) )
d1839 1
a1839 1
    ! checking whether the quantity is stacked -- it's done here.
d1851 1
a1851 1
    ! checking whether the quantity is stacked -- it's done here.
d1863 1
a1863 1
    ! checking whether the quantity is stacked -- it's done here.
d2040 56
d2098 1
a2098 1
    ! Store a latitude as if the GeodLat component were a rank-3 array
d2100 3
a2102 1
    ! without checking whether the quantity is stacked -- that's done here.
d2105 1
a2105 1
    real(rt), intent(in) :: Lat
d2108 6
a2113 1
    qty%geodlat(surfOr1, inst + qty%noInstances * ( crossIndex - 1 ) ) = lat
d2120 1
a2120 1
    ! without checking whether the quantity is stacked -- that's done here.
d2133 1
a2133 1
    ! without checking whether the quantity is stacked -- that's done here.
d2146 1
a2146 1
    ! without checking whether the quantity is stacked -- that's done here.
d2159 1
a2159 1
       "$Id: QuantityTemplates.f90,v 2.104 2015/08/31 17:26:04 pwagner Exp $"
d2171 3
@


2.104
log
@Fixed error in displaying qty%unit
@
text
@d123 3
a125 3
    ! Surfs is dimensioned (noSurfs,1) for coherent quantities and
    ! (noSurfs, noInstances) for incoherent ones.  Pretending the values are
    ! dimensioned (noChans, noSurfs, noInstances), or
d132 1
d158 5
a162 4
    ! Phi is dimensioned (1, noInstances) for stacked quantities and
    ! (noSurfs, noInstances) for unstacked ones.  The PHI coordinate for the
    ! (i,j) value is phi(1,j) for a stacked quantity and phi(i,j) for an
    ! unstacked one.  Phi is either taken from or derived from Geolocation.
d229 1
d232 3
d384 1
a384 1
  subroutine CreateGeolocationFields ( Qty, NoSurfsToAllocate, What )
d390 1
d395 3
d433 12
d474 1
a474 1
    use string_table, only: get_string, how_many_strings
d562 1
a562 1
    use output_m, only: blanks, newLine
d580 4
a583 4
          call blanks ( 9, FillChar = '-', advance='no' )
          call output ( ' Quantity index ', advance='no' )
          call output ( qtyIndex, advance='no' )
          call blanks ( 1, advance='no' )
d600 1
a600 1
    use output_m, only: blanks, newLine
d651 1
a651 2
      call myDisplayString ( lit_indices(qty%unit), &
        & before='      Unit = ' )
d664 1
a664 2
    call output ( '      sharedVGrid = ' )
    call output ( qty%sharedVGrid, advance='no' )
d673 1
a673 2
    call output ( '      sharedFGrid = ' )
    call output ( qty%sharedFGrid, advance='no' )
d711 9
a719 3
        call dump ( reshape ( qty%phi, &
          & [ size(qty%geodLat,1),qty%noInstances] ), &
          & '      Phi = ' )
d1135 2
d1138 11
a1148 1
      qty%phi = hGrid%phi
d1151 1
a1151 1
        do j = 1, size(qty%geodLat,2)
a1159 2
      call allocate_test ( qty%phi, qty%noSurfs, qty%noInstances, 'qty%phi', &
        & ModuleName )
d1797 24
d2016 26
d2046 1
a2046 1
       "$Id: QuantityTemplates.f90,v 2.103 2015/08/26 01:08:17 vsnyder Exp $"
d2058 3
@


2.103
log
@Yet more dump spiffing
@
text
@d629 1
a629 1
      call myDisplayString ( phyq_indices(qty%unit), &
d1961 1
a1961 1
       "$Id: QuantityTemplates.f90,v 2.102 2015/08/25 18:36:03 vsnyder Exp $"
d1973 3
@


2.102
log
@More dump spiffing
@
text
@d616 8
a623 17
    call Blanks( 5 )
    if ( .not. qty%coherent ) call output ( 'in' )
    call output ( 'coherent ' )
    if ( .not. qty%stacked ) call output ( 'non' )
    call output ( 'stacked ' )
    if ( .not. qty%regular ) call output ( 'ir' )
    call output ( 'regular ' )
    if ( qty%logBasis ) then
      call output ('log-')
    else
      call output ('linear-')
    end if
    call output ('basis ' )
    call output ( trim(merge('   ','non',qty%minorFrame)) // &
      & 'minorFrame' )
    call output ( ' ' // trim(merge('   ','non',qty%majorFrame)) // &
      & 'majorFrame', advance='yes' )
d1961 1
a1961 1
       "$Id: QuantityTemplates.f90,v 2.101 2015/08/21 01:00:47 vsnyder Exp $"
d1973 3
@


2.101
log
@Spiff a dump
@
text
@d709 1
a709 1
        call dump ( qty%surfs, '      Surfs' )
d1970 1
a1970 1
       "$Id: QuantityTemplates.f90,v 2.100 2015/07/31 20:42:22 pwagner Exp $"
d1982 3
@


2.100
log
@Improved Dump
@
text
@d709 1
a709 1
        call dump ( qty%surfs, 'Surfs' )
d1970 1
a1970 1
       "$Id: QuantityTemplates.f90,v 2.99 2015/07/29 00:27:28 vsnyder Exp $"
d1982 3
@


2.99
log
@Convert Phi from pointer to allocated
@
text
@d19 16
a34 16
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only: DUMP
  use EXPR_M, only: EXPR_CHECK
  use HGridsDatabase, only: HGrid_T
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use INTRINSIC, only: L_DL, L_Geodetic, L_None, L_PhiTan, L_VMR, LIT_INDICES, &
    & PHYQ_Angle, PHYQ_Dimensionless, PHYQ_Frequency, PHYQ_Indices, PHYQ_Time
  use MLSFILLVALUES, only: RERANK
  use MLSKINDS, only: RT => R8 ! RT is "kind of Real components of template"
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
  use MLSFINDS, only: FINDFIRST
  use MLSSTRINGLISTS, only: SWITCHDETAIL
  use MLSSTRINGS, only: LOWERCASE, WRITEINTSTOCHARS
  use OUTPUT_M, only: OUTPUT
  use TOGGLES, only: SWITCHES
  use TREE, only: NSONS, SUBTREE
d577 1
a577 1
    use MLSSIGNALS_M, only: SIGNALS, DUMP, GETRADIOMETERNAME, GETMODULENAME
d579 1
a579 1
    use VGRIDSDATABASE, only: DUMP
d609 8
a616 5
    call output ( qty%noChans,      before='      NoChans = ' )
    call output ( qty%noSurfs,      before=' NoSurfs = ' )
    call output ( qty%noInstances,  before=' NoInstances = ' )
    call output ( qty%noCrossTrack, before=' NoCrossTrack = ', advance='yes' )
    call output ( '      ' )
d1191 3
a1193 3
    use MLSHDF5, only: GETHDF5ATTRIBUTE
    use MLSSIGNALS_M, only: GETRADIOMETERINDEX, GETMODULEINDEX, &
      & GETSIGNALINDEX
d1401 3
a1403 3
    use MLSHDF5, only: MAKEHDF5ATTRIBUTE
    use MLSSIGNALS_M, only: GETRADIOMETERNAME, GETMODULENAME, &
      & GETSIGNALNAME
d1704 3
a1706 3
    use INTRINSIC, only: FIRST_LIT, LAST_AUTO_LIT
    use MLSHDF5, only: GETHDF5ATTRIBUTE
    use STRING_TABLE, only: ADD_CHAR, LOOKUP
d1730 3
a1732 3
    use MLSHDF5, only: GETHDF5ATTRIBUTE
    use STRING_TABLE, only: ADD_CHAR, LOOKUP
    use TREE_TYPES, only: ADD_CHAR
d1774 1
a1774 1
    use String_Table, only: DISPLAY_STRING, HOW_MANY_STRINGS
d1794 1
a1794 1
    use STRING_TABLE, only: GET_STRING, HOW_MANY_STRINGS
d1970 1
a1970 1
       "$Id: QuantityTemplates.f90,v 2.98 2015/07/23 23:45:57 vsnyder Exp $"
d1982 3
@


2.98
log
@qty%unit should be index in phyq_indices, not in lit_indices
@
text
@d155 1
a155 1
    real(rt), dimension(:,:), pointer :: Phi => NULL() ! Degrees
d359 2
a360 2
    if ( allocated(z%surfs)        .and. allocated(a%surfs) )       z%surfs =       a%surfs
    if ( associated(z%phi)         .and. associated(a%phi) )         z%phi =         a%phi
d697 8
a704 1
      call maybe_dump_2_rt ( qty%phi, 'Phi' )
d1117 1
a1117 1
      qty%phi => hGrid%phi
d1129 2
a1130 3
      nullify ( qty%phi )
!       This results in a "double free or corruption" termination:
!       call allocate_test ( qty%phi, 0, 0, 'qty%phi(1,1)', ModuleName )
d1134 1
a1134 1
        & "; assume Lat, Lon computed somehow; hope nobody needs Phi", qty%name)
d1137 2
a1138 1
          & "Cannot copy hGrids into unstacked quantities; assume Lat, Lon computed somehow; hope nobody needs Phi")
d1560 1
a1560 1
    if ( .not. associated ( qty%phi ) ) then
d1562 1
a1562 1
        & 'The quantity template '//trim(name)// ' does not have phi associated' )
d1967 1
a1967 1
       "$Id: QuantityTemplates.f90,v 2.97 2015/06/04 03:13:16 vsnyder Exp $"
d1979 3
@


2.97
log
@Make Surfs component of quantity template allocatable
@
text
@d25 1
a25 1
    & PHYQ_Angle, PHYQ_Dimensionless, PHYQ_Frequency, PHYQ_Time
d635 1
a635 1
      call myDisplayString ( lit_indices(qty%unit), &
d1179 1
a1179 1
    use Declaration_Table, only: Decls, Get_Decl, Units_Name
d1204 2
a1205 2
    decl = get_decl ( str, units_name )
    if ( decl%type == units_name ) then
d1960 1
a1960 1
       "$Id: QuantityTemplates.f90,v 2.96 2015/06/03 23:09:00 pwagner Exp $"
d1972 3
@


2.96
log
@Tried to prevent end-of-run crashes
@
text
@a121 1
    real(rt), dimension(:,:), pointer :: surfs => NULL()
d123 1
a123 1
    ! This is dimensioned (noSurfs,1) for coherent quantities and
d125 3
a127 2
    ! dimensioned (noChans, noSurfs, noInstances), the SURFS coordinate
    ! for the (:,i,j) values is surfs(i,1) for a coherent quantity or
d129 4
d162 8
a169 4
    ! These other coordinates are dimensioned in the same manner as Phi:
    real(rt), pointer, contiguous :: GeodLat(:,:) => NULL()  ! Degrees
    real(rt), pointer, contiguous :: Lon(:,:) => NULL()      ! Degrees
    real(rt), pointer :: Time(:,:) => NULL()        ! Seconds since EPOCH
d171 2
a172 2
    real(rt), pointer :: SolarZenith(:,:) => NULL() ! Degrees
    real(rt), pointer :: LosAngle(:,:) => NULL()    ! Degrees
d359 1
a359 1
    if ( associated(z%surfs)       .and. associated(a%surfs) )       z%surfs =       a%surfs
d361 2
a362 2
    if ( associated(z%geodLat)     .and. associated(a%geodLat) )     z%geodLat =     a%geodLat
    if ( associated(z%lon)         .and. associated(a%lon) )         z%lon =         a%lon
d387 1
d423 13
d438 3
a440 3
    ! Deallocate the latitude and longitude fields if the hGrid is
    ! not shared, or if it is shared and there are cross angles,
    ! else nullify them.
d698 5
a702 1
      call maybe_dump_2_rt ( qty%surfs, 'Surfs' )
d706 1
a706 1
        if ( associated(qty%geodlat) ) then
d713 1
a713 1
        if ( associated(qty%lon) ) then
d1352 1
a1352 3
    if ( qty%sharedVGrid ) then
      nullify ( qty%surfs )
    else
d1450 1
a1450 1
    if ( associated(qt%surfs) ) &
d1547 1
a1547 1
    if ( .not. associated ( qty%surfs ) ) then
d1559 1
a1559 1
    if ( .not. associated ( qty%geodLat ) ) then
d1564 1
a1564 1
    if ( .not. associated ( qty%lon ) ) then
d1960 1
a1960 1
       "$Id: QuantityTemplates.f90,v 2.95 2015/06/02 23:53:00 vsnyder Exp $"
d1972 3
@


2.95
log
@Add type-bound procedures to do rank-3 reference and update for latitude
and longitude, instead of using rank-remapped pointers.
@
text
@d420 1
d422 1
a422 1

d430 1
d433 2
a434 1

d439 11
a449 1
    verbose = ( switchDetail(switches, 'qtmp' ) > -1 )
d461 5
d518 1
d531 1
a531 1
    verbose = ( switchDetail(switches, 'qtmp' ) > -1 )
d535 7
d556 1
a556 1
    use OUTPUT_M, only: NEWLINE
d568 1
d570 1
a571 1
    logical :: myNoL2CF
d1936 1
a1936 1
       "$Id: QuantityTemplates.f90,v 2.94 2015/05/28 20:32:40 vsnyder Exp $"
d1948 4
@


2.94
log
@Deallocate the correct component in DestroyGeolocationFields
@
text
@d159 2
a160 2
    real(rt), pointer :: GeodLat(:,:) => NULL()     ! Degrees
    real(rt), pointer :: Lon(:,:) => NULL()         ! Degrees
a165 15
    ! GeodLat1 and Lon1 are the ones that are allocated.  The extents are the
    ! number of surfaces (for unstacked quantities) or 1 (for stacked
    ! quantities), times the number of instances, times the size of xGrid.
    ! GeodLat, Lon, GeodLat3, and Lon3 are then rank remapped pointers
    ! associated with GeodLat1 and Lon1.  The third extent of GeodLat3 and
    ! Lon3 is 1, or the size of xGrid if there is one.  If there is an xGrid,
    ! the second extent of GeodLat and Lon is the number of instances times
    ! the size of xGrid, with subscript values in the second dimension
    ! corresponding to positions in the xGrid separated by the number of
    ! instances (using GeodLat3 and Lon3 would be much simpler).
    real(rt), contiguous, pointer :: GeodLat1(:) => NULL()      ! Degrees
    real(rt), contiguous, pointer :: Lon1(:) => NULL()          ! Degrees
    real(rt), contiguous, pointer :: GeodLat3(:,:,:) => NULL()  ! Degrees
    real(rt), contiguous, pointer :: Lon3(:,:,:) => NULL()      ! Degrees

d216 5
d371 1
a371 3
    ! Allocate Qty%GeodLat1 and Qty%Lon1.  Create rank-remapped pointers to
    ! Qty%GeodLat, Qty%Lon, Qty%GeodLat3, and Qty%Lon3.
    use Pointer_Rank_Remapping, only: REMAP
d384 1
a384 3
    ! Allocate Qty%GeodLat1.  Create rank-remapped pointers to
    ! Qty%GeodLat, and Qty%GeodLat3.
    use Pointer_Rank_Remapping, only: REMAP
d392 2
a393 2
    numAlloc = noSurfsToAllocate * qty%noInstances * qty%noCrossTrack
    call allocate_test ( qty%geodLat1, numAlloc, trim(what) // "%geodLat1", &
d395 1
a395 4
    call remap ( qty%geodLat1, qty%geodLat, &
      & [ noSurfsToAllocate, qty%noInstances * qty%noCrossTrack ] )
    call remap ( qty%geodLat1, qty%geodLat3, &
      & [ noSurfsToAllocate, qty%noInstances, qty%noCrossTrack ] )
d400 1
a400 3
    ! Allocate Qty%Lon1.  Create rank-remapped pointers to
    ! Qty%Lon, and Qty%Lon3.
    use Pointer_Rank_Remapping, only: REMAP
d408 2
a409 2
    numAlloc = noSurfsToAllocate * qty%noInstances * qty%noCrossTrack
    call allocate_test ( qty%lon1, numAlloc, trim(what) // "%lon1", &
d411 1
a411 4
    call remap ( qty%lon1, qty%lon, &
      & [ noSurfsToAllocate, qty%noInstances * qty%noCrossTrack ] )
    call remap ( qty%lon1, qty%lon3, &
      & [ noSurfsToAllocate, qty%noInstances, qty%noCrossTrack ] )
d422 2
a423 3
    call deallocate_test ( qty%geodLat1, 'Qty%GeodLat1', moduleName )
    call deallocate_test ( qty%lon1, 'Qty%Lon', moduleName )
    nullify ( qty%geodLat, qty%geodLat3, qty%lon, qty%lon3 )
d462 1
a462 1
    call deallocate_test ( qty%geodLat1, trim(what) // '%geodLat1', ModuleName )
d464 1
a464 1
    call deallocate_test ( qty%lon1, trim(what) // '%lon1', ModuleName )
a475 3
    ! Nullify the remapped ones.
    nullify ( qty%geodLat, qty%geodLat3, qty%lon, qty%lon3 )

d527 1
a527 1
  subroutine DUMP_QUANTITY_TEMPLATE ( QUANTITY_TEMPLATE, DETAILS, NOL2CF, What )
d533 1
a533 1
    type(QuantityTemplate_T), intent(in) :: QUANTITY_TEMPLATE
d551 2
a552 2
    call myDisplayString ( quantity_template%name )
    if ( .not. myNoL2CF .and. quantity_template%quantityType > 0 ) then
d554 1
a554 1
      call myDisplayString ( lit_indices(quantity_template%quantityType) )
d560 4
a563 4
    call output ( quantity_template%noChans,      before='      NoChans = ' )
    call output ( quantity_template%noSurfs,      before=' NoSurfs = ' )
    call output ( quantity_template%noInstances,  before=' NoInstances = ' )
    call output ( quantity_template%noCrossTrack, before=' NoCrossTrack = ', advance='yes' )
d565 1
a565 1
    if ( .not. quantity_template%coherent ) call output ( 'in' )
d567 1
a567 1
    if ( .not. quantity_template%stacked ) call output ( 'non' )
d569 1
a569 1
    if ( .not. quantity_template%regular ) call output ( 'ir' )
d571 1
a571 1
    if ( quantity_template%logBasis ) then
d577 1
a577 1
    call output ( trim(merge('   ','non',quantity_template%minorFrame)) // &
d579 1
a579 1
    call output ( ' ' // trim(merge('   ','non',quantity_template%majorFrame)) // &
d582 1
a582 1
    call output ( quantity_template%noInstancesLowerOverlap )
d584 3
a586 3
    call output ( quantity_template%noInstancesUpperOverlap, advance='yes' )
    if ( .not. myNoL2CF .and. quantity_template%unit > 0 ) then
      call myDisplayString ( lit_indices(quantity_template%unit), &
d589 1
a589 1
    call output ( quantity_template%badValue, before=' BadValue = ' )
d591 3
a593 3
    call output ( quantity_template%InstanceLen, advance='yes' )
    if ( .not. myNoL2CF .and. quantity_template%horizontalCoordinate > 0 ) &
      & call myDisplayString ( lit_indices(quantity_template%horizontalCoordinate), &
d595 1
a595 1
    call myDisplayString ( lit_indices(quantity_template%latitudeCoordinate), &
d597 2
a598 2
    call output ( quantity_template%hGridIndex, before='      hGridIndex = ' )
    call output ( quantity_template%xGridIndex, before=' xGridIndex = ' )
d601 2
a602 2
    call output ( quantity_template%sharedVGrid, advance='no' )
    if ( quantity_template%sharedVGrid ) then
d604 1
a604 1
      call output ( quantity_template%vGridIndex )
d606 2
a607 2
    if ( .not. myNoL2CF .and. quantity_template%verticalCoordinate > 0 ) &
      & call myDisplayString ( lit_indices(quantity_template%verticalCoordinate), &
d611 2
a612 2
    call output ( quantity_template%sharedFGrid, advance='no' )
    if ( quantity_template%sharedFGrid ) then
d614 1
a614 1
      call output ( quantity_template%fGridIndex )
d616 1
a616 1
    call myDisplayString ( lit_indices(quantity_template%frequencyCoordinate), &
d618 1
a618 1
    if ( quantity_template%radiometer /= 0 .and. .not. myNoL2CF ) then
d620 1
a620 1
      call GetRadiometerName ( quantity_template%radiometer, str )
d625 1
a625 1
      if ( quantity_template%quantityType == l_vmr ) then
d627 1
a627 1
        call myDisplayString ( lit_indices(quantity_template%molecule) )
d629 1
a629 1
      if ( quantity_template%instrumentModule /= 0 ) then
d631 1
a631 1
        call GetModuleName ( quantity_template%instrumentModule, str )
d637 1
a637 1
      if ( quantity_template%signal /= 0 ) then
d639 1
a639 1
        call output ( quantity_template%signal )
d641 3
a643 3
        if ( associated(quantity_template%channels) ) then
          call dump ( signals(quantity_template%signal), &
            & otherChannels=quantity_template%channels )
d645 1
a645 1
          call dump ( signals(quantity_template%signal) )
d648 2
a649 2
      call maybe_dump_2_rt ( quantity_template%phi, 'Phi' )
      call maybe_dump_2_rt ( quantity_template%surfs, 'Surfs' )
d651 21
a671 9
        call maybe_dump_2_I ( quantity_template%surfIndex, 'SurfIndex' )
        call maybe_dump_2_I ( quantity_template%chanIndex, 'ChanIndex' )
        call maybe_dump_3_rt ( quantity_template%geodLat3, 'GeodLat' )
        call maybe_dump_3_rt ( quantity_template%lon3, 'Lon' )
        call maybe_dump_2_rt ( quantity_template%time, 'Time' )
        call maybe_dump_2_rt ( quantity_template%solarTime, 'SolarTime' )
        call maybe_dump_2_rt ( quantity_template%solarZenith, 'SolarZenith' )
        call maybe_dump_2_rt ( quantity_template%losAngle, 'LosAngle' )
        call maybe_dump_1_rt ( quantity_template%crossAngles, 'CrossAngles' )
d673 2
a674 2
      if ( associated(quantity_template%frequencies)  .and. .not. myNoL2CF ) then
        call myDisplayString ( lit_indices(quantity_template%frequencyCoordinate), &
d676 1
a676 1
        call dump ( quantity_template%frequencies, ' Frequencies = ' )
d679 2
a680 2
      if ( associated(quantity_template%frequencies)  .and. .not. myNoL2CF ) &
        & call myDisplayString ( lit_indices(quantity_template%frequencyCoordinate), &
a714 10
  
    subroutine Maybe_Dump_3_RT ( Array, Name )
      real(rt), intent(in), pointer :: Array(:,:,:)
      character(*), intent(in) :: Name
      if ( associated(array) ) then
        call dump ( array, '      ' // trim(name) // ' = ' )
      else
        call output ( '      No ' // trim(name), advance='yes' )
      end if
    end subroutine Maybe_Dump_3_RT
d809 2
a810 3
        call deallocate_test( z%geodLat1, 'template geodLat', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        nullify ( z%geodLat, z%geodLat3 )
d817 2
a818 3
        call deallocate_test( z%lon1, 'template lon', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        nullify ( z%lon, z%lon3 )
d1042 1
a1042 1
    integer :: I
d1059 7
a1065 3
      do i = 1, qty%noCrossTrack
        qty%geodLat3(:,:,i) = hGrid%geodLat
        qty%lon3(:,:,i) = hGrid%lon
d1403 2
a1404 1
  ! --------- Private procedures ---
d1686 24
d1879 26
d1909 1
a1909 1
       "$Id: QuantityTemplates.f90,v 2.93 2015/05/27 22:41:46 vsnyder Exp $"
d1921 3
@


2.93
log
@Move PointQuantityToHGrid here from HGridDatabase.  Eliminate shared
HGrids.
@
text
@d445 1
a445 1
    call deallocate_test ( qty%lon, 'Qty%Lon', moduleName )
d1880 1
a1880 1
       "$Id: QuantityTemplates.f90,v 2.92 2015/05/01 02:09:28 vsnyder Exp $"
d1892 4
@


2.92
log
@Spiff a dump
@
text
@d22 1
d24 2
a25 2
  use INTRINSIC, only: L_DL, L_Geocentric, L_Geodetic, L_None, L_PhiTan, L_VMR, &
    & LIT_INDICES, PHYQ_Angle, PHYQ_Dimensionless, PHYQ_Frequency, PHYQ_Time
d42 5
a46 3
    & DestroyQuantityTemplateContents, DestroyQuantityTemplateDatabase, &
    & Dump, ModifyQuantityTemplate, NullifyQuantityTemplate, &
    & QuantitiesAreCompatible, SetupNewQuantityTemplate, WriteAttributes
d136 1
a137 1
    logical :: sharedHGrid              ! Set if horiz coord is a pointer not a copy
a344 1
    z%sharedHGrid                  = a%sharedHGrid             
d389 15
d413 15
d434 9
d444 5
a448 1
  end subroutine CreateGeolocationFields
d477 1
a477 1
    if ( qty%sharedHGrid ) then
d479 19
a497 20
      if ( qty%noCrossTrack > 1 ) then
        call deallocate_test ( qty%lon1, trim(what) // '%geodLat1', ModuleName )
        call deallocate_test ( qty%geodLat1, trim(what) // '%geodLat1', ModuleName )
        if ( verbose ) call output( 'About to deallocate lons', advance='yes' )
        call deallocate_test ( qty%lon1, trim(what) // '%lon1', ModuleName )
      end if

      ! ------------ This ought to be true but apparently isn't ------------
      ! If the quantity isn't stacked, an empty Phi array is allocated, even
      ! if hGrids are shared.  Its size is zero, but it doesn't hurt to
      ! deallocate it.
      ! --------------------------------------------------------------------
!       if ( .not. qty%stacked ) &
!         & call deallocate_test ( qty%phi, trim(what) // '%phi', ModuleName )

      nullify ( qty%geodLat1, qty%geodLat, qty%geodLat3, &
              & qty%lon1, qty%lon, qty%lon3, qty%time, qty%solarTime, &
              & qty%solarZenith, qty%losAngle, qty%crossAngles )

    else
d499 2
a500 24
      ! If not stacked, there is no Phi.
      if ( qty%stacked ) then
        if ( verbose ) call output( 'About to deallocate stacked phi', advance='yes' )
        call deallocate_test ( qty%phi, trim(what) // '%phi', ModuleName )
      end if
      if ( verbose ) call output( 'About to deallocate geosdlat', advance='yes' )
      call deallocate_test ( qty%geodLat1, trim(what) // '%geodLat', ModuleName )
      if ( verbose ) call output( 'About to deallocate lons', advance='yes' )
      call deallocate_test ( qty%lon1, trim(what) // '%lon', ModuleName )
      if ( verbose ) call output( 'About to deallocate times', advance='yes' )
      call deallocate_test ( qty%time, trim(what) // '%time', ModuleName )
      if ( verbose ) call output( 'About to deallocate solartime', advance='yes' )
      call deallocate_test ( qty%solarTime, trim(what) // '%solarTime', ModuleName )
      if ( verbose ) call output( 'About to deallocate solarzenits', advance='yes' )
      call deallocate_test ( qty%solarZenith, trim(what) // '%solarZenith', ModuleName )
      if ( verbose ) call output( 'About to deallocate losangle', advance='yes' )
      call deallocate_test ( qty%losAngle, trim(what) // '%losAngle', ModuleName )
      if ( verbose ) call output( 'About to deallocate crossAngles', advance='yes' )
      call deallocate_test ( qty%crossAngles, trim(what) // '%crossAngles', ModuleName )

      ! Nullify the remapped ones.
      nullify ( qty%geodLat, qty%geodLat3, qty%lon, qty%lon3 )

    end if
d509 2
d518 2
d623 2
a624 6
    call output ( '      sharedHGrid = ' )
    call output ( quantity_template%sharedHGrid, advance='no' )
    if ( quantity_template%sharedHGrid ) then
      call output ( quantity_template%hGridIndex, before=' hGridIndex = ' )
      call output ( quantity_template%xGridIndex, before=' xGridIndex = ' )
    end if
d664 1
a664 1
        call output ( '   Signal ' )
d674 2
a675 4
      if ( associated(quantity_template%phi) ) &
        & call dump ( quantity_template%phi,           '      Phi = ' )
      if ( associated(quantity_template%surfs) ) &
        & call dump ( quantity_template%surfs,         '      Surfs = ' )
d677 9
a685 18
        if ( associated(quantity_template%surfIndex) ) &
          & call dump ( quantity_template%surfIndex,   '      SurfIndex = ' )
        if ( associated(quantity_template%chanIndex) ) &
          & call dump ( quantity_template%chanIndex,   '      ChanIndex = ' )
        if ( associated(quantity_template%geodLat3) ) &
          & call dump ( quantity_template%geodLat3,    '      GeodLat = ' )
        if ( associated(quantity_template%lon3) ) &
          & call dump ( quantity_template%lon3,        '      Lon = ' )
        if ( associated(quantity_template%time) ) &
          & call dump ( quantity_template%time,        '      Time = ' )
        if ( associated(quantity_template%solarTime) ) &
          & call dump ( quantity_template%solarTime,   '      SolarTime = ' )
        if ( associated(quantity_template%solarZenith) ) &
          & call dump ( quantity_template%solarZenith, '      SolarZenith = ' )
        if ( associated(quantity_template%losAngle) ) &
          & call dump ( quantity_template%losAngle,    '      LosAngle = ' )
        if ( associated(quantity_template%crossAngles) ) &
          call dump ( quantity_template%crossAngles, name='      CrossAngles' )
d697 43
d833 1
a833 4
        call deallocate_test( z%geodLat, 'template geodLat', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        call allocate_test ( z%geodLat, shp(1), shp(2), &
          & "template geodLat", &
d835 3
d842 1
a842 4
        call deallocate_test( z%lon, 'template lon', &
          & ModuleName // 'ModifyQuantityTemplate_allocate' )
        call allocate_test ( z%lon, shp(1), shp(2), &
          & "template lon", &
d844 3
d1052 63
d1194 1
a1194 1
    & sharedVGrid, sharedHGrid, sharedFGrid, badValue )
a1216 1
    logical, intent(in), optional :: sharedHGrid
a1253 1
    qty%sharedHGrid = .false.
a1276 1
    if ( present (sharedHGrid) )  qty%sharedHGrid = sharedHGrid
d1330 15
a1344 21
    if ( qty%sharedHGrid ) then
      nullify ( qty%phi, qty%geodLat, qty%geodLat1, qty%geodLat3, &
        & qty%lon, qty%lon1, qty%lon3, qty%crossAngles, qty%time, &
        & qty%solarTime, qty%solarZenith, qty%losAngle )
    else
      call allocate_test ( qty%crossAngles, qty%noCrossTrack, &
        & trim(what) // "%crossAngles", ModuleName )
      qty%crossAngles = 0.0 ! In case there actually is no xGrid
      call allocate_test ( qty%phi, noSurfsToAllocate, qty%noInstances, &
        & trim(what) // "%phi", ModuleName )
      ! Create GeodLat and Lon fields.
      call createGeolocationFields ( qty, noSurfsToAllocate, what )
      call allocate_test ( qty%time, noSurfsToAllocate, qty%noInstances, &
        & trim(what) // "%time", ModuleName )
      call allocate_test ( qty%solarTime, noSurfsToAllocate, qty%noInstances, &
        & trim(what) // "%solarTime", ModuleName )
      call allocate_test ( qty%solarZenith, noSurfsToAllocate, qty%noInstances, &
        & trim(what) // "%solarZenith", ModuleName )
      call allocate_test ( qty%losAngle, noSurfsToAllocate, qty%noInstances, &
        & trim(what) // "%losAngle", ModuleName )
    end if
d1880 1
a1880 1
       "$Id: QuantityTemplates.f90,v 2.91 2015/04/29 00:53:28 vsnyder Exp $"
d1892 3
@


2.91
log
@Spiff the dump
@
text
@d560 1
a560 1
    call output ( quantity_template%noInstances,  before='      NoInstances = ' )
d562 1
a562 1
    call output ( quantity_template%noChans,      before=' NoChans = ' )
d1772 1
a1772 1
       "$Id: QuantityTemplates.f90,v 2.90 2015/04/07 02:51:50 vsnyder Exp $"
d1784 3
@


2.90
log
@Remove CONTIGUOUS attribute from 2-D geolocation components.  Non-
contiguous sections of them are targets in ConstructMajorFrameQuantity in
ConstructQuantityTemplates.
@
text
@d158 1
a158 1
    real(rt), pointer :: Time(:,:) => NULL() ! Seconds since EPOCH
a560 1
    call output ( quantity_template%noChans,      before=' noChans = ' )
d562 1
d612 2
a613 1
      & before=' vertical coordinate = ', advance='yes' )
d618 1
a618 1
      call output ( quantity_template%fGridIndex, advance='yes' )
d621 1
a621 1
      & before=   '      frequency coordinate = ', advance='yes' )
d1772 1
a1772 1
       "$Id: QuantityTemplates.f90,v 2.89 2015/03/28 01:40:45 vsnyder Exp $"
d1784 5
@


2.89
log
@Added NoCrossTrack.  Added Unit (for values).  Added xGridIndex.  Added
1-d and 3-d geolocation quantities; made them contiguous.  Added
LatitudeCoordinate (geocentric or geodetic).  Added CrossAngles.  Checked
pointer components before copying them in CopyQuantityTemplate.  Added
CreateGeolocationFields.  Fiddled with shared HGrids, but probably didn't
improve anything.  Spiffed a dump, dump units, dump CrossAngles, dump
LatitudeCorrdinate.  Adjusted QuantitiesAreCompatible to allow different
types if requested.  Added NoCrossTrack to SetupNewQuantityTemplate.
Added stuff to trace allocate/deallocate addresses -- some commented out
because NAG build 1017 doesn't yet allow arrays as arguments to C_LOC.
@
text
@d72 1
a72 1
    integer :: NoChans         ! Number of channels
d156 6
a161 6
    real(rt), contiguous, pointer :: GeodLat(:,:) => NULL()     ! Degrees
    real(rt), contiguous, pointer :: Lon(:,:) => NULL()         ! Degrees
    real(rt), contiguous, pointer :: Time(:,:) => NULL() ! Seconds since EPOCH
    real(rt), contiguous, pointer :: SolarTime(:,:) => NULL()
    real(rt), contiguous, pointer :: SolarZenith(:,:) => NULL() ! Degrees
    real(rt), contiguous, pointer :: LosAngle(:,:) => NULL()    ! Degrees
d620 1
a620 1
      & before=   ' frequency coordinate = ', advance='yes' )
d1771 1
a1771 1
       "$Id: QuantityTemplates.f90,v 2.88 2014/10/29 23:04:29 vsnyder Exp $"
d1783 12
@


2.88
log
@Specified units of several components
@
text
@d23 2
a24 2
  use INTRINSIC, only: L_NONE, L_VMR, L_PhiTan, LIT_INDICES, PHYQ_Angle, &
    & PHYQ_Dimensionless, PHYQ_Frequency, PHYQ_Time
d38 7
d65 1
a65 1
    integer :: quantityType
d69 6
a74 3
    integer :: noInstances     ! Number of horizontal instances in this quantity
    integer :: noSurfs         ! Number of surfaces per instance
    integer :: noChans         ! Number of channels
d102 5
a106 2
    integer :: unit           ! Unit quantity is in when scaled as below,
                              ! an l_lit of the type t_units in Units.f90.
d127 1
a127 1
    ! Horizontal coordinates
d130 2
a131 1
    logical :: sharedHGrid              ! Set if horiz coord is a pointer not a copy
d134 2
a135 2
    integer :: grandTotalInstances      ! Total number of instances in destination output file
    ! for example MAF index, or profile index.
d142 2
a143 2
    ! Geolocation is dimensioned (*,1, noInstances) for stacked quantities and
    ! (*,noSurfs, noInstances) for unstacked ones.  The Geolocation coordinate
d148 1
a148 1
    real(rt), dimension(:,:), pointer :: phi => NULL() ! Degrees
d156 35
a190 6
    real(rt), dimension(:,:), pointer :: geodLat => NULL() ! Degrees
    real(rt), dimension(:,:), pointer :: lon => NULL()     ! Degrees
    real(rt), dimension(:,:), pointer :: time => NULL() ! Seconds since EPOCH
    real(rt), dimension(:,:), pointer :: solarTime => NULL()
    real(rt), dimension(:,:), pointer :: solarZenith => NULL()
    real(rt), dimension(:,:), pointer :: losAngle => NULL()
a257 6
  public :: EPOCH, QuantityTemplate_T, RT
  public :: AddQuantityTemplateToDatabase, InflateQuantityTemplateDatabase
  public :: CheckIntegrity, CopyQuantityTemplate, &
    & DestroyQuantityTemplateContents, DestroyQuantityTemplateDatabase, &
    & Dump, ModifyQuantityTemplate, NullifyQuantityTemplate, &
    & QuantitiesAreCompatible, SetupNewQuantityTemplate, WriteAttributes
d284 1
d302 2
a303 2
    ! is required.  Note that this also follows any 'links' to h/vGrids and expands
    ! them too.
d313 5
a317 3
    call SetupNewQuantityTemplate ( z, a%noInstances, a%noSurfs, a%noChans, &
      & a%coherent, a%stacked, a%regular, a%instanceLen, a%minorFrame, &
      & a%majorFrame )
d341 1
d359 10
a368 10
    z%surfs       = a%surfs
    z%phi         = a%phi
    z%geodLat     = a%geodLat
    z%lon         = a%lon
    z%time        = a%time
    z%solarTime   = a%solarTime
    z%solarZenith = a%solarZenith
    z%losAngle    = a%losAngle
    z%ChanInds    = a%ChanInds
    z%Channels    = a%Channels
d377 28
d432 28
a459 3
    if ( .not. qty%sharedHGrid ) then
      if ( verbose ) call output( 'About to deallocate phi', advance='yes' )
      call deallocate_test ( qty%phi, trim(what) // '%phi', ModuleName )
d461 1
a461 1
      call deallocate_test ( qty%geodLat, trim(what) // '%geodLat', ModuleName )
d463 1
a463 1
      call deallocate_test ( qty%lon, trim(what) // '%lon', ModuleName )
d472 6
d503 2
d507 1
d519 2
d522 1
a522 1
      call test_deallocate ( status, ModuleName, "database", s )
d527 1
a527 1
  subroutine DUMP_QUANTITY_TEMPLATE ( QUANTITY_TEMPLATE, DETAILS, NOL2CF )
d541 1
d545 1
d552 1
a552 1
    if ( .not. myNoL2CF ) then
d554 3
a556 2
      call myDisplayString ( lit_indices(quantity_template%quantityType), &
        & advance='yes' )
d558 6
a563 3
    call output ( quantity_template%noInstances, before='      NoInstances = ' )
    call output ( quantity_template%noChans,     before=' noChans = ' )
    call output ( quantity_template%noSurfs,     before=' NoSurfs = ', advance='yes' )
d577 4
a580 2
    if ( .not. quantity_template%minorFrame ) call output ( 'non' )
    call output ( 'minorFrame', advance='yes' )
d585 3
a587 5
    call output ( '      BadValue = ' )
    call output ( quantity_template%badValue )
    if ( .not. myNoL2CF ) then
      call output ( ' Unit = ' )
      call myDisplayString ( lit_indices(quantity_template%unit) )
d589 1
d592 1
a592 1
    if ( .not. myNoL2CF ) &
d594 3
a596 1
      & before=   '      horizontal coordinate = ', advance='yes' )
d600 2
a601 4
      call output ( ' hGridIndex = ' )
      call output ( quantity_template%hGridIndex, advance='yes' )
    else
      call newline
d603 1
d610 1
a610 1
    if ( .not. myNoL2CF ) &
a617 2
    else
      call newline
d619 2
d660 4
a663 4
        if ( associated(quantity_template%geodLat) ) &
          & call dump ( quantity_template%geodLat,     '      GeodLat = ' )
        if ( associated(quantity_template%lon) ) &
          & call dump ( quantity_template%lon,         '      Lon = ' )
d672 2
d688 1
a688 1
  subroutine DUMP_QUANTITY_TEMPLATES ( QUANTITY_TEMPLATES, DETAILS, NOL2CF )
d695 1
d704 1
a704 1
      call dump_quantity_template ( quantity_templates(i), details, nol2cf )
d715 1
d756 1
a756 1
    endif
d765 1
a765 1
      endif
d774 1
a774 1
      endif
d783 1
a783 1
      endif
d792 1
a792 1
      endif
d801 1
a801 1
      endif
d810 1
a810 1
      endif
d819 1
a819 1
      endif
d828 1
a828 1
      endif
d835 1
a835 1
      elseif ( size(z%frequencies) /= shp(1) ) then
d841 1
a841 1
      endif
d848 1
a848 1
    elseif ( lowercase(field) == 'frequencies' ) then
d853 1
a853 1
    endif
d875 1
a875 1
    endif
d899 1
a899 1
    elseif ( spread .and. shp(2) == 1 ) then
d943 1
a943 1
    endif
d958 1
a958 1
    endif
d998 1
a998 1
  logical function QuantitiesAreCompatible ( Qty_1, Qty_2 )
d1000 6
d1007 1
a1007 1
      & qty_1%quantityType == qty_2%quantityType .and. &
d1011 1
d1074 2
a1075 1
    & noChans, coherent, stacked, regular, instanceLen, minorFrame, majorFrame, &
d1078 2
d1095 1
d1120 1
d1131 1
a1131 1
    qty%unit = 0
d1136 1
d1156 1
d1189 1
a1189 1
      qty%instanceLen = qty%noSurfs * qty%noChans
d1216 3
a1218 2
      nullify ( qty%phi, qty%geodLat, qty%lon, qty%time, qty%solarTime, &
        & qty%solarZenith, qty%losAngle )
d1220 3
d1225 2
a1226 4
      call allocate_test ( qty%geodLat, noSurfsToAllocate, qty%noInstances, &
        & trim(what) // "%geodLat", ModuleName )
      call allocate_test ( qty%lon, noSurfsToAllocate, qty%noInstances, &
        & trim(what) // "%lon", ModuleName )
d1572 1
a1572 1
    enddo
d1656 1
a1656 1
    endif
d1661 1
a1661 1
    endif
d1673 2
a1674 2
      endif
    enddo
d1695 1
a1695 1
    endif
d1700 1
a1700 1
    endif
d1718 2
a1719 2
      endif
    enddo
d1740 1
a1740 1
    endif
d1745 1
a1745 1
    endif
d1763 2
a1764 2
      endif
    enddo
d1771 1
a1771 1
       "$Id: QuantityTemplates.f90,v 2.87 2014/09/05 00:17:16 vsnyder Exp $"
d1783 3
@


2.88.2.1
log
@Some changes to work properly with branch
@
text
@a37 7
  public :: EPOCH, QuantityTemplate_T, RT
  public :: AddQuantityTemplateToDatabase, InflateQuantityTemplateDatabase
  public :: CheckIntegrity, CopyQuantityTemplate, CreateGeolocationFields, &
    & DestroyQuantityTemplateContents, DestroyQuantityTemplateDatabase, &
    & Dump, ModifyQuantityTemplate, NullifyQuantityTemplate, &
    & QuantitiesAreCompatible, SetupNewQuantityTemplate, WriteAttributes

d58 1
a58 1
    integer :: QuantityType
d62 3
a64 6
    integer :: NoInstances     ! Number of along-track horizontal instances in
                               ! this quantity
    integer :: NoSurfs         ! Number of surfaces per instance
    integer :: NoChans         ! Number of channels
    integer :: NoCrossTrack = 1! Number of cross-track horizontal instances in
                               ! this quantity (from xGrid)
d114 1
a114 1
    ! Horizontal coordinates in the orbit plane.
d117 3
a121 4
    integer :: hGridIndex               ! Index of any hGrid used
    integer :: instanceOffset           ! Ind of 1st non overlapped instance in output
    logical :: sharedHGrid              ! Set if horiz coord is a pointer not a copy
    integer :: xGridIndex = 0           ! Index of any xGrid used
d128 2
a129 2
    ! Geolocation is dimensioned (*, 1, noInstances) for stacked quantities and
    ! (*, noSurfs, noInstances) for unstacked ones.  The Geolocation coordinate
d134 1
a134 1
    real(rt), dimension(:,:), pointer :: Phi => NULL() ! Degrees
d142 6
a147 29
    real(rt), dimension(:,:), pointer :: GeodLat => NULL()     ! Degrees
    real(rt), dimension(:,:), pointer :: Lon => NULL()         ! Degrees
    real(rt), dimension(:,:), pointer :: Time => NULL() ! Seconds since EPOCH
    real(rt), dimension(:,:), pointer :: SolarTime => NULL()
    real(rt), dimension(:,:), pointer :: SolarZenith => NULL() ! Degrees
    real(rt), dimension(:,:), pointer :: LosAngle => NULL()    ! Degrees

    ! GeodLat1 and Lon1 are the ones that are allocated.  The extents are the
    ! number of surfaces (for unstacked quantities) or 1 (for stacked
    ! quantities), times the number of instances, times the size of xGrid.
    ! GeodLat, Lon, GeodLat3, and Lon3 are then rank remapped pointers
    ! associated with GeodLat1 and Lon1.  The third extent of GeodLat3 and
    ! Lon3 is 1, or the size of xGrid if there is one.  If there is an xGrid,
    ! the second extent of GeodLat and Lon is the number of instances times
    ! the size of xGrid, with subscript values in the second dimension
    ! corresponding to positions in the xGrid separated by the number of
    ! instances (using GeodLat3 and Lon3 would be much simpler).
    real(rt), dimension(:), pointer :: GeodLat1 => NULL()      ! Degrees
    real(rt), dimension(:), pointer :: Lon1 => NULL()          ! Degrees
    real(rt), dimension(:,:,:), pointer :: GeodLat3 => NULL()  ! Degrees
    real(rt), dimension(:,:,:), pointer :: Lon3 => NULL()      ! Degrees

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! For quantities having cross-track extent other than one, CrossAngles
    ! gives the angles from Phi, in the direction of the instrument.  Positive
    ! values are away from the instrument, negative values are toward the
    ! instrument.  The values come from the quantity's xGrid, which is
    ! reqired to be an explicit hGrid.
    real(rt), dimension(:), pointer :: CrossAngles => NULL()   ! Degrees
d215 6
d264 2
a265 2
    ! is required.  Note that this also follows any 'links' to h/v/xGrids
    ! and expands them too.
d275 3
a277 5
    call SetupNewQuantityTemplate ( z, noInstances=a%noInstances, &
      & noSurfs=a%noSurfs, noChans=a%noChans, noCrossTrack=a%noCrossTrack, &
      & coherent=a%coherent, stacked=a%stacked, regular=a%regular, &
      & instanceLen=a%instanceLen, minorFrame=a%minorFrame, &
      & majorFrame=a%majorFrame )
a300 1
    z%xGridIndex                   = a%xGridIndex             
a335 28
  ! ------------------------------------  CreateGeolocationFields  -----
  subroutine CreateGeolocationFields ( Qty, NoSurfsToAllocate, What )
    ! Allocate Qty%GeodLat1 and Qty%Lon1.  Create rank-remapped pointers to
    ! Qty%GeodLat, Qty%Lon, Qty%GeodLat3, and Qty%Lon3.
    use Pointer_Rank_Remapping, only: REMAP

    type (QuantityTemplate_T), intent(inout) :: QTY
    integer, intent(in) :: NoSurfsToAllocate
    character(len=*), intent(in) :: What

    integer :: NumAlloc

    numAlloc = noSurfsToAllocate * qty%noInstances * qty%noCrossTrack
    call allocate_test ( qty%geodLat1, numAlloc, trim(what) // "%geodLat1", &
      & moduleName )
    call remap ( qty%geodLat1, qty%geodLat, &
      & [ noSurfsToAllocate, qty%noInstances * qty%noCrossTrack ] )
    call remap ( qty%geodLat1, qty%geodLat3, &
      & [ noSurfsToAllocate, qty%noInstances, qty%noCrossTrack ] )
    call allocate_test ( qty%lon1, numAlloc, trim(what) // "%lon1", &
      & moduleName )
    call remap ( qty%lon1, qty%lon, &
      & [ noSurfsToAllocate, qty%noInstances * qty%noCrossTrack ] )
    call remap ( qty%lon1, qty%lon3, &
      & [ noSurfsToAllocate, qty%noInstances, qty%noCrossTrack ] )

  end subroutine CreateGeolocationFields

a337 1
    use highOutput, only: beVerbose, letsDebug
a340 1
    logical :: DeeBug
d345 1
a345 2
    deeBug =  letsDebug( 'qtmp', 0 )
    verbose = beVerbose( 'qtmp', -1 )
d347 1
a347 1
      if ( deeBug ) call dump( qty )
a356 1
    if ( deeBug ) call outputnamedValue( 'name', what )
d363 3
a365 31
    if ( qty%sharedHGrid ) then

      if ( qty%noCrossTrack > 1 ) then
        if ( verbose ) call output( 'About to deallocate geodLat1', advance='yes' )
        call deallocate_test ( qty%geodLat1, trim(what) // '%geodLat1', ModuleName )
        if ( verbose ) call output( 'About to deallocate lons', advance='yes' )
        call deallocate_test ( qty%lon1, trim(what) // '%lon1', ModuleName )
      end if

      ! ----------------- The following is simply not true -----------------
      ! If the quantity isn't stacked, an empty Phi array is allocated, even
      ! if hGrids are shared.  Its size is zero, but it doesn't hurt to
      ! deallocate it.
      ! --------------------------------------------------------------------
      
      ! if ( verbose .and. .not. qty%stacked ) &
      !  & call output( 'About to deallocate unstacked phi', advance='yes' )
      ! if ( .not. qty%stacked ) &
      !  & call deallocate_test ( qty%phi, trim(what) // '%phi', ModuleName )

      nullify ( qty%geodLat1, qty%geodLat, qty%geodLat3, &
              & qty%lon1, qty%lon, qty%lon3, qty%time, qty%solarTime, &
              & qty%solarZenith, qty%losAngle, qty%crossAngles )

    else

      ! If not stacked, there is no Phi.
      if ( qty%stacked ) then
        if ( verbose ) call output( 'About to deallocate stacked phi', advance='yes' )
        call deallocate_test ( qty%phi, trim(what) // '%phi', ModuleName )
      end if
d367 1
a367 1
      call deallocate_test ( qty%geodLat1, trim(what) // '%geodLat', ModuleName )
d369 1
a369 1
      call deallocate_test ( qty%lon1, trim(what) // '%lon', ModuleName )
a377 6
      if ( verbose ) call output( 'About to deallocate crossAngles', advance='yes' )
      call deallocate_test ( qty%crossAngles, trim(what) // '%crossAngles', ModuleName )

      ! Nullify the remapped ones.
      nullify ( qty%geodLat, qty%geodLat3, qty%lon, qty%lon3 )

d411 1
a411 1
      call outputNamedValue( 'size(qty db)', size ( database ) )
a417 2
    else
      call output( 'databasee not associated', advance='yes' )
d445 1
a445 1
    if ( .not. myNoL2CF .and. quantity_template%quantityType > 0 ) then
a448 2
    else
      call output ( ' unknown quantityType', advance='yes' )
d450 3
a452 4
    call output ( quantity_template%noInstances,  before='      NoInstances = ' )
    call output ( quantity_template%noChans,      before=' noChans = ' )
    call output ( quantity_template%noSurfs,      before=' NoSurfs = ' )
    call output ( quantity_template%noCrossTrack, before=' NoCrossTrack = ', advance='yes' )
d466 2
a467 4
    call output ( ' ' // trim(merge('   ','non',quantity_template%minorFrame)) // &
      & 'minorFrame' )
    call output ( ' ' // trim(merge('   ','non',quantity_template%majorFrame)) // &
      & 'majorFrame', advance='yes' )
d474 1
a474 1
    if ( .not. myNoL2CF .and. quantity_template%unit > 0 ) then
d480 1
a480 1
    if ( .not. myNoL2CF .and. quantity_template%horizontalCoordinate > 0 ) &
d486 4
a489 2
      call output ( quantity_template%hGridIndex, before=' hGridIndex = ' )
      call output ( quantity_template%xGridIndex, before=' xGridIndex = ' )
a490 1
    call newline
d497 1
a497 1
    if ( .not. myNoL2CF .and. quantity_template%verticalCoordinate > 0 ) &
d505 2
a507 2
    call myDisplayString ( lit_indices(quantity_template%frequencyCoordinate), &
      & before=   ' frequency coordinate = ', advance='yes' )
d547 4
a550 4
        if ( associated(quantity_template%geodLat3) ) &
          & call dump ( quantity_template%geodLat3,    '      GeodLat = ' )
        if ( associated(quantity_template%lon3) ) &
          & call dump ( quantity_template%lon3,        '      Lon = ' )
a558 2
        if ( associated(quantity_template%crossAngles) ) &
          call dump ( quantity_template%crossAngles, name='      CrossAngles' )
d639 1
a639 1
    end if
d648 1
a648 1
      end if
d657 1
a657 1
      end if
d666 1
a666 1
      end if
d675 1
a675 1
      end if
d684 1
a684 1
      end if
d693 1
a693 1
      end if
d702 1
a702 1
      end if
d711 1
a711 1
      end if
d724 1
a724 1
      end if
d736 1
a736 1
    end if
d758 1
a758 1
    end if
d826 1
a826 1
    end if
d841 1
a841 1
    end if
d881 1
a881 1
  logical function QuantitiesAreCompatible ( Qty_1, Qty_2, DifferentTypeOK )
a882 6
    logical, intent(in), optional :: DifferentTypeOK
    logical :: TypeCheck
    typeCheck = qty_1%quantityType == qty_2%quantityType
    if ( present(differentTypeOK) ) then
      if ( differentTypeOK ) typeCheck = .true.
    end if
d884 1
a884 1
      & typeCheck .and. &
a887 1
      & qty_1%noCrossTrack == qty_2%noCrossTrack .and. &
d950 1
a950 2
    & noChans, coherent, stacked, regular, instanceLen, noCrossTrack, &
    & minorFrame, majorFrame, &
a967 1
    integer, intent(in), optional :: noCrossTrack
a991 1
    qty%noCrossTrack = 1
a1006 1
    qty%xGridIndex = 0
a1025 1
    if ( present (noCrossTrack) ) qty%noCrossTrack = noCrossTrack
d1058 1
a1058 1
      qty%instanceLen = qty%noSurfs * qty%noChans * qty%noCrossTrack
d1085 2
a1086 3
      nullify ( qty%phi, qty%geodLat, qty%geodLat1, qty%geodLat3, &
        & qty%lon, qty%lon1, qty%lon3, qty%crossAngles, qty%time, &
        & qty%solarTime, qty%solarZenith, qty%losAngle )
a1087 3
      call allocate_test ( qty%crossAngles, qty%noCrossTrack, &
        & trim(what) // "%crossAngles", ModuleName )
      qty%crossAngles = 0.0 ! In case there actually is no xGrid
d1090 4
a1093 2
      ! Create GeodLat and Lon fields.
      call createGeolocationFields ( qty, noSurfsToAllocate, what )
d1523 1
a1523 1
    end if
d1528 1
a1528 1
    end if
d1540 1
a1540 1
      end if
d1562 1
a1562 1
    end if
d1567 1
a1567 1
    end if
d1585 1
a1585 1
      end if
d1607 1
a1607 1
    end if
d1612 1
a1612 1
    end if
d1630 1
a1630 1
      end if
d1638 1
a1638 1
       "$Id: QuantityTemplates.f90,v 2.88 2014/10/29 23:04:29 vsnyder Exp $"
a1649 3
! Revision 2.88  2014/10/29 23:04:29  vsnyder
! Specified units of several components
!
@


2.87
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d134 1
a134 1
    real(rt), dimension(:,:), pointer :: phi => NULL()
d142 2
a143 2
    real(rt), dimension(:,:), pointer :: geodLat => NULL()
    real(rt), dimension(:,:), pointer :: lon => NULL()
d1638 1
a1638 1
       "$Id: QuantityTemplates.f90,v 2.86 2014/08/19 00:28:33 vsnyder Exp $"
d1650 3
@


2.86
log
@Make sure 'what' is always defined in DestroyQuantityTemplate
@
text
@d27 1
a27 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, &
    & MLSMSG_ERROR, MLSMSG_WARNING
d246 2
d401 2
a403 1

d405 1
a405 1
    integer :: qtyIndex, status
d415 1
d417 1
a417 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate // "database" )
d598 2
d1638 1
a1638 1
       "$Id: QuantityTemplates.f90,v 2.85 2014/08/07 22:45:15 vsnyder Exp $"
d1650 3
@


2.85
log
@Default HorizontalCoordinate to L_Phi_Tan instead of undefined
@
text
@d351 1
a351 1
    elseif ( verbose ) then
d353 2
d1634 1
a1634 1
       "$Id: QuantityTemplates.f90,v 2.84 2014/08/06 23:23:02 vsnyder Exp $"
d1646 3
@


2.84
log
@Forgot to save from editor before commiting last time
@
text
@d116 2
a117 2
    integer :: horizontalCoordinate     ! The horizontal coordinate used. Either
                                        ! l_phiTan or l_time
d1632 1
a1632 1
       "$Id: QuantityTemplates.f90,v 2.83 2014/08/06 23:22:28 vsnyder Exp $"
d1644 3
@


2.83
log
@Combine several USE statements for the same module.  Remove declaration
of unused parameter DEEBUG.
@
text
@a24 1
  use INTRINSIC, only: 
d1632 1
a1632 1
       "$Id: QuantityTemplates.f90,v 2.82 2014/04/24 23:49:25 pwagner Exp $"
d1644 4
@


2.82
log
@Added horizontalCoordinate component
@
text
@d23 3
a25 2
  use INTRINSIC, only: phyq_angle, phyq_dimensionless, phyq_frequency, &
    & phyq_time, l_phiTan
a29 1
  use INTRINSIC, only: L_NONE, L_VMR, LIT_INDICES, PHYQ_INDICES
a45 2
  logical, parameter, private :: DEEBUG = .FALSE.           ! Usually FALSE

d1633 1
a1633 1
       "$Id: QuantityTemplates.f90,v 2.81 2014/03/20 01:39:47 vsnyder Exp $"
d1645 3
@


2.81
log
@Unified types in Intrinsic
@
text
@d23 2
a24 2
  use INTRINSIC, only: PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_FREQUENCY, &
    & PHYQ_TIME
d119 2
d304 1
d479 3
d496 2
a497 1
    if ( .not. myNoL2CF ) call myDisplayString ( lit_indices(quantity_template%verticalCoordinate), &
d1005 1
d1635 1
a1635 1
       "$Id: QuantityTemplates.f90,v 2.80 2014/01/09 00:24:29 pwagner Exp $"
d1647 3
@


2.80
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d472 1
a472 1
      call myDisplayString ( phyq_indices(quantity_template%unit) )
d896 2
a897 1
    use INTRINSIC, only: GET_PHYQ
d905 2
d921 6
a926 1
    qt%unit = get_phyq( str )
d1140 1
a1140 1
      call myGetString ( phyq_indices(qt%unit), str, strip=.true. )
d1627 1
a1627 1
       "$Id: QuantityTemplates.f90,v 2.79 2013/12/12 01:57:17 vsnyder Exp $"
d1639 3
@


2.79
log
@Change type of debug from logical to integer
@
text
@d22 1
d33 1
a33 1
  use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
d1619 1
a1619 1
       "$Id: QuantityTemplates.f90,v 2.78 2013/09/19 23:31:08 vsnyder Exp $"
d1631 3
@


2.78
log
@Use MyDisplayString more, add QuantitiesAreCompatible
@
text
@d1416 1
a1416 1
    call lookup ( strID, found, caseless=.true., debug=.false. )
d1441 1
a1441 1
    call lookup ( strID, found, caseless=.true., debug=.false. )
d1618 1
a1618 1
       "$Id: QuantityTemplates.f90,v 2.77 2013/08/16 02:27:04 vsnyder Exp $"
d1630 3
@


2.77
log
@Declare RT named constant = R8, and use it for REAL components
@
text
@a32 1
  use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
a204 1
  ! Local procedures
d209 1
a216 1
  public :: CHECKINTEGRITY, DUMP
d218 1
a218 1
  public :: CopyQuantityTemplate, &
d220 2
a221 2
    & ModifyQuantityTemplate, &
    & NullifyQuantityTemplate, SetupNewQuantityTemplate, WriteAttributes
a420 1
    use STRING_TABLE, only: DISPLAY_STRING
d489 1
a489 1
    if ( .not. myNoL2CF ) call display_string ( lit_indices(quantity_template%verticalCoordinate), &
d552 1
a552 1
        call display_string ( lit_indices(quantity_template%frequencyCoordinate), &
d558 1
a558 1
        & call display_string ( lit_indices(quantity_template%frequencyCoordinate), &
d869 20
d1446 1
a1446 1
  subroutine myDisplayString ( index, advance )
d1448 1
a1448 1
    use String_Table, only: HOW_MANY_STRINGS
d1451 1
d1454 1
d1456 1
a1456 1
      call output ( '(string index < 1)' )
d1458 2
a1459 1
      call output ( how_many_strings(), before='(string index > ', after=')' )
d1468 1
a1468 1
    use String_Table, only: HOW_MANY_STRINGS
d1618 1
a1618 1
       "$Id: QuantityTemplates.f90,v 2.76 2013/08/12 23:47:25 pwagner Exp $"
d1630 3
@


2.76
log
@FindSomethings moved to MLSFinds module
@
text
@d25 1
a25 1
  use MLSKINDS, only: R8, RV
d50 1
a50 1
  real(r8), parameter :: EPOCH = 1993.0 ! Starting point for time references
d86 1
a86 1
    real(r8) :: minValue                ! Minimum value to consider if using log
d95 1
a95 1
    real(r8) :: badValue      ! Value used to flag bad/missing data
d110 1
a110 1
    real(r8), dimension(:,:), pointer :: surfs => NULL()
d128 1
a128 1
    real(r8), dimension(:,:,:), pointer :: Geolocation => NULL()
d136 1
a136 1
    real(r8), dimension(:,:), pointer :: phi => NULL()
d144 6
a149 6
    real(r8), dimension(:,:), pointer :: geodLat => NULL()
    real(r8), dimension(:,:), pointer :: lon => NULL()
    real(r8), dimension(:,:), pointer :: time => NULL() ! Seconds since EPOCH
    real(r8), dimension(:,:), pointer :: solarTime => NULL()
    real(r8), dimension(:,:), pointer :: solarZenith => NULL()
    real(r8), dimension(:,:), pointer :: losAngle => NULL()
d155 1
a155 1
    ! Some quantities are on abritrary freqency grids; these quantities refer
d161 1
a161 1
    real(r8), dimension(:), pointer :: frequencies => NULL() ! List of frequencies
d164 1
a164 1
    real(r8) :: lo                      ! Local oscillator frequency, MHz
d217 1
a217 1
  public :: EPOCH, QuantityTemplate_T
d741 1
a741 1
    real(rv), dimension(:,:), intent(in)     :: array
d828 1
a828 1
    real(rv), intent(in)                     :: newvalue
d937 1
a937 1
    real(r8), intent(in), optional :: badValue
d962 1
a962 1
    qty%minValue = - huge ( 0.0_r8 )
d965 1
a965 1
    qty%badValue = huge ( 0.0_r8 )
d977 1
a977 1
    qty%lo = 0.0_r8
d1478 1
a1478 1
    real (r8), dimension(2) :: valueAsArray ! Value given
d1516 1
a1516 1
    real (r8), dimension(2) :: valueAsArray ! Value given
d1561 1
a1561 1
    real (r8), dimension(2) :: valueAsArray ! Value given
d1598 1
a1598 1
       "$Id: QuantityTemplates.f90,v 2.75 2013/07/12 23:57:42 vsnyder Exp $"
d1610 3
@


2.75
log
@Added Geolocation component
@
text
@d29 1
a29 1
  use MLSSETS, only: FINDFIRST
d1598 1
a1598 1
       "$Id: QuantityTemplates.f90,v 2.74 2013/06/12 02:13:40 vsnyder Exp $"
d1610 3
@


2.74
log
@Cruft removal
@
text
@d124 12
d141 1
a141 1
    ! unstacked one.
d143 1
a143 1
    ! These other coordinates are dimensioned in the same manner:
d1598 1
a1598 1
       "$Id: QuantityTemplates.f90,v 2.73 2012/10/30 22:06:14 pwagner Exp $"
d1610 3
@


2.73
log
@Fixed some obscure bugs when modifying templates
@
text
@d732 1
a732 1
    integer, dimension(2) :: shp(2)
d1586 1
a1586 1
       "$Id: QuantityTemplates.f90,v 2.72 2012/10/29 17:41:16 pwagner Exp $"
d1598 3
@


2.72
log
@Attempted a more complete CopyQuantityTemplate
@
text
@d22 2
a23 2
  use INTRINSIC, only: PHYQ_DIMENSIONLESS
  use MLSCOMMON, only: NAMELEN
d32 1
a32 1
  use OUTPUT_M, only: NEWLINE, OUTPUT, OUTPUTNAMEDVALUE
d35 1
a35 1
  use TREE, only: NSONS,SUBTREE
a408 1
    use INTRINSIC, only: LIT_INDICES
a613 3
    ! Local variables
    integer :: n1
    integer :: n2
d629 1
a629 1
      call myValuesToField( z%surfs, SHP, VALUESNODE, spread )
d638 1
a638 1
      call myValuesToField( z%phi, SHP, VALUESNODE, spread )
d647 1
a647 1
      call myValuesToField( z%geodLat, SHP, VALUESNODE, spread )
d656 1
a656 1
      call myValuesToField( z%lon, SHP, VALUESNODE, spread )
d665 1
a665 1
      call myValuesToField( z%time, SHP, VALUESNODE, spread )
d674 1
a674 1
      call myValuesToField( z%solartime, SHP, VALUESNODE, spread )
d683 1
a683 1
      call myValuesToField( z%solarzenith, SHP, VALUESNODE, spread )
d692 1
a692 1
      call myValuesToField( z%losangle, SHP, VALUESNODE, spread )
d705 1
a705 1
      call myValuesToField( z%frequencies, VALUESNODE, spread )
d868 1
a868 1
    use MLSSIGNALS_M, only: SIGNALS, DUMP, GETRADIOMETERINDEX, GETMODULEINDEX, &
a1070 1
    use INTRINSIC, only: LIT_INDICES
d1072 1
a1072 1
    use MLSSIGNALS_M, only: SIGNALS, DUMP, GETRADIOMETERNAME, GETMODULENAME, &
d1373 1
a1373 1
    use INTRINSIC, only: FIRST_LIT, LAST_AUTO_LIT, LIT_INDICES
a1381 1
    integer :: i
d1456 1
a1456 1
  subroutine myValuesToField_1d_dble ( tField, valuesNode, spread )
d1460 1
a1461 1
    integer, dimension(2) :: indices
a1463 1
    integer :: TestUnit                 ! Unit to use
a1466 1

d1492 1
a1492 1
  subroutine myValuesToField_2d_real ( tField, shp, valuesNode, spread )
d1497 1
a1501 1
    integer :: TestUnit                 ! Unit to use
d1537 1
a1537 1
  subroutine myValuesToField_2d_dble ( tField, shp, valuesNode, spread )
d1542 1
a1546 1
    integer :: TestUnit                 ! Unit to use
d1586 1
a1586 1
       "$Id: QuantityTemplates.f90,v 2.71 2012/08/08 20:00:21 vsnyder Exp $"
d1598 3
@


2.71
log
@Honest! I only changed some comments!
@
text
@d269 43
a311 16
    z%quantityType = a%quantityType
    z%logBasis = a%logBasis
    z%minValue = a%minValue
    z%noInstancesLowerOverlap = a%noInstancesLowerOverlap
    z%noInstancesUpperOverlap = a%noInstancesUpperOverlap
    z%badValue = a%badValue
    z%unit = a%unit
    z%verticalCoordinate = a%verticalCoordinate
    z%surfs = a%surfs
    z%instanceOffset = a%instanceOffset
    z%grandTotalInstances = a%grandTotalInstances
    z%phi = a%phi
    z%geodLat = a%geodLat
    z%lon = a%lon
    z%time = a%time
    z%solarTime = a%solarTime
d313 3
a315 2
    z%losAngle = a%losAngle
    z%frequencyCoordinate = a%frequencyCoordinate
a316 7
    z%lo = a%lo
    z%signal = a%signal
    z%sideband = a%sideband
    z%instrumentModule = a%instrumentModule
    z%radiometer = a%radiometer
    z%reflector = a%reflector
    z%molecule = a%molecule
d1594 1
a1594 1
       "$Id: QuantityTemplates.f90,v 2.70 2012/07/10 03:53:49 vsnyder Exp $"
d1606 3
@


2.70
log
@Use DeepCopy
@
text
@a68 1
    ! So far, the next two are used only for TScat quantities
d119 1
a119 1
    logical :: sharedHGrid              ! Set if horiz coords a pointer not a copy
d126 1
a126 1
    ! This is dimensioned (1, noInstances) for stacked quantities and
d152 1
a152 1
    real(r8) :: lo                      ! Local oscillator
d169 1
a169 1
    ! For irregular quantities, instead of using the we have these arrays to
d224 1
d226 1
d555 1
a555 1
  ! ---------------------------------- InflateQuantityTemplateDatabase --
d571 1
a571 1
  ! ----------------------------  ModifyQuantityTemplate   -----
d828 1
a828 1
  ! ----------------------------------------NullifyQuantityTemplate -----
d843 1
a843 1
  ! -------------------------------------  ReadAttributes_QuantityTemplate  -----
d1050 1
a1050 1
  ! -------------------------------------  WriteAttributes_QuantityTemplate  -----
d1119 1
a1119 1
  ! ---------------------------- CheckIntegrity_QuantityTemplate -------
d1352 1
a1352 1
  ! ---------------------------------------- GetHDF5AttrAsLitID -----
d1379 1
a1379 1
  ! ---------------------------------------- GetHDF5AttrAsStrID -----
d1401 1
a1401 1
  ! ---------------------------------------- myDisplayString -----
d1418 1
a1418 1
  ! ---------------------------------------- myGetString -----
d1437 1
a1437 1
  ! ---------------------------------------- myValuesToField -----
d1573 1
a1573 1
       "$Id: QuantityTemplates.f90,v 2.69 2012/02/24 21:11:50 pwagner Exp $"
d1585 3
@


2.69
log
@Include surfs when writing quantity attributes
@
text
@d254 1
d287 1
a287 4
    if ( associated ( a%frequencies ) ) then
      call Allocate_test ( z%frequencies, size(a%frequencies), 'z%frequencies', ModuleName )
      z%frequencies = a%frequencies
    end if
d1572 1
a1572 1
       "$Id: QuantityTemplates.f90,v 2.68 2012/02/23 00:08:35 vsnyder Exp $"
d1584 3
@


2.68
log
@Don't dump molecule names if quantity type is not vmr
@
text
@d1114 3
d1574 1
a1574 1
       "$Id: QuantityTemplates.f90,v 2.67 2012/02/13 23:22:31 pwagner Exp $"
d1586 3
@


2.67
log
@Print moleccule when dumping template
@
text
@d28 1
a28 1
  use INTRINSIC, only: L_NONE, LIT_INDICES, PHYQ_INDICES
d478 4
a481 2
      call output ( ' Molecule = ' )
      call myDisplayString ( lit_indices(quantity_template%molecule) )
d1571 1
a1571 1
       "$Id: QuantityTemplates.f90,v 2.66 2012/01/05 01:17:50 pwagner Exp $"
d1583 3
@


2.66
log
@Added ReadAttributes; improved WriteAttributes
@
text
@d476 1
a476 2
    if ( quantity_template%molecule + &
      &  quantity_template%instrumentModule /= 0 .and. .not. myNoL2CF ) then
d478 2
a479 4
      if ( quantity_template%molecule /= 0 ) then
        call output ( ' Molecule = ' )
        call myDisplayString ( lit_indices(quantity_template%molecule) )
      end if
d1569 1
a1569 1
       "$Id: QuantityTemplates.f90,v 2.65 2011/10/25 18:07:02 pwagner Exp $"
d1581 3
@


2.65
log
@Added WriteAttributes to attach qty template attributes when writing datasets
@
text
@d187 4
d845 40
d1053 2
a1054 1
  subroutine WriteAttributes_QuantityTemplate ( L2FileHandle, NAME, QuantityTemplate, NOL2CF )
d1062 1
a1062 1
    integer, intent(in) :: L2FileHandle
d1064 3
a1066 3
    type(QuantityTemplate_T), intent(in) :: QuantityTemplate
    logical, intent(in), optional :: NOL2CF  ! if TRUE => Don't WriteAttributes L2-specific
                                             !  stuff
d1072 2
a1073 2
    call myGetString ( QuantityTemplate%name, str, strip=.true. )
    call MakeHDF5Attribute ( L2FileHandle, name, 'TemplateName', str )
d1075 2
a1076 2
      call myGetString ( lit_indices(QuantityTemplate%quantityType), str, strip=.true. )
      call MakeHDF5Attribute ( L2FileHandle, name, 'tempQtyType', str )
d1078 9
a1086 9
    call MakeHDF5Attribute ( L2FileHandle, name, 'noInstances', QuantityTemplate%noInstances )
    call MakeHDF5Attribute ( L2FileHandle, name, 'noChans    ', QuantityTemplate%noChans     )
    call MakeHDF5Attribute ( L2FileHandle, name, 'noSurfs    ', QuantityTemplate%noSurfs     )
    call MakeHDF5Attribute ( L2FileHandle, name, 'coherent   ', QuantityTemplate%coherent     )
    call MakeHDF5Attribute ( L2FileHandle, name, 'stacked    ', QuantityTemplate%stacked     )
    call MakeHDF5Attribute ( L2FileHandle, name, 'regular    ', QuantityTemplate%regular     )
    call MakeHDF5Attribute ( L2FileHandle, name, 'logBasis    ', QuantityTemplate%logBasis     )
    call MakeHDF5Attribute ( L2FileHandle, name, 'minorFrame    ', QuantityTemplate%minorFrame     )
    call MakeHDF5Attribute ( L2FileHandle, name, 'badValue    ', QuantityTemplate%badValue     )
d1088 2
a1089 2
      call myGetString ( phyq_indices(QuantityTemplate%unit), str, strip=.true. )
      call MakeHDF5Attribute ( L2FileHandle, name, 'tempQtyUnit', str )
d1091 1
a1091 1
    call MakeHDF5Attribute ( L2FileHandle, name, 'instanceLen    ', QuantityTemplate%instanceLen     )
d1093 2
a1094 2
      call myGetString ( lit_indices(QuantityTemplate%verticalCoordinate), str, strip=.true. )
      call MakeHDF5Attribute ( L2FileHandle, name, 'verticalCoordinate', str )
d1096 9
a1104 9
    if ( QuantityTemplate%radiometer /= 0 .and. .not. myNoL2CF ) then
      call GetRadiometerName ( QuantityTemplate%radiometer, str )
      call MakeHDF5Attribute ( L2FileHandle, name, 'radiometer', str )
    end if
    if ( QuantityTemplate%molecule + &
      &  QuantityTemplate%instrumentModule /= 0 .and. .not. myNoL2CF ) then
      if ( QuantityTemplate%molecule /= 0 ) then
        call myGetString ( lit_indices(QuantityTemplate%molecule), str, strip=.true. )
        call MakeHDF5Attribute ( L2FileHandle, name, 'molecule', str )
d1106 3
a1108 3
      if ( QuantityTemplate%instrumentModule /= 0 ) then
        call GetModuleName ( QuantityTemplate%instrumentModule, str )
        call MakeHDF5Attribute ( L2FileHandle, name, 'tempQtyInstrumentModule', str )
d1111 3
a1113 3
    if ( QuantityTemplate%signal /= 0 ) then
      call GetSignalName ( QuantityTemplate%signal, str )
      call MakeHDF5Attribute ( L2FileHandle, name, 'signal', str )
d1351 49
d1572 1
a1572 1
       "$Id: QuantityTemplates.f90,v 2.64 2011/05/09 17:26:03 pwagner Exp $"
d1584 3
@


2.64
log
@Converted to using switchDetail
@
text
@d19 1
a19 1
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d21 3
a23 3
  use Expr_M, only: EXPR_CHECK
  use Intrinsic, only: PHYQ_Dimensionless
  use MLSCommon, only: NameLen
d25 4
a28 4
  use MLSKinds, only: R8, RV
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    & MLSMSG_Error, MLSMSG_Warning
  use Intrinsic, only: L_None, LIT_INDICES, PHYQ_INDICES
d30 4
a33 4
  use MLSStringLists, only: SWITCHDETAIL
  use MLSStrings, only: LOWERCASE, WRITEINTSTOCHARS
  use Output_m, only: NEWLINE, OUTPUT, OUTPUTNAMEDVALUE
  use String_Table, only: DISPLAY_STRING, GET_STRING
d187 4
d208 1
a208 1
    & NullifyQuantityTemplate, SetupNewQuantityTemplate
d385 5
a389 5
    use Intrinsic, only: lit_indices
    use MLSSignals_m, only: Signals, DUMP, GetRadiometerName, GetModuleName
    use Output_m, only: NewLine
    use String_Table, only: Display_String
    use VGridsDatabase, only: Dump
d1008 64
d1309 1
a1309 1
    use String_Table, only: How_Many_Strings
d1326 1
a1326 1
    use String_Table, only: How_Many_Strings
d1478 1
a1478 1
       "$Id: QuantityTemplates.f90,v 2.63 2011/03/31 18:30:02 pwagner Exp $"
d1490 3
@


2.63
log
@Corrected spelling in MODIFIABLEFIELDS
@
text
@d1001 1
a1001 1
    ! if ( index(switches, 'qtmp') > 0 ) call dump(qty, details=0, noL2CF=.true.)
d1410 1
a1410 1
       "$Id: QuantityTemplates.f90,v 2.62 2011/03/23 00:42:08 pwagner Exp $"
d1422 3
@


2.62
log
@Tried to fix some of the more obvious bugs in ModifyQuantityTemplate_allocate
@
text
@d209 1
a209 1
    & 'geodLat    ', &
d1410 1
a1410 1
       "$Id: QuantityTemplates.f90,v 2.61 2011/03/22 23:39:50 pwagner Exp $"
d1422 3
@


2.61
log
@May now change both shape and values of qtytemplate field
@
text
@d595 1
a595 1
        & trim(field) // " not a modifiable filed" )
d599 7
a605 5
      call deallocate_test( z%surfs, 'template surfs', &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
      call allocate_test ( z%surfs, shp(1), shp(2), &
        & "template surfs", &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
d608 7
a614 5
      call deallocate_test( z%phi, 'template phi', &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
      call allocate_test ( z%phi, shp(1), shp(2), &
        & "template phi", &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
d617 7
a623 5
      call deallocate_test( z%geodLat, 'template geodLat', &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
      call allocate_test ( z%geodLat, shp(1), shp(2), &
        & "template geodLat", &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
d626 7
a632 5
      call deallocate_test( z%lon, 'template lon', &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
      call allocate_test ( z%lon, shp(1), shp(2), &
        & "template lon", &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
d635 7
a641 5
      call deallocate_test( z%time, 'template time', &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
      call allocate_test ( z%time, shp(1), shp(2), &
        & "template time", &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
d644 7
a650 5
      call deallocate_test( z%solartime, 'template solartime', &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
      call allocate_test ( z%solartime, shp(1), shp(2), &
        & "template solartime", &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
d653 7
a659 5
      call deallocate_test( z%solarzenith, 'template solarzenith', &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
      call allocate_test ( z%solarzenith, shp(1), shp(2), &
        & "template solarzenith", &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
d662 7
a668 5
      call deallocate_test( z%losangle, 'template losangle', &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
      call allocate_test ( z%losangle, shp(1), shp(2), &
        & "template losangle", &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
d671 11
a681 5
      call deallocate_test( z%frequencies, 'template frequencies', &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
      call allocate_test ( z%frequencies, shp(1), &
        & "template frequencies", &
        & ModuleName // 'ModifyQuantityTemplate_allocate' )
d685 9
d1410 1
a1410 1
       "$Id: QuantityTemplates.f90,v 2.60 2011/03/15 22:43:52 pwagner Exp $"
d1422 3
@


2.60
log
@Added ModifyQuantityTemplate; defaults to private
@
text
@d21 2
d24 1
d29 1
d35 1
d183 1
d192 6
d205 12
a216 1

d565 100
a664 1
  ! ----------------------------  ModifyQuantityTemplate_array   -----
a677 2
    integer :: n1
    integer :: n2
d680 5
d692 1
a692 1
      case ( 'geodLat' )
d714 1
a714 1
      case ( 'geodLat' )
d736 1
a736 1
      case ( 'geodLat' )
a754 1
  ! ----------------------------  ModifyQuantityTemplate_sca   -----
d763 5
d773 1
a773 1
    case ( 'geodLat' )
d1243 132
d1379 1
a1379 1
       "$Id: QuantityTemplates.f90,v 2.59 2011/02/18 17:54:49 pwagner Exp $"
d1391 3
@


2.59
log
@Prevented crashes when run w/o l2cf
@
text
@d21 2
a22 1
  use MLSCommon, only: NameLen, R8
d27 1
a27 1
  use MLSStrings, only: WRITEINTSTOCHARS
d33 1
a33 1
  public
d177 4
d182 1
a182 1
  interface CheckIntegrity
d186 7
a192 1
  private :: CheckIntegrity_QuantityTemplate
d194 2
a195 1
contains ! =====     Public Procedures     =============================
a216 233
  ! ---------------------------- CheckIntegrity_QuantityTemplate -------
  logical function CheckIntegrity_QuantityTemplate ( qty, noError )
    type (QuantityTemplate_T), intent(in) :: QTY
    logical, intent(in), optional :: NOERROR

    ! Local variables
    integer :: NOINSTANCESOR1           ! Test value
    integer :: NOSURFSOR1               ! Test value

    integer :: MESSAGETYPE
    character ( len=132 ) :: NAME

    ! Executable code
    messageType = MLSMSG_Error
    if ( present ( noError ) ) then
      if ( noError ) messageType = MLSMSG_Warning
    end if

    ! Now check the integrity of the template
    if ( qty%coherent ) then
      noInstancesOr1 = 1
    else
      noInstancesOr1 = qty%noInstances
    end if

    if ( qty%stacked ) then
      noSurfsOr1 = 1
    else
      noSurfsOr1 = qty%noSurfs
    end if

    if ( qty%name > 0 ) then
      call myGetString ( qty%name, name, strip=.true. )
    else
      name = '<no name>'
    end if

    CheckIntegrity_QuantityTemplate = .true.

    ! Check the instances / overlap stuff
    if ( qty%noInstances < 0 ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad noInstances for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( ( qty%noInstancesLowerOverlap < 0 ) .or. &
      &  ( qty%noInstancesLowerOverlap > qty%noInstances ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Inappropriate noInstancesLowerOverlap for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( ( qty%noInstancesUpperOverlap < 0 ) .or. &
      &  ( qty%noInstancesUpperOverlap > qty%noInstances ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Inappropriate noInstancesUpperOverlap for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( qty%noInstancesLowerOverlap + qty%noInstancesUpperOverlap > &
      & qty%noInstances ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Too much overlap for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the surfaces stuff
    if ( qty%noSurfs < 0 ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad noSurfs for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the channels stuff
    if ( qty%noChans < 0 ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad noChans for quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the instanceLen
    if ( qty%regular .and. &
      & qty%InstanceLen /= qty%noSurfs * qty%noChans ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The quantity template '//trim(name)//' does not have the right instanceLen' )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the arrays are associated.  Note these have to be errors, as later
    ! tests will fail otherwise.
    if ( .not. associated ( qty%surfs ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have surfs associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( .not. associated ( qty%phi ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have phi associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( .not. associated ( qty%geodLat ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have geodLat associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( .not. associated ( qty%lon ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have lon associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( .not. associated ( qty%time ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have time associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( .not. associated ( qty%solarTime ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have solarTime associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( .not. associated ( qty%solarZenith ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have solarZenith associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( .not. associated ( qty%losAngle ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity template '//trim(name)// ' does not have losAngle associated' )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the array lower bounds
    if ( any ( lbound ( qty%surfs ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for surfs array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( any ( lbound ( qty%phi ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for phi array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( any ( lbound ( qty%geodLat ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for geodLat array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( lbound ( qty%lon ) /= (/1,1/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for lon array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( lbound ( qty%time ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for time array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( lbound ( qty%solarTime ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for solarTime array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( lbound ( qty%solarZenith ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for solarZenith array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( lbound ( qty%losAngle ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad lbound for losAngle array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check the array upper bounds
    if ( any ( ubound ( qty%surfs ) /= (/qty%noSurfs, noInstancesOr1/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for surfs array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( any ( ubound ( qty%phi ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for phi array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    if ( any ( ubound ( qty%geodLat ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for geodLat array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( ubound ( qty%lon ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for lon array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( ubound ( qty%time ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for time array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( ubound ( qty%solarTime ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for solarTime array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( ubound ( qty%solarZenith ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for solarZenith array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if
    if ( any ( ubound ( qty%losAngle ) /= (/noSurfsOr1, qty%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Bad ubound for losAngle array in quantity template '//trim(name) )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Check irregular stuff
    if ( .not. qty%regular ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The quantity '//trim(name)//' appears to be irregular' )
      CheckIntegrity_QuantityTemplate = .false.
    end if

    ! Could check channels stuff here, but not sure what to do.

  end function CheckIntegrity_QuantityTemplate

d542 63
a604 12
  ! ---------------------------------------- myDisplayString -----
  subroutine myDisplayString ( index, advance )
    ! Given a string index, display the string or an error message
    use String_Table, only: How_Many_Strings
    integer, intent(in) :: index
    character(len=*), intent(in), optional :: advance

    ! Executable code
    if ( index < 1 ) then
      call output ( '(string index < 1)' )
    else if ( index > how_many_strings() ) then ! How can an integer be a NaN ?????
      call output ( how_many_strings(), before='(string index > ', after=')' )
d606 55
a660 3
      call display_string ( index, advance )
    end if
  end subroutine myDisplayString
d662 3
a664 22
  ! ---------------------------------------- myGetString -----
  subroutine myGetString ( index, what, strip )
    ! Given a string index, Get the string or an error message
    use String_Table, only: How_Many_Strings
    integer, intent(in)           :: index
    character(len=*), intent(out) :: what
    logical, intent(in), optional :: strip

    ! Executable code
    if ( index < 1 ) then
      what = '(string index < 1)'
    else if ( index > how_many_strings() ) then
      call writeIntsToChars( how_many_strings(), what )
      what = '(string index >' // trim(what) // ')'
    else
      call get_string ( index, what, strip )
    end if
  end subroutine myGetString

  ! ----------------------------------------NullifyQuantityTemplate -----
  subroutine NullifyQuantityTemplate ( IntentionallyNotUsed )
    ! Given a quantity template, nullify all the pointers within it
d844 270
d1118 1
a1118 1
       "$Id: QuantityTemplates.f90,v 2.58 2010/09/25 01:16:35 vsnyder Exp $"
d1130 3
@


2.58
log
@Add ChanInds component, some cannonball polishing
@
text
@d26 3
a28 2
  use Output_m, only: NEWLINE, Output, outputNamedValue
  use String_Table, only: DISPLAY_STRING, Get_String
d237 1
a237 1
      call get_string ( qty%name, name, strip=.true. )
d511 1
a511 1
      call get_string ( qty%name, what )
d598 1
a598 1
    myNoL2CF = .false.
d651 1
a651 1
    call display_string ( lit_indices(quantity_template%verticalCoordinate), &
d714 1
a714 1
      if ( associated(quantity_template%frequencies) ) then
d720 1
a720 1
      if ( associated(quantity_template%frequencies) ) &
d780 19
d849 1
a849 1
      call get_string ( qty%name, what )
d985 1
a985 1
       "$Id: QuantityTemplates.f90,v 2.57 2010/09/17 00:04:54 pwagner Exp $"
d997 3
@


2.57
log
@Workaround for obscure crashes when called from outside mlsl2
@
text
@d36 1
a36 1
  private :: not_used_here 
d124 1
a124 1
    
d139 2
a141 2
    integer :: frequencyCoordinate ! An enumerated type, e.g. FG_USBFreq
    logical :: sharedFGrid              ! Set of frequencies are a pointer not a copy
d144 2
a145 1
                                                   ! (noChans)
d147 2
a149 1
    integer :: sideband                 ! Associated sideband -1, 0, +1
d181 1
a181 1
  
d208 1
a208 1
    
d215 1
a215 1
    
d268 1
a268 1
      CheckIntegrity_QuantityTemplate = .false.      
d275 1
a275 1
      CheckIntegrity_QuantityTemplate = .false.      
d282 1
a282 1
      CheckIntegrity_QuantityTemplate = .false.      
d298 1
a298 1
      CheckIntegrity_QuantityTemplate = .false.      
d304 1
a304 1
      CheckIntegrity_QuantityTemplate = .false.      
d310 1
a310 1
      CheckIntegrity_QuantityTemplate = .false.      
d315 1
a315 1
      CheckIntegrity_QuantityTemplate = .false.      
d320 1
a320 1
      CheckIntegrity_QuantityTemplate = .false.      
d325 1
a325 1
      CheckIntegrity_QuantityTemplate = .false.      
d330 1
a330 1
      CheckIntegrity_QuantityTemplate = .false.      
d335 1
a335 1
      CheckIntegrity_QuantityTemplate = .false.      
d342 1
a342 1
      CheckIntegrity_QuantityTemplate = .false.      
d348 1
a348 1
      CheckIntegrity_QuantityTemplate = .false.      
d354 1
a354 1
      CheckIntegrity_QuantityTemplate = .false.      
d359 1
a359 1
      CheckIntegrity_QuantityTemplate = .false.      
d364 1
a364 1
      CheckIntegrity_QuantityTemplate = .false.      
d369 1
a369 1
      CheckIntegrity_QuantityTemplate = .false.      
d374 1
a374 1
      CheckIntegrity_QuantityTemplate = .false.      
d379 1
a379 1
      CheckIntegrity_QuantityTemplate = .false.      
d386 1
a386 1
      CheckIntegrity_QuantityTemplate = .false.      
d392 1
a392 1
      CheckIntegrity_QuantityTemplate = .false.      
d398 1
a398 1
      CheckIntegrity_QuantityTemplate = .false.      
d403 1
a403 1
      CheckIntegrity_QuantityTemplate = .false.      
d408 1
a408 1
      CheckIntegrity_QuantityTemplate = .false.      
d413 1
a413 1
      CheckIntegrity_QuantityTemplate = .false.      
d418 1
a418 1
      CheckIntegrity_QuantityTemplate = .false.      
d423 1
a423 1
      CheckIntegrity_QuantityTemplate = .false.      
d490 1
a490 1
   
d534 1
a534 1
    
d536 2
d621 1
a621 1
    call output ('basis ' )  
d788 1
a788 1
    
d907 1
a907 1
    if ( qty%coherent ) then 
d965 1
a965 1
       "$Id: QuantityTemplates.f90,v 2.56 2010/08/31 02:05:10 vsnyder Exp $"
d977 3
@


2.56
log
@Deallocate channels component in DestroyQuantityTemplateContents
@
text
@d507 1
a507 1
    else
d961 1
a961 1
       "$Id: QuantityTemplates.f90,v 2.55 2010/02/04 23:08:00 vsnyder Exp $"
d973 3
@


2.55
log
@Remove USE or declaration for unused names
@
text
@d534 2
d961 1
a961 1
       "$Id: QuantityTemplates.f90,v 2.54 2009/09/25 02:42:07 vsnyder Exp $"
d973 3
@


2.54
log
@Added badValue to SetupNewQuantityTemplate, dump channels field of
quantity if it's associated.
@
text
@a440 1
    use Allocate_Deallocate, only: Test_Allocate
a442 1
    integer :: Stat
a493 1
    use Allocate_Deallocate, only: Test_Deallocate
a495 1
    integer :: Stat
a585 1
    integer :: I ! Loop counter
d959 1
a959 1
       "$Id: QuantityTemplates.f90,v 2.53 2009/06/23 18:25:42 pwagner Exp $"
d971 4
@


2.53
log
@Prevent Intel from optimizing ident string away
@
text
@d35 1
a35 1
       "$RCSfile: $"
d139 1
d683 6
a688 1
        call dump ( signals(quantity_template%signal) )
d788 2
a789 2
    ! All non-pointer compnents of course become undefined and so must
    ! be explicitly defined after the call
d796 1
a796 1
    & sharedVGrid, sharedHGrid, sharedFGrid )
d818 1
d876 1
d964 1
a964 1
       "$Id: read_apriori.f90 is it here $"
d976 3
@


2.52
log
@Remove AuxGrids -- didn't need them after all
@
text
@d35 1
a35 1
       "$RCSfile: QuantityTemplates.f90,v $"
d953 1
a954 1
!---------------------------- RCS Ident Info -------------------------------
d956 2
a957 3
       "$Id: QuantityTemplates.f90,v 2.51 2008/06/06 01:54:08 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d959 1
a959 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d961 1
d968 3
@


2.51
log
@Aux grids have to be vGrids, not indices in vGridsDatabase, else clients
will have to have the database.
Make sure to deallocate the auxGrids.  Dump auxGrids.
@
text
@a28 1
  use VGridsDatabase, only: VGrid_T
d62 1
a62 3
    integer :: noAux           ! Number of auxiliary coordinates.  The types
                               ! of auxiliary coordinates are not constrained,
                               ! but they are all specified by vGrids.
d108 1
a108 1
    ! dimensioned (noAux*noChans, noSurfs, noInstances), the SURFS coordinate
a148 7
    ! Auxiliary coordinates
    ! These are specified by vGrids.  noAux is the product of the sizes of
    ! the vGrids.

    type(VGrid_T), pointer :: AuxGrids(:) => NULL() ! vGrid indices

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
d452 1
a452 1
      & a%majorFrame, noAux=a%noAux )
a488 6
    if ( associated ( a%auxGrids ) ) then
      allocate ( z%auxGrids(size(a%auxGrids)), stat=stat )
      call test_allocate ( stat, 'QuantityTemplates', 'z%auxGrids', &
        & (/ 1 /), (/ size(a%auxGrids) /) )
      z%auxGrids = a%auxGrids
    end if
a547 6
    if ( associated(qty%auxGrids) ) then
      if ( verbose ) call output( 'About to deallocate auxGrids', advance='yes' )
      deallocate ( qty%auxGrids, stat=stat )
      call test_deallocate ( stat, 'QuantityTemplates', trim(what)//'%auxGrids' )
    end if

d604 3
a606 6
    call output ( '      NoInstances = ' )
    call output ( quantity_template%noInstances )
    call output ( ' NoSurfs = ' )
    call output ( quantity_template%noSurfs )
    call output ( ' noChans = ' )
    call output ( quantity_template%noChans, advance='yes' )
a657 5
    if ( associated(quantity_template%auxGrids) ) then
      do i = 1, size(quantity_template%auxGrids)
        call dump ( quantity_template%auxGrids(i), details )
      end do
    end if
d685 1
a685 1
        & call dump ( quantity_template%phi, '      Phi = ' )
d687 1
a687 1
        & call dump ( quantity_template%surfs, '      Surfs = ' )
d690 1
a690 1
          & call dump ( quantity_template%surfIndex, '      SurfIndex = ' )
d692 1
a692 1
          & call dump ( quantity_template%chanIndex, '      ChanIndex = ' )
d694 1
a694 1
          & call dump ( quantity_template%geodLat, '      GeodLat = ' )
d696 1
a696 1
          & call dump ( quantity_template%lon, '      Lon = ' )
d698 1
a698 1
          & call dump ( quantity_template%time, '      Time = ' )
d700 1
a700 1
          & call dump ( quantity_template%solarTime, '      SolarTime = ' )
d704 1
a704 1
          & call dump ( quantity_template%losAngle, '      LosAngle = ' )
d711 4
d790 1
a790 1
    & sharedVGrid, sharedHGrid, sharedFGrid, noAux )
a811 1
    integer, intent(in), optional :: noAux
a826 1
    qty%noAux = 1
d860 9
a868 10
    if ( present ( noAux) )        qty%noAux = noAux
    if ( present ( noChans) )      qty%noChans = noChans
    if ( present ( noInstances) )  qty%noInstances = noInstances
    if ( present ( noSurfs) )      qty%noSurfs = noSurfs
    if ( present ( regular) )      qty%regular = regular
    if ( present ( minorFrame) )   qty%minorFrame = minorFrame
    if ( present ( majorFrame) )   qty%majorFrame = majorFrame
    if ( present ( sharedVGrid ) ) qty%sharedVGrid = sharedVGrid
    if ( present ( sharedHGrid ) ) qty%sharedHGrid = sharedHGrid
    if ( present ( sharedFGrid ) ) qty%sharedFGrid = sharedFGrid
d894 1
a894 1
      qty%instanceLen = qty%noSurfs*qty%noChans*qty%noAux
d948 1
d956 1
a956 1
       "$Id: QuantityTemplates.f90,v 2.50 2008/06/05 02:05:53 vsnyder Exp $"
d960 1
d968 5
@


2.50
log
@Added Aux grids
@
text
@d29 1
d156 1
a156 1
    integer, pointer :: AuxGrids(:) => NULL() ! vGrid indices
d450 1
d453 1
d500 3
a502 1
      call allocate_test ( z%auxGrids, size(a%auxGrids), 'z%auxGrids', moduleName )
d511 1
d514 2
a516 1
    logical :: verbose
d521 3
a523 3
        call dump( qty )
    call output( 'About to destroy this quantity', advance='yes' )
    endif
d537 1
a537 1
      call deallocate_test ( qty%phi, trim(what) // "%phi", ModuleName )
d539 1
a539 1
      call deallocate_test ( qty%geodLat, trim(what) // "%geodLat", ModuleName )
d541 1
a541 1
      call deallocate_test ( qty%lon, trim(what) // "%lon", ModuleName )
d543 1
a543 1
      call deallocate_test ( qty%time, trim(what) // "%time", ModuleName )
d545 1
a545 1
      call deallocate_test ( qty%solarTime, trim(what) // "%solarTime", ModuleName )
d547 1
a547 1
      call deallocate_test ( qty%solarZenith, trim(what) // "%solarZenith", ModuleName )
d549 1
a549 1
      call deallocate_test ( qty%losAngle, trim(what) // "%losAngle", ModuleName )
d561 7
a567 1
      call deallocate_test ( qty%chanIndex, trim(what) // "%chanIndex", ModuleName )
d569 1
d601 1
d611 1
d683 5
d984 1
a984 1
       "$Id: QuantityTemplates.f90,v 2.49 2007/09/12 00:16:12 vsnyder Exp $"
d995 3
@


2.49
log
@Default initialize name component of QuantityTemplate_T to zero
@
text
@d62 3
d109 4
a112 4
    ! (noSurfs, noInstances) for incoherent ones.  Pretending the values
    ! are dimensioned (noChans, noSurfs, noInstances), the SURFS coordinate
    ! for the (:,i,j) values is surfs(i,1) for a coherent quantity or surfs(i,j)
    ! for an incoherent one.
d151 7
d457 5
a461 4
    call SetupNewquantityTemplate ( z, a%noInstances, a%noSurfs, a%noChans, &
      & a%coherent, a%stacked, a%regular, a%instanceLen, a%minorFrame, a%majorFrame )
    ! Copy each other component -- tedious, but can't do a shallow copy
    ! as would lose newly allocated arrays
d496 4
d795 1
a795 1
    & sharedVGrid, sharedHGrid, sharedFGrid )
d817 1
d833 2
a836 1
    qty%noChans = 1
d867 2
a870 1
    if ( present ( noChans) )      qty%noChans = noChans
d902 1
a902 1
      qty%instanceLen = qty%noSurfs*qty%noChans
d963 1
a963 1
       "$Id: QuantityTemplates.f90,v 2.48 2007/03/23 00:11:52 pwagner Exp $"
d974 3
@


2.48
log
@qtmp switch now warns while destroying quantitytemplates
@
text
@d49 1
a49 1
    integer :: name            ! Sub-rosa index of quantity name
d945 1
a945 1
       "$Id: QuantityTemplates.f90,v 2.47 2006/08/04 20:54:09 pwagner Exp $"
d956 3
@


2.47
log
@get_string for quantity name only if positive
@
text
@d25 2
a26 1
  use Output_m, only: NEWLINE, Output
d494 1
d497 5
d509 1
d514 1
d516 1
d518 1
d520 1
d522 1
d524 1
d526 1
d531 1
d536 1
d538 1
d550 1
d552 2
d555 1
d771 3
d945 1
a945 1
       "$Id: QuantityTemplates.f90,v 2.46 2006/08/04 01:54:16 vsnyder Exp $"
d956 3
@


2.46
log
@Use >0 instead of ==0 to test the name string
@
text
@d786 2
a788 2
    else
      call get_string ( qty%name, what )
d920 1
a920 1
       "$Id: QuantityTemplates.f90,v 2.45 2006/08/03 01:10:06 vsnyder Exp $"
d931 3
@


2.45
log
@Put l2cf names in leak track database
@
text
@d230 1
a230 1
    if ( qty%name /= 0 ) then
d785 1
a785 1
    if ( qty%name == 0 ) then
d920 1
a920 1
       "$Id: QuantityTemplates.f90,v 2.44 2006/03/22 23:49:20 vsnyder Exp $"
d931 3
@


2.44
log
@Change the name of a dummy argument, add some comments
@
text
@d445 1
a449 1
    z%name = a%name
d492 2
d495 6
d502 1
a502 1
      call deallocate_test ( qty%surfs, "qty%surfs", ModuleName )
d506 7
a512 7
      call deallocate_test ( qty%phi, "qty%phi", ModuleName )
      call deallocate_test ( qty%geodLat, "qty%geodLat", ModuleName )
      call deallocate_test ( qty%lon, "qty%lon", ModuleName )
      call deallocate_test ( qty%time, "qty%time", ModuleName )
      call deallocate_test ( qty%solarTime, "qty%solarTime", ModuleName )
      call deallocate_test ( qty%solarZenith, "qty%solarZenith", ModuleName )
      call deallocate_test ( qty%losAngle, "qty%losAngle", ModuleName )
d516 1
a516 1
      call deallocate_test ( qty%frequencies, "qty%frequencies", ModuleName )
d520 2
a521 2
      call deallocate_test ( qty%surfIndex, "qty%surfIndex", ModuleName )
      call deallocate_test ( qty%chanIndex, "qty%chanIndex", ModuleName )
d759 2
a760 1
  ! modifications), or created from scratch.
d782 2
d785 6
a790 1
    qty%name = 0
d880 1
a880 1
        & "qty%surfs", ModuleName )
d890 1
a890 1
        & "qty%phi", ModuleName )
d892 1
a892 1
        & "qty%geodLat", ModuleName )
d894 1
a894 1
        & "qty%lon", ModuleName )
d896 1
a896 1
        & "qty%time", ModuleName )
d898 1
a898 1
        & "qty%solarTime", ModuleName )
d900 1
a900 1
        & "qty%solarZenith", ModuleName )
d902 1
a902 1
        & "qty%losAngle", ModuleName )
d907 1
a907 1
        & "qty%surfIndex", ModuleName )
d909 1
a909 1
        & "qty%chanIndex", ModuleName )
d920 1
a920 1
       "$Id: QuantityTemplates.f90,v 2.43 2006/03/22 02:15:18 vsnyder Exp $"
d931 3
@


2.43
log
@Spiff up a dump
@
text
@d733 8
a740 5
  subroutine NullifyQuantityTemplate ( Q )
    ! Given a quantity template, nullify all the pointers associated with it
    type ( QuantityTemplate_T ), intent(out) :: Q

    ! Executable code not needed because Q is intent(out)
d904 1
a904 1
       "$Id: QuantityTemplates.f90,v 2.42 2006/01/05 03:47:28 vsnyder Exp $"
d915 3
@


2.42
log
@Add some stuff to the dump
@
text
@d105 4
a108 1
    ! (noSurfs, noInstances) for incoherent ones.
d119 3
a121 1
    ! (noSurfs, noInstances) for unstacked ones.
d538 1
d541 1
d545 5
a549 3
    !                                        ! >0   => Do dump arrays
    !                                        ! Default 1
    logical, intent(in), optional :: NOL2CF  ! if TRUE => Don't dump l2-specific
d610 1
a610 3
      call output ( quantity_template%vGridIndex, advance='yes' )
    else
      call newline
d612 2
a621 15
    if ( myDetails < 0 ) then
      call dump ( quantity_template%surfs, '  Surfs = ' )
      call dump ( quantity_template%phi, '      Phi = ' )
      call dump ( quantity_template%geodLat, '      GeodLat = ' )
      call dump ( quantity_template%lon, '      Lon = ' )
      call dump ( quantity_template%time, '      Time = ' )
      call dump ( quantity_template%solarTime, '      SolarTime = ' )
      call dump ( quantity_template%solarZenith, '      SolarZenith = ' )
      call dump ( quantity_template%losAngle, '      LosAngle = ' )
      if ( associated(quantity_template%frequencies) ) then
        call output ( '      FrequencyCoordinate = ' )
        call output ( quantity_template%frequencyCoordinate )
        call dump ( quantity_template%frequencies, ' Frequencies = ' )
      end if
    end if
a647 2
      if ( quantity_template%radiometer + &
        &  quantity_template%molecule /= 0 ) call newLine
d652 23
a674 4
      if ( associated(quantity_template%surfIndex) ) &
        & call dump ( quantity_template%surfIndex, '      SurfIndex = ' )
      if ( associated(quantity_template%chanIndex) ) &
        & call dump ( quantity_template%chanIndex, '      ChanIndex = ' )
d901 1
a901 1
       "$Id: QuantityTemplates.f90,v 2.41 2005/08/04 02:57:27 vsnyder Exp $"
d912 3
@


2.41
log
@Cannonball polishing
@
text
@d656 8
a663 6
      if ( associated(quantity_template%surfIndex) ) then
        call dump ( quantity_template%surfIndex, '      SurfIndex = ' )
      end if
      if ( associated(quantity_template%chanIndex) ) then
        call dump ( quantity_template%chanIndex, '      ChanIndex = ' )
      end if
d890 1
a890 1
       "$Id: QuantityTemplates.f90,v 2.40 2005/06/22 17:25:50 pwagner Exp $"
d901 3
@


2.40
log
@Reworded Copyright statement, moved rcs id
@
text
@d34 1
a34 1
       "$RCSfile: $"
d506 1
a506 1
    if ( .not. qty%regular) then
d552 4
a555 4
    call output ( ' quantityType = ' )
    call myDisplayString ( lit_indices(quantity_template%quantityType), &
      & advance='yes' )
    endif
d573 1
a573 1
    endif
d584 3
a586 3
    call output ( ' Unit = ' )
    call myDisplayString ( phyq_indices(quantity_template%unit) )
    endif
d589 1
a589 1
    call output ( ' sharedHGrid = ' )
d591 1
a591 1
    if ( quantity_template%sharedHGrid  ) then
d596 2
a597 2
    endif
    call output ( ' sharedVGrid = ' )
d599 1
a599 1
    if ( quantity_template%sharedVGrid  ) then
d604 2
a605 2
    endif
    call output ( ' sharedFGrid = ' )
d607 1
a607 1
    if ( quantity_template%sharedFGrid  ) then
d612 1
a612 1
    endif
d704 2
a705 1
    ! Given a quantity template, nullify all the pointers associated with it
d712 2
a713 2
    elseif ( index /= index ) then
      call output ( '(string index is NaN)' )
d716 1
a716 1
    endif
d724 2
a725 12
    ! Executable code
    nullify ( q%surfs )
    nullify ( q%phi )
    nullify ( q%geodLat )
    nullify ( q%lon )
    nullify ( q%time )
    nullify ( q%solarTime )
    nullify ( q%solarZenith )
    nullify ( q%losAngle )
    nullify ( q%frequencies )
    nullify ( q%surfIndex )
    nullify ( q%chanIndex )
d873 1
a873 1
    if ( .not. qty%regular) then        !
d888 1
a888 1
       "$Id: $"
d899 3
@


2.39
log
@qtmp switch now dumps in CreateQtyTemplateFromMLSCFInfo, not setup..
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology. ALL RIGHTS RESERVED.
! U.S. Government sponsorship under NASA Contract NAS7407 is acknowledged.
d32 3
a34 5
  !------------------------------- RCS Ident Info ------------------------------
  character(len=130), private :: id = & 
       "$Id: QuantityTemplates.f90,v 2.38 2004/08/16 17:07:11 pwagner Exp $"
  character(len=*), parameter, private :: ModuleName = &
    & "$RCSfile: QuantityTemplates.f90,v $"
d36 1
a36 1
  !-----------------------------------------------------------------------------
d895 5
d908 3
@


2.38
log
@qtmp switch dumps quantity template after setup
@
text
@d17 1
a17 1
  use Output_m, only: Output
d26 1
a26 1
       "$Id: QuantityTemplates.f90,v 2.37 2004/05/01 04:07:44 vsnyder Exp $"
d583 24
d884 1
a884 1
    if ( index(switches, 'qtmp') > 0 ) call dump(qty, details=0, noL2CF=.true.)
d897 3
@


2.37
log
@Rearranged some dumping stuff
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology. ALL RIGHTS RESERVED.
d19 1
d26 1
a26 1
       "$Id: QuantityTemplates.f90,v 2.36 2004/04/15 20:51:51 pwagner Exp $"
d860 1
a860 1

d873 3
@


2.36
log
@Added DUMP_QUANTITY_TEMPLATES (found in l2/dumper)
@
text
@d25 1
a25 1
       "$Id: QuantityTemplates.f90,v 2.35 2004/01/24 01:02:43 livesey Exp $"
d154 4
d523 2
a524 2
  ! ------------------------------------  DUMP_QUANTITY_TEMPLATES  -----
  subroutine DUMP_QUANTITY_TEMPLATES ( QUANTITY_TEMPLATES, DETAILS, NOL2CF )
d526 2
a527 1
    use MLSSignals_m, only: signals, DUMP, GetRadiometerName, GetModuleName
d529 1
a529 1
    type(QuantityTemplate_T), intent(in) :: QUANTITY_TEMPLATES(:)
d534 2
a535 1
    integer :: I, MyDetails                   !  stuff
d542 103
d649 2
a650 88
      call output ( ': Name = ' )
      call myDisplayString ( quantity_templates(i)%name )
      if ( .not. myNoL2CF ) then
      call output ( ' quantityType = ' )
      call myDisplayString ( lit_indices(quantity_templates(i)%quantityType), &
        & advance='yes' )
      endif
      call output ( '      NoInstances = ' )
      call output ( quantity_templates(i)%noInstances )
      call output ( ' NoSurfs = ' )
      call output ( quantity_templates(i)%noSurfs )
      call output ( ' noChans = ' )
      call output ( quantity_templates(i)%noChans, advance='yes' )
      call output ( '      ' )
      if ( .not. quantity_templates(i)%coherent ) call output ( 'in' )
      call output ( 'coherent ' )
      if ( .not. quantity_templates(i)%stacked ) call output ( 'non' )
      call output ( 'stacked ' )
      if ( .not. quantity_templates(i)%regular ) call output ( 'ir' )
      call output ( 'regular ' )
      if ( quantity_templates(i)%logBasis ) then
        call output ('log-')
      else
        call output ('linear-')
      endif
      call output ('basis ' )  
      if ( .not. quantity_templates(i)%minorFrame ) call output ( 'non' )
      call output ( 'minorFrame', advance='yes' )
      call output ( '      NoInstancesLowerOverlap = ' )
      call output ( quantity_templates(i)%noInstancesLowerOverlap )
      call output ( ' NoInstancesUpperOverlap = ' )
      call output ( quantity_templates(i)%noInstancesUpperOverlap, advance='yes' )
      call output ( '      BadValue = ' )
      call output ( quantity_templates(i)%badValue )
      if ( .not. myNoL2CF ) then
      call output ( ' Unit = ' )
      call myDisplayString ( phyq_indices(quantity_templates(i)%unit) )
      endif
      call output ( ' InstanceLen = ' )
      call output ( quantity_templates(i)%InstanceLen, advance='yes' )
      if ( myDetails < 0 ) then
        call dump ( quantity_templates(i)%surfs, '  Surfs = ' )
        call dump ( quantity_templates(i)%phi, '      Phi = ' )
        call dump ( quantity_templates(i)%geodLat, '      GeodLat = ' )
        call dump ( quantity_templates(i)%lon, '      Lon = ' )
        call dump ( quantity_templates(i)%time, '      Time = ' )
        call dump ( quantity_templates(i)%solarTime, '      SolarTime = ' )
        call dump ( quantity_templates(i)%solarZenith, '      SolarZenith = ' )
        call dump ( quantity_templates(i)%losAngle, '      LosAngle = ' )
        if ( associated(quantity_templates(i)%frequencies) ) then
          call output ( '      FrequencyCoordinate = ' )
          call output ( quantity_templates(i)%frequencyCoordinate )
          call dump ( quantity_templates(i)%frequencies, ' Frequencies = ' )
        end if
      end if
      if ( quantity_templates(i)%radiometer /= 0 .and. .not. myNoL2CF ) then
        call output ( '      Radiometer = ' )
        call GetRadiometerName ( quantity_templates(i)%radiometer, str )
        call output ( trim(str), advance='yes' )
      end if
      if ( quantity_templates(i)%molecule + &
        &  quantity_templates(i)%instrumentModule /= 0 .and. .not. myNoL2CF ) then
        call output ( '     ' )
        if ( quantity_templates(i)%molecule /= 0 ) then
          call output ( ' Molecule = ' )
          call myDisplayString ( lit_indices(quantity_templates(i)%molecule) )
        end if
        if ( quantity_templates(i)%instrumentModule /= 0 ) then
          call output ( ' Instrument Module = ' )
          call GetModuleName ( quantity_templates(i)%instrumentModule, str )
          call output ( trim(str) )
        end if
        call output ( '', advance = 'yes')
      end if
      if ( myDetails > 0 ) then
        if ( quantity_templates(i)%signal /= 0 ) then
          call dump ( signals( (/ quantity_templates(i)%signal /) ) )
        end if
        if ( quantity_templates(i)%radiometer + &
          &  quantity_templates(i)%molecule /= 0 ) &
          &  call output ( '', advance='yes' )
        if ( associated(quantity_templates(i)%surfIndex) ) then
          call dump ( quantity_templates(i)%surfIndex, '      SurfIndex = ' )
        end if
        if ( associated(quantity_templates(i)%chanIndex) ) then
          call dump ( quantity_templates(i)%chanIndex, '      ChanIndex = ' )
        end if
      end if
d652 1
d872 3
@


2.35
log
@Added CopyQuantityTemplate
@
text
@d12 1
d16 1
a16 1
  use Intrinsic, only: L_None
d18 1
a18 1
  use String_Table, only: Get_String
d25 1
a25 1
       "$Id: QuantityTemplates.f90,v 2.34 2003/07/01 19:29:00 livesey Exp $"
d519 112
d647 16
d848 3
@


2.34
log
@Added grandTotalInstances
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.33 2003/06/20 19:33:53 pwagner Exp $"
d415 55
d719 3
@


2.33
log
@Quanities now share grids stored separately in databses
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.32 2003/05/29 16:36:41 livesey Exp $"
d103 1
d664 3
@


2.32
log
@Added the reflector item
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.31 2003/01/14 21:35:53 vsnyder Exp $"
d40 1
a40 2
    integer :: Name            ! Sub-rosa index of quantity name
    integer :: id              ! Id code for quantity (for checking stuff)
a65 5

   ! At least in the beginning
   ! there will only be a few major frame quantities
   ! (These are vector quantities with no vert. coord. that share
   !  their other geoloc., e.g. lat and lon, with minor frame quants.)
a77 6
    ! Vertical coordinate

    integer :: verticalCoordinate ! The vertical coordinate used.  These
                                  ! are l_lits of the type t_VGridCoord
                                  ! defined in Init_Tables_Module.

a78 1

a81 1
    real(r8) :: scaleFactor   ! Scale factor used when printing etc.
a85 1

d88 6
a93 2
    ! Give the vertical coordinates

d100 4
a103 1

a109 1

a116 6
    ! These optional integer arrays are used for minor frame quantities,
    ! to index the major frames.

    integer, dimension(:), pointer :: mafIndex => NULL() ! (noInstances) index in l1b file
    integer, dimension(:), pointer :: mafCounter => NULL() ! (noInstances) from l1b

a122 1

d124 2
d128 1
a128 3

    real(r8) :: lo     ! Local oscillator (optional)

a151 4
  ! Incrementing counter used to set the id field of a quantity template:

  integer, save, public :: quantityTemplateCounter = 0

a402 36
    ! Check stuff specific for major/minor frame stuff
    if ( qty%minorFrame .or. qty%majorFrame ) then
      if ( .not. associated ( qty%mafIndex ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'The quantity template '//trim(name)// ' does not have mafIndex associated' )
        CheckIntegrity_QuantityTemplate = .false.      
      end if
      if ( .not. associated ( qty%mafCounter ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'The quantity template '//trim(name)// ' does not have mafCounter associated' )
        CheckIntegrity_QuantityTemplate = .false.      
      end if

      if ( lbound ( qty%mafIndex, 1 ) /= 1 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Bad lbound for mafIndex' )
        CheckIntegrity_QuantityTemplate = .false.      
      end if
      if ( lbound ( qty%mafCounter, 1 ) /= 1 ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Bad lbound for mafCounter' )
        CheckIntegrity_QuantityTemplate = .false.      
      end if

      if ( ubound ( qty%mafIndex, 1 ) /= qty%noInstances ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Bad ubound for mafIndex' )
        CheckIntegrity_QuantityTemplate = .false.      
      end if
      if ( ubound ( qty%mafIndex, 1 ) /= qty%noInstances ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'Bad ubound for mafIndex' )
        CheckIntegrity_QuantityTemplate = .false.      
      end if
    end if

a415 3

  ! Destroy a quantity template

a418 3
    ! Local variables
    character (LEN=32) :: quantityNameStr

d420 3
d424 8
a431 39
    if ( DEEBUG ) then
      call output('Destroying Quantity template contents', advance='yes')
      call output('minor frame? ', advance='no')
      call output(qty%minorFrame, advance='no')
      call output('   major frame? ', advance='no')
      call output(qty%majorFrame, advance='no')
      call output('   template  name ', advance='no')
      if ( qty%name < 1 ) then
        call output('   (unnamed) ', advance='yes')
      else
        call get_string(qty%name, quantityNameStr, strip=.true., noerror=.true.)
        call output(trim(quantityNameStr), advance='yes')
      endif
    endif
    if ( DEEBUG ) call output('Deallocating qty%surfs', advance='no')
    call deallocate_test ( qty%surfs, "qty%surfs", ModuleName )
    if ( DEEBUG ) call output('  qty%phi', advance='no')
    call deallocate_test ( qty%phi, "qty%phi", ModuleName )
    if ( DEEBUG ) call output('  qty%geodLat', advance='no')
    call deallocate_test ( qty%geodLat, "qty%geodLat", ModuleName )
    if ( DEEBUG ) call output('  qty%lon', advance='no')
    call deallocate_test ( qty%lon, "qty%lon", ModuleName )
    if ( DEEBUG ) call output('  qty%time', advance='no')
    call deallocate_test ( qty%time, "qty%time", ModuleName )
    if ( DEEBUG ) call output('  qty%solartime', advance='no')
    call deallocate_test ( qty%solarTime, "qty%solarTime", ModuleName )
    if ( DEEBUG ) call output('  qty%solarzenith', advance='no')
    call deallocate_test ( qty%solarZenith, "qty%solarZenith", ModuleName )
    if ( DEEBUG ) call output('  qty%losAngle', advance='no')
    call deallocate_test ( qty%losAngle, "qty%losAngle", ModuleName )
    if ( DEEBUG ) call output('  qty%frequencies', advance='yes')
    call deallocate_test ( qty%frequencies, "qty%frequencies", ModuleName )

!    if (qty%minorFrame .or. qty%majorFrame) then
    if ( qty%minorFrame ) then
      if ( DEEBUG ) call output('Deallocating qty%MAFIndex', advance='no')
      call deallocate_test ( qty%MAFIndex, "qty%MAFIndex", ModuleName )
      if ( DEEBUG ) call output('  qty%MAFCounter', advance='yes')
      call deallocate_test ( qty%MAFCounter, "qty%MAFCounter", ModuleName )
d434 5
a438 2
    if (.NOT. qty%regular) then
      if ( DEEBUG ) call output('Deallocating qty%surfIndex', advance='no')
a439 1
      if ( DEEBUG ) call output('  qty%chanIndex', advance='yes')
a441 1

d445 1
a445 5
  subroutine DestroyQuantityTemplateDatabase ( database, &
    & ignoreMinorFrame, ignoreMajorFrame )

  ! Destroy a quantity template database

a447 2
    logical, intent(in), optional :: ignoreMinorFrame
    logical, intent(in), optional :: ignoreMajorFrame
a450 7
    logical :: myIgnoreMinorFrame
    logical :: myIgnoreMajorFrame
    
    myIgnoreMinorFrame = .false.
    if ( present ( ignoreMinorFrame ) ) myIgnoreMinorFrame = ignoreMinorFrame
    myIgnoreMajorFrame = .false.
    if ( present ( ignoreMajorFrame ) ) myIgnoreMajorFrame = ignoreMajorFrame
d453 2
a454 8
      do qtyIndex = 1, SIZE(database)
        if ( &
          & .not. ( &
            & (database(qtyIndex)%minorFrame .and. myIgnoreMinorFrame) &
            & .or. &
            & (database(qtyIndex)%majorFrame .and. myIgnoreMajorFrame) &
            & ) &
          & ) call DestroyQuantityTemplateContents ( database(qtyIndex) )
a491 2
    nullify ( q%mafIndex )
    nullify ( q%mafCounter )
d498 3
a500 2
  subroutine SetupNewQuantityTemplate ( qty, source, noInstances, noSurfs, &
    & noChans, coherent, stacked, regular, instanceLen, minorFrame, majorFrame )
a508 1
    type (QuantityTemplate_T), optional, intent(in) :: source ! Template
d518 3
d527 33
d561 10
a570 1
    call destroyQuantityTemplateContents ( qty ) ! Avoid memory leaks
a571 36
    ! First, if we have a template setup according to that
    if (present(source)) then
      qty%noInstances = source%noInstances
      qty%noSurfs = source%noSurfs
      qty%noChans = source%noChans
      qty%coherent = source%coherent
      qty%stacked = source%stacked
      qty%regular = source%regular
      qty%minorFrame = source%minorFrame
      qty%majorFrame = source%majorFrame
      qty%logBasis = source%logBasis
      qty%instanceLen =  source%instanceLen
      qty%verticalCoordinate = source%verticalCoordinate
      qty%frequencyCoordinate = source%frequencyCoordinate
    else ! We have no template, setup a very bare quantity
      qty%noInstances = 1
      qty%noSurfs = 1
      qty%noChans = 1
      qty%coherent = .TRUE.
      qty%stacked = .TRUE.
      qty%regular = .TRUE.
      qty%logBasis = .FALSE.
      qty%minorFrame = .FALSE.
      qty%majorFrame = .FALSE.
      qty%instanceLen = 1
      qty%verticalCoordinate=l_none
      qty%frequencyCoordinate=l_none
    end if

    ! Now, see if the user asked for modifications to this
    if ( present(noInstances) ) qty%noInstances = noInstances
    if ( present(noSurfs) ) qty%noSurfs = noSurfs
    if ( present(noChans) ) qty%noChans = noChans
    if ( present(regular) ) qty%regular = regular
    if ( present(minorFrame) ) qty%minorFrame = minorFrame
    if ( present(majorFrame) ) qty%majorFrame = majorFrame
d599 1
a599 2
    ! Now we allocate all the arrays we're going to need

d613 6
a618 3

    call allocate_test ( qty%surfs, qty%noSurfs, noInstancesToAllocate, &
      & "qty%surfs", ModuleName )
d622 3
a624 28
    call allocate_test ( qty%phi, noSurfsToAllocate, qty%noInstances, &
      & "qty%phi", ModuleName )

    call allocate_test ( qty%geodLat, noSurfsToAllocate, qty%noInstances, &
      & "qty%geodLat", ModuleName )

    call allocate_test ( qty%lon, noSurfsToAllocate, qty%noInstances, &
      & "qty%lon", ModuleName )

    call allocate_test ( qty%time, noSurfsToAllocate, qty%noInstances, &
      & "qty%time", ModuleName )

    call allocate_test ( qty%solarTime, noSurfsToAllocate, qty%noInstances, &
      & "qty%solarTime", ModuleName )

    call allocate_test ( qty%solarZenith, noSurfsToAllocate, qty%noInstances, &
      & "qty%solarZenith", ModuleName )

    call allocate_test ( qty%losAngle, noSurfsToAllocate, qty%noInstances, &
      & "qty%losAngle", ModuleName )

    ! Now some other stuff to allocate

    if ( qty%minorFrame .or. qty%majorFrame ) then
      call allocate_test ( qty%MAFIndex, qty%noInstances, &
        & "qty%MAFIndex", ModuleName )
      call allocate_test ( qty%MAFCounter, qty%noInstances, &
        & "qty%MAFCounter", ModuleName )
d626 14
a639 1
      nullify ( qty%MAFIndex, qty%MAFCounter )
d642 1
a642 1
    if (.NOT. qty%regular) then
a650 3
    ! Increment the id counter and set the id field
    quantityTemplateCounter = quantityTemplateCounter + 1
    qty%id = quantityTemplateCounter
d663 3
@


2.31
log
@Add EPOCH and a comment about it in 'time' component
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.30 2003/01/08 21:39:55 livesey Exp $"
d154 1
d777 3
@


2.30
log
@Minor change in irregular quantity handling
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.29 2002/11/27 01:06:26 livesey Exp $"
d34 2
d121 1
a121 1
    real(r8), dimension(:,:), pointer :: time => NULL()
d776 3
@


2.29
log
@Better handling of major frame quantities
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.28 2002/11/22 12:54:34 mjf Exp $"
d687 6
a692 2
    if ( (.NOT. qty%regular) .AND. (present(instanceLen)) ) then
      qty%instanceLen = instanceLen
d774 3
@


2.28
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.27 2002/10/08 00:09:13 pwagner Exp $"
d737 1
a737 1
    if ( qty%minorFrame ) then
d770 4
@


2.27
log
@Added idents to survive zealous Lahey optimizer
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.26 2002/09/24 21:36:42 livesey Exp $"
d583 21
d770 3
@


2.26
log
@Added minValue
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.25 2002/08/28 20:42:11 livesey Exp $"
d27 1
d740 4
d749 3
@


2.25
log
@Added InflateQuantityTemplateDatabase
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.24 2002/07/22 03:26:05 livesey Exp $"
d73 1
d744 3
@


2.24
log
@Added checkIntegrity
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.23 2002/07/01 23:51:07 vsnyder Exp $"
d565 16
d743 3
@


2.23
log
@Plug a memory leak
@
text
@d14 1
a14 1
    & MLSMSG_Error
d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.22 2001/10/12 23:09:25 pwagner Exp $"
d167 7
d196 269
d727 3
@


2.22
log
@More debugging statements
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.21 2001/10/03 17:42:27 pwagner Exp $"
d298 1
a298 1
    type (QuantityTemplate_T), intent(out) :: qty ! Result
d317 2
d451 3
@


2.21
log
@reset DEEBUG to FALSE
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.20 2001/10/02 23:12:50 pwagner Exp $"
d208 7
a214 3
      call output('   template  name', advance='no')
      call get_string(qty%name, quantityNameStr, strip=.true.)
      call output(trim(quantityNameStr), advance='yes')
d216 1
d218 1
d220 1
d222 1
d224 1
d226 1
d228 1
d230 1
d232 1
d237 1
d239 1
d244 1
d246 1
d449 3
@


2.20
log
@More chi^2 fixes
@
text
@d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.19 2001/09/17 21:59:26 livesey Exp $"
d29 1
a29 1
  logical, parameter, private :: DEEBUG = .TRUE.           ! Usually FALSE
d432 3
@


2.19
log
@Removed allocate of frequencies, it's deferred to later in the code
@
text
@d17 1
d24 1
a24 1
       "$Id: QuantityTemplates.f90,v 2.18 2001/09/13 19:59:43 pwagner Exp $"
d29 2
d198 1
d202 10
d222 2
a223 1
    if (qty%minorFrame .or. qty%majorFrame) then
d432 3
@


2.18
log
@Added majorframe as possible quantity type
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.17 2001/07/31 23:39:12 dwu Exp $"
a385 3
    call allocate_test ( qty%frequencies, qty%noChans, &
        & "qty%frequencies", ModuleName )

d417 3
@


2.17
log
@allocate and deallocate qty%frequencies
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.16 2001/07/11 21:41:16 livesey Exp $"
d62 6
d208 1
a208 1
    if (qty%minorFrame) then
d221 2
a222 1
  subroutine DestroyQuantityTemplateDatabase ( database, ignoreMinorFrame )
d229 1
d234 1
d238 2
d243 7
a249 2
        if (.not. (database(qtyIndex)%minorFrame .and. myIgnoreMinorFrame) ) &
          &   call DestroyQuantityTemplateContents ( database(qtyIndex) )
d259 1
a259 1
    & noChans, coherent, stacked, regular, instanceLen, minorFrame )
d277 1
d294 1
d308 1
d320 1
d420 3
@


2.16
log
@Made quantityTemplateCounter public
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.15 2001/07/02 17:25:30 livesey Exp $"
d200 1
d366 3
d400 3
@


2.15
log
@Some changes to comments, following walk through
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.14 2001/05/23 20:38:35 livesey Exp $"
d156 1
a156 1
  integer, save, private :: quantityTemplateCounter = 0
d396 3
@


2.14
log
@Updated a comment
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.13 2001/04/23 23:52:16 livesey Exp $"
d81 1
a81 2
                              ! an l_lit of the type t_units in
                              ! Init_Tables_Module.
d116 2
a117 1
    integer, dimension(:), pointer :: mafIndex => NULL(), mafCounter => NULL()
d142 1
a142 1
                        ! lits of type t_molecule in Init_Tables_Module.)
d396 3
@


2.13
log
@Sorry, should have put comment in one below.  Now has optional ignoreMinorFrame
argument to DestroyQuantityTemplateDatabase
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.12 2001/04/23 23:50:41 livesey Exp $"
d140 1
a140 1
    integer :: radiometer       ! For ptan etc. e.g. L_R1A
d396 4
@


2.12
log
@*** empty log message ***
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.11 2001/04/12 21:43:06 livesey Exp $"
d214 1
a214 1
  subroutine DestroyQuantityTemplateDatabase ( database, ingnoreMinorFrame )
d231 1
a231 1
        if ( .not. (database(qtyIndex)%minorFrame .and. myIgnoreMinorFrame) &
d396 3
@


2.11
log
@Added sideband field
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.10 2001/04/10 22:37:49 vsnyder Exp $"
d214 1
a214 1
  subroutine DestroyQuantityTemplateDatabase ( database )
d220 1
d224 4
d231 2
a232 1
        call DestroyQuantityTemplateContents ( database(qtyIndex) )
d396 3
@


2.10
log
@Fix a type
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.9 2001/03/24 00:31:12 pwagner Exp $"
d133 1
d390 3
@


2.9
log
@USEs output in case we replace MLSMessage with output in additem..
@
text
@d16 1
a16 1
   USE output_m, only: output
d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.8 2001/03/17 02:23:18 livesey Exp $"
d389 3
@


2.8
log
@Added log basis field
@
text
@d16 1
d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.7 2001/03/15 20:20:59 vsnyder Exp $"
d389 3
@


2.7
log
@Correct the description of 'InstrumentModule'
@
text
@d22 1
a22 1
       "$Id: QuantityTemplates.f90,v 2.6 2001/03/02 01:34:03 livesey Exp $"
d61 3
d268 1
d279 1
d388 3
@


2.6
log
@New signals stuff
@
text
@d22 1
a22 1
       "$Id: QuantityTemplates.f90,v 2.5 2001/02/23 17:47:01 livesey Exp $"
d134 1
a134 1
    integer :: instrumentModule ! Literal, L_GHz, L_THz or L_None
d383 3
@


2.5
log
@Nullified pointers.
@
text
@a14 1
  use MLSSignalNomenclature, only: MLSSignal_T
d22 1
a22 1
       "$Id: QuantityTemplates.f90,v 2.4 2001/02/14 00:12:34 livesey Exp $"
d128 2
a129 1
    type (MLSSignal_T), dimension(:), pointer :: signal => NULL() ! (optional)
d383 3
@


2.4
log
@Removed firstIndexChannel
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.3 2001/02/09 00:38:56 livesey Exp $"
d90 1
a90 1
    real(r8), dimension(:,:), pointer :: surfs
d97 1
a97 1
    real(r8), dimension(:,:), pointer :: phi
d104 6
a109 2
    real(r8), dimension(:,:), pointer :: geodLat, lon, time, &
      & solarTime, solarZenith, losAngle
d124 1
a124 1
    real(r8), dimension(:), pointer :: frequencies ! List of frequencies
d144 2
a145 2
    integer, dimension(:,:), pointer :: surfIndex
    integer, dimension(:,:), pointer :: chanIndex
d383 3
@


2.3
log
@Various changes
@
text
@d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.2 2000/12/04 23:43:59 vsnyder Exp $"
a87 5
    ! Define how the data in each instance are stored, whether by
    ! surface or channels (regular quantities only).

    logical :: firstIndexChannel

d137 2
a138 3
    ! For irregular quantities, instead of using the firstIndexChannel
    ! information, we have these arrays to help us navigate around the
    ! quantity.
d227 1
a227 2
    & noChans, coherent, stacked, regular, instanceLen, firstIndexChannel, &
    & minorFrame )
a243 1
    logical, intent(in), optional :: firstIndexChannel
a305 4
    ! Deal with the firstindexchannel argument
    qty%firstIndexchannel = .TRUE.
    if ( present(firstindexchannel) ) qty%firstIndexchannel = firstindexchannel

d379 3
@


2.2
log
@Move more of addItemToDatabase into the include
@
text
@d16 1
d23 1
a23 1
       "$Id: QuantityTemplates.f90,v 2.1 2000/10/13 00:00:37 vsnyder Exp $"
a27 20
  ! This set of integers defines how quantities are broken into `channels'
  ! These are known as FGrid information.  Rather than have an FGrid module,
  ! for the moment we'll just handle this information here. This may be split
  ! out in later versions of the code.

  integer, parameter :: NoFGTypes=5
  character (len=24), parameter, dimension(NoFGTypes) :: &
    & FGTypeNames= (/ &
    & "No frequency dependence ", &
    & "MLS Channel             ", &
    & "Intermediate Frequecny  ", &
    & "Upper Sideband Frequency", &
    & "Lower Sideband Frequency"/)
  integer, parameter :: FG_Invalid=0
  integer, parameter :: FG_None=1
  integer, parameter :: FG_InstrumentChannel=2
  integer, parameter :: FG_IntermediateFrequency=3
  integer, parameter :: FG_USBFrequency=4
  integer, parameter :: FG_LSBFrequency=5

d135 2
a136 1
    integer :: radiometerIndex ! Which radiometer does a ptan qty refer to?
d269 3
a271 1
      qty%instanceLen = source%instanceLen
d281 2
d391 3
a402 2


@


2.1
log
@Moved from mlspgs/l2 to mlspgs/lib
@
text
@d22 1
a22 1
       "$Id: QuantityTemplates.f90,v 2.0 2000/09/05 18:57:04 ahanzel Exp $"
a191 1
    database(newSize) = item
d405 3
@


1.13
log
@moved to mlspgs/l2
@
text
@d5 1
a5 1
MODULE QuantityTemplates         ! Quantities within vectors
d8 8
a15 4
  USE MLSCommon
  USE MLSMessageModule
  USE MLSSignalNomenclature
  USE VGrid
d17 2
a18 2
  IMPLICIT NONE
  PUBLIC
a19 1
  PRIVATE :: Id,ModuleName
d21 4
a24 3
  CHARACTER(LEN=130) :: id = & 
       "$Id: QuantityTemplates.f90,v 1.12 2000/06/19 23:57:41 lungu Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: QuantityTemplates.f90,v $"
a26 25
  ! This module defines the `quantities' that make up vectors and their
  ! template information.

  ! This set of integers define various families that quantities can fall into
  ! No doubt more will be added.

  INTEGER, PARAMETER :: NoQTYTypes=7
  CHARACTER (LEN=12), PARAMETER, DIMENSION(NoQtyTypes) :: &
       & QTYTypeNames= (/ &
       & "TEMPERATURE ", &
       & "VMR         ", &
       & "RADIANCE    ", &
       & "PTAN        ", &
       & "BASELINE    ", &
       & "EXTINCTION  ", &
       & "GPH         "/)
  INTEGER, PARAMETER :: QTY_Invalid=0
  INTEGER, PARAMETER :: QTY_Temperature=1
  INTEGER, PARAMETER :: QTY_Vmr=2
  INTEGER, PARAMETER :: QTY_Radiance=3
  INTEGER, PARAMETER :: QTY_Ptan=4
  INTEGER, PARAMETER :: QTY_Baseline=5
  INTEGER, PARAMETER :: QTY_Extinction=6
  INTEGER, PARAMETER :: QTY_Gph=7

d32 16
a47 14
  INTEGER, PARAMETER :: NoFGTypes=5
  CHARACTER (LEN=24), PARAMETER, DIMENSION(NoFGTypes) :: &
       & FGTypeNames= (/ &
       & "No frequency dependence ", &
       & "MLS Channel             ", &
       & "Intermediate Frequecny  ", &
       & "Upper Sideband Frequency", &
       & "Lower Sideband Frequency"/)
  INTEGER, PARAMETER :: FG_Invalid=0
  INTEGER, PARAMETER :: FG_None=1
  INTEGER, PARAMETER :: FG_InstrumentChannel=2
  INTEGER, PARAMETER :: FG_IntermediateFrequency=3
  INTEGER, PARAMETER :: FG_USBFrequency=4
  INTEGER, PARAMETER :: FG_LSBFrequency=5
d49 1
a49 1
  ! First we'll define some global parameters and data types.
d51 1
a51 1
  TYPE QuantityTemplate_T
d53 2
a54 1
     ! First some administrative stuff
d56 3
a58 2
     CHARACTER (LEN=NameLen) :: name ! Simple name for quantity
     INTEGER :: id              ! Id code for quantity (for checking stuff)
d60 1
a60 2
     ! This integer is an enumerated type describing what kind of quantity this
     ! is. e.g. QTY_Temperature
d62 1
a62 1
     INTEGER :: quantityType
d64 3
a66 1
     ! Now the dimensions of this quantity
d68 1
a68 3
     INTEGER :: noSubVectors    ! Number of subVectors in this quantity
     INTEGER :: noSurfs         ! Number of surfaces per subvector 
     INTEGER :: noChans         ! Number of channels
d70 3
a72 1
     ! Now some flags describing the quantity
d74 4
a77 3
     LOGICAL :: coherent        ! Do subvectors have same vertical coordiantes?
     LOGICAL :: stacked         ! Are subvectors true vertical profiles?
     LOGICAL :: regular         ! Are all channels/heights represented
d79 1
a79 4
     ! This next one allows software using the vector quantities to be somewhat
     ! lazy and, for example, avoid interpolation.  Minor frame quantities are
     ! incoherent and unstacked, but may be regular or irregular.  However, not
     ! all incoherent unstacked quantities are minor frame quantities.
d81 2
a82 1
     LOGICAL :: minorFrame      ! Is this a minor frame quantity.
d84 2
a85 2
     ! This information describes how much of the data is in the overlap
     ! regions if any.
d87 1
a87 2
     INTEGER :: noSubVectorsLowerOverlap
     INTEGER :: noSubVectorsUpperOverlap
d89 3
a91 1
     ! Now the vertical coordinate
d93 1
a93 1
     INTEGER :: verticalCoordinate ! The vertical coordinate used
d95 5
a99 1
     ! Now some misc. information
d101 3
a103 3
     REAL(r8) :: badValue ! Value used to flag bad/missing data
     CHARACTER(LEN=NameLen) :: unit ! Unit quantity is in when scaled as below
     REAL(r8) :: scaleFactor ! Scale factor used when printing etc.
d105 1
a105 3
     ! Now, for regular quantities the number of elements each subvector is
     ! simply noSurfs*noChans.  For irregular ones it is less, but it is
     ! constant from subvector to subvector, this is that number
d107 2
a108 1
     INTEGER :: subVectorLen
d110 1
a110 2
     ! Now we define how the data in each subvector is stored whether by
     ! surface or channels (regular quantities only).
d112 1
a112 1
     LOGICAL :: firstIndexChannel
d114 1
a114 1
     ! Now we give the vertical coordinates
d116 2
a117 1
     REAL(r8), DIMENSION(:,:), POINTER :: surfs
d119 1
a119 2
     ! This is dimensioned (noSurfs,1) for coherent quantities and (noSurfs
     !,noSubVectors) for incoherent ones.
d121 1
a121 1
     ! Now the horizontal coordinates
d123 4
a126 1
     REAL(r8), DIMENSION(:,:), POINTER :: phi
d128 2
a129 3
     ! This is dimensioned (1,noSubVectors) for stacked quantities and (noSurfs
     !,noSubVectors) for unstacked ones.  These other coordinates are
     ! dimensioned in the same manner.
d131 2
a132 2
     REAL(r8), DIMENSION(:,:), POINTER :: geodLat,lon,time, &
          & solarTime,solarZenith,losAngle
d134 1
a134 2
     ! These integer arrays are used for minor frame quantities to index the
     ! major frames.
d136 3
a138 1
     INTEGER, DIMENSION(:), POINTER :: mafIndex,mafCounter
d140 2
a141 3
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     ! For quantities containing `channels' the following information may or
     ! may not be useful.
d143 3
a145 2
     ! Some quantities are on abritrary freqency grids, these quantities refer
     ! to those.
d147 1
a147 3
     INTEGER :: frequencyCoordinate ! An enumerated type, e.g. FG_USBFreq
     REAL(r8), DIMENSION(:), POINTER :: frequencies 
     ! List of frequencies (noChans)
d149 4
a152 6
     REAL(r8) :: lo     ! Local oscillator (optional)
     
     TYPE (MLSSignal_T), DIMENSION(:), POINTER :: signal ! Signal (optional)
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     ! Some families of quantities require special additional information.
     ! This is given here if needed.
d154 3
a156 4
     INTEGER :: radiometerIndex ! Which radiometer does a ptan qty refer to?
     CHARACTER(LEN=NameLen) :: molecule ! What molecule does this refer to?
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
d158 1
a158 3
     ! Now for irregular quantities, instead of using the firstIndexChannel
     ! information, we have these arrays to help us navigate around the
     ! quantity.
d160 3
a162 4
     INTEGER, DIMENSION(:,:), POINTER :: surfIndex
     INTEGER, DIMENSION(:,:), POINTER :: chanIndex
     ! These are actually dimensioned (subVectorLen,noSubVectors)
  END TYPE QuantityTemplate_T
d164 4
a167 1
  ! This incrementing counter is used to set the id field of a quantity template
d169 1
a169 1
  INTEGER, PRIVATE :: quantityTemplateCounter=0
d171 1
a171 1
  ! --------------------------------------------------------------------------
d173 1
a173 1
  CONTAINS
d175 1
a175 1
  ! Now we have some subroutines to deal with these quantitites
d177 2
a178 3
  ! This first routine sets up a new quantity template according to the user
  ! input.  This may be based on a previously supplied template (with possible
  ! modifications), or created from scratch.
d180 2
a181 3
  SUBROUTINE SetupNewQuantityTemplate(qty, source, noSubVectors, noSurfs, &
       & noChans, coherent, stacked, regular, subVectorLen, firstIndexChannel, &
       & minorFrame)
d184 7
a190 1
    TYPE (QuantityTemplate_T), INTENT(OUT) :: qty ! Result
d192 3
a194 10
    TYPE (QuantityTemplate_T), OPTIONAL, INTENT(IN) :: source ! Template
    INTEGER, INTENT(IN), OPTIONAL :: noSubVectors
    INTEGER, INTENT(IN), OPTIONAL :: noSurfs
    INTEGER, INTENT(IN), OPTIONAL :: noChans
    LOGICAL, INTENT(IN), OPTIONAL :: coherent
    LOGICAL, INTENT(IN), OPTIONAL :: stacked
    LOGICAL, INTENT(IN), OPTIONAL :: regular
    INTEGER, INTENT(IN), OPTIONAL :: subVectorLen
    LOGICAL, INTENT(IN), OPTIONAL :: firstIndexChannel
    LOGICAL, INTENT(IN), OPTIONAL :: minorFrame
d196 2
a197 5
    ! Local variables
    INTEGER :: status           ! Status from allocates etc.
    LOGICAL :: useFirstindexchannel ! Copy of store by channel
    INTEGER :: noSurfsToAllocate ! For allocations
    INTEGER :: noSubVectorsToAllocate ! For allocations
d199 1
a199 1
    ! Executable code
d201 2
a202 20
    ! First, if we have a template setup according to that
    IF (PRESENT(source)) THEN
       qty%noSubVectors=source%noSubVectors
       qty%noSurfs=source%noSurfs
       qty%noChans=source%noChans
       qty%coherent=source%coherent
       qty%stacked=source%stacked
       qty%regular=source%regular
       qty%minorFrame=source%minorFrame
       qty%subVectorLen=source%subVectorLen
    ELSE ! We have no template, setup a very bare quantity
       qty%noSubVectors=1
       qty%noSurfs=1
       qty%noChans=1
       qty%coherent=.TRUE.
       qty%stacked=.TRUE.
       qty%regular=.TRUE.
       qty%minorFrame=.FALSE.
       qty%subVectorLen=1
    ENDIF
d204 1
a204 28
    ! Now, see if the user asked for modifications to this
    IF (PRESENT(noSubVectors)) qty%noSubVectors=noSubVectors
    IF (PRESENT(noSurfs)) qty%noSurfs=noSurfs
    IF (PRESENT(noChans)) qty%noChans=noChans
    IF (PRESENT(regular)) qty%regular=regular
    IF (PRESENT(minorFrame)) qty%minorFrame=minorFrame
    IF (qty%minorFrame) THEN
       IF (PRESENT(coherent)) THEN
          IF (coherent) CALL MLSMessage(MLSMSG_Error,ModuleName, &
               & "Minor frame quantities must be incoherent")
       ENDIF
       qty%coherent=.FALSE.
       IF (PRESENT(stacked)) THEN
          IF (stacked) CALL MLSMessage(MLSMSG_Error,ModuleName, &
               & "Minor frame quantities must be unstacked")
       ENDIF
       qty%stacked=.FALSE.
    ELSE
       IF (PRESENT(coherent)) qty%coherent=coherent
       IF (PRESENT(stacked)) qty%stacked=stacked
    ENDIF

    ! Now think about subVectorLen
    IF ((.NOT. qty%regular).AND.(PRESENT(subVectorLen))) THEN
       qty%subVectorLen=subVectorLen
    ELSE
       qty%subVectorLen=qty%noSurfs*qty%noChans
    ENDIF
d206 1
a206 4
    ! Deal with the firstindexchannel argument
    useFirstindexchannel=.TRUE.
    IF (PRESENT(firstindexchannel)) useFirstindexchannel=firstindexchannel
    qty%firstIndexChannel=useFirstIndexChannel
d208 18
a225 1
    ! Now we allocate all the arrays we're going to need
d227 1
a227 11
    IF (qty%coherent) THEN 
       noSubVectorsToAllocate=1
    ELSE
       noSubVectorsToAllocate=qty%noSubVectors
    ENDIF

    IF (qty%stacked) THEN
       noSurfsToAllocate=1
    ELSE
       noSurfsToAllocate=qty%noSurfs
    ENDIF
d229 2
a230 1
    ! First the vertical coordinates
d232 1
a232 3
    ALLOCATE (qty%surfs(qty%noSurfs,noSubVectorsToAllocate),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"surfs")
d234 2
a235 1
    ! Now the horizontal coordinates
d237 2
a238 27
    ALLOCATE (qty%phi(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"phi")

    ALLOCATE (qty%geodLat(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"geodLat")

    ALLOCATE (qty%lon(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"lon")

    ALLOCATE (qty%time(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"time")

    ALLOCATE (qty%solarTime(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"solarTime")

    ALLOCATE (qty%solarZenith(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"solarZenith")

    ALLOCATE (qty%losAngle(noSurfsToAllocate,qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"losAngle")
d240 14
a253 23
    ! Now some other stuff to allocate
    IF (qty%minorFrame) THEN
       ALLOCATE (qty%MAFIndex(qty%noSubVectors), &
            & qty%MAFCounter(qty%noSubVectors), &
            & STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"MAFIndex/MAFCounter")
    END IF

    IF (.NOT. qty%regular) THEN
       ALLOCATE (qty%surfIndex(qty%subVectorLen,qty%noSubVectors),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"surfIndex")

       ALLOCATE (qty%chanIndex(qty%subVectorLen,qty%noSubVectors),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"chanIndex")
    ENDIF

    ! Se the id field and increment the counter
    qty%id=quantityTemplateCounter
    quantityTemplateCounter=quantityTemplateCounter+1
  END SUBROUTINE SetupNewQuantityTemplate
d255 3
a257 1
  ! --------------------------------------------------------------------------
d259 2
a260 1
  ! This subroutine destroys a quantity template
d262 10
a271 1
  SUBROUTINE DestroyQuantityTemplateContents(qty)
d273 3
a275 2
    ! Dummy argument
    TYPE (QuantityTemplate_T), INTENT(INOUT) :: qty
a276 1
    integer status
a277 36
    DEALLOCATE (qty%surfs, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%surfs")

    DEALLOCATE (qty%phi,STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%phi")

    DEALLOCATE (qty%geodLat, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%geodLat")

    DEALLOCATE (qty%lon, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%lon")

    DEALLOCATE (qty%time,STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%time")

    DEALLOCATE (qty%solarTime, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%solarTime")

    DEALLOCATE (qty%solarZenith, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%solarZenith")

    DEALLOCATE (qty%losAngle, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%losAngle")


    IF (qty%minorFrame) DEALLOCATE (qty%MAFIndex,qty%MAFCounter, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%minorFrame")
d279 20
a298 5
    
    IF (.NOT. qty%regular) THEN
       DEALLOCATE (qty%surfIndex, STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%regular")
d300 28
a327 3
       DEALLOCATE (qty%chanIndex, STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"qty%chanIndex")
d329 3
a331 1
    ENDIF
d333 1
a333 1
  END SUBROUTINE DestroyQuantityTemplateContents
d335 11
a345 1
  ! --------------------------------------------------------------------------
d347 1
a347 2
  ! This subroutine adds a quantity template to a database, or creates the
  ! database if it doesn't yet exist
d349 2
a350 1
  SUBROUTINE AddQuantityTemplateToDatabase(database,qty)
d352 1
a352 3
    ! Dummy arguments
    TYPE (QuantityTemplate_T), DIMENSION(:), POINTER :: database
    TYPE (QuantityTemplate_T), INTENT(IN) :: qty
d354 2
a355 3
    ! Local variables
    TYPE (QuantityTemplate_T), DIMENSION(:), POINTER :: tempDatabase
    INTEGER :: newSize,status
d357 2
a358 1
    ! Executable code
d360 2
a361 21
    IF (ASSOCIATED(database)) THEN
       ! Check we don't already have one of this name
       IF (LinearSearchStringArray(database%name,qty%name, &
            & caseInsensitive=.TRUE.)/=0) CALL MLSMessage(MLSMSG_Error,&
            & ModuleName,MLSMSG_Duplicate//qty%name)
       newSize=SIZE(database)+1
    ELSE
       newSize=1
    ENDIF

    ALLOCATE(tempDatabase(newSize),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Allocation failed for tempDatabase")

    IF (newSize>1) tempDatabase(1:newSize-1)=database
    tempDatabase(newSize)=qty
    IF (ASSOCIATED(database))DEALLOCATE(database, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"database")
    database=>tempDatabase
  END SUBROUTINE AddQuantityTemplateToDatabase
d363 2
a364 1
  ! --------------------------------------------------------------------------
d366 2
a367 1
  ! This subroutine destroys a quantity template database
d369 2
a370 1
  SUBROUTINE DestroyQuantityTemplateDatabase(database)
d372 2
a373 2
    ! Dummy argument
    TYPE (QuantityTemplate_T), DIMENSION(:), POINTER :: database
d375 1
a375 2
    ! Local variables
    INTEGER :: qtyIndex, status
d377 22
a398 9
    IF (ASSOCIATED(database)) THEN
       DO qtyIndex=1,SIZE(database)
          CALL DestroyQuantityTemplateContents(database(qtyIndex))
       ENDDO
       DEALLOCATE(database, STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"database")
    ENDIF
  END SUBROUTINE DestroyQuantityTemplateDatabase
d401 1
a401 1
END MODULE QuantityTemplates
d406 2
a407 69
! Revision 1.12  2000/06/19 23:57:41  lungu
! Added GPH.
! Added status check after each DEALLOCATE.
!
! Revision 1.11  2000/05/17 23:49:14  lungu
! Added check "IF (ASSOCIATED(database))DEALLOCATE(database)".
! Added type for GPH.
!
! Revision 1.10  2000/05/15 22:52:35  livesey
! Typo fix.
!
! Revision 1.9  2000/01/20 21:59:28  livesey
! Replaced subVectorIndex with MAFIndex and MAFCounter
!
! Revision 1.8  2000/01/20 01:28:21  livesey
! Removed the horizontal coordinate information, and beefed up the
! frequency coordinate information.
!
! Revision 1.7  2000/01/18 21:27:00  livesey
! Added noSubVectors(Lower/Upper)Overlap, copied from HGrid or similar.
!
! Revision 1.6  2000/01/12 20:55:49  livesey
! Added minorFrame flag.
!
! Revision 1.5  2000/01/07 23:53:35  livesey
! Nearly integrated, just a few tweaks.
!
! Revision 1.4  1999/12/17 21:42:16  livesey
! Added check for duplicate name
!
! Revision 1.3  1999/12/16 23:46:35  livesey
! Added the unit field and fixed a couple of compile glitches
!
! Revision 1.2  1999/12/16 23:12:09  livesey
! Added quantityType and other support entries
!
! Revision 1.1  1999/12/16 18:31:43  livesey
! First version. Renamed from VectorQuantities
!
!
! This module was previously known as VectorQuantities.  This is it's previous
! revision history.
!
! Revision 1.9  1999/12/16 01:28:02  livesey
! Routine checkin
!
! Revision 1.8  1999/12/14 00:55:29  livesey
! Changed DOUBLE PRECISION to REAL(r8)
!
! Revision 1.7  1999/12/04 00:26:33  livesey
! Added a few comments.
!
! Revision 1.6  1999/12/03 22:27:08  livesey
! Tidied up some of the INTENT stuff
!
! Revision 1.5  1999/12/03 21:57:34  livesey
! Added the code to set the id field with an incrementing counter
!
! Revision 1.4  1999/12/01 23:01:41  livesey
! Before renaming things to upper/lower case
!
! Revision 1.3  1999/12/01 05:03:56  livesey
! Nightly checkin
!
! Revision 1.2  1999/11/30 04:03:51  livesey
! Bug fix
!
! Revision 1.1  1999/11/24 23:06:33  livesey
! First simple version.
d409 2
d412 1
@


1.12
log
@Added GPH.
Added status check after each DEALLOCATE.
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.11 2000/05/17 23:49:14 lungu Exp $"
d481 4
@


1.11
log
@Added check "IF (ASSOCIATED(database))DEALLOCATE(database)".
Added type for GPH.
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.10 2000/05/15 22:52:35 livesey Exp $"
d361 1
d363 31
a394 8
    DEALLOCATE (qty%surfs)
    DEALLOCATE (qty%phi)
    DEALLOCATE (qty%geodLat)
    DEALLOCATE (qty%lon)
    DEALLOCATE (qty%time)
    DEALLOCATE (qty%solarTime)
    DEALLOCATE (qty%solarZenith)
    DEALLOCATE (qty%losAngle)
d396 4
a399 1
    IF (qty%minorFrame) DEALLOCATE (qty%MAFIndex,qty%MAFCounter)
d402 8
a409 2
       DEALLOCATE (qty%surfIndex)
       DEALLOCATE (qty%chanIndex)
d447 3
a449 1
    IF (ASSOCIATED(database))DEALLOCATE(database)
d463 1
a463 1
    INTEGER :: qtyIndex
d469 3
a471 1
       DEALLOCATE(database)
d481 4
@


1.10
log
@Typo fix.
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.9 2000/01/20 21:59:28 livesey Exp $"
d29 1
a29 1
  INTEGER, PARAMETER :: NoQTYTypes=6
d37 2
a38 2
       & "EXTINCTION  "/)

d46 1
d414 1
a414 1
    DEALLOCATE(database)
d444 3
@


1.9
log
@Replaced subVectorIndex with MAFIndex and MAFCounter
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.8 2000/01/20 01:28:21 livesey Exp $"
d131 2
a132 2
     ! This is dimensioned (noSurfs,1) for regular quantities and (noSurfs
     !,noSubVectors) for irregular ones.
d443 3
@


1.8
log
@Removed the horizontal coordinate information, and beefed up the
frequency coordinate information.
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.7 2000/01/18 21:27:00 livesey Exp $"
d145 2
a146 2
     ! This integer array can be used to tie subVectors to say l2gp profile
     ! numbers or to MAF indices
d148 1
a148 1
     INTEGER, DIMENSION(:), POINTER :: subVectorIndex
d328 7
a334 3
    ALLOCATE (qty%subVectorIndex(qty%noSubVectors),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"subVectorIndex")
d370 2
a371 1
    DEALLOCATE (qty%subVectorIndex)
d443 4
@


1.7
log
@Added noSubVectors(Lower/Upper)Overlap, copied from HGrid or similar.
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.6 2000/01/12 20:55:49 livesey Exp $"
d47 19
a65 18
  ! This set of integers defines another enumerated type describing the types
  ! of `horizontal' divisions there can be in vector quantities

  INTEGER, PARAMETER :: NoHDTypes=5
  CHARACTER (LEN=13), PARAMETER, DIMENSION(NoHDTypes) :: &
       & HDTypeNames= (/ &
       & "L2GP profile ", &
       & "Major Frame  ", &
       & "Orbital      ", &
       & "Temporal     ", &
       & "Constant     "/)
  
  INTEGER, PARAMETER :: HD_Invalid=0
  INTEGER, PARAMETER :: HD_L2GProfile=1
  INTEGER, PARAMETER :: HD_MAF=2
  INTEGER, PARAMETER :: HD_Orbital=3
  INTEGER, PARAMETER :: HD_Temporal=4
  INTEGER, PARAMETER :: HD_Constant=5
d125 1
a125 1
     INTEGER :: surfStride, chanStride
a149 5
     ! This integer is an enumerated type which defines how the `horizontal'
     ! profiles in a quantity are divided.

     INTEGER :: horizontalDivision 

d157 1
a157 2
     INTEGER :: frequencyCoordinate ! An enumerated type, explains next fields

d173 3
a175 2
     ! Now for irregular quantities, instead of using the stride information,
     ! we have these arrays to help us navigate around the quantity.
d197 1
a197 1
       & noChans, coherent, stacked, regular, subVectorLen, storeByChannel, &
d211 1
a211 1
    LOGICAL, INTENT(IN), OPTIONAL :: storeByChannel
d216 1
a216 1
    LOGICAL :: useStoreByChannel ! Copy of store by channel
d272 4
a275 17
    ! Deal with the storeByChannel argument
    useStoreByChannel=.FALSE.
    IF (PRESENT(storeByChannel)) useStoreByChannel=storeByChannel

    ! Now think about strides
    IF (qty%regular) THEN
       IF (useStoreByChannel) THEN
          qty%surfStride=qty%noChans
          qty%chanStride=1
       ELSE
          qty%chanStride=qty%noSurfs
          qty%surfStride=1
       ENDIF
    ELSE
       qty%surfStride=0
       qty%chanStride=0
    ENDIF
d438 3
@


1.6
log
@Added minorFrame flag.
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.5 2000/01/07 23:53:35 livesey Exp $"
d99 6
d455 3
@


1.5
log
@Nearly integrated, just a few tweaks.
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.4 1999/12/17 21:42:16 livesey Exp $"
d92 7
d195 2
a196 1
       & noChans, coherent, stacked, regular, subVectorLen, storeByChannel)
d210 1
d228 1
d237 1
a244 2
    IF (PRESENT(coherent)) qty%coherent=coherent
    IF (PRESENT(stacked)) qty%stacked=stacked
d246 16
d449 3
@


1.4
log
@Added check for duplicate name
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.3 1999/12/16 23:46:35 livesey Exp $"
d47 19
d136 5
d424 3
@


1.3
log
@Added the unit field and fixed a couple of compile glitches
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.2 1999/12/16 23:12:09 livesey Exp $"
d355 4
a393 8
  ! --------------------------------------------------------------------------

  ! This subroutine creates a new quantity template from the l2cf information

!   SUBROUTINE CreateQtyTemplateFromMLSCFInfo(qty,cfInfo,&
!        & vGridDatabase,hGridDatabase)
!   END SUBROUTINE CreateQtyTemplateFromMLSCFInfo

d400 3
@


1.2
log
@Added quantityType and other support entries
@
text
@d19 1
a19 1
       "$Id: QuantityTemplates.f90,v 1.1 1999/12/16 18:31:43 livesey Exp $"
d30 1
a30 1
  CHARACTER (LEN=12), PARAMETER, DIMENSION(NoQtyFamilies) :: &
d80 1
d404 3
@


1.1
log
@First version. Renamed from VectorQuantities
@
text
@d19 2
a20 2
       "$Id: VectorQuantities.f90,v 1.9 1999/12/16 01:28:02 livesey Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: VectorQuantities.f90,v $"
d26 2
a27 1
  ! First we'll define some global parameters and data types.
d29 17
a45 1
  INTEGER, PARAMETER :: QtyNameLen=20
d47 1
a47 1
  ! This data type defines a quantity template
d53 1
a53 1
     CHARACTER (LEN=QtyNameLen) :: name ! Simple name for quantity
d56 5
d129 5
d135 3
a137 3
     ! Other quantities refer to a particular MLS signal designation

     TYPE (MLSSignal_T), DIMENSION(:), POINTER :: signal ! Signal (optional)
d402 4
a405 1
! $Log$
@

