head	2.23;
access;
symbols
	v5-02-NRT-19:2.23
	v6-00:2.23
	v5-02-NRT-18:2.23
	v5-02:2.23
	v5-01-NRT-17:2.23
	v5-01-NRT-16:2.23
	v5-01-NRT-15:2.23
	v5-01-NRT-14:2.23
	neuralnetworks-1-0:2.23.0.12
	cfm-single-freq-0-1:2.23.0.10
	v5-01:2.23
	v5-00:2.23
	v4-23-TA133:2.23.0.8
	mus-emls-1-70:2.23.0.6
	rel-1-0-englocks-work:2.23.0.4
	VUMLS1-00:2.23
	VPL1-00:2.23
	V4-22-NRT-08:2.23
	VAM1-00:2.23
	V4-21:2.23.0.2
	V4-13:2.23
	V4-12:2.22
	V4-11:2.22
	V4-10:2.22
	V3-43:2.10
	M4-00:2.10
	V3-41:2.10
	V3-40-PlusGM57:2.10.0.2
	V2-24-NRT-04:2.9
	V3-33:2.10
	V2-24:2.9
	V3-31:2.10
	V3-30-NRT-05:2.10
	cfm-01-00:2.10
	V3-30:2.10
	V3-20:2.10
	V3-10:2.10
	V2-23-NRT-02:2.9
	V2-23:2.9
	V2-22-NRT-01:2.9
	V2-22:2.9
	V2-21:2.9
	V2-20:2.9
	V2-11:2.9
	V2-10:2.9
	V2-00:2.9
	V1-51:2.8
	V1-50:2.8
	V1-45:2.8
	V1-44:2.8
	V1-43:2.8
	V1-42:2.5
	V1-41:2.5
	V1-32:2.5
	V1-40:2.5
	V1-31:2.5
	V1-30:2.5
	V1-13:2.5
	V1-12:2.5
	V1-11:2.5
	V1-10:2.5
	newfwm-feb03:2.5.0.2
	V1-04:2.3
	V1-03:2.3
	V1-02:2.3
	V1-00:2.3
	newfwm-sep01:2.3.0.2
	V0-7:2.3
	V0-5-Level2:2.3
	V0-5-SIPS:2.3;
locks; strict;
comment	@# @;


2.23
date	2014.09.05.00.21.40;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2014.04.09.00.43.18;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2014.03.20.01.38.29;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2014.02.27.02.27.09;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2014.02.21.19.24.32;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2014.01.08.21.09.43;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2013.12.12.01.55.54;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2013.10.16.01.12.47;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2013.10.11.00.44.28;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2013.10.09.23.39.49;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2013.10.02.01.30.03;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2013.09.19.23.29.33;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2013.09.17.00.55.07;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2009.06.23.18.25.43;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2005.06.22.17.25.48;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2004.01.23.05.35.50;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2004.01.17.03.04.48;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2004.01.16.23.51.23;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2002.10.08.00.09.08;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2002.07.18.22.04.06;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.04.16.23.05.29;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2001.04.05.01.28.06;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.11.18.57.28;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.23
log
@Keep track of allocate/deallocate sizes in bytes instead of Memory_Units
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module DECLARATION_TABLE

! It is necessary that the INIT_TABLES procedure from INIT_TABLES_MODULE
! is called before any procedures here.  The INIT_TABLES_MODULE depends on
! the application -- it is not part of the library -- but it is responsible
! for initializing the representation of intrinsic types accessed from
! the INTRINSIC module.

  use INTRINSIC, only: Data_Type_Indices, Lit_Indices, Parm_Indices, &
    &                  PHYQ_Indices, PHYQ_Invalid, Spec_Indices, T_A_dot_B, &
    &                  T_Boolean, T_Do_Label, T_Enum_Name, T_Empty, T_Exprn, &
    &                  T_Exprn_M, T_Exprn_V, T_Field_name, T_Function_Name, &
    &                  T_Label, T_Numeric, T_Numeric_Range, T_Param_Name, &
    &                  T_Phys_Unit_Name, T_Section_Name, T_Spec_Name, T_String, &
    &                  T_String_Range, T_Tree_Name, T_Type_Name, T_Unit_Name, &
    &                  T_Variable_Name
  use MACHINE, only: IO_ERROR
  use OUTPUT_M, only: NewLine, OUTPUT
  use STRING_TABLE, only: CREATE_STRING, DISPLAY_STRING, HOW_MANY_STRINGS, &
    &                     STRING_TABLE_SIZE
  use TOGGLES, only: LEVELS, TAB, TOGGLE
  use Tree, only: Null_Tree

  implicit NONE
  private

  public :: ALLOCATE_DECL, Allocate_Test, Base_Unit, Value_Allocate
  public :: DEALLOCATE_DECL, Deallocate_Test, DECLARATION, DECLARE, DECLARED
  public :: DECLS, DO_LABEL, DUMP_DECL, DUMP_A_DECL, DUMP_1_DECL, DUMP_VALUES
  public :: EMPTY, ENUM_VALUE, EXPRN, EXPRN_M, EXPRN_V, FIELD, FUNCTION
  public :: GET_DECL, INIT_DECL, LABEL, LOG_VALUE, NAMED_VALUE, NULL_DECL
  public :: NUM_VALUE, PHYS_UNIT_NAME, PRIOR_DECL, RANGE, REDECLARE, SECTION
  public :: STR_RANGE, STR_VALUE, SPEC, TREE_NODE, TYPE_NAME, UNITS_NAME
  public :: Value_Add, Value_Deallocate, Value_Diff, Value_Div, Value_Equal
  public :: Value_Neg, Value_Prod, Value_Same, Value_t, Value_Unequal, VARIABLE

  public :: Operator(==), Operator(/=)
  public :: Operator(+), Operator(-), Operator(*), Operator(/)

  include "Value_T_Interfaces.f9h"

  interface Allocate_Test
    module procedure Value_Allocate
  end interface

  interface Deallocate_Test
    module procedure Value_Deallocate
  end interface

  interface Get_Decl
    module procedure Get_Decl_Array, Get_Decl_Scalar, Get_Decl_Text
  end interface

  interface Prior_Decl
    module procedure Prior_Decl_Array, Prior_Decl_Scalar
  end interface

  integer, parameter :: NULL_DECL = 0   ! Index and type of the null
                                        ! declaration

! Values of the "type" field of "decls":
  integer, parameter :: EMPTY = t_empty ! The "type" field of the sentinel
!   integer, parameter :: DOT = 1         ! A.B -- not used in decl table
  integer, parameter :: DO_LABEL = t_do_label ! Label of a construct
  integer, parameter :: ENUM_VALUE = t_enum_name  ! An enumerator
  integer, parameter :: EXPRN = t_exprn ! The "tree" field points to a
                                        ! scalar expression
  integer, parameter :: EXPRN_M = t_exprn_m ! The "tree" field points to a
                                        ! matrix expression
  integer, parameter :: EXPRN_V = t_exprn_v ! The "tree" field points to a
                                        ! vector expression
  integer, parameter :: FIELD = t_field_name ! Field of a structure definition
  integer, parameter :: FUNCTION = t_function_name ! Name is a built-in function
  integer, parameter :: LABEL = t_label ! A "name:" label for a stru
  integer, parameter :: LOG_VALUE = 10  ! Entity is a logical value, value is
                                        ! .false. if the "value" field is zero.
  integer, parameter :: NAMED_VALUE = t_param_name ! X = expr
  integer, parameter :: NUM_VALUE = t_numeric ! Entity is a numeric value, value is
                                        ! in the "value" field"
  integer, parameter :: PHYS_UNIT_NAME = t_phys_unit_name ! PHYQ_....
  integer, parameter :: RANGE = t_numeric_range ! A range -- not used in decl table
  integer, parameter :: SECTION = t_section_name ! Name of a section
!   integer, parameter :: SECTION_NODE = 16 ! Tree node of a section
  integer, parameter :: STR_RANGE = t_string_range ! String range
  integer, parameter :: STR_VALUE = t_string ! The string is the value
  integer, parameter :: SPEC = t_spec_name ! Name of a specification, e.g. vGrid
  integer, parameter :: TREE_NODE = t_tree_name ! Name of a tree node, e.g. n_plus
  integer, parameter :: TYPE_NAME = t_type_name ! Name of a data type
!   integer, parameter :: UNDECLARED = 22 ! Entity is undeclared
  integer, parameter :: UNITS_NAME = t_unit_name ! Name is a units name, e.g. km, hPa
                                        ! Scale to "canonical" units of the
                                        ! name is in "value", e.g. km = 1000.0
  integer, parameter :: VARIABLE = t_variable_name ! Name is a variable, e.g. A := <expr>

  integer, parameter :: LAST_TYPE = VARIABLE

  type :: Value_t             ! Used if decls%type == variable or named_value,
                              ! or as the value of an array-valued expression
    integer :: What = empty   ! Type index (above)
    integer :: Type           ! Type index (again), or data type index (t_...)
                              ! if WHAT ==  Enum_Value, or variable value
                              ! type if WHAT == Variable.
    double precision :: Value(2) = 0.0d0 ! Numeric value if type is numeric
                                         ! String index if type is string
                                         ! or label
                                         ! Lit index otherwise
    integer :: Units(2) = 0   ! PHYQ_...
    integer :: Decor = 0      ! Decoration if expr was identifier, or tree
                              ! node index if type == range or str_range
  end type Value_t

  ! Type            Units                  Value           Tree
  ! EMPTY           0                      0.0d0           null_tree
  ! DO_LABEL        PHYQ_Invalid           string index    DO Construct root
  ! ENUM_VALUE      lit index              string index    DT_Def
  ! EXPRN
  ! EXPRN_M
  ! EXPRN_V
  ! FIELD           field index            0.0d0           Field_type
  !                                        0.0d0           Field_Spec
  ! FUNCTION        function index         string index    Func_def
  ! LABEL           Spec_Index             string index    Spec_Args
  ! LOG_VALUE
  ! NAMED_VALUE     param index            string index    Name_Def
  ! NUM_VALUE       PHYQ_Dimensionless     its value       N_Number
  ! PHYS_UNIT_NAME  PHYQ_... index         conversion      a unit's L_... index
  ! RANGE
  ! SECTION         section index          string index    Section
  ! STR_RANGE
  ! STR_VALUE       PHYQ_Invalid           string index    String
  ! SPEC            spec index             string index    Spec_def
  ! TREE_NODE
  ! TYPE_NAME       type index             string index    DT_Def
  ! UNITS_NAME      PHYQ_... index         conversion      L_... unit index
  ! VARIABLE        Type of first          string index    Identifier
  !                 element of value

  type :: DECLS
    double precision :: VALUE = 0.0d0
    integer :: TYPE = empty   ! "units", "variable", "spec", "field", "value", ...
    integer :: UNITS = 0      ! Depends on "type" field:
                              ! "units_name" => Index of "units" of name,
                              !            e.g. km = length, ...
                              ! "enum_value" => The enumerator's lit index
                              ! "exprn" => < 0 offset in matrix database
                              !            > 0 offset in vector database
                              !            0 = double-precision value only
                              ! "field" => Index of field
                              ! "function" => Index of function
                              ! "named_value" => Type of its first value
                              ! "section" => Index of section
                              ! "spec" => Index of specification
                              ! "variable" => Type of its first value
    integer :: TREE = null_tree ! Index of declaration in the tree, except for
                              ! "units_name" => string index of name
    integer :: PRIOR = null_decl ! Index of previous declaration
    type(value_t), allocatable :: Values(:) ! If type == variable or named_value
  end type DECLS

! -----     Private declarations     -----------------------------------
  type(decls), save, allocatable :: DECL_TABLE(:)
  integer, save :: NUM_DECLS            ! amount of decl_table used
  integer, save, allocatable :: SYMBOL_DECL(:) ! indexed by string
                                        ! index, gives index in decl_table.

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: declaration_table.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains ! =====     Public Procedures     =============================
! ------------------------------------------------  ALLOCATE_DECL  -----
  subroutine ALLOCATE_DECL ( NDECLS, STAT )
  ! Allocate NDECLS declarations.  Allocate STRING_TABLE_SIZE symbol
  ! declarations (indexes from STRING_TABLE to DECL_TABLE).  Also does
  ! INIT_DECL.
    integer, intent(in) :: NDECLS       ! Number to allocate
    integer, intent(out), optional :: STAT   ! From ALLOCATE statement
    integer :: MY_STAT
    if ( allocated(decl_table) ) then; deallocate(decl_table); end if
    if ( allocated(symbol_decl) ) then; deallocate(symbol_decl); end if
    allocate ( decl_table(0:ndecls), stat=my_stat )
    if ( my_stat /= 0 ) then
      if ( present(stat) ) then
        stat = my_stat
        return
      end if
      call io_error &
      ( 'DECL_TABLE%ALLOCATE_DECL-E- Unable to allocate storage', my_stat )
      stop
    end if
    allocate ( symbol_decl(0:string_table_size()), stat=my_stat )
    if ( my_stat /= 0 ) then
      if ( present(stat) ) then
        stat = my_stat
        return
      end if
      call io_error &
      ( 'DECL_TABLE%ALLOCATE_DECL-E- Unable to allocate storage', my_stat )
      stop
    end if
    call init_decl
    symbol_decl = null_decl
    return
  end subroutine ALLOCATE_DECL

! ----------------------------------------------------  Base_Unit  -----
  integer function Base_Unit ( PHYS_Unit )
    ! Get the base unit corresponding to a physical unit.
    ! The base unit is one with scale == 1.0.
    ! The result is the base unit's lit index, not it's string index.
    ! This is here instead of in the Units module, because we need it, and
    ! can't uset from the Units module because the Units module accesses this
    ! module by use association.
    use Intrinsic, only: L_Dimensionless, PHYQ_Indices
    integer, intent(in) :: PHYS_Unit
    type(decls) :: Decl
    base_unit = l_dimensionless ! for want of a better default
    decl = get_decl ( phyq_indices(phys_unit), type=phys_unit_name, value=1.0d0 )
    if ( decl%type == phys_unit_name ) base_unit = decl%tree
  end function Base_Unit

! ----------------------------------------------  DEALLOCATE_DECL  -----
  subroutine DEALLOCATE_DECL
    if ( allocated(decl_table) ) deallocate ( decl_table )
    if ( allocated(symbol_decl) ) deallocate( symbol_decl )
  end subroutine DEALLOCATE_DECL

! --------------------------------------------------  DECLARATION  -----
  type(decls) function DECLARATION ( STRING )
    integer, intent(in) :: STRING  ! String index for which declaration needed
    if ( string > ubound(symbol_decl,1) ) & ! Assume string_table is increased
      & call increase_symbol_decl
    declaration = decl_table(symbol_decl(string))
  end function DECLARATION

! ------------------------------------------------------  DECLARE  -----
  subroutine DECLARE ( STRING, VALUE, TYPE, UNITS, TREE, VALUES )
    integer, intent(in) :: STRING  ! String index of name to declare
    double precision, intent(in) :: VALUE    ! Declared value
    integer, intent(in) :: TYPE    ! Type of object, e.g. UNITS, LABEL...
    integer, intent(in) :: UNITS   ! Units of value -- index of units string
    integer, intent(in) :: TREE    ! Index of tree node of declaration
    type(value_t), allocatable, intent(inout), optional :: Values(:)

    integer :: STAT
    type(decls), allocatable :: OLD_DECL(:)

    num_decls = num_decls + 1
    if ( num_decls > ubound(decl_table,1) ) then
    ! Double size of declaration table
      allocate ( old_decl(0:ubound(decl_table,1)), stat=stat )
      if ( stat /= 0 ) then
        call io_error &
        ( 'DECLARATION_TABLE%DECLARE-E- Unable to allocate storage', stat )
        stop
      end if
      old_decl = decl_table
      deallocate ( decl_table )
      allocate( decl_table(0:2*size(old_decl)), stat=stat )
      if ( stat /= 0 ) then
        call io_error &
        ( 'DECLARATION_TABLE%DECLARE-E- Unable to allocate storage', stat )
        stop
      end if
      decl_table(0:ubound(old_decl,1)) = old_decl
      deallocate ( old_decl )
    end if
    if ( string > ubound(symbol_decl,1) ) & ! Assume string_table is increased
      & call increase_symbol_decl
    decl_table(num_decls) = decls ( value, type, units, tree, &
                                    symbol_decl(string), null() )
    if ( present(values) ) call move_alloc ( values, decl_table(num_decls)%values )
    symbol_decl(string) = num_decls
    if ( toggle(tab) ) then
      call display_string ( string, before='Declare ' )
      call dump_a_decl ( decl_table(num_decls), before=' with', details=levels(tab) )
    end if
  end subroutine DECLARE

! -----------------------------------------------------  DECLARED  -----
  logical function DECLARED ( STRING )
    integer, intent(in) :: STRING
    if ( string > ubound(symbol_decl,1) ) & ! Assume string_table is increased
      & call increase_symbol_decl
    declared = symbol_decl(string) /= null_decl
  end function DECLARED

! ----------------------------------------------------  DUMP_DECL  -----
  subroutine DUMP_DECL ( Details )
    integer, intent(in), optional :: Details
    integer :: I    ! Loop inductor
    if ( num_decls <= 0 ) return
    call output ( ' dec  str', advance='yes' )
    do i = 1, how_many_strings()
      call dump_1_decl ( i, details=details )
    end do
  end subroutine DUMP_DECL

! --------------------------------------------------  DUMP_A_DECL  -----
  recursive subroutine DUMP_A_DECL ( Decl, Before, Details )
    use Lexer_Core, only: Print_Source
    use Tree, only: Decoration, Source_Ref, Subtree, Sub_Rosa
    type(decls), intent(in) :: Decl
    character(len=*), intent(in), optional :: Before
    integer, intent(in), optional :: Details ! 0 -> no tree or source location
                                             ! 1 -> tree & source (default)
                                             ! >1 -> values of type and what
    integer :: MyDetails
    integer :: Enum_Type ! Type def of enum if variable of enum type
    if ( present(before) ) call output ( before )
    myDetails = 1
    if ( present(details) ) myDetails = details
    if ( myDetails > 0 ) then
      if ( associated(data_type_indices) ) & ! Might not be if called from
                                             ! command line processing
        & call display_string ( data_type_indices(decl%type), before=' type=' )
      if ( myDetails > 1 ) then
        call output ( decl%type, before='=' )
        call output ( decl%units, before=' units=' )
      end if
    end if
    if ( .not. allocated(decl%values) ) &
      & call output ( decl%value, before=' value=' )
    select case ( decl%type )
    case ( do_label )
      call output ( ' DO label' )
    case ( enum_value )
      call display_string ( sub_rosa(subtree(1,decl%tree)), before=' of type ' )
      call display_string ( lit_indices(decl%units), before=' lit ' )
      call output ( decl%units, before=' ' )
    case ( label )
      call display_string ( sub_rosa(subtree(1,decl%tree)), before=' of ' )
      call output ( ' spec ' )
    case ( phys_unit_name )
      call display_string ( lit_indices(decl%tree), before=' units=' )
    case ( variable )
      if ( decl%units /= 0 .and. associated(data_type_indices) ) then
        call display_string ( data_type_indices(decl%units), before=' type ' )
      else
        call output ( decl%units, before=' What is ' )
        call output ( '?' )
      end if
      if ( decl%units == str_value .and. decl%value > 0 ) &
        & call display_string ( nint(decl%value), before=' ' )
    case ( named_value )
      call output ( decl%units, before=' param index=' )
    case ( units_name )
      if ( phyq_indices(decl%units) == 0 ) then
        call output ( ' units=<unknown> ' )
      else
        call display_string ( phyq_indices(decl%units), before=' units=' )
      end if
    case default
      call output ( decl%units, before=' units=' )
    end select
    if ( myDetails > 0 ) then
      call output ( decl%tree, before=' tree=' )
      call print_source ( source_ref(decl%tree), before=' ' )
    end if
    if ( allocated(decl%values) ) then
      call output ( ' values:', advance='yes' )
      enum_type = 0
      if ( decl%type == variable ) then
        select case ( decl%units ) ! Type of first element of value
        case ( enum_value )
          enum_type = decoration(decl%tree)
        case ( label )
          enum_type = decoration(decl%tree)
        end select
      end if 
      call dump_values ( decl%values, type_tree=enum_type, details=details )
    else
      call output ( ' No values', advance='yes' )
    end if
  end subroutine DUMP_A_DECL

! --------------------------------------------------  DUMP_1_DECL  -----
  subroutine DUMP_1_DECL ( SYMBOL, Details )
    integer, intent(in) :: SYMBOL  ! Index of symbol whose declaration to dump
    integer, intent(in), optional :: Details
    integer :: DECL                ! Index of decl of "symbol"
    if ( symbol > ubound(symbol_decl,1) ) & ! Assume string_table is increased
      & call increase_symbol_decl
    decl = symbol_decl(symbol)
    do while ( decl /= null_decl )
      call output ( decl, 4 )
      call output ( symbol, 5 ); call output ( ': ' )
      call display_string ( symbol )
      call dump_a_decl ( decl_table(decl), details=details )
      decl = decl_table(decl)%prior
    end do
  end subroutine DUMP_1_DECL

! --------------------------------------------------  DUMP_VALUES  -----
  subroutine DUMP_VALUES ( VALUES, BEFORE, ADVANCE, Type_Tree, Details )
    use Tree, only: Decoration, Subtree, Sub_Rosa
    type(value_t), intent(in) :: Values(:)
    character(len=*), intent(in), optional :: BEFORE, ADVANCE
    integer, intent(in), optional :: Type_Tree ! Root of type def if enum_value
    integer, intent(in), optional :: Details
    logical :: DoWhat   ! Print %what and %type
    integer :: I, MyDetails, N
    integer :: The_Type
    if ( present(before) ) call output ( before, advance )
    the_type = 0
    if ( present(type_tree) ) the_type = type_tree
    myDetails = 1
    if ( present(details) ) myDetails = details
    do i = 1, size(values)
      doWhat = myDetails > 1
      if ( myDetails > 8 ) then
        call the_numbers
        call newline
        doWhat = .false.
      end if
      call output ( i, places=3 )
      call output ( ': ' )
      select case ( values(i)%what )
      case ( do_label )
        call display_string ( nint(values(i)%value(1)), before='DO label ' )
      case ( enum_value )  ! values%value(1) is a lit index
        if ( associated(lit_indices) ) &
          & call display_string ( lit_indices(nint(values(i)%value(1))) )
        if ( values(i)%what /= 0 .and. associated(data_type_indices) ) &
          & call display_string ( data_type_indices(values(i)%type), before=' ' )
        call output ( values(i)%decor, before=' decor=' )
      case ( label )       ! values%value(1) is a string index
        call display_string ( nint(values(i)%value(1)), before=' ' )
        if ( values(i)%units(1) /= 0 .and. associated(spec_indices) ) &
          & call display_string ( spec_indices(values(i)%units(1)), before=': ' )
      case ( log_value )   ! values%value(1) 0= 0 => false, else true
        call output ( trim(merge('true ','false',values(i)%value(1)/=0.0d0)) )
        call output ( ' log_value' )
      case ( named_value )  ! values%value(1) is a string index
        call display_string ( nint(values(i)%value(1)) )
        if ( the_type /= 0 .and. associated(parm_indices) ) &
          & call display_string ( parm_indices(the_type), before=' ' )
      case ( num_value )   ! values%value(1) is a number
        call output ( values(i)%value(1) )
        if ( associated(lit_indices) ) &
          & call display_string ( lit_indices(base_unit(values(i)%units(1))), &
            & before=' ' )
      case ( range )       ! values%value(1:2) are numbers
        call output ( values(i)%value(1) )
        if ( associated(lit_indices) ) &
          & call display_string ( lit_indices(base_unit(values(i)%units(1))), &
            & before=' ' )
        call show_range ( values(i)%decor ) ! Tree node id
        if ( associated(lit_indices) ) &
          & call display_string ( lit_indices(base_unit(values(i)%units(2))), &
            & before=' ' )
      case ( str_range )   ! values%value(1:2) are string indices
        call display_string ( nint(values(i)%value(1)) )
        call show_range ( values(i)%decor ) ! Tree node id
        call display_string ( nint(values(i)%value(2)), before=' : ' )
        if ( values(i)%decor /= 0 ) call display_string ( values(i)%decor, before=' ' )
      case ( str_value )   ! values%value(1) is a string index
        n = nint(values(i)%value(1))
        if ( n > 0 ) then
          call display_string ( n )
        else
          call output ( '<no value>' )
        end if
      case default
        doWhat = .true.
      end select
      if ( doWhat ) call the_numbers
      call newline
    end do

  contains

  ! .................................................  Show_Range  .....
    subroutine Show_Range ( Node_ID )
      ! Output : <: :< or <:< depending on Node_Id
      use Tree_Types, only: N_Colon, N_Colon_Less, N_Less_Colon, N_Less_Colon_Less
      integer, intent(in) :: Node_ID
      select case ( node_id )
      case ( n_colon_less )
        call output ( ' :< ' )
      case ( n_less_colon )
        call output ( ' <: ' )
      case ( n_less_colon_less )
        call output ( ' <:< ' )
      case default
        call output ( ' : ' )
      end select
    end subroutine Show_Range

  ! ................................................  The_Numbers  .....
    subroutine The_Numbers
      call output ( values(i)%what, before=' %what=' )
      call output ( values(i)%type, before=' %type=' )
      call output ( values(i)%value(1), before=' %value=' )
      call output ( values(i)%value(2), before=' ' )
      call output ( values(i)%units(1), before=' %units=' )
      call output ( values(i)%units(2), before=' ' )
      call output ( values(i)%decor, before=' %decor=' )
    end subroutine The_Numbers

  end subroutine DUMP_VALUES

! -----------------------------------------------  GET_DECL_ARRAY  -----
  type(decls) function GET_DECL_ARRAY ( String, Types ) result ( decl )
    ! Hunt for decls of types.  Return the first one found, or empty if none
    integer, intent(in) :: String   ! String index of identifier
    integer, intent(in) :: Types(:)
    integer :: I
    do i = 1, size(types)
      decl = get_decl ( string, types(i) )
      if ( decl%type /= empty ) return
    end do
  end function GET_DECL_ARRAY

! ----------------------------------------------  GET_DECL_SCALAR  -----
  type(decls) function GET_DECL_SCALAR ( STRING, TYPE, UNITS, TREE, VALUE ) &
    & result ( decl )
  ! Get the latest declaration of "string" having a "type" field equal
  ! to "type" (if present), a "units" field equal to "units" (if
  ! present) and a "tree" field equal to "tree" (if present).  Return it
  ! if any, else return the decl at null_decl.
    integer, intent(in) :: STRING  ! Index of string
    integer, intent(in), optional :: TYPE  ! "type" value to look for
    integer, intent(in), optional :: UNITS ! "units" value to look for
    integer, intent(in), optional :: TREE  ! "tree" value to look for
    double precision, intent(in), optional :: VALUE ! "value" to look for

    logical :: GOT_IT
    integer :: PRIOR

    decl = declaration(string)
    do
      got_it = .true.
      if ( present(type) ) got_it = decl%type == type
      if ( got_it .and. present(units) ) got_it = decl%units == units
      if ( got_it .and. present(tree) ) got_it = decl%tree == tree
      if ( got_it .and. present(value) ) &
        & got_it = abs(decl%value - value) < epsilon(value)
      if ( got_it ) return
      prior = decl%prior
      decl = prior_decl(decl)
      if ( prior == null_decl ) return
    end do
  end function GET_DECL_SCALAR

! ------------------------------------------------  GET_DECL_TEXT  -----
  type(decls) function GET_DECL_TEXT ( String, TYPE, Value, Index ) result ( decl )
  ! Get the latest declaration of "String" (which is text here, not a
  ! string index) having a Type field equal to "type".
    use STRING_TABLE, only: ADD_CHAR, LOOKUP
    character(len=*), intent(in) :: String
    integer, intent(in) :: Type
    double precision, intent(in), optional :: VALUE ! "value" to look for
    integer, intent(out), optional :: Index ! String index of String, useful
                                            ! in subsequent Prior_Decl's
    ! Internal variables
    logical :: found
    integer :: strID
    call add_char( string(:len_trim(string)) )
    call lookup ( strID, found, caseless=.true., debug=0 )
    if ( present(index) ) index = strID
    if ( found ) then
      decl = get_decl ( strID, type, value=value )
    else
      decl = decl_table(null_decl)
    end if
  end function GET_DECL_TEXT

! ----------------------------------------------------  INIT_DECL  -----
  subroutine INIT_DECL
    !                             value type  units     tree prior
    decl_table(null_decl) = decls(0.0d0,empty,phyq_invalid,0,null_decl)
    num_decls = 0
  end subroutine INIT_DECL

! ---------------------------------------------  PRIOR_DECL_ARRAY  -----
  type(decls) function PRIOR_DECL_ARRAY ( THE_DECL, TYPE, UNITS ) &
    result ( PRIOR_DECL )
  ! Return the prior declaration of "the_decl" with specified values of
  ! "type" and "units" (if they're specified).
    type(decls), intent(in) :: THE_DECL
    integer, intent(in) :: TYPE(:)
    integer, intent(in), optional :: UNITS
    integer :: PRIOR
    prior = the_decl%prior
    do
      prior_decl = decl_table(prior)
      if ( prior_decl%type == empty ) return
      if ( any(prior_decl%type == type) ) then
        if ( .not. present(units) ) return
        if ( prior_decl%units == units ) return
      else
        if ( .not. present(units) ) return
        if ( prior_decl%units == units ) return
      end if
      prior = prior_decl%prior
    end do
  end function PRIOR_DECL_ARRAY

! --------------------------------------------  PRIOR_DECL_SCALAR  -----
  type(decls) function PRIOR_DECL_SCALAR ( THE_DECL, TYPE, UNITS ) &
    result ( PRIOR_DECL )
  ! Return the prior declaration of "the_decl" with specified values of
  ! "type" and "units" (if they're specified).
    type(decls), intent(in) :: THE_DECL
    integer, intent(in), optional :: TYPE, UNITS
    integer :: PRIOR
    prior = the_decl%prior
    do
      prior_decl = decl_table(prior)
      if ( prior_decl%type == empty ) return
      if ( present(type) ) then
        if ( prior_decl%type == type ) then
          if ( .not. present(units) ) return
          if ( prior_decl%units == units ) return
        end if
      else
        if ( .not. present(units) ) return
        if ( prior_decl%units == units ) return
      end if
      prior = prior_decl%prior
    end do
  end function PRIOR_DECL_SCALAR

! ----------------------------------------------------  REDECLARE  -----
  subroutine REDECLARE ( STRING, VALUE, TYPE, UNITS, TREE, VALUES )
  ! Find the latest declaration for "string" of type "type".  If there
  ! isn't one, declare it.  Otherwise, change the "value", "units",
  ! "tree" and "values" fields of the found one.
    integer, intent(in) :: STRING  ! String index of name to declare
    double precision, intent(in) :: VALUE    ! Declared value
    integer, intent(in) :: TYPE    ! Type of object, e.g. UNITS, LABEL...
    integer, intent(in), optional :: UNITS   ! Units of value -- index of units string
    integer, intent(in), optional :: TREE    ! Index of tree node of declaration
    type(value_t), allocatable, intent(inout), optional :: Values(:)
    integer :: PRIOR
    if ( string > ubound(symbol_decl,1) ) & ! Assume string_table is increased
      & call increase_symbol_decl
    prior = symbol_decl(string)
    do
      if ( prior == null_decl ) then
        call declare ( string, value, type, units, tree, values )
        return
      end if
      if ( decl_table(prior)%type == type ) then
        decl_table(prior)%value = value
        if ( present(units) )  decl_table(prior)%units = units
        if ( present(tree) )   decl_table(prior)%tree = tree
        if ( present(values) ) &
          & call move_alloc ( values, decl_table(prior)%values )
        if ( toggle(tab) ) then
          call display_string ( string, before='Redeclare ' )
          call dump_a_decl ( decl_table(prior), before=' with', details=levels(tab) )
        end if
        return
      end if
      prior = decl_table(prior)%prior
    end do
  end subroutine REDECLARE

! -----------------------------------------------  Value_Allocate  -----
  subroutine Value_Allocate ( Value, N, ItsName, ModuleName )
    use Allocate_Deallocate, only: Test_Allocate
    type(value_t), allocatable :: Value(:)
    integer, intent(in) :: N
    character(len=*), intent(in) :: ItsName, ModuleName
    integer :: Stat
    call deallocate_test ( value, itsName, moduleName )
    allocate ( value(1:n), stat=stat )
    call test_allocate ( stat, moduleName, ItsName, [1], [n], &
      & storage_size(value) / 8 )
  end subroutine Value_Allocate

! ---------------------------------------------  Value_Deallocate  -----
  subroutine Value_Deallocate ( Value, ItsName, ModuleName )
    use Allocate_Deallocate, only: Test_Deallocate
    type(value_t), allocatable :: Value(:)
    character(len=*), intent(in) :: ItsName, ModuleName
    integer :: N, Stat
    if ( allocated(value) ) then
      n = size(value)
      deallocate ( value, stat=stat )
      call test_deallocate ( stat, moduleName, ItsName,  &
        & n * (storage_size(value) / 8) )
    end if
  end subroutine Value_Deallocate

  include "Value_T_Implementations.f9h"

! =====     Private Procedures     =====================================
! -----------------------------------------  Increase_Symbol_Decl  -----
  subroutine Increase_Symbol_Decl ( Status )
  ! Double the size of the Symbol_Decl table.
    integer, intent(out), optional :: Status
    integer, allocatable :: Old_Decl(:)
    integer :: Stat

    allocate ( old_decl(0:ubound(symbol_decl,1)), stat=stat )
    if ( stat /= 0 ) then
      if ( present(status) ) then
        status = stat
        return
      end if
      call io_error &
      ( 'DECL_TABLE%Increase_Symbol_Decl-E- Unable to allocate storage', stat )
      stop
    end if
    old_decl = symbol_decl
    deallocate ( symbol_decl )
    allocate ( symbol_decl(0:string_table_size()), stat=stat )
    if ( stat /= 0 ) then
      if ( present(status) ) then
        status = stat
        return
      end if
      call io_error &
      ( 'DECL_TABLE%Increase_Symbol_Decl-E- Unable to allocate storage', stat )
      stop
    end if
    symbol_decl(0:ubound(old_decl,1)) = old_decl
    symbol_decl(ubound(old_decl,1)+1:) = null_decl
    deallocate ( old_decl )
  end subroutine Increase_Symbol_Decl

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: declaration_table.f90,v 2.22 2014/04/09 00:43:18 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module DECLARATION_TABLE

! $Log: declaration_table.f90,v $
! Revision 2.22  2014/04/09 00:43:18  vsnyder
! Don't try to use data_type_indices or lit_indices if they're not yet
! associated.  Pass "values" through from redeclare to declare.  Print
! "No values" instead of simply a new line if a variable has no values.
!
! Revision 2.21  2014/03/20 01:38:29  vsnyder
! Unify types in Intrinsic instead of having a separate system in
! Declaration_Table.
!
! Revision 2.20  2014/02/27 02:27:09  vsnyder
! More fiddling with the dumps
!
! Revision 2.19  2014/02/21 19:24:32  vsnyder
! Add Do_Label, Prior_Decl_Array, polish some dumps
!
! Revision 2.18  2014/01/08 21:09:43  vsnyder
! Add more tracing info
!
! Revision 2.17  2013/12/12 01:55:54  vsnyder
! Provide a place for variable values in the declaration table
!
! Revision 2.16  2013/10/16 01:12:47  vsnyder
! Cannonball polishing
!
! Revision 2.15  2013/10/11 00:44:28  vsnyder
! Get Values_t operations from the include files
!
! Revision 2.14  2013/10/09 23:39:49  vsnyder
! Add Allocate_Test etc, equality etc.
!
! Revision 2.13  2013/10/02 01:30:03  vsnyder
! Add 'variable' type
!
! Revision 2.12  2013/09/19 23:29:33  vsnyder
! Add Dump_A_Decl, PHYS_Unit
!
! Revision 2.11  2013/09/17 00:55:07  vsnyder
! Add Dot type
!
! Revision 2.10  2009/06/23 18:25:43  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.9  2005/06/22 17:25:48  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.8  2004/01/23 05:35:50  livesey
! Made dump_1_decl a little more robust
!
! Revision 2.7  2004/01/17 03:04:48  vsnyder
! Provide for functions in expressions
!
! Revision 2.6  2004/01/16 23:51:23  vsnyder
! Add more declaration table types for Algebra
!
! Revision 2.5  2002/10/08 00:09:08  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.4  2002/07/18 22:04:06  vsnyder
! Improve some debugging print
!
! Revision 2.3  2001/04/16 23:05:29  vsnyder
! SAVE some module variables
!
! Revision 2.2  2001/04/05 01:28:06  vsnyder
! Add 'increase the symbol declaration table size' code
!
! Revision 2.1  2000/10/11 18:57:28  vsnyder
! Move from lib/cf_parser to lib; insert copyright notice
!
! Revision 2.0  2000/09/05 17:41:49  dcuddy
! Change revision to 2.0
!
! Revision 1.1  2000/07/06 01:43:12  vsnyder
! Initial check-in
!
@


2.22
log
@Don't try to use data_type_indices or lit_indices if they're not yet
associated.  Pass "values" through from redeclare to declare.  Print
"No values" instead of simply a new line if a variable has no values.
@
text
@d689 1
a689 1
    use Allocate_Deallocate, only: Memory_Units, Test_Deallocate
d697 1
a697 1
        & n * (storage_size(value) / 8) / memory_units )
d741 1
a741 1
       "$Id: declaration_table.f90,v 2.21 2014/03/20 01:38:29 vsnyder Exp $"
d751 5
@


2.21
log
@Unify types in Intrinsic instead of having a separate system in
Declaration_Table.
@
text
@d327 3
a329 1
      call display_string ( data_type_indices(decl%type), before=' type=' )
d350 1
a350 1
      if ( decl%units /= 0 ) then
d386 1
a386 1
      call newLine
d435 4
a438 3
        call display_string ( lit_indices(nint(values(i)%value(1))) )
        if ( values(i)%what /= 0 ) call display_string ( &
          & data_type_indices(values(i)%type), before=' ' )
d442 2
a443 2
        if ( values(i)%units(1) /= 0 ) call display_string ( &
           & spec_indices(values(i)%units(1)), before=': ' )
d449 1
a449 1
        if ( the_type /= 0 ) &
d453 3
a455 2
        call display_string ( lit_indices(base_unit(values(i)%units(1))), &
          & before=' ' )
d458 3
a460 2
        call display_string ( lit_indices(base_unit(values(i)%units(1))), &
          & before=' ' )
d462 3
a464 2
        call display_string ( lit_indices(base_unit(values(i)%units(2))), &
          & before=' ' )
d655 1
a655 1
        call declare ( string, value, type, units, tree )
d741 1
a741 1
       "$Id: declaration_table.f90,v 2.20 2014/02/27 02:27:09 vsnyder Exp $"
d751 4
@


2.20
log
@More fiddling with the dumps
@
text
@d20 8
a27 3
  use INTRINSIC, only: DATA_TYPE_INDICES, LIT_INDICES, PARM_INDICES, &
    &                  PHYQ_INDICES, PHYQ_INVALID, SPEC_INDICES, T_A_DOT_B, &
    &                  T_BOOLEAN, T_NUMERIC, T_NUMERIC_RANGE, T_STRING
d38 5
a42 5
  public :: ALLOCATE_DECL, Allocate_Test, Value_Allocate, DEALLOCATE_DECL
  public :: Deallocate_Test, DECLARATION, DECLARE, DECLARED, DECLS, DOT
  public :: DO_LABEL, DUMP_DECL, DUMP_A_DECL, DUMP_1_DECL, DUMP_VALUES, EMPTY
  public :: ENUM_VALUE, EXPRN, EXPRN_M, EXPRN_V, FIELD, FUNCTION, GET_DECL
  public :: GET_TYPE, INIT_DECL, LABEL, LOG_VALUE, NAMED_VALUE, NULL_DECL
d44 1
a44 2
  public :: SECTION_NODE, STR_RANGE, STR_VALUE, SPEC, TREE_NODE, TYPE_MAP
  public :: TYPE_NAME, TYPE_NAMES, TYPE_NAME_INDICES, UNDECLARED, UNITS_NAME
d62 1
a62 1
    module procedure Get_Decl_Array, Get_Decl_Scalar
d73 5
a77 5
  integer, parameter :: EMPTY = 0       ! The "type" field of the sentinel
  integer, parameter :: DOT = 1         ! A.B -- not used in decl table
  integer, parameter :: DO_LABEL = 2    ! Label of a DO construct
  integer, parameter :: ENUM_VALUE = 3  ! An enumerator
  integer, parameter :: EXPRN = 4       ! The "tree" field points to a
d79 1
a79 1
  integer, parameter :: EXPRN_M = 5     ! The "tree" field points to a
d81 1
a81 1
  integer, parameter :: EXPRN_V = 6     ! The "tree" field points to a
d83 3
a85 3
  integer, parameter :: FIELD = 7       ! Field of a structure definition
  integer, parameter :: FUNCTION = 8    ! Name is a built-in function
  integer, parameter :: LABEL = 9       ! A "name:" label for a stru
d88 2
a89 2
  integer, parameter :: NAMED_VALUE = 11! X = expr
  integer, parameter :: NUM_VALUE = 12  ! Entity is a numeric value, value is
d91 11
a101 11
  integer, parameter :: PHYS_UNIT_NAME = 13 ! PHYQ_....
  integer, parameter :: RANGE = 14      ! A range -- not used in decl table
  integer, parameter :: SECTION = 15    ! Name of a section
  integer, parameter :: SECTION_NODE = 16 ! Tree node of a section
  integer, parameter :: STR_RANGE = 17  ! String range -- for dates
  integer, parameter :: STR_VALUE = 18  ! The string is the value
  integer, parameter :: SPEC = 19       ! Name of a specification, e.g. vGrid
  integer, parameter :: TREE_NODE = 20  ! Name of a tree node, e.g. n_plus
  integer, parameter :: TYPE_NAME = 21  ! Name of a data type
  integer, parameter :: UNDECLARED = 22 ! Entity is undeclared
  integer, parameter :: UNITS_NAME = 23 ! Name is a units name, e.g. km, hPa
d104 1
a104 1
  integer, parameter :: VARIABLE = 24   ! Name is a variable, e.g. A := <expr>
a124 1
  ! DOT
d136 2
a137 2
  ! NUM_VALUE       PHYQ_Dimensionless     its value       Number
  ! PHYS_UNIT_NAME  its lit index          value           string index
a139 1
  ! SECTION_NODE
d145 1
a145 2
  ! UNDECLARED      PHYQ_Invalid           0.0d0           Identifier
  ! UNITS_NAME      PHYQ_...               Value           string index
a170 21
  character(len=*), parameter :: TYPE_NAMES(empty:variable) = &
  (/ 'empty         ', 'dot           ', 'do_label      ', 'enum_value    ', &
     'exprn         ', 'exprn_m       ', 'exprn_v       ', 'field         ', &
     'function      ', 'label         ', 'log_value     ', 'nam_value     ', &
     'num_value     ', 'phys_unit_name', 'range         ', 'section       ', &
     'section_n     ', 'str_range     ', 'str_value     ', 'spec          ', &
     'tree          ', 'type_name     ', 'undeclared    ', 'units         ', &
     'variable      ' /)

  ! String indices of type names, filled on first call to Get_Type or
  ! Init_Decl
  integer :: TYPE_NAME_INDICES(empty:variable) = -1

! Mapping from declaration table types to data types:
  integer, parameter :: TYPE_MAP(empty:variable) =                   &
  (/ 0,         t_a_dot_b,    0,         0,         0,               &
     0,         0,            0,         0,         0,               &
     t_boolean, 0,            t_numeric, 0,         t_numeric_range, &
     0,         0,            0,         t_string,  0,               &
     0,         0,            0,         0,         0 /)

d219 16
d313 1
a313 1
  subroutine DUMP_A_DECL ( Decl, Before, Details )
d327 1
a327 2
      call output ( ' type=' )
      call output ( trim(type_names(decl%type)) )
d346 1
a346 1
      call display_string ( lit_indices(decl%units), before=' units=' )
d348 2
a349 2
      if ( decl%units >= empty .and. decl%units <= last_type ) then
        call output ( ' type ' // trim(type_names(decl%units)) )
d407 1
a407 1
    use Tree, only: Decoration, Subtree, Sub_Rosa, Tree_Text
d412 1
a412 1
    logical :: DoWhat ! Print %what and %type
d450 2
a451 1
        call display_string ( phyq_indices(values(i)%units(1)), before=' ' )
d454 5
a458 5
        call display_string ( phyq_indices(values(i)%units(1)), before=' ' )
        call output ( values(i)%value(2), before=' : ' )
        call display_string ( phyq_indices(values(i)%units(2)), before=' ' )
        if ( values(i)%decor /= 0 ) call display_string ( &
          & tree_text(values(i)%decor), before=' ' )
d461 1
a463 2
        if ( values(i)%decor /= 0 ) call display_string ( &
          & tree_text(values(i)%decor), before=' ' )
d480 18
d523 2
a524 1
  type(decls) function GET_DECL_SCALAR ( STRING, TYPE, UNITS, TREE ) result ( decl )
d533 1
d544 2
d553 22
a574 9
  ! --------------------------------------------------  Get_Type  -----
  ! Return the string index for the type indexed by Decor
  integer function Get_Type ( Decor )
    integer, intent(in) :: Decor  ! Tree node decoration
    if ( (empty) < 0 ) call init_type_indices
    get_type = 0
    if ( decor >= empty .and. decor <= last_type ) &
      & get_type = type_name_indices ( decor )
  end function Get_Type
a580 1
    if ( type_name_indices(empty) < 0 ) call init_type_indices
a730 7
! --------------------------------------------  INIT_TYPE_INDICES  -----
  subroutine INIT_TYPE_INDICES
    integer :: I
    do i = empty, last_type
      type_name_indices(i) = create_string ( trim(type_names(i)) )
    end do
  end subroutine INIT_TYPE_INDICES
d735 1
a735 1
       "$Id: declaration_table.f90,v 2.19 2014/02/21 19:24:32 vsnyder Exp $"
d745 3
@


2.19
log
@Add Do_Label, Prior_Decl_Array, polish some dumps
@
text
@d115 2
a116 1
    integer :: Decor = 0      ! Decoration if expr was identifier
d319 1
a319 1
    use Tree, only: Decoration, Subtree, Sub_Rosa
d374 1
a374 1
      call print_source ( decl%tree, before=' ' )
d412 1
a412 1
    use Tree, only: Decoration, Subtree, Sub_Rosa
d427 5
d459 1
a459 1
        call output ( values(i)%value(2), before=' : ', advance='yes' )
d461 2
d466 3
d479 1
a479 9
      if ( doWhat ) then
        call output ( values(i)%what, before=' %what=' )
        call output ( values(i)%type, before=' %type=' )
        call output ( values(i)%value(1), before=' %value=' )
        call output ( values(i)%value(2), before=' ' )
        call output ( values(i)%units(1), before=' %units=' )
        call output ( values(i)%units(2), before=' ' )
        call output ( values(i)%decor, before=' %decor=' )
      end if
d482 13
d631 1
a631 1
          call dump_a_decl ( decl_table(prior), before=' with' )
d713 1
a713 1
       "$Id: declaration_table.f90,v 2.18 2014/01/08 21:09:43 vsnyder Exp $"
d723 3
@


2.18
log
@Add more tracing info
@
text
@d20 3
a22 2
  use INTRINSIC, only: LIT_INDICES, PARM_INDICES, PHYQ_INDICES, PHYQ_INVALID, &
    &                  T_A_DOT_B, T_BOOLEAN, T_NUMERIC, T_NUMERIC_RANGE, T_STRING
d35 4
a38 4
  public :: DUMP_DECL, DUMP_A_DECL, DUMP_1_DECL, DUMP_VALUES, EMPTY, ENUM_VALUE
  public :: EXPRN, EXPRN_M, EXPRN_V, FIELD, FUNCTION, GET_DECL, GET_TYPE
  public :: INIT_DECL, LABEL, LOG_VALUE, NAMED_VALUE, NULL_DECL, NUM_VALUE
  public :: PHYS_UNIT_NAME, PRIOR_DECL, RANGE, REDECLARE, SECTION
d61 4
d71 3
a73 2
  integer, parameter :: ENUM_VALUE = 2  ! An enumerator
  integer, parameter :: EXPRN = 3       ! The "tree" field points to a
d75 1
a75 1
  integer, parameter :: EXPRN_M = 4     ! The "tree" field points to a
d77 1
a77 1
  integer, parameter :: EXPRN_V = 5     ! The "tree" field points to a
d79 4
a82 4
  integer, parameter :: FIELD = 6       ! Field of a structure definition
  integer, parameter :: FUNCTION = 7    ! Name is a built-in function
  integer, parameter :: LABEL = 8       ! A "name:" label for a stru
  integer, parameter :: LOG_VALUE = 9   ! Entity is a logical value, value is
d84 2
a85 2
  integer, parameter :: NAMED_VALUE = 10! X = expr
  integer, parameter :: NUM_VALUE = 11  ! Entity is a numeric value, value is
d87 11
a97 11
  integer, parameter :: PHYS_UNIT_NAME = 12 ! PHYQ_....
  integer, parameter :: RANGE = 13      ! A range -- not used in decl table
  integer, parameter :: SECTION = 14    ! Name of a section
  integer, parameter :: SECTION_NODE = 15 ! Tree node of a section
  integer, parameter :: STR_RANGE = 16  ! String range -- for dates
  integer, parameter :: STR_VALUE = 17  ! The string is the value
  integer, parameter :: SPEC = 18       ! Name of a specification, e.g. vGrid
  integer, parameter :: TREE_NODE = 19  ! Name of a tree node, e.g. n_plus
  integer, parameter :: TYPE_NAME = 20  ! Name of a data type
  integer, parameter :: UNDECLARED = 21 ! Entity is undeclared
  integer, parameter :: UNITS_NAME = 22 ! Name is a units name, e.g. km, hPa
d100 1
a100 1
  integer, parameter :: VARIABLE = 23   ! Name is a variable, e.g. A := <expr>
d106 4
a109 3
    integer :: What = empty   ! Variable or Named_Value, or Empty if it's
                              ! an expression result value
    integer :: Type           ! type index
d112 1
d118 2
a119 2
  ! Type            Units                Value           Tree
  ! EMPTY           0                    0.0d0           null_tree
d121 2
a122 1
  ! ENUM_VALUE      lit index            string index    DT_Def
d126 4
a129 4
  ! FIELD           field index          0.0d0           Field_type
  !                                      0.0d0           Field_Spec
  ! FUNCTION        function index       string index    Func_def
  ! LABEL           PHYQ_Invalid         string index    Spec_Args
d131 3
a133 3
  ! NAMED_VALUE     param index          string index    Name_Def
  ! NUM_VALUE       PHYQ_Dimensionless   its value       Number
  ! PHYS_UNIT_NAME  its lit index        value           string index
d135 1
a135 1
  ! SECTION         section index        string index    Section
d138 2
a139 2
  ! STR_VALUE       PHYQ_Invalid         string index    String
  ! SPEC            spec index           string index    Spec_def
d141 4
a144 4
  ! TYPE_NAME       type index           string index    DT_Def
  ! UNDECLARED      PHYQ_Invalid         0.0d0           Identifier
  ! UNITS_NAME      PHYQ_...             Value           string index
  ! VARIABLE        Type of first        string index    Identifier
d170 7
a176 6
  (/ 'empty         ', 'dot           ', 'enum_value    ', 'exprn         ', &
     'exprn_m       ', 'exprn_v       ', 'field         ', 'function      ', &
     'label         ', 'log_value     ', 'nam_value     ', 'num_value     ', &
     'phys_unit_name', 'range         ', 'section       ', 'section_n     ', &
     'str_range     ', 'str_value     ', 'spec          ', 'tree          ', &
     'type_name     ', 'undeclared    ', 'units         ', 'variable      ' /)
d183 6
a188 6
  integer, parameter :: TYPE_MAP(empty:variable) =        &
  (/ 0, t_a_dot_b, 0,         0,               0,         &
     0, 0,         0,         0,               t_boolean, &
     0, t_numeric, 0,         t_numeric_range, 0,         &
     0, 0,         t_string,  0,               0,         &
     0, 0,         0,         0 /)
d332 4
d340 2
d346 3
d353 1
a353 1
        call output ( ' ' // trim(type_names(decl%units)) )
d380 3
a382 1
        case ( enum_value, label )
d411 1
a411 1
    use Tree, only: Subtree, Sub_Rosa
d429 6
a434 4
      case ( enum_value, label )  ! values%value(1) is a string index
        call display_string ( nint(values(i)%value(1)) )
        if ( the_type /= 0 ) &
          & call display_string ( sub_rosa(subtree(1,the_type)), before=' ' )
d436 4
d442 1
a442 1
        call output ( 'log_value' )
d471 5
d538 27
a564 2
! ---------------------------------------------------  PRIOR_DECL  -----
  type(decls) function PRIOR_DECL ( THE_DECL, TYPE, UNITS )
d585 1
a585 1
  end function PRIOR_DECL
d697 1
a697 1
       "$Id: declaration_table.f90,v 2.17 2013/12/12 01:55:54 vsnyder Exp $"
d707 3
@


2.17
log
@Provide a place for variable values in the declaration table
@
text
@d107 1
d328 2
d412 1
d415 1
a415 28
!       case ( named_value, variable )
!         select case ( values(i)%units(1) )
!         case ( enum_value, label )
!           call display_string ( nint(values(i)%value(1)) )
!           if ( the_type /= 0 ) &
!             & call display_string ( sub_rosa(subtree(1,the_type)), before=' ' )
!         case ( num_value )
!           call output ( values(i)%value(1), advance='yes' )
!           call display_string ( phyq_indices(values(i)%units(1)), before=' ' )
!         case ( range )
!           call output ( values(i)%value(1) )
!           call display_string ( phyq_indices(values(i)%units(1)), before=' ' )
!           call output ( values(i)%value(2), before=' : ' )
!           call display_string ( phyq_indices(values(i)%units(2)), before=' ' )
!         case ( str_range )
!           n = nint(values(i)%value(1))
!           if ( n > 0 ) call display_string ( nint(values(i)%value(1)) )
!           n = nint(values(i)%value(2))
!           if ( n > 0 ) then
!             call display_string ( n, before=' : ' )
!           else
!             call output ( ' : ' )
!           end if
!         case ( str_value )
!           n = nint(values(i)%value(1))
!           if ( n > 0 ) call display_string ( n )
!         case default
!         end select
d554 2
a555 5
        if ( present(values) ) then
          call deallocate_test ( decl_table(prior)%values, &
            & 'decl_table(prior)%values', moduleName )
          call move_alloc ( values, decl_table(prior)%values )
        end if
d640 1
a640 1
       "$Id: declaration_table.f90,v 2.16 2013/10/16 01:12:47 vsnyder Exp $"
d650 3
@


2.16
log
@Cannonball polishing
@
text
@d20 2
a21 2
  use INTRINSIC, only: LIT_INDICES, PHYQ_INDICES, PHYQ_INVALID, T_A_DOT_B, &
    &                  T_BOOLEAN, T_NUMERIC, T_NUMERIC_RANGE, T_STRING
d26 1
a26 1
  use TOGGLES, only: TAB, TOGGLE
d56 4
d98 9
a106 7
  type :: Value_t             ! Used if decls%type == variable or named_value
    integer :: TYPE = empty   ! Value type, subset of decls%type
    double precision :: VALUE(2) = 0.0d0 ! Real if type == num_value or range
                              ! 0 => false, 1 => true if type == log_value
                              ! string index if type == enum_value, label,
                              !   named_value, str_range, str_value
    integer :: Units(2) = 0   ! Subset of decls%units, depends on Type
d112 1
a112 1
  ! ENUM_VALUE      data type index      string index    DT_Def
d119 1
a119 1
  ! LABEL           PHYQ_Invalid         0.0d0           Spec_Args
d128 1
a128 1
  ! STR_VALUE       PHYQ_Invalid         0.0d0           String
d281 1
a281 1
      call dump_a_decl ( decl_table(num_decls), before=' with' )
d294 2
a295 1
  subroutine DUMP_DECL
d300 1
a300 1
      call dump_1_decl ( i )
d305 1
a305 1
  subroutine DUMP_A_DECL ( Decl, Before, Value_Only )
d307 1
a307 1
    use Tree, only: Subtree, Sub_Rosa
d310 5
a314 4
    logical, intent(in), optional :: Value_Only
    logical :: All
    all = .true.
    if ( present(value_only) ) all = .not. value_only
d316 3
a318 1
    if ( all ) then
d329 7
a335 3
    case ( named_value, variable )
      if ( decl%units >= empty .and. decl%units <= last_type ) &
        & call output ( ' ' // trim(type_names(decl%units)) )
d338 2
d349 2
a350 3
    if ( all ) then
      call output ( ' tree=' )
      call output ( decl%tree )
d355 8
a362 1
      call dump_values ( decl%values )
d369 1
a369 1
  subroutine DUMP_1_DECL ( SYMBOL )
d371 1
d380 1
a380 1
      call dump_a_decl ( decl_table(decl) )
d386 2
a387 1
  subroutine DUMP_VALUES ( VALUES, BEFORE, ADVANCE )
d390 5
a394 1
    integer :: I, N
d396 4
d401 8
a408 9
      if ( size(values) > 1 ) then
        call output ( i, places=3 )
        call output ( ': ' )
      end if
      select case ( values(i)%type )
      case ( enum_value )  ! values%value(1) is a string index
        call display_string ( nint(values(i)%value(1)) , advance='yes' )
      case ( label )       ! values%value(1) is a string index
        call display_string ( nint(values(i)%value(1)), advance='yes' )
d410 33
a442 28
        call output ( trim(merge('true ','false',values(i)%value(1)/=0.0d0)), &
          & advance='yes' )
      case ( named_value, variable )
        select case ( values(i)%units(1) )
        case ( num_value )
          call output ( values(i)%value(1), advance='yes' )
        case ( range )
          call output ( values(i)%value(1) )
          call output ( values(i)%value(2), before=' : ', advance='yes' )
        case ( str_range )
          n = nint(values(i)%value(1))
          if ( n > 0 ) call display_string ( nint(values(i)%value(1)) )
          n = nint(values(i)%value(2))
          if ( n > 0 ) then
            call display_string ( n, before=' : ', advance='yes' )
          else
            call output ( ' : ', advance='yes' )
          end if
        case ( str_value )
          n = nint(values(i)%value(1))
          if ( n > 0 ) then
            call display_string ( n, advance='yes' )
          else
            call newLine
          end if
        case default
          call newLine
        end select
d444 2
a445 1
        call output ( values(i)%value(1), advance='yes' )
d448 1
d450 1
d453 1
a453 2
        call display_string ( nint(values(i)%value(2)), before=' : ', &
          & advance='yes' )
d455 6
a460 1
        call display_string ( nint(values(i)%value(1)), advance='yes' )
d462 1
a462 1
        call output ( trim(type_names(values(i)%type )), advance='yes' )
d464 5
d472 14
a485 2
! -----------------------------------------------------  GET_DECL  -----
  type(decls) function GET_DECL ( STRING, TYPE, UNITS, TREE )
d498 1
a498 1
    get_decl = declaration(string)
d501 3
a503 3
      if ( present(type) ) got_it = get_decl%type == type
      if ( got_it .and. present(units) ) got_it = get_decl%units == units
      if ( got_it .and. present(tree) ) got_it = get_decl%tree == tree
d505 2
a506 2
      prior = get_decl%prior
      get_decl = prior_decl(get_decl)
d509 1
a509 1
  end function GET_DECL
d666 1
a666 1
       "$Id: declaration_table.f90,v 2.15 2013/10/11 00:44:28 vsnyder Exp $"
d676 3
@


2.15
log
@Get Values_t operations from the include files
@
text
@d27 1
d103 28
d147 1
a147 1
    integer :: TREE = 0       ! Index of declaration in the tree, except for
d161 2
a162 1
  ! String indices of type names, filled on first call to get_type
d369 4
a372 2
      call output ( i, places=3 )
      call output ( ': ' )
d455 1
a455 1
    if ( type_name_indices(empty) < 0 ) call init_type_indices
d606 1
a606 1
       "$Id: declaration_table.f90,v 2.14 2013/10/09 23:39:49 vsnyder Exp $"
d616 3
@


2.14
log
@Add Allocate_Test etc, equality etc.
@
text
@d31 10
a40 10
  public :: ALLOCATE_DECL, Allocate_Test, Allocate_Value, DEALLOCATE_DECL
  public :: Deallocate_Test, Deallocate_Value, DECLARATION, DECLARE
  public :: DECLARED, DECLS, DOT, DUMP_DECL, DUMP_A_DECL, DUMP_1_DECL
  public :: DUMP_VALUES, EMPTY, ENUM_VALUE, Equal_Value, EXPRN, EXPRN_M
  public :: EXPRN_V, FIELD, FUNCTION, GET_DECL, GET_TYPE, INIT_DECL, LABEL
  public :: LOG_VALUE, NAMED_VALUE, NULL_DECL, NUM_VALUE, PHYS_UNIT_NAME
  public :: PRIOR_DECL, RANGE, REDECLARE, SECTION, SECTION_NODE, STR_RANGE
  public :: STR_VALUE, SPEC, TREE_NODE, TYPE_MAP, TYPE_NAME, TYPE_NAMES
  public :: TYPE_NAME_INDICES, UNDECLARED, Unequal_Value, UNITS_NAME, Value_t
  public :: VARIABLE
d43 1
d45 1
a45 7
  interface operator(==)
    module procedure Equal_Value ! Two value_t objects are equal
  end interface

  interface operator(/=)
    module procedure Unequal_Value ! Two value_t objects are unequal
  end interface
d48 1
a48 1
    module procedure Allocate_Value
d52 1
a52 1
    module procedure Deallocate_Value
d190 1
a190 12
! -----------------------------------------------  Allocate_Value  -----
  subroutine Allocate_Value ( Value, N, ItsName, ModuleName )
    use Allocate_Deallocate, only: Test_Allocate
    type(value_t), allocatable :: Value(:)
    integer, intent(in) :: N
    character(len=*), intent(in) :: ItsName, ModuleName
    integer :: Stat
    call deallocate_test ( value, itsName, moduleName )
    allocate ( value(1:n), stat=stat )
    call test_allocate ( stat, moduleName, ItsName, [1], [n], &
      & storage_size(value) / 8 )
  end subroutine Allocate_Value
d196 1
a196 13
! ---------------------------------------------  Deallocate_Value  -----
  subroutine Deallocate_Value ( Value, ItsName, ModuleName )
    use Allocate_Deallocate, only: Memory_Units, Test_Deallocate
    type(value_t), allocatable :: Value(:)
    character(len=*), intent(in) :: ItsName, ModuleName
    integer :: N, Stat
    if ( allocated(value) ) then
      n = size(value)
      deallocate ( value, stat=stat )
      call test_deallocate ( stat, moduleName, ItsName,  &
        & n * (storage_size(value) / 8) / memory_units )
    end if
  end subroutine Deallocate_Value
d204 1
d248 1
d256 1
d266 1
d315 1
d331 1
d391 1
a391 6
! --------------------------------------------------  Equal_Value  -----
  elemental logical function Equal_Value ( V1, V2 )
    type(value_t), intent(in) :: V1, V2
    equal_value = v1%type == v2%type .and. all(v1%value == v2%value) .and. &
                  all(v1%units == v2%units)
  end function Equal_Value
d418 1
d428 1
d436 1
d460 1
d499 29
a527 5
! ------------------------------------------------  Unequal_Value  -----
  elemental logical function Unequal_Value ( V1, V2 )
    type(value_t), intent(in) :: V1, V2
    unequal_value = .not. ( v1 == v2 )
  end function Unequal_Value
d574 1
a574 1
       "$Id: declaration_table.f90,v 2.13 2013/10/02 01:30:03 vsnyder Exp $"
d584 3
@


2.13
log
@Add 'variable' type
@
text
@d21 1
a21 1
   &                   T_BOOLEAN, T_NUMERIC, T_NUMERIC_RANGE, T_STRING
d23 3
a25 2
  use OUTPUT_M, only: OUTPUT
  use STRING_TABLE, only: DISPLAY_STRING, HOW_MANY_STRINGS, STRING_TABLE_SIZE
d31 28
a58 25
  public :: ALLOCATE_DECL, DEALLOCATE_DECL, DECLARATION, DECLARE
  public :: DECLARED, DECLS, DOT, DUMP_DECL, DUMP_A_DECL, DUMP_1_DECL, EMPTY
  public :: ENUM_VALUE, EXPRN, EXPRN_M, EXPRN_V, FIELD, FUNCTION, GET_DECL
  public :: INIT_DECL, LABEL, LOG_VALUE, NAMED_VALUE, NULL_DECL, NUM_VALUE
  public :: PHYS_UNIT_NAME, PRIOR_DECL, RANGE, REDECLARE
  public :: SECTION, SECTION_NODE, STR_RANGE, STR_VALUE, SPEC, TREE_NODE
  public :: TYPE_MAP, TYPE_NAME, TYPE_NAMES, UNDECLARED, UNITS_NAME, VARIABLE

  type :: DECLS
    double precision :: VALUE
    integer :: TYPE           ! "units", "variable", "spec", "field", "value", ...
    integer :: UNITS          ! Depends on "type" field:
                              ! "units_name" => Index of "units" of name,
                              !            e.g. km = length, ...
                              ! "exprn" => < 0 offset in matrix database
                              !            > 0 offset in vector database
                              !            0 = double-precision value only
                              ! "field" => Index of field
                              ! "function" => Index of function
                              ! "section" => Index of section
                              ! "spec" => Index of specification
                              ! "variable" => Type of its first value
    integer :: TREE           ! Index of declaration in the tree
    integer :: PRIOR          ! Index of previous declaration
  end type DECLS
d96 33
d137 3
d195 12
d212 13
d233 1
a233 1
  subroutine DECLARE ( STRING, VALUE, TYPE, UNITS, TREE )
d239 1
d267 2
a268 1
                                    symbol_decl(string) )
d271 2
a272 18
      call output ( 'Declare ' ); call display_string ( string )
      call output ( ' with VALUE = ' ); call output ( value )
      call output ( ', TYPE = ' ); call output ( trim(type_names(type)) )
      call output ( ', UNITS = ' )
      if ( type == units_name ) then
        if ( phyq_indices(units) == 0 ) then
          call output ( ' <unknown> ' )
        else
          call display_string ( phyq_indices(units) )
        end if
      else if ( type == phys_unit_name ) then
        call display_string ( lit_indices(units) )
      else if ( type == variable ) then
        call output ( units, before=trim(type_names(units)) // ' = ' )
      else
        call output ( units )
      end if
      call output ( ', TREE = ' ); call output ( tree, advance='yes' )
d292 3
a294 1
  subroutine DUMP_A_DECL ( Decl )
d296 23
a318 5
    call output ( ' type=' )
    call output ( trim(type_names(decl%type)) )
    call output ( decl%value, before=' value=' )
    call output ( ' units=' )
    if ( decl%type == units_name ) then
d320 1
a320 1
        call output ( ' <unknown> ' )
d322 1
a322 1
        call display_string ( phyq_indices(decl%units) )
d324 11
a334 4
    else if ( decl%type == phys_unit_name ) then
      call display_string ( lit_indices(decl%units) )
    else if ( decl%type == variable ) then
      call output ( decl%units, before=trim(type_names(decl%units)) // ' = ' )
d336 1
a336 1
      call output ( decl%units )
a337 2
    call output ( ' tree=' )
    call output ( decl%tree, advance='yes' )
d354 65
d445 9
d459 1
d485 1
a485 1
  subroutine REDECLARE ( STRING, VALUE, TYPE, UNITS, TREE )
d487 2
a488 2
  ! isn't one, declare it.  Otherwise, change the "value", "units" and
  ! "tree" fields of the found one.
d492 3
a494 2
    integer, intent(in) :: UNITS   ! Units of value -- index of units string
    integer, intent(in) :: TREE    ! Index of tree node of declaration
d506 11
a516 2
        decl_table(prior)%units = units
        decl_table(prior)%tree = tree
d522 5
d562 8
d573 1
a573 1
       "$Id: declaration_table.f90,v 2.12 2013/09/19 23:29:33 vsnyder Exp $"
d583 3
@


2.12
log
@Add Dump_A_Decl, PHYS_Unit
@
text
@d36 1
a36 1
  public :: TYPE_MAP, TYPE_NAME, TYPE_NAMES, UNDECLARED, UNITS_NAME
d44 2
a45 2
                              ! "exprn" => Index < offset in matrix database
                              !            Index > offset in vector database
d51 1
d90 1
d92 1
a92 1
  character(len=*), parameter :: TYPE_NAMES(empty:units_name) = &
d98 1
a98 1
     'type_name     ', 'undeclared    ', 'units         ' /)
d101 1
a101 1
  integer, parameter :: TYPE_MAP(empty:units_name) =      &
d106 1
a106 1
     0, 0,         0 /)
d209 9
a217 1
        call display_string ( phyq_indices(units) )
d253 1
a253 1
    else if  ( decl%type == phys_unit_name ) then
d255 2
d399 1
a399 1
       "$Id: declaration_table.f90,v 2.11 2013/09/17 00:55:07 vsnyder Exp $"
d409 3
@


2.11
log
@Add Dot type
@
text
@d20 2
a21 2
  use INTRINSIC, only: PHYQ_INDICES, PHYQ_INVALID, T_A_DOT_B, T_BOOLEAN, &
   &                   T_NUMERIC, T_NUMERIC_RANGE, T_STRING
d31 1
a31 1
  public :: DECLARED, DECLS, DOT, DUMP_DECL, DUMP_1_DECL, EMPTY
d34 1
a34 1
  public :: PRIOR_DECL, RANGE, REDECLARE
d76 2
a77 1
  integer, parameter :: RANGE = 12      ! A range -- not used in decl table
d79 8
a86 8
  integer, parameter :: SECTION_NODE = 14 ! Tree node of a section
  integer, parameter :: STR_RANGE = 15  ! String range -- for dates
  integer, parameter :: STR_VALUE = 16  ! The string is the value
  integer, parameter :: SPEC = 17       ! Name of a specification, e.g. vGrid
  integer, parameter :: TREE_NODE = 18  ! Name of a tree node, e.g. n_plus
  integer, parameter :: TYPE_NAME = 19  ! Name of a data type
  integer, parameter :: UNDECLARED = 20 ! Entity is undeclared
  integer, parameter :: UNITS_NAME = 21 ! Name is a units name, e.g. km, hPa
d91 6
a96 5
  (/ 'empty     ', 'dot       ', 'enum_value', 'exprn     ', 'exprn_m   ', &
     'exprn_v   ', 'field     ', 'function  ', 'label     ', 'log_value ', &
     'nam_value ', 'num_value ', 'range     ', 'section   ', 'section_n ', &
     'str_range ', 'str_value ', 'spec      ', 'tree      ', 'type_name ', &
     'undeclared', 'units     ' /)
d100 5
a104 5
  (/ 0,         t_a_dot_b, 0,               0, 0,         &
     0,         0,         0,               0, t_boolean, &
     0,         t_numeric, t_numeric_range, 0, 0,         &
     0,         t_string,  0,               0, 0,         &
     0,         0 /)
d230 21
d262 1
a262 16
      call output ( ' value=' )
      call output ( decl_table(decl)%value )
      call output ( ' type=' )
      call output ( trim(type_names(decl_table(decl)%type)) )
      call output ( ' units=' )
      if ( decl_table(decl)%type == units_name ) then
        if ( phyq_indices(decl_table(decl)%units) == 0 ) then
          call output ( ' <unknown> ' )
        else
          call display_string ( phyq_indices(decl_table(decl)%units) )
        end if
      else
        call output ( decl_table(decl)%units )
      end if
      call output ( ' tree=' )
      call output ( decl_table(decl)%tree, advance='yes' )
d387 1
a387 1
       "$Id: declaration_table.f90,v 2.10 2009/06/23 18:25:43 pwagner Exp $"
d397 3
@


2.10
log
@Prevent Intel from optimizing ident string away
@
text
@d20 1
a20 1
  use INTRINSIC, only: PHYQ_INDICES, PHYQ_INVALID, T_BOOLEAN, &
d31 1
a31 1
  public :: DECLARED, DECLS, DUMP_DECL, DUMP_1_DECL, EMPTY
d60 3
a62 2
  integer, parameter :: ENUM_VALUE = 1  ! An enumerator
  integer, parameter :: EXPRN = 2       ! The "tree" field points to a
d64 1
a64 1
  integer, parameter :: EXPRN_M = 3     ! The "tree" field points to a
d66 1
a66 1
  integer, parameter :: EXPRN_V = 4     ! The "tree" field points to a
d68 4
a71 4
  integer, parameter :: FIELD = 5       ! Field of a structure definition
  integer, parameter :: FUNCTION = 6    ! Name is a built-in function
  integer, parameter :: LABEL = 7       ! A "name:" label for a stru
  integer, parameter :: LOG_VALUE = 8   ! Entity is a logical value, value is
d73 2
a74 2
  integer, parameter :: NAMED_VALUE = 9 ! X = expr
  integer, parameter :: NUM_VALUE = 10  ! Entity is a numeric value, value is
d76 10
a85 10
  integer, parameter :: RANGE = 11      ! A range -- not used in decl table
  integer, parameter :: SECTION = 12    ! Name of a section
  integer, parameter :: SECTION_NODE = 13 ! Tree node of a section
  integer, parameter :: STR_RANGE = 14  ! String range -- for dates
  integer, parameter :: STR_VALUE = 15  ! The string is the value
  integer, parameter :: SPEC = 16       ! Name of a specification, e.g. vGrid
  integer, parameter :: TREE_NODE = 17  ! Name of a tree node, e.g. n_plus
  integer, parameter :: TYPE_NAME = 18  ! Name of a data type
  integer, parameter :: UNDECLARED = 19 ! Entity is undeclared
  integer, parameter :: UNITS_NAME = 20 ! Name is a units name, e.g. km, hPa
d90 5
a94 5
  (/ 'empty     ', 'enum_value', 'exprn     ', 'exprn_m   ', 'exprn_v   ', &
     'field     ', 'function  ', 'label     ', 'log_value ', 'nam_value ', &
     'num_value ', 'range     ', 'section   ', 'section_n ', 'str_range ', &
     'str_value ', 'spec      ', 'tree      ', 'type_name ', 'undeclared', &
     'units     ' /)
d97 6
a102 6
  integer, parameter :: TYPE_MAP(empty:units_name) = &
  (/ 0,         0,               0, 0,         0, &      
     0,         0,               0, t_boolean, 0, &   
     t_numeric, t_numeric_range, 0, 0,         0, &
     t_string,  0,               0, 0,         0, &
     0 /)
d112 1
a112 1
       "$RCSfile: $"
d379 1
a379 1
       "$Id: read_apriori.f90 is it here $"
d389 3
@


2.9
log
@Reworded Copyright statement, moved rcs id
@
text
@d375 1
a376 1
!---------------------------- RCS Ident Info -------------------------------
d378 2
a379 3
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d381 1
d383 1
d388 3
@


2.8
log
@Made dump_1_decl a little more robust
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d109 3
a111 6
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
    & "$Id: declaration_table.f90,v 2.7 2004/01/17 03:04:48 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: declaration_table.f90,v $"
d376 5
d387 3
@


2.7
log
@Provide for functions in expressions
@
text
@d103 1
a103 1
    & "$Id: declaration_table.f90,v 2.6 2004/01/16 23:51:23 vsnyder Exp $"
d239 5
a243 1
        call display_string ( phyq_indices(decl_table(decl)%units) )
d377 3
@


2.6
log
@Add more declaration table types for Algebra
@
text
@d24 2
a25 2
  public :: ENUM_VALUE, EXPRN, EXPRN_M, EXPRN_V, FIELD, GET_DECL, INIT_DECL
  public :: LABEL, LOG_VALUE, NAMED_VALUE, NULL_DECL, NUM_VALUE
d40 1
d60 3
a62 2
  integer, parameter :: LABEL = 6       ! A "name:" label for a stru
  integer, parameter :: LOG_VALUE = 7   ! Entity is a logical value, value is
d64 2
a65 2
  integer, parameter :: NAMED_VALUE = 8 ! X = expr
  integer, parameter :: NUM_VALUE = 9   ! Entity is a numeric value, value is
d67 10
a76 10
  integer, parameter :: RANGE = 10      ! A range -- not used in decl table
  integer, parameter :: SECTION = 11    ! Name of a section
  integer, parameter :: SECTION_NODE = 12 ! Tree node of a section
  integer, parameter :: STR_RANGE = 13  ! String range -- for dates
  integer, parameter :: STR_VALUE = 14  ! The string is the value
  integer, parameter :: SPEC = 15       ! Name of a specification, e.g. vGrid
  integer, parameter :: TREE_NODE = 16  ! Name of a tree node, e.g. n_plus
  integer, parameter :: TYPE_NAME = 17  ! Name of a data type
  integer, parameter :: UNDECLARED = 18 ! Entity is undeclared
  integer, parameter :: UNITS_NAME = 19 ! Name is a units name, e.g. km, hPa
d82 4
a85 3
     'field     ', 'label     ', 'log_value ', 'nam_value ', 'num_value ', &
     'range     ', 'section   ', 'section_n ', 'str_range ', 'str_value ', &
     'spec      ', 'tree      ', 'type_name ', 'undeclared', 'units     ' /)
d89 5
a93 4
  (/ 0,               0, 0,         0, 0, &
     0,               0, t_boolean, 0, t_numeric, &
     t_numeric_range, 0, 0,         0, t_string, &
     0,               0, 0,         0, 0 /)
d103 1
a103 1
    & "$Id: declaration_table.f90,v 2.5 2002/10/08 00:09:08 pwagner Exp $"
d373 3
@


2.5
log
@Added idents to survive zealous Lahey optimizer
@
text
@d24 3
a26 2
  public :: ENUM_VALUE, EXPRN, FIELD, GET_DECL, INIT_DECL, LABEL, LOG_VALUE
  public :: NAMED_VALUE, NULL_DECL, NUM_VALUE, PRIOR_DECL, RANGE, REDECLARE
d36 3
a38 1
                              ! "spec" => Index of specification
d41 1
d52 9
a60 5
  integer, parameter :: EXPRN = 2       ! The "tree" field points to an
                                        ! unevaluated expression
  integer, parameter :: FIELD = 3       ! Field of a structure definition
  integer, parameter :: LABEL = 4       ! A "name:" label for a stru
  integer, parameter :: LOG_VALUE = 5   ! Entity is a logical value, value is
d62 2
a63 2
  integer, parameter :: NAMED_VALUE = 6 ! X = expr
  integer, parameter :: NUM_VALUE = 7   ! Entity is a numeric value, value is
d65 10
a74 10
  integer, parameter :: RANGE = 8       ! A range -- not used in decl table
  integer, parameter :: SECTION = 9     ! Name of a section
  integer, parameter :: SECTION_NODE = 10 ! Tree node of a section
  integer, parameter :: STR_RANGE = 11  ! String range -- for dates
  integer, parameter :: STR_VALUE = 12  ! The string is the value
  integer, parameter :: SPEC = 13       ! Name of a specification, e.g. vGrid
  integer, parameter :: TREE_NODE = 14  ! Name of a tree node, e.g. n_plus
  integer, parameter :: TYPE_NAME = 15  ! Name of a data type
  integer, parameter :: UNDECLARED = 16 ! Entity is undeclared
  integer, parameter :: UNITS_NAME = 17 ! Name is a units name, e.g. km, hPa
d79 4
a82 4
  (/ 'empty     ', 'enum_value', 'exprn     ', 'field     ', 'label     ', &
     'log_value ', 'nam_value ', 'num_value ', 'range     ', 'section   ', &
     'section_n ', 'str_range ', 'str_value ', 'spec      ', 'tree      ', &
     'type_name ', 'undeclared', 'units     ' /)
d86 4
a89 2
  (/ 0, 0, 0, 0, 0, t_boolean, 0, t_numeric, t_numeric_range, 0, 0, 0, &
     t_string, 0, 0, 0, 0, 0 /)
d99 1
a99 1
    & "$Id: declaration_table.f90,v 2.4 2002/07/18 22:04:06 vsnyder Exp $"
d369 3
@


2.4
log
@Improve some debugging print
@
text
@d89 1
a89 1
    & "$Id: declaration_table.f90,v 2.3 2001/04/16 23:05:29 vsnyder Exp $"
d93 1
d352 4
d359 3
@


2.3
log
@SAVE some module variables
@
text
@d89 1
a89 1
    & "$Id: declaration_table.f90,v 2.2 2001/04/05 01:28:06 vsnyder Exp $"
d181 7
a187 2
      call output ( ', TYPE = ' ); call output ( type )
      call output ( ', UNITS = ' ); call output ( units )
d202 1
a202 1
    call output ( ' dec str', advance='yes' )
d216 1
a216 1
      call output ( symbol, 4 ); call output ( ': ' )
d354 3
@


2.2
log
@Add 'increase the symbol declaration table size' code
@
text
@d82 4
a85 4
  type(decls), private, allocatable :: DECL_TABLE(:)
  integer, private :: NUM_DECLS                   ! amount of decl_table used
  integer, private, allocatable :: SYMBOL_DECL(:) ! indexed by string index,
                                                  ! gives index in decl_table.
d88 4
a91 3
  character (len=256), private :: Id = &
       "$Id: declaration_table.f90,v 2.1 2000/10/11 18:57:28 vsnyder Exp $"
  character (len=*), private, parameter :: ModuleName= &
d349 3
@


2.1
log
@Move from lib/cf_parser to lib; insert copyright notice
@
text
@d42 2
a43 2
  integer, parameter :: NULL_DECL = 0 ! Index and type of the null
                                              ! declaration
d89 1
a89 1
       "$Id: declaration_table.f90,v 2.0 2000/09/05 17:41:49 dcuddy Exp $"
d135 1
a135 1
  pure type(decls) function DECLARATION ( STRING )
d137 2
a150 1
    integer, allocatable :: OLD_SYM(:)
d172 2
a175 19
    if ( string > string_table_size() ) then
    ! Double size of string-to-declaration index table.
      allocate ( old_sym(0:ubound(decl_table,1)), stat=stat )
      if ( stat /= 0 ) then
        call io_error &
        ( 'DECLARATION_TABLE%DECLARE-E- Unable to allocate storage', stat )
        stop
      end if
      old_sym = symbol_decl
      deallocate ( symbol_decl )
      allocate( symbol_decl(0:2*size(old_sym)), stat=stat )
      if ( stat /= 0 ) then
        call io_error &
        ( 'DECLARATION_TABLE%DECLARE-E- Unable to allocate storage', stat )
        stop
      end if
      symbol_decl(0:ubound(old_sym,1)) = old_sym
      deallocate ( old_sym )
    end if
d186 1
a186 1
  pure logical function DECLARED ( STRING )
d188 2
d205 2
d293 2
d310 35
d348 3
@

