head	2.42;
access;
symbols
	v5-02-NRT-19:2.42
	v6-00:2.42
	v5-02-NRT-18:2.42
	v5-02:2.33
	v5-01-NRT-17:2.42
	v5-01-NRT-16:2.42
	v5-01-NRT-15:2.42
	v5-01-NRT-14:2.41
	neuralnetworks-1-0:2.40.0.4
	cfm-single-freq-0-1:2.40.0.2
	v5-01:2.33
	v5-00:2.33
	v4-23-TA133:2.29.0.2
	mus-emls-1-70:2.27.0.2
	rel-1-0-englocks-work:2.25.0.2
	VUMLS1-00:2.16
	VPL1-00:2.11
	V4-22-NRT-08:2.11
	VAM1-00:2.10
	V4-21:2.8.0.2
	V4-13:2.3
	V4-12:2.2
	V4-11:2.2
	V4-10:2.2;
locks; strict;
comment	@# @;


2.42
date	2021.09.09.23.23.15;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2021.07.22.23.20.14;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2020.06.30.23.18.07;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2020.06.09.21.56.32;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2020.04.30.23.09.54;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2020.04.27.21.32.07;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2019.11.11.23.08.27;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2019.10.30.20.07.18;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2019.10.01.23.40.51;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2019.08.01.23.44.25;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2019.07.17.20.19.21;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2019.07.09.23.52.17;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2019.05.15.23.20.43;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2019.02.21.22.35.26;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2019.01.24.18.33.20;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2018.05.11.20.33.36;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2018.04.19.23.42.20;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2018.01.05.01.21.16;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2018.01.03.01.13.51;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2017.12.22.00.25.24;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2017.12.14.23.20.48;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2017.11.30.20.48.59;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2017.11.15.00.01.51;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2017.10.03.21.44.11;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2017.09.29.00.20.27;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2017.09.07.23.43.40;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2017.01.19.23.33.23;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2017.01.13.01.28.32;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2016.12.14.01.22.40;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2016.11.15.19.27.19;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2016.09.22.22.21.16;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2016.03.25.00.37.06;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2015.09.24.18.50.41;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2015.05.18.17.42.50;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2015.02.24.23.32.22;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2015.02.13.00.17.49;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2015.02.10.01.00.58;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2015.02.06.01.08.20;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2014.10.06.23.06.26;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2014.09.05.00.23.57;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2014.04.22.16.30.57;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2014.01.09.00.22.32;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.42
log
@Show memory_used and its change since last memory report
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module HighOutput

  ! Very high level printing and formatting
  
  ! See also Dump_0 and Output_M
  
  use Dates_Module, only: BuildCalendar, DaysInMonth, &
    & ReformatDate, ReformatTime, Utc_To_Yyyymmdd
  use Machine, only: Crash_Burn, Exit_With_Status, NeverCrash
  use MLSCommon, only: LineLen, MLSDebug, MLSVerbose
  use MLSFinds, only: FindFirst, FindNext
  use MLSStringLists, only: ExpandStringRange, GetStringElement, &
    & List2Array, NumStringElements, SwitchDetail, Wrap
  use MLSStrings, only: Asciify, Indexes, Justify, Lowercase, &
    & NCharsInFormat, Ncopies, &
    & Replace, Stretch, Trim_Safe, WriteIntsToChars
  use Output_M, only: Advance_Is_Yes_Or_No, Blanks, GetOutputStatus, &
    & MaxOutputLineslen, Newline, &
    & Output, Output_ => Output_Char_Nocr, &
    & RestoreOutputSettings => RestoreSettings, &
    & OutputOptions, OutputOptions_T, PatternOptions_T, &
    & StampOptions, StampOptions_T, &
    & TimeStampOptions, TimeStampOptions_T, &
    & BothPrUnit, InvalidPrUnit, MSGLogPrUnit, &
    & OutputLines, OutputLinesPrUnit, SetOutputStatus, StdoutPrUnit
  use PrintIt_M, only: AssembleFullLine, Get_Config, &
    & MLSMSG_Crash, MLSMSG_Debug, &
    & MLSMSG_Severity_To_Quit, &
    & MLSMSG_Warning, &
    & PrintItOut, MLSMessageConfig, SeverityNamesFun
  use Toggles, only: Switches
  implicit none
  private

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -
!     (datatypes)
! StyleOptions             How Banners and Headlines will appear
!     (subroutines and functions)
! AddRow                   Add a {name, value} row to a 2-d table of cells
! AddRow_header            Add a single line stretched across an entire row
! AddRow_divider           Add a row composed of a single, repeated character
! AlignToFit               Align printed argument to fit column range
! Banner                   Surround message with stars and stripes; e.g.,
!                            *-----------------------------------------------*
!                            *            Your message here                  *
!                            *-----------------------------------------------*
! BeVerbose                Should we print extra, optional data?
! BlanksToColumn           Print blanks [or fill chars] out to specified column
! BlanksToTab              Print blanks [or fill chars] out to next tab stop
! Dump                     Dump output, pattern, or stamp options
! Dumpsize                 Print a nicely-formatted memory size 
! Dumptabs                 Print the current tab stop positions
! FinalMemoryReport        Print a summary of memory allocated/deallocated
! GetStamp                 Get stamp being added to every output
! HeadLine                 Print a line with eye-catching features
!                           e.g., '*-------  Your message here   -------*'
! LetsDebug                Should we print extra debugging data?
! NextColumn               Return next column number that would be printed
! NextTab                  Return next column number that Tab would move to
! NumNeedsFormat           Return what format is needed to output num
! NumToChars               Return what string would be printed by output
! OutputCalendar           Output nicely-formatted calendar page
! Output_Date_And_Time     Print nicely formatted date and time
! OutputList               Output array as comma-separated list; e.g. '(1,2,..)'
! OutputNamedValue         Print nicely formatted name and value
! OutputParagraph          Print text formatted as a paragraph with line breaks, 
!                            indent, etc.
! OutputTable              Output 2-d array as cells in table,; or else
!                          Output the 2d table of cells constucted by AddRow(s)
! ResetTabs                Restore tab stops to what was in effect at start
! RestoreSettings          Restore default settings for output, styles, tabs
! SetStamp                 Set stamp to be automatically printed on every line
! SetTabs                  Set tab stops (to be used by tab)
! StartTable               Initialize a 2-d table of cells to be output later
! StyledOutput             Output a line according to options; e.g. "--Banner"
! Tab                      Move to next tab stop
! Timestamp                Print argument with a timestamp manually
!                            (both stdout and logged output)
! === (end of toc) ===

! === (start of api) ===
! AddRow ( char* name, value, [int BlocLen], [char* options], [char* format] )
! AddRow_header ( char* name, char alignment )
! AddRow_divider ( char char )
! AlignToFit ( char* chars, int columnRange(2), char alignment, [int skips] )
! Banner ( char* chars, [int columnRange(2)], [char alignment], [int skips], 
!    [int lineLength], [char mode], [char pattern], [log underline] )
! log BeVerbose ( char* switch[(:)], threshold )
! BlanksToColumn ( int column, [char fillChar], [char* advance] )
! BlanksToTab ( [int tabn], [char* fillChar] )
! Dump ( options )
! DumpSize ( n, [char* advance], [units] )
!       where n can be an int or a real, and 
!       units is a scalar of the same type, if present
! DumpTabs ( [int tabs(:)] )
! FinalMemoryReport ( [log IsFinal] )
! GetStamp ( [char* textCode], [log post], [int interval],
!          [log showTime], [char* dateFormat], [char* timeFormat] )
! HeadLine ( char* chars, 
!          [char fillChar], [char* Before], [char* After], 
!          [int columnRange(2)], [char alignment], [int skips], [log underline] )
! log LetsDebug ( char* switch[(:)], threshold )
! int NextColumn ( )
! int NextTab ( )
! char* NumNeedsFormat ( value )
! char* NumToChars ( value, [char* format] )
! Output_Date_And_Time ( [log date], [log time], [char* from_where], 
!          [char* msg], [char* dateFormat], [char* timeFormat], 
!          [double CPU_seconds], [int wallClock_seconds], [char* advance] )
! OutputCalendar ( [char* date], [char* datenote], [char* notes(:)], 
!          [log dontwrap, [log moonPhases] ] )
! OutputList ( values(:), [char* sep], [char* delims] )
! OutputNamedValue ( char* name, value, [char* advance],
!          [char colon], [char fillChar], [char* Before], [char* After], 
!          [integer tabn], [integer tabc], [integer taba], log dont_stamp],
!          [char* options] )
! OutputParagraph ( char* text, int ColumnRange(2), [char* alignment], &
!          [int indent] )
! OutputTable ( [array(:,:)], [char sep], [char border], [int cellWidth],
!          [char interior], [char headliner], [char alignment] )
! ResetTabs ( [int tabs(:)] )
! RestoreSettings ( [char* settings] )
! SetStamp ( [char* textCode], [log post], [int interval],
!          [log showTime], [char* dateFormat], [char* timeFormat] )
! SetTabs ( [char* Range], [int tabs(:)] )
! StartTable
! StyledOutput ( char* chars, [char* options] )
! Tab ( [int tabn], [char* fillChar] )
! TimeStamp ( char* chars, [char* advance], [char* from_where], 
!          [log dont_log], [char* log_chars], [char* insteadOfBlank],
!          [char*8 style], [log date] )
! TimeStamp ( log value, [char* advance], [char* from_where], 
!          [log dont_log], [char* log_chars], [char* insteadOfBlank],
!          [char*8 style], [log date] )
! TimeStamp ( int int, [int places], [char* advance],
!          [log fill], [char* format], [char* Before], [char* After],
!          [char*8 style], [log date] )
! === (end of api) ===
!
! Note:
! By calling appropriate functions and procedures you can adjust aspects of
! behavior of output, and others can be changed by setting various
! public global parameters directly
! (in OO-speak they are class-level rather than instance-level)
! Sometimes there is more than one way to accomplish the same thing
! E.g., calling TimeStamp or else using SetStamp before calling output
!
! To understand the codes for DateFormat and TimeFormat, see the Dates_Module
! 
! Here's how to build and print a 2d table of names and values
! (1) Call startTable
! (2) Optionally call AddRow_header
! (3) Optionally call AddRow_divider
! (4) For each name, value pair
!     (a) call AddRow
!     (b) call AddRow_Divider
! (5) Call OutputTable
!
! (see CellDatabase)
!
! The aligment arg in AlignToFit, etc.  can be explained best with an example,
! in fact 4 different examples (showing L, R, C, and J in that order)
! ------------------------------------------------------------------------------
! The first line is L                                                               
!                                                           The second line is R
!                               The third line is C                                
! The                                 final                                 line
! ------------------------------------------------------------------------------
! The same 4 styles can be applied to Banner and StyledOutput by
! suitable choices of the options arg.
!
! A better programmer would make a '--help' option
! available for most of these procedures
! and maybe the whole module, too.

! A general rule to be remembered always:
!    * There's no software that can't be improved *
! which is a corollary of the more biting and disheartening rule
!    * There's no software that is free of bugs *


  public :: AddRow, AddRow_Divider, AddRow_Header, AlignToFit, &
    & Banner, BeVerbose, BlanksToColumn, BlanksToTab, &
    & Dump, DumpSize, DumpTabs, FinalMemoryReport, GetStamp, HeadLine, &
    & LetsDebug, NextColumn, NextTab, NumNeedsFormat, NumToChars, &
    & Output_Date_And_Time, OutputCalendar, OutputList, OutputTable, &
    & OutputAnyNamedValue, OutputNamedValue, OutputParagraph, &
    & ResetTabs, RestoreSettings, &
    & SetStamp, SetTabs, StartTable, StyledOutput, Tab, TimeStamp

  ! These types must be made public because the class instances are public
  public :: OutputOptions_T
  public :: StampOptions_T
  public :: TimeStampOptions_T

  interface AddRow
    module procedure AddRow_Character, AddRow_Character_Blocs
    module procedure AddRow_Complex
    module procedure AddRow_Dbl_Array, AddRow_Double
    module procedure AddRow_Int_Array, AddRow_Integer
    module procedure AddRow_Log_Array, AddRow_Logical
    module procedure AddRow_Sngl_Array, AddRow_Single
  end interface

  interface AlignToFit
    module procedure AlignToFit_Chars, AlignToFit_Double, AlignToFit_Single
    module procedure AlignToFit_Integer
  end interface

  interface Banner
    module procedure Banner_Chars
    module procedure Banner_Chararray
  end interface

! Other modules may interrogate Beverbose or LetsDebug to decide whether or not
! to print some intermediate results or messages.
! Do these really belong here, or somewhere else?
  interface Beverbose
    module procedure Beverbose_Chars
    module procedure Beverbose_Chararray
  end interface

  interface Letsdebug
    module procedure Letsdebug_Chars
    module procedure Letsdebug_Chararray
  end interface

  interface Dump
    module procedure DumpOutputOptions, DumpPatternOptions, &
      & DumpStampOptions, DumpTimeStampOptions
  end interface

  interface Dumpsize
    module procedure Dumpsize_Double, Dumpsize_Integer, Dumpsize_Real
  end interface

  interface Getoption
    module procedure Getoption_Char, Getoption_Log
  end interface

  interface NumNeedsFormat
    module procedure NumNeedsFormat_Double, NumNeedsFormat_Integer, NumNeedsFormat_Single
    module procedure NumNeedsFormat_Complex, NumNeedsFormat_Dcomplx
  end interface

  interface NumToChars
    module procedure NumToChars_Double, NumToChars_Integer, NumToChars_Single
  end interface

  interface OutputList
    module procedure OutputList_Ints, OutputList_Chars
  end interface

  interface OutputnamedValue
    module procedure Output_Nvp_Character
    module procedure Output_Nvp_Complex
    module procedure Output_Nvp_Dbl_Array, Output_Nvp_Double
    module procedure Output_Nvp_Int_Array, Output_Nvp_Integer
    module procedure Output_Nvp_Log_Array, Output_Nvp_Logical
    module procedure Output_Nvp_Sngl_Array, Output_Nvp_Single
  end interface

  interface OutputanynamedValue
    module procedure Output_Nvp_Whatever
  end interface

  interface Tab
    module procedure Blankstotab
  end interface
  
  interface TimeStamp
    module procedure TimeStamp_Char, TimeStamp_Integer, TimeStamp_Logical
  end interface
  
  ! -------------------------------------------------------------------------
  ! *      Module settings, parameters, and data types                      *
  ! When Calling OutputNamedValue with character values, should we trim them?
  logical, public        :: TrimCharacterValues = .true.
  logical, save, private :: OldNeverStamp
  integer, save, private :: OLDWRAPPASTCOLNUM = 0
  integer, save, private :: WRAPPASTCOLNUM = 0  ! Don't print beyond (if > 0)
  
  ! -------------------------------------------------------------------------
  ! Used for automatic assembly of a table to be neatly formatted and output
  ! The table holds two columns:
  ! names and values  
  ! It might look something like the following
  ! ------------------------------------------------------------
  ! - names  values                                            -
  ! ------------------------------------------------------------
  ! - true   true                                              -
  ! - false  false                                             -
  ! - count  count                                             -
  ! - l2cf   /users/mmadatya/l2tests/ASMLS/AS-01-009-QTM.l2cf  -
  ! ------------------------------------------------------------
  integer, parameter :: MAXCELLSIZE = 128 ! How many chars can 1 cell hold
  character(len=MAXCELLSIZE), dimension(:,:), pointer :: CellDatabase => null()
  ! -------------------------------------------------------------------------

  ! -------------------------------------------------------------------------
  ! * Tabs                                                                    *
  integer, private, parameter :: MAXNUMTABSTOPS = 24
  ! These next tab stops can be reset using the procedure setTabs
  ! the default values correspond to range coded '5-120+5'
  ! (read as from 5 to 120 in intervals of 5)
  character(len=*), parameter :: INITTABRANGE = '5-120+5'
  integer, dimension(MAXNUMTABSTOPS), save, private :: TABSTOPS = &
    & (/ 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, &
    &   65, 70, 75, 80, 85, 90, 95,100,105,110,115,120 /)

  ! -------------------------------------------------------------------------
  ! For certain numerical values we will use list directed '*' format
  ! unless optional FORMAT specifier supplied
  double precision, parameter, dimension(3) :: DPREFERDEFAULTFORMAT = &
    & (/ -1.d0, 0.d0, 1.d0 /)  ! For which values to use default format '*'
  character(len=12), private :: sdNeedsFormat = '(1pg14.6)'
  character(len=12), private :: sdNeedsFragment = '(1pg14'

  ! -------------------------------------------------------------------------
  ! This is the type for configuring how to automatically style 
  ! special output formats; e.g., Banner
  ! Note the effect on the "bars" part of "stars and bars"
  ! of choosing different HeadLineFill or BannerPattern characters:
!------------------------------------------------------------------------------*
!                            Test Banner Pattern: -                            *
!------------------------------------------------------------------------------*
!*******************************************************************************
!                            Test Banner Pattern: *                            *
!*******************************************************************************
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
!                            Test Banner Pattern: +                            *
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
!##############################################################################*
!                            Test Banner Pattern: #                            *
!##############################################################################*
!                                                                              *
!                            Test Banner Pattern: 0                            *
!                                                                              *
!. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   *
!                            Test Banner Pattern: 1                            *
!. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   *
! . .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .  *
!                            Test Banner Pattern: 2                            *
! . .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .  *
! .  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  . *
!                            Test Banner Pattern: 3                            *
! .  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  . *
! .   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   .  *
!                            Test Banner Pattern: 4                            *
! .   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   .  *
! .. .... .... .... .... .... .... .... .... .... .... .... .... .... .... ..  *
!                            Test Banner Pattern: 5                            *
! .. .... .... .... .... .... .... .... .... .... .... .... .... .... .... ..  *
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   *
!                            Test Banner Pattern: 6                            *
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   *
! - -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -  *
!                            Test Banner Pattern: 7                            *
! - -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -  *
! -  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  - *
!                            Test Banner Pattern: 8                            *
! -  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  - *
! - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - ..   *
!                            Test Banner Pattern: 9                            *
! - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - ..   *
!= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   *
!                            Test Banner Pattern: A                            *
!= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   *
!~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~   *
!                            Test Banner Pattern: B                            *
!~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~   *
! = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~  *
!                            Test Banner Pattern: C                            *
! = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~  *

  type StyleOptions_T
    logical                            :: Underline           = .false.
    ! HeadLine
    integer, dimension(2)              :: HeadLineColumnrange = (/ 1, 80 /)
    integer                            :: HeadLineSkips       = 0
    character(len=1)                   :: HeadLineAlignment   = 'C'
    character(len=1)                   :: HeadLineFill        = ' '
    character(len=8)                   :: HeadLineBefore      = ' '
    character(len=8)                   :: HeadLineAfter       = ' '
    logical                            :: HeadlineStretch     = .false.
    ! Banner
    integer, dimension(2)              :: BannerColumnrange   = (/ 1, 80 /)
    integer                            :: BannerSkips         = 0
    character(len=1)                   :: BannerAlignment     = 'C'
    character(len=1)                   :: BannerPattern       = '-'
    integer                            :: BannerLength        = 0
    logical                            :: BannerStretch     = .false.
  end type
  type(StyleOptions_T), private, save  :: DefaultStyleOptions
  type(StyleOptions_T), public, save   :: StyleOptions

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: highOutput.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  ! ----------------------------------------------  AddRow  -----
  ! This family of routines pairs each added name with its value
  ! by inserting a new row into the CellDatabase
  
  ! later to be printed as a neatly-formatted table to stdout
  ! By means of optional args you can create a line like
  ! *   name                   value   *
  subroutine AddRow_character_blocs ( name, value, BlocLen, &
    & options, format, wrappingChar )
    ! For character values of great length, the values may
    ! span multiple lines, which we'll call "blocs"
    ! Method: divide value up into separate blocs, each BlocLen long
    ! The 1st bloc will have its name in the name cell,
    ! later blocs won't.
    ! If options is present and contains the character 'w', the blocs
    ! will be divided at spaces (or wrappingChar if present) 
    ! instead of arbitrarily
    character(len=*), intent(in)             :: name
    character(len=*), intent(in)             :: value
    integer, intent(in)                      :: BlocLen ! How long is each bloc?
    character(len=*), intent(in), optional   :: options
    character(len=*), intent(in), optional   :: format
    character(len=*), intent(in), optional   :: wrappingChar
    ! Local variables
    integer                                  :: BlocLength
    character(len=1)                         :: break
    integer, parameter                       :: MaxNBlocs = 50
    integer                                  :: c1, c2 ! 1st and last positions
    integer                                  :: i
    character(len=1)                         :: null
    character(len=len(name))                 :: itsName
    integer                                  :: NBlocs ! How many blocs?
    character(len=len(value)+51)             :: wrapped
    logical                                  :: wrapValue
    logical, parameter                       :: DeeBug = .false.
    ! Executable
    BlocLength = max( BlocLen, 1)
    BlocLength = min(MAXCELLSIZE, BlocLength)
    wrapValue = .false.
    if ( present(options) ) wrapValue = (index( options, 'w' ) > 0)
    if ( wrapValue .and. any( indexes( trim(value), (/'"',  "'"/) ) > 0 ) ) then
      call myMessage ( MLSMSG_Warning, 'AddRow_character_blocs', &
        & 'Value contains quoted material--may not wrap properly' )
      ! wrapValue = .false.
    endif
    nBlocs = ( len_trim(value ) - 1)/BlocLength + 1
    if ( wrapvalue ) then
      ! Instead of wrapping hard at fixed bloc sizes, 
      ! try to wrap soft at spaces
      null = achar(10)
      break = ' '
      if ( present(wrappingChar) ) break = wrappingChar
      if ( DeeBug ) call output( trim(value), advance='yes' )
      call wrap( trim(value), wrapped, BlocLength, inseparator=null, &
        & mode='soft', break=break, addedLines=nBlocs )
      wrapped = adjustl(wrapped) ! Still unsure why this is necessary
      if ( DeeBug ) call output( trim(wrapped), advance='yes' )
      nBlocs = nBlocs + 1
      if ( DeeBug ) call outputNamedValue ( 'nBlocs', nBlocs )
      itsName = name
      c2 = 0
      do i=1, nBlocs
        c1 = c2 + 1
        if ( i < 2 ) then
          c2 = FindFirst( wrapped, null )
        elseif ( c1 > len_trim(wrapped) ) then
          exit
        else
          c2 = FindNext( wrapped, null, current=c1 )
        endif
        c2 = c2 - 1 ! Back up to last non-breaking character
        if ( wrapped(c1:c1) == null ) c1 = c1 + 1
        if ( c2 < c1 ) then
          c2 = len_trim(wrapped)
        endif
        call AddRow_character ( itsName, wrapped(c1:c2), format )
        if ( DeeBug ) call output( (/c1, c2/), advance='yes' )
        if ( DeeBug ) call output( wrapped(c1:c2), advance='yes' )
        itsName = ' ' ! A trick so blocs after 1st are nameless
      enddo
      return
    endif
    nBlocs = min( MaxNBlocs, NBlocs )
    itsName = name
    c2 = 0 ! A trick making 1st bloc start at position 1
    do i=1, nBlocs
      c1 = c2 + 1
      c2 = min(c2 + BlocLength, len_trim(value) )
      call AddRow_character ( itsName, value(c1:c2), format )
      itsName = ' ' ! A trick so blocs after 1st are nameless
    enddo
  end subroutine AddRow_character_blocs

  subroutine AddRow_character ( name, value, format )
    character(len=*), intent(in)          :: name
    character(len=*), intent(in)          :: value
    include 'addRow.f9h'
  end subroutine AddRow_character

  subroutine AddRow_complex ( name, value, format )
    character(len=*), intent(in)          :: name
    complex, intent(in)                   :: value
    include 'addRow.f9h'
  end subroutine AddRow_complex

  subroutine AddRow_double ( name, value, format )
    character(len=*), intent(in)          :: name
    double precision, intent(in)                   :: value
    include 'addRow.f9h'
  end subroutine AddRow_double

  subroutine AddRow_dbl_array ( name, value, format )
    character(len=*), intent(in)          :: name
    double precision, dimension(:), intent(in)     :: value
    include 'addRow.f9h'
  end subroutine AddRow_dbl_array

  subroutine AddRow_int_array ( name, value, format )
    character(len=*), intent(in)          :: name
    integer, dimension(:), intent(in)     :: value
    include 'addRow.f9h'
  end subroutine AddRow_int_array

  subroutine AddRow_integer ( name, value, format )
    character(len=*), intent(in)          :: name
    integer, intent(in)                   :: value
    include 'addRow.f9h'
  end subroutine AddRow_integer

  subroutine AddRow_log_array ( name, value, format )
    character(len=*), intent(in)          :: name
    logical, dimension(:), intent(in)     :: value
    include 'addRow.f9h'
  end subroutine AddRow_log_array

  subroutine AddRow_logical ( name, value, format )
    character(len=*), intent(in)          :: name
    logical, intent(in)                   :: value
    include 'addRow.f9h'
  end subroutine AddRow_logical

  subroutine AddRow_single ( name, value, format )
    character(len=*), intent(in)          :: name
    real, intent(in)                      :: value
    include 'addRow.f9h'
  end subroutine AddRow_single

  subroutine AddRow_sngl_array ( name, value, format )
    character(len=*), intent(in)          :: name
    real, dimension(:), intent(in)     :: value
    include 'addRow.f9h'
  end subroutine AddRow_sngl_array

  subroutine AddRow_header ( name, alignment )
    character(len=*), intent(in)          :: name
    character(len=1), intent(in)          :: alignment !: 'l(eft)', 'c', or 'r'
    character(len=MAXCELLSIZE), dimension(2)   :: item = ' '
    integer                                    :: newSize
    item(1) = '<<' // alignment // '>>' // name
    newSize = addCellRowToDatabase( cellDatabase, item )
  end subroutine AddRow_header

  subroutine AddRow_divider ( char )
    character(len=1), intent(in)          :: char
    character(len=MAXCELLSIZE), dimension(2)   :: item = ' '
    integer                                    :: newSize
    item(1) = '<<' // 'd' // '>>' // char
    newSize = addCellRowToDatabase( cellDatabase, item )
  end subroutine AddRow_divider

  ! -----------------------------------------------------  AlignToFit  -----
  ! Align chars to fit within column range
  ! Alignment controls whether the chars are
  ! L    Flushed left
  ! R                                              Flushed right
  ! C                 Centered
  ! J    Justified       (padding spaces to any existing spaces)
  subroutine AlignToFit_Chars ( chars, columnrange, alignment, skips )
    character(len=*), intent(in)                :: Chars
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), intent(in)           :: Columnrange
    character(len=1), intent(in), optional      :: Alignment ! L, R, C, or J
    integer, optional, intent(in)               :: Skips ! How many spaces between chars
    !
    ! Internal variables
    character(len=max(len(chars), abs(columnRange(2)-columnRange(1)))) :: &
      & Allchars
    character(len=max(len(chars), abs(columnRange(2)-columnRange(1)))) :: &
      & Justified
    integer :: char1
    integer :: char2
    integer :: firstSpace
    integer :: m
    integer :: nc
    integer :: padLeft
    integer :: padRight
    integer :: spaces
    ! Executable
    allChars = chars
    if ( present(skips) ) then
      if ( skips > 0 .and. len_trim(chars) > 0 ) then
        allChars = stretch( chars, skips, options='a' )
      end if
    end if
    if ( columnRange(1) > 0 ) then
      spaces = columnRange(2) - max( columnRange(1), getOutputStatus( 'column' ) )
      if ( spaces < 1 ) return
      if ( columnRange(1) > getOutputStatus( 'column' ) ) &
        & call blanks( columnRange(1) - getOutputStatus( 'column' ) )
    else
      spaces = columnRange(2) - columnRange(1)
    end if
    firstSpace = 0
    nc = max( len_trim(allchars), 1 )
    ! Why was this necessary? Are there nulls?
    ! if ( nc > 1 .and. allchars(nc:nc) == ' ' ) nc = nc - 1
    select case (lowercase(alignment))
    case ('l')
      char1    = 1
      padLeft  = 0
      char2    = min( nc, spaces )
      padRight = spaces - char2
    case ('r')
      char1    = max(1, nc-spaces+1)
      char2    = nc
      padLeft  = spaces - (char2-char1)
      padRight = 0
    case ('j')
      ! print *, 'columnRange: ', columnRange
      nc = abs(columnRange(2) - columnRange(1)) + 1
      Justified = Justify( allChars, nc )
      call output_( Justified(1:nc) )
      return
    case ('c')
    ! case ('c', 'j')
      m = (spaces - nc) / 2
      padLeft  = max( m, 0 )
      padRight = max( spaces - nc - m, 0 )
      char1 = max(1-m, 1)
      char2 = min(nc+m, nc)
      if ( lowercase(alignment) == 'j' .and. padRight > 0 ) &
        & firstSpace = index( allChars, ' ' )
    end select
    ! print *, 'char1, char2, padLeft, padRight, firstSpace ', &
    !   & char1, char2, padLeft, padRight, firstSpace
    ! print *, 'nc, alignment, char(char2): ', &
    !   & nc, lowercase(alignment), allChars(char2:char2)
    if ( firstSpace > 1 ) then
      call output_( allChars(char1:firstSpace-1) )
      call blanks( padRight+padLeft+1 )
      if ( firstSpace+1 < char2 ) call output_( allChars(firstSpace+1:char2) )
    else
      call blanks( padLeft )
      call output_( allChars(char1:char2) )
      call blanks( padRight )
    end if
  end subroutine AlignToFit_Chars

  subroutine AlignToFit_Double ( value, columnrange, alignment, format )
    double precision, intent(in)                :: value
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: Columnrange
    character(len=1), intent(in), optional      :: Alignment ! L, R, C, or J
    character(len=*), optional, intent(in)      :: FORMAT
    !
    ! Internal variables
    character(len=30) :: line
    ! Executable
    line = numToChars( value, format )
    call AlignToFit( trim(line), columnRange, alignment )
  end subroutine AlignToFit_Double

  subroutine AlignToFit_Integer ( value, columnrange, alignment, format )
    integer, intent(in)                         :: value
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: Columnrange
    character(len=1), intent(in), optional      :: Alignment ! L, R, C, or J
    character(len=*), optional, intent(in)      :: FORMAT
    !
    ! Internal variables
    character(len=30) :: line
    ! Executable
    line = numToChars( value, format )
    call AlignToFit( trim(line), columnRange, alignment )
  end subroutine AlignToFit_Integer

  subroutine AlignToFit_Single ( value, columnrange, alignment, format )
    real, intent(in)                            :: value
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: Columnrange
    character(len=1), intent(in), optional      :: Alignment ! L, R, C, or J
    character(len=*), optional, intent(in)      :: FORMAT
    !
    ! Internal variables
    character(len=30) :: line
    ! Executable
    line = numToChars( value, format )
    call AlignToFit( trim(line), columnRange, alignment )
  end subroutine AlignToFit_Single

  ! -----------------------------------------------------  Banner  -----
  ! Surround your message with stars and stripes; e.g.,
  ! *-----------------------------------------------*
  ! *            Your message here                  *
  ! *-----------------------------------------------*
  ! proclaiming its great importance to an uncaring world.
  ! For multiline messages, you may divide them into elements of
  ! a character array, or else a longer character scalar and
  ! supply LineLength asking the routine to wrap at word boundaries
  !
  ! Another way to combine multiple mesgs is like this
  !   call Banner ( first, Bottomless=.true. )
  !   call Banner ( second, Bottomless=.true., Topless=.true. )
  !     .   .   .
  !   call Banner ( last, Topless=.true. )
  !
  ! See also HeadLine, StyledOutput
  subroutine Banner_Chars ( inChars, &
    & columnRange, alignment, skips, lineLength, &
      & mode, pattern, underline, Stretched, Topless, Bottomless )
    character(len=*), intent(in)                :: inChars
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: Columnrange
    character(len=1), intent(in), optional      :: Alignment ! L, R, C, or J
    integer, optional, intent(in)               :: Skips ! How many spaces between chars
    integer, optional, intent(in)               :: Linelength
    character (len=*), optional, intent(in)     :: mode ! if not 'hard'
    character (len=1), optional, intent(in)     :: pattern ! if not stripes
    logical, optional, intent(in)               :: underline ! beneath non-blank chars
    logical, optional, intent(in)               :: Stretched   ! s t r e t c h
    logical, optional, intent(in)               :: Topless     ! skip top stripe
    logical, optional, intent(in)               :: Bottomless  ! skip bottom
    !
    ! Internal variables
    integer                          :: addedLines
    character(len=160), dimension(:), allocatable :: lines
    character(len=2*len(inchars))    :: Chars
    integer                          :: lineLen, mySkips, padding
    character(len=1)                 :: myAlignment              
    character(len=1)                 :: myFillChar               
    integer, dimension(2)            :: myColumnRange            
    logical                          :: myStretched
    logical                          :: myUnderline              
    logical, parameter               :: DEBUG = .false.          
    logical                          :: skipTop
    logical                          :: skipBottom
    character(len=len(chars))        :: underlineChars
    character(len=2*len(chars))      :: wrappedChars
    ! Executable
    Chars = ' '
    myAlignment = StyleOptions%BannerAlignment ! 'C'
    if ( present(alignment) ) myAlignment = alignment
    mySkips = StyleOptions%BannerSkips ! 0
    if ( present(skips) ) mySkips = skips
    myFillChar = StyleOptions%BannerPattern ! '-'
    if ( present(pattern) ) myFillChar = pattern
    lineLen = StyleOptions%BannerLength ! 0
    myStretched = .false.
    if ( present(Stretched) ) myStretched = Stretched
    myUnderline = .false.
    if ( present(underline) ) myUnderline = underline

    if ( present(LineLength) ) lineLen = LineLength
    if ( myStretched ) then
      Chars = Stretch ( inChars, 1, options='a' )
    else
      Chars = inChars
    endif
    skipTop = .false.
    if ( present(Topless) ) skipTop = Topless
    skipBottom = .false.
    if ( present(Bottomless) ) skipBottom = Bottomless
    if ( lineLen > 4 ) then
      ! We will wrap the input to fit within LineLength, but remembering
      ! the stars and padding
      call wrap( chars, wrappedChars, width=lineLen-4, &
        & inseparator=achar(0), addedLines=addedLines, mode=mode )
      addedLines = addedLines + 1
      allocate( lines(addedLines) )
      lines = ' '
      call List2Array( wrappedChars, lines, &
        & countEmpty=.true., inseparator=achar(0) )
      call banner( lines, alignment=alignment, pattern=pattern )
      deallocate(lines)
      return
    else if ( present(columnRange) ) then
      myColumnRange = columnRange
    elseif ( myAlignment == 'C' ) then
      lineLen = max( 80, 4 + len_trim(chars)*(1+mySkips) )
      padding = ( lineLen - len_trim(chars)*(1+mySkips) ) / 2
      myColumnRange(1) = 1 + padding
      myColumnRange(2) = lineLen - padding
    else
      lineLen = max( 80, 4 + len_trim(chars)*(1+mySkips) )
      myColumnRange(1) = 1
      myColumnRange(2) = LineLen
    end if
    
    ! define padding as the larger of columnrange(1) and 1
    padding = max( 1, myColumnRange(1) )
    LineLen = padding + myColumnRange(2) - 1
    if ( DEBUG ) then
      call outputnamedValue( 'padding', padding )
      call outputnamedValue( 'LineLen', LineLen )
      call outputnamedValue( 'myColumnRange', myColumnRange )
    end if
    ! Here we begin printing
    ! Temporarily stop Stamping lines
    OldNeverStamp = stampOptions%neverStamp
    stampOptions%neverStamp = .true.
    ! Top border
    if ( .not. SkipTop ) then
      call output( '*' )
      call blanks ( lineLen-2, FillChar=myFillChar )
      call output( '*', advance = 'yes' )
    endif
    ! Left star, then message, then right star
    call output( '*' )
    call AlignToFit( chars, myColumnRange, myAlignment, skips )
    call BlanksToColumn( lineLen )
    call output( '*', advance = 'yes' )
    if ( myUnderline .and. len_trim(chars) > 0 ) then
      ! The next trick replaces everything with a dash except spaces
      underlineChars = Replace( chars, ' ', '-', reverse=.true. )
      call output( '*' )
      call AlignToFit( underlineChars, myColumnRange, myAlignment, skips )
      call BlanksToColumn( lineLen )
      call output( '*', advance = 'yes' )
    endif
    ! Bottom border
    if ( .not. SkipBottom ) then
      call output( '*' )
      call blanks ( lineLen-2, FillChar=myFillChar )
      call output( '*', advance = 'yes' )
    endif
    ! Restore Stamping
    stampOptions%neverStamp = OldNeverStamp
  end subroutine Banner_Chars

  subroutine Banner_Chararray ( charArray, &
    & columnRange, alignment, skips, pattern )
    character(len=*), dimension(:), intent(in)  :: CHARARRAY
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: COLUMNRANGE
    character(len=1), intent(in), optional      :: ALIGNMENT ! L, R, C, or J
    integer, optional, intent(in)               :: Skips ! How many spaces between chars
    character (len=1), optional, intent(in)     :: pattern ! if not stripes
    !
    ! Internal variables
    integer :: i
    ! Internal variables
    character(len=1)      :: myAlignment
    integer, dimension(2) :: myColumnRange
    character(len=1)      :: myFillChar
    integer :: lineLen, mySkips,  padding
    ! Executable
    myAlignment = 'C'
    if ( present(alignment) ) myAlignment = alignment
    mySkips = 0
    if ( present(skips) ) mySkips = skips
    myFillChar = '-'
    if ( present(pattern) ) myFillChar = pattern
    if ( present(columnRange) ) then
      myColumnRange = columnRange
    else
      lineLen = 80
      padding = LineLen
      do i = 1, size(chararray)
        lineLen = max( lineLen, 4 + len_trim(chararray(i))*(1+mySkips) )
        padding = min( padding, &
          & ( lineLen - len_trim(chararray(i))*(1+mySkips) ) / 2 )
      end do
      myColumnRange(1) = 1 + padding
      myColumnRange(2) = lineLen - padding
    end if
    
    ! define padding as the larger of columnrange(1) and 1
    padding = max( 1, myColumnRange(1) )
    LineLen = padding + myColumnRange(2) - 1
    ! Here we begin printing
    ! Temporarily stop Stamping lines
    OldNeverStamp = stampOptions%neverStamp
    stampOptions%neverStamp = .true.
    ! Top border
    call output( '*' )
    call blanks ( lineLen-2, FillChar=myFillChar )
    call output( '*', advance = 'yes' )
    do i = 1, size(chararray)
      ! Left star, then message, then right star
      call output( '*' )
      call AlignToFit( chararray(i), myColumnRange, myAlignment, skips )
      call BlanksToColumn( lineLen )
      call output( '*', advance = 'yes' )
    end do
    ! Bottom border
    call output( '*' )
    call blanks ( lineLen-2, FillChar=myFillChar )
    call output( '*', advance = 'yes' )
    ! Restore Stamping
    stampOptions%neverStamp = OldNeverStamp
  end subroutine Banner_Chararray

  ! -----------------------------------------------------  Beverbose_Chars  -----
  logical function Beverbose_Chars ( switch, threshold )
    ! Args
    character(len=*), intent(in) :: SWITCH
    integer, intent(in)          :: THRESHOLD
    ! Executable
    Beverbose_Chars = switchDetail( switches, switch ) > threshold .or. MLSVerbose
  end function Beverbose_Chars

  logical function Beverbose_CharArray ( switcharray, threshold )
    ! Args
    character(len=*), dimension(:), intent(in) :: switcharray
    integer, intent(in)                        :: THRESHOLD
    ! Internal variables
    integer                                    :: i
    ! Executable
    Beverbose_CharArray = MLSVerbose
    if ( Beverbose_CharArray ) return
    do i=1, size(switcharray)
      Beverbose_CharArray = Beverbose_CharArray .or. &
        & switchDetail( switches, switcharray(i) ) > threshold
    enddo
  end function Beverbose_CharArray

  ! -----------------------------------------------------  BlanksToColumn  -----
  subroutine BlanksToColumn ( column, fillchar, advance, dont_stamp )
  ! Output blanks to PRUNIT out to column COLUMN.
  ! (or optionally that many copies of fillChar)
    integer, intent(in) :: COLUMN
    character(len=*), intent(in), optional :: advance
    character(len=*), intent(in), optional :: fillchar  ! default is ' '
    logical, intent(in), optional          :: dont_stamp ! Prevent double-stamping
    ! Internal variables
    integer :: nblanks
    ! Executable
    if ( getOutputStatus( 'physicalcolumn' ) == 1 ) then
      ! Don't double indent the line's first field
      nblanks = column - getOutputStatus( 'physicalcolumn' )
    else
      nblanks = column - getOutputStatus( 'column' )
    endif
    if ( nblanks < 1 ) return
    call blanks( nblanks, fillChar, advance, dont_stamp )
  end subroutine BlanksToColumn

  ! ------------------------------------------------  blanksToTab  -----
  ! Print blanks out to next tabstop
  ! (or else to tabstop number tabn)
  ! (or optionally that many copies of fillChar)
  subroutine blanksToTab ( tabn, fillChar, MayStayIfAtTab )
    ! Args
    integer, optional, intent(in)          :: TABN
    character(len=*), intent(in), optional :: FILLCHAR  ! default is ' '
    logical, intent(in), optional          :: MayStayIfAtTab
    ! Internal variables
    integer :: nColumn
    integer :: nTab
    logical :: MayStay
    ! Executable
    MayStay = .false.
    if ( present(MayStayIfAtTab) ) MayStay = MayStayIfAtTab
    if ( getOutputStatus( 'physicalcolumn' ) == 1 ) then
      ! Don't double indent the line's first field
      nColumn = getOutputStatus( 'physicalcolumn' )
    else
      nColumn = getOutputStatus( 'column' )
    endif
    if ( present(tabn) ) then
      if ( tabn < 1 .or. tabn > MAXNUMTABSTOPS ) return
      if ( nColumn < tabStops(tabn) ) &
        & call blanksToColumn( tabStops(tabn), fillChar )
    else
      if ( MayStay ) then
        nTab = findFirst( tabStops >= nColumn )
      else
        nTab = findFirst( tabStops > nColumn )
      endif
      if ( nTab > 0 ) &
        & call blanksToColumn( tabStops(nTab), fillChar )
    end if
  end subroutine blanksToTab

  ! ---------------------------------------------- DumpOutputOptions -----
  subroutine DumpOutputOptions( options )
    ! Show currently-active output options
    ! We put this here because it uses other routines from HighOutput
    ! Why aren't we using the CellDatabase?
    type(OutputOptions_T), intent(in) :: options
    ! Internal variables
    logical                      :: AlwaysWrap
    logical, parameter           :: checkingTabbing = .false.
    character(len=10), parameter :: decade = '1234567890'
    character(len=1), parameter  :: fillChar = '1' ! fill blanks with '. .'
    integer                      :: i
    integer                      :: IndentBy
    integer                      :: status
    integer                      :: WrapPastColumn
    ! Executable
    AlwaysWrap = options%AlwaysWrap
    WrapPastColumn = options%WrapPastColumn
    IndentBy = GetOutputStatus ( 'indent' )
    call blanks(80, fillChar='-', advance='yes')
    call HeadLine( 'Summary of output options', &
      & fillChar='-', before='*', after='*' )
    call outputNamedValue ( 'Unit number', options%prUnit, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    if ( options%prUnit < 0 ) then
      call outputNamedValue ( 'Meaning', prunitname(options ), &
        & advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    end if
    call outputNamedValue ( 'File name', trim(options%name), advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'Logging level', &
      & SeverityNamesFun(options%MLSMSG_Level), advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'Buffered?', options%buffered, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'Skip MLSMSG logging?', options%SKIPMLSMSGLOGGING, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'Log Parent Name?', options%logParent, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'AdvanceDefault', options%advanceDefault, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'SdFormatDefault', options%sdFormatDefault, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'Indent By', IndentBy, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'Always Wrap', AlwaysWrap, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    if ( AlwaysWrap ) &
  & call outputNamedValue ( 'Wrap past column', WrapPastColumn, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'Tab stops', tabstops, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    do i=1, MAXNUMTABSTOPS
      call tab( fillChar='.' )
      call output_( '^', advance='no' )
    end do
    call newline
    if ( CHECKINGTABBING ) then
      do i=1, MAXNUMTABSTOPS
        call blanksToColumn( tabStops(i), fillChar=fillChar )
        call output_( '^', advance='no' )
      end do
      call newline
    end if
    do i = 1, 14
      call output_( decade, advance='no' )
      if ( getOutputStatus( 'column' ) > 132 ) exit
    end do
    call newline
    call blanks(80, fillChar='-', advance='yes')
  contains
    function PRUnitName( options ) result( name )
      ! Return an appropriate name for the prUnit number
      ! Args
      type(OutputOptions_T), intent(in) :: options
      character(len=12) :: name
      ! Executable
      if ( options%prUnitLiteral ) then
        name = 'literal'
      else
        select case ( options%prUnit )
        case ( STDOUTPRUNIT )
          name = 'stdout'
        case ( MSGLOGPRUNIT )
          name = 'mls logfile'
        case ( BOTHPRUNIT )
          name = 'stdout+log'
        case ( OUTPUTLINESPRUNIT )
          name = 'outputLines'
        case ( INVALIDPRUNIT )
          name = 'invalid'
        case default ! > 0
          name = 'Fortran unit'
        end select
      end if
    end function PRUnitName
  end subroutine DumpOutputOptions

  ! ---------------------------------------------- DumpPatternOptions -----
  subroutine DumpPatternOptions( options )
    ! Show currently-active pattern options
    type(PatternOptions_T), intent(in) :: options
    ! Internal variables
    character(len=1), parameter :: fillChar = '1' ! fill blanks with '. .'
    ! Executable
    call blanks(80, fillChar='-', advance='yes')
    call HeadLine( 'Summary of pattern options', &
      & fillChar='-', before='*', after='*' )
    call outputNamedValue ( 'use patterned blanks?', options%usePatternedBlanks, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'special fills', trim(options%specialFillChars), advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'lineup fills', trim(options%lineupFillChars), advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call newline
    call blanks(80, fillChar='-', advance='yes')
  end subroutine DumpPatternOptions

  ! ---------------------------------------------- DumpStampOptions -----
  subroutine DumpStampOptions( options )
    ! Show currently-active stamp options
    type(StampOptions_T), intent(in) :: options
    character(len=1), parameter :: fillChar = '1' ! fill blanks with '. .'
     call blanks(80, fillChar='-', advance='yes')
    call HeadLine( 'Summary of automatic stamp options', &
      & fillChar='-', before='*', after='*' )
     call outputNamedValue ( 'Never stamp', options%neverStamp, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Stamp end of line', options%post, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Show time', options%showTime, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Extra text', trim_safe(options%textCode), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Date format', trim_safe(options%dateFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Time format', trim_safe(options%timeFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Interval', options%interval, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Style of TimeStamps', trim_safe(options%TimeStampstyle), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call blanks(80, fillChar='-', advance='yes')
  end subroutine DumpStampOptions

  ! ---------------------------------------------- DumpTimeStampOptions -----
  subroutine DumpTimeStampOptions( options )
    ! Show output options
    type(TimeStampOptions_T), intent(in) :: options
    character(len=1), parameter :: fillChar = '1' ! fill blanks with '. .'
     call blanks(80, fillChar='-', advance='yes')
    call HeadLine( 'Summary of time stamp options', &
      & fillChar='-', before='*', after='*' )
     call outputNamedValue ( 'Stamp end of line', options%post, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Show date', options%showDate, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Extra text', trim_safe(options%textCode), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Date format', trim_safe(options%dateFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Time format', trim_safe(options%timeFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'Style of TimeStamps', trim_safe(options%TimeStampstyle), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call blanks(80, fillChar='-', advance='yes')
  end subroutine DumpTimeStampOptions

  ! ---------------------------------------------- DumpSize_double -----
  subroutine DumpSize_double ( n, advance, units, Before, After, Signed )
    double precision, intent(in) :: N
    character(len=*), intent(in), optional :: ADVANCE
    real, intent(in), optional :: units
    character(len=*), intent(in), optional :: Before, After
    logical, intent(in), optional :: Signed ! Force "+" if positive
    ! Local parameters
    real, parameter :: KB = 1024.0
    real, parameter :: MB = KB * 1024.0
    real, parameter :: GB = MB * 1024.0
    real, parameter :: TB = GB * 1024.0
    double precision :: Amount ! N * MyUnits
    character(len=8) :: HowMuch
    character        :: mySigned ! blank or "+"
    real             :: myUnits
    character(len=6) :: Suffix
    ! Make a 'nice' output
    if ( present(before) ) call output_ ( before )
    mySigned = ''
    if ( present(signed) ) then
      if ( signed ) mySigned = merge('+', ' ', n >= 0)
    end if
    myUnits = 1.0
    if ( present(units) ) myUnits = units
    if ( myUnits == 0.0 ) then
      call output ( n, format='(e12.1)', before=trim(mySigned) )
      call output_ ( ' (illegal units)', advance=advance )
      return
    end if
    amount = n*myUnits
    if ( abs(n) < kb/myUnits ) then
      suffix = ' bytes'
    else if ( abs(n) < Mb/myUnits ) then
      amount = amount/kb
      suffix = ' kB'
    else if ( abs(n) < Gb/myUnits ) then
      amount = amount/Mb
      suffix = ' MB'
    else if ( abs(n) < Tb/myUnits ) then
      amount = amount/Gb
      suffix = ' GB'
    else
      amount = amount/Tb
      suffix = ' TB'
    end if
    if ( amount < -99999 ) then     ! I6 format limits this
      call output_( '(-HUGE)' )
    else if ( amount > 999999 ) then ! I6 format limits this
      call output_( '(HUGE)' )
    else if ( amount == int(amount) ) then
      write ( howMuch, '(i6)' ) int(amount)
    else
      write ( howMuch, '(f8.1)' ) amount
    end if
    call output_ ( trim(mySigned) )
    call output_ ( trim(adjustl(howMuch)) )
    call output_ ( trim(suffix) )
    if ( present(after) ) call output_ ( after )
    call output_ ( '', advance=advance )
  end subroutine DumpSize_double

  ! --------------------------------------------- DumpSize_integer -----
  subroutine DumpSize_integer ( n, advance, units, Before, After, Signed )
    integer, intent(in) :: N
    character(len=*), intent(in), optional :: ADVANCE
    integer, intent(in), optional :: units ! E.g., 1024 for kB
    character(len=*), intent(in), optional :: Before, After
    logical, intent(in), optional :: Signed ! Force "+" if positive
    ! Executable
    if ( present(units) ) then
      call dumpSize ( dble(n), advance=advance, units=real(units), &
        & before=before, after=after, signed=signed )
    else
      call dumpSize ( dble(n), advance=advance, before=before, after=after, &
        & signed=signed )
    end if
  end subroutine DumpSize_integer

  ! ------------------------------------------------ DumpSize_real -----
  subroutine DumpSize_real ( n, advance, units, Before, After, Signed )
    real, intent(in) :: N
    character(len=*), intent(in), optional :: ADVANCE
    real, intent(in), optional :: units
    character(len=*), intent(in), optional :: Before, After
    logical, intent(in), optional :: Signed ! Force "+" if positive
    ! Make a 'nice' output
    call dumpsize ( dble(n), advance, units, before, after, signed )
  end subroutine DumpSize_real

  ! ----------------------------------------------  dumpTabs  -----
  ! Show tab stops in effect
  ! Optionally returning them as an integer array
  subroutine dumpTabs ( tabs )
    ! Args
    integer, dimension(:), optional, intent(out) :: tabs
    ! Internal variables
    integer :: n
    ! Executable
    call output( 'Current tab stops', advance='yes' )
    call output( TABSTOPS, advance='yes' )
    if ( present(tabs) ) then
      n = min(size(tabs), MAXNUMTABSTOPS)
      tabs = 0
      tabs(1:n) = TABSTOPS(1:n)
    end if
  end subroutine dumpTabs

  !-----------------------------------   FinalMemoryReport  -----
  subroutine FinalMemoryReport ( IsFinal )
    use MLSCommon, only: NoBlocksAllocated, NoBlocksDeAllocated, &
      & NoBytesAllocated, TotalAllocated, TotalDeAllocated
    use Memory_M, only: Memory_Used
    use Optional_M, only: Default
    use Output_M, only: Output
    ! Print Final or interim report summarizing allocates, deallocates
    logical, optional, intent(in)  :: IsFinal
    integer, save                  :: Previous_used = 0
    integer                        :: Total_used     ! Memory used in kilobytes (1024)

    ! Executable code
    call Output ( '* ', advance='no' )
    if ( .not. Default( IsFinal, .false. ) ) then
      call Output ( 'Interim', advance='no' )
    else
      call Output ( 'Final', advance='no' )
    endif
    call Output( ' report on allocates/deallocates *', advance='yes' )
    call OutputNamedValue ( 'Number of calls to _allocate_', &
      & NoBlocksAllocated )
    call OutputNamedValue ( 'Number of calls to _deallocate_', &
      & NoBlocksDeAllocated )
    call OutputNamedValue ( 'Total GB allocated', &
      & TotalAllocated*1.e-9 )
    call OutputNamedValue ( 'Total GB deallocated', &
      & TotalDeAllocated*1.e-9 )
    call OutputNamedValue ( 'Net GB remaining allocated', &
      & NoBytesAllocated*1.e-9 )
    call memory_used ( total=Total_used )
    call OutputNamedValue ( 'Compared with total memory used', &
      & Total_used*1.e-6 )
    call OutputNamedValue ( 'Change from last report', &
      & (Total_used-Previous_used)*1.e-6 )
    Previous_used = Total_used ! To remember for the next call


  end subroutine FinalMemoryReport

  ! ----------------------------------------------  getStamp  -----
  subroutine getStamp ( textCode, showTime, dateFormat, timeFormat, &
    & post, interval )
  ! get stamp being added to every output to PRUNIT.
    character(len=*), optional, intent(out) :: textCode
    logical, optional, intent(out)          :: showTime
    character(len=*), optional, intent(out) :: dateFormat
    character(len=*), optional, intent(out) :: timeFormat
    logical, optional, intent(out)          :: post
    integer, optional, intent(out)          :: interval
    if ( present(showTime) )   showTime   = stampOptions%showTime
    if ( present(textCode) )   textCode   = stampOptions%textCode
    if ( present(dateFormat) ) dateFormat = stampOptions%dateFormat
    if ( present(timeFormat) ) timeFormat = stampOptions%timeFormat
    if ( present(post) )       post       = stampOptions%post
    if ( present(interval) )   interval   = stampOptions%interval
  end subroutine getStamp

  ! -----------------------------------------------------  HeadLine  -----
  ! Print your message with extra formatting features; e.g.,
  ! *----------------  Your message here   ----------------*
  ! See also Banner, StyledOutput
  subroutine HeadLine ( inChars, fillChar, Before, After, &
    & ColumnRange, Alignment, Skips, Underline, Stretched )
    character(len=*), intent(in)                ::inChars
    character(len=1), intent(in), optional      :: fillChar      ! For padding
    character(len=*), intent(in), optional      :: Before, After ! text to print
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: Columnrange
    character(len=1), intent(in), optional      :: Alignment ! L, R, C, or J
    integer, optional, intent(in)               :: Skips ! How many spaces between chars
    logical, optional, intent(in)               :: Underline
    logical, optional, intent(in)               :: Stretched   ! s t r e t c h
    !
    ! Internal variables
    character(len=2*len(inchars))    :: Chars
    character(len=1)      :: myAlignment
    integer, dimension(2) :: myColumnRange      ! To fit chars
    integer, dimension(2) :: myFullColumnRange  ! Must fit before and after, too
    integer               :: mySkips,  rightpadding
    character(len=1)      :: myFillChar
    character(len=8)      :: myBefore, myAfter
    logical                          :: myStretched
    logical               :: myUnderline
    character(len=len(chars))        :: underlineChars
    ! Executable
    Chars = ' '
    rightpadding = 0
    if ( present(columnRange) ) then
      myFullColumnRange = columnRange
    else
      myFullColumnRange = StyleOptions%HeadLineColumnRange ! (/ 1, 80 /)
    end if
    ! print *, 'myFullColumnRange ', myFullColumnRange 
    myColumnRange = myFullColumnRange
    mySkips = StyleOptions%HeadLineSkips ! 0
    if ( present(skips) ) mySkips = skips
    myFillChar = StyleOptions%HeadLinefill ! ' '
    if ( present(fillChar) ) myFillChar = fillChar
    myAlignment = StyleOptions%HeadLineAlignment ! 'C'
    if ( present(alignment) ) myAlignment = alignment
    myStretched = .false.
    if ( present(Stretched) ) myStretched = Stretched
    myUnderline = .false.
    if ( present(Underline) ) myUnderline = Underline
    if ( myStretched ) then
      Chars = Stretch ( inChars, 1, options='a' )
    else
      Chars = inChars
    endif
    myBefore = StyleOptions%HeadLineBefore
    myAfter = StyleOptions%HeadLineAfter
    ! call outputNamedValue ( 'myFullColumnRange', myFullColumnRange )
    ! call outputNamedValue ( 'myColumnRange', myColumnRange )
    ! call outputNamedValue ( 'mySkips', mySkips )
    ! call outputNamedValue ( 'myFillChar', myFillChar )
    ! Adjust for lengths of before, after
    if ( len_trim(myBefore) > 0 ) &
      & myColumnRange(1) = myFullColumnRange(1) + len_trim(myBefore)
    if ( len_trim(myAfter) > 0 ) then
      myColumnRange(2) = myFullColumnRange(2) - len_trim(myAfter)
      rightpadding = len_trim(myAfter) - 1
    end if
    call blanksToColumn( myFullColumnRange(1), advance='no' )
    if ( len_trim(myBefore) > 0 ) call output( trim(myBefore), advance='no' )
    if ( mySkips == 0 .and. myAlignment == 'C' .and. myFillChar /= ' ' ) then
      ! OK, final adjustments of myColumnRange
      myColumnRange(1) = &
        & ( myColumnRange(1) + myColumnRange(2) + 1 - len(chars) )/2
      myColumnRange(2) =  myColumnRange(1) - 1 + len(chars)
      ! print *, 'myColumnRange ', myColumnRange
      call blanksToColumn( myColumnRange(1), fillChar=myFillChar, advance='no' )
      call AlignToFit( chars, myColumnRange, myAlignment, skips )
      call blanksToColumn( myFullColumnRange(2)-rightpadding, &
        & fillChar=myFillChar, advance='no' )
      if ( len_trim(myAfter) > 0 ) call output( trim(myAfter), advance='no' )
    else
      call AlignToFit( chars, myColumnRange, myAlignment, skips )
      call blanksToColumn( myFullColumnRange(2)-rightpadding, advance='no' )
      if ( len_trim(myAfter) > 0 ) call output( trim(myAfter), advance='no' )
    end if
    call newLine
    if ( myUnderline .and. len_trim(chars) > 0 ) then
      ! The next trick replaces everything with a dash except spaces
      underlineChars = Replace( chars, ' ', '-', reverse=.true. )
      call AlignToFit( underlineChars, myColumnRange, myAlignment, skips )
      call newLine
    endif
  end subroutine HeadLine

  ! -----------------------------------------------------  Letsdebug  -----
  logical function Letsdebug_Chars ( switch, threshold )
    ! Args
    character(len=*), intent(in) :: SWITCH
    integer, intent(in)          :: THRESHOLD
    ! Executable
    Letsdebug_Chars = switchDetail( switches, switch ) > threshold .or. MLSDebug
  end function Letsdebug_Chars

  logical function Letsdebug_CharArray ( switcharray, threshold )
    ! Args
    character(len=*), dimension(:), intent(in) :: switcharray
    integer, intent(in)                        :: THRESHOLD
    ! Internal variables
    integer                                    :: i
    ! Executable
    Letsdebug_CharArray = MLSVerbose
    if ( Letsdebug_CharArray ) return
    do i=1, size(SwitchArray)
      Letsdebug_CharArray = Letsdebug_CharArray .or. &
        & switchDetail( switches, switcharray(i) ) > threshold
    enddo
  end function Letsdebug_CharArray

  ! ----------------------------------------------------  NextColumn  -----
  function NextColumn() result(Column)
    ! Args
    integer :: Column
    Column = getOutputStatus( 'column' )
  end function NextColumn

  ! ----------------------------------------------------  NextTab  -----
  function NextTab() result(Column)
    ! Args
    integer :: Column
    ! Internal variables
    integer :: nTab
    ! Executable
    Column = 0
    nTab = findFirst( tabStops > getOutputStatus( 'column' ) )
    if ( nTab > 0 ) Column = max( tabStops(nTab), getOutputStatus( 'column' ) )
  end function NextTab

  ! ----------------------------------------------------  numNeedsFormat  -----
  ! This family of functions return what format is needed to be printed by output
  function numNeedsFormat_double( value, inFormat ) result ( format )
    ! Args
    double precision, intent(in) :: VALUE
    character(len=*), optional, intent(in)  :: inFormat
    character(len=30) :: format
    ! Internal variables
    character(len=30) :: charValue
    character(len=2)  :: dotm
    character(len=30) :: ndotm
    integer :: I
    ! Executable
    call whatSDNeedsFormat( ndotm, dotm, inFormat )
    charValue = adjustl(numToChars ( value, format=ndotm ))
    ! call outputNamedValue( 'ndotm', ndotm )
    ! call outputNamedValue( 'charValue', charValue )
    i = len_trim(charValue)
    write(charValue, *) i+5
    format = '(1pg' // trim(adjustl(charValue)) // dotm // ')'
  end function numNeedsFormat_double

  function numNeedsFormat_integer( value, inFormat ) result ( format )
    ! Args
    integer, intent(in) :: VALUE
    character(len=*), optional, intent(in)  :: inFormat
    character(len=30) :: format
    ! Internal variables
    character(len=30) :: charValue
    integer :: I
    ! Executable
    charValue = numToChars(value)
    i = len_trim(charValue)
    write(charValue, *) i+5
    format = '(i' // trim(adjustl(charValue)) // ')'
  end function numNeedsFormat_integer

  function numNeedsFormat_single( value, inFormat ) result ( format )
    ! Args
    real, intent(in) :: VALUE
    character(len=*), optional, intent(in)  :: inFormat
    character(len=30) :: format
    ! Internal variables
    character(len=30) :: charValue
    character(len=2)  :: dotm
    character(len=30) :: ndotm
    integer :: I
    ! Executable
    call whatSDNeedsFormat( ndotm, dotm, inFormat )
    charValue = adjustl(numToChars ( value, format=ndotm ))
    i = len_trim(charValue)
    write(charValue, *) i+5
    format = '(1pg' // trim(adjustl(charValue)) // dotm // ')'
  end function numNeedsFormat_single

  function numNeedsFormat_complex( value, inFormat ) result ( format )
    ! Args
    integer, parameter :: RK = kind(0.0e0)
    complex(rk), intent(in) :: VALUE
    character(len=*), optional, intent(in)  :: inFormat
    character(len=45) :: format
    ! Internal variables
    character(len=30) :: charValue
    character(len=2)  :: dotm
    character(len=30) :: ndotm
    integer :: I
    ! Executable
    call whatSDNeedsFormat( ndotm, dotm, inFormat )
    charValue = adjustl(numToChars ( abs(value), format=ndotm ))
    i = len_trim(charValue)
    write(charValue, *) i+5
    format = '(1x,"(",1pg' // trim(adjustl(charValue)) // dotm // ',",",1pg' &
      & // trim(adjustl(charValue)) // dotm // ',")")'
  end function numNeedsFormat_complex

  function NumNeedsFormat_dcomplx( value, inFormat ) result ( format )
    ! Args
    integer, parameter :: RK = kind(0.0d0)
    complex(rk), intent(in) :: VALUE
    character(len=*), optional, intent(in)  :: inFormat
    character(len=45) :: format
    ! Internal variables
    character(len=30) :: charValue
    character(len=2)  :: dotm
    character(len=30) :: ndotm
    integer :: I
    ! Executable
    call whatSDNeedsFormat( ndotm, dotm, inFormat )
    charValue = adjustl(numToChars ( abs(value), format=ndotm ))
    i = len_trim(charValue)
    write(charValue, *) i+5
    format = '(1x,"(",1pg' // trim(adjustl(charValue)) // dotm // ',",",1pg' &
      & // trim(adjustl(charValue)) // dotm // ',")")'
  end function numNeedsFormat_dcomplx

  ! ----------------------------------------------------  numToChars  -----
  ! This family of functions return what would otherwise be printed by output
  function numToChars_double( value, format, trim ) result ( line )
    ! Args
    double precision, intent(in) :: VALUE
    character(len=*), intent(in), optional :: Format    ! How to print
    logical, intent(in), optional :: Trim ! Trim blanks even if Format present
    logical :: Do_Trim
    character(len=30) :: line
    ! Internal variables
    character(len=30) :: FormatSpec
    integer :: I, J, K
    ! Executable
    FormatSpec = OutputOptions%sdFormatDefault
    if ( any( value == DPREFERDEFAULTFORMAT ) ) FormatSpec = '*'
    if ( present(Format)  ) then
      if ( format /= '*' ) FormatSpec = Format
    end if
    include 'numToChars.f9h'
  end function numToChars_double

  function numToChars_integer( value, format ) result ( line )
    ! Args
    integer, intent(in) :: VALUE
    character(len=*), intent(in), optional :: Format    ! How to print
    character(len=30) :: line
    ! Executable
    if ( present(Format)  ) then
      write( line, Format ) value
    else
      write( line, * ) value
    end if
    line = adjustl(line)
  end function numToChars_integer

  function numToChars_single( value, format, trim ) result ( line )
    ! Args
    real, intent(in) :: VALUE
    character(len=*), intent(in), optional :: Format    ! How to print
    logical, intent(in), optional :: Trim ! Trim blanks even if Format present
    logical :: Do_Trim
    character(len=30) :: line
    ! Internal variables
    character(len=30) :: FormatSpec
    integer :: I, J, K
    ! Executable
    FormatSpec = OutputOptions%sdFormatDefault
    if ( any( value == DPREFERDEFAULTFORMAT ) ) FormatSpec = '*'
    if ( present(Format)  ) then
      if ( format /= '*' ) FormatSpec = Format
    end if
    include 'numToChars.f9h'
  end function numToChars_single

  ! ---------------------------------------  OutputCalendar  -----
  subroutine OutputCalendar ( date, datenote, notes, dontWrap, moonPhases )
    use Dates_Module, only: NextMoon
    use MLSStringLists, only: CatLists
    ! output a nicely-formatted calendar of the current month with
    ! today's date marked in "bold"
    ! Args
    character(len=*), intent(in), optional :: date ! use date instead of today
    ! dateNote, (notes), if present, is (an array of)
    ! stringLists, (one per day in the month,)
    character(len=*), optional :: dateNote ! Note for the current date
    ! Each string list contains either a blank for a date, meaning
    ! nothing will be printed in the calendar square for that date,
    ! or else it contains '/'-separated lines of text, each of
    ! which will be printed on a separate line within the square
    character(len=*), dimension(:), optional :: notes
    logical, optional                        :: dontWrap ! Dont wrap notes to fit
    logical, optional                        :: moonPhases ! Show new, full moons
    ! Internal variables
    integer, parameter :: MAXNOTELENGTH = 256
    ! This should be modified for internationalization; e.g. with
    ! an include statement or suchlike
    ! The next two arrays may be customized for non-English users
    character(len=*), dimension(12), parameter :: MONTHNAME = (/ &
      & 'January  ', 'February ', 'March    ', 'April    ', 'May      ', &
      & 'June     ', 'July     ', 'August   ', 'September', 'October  ', &
      & 'November ', 'December '/)

    character(len=*), dimension(7), parameter :: DAYSOFWEEK = (/ &
      & 'Sunday   ', 'Monday   ', 'Tuesday  ', 'Wednesday', 'Thursday ', &
      & 'Friday   ', 'Saturday '/)
    logical, parameter :: countEmpty = .true.
    character(len=1), parameter :: inseparator = '/'
    character(len=*), parameter :: utcformat = 'yyyy-mm-dd' ! 'yyyy-Doy'
    integer :: aday
    integer :: col1
    integer :: col2
    character(len=16) :: date2, dateString
    character(len=16) :: fullDate, newDate
    integer :: day
    integer, dimension(6,7) :: days, daysOfYear
    integer :: ErrTyp
    integer :: FullMoonDay
    integer :: iwk
    integer :: month
    logical :: myDontWrap
    integer :: NewMoonDay
    character(len=10) :: noteString
    character(len=128), dimension(42) :: myNotes
    integer :: numRows
    integer :: numWeeks
    logical :: PrintedDate
    integer :: row
    logical :: today ! Print extra '|' around today's date
    integer :: wkdy
    character(len=MAXNOTELENGTH) :: wrappedNote
    integer :: year
    ! Executable
    myDontWrap = .false.
    if ( present(dontWrap) ) myDontWrap = dontWrap
    if ( present(date) ) then
      dateString = date
    else
      dateString = '' ! Intel 12 and earlier doesn't fill with blanks
      call date_and_time ( date=dateString )
    end if
    myNotes = ' '
    if ( present(notes) ) myNotes(1:size(notes) ) = notes
    col1 = index(lowercase(dateString), 't')
    if ( col1 > 0 ) then
      date2 = dateString(1:col1-1)
       if ( nCopies(dateString(:col1-1), '-') < 2 ) &
        & date2 = reformatDate( dateString(1:col1-1), fromForm='yyyy-Doy', toForm=utcformat )
    else
      date2 = reformatDate( dateString, fromForm='*', toForm=utcformat )
    end if
    call utc_to_yyyymmdd( date2, ErrTyp, year, month, day )
    if ( month < 0 ) then
    end if
    FullMoonDay = 0
    NewMoonDay = 0
    if ( present(moonPhases) ) then
      if ( moonPhases) then
        fullDate = nextMoon( date2(1:8) // '01', 'full' )
        newDate = nextMoon( date2(1:8) // '01', 'new' )
        read ( fullDate(9:10), * ) FullMoonDay
        read ( newDate(9:10), * ) NewMoonDay
        ! Add these to notes if present
        if ( present(notes) ) then
          do aday=1, min( size(notes), daysInMonth( month, year ) )
            if ( aday == FullMoonday ) then
              myNotes(aday) = catLists( 'Full moon', myNotes(aday), inseparator )
              ! call outputnamedValue ( 'fullmoonday', trim(myNotes(aday)) )
            elseif ( aday == newMoonday ) then
              myNotes(aday) = catLists( 'New moon', myNotes(aday), inseparator )
              ! call outputnamedValue ( 'newmoonday', trim(myNotes(aday)) )
            endif
          enddo
        endif
      endif
    endif
    call buildCalendar( year, month, days, daysOfYear )
    ! Temporary use of   w i d e  tabstops
    call settabs( '14-210+14' )
    ! Here we begin printing
    ! Temporarily stop Stamping lines
    OldNeverStamp = stampOptions%neverStamp
    stampOptions%neverStamp = .true.
    call newline
    call AlignToFit( trim(monthName(month)), (/ 1, 100 /), 'c', skips=1 )
    call newline
    col2 = 0
    do wkdy=1, 7
      col1 = col2 + 1
      col2 = tabStops(wkdy)
      call AlignToFit( trim(daysOfWeek(wkdy)), (/ col1, col2 /), 'c' )
    end do
    call newline
    numWeeks = 4
    if ( any( days(5,:) /= 0 ) ) numWeeks = 5
    if ( any( days(6,:) /= 0 ) ) numWeeks = 6
    ! How many rows will we need?
    numRows = 4
    if ( present(dateNote) ) then
      if ( myDontWrap ) then
        wrappedNote = dateNote
      else
        call wrap( dateNote, wrappedNote, 10, '/' )
      end if
      numRows = max( numRows, &
        & NumStringElements( wrappedNote, countEmpty, inseparator ) + 2 &
        & )
    end if
    if ( present(notes) ) then
      do aday=1, min( size(notes), daysInMonth( month, year ) )
        if ( myDontWrap ) then
          wrappedNote = myNotes(aday)
        else
          call wrap( myNotes(aday), wrappedNote, 10, '/' )
        end if
        numRows = max( numRows, &
          & NumStringElements( wrappedNote, countEmpty, inseparator ) + 2 &
          & )
      end do
    end if
    do iwk = 1, numWeeks
      ! Start with horizontal line
      call blanksToTab( 7, fillChar='-' )
      call newline
      do row=1, numRows
        col2 = 0
        do wkdy=1, 7
          PrintedDate = .false.
          col1 = col2 + 1
          col2 = tabStops(wkdy)
          today = ( days(iwk, wkdy) == day )
          if ( today ) then
            call output_('||')
            col2 = col2 - 1 ! Must scoot string one space to the lefts
          else
            call output_('|')
          end if
          if ( days(iwk, wkdy) < 1 ) then
            ! Don't write notes or anything else in "empty" days
          else if ( row == 1 ) then
            call writeIntsToChars( days(iwk, wkdy), dateString )
            dateString = adjustl(dateString)
            call AlignToFit( trim(dateString), (/ col1, col2-1 /), 'r' )
            PrintedDate = .true.
          else if( row == numRows ) then
            call writeIntsToChars( daysOfYear(iwk, wkdy), dateString )
            dateString = adjustl(dateString)
            call AlignToFit( 'd' // trim(dateString), (/ col1, col2-1 /), 'r' )
            PrintedDate = .true.
          else if( present(dateNote) .and. today ) then
            if ( myDontWrap ) then
              wrappedNote = dateNote
            else
              call wrap( dateNote, wrappedNote, 10, '/' )
            end if
            call GetStringElement ( wrappedNote, noteString, &
              & row-1, countEmpty, inseparator )
            if ( noteString == inseparator ) noteString = ' '
            call output_( noteString )
          else if( present(notes) ) then
            if ( days(iwk, wkdy) <= size(notes) ) then
              if ( myDontWrap ) then
                wrappedNote = myNotes(days(iwk, wkdy))
              else
                call wrap( myNotes(days(iwk, wkdy)), wrappedNote, 10, '/' )
              end if
              call GetStringElement ( wrappedNote, noteString, &
                & row-1, countEmpty, inseparator )
              if ( noteString == inseparator ) noteString = ' '
              call output_( noteString )
            end if
          else if ( days(iwk, wkdy) == FullMoonday .and. row < 3 ) then
            call output_( 'Full moon' )
          else if ( days(iwk, wkdy) == NewMoonday .and. row < 3 ) then
            call output_( 'New moon' )
          end if
          if ( today ) then
            call blanksToColumn(col2-1)
            if ( .not. PrintedDate ) call Blanks( 1 )
            call output_('|')
          else
            call blanksToTab ( MayStayIfAtTab=.true. )
          end if
        end do ! wkdy
        call output_('|')
        call newline
      end do ! row
      ! begin with 
    end do ! week
    call blanksToTab( 7, fillChar='-' )
    call newline
    ! Restore tabstops, Stamping
    call settabs( '5-120+5' )
    stampOptions%neverStamp = OldNeverStamp
  end subroutine OutputCalendar

  ! ---------------------------------------  Output_Date_And_Time  -----
  subroutine Output_Date_And_Time ( date, time, &
    & from_where, msg, dateFormat, timeFormat, &
    & CPU_Seconds, wallClock_Seconds, advance )
    ! Output nicely-formatted date, time, and extra message
    ! We'll assume we won't want this line stamped with date and time
    ! (for fear of being redundant, which we fear)
    ! Optionally print CPU and wall clock usage, too.
    ! The first two args optionally override the defaults, which are to output
    ! both date and time
    logical, intent(in), optional          :: Date ! output date?
    logical, intent(in), optional          :: Time ! output time?
    ! Anything else to output?
    character(len=*), intent(in), optional :: From_where
    character(len=*), intent(in), optional :: Msg
    character(len=*), intent(in), optional :: Dateformat
    character(len=*), intent(in), optional :: Timeformat
    double precision, intent(in), optional :: Cpu_seconds
    integer, intent(in), optional          :: Wallclock_seconds
    character(len=*), intent(in), optional :: Advance
    ! Internal variables
    character(len=16) :: dateString
    logical, parameter :: DONT_STAMP = .true. ! Don't double-stamp
    integer :: HH, MM, MS, SS
    logical :: myDate
    logical :: myTime
    character(len=3) :: MY_ADV
    real :: My_CPU, Seconds
    character(len=16) :: timeString
    ! Executable
    myDate = .true.
    if ( present(date) ) myDate = date
    myTime = .true.
    if ( present(time) ) myTime = time
    if ( .not. (myDate .or. myTime) ) return ! Why call if won't print?
    my_adv = 'no'
    if ( .not. present(msg) ) then
      my_adv = 'yes'
      if ( present(advance) ) my_adv = advance
    end if
    dateString = '' ! Intel 12 and earlier doesn't fill with blanks
    timeString = '' ! Intel 12 and earlier doesn't fill with blanks
    call date_and_time ( date=dateString, time=timeString )
    dateString = reFormatDate(trim(dateString), toForm=dateFormat)
    timeString = reFormatTime(trim(timeString), timeFormat)
    if ( myDate .and. myTime ) then
      call output_ ( trim(dateString), from_where=from_where, advance='no', &
        & DONT_STAMP=DONT_STAMP )
      call blanks(3)
      call output_ ( trim(timeString), from_where=from_where, advance=my_adv, &
        & DONT_STAMP=DONT_STAMP )
    else if ( myDate ) then
      call output_ ( trim(dateString), from_where=from_where, advance=my_adv, &
        & DONT_STAMP=DONT_STAMP )
    else if ( myTime ) then
      call output_ ( trim(TimeString), from_where=from_where, advance=my_adv, &
        & DONT_STAMP=DONT_STAMP )
    end if
    if ( .not. present(msg) ) return
    my_adv = 'yes'
    if ( present(advance) ) my_adv = advance
    call blanks ( 3 )
    call output_ ( trim(msg), from_where=from_where, &
      & advance=merge ( 'no ', my_adv, present(CPU_seconds) .or. &
      & present(WallClock_seconds) ), &
      & DONT_STAMP=DONT_STAMP )
    if ( present(CPU_seconds) ) then
      hh = CPU_seconds / 3600
      my_cpu = CPU_seconds - hh * 3600
      mm = my_cpu / 60
      seconds = my_cpu - mm * 60
      ss = seconds
      ms = nint(1000 * (seconds-ss))
      write ( timeString, '(2(i2.2,":"),i2.2,".",i3.3)' ) hh, mm, ss, ms
      call output_ ( '   CPU time ' // trim(timeString), from_where=from_where, &
        & advance=merge ( 'no ', my_adv, present(WallClock_seconds)), &
        & DONT_STAMP=DONT_STAMP )
    end if
    if ( present(WallClock_seconds) ) then
      hh = WallClock_seconds / 3600
      my_cpu = WallClock_seconds - hh * 3600
      mm = my_cpu / 60
      seconds = my_cpu - mm * 60
      ss = seconds
      write ( timeString, '(2(i2.2,":"),i2.2)' ) hh, mm, ss
      call output_ ( '   wall clock time ' // trim(timeString), from_where=from_where, &
        & advance=my_adv, DONT_STAMP=DONT_STAMP )
    end if
  end subroutine Output_Date_And_Time

  ! ----------------------------------------------  OutputList  -----
  ! This family of routines outputs an array as a comma-separated list
  ! E.g., given the array (/ 1, 2, 3, .. /) outputs
  ! '(1, 2, 3, .. )'
  ! optionally using sep instead of ',' and delims instead of '()'
  subroutine OutputList_Chars ( array, sep, delims )
    ! Args
    character(len=*), dimension(:), intent(in)      :: array
    character(len=*), optional, intent(in) :: sep
    character(len=*), optional, intent(in) :: delims
    ! Local variables
    character(len=1) :: comma
    integer          :: i
    character(len=2) :: parens
    ! Executable
    if ( size(array) < 1 ) return
    comma = ','
    if ( present(sep) ) comma = sep
    parens = '()'
    if ( present(delims) ) parens = delims
    call output( parens(1:1) )
    do i=1, size(array)
      call output( trim_safe(array(i)) )
      if ( i < size(array) ) call output( comma )
    end do
    call output( parens(2:2) )
  end subroutine OutputList_Chars

  subroutine OutputList_Ints ( array, sep, delims )
    ! Args
    integer, dimension(:), intent(in)      :: array
    character(len=*), optional, intent(in) :: sep
    character(len=*), optional, intent(in) :: delims
    ! Local variables
    character(len=1) :: comma
    integer          :: i
    character(len=2) :: parens
    ! Executable
    if ( size(array) < 1 ) return
    comma = ','
    if ( present(sep) ) comma = sep
    parens = '()'
    if ( present(delims) ) parens = delims
    call output( parens(1:1) )
    do i=1, size(array)
      call output( array(i) )
      if ( i < size(array) ) call output( comma )
    end do
    call output( parens(2:2) )
  end subroutine OutputList_Ints

  ! ----------------------------------------------  OutputNamedValue  -----
  ! This family of routines outputs a paired name and value
  ! (Basically saving you a few lines over the idiom
  !  call output ( trim(name), advance='no' )
  !  call output ( ': ', advance='no' )
  !  call output ( value, advance='yes' )
  
  ! to print following line to stdout
  !  name: value
  ! Optional args control
  ! Before:     what extra to print at start of each line
  ! After:      what extra to print at end of each line
  ! Colon:      what to print instead of ':'
  ! FillChar:   instead of spaces if you use tabs to align name, value
  ! Tabn:       column number where name begins
  ! Tabc:       column number where colon occurs
  ! Taba:       column number where after begins
  ! Advance:    whether to advance after printing pair (by default we will advance)
  ! Dont_stamp: override setting to stamp end of each line
  ! By means of optional args you can create a line like the following
  ! *   name                   value   *
  ! See also startTable, AddRow, outputTable
  subroutine Output_Nvp_whatever ( name, &
   & chvalue, ivalue, cmvalue, dbvalue, snvalue, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)           :: name
    character(len=*), intent(in), optional :: chvalue
    complex, intent(in), optional          :: cmvalue
    double precision, intent(in), optional :: dbvalue
    integer, intent(in), optional          :: ivalue
    real, intent(in), optional             :: snvalue
    character(len=*), intent(in), optional :: Advance
    character(len=1), intent(in), optional :: Colon
    character(len=1), intent(in), optional :: Fillchar
    integer, intent(in), optional          :: Tabn
    integer, intent(in), optional          :: Tabc
    integer, intent(in), optional          :: Taba
    logical, intent(in), optional          :: Dont_stamp
    character(len=*), intent(in), optional :: Before, After ! text to print
    character(len=*), intent(in), optional :: options
    ! Local variables
    if ( present(chvalue) ) then
      call Output_Nvp_character ( name, chvalue, &
        & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    elseif ( present(cmvalue) ) then
      call Output_Nvp_complex ( name, cmvalue, &
        & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    elseif ( present(dbvalue) ) then
      call Output_Nvp_double ( name, dbvalue, &
        & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    elseif ( present(ivalue) ) then
      call Output_Nvp_integer ( name, ivalue, &
        & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    elseif ( present(snvalue) ) then
      call Output_Nvp_single ( name, snvalue, &
        & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    endif
  end subroutine Output_Nvp_whatever

  subroutine Output_Nvp_character ( name, value, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)          :: name
    character(len=*), intent(in)          :: value
    character(len=*), intent(in), optional :: ADVANCE
    character(len=1), intent(in), optional :: COLON
    character(len=1), intent(in), optional :: fillChar
    integer, intent(in), optional :: TABN
    integer, intent(in), optional :: TABC
    integer, intent(in), optional :: TABA
    logical, intent(in), optional :: DONT_STAMP
    character(len=*), intent(in), optional :: Before, After ! text to print
    character(len=*), intent(in), optional :: options
    if ( TrimCharacterValues ) then
      call possiblyTrimmedvalue ( name, trim(value), &
        & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    else
      call possiblyTrimmedvalue ( name, value, &
        & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    endif
  contains
    subroutine possiblyTrimmedvalue ( name, value, &
      & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
      character(len=*), intent(in)          :: name
      character(len=*), intent(in)          :: value
      include 'output_name_value_pair.f9h'
    end subroutine possiblyTrimmedvalue
  end subroutine Output_Nvp_character

  subroutine Output_Nvp_complex ( name, value, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)          :: name
    complex, intent(in)                   :: value
    include 'output_name_value_pair.f9h'
  end subroutine Output_Nvp_complex

  subroutine Output_Nvp_double ( name, value, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)          :: name
    double precision, intent(in)                   :: value
    include 'output_name_value_pair.f9h'
  end subroutine Output_Nvp_double

  subroutine Output_Nvp_dbl_array ( name, value, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)          :: name
    double precision, dimension(:), intent(in)     :: value
    include 'output_name_value_pair.f9h'
  end subroutine Output_Nvp_dbl_array

  subroutine Output_Nvp_int_array ( name, value, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)          :: name
    integer, dimension(:), intent(in)     :: value
    include 'output_name_value_pair.f9h'
  end subroutine Output_Nvp_int_array

  subroutine Output_Nvp_integer ( name, value, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)          :: name
    integer, intent(in)                   :: value
    include 'output_name_value_pair.f9h'
  end subroutine Output_Nvp_integer

  subroutine Output_Nvp_log_array ( name, value, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)          :: name
    logical, dimension(:), intent(in)     :: value
    include 'output_name_value_pair.f9h'
  end subroutine Output_Nvp_log_array

  subroutine Output_Nvp_logical ( name, value, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)          :: name
    logical, intent(in)                   :: value
    include 'output_name_value_pair.f9h'
  end subroutine Output_Nvp_logical

  subroutine Output_Nvp_single ( name, value, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)          :: name
    real, intent(in)                      :: value
    include 'output_name_value_pair.f9h'
  end subroutine Output_Nvp_single

  subroutine Output_Nvp_sngl_array ( name, value, &
   & Advance, colon, fillChar, Before, After, Tabn, Tabc, Taba, Dont_stamp, options )
    character(len=*), intent(in)          :: name
    real, dimension(:), intent(in)     :: value
    include 'output_name_value_pair.f9h'
  end subroutine Output_Nvp_sngl_array

  ! ----------------------------------------------  OutputParagraph  -----
  ! Outputs text formatted as a paragraph where each line begins on
  ! columnrange(1) and ends on columnrange(2).
  ! Optionally, 
  ! (1)  you may specify an alignment, one of L R C or J
  ! (2)  you may specify an ident
  !      (a) of the first line, if indent > 0
  !      (b) of every line except the first
  !          if indent < 0 and columnrange(1) > 1
  subroutine OutputParagraph ( text, columnrange, alignment, indent )
    ! Args
    character(len=*), intent(in)                   :: text ! text to print
    integer, dimension(2), intent(in)              :: columnrange ! left, right columns
    character(len=1), optional, intent(in)         :: alignment ! L R C or J
    integer, optional, intent(in)                  :: indent ! num of spaces
    ! Internal variables
    integer, parameter                             :: maxindent = 15
    integer, parameter                             :: maxLines = 256
    integer, parameter                             :: MaxStrElementLength = LineLen
    character (len=MaxStrElementLength), dimension(:), allocatable    &
      &                                            :: array
    logical, parameter                             :: countEmpty = .true.
    integer                                        :: i
    logical                                        :: ignoreFirstIndent
    character(len=maxindent+len(text))             :: intext ! indented text
    character                                      :: firstAlignment
    character                                      :: myAlignment
    integer                                        :: nElems
    character, parameter                           :: null = achar(0)
    integer                                        :: status
    character(len=maxindent+maxLines+len(text))    :: wrappedtext ! indented text
    ! Executable
    ! Reasonable choices of args?
    if ( len_trim (text) < 1 ) return
    if ( columnrange(2) <= columnrange(1) ) return
    myAlignment = 'l'
    if ( present(Alignment) ) myAlignment = Alignment
    ignoreFirstIndent = .false.
    FirstAlignment = myAlignment
    if ( present(indent) ) then
      if ( indent > 0 ) then
        intext = repeat( ' ', indent ) // adjustl(text)
        if ( Lowercase(myAlignment) == 'j' ) firstAlignment = 'r'
      elseif ( indent < 0 ) then
        ignoreFirstIndent = .true.
        intext = adjustl(text)
      else
        intext = text
      endif
    else
      intext = text
    endif
    ! print *, trim(inText)
    call wrap( intext, wrappedText, columnrange(2)-columnrange(1)+1, &
      & inseparator=null, dontSqueeze=.true. )
    ! print *, trim(wrappedText)
    ! call output( trim(wrappedText), advance='yes' )
    nElems = NumStringElements( wrappedText, countEmpty, null )
    ! print *, 'nElems: ', nElems
    allocate ( Array(nElems), STAT=status )
    ! call List2Array( trim(wrappedText), array, countEmpty, null )
    call wrap( trim(wrappedText), array, columnrange(2)-columnrange(1)+1, &
      & inseparator=null )
    ! print *, 1, ' ', trim(array(1))
    ! print *, 2, ' ', trim(array(2))
    ! print *, NElems, ' ', trim(array(NElems))
    do i=1, NElems
    ! Convert every null into a space
      array(i) = Replace( array(i), null, ' ' )
      if ( i == 1 .and. ignoreFirstIndent ) then
        call AlignToFit( array(i), (/ 1, ColumnRange(2) /) , Alignment )
      elseif ( i == NElems .and. Lowercase(myAlignment) == 'j' ) then
        ! We won't attempt to left-right justify the last line in the paragraph
        call AlignToFit( array(i), ColumnRange, Alignment='l' )
      elseif ( i == 1 ) then
        ! We won't attempt to left-right justify the first line in the paragraph
        ! if it's indented
        call AlignToFit( array(i), ColumnRange, FirstAlignment )
      else
        call AlignToFit( array(i), ColumnRange, Alignment )
      endif
      call newLine
    enddo
  end subroutine OutputParagraph

  ! ----------------------------------------------  OutputTable  -----
  ! Outputs a 2d character array as a table
  ! Optionally, 
  ! (1)  you may supply the array; otherwise, cellDatabase will be used
  ! (2)  the table can have a character separating cells, and another 
  !      marking its outer borders
  ! (3)  the minimum cell width can be set; otherwise
  !      it is computed based on the trimmed lengths of each column
  ! (4)  the alignment within each cell can be set; otherwise
  !      it is flushed left, i.e. 'L'
  ! (5)  each row can be separated by an interior wall of characters;
  !      by default they are consecutive
  !      a special value of interior, null (achar(0)) inserts an empty line
  ! (6)  the first row can be treated as special, and separated from the second
  !      by a wall of special HeadLiner characters
  subroutine outputTable ( array, sep, border, cellWidth, &
    & interior, HeadLiner, alignment )
    ! Args
    character(len=*), dimension(:,:), optional, intent(in)   &
      &                                            :: array
    character(len=1), optional, intent(in)         :: sep       ! between cols
    character(len=1), optional, intent(in)         :: border    ! outside
    integer, optional, intent(in)                  :: cellWidth
    character(len=1), optional, intent(in)         :: interior  ! between rows
    character(len=1), optional, intent(in)         :: HeadLiner ! 1st row are headers
    character(len=1), optional, intent(in)         :: alignment ! L, R, or C
    ! Local variables
    integer                                        :: status
    ! Executable
    if ( present( array ) ) then
      call outputTableArray ( array, sep, border, cellWidth, &
        & interior, HeadLiner, alignment )
    elseif ( .not. associated ( cellDatabase ) ) then
      call banner ( 'Empty table' )
    else
      call outputTableArray ( cellDatabase, sep, border, cellWidth, &
        & interior, HeadLiner, alignment )
      deallocate( cellDatabase, stat=status )
      nullify( cellDatabase )
    endif
  end subroutine outputTable

  ! ----------------------------------------------  ResetTabs  -----
  ! Restore tab stops to what was in effect at start
  ! Optionally returning them as an integer array
  subroutine ResetTabs ( tabs )
    ! Args
    integer, dimension(:), optional, intent(out) :: tabs
    ! Internal variables
    integer :: n
    ! Executable
    call setTabs( range=INITTABRANGE )
    if ( present(tabs) ) then
      n = min(size(tabs), MAXNUMTABSTOPS)
      tabs = 0
      tabs(1:n) = TABSTOPS(1:n)
    end if
  end subroutine ResetTabs

  ! ----------------------------------------------  RestoreSettings  -----
  ! Restore output settings by call to RestoreOutputSettings
  ! Optionally restore StyleOptions and Tabs
  subroutine RestoreSettings ( settings )
    ! Args
    character(len=*), optional, intent(in) :: settings
    ! Local variables
    character(len=*), parameter            :: allSettings = 'style'
    character(len=64)                      :: mySettings 
    ! Executable
    call RestoreOutputSettings ( settings )
    mySettings = ' '
    if ( present(settings) ) mySettings = settings
    if ( index(mySettings, '*') > 0 ) mySettings = allSettings
    mySettings = lowercase(mySettings)
    if ( index(mySettings, 'tabs') > 0 ) call ResetTabs
    if ( index(mySettings, 'style') > 0 ) StyleOptions = DefaultStyleOptions
  end subroutine RestoreSettings 

  ! ----------------------------------------------  SetStamp  -----
  subroutine SetStamp ( textCode, showTime, dateFormat, timeFormat, &
    & post, interval )
  ! set stamp to be added to every output to PRUNIT.
    character(len=*), optional, intent(in) :: textCode
    logical, optional, intent(in)          :: showTime
    character(len=*), optional, intent(in) :: dateFormat
    character(len=*), optional, intent(in) :: timeFormat
    logical, optional, intent(in)          :: post
    integer, optional, intent(in)          :: interval
    if ( present(showTime) )   stampOptions%showTime   = showTime  
    if ( present(textCode) )   stampOptions%textCode   = textCode  
    if ( present(dateFormat) ) stampOptions%dateFormat = dateFormat
    if ( present(timeFormat) ) stampOptions%timeFormat = timeFormat
    if ( present(post) )       stampOptions%post       = post
    if ( present(interval) )   stampOptions%interval   = interval
  end subroutine SetStamp

  ! ----------------------------------------------  setTabs  -----
  subroutine setTabs ( range, tabs )
    ! Set tabstops
    ! Methods:
    ! (1) a string range; e.g., "8, 32-100+8"
    !     is converted to its expanded form 
    !      "8, 32, 40, 48, 56, 64, 72, 80, 88, 96"
    ! (2) an array of ints; e.g., (/ 4, 9, 12, 18, 22, 30, 35, 40 /)
    ! (3) reset back to the defaults (equiv to "5-120+5")
    ! Args
    character(len=*), optional, intent(in)         :: Range
    integer, dimension(:), optional, intent(in)    :: Tabs
    ! Internal variables
    integer :: n
    ! Executable
    if ( present(range) ) then
      call ExpandStringRange ( range, TABSTOPS )
    else if ( present(tabs) ) then
      n = min( MAXNUMTABSTOPS, size(tabs) )
      tabStops(1:n) = tabs(1:n) 
    else
      call ExpandStringRange ( '5-120+5', TABSTOPS )
    end if
  end subroutine setTabs

  ! ----------------------------------------------  startTable  -----
  ! Set up a table, initially empty. Subsequent calls to AddRow will
  ! add a new row, consisting of two columns: 
  ! the name field and the value field
  ! Optionally, 
  ! (1)  the table can have a character separating cells, and another 
  !      marking its outer borders
  ! (2)  the minimum cell width can be set; otherwise
  !      it is computed based on the trimmed lengths of each column
  ! (3)  the alignment within each cell can be set; otherwise
  !      it is flushed left, i.e. 'L'
  ! (4)  each row can be separated by an interior wall of characters;
  !      by default they are consecutive
  !      a special value of interior, null (achar(0)) inserts an empty line
  ! (5)  the first row can be treated as special, and separated from the second
  !      by a wall of special HeadLiner characters
  subroutine startTable 
    ! Internal variables
    integer :: status
    ! Executable
    status = 0
    if ( associated( cellDatabase ) ) &
      & deallocate( cellDatabase, stat=status )
    if ( status /= 0 ) call myMessage ( MLSMSG_Warning, 'startTable', &
      & 'Unable to deallocate celldatabase' )
    nullify ( cellDatabase )
    outputLines = ' '
  end subroutine startTable

  ! -----------------------------------------------------  StyledOutput  -----
  ! Print your message according to the style set by options
  ! e.g., "--Banner" or "-B"
  ! See also banner
  !
  ! options contains       style
  !    ----                -----
  !      B               Banner
  !      H               Headline
  !      U               Underline
  !      S               s t r e t c h e d
  !            sub-options of Banner
  !      L, C, R, or J   Alignment (if not default)
  !      w               Don't print top stripe of banner
  !      m               Don't print bottom stripe of banner
  !
  ! Some, though not all, of these options may be combined; e.g. "-USB"
  !
  ! We could dig more deeply into options to allow
  ! it to pass Alignment, Fill, After, etc.
  subroutine StyledOutput ( chars, options )
    character(len=*), intent(in)                :: chars
    character(len=*), intent(in), optional      :: options
    ! Internal variables
    character(len=1)                            :: Alignment
    logical                                     :: AsBanner
    logical                                     :: AsHeadLine
    logical                                     :: Bottomless
    logical                                     :: Stretched
    logical                                     :: Topless
    logical                                     :: Underline
    character(len=4*len(chars))                 :: UnderlineChars
    ! Executable
    asBanner   = .false.
    asHeadLine = .false.
    if ( .not. present(options ) ) then
      call output( chars, advance='yes' )
      return
    endif
    asBanner   = index( options, 'B' ) > 0
    asHeadLine = index( options, 'H' ) > 0
    Stretched  = index( options, 'S' ) > 0
    Underline  = index( options, 'U' ) > 0 .or. StyleOptions%Underline
    ! Sub-options for Banner
    Topless  = index( options, 'w' ) > 0
    Bottomless  = index( options, 'm' ) > 0
    if ( asBanner ) then
      Alignment = StyleOptions%BannerAlignment
      if ( index(options, 'L' ) > 0 ) then
        Alignment = 'L'
      elseif ( index(options, 'R' ) > 0 ) then
        Alignment = 'R'
      elseif ( index(options, 'J' ) > 0 ) then
        Alignment = 'J'
      else
        Alignment = 'C'
      endif
      Stretched = Stretched .or. StyleOptions%BannerStretch
      call Banner( chars, Underline=Underline, Stretched=Stretched, &
        & Alignment=Alignment, &
        & Topless=Topless, BottomLess=BottomLess )
    elseif ( asHeadLine ) then
      StyleOptions%HeadLineFill = '-'
      StyleOptions%HeadLineBefore = '*'
      StyleOptions%HeadLineAfter = '*'
      Stretched = Stretched .or. StyleOptions%HeadlineStretch
      call HeadLine( chars, Underline=Underline, Stretched=Stretched ) 
      StyleOptions = DefaultStyleOptions
    elseif ( Stretched .and. Underline ) then
      underlineChars = Stretch( chars, 1, options='a' )
      call output( underlineChars, advance='yes' )
      underlineChars = Replace( underlineChars, ' ', '-', reverse=.true. )
      call output( underlineChars, advance='yes' )
    elseif ( Underline ) then
      call output( chars, advance='yes' )
      ! The next trick replaces everything with a dash except spaces
      underlineChars = Replace( chars, ' ', '-', reverse=.true. )
      call output( underlineChars, advance='yes' )
    elseif ( Stretched ) then
      underlineChars = Stretch( chars, 1, options='a' )
      call output( underlineChars, advance='yes' )
    else
      call output( chars, advance='yes' )
    endif
  end subroutine StyledOutput

  ! ------------------------------------------------  TimeStamp  -----
  ! time-stamp output on demand, not automatic:
  ! Either in style pre or post
  ! (pre) '(HH:MM:SS) chars'
  ! (post) 'chars (HH:MM:SS)'
  ! Note that in pre-style, the time will be printed only if getOutputStatus( 'start' ) == 1 true
  ! in post-style, the time will be printed only if MY_ADV is 'yes'
  subroutine TimeStamp_char ( chars, &
    & advance, from_where, dont_log, log_chars, insteadofblank, style, date )
    character(len=*), intent(in) :: CHARS
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: FROM_WHERE
    logical, intent(in), optional          :: DONT_LOG ! Prevent double-logging
    character(len=*), intent(in), optional :: LOG_CHARS
    character(len=*), intent(in), optional :: INSTEADOFBLANK ! What to output
    character(len=8), intent(in), optional :: STYLE ! pre or post
    logical, intent(in), optional          :: DATE  ! Include date with time
    !
    logical, parameter :: DONT_STAMP = .true. ! Don't double-stamp
    character(len=8) :: my_style
    character(len=3) :: MY_ADV
    logical  ::         myDate
    !
    my_adv = Advance_is_yes_or_no(advance)
    my_style = TimeStampOptions%TimeStampstyle
    if ( present(style) ) my_style = lowercase(style)
    myDate = TimeStampOptions%showDate
    if ( present(date) ) myDate = date
    if ( my_style == 'post' ) then
      call output_( CHARS, &
        & ADVANCE='no', FROM_WHERE=FROM_WHERE, DONT_LOG=DONT_LOG, &
        & LOG_CHARS=LOG_CHARS, INSTEADOFBLANK=INSTEADOFBLANK, DONT_STAMP=DONT_STAMP )
      if ( my_adv=='yes' ) then
        call output_(' (', ADVANCE='no', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
        call Output_Date_And_Time( date=myDate, &
          & dateFormat=TimeStampOptions%dateFormat, &
          & timeFormat=TimeStampOptions%timeFormat, &
          & advance='no')
        call output_(')', ADVANCE='yes', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
      end if
    else
      if ( getOutputStatus( 'start' ) == 1 ) then
        call output_('(', ADVANCE='no', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
        call Output_Date_And_Time( date=myDate, &
          & dateFormat=TimeStampOptions%dateFormat, &
          & timeFormat=TimeStampOptions%timeFormat, &
          & advance='no')
        call output_(')', ADVANCE='no', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
      end if
      call output_( chars, &
        & advance, from_where, dont_log, &
        & log_chars, insteadofblank, dont_stamp=dont_stamp )
    end if
  end subroutine TimeStamp_char

  subroutine TimeStamp_integer ( int, &
    & places, advance, fill, format, Before, After, style, date )
    integer, intent(in) :: INT
    integer, intent(in), optional :: PLACES
    character(len=*), intent(in), optional :: ADVANCE
    logical, intent(in), optional :: FILL
    character(len=*), intent(in), optional :: FORMAT
    character(len=*), intent(in), optional :: Before, After ! text to print
    character(len=*), intent(in), optional :: style ! pre or post
    logical, intent(in), optional          :: DATE  ! Include date with time
    !
    logical, parameter :: DONT_STAMP = .true. ! Don't double-stamp
    character(len=8) :: my_style
    character(len=3) :: MY_ADV
    logical  ::         myDate
    !
    my_adv = Advance_is_yes_or_no(advance)
    my_style = TimeStampOptions%TimeStampstyle
    if ( present(style) ) my_style = lowercase(style)
    myDate = TimeStampOptions%showDate
    if ( present(date) ) myDate = date
    if ( my_style == 'post' ) then
      call output( INT, PLACES, &
        & ADVANCE='no', FILL=FILL, FORMAT=FORMAT, BEFORE=BEFORE, AFTER=AFTER, &
        & DONT_STAMP=DONT_STAMP )
      if ( my_adv=='yes' ) then
        call output_(' (', ADVANCE='no', DONT_STAMP=DONT_STAMP )
        call Output_Date_And_Time( date=myDate, &
          & dateFormat=TimeStampOptions%dateFormat, &
          & timeFormat=TimeStampOptions%timeFormat, &
          & advance='no')
        call output_(')', ADVANCE='yes', DONT_STAMP=DONT_STAMP)
      end if
    else
      if ( getOutputStatus( 'start' ) == 1 ) then
        call output_('(', ADVANCE='no', DONT_STAMP=DONT_STAMP)
        call Output_Date_And_Time( date=myDate, &
          & dateFormat=TimeStampOptions%dateFormat, &
          & timeFormat=TimeStampOptions%timeFormat, &
          & advance='no')
        call output_(')', ADVANCE='no', DONT_STAMP=DONT_STAMP)
      end if
      call output( int, places, &
        & advance, fill, format, before, after, dont_stamp=dont_stamp )
    end if
  end subroutine TimeStamp_integer

  subroutine TimeStamp_logical ( value, &
    & advance, from_where, dont_log, log_chars, insteadofblank, style, date )
    logical, intent(in) ::                    value
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: FROM_WHERE
    logical, intent(in), optional          :: DONT_LOG ! Prevent double-logging
    character(len=*), intent(in), optional :: LOG_CHARS
    character(len=*), intent(in), optional :: INSTEADOFBLANK ! What to output
    character(len=8), intent(in), optional :: STYLE ! pre or post
    logical, intent(in), optional          :: DATE  ! Include date with time
    ! Internal variables
    character(len=1) :: str
    ! Executable
    if ( value ) then
      str = 'T'
    else
      str = 'F'
    end if
    call TimeStamp_char(str, &
    & advance, from_where, dont_log, log_chars, insteadofblank, style, date )
  end subroutine TimeStamp_logical

  ! ------------------ Private procedures -------------------------
  ! .............................................  addCellRowToDatabase  .....
  ! Add an additional row to end of cellDatabase
  integer function addCellRowToDatabase ( database, item )
    ! Args
    character(len=*), dimension(:,:), pointer  :: database
    character(len=*), dimension(2)             :: item
    ! Local variables
    integer :: newSize
    integer :: status
    character(len=MAXCELLSIZE), dimension(:,:), pointer  &
      &                                        :: tempDatabase
    !This include causes real trouble if you are compiling in a different 
    !directory.
    if ( associated(database) ) then ! tree_checker prevents duplicate names
      newSize = SIZE(database,1) + 1
    else
      newSize = 1
    end if
    allocate ( tempDatabase(newSize,2), stat=status )
    if ( newSize>1 ) tempDatabase(1:newSize-1,:) = database
    if ( associated(database) ) then
      deallocate ( database, stat=status )
    end if
    database => tempDatabase
    database(newSize,:) = ' '
    database(newSize,:) = adjustl(item)

    ! include "addCellRowToDatabase.f9h" 

    addCellRowToDatabase = newSize
  end function addCellRowToDatabase

  ! .............................................  getOption  .....
  ! This family of subroutines parses a multipart advance arg into
  ! its components, returning an appropriate value
  ! Example, say the component is marked by the '-S' flag
  ! value type     component   returned value
  !  logical          -S         true
  ! character       -Sxyz        xyz
  subroutine getOption_char ( arg, flag, val )
    ! Args
    character(len=*), intent(in)  :: arg
    character(len=*), intent(in)  :: flag
    character(len=*), intent(out) :: val
    ! Local variables
    integer :: kFlag, kNext, flagLen
    ! Executable
    val = ' '
    kFlag = index( arg, trim(flag) )
    if ( kFlag < 1 ) return
    flagLen = len(flag)
    ! Find start of next component
    kNext = index( arg(kFlag+flagLen:), ' ' )
    if ( kNext < 1 ) then
      val = arg(kFlag+flagLen:)
    else
      val = arg(kFlag+flagLen:kFlag+flagLen+kNext)
    end if
  end subroutine getOption_char

  subroutine getOption_log ( arg, flag, val )
    ! Args
    character(len=*), intent(in) :: arg
    character(len=*), intent(in) :: flag
    logical, intent(out)         :: val
    ! Local variables
    integer :: kFlag
    ! Executable
    kFlag = index( arg, trim(flag) )
    val = ( kFlag > 0 )
  end subroutine getOption_log

  ! ------------------------------------  myMessage  -----
  subroutine myMessage ( Severity, ModuleNameIn, Message, &
    & Advance )

    ! Print a message (unless printing is suppressed).  If it has %[Nn]
    ! in it, replace that with newline.

    ! Dummy arguments
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'

    ! Local variables
    !                                     If nonzero, do not insert prefix.
    logical :: AllOfIt                  ! Print all of it (no %n or %N remains)
    integer :: L1, L2                   ! How far in the line have we printed?
    character (len=512), save :: Line   ! Line to output, should be long enough
    integer, save :: Line_len=0         ! Number of saved characters in line.
    integer :: LogFileUnit
    logical :: My_adv

    ! Executable code
    my_adv = .true.
    if ( present(advance) ) &
      & my_adv = advance(1:1) /= 'n' .and. advance(1:1) /= 'N'

    my_adv = my_adv .and. ( severity >= MLSMessageConfig%skipMessageThr )
    if ( (.not. MLSMessageConfig%suppressDebugs).OR. &
         & (severity /= MLSMSG_Debug) ) then
      l1 = 0
      do
        l2 = index(Message(l1+1:),'%n' )
        if ( l2 == 0 ) l2 = index(Message(l1+1:),'%N')
        allOfIt = l2 == 0
        l2 = l2 + l1 - 1 ! Last character before %n or %N, if any
        if ( allOfIt ) l2 = len(Message) ! no %n or %N
        call assembleFullLine( Severity, ModuleNameIn, Message(l1+1:l2), &
          & line, line_len )
        l1 = l2 + 2 ! "n" or "N" of %n or %N
         ! Log the message using the toolkit routine
         ! (or its substitute )
         ! if either using toolkit or severity is sufficient to
         ! quit (which means we might have been called directly
         ! rather than from output module )

        if ( my_adv .or. .not. allOfIt ) then
          call printitout( line, severity, line_len )
          line_len = 0
          line = ' '
        end if
        if ( allOfIt ) exit
      end do

    end if

    ! Now if it's an error, and the message is complete, then try to close
    ! log file if any and quit (or crash)

    if ( my_adv .and. severity >= MLSMSG_Severity_to_quit ) then
      call get_config ( logFileUnit = logFileUnit )
      if ( logFileUnit > 0 ) close ( logFileUnit  )
      if ( severity >= MLSMSG_Crash .or. MLSMessageConfig%CrashOnAnyError ) then
        NEVERCRASH = .false.
        call crash_burn
      end if
      call exit_with_status ( 1  )
    end if
  end subroutine myMessage

  ! ----------------------------------------------  outputTableArray  -----
  ! outputs a 2d character array as a table
  ! Optionally, 
  ! (1)  the table can have a character separating cells, and another 
  !      marking its outer borders
  ! (2)  the minimum cell width can be set; otherwise
  !      it is computed based on the trimmed lengths of each column
  ! (3)  the alignment within each cell can be set; otherwise
  !      it is flushed left, i.e. 'L'
  ! (4)  each row can be separated by an interior wall of characters;
  !      by default they are consecutive
  !      a special value of interior, null (achar(0)) inserts an empty line
  ! (5)  the first row can be treated as special, and separated from the second
  !      by a wall of special HeadLiner characters
  ! (6)  If any row begins with the special formatting sequence '<<', then
  !      one of the following occurs:
  !      special format             action
  !          <<l>>xxxx       merge:  left-aligned xxx stretched across table
  !          <<c>>xxxx       merge:  centered xxx stretched across table
  !          <<r>>xxxx       merge:  right-aligned xxx stretched across table
  !          <<d>>x          divider: inserts a wall of x's
  subroutine outputTableArray ( array, sep, border, cellWidth, &
    & interior, HeadLiner, alignment )
    ! use Dump_0, only: Dump
    ! Args
    character(len=*), dimension(:,:),intent(in)    :: array
    character(len=1), optional, intent(in)         :: sep       ! between cols
    character(len=1), optional, intent(in)         :: border    ! outside
    integer, optional, intent(in)                  :: cellWidth
    character(len=1), optional, intent(in)         :: interior  ! between rows
    character(len=1), optional, intent(in)         :: HeadLiner ! 1st row are headers
    character(len=1), optional, intent(in)         :: alignment ! L, R, or C
    ! Local variables
    character(len=1)                               :: align
    integer                                        :: i
    integer                                        :: j
    integer                                        :: k
    integer                                        :: left
    integer                                        :: minWidth
    character(len=1)                               :: myAlignment
    character(len=1)                               :: myBorder
    character(len=1)                               :: mySep
    character(len=1)                               :: myHeadLiner
    character(len=1)                               :: myInterior
    integer                                        :: right
    integer, dimension(size(array,2))              :: widths
    integer, parameter                             :: leftPadding = 1
    integer, parameter                             :: rightPadding = 1
    integer                                        :: totalWidth
    logical, parameter                             :: debug=.false.
    ! Executable
    minWidth = 3 ! Don't know why, but this works
    if ( present(cellWidth) ) minWidth = cellWidth

    mySep = ' '
    if ( present(sep) ) mySep = sep
    myBorder = ' '
    if ( present(border) ) myBorder = border
    myInterior = ' '
    if ( present(Interior) ) myInterior = Interior
    
    myHeadLiner = myInterior
    if ( present(HeadLiner) ) myHeadLiner = HeadLiner
    
    myAlignment = 'L'
    if ( present(alignment) ) myAlignment = alignment

    ! 1st, compute total table width
    widths = minWidth
    totalWidth = 3
    do j=1, size(array,2)
      widths(j) = maxval( len_trim(array(:,j)) )
      widths(j) = max( widths(j), minWidth )
      totalWidth = totalWidth + widths(j) + leftPadding + rightPadding
      if ( j > 1 .and. j < size(array,2) ) totalWidth = totalWidth + 1
    enddo
    if ( debug ) then
      ! call dump( widths, 'widths' )
      call outputNamedValue( 'totalWidth', totalWidth )
      do i=1, size(array,1)
        call output ( i, advance='no' )
        call blanks(2)
        call output( trim(array(i, 1)), advance='yes' )
      enddo
      do i=1, size(array,1)
        call output ( i, advance='no' )
        call blanks(2)
        call output( trim(array(i, 2)), advance='yes' )
      enddo
    endif
    ! Here we begin printing
    ! Temporarily stop Stamping lines
    OldNeverStamp = stampOptions%neverStamp
    stampOptions%neverStamp = .true.
    if ( len_trim(myBorder) > 0 ) &
      & call output( repeat( myBorder, totalWidth ), advance='yes' )
    do i=1, size(array,1)
      right = 0
      if ( len_trim(myBorder) > 0 ) then
        call output( myBorder, advance='no' )
        right = right + 1
      endif
      ! Special formatting?
      k = index(array(i,1), '<<' )
      if ( k > 0 ) then
        align = array(i,1)(k+2:k+2)
        select case ( lowercase(align))
        case ('l') ! left-aligned merge
          call blanks ( leftPadding )
          call output( trim(array(i,1)(k+5:)), advance='no' )
        case ('c') ! centered merge
          call AlignToFit ( trim(array(i,1)(k+5:)), &
            & (/ right, totalWidth /), 'c' )
        case ('r') ! right-aligned merge
          call AlignToFit ( trim(array(i,1)(k+5:)), &
            & (/ right, totalWidth /), 'r' )
        case ('d') ! wall of chars
          call blanksToColumn( totalWidth, fillChar=array(i,1)(k+5:k+5) )
        end select
        if ( len_trim(myBorder) > 0 ) then
          call blanksToColumn( totalWidth )
          call output( myBorder, advance='yes' )
        else
          call newLine
        endif
        cycle
      endif
      do j=1, size(array,2)
        left = right + 1 + leftPadding
        right = left + widths(j) ! Don't know why, but this works
        call AlignToFit ( trim(array(i,j)), (/ left, right /), myAlignment )
        call blanks ( rightPadding )
        if ( len_trim(mySep) > 0 .and. j < size(array,2) ) then
          call output( mySep, advance='no' )
          right = right + 1
        endif
      enddo
      if ( len_trim(myBorder) > 0 ) then
        call blanksToColumn( totalWidth )
        call output( myBorder, advance='yes' )
      else
        call newLine
      endif
      ! Interior cell walls or HeadLiners
      if ( len_trim(myHeadLiner) > 0 .and. i == 1 .and. &
        & myHeadLiner /= achar(0) ) then
        call output( repeat( myHeadLiner, totalWidth ), advance='yes' )
      elseif ( myInterior == achar(0) .and. i < size(array,1) ) then
        call output( myBorder, advance='no' )
        call blanksToColumn( totalWidth )
        call output( myBorder, advance='yes' )
      elseif ( len_trim(myInterior) > 0 .and. i < size(array,1) ) then
        call output( repeat( myInterior, totalWidth ), advance='yes' )
      endif
    enddo
    if ( len_trim(myBorder) > 0 ) &
      & call output( repeat( myBorder, totalWidth ), advance='yes' )
    ! Restore Stamping
    stampOptions%neverStamp = OldNeverStamp
  end subroutine outputTableArray

  ! ----------------------------------------------  stamp  -----
  function stamp( chars )
  ! stamp input chars before outputting to PRUNIT.
  ! Args
    character(len=*), intent(in) :: chars
    character(len=len(chars)+64) :: stamp
    character(len=16) :: dateString
    character(len=16) :: timeString
    ! Executable
    stamp = chars
    if ( stampOptions%showTime ) then
      dateString = '' ! Intel 12 and earlier doesn't fill with blanks
      timeString = '' ! Intel 12 and earlier doesn't fill with blanks
      call date_and_time ( date=dateString, time=timeString )
      dateString = reFormatDate(trim(dateString), toForm=stampOptions%dateFormat)
      timeString = reFormatTime(trim(timeString), stampOptions%timeFormat)
      if ( stampOptions%dateFormat /= ' ' ) &
      & stamp = catStrings( stamp, dateString )
      if ( stampOptions%timeFormat /= ' ' ) &
      & stamp = catStrings( stamp, timeString )
    end if
    if ( stampOptions%textCode /= ' ' ) &
        & stamp = catStrings( stamp, stampOptions%textCode )
  contains
    function catStrings(a, b) result(c)
      ! Catenates strings a and b with intervening space
      ! if post then a before b
      ! otherwise b before a
      character(len=*), intent(in) :: a
      character(len=*), intent(in) :: b
      character(len = (len(a)+len(b)+1) ) :: c
      if ( stampOptions%post ) then
        c = trim(a) // ' ' // b
      else
        c = trim(b) // ' ' // a
      end if
    end function catStrings
    
  end function stamp 

  ! ........................................  whatSDNeedsFormat
  ! parse inFormat which might be
  ! (1) absent, in which case format=sdNeedsFormat and dotm='.6'
  ! (2) '(*)', in which case format=sdNeedsFormat and dotm='.6'
  ! (3) '(*.m)', in which case format=(sdNeedsFragment //'.m') and dotm='.m'
  subroutine whatSDNeedsFormat ( format, dotm, inFormat )
    character(len=*), optional, intent(in)  :: inFormat
    character(len=*), intent(out)           :: format
    character(len=*), intent(out)           :: dotm
    integer :: dot
    if ( .not. present(inFormat) ) then
      format = sdNeedsFormat
      dotm = '.6'
    else if ( index(inFormat, '.') < 1 ) then
      format = sdNeedsFormat
      dotm = '.6'
    else
      ! Must find integer after '.'
      dot = index( inFormat, '.' )
      dotm = inFormat(dot:dot+1)
      format = trim(sdNeedsFragment) // trim(dotm) // ')'
    end if
  end subroutine whatSDNeedsFormat

  ! ..............................................  not_used_here  .....
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: highOutput.f90,v 2.41 2021/07/22 23:20:14 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module HighOutput

! $Log: highOutput.f90,v $
! Revision 2.41  2021/07/22 23:20:14  pwagner
! Repair printing errors in Calendar
!
! Revision 2.40  2020/06/30 23:18:07  pwagner
! Improved comments among toc and api blocs
!
! Revision 2.39  2020/06/09 21:56:32  pwagner
! report on allocates/deallocates now stands out with stars
!
! Revision 2.38  2020/04/30 23:09:54  pwagner
! Added optional arg IsFinal to FinalMemoryReport
!
! Revision 2.37  2020/04/27 21:32:07  pwagner
! Added procedure to print FinalMemoryReport
!
! Revision 2.36  2019/11/11 23:08:27  pwagner
! Added OutputParagraph
!
! Revision 2.35  2019/10/30 20:07:18  pwagner
! Banner and styledOutput may align output as one of {LRCJ}
!
! Revision 2.34  2019/10/01 23:40:51  vsnyder
! Add Trim optional argument to floating-point output
!
! Revision 2.33  2019/08/01 23:44:25  pwagner
! Removed unused stuff; numerous other changes
!
! Revision 2.32  2019/07/17 20:19:21  pwagner
! StyledOutput can now underline and/or stretch, too
!
! Revision 2.31  2019/07/09 23:52:17  pwagner
! The values added by AddRow may now span several lines if needed
!
! Revision 2.30  2019/05/15 23:20:43  pwagner
! Non-essential housekeeping
!
! Revision 2.29  2019/02/21 22:35:26  pwagner
! Improved DumpOutputOptions
!
! Revision 2.28  2019/01/24 18:33:20  pwagner
! Reorganized modules that print to simplify toolkit-free builds
!
! Revision 2.27  2018/05/11 20:33:36  pwagner
! Make sure myChars long enough; reinitialize outputLines after use
!
! Revision 2.26  2018/04/19 23:42:20  pwagner
! Switch arg may be array in BeVerbose and LetsDebug
!
! Revision 2.25  2018/01/05 01:21:16  pwagner
! Corrected data type for OldNeverStamp
!
! Revision 2.24  2018/01/03 01:13:51  pwagner
! Prevent time stamps from interrupting tables, banners
!
! Revision 2.23  2017/12/22 00:25:24  pwagner
! Add move some items from DumpOuputOptions to new DumpPatternOptions
!
! Revision 2.22  2017/12/14 23:20:48  pwagner
! Added TrimCharacterValues
!
! Revision 2.21  2017/11/30 20:48:59  pwagner
! RestoreSettings may now restore all or just some
!
! Revision 2.20  2017/11/15 00:01:51  pwagner
! Print options%neverStamp as part of Dump
!
! Revision 2.19  2017/10/03 21:44:11  pwagner
! restored bars to Banner; improved comments showing effect of BannerPattern
!
! Revision 2.18  2017/09/29 00:20:27  pwagner
! Added Styled output and options; options as an arg to OutputNamedValue
!
! Revision 2.17  2017/09/07 23:43:40  pwagner
! Improved comments; removed unused myMessage_old
!
! Revision 2.16  2017/01/19 23:33:23  pwagner
! New procedures to add an internal wall or merge cells across a cell table
!
! Revision 2.15  2017/01/13 01:28:32  pwagner
! Rename internal procedure to addCellRowToDatabase
!
! Revision 2.14  2016/12/14 01:22:40  pwagner
! outputCalendar prints new, full moons if moonphases present and ttrue
!
! Revision 2.13  2016/11/15 19:27:19  pwagner
! May print elapsed WallClock_seconds at Finish
!
! Revision 2.12  2016/09/22 22:21:16  pwagner
! May specify format in call to AddRow
!
! Revision 2.11  2016/03/25 00:37:06  pwagner
! Added OUTPUTANYNAMEDVALUE
!
! Revision 2.10  2015/09/24 18:50:41  pwagner
! May choose different pattern for stripes in banner
!
! Revision 2.9  2015/05/18 17:42:50  pwagner
! AddRow and startTable maintains an internal Table for outputTable to output
!
! Revision 2.8  2015/02/24 23:32:22  pwagner
! Make sure rightpadding defined in headLine
!
! Revision 2.7  2015/02/13 00:17:49  pwagner
! Added procedure to output 2d array as Table
!
! Revision 2.6  2015/02/10 01:00:58  pwagner
! Avoid another double-indent error
!
! Revision 2.5  2015/02/06 01:08:20  pwagner
! Can now print to virtual page indented w.r.t. physical page
!
! Revision 2.4  2014/10/06 23:06:26  vsnyder
! Add Signed argument to Dump_Size
!
! Revision 2.3  2014/09/05 00:23:57  vsnyder
! Better handling of literal output unit.  Convert a local pointer temp to
! allocatable.
!
! Revision 2.2  2014/04/22 16:30:57  pwagner
! Banner accepts mode as optional arg
!
! Revision 2.1  2014/01/09 00:22:32  pwagner
! Split output module procedures between it and new highOutput
!
@


2.41
log
@Repair printing errors in Calendar
@
text
@d1283 2
d1288 2
d1293 1
a1293 3
    if ( .not. present ( IsFinal ) ) then
      call Output ( 'Interim', advance='no' )
    elseif ( .not. IsFinal ) then
d1309 7
d2953 1
a2953 1
       "$Id: highOutput.f90,v 2.40 2020/06/30 23:18:07 pwagner Exp $"
d2963 3
@


2.40
log
@Improved comments among toc and api blocs
@
text
@d969 1
a969 1
  subroutine blanksToTab ( tabn, fillChar )
d971 1
a971 1
    integer, optional, intent(in) :: TABN
d973 1
d977 1
d979 2
d992 5
a996 1
      nTab = findFirst( tabStops > nColumn )
d1663 1
d1665 1
a1665 1
    logical :: today
d1764 1
d1770 1
d1780 1
d1785 1
d1815 1
d1818 1
a1818 1
            call blanksToTab
d2944 1
a2944 1
       "$Id: highOutput.f90,v 2.39 2020/06/09 21:56:32 pwagner Exp $"
d2954 3
@


2.39
log
@report on allocates/deallocates now stands out with stars
@
text
@d66 1
d71 2
d109 1
d116 2
d159 1
a159 1
! E.g., calling TimeStamp or using SetStamp before calling output
d161 1
a161 1
! To understand the codes for dateformat and timeFormat, see the dates_module
d163 1
a163 1
! You can use this module to build a 2d table of names and values
d177 3
a179 3
! The first line                                                                
!                                                                The second line
!                                 The third line                                
d184 10
d229 2
a230 1
! to print some intermediate results or messages
d288 2
d291 4
a294 1
  logical, public                      :: TrimCharacterValues = .true.
d313 2
a315 4
  logical, save, private :: OldNeverStamp
  integer, save, private :: OLDWRAPPASTCOLNUM = 0
  integer, save, private :: WRAPPASTCOLNUM = 0  ! Don't print beyond (if > 0)

d324 1
d332 1
d2930 1
a2930 1
       "$Id: highOutput.f90,v 2.38 2020/04/30 23:09:54 pwagner Exp $"
d2940 3
@


2.38
log
@Added optional arg IsFinal to FinalMemoryReport
@
text
@d1258 1
d1266 1
a1266 1
    call Output( ' report on allocates/deallocates', advance='yes' )
d2908 1
a2908 1
       "$Id: highOutput.f90,v 2.37 2020/04/27 21:32:07 pwagner Exp $"
d2918 3
@


2.37
log
@Added procedure to print FinalMemoryReport
@
text
@d1250 1
a1250 1
  subroutine FinalMemoryReport
d1254 2
a1255 1
    ! Print Final report summarizing allocates, deallocates
d1258 8
a1265 1
    call Output( 'Final report on allocates/deallocates', advance='yes' )
d2907 1
a2907 1
       "$Id: highOutput.f90,v 2.36 2019/11/11 23:08:27 pwagner Exp $"
d2917 3
@


2.36
log
@Added OutputParagraph
@
text
@d181 1
a181 1
    & Dump, DumpSize, DumpTabs, GetStamp, HeadLine, &
d1249 22
d2899 1
a2899 1
       "$Id: highOutput.f90,v 2.35 2019/10/30 20:07:18 pwagner Exp $"
d2909 3
@


2.35
log
@Banner and styledOutput may align output as one of {LRCJ}
@
text
@d21 1
a21 1
  use MLSCommon, only: MLSDebug, MLSVerbose
d76 2
d124 2
d168 1
a168 1
! The aligment arg in AlignToFit  can be explained best with an example,
d184 1
a184 1
    & OutputAnyNamedValue, OutputNamedValue, &
d610 2
d621 1
a621 1
      padLeft  = spaces - (char2-char1+1)
d625 3
a627 3
      nc = abs(columnRange(2)-columnRange(1))
      Justified = Justify( allChars, nc-1 )
      call output_( Justified(1:nc-1) )
d641 2
d2058 85
d2146 1
a2146 1
  ! (1)  you may supply the arry; otherwise, dellDatabase will be used
d2877 1
a2877 1
       "$Id: highOutput.f90,v 2.34 2019/10/01 23:40:51 vsnyder Exp $"
d2887 3
@


2.34
log
@Add Trim optional argument to floating-point output
@
text
@d16 1
a16 1
  ! See also dump_0 and output_m
d25 2
a26 1
  use MLSStrings, only: Asciify, Indexes, Lowercase, NCharsInFormat, Ncopies, &
d60 1
a60 1
! BeVerbose                Should we do extra printing?
d69 1
a69 1
! LetsDebug                Should we do debug printing?
d153 1
a153 1
! To use this module to build a 2d table of names and values
d163 12
d208 2
d215 5
a232 5
  interface Letsdebug
    module procedure Letsdebug_Chars
    module procedure Letsdebug_Chararray
  end interface

d393 1
a393 1
  ! This family of routines adds a paired name and value
d399 2
a400 1
  subroutine AddRow_character_blocs ( name, value, BlocLen, options, format )
d407 2
a408 1
    ! will be divided at spaces instead of arbitrarily
d414 1
d417 1
d439 2
d442 2
a443 1
      wrapped = ' '
d446 1
a446 1
        & mode='soft', addedLines=nBlocs )
d566 3
a568 3
  ! R    Flushed right
  ! C    Centered
  ! J    Justified (padding spaces to any existing spaces)
d578 3
a580 1
      & ALLCHARS
d617 8
a624 1
    case ('c', 'j')
d633 2
d697 8
d707 1
a707 1
      & mode, pattern, underline, Stretched )
d718 2
d732 2
d756 4
d775 1
a775 1
    else
d780 4
d799 5
a803 3
    call output( '*' )
    call blanks ( lineLen-2, FillChar=myFillChar )
    call output( '*', advance = 'yes' )
d818 5
a822 3
    call output( '*' )
    call blanks ( lineLen-2, FillChar=myFillChar )
    call output( '*', advance = 'yes' )
d916 1
a916 1
  ! Output N_BLANKS blanks to PRUNIT out to column COLUMN.
d938 1
d1262 1
a1262 1
  ! See also banner
d1909 10
a1918 10
  ! before: what extra to print at start of each line
  ! after: what extra to print at end of each line
  ! colon: what to print instead of ':'
  ! fillChar: instead of spaces if you use tabs to align name, value
  ! tabn: column number where name begins
  ! tabc: column number where colon occurs
  ! taba: column number where after begins
  ! advance: whether to advance after printing pair (by default we WILL advance)
  ! dont_stamp: override setting to stamp end of each line
  ! By means of optional args you can create a line like
d1923 14
a1936 14
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
    character(len=*), intent(in)          :: name
    character(len=*), intent(in), optional:: chvalue
    complex, intent(in), optional         :: cmvalue
    double precision, intent(in), optional:: dbvalue
    integer, intent(in), optional         :: ivalue
    real, intent(in), optional            :: snvalue
    character(len=*), intent(in), optional :: ADVANCE
    character(len=1), intent(in), optional :: COLON
    character(len=1), intent(in), optional :: fillChar
    integer, intent(in), optional :: TABN
    integer, intent(in), optional :: TABC
    integer, intent(in), optional :: TABA
    logical, intent(in), optional :: DONT_STAMP
d1942 1
a1942 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d1945 1
a1945 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d1948 1
a1948 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d1951 1
a1951 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d1954 1
a1954 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d1959 1
a1959 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d1973 1
a1973 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d1976 1
a1976 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d1980 1
a1980 1
      & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d1988 1
a1988 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d1995 1
a1995 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d2002 1
a2002 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d2009 1
a2009 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d2016 1
a2016 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d2023 1
a2023 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d2030 1
a2030 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d2037 1
a2037 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d2044 1
a2044 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP, options )
d2211 4
d2224 1
d2227 1
d2229 1
d2243 3
d2247 10
d2258 3
a2260 1
      call Banner( chars, Underline=Underline, Stretched=Stretched )
d2784 1
a2784 1
       "$Id: highOutput.f90,v 2.33 2019/08/01 23:44:25 pwagner Exp $"
d2794 3
@


2.33
log
@Removed unused stuff; numerous other changes
@
text
@d1433 1
a1433 1
  function numToChars_double( value, format ) result ( line )
d1437 2
d1466 1
a1466 1
  function numToChars_single( value, format ) result ( line )
d1470 2
d2704 1
a2704 1
       "$Id: highOutput.f90,v 2.32 2019/07/17 20:19:21 pwagner Exp $"
d2714 3
@


2.32
log
@StyledOutput can now underline and/or stretch, too
@
text
@d62 1
a62 1
! Dump                     Dump output or stamp options
d78 1
a78 1
! RestoreSettings          Restore default settings for output, stamps, tabs
d124 1
a124 1
! RestoreSettings ( [log useToolkit] )
d201 2
a202 2
    module procedure DumpOutputoptions, Dumppatternoptions, &
      & Dumpstampoptions, DumpTimeStampoptions
d908 4
a911 2
    ! Show output options
    type(outputOptions_T), intent(in) :: options
d913 2
a914 1
    logical, parameter :: checkingTabbing = .false.
d916 9
a924 3
    character(len=1), parameter :: fillChar = '1' ! fill blanks with '. .'
    integer :: i
    ! Executable
d928 1
a928 1
    call outputNamedValue ( 'unit number', options%prUnit, advance='yes', &
d931 1
a931 1
      call outputNamedValue ( 'meaning', prunitname(options ), &
d935 1
a935 1
    call outputNamedValue ( 'file name', trim(options%name), advance='yes', &
d937 1
a937 1
    call outputNamedValue ( 'logging level', &
d940 7
a946 1
    call outputNamedValue ( 'buffered?', options%buffered, advance='yes', &
d948 1
a948 1
    call outputNamedValue ( 'skip MLSMSG logging?', options%SKIPMLSMSGLOGGING, advance='yes', &
d950 1
a950 1
    call outputNamedValue ( 'log Parent Name?', options%logParent, advance='yes', &
d952 1
a952 1
    call outputNamedValue ( 'advanceDefault', options%advanceDefault, advance='yes', &
d954 2
a955 1
    call outputNamedValue ( 'sdFormatDefault', options%sdFormatDefault, advance='yes', &
d957 1
a957 1
    call outputNamedValue ( 'tab stops', tabstops, advance='yes', &
d981 1
a981 1
      type(outputOptions_T), intent(in) :: options
d1007 1
a1007 1
    ! Show output options
d1027 1
a1027 1
    ! Show output options
d1033 1
a1033 1
     call outputNamedValue ( 'never stamp', options%neverStamp, advance='yes', &
d1035 1
a1035 1
     call outputNamedValue ( 'stamp end of line', options%post, advance='yes', &
d1037 1
a1037 1
     call outputNamedValue ( 'show time', options%showTime, advance='yes', &
d1039 1
a1039 1
     call outputNamedValue ( 'extra text', trim_safe(options%textCode), advance='yes', &
d1041 1
a1041 1
     call outputNamedValue ( 'date format', trim_safe(options%dateFormat), advance='yes', &
d1043 1
a1043 1
     call outputNamedValue ( 'time format', trim_safe(options%timeFormat), advance='yes', &
d1045 1
a1045 1
     call outputNamedValue ( 'interval', options%interval, advance='yes', &
d1047 1
a1047 1
     call outputNamedValue ( 'style of TimeStamps', trim_safe(options%TimeStampstyle), advance='yes', &
d1060 1
a1060 1
     call outputNamedValue ( 'stamp end of line', options%post, advance='yes', &
d1062 1
a1062 1
     call outputNamedValue ( 'show date', options%showDate, advance='yes', &
d1064 1
a1064 1
     call outputNamedValue ( 'extra text', trim_safe(options%textCode), advance='yes', &
d1066 1
a1066 1
     call outputNamedValue ( 'date format', trim_safe(options%dateFormat), advance='yes', &
d1068 1
a1068 1
     call outputNamedValue ( 'time format', trim_safe(options%timeFormat), advance='yes', &
d1070 1
a1070 1
     call outputNamedValue ( 'style of TimeStamps', trim_safe(options%TimeStampstyle), advance='yes', &
d1442 1
a1442 1
    FormatSpec = outputOptions%sdFormatDefault
d1473 1
a1473 1
    FormatSpec = outputOptions%sdFormatDefault
d1704 13
a1716 10
    logical, intent(in), optional :: date ! output date as character string
    logical, intent(in), optional :: time ! output time as character string
    character(len=*), intent(in), optional :: FROM_WHERE
    character(len=*), intent(in), optional :: MSG
    character(len=*), intent(in), optional :: DATEFORMAT
    character(len=*), intent(in), optional :: TIMEFORMAT
    double precision, intent(in), optional :: CPU_Seconds
    integer, intent(in), optional          :: wallClock_Seconds
    character(len=*), intent(in), optional :: ADVANCE

d1725 1
a1725 1

d2048 2
a2049 2
  ! Restore tab stops to what was in effect at start
  ! Optionally returning them as an integer array
d2054 1
a2054 2
    character(len=*), parameter            :: allSettings = &
      & 'style'
d2062 1
a2631 24
  ! ------------------------------------  SeparateElements  -----
  ! insert blanks or separator between consecutive elements while outputting
  subroutine SeparateElements (i, n )
    ! Args
    integer, intent(in) :: i ! Element number
    integer, intent(in) :: n ! Number of elements
    ! Executable
    if ( i >= n ) return
    if ( wrappastcolnum > 0 .and. getOutputStatus( 'column' ) >= wrappastcolnum ) then
      call newLine
      return
    end if
    if ( wrappastcolnum == 0 .and. &
      & mod(i, outputOptions%nArrayElmntsPerLine) == 0 ) then
      call output_ ( '', advance='yes', DONT_STAMP=.true. )
      return
    end if
    if ( len_trim(outputOptions%arrayElmntSeparator) > 0 ) then
      call output_( outputOptions%arrayElmntSeparator, advance='no' )
    else
      call blanks ( outputOptions%nBlanksBtwnElmnts, advance='no' )
    end if
  end subroutine SeparateElements

d2700 1
a2700 1
       "$Id: highOutput.f90,v 2.31 2019/07/09 23:52:17 pwagner Exp $"
d2710 3
@


2.31
log
@The values added by AddRow may now span several lines if needed
@
text
@d25 2
a26 2
  use MLSStrings, only: Asciify, Lowercase, NCharsInFormat, Ncopies, &
    & Trim_Safe, WriteIntsToChars
d48 2
d51 5
a55 5
! AddRow                   add a {name, value} row to a 2-d table of cells
! AddRow_header            add a single line stretched across an entire row
! AddRow_divider           add a row composed of a single, repeated character
! AlignToFit               align printed argument to fit column range
! Banner                   surround message with stars and stripes; e.g.,
d60 7
a66 7
! BlanksToColumn           print blanks [or fill chars] out to specified column
! BlanksToTab              print blanks [or fill chars] out to next tab stop
! Dump                     dump output or stamp options
! Dumpsize                 print a nicely-formatted memory size 
! Dumptabs                 print the current tab stop positions
! GetStamp                 get stamp being added to every output
! HeadLine                 print a line with eye-catching features
d69 16
a84 16
! NumNeedsFormat           return what format is needed to output num
! NumToChars               return what string would be printed by output
! OutputCalendar           output nicely-formatted calendar page
! Output_Date_And_Time     print nicely formatted date and time
! OutputList               output array as comma-separated list; e.g. '(1,2,..)'
! OutputNamedValue         print nicely formatted name and value
! OutputTable              output 2-d array as cells in table,; or else
!                          output the 2d table of cells constucted by AddRow(s)
! ResetTabs                restore tab stops to what was in effect at start
! RestoreSettings          restore default settings for output, stamps, tabs
! SetStamp                 set stamp to be automatically printed on every line
! SetTabs                  set tab stops (to be used by tab)
! StartTable               initialize a 2-d table of cells to be output later
! StyledOutput             output a line according to options; e.g. "--Banner"
! Tab                      move to next tab stop
! Timestamp                print argument with a timestamp manually
d94 1
a94 1
!    [int lineLength], [char mode], [char pattern] )
d107 1
a107 1
!          [int columnRange(2)], [char alignment], [int skips] )
d349 1
d351 7
a357 6
    character(len=1) :: HeadLineAlignment        = 'C'
    character(len=1) :: HeadLineFill             = ' '
    character(len=8) :: HeadLineBefore           = ' '
    character(len=8) :: HeadLineAfter            = ' '
    integer, dimension(2) :: HeadLineColumnrange = (/ 1, 80 /)
    integer          :: HeadLineSkips            = 0
d359 6
a364 5
    character(len=1) :: BannerAlignment          = 'C'
    character(len=1) :: BannerPattern            = '-'
    integer, dimension(2) :: BannerColumnrange   = (/ 1, 80 /)
    integer          :: BannerSkips              = 0
    integer          :: BannerLength             = 0
a384 1
    use MLSStrings, only: Indexes
d407 1
a407 1
    logical, parameter                       :: DEEBug = .false.
d415 1
a415 1
        & 'Value contains quoted material--cannot wrap' )
d547 2
a548 2
  subroutine AlignToFit_CHARS ( CHARS, COLUMNRANGE, ALIGNMENT, SKIPS )
    character(len=*), intent(in)      :: CHARS
d550 3
a552 3
    integer, dimension(2), intent(in) :: COLUMNRANGE
    character(len=1), intent(in)      :: ALIGNMENT ! L, R, C, or J
    integer, optional, intent(in)     :: SKIPS ! How many spaces between chars
d569 1
a569 1
        allChars = stretch(chars, skips)
d611 1
a611 1
  end subroutine AlignToFit_CHARS
d613 2
a614 2
  subroutine AlignToFit_DOUBLE ( value, COLUMNRANGE, ALIGNMENT, FORMAT )
    double precision, intent(in)      :: value
d616 3
a618 3
    integer, dimension(2), intent(in) :: COLUMNRANGE
    character(len=1), intent(in)      :: ALIGNMENT ! L, R, C, or J
    character(len=*), optional, intent(in)     :: FORMAT
d625 1
a625 1
  end subroutine AlignToFit_DOUBLE
d627 2
a628 2
  subroutine AlignToFit_INTEGER ( value, COLUMNRANGE, ALIGNMENT, FORMAT )
    integer, intent(in)               :: value
d630 3
a632 3
    integer, dimension(2), intent(in) :: COLUMNRANGE
    character(len=1), intent(in)      :: ALIGNMENT ! L, R, C, or J
    character(len=*), optional, intent(in)     :: FORMAT
d639 1
a639 1
  end subroutine AlignToFit_INTEGER
d641 2
a642 2
  subroutine AlignToFit_SINGLE ( value, COLUMNRANGE, ALIGNMENT, FORMAT )
    real, intent(in)      :: value
d644 3
a646 3
    integer, dimension(2), intent(in) :: COLUMNRANGE
    character(len=1), intent(in)      :: ALIGNMENT ! L, R, C, or J
    character(len=*), optional, intent(in)     :: FORMAT
d653 1
a653 1
  end subroutine AlignToFit_SINGLE
d664 4
a667 3
  subroutine Banner_Chars ( chars, &
    & columnRange, alignment, skips, lineLength, mode, pattern )
    character(len=*), intent(in)                :: CHARS
d669 4
a672 4
    integer, dimension(2), optional, intent(in) :: COLUMNRANGE
    character(len=1), intent(in), optional      :: ALIGNMENT ! L, R, C, or J
    integer, optional, intent(in)               :: SKIPS ! How many spaces between chars
    integer, optional, intent(in)               :: LINELENGTH
d675 2
d679 11
a689 5
    integer :: addedLines
    character(len=1)      :: myAlignment
    character(len=1)      :: myFillChar
    integer, dimension(2) :: myColumnRange
    integer :: lineLen, mySkips, padding
a690 2
    character(len=160), dimension(:), allocatable :: lines
    logical, parameter :: DEBUG = .false.
d692 1
d700 5
d706 5
d752 1
a752 1
    call blanksToColumn( lineLen )
d754 8
d776 1
a776 1
    integer, optional, intent(in)               :: SKIPS ! How many spaces between chars
d822 1
a822 1
      call blanksToColumn( lineLen )
d857 2
a858 2
  ! -----------------------------------------------------  BLANKSTOCOLUMN  -----
  subroutine BLANKSTOCOLUMN ( column, fillchar, advance, dont_stamp )
d876 1
a876 1
  end subroutine BLANKSTOCOLUMN
d1189 3
a1191 3
  subroutine HeadLine ( Chars, fillChar, Before, After, &
    & ColumnRange, Alignment, Skips )
    character(len=*), intent(in)                :: Chars
d1195 5
a1199 3
    integer, dimension(2), optional, intent(in) :: COLUMNRANGE
    character(len=1), intent(in), optional      :: ALIGNMENT ! L, R, C, or J
    integer, optional, intent(in)               :: SKIPS ! How many spaces between chars
d1202 1
d1206 6
a1211 3
    integer :: mySkips,  rightpadding
    character(len=1) :: myFillChar
    character(len=8) :: myBefore, myAfter
d1213 1
d1228 9
d1269 6
d2121 1
a2121 1
  ! e.g., "--Banner"
d2124 10
a2133 1
  ! We could dig more deeply into options to allow\
d2139 5
a2143 2
    logical :: asBanner
    logical :: asHeadLine
d2153 2
d2156 2
a2157 1
      call Banner( chars ) 
d2162 2
a2163 1
      call HeadLine( chars ) 
d2165 13
d2326 1
a2326 1
    allocate ( tempDatabase(newSize,2), STAT=status )
a2676 20
  ! ----------------------------------------------  stretch  -----
  function stretch( arg, skips ) result(chars)
  ! stretch input arg by inserting skips number of spaces
  ! between each pair of consecutive characters
  ! Args
    character(len=*), intent(in)      :: arg
    integer, intent(in)               :: skips
    character(len=(1+skips)*len(arg)) :: chars
    ! Internal variables
    integer :: i, k
    ! Executable
    chars = ' '
    if ( len_trim(arg) < 1 ) return
    do i=1, len_trim(arg)
      ! E.g., if skips==1, k ~ 1 3 5 7 ..
      k = 1 + (skips+1)*(i-1)
      chars(k:k) = arg(i:i)
    end do
  end function stretch

d2705 1
a2705 1
       "$Id: highOutput.f90,v 2.30 2019/05/15 23:20:43 pwagner Exp $"
d2715 3
@


2.30
log
@Non-essential housekeeping
@
text
@d22 1
a22 1
  use MLSFinds, only: FindFirst
d31 1
a31 1
    & OutputOptions, OutputOptions_T, PatternOptions, PatternOptions_T, &
d49 1
a49 1
! AddRow                   add name, value row to a 2-d table of cells
d70 1
a70 1
! Output_date_and_time     print nicely formatted date and time
d73 3
a75 2
! OutputTable              output 2-d array as cells in table
! Resettabs                restore tab stops to what was in effect at start
d87 1
a87 1
! AddRow ( char* name, value )
d109 1
a109 1
! Output_date_and_time ( [log date], [log time], [char* from_where], 
d146 1
a146 1
! E.g., calling timeStamp or using setStamp before calling output
d175 1
a175 1
    module procedure AddRow_Character
d200 1
a200 1
      & Dumpstampoptions, Dumptimestampoptions
d216 3
a218 3
  interface Numneedsformat
    module procedure Numneedsformat_Double, Numneedsformat_Integer, Numneedsformat_Single
    module procedure Numneedsformat_Complex, Numneedsformat_Dcomplx
d221 2
a222 2
  interface Numtochars
    module procedure Numtochars_Double, Numtochars_Integer, Numtochars_Single
d246 2
a247 2
  interface Timestamp
    module procedure Timestamp_Char, Timestamp_Integer, Timestamp_Logical
d374 1
a374 1
  ! as a new row to the cellDatabase
d379 80
a963 2
    logical, parameter :: checkingTabbing = .false.
    character(len=10), parameter :: decade = '1234567890'
a964 1
    integer :: i
d1001 1
a1001 1
     call outputNamedValue ( 'style of timeStamps', trim_safe(options%timestampstyle), advance='yes', &
d1024 1
a1024 1
     call outputNamedValue ( 'style of timeStamps', trim_safe(options%timestampstyle), advance='yes', &
d1343 1
a1343 1
  function numNeedsFormat_dcomplx( value, inFormat ) result ( format )
d1962 1
a1962 1
  subroutine resetTabs ( tabs )
d1974 1
a1974 1
  end subroutine resetTabs
d1995 2
a1996 2
  ! ----------------------------------------------  setStamp  -----
  subroutine setStamp ( textCode, showTime, dateFormat, timeFormat, &
d2011 1
a2011 1
  end subroutine setStamp
d2014 1
a2014 1
  subroutine setTabs ( RANGE, TABS )
d2018 3
a2020 2
    !     is converterd to "8, 32, 40, 48, 56, 64, 72, 80, 88, 96"
    ! (2) an arrays of ints; e.g., (/ 4, 9, 12, 18, 22, 30, 35, 40 /)
d2102 1
a2102 1
  ! ------------------------------------------------  timeStamp  -----
d2109 2
a2110 2
  subroutine timeStamp_char ( CHARS, &
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, STYLE, DATE )
d2126 1
a2126 1
    my_style = timeStampOptions%Timestampstyle
d2128 1
a2128 1
    myDate = timeStampOptions%showDate
d2136 3
a2138 3
        call OUTPUT_DATE_AND_TIME( date=myDate, &
          & dateFormat=timeStampOptions%dateFormat, &
          & timeFormat=timeStampOptions%timeFormat, &
d2145 3
a2147 3
        call OUTPUT_DATE_AND_TIME( date=myDate, &
          & dateFormat=timeStampOptions%dateFormat, &
          & timeFormat=timeStampOptions%timeFormat, &
d2151 3
a2153 3
      call output_( CHARS, &
        & ADVANCE, FROM_WHERE, DONT_LOG, &
        & LOG_CHARS, INSTEADOFBLANK, DONT_STAMP=DONT_STAMP )
d2155 1
a2155 1
  end subroutine timeStamp_char
d2157 2
a2158 2
  subroutine timeStamp_integer ( INT, &
    & PLACES, ADVANCE, FILL, FORMAT, Before, After, style, date )
d2174 1
a2174 1
    my_style = timeStampOptions%Timestampstyle
d2176 1
a2176 1
    myDate = timeStampOptions%showDate
d2184 3
a2186 3
        call OUTPUT_DATE_AND_TIME( date=myDate, &
          & dateFormat=timeStampOptions%dateFormat, &
          & timeFormat=timeStampOptions%timeFormat, &
d2193 3
a2195 3
        call OUTPUT_DATE_AND_TIME( date=myDate, &
          & dateFormat=timeStampOptions%dateFormat, &
          & timeFormat=timeStampOptions%timeFormat, &
d2199 2
a2200 2
      call output( INT, PLACES, &
        & ADVANCE, FILL, FORMAT, BEFORE, AFTER, DONT_STAMP=DONT_STAMP )
d2202 1
a2202 1
  end subroutine timeStamp_integer
d2204 2
a2205 2
  subroutine timeStamp_logical ( value, &
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, STYLE, DATE )
d2222 3
a2224 3
    call timeStamp_char(str, &
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, STYLE, DATE )
  end subroutine timeStamp_logical
a2404 1
    character(len=MAXCELLSIZE)                     :: cell
d2644 1
a2644 1
       "$Id: highOutput.f90,v 2.29 2019/02/21 22:35:26 pwagner Exp $"
d2654 3
@


2.29
log
@Improved DumpOutputOptions
@
text
@d151 2
a152 2
! (2) Optionally call addRow_header
! (3) Optionally call addRow_divider
d182 3
a184 3
  interface Aligntofit
    module procedure Aligntofit_Chars, Aligntofit_Double, Aligntofit_Single
    module procedure Aligntofit_Integer
d224 2
a225 2
  interface Outputlist
    module procedure Outputlist_Ints, Outputlist_Chars
d292 1
a292 1
  ! of choosing different HeadlineFill or BannerPattern characters:
d346 1
a346 1
    ! Headline
d371 1
a371 1
  ! ----------------------------------------------  addRow  -----
d378 1
a378 1
  subroutine addRow_character ( name, value, format )
d382 1
a382 1
  end subroutine addRow_character
d384 1
a384 1
  subroutine addRow_complex ( name, value, format )
d388 1
a388 1
  end subroutine addRow_complex
d390 1
a390 1
  subroutine addRow_double ( name, value, format )
d394 1
a394 1
  end subroutine addRow_double
d396 1
a396 1
  subroutine addRow_dbl_array ( name, value, format )
d400 1
a400 1
  end subroutine addRow_dbl_array
d402 1
a402 1
  subroutine addRow_int_array ( name, value, format )
d406 1
a406 1
  end subroutine addRow_int_array
d408 1
a408 1
  subroutine addRow_integer ( name, value, format )
d412 1
a412 1
  end subroutine addRow_integer
d414 1
a414 1
  subroutine addRow_log_array ( name, value, format )
d418 1
a418 1
  end subroutine addRow_log_array
d420 1
a420 1
  subroutine addRow_logical ( name, value, format )
d424 1
a424 1
  end subroutine addRow_logical
d426 1
a426 1
  subroutine addRow_single ( name, value, format )
d430 1
a430 1
  end subroutine addRow_single
d432 1
a432 1
  subroutine addRow_sngl_array ( name, value, format )
d436 1
a436 1
  end subroutine addRow_sngl_array
d438 1
a438 1
  subroutine addRow_header ( name, alignment )
d445 1
a445 1
  end subroutine addRow_header
d447 1
a447 1
  subroutine addRow_divider ( char )
d453 1
a453 1
  end subroutine addRow_divider
d455 1
a455 1
  ! -----------------------------------------------------  ALIGNTOFIT  -----
d462 1
a462 1
  subroutine ALIGNTOFIT_CHARS ( CHARS, COLUMNRANGE, ALIGNMENT, SKIPS )
d526 1
a526 1
  end subroutine ALIGNTOFIT_CHARS
d528 1
a528 1
  subroutine ALIGNTOFIT_DOUBLE ( value, COLUMNRANGE, ALIGNMENT, FORMAT )
d539 2
a540 2
    call alignToFit( trim(line), columnRange, alignment )
  end subroutine ALIGNTOFIT_DOUBLE
d542 1
a542 1
  subroutine ALIGNTOFIT_INTEGER ( value, COLUMNRANGE, ALIGNMENT, FORMAT )
d553 2
a554 2
    call alignToFit( trim(line), columnRange, alignment )
  end subroutine ALIGNTOFIT_INTEGER
d556 1
a556 1
  subroutine ALIGNTOFIT_SINGLE ( value, COLUMNRANGE, ALIGNMENT, FORMAT )
d567 2
a568 2
    call alignToFit( trim(line), columnRange, alignment )
  end subroutine ALIGNTOFIT_SINGLE
d570 1
a570 1
  ! -----------------------------------------------------  BANNER  -----
d579 1
a579 1
  subroutine BANNER_CHARS ( chars, &
d648 1
a648 1
    call alignToFit( chars, myColumnRange, myAlignment, skips )
d657 1
a657 1
  end subroutine BANNER_CHARS
d659 1
a659 1
  subroutine BANNER_CHARARRAY ( charArray, &
d710 1
a710 1
      call alignToFit( chararray(i), myColumnRange, myAlignment, skips )
d720 1
a720 1
  end subroutine BANNER_CHARARRAY
d795 1
a795 1
  ! ---------------------------------------------- DumpOuputOptions -----
d806 1
a806 1
    call headline( 'Summary of output options', &
d833 1
a833 1
      call tab( fillChar=fillChar )
d889 1
a889 1
    call headline( 'Summary of pattern options', &
d907 1
a907 1
    call headline( 'Summary of automatic stamp options', &
d928 2
a929 2
  ! ---------------------------------------------- DUMPTIMESTAMPOPTIONS -----
  subroutine DUMPTIMESTAMPOPTIONS( options )
d934 1
a934 1
    call headline( 'Summary of time stamp options', &
d949 1
a949 1
  end subroutine DUMPTIMESTAMPOPTIONS
d1077 1
a1077 1
  ! -----------------------------------------------------  HEADLINE  -----
d1081 1
a1081 1
  subroutine HEADLINE ( CHARS, fillChar, Before, After, &
d1083 1
a1083 1
    character(len=*), intent(in)                :: CHARS
d1103 1
a1103 1
      myFullColumnRange = StyleOptions%HeadlineColumnRange ! (/ 1, 80 /)
d1107 1
a1107 1
    mySkips = StyleOptions%HeadlineSkips ! 0
d1109 1
a1109 1
    myFillChar = StyleOptions%Headlinefill ! ' '
d1111 1
a1111 1
    myAlignment = StyleOptions%HeadlineAlignment ! 'C'
d1113 2
a1114 2
    myBefore = StyleOptions%HeadlineBefore
    myAfter = StyleOptions%HeadlineAfter
d1135 1
a1135 1
      call aligntofit( chars, myColumnRange, myAlignment, skips )
d1140 1
a1140 1
      call aligntofit( chars, myColumnRange, myAlignment, skips )
d1145 1
a1145 1
  end subroutine HEADLINE
d1335 2
a1336 2
  ! ---------------------------------------  OUTPUTCALENDAR  -----
  subroutine OUTPUTCALENDAR ( date, datenote, notes, dontWrap, moonPhases )
d1443 1
a1443 1
    call alignToFit( trim(monthName(month)), (/ 1, 100 /), 'c', skips=1 )
d1449 1
a1449 1
      call alignToFit( trim(daysOfWeek(wkdy)), (/ col1, col2 /), 'c' )
d1499 1
a1499 1
            call alignToFit( trim(dateString), (/ col1, col2-1 /), 'r' )
d1503 1
a1503 1
            call alignToFit( 'd' // trim(dateString), (/ col1, col2-1 /), 'r' )
d1548 1
a1548 1
  end subroutine OUTPUTCALENDAR
d1550 2
a1551 2
  ! ---------------------------------------  OUTPUT_DATE_AND_TIME  -----
  subroutine OUTPUT_DATE_AND_TIME ( date, time, &
d1635 1
a1635 1
  end subroutine OUTPUT_DATE_AND_TIME
d1637 1
a1637 1
  ! ----------------------------------------------  OUTPUTLIST  -----
d1642 1
a1642 1
  subroutine OUTPUTLIST_CHARS ( array, sep, delims )
d1663 1
a1663 1
  end subroutine OUTPUTLIST_CHARS
d1665 1
a1665 1
  subroutine OUTPUTLIST_INTS ( array, sep, delims )
d1686 1
a1686 1
  end subroutine OUTPUTLIST_INTS
d1688 1
a1688 1
  ! ----------------------------------------------  outputNamedValue  -----
d1709 2
a1710 2
  ! See also startTable, addRow, outputTable
  subroutine output_nvp_whatever ( name, &
d1730 1
a1730 1
      call output_nvp_character ( name, chvalue, &
d1733 1
a1733 1
      call output_nvp_complex ( name, cmvalue, &
d1736 1
a1736 1
      call output_nvp_double ( name, dbvalue, &
d1739 1
a1739 1
      call output_nvp_integer ( name, ivalue, &
d1742 1
a1742 1
      call output_nvp_single ( name, snvalue, &
d1745 1
a1745 1
  end subroutine output_nvp_whatever
d1747 1
a1747 1
  subroutine output_nvp_character ( name, value, &
d1774 1
a1774 1
  end subroutine output_nvp_character
d1776 1
a1776 1
  subroutine output_nvp_complex ( name, value, &
d1781 1
a1781 1
  end subroutine output_nvp_complex
d1783 1
a1783 1
  subroutine output_nvp_double ( name, value, &
d1788 1
a1788 1
  end subroutine output_nvp_double
d1790 1
a1790 1
  subroutine output_nvp_dbl_array ( name, value, &
d1795 1
a1795 1
  end subroutine output_nvp_dbl_array
d1797 1
a1797 1
  subroutine output_nvp_int_array ( name, value, &
d1802 1
a1802 1
  end subroutine output_nvp_int_array
d1804 1
a1804 1
  subroutine output_nvp_integer ( name, value, &
d1809 1
a1809 1
  end subroutine output_nvp_integer
d1811 1
a1811 1
  subroutine output_nvp_log_array ( name, value, &
d1816 1
a1816 1
  end subroutine output_nvp_log_array
d1818 1
a1818 1
  subroutine output_nvp_logical ( name, value, &
d1823 1
a1823 1
  end subroutine output_nvp_logical
d1825 1
a1825 1
  subroutine output_nvp_single ( name, value, &
d1830 1
a1830 1
  end subroutine output_nvp_single
d1832 1
a1832 1
  subroutine output_nvp_sngl_array ( name, value, &
d1837 1
a1837 1
  end subroutine output_nvp_sngl_array
d1839 1
a1839 1
  ! ----------------------------------------------  outputTable  -----
d1853 1
a1853 1
  !      by a wall of special headliner characters
d1855 1
a1855 1
    & interior, headliner, alignment )
d1863 1
a1863 1
    character(len=1), optional, intent(in)         :: headliner ! 1st row are headers
d1870 1
a1870 1
        & interior, headliner, alignment )
d1875 1
a1875 1
        & interior, headliner, alignment )
d1881 1
a1881 1
  ! ----------------------------------------------  resetTabs  -----
d1974 1
a1974 1
  !      by a wall of special headliner characters
d2000 1
a2000 1
    logical :: asHeadline
d2003 1
a2003 1
    asHeadline = .false.
d2009 1
a2009 1
    asHeadline = index( options, 'H' ) > 0
d2012 1
a2012 1
    elseif ( asHeadline ) then
d2016 1
a2016 1
      call Headline( chars ) 
d2305 1
a2305 1
  !      by a wall of special headliner characters
d2314 1
a2314 1
    & interior, headliner, alignment )
d2322 1
a2322 1
    character(len=1), optional, intent(in)         :: headliner ! 1st row are headers
d2335 1
a2335 1
    character(len=1)                               :: myHeadliner
d2354 2
a2355 2
    myHeadliner = myInterior
    if ( present(headliner) ) myHeadliner = headliner
d2404 1
a2404 1
          call aligntofit ( trim(array(i,1)(k+5:)), &
d2407 1
a2407 1
          call aligntofit ( trim(array(i,1)(k+5:)), &
d2423 1
a2423 1
        call alignToFit ( trim(array(i,j)), (/ left, right /), myAlignment )
d2436 4
a2439 4
      ! Interior cell walls or headliners
      if ( len_trim(myheadliner) > 0 .and. i == 1 .and. &
        & myheadliner /= achar(0) ) then
        call output( repeat( myheadliner, totalWidth ), advance='yes' )
d2566 1
a2566 1
       "$Id: highOutput.f90,v 2.28 2019/01/24 18:33:20 pwagner Exp $"
d2573 1
a2573 1
end module HIGHOUTPUT
d2576 3
d2628 1
a2628 1
! May specify format in call to addRow
d2637 1
a2637 1
! addRow and startTable maintains an internal Table for outputTable to output
@


2.28
log
@Reorganized modules that print to simplify toolkit-free builds
@
text
@d40 1
a40 1
    & PrintItOut, MLSMessageConfig
d817 2
a818 1
    call outputNamedValue ( 'logging level', options%MLSMSG_Level, advance='yes', &
d2566 1
a2566 1
       "$Id: highOutput.f90,v 2.27 2018/05/11 20:33:36 pwagner Exp $"
d2576 3
@


2.27
log
@Make sure myChars long enough; reinitialize outputLines after use
@
text
@d24 2
a25 2
    & List2Array, NCharsInFormat, NumStringElements, SwitchDetail, Wrap
  use MLSStrings, only: Asciify, Lowercase, Ncopies, &
d2565 1
a2565 1
       "$Id: highOutput.f90,v 2.26 2018/04/19 23:42:20 pwagner Exp $"
d2575 3
@


2.26
log
@Switch arg may be array in BeVerbose and LetsDebug
@
text
@d28 1
a28 1
    & Newline, &
d2565 1
a2565 1
       "$Id: highOutput.f90,v 2.25 2018/01/05 01:21:16 pwagner Exp $"
d2575 3
@


2.25
log
@Corrected data type for OldNeverStamp
@
text
@d86 5
a90 5
! addRow ( char* name, value )
! addRow_header ( char* name, char alignment )
! addRow_divider ( char char )
! alignToFit ( char* chars, int columnRange(2), char alignment, [int skips] )
! banner ( char* chars, [int columnRange(2)], [char alignment], [int skips], 
d92 3
a94 3
! log BeVerbose ( char* switch, threshold )
! blanksToColumn ( int column, [char fillChar], [char* advance] )
! blanksToTab ( [int tabn], [char* fillChar] )
d100 1
a100 1
! getStamp ( [char* textCode], [log post], [int interval],
d102 1
a102 1
! headLine ( char* chars, 
d105 4
a108 4
! log LetsDebug ( char* switch, threshold )
! char* numNeedsFormat ( value )
! char* numToChars ( value, [char* format] )
! output_date_and_time ( [log date], [log time], [char* from_where], 
d111 1
a111 1
! outputCalendar ( [char* date], [char* datenote], [char* notes(:)], 
d113 2
a114 2
! outputList ( values(:), [char* sep], [char* delims] )
! outputNamedValue ( char* name, value, [char* advance],
d118 1
a118 1
! outputTable ( [array(:,:)], [char sep], [char border], [int cellWidth],
d120 3
a122 3
! resetTabs ( [int tabs(:)] )
! restoreSettings ( [log useToolkit] )
! setStamp ( [char* textCode], [log post], [int interval],
d124 5
a128 5
! setTabs ( [char* Range], [int tabs(:)] )
! startTable
! styledOutput ( char* chars, [char* options] )
! tab ( [int tabn], [char* fillChar] )
! timeStamp ( char* chars, [char* advance], [char* from_where], 
d131 1
a131 1
! timeStamp ( log value, [char* advance], [char* from_where], 
d134 1
a134 1
! timeStamp ( int int, [int places], [char* advance],
d157 10
a166 8
  public :: addRow, addRow_divider, addRow_header, alignToFit, &
    & banner, beVerbose, blanksToColumn, blanksToTab, &
    & dump, dumpSize, dumpTabs, getStamp, headLine, &
    & letsDebug, nextColumn, nextTab, numNeedsFormat, numToChars, &
    & output_date_and_time, outputCalendar, outputList, outputTable, &
    & outputAnyNamedValue, outputNamedValue, &
    & resetTabs, restoreSettings, &
    & setStamp, setTabs, startTable, styledOutput, tab, timeStamp
d169 21
a189 11
  public :: outputOptions_T
  public :: stampOptions_T
  public :: timeStampOptions_T

  interface addRow
    module procedure addRow_character
    module procedure addRow_complex
    module procedure addRow_dbl_array, addRow_double
    module procedure addRow_int_array, addRow_integer
    module procedure addRow_log_array, addRow_logical
    module procedure addRow_sngl_array, addRow_single
d192 3
a194 3
  interface ALIGNTOFIT
    module procedure aligntofit_chars, aligntofit_double, aligntofit_single
    module procedure aligntofit_integer
d197 3
a199 3
  interface BANNER
    module procedure banner_chars
    module procedure banner_chararray
d202 2
a203 3
  interface DUMP
    module procedure DumpOutputOptions, DumpPatternOptions, &
      & DumpStampOptions, DumpTimeStampOptions
d206 2
a207 2
  interface DUMPSIZE
    module procedure DUMPSIZE_DOUBLE, DUMPSIZE_INTEGER, DUMPSIZE_REAL
d210 3
a212 2
  interface GETOPTION
    module procedure getOption_char, getOption_log
d215 3
a217 3
  interface NUMNEEDSFORMAT
    module procedure numNeedsFormat_double, numNeedsFormat_integer, numNeedsFormat_single
    module procedure numNeedsFormat_complex, numNeedsFormat_dcomplx
d220 2
a221 2
  interface NUMTOCHARS
    module procedure numtochars_double, numtochars_integer, numtochars_single
d224 2
a225 2
  interface OUTPUTLIST
    module procedure OUTPUTLIST_INTS, OUTPUTLIST_CHARS
d228 7
a234 7
  interface OUTPUTNAMEDVALUE
    module procedure output_nvp_character
    module procedure output_nvp_complex
    module procedure output_nvp_dbl_array, output_nvp_double
    module procedure output_nvp_int_array, output_nvp_integer
    module procedure output_nvp_log_array, output_nvp_logical
    module procedure output_nvp_sngl_array, output_nvp_single
d237 2
a238 2
  interface OUTPUTANYNAMEDVALUE
    module procedure output_nvp_whatever
d241 2
a242 2
  interface TAB
    module procedure blanksToTab
d245 2
a246 2
  interface TIMESTAMP
    module procedure timestamp_char, timestamp_integer, timestamp_logical
d252 1
d266 2
a267 1
  character(len=MAXCELLSIZE), dimension(:,:), pointer :: cellDatabase => null()
d722 2
a723 2
  ! -----------------------------------------------------  BEVERBOSE  -----
  logical function BEVERBOSE ( SWITCH, THRESHOLD )
d728 17
a744 2
    BeVerbose = switchDetail( switches, switch ) > threshold .or. MLSVerbose
  end function BEVERBOSE
d1146 2
a1147 2
  ! -----------------------------------------------------  LETSDEBUG  -----
  logical function LETSDEBUG ( SWITCH, THRESHOLD )
d1152 17
a1168 2
    letsDebug = switchDetail( switches, switch ) > threshold .or. MLSDebug
  end function LETSDEBUG
d2565 1
a2565 1
       "$Id: highOutput.f90,v 2.24 2018/01/03 01:13:51 pwagner Exp $"
d2575 3
@


2.24
log
@Prevent time stamps from interrupting tables, banners
@
text
@d256 1
a256 1
  integer, save, private :: OldNeverStamp
d2521 1
a2521 1
       "$Id: highOutput.f90,v 2.23 2017/12/22 00:25:24 pwagner Exp $"
d2531 3
@


2.23
log
@Add move some items from DumpOuputOptions to new DumpPatternOptions
@
text
@d256 2
a258 1
  integer, save, private :: OLDWRAPPASTCOLNUM = 0
d624 4
d641 2
d685 4
d704 2
d1393 4
d1500 1
a1500 1
    ! Restore tabstops
d1502 1
d2338 4
d2405 2
d2521 1
a2521 1
       "$Id: highOutput.f90,v 2.22 2017/12/14 23:20:48 pwagner Exp $"
d2531 3
@


2.22
log
@Added TrimCharacterValues
@
text
@d31 2
a32 1
    & OutputOptions, OutputOptions_T, StampOptions, StampOptions_T, &
d191 2
a192 1
    module procedure DUMPOUTPUTOPTIONS, DUMPSTAMPOPTIONS, DUMPTIMESTAMPOPTIONS
d783 1
a783 3
    call outputNamedValue ( 'use patterned blanks?', options%usePatternedBlanks, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'special fills', trim(options%specialFillChars), advance='yes', &
d785 1
a785 1
    call outputNamedValue ( 'lineup fills', trim(options%lineupFillChars), advance='yes', &
d835 23
d2497 1
a2497 1
       "$Id: highOutput.f90,v 2.21 2017/11/30 20:48:59 pwagner Exp $"
d2507 3
@


2.21
log
@RestoreSettings may now restore all or just some
@
text
@d235 3
d345 1
d1665 23
a1687 1
    include 'output_name_value_pair.f9h'
d2474 1
a2474 1
       "$Id: highOutput.f90,v 2.20 2017/11/15 00:01:51 pwagner Exp $"
d2484 3
@


2.20
log
@Print options%neverStamp as part of Dump
@
text
@d1789 1
a1789 1
  subroutine RestoreSettings ( usetoolkit )
d1791 12
a1802 4
    logical, optional, intent(in) :: useToolkit
    ! Executable
    call RestoreOutputSettings ( useToolkit )
    StyleOptions = DefaultStyleOptions
d2448 1
a2448 1
       "$Id: highOutput.f90,v 2.19 2017/10/03 21:44:11 pwagner Exp $"
d2458 3
@


2.19
log
@restored bars to Banner; improved comments showing effect of BannerPattern
@
text
@a706 1
    integer :: atColumn
d839 2
d2195 1
d2222 1
d2249 14
d2440 1
a2440 1
       "$Id: highOutput.f90,v 2.18 2017/09/29 00:20:27 pwagner Exp $"
d2450 3
@


2.18
log
@Added Styled output and options; options as an arg to OutputNamedValue
@
text
@d270 55
a324 1
  ! special output formats; e.g., baanner
d335 1
a335 1
    character(len=1) :: BannerPattern            = ' '
d2423 1
a2423 1
       "$Id: highOutput.f90,v 2.17 2017/09/07 23:43:40 pwagner Exp $"
d2433 3
@


2.17
log
@Improved comments; removed unused myMessage_old
@
text
@d25 1
a25 1
  use MLSStrings, only: Lowercase, Ncopies, &
d30 1
a30 1
    & RestoreSettings, &
d34 1
a34 1
    & OutputLines, OutputLinesPrUnit, StdoutPrUnit
d78 1
d115 2
a116 1
!          [integer tabn], [integer tabc], [integer taba], log dont_stamp] )
d125 1
d163 1
a163 1
    & setStamp, setTabs, startTable, tab, timeStamp
d165 1
a165 1
  ! These types made public because the class instances are public
d269 19
d520 1
a520 1
    integer :: lineLen, mySkips,  padding
d525 1
a525 1
    myAlignment = 'C'
d527 1
a527 1
    mySkips = 0
d529 1
a529 1
    myFillChar = '-'
d531 3
a533 1
    if ( present(LineLength) ) then
d536 1
a536 1
      call wrap( chars, wrappedChars, width=LineLength-4, &
d695 1
a695 1
  subroutine DumpOutputOptions(options)
d710 1
a710 1
      call outputNamedValue ( 'meaning', prunitname(options), &
d779 1
a779 1
  subroutine DumpStampOptions(options)
d804 1
a804 1
  subroutine DUMPTIMESTAMPOPTIONS(options)
d957 1
a957 1
    & COLUMNRANGE, ALIGNMENT, SKIPS )
d972 1
d978 1
a978 2
      myFullColumnRange(1) = 1
      myFullColumnRange(2) = 80
d980 1
d982 1
a982 1
    mySkips = 0
d984 1
a984 1
    myFillChar = ' '
d986 1
a986 1
    myAlignment = 'C'
d988 2
d995 5
a999 4
    if ( present(before) ) myColumnRange(1) = myFullColumnRange(1) + len(before)
    if ( present(after) ) then
      myColumnRange(2) = myFullColumnRange(2) - len(after)
      rightpadding = len(after) - 1
d1002 1
a1002 1
    if ( present(before) ) call output( before, advance='no' )
d1008 2
a1009 2
      ! call outputNamedValue ( 'myColumnRange', myColumnRange )
      call blanksToColumn( myColumnRange(1), fillChar=fillChar, advance='no' )
d1012 2
a1013 2
        & fillChar=fillChar, advance='no' )
      if ( present(after) ) call output(after, advance='no' )
d1017 1
a1017 1
      if ( present(after) ) call output( after, advance='no' )
d1567 1
a1567 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1582 1
d1586 1
a1586 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1589 1
a1589 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1592 1
a1592 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1595 1
a1595 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1598 1
a1598 1
        & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1603 1
a1603 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1610 1
a1610 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1617 1
a1617 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1624 1
a1624 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1631 1
a1631 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1638 1
a1638 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1645 1
a1645 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1652 1
a1652 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1659 1
a1659 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1666 1
a1666 1
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
d1731 11
d1813 35
d2369 1
a2369 1
       "$Id: highOutput.f90,v 2.16 2017/01/19 23:33:23 pwagner Exp $"
d2379 3
@


2.16
log
@New procedures to add an internal wall or merge cells across a cell table
@
text
@d12 1
a12 1
module HIGHOUTPUT
d18 3
a20 3
  use Dates_module, only:  buildCalendar, daysInMonth, &
    & ReformatDate, reformatTime, utc_to_yyyymmdd
  use Machine, only: crash_burn, exit_with_status, neverCrash
d22 6
a27 6
  use MLSFinds, only: findFirst
  use MLSStringLists, only: expandStringRange, getStringElement, &
    & List2Array, nCharsInFormat, numStringElements, switchDetail, wrap
  use MLSStrings, only: lowercase, ncopies, &
    & Trim_safe, writeIntsToChars
  use Output_m, only: Advance_is_yes_or_no, Blanks, GetOutputStatus, &
d29 1
a29 1
    & Output, Output_ => output_char_nocr, &
d31 5
a35 5
    & OutputOptions, OutputOptions_t, StampOptions, StampOptions_t, &
    & TimeStampOptions, TimeStampOptions_t, &
    & BothPrUnit, invalidPrUnit, MSGLogPrUnit, &
    & OutputLines, outputLinesPrUnit, stdoutPrUnit
  use PrintIt_m, only: assembleFullLine, get_config, &
d37 1
a37 1
    & MLSMSG_Severity_to_quit, &
d40 1
a40 1
  use Toggles, only: switches
d48 5
a52 5
! addRow                   add name, value row to a 2-d table of cells
! addRow_header            add a single line stretched across an entire row
! addRow_divider           add a row composed of a single, repeated character
! alignToFit               align printed argument to fit column range
! banner                   surround message with stars and stripes; e.g.,
d57 7
a63 7
! blanksToColumn           print blanks [or fill chars] out to specified column
! blanksToTab              print blanks [or fill chars] out to next tab stop
! dump                     dump output or stamp options
! dumpsize                 print a nicely-formatted memory size 
! dumptabs                 print the current tab stop positions
! getStamp                 get stamp being added to every output
! headLine                 print a line with eye-catching features
d66 14
a79 14
! numNeedsFormat           return what format is needed to output num
! numToChars               return what string would be printed by output
! outputCalendar           output nicely-formatted calendar page
! output_date_and_time     print nicely formatted date and time
! outputList               output array as comma-separated list; e.g. '(1,2,..)'
! outputNamedValue         print nicely formatted name and value
! outputTable              output 2-d array as cells in table
! resettabs                restore tab stops to what was in effect at start
! restoreSettings          restore default settings for output, stamps, tabs
! setStamp                 set stamp to be automatically printed on every line
! setTabs                  set tab stops (to be used by tab)
! startTable               initialize a 2-d table of cells to be output later
! tab                      move to next tab stop
! timestamp                print argument with a timestamp manually
d145 8
a231 1
  integer, parameter :: MAXCELLSIZE = 128 ! How many chars can 1 cell hold
d235 10
a246 5
  ! We can use the OutputLines mechanism for user-controlled
  ! buffering, filtering, grep-ing, or whatever
  ! integer, parameter :: MAXOUTPUTLINESLEN = 2048 ! How many chars it can hold
  ! character(len=MAXOUTPUTLINESLEN), public, save     :: OUTPUTLINES = ' '

d250 1
d258 1
d478 1
d481 1
a481 1
  ! supply LineLength for the routine to wrap at word boundaries
d515 1
a515 1
      allocate(lines(addedLines))
d935 2
a936 2
    character(len=1), intent(in), optional :: fillChar      ! For padding
    character(len=*), intent(in), optional :: Before, After ! text to print
d974 1
a974 1
    if ( present(before) ) call output(before, advance='no' )
d988 2
a989 2
      call blanksToColumn(myFullColumnRange(2)-rightpadding, advance='no' )
      if ( present(after) ) call output(after, advance='no' )
d1169 1
a1169 1
    use dates_module, only: NextMoon
d1536 1
a1970 25
  subroutine myMessage_old ( severity, name, line, advance )
    ! Args
    integer, intent(in)           :: severity
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: line
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    ! Local variables
    integer :: nChars
    character(len=len(line) + len(name) + 3) :: thus
    ! Executable
    nChars = len(line)
    thus = line
    if ( len_trim(name) > 0 ) then
      nChars = len(line) + len(name) + 3
      thus = '(' // trim(name) // ') ' // line
    end if
    if ( severity > MLSMSG_Warning ) then
      call PrintItOut( thus(1:nChars), SEVERITY, exitStatus = 1  )
    else
      call PrintItOut( thus(1:nChars), SEVERITY  )
    end if
  end subroutine myMessage_old

d2294 1
a2294 1
       "$Id: highOutput.f90,v 2.15 2017/01/13 01:28:32 pwagner Exp $"
d2304 3
@


2.15
log
@Rename internal procedure to addCellRowToDatabase
@
text
@d27 1
a27 1
  use Output_m, only: Advance_is_yes_or_no, blanks, getOutputStatus, &
d31 2
a32 2
    & OutputOptions, outputOptions_t, stampOptions, stampOptions_t, &
    & TimeStampOptions, timeStampOptions_t, &
d49 2
d85 2
d145 1
a145 1
  public :: addRow, alignToFit, &
d327 17
d2065 7
d2083 1
d2087 1
d2134 25
d2303 1
a2303 1
       "$Id: highOutput.f90,v 2.14 2016/12/14 01:22:40 pwagner Exp $"
d2313 3
@


2.14
log
@outputCalendar prints new, full moons if moonphases present and ttrue
@
text
@d1861 1
a1861 1
  ! .............................................  addItemToDatabase  .....
d1863 1
a1863 1
  integer function addItemToDatabase ( database, item )
d1888 1
a1888 1
    ! include "addItemToDatabase.f9h" 
d1890 2
a1891 2
    addItemToDatabase = newSize
  end function addItemToDatabase
d2248 1
a2248 1
       "$Id: highOutput.f90,v 2.13 2016/11/15 19:27:19 pwagner Exp $"
d2258 3
@


2.13
log
@May print elapsed WallClock_seconds at Finish
@
text
@d19 2
a20 2
    & Reformatdate, reformatTime, utc_to_yyyymmdd
  use Machine, only: crash_burn, exit_with_status, nevercrash
d22 2
a23 2
  use MLSFinds, only: findfirst
  use MLSStringlists, only: expandStringRange, getStringElement, &
d35 1
a35 1
  use Printit_m, only: assembleFullLine, get_config, &
d39 1
a39 1
    & PrintitOut, MLSMessageConfig
d54 1
a54 1
! BeVerbose                Do extra printing?
d61 1
a61 1
! headLine                 print a line with extra formatting features
d63 3
a65 3
! LetsDebug                Do debug printing?
! numNeedsFormat           return what format is need to output num
! numToChars               return what would be printed by output
d70 1
a70 1
! outputTable              output 2-darray as cells in table
d73 1
a73 1
! setStamp                 set stamp to be added to every output automatically
d106 1
a106 1
!          [dontwrap] )
d1132 5
a1136 3
  subroutine OUTPUTCALENDAR ( date, datenote, notes, dontWrap )
    ! output a nicely-formatted calendar of current month with
    ! today's date in "bold"
d1138 1
a1138 1
    character(len=*), intent(in), optional :: date ! date instead of current one
d1148 1
d1153 1
d1169 1
d1173 1
d1177 1
d1179 1
d1196 2
d1209 22
d1262 1
a1262 1
          wrappedNote = notes(aday)
d1264 1
a1264 1
          call wrap( notes(aday), wrappedNote, 10, '/' )
d1309 1
a1309 1
                wrappedNote = notes(days(iwk, wkdy))
d1311 1
a1311 1
                call wrap( notes(days(iwk, wkdy)), wrappedNote, 10, '/' )
d1318 4
d2248 1
a2248 1
       "$Id: highOutput.f90,v 2.12 2016/09/22 22:21:16 pwagner Exp $"
d2258 3
@


2.12
log
@May specify format in call to addRow
@
text
@d104 1
a104 1
!          [double CPU_seconds], [char* advance] )
d1307 2
a1308 1
    & from_where, msg, dateFormat, timeFormat, CPU_Seconds, advance )
d1312 1
d1320 1
d1365 2
a1366 1
      & advance=merge ( 'no ', my_adv, present(CPU_seconds) ), &
d1377 11
d2212 1
a2212 1
       "$Id: highOutput.f90,v 2.11 2016/03/25 00:37:06 pwagner Exp $"
d2222 3
@


2.11
log
@Added OUTPUTANYNAMEDVALUE
@
text
@d263 1
a263 1
  subroutine addRow_character ( name, value )
d269 1
a269 1
  subroutine addRow_complex ( name, value )
d275 1
a275 1
  subroutine addRow_double ( name, value )
d281 1
a281 1
  subroutine addRow_dbl_array ( name, value )
d287 1
a287 1
  subroutine addRow_int_array ( name, value )
d293 1
a293 1
  subroutine addRow_integer ( name, value )
d299 1
a299 1
  subroutine addRow_log_array ( name, value )
d305 1
a305 1
  subroutine addRow_logical ( name, value )
d311 1
a311 1
  subroutine addRow_single ( name, value )
d317 1
a317 1
  subroutine addRow_sngl_array ( name, value )
d1675 2
d2197 1
a2197 1
       "$Id: highOutput.f90,v 2.10 2015/09/24 18:50:41 pwagner Exp $"
d2207 3
@


2.10
log
@May choose different pattern for stripes in banner
@
text
@d146 1
a146 1
    & outputNamedValue, &
d208 4
d1449 36
d2195 1
a2195 1
       "$Id: highOutput.f90,v 2.9 2015/05/18 17:42:50 pwagner Exp $"
d2205 3
@


2.9
log
@addRow and startTable maintains an internal Table for outputTable to output
@
text
@d84 2
a85 1
! banner ( char* chars, [int columnRange(2)], [char alignment], [int skips] )
d443 1
a443 1
    & columnRange, alignment, skips, lineLength, mode )
d451 1
d456 1
d467 2
d479 1
a479 1
      call banner( lines, alignment=alignment )
d501 1
a501 1
    call blanks ( lineLen-2, FillChar='-' )
d510 1
a510 1
    call blanks ( lineLen-2, FillChar='-' )
d514 2
a515 1
  subroutine BANNER_CHARARRAY ( CHARARRAY, COLUMNRANGE, ALIGNMENT, SKIPS )
d521 1
d528 1
d535 2
d556 1
a556 1
    call blanks ( lineLen-2, FillChar='-' )
d567 1
a567 1
    call blanks ( lineLen-2, FillChar='-' )
d656 1
a656 1
    call outputNamedValue ( 'skip MLSMsg logging?', options%SKIPMLSMSGLOGGING, advance='yes', &
d1617 1
a1617 1
  ! Set up a table, iniotially empty. Subsequent calls to AddRow will
d2155 1
a2155 1
       "$Id: highOutput.f90,v 2.8 2015/02/24 23:32:22 pwagner Exp $"
d2165 3
@


2.8
log
@Make sure rightpadding defined in headLine
@
text
@d18 3
a20 3
  use dates_module, only:  buildCalendar, daysInMonth, &
    & reformatdate, reformatTime, utc_to_yyyymmdd
  use machine, only: crash_burn, exit_with_status, nevercrash
d24 1
a24 1
    & List2array, nCharsInFormat, numStringElements, switchDetail, wrap
d26 15
a40 13
    & trim_safe, writeIntsToChars
  use output_m, only: blanks, getOutputStatus, newline, output, &
    & output_ => output_char_nocr, &
    & restoreSettings, &
    & outputOptions, outputoptions_t, stampOptions, stampOptions_t, &
    & timeStampOptions, timeStampOptions_t, &
    & bothPrUnit, invalidPrUnit, msglogPrUnit, outputlinesPrUnit, stdoutPrUnit
  use printit_m, only: assembleFullLine, get_config, &
    & MLSMsg_crash, MLSMsg_debug, &
    & MLSMsg_severity_to_quit, &
    & MLSMsg_warning, &
    & printitOut, MLSMessageConfig
  use toggles, only: switches
d48 1
d75 1
d82 1
d110 1
a110 1
! outputTable ( array(:,:), [char sep], [char border], [int cellWidth],
d117 1
d140 1
a140 1
  public :: alignToFit, &
d147 1
a147 1
    & setStamp, setTabs, tab, timeStamp
d154 9
d216 5
d223 2
a224 2
  integer, parameter :: MAXOUTPUTLINESLEN = 2048 ! How many chars it can hold
  character(len=MAXOUTPUTLINESLEN), public, save     :: OUTPUTLINES = ' '
d251 67
d1506 1
a1506 1
  ! This family of routines outputs a 2d character array as a table
d1508 2
a1509 1
  ! (1)  the table can have a character separating cells, and another 
d1511 1
a1511 1
  ! (2)  the minimum cell width can be set; otherwise
d1513 1
a1513 1
  ! (3)  the alignment within each cell can be set; otherwise
d1515 1
a1515 1
  ! (4)  each row can be separated by an interior wall of characters;
d1518 1
a1518 1
  ! (5)  the first row can be treated as special, and separated from the second
d1523 2
a1524 1
    character(len=*), dimension(:,:), intent(in)   :: array
d1532 1
a1532 15
    character(len=MAXCELLSIZE)                     :: cell
    integer                                        :: i
    integer                                        :: j
    integer                                        :: left
    integer                                        :: minWidth
    character(len=1)                               :: myAlignment
    character(len=1)                               :: myBorder
    character(len=1)                               :: mySep
    character(len=1)                               :: myHeadliner
    character(len=1)                               :: myInterior
    integer                                        :: right
    integer, dimension(size(array,2))              :: widths
    integer, parameter                             :: leftPadding = 1
    integer, parameter                             :: rightPadding = 1
    integer                                        :: totalWidth
d1534 11
a1544 63
    minWidth = 3 ! Don't know why, but this works
    if ( present(cellWidth) ) minWidth = cellWidth

    mySep = ' '
    if ( present(sep) ) mySep = sep
    myBorder = ' '
    if ( present(border) ) myBorder = border
    myInterior = ' '
    if ( present(Interior) ) myInterior = Interior
    
    myHeadliner = myInterior
    if ( present(headliner) ) myHeadliner = headliner
    
    myAlignment = 'L'
    if ( present(alignment) ) myAlignment = alignment

    ! 1st, compute total table width
    widths = minWidth
    totalWidth = 3
    do j=1, size(array,2)
      widths(j) = maxval( len_trim(array(:,j)) )
      widths(j) = max( widths(j), minWidth )
      totalWidth = totalWidth + widths(j) + leftPadding + rightPadding
      if ( j > 1 .and. j < size(array,2) ) totalWidth = totalWidth + 1
    enddo
    if ( len_trim(myBorder) > 0 ) &
      & call output( repeat( myBorder, totalWidth ), advance='yes' )
    do i=1, size(array,1)
      right = 0
      if ( len_trim(myBorder) > 0 ) then
        call output( myBorder, advance='no' )
        right = right + 1
      endif
      do j=1, size(array,2)
        left = right + 1 + leftPadding
        right = left + widths(j) ! Don't know why, but this works
        call alignToFit ( trim(array(i,j)), (/ left, right /), myAlignment )
        call blanks ( rightPadding )
        if ( len_trim(mySep) > 0 .and. j < size(array,2) ) then
          call output( mySep, advance='no' )
          right = right + 1
        endif
      enddo
      if ( len_trim(myBorder) > 0 ) then
        call blanksToColumn( totalWidth )
        call output( myBorder, advance='yes' )
      else
        call newLine
      endif
      ! Interior cell walls or headliners
      if ( len_trim(myheadliner) > 0 .and. i == 1 .and. &
        & myheadliner /= achar(0) ) then
        call output( repeat( myheadliner, totalWidth ), advance='yes' )
      elseif ( myInterior == achar(0) .and. i < size(array,1) ) then
        call output( myBorder, advance='no' )
        call blanksToColumn( totalWidth )
        call output( myBorder, advance='yes' )
      elseif ( len_trim(myInterior) > 0 .and. i < size(array,1) ) then
        call output( repeat( myInterior, totalWidth ), advance='yes' )
      endif
    enddo
    if ( len_trim(myBorder) > 0 ) &
      & call output( repeat( myBorder, totalWidth ), advance='yes' )
d1606 27
d1758 26
a1783 22
  ! .......................................  Advance_is_yes_or_no  .....
  function Advance_is_yes_or_no ( str ) result ( outstr )
    ! takes '[Yy]...' or '[Nn..] and returns 'yes' or 'no' respectively
    ! also does the same with '[Tt]..' and '[Ff]..'
    ! leaves all other patterns unchanged, but truncated to three
    ! characters.  Returns 'no' if the argument is absent.
    
    ! We are allowing its argument str to do multiple duties by being
    ! composed of multiple space-separated arguments, e.g. 
    ! 'arg1 [arg2] .. [argn]'
    ! (1) the first arg1 is treated as before, basically 'yes' or 'no'
    ! (2) arg2 and beyond will introduce extra options to the
    ! output command, eventually simplifying it to just
    !   call output( something, [advance='arg1 [arg2] .. [argn]' )
    !--------Argument--------!
    character (len=*), intent(in), optional :: Str
    character (len=3) :: Outstr

    !----------Local vars----------!
    character (len=*), parameter :: yeses = 'YyTt'
    character (len=*), parameter :: nose = 'NnFf'
    integer :: kSpace
d1785 1
a1785 4
    if ( .not. present(str)  ) then
      outstr = outputoptions%advanceDefault ! 'no'
      return
    end if
d1787 2
a1788 11
    outstr = adjustl(str)
    kSpace = index( outstr, ' ' )
    if ( kSpace > 1 ) outstr = outstr(:kSpace) ! To snip off arg2 ..
    if ( index( yeses, outstr(:1)) > 0  ) then
      outstr = 'yes'
    else if ( index( nose, outstr(:1)) > 0  ) then
      outstr = 'no'
    else
      outstr = str
    end if
  end function Advance_is_yes_or_no
a1829 24
  ! ------------------------------------  SeparateElements  -----
  ! insert blanks or separator between consecutive elements while outputting
  subroutine SeparateElements (i, n )
    ! Args
    integer, intent(in) :: i ! Element number
    integer, intent(in) :: n ! Number of elements
    ! Executable
    if ( i >= n ) return
    if ( wrappastcolnum > 0 .and. getOutputStatus( 'column' ) >= wrappastcolnum ) then
      call newLine
      return
    end if
    if ( wrappastcolnum == 0 .and. &
      & mod(i, outputOptions%nArrayElmntsPerLine) == 0 ) then
      call output_ ( '', advance='yes', DONT_STAMP=.true. )
      return
    end if
    if ( len_trim(outputOptions%arrayElmntSeparator) > 0 ) then
      call output_( outputOptions%arrayElmntSeparator, advance='no' )
    else
      call blanks ( outputOptions%nBlanksBtwnElmnts, advance='no' )
    end if
  end subroutine SeparateElements

d1927 125
a2051 16
  ! ........................................  whatSDNeedsFormat
  ! parse inFormat which might be
  ! (1) absent, in which case format=sdNeedsFormat and dotm='.6'
  ! (2) '(*)', in which case format=sdNeedsFormat and dotm='.6'
  ! (3) '(*.m)', in which case format=(sdNeedsFragment //'.m') and dotm='.m'
  subroutine whatSDNeedsFormat ( format, dotm, inFormat )
    character(len=*), optional, intent(in)  :: inFormat
    character(len=*), intent(out)           :: format
    character(len=*), intent(out)           :: dotm
    integer :: dot
    if ( .not. present(inFormat) ) then
      format = sdNeedsFormat
      dotm = '.6'
    else if ( index(inFormat, '.') < 1 ) then
      format = sdNeedsFormat
      dotm = '.6'
d2053 1
a2053 4
      ! Must find integer after '.'
      dot = index( inFormat, '.' )
      dotm = inFormat(dot:dot+1)
      format = trim(sdNeedsFragment) // trim(dotm) // ')'
d2055 1
a2055 21
  end subroutine whatSDNeedsFormat

  ! ----------------------------------------------  stretch  -----
  function stretch( arg, skips ) result(chars)
  ! stretch input arg by inserting skips number of spaces
  ! between each pair of consecutive characters
  ! Args
    character(len=*), intent(in)      :: arg
    integer, intent(in)               :: skips
    character(len=(1+skips)*len(arg)) :: chars
    ! Internal variables
    integer :: i, k
    ! Executable
    chars = ' '
    if ( len_trim(arg) < 1 ) return
    do i=1, len_trim(arg)
      ! E.g., if skips==1, k ~ 1 3 5 7 ..
      k = 1 + (skips+1)*(i-1)
      chars(k:k) = arg(i:i)
    end do
  end function stretch
d2097 44
d2145 1
a2145 1
       "$Id: highOutput.f90,v 2.7 2015/02/13 00:17:49 pwagner Exp $"
d2155 3
@


2.7
log
@Added procedure to output 2d array as Table
@
text
@d812 1
d1997 1
a1997 1
       "$Id: highOutput.f90,v 2.6 2015/02/10 01:00:58 pwagner Exp $"
d2007 3
@


2.6
log
@Avoid another double-indent error
@
text
@d67 1
d105 2
d134 8
a141 8
  public :: ALIGNTOFIT, &
    & BANNER, BEVERBOSE, BLANKSTOCOLUMN, BLANKSTOTAB, &
    & DUMP, DUMPSIZE, DUMPTABS, GETSTAMP, HEADLINE, &
    & LETSDEBUG, NEXTCOLUMN, NEXTTAB, NUMNEEDSFORMAT, NUMTOCHARS, &
    & OUTPUT_DATE_AND_TIME, OUTPUTCALENDAR, OUTPUTLIST, &
    & OUTPUTNAMEDVALUE, &
    & RESETTABS, RESTORESETTINGS, &
    & SETSTAMP, SETTABS, TAB, TIMESTAMP
d200 1
d1417 106
d1996 1
a1996 1
       "$Id: highOutput.f90,v 2.5 2015/02/06 01:08:20 pwagner Exp $"
d2006 3
@


2.5
log
@Can now print to virtual page indented w.r.t. physical page
@
text
@d18 21
a38 21
  use DATES_MODULE, only:  BUILDCALENDAR, DAYSINMONTH, &
    & REFORMATDATE, REFORMATTIME, UTC_TO_YYYYMMDD
  use MACHINE, only: CRASH_BURN, EXIT_WITH_STATUS, NEVERCRASH
  use MLSCOMMON, only: MLSDEBUG, MLSVERBOSE
  use MLSFINDS, only: FINDFIRST
  use MLSSTRINGLISTS, only: EXPANDSTRINGRANGE, GETSTRINGELEMENT, &
    & LIST2ARRAY, NCHARSINFORMAT, NUMSTRINGELEMENTS, SWITCHDETAIL, WRAP
  use MLSSTRINGS, only: LOWERCASE, NCOPIES, &
    & TRIM_SAFE, WRITEINTSTOCHARS
  use OUTPUT_M, only: BLANKS, GETOUTPUTSTATUS, NEWLINE, OUTPUT, &
    & OUTPUT_ => OUTPUT_CHAR_NOCR, &
    & RESTORESETTINGS, &
    & OUTPUTOPTIONS, OUTPUTOPTIONS_T, STAMPOPTIONS, STAMPOPTIONS_T, &
    & TIMESTAMPOPTIONS, TIMESTAMPOPTIONS_T, &
    & BOTHPRUNIT, INVALIDPRUNIT, MSGLOGPRUNIT, OUTPUTLINESPRUNIT, STDOUTPRUNIT
  use PRINTIT_M, only: ASSEMBLEFULLLINE, GET_CONFIG, &
    & MLSMSG_CRASH, MLSMSG_DEBUG, &
    & MLSMSG_SEVERITY_TO_QUIT, &
    & MLSMSG_WARNING, &
    & PRINTITOUT, MLSMESSAGECONFIG
  use TOGGLES, only: SWITCHES
d509 1
d512 6
d520 1
a520 1
      if ( getOutputStatus( 'column' ) < tabStops(tabn) ) &
d523 1
a523 1
      nTab = findFirst( tabStops > getOutputStatus( 'column' ) )
d1886 1
a1886 1
       "$Id: highOutput.f90,v 2.4 2014/10/06 23:06:26 vsnyder Exp $"
d1896 3
@


2.4
log
@Add Signed argument to Dump_Size
@
text
@d480 1
a480 1
  subroutine BLANKSTOCOLUMN ( COLUMN, FILLCHAR, ADVANCE, DONT_STAMP )
d484 6
a489 3
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: FILLCHAR  ! default is ' '
    logical, intent(in), optional          :: DONT_STAMP ! Prevent double-stamping
d491 8
a498 2
    if ( getOutputStatus( 'column' ) >= COLUMN ) return
    call blanks( COLUMN-getOutputStatus( 'column' ), fillChar, advance, dont_stamp )
d1879 1
a1879 1
       "$Id: highOutput.f90,v 2.3 2014/09/05 00:23:57 vsnyder Exp $"
d1889 3
@


2.3
log
@Better handling of literal output unit.  Convert a local pointer temp to
allocatable.
@
text
@d646 1
a646 1
  subroutine DumpSize_double ( n, advance, units, Before, After )
d651 1
d659 1
d664 4
d671 1
a671 1
      call output ( n, format='(e12.1)' )
d700 1
d708 1
a708 1
  subroutine DumpSize_integer ( n, advance, units, Before, After )
d713 1
d717 1
a717 1
        & before=before, after=after )
d719 2
a720 1
      call dumpSize ( dble(n), advance=advance, before=before, after=after )
d725 1
a725 1
  subroutine DumpSize_real ( n, advance, units, Before, After )
d730 1
d732 1
a732 1
    call dumpsize ( dble(n), advance, units, before, after )
d1870 1
a1870 1
       "$Id: highOutput.f90,v 2.2 2014/04/22 16:30:57 pwagner Exp $"
d1880 4
@


2.2
log
@Banner accepts mode as optional arg
@
text
@d257 2
a258 2
      endif
    endif
d266 1
a266 1
    endif
d297 1
a297 1
    endif
d366 1
a366 1
    character(len=160), dimension(:), pointer :: lines
d386 1
a386 1
    elseif ( present(columnRange) ) then
d393 1
a393 1
    endif
d402 1
a402 1
    endif
d445 1
a445 1
      enddo
d448 1
a448 1
    endif
d463 1
a463 1
    enddo
d510 1
a510 1
    endif
d529 1
a529 1
      call outputNamedValue ( 'meaning', prunitname(options%prUnit), &
d532 1
a532 1
    endif
d554 1
a554 1
    enddo
d560 1
a560 1
      enddo
d562 2
a563 2
    endif
    do
d566 1
a566 1
    enddo
d570 1
a570 1
    function PRUnitName( prUnit ) result( name )
d573 1
a573 1
      integer, intent(in) :: prUnit
d576 18
a593 14
      select case ( prUnit )
      case ( STDOUTPRUNIT )
        name = 'stdout'
      case ( MSGLOGPRUNIT )
        name = 'mls logfile'
      case ( BOTHPRUNIT )
        name = 'stdout+log'
      case ( OUTPUTLINESPRUNIT )
        name = 'outputLines'
      case ( INVALIDPRUNIT )
        name = 'invalid'
      case default ! > 0
        name = 'Fortran unit'
      end select
d687 1
a687 1
    elseif ( amount > 999999 ) then ! I6 format limits this
d689 1
a689 1
    elseif ( amount == int(amount) ) then
d740 1
a740 1
    endif
d787 1
a787 1
    endif
d804 1
a804 1
    endif
d822 1
a822 1
    endif
d964 1
a964 1
    endif
d978 1
a978 1
    endif
d995 1
a995 1
    endif
d1055 1
a1055 1
    endif
d1063 1
a1063 1
    endif
d1066 1
a1066 1
    endif
d1078 1
a1078 1
    enddo
d1090 1
a1090 1
      endif
d1094 1
a1094 1
    endif
d1101 1
a1101 1
        endif
d1105 2
a1106 2
      enddo
    endif
d1121 1
a1121 1
          endif
d1124 1
a1124 1
          elseif ( row == 1 ) then
d1128 1
a1128 1
          elseif( row == numRows ) then
d1132 1
a1132 1
          elseif( present(dateNote) .and. today ) then
d1137 1
a1137 1
            endif
d1142 1
a1142 1
          elseif( present(notes) ) then
d1148 1
a1148 1
              endif
d1153 2
a1154 2
            endif
          endif
d1160 2
a1161 2
          endif
        enddo ! wkdy
d1164 1
a1164 1
      enddo ! row
d1166 1
a1166 1
    enddo ! week
d1269 1
a1269 1
    enddo
d1292 1
a1292 1
    enddo
d1401 1
a1401 1
    endif
d1438 1
a1438 1
    elseif ( present(tabs) ) then
d1443 1
a1443 1
    endif
d1565 1
a1565 1
    endif
d1636 1
a1636 1
    endif
d1662 1
a1662 1
    endif
d1667 1
a1667 1
    endif
d1672 1
a1672 1
    endif
d1693 1
a1693 1
    endif
d1698 1
a1698 1
    endif
d1767 1
a1767 1
      endif
d1785 1
a1785 1
    elseif ( index(inFormat, '.') < 1 ) then
d1793 1
a1793 1
    endif
d1813 1
a1813 1
    enddo
d1860 1
a1860 1
       "$Id: highOutput.f90,v 2.1 2014/01/09 00:22:32 pwagner Exp $"
d1870 3
@


2.1
log
@Split output module procedures between it and new highOutput
@
text
@d131 2
a132 1
  public :: ALIGNTOFIT, BANNER, BEVERBOSE, BLANKSTOCOLUMN, BLANKSTOTAB, &
d221 1
a221 1
       "$RCSfile: HIGHOUTPUT.f90,v $"
d350 2
a351 1
  subroutine BANNER_CHARS ( CHARS, COLUMNRANGE, ALIGNMENT, SKIPS, LINELENGTH )
d358 1
d377 1
a377 1
        & inseparator=achar(0), addedLines=addedLines )
d1856 1
a1856 1
       "$Id: HIGHOUTPUT.f90,v 2.109 2013/11/21 21:21:41 pwagner Exp $"
d1865 4
a1868 1
! $Log: output_m.f90,v $
@

