head	2.12;
access;
symbols
	v5-02-NRT-19:2.12
	v6-00:2.12
	v5-02-NRT-18:2.12
	v5-02:2.12
	v5-01-NRT-17:2.12
	v5-01-NRT-16:2.12
	v5-01-NRT-15:2.12
	v5-01-NRT-14:2.12
	neuralnetworks-1-0:2.12.0.12
	cfm-single-freq-0-1:2.12.0.10
	v5-01:2.12
	v5-00:2.12
	v4-23-TA133:2.12.0.8
	mus-emls-1-70:2.12.0.6
	rel-1-0-englocks-work:2.12.0.4
	VUMLS1-00:2.12
	VPL1-00:2.12
	V4-22-NRT-08:2.12
	VAM1-00:2.12
	V4-21:2.12.0.2
	V4-13:2.12
	V4-12:2.12
	V4-11:2.12
	V4-10:2.12
	V3-43:2.8
	M4-00:2.8
	V3-41:2.8
	V3-40-PlusGM57:2.8.0.2
	V2-24-NRT-04:2.7
	V3-33:2.8
	V2-24:2.7
	V3-31:2.8
	V3-30-NRT-05:2.8
	cfm-01-00:2.8
	V3-30:2.8
	V3-20:2.8
	V3-10:2.8
	V2-23-NRT-02:2.7
	V2-23:2.7
	V2-22-NRT-01:2.7
	V2-22:2.7
	V2-21:2.7
	V2-20:2.7
	V2-11:2.7
	V2-10:2.7
	V2-00:2.7
	V1-51:2.6
	V1-50:2.6
	V1-45:2.6
	V1-44:2.6
	V1-43:2.6
	V1-42:2.6
	V1-41:2.6
	V1-32:2.6
	V1-40:2.6
	V1-31:2.6
	V1-30:2.6
	V1-13:2.6
	V1-12:2.6
	V1-11:2.6
	V1-10:2.6
	newfwm-feb03:2.6.0.2
	V1-04:2.4
	V1-03:2.4
	V1-02:2.4
	V1-00:2.4
	newfwm-sep01:2.4.0.2
	V0-7:2.4
	V0-5-Level2:2.4
	V0-5-SIPS:2.4;
locks; strict;
comment	@# @;


2.12
date	2014.03.20.01.39.47;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2013.09.24.23.27.14;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2013.08.30.03.56.02;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2013.08.17.02.56.58;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2009.06.23.18.25.44;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2005.06.22.17.25.51;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2002.10.08.00.09.14;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2002.06.26.22.02.19;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.02.02.20.50.39;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.02.20.49.22;	author vsnyder;	state dead;
branches;
next	2.2;

2.2
date	2000.11.15.21.24.41;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.11.18.58.37;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.12
log
@Unified types in Intrinsic
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module TABLE_GENERATOR

! Traverse the tree output by the parser, as annotated by tree_checker.
! Output tables in the "mlscf" format.

  use DECLARATION_TABLE, only: DUMP_1_DECL, EMPTY, ENUM_VALUE, LABEL, &
    & LOG_VALUE, RANGE, STR_RANGE, STR_VALUE
  use EXPR_M, only: EXPR
  use INTRINSIC ! everything beginning with PHYQ_
  use LEXER_CORE, only: PRINT_SOURCE
  use MLSCF, only: ALLOCATE_MLSCF, MLSCF_T, MLSCFCELL_T
  use OUTPUT_M, only: OUTPUT
  use STRING_TABLE, only: GET_STRING, STRING_LENGTH
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TOGGLES, only: GEN, TOGGLE
  use TREE, only: DUMP_TREE_NODE, NODE_ID, &
                  NODE_KIND, NSONS, PSEUDO, WHERE_AT=>WHERE, &
                  SUB_ROSA, SUBTREE
  use TREE_TYPES ! Everything, especially everything beginning with N_

  implicit NONE
  private

  public :: GENERATE_TABLE

! -----     Private declarations     -----------------------------------
  integer, private :: ERROR   ! 0 => No errors

  ! Counters for filling the tables
  integer, private :: ISECTION     ! Section number
  integer, private :: IDEF         ! Definition (X=...) in the section
  integer, private :: ISPEC        ! Specification (Y,...) number in the section
  integer, private :: ICELL        ! Cell (field=expr) number in the spec

! Error codes for "announce_error"
  integer, private, parameter :: NO_CODE_FOR = 1
  integer, private, parameter :: TOO_MANY_CELLS = 2
  integer, private, parameter :: TOO_MANY_DEFS = 3
  integer, private, parameter :: TOO_MANY_SPECS = 4

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: table_generator.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains ! ====     Public Procedures     ==============================
! -----------------------------------------------  GENERATE_TABLE  -----
  subroutine GENERATE_TABLE ( ROOT, HOW_MANY_SECTIONS, L2CF_DATA, UPCASE, &
    &                         QUOTE )
  ! Traverse the abstract syntax tree starting at ROOT, which should
  ! be a N_CFS node (but we don't check).
    integer, intent(in) :: ROOT               ! Root of tree output by parser
                                              ! and decorated by check_tree
    integer, intent(in) :: HOW_MANY_SECTIONS  ! How many begin-end blocks
                                              ! were found by check_tree
    type(mlscf_t), intent(inout) :: L2CF_DATA ! Tables
    logical, intent(in), optional :: UPCASE   ! Upper-case strings if present
                                              ! and true.
    logical, intent(in), optional :: QUOTE    ! Quote strings if present
                                              ! and true.

    integer :: I              ! Loop inductor
    integer :: Me = -1        ! String index for trace
    logical :: MYQUOTE
    logical :: MYUPCASE
    integer :: SON            ! Son of root

    error = 0
    isection = 0
    call trace_begin ( me, 'GENERATE_TABLE', root, cond=toggle(gen) )
    myquote = .false.
    if ( present(quote) ) myquote = quote
    myupcase = .false.
    if ( present(upcase) ) myupcase = upcase
    nullify ( l2cf_data%sections )
    call allocate_mlscf ( l2cf_data, how_many_sections )
    do i = 1, nsons(root)
      son = subtree(i,root)
      select case ( node_id(son) )
      case ( n_cf );        call one_cf ( son )
      case ( n_dt_def );    ! nothing needed
      case ( n_section );   ! nothing needed
      case ( n_spec_def );  ! nothing needed
      case default ;        call announce_error ( son, no_code_for )
      end select
    end do
    call trace_end ( 'GENERATE_TABLE', cond=toggle(gen) )

! =====     Internal Procedures     ====================================

  contains

! -----------------------------------------------  ANNOUNCE_ERROR  -----
  subroutine ANNOUNCE_ERROR ( WHERE, CODE, SONS )
    integer, intent(in) :: WHERE   ! Tree node where error was noticed
    integer, intent(in) :: CODE    ! Code for error message
    integer, intent(in), optional :: SONS(:) ! Tree nodes, maybe sons of
                                   ! "where".  If they're pseudo_terminal,
                                   ! their declarations are dumped.
    integer :: I                   ! Index for "sons"

    error = max(error,1)
    call output ( '***** At ' )
    call print_source ( where_at(where) )
    call output ( ' table_generator complained: ' )
    select case ( code )
    case ( no_code_for )
      call output ( ' There is no code to analyze ' )
      call dump_tree_node ( where, 0, advance='yes' )
    case ( too_many_cells )
      call output ( ' Too many cells.', advance = 'yes' )
    case ( too_many_defs )
      call output ( ' Too many defs.', advance = 'yes' )
    case ( too_many_specs )
      call output ( ' Too many specs.', advance = 'yes' )
    case default
      call output ( ' No message in TABLE_GENERATOR for error code ' )
      call output ( code, advance='yes' )
      stop
    end select
    if ( present(sons) ) then
      do i = 1, size(sons)
        if ( node_kind(sons(i)) == pseudo ) &
          call dump_1_decl ( sub_rosa(sons(i)) )
      end do
    end if
  end subroutine ANNOUNCE_ERROR
! ----------------------------------------------------  FILL_CELL  -----
  subroutine FILL_CELL ( ROOT, CELL, IC, MSGNUM )
  ! Fill a cell from "name = expr", "/name" or "expr"
    integer, intent(in) :: ROOT              ! Root of subtree
    type(MlscfCell_T), intent(inout) :: CELL(:)  ! Cell array
    integer, intent(inout) :: IC             ! Index of CELL, updated here
    integer, intent(in) :: MSGNUM            ! Message if IC > MAXIC

    integer :: GSON1, GSON2   ! Sons of Son
    integer :: I              ! Index of son
    integer :: L              ! Length of a string
    integer :: Me = -1        ! String index for trace
    integer :: SON            ! A son of root
    integer :: TYPE           ! Type of son
    integer :: UNITS(2)       ! Units of son
    double precision :: VALUE(2) ! Value of son

    call trace_begin ( me, 'FILL_CELL', root, cond=toggle(gen) )
    ic = ic + 1
    if ( ic > size(cell) ) then
      call announce_error ( root, msgnum )
      call output ( 'Number of them = ' ); call output ( ic, advance='yes' )
      stop
    end if
    cell(ic)%charvalue = ' '
    cell(ic)%units = 0
    cell(ic)%rangeUpperBound = 0.0
    cell(ic)%charRangeUpperBound = ' '
    select case ( node_id(root) )
    case ( n_set_one )        ! field is "/fieldname"
      son = subtree(1,root)
      call get_string ( sub_rosa(son), cell(ic)%keyword, myupcase )
      call get_string ( sub_rosa(son), cell(ic)%charValue, myupcase )
      cell(ic)%type = log_value
      cell(ic)%units = phyq_dimensionless
      cell(ic)%realValue = 1.0
    case ( n_equal, n_asg )   ! field is "name=expr"
      son = subtree(1,root)
      call get_string ( sub_rosa(son), cell(ic)%keyword, myupcase )
      do i = 2, nsons(root)
        if ( i > 2 ) then
          ic = ic + 1
          if ( ic > size(cell) ) then
            call announce_error ( root, msgnum )
            call output ( 'Number of them = ' )
            call output ( ic, advance='yes' )
            stop
          end if
          cell(ic)%keyword = ' '
          cell(ic)%charvalue = ' '
          cell(ic)%units = 0
          cell(ic)%rangeUpperBound = 0.0
          cell(ic)%charRangeUpperBound = ' '
        end if
        cell(ic)%more = nsons(root) - i
        cell(ic)%realValue = 0.0
        son = subtree(i,root)
        select case ( node_id(son) )
        case ( n_colon ) ! A range
          call expr ( son, units, value, type )
          if ( type /= str_range ) then
            cell(ic)%units = units(1)
            cell(ic)%realValue = value(1)
            cell(ic)%rangeUpperBound = value(2)
            cell(ic)%type = range
          else
            gson1 = subtree(1,son); gson2 = subtree(2,son)
            call get_string ( sub_rosa(gson1), cell(ic)%charValue, myupcase )
            call get_string ( sub_rosa(gson2), cell(ic)%charRangeUpperBound, &
                              myupcase )
            cell(ic)%type = str_range
          end if
        case ( n_dot ) ! A reference of the form X.Y
          call get_string ( sub_rosa(subtree(1,son)), cell(ic)%charValue, &
                            myupcase )
          call get_string ( sub_rosa(subtree(2,son)), &
                            cell(ic)%charRangeUpperBound, myupcase )
          cell(ic)%type = label
          cell(ic)%units = phyq_dimensionless
        case ( n_string )
          call get_string ( sub_rosa(son), cell(ic)%charValue, myupcase )
          if ( .not. myquote ) then
            l = string_length(sub_rosa(son))
            cell(ic)%charValue(1:l) = cell(ic)%charValue(2:l-1)
          end if
          cell(ic)%type = str_value
          cell(ic)%units = phyq_dimensionless
        case default
          call fill_cell_expr ( son, cell(ic) )
        end select
      end do
    case default              ! field is "expr"
      cell(ic)%keyword = ' '
      call fill_cell_expr ( root, cell(ic) )
    end select
    call trace_end ( 'FILL_CELL', cond=toggle(gen) )
  end subroutine FILL_CELL
! -----------------------------------------------  FILL_CELL_EXPR  -----
  subroutine FILL_CELL_EXPR ( ROOT, CELL )
  ! Fill a cell's RHS from expr
    integer, intent(in) :: ROOT              ! Root of subtree
    type(MlscfCell_T), intent(inout) :: CELL ! Cell to fill

    integer :: L                             ! Length of a string
    integer :: UNITS(2)                      ! Output of expr
    double precision :: VALUE(2)             ! Output of expr

    call expr ( root, units, value, cell%type )
    if ( cell%type == label ) then
      call get_string ( sub_rosa(root), cell%charValue, myupcase )
    else if ( node_id(root) == n_identifier .and. &
         ( cell%type == empty .or. cell%type == enum_value) ) then
      call get_string ( sub_rosa(root), cell%charValue, myupcase )
      cell%type = enum_value
    else if ( cell%type == str_value ) then
      call get_string ( sub_rosa(root), cell%charValue, myupcase )
      if ( .not. myquote ) then
        l = string_length(sub_rosa(son))
        cell%charValue(1:l) = cell%charValue(2:l-1)
      end if
      cell%type = str_value
    else
      cell%units = units(1)
      cell%realValue = value(1)
    end if
  end subroutine FILL_CELL_EXPR
! -------------------------------------------------------  ONE_CF  -----
  subroutine ONE_CF ( ROOT )
  ! Analyze one configuration, with abstract syntax tree rooted at ROOT.
  ! The root should be an N_CF node (but we don't check).
    integer, intent(in) :: ROOT

    integer :: GSON1, GSON2        ! Grandsons of ROOT being analyzed
    integer :: I, N                ! Loop inductor, number of sons
    integer :: Me = -1             ! String index for trace
    integer :: SON1, SONN          ! Sons of ROOT being analyzed
    integer :: STRING1             ! Sub_Rosa of first sons

    call trace_begin ( me, 'ONE_CF', root, cond=toggle(gen) )
    isection = isection + 1
    idef = 0
    ispec = 0
    n = nsons(root)
    son1 = subtree(1,root)
    string1 = sub_rosa(son1)
    call get_string ( string1, l2cf_data%sections(isection)%MlscfSectionName, &
                      myupcase )
    do i = 2, n-1
      sonn = subtree(i,root)
      select case ( node_id(sonn) )
      case ( n_equal )           ! Spec of the form x = expr
        call fill_cell ( sonn, l2cf_data%sections(isection)%cells, idef, &
          too_many_defs )
      case ( n_named )
        ispec = ispec + 1
        if ( ispec > size(l2cf_data%sections(isection)%entries) ) then
          call announce_error ( sonn, too_many_specs )
          call output ( 'ISPEC = ' ); call output ( ispec, advance='yes' )
          stop
        end if
        gson1 = subtree(1,sonn)  ! Label
        call get_string ( sub_rosa(gson1), &
          l2cf_data%sections(isection)%entries(ispec)%MlscfLabelName, myupcase )
        gson2 = subtree(2,sonn)  ! spec_args tree
        call spec_args ( gson2 )
      case ( n_spec_args )       ! Spec of the form x,(y[=expr])+
        ispec = ispec + 1
        if ( ispec > size(l2cf_data%sections(isection)%entries) ) then
          call announce_error ( sonn, too_many_specs )
          call output ( 'ISPEC = ' ); call output ( ispec, advance='yes' )
          stop
        end if
        l2cf_data%sections(isection)%entries(ispec)%MlscfLabelName = ' '
        call spec_args ( sonn )
      case default
        call announce_error ( sonn, no_code_for )
      end select
    end do
    l2cf_data%sections(isection)%NoSectionDefs = idef
    l2cf_data%sections(isection)%NoSectionEntries = ispec
    call trace_end ( 'ONE_CF', cond=toggle(gen) )
  end subroutine ONE_CF
! ----------------------------------------------------  SPEC_ARGS  -----
  subroutine SPEC_ARGS ( ROOT )
  ! Analyze a specification of the form NAME (, EXPR ( = EXPR)? )+
  ! starting at ROOT
    integer, intent(in) :: ROOT

    integer :: I              ! Loop inductor
    integer :: Me = -1        ! String index for trace
    integer :: SON            ! I'th son of "root"

    call trace_begin ( me, 'SPEC_ARGS', root, cond=toggle(gen) )
    son = subtree(1,root)
    call get_string ( sub_rosa(son), &
      l2cf_data%sections(isection)%entries(ispec)%MlscfEntryName, myupcase )
    icell = 0
    do i = 2, nsons(root)
      son = subtree(i,root)
      call fill_cell ( son, &
        l2cf_data%sections(isection)%entries(ispec)%cells, icell, &
        too_many_cells )
    end do
    l2cf_data%sections(isection)%entries(ispec)%MlscfEntryNoKeys = icell
    call trace_end ( 'SPEC_ARGS', cond=toggle(gen) )
  end subroutine SPEC_ARGS

  end subroutine GENERATE_TABLE
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: table_generator.f90,v 2.11 2013/09/24 23:27:14 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module TABLE_GENERATOR

! $Log: table_generator.f90,v $
! Revision 2.11  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.10  2013/08/30 03:56:02  vsnyder
! Revise use of trace_begin and trace_end
!
! Revision 2.9  2013/08/17 02:56:58  vsnyder
! Remove references to DEPTH from trace_m
!
! Revision 2.8  2009/06/23 18:25:44  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.7  2005/06/22 17:25:51  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.6  2002/10/08 00:09:14  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.5  2002/06/26 22:02:19  vsnyder
! Change 'cell' to intent(inout) in 'fillCell'
!
! Revision 2.4  2001/02/02 20:50:39  vsnyder
! Moved from lib/tests/test_cf_parser to lib
!
! Revision 2.2  2000/11/15 21:24:41  vsnyder
! Added the module name to error messages
!
! Revision 2.1  2000/10/11 18:58:37  vsnyder
! Move from lib/cf_parser to lib
!
! Revision 2.1  2000/09/11 19:33:53  vsnyder
! Added an optional argument (default .false.) to request quoting strings.
!
! Revision 2.0  2000/09/05 17:41:51  dcuddy
! Change revision to 2.0
!
! Revision 1.2  2000/09/01 21:42:15  vsnyder
! Add "more" field to MLSCF_CELL type
!
@


2.11
log
@Use Get_Where or Print_Source to start error messages
@
text
@d18 1
a18 1
    & LOG_VALUE, RANGE, STR_RANGE, STR_VALUE, UNDECLARED
d251 1
a251 2
         ( cell%type == undeclared .or. cell%type == empty .or. &
           cell%type == enum_value) ) then
d351 1
a351 1
       "$Id: table_generator.f90,v 2.10 2013/08/30 03:56:02 vsnyder Exp $"
d361 3
@


2.10
log
@Revise use of trace_begin and trace_end
@
text
@d28 1
a28 1
                  NODE_KIND, NSONS, PSEUDO, SOURCE_REF, &
d116 1
a116 1
    call print_source ( source_ref(where) )
d352 1
a352 1
       "$Id: table_generator.f90,v 2.9 2013/08/17 02:56:58 vsnyder Exp $"
d362 3
@


2.9
log
@Remove references to DEPTH from trace_m
@
text
@d31 1
d75 1
d82 1
a82 1
    if ( toggle(gen) ) call trace_begin ( 'GENERATE_TABLE', root )
d99 2
a100 1
    if ( toggle(gen) ) call trace_end ( 'GENERATE_TABLE' )
d102 1
d104 1
d151 1
d157 1
a157 1
    if ( toggle(gen) ) call trace_begin ( 'FILL_CELL', root )
d235 1
a235 1
    if ( toggle(gen) ) call trace_end ( 'FILL_CELL' )
d275 1
d279 1
a279 1
    if ( toggle(gen) ) call trace_begin ( 'ONE_CF', root )
d321 1
a321 1
    if ( toggle(gen) ) call trace_end ( 'ONE_CF' )
d330 1
d333 1
a333 1
    if ( toggle(gen) ) call trace_begin ( 'SPEC_ARGS', root )
d345 1
a345 1
    if ( toggle(gen) ) call trace_end ( 'SPEC_ARGS' )
d352 1
a352 1
       "$Id: table_generator.f90,v 2.8 2009/06/23 18:25:44 pwagner Exp $"
d362 3
@


2.8
log
@Prevent Intel from optimizing ident string away
@
text
@d25 1
a25 1
  use TRACE_M, only: DEPTH, TRACE_BEGIN, TRACE_END
d53 1
a53 1
       "$RCSfile: $"
a77 1
    depth = 0
d344 1
a344 1
       "$Id: read_apriori.f90 is it here $"
d354 3
@


2.7
log
@Reworded Copyright statement, moved rcs id
@
text
@d342 1
a343 1
!---------------------------- RCS Ident Info -------------------------------
d345 2
a346 3
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d348 1
d350 1
d355 3
@


2.6
log
@Added idents to survive zealous Lahey optimizer
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d51 1
a51 3
!---------------------------- RCS Ident Info -------------------------------
  character (len=256), private :: Id = &
       "$Id: table_generator.f90,v 2.5 2002/06/26 22:02:19 vsnyder Exp $"
d53 1
a53 1
       "$RCSfile: table_generator.f90,v $"
d343 5
d354 3
@


2.5
log
@Change 'cell' to intent(inout) in 'fillCell'
@
text
@d45 1
a45 1
       "$Id: table_generator.f90,v 2.4 2001/02/02 20:50:39 vsnyder Exp $"
d48 1
d336 4
d343 3
@


2.4
log
@Moved from lib/tests/test_cf_parser to lib
@
text
@d45 1
a45 1
       "$Id: table_generator.f90,v 2.2 2000/11/15 21:24:41 vsnyder Exp $"
d133 1
a133 1
    type(MlscfCell_T), intent(out) :: CELL(:)  ! Cell array
d338 3
@


2.3
log
@Moved from lib/tests/test_cf_parser to lib
@
text
@d106 1
a106 1
    call output ( ' in module table_generator: ' )
d109 1
a109 1
      call output ( ' there is no code to analyze ' )
d112 1
a112 1
      call output ( '.  Too many cells.', advance = 'yes' )
d114 1
a114 1
      call output ( '.  Too many defs.', advance = 'yes' )
d116 1
a116 1
      call output ( '.  Too many specs.', advance = 'yes' )
d118 1
a118 1
      call output ( 'No message in TABLE_GENERATOR for error code ' )
@


2.2
log
@Added the module name to error messages
@
text
@d45 1
a45 1
       "$Id: table_generator.f90,v 2.1 2000/10/11 18:58:37 vsnyder Exp $"
d338 3
@


2.1
log
@Move from lib/cf_parser to lib
@
text
@d45 1
a45 1
       "$Id: table_generator.f90,v 2.1 2000/09/11 19:33:53 vsnyder Exp $"
d106 1
a106 1
    call output ( ': ' )
d338 3
@

