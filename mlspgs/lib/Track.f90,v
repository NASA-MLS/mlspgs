head	2.11;
access;
symbols
	v5-02-NRT-19:2.11
	v6-00:2.11
	v5-02-NRT-18:2.11
	v5-02:2.11
	v5-01-NRT-17:2.11
	v5-01-NRT-16:2.11
	v5-01-NRT-15:2.11
	v5-01-NRT-14:2.11
	neuralnetworks-1-0:2.11.0.8
	cfm-single-freq-0-1:2.11.0.6
	v5-01:2.11
	v5-00:2.11
	v4-23-TA133:2.11.0.4
	mus-emls-1-70:2.11.0.2
	rel-1-0-englocks-work:2.10.0.2
	VUMLS1-00:2.9
	VPL1-00:2.8
	V4-22-NRT-08:2.8
	VAM1-00:2.8
	V4-21:2.7.0.2
	V4-13:2.7
	V4-12:2.7
	V4-11:2.7
	V4-10:2.7
	V3-43:2.6
	M4-00:2.6
	V3-41:2.6
	V3-40-PlusGM57:2.6.0.2
	V2-24-NRT-04:2.4
	V3-33:2.6
	V2-24:2.4
	V3-31:2.6
	V3-30-NRT-05:2.6
	cfm-01-00:2.6
	V3-30:2.6
	V3-20:2.6
	V3-10:2.6
	V2-23-NRT-02:2.4
	V2-23:2.4
	V2-22-NRT-01:2.4
	V2-22:2.4
	V2-21:2.3
	V2-20:2.3
	V2-11:2.2
	V2-10:2.2;
locks; strict;
comment	@# @;


2.11
date	2018.05.15.03.17.36;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2017.10.31.23.42.57;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2016.09.07.23.54.37;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2015.06.02.23.59.42;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2008.05.20.01.59.29;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2007.04.14.00.35.34;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2006.08.04.18.14.15;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2006.07.29.03.42.34;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2006.07.29.03.00.54;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.11
log
@Add 1D and 2D character allocatable versions
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Track_m

  implicit None

  private

  public :: TrackAllocate, TrackDeallocate, ReportLeaks

  interface TrackAllocate
    module procedure TrackAllocate_C1
    module procedure TrackAllocate_C2
    module procedure TrackAllocate_C3
    module procedure TrackAllocate_X1
    module procedure TrackAllocate_X2
    module procedure TrackAllocate_X3
    module procedure TrackAllocate_Z1
    module procedure TrackAllocate_Z2
    module procedure TrackAllocate_Z3
    module procedure TrackAllocate_I1
    module procedure TrackAllocate_I2
    module procedure TrackAllocate_I3
    module procedure TrackAllocate_I4
    module procedure TrackAllocate_R1
    module procedure TrackAllocate_R2
    module procedure TrackAllocate_R3
    module procedure TrackAllocate_R4
    module procedure TrackAllocate_D1
    module procedure TrackAllocate_D2
    module procedure TrackAllocate_D3
    module procedure TrackAllocate_D4
    module procedure TrackAllocate_L1
    module procedure TrackAllocate_L2
    module procedure TrackAllocate_L3
  ! For allocatable argument instead of pointer
    module procedure TrackAllocateA_C1
    module procedure TrackAllocateA_C2
    module procedure TrackAllocateA_I1
    module procedure TrackAllocateA_I2
    module procedure TrackAllocateA_I3
    module procedure TrackAllocateA_I4
    module procedure TrackAllocateA_L1
    module procedure TrackAllocateA_L2
    module procedure TrackAllocateA_L3
    module procedure TrackAllocateA_R1
    module procedure TrackAllocateA_R2
    module procedure TrackAllocateA_R3
    module procedure TrackAllocateA_R4
    module procedure TrackAllocateA_D1
    module procedure TrackAllocateA_D2
    module procedure TrackAllocateA_D3
    module procedure TrackAllocateA_D4
  end interface

  interface TrackDeallocate
    module procedure TrackDeallocate_C1
    module procedure TrackDeallocate_C2
    module procedure TrackDeallocate_C3
    module procedure TrackDeallocate_X1
    module procedure TrackDeallocate_X2
    module procedure TrackDeallocate_X3
    module procedure TrackDeallocate_Z1
    module procedure TrackDeallocate_Z2
    module procedure TrackDeallocate_Z3
    module procedure TrackDeallocate_I1
    module procedure TrackDeallocate_I2
    module procedure TrackDeallocate_I3
    module procedure TrackDeallocate_I4
    module procedure TrackDeallocate_R1
    module procedure TrackDeallocate_R2
    module procedure TrackDeallocate_R3
    module procedure TrackDeallocate_R4
    module procedure TrackDeallocate_D1
    module procedure TrackDeallocate_D2
    module procedure TrackDeallocate_D3
    module procedure TrackDeallocate_D4
    module procedure TrackDeallocate_L1
    module procedure TrackDeallocate_L2
    module procedure TrackDeallocate_L3
  ! For allocatable argument instead of pointer
    module procedure TrackDeallocateA_C1
    module procedure TrackDeallocateA_C2
    module procedure TrackDeallocateA_I1
    module procedure TrackDeallocateA_I2
    module procedure TrackDeallocateA_I3
    module procedure TrackDeallocateA_I4
    module procedure TrackDeallocateA_L1
    module procedure TrackDeallocateA_L2
    module procedure TrackDeallocateA_L3
    module procedure TrackDeallocateA_R1
    module procedure TrackDeallocateA_R2
    module procedure TrackDeallocateA_R3
    module procedure TrackDeallocateA_R4
    module procedure TrackDeallocateA_D1
    module procedure TrackDeallocateA_D2
    module procedure TrackDeallocateA_D3
    module procedure TrackDeallocateA_D4
  end interface

  integer, parameter :: WhereLen = 48

  type :: Track_C1_t
    character, pointer :: P(:) => NULL()
    character(len=whereLen) :: Where
  end type Track_C1_t
  type :: Track_C2_t
    character, pointer :: P(:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_C2_t
  type :: Track_C3_t
    character, pointer :: P(:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_C3_t
  type :: Track_X1_t
    complex, pointer :: P(:) => NULL()
    character(len=whereLen) :: Where
  end type Track_X1_t
  type :: Track_X2_t
    complex, pointer :: P(:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_X2_t
  type :: Track_X3_t
    complex, pointer :: P(:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_X3_t
  type :: Track_Z1_t
    complex(kind(0.0d0)), pointer :: P(:) => NULL()
    character(len=whereLen) :: Where
  end type Track_Z1_t
  type :: Track_Z2_t
    complex(kind(0.0d0)), pointer :: P(:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_Z2_t
  type :: Track_Z3_t
    complex(kind(0.0d0)), pointer :: P(:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_Z3_t
  type :: Track_I1_t
    integer, pointer :: P(:) => NULL()
    character(len=whereLen) :: Where
  end type Track_I1_t
  type :: Track_I2_t
    integer, pointer :: P(:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_I2_t
  type :: Track_I3_t
    integer, pointer :: P(:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_I3_t
  type :: Track_L1_t
    logical, pointer :: P(:) => NULL()
    character(len=whereLen) :: Where
  end type Track_L1_t
  type :: Track_L2_t
    logical, pointer :: P(:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_L2_t
  type :: Track_L3_t
    logical, pointer :: P(:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_L3_t
  type :: Track_I4_t
    integer, pointer :: P(:,:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_I4_t
  type :: Track_R1_t
    real, pointer :: P(:) => NULL()
    character(len=whereLen) :: Where
  end type Track_R1_t
  type :: Track_R2_t
    real, pointer :: P(:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_R2_t
  type :: Track_R3_t
    real, pointer :: P(:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_R3_t
  type :: Track_R4_t
    real, pointer :: P(:,:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_R4_t
  type :: Track_D1_t
    double precision, pointer :: P(:) => NULL()
    character(len=whereLen) :: Where
  end type Track_D1_t
  type :: Track_D2_t
    double precision, pointer :: P(:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_D2_t
  type :: Track_D3_t
    double precision, pointer :: P(:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_D3_t
  type :: Track_D4_t
    double precision, pointer :: P(:,:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_D4_t

  type(Track_C1_t), pointer, save :: Track_C1(:) => NULL()
  type(Track_C2_t), pointer, save :: Track_C2(:) => NULL()
  type(Track_C3_t), pointer, save :: Track_C3(:) => NULL()
  type(Track_X1_t), pointer, save :: Track_X1(:) => NULL()
  type(Track_X2_t), pointer, save :: Track_X2(:) => NULL()
  type(Track_X3_t), pointer, save :: Track_X3(:) => NULL()
  type(Track_Z1_t), pointer, save :: Track_Z1(:) => NULL()
  type(Track_Z2_t), pointer, save :: Track_Z2(:) => NULL()
  type(Track_Z3_t), pointer, save :: Track_Z3(:) => NULL()
  type(Track_I1_t), pointer, save :: Track_I1(:) => NULL()
  type(Track_I2_t), pointer, save :: Track_I2(:) => NULL()
  type(Track_I3_t), pointer, save :: Track_I3(:) => NULL()
  type(Track_I4_t), pointer, save :: Track_I4(:) => NULL()
  type(Track_R1_t), pointer, save :: Track_R1(:) => NULL()
  type(Track_R2_t), pointer, save :: Track_R2(:) => NULL()
  type(Track_R3_t), pointer, save :: Track_R3(:) => NULL()
  type(Track_R4_t), pointer, save :: Track_R4(:) => NULL()
  type(Track_D1_t), pointer, save :: Track_D1(:) => NULL()
  type(Track_D2_t), pointer, save :: Track_D2(:) => NULL()
  type(Track_D3_t), pointer, save :: Track_D3(:) => NULL()
  type(Track_D4_t), pointer, save :: Track_D4(:) => NULL()
  type(Track_L1_t), pointer, save :: Track_L1(:) => NULL()
  type(Track_L2_t), pointer, save :: Track_L2(:) => NULL()
  type(Track_L3_t), pointer, save :: Track_L3(:) => NULL()

  integer, save :: Num_C1 = 0
  integer, save :: Num_C2 = 0
  integer, save :: Num_C3 = 0
  integer, save :: Num_X1 = 0
  integer, save :: Num_X2 = 0
  integer, save :: Num_X3 = 0
  integer, save :: Num_Z1 = 0
  integer, save :: Num_Z2 = 0
  integer, save :: Num_Z3 = 0
  integer, save :: Num_I1 = 0
  integer, save :: Num_I2 = 0
  integer, save :: Num_I3 = 0
  integer, save :: Num_I4 = 0
  integer, save :: Num_R1 = 0
  integer, save :: Num_R2 = 0
  integer, save :: Num_R3 = 0
  integer, save :: Num_R4 = 0
  integer, save :: Num_D1 = 0
  integer, save :: Num_D2 = 0
  integer, save :: Num_D3 = 0
  integer, save :: Num_D4 = 0
  integer, save :: Num_L1 = 0
  integer, save :: Num_L2 = 0
  integer, save :: Num_L3 = 0

  integer, parameter :: InitSize = 100

  integer, parameter :: CharsPerInt = 4 ! Characters per integer

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Track.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  subroutine TrackAllocate_C1 ( What, Where, Module )
    character(len=*), pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_c1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_c1
      if ( .not. associated(track_c1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_c1) ) then
      allocate(track_c1(initSize))
    else if ( i > size(track_c1) ) then
      temp => track_c1
      allocate ( track_c1(2*size(temp)) )
      track_c1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_c1(i)%p => what(:)(1:1)
    track_c1(i)%where = trim(where) // "@@" // trimModule(module)
    num_c1 = max(num_c1,i)
  end subroutine TrackAllocate_C1
  subroutine TrackAllocate_C2 ( What, Where, Module )
    character(len=*), pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_c2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_c2
      if ( .not. associated(track_c2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_c2) ) then
      allocate(track_c2(initSize))
    else if ( i > size(track_c2) ) then
      temp => track_c2
      allocate ( track_c2(2*size(temp)) )
      track_c2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_c2(i)%p => what(:,:)(1:1)
    track_c2(i)%where = trim(where) // "@@" // trimModule(module)
    num_c2 = max(num_c2,i)
  end subroutine TrackAllocate_C2
  subroutine TrackAllocate_C3 ( What, Where, Module )
    character(len=*), pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_c3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_c3
      if ( .not. associated(track_c3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_c3) ) then
      allocate(track_c3(initSize))
    else if ( i > size(track_c3) ) then
      temp => track_c3
      allocate ( track_c3(2*size(temp)) )
      track_c3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_c3(i)%p => what(:,:,:)(1:1)
    track_c3(i)%where = trim(where) // "@@" // trimModule(module)
    num_c3 = max(num_c3,i)
  end subroutine TrackAllocate_C3

  subroutine TrackAllocate_X1 ( What, Where, Module )
    complex, pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_x1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_x1
      if ( .not. associated(track_x1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_x1) ) then
      allocate(track_x1(initSize))
    else if ( i > size(track_x1) ) then
      temp => track_x1
      allocate ( track_x1(2*size(temp)) )
      track_x1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_x1(i)%p => what(:)
    track_x1(i)%where = trim(where) // "@@" // trimModule(module)
    num_x1 = max(num_x1,i)
  end subroutine TrackAllocate_X1
  subroutine TrackAllocate_X2 ( What, Where, Module )
    complex, pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_x2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_x2
      if ( .not. associated(track_x2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_x2) ) then
      allocate(track_x2(initSize))
    else if ( i > size(track_x2) ) then
      temp => track_x2
      allocate ( track_x2(2*size(temp)) )
      track_x2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_x2(i)%p => what(:,:)
    track_x2(i)%where = trim(where) // "@@" // trimModule(module)
    num_x2 = max(num_x2,i)
  end subroutine TrackAllocate_X2
  subroutine TrackAllocate_X3 ( What, Where, Module )
    complex, pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_x3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_x3
      if ( .not. associated(track_x3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_x3) ) then
      allocate(track_x3(initSize))
    else if ( i > size(track_x3) ) then
      temp => track_x3
      allocate ( track_x3(2*size(temp)) )
      track_x3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_x3(i)%p => what(:,:,:)
    track_x3(i)%where = trim(where) // "@@" // trimModule(module)
    num_x3 = max(num_x3,i)
  end subroutine TrackAllocate_X3

  subroutine TrackAllocate_Z1 ( What, Where, Module )
    complex(kind(0.0d0)), pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_z1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_z1
      if ( .not. associated(track_z1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_z1) ) then
      allocate(track_z1(initSize))
    else if ( i > size(track_z1) ) then
      temp => track_z1
      allocate ( track_z1(2*size(temp)) )
      track_z1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_z1(i)%p => what(:)
    track_z1(i)%where = trim(where) // "@@" // trimModule(module)
    num_z1 = max(num_z1,i)
  end subroutine TrackAllocate_Z1
  subroutine TrackAllocate_Z2 ( What, Where, Module )
    complex(kind(0.0d0)), pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_z2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_z2
      if ( .not. associated(track_z2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_z2) ) then
      allocate(track_z2(initSize))
    else if ( i > size(track_z2) ) then
      temp => track_z2
      allocate ( track_z2(2*size(temp)) )
      track_z2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_z2(i)%p => what(:,:)
    track_z2(i)%where = trim(where) // "@@" // trimModule(module)
    num_z2 = max(num_z2,i)
  end subroutine TrackAllocate_Z2
  subroutine TrackAllocate_Z3 ( What, Where, Module )
    complex(kind(0.0d0)), pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_z3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_z3
      if ( .not. associated(track_z3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_z3) ) then
      allocate(track_z3(initSize))
    else if ( i > size(track_z3) ) then
      temp => track_z3
      allocate ( track_z3(2*size(temp)) )
      track_z3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_z3(i)%p => what(:,:,:)
    track_z3(i)%where = trim(where) // "@@" // trimModule(module)
    num_z3 = max(num_z3,i)
  end subroutine TrackAllocate_Z3

  subroutine TrackAllocate_I1 ( What, Where, Module )
    integer, pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_i1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_i1
      if ( .not. associated(track_i1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_i1) ) then
      allocate(track_i1(initSize))
    else if ( i > size(track_i1) ) then
      temp => track_i1
      allocate ( track_i1(2*size(temp)) )
      track_i1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_i1(i)%p => what
    track_i1(i)%where = trim(where) // "@@" // trimModule(module)
    num_i1 = max(num_i1,i)
  end subroutine TrackAllocate_I1
  subroutine TrackAllocate_I2 ( What, Where, Module )
    integer, pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_i2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_i2
      if ( .not. associated(track_i2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_i2) ) then
      allocate(track_i2(initSize))
    else if ( i > size(track_i2) ) then
      temp => track_i2
      allocate ( track_i2(2*size(temp)) )
      track_i2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_i2(i)%p => what
    track_i2(i)%where = trim(where) // "@@" // trimModule(module)
    num_i2 = max(num_i2,i)
  end subroutine TrackAllocate_I2
  subroutine TrackAllocate_I3 ( What, Where, Module )
    integer, pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_i3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_i3
      if ( .not. associated(track_i3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_i3) ) then
      allocate(track_i3(initSize))
    else if ( i > size(track_i3) ) then
      temp => track_i3
      allocate ( track_i3(2*size(temp)) )
      track_i3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_i3(i)%p => what
    track_i3(i)%where = trim(where) // "@@" // trimModule(module)
    num_i3 = max(num_i3,i)
  end subroutine TrackAllocate_I3
  subroutine TrackAllocate_I4 ( What, Where, Module )
    integer, pointer :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_i4_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_i4
      if ( .not. associated(track_i4(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_i4) ) then
      allocate(track_i4(initSize))
    else if ( i > size(track_i4) ) then
      temp => track_i4
      allocate ( track_i4(2*size(temp)) )
      track_i4(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_i4(i)%p => what
    track_i4(i)%where = trim(where) // "@@" // trimModule(module)
    num_i4 = max(num_i4,i)
  end subroutine TrackAllocate_I4

  subroutine TrackAllocate_R1 ( What, Where, Module )
    real, pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_r1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r1
      if ( .not. associated(track_r1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_r1) ) then
      allocate(track_r1(initSize))
    else if ( i > size(track_r1) ) then
      temp => track_r1
      allocate ( track_r1(2*size(temp)) )
      track_r1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_r1(i)%p => what
    track_r1(i)%where = trim(where) // "@@" // trimModule(module)
    num_r1 = max(num_r1,i)
  end subroutine TrackAllocate_R1
  subroutine TrackAllocate_R2 ( What, Where, Module )
    real, pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_r2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r2
      if ( .not. associated(track_r2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_r2) ) then
      allocate(track_r2(initSize))
    else if ( i > size(track_r2) ) then
      temp => track_r2
      allocate ( track_r2(2*size(temp)) )
      track_r2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_r2(i)%p => what
    track_r2(i)%where = trim(where) // "@@" // trimModule(module)
    num_r2 = max(num_r2,i)
  end subroutine TrackAllocate_R2
  subroutine TrackAllocate_R3 ( What, Where, Module )
    real, pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_r3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r3
      if ( .not. associated(track_r3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_r3) ) then
      allocate(track_r3(initSize))
    else if ( i > size(track_r3) ) then
      temp => track_r3
      allocate ( track_r3(2*size(temp)) )
      track_r3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_r3(i)%p => what
    track_r3(i)%where = trim(where) // "@@" // trimModule(module)
    num_r3 = max(num_r3,i)
  end subroutine TrackAllocate_R3
  subroutine TrackAllocate_R4 ( What, Where, Module )
    real, pointer :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_r4_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r4
      if ( .not. associated(track_r4(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_r4) ) then
      allocate(track_r4(initSize))
    else if ( i > size(track_r4) ) then
      temp => track_r4
      allocate ( track_r4(2*size(temp)) )
      track_r4(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_r4(i)%p => what
    track_r4(i)%where = trim(where) // "@@" // trimModule(module)
    num_r4 = max(num_r4,i)
  end subroutine TrackAllocate_R4

  subroutine TrackAllocateA_C1 ( What, Where, Module )
    character(len=*), allocatable :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_c1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_c1
      if ( .not. associated(track_c1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_c1) ) then
      allocate(track_c1(initSize))
    else if ( i > size(track_c1) ) then
      temp => track_c1
      allocate ( track_c1(2*size(temp)) )
      track_c1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_c1(i)%p )
    track_c1(i)%where = trim(where) // "@@" // trimModule(module)
    num_c1 = max(num_c1,i)
  end subroutine TrackAllocateA_C1
  subroutine TrackAllocateA_C2 ( What, Where, Module )
    character(len=*), allocatable :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_c2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_c2
      if ( .not. associated(track_c2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_c2) ) then
      allocate(track_c2(initSize))
    else if ( i > size(track_c2) ) then
      temp => track_c2
      allocate ( track_c2(2*size(temp)) )
      track_c2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_c2(i)%p )
    track_c2(i)%where = trim(where) // "@@" // trimModule(module)
    num_c2 = max(num_c2,i)
  end subroutine TrackAllocateA_C2
  subroutine TrackAllocateA_I1 ( What, Where, Module )
    integer, allocatable :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_i1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r1
      if ( .not. associated(track_i1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_i1) ) then
      allocate(track_i1(initSize))
    else if ( i > size(track_i1) ) then
      temp => track_i1
      allocate ( track_i1(2*size(temp)) )
      track_i1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_i1(i)%p )
    track_i1(i)%where = trim(where) // "@@" // trimModule(module)
    num_r1 = max(num_r1,i)
  end subroutine TrackAllocateA_I1
  subroutine TrackAllocateA_I2 ( What, Where, Module )
    integer, allocatable :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_i2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r2
      if ( .not. associated(track_i2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_i2) ) then
      allocate(track_i2(initSize))
    else if ( i > size(track_i2) ) then
      temp => track_i2
      allocate ( track_i2(2*size(temp)) )
      track_i2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_i2(i)%p )
    track_i2(i)%where = trim(where) // "@@" // trimModule(module)
    num_r2 = max(num_r2,i)
  end subroutine TrackAllocateA_I2
  subroutine TrackAllocateA_I3 ( What, Where, Module )
    integer, allocatable :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_i3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r3
      if ( .not. associated(track_i3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_i3) ) then
      allocate(track_i3(initSize))
    else if ( i > size(track_i3) ) then
      temp => track_i3
      allocate ( track_i3(2*size(temp)) )
      track_i3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_i3(i)%p )
    track_i3(i)%where = trim(where) // "@@" // trimModule(module)
    num_r3 = max(num_r3,i)
  end subroutine TrackAllocateA_I3
  subroutine TrackAllocateA_I4 ( What, Where, Module )
    integer, allocatable :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_i4_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r4
      if ( .not. associated(track_i4(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_i4) ) then
      allocate(track_i4(initSize))
    else if ( i > size(track_i4) ) then
      temp => track_i4
      allocate ( track_i4(2*size(temp)) )
      track_i4(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_i4(i)%p )
    track_i4(i)%where = trim(where) // "@@" // trimModule(module)
    num_r4 = max(num_r4,i)
  end subroutine TrackAllocateA_I4

  subroutine TrackAllocateA_L1 ( What, Where, Module )
    logical, allocatable :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_L1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r1
      if ( .not. associated(track_L1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_L1) ) then
      allocate(track_L1(initSize))
    else if ( i > size(track_L1) ) then
      temp => track_L1
      allocate ( track_L1(2*size(temp)) )
      track_L1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_L1(i)%p )
    track_L1(i)%where = trim(where) // "@@" // trimModule(module)
    num_r1 = max(num_r1,i)
  end subroutine TrackAllocateA_L1
  subroutine TrackAllocateA_L2 ( What, Where, Module )
    logical, allocatable :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_L2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r2
      if ( .not. associated(track_L2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_L2) ) then
      allocate(track_L2(initSize))
    else if ( i > size(track_L2) ) then
      temp => track_L2
      allocate ( track_L2(2*size(temp)) )
      track_L2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_L2(i)%p )
    track_L2(i)%where = trim(where) // "@@" // trimModule(module)
    num_r2 = max(num_r2,i)
  end subroutine TrackAllocateA_L2
  subroutine TrackAllocateA_L3 ( What, Where, Module )
    logical, allocatable :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_L3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r3
      if ( .not. associated(track_L3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_L3) ) then
      allocate(track_L3(initSize))
    else if ( i > size(track_L3) ) then
      temp => track_L3
      allocate ( track_L3(2*size(temp)) )
      track_L3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_L3(i)%p )
    track_L3(i)%where = trim(where) // "@@" // trimModule(module)
    num_r3 = max(num_r3,i)
  end subroutine TrackAllocateA_L3

  subroutine TrackAllocateA_R1 ( What, Where, Module )
    real, allocatable :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_r1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r1
      if ( .not. associated(track_r1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_r1) ) then
      allocate(track_r1(initSize))
    else if ( i > size(track_r1) ) then
      temp => track_r1
      allocate ( track_r1(2*size(temp)) )
      track_r1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_r1(i)%p )
    track_r1(i)%where = trim(where) // "@@" // trimModule(module)
    num_r1 = max(num_r1,i)
  end subroutine TrackAllocateA_R1
  subroutine TrackAllocateA_R2 ( What, Where, Module )
    real, allocatable :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_r2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r2
      if ( .not. associated(track_r2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_r2) ) then
      allocate(track_r2(initSize))
    else if ( i > size(track_r2) ) then
      temp => track_r2
      allocate ( track_r2(2*size(temp)) )
      track_r2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_r2(i)%p )
    track_r2(i)%where = trim(where) // "@@" // trimModule(module)
    num_r2 = max(num_r2,i)
  end subroutine TrackAllocateA_R2
  subroutine TrackAllocateA_R3 ( What, Where, Module )
    real, allocatable :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_r3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r3
      if ( .not. associated(track_r3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_r3) ) then
      allocate(track_r3(initSize))
    else if ( i > size(track_r3) ) then
      temp => track_r3
      allocate ( track_r3(2*size(temp)) )
      track_r3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_r3(i)%p )
    track_r3(i)%where = trim(where) // "@@" // trimModule(module)
    num_r3 = max(num_r3,i)
  end subroutine TrackAllocateA_R3
  subroutine TrackAllocateA_R4 ( What, Where, Module )
    real, allocatable :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_r4_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r4
      if ( .not. associated(track_r4(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_r4) ) then
      allocate(track_r4(initSize))
    else if ( i > size(track_r4) ) then
      temp => track_r4
      allocate ( track_r4(2*size(temp)) )
      track_r4(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_r4(i)%p )
    track_r4(i)%where = trim(where) // "@@" // trimModule(module)
    num_r4 = max(num_r4,i)
  end subroutine TrackAllocateA_R4

  subroutine TrackAllocate_D1 ( What, Where, Module )
    double precision, pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_d1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d1
      if ( .not. associated(track_d1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_d1) ) then
      allocate(track_d1(initSize))
    else if ( i > size(track_d1) ) then
      temp => track_d1
      allocate ( track_d1(2*size(temp)) )
      track_d1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_d1(i)%p => what
    track_d1(i)%where = trim(where) // "@@" // trimModule(module)
    num_d1 = max(num_d1,i)
  end subroutine TrackAllocate_D1
  subroutine TrackAllocate_D2 ( What, Where, Module )
    double precision, pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_d2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d2
      if ( .not. associated(track_d2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_d2) ) then
      allocate(track_d2(initSize))
    else if ( i > size(track_d2) ) then
      temp => track_d2
      allocate ( track_d2(2*size(temp)) )
      track_d2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_d2(i)%p => what
    track_d2(i)%where = trim(where) // "@@" // trimModule(module)
    num_d2 = max(num_d2,i)
  end subroutine TrackAllocate_D2
  subroutine TrackAllocate_D3 ( What, Where, Module )
    double precision, pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_d3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d3
      if ( .not. associated(track_d3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_d3) ) then
      allocate(track_d3(initSize))
    else if ( i > size(track_d3) ) then
      temp => track_d3
      allocate ( track_d3(2*size(temp)) )
      track_d3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_d3(i)%p => what
    track_d3(i)%where = trim(where) // "@@" // trimModule(module)
    num_d3 = max(num_d3,i)
  end subroutine TrackAllocate_D3
  subroutine TrackAllocate_D4 ( What, Where, Module )
    double precision, pointer :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_d4_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d4
      if ( .not. associated(track_d4(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_d4) ) then
      allocate(track_d4(initSize))
    else if ( i > size(track_d4) ) then
      temp => track_d4
      allocate ( track_d4(2*size(temp)) )
      track_d4(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_d4(i)%p => what
    track_d4(i)%where = trim(where) // "@@" // trimModule(module)
    num_d4 = max(num_d4,i)
  end subroutine TrackAllocate_D4

  subroutine TrackAllocateA_D1 ( What, Where, Module )
    double precision, allocatable :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_d1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d1
      if ( .not. associated(track_d1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_d1) ) then
      allocate(track_d1(initSize))
    else if ( i > size(track_d1) ) then
      temp => track_d1
      allocate ( track_d1(2*size(temp)) )
      track_d1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_d1(i)%p )
    track_d1(i)%where = trim(where) // "@@" // trimModule(module)
    num_d1 = max(num_d1,i)
  end subroutine TrackAllocateA_D1
  subroutine TrackAllocateA_D2 ( What, Where, Module )
    double precision, allocatable :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_d2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d2
      if ( .not. associated(track_d2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_d2) ) then
      allocate(track_d2(initSize))
    else if ( i > size(track_d2) ) then
      temp => track_d2
      allocate ( track_d2(2*size(temp)) )
      track_d2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_d2(i)%p )
    track_d2(i)%where = trim(where) // "@@" // trimModule(module)
    num_d2 = max(num_d2,i)
  end subroutine TrackAllocateA_D2
  subroutine TrackAllocateA_D3 ( What, Where, Module )
    double precision, allocatable :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_d3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d3
      if ( .not. associated(track_d3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_d3) ) then
      allocate(track_d3(initSize))
    else if ( i > size(track_d3) ) then
      temp => track_d3
      allocate ( track_d3(2*size(temp)) )
      track_d3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_d3(i)%p )
    track_d3(i)%where = trim(where) // "@@" // trimModule(module)
    num_d3 = max(num_d3,i)
  end subroutine TrackAllocateA_D3
  subroutine TrackAllocateA_D4 ( What, Where, Module )
    double precision, allocatable :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_d4_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d4
      if ( .not. associated(track_d4(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_d4) ) then
      allocate(track_d4(initSize))
    else if ( i > size(track_d4) ) then
      temp => track_d4
      allocate ( track_d4(2*size(temp)) )
      track_d4(:size(temp)) = temp
      deallocate ( temp )
    end if
9   nullify ( track_d4(i)%p )
    track_d4(i)%where = trim(where) // "@@" // trimModule(module)
    num_d4 = max(num_d4,i)
  end subroutine TrackAllocateA_D4

  subroutine TrackAllocate_L1 ( What, Where, Module )
    logical, pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_l1_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_l1
      if ( .not. associated(track_l1(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_l1) ) then
      allocate(track_l1(initSize))
    else if ( i > size(track_l1) ) then
      temp => track_l1
      allocate ( track_l1(2*size(temp)) )
      track_l1(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_l1(i)%p => what(:)
    track_l1(i)%where = trim(where) // "@@" // trimModule(module)
    num_l1 = max(num_l1,i)
  end subroutine TrackAllocate_L1
  subroutine TrackAllocate_L2 ( What, Where, Module )
    logical, pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_l2_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_l2
      if ( .not. associated(track_l2(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_l2) ) then
      allocate(track_l2(initSize))
    else if ( i > size(track_l2) ) then
      temp => track_l2
      allocate ( track_l2(2*size(temp)) )
      track_l2(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_l2(i)%p => what(:,:)
    track_l2(i)%where = trim(where) // "@@" // trimModule(module)
    num_l2 = max(num_l2,i)
  end subroutine TrackAllocate_L2
  subroutine TrackAllocate_L3 ( What, Where, Module )
    logical, pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    type(track_l3_t), pointer :: temp(:)
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_l3
      if ( .not. associated(track_l3(i)%p) ) go to 9 ! Found empty one
    end do
    if ( .not. associated(track_l3) ) then
      allocate(track_l3(initSize))
    else if ( i > size(track_l3) ) then
      temp => track_l3
      allocate ( track_l3(2*size(temp)) )
      track_l3(:size(temp)) = temp
      deallocate ( temp )
    end if
9   track_l3(i)%p => what(:,:,:)
    track_l3(i)%where = trim(where) // "@@" // trimModule(module)
    num_l3 = max(num_l3,i)
  end subroutine TrackAllocate_L3

  subroutine TrackDeallocate_C1 ( What, Where, Module )
    character(len=*), pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_c1
      if ( associated(track_c1(i)%p, what(:)(1:1)) ) then
        nullify ( track_c1(i)%p )  ! Mark it free
        do num_c1 = num_c1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_c1(num_c1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_C1
  subroutine TrackDeallocate_C2 ( What, Where, Module )
    character(len=*), pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_c2
      if ( associated(track_c2(i)%p, what(:,:)(1:1)) ) then
        nullify ( track_c2(i)%p )  ! Mark it free
        do num_c2 = num_c2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_c2(num_c2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_C2
  subroutine TrackDeallocate_C3 ( What, Where, Module )
    character(len=*), pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_c3
      if ( associated(track_c3(i)%p, what(:,:,:)(1:1)) ) then
        nullify ( track_c3(i)%p )  ! Mark it free
        do num_c3 = num_c3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_c3(num_c3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_C3

  subroutine TrackDeallocate_X1 ( What, Where, Module )
    complex, pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_x1
      if ( associated(track_x1(i)%p, what) ) then
        nullify ( track_x1(i)%p )  ! Mark it free
        do num_x1 = num_x1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_x1(num_x1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_X1
  subroutine TrackDeallocate_X2 ( What, Where, Module )
    complex, pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_x2
      if ( associated(track_x2(i)%p, what) ) then
        nullify ( track_x2(i)%p )  ! Mark it free
        do num_x2 = num_x2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_x2(num_x2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_X2
  subroutine TrackDeallocate_X3 ( What, Where, Module )
    complex, pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_x3
      if ( associated(track_x3(i)%p, what) ) then
        nullify ( track_x3(i)%p )  ! Mark it free
        do num_x3 = num_x3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_x3(num_x3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_X3

  subroutine TrackDeallocate_Z1 ( What, Where, Module )
    complex(kind(0.0d0)), pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_z1
      if ( associated(track_z1(i)%p, what) ) then
        nullify ( track_z1(i)%p )  ! Mark it free
        do num_z1 = num_z1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_z1(num_z1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_Z1
  subroutine TrackDeallocate_Z2 ( What, Where, Module )
    complex(kind(0.0d0)), pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_z2
      if ( associated(track_z2(i)%p, what) ) then
        nullify ( track_z2(i)%p )  ! Mark it free
        do num_z2 = num_z2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_z2(num_z2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_Z2
  subroutine TrackDeallocate_Z3 ( What, Where, Module )
    complex(kind(0.0d0)), pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_z3
      if ( associated(track_z3(i)%p, what) ) then
        nullify ( track_z3(i)%p )  ! Mark it free
        do num_z3 = num_z3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_z3(num_z3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_Z3

  subroutine TrackDeallocate_I1 ( What, Where, Module )
    integer, pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_i1
      if ( associated(track_i1(i)%p, what) ) then
        nullify ( track_i1(i)%p )  ! Mark it free
        do num_i1 = num_i1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_i1(num_i1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_I1
  subroutine TrackDeallocate_I2 ( What, Where, Module )
    integer, pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_i2
      if ( associated(track_i2(i)%p, what) ) then
        nullify ( track_i2(i)%p )  ! Mark it free
        do num_i2 = num_i2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_i2(num_i2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_I2
  subroutine TrackDeallocate_I3 ( What, Where, Module )
    integer, pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_i3
      if ( associated(track_i3(i)%p, what) ) then
        nullify ( track_i3(i)%p )  ! Mark it free
        do num_i3 = num_i3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_i3(num_i3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_I3
  subroutine TrackDeallocate_I4 ( What, Where, Module )
    integer, pointer :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_i4
      if ( associated(track_i4(i)%p, what) ) then
        nullify ( track_i4(i)%p )  ! Mark it free
        do num_i4 = num_i4, 1, -1  ! Reduce count to speed searches
          if ( associated(track_i4(num_i4)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_I4

  subroutine TrackDeallocate_R1 ( What, Where, Module )
    real, pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r1
      if ( associated(track_r1(i)%p, what) ) then
        nullify ( track_r1(i)%p )  ! Mark it free
        do num_r1 = num_r1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_r1(num_r1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_R1
  subroutine TrackDeallocate_R2 ( What, Where, Module )
    real, pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r2
      if ( associated(track_r2(i)%p, what) ) then
        nullify ( track_r2(i)%p )  ! Mark it free
        do num_r2 = num_r2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_r2(num_r2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_R2
  subroutine TrackDeallocate_R3 ( What, Where, Module )
    real, pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r3
      if ( associated(track_r3(i)%p, what) ) then
        nullify ( track_r3(i)%p )  ! Mark it free
        do num_r3 = num_r3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_r3(num_r3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_R3
  subroutine TrackDeallocate_R4 ( What, Where, Module )
    real, pointer :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r4
      if ( associated(track_r4(i)%p, what) ) then
        nullify ( track_r4(i)%p )  ! Mark it free
        do num_r4 = num_r4, 1, -1  ! Reduce count to speed searches
          if ( associated(track_r4(num_r4)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_R4

  subroutine TrackDeallocateA_C1 ( What, Where, Module )
    character(len=*), allocatable, target :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_c1
      if ( associated(track_c1(i)%p, what) ) then
        nullify ( track_c1(i)%p )  ! Mark it free
        do num_c1 = num_c1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_c1(num_c1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_C1
  subroutine TrackDeallocateA_C2 ( What, Where, Module )
    character(len=*), allocatable, target :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_c2
      if ( associated(track_c2(i)%p, what) ) then
        nullify ( track_c2(i)%p )  ! Mark it free
        do num_c2 = num_c2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_c2(num_c2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_C2
  subroutine TrackDeallocateA_I1 ( What, Where, Module )
    integer, allocatable, target :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r1
      if ( associated(track_I1(i)%p, what) ) then
        nullify ( track_I1(i)%p )  ! Mark it free
        do num_r1 = num_r1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_I1(num_r1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_I1
  subroutine TrackDeallocateA_I2 ( What, Where, Module )
    integer, allocatable, target :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r2
      if ( associated(track_I2(i)%p, what) ) then
        nullify ( track_I2(i)%p )  ! Mark it free
        do num_r2 = num_r2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_I2(num_r2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_I2
  subroutine TrackDeallocateA_I3 ( What, Where, Module )
    integer, allocatable, target :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r3
      if ( associated(track_I3(i)%p, what) ) then
        nullify ( track_I3(i)%p )  ! Mark it free
        do num_r3 = num_r3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_I3(num_r3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_I3
  subroutine TrackDeallocateA_I4 ( What, Where, Module )
    integer, allocatable, target :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r4
      if ( associated(track_I4(i)%p, what) ) then
        nullify ( track_I4(i)%p )  ! Mark it free
        do num_r4 = num_r4, 1, -1  ! Reduce count to speed searches
          if ( associated(track_I4(num_r4)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_I4

  subroutine TrackDeallocateA_L1 ( What, Where, Module )
    logical, allocatable, target :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r1
      if ( associated(track_L1(i)%p, what) ) then
        nullify ( track_L1(i)%p )  ! Mark it free
        do num_r1 = num_r1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_L1(num_r1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_L1
  subroutine TrackDeallocateA_L2 ( What, Where, Module )
    logical, allocatable, target :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r2
      if ( associated(track_L2(i)%p, what) ) then
        nullify ( track_L2(i)%p )  ! Mark it free
        do num_r2 = num_r2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_L2(num_r2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_L2
  subroutine TrackDeallocateA_L3 ( What, Where, Module )
    logical, allocatable, target :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r3
      if ( associated(track_L3(i)%p, what) ) then
        nullify ( track_L3(i)%p )  ! Mark it free
        do num_r3 = num_r3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_L3(num_r3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_L3

  subroutine TrackDeallocateA_R1 ( What, Where, Module )
    real, allocatable, target :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r1
      if ( associated(track_r1(i)%p, what) ) then
        nullify ( track_r1(i)%p )  ! Mark it free
        do num_r1 = num_r1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_r1(num_r1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_R1
  subroutine TrackDeallocateA_R2 ( What, Where, Module )
    real, allocatable, target :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r2
      if ( associated(track_r2(i)%p, what) ) then
        nullify ( track_r2(i)%p )  ! Mark it free
        do num_r2 = num_r2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_r2(num_r2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_R2
  subroutine TrackDeallocateA_R3 ( What, Where, Module )
    real, allocatable, target :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r3
      if ( associated(track_r3(i)%p, what) ) then
        nullify ( track_r3(i)%p )  ! Mark it free
        do num_r3 = num_r3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_r3(num_r3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_R3
  subroutine TrackDeallocateA_R4 ( What, Where, Module )
    real, allocatable, target :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_r4
      if ( associated(track_r4(i)%p, what) ) then
        nullify ( track_r4(i)%p )  ! Mark it free
        do num_r4 = num_r4, 1, -1  ! Reduce count to speed searches
          if ( associated(track_r4(num_r4)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_R4

  subroutine TrackDeallocate_D1 ( What, Where, Module )
    double precision, pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d1
      if ( associated(track_d1(i)%p, what) ) then
        nullify ( track_d1(i)%p )  ! Mark it free
        do num_d1 = num_d1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_d1(num_d1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_D1
  subroutine TrackDeallocate_D2 ( What, Where, Module )
    double precision, pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d2
      if ( associated(track_d2(i)%p, what) ) then
        nullify ( track_d2(i)%p )  ! Mark it free
        do num_d2 = num_d2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_d2(num_d2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_D2
  subroutine TrackDeallocate_D3 ( What, Where, Module )
    double precision, pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d3
      if ( associated(track_d3(i)%p, what) ) then
        nullify ( track_d3(i)%p )  ! Mark it free
        do num_d3 = num_d3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_d3(num_d3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_D3
  subroutine TrackDeallocate_D4 ( What, Where, Module )
    double precision, pointer :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d4
      if ( associated(track_d4(i)%p, what) ) then
        nullify ( track_d4(i)%p )  ! Mark it free
        do num_d4 = num_d4, 1, -1  ! Reduce count to speed searches
          if ( associated(track_d4(num_d4)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_D4

  subroutine TrackDeallocateA_D1 ( What, Where, Module )
    double precision, allocatable, target :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d1
      if ( associated(track_d1(i)%p, what) ) then
        nullify ( track_d1(i)%p )  ! Mark it free
        do num_d1 = num_d1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_d1(num_d1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_D1
  subroutine TrackDeallocateA_D2 ( What, Where, Module )
    double precision, allocatable, target :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d2
      if ( associated(track_d2(i)%p, what) ) then
        nullify ( track_d2(i)%p )  ! Mark it free
        do num_d2 = num_d2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_d2(num_d2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_D2
  subroutine TrackDeallocateA_D3 ( What, Where, Module )
    double precision, allocatable, target :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d3
      if ( associated(track_d3(i)%p, what) ) then
        nullify ( track_d3(i)%p )  ! Mark it free
        do num_d3 = num_d3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_d3(num_d3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_D3
  subroutine TrackDeallocateA_D4 ( What, Where, Module )
    double precision, allocatable, target :: What(:,:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_d4
      if ( associated(track_d4(i)%p, what) ) then
        nullify ( track_d4(i)%p )  ! Mark it free
        do num_d4 = num_d4, 1, -1  ! Reduce count to speed searches
          if ( associated(track_d4(num_d4)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocateA_D4

  subroutine TrackDeallocate_L1 ( What, Where, Module )
    logical, pointer :: What(:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_l1
      if ( associated(track_l1(i)%p, what) ) then
        nullify ( track_l1(i)%p )  ! Mark it free
        do num_l1 = num_l1, 1, -1  ! Reduce count to speed searches
          if ( associated(track_l1(num_l1)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_L1
  subroutine TrackDeallocate_L2 ( What, Where, Module )
    logical, pointer :: What(:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_l2
      if ( associated(track_l2(i)%p, what) ) then
        nullify ( track_l2(i)%p )  ! Mark it free
        do num_l2 = num_l2, 1, -1  ! Reduce count to speed searches
          if ( associated(track_l2(num_l2)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_L2
  subroutine TrackDeallocate_L3 ( What, Where, Module )
    logical, pointer :: What(:,:,:)
    character(len=*), intent(in) :: Where, Module
    integer :: I
    if ( size(what) == 0 ) return ! Never associated with another, so we can't track them
    do i = 1, num_l3
      if ( associated(track_l3(i)%p, what) ) then
        nullify ( track_l3(i)%p )  ! Mark it free
        do num_l3 = num_l3, 1, -1  ! Reduce count to speed searches
          if ( associated(track_l3(num_l3)%p) ) return
        end do
        return
      end if
    end do
    write ( *, '("No allocation found for ", a, " in ", a)' ) trim(where), trim(trimModule(module))
  end subroutine TrackDeallocate_L3

  subroutine ReportLeaks ( Where )
    use HIGHOUTPUT, only: DUMPSIZE
    character(len=*), intent(in), optional :: Where
    double precision :: Total ! memory still allocated that we could find
    if ( present(where) )  write ( *, '(a)' ) trim(where)
    write ( *, '(a)' ) "Checking for leaks involving arrays of one, two, or three dimensions", &
                     & "of type character, complex, double precision complex, integer, real", &
                     & "double precision, and logical.  Other types and ranks not tracked."
    total = 0
    call reportLeaks_c1 ( total )
    call reportLeaks_c2 ( total )
    call reportLeaks_c3 ( total )
    call reportLeaks_x1 ( total )
    call reportLeaks_x2 ( total )
    call reportLeaks_x3 ( total )
    call reportLeaks_z1 ( total )
    call reportLeaks_z2 ( total )
    call reportLeaks_z3 ( total )
    call reportLeaks_i1 ( total )
    call reportLeaks_i2 ( total )
    call reportLeaks_i3 ( total )
    call reportLeaks_i4 ( total )
    call reportLeaks_r1 ( total )
    call reportLeaks_r2 ( total )
    call reportLeaks_r3 ( total )
    call reportLeaks_r4 ( total )
    call reportLeaks_d1 ( total )
    call reportLeaks_d2 ( total )
    call reportLeaks_d3 ( total )
    call reportLeaks_d4 ( total )
    call reportLeaks_l1 ( total )
    call reportLeaks_l2 ( total )
    call reportLeaks_l3 ( total )
    call dumpsize ( total, advance='yes', before='At least ', &
      & after=' total still allocated.' )
  end subroutine ReportLeaks

  subroutine ReportLeaks_c1 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_c1
      if ( associated(track_c1(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
         &  track_c1(i)%where, size(track_c1(i)%p)
        total = total + len(track_c1(i)%p) * size(track_c1(i)%p)
      end if
    end do
  end subroutine ReportLeaks_c1
  subroutine ReportLeaks_c2 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_c2
      if ( associated(track_c2(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_c2(i)%where, size(track_c2(i)%p)
        total = total + len(track_c2(i)%p) * size(track_c2(i)%p)
      end if
    end do
  end subroutine ReportLeaks_c2
  subroutine ReportLeaks_c3 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_c3
      if ( associated(track_c3(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_c3(i)%where, size(track_c3(i)%p)
        total = total + len(track_c3(i)%p) * size(track_c3(i)%p)
      end if
    end do
  end subroutine ReportLeaks_c3

  subroutine ReportLeaks_x1 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_x1
      if ( associated(track_x1(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_x1(i)%where, size(track_x1(i)%p)
        total = total + 2 * charsPerInt * size(track_x1(i)%p)
      end if
    end do
  end subroutine ReportLeaks_x1
  subroutine ReportLeaks_x2 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_x2
      if ( associated(track_x2(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_x2(i)%where, size(track_x2(i)%p)
        total = total + 2 * charsPerInt * size(track_x2(i)%p)
      end if
    end do
  end subroutine ReportLeaks_x2
  subroutine ReportLeaks_x3 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_x3
      if ( associated(track_x3(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_x3(i)%where, size(track_x3(i)%p)
        total = total + 2 * charsPerInt * size(track_x3(i)%p)
      end if
    end do
  end subroutine ReportLeaks_x3

  subroutine ReportLeaks_z1 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_z1
      if ( associated(track_z1(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_z1(i)%where, size(track_z1(i)%p)
        total = total + 4 * charsPerInt * size(track_z1(i)%p)
      end if
    end do
  end subroutine ReportLeaks_z1
  subroutine ReportLeaks_z2 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_z2
      if ( associated(track_z2(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_z2(i)%where, size(track_z2(i)%p)
        total = total + 4 * charsPerInt * size(track_z2(i)%p)
      end if
    end do
  end subroutine ReportLeaks_z2
  subroutine ReportLeaks_z3 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_z3
      if ( associated(track_z3(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_z3(i)%where, size(track_z3(i)%p)
        total = total + 4 * charsPerInt * size(track_z3(i)%p)
      end if
    end do
  end subroutine ReportLeaks_z3

  subroutine ReportLeaks_i1 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_i1
      if ( associated(track_i1(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_i1(i)%where, size(track_i1(i)%p)
        total = total + charsPerInt * size(track_i1(i)%p)
      end if
    end do
  end subroutine ReportLeaks_i1
  subroutine ReportLeaks_i2 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_i2
      if ( associated(track_i2(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_i2(i)%where, size(track_i2(i)%p)
        total = total + charsPerInt * size(track_i2(i)%p)
      end if
    end do
  end subroutine ReportLeaks_i2
  subroutine ReportLeaks_i3 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_i3
      if ( associated(track_i3(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_i3(i)%where, size(track_i3(i)%p)
        total = total + charsPerInt * size(track_i3(i)%p)
      end if
    end do
  end subroutine ReportLeaks_i3
  subroutine ReportLeaks_i4 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_i4
      if ( associated(track_i4(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_i4(i)%where, size(track_i4(i)%p)
        total = total + charsPerInt * size(track_i4(i)%p)
      end if
    end do
  end subroutine ReportLeaks_i4

  subroutine ReportLeaks_r1 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_r1
      if ( associated(track_r1(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_r1(i)%where, size(track_r1(i)%p)
        total = total + charsPerInt * size(track_r1(i)%p)
      end if
    end do
  end subroutine ReportLeaks_r1
  subroutine ReportLeaks_r2 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_r2
      if ( associated(track_r2(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_r2(i)%where, size(track_r2(i)%p)
        total = total + charsPerInt * size(track_r2(i)%p)
      end if
    end do
  end subroutine ReportLeaks_r2
  subroutine ReportLeaks_r3 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_r3
      if ( associated(track_r3(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_r3(i)%where, size(track_r3(i)%p)
        total = total + charsPerInt * size(track_r3(i)%p)
      end if
    end do
  end subroutine ReportLeaks_r3
  subroutine ReportLeaks_r4 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_r4
      if ( associated(track_r4(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_r4(i)%where, size(track_r4(i)%p)
        total = total + charsPerInt * size(track_r4(i)%p)
      end if
    end do
  end subroutine ReportLeaks_r4

  subroutine ReportLeaks_d1 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_d1
      if ( associated(track_d1(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_d1(i)%where, size(track_d1(i)%p)
        total = total + 2 * charsPerInt * size(track_d1(i)%p)
      end if
    end do
  end subroutine ReportLeaks_d1
  subroutine ReportLeaks_d2 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_d2
      if ( associated(track_d2(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_d2(i)%where, size(track_d2(i)%p)
        total = total + 2 * charsPerInt * size(track_d2(i)%p)
      end if
    end do
  end subroutine ReportLeaks_d2
  subroutine ReportLeaks_d3 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_d3
      if ( associated(track_d3(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_d3(i)%where, size(track_d3(i)%p)
        total = total + 2 * charsPerInt * size(track_d3(i)%p)
      end if
    end do
  end subroutine ReportLeaks_d3
  subroutine ReportLeaks_d4 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_d4
      if ( associated(track_d4(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_d4(i)%where, size(track_d4(i)%p)
        total = total + 2 * charsPerInt * size(track_d4(i)%p)
      end if
    end do
  end subroutine ReportLeaks_d4

  subroutine ReportLeaks_l1 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_l1
      if ( associated(track_l1(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_l1(i)%where, size(track_l1(i)%p)
        total = total + charsPerInt * size(track_l1(i)%p)
      end if
    end do
  end subroutine ReportLeaks_l1
  subroutine ReportLeaks_l2 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_l2
      if ( associated(track_l2(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_l2(i)%where, size(track_l2(i)%p)
        total = total + charsPerInt * size(track_l2(i)%p)
      end if
    end do
  end subroutine ReportLeaks_l2
  subroutine ReportLeaks_l3 ( Total )
    double precision, intent(inout) :: Total
    integer :: I
    do i = 1, num_l3
      if ( associated(track_l3(i)%p) ) then
        write ( *, '(a," Still allocated with ", i0, " elements")' ) &
          & track_l3(i)%where, size(track_l3(i)%p)
        total = total + charsPerInt * size(track_l3(i)%p)
      end if
    end do
  end subroutine ReportLeaks_l3

  function TrimModule ( Module )
    character(len=*), intent(in) :: Module
    character(len=len(module)) :: TrimModule
    if ( module(1:1) == '$' ) then
      ! Module is <dollar>RCSFile: <filename>,v <dollar>
      trimModule = module(11:(len_trim(module)-8))
    else
      trimModule = module
    end if
  end function TrimModule

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Track.f90,v 2.10 2017/10/31 23:42:57 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Track_m

! $Log: Track.f90,v $
! Revision 2.10  2017/10/31 23:42:57  vsnyder
! Add allocatable logical array support
!
! Revision 2.9  2016/09/07 23:54:37  vsnyder
! Add support for allocatable integer arrays
!
! Revision 2.8  2015/06/02 23:59:42  vsnyder
! Track allocation and deallocation of allocatable arrays
!
! Revision 2.7  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.6  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.5  2008/05/20 01:59:29  vsnyder
! Add 4d integer, real, double
!
! Revision 2.4  2007/04/14 00:35:34  vsnyder
! Remove declarations for unused variables
!
! Revision 2.3  2006/08/04 18:14:15  vsnyder
! Add size tracking to ReportLeaks, simplify TrackDeallocate
!
! Revision 2.2  2006/07/29 03:42:34  vsnyder
! Can't track zero-size allocations
!
! Revision 2.1  2006/07/29 03:00:54  vsnyder
! Initial commit
!
@


2.10
log
@Add allocatable logical array support
@
text
@d46 2
d91 2
d633 42
d1420 32
d2132 1
a2132 1
       "$Id: Track.f90,v 2.9 2016/09/07 23:54:37 vsnyder Exp $"
d2142 3
@


2.9
log
@Add support for allocatable integer arrays
@
text
@d50 3
d93 3
d156 12
a203 12
  type :: Track_L1_t
    logical, pointer :: P(:) => NULL()
    character(len=whereLen) :: Where
  end type Track_L1_t
  type :: Track_L2_t
    logical, pointer :: P(:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_L2_t
  type :: Track_L3_t
    logical, pointer :: P(:,:,:) => NULL()
    character(len=whereLen) :: Where
  end type Track_L3_t
d714 64
d1439 49
d2054 1
a2054 1
       "$Id: Track.f90,v 2.8 2015/06/02 23:59:42 vsnyder Exp $"
d2064 3
@


2.8
log
@Track allocation and deallocation of allocatable arrays
@
text
@d46 4
d86 4
d623 85
d1304 65
d1935 1
a1935 1
       "$Id: Track.f90,v 2.7 2014/01/09 00:24:29 pwagner Exp $"
d1945 3
@


2.7
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d45 9
d81 9
d615 85
d785 85
d1211 65
d1341 65
d1777 1
a1777 1
       "$Id: Track.f90,v 2.6 2009/06/23 18:25:42 pwagner Exp $"
d1787 3
@


2.6
log
@Prevent Intel from optimizing ident string away
@
text
@d229 1
a229 1
       "$RCSfile: $"
d1138 1
a1138 1
    use output_m, only: DumpSize
d1459 1
a1459 1
       "$Id: read_apriori.f90 is it here $"
d1469 3
@


2.5
log
@Add 4d integer, real, double
@
text
@d229 1
a229 1
       "$RCSfile: Track.f90,v $"
d1456 1
a1457 1
!---------------------------- RCS Ident Info -------------------------------
d1459 2
a1460 3
       "$Id: Track.f90,v 2.4 2007/04/14 00:35:34 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1462 1
d1464 1
d1469 3
@


2.4
log
@Remove declarations for unused variables
@
text
@d33 1
d37 1
d41 1
d60 1
d64 1
d68 1
d124 4
d140 4
d156 4
d185 1
d189 1
d193 1
d210 1
d214 1
d218 1
d444 1
a444 1
9   track_i1(i)%p => what(:)
d465 1
a465 1
9   track_i2(i)%p => what(:,:)
d486 1
a486 1
9   track_i3(i)%p => what(:,:,:)
d490 21
d529 1
a529 1
9   track_r1(i)%p => what(:)
d550 1
a550 1
9   track_r2(i)%p => what(:,:)
d571 1
a571 1
9   track_r3(i)%p => what(:,:,:)
d575 21
d614 1
a614 1
9   track_d1(i)%p => what(:)
d635 1
a635 1
9   track_d2(i)%p => what(:,:)
d656 1
a656 1
9   track_d3(i)%p => what(:,:,:)
d660 21
d941 16
d1006 16
d1071 16
d1158 1
d1162 1
d1166 1
d1309 11
d1354 11
d1399 11
d1459 1
a1459 1
       "$Id: Track.f90,v 2.3 2006/08/04 18:14:15 vsnyder Exp $"
d1468 3
@


2.3
log
@Add size tracking to ReportLeaks, simplify TrackDeallocate
@
text
@d662 1
a662 1
    integer :: I, J
d678 1
a678 1
    integer :: I, J
d694 1
a694 1
    integer :: I, J
d711 1
a711 1
    integer :: I, J
d727 1
a727 1
    integer :: I, J
d743 1
a743 1
    integer :: I, J
d760 1
a760 1
    integer :: I, J
d776 1
a776 1
    integer :: I, J
d792 1
a792 1
    integer :: I, J
d809 1
a809 1
    integer :: I, J
d825 1
a825 1
    integer :: I, J
d841 1
a841 1
    integer :: I, J
d858 1
a858 1
    integer :: I, J
d874 1
a874 1
    integer :: I, J
d890 1
a890 1
    integer :: I, J
d907 1
a907 1
    integer :: I, J
d923 1
a923 1
    integer :: I, J
d939 1
a939 1
    integer :: I, J
d956 1
a956 1
    integer :: I, J
d972 1
a972 1
    integer :: I, J
d988 1
a988 1
    integer :: I, J
d1288 1
a1288 1
       "$Id: Track.f90,v 2.2 2006/07/29 03:42:34 vsnyder Exp $"
d1297 3
@


2.2
log
@Can't track zero-size allocations
@
text
@d201 2
d667 3
a669 9
        if ( i == num_c1 ) then    ! Reduce count to speed searches
          do j = num_c1-1, 1, -1
            if ( associated(track_c1(j)%p) ) then
              num_c1 = j
              return
            end if
          end do
          num_c1 = 0
        end if
d683 3
a685 9
        if ( i == num_c2 ) then    ! Reduce count to speed searches
          do j = num_c2-1, 1, -1
            if ( associated(track_c2(j)%p) ) then
              num_c2 = j
              return
            end if
          end do
          num_c2 = 0
        end if
d699 3
a701 9
        if ( i == num_c3 ) then    ! Reduce count to speed searches
          do j = num_c3-1, 1, -1
            if ( associated(track_c3(j)%p) ) then
              num_c3 = j
              return
            end if
          end do
          num_c3 = 0
        end if
d716 3
a718 9
        if ( i == num_x1 ) then    ! Reduce count to speed searches
          do j = num_x1-1, 1, -1
            if ( associated(track_x1(j)%p) ) then
              num_x1 = j
              return
            end if
          end do
          num_x1 = 0
        end if
d732 3
a734 9
        if ( i == num_x2 ) then    ! Reduce count to speed searches
          do j = num_x2-1, 1, -1
            if ( associated(track_x2(j)%p) ) then
              num_x2 = j
              return
            end if
          end do
          num_x2 = 0
        end if
d748 3
a750 9
        if ( i == num_x3 ) then    ! Reduce count to speed searches
          do j = num_x3-1, 1, -1
            if ( associated(track_x3(j)%p) ) then
              num_x3 = j
              return
            end if
          end do
          num_x3 = 0
        end if
d765 3
a767 9
        if ( i == num_z1 ) then    ! Reduce count to speed searches
          do j = num_z1-1, 1, -1
            if ( associated(track_z1(j)%p) ) then
              num_z1 = j
              return
            end if
          end do
          num_z1 = 0
        end if
d781 3
a783 9
        if ( i == num_z2 ) then    ! Reduce count to speed searches
          do j = num_z2-1, 1, -1
            if ( associated(track_z2(j)%p) ) then
              num_z2 = j
              return
            end if
          end do
          num_z2 = 0
        end if
d797 3
a799 9
        if ( i == num_z3 ) then    ! Reduce count to speed searches
          do j = num_z3-1, 1, -1
            if ( associated(track_z3(j)%p) ) then
              num_z3 = j
              return
            end if
          end do
          num_z3 = 0
        end if
d814 3
a816 9
        if ( i == num_i1 ) then    ! Reduce count to speed searches
          do j = num_i1-1, 1, -1
            if ( associated(track_i1(j)%p) ) then
              num_i1 = j
              return
            end if
          end do
          num_i1 = 0
        end if
d830 3
a832 9
        if ( i == num_i2 ) then    ! Reduce count to speed searches
          do j = num_i2-1, 1, -1
            if ( associated(track_i2(j)%p) ) then
              num_i2 = j
              return
            end if
          end do
          num_i2 = 0
        end if
d846 3
a848 9
        if ( i == num_i3 ) then    ! Reduce count to speed searches
          do j = num_i3-1, 1, -1
            if ( associated(track_i3(j)%p) ) then
              num_i3 = j
              return
            end if
          end do
          num_i3 = 0
        end if
d863 3
a865 9
        if ( i == num_r1 ) then    ! Reduce count to speed searches
          do j = num_r1-1, 1, -1
            if ( associated(track_r1(j)%p) ) then
              num_r1 = j
              return
            end if
          end do
          num_r1 = 0
        end if
d879 3
a881 9
        if ( i == num_r2 ) then    ! Reduce count to speed searches
          do j = num_r2-1, 1, -1
            if ( associated(track_r2(j)%p) ) then
              num_r2 = j
              return
            end if
          end do
          num_r2 = 0
        end if
d895 3
a897 9
        if ( i == num_r3 ) then    ! Reduce count to speed searches
          do j = num_r3-1, 1, -1
            if ( associated(track_r3(j)%p) ) then
              num_r3 = j
              return
            end if
          end do
          num_r3 = 0
        end if
d912 3
a914 9
        if ( i == num_d1 ) then    ! Reduce count to speed searches
          do j = num_d1-1, 1, -1
            if ( associated(track_d1(j)%p) ) then
              num_d1 = j
              return
            end if
          end do
          num_d1 = 0
        end if
d928 3
a930 9
        if ( i == num_d2 ) then    ! Reduce count to speed searches
          do j = num_d2-1, 1, -1
            if ( associated(track_d2(j)%p) ) then
              num_d2 = j
              return
            end if
          end do
          num_d2 = 0
        end if
d944 3
a946 9
        if ( i == num_d3 ) then    ! Reduce count to speed searches
          do j = num_d3-1, 1, -1
            if ( associated(track_d3(j)%p) ) then
              num_d3 = j
              return
            end if
          end do
          num_d3 = 0
        end if
d961 3
a963 9
        if ( i == num_l1 ) then    ! Reduce count to speed searches
          do j = num_l1-1, 1, -1
            if ( associated(track_l1(j)%p) ) then
              num_l1 = j
              return
            end if
          end do
          num_l1 = 0
        end if
d977 3
a979 9
        if ( i == num_l2 ) then    ! Reduce count to speed searches
          do j = num_l2-1, 1, -1
            if ( associated(track_l2(j)%p) ) then
              num_l2 = j
              return
            end if
          end do
          num_l2 = 0
        end if
d993 3
a995 9
        if ( i == num_l3 ) then    ! Reduce count to speed searches
          do j = num_l3-1, 1, -1
            if ( associated(track_l3(j)%p) ) then
              num_l3 = j
              return
            end if
          end do
          num_l3 = 0
        end if
d1002 32
a1033 23
  subroutine ReportLeaks
    write ( *, '(a)' ) "Checking for leaks..."
    call reportLeaks_c1
    call reportLeaks_c2
    call reportLeaks_c3
    call reportLeaks_x1
    call reportLeaks_x2
    call reportLeaks_x3
    call reportLeaks_z1
    call reportLeaks_z2
    call reportLeaks_z3
    call reportLeaks_i1
    call reportLeaks_i2
    call reportLeaks_i3
    call reportLeaks_r1
    call reportLeaks_r2
    call reportLeaks_r3
    call reportLeaks_d1
    call reportLeaks_d2
    call reportLeaks_d3
    call reportLeaks_l1
    call reportLeaks_l2
    call reportLeaks_l3
d1036 2
a1037 1
  subroutine ReportLeaks_c1
d1040 5
a1044 3
      if ( associated(track_c1(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_c1(i)%where, size(track_c1(i)%p)
d1047 2
a1048 1
  subroutine ReportLeaks_c2
d1051 5
a1055 3
      if ( associated(track_c2(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_c2(i)%where, size(track_c2(i)%p)
d1058 2
a1059 1
  subroutine ReportLeaks_c3
d1062 5
a1066 3
      if ( associated(track_c3(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_c3(i)%where, size(track_c3(i)%p)
d1070 2
a1071 1
  subroutine ReportLeaks_x1
d1074 5
a1078 3
      if ( associated(track_x1(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_x1(i)%where, size(track_x1(i)%p)
d1081 2
a1082 1
  subroutine ReportLeaks_x2
d1085 5
a1089 3
      if ( associated(track_x2(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_x2(i)%where, size(track_x2(i)%p)
d1092 2
a1093 1
  subroutine ReportLeaks_x3
d1096 5
a1100 3
      if ( associated(track_x3(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_x3(i)%where, size(track_x3(i)%p)
d1104 2
a1105 1
  subroutine ReportLeaks_z1
d1108 5
a1112 3
      if ( associated(track_z1(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_z1(i)%where, size(track_z1(i)%p)
d1115 2
a1116 1
  subroutine ReportLeaks_z2
d1119 5
a1123 3
      if ( associated(track_z2(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_z2(i)%where, size(track_z2(i)%p)
d1126 2
a1127 1
  subroutine ReportLeaks_z3
d1130 5
a1134 3
      if ( associated(track_z3(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_z3(i)%where, size(track_z3(i)%p)
d1138 2
a1139 1
  subroutine ReportLeaks_i1
d1142 5
a1146 3
      if ( associated(track_i1(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_i1(i)%where, size(track_i1(i)%p)
d1149 2
a1150 1
  subroutine ReportLeaks_i2
d1153 5
a1157 3
      if ( associated(track_i2(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_i2(i)%where, size(track_i2(i)%p)
d1160 2
a1161 1
  subroutine ReportLeaks_i3
d1164 5
a1168 3
      if ( associated(track_i3(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_i3(i)%where, size(track_i3(i)%p)
d1172 2
a1173 1
  subroutine ReportLeaks_r1
d1176 5
a1180 3
      if ( associated(track_r1(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_r1(i)%where, size(track_r1(i)%p)
d1183 2
a1184 1
  subroutine ReportLeaks_r2
d1187 5
a1191 3
      if ( associated(track_r2(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_r2(i)%where, size(track_r2(i)%p)
d1194 2
a1195 1
  subroutine ReportLeaks_r3
d1198 5
a1202 3
      if ( associated(track_r3(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_r3(i)%where, size(track_r3(i)%p)
d1206 2
a1207 1
  subroutine ReportLeaks_d1
d1210 5
a1214 3
      if ( associated(track_d1(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_d1(i)%where, size(track_d1(i)%p)
d1217 2
a1218 1
  subroutine ReportLeaks_d2
d1221 5
a1225 3
      if ( associated(track_d2(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_d2(i)%where, size(track_d2(i)%p)
d1228 2
a1229 1
  subroutine ReportLeaks_d3
d1232 5
a1236 3
      if ( associated(track_d3(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_d3(i)%where, size(track_d3(i)%p)
d1240 2
a1241 1
  subroutine ReportLeaks_l1
d1244 5
a1248 3
      if ( associated(track_l1(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_l1(i)%where, size(track_l1(i)%p)
d1251 2
a1252 1
  subroutine ReportLeaks_l2
d1255 5
a1259 3
      if ( associated(track_l2(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_l2(i)%where, size(track_l2(i)%p)
d1262 2
a1263 1
  subroutine ReportLeaks_l3
d1266 5
a1270 3
      if ( associated(track_l3(i)%p) ) &
        & write ( *, '(a," Still allocated with ", i0, " elements")' ) &
            & track_l3(i)%where, size(track_l3(i)%p)
d1288 1
a1288 1
       "$Id: Track.f90,v 2.1 2006/07/29 03:00:54 vsnyder Exp $"
d1297 3
@


2.1
log
@Initial commit
@
text
@d68 2
d72 1
a72 1
    character(32) :: Where
d76 1
a76 1
    character(32) :: Where
d80 1
a80 1
    character(32) :: Where
d84 1
a84 1
    character(32) :: Where
d88 1
a88 1
    character(32) :: Where
d92 1
a92 1
    character(32) :: Where
d96 1
a96 1
    character(32) :: Where
d100 1
a100 1
    character(32) :: Where
d104 1
a104 1
    character(32) :: Where
d108 1
a108 1
    character(32) :: Where
d112 1
a112 1
    character(32) :: Where
d116 1
a116 1
    character(32) :: Where
d120 1
a120 1
    character(32) :: Where
d124 1
a124 1
    character(32) :: Where
d128 1
a128 1
    character(32) :: Where
d132 1
a132 1
    character(32) :: Where
d136 1
a136 1
    character(32) :: Where
d140 1
a140 1
    character(32) :: Where
d144 1
a144 1
    character(32) :: Where
d148 1
a148 1
    character(32) :: Where
d152 1
a152 1
    character(32) :: Where
d154 1
d176 1
d203 1
a203 1
       "$RCSfile: Parse_Signal_m.f90,v $"
d214 1
d235 1
d256 1
d278 1
d299 1
d320 1
d342 1
d363 1
d384 1
d406 1
d427 1
d448 1
d470 1
d491 1
d512 1
d534 1
d555 1
d576 1
d598 1
d619 1
d640 1
d661 1
d683 1
d705 1
d728 1
d730 1
a730 1
      if ( associated(track_x1(i)%p, what(:)) ) then
d750 1
d752 1
a752 1
      if ( associated(track_x2(i)%p, what(:,:)) ) then
d772 1
d774 1
a774 1
      if ( associated(track_x3(i)%p, what(:,:,:)) ) then
d795 1
d797 1
a797 1
      if ( associated(track_z1(i)%p, what(:)) ) then
d817 1
d819 1
a819 1
      if ( associated(track_z2(i)%p, what(:,:)) ) then
d839 1
d841 1
a841 1
      if ( associated(track_z3(i)%p, what(:,:,:)) ) then
d862 1
d864 1
a864 1
      if ( associated(track_i1(i)%p, what(:)) ) then
d884 1
d886 1
a886 1
      if ( associated(track_i2(i)%p, what(:,:)) ) then
d906 1
d908 1
a908 1
      if ( associated(track_i3(i)%p, what(:,:,:)) ) then
d929 1
d931 1
a931 1
      if ( associated(track_r1(i)%p, what(:)) ) then
d951 1
d953 1
a953 1
      if ( associated(track_r2(i)%p, what(:,:)) ) then
d973 1
d975 1
a975 1
      if ( associated(track_r3(i)%p, what(:,:,:)) ) then
d996 1
d998 1
a998 1
      if ( associated(track_d1(i)%p, what(:)) ) then
d1018 1
d1020 1
a1020 1
      if ( associated(track_d2(i)%p, what(:,:)) ) then
d1040 1
d1042 1
a1042 1
      if ( associated(track_d3(i)%p, what(:,:,:)) ) then
d1063 1
d1065 1
a1065 1
      if ( associated(track_l1(i)%p, what(:)) ) then
d1085 1
d1087 1
a1087 1
      if ( associated(track_l2(i)%p, what(:,:)) ) then
d1107 1
d1109 1
a1109 1
      if ( associated(track_l3(i)%p, what(:,:,:)) ) then
d1127 1
d1340 1
a1340 1
       "$Id: Parse_Signal_m.f90,v 2.23 2005/06/22 17:25:50 pwagner Exp $"
d1348 4
a1351 1
! $Log: $
@

