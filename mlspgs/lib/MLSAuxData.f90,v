head	2.37;
access;
symbols
	v5-02-NRT-19:2.37
	v6-00:2.37
	v5-02-NRT-18:2.37
	v5-02:2.37
	v5-01-NRT-17:2.37
	v5-01-NRT-16:2.37
	v5-01-NRT-15:2.37
	v5-01-NRT-14:2.37
	neuralnetworks-1-0:2.37.0.8
	cfm-single-freq-0-1:2.37.0.6
	v5-01:2.37
	v5-00:2.37
	v4-23-TA133:2.37.0.4
	mus-emls-1-70:2.37.0.2
	rel-1-0-englocks-work:2.36.0.2
	VUMLS1-00:2.36
	VPL1-00:2.36
	V4-22-NRT-08:2.36
	VAM1-00:2.36
	V4-21:2.34.0.2
	V4-13:2.33
	V4-12:2.32
	V4-11:2.32
	V4-10:2.32
	V3-43:2.30
	M4-00:2.31
	V3-41:2.30
	V3-40-PlusGM57:2.30.0.2
	V2-24-NRT-04:2.26
	V3-33:2.31
	V2-24:2.26
	V3-31:2.31
	V3-30-NRT-05:2.31
	cfm-01-00:2.31
	V3-30:2.30
	V3-20:2.30
	V3-10:2.28
	V2-23-NRT-02:2.26
	V2-23:2.26
	V2-22-NRT-01:2.26
	V2-22:2.26
	V2-21:2.25
	V2-20:2.25
	V2-11:2.25
	V2-10:2.25
	V2-00:2.25
	V1-51:2.24
	V1-50:2.24
	V1-45:2.22
	V1-44:2.22
	V1-43:2.22
	V1-42:2.22
	V1-41:2.22
	V1-32:2.22
	V1-40:2.22
	V1-31:2.22
	V1-30:2.22
	V1-13:2.21
	V1-12:2.21
	V1-11:2.21
	V1-10:2.21
	newfwm-feb03:2.21.0.2;
locks; strict;
comment	@# @;


2.37
date	2018.04.19.02.00.36;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2015.04.29.00.52.16;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2015.03.28.01.12.53;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2015.01.21.19.27.07;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2014.09.05.00.00.00;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2014.03.07.19.19.24;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2010.03.25.18.41.02;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2009.08.21.19.45.05;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2009.07.30.20.43.05;	author honghanh;	state Exp;
branches;
next	2.27;

2.27
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2007.04.03.20.51.16;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2005.06.22.17.25.49;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2004.10.07.18.51.12;	author perun;	state Exp;
branches;
next	2.23;

2.23
date	2004.09.02.20.45.32;	author perun;	state Exp;
branches;
next	2.22;

2.22
date	2003.09.03.19.46.30;	author perun;	state Exp;
branches;
next	2.21;

2.21
date	2003.01.02.23.14.50;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2002.12.20.20.45.57;	author perun;	state Exp;
branches;
next	2.19;

2.19
date	2002.12.18.16.24.43;	author perun;	state Exp;
branches;
next	2.18;

2.18
date	2002.12.06.23.38.12;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2002.11.25.05.35.35;	author jdone;	state Exp;
branches;
next	2.16;

2.16
date	2002.11.11.19.20.25;	author jdone;	state Exp;
branches;
next	2.15;

2.15
date	2002.10.31.22.12.49;	author jdone;	state Exp;
branches;
next	2.14;

2.14
date	2002.10.24.03.19.00;	author jdone;	state Exp;
branches;
next	2.13;

2.13
date	2002.10.21.22.10.32;	author jdone;	state Exp;
branches;
next	2.12;

2.12
date	2002.10.08.00.09.11;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2002.10.05.01.03.08;	author jdone;	state Exp;
branches;
next	2.10;

2.10
date	2002.10.05.00.52.50;	author jdone;	state Exp;
branches;
next	2.9;

2.9
date	2002.10.05.00.30.20;	author jdone;	state Exp;
branches;
next	2.8;

2.8
date	2002.10.04.22.35.31;	author jdone;	state Exp;
branches;
next	2.7;

2.7
date	2002.10.04.22.13.30;	author jdone;	state Exp;
branches;
next	2.6;

2.6
date	2002.10.03.22.15.37;	author jdone;	state Exp;
branches;
next	2.5;

2.5
date	2002.09.27.23.37.54;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2002.09.26.23.58.04;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2002.09.09.05.43.39;	author jdone;	state Exp;
branches;
next	2.2;

2.2
date	2002.09.09.05.26.15;	author jdone;	state Exp;
branches;
next	2.1;

2.1
date	2002.09.03.04.20.34;	author jdone;	state Exp;
branches;
next	;


desc
@@


2.37
log
@Compute address for allocate/deallocate tracking.  Remove USE statements for
unused names.
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module MLSAuxData

  ! Reading and interacting with Level 1B data (HDF5)
  use MLS_DataProducts, only: DATAPRODUCTS_T
  use HDF5, only: HID_T, HSIZE_T, H5T_NATIVE_CHARACTER, H5T_NATIVE_DOUBLE, &
       H5T_NATIVE_INTEGER, H5T_IEEE_F32LE, H5S_UNLIMITED_F, H5T_STD_I32LE, & 
       H5T_NATIVE_REAL,H5T_IEEE_F64LE,H5P_DATASET_CREATE_F, H5S_SELECT_SET_F, &
       H5DOPEN_F, H5DCLOSE_F, H5SCREATE_SIMPLE_F, H5PCREATE_F, H5DCREATE_F, &
       H5PSET_CHUNK_F, H5SCLOSE_F, H5DGET_SPACE_F, H5PCLOSE_F, & 
       H5SGET_SIMPLE_EXTENT_NDIMS_F, H5SGET_SIMPLE_EXTENT_DIMS_F, &
       H5DGET_CREATE_PLIST_F, H5PGET_CHUNK_F, H5DGET_TYPE_F, & 
       H5SSELECT_HYPERSLAB_F, H5DREAD_F, H5DWRITE_F, H5DEXTEND_F, &
       H5ACREATE_F, H5AWRITE_F, H5AREAD_F, H5ACLOSE_F, H5TCOPY_F, &
       H5TSET_SIZE_F, H5AOPEN_NAME_F, H5AGET_SPACE_F, &
       H5TEQUAL_F, H5ESET_AUTO_F, H5GCREATE_F, H5GCLOSE_F, &
       H5GOPEN_F, H5PSET_FILL_VALUE_F, SIZE_T
  use MLSCommon, only: NAMELEN
  use MLSKINDS, only: R4, R8
  use MLSStrings, only: LOWERCASE
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
  use output_m, only: switchOutput, revertOutput
  
  implicit NONE

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -
!     (data types and parameters)
! MLSAuxData_T                   Quantities from an L1B/L2 data file
!
!                 (subroutines and functions)
!
! AddMLSAuxDataToDatabase      Creates and updates an array of MLSAuxData_T.
!                              Returns size of the array.
!
! DestroyMLSAuxDataDatabase    Deallocates each element of an array of 
!                              MLSAuxData_T and then deallocates the array.
!
! Build_MLSAuxData             Incorporates the routines stated below to 
!                              create a dataset of any type and any dimension
!                              so that user does not need to worry about 
!                              MLSAuxData_T data structure.
!
! Recall_MLSAuxData            Incorporates the routines stated below to 
!                              read a dataset of any type and any dimension
!                              so that user does not need to worry about 
!                              MLSAuxData_T data structure.
!
! Allocate_MLSAuxData          Allocates a MLSAuxData data structure.
! 
! Create_MLSAuxData            Creates MLSAuxData in a file. 
!
! CreateGroup_MLSAuxData       Creates a group or subgroup in a file. 
!
! Read_MLSAuxAttributes        Reads an attribute of a MLSAuxData quantity
!                              from a file.
!
! Read_MLSAuxData              Reads all info concerning a MLSAuxData quantity
!                              from a file.
!
! Write_MLSAuxAttributes       Writes an attribute of a MLSAuxData quantity
!                              to a file.
!
! Write_MLSAuxData             Writes all info concerning a MLSAuxData quantity
!                              to a file.
!
! Deallocate_MLSAuxData        Deallocates memory of a MLSAuxData_T.
!
! === (end of toc) ===
  private
  public :: MLSAuxData_T, Create_MLSAuxData, Read_MLSAuxData, & 
   & Deallocate_MLSAuxData, Write_MLSAuxData, Read_MLSAuxAttributes, &
   & Write_MLSAuxAttributes, CreateGroup_MLSAuxData, Allocate_MLSAuxData, &
   & Build_MLSAuxData, AddMLSAuxDataToDatabase, DestroyMLSAuxDataDatabase, &
   MaxCharFieldLen
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSAuxData.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
  !
  ! Parameters
  INTEGER, PARAMETER :: MaxCharFieldLen = 100000  ! max char field length
  !
  type MLSAuxData_T
    character (len=namelen) :: name, type_name  
    character(len=20),  dimension(:), pointer :: Dimensions => NULL()
    !
    character(len=MaxCharFieldLen), dimension(:,:,:), pointer :: CharField => &
         NULL()
    real(r8),  dimension(:,:,:), pointer :: DpField          => NULL()   
    real(r4),  dimension(:,:,:), pointer :: RealField        => NULL()   
    integer,   dimension(:,:,:), pointer :: IntField         => NULL()
    ! all the above dimensioned (noAuxInds,maxMIFs,noMAFs)
    !
    real(r8), dimension(:), pointer :: FrequencyCoordinates  => NULL()
    real(r8), dimension(:), pointer :: VerticalCoordinates   => NULL()
    real(r8), dimension(:), pointer :: HorizontalCoordinates => NULL()
    !
    integer :: FrequencyDimension          ! Enumerated type
    integer :: VerticalDimension           ! Enumerated type  
    integer :: HorizontalDimension         ! Enumerated type
    !
    integer :: rank ! rank of data set
    !
  end type MLSAuxData_T
!------------------------------------------------------------------- Exceptions
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSET_OPEN   = 'HDF5 Error Opening Dataset '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSET_CREATE = 'HDF5 Error Creating Dataset '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSET_WRITE  = 'HDF5 Error Writing Dataset '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSET_READ  = 'HDF5 Error Reading Dataset '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSET_EXTEND  = 'HDF5 Error Extending Dataset '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSET_GETSPACE = 'HDF5 Error Retrieving Dataspace of Dataset '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSET_GET_TYPE = 'HDF5 Error Retrieving Data Type of Dataset '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSET_CLOSE  = 'HDF5 Error Closing Dataset '

  CHARACTER(len=*), PUBLIC, PARAMETER :: &
    H5_ERROR_GROUP_OPEN   = 'HDF5 Error Opening Group '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_GROUP_CREATE = 'HDF5 Error Creating Group '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_GROUP_CLOSE  = 'HDF5 Error Closing Group '

  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_ATT_WRITE  = 'HDF5 Error Writing Attribute '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_ATT_GETSPACE  = 'HDF5 Error Getting Space of Attribute '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_ATT_READ  = 'HDF5 Error Reading Attribute '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_ATT_CREATE = 'HDF5 Error Creating Attribute '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_ATT_CLOSE  = 'HDF5 Error Closing Attribute '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_ATT_OPEN  = 'HDF5 Error Opening Attribute '

  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_TYPE_COPY = 'HDF5 Error Copying Datatype '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_TYPE_SET  = 'HDF5 Error Setting Datatype '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_TYPE_EQUAL  = 'HDF5 Error Equating Datatype '

  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSPACE_OPEN   = 'HDF5 Error Opening Dataspace '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSPACE_CREATE = 'HDF5 Error Creating Dataspace '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSPACE_GET_DIMS = & 
    'HDF5 Error Obtaining Dimensions of Dataspace '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSPACE_GET_NDIMS = & 
    'HDF5 Error Obtaining Number of Dimensions of Dataspace '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSPACE_HYPERSLAB = 'HDF5 Error Selecting Hyperslab '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_DSPACE_CLOSE  = 'HDF5 Error Closing Dataspace '

  CHARACTER(len=*), PUBLIC, PARAMETER :: &
    H5_ERROR_FILE_OPEN   = 'HDF5 Error Opening File '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_FILE_CLOSE  = 'HDF5 Error Closing File '

  CHARACTER(len=*), PUBLIC, PARAMETER :: &
    H5_ERROR_OPEN   = 'HDF5 Error Opening FORTRAN File API '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_CLOSE  = 'HDF5 Error Closing FORTRAN File API '

  CHARACTER(len=*), PUBLIC, PARAMETER :: &
    H5_ERROR_PROPERTY_CREATE = 'HDF5 Error Creating Property List '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_PROPERTY_CHUNK_SET  = 'HDF5 Error Setting Chunk Property '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_PROPERTY_CHUNK_GET  = 'HDF5 Error Getting Chunk Property '
  CHARACTER(len=*), PUBLIC, PARAMETER :: & 
    H5_ERROR_PROPERTY_CLOSE  = 'HDF5 Error Closing Property List '

  logical, parameter :: DEBUG = .false.

  interface Build_MLSAuxData
    module procedure Build_MLSAuxData_Character
    module procedure Build_MLSAuxData_Double, &
         Build_MLSAuxData_Double_1d, Build_MLSAuxData_Double_2d
    module procedure Build_MLSAuxData_Double_3d
    module procedure Build_MLSAuxData_Real, Build_MLSAuxData_Real_1d, & 
         Build_MLSAuxData_Real_2d
    module procedure Build_MLSAuxData_Real_3d
    module procedure Build_MLSAuxData_Integer, Build_MLSAuxData_Integer_1d, & 
         Build_MLSAuxData_Integer_2d
    module procedure Build_MLSAuxData_Integer_3d
  end interface

  interface Recall_MLSAuxData
    module procedure Recall_MLSAuxData_Character
    module procedure Recall_MLSAuxData_Double, &
         Recall_MLSAuxData_Double_1d, Recall_MLSAuxData_Double_2d
    module procedure Recall_MLSAuxData_Double_3d
    module procedure Recall_MLSAuxData_Real, Recall_MLSAuxData_Real_1d, & 
         Recall_MLSAuxData_Real_2d
    module procedure Recall_MLSAuxData_Real_3d
    module procedure Recall_MLSAuxData_Integer, Recall_MLSAuxData_Integer_1d, & 
         Recall_MLSAuxData_Integer_2d
    module procedure Recall_MLSAuxData_Integer_3d
  end interface

contains ! ============================ MODULE PROCEDURES ====================
!-------------------------------------------------------AddMLSAuxDataToDatabase
  integer function AddMLSAuxDataToDatabase ( database, item )
  ! Add a MLSAuxData to a database, and/or create the database.
  ! Returns the size of the array.
    
    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    type (MLSAuxData_T), dimension(:), pointer :: database
    type (MLSAuxData_T), intent(in) :: item

    ! Local variables
    type (MLSAuxData_T), dimension(:), pointer :: tempDatabase => NULL()

    include "addItemToDatabase.f9h"

    AddMLSAuxDataToDatabase = newSize

  end function AddMLSAuxDataToDatabase
!-----------------------------------------------------DestroyMLSAuxDataDatabase
  subroutine DestroyMLSAuxDataDatabase ( database )
  ! Deallocates the elements of array of MLSAuxData_T and then the array.
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type (MLSAuxData_T), dimension(:), pointer :: database
    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: index, s, status

    if ( associated(database) ) then
       do index = 1, SIZE(database)
          call  Deallocate_MLSAuxData( database(index) )
       end do
       s = size(database) * storage_size(database) / 8
       addr = 0
       if ( s > 0 ) addr = transfer(c_loc(database(1)), addr)
       deallocate ( database, stat=status )
       call test_deallocate ( status, ModuleName, "database", s, address=addr )
    end if

  end subroutine DestroyMLSAuxDataDatabase
!---------------------------------------------------------- Allocate_MLSAuxData
 subroutine Allocate_MLSAuxData( name, data_type, dims, MLSData  )
    ! This should be called when allocating a MLSAuxData structure.
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( MLSAuxData_T ), intent(inout) :: MLSData
    integer, dimension(3), intent(in) :: dims
    character (len=*), intent(in) :: name, data_type
    ! internal variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: status

    MLSData%name        = trim(name) 
    MLSData%type_name   = trim(data_type)

    if ( data_type == 'real') then
      allocate(MLSData%RealField(dims(1),dims(2),dims(3)), stat=status)
      addr = 0
      if ( status == 0 ) then
        addr = transfer(c_loc(MLSData%RealField(1,1,1)), addr)
      end if
      call test_allocate ( status, ModuleName, "MLSData%RealField", &
        & uBounds = dims(1:3), elementSize = storage_size(MLSData%RealField) / 8, &
        & address=addr )
    end if

    if ( data_type == 'double') then
      allocate(MLSData%DpField(dims(1),dims(2),dims(3)), stat=status)
      addr = 0
      if ( status == 0 ) then
        addr = transfer(c_loc(MLSData%DpField(1,1,1)), addr)
      end if
      call test_allocate ( status, ModuleName, "MLSData%DpField", &
        & uBounds = dims(1:3), elementSize = storage_size(MLSData%DpField) / 8, &
        & address=addr )
    end if

    if ( data_type == 'integer') then
      allocate(MLSData%IntField(dims(1),dims(2),dims(3)), stat=status)
      addr = 0
      if ( status == 0 ) then
        addr = transfer(c_loc(MLSData%IntField(1,1,1)), addr)
      end if
      call test_allocate ( status, ModuleName, "MLSData%IntField", &
        & uBounds = dims(1:3), elementSize = storage_size(MLSData%IntField) / 8, &
        & address=addr )
    end if

    if ( data_type == 'character') then
      allocate(MLSData%CharField(dims(1),dims(2),dims(3)), stat=status)
      addr = 0
      if ( status == 0 ) then
        addr = transfer(c_loc(MLSData%CharField(1,1,1)), addr)
      end if
      call test_allocate ( status, ModuleName, "MLSData%CharField", &
        & uBounds = dims(1:3), elementSize = storage_size(MLSData%CharField) / 8, &
        & address=addr )
    end if

 end subroutine Allocate_MLSAuxData
!---------------------------------------------------------Deallocate_MLSAuxData
 subroutine Deallocate_MLSAuxData( MLSAuxData )
    ! This should be called when deallocating a MLSAuxData structure.
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( MLSAuxData_T ), intent(inout) :: MLSAuxData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: s, status

    if (associated(MLSAuxData%RealField)) then
      s = size(MLSAuxData%RealField) * storage_size(MLSAuxData%RealField) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MLSAuxData%RealField(1,1,1)), addr)
      deallocate(MLSAuxData%RealField, stat=status)
      call test_deallocate ( status, ModuleName, &
        & ' MLSAuxData%RealField in ' // trim(MLSAuxData%name), s, address=addr )
    end if

    if (associated(MLSAuxData%IntField)) then 
      s = size(MLSAuxData%IntField) * storage_size(MLSAuxData%IntField) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MLSAuxData%IntField(1,1,1)), addr)
      deallocate(MLSAuxData%IntField, stat=status)
      call test_deallocate ( status, ModuleName, &
        & ' MLSAuxData%IntField in ' // trim(MLSAuxData%name), s, address=addr )
    end if

    if (associated(MLSAuxData%CharField)) then 
      s = size(MLSAuxData%CharField) * storage_size(MLSAuxData%CharField) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MLSAuxData%CharField(1,1,1)), addr)
      deallocate(MLSAuxData%CharField, stat=status)
      call test_deallocate ( status, ModuleName, &
        & ' MLSAuxData%CharField in ' // trim(MLSAuxData%name), s, address=addr )
    end if

    if (associated(MLSAuxData%DpField)) then 
      s = size(MLSAuxData%DpField) * storage_size(MLSAuxData%DpField) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MLSAuxData%DpField(1,1,1)), addr)
      deallocate(MLSAuxData%DpField, stat=status)
      call test_deallocate ( status, ModuleName, &
        & ' MLSAuxData%DpField in ' // trim(MLSAuxData%name), s, address=addr )
    end if

    if (associated(MLSAuxData%FrequencyCoordinates)) then 
      s = size(MLSAuxData%FrequencyCoordinates) * &
        & storage_size(MLSAuxData%FrequencyCoordinates) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MLSAuxData%FrequencyCoordinates(1)), addr)
      deallocate(MLSAuxData%FrequencyCoordinates, stat=status)
      call test_deallocate ( status, ModuleName, &
        & ' MLSAuxData%FrequencyCoordinates in ' // trim(MLSAuxData%name), s, &
        & address=addr )
    end if

    if (associated(MLSAuxData%VerticalCoordinates)) then 
      s = size(MLSAuxData%VerticalCoordinates) * &
        & storage_size(MLSAuxData%VerticalCoordinates) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MLSAuxData%VerticalCoordinates(1)), addr)
      deallocate(MLSAuxData%VerticalCoordinates, stat=status)
      call test_deallocate ( status, ModuleName, &
        & ' MLSAuxData%VerticalCoordinates in ' // trim(MLSAuxData%name), s, &
        & address=addr )
    end if

    if (associated(MLSAuxData%HorizontalCoordinates)) then 
      s = size(MLSAuxData%HorizontalCoordinates) * &
        & storage_size(MLSAuxData%HorizontalCoordinates) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MLSAuxData%HorizontalCoordinates(1)), addr)
      deallocate(MLSAuxData%HorizontalCoordinates, stat=status)
      call test_deallocate ( status, ModuleName, &
        & ' MLSAuxData%HorizontalCoordinates in ' // trim(MLSAuxData%name), s, &
        & address=addr )
    end if

    if (associated(MLSAuxData%Dimensions)) then 
      s = size(MLSAuxData%Dimensions) * &
        & storage_size(MLSAuxData%Dimensions) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MLSAuxData%Dimensions(1)), addr)
      deallocate(MLSAuxData%Dimensions, stat=status)
      call test_deallocate ( status, ModuleName, &
        & ' MLSAuxData%Dimensions in ' // trim(MLSAuxData%name), s, address=addr )
    end if

 end subroutine Deallocate_MLSAuxData
!--------------------------------------------------------------Build_MLSAuxData
 subroutine Build_MLSAuxData_Character( file_id, dataset, char_data, & 
      char_length, lastIndex, disable_attrib)
    type( DataProducts_T ), intent(in) :: dataset
    character (len=*), intent(in) :: char_data
    integer, intent(in) :: char_length
    integer, intent(in), optional ::lastIndex
    logical, intent(in), optional :: disable_attrib
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dims
    integer :: error
    logical :: attribenabled

    dims = 1

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),&
         trim(dataset%data_type),dims,MLSData)

    MLSData%CharField(1,1,1) = char_data
    MLSData%rank = 1

    call CopyFromDataProducts (dataset, MLSData)

    attribenabled = .false.
    if (present(lastIndex)) then 
       if (lastIndex == 1) then 
          if (present (disable_attrib)) then
             attribenabled = .false.
          else
             attribenabled = .true.
          end if
       end if
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=attribenabled, & 
            string_length=char_length, index=lastIndex)
    else
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=.true., & 
            string_length=char_length)
    end if

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Character
!--------------------------------------------------------------Build_MLSAuxData
 subroutine Build_MLSAuxData_Integer( file_id, dataset, int_data, & 
      lastIndex, fill_value, disable_attrib)
    type( DataProducts_T ), intent(in) :: dataset
    integer, intent(in) :: int_data
    integer, intent(in), optional :: lastIndex
    integer(hid_t), intent(in) :: file_id
    integer, intent(in), optional :: fill_value
    logical, intent(in), optional :: disable_attrib

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dims
    integer :: error
    logical :: attribenabled

    dims = 1

    call deallocate_mlsauxdata(MLSData)

    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dims,MLSData)

    MLSData%IntField(1,1,1) = int_data
    MLSData%rank = 1

    call CopyFromDataProducts (dataset, MLSData)

    attribenabled = .false.
    if ( present (lastIndex)) then
       if (lastIndex == 1) then 
          if (present (disable_attrib)) then
             attribenabled = .false.
          else
             attribenabled = .true.
          end if
       end if
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=attribenabled, index=lastIndex, &
               fill_value_i=fill_value)
    else

       call Write_MLSAuxData(file_id, MLSData, error, &
            write_attributes=.true., fill_value_i=fill_value)

    end if

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) )
    call deallocate_mlsauxdata(MLSData)

 end subroutine Build_MLSAuxData_Integer
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Real (file_id, dataset, real_data, lastIndex, &
      fill_value, disable_attrib)
    type( DataProducts_T ), intent(inout) :: dataset
    real, intent(in) :: real_data
    integer, intent(in), optional :: lastIndex
    real, intent(in), optional :: fill_value
    integer(hid_t), intent(in) :: file_id
    logical, intent(in), optional :: disable_attrib

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dims
    integer :: error
    logical :: attribenabled

    dims = 1

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dims,MLSData)

    MLSData%RealField(1,1,1) = real_data
    MLSData%rank = 1

    call CopyFromDataProducts (dataset, MLSData)

    attribenabled = .false.
    if ( present(lastIndex) ) then
       if (lastIndex == 1) then 
          if (present (disable_attrib)) then
             attribenabled = .false.
          else
             attribenabled = .true.
          end if
       end if
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=attribenabled, index=lastIndex, &
               fill_value_r=fill_value)
    else
       call Write_MLSAuxData (file_id, MLSData, error, fill_value_r=fill_value)
    end if

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Real
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Double( file_id, dataset, double_data, lastIndex, &
      fill_value, disable_attrib)
    type( DataProducts_T ), intent(in) :: dataset
    real(r8), intent(in) :: double_data
    integer, intent(in), optional :: lastIndex
    integer(hid_t), intent(in) :: file_id
    real(r8), intent(in), optional :: fill_value
    logical, intent(in), optional :: disable_attrib

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dims
    integer :: error
    logical :: attribenabled

    dims = 1

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dims,MLSData)
    MLSData%DpField(1,1,1) = double_data
    MLSData%rank = 1

    call CopyFromDataProducts (dataset, MLSData)

    attribenabled = .false.
    if ( present (lastIndex) ) then 
        if (lastIndex == 1) then 
          if (present (disable_attrib)) then
             attribenabled = .false.
          else
             attribenabled = .true.
          end if
       end if
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=attribenabled, index=lastIndex, &
               fill_value_d=fill_value)
     else
       call Write_MLSAuxData(file_id, MLSData, error,&           
            write_attributes=.true., fill_value_d=fill_value)
    end if

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Double
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Real_1d( file_id, dataset, real_data, lastIndex, &
      dims, fill_value, disable_attrib)
    type( DataProducts_T ), intent(in) :: dataset
    real, dimension(:), intent(in) :: real_data
    integer, dimension(:), intent(in), optional :: dims
    integer, intent(in), optional :: lastIndex
    real, intent(in), optional :: fill_value
    integer(hid_t), intent(in) :: file_id
    logical, intent(in), optional :: disable_attrib

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dim_array
    integer :: i,error
    logical :: attribenabled

    dim_array = 1
    if (present(dims) ) then
       dim_array(:size(dims)) = dims
    else
       do i=1,size(shape(real_data))
          dim_array(i) = size(real_data,i)
       end do
    end if

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    MLSData%RealField(1:dim_array(1),1,1) = real_data(1:dim_array(1)) 

    if ( present(lastIndex)) then 
       MLSData%rank = 2
    else
       MLSData%rank = 1
    end if

    call CopyFromDataProducts (dataset, MLSData)

    attribenabled = .false.
    if ( present(lastIndex)) then
       if (lastIndex == 1) then 
          if (present (disable_attrib)) then
             attribenabled = .false.
          else
             attribenabled = .true.
          end if
       end if
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=attribenabled, index=lastIndex, &
               fill_value_r=fill_value)
    else
       call Write_MLSAuxData(file_id, MLSData, error,&           
            write_attributes=.true., fill_value_r=fill_value) 
    end if

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) ) 

    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Real_1d
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Double_1d( file_id, dataset, double_data, & 
      lastIndex, dims, fill_value, disable_attrib)
    type( DataProducts_T ), intent(in) :: dataset
    real(r8), dimension(:), intent(in) :: double_data
    integer, dimension(:), intent(in), optional :: dims
    integer, intent(in), optional :: lastIndex
    integer(hid_t), intent(in) :: file_id
    real(r8), intent(in), optional :: fill_value
    logical, intent(in), optional :: disable_attrib

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dim_array
    integer :: i,error
    logical :: attribenabled

    dim_array = 1
    if (present(dims) ) then
       dim_array(:size(dims)) = dims
    else
       do i=1,size(shape(double_data))
          dim_array(i) = size(double_data,i)
       end do
    end if

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    MLSData%DpField(1:dim_array(1),1,1) = double_data(1:dim_array(1)) 

    if ( present (lastIndex) ) then 
       MLSData%rank = 2
    else
       MLSData%rank = 1
    end if

    call CopyFromDataProducts (dataset, MLSData)

    attribenabled = .false.
    if ( present(lastIndex)) then
       if (lastIndex == 1) then 
          if (present (disable_attrib)) then
             attribenabled = .false.
          else
             attribenabled = .true.
          end if
       end if
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=attribenabled, index=lastIndex, &
               fill_value_d=fill_value)
    else
       call Write_MLSAuxData(file_id, MLSData, error, &
            write_attributes=.true., fill_value_d=fill_value)
    end if

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Double_1d
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Integer_1d( file_id, dataset, integer_data, &
      lastIndex, dims, fill_value, disable_attrib)
    type( DataProducts_T ), intent(in) :: dataset
    integer, dimension(:), intent(in) :: integer_data
    integer, dimension(:), intent(in), optional :: dims
    integer, intent(in), optional :: lastIndex
    integer(hid_t), intent(in) :: file_id
    integer, intent(in), optional :: fill_value
    logical, intent(in), optional :: disable_attrib

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dim_array
    integer :: i,error
    logical :: attribenabled

    dim_array = 1
    if (present(dims) ) then
       dim_array(:size(dims)) = dims
    else
       do i=1,size(shape(integer_data))
          dim_array(i) = size(integer_data,i)
       end do
    end if

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    MLSData%IntField(1:dim_array(1),1,1) = integer_data(1:dim_array(1)) 

    if (present (lastIndex) ) then
       MLSData%rank = 2 
    else
       MLSData%rank = 1
    end if

    call CopyFromDataProducts (dataset, MLSData)

    attribenabled = .false.
    if ( present(lastIndex)) then
       if (lastIndex == 1) then 
          if (present (disable_attrib)) then
             attribenabled = .false.
          else
             attribenabled = .true.
          end if
       end if
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=attribenabled, index=lastIndex, &
               fill_value_i=fill_value)
    else
       call Write_MLSAuxData(file_id, MLSData, error, &
            write_attributes=.true., fill_value_i=fill_value)
    end if

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Integer_1d
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Real_2d( file_id, dataset, real_data, lastIndex, &
      dims, fill_value, disable_attrib)
    type( DataProducts_T ), intent(in) :: dataset
    real, dimension(:,:), intent(in) :: real_data
    integer, dimension(:), intent(in), optional :: dims
    integer, intent(in), optional :: lastIndex
    real, intent(in), optional :: fill_value
    integer(hid_t), intent(in) :: file_id
    logical, intent(in), optional :: disable_attrib

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dim_array
    integer :: i,error
    logical :: attribenabled

    dim_array = 1
    if (present(dims) ) then
       dim_array(:size(dims)) = dims
    else
       do i=1,size(shape(real_data))
          dim_array(i) = size(real_data,i)
       end do
    end if

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    MLSData%RealField(1:dim_array(1),1:dim_array(2),1) = &
      & real_data(1:dim_array(1),1:dim_array(2))

    if (present (lastIndex) ) then 
       MLSData%rank = 3
    else
       MLSData%rank = 2
    end if

    call CopyFromDataProducts (dataset, MLSData)

    if ( MLSData%name == "R1A:118.B22D:PT.S0.DACS-4 precision" .and. DEBUG ) then
      print *, '2d real dim_array: ', dim_array
    end if
    attribenabled = .false.
    if (present (lastIndex) ) then 
       if (lastIndex == 1) then 
          if (present (disable_attrib)) then
             attribenabled = .false.
          else
             attribenabled = .true.
          end if
       end if
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=attribenabled, index=lastIndex, &
               fill_value_r=fill_value)
    else
       call Write_MLSAuxData(file_id, MLSData, error, &
            write_attributes=.true., fill_value_r=fill_value)
    end if

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Real_2d
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Double_2d( file_id, dataset, double_data, & 
      lastIndex, dims, fill_value, disable_attrib)
    type( DataProducts_T ), intent(in) :: dataset
    real(r8), dimension(:,:), intent(in) :: double_data
    integer, dimension(:), intent(in), optional :: dims
    integer, intent(in), optional :: lastIndex
    integer(hid_t), intent(in) :: file_id
    real(r8), intent(in), optional :: fill_value
    logical, intent(in), optional :: disable_attrib

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dim_array
    integer :: i,error
    logical :: attribenabled

    dim_array = 1
    if (present(dims) ) then
       dim_array(:size(dims)) = dims
    else
       do i=1,size(shape(double_data))
          dim_array(i) = size(double_data,i)
       end do
    end if

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    MLSData%DpField(1:dim_array(1),1:dim_array(2),1) = &
      & double_data(1:dim_array(1),1:dim_array(2))

    if (present (lastIndex) ) then 
       MLSData%rank = 3
    else
       MLSData%rank = 2
    end if

    call CopyFromDataProducts (dataset, MLSData)

    if ( MLSData%name == "R1A:118.B22D:PT.S0.DACS-4 precision"  .and. DEBUG ) then
      print *, '2d double dim_array: ', dim_array
    end if
    attribenabled = .false.
    if (present (lastIndex) ) then
       if (lastIndex == 1) then 
          if (present (disable_attrib)) then
             attribenabled = .false.
          else
             attribenabled = .true.
          end if
       end if
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=attribenabled, index=lastIndex, &
               fill_value_d=fill_value)
    else
       call Write_MLSAuxData(file_id, MLSData, error, &
            write_attributes=.true., fill_value_d=fill_value)
    end if

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Double_2d
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Integer_2d( file_id, dataset, integer_data, &
      lastIndex, dims, fill_value, disable_attrib)
    type( DataProducts_T ), intent(in) :: dataset
    integer, dimension(:,:), intent(in) :: integer_data
    integer, dimension(:), intent(in), optional :: dims
    integer, intent(in), optional :: lastIndex
    integer(hid_t), intent(in) :: file_id
    integer, intent(in), optional :: fill_value
    logical, intent(in), optional :: disable_attrib

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dim_array
    integer :: i,error
    logical :: attribenabled

    dim_array = 1
    if (present(dims) ) then
       dim_array(:size(dims)) = dims
    else
       do i=1,size(shape(integer_data))
          dim_array(i) = size(integer_data,i)
       end do
    end if

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    MLSData%IntField(1:dim_array(1),1:dim_array(2),1) = &
      & integer_data(1:dim_array(1),1:dim_array(2))

    if (present (lastIndex)) then 
       MLSData%rank = 3
    else
       MLSData%rank = 2
    end if

    call CopyFromDataProducts (dataset, MLSData)

    attribenabled = .false.
    if (present (lastIndex)) then
       if (lastIndex == 1) then 
          if (present (disable_attrib)) then
             attribenabled = .false.
          else
             attribenabled = .true.
          end if
       end if
       call Write_MLSAuxData(file_id, MLSData, error, & 
            write_attributes=attribenabled, index=lastIndex, &
               fill_value_i=fill_value)
    else
       call Write_MLSAuxData(file_id, MLSData, error, &
            write_attributes=.true., fill_value_i=fill_value)
    end if

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Integer_2d
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Real_3d( file_id, dataset, real_data, &
      dims, fill_value)
    type( DataProducts_T ), intent(in) :: dataset
    real, dimension(:,:,:), intent(in) :: real_data
    integer, dimension(:), intent(in), optional :: dims
    real, intent(in), optional :: fill_value
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dim_array
    integer :: i,error

    dim_array = 1
    if (present(dims) ) then
       dim_array(:size(dims)) = dims
    else
       do i=1,size(shape(real_data))
          dim_array(i) = size(real_data,i)
       end do
    end if

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    MLSData%rank = 3

    MLSData%RealField(1:dim_array(1),1:dim_array(2),1:dim_array(3)) = &
      & real_data(1:dim_array(1),1:dim_array(2),1:dim_array(3))

    call CopyFromDataProducts (dataset, MLSData)

    if ( MLSData%name == "R1A:118.B22D:PT.S0.DACS-4 precision"  .and. DEBUG ) then
      print *, '3d real dim_array: ', dim_array
    end if

    call Write_MLSAuxData(file_id, MLSData, error,write_attributes=.true., &
         fill_value_r=fill_value)

    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData for '// trim(dataset%name) ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Real_3d
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Double_3d( file_id, dataset, double_data, &
      dims, fill_value)
    type( DataProducts_T ), intent(in) :: dataset
    real(r8), dimension(:,:,:), intent(in) :: double_data
    integer, dimension(:), intent(in), optional :: dims
    integer(hid_t), intent(in) :: file_id
    real(r8), intent(in), optional :: fill_value

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dim_array
    integer :: i,error

    dim_array = 1
    if (present(dims) ) then
       dim_array(:size(dims)) = dims
    else
       do i=1,size(shape(double_data))
          dim_array(i) = size(double_data,i)
       end do
    end if

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    MLSData%rank = 3

    MLSData%DpField(1:dim_array(1),1:dim_array(2),1:dim_array(3)) = &
      & double_data(1:dim_array(1),1:dim_array(2),1:dim_array(3))

    call CopyFromDataProducts (dataset, MLSData)
    if ( MLSData%name == "R1A:118.B22D:PT.S0.DACS-4 precision"  .and. DEBUG ) then
      print *, '3d double dim_array: ', dim_array
    end if

    call Write_MLSAuxData(file_id, MLSData, error,write_attributes=.true., &
         fill_value_d=fill_value)
    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData.' ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Double_3d
!------------------------------------------------------------------------------
 subroutine Build_MLSAuxData_Integer_3d (file_id,dataset, integer_data, dims, &
      fill_value)
    type( DataProducts_T ), intent(in) :: dataset
    integer, dimension(:,:,:), intent(in) :: integer_data
    integer, dimension(:), intent(in), optional :: dims
    integer(hid_t), intent(in) :: file_id
    integer, intent(in), optional :: fill_value

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dim_array
    integer :: i,error

    dim_array = 1
    if (present(dims) ) then
       dim_array(:size(dims)) = dims
    else
       do i=1,size(shape(integer_data))
          dim_array(i) = size(integer_data,i)
       end do
    end if

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    MLSData%rank = 3

    MLSData%IntField(1:dim_array(1),1:dim_array(2),1:dim_array(3)) = &
      & integer_data(1:dim_array(1),1:dim_array(2),1:dim_array(3))

    call CopyFromDataProducts (dataset, MLSData)

    call Write_MLSAuxData(file_id, MLSData, error, write_attributes=.true., &
         fill_value_i=fill_value)
    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         'Error Writing MLSAuxData.' ) 
    call deallocate_mlsauxdata(MLSData)
 end subroutine Build_MLSAuxData_Integer_3d
  !------------------------------------------------------- Recall_MLSAuxData
 subroutine Recall_MLSAuxData_Character( file_id, dataset, char_data, &
      char_length)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    character (len=*), intent(inout) :: char_data
    integer, intent(in) :: char_length
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dims
    integer :: error, status

    dims = 1

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),&
         trim(dataset%data_type),dims,MLSData)

    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type), MLSData, error, read_attributes=.true.)

    if (error == 0) then 
       char_data = MLSData%CharField(1,1,1) 

       allocate(dataset%Dimensions(1), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = 1, elementSize = storage_size(dataset%Dimensions) / 8, &
         & address=addr )
       call CopyToDataProducts (MLSData, dataset)

    else 
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) )
    end if

    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Character
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Integer( file_id, dataset, int_data )
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    integer, intent(inout) :: int_data
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dims
    integer :: error, status

    dims = 1

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dims,MLSData)

    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type),MLSData, error, read_attributes=.true.)

    if (error == 0) then 
       int_data = MLSData%IntField(1,1,1)

       allocate(dataset%Dimensions(1), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = 1, elementSize = storage_size(dataset%Dimensions) / 8, &
         & address=addr )
       call CopyToDataProducts(MLSData, dataset)

    else 
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) ) 
    end if

    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Integer
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Real(file_id,dataset,real_data)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    real, intent(inout) :: real_data
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dims
    integer :: error, status

    dims = 1

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dims,MLSData)

    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type),MLSData, error, read_attributes=.true.)
    if (error == 0) then 
       real_data = MLSData%RealField(1,1,1)

       allocate(dataset%Dimensions(1), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = 1, elementSize = storage_size(dataset%Dimensions) / 8, &
         & address=addr )
       call CopyToDataProducts(MLSData, dataset)

    else
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) )
    end if
    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Real
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Double( file_id, dataset, double_data)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    real(r8), intent(inout) :: double_data
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dims
    integer :: error, status

    dims = 1

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dims,MLSData)
    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type),MLSData, error, read_attributes=.true.)

    if (error == 0) then 
       double_data = MLSData%DpField(1,1,1)
       allocate(dataset%Dimensions(1), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = 1, elementSize = storage_size(dataset%Dimensions) / 8, &
         & address=addr )
       call CopyToDataProducts(MLSData, dataset)
    else
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) )
    end if

    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Double
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Real_1d( file_id, dataset, real_data, & 
      firstIndex, lastIndex)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    real, dimension(:), intent(inout) :: real_data
    integer, intent(in), optional :: firstIndex, lastIndex
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dim_array
    integer :: i,error, status, i_first, i_last

    dim_array = 1

    do i=1,size(shape(real_data))
      dim_array(i) = size(real_data,i)
    end do

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)
    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type),MLSData, error, read_attributes=.true.)

    if (error == 0) then

       if (present (firstIndex) .and. present (lastIndex) ) then
          i_first = firstIndex
          i_last  = lastIndex
       else
          i_first = 1
          i_last  = dim_array(1)
       end if

       allocate(dataset%Dimensions(MLSData%rank), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = MLSData%rank, &
         & elementSize = storage_size(dataset%Dimensions) / 8, address=addr )
       call CopyToDataProducts(MLSData, dataset)

       real_data(i_first:i_last) = MLSData%RealField(i_first:i_last,1,1)  

    else
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) )
    end if

    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Real_1d
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Double_1d(file_id, dataset, double_data, & 
      firstIndex, lastIndex)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    real(r8), dimension(:), intent(inout) :: double_data
    integer, intent(in), optional :: firstIndex, lastIndex
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dim_array
    integer :: i,error, status, i_first, i_last

    dim_array = 1

    do i=1,size(shape(double_data))
       dim_array(i) = size(double_data,i)
    end do

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type),MLSData, error, read_attributes=.true.)

    if (error == 0) then 

       if (present (firstIndex) .and. present (lastIndex) ) then
          i_first = firstIndex
          i_last  = lastIndex
       else
          i_first = 1
          i_last  = dim_array(1)
       end if

       allocate(dataset%Dimensions(MLSData%rank), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = MLSData%rank, &
         & elementSize = storage_size(dataset%Dimensions) / 8, address=addr )
       call CopyToDataProducts(MLSData, dataset)

       do i = i_first, i_last
          double_data(i) = MLSData%DpField(i,1,1) 
       end do


    else
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) )
    end if

    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Double_1d
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Integer_1d(file_id,dataset,integer_data, &
      firstIndex, lastIndex)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    integer, dimension(:), intent(inout) :: integer_data
    integer, intent(in), optional :: firstIndex, lastIndex
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dim_array
    integer :: i,error,status,i_first,i_last

    dim_array = 1

    do i=1,size(shape(integer_data))
       dim_array(i) = size(integer_data,i)
    end do

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type),MLSData, error, read_attributes=.true.)

    if (error == 0) then
       if (present (firstIndex) .and. present (lastIndex) ) then
          i_first = firstIndex
          i_last  = lastIndex
       else
          i_first = 1
          i_last  = dim_array(1)
       end if
       do i = i_first, i_last
          integer_data(i) = MLSData%IntField(i,1,1)  
       end do

       allocate(dataset%Dimensions(MLSData%rank), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = MLSData%rank, &
         & elementSize = storage_size(dataset%Dimensions) / 8, address=addr )
       call CopyToDataProducts(MLSData, dataset)

    else
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) )
    end if

    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Integer_1d
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Real_2d( file_id, dataset, real_data, & 
      firstIndex, lastIndex)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    real, dimension(:,:), intent(inout) :: real_data
    integer, intent(in), optional :: firstIndex, lastIndex
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dim_array
    integer :: i,error,status,j_first,j_last

    dim_array = 1

    do i=1,size(shape(real_data))
       dim_array(i) = size(real_data,i)
    end do

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type),MLSData, error, read_attributes=.true.)
    if (error == 0) then 

       if (present (firstIndex) .and. present (lastIndex) ) then
          j_first = firstIndex
          j_last  = lastIndex
       else
          j_first = 1
          j_last  = dim_array(2)
       end if

       real_data(1:dim_array(1),j_first:j_last) = &
         & MLSData%RealField(1:dim_array(1),j_first:j_last,1) 

       allocate(dataset%Dimensions(MLSData%rank), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = MLSData%rank, &
         & elementSize = storage_size(dataset%Dimensions) / 8, address=addr )
       call CopyToDataProducts(MLSData, dataset)

    else
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) )
    end if

    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Real_2d
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Double_2d( file_id, dataset, double_data,& 
      firstIndex, lastIndex)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    real(r8), dimension(:,:), intent(inout) :: double_data
    integer, intent(in), optional :: firstIndex, lastIndex
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dim_array
    integer :: i,error,status,j_first,j_last

    dim_array = 1

    do i=1,size(shape(double_data))
       dim_array(i) = size(double_data,i)
    end do

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type), MLSData, error, read_attributes=.true.)
    if (error == 0) then

       if (present (firstIndex) .and. present (lastIndex) ) then
          j_first = firstIndex
          j_last  = lastIndex
       else
          j_first = 1
          j_last  = dim_array(2)
       end if

       double_data(1:dim_array(1),j_first:j_last) = &
         & MLSData%DpField(1:dim_array(1),j_first:j_last,1) 

       allocate(dataset%Dimensions(MLSData%rank), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = MLSData%rank, &
         & elementSize = storage_size(dataset%Dimensions) / 8, address=addr )
       call CopyToDataProducts(MLSData, dataset)

    else
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) )
    end if
    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Double_2d
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Integer_2d( file_id, dataset, integer_data, &
      firstIndex, lastIndex)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    integer, dimension(:,:), intent(inout) :: integer_data
    integer, intent(in), optional :: firstIndex, lastIndex
    integer(hid_t), intent(in) :: file_id

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dim_array
    integer :: i,error, status,j_first, j_last

    dim_array = 1

    do i=1,size(shape(integer_data))
       dim_array(i) = size(integer_data,i)
    end do

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type), MLSData, error, read_attributes=.true.)
    if (error == 0) then

       if (present (firstIndex) .and. present (lastIndex) ) then
          j_first = firstIndex
          j_last  = lastIndex
       else
          j_first = 1
          j_last  = dim_array(2)
       end if

       integer_data(1:dim_array(1),j_first:j_last) = &
         & MLSData%IntField(1:dim_array(1),j_first:j_last,1) 

       allocate(dataset%Dimensions(MLSData%rank), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = MLSData%rank, &
         & elementSize = storage_size(dataset%Dimensions) / 8, address=addr )
       call CopyToDataProducts(MLSData, dataset)

    else
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) )
    end if
    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Integer_2d
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Real_3d( file_id, dataset, real_data, & 
      firstIndex, lastIndex)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    real, dimension(:,:,:), intent(inout) :: real_data
    integer(hid_t), intent(in) :: file_id
    integer, intent(in), optional :: firstIndex, lastIndex

    type( MLSAuxData_T ) :: MLSData
    integer, dimension(3) :: dim_array
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: i,error, status,k_first, k_last

    dim_array = 1

    do i=1,size(shape(real_data))
       dim_array(i) = size(real_data,i)
    end do

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type), MLSData, error, read_attributes=.true.)

    if (error == 0) then

       if (present (firstIndex) .and. present (lastIndex) ) then
          k_first = firstIndex
          k_last  = lastIndex
       else
          k_first = 1
          k_last  = dim_array(3)
       end if

       real_data(1:dim_array(1),1:dim_array(2),1:dim_array(3)) = &
         & MLSData%RealField(1:dim_array(1),1:dim_array(2),1:dim_array(3))

       allocate(dataset%Dimensions(3), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = 3, elementSize = storage_size(dataset%Dimensions) / 8, &
         & address=addr )
       call CopyToDataProducts(MLSData, dataset)

    else
       call MLSMessage(MLSMSG_Error, ModuleName, & 
            'Error Writing MLSAuxData for '// trim(dataset%name) )
    end if
    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Real_3d
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Double_3d( file_id, dataset, double_data, &
      firstIndex, lastIndex)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    real(r8), dimension(:,:,:), intent(inout) :: double_data
    integer(hid_t), intent(in) :: file_id
    integer, intent(in), optional :: firstIndex, lastIndex

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dim_array
    integer :: i,error, status,k_first, k_last

    dim_array = 1

    do i=1,size(shape(double_data))
       dim_array(i) = size(double_data,i)
    end do

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)
    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type), MLSData, error, read_attributes=.true.)
    if (error == 0) then

       if (present (firstIndex) .and. present (lastIndex) ) then
          k_first = firstIndex
          k_last  = lastIndex
       else
          k_first = 1
          k_last  = dim_array(3)
       end if

       double_data(1:dim_array(1),1:dim_array(2),1:dim_array(3)) = &
         & MLSData%DpField(1:dim_array(1),1:dim_array(2),1:dim_array(3))

       allocate(dataset%Dimensions(3), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = 3, elementSize = storage_size(dataset%Dimensions) / 8, &
         & address=addr )
       call CopyToDataProducts(MLSData, dataset)

    else
       call MLSMessage(MLSMSG_Error,ModuleName,'Error Writing MLSAuxData.')
    end if
    call deallocate_mlsauxdata(MLSData)
  end subroutine Recall_MLSAuxData_Double_3d
  !------------------------------------------------------------------------------
  subroutine Recall_MLSAuxData_Integer_3d(file_id,dataset,integer_data, &
       firstIndex, lastIndex)
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( DataProducts_T ), intent(inout) :: dataset
    integer, dimension(:,:,:), intent(inout) :: integer_data
    integer(hid_t), intent(in) :: file_id
    integer, intent(in), optional :: firstIndex, lastIndex

    type( MLSAuxData_T ) :: MLSData
    integer(c_intptr_t) :: Addr         ! For tracing
    integer, dimension(3) :: dim_array
    integer :: i,error,status,k_first, k_last

    dim_array = 1

    do i=1,size(shape(integer_data))
       dim_array(i) = size(integer_data,i)
    end do

    call deallocate_mlsauxdata(MLSData)
    call Allocate_MLSAuxData(trim(dataset%name),& 
         trim(dataset%data_type),dim_array,MLSData)

    call Read_MLSAuxData(file_id, trim(dataset%name), &
         trim(dataset%data_type), MLSData, error, read_attributes=.true.)
    if (error == 0) then

       if (present (firstIndex) .and. present (lastIndex) ) then
          k_first = firstIndex
          k_last  = lastIndex
       else
          k_first = 1
          k_last  = dim_array(3)
       end if

       ! dump the data into the array.

       integer_data(1:dim_array(1),1:dim_array(2),1:dim_array(3)) = &
         & MLSData%IntField(1:dim_array(1),1:dim_array(2),1:dim_array(3))

       allocate(dataset%Dimensions(3), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "dataset%Dimensions", &
         & ubounds = 3, elementSize = storage_size(dataset%Dimensions) / 8, &
         & address=addr )
       call CopyToDataProducts(MLSData, dataset)

    else
       call MLSMessage(MLSMSG_Error,ModuleName,'Error Writing MLSAuxData.')
    end if
    call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Integer_3d
!------------------------------------------------------------------------------
  subroutine CreateGroup_MLSAuxData(loc_id, group_name, subgroup_name)
!
! External variables
!
    character(len=*), intent(in) :: group_name
    character(len=*), intent(in), optional :: subgroup_name
    integer(hid_t), intent(in)   :: loc_id ! From HDF
!
! Internal variables
!
    integer(hid_t) :: group_id, subgroup_id
    integer :: h5error

    if ( .not. present(subgroup_name) ) then 

       call h5gcreate_f(loc_id, trim(group_name), group_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_GROUP_CREATE // trim(group_name))

       call h5gclose_f(group_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_GROUP_CLOSE // trim(group_name)) 

    else

       call h5gopen_f(loc_id, trim(group_name), group_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_GROUP_OPEN // trim(group_name))

       call h5gcreate_f(group_id, trim(subgroup_name), subgroup_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_GROUP_CREATE // trim(subgroup_name))

       call h5gclose_f(subgroup_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_GROUP_CLOSE // trim(subgroup_name)) 

       call h5gclose_f(group_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_GROUP_CLOSE // trim(group_name)) 

    end if

  end subroutine CreateGroup_MLSAuxData
! -------------------------------------------------  Create_MLSAuxData ----
  subroutine Create_MLSAuxData(file_id, MLSAuxData, string_length, & 
       write_attributes)

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
! This subroutine creates an entry in the HDF5 file.
!----------------------------------------------------------------------
! External variables

    type( MLSAuxData_T ), intent(in) :: MLSAuxData
    integer(hid_t), intent(in)       :: file_id ! From HDF
    integer, intent(in), optional    :: string_length
    logical, intent(in), optional    :: write_attributes
!-----------------------------------------------------------------------
! Internal variables
!
    character(len=namelen) :: aname
    real, dimension(:), allocatable :: attr_data
    integer(hsize_t), dimension(7) :: adims
    integer(hsize_t), dimension(3) :: chunk_dims, dims, maxdims
    integer(hsize_t), dimension(1) :: adims_create
    integer(hid_t) :: cparms,dspace_id,dset_id,type_id, &
         attr_id, atype_id, aspace_id, s_type_id
    integer :: i, rank, arank, h5error, status
!-----------------------------------------------------------------------

    test_type: select case (trim(MLSAuxData%type_name))
    case ('real')
       if (associated(MLSAuxData%RealField)) then 
          rank = size(shape(MLSAuxData%RealField))
          type_id = H5T_IEEE_F32LE
             do i=1,rank-1
                dims(i) = size(MLSAuxData%RealField, i)
                chunk_dims(i) = dims(i)
                maxdims(i) = chunk_dims(i)
             end do
             dims(rank) = 1
             chunk_dims(rank) = 1
             maxdims(rank) = H5S_UNLIMITED_F
          end if
       case ('double')
          if (associated(MLSAuxData%DpField)) then 
             rank = size(shape(MLSAuxData%DpField))
             type_id = H5T_NATIVE_DOUBLE
                do i=1,rank-1
                   dims(i) = size(MLSAuxData%DpField, i)
                   chunk_dims(i) = dims(i)
                   maxdims(i) = chunk_dims(i)
                end do
                dims(rank) = 1
                chunk_dims(rank) = 1
                maxdims(rank) = H5S_UNLIMITED_F
             end if
          case ('integer')
             if (associated(MLSAuxData%IntField)) then 
                rank = size(shape(MLSAuxData%IntField))
                type_id = H5T_NATIVE_INTEGER
                   do i=1,rank-1
                      dims(i) = size(MLSAuxData%IntField, i)
                      chunk_dims(i) = dims(i)
                      maxdims(i) = chunk_dims(i)
                   end do
                   dims(rank) = 1
                   chunk_dims(rank) = 1
                   maxdims(rank) = H5S_UNLIMITED_F
                end if
             case ('character')
                if (associated(MLSAuxData%CharField)) then 
                   rank = size(shape(MLSAuxData%CharField))
                   type_id = H5T_NATIVE_CHARACTER
                      do i=1,rank-1
                         dims(i) = size(MLSAuxData%CharField, i)
                         chunk_dims(i) = dims(i)
                         maxdims(i) = chunk_dims(i)
                      end do
                      dims(rank) = 1
                      chunk_dims(rank) = 1
                      maxdims(rank) = H5S_UNLIMITED_F
                   end if
                end select test_type
!--------------------------------------------------------------------
                call h5screate_simple_f(rank, dims(1:rank),dspace_id,h5error,& 
                     maxdims(1:rank))
                if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
                     H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name) )

                call h5pcreate_f(H5P_DATASET_CREATE_F,cparms,h5error)
                if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
                     H5_ERROR_PROPERTY_CREATE // trim(MLSAuxData%name) )

                call h5pset_chunk_f(cparms,rank,chunk_dims(1:rank),h5error)
                if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
                     H5_ERROR_PROPERTY_CHUNK_SET // trim(MLSAuxData%name) )

                if (trim(MLSAuxData%type_name)/='character') then

                   call h5dcreate_f(file_id,trim(MLSAuxData%name),type_id,&
                        dspace_id, dset_id,h5error,cparms)
                   if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                        ModuleName, H5_ERROR_DSET_CREATE//trim(MLSAuxData%name))

                else

                   call h5tcopy_f(type_id, s_type_id, h5error)
                   if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                        ModuleName, H5_ERROR_TYPE_COPY // trim(MLSAuxData%name))

                   call h5tset_size_f(s_type_id, int(string_length, size_t), h5error)
                   if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                        & ModuleName, H5_ERROR_TYPE_SET // trim(MLSAuxData%name))

                   call h5dcreate_f(file_id, trim(MLSAuxData%name), s_type_id, &
                        dspace_id, dset_id, h5error, cparms)
                   if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                        ModuleName, H5_ERROR_DSET_CREATE // &
                        trim(MLSAuxData%name))

                end if

!---------------- write the attributes -----------------------------

                if (present(write_attributes)) then 

                   if (write_attributes) then 

                      do i = 2, 7
                         adims(i) = 0
                      end do


                      if (associated(MLSAuxData%HorizontalCoordinates)) then 

                         arank = size(shape(MLSAuxData%HorizontalCoordinates))
                         atype_id = H5T_IEEE_F32LE
                         adims(1) = size(MLSAuxData%HorizontalCoordinates)
                         adims_create(1) = adims(1)

                         allocate(attr_data(adims(1)),STAT=status)
                         call test_allocate ( status, ModuleName, 'attr_data' )

                         do i=1, adims(1)
                            attr_data(i) = MLSAuxData%HorizontalCoordinates(i)
                         end do

                         aname = "HorizontalCoordinates"  

                         call h5screate_simple_f (arank, adims_create, &
                              aspace_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_DSPACE_CREATE//trim(aname)//&
                              ' in '//trim(MLSAuxData%name) )

                         call h5acreate_f (dset_id, trim(aname), atype_id, &
                              aspace_id, attr_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_ATT_CREATE //trim(aname)// &
                              ' in ' // trim(MLSAuxData%name) )

                         call h5awrite_f (attr_id, atype_id, attr_data, adims, &
                              h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_ATT_WRITE // &
                              trim(MLSAuxData%name))

                         call h5aclose_f (attr_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_ATT_CLOSE // &
                              trim(MLSAuxData%name))

                         call h5sclose_f (aspace_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_DSPACE_CLOSE // &
                              trim(MLSAuxData%name))

                         deallocate(attr_data,STAT=status)
                         call test_deallocate ( status, ModuleName,'attr_data' )

                      end if

                      if (associated(MLSAuxData%VerticalCoordinates) ) then 
                         arank = size(shape(MLSAuxData%VerticalCoordinates))
                         atype_id = H5T_IEEE_F32LE
                         adims(1) = size(MLSAuxData%VerticalCoordinates)
                         adims_create(1) = adims(1)

                         allocate(attr_data(adims(1)),STAT=status)
                         call test_allocate ( status, ModuleName, 'attr_data' )

                         do i=1,adims(1)
                            attr_data(i) = MLSAuxData%VerticalCoordinates(i)
                         end do

                         call h5screate_simple_f (arank, adims_create, &
                              aspace_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_DSPACE_CREATE // &
                              trim(MLSAuxData%name))

                         aname = "VerticalCoordinates"   
                         call h5acreate_f (dset_id, trim(aname), atype_id, &
                              aspace_id, attr_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_ATT_CREATE // &
                              trim(MLSAuxData%name))

                         call h5awrite_f (attr_id, atype_id, attr_data, adims, &
                              h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_ATT_WRITE // &
                              trim(MLSAuxData%name))

                         call h5aclose_f (attr_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_ATT_CLOSE // &
                              trim(MLSAuxData%name))

                         call h5sclose_f (aspace_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_DSPACE_CLOSE // &
                              trim(MLSAuxData%name))

                         deallocate(attr_data,STAT=status)
                         call test_deallocate ( status, ModuleName,'attr_data' )

                      end if

                      if (associated(MLSAuxData%FrequencyCoordinates)) then 
                         arank = size(shape(MLSAuxData%FrequencyCoordinates))
                         atype_id = H5T_IEEE_F32LE
                         adims(1) = size(MLSAuxData%FrequencyCoordinates)
                         adims_create(1) = adims(1)

                         allocate(attr_data(adims(1)),STAT=status)
                         call test_allocate ( status, ModuleName, 'attr_data' )

                         do i=1,adims(1)
                            attr_data(i) = MLSAuxData%FrequencyCoordinates(i)
                         end do

                         call h5screate_simple_f (arank, adims_create, &
                              aspace_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_DSPACE_CREATE // &
                              trim(MLSAuxData%name) )

                         aname = "FrequencyCoordinates"
                         call h5acreate_f (dset_id, trim(aname), atype_id, &
                              aspace_id, attr_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_ATT_CREATE // &
                              trim(MLSAuxData%name))

                         call h5awrite_f (attr_id, atype_id, attr_data, adims, &
                              h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_ATT_WRITE // &
                              trim(MLSAuxData%name) )

                         call h5aclose_f (attr_id, h5error)
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_ATT_CLOSE // &
                              trim(MLSAuxData%name) )

                         call h5sclose_f (aspace_id, h5error) 
                         if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
                              ModuleName, H5_ERROR_DSPACE_CLOSE // &
                              trim(MLSAuxData%name) )

                         deallocate(attr_data,STAT=status)
                         call test_deallocate ( status, ModuleName,'attr_data' )
                      end if
                   end if
                end if

!---------------- close all structures----------------------------------
!
                call h5sclose_f( dspace_id, h5error )
                if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
                     H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )

                call h5dclose_f( dset_id,   h5error )
                if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
                     H5_ERROR_DSET_CLOSE // trim(MLSAuxData%name) )

                call h5pclose_f( cparms,    h5error )
                if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
                     H5_ERROR_PROPERTY_CLOSE // trim(MLSAuxData%name) )

  end subroutine Create_MLSAuxData
!------------Read_MLSAuxAttributes ----
  subroutine Read_MLSAuxAttributes(dset_id, QuantityName, AttributeName, & 
       error, MLSAuxData, AttributeData)
  ! This subroutine reads attributes from the HDF5 file;
  ! e.g., FrequencyCoordinates
  ! They are returned either as:
  ! components of MLSAuxData (if supplied); or
  ! in the array AttributeData
  ! It is an error unless exactly one of the two is supplied
    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    character(len=*), intent(in)                  :: QuantityName
    character(len=*), intent(in)                  :: AttributeName
    integer(hid_t), intent(in)                    :: dset_id ! From h5dopen_f
    integer, intent(out)                          :: error   ! 0 unless trouble
    type( MLSAuxData_T ), intent(inout), optional :: MLSAuxData
    real, dimension(:), intent(out), optional     :: AttributeData
  ! Private
    character, dimension(:), allocatable :: char_data
    real, dimension(:), allocatable :: attr_data
    integer(hsize_t), dimension(7) :: adims    
    integer(hid_t) :: attr_id, atype_id, aspace_id
    integer, parameter :: OPTARGISMAD = 1
    integer, parameter :: OPTARGISARR = 2
    integer :: which_opt_arg, i, arank, h5error, status
    logical :: is_char
!------------------------------------------------------------------------
  ! Executable
    error = 0
    is_char = .false.
    atype_id = H5T_IEEE_F32LE
    do i = 2, 7
       adims(i) = 0
    end do
    ! Check that exactly 1 of the optional args is supplied
    which_opt_arg = 0
    if ( present(MLSAuxData) ) which_opt_arg = which_opt_arg + OPTARGISMAD
    if ( present(AttributeData) ) which_opt_arg = which_opt_arg + OPTARGISARR
    select case (which_opt_arg)
    case (OPTARGISMAD)
       select case (trim(AttributeName))
       case ('FrequencyCoordinates')
          if ( associated ( MLSAuxData%FrequencyCoordinates ) ) then
             arank = 1
             adims(1) = size(MLSAuxData%FrequencyCoordinates)
          else
             error = 1
             return
          end if
       case ('HorizontalCoordinates')
          if ( associated ( MLSAuxData%HorizontalCoordinates ) ) then
             arank = 1
             adims(1) = size(MLSAuxData%HorizontalCoordinates)
          else
             error = 1
             return
          end if
       case ('VerticalCoordinates')
          if ( associated ( MLSAuxData%VerticalCoordinates ) ) then
             arank = 1
             adims(1) = size(MLSAuxData%VerticalCoordinates)
          else
             error = 1
             return
          end if
       case ('Dimensions')
          if ( associated (MLSAuxData%Dimensions) ) then
             arank = 1
             is_char  = .true.
             atype_id = H5T_NATIVE_CHARACTER
             do i = 1, arank
                adims(i) = size(MLSAuxData%Dimensions)
             end do
          else
             error = 1
             return
          end if
       case default
          error = 1
          return
       end select
    case (OPTARGISARR)
       adims(1) = size(AttributeData)
    case default
       error = 1
       return
    end select

    call h5aopen_name_f(dset_id, trim(AttributeName), attr_id, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_ATT_OPEN // trim(AttributeName) // ' in ' // &
         QuantityName )

    call h5aget_space_f(attr_id, aspace_id, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_ATT_GETSPACE // QuantityName )

    if (is_char) then 

       allocate(char_data(adims(1)),stat=status)
       call test_allocate ( status, ModuleName, 'char_data' )

       call h5aread_f(attr_id, atype_id, char_data, adims, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_ATT_READ // trim(AttributeName) // ' in ' // &
            QuantityName )

    else

       allocate(attr_data(adims(1)),stat=status)
       call test_allocate ( status, ModuleName, 'attr_data' )

       call h5aread_f(attr_id, atype_id, attr_data, adims, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_ATT_READ // trim(AttributeName) // ' in ' // &
            QuantityName )

    end if

    select case (which_opt_arg)
    case (OPTARGISMAD)
       select case (trim(AttributeName))
       case ('FrequencyCoordinates')
          MLSAuxData%FrequencyCoordinates = attr_data(:adims(1))
       case ('HorizontalCoordinates')
          MLSAuxData%HorizontalCoordinates = attr_data(:adims(1))
       case ('VerticalCoordinates')
          MLSAuxData%VerticalCoordinates = attr_data(:adims(1))
       case ('Dimensions')
          MLSAuxData%Dimensions = char_data(:adims(1))
       end select

    case (OPTARGISARR)
       AttributeData = attr_data(:adims(1))
    end select

    call h5aclose_f(attr_id, h5error)                                  
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_ATT_CLOSE // trim(AttributeName) // ' in ' // &
         QuantityName )

    call h5sclose_f(aspace_id, h5error)                                
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_CLOSE // trim(AttributeName) // ' in ' // &
         QuantityName )

    if (allocated(attr_data)) then 
       deallocate(attr_data,STAT=status)
       call test_deallocate ( status, ModuleName, 'attr_data' )
    end if

    if (allocated(char_data)) then      
       deallocate(char_data,STAT=status)
       call test_deallocate ( status, ModuleName, 'char_data' )
    end if

  end subroutine Read_MLSAuxAttributes
  !-------------------------------------------------Write_MLSAuxAttributes ----
  subroutine Write_MLSAuxAttributes(dset_id, QuantityName, AttributeName, & 
       error, MLSAuxData, AttributeData)

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    ! This subroutine writes attributes to the HDF5 file;
    ! e.g., FrequencyCoordinates
    ! They are supplied either as:
    ! components of MLSAuxData (if supplied); or
    ! in the array AttributeData
    ! It is an error unless exactly one of the two is supplied
    character(len=*), intent(in)                  :: QuantityName
    character(len=*), intent(in)                  :: AttributeName
    integer(hid_t), intent(in)                    :: dset_id ! From h5dcreate_f
    integer, intent(out)                          :: error
    type( MLSAuxData_T ), intent(in), optional :: MLSAuxData
    real, dimension(:), intent(in), optional      :: AttributeData
    ! Private
    character(len=20), dimension(:), allocatable :: char_data
    real, dimension(:), allocatable :: attr_data
    integer(hsize_t), dimension(7) :: adims
    integer(hsize_t), dimension(1) :: adims_create
    integer(hid_t) :: atype_id, aspace_id, attr_id
    integer, parameter :: OPTARGISMAD = 1
    integer, parameter :: OPTARGISARR = 2
    integer :: which_opt_arg, i, arank, attrlen, h5error, status  
    logical :: is_char
    !-----------------------------------------------------------------------
    ! Executable
    error = 0
    atype_id = H5T_IEEE_F32LE
    is_char = .false.
    adims = 1
    ! Check that exactly 1 of the optional args is supplied
    ! The following will produce 0 if neither, 3 if both; else 1 or 2
    which_opt_arg = 0
    if ( present(MLSAuxData) ) which_opt_arg = which_opt_arg + OPTARGISMAD
    if ( present(AttributeData) ) which_opt_arg = which_opt_arg + OPTARGISARR
    select case (which_opt_arg)
    case (OPTARGISMAD)
       select case (trim(AttributeName))
       case ('FrequencyCoordinates')
          arank = 1
          adims(1) = size(MLSAuxData%FrequencyCoordinates)
          allocate(attr_data(adims(1)),STAT=status)
          call test_allocate ( status, ModuleName, 'attr_data' )

          do i=1,adims(1)
             attr_data(i) = MLSAuxData%FrequencyCoordinates(i)
          end do
       case ('HorizontalCoordinates')
          arank = 1
          adims(1) = size(MLSAuxData%HorizontalCoordinates)
          allocate(attr_data(adims(1)),STAT=status)
          call test_allocate ( status, ModuleName, 'attr_data' )

          do i=1,adims(1)
             attr_data(i) = MLSAuxData%HorizontalCoordinates(i)
          end do
       case ('VerticalCoordinates')
          arank = 1
          adims(1) = size(MLSAuxData%VerticalCoordinates)
          allocate(attr_data(adims(1)),STAT=status)
          call test_allocate ( status, ModuleName, 'attr_data' )

          do i=1,adims(1)
             attr_data(i) = MLSAuxData%VerticalCoordinates(i)
          end do
       case ('Dimensions')
          arank = 1
          atype_id = H5T_NATIVE_CHARACTER
          is_char  = .true.
          adims(1) = size(MLSAuxData%Dimensions)
          allocate(char_data(adims(1)),STAT=status)
          call test_allocate ( status, ModuleName, 'char_data' )
          do i=1,adims(1)
             char_data(i) = trim(MLSAuxData%Dimensions(i))
          end do
       case default
          error = 1
          return
       end select
    case (OPTARGISARR)
       arank = 1
       adims(1) = size(AttributeData)
       allocate(attr_data(adims(1)),STAT=status)
       call test_allocate ( status, ModuleName, 'attr_data' )

       do i=1,adims(1)
          attr_data(i) = AttributeData(i)
       end do
    case default
       error = 1
       return
    end select

    adims_create(1) = adims(1)                                         
    call h5screate_simple_f(arank, adims_create(1:arank), aspace_id, h5error)  
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_CREATE // trim(AttributeName) // ' in ' // & 
         trim(MLSAuxData%name) )

    if (is_char) then 

       attrlen = 20 

       CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, h5error)
       IF (h5error /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_TYPE_COPY // trim(AttributeName) // ' in ' // &
            trim(MLSAuxData%name))

       CALL h5tset_size_f(atype_id, int(attrlen, size_t), h5error)
       IF (h5error /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_TYPE_SET // trim(AttributeName) // ' in ' // &
            trim(MLSAuxData%name))

       call h5acreate_f(dset_id, trim(AttributeName), atype_id, &         
            & aspace_id, attr_id, h5error)                                   
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_ATT_CREATE // trim(AttributeName) // ' in ' // &
            trim(MLSAuxData%name) )

       call h5awrite_f(attr_id, atype_id, char_data, adims, h5error)      
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_ATT_WRITE // trim(AttributeName) // ' in ' // &
            trim(MLSAuxData%name) )

    else

       call h5acreate_f(dset_id, trim(AttributeName), atype_id, &         
            & aspace_id, attr_id, h5error)                                   
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_ATT_CREATE // trim(AttributeName) // ' in ' // &
            trim(MLSAuxData%name) )

       call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)      
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_ATT_WRITE // trim(AttributeName) // ' in ' // &
            trim(MLSAuxData%name) )

    end if

    call h5aclose_f(attr_id, h5error)                                  
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_ATT_CLOSE // trim(AttributeName) // ' in ' // &
         trim(MLSAuxData%name) )

    call h5sclose_f(aspace_id, h5error)                                
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_CLOSE // trim(AttributeName) // ' in ' // & 
         trim(MLSAuxData%name) )

    if (allocated(attr_data)) then 
       deallocate(attr_data,STAT=status)
       call test_deallocate ( status, moduleName, 'attr_data' )
    end if

    if (allocated(char_data)) then 
       deallocate(char_data,STAT=status)
       call test_deallocate ( status, moduleName, 'char_data' )
    end if

  end subroutine Write_MLSAuxAttributes
  !-------------------------------------------------Read_MLSAuxData ----
  subroutine Read_MLSAuxData(file_id, QuantityName, QuantityType, & 
       MLSAuxData, error, read_attributes, FirstIndex, LastIndex)

    ! This subroutine reads an entry from the HDF5 file.

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    type( MLSAuxData_T ), intent(inout) :: MLSAuxData
    character(len=*), intent(in)   :: QuantityName
    character(len=*), intent(in)   :: QuantityType ! if 'unknown' will derive
    integer(hid_t), intent(in)     :: file_id ! From HDF
    integer, intent(out)           :: error   ! 0 unless trouble
    integer, intent(in), optional  :: FirstIndex, LastIndex
    logical, intent(in), optional  :: read_attributes  ! read freqCoords, etc 
!
    !-------------------------------------------------------------------------
!
    character, dimension(:,:,:), allocatable :: character_buffer
    character(len=16) :: myQuantityType
!
    real, dimension(:,:,:), allocatable :: real_buffer, double_buffer
!
    integer, dimension(:,:,:), allocatable :: integer_buffer
    integer(hsize_t), dimension(7) :: dims
    integer(hsize_t), dimension(3) :: chunk_dims, dims_create, maxdims, start
    integer(hid_t) :: cparms, dset_id, dspace_id, type_id, memspace
    integer        :: rank, h5error, i, status
!
    logical :: myRead_attributes, is_integer, is_real, is_double, & 
         is_character, is_int32, is_float32, is_float64
!
    error = 0
    myRead_attributes = .false.
    dims = 1
    if ( present(read_attributes) ) myRead_attributes=read_attributes
    !-- assign name and type for dataset

    MLSAuxData%name = trim(QuantityName)
    MLSAuxData%type_name = trim(QuantityType)

    call h5dopen_f(file_id,trim(QuantityName),dset_id,h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_OPEN // trim(MLSAuxData%name) )

    call h5dget_space_f(dset_id,dspace_id,h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_GETSPACE // trim(MLSAuxData%name) )

    call h5sget_simple_extent_ndims_f(dspace_id,rank,h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_GET_NDIMS // trim(MLSAuxData%name) )

    MLSAuxData%rank = rank

    call h5sget_simple_extent_dims_f(dspace_id,dims_create(1:rank),&
         maxdims(1:rank),h5error)
    if (h5error /= rank) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_GET_DIMS // trim(MLSAuxData%name) )

    call h5dget_create_plist_f(dset_id,cparms,h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_CREATE // trim(MLSAuxData%name) )

    call h5pget_chunk_f(cparms,rank,chunk_dims(1:rank),h5error)
    if (h5error /= rank) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_PROPERTY_CHUNK_GET // trim(MLSAuxData%name) )

    call h5screate_simple_f(rank, dims_create(1:rank), memspace, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name) )

    call h5dget_type_f(dset_id, type_id, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_GET_TYPE // trim(MLSAuxData%name) )

    if ( lowercase(trim(QuantityType)) /= 'unknown' ) then
       myQuantityType = QuantityType
    else

       is_integer = .FALSE.
       is_real = .FALSE.
       is_double = .FALSE.
       is_int32 = .FALSE.
       is_float32 = .FALSE.
       is_float64 = .FALSE.
       is_character = .FALSE.

       call h5tequal_f(type_id, H5T_NATIVE_INTEGER, is_integer, h5error)
       call h5tequal_f(type_id, H5T_STD_I32LE, is_int32, h5error)
       call h5tequal_f(type_id, H5T_NATIVE_CHARACTER, is_character, h5error)
       call h5tequal_f(type_id, H5T_NATIVE_REAL, is_real, h5error)
       call h5tequal_f(type_id, H5T_IEEE_F32LE, is_float32, h5error)
       call h5tequal_f(type_id, H5T_IEEE_F64LE, is_float64, h5error)
       call h5tequal_f(type_id, H5T_NATIVE_DOUBLE, is_double, h5error)

       ! Please add any new or compound datatypes here.

       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
            H5_ERROR_TYPE_EQUAL // trim(MLSAuxData%name) )

       if ( is_integer .or. is_int32 ) then
          myQuantityType = 'integer'
       else if ( is_real .or. is_float32 ) then
          myQuantityType = 'real'
       else if ( is_double .or. is_float64 ) then
          myQuantityType = 'double'
       else if ( is_character ) then
          myQuantityType = 'character'
       else
          error = 1
          return
       end if

    end if

    do i = 1, 7
       if (i .le. rank) then 
          dims(i) = dims_create(i) 
       else
          dims(i) = 0
       end if
    end do

    do i = 1, rank
       start(i) = 0
    end do

    call h5sselect_hyperslab_f(memspace, H5S_SELECT_SET_F, &
         start(1:rank), dims_create(1:rank), h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_HYPERSLAB // trim(MLSAuxData%name) )

    ! based on type chose which h5dread to call.

    if ( .NOT.(PRESENT(FirstIndex) ) ) then 

       test_type: select case (trim(myQuantityType))
       case ('real')
          call h5dread_f(dset_id,type_id,MLSAuxData%RealField,dims,& 
               h5error, memspace,dspace_id)
       case ('double')    
          call h5dread_f(dset_id,type_id,MLSAuxData%DpField,dims,&
               h5error,memspace,dspace_id)
       case ('integer')  
          call h5dread_f(dset_id,type_id,MLSAuxData%IntField,dims,& 
               h5error,memspace,dspace_id)
       case ('character') 
          call h5dread_f(dset_id,type_id,MLSAuxData%CharField,dims,&
               h5error,memspace,dspace_id)
       end select test_type

    else

       test_type_dims: select case (trim(myQuantityType))
       case ('real')
          allocate( real_buffer(dims(1),dims(2),dims(3)),stat=status)
          call test_allocate ( status, ModuleName, 'real_buffer' )

          call h5dread_f(dset_id,type_id,& 
               real_buffer,dims,h5error, memspace, dspace_id)

          MLSAuxData%RealField(1:dims(1),1:dims(2),firstIndex:lastIndex) = &
            & real_buffer(1:dims(1),1:dims(2),firstIndex:lastIndex)

          if (allocated(real_buffer)) then 
             deallocate(real_buffer, stat=status)
             call test_deallocate ( status, ModuleName, 'real_buffer' )
          end if

       case ('double')    

          allocate( double_buffer(dims(1),dims(2),dims(3)),stat=status)
          call test_allocate ( status, ModuleName, 'double_buffer' )

          call h5dread_f(dset_id,type_id,& 
               double_buffer,dims,h5error, memspace, dspace_id)

          MLSAuxData%DpField(1:dims(1),1:dims(2),firstIndex:lastIndex) = &
            & double_buffer(1:dims(1),1:dims(2),firstIndex:lastIndex)

          if (allocated(double_buffer)) then 
             deallocate(double_buffer, stat=status)
             call test_deallocate ( status, ModuleName, 'double_buffer' )
          end if

       case ('integer')  
          allocate( integer_buffer(dims(1),dims(2),dims(3)),stat=status)
          call test_allocate ( status, ModuleName, 'integer_buffer' )

          call h5dread_f(dset_id,type_id,& 
               integer_buffer,dims,h5error, memspace, dspace_id)

          MLSAuxData%IntField(1:dims(1),1:dims(2),firstIndex:lastIndex) = &
            & integer_buffer(1:dims(1),1:dims(2),firstIndex:lastIndex)

          if (allocated(integer_buffer)) then 
             deallocate(integer_buffer, stat=status)
             call test_deallocate ( status, ModuleName, 'integer_buffer' )
          end if

       case ('character') 
          allocate( character_buffer(dims(1),dims(2),dims(3)),stat=status)
          call test_allocate ( status, ModuleName, 'character_buffer' )

          call h5dread_f(dset_id,type_id,& 
               character_buffer,dims,h5error, memspace, dspace_id)

          MLSAuxData%CharField(1:dims(1),1:dims(2),firstIndex:lastIndex) = &
            & character_buffer(1:dims(1),1:dims(2),firstIndex:lastIndex)

          if (allocated(character_buffer)) then 
             deallocate(character_buffer, stat=status)
             call test_deallocate ( status, ModuleName, 'character_buffer' )
          end if

       end select test_type_dims

    end if

    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_READ // trim(MLSAuxData%name) )

    ! Do we also read the attributes
    if ( myRead_attributes ) then
       call Read_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
            & 'FrequencyCoordinates', h5error, MLSAuxData)
       call Read_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
            & 'HorizontalCoordinates', h5error, MLSAuxData)
       call Read_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
            & 'VerticalCoordinates', h5error, MLSAuxData)
       call Read_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
            & 'Dimensions', h5error, MLSAuxData)
    end if
!
    ! Close all identifiers.
!
    call h5sclose_f(memspace, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )

    call h5sclose_f(dspace_id, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )

    call h5dclose_f(dset_id, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_CLOSE // trim(MLSAuxData%name) )

    call h5pclose_f(cparms, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_PROPERTY_CLOSE // trim(MLSAuxData%name) )

  end subroutine Read_MLSAuxData
! -------------------------------------------------  Write_MLSAuxData ----
  subroutine Write_MLSAuxData (file_id, MLSAuxData, error, &
       & write_attributes, string_length, index, fill_value_r, fill_value_d, &
       fill_value_i)
!
! This routine assumes that the MLSAuxData dataset is created.
! This subroutine writes an entry to the HDF5 file.
!
    type( MLSAuxData_T ), intent(in) :: MLSAuxData
    integer(hid_t), intent(in)     :: file_id ! From HDF
    integer, intent(out)           :: error   ! 0 unless trouble
    integer, intent(in), optional  :: index ! number of major frames
    logical, intent(in), optional  :: write_attributes ! write freqCoords, etc 
    integer, intent(in), optional  :: string_length ! length of string  
    real, intent(in), optional     :: fill_value_r    ! value to use for filling
    real(r8), intent(in), optional :: fill_value_d    ! value to use for filling
    integer, intent(in), optional  :: fill_value_i    ! value to use for filling
!-------------------------------------------------------------------------
! Internal variables.
!
    character(len=1), dimension(:), pointer :: char_data => NULL()
    real, dimension(:), pointer :: attr_data => NULL()
    integer(hsize_t), dimension(7) :: dims
    integer(hsize_t), dimension(3) :: chunk_dims, dims_create, maxdims, start
    integer(hsize_t), dimension(3) :: dims_file
    integer(hid_t) :: cparms,dspace_id,dset_id,type_id, &
         filespace, memspace, s_type_id 
    integer :: i, rank, h5error
    logical :: myWrite_attributes
    !--------------------------------------------------------------------------
      call switchOutput( 'stdout' )
    error = 0
    myWrite_attributes = .false.
    if ( present(write_attributes) ) myWrite_attributes=write_attributes

    nullify (char_data, attr_data)
    dims = 1
    test_type: select case (trim(MLSAuxData%type_name))

    case ('real')
       if (associated(MLSAuxData%RealField)) then 
          rank = MLSAuxData%rank
          type_id = H5T_IEEE_F32LE
          if (present(index)) then 
             do i=1,rank-1
                dims(i) = size(MLSAuxData%RealField, i)
                chunk_dims(i) = dims(i)
                dims_create(i) = dims(i)
                maxdims(i) = dims(i)
             end do
             dims(rank) = 1
             chunk_dims(rank) = 1
             dims_create(rank) = 1
             maxdims(rank) = H5S_UNLIMITED_F
          else
             do i=1,rank
                dims(i) = size(MLSAuxData%RealField, i)
                chunk_dims(i) = dims(i)
                dims_create(i) = dims(i)
                maxdims(i) = dims(i)
             end do
          end if
       end if

    case ('double')
       if (associated(MLSAuxData%DpField)) then 
          rank = MLSAuxData%rank
          type_id = H5T_NATIVE_DOUBLE
          if (present(index)) then 
             do i=1,rank-1
                dims(i) = size(MLSAuxData%DpField, i)
                chunk_dims(i) = dims(i)
                dims_create(i) = dims(i)
                maxdims(i) = dims(i)
             end do
             dims(rank) = 1
             chunk_dims(rank) = 1
             dims_create(rank) = 1
             maxdims(rank) = H5S_UNLIMITED_F
          else
             do i=1,rank
                dims(i) = size(MLSAuxData%DpField, i)
                chunk_dims(i) = dims(i)
                dims_create(i) = dims(i)
                maxdims(i) = dims(i)
             end do
          end if
       end if
    case ('integer')

       if (associated(MLSAuxData%IntField)) then 
          rank = MLSAuxData%rank
          type_id = H5T_NATIVE_INTEGER
          if (present(index)) then 
             do i=1,rank-1
                dims(i) = size(MLSAuxData%IntField, i)
                chunk_dims(i) = dims(i)
                dims_create(i) = dims(i)
                maxdims(i) = dims(i)
             end do
             dims(rank) = 1
             chunk_dims(rank) = 1
             dims_create(rank) = 1
             maxdims(rank) = H5S_UNLIMITED_F
          else
             do i=1,rank
                dims(i) = size(MLSAuxData%IntField, i)
                chunk_dims(i) = dims(i)
                dims_create(i) = dims(i)
                maxdims(i) = dims(i)
             end do
          end if
       end if

    case ('character')
       if (associated(MLSAuxData%CharField)) then 
          rank = MLSAuxData%rank
          type_id = H5T_NATIVE_CHARACTER
          if (present (index) ) then 
             do i=1, rank-1
                dims(i) = 1
                chunk_dims(i) = dims(i)
                dims_create(i) = dims(i)
                maxdims(i) = dims(i)
             end do
             dims(rank) = 1
             chunk_dims(rank) = 1
             dims_create(rank) = 1
             maxdims(rank) = H5S_UNLIMITED_F
          else
             do i=1,rank
                dims(i) = size(MLSAuxData%CharField, i)
                chunk_dims(i) = dims(i)
                dims_create(i) = dims(i)
                maxdims(i) = dims(i)
             end do
          end if
       end if
    end select test_type

    call h5eset_auto_f(0, h5error)
    call h5dopen_f(file_id, trim(MLSAuxData%name), dset_id, h5error)

    if (h5error /= 0) then 

       if ( MLSAuxData%name == 'R1A:118.B22D:PT.S0.DACS-4 precision'  .and. DEBUG ) then
         print *, 'The dataset doesnt exist yet--must create it', h5error, dset_id
       end if
       call h5eset_auto_f(1, h5error)
!--------------------------------------------------------------------
       call h5screate_simple_f (rank, dims_create(1:rank), &
            dspace_id,h5error, maxdims(1:rank))
       if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
            ModuleName, H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name))

       call h5pcreate_f (H5P_DATASET_CREATE_F,cparms,h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, &
            H5_ERROR_PROPERTY_CREATE // trim(MLSAuxData%name))

       call h5pset_chunk_f (cparms,rank,chunk_dims(1:rank),h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, &
            H5_ERROR_PROPERTY_CHUNK_SET // trim(MLSAuxData%name) )

       IF (PRESENT (fill_value_r)) THEN
          CALL H5pSet_Fill_Value_f (cparms, type_id, fill_value_r, h5error)
          IF (h5error /= 0) CALL MLSMessage (MLSMSG_Error, &
               ModuleName, "Fill value " // TRIM (MLSAuxData%name))
       end if

       IF (PRESENT (fill_value_d)) THEN
          CALL H5pSet_Fill_Value_f (cparms, type_id, fill_value_d, h5error)
          IF (h5error /= 0) CALL MLSMessage (MLSMSG_Error, &
               ModuleName, "Fill value " // TRIM (MLSAuxData%name))
       end if

       IF (PRESENT (fill_value_i)) THEN
          CALL H5pSet_Fill_Value_f (cparms, type_id, fill_value_i, h5error)
          IF (h5error /= 0) CALL MLSMessage (MLSMSG_Error, &
               ModuleName, "Fill value " // TRIM (MLSAuxData%name))
       end if

       if (trim(MLSAuxData%type_name)/='character') then

          call h5dcreate_f (file_id, trim(MLSAuxData%name), &
               type_id, dspace_id, dset_id, h5error, cparms)
          if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
               ModuleName, H5_ERROR_DSET_CREATE // trim(MLSAuxData%name))

       else

          call h5tcopy_f (type_id, s_type_id, h5error)
          if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
               ModuleName, H5_ERROR_TYPE_COPY // trim(MLSAuxData%name))

          call h5tset_size_f (s_type_id, int(string_length, size_t), h5error)
          IF (h5error /= 0) CALL MLSMessage (MLSMSG_Error, &
               ModuleName, H5_ERROR_TYPE_SET//trim(MLSAuxData%name))

          CALL h5dcreate_f (file_id, trim(MLSAuxData%name), &
               s_type_id, dspace_id, dset_id, h5error, cparms)
          IF (h5error /= 0) CALL MLSMessage (MLSMSG_Error, &
               ModuleName, H5_ERROR_DSET_CREATE // trim(MLSAuxData%name))

       end if
!---------------- close all structures----------------------------------
       call h5sclose_f (dspace_id, h5error )
       if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
            ModuleName, H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name))

       call h5pclose_f (cparms, h5error)
       if (h5error /= 0) call MLSMessage (MLSMSG_Error, &
            ModuleName, H5_ERROR_PROPERTY_CLOSE // trim(MLSAuxData%name))

    end if

    if (associated(MLSAuxData%RealField)) then

       rank = MLSAuxData%rank

       do i=1,rank
          dims_create(i) = size(MLSAuxData%RealField,i)
          dims(i) = dims_create(i)
          chunk_dims(i) = dims(i)
       end do
    end if

    if (associated(MLSAuxData%DpField)) then 

       rank = MLSAuxData%rank

       do i=1,rank
          dims_create(i) = size(MLSAuxData%DpField,i)
          dims(i) = dims_create(i)
          chunk_dims(i) = dims(i)
       end do
    end if

    if (associated(MLSAuxData%CharField)) then 

       rank = MLSAuxData%rank

       do i=1,rank
          dims_create(i) = 1
          dims(i) = 1
          chunk_dims(i) = 1
       end do

    end if

    if (associated(MLSAuxData%IntField)) then 

       rank = MLSAuxData%rank

       do i=1,rank
          dims_create(i) = size(MLSAuxData%IntField,i)
          dims(i) = dims_create(i)
          chunk_dims(i) = dims(i)
       end do
    end if

    do i = 1, rank
       start(i) = 0
    end do

    if (PRESENT(index)) then 
       start(rank) = index-1
       dims_create(rank) = index
       dims(rank) = index
       chunk_dims(rank) = index
    end if
    call h5dget_space_f(dset_id, filespace, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_GETSPACE // trim(MLSAuxData%name) )

  ! Wonder what the existing dims are?
    call h5sget_simple_extent_dims_f(filespace, dims_file(1:rank),&
         maxdims(1:rank),h5error)
    if ( MLSAuxData%name == 'R1A:118.B22D:PT.S0.DACS-4 precision' .and. DEBUG ) then
      print *, 'Before call to extend'
      write(*, '(a12, 8I8)') 'start      : ', start(1:rank)
      write(*, '(a12, 8I8)') 'dims       : ', dims(1:rank)
      write(*, '(a12, 8I8)') 'dims_create: ', dims_create(1:rank)
      write(*, '(a12, 8I8)') 'dims_file: ', dims_file(1:rank)
      write(*, '(a12, 8I8)') 'maxdims    : ', maxdims(1:rank)
    end if
    ! call h5dextend_f(dset_id, dims_create, h5error)
    do i=1, rank
      dims_file(i) = max( dims_file(i), dims_create(i) )
    end do
    ! hdf5 1.8 introduced h5dset_extent_f to rplace h5dextend_f
    ! which has been deprecated
    ! Therefore swap comments between the following two statements
    ! when necessary.
    ! call h5dset_extent_f(dset_id, dims_file, h5error)
    call h5dextend_f(dset_id, dims_file, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_EXTEND // trim(MLSAuxData%name) )

    call h5dget_space_f(dset_id, filespace, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_GETSPACE // trim(MLSAuxData%name) )

  ! Wonder what the existing dims are?
    call h5sget_simple_extent_dims_f(filespace, dims_file(1:rank),&
         maxdims(1:rank),h5error)
    if ( MLSAuxData%name == 'R1A:118.B22D:PT.S0.DACS-4 precision'  .and. DEBUG ) then
      print *, 'After dextend'
      write(*, '(a12, 8I8)') 'dims_file: ', dims_file(1:rank)
      write(*, '(a12, 8I8)') 'maxdims    : ', maxdims(1:rank)
    end if

    call h5dget_type_f(dset_id, type_id, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_GET_TYPE // trim(MLSAuxData%name) )

    dims_create(rank)=1

    call h5screate_simple_f (rank, dims_create(1:rank), memspace, h5error)
    if (h5error /= 0) call MLSMessage (MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name))

  ! Wonder what the existing dims are?
    call h5sget_simple_extent_dims_f(filespace, dims_file(1:rank),&
         maxdims(1:rank),h5error)
    if ( MLSAuxData%name == 'R1A:118.B22D:PT.S0.DACS-4 precision' .and. DEBUG ) then
      print *, 'Before hyperslab'
      write(*, '(a12, 8I8)') 'dims_file: ', dims_file(1:rank)
      write(*, '(a12, 8I8)') 'maxdims    : ', maxdims(1:rank)
    end if
    call h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, start(1:rank), &
         dims_create(1:rank), h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_HYPERSLAB // trim(MLSAuxData%name) )

    test_type_name: select case (trim(MLSAuxData%type_name))

    case ('real')
       call h5dwrite_f(dset_id, type_id, MLSAuxData%RealField, &
            dims(1:rank), h5error, memspace, filespace)
    case ('double')
       call h5dwrite_f (dset_id, type_id, MLSAuxData%DpField, &
            dims(1:rank), h5error, memspace, filespace)
    case ('integer')
       call h5dwrite_f (dset_id, type_id, MLSAuxData%IntField, &
            dims(1:rank), h5error, memspace, filespace)
    case('character')
       call h5tcopy_f (type_id, s_type_id, h5error)
       IF (h5error /= 0) call MLSMessage (MLSMSG_Error, &
            ModuleName, H5_ERROR_TYPE_COPY // trim(MLSAuxData%name))
       
       call h5tset_size_f (s_type_id, int(string_length, size_t), h5error)
       IF (h5error /= 0) call MLSMessage (MLSMSG_Error, &
            ModuleName, H5_ERROR_TYPE_SET // trim(MLSAuxData%name))

       call h5dwrite_f (dset_id, s_type_id, MLSAuxData%CharField, & 
            dims(1:rank), h5error, memspace, filespace)
  
    end select test_type_name

    if (h5error /= 0) call MLSMessage (MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_WRITE // trim(MLSAuxData%name))

! Do we also write the attributes
    if ( myWrite_attributes ) then
       if (associated(MLSAuxData%FrequencyCoordinates)) & 
            call Write_MLSAuxAttributes (dset_id, &
            trim(MLSAuxData%name), 'FrequencyCoordinates', error, MLSAuxData)
       if (associated(MLSAuxData%HorizontalCoordinates)) & 
            call Write_MLSAuxAttributes (dset_id, &
            trim(MLSAuxData%name), 'HorizontalCoordinates', error, MLSAuxData)
       if (associated(MLSAuxData%VerticalCoordinates)) & 
            call Write_MLSAuxAttributes (dset_id, &
            trim(MLSAuxData%name), 'VerticalCoordinates', error, MLSAuxData)
       if (associated(MLSAuxData%Dimensions)) & 
            call Write_MLSAuxAttributes (dset_id, &
            trim(MLSAuxData%name), 'Dimensions', error, MLSAuxData)
    end if

!
! Close all identifiers.
!
    call h5sclose_f(filespace, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )

    call h5sclose_f(memspace, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )

    call h5dclose_f(dset_id, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
         H5_ERROR_DSET_CLOSE // trim(MLSAuxData%name) )

    if ( MLSAuxData%name == 'R1A:118.B22D:PT.S0.DACS-4 precision' .and. DEBUG ) then
      print *, 'After closing all the identifiers'
      write(*, '(a12, 8I8)') 'start      : ', start(1:rank)
      write(*, '(a12, 8I8)') 'dims       : ', dims(1:rank)
      write(*, '(a12, 8I8)') 'dims_create: ', dims_create(1:rank)
      write(*, '(a12, 8I8)') 'maxdims    : ', maxdims(1:rank)
      print *, '(reopening dspace)'
      call h5dopen_f(file_id, trim(MLSAuxData%name), dset_id, h5error)
      call h5dget_space_f(dset_id,dspace_id,h5error)
      call h5sget_simple_extent_ndims_f(dspace_id,rank,h5error)
      call h5sget_simple_extent_dims_f(dspace_id,dims_create(1:rank),&
           maxdims(1:rank),h5error)
      write(*, '(a12, 8I8)') 'dims_create: ', dims_create(1:rank)
      write(*, '(a12, 8I8)') 'maxdims    : ', maxdims(1:rank)
      call h5dclose_f(dset_id, h5error)
    end if
    call revertOutput
  end subroutine Write_MLSAuxData

  subroutine CopyFromDataProducts( dataset, MLSAuxData )
    ! It's unclear to me what the original developer's vision for this
    ! subroutine is. However, since the name of the subroutine is "Copy,"
    ! it is reasonable to assume that the fields Dimensions,
    ! FrequencyCoordinates, VerticalCoordinates, and HorizontalCoordinates
    ! of MLSAuxData will be identical to those of dataset once this
    ! subroutine finishes given that it does not violate the constraints
    ! of MLSAuxData's data type. In addition, since it does not conflict with
    ! the current use of this subroutine, I will mandate that this 
    ! subroutine will allocate those fields for MLSAuxData. This means
    ! that before this subroutine is called, MLSAuxData should not
    ! have those fields allocated, otherwise, the program will stop to
    ! avoid memory leak.
    ! Concerning this subroutine, MLSAuxData_T type has one constraint
    ! that dictates the size of MLSAuxData%Dimensions to be equal to 
    ! the value of MLSAuxData%rank. I'm not aware of constraints regarding
    ! FrequencyCoordinates, VerticalCoordinates, or HorizontalCoordinates.
    ! -haley n-
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type( MLSAuxData_T ), intent(inout) :: MLSAuxData
    type( DataProducts_T ), intent(in) :: dataset
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: i, status, length

    if (associated(MLSAuxData%Dimensions)) &
      call MLSMessage(MLSMSG_Error, ModuleName, & 
         'MLSAuxData%Dimensions is already allocated. ' &
         // 'Quitting to avoid memory leak.')

    if (associated(MLSAuxData%FrequencyCoordinates)) &
      call MLSMessage(MLSMSG_Error, ModuleName, &
         'MLSAuxData%FrequencyCoordinates is already allocated. ' &
         // 'Quitting to avoid memory leak.')

    if (associated(MLSAuxData%VerticalCoordinates)) &
      call MLSMessage(MLSMSG_Error, ModuleName, &
         'MLSAuxData%VerticalCoordinates is already allocated. ' &
         // 'Quitting to avoid memory leak.')

    if (associated(MLSAuxData%HorizontalCoordinates)) &
      call MLSMessage(MLSMSG_Error, ModuleName, &
         'MLSAuxData%HorizontalCoordinates is already allocated. ' &
         // 'Quitting to avoid memory leak.')

    if (associated(dataset%Dimensions)) then 
       allocate(MLSAuxData%Dimensions(MLSAuxData%rank), stat=status)
       addr = 0
       if ( status == 0 ) addr = transfer(c_loc(MLSAuxData%Dimensions(1)), addr)
       call test_allocate ( status, ModuleName, "MLSAuxData%Dimensions", &
         & uBounds = MLSAuxData%rank, &
         & elementSize = storage_size(MLSAuxData%Dimensions ) / 8, address=addr )
       !MLSAuxData%rank should be less than or equal to the size of dataset%Dimensions,
       !but just to be on the safe size, I'll get the min size of the 2. -haley n-
        do i = 1, min(size(dataset%Dimensions), size(MLSAuxData%Dimensions))
           MLSAuxData%Dimensions(i) = trim(dataset%Dimensions(i))
        end do
    end if

    if (associated(dataset%FrequencyCoordinates)) then
       length = size(dataset%FrequencyCoordinates)
       allocate(MLSAuxData%FrequencyCoordinates(length), stat=status)
       addr = 0
       if ( status == 0 ) then
         if ( length>0 ) addr = transfer(c_loc(MLSAuxData%FrequencyCoordinates(1)), addr)
       end if
       call test_allocate ( status, ModuleName, "MLSAuxData%FrequencyCoordinates", &
         & uBounds = length, &
         & elementSize = storage_size(MLSAuxData%FrequencyCoordinates) / 8, &
         & address=addr )
       MLSAuxData%FrequencyCoordinates(1:length) = &
           & dataset%FrequencyCoordinates(1:length)
    end if

    if (associated(dataset%VerticalCoordinates)) then
       length = size(dataset%VerticalCoordinates)
       allocate(MLSAuxData%VerticalCoordinates(length), stat=status)
       addr = 0
       if ( status == 0 ) then
         if ( length>0 ) addr = transfer(c_loc(MLSAuxData%VerticalCoordinates(1)), addr)
       end if
       call test_allocate ( status, ModuleName, "MLSAuxData%VerticalCoordinates", &
         & uBounds = length, &
         & elementSize = storage_size(MLSAuxData%VerticalCoordinates) / 8, &
         & address=addr )
       MLSAuxData%VerticalCoordinates(1:length) = &
           & dataset%VerticalCoordinates(1:length)
    end if

    if (associated(dataset%HorizontalCoordinates)) then
       length = size(dataset%HorizontalCoordinates)
       allocate(MLSAuxData%HorizontalCoordinates(length), stat=status)
       addr = 0
       if ( status == 0 ) then
         if ( length>0 ) addr = transfer(c_loc(MLSAuxData%HorizontalCoordinates(1)), addr)
       end if
       call test_allocate ( status, ModuleName, "MLSAuxData%HorizontalCoordinates", &
         & uBounds = length, &
         & elementSize = storage_size(MLSAuxData%HorizontalCoordinates) / 8 )
       MLSAuxData%HorizontalCoordinates(1:length) = &
           & dataset%HorizontalCoordinates(1:length)
    end if

  end subroutine CopyFromDataProducts

  subroutine CopyToDataProducts( MLSAuxData, dataset )
    type( MLSAuxData_T ), intent(in) :: MLSAuxData
    type( DataProducts_T ), intent(inout) :: dataset
    integer :: i

    if (associated(MLSAuxData%Dimensions) ) then
      do i = 1, size(MLSAuxData%Dimensions)
        dataset%Dimensions(i) = trim(MLSAuxData%Dimensions(i))
      end do
    end if

    if (associated(MLSAuxData%FrequencyCoordinates) ) then
      i = size(MLSAuxData%FrequencyCoordinates)
      dataset%FrequencyCoordinates(1:i) = MLSAuxData%FrequencyCoordinates(1:i)
    end if

    if (associated(MLSAuxData%VerticalCoordinates) ) then
      i = size(MLSAuxData%VerticalCoordinates)
      dataset%VerticalCoordinates(1:i) = MLSAuxData%VerticalCoordinates(1:i)
    end if

    if (associated(MLSAuxData%HorizontalCoordinates) ) then
      i = size(MLSAuxData%HorizontalCoordinates)
      dataset%HorizontalCoordinates(1:i) = MLSAuxData%HorizontalCoordinates(1:i)
    end if

  end subroutine CopyToDataProducts

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSAuxData.f90,v 2.36 2015/04/29 00:52:16 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MLSAuxData

! $Log: MLSAuxData.f90,v $
! Revision 2.36  2015/04/29 00:52:16  vsnyder
! Allocate MLSData%IntField before attempting to compute its address
!
! Revision 2.35  2015/03/28 01:12:53  vsnyder
! Some spiffing.
! Added stuff to trace allocate/deallocate addresses -- mostly commented out
! because NAG build 1017 doesn't yet allow arrays as arguments to C_LOC.
!
! Revision 2.34  2015/01/21 19:27:07  pwagner
! Repaired faulty deallocation
!
! Revision 2.33  2014/09/05 00:00:00  vsnyder
! More complete and accurate allocate/deallocate size tracking.
! Convert some local pointer temps to allocatable.
!
! Revision 2.32  2014/03/07 19:19:24  pwagner
! Name_Len changed to nameLen; got from MLSCommon
!
! Revision 2.31  2010/03/25 18:41:02  pwagner
! args to max function now the same integer type
!
! Revision 2.30  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.29  2009/08/21 19:45:05  pwagner
! Reverse effects of hdf5.1.8 that led to consinsistent noMAFs between datasets
!
! Revision 2.28  2009/07/30 20:43:05  honghanh
! Changed CopyFromDataProduct to create arrays before copying to them
! Add array size checking for Dimensions field in CopyFromDataProduct
!
! Revision 2.27  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.26  2007/04/03 20:51:16  pwagner
! Made dims an assumed-shape array in Build_MLSAuxData
!
! Revision 2.25  2005/06/22 17:25:49  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.24  2004/10/07 18:51:12  perun
! Add new optional argument to control writing attributes
!
! Revision 2.23  2004/09/02 20:45:32  perun
! Added more fill_value types
!
! Revision 2.22  2003/09/03 19:46:30  perun
! Add fill value for Reals
!
! Revision 2.21  2003/01/02 23:14:50  pwagner
! Repaired misplaced ampersand on line 1812
!
! Revision 2.20  2002/12/20 20:45:57  perun
! Added MaxCharFieldLen for MLSAuxData_T
!
! Revision 2.19  2002/12/18 16:24:43  perun
! Remove memory leaks due to nullify
!
! Revision 2.18  2002/12/06 23:38:12  pwagner
! Helpful pre-nullifying of pointers
!
! Revision 2.17  2002/11/25 05:35:35  jdone
! Added dimension names.
!
! Revision 2.16  2002/11/11 19:20:25  jdone
! name in DataProducts_T now has length of 80
!
! Revision 2.15  2002/10/31 22:12:49  jdone
! Added Build_MLSAuxData.
!
! Revision 2.14  2002/10/24 03:19:00  jdone
! subroutine Allocate_MLSAuxData added.
!
! Revision 2.13  2002/10/21 22:10:32  jdone
! inclusion of string types for i/o
!
! Revision 2.12  2002/10/08 00:09:11  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.11  2002/10/05 01:03:08  jdone
! Create_MLSAuxData updated to reduce memory.
!
! Revision 2.10  2002/10/05 00:52:50  jdone
! CreateGroup_MLSAuxData added.
!
! Revision 2.9  2002/10/05 00:30:20  jdone
! Write_MLSAuxData creates & writes dataset if not already created.
!
! Revision 2.8  2002/10/04 22:35:31  jdone
! Added exception handling for h5tequal_f call
!
! Revision 2.7  2002/10/04 22:13:30  jdone
! Replace == for types with h5tequal_f
!
! Revision 2.6  2002/10/03 22:15:37  jdone
! check hdf5 error flags that return rank
!
! Revision 2.5  2002/09/27 23:37:54  pwagner
! More progress toward hdf5-capable l1b files
!
! Revision 2.4  2002/09/26 23:58:04  pwagner
! Moved attributes out of create function; standalone attribute io, too
!
! Revision 2.3  2002/09/09 05:43:39  jdone
! deallocate statements added for read buffers.
!
@


2.36
log
@Allocate MLSData%IntField before attempting to compute its address
@
text
@a231 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d318 1
a318 1
!         addr = transfer(c_loc(MLSData%CharField(1,1,1)), addr)
d356 1
a356 1
!       if ( s > 0 ) addr = transfer(c_loc(MLSAuxData%CharField(1,1,1)), addr)
d408 1
a408 1
!       if ( s > 0 ) addr = transfer(c_loc(MLSAuxData%Dimensions(1)), addr)
d1130 1
a1130 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1170 1
a1170 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1209 1
a1209 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1246 1
a1246 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1297 1
a1297 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1352 1
a1352 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1412 1
a1412 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1467 1
a1467 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1522 1
a1522 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1576 1
a1576 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1631 1
a1631 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1684 1
a1684 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d1739 1
a1739 1
!        if ( status == 0 ) addr = transfer(c_loc(dataset%Dimensions(1)), addr)
d3116 1
a3116 1
!        if ( status == 0 ) addr = transfer(c_loc(MLSAuxData%Dimensions(1)), addr)
d3204 1
a3204 1
       "$Id: MLSAuxData.f90,v 2.35 2015/03/28 01:12:53 vsnyder Exp $"
d3214 3
@


2.35
log
@Some spiffing.
Added stuff to trace allocate/deallocate addresses -- mostly commented out
because NAG build 1017 doesn't yet allow arrays as arguments to C_LOC.
@
text
@d305 1
a309 1
      allocate(MLSData%IntField(dims(1),dims(2),dims(3)), stat=status)
d3205 1
a3205 1
       "$Id: MLSAuxData.f90,v 2.34 2015/01/21 19:27:07 pwagner Exp $"
d3215 5
@


2.34
log
@Repaired faulty deallocation
@
text
@d199 25
a223 25
interface Build_MLSAuxData
  module procedure Build_MLSAuxData_Character
  module procedure Build_MLSAuxData_Double, &
       Build_MLSAuxData_Double_1d, Build_MLSAuxData_Double_2d
  module procedure Build_MLSAuxData_Double_3d
  module procedure Build_MLSAuxData_Real, Build_MLSAuxData_Real_1d, & 
       Build_MLSAuxData_Real_2d
  module procedure Build_MLSAuxData_Real_3d
  module procedure Build_MLSAuxData_Integer, Build_MLSAuxData_Integer_1d, & 
       Build_MLSAuxData_Integer_2d
  module procedure Build_MLSAuxData_Integer_3d
end interface

interface Recall_MLSAuxData
  module procedure Recall_MLSAuxData_Character
  module procedure Recall_MLSAuxData_Double, &
       Recall_MLSAuxData_Double_1d, Recall_MLSAuxData_Double_2d
  module procedure Recall_MLSAuxData_Double_3d
  module procedure Recall_MLSAuxData_Real, Recall_MLSAuxData_Real_1d, & 
       Recall_MLSAuxData_Real_2d
  module procedure Recall_MLSAuxData_Real_3d
  module procedure Recall_MLSAuxData_Integer, Recall_MLSAuxData_Integer_1d, & 
       Recall_MLSAuxData_Integer_2d
  module procedure Recall_MLSAuxData_Integer_3d
end interface
d232 1
d249 1
d252 1
d260 2
d263 1
a263 1
       call test_deallocate ( status, ModuleName, "database", s )
d271 1
d276 1
d282 42
a323 22
    if ( data_type .eq. 'real') then
       allocate(MLSData%RealField(dims(1),dims(2),dims(3)), stat=status)
       call test_allocate ( status, ModuleName, "MLSData%RealField", &
         & uBounds = dims(1:3), elementSize = storage_size(MLSData%RealField) / 8 )
    end if

    if ( data_type .eq. 'double') then
       allocate(MLSData%DpField(dims(1),dims(2),dims(3)), stat=status)
       call test_allocate ( status, ModuleName, "MLSData%DpField", &
         & uBounds = dims(1:3), elementSize = storage_size(MLSData%DpField) / 8 )
    end if

    if ( data_type .eq. 'integer') then
       allocate(MLSData%IntField(dims(1),dims(2),dims(3)), stat=status)
       call test_allocate ( status, ModuleName, "MLSData%IntField", &
         & uBounds = dims(1:3), elementSize = storage_size(MLSData%IntField) / 8 )
    end if

    if ( data_type .eq. 'character') then
       allocate(MLSData%CharField(dims(1),dims(2),dims(3)), stat=status)
       call test_allocate ( status, ModuleName, "MLSData%CharField", &
         & uBounds = dims(1:3), elementSize = storage_size(MLSData%CharField) / 8 )
d331 1
d333 1
d338 2
d342 1
a342 1
        & ' MLSAuxData%RealField in ' // trim(MLSAuxData%name), s )
d347 2
d351 1
a351 1
        & ' MLSAuxData%IntField in ' // trim(MLSAuxData%name), s )
d356 2
d360 1
a360 1
        & ' MLSAuxData%CharField in ' // trim(MLSAuxData%name), s )
d365 2
a366 1
      if ( s < 1 ) return
d369 1
a369 1
        & ' MLSAuxData%DpField in ' // trim(MLSAuxData%name), s )
d375 2
d379 2
a380 1
        & ' MLSAuxData%FrequencyCoordinates in ' // trim(MLSAuxData%name), s )
d386 2
d390 2
a391 1
        & ' MLSAuxData%VerticalCoordinates in ' // trim(MLSAuxData%name), s )
d397 2
d401 2
a402 1
        & ' MLSAuxData%HorizontalCoordinates in ' // trim(MLSAuxData%name), s )
d408 2
d412 1
a412 1
        & ' MLSAuxData%Dimensions in ' // trim(MLSAuxData%name), s )
d431 1
a431 3
    dims(1) = 1
    dims(2) = 1
    dims(3) = 1
d444 1
a444 1
       if (lastIndex .eq. 1) then 
d479 1
a479 3
    dims(1) = 1
    dims(2) = 1
    dims(3) = 1
d493 1
a493 1
       if (lastIndex .eq. 1) then 
d530 1
a530 3
    dims(1) = 1
    dims(2) = 1
    dims(3) = 1
d543 1
a543 1
       if (lastIndex .eq. 1) then 
d576 1
a576 3
    dims(1) = 1
    dims(2) = 1
    dims(3) = 1
d588 1
a588 1
        if (lastIndex .eq. 1) then 
d636 1
a636 3
    do i = 1, dim_array(1)
       MLSData%RealField(i,1,1) = real_data(i) 
    end do
d648 1
a648 1
       if (lastIndex .eq. 1) then 
d697 1
a697 3
    do i = 1, dim_array(1)
       MLSData%DpField(i,1,1) = double_data(i) 
    end do
d709 1
a709 1
       if (lastIndex .eq. 1) then 
d757 1
a757 3
    do i = 1, dim_array(1)
       MLSData%IntField(i,1,1) = integer_data(i) 
    end do
d769 1
a769 1
       if (lastIndex .eq. 1) then 
d801 1
a801 1
    integer :: i,j,error
d817 2
a818 5
    do j = 1, dim_array(2)
       do i = 1, dim_array(1)
          MLSData%RealField(i,j,1) = real_data(i,j) 
       end do
    end do
d833 1
a833 1
       if (lastIndex .eq. 1) then 
d865 1
a865 1
    integer :: i,j,error
d881 2
a882 5
    do j = 1, dim_array(2)
       do i = 1, dim_array(1)
          MLSData%DpField(i,j,1) = double_data(i,j) 
       end do
    end do
d897 1
a897 1
       if (lastIndex .eq. 1) then 
d929 1
a929 1
    integer :: i,j,error
d945 2
a946 5
    do j = 1, dim_array(2)
       do i = 1, dim_array(1)
          MLSData%IntField(i,j,1) = integer_data(i,j) 
       end do
    end do
d958 1
a958 1
       if (lastIndex .eq. 1) then 
d988 1
a988 1
    integer :: i,j,k,error
d1005 2
a1006 7
    do k = 1, dim_array(3)
       do j = 1, dim_array(2)
          do i = 1, dim_array(1)
             MLSData%RealField(i,j,k) = real_data(i,j,k) 
          end do
       end do
    end do
d1032 1
a1032 1
    integer :: i,j,k,error
d1049 2
a1050 7
    do k = 1, dim_array(3)
       do j = 1, dim_array(2)
          do i = 1, dim_array(1)
             MLSData%DpField(i,j,k) = double_data(i,j,k) 
          end do
       end do
    end do
d1074 1
a1074 1
    integer :: i,j,k,error
d1091 2
a1092 7
    do k = 1, dim_array(3)
       do j = 1, dim_array(2)
          do i = 1, dim_array(1)
             MLSData%IntField(i,j,k) = integer_data(i,j,k) 
          end do
       end do
    end do
d1106 1
d1113 1
d1117 1
a1117 3
    dims(1) = 1
    dims(2) = 1
    dims(3) = 1
d1126 1
a1126 1
    if (error .eq. 0) then 
d1130 2
d1133 2
a1134 1
         & ubounds = 1, elementSize = storage_size(dataset%Dimensions) / 8 )
d1147 1
d1153 1
d1157 1
a1157 3
    dims(1) = 1
    dims(2) = 1
    dims(3) = 1
d1166 1
a1166 1
    if (error .eq. 0) then 
d1170 2
d1173 2
a1174 1
         & ubounds = 1, elementSize = storage_size(dataset%Dimensions) / 8 )
d1187 1
d1193 1
d1197 1
a1197 3
    dims(1) = 1
    dims(2) = 1
    dims(3) = 1
d1205 1
a1205 1
    if (error .eq. 0) then 
d1209 2
d1212 2
a1213 1
         & ubounds = 1, elementSize = storage_size(dataset%Dimensions) / 8 )
d1225 1
d1231 1
d1235 1
a1235 3
    dims(1) = 1
    dims(2) = 1
    dims(3) = 1
d1243 1
a1243 1
    if (error .eq. 0) then 
d1246 2
d1249 2
a1250 1
         & ubounds = 1, elementSize = storage_size(dataset%Dimensions) / 8 )
d1263 1
d1270 1
d1274 1
a1274 3
    do i=1,3
       dim_array(i) = 1
    end do
d1277 1
a1277 1
       dim_array(i) = size(real_data,i)
d1286 1
a1286 1
    if (error .eq. 0) then
d1297 2
d1301 1
a1301 1
         & elementSize = storage_size(dataset%Dimensions) / 8 )
d1304 1
a1304 3
       do i = i_first, i_last
          real_data(i) = MLSData%RealField(i,1,1)  
       end do
d1317 1
d1324 1
d1328 1
a1328 3
    do i=1,3
       dim_array(i) = 1
    end do
d1341 1
a1341 1
    if (error /= 0) then 
d1352 2
d1356 1
a1356 1
         & elementSize = storage_size(dataset%Dimensions) / 8 )
d1375 1
d1382 1
d1386 1
a1386 3
    do i=1,3
       dim_array(i) = 1
    end do
d1399 1
a1399 1
    if (error .eq. 0) then
d1412 2
d1416 1
a1416 1
         & elementSize = storage_size(dataset%Dimensions) / 8 )
d1430 1
d1437 1
d1439 3
a1441 1
    integer :: i,j,error,status,j_first,j_last
a1442 3
    do i=1,3
       dim_array(i) = 1
    end do
d1453 1
a1453 1
    if (error .eq. 0) then 
d1463 2
a1464 5
       do j = j_first, j_last
          do i = 1, dim_array(1)
             real_data(i,j) = MLSData%RealField(i,j,1) 
          end do
       end do
d1467 2
d1471 1
a1471 1
         & elementSize = storage_size(dataset%Dimensions) / 8 )
d1485 1
d1492 1
d1494 3
a1496 1
    integer :: i,j,error,status,j_first,j_last
a1497 3
    do i=1,3
       dim_array(i) = 1
    end do
d1508 1
a1508 1
    if (error .eq. 0) then
d1518 2
a1519 5
       do j = j_first, j_last
          do i = 1, dim_array(1)
             double_data(i,j) = MLSData%DpField(i,j,1) 
          end do
       end do
d1522 2
d1526 1
a1526 1
         & elementSize = storage_size(dataset%Dimensions) / 8 )
d1539 1
d1546 1
d1548 3
a1550 1
    integer :: i,j,error, status,j_first, j_last
a1551 3
    do i=1,3
       dim_array(i) = 1
    end do
d1562 1
a1562 1
    if (error .eq. 0) then
d1572 2
a1573 5
       do j = j_first, j_last
          do i = 1, dim_array(1)
             integer_data(i,j) = MLSData%IntField(i,j,1)  
          end do
       end do
d1576 2
d1580 1
a1580 1
         & elementSize = storage_size(dataset%Dimensions) / 8 )
d1593 1
d1601 4
a1604 1
    integer :: i,j,k,error, status,k_first, k_last
a1605 3
    do i=1,3
       dim_array(i) = 1
    end do
d1617 1
a1617 1
    if (error .eq. 0) then
d1627 2
a1628 7
       do k = k_first, k_last
          do j = 1, dim_array(2)
             do i = 1, dim_array(1)
                real_data(i,j,k) = MLSData%RealField(i,j,k)  
             end do
          end do
       end do
d1631 2
d1634 2
a1635 1
         & ubounds = 3, elementSize = storage_size(dataset%Dimensions) / 8 )
d1648 1
d1655 1
d1657 3
a1659 1
    integer :: i,j,k,error, status,k_first, k_last
a1660 3
    do i=1,3
       dim_array(i) = 1
    end do
d1670 1
a1670 1
    if (error .eq. 0) then
d1680 2
a1681 7
       do k = k_first, k_last
          do j = 1, dim_array(2)
             do i = 1, dim_array(1)
                double_data(i,j,k) = MLSData%DpField(i,j,k) 
             end do
          end do
       end do
d1684 2
d1687 2
a1688 1
         & ubounds = 3, elementSize = storage_size(dataset%Dimensions) / 8 )
d1700 1
d1707 1
d1709 3
a1711 1
    integer :: i,j,k,error,status,k_first, k_last
a1712 3
    do i=1,3
       dim_array(i) = 1
    end do
d1723 1
a1723 1
    if (error .eq. 0) then
d1732 1
a1732 1
!
d1734 3
a1736 8
!
       do k = k_first, k_last
          do j = 1, dim_array(2)
             do i = 1, dim_array(1)
                integer_data(i,j,k) = MLSData%IntField(i,j,k)  
             end do
          end do
       end do
d1739 2
d1742 2
a1743 1
         & ubounds = 3, elementSize = storage_size(dataset%Dimensions) / 8 )
d1890 1
a1890 1
                if (trim(MLSAuxData%type_name).ne.'character') then
d2430 1
a2430 1
    integer        :: rank, h5error, i, j, k, status
d2565 2
a2566 7
          do k = FirstIndex, LastIndex
             do j = 1, dims(2)
                do i = 1, dims(1)
                   MLSAuxData%RealField(i,j,k) = real_buffer(i,j,k)
                end do
             end do
          end do
d2580 3
a2582 7
          do k = FirstIndex, LastIndex
             do j = 1, dims(2)
                do i = 1, dims(1)
                   MLSAuxData%DpField(i,j,k) = double_buffer(i,j,k)
                end do
             end do
          end do
d2595 3
a2597 7
          do k = FirstIndex, LastIndex
             do j = 1, dims(2)
                do i = 1, dims(1)
                   MLSAuxData%IntField(i,j,k) = integer_buffer(i,j,k)
                end do
             end do
          end do
d2610 3
a2612 7
          do k = FirstIndex, LastIndex
             do j = 1, dims(2)
                do i = 1, dims(1)
                   MLSAuxData%CharField(i,j,k) = character_buffer(i,j,k)
                end do
             end do
          end do
d2838 1
a2838 1
       if (trim(MLSAuxData%type_name).ne.'character') then
d3088 1
d3091 1
d3116 2
d3120 1
a3120 1
         & elementSize = storage_size(MLSAuxData%Dimensions ) / 8 )
d3131 4
d3137 4
a3140 5
         & elementSize = storage_size(MLSAuxData%FrequencyCoordinates) / 8 )
       do i = 1, length
         MLSAuxData%FrequencyCoordinates(i) = &
           & dataset%FrequencyCoordinates(i)
       end do
d3146 4
d3152 4
a3155 5
         & elementSize = storage_size(MLSAuxData%VerticalCoordinates) / 8 )
       do i = 1, length
         MLSAuxData%VerticalCoordinates(i) = &
           & dataset%VerticalCoordinates(i)
       end do
d3160 5
a3164 1
       allocate(MLSAuxData%HorizontalCoordinates(length), stat=status) 
d3168 2
a3169 4
       do i = 1, length
         MLSAuxData%HorizontalCoordinates(i) = &
           & dataset%HorizontalCoordinates(i)
       end do
d3180 13
a3192 4
       do i = 1, size(MLSAuxData%Dimensions)
          dataset%Dimensions(i) = '                    '
          dataset%Dimensions(i) = trim(MLSAuxData%Dimensions(i))
       end do
d3195 3
a3197 16
    if (associated(MLSAuxData%FrequencyCoordinates) ) then 
       do i = 1, size(MLSAuxData%FrequencyCoordinates)
          dataset%FrequencyCoordinates(i) = MLSAuxData%FrequencyCoordinates(i)
       end do 
    end if

    if (associated(MLSAuxData%VerticalCoordinates) ) then 
       do i = 1, size(MLSAuxData%VerticalCoordinates)
          dataset%VerticalCoordinates(i) = MLSAuxData%VerticalCoordinates(i)
       end do 
    end if

    if (associated(MLSAuxData%HorizontalCoordinates) ) then 
       do i = 1, size(MLSAuxData%HorizontalCoordinates)
        dataset%HorizontalCoordinates(i) = MLSAuxData%HorizontalCoordinates(i)
       end do 
d3205 1
a3205 1
       "$Id: MLSAuxData.f90,v 2.33 2014/09/05 00:00:00 vsnyder Exp $"
d3215 3
@


2.33
log
@More complete and accurate allocate/deallocate size tracking.
Convert some local pointer temps to allocatable.
@
text
@d32 1
d330 2
a331 1
      deallocate(MLSAuxData%CharField, stat=status)
d2682 1
a2688 5
    if ( MLSAuxData%name == 'R1A:118.B22D:PT.S0.DACS-4 precision'  .and. DEBUG ) then
      print *, 'Write_MLSAuxData: ', trim(MLSAuxData%type_name)
      write(*, '(a12, 8I8)') 'rank: ', MLSAuxData%rank
      if ( present(index) ) write(*, '(a12, 8I8)') 'index: ', index
    end if
d3061 1
d3192 1
a3192 1
       "$Id: MLSAuxData.f90,v 2.32 2014/03/07 19:19:24 pwagner Exp $"
d3202 4
@


2.32
log
@Name_Len changed to nameLen; got from MLSCommon
@
text
@d31 1
a31 2
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_DEALLOCATE, &
       MLSMSG_ALLOCATE
d229 2
d246 1
d249 1
a249 1
    integer :: index, status
d255 1
d257 1
a257 2
       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_DeAllocate // "database" )
d264 1
a268 1
    character(len=480) :: msr
d276 3
a278 5
       if ( status /= 0 ) then
          msr = MLSMSG_allocate // ' MLSAuxData%RealField in ' // name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d282 3
a284 5
       if ( status /= 0 ) then
          msr = MLSMSG_allocate // ' MLSAuxData%DpField in ' // name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d288 3
a290 5
       if ( status /= 0 ) then
          msr = MLSMSG_allocate // ' MLSAuxData%IntField in ' // name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d294 3
a296 5
       if ( status /= 0 ) then
          msr = MLSMSG_allocate // ' MLSAuxData%CharField in ' // name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d302 1
d304 1
a304 2
    character(len=480) :: msr
    integer :: status
d307 5
a311 7
       deallocate(MLSAuxData%RealField, stat=status)
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate // ' MLSAuxData%RealField in ' // & 
               MLSAuxData%name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d314 5
a318 7
       deallocate(MLSAuxData%IntField, stat=status)
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate // ' MLSAuxData%IntField in ' // &
               MLSAuxData%name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d321 5
a325 7
       deallocate(MLSAuxData%CharField, stat=status)
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate // ' MLSAuxData%CharField in ' // &
               MLSAuxData%name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d328 5
a332 7
       deallocate(MLSAuxData%DpField, stat=status)
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate // ' MLSAuxData%DpField in ' // &
               MLSAuxData%name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d335 6
a340 7
       deallocate(MLSAuxData%FrequencyCoordinates, stat=status)
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate // ' MLSAuxData%FrequencyCoordinates in ' // &
               MLSAuxData%name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d343 6
a348 7
       deallocate(MLSAuxData%VerticalCoordinates, stat=status)
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate // ' MLSAuxData%VerticalCoordinates in ' // &
               MLSAuxData%name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d351 6
a356 7
       deallocate(MLSAuxData%HorizontalCoordinates, stat=status)
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate//' MLSAuxData%HorizontalCoordinates in '// &
               MLSAuxData%name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d359 6
a364 7
       deallocate(MLSAuxData%Dimensions, stat=status)
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate // ' MLSAuxData%Dimensions in ' // &
               MLSAuxData%name
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d402 2
a403 2
          endif
       endif
d411 1
a411 1
    endif
d453 2
a454 2
          endif
       endif
d463 1
a463 1
    endif
d505 2
a506 2
          endif
       endif
d512 1
a512 1
    endif
d552 2
a553 2
          endif
       endif
d560 1
a560 1
    endif
d588 2
a589 2
       enddo
    endif
d597 1
a597 1
    enddo
d603 1
a603 1
    endif
d614 2
a615 2
          endif
       endif
d622 1
a622 1
    endif
d651 2
a652 2
       enddo
    endif
d660 1
a660 1
    enddo
d666 1
a666 1
    endif
d677 2
a678 2
          endif
       endif
d685 1
a685 1
    endif
d713 2
a714 2
       enddo
    endif
d722 1
a722 1
    enddo
d728 1
a728 1
    endif
d739 2
a740 2
          endif
       endif
d747 1
a747 1
    endif
d775 2
a776 2
       enddo
    endif
d785 2
a786 2
       enddo
    enddo
d792 1
a792 1
    endif
d798 1
a798 1
    endif
d806 2
a807 2
          endif
       endif
d814 1
a814 1
    endif
d842 2
a843 2
       enddo
    endif
d852 2
a853 2
       enddo
    enddo
d859 1
a859 1
    endif
d865 1
a865 1
    endif
d873 2
a874 2
          endif
       endif
d881 1
a881 1
    endif
d909 2
a910 2
       enddo
    endif
d919 2
a920 2
       enddo
    enddo
d926 1
a926 1
    endif
d937 2
a938 2
          endif
       endif
d945 1
a945 1
    endif
d970 2
a971 2
       enddo
    endif
d983 3
a985 3
          enddo
       enddo
    enddo
d991 1
a991 1
    endif
d1019 2
a1020 2
       enddo
    endif
d1032 3
a1034 3
          enddo
       enddo
    enddo
d1039 1
a1039 1
    endif
d1066 2
a1067 2
       enddo
    endif
d1079 3
a1081 3
          enddo
       enddo
    enddo
d1094 1
d1119 2
d1126 1
a1126 1
    endif
d1132 1
d1156 2
d1163 1
a1163 1
    endif
d1169 1
d1192 2
d1199 1
a1199 1
    endif
d1204 1
d1226 2
d1232 1
a1232 1
    endif
d1239 1
d1251 1
a1251 1
    enddo
d1255 1
a1255 1
    enddo
d1271 1
a1271 1
       endif
d1274 3
d1281 1
a1281 1
       enddo
d1286 1
a1286 1
    endif
d1293 1
d1305 1
a1305 1
    enddo
d1309 1
a1309 1
    enddo
d1326 1
a1326 1
       endif
d1329 3
d1336 1
a1336 1
       enddo
d1342 1
a1342 1
    endif
d1349 1
d1361 1
a1361 1
    enddo
d1365 1
a1365 1
    enddo
d1381 1
a1381 1
       endif
d1384 1
a1384 1
       enddo
d1387 3
d1395 1
a1395 1
    endif
d1402 1
d1414 1
a1414 1
    enddo
d1417 1
a1417 1
    enddo
d1433 1
a1433 1
       endif
d1438 2
a1439 2
          enddo
       enddo
d1442 3
d1450 1
a1450 1
    endif
d1457 1
d1469 1
a1469 1
    enddo
d1472 1
a1472 1
    enddo
d1488 1
a1488 1
       endif
d1493 2
a1494 2
          enddo
       enddo
d1497 3
d1505 1
a1505 1
    endif
d1511 1
d1523 1
a1523 1
    enddo
d1526 1
a1526 1
    enddo
d1542 1
a1542 1
       endif
d1547 2
a1548 2
          enddo
       enddo
d1551 3
d1559 1
a1559 1
    endif
d1565 1
d1577 1
a1577 1
    enddo
d1580 1
a1580 1
    enddo
d1597 1
a1597 1
       endif
d1603 3
a1605 3
             enddo
          enddo
       enddo
d1608 2
d1615 1
a1615 1
    endif
d1621 1
d1633 1
a1633 1
    enddo
d1636 1
a1636 1
    enddo
d1651 1
a1651 1
       endif
d1657 3
a1659 3
             enddo
          enddo
       enddo
d1662 2
d1668 1
a1668 1
    endif
d1674 1
d1686 1
a1686 1
    enddo
d1689 1
a1689 1
    enddo
d1705 1
a1705 1
       endif
d1713 3
a1715 3
             enddo
          enddo
       enddo
d1718 2
d1724 1
a1724 1
    endif
d1769 1
a1769 1
    endif
d1775 2
a1776 1
!
d1780 1
a1780 1
!
a1787 1
    character(len=480) :: msr
d1789 1
a1789 1
    real, dimension(:), pointer :: attr_data => NULL()
d1797 1
a1797 1
    nullify(attr_data)
d1824 1
a1824 1
             endif
d1837 1
a1837 1
                endif
d1850 1
a1850 1
                   endif
d1889 1
a1889 1
                endif
d1910 1
a1910 4
                         if ( status /= 0 ) then
                            msr = MLSMSG_Allocate// ' attr_data.'
                            call MLSMessage(MLSMSG_Error, ModuleName, msr)
                         endif
d1946 2
a1947 5
                         deallocate (attr_data,STAT=status)
                         if (status /= 0) then
                            msr = MLSMSG_deallocate// ' attr_data.'
                            call MLSMessage(MLSMSG_Error, ModuleName, msr)
                         endif
d1949 1
a1949 1
                      endif
d1958 1
a1958 4
                         if ( status /= 0 ) then
                            msr = MLSMSG_allocate// ' attr_data.'
                            call MLSMessage(MLSMSG_Error, ModuleName, msr)
                         endif
d1993 2
a1994 5
                         deallocate (attr_data,STAT=status)
                         if (status /= 0) then
                            msr = MLSMSG_deallocate// ' attr_data.'
                            call MLSMessage (MLSMSG_Error, ModuleName, msr)
                         endif
d1996 1
a1996 1
                      endif
d2005 1
a2005 4
                         if ( status /= 0 ) then
                            msr = MLSMSG_allocate// ' attr_data.'
                            call MLSMessage(MLSMSG_Error, ModuleName, msr)
                         endif
d2041 4
a2044 7
                         if ( status /= 0 ) then
                            msr = MLSMSG_deallocate// ' attr_data.'
                            call MLSMessage(MLSMSG_Error, ModuleName, msr)
                         endif
                      endif
                   endif
                endif
d2070 1
d2078 2
a2079 3
    character(len=480) :: msr
    character, dimension(:), pointer :: char_data => NULL()
    real, dimension(:), pointer :: attr_data => NULL()
a2090 1
    nullify(char_data, attr_data)
d2108 1
a2108 1
          endif
d2116 1
a2116 1
          endif
d2124 1
a2124 1
          endif
d2132 1
a2132 1
             enddo
d2136 1
a2136 1
          endif
d2160 1
a2160 4
       if ( status /= 0 ) then
          msr = MLSMSG_allocate// ' char_data.'
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d2170 1
a2170 4
       if ( status /= 0 ) then
          msr = MLSMSG_allocate// ' attr_data.'
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d2177 1
a2177 1
    endif
d2206 1
a2206 1
    if (associated(attr_data)) then 
d2208 2
a2209 5
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate// ' attr_data.'
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d2211 1
a2211 1
    if (associated(char_data)) then      
d2213 2
a2214 5
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate// ' char_data.'
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d2220 2
a2221 1
!
d2235 2
a2236 3
    character(len=480) :: msr
    character(len=20), dimension(:), pointer :: char_data => NULL()
    real, dimension(:), pointer :: attr_data => NULL()
a2248 1
    nullify(char_data, attr_data)
d2262 1
a2262 4
          if ( status /= 0 ) then
             msr = MLSMSG_allocate// ' attr_data.'
             call MLSMessage(MLSMSG_Error, ModuleName, msr)
          endif
d2271 1
a2271 4
          if ( status /= 0 ) then
             msr = MLSMSG_allocate// ' attr_data.'
             call MLSMessage(MLSMSG_Error, ModuleName, msr)
          endif
d2280 1
a2280 4
          if ( status /= 0 ) then
             msr = MLSMSG_allocate// ' attr_data.'
             call MLSMessage(MLSMSG_Error, ModuleName, msr)
          endif
d2291 1
a2291 4
          if ( status /= 0 ) then
             msr = MLSMSG_allocate// ' char_data.'
             call MLSMessage(MLSMSG_Error, ModuleName, msr)
          endif
d2303 1
a2303 4
       if ( status /= 0 ) then
          msr = MLSMSG_allocate // ' attr_data.'
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d2357 1
a2357 1
    endif
d2369 1
a2369 1
    if (associated(attr_data)) then 
d2371 2
a2372 5
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate// ' attr_data.'
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d2374 1
a2374 1
    if (associated(char_data)) then 
d2376 2
a2377 5
       if ( status /= 0 ) then
          msr = MLSMSG_deallocate// ' char_data.'
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
    endif
d2383 1
a2383 1
!
d2385 2
a2386 1
!
d2397 1
a2397 2
    character, dimension(:,:,:), pointer :: character_buffer => NULL()
    character(len=480) :: msr
d2400 1
a2400 1
    real, dimension(:,:,:), pointer :: real_buffer, double_buffer
d2402 1
a2402 1
    integer, dimension(:,:,:), pointer :: integer_buffer => NULL()
a2412 1
    nullify (character_buffer, real_buffer, double_buffer, integer_buffer)
d2482 1
a2482 1
       elseif ( is_real .or. is_float32 ) then
d2484 1
a2484 1
       elseif ( is_double .or. is_float64 ) then
d2486 1
a2486 1
       elseif ( is_character ) then
d2491 1
a2491 1
       endif
d2493 1
a2493 1
    endif
d2500 1
a2500 1
       endif
d2536 1
a2536 4
          if ( status /= 0 ) then
             msr = MLSMSG_allocate // ' real_buffer.'
             call MLSMessage(MLSMSG_Error, ModuleName, msr)
          endif
d2549 1
a2549 1
          if (associated(real_buffer)) then 
d2551 2
a2552 7

             if ( status /= 0 ) then
                msr = MLSMSG_deallocate // ' real_buffer.'  
                call MLSMessage(MLSMSG_Error, ModuleName, msr)
             endif

          endif
d2557 1
a2557 4
          if ( status /= 0 ) then
             msr = MLSMSG_allocate // ' double_buffer'
             call MLSMessage(MLSMSG_Error, ModuleName, msr)
          endif
d2569 1
a2569 1
          if (associated(double_buffer)) then 
d2571 2
a2572 7

             if ( status /= 0 ) then
                msr = MLSMSG_deallocate // ' double_buffer.' 
                call MLSMessage(MLSMSG_Error, ModuleName, msr)
             endif

          endif
d2576 1
a2576 4
          if ( status /= 0 ) then
             msr = MLSMSG_deallocate // ' integer_buffer'  
             call MLSMessage(MLSMSG_Error, ModuleName, msr)
          endif
d2588 1
a2588 1
          if (associated(integer_buffer)) then 
d2590 2
a2591 5
             if ( status /= 0 ) then
                msr = MLSMSG_deallocate // ' integer_buffer.' 
                call MLSMessage(MLSMSG_Error, ModuleName, msr)
             endif
          endif
d2595 1
a2595 5

          if ( status /= 0 ) then
             msr = MLSMSG_allocate // ' character_buffer.' 
             call MLSMessage(MLSMSG_Error, ModuleName, msr)
          endif
d2607 1
a2607 1
          if (associated(character_buffer)) then 
d2609 2
a2610 7

             if ( status /= 0 ) then
                msr = MLSMSG_deallocate // ' character_buffer.' 
                call MLSMessage(MLSMSG_Error, ModuleName, msr)
             endif

          endif
d2614 1
a2614 1
    endif
d2629 1
a2629 1
    endif
d2690 1
a2690 1
    endif
d2715 2
a2716 2
          endif
       endif
d2740 2
a2741 2
          endif
       endif
d2764 3
a2766 3
             enddo
          endif
       endif
d2789 3
a2791 3
             enddo
          endif
       endif
d2801 1
a2801 1
       endif
d2821 1
a2821 1
       ENDIF
d2827 1
a2827 1
       ENDIF
d2833 1
a2833 1
       ENDIF
d2857 1
a2857 1
       endif
d2867 1
a2867 1
    endif
d2878 1
a2878 1
    endif
d2889 1
a2889 1
    endif
d2901 1
a2901 1
    endif
d2912 1
a2912 1
    endif
d2923 1
a2923 1
    endif
d2938 1
a2938 1
    endif
d2942 1
a2942 1
    enddo
d2963 1
a2963 1
    endif
d2982 1
a2982 1
    endif
d3030 1
a3030 1
    endif
d3062 1
a3062 1
    endif
d3083 1
a3086 1
    character(len=20) :: routineName = "CopyFromDataProducts"
d3109 4
a3112 1
       allocate(MLSAuxData%Dimensions(MLSAuxData%rank), stat=status) 
d3115 4
a3118 9
       if (status == 0) then
          do i = 1, min(size(dataset%Dimensions), size(MLSAuxData%Dimensions))
             MLSAuxData%Dimensions(i) = trim(dataset%Dimensions(i))
          end do
       else
          call MLSMessage(MLSMSG_Error, ModuleName, "In " // routineName &
               // ": cannot allocate MLSAuxData%Dimensions.")
       endif
    endif
d3123 8
a3130 10
       if (status == 0) then
          do i = 1, length
             MLSAuxData%FrequencyCoordinates(i) = &
                  dataset%FrequencyCoordinates(i)
          enddo
       else
          call MLSMessage(MLSMSG_Error, ModuleName, "In " // routineName &
               // ": cannot allocate MLSAuxData%FrequencyCoordinates.")
       endif
    endif
d3135 8
a3142 10
       if (status == 0) then 
          do i = 1, length
             MLSAuxData%VerticalCoordinates(i) = &
                  dataset%VerticalCoordinates(i)
          enddo
       else
          call MLSMessage(MLSMSG_Error, ModuleName, "In " // routineName &
               // ": cannot allocate MLSAuxData%VerticalCoordinates.")
       endif 
    endif
d3147 8
a3154 10
       if (status == 0) then
          do i = 1, length
             MLSAuxData%HorizontalCoordinates(i) = &
                  dataset%HorizontalCoordinates(i)
          enddo
       else
          call MLSMessage(MLSMSG_Error, ModuleName, "In " // routineName &
               // ": cannot allocate MLSAuxData%HorizontalCoordinates.")
       endif
    endif
d3168 1
a3168 1
    endif
d3173 2
a3174 2
       enddo 
    endif
d3179 2
a3180 2
       enddo 
    endif
d3185 2
a3186 2
       enddo 
    endif
d3193 1
a3193 1
       "$Id: MLSAuxData.f90,v 2.31 2010/03/25 18:41:02 pwagner Exp $"
d3203 3
@


2.31
log
@args to max function now the same integer type
@
text
@d15 2
a16 2
  use MLS_DataProducts, only: DataProducts_T
  use HDF5, only: hid_t, hsize_t, H5T_NATIVE_CHARACTER, H5T_NATIVE_DOUBLE, &
d19 14
a32 13
       h5dopen_f, h5dclose_f, h5screate_simple_f, h5pcreate_f, h5dcreate_f, &
       h5pset_chunk_f, h5sclose_f, h5dget_space_f, h5pclose_f, & 
       h5sget_simple_extent_ndims_f, h5sget_simple_extent_dims_f, &
       h5dget_create_plist_f, h5pget_chunk_f, h5dget_type_f, & 
       h5sselect_hyperslab_f, h5dread_f, h5dwrite_f, h5dextend_f, &
       h5acreate_f, h5awrite_f, h5aread_f, h5aclose_f, h5tcopy_f, &
       h5tset_size_f, h5aopen_name_f, h5aget_space_f, &
       h5tequal_f, h5eset_auto_f, h5gcreate_f, h5gclose_f, &
       h5gopen_f, h5pset_fill_value_f, size_t
  use MLSCommon, only: r4, r8
  use MLSStrings, only: Lowercase
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_Error, MLSMSG_deallocate, &
       MLSMSG_allocate
a40 1
! NAME_LEN                       Max length of l1b/l2 sds array name
d82 1
a82 1
  public :: name_len, MLSAuxData_T, Create_MLSAuxData, Read_MLSAuxData, & 
a93 1
  integer, parameter :: name_len = 64  ! Max len of SDS array name
d97 1
a97 1
    character (len=name_len) :: name, type_name  
d1761 1
a1761 1
    character(len=name_len) :: aname
d2730 1
a2730 1
    integer(hsize_t), dimension(7) :: adims, dims
a2743 1
    adims = 1
d3259 1
a3259 1
       "$Id: MLSAuxData.f90,v 2.30 2010/02/04 23:08:00 vsnyder Exp $"
d3269 3
@


2.30
log
@Remove USE or declaration for unused names
@
text
@d27 1
a27 1
       h5gopen_f, h5pset_fill_value_f
d1853 1
a1853 1
                   call h5tset_size_f(s_type_id, string_length, h5error)
d2349 1
a2349 1
       CALL h5tset_size_f(atype_id, attrlen, h5error)
d2908 1
a2908 1
          call h5tset_size_f (s_type_id, string_length, h5error)
d3064 1
a3064 1
       call h5tset_size_f (s_type_id, string_length, h5error)
d3261 1
a3261 1
       "$Id: MLSAuxData.f90,v 2.29 2009/08/21 19:45:05 pwagner Exp $"
d3271 3
@


2.29
log
@Reverse effects of hdf5.1.8 that led to consinsistent noMAFs between datasets
@
text
@d15 1
a15 1
  use MLS_DataProducts, only: Deallocate_DataProducts, DataProducts_T
d25 2
a26 2
       h5tset_size_f, h5aopen_name_f, h5aget_type_f, h5aget_space_f, &
       h5tequal_f, h5fis_hdf5_f, h5eset_auto_f, h5gcreate_f, h5gclose_f, &
d398 1
a398 1
    integer :: error, status
d448 1
a448 1
    integer :: error, status
d501 1
a501 1
    integer :: error, status
d549 1
a549 1
    integer :: error, status
d598 1
a598 1
    integer :: i,error, status
d661 1
a661 1
    integer :: i,error, status
d723 1
a723 1
    integer :: i,j,error, status
d785 1
a785 1
    integer :: i,j,k,error, status
d852 1
a852 1
    integer :: i,j,error, status
d919 1
a919 1
    integer :: i,j,error, status
d981 1
a981 1
    integer :: i,j,k,error, status
d1030 1
a1030 1
    integer :: i,j,k,error, status
d1077 1
a1077 1
    integer :: i,j,k,error, status
d1115 1
a1115 1
    integer, intent(inout) :: char_length
d1355 1
a1355 1
    integer :: i,j,error,status,i_first,i_last
d1404 1
a1404 1
    integer :: i,j,k,error,status,j_first,j_last
a2728 2
    character(len=480) :: msr
    character(len=name_len) :: aname
a2733 1
    integer(hsize_t), dimension(1) :: adims_create
d2735 2
a2736 2
         attr_id, atype_id, aspace_id, filespace, memspace, s_type_id 
    integer :: i, rank, arank, h5error, status
d3261 1
a3261 1
       "$Id: MLSAuxData.f90,v 2.28 2009/07/30 20:43:05 honghanh Exp $"
d3271 3
@


2.28
log
@Changed CopyFromDataProduct to create arrays before copying to them
Add array size checking for Dimensions field in CopyFromDataProduct
@
text
@d198 2
d815 3
d882 3
d1008 4
d1056 3
d2735 1
d2749 5
a2753 1

d2862 3
d2987 3
d2991 21
a3011 1
    call h5dextend_f(dset_id, dims_create, h5error)
d3019 9
d3038 8
d3110 16
d3264 1
a3264 1
       "$Id: MLSAuxData.f90,v 2.27 2009/06/23 18:25:42 pwagner Exp $"
d3274 4
@


2.27
log
@Prevent Intel from optimizing ident string away
@
text
@d89 1
a89 1
       "$RCSfile: $"
a409 2
    allocate(MLSData%Dimensions(1), stat=status)

a460 1
    allocate(MLSData%Dimensions(1), stat=status)
d512 1
a512 1
    allocate(MLSData%Dimensions(1), stat=status)
a559 2

    allocate(MLSData%Dimensions(1), stat=status)
a621 1
    allocate(MLSData%Dimensions(MLSData%rank), stat=status)
d643 1
a684 1
    allocate(MLSData%Dimensions(MLSData%rank), stat=status)
a746 1
    allocate(MLSData%Dimensions(MLSData%rank), stat=status)
a810 1
    allocate(MLSData%Dimensions(MLSData%rank), stat=status)
a862 1

a874 1
    allocate(MLSData%Dimensions(MLSData%rank), stat=status)
a938 1
    allocate(MLSData%Dimensions(MLSData%rank), stat=status)
a997 1
    allocate(MLSData%Dimensions(3), stat=status)
a1042 1
    allocate(MLSData%Dimensions(3), stat=status)
a1086 1
    allocate(MLSData%Dimensions(3), stat=status)
d2318 1
a2725 1

d2733 1
a2837 1

d3031 1
d3050 17
d3069 2
a3070 1
    integer :: i
d3072 32
a3103 5
    if (associated(dataset%Dimensions) ) then 
       do i = 1, size(dataset%Dimensions)
          MLSAuxData%Dimensions(i) = '                    '
          MLSAuxData%Dimensions(i) = trim(dataset%Dimensions(i))
       end do
d3106 12
a3117 5
    if (associated(dataset%FrequencyCoordinates) ) then 
       do i = 1, size(dataset%FrequencyCoordinates)
          MLSAuxData%FrequencyCoordinates(i) = &
               dataset%FrequencyCoordinates(i)
       enddo
d3120 12
a3131 5
    if (associated(dataset%VerticalCoordinates) ) then 
       do i = 1, size(dataset%VerticalCoordinates)
          MLSAuxData%VerticalCoordinates(i) = &
               dataset%VerticalCoordinates(i)
       enddo
d3134 12
a3145 5
    if (associated(dataset%HorizontalCoordinates) ) then 
       do i = 1, size(dataset%HorizontalCoordinates)
          MLSAuxData%HorizontalCoordinates(i) = &
               dataset%HorizontalCoordinates(i)
       enddo
d3185 1
a3185 1
       "$Id: read_apriori.f90 is it here $"
d3195 3
@


2.26
log
@Made dims an assumed-shape array in Build_MLSAuxData
@
text
@d89 1
a89 1
       "$RCSfile: MLSAuxData.f90,v $"
d3129 1
a3130 1
!---------------------------- RCS Ident Info -------------------------------
d3132 2
a3133 3
       "$Id: MLSAuxData.f90,v 2.25 2005/06/22 17:25:49 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d3135 1
d3137 1
d3142 3
@


2.25
log
@Reworded Copyright statement, moved rcs id
@
text
@d89 1
a89 1
       "$RCSfile: $"
d593 1
a593 1
    integer, dimension(3), intent(in), optional :: dims
d604 3
a606 4
    if (present(dims) ) then        
       do i=1,3
          dim_array(i) = dims(i)
       enddo
a607 3
       do i=1,3
          dim_array(i) = 1
       enddo
d656 1
a656 1
    integer, dimension(3), intent(in), optional :: dims
d667 3
a669 4
    if (present(dims) ) then        
       do i=1,3
          dim_array(i) = dims(i)
       enddo
a670 3
       do i=1,3
          dim_array(i) = 1
       enddo
d719 1
a719 1
    integer, dimension(3), intent(in), optional :: dims
d730 3
a732 4
    if (present(dims) ) then        
       do i=1,3
          dim_array(i) = dims(i)
       enddo
a733 3
       do i=1,3
          dim_array(i) = 1
       enddo
d782 1
a782 1
    integer, dimension(3), intent(in), optional :: dims
d793 3
a795 4
    if (present(dims) ) then        
       do i=1,3
          dim_array(i) = dims(i)
       enddo
a796 3
       do i=1,3
          dim_array(i) = 1
       enddo
d847 1
a847 1
    integer, dimension(3), intent(in), optional :: dims
d858 3
a860 4
    if (present(dims) ) then 
       do i=1,3
          dim_array(i) = dims(i)
       enddo
a861 3
       do i=1,3
          dim_array(i) = 1
       enddo
d913 1
a913 1
    integer, dimension(3), intent(in), optional :: dims
d924 3
a926 4
    if (present(dims) ) then 
       do i=1,3
          dim_array(i) = dims(i)
       enddo
a927 3
       do i=1,3
          dim_array(i) = 1
       enddo
d978 1
a978 1
    integer, dimension(3), intent(in), optional :: dims
d986 3
a988 4
    if (present(dims) ) then 
       do i=1,3
          dim_array(i) = dims(i)
       enddo
a989 3
       do i=1,3
          dim_array(i) = 1
       enddo
d1024 1
a1024 1
    integer, dimension(3), intent(in), optional :: dims
d1032 3
a1034 4
    if (present(dims) ) then 
       do i=1,3
          dim_array(i) = dims(i)
       enddo
a1035 3
       do i=1,3
          dim_array(i) = 1
       enddo
d1069 1
a1069 1
    integer, dimension(3), intent(in), optional :: dims
d1077 3
a1079 4
    if (present(dims) ) then 
       do i=1,3
          dim_array(i) = dims(i)
       enddo
a1080 3
       do i=1,3
          dim_array(i) = 1
       enddo
d3132 1
a3132 1
       "$Id: $"
d3141 3
@


2.24
log
@Add new optional argument to control writing attributes
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d87 1
a87 4
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
    "$Id: MLSAuxData.f90,v 2.23 2004/09/02 20:45:32 perun Exp $"
  character (len=len(idParm)), private :: Id = idParm
d89 1
a89 1
    "$RCSfile: MLSAuxData.f90,v $"
d91 1
a91 1
  !---------------------------------------------------------------------------
d3166 5
d3177 3
@


2.23
log
@Added more fill_value types
@
text
@d81 1
a81 1
    "$Id: MLSAuxData.f90,v 2.22 2003/09/03 19:46:30 perun Exp $"
d381 1
a381 1
      char_length, lastIndex)
d386 1
d392 1
d409 1
d412 5
a416 7
          call Write_MLSAuxData(file_id, MLSData, error, & 
               write_attributes=.true., & 
               string_length=char_length, index=lastIndex)
       else
          call Write_MLSAuxData(file_id, MLSData, error, & 
               write_attributes=.false., & 
               string_length=char_length, index=lastIndex)
d418 3
d433 1
a433 1
      lastIndex, fill_value)
d439 1
d444 1
d461 1
d463 6
a468 9

       if (lastIndex .eq. 1) then
          call Write_MLSAuxData(file_id, MLSData, error, &
               write_attributes=.true., &  
               index=lastIndex, fill_value_i=fill_value)
       else
          call Write_MLSAuxData(file_id, MLSData, error, &
               write_attributes=.false., &  
               index=lastIndex, fill_value_i=fill_value)
d470 3
d487 1
a487 1
      fill_value)
d493 1
d498 1
d513 1
d516 8
a523 2
          call Write_MLSAuxData (file_id, MLSData, error, &
               write_attributes=.true., index=lastIndex, &
a524 5
       else
          call Write_MLSAuxData (file_id, MLSData, error, &
               write_attributes=.false., index=lastIndex, &
               fill_value_r=fill_value)
       endif
d535 1
a535 1
      fill_value)
d541 1
d546 1
d562 1
d564 6
a569 6
       if (lastIndex .eq. 1) then 
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.true., fill_value_d=fill_value)
       else
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.false., fill_value_d=fill_value)
d571 4
a574 1
    else
d585 1
a585 1
      dims, fill_value)
d592 1
d597 1
d629 1
d632 5
a636 5
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.true., fill_value_r=fill_value)
       else
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.false., fill_value_r=fill_value)
d638 3
d652 1
a652 1
      lastIndex, dims, fill_value)
d659 1
d664 1
d696 2
a697 1
    if ( present (lastIndex) ) then 
d699 5
a703 5
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.true., fill_value_d=fill_value)
       else 
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.false., fill_value_d=fill_value)
d705 3
d719 1
a719 1
      lastIndex, dims, fill_value)
d726 1
d731 1
d763 2
a764 1
    if (present (lastIndex) ) then
d766 5
a770 5
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.true., fill_value_i=fill_value)
       else
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.false., fill_value_i=fill_value)
d772 3
d786 1
a786 1
      dims, fill_value)
d793 1
d798 1
d832 1
d835 5
a839 5
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.true., fill_value_r=fill_value)
       else
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.false., fill_value_r=fill_value)
d841 3
d855 1
a855 1
      lastIndex, dims, fill_value)
d862 1
d867 1
d902 1
d905 5
a909 5
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.true., fill_value_d=fill_value)
       else
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.false., fill_value_d=fill_value)
d911 3
d925 1
a925 1
      lastIndex, dims, fill_value)
d932 1
d937 1
d971 1
d974 5
a978 5
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.true., fill_value_i=fill_value)
       else
          call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
               write_attributes=.false., fill_value_i=fill_value)
d980 3
d3167 3
@


2.22
log
@Add fill value for Reals
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d81 1
a81 1
    "$Id: MLSAuxData.f90,v 2.21 2003/01/02 23:14:50 pwagner Exp $"
d429 1
a429 1
      lastIndex)
d434 1
d460 1
a460 1
               index=lastIndex)
d464 1
a464 1
               index=lastIndex)
d469 1
a469 1
            write_attributes=.true.)
d507 2
a508 1
               write_attributes=.true., index=lastIndex, fill_value=fill_value)
d511 2
a512 1
               write_attributes=.false., index=lastIndex, fill_value=fill_value)
d515 1
a515 1
       call Write_MLSAuxData (file_id, MLSData, error, fill_value=fill_value)
d523 2
a524 1
 subroutine Build_MLSAuxData_Double( file_id, dataset, double_data, lastIndex)
d529 1
d552 1
a552 1
               write_attributes=.true.)
d555 1
a555 1
               write_attributes=.false.)
d559 1
a559 1
            write_attributes=.true.)
d613 1
a613 1
               write_attributes=.true., fill_value=fill_value)
d616 1
a616 1
               write_attributes=.false., fill_value=fill_value)
d620 1
a620 1
            write_attributes=.true., fill_value=fill_value) 
d629 1
a629 1
      lastIndex, dims)
d635 1
d674 1
a674 1
               write_attributes=.true.)
d677 1
a677 1
               write_attributes=.false.)
d681 1
a681 1
            write_attributes=.true.)
d690 1
a690 1
      lastIndex, dims)
d696 1
d735 1
a735 1
               write_attributes=.true.)
d738 1
a738 1
               write_attributes=.false.)
d742 1
a742 1
            write_attributes=.true.)
d798 1
a798 1
               write_attributes=.true., fill_value=fill_value)
d801 1
a801 1
               write_attributes=.false., fill_value=fill_value)
d805 1
a805 1
            write_attributes=.true., fill_value=fill_value)
d814 1
a814 1
      lastIndex, dims)
d820 1
d862 1
a862 1
               write_attributes=.true.)
d865 1
a865 1
               write_attributes=.false.)
d869 1
a869 1
            write_attributes=.true.)
d878 1
a878 1
      lastIndex, dims)
d884 1
d925 1
a925 1
               write_attributes=.true.)
d928 1
a928 1
               write_attributes=.false.)
d932 1
a932 1
            write_attributes=.true.)
d983 1
a983 1
         fill_value=fill_value)
d991 1
a991 1
      dims)
d996 1
d1032 2
a1033 1
    call Write_MLSAuxData(file_id, MLSData, error,write_attributes=.true.)
d1039 2
a1040 1
 subroutine Build_MLSAuxData_Integer_3d(file_id,dataset,integer_data,dims)
d1045 1
d1081 2
a1082 1
    call Write_MLSAuxData(file_id, MLSData, error,write_attributes=.true.)
d2687 2
a2688 1
       & write_attributes, string_length, index, fill_value)
d2699 3
a2701 1
    real, intent(in), optional     :: fill_value    ! value to use for filling
d2849 14
a2862 2
       IF (PRESENT (fill_value)) THEN
          CALL H5pSet_Fill_Value_f (cparms, type_id, fill_value, h5error)
d3114 3
@


2.21
log
@Repaired misplaced ampersand on line 1812
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d19 1
a19 1
       h5gopen_f
d81 1
a81 1
    "$Id: MLSAuxData.f90,v 2.20 2002/12/20 20:45:57 perun Exp $"
d478 2
a479 1
 subroutine Build_MLSAuxData_Real( file_id, dataset, real_data, lastIndex)
d483 1
d505 2
a506 2
          call Write_MLSAuxData(file_id, MLSData, error, &
               write_attributes=.true., index=lastIndex)
d508 2
a509 2
          call Write_MLSAuxData(file_id, MLSData, error, &
               write_attributes=.false., index=lastIndex)
d512 1
a512 1
       call Write_MLSAuxData(file_id, MLSData, error)
d563 1
a563 1
      dims)
d568 1
d608 1
a608 1
               write_attributes=.true.)
d611 1
a611 1
               write_attributes=.false.)
d615 1
a615 1
            write_attributes=.true.) 
d744 1
a744 1
      dims)
d749 1
d791 1
a791 1
               write_attributes=.true.)
d794 1
a794 1
               write_attributes=.false.)
d798 1
a798 1
            write_attributes=.true.)
d932 1
a932 1
      dims)
d936 1
d973 2
a974 1
    call Write_MLSAuxData(file_id, MLSData, error,write_attributes=.true.)
d2672 2
a2673 2
  subroutine Write_MLSAuxData(file_id, MLSAuxData, error, &
       & write_attributes, string_length, index)
d2684 1
d2826 1
a2826 1
            H5_ERROR_PROPERTY_CREATE // trim(MLSAuxData%name) )
d2832 6
d3085 3
@


2.20
log
@Added MaxCharFieldLen for MLSAuxData_T
@
text
@d81 1
a81 1
    "$Id: MLSAuxData.f90,v 2.19 2002/12/18 16:24:43 perun Exp $"
d1812 1
a1812 1
                        ModuleName, &H5_ERROR_TYPE_SET // trim(MLSAuxData%name))
d2212 1
d2397 1
d2699 2
d3072 3
@


2.19
log
@Remove memory leaks due to nullify
@
text
@d77 2
a78 1
   & Build_MLSAuxData, AddMLSAuxDataToDatabase, DestroyMLSAuxDataDatabase
d81 1
a81 1
    "$Id: MLSAuxData.f90,v 2.18 2002/12/06 23:38:12 pwagner Exp $"
d90 1
d96 2
a97 1
    character(len=27), dimension(:,:,:), pointer :: CharField => NULL()
d244 1
a244 1
      do index = 1, SIZE(database)
d246 4
a249 4
      end do
      deallocate ( database, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate // "database" )
d263 2
a264 2
     MLSData%name        = trim(name) 
     MLSData%type_name   = trim(data_type)
d267 5
a271 5
     allocate(MLSData%RealField(dims(1),dims(2),dims(3)), stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_allocate // ' MLSAuxData%RealField in ' // name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d275 5
a279 5
     allocate(MLSData%DpField(dims(1),dims(2),dims(3)), stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_allocate // ' MLSAuxData%DpField in ' // name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d283 5
a287 5
     allocate(MLSData%IntField(dims(1),dims(2),dims(3)), stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_allocate // ' MLSAuxData%IntField in ' // name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d291 5
a295 5
     allocate(MLSData%CharField(dims(1),dims(2),dims(3)), stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_allocate // ' MLSAuxData%CharField in ' // name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d307 6
a312 6
        deallocate(MLSAuxData%RealField, stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' MLSAuxData%RealField in ' // & 
           MLSAuxData%name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d316 6
a321 6
        deallocate(MLSAuxData%IntField, stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' MLSAuxData%IntField in ' // &
           MLSAuxData%name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d325 6
a330 6
        deallocate(MLSAuxData%CharField, stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' MLSAuxData%CharField in ' // &
           MLSAuxData%name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d334 6
a339 6
        deallocate(MLSAuxData%DpField, stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' MLSAuxData%DpField in ' // &
           MLSAuxData%name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d343 6
a348 6
        deallocate(MLSAuxData%FrequencyCoordinates, stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' MLSAuxData%FrequencyCoordinates in ' // &
           MLSAuxData%name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d352 6
a357 6
        deallocate(MLSAuxData%VerticalCoordinates, stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' MLSAuxData%VerticalCoordinates in ' // &
           MLSAuxData%name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d361 6
a366 6
        deallocate(MLSAuxData%HorizontalCoordinates, stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' MLSAuxData%HorizontalCoordinates in ' // &
           MLSAuxData%name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d370 6
a375 6
        deallocate(MLSAuxData%Dimensions, stat=status)
     if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' MLSAuxData%Dimensions in ' // &
           MLSAuxData%name
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
d396 26
a421 26
     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),&
          trim(dataset%data_type),dims,MLSData)

      MLSData%CharField(1,1,1) = char_data
      MLSData%rank = 1

      allocate(MLSData%Dimensions(1), stat=status)

      call CopyFromDataProducts(dataset, MLSData)

      if (present(lastIndex)) then 
         if (lastIndex .eq. 1) then 
     call Write_MLSAuxData(file_id, MLSData, error, & 
          write_attributes=.true., & 
          string_length=char_length, index=lastIndex)
         else
     call Write_MLSAuxData(file_id, MLSData, error, & 
          write_attributes=.false., & 
          string_length=char_length, index=lastIndex)
        endif
     else
     call Write_MLSAuxData(file_id, MLSData, error, & 
          write_attributes=.true., & 
          string_length=char_length)
     endif
d424 2
a425 2
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
     call deallocate_mlsauxdata(MLSData)
d427 1
a427 1
!------------------------------------------------------------------------------
d443 4
a446 1
     call deallocate_mlsauxdata(MLSData)
d448 2
a449 2
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dims,MLSData)
d451 2
a452 2
     MLSData%IntField(1,1,1) = int_data
     MLSData%rank = 1
d454 1
a454 15
      allocate(MLSData%Dimensions(1), stat=status)
      call CopyFromDataProducts(dataset, MLSData)

      if ( present (lastIndex)) then

         if (lastIndex .eq. 1) then
            call Write_MLSAuxData(file_id, MLSData, error, &
                 write_attributes=.true., &  
                 index=lastIndex)
         else
            call Write_MLSAuxData(file_id, MLSData, error, &
                 write_attributes=.false., &  
                 index=lastIndex)
         endif
      else
d456 13
a468 2
         call Write_MLSAuxData(file_id, MLSData, error, &
              write_attributes=.true.)
d470 1
a470 1
      endif
d473 2
a474 2
       'Error Writing MLSAuxData for '// trim(dataset%name) )
     call deallocate_mlsauxdata(MLSData)
d492 20
a511 20
     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dims,MLSData)

     MLSData%RealField(1,1,1) = real_data
     MLSData%rank = 1
      allocate(MLSData%Dimensions(1), stat=status)
      call CopyFromDataProducts(dataset, MLSData)

     if ( present(lastIndex) ) then
        if (lastIndex .eq. 1) then 
        call Write_MLSAuxData(file_id, MLSData, error, &
          write_attributes=.true., index=lastIndex)
        else
        call Write_MLSAuxData(file_id, MLSData, error, &
          write_attributes=.false., index=lastIndex)
        endif
     else
        call Write_MLSAuxData(file_id, MLSData, error)
     endif
d514 2
a515 2
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
     call deallocate_mlsauxdata(MLSData)
d532 22
a553 22
     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dims,MLSData)
     MLSData%DpField(1,1,1) = double_data
     MLSData%rank = 1


      allocate(MLSData%Dimensions(1), stat=status)
      call CopyFromDataProducts(dataset, MLSData)

     if ( present (lastIndex) ) then 
        if (lastIndex .eq. 1) then 
           call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
                write_attributes=.true.)
        else
           call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
          write_attributes=.false.)
        endif
     else
        call Write_MLSAuxData(file_id, MLSData, error,&           
             write_attributes=.true.)
     endif
d556 2
a557 2
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
     call deallocate_mlsauxdata(MLSData)
d572 42
a613 42
     if (present(dims) ) then        
          do i=1,3
             dim_array(i) = dims(i)
          enddo
     else
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(real_data))
         dim_array(i) = size(real_data,i)
        enddo
     endif

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)

        do i = 1, dim_array(1)
          MLSData%RealField(i,1,1) = real_data(i) 
        enddo

     if ( present(lastIndex)) then 
             MLSData%rank = 2
     else
             MLSData%rank = 1
     endif

          allocate(MLSData%Dimensions(MLSData%rank), stat=status)
          call CopyFromDataProducts(dataset, MLSData)

     if ( present(lastIndex)) then
        if (lastIndex .eq. 1) then 
        call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
          write_attributes=.true.)
        else
        call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
          write_attributes=.false.)
        endif
     else
        call Write_MLSAuxData(file_id, MLSData, error,&           
             write_attributes=.true.) 
     endif
d616 2
a617 2
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
     call deallocate_mlsauxdata(MLSData)
d632 42
a673 42
     if (present(dims) ) then        
          do i=1,3
             dim_array(i) = dims(i)
          enddo
     else
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(double_data))
         dim_array(i) = size(double_data,i)
        enddo
     endif

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
    
        do i = 1, dim_array(1)
          MLSData%DpField(i,1,1) = double_data(i) 
       enddo

     if ( present (lastIndex) ) then 
             MLSData%rank = 2
     else
             MLSData%rank = 1
     endif

     allocate(MLSData%Dimensions(MLSData%rank), stat=status)
     call CopyFromDataProducts(dataset, MLSData)

     if ( present (lastIndex) ) then 
        if (lastIndex .eq. 1) then 
           call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
                       write_attributes=.true.)
        else 
        call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
                       write_attributes=.false.)
        endif
     else
        call Write_MLSAuxData(file_id, MLSData, error, &
          write_attributes=.true.)
     endif
d676 2
a677 2
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
     call deallocate_mlsauxdata(MLSData)
d692 42
a733 42
     if (present(dims) ) then        
          do i=1,3
             dim_array(i) = dims(i)
          enddo
     else
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(integer_data))
         dim_array(i) = size(integer_data,i)
        enddo
     endif

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)

        do i = 1, dim_array(1)
          MLSData%IntField(i,1,1) = integer_data(i) 
       enddo

     if (present (lastIndex) ) then
             MLSData%rank = 2 
     else
             MLSData%rank = 1
     endif

      allocate(MLSData%Dimensions(MLSData%rank), stat=status)
      call CopyFromDataProducts(dataset, MLSData)

     if (present (lastIndex) ) then
        if (lastIndex .eq. 1) then 
        call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
          write_attributes=.true.)
        else
        call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
          write_attributes=.false.)
        endif
     else
        call Write_MLSAuxData(file_id, MLSData, error, &
          write_attributes=.true.)
     endif
d736 2
a737 2
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
     call deallocate_mlsauxdata(MLSData)
d752 16
a767 16
     if (present(dims) ) then        
          do i=1,3
             dim_array(i) = dims(i)
          enddo
     else
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(real_data))
         dim_array(i) = size(real_data,i)
        enddo
     endif

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
d769 2
a770 2
     do j = 1, dim_array(2)
        do i = 1, dim_array(1)
d773 7
a779 1
     enddo
d781 15
a795 21
     if (present (lastIndex) ) then 
             MLSData%rank = 3
     else
             MLSData%rank = 2
     endif

      allocate(MLSData%Dimensions(MLSData%rank), stat=status)
      call CopyFromDataProducts(dataset, MLSData)

     if (present (lastIndex) ) then 
        if (lastIndex .eq. 1) then 
        call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
                       write_attributes=.true.)
        else
        call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
                       write_attributes=.false.)
        endif
     else
        call Write_MLSAuxData(file_id, MLSData, error, &
          write_attributes=.true.)
     endif
d798 2
a799 2
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
     call deallocate_mlsauxdata(MLSData)
d814 16
a829 16
     if (present(dims) ) then 
          do i=1,3
             dim_array(i) = dims(i)
          enddo
     else
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(double_data))
         dim_array(i) = size(double_data,i)
        enddo
     endif

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
d832 2
a833 2
     do j = 1, dim_array(2)
        do i = 1, dim_array(1)
d836 7
a842 1
     enddo
d844 15
a858 21
     if (present (lastIndex) ) then 
             MLSData%rank = 3
     else
             MLSData%rank = 2
     endif

      allocate(MLSData%Dimensions(MLSData%rank), stat=status)
      call CopyFromDataProducts(dataset, MLSData)

     if (present (lastIndex) ) then
        if (lastIndex .eq. 1) then 
        call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
          write_attributes=.true.)
        else
        call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
          write_attributes=.false.)
        endif
     else
        call Write_MLSAuxData(file_id, MLSData, error, &
          write_attributes=.true.)
     endif
d861 2
a862 2
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
     call deallocate_mlsauxdata(MLSData)
d877 16
a892 16
     if (present(dims) ) then 
          do i=1,3
             dim_array(i) = dims(i)
          enddo
     else
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(integer_data))
         dim_array(i) = size(integer_data,i)
        enddo
     endif

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
d894 2
a895 2
      do j = 1, dim_array(2)
        do i = 1, dim_array(1)
d898 7
a904 1
      enddo
d906 15
a920 21
      if (present (lastIndex)) then 
             MLSData%rank = 3
      else
             MLSData%rank = 2
      endif

      allocate(MLSData%Dimensions(MLSData%rank), stat=status)
      call CopyFromDataProducts(dataset, MLSData)

      if (present (lastIndex)) then
         if (lastIndex .eq. 1) then 
         call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
          write_attributes=.true.)
         else
         call Write_MLSAuxData(file_id, MLSData, error, index=lastIndex, &
          write_attributes=.false.)
         endif
      else
         call Write_MLSAuxData(file_id, MLSData, error, &
              write_attributes=.true.)
      endif
d923 2
a924 2
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
     call deallocate_mlsauxdata(MLSData)
d938 23
a960 7
     if (present(dims) ) then 
          do i=1,3
             dim_array(i) = dims(i)
          enddo
     else
          do i=1,3
             dim_array(i) = 1
a961 15
        do i=1,size(shape(real_data))
         dim_array(i) = size(real_data,i)
        enddo
     endif

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)

     MLSData%rank = 3

     do k = 1, dim_array(3)
      do j = 1, dim_array(2)
        do i = 1, dim_array(1)
          MLSData%RealField(i,j,k) = real_data(i,j,k) 
d963 1
a963 2
      enddo
     enddo
d965 2
a966 2
      allocate(MLSData%Dimensions(3), stat=status)
      call CopyFromDataProducts(dataset, MLSData)
d968 1
a968 1
     call Write_MLSAuxData(file_id, MLSData, error,write_attributes=.true.)
d971 2
a972 2
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
     call deallocate_mlsauxdata(MLSData)
d986 23
a1008 7
     if (present(dims) ) then 
          do i=1,3
             dim_array(i) = dims(i)
          enddo
     else
          do i=1,3
             dim_array(i) = 1
a1009 15
        do i=1,size(shape(double_data))
         dim_array(i) = size(double_data,i)
        enddo
     endif

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)

     MLSData%rank = 3

     do k = 1, dim_array(3)
      do j = 1, dim_array(2)
        do i = 1, dim_array(1)
          MLSData%DpField(i,j,k) = double_data(i,j,k) 
d1011 1
a1011 2
      enddo 
     enddo
d1013 2
a1014 2
      allocate(MLSData%Dimensions(3), stat=status)
      call CopyFromDataProducts(dataset, MLSData)
d1016 1
a1016 1
     call Write_MLSAuxData(file_id, MLSData, error,write_attributes=.true.)
d1018 2
a1019 2
       'Error Writing MLSAuxData.' ) 
     call deallocate_mlsauxdata(MLSData)
d1032 23
a1054 7
     if (present(dims) ) then 
          do i=1,3
             dim_array(i) = dims(i)
          enddo
     else
          do i=1,3
             dim_array(i) = 1
a1055 15
        do i=1,size(shape(integer_data))
         dim_array(i) = size(integer_data,i)
        enddo
     endif

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)

     MLSData%rank = 3

     do k = 1, dim_array(3)
      do j = 1, dim_array(2)
        do i = 1, dim_array(1)
          MLSData%IntField(i,j,k) = integer_data(i,j,k) 
d1057 1
a1057 2
      enddo
     enddo
d1059 2
a1060 2
      allocate(MLSData%Dimensions(3), stat=status)
      call CopyFromDataProducts(dataset, MLSData)
d1062 1
a1062 1
     call Write_MLSAuxData(file_id, MLSData, error,write_attributes=.true.)
d1064 2
a1065 2
       'Error Writing MLSAuxData.' ) 
     call deallocate_mlsauxdata(MLSData)
d1083 3
a1085 3
     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),&
          trim(dataset%data_type),dims,MLSData)
d1087 2
a1088 2
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type), MLSData, error, read_attributes=.true.)
d1091 1
a1091 1
      char_data = MLSData%CharField(1,1,1) 
d1093 2
a1094 2
      allocate(dataset%Dimensions(1), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1098 1
a1098 1
       'Error Writing MLSAuxData for '// trim(dataset%name) )
d1100 2
a1101 2
 
     call deallocate_mlsauxdata(MLSData)
d1117 3
a1119 3
     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dims,MLSData)
d1121 2
a1122 2
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type),MLSData, error, read_attributes=.true.)
d1125 1
a1125 1
     int_data = MLSData%IntField(1,1,1)
d1127 2
a1128 2
      allocate(dataset%Dimensions(1), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1132 1
a1132 1
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
d1135 1
a1135 1
     call deallocate_mlsauxdata(MLSData)
d1151 3
a1153 3
     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dims,MLSData)
d1155 2
a1156 2
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type),MLSData, error, read_attributes=.true.)
d1158 1
a1158 1
        real_data = MLSData%RealField(1,1,1)
d1160 2
a1161 2
      allocate(dataset%Dimensions(1), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1165 1
a1165 1
       'Error Writing MLSAuxData for '// trim(dataset%name) )
d1167 1
a1167 1
     call deallocate_mlsauxdata(MLSData)
d1183 5
a1187 5
     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dims,MLSData)
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type),MLSData, error, read_attributes=.true.)
d1190 3
a1192 3
     double_data = MLSData%DpField(1,1,1)
      allocate(dataset%Dimensions(1), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1195 1
a1195 1
       'Error Writing MLSAuxData for '// trim(dataset%name) )
d1198 1
a1198 1
     call deallocate_mlsauxdata(MLSData)
d1212 13
a1224 13
        do i=1,3
            dim_array(i) = 1
        enddo

        do i=1,size(shape(real_data))
         dim_array(i) = size(real_data,i)
        enddo

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type),MLSData, error, read_attributes=.true.)
d1236 2
a1237 2
          allocate(dataset%Dimensions(MLSData%rank), stat=status)
          call CopyToDataProducts(MLSData, dataset)
d1239 1
a1239 1
        do i = i_first, i_last
d1241 1
a1241 1
        enddo
d1245 1
a1245 1
       'Error Writing MLSAuxData for '// trim(dataset%name) )
d1248 1
a1248 1
     call deallocate_mlsauxdata(MLSData)
d1262 11
a1272 11
        do i=1,3
            dim_array(i) = 1
        enddo

        do i=1,size(shape(double_data))
         dim_array(i) = size(double_data,i)
        enddo

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
d1274 2
a1275 2
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type),MLSData, error, read_attributes=.true.)
d1277 1
a1277 1
     if (error /= 0) then 
d1287 2
a1288 2
          allocate(dataset%Dimensions(MLSData%rank), stat=status)
          call CopyToDataProducts(MLSData, dataset)
d1290 1
a1290 1
        do i = i_first, i_last
d1292 1
a1292 1
        enddo
d1295 1
a1295 1
     else
d1297 2
a1298 2
       'Error Writing MLSAuxData for '// trim(dataset%name) )
     endif
d1300 1
a1300 1
     call deallocate_mlsauxdata(MLSData)
d1314 11
a1324 3
          do i=1,3
             dim_array(i) = 1
          enddo
d1326 2
a1327 7
        do i=1,size(shape(integer_data))
         dim_array(i) = size(integer_data,i)
        enddo

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
d1329 1
a1329 4
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type),MLSData, error, read_attributes=.true.)

     if (error .eq. 0) then
d1337 1
a1337 1
        do i = i_first, i_last
d1339 1
a1339 1
        enddo
d1341 2
a1342 2
      allocate(dataset%Dimensions(MLSData%rank), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1344 4
a1347 4
     else
        call MLSMessage(MLSMSG_Error, ModuleName, & 
       'Error Writing MLSAuxData for '// trim(dataset%name) )
     endif
d1349 1
a1349 1
     call deallocate_mlsauxdata(MLSData)
d1363 14
a1376 14
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(real_data))
         dim_array(i) = size(real_data,i)
        enddo

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)

     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type),MLSData, error, read_attributes=.true.)
     if (error .eq. 0) then 
d1386 4
a1389 3
      do j = j_first, j_last
        do i = 1, dim_array(1)
          real_data(i,j) = MLSData%RealField(i,j,1) 
a1390 1
      enddo
d1392 2
a1393 2
      allocate(dataset%Dimensions(MLSData%rank), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1395 1
a1395 1
     else
d1397 2
a1398 2
       'Error Writing MLSAuxData for '// trim(dataset%name) )
     endif
d1400 1
a1400 1
     call deallocate_mlsauxdata(MLSData)
d1414 10
a1423 10
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(double_data))
         dim_array(i) = size(double_data,i)
        enddo

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
d1425 2
a1426 2
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type), MLSData, error, read_attributes=.true.)
d1437 4
a1440 3
     do j = j_first, j_last
        do i = 1, dim_array(1)
          double_data(i,j) = MLSData%DpField(i,j,1) 
a1441 1
     enddo
d1443 2
a1444 2
      allocate(dataset%Dimensions(MLSData%rank), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1448 1
a1448 1
       'Error Writing MLSAuxData for '// trim(dataset%name) )
d1450 1
a1450 1
     call deallocate_mlsauxdata(MLSData)
d1464 10
a1473 10
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(integer_data))
         dim_array(i) = size(integer_data,i)
        enddo

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
d1475 2
a1476 2
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type), MLSData, error, read_attributes=.true.)
d1487 4
a1490 3
      do j = j_first, j_last
        do i = 1, dim_array(1)
          integer_data(i,j) = MLSData%IntField(i,j,1)  
a1491 1
      enddo
d1493 2
a1494 2
      allocate(dataset%Dimensions(MLSData%rank), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1498 1
a1498 1
       'Error Writing MLSAuxData for '// trim(dataset%name) )
d1500 1
a1500 1
     call deallocate_mlsauxdata(MLSData)
d1514 10
a1523 10
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(real_data))
         dim_array(i) = size(real_data,i)
        enddo

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
d1525 2
a1526 2
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type), MLSData, error, read_attributes=.true.)
d1537 7
a1543 5
       
     do k = k_first, k_last
      do j = 1, dim_array(2)
        do i = 1, dim_array(1)
          real_data(i,j,k) = MLSData%RealField(i,j,k)  
a1544 2
      enddo
     enddo
d1546 2
a1547 2
      allocate(dataset%Dimensions(3), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1551 1
a1551 1
       'Error Writing MLSAuxData for '// trim(dataset%name) )
d1553 1
a1553 1
     call deallocate_mlsauxdata(MLSData)
d1567 12
a1578 12
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(double_data))
         dim_array(i) = size(double_data,i)
        enddo

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type), MLSData, error, read_attributes=.true.)
d1589 6
a1594 4
     do k = k_first, k_last
      do j = 1, dim_array(2)
        do i = 1, dim_array(1)
          double_data(i,j,k) = MLSData%DpField(i,j,k) 
a1595 2
      enddo 
     enddo
d1597 2
a1598 2
      allocate(dataset%Dimensions(3), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1601 1
a1601 1
     call MLSMessage(MLSMSG_Error,ModuleName,'Error Writing MLSAuxData.')
d1603 5
a1607 5
     call deallocate_mlsauxdata(MLSData)
 end subroutine Recall_MLSAuxData_Double_3d
!------------------------------------------------------------------------------
 subroutine Recall_MLSAuxData_Integer_3d(file_id,dataset,integer_data, &
      firstIndex, lastIndex)
d1617 10
a1626 10
          do i=1,3
             dim_array(i) = 1
          enddo
        do i=1,size(shape(integer_data))
         dim_array(i) = size(integer_data,i)
        enddo

     call deallocate_mlsauxdata(MLSData)
     call Allocate_MLSAuxData(trim(dataset%name),& 
          trim(dataset%data_type),dim_array,MLSData)
d1628 2
a1629 2
     call Read_MLSAuxData(file_id, trim(dataset%name), &
          trim(dataset%data_type), MLSData, error, read_attributes=.true.)
d1640 1
a1640 1
! dump the data into the array.
d1642 6
a1647 4
     do k = k_first, k_last
      do j = 1, dim_array(2)
        do i = 1, dim_array(1)
          integer_data(i,j,k) = MLSData%IntField(i,j,k)  
a1648 2
      enddo
     enddo
d1650 2
a1651 2
      allocate(dataset%Dimensions(3), stat=status)
      call CopyToDataProducts(MLSData, dataset)
d1654 1
a1654 1
     call MLSMessage(MLSMSG_Error,ModuleName,'Error Writing MLSAuxData.')
d1656 1
a1656 1
     call deallocate_mlsauxdata(MLSData)
d1674 3
a1676 3
     call h5gcreate_f(loc_id, trim(group_name), group_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_CREATE // trim(group_name))
d1678 3
a1680 3
     call h5gclose_f(group_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_CLOSE // trim(group_name)) 
d1684 3
a1686 3
     call h5gopen_f(loc_id, trim(group_name), group_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_OPEN // trim(group_name))
d1688 3
a1690 3
     call h5gcreate_f(group_id, trim(subgroup_name), subgroup_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_CREATE // trim(subgroup_name))
d1692 3
a1694 3
     call h5gclose_f(subgroup_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_CLOSE // trim(subgroup_name)) 
d1696 3
a1698 3
     call h5gclose_f(group_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_CLOSE // trim(group_name)) 
d1732 51
a1782 51
       rank = size(shape(MLSAuxData%RealField))
       type_id = H5T_IEEE_F32LE
       do i=1,rank-1
          dims(i) = size(MLSAuxData%RealField, i)
          chunk_dims(i) = dims(i)
          maxdims(i) = chunk_dims(i)
       end do
          dims(rank) = 1
          chunk_dims(rank) = 1
          maxdims(rank) = H5S_UNLIMITED_F
       end if
    case ('double')
       if (associated(MLSAuxData%DpField)) then 
       rank = size(shape(MLSAuxData%DpField))
       type_id = H5T_NATIVE_DOUBLE
       do i=1,rank-1
          dims(i) = size(MLSAuxData%DpField, i)
          chunk_dims(i) = dims(i)
          maxdims(i) = chunk_dims(i)
       end do
          dims(rank) = 1
          chunk_dims(rank) = 1
          maxdims(rank) = H5S_UNLIMITED_F
       endif
    case ('integer')
       if (associated(MLSAuxData%IntField)) then 
       rank = size(shape(MLSAuxData%IntField))
       type_id = H5T_NATIVE_INTEGER
       do i=1,rank-1
          dims(i) = size(MLSAuxData%IntField, i)
          chunk_dims(i) = dims(i)
          maxdims(i) = chunk_dims(i)
       end do
          dims(rank) = 1
          chunk_dims(rank) = 1
          maxdims(rank) = H5S_UNLIMITED_F
       endif
    case ('character')
       if (associated(MLSAuxData%CharField)) then 
       rank = size(shape(MLSAuxData%CharField))
       type_id = H5T_NATIVE_CHARACTER
       do i=1,rank-1
          dims(i) = size(MLSAuxData%CharField, i)
          chunk_dims(i) = dims(i)
          maxdims(i) = chunk_dims(i)
       end do
          dims(rank) = 1
          chunk_dims(rank) = 1
          maxdims(rank) = H5S_UNLIMITED_F
       endif
    end select test_type
d1784 35
a1818 29
    call h5screate_simple_f(rank, dims(1:rank),dspace_id,h5error,& 
         maxdims(1:rank))
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name) )

    call h5pcreate_f(H5P_DATASET_CREATE_F,cparms,h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_PROPERTY_CREATE // trim(MLSAuxData%name) )

    call h5pset_chunk_f(cparms,rank,chunk_dims(1:rank),h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_PROPERTY_CHUNK_SET // trim(MLSAuxData%name) )

    if (trim(MLSAuxData%type_name).ne.'character') then

    call h5dcreate_f(file_id,trim(MLSAuxData%name),type_id,dspace_id, &
          dset_id,h5error,cparms)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSET_CREATE // trim(MLSAuxData%name) ) 

    else
 
     call h5tcopy_f(type_id, s_type_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_TYPE_COPY // trim(MLSAuxData%name))

     call h5tset_size_f(s_type_id, string_length, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_TYPE_SET // trim(MLSAuxData%name))
d1820 1
a1820 6
     call h5dcreate_f(file_id, trim(MLSAuxData%name), s_type_id, &
       dspace_id, dset_id, h5error, cparms)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_DSET_CREATE // trim(MLSAuxData%name))

    endif
d1824 1
a1824 1
    if (present(write_attributes)) then 
d1826 1
a1826 1
    if (write_attributes) then 
d1828 166
a1993 3
    do i = 2, 7
       adims(i) = 0
    end do
d1995 13
d2009 7
a2015 164
    if (associated(MLSAuxData%HorizontalCoordinates)) then 

       arank = size(shape(MLSAuxData%HorizontalCoordinates))
       atype_id = H5T_IEEE_F32LE
       adims(1) = size(MLSAuxData%HorizontalCoordinates)
       adims_create(1) = adims(1)

       allocate(attr_data(adims(1)),STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_Allocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

       do i=1, adims(1)
          attr_data(i) = MLSAuxData%HorizontalCoordinates(i)
       end do

       aname = "HorizontalCoordinates"  

       call h5screate_simple_f(arank, adims_create, aspace_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CREATE // trim(aname) // ' in ' // & 
       trim(MLSAuxData%name) )

       call h5acreate_f(dset_id, trim(aname), atype_id, aspace_id, attr_id, &
          h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CREATE // trim(aname) // ' in ' // &
       trim(MLSAuxData%name) )

       call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_WRITE // trim(MLSAuxData%name)  )

       call h5aclose_f(attr_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CLOSE // trim(MLSAuxData%name) )

       call h5sclose_f(aspace_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )

       deallocate(attr_data,STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_deallocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

    endif

    if (associated(MLSAuxData%VerticalCoordinates) ) then 
       arank = size(shape(MLSAuxData%VerticalCoordinates))
       atype_id = H5T_IEEE_F32LE
       adims(1) = size(MLSAuxData%VerticalCoordinates)
       adims_create(1) = adims(1)

       allocate(attr_data(adims(1)),STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_allocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

       do i=1,adims(1)
          attr_data(i) = MLSAuxData%VerticalCoordinates(i)
       end do

       call h5screate_simple_f(arank, adims_create, aspace_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name) )

       aname = "VerticalCoordinates"   
       call h5acreate_f(dset_id, trim(aname), atype_id, aspace_id, attr_id, &
          h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CREATE // trim(MLSAuxData%name) )

       call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_WRITE // trim(MLSAuxData%name) )

       call h5aclose_f(attr_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CLOSE // trim(MLSAuxData%name) )

       call h5sclose_f(aspace_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )
 
       deallocate(attr_data,STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_deallocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

    endif

    if (associated(MLSAuxData%FrequencyCoordinates)) then 
       arank = size(shape(MLSAuxData%FrequencyCoordinates))
       atype_id = H5T_IEEE_F32LE
       adims(1) = size(MLSAuxData%FrequencyCoordinates)
       adims_create(1) = adims(1)

       allocate(attr_data(adims(1)),STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_allocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

       do i=1,adims(1)
          attr_data(i) = MLSAuxData%FrequencyCoordinates(i)
       end do

       call h5screate_simple_f(arank, adims_create, aspace_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name) )

       aname = "FrequencyCoordinates"
       call h5acreate_f(dset_id, trim(aname), atype_id, aspace_id, attr_id, &
          h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CREATE // trim(MLSAuxData%name) )

       call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_WRITE // trim(MLSAuxData%name) )

       call h5aclose_f(attr_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CLOSE // trim(MLSAuxData%name) )

       call h5sclose_f(aspace_id, h5error) 
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )

       deallocate(attr_data,STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_deallocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
      endif
     endif
    endif

!---------------- close all structures----------------------------------
!
    call h5sclose_f( dspace_id, h5error )
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )

    call h5dclose_f( dset_id,   h5error )
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSET_CLOSE // trim(MLSAuxData%name) )

    call h5pclose_f( cparms,    h5error )
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_PROPERTY_CLOSE // trim(MLSAuxData%name) )

  end subroutine Create_MLSAuxData
!------------Read_MLSAuxAttributes ----
  subroutine Read_MLSAuxAttributes(dset_id, QuantityName, AttributeName, & 
       error, MLSAuxData, AttributeData)
  ! This subroutine reads attributes from the HDF5 file;
  ! e.g., FrequencyCoordinates
  ! They are returned either as:
d2044 1
a2044 1
  ! Check that exactly 1 of the optional args is supplied
d2050 38
a2087 6
      select case (trim(AttributeName))
      case ('FrequencyCoordinates')
        if ( associated ( MLSAuxData%FrequencyCoordinates ) ) then
          arank = 1
          adims(1) = size(MLSAuxData%FrequencyCoordinates)
        else
d2090 1
a2090 33
        endif
      case ('HorizontalCoordinates')
        if ( associated ( MLSAuxData%HorizontalCoordinates ) ) then
          arank = 1
          adims(1) = size(MLSAuxData%HorizontalCoordinates)
        else
          error = 1
          return
        endif
      case ('VerticalCoordinates')
        if ( associated ( MLSAuxData%VerticalCoordinates ) ) then
          arank = 1
          adims(1) = size(MLSAuxData%VerticalCoordinates)
        else
          error = 1
          return
        endif
      case ('Dimensions')
        if ( associated (MLSAuxData%Dimensions) ) then
           arank = 1
               is_char  = .true.
               atype_id = H5T_NATIVE_CHARACTER
           do i = 1, arank
              adims(i) = size(MLSAuxData%Dimensions)
           enddo
        else
          error = 1
          return
        endif
      case default
        error = 1
        return
      end select
d2092 1
a2092 1
      adims(1) = size(AttributeData)
d2094 2
a2095 2
      error = 1
      return
d2100 2
a2101 2
        H5_ERROR_ATT_OPEN // trim(AttributeName) // ' in ' // &
        QuantityName )
d2105 1
a2105 1
        H5_ERROR_ATT_GETSPACE // QuantityName )
d2109 5
a2113 5
    allocate(char_data(adims(1)),stat=status)
    if ( status /= 0 ) then
       msr = MLSMSG_allocate// ' char_data.'
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d2115 4
a2118 4
    call h5aread_f(attr_id, atype_id, char_data, adims, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
        H5_ERROR_ATT_READ // trim(AttributeName) // ' in ' // &
        QuantityName )
d2122 5
a2126 5
    allocate(attr_data(adims(1)),stat=status)
    if ( status /= 0 ) then
       msr = MLSMSG_allocate// ' attr_data.'
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d2128 4
a2131 4
    call h5aread_f(attr_id, atype_id, attr_data, adims, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
        H5_ERROR_ATT_READ // trim(AttributeName) // ' in ' // &
        QuantityName )
d2137 10
a2146 10
      select case (trim(AttributeName))
      case ('FrequencyCoordinates')
        MLSAuxData%FrequencyCoordinates = attr_data(:adims(1))
      case ('HorizontalCoordinates')
        MLSAuxData%HorizontalCoordinates = attr_data(:adims(1))
      case ('VerticalCoordinates')
        MLSAuxData%VerticalCoordinates = attr_data(:adims(1))
      case ('Dimensions')
        MLSAuxData%Dimensions = char_data(:adims(1))
      end select
d2149 1
a2149 1
      AttributeData = attr_data(:adims(1))
d2154 2
a2155 2
        H5_ERROR_ATT_CLOSE // trim(AttributeName) // ' in ' // &
        QuantityName )
d2159 2
a2160 2
        H5_ERROR_DSPACE_CLOSE // trim(AttributeName) // ' in ' // &
        QuantityName )
d2163 6
a2168 6
    deallocate(attr_data,STAT=status)
     if ( status /= 0 ) then
        msr = MLSMSG_deallocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
     endif
d2171 6
a2176 6
    deallocate(char_data,STAT=status)
     if ( status /= 0 ) then
        msr = MLSMSG_deallocate// ' char_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
     endif
     endif
d2179 1
a2179 1
!-------------------------------------------------Write_MLSAuxAttributes ----
d2182 7
a2188 7
  !
  ! This subroutine writes attributes to the HDF5 file;
  ! e.g., FrequencyCoordinates
  ! They are supplied either as:
  ! components of MLSAuxData (if supplied); or
  ! in the array AttributeData
  ! It is an error unless exactly one of the two is supplied
d2195 1
a2195 1
  ! Private
d2206 2
a2207 2
!-----------------------------------------------------------------------
  ! Executable
d2212 2
a2213 2
  ! Check that exactly 1 of the optional args is supplied
  ! The following will produce 0 if neither, 3 if both; else 1 or 2
d2219 58
a2276 5
      select case (trim(AttributeName))
      case ('FrequencyCoordinates')
        arank = 1
        adims(1) = size(MLSAuxData%FrequencyCoordinates)
        allocate(attr_data(adims(1)),STAT=status)
d2278 2
a2279 2
           msr = MLSMSG_allocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
d2282 3
a2284 56
        do i=1,adims(1)
           attr_data(i) = MLSAuxData%FrequencyCoordinates(i)
        end do
      case ('HorizontalCoordinates')
        arank = 1
        adims(1) = size(MLSAuxData%HorizontalCoordinates)
        allocate(attr_data(adims(1)),STAT=status)
        if ( status /= 0 ) then
           msr = MLSMSG_allocate// ' attr_data.'
         call MLSMessage(MLSMSG_Error, ModuleName, msr)
        endif

        do i=1,adims(1)
           attr_data(i) = MLSAuxData%HorizontalCoordinates(i)
        end do
      case ('VerticalCoordinates')
        arank = 1
        adims(1) = size(MLSAuxData%VerticalCoordinates)
        allocate(attr_data(adims(1)),STAT=status)
        if ( status /= 0 ) then
           msr = MLSMSG_allocate// ' attr_data.'
         call MLSMessage(MLSMSG_Error, ModuleName, msr)
        endif

        do i=1,adims(1)
           attr_data(i) = MLSAuxData%VerticalCoordinates(i)
        end do
      case ('Dimensions')
        arank = 1
        atype_id = H5T_NATIVE_CHARACTER
        is_char  = .true.
        adims(1) = size(MLSAuxData%Dimensions)
        allocate(char_data(adims(1)),STAT=status)
        if ( status /= 0 ) then
           msr = MLSMSG_allocate// ' char_data.'
         call MLSMessage(MLSMSG_Error, ModuleName, msr)
        endif
        do i=1,adims(1)
           char_data(i) = trim(MLSAuxData%Dimensions(i))
        end do
      case default
        error = 1
        return
      end select
    case (OPTARGISARR)
        arank = 1
        adims(1) = size(AttributeData)
        allocate(attr_data(adims(1)),STAT=status)
        if ( status /= 0 ) then
           msr = MLSMSG_allocate // ' attr_data.'
         call MLSMessage(MLSMSG_Error, ModuleName, msr)
        endif

        do i=1,adims(1)
           attr_data(i) = AttributeData(i)
        end do
d2286 2
a2287 2
      error = 1
      return
d2292 2
a2293 2
        H5_ERROR_DSPACE_CREATE // trim(AttributeName) // ' in ' // & 
        trim(MLSAuxData%name) )
d2297 1
a2297 1
     attrlen = 20 
d2299 9
a2307 4
     CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, h5error)
     IF (h5error /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_TYPE_COPY // trim(AttributeName) // ' in ' // &
        trim(MLSAuxData%name))
d2309 5
a2313 4
     CALL h5tset_size_f(atype_id, attrlen, h5error)
     IF (h5error /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_TYPE_SET // trim(AttributeName) // ' in ' // &
        trim(MLSAuxData%name))
d2315 4
a2318 10
    call h5acreate_f(dset_id, trim(AttributeName), atype_id, &         
      & aspace_id, attr_id, h5error)                                   
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
        H5_ERROR_ATT_CREATE // trim(AttributeName) // ' in ' // &
        trim(MLSAuxData%name) )

    call h5awrite_f(attr_id, atype_id, char_data, adims, h5error)      
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
        H5_ERROR_ATT_WRITE // trim(AttributeName) // ' in ' // &
        trim(MLSAuxData%name) )
d2322 5
a2326 5
    call h5acreate_f(dset_id, trim(AttributeName), atype_id, &         
      & aspace_id, attr_id, h5error)                                   
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
        H5_ERROR_ATT_CREATE // trim(AttributeName) // ' in ' // &
        trim(MLSAuxData%name) )
d2328 4
a2331 4
    call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)      
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
        H5_ERROR_ATT_WRITE // trim(AttributeName) // ' in ' // &
        trim(MLSAuxData%name) )
d2337 2
a2338 2
        H5_ERROR_ATT_CLOSE // trim(AttributeName) // ' in ' // &
        trim(MLSAuxData%name) )
d2342 2
a2343 2
        H5_ERROR_DSPACE_CLOSE // trim(AttributeName) // ' in ' // & 
    trim(MLSAuxData%name) )
d2346 5
a2350 5
    deallocate(attr_data,STAT=status)
    if ( status /= 0 ) then
        msr = MLSMSG_deallocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d2354 5
a2358 4
    deallocate(char_data,STAT=status)
    if ( status /= 0 ) then
        msr = MLSMSG_deallocate// ' char_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
d2360 1
a2360 2
    endif
                                
d2362 1
a2362 1
!-------------------------------------------------Read_MLSAuxData ----
d2366 1
a2366 1
! This subroutine reads an entry from the HDF5 file.
d2376 1
a2376 1
!-------------------------------------------------------------------------
d2397 1
a2397 1
!-- assign name and type for dataset
d2404 1
a2404 1
       H5_ERROR_DSET_OPEN // trim(MLSAuxData%name) )
d2408 1
a2408 1
       H5_ERROR_DSET_GETSPACE // trim(MLSAuxData%name) )
d2412 1
a2412 1
       H5_ERROR_DSPACE_GET_NDIMS // trim(MLSAuxData%name) )
d2419 1
a2419 1
       H5_ERROR_DSPACE_GET_DIMS // trim(MLSAuxData%name) )
d2423 1
a2423 1
       H5_ERROR_DSET_CREATE // trim(MLSAuxData%name) )
d2427 1
a2427 1
       H5_ERROR_PROPERTY_CHUNK_GET // trim(MLSAuxData%name) )
d2431 1
a2431 1
       H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name) )
d2435 1
a2435 1
       H5_ERROR_DSET_GET_TYPE // trim(MLSAuxData%name) )
d2438 1
a2438 1
      myQuantityType = QuantityType
d2441 33
a2473 33
      is_integer = .FALSE.
      is_real = .FALSE.
      is_double = .FALSE.
      is_int32 = .FALSE.
      is_float32 = .FALSE.
      is_float64 = .FALSE.
      is_character = .FALSE.

      call h5tequal_f(type_id, H5T_NATIVE_INTEGER, is_integer, h5error)
      call h5tequal_f(type_id, H5T_STD_I32LE, is_int32, h5error)
      call h5tequal_f(type_id, H5T_NATIVE_CHARACTER, is_character, h5error)
      call h5tequal_f(type_id, H5T_NATIVE_REAL, is_real, h5error)
      call h5tequal_f(type_id, H5T_IEEE_F32LE, is_float32, h5error)
      call h5tequal_f(type_id, H5T_IEEE_F64LE, is_float64, h5error)
      call h5tequal_f(type_id, H5T_NATIVE_DOUBLE, is_double, h5error)

! Please add any new or compound datatypes here.

    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
        H5_ERROR_TYPE_EQUAL // trim(MLSAuxData%name) )

      if ( is_integer .or. is_int32 ) then
        myQuantityType = 'integer'
      elseif ( is_real .or. is_float32 ) then
        myQuantityType = 'real'
      elseif ( is_double .or. is_float64 ) then
        myQuantityType = 'double'
      elseif ( is_character ) then
        myQuantityType = 'character'
      else
        error = 1
        return
      endif
d2479 1
a2479 1
           dims(i) = dims_create(i) 
d2481 1
a2481 1
           dims(i) = 0
d2490 1
a2490 1
                                start(1:rank), dims_create(1:rank), h5error)
d2492 1
a2492 1
        H5_ERROR_DSPACE_HYPERSLAB // trim(MLSAuxData%name) )
d2494 1
a2494 1
! based on type chose which h5dread to call.
d2498 14
a2511 14
    test_type: select case (trim(myQuantityType))
    case ('real')
    call h5dread_f(dset_id,type_id,MLSAuxData%RealField,dims,& 
         h5error, memspace,dspace_id)
    case ('double')    
    call h5dread_f(dset_id,type_id,MLSAuxData%DpField,dims,&
         h5error,memspace,dspace_id)
    case ('integer')  
    call h5dread_f(dset_id,type_id,MLSAuxData%IntField,dims,& 
         h5error,memspace,dspace_id)
    case ('character') 
    call h5dread_f(dset_id,type_id,MLSAuxData%CharField,dims,&
         h5error,memspace,dspace_id)
    end select test_type
a2513 8
     
    test_type_dims: select case (trim(myQuantityType))
    case ('real')
    allocate( real_buffer(dims(1),dims(2),dims(3)),stat=status)
    if ( status /= 0 ) then
      msr = MLSMSG_allocate // ' real_buffer.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d2515 17
a2531 7
    call h5dread_f(dset_id,type_id,& 
         real_buffer,dims,h5error, memspace, dspace_id)

    do k = FirstIndex, LastIndex
       do j = 1, dims(2)
          do i = 1, dims(1)
             MLSAuxData%RealField(i,j,k) = real_buffer(i,j,k)
a2532 5
       end do
    end do
         
    if (associated(real_buffer)) then 
        deallocate(real_buffer, stat=status)
d2534 2
a2535 4
    if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' real_buffer.'  
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d2537 24
a2560 1
    endif
d2562 2
a2563 1
    case ('double')    
d2565 23
a2587 5
    allocate( double_buffer(dims(1),dims(2),dims(3)),stat=status)
    if ( status /= 0 ) then
      msr = MLSMSG_allocate // ' double_buffer'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d2589 25
a2613 9
    call h5dread_f(dset_id,type_id,& 
         double_buffer,dims,h5error, memspace, dspace_id)
         do k = FirstIndex, LastIndex
            do j = 1, dims(2)
               do i = 1, dims(1)
                  MLSAuxData%DpField(i,j,k) = double_buffer(i,j,k)
               end do 
            end do
         end do    
d2615 2
a2616 2
    if (associated(double_buffer)) then 
        deallocate(double_buffer, stat=status)
d2618 4
a2621 4
    if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' double_buffer.' 
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d2623 1
a2623 1
    endif
d2625 1
a2625 6
    case ('integer')  
    allocate( integer_buffer(dims(1),dims(2),dims(3)),stat=status)
    if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' integer_buffer'  
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
a2626 16
    call h5dread_f(dset_id,type_id,& 
         integer_buffer,dims,h5error, memspace, dspace_id)
         do k = FirstIndex, LastIndex
            do j = 1, dims(2)
               do i = 1, dims(1)
                  MLSAuxData%IntField(i,j,k) = integer_buffer(i,j,k)
               end do 
            end do
         end do

    if (associated(integer_buffer)) then 
        deallocate(integer_buffer, stat=status)
    if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' integer_buffer.' 
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d2629 2
a2630 25
    case ('character') 
    allocate( character_buffer(dims(1),dims(2),dims(3)),stat=status)

    if ( status /= 0 ) then
      msr = MLSMSG_allocate // ' character_buffer.' 
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    call h5dread_f(dset_id,type_id,& 
         character_buffer,dims,h5error, memspace, dspace_id)
         do k = FirstIndex, LastIndex
            do j = 1, dims(2)
               do i = 1, dims(1)
                  MLSAuxData%CharField(i,j,k) = character_buffer(i,j,k)
               end do 
            end do
         end do

    if (associated(character_buffer)) then 
        deallocate(character_buffer, stat=status)

    if ( status /= 0 ) then
      msr = MLSMSG_deallocate // ' character_buffer.' 
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d2632 10
a2642 19

    end select test_type_dims

    endif

    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSET_READ // trim(MLSAuxData%name) )

! Do we also read the attributes
   if ( myRead_attributes ) then
     call Read_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
       & 'FrequencyCoordinates', h5error, MLSAuxData)
     call Read_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
       & 'HorizontalCoordinates', h5error, MLSAuxData)
     call Read_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
       & 'VerticalCoordinates', h5error, MLSAuxData)
     call Read_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
       & 'Dimensions', h5error, MLSAuxData)
   endif
d2644 1
a2644 1
! Close all identifiers.
d2648 2
a2649 2
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )
 
d2652 1
a2652 1
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )
d2656 1
a2656 1
       H5_ERROR_DSET_CLOSE // trim(MLSAuxData%name) )
d2660 1
a2660 1
       H5_ERROR_PROPERTY_CLOSE // trim(MLSAuxData%name) )
d2663 1
a2663 1
  ! -------------------------------------------------  Write_MLSAuxData ----
d2665 1
a2665 1
    & write_attributes, string_length, index)
d2690 1
a2690 1
!--------------------------------------------------------------------------
d2696 1
a2696 1
    nullify(char_data, attr_data)
d2698 1
d2701 21
a2721 21
       rank = MLSAuxData%rank
       type_id = H5T_IEEE_F32LE
       if (present(index)) then 
       do i=1,rank-1
          dims(i) = size(MLSAuxData%RealField, i)
          chunk_dims(i) = dims(i)
          dims_create(i) = dims(i)
          maxdims(i) = dims(i)
       end do
          dims(rank) = 1
          chunk_dims(rank) = 1
          dims_create(rank) = 1
          maxdims(rank) = H5S_UNLIMITED_F
       else
       do i=1,rank
          dims(i) = size(MLSAuxData%RealField, i)
          chunk_dims(i) = dims(i)
          dims_create(i) = dims(i)
          maxdims(i) = dims(i)
       end do
       endif
d2723 1
d2726 21
a2746 21
       rank = MLSAuxData%rank
       type_id = H5T_NATIVE_DOUBLE
       if (present(index)) then 
       do i=1,rank-1
          dims(i) = size(MLSAuxData%DpField, i)
          chunk_dims(i) = dims(i)
          dims_create(i) = dims(i)
          maxdims(i) = dims(i)
       end do
          dims(rank) = 1
          chunk_dims(rank) = 1
          dims_create(rank) = 1
          maxdims(rank) = H5S_UNLIMITED_F
       else
       do i=1,rank
          dims(i) = size(MLSAuxData%DpField, i)
          chunk_dims(i) = dims(i)
          dims_create(i) = dims(i)
          maxdims(i) = dims(i)
       end do
       endif
d2751 21
a2771 21
       rank = MLSAuxData%rank
       type_id = H5T_NATIVE_INTEGER
       if (present(index)) then 
       do i=1,rank-1
          dims(i) = size(MLSAuxData%IntField, i)
          chunk_dims(i) = dims(i)
          dims_create(i) = dims(i)
          maxdims(i) = dims(i)
       end do
          dims(rank) = 1
          chunk_dims(rank) = 1
          dims_create(rank) = 1
          maxdims(rank) = H5S_UNLIMITED_F
       else
        do i=1,rank
          dims(i) = size(MLSAuxData%IntField, i)
          chunk_dims(i) = dims(i)
          dims_create(i) = dims(i)
          maxdims(i) = dims(i)
       enddo
       endif
d2776 21
a2796 21
       rank = MLSAuxData%rank
       type_id = H5T_NATIVE_CHARACTER
       if (present (index) ) then 
       do i=1, rank-1
          dims(i) = 1
          chunk_dims(i) = dims(i)
          dims_create(i) = dims(i)
          maxdims(i) = dims(i)
       end do
          dims(rank) = 1
          chunk_dims(rank) = 1
          dims_create(rank) = 1
          maxdims(rank) = H5S_UNLIMITED_F
       else
        do i=1,rank
          dims(i) = size(MLSAuxData%CharField, i)
          chunk_dims(i) = dims(i)
          dims_create(i) = dims(i)
          maxdims(i) = dims(i)
       enddo
       endif
d2806 1
a2806 2
    call h5eset_auto_f(1, h5error)

d2808 19
a2826 4
    call h5screate_simple_f(rank, dims_create(1:rank),dspace_id,h5error,& 
         maxdims(1:rank))
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name) )
d2828 1
a2828 3
    call h5pcreate_f(H5P_DATASET_CREATE_F,cparms,h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_PROPERTY_CREATE // trim(MLSAuxData%name) )
d2830 12
a2841 3
    call h5pset_chunk_f(cparms,rank,chunk_dims(1:rank),h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_PROPERTY_CHUNK_SET // trim(MLSAuxData%name) )
d2843 1
a2843 23
    if (trim(MLSAuxData%type_name).ne.'character') then
    
    call h5dcreate_f(file_id,trim(MLSAuxData%name),type_id,dspace_id, &
          dset_id,h5error,cparms)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSET_CREATE // trim(MLSAuxData%name) )

    else

     call h5tcopy_f(type_id, s_type_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_TYPE_COPY // trim(MLSAuxData%name))

     call h5tset_size_f(s_type_id, string_length, h5error)
     IF (h5error /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_TYPE_SET // trim(MLSAuxData%name))

     CALL h5dcreate_f(file_id, trim(MLSAuxData%name), s_type_id, &
       dspace_id, dset_id, h5error, cparms)
     IF (h5error /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_DSET_CREATE // trim(MLSAuxData%name))

    endif 
d2845 7
a2851 3
    call h5sclose_f( dspace_id, h5error )
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )
d2853 1
a2853 3
    call h5pclose_f( cparms,    h5error )
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_PROPERTY_CLOSE // trim(MLSAuxData%name) )
d2855 1
a2855 1
    endif
a2856 2
       if (associated(MLSAuxData%RealField)) then
 
d2858 1
a2858 1
 
d2864 1
a2864 1
       endif
d2866 1
a2866 1
       if (associated(MLSAuxData%DpField)) then 
d2875 1
a2875 1
       endif
d2877 1
a2877 1
       if (associated(MLSAuxData%CharField)) then 
d2887 3
a2889 3
       endif
    
       if (associated(MLSAuxData%IntField)) then 
d2898 1
a2898 1
       endif
d2902 1
a2902 1
    end do 
d2909 1
a2909 1
    endif 
d2913 1
a2913 1
       H5_ERROR_DSET_EXTEND // trim(MLSAuxData%name) )
d2917 1
a2917 1
       H5_ERROR_DSET_GETSPACE // trim(MLSAuxData%name) )
d2921 1
a2921 1
       H5_ERROR_DSET_GET_TYPE // trim(MLSAuxData%name) )
d2925 3
a2927 3
    call h5screate_simple_f(rank, dims_create(1:rank), memspace, h5error)
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name) )
d2929 1
a2929 2
    call h5sselect_hyperslab_f( & 
         filespace, H5S_SELECT_SET_F, start(1:rank), & 
d2932 1
a2932 1
       H5_ERROR_DSPACE_HYPERSLAB // trim(MLSAuxData%name) )
d2935 1
d2937 2
a2938 2
     call h5dwrite_f(dset_id, type_id, MLSAuxData%RealField, dims(1:rank), &
          h5error,memspace,filespace)
d2940 2
a2941 2
     call h5dwrite_f(dset_id, type_id, MLSAuxData%DpField, dims(1:rank), & 
          h5error,memspace,filespace)
d2943 2
a2944 2
     call h5dwrite_f(dset_id, type_id, MLSAuxData%IntField, dims(1:rank), &
          h5error,memspace,filespace)
d2946 11
a2956 12

    call h5tcopy_f(type_id, s_type_id, h5error)
     IF (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_TYPE_COPY // trim(MLSAuxData%name))

    call h5tset_size_f(s_type_id, string_length, h5error)
     IF (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_TYPE_SET // trim(MLSAuxData%name))

    call h5dwrite_f(dset_id, s_type_id, MLSAuxData%CharField, & 
         dims(1:rank), h5error,memspace,filespace)

d2959 2
a2960 2
    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSET_WRITE // trim(MLSAuxData%name) )
d2963 14
a2976 14
   if ( myWrite_attributes ) then
      if ( associated(MLSAuxData%FrequencyCoordinates)) & 
     call Write_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
       & 'FrequencyCoordinates', error, MLSAuxData)
      if ( associated(MLSAuxData%HorizontalCoordinates)) & 
     call Write_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
       & 'HorizontalCoordinates', error, MLSAuxData)
      if ( associated(MLSAuxData%VerticalCoordinates)) & 
     call Write_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
       & 'VerticalCoordinates', error, MLSAuxData)
      if ( associated(MLSAuxData%Dimensions)) & 
     call Write_MLSAuxAttributes(dset_id, trim(MLSAuxData%name), & 
       & 'Dimensions', error, MLSAuxData)
   endif
d2982 2
a2983 2
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )
 
d2986 1
a2986 1
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )
d2990 1
a2990 1
       H5_ERROR_DSET_CLOSE // trim(MLSAuxData%name) )
d3008 3
a3010 2
          MLSAuxData%FrequencyCoordinates(i) = dataset%FrequencyCoordinates(i)
       enddo 
d3015 3
a3017 2
          MLSAuxData%VerticalCoordinates(i) = dataset%VerticalCoordinates(i)
       enddo 
d3022 3
a3024 2
          MLSAuxData%HorizontalCoordinates(i) =dataset%HorizontalCoordinates(i)
       enddo 
d3068 3
@


2.18
log
@Helpful pre-nullifying of pointers
@
text
@d80 1
a80 1
    "$Id: MLSAuxData.f90,v 2.17 2002/11/25 05:35:35 jdone Exp $"
d226 1
a226 1
    type (MLSAuxData_T), dimension(:), pointer :: tempDatabase
d441 1
d451 12
a462 11
     if ( present (lastIndex)) then 
        if (lastIndex .eq. 1) then 
        call Write_MLSAuxData(file_id, MLSData, error, &
          write_attributes=.true., &  
             index=lastIndex)
        else
        call Write_MLSAuxData(file_id, MLSData, error, &
          write_attributes=.false., &  
             index=lastIndex)
        endif
     else
d464 2
a465 2
        call Write_MLSAuxData(file_id, MLSData, error, &
          write_attributes=.true.)
d467 1
a467 1
     endif
d470 1
a470 1
       'Error Writing MLSAuxData for '// trim(dataset%name) ) 
d472 1
d1717 1
a1717 1
    real, dimension(:), pointer :: attr_data
d2004 2
a2005 2
    character, dimension(:), pointer :: char_data
    real, dimension(:), pointer :: attr_data
d2174 2
a2175 2
    character(len=20), dimension(:), pointer :: char_data
    real, dimension(:), pointer :: attr_data
d2355 1
a2355 1
    character, dimension(:,:,:), pointer :: character_buffer
d2361 1
a2361 1
    integer, dimension(:,:,:), pointer :: integer_buffer
d2372 1
a2372 1
    nullify(character_buffer, real_buffer, double_buffer, integer_buffer)
d2503 8
a2510 8
         do k = FirstIndex, LastIndex
            do j = 1, dims(2)
               do i = 1, dims(1)
                  MLSAuxData%RealField(i,j,k) = real_buffer(i,j,k)
               end do 
            end do
         end do

a2511 1
        nullify(real_buffer)
a2539 1
        nullify(double_buffer)
a2566 1
        nullify(integer_buffer)
a2592 1
        nullify(character_buffer)
d2658 2
a2659 2
    character(len=1), dimension(:), pointer :: char_data
    real, dimension(:), pointer :: attr_data
d2724 1
d2748 1
d3042 3
@


2.17
log
@Added dimension names.
@
text
@d80 1
a80 1
    "$Id: MLSAuxData.f90,v 2.16 2002/11/11 19:20:25 jdone Exp $"
d1722 1
d2014 1
d2185 1
d2369 1
d2674 1
d3041 3
@


2.16
log
@name in DataProducts_T now has length of 80
@
text
@d7 1
a7 1

d9 2
a10 3
       H5T_NATIVE_INTEGER, H5T_IEEE_F32LE, H5S_UNLIMITED_F, &
       H5T_STD_I32LE, H5T_NATIVE_REAL, H5T_IEEE_F64LE, &
       H5P_DATASET_CREATE_F, H5S_SELECT_SET_F, &
d24 1
a24 1

d33 1
d36 16
d70 1
a70 1
! Deallocate_MLSAuxData        Called when an MLSAuxData is finished.
d77 1
a77 1
   & Build_MLSAuxData, DataProducts_T
d80 1
a80 1
    "$Id: MLSAuxData.f90,v 2.15 2002/10/31 22:12:49 jdone Exp $"
d92 1
d107 3
a189 4
  TYPE DataProducts_T
     CHARACTER(len=80) :: name, data_type
  END TYPE DataProducts_T

d193 2
a194 2
       Build_MLSAuxData_Double_1d, Build_MLSAuxData_Double_2d, &
       Build_MLSAuxData_Double_3d
d196 2
a197 1
       Build_MLSAuxData_Real_2d, Build_MLSAuxData_Real_3d
d199 15
a213 1
       Build_MLSAuxData_Integer_2d, Build_MLSAuxData_Integer_3d
d217 34
a250 1
  !------------------------------------------------------- Allocate_MLSAuxData
d296 1
a296 1
  !-------------------------------------------  Deallocate_MLSAuxData  -----
d305 1
a305 1
    if ( status /= 0 ) then
d309 1
a309 2
    endif

d314 1
a314 1
    if ( status /= 0 ) then
d318 1
a318 2
    endif

d323 1
a323 1
    if ( status /= 0 ) then
d327 1
a327 2
    endif

d332 1
a332 1
    if ( status /= 0 ) then
d336 1
a336 1
    endif
d341 1
a341 1
    if ( status /= 0 ) then
d345 1
a345 2
    endif

d350 1
a350 1
    if ( status /= 0 ) then
d354 1
a354 2
    endif

d359 1
a359 2

    if ( status /= 0 ) then
d363 1
d366 7
d376 1
a376 1
  !------------------------------------------------------- Build_MLSAuxData
d378 1
a378 1
      noMAF, char_length)
d381 2
a382 1
    integer, intent(in) :: char_length, noMAF
d387 1
a387 1
    integer :: error
d396 1
d398 22
a419 2
     call Write_MLSAuxData(file_id, MLSData, error, noMAF, .false., & 
          char_length)
d424 1
a424 1
!----------------------------------------------------------------------
d426 1
a426 1
      noMAF)
d429 1
a429 2

    integer, intent(in) :: noMAF
d434 1
a434 1
    integer :: error
d443 1
d445 22
a466 1
     call Write_MLSAuxData(file_id, MLSData, error, noMAF)
d471 2
a472 2
!-----------------------------------------------------------------------
 subroutine Build_MLSAuxData_Real( file_id, dataset, real_data, noMAF)
d475 1
a475 1
    integer, intent(in) :: noMAF
d480 1
a480 1
    integer :: error
d489 1
d491 16
a506 1
     call Write_MLSAuxData(file_id, MLSData, error, noMAF)
d511 2
a512 2
!-----------------------------------------------------------------------
 subroutine Build_MLSAuxData_Double( file_id, dataset, double_data, noMAF)
d515 1
a515 1
    integer, intent(in) :: noMAF
d520 1
a520 1
    integer :: error
d530 19
a548 1
     call Write_MLSAuxData(file_id, MLSData, error, noMAF)
d553 2
a554 2
!-----------------------------------------------------------------------
 subroutine Build_MLSAuxData_Real_1d( file_id, dataset, real_data, noMAF, &
d559 1
a559 1
    integer, intent(in) :: noMAF
d564 1
a564 1
    integer :: i,error
d585 23
a607 1
       enddo
a608 1
     call Write_MLSAuxData(file_id, MLSData, error, noMAF)
d613 3
a615 3
!-----------------------------------------------------------------------
 subroutine Build_MLSAuxData_Double_1d( file_id, dataset, double_data, noMAF, &
      dims)
d619 1
a619 1
    integer, intent(in) :: noMAF
d624 1
a624 1
    integer :: i,error
d642 1
a642 1

d647 22
a668 1
     call Write_MLSAuxData(file_id, MLSData, error, noMAF)
d673 1
a673 1
!-----------------------------------------------------------------------
d675 1
a675 1
      noMAF, dims)
d679 1
a679 1
    integer, intent(in) :: noMAF
d684 1
a684 1
    integer :: i,j,error
d707 22
a728 1
     call Write_MLSAuxData(file_id, MLSData, error, noMAF)
d733 2
a734 2
!-----------------------------------------------------------------------
 subroutine Build_MLSAuxData_Real_2d( file_id, dataset, real_data, noMAF, &
d739 1
a739 1
    integer, intent(in) :: noMAF
d744 1
a744 1
    integer :: i,j,k,error
d769 22
a790 1
     call Write_MLSAuxData(file_id, MLSData, error, noMAF)
d795 3
a797 3
!-----------------------------------------------------------------------
 subroutine Build_MLSAuxData_Double_2d( file_id, dataset, double_data, noMAF, &
      dims)
d801 1
a801 1
    integer, intent(in) :: noMAF
d806 1
a806 1
    integer :: i,j,error
d825 1
d832 22
a853 1
     call Write_MLSAuxData(file_id, MLSData, error, noMAF)
d858 1
a858 1
!-----------------------------------------------------------------------
d860 1
a860 1
      noMAF, dims)
d864 1
a864 1
    integer, intent(in) :: noMAF
d869 1
a869 1
    integer :: i,j,error
d894 22
a915 1
     call Write_MLSAuxData(file_id, MLSData, error)
d920 1
a920 1
!-----------------------------------------------------------------------
d930 1
a930 1
    integer :: i,j,k,error
d949 2
d959 5
a963 1
     call Write_MLSAuxData(file_id, MLSData, error)
d968 1
a968 1
!-----------------------------------------------------------------------
d978 1
a978 1
    integer :: i,j,k,error
d996 3
d1007 4
a1010 1
     call Write_MLSAuxData(file_id, MLSData, error)
d1015 1
a1015 1
!-----------------------------------------------------------------------
d1024 1
a1024 1
    integer :: i,j,k,error
d1043 2
d1053 4
a1056 1
     call Write_MLSAuxData(file_id, MLSData, error)
d1061 59
a1119 13
!-----------------------------------------------------------------------
  subroutine CreateGroup_MLSAuxData(loc_id, group_name, subgroup_name)
!
! External variables
!
    character(len=*), intent(in) :: group_name
    character(len=*), intent(in), optional :: subgroup_name
    integer(hid_t), intent(in)   :: loc_id ! From HDF
!
! Internal variables
!
    integer(hid_t) :: group_id, subgroup_id
    integer :: h5error
d1121 2
a1122 1
    if ( .not. present(subgroup_name) ) then 
d1124 4
a1127 3
     call h5gcreate_f(loc_id, trim(group_name), group_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_CREATE // trim(group_name))
d1129 7
a1135 3
     call h5gclose_f(group_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_CLOSE // trim(group_name)) 
d1137 3
a1139 1
    else
d1141 3
a1143 3
     call h5gopen_f(loc_id, trim(group_name), group_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_OPEN // trim(group_name))
d1145 3
a1147 3
     call h5gcreate_f(group_id, trim(subgroup_name), subgroup_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_CREATE // trim(subgroup_name))
d1149 4
a1152 3
     call h5gclose_f(subgroup_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_CLOSE // trim(subgroup_name)) 
d1154 539
a1692 3
     call h5gclose_f(group_id, h5error)
     if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
      H5_ERROR_GROUP_CLOSE // trim(group_name)) 
d1824 1
d2000 1
d2007 1
d2011 1
d2025 1
d2033 1
d2041 1
d2047 12
d2079 15
a2093 1
    arank = 1
d2105 2
d2116 2
d2134 1
d2140 9
d2169 1
d2176 2
a2177 1
    integer :: which_opt_arg, i, arank, h5error, status  
d2182 1
a2191 1
!        arank = size(shape(MLSAuxData%FrequencyCoordinates))
a2203 1
!        arank = size(shape(MLSAuxData%HorizontalCoordinates))
a2215 1
!        arank = size(shape(MLSAuxData%VerticalCoordinates))
d2227 13
a2244 1
!        arank = size(shape(AttributeData))
d2251 34
a2284 1
        endif
d2286 1
a2286 9
        do i=1,adims(1)
           attr_data(i) = AttributeData(i)
        end do
    case default
      error = 1
      return
    end select
    adims_create(1) = adims(1)                                         
    call h5screate_simple_f(arank, adims_create(1:arank), aspace_id, h5error)  
d2288 1
a2288 1
        H5_ERROR_DSPACE_CREATE // trim(AttributeName) // ' in ' // & 
d2291 2
d2304 2
d2316 1
d2322 9
d2335 1
a2335 1
       MLSAuxData, error, FirstMAF, LastMAF, read_attributes)
d2343 2
a2344 3
    integer, intent(out)                          :: error   ! 0 unless trouble
    integer, intent(in), optional  :: FirstMAF ! First to read (default 0)
    integer, intent(in), optional  :: LastMAF  ! Last to read 
d2384 2
d2466 1
a2466 1
    if ( .NOT.(PRESENT(FirstMAF) ) ) then 
d2496 1
a2496 1
         do k = FirstMAF, LastMAF
d2525 1
a2525 1
         do k = FirstMAF, LastMAF
d2553 1
a2553 1
         do k = FirstMAF, LastMAF
d2580 1
a2580 1
         do k = FirstMAF, LastMAF
d2614 2
d2639 1
a2639 1
    & number_MAF, write_attributes, string_length)
d2647 1
a2647 1
    integer, intent(in), optional  :: number_MAF ! number of major frames
d2655 1
d2663 1
a2665 2
    logical :: myWrite_attributes

d2673 1
a2673 1
       rank = size(shape(MLSAuxData%RealField))
d2675 1
d2686 9
a2694 1
       end if
d2697 1
a2697 1
       rank = size(shape(MLSAuxData%DpField))
d2699 1
d2710 8
d2721 1
a2721 1
       rank = size(shape(MLSAuxData%IntField))
d2723 1
d2734 8
d2745 1
a2745 1
       rank = size(shape(MLSAuxData%CharField))
d2747 1
d2758 8
d2813 1
a2813 155
    endif
 
!---------------- write the attributes -----------------------------

    if (present(write_attributes)) then 

     if (write_attributes) then 

    do i = 2, 7
       adims(i) = 0
    end do

    if (associated(MLSAuxData%HorizontalCoordinates)) then 

       arank = size(shape(MLSAuxData%HorizontalCoordinates))
       atype_id = H5T_IEEE_F32LE
       adims(1) = size(MLSAuxData%HorizontalCoordinates)
       adims_create(1) = adims(1)

       allocate(attr_data(adims(1)),STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_Allocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

       do i=1, adims(1)
          attr_data(i) = MLSAuxData%HorizontalCoordinates(i)
       end do

       aname = "HorizontalCoordinates"  

       call h5screate_simple_f(arank, adims_create, aspace_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CREATE // trim(aname) // ' in ' // & 
       trim(MLSAuxData%name) )

       call h5acreate_f(dset_id, trim(aname), atype_id, aspace_id, attr_id, &
          h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CREATE // trim(aname) // ' in ' // &
       trim(MLSAuxData%name) )

       call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_WRITE // trim(MLSAuxData%name)  )

       call h5aclose_f(attr_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CLOSE // trim(MLSAuxData%name) )

       call h5sclose_f(aspace_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )

       deallocate(attr_data,STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_deallocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

    endif

    if (associated(MLSAuxData%VerticalCoordinates)) then 
       arank = size(shape(MLSAuxData%VerticalCoordinates))
       atype_id = H5T_IEEE_F32LE
       adims(1) = size(MLSAuxData%VerticalCoordinates)
       adims_create(1) = adims(1)

       allocate(attr_data(adims(1)),STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_allocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

       do i=1,adims(1)
          attr_data(i) = MLSAuxData%VerticalCoordinates(i)
       end do

       call h5screate_simple_f(arank, adims_create, aspace_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name) )

       aname = "VerticalCoordinates"   
       call h5acreate_f(dset_id, trim(aname), atype_id, aspace_id, attr_id, &
          h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CREATE // trim(MLSAuxData%name) )

       call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_WRITE // trim(MLSAuxData%name) )

       call h5aclose_f(attr_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CLOSE // trim(MLSAuxData%name) )

       call h5sclose_f(aspace_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )
 
       deallocate(attr_data,STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_deallocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

    endif

    if (associated(MLSAuxData%FrequencyCoordinates)) then 
       arank = size(shape(MLSAuxData%FrequencyCoordinates))
       atype_id = H5T_IEEE_F32LE
       adims(1) = size(MLSAuxData%FrequencyCoordinates)
       adims_create(1) = adims(1)

       allocate(attr_data(adims(1)),STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_allocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

       do i=1,adims(1)
          attr_data(i) = MLSAuxData%FrequencyCoordinates(i)
       end do

       call h5screate_simple_f(arank, adims_create, aspace_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CREATE // trim(MLSAuxData%name) )

       aname = "FrequencyCoordinates"
       call h5acreate_f(dset_id, trim(aname), atype_id, aspace_id, attr_id, &
          h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CREATE // trim(MLSAuxData%name) )

       call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_WRITE // trim(MLSAuxData%name) )

       call h5aclose_f(attr_id, h5error)
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_ATT_CLOSE // trim(MLSAuxData%name) )

       call h5sclose_f(aspace_id, h5error) 
       if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
       H5_ERROR_DSPACE_CLOSE // trim(MLSAuxData%name) )

       deallocate(attr_data,STAT=status)
       if ( status /= 0 ) then
           msr = MLSMSG_deallocate// ' attr_data.'
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
      endif
     endif
    endif

d2826 2
a2827 2
       
       rank = size(shape(MLSAuxData%RealField))
d2838 1
a2838 1
       rank = size(shape(MLSAuxData%DpField))
d2849 1
a2849 1
       rank = size(shape(MLSAuxData%CharField))
d2861 1
a2861 1
       rank = size(shape(MLSAuxData%IntField))
d2874 5
a2878 5
    if (PRESENT(number_MAF)) then 
       start(rank) = number_MAF-1
       dims_create(rank) = number_MAF
       dims(rank) = number_MAF
       chunk_dims(rank) = number_MAF
a2928 28
!    test_type_dims: select case (trim(MLSAuxData%type_name))
!    case ('real')
!    call h5dwrite_f(dset_id,type_id,& 
!         MLSAuxData%RealField(1:dims(1),1:dims(2),startMAF:dims(3)),& 
!         dims(1:rank),h5error,memspace,filespace)
!    case ('double')    
!    call h5dwrite_f(dset_id,type_id,& 
!         MLSAuxData%DpField(1:dims(1),1:dims(2),startMAF:dims(3)),& 
!         dims(1:rank),h5error,memspace,filespace)
!    case ('integer')  
!    call h5dwrite_f(dset_id,type_id,&
!         MLSAuxData%IntField(1:dims(1),1:dims(2),startMAF:dims(3)),&         
!         dims(1:rank),h5error,memspace,filespace)
!    case ('character') 
!
!    call h5tcopy_f(type_id, s_type_id, h5error)
!     IF (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!      H5_ERROR_TYPE_COPY // trim(MLSAuxData%name))
!
!    call h5tset_size_f(s_type_id, string_length, h5error)
!     IF (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!      H5_ERROR_TYPE_SET // trim(MLSAuxData%name))
!
!    call h5dwrite_f(dset_id,type_id,&
!         MLSAuxData%CharField(1:dims(1),1:dims(2),startMAF:dims(3)),&     
!         dims(1:rank),h5error,memspace,filespace)
!    end select test_type_dims    
!    endif
d2932 1
d2935 1
d2938 1
d2941 1
d2944 3
d2965 64
d3036 3
@


2.15
log
@Added Build_MLSAuxData.
@
text
@d64 1
a64 1
    "$Id: MLSAuxData.f90,v 2.14 2002/10/24 03:19:00 jdone Exp $"
d171 1
a171 1
     CHARACTER(len=18) :: name, data_type
d2132 3
@


2.14
log
@subroutine Allocate_MLSAuxData added.
@
text
@d60 2
a61 1
   & Write_MLSAuxAttributes, CreateGroup_MLSAuxData, Allocate_MLSAuxData
d64 1
a64 1
    "$Id: MLSAuxData.f90,v 2.13 2002/10/21 22:10:32 jdone Exp $"
d169 16
a184 1
  
d310 465
a774 1
!-----------------------------------------------------------
d2132 3
@


2.13
log
@inclusion of string types for i/o
@
text
@d58 3
a60 7

  public :: MLSAuxData_T, Create_MLSAuxData, Read_MLSAuxData, &
      & Write_MLSAuxData, Deallocate_MLSAuxData, &
      & Read_MLSAuxAttributes, Write_MLSAuxAttributes, &
      & CreateGroup_MLSAuxData, &
      & NAME_LEN

d63 1
a63 1
    "$Id: MLSAuxData.f90,v 2.12 2002/10/08 00:09:11 pwagner Exp $"
d69 1
a69 1

d71 2
a72 2
  integer, parameter :: NAME_LEN = 64  ! Max len of SDS array name

d74 2
a75 11
    character (len=name_len) :: name       ! Name of field in file
    character (len=name_len) :: type_name  ! Name of type

    integer :: FrequencyDimension          ! Enumerated type
    integer :: VerticalDimension           ! Enumerated type  
    integer :: HorizontalDimension         ! Enumerated type

    real(r8), dimension(:), pointer :: FrequencyCoordinates  => NULL()
    real(r8), dimension(:), pointer :: VerticalCoordinates   => NULL()
    real(r8), dimension(:), pointer :: HorizontalCoordinates => NULL()

a79 1

d81 8
d90 1
a90 1

d170 36
d207 9
d340 2
a341 1
  subroutine Create_MLSAuxData(file_id, MLSAuxData, string_length)
d350 1
a362 3
    logical :: is_hdf5
    logical, parameter ::  ATTRIBUTE = .FALSE.

a363 1

d441 2
a442 2
     CALL h5tcopy_f(type_id, s_type_id, h5error)
     IF (h5error /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
d446 1
a446 1
     IF (h5error /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
d449 1
a449 1
     CALL h5dcreate_f(file_id, trim(MLSAuxData%name), s_type_id, &
d451 1
a451 1
     IF (h5error /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
d458 4
d466 1
a466 1
    if (associated(MLSAuxData%HorizontalCoordinates) .and. ATTRIBUTE) then 
d516 1
a516 1
    if (associated(MLSAuxData%VerticalCoordinates) .and. ATTRIBUTE) then 
d562 1
a562 1
    if (associated(MLSAuxData%FrequencyCoordinates) .and. ATTRIBUTE) then 
d605 3
a608 1
    endif
a638 1

d642 2
a643 2
    integer(hsize_t), dimension(7) :: adims
    
d646 2
a647 4
    integer :: which_opt_arg
    integer(hid_t) :: attr_id, atype_id, aspace_id
    integer :: i, arank, h5error, status

a763 3
    integer, parameter :: OPTARGISMAD = 1
    integer, parameter :: OPTARGISARR = 2
    integer :: which_opt_arg
d768 4
a771 1
    integer :: i, arank, h5error, status
d894 1
d896 2
d899 1
a900 2
    character, dimension(:,:,:), pointer :: character_buffer

d905 1
d908 1
a908 2
    character(len=16) :: myQuantityType

a976 2
      elseif ( is_character ) then
        myQuantityType = 'character'
d981 2
d1025 1
a1202 2
    logical :: is_hdf5
    logical, parameter ::  ATTRIBUTE = .FALSE.
a1261 1
!          dims(i) = size(MLSAuxData%CharField, i)
d1305 2
a1306 2
     CALL h5tcopy_f(type_id, s_type_id, h5error)
     IF (h5error /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
d1322 4
d1330 1
a1330 1
    if (associated(MLSAuxData%HorizontalCoordinates) .and. ATTRIBUTE) then 
d1380 1
a1380 1
    if (associated(MLSAuxData%VerticalCoordinates) .and. ATTRIBUTE) then 
d1426 1
a1426 1
    if (associated(MLSAuxData%FrequencyCoordinates) .and. ATTRIBUTE) then 
d1469 3
a1472 1
    endif
d1584 2
a1585 2
    call h5dwrite_f(dset_id, s_type_id, MLSAuxData%CharField, dims(1:rank), &
          h5error,memspace,filespace)
a1587 1

a1618 1

d1622 1
a1622 1
       & 'FrequencyCoordinates', h5error, MLSAuxData)
d1624 1
a1624 1
       & 'HorizontalCoordinates', h5error, MLSAuxData)
d1626 1
a1626 1
       & 'VerticalCoordinates', h5error, MLSAuxData)
a1627 1

d1652 3
@


2.12
log
@Added idents to survive zealous Lahey optimizer
@
text
@d19 2
a20 1
       h5tequal_f, h5fis_hdf5_f, h5eset_auto_f, h5gcreate_f, h5gclose_f
d40 1
a40 1
! CreateGroup_MLSAuxData       Creates a Group in a file. 
d62 1
a62 1
      & CreateGroup_MLSAuxData,&
d67 1
a67 1
    "$Id: MLSAuxData.f90,v 2.11 2002/10/05 01:03:08 jdone Exp $"
d89 1
a89 1
    character, dimension(:,:,:), pointer :: CharField        => NULL()
d256 1
a256 1
  subroutine CreateGroup_MLSAuxData(loc_id, group_name)
d261 2
a262 1
    integer(hid_t), intent(in)          :: loc_id ! From HDF
d266 1
a266 1
    integer(hid_t) :: group_id
d269 2
d273 19
a291 1
      H5_ERROR_GROUP_CREATE // group_name)
d295 3
a297 1
      H5_ERROR_GROUP_CLOSE // group_name) 
d301 1
a301 1
  subroutine Create_MLSAuxData(file_id, MLSAuxData)
d309 1
d320 1
a320 1
         attr_id, atype_id, aspace_id
d395 2
d401 18
d744 2
a745 1
        arank = size(shape(MLSAuxData%FrequencyCoordinates))
d757 2
a758 1
        arank = size(shape(MLSAuxData%HorizontalCoordinates))
d770 2
a771 1
        arank = size(shape(MLSAuxData%VerticalCoordinates))
d787 2
a788 1
        arank = size(shape(AttributeData))
d804 1
a804 1
    call h5screate_simple_f(arank, adims_create, aspace_id, h5error)   
d1137 1
a1137 1
    & startMAF, write_attributes)
d1145 3
a1147 2
    integer, intent(in), optional  :: startMAF ! First to write (default 0)
    logical, intent(in), optional  :: write_attributes  ! write freqCoords, etc 
d1158 1
a1158 1
         attr_id, atype_id, aspace_id, filespace, memspace 
d1179 1
a1179 1
          maxdims(i) = chunk_dims(i)
d1194 1
a1194 1
          maxdims(i) = chunk_dims(i)
d1209 1
a1209 1
          maxdims(i) = chunk_dims(i)
d1221 2
a1222 1
          dims(i) = size(MLSAuxData%CharField, i)
d1225 1
a1225 1
          maxdims(i) = chunk_dims(i)
d1256 2
d1261 19
a1279 1
       H5_ERROR_DSET_CREATE // trim(MLSAuxData%name) ) 
d1438 2
a1439 1
       if (associated(MLSAuxData%RealField)) then 
d1441 1
d1450 1
d1452 1
d1461 1
d1463 1
d1465 3
a1467 3
          dims_create(i) = size(MLSAuxData%CharField,i)
          dims(i) = dims_create(i)
          chunk_dims(i) = dims(i)
d1469 1
d1473 1
d1475 1
a1485 1
    if (PRESENT(startMAF)) start(rank) = startMAF-1
d1487 8
a1494 1
    call h5dextend_f(dset_id, dims_create(1:rank), h5error)
d1506 2
a1517 2
    if ( .NOT.( PRESENT(startMAF) ) ) then 

d1529 10
a1538 1
     call h5dwrite_f(dset_id, type_id, MLSAuxData%CharField, dims(1:rank), &
d1540 1
d1543 28
a1570 23
    else

    print *,'Does not yet handle optional MAF I/O.'

    test_type_dims: select case (trim(MLSAuxData%type_name))
    case ('real')
    call h5dwrite_f(dset_id,type_id,& 
         MLSAuxData%RealField(1:dims(1),1:dims(2),startMAF:dims(3)),& 
         dims,h5error,memspace,filespace)
    case ('double')    
    call h5dwrite_f(dset_id,type_id,& 
         MLSAuxData%DpField(1:dims(1),1:dims(2),startMAF:dims(3)),& 
         dims,h5error,memspace,filespace)
    case ('integer')  
    call h5dwrite_f(dset_id,type_id,&
         MLSAuxData%IntField(1:dims(1),1:dims(2),startMAF:dims(3)),&         
         dims,h5error,memspace,filespace)
    case ('character') 
    call h5dwrite_f(dset_id,type_id,&
         MLSAuxData%CharField(1:dims(1),1:dims(2),startMAF:dims(3)),&     
         dims,h5error,memspace,filespace)
    end select test_type_dims    
    endif
d1609 3
@


2.11
log
@Create_MLSAuxData updated to reduce memory.
@
text
@d66 1
a66 1
    "$Id: MLSAuxData.f90,v 2.10 2002/10/05 00:52:50 jdone Exp $"
d70 1
d1501 4
d1508 3
@


2.10
log
@CreateGroup_MLSAuxData added.
@
text
@d66 1
a66 1
    "$Id: MLSAuxData.f90,v 2.9 2002/10/05 00:30:20 jdone Exp $"
d306 1
a306 1
       do i=1,rank
d311 2
d319 1
a319 1
       do i=1,rank
d324 2
d332 1
a332 1
       do i=1,rank
d337 2
d345 1
a345 1
       do i=1, rank
d350 2
d1503 3
@


2.9
log
@Write_MLSAuxData creates & writes dataset if not already created.
@
text
@d19 1
a19 1
       h5tequal_f, h5fis_hdf5_f, h5eset_auto_f
a29 1

a32 1

d61 1
d66 1
a66 1
    "$Id: MLSAuxData.f90,v 2.8 2002/10/04 22:35:31 jdone Exp $"
d253 22
d1495 3
@


2.8
log
@Added exception handling for h5tequal_f call
@
text
@d19 1
a19 1
       h5tequal_f, h5fis_hdf5_f
d37 2
a38 1
! Allocate_MLSAuxData          Allocates a MLSAuxData data structure. 
d40 3
d45 1
d48 1
d51 1
d54 1
d67 1
a67 1
    "$Id: MLSAuxData.f90,v 2.7 2002/10/04 22:13:30 jdone Exp $"
d269 1
a270 1
    integer(hsize_t), dimension(7) :: adims
a343 1

d1071 11
a1081 6
    integer(hsize_t), dimension(7) :: dims
    integer(hsize_t), dimension(3) :: dims_create, start

    integer(hid_t) :: filespace, memspace, dset_id, type_id
    integer :: h5error, rank, i

d1089 66
d1156 172
d1329 7
a1335 1
       H5_ERROR_DSET_OPEN // trim(MLSAuxData%name) )
d1342 1
d1351 1
d1360 1
d1369 1
d1402 1
a1402 1
    test_type: select case (trim(MLSAuxData%type_name))
d1415 1
a1415 1
    end select test_type
d1474 3
@


2.7
log
@Replace == for types with h5tequal_f
@
text
@d19 1
a19 1
       h5tequal_f
d59 1
a59 1
    "$Id: MLSAuxData.f90,v 2.6 2002/10/03 22:15:37 jdone Exp $"
d129 2
d267 1
d777 2
a778 2
    logical :: myRead_attributes, is_integer, is_real, is_double, is_character, &
         is_int32, is_float32, is_float64
d844 3
d1214 3
@


2.6
log
@check hdf5 error flags that return rank
@
text
@d18 2
a19 1
       h5tset_size_f, h5aopen_name_f, h5aget_type_f, h5aget_space_f
d59 1
a59 1
    "$Id: MLSAuxData.f90,v 2.5 2002/09/27 23:37:54 pwagner Exp $"
d774 2
a775 1
    logical :: myRead_attributes
d822 20
a841 1
      if ( type_id == H5T_NATIVE_INTEGER .or. type_id == H5T_STD_I32LE ) then
d843 1
a843 1
      elseif ( type_id == H5T_NATIVE_CHARACTER ) then
d845 1
a845 1
      elseif ( type_id == H5T_NATIVE_REAL .or. type_id == H5T_IEEE_F32LE ) then
d847 1
a847 1
      elseif ( type_id == H5T_NATIVE_DOUBLE .or. type_id == H5T_IEEE_F64LE ) then
d853 1
d1208 3
@


2.5
log
@More progress toward hdf5-capable l1b files
@
text
@d21 2
d58 1
a58 1
    "$Id: MLSAuxData.f90,v 2.4 2002/09/26 23:58:04 pwagner Exp $"
d94 2
d114 2
d121 2
d169 1
d172 1
a172 2
    if (associated(MLSAuxData%RealField)) then 
        nullify(MLSAuxData%RealField)
d174 6
a179 1
! check on status.
a182 1
        nullify(MLSAuxData%IntField)
d184 6
a189 1
! check on status.
a192 1
        nullify(MLSAuxData%CharField)
d194 6
a199 1
! check on status.
a202 1
        nullify(MLSAuxData%DpField)
d204 5
a208 1
! check on status.
a211 1
        nullify(MLSAuxData%FrequencyCoordinates)
d213 6
a218 1
! check on status.
a221 1
        nullify(MLSAuxData%VerticalCoordinates)
d223 6
a228 1
! check on status.
a231 1
        nullify(MLSAuxData%HorizontalCoordinates)
d233 7
a239 1
! check on status.
d251 1
a251 1
    integer(hid_t), intent(in)     :: file_id ! From HDF
d255 1
d261 1
a261 1
   integer(hid_t) :: cparms,dspace_id,dset_id,type_id, &
d263 1
a263 1
    integer :: i, rank_MAF, rank, arank, h5error
d265 1
d276 1
a276 1
          maxdims(i) = H5S_UNLIMITED_F
d278 1
d287 1
a287 1
          maxdims(i) = H5S_UNLIMITED_F
d289 1
d298 1
a298 1
          maxdims(i) = H5S_UNLIMITED_F
d300 1
d309 1
a309 1
          maxdims(i) = H5S_UNLIMITED_F
d311 1
d317 2
a318 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_CREATE // QuantityName )
d321 2
a322 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_PROPERTY_CREATE // QuantityName )
d325 2
a326 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_PROPERTY_CHUNK_SET // QuantityName )
d330 2
a331 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_CREATE // QuantityName ) 
a332 6
!    A question:
! Is it better to do this here in a routine that creates the
! MLSAuxData, or to do it in Write_MLSAuxData ?
! For now we leave it here
! ( Might even break it out into its own separate routines:
!   Read_MLSAuxAttributes and Write_MLSAuxAttributes? )
d345 7
a351 1
       allocate(attr_data(adims(1)))
d356 2
d359 4
a362 1
       aname = "HorizontalCoordinates"  
d365 4
d370 3
d374 3
d378 9
a386 1
       deallocate(attr_data)
d394 7
a400 1
       allocate(attr_data(adims(1)))
d406 3
d412 3
d416 3
d420 13
a432 2
       call h5sclose_f(aspace_id, h5error) 
       deallocate(attr_data)
d440 7
a446 1
       allocate(attr_data(adims(1)))
d452 3
d458 3
d462 3
d466 3
d470 9
a478 1
       deallocate(attr_data)
d483 2
a484 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_CLOSE // QuantityName )
d487 2
a488 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_CLOSE // QuantityName )
d491 2
a492 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_PROPERTY_CLOSE // QuantityName )
d495 1
a495 1
!-------------------------------------------------Read_MLSAuxAttributes ----
a497 1
  !
d512 4
d519 3
a521 6
    real, dimension(:), pointer :: attr_data
    integer(hsize_t), dimension(7) :: adims
    integer(hsize_t), dimension(1) :: adims_create
    integer(hid_t) :: cparms,dspace_id,type_id, &
         attr_id, atype_id, aspace_id
    integer :: i, rank_MAF, rank, arank, h5error
d566 1
d568 4
d573 3
d577 6
a582 1
    allocate(attr_data(adims(1)))
d584 4
a587 4
  ! > >     print *, 'reading attribute ' // trim(AttributeName)
  ! > >     print *, 'adims(1) ', adims(1)
  ! > >     print *, 'attr_data ', attr_data
  ! > >     print *, 'h5error ', h5error
d598 1
d602 1
d604 4
d609 10
a618 2
    deallocate(attr_data)
    error = h5error                                              
a635 1

d637 1
d644 2
a645 3
    integer(hid_t) :: cparms,dspace_id,type_id, &
         attr_id, atype_id, aspace_id
    integer :: i, rank_MAF, rank, arank, h5error
d660 6
a665 1
        allocate(attr_data(adims(1)))
d672 6
a677 1
        allocate(attr_data(adims(1)))
d684 6
a689 1
        allocate(attr_data(adims(1)))
d700 6
a705 1
        allocate(attr_data(adims(1)))
d715 4
d721 4
d726 4
a729 4
  ! > >     print *, 'writing attribute ' // trim(AttributeName)
  ! > >     print *, 'adims(1) ', adims(1)
  ! > >     print *, 'attr_data ', attr_data
  ! > >     print *, 'h5error ', h5error
d731 4
d736 10
a745 2
    deallocate(attr_data)
    error = h5error                                              
d764 1
d769 1
a769 1
    integer(hsize_t), dimension(7) :: dims, adims
d771 1
a771 2
    integer(hid_t) :: cparms, dset_id, dspace_id, type_id, memspace, & 
         attr_id, atype_id, aspace_id
a783 1
!---
d785 2
a786 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_OPEN // trim(QuantityName) )
d789 2
a790 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_CREATE // trim(QuantityName) )
d793 2
a794 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_GET_NDIMS // trim(QuantityName) )
d798 3
a800 3
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_GET_DIMS // trim(QuantityName) )
!
d802 2
a803 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_CREATE // trim(QuantityName) )
d806 2
a807 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_PROPERTY_GET // trim(QuantityName) )
d810 2
a811 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_CREATE // trim(QuantityName) )
d814 2
a815 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_TYPE // trim(QuantityName) )
d820 1
a820 6
  ! While case select seemed most natural here, these H5T_..
  ! unfortunately are not initialization expressions; therefore
  ! must use clunky old if elseif blocks
  !    select case (type_id)
  !    case (H5T_STD_I32LE, H5T_NATIVE_INTEGER)
      if ( type_id == H5T_STD_I32LE .or. type_id == H5T_STD_I32LE ) then
a821 1
  !    case (H5T_NATIVE_CHARACTER)
a823 1
  !    case (H5T_NATIVE_REAL, H5T_IEEE_F32LE)
a825 1
  !    case (H5T_NATIVE_DOUBLE, H5T_IEEE_F64LE)
a827 1
  !    case default
a830 1
  !    end select
d848 2
d858 1
a858 1
         h5error, memspace, dspace_id)
d861 1
a861 1
         h5error,memspace, dspace_id)
d864 1
a864 1
         h5error,memspace, dspace_id)
d874 5
d881 1
d893 6
d904 5
d922 6
d932 5
d950 4
d958 6
d977 6
d989 2
a990 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_READ // trim(QuantityName) )
d994 1
a994 1
     call Read_MLSAuxAttributes(dset_id, trim(QuantityName), & 
d996 1
a996 1
     call Read_MLSAuxAttributes(dset_id, trim(QuantityName), & 
d998 1
a998 1
     call Read_MLSAuxAttributes(dset_id, trim(QuantityName), & 
a1000 1

d1005 2
a1006 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_CLOSE // trim(QuantityName) )
d1009 2
a1010 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_CLOSE // trim(QuantityName) )
d1013 2
a1014 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_CLOSE // trim(QuantityName) )
d1017 2
a1018 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_PROPERTY_CLOSE // trim(QuantityName) )
a1035 1

d1039 1
a1039 2
    integer(hid_t) :: filespace, memspace, dset_id, dspace_id, type_id

d1050 2
a1051 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_OPEN // trim(QuantityName) )
d1091 2
a1092 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_EXTEND // trim(QuantityName) )
d1095 2
a1096 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_GET // trim(QuantityName) )
d1099 2
a1100 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_GET_TYPE // trim(QuantityName) )
d1103 2
a1104 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_CREATE // trim(QuantityName) )
d1109 2
a1110 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_HYPERSLAB // trim(QuantityName) )
d1153 2
a1155 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_WRITE // trim(QuantityName) )
d1170 2
a1171 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_CLOSE // trim(QuantityName) )
d1174 2
a1175 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSPACE_CLOSE // trim(QuantityName) )
d1178 2
a1179 2
!    if (h5error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, & 
!       H5_ERROR_DSET_CLOSE // trim(QuantityName) )
d1186 3
@


2.4
log
@Moved attributes out of create function; standalone attribute io, too
@
text
@d24 1
d46 1
d56 1
a56 1
    "$Id: MLSAuxData.f90,v 2.3 2002/09/09 05:43:39 jdone Exp $"
d648 1
a648 1
      elseif ( type_id == H5T_NATIVE_CHARACTER ) then
d651 1
a651 1
      elseif ( type_id == H5T_NATIVE_CHARACTER ) then
d970 3
@


2.3
log
@deallocate statements added for read buffers.
@
text
@d10 1
d19 2
d35 2
d39 2
d48 3
a50 2
      Write_MLSAuxData, Deallocate_MLSAuxData,&
      NAME_LEN
d54 1
a54 1
    "$Id: MLSAuxData.f90,v 2.19 2002/07/23 23:16:06 jdone Exp $"
d71 8
a78 8
    integer, dimension(:), pointer :: FrequencyCoordinates
    integer, dimension(:), pointer :: VerticalCoordinates
    integer, dimension(:), pointer :: HorizontalCoordinates

    character, dimension(:,:,:), pointer :: CharField => NULL()
    real,  dimension(:,:,:), pointer :: DpField => NULL()
    real,  dimension(:,:,:), pointer :: RealField => NULL()
    integer,   dimension(:,:,:), pointer :: IntField => NULL()
d217 1
a217 1
    real, dimension(3) :: attr_data
d224 1
d288 6
d300 1
a300 1
    if (associated(MLSAuxData%HorizontalCoordinates)) then 
d306 1
d311 8
a318 7
    call h5screate_simple_f(arank, adims_create, aspace_id, h5error)
    aname = "HorizontalCoordinates"  
    call h5acreate_f(dset_id, trim(aname), atype_id, aspace_id, attr_id, &
       h5error)
    call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)
    call h5aclose_f(attr_id, h5error)
    call h5sclose_f(aspace_id, h5error) 
d321 1
a321 1
    if (associated(MLSAuxData%VerticalCoordinates)) then 
d326 1
d331 8
a338 7
    call h5screate_simple_f(arank, adims_create, aspace_id, h5error)
    aname = "VerticalCoordinates"   
    call h5acreate_f(dset_id, trim(aname), atype_id, aspace_id, attr_id, &
       h5error)
    call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)
    call h5aclose_f(attr_id, h5error)
    call h5sclose_f(aspace_id, h5error) 
d341 1
a341 1
    if (associated(MLSAuxData%FrequencyCoordinates)) then 
d346 1
d351 8
a358 7
    call h5screate_simple_f(arank, adims_create, aspace_id, h5error)
    aname = "FrequencyCoordinates"
    call h5acreate_f(dset_id, trim(aname), atype_id, aspace_id, attr_id, &
       h5error)
    call h5awrite_f(attr_id, atype_id, attr_data, adims, h5error)
    call h5aclose_f(attr_id, h5error)
    call h5sclose_f(aspace_id, h5error) 
d375 186
d563 1
a563 1
       MLSAuxData, FirstMAF, LastMAF)
d568 2
a569 1
    character(len=*), intent(in)   :: QuantityName, QuantityType
d571 1
d574 1
d587 2
d590 3
d632 27
d678 1
a678 1
    test_type: select case (trim(QuantityType))
d694 1
a694 1
    test_type_dims: select case (trim(QuantityType))
d771 10
d802 2
a803 1
  subroutine Write_MLSAuxData(file_id, MLSAuxData, startMAF)
d810 1
d812 1
d826 5
d938 10
d968 3
@


2.2
log
@Now reads portion of dataset
@
text
@d464 6
d482 6
d499 6
d516 6
@


2.1
log
@add routine to read/write HDF5 files
@
text
@d15 3
a17 1
       h5sselect_hyperslab_f, h5dread_f, h5dwrite_f, h5dextend_f
a71 2
    integer, dimension(:), pointer :: CounterMAF => NULL() !dimensioned(noMAFs)

a72 1

d100 2
d177 15
a191 3
    if (associated(MLSAuxData%counterMAF)) then 
        nullify(MLSAuxData%counterMAF)
        deallocate(MLSAuxData%counterMAF, stat=status)
d208 2
d211 5
a215 3
    integer(hsize_t), dimension(1) :: maxdims_MAF, dims_MAF, chunk_dims_MAF 
    integer(hid_t) :: cparms, dspace_id, dset_id, type_id
    integer :: i, rank_MAF, rank, h5error
d222 1
a225 1
          type_id = H5T_IEEE_F32LE
d232 1
a235 1
          type_id = H5T_NATIVE_DOUBLE
d242 1
a245 1
          type_id = H5T_NATIVE_INTEGER
d252 1
a255 1
          type_id = H5T_NATIVE_CHARACTER
d260 2
a261 2

    call h5screate_simple_f(rank, dims(1:rank), dspace_id, h5error, & 
d279 60
d368 5
a372 2
    integer(hid_t) :: cparms, dset_id, dspace_id, type_id, memspace
    integer        :: rank, h5error, i, status
d374 8
a381 1
    integer(hsize_t), dimension(7) :: dims
d383 1
d401 1
a401 1
     call h5dget_create_plist_f(dset_id,cparms,h5error)
a428 2
    if (present (FirstMAF)) start(rank)=FirstMAF-1

a449 1

d451 14
a464 2
    
    print *,'Does not yet handle optional MAF I/O.'
d466 33
a498 18
!    test_type_dims: select case (trim(QuantityType))
!    case ('real')
!    call h5dread_f(dset_id,type_id,& 
!         MLSAuxData%RealField(1:dims(1),1:dims(2),FirstMAF:LastMAF),& 
!         dims,h5error, memspace, dspace_id)
!    case ('double')    
!    call h5dread_f(dset_id,type_id,& 
!         MLSAuxData%DpField(1:dims(1),1:dims(2),FirstMAF:LastMAF),& 
!         dims,h5error,memspace,dspace_id)
!    case ('integer')  
!    call h5dread_f(dset_id,type_id,&
!         MLSAuxData%IntField(1:dims(1),1:dims(2),FirstMAF:LastMAF),&         
!         dims,h5error,memspace,dspace_id)
!    case ('character') 
!    call h5dread_f(dset_id,type_id,&
!         MLSAuxData%CharField(1:dims(1),1:dims(2),FirstMAF:LastMAF),&          
!         dims,h5error,memspace,dspace_id)
!    end select test_type_dims
a504 1
    MLSAuxData%type_name = trim(QuantityType)
d537 4
d542 1
d544 2
a545 2
    integer(hsize_t), dimension(7) :: dims
    integer(hsize_t), dimension(3) :: dims_create, start
a615 1

d631 18
a648 18
!    test_type_dims: select case (trim(MLSAuxData%type_name))
!    case ('real')
!    call h5dwrite_f(dset_id,type_id,& 
!         MLSAuxData%RealField(1:dims(1),1:dims(2),startMAF:dims(3)),& 
!         dims,h5error,memspace,filespace)
!    case ('double')    
!    call h5dwrite_f(dset_id,type_id,& 
!         MLSAuxData%DpField(1:dims(1),1:dims(2),startMAF:dims(3)),& 
!         dims,h5error,memspace,filespace)
!    case ('integer')  
!    call h5dwrite_f(dset_id,type_id,&
!         MLSAuxData%IntField(1:dims(1),1:dims(2),startMAF:dims(3)),&         
!         dims,h5error,memspace,filespace)
!    case ('character') 
!    call h5dwrite_f(dset_id,type_id,&
!         MLSAuxData%CharField(1:dims(1),1:dims(2),startMAF:dims(3)),&     
!         dims,h5error,memspace,filespace)
!    end select test_type_dims    
d651 1
a653 1

@

