head	2.114;
access;
symbols
	v5-02-NRT-19:2.114
	v6-00:2.114
	v5-02-NRT-18:2.114
	v5-02:2.113
	v5-01-NRT-17:2.114
	v5-01-NRT-16:2.114
	v5-01-NRT-15:2.114
	v5-01-NRT-14:2.114
	neuralnetworks-1-0:2.114.0.4
	cfm-single-freq-0-1:2.114.0.2
	v5-01:2.113
	v5-00:2.113
	v4-23-TA133:2.113.0.2
	mus-emls-1-70:2.112.0.2
	rel-1-0-englocks-work:2.110.0.2
	VUMLS1-00:2.107
	VPL1-00:2.104
	V4-22-NRT-08:2.103
	VAM1-00:2.103
	V4-21:2.102.0.2
	V4-13:2.102
	V4-12:2.100
	V4-11:2.100
	V4-10:2.100
	V3-43:2.88
	M4-00:2.94
	V3-41:2.88
	V3-40-PlusGM57:2.88.0.2
	V2-24-NRT-04:2.79
	V3-33:2.88
	V2-24:2.78
	V3-31:2.88
	V3-30-NRT-05:2.88
	cfm-01-00:2.88
	V3-30:2.88
	V3-20:2.88
	V3-10:2.87
	V2-23-NRT-02:2.79
	V2-23:2.78
	V2-22-NRT-01:2.79
	V2-22:2.78
	V2-21:2.74
	V2-20:2.74
	V2-11:2.73
	V2-10:2.73
	V2-00:2.73
	V1-51:2.61
	V1-50:2.61
	V1-45:2.59
	V1-44:2.59
	V1-43:2.58
	V1-42:2.52
	V1-41:2.52
	V1-32:2.58
	V1-40:2.52
	V1-31:2.52
	V1-30:2.52
	V1-13:2.49
	V1-12:2.49
	V1-11:2.49
	V1-10:2.47
	newfwm-feb03:2.47.0.2
	V1-04:2.31
	V1-03:2.31
	V1-02:2.31
	V1-00:2.31
	newfwm-sep01:2.21.0.2
	V0-7:2.21
	V0-5-Level2:2.16
	V0-5-SIPS:2.14;
locks; strict;
comment	@# @;


2.114
date	2019.10.22.18.51.18;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2019.01.30.23.56.39;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2018.04.19.02.09.49;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2018.04.16.18.25.18;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2018.02.08.23.16.41;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2017.12.12.21.25.32;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2017.11.15.00.09.31;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2017.01.19.23.35.01;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2017.01.13.01.27.27;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2016.09.21.00.38.41;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2016.08.09.18.13.34;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2015.03.28.01.13.24;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2014.09.05.00.01.11;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2014.09.02.18.31.40;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2014.04.02.23.02.10;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2013.09.24.23.27.14;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2013.07.24.19.01.03;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2013.05.31.00.27.44;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2012.08.27.23.01.29;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2012.08.14.00.20.13;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2012.05.24.20.32.11;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2012.03.14.16.55.11;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2012.01.05.01.14.54;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2011.07.12.22.35.44;	author honghanh;	state Exp;
branches;
next	2.88;

2.88
date	2009.09.29.23.32.40;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2008.12.02.23.10.51;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2008.05.24.00.54.46;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2008.05.02.00.41.09;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2008.05.02.00.03.33;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2008.04.18.16.32.30;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2008.03.11.00.09.54;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2008.02.22.21.27.15;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2008.01.14.23.47.16;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2007.06.21.00.49.51;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2007.04.06.16.23.17;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2007.02.06.17.55.14;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2007.01.11.20.41.20;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2006.09.21.18.45.52;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2006.04.11.23.15.34;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2006.02.21.19.07.58;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2005.12.21.18.44.08;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2005.10.18.23.03.32;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2005.08.09.00.00.10;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2005.06.29.17.56.24;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2005.06.22.17.25.49;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2005.06.16.18.41.41;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2005.06.14.20.32.09;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2005.06.03.23.58.04;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2005.05.31.17.50.20;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2005.01.07.00.36.51;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2004.10.13.00.50.32;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2004.10.09.02.46.09;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2004.08.04.23.19.01;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2004.02.05.23.29.16;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2004.01.27.21.34.57;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2004.01.23.01.13.11;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2004.01.22.00.44.02;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2004.01.21.18.54.54;	author livesey;	state Exp;
branches;
next	2.53;

2.53
date	2004.01.21.18.48.59;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2003.06.23.21.06.55;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2003.06.20.19.32.32;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2003.04.02.23.53.18;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2003.02.28.00.46.32;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2003.02.26.17.34.39;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2002.12.10.00.43.44;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2002.12.09.17.55.03;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2002.12.06.23.38.57;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2002.12.05.19.44.24;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2002.12.04.01.16.25;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2002.12.02.23.37.27;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2002.11.07.21.22.40;	author jdone;	state Exp;
branches;
next	2.40;

2.40
date	2002.10.29.01.02.26;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2002.10.08.23.46.03;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2002.10.08.00.09.11;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2002.09.27.23.38.38;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2002.09.26.23.59.39;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2002.08.08.22.40.42;	author jdone;	state Exp;
branches;
next	2.34;

2.34
date	2002.07.23.00.06.55;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2002.07.11.22.21.01;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2002.06.04.18.11.39;	author bill;	state Exp;
branches;
next	2.31;

2.31
date	2002.03.14.23.31.45;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2002.02.19.23.12.40;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2002.01.31.00.35.56;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2002.01.29.23.45.26;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2002.01.29.00.47.41;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2002.01.23.21.47.31;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2002.01.18.18.51.22;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2002.01.18.00.53.37;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2002.01.11.00.44.37;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2002.01.09.23.43.26;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2001.07.18.23.59.16;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2001.06.19.22.22.28;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2001.05.08.23.35.44;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2001.05.08.21.36.38;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2001.05.07.23.25.02;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2001.04.25.21.52.50;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.04.25.20.32.29;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.04.17.23.44.54;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.17.22.10.55;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.13.23.50.55;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.13.00.18.10;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.10.20.05.07;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.04.09.23.42.38;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2001.04.07.00.16.28;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2001.04.03.23.52.29;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.27.17.30.59;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.24.00.30.14;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.22.01.09.31;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.21.00.48.43;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2001.03.20.00.41.28;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2001.03.07.01.02.37;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.114
log
@Fixed bug confusing r and R options in call to SortArray
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!===============================================================================
module MLSFiles               ! Utility file routines
  !=============================================================================
  use Dump_0, only: Dump
  use HDF, only: Dfacc_Create, Dfacc_Rdonly, Dfacc_Read, Dfacc_Rdwr, &
    & Sfstart, Sfend
  use HDFeos, only: Gdclose, Gdopen, Swclose, Swopen, Swinqswath
  use HDFeos5, only: HE5_Swclose, HE5_Swopen, HE5_Swinqswath, &
    & HE5_Gdopen, HE5_Gdclose, &
    & HE5f_Acc_Trunc, HE5f_Acc_Rdonly, HE5f_Acc_Rdwr
  use HighOutput, only: OutputNamedValue, OutputTable
  use Intrinsic, only: L_Ascii, L_HDFeos, L_HDF, L_Open, &
    & L_Swath, L_Tkgen, L_Zonalavg, Lit_Indices
  use Io_Stuff, only: Get_Lun
  use Machine, only: Io_Error
  use MLSCommon, only: BareFNLen, FileNameLen, FileIds_T, MLSFile_T, Range_T, &
    & FileStringTable, InRange, Split_Path_Name
  use MLSMessageModule, only: MLSMessage, MLSMSG_Crash, MLSMSG_Error, &
    & MLSMSG_Warning, Dump_MLSFile
  use MLSFinds, only: Findfirst
  use MLSStrings, only: Capitalize, Lowercase
  use MLSStringLists, only: ExtractSubstring, &
    & ReplaceSubstring, SortArray
  use Output_M, only: Blanks, Output
  use SDPtoolkit, only: &
    & PGS_Pc_Getreference, PGS_S_Success, &
    & PGSd_Io_Gen_Rseqfrm, PGSd_Io_Gen_Rsequnf, &
    & PGSd_Io_Gen_Rdirfrm, PGSd_Io_Gen_Rdirunf, &
    & PGSd_Io_Gen_Wseqfrm, PGSd_Io_Gen_Wsequnf, &
    & PGSd_Io_Gen_Wdirfrm, PGSd_Io_Gen_Wdirunf, &
    & PGSd_Io_Gen_Useqfrm, PGSd_Io_Gen_Usequnf, &
    & PGSd_Io_Gen_Udirfrm, PGSd_Io_Gen_Udirunf, &
    & PGSd_Io_Gen_Aseqfrm, PGSd_Io_Gen_Asequnf, &
    & PGS_Io_Gen_Closef, PGS_Io_Gen_Openf, PGSd_Pc_File_Path_Max, &
    & UseSDPtoolkit
  ! In The Long Run, We'll Try Putting Interfaces To These In SDPToolkit.f90
  ! Until Then, Just Declare Them As External
  ! & PGS_MET_SFstart, PGS_MET_SFend, &
  use String_Table, only: Display_String, Get_String
  use HDF5, only: Size_T
  implicit none

  private 

  public :: AddFiletoDatabase, &
    & AddinitializeMLSFile, ArethesameFile, &
    & Deallocate_FileDatabase, Dump, FileStringTable, &
    & GetMLSFilebyname, GetMLSFilebytype, Getpcfromref, &
    & InitializeMLSFile, &
    & Maskname, &
    & MLS_CloseFile, MLS_Exists, MLS_HDF_Version, MLS_Inqswath, &
    & MLS_OpenFile, MLS_Sfstart, MLS_Sfend, &
    & Readnchars, Release_MLSFile, Reserve_MLSFile, &
    & RmFilefromDatabase, Split_Path_Name, &
    & Transfer_MLSFile, UnMaskname, Unsplitname

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSFiles.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (parameters)
! HDFVERSION_4       integer corresponding to hdf4
! HDFVERSION_5       integer corresponding to hdf5
! WILDCARDHDFVERSION integer corresponding to automatically recognize hdf4/hdf5
! NAMENOTFOUND       GetPCFromRef unable to find named file
! INVALIDPCRANGE     GetPCFromRef given invalid pc range
! CANTALLOCATENAMEARRAY
!                    GetPCFromRef unable to allocate memory needed
! UNKNOWNFILEACCESSTYPE
!                    invalid file access type
! UNKNOWNTOOLBOXMODE invalid toolbox mode
! NOFREEUNITS        ran out of free units
! MUSTSUPPLYFILENAMEORPC
!                    missing required argument
! NOPCIFNOTOOLKIT    must be given filename if toolkitless
! NOSUCHHDFVERSION   invalid hdf version
! MUSTSUPPLYFILENAME Required filename arg missing
! ERRORINH5FFUNCTION Internal hdf5 library function error
! WRONGHDFVERSION    Supplied hdf version differs from actual file version

!     (subroutines and functions)
! AddFileToDataBase  Enters an MLSFile {FileName, id, ..} into the database
! AddInitializeMLSFile  AddFileToDataBase, initializes, and returns pointer to it
! AreTheSameFile     Returns TRUE if the two args are the same file
! Deallocate_filedatabase
!                    Deallocates file database, closing any still-open files
! Dump               Dumps file info: type, access, name, etc.
! GetMLSFileByName   Returns pointer to MLSFile matching fileName
! GetMLSFileByType   Returns pointer to MLSFile matching fileType
! GetPCFromRef       Turns a FileName into the corresponding PC
! InitializeMLSFile  Initializes an MLSFile
! Maskname           Add stuff to file_name so parser can't recognize it
! MLS_Exists         Returns 0 if the filename exists
! MLS_CloseFile      Closes a file opened by MLS_openFile
! MLS_Hdf_version    Returns one of 'hdf4', 'hdf5', or '????'
! MLS_Inqswath       A wrapper for doing swinqswath for versions 4 and 5
! MLS_OpenFile       Opens an MLSFile_T file
! MLS_Sfend          Closes a file opened by MLS_sfstart
! MLS_Sfstart        Opens an hdf file for writing metadata
! Release_MLSFile    undoes what reserve_MLSFile does
! Reserve_MLSFile    initializes an MLS file 
!                      (to be operated on by single-argument functions)
! RmFileFromDataBase Removes a FileName, id, etc. from the database
! Split_path_name    splits the input path/name into path and name
! Transfer_MLSFile   Changes the path of an MLSFile
! Unmaskname         Recover file name from masked form
! Unsplitname        Split File name -> catenated: '..DGG13..' -> 'DGG'
! === (end of toc) ===

! (The following 2 are currently private, but could be made public if needed)
! hdf2hdf5_fileaccess
!                    Translates version 4 hdf access codes to version 5
! he2he5_fileaccess
!                    Translates version 4 hdfeos access codes to version 5

! === (start of api) ===
! GetPCFromRef (char* FileName, PCBottom, PCTop,
!     log caseSensitive, ErrType, [int versionNum], [log debugOption],
!     [char* path], [char* ExactName])
! split_path_name (char* full_file_name, char* path, char* name, [char slash])
! int mls_exists ( char* FileName )
! int mls_inqswath (char* FileName, char* swathList, int strBufSize,
!     [int hdfVersion])
! int mls_sfstart (char* FileName, int FileAccess, [int hdfVersion])
! int mls_sfend (int sdid, [int hdfVersion])
! int mls_hdf_version (char* FileName, [int preferred_version], [int AccessType])
! mls_openFile (char* filename, char* access, hid_t file_id)
! mls_closeFile (hid_t file_id)
! === (end of api) ===

! Note that of the above functions and procedures, the following operate on the
! MLSFile user-defined type--a high level type insulating the user from
! some of the grittier details
!    AddFileToDataBase
!    AddInitializeMLSFile
!    AreTheSameFile
!    Deallocate_filedatabase
!    Dump
!    GetMLSFileByName
!    GetMLSFileByType
!    InitializeMLSFile
!    Mls_closeFile
!    Mls_openFile
!    RmFileFromDataBase
! int AddFileToDataBase (MLSFile *dataBase(:), MLSFile(item) )
! MLSFile *AddInitializeMLSFile (MLSFile *dataBase(:), [int type],
!   [int access], [char* content], [char* name], [char* shortName], 
!   [int HDFVersion], [int recordLength], 
!   [Range PCFIdRange], [int PCFBottom], [int PCFTop])
! log AreTheSameFile (MLSFile File1, MLSFile File2 )
! Deallocate_filedatabase(MLSFile *dataBase(:))
! Dump ( MLSFile *dataBase(:), [char* Name], [int details], [log table] )
! Dump ( MLSFile MLSFile, [int details] )
! MLSFile *GetMLSFileByName (MLSFile *dataBase(:), char* name, [log ignore_paths])
! MLSFile *GetMLSFileByType (MLSFile *dataBase(:), [int type], [char* content],
!    [int PCFId], [Range PCFIdRange])
! int InitializeMLSFile (MLSFile item, [int type],
!   [int access], [char* content], [char* name], [char* shortName], 
!   [int HDFVersion], [int recordLength], 
!   [Range PCFIdRange], [int PCFBottom], [int PCFTop])
! mls_CloseFile( MLSFile MLSFile, [int error] )
! mls_OpenFile( MLSFile MLSFile, [int error] )

! A long-term plan is for almost all calls from outside this module to
! be made to one of the above procedures and removing the public attribute
! of the other procedures

   ! ---------------- Module Parameters ------------------
   ! 4 corresponds to hdf4, 5 to hdf5 in L2GP, L2AUX, etc.
   ! *** HDFVersions must be consecutive, ***
   !     as they're used for subscripts!
   integer, parameter, public :: HDFVERSION_4 = 4
   integer, parameter, public :: HDFVERSION_5 = 5
   ! Assume hdf files w/o explicit hdfVersion field are DEFAULT_HDFVERSION
   ! (Does anyone still use it? Should we deprecate it?)
   integer, parameter         :: DEFAULT_HDFVERSION = HDFVERSION_4
   
  ! Given this WILDCARDHDFVERSION, try to automatically recognize hdfversion
  ! then perform appropriate version of open/close; i.e., forgiving
  integer, parameter, public :: WILDCARDHDFVERSION = HDFVERSION_4+HDFVERSION_5

  ! This isn't NameLen because it may have a path prefixed
  integer, parameter :: MAXFILENAMELENGTH=PGSd_PC_FILE_PATH_MAX

  ! This error code may be returned from almost any routine or function

  integer, parameter, public :: FILENOTFOUND=-1

  ! These are error codes that may be returned by GetPCFromRef

  integer, parameter, public :: NAMENOTFOUND=FILENOTFOUND-1
  integer, parameter, public :: INVALIDPCRANGE=NAMENOTFOUND-1
  integer, parameter, public :: CANTALLOCATENAMEARRAY=INVALIDPCRANGE-1

  ! These are error codes that may be returned by mls_io_gen_openF

  integer, parameter, public :: UNKNOWNFILEACCESSTYPE=-999
  integer, parameter, public :: UNKNOWNTOOLBOXMODE=UNKNOWNFILEACCESSTYPE+1
  integer, parameter, public :: NOFREEUNITS=UNKNOWNTOOLBOXMODE+1
  integer, parameter, public :: MUSTSUPPLYFILENAMEORPC=NOFREEUNITS+1
  integer, parameter, public :: NOPCIFNOTOOLKIT=MUSTSUPPLYFILENAMEORPC+1
  integer, parameter, public :: NOSUCHHDFVERSION=NOPCIFNOTOOLKIT+1
  integer, parameter, public :: FILEALREADYOPEN=NOSUCHHDFVERSION+1

  ! These are error codes that may be returned by mls_io_gen_openF
  ! or by mls_hdf_version if you call it directly

  integer, parameter, public :: MUSTSUPPLYFILENAME=FILEALREADYOPEN+1
  integer, parameter, public :: ERRORINH5FFUNCTION=MUSTSUPPLYFILENAME+1
  integer, parameter, public :: WRONGHDFVERSION=ERRORINH5FFUNCTION+1
  
  ! Whether to use PGS_MET commands in mls_sf(start)(end)
  ! (The alternative is to use hdf5 calls directly)
  ! logical, parameter :: PGS_MET4MLS_SF = .true.
  ! Whether to pass hdf5_acc types to PGS_MET 
  ! (The alternative is to pass h5f_acc directly)
  ! Contradicting what the documents say,
  ! currently (TK 5.2.7.4) the toolkit routine
  ! PGS_MET_HDFSDStart.c assumes the File Access is of
  ! one of the following types:
  ! (1) hdf4_acc: DFACC_RDWR, DFACC_RDONLY, or DFACC_CREATE
  !      (equiv. to HDF4_ACC_RDWR, etc.)
  ! (2) hdf5_acc: HDF5_ACC_RDWR, HDF5_ACC_RDONLY, or HDF5_ACC_CREATE
  !          * * *    w a r n i n g   * * *
  ! According to mls/hirdls telecom of 03-12-2002 this will change
  ! in a future release of the toolkit
  ! That means some programmer (paw?) will have to revisit
  ! this and see what the toolkit code actually does,
  ! not just what the docs say
  logical, parameter :: HDF5_ACC_TYPES_TO_MET = .true.
  integer, parameter :: HDF5_ACC_DEFAULT = HE5F_ACC_RDWR ! HDF5_ACC_RDWR

  ! ------------- Warning--trickery ahead -----------
  ! Character(s) added to file name so parser won't recognize it
  ! (Parser sometimes changes its case if it thinks it has seen the name before)
  character (len=*), parameter :: MASKINGTAPE = ')('

  interface Dump
    module procedure Dump_MLSFile
    module procedure Dump_FileDatabase
  end interface

  interface mls_closeFile
    module procedure mls_closeFileID
    module procedure mls_closeFileType
  end interface

  interface mls_openFile
    module procedure mls_openFileName
    module procedure mls_openFileType
  end interface

  ! The following parameters may some day be used
  ! but, not so far
  !   Don't remember what we intended. Were they to be keys and values
  !   for clever hashes? To be used in functions beginning with
  !      Mls_io_gen_..
  !   How exactly would they make our life simpler?
  ! character (len=*), parameter :: accesses = 'rdonly,write,rdwrite,create,nonhdf'
  ! integer, dimension(5), parameter :: accessTypes = &
  !   & (/ DFACC_RDONLY, DFACC_RDWR, DFACC_RDWR, DFACC_CREATE, PGSd_IO_Gen_RSeqFrm/)
  ! character (len=*), parameter :: hdfmodes = 'hg,sw,gd,za'
  ! character (len=*), parameter :: modes = 'op,hg,sw,gd,za,bin,pg'
  ! character (len=*), parameter :: types = 'ascii,hdf,swath,grid,zonalavg,binary,tkgen'

  type(MLSFile_T), save :: MLSFile_save
  logical, parameter :: DeeBug = .false.

contains

  !-------------------------------------------  AddFileToDatabase  -----
  integer function AddFileToDatabase ( DATABASE, ITEM )

  ! This routine adds an MLSFile to a database of such MLSFiles, 
  ! creating the database if necessary.

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type (MLSFile_T), dimension(:), pointer :: DATABASE
    type (MLSFile_T), intent(in) ::            ITEM

    ! Local variables
    type (MLSFile_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddFileToDatabase = newSize
  end function AddFileToDatabase

  !----------------------------------------  AddInitializeMLSFile  -----
  function AddInitializeMLSFile ( DATABASE, type, access, content, name, &
    & shortName, HDFVersion, recordLength, PCFIdRange, PCBottom, PCTop ) &
    & result(item)

  ! This routine initializes an MLSFile, and adds it to database
  ! returning a pointer to the new entry

    ! Dummy arguments
    type (MLSFile_T), dimension(:), pointer :: DATABASE
    type (MLSFile_T), pointer               :: ITEM
    integer, optional, intent(in)          :: type
    ! character(len=*), optional, intent(in) :: access
    integer, optional, intent(in)          :: access
    character(len=*), optional, intent(in) :: content
    character(len=*), optional, intent(in) :: name
    character(len=*), optional, intent(in) :: shortName
    integer, optional, intent(in)          :: HDFVersion
    integer, optional, intent(in)          :: recordLength
    type(Range_T), optional, intent(in)    :: PCFIdRange
    integer, optional, intent(in)          :: PCBottom ! (Instead of range_T)
    integer, optional, intent(in)          :: PCTop    ! (Instead of range_T)
    ! Internal variables
    integer :: newSize
    type (MLSFile_T)                       :: NEWITEM
    ! Executable
    newSize = InitializeMLSFile ( NEWITEM, type, access, content, name, &
    & shortName, HDFVersion, recordLength, PCFIdRange, PCBottom, PCTop )
    newSize = AddFileToDatabase ( DATABASE, NEWITEM )
    item => Database(newSize)
  end function AddInitializeMLSFile

  !----------------------------------------------  AreTheSameFile  -----
  function AreTheSameFile ( File1, File2 ) &
    & result(SooDesu)

  ! This routine checks whether the two inputs name the same file

    ! Dummy arguments
    type (MLSFile_T), intent(in) :: File1
    type (MLSFile_T), intent(in) :: File2
    logical                      :: SooDesu
    ! Internal variables
    SooDesu = ( File1%name == File2%name )
  end function AreTheSameFile

  !-------------------------------------------  InitializeMLSFile  -----
  integer function InitializeMLSFile ( ITEM, type, access, content, name, &
    & shortName, HDFVersion, recordLength, PCFIdRange, PCBottom, PCTop )

  ! This routine initializes an MLSFile, optionally supplying type, content, etc.

    ! Dummy arguments
    type (MLSFile_T)                       :: ITEM
    integer, optional, intent(in)          :: type
    integer, optional, intent(in)          :: access
    character(len=*), optional, intent(in) :: content
    character(len=*), optional, intent(in) :: name
    character(len=*), optional, intent(in) :: shortName
    integer, optional, intent(in)          :: HDFVersion
    integer, optional, intent(in)          :: recordLength
    type(Range_T), optional, intent(in)    :: PCFIdRange
    integer, optional, intent(in)          :: PCBottom ! (Instead of range_T)
    integer, optional, intent(in)          :: PCTop    ! (Instead of range_T)

    InitializeMLSFile = 0 ! Will we ever return non-zero values?
    item%type         = 0
    item%access       = 0
    item%recordLength = 0
    item%PCFID        = 0
    item%fileID%f_id  = 0
    item%fileID%grp_id= 0
    item%fileID%sd_id = 0
    item%stillOpen    = .false.

    ! item%accessStr   = ""
    item%content     = ""
    item%name        = ""
    item%shortName   = ""
    item%HDFVersion  = 0
    item%recordLength= 0
    item%PCFIDRange%Bottom = 0
    item%PCFIDRange%Top = 0
    
    if ( present(type         ) ) item%type       = type      
    if ( present(access       ) ) item%access     = access    
    if ( present(content      ) ) item%content    = content   
    if ( present(name         ) ) item%name       = name      
    if ( present(shortName    ) ) item%shortName  = shortName      
    if ( present(HDFVersion   ) ) item%HDFVersion = HDFVersion
    if ( present(recordLength ) ) item%recordLength= recordLength
    if ( present(PCFIDRange   ) ) item%PCFIDRange = PCFIDRange
    if ( present(PCBottom     ) ) item%PCFIDRange%Bottom   = PCBottom
    if ( present(PCTop        ) ) item%PCFIDRange%Top      = PCTop   
    ! Make certain not to store simply a truncated name as short name
    if ( present(name) .and. present(shortName) ) then
      if ( name == shortName ) item%shortName = ""
    endif
    if ( item%type > 0 .and. FILESTRINGTABLE ) &
      & call get_string(lit_indices(item%type), item%typeStr, strip=.true.)
  end function InitializeMLSFile

  ! -----------------------------------------------  GetPCFromRef  -----

  ! This function takes a FileName as an arg and a range of PC numbers
  ! [PCBottom, PCTop] which are integers
  ! It returns thePC corresponding to the FileName

  ! FileName may be a fragment such as l2gp_temp of a longer name
  ! such as mls_l2_temp_v0.5_01-01-2004.dat

  ! If no matching file found, it sets ErrType=NAMENOTFOUND
  ! otherwise ErrType=0

  ! This is useful because all the Toolbox routines refer to files
  ! by their PC numbers, not their names

  ! Optionally you may require the match to be case-sensitive
  !   (by default it is not: l2_temp will match MLS_L2_TEMP_...)

  ! If you pass in a path, it will require that the paths also match

  ! Optionally you may pass in a version number and a debug flag

  ! optionally returns the exact name of the matching file
  
  ! You might see the term PCFId used for thePC elsewhere
  ! Someday we should enforce uniform nomenclature here

  function GetPCFromRef(FileName, PCBottom, PCTop, &
    & caseSensitive, ErrType, versionNum, debugOption, path, ExactName) &
    & result (thePC)

    ! Dummy arguments
    character (len=*), intent(in)            :: FileName
    integer,  intent(in)                     :: PCBottom, PCTop
    integer                                  :: thePC, notThePC
    integer,  intent(out)                    :: ErrType
    logical,  intent(in)                     :: caseSensitive
    integer,  optional                       :: versionNum
    logical,  optional, intent(in)           :: debugOption
    character (len=*),  optional, intent(in) :: path
    character (len=*), optional, intent(out) :: ExactName

    ! Local variables
    logical ::                           debug
    integer, dimension(:), allocatable &
     &                                :: intArray
    character (LEN=MAXFILENAMELENGTH) :: MatchName, TryName, NameOnly
    character (LEN=MAXFILENAMELENGTH), dimension(:), allocatable &
     &                                :: nameArray
    integer                           :: numberPCs
    character(len=8)                  :: options
    character (LEN=MAXFILENAMELENGTH) :: PhysicalName, MatchPath
    character (len=*), parameter      :: UNASSIGNEDFILENAME = '*'
    character (LEN=BareFNLen), dimension(:), allocatable &
     &                                :: unsortedArray
    integer                           :: version, returnStatus

   ! Executable
   if(.not. UseSDPToolkit) then
      ErrType = NOPCIFNOTOOLKIT
      thePC = 0
      return
   endif

    if(present(debugOption)) then
      debug = debugOption
   else
      debug = .false.
   endif
   
    if(debug) then
      call output('get pc from ref', advance='yes')
      call output('FileName: ' // trim(FileName), advance='yes')
      call output('lower PCF limit: ' )
      call output(PCBottom, advance='yes')
      call output('upper PCF limit: ' )
      call output(PCTop, advance='yes')
      call output('case sensitive?: ' )
      call output(caseSensitive, advance='yes')
      call output('version number: ' )
      call output(versionNum, advance='yes')
    endif

    thePC = 0
    if(PCTop < PCBottom) then
      ErrType = INVALIDPCRANGE
      return
    endif

    if(caseSensitive) then
      MatchName = FileName
    else
      MatchName = Capitalize(FileName)
    endif

    if(debug) then
      call output('getting ref from pc:', advance='no')
    endif

    numberPCs = PCTop - PCBottom + 1
    Allocate(nameArray(numberPCs), unsortedArray(numberPCs), &
      & intArray(numberPCs), STAT=ErrType)
    if ( ErrType /= 0 ) then
      ErrType = CANTALLOCATENAMEARRAY
      return
    endif

    ErrType = NAMENOTFOUND
    nameArray = UNASSIGNEDFILENAME
    do thePC = PCBottom, PCTop

      if(present(versionNum)) then
        version = versionNum
      else
        version = 1
      endif

      returnStatus = Pgs_pc_getReference(thePC, version, &
        & PhysicalName)

      if ( returnStatus == PGS_S_SUCCESS ) then

        if(.not. caseSensitive) then
          TryName = Capitalize(PhysicalName)
        else
          TryName = PhysicalName
        endif
        
        call split_path_name(TryName, MatchPath, NameOnly)
        nameArray(thePC-PCBottom+1) = NameOnly
      endif

    enddo
    ! Sort the file names from short to long
    ! to prevent unwanted matches between "O3" and "HNO3"
    options="-sR" ! options string is case-sensitive; 'r' now means 'reverse'
    if ( caseSensitive ) options=trim(options) // 'c'
    unsortedArray = nameArray
    call SortArray( unsortedArray, intArray, &
     & sortedArray=nameArray, options=options )
    if ( DeeBug ) then
      call outputNamedvalue ( 'numberPCs', numberPCs )
      call Dump( intArray,  'array of ints' )
      call Dump( nameArray, 'sorted array of names' )
    endif
    do notThePC = 1, numberPCs
      thePC = intArray(notThePC) + PCBottom - 1         
      NameOnly = nameArray(notThePC)            
      if ( index(NameOnly, trim(MatchName)) /= 0 ) then  
        ErrType = 0                                     
        exit                                            
      endif                                             
    enddo

    if(present(versionNum)) then  
      version = versionNum        
    else                          
      version = 1                 
    endif                         
    returnStatus = Pgs_pc_getReference(thePC, version, &
        & PhysicalName)
    if ( returnStatus == PGS_S_SUCCESS ) then             

      if(.not. caseSensitive) then                        
        TryName = Capitalize(PhysicalName)                
      else                                                
        TryName = PhysicalName                            
      endif                                               
                                                          
      call split_path_name(TryName, MatchPath, NameOnly)
    else
      ErrType = NAMENOTFOUND
    endif  
    if(present(path) .and. ErrType == 0) then
        if ( index(MatchPath, trim(path)) == 0 )then
          ErrType = NAMENOTFOUND
        endif
    endif

    if(present(ExactName) .and. ErrType == 0) then
      ExactName = PhysicalName
    endif

    Deallocate(nameArray, unsortedArray, intArray)
  end function GetPCFromRef

! ---------------------------------------------- GetMLSFileByName ------

! This function returns the MLSFile matching a given name

  function GetMLSFileByName(database, name, ignore_paths) result(item)
  type(MLSFile_T), dimension(:), pointer :: database
  character(len=*), intent(in)           :: name
  type(MLSFile_T), pointer               :: item
  logical, optional, intent(in)          :: ignore_paths
  !
  integer :: i
  integer :: indx
  logical :: myignore_paths
  character(len=len(name)) :: barename
  !
  nullify(item)
  if ( .not. associated(database) ) return
  if ( size(database) < 1 ) return
  myignore_paths = .false.
  if ( present(ignore_paths) ) myignore_paths = ignore_paths
  if ( .not. myignore_paths ) then
    indx = findFirst(database%name == name)
  else
    ! streqOptions = '-ps' ! Enabling partial match, and returning the shortest
    ! doTheyMatch = streq(database%name, name, streqOptions)
    indx = findFirst( strip_path(database%name), strip_path(name) )
    if ( indx < 1 .and. DeeBug ) then
      barename = strip_path(name)
      call output( 'barename: ' // trim(barename), advance='yes' )
      do i=1, size(database)
        barename = strip_path(database(i)%name)
        call output( 'barename(db(i): ' // trim(barename), advance='yes' )
      enddo
    endif
  endif
  if ( indx > 0 ) item => database(indx)
  end function GetMLSFileByName

! ---------------------------------------------- GetMLSFileByType ------

! This function returns the MLSFile matching a given type, content, etc.
! It always returns the first match if more than one found
! If no optional args supplied, it therefore returns the first database entry

  function GetMLSFileByType(database, type, content, PCFid, PCFIDRange) &
    & result(item)
  type(MLSFile_T), dimension(:), pointer   :: database
  ! character(len=*), optional, intent(in)   :: type
  integer, optional, intent(in)   :: type
  character(len=*), optional, intent(in)   :: content
  integer, optional, intent(in)            :: PCFID
  type(Range_T), optional, intent(in) :: PCFIDRange
  type(MLSFile_T), pointer                 :: item
  !
  logical, dimension(size(database)) :: doTheyMatch
  integer :: indx
  !
  nullify(item)
  if ( .not. associated(database) ) return
  if ( size(database) < 1 ) return
  doTheyMatch = .true.
  if ( present(type) ) doTheyMatch = doTheyMatch .and. &
    & (database%type == type)
  if ( present(content) ) doTheyMatch = doTheyMatch .and. &
    & (database%content == content)
  if ( present(PCFID) ) doTheyMatch = doTheyMatch .and. &
    & (database%PCFID == PCFID)
  if ( present(PCFIDRange) ) doTheyMatch = doTheyMatch .and. &
    & inRange(database%PCFID, PCFIDRange)
  !
  indx = findFirst(doTheyMatch)
  if ( indx > 0 .and. indx < size(database)+1 ) item => database(indx)
  
  end function GetMLSFileByType

! ---------------------------------------------- maskName ------

! This function returns the name plus a masking portion
! We do this to fool the parser into thinking it's not seen
! this name before. Otherwise the parser may not preserve its case.

  function maskName(inName) result(outName)
  character(len=*), intent(in)     :: inName        ! Name to be masked
  character(len=min(MAXFILENAMELENGTH, len(inName)+2)) :: outName       ! masked name
  ! Executable
  if ( len_trim(inName)  < 1 ) then
    outName = ''
  else
    outName = trim(inName) // MASKINGTAPE
  endif
  end function maskName

  !------------------------------------------  RmFileFromDatabase  -----
  integer function RmFileFromDatabase ( DATABASE, ITEM )

  ! This routine removes a vector from a database of such vectors, 
  ! deallocating the database if necessary.
  ! Alas, doesn't work--we need to know how to undecorate character tree
  ! first before we will be able to make it work; sorry (P. Wagner)

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    ! Dummy arguments
    type (MLSFile_T), dimension(:), pointer :: DATABASE
    type (MLSFile_T), intent(in) ::            ITEM

    ! Local variables
    type (MLSFile_T), dimension(:), pointer :: tempDatabase
    logical, parameter                      :: okToDeallocEmptyDB = .FALSE.
    include "rmItemFromDatabase.f9h"
    call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot yet (ever?) rm File from database" ) 

    RmFileFromDatabase = newSize
  end function RmFileFromDatabase

  ! ------------------------------------  Deallocate_filedatabase  -----

  ! This routine deallocates the file database, closing any files
  ! that may still be open

  subroutine Deallocate_filedatabase(database)

    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    ! Arguments
    type (MLSFile_T), dimension(:), pointer :: DATABASE
    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: error, i, s
    ! Executable
    if ( .not. associated(database) ) return
    do i=1, size(database)
      if ( database(i)%StillOpen ) call MLS_CloseFile(database(i))
    end do
    s = size(database) * storage_size(database) / 8
    if ( s > 0 ) addr = transfer(c_loc(database(1)), addr)
    Deallocate ( database, stat=error )
    call test_deallocate ( error, ModuleName, 'database', s, address=addr )

  end subroutine Deallocate_filedatabase

  ! ------------------------------------------  Dump_FileDataBase  -----

  subroutine Dump_FileDataBase ( database, Name, details, table )
    ! Dummy arguments
    type (MLSFile_T), intent(in) ::           database(:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional          :: details ! How verbose
    logical, intent(in), optional          :: table   ! As a table

    ! Local variables
    character(len=256), dimension(:,:), pointer :: array
    integer :: i
    integer :: myDetails
    logical :: myTable
    integer :: n
    ! Executable
    myDetails = 0
    if ( present(details) ) myDetails = details
    myTable = .false.
    if ( present(Table) ) myTable = Table
    n = size(database)
    call output ( '============ MLS File Data Base ============', advance='yes' )
    if ( present(name) ) then
      call output ( 'MLS File Database name: ', advance='no' )
      call output ( name, advance='yes' )
    endif
    if ( n < 1 ) then
      call output ( '**** MLS File Database empty ****', advance='yes' )
      return
    elseif ( myTable ) then
      nullify( array )
      allocate( array(n+1, 2 ) )
      array(1,1) = 'name'
      array(1,2) = 'path'
      do i = 1, size(database)
        call split_path_name( database(i)%name, array(i+1, 2), array(i+1, 1) )
      end do
      call outputTable( array, border='-', headliner='-' )
      deallocate( array )
    else
      call output ( 'size: ')
      call output ( size(database), advance='yes')                                
    endif
    if ( myDetails < -1 .or. (myTable .and. myDetails < 1) ) return
    do i = 1, size(database)
      call dump(database(i), details)
    end do
      
  end subroutine Dump_FileDataBase

  ! --------------------------------------------  release_MLSFile  -----

  ! This routine releases an MLSFile
  subroutine release_MLSFile

    ! Internal variables
    integer :: status
    ! Executable
    status = InitializeMLSFile( MLSFile_save )
  end subroutine release_MLSFile

  ! --------------------------------------------  reserve_MLSFile  -----

  ! This routine initializes an MLSFile
  ! so that it can be used by single-parameter functions
  ! like readnchars
  subroutine reserve_MLSFile ( full_file_name, type, access, content, &
    & shortName, hdfVersion, recordLength, PCFIdRange, PCBottom, PCTop )

    ! Arguments
    character(len=*), intent(in)           :: full_file_name
    integer, optional, intent(in)          :: type
    integer, optional, intent(in)          :: access
    character(len=*), optional, intent(in) :: content
    character(len=*), optional, intent(in) :: shortName
    integer, optional, intent(in)          :: HDFVersion
    integer, optional, intent(in)          :: recordLength
    type(Range_T), optional, intent(in)    :: PCFIdRange
    integer, optional, intent(in)          :: PCBottom ! (Instead of range_T)
    integer, optional, intent(in)          :: PCTop    ! (Instead of range_T)
    ! Internal variables
    integer :: status
    ! Executable
    status = InitializeMLSFile( MLSFile_save, type, access, content, full_file_name, &
      & shortName, HDFVersion, recordLength, PCFIdRange, PCBottom, PCTop )
  end subroutine reserve_MLSFile

  ! --------------------------------------- 1-parameter family of functions --
  ! These functions can be called to operate on MLSFile_save
  function readnchars ( n )  result( status )
    ! Tries to read n chars
    ! Our success or failure determines the resulting status
    ! We don't actually care what the chars are, merely whether we can read them
    ! Args
    integer, intent(in) :: n
    integer :: status
    ! Internal variables
    character(len=n) :: chars
    ! Executable
    if ( MLSFile_save%type /= l_ascii ) &
      & call MLSMessage ( MLSMSG_Warning, moduleName,  &
         & 'Trying to readnchars from a non-ascii file' )
    call get_lun( MLSFile_save%FileID%f_id )
    open( UNIT=MLSFile_save%FileID%f_id, access='direct', recl=n, &
      & file=trim(MLSFile_save%name), status='old', iostat=status )
    if ( status /= 0 ) return
    read( UNIT=MLSFile_save%FileID%f_id, REC=1, IOSTAT=status ) chars
    close( UNIT=MLSFile_save%FileID%f_id )
  end function readnchars
  
  ! ------------------------------------------  he2he5_fileaccess  -----

  ! This function converts hdfeos2 file access types to
  ! corresponding hdfeos5 numbers

  function he2he5_fileaccess(FileAccesshdf4) result (FileAccesshdf5)

    ! Arguments

    integer, intent(in)       :: FileAccesshdf4
    integer                   :: FileAccesshdf5
    
!    integer, parameter        :: H5F_ACC_RDONLY = 0
!    integer, parameter        :: H5F_ACC_RDWR   = 1
!    integer, parameter        :: H5F_ACC_TRUNC  = 2

    ! begin
    select case (FileAccesshdf4)

    case(DFACC_CREATE)
      FileAccesshdf5 = HE5F_ACC_TRUNC   ! H5F_ACC_TRUNC

    case(DFACC_READ)                      ! also , DFACC_RDONLY
      FileAccesshdf5 = HE5F_ACC_RDONLY   ! H5F_ACC_RDONLY

    case default
      FileAccesshdf5 = HE5F_ACC_RDWR   ! H5F_ACC_RDWR

    end select

  end function he2he5_fileaccess

  ! ----------------------------------------  hdf2hdf5_fileaccess  -----

  ! This function converts hdf4 file access types to
  ! corresponding hdf5 numbers

  function hdf2hdf5_fileaccess(FileAccesshdf4) result (FileAccesshdf5)

    use HDF5, only: &
      & H5f_Acc_Rdonly_F, H5f_Acc_Rdwr_F, H5f_Acc_Excl_F
    ! Arguments

    integer, intent(in)       :: FileAccesshdf4
    integer(kind(H5F_ACC_EXCL_F)) :: FileAccesshdf5
    
    ! begin
    select case (FileAccesshdf4)

    case(DFACC_CREATE)
      FileAccesshdf5 = H5F_ACC_EXCL_F  ! H5F_ACC_TRUNC_F

    case(DFACC_READ)    ! also , DFACC_RDONLY
      FileAccesshdf5 = H5F_ACC_RDONLY_F

    case default
      FileAccesshdf5 = H5F_ACC_RDWR_F

    end select

  end function hdf2hdf5_fileaccess

  ! -----------------------------------------------  mls_inqswath  -----

  ! This function acts as a wrapper to allow 
  ! either hdf5 or hdf4 routines to be called

  function mls_inqswath(FileName, swathList, strBufSize, hdfVersion)

    ! Arguments

    character (len=*), intent(in)  :: Filename
    character (len=*), intent(out) :: Swathlist
    integer, intent(out)           :: Strbufsize
    integer                        :: MLS_Inqswath
    integer, optional, intent(in)  :: HDFVersion

    ! Local
    integer :: myhdfVersion
    integer(kind=size_t) :: HSTRBUFSIZE
    ! logical, parameter :: DEEBUG = .true.
    logical, parameter :: IGNOREHSTRBUFSIZE = .true.

    ! Executable code
    ! These next unnecessary assignments aid in running a debug
    ! version compiled with NAG
    strbufsize = 0
    SWATHLIST = ' '
    if ( mls_exists(trim(FileName)) /= 0 ) then
      mls_inqswath = FILENOTFOUND
      strbufsize = FILENOTFOUND
      return
    endif
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = DEFAULT_HDFVERSION
    endif

    ! begin
    if(myhdfVersion == WILDCARDHDFVERSION) then
      myhdfVersion = mls_hdf_version(trim(FileName))
    endif
    if(myhdfVersion == HDFVERSION_5) then
      mls_inqswath = he5_swinqswath(trim(FileName), swathList, hstrBufSize)
      if ( DEEBUG ) then
        print *, 'hstrBufSize: ', hstrBufSize
        print *, 'swathList: ', trim(swathList)
      endif
      strbufsize = hstrbufsize
      if ( IGNOREHSTRBUFSIZE ) strbufsize = len_trim(swathList)
    elseif(myhdfVersion == HDFVERSION_4) then
      mls_inqswath = swinqswath(FileName, swathList, strBufSize)
    else                          
      mls_inqswath = NOSUCHHDFVERSION  
    endif
    if ( strBufSize > len(swathList) ) then
    call outputNamedValue( 'strBufSize, len(swathList)', &
      & (/ strBufSize, len(swathList) /) )
    call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'HDF trod on my memory' )
    endif
    swathList = swathList ( 1:strBufSize )

  end function mls_inqswath

  ! ------------------------------------------------  mls_sfstart  -----

  ! This function acts as a wrapper to allow hdf5 or hdf4 routines to be called
  ! with hdf4-style FileAccess (e.g., DFACC_RDONLY)
  
  ! the logical addingMetadata optionally treats hdf5 files as hdf4-like
  ! in the sd_id returned, as required when adding metadata,
  ! by calling special toolkit function
  
  function mls_sfstart(FileName, FileAccess, hdfVersion, addingmetadata)
    use HDF5, only: H5fopen_F, H5fcreate_F
    use HDF5, only: &
      & H5f_Acc_Rdonly_F, H5f_Acc_Rdwr_F, H5f_Acc_Trunc_F
    ! Arguments

    character (len=*), intent(in) :: Filename
    integer, intent(in)           :: FileAccess ! (one of the hdf4 types)
    integer, optional, intent(in) :: hdfVersion
    logical, optional, intent(in) :: addingmetadata
    ! Local variables
    integer                       :: mls_sfstart
    integer                       :: myhdfVersion
    integer                       :: myAccess
    logical                       :: myaddingmetadata
    integer                       :: returnStatus
    ! parameters    
    logical, parameter :: DEBUG = .false.
    ! external
    integer, external :: PGS_MET_SFstart

    ! begin
   returnStatus = 0
   myaddingmetadata = .false.
   if ( present (addingmetadata) ) myaddingmetadata = addingmetadata
   if ( DEBUG ) then
     call output ('Entering mls_sfstart with args ', advance='no')
     call output ('File name: ', advance='no')
     call output (trim(Filename), advance='no')
     call blanks (2)
     call output ('FileAccess: ', advance='no')
     call output (FileAccess, advance='no')
     if ( present(hdfVersion) ) then
       call blanks (2)
       call output ('hdfVersion: ', advance='no')
       call output (hdfVersion, advance='no')
     endif
     call blanks (2)
     call output ('adding meta data?: ', advance='no')
     call output (myaddingmetadata, advance='yes')
   endif
   if ( present(hdfVersion) ) then
     myhdfVersion = hdfVersion
   else
     myhdfVersion = DEFAULT_HDFVERSION
   endif
   if(myhdfVersion == WILDCARDHDFVERSION) then
     myhdfVersion = mls_hdf_version(trim(FileName))
   endif
   if ( myhdfVersion == HDFVERSION_4) then
     mls_sfstart = sfstart (FileName, FileAccess)
     return
   elseif ( myhdfVersion /= HDFVERSION_5) then
     mls_sfstart = WRONGHDFVERSION
     return
   endif
!   if ( PGS_MET4MLS_SF ) then
   if ( myaddingmetadata ) then
     if ( .not. HDF5_ACC_TYPES_TO_MET ) then
       myAccess = he2he5_fileaccess(FileAccess)
     elseif ( FileAccess == DFACC_RDWR ) then
       myAccess = HE5F_ACC_RDWR  ! HDF5_ACC_RDWR
     elseif ( FileAccess == DFACC_CREATE ) then
       myAccess = HE5F_ACC_TRUNC ! HDF5_ACC_CREATE
     elseif ( FileAccess == DFACC_RDONLY ) then
       myAccess = HE5F_ACC_RDONLY ! HDF5_ACC_RDONLY
     else
       myAccess = HDF5_ACC_DEFAULT
     endif
     returnStatus = PGS_MET_SFstart(trim(FileName), myAccess, mls_sfstart)
   else
     select case (FileAccess)
     case (DFACC_CREATE)
       call h5fcreate_f(trim(filename), H5F_ACC_TRUNC_F, mls_sfstart, &
         & returnStatus)
       if ( returnStatus /= 0 ) &
         & call output('Failing to create file; ' // &
         & 'perhaps you lack write permission', advance='yes')
     case (DFACC_RDWR)
       call h5fopen_f(trim(filename), H5F_ACC_RDWR_F, mls_sfstart, returnStatus)
     case (DFACC_RDONLY)
       call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, mls_sfstart, &
         & returnStatus)
     case default
       call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, mls_sfstart, &
         & returnStatus)
     end select
   endif
   if ( returnStatus /= 0 .and. myAddingMetaData) then
     call output ('Try again--PGS_MET_SFstart still unhappy; returns ')
     call output (returnStatus, advance='yes')                             
     mls_sfstart = -1                                                      
   elseif ( returnStatus /= 0) then                                            
     call output ('Try again--h5fopen_f/h5fcreate_f still unhappy; returns ')    
     call output (returnStatus, advance='yes')                             
     mls_sfstart = -1                                                      
   endif                                                                  
   if ( DEBUG ) then
     call output ('Returning from mls_sfstart an sdid: ', advance='no')
     call output (mls_sfstart, advance='yes')
   endif

  end function mls_sfstart

  ! --------------------------------------------------  mls_sfend  -----

  ! This function acts as a wrapper to allow hdf5 or hdf4 routines to be called
  ! Right now, it works for hdf4 files in general, but only for adding
  ! metadata to hdf5 files
  
  ! Therefore, when the grand unified hdf4/hdf5 interfaces are
  ! implemented this will probably need to take an added arg:
  ! the logical addingMetadata

  function mls_sfend(sdid, hdfVersion, addingMetadata)

    use HDF5, only: H5FClose_F
    ! Arguments

    integer, intent(in)           :: Sdid  
    integer                       :: Mls_sfend            
    integer, optional, intent(in) :: HdfVersion
    logical, optional, intent(in) :: Addingmetadata
    ! Local variables
    logical                       :: Myaddingmetadata
    integer                       :: MyhdfVersion
    integer, external :: PGS_MET_SFend
    logical, parameter :: DEBUG = .false.

    ! begin
   myaddingmetadata = .false.
   if ( present (addingmetadata) ) myaddingmetadata = addingmetadata
   if ( DEBUG ) then
     call output ('Entering mls_sfend with args ', advance='no')
     call output ('sdid: ', advance='no')
     call output (sdid, advance='no')
     call blanks (2)
     call output ('adding meta data?: ', advance='no')
     call output (myaddingmetadata, advance='yes')
   endif
   if ( present(hdfVersion) ) then
     myhdfVersion = hdfVersion
   else
     myhdfVersion = DEFAULT_HDFVERSION
   endif
   if(myhdfVersion == WILDCARDHDFVERSION) then
     ! myhdfVersion = mls_hdf_version(trim(FileName))
     call MLSMessage ( MLSMSG_Error, moduleName,  &
     & "You cannot mls_sfend a file with wildcardhdfversion w/o a file name" ) 
   endif
   if ( myhdfVersion == HDFVERSION_4) then
     mls_sfend = sfend (sdid)
     return
   elseif ( myhdfVersion /= HDFVERSION_5) then
     mls_sfend = WRONGHDFVERSION
     return
   endif
!    mls_sfend = h5fclose_c(sdid)
!   if ( PGS_MET4MLS_SF ) then
   if ( myaddingmetadata ) then
     mls_sfend = PGS_MET_SFend(sdid)
   else
     call h5fclose_f(sdid, mls_sfend)
   endif
!    mls_sfend = 0
   if ( DEBUG ) then
     call output ('Returning from mls_sfend a status: ', advance='no')
     call output (mls_sfend, advance='yes')
   endif

  end function mls_sfend

  ! --------------------------------------------  mls_hdf_version  -----

  ! This function returns the hdf version of the file:
  ! hdf version         returned value   integer
  !    hdf4                 hdf4           4
  !    hdf5                 hdf5           5
  !  unknown                ????      ERRORINH5FFUNCTION

  function mls_hdf_version(FileName, preferred_version, AccessType) &
   & result (hdf_version)

   use HDF5, only: H5FIs_HDF5_F
   ! Arguments

    character (len=*), intent(in)  :: FILENAME                                  
   ! character (len=4)             :: hdf_version                               
    integer, optional, intent(in)  :: PREFERRED_VERSION                     
    integer, optional, intent(in)  :: ACCESSTYPE   ! one of the hdf4 types  
    integer                        :: HDF_VERSION                           

    integer :: returnStatus                                                     
    integer :: myPreferred_Version                                              
    integer :: myAccessType                                                     
    logical :: is_hdf5                                                          

    ! begin

    if (FileName == '') then
      HDF_VERSION = MUSTSUPPLYFILENAME
      return
    endif
    
    if ( present(preferred_version) ) then
      myPreferred_Version = preferred_version
    else
      myPreferred_Version = WILDCARDHDFVERSION
    endif
    if ( present(accesstype) ) then
      myAccessType = accesstype
    else
      myAccessType = DFACC_READ
    endif

   ! If the file is being newly created, no way to find its hdf version yet
    if ( myAccessType == DFACC_CREATE ) then
      hdf_version = myPreferred_Version
      return
    endif

    ! Does the file really, really exist?
    if ( mls_exists(trim(FileName)) /= 0 ) then
      hdf_version = FILENOTFOUND
      return
    endif
    returnStatus = 0
    is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) ! was ... == 5
    call h5fis_hdf5_f(trim(FileName), is_hdf5, returnStatus)
    if ( returnStatus /= 0 ) then
!      hdf_version = '????'
      hdf_version = ERRORINH5FFUNCTION
    elseif ( is_hdf5 ) then
!      hdf_version = 'hdf5'
      hdf_version = HDFVERSION_5       ! 5
    else
!      hdf_version = 'hdf4'
      hdf_version = HDFVERSION_4       ! 4
    endif

   ! hdf_version ==  myPreferred_Version ?
   if ( myPreferred_Version /= WILDCARDHDFVERSION &
     & .and. &
     & hdf_version /= myPreferred_Version ) then
       print *, 'file name: ', trim(FileName)
       print *, 'myPreferred_Version: ', myPreferred_Version
       print *, 'is_hdf5: ', is_hdf5
       print *, 'returnStatus: ', returnStatus
       print *, 'hdf_version: ', hdf_version
       hdf_version = WRONGHDFVERSION
       call MLSMessage (MLSMSG_Crash, ModuleName, & 
        & "Who cares?")
   endif
  end function mls_hdf_version
!-----------------------------------------------

  subroutine mls_openFileName(filename, access, file_id, hdfVersion)
! Opens vanilla hdf 4 or 5 filename for various types of access:
! 'create', 'update', or 'readonly'
! Returns file_id
! By default, hdfVersion is WILDCARDHDFVERSION meaning it autodetects
! which version to open the filename under
    use HDF5, only: H5fopen_F, H5fcreate_F, H5fis_HDF5_F
    use HDF5, only: &
      & H5f_Acc_Rdonly_F, H5f_Acc_Rdwr_F, H5f_Acc_Excl_F
!
! External Variables
!
    character(len=*), intent(in) :: filename, access
    integer, intent(in), optional :: hdfVersion
    integer, intent(out) :: file_id
!
! Internal Variables
!
    integer :: error
    logical :: is_hdf5
    integer :: actual_hdfVersion

   ! Executable
   actual_hdfVersion = WILDCARDHDFVERSION
   if ( present(hdfVersion) ) actual_hdfVersion = hdfVersion
   if ( actual_hdfVersion == WILDCARDHDFVERSION ) then
     actual_hdfVersion = mls_hdf_version(filename)
   endif
   error = 0
   select case (actual_hdfVersion)
    case (HDFVERSION_4) 
     if (lowercase(trim(access)) == 'create') then
       file_id = mls_sfstart(trim(filename),DFACC_CREATE,actual_hdfVersion)
     elseif (lowercase(trim(access)) == 'update') then
       file_id = mls_sfstart(trim(filename),DFACC_RDWR,actual_hdfVersion)
     elseif (lowercase(trim(access)) == 'readonly') then
       file_id = mls_sfstart(trim(filename),DFACC_RDONLY,actual_hdfVersion)
     endif
     if (file_id .eq. -1) error = file_id 
    case (HDFVERSION_5)
      if (trim(access) == 'create') then 
          call h5fcreate_f(trim(filename), H5F_ACC_EXCL_F, file_id, error)
      elseif (trim(access) == 'update') then
          is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) 
          call h5fis_hdf5_f(trim(filename), is_hdf5, error)
       if (is_hdf5) then 
          call h5fopen_f(trim(filename), H5F_ACC_RDWR_F, file_id, error)
       endif
      elseif (trim(access) == 'readonly') then 
          is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) 
          call h5fis_hdf5_f(trim(filename), is_hdf5, error)
       if (is_hdf5) then 
          call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, file_id, error)
       endif
      else           ! same as 'update'
          is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) 
          call h5fis_hdf5_f(trim(filename), is_hdf5, error)
       if (is_hdf5) then 
          call h5fopen_f(trim(filename), H5F_ACC_RDWR_F, file_id, error)
       endif
      endif
    case default
      error = 1
    end select 

   if (error /= 0) then 
      call MLSMessage (MLSMSG_Error, ModuleName, & 
        & "Error: cannot "//lowercase(trim(access))//" file: "//trim(filename))
   endif
 
  end subroutine mls_openFileName

  subroutine mls_openFileType(MLSFile, error)
  ! Opens any kind of file for any kind of access
    type(MLSFIle_T) :: MLSFile
    integer, optional, intent(out) :: error
    !
    logical, parameter :: CASESENSITIVE = .true.
    ! logical, parameter :: DeeBug = .true.
    ! integer :: FileAccessType
    integer :: ioerror
    logical :: neededPCF
    integer :: PCBottom
    integer :: PCTop
    integer :: record_length
    ! character(len=8) :: toolbox_mode
    !
    if ( present(error) ) error = FILEALREADYOPEN
    if ( MLSFile%StillOpen ) return
    if ( DeeBug )  print *, 'Opening ' // trim(MLSFile%name)
    if ( DeeBug )  print *, 'type ', MLSFile%type
    PCBottom = MLSFile%PCFidRange%Bottom
    PCTop = MLSFile%PCFidRange%Top
    record_length = MLSFile%recordLength
    ! call dump(MLSFile, details=1)
    ! Fill in file name if blank and we're using the toolkit panoply
    if ( MLSFile%name == ' ' ) then
      if ( .not. UseSDPToolkit ) &
        & call MLSMessage (MLSMSG_Error, ModuleName, & 
        & "blank filename  and yet no toolkit", MLSFile=MLSFile)
      if ( MLSFile%PCFidRange%Top < 1 ) &
        & call MLSMessage (MLSMSG_Error, ModuleName, & 
        & "blank filename  and yet no PCF id range", MLSFile=MLSFile)
      call GetMLSFileNameFromPCF(MLSFile, ioerror)
    endif
    ! Do we need to find the hdfVersion?
   if ( &
     & any(MLSFile%type == (/l_hdf, l_swath, l_hdfeos, l_zonalavg /) ) .and. &
     & (MLSFile%HDFVersion == 0 .or. MLSFile%HDFVersion == WILDCARDHDFVERSION) &
     & .and. (MLSFile%name /= ' ') ) then
     if ( DeeBug )  print *, 'MLSFile%type ' , MLSFile%type
     if ( DeeBug )  print *, 'WILDCARDHDFVERSION ' , WILDCARDHDFVERSION
     MLSFile%HDFVersion = mls_hdf_version(trim(MLSFile%name))
     if ( DeeBug )  print *, 'MLSFile%HDFVersion ' , MLSFile%HDFVersion
    endif
    neededPCF = .true.

    ! If the file has already been created by this run, we don't want to
    ! clobber it or fail on open because it already exists
    ! Therefore, if lastoperation != "", reset access to 'rdwr'
    if ( MLSFile%access == DFACC_CREATE .and. MLSFile%lastOperation /= "" ) &
      & MLSFile%access = DFACC_RDWR
    ! if ( toolbox_mode == 'pg' .and. MLSFile%recordLength /= 0 ) then
    if ( MLSFile%type == l_tkgen .and. MLSFile%recordLength /= 0 ) then
      if( PCTop > PCBottom ) then
        if ( DeeBug )  print *, '1'
        MLSFile%FileId%f_id = Mls_io_gen_openF ( l_tkgen, CASESENSITIVE, &
        & ioerror, record_length, &
        & PGSd_IO_Gen_RSeqFrm, &
        & PCBottom=PCBottom, PCTop=PCTop, &
        & inp_rec_length=MLSFile%recordLength)
      else
        if ( DeeBug )  print *, '2'
        ! print *, 'pg', CASESENSITIVE, &
        ! & ioerror, record_length, &
        ! & PGSd_IO_Gen_RSeqFrm, &
        ! & PCTop, MLSFile%recordLength
        MLSFile%FileId%f_id = Mls_io_gen_openF ( l_tkgen, CASESENSITIVE, &
        & ioerror, record_length, &
        & PGSd_IO_Gen_RSeqFrm, &
        & thePC=PCTop, inp_rec_length=MLSFile%recordLength)
        if ( DeeBug )  print *, "After iogenopen, ioerror: ", ioerror
      endif
    elseif ( MLSFile%recordLength /= 0 ) then
      if ( DeeBug )  print *, '3'
      MLSFile%FileId%f_id = mls_io_gen_openF(MLSFile%type, CASESENSITIVE, &
      & ioerror, record_length, MLSFile%access, &
      & MLSFile%Name, inp_rec_length=MLSFile%recordLength)
      neededPCF = .false.
    elseif ( .not. UseSDPToolkit ) then
      if ( DeeBug )  print *, '4'
      MLSFile%FileId%f_id = mls_io_gen_openF(MLSFile%type, CASESENSITIVE, &
      & ioerror, record_length, MLSFile%access, &
      & MLSFile%Name, hdfVersion=MLSFile%hdfVersion)
      neededPCF = .false.
    elseif( PCTop > PCBottom ) then
      if ( DeeBug )  print *, '5'
      if ( DeeBug )  print *, 'Trying to open ', trim(MLSFile%Name)
      ! print *, 'Toolbox mode ', trim(toolbox_mode)
      if ( DeeBug )  print *, 'hdf version ', MLSFile%hdfVersion
      MLSFile%FileId%f_id = mls_io_gen_openF(MLSFile%type, CASESENSITIVE, &
      & ioerror, record_length, MLSFile%access, &
      & MLSFile%Name, MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%Top, &
      & hdfVersion=MLSFile%hdfVersion)
      neededPCF = .true.
      if ( DeeBug )  print *, 'Did it'
    elseif( PCTop > 0 ) then
      if ( DeeBug )  print *, '6'
      MLSFile%FileId%f_id = mls_io_gen_openF(MLSFile%type, CASESENSITIVE, &
      & ioerror, record_length, MLSFile%access, &
      & MLSFile%Name, thePC=PCTop, &
      & hdfVersion=MLSFile%hdfVersion)
      neededPCF = .true.
    else
      if ( DeeBug )  print *, '7'
      MLSFile%FileId%f_id = mls_io_gen_openF(MLSFile%type, CASESENSITIVE, &
      & ioerror, record_length, MLSFile%access, &
      & MLSFile%Name, hdfVersion=MLSFile%hdfVersion)
      neededPCF = .false.
    endif
      if ( DeeBug )  print *, 'ioerror: ', ioerror
    if ( ioerror == 0 ) then
      MLSFile%StillOpen=.true.
      ! The next matches 'hg' and 'pg'
      if ( DeeBug )  print *, 'About to call GetMLSFilePCFidFromName'
      if ( neededPCF ) call GetMLSFilePCFidFromName(MLSFile, ioerror)
      if ( DeeBug )  print *, 'Done with that call'
    endif
    MLSFile%errorCode = ioerror
    MLSFile%lastOperation = 'open'
    if ( present(error) ) error = ioerror
  end subroutine mls_openFileType

!-----------------------------------------------
  subroutine mls_closeFileID(file_id, filename, hdfVersion)
! Closes vanilla hdf 4 or 5 filename
! By default, hdfVersion is WILDCARDHDFVERSION meaning it autodetects
! which version to close the filename under
! so unless you supply hdfVersion, you'd better supply filename
    use HDF5, only: H5FClose_F
!
! External Variables
!
    integer, intent(in) :: file_id
    character(len=*), intent(in), optional :: filename
    integer, intent(in), optional :: hdfVersion
!
! Internal Variables
!
    integer :: error
    integer :: actual_hdfVersion

    ! Executable
    actual_hdfVersion = WILDCARDHDFVERSION
    if ( present(hdfVersion) ) actual_hdfVersion = hdfVersion
    if ( actual_hdfVersion == WILDCARDHDFVERSION ) then
      if( present(filename) ) then
        actual_hdfVersion = mls_hdf_version(filename)
      else
        call MLSMessage (MLSMSG_Error, ModuleName, & 
         & "You must supply a filename to close a file with wildcardhdfversion")
      endif
    endif
    select case (actual_hdfVersion)
    case (HDFVERSION_4) 
       error = sfend(file_id)
    case (HDFVERSION_5) 
       call h5fclose_f(file_id, error)
    case default
       error = sfend(file_id)       
    end select 

    if (error /= 0) then 
       call MLSMessage (MLSMSG_Error, ModuleName, "Error closing file.")
    endif

  end subroutine mls_closeFileID

  subroutine MLS_CloseFileType( MLSFile, error )
  ! Closes any kind of file
    type(MLSFIle_T) :: MLSFile
    integer, optional, intent(out) :: error
    !
    integer :: ioerror
    !
    if ( MLSFile%hdfVersion < 1 ) then
      ioerror = mls_io_gen_closeF(MLSFile%type, MLSFile%FileID%f_id)
    else
      ! print *, 'Trying to close ', trim(MLSFile%Name)
      ! print *, 'Toolbox mode ', trim(toolbox_mode)
      ! print *, 'hdf version ', MLSFile%hdfVersion
      ioerror = mls_io_gen_closeF(MLSFile%type, MLSFile%FileID%f_id, &
       MLSFile%Name, MLSFile%hdfVersion)
    endif
    MLSFile%StillOpen=.false.
    MLSFile%errorCode = ioerror
    MLSFile%lastOperation = 'close'
    MLSFile%FileID = FileIds_T( 0, 0, 0 )
    if ( present(error) ) error = ioerror
  end subroutine mls_CloseFileType

!----------------------------------------------------  mls_exists  -----
  integer function mls_exists(filename)
  ! returns 0 if file exists, FILENOTFOUND if not
  ! Argument
  character (len=*) :: filename
  ! Internal variables
  logical :: exist
  inquire(file=filename, exist=exist)
  mls_exists = merge(0, FILENOTFOUND, exist)
  end function mls_exists

  !--------------------------------------------  transfer_MLSFile  -----
  integer function transfer_MLSFile ( ITEM, path, name )

  ! This routine transfers an MLSFile, e.g. resetting its path
  ! --- Don't be fooled, it does not physically relocate the file ---
  !     To do something like that see
  !     Execute or Shell_Command in the machine module

    ! Dummy arguments
    type (MLSFile_T)                       :: ITEM
    character(len=*), optional, intent(in) :: path
    character(len=*), optional, intent(in) :: Name
    ! Internal variables
    character(len=MAXFILENAMELENGTH) :: oldpath
    character(len=MAXFILENAMELENGTH) :: oldname

    transfer_MLSFile = 0
    if ( present(Name    ) ) item%Name  = Name
    if ( present(path) ) then
      call split_path_name(item%name, oldpath, oldname)
      ! Remember: split_path_name returns a path with a terminating '/'
      ! (unless blank)
      item%name = trim(path) // oldname
    endif   
  end function transfer_MLSFile

! ---------------------------------------------- unMaskName ------

! This function returns the name minus its masking portion
! We do this to fool the parser into thinking it's not seen
! this name before. Otherwise the parser may not preserve its case.

  function unMaskName(inName) result(outName)
  character(len=*), intent(in)     :: inName        ! Name to be unmasked
  character(len=len(inName)) :: outName             ! unmasked name
  ! Executable
  if ( len_trim(inName)  < 1 ) then
    outName = ''
  elseif (index(inName, MASKINGTAPE) < 1) then
    outName = inName
  else
    call ReplaceSubString(trim(inName), outName, MASKINGTAPE, '')
  endif
  end function unMaskName

! ---------------------------------------------- unSplitName ------

! This function returns the name minus its splitting number
! Which transforms strings like
! /long/path/MLS-Aura_L2GP-DGG16_v01-31_c01.he5
! into
! /long/path/MLS-Aura_L2GP-DGG_v01-31_c01.he5
! It assumes the split name takes one of the following forms
! (dgg)   ...L2GP-DGGnn_...
! (l2aux) ...L2AUX-DGMnn_...

  function unSplitName(inName) result(outName)
  character(len=*), intent(in)     :: inName        ! Name to be unsplit
  character(len=len(inName)) :: outName             ! unsplit name
  ! Local variables
  ! character(len=len(inName)) :: tempName
  character(len=*), parameter :: dgg_type = 'L2GP-DGG'
  character(len=*), parameter :: l2aux_type = 'L2AUX-DGM'
  character(len=*), parameter :: underscore = '_'
  character(len=16)           :: sub1
  character(len=16)           :: sub2
  character(len=8)            :: nn
  ! Executable
  outName = ''
  if ( len_trim(inName)  < 1 ) return
  ! tempName = lowerCase(inName)
  if (index(inName, dgg_type) > 0) then
    sub1 = dgg_type
  elseif (index(inName, l2aux_type) > 0) then
    sub1 = l2aux_type
  elseif (index(inName, lowerCase(dgg_type)) > 0) then
    sub1 = lowerCase(dgg_type)
  elseif (index(inName, lowerCase(l2aux_type)) > 0) then
    sub1 = lowerCase(l2aux_type)
  else
    return
  endif
  call ExtractSubString (inName, nn, trim(sub1), underscore)
  if ( len_trim(nn) < 1 ) return
  sub2 = trim(sub1) // trim(nn)
  call ReplaceSubString(trim(inName), outName, trim(sub2), trim(sub1))
  end function unSplitName

!-----------------------------------------------
!       Private routines
!------------------------
  subroutine GetMLSFileNameFromPCF(MLSFile, ioerror)
    type(MLSFile_T) :: MLSFile
    integer, intent(out) :: ioerror
    integer :: pcfid
    integer :: version
    ioerror = 1
    if ( MLSFile%PCFidRange%top < 1 ) return
    if ( MLSFile%PCFidRange%top < MLSFile%PCFidRange%Bottom ) return
    do pcfid = MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%top
      version = 1
      ioerror = Pgs_pc_getReference(pcfid, version, MLSFile%name)
      if ( ioerror == 0 ) return
    enddo
  end  subroutine GetMLSFileNameFromPCF
  subroutine GetMLSFilePCFidFromName(MLSFile, ioerror)
    type(MLSFile_T) :: MLSFile
    integer, intent(out) :: ioerror
    integer :: pcfid
    integer :: version
    character(len=FileNameLen) :: name
    ioerror = 1
    if ( MLSFile%PCFidRange%top < 1 ) return
    if ( MLSFile%PCFidRange%top < MLSFile%PCFidRange%Bottom ) return
    ! print *, 'MLSFile%PCFidRange%Bottom: ', MLSFile%PCFidRange%Bottom
    ! print *, 'MLSFile%PCFidRange%top: ', MLSFile%PCFidRange%top
    do pcfid = MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%top
      version = 1
      ioerror = Pgs_pc_getReference(pcfid, version, name)
      if ( ioerror == 0 ) then
        MLSFile%PCFID = pcfid
        if ( trim(name) == trim(MLSFile%name) ) return
      endif
    enddo
    ! print *, 'Failed to find a PCFid for: ', trim(MLSFile%name)
  end  subroutine GetMLSFilePCFidFromName
  elemental function strip_path(fullName) result(name)
    character(len=*), intent(in) :: fullName
    character(len=max(1, len(fullName))) :: name
    character(len=max(1, len(fullName))) :: path
    !
    name = ' '
    if ( len_trim(fullName) < 1 ) return
    call split_path_name(fullName, path, name)
  end function strip_path

  ! ------------------------------------------  mls_io_gen_closeF  -----

  ! This function closes a generic file using either the toolbox
  ! or else a Fortran CLOSE statement
  ! according to toolbox_mode:
  ! 'cl' for l3ascii files opened with simple fortran 'open'
  ! 'gd' for grid files opened with gdopen
  ! 'hg' for hdf4/5 files opened with sfstart/h5fopen_f; e.g. l1brad
  ! 'pg' for generic files opened with pgs_io_gen_openF
  ! 'sw' for swath files opened with swopen

  ! It returns a non-zero error status only if unsuccessful

  ! It must be given a FileHandle as an arg
  ! (A later version may allow choice between file handle and file name)
  ! (This version only uses a file name in autodetecting its hdf version)
  function mls_io_gen_closeF( mode, theFileHandle, &
    & FileName, hdfVersion, debugOption ) &
    &  result (ErrType)

    use HDF5, only: H5FClose_F
    ! Dummy arguments
    integer                                   :: ErrType
    integer, intent(in)                       :: Mode
    integer, intent(in)                       :: TheFileHandle
    character (len=*), optional, intent(in)   :: FileName
    integer, optional, intent(in)             :: HdfVersion
    logical, optional, intent(in)             :: DebugOption

    ! Local
    logical ::                            debug
    integer :: myhdfVersion

    logical, parameter :: PRINT_EVERY_CLOSE=.false.
    ! character (LEN=2) :: the_eff_mode
    integer :: the_eff_mode

    ! begin

    if(present(debugOption)) then
      debug = debugOption
   else
      debug = .false.
   endif
   the_eff_mode = mode
   if(UseSDPToolkit) then
   ! Using Toolkit
    ! the_eff_mode = LowerCase(toolbox_mode(1:2))
   ! Not Using Toolkit
   else
      ! the_eff_mode = LowerCase(toolbox_mode(1:2))
      ! if(the_eff_mode == 'pg') the_eff_mode = 'cl'
      if(the_eff_mode == l_tkgen) the_eff_mode = l_ascii ! l_close
   endif

  if ( debug ) then
    call output('Call to mls_io_gen_closeF', &
    & advance='yes')
    call output('the_eff_mode: ', advance='no')
    call blanks(2)
    call output(the_eff_mode, advance='yes')
    call output('theFileHandle: ', advance='no')
    call blanks(2)
    call output(theFileHandle, advance='yes')
    if ( present (hdfVersion) ) then
      call output('hdfVersion: ', advance='no')
      call blanks(2)
      call output(hdfVersion, advance='yes')
    endif
    if ( present (fileName) ) then
      call output('fileName: ', advance='no')
      call blanks(2)
      call output(trim(fileName), advance='yes')
    endif
  endif
  ErrType = 0
  myhdfVersion = WILDCARDHDFVERSION
  if ( present(hdfVersion) ) myhdfVersion = hdfVersion
   ! hdfVersion unimportant for 'pg' or 'cl' operations
   ! if (the_eff_mode == 'pg' .or. the_eff_mode == 'cl' ) then
   ! if (the_eff_mode == l_tkgen .or. the_eff_mode == l_close ) then
   if (the_eff_mode == l_tkgen .or. the_eff_mode == l_ascii ) then
     ErrType = 0
   elseif ( myhdfVersion /= WILDCARDHDFVERSION ) then
     ErrType = 0
   elseif ( present(FileName) ) then
     myhdfVersion = mls_hdf_version(trim(FileName), hdfVersion, DFACC_READ)
     if ( debug ) then
       call output('mls_hdf_versionF', &
       & advance='yes')
       call output('myhdfVersion: ', advance='no')
       call blanks(2)
       call output(myhdfVersion, advance='yes')
     endif
     if ( myhdfVersion < 0 ) then
        ErrType = myhdfVersion
        return
     endif
   elseif ( present(hdfVersion) ) then
     myhdfVersion = hdfVersion
   else
     myhdfVersion = DEFAULT_HDFVERSION
   endif
    select case (the_eff_mode)

    ! case('pg')
    case(l_tkgen)
      ErrType = PGS_IO_Gen_CLoseF(theFileHandle)

    ! case('sw')
    case(l_swath)
      if(myhdfVersion == HDFVERSION_5) then
        ErrType = he5_swclose(theFileHandle)
        if ( debug ) then
          call output('he5_swclose', &
          & advance='yes')
          call output('ErrType: ', advance='no')
          call blanks(2)
          call output(ErrType, advance='yes')
        endif
      elseif(myhdfVersion == HDFVERSION_4) then
        ErrType = swclose(theFileHandle)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    ! case('gd')
    case(l_hdfeos)
      if(myhdfVersion == HDFVERSION_5) then
        ErrType = he5_gdclose(theFileHandle)
      elseif(myhdfVersion == HDFVERSION_4) then
        ErrType = gdclose(theFileHandle)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    ! case('hg')
    case(l_hdf)
      if(myhdfVersion == HDFVERSION_5) then
        call h5fclose_f(theFileHandle, ErrType)
      elseif(myhdfVersion == HDFVERSION_4) then
        ErrType = sfend(theFileHandle)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    ! case('cl')
    case(l_ascii) ! (l_ascii, l_close)
      close(unit=theFileHandle, iostat=ErrType)

      if(ErrType /= 0 .or. PRINT_EVERY_CLOSE) then
        call output( 'Fortran closing unit ', advance='no')
        call output(  theFileHandle, advance='yes')
      endif

      if(ErrType /= 0) then
        call output( 'iostat ', advance='no')
        call output(  ErrType, advance='yes')
        call io_error('io error in MLSFiles: mls_io_gen_closeF' // &
          & ' Fortran close', ErrType, 'unknown')
      endif

    case default
      ErrType = UNKNOWNTOOLBOXMODE

    end select

  end function mls_io_gen_closeF

  ! -------------------------------------------  mls_io_gen_openF  -----

  ! This function opens a generic file using either the toolbox
  ! or else a Fortran OPEN statement
  ! according to toolbox_mode:
  ! 'gd' for grid files opened with gdopen
  ! 'hg' for hdf4/5 files opened with sfstart/h5fopen_f; e.g. l1brad
  ! 'pg' for generic files opened with pgs_io_gen_openF
  ! 'op' for l3ascii files opened with simple fortran 'open'
  ! 'sw' for swath files opened with swopen

  ! It returns theFileHandle corresponding to the FileName or the PC

  ! If given a FileName as an arg and a range of PC numbers
  ! [PCBottom, PCTop] which are integers
  ! it will attempt to find a corresponding PC

  ! If given a PC it will attempt to find the corresponding FileName

  ! toolbox_mode                  meaning
  ! PGS_IO_GEN_OpenF              use PGS_IO_Gen_OpenF or fail
  !      swopen                   use swopen or fail
  !      gdopen                   use gdopen or fail
  !       open                    use Fortran or fail

  ! If the FileName is not found, it sets ErrType=NAMENOTFOUND
  ! otherwise ErrType=0

  ! This is useful because all the Toolbox routines refer to files
  ! by their PC numbers, not their names

  function mls_io_gen_openF(mode, caseSensitive, ErrType, &
    & record_length, FileAccessType, &
    & FileName, PCBottom, PCTop, versionNum, unknown, thePC, &
    & hdfVersion, debugOption, inp_rec_length) &
    &  result (theFileHandle)

    use IO_Stuff, only: Get_Lun

    ! Dummy arguments
    integer                                 :: TheFileHandle
    integer, intent(in)                     :: Mode
    logical,  intent(in)                    :: CaseSensitive
    integer,  intent(out)                   :: ErrType
    integer,  intent(in)                    :: Record_length
    integer, intent(in)                     :: FileAccessType ! One of hdf4 dfacc*
    character (len=*), optional, intent(in) :: FileName  
    integer,  optional, intent(in)          :: PCBottom, PCTop
    integer,  optional                      :: VersionNum
    logical, optional, intent(in)           :: Unknown
    integer, optional, intent(in)           :: ThePC     
    integer, optional, intent(in)           :: HdfVersion
    logical, optional, intent(in)           :: DebugOption
    integer, optional, intent(in)           :: Inp_rec_length

    ! Local
    integer :: myhdfVersion

    logical, parameter :: DEFAULT_PRINT_EVERY_OPEN=.false.
    integer, parameter :: FH_ON_ERROR=-99
    integer, parameter :: KEYWORDLEN=12 ! Max length of keywords in OPEN(...)
    character (LEN=MAXFILENAMELENGTH) :: myName
    integer :: myPC
    integer                       :: version, returnStatus, your_version
    character (LEN=KEYWORDLEN) :: access, action, form, position, status
    ! character (LEN=2) :: the_eff_mode
    integer :: the_eff_mode
    integer                       :: unit
    logical ::                            debug
    logical ::                            PRINT_EVERY_OPEN

    ! begin

    if(present(debugOption)) then
      debug = debugOption
   else
      debug = .false.
   endif

   PRINT_EVERY_OPEN = DEFAULT_PRINT_EVERY_OPEN .or. debug
   returnStatus = 0           ! In case using Toolkit but supplied FileName
   myPC = 0
    ! In case of premature return
    theFileHandle = FH_ON_ERROR

    if(present(versionNum)) then
      version = versionNum
    else
      version = 1
    endif

   the_eff_mode = mode
   if(UseSDPToolkit) then
    ! the_eff_mode = LowerCase(toolbox_mode(1:2))
    your_version = version
   ! Using Toolkit
    if(present(thePC)) then
      myPC = thePC
      returnStatus = Pgs_pc_getReference(thePC, your_version, &
        & myName)
      if ( debug ) then
          call output('Call to Pgs_pc_getReference', &
          & advance='yes')
          call output('returnStatus: ', advance='no')
          call blanks(2)
          call output(returnStatus, advance='yes')
          call output('thePC: ', advance='no')
          call blanks(2)
          call output(thePC, advance='yes')
          call output('your_version: ', advance='no')
          call blanks(2)
          call output(your_version, advance='yes')
      endif
    elseif(present(FileName)) then
      myName = FileName
      ! if(LowerCase(toolbox_mode(1:2)) == 'pg') then
      if(mode == l_tkgen) then
        myPC = GetPCFromRef(trim(FileName), PCBottom, PCTop, &
          & caseSensitive, returnStatus, your_version, &
          & debugOption=debugOption)
      endif

    else
      ErrType = MUSTSUPPLYFILENAMEORPC
      if ( debug ) & 
       & call output('Must supply file name or pc to mls_io_gen_openF', &
       & advance='yes')
      return
    endif

   ! Not Using Toolkit
   ! Must supply FileName, use generic Fortran open
   elseif(.not. present(FileName)) then
      ErrType = NOPCIFNOTOOLKIT
      if ( debug ) & 
       & call output('No toolkit: must supply file name to mls_io_gen_openF', &
       & advance='yes')
      return
      
   else
      myName = FileName
      ! the_eff_mode = LowerCase(toolbox_mode(1:2))
      ! if(the_eff_mode == 'pg') the_eff_mode = 'op'
      if(the_eff_mode == l_tkgen) the_eff_mode = l_open
   endif

   ! hdfVersion unimportant for 'pg' or 'op' operations
   ! if (the_eff_mode == 'pg' .or. the_eff_mode == 'op' ) then
   myhdfVersion = WRONGHDFVERSION
   if ( present(hdfVersion) ) myHdfVersion = hdfVersion
   if ( any( the_eff_mode == (/l_tkgen, l_open, l_ascii/) ) ) then
     myhdfVersion = WILDCARDHDFVERSION
   elseif ( .not. any( myhdfVersion == (/HDFVERSION_4, HDFVERSION_5/) ) ) then
     if ( debug ) then
       call output( 'myName: ', advance='no' )
       call output( trim(myName), advance='yes' )
       call output( 'FileAccessType: ', advance='no' )
       call output( FileAccessType, advance='yes' )
       call outputnamedValue( 'the_eff_mode', the_eff_mode )
       call outputnamedValue( 'l_tkgen', l_tkgen )
       call outputnamedValue( 'l_open', l_open )
       call outputnamedValue( 'l_ascii', l_ascii )
       if ( present(hdfVersion) ) then
       call output( 'hdfVersion: ', advance='no' )
       call output( hdfVersion, advance='yes' )
       endif
     endif
     myhdfVersion = mls_hdf_version(trim(myName), hdfVersion, FileAccessType)             
   endif

   if ( debug ) then
       call output('Arguments and options in call to mls_io_gen_openF', &
       & advance='yes')
       call output('Mode: ', advance='no')
       call blanks(2)
       if ( FILESTRINGTABLE ) then
       call display_string ( lit_indices(the_eff_mode), strip=.true.)                                  
       call blanks(2)
       endif
       call output(the_eff_mode, advance='yes')
       call output('l_hdf: ', advance='no')
       call blanks(2)
       call output(l_hdf, advance='yes')
       call output('l_ascii: ', advance='no')
       call blanks(2)
       call output(l_ascii, advance='yes')
       call output('l_open: ', advance='no')
       call blanks(2)
       call output(l_open, advance='yes')
       call output('File Name: ', advance='no')
       call blanks(2)
       call output(trim(myName), advance='yes')
       call output('PCF-supplied number: ', advance='no')
       call blanks(2)
       call output(myPC, advance='yes')
       call output('Case sensitive? ', advance='no')
       call blanks(2)
       call output(caseSensitive, advance='yes')
       call output('File access type ', advance='no')
       call blanks(2)
       call output(FileAccessType, advance='yes')
       call output('Return status ', advance='no')
       call blanks(2)
       call output(returnStatus, advance='yes')
       call output('hdf version ', advance='no')
       call blanks(2)
       call output(myhdfVersion, advance='yes')
   endif

   if ( myhdfVersion < 0 .and. any( the_eff_mode == &
   & (/ l_swath, l_hdf, l_hdfeos /) ) ) then
     ErrType = myhdfVersion
     return
   endif
    your_version = version
    if ( debug ) call outputnamedValue( 'the_eff_mode', the_eff_mode )
    select case (the_eff_mode)

    ! case('pg')
    case(l_tkgen)
      if(returnStatus == 0) then
         ErrType = PGS_IO_Gen_OpenF(myPC, FileAccessType, record_length, &
          & theFileHandle, your_version)
      else
        ErrType = returnStatus
       endif

    ! case('sw')
    case(l_swath)
      if(returnStatus /= 0) then
        ErrType = returnStatus
        return
      elseif(myhdfVersion == HDFVERSION_5) then
        theFileHandle = he5_swopen(trim(myName), &
          & he2he5_fileaccess(FileAccessType))
      elseif(myhdfVersion == HDFVERSION_4) then
        theFileHandle = swopen(trim(myName), FileAccessType)
      else
        ErrType = NOSUCHHDFVERSION
        return
      endif
      if(theFileHandle <= 0) then                                          
        ErrType = min(theFileHandle, -1)                                   
      else                                                                 
        ErrType = 0                                                        
      endif                                                                
      if ( debug ) then                                                    
          call output('Args and results from he5_swopen', &                
          & advance='yes')                                                 
          call output('File Name: ', advance='no')                         
          call blanks(2)                                                   
          call output(trim(myName), advance='yes')                         
          call output('File Access: ', advance='no')                       
          call blanks(2)                                                   
          call output(he2he5_fileaccess(FileAccessType), advance='yes')  
          call output('theFileHandle: ', advance='no')                     
          call blanks(2)                                                   
          call output(theFileHandle, advance='yes')                        
      endif                                                                

    ! case('gd')
    case(l_hdfeos)
      if(returnStatus /= 0) then
        ErrType = returnStatus
        return
      elseif(myhdfVersion == HDFVERSION_5) then
        theFileHandle = he5_gdopen(trim(myName), &
          & he2he5_fileaccess(FileAccessType))
      elseif(myhdfVersion == HDFVERSION_4) then
        theFileHandle = gdopen(trim(myName), FileAccessType)
      else
        ErrType = NOSUCHHDFVERSION
        return
      endif
      if(theFileHandle <= 0) then         
        ErrType = min(theFileHandle, -1)  
      else                                
        ErrType = 0                       
      endif                               

    ! case('hg')
    case(l_hdf)
      theFileHandle = -1   ! This is the error value expected by hdf4/5
      if(returnStatus /= 0) then
        ErrType = returnStatus
        return
      elseif(myhdfVersion == HDFVERSION_5) then
        ! print *, 'We are using the right mls_sfstart'
        ! print *, 'FileAccessType ', FileAccessType
        theFileHandle = mls_sfstart(trim(myName), FileAccessType, &
          & HDFVERSION_5)
      elseif(myhdfVersion == HDFVERSION_4) then
        theFileHandle = sfstart(trim(myName), FileAccessType)
      else
        ErrType = NOSUCHHDFVERSION
        return
      endif
      if(theFileHandle <= 0) then         
        ErrType = min(theFileHandle, -1)  
      else                                
        ErrType = 0                       
      endif                               

    ! case('op')
    case(l_ascii, l_open)
      theFileHandle = FH_ON_ERROR
      if ( debug ) then
        call outputNamedValue( 'FileAccessType', FileAccessType )
        call outputNamedValue( 'DFACC_RDWR', DFACC_RDWR )
      endif
      select case (FileAccessType)
      case(PGSd_IO_Gen_RSeqFrm, DFACC_RDONLY)
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'read'
        position = 'rewind'
      case(PGSd_IO_Gen_RSeqUnf)
        status = 'old'
        access = 'sequential'
        form = 'unformatted'
        action = 'read'
        position = 'rewind'
      case(PGSd_IO_Gen_RDirFrm)
        status = 'old'
        access = 'direct'
        form = 'formatted'
        action = 'read'
        position = 'rewind'
      case(PGSd_IO_Gen_RDirUnf)
        status = 'old'
        access = 'direct'
        form = 'unformatted'
        action = 'read'
        position = 'rewind'
      case(PGSd_IO_Gen_WSeqFrm, DFACC_CREATE)
        status = 'new'
        access = 'sequential'
        form = 'formatted'
        action = 'write'
        position = 'rewind'
      case(PGSd_IO_Gen_WSeqUnf)
        status = 'new'
        access = 'sequential'
        form = 'unformatted'
        action = 'write'
        position = 'rewind'
      case(PGSd_IO_Gen_WDirFrm)
        status = 'new'
        access = 'direct'
        form = 'formatted'
        action = 'write'
        position = 'rewind'
      case(PGSd_IO_Gen_WDirUnf)
        status = 'new'
        access = 'direct'
        form = 'unformatted'
        action = 'write'
        position = 'rewind'
      case(PGSd_IO_Gen_USeqFrm, DFACC_RDWR)
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'readwrite'
        position = 'rewind'
      case(PGSd_IO_Gen_USeqUnf)
        status = 'old'
        access = 'sequential'
        form = 'unformatted'
        action = 'readwrite'
        position = 'rewind'
      case(PGSd_IO_Gen_UDirFrm)
        status = 'old'
        access = 'direct'
        form = 'formatted'
        action = 'readwrite'
        position = 'rewind'
      case(PGSd_IO_Gen_UDirUnf)
        status = 'old'
        access = 'direct'
        form = 'unformatted'
        action = 'readwrite'
        position = 'rewind'
      case(PGSd_IO_Gen_ASeqFrm)
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'readwrite'
        position = 'append'
      case(PGSd_IO_Gen_ASeqUnf)
        status = 'old'
        access = 'sequential'
        form = 'unformatted'
        action = 'readwrite'
        position = 'append'
      case default
        ! ErrType = UNKNOWNFILEACCESSTYPE
        ! if ( debug ) &
        !  & call output('Unknown file access type', advance='yes')
        ! return
        status = 'unknown'
        access = 'sequential'
        form = 'formatted'
        action = 'readwrite'
        position = 'rewind'
      end select

      call get_lun ( unit, msg=.false. )
      if( unit < 0 ) then
        ErrType = NOFREEUNITS
        if ( debug ) &
         & call output('No free io units available', advance='yes')
        return
      endif

      if (present(unknown)) then
        if (unknown) status = 'unknown'
      end if

      if ( debug ) then
        call output( 'access ' // access, advance='yes')
        call output( 'action ' // action, advance='yes')
        call output( 'form ' // form, advance='yes')
        call output( 'position ' // position, advance='yes')
        call output( 'status ' // status, advance='yes')
      endif
      if ( present(inp_rec_length) ) then
        open(unit=unit, recl=inp_rec_length, form=form, &
          & status=status, file=trim(myName), iostat=ErrType)
      elseif(access /= 'direct') then
        open(unit=unit, access=access, action=action, form=form, &
          & position=position, status=status, file=trim(myName), iostat=ErrType)
      else
        open(unit=unit, access=access, action=action, form=form, &
          & status=status, file=trim(myName), iostat=ErrType)
      endif

      if(ErrType /= 0 .or. PRINT_EVERY_OPEN) then
        call output( 'Fortran opening unit ', advance='no')
        call output(  unit, advance='yes')
        call output( 'access ' // access, advance='yes')
        call output( 'action ' // action, advance='yes')
        call output( 'form ' // form, advance='yes')
        call output( 'position ' // position, advance='yes')
        call output( 'status ' // status, advance='yes')
        call output( 'file ' // trim(myName), advance='yes')
      endif

      if(ErrType /= 0) then
        call output( 'iostat ', advance='no')
        call output(  ErrType, advance='yes')
        call io_error('io error in MLSFiles: mls_io_gen_openF' // &
          & ' Fortran open', ErrType, trim(myName))
      else
        theFileHandle = unit
      endif

    case default
      ErrType = UNKNOWNTOOLBOXMODE

    end select

    if(ErrType /= 0) then
      theFileHandle = FH_ON_ERROR
    endif
    
    if( debug ) then
       call output('Error Type (0 means none): ', advance='no')
       call blanks(2)
       call output(ErrType, advance='yes')
       call output('record_length: ', advance='no')
       call blanks(2)
       call output(record_length, advance='yes')
       call output('theFileHandle: ', advance='no')
       call blanks(2)
       call output(theFileHandle, advance='yes')
    endif

  end function mls_io_gen_openF

!====================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSFiles.f90,v 2.113 2019/01/30 23:56:39 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MLSFiles
!====================

!
! $Log: MLSFiles.f90,v $
! Revision 2.113  2019/01/30 23:56:39  pwagner
! Corrected various comments
!
! Revision 2.112  2018/04/19 02:09:49  vsnyder
! Remove USE statements for unused names
!
! Revision 2.111  2018/04/16 18:25:18  pwagner
! Actually obey NEVERFAIL in ReadL1BData_MLSFile
!
! Revision 2.110  2018/02/08 23:16:41  pwagner
! Moved Dump, accessType, and Split_path_name to other modules
!
! Revision 2.109  2017/12/12 21:25:32  pwagner
! Raise char length limit of nameArray in GetPCFromRef
!
! Revision 2.108  2017/11/15 00:09:31  pwagner
! Improve appearance Dumping each MLSFile
!
! Revision 2.107  2017/01/19 23:35:01  pwagner
! Improve appeearance when dumping an MLSFile
!
! Revision 2.106  2017/01/13 01:27:27  pwagner
! Dump_MLSFile now uses OutputTable
!
! Revision 2.105  2016/09/21 00:38:41  pwagner
! May Dump filedatabase as a table
!
! Revision 2.104  2016/08/09 18:13:34  pwagner
! MLS_CloseFile now sets FileIDs to 0
!
! Revision 2.103  2015/03/28 01:13:24  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.102  2014/09/05 00:01:11  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.100  2014/04/02 23:02:10  pwagner
! Removed redundant open_ and close_MLSFile
!
! Revision 2.99  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.98  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.97  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.96  2013/07/24 19:01:03  pwagner
! Fixed bug opening non-hdf file
!
! Revision 2.95  2013/05/31 00:27:44  vsnyder
! Add cautionary comment about HDFVersions
!
! Revision 2.94  2012/08/27 23:01:29  pwagner
! Consistent with new api for SortArray
!
! Revision 2.93  2012/08/14 00:20:13  pwagner
! Removed unused stuff
!
! Revision 2.92  2012/05/24 20:32:11  vsnyder
! Simplify mls_exists
!
! Revision 2.91  2012/03/14 16:55:11  pwagner
! Fixed most recent goldbrick-busting bug
!
! Revision 2.90  2012/01/05 01:14:54  pwagner
! Capitalized USEd stuff
!
! Revision 2.89  2011/07/12 22:35:44  honghanh
! Change l_grid to l_hdfeos
!
! Revision 2.88  2009/09/29 23:32:40  pwagner
! Changes needed by 64-bit build
!
! Revision 2.87  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.86  2008/12/02 23:10:51  pwagner
! mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
!
! Revision 2.85  2008/05/24 00:54:46  vsnyder
! Remove unused declarations
!
! Revision 2.84  2008/05/02 00:41:09  vsnyder
! Delete unused symbol
!
! Revision 2.83  2008/05/02 00:03:33  pwagner
! Removed redundant procedures
!
! Revision 2.82  2008/04/18 16:32:30  pwagner
! read_textFile can return value array; optional arg maxLineLen added
!
! Revision 2.81  2008/03/11 00:09:54  pwagner
! Uses read_textFile from io_stuff
!
! Revision 2.80  2008/02/22 21:27:15  pwagner
! Added textFile_to_Chars
!
! Revision 2.79  2008/01/14 23:47:16  pwagner
! GetMLSFileByName sometimes failed to match; fixed
!
! Revision 2.78  2007/06/21 00:49:51  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.77  2007/04/06 16:23:17  pwagner
! Added 1st 1-parameter function, readnchars
!
! Revision 2.76  2007/02/06 17:55:14  pwagner
! Added transfer_MLSFile to change path of an MLSFile
!
! Revision 2.75  2007/01/11 20:41:20  vsnyder
! Remove get_free_lun, use Get_Lun, handle record length for sequential files
!
! Revision 2.74  2006/09/21 18:45:52  pwagner
! Fix bug causing PCFid-equipped inquiries to complain about missing filenames
!
! Revision 2.73  2006/04/11 23:15:34  pwagner
! Disclose whether MLSFile still open as part of default dump
!
! Revision 2.72  2006/02/21 19:07:58  pwagner
! Removed references to unused stuff
!
! Revision 2.71  2005/12/21 18:44:08  pwagner
! Added AreTheSameFile; not clever yet, should consider paths, etc
!
! Revision 2.70  2005/10/18 23:03:32  pwagner
! Interface to GetMLSFileByName allows ignoring path
!
! Revision 2.69  2005/08/09 00:00:10  pwagner
! Mistake to call sortarray from GetPCFFromRef with same nameArray in both positions--fixed
!
! Revision 2.68  2005/06/29 17:56:24  pwagner
! FILESTRINGTABLE utilized to prevent tools from segment faulting
!
! Revision 2.67  2005/06/22 17:25:49  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.66  2005/06/16 18:41:41  pwagner
! Stopped some unnecessary printing
!
! Revision 2.65  2005/06/14 20:32:09  pwagner
! Many changes to accommodate the new fields in MLSFile_T
!
! Revision 2.64  2005/06/03 23:58:04  pwagner
! Extra check on indx in GetMLSFileByType; added AddInitializeMLSFile
!
! Revision 2.63  2005/05/31 17:50:20  pwagner
! Began switch from passing file handles to passing MLSFiles
!
! Revision 2.62  2005/01/07 00:36:51  vsnyder
! Remove unused declarations
!
! Revision 2.61  2004/10/13 00:50:32  vsnyder
! Remove USE for Reverse, which isn't used
!
! Revision 2.60  2004/10/09 02:46:09  vsnyder
! Simplify split_file_name.  It doesn't work anyway if len(full_file_name) >
! MAXFILENAMELENGTH.
!
! Revision 2.59  2004/08/04 23:19:01  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.58  2004/02/05 23:29:16  pwagner
! Extra debugging when appropriate
!
! Revision 2.57  2004/01/27 21:34:57  pwagner
! Fixed bugs in unSplitName
!
! Revision 2.56  2004/01/23 01:13:11  pwagner
! Added unSplitName
!
! Revision 2.55  2004/01/22 00:44:02  pwagner
! Added (un)maskName
!
! Revision 2.54  2004/01/21 18:54:54  livesey
! Typo!
!
! Revision 2.53  2004/01/21 18:48:59  livesey
! Bug fix in mls_inqswath
!
! Revision 2.52  2003/06/23 21:06:55  pwagner
! Moved use HDF5 down among module procedures to speed up Lahey compilation
!
! Revision 2.51  2003/06/20 19:32:32  pwagner
! mls_exists now public
!
! Revision 2.50  2003/04/02 23:53:18  pwagner
! Added mls_exists; Checks for FILENOTFOUND
!
! Revision 2.49  2003/02/28 00:46:32  pwagner
! Improved apis for mls_open(close)file to exploit WILDCARDHDFVERSION
!
! Revision 2.48  2003/02/26 17:34:39  pwagner
! mls_inqswath, mls_sfstart, and mls_sfend act sensibly when passed WILDCARDHDFVERSION
!
! Revision 2.47  2002/12/10 00:43:44  pwagner
! At last can h5fcreate an extant file with H5F_ACC_TRUNC_F
!
! Revision 2.46  2002/12/09 17:55:03  pwagner
! Reuses mls_sfstart in mls_io_gen_openf and open_mls routines
!
! Revision 2.45  2002/12/06 23:38:57  pwagner
! mls_sfstart improved with addingMetaData optional arg
!
! Revision 2.44  2002/12/05 19:44:24  pwagner
! Moved MLSFile_T from MLSFiles to MLSCommon
!
! Revision 2.43  2002/12/04 01:16:25  pwagner
! Open_ Close_ Dump_ Deallocate_ on new MLSFile_T added
!
! Revision 2.42  2002/12/02 23:37:27  pwagner
! First halting steps toward reorg of how mls treats files--will be done via MLSFile_T
!
! Revision 2.41  2002/11/07 21:22:40  jdone
! HDF4/HDF5 capabilities integrated
!
! Revision 2.40  2002/10/29 01:02:26  pwagner
! Reverted DEFAULT_HDFVERSION to 4; added api
!
! Revision 2.39  2002/10/08 23:46:03  pwagner
! Separate he2he5_fileaccess and hdf2hdf5_fileaccess functions
!
! Revision 2.38  2002/10/08 00:09:11  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.37  2002/09/27 23:38:38  pwagner
! Added hg type to mls_gen_close
!
! Revision 2.36  2002/09/26 23:59:39  pwagner
! added 'hg' toolbox_mode to mls_io_gen_openF
!
! Revision 2.35  2002/08/08 22:40:42  jdone
! New routines to Open/Close HDF5 Files
!
! Revision 2.34  2002/07/23 00:06:55  pwagner
! debug set to false in sfstart and sfend
!
! Revision 2.33  2002/07/11 22:21:01  pwagner
! These hdf5-savvy versions transferred from he5lib
!
! Revision 1.13  2002/06/12 17:59:37  livesey
! Brought get_free_lun in from lib version
!
! Revision 1.12  2002/05/28 23:11:23  pwagner
! Changed to comply with hdf5.1.4.3/hdfeos5.1.2
!
! Revision 1.11  2002/03/14 23:31:57  pwagner
! HDFVERSION_4 and 5 now public
!
! Revision 1.10  2002/03/13 18:32:05  pwagner
! No longer dumps core after writing metadata to hdf5 files
!
! Revision 1.9  2002/02/19 23:39:29  pwagner
! Eliminated unwanted match between o3 and hno3
!
! Revision 1.8  2002/01/31 00:36:41  pwagner
! Repaired comment statements
!
! Revision 1.7  2002/01/29 23:46:30  pwagner
! Added WILDCARDHDFVERSION as public param
!
! Revision 1.6  2002/01/29 00:48:43  pwagner
! Now should handle both hdfVersions; not tested yet
!
! Revision 1.5  2002/01/26 00:14:47  pwagner
! Accepts hdfVersion optional arg; restored hdf5 module use
!
! Revision 1.4  2002/01/23 22:41:21  pwagner
! Handles optional hdfVersion parameter
!
! Revision 1.3  2002/01/23 00:54:10  pwagner
! Added mls_hdf_version function
!
! Revision 1.2  2002/01/18 23:55:49  pwagner
! Various strategems to try writing metadata; all fail
!
! Revision 1.1  2002/01/18 00:51:22  pwagner
! First commit
!
@


2.113
log
@Corrected various comments
@
text
@d545 1
a545 1
    options="-sr"
d2299 1
a2299 1
       "$Id: MLSFiles.f90,v 2.112 2018/04/19 02:09:49 vsnyder Exp $"
d2311 3
@


2.112
log
@Remove USE statements for unused names
@
text
@d81 1
a81 1
! WILDCARDHDFVERSION integer corresponding to autorecognize hdf4/hdf5
d109 10
a118 10
! maskname           Add stuff to file_name so parser can't recognize it
! mls_exists         Returns 0 if the filename exists
! mls_closeFile      Closes a file opened by mls_openFile
! mls_hdf_version    Returns one of 'hdf4', 'hdf5', or '????'
! mls_inqswath       A wrapper for doing swinqswath for versions 4 and 5
! mls_openFile       Opens an MLSFile_T file
! mls_sfend          Closes a file opened by mls_sfstart
! mls_sfstart        Opens an hdf file for writing metadata
! release_MLSFile    undoes what reserve_MLSFile does
! reserve_MLSFile    initializes an mls file 
d121 4
a124 4
! split_path_name    splits the input path/name into path and name
! transfer_MLSFile   Changes the path of an mlsFile
! unmaskname         Recover file name from masked form
! unsplitname        Split File name -> catenated: '..DGG13..' -> 'DGG'
d159 2
a160 2
!    mls_closeFile
!    mls_openFile
d185 1
a185 1
   ! Assume hdf files w/o explicit hdfVersion field are this
d187 2
a188 1
   ! MAKE SURE that HDFVersions are consecutive, as they're used for subscripts!
d191 2
d195 1
a195 1
  ! Given this hdfVersion, try to autorecognize hdfversion
d197 1
a197 2
  ! (must *not* be 4 or 5)
  integer, parameter, public :: WILDCARDHDFVERSION=HDFVERSION_4+HDFVERSION_5
d252 1
a252 1
  ! (Parser might change its case if it thinks it has seen the name before)
d255 1
a255 1
  interface DUMP
d272 4
d291 1
a291 1
  ! This routine adds a vector to a database of such vectors, 
d433 3
d442 9
a450 9
    character (LEN=*), intent(IN)            :: FileName
    integer,  intent(IN)                 :: PCBottom, PCTop
    integer                              :: thePC, notThePC
    integer,  intent(OUT)                :: ErrType
    logical,  intent(IN)                     :: caseSensitive
    integer,  optional                   :: versionNum
    logical,  optional, intent(IN)           :: debugOption
    character (LEN=*),  optional, intent(IN) :: path
    character (LEN=*), optional, intent(out) :: ExactName
d462 1
a462 1
    character (LEN=*), parameter      :: UNASSIGNEDFILENAME = '*'
d828 2
a829 2
    ! Our success orr failure determines the resulting status
    ! We don't actually care what the chars are
d856 1
a856 1
    integer, intent(IN)       :: FileAccesshdf4
d890 1
a890 1
    integer, intent(IN)       :: FileAccesshdf4
d911 2
a912 1
  ! This function acts as a wrapper to allow hdf5 or hdf4 routines to be called
d918 5
a922 5
    character (len=*), intent(in) :: FILENAME
    character (len=*), intent(out) :: SWATHLIST
    integer, intent(out):: STRBUFSIZE
    integer :: mls_inqswath
    integer, optional, intent(in) :: hdfVersion
d988 2
a989 2
    character (len=*), intent(in) :: FILENAME
    integer, intent(IN)       :: FileAccess ! (one of the hdf4 types)
d1101 4
a1104 4
    integer, intent(IN)       :: sdid  
    integer :: mls_sfend            
    integer, optional, intent(in) :: hdfVersion
    logical, optional, intent(in) :: addingmetadata
d1106 2
a1107 2
    logical                       :: myaddingmetadata
    integer                       :: myhdfVersion
a1363 1
        ! MLSFile%FileId%f_id = Mls_io_gen_openF ( 'pg', CASESENSITIVE, &
a1382 1
      ! MLSFile%FileId%f_id = mls_io_gen_openF(toolbox_mode, CASESENSITIVE, &
a1483 1
      ! ioerror = mls_io_gen_closeF(toolbox_mode, MLSFile%FileID%f_id)
a1488 1
      ! ioerror = mls_io_gen_closeF(toolbox_mode, MLSFile%FileID%f_id, &
d1513 4
a1516 1
  ! This routine transforms an MLSFile, e.g. relocating its path
a1661 1
  ! function mls_io_gen_closeF( toolbox_mode, theFileHandle, &
d1668 6
a1673 8
    integer  :: ErrType
    integer, intent(IN)  :: theFileHandle
    ! character (LEN=*), intent(IN)   :: toolbox_mode
    integer, intent(IN)   :: mode
    character (LEN=*), optional, intent(IN)   :: FileName

    integer, optional, intent(in) :: hdfVersion
    logical, optional, intent(in) :: debugOption
a1845 1
  !  function mls_io_gen_openF(toolbox_mode, caseSensitive, ErrType, &
d1855 14
a1868 16
    integer,  intent(OUT)  :: ErrType
    integer,  intent(IN)  :: record_length
    logical,  intent(IN)       :: caseSensitive
    ! character (LEN=*), intent(IN) :: toolbox_mode
    integer, intent(IN) :: mode
    integer, intent(IN)       :: FileAccessType ! One of hdf4 dfacc*
    integer  :: theFileHandle
    character (LEN=*), optional, intent(IN)   :: FileName
    integer,  optional, intent(IN)   :: PCBottom, PCTop
    integer, optional, intent(IN)                :: thePC
    integer,  optional     :: versionNum
    logical, optional, intent(in) :: unknown
    logical, optional, intent(in) :: debugOption

    integer, optional, intent(in) :: hdfVersion
    integer, optional, intent(in) :: inp_rec_length
d2299 1
a2299 1
       "$Id: MLSFiles.f90,v 2.111 2018/04/16 18:25:18 pwagner Exp $"
d2311 3
@


2.111
log
@Actually obey NEVERFAIL in ReadL1BData_MLSFile
@
text
@d28 1
a28 1
    & AccessType, FileStringTable, InRange, Split_Path_Name
a288 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a687 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d2296 1
a2296 1
       "$Id: MLSFiles.f90,v 2.110 2018/02/08 23:16:41 pwagner Exp $"
d2308 3
@


2.110
log
@Moved Dump, accessType, and Split_path_name to other modules
@
text
@d113 1
a113 1
! mls_inqswath       A wrapper for doing swingswath for versions 4 and 5
d2298 1
a2298 1
       "$Id: MLSFiles.f90,v 2.109 2017/12/12 21:25:32 pwagner Exp $"
d2310 3
@


2.109
log
@Raise char length limit of nameArray in GetPCFromRef
@
text
@d22 1
a22 2
  use HighOutput, only: AddRow, AddRow_Divider, AddRow_Header, &
    & OutputNamedValue, OutputTable, StartTable
d28 1
a28 1
    & InRange
d30 1
a30 1
    & MLSMSG_Warning
a51 1

d56 11
a66 11
  public :: accesstype, addFiletodatabase, &
  & addinitializeMLSFile, arethesameFile, &
  & deallocate_Filedatabase, dump, &
  & getMLSFilebyname, getMLSFilebytype, getpcfromref, &
  & initializeMLSFile, &
  & maskname, &
  & MLS_closeFile, MLS_exists, MLS_hdf_version, MLS_inqswath, &
  & MLS_openFile, MLS_sfstart, MLS_sfend, &
  & readnchars, release_MLSFile, reserve_MLSFile, &
  & rmFilefromdatabase, split_path_name, &
  & transfer_MLSFile, unmaskname, unsplitname
a98 1
! accessType         Converts DFACC_* <-> {l_create, l_rdwr, l_rdonly}
a196 5
  ! Unless you fill the string table with l_ quantities from intrinsic
  ! make sure the next entry is .false. 
  ! (or else it will segment fault in get_string)
  ! MLSL2 does fill the string table, but many tools do not
  logical, save, public :: FILESTRINGTABLE = .FALSE.
a252 5
  interface accessType
    module procedure accessDFACCToStr
    module procedure accessStrToDFACC
  end interface

a281 44
  !--------------------------------------------  accessDFACCToStr  -----
  function accessDFACCToStr ( dfacc ) result(str)

  ! This routine converts an hdf access type
  ! like DFACC_RDONLY into a string like 'rdonly'
  ! If access type is unrecognized, returns 'unknown'
  ! Args
  integer, intent(in)           :: dfacc
  character(len=8)              :: str
  ! Executable
  select case (dfacc)
  case (DFACC_CREATE)
    str = 'create'
  case (DFACC_RDONLY)
    str = 'rdonly'
  case (DFACC_RDWR)
    str = 'rdwrite'
  case default
    str = 'unknown' ! Why not ' '? Or '?'
  end select
  end function accessDFACCToStr

  !--------------------------------------------  accessStrToDFACC  -----
  function accessStrToDFACC ( str ) result(dfacc)

  ! This routine converts a string like 'rdonly' into an hdf access type
  ! like DFACC_RDONLY
  ! If string is unrecognized, returns -999
  ! Args
  character(len=*), intent(in) :: str
  integer                      :: dfacc
  ! Executable
  select case (lowercase(str(1:4)))
  case ('crea')
    dfacc = DFACC_CREATE
  case ('rdon')
    dfacc = DFACC_RDONLY
  case ('rdwr')
    dfacc = DFACC_RDWR
  case default
    dfacc = -999 ! why not DFACC_RDWR?
  end select
  end function accessStrToDFACC

a779 120
  ! ------------------------------------------ Dump_MLSFile ------------

  subroutine Dump_MLSFile ( MLSFile, details )

    ! Dummy arguments
    type (MLSFile_T), intent(in) ::          MLSFile
    integer, intent(in), optional          :: details
    ! Local variables
    integer                          ::      myDetails
    character(len=MAXFILENAMELENGTH) ::      name
    character(len=MAXFILENAMELENGTH) ::      path
    character(len=MAXFILENAMELENGTH) ::      str

    ! Executable code
    myDetails = 0
    if ( present(details) ) myDetails = details
    call split_path_name(MLSFile%Name, Path, Name)
    call startTable
    call addRow_header ( 'File Info', 'c' )
    call addRow_divider ( '-' )
    if ( len_trim(path) > 0 ) call addRow ( 'path', trim(path) )
    call addRow ( 'name', trim(name) )
    ! If details < 0, show only this name
    if ( myDetails > -1 ) then
      if ( UseSDPToolkit .and. MLSFile%shortName /= ' ' ) &
        & call addRow ( 'short name', trim(MLSFile%shortName) )
      call addRow ( 'Type', MLSFile%TypeStr )
      if ( FILESTRINGTABLE ) then
        call get_string ( lit_indices(MLSFile%Type), str, strip=.true. )
        call addRow ( 'Type(int)', trim(str) )
      endif
      call addRow ( 'Access', trim(accessType(MLSFile%access)) )
      call addRow ( 'Access (int)', MLSFile%access )
      call addRow ( 'content', trim(MLSFile%content) )
      call addRow ( 'last Operation', trim(MLSFile%lastOperation) )
      call addRow ( 'still open?', MLSFile%stillOpen )
      ! If details < 1, don't show any FileID info
      if ( myDetails > 0 ) then
        call addRow_divider ( '-' )
        call addRow ( 'File ID', MLSFile%FileId%f_id )
        if ( MLSFile%FileId%grp_id > 0 ) &
          & call addRow ( 'Group ID', MLSFile%FileId%grp_id )
        if ( MLSFile%FileId%sd_id > 0 ) &
          & call addRow ( 'Dataset ID', MLSFile%FileId%sd_id )
        if ( UseSDPToolkit )  then
          call addRow ( 'PCF ID', MLSFile%PCFId )
          call addRow ( 'PCF Range', (/MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%Top /) )
        endif
        if ( any(MLSFile%type == (/l_hdf, l_swath, l_hdfeos, l_zonalavg /) ) ) &
          & call addRow ( 'hdf version', MLSFile%HDFVersion )
        if ( MLSFile%recordLength > 0 ) &
          & call addRow ( 'record length', MLSFile%recordLength )
        call addRow ( 'error code', MLSFile%errorCode )
      endif
    endif
    call outputTable ( sep='|', border='-' )
  end subroutine Dump_MLSFile

  ! --------------------------------------------  split_path_name  -----

  ! This routine splits the input full_file_name
  ! into its components path and name
  ! where path may include one or more "/" or slash elements
  ! (but one must be the terminating one; e.g., 'System/')
  ! while name must have none (actually "/" comes from Machine%filsep).
  ! special cases by example: full_file_name -> (path, name)
  ! look.ma.no.slash -> (' ', 'look.ma.no.slash')
  ! Luke/I/am/your/father/ -> ('Luke/I/am/your/father/', ' ')

  ! optionally you may supply the slash divider
  ! which must be a single character

  elemental subroutine split_path_name ( full_file_name, path, name, slash )

    ! Arguments

    use Machine, only: Filsep ! / or :\

    character (len=*), intent(in) :: full_file_name
    character (len=*), intent(out) :: path
    character (len=*), intent(out) :: name
    character (len=1), optional, intent(in) :: slash

    ! Local

    character (len=1) :: mySlash
    integer :: loc, n
!   logical, parameter :: DEBUG = .false.

    ! Begin

    n = len_trim(full_file_name)

    if ( n <= 0 ) then
      path = ' '
      name = ' '
      return
    end if

    if ( present(slash) ) then
      mySlash = slash
    else
      mySlash = filsep
    end if

    loc = scan(full_file_name(:n), mySlash, back=.true.)

    if ( loc <= 0 ) then
      path = ' '
      name = adjustl(full_file_name)
    else if ( loc == n ) then
      path = adjustl(full_file_name)
      name = ' '
    else
      path = adjustl(full_file_name(:loc))
      name = adjustl(full_file_name(loc+1:))
    end if

  end subroutine split_path_name

d1090 1
a1090 1
    use HDF5, only: H5FCLOSE_F
d1308 1
d1319 2
a1320 2
    ! print *, 'Opening ' // trim(MLSFile%name)
    ! print *, 'type ', MLSFile%type
d1340 2
a1341 2
     ! print *, 'MLSFile%type ' , MLSFile%type
     ! print *, 'WILDCARDHDFVERSION ' , WILDCARDHDFVERSION
d1343 1
a1343 1
     ! print *, 'MLSFile%HDFVersion ' , MLSFile%HDFVersion
d1355 1
a1355 1
        ! print *, '1'
d1363 1
a1363 1
        ! print *, '2'
d1372 1
a1372 1
        ! print *, "After iogenopen, ioerror: ", ioerror
d1375 1
a1375 1
      ! print *, '3'
d1382 1
a1382 1
      ! print *, '4'
d1388 2
a1389 2
      ! print *, '5'
      ! print *, 'Trying to open ', trim(MLSFile%Name)
d1391 1
a1391 1
      ! print *, 'hdf version ', MLSFile%hdfVersion
d1397 1
d1399 1
a1399 1
      ! print *, '6'
d1406 1
a1406 1
      ! print *, '7'
d1412 1
a1412 1
      ! print *, 'ioerror: ', ioerror
d1416 1
d1418 1
d1617 2
d1627 1
d1660 1
a1660 1
    use HDF5, only: H5FCLOSE_F
d2298 1
a2298 1
       "$Id: MLSFiles.f90,v 2.108 2017/11/15 00:09:31 pwagner Exp $"
d2310 3
@


2.108
log
@Improve appearance Dumping each MLSFile
@
text
@d15 1
d506 1
a506 1
    character (LEN=BareFNLen), dimension(:), allocatable &
d508 1
a508 1
    integer                       ::     numberPCs
d599 5
d2468 1
a2468 1
       "$Id: MLSFiles.f90,v 2.107 2017/01/19 23:35:01 pwagner Exp $"
d2480 3
@


2.107
log
@Improve appeearance when dumping an MLSFile
@
text
@d15 7
a21 7
  use HDF, only: dfacc_create, dfacc_rdonly, dfacc_read, dfacc_rdwr, &
    & Sfstart, sfend
  use HDFeos, only: gdclose, gdopen, swclose, swopen, swinqswath
  use HDFeos5, only: HE5_swclose, HE5_swopen, HE5_swinqswath, &
    & HE5_gdopen, HE5_gdclose, &
    & HE5f_acc_trunc, HE5f_acc_rdonly, HE5f_acc_rdwr
  use HighOutput, only: AddRow, AddRow_divider, AddRow_header, &
d23 5
a27 5
  use Intrinsic, only: l_ascii, l_hdfeos, l_hdf, l_open, &
    & L_swath, l_tkgen, l_zonalavg, lit_indices
  use Io_stuff, only: get_lun
  use Machine, only: io_error
  use MLSCommon, only: bareFNLen, fileNameLen, FileIds_T, MLSFile_t, Range_t, &
d31 3
a33 3
  use MLSFinds, only: findfirst
  use MLSStrings, only: capitalize, lowercase
  use MLSStringLists, only: extractSubstring, &
d35 1
a35 1
  use Output_m, only: Blanks, Output
d37 9
a45 9
    & PGS_pc_getreference, PGS_s_success, &
    & PGSd_io_gen_rseqfrm, PGSd_io_gen_rsequnf, & 
    & PGSd_io_gen_rdirfrm, PGSd_io_gen_rdirunf, & 
    & PGSd_io_gen_wseqfrm, PGSd_io_gen_wsequnf, & 
    & PGSd_io_gen_wdirfrm, PGSd_io_gen_wdirunf, & 
    & PGSd_io_gen_useqfrm, PGSd_io_gen_usequnf, & 
    & PGSd_io_gen_udirfrm, PGSd_io_gen_udirunf, & 
    & PGSd_io_gen_aseqfrm, PGSd_io_gen_asequnf, &
    & PGS_io_gen_closef, PGS_io_gen_openf, PGSd_pc_file_path_max, &
d47 5
a51 5
!   In the long run, we'll try putting interfaces to these in SDPToolkit.f90
!   Until then, just declare them as external
!    & PGS_MET_SFstart, PGS_MET_SFend, &
  use String_table, only: display_string, get_string
  use HDF5, only: size_t
a783 1

a801 1
    
a802 1
    call output ( ' ', advance='yes' )
d851 2
a852 1
    call addRow ( 'full name', trim(MLSFile%Name) )
a854 2
      call addRow ( 'path', trim(path) )
      call addRow ( 'name', trim(name) )
d907 1
a907 1
    use Machine, only: FILSEP ! / or :\
d1051 1
a1051 1
     & H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, H5F_ACC_EXCL_F
d1146 1
a1146 1
    use HDF5, only: H5FOPEN_F, H5FCREATE_F
d1148 1
a1148 1
     & H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, H5F_ACC_TRUNC_F
d1328 1
a1328 1
   use HDF5, only: H5FIS_HDF5_F
d1407 3
a1409 3
   use HDF5, only: H5FOPEN_F, H5FCREATE_F, H5FIS_HDF5_F
   use HDF5, only: &
     & H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, H5F_ACC_EXCL_F
d1598 1
a1598 1
    use HDF5, only: H5FCLOSE_F
d2013 1
a2013 1
    use IO_Stuff, only: GET_LUN
d2462 1
a2462 1
       "$Id: MLSFiles.f90,v 2.106 2017/01/13 01:27:27 pwagner Exp $"
d2474 3
@


2.106
log
@Dump_MLSFile now uses OutputTable
@
text
@d21 2
a22 1
  use HighOutput, only: AddRow, OutputNamedValue, OutputTable, StartTable
d852 2
a853 1
    call addRow ( 'File Info', ' ' )
a868 1
      call addRow ( 'content', trim(MLSFile%content) )
d870 1
a870 1
      call addRow ( 'still open?', MLSFile%FileId%f_id )
d873 2
a874 1
        call addRow ( 'File ID', MLSFile%stillOpen )
d2466 1
a2466 1
       "$Id: MLSFiles.f90,v 2.105 2016/09/21 00:38:41 pwagner Exp $"
d2478 3
@


2.105
log
@May Dump filedatabase as a table
@
text
@d21 1
a21 1
  use HighOutput, only: OutputNamedValue, OutputTable
d844 1
d850 37
a886 57
    if ( myDetails >  -1 ) &
      & call output ( 'MLS File Info (full name): ', advance='yes')                                  
    ! call output ( '(name) ')                                  
    call output ( trim(MLSFile%Name), advance='yes')                                  
    if ( myDetails < 0 ) return
    call output ( '    path         : ')                                
    call output ( trim(path), advance='yes')                                  
    call output ( '    name         : ')
    call output ( trim(name), advance='yes')                                  
    if ( UseSDPToolkit .and. MLSFile%shortName /= ' ' )  then
      call output ( '    short name   : ')                                
      call output ( trim(MLSFile%shortName), advance='yes')                                  
    endif
    call output ( '    Type         : ')                                
    call output ( trim(MLSFile%TypeStr), advance='yes')                                  
    if ( FILESTRINGTABLE ) then
    call output ( '    Type(int)    : ')                                
    call display_string ( lit_indices(MLSFile%Type), strip=.true.)                                  
    call output(' ', advance='yes')
    endif
    call output ( '    Access       : ')                                
    ! call output ( trim(MLSFile%accessStr), advance='yes')                                  
    call output ( trim(accessType(MLSFile%access)), advance='yes')                                  
    call output ( '    Access (int) : ')                                
    call output ( MLSFile%access, advance='yes')                                  
    call output ( '    content      : ')                                
    call output ( trim(MLSFile%content), advance='yes')                                  
    call output ( '    last Operatn : ')                                
    call output ( trim(MLSFile%lastOperation), advance='yes')                                  
    call output ( '    still open? : ')                                
    call output ( MLSFile%stillOpen, advance='yes')                                  
    if ( myDetails < 1 ) return
    call output ( '    File ID      : ')                                
    call output ( MLSFile%FileId%f_id, advance='yes')
    if ( MLSFile%FileId%grp_id > 0 ) then
      call output ( '    Group ID     : ')                              
      call output ( MLSFile%FileId%grp_id, advance='yes')                                
    endif
    if ( MLSFile%FileId%sd_id > 0 ) then
      call output ( '    DataSet ID   : ')                              
      call output ( MLSFile%FileId%sd_id, advance='yes')
    endif
    if ( UseSDPToolkit )  then
      call output ( '    PCF ID       : ')                                
      call output ( MLSFile%PCFId, advance='yes')                                
      call output ( '    PCF Range    : ')                                
      call output ( (/MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%Top /), &
        & advance='yes')                                  
    endif
    ! if ( any(MLSFile%type == (/'hdf  ', 'swath' /) ) ) then
    if ( any(MLSFile%type == (/l_hdf, l_swath, l_hdfeos, l_zonalavg /) ) ) then
      call output ( '    hdf version  : ')                              
      call output ( MLSFile%HDFVersion, advance='yes')
    endif
    if ( MLSFile%recordLength > 0 )  then
      call output ( '    record length: ')                              
      call output ( MLSFile%recordLength, advance='yes')                                
d888 1
a888 2
    call output ( '    error code   : ')                                
    call output ( MLSFile%errorCode, advance='yes')                                  
d2464 1
a2464 1
       "$Id: MLSFiles.f90,v 2.104 2016/08/09 18:13:34 pwagner Exp $"
d2476 3
@


2.104
log
@MLS_CloseFile now sets FileIDs to 0
@
text
@d16 1
a16 1
    & sfstart, sfend
d21 7
a27 7
  use highoutput, only: outputnamedvalue
  use intrinsic, only: l_ascii, l_hdfeos, l_hdf, l_open, &
    & l_swath, l_tkgen, l_zonalavg, lit_indices
  use io_stuff, only: get_lun
  use machine, only: io_error
  use MLSCommon, only: bareFNLen, fileNameLen, FileIds_T, MLSFile_t, range_t, &
    & inRange
d32 3
a34 3
  use MLSStringLists, only: extractsubstring, &
    & replacesubstring, sortarray
  use output_m, only: blanks, output
d45 1
a45 1
    & useSDPtoolkit
d49 1
a49 1
  use string_table, only: display_string, get_string
d170 1
a170 1
! Dump ( MLSFile *dataBase(:), [char* Name], [int details] )
d782 1
a782 1
  subroutine Dump_FileDataBase ( database, Name, details )
d787 2
a788 1
    integer, intent(in), optional          :: details
d791 1
d794 2
d799 3
d809 1
a809 1
    if ( size(database) < 1 ) then
d812 10
d826 1
a826 1
    if ( myDetails < -1 ) return
d2484 1
a2484 1
       "$Id: MLSFiles.f90,v 2.103 2015/03/28 01:13:24 vsnyder Exp $"
d2496 3
@


2.103
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d26 7
a32 7
  use MLScommon, only: barefnlen, filenamelen,  MLSfile_t, range_t, &
    & inrange
  use MLSmessagemodule, only: MLSmessage, MLSmsg_crash, MLSmsg_error, &
    & MLSmsg_warning
  use MLSfinds, only: findfirst
  use MLSstrings, only: capitalize, lowercase
  use MLSstringlists, only: extractsubstring, &
d235 1
a235 1
  logical, parameter :: PGS_MET4MLS_SF = .true.
d279 8
a286 6
  character (len=*), parameter :: accesses = 'rdonly,write,rdwrite,create,nonhdf'
  integer, dimension(5), parameter :: accessTypes = &
    & (/ DFACC_RDONLY, DFACC_RDWR, DFACC_RDWR, DFACC_CREATE, PGSd_IO_Gen_RSeqFrm/)
  character (len=*), parameter :: hdfmodes = 'hg,sw,gd,za'
  character (len=*), parameter :: modes = 'op,hg,sw,gd,za,bin,pg'
  character (len=*), parameter :: types = 'ascii,hdf,swath,grid,zonalavg,binary,tkgen'
d997 2
a1161 2
    integer                       :: returnStatus
    integer                       :: access_prp_default
d1165 4
a1168 2
    
    integer, parameter :: h5p_default_f = 0
a1169 1
    logical, parameter :: DEBUG = .false.
a1220 1
     access_prp_default = h5p_default_f    ! Can't figure out what this means
a1490 1
    integer :: version
a1495 1
    version = 1
d1642 1
a1642 1
  subroutine mls_CloseFileType(MLSFile, error)
a1646 1
    logical, parameter :: CASESENSITIVE = .true.
a1647 3
    integer :: PCBottom
    integer :: PCTop
    integer :: version
a1648 3
    version = 1
    PCBottom = MLSFile%PCFidRange%Bottom
    PCTop = MLSFile%PCFidRange%Top
d1663 1
a2042 1
    integer, parameter :: DEFAULTRECLEN=0
a2066 1
    ! record_length = DEFAULTRECLEN
d2467 1
a2467 1
       "$Id: MLSFiles.f90,v 2.102 2014/09/05 00:01:11 vsnyder Exp $"
d2479 3
@


2.102
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d342 1
d737 1
d760 1
d764 1
d772 1
d774 1
a774 1
    call test_deallocate ( error, ModuleName, 'database', s )
d2475 1
a2475 1
       "$Id: MLSFiles.f90,v 2.100 2014/04/02 23:02:10 pwagner Exp $"
d2487 3
@


2.101
log
@Added mls_exists to toc and api
@
text
@d22 1
a22 1
  use intrinsic, only: l_ascii, l_binary, l_HDFeos, l_HDF, l_open, &
d28 2
a29 2
  use MLSmessagemodule, only: MLSmessage, MLSmsg_allocate, &
    & MLSmsg_deallocate, MLSmsg_crash, MLSmsg_error, MLSmsg_warning
d46 3
a48 3
!   in the long run, we'll try putting interfaces to these in SDPtoolkit.f90
!   until then, just declare them as external
!    & PGS_met_sfstart, PGS_met_sfend, &
d51 1
d138 1
a138 1
! split_path_name ( char* full_file_name, char* path, char* name, [char slash] )
d253 1
a253 1
  
d341 2
d735 1
d742 1
a742 1
    logical, parameter                     :: okToDeallocEmptyDB = .FALSE.
d757 1
d761 1
a761 1
    integer :: i, error
d766 2
a767 1
    enddo
d769 2
a770 3
    if ( error /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot deallocate file database" )
@


2.100
log
@Removed redundant open_ and close_MLSFile
@
text
@d15 36
a50 36
  use HDF, only: DFACC_CREATE, DFACC_RDONLY, DFACC_READ, DFACC_RDWR, &
    & SFSTART, SFEND
  use HDFEOS, only: GDCLOSE, GDOPEN, SWCLOSE, SWOPEN, SWINQSWATH
  use HDFEOS5, only: HE5_SWCLOSE, HE5_SWOPEN, HE5_SWINQSWATH, &
    & HE5_GDOPEN, HE5_GDCLOSE, &
    & HE5F_ACC_TRUNC, HE5F_ACC_RDonly, HE5F_ACC_RDWR
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use INTRINSIC, only: L_ASCII, L_BINARY, L_HDFEOS, L_HDF, L_OPEN, &
    & L_SWATH, L_TKGEN, L_ZONALAVG, LIT_INDICES
  use IO_STUFF, only: GET_LUN
  use MACHINE, only: IO_ERROR
  use MLSCOMMON, only: BAREFNLEN, FILENAMELEN,  MLSFILE_T, RANGE_T, &
    & INRANGE
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ALLOCATE, &
    & MLSMSG_DEALLOCATE, MLSMSG_CRASH, MLSMSG_ERROR, MLSMSG_WARNING
  use MLSFINDS, only: FINDFIRST
  use MLSSTRINGS, only: CAPITALIZE, LOWERCASE
  use MLSSTRINGLISTS, only: EXTRACTSUBSTRING, &
    & REPLACESUBSTRING, SORTARRAY
  use OUTPUT_M, only: BLANKS, OUTPUT
  use SDPTOOLKIT, only: &
    & PGS_PC_GETREFERENCE, PGS_S_SUCCESS, &
    & PGSD_IO_GEN_RSEQFRM, PGSD_IO_GEN_RSEQUNF, & 
    & PGSD_IO_GEN_RDIRFRM, PGSD_IO_GEN_RDIRUNF, & 
    & PGSD_IO_GEN_WSEQFRM, PGSD_IO_GEN_WSEQUNF, & 
    & PGSD_IO_GEN_WDIRFRM, PGSD_IO_GEN_WDIRUNF, & 
    & PGSD_IO_GEN_USEQFRM, PGSD_IO_GEN_USEQUNF, & 
    & PGSD_IO_GEN_UDIRFRM, PGSD_IO_GEN_UDIRUNF, & 
    & PGSD_IO_GEN_ASEQFRM, PGSD_IO_GEN_ASEQUNF, &
    & PGS_IO_GEN_CLOSEF, PGS_IO_GEN_OPENF, PGSD_PC_FILE_PATH_MAX, &
    & USESDPTOOLKIT
!   In the long run, we'll try putting interfaces to these in SDPToolkit.f90
!   Until then, just declare them as external
!    & PGS_MET_SFstart, PGS_MET_SFend, &
  use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
  use HDF5, only: SIZE_T
d55 11
a65 11
  public :: ACCESSTYPE, ADDFILETODATABASE, &
  & ADDINITIALIZEMLSFILE, ARETHESAMEFILE, &
  & DEALLOCATE_FILEDATABASE, DUMP, &
  & GETMLSFILEBYNAME, GETMLSFILEBYTYPE, GETPCFROMREF, &
  & INITIALIZEMLSFILE, &
  & MASKNAME, &
  & MLS_CLOSEFILE, MLS_EXISTS, MLS_HDF_VERSION, MLS_INQSWATH, &
  & MLS_OPENFILE, MLS_SFSTART, MLS_SFEND, &
  & READNCHARS, RELEASE_MLSFILE, RESERVE_MLSFILE, &
  & RMFILEFROMDATABASE, SPLIT_PATH_NAME, &
  & TRANSFER_MLSFILE, UNMASKNAME, UNSPLITNAME
d110 1
d137 2
a138 1
! split_path_name (char* full_file_name, char* path, char* name, [char slash])
d253 1
d2465 1
a2465 1
       "$Id: MLSFiles.f90,v 2.99 2014/01/09 00:24:29 pwagner Exp $"
d2477 3
@


2.99
log
@Some procedures formerly in output_m now got from highOutput
@
text
@a56 1
  & CLOSE_MLSFILE, &
a62 1
  & OPEN_MLSFILE, &
a101 1
! close_MLSFile      Closes an mls file (of any type)
a115 1
! open_MLSFile       Opens an mls file (of any type)
a165 1
! close_MLSFile ( MLSFile_T MLSFile )
a177 1
! open_MLSFile ( MLSFile_T MLSFile )
a720 274
  ! ----------------------------------------------  open_MLSFile  -----

  ! This routine opens an mls file using either the toolbox
  ! or else a Fortran OPEN statement
  ! as appropriate, filling the fields of the MLSFile as needed
  
  ! It must be supplied an MLSFile_t for its arg

  ! Naturally, at least one of the arg's fields must be non-default values:
  ! MLSFile%{Name, PC_Id}

  ! It generates an error if unsuccessful

  subroutine open_MLSFile(MLSFile, PCBottom, PCTop, inp_rec_length, unknown)

    use IO_Stuff, only: GET_LUN

    ! Dummy arguments
    type (MLSFile_T)          :: MLSFile
    integer,  optional, intent(IN)   :: PCBottom, PCTop
    logical, optional, intent(in) :: unknown
    integer, optional, intent(in) :: inp_rec_length

    ! Local
    integer  :: ErrType
    logical,  parameter      :: caseSensitive = .true.
    ! integer       :: FileAccessType

    logical, parameter :: DEFAULT_PRINT_EVERY_OPEN=.false.
    integer, parameter :: FH_ON_ERROR=-99
    integer, parameter :: DEFAULTRECLEN=0
    integer, parameter :: KEYWORDLEN=12   ! Max length of keywords in OPEN(...)
    integer                       :: version, returnStatus
    character (LEN=KEYWORDLEN) :: access, action, form, position, status
    integer                       :: record_length
    integer                       :: unit

    ! begin
    ErrType = 0
    version = 1
    if ( present(PCBottom) .and. present(PCTop) ) then
      if ( MLSFile%PCFId > 0 ) then
        returnStatus = Pgs_pc_getReference(MLSFile%PCFId, version, &
          & MLSFile%Name)
      else if ( MLSFile%Name /= '' ) then
        MLSFile%PCFId = GetPCFromRef(trim(MLSFile%Name), PCBottom, PCTop, &
          & caseSensitive, returnStatus, version, &
          & debugOption=.false.)
      else
        call MLSMessage ( MLSMSG_Error, moduleName,  &
         & 'You must supply either a name or a PCFid to open a file' )
      end if
    end if

    select case (MLSFile%Type)

    ! case('asc-tk', 'bin-tk')
    case(l_tkgen)
     ! Using Toolkit
      if ( MLSFile%PCFId > 0 ) then
        returnStatus = Pgs_pc_getReference(MLSFile%PCFId, version, &
          & MLSFile%Name)
      elseif ( MLSFile%Name /= '' ) then
          MLSFile%PCFId = GetPCFromRef(trim(MLSFile%Name), PCBottom, PCTop, &
            &  caseSensitive, returnStatus, version, &
            & debugOption=.false.)

      else
        CALL MLSMessage ( MLSMSG_Error, moduleName,  &
         & 'You must supply either a name or a PCFid to open a file' )
      endif
      ErrType = PGS_IO_Gen_OpenF(MLSFile%PCFId, MLSFile%access, record_length, &
          & MLSFile%FileId%f_id, version)

    case(l_swath)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        ! call output( 'About to attempt to mls_open a swath file: ' // trim(MLSFile%Name), &
        !  & advance='yes' )
        ! print *, 'access: ', MLSFile%access
        ! print *, 'access(hdf5): ', he2he5_fileaccess(MLSFile%access)
        MLSFile%FileId%f_id = he5_swopen(trim(MLSFile%Name), &
          & he2he5_fileaccess(MLSFile%access))
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
         MLSFile%FileId%f_id = swopen(trim(MLSFile%Name), MLSFile%access)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    case(l_hdfeos)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        MLSFile%FileId%f_id = he5_gdopen(trim(MLSFile%Name), &
          & he2he5_fileaccess(MLSFile%access))
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
        MLSFile%FileId%f_id = gdopen(trim(MLSFile%Name), MLSFile%access)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    case(l_hdf)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        MLSFile%FileId%f_id = mls_sfstart(trim(MLSFile%Name), &
          & MLSFile%access, HDFVERSION_5)
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
        MLSFile%FileId%f_id = sfstart(trim(MLSFile%Name), MLSFile%access)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    case(l_ascii, l_binary)
      if(MLSFile%access == DFACC_RDONLY) then
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'read'
        position = 'rewind'
      elseif(MLSFile%access == DFACC_CREATE) then
        status = 'new'
        access = 'sequential'
        form = 'formatted'
        action = 'write'
        position = 'rewind'
      elseif(MLSFile%access == DFACC_RDWR) then
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'readwrite'
        position = 'rewind'
      else
        ErrType = UNKNOWNFILEACCESSTYPE
      endif
      
      if ( MLSFile%Type == l_binary ) then
        access = 'direct'
        form = 'unformatted'
      endif

      call get_lun ( unit, msg=.false. )
      if ( unit < 0 ) then
        ErrType = NOFREEUNITS
      end if

      if (present(unknown)) then
        if (unknown) status = 'unknown'
      end if

      if ( present(inp_rec_length) ) then
        if ( access /= 'direct' ) then
          open ( unit=unit, access=access, action=action, form=form, &
            & status=status, file=trim(MLSFile%Name), iostat=ErrType, &
            & recl=inp_rec_length, position=position )
        else
          open ( unit=unit, access=access, action=action, form=form, &
            & status=status, file=trim(MLSFile%Name), iostat=ErrType, &
            & recl=inp_rec_length )
        end if
      else if ( access /= 'direct' ) then
        open ( unit=unit, access=access, action=action, form=form, &
          & status=status, file=trim(MLSFile%Name), iostat=ErrType, &
          & position=position )
      else
        open ( unit=unit, access=access, action=action, form=form, &
          & status=status, file=trim(MLSFile%Name), iostat=ErrType )
      end if

      if(ErrType /= 0) then
        call output( 'Fortran opening unit ', advance='no')
        call output(  unit, advance='yes')
        call output( 'access ' // access, advance='yes')
        call output( 'action ' // action, advance='yes')
        call output( 'form ' // form, advance='yes')
        call output( 'position ' // position, advance='yes')
        call output( 'status ' // status, advance='yes')
        call output( 'file ' // trim(MLSFile%Name), advance='yes')
        call output( 'iostat ', advance='no')
        call output(  ErrType, advance='yes')
        call io_error('io error in MLSFiles: open_MLSFile' // &
          & ' Fortran open', ErrType, trim(MLSFile%Name))
      else
        MLSFile%FileId%f_id = unit
      endif

    case default
      ErrType = UNKNOWNTOOLBOXMODE

    end select

    if(ErrType /= 0) then
      call MLSMessage ( MLSMSG_Error, &
        & ModuleName // 'open_MLSFile', &
        & "Cannot open file " // trim(MLSFile%Name), MLSFile=MLSFile )
    endif
    
  end subroutine open_MLSFile

  ! ----------------------------------------------  close_MLSFile  -----

  ! This subroutine closes an mls file using either the toolbox
  ! or else a Fortran CLOSE statement
  ! as appropriate

  ! It generates an error if unsuccessful

  ! It must be supplied an MLSFile_t for its arg
  subroutine close_MLSFile(MLSFile)

    use HDF5, only: H5FCLOSE_F
    ! Dummy arguments
    type (MLSFile_T) ::            MLSFile

    ! Local
    integer :: ErrType

    ! begin
    ErrType = 0

    select case (MLSFile%Type)

    ! case('asc-tk', 'bin-tk', 'tkgen')
    case(l_tkgen)
      ErrType = PGS_IO_Gen_CLoseF(MLSFile%FileId%f_id)

    ! case('swath')
    case(l_swath)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        ErrType = he5_swclose(MLSFile%FileId%f_id)
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
        ErrType = swclose(MLSFile%FileId%f_id)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    ! case('grid')
    case(l_hdfeos)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        ErrType = he5_gdclose(MLSFile%FileId%f_id)
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
        ErrType = gdclose(MLSFile%FileId%f_id)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    ! case('hdf')
    case(l_hdf)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        call h5fclose_f(MLSFile%FileId%f_id, ErrType)
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
        ErrType = sfend(MLSFile%FileId%f_id)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    ! case('ascii', 'binary')
    case(l_ascii, l_binary)
      close(unit=MLSFile%FileId%f_id, iostat=ErrType)

      if(ErrType /= 0) then
        call output( 'Fortran closing unit ', advance='no')
        call output(  MLSFile%FileId%f_id, advance='yes')
        call output( 'iostat ', advance='no')
        call output(  ErrType, advance='yes')
        call io_error('io error in MLSFiles: close_MLSFile' // &
          & ' Fortran close', ErrType, 'unknown')
      endif

    case default
      ErrType = UNKNOWNTOOLBOXMODE

    end select
    if ( ErrType /= 0 ) &
      &  CALL MLSMessage ( MLSMSG_Error, moduleName,  &
      & "Unable to close file " // trim(MLSFile%Name) )

  end subroutine close_MLSFile

d757 1
a757 1
      if ( database(i)%StillOpen ) call close_MLSFile(database(i))
d2462 1
a2462 1
       "$Id: MLSFiles.f90,v 2.98 2013/09/24 23:27:14 vsnyder Exp $"
d2474 3
@


2.98
log
@Use Get_Where or Print_Source to start error messages
@
text
@d21 1
d34 1
a34 1
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE
d2742 1
a2742 1
       "$Id: MLSFiles.f90,v 2.97 2013/08/12 23:47:25 pwagner Exp $"
d2754 3
@


2.97
log
@FindSomethings moved to MLSFinds module
@
text
@d292 1
a292 1
  !-----------------------------------------  accessDFACCToStr  -----
d314 1
a314 1
  !-----------------------------------------  accessStrToDFACC  -----
d336 1
a336 1
  !-----------------------------------------  AddFileToDatabase  -----
d354 1
a354 1
  !-----------------------------------------  AddInitializeMLSFile  -----
d386 1
a386 1
  !-----------------------------------------  AreTheSameFile  -----
d400 1
a400 1
  !-----------------------------------------  InitializeMLSFile  -----
d456 1
a456 1
  ! ---------------------------------------------  GetPCFromRef  -----
d726 1
a726 1
  ! ---------------------------------------------  open_MLSFile  -----
d920 1
a920 1
  ! ---------------------------------------------  close_MLSFile  -----
d1000 1
a1000 1
  !-----------------------------------------  RmFileFromDatabase  -----
d1022 1
a1022 1
  ! ----------------------  Deallocate_filedatabase  -----
d1044 1
a1044 1
  ! ------------------------------------------ Dump_FileDataBase ------------
d1278 1
a1278 1
  ! ---------------------------------------------  he2he5_fileaccess  -----
d1310 1
a1310 1
  ! ---------------------------------------------  hdf2hdf5_fileaccess  -----
d1340 1
a1340 1
  ! ---------------------------------------------  mls_inqswath  -----
d1403 1
a1403 1
  ! ---------------------------------------------  mls_sfstart  -----
d1518 1
a1518 1
  ! ---------------------------------------------  mls_sfend  -----
d1586 1
a1586 1
  ! ---------------------------------------------  mls_hdf_version  -----
d1939 1
a1939 1
!----------------------- mls_exists
d1950 1
a1950 1
  !-----------------------------------------  transfer_MLSFile  -----
d2080 1
a2080 1
  ! ---------------------------------------------  mls_io_gen_closeF  -----
d2252 1
a2252 1
  ! ---------------------------------------------  mls_io_gen_openF  -----
d2741 1
a2741 1
       "$Id: MLSFiles.f90,v 2.96 2013/07/24 19:01:03 pwagner Exp $"
d2753 3
@


2.96
log
@Fixed bug opening non-hdf file
@
text
@d29 1
a29 1
  use MLSSETS, only: FINDFIRST
d2741 1
a2741 1
       "$Id: MLSFiles.f90,v 2.95 2013/05/31 00:27:44 vsnyder Exp $"
d2753 3
@


2.95
log
@Add cautionary comment about HDFVersions
@
text
@d419 1
a419 1
    InitializeMLSFile = 0
a451 2
!     if ( item%access > 0 ) &
!       & item%accessStr = accessType(access)
d1760 1
d2407 1
a2407 1
   if (the_eff_mode == l_tkgen .or. the_eff_mode == l_open ) then
d2415 4
d2440 6
d2466 2
a2467 1
   if ( myhdfVersion < 0 ) then
d2472 1
d2563 4
d2653 9
a2661 4
        ErrType = UNKNOWNFILEACCESSTYPE
        if ( debug ) &
         & call output('Unknown file access type', advance='yes')
        return
d2676 7
d2741 1
a2741 1
       "$Id: MLSFiles.f90,v 2.94 2012/08/27 23:01:29 pwagner Exp $"
d2753 3
@


2.94
log
@Consistent with new api for SortArray
@
text
@d190 1
d2714 1
a2714 1
       "$Id: MLSFiles.f90,v 2.93 2012/08/14 00:20:13 pwagner Exp $"
d2726 3
@


2.93
log
@Removed unused stuff
@
text
@d504 1
d589 2
d592 2
a593 2
    call SortArray(unsortedArray, intArray, caseSensitive, &
     & sortedArray=nameArray, shorterFirst=.true., leftRight='r')
d597 1
a597 1
      if ( index(NameOnly, trim(MatchName)) /= 0 )then  
a1938 2


d2713 1
a2713 1
       "$Id: MLSFiles.f90,v 2.92 2012/05/24 20:32:11 vsnyder Exp $"
d2725 3
@


2.92
log
@Simplify mls_exists
@
text
@d54 13
a66 13
  public :: accessType, AddFileToDataBase, &
  & AddInitializeMLSFile, AreTheSameFile, &
  & close_MLSFile, &
  & Deallocate_filedatabase, Dump, &
  & GetMLSFileByName, GetMLSFileByType, GetPCFromRef, &
  & InitializeMLSFile, &
  & maskName, &
  & mls_closeFile, mls_exists, mls_hdf_version, mls_inqswath, &
  & mls_openFile, mls_sfstart, mls_sfend, &
  & open_MLSFile, &
  & readnchars, release_MLSFile, reserve_MLSFile, &
  & RmFileFromDataBase, split_path_name, &
  & transfer_MLSFile, unMaskName, unSplitName
a254 5
  ! The only legal unit numbers that files may be assigned
  ! for use by Fortran opens, closes, reads and writes
  integer, parameter :: bottom_unit_num=1
  integer, parameter :: top_unit_num=99

d2712 1
a2712 1
       "$Id: MLSFiles.f90,v 2.91 2012/03/14 16:55:11 pwagner Exp $"
d2724 3
@


2.91
log
@Fixed most recent goldbrick-busting bug
@
text
@d1951 1
a1951 5
  if (exist) then
    mls_exists = 0
  else
    mls_exists = FILENOTFOUND
  endif
d2717 1
a2717 1
       "$Id: MLSFiles.f90,v 2.90 2012/01/05 01:14:54 pwagner Exp $"
d2729 3
@


2.90
log
@Capitalized USEd stuff
@
text
@d33 1
a33 1
  use OUTPUT_M, only: BLANKS, OUTPUT
d1360 2
d1364 4
d1385 4
d1390 1
d1396 4
a1399 1
    if ( strBufSize > len(swathList) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1401 1
d1791 1
a1791 1
    ! clobber it or fail on open becuase it already exists
d2721 1
a2721 1
       "$Id: MLSFiles.f90,v 2.89 2011/07/12 22:35:44 honghanh Exp $"
d2733 3
@


2.89
log
@Change l_grid to l_hdfeos
@
text
@d15 30
a44 30
  use Hdf, only: DFACC_CREATE, DFACC_RDONLY, DFACC_READ, DFACC_RDWR, &
    & sfstart, sfend
  use HDFEOS, only: gdclose, gdopen, swclose, swopen, swinqswath
  use HDFEOS5, only: he5_swclose, he5_swopen, he5_swinqswath, &
    & he5_gdopen, he5_gdclose, &
    & HE5F_ACC_TRUNC, HE5F_ACC_RDONLY, HE5F_ACC_RDWR
  use intrinsic, only: l_ascii, l_binary, l_hdfeos, l_hdf, l_open, &
    & l_swath, l_tkgen, l_zonalavg, lit_indices
  use IO_STUFF, only: get_lun
  use machine, only: io_error
  use MLSCommon, only: BareFNLen, FileNameLen,  MLSFile_T, Range_T, &
    & inRange
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, &
    & MLSMSG_DeAllocate, MLSMSG_Crash, MLSMSG_Error, MLSMSG_Warning
  use MLSSets, only: findFirst
  use MLSStrings, only: Capitalize, LowerCase
  use MLSStringLists, only: ExtractSubString, &
    & ReplaceSubString, SortArray
  use output_m, only: blanks, output
  use SDPToolkit, only: &
    & Pgs_pc_getReference, PGS_S_SUCCESS, &
    & PGSd_IO_Gen_RSeqFrm, PGSd_IO_Gen_RSeqUnf, & 
    & PGSd_IO_Gen_RDirFrm, PGSd_IO_Gen_RDirUnf, & 
    & PGSd_IO_Gen_WSeqFrm, PGSd_IO_Gen_WSeqUnf, & 
    & PGSd_IO_Gen_WDirFrm, PGSd_IO_Gen_WDirUnf, & 
    & PGSd_IO_Gen_USeqFrm, PGSd_IO_Gen_USeqUnf, & 
    & PGSd_IO_Gen_UDirFrm, PGSd_IO_Gen_UDirUnf, & 
    & PGSd_IO_Gen_ASeqFrm, PGSd_IO_Gen_ASeqUnf, &
    & PGS_IO_GEN_CloseF, PGS_IO_GEN_OpenF, PGSd_PC_FILE_PATH_MAX, &
    & UseSDPToolkit
d48 2
a49 2
  use String_Table, only: display_string, get_string
  use HDF5, only: size_t
d744 1
a744 1
    use IO_Stuff, only: Get_Lun
d934 1
a934 1
    use HDF5, only: h5fclose_f
d1179 1
a1179 1
    use Machine, only: Filsep ! / or :\
d1401 1
a1401 1
    use HDF5, only: h5fopen_f, h5fcreate_f
d1518 1
a1518 1
    use HDF5, only: h5fclose_f
d1585 1
a1585 1
   use HDF5, only: h5fis_hdf5_f
d1664 1
a1664 1
   use HDF5, only: h5fopen_f, h5fcreate_f, h5fis_hdf5_f
d1856 1
a1856 1
    use HDF5, only: h5fclose_f
d2094 1
a2094 1
    use HDF5, only: h5fclose_f
d2283 1
a2283 1
    use IO_Stuff, only: Get_Lun
d2706 1
a2706 1
       "$Id: MLSFiles.f90,v 2.88 2009/09/29 23:32:40 pwagner Exp $"
d2718 3
@


2.88
log
@Changes needed by 64-bit build
@
text
@d21 1
a21 1
  use intrinsic, only: l_ascii, l_binary, l_grid, l_hdf, l_open, &
d817 1
a817 1
    case(l_grid)
d961 1
a961 1
    case(l_grid)
d1149 1
a1149 1
    if ( any(MLSFile%type == (/l_hdf, l_swath, l_grid, l_zonalavg /) ) ) then
d1765 1
a1765 1
     & any(MLSFile%type == (/l_hdf, l_swath, l_grid, l_zonalavg /) ) .and. &
d2203 1
a2203 1
    case(l_grid)
d2499 1
a2499 1
    case(l_grid)
d2706 1
a2706 1
       "$Id: MLSFiles.f90,v 2.87 2009/06/23 18:25:42 pwagner Exp $"
d2718 3
@


2.87
log
@Prevent Intel from optimizing ident string away
@
text
@d49 1
d70 1
a70 1
       "$RCSfile: $"
d1351 4
a1354 4
      character (len=*), intent(in) :: FILENAME
      character (len=*), intent(out) :: SWATHLIST
      integer, intent(out):: STRBUFSIZE
      integer :: mls_inqswath
d1359 1
d1378 2
a1379 1
      mls_inqswath = he5_swinqswath(trim(FileName), swathList, strBufSize)
d2706 1
a2706 1
       "$Id: read_apriori.f90 is it here $"
d2718 3
@


2.86
log
@mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
@
text
@d69 1
a69 1
       "$RCSfile: MLSFiles.f90,v $"
d2700 1
a2701 1
!---------------------------- RCS Ident Info -------------------------------
d2703 2
a2704 3
       "$Id: MLSFiles.f90,v 2.85 2008/05/24 00:54:46 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2706 1
a2706 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d2708 1
d2715 3
@


2.85
log
@Remove unused declarations
@
text
@d25 1
a25 1
  use MLSCommon, only: i4, BareFNLen, FileNameLen,  MLSFile_T, Range_T, &
a60 2
  & mls_io_gen_closeF, &
  & mls_io_gen_openF, &
d86 3
a88 3
!                    mls_io_gen_openF given invalid file access type
! UNKNOWNTOOLBOXMODE mls_io_gen_openF given invalid toolbox mode
! NOFREEUNITS        mls_io_gen_openF ran out of free units
d90 3
a92 3
!                    mls_io_gen_openF given neither required argument
! NOPCIFNOTOOLKIT    mls_io_gen_openF must be given filename if toolkitless
! NOSUCHHDFVERSION   mls_io_gen_openF given invalid hdf version
a113 2
! mls_io_gen_openF   Opens a generic file using the toolbox or Fortran OPEN
! mls_io_gen_closeF  Closes a generic file using the toolbox or Fortran CLOSE
d135 2
a136 2
! i4 GetPCFromRef (char* FileName, i4 PCBottom, i4 PCTop,
!     log caseSensitive, i4 ErrType, [i4 versionNum], [log debugOption],
a137 6
! i4 mls_io_gen_openF (char* toolbox_mode, log caseSensitive, i4 ErrType, 
!     i4 record_length, i4 FileAccessType, 
!     [char* FileName], [i4 PCBottom], [i4 PCTop], [i4 versionNum],
!     [log unknown], [i4 thePC], [int hdfVersion], [log debugOption])
! i4 mls_io_gen_closeF (char* toolbox_mode, i4 theFileHandle, 
!     [char* FileName], [int hdfVersion])
d141 1
a141 1
! int mls_sfstart (char* FileName, i4 FileAccess, [int hdfVersion])
d143 1
a143 1
! i4 mls_hdf_version (char* FileName, [i4 preferred_version], [i4 AccessType])
d168 1
d179 3
a181 2
! mls_CloseFile(MLSFile MLSFile, [int error])
! mls_OpenFile(MLSFile MLSFile, [int error])
d491 3
a493 3
    integer(i4),  intent(IN)                 :: PCBottom, PCTop
    integer(i4)                              :: thePC, notThePC
    integer(i4),  intent(OUT)                :: ErrType
d495 1
a495 1
    integer(i4),  optional                   :: versionNum
d728 1
a728 1
  ! ---------------------------------------------  mls_io_gen_openF  -----
d730 1
a730 1
  ! This function opens a generic file using either the toolbox
d732 3
a734 6
  ! according to toolbox_mode:
  ! 'gd' for grid files opened with gdopen
  ! 'hg' for hdf4/5 files opened with sfstart/h5fopen_f; e.g. l1brad
  ! 'pg' for generic files opened with pgs_io_gen_openF
  ! 'op' for l3ascii files opened with simple fortran 'open'
  ! 'sw' for swath files opened with swopen
d736 2
a737 1
  ! It returns theFileHandle corresponding to the FileName or the PC
d739 1
a739 3
  ! If given a FileName as an arg and a range of PC numbers
  ! [PCBottom, PCTop] which are integers
  ! it will attempt to find a corresponding PC
d741 1
a741 20
  ! If given a PC it will attempt to find the corresponding FileName

  ! toolbox_mode                  meaning
  ! PGS_IO_GEN_OpenF              use PGS_IO_Gen_OpenF or fail
  !      swopen                   use swopen or fail
  !      gdopen                   use gdopen or fail
  !       open                    use Fortran or fail

  ! If the FileName is not found, it sets ErrType=NAMENOTFOUND
  ! otherwise ErrType=0

  ! This is useful because all the Toolbox routines refer to files
  ! by their PC numbers, not their names

  !  function mls_io_gen_openF(toolbox_mode, caseSensitive, ErrType, &
  function mls_io_gen_openF(mode, caseSensitive, ErrType, &
    & record_length, FileAccessType, &
    & FileName, PCBottom, PCTop, versionNum, unknown, thePC, &
    & hdfVersion, debugOption, inp_rec_length) &
    &  result (theFileHandle)
d746 2
a747 11
    integer(i4),  intent(OUT)  :: ErrType
    integer(i4),  intent(IN)  :: record_length
    logical,  intent(IN)       :: caseSensitive
    ! character (LEN=*), intent(IN) :: toolbox_mode
    integer, intent(IN) :: mode
    integer(i4), intent(IN)       :: FileAccessType ! One of hdf4 dfacc*
    integer(i4)  :: theFileHandle
    character (LEN=*), optional, intent(IN)   :: FileName
    integer(i4),  optional, intent(IN)   :: PCBottom, PCTop
    integer(i4), optional, intent(IN)                :: thePC
    integer(i4),  optional     :: versionNum
a748 3
    logical, optional, intent(in) :: debugOption

    integer, optional, intent(in) :: hdfVersion
d752 3
a754 1
    integer :: myhdfVersion
d759 2
a760 4
    integer, parameter :: KEYWORDLEN=12 ! Max length of keywords in OPEN(...)
    character (LEN=MAXFILENAMELENGTH) :: myName
    integer(i4) :: myPC
    integer                       :: version, returnStatus, your_version
d762 1
a762 2
    ! character (LEN=2) :: the_eff_mode
    integer :: the_eff_mode
a763 2
    logical ::                            debug
    logical ::                            PRINT_EVERY_OPEN
d766 15
d782 1
a782 5
    if(present(debugOption)) then
      debug = debugOption
   else
      debug = .false.
   endif
d784 10
a793 6
   PRINT_EVERY_OPEN = DEFAULT_PRINT_EVERY_OPEN .or. debug
   returnStatus = 0           ! In case using Toolkit but supplied FileName
   myPC = 0
    ! In case of premature return
    theFileHandle = FH_ON_ERROR
    ! record_length = DEFAULTRECLEN
d795 6
a800 5
    if(present(versionNum)) then
      version = versionNum
    else
      version = 1
    endif
d802 12
a813 21
   the_eff_mode = mode
   if(UseSDPToolkit) then
    ! the_eff_mode = LowerCase(toolbox_mode(1:2))
    your_version = version
   ! Using Toolkit
    if(present(thePC)) then
      myPC = thePC
      returnStatus = Pgs_pc_getReference(thePC, your_version, &
        & myName)
      if ( debug ) then
          call output('Call to Pgs_pc_getReference', &
          & advance='yes')
          call output('returnStatus: ', advance='no')
          call blanks(2)
          call output(returnStatus, advance='yes')
          call output('thePC: ', advance='no')
          call blanks(2)
          call output(thePC, advance='yes')
          call output('your_version: ', advance='no')
          call blanks(2)
          call output(your_version, advance='yes')
d815 9
a823 7
    elseif(present(FileName)) then
      myName = FileName
      ! if(LowerCase(toolbox_mode(1:2)) == 'pg') then
      if(mode == l_tkgen) then
        myPC = GetPCFromRef(trim(FileName), PCBottom, PCTop, &
          & caseSensitive, returnStatus, your_version, &
          & debugOption=debugOption)
d826 9
a834 7
    else
      ErrType = MUSTSUPPLYFILENAMEORPC
      if ( debug ) & 
       & call output('Must supply file name or pc to mls_io_gen_openF', &
       & advance='yes')
      return
    endif
d836 22
a857 8
   ! Not Using Toolkit
   ! Must supply FileName, use generic Fortran open
   elseif(.not. present(FileName)) then
      ErrType = NOPCIFNOTOOLKIT
      if ( debug ) & 
       & call output('No toolkit: must supply file name to mls_io_gen_openF', &
       & advance='yes')
      return
d859 13
a871 6
   else
      myName = FileName
      ! the_eff_mode = LowerCase(toolbox_mode(1:2))
      ! if(the_eff_mode == 'pg') the_eff_mode = 'op'
      if(the_eff_mode == l_tkgen) the_eff_mode = l_open
   endif
d873 18
a890 19
   ! hdfVersion unimportant for 'pg' or 'op' operations
   ! if (the_eff_mode == 'pg' .or. the_eff_mode == 'op' ) then
   myhdfVersion = WRONGHDFVERSION
   if ( present(hdfVersion) ) myHdfVersion = hdfVersion
   if (the_eff_mode == l_tkgen .or. the_eff_mode == l_open ) then
     myhdfVersion = WILDCARDHDFVERSION
   elseif ( .not. any( myhdfVersion == (/HDFVERSION_4, HDFVERSION_5/) ) ) then
     if ( debug ) then
       call output( 'myName: ', advance='no' )
       call output( trim(myName), advance='yes' )
       call output( 'FileAccessType: ', advance='no' )
       call output( FileAccessType, advance='yes' )
       if ( present(hdfVersion) ) then
       call output( 'hdfVersion: ', advance='no' )
       call output( hdfVersion, advance='yes' )
       endif
     endif
     myhdfVersion = mls_hdf_version(trim(myName), hdfVersion, FileAccessType)             
   endif
d892 50
a941 32
   if ( debug ) then
       call output('Arguments and options in call to mls_io_gen_openF', &
       & advance='yes')
       call output('Mode: ', advance='no')
       call blanks(2)
       if ( FILESTRINGTABLE ) then
       call display_string ( lit_indices(the_eff_mode), strip=.true.)                                  
       call blanks(2)
       endif
       call output(the_eff_mode, advance='yes')
       call output('l_hdf: ', advance='no')
       call blanks(2)
       call output(l_hdf, advance='yes')
       call output('File Name: ', advance='no')
       call blanks(2)
       call output(trim(myName), advance='yes')
       call output('PCF-supplied number: ', advance='no')
       call blanks(2)
       call output(myPC, advance='yes')
       call output('Case sensitive? ', advance='no')
       call blanks(2)
       call output(caseSensitive, advance='yes')
       call output('File access type ', advance='no')
       call blanks(2)
       call output(FileAccessType, advance='yes')
       call output('Return status ', advance='no')
       call blanks(2)
       call output(returnStatus, advance='yes')
       call output('hdf version ', advance='no')
       call blanks(2)
       call output(myhdfVersion, advance='yes')
   endif
d943 1
a943 6
   if ( myhdfVersion < 0 ) then
     ErrType = myhdfVersion
     return
   endif
    your_version = version
    select case (the_eff_mode)
d945 1
a945 1
    ! case('pg')
d947 1
a947 6
      if(returnStatus == 0) then
         ErrType = PGS_IO_Gen_OpenF(myPC, FileAccessType, record_length, &
          & theFileHandle, your_version)
      else
        ErrType = returnStatus
       endif
d949 1
a949 1
    ! case('sw')
d951 4
a954 8
      if(returnStatus /= 0) then
        ErrType = returnStatus
        return
      elseif(myhdfVersion == HDFVERSION_5) then
        theFileHandle = he5_swopen(trim(myName), &
          & he2he5_fileaccess(FileAccessType))
      elseif(myhdfVersion == HDFVERSION_4) then
        theFileHandle = swopen(trim(myName), FileAccessType)
a956 1
        return
a957 18
      if(theFileHandle <= 0) then                                          
        ErrType = min(theFileHandle, -1)                                   
      else                                                                 
        ErrType = 0                                                        
      endif                                                                
      if ( debug ) then                                                    
          call output('Args and results from he5_swopen', &                
          & advance='yes')                                                 
          call output('File Name: ', advance='no')                         
          call blanks(2)                                                   
          call output(trim(myName), advance='yes')                         
          call output('File Access: ', advance='no')                       
          call blanks(2)                                                   
          call output(he2he5_fileaccess(FileAccessType), advance='yes')  
          call output('theFileHandle: ', advance='no')                     
          call blanks(2)                                                   
          call output(theFileHandle, advance='yes')                        
      endif                                                                
d959 1
a959 1
    ! case('gd')
d961 4
a964 8
      if(returnStatus /= 0) then
        ErrType = returnStatus
        return
      elseif(myhdfVersion == HDFVERSION_5) then
        theFileHandle = he5_gdopen(trim(myName), &
          & he2he5_fileaccess(FileAccessType))
      elseif(myhdfVersion == HDFVERSION_4) then
        theFileHandle = gdopen(trim(myName), FileAccessType)
a966 1
        return
a967 5
      if(theFileHandle <= 0) then         
        ErrType = min(theFileHandle, -1)  
      else                                
        ErrType = 0                       
      endif                               
d969 1
a969 1
    ! case('hg')
d971 4
a974 11
      theFileHandle = -1   ! This is the error value expected by hdf4/5
      if(returnStatus /= 0) then
        ErrType = returnStatus
        return
      elseif(myhdfVersion == HDFVERSION_5) then
        ! print *, 'We are using the right mls_sfstart'
        ! print *, 'FileAccessType ', FileAccessType
        theFileHandle = mls_sfstart(trim(myName), FileAccessType, &
          & HDFVERSION_5)
      elseif(myhdfVersion == HDFVERSION_4) then
        theFileHandle = sfstart(trim(myName), FileAccessType)
a976 1
        return
a977 5
      if(theFileHandle <= 0) then         
        ErrType = min(theFileHandle, -1)  
      else                                
        ErrType = 0                       
      endif                               
d979 102
a1080 94
    ! case('op')
    case(l_ascii, l_open)
      theFileHandle = FH_ON_ERROR
      select case (FileAccessType)
      case(PGSd_IO_Gen_RSeqFrm, DFACC_RDONLY)
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'read'
        position = 'rewind'
      case(PGSd_IO_Gen_RSeqUnf)
        status = 'old'
        access = 'sequential'
        form = 'unformatted'
        action = 'read'
        position = 'rewind'
      case(PGSd_IO_Gen_RDirFrm)
        status = 'old'
        access = 'direct'
        form = 'formatted'
        action = 'read'
        position = 'rewind'
      case(PGSd_IO_Gen_RDirUnf)
        status = 'old'
        access = 'direct'
        form = 'unformatted'
        action = 'read'
        position = 'rewind'
      case(PGSd_IO_Gen_WSeqFrm, DFACC_CREATE)
        status = 'new'
        access = 'sequential'
        form = 'formatted'
        action = 'write'
        position = 'rewind'
      case(PGSd_IO_Gen_WSeqUnf)
        status = 'new'
        access = 'sequential'
        form = 'unformatted'
        action = 'write'
        position = 'rewind'
      case(PGSd_IO_Gen_WDirFrm)
        status = 'new'
        access = 'direct'
        form = 'formatted'
        action = 'write'
        position = 'rewind'
      case(PGSd_IO_Gen_WDirUnf)
        status = 'new'
        access = 'direct'
        form = 'unformatted'
        action = 'write'
        position = 'rewind'
      case(PGSd_IO_Gen_USeqFrm, DFACC_RDWR)
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'readwrite'
        position = 'rewind'
      case(PGSd_IO_Gen_USeqUnf)
        status = 'old'
        access = 'sequential'
        form = 'unformatted'
        action = 'readwrite'
        position = 'rewind'
      case(PGSd_IO_Gen_UDirFrm)
        status = 'old'
        access = 'direct'
        form = 'formatted'
        action = 'readwrite'
        position = 'rewind'
      case(PGSd_IO_Gen_UDirUnf)
        status = 'old'
        access = 'direct'
        form = 'unformatted'
        action = 'readwrite'
        position = 'rewind'
      case(PGSd_IO_Gen_ASeqFrm)
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'readwrite'
        position = 'append'
      case(PGSd_IO_Gen_ASeqUnf)
        status = 'old'
        access = 'sequential'
        form = 'unformatted'
        action = 'readwrite'
        position = 'append'
      case default
        ErrType = UNKNOWNFILEACCESSTYPE
        if ( debug ) &
         & call output('Unknown file access type', advance='yes')
        return
      end select
d1082 1
a1082 7
      call get_lun ( unit, msg=.false. )
      if( unit < 0 ) then
        ErrType = NOFREEUNITS
        if ( debug ) &
         & call output('No free io units available', advance='yes')
        return
      endif
d1084 1
a1084 3
      if (present(unknown)) then
        if (unknown) status = 'unknown'
      end if
d1086 7
a1092 10
      if ( present(inp_rec_length) ) then
        open(unit=unit, recl=inp_rec_length, form=form, &
          & status=status, file=trim(myName), iostat=ErrType)
      elseif(access /= 'direct') then
        open(unit=unit, access=access, action=action, form=form, &
          & position=position, status=status, file=trim(myName), iostat=ErrType)
      else
        open(unit=unit, access=access, action=action, form=form, &
          & status=status, file=trim(myName), iostat=ErrType)
      endif
d1094 65
a1158 10
      if(ErrType /= 0 .or. PRINT_EVERY_OPEN) then
        call output( 'Fortran opening unit ', advance='no')
        call output(  unit, advance='yes')
        call output( 'access ' // access, advance='yes')
        call output( 'action ' // action, advance='yes')
        call output( 'form ' // form, advance='yes')
        call output( 'position ' // position, advance='yes')
        call output( 'status ' // status, advance='yes')
        call output( 'file ' // trim(myName), advance='yes')
      endif
d1160 1
a1160 8
      if(ErrType /= 0) then
        call output( 'iostat ', advance='no')
        call output(  ErrType, advance='yes')
        call io_error('io error in MLSFiles: mls_io_gen_openF' // &
          & ' Fortran open', ErrType, trim(myName))
      else
        theFileHandle = unit
      endif
d1162 8
a1169 2
    case default
      ErrType = UNKNOWNTOOLBOXMODE
d1171 2
a1172 1
    end select
d1174 1
a1174 15
    if(ErrType /= 0) then
      theFileHandle = FH_ON_ERROR
    endif
    
    if( debug ) then
       call output('Error Type (0 means none): ', advance='no')
       call blanks(2)
       call output(ErrType, advance='yes')
       call output('record_length: ', advance='no')
       call blanks(2)
       call output(record_length, advance='yes')
       call output('theFileHandle: ', advance='no')
       call blanks(2)
       call output(theFileHandle, advance='yes')
    endif
d1176 1
a1176 1
  end function mls_io_gen_openF
d1178 1
a1178 1
  ! ---------------------------------------------  open_MLSFile  -----
d1180 4
a1183 5
  ! This routine opens an mls file using either the toolbox
  ! or else a Fortran OPEN statement
  ! as appropriate, filling the fields of the MLSFile as needed
  
  ! It must be supplied an MLSFile_t for its arg
d1185 1
a1185 2
  ! Naturally, at least one of the arg's fields must be non-default values:
  ! MLSFile%{Name, PC_Id}
d1187 3
a1189 1
  ! It generates an error if unsuccessful
d1191 1
a1191 1
  subroutine open_MLSFile(MLSFile, PCBottom, PCTop, inp_rec_length, unknown)
d1193 1
a1193 1
    use IO_Stuff, only: Get_Lun
d1195 5
a1199 5
    ! Dummy arguments
    type (MLSFile_T)          :: MLSFile
    integer(i4),  optional, intent(IN)   :: PCBottom, PCTop
    logical, optional, intent(in) :: unknown
    integer, optional, intent(in) :: inp_rec_length
d1201 5
a1205 4
    ! Local
    integer(i4)  :: ErrType
    logical,  parameter      :: caseSensitive = .true.
    ! integer(i4)       :: FileAccessType
d1207 1
a1207 8
    logical, parameter :: DEFAULT_PRINT_EVERY_OPEN=.false.
    integer, parameter :: FH_ON_ERROR=-99
    integer, parameter :: DEFAULTRECLEN=0
    integer, parameter :: KEYWORDLEN=12   ! Max length of keywords in OPEN(...)
    integer                       :: version, returnStatus
    character (LEN=KEYWORDLEN) :: access, action, form, position, status
    integer                       :: record_length
    integer                       :: unit
d1209 9
a1217 14
    ! begin
    version = 1
    if ( present(PCBottom) .and. present(PCTop) ) then
      if ( MLSFile%PCFId > 0 ) then
        returnStatus = Pgs_pc_getReference(MLSFile%PCFId, version, &
          & MLSFile%Name)
      else if ( MLSFile%Name /= '' ) then
        MLSFile%PCFId = GetPCFromRef(trim(MLSFile%Name), PCBottom, PCTop, &
          & caseSensitive, returnStatus, version, &
          & debugOption=.false.)
      else
        call MLSMessage ( MLSMSG_Error, moduleName,  &
         & 'You must supply either a name or a PCFid to open a file' )
      end if
d1220 14
a1233 1
    select case (MLSFile%Type)
d1235 5
a1239 10
    ! case('asc-tk', 'bin-tk')
    case(l_tkgen)
     ! Using Toolkit
      if ( MLSFile%PCFId > 0 ) then
        returnStatus = Pgs_pc_getReference(MLSFile%PCFId, version, &
          & MLSFile%Name)
      elseif ( MLSFile%Name /= '' ) then
          MLSFile%PCFId = GetPCFromRef(trim(MLSFile%Name), PCBottom, PCTop, &
            &  caseSensitive, returnStatus, version, &
            & debugOption=.false.)
d1241 17
a1257 6
      else
        CALL MLSMessage ( MLSMSG_Error, moduleName,  &
         & 'You must supply either a name or a PCFid to open a file' )
      endif
      ErrType = PGS_IO_Gen_OpenF(MLSFile%PCFId, MLSFile%access, record_length, &
          & MLSFile%FileId%f_id, version)
d1259 22
a1280 9
    case(l_swath)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        MLSFile%FileId%f_id = he5_swopen(trim(MLSFile%Name), &
          & he2he5_fileaccess(MLSFile%access))
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
         MLSFile%FileId%f_id = swopen(trim(MLSFile%Name), MLSFile%access)
      else
        ErrType = NOSUCHHDFVERSION
      endif
d1282 2
a1283 9
    case(l_grid)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        MLSFile%FileId%f_id = he5_gdopen(trim(MLSFile%Name), &
          & he2he5_fileaccess(MLSFile%access))
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
        MLSFile%FileId%f_id = gdopen(trim(MLSFile%Name), MLSFile%access)
      else
        ErrType = NOSUCHHDFVERSION
      endif
d1285 1
a1285 9
    case(l_hdf)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        MLSFile%FileId%f_id = mls_sfstart(trim(MLSFile%Name), &
          & MLSFile%access, HDFVERSION_5)
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
        MLSFile%FileId%f_id = sfstart(trim(MLSFile%Name), MLSFile%access)
      else
        ErrType = NOSUCHHDFVERSION
      endif
d1287 1
a1287 27
    case(l_ascii, l_binary)
      if(MLSFile%access == DFACC_RDONLY) then
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'read'
        position = 'rewind'
      elseif(MLSFile%access == DFACC_CREATE) then
        status = 'new'
        access = 'sequential'
        form = 'formatted'
        action = 'write'
        position = 'rewind'
      elseif(MLSFile%access == DFACC_RDWR) then
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'readwrite'
        position = 'rewind'
      else
        ErrType = UNKNOWNFILEACCESSTYPE
      endif
      
      if ( MLSFile%Type == l_binary ) then
        access = 'direct'
        form = 'unformatted'
      endif
d1289 6
a1294 4
      call get_lun ( unit, msg=.false. )
      if ( unit < 0 ) then
        ErrType = NOFREEUNITS
      end if
d1296 2
a1297 3
      if (present(unknown)) then
        if (unknown) status = 'unknown'
      end if
d1299 2
a1300 18
      if ( present(inp_rec_length) ) then
        if ( access /= 'direct' ) then
          open ( unit=unit, access=access, action=action, form=form, &
            & status=status, file=trim(MLSFile%Name), iostat=ErrType, &
            & recl=inp_rec_length, position=position )
        else
          open ( unit=unit, access=access, action=action, form=form, &
            & status=status, file=trim(MLSFile%Name), iostat=ErrType, &
            & recl=inp_rec_length )
        end if
      else if ( access /= 'direct' ) then
        open ( unit=unit, access=access, action=action, form=form, &
          & status=status, file=trim(MLSFile%Name), iostat=ErrType, &
          & position=position )
      else
        open ( unit=unit, access=access, action=action, form=form, &
          & status=status, file=trim(MLSFile%Name), iostat=ErrType )
      end if
d1302 2
a1303 16
      if(ErrType /= 0) then
        call output( 'Fortran opening unit ', advance='no')
        call output(  unit, advance='yes')
        call output( 'access ' // access, advance='yes')
        call output( 'action ' // action, advance='yes')
        call output( 'form ' // form, advance='yes')
        call output( 'position ' // position, advance='yes')
        call output( 'status ' // status, advance='yes')
        call output( 'file ' // trim(MLSFile%Name), advance='yes')
        call output( 'iostat ', advance='no')
        call output(  ErrType, advance='yes')
        call io_error('io error in MLSFiles: open_MLSFile' // &
          & ' Fortran open', ErrType, trim(MLSFile%Name))
      else
        MLSFile%FileId%f_id = unit
      endif
d1306 1
a1306 1
      ErrType = UNKNOWNTOOLBOXMODE
d1310 6
a1315 6
    if(ErrType /= 0) then
      call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot open file " // trim(MLSFile%Name) )
    endif
    
  end subroutine open_MLSFile
d1317 1
a1317 1
  ! ---------------------------------------------  mls_io_gen_closeF  -----
d1319 3
a1321 37
  ! This function closes a generic file using either the toolbox
  ! or else a Fortran CLOSE statement
  ! according to toolbox_mode:
  ! 'cl' for l3ascii files opened with simple fortran 'open'
  ! 'gd' for grid files opened with gdopen
  ! 'hg' for hdf4/5 files opened with sfstart/h5fopen_f; e.g. l1brad
  ! 'pg' for generic files opened with pgs_io_gen_openF
  ! 'sw' for swath files opened with swopen

  ! It returns a non-zero error status only if unsuccessful

  ! It must be given a FileHandle as an arg
  ! (A later version may allow choice between file handle and file name)
  ! (This version only uses a file name in autodetecting its hdf version)
  ! function mls_io_gen_closeF( toolbox_mode, theFileHandle, &
  function mls_io_gen_closeF( mode, theFileHandle, &
    & FileName, hdfVersion, debugOption ) &
    &  result (ErrType)

    use HDF5, only: h5fclose_f
    ! Dummy arguments
    integer(i4)  :: ErrType
    integer(i4), intent(IN)  :: theFileHandle
    ! character (LEN=*), intent(IN)   :: toolbox_mode
    integer, intent(IN)   :: mode
    character (LEN=*), optional, intent(IN)   :: FileName

    integer, optional, intent(in) :: hdfVersion
    logical, optional, intent(in) :: debugOption

    ! Local
    logical ::                            debug
    integer :: myhdfVersion

    logical, parameter :: PRINT_EVERY_CLOSE=.false.
    ! character (LEN=2) :: the_eff_mode
    integer :: the_eff_mode
d1323 3
d1327 1
d1329 2
a1330 15
    if(present(debugOption)) then
      debug = debugOption
   else
      debug = .false.
   endif
   the_eff_mode = mode
   if(UseSDPToolkit) then
   ! Using Toolkit
    ! the_eff_mode = LowerCase(toolbox_mode(1:2))
   ! Not Using Toolkit
   else
      ! the_eff_mode = LowerCase(toolbox_mode(1:2))
      ! if(the_eff_mode == 'pg') the_eff_mode = 'cl'
      if(the_eff_mode == l_tkgen) the_eff_mode = l_ascii ! l_close
   endif
d1332 2
a1333 106
  if ( debug ) then
    call output('Call to mls_io_gen_closeF', &
    & advance='yes')
    call output('the_eff_mode: ', advance='no')
    call blanks(2)
    call output(the_eff_mode, advance='yes')
    call output('theFileHandle: ', advance='no')
    call blanks(2)
    call output(theFileHandle, advance='yes')
    if ( present (hdfVersion) ) then
      call output('hdfVersion: ', advance='no')
      call blanks(2)
      call output(hdfVersion, advance='yes')
    endif
    if ( present (fileName) ) then
      call output('fileName: ', advance='no')
      call blanks(2)
      call output(trim(fileName), advance='yes')
    endif
  endif
  ErrType = 0
  myhdfVersion = WILDCARDHDFVERSION
  if ( present(hdfVersion) ) myhdfVersion = hdfVersion
   ! hdfVersion unimportant for 'pg' or 'cl' operations
   ! if (the_eff_mode == 'pg' .or. the_eff_mode == 'cl' ) then
   ! if (the_eff_mode == l_tkgen .or. the_eff_mode == l_close ) then
   if (the_eff_mode == l_tkgen .or. the_eff_mode == l_ascii ) then
     ErrType = 0
   elseif ( myhdfVersion /= WILDCARDHDFVERSION ) then
     ErrType = 0
   elseif ( present(FileName) ) then
     myhdfVersion = mls_hdf_version(trim(FileName), hdfVersion, DFACC_READ)
     if ( debug ) then
       call output('mls_hdf_versionF', &
       & advance='yes')
       call output('myhdfVersion: ', advance='no')
       call blanks(2)
       call output(myhdfVersion, advance='yes')
     endif
     if ( myhdfVersion < 0 ) then
        ErrType = myhdfVersion
        return
     endif
   elseif ( present(hdfVersion) ) then
     myhdfVersion = hdfVersion
   else
     myhdfVersion = DEFAULT_HDFVERSION
   endif
    select case (the_eff_mode)

    ! case('pg')
    case(l_tkgen)
      ErrType = PGS_IO_Gen_CLoseF(theFileHandle)

    ! case('sw')
    case(l_swath)
      if(myhdfVersion == HDFVERSION_5) then
        ErrType = he5_swclose(theFileHandle)
        if ( debug ) then
          call output('he5_swclose', &
          & advance='yes')
          call output('ErrType: ', advance='no')
          call blanks(2)
          call output(ErrType, advance='yes')
        endif
      elseif(myhdfVersion == HDFVERSION_4) then
        ErrType = swclose(theFileHandle)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    ! case('gd')
    case(l_grid)
      if(myhdfVersion == HDFVERSION_5) then
        ErrType = he5_gdclose(theFileHandle)
      elseif(myhdfVersion == HDFVERSION_4) then
        ErrType = gdclose(theFileHandle)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    ! case('hg')
    case(l_hdf)
      if(myhdfVersion == HDFVERSION_5) then
        call h5fclose_f(theFileHandle, ErrType)
      elseif(myhdfVersion == HDFVERSION_4) then
        ErrType = sfend(theFileHandle)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    ! case('cl')
    case(l_ascii) ! (l_ascii, l_close)
      close(unit=theFileHandle, iostat=ErrType)

      if(ErrType /= 0 .or. PRINT_EVERY_CLOSE) then
        call output( 'Fortran closing unit ', advance='no')
        call output(  theFileHandle, advance='yes')
      endif

      if(ErrType /= 0) then
        call output( 'iostat ', advance='no')
        call output(  ErrType, advance='yes')
        call io_error('io error in MLSFiles: mls_io_gen_closeF' // &
          & ' Fortran close', ErrType, 'unknown')
      endif
d1336 1
a1336 1
      ErrType = UNKNOWNTOOLBOXMODE
d1340 1
a1340 1
  end function mls_io_gen_closeF
d1342 1
a1342 1
  ! ---------------------------------------------  close_MLSFile  -----
d1344 1
a1344 3
  ! This subroutine closes an mls file using either the toolbox
  ! or else a Fortran CLOSE statement
  ! as appropriate
d1346 1
a1346 1
  ! It generates an error if unsuccessful
d1348 1
a1348 2
  ! It must be supplied an MLSFile_t for its arg
  subroutine close_MLSFile(MLSFile)
d1350 5
a1354 3
    use HDF5, only: h5fclose_f
    ! Dummy arguments
    type (MLSFile_T) ::            MLSFile
d1357 13
a1369 1
    integer :: ErrType
d1372 13
d1386 1
a1386 1
    select case (MLSFile%Type)
d1388 1
a1388 3
    ! case('asc-tk', 'bin-tk', 'tkgen')
    case(l_tkgen)
      ErrType = PGS_IO_Gen_CLoseF(MLSFile%FileId%f_id)
d1390 12
a1401 9
    ! case('swath')
    case(l_swath)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        ErrType = he5_swclose(MLSFile%FileId%f_id)
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
        ErrType = swclose(MLSFile%FileId%f_id)
      else
        ErrType = NOSUCHHDFVERSION
      endif
d1403 15
a1417 9
    ! case('grid')
    case(l_grid)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        ErrType = he5_gdclose(MLSFile%FileId%f_id)
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
        ErrType = gdclose(MLSFile%FileId%f_id)
      else
        ErrType = NOSUCHHDFVERSION
      endif
d1419 81
a1499 9
    ! case('hdf')
    case(l_hdf)
      if(MLSFile%HDFVersion == HDFVERSION_5) then
        call h5fclose_f(MLSFile%FileId%f_id, ErrType)
      elseif(MLSFile%HDFVersion == HDFVERSION_4) then
        ErrType = sfend(MLSFile%FileId%f_id)
      else
        ErrType = NOSUCHHDFVERSION
      endif
d1501 1
a1501 3
    ! case('ascii', 'binary')
    case(l_ascii, l_binary)
      close(unit=MLSFile%FileId%f_id, iostat=ErrType)
d1503 1
a1503 8
      if(ErrType /= 0) then
        call output( 'Fortran closing unit ', advance='no')
        call output(  MLSFile%FileId%f_id, advance='yes')
        call output( 'iostat ', advance='no')
        call output(  ErrType, advance='yes')
        call io_error('io error in MLSFiles: close_MLSFile' // &
          & ' Fortran close', ErrType, 'unknown')
      endif
d1505 7
a1511 2
    case default
      ErrType = UNKNOWNTOOLBOXMODE
d1513 1
a1513 4
    end select
    if ( ErrType /= 0 ) &
      &  CALL MLSMessage ( MLSMSG_Error, moduleName,  &
      & "Unable to close file " // trim(MLSFile%Name) )
d1515 2
a1516 1
  end subroutine close_MLSFile
d1518 9
a1526 2
  !-----------------------------------------  RmFileFromDatabase  -----
  integer function RmFileFromDatabase ( DATABASE, ITEM )
d1528 40
a1567 4
  ! This routine removes a vector from a database of such vectors, 
  ! deallocating the database if necessary.
  ! Alas, doesn't work--we need to know how to undecorate character tree
  ! first before we will be able to make it work; sorry (P. Wagner)
d1569 1
a1569 3
    ! Dummy arguments
    type (MLSFile_T), dimension(:), pointer :: DATABASE
    type (MLSFile_T), intent(in) ::            ITEM
d1571 1
a1571 6
    ! Local variables
    type (MLSFile_T), dimension(:), pointer :: tempDatabase
    logical, parameter                     :: okToDeallocEmptyDB = .FALSE.
    include "rmItemFromDatabase.f9h"
    call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot yet (ever?) rm File from database" ) 
d1573 5
a1577 2
    RmFileFromDatabase = newSize
  end function RmFileFromDatabase
d1579 2
a1580 1
  ! ----------------------  Deallocate_filedatabase  -----
d1582 2
a1583 2
  ! This routine deallocates the file database, closing any files
  ! that may still be open
d1585 5
a1589 1
  subroutine Deallocate_filedatabase(database)
d1591 4
a1594 14
    ! Arguments
    type (MLSFile_T), dimension(:), pointer :: DATABASE
    ! Local variables
    integer :: i, error
    ! Executable
    if ( .not. associated(database) ) return
    do i=1, size(database)
      if ( database(i)%StillOpen ) call close_MLSFile(database(i))
    enddo
    Deallocate ( database, stat=error )
    if ( error /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot deallocate file database" )
  end subroutine Deallocate_filedatabase
d1596 1
a1596 1
  ! ------------------------------------------ Dump_FileDataBase ------------
d1598 15
a1612 1
  subroutine Dump_FileDataBase ( database, Name, details )
d1614 5
a1618 4
    ! Dummy arguments
    type (MLSFile_T), intent(in) ::           database(:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional          :: details
d1620 4
a1623 12
    ! Local variables
    integer :: i
    integer :: myDetails
    ! Executable
    myDetails = 0
    if ( present(details) ) myDetails = details
    
    call output ( '============ MLS File Data Base ============', advance='yes' )
    call output ( ' ', advance='yes' )
    if ( present(name) ) then
      call output ( 'MLS File Database name: ', advance='no' )
      call output ( name, advance='yes' )
d1625 9
a1633 3
    if ( size(database) < 1 ) then
      call output ( '**** MLS File Database empty ****', advance='yes' )
      return
d1635 2
a1636 2
      call output ( 'size: ')
      call output ( size(database), advance='yes')                                
a1637 6
    if ( myDetails < -1 ) return
    do i = 1, size(database)
      call dump(database(i), details)
    end do
      
  end subroutine Dump_FileDataBase
d1639 37
a1675 1
  ! ------------------------------------------ Dump_MLSFile ------------
d1677 42
a1718 1
  subroutine Dump_MLSFile ( MLSFile, details )
d1720 6
a1725 7
    ! Dummy arguments
    type (MLSFile_T), intent(in) ::          MLSFile
    integer, intent(in), optional          :: details
    ! Local variables
    integer                          ::      myDetails
    character(len=MAXFILENAMELENGTH) ::      name
    character(len=MAXFILENAMELENGTH) ::      path
d1727 32
a1758 16
    ! Executable code
    myDetails = 0
    if ( present(details) ) myDetails = details
    call split_path_name(MLSFile%Name, Path, Name)
    if ( myDetails >  -1 ) &
      & call output ( 'MLS File Info (full name): ', advance='yes')                                  
    ! call output ( '(name) ')                                  
    call output ( trim(MLSFile%Name), advance='yes')                                  
    if ( myDetails < 0 ) return
    call output ( '    path         : ')                                
    call output ( trim(path), advance='yes')                                  
    call output ( '    name         : ')
    call output ( trim(name), advance='yes')                                  
    if ( UseSDPToolkit .and. MLSFile%shortName /= ' ' )  then
      call output ( '    short name   : ')                                
      call output ( trim(MLSFile%shortName), advance='yes')                                  
d1760 9
a1768 6
    call output ( '    Type         : ')                                
    call output ( trim(MLSFile%TypeStr), advance='yes')                                  
    if ( FILESTRINGTABLE ) then
    call output ( '    Type(int)    : ')                                
    call display_string ( lit_indices(MLSFile%Type), strip=.true.)                                  
    call output(' ', advance='yes')
d1770 1
a1770 41
    call output ( '    Access       : ')                                
    ! call output ( trim(MLSFile%accessStr), advance='yes')                                  
    call output ( trim(accessType(MLSFile%access)), advance='yes')                                  
    call output ( '    Access (int) : ')                                
    call output ( MLSFile%access, advance='yes')                                  
    call output ( '    content      : ')                                
    call output ( trim(MLSFile%content), advance='yes')                                  
    call output ( '    last Operatn : ')                                
    call output ( trim(MLSFile%lastOperation), advance='yes')                                  
    call output ( '    still open? : ')                                
    call output ( MLSFile%stillOpen, advance='yes')                                  
    if ( myDetails < 1 ) return
    call output ( '    File ID      : ')                                
    call output ( MLSFile%FileId%f_id, advance='yes')
    if ( MLSFile%FileId%grp_id > 0 ) then
      call output ( '    Group ID     : ')                              
      call output ( MLSFile%FileId%grp_id, advance='yes')                                
    endif
    if ( MLSFile%FileId%sd_id > 0 ) then
      call output ( '    DataSet ID   : ')                              
      call output ( MLSFile%FileId%sd_id, advance='yes')
    endif
    if ( UseSDPToolkit )  then
      call output ( '    PCF ID       : ')                                
      call output ( MLSFile%PCFId, advance='yes')                                
      call output ( '    PCF Range    : ')                                
      call output ( (/MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%Top /), &
        & advance='yes')                                  
    endif
    ! if ( any(MLSFile%type == (/'hdf  ', 'swath' /) ) ) then
    if ( any(MLSFile%type == (/l_hdf, l_swath, l_grid, l_zonalavg /) ) ) then
      call output ( '    hdf version  : ')                              
      call output ( MLSFile%HDFVersion, advance='yes')
    endif
    if ( MLSFile%recordLength > 0 )  then
      call output ( '    record length: ')                              
      call output ( MLSFile%recordLength, advance='yes')                                
    endif
    call output ( '    error code   : ')                                
    call output ( MLSFile%errorCode, advance='yes')                                  
  end subroutine Dump_MLSFile
d1772 74
a1845 1
  ! --------------------------------------------  split_path_name  -----
d1847 18
a1864 8
  ! This routine splits the input full_file_name
  ! into its components path and name
  ! where path may include one or more "/" or slash elements
  ! (but one must be the terminating one; e.g., 'System/')
  ! while name must have none (actually "/" comes from Machine%filsep).
  ! special cases by example: full_file_name -> (path, name)
  ! look.ma.no.slash -> (' ', 'look.ma.no.slash')
  ! Luke/I/am/your/father/ -> ('Luke/I/am/your/father/', ' ')
d1866 19
a1884 2
  ! optionally you may supply the slash divider
  ! which must be a single character
d1886 3
a1888 1
  elemental subroutine split_path_name ( full_file_name, path, name, slash )
d1890 1
a1890 1
    ! Arguments
d1892 30
a1921 1
    use Machine, only: Filsep ! / or :\
a1922 4
    character (len=*), intent(in) :: full_file_name
    character (len=*), intent(out) :: path
    character (len=*), intent(out) :: name
    character (len=1), optional, intent(in) :: slash
a1923 1
    ! Local
d1925 14
a1938 3
    character (len=1) :: mySlash
    integer :: loc, n
!   logical, parameter :: DEBUG = .false.
d1940 2
a1941 1
    ! Begin
d1943 1
a1943 1
    n = len_trim(full_file_name)
d1945 7
a1951 5
    if ( n <= 0 ) then
      path = ' '
      name = ' '
      return
    end if
d1953 9
a1961 5
    if ( present(slash) ) then
      mySlash = slash
    else
      mySlash = filsep
    end if
d1963 1
a1963 1
    loc = scan(full_file_name(:n), mySlash, back=.true.)
d1965 3
a1967 10
    if ( loc <= 0 ) then
      path = ' '
      name = adjustl(full_file_name)
    else if ( loc == n ) then
      path = adjustl(full_file_name)
      name = ' '
    else
      path = adjustl(full_file_name(:loc))
      name = adjustl(full_file_name(loc+1:))
    end if
d1969 12
a1980 1
  end subroutine split_path_name
d1982 1
a1982 1
  ! --------------------------------------------  release_MLSFile  -----
d1984 8
a1991 2
  ! This routine releases an MLSFile
  subroutine release_MLSFile
d1993 76
a2068 5
    ! Internal variables
    integer :: status
    ! Executable
    status = InitializeMLSFile( MLSFile_save )
  end subroutine release_MLSFile
d2070 1
a2070 1
  ! --------------------------------------------  reserve_MLSFile  -----
d2072 8
a2079 5
  ! This routine initializes an MLSFile
  ! so that it can be used by single-parameter functions
  ! like readnchars
  subroutine reserve_MLSFile ( full_file_name, type, access, content, &
    & shortName, hdfVersion, recordLength, PCFIdRange, PCBottom, PCTop )
d2081 1
a2081 17
    ! Arguments
    character(len=*), intent(in)           :: full_file_name
    integer, optional, intent(in)          :: type
    integer, optional, intent(in)          :: access
    character(len=*), optional, intent(in) :: content
    character(len=*), optional, intent(in) :: shortName
    integer, optional, intent(in)          :: HDFVersion
    integer, optional, intent(in)          :: recordLength
    type(Range_T), optional, intent(in)    :: PCFIdRange
    integer, optional, intent(in)          :: PCBottom ! (Instead of range_T)
    integer, optional, intent(in)          :: PCTop    ! (Instead of range_T)
    ! Internal variables
    integer :: status
    ! Executable
    status = InitializeMLSFile( MLSFile_save, type, access, content, full_file_name, &
      & shortName, HDFVersion, recordLength, PCFIdRange, PCBottom, PCTop )
  end subroutine reserve_MLSFile
d2083 7
a2089 22
  ! --------------------------------------- 1-parameter family of functions --
  ! These functions can be called to operate on MLSFile_save
  function readnchars ( n )  result( status )
    ! Tries to read n chars
    ! Args
    integer, intent(in) :: n
    integer :: status
    ! Internal variables
    character(len=n) :: chars
    ! Executable
    if ( MLSFile_save%type /= l_ascii ) &
      & call MLSMessage ( MLSMSG_Warning, moduleName,  &
         & 'Trying to readnchars from a non-ascii file' )
    call get_lun( MLSFile_save%FileID%f_id )
    open( UNIT=MLSFile_save%FileID%f_id, access='direct', recl=n, &
      & file=trim(MLSFile_save%name), status='old', iostat=status )
    if ( status /= 0 ) return
    read( UNIT=MLSFile_save%FileID%f_id, REC=1, IOSTAT=status ) chars
    close( UNIT=MLSFile_save%FileID%f_id )
  end function readnchars
  
  ! ---------------------------------------------  he2he5_fileaccess  -----
d2091 7
a2097 2
  ! This function converts hdfeos2 file access types to
  ! corresponding hdfeos5 numbers
d2099 2
a2100 1
  function he2he5_fileaccess(FileAccesshdf4) result (FileAccesshdf5)
d2102 3
a2104 1
    ! Arguments
d2106 3
a2108 6
    integer(i4), intent(IN)       :: FileAccesshdf4
    integer(i4)                   :: FileAccesshdf5
    
!    integer(i4), parameter        :: H5F_ACC_RDONLY = 0
!    integer(i4), parameter        :: H5F_ACC_RDWR   = 1
!    integer(i4), parameter        :: H5F_ACC_TRUNC  = 2
a2110 1
    select case (FileAccesshdf4)
d2112 15
a2126 2
    case(DFACC_CREATE)
      FileAccesshdf5 = HE5F_ACC_TRUNC   ! H5F_ACC_TRUNC
d2128 49
a2176 2
    case(DFACC_READ)                      ! also , DFACC_RDONLY
      FileAccesshdf5 = HE5F_ACC_RDONLY   ! H5F_ACC_RDONLY
d2178 3
a2180 2
    case default
      FileAccesshdf5 = HE5F_ACC_RDWR   ! H5F_ACC_RDWR
d2182 16
a2197 1
    end select
d2199 9
a2207 1
  end function he2he5_fileaccess
d2209 28
a2236 1
  ! ---------------------------------------------  hdf2hdf5_fileaccess  -----
d2238 1
a2238 2
  ! This function converts hdf4 file access types to
  ! corresponding hdf5 numbers
d2240 1
a2240 1
  function hdf2hdf5_fileaccess(FileAccesshdf4) result (FileAccesshdf5)
d2242 1
a2242 3
    use HDF5, only: &
     & H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, H5F_ACC_EXCL_F
    ! Arguments
d2244 8
a2251 5
    integer(i4), intent(IN)       :: FileAccesshdf4
    integer(kind(H5F_ACC_EXCL_F)) :: FileAccesshdf5
    
    ! begin
    select case (FileAccesshdf4)
d2253 1
a2253 2
    case(DFACC_CREATE)
      FileAccesshdf5 = H5F_ACC_EXCL_F  ! H5F_ACC_TRUNC_F
d2255 3
a2257 2
    case(DFACC_READ)    ! also , DFACC_RDONLY
      FileAccesshdf5 = H5F_ACC_RDONLY_F
d2259 1
a2259 2
    case default
      FileAccesshdf5 = H5F_ACC_RDWR_F
d2261 5
a2265 1
    end select
d2267 2
a2268 1
  end function hdf2hdf5_fileaccess
d2270 2
a2271 1
  ! ---------------------------------------------  mls_inqswath  -----
d2273 6
a2278 1
  ! This function acts as a wrapper to allow hdf5 or hdf4 routines to be called
d2280 1
a2280 1
  function mls_inqswath(FileName, swathList, strBufSize, hdfVersion)
d2282 14
a2295 1
    ! Arguments
a2296 4
      character (len=*), intent(in) :: FILENAME
      character (len=*), intent(out) :: SWATHLIST
      integer, intent(out):: STRBUFSIZE
      integer :: mls_inqswath
d2298 1
d2303 13
a2315 11
    ! Executable code
    if ( mls_exists(trim(FileName)) /= 0 ) then
      mls_inqswath = FILENOTFOUND
      strbufsize = FILENOTFOUND
      return
    endif
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = DEFAULT_HDFVERSION
    endif
d2318 18
a2335 9
    if(myhdfVersion == WILDCARDHDFVERSION) then
      myhdfVersion = mls_hdf_version(trim(FileName))
    endif
    if(myhdfVersion == HDFVERSION_5) then
      mls_inqswath = he5_swinqswath(trim(FileName), swathList, strBufSize)
    elseif(myhdfVersion == HDFVERSION_4) then
      mls_inqswath = swinqswath(FileName, swathList, strBufSize)
    else                          
      mls_inqswath = NOSUCHHDFVERSION  
a2336 3
    if ( strBufSize > len(swathList) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'HDF trod on my memory' )
    swathList = swathList ( 1:strBufSize )
d2338 30
a2367 1
  end function mls_inqswath
d2369 7
a2375 1
  ! ---------------------------------------------  mls_sfstart  -----
d2377 15
a2391 12
  ! This function acts as a wrapper to allow hdf5 or hdf4 routines to be called
  ! with hdf4-style FileAccess (e.g., DFACC_RDONLY)
  
  ! the logical addingMetadata optionally treats hdf5 files as hdf4-like
  ! in the sd_id returned, as required when adding metadata,
  ! by calling special toolkit function
  
  function mls_sfstart(FileName, FileAccess, hdfVersion, addingmetadata)
    use HDF5, only: h5fopen_f, h5fcreate_f
    use HDF5, only: &
     & H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, H5F_ACC_TRUNC_F
    ! Arguments
d2393 16
a2408 31
    character (len=*), intent(in) :: FILENAME
    integer(i4), intent(IN)       :: FileAccess ! (one of the hdf4 types)
    integer, optional, intent(in) :: hdfVersion
    logical, optional, intent(in) :: addingmetadata
    ! Local variables
    integer                       :: mls_sfstart
    integer                       :: returnStatus
    integer                       :: access_prp_default
    integer                       :: myhdfVersion
    integer                       :: myAccess
    logical                       :: myaddingmetadata
    
    integer, parameter :: h5p_default_f = 0
    integer, external :: PGS_MET_SFstart
    logical, parameter :: DEBUG = .false.

    ! begin
   returnStatus = 0
   myaddingmetadata = .false.
   if ( present (addingmetadata) ) myaddingmetadata = addingmetadata
   if ( DEBUG ) then
     call output ('Entering mls_sfstart with args ', advance='no')
     call output ('File name: ', advance='no')
     call output (trim(Filename), advance='no')
     call blanks (2)
     call output ('FileAccess: ', advance='no')
     call output (FileAccess, advance='no')
     if ( present(hdfVersion) ) then
       call blanks (2)
       call output ('hdfVersion: ', advance='no')
       call output (hdfVersion, advance='no')
d2410 1
a2410 3
     call blanks (2)
     call output ('adding meta data?: ', advance='no')
     call output (myaddingmetadata, advance='yes')
d2412 32
a2443 60
   if ( present(hdfVersion) ) then
     myhdfVersion = hdfVersion
   else
     myhdfVersion = DEFAULT_HDFVERSION
   endif
   if(myhdfVersion == WILDCARDHDFVERSION) then
     myhdfVersion = mls_hdf_version(trim(FileName))
   endif
   if ( myhdfVersion == HDFVERSION_4) then
     mls_sfstart = sfstart (FileName, FileAccess)
     return
   elseif ( myhdfVersion /= HDFVERSION_5) then
     mls_sfstart = WRONGHDFVERSION
     return
   endif
!   if ( PGS_MET4MLS_SF ) then
   if ( myaddingmetadata ) then
     if ( .not. HDF5_ACC_TYPES_TO_MET ) then
       myAccess = he2he5_fileaccess(FileAccess)
     elseif ( FileAccess == DFACC_RDWR ) then
       myAccess = HE5F_ACC_RDWR  ! HDF5_ACC_RDWR
     elseif ( FileAccess == DFACC_CREATE ) then
       myAccess = HE5F_ACC_TRUNC ! HDF5_ACC_CREATE
     elseif ( FileAccess == DFACC_RDONLY ) then
       myAccess = HE5F_ACC_RDONLY ! HDF5_ACC_RDONLY
     else
       myAccess = HDF5_ACC_DEFAULT
     endif
     returnStatus = PGS_MET_SFstart(trim(FileName), myAccess, mls_sfstart)
   else
     access_prp_default = h5p_default_f    ! Can't figure out what this means
     select case (FileAccess)
     case (DFACC_CREATE)
       call h5fcreate_f(trim(filename), H5F_ACC_TRUNC_F, mls_sfstart, &
         & returnStatus)
       if ( returnStatus /= 0 ) &
         & call output('Failing to create file; ' // &
         & 'perhaps you lack write permission', advance='yes')
     case (DFACC_RDWR)
       call h5fopen_f(trim(filename), H5F_ACC_RDWR_F, mls_sfstart, returnStatus)
     case (DFACC_RDONLY)
       call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, mls_sfstart, &
         & returnStatus)
     case default
       call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, mls_sfstart, &
         & returnStatus)
     end select
   endif
   if ( returnStatus /= 0 .and. myAddingMetaData) then
     call output ('Try again--PGS_MET_SFstart still unhappy; returns ')
     call output (returnStatus, advance='yes')                             
     mls_sfstart = -1                                                      
   elseif ( returnStatus /= 0) then                                            
     call output ('Try again--h5fopen_f/h5fcreate_f still unhappy; returns ')    
     call output (returnStatus, advance='yes')                             
     mls_sfstart = -1                                                      
   endif                                                                  
   if ( DEBUG ) then
     call output ('Returning from mls_sfstart an sdid: ', advance='no')
     call output (mls_sfstart, advance='yes')
d2446 2
a2447 53
  end function mls_sfstart

  ! ---------------------------------------------  mls_sfend  -----

  ! This function acts as a wrapper to allow hdf5 or hdf4 routines to be called
  ! Right now, it works for hdf4 files in general, but only for adding
  ! metadata to hdf5 files
  
  ! Therefore, when the grand unified hdf4/hdf5 interfaces are
  ! implemented this will probably need to take an added arg:
  ! the logical addingMetadata

  function mls_sfend(sdid, hdfVersion, addingMetadata)

    use HDF5, only: h5fclose_f
    ! Arguments

    integer, intent(IN)       :: sdid  
    integer :: mls_sfend            
    integer, optional, intent(in) :: hdfVersion
    logical, optional, intent(in) :: addingmetadata
    ! Local variables
    logical                       :: myaddingmetadata
    integer                       :: myhdfVersion
    integer, external :: PGS_MET_SFend
    logical, parameter :: DEBUG = .false.

    ! begin
   myaddingmetadata = .false.
   if ( present (addingmetadata) ) myaddingmetadata = addingmetadata
   if ( DEBUG ) then
     call output ('Entering mls_sfend with args ', advance='no')
     call output ('sdid: ', advance='no')
     call output (sdid, advance='no')
     call blanks (2)
     call output ('adding meta data?: ', advance='no')
     call output (myaddingmetadata, advance='yes')
   endif
   if ( present(hdfVersion) ) then
     myhdfVersion = hdfVersion
   else
     myhdfVersion = DEFAULT_HDFVERSION
   endif
   if(myhdfVersion == WILDCARDHDFVERSION) then
     ! myhdfVersion = mls_hdf_version(trim(FileName))
     call MLSMessage ( MLSMSG_Error, moduleName,  &
     & "You cannot mls_sfend a file with wildcardhdfversion w/o a file name" ) 
   endif
   if ( myhdfVersion == HDFVERSION_4) then
     mls_sfend = sfend (sdid)
     return
   elseif ( myhdfVersion /= HDFVERSION_5) then
     mls_sfend = WRONGHDFVERSION
d2450 2
a2451 12
!    mls_sfend = h5fclose_c(sdid)
!   if ( PGS_MET4MLS_SF ) then
   if ( myaddingmetadata ) then
     mls_sfend = PGS_MET_SFend(sdid)
   else
     call h5fclose_f(sdid, mls_sfend)
   endif
!    mls_sfend = 0
   if ( DEBUG ) then
     call output ('Returning from mls_sfend a status: ', advance='no')
     call output (mls_sfend, advance='yes')
   endif
d2453 8
a2460 1
  end function mls_sfend
d2462 32
a2493 1
  ! ---------------------------------------------  mls_hdf_version  -----
d2495 19
a2513 5
  ! This function returns the hdf version of the file:
  ! hdf version         returned value   integer
  !    hdf4                 hdf4           4
  !    hdf5                 hdf5           5
  !  unknown                ????      ERRORINH5FFUNCTION
d2515 22
a2536 2
  function mls_hdf_version(FileName, preferred_version, AccessType) &
   & result (hdf_version)
d2538 94
a2631 283
   use HDF5, only: h5fis_hdf5_f
   ! Arguments

    character (len=*), intent(in)  :: FILENAME                                  
   ! character (len=4)             :: hdf_version                               
    integer(i4), optional, intent(in)  :: PREFERRED_VERSION                     
    integer(i4), optional, intent(in)  :: ACCESSTYPE   ! one of the hdf4 types  
    integer(i4)                        :: HDF_VERSION                           

    integer :: returnStatus                                                     
    integer :: myPreferred_Version                                              
    integer :: myAccessType                                                     
    logical :: is_hdf5                                                          

    ! begin

    if (FileName == '') then
      HDF_VERSION = MUSTSUPPLYFILENAME
      return
    endif
    
    if ( present(preferred_version) ) then
      myPreferred_Version = preferred_version
    else
      myPreferred_Version = WILDCARDHDFVERSION
    endif
    if ( present(accesstype) ) then
      myAccessType = accesstype
    else
      myAccessType = DFACC_READ
    endif

   ! If the file is being newly created, no way to find its hdf version yet
    if ( myAccessType == DFACC_CREATE ) then
      hdf_version = myPreferred_Version
      return
    endif

    ! Does the file really, really exist?
    if ( mls_exists(trim(FileName)) /= 0 ) then
      hdf_version = FILENOTFOUND
      return
    endif
    returnStatus = 0
    is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) ! was ... == 5
    call h5fis_hdf5_f(trim(FileName), is_hdf5, returnStatus)
    if ( returnStatus /= 0 ) then
!      hdf_version = '????'
      hdf_version = ERRORINH5FFUNCTION
    elseif ( is_hdf5 ) then
!      hdf_version = 'hdf5'
      hdf_version = HDFVERSION_5       ! 5
    else
!      hdf_version = 'hdf4'
      hdf_version = HDFVERSION_4       ! 4
    endif

   ! hdf_version ==  myPreferred_Version ?
   if ( myPreferred_Version /= WILDCARDHDFVERSION &
     & .and. &
     & hdf_version /= myPreferred_Version ) then
       print *, 'file name: ', trim(FileName)
       print *, 'myPreferred_Version: ', myPreferred_Version
       print *, 'is_hdf5: ', is_hdf5
       print *, 'returnStatus: ', returnStatus
       print *, 'hdf_version: ', hdf_version
       hdf_version = WRONGHDFVERSION
       call MLSMessage (MLSMSG_Crash, ModuleName, & 
        & "Who cares?")
   endif
  end function mls_hdf_version
!-----------------------------------------------

  subroutine mls_openFileName(filename, access, file_id, hdfVersion)
! Opens vanilla hdf 4 or 5 filename for various types of access:
! 'create', 'update', or 'readonly'
! Returns file_id
! By default, hdfVersion is WILDCARDHDFVERSION meaning it autodetects
! which version to open the filename under
   use HDF5, only: h5fopen_f, h5fcreate_f, h5fis_hdf5_f
   use HDF5, only: &
     & H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, H5F_ACC_EXCL_F
!
! External Variables
!
    character(len=*), intent(in) :: filename, access
    integer, intent(in), optional :: hdfVersion
    integer(i4), intent(out) :: file_id
!
! Internal Variables
!
    integer :: error
    logical :: is_hdf5
    integer :: actual_hdfVersion

   ! Executable
   actual_hdfVersion = WILDCARDHDFVERSION
   if ( present(hdfVersion) ) actual_hdfVersion = hdfVersion
   if ( actual_hdfVersion == WILDCARDHDFVERSION ) then
     actual_hdfVersion = mls_hdf_version(filename)
   endif
   error = 0
   select case (actual_hdfVersion)
    case (HDFVERSION_4) 
     if (lowercase(trim(access)) == 'create') then
       file_id = mls_sfstart(trim(filename),DFACC_CREATE,actual_hdfVersion)
     elseif (lowercase(trim(access)) == 'update') then
       file_id = mls_sfstart(trim(filename),DFACC_RDWR,actual_hdfVersion)
     elseif (lowercase(trim(access)) == 'readonly') then
       file_id = mls_sfstart(trim(filename),DFACC_RDONLY,actual_hdfVersion)
     endif
     if (file_id .eq. -1) error = file_id 
    case (HDFVERSION_5)
      if (trim(access) == 'create') then 
          call h5fcreate_f(trim(filename), H5F_ACC_EXCL_F, file_id, error)
      elseif (trim(access) == 'update') then
          is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) 
          call h5fis_hdf5_f(trim(filename), is_hdf5, error)
       if (is_hdf5) then 
          call h5fopen_f(trim(filename), H5F_ACC_RDWR_F, file_id, error)
       endif
      elseif (trim(access) == 'readonly') then 
          is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) 
          call h5fis_hdf5_f(trim(filename), is_hdf5, error)
       if (is_hdf5) then 
          call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, file_id, error)
       endif
      else           ! same as 'update'
          is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) 
          call h5fis_hdf5_f(trim(filename), is_hdf5, error)
       if (is_hdf5) then 
          call h5fopen_f(trim(filename), H5F_ACC_RDWR_F, file_id, error)
       endif
      endif
    case default
      error = 1
    end select 

   if (error /= 0) then 
      call MLSMessage (MLSMSG_Error, ModuleName, & 
        & "Error: cannot "//lowercase(trim(access))//" file: "//trim(filename))
   endif
 
  end subroutine mls_openFileName

  subroutine mls_openFileType(MLSFile, error)
  ! Opens any kind of file for any kind of access
    type(MLSFIle_T) :: MLSFile
    integer, optional, intent(out) :: error
    !
    logical, parameter :: CASESENSITIVE = .true.
    ! integer :: FileAccessType
    integer :: ioerror
    logical :: neededPCF
    integer :: PCBottom
    integer :: PCTop
    integer :: record_length
    ! character(len=8) :: toolbox_mode
    integer :: version
    !
    if ( present(error) ) error = FILEALREADYOPEN
    if ( MLSFile%StillOpen ) return
    ! print *, 'Opening ' // trim(MLSFile%name)
    version = 1
    PCBottom = MLSFile%PCFidRange%Bottom
    PCTop = MLSFile%PCFidRange%Top
    record_length = MLSFile%recordLength
    ! call dump(MLSFile, details=1)
    ! Fill in file name if blank and we're using the toolkit panoply
    if ( MLSFile%name == ' ' ) then
      if ( .not. UseSDPToolkit ) &
        & call MLSMessage (MLSMSG_Error, ModuleName, & 
        & "blank filename  and yet no toolkit", MLSFile=MLSFile)
      if ( MLSFile%PCFidRange%Top < 1 ) &
        & call MLSMessage (MLSMSG_Error, ModuleName, & 
        & "blank filename  and yet no PCF id range", MLSFile=MLSFile)
      call GetMLSFileNameFromPCF(MLSFile, ioerror)
    endif
    ! Do we need to find the hdfVersion?
   if ( &
     & any(MLSFile%type == (/l_hdf, l_swath, l_grid, l_zonalavg /) ) .and. &
     & (MLSFile%HDFVersion == 0 .or. MLSFile%HDFVersion == WILDCARDHDFVERSION) &
     & .and. (MLSFile%name /= ' ') ) then
     ! print *, 'MLSFile%type ' , MLSFile%type
     ! print *, 'WILDCARDHDFVERSION ' , WILDCARDHDFVERSION
     MLSFile%HDFVersion = mls_hdf_version(trim(MLSFile%name))
     ! print *, 'MLSFile%HDFVersion ' , MLSFile%HDFVersion
    endif
    neededPCF = .true.

    ! If the file has already been created by this run, we don't want to
    ! clobber it or fail on open becuase it already exists
    ! Therefore, if lastoperation != "", reset access to 'rdwr'
    if ( MLSFile%access == DFACC_CREATE .and. MLSFile%lastOperation /= "" ) &
      & MLSFile%access = DFACC_RDWR
    ! if ( toolbox_mode == 'pg' .and. MLSFile%recordLength /= 0 ) then
    if ( MLSFile%type == l_tkgen .and. MLSFile%recordLength /= 0 ) then
      if( PCTop > PCBottom ) then
        ! print *, '1'
        ! MLSFile%FileId%f_id = Mls_io_gen_openF ( 'pg', CASESENSITIVE, &
        MLSFile%FileId%f_id = Mls_io_gen_openF ( l_tkgen, CASESENSITIVE, &
        & ioerror, record_length, &
        & PGSd_IO_Gen_RSeqFrm, &
        & PCBottom=PCBottom, PCTop=PCTop, &
        & inp_rec_length=MLSFile%recordLength)
      else
        ! print *, '2'
        ! print *, 'pg', CASESENSITIVE, &
        ! & ioerror, record_length, &
        ! & PGSd_IO_Gen_RSeqFrm, &
        ! & PCTop, MLSFile%recordLength
        MLSFile%FileId%f_id = Mls_io_gen_openF ( l_tkgen, CASESENSITIVE, &
        & ioerror, record_length, &
        & PGSd_IO_Gen_RSeqFrm, &
        & thePC=PCTop, inp_rec_length=MLSFile%recordLength)
        ! print *, "After iogenopen, ioerror: ", ioerror
      endif
    elseif ( MLSFile%recordLength /= 0 ) then
      ! print *, '3'
      ! MLSFile%FileId%f_id = mls_io_gen_openF(toolbox_mode, CASESENSITIVE, &
      MLSFile%FileId%f_id = mls_io_gen_openF(MLSFile%type, CASESENSITIVE, &
      & ioerror, record_length, MLSFile%access, &
      & MLSFile%Name, inp_rec_length=MLSFile%recordLength)
      neededPCF = .false.
    elseif ( .not. UseSDPToolkit ) then
      ! print *, '4'
      MLSFile%FileId%f_id = mls_io_gen_openF(MLSFile%type, CASESENSITIVE, &
      & ioerror, record_length, MLSFile%access, &
      & MLSFile%Name, hdfVersion=MLSFile%hdfVersion)
      neededPCF = .false.
    elseif( PCTop > PCBottom ) then
      ! print *, '5'
      ! print *, 'Trying to open ', trim(MLSFile%Name)
      ! print *, 'Toolbox mode ', trim(toolbox_mode)
      ! print *, 'hdf version ', MLSFile%hdfVersion
      MLSFile%FileId%f_id = mls_io_gen_openF(MLSFile%type, CASESENSITIVE, &
      & ioerror, record_length, MLSFile%access, &
      & MLSFile%Name, MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%Top, &
      & hdfVersion=MLSFile%hdfVersion)
      neededPCF = .true.
    elseif( PCTop > 0 ) then
      ! print *, '6'
      MLSFile%FileId%f_id = mls_io_gen_openF(MLSFile%type, CASESENSITIVE, &
      & ioerror, record_length, MLSFile%access, &
      & MLSFile%Name, thePC=PCTop, &
      & hdfVersion=MLSFile%hdfVersion)
      neededPCF = .true.
    else
      ! print *, '7'
      MLSFile%FileId%f_id = mls_io_gen_openF(MLSFile%type, CASESENSITIVE, &
      & ioerror, record_length, MLSFile%access, &
      & MLSFile%Name, hdfVersion=MLSFile%hdfVersion)
      neededPCF = .false.
    endif
      ! print *, 'ioerror: ', ioerror
    if ( ioerror == 0 ) then
      MLSFile%StillOpen=.true.
      ! The next matches 'hg' and 'pg'
      if ( neededPCF ) call GetMLSFilePCFidFromName(MLSFile, ioerror)
    endif
    MLSFile%errorCode = ioerror
    MLSFile%lastOperation = 'open'
    if ( present(error) ) error = ioerror
  end subroutine mls_openFileType

!-----------------------------------------------
  subroutine mls_closeFileID(file_id, filename, hdfVersion)
! Closes vanilla hdf 4 or 5 filename
! By default, hdfVersion is WILDCARDHDFVERSION meaning it autodetects
! which version to close the filename under
! so unless you supply hdfVersion, you'd better supply filename
    use HDF5, only: h5fclose_f
!
! External Variables
!
    integer(i4), intent(in) :: file_id
    character(len=*), intent(in), optional :: filename
    integer, intent(in), optional :: hdfVersion
!
! Internal Variables
!
    integer :: error
    integer :: actual_hdfVersion
d2633 6
a2638 9
    ! Executable
    actual_hdfVersion = WILDCARDHDFVERSION
    if ( present(hdfVersion) ) actual_hdfVersion = hdfVersion
    if ( actual_hdfVersion == WILDCARDHDFVERSION ) then
      if( present(filename) ) then
        actual_hdfVersion = mls_hdf_version(filename)
      else
        call MLSMessage (MLSMSG_Error, ModuleName, & 
         & "You must supply a filename to close a file with wildcardhdfversion")
a2639 9
    endif
    select case (actual_hdfVersion)
    case (HDFVERSION_4) 
       error = sfend(file_id)
    case (HDFVERSION_5) 
       call h5fclose_f(file_id, error)
    case default
       error = sfend(file_id)       
    end select 
d2641 3
a2643 3
    if (error /= 0) then 
       call MLSMessage (MLSMSG_Error, ModuleName, "Error closing file.")
    endif
d2645 10
a2654 1
  end subroutine mls_closeFileID
d2656 10
a2665 30
  subroutine mls_CloseFileType(MLSFile, error)
  ! Closes any kind of file
    type(MLSFIle_T) :: MLSFile
    integer, optional, intent(out) :: error
    !
    logical, parameter :: CASESENSITIVE = .true.
    integer :: ioerror
    integer :: PCBottom
    integer :: PCTop
    integer :: version
    !
    version = 1
    PCBottom = MLSFile%PCFidRange%Bottom
    PCTop = MLSFile%PCFidRange%Top
    if ( MLSFile%hdfVersion < 1 ) then
      ! ioerror = mls_io_gen_closeF(toolbox_mode, MLSFile%FileID%f_id)
      ioerror = mls_io_gen_closeF(MLSFile%type, MLSFile%FileID%f_id)
    else
      ! print *, 'Trying to close ', trim(MLSFile%Name)
      ! print *, 'Toolbox mode ', trim(toolbox_mode)
      ! print *, 'hdf version ', MLSFile%hdfVersion
      ! ioerror = mls_io_gen_closeF(toolbox_mode, MLSFile%FileID%f_id, &
      ioerror = mls_io_gen_closeF(MLSFile%type, MLSFile%FileID%f_id, &
       MLSFile%Name, MLSFile%hdfVersion)
    endif
    MLSFile%StillOpen=.false.
    MLSFile%errorCode = ioerror
    MLSFile%lastOperation = 'close'
    if ( present(error) ) error = ioerror
  end subroutine mls_CloseFileType
d2667 8
d2676 2
d2679 1
a2679 14
!----------------------- mls_exists
  integer function mls_exists(filename)
  ! returns 0 if file exists, FILENOTFOUND if not
  ! Argument
  character (len=*) :: filename
  ! Internal variables
  logical :: exist
  inquire(file=filename, exist=exist)
  if (exist) then
    mls_exists = 0
  else
    mls_exists = FILENOTFOUND
  endif
  end function mls_exists
d2681 15
a2695 2
  !-----------------------------------------  transfer_MLSFile  -----
  integer function transfer_MLSFile ( ITEM, path, name )
d2697 1
a2697 81
  ! This routine transforms an MLSFile, e.g. relocating its path

    ! Dummy arguments
    type (MLSFile_T)                       :: ITEM
    character(len=*), optional, intent(in) :: path
    character(len=*), optional, intent(in) :: Name
    ! Internal variables
    character(len=MAXFILENAMELENGTH) :: oldpath
    character(len=MAXFILENAMELENGTH) :: oldname

    transfer_MLSFile = 0
    if ( present(Name    ) ) item%Name  = Name
    if ( present(path) ) then
      call split_path_name(item%name, oldpath, oldname)
      ! Remember: split_path_name returns a path with a terminating '/'
      ! (unless blank)
      item%name = trim(path) // oldname
    endif   
  end function transfer_MLSFile

! ---------------------------------------------- unMaskName ------

! This function returns the name minus its masking portion
! We do this to fool the parser into thinking it's not seen
! this name before. Otherwise the parser may not preserve its case.

  function unMaskName(inName) result(outName)
  character(len=*), intent(in)     :: inName        ! Name to be unmasked
  character(len=len(inName)) :: outName             ! unmasked name
  ! Executable
  if ( len_trim(inName)  < 1 ) then
    outName = ''
  elseif (index(inName, MASKINGTAPE) < 1) then
    outName = inName
  else
    call ReplaceSubString(trim(inName), outName, MASKINGTAPE, '')
  endif
  end function unMaskName

! ---------------------------------------------- unSplitName ------

! This function returns the name minus its splitting number
! Which transforms strings like
! /long/path/MLS-Aura_L2GP-DGG16_v01-31_c01.he5
! into
! /long/path/MLS-Aura_L2GP-DGG_v01-31_c01.he5
! It assumes the split name takes one of the following forms
! (dgg)   ...L2GP-DGGnn_...
! (l2aux) ...L2AUX-DGMnn_...

  function unSplitName(inName) result(outName)
  character(len=*), intent(in)     :: inName        ! Name to be unsplit
  character(len=len(inName)) :: outName             ! unsplit name
  ! Local variables
  ! character(len=len(inName)) :: tempName
  character(len=*), parameter :: dgg_type = 'L2GP-DGG'
  character(len=*), parameter :: l2aux_type = 'L2AUX-DGM'
  character(len=*), parameter :: underscore = '_'
  character(len=16)           :: sub1
  character(len=16)           :: sub2
  character(len=8)            :: nn
  ! Executable
  outName = ''
  if ( len_trim(inName)  < 1 ) return
  ! tempName = lowerCase(inName)
  if (index(inName, dgg_type) > 0) then
    sub1 = dgg_type
  elseif (index(inName, l2aux_type) > 0) then
    sub1 = l2aux_type
  elseif (index(inName, lowerCase(dgg_type)) > 0) then
    sub1 = lowerCase(dgg_type)
  elseif (index(inName, lowerCase(l2aux_type)) > 0) then
    sub1 = lowerCase(l2aux_type)
  else
    return
  endif
  call ExtractSubString (inName, nn, trim(sub1), underscore)
  if ( len_trim(nn) < 1 ) return
  sub2 = trim(sub1) // trim(nn)
  call ReplaceSubString(trim(inName), outName, trim(sub2), trim(sub1))
  end function unSplitName
a2698 44
!-----------------------------------------------
!       Private routines
!------------------------
  subroutine GetMLSFileNameFromPCF(MLSFile, ioerror)
    type(MLSFile_T) :: MLSFile
    integer, intent(out) :: ioerror
    integer :: pcfid
    integer :: version
    ioerror = 1
    if ( MLSFile%PCFidRange%top < 1 ) return
    if ( MLSFile%PCFidRange%top < MLSFile%PCFidRange%Bottom ) return
    do pcfid = MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%top
      version = 1
      ioerror = Pgs_pc_getReference(pcfid, version, MLSFile%name)
      if ( ioerror == 0 ) return
    enddo
  end  subroutine GetMLSFileNameFromPCF
  subroutine GetMLSFilePCFidFromName(MLSFile, ioerror)
    type(MLSFile_T) :: MLSFile
    integer, intent(out) :: ioerror
    integer :: pcfid
    integer :: version
    character(len=FileNameLen) :: name
    ioerror = 1
    if ( MLSFile%PCFidRange%top < 1 ) return
    if ( MLSFile%PCFidRange%top < MLSFile%PCFidRange%Bottom ) return
    do pcfid = MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%top
      version = 1
      ioerror = Pgs_pc_getReference(pcfid, version, name)
      if ( ioerror == 0 ) then
        MLSFile%PCFID = pcfid
        if ( trim(name) == trim(MLSFile%name) ) return
      endif
    enddo
  end  subroutine GetMLSFilePCFidFromName
  elemental function strip_path(fullName) result(name)
    character(len=*), intent(in) :: fullName
    character(len=max(1, len(fullName))) :: name
    character(len=max(1, len(fullName))) :: path
    !
    name = ' '
    if ( len_trim(fullName) < 1 ) return
    call split_path_name(fullName, path, name)
  end function strip_path
d2703 1
a2703 1
       "$Id: MLSFiles.f90,v 2.84 2008/05/02 00:41:09 vsnyder Exp $"
d2707 1
d2715 3
@


2.84
log
@Delete unused symbol
@
text
@d23 1
a23 1
  use IO_STUFF, only: get_lun, read_textFile
d2703 1
a2703 1
       "$Id: MLSFiles.f90,v 2.83 2008/05/02 00:03:33 pwagner Exp $"
d2714 3
@


2.83
log
@Removed redundant procedures
@
text
@d30 1
a30 1
  use MLSStrings, only: Capitalize, LowerCase, Replace
d2703 1
a2703 1
       "$Id: MLSFiles.f90,v 2.82 2008/04/18 16:32:30 pwagner Exp $"
d2714 3
@


2.82
log
@read_textFile can return value array; optional arg maxLineLen added
@
text
@d66 1
a66 1
  & RmFileFromDataBase, split_path_name, TextFile_to_chars, &
a126 1
! TextFile_to_chars  reads a text file into a character string or array
a290 4
  interface textFile_to_Chars
    module procedure textFile_to_Chars_arr, textFile_to_Chars_sca
  end interface

a1851 29
  ! --------------------------------------------  textFile_to_Chars  -----

  ! read the contents of a text file into a character string or array

  subroutine textFile_to_Chars_arr ( textFile, value, nLines, maxLineLen )
    ! Args
    character(len=*), intent(in)  :: textFile ! path and name of text file
    character(len=*), dimension(:), intent(inout) :: value    ! its contents
    integer, optional, intent(out) :: nLines
    integer, optional, intent(in) :: maxLineLen
    ! Internal variables
    integer :: lun
    integer :: status
    ! Try to read the textfile
    call read_textFile( textFile, value, nLines, maxLineLen )
  end subroutine textFile_to_Chars_arr

  subroutine textFile_to_Chars_sca ( textFile, value, maxLineLen )
    ! Args
    character(len=*), intent(in)  :: textFile ! path and name of text file
    character(len=*), intent(out) :: value    ! its contents
    integer, optional, intent(in) :: maxLineLen
    ! Internal variables
    integer :: lun
    integer :: status
    ! Try to read the textfile
    call read_textFile( textFile, value, maxLineLen )
  end subroutine textFile_to_Chars_sca

d2703 1
a2703 1
       "$Id: MLSFiles.f90,v 2.81 2008/03/11 00:09:54 pwagner Exp $"
d2714 3
@


2.81
log
@Uses read_textFile from io_stuff
@
text
@d127 1
a127 1
! TextFile_to_chars  reads a text file into a single character string
d129 1
a129 1
! unmaskname         Recover file name from maskzed form
d292 10
a301 6
    character (len=*), parameter :: accesses = 'rdonly,write,rdwrite,create,nonhdf'
    integer, dimension(5), parameter :: accessTypes = &
      & (/ DFACC_RDONLY, DFACC_RDWR, DFACC_RDWR, DFACC_CREATE, PGSd_IO_Gen_RSeqFrm/)
    character (len=*), parameter :: hdfmodes = 'hg,sw,gd,za'
    character (len=*), parameter :: modes = 'op,hg,sw,gd,za,bin,pg'
    character (len=*), parameter :: types = 'ascii,hdf,swath,grid,zonalavg,binary,tkgen'
d406 1
a406 2
  ! This routine initializes an MLSFile, and adds it to database
  ! returning a pointer to the new entry
d727 2
d1859 14
a1872 1
  ! read the contents of a text file into a single character string
d1874 1
a1874 1
  subroutine textFile_to_Chars ( textFile, value )
d1878 1
d1883 2
a1884 2
    call read_textFile( textFile, value )
  end subroutine textFile_to_Chars
d2630 2
d2737 1
a2737 1
       "$Id: MLSFiles.f90,v 2.80 2008/02/22 21:27:15 pwagner Exp $"
d2748 3
@


2.80
log
@Added textFile_to_Chars
@
text
@d23 1
a23 1
  use IO_STUFF, only: get_lun
d1864 1
a1864 17
    call GET_LUN ( LUN )
    open(UNIT=lun, access='direct', recl=len(value), &
      & file=trim(textFile), status='old', iostat=status )
    if ( status /= 0 ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to textfile to chars--failed to open textfile' )
      return
    endif
    read(UNIT=lun, REC=1, IOSTAT=status) value
    if ( status /= 0 ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to textfile to chars--failed to read textfile' )
      return
    endif
    ! Unfortunately, a lot of null characters sneak into this
    value = Replace( value, char(0), char(32) ) ! Replace null with space
    close( UNIT=lun, iostat=status )
d2716 1
a2716 1
       "$Id: MLSFiles.f90,v 2.79 2008/01/14 23:47:16 pwagner Exp $"
d2727 3
@


2.79
log
@GetMLSFileByName sometimes failed to match; fixed
@
text
@d30 1
a30 1
  use MLSStrings, only: Capitalize, LowerCase
d66 1
a66 1
  & RmFileFromDataBase, split_path_name, &
d126 2
a128 1
! split_path_name    splits the input path/name into path and name
d1852 31
d2732 1
a2732 1
       "$Id: MLSFiles.f90,v 2.78 2007/06/21 00:49:51 vsnyder Exp $"
d2743 3
@


2.78
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d21 2
a22 2
  use intrinsic, only: l_ascii, l_binary, l_create, l_grid, l_hdf, l_open, &
    & l_rdonly, l_rdwrite, l_swath, l_tkgen, l_zonalavg, lit_indices
d30 1
a30 1
  use MLSStrings, only: Capitalize, LowerCase, streq
d299 1
d655 1
a655 1
  ! logical, dimension(size(database)) :: doTheyMatch
d658 1
a658 1
  ! character(len=8) :: streqOptions
d670 9
a678 1
    indx = findFirst( strip_path(database%name) == strip_path(name) )
a2529 2
    integer :: record_length
    character(len=8) :: toolbox_mode
d2700 1
a2700 1
       "$Id: MLSFiles.f90,v 2.77 2007/04/06 16:23:17 pwagner Exp $"
d2711 3
@


2.77
log
@Added 1st 1-parameter function, readnchars
@
text
@d520 1
a520 1
	 integer                       ::     version, returnStatus
d790 1
a790 1
    integer, parameter :: KEYWORDLEN=12			! Max length of keywords in OPEN(...)
d849 1
a849 1
          &	 caseSensitive, returnStatus, your_version, &
d1214 1
a1214 1
    integer, parameter :: KEYWORDLEN=12			! Max length of keywords in OPEN(...)
d1522 1
a1522 1
      close(unit=theFileHandle, iostat=ErrType)		
d1601 1
a1601 1
      close(unit=MLSFile%FileId%f_id, iostat=ErrType)		
d2693 1
a2693 1
       "$Id: MLSFiles.f90,v 2.76 2007/02/06 17:55:14 pwagner Exp $"
d2704 3
@


2.76
log
@Added transfer_MLSFile to change path of an MLSFile
@
text
@d23 1
d28 1
a28 1
    & MLSMSG_DeAllocate, MLSMSG_Crash, MLSMSG_Error
d64 2
a65 1
  & open_MLSFile, transfer_MLSFile, &
d67 1
a67 1
  & unMaskName, unSplitName
d111 1
a111 1
! InitializeMLSFile  Initializes and MLSFile
d122 3
d298 2
a418 1
    ! character(len=*), optional, intent(in) :: type
a420 1
    ! character(len=*), optional, intent(in) :: access
a1234 11
!     select case (MLSFile%access)
!     case('rdonly')
!       FileAccessType = DFACC_RDONLY
!     case('write')
!       FileAccessType = DFACC_CREATE
!     case('rdwrite')
!       FileAccessType = DFACC_RDWR
!     case default
!       FileAccessType = DFACC_RDWR
! 
!     end select
a1255 1
    ! case('swath')
a1265 1
    ! case('grid')
a1275 1
    ! case('hdf')
a1285 1
    ! case('ascii', 'binary')
a1308 1
      ! if ( MLSFile%Type == 'binary' ) then
d1842 58
d2693 1
a2693 1
       "$Id: MLSFiles.f90,v 2.75 2007/01/11 20:41:20 vsnyder Exp $"
d2704 3
@


2.75
log
@Remove get_free_lun, use Get_Lun, handle record length for sequential files
@
text
@d63 1
a63 1
  & open_MLSFile, &
d121 1
d2515 23
d2646 1
a2646 1
       "$Id: MLSFiles.f90,v 2.74 2006/09/21 18:45:52 pwagner Exp $"
d2657 3
@


2.74
log
@Fix bug causing PCFid-equipped inquiries to complain about missing filenames
@
text
@d56 1
a56 1
  & get_free_lun, GetMLSFileByName, GetMLSFileByType, GetPCFromRef, &
a105 1
! get_free_lun       Gets a free logical unit number
a637 15
! ---------------------------------------------- get_free_lun ------

! This function returns a free logical unit number

  INTEGER(i4) FUNCTION get_free_lun()
  LOGICAL :: exist                    ! Flag from inquire
  LOGICAL :: opened                   ! Flag from inquire
  DO get_free_lun = bottom_unit_num, top_unit_num
    INQUIRE(UNIT=get_free_lun, EXIST=exist, OPENED=opened)
    IF(exist .and. .not. opened) EXIT
  END DO
  IF (opened .or. .not. exist) CALL MLSMessage ( MLSMSG_Error, moduleName,  &
     "No logical unit numbers available" )
  END FUNCTION get_free_lun

d758 2
a787 1
    logical       :: tiedup
d1111 2
a1112 10
      tiedup = .true.

      do unit = bottom_unit_num, top_unit_num
      	inquire ( unit=unit, opened=tiedup )
        if (.not. tiedup) then
          exit
        endif
      enddo

      if(tiedup) then
d1192 2
a1209 1
    logical       :: tiedup
d1220 4
a1223 5
      elseif ( MLSFile%Name /= '' ) then
          MLSFile%PCFId = GetPCFromRef(trim(MLSFile%Name), PCBottom, PCTop, &
            &  caseSensitive, returnStatus, version, &
            & debugOption=.false.)

d1225 1
a1225 1
        CALL MLSMessage ( MLSMSG_Error, moduleName,  &
d1227 2
a1228 2
      endif
    endif
d1324 2
a1325 10
      tiedup = .true.

      do unit = bottom_unit_num, top_unit_num
      	inquire ( unit=unit, opened=tiedup )
        if (.not. tiedup) then
          exit
        endif
      enddo

      if(tiedup) then
d1327 1
a1327 1
      endif
d1334 13
a1346 5
        open(unit=unit, recl=inp_rec_length, form=form, &
          & status=status, file=trim(MLSFile%Name), iostat=ErrType)
      elseif(access /= 'direct') then
        open(unit=unit, access=access, action=action, form=form, &
          & position=position, status=status, file=trim(MLSFile%Name), iostat=ErrType)
d1348 3
a1350 3
        open(unit=unit, access=access, action=action, form=form, &
          & status=status, file=trim(MLSFile%Name), iostat=ErrType)
      endif
d2622 1
a2622 1
       "$Id: MLSFiles.f90,v 2.73 2006/04/11 23:15:34 pwagner Exp $"
d2633 3
@


2.73
log
@Disclose whether MLSFile still open as part of default dump
@
text
@d27 1
a27 1
    & MLSMSG_DeAllocate, MLSMSG_Error
d893 10
d2244 2
d2344 1
a2344 1
    ! call dump(MLSFile)
d2359 1
a2359 1
     & ) then
a2360 1
     ! print *, 'MLSFile%HDFVersion ' , MLSFile%HDFVersion
d2363 1
d2645 1
a2645 1
       "$Id: MLSFiles.f90,v 2.72 2006/02/21 19:07:58 pwagner Exp $"
d2656 3
@


2.72
log
@Removed references to unused stuff
@
text
@d1770 2
a1798 2
    call output ( '    Open?        : ')                                
    call output ( MLSFile%StillOpen, advance='yes')                                  
d2633 1
a2633 1
       "$Id: MLSFiles.f90,v 2.71 2005/12/21 18:44:08 pwagner Exp $"
d2644 3
@


2.71
log
@Added AreTheSameFile; not clever yet, should consider paths, etc
@
text
@a30 1
    & GetStringHashElement, GetIntHashElement, &
a2330 6
!     call GetStringHashElement (types, &
!       & modes, trim(MLSFile%type), &
!       & toolbox_mode, .false.)
!     FileAccessType = GetIntHashElement (accesses, &
!       & accessTypes, trim(MLSFile%access), ioerror, &
!       & .false.)
a2490 3
!     call GetStringHashElement (types, &
!       & modes, trim(MLSFile%type), &
!       & toolbox_mode, .false.)
d2633 1
a2633 1
       "$Id: MLSFiles.f90,v 2.70 2005/10/18 23:03:32 pwagner Exp $"
d2644 3
@


2.70
log
@Interface to GetMLSFileByName allows ignoring path
@
text
@d54 1
a54 1
  & AddInitializeMLSFile, &
d102 1
d159 1
d173 1
d390 15
d2643 1
a2643 1
       "$Id: MLSFiles.f90,v 2.69 2005/08/09 00:00:10 pwagner Exp $"
d2654 3
@


2.69
log
@Mistake to call sortarray from GetPCFFromRef with same nameArray in both positions--fixed
@
text
@d174 1
a174 1
! MLSFile *GetMLSFileByName (MLSFile *dataBase(:), char* name, [log part_match])
d641 1
a641 1
  function GetMLSFileByName(database, name, part_match) result(item)
d645 1
a645 1
  logical, optional, intent(in)          :: part_match
d647 1
a647 1
  logical, dimension(size(database)) :: doTheyMatch
d649 2
a650 2
  logical :: myPart_match
  character(len=8) :: streqOptions
d655 3
a657 3
  myPart_match = .false.
  if ( present(part_match) ) myPart_match = part_match
  if ( .not. myPart_match ) then
d660 3
a662 3
    streqOptions = '-ps' ! Enabling partial match, and returning the shortest
    doTheyMatch = streq(database%name, name, streqOptions)
    indx = findFirst(doTheyMatch)
d871 2
d875 1
a875 1
   else
d889 3
d907 3
d988 2
a989 1
      
d1800 1
a1800 1
  subroutine split_path_name ( full_file_name, path, name, slash )
d2310 1
d2333 9
a2341 4
    ! if ( index(hdfmodes, trim(toolbox_mode)) > 0 .and. &
   if ( any(MLSFile%type == (/l_hdf, l_swath, l_grid, l_zonalavg /) ) .and. &
      & (MLSFile%HDFVersion == 0 .or. MLSFile%HDFVersion == WILDCARDHDFVERSION) ) &
      & MLSFile%HDFVersion = mls_hdf_version(trim(MLSFile%name))
d2612 9
d2625 1
a2625 1
       "$Id: MLSFiles.f90,v 2.68 2005/06/29 17:56:24 pwagner Exp $"
d2636 3
@


2.68
log
@FILESTRINGTABLE utilized to prevent tools from segment faulting
@
text
@d487 1
a487 2
    character (LEN=BareFNLen), dimension(:), allocatable &
     &                                :: nameArray
a489 1
    character (LEN=*), parameter      :: UNASSIGNEDFILENAME = '*'
d491 3
d495 3
a498 2
    integer                       ::     numberPCs
    logical ::                            debug
d500 1
d543 2
a544 1
    Allocate(nameArray(numberPCs), intArray(numberPCs), STAT=ErrType)
d578 2
a579 1
    call SortArray(nameArray, intArray, caseSensitive, &
d619 1
a619 1
    Deallocate(nameArray, intArray)
d2601 1
a2601 1
       "$Id: MLSFiles.f90,v 2.67 2005/06/22 17:25:49 pwagner Exp $"
d2612 3
@


2.67
log
@Reworded Copyright statement, moved rcs id
@
text
@d70 1
a70 1
       "$RCSfile: $"
d199 5
d443 1
a443 1
    if ( item%type > 0 ) &
d877 1
d880 1
d1725 1
d1729 1
d2596 1
a2596 1
       "$Id: $"
d2607 3
@


2.66
log
@Stopped some unnecessary printing
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d68 1
a68 3
  !------------------- RCS Ident Info -----------------------
  character(LEN=130) :: Id = &
    "$Id: MLSFiles.f90,v 2.65 2005/06/14 20:32:09 pwagner Exp $"
d70 1
a70 1
    "$RCSfile: MLSFiles.f90,v $"
d72 1
a72 1
  !----------------------------------------------------------
d2585 5
d2598 3
@


2.65
log
@Many changes to accommodate the new fields in MLSFile_T
@
text
@d62 1
a62 1
    "$Id: MLSFiles.f90,v 2.64 2005/06/03 23:58:04 pwagner Exp $"
d787 1
d807 1
a807 1
      if ( debug .or. .true. ) then
d861 1
a861 1
   if ( debug .or. .true. ) then
d2587 3
@


2.64
log
@Extra check on indx in GetMLSFileByType; added AddInitializeMLSFile
@
text
@d13 2
d40 1
d45 3
a47 1
  public :: AddFileToDataBase, AddInitializeMLSFile, close_MLSFile, &
d50 2
a51 1
  & InitializeMLSFile, maskName, &
d62 1
a62 1
    "$Id: MLSFiles.f90,v 2.63 2005/05/31 17:50:20 pwagner Exp $"
d93 3
a95 1
! AddFileToDataBase  Enters a FileName, id, etc. into the database
d100 3
d104 1
a104 1
! get_free_lun       Gets a free logical unit number
d111 1
a111 1
! mls_openFile       Opens an hdf5 file
d118 1
a118 1
! unsplitname        Split FIle name -> catenated: '..DGG13..' -> 'DGG'
d147 35
d253 5
d282 44
d346 2
a347 1
    & HDFVersion, recordLength, PCFIdRange, PCBottom, PCTop ) result(item)
d355 3
a357 2
    character(len=*), optional, intent(in) :: type
    character(len=*), optional, intent(in) :: access
d360 1
d371 1
a371 1
    & HDFVersion, recordLength, PCFIdRange, PCBottom, PCTop )
d378 1
a378 1
    & HDFVersion, recordLength, PCFIdRange, PCBottom, PCTop )
d384 4
a387 2
    character(len=*), optional, intent(in) :: type
    character(len=*), optional, intent(in) :: access
d390 1
d398 2
d407 1
a407 2
    item%type        = ""
    item%access      = ""
d410 1
d420 1
d426 8
d660 2
a661 1
  character(len=*), optional, intent(in)   :: type
d734 2
a735 1
  function mls_io_gen_openF(toolbox_mode, caseSensitive, ErrType, &
d745 3
a747 2
    character (LEN=*), intent(IN) :: toolbox_mode
    integer(i4), intent(IN)       :: FileAccessType
d771 2
a772 1
    character (LEN=2) :: the_eff_mode
d797 1
d799 1
a799 1
    the_eff_mode = LowerCase(toolbox_mode(1:2))
d806 1
a806 1
      if ( debug ) then
d821 2
a822 1
      if(LowerCase(toolbox_mode(1:2)) == 'pg') then
d847 3
a849 2
      the_eff_mode = LowerCase(toolbox_mode(1:2))
      if(the_eff_mode == 'pg') the_eff_mode = 'op'
d853 2
a854 1
   if (the_eff_mode == 'pg' .or. the_eff_mode == 'op' ) then
d860 1
a860 1
   if ( debug ) then
d865 2
d892 2
a893 1
    case('pg')
d901 2
a902 1
    case('sw')
d934 2
a935 1
    case('gd')
d954 2
a955 1
    case('hg')
d976 2
a977 1
    case('op')
d979 2
a980 1
      if(FileAccessType == PGSd_IO_Gen_RSeqFrm) then
d986 1
a986 1
      elseif(FileAccessType == PGSd_IO_Gen_RSeqUnf) then
d992 1
a992 1
      elseif(FileAccessType == PGSd_IO_Gen_RDirFrm) then
d998 1
a998 1
      elseif(FileAccessType == PGSd_IO_Gen_RDirUnf) then
d1004 1
a1004 2

      elseif(FileAccessType == PGSd_IO_Gen_WSeqFrm) then
d1010 1
a1010 1
      elseif(FileAccessType == PGSd_IO_Gen_WSeqUnf) then
d1016 1
a1016 1
      elseif(FileAccessType == PGSd_IO_Gen_WDirFrm) then
d1022 1
a1022 1
      elseif(FileAccessType == PGSd_IO_Gen_WDirUnf) then
d1028 1
a1028 2

      elseif(FileAccessType == PGSd_IO_Gen_USeqFrm) then
d1034 1
a1034 1
      elseif(FileAccessType == PGSd_IO_Gen_USeqUnf) then
d1040 1
a1040 1
      elseif(FileAccessType == PGSd_IO_Gen_UDirFrm) then
d1046 1
a1046 1
      elseif(FileAccessType == PGSd_IO_Gen_UDirUnf) then
d1052 1
a1052 2

      elseif(FileAccessType == PGSd_IO_Gen_ASeqFrm) then
d1058 1
a1058 1
      elseif(FileAccessType == PGSd_IO_Gen_ASeqUnf) then
d1064 1
a1064 2

      else
d1069 1
a1069 1
      endif
d1169 1
a1169 1
    integer(i4)       :: FileAccessType
d1197 11
a1207 11
    select case (MLSFile%access)
    case('rdonly')
      FileAccessType = DFACC_RDONLY
    case('write')
      FileAccessType = DFACC_CREATE
    case('rdwrite')
      FileAccessType = DFACC_RDWR
    case default
      FileAccessType = DFACC_RDWR

    end select
d1211 2
a1212 1
    case('asc-tk', 'bin-tk')
d1226 1
a1226 1
      ErrType = PGS_IO_Gen_OpenF(MLSFile%PCFId, FileAccessType, record_length, &
d1229 2
a1230 1
    case('swath')
d1233 1
a1233 1
          & he2he5_fileaccess(FileAccessType))
d1235 1
a1235 1
         MLSFile%FileId%f_id = swopen(trim(MLSFile%Name), FileAccessType)
d1240 2
a1241 1
    case('grid')
d1244 1
a1244 1
          & he2he5_fileaccess(FileAccessType))
d1246 1
a1246 1
        MLSFile%FileId%f_id = gdopen(trim(MLSFile%Name), FileAccessType)
d1251 2
a1252 1
    case('hdf')
d1255 1
a1255 1
          & FileAccessType, HDFVERSION_5)
d1257 1
a1257 1
        MLSFile%FileId%f_id = sfstart(trim(MLSFile%Name), FileAccessType)
d1262 3
a1264 2
    case('ascii', 'binary')
      if(FileAccessType == DFACC_RDONLY) then
d1270 1
a1270 1
      elseif(FileAccessType == DFACC_CREATE) then
d1276 1
a1276 1
      elseif(FileAccessType == DFACC_RDWR) then
d1286 2
a1287 1
      if ( MLSFile%Type == 'binary' ) then
d1331 1
a1331 1
        call io_error('io error in MLSFiles: mls_io_gen_openF' // &
d1365 2
a1366 1
  function mls_io_gen_closeF( toolbox_mode, theFileHandle, &
d1374 2
a1375 1
    character (LEN=*), intent(IN)   :: toolbox_mode
d1386 2
a1387 1
    character (LEN=2) :: the_eff_mode
d1396 1
d1399 1
a1399 1
    the_eff_mode = LowerCase(toolbox_mode(1:2))
d1402 3
a1404 2
      the_eff_mode = LowerCase(toolbox_mode(1:2))
      if(the_eff_mode == 'pg') the_eff_mode = 'cl'
d1427 3
d1431 5
a1435 1
   if (the_eff_mode == 'pg' .or. the_eff_mode == 'cl' ) then
d1457 2
a1458 1
    case('pg')
d1461 2
a1462 1
    case('sw')
d1478 2
a1479 1
    case('gd')
d1488 2
a1489 1
    case('hg')
d1498 2
a1499 1
    case('cl')
d1543 2
a1544 1
    case('asc-tk', 'bin-tk', 'tkgen')
d1547 2
a1548 1
    case('swath')
d1557 2
a1558 1
    case('grid')
d1567 2
a1568 1
    case('hdf')
d1577 2
a1578 1
    case('ascii', 'binary')
d1586 1
a1586 1
        call io_error('io error in MLSFiles: mls_io_gen_closeF' // &
d1646 1
a1646 1
  subroutine Dump_FileDataBase ( database, Name )
d1649 1
a1649 1
    type (MLSFile_T), intent(in) ::          database(:)
d1651 1
d1655 4
d1669 3
d1673 1
d1675 1
a1675 1
      call dump(database(i))
d1682 1
a1682 1
  subroutine Dump_MLSFile ( MLSFile )
d1686 5
d1693 6
a1698 2
    call output ( 'MLS File Info: ')                                  
    call output ( '(name) ')                                  
d1700 9
d1710 4
a1713 1
    call output ( trim(MLSFile%Type), advance='yes')                                  
d1715 4
a1718 1
    call output ( trim(MLSFile%access), advance='yes')                                  
d1721 3
d1725 25
a1749 14
    call output ( MLSFile%FileId%f_id, advance='yes')                                  
    call output ( '    Group ID     : ')                                
    call output ( MLSFile%FileId%grp_id, advance='yes')                                  
    call output ( '    DataSet ID   : ')                                
    call output ( MLSFile%FileId%sd_id, advance='yes')                                  
    call output ( '    PCF ID       : ')                                
    call output ( MLSFile%PCFId, advance='yes')                                  
    call output ( '    PCF Range    : ')                                
    call output ( (/MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%Top /), &
      & advance='yes')                                  
    call output ( '    hdf version  : ')                                
    call output ( MLSFile%HDFVersion, advance='yes')                                  
    call output ( '    record length  : ')                                
    call output ( MLSFile%recordLength, advance='yes')                                  
d1752 2
d2181 1
d2184 1
d2269 1
a2269 1
    integer :: FileAccessType
d2275 1
a2275 1
    character(len=8) :: toolbox_mode
d2283 6
a2288 6
    call GetStringHashElement (types, &
      & modes, trim(MLSFile%type), &
      & toolbox_mode, .false.)
    FileAccessType = GetIntHashElement (accesses, &
      & accessTypes, trim(MLSFile%access), ioerror, &
      & .false.)
a2299 2
      ! print *, "Got file name from PCF: ", trim(MLSFile%name)
      ! print *, "toolbox_mode: ", trim(toolbox_mode)
d2302 2
a2303 1
    if ( index(hdfmodes, trim(toolbox_mode)) > 0 .and. &
d2307 8
a2314 1
    if ( toolbox_mode == 'pg' .and. MLSFile%recordLength /= 0 ) then
d2317 2
a2318 1
        MLSFile%FileId%f_id = Mls_io_gen_openF ( 'pg', CASESENSITIVE, &
d2329 1
a2329 1
        MLSFile%FileId%f_id = Mls_io_gen_openF ( 'pg', CASESENSITIVE, &
d2336 4
a2339 3
        ! print *, '3'
      MLSFile%FileId%f_id = mls_io_gen_openF(toolbox_mode, CASESENSITIVE, &
      & ioerror, record_length, FileAccessType, &
d2342 6
d2349 6
a2354 3
        ! print *, '4'
      MLSFile%FileId%f_id = mls_io_gen_openF(toolbox_mode, CASESENSITIVE, &
      & ioerror, record_length, FileAccessType, &
d2359 3
a2361 3
        ! print *, '5'
      MLSFile%FileId%f_id = mls_io_gen_openF(toolbox_mode, CASESENSITIVE, &
      & ioerror, record_length, FileAccessType, &
d2366 3
a2368 3
        ! print *, '6'
      MLSFile%FileId%f_id = mls_io_gen_openF(toolbox_mode, CASESENSITIVE, &
      & ioerror, record_length, FileAccessType, &
d2372 1
a2372 1
    ! print *, 'ioerror: ', ioerror
d2378 2
d2444 3
a2446 3
    call GetStringHashElement (types, &
      & modes, trim(MLSFile%type), &
      & toolbox_mode, .false.)
d2448 2
a2449 1
      ioerror = mls_io_gen_closeF(toolbox_mode, MLSFile%FileID%f_id)
d2451 5
a2455 1
      ioerror = mls_io_gen_closeF(toolbox_mode, MLSFile%FileID%f_id, &
d2459 2
a2534 1
  ! print *, 'sub1: ', trim(sub1)
a2535 1
  ! print *, 'nn: ', trim(nn)
a2537 1
  ! print *, 'sub2: ', trim(sub2)
a2538 1
  ! print *, 'outName: ', trim(outName)
a2564 1
    ! print *, 'Bottom, top ', MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%Top
a2569 1
      ! print *, pcfid, ioerror, trim(name)
d2586 3
@


2.63
log
@Began switch from passing file handles to passing MLSFiles
@
text
@d42 2
a43 1
  public :: AddFileToDataBase, close_MLSFile, Deallocate_filedatabase, Dump, &
d56 1
a56 1
    "$Id: MLSFiles.f90,v 2.62 2005/01/07 00:36:51 vsnyder Exp $"
d249 29
d571 1
a571 1
  if ( indx > 0 ) item => database(indx)
d2363 3
@


2.62
log
@Remove unused declarations
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d14 2
a15 1
  use MLSCommon, only: i4, BareFNLen, MLSFile_T
d18 2
a19 1
  use MLSStrings, only: Capitalize, LowerCase
d21 1
d42 10
a51 6
  public :: AddFileToDataBase, GetPCFromRef, get_free_lun, mls_io_gen_openF, &
  & mls_io_gen_closeF, split_path_name, RmFileFromDataBase, &
  & mls_hdf_version, mls_inqswath, mls_sfstart, mls_sfend, &
  & mls_openFile, mls_closeFile, MLSFile_T, Deallocate_filedatabase, &
  & open_MLSFile, close_MLSFile, Dump, mls_exists, &
  & maskName, unMaskName, unSplitName
d55 1
a55 1
    "$Id: MLSFiles.f90,v 2.61 2004/10/13 00:50:32 vsnyder Exp $"
d167 1
d172 1
a172 1
  integer, parameter, public :: MUSTSUPPLYFILENAME=NOSUCHHDFVERSION+1
d211 17
a227 15
! The following data type was moved to MLSCommon in an attempt to code around
! Lahey's compiler that can cause compile times to exceed mission lifetime
! >   ! Information describing the files used by the mls software
! >   ! Stop passing file handles back & forth bewteen routines
! >   ! -- pass one of these instead
! >   TYPE MLSFile_T
! >     CHARACTER (LEN=8) :: Type=""  ! e.g., 'ascii', 'hdf', 'swath', 'binary'
! >     CHARACTER (LEN=8) :: access=""  ! e.g., 'rdonly', 'write', 'rdwrite'
! >     CHARACTER (LEN=8) :: content=""  ! e.g., 'l1brad', 'l2gp', 'l2aux'
! >     CHARACTER (LEN=FileNameLen) :: Name=""  ! its name (usu. w/path)
! >     INTEGER :: File_Id=0     ! The HDF ID (handle) or io unit for the file
! >     INTEGER :: PCF_Id=0      ! The PCF ID (ref), if any,  for the file
! >     INTEGER :: HDFVersion=0  ! Which hdf version is the file if hdf(eos)
! >     LOGICAL :: StillOpen=.false.
! >   END TYPE MLSFile_T
d248 46
d479 66
d1030 2
a1031 2
      if ( MLSFile%PCF_Id > 0 ) then
        returnStatus = Pgs_pc_getReference(MLSFile%PCF_Id, version, &
d1034 1
a1034 1
          MLSFile%PCF_Id = GetPCFromRef(trim(MLSFile%Name), PCBottom, PCTop, &
d1059 2
a1060 2
      if ( MLSFile%PCF_Id > 0 ) then
        returnStatus = Pgs_pc_getReference(MLSFile%PCF_Id, version, &
d1063 1
a1063 1
          MLSFile%PCF_Id = GetPCFromRef(trim(MLSFile%Name), PCBottom, PCTop, &
d1071 2
a1072 2
      ErrType = PGS_IO_Gen_OpenF(MLSFile%PCF_Id, FileAccessType, record_length, &
          & MLSFile%File_id, version)
d1076 1
a1076 1
        MLSFile%File_Id = he5_swopen(trim(MLSFile%Name), &
d1079 1
a1079 1
         MLSFile%File_Id = swopen(trim(MLSFile%Name), FileAccessType)
d1086 1
a1086 1
        MLSFile%File_Id = he5_gdopen(trim(MLSFile%Name), &
d1089 1
a1089 1
        MLSFile%File_Id = gdopen(trim(MLSFile%Name), FileAccessType)
d1096 1
a1096 1
        MLSFile%File_Id = mls_sfstart(trim(MLSFile%Name), &
d1099 1
a1099 1
        MLSFile%File_Id = sfstart(trim(MLSFile%Name), FileAccessType)
d1174 1
a1174 1
        MLSFile%File_Id = unit
d1366 2
a1367 2
    case('asc-tk', 'bin-tk')
      ErrType = PGS_IO_Gen_CLoseF(MLSFile%File_Id)
d1371 1
a1371 1
        ErrType = he5_swclose(MLSFile%File_Id)
d1373 1
a1373 1
        ErrType = swclose(MLSFile%File_Id)
d1380 1
a1380 1
        ErrType = he5_gdclose(MLSFile%File_Id)
d1382 1
a1382 1
        ErrType = gdclose(MLSFile%File_Id)
d1389 1
a1389 1
        call h5fclose_f(MLSFile%File_Id, ErrType)
d1391 1
a1391 1
        ErrType = sfend(MLSFile%File_Id)
d1397 1
a1397 1
      close(unit=MLSFile%File_Id, iostat=ErrType)		
d1401 1
a1401 1
        call output(  MLSFile%File_Id, advance='yes')
d1507 5
a1511 1
    call output ( MLSFile%File_Id, advance='yes')                                  
d1513 4
a1516 1
    call output ( MLSFile%PCF_Id, advance='yes')                                  
d1519 2
a1783 1
       ! call mls_openFile(filename, 'create', mls_sfstart, HDFVERSION_5)
a1785 1
       ! call mls_openFile(filename, 'update', mls_sfstart, HDFVERSION_5)
a1788 1
       ! call mls_openFile(filename, 'readonly', mls_sfstart, HDFVERSION_5)
a1791 1
       ! call mls_openFile(filename, 'readonly', mls_sfstart, HDFVERSION_5)
d1958 1
a1958 1
  subroutine mls_openFile(filename, access, file_id, hdfVersion)
d2020 1
a2020 8
! >      if (lowercase(trim(access)) == 'create') then 
! >        file_id = mls_sfstart(trim(filename),DFACC_CREATE,hdfVersion)
! >      elseif (lowercase(trim(access)) == 'update') then
! >        file_id = mls_sfstart(trim(filename),DFACC_RDWR,hdfVersion)
! >      elseif (lowercase(trim(access)) == 'readonly') then
! >        file_id = mls_sfstart(trim(filename),DFACC_RDONLY,hdfVersion)
! >      endif
! >      if (file_id .eq. -1) error = file_id 
d2025 1
a2025 1
           "Error: cannot "//lowercase(trim(access))//" file: "//trim(filename))
d2028 102
a2129 1
  end subroutine mls_openFile
d2132 1
a2132 1
  subroutine mls_closeFile(file_id, filename, hdfVersion)
d2174 33
a2206 1
  end subroutine mls_closeFile
d2289 34
d2333 3
@


2.61
log
@Remove USE for Reverse, which isn't used
@
text
@d14 1
a14 1
  use MLSCommon, only: i4, BareFNLen, FileNameLen, MLSFile_T
d16 1
a16 1
    & MLSMSG_DeAllocate, MLSMSG_Error, MLSMSG_Warning
a21 1
    & HDF5_ACC_CREATE, HDF5_ACC_RDONLY, HDF5_ACC_RDWR,  &
d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.60 2004/10/09 02:46:09 vsnyder Exp $"
a898 1
    integer(i4) :: myPC
d1349 1
a1349 1
    integer :: i, dim
d1496 1
a1496 1
     & H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, H5F_ACC_TRUNC_F, H5F_ACC_EXCL_F
d1576 1
a1576 1
     & H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, H5F_ACC_TRUNC_F, H5F_ACC_EXCL_F
d1839 1
a1839 1
     & H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, H5F_ACC_TRUNC_F, H5F_ACC_EXCL_F
d2046 3
@


2.60
log
@Simplify split_file_name.  It doesn't work anyway if len(full_file_name) >
MAXFILENAMELENGTH.
@
text
@d17 1
a17 2
  use MLSStrings, only: Capitalize, LowerCase, &
    & Reverse
d49 1
a49 1
    "$Id: MLSFiles.f90,v 2.59 2004/08/04 23:19:01 pwagner Exp $"
d2048 4
@


2.59
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d50 1
a50 1
    "$Id: MLSFiles.f90,v 2.58 2004/02/05 23:29:16 pwagner Exp $"
d1397 1
a1397 1
  ! ---------------------------------------------  split_path_name  -----
d1403 1
a1403 1
  ! while name must have none
d1411 1
a1411 1
  subroutine split_path_name(full_file_name, path, name, slash)
d1415 2
d1425 1
a1425 2
    character (len=MAXFILENAMELENGTH) :: mirrored_ffn
    integer :: loc
d1430 1
a1430 5
    if(present(slash)) then
      mySlash = slash
    else
      mySlash = '/'
    endif
d1432 1
a1432 1
    if(len(full_file_name) <= 0) then
d1436 7
a1442 1
    endif
d1444 1
a1444 3
    mirrored_ffn = Reverse(full_file_name)
    loc = index(mirrored_ffn, mySlash)
    
d1446 1
a1446 1
    if(loc <= 0) then
d1449 1
a1449 1
    elseif(loc == 1) then
d1453 3
a1455 3
      path = adjustl(Reverse(mirrored_ffn(loc:)))
      name = adjustl(Reverse(mirrored_ffn(:loc-1)))
    endif
d2049 3
@


2.58
log
@Extra debugging when appropriate
@
text
@d17 4
a20 2
  use MLSStrings, only: Capitalize, ExtractSubString, LowerCase, &
    & ReplaceSubString, Reverse, SortArray
d50 1
a50 1
    "$Id: MLSFiles.f90,v 2.57 2004/01/27 21:34:57 pwagner Exp $"
d2048 3
@


2.57
log
@Fixed bugs in unSplitName
@
text
@d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.56 2004/01/23 01:13:11 pwagner Exp $"
d1084 2
a1085 2
  function mls_io_gen_closeF(toolbox_mode, theFileHandle, &
    & FileName, hdfVersion) &
d1096 1
d1099 1
d1107 5
d1121 20
d1146 7
d1170 7
d1822 6
a1827 3
     & hdf_version /= myPreferred_Version ) &
     & hdf_version = WRONGHDFVERSION

d2046 3
@


2.56
log
@Added unSplitName
@
text
@d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.55 2004/01/22 00:44:02 pwagner Exp $"
d1945 4
d1957 4
a1960 4
  character(len=len(inName)) :: tempName
  character(len=*), parameter :: dgg_type = 'l2gp-dgg'
  character(len=*), parameter :: l2aux_type = 'l2aux-dgm'
  character(len=*), parameter :: sub2 = '_'
d1962 1
d1967 2
a1968 2
  tempName = lowerCase(inName)
  if (index(tempName, dgg_type) > 0) then
d1970 1
a1970 1
  elseif (index(tempName, l2aux_type) > 0) then
d1972 4
d1979 3
a1981 1
  call ExtractSubString (tempName, nn, trim(sub1), sub2)
d1983 4
a1986 1
  call ReplaceSubString(trim(inName), outName, trim(nn), '')
d2002 3
@


2.55
log
@Added (un)maskName
@
text
@d6 1
a6 1
  !===============================================================================
d17 2
a18 2
  use MLSStrings, only: Capitalize, LowerCase, ReplaceSubString, &
    & Reverse, SortArray
d44 1
a44 1
  & maskName, unMaskName
d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.54 2004/01/21 18:54:54 livesey Exp $"
d99 1
d425 1
a425 1
! This function returns a free logical unit number
d1927 1
a1927 1
! This function returns a free logical unit number
d1930 2
a1931 2
  character(len=*), intent(in)     :: inName        ! Name to be masked
  character(len=len(inName)) :: outName       ! masked name
d1942 33
d1988 3
@


2.54
log
@Typo!
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d17 2
a18 1
  use MLSStrings, only: Capitalize, LowerCase, Reverse, SortArray
d43 2
a44 1
  & open_MLSFile, close_MLSFile, Dump, mls_exists
d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.53 2004/01/21 18:48:59 livesey Exp $"
d86 1
d98 1
d193 4
d422 15
d1924 17
d1954 3
@


2.53
log
@Bug fix in mls_inqswath
@
text
@d46 1
a46 1
    "$Id: MLSFiles.f90,v 2.52 2003/06/23 21:06:55 pwagner Exp $"
d1598 1
a1598 1
1         & returnStatus)
d1914 3
@


2.52
log
@Moved use HDF5 down among module procedures to speed up Lahey compilation
@
text
@d46 1
a46 1
    "$Id: MLSFiles.f90,v 2.51 2003/06/20 19:32:32 pwagner Exp $"
d1492 4
a1495 1
    endif                         
d1598 1
a1598 1
         & returnStatus)
d1914 3
@


2.51
log
@mls_exists now public
@
text
@a8 2
  use HDF5, only: hid_t, h5fopen_f, h5fcreate_f, h5fclose_f, h5fis_hdf5_f, &
      H5F_ACC_RDONLY_F, H5F_ACC_RDWR_F, H5F_ACC_TRUNC_F, H5F_ACC_EXCL_F
d46 1
a46 1
    "$Id: MLSFiles.f90,v 2.50 2003/04/02 23:53:18 pwagner Exp $"
a659 2
        ! call h5fopen_f(trim(myName), &
        !  & hdf2hdf5_fileaccess(FileAccessType), theFileHandle, ErrType)
a950 2
        ! call h5fopen_f(trim(MLSFile%Name), &
        ! & hdf2hdf5_fileaccess(FileAccessType), MLSFile%File_Id, ErrType)
d1064 1
d1169 1
d1430 2
d1506 3
a1508 1

a1577 3
     ! call h5fopen_f(trim(FileName), hdf2hdf5_fileaccess(FileAccess), &
     ! & mls_sfstart, returnStatus)
!      & mls_sfstart, returnStatus, access_prp_default)  ! so abandoning it
d1627 1
d1694 1
d1766 3
d1845 1
d1911 3
@


2.50
log
@Added mls_exists; Checks for FILENOTFOUND
@
text
@d44 1
a44 1
  & open_MLSFile, close_MLSFile, Dump
d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.49 2003/02/28 00:46:32 pwagner Exp $"
a1879 3
!-----------------------------------------------
!       Private routines
!------------------------
d1895 3
d1908 3
@


2.49
log
@Improved apis for mls_open(close)file to exploit WILDCARDHDFVERSION
@
text
@d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.48 2003/02/26 17:34:39 pwagner Exp $"
d139 4
d145 1
a145 1
  integer, parameter, public :: NAMENOTFOUND=-1
d1473 5
d1732 6
a1737 1
    
d1881 16
d1908 3
@


2.48
log
@mls_inqswath, mls_sfstart, and mls_sfend act sensibly when passed WILDCARDHDFVERSION
@
text
@d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.47 2002/12/10 00:43:44 pwagner Exp $"
d1748 5
d1757 1
a1757 1
    integer, intent(in) :: hdfVersion
d1764 1
d1766 8
a1773 2
    error = 0
   select case (hdfVersion)
d1776 1
a1776 1
       file_id = mls_sfstart(trim(filename),DFACC_CREATE,hdfVersion)
d1778 1
a1778 1
       file_id = mls_sfstart(trim(filename),DFACC_RDWR,hdfVersion)
d1780 1
a1780 1
       file_id = mls_sfstart(trim(filename),DFACC_RDONLY,hdfVersion)
d1824 5
a1828 1
  subroutine mls_closeFile(file_id,hdfVersion)
d1833 2
a1834 1
    integer, intent(in) :: hdfVersion
d1839 1
d1841 12
a1852 1
    select case (hdfVersion)
d1878 3
@


2.47
log
@At last can h5fcreate an extant file with H5F_ACC_TRUNC_F
@
text
@d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.46 2002/12/09 17:55:03 pwagner Exp $"
d451 1
a451 1
    integer(i4),  intent(OUT)  :: record_length
d495 1
a495 1
    record_length = DEFAULTRECLEN
d1476 3
d1543 3
d1649 5
d1849 3
@


2.46
log
@Reuses mls_sfstart in mls_io_gen_openf and open_mls routines
@
text
@d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.45 2002/12/06 23:38:57 pwagner Exp $"
d1489 5
a1493 2
  ! Right now, it works for hdf4 files in general, but only for adding
  ! metadata to hdf5 files
a1494 4
  ! Therefore, when the grand unified hdf4/hdf5 interfaces are
  ! implemented this will probably need to take an added arg:
  ! the logical addingMetadata

a1562 10
! >      print *, 'About to call h5fopen_f'
! >      print *, 'FileAccess: ', FileAccess
! >      print *, 'DFACC_CREATE: ', DFACC_CREATE
! >      print *, 'DFACC_RDWR: ', DFACC_RDWR
! >      print *, 'DFACC_RDONLY: ', DFACC_RDONLY
! >      print *, 'hdf2hdf5_fileaccess(FileAccess): ', hdf2hdf5_fileaccess(FileAccess)
! >      print *, 'H5F_ACC_RDWR_F: ', H5F_ACC_RDWR_F
! >      print *, 'H5F_ACC_EXCL_F: ', H5F_ACC_EXCL_F
! >      print *, 'H5F_ACC_RDONLY_F: ', H5F_ACC_RDONLY_F
! >      print *, 'H5F_ACC_TRUNC_F: ', H5F_ACC_TRUNC_F
d1568 5
a1572 1
       call h5fcreate_f(trim(filename), H5F_ACC_EXCL_F, mls_sfstart, returnStatus)
d1578 2
a1579 1
       call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, mls_sfstart, returnStatus)
d1582 2
a1583 1
       call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, mls_sfstart, returnStatus)
d1587 2
a1588 2
   if ( returnStatus /= 0 .and. myAddingMetaData) then                                            
     call output ('Try again--PGS_MET_SFstart still unhappy; returns ')    
d1592 1
a1592 1
     call output ('Try again--h5fopen_f still unhappy; returns ')    
d1838 3
@


2.45
log
@mls_sfstart improved with addingMetaData optional arg
@
text
@d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.44 2002/12/05 19:44:24 pwagner Exp $"
d658 4
a661 2
        call h5fopen_f(trim(myName), &
          & hdf2hdf5_fileaccess(FileAccessType), theFileHandle, ErrType)
d951 4
a954 2
        call h5fopen_f(trim(MLSFile%Name), &
          & hdf2hdf5_fileaccess(FileAccessType), MLSFile%File_Id, ErrType)
d1843 3
@


2.44
log
@Moved MLSFile_T from MLSFiles to MLSCommon
@
text
@d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.43 2002/12/04 01:16:25 pwagner Exp $"
a872 1
    character (LEN=MAXFILENAMELENGTH) :: myName
d1021 1
a1021 1
        call output( 'file ' // trim(myName), advance='yes')
d1025 1
a1025 1
          & ' Fortran open', ErrType, trim(myName))
d1429 1
a1429 1
    integer(i4)                   :: FileAccesshdf5
d1435 1
a1435 1
      FileAccesshdf5 = H5F_ACC_TRUNC_F
d1492 1
a1492 2
! function mls_sfstart(FileName, FileAccess, addingMetadata, hdfVersion)
  function mls_sfstart(FileName, FileAccess, hdfVersion)
a1497 1
!   logical, intent(IN)           :: addingMetadata
d1499 2
d1506 1
d1513 3
d1523 5
d1529 2
a1530 2
     call output ('hdfVersion: ', advance='no')
     call output (hdfVersion, advance='yes')
d1544 2
a1545 1
   if ( PGS_MET4MLS_SF ) then
d1559 28
a1586 3
     access_prp_default = h5p_default_f
     call h5fopen_f(trim(FileName), he2he5_fileaccess(FileAccess), &
      & mls_sfstart, returnStatus, access_prp_default)
d1588 9
a1596 5
     if (returnStatus /= 0 ) then
       call output ('Try again--PGS_MET_SFstart still unhappy; returns ')
       call output (returnStatus, advance='yes')
       mls_sfstart = -1
      endif
d1614 1
a1614 2
  function mls_sfend(sdid, hdfVersion)
! function mls_sfend(sdid, addingMetadata, hdfVersion)
a1619 1
!   logical, intent(IN)           :: addingMetadata
d1621 3
a1623 1

d1629 2
d1634 4
a1637 1
     call output (sdid, advance='yes')
d1652 2
a1653 1
   if ( PGS_MET4MLS_SF ) then
d1776 6
d1784 8
a1791 8
     if (lowercase(trim(access)) == 'create') then 
       file_id = mls_sfstart(trim(filename),DFACC_CREATE,hdfVersion)
     elseif (lowercase(trim(access)) == 'update') then
       file_id = mls_sfstart(trim(filename),DFACC_RDWR,hdfVersion)
     elseif (lowercase(trim(access)) == 'readonly') then
       file_id = mls_sfstart(trim(filename),DFACC_RDONLY,hdfVersion)
     endif
     if (file_id .eq. -1) error = file_id 
d1839 3
@


2.43
log
@Open_ Close_ Dump_ Deallocate_ on new MLSFile_T added
@
text
@d16 1
a16 1
  use MLSCommon, only: i4, BareFNLen, FileNameLen
d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.42 2002/12/02 23:37:27 pwagner Exp $"
d192 15
a206 13
  ! Information describing the files used by the mls software
  ! Stop passing file handles back & forth bewteen routines
  ! -- pass one of these instead
  TYPE MLSFile_T
    CHARACTER (LEN=8) :: Type=""  ! e.g., 'ascii', 'hdf', 'swath', 'binary'
    CHARACTER (LEN=8) :: access=""  ! e.g., 'rdonly', 'write', 'rdwrite'
    CHARACTER (LEN=8) :: content=""  ! e.g., 'l1brad', 'l2gp', 'l2aux'
    CHARACTER (LEN=FileNameLen) :: Name=""  ! its name (usu. w/path)
    INTEGER :: File_Id=0     ! The HDF ID (handle) or io unit for the file
    INTEGER :: PCF_Id=0      ! The PCF ID (ref), if any,  for the file
    INTEGER :: HDFVersion=0  ! Which hdf version is the file if hdf(eos)
    LOGICAL :: StillOpen=.false.
  END TYPE MLSFile_T
d1789 3
@


2.42
log
@First halting steps toward reorg of how mls treats files--will be done via MLSFile_T
@
text
@d43 2
a44 1
  & mls_openFile, mls_closeFile, MLSFile_T
d48 1
a48 1
    "$Id: MLSFiles.f90,v 2.41 2002/11/07 21:22:40 jdone Exp $"
d80 4
d94 1
d187 5
d196 3
a198 4
    INTEGER :: File_Id=0     ! The HDF ID (handle) for the file
    INTEGER :: PCF_Id=0      ! The PCF ID (ref) for the file
    INTEGER :: HDFVersion=0  ! Which hdf version is the file
    CHARACTER (LEN=8) :: Type=""  ! e.g., 'ascii', 'hdf', hdf-eos', 'binary'
d200 3
d444 1
a444 1
    & hdfVersion, debugOption) &
d462 1
d787 4
a790 1
      if(access /= 'direct') then
d841 200
d1154 73
d1249 76
d1787 3
@


2.41
log
@HDF4/HDF5 capabilities integrated
@
text
@d16 3
a18 2
  use MLSCommon, only: i4, BareFNLen
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d40 2
a41 2
  public :: GetPCFromRef, get_free_lun, mls_io_gen_openF, &
  & mls_io_gen_closeF, split_path_name, &
d43 1
a43 1
  & mls_openFile, mls_closeFile
d47 1
a47 1
    "$Id: MLSFiles.f90,v 2.40 2002/10/29 01:02:26 pwagner Exp $"
d78 1
d89 1
d181 11
d194 18
d937 22
d1421 3
@


2.40
log
@Reverted DEFAULT_HDFVERSION to 4; added api
@
text
@d46 1
a46 1
    "$Id: MLSFiles.f90,v 2.39 2002/10/08 23:46:03 pwagner Exp $"
d1271 1
a1271 1
  subroutine mls_openFile(filename, access, file_id)
d1276 2
a1277 1
    integer(hid_t), intent(out) :: file_id
d1281 1
a1281 1
    integer :: h5error
d1284 37
a1320 26
  if (trim(access) == 'create') then 

  call h5fcreate_f(trim(filename), H5F_ACC_EXCL_F, file_id, h5error)
  if (h5error /= 0) call MLSMessage (MLSMSG_Error, ModuleName, "Error Creating File: "//trim(filename))

  elseif (trim(access) == 'update') then

   is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) 
   call h5fis_hdf5_f(trim(filename), is_hdf5, h5error)

  if (is_hdf5) then 
   call h5fopen_f(trim(filename), H5F_ACC_RDWR_F, file_id, h5error)
   if (h5error /= 0) call MLSMessage (MLSMSG_Error, ModuleName, "Error Updating File: "//trim(filename))
  endif

  elseif (trim(access) == 'readonly') then 

  is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) 
  call h5fis_hdf5_f(trim(filename), is_hdf5, h5error)

  if (is_hdf5) then 
  call h5fopen_f(trim(filename), H5F_ACC_RDONLY_F, file_id, h5error)
  if (h5error /= 0) call MLSMessage (MLSMSG_Error, ModuleName, "Error Reading File: "//trim(filename))
  endif

  endif
d1322 5
d1330 1
a1330 2

  subroutine mls_closeFile(file_id)
d1334 2
a1335 1
    integer(hid_t), intent(in) :: file_id
d1339 10
a1348 1
    integer :: h5error
d1350 1
a1350 2
    call h5fclose_f(file_id, h5error)
    if (h5error /= 0) then 
a1354 1

d1367 3
@


2.39
log
@Separate he2he5_fileaccess and hdf2hdf5_fileaccess functions
@
text
@d46 1
a46 1
    "$Id: MLSFiles.f90,v 2.38 2002/10/08 00:09:11 pwagner Exp $"
d56 21
d79 1
d84 2
a86 1
! mls_sfend          Closes a file opened by mls_sfstart
d96 20
d120 1
a120 1
   integer, parameter         :: DEFAULT_HDFVERSION = HDFVERSION_5
d1343 3
@


2.38
log
@Added idents to survive zealous Lahey optimizer
@
text
@d46 1
a46 1
    "$Id: MLSFiles.f90,v 2.37 2002/09/27 23:38:38 pwagner Exp $"
d65 3
d70 2
a71 1
! === (end of toc) ===
d515 1
a515 1
          & hdf2hdf5_fileaccess(FileAccessType))
d535 1
a535 1
          call output(hdf2hdf5_fileaccess(FileAccessType), advance='yes')  
d547 1
a547 1
          & hdf2hdf5_fileaccess(FileAccessType))
d923 1
a923 1
  ! ---------------------------------------------  hdf2hdf5_fileaccess  -----
d925 2
a926 2
  ! This function converts hdf4 file access types to
  ! corresponding hdf5 numbers
d928 1
a928 1
  function hdf2hdf5_fileaccess(FileAccesshdf4) result (FileAccesshdf5)
d945 1
a945 1
    case(DFACC_READ)
d953 28
d1073 1
a1073 1
       myAccess = hdf2hdf5_fileaccess(FileAccess)
d1086 1
a1086 1
     call h5fopen_f(trim(FileName), hdf2hdf5_fileaccess(FileAccess), &
d1300 3
@


2.37
log
@Added hg type to mls_gen_close
@
text
@d46 1
a46 1
    "$Id: MLSFiles.f90,v 2.36 2002/09/26 23:59:39 pwagner Exp $"
d49 1
d1259 4
d1268 3
@


2.36
log
@added 'hg' toolbox_mode to mls_io_gen_openF
@
text
@d46 1
a46 1
    "$Id: MLSFiles.f90,v 2.35 2002/08/08 22:40:42 jdone Exp $"
d51 1
d59 2
a60 2
! mls_io_gen_openF   Opens a generic file using either the toolbox or else a Fortran OPEN statement
! mls_io_gen_closeF  Closes a generic file using either the toolbox or else a Fortran OPEN statement
d63 1
a63 1
! split_path_name    splits the input full_file_name into its components path and name
d66 1
d323 1
a323 1
  ! 'hg' for hdf4/5 files opened with sfstart; e.g. l1brad
d749 1
a749 1
  ! 'sw' for swath files opened with swopen
d751 1
d753 1
a753 1
  ! 'cl' for l3ascii files opened with simple fortran 'open'
d826 9
d1263 3
@


2.35
log
@New routines to Open/Close HDF5 Files
@
text
@d46 1
a46 1
    "$Id: MLSFiles.f90,v 2.34 2002/07/23 00:06:55 pwagner Exp $"
a319 1
  ! 'sw' for swath files opened with swopen
d321 1
d324 1
d553 21
d1251 3
@


2.34
log
@debug set to false in sfstart and sfend
@
text
@d9 2
a10 2
  use Hdf5, only: h5fopen_f, h5fclose_f, h5fis_hdf5_f
!  use Hdf5_params, only: H5F_ACC_RDONLY, H5F_ACC_RDWR, H5F_ACC_TRUNC
d41 2
a42 1
  & mls_hdf_version, mls_inqswath, mls_sfstart, mls_sfend
d46 1
a46 1
    "$Id: MLSFiles.f90,v 2.33 2002/07/11 22:21:01 pwagner Exp $"
d1159 1
d1161 63
a1223 1
  !====================
d1229 3
@


2.33
log
@These hdf5-savvy versions transferred from he5lib
@
text
@d45 1
a45 1
    "$Id: MLSFiles.f90,v 1.13 2002/06/12 17:59:37 livesey Exp $"
d977 1
a977 1
    logical, parameter :: DEBUG = .true.
d1055 1
a1055 1
    logical, parameter :: DEBUG = .true.
d1165 3
@


2.32
log
@added a get free lun module--wgr
@
text
@d6 5
a10 2
!===============================================================================
  use HDF, only: sfstart, sfend
d12 3
d16 1
a16 1
  use MLSCommon, only: i4, NameLen, BareFNLen
d20 3
a22 1
  use SDPToolkit, only: Pgs_pc_getReference, PGS_S_SUCCESS, Pgs_smf_getMsg, &
d32 3
d39 1
a39 1
  PUBLIC :: GetPCFromRef, get_free_lun, mls_io_gen_openF, &
d45 1
a45 1
    "$Id: MLSFiles.f90,v 2.31 2002/03/14 23:31:45 pwagner Exp $"
a64 4
  ! ((( Not yet ready for hdfeos5 versions of files )))
  !       The latter will incorporate the
  !       routines in he5lib

d69 1
a69 1
   integer, parameter         :: DEFAULT_HDFVERSION = HDFVERSION_4
d92 1
d94 2
a95 1
  ! Now we have the legal unit numbers that files may be assigned
d97 27
a390 6
    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = DEFAULT_HDFVERSION
    endif
d392 1
a395 2
    myPC = FH_ON_ERROR
    returnStatus = 0           ! In case using Toolkit but supplied FileName
a402 2
   the_eff_mode = LowerCase(toolbox_mode(1:2))
   
d404 1
d451 1
d455 7
d471 3
a473 5
       if(UseSDPToolkit) then
          call output('PCF-supplied number: ', advance='no')
          call blanks(2)
          call output(myPC, advance='yes')
       endif
d480 3
d485 4
d501 7
a507 1
      if(returnStatus == 0) then
a508 5
        if(theFileHandle <= 0) then
          ErrType = min(theFileHandle, -1)
        else
          ErrType = 0
        endif
d510 2
a511 1
        ErrType = returnStatus
d513 18
d533 7
a539 1
      if(returnStatus == 0) then
a540 5
        if(theFileHandle <= 0) then
          ErrType = min(theFileHandle, -1)
        else
          ErrType = 0
        endif
d542 2
a543 1
        ErrType = returnStatus
d545 5
d731 1
a731 1
  ! If must be given a FileHandle as an arg
d752 1
a752 6
    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = DEFAULT_HDFVERSION
    endif
d763 14
d783 7
a789 1
      ErrType = swclose(theFileHandle)
d792 7
a798 1
      ErrType = gdclose(theFileHandle)
d883 32
a926 1

d938 1
d940 7
a946 1
    mls_inqswath = swinqswath(FileName, swathList, strBufSize)
d953 6
d960 1
d965 4
a968 2
      character (len=*), intent(in) :: FILENAME
    integer(i4), intent(IN)       :: FileAccess
d970 8
a978 11
    integer, optional, intent(in) :: hdfVersion

    ! Local
    integer :: myhdfVersion

    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = DEFAULT_HDFVERSION
    endif
d980 50
a1029 1
    mls_sfstart = sfstart(FileName, FileAccess)
d1036 6
d1044 1
d1048 3
a1050 3
      integer, intent(IN)       :: sdid
      integer :: mls_sfend

d1053 3
a1055 2
    ! Local
    integer :: myhdfVersion
a1056 6
    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = DEFAULT_HDFVERSION
    endif
d1058 28
a1085 1
    mls_sfend = sfend(sdid)
d1091 5
a1095 5
  ! This function returns a character string depending on hdf version:
  ! hdf version         returned value
  !    hdf4                 hdf4
  !    hdf5                 hdf5
  !  unknown                ????
a1098 1
!  function mls_hdf_version(FileName)  result (hdf_version)
d1100 1
a1100 1
    ! Arguments
d1102 10
a1111 5
      character (len=*), intent(in) :: FILENAME
   !   character (len=4)             :: hdf_version
      integer(i4), optional, intent(in)  :: PREFERRED_VERSION
      integer(i4), optional, intent(in)  :: ACCESSTYPE
      integer(i4)                        :: HDF_VERSION
a1112 2
      integer :: returnStatus
      logical :: is_hdf5
d1114 33
d1148 8
a1155 1
      hdf_version = 4
d1159 1
a1159 1
!====================
d1165 2
a1166 2
! Revision 2.31  2002/03/14 23:31:45  pwagner
! HDFVERSION_4 and 5 now public
d1168 2
a1169 2
! Revision 2.30  2002/02/19 23:12:40  pwagner
! Eliminated unwanted matches between o3 and hno3
d1171 2
a1172 2
! Revision 2.29  2002/01/31 00:35:56  pwagner
! Brought mls_io_gen_closeF into compilance with he5lib version
d1174 2
a1175 2
! Revision 2.28  2002/01/29 23:45:26  pwagner
! Added WILDCARDHDFVERSION as public param
d1177 2
a1178 2
! Revision 2.27  2002/01/29 00:47:41  pwagner
! Converted mls_hdf_version to integer function
d1180 2
a1181 2
! Revision 2.26  2002/01/23 21:47:31  pwagner
! Begun to make hdf5-capable; not yet, though
d1183 2
a1184 56
! Revision 2.25  2002/01/18 18:51:22  pwagner
! Fixed bug when calling mls_open w/o toolkit
!
! Revision 2.24  2002/01/18 00:53:37  pwagner
! Added inqswath, sfend, sfstart wrappers; not ready yet for hdf5
!
! Revision 2.23  2002/01/11 00:44:37  pwagner
! Fixed bug where ErrType was left unset
!
! Revision 2.22  2002/01/09 23:43:26  pwagner
! Added toc; removed debugging stuff
!
! Revision 2.21  2001/07/18 23:59:16  pwagner
! Fixed bug with version variable in mls_io_gen_openf
!
! Revision 2.20  2001/06/19 22:22:28  pwagner
! Set record_length to DEFAULTRECLEN unless otherwise
!
! Revision 2.19  2001/05/08 23:35:44  pwagner
! Fixed bug in the_eff_mode
!
! Revision 2.18  2001/05/08 21:36:38  livesey
! Changed PRINT_EVERY_OPEN to .false.
!
! Revision 2.17  2001/05/07 23:25:02  pwagner
! Detachable from toolkit
!
! Revision 2.16  2001/04/25 21:52:50  livesey
! Added optional `unknown' argument
!
! Revision 2.15  2001/04/25 20:32:29  livesey
! Bug fix, trim filename on output
!
! Revision 2.14  2001/04/17 23:44:54  pwagner
! Fixed bug with ExactName in getpc..
!
! Revision 2.13  2001/04/17 22:10:55  pwagner
! getpcfromref takes optional path; otherwise matches only filename
!
! Revision 2.12  2001/04/13 23:50:55  pwagner
! split_path_name now works properly
!
! Revision 2.11  2001/04/13 00:18:10  pwagner
! Prints only if debug present AND .TRUE.
!
! Revision 2.10  2001/04/10 20:05:07  livesey
! Tidied up
!
! Revision 2.9  2001/04/09 23:42:38  pwagner
! Resets version properly each time
!
! Revision 2.8  2001/04/07 00:16:28  pwagner
! fixed MAXFILENAMELENGTH to not core dump in toolbox
!
! Revision 2.7  2001/04/03 23:52:29  pwagner
! Added split_path_name
d1186 2
a1187 2
! Revision 2.6  2001/03/27 17:30:59  pwagner
! Added mls_io_gen_closeF
d1189 2
a1190 2
! Revision 2.5  2001/03/24 00:30:14  pwagner
! Now complains only if an error, and then via output
d1192 2
a1193 2
! Revision 2.4  2001/03/22 01:09:31  pwagner
! Added file name to Fortran open statement
d1195 2
a1196 2
! Revision 2.3  2001/03/21 00:48:43  pwagner
! Corrected mls_io_gen_openF
d1198 2
a1199 2
! Revision 2.2  2001/03/20 00:41:28  pwagner
! Added mls_io_gen_openF
d1201 1
a1201 1
! Revision 2.1  2001/03/07 01:02:37  pwagner
@


2.31
log
@HDFVERSION_4 and 5 now public
@
text
@d11 1
d28 1
a28 1
  public :: GetPCFromRef, mls_io_gen_openF, &
d34 3
a36 1
    "$Id: MLSFiles.f90,v 2.30 2002/02/19 23:12:40 pwagner Exp $"
d43 1
d263 15
d912 3
@


2.30
log
@Eliminated unwanted matches between o3 and hno3
@
text
@d33 1
a33 1
    "$Id: MLSFiles.f90,v 2.29 2002/01/31 00:35:56 pwagner Exp $"
d56 3
a58 3
   integer, parameter :: HDFVERSION_4 = 4
   integer, parameter :: HDFVERSION_5 = 5
   integer, parameter :: DEFAULT_HDFVERSION = HDFVERSION_4
d893 3
@


2.29
log
@Brought mls_io_gen_closeF into compilance with he5lib version
@
text
@d6 1
a6 1
  !===============================================================================
d10 2
a11 2
  use MLSCommon, only: i4
  use MLSStrings, only: Capitalize, LowerCase, Reverse
d33 1
a33 1
    "$Id: MLSFiles.f90,v 2.28 2002/01/29 23:45:26 pwagner Exp $"
d72 1
d120 1
a120 1
    integer(i4)                              :: thePC
d125 1
a125 1
    character (LEN=*),  optional, intent(IN)       :: path
d129 5
a133 1

d136 2
a137 1
    integer                       ::     version, returnStatus
a176 2
    ErrType = NAMENOTFOUND

d181 9
d210 1
a210 6

        if ( index(NameOnly, trim(MatchName)) /= 0 )then
          ErrType = 0
          exit
        endif

d214 12
d227 19
d256 1
d893 3
@


2.28
log
@Added WILDCARDHDFVERSION as public param
@
text
@d33 1
a33 1
    "$Id: MLSFiles.f90,v 2.27 2002/01/29 00:47:41 pwagner Exp $"
d595 1
a595 1
  ! or else a Fortran OPEN statement
d606 3
a608 1
  function mls_io_gen_closeF(toolbox_mode, theFileHandle, hdfVersion) &
d615 1
d853 3
@


2.27
log
@Converted mls_hdf_version to integer function
@
text
@d33 1
a33 1
    "$Id: MLSFiles.f90,v 2.26 2002/01/23 21:47:31 pwagner Exp $"
d56 8
a63 1
   integer, parameter :: DEFAULT_HDFVERSION = 4
d850 3
@


2.26
log
@Begun to make hdf5-capable; not yet, though
@
text
@d33 1
a33 1
    "$Id: MLSFiles.f90,v 2.25 2002/01/18 18:51:22 pwagner Exp $"
d817 3
a819 1
  function mls_hdf_version(FileName)  result (hdf_version)
d824 4
a827 1
      character (len=4)             :: hdf_version
d832 2
a833 1
      hdf_version = 'hdf4'
d843 3
@


2.25
log
@Fixed bug when calling mls_open w/o toolkit
@
text
@a23 1
  public
d25 5
a29 1
  private :: ID
d33 1
a33 1
    "$Id: MLSFiles.f90,v 2.24 2002/01/18 00:53:37 pwagner Exp $"
d40 2
d44 2
d47 10
d63 2
a64 2
  integer, parameter :: NAMENOTFOUND=-1
  integer, parameter :: INVALIDPCRANGE=NAMENOTFOUND-1
d68 5
a72 5
  integer, parameter :: UNKNOWNFILEACCESSTYPE=-999
  integer, parameter :: UNKNOWNTOOLBOXMODE=UNKNOWNFILEACCESSTYPE+1
  integer, parameter :: NOFREEUNITS=UNKNOWNTOOLBOXMODE+1
  integer, parameter :: MUSTSUPPLYFILENAMEORPC=NOFREEUNITS+1
  integer, parameter :: NOPCIFNOTOOLKIT=MUSTSUPPLYFILENAMEORPC+1
d244 2
a245 1
    & FileName, PCBottom, PCTop, versionNum, unknown, thePC, debugOption) &
d262 4
a265 1
    ! Local variables
d289 6
d599 1
a599 1
  function mls_io_gen_closeF(toolbox_mode, theFileHandle) &
d607 4
a610 1
    ! Local variables
d615 7
d729 1
a729 1
  function mls_inqswath(FileName, swathList, strBufSize)
d738 11
d758 1
a758 1
  function mls_sfstart(FileName, FileAccess)
d766 11
d786 1
a786 1
  function mls_sfend(sdid)
d793 11
d809 23
a831 1
  !====================
d837 3
@


2.24
log
@Added inqswath, sfend, sfstart wrappers; not ready yet for hdf5
@
text
@d30 1
a30 1
    "$Id: MLSFiles.f90,v 2.23 2002/01/11 00:44:37 pwagner Exp $"
d272 2
d281 2
a283 1
    the_eff_mode = LowerCase(toolbox_mode(1:2))
a329 1
      the_eff_mode = LowerCase(toolbox_mode(1:2))
d342 5
a346 3
       call output('PCF-supplied number: ', advance='no')
       call blanks(2)
       call output(myPC, advance='yes')
d745 3
@


2.23
log
@Fixed bug where ErrType was left unset
@
text
@d7 2
a8 1
  use HDFEOS, only: gdclose, gdopen, swclose, swopen
d12 1
a12 1
  use output_m, only: output
d30 1
a30 1
    "$Id: MLSFiles.f90,v 2.22 2002/01/09 23:43:26 pwagner Exp $"
d108 1
a108 1
   logical ::                            debug
d227 1
a227 1
    & FileName, PCBottom, PCTop, versionNum, unknown, thePC) &
d242 1
d246 1
a246 1
    logical, parameter :: PRINT_EVERY_OPEN=.false.
d257 2
d262 7
d287 13
d304 2
a305 1
          &	 caseSensitive, returnStatus, your_version)
d310 3
d320 3
d331 20
d478 2
d494 2
d539 12
d684 51
d741 3
a808 1
!
@


2.22
log
@Added toc; removed debugging stuff
@
text
@d9 1
a9 1
  use MLSCommon, only: i4, NameLen
d29 1
a29 1
    "$Id: MLSFiles.f90,v 2.21 2001/07/18 23:59:16 pwagner Exp $"
d307 2
d623 3
@


2.21
log
@Fixed bug with version variable in mls_io_gen_openf
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d29 1
a29 1
    "$Id: MLSFiles.f90,v 2.20 2001/06/19 22:22:28 pwagner Exp $"
d32 8
d582 1
a582 1
   logical, parameter :: DEBUG = .false.
a600 3
    if(DEBUG) then
      print*, trim(mirrored_ffn), ' ', loc
   endif
a608 4
    if(DEBUG) then
      print*, trim(mirrored_ffn(loc:))
      print*, trim(mirrored_ffn(:loc-1))
   endif
d621 3
@


2.20
log
@Set record_length to DEFAULTRECLEN unless otherwise
@
text
@d29 1
a29 1
    "$Id: MLSFiles.f90,v 2.19 2001/05/08 23:35:44 pwagner Exp $"
a145 7
      !		if(debug) then
      !			call output('pc: ' )
      !			call output(thePC, advance='no')
      !			call output('              version: ' )
      !			call output(version, advance='yes')
      !		endif

d242 1
a242 1
    integer                       :: version, returnStatus
d262 1
d266 1
a266 1
      returnStatus = Pgs_pc_getReference(thePC, version, &
d271 2
a272 2
        myPC = GetPCFromRef(FileName, PCBottom, PCTop, &
          &	 caseSensitive, returnStatus, versionNum)
d292 1
d297 3
a299 3
        ErrType = PGS_IO_Gen_OpenF(myPC, FileAccessType, record_length, &
          & theFileHandle, version)
      endif
d303 1
a303 1
        theFileHandle = swopen(myName, FileAccessType)
d315 1
a315 1
        theFileHandle = gdopen(myName, FileAccessType)
d440 1
a440 1
          & position=position, status=status, file=myName, iostat=ErrType)
d443 1
a443 1
          & status=status, file=myName, iostat=ErrType)
d461 1
a461 1
          & ' Fortran open', ErrType, myName)
d620 3
@


2.19
log
@Fixed bug in the_eff_mode
@
text
@d29 1
a29 1
    "$Id: MLSFiles.f90,v 2.18 2001/05/08 21:36:38 livesey Exp $"
d245 1
d259 1
d625 3
@


2.18
log
@Changed PRINT_EVERY_OPEN to .false.
@
text
@d29 1
a29 1
    "$Id: MLSFiles.f90,v 2.17 2001/05/07 23:25:02 pwagner Exp $"
d292 2
a293 1
      the_eff_mode = 'op'
d512 2
a513 1
      the_eff_mode = 'cl'
d623 3
@


2.17
log
@Detachable from toolkit
@
text
@d29 1
a29 1
    "$Id: MLSFiles.f90,v 2.16 2001/04/25 21:52:50 livesey Exp $"
d243 1
a243 1
    logical, parameter :: PRINT_EVERY_OPEN=.true.
d621 3
@


2.16
log
@Added optional `unknown' argument
@
text
@d20 2
a21 1
    & PGS_IO_GEN_CloseF, PGS_IO_GEN_OpenF, PGSd_PC_FILE_PATH_MAX
d29 1
a29 1
    "$Id: MLSFiles.f90,v 2.15 2001/04/25 20:32:29 livesey Exp $"
d46 1
d101 6
d251 1
d265 3
d278 1
d284 12
a295 1
    select case (LowerCase(toolbox_mode(1:2)))
d503 10
a512 1
    logical, parameter :: PRINT_EVERY_CLOSE=.true.
d514 1
a514 1
    select case (LowerCase(toolbox_mode(1:2)))
d621 3
@


2.15
log
@Bug fix, trim filename on output
@
text
@d28 1
a28 1
    "$Id: MLSFiles.f90,v 2.14 2001/04/17 23:44:54 pwagner Exp $"
d217 1
a217 1
    & FileName, PCBottom, PCTop, versionNum, thePC) &
d231 1
d412 3
d588 3
@


2.14
log
@Fixed bug with ExactName in getpc..
@
text
@d28 1
a28 1
    "$Id: MLSFiles.f90,v 2.13 2001/04/17 22:10:55 pwagner Exp $"
d428 1
a428 1
        call output( 'file ' // myName, advance='yes')
d584 3
@


2.13
log
@getpcfromref takes optional path; otherwise matches only filename
@
text
@d28 1
a28 1
    "$Id: MLSFiles.f90,v 2.12 2001/04/13 23:50:55 pwagner Exp $"
d94 1
a94 1
    character (LEN=MAXFILENAMELENGTH) :: MatchName, TryName
d162 1
a162 1
        call split_path_name(TryName, MatchPath, PhysicalName)
d164 1
a164 1
        if ( index(PhysicalName, trim(MatchName)) /= 0 )then
d584 3
@


2.12
log
@split_path_name now works properly
@
text
@d28 1
a28 1
    "$Id: MLSFiles.f90,v 2.11 2001/04/13 00:18:10 pwagner Exp $"
d71 2
d78 1
a78 1
    & caseSensitive, ErrType, versionNum, debugOption, ExactName) &
d82 8
a89 7
    character (LEN=*), intent(IN)   :: FileName
    integer(i4),  intent(IN)   :: PCBottom, PCTop
    integer(i4)                :: thePC
    integer(i4),  intent(OUT)  :: ErrType
    logical,  intent(IN)       :: caseSensitive
    integer(i4),  optional     :: versionNum
    logical,  optional, intent(IN)       :: debugOption
d94 2
a95 1
    character (LEN=MAXFILENAMELENGTH) :: MatchName, TryName, PhysicalName
d161 2
d164 1
a164 1
        if ( index(TryName, trim(MatchName)) /= 0 )then
d173 6
d584 3
@


2.11
log
@Prints only if debug present AND .TRUE.
@
text
@d28 1
a28 1
    "$Id: MLSFiles.f90,v 2.10 2001/04/10 20:05:07 livesey Exp $"
d524 1
a524 1
    character (len=NameLEN) :: mirrored_ffn
d526 1
d544 4
d556 4
d572 3
@


2.10
log
@Tidied up
@
text
@d28 1
a28 1
    "$Id: MLSFiles.f90,v 2.9 2001/04/09 23:42:38 pwagner Exp $"
d76 2
a77 1
    & caseSensitive, ErrType, versionNum, debug, ExactName) result (thePC)
d86 1
a86 1
    logical,  optional, intent(IN)       :: debug
d92 2
a93 1
    integer                       :: version, returnStatus
d95 7
a101 1
    if(present(debug)) then
d128 1
a128 1
    if(present(debug)) then
d134 1
a134 1
      !		if(present(debug)) then
d563 3
@


2.9
log
@Resets version properly each time
@
text
@d5 7
a11 7
MODULE MLSFiles               ! Utility file routines
!===============================================================================
   USE HDFEOS, only: gdclose, gdopen, swclose, swopen
   USE machine, only: io_error
   USE MLSCommon, only: i4, NameLen
   USE MLSStrings, only: Capitalize, LowerCase, Reverse
   USE output_m, only: output
d13 17
a29 17
  & PGSd_IO_Gen_RSeqFrm, PGSd_IO_Gen_RSeqUnf, & 
  & PGSd_IO_Gen_RDirFrm, PGSd_IO_Gen_RDirUnf, & 
  & PGSd_IO_Gen_WSeqFrm, PGSd_IO_Gen_WSeqUnf, & 
  & PGSd_IO_Gen_WDirFrm, PGSd_IO_Gen_WDirUnf, & 
  & PGSd_IO_Gen_USeqFrm, PGSd_IO_Gen_USeqUnf, & 
  & PGSd_IO_Gen_UDirFrm, PGSd_IO_Gen_UDirUnf, & 
  & PGSd_IO_Gen_ASeqFrm, PGSd_IO_Gen_ASeqUnf, &
  & PGS_IO_GEN_CloseF, PGS_IO_GEN_OpenF, PGSd_PC_FILE_PATH_MAX
   IMPLICIT NONE
   PUBLIC

   PRIVATE :: ID

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &
   "$Id: MLSFiles.f90,v 2.8 2001/04/07 00:16:28 pwagner Exp $"
!----------------------------------------------------------
d31 2
a32 2
	! This isn't NameLen because it may have a path prefixed
	INTEGER, PARAMETER :: MAXFILENAMELENGTH=PGSd_PC_FILE_PATH_MAX
d36 2
a37 2
	INTEGER, PARAMETER :: NAMENOTFOUND=-1
	INTEGER, PARAMETER :: INVALIDPCRANGE=NAMENOTFOUND-1
d41 4
a44 4
	INTEGER, PARAMETER :: UNKNOWNFILEACCESSTYPE=-999
	INTEGER, PARAMETER :: UNKNOWNTOOLBOXMODE=UNKNOWNFILEACCESSTYPE+1
	INTEGER, PARAMETER :: NOFREEUNITS=UNKNOWNTOOLBOXMODE+1
	INTEGER, PARAMETER :: MUSTSUPPLYFILENAMEORPC=NOFREEUNITS+1
d48 2
a49 2
  INTEGER, PARAMETER :: bottom_unit_num=1
  INTEGER, PARAMETER :: top_unit_num=99
d51 1
a51 1
  CONTAINS
d58 1
a58 1
  !
d61 1
a61 1
  
d64 1
a64 1
  
d67 1
a67 1
  
d70 1
a70 1
  
d72 1
a72 1
  
d74 3
a76 3
  
  FUNCTION GetPCFromRef(FileName, PCBottom, PCTop, &
  & caseSensitive, ErrType, versionNum, debug, ExactName) RESULT (thePC)
d79 9
a87 9
    CHARACTER (LEN=*), INTENT(IN)   :: FileName
    INTEGER(i4),  INTENT(IN)   :: PCBottom, PCTop
    INTEGER(i4)                :: thePC
    INTEGER(i4),  INTENT(OUT)  :: ErrType
    LOGICAL,  INTENT(IN)       :: caseSensitive
    INTEGER(i4),  OPTIONAL     :: versionNum
    LOGICAL,  OPTIONAL, INTENT(IN)       :: debug
	CHARACTER (LEN=*), optional, intent(out) :: ExactName
  
a88 74
	
	CHARACTER (LEN=MAXFILENAMELENGTH) :: MatchName, TryName, PhysicalName
	INTEGER                       :: version, returnStatus
		
	!
	if(present(debug)) then
		call output('get pc from ref', advance='yes')
		call output('FileName: ' // trim(FileName), advance='yes')
		call output('lower PCF limit: ' )
		call output(PCBottom, advance='yes')
		call output('upper PCF limit: ' )
		call output(PCTop, advance='yes')
		call output('case sensitive?: ' )
		call output(caseSensitive, advance='yes')
		call output('version number: ' )
		call output(versionNum, advance='yes')
	endif

	thePC = 0
	IF(PCTop < PCBottom) THEN
		ErrType = INVALIDPCRANGE
		RETURN
	ENDIF
	
	IF(caseSensitive) THEN
		MatchName = FileName
	ELSE
		MatchName = Capitalize(FileName)
	ENDIF

	ErrType = NAMENOTFOUND

	if(present(debug)) then
		call output('getting ref from pc:', advance='no')
	endif

	DO thePC = PCBottom, PCTop

!		if(present(debug)) then
!			call output('pc: ' )
!			call output(thePC, advance='no')
!			call output('              version: ' )
!			call output(version, advance='yes')
!		endif

		IF(PRESENT(versionNum)) THEN
			version = versionNum
		ELSE
			version = 1
		ENDIF

            returnStatus = Pgs_pc_getReference(thePC, version, &
              & PhysicalName)
            
            if ( returnStatus == PGS_S_SUCCESS ) then

					IF(.NOT. caseSensitive) THEN
						TryName = Capitalize(PhysicalName)
					ELSE
						TryName = PhysicalName
					ENDIF

              if ( INDEX(TryName, TRIM(MatchName)) /= 0 )then
					ErrType = 0
                EXIT
					endif

				endif
				
	ENDDO

	if(present(ExactName) .AND. ErrType == 0) then
		ExactName = PhysicalName
	endif
d90 75
a164 2
  END FUNCTION GetPCFromRef
	
d180 1
a180 1
  
d182 1
a182 1
  
d188 1
a188 1
  
d191 1
a191 1
  
d194 5
a198 5
  
  FUNCTION mls_io_gen_openF(toolbox_mode, caseSensitive, ErrType, &
  & record_length, FileAccessType, &
  & FileName, PCBottom, PCTop, versionNum, thePC) &
  &  RESULT (theFileHandle)
d201 11
a211 11
    INTEGER(i4),  INTENT(OUT)  :: ErrType
    INTEGER(i4),  INTENT(OUT)  :: record_length
    LOGICAL,  INTENT(IN)       :: caseSensitive
    CHARACTER (LEN=*), INTENT(IN)   :: toolbox_mode
    INTEGER(i4), INTENT(IN)                :: FileAccessType
    INTEGER(i4)  :: theFileHandle
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN)   :: FileName
    INTEGER(i4),  OPTIONAL, INTENT(IN)   :: PCBottom, PCTop
    INTEGER(i4), OPTIONAL, INTENT(IN)                :: thePC
    INTEGER(i4),  OPTIONAL     :: versionNum
  
d214 162
a375 164
	LOGICAL, PARAMETER :: PRINT_EVERY_OPEN=.TRUE.
	INTEGER, PARAMETER :: FH_ON_ERROR=-99
	INTEGER, PARAMETER :: KEYWORDLEN=12			! Max length of keywords in OPEN(...)
	CHARACTER (LEN=MAXFILENAMELENGTH) :: myName
	INTEGER(i4) :: myPC
	INTEGER                       :: version, returnStatus
   LOGICAL       :: tiedup
	CHARACTER (LEN=KEYWORDLEN) :: access, action, form, position, status
	INTEGER                       :: unit

	! begin

	! In case of premature return
	theFileHandle = FH_ON_ERROR

	IF(PRESENT(versionNum)) THEN
		version = versionNum
	ELSE
		version = 1
	ENDIF

	if(PRESENT(thePC)) then
		myPC = thePC
		returnStatus = Pgs_pc_getReference(thePC, version, &
              & myName)
	elseif(PRESENT(FileName)) then
		myName = FileName
		if(LowerCase(toolbox_mode(1:2)) == 'pg') then
			myPC = GetPCFromRef(FileName, PCBottom, PCTop, &
  &	 caseSensitive, returnStatus, versionNum)
  		endif
	else
		ErrType = MUSTSUPPLYFILENAMEORPC
		return
	ENDIF
	
	select case (LowerCase(toolbox_mode(1:2)))
	
	case('pg')
		if(returnStatus == 0) then
			ErrType = PGS_IO_Gen_OpenF(myPC, FileAccessType, record_length, &
			& theFileHandle, version)
		endif
	
	case('sw')
		if(returnStatus == 0) then
			theFileHandle = swopen(myName, FileAccessType)
			if(theFileHandle <= 0) then
				ErrType = min(theFileHandle, -1)
			else
				ErrType = 0
			endif
		else
			ErrType = returnStatus
		endif
	
	case('gd')
		if(returnStatus == 0) then
			theFileHandle = gdopen(myName, FileAccessType)
			if(theFileHandle <= 0) then
				ErrType = min(theFileHandle, -1)
			else
				ErrType = 0
			endif
		else
			ErrType = returnStatus
		endif
	
	case('op')
		theFileHandle = FH_ON_ERROR
		if(FileAccessType == PGSd_IO_Gen_RSeqFrm) then
			status = 'old'
			access = 'sequential'
			form = 'formatted'
			action = 'read'
			position = 'rewind'
		elseif(FileAccessType == PGSd_IO_Gen_RSeqUnf) then
			status = 'old'
			access = 'sequential'
			form = 'unformatted'
			action = 'read'
			position = 'rewind'
		elseif(FileAccessType == PGSd_IO_Gen_RDirFrm) then
			status = 'old'
			access = 'direct'
			form = 'formatted'
			action = 'read'
			position = 'rewind'
		elseif(FileAccessType == PGSd_IO_Gen_RDirUnf) then
			status = 'old'
			access = 'direct'
			form = 'unformatted'
			action = 'read'
			position = 'rewind'

		elseif(FileAccessType == PGSd_IO_Gen_WSeqFrm) then
			status = 'new'
			access = 'sequential'
			form = 'formatted'
			action = 'write'
			position = 'rewind'
		elseif(FileAccessType == PGSd_IO_Gen_WSeqUnf) then
			status = 'new'
			access = 'sequential'
			form = 'unformatted'
			action = 'write'
			position = 'rewind'
		elseif(FileAccessType == PGSd_IO_Gen_WDirFrm) then
			status = 'new'
			access = 'direct'
			form = 'formatted'
			action = 'write'
			position = 'rewind'
		elseif(FileAccessType == PGSd_IO_Gen_WDirUnf) then
			status = 'new'
			access = 'direct'
			form = 'unformatted'
			action = 'write'
			position = 'rewind'

		elseif(FileAccessType == PGSd_IO_Gen_USeqFrm) then
			status = 'old'
			access = 'sequential'
			form = 'formatted'
			action = 'readwrite'
			position = 'rewind'
		elseif(FileAccessType == PGSd_IO_Gen_USeqUnf) then
			status = 'old'
			access = 'sequential'
			form = 'unformatted'
			action = 'readwrite'
			position = 'rewind'
		elseif(FileAccessType == PGSd_IO_Gen_UDirFrm) then
			status = 'old'
			access = 'direct'
			form = 'formatted'
			action = 'readwrite'
			position = 'rewind'
		elseif(FileAccessType == PGSd_IO_Gen_UDirUnf) then
			status = 'old'
			access = 'direct'
			form = 'unformatted'
			action = 'readwrite'
			position = 'rewind'

		elseif(FileAccessType == PGSd_IO_Gen_ASeqFrm) then
			status = 'old'
			access = 'sequential'
			form = 'formatted'
			action = 'readwrite'
			position = 'append'
		elseif(FileAccessType == PGSd_IO_Gen_ASeqUnf) then
			status = 'old'
			access = 'sequential'
			form = 'unformatted'
			action = 'readwrite'
			position = 'append'

		else
			ErrType = UNKNOWNFILEACCESSTYPE
			return
		endif
		
		tiedup = .TRUE.
d377 3
a379 1
		do unit = bottom_unit_num, top_unit_num
d381 47
a427 47
			if (.not. tiedup) then
				exit
			endif
		enddo

		if(tiedup) THEN
			ErrType = NOFREEUNITS
			return
		endif
			

		if(access /= 'direct') then
			open(unit=unit, access=access, action=action, form=form, &
			& position=position, status=status, file=myName, iostat=ErrType)
		else
			open(unit=unit, access=access, action=action, form=form, &
			& status=status, file=myName, iostat=ErrType)
		endif
		
		if(ErrType /= 0 .OR. PRINT_EVERY_OPEN) then
			call output( 'Fortran opening unit ', advance='no')
			call output(  unit, advance='yes')
			call output( 'access ' // access, advance='yes')
			call output( 'action ' // action, advance='yes')
			call output( 'form ' // form, advance='yes')
			call output( 'position ' // position, advance='yes')
			call output( 'status ' // status, advance='yes')
			call output( 'file ' // myName, advance='yes')
		endif
		
		if(ErrType /= 0) then
			call output( 'iostat ', advance='no')
			call output(  ErrType, advance='yes')
			call io_error('io error in MLSFiles: mls_io_gen_openF' // &
			& ' Fortran open', ErrType, myName)
		else
			theFileHandle = unit
		endif
			
	case default
		ErrType = UNKNOWNTOOLBOXMODE

	end select
	
	if(ErrType /= 0) then
		theFileHandle = FH_ON_ERROR
	endif
d429 1
a429 1
  END FUNCTION mls_io_gen_openF
d445 2
a446 2
  FUNCTION mls_io_gen_closeF(toolbox_mode, theFileHandle) &
  &  RESULT (ErrType)
d449 3
a451 3
    INTEGER(i4)  :: ErrType
    INTEGER(i4), INTENT(IN)  :: theFileHandle
    CHARACTER (LEN=*), INTENT(IN)   :: toolbox_mode
d455 12
a466 1
	LOGICAL, PARAMETER :: PRINT_EVERY_CLOSE=.TRUE.
d468 2
a469 25
	select case (LowerCase(toolbox_mode(1:2)))
	
	case('pg')
			ErrType = PGS_IO_Gen_CLoseF(theFileHandle)
			
	case('sw')
			ErrType = swclose(theFileHandle)
			
	case('gd')
			ErrType = gdclose(theFileHandle)
	
	case('cl')
			close(unit=theFileHandle, iostat=ErrType)		

		if(ErrType /= 0 .OR. PRINT_EVERY_CLOSE) then
			call output( 'Fortran closing unit ', advance='no')
			call output(  theFileHandle, advance='yes')
		endif
		
		if(ErrType /= 0) then
			call output( 'iostat ', advance='no')
			call output(  ErrType, advance='yes')
			call io_error('io error in MLSFiles: mls_io_gen_closeF' // &
			& ' Fortran close', ErrType, 'unknown')
		endif
d471 4
a474 2
	case default
		ErrType = UNKNOWNTOOLBOXMODE
d476 6
a481 1
	end select
d483 6
a488 1
  END FUNCTION mls_io_gen_closeF
d500 1
a500 1
  
a502 2
  
  SUBROUTINE split_path_name(full_file_name, path, name, slash)
d504 3
a506 1
	! Arguments
d508 38
a545 40
	character (len=*), intent(in) :: full_file_name
	character (len=*), intent(out) :: path
	character (len=*), intent(out) :: name
	character (len=1), optional, intent(in) :: slash
	
	! Local
	
	character (len=1) :: mySlash
	character (len=NameLEN) :: mirrored_ffn
	integer :: loc
	
	! Begin
	
	if(present(slash)) then
		mySlash = slash
	else
		mySlash = '/'
	endif
	
	if(len(full_file_name) <= 0) then
		path = ' '
		name = ' '
		return
	endif
	
	mirrored_ffn = Reverse(full_file_name)
	loc = INDEX(mirrored_ffn, mySlash)
	
	if(loc <= 0) then
		path = ' '
		name = adjustl(full_file_name)
	elseif(loc == 1) then
		path = adjustl(full_file_name)
		name = ' '
	else
		path = adjustl(Reverse(mirrored_ffn(loc:)))
		name = adjustl(Reverse(mirrored_ffn(:loc-1)))
	endif
	
  END SUBROUTINE split_path_name
d547 4
a550 2
!====================
END MODULE MLSFiles
d555 3
@


2.8
log
@fixed MAXFILENAMELENGTH to not core dump in toolbox
@
text
@d28 1
a28 1
   "$Id: MLSFiles.f90,v 2.7 2001/04/03 23:52:29 pwagner Exp $"
d58 5
a62 1
  ! If the FileName is not found, it sets ErrType=NAMENOTFOUND
d68 7
d76 1
a76 1
  & caseSensitive, ErrType, versionNum, debug) RESULT (thePC)
d86 1
d90 1
a90 1
	CHARACTER (LEN=MAXFILENAMELENGTH) :: MatchName, TryName
a118 6
	IF(PRESENT(versionNum)) THEN
		version = versionNum
	ELSE
		version = 1
	ENDIF

d124 1
d133 7
d141 1
a141 1
              & TryName)
d146 3
a148 1
						TryName = Capitalize(TryName)
d157 2
d160 3
a162 1
	ENDDO
a517 2
	character (len=NameLEN) :: mirrored_name
	character (len=NameLEN) :: mirrored_path
d556 3
@


2.7
log
@Added split_path_name
@
text
@d20 1
a20 1
  & PGS_IO_GEN_CloseF, PGS_IO_GEN_OpenF
d28 1
a28 1
   "$Id: MLSFiles.f90,v 2.6 2001/03/27 17:30:59 pwagner Exp $"
d31 2
a32 2
	! This needs to be twice NameLen becuase it may have a path prefixed
	INTEGER, PARAMETER :: MAXFILENAMELENGTH=2*NameLen
d65 1
a65 1
  & caseSensitive, ErrType, versionNum) RESULT (thePC)
d74 1
d82 13
d115 3
d120 6
d131 3
a133 3
		IF(.NOT. caseSensitive) THEN
			TryName = Capitalize(TryName)
		ENDIF
d538 3
@


2.6
log
@Added mls_io_gen_closeF
@
text
@d10 1
a10 1
   USE MLSStrings, only: Capitalize, LowerCase
d28 1
a28 1
   "$Id: MLSFiles.f90,v 2.5 2001/03/24 00:30:14 pwagner Exp $"
d448 61
d515 3
@


2.5
log
@Now complains only if an error, and then via output
@
text
@d7 1
a7 1
   USE HDFEOS, only: gdopen, swopen
d19 2
a20 1
  & PGSd_IO_Gen_ASeqFrm, PGSd_IO_Gen_ASeqUnf, PGS_IO_GEN_OpenF
d28 1
a28 1
   "$Id: MLSFiles.f90,v 2.4 2001/03/22 01:09:31 pwagner Exp $"
d31 3
a75 1
	INTEGER, PARAMETER :: MAXNAMELENGTH=NameLen
d77 1
a77 1
	CHARACTER (LEN=MAXNAMELENGTH) :: MatchName, TryName
d127 6
a132 1
  ! according to toolbox_mode
d174 2
a175 2
	INTEGER, PARAMETER :: KEYWORDLEN=12			! Length of keywords in OPEN(...)
	CHARACTER (LEN=NameLen) :: myName
d360 7
a366 7
			call output(  unit)
			call output( 'access ' // access)
			call output( 'action ' // action)
			call output( 'form ' // form)
			call output( 'position ' // position)
			call output( 'status ' // status)
			call output( 'file ' // myName)
d371 1
a371 1
			call output(  ErrType)
d389 59
d454 3
@


2.4
log
@Added file name to Fortran open statement
@
text
@d11 1
d27 1
a27 1
   "$Id: MLSFiles.f90,v 2.3 2001/03/21 00:48:43 pwagner Exp $"
d30 12
a71 2
	INTEGER, PARAMETER :: NAMENOTFOUND=-1
	INTEGER, PARAMETER :: INVALIDPCRANGE=NAMENOTFOUND-1
d164 1
a164 4
	INTEGER, PARAMETER :: UNKNOWNFILEACCESSTYPE=-999
	INTEGER, PARAMETER :: UNKNOWNTOOLBOXMODE=UNKNOWNFILEACCESSTYPE+1
	INTEGER, PARAMETER :: NOFREEUNITS=UNKNOWNTOOLBOXMODE+1
	INTEGER, PARAMETER :: MUSTSUPPLYFILENAMEORPC=NOFREEUNITS+1
a340 6
		print*, 'Fortran opening unit ', unit
		print*, 'access ', access
		print*, 'action ', action
		print*, 'form ', form
		print*, 'position ', position
		print*, 'status ', status
d350 19
a368 5
		print*, 'iostat ', ErrType
		call io_error('io error in MLSFiles: mls_io_gen_openF' // &
		& ' Fortran open', ErrType, myName)

		theFileHandle = unit
d387 3
@


2.3
log
@Corrected mls_io_gen_openF
@
text
@d8 1
d26 1
a26 1
   "$Id: MLSFiles.f90,v 2.2 2001/03/20 00:41:28 pwagner Exp $"
d342 1
a342 1
			& position=position, status=status, iostat=ErrType)
d345 1
a345 1
			& status=status, iostat=ErrType)
d349 2
d371 3
@


2.2
log
@Added mls_io_gen_openF
@
text
@d25 1
a25 1
   "$Id: MLSFiles.f90,v 2.1 2001/03/07 01:02:37 pwagner Exp $"
d153 5
a157 1
	INTEGER, PARAMETER :: NOFREEUNITS=UNKNOWNFILEACCESSTYPE+1
d162 1
a162 1
	CHARACTER (LEN=9) :: access, action, form, position, status
d165 5
d180 1
a180 1
	ELSE
d182 7
a188 2
		myPC = GetPCFromRef(FileName, PCBottom, PCTop, &
  & caseSensitive, returnStatus, versionNum)
d224 1
a224 2
	
	case default
d332 7
d341 1
a341 1
			& position=position, status=status)
d344 1
a344 1
			& status=status)
d346 4
d351 3
d355 4
d368 3
@


2.1
log
@First commit
@
text
@d7 11
a17 3
   USE MLSCommon, only: i4
   USE MLSStrings, only: Capitalize
  use SDPToolkit, only: Pgs_pc_getReference, PGS_S_SUCCESS, Pgs_smf_getMsg
d25 1
a25 1
   "$Id: MLSFiles.f90,v 2.3 2000/09/27 15:01:08 pumphrey Exp $"
d28 5
d60 1
a60 1
	INTEGER, PARAMETER :: MAXNAMELENGTH=132
d108 223
d337 3
@

