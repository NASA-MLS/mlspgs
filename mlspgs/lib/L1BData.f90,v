head	2.128;
access;
symbols
	v5-02-NRT-19:2.128
	v6-00:2.128
	v5-02-NRT-18:2.128
	v5-02:2.126
	v5-01-NRT-17:2.128
	v5-01-NRT-16:2.128
	v5-01-NRT-15:2.128
	v5-01-NRT-14:2.128
	neuralnetworks-1-0:2.128.0.4
	cfm-single-freq-0-1:2.128.0.2
	v5-01:2.126
	v5-00:2.126
	v4-23-TA133:2.124.0.2
	mus-emls-1-70:2.123.0.2
	rel-1-0-englocks-work:2.121.0.2
	VUMLS1-00:2.118
	VPL1-00:2.114
	V4-22-NRT-08:2.107
	VAM1-00:2.105
	V4-21:2.102.0.2
	V4-13:2.102
	V4-12:2.101
	V4-11:2.100
	V4-10:2.100
	V3-43:2.87
	M4-00:2.94
	V3-41:2.87
	V3-40-PlusGM57:2.87.0.2
	V2-24-NRT-04:2.76
	V3-33:2.89
	V2-24:2.76
	V3-31:2.89
	V3-30-NRT-05:2.88
	cfm-01-00:2.88
	V3-30:2.87
	V3-20:2.87
	V3-10:2.82
	V2-23-NRT-02:2.76
	V2-23:2.76
	V2-22-NRT-01:2.76
	V2-22:2.76
	V2-21:2.73
	V2-20:2.70
	V2-11:2.70
	V2-10:2.70
	V2-00:2.70
	V1-51:2.53
	V1-50:2.52
	V1-45:2.50
	V1-44:2.48
	V1-43:2.44
	V1-42:2.43
	V1-41:2.43
	V1-32:2.43
	V1-40:2.43
	V1-31:2.43
	V1-30:2.43
	V1-13:2.38
	V1-12:2.38
	V1-11:2.38
	V1-10:2.35
	newfwm-feb03:2.36.0.2
	V1-04:2.16
	V1-03:2.16
	V1-02:2.16
	V1-00:2.16
	newfwm-sep01:2.9.0.2
	V0-7:2.9
	V0-5-Level2:2.5
	V0-5-SIPS:2.2
	V0_1:1.11;
locks; strict;
comment	@# @;


2.128
date	2020.01.27.18.28.28;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2020.01.16.00.18.45;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2020.01.09.22.24.05;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2019.05.13.20.55.49;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2018.08.03.23.23.08;	author vsnyder;	state Exp;
branches;
next	2.123;

2.123
date	2018.04.19.23.41.09;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2018.04.19.02.00.36;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2018.03.05.19.25.38;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2017.11.03.19.59.37;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2017.10.18.22.46.52;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2017.02.09.23.46.46;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2016.10.19.00.09.15;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2016.10.11.23.27.18;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2016.10.05.20.13.58;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2016.08.12.00.35.18;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2016.08.09.18.15.29;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2016.07.28.19.23.10;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2016.07.28.01.42.27;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2016.07.22.20.03.52;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2016.07.22.00.22.58;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2016.07.21.20.27.06;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2016.04.20.00.05.15;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2016.03.23.00.19.31;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2015.07.31.20.40.34;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2015.07.14.23.19.32;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2015.03.28.01.07.53;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2014.09.04.23.46.21;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2014.07.23.21.57.59;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2014.03.07.19.12.49;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2014.01.09.00.25.06;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2013.09.24.23.27.14;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2013.08.31.01.24.53;	author vsnyder;	state Exp;
branches;
next	2.96;

2.96
date	2013.06.29.00.16.37;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2013.05.31.00.40.31;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2012.09.11.18.53.40;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2012.09.05.21.41.20;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2012.06.07.23.57.17;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2011.07.15.23.31.06;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2011.07.07.00.30.03;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2011.02.05.01.37.05;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2010.03.12.21.12.07;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2010.01.11.18.33.19;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2009.10.30.23.03.50;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2009.08.24.18.34.45;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2009.08.17.16.53.40;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2009.08.04.20.43.18;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2009.06.16.17.15.55;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2008.06.06.22.52.21;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2008.02.08.00.00.04;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2008.02.07.18.48.16;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2008.01.07.21.37.05;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2007.08.13.17.36.13;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2007.07.17.00.25.50;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2007.06.21.00.49.51;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2007.02.07.20.56.38;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2007.01.26.23.58.02;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2006.11.22.18.12.37;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2006.04.11.23.13.29;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2006.02.06.22.54.51;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2006.01.26.00.33.09;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2006.01.04.20.31.18;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2005.11.18.01.25.16;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2005.11.17.20.10.44;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2005.10.22.00.50.30;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2005.10.19.20.47.29;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2005.10.18.23.05.11;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2005.09.21.23.12.28;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2005.08.05.20.36.29;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2005.07.21.23.36.28;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2005.06.22.17.25.49;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2005.06.14.20.37.54;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2005.06.01.17.29.06;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2005.05.31.17.50.20;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2005.05.12.20.44.52;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2005.01.12.23.59.45;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2004.12.21.22.05.14;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2004.12.14.21.37.11;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2004.08.26.22.34.41;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2004.08.19.00.10.43;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2004.08.17.23.47.48;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2004.08.16.17.04.23;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2004.08.04.23.19.01;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2004.08.03.17.59.35;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2004.03.12.00.36.33;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2003.09.12.16.37.10;	author cvuu;	state Exp;
branches;
next	2.42;

2.42
date	2003.05.07.01.05.57;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2003.05.05.23.00.04;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2003.04.02.23.52.34;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2003.04.02.00.38.09;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2003.03.10.17.27.10;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2003.03.07.00.35.15;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2003.02.12.21.49.06;	author pwagner;	state Exp;
branches
	2.36.2.1;
next	2.35;

2.35
date	2002.12.11.22.22.15;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2002.12.10.00.42.15;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2002.12.06.01.10.08;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2002.12.05.19.43.47;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2002.12.04.01.15.11;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2002.12.02.23.38.32;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2002.11.22.21.48.54;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2002.11.13.01.02.16;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2002.10.29.18.50.03;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2002.10.10.23.50.57;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2002.10.09.00.05.02;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2002.10.07.23.21.20;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2002.10.05.00.09.16;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2002.10.03.23.04.11;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2002.09.27.23.37.54;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2002.09.27.00.00.39;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2002.07.23.23.16.06;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2002.07.01.23.48.00;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2002.05.28.22.34.47;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2002.01.09.23.42.23;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2001.11.01.21.02.31;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2001.10.26.23.11.10;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2001.10.25.23.31.28;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2001.10.23.22.44.15;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.10.23.17.09.04;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.10.03.22.50.03;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.06.01.02.06.45;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.05.30.23.51.48;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.05.06.20.53.47;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2001.05.04.22.51.06;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2001.05.03.23.58.38;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.05.03.23.16.57;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.05.03.22.32.25;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2001.03.03.00.06.23;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.04.01.27.34;	author vsnyder;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.17.41.06;	author dcuddy;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.06.21.11.55;	author vsnyder;	state Exp;
branches;
next	;

2.36.2.1
date	2003.03.27.23.21.31;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.128
log
@Simplified AssembleL1BQtyName
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module L1BData

  ! Reading and interacting with Level 1B data (HDF4 or HDF5)

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, &
    & Test_Allocate, Test_DeAllocate
  use HyperSlabs, only: EssentiallyEqual
  use Diff_1, only: Diff, Diff_Fun
  use Dump_Options, only: NameOnEachLine, StatsOnOneLine
  use Dump_0, only: Dump
  use Dump_1, only: Dump
  use HDF, only: DFACC_Rdonly, SFGInfo, SFN2Index, SFSelect, &
    & SFRData_F90, &
    & SFRCData, SFENDACC, DFNT_Char8, DFNT_Int32, DFNT_Float64, &
    & DFNT_Float32
  use HighOutput, only: OutputNamedValue
  use IEEE_Arithmetic, only: IEEE_Is_Finite
  use, Intrinsic :: ISO_C_Binding, only: C_Intptr_T, C_Loc
  use Intrinsic, only: L_HDF
  use Lexer_Core, only: Print_Source
  use Machine, only: Crash_Burn
  use MLSCommon, only: MLSFile_T, &
    & UnDefinedValue, FileNameLen, NameLen
  use MLSFiles, only: FileNotFound, HDFVersion_4, HDFVersion_5, &
    & AddFileToDatabase, GetMLSFileByType, InitializeMLSfile, &
    & MLS_OpenFile, MLS_CloseFile
  use MLSFinds, only: FindFirst
  use MLSHDF5, only: MaxNDSNames, GetAllHDF5DSNames, SaveAsHDF5DS
  use MLSKinds, only: R4, R8
  use MLSMessageModule, only: MLSMSG_Error, &
    & MLSMSG_L1BRead, MLSMSG_Warning, MLSMessage
  use MLSStrings, only: Indexes, Reverse, Streq
  use MLSStringLists, only: NumStringElements, ReplaceSubstring, SwitchDetail
  use Moretree, only: Get_Field_Id
  use Output_M, only: NewLine, Output
  use String_Table, only: Get_String
  use Toggles, only: Gen, Levels, Switches, Toggle
  use Trace_M, only: Trace_Begin, Trace_End
  use Tree, only: Nsons, Sub_Rosa, Subtree, Dump_Tree_Node, Where

  implicit none

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (data types and parameters)
! L1BData_T                       Quantities from an L1B data file
! PRECISIONSUFFIX                 Suffix stuck on end of array name if precision
! NOERROR                         ReadL1BData had no error
! NOCOUNTERMAFINDX                ReadL1BData unable to find counterMAF index
! NOCOUNTERMAFID                  ReadL1BData unable to find counterMAF sds
! NOQUANTITYINDEX                 ReadL1BData unable to find quantity index
! NODATASETID                     ReadL1BData unable to find quantity sds
! NODATASETRANK                   ReadL1BData unable to find quantity rank
! FIRSTMAFNOTFOUND                ReadL1BData unable to requested first MAF
! LASTMAFNOTFOUND                 ReadL1BData unable to requested last MAF
! CANTREADCOUNTERMAF              ReadL1BData unable to read counterMAF
! CANTALLOCATECHARS               ReadL1BData unable to allocate memory
! CANTREAD3DFIELD                 ReadL1BData unable to read sds
! UNKNOWNDATATYPE                 ReadL1BData unable to read data type
! CANTENDCOUNTERMAF               ReadL1BData unable to end access to counterMAF
! CANTENDQUANTITY                 ReadL1BData unable to end access to quantity

!     (subroutines and functions)
! AssembleL1BQtyName              Returns Quantity Name depending on hdfVersion
! ContractL1BData                 Contract an l1bData to just a range of mafs
! ConvertL1BData                  Convert an l1bData from integer-valued to d.p.
! ConvertL1BOADSNames             Convert L1BOA DS names between hdf versions
! CpL1BData                       Duplicate an l1bData
! DeallocateL1BData               Called when an l1bData is finished with
! DupL1BData                      Duplicate an l1bData
! Diff                            Diff two l1b quantities
! Dump                            Print facts about l1brad quantity
! Findl1bdata                     Which file handle contains a given sd name
! FindMaxMAF                      What is the maximum MAF number in the file?
! Getl1BFile                      Which MLSFile contains a given sd name
!                                  (or attribute)
! L1BOAHDF4DSName                 Convert L1BOA DS names from HDF5 to HDF4
! L1BOAHDF4DSName                 Convert L1BOA DS names from HDF4 to HDF5
! L1BOASetup                      From l2cf, open, and save l1boa file info
! L1BRadSetup                     From l2cf, open, and save l1brad file info
! ReadL1BData                     Read all info concerning a l1brad quantity
! ReadL1BAttribute                Read attributes
! === (end of toc) ===

! === (start of api) ===
!     (user-defined types)
! L1BData_T (char L1BName, int FirstMAF, int NoMAFs, int MaxMIFs, int NoAuxInds,
!             *int CounterMAF(:),
!             *char CharField(:,:,:),
!             *r8   DpField(:,:,:),
!             *int  IntField(:,:,:),
!             )

!     (subroutines and functions)
! char*64 AssembleL1BQtyName (char name, int hdfVersion, log isTngtQty,
!                         [char InstrumentName] )
! ConvertL1BData ( l1bData_T l1bDatain , l1bData_T l1bDataOut, int noMAFs,
!   int firstMAF, int lastMAF, int firstChannel, int lastChannel,
!   int firstMIF, int lastMIF )
! ConvertL1BData ( l1bData_T l1bData )
! ConvertL1BOADSNames ( char* HDF4name, char* HDF5Name, char* direction )
! CpL1BData ( MLSFile_t L1BFile1, MLSFile_t L1BFile2, char QuantityName, &
!    [char NewName], [log l2aux] )
! DupL1BData ( l1bData_T l1bData1, l1bData_T l1bData2, int offsetMAF )
! DeallocateL1BData (l1bData_T l1bData)
! Diff (l1bData_T l1bData1, l1bData_T l1bData2, int details, &
!   [char options], [int numDiffs], [int mafStart], [int mafEnd])
! Dump (l1bData_T l1bData, int details)
! int FindL1BData (int files(:), char fieldName, [int hdfVersion])
! int FindMaxMAF (MLSFile_t file, [int minMAF])
! MLSFile_T GetL1BFile (MLSFile_t filedatabase(:), char fieldName, [char options])
! char* L1BOAHDF4DSName ( char* HDF5Name )
! char* L1BOAHDF5DSName ( char* HDF4Name )
! L1boaSetup (int root, MLSFile_t filedatabase(:), int f_file, [int hdfVersion])
! L1bradSetup (int root, MLSFile_t filedatabase(:), int f_file, [int hdfVersion])
! ReadL1BData (int L1FileHandle, char QuantityName, l1bData_T l1bData,
!               int NoMAFs, int Flag, [int FirstMAF], [int LastMAF],
!               [log NeverFail], [int hdfVersion])
! ReadL1BAttribute (int L1FileHandle, value(:), nchar AttributeName,
!               int Flag, [int hdfVersion])
! === (end of api) ===

  private

  public :: L1BData_T, NameLen, PrecisionSuffix, &
    & AllocateL1BData, AssembleL1BQtyName, &
    & CheckForCorruptFileDatabase, ContractL1BData, &
    & ConvertL1BData, ConvertL1BOADSNames, CpL1BData, &
    & DeallocateL1BData, Diff, Dump, DupL1BData, &
    & FindL1BData, FindMaxMAF, GetL1BFile, &
    & L1BOAHDF4DSName, L1BOAHDF5DSName, L1BRadSetup, L1BOASetup, PadL1BData, &
    & ReadL1BAttribute, ReadL1BData

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: L1BData.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

  interface Diff
    module procedure DiffL1BData
  end interface

  interface Dump
    module procedure DumpL1BData
  end interface

  interface FindMaxMAF
    module procedure FindMaxMAF_arr, FindMaxMAF_sca
  end interface

  interface ReadL1BAttribute
    module procedure ReadL1BAttribute_intarr1, &
      & ReadL1BAttribute_dblarr1
  end interface

  interface ReadL1BData
    module procedure ReadL1BData_FileHandle
    module procedure ReadL1BData_MLSFile
  end interface

  ! Parameters
  ! suffix of sd precision; check against 'grep -i precision l1/OutputL1B.f90'
  character  (len=*), parameter :: PRECISIONSUFFIX = ' precision'

  ! If TRUE, treats l1brad and l2aux files the same
  ! Among other things, this means forgiving absence of counterMAF
  ! so we may read l2aux and l1brad files alike
  logical, parameter            :: JUSTLIKEL2AUX = .true.

  ! Assume l1b files w/o explicit hdfVersion field are this
  ! 4 corresponds to hdf4, 5 to hdf5 in L2GP, L2AUX, etc.
  integer, parameter :: L1BDEFAULT_HDFVERSION = HDFVERSION_5

  ! Unless the following is true, a subgroup named 'tp' will be
  ! created under each instrument Module for hdf5 versions
  ! (An early idea we later repented of)
  logical, parameter :: DROPTPSUBGROUP = .true.

  ! No MAF number can ever be this big
  integer, parameter :: BIGGESTMAFCTR = huge(0)/2

  ! This data type is used to store quantities from an L1B data file.
  ! (This next param may need to be increased)
  integer, parameter :: MaxCharFieldLen = 128  ! max char field length

  type L1BData_T
    character (len=namelen) :: L1BName ! Name of field in file
    character (len=16) :: data_type     ! 'character', 'double', or 'integer'
    integer :: FirstMAF                 ! First major frame read (usu. 0)
    integer :: FirstMAFCtr              ! depends on date
    integer :: LastMAFCtr               ! depends on date
    integer :: NoMAFs                   ! # of MAFs read
    integer :: MaxMIFs                  ! Max # of MIFs/MAF in SD array
    integer :: NoAuxInds                ! # of auxilliary indices
    integer :: TrueRank                 ! # necessary indices (e.g., 1 for MAFs)
    character (len=16) :: NameInst = ' '

    integer, dimension(:), pointer :: CounterMAF => NULL() ! dimensioned (noMAFs)
    character(len=MaxCharFieldLen), &
      &        dimension(:,:,:), pointer :: CharField => NULL()
    real(r8),  dimension(:,:,:), pointer :: DpField => NULL()
    integer,   dimension(:,:,:), pointer :: IntField => NULL()
    ! all the above dimensioned (noAuxInds,maxMIFs,noMAFs)
    ! logical :: mustPad                  ! Gaps in counterMAF
  contains
    final :: DeallocateL1BData
  end type L1BData_T

  integer :: Error            ! Error level -- 0 = OK
  logical, parameter           :: DEEBUG = .FALSE.

  ! Error flags returned from ReadL1BData when NeverFail=TRUE
  integer, public, parameter :: NOERROR =            0
  integer, public, parameter :: NOCOUNTERMAFINDX =   NOERROR + 1
  integer, public, parameter :: NOCOUNTERMAFID =     NOCOUNTERMAFINDX + 1
  integer, public, parameter :: NOQUANTITYINDEX =    NOCOUNTERMAFID + 1
  integer, public, parameter :: NODATASETID =        NOQUANTITYINDEX + 1
  integer, public, parameter :: NODATASETRANK =      NODATASETID + 1
  integer, public, parameter :: FIRSTMAFNOTFOUND =   NODATASETRANK + 1
  integer, public, parameter :: LASTMAFNOTFOUND =    FIRSTMAFNOTFOUND + 1
  integer, public, parameter :: CANTREADCOUNTERMAF = LASTMAFNOTFOUND + 1
  integer, public, parameter :: CANTREADSCALARDS   = CANTREADCOUNTERMAF + 1
  integer, public, parameter :: CANTALLOCATECHARS =  CANTREADSCALARDS + 1
  integer, public, parameter :: CANTREAD3DFIELD =    CANTALLOCATECHARS + 1
  integer, public, parameter :: UNKNOWNDATATYPE =    CANTREAD3DFIELD + 1
  integer, public, parameter :: CANTENDCOUNTERMAF =  UNKNOWNDATATYPE + 1
  integer, public, parameter :: CANTENDQUANTITY =    CANTENDCOUNTERMAF + 1

  ! We plan to use this 2-d array to convert hdf5-formatted l1boa ds names
  ! to the older hdf4 format.
  include 'l1boa_dsnames.f9h'
contains ! ============================ MODULE PROCEDURES =======================

  ! --------------------------------------------  AllocateL1BData  -----
  subroutine AllocateL1BData ( l1bData, &
    & indims, trueRank, datatype, &
    & L1bDataSibling )
    ! Allocate arrays in l1bData type to match one of
    !   indims(1:3)       explicit sizes
    !   L1bDataSibling    L1bDataSibling%dims(1:3)
    ! Their values will be initialized as undefined value or as ' '
    type( L1BData_T ), intent(out) :: L1bData
    integer, dimension(3), optional,  intent(in) :: indims
    integer, optional, intent(in) :: trueRank
    character(len=*), optional, intent(in) :: datatype
    type( L1BData_T ), optional, intent(in) :: L1bDataSibling
    ! Internal variables
    integer :: noMAFs
    character(len=16) :: myDataType
    integer :: rank
    integer, dimension(3) :: dims

    ! Executable code
    if ( present(datatype) ) then
      myDataType = datatype
      rank = trueRank
      dims = indims
      noMAFs = dims(3)
    else if( present(L1bDataSibling) ) then
      myDataType = L1bDataSibling%data_type
      rank = L1bDataSibling%trueRank
      noMAFs = L1bDataSibling%noMAFs
      if ( associated(L1bDataSibling%charField)) then
        dims = shape(L1bDataSibling%charField)
      else if ( associated(L1bDataSibling%intField)) then
        dims = shape(L1bDataSibling%intField)
      else if ( associated(L1bDataSibling%dpField)) then
        dims = shape(L1bDataSibling%dpField)
      else
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'allocatel1bData was passed L1bDataSibling w/o allocating it' )
      end if
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'allocatel1bData must be passed either datatype or L1bDataSibling' )
    end if
    if ( present(indims) ) then
      dims = indims
      noMAFs = dims(3)
    end if
    ! print *, 'rank in allocatel1bdata ', rank
    ! print *, 'dims in allocatel1bdata ', dims
    ! print *, 'noMAFs in allocatel1bdata ', noMAFs
    if ( any(dims < 1) ) then
      call output('NoMAFs ', advance='no')
      call output(NoMAFs , advance='yes')
      call output('dims ', advance='no')
      call output(dims , advance='yes')
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'allocatel1bData encountered illegal dims' )
    end if
    call allocate_test ( l1bData%counterMAF, noMAFs, 'l1bData%counterMAF', &
      & ModuleName )
    l1bData%counterMAF = int(undefinedValue)
    l1bdata%data_type = myDataType
    l1bdata%noMAFs = noMAFs
    select case( myDataType(1:1) )
    case ( 'c' ) ! character
      call allocate_test ( l1bData%charField, dims(1), dims(2), dims(3), &
        & 'l1bData%charField', ModuleName )
      l1bData%charField = ''
    case ( 'i' ) ! integer
      call allocate_test ( l1bData%intField, dims(1), dims(2), dims(3), &
        & 'l1bData%intField', ModuleName )
      l1bData%intField = int(undefinedValue)
    case ( 'd', 'r' ) ! double
      call allocate_test ( l1bData%dpField, dims(1), dims(2), dims(3), &
        & 'l1bData%dpField', ModuleName )
      l1bData%dpField = undefinedValue
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'datatype not recognized in allocating l1bdata field' )
    end select
    if ( .not. present(L1bDataSibling) ) return
    l1bData%L1BName                = l1bDataSibling%L1BName
    l1bData%FirstMAF               = l1bDataSibling%firstMAF
    l1bData%FirstMAFCtr            = l1bDataSibling%firstMAFCtr
    l1bData%LastMAFCtr             = l1bDataSibling%LastMAFCtr
    l1bData%MaxMIFs                = l1bDataSibling%MaxMIFs
    l1bData%NoAuxInds              = l1bDataSibling%NoAuxInds
    l1bData%TrueRank               = l1bDataSibling%TrueRank
    l1bData%NameInst               = l1bDataSibling%NameInst
  end subroutine AllocateL1BData

  ! -----------------------------------------  AssembleL1BQtyName  -----
  function AssembleL1BQtyName ( name, hdfVersion, isTngtQty, &
    & InstrumentName ) &
    & result(QtyName)
    use MLSStrings, only: IsDigits
    ! Returns a QtyName to be found in the L1b file
    ! If given InstrumentName, name should be a fragment:
    ! e.g., name='VelECI' and InstrumentName='sc'
    ! Without InstrumentName, name should be complete (in hdf4-style)
    ! e.g., name='scVelECI' or name='R1A:118.B1F:PT.S0.FB25-1'
    ! and isTngtQty is simply ignored
    !
    ! we should rewrite it using the L1BOADSNames array.
    character(len=*), intent(in)  :: name        ! bare name; e.g. SolarZenith
    integer, intent(in)           :: hdfVersion  ! which QtyName must conform to
    logical, intent(in)           :: isTngtQty   ! T or F (ignored)
    character(len=*), intent(in), optional :: InstrumentName ! e.g. THz
    ! logical, intent(in), optional :: dont_compress_name ! Won't use
    character(len=Namelen)        :: QtyName

    ! Private
    character(len=Namelen)        :: HDF4Name
    character(len=Namelen)        :: HDF5Name
    integer                       :: indx
    ! Executable
    ! Are we a radiance?
    if ( name(1:1) == 'R' .and. IsDigits(name(2:2) ) ) then
      QtyName = Name
      return
    elseif ( name == 'counterMAF' ) then
      QtyName = Name
      return
    endif
    ! Apparently we are an l1boa quantity
    ! Were we given an instrument name?
    if ( present(InstrumentName) ) then
      HDF5Name = trim(InstrumentName) // '/' // Name
    else
      HDF5Name = Name
    endif
    ! print *, 'HDF5Name: ', trim(HDF5Name)
    if ( hdfVersion == HDFVersion_4 ) then
      QtyName = L1BOAHDF4DSName( HDF5Name )
      ! print *, 'QtyName: ', trim(QtyName)
      if ( QtyName == 'unknown' ) QtyName = Name
    else
      HDF4Name = Name
      QtyName = L1BOAHDF5DSName( HDF4Name )
      if ( QtyName == 'unknown' ) QtyName = HDF5Name
    endif
  end function AssembleL1BQtyName

  function AssembleL1BQtyName_old ( name, hdfVersion, isTngtQty, &
    & InstrumentName, dont_compress_name ) &
    & result(QtyName)
    use MLSStrings, only: CompressString, Lowercase
    ! Returns a QtyName to be found in the L1b file
    ! If given InstrumentName, name should be a fragment:
    ! e.g., name='VelECI' and InstrumentName='sc'
    ! Without InstrumentName, name should be complete (in hdf4-style)
    ! e.g., name='scVelECI' or name='R1A:118.B1F:PT.S0.FB25-1'
    ! and isTngtQty is simply ignored
    !
    ! This is flaky and difficult to maintain as currently written;
    ! we should rewrite it using the L1BOADSNames array.
    character(len=*), intent(in) :: name        ! bare name; e.g. SolarZenith
    integer, intent(in)          :: hdfVersion  ! which QtyName must conform to
    logical, intent(in)          :: isTngtQty   ! T or F
    character(len=*), intent(in), optional :: InstrumentName ! e.g. THz
    logical, intent(in), optional :: dont_compress_name
    character(len=namelen)       :: QtyName

    ! Private
    character(len=1), dimension(HDFVersion_4:HDFVersion_5), parameter :: &
      heads =       (/ ' ', '/' /), &
      instr_tails = (/ '.', '/' /), &
      tp_tails =    (/ ' ', '/' /)
    logical, parameter     :: DEEBUG = .false.
    character(len=1)       :: head
    character(len=1)       :: instr_tail
    character(len=1)       :: tp_tail
    character(len=16)      :: my_instrument
    integer                :: p
    character(len=namelen) :: the_rest
    logical                :: is_a_signal
    logical                :: compress
    ! Executable code
    compress = .true.
    if ( present(dont_compress_name) ) compress = .not. dont_compress_name
    is_a_signal = (NumStringElements(trim(name), .true., ':') > 2)
    if ( DEEBUG ) then
      print *, 'name: ', trim(name)
      print *, 'hdfVersion: ', hdfVersion
      print *, 'isTngtQty: ', isTngtQty
      print *, 'is a signal: ', is_a_signal
      if ( present(InstrumentName) ) print *, 'Instrument: ', trim(InstrumentName)
    end if
    my_instrument = ''
    if ( present(InstrumentName) ) then
      my_instrument = instrumentName
      if ( my_instrument == 'SC' ) my_instrument = 'sc'
    end if
    head = heads(hdfVersion)
    instr_tail = instr_tails(hdfVersion)
    tp_tail = tp_tails(hdfVersion)
    if ( hdfVersion == HDFVERSION_4 .and. my_instrument == 'sc' ) instr_tail= ''
    if ( DEEBUG ) then
      print *, 'my_instrument: ', trim(my_instrument)
    endif
    if ( present(InstrumentName) ) then
      QtyName = head // trim(my_instrument) // instr_tail
    else if ( is_a_signal .or. hdfVersion /= HDFVERSION_5 ) then
      QtyName = head
    else
      ! Need only to convert complete hdf4-name to hdf5-name
      ! This means we must parse hdf4-name fully, however
      QtyName = head
      ! Do we match the pattern 'Instrument.tpItem'
      if ( streq(name, '*.tp*', options='-wc' ) ) then
        p = index( name, '.tp' )
        my_instrument = name(:p-1)
        the_rest = name(p+3:)
      ! Is there an instrument prefixed to name?
      elseif ( name(1:2) == 'sc' ) then
        my_instrument = 'sc'
        the_rest = name(3:)
      else
        my_instrument = ' '
        the_rest = name
      end if
      ! 2nd--Does the_rest start with 'tp'?
      if ( my_instrument == ' ' ) then
        QtyName = '/' // trim(name)
      else if ( the_rest(1:2) /= 'tp' ) then
        QtyName = '/' // trim(my_instrument) // &
          & '/' // trim(the_rest)
      else if ( DROPTPSUBGROUP .and. HDFVersion /= HDFVersion_4 ) then
        QtyName = '/' // trim(my_instrument) // &
          & '/' // trim(the_rest(3:))
      else
        QtyName = '/' // trim(my_instrument) // &
          & '/' // 'tp' // &
          & '/' // trim(the_rest(3:))
      end if
      ! We're done
      if ( DEEBUG ) then
        print *, 'converted name: ', trim(QtyName)
      end if
      call restoreHDF4Dot ( QtyName )
      return
    end if
    if ( isTngtQty .and. Lowercase(my_Instrument) /= 'sc' ) then
      if ( DROPTPSUBGROUP .and. hdfVersion == HDFVERSION_5 ) then
        QtyName = trim(QtyName)
      else
        QtyName = trim(QtyName) // 'tp' // tp_tail
      end if
    end if
    QtyName = trim(QtyName) // trim(name)
    if ( compress ) QtyName = CompressString(QtyName)
    if ( DEEBUG ) then
      print *, 'Before restoring dot: ', trim(QtyName)
    end if
    call restoreHDF4Dot ( QtyName )
    ! No name should begin with a dot
    if ( QtyName(1:1) == '.' ) QtyName = QtyName(2:)
    if ( DEEBUG ) then
      print *, 'more converted name: ', trim(QtyName)
    end if
  contains
    subroutine restoreHDF4Dot ( name )
      ! If hdf4, make certain the "." is part of the dataset name, e.g. 
      !               GHz.tpGeodAngle
      ! If hdf5, make certain "/" is not followed by "tp", e.g. 
      !               not /GHz/tpGeodAngle but /GHz/GeodAngle
      ! Dummy arg
      character(len=*), intent(inout)     :: name
      ! Internal variable
      integer                             :: i
      character(len=len(name))            :: temp
      ! Executable
      if ( hdfVersion == HDFVERSION_5 ) then
        i = index(name, '/tp')
        if ( i > 0 ) name = name(:i) // name(i+3:)
      else
        if ( index(name, 'tptp' ) > 0 ) then
          temp = name
          call ReplaceSubString ( temp, name, 'tptp', 'tp' )
        endif
        if ( index(name, '.tp') > 0 ) return
        if ( index(name, 'tp') < 1 ) return
        ! OK, we apparently have an undotted tp in name
        ! so we'll simply insert a "." before it
        ! call output( 'Restored the dot in ' // trim(name), advance='yes' )
        i = index( name, 'tp' )
        name = name(:i-1) // '.' // name(i:)
      endif
    end subroutine restoreHDF4Dot
  end function AssembleL1BQtyName_old

  ! --------------------------------------------  CheckForCorruptFileDatabase  -----
  subroutine CheckForCorruptFileDatabase ( FileDatabase )
    ! Check whether filedatabase has become corrupted
    type (MLSFile_T), dimension(:), pointer, optional ::     FILEDATABASE
    ! Internal variables
    character(len=1024) :: DSNames
    type (MLSFile_T), pointer :: L1BFile

    ! Executable code
    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    call output ( 'Checking file ' // trim(L1BFile%name) // ' for corrupt database', &
                & advance='yes' )
    if ( L1BFile%HDFVersion == HDFVersion_5 ) then
      call GetAllHDF5DSNames ( L1BFile, DSNames )
      call Dump ( DSNames, 'DSNames from MLSFile type' )
      call newLine
      !call GetAllHDF5DSNames ( L1BFile%name, '/', DSNames )
      !call Dump ( DSNames, 'DSNames from MLSFile name' )
      !call newLine
      ! call crash_burn
    else
      call output ( 'Unable to check HDF4 file', advance='yes' )
    end if
  end subroutine CheckForCorruptFileDatabase

  ! --------------------------------------------  ContractL1BData  -----
  subroutine ContractL1BData ( L1BDataIn, L1BDataOut, noMAFs, &
    & firstMAF, lastMAF, firstChannel, lastChannel, firstMIF, lastMIF )
    ! Contract full l1bdataIn to just those mafs
    ! beginning with firstMAF (if present) and ending with lastMAF
    ! Remember 1st maf of full l1bData is numbered 0
    ! (I disapprove, but nobody ever asks my opinion)

    ! Perhaps related to this source of confusion, is the following:
    ! What do we do when the lastMAF blows past the end of l1bDataIn?
    ! For now, we'll try to keep noMAFs correct, but scoot everything down
    ! Dummy arguments
    type(L1BData_T), intent(in)  :: L1BDataIn
    type(L1BData_T), intent(out) :: L1BDataOut
    integer, optional, intent(in):: firstMAF ! Remember, 1st of full set is 0
    integer, optional, intent(in):: lastMAF
    integer, optional, intent(in):: firstChannel
    integer, optional, intent(in):: lastChannel
    integer, optional, intent(in):: firstMIF
    integer, optional, intent(in):: lastMIF
    integer, intent(out)         :: NoMAFs
    ! Internal variables
    integer, dimension(3) :: dims
    integer :: maf
    integer :: mafOffSet
    integer :: myFirstMAF
    integer :: myLastMAF
    integer :: rank
    logical, parameter :: DEEBug = .false.
    ! Executable
    myFirstMAF = 0
    if ( present(firstMAF) ) then
      call output( 'Should not print, but who knows?', advance='yes' )
      myFirstMAF = firstMAF
    end if
    myLastMAF = l1bDataIn%NoMAFs - l1bDataIn%firstMAF - 1
    if ( present(lastMAF) ) myLastMAF = lastMAF
    if ( associated(l1bDataIn%charField)) then
      dims = shape(l1bDataIn%charField)
    else if ( associated(l1bDataIn%intField)) then
      dims = shape(l1bDataIn%intField)
    else if ( associated(l1bDataIn%dpField)) then
      dims = shape(l1bDataIn%dpField)
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Contractl1bData was passed l1bDataIn w/o allocating it' )
    end if
    noMAFs = myLastMAF - myFirstMAF + 1
    dims(3) = noMAFs
    rank = l1bDataIn%trueRank
    l1bDataOut%noMAFs = noMAFs
    l1bDataOut%firstMAF = myFirstMAF
    if ( present(firstChannel) .and. present(lastChannel) ) &
      & dims(1) = lastChannel - firstChannel + 1
    if ( present(firstMIF) .and. present(lastMIF) ) &
      & dims(1) = lastMIF - firstMIF + 1
    if ( DEEBug ) print *, 'Preparing to contract ', trim(l1bDataIn%L1BName)
    if ( DEEBug ) print *, 'rank ', rank
    if ( DEEBug ) print *, 'NoMAFs ', NoMAFs
    if ( DEEBug ) print *, 'l1b(in)NoMAFs ', l1bDataIn%NoMAFs
    if ( DEEBug ) print *, 'dims ', dims
    if ( DEEBug ) print *, 'min(counterMAF) ', myminval(l1bDataIn%counterMAF)
    if ( DEEBug ) print *, 'min(dpField) ',minval(l1bDataIn%dpField(1,1,:))
    if ( DEEBug ) print *, 'max(dpField) ',maxval(l1bDataIn%dpField(1,1,:))
    call allocateL1BData ( l1bDataOut, dims, L1bDataSibling=l1bDataIn )
    mafOffSet = myFirstMAF
    if ( mafOffSet+NoMAFs > size(l1bDataIn%counterMAF) ) &
      & mafOffSet = size(l1bDataIn%counterMAF) - NoMAFs
    do maf=1, NoMAFs
      l1bDataOut%counterMAF(maf) = l1bDataIn%counterMAF(mafOffSet+maf)
      call cpField(l1bDataIn, mafOffSet+maf, l1bdataOut, maf)
    end do
    l1bDataOut%firstMAFCtr = myminval(l1bDataOut%counterMAF)
    l1bDataOut%lastMAFCtr = maxval(l1bDataOut%counterMAF)
  end subroutine ContractL1BData

  ! --------------------------------------------  ConvertL1BData  -----
  subroutine ConvertL1BData ( L1BData )
    ! Convert an l1bdatafrom integer type to d.p.
    type(L1BData_T), intent(inout)  :: L1BData
    ! Internal variables
    integer, dimension(3) :: dims
    integer :: rank
    logical, parameter :: DEEBug = .false.
    ! Executable
    dims = shape(l1bData%intField)
    call allocate_test ( l1bData%dpField, dims(1), dims(2), dims(3), &
      & 'l1bData%dpField', ModuleName )
    l1bData%dpField = l1bData%intField
    call deallocate_test ( l1bData%intField, 'l1bData%intField', ModuleName )
  end subroutine ConvertL1BData

  ! --------------------------------------------  ConvertL1BOADSNames  -----
  subroutine ConvertL1BOADSNames ( HDF4name, HDF5Name, direction )
    ! Convert an l1boa name from how it appears in an hdf5-formatted file
    ! to the name we used in the older hdf4 format or vice versa.
    ! Useful only in retrievals based on sids radiances
    ! direction             conversion
    ! ---------             ----------
    !   5to4            HDF5Name -> HDF4Name
    !   4to5            HDF4Name -> HDF5Name
    character(len=*), intent(inout)     :: HDF5name
    character(len=*), intent(inout)     :: HDF4name
    character(len=*), intent(in)        :: direction ! '5to4' or '4to5'
    ! Internal variables
    character                           :: goal
    integer                             :: i
    ! Executable
    goal = Reverse(trim(direction)) ! '4' or '5'
    select case( goal )
    case ( '4' )
      HDF4Name = 'unknown'
      i = FindFirst( L1BOADSNames(2,:), HDF5Name )
      ! print *, 'HDF5Name, i', trim(HDF5Name), i
      if ( i > 0 ) HDF4Name = L1BOADSNames(1,i)
    case ( '5' )
      HDF5Name = 'unknown'
      i = FindFirst( L1BOADSNames(1,:), HDF4Name )
      if ( i > 0 ) HDF5Name = L1BOADSNames(2,i)
    case default
    end select
  end subroutine ConvertL1BOADSNames

  ! ----------------------------------------  CpL1BData  -----
  subroutine CpL1BData ( L1BFile1, L1BFile2, QuantityName, NewName, l2aux )

    ! Dummy arguments
    type(MLSFile_T), pointer                :: L1BFile1
    type(MLSFile_T), pointer                :: L1BFile2
    character(len=*), intent(in)            :: quantityName ! Name of SD to cp
    character(len=*), optional, intent(in)  :: newName
    logical, optional, intent(in)           :: l2aux

    ! Local variables
    type(l1bdata_t)                :: L1BDATA ! Result
    integer                        :: Me = -1 ! String index for trace
    integer                        :: flag
    integer                        :: noMAFs
    character(len=256)             :: rename
    integer                        :: status
    ! Executable code
    call trace_begin ( me, "CpL1BData", &
      & cond=toggle(gen) .and. levels(gen) > 1 )
    rename = QuantityName
    if ( present(NewName) ) rename = NewName
    if ( .not. associated(L1BFile1) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'null pointer passed to readl1bdata--probably cant find ' // &
        & trim(QuantityName) )
    call mls_openFile ( L1BFile2, status )
    call ReadL1BData_MLSFile ( L1BFile1, QuantityName, L1BData, noMAFs, flag, &
      & l2aux=l2aux  )
    if ( associated(L1BData%CharField) ) then
      call SaveAsHDF5DS( L1BFile2%FileID%f_id, rename, &
        & L1BData%CharField(:,:,1) )
    endif
    if ( associated(L1BData%DpField) ) then
      call SaveAsHDF5DS( L1BFile2%FileID%f_id, rename, L1BData%DpField )
    endif
    if ( associated(L1BData%IntField) ) then
      call SaveAsHDF5DS( L1BFile2%FileID%f_id, rename, L1BData%IntField )
    endif
    call deallocateL1BData ( L1BData )
    call mls_CloseFile( L1BFile2 )
    call trace_end ( "CpL1BData", &
      & cond=toggle(gen) .and. levels(gen) > 1 )
  end subroutine CpL1BData

  ! --------------------------------------------------  DupL1BData  -----
  subroutine DupL1BData ( l1bData1, l1bData2, offsetMAF )
    ! cp all components from l1bdata1 to l1bdata2
    ! increment counterMAF by offsetMAF (if present)
    type( L1BData_T ), intent(in)  :: L1bData1
    type( L1BData_T ), intent(out) :: L1bData2
    integer, optional, intent(in)  :: offsetMAF

    ! Executable code
    call allocatel1bdata ( l1bData2, L1bDataSibling=l1bData1 )
    ! print *, 'l1bData1%counterMAF(1): ', l1bData1%counterMAF
    if ( .not. present(offsetMAF) ) then
      l1bData2%counterMAF = l1bData1%counterMAF
    else
      l1bData2%counterMAF = l1bData1%counterMAF + offsetMAF
      l1bData2%FirstMAFCtr = l1bData1%FirstMAFCtr + offsetMAF
      l1bData2%LastMAFCtr = l1bData1%LastMAFCtr + offsetMAF
    end if
    ! print *, 'l1bData2%counterMAF(1): ', l1bData2%counterMAF
    if ( associated(l1bdata1%charField) ) l1bdata2%charField=l1bdata1%charField
    if ( associated(l1bdata1%intField) ) l1bdata2%intField=l1bdata1%intField
    if ( associated(l1bdata1%dpField) ) l1bdata2%dpField=l1bdata1%dpField
  end subroutine DupL1BData

  ! ------------------------------------------  DeallocateL1BData  -----
  subroutine DeallocateL1BData ( l1bData )
    ! This should be called when finished with an l1bData.
    type( L1BData_T ), intent(inout) :: L1bData

    ! Executable code
    call deallocate_test ( l1bData%counterMAF, 'l1bData%counterMAF', ModuleName )
    call deallocate_test ( l1bData%charField, 'l1bData%charField', ModuleName )
    call deallocate_test ( l1bData%intField, 'l1bData%intField', ModuleName )
    call deallocate_test ( l1bData%dpField, 'l1bData%dpField', ModuleName )
  end subroutine DeallocateL1BData

  ! ------------------------------------------------  DiffL1BData  -----
  subroutine DiffL1BData ( l1bData1, l1bData2, &
    & details, options, numDiffs, mafStart, mafEnd, l1bValues1, l1bValues2, &
    & Period )
  use MLSStrings, only: Asciify, IsAllAscii
    ! Diff two l1brad quantities
    type( L1BData_T ), intent(inout) :: L1bData1
    type( L1BData_T ), intent(inout) :: L1bData2
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even counterMAF
    !                                        ! -2 Skip all but name
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 1
    character(len=*), intent(in), optional :: options
    ! logical, intent(in), optional :: silent  ! don't print anything
    integer, intent(out), optional :: numDiffs  ! how many diffs
    integer, intent(in), optional :: mafStart, mafEnd
    real(r8), dimension(:), optional :: l1bValues1
    real(r8), dimension(:), optional :: l1bValues2
    real(r8), optional, intent(in)   :: Period
    ! If options contains 'r' or 's', print much less
    ! if options contains 'd' don't bother with essentially equal and so on
    ! Local variables
    integer :: i,j,k
    logical :: hideAssocStatus
    logical :: l1b1NotFinite
    logical :: l1b2NotFinite
    integer :: MYDETAILS
    logical :: myDirect
    logical :: myPeriodic
    integer :: mafStart1, mafStart2, mafEnd1, mafEnd2
    integer :: myNumDiffs
    real(r8) :: myPeriod
    logical :: mySilent
    logical :: prntAssocStatus  ! Whether to remark on association status
                                !  of multidimensional arrays
    logical, parameter :: DEBUG = .false.
    ! Executable code
    myDetails = 1
    if ( present(details) ) myDetails = details
    hideAssocStatus = .false.
    if ( present(options) ) then
      hideAssocStatus = any(indexes(options, (/'s','r','@@'/)) > 0 )
    end if
    prntAssocStatus = .not. hideAssocStatus
    if ( present(mafStart) ) then
      mafStart1 = mafStart
      mafStart2 = mafStart
    else
      mafStart1 = 1
      mafStart2 = 1
    end if
    if ( present(mafEnd) ) then
      mafEnd1 = mafEnd
      mafEnd2 = mafEnd
    else
      mafEnd1 = L1bData1%NoMAFs
      mafEnd2 = L1bData1%NoMAFs
    end if

    mySilent = .false.
    if ( present(options) ) mySilent = ( index( options, 'h' ) > 0 )
    myDirect = .false.
    if ( present(options) ) myDirect = ( index( options, 'd' ) > 0 )
    myPeriod = 360._r8
    if ( present(Period) ) myPeriod = Period
    myPeriodic = .false.
    if ( present(options) ) myPeriodic = ( index( options, 'p' ) > 0 )
    nameOnEachLine = ' '
    if ( DEBUG ) then
      call outputNamedValue( 'options', options )
      call outputNamedValue( 'myDetails', myDetails )
      call outputNamedValue( 'mySilent', mysilent )
    end if
    ! if ( mySilent ) call suspendOutput

    myNumDiffs = 0
    if ( trim(L1bData1%NameInst) /= trim(L1bData2%NameInst) ) then
      call output(trim(L1bData1%NameInst), advance='yes')
      call output(trim(L1bData2%NameInst), advance='yes')
      myNumDiffs = myNumDiffs + 1
    end if
    if ( trim(L1bData1%L1BName) /= trim(L1bData2%L1BName) ) then
      call output('L1B rad quantity (1) Name = ', advance='no')
      call output(trim(L1bData1%L1BName), advance='yes')
      call output('L1B rad quantity (2) Name = ', advance='no')
      call output(trim(L1bData2%L1BName), advance='yes')
      myNumDiffs = myNumDiffs + 1
    end if
    if ( myDetails < -1 ) then
      call doneHere
      return
    end if
    if ( L1bData1%FirstMAF /= L1bData2%FirstMAF ) then
      call output(' (1) First major frame read = ', advance='no')
      call output(L1bData1%FirstMAF, advance='yes')
      call output(' (2) First major frame read = ', advance='no')
      call output(L1bData2%FirstMAF, advance='yes')
      myNumDiffs = myNumDiffs + 1
    end if
    if ( L1bData1%NoMAFs /= L1bData2%NoMAFs ) then
      call output(' (1) Num of MAFs read = ', advance='no')
      call output(L1bData1%NoMAFs, advance='yes')
      call output(' (2) Num of MAFs read = ', advance='no')
      call output(L1bData2%NoMAFs, advance='yes')
      myNumDiffs = myNumDiffs + 1
    end if
    if ( L1bData1%MaxMIFs /= L1bData2%MaxMIFs ) then
      call output(' (1) Max # of MIFs/MAF in SD array = ', advance='no')
      call output(L1bData1%MaxMIFs, advance='yes')
      call output(' (2) Max # of MIFs/MAF in SD array = ', advance='no')
      call output(L1bData2%MaxMIFs, advance='yes')
      myNumDiffs = myNumDiffs + 1
    end if
    if ( L1bData1%NoAuxInds /= L1bData2%NoAuxInds ) then
      call output(' (1) Num of auxilliary indices = ', advance='no')
      call output(L1bData1%NoAuxInds, advance='yes')
      call output(' (2) Num of auxilliary indices = ', advance='no')
      call output(L1bData2%NoAuxInds, advance='yes')
      myNumDiffs = myNumDiffs + 1
    end if
    if ( L1bData1%FirstMAFCtr /= L1bData2%FirstMAFCtr ) then
      call output(' (1) First major frame counter = ', advance='no')
      call output(L1bData1%FirstMAFCtr, advance='yes')
      call output(' (2) First major frame counter = ', advance='no')
      call output(L1bData2%FirstMAFCtr, advance='yes')
      myNumDiffs = myNumDiffs + 1
    end if
    if ( L1bData1%LastMAFCtr /= L1bData2%LastMAFCtr ) then
      call output(' (1) Last major frame counter = ', advance='no')
      call output(L1bData1%LastMAFCtr, advance='yes')
      call output(' (2) Last major frame counter = ', advance='no')
      call output(L1bData2%LastMAFCtr, advance='yes')
      myNumDiffs = myNumDiffs + 1
    end if
    if ( L1bData1%FirstMAFCtr < L1bData2%FirstMAFCtr ) then
      mafStart1 = mafStart1 + L1bData2%FirstMAFCtr - L1bData1%FirstMAFCtr
    else if ( L1bData1%FirstMAFCtr > L1bData2%FirstMAFCtr ) then
      mafStart2 = mafStart2 + L1bData1%FirstMAFCtr - L1bData2%FirstMAFCtr
    end if
    if ( L1bData1%LastMAFCtr < L1bData2%LastMAFCtr ) then
      mafEnd2 = mafEnd2 - ( L1bData2%LastMAFCtr - L1bData1%LastMAFCtr )
    else if ( L1bData1%LastMAFCtr > L1bData2%LastMAFCtr ) then
      mafEnd1 = mafEnd1 - ( L1bData1%LastMAFCtr - L1bData2%LastMAFCtr )
    end if
    if ( myDetails < 0 ) then
      call doneHere
      return
    end if
    if ( associated(l1bData1%counterMAF) .and. &
      & associated(l1bData2%counterMAF) ) then
      if ( any(l1bData1%counterMAF(1:mafEnd2) /= l1bData2%counterMAF(1:mafEnd2))) then
        call dump ( l1bData1%counterMAF(1:mafEnd2) - l1bData2%counterMAF(1:mafEnd2), &
          & 'l1bData%counterMAF (diff)' )
         myNumDiffs = myNumDiffs + 1
       end if
    else
      if ( prntAssocStatus ) &
        & call output('(CounterMAF arrays not associated)', advance='yes')
    end if

    if ( myDetails < 1 ) then
      if ( DEBUG ) call output( ' Done here', advance='yes' )
      call doneHere
      return
    end if
    if ( statsOnOneLine ) nameOnEachLine = L1BData1%L1BName
    if ( associated(l1bData1%charField) .and. &
      & associated(l1bData2%charField)) then
      if ( any(l1bData1%charField /= l1bData2%charField) ) then
        myNumDiffs = myNumDiffs + count(l1bData1%charField /= l1bData2%charField)
        ! where ( .not. isAllAscii(l1bData1%CharField) )
        !  l1bData1%CharField = asciify( l1bData1%CharField, 'snip')
        ! end where
        do k=1, size(l1bData1%CharField, 3)
          do j=1, size(l1bData1%CharField, 2)
            do i=1, size(l1bData1%CharField, 1)
              if ( .not. isAllAscii(l1bData1%CharField(i,j,k) ) ) &
              l1bData1%CharField(i,j,k) = asciify( l1bData1%CharField(i,j,k), 'snip')
            end do
          end do
        end do
        ! where ( .not. isAllAscii(l1bData2%CharField) )
        !  l1bData2%CharField = asciify( l1bData2%CharField, 'snip')
        ! end where
        do k=1, size(l1bData1%CharField, 3)
          do j=1, size(l1bData1%CharField, 2)
            do i=1, size(l1bData1%CharField, 1)
              if ( .not. isAllAscii(l1bData2%CharField(i,j,k) ) ) &
              l1bData2%CharField(i,j,k) = asciify( l1bData2%CharField(i,j,k), 'snip')
            end do
          end do
        end do
        call dump ( l1bData1%CharField, 'l1bData1%CharField' )
        call dump ( l1bData2%CharField, 'l1bData2%CharField' )
      end if
    else
      if ( prntAssocStatus ) &
        & call output('(CharField arrays not associated)', advance='yes')
    end if

    if ( associated(l1bData1%intField) &
      & .and. associated(l1bData1%intField) ) then
      if ( any(l1bData1%intField /= l1bData2%intField) ) then
        call output( 'About to call dump with l1bData%intField', advance='yes' )
        call dump ( l1bData1%intField - l1bData2%intField, &
          & 'l1bData%intField (diff)', options=options )
        myNumDiffs = myNumDiffs + count(l1bData1%intField /= l1bData2%intField)
      else if ( .not. mySilent ) then
        call output('(integer arrays are exactly equal)', advance='yes')
      end if
    else
      if ( prntAssocStatus ) &
        & call output('(intField arrays not associated)', advance='yes')
    end if

    if ( present(l1bValues1) .and. present(l1bValues2) ) then
      l1b1NotFinite = .not. any(ieee_is_finite(l1bValues1))
      l1b2NotFinite = .not. any(ieee_is_finite(l1bValues2))
      if ( l1b1NotFinite .and. l1b2NotFinite ) then
        call output('both dpField arrays all NaNs', advance='yes')
      else if ( l1b1NotFinite ) then
        call output('l1bValues1 array all NaNs', advance='yes')
      else if ( l1b2NotFinite ) then
        call output('l1bValues2 array all NaNs', advance='yes')
      else
        if ( DEBUG ) call output( 'Calling direct diff with l1bvalues1 and 2', advance='yes' )
        myNumDiffs = myNumDiffs + count(l1bValues1 /= l1bValues2)
        if ( .not. myPeriodic ) then
          call DIFF ( &
            & l1bValues1, ' ', &
            & l1bValues2, ' ', &
            & options=options )
        else
          call dump ( &
            & diff_fun( l1bValues1, l1bValues1, &
            & auxvalue=myPeriod , options=options), &
            & options=options )
        end if
      end if
    end if

    if ( associated(l1bData1%dpField) &
      & .and. associated(l1bData1%dpField) ) then
      ! if ( any(l1bData1%dpField /= l1bData2%dpField) ) &
      l1b1NotFinite = .not. any(ieee_is_finite(l1bData1%dpField))
      l1b2NotFinite = .not. any(ieee_is_finite(l1bData2%dpField))
      if ( DEBUG ) then
        call outputNamedValue( 'l1b1NotFinite', l1b1NotFinite )
        call outputNamedValue( 'l1b2NotFinite', l1b2NotFinite )
      end if
      if ( l1b1NotFinite .and. l1b2NotFinite ) then
        call output('both dpField arrays all NaNs', advance='yes')
      else if ( l1b1NotFinite ) then
        call output('l1bData1%dpField array all NaNs', advance='yes')
      else if ( l1b2NotFinite ) then
        call output('l1bData2%dpField array all NaNs', advance='yes')
      else if ( myPeriodic ) then
        myNumDiffs = myNumDiffs + count(l1bData1%dpField /= l1bData2%dpField)
        call dump ( &
          & diff_fun( l1bData1%dpField, l1bData2%dpField, &
          & auxvalue=myPeriod , options=options), &
          & options=options )
      else if ( myDirect ) then
        if ( DEBUG ) call output( 'Calling direct diff', advance='yes' )
        myNumDiffs = myNumDiffs + count(l1bData1%dpField /= l1bData2%dpField)
        ! l1bData1%dpField = l1bData1%dpField - l1bData2%dpField
        ! call dump ( &
        !  & l1bData1%dpField, '(1)-(2)', &
        !  & options=options )
        call DIFF ( &
          & l1bData1%dpField, ' ', &
          & l1bData2%dpField, ' ', &
          & options=options )
      else if ( .not. EssentiallyEqual(l1bData1%dpField, l1bData2%dpField, &
        & FillValue=REAL(undefinedValue, R8)) ) then
        if ( DEBUG ) call output( 'Calling diff', advance='yes' )
        call diff ( &
        & l1bData1%dpField(:,:,mafStart1:mafEnd1), ' ', &
        & l1bData2%dpField(:,:,mafStart2:mafEnd2), ' ', &
        & FillValue=REAL(undefinedValue, R8), &
        & options=options )
        myNumDiffs = myNumDiffs + count(l1bData1%dpField /= l1bData2%dpField)
      end if
    else
      if ( prntAssocStatus ) &
        & call output('(dpField arrays not associated)', advance='yes')
    end if
    call doneHere

  contains
    subroutine doneHere
      ! Housekeeping
      ! call resumeOutput
      if ( present(numDiffs) ) numDiffs = myNumDiffs
      nameOnEachLine = ' '
    end subroutine doneHere
  end subroutine DiffL1BData

  ! ------------------------------------------------  DumpL1BData  -----
  subroutine DumpL1BData ( l1bData, details, options )
    ! Disclose pertinent, perhaps damning facts about an l1brad quantity
    type( L1BData_T ), intent(inout) :: L1bData
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even counterMAF
    !                                        ! -2 Skip all but name
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 1
    character(len=*), intent(in), optional :: options ! Passed dumping arrays

    ! Local variables
    integer :: MYDETAILS

    ! Executable code
    myDetails = 1
    if ( present(details) ) myDetails = details

    if ( trim(L1bData%NameInst) /= ' ' ) &
      & call output(trim(L1bData%NameInst), advance='yes')
    call output('L1B rad/oa quantity Name = ', advance='no')
    call output(trim(L1bData%L1BName), advance='yes')
    if ( myDetails < -1 ) return
    call output('  First major frame read = ', advance='no')
    call output(L1bData%FirstMAF, advance='yes')
    call output('  Num of MAFs read = ', advance='no')
    call output(L1bData%NoMAFs, advance='yes')
    call output('  Max # of MIFs/MAF in SD array = ', advance='no')
    call output(L1bData%MaxMIFs, advance='yes')
    call output('  Num of auxilliary indices = ', advance='no')
    call output(L1bData%NoAuxInds, advance='yes')
    call output('  First major frame counter = ', advance='no')
    call output(L1bData%FirstMAFCtr, advance='yes')
    call output('  Last major frame counter = ', advance='no')
    call output(L1bData%LastMAFCtr, advance='yes')

    if ( myDetails < 0 ) return
    if ( associated(l1bData%counterMAF) ) then
      call dump ( l1bData%counterMAF, 'l1bData%counterMAF', format='(i8)' )
    else
      call output('(CounterMAF array not associated)', advance='yes')
    end if

    if ( myDetails < 1 ) return
    if ( associated(l1bData%charField) ) then
      call dump ( l1bData%CharField, 'l1bData%CharField' )
    else
      call output('(CharField array not associated)', advance='yes')
    end if

    if ( associated(l1bData%intField) ) then
      call dump ( l1bData%intField, 'l1bData%intField', &
        & fillValue = int(undefinedValue), options=options )
    else
      call output('(intField array not associated)', advance='yes')
    end if

    if ( associated(l1bData%dpField) ) then
      call dump ( l1bData%dpField, 'l1bData%dpField', &
        & fillValue=undefinedValue*1.d0, options=options )
    else
      call output('(dpField array not associated)', advance='yes')
    end if
  end subroutine DumpL1BData

  ! -------------------------------------------------  GetL1BFile  -----
  function GetL1BFile ( filedatabase, fieldName, options, object ) &
    & result(item)
  ! Which MLSFile contains a given sd name or attribute name
  !
  ! options, if present, may influence how it works
  ! By convention, options is preceded by a "-"; it is ignored, however
  !
  ! option      effect
  ! ------      ------
  !  a       search for sttribute, not dataset
  !  d       search for dataset, not attribute
  !  /       search for attribute under FileID%grp_id; i.e., '/'
  !  f       search for attribute under FileID%f_id
  !  s       search for attribute under FileID%sd_id
  !  w       Wildcard * which allows 'a*' to match 'abcd'
  !  c       case insensitive which allows 'ABCD' to match 'abcd'

  ! Tries to adapt to where attributes are stored in file
  ! This means, e.g. if the attribute is attached to a ds, opening
  ! that ds.
  ! Afterwards we atempt to cleanup, closing the ds.
    use MLSHDF5, only: IsHDF5ItemPresent
    use MLSFiles, only: Dump
    use HDF5, only: H5DOpen_F, H5GClose_F, H5GOpen_F

    type (MLSFile_T), dimension(:), pointer :: FILEDATABASE
    character (len=*), intent(in)           :: fieldName ! Name of field
    character (len=*), optional, intent(in) :: options ! E.g., -a
    character (len=*), optional, intent(in) :: object  ! If we need to open
    type(MLSFile_T), pointer                :: item
    logical, parameter :: DEEBUG = .false.

    ! Externals
    integer, external :: SFN2INDEX

    ! Local variables
    logical :: alreadyOpen
    integer :: i
    integer :: locID
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: myhdfVersion
    character(len=80) :: myObject
    character(len=8) :: myOptions
    character(len=1) :: openedCode ! What type of object did we open? s,g,f
    integer :: returnStatus

    ! Executable code
    ! DEEBUG = (fieldname=='DACsDeconvolved')
    call trace_begin ( me, 'GetL1BFile' , cond=.false. )
    nullify(item)
    myOptions = '-d' ! By default, search for sd names
    if (present(options)) myOptions = options
    myObject = '/'
    if (present(object)) myObject = object
    openedCode = ' '
    do i = 1, size(filedatabase)
      returnStatus = 0
      if ( streq(filedatabase(i)%content, 'l1b*', '-w') ) then
        if ( DEEBUG ) call dump(filedatabase(i), details=1)
        ! This is an l1b file
        alreadyOpen = filedatabase(i)%StillOpen
        if ( .not. alreadyOpen ) &
          & call mls_openFile(filedatabase(i), returnStatus)
        ! print *, 'Oops--must open file?'
        if ( returnStatus /= 0 ) &
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'unable to open L1BFile searching for ' // trim(fieldname), &
            & MLSFile=filedatabase(i) )
        myHDFVersion = filedatabase(i)%HDFVersion
        ! Are we looking for an attribute?
        ! (Then we may need an object name)
        if ( index(myoptions, 'a') > 0 ) then
          if ( myhdfVersion == HDFVERSION_4 ) then
            openedCode = 'n' ! Because we can't read attributes from HDF4 files
          ! What object would the attribute be attached to?
          else if ( index(myOptions, 'f') > 0 ) then
            openedCode = 'f'
          else if ( index(myOptions, '/') > 0 ) then
            call h5gopen_f ( filedatabase(i)%fileID%f_id, trim(myObject), &
              & filedatabase(i)%fileID%grp_id, returnStatus )
            openedCode = 'g'
          else if ( index(myOptions, 's') > 0 ) then
            call h5dopen_f ( filedatabase(i)%fileID%f_id, trim(myObject), &
              & filedatabase(i)%fileID%sd_id, returnStatus )
            openedCode = 's'
          else
            call h5dopen_f ( filedatabase(i)%fileID%f_id, trim(myObject), &
              & filedatabase(i)%fileID%sd_id, returnStatus )
            openedCode = 's'
          end if
        end if

        if ( myhdfVersion == HDFVERSION_4 ) then
          if ( index(myOptions, 'a') > 0 ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Cannot search for attribute names in hdf4 files' )
            cycle
          end if
          if ( sfn2index(filedatabase(i)%FileID%f_id, trim(fieldName)) /= -1 ) then
            item => filedatabase(i)
            if ( .not. alreadyOpen ) &
              & call mls_closeFile(filedatabase(i), returnStatus)
            call trace_end ( 'GetL1BFile' , cond=.false. )
            return
          end if
        else
          ! Are we looking for an attribute?
          if ( index(myoptions, 'a') > 0 ) then
            ! What object would the attribute be attached to?
            if ( index(myOptions, 'f') > 0 ) then
              locID = filedatabase(i)%FileID%f_id
            else if ( index(myOptions, '/') > 0 ) then
              locID = filedatabase(i)%FileID%grp_id
            else if ( index(myOptions, 's') > 0 ) then
              locID = filedatabase(i)%FileID%sd_id
            else
              locID = filedatabase(i)%FileID%f_id
            end if
          else
            locID = filedatabase(i)%FileID%f_id
          end if
          if ( DEEBUG ) call outputnamedValue('locID', locID)
          if ( IsHDF5ItemPresent( &
            & locID, trim(fieldName), myOptions ) &
            & ) then
            item => filedatabase(i)
            if ( .not. alreadyOpen ) call closeEverything(filedatabase(i))
            call trace_end ( 'GetL1BFile' , cond=.false. )
            return
          end if
        end if
        if ( .not. alreadyOpen ) call closeEverything(filedatabase(i))
      end if
    end do
    call trace_end ( 'GetL1BFile' , cond=.false. )
    ! if ( DEEBUG ) stop

  contains

    subroutine closeEverything(L1BFile)
      ! Args:
      type(MLSFile_T) :: L1BFile
      integer :: returnStatus
      ! Executable
       select case (openedCode)
       case ('s')
         call h5gclose_f ( L1BFile%fileID%sd_id, returnStatus )
       case ('g')
         call h5gclose_f ( L1BFile%fileID%grp_id, returnStatus )
       case default
       end select
       call mls_closeFile(L1BFile, returnStatus)
    end subroutine closeEverything
  end function GetL1BFile

  ! ------------------------------------------------  FindL1BData  -----
  integer function FindL1BData ( filedatabase, fieldName, hdfVersion )

  use MLSHDF5, only: IsHDF5DSPresent

    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    ! integer, dimension(:), intent(in) :: files ! File handles
    character (len=*), intent(in) :: fieldName ! Name of field
    integer, optional, intent(in) :: hdfVersion
    logical, parameter :: TRUSTDATABASE = .true.

    ! Externals
    integer, external :: SFN2INDEX

    ! Local variables
    integer :: i
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: myhdfVersion

    ! Executable code
    call trace_begin ( me, 'FindL1BData' , cond=.false. )
    if ( present(hdfVersion) ) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L1BDEFAULT_HDFVERSION
    end if

    findL1BData=0
    ! print *, 'Looking for ', trim(fieldname)
    do i = 1, size(filedatabase)
      if ( TRUSTDATABASE ) myHDFVersion = filedatabase(i)%HDFVersion
      if ( .not. streq(filedatabase(i)%content, 'l1b*', '-w') ) then
        ! This is not an l1b file
      else if ( myhdfVersion == HDFVERSION_4 ) then
        if ( sfn2index(filedatabase(i)%FileID%f_id, trim(fieldName)) /= -1 ) then
          findL1BData = filedatabase(i)%FileID%f_id
          return
        end if
      else
        ! print *, 'Looking in ', trim(filedatabase(i)%name)
        if ( IsHDF5DSPresent(filedatabase(i)%FileID%f_id, trim(fieldName)) ) then
          findL1BData = filedatabase(i)%FileID%f_id
          ! print *, 'Eureka '
          return
        end if
      end if
    end do
    call trace_end ( 'FindL1BData' , cond=.false. )

  end function FindL1BData

  ! -------------------------------------------------  FindMaxMAF_arr  -----
  integer function FindMaxMAF_arr ( files, minMAF )
  ! Find maximum MAF among files (using counterMAF arrays)

    type(MLSFile_T), dimension(:), intent(in), target    :: files ! File handles
    integer, optional, intent(out)                       :: minMAF

    ! Local variables
    integer :: i
    type(MLSFile_T), pointer :: L1BFile
    integer :: myMinMAF
    integer :: theMinMAF
    logical :: haveCtrMAF
    logical, parameter :: DEEBug = .false.
    ! Executable code

    FindMaxMAF_arr = 0
    myMinMAF = BIGGESTMAFCTR
    haveCtrMAF = .false.
    do i = 1, size(files)
      L1BFile => files(i)
      if ( streq( L1BFile%content, 'l1b*', '-w') ) then
        ! This is an l1b file
        FindMaxMAF_arr = max( FindMaxMAF_sca( L1BFile, theMinMAF ), FindMaxMAF_arr )
        myMinMAF = min( myMinMAF, theMinMAF )
      end if
    end do
    if ( DEEBug ) print *, 'FindMaxMAF_arr ', FindMaxMAF_arr
    if ( DEEBug ) print *, 'myMinMAF ', myMinMAF
    if ( present(minMAF) ) minMAF = myMinMAF
  end function FindMaxMAF_arr

  ! -------------------------------------------------  FindMaxMAF_sca  -----
  integer function FindMaxMAF_sca ( L1BFile, minMAF )
  ! Find maximum MAF among files (using counterMAF arrays)
  ! If there is no counterMAF, just return the isze of the MAFStartTimeTAI

  use MLSHDF5, only: IsHDF5DSPresent

    type(MLSFile_T), pointer               :: L1BFile ! File handles
    integer, optional, intent(out)         :: minMAF

    ! Externals
    integer, external :: SFN2INDEX

    ! Local variables
    logical :: alreadyOpen
    character(len=*), parameter :: fieldname = 'counterMAF'
    type(L1BData_T) :: l1bData
    integer :: myhdfVersion
    integer :: myMinMAF
    integer :: noMAFs
    integer :: status
    logical :: haveCounterMAF
    logical :: haveMAFStartTimeTAI
    logical, parameter :: DEEBug = .false.
    character(len=1024) :: DSNames
    ! Executable code
    alreadyOpen = L1BFile%StillOpen
    myMinMAF = 0
    if ( .not. alreadyOpen ) &
      & call mls_openFile( L1BFile, status )
    myHDFVersion = L1BFile%HDFVersion
    if ( myhdfVersion == HDFVERSION_4 ) then
      haveCounterMAF = sfn2index(L1BFile%FileID%f_id,trim(fieldName)) /= -1
      if ( haveCounterMAF ) then
        call ReadL1BData ( L1BFile, fieldName, L1bData, noMAFs, status, &
          & dontPad=.true. )
      end if
    else
      haveCounterMAF = IsHDF5DSPresent( L1BFile, trim(fieldName) )
      haveMAFStartTimeTAI = IsHDF5DSPresent( L1BFile, 'MAFStartTimeTAI' )
      if ( DEEBug ) call outputNamedValue( 'haveCounterMAF', haveCounterMAF )
      if ( DEEBug )  call outputNamedValue( 'haveMAFStartTimeTAI', haveMAFStartTimeTAI )
      if ( haveCounterMAF ) then
        call ReadL1BData ( L1BFile, fieldName, L1bData, noMAFs, status, &
          & dontPad=.true.)
      elseif ( haveMAFStartTimeTAI ) then
        call ReadL1BData ( L1BFile, 'MAFStartTimeTAI', L1bData, noMAFs, status, &
          & dontPad=.true.)
      end if
    end if
    if ( haveCounterMAF ) then
      FindMaxMAF_sca =  maxval(l1bData%counterMAF)
      myMinMAF =  myminval(l1bData%counterMAF)
      if ( DEEBug ) print *, 'counterMAF ', l1bData%counterMAF
      ! call output('Shape L1b counterMAF ')
      ! call output(shape(l1bData%intField), advance='yes')
      call deallocatel1bdata(L1bData)
    elseif ( haveMAFStartTimeTAI ) then
      FindMaxMAF_sca =  size(l1bData%dpField)
      myMinMAF = 1
      if ( DEEBug ) print *, 'MAFStartTimeTAI ', l1bData%dpField
      ! call output('Shape L1b counterMAF ')
      ! call output(shape(l1bData%intField), advance='yes')
      call deallocatel1bdata(L1bData)
    else
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & 'Failed to find '//trim(fieldName)// &
      & ' in l1b files while FindMaxMAF_sca', MLSFile=L1BFile )
      call GetAllHDF5DSNames( L1BFile, DSNames )
      call Dump ( DSNames, 'DSNames' )
    end if
    if ( .not. alreadyOpen ) &
      & call mls_closeFile( L1BFile, status )
    if ( present(minMAF) ) minMAF = myMinMAF
  end function FindMaxMAF_sca

  ! -------------------------------------------------  IsL1BGappy  -----
  logical function IsL1BGappy ( l1bData, ignoreGlobalAttrs )
    ! Look for gaps in l1bData, returning true if any found
  use PCFHdr, only: GlobalAttributes

    ! Dummy arguments
    type (L1BData_T), intent(in) :: l1bData
    logical, optional, intent(in) :: ignoreGlobalAttrs  ! defaults to checking
    ! Internal variables
    logical :: skipGACHecks
    integer :: i
    integer :: nextMAF
    integer :: maxCtrMAF
    integer :: minCtrMAF
    ! Executable
    skipGACHecks = .false.
    if ( present(ignoreGlobalAttrs) ) skipGACHecks = ignoreGlobalAttrs
    IsL1BGappy = .false.
    if ( .not. skipGACHecks ) then
      maxCtrMAF = maxval(l1BData%counterMAF)
      minCtrMAF = myminval(l1BData%counterMAF)
      IsL1BGappy = (maxCtrMAF < GlobalAttributes%LastMAFCtr &
        & .or. &
        & minCtrMAF > GlobalAttributes%FirstMAFCtr)
    end if
    if ( IsL1BGappy ) return
    ! Search for interior gaps
    IsL1BGappy = .true. ! If exit from next loop prematurely, must be gappy
    nextMAF = minCtrMAF
    do i=1, size(l1BData%counterMAF)
      if ( nextMAF /= l1BData%counterMAF(i)) return
    end do
    IsL1BGappy = .false.
  end function IsL1BGappy

  ! -------------------------------------------------  showL1BGaps  -----
  subroutine showL1BGaps ( l1bData, ignoreGlobalAttrs )
    ! Look for gaps in l1bData, returning true if any found
  use PCFHdr, only: GlobalAttributes

    ! Dummy arguments
    type (L1BData_T), intent(in) :: l1bData
    logical, optional, intent(in) :: ignoreGlobalAttrs  ! defaults to checking
    ! Internal variables
    logical :: skipGACHecks
    integer :: i
    integer :: nextMAF
    integer :: maxCtrMAF
    integer :: minCtrMAF
    ! Executable
    skipGACHecks = .false.
    if ( present(ignoreGlobalAttrs) ) skipGACHecks = ignoreGlobalAttrs
    if ( .not. skipGACHecks ) then
      maxCtrMAF = maxval(l1BData%counterMAF)
      minCtrMAF = myminval(l1BData%counterMAF)
      if ( maxCtrMAF < GlobalAttributes%LastMAFCtr ) &
        & call outputnamedValue( 'maxCtrMAF, LastMAFCtr', &
        &                      (/ maxCtrMAF, GlobalAttributes%LastMAFCtr /) )
      if ( minCtrMAF > GlobalAttributes%FirstMAFCtr ) &
        & call outputnamedValue( 'minCtrMAF, FirstMAFCtr', &
        &                      (/ minCtrMAF, GlobalAttributes%FirstMAFCtr /) )
    end if
    ! Search for interior gaps
    nextMAF = minCtrMAF
    do i=1, size(l1BData%counterMAF)
      if ( nextMAF /= l1BData%counterMAF(i)) exit
      nextMAF = nextMAF + 1
    end do
    if ( i > size(l1BData%counterMAF) ) then
      call output( 'No interior gaps found in counterMAF array', advance='yes' )
    else
      call outputNamedValue( 'First counterMAF gap found at MAF ', i )
    endif
  end subroutine showL1BGaps

  !--------------------------------------------------  L1BOAHDF4DSName  -----
  function L1BOAHDF4DSName ( HDF5Name ) result( HDF4Name )
    ! Convert an l1boa ds name from hdf5 to hdf4

    ! Dummy arguments
    character(len=*), intent(in)      :: HDF5Name
    character(len=128)                :: HDF4Name
    character(len=128)                :: Name
    ! Executable
    Name = HDF5Name
    call ConvertL1BOADSNames ( HDF4Name, Name, '5to4' )
  end function L1BOAHDF4DSName

  !--------------------------------------------------  L1BOAHDF5DSName  -----
  function L1BOAHDF5DSName ( HDF4Name ) result( HDF5Name )
    ! Convert an l1boa ds name from hdf4 to hdf5

    ! Dummy arguments
    character(len=*), intent(in)      :: HDF4Name
    character(len=128)                :: HDF5Name
    character(len=128)                :: Name
    ! Executable
    Name = HDF4Name
    call ConvertL1BOADSNames ( Name, HDF5Name, '4to5' )
  end function L1BOAHDF5DSName

  !--------------------------------------------------  L1BOASetup  -----
  subroutine L1boaSetup ( root, filedatabase, F_FILE, hdfVersion )
    ! Take file name from l2cf, open, and add new file to filedatabase

    ! Dummy arguments
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    integer, intent(in) :: ROOT         ! of the l1brad file specification.
    integer, intent(in) :: F_FILE       ! From init_tables_module
    integer, optional, intent(inout) :: hdfVersion

    ! Local variables

    character(len=FileNameLen) :: FileName

    integer :: I                        ! Loop inductor, subscript
    integer :: numFiles
    integer :: returnStatus
    integer :: SON                      ! Some subtree of root.
    type(MLSFile_T) :: L1BFile

    ! Executable code
    error = 0
    if ( present(hdfVersion) ) hdfVersion = FILENOTFOUND
    ! Collect data from the fields. (only one legal field: file='...')
    do i = 2, nsons(root)
      son = subtree(i,root)
      if ( get_field_id(son) == f_file ) then
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        returnStatus = InitializeMLSFile(L1BFile, content = 'l1boa', &
          & type=l_hdf, access=DFACC_RDONLY, name=fileName)
        call mls_openFile(L1BFile, returnStatus)
        if ( returnStatus == 0 ) then
          numFiles = addFileToDatabase(filedatabase, L1BFile)
          if ( present(hdfVersion) ) hdfVersion = L1BFile%HDFVersion
        end if
      else
        call announce_error ( son, &
          & 'Unknown field specified in read l1boa' )
      end if
    end do
  end subroutine L1boaSetup

  ! ------------------------------------------------- L1BRadSetup  -----
  subroutine L1bradSetup ( Root, filedatabase, F_File, &
    & hdfVersion )
    ! Take file name from l2cf, open, and add new file to filedatabase
    ! Dummy arguments
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    integer, intent(in) :: ROOT         ! of the l1brad file specification.
    integer, intent(in) :: F_FILE
    integer, optional, intent(inout) :: hdfVersion

    ! Local variables
    character(len=FileNameLen) :: FILENAME

    integer :: I                        ! Loop inductor, subscript
    integer :: numFiles
    integer :: returnStatus
    integer :: SON                      ! Some subtree of root.

    type(MLSFile_T) :: L1BFile

    ! Executable code
    error = 0
    if ( present(hdfVersion) ) hdfVersion = FILENOTFOUND

    ! Collect data from the fields. (only one legal field: file='...')
    do i = 2, nsons(root)
      son = subtree(i,root)
      if ( get_field_id(son) == f_file ) then
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        returnStatus = InitializeMLSFile(L1BFile, content = 'l1brad', &
          & type=l_hdf, access=DFACC_RDONLY, name=fileName)
        call mls_openFile(L1BFile, returnStatus)
        if ( returnStatus == 0 ) then
          numFiles = addFileToDatabase(filedatabase, L1BFile)
          if ( present(hdfVersion) ) hdfVersion = L1BFile%HDFVersion
        end if
      else
        call announce_error ( son, &
          & 'Unknown field specified in read l1brad' )
      end if
    end do

  end subroutine L1bradSetup

  ! ----------------------------------  ReadL1BAttribute_intarr1l  -----
  subroutine ReadL1BAttribute_intarr1 ( L1BFile, value, AttrName, Flag )

    use MLSHDF5, only: IsHDF5AttributePresent, GetHDF5Attribute
    use HDF5, only: H5GClosE_F, H5GOpen_F

    ! Dummy arguments
    type(MLSFile_T), intent(in)            :: L1BFile
    integer, intent(out) :: value(:) ! Result
    character(len=*), intent(in) :: AttrName ! attribute name to retrieve
    integer, intent(out) :: Flag        ! Error flag

    ! Local variables
    integer :: myhdfVersion
    integer :: aID, status
    logical :: alreadyOpen
    ! Executable code
    alreadyOpen = L1BFile%StillOpen
    if ( .not. alreadyOpen ) &
      & call mls_openFile(L1BFile, status)
        myHDFVersion = L1BFile%HDFVersion

    Flag = 0

    if ( myhdfVersion == HDFVERSION_4 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Not implemented in hdf4 l1boa file', MLSFile=L1bFile)
        Flag = -1
    else
      call h5gOpen_f (L1BFile%FileID%f_id,'/', aID, status)
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Unable to open group attribute in l1boa file', MLSFile=L1BFile )
        Flag = -1
      end if
      if ( .not. IsHDF5AttributePresent(aID, AttrName) ) then
        Flag = -1
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Failed to find attribute in l1boa file'//AttrName, MLSFile=L1bFile)
      else
        if ( DEEBUG ) then
          call output ('get attribute ', advance='no')
          call output (AttrName, advance='yes')
        end if
        call GetHDF5Attribute(aID, AttrName, value)
      end if
      call h5gClose_f (aID, status)
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Unable to close group attribute in l1boa file', MLSFile=L1bFile )
      end if
    end if
    if ( .not. alreadyOpen ) &
      & call mls_closeFile(L1BFile, status)
  end subroutine ReadL1BAttribute_intarr1

  ! -----------------------------------  ReadL1BAttribute_dblarr1  -----
  subroutine ReadL1BAttribute_dblarr1 ( L1BFile, value, AttrName, Flag )

    use MLSHDF5, only: IsHDF5AttributePresent, GetHDF5Attribute
    use HDF5, only: H5GClose_F, H5GOpen_F

    ! Dummy arguments
    type(MLSFile_T), intent(in)            :: L1BFile
    real(r8), intent(out) :: value(:) ! Result
    character(len=*), intent(in) :: AttrName ! attribute name to retrieve
    integer, intent(out) :: Flag        ! Error flag

    ! Local variables
    integer :: myhdfVersion
    integer :: aID, status
    logical :: alreadyOpen
    ! Executable code
    alreadyOpen = L1BFile%StillOpen
    if ( .not. alreadyOpen ) &
      & call mls_openFile(L1BFile, status)
        myHDFVersion = L1BFile%HDFVersion

    Flag = 0

    if ( myhdfVersion == HDFVERSION_4 ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & 'Not implemented in hdf4 l1boa file', MLSFile=L1bFile)
      Flag = -1
    else
      call h5gOpen_f (L1BFile%FileID%f_id,'/', aID, status)
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Unable to open group attribute in l1boa file', MLSFile=L1BFile )
        Flag = -1
      end if
      if ( .not. IsHDF5AttributePresent(aID, AttrName) ) then
        Flag = -1
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Failed to find attribute in l1boa file'//AttrName, MLSFile=L1bFile)
      else
        if ( DEEBUG ) then
          call output ('get attribute ', advance='no')
          call output (AttrName, advance='yes')
        endif
        call GetHDF5Attribute(aID, AttrName, value)
      end if
      call h5gClose_f (aID, status)
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Unable to close group attribute in l1boa file', MLSFile=L1bFile )
      end if
    end if
    if ( .not. alreadyOpen ) &
      & call mls_closeFile(L1BFile, status)
  end subroutine ReadL1BAttribute_dblarr1

  ! -------------------------------------------------  PadL1BData  -----
  subroutine PadL1BData ( L1BDataIn, L1BDataOut, FirstMAF, LastMAF, NoMAFs )
    ! Pad l1bdataIn to fit NoMafs (assuming noMafs >= l1bdatain%NoMAFs)
    ! beginning with 1st MAF number of day
    ! (May need to pad at start, at end, or at both ends)
    ! Return newly created padded object as l1bdataOut
    ! If optionally supplied PrecisionIn it will return padded PrecisionOut
    ! where the padded values will all be cleverly set negative
    ! (meaning do not use)
    ! Just as important, fill any gaps
    ! where a gap is defined as a break in sequence in counterMAF array
    ! .., p-2, p-1, [p], [p+1], .., p+gap-1, ..
    ! such that the bracketed numbers above are absent from the counterMAF
    ! Dummy arguments
    type(L1BData_T), intent(in)  :: L1BDataIn
    type(L1BData_T), intent(out) :: L1BDataOut
    integer, intent(in)          :: FirstMAF ! 1st MAF
    integer, intent(in)          :: LastMAF  ! last MAF number of day
    integer, intent(out)         :: NoMAFs   ! number
    ! Internal variables
    integer, dimension(3) :: dims
    integer               :: maf
    integer               :: oldSize
    logical, parameter    :: DEEBug = .false.
    ! Executable
    if ( associated(l1bDataIn%charField)) then
      dims = shape(l1bDataIn%charField)
    else if ( associated(l1bDataIn%intField)) then
      dims = shape(l1bDataIn%intField)
    else if ( associated(l1bDataIn%dpField)) then
      dims = shape(l1bDataIn%dpField)
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Padl1bData was passed l1bDataIn w/o allocating it' )
    end if
    oldSize = dims(3)
    NoMAFs = max(dims(3), lastMAF-firstMAF+1)
    dims(3) = NoMAFs

    if ( DEEBug ) print *, 'Preparing to pad ', trim(l1bDataIn%L1BName)
    if ( DEEBug ) print *, 'NoMAFs ', NoMAFs
    if ( DEEBug ) print *, 'l1b(in)NoMAFs ', l1bDataIn%NoMAFs
    if ( DEEBug ) print *, 'dims ', dims
    if ( DEEBug ) print *, 'min(counterMAF) ', myminval(l1bDataIn%counterMAF)
    if ( DEEBug ) print *, 'min(dpField) ',minval(l1bDataIn%dpField(1,1,:))
    if ( DEEBug ) print *, 'max(dpField) ',maxval(l1bDataIn%dpField(1,1,:))
    call allocateL1BData ( l1bDataOut, dims, L1bDataSibling=l1bDataIn )
    do maf=1, NoMAFs
      l1bDataOut%counterMAF(maf) = FirstMAF - 1 + maf
    end do
    call zeroField(l1bdataOut, 1, undefinedValue, m=NoMAFs)
    call cpField(l1bdataIn, 1, l1bdataOut, 1, m=oldSize)
  end subroutine PadL1BData

  ! ----------------------------------------------  BadPadL1BData  -----
  subroutine BadPadL1BData ( L1BDataIn, L1BDataOut, FirstMAFCtr, NoMAFs, &
    & PrecisionIn, PrecisionOut, force )
    ! Pad l1bdataIn to fit NoMafs (assuming noMafs >= l1bdatain%NoMAFs)
    ! beginning with 1st MAF number of day
    ! (May need to pad at start, at end, or at both ends)
    ! Return newly created padded object as l1bdataOut
    ! If optionally supplied PrecisionIn it will return padded PrecisionOut
    ! where the padded values will all be cleverly set negative
    ! (meaning do not use)
    ! Just as important, fill any gaps
    ! where a gap is defined as a break in sequence in counterMAF array
    ! .., p-2, p-1, [p], [p+1], .., p+gap-1, ..
    ! such that the bracketed numbers above are absent from the counterMAF
    ! Dummy arguments
    type(L1BData_T), intent(in)  :: L1BDataIn
    type(L1BData_T), intent(out) :: L1BDataOut
    integer, intent(in)          :: FirstMAFCtr ! 1st MAF number of day
    integer, intent(in)          :: NoMAFs
    type(L1BData_T), optional, intent(in)  :: PrecisionIn
    type(L1BData_T), optional, intent(out) :: PrecisionOut
    logical, optional, intent(in) :: force   ! Relax assumption
    ! Internal variables
    logical :: MyForce
    integer :: Dims(3)
    integer :: Gap
    integer :: I
    integer :: IndexOut
    integer :: Cmindex
    integer :: Current
    integer :: Maf
    integer :: Rank
    logical, parameter :: DEEBug = .false.
    ! Executable
    myForce = .false.
    if ( present(force) ) myForce = force
    ! Check assumption that noMafs >= l1bdatain%NoMAFs
    if ( .not. myForce .and. noMAFs < l1bdatain%NoMAFs ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'noMAFs requested smaller than number stored in input l1bData' )
    else if ( present(PrecisionOut) .and. .not. present(PrecisionIn) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Must have PrecisionIn to calculate PrecisionOut' )
    end if
    if ( associated(l1bDataIn%charField)) then
      dims = shape(l1bDataIn%charField)
    else if ( associated(l1bDataIn%intField)) then
      dims = shape(l1bDataIn%intField)
    else if ( associated(l1bDataIn%dpField)) then
      dims = shape(l1bDataIn%dpField)
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'BadPadL1BData was passed l1bDataIn w/o allocating it' )
    end if
    dims(3) = noMAFs
    rank = l1bDataIn%trueRank
    if ( DEEBug ) print *, 'Preparing to pad ', trim(l1bDataIn%L1BName)
    if ( DEEBug ) print *, 'rank ', rank
    if ( DEEBug ) print *, 'NoMAFs ', NoMAFs
    if ( DEEBug ) print *, 'l1b(in)NoMAFs ', l1bDataIn%NoMAFs
    if ( DEEBug ) print *, 'dims ', dims
    if ( DEEBug ) print *, 'min(counterMAF) ', myminval(l1bDataIn%counterMAF)
    if ( DEEBug ) print *, 'min(dpField) ',minval(l1bDataIn%dpField(1,1,:))
    if ( DEEBug ) print *, 'max(dpField) ',maxval(l1bDataIn%dpField(1,1,:))
    call allocateL1BData ( l1bDataOut, dims, L1bDataSibling=l1bDataIn )
    do maf=1, NoMAFs
      l1bDataOut%counterMAF(maf) = FirstMAFCtr - 1 + maf
      if ( present(PrecisionOut) ) &
        & PrecisionOut%counterMAF(maf) = FirstMAFCtr - 1 + maf
    end do
    ! Now hunt for missing MAFs
    maf = FirstMAFCtr
    indexOut = 0
    if ( DEEBug ) print *, 'size(l1bDataOut%counterMAF) ', size(l1bDataOut%counterMAF)
    do cmindex = 1, l1bDataIn%noMAFs
      if ( DEEBug ) print *, 'l1bDataIn%counterMAF(cmindex) ', l1bDataIn%counterMAF(cmindex)
      if ( DEEBug ) print *, 'maf ', maf
      if ( DEEBug ) print *, 'indexOut ', indexOut
      if ( l1bDataIn%counterMAF(cmindex) < maf ) then
        ! counterMAF too small: must ignore (perhaps past end of array?)
      else if ( l1bDataIn%counterMAF(cmindex) == maf ) then
        ! Found expected maf: no gap from last maf
        indexOut = indexOut + 1
        if ( DEEBug ) print *, 'Found expected maf: no gap from last maf'
        l1bDataOut%counterMAF(indexOut) = maf
        call cpField(l1bDataIn, cmindex, l1bdataOut, indexOut)
        if ( present(PrecisionOut) ) &
          &  call cpField(PrecisionIn, cmindex, PrecisionOut, indexOut)
        maf = maf+1
      else
        current = l1bDataIn%counterMAF(cmindex)
        if ( DEEBug ) print *, 'Found a greater maf than expected: gap from maf to ', current-1
        ! Found a greater maf than expected: gap from maf to current-1
        gap = current-maf
        ! fill the gap with undefined
        do i=1, gap
          l1bDataOut%counterMAF(indexOut+i) = maf-1+i
          call zeroField(l1bdataOut, indexOut+i, undefinedValue)
          if ( present(PrecisionOut) ) &
            & call zeroField(PrecisionOut, indexOut+i, undefinedValue)
        end do
        if ( DEEBug ) print *, 'Now treat current normally ', current
        ! Now treat current normally
        indexOut = indexOut + gap + 1
        l1bDataOut%counterMAF(indexOut) = current
        call cpField(l1bDataIn, cmindex, l1bdataOut, indexOut)
        if ( present(PrecisionOut) ) &
          &  call cpField(PrecisionIn, cmindex, PrecisionOut, indexOut)
        maf = current+1
      end if
    end do
    if ( maf > FirstMAFCtr + noMAFs - 1 ) return
    gap = FirstMAFCtr + noMAFs - maf
    ! Apparently, we end too soon, so must pad
    if ( DEEBug ) print *, 'Apparently, we end too soon, so must pad ', gap, indexOut
    do i=1, gap
      l1bDataOut%counterMAF(indexOut+i) = maf-1+i
      call zeroField(l1bdataOut, indexOut+i, undefinedValue)
      if ( present(PrecisionOut) ) &
        & call zeroField(PrecisionOut, indexOut+i, undefinedValue)
    end do
  end subroutine BadPadL1BData

  ! -------------------------------------  ReadL1BData_fileHandle  -----
  ! In time we will do away with most file-handle based interfaces
  subroutine ReadL1BData_fileHandle ( L1FileHandle, QuantityName, L1bData, NoMAFs, Flag, &
    & FirstMAF, LastMAF, NeverFail, hdfVersion, dontPad, L2AUX )
    ! Dummy arguments
    character(len=*), intent(in)   :: QUANTITYNAME ! Name of SD to read
    integer, intent(in)            :: L1FILEHANDLE ! From HDF
    integer, intent(in), optional  :: FIRSTMAF ! First to read (default 0)
    integer, intent(in), optional  :: LASTMAF ! Last to read (default last/file)
    logical, intent(in), optional  :: NEVERFAIL ! Don't quit if TRUE
    logical, intent(in), optional  :: L2AUX     ! Don't even warn if TRUE
    type(l1bdata_t), intent(inout) :: L1BDATA ! Result
    integer, intent(out) :: FLAG        ! Error flag
    integer, intent(out) :: NOMAFS      ! Number actually read
    integer, optional, intent(in) :: HDFVERSION
    logical, intent(in), optional  :: DONTPAD ! Don't try to pad even if gappy

    ! Local variables
    type(MLSFile_T), target :: f
    type(MLSFile_T), pointer :: fp
    integer :: Me = -1                  ! String index for trace
    integer :: myhdfVersion
    ! logical, parameter :: DEEBug = .false.
    integer :: status

    ! Executable code
    call trace_begin ( me, "ReadL1BData_fileHandle", &
      & cond=toggle(gen) .and. levels(gen) > 1 )

    if ( present(hdfVersion) ) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L1BDEFAULT_HDFVERSION
    end if

    ! Set up an MLSFile instance
    status = InitializeMLSFile( f, content='l1b', &
      & shortname='l1b', type=l_hdf, access=DFACC_RDONLY )
    f%fileID%f_id = L1FileHandle
    f%stillOpen = .true.
    f%hdfVersion = myhdfVersion
    fp => f
    call ReadL1BData_MLSFile ( fp, QuantityName, L1bData, NoMAFs, Flag, &
      & FirstMAF, LastMAF, NeverFail, dontPad, L2AUX )
    call trace_end ( "ReadL1BData_fileHandle", &
      & cond=toggle(gen) .and. levels(gen) > 1 )
  end subroutine ReadL1BData_fileHandle

  ! ----------------------------------------  ReadL1BData_MLSFile  -----
  subroutine ReadL1BData_MLSFile ( L1BFile, QuantityName, L1bData, NoMAFs, Flag, &
    & FirstMAF, LastMAF, NeverFail, dontPad, L2AUX )
    use MLSFiles, only: Dump
    use MLSFillValues, only: IsFillValue
    use Optional_m, only: Default
    use PCFHdr, only: GlobalAttributes
    ! Dummy arguments
    character(len=*), intent(in)   :: QUANTITYNAME ! Name of SD to read
    type(MLSFile_T), pointer       :: L1BFile
    integer, intent(out)           :: FLAG        ! Error flag
    integer, intent(out)           :: NOMAFS      ! Number actually read
    integer, intent(in), optional  :: FIRSTMAF ! First to read (default 0)
    integer, intent(in), optional  :: LASTMAF ! Last to read (default last/file)
    logical, intent(in), optional  :: NEVERFAIL ! Don't quit if TRUE
    logical, intent(in), optional  :: L2AUX     ! Don't even warn if TRUE
    type(l1bdata_t), intent(inout) :: L1BDATA ! Result
    logical, intent(in), optional  :: DONTPAD ! Don't try to pad even if gappy

    ! Local variables
    logical :: alreadyOpen
    logical :: DEEBug
    character(len=MaxNDSNames*128) :: DSNames
    logical :: isScalar
    type(l1bdata_t) :: L1BDATATMP
    integer :: Me = -1                  ! String index for trace
    integer :: myhdfVersion
    logical :: myDontPad
    integer :: returnStatus
    logical, parameter :: ShowName = .false.
    ! Executable code
    DEEBug = .false. ! ( index(QuantityName, '/GHz/GeodAngle') > 0 )
    if ( .not. associated(L1BFile) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'null pointer passed to readl1bdata--probably cant find ' // &
        & trim(QuantityName) )
      return
    endif
    if ( showName ) call output ( '&&&&&&&&&&&&&&&&& ' // trim(Quantityname), advance='yes' )
    call trace_begin ( me, "ReadL1BData_MLSFile", &
      & cond=toggle(gen) .and. levels(gen) > 1 )
    alreadyOpen = L1BFile%StillOpen
    if ( .not. alreadyOpen .and. DEEBug ) then
      print *, 'Oops--need to open l1b file before reading'
      call Dump( L1BFile, details=2 )
      call GetAllHDF5DSNames( L1BFile, DSNames )
      call Dump ( DSNames, 'DSNames' )
      call mls_openFile( L1BFile, returnStatus )
      call Dump( L1BFile, details=2 )
      call GetAllHDF5DSNames( L1BFile, DSNames )
      if ( returnStatus /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l1b file', MLSFile=L1BFile)
    end if
    myhdfVersion = L1BFile%HDFVersion
    ! print * 'hdfVersion: ', hdfVersion
    myDontPad = .false.
    if ( present(firstMAF) ) myDontPad = .true.
    if ( present(dontPad) ) myDontPad = dontPad
    if ( switchDetail(switches, 'l1bread') > -1 ) &
      & call output( 'About to read L1B dataset %% ' // &
      & trim(QuantityName) // &
      & ' %%', advance='yes' )

    if ( myhdfVersion == HDFVERSION_4 ) then
      call ReadL1BData_MF_hdf4 ( L1BFile, trim(QuantityName), L1bData, &
      & NoMAFs, Flag, FirstMAF, LastMAF, NeverFail, L2AUX )
      if ( flag /= 0 ) noMAFs = -1
    else
      call ReadL1BData_MF_hdf5 ( L1BFile, trim(QuantityName), L1bData, &
      & NoMAFs, Flag, FirstMAF, LastMAF, NeverFail, L2AUX )
      !Unfortunately, hdf5-formatted l1b data have different shapes from hdf4
      ! E.g., for MAFStartTimeTAI we obtain the following
      !  hdfVERSION      shape
      !     4           1   1   5
      !     5           5   1   1
      if ( Flag == 0 ) then
        call Reshape_for_hdf4(L1bData)
      else
        call MLSMessage ( MLSMSG_Warning, ModuleName // '/ReadL1BData_MLSFile', &
          & 'Failed to find '//trim(QuantityName)//' in l1b files')
        call OutputNamedValue ( 'read status flag', flag )
        call OutputNamedValue ( 'data type', trim(L1bData%data_type) )
        call Dump ( L1BFile, details=2 )
        call GetAllHDF5DSNames( L1BFile, DSNames )
        call Dump ( DSNames, 'DSNames' )
        if ( .not. Default( neverFail, .false. ) ) call crash_burn
        NOMAFS = -1
        go to 9
      end if
    end if
    isScalar = ( l1bData%noMAFs < 2 ) ! There may be a better way to decide
    if ( index(QuantityName, 'Angle') > 0 .and. DEEBUG ) then
      call outputnamedValue( 'isScalar', isScalar )
      call outputnamedValue( 'myDontPad', myDontPad )
      call outputnamedValue( 'IsL1BGappy(l1bData)', IsL1BGappy(l1bData) )
      if ( IsL1BGappy(l1bData) ) call showL1BGaps( l1bData )
    endif
    if ( myDontPad .or. flag /= 0 .or. isScalar .or. &
      & (GlobalAttributes%FirstMAFCtr > GlobalAttributes%LastMAFCtr) ) go to 9
    if ( .not. IsL1BGappy(l1bData) ) go to 9
    ! Must pad l1bdata; so first copy to temp l1bData
    if ( associated(l1bdata%dpField) .and. DEEBug ) then
      ! print *, 'max(l1bdata) ', maxval(l1bdata%dpField(1,1,:))
      ! print *, 'min(l1bdata) ', minval(l1bdata%dpField(1,1,:))
    end if
    call dupL1BData(l1bdata, l1bdataTmp)
    if ( associated(l1bdatatmp%dpField) .and. DEEBug ) then
      ! print *, 'max(l1bdatatmp) ', maxval(l1bdatatmp%dpField(1,1,:))
      ! print *, 'min(l1bdatatmp) ', minval(l1bdatatmp%dpField(1,1,:))
    end if
    call deallocatel1bData(l1bdata)
    if ( GlobalAttributes%LastMAFCtr > 0 ) &
      & NoMAFs = GlobalAttributes%LastMAFCtr - GlobalAttributes%FirstMAFCtr + 1
    if ( DEEBug ) print *, 'preparing to pad'
    if ( DEEBug ) print *, 'GlobalAttributes%FirstMAFCtr ', GlobalAttributes%FirstMAFCtr
    if ( DEEBug ) print *, 'GlobalAttributes%LastMAFCtr ', GlobalAttributes%LastMAFCtr
    if ( DEEBug ) print *, 'NoMAFs ', NoMAFs
    if ( present(firstMAF) .and. present(lastMAF)) then
      call PadL1BData(l1bdataTmp, l1bData, FirstMAF, LastMAF, NoMAFs)
      call deallocatel1bData(l1bdataTmp)
      if ( .not. alreadyOpen )  call mls_closeFile(L1BFile, returnStatus)
      go to 9
    end if
    call BadPadL1BData(l1bdataTmp, l1bData, GlobalAttributes%FirstMAFCtr, NoMAFs)
    if ( index(QuantityName, 'Angle') > 0 .and. DEEBUG ) then
      call output( 'Gone through padding', advance='yes' )
      call outputnamedValue( 'Fills in new l1bdata?', any(isFillValue(l1bdata%dpField)) )
      call outputnamedValue( 'Fills in l1bdataTmp?', any(isFillValue(l1bdataTmp%dpField)) )
    endif
    call deallocatel1bData(l1bdataTmp)
    if ( .not. present(firstMAF) .and. .not. present(lastMAF) ) go to 9
    ! Need to contract padded l1bdata to just those MAFs requested
    call dupL1BData(l1bdata, l1bdataTmp)
    call deallocatel1bData(l1bdata)
    if ( DEEBug ) print *, 'preparing to contract'
    call ContractL1BData(l1bdataTmp, l1bData, noMAFs, firstMAF, lastMAF)
    call deallocatel1bData(l1bdataTmp)
    if ( .not. alreadyOpen )  call mls_closeFile(L1BFile, returnStatus)
9   continue
    call trace_end ( "ReadL1BData_MLSFile", &
      & cond=toggle(gen) .and. levels(gen) > 1 )
  end subroutine ReadL1BData_MLSFile

  ! ----------------------------------------  ReadL1BData_MF_hdf4  -----
  subroutine ReadL1BData_MF_hdf4 ( L1BFile, QuantityName, L1bData, &
    & NoMAFs, Flag, FirstMAF, LastMAF, NeverFail, L2AUX )

    ! Dummy arguments
    character(len=*), intent(in)   :: QUANTITYNAME ! Name of SD to read
    type(MLSFile_T), pointer       :: L1BFile
    integer, intent(in), optional  :: FIRSTMAF ! First to read (default 0)
    integer, intent(in), optional  :: LASTMAF ! Last to read (default last in file)
    logical, intent(in), optional  :: NEVERFAIL ! Don't quit if TRUE
    logical, intent(in), optional  :: L2AUX     ! Don't even warn if TRUE
    type(l1bdata_t), intent(inout) :: L1BDATA ! Result
    integer, intent(out) :: FLAG        ! Error flag
    integer, intent(out) :: NOMAFS      ! Number actually read

    ! Local Parameters
    character (len=*), parameter :: INPUT_ERR = 'Error in input argument '
    integer, parameter :: MAX_VAR_DIMS = 32
    integer, parameter :: SD_NO_COUNTERMAF = -2

    ! Local Variables

    character (len=128) :: DUMMY        ! Dummy quantity name

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: ALLOC_ERR
    integer :: DATA_TYPE
    integer :: DIM_SIZES(MAX_VAR_DIMS)
    integer :: I
    integer :: L1FileHandle
    integer :: Me = -1                  ! String index for trace
    integer :: MLSMsgLevel              ! Eigher MLSMSG_Error or MLSMSG_Warning
    logical :: MyNeverFail
    integer :: N_ATTRS
    integer :: NUMMAFS
    integer :: RANK
    integer :: SDS1_ID
    integer :: SDS2_ID
    integer :: SDS_INDEX
    integer :: STATUS

    integer, dimension(:), allocatable :: EDGE
    integer, dimension(:), allocatable :: START
    integer, dimension(:), allocatable :: STRIDE

    real(r4), pointer, dimension(:,:,:) :: tmpR4Field

    ! Executable code
    call trace_begin ( me, "ReadL1BData_MF_hdf4", &
      & cond=toggle(gen) .and. levels(gen) > 1 )
    L1FileHandle = L1BFile%FileID%f_id
    call deallocateL1BData ( l1bData ) ! Avoid memory leaks

    flag = 0
    MyNeverFail = .false.
    if ( present(NeverFail) ) MyNeverFail = NeverFail
    MLSMsgLevel = merge(MLSMSG_Warning, MLSMSG_Error, myNeverFail)

    ! Find data sets for counterMAF & quantity by name

    sds_index = sfn2index(L1FileHandle, 'counterMAF')
    if ( sds_index == -1 ) then
      if ( .not. JUSTLIKEL2AUX ) then
        flag = NOCOUNTERMAFINDX
        call MLSMessage ( MLSMsgLevel, ModuleName, &
        & 'Failed to find index of counterMAF data set.', MLSFile=L1BFile)
        go to 9
      end if
      sds1_id = SD_NO_COUNTERMAF
    else

      sds1_id = sfselect(L1FileHandle, sds_index)
      if ( sds1_id == -1 ) then
        flag = NOCOUNTERMAFID
        call MLSMessage ( MLSMsgLevel, ModuleName, &
        & 'Failed to find identifier of counterMAF data set.', MLSFile=L1BFile)
        go to 9
      end if
    end if

    sds_index = sfn2index(L1FileHandle, quantityName)
    if ( sds_index == -1 ) then
      flag = NOQUANTITYINDEX
      dummy = 'Failed to find index of quantity "' // trim(quantityName) // &
        & '" data set.'
      call MLSMessage ( MLSMsgLevel, ModuleName, dummy, MLSFile=L1BFile )
      go to 9
    end if

    sds2_id = sfselect(L1FileHandle, sds_index)
    if ( sds2_id == -1 ) then
      flag = NODATASETID
      call MLSMessage ( MLSMsgLevel, ModuleName, &
      & 'Failed to find identifier of data set matching the index.', MLSFile=L1BFile)
      go to 9
    end if

    ! Find rank (# of dimensions), dimension sizes of quantity data set
    status = sfginfo ( sds2_id, dummy, rank, dim_sizes, data_type, &
      n_attrs )

    if ( status == -1 ) then
      flag = NODATASETRANK
      call MLSMessage ( MLSMsgLevel, ModuleName,&
      & 'Failed to find rank of data set.', MLSFile=L1BFile)
      go to 9
    end if

    ! allocate, based on above SD, dim info; don't track allocatable sizes
    allocate ( edge(rank), start(rank), stride(rank), stat=status)
    call test_allocate ( status, moduleName, 'edge, start, stride' )

    ! Set "slab" dimensions
    edge = dim_sizes(1:rank)
    start = 0
    stride = 1

    ! Fill in "indexing" values of l1b object

    l1bData%L1BName = quantityName
    l1bData%TrueRank = rank

    l1bData%noAuxInds = product(dim_sizes(1:rank-2))
    l1bData%maxMIFs = 1
    if ( rank > 1 ) l1bData%maxMIFs = dim_sizes(rank-1)

    ! Check input arguments, set noMAFs

    numMAFs = dim_sizes(rank)

    if ( present ( firstMAF ) ) then
      if ( (firstMAF >= numMAFs) .or. (firstMAF < 0) ) then
        flag = FIRSTMAFNOTFOUND
        call MLSMEssage ( MLSMsgLevel, ModuleName, &
        & input_err // 'firstMAF (bad chunkNo?)', MLSFile=L1BFile )
        go to 9
      end if
      l1bData%firstMAF = firstMAF
    else
      l1bData%firstMAF = 0
    end if

    if ( present (lastMAF) ) then
      if ( lastMAF < l1bData%firstMAF ) then
        flag = LASTMAFNOTFOUND
        call MLSMEssage ( MLSMsgLevel, ModuleName, &
        & input_err // 'last' , MLSFile=L1BFile)
        go to 9
      end if
      if ( lastMAF >= numMAFs ) then
        l1bData%noMAFs = numMAFs - l1bData%firstMAF
      else
        l1bData%noMAFs = lastMAF - l1bData%firstMAF + 1
      end if
    else
      l1bData%noMAFs = numMAFs - l1bData%firstMAF
    end if

    noMAFs = l1bData%noMAFs
    edge(rank) = l1bData%noMAFs
    start(rank) = l1bData%firstMAF

    ! allocate, read counterMAF
    call Allocate_test ( l1bData%counterMaf, l1bData%noMAFs, &
      & 'l1bData%counterMAF', ModuleName )
    if ( sds1_id /= SD_NO_COUNTERMAF ) then
      status = sfrdata_f90(sds1_id,  (/ l1bData%firstMAF /) , (/1/), &
        & (/l1bData%noMAFs/), l1bData%counterMAF )
      if ( status == -1 ) then
        flag = CANTREADCOUNTERMAF
        call MLSMessage ( MLSMsgLevel, ModuleName, &
        & MLSMSG_L1BRead // 'counterMAF.', MLSFile=L1BFile )
        go to 9
      end if
    else
      ! Since we aren't reading these, just make them internally consistent
      do i = 1, l1bData%noMAFs
        l1bData%counterMAF(i) = l1bData%firstMAF + i - 1
      end do
    end if

    l1bData%FirstMAFCtr = myminval(l1bData%counterMAF)
    l1bData%LastMAFCtr = maxval(l1bData%counterMAF)
    ! allocate, read according to field type; nullify unused pointers
    select case ( data_type )

    case ( DFNT_CHAR8 ) ! ----------------------- character
      allocate ( l1bData%charField(l1bData%noAuxInds,l1bData%maxMIFs, &
        & l1bData%noMAFs), STAT=alloc_err )
      if ( alloc_err /= 0 ) then
        flag = CANTALLOCATECHARS
        ! Announce the error
        call test_allocate ( alloc_err, ModuleName, "l1bData%charField" )
        go to 9
      end if
      ! Account for the allocation size
      addr = 0
      if ( size(l1bData%charField) > 0 ) &
        & addr = transfer(c_loc(l1bData%charField(1,1,1)), addr)
      call test_allocate ( alloc_err, ModuleName, "l1bData%charField", &
        & uBounds = [l1bData%noAuxInds,l1bData%maxMIFs], &
        & elementSize = storage_size(l1bData%charField) / 8, address=addr )
      nullify (l1bData%intField, l1bData%dpField)
      l1bdata%data_type = 'character'
      status = sfrcdata ( sds2_id, start, stride, edge, &
        & l1bData%charField )

    case ( DFNT_INT32 ) ! ------------------------------ integer
      call allocate_test ( l1bData%intField, &
        & l1bData%noAuxInds, l1bData%maxMIFs, l1bData%noMAFs, &
        & 'l1bData%intField', ModuleName )
      nullify ( l1bData%charField, l1bData%dpField )
      l1bdata%data_type = 'integer'
      status = sfrdata_f90 ( sds2_id, start, stride, edge, &
          l1bData%intField )

    case ( DFNT_FLOAT64 ) ! ------------------------------ real (r8)
      call allocate_test ( l1bData%dpField, &
        & l1bData%noAuxInds, l1bData%maxMIFs, l1bData%noMAFs, &
        & 'l1bData%dpField', ModuleName )
      nullify ( l1bData%charField, l1bData%intField )
      l1bdata%data_type = 'double'
      status = sfrdata_f90 ( sds2_id, start, stride, edge, &
          l1bData%dpField )

    case ( DFNT_FLOAT32 ) ! ------------------------------ real (r4)
      call allocate_test ( l1bData%dpField, &
        & l1bData%noAuxInds, l1bData%maxMIFs, l1bData%noMAFs, &
        & 'l1bData%dpField', ModuleName )
      nullify ( l1bData%charField, l1bData%intField, tmpr4Field )
      l1bdata%data_type = 'double'

      call allocate_test ( tmpr4Field, &
        & l1bData%noAuxInds, l1bData%maxMIFs, l1bData%noMAFs, &
        & 'tmpR4Field', ModuleName )
      status = sfrdata_f90 ( sds2_id, start, stride, edge, &
          tmpR4Field )
      l1bData%dpField = tmpR4Field

      call deallocate_test ( tmpr4Field, 'tmpr4Field', ModuleName )

    case default
      status = -2
    end select ! ----------------------------------------------------

    if ( status == -1 ) then
      flag = CANTREAD3DFIELD
      call MLSMessage ( MLSMsgLevel, ModuleName, &
      & MLSMSG_L1BRead // quantityName, MLSFile=L1BFile )
      go to 9
    else if ( status == -2 ) then
      flag = UNKNOWNDATATYPE
      call MLSMessage ( MLSMsgLevel, ModuleName, &
      & 'Unknown data type in readl1bData', MLSFile=L1BFile   )
      go to 9
    end if

    ! Terminate access to the data sets

    if ( sds1_id /= SD_NO_COUNTERMAF ) then
      status = sfendacc(sds1_id)
      if ( status == -1 ) then
        flag = CANTENDCOUNTERMAF
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Failed to terminate access to data sets.', MLSFile=L1BFile )
        flag = -1
        if ( MyNeverFail ) go to 9
      end if
    end if

    status = sfendacc(sds2_id)
    if ( status == -1 ) then
      flag = CANTENDQUANTITY
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Failed to terminate access to data sets.', MLSFile=L1BFile )
      flag = -1
    end if

9   continue

    call trace_end ( "ReadL1BData_MF_hdf4", &
      & cond=toggle(gen) .and. levels(gen) > 1 )

  end subroutine ReadL1BData_MF_hdf4

  ! ----------------------------------------  ReadL1BData_MF_hdf5  -----
  subroutine ReadL1BData_MF_hdf5 ( L1BFile, QuantityName, L1bData, NoMAFs, &
    & Flag, FirstMAF, LastMAF, NeverFail, L2AUX )
    use MLSFillValues, only: IsFillValue
    use HDF5, only: HSize_T
    use MLSHDF5, only: IsHDF5DSPresent, LoadFromHDF5DS, &
      & GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType

    ! Dummy arguments
    character(len=*), intent(in)   :: QUANTITYNAME ! Name of SD to read
    type(MLSFile_T), pointer       :: L1BFile
    integer, intent(in), optional  :: FIRSTMAF ! First to read (default 0)
    integer, intent(in), optional  :: LASTMAF ! Last to read (default last/file)
    logical, intent(in), optional  :: NEVERFAIL ! Don't quit if TRUE
    logical, intent(in), optional  :: L2AUX     ! Don't even warn if TRUE
    type(l1bdata_t), intent(inout) :: L1BDATA ! Result
    integer, intent(out) :: FLAG        ! Error flag
    integer, intent(out) :: NOMAFS      ! Number actually read

    ! Local Parameters
    character (len=*), parameter :: INPUT_ERR = 'Error in input argument '

    ! Local Variables
    character (len=128) :: DUMMY        ! Dummy quantity name
    character(len=1) :: Char_rank
    real(r8), dimension(:,:,:,:), pointer :: DP4Buf => null()
    character(len=1024) :: DSNames
    integer :: I
    integer :: L1FileHandle
    integer :: MAFoffset
    integer :: Me = -1                  ! String index for trace
    integer :: MLSMsgLevel              ! Eigher MLSMSG_Error or MLSMSG_Warning
    logical :: MyNeverFail
    integer :: NUMMAFS
    integer :: RANK
    integer :: CMRANK
    character(len=16) :: QTYPE
    integer :: STATUS

    integer(kind=hSize_t), dimension(:), allocatable :: HDIMS
    integer,               dimension(:), allocatable :: DIMS
    integer(kind=hSize_t), dimension(:), allocatable :: MAXDIMS
    integer(kind=hSize_t), dimension(:), allocatable :: CMDIMS
    integer(kind=hSize_t), dimension(:), allocatable :: CMMAXDIMS

    logical, parameter           :: DEEBUG = .false.
    logical :: isL2AUX

    ! Executable code
    call trace_begin ( me, "ReadL1BData_MF_hdf5", &
      & cond=toggle(gen) .and. levels(gen) > 1 )
    L1FileHandle = L1BFile%FileID%f_id
    if ( L1FileHandle < 1 .or. .not. L1BFile%stillOpen ) then
      call MLS_OpenFile ( L1BFile, status )
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open L1B File', MLSFile=L1BFile )
      L1FileHandle = L1BFile%FileID%f_id
    endif
    if ( present(FirstMAF) ) then
      MAFoffset = max(0, FirstMAF)   ! Never let this be < 0
    end if
    call deallocateL1BData ( l1bData ) ! Avoid memory leaks

    flag = 0
    MyNeverFail = .false.
    if ( present(NeverFail) ) MyNeverFail = NeverFail
    MLSMsgLevel = merge(MLSMSG_Warning, MLSMSG_Error, myNeverFail)
    isL2AUX = .false.
    if ( present(l2AUX) ) isL2AUX = L2AUX

    if ( .not. IsHDF5DSPresent(L1FileHandle, QuantityName) ) then
      flag = NOQUANTITYINDEX
      print *, 'Oops--' // trim(QuantityName) // ' not here'
      dummy = 'Failed to find index of quantity "' // trim(quantityName) // &
        & '" data set.'
      call MLSMessage ( MLSMsgLevel, ModuleName, dummy, MLSFile=L1BFile )
      go to 9
    end if

    ! Find Qtype, rank and dimensions of QuantityName
    ! print*, ' Find Qtype, rank and dimensions of QuantityName ', trim(QuantityName)
    call GetHDF5DSRank(L1FileHandle, QuantityName, rank)
    l1bData%TrueRank = rank
    allocate ( dims(rank), Hdims(rank), maxDims(rank), stat=status )
    if ( status /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Could not allocate dims in ReadL1BData_MF_hdf5' )
    call GetHDF5DSDims(L1FileHandle, QuantityName, Hdims, maxDims)
    dims = Hdims
    call GetHDF5DSQType ( L1FileHandle, QuantityName, Qtype )
    if ( DEEBug ) print *, 'L1FileHandle ', L1FileHandle
    if ( DEEBug ) print *, 'QuantityName ', trim(QuantityName)
    if ( DEEBug ) print *, 'rank ', rank
    if ( DEEBug ) print *, 'maxDims ', maxDims
    if ( DEEBug ) print *, 'dims ', dims
    if ( DEEBug ) print *, 'Qtype ', Qtype
    if ( present(firstMAF) .and. DEEBug ) print *, 'firstMAF ', firstMAF
    if ( present(LastMAF) .and. DEEBug ) print *, 'LastMAF ', LastMAF

    l1bData%noAuxInds = product(dims(1:rank-2))
    l1bData%maxMIFs = 1
    if ( rank > 1 ) l1bData%maxMIFs = dims(rank-1)

    ! Check input arguments, set noMAFs

    numMAFs = dims(rank)

    if ( present ( firstMAF ) ) then
      if ( (firstMAF >= numMAFs) .or. (firstMAF < 0) ) then
        flag = FIRSTMAFNOTFOUND
        if ( MyNeverFail ) go to 9
        call MLSMEssage ( MLSMsgLevel, ModuleName, &
        & input_err // 'firstMAF (bad chunkNo?)', MLSFile=L1BFile )
        go to 9
      end if
      l1bData%firstMAF = firstMAF
    else
      l1bData%firstMAF = 0
    end if

    if ( present (lastMAF) ) then
      if ( lastMAF < l1bData%firstMAF ) then
        flag = LASTMAFNOTFOUND
        call dump( (/lastMAF, l1bData%firstMAF/), 'lastMAF, l1bData%firstMAF')
        call MLSMEssage ( MLSMsgLevel, ModuleName, &
        & input_err // 'last', MLSFile=L1BFile )
        go to 9
      end if
      if ( lastMAF >= numMAFs ) then
        l1bData%noMAFs = numMAFs - l1bData%firstMAF
      else
        l1bData%noMAFs = lastMAF - l1bData%firstMAF + 1
      end if
    else
      l1bData%noMAFs = numMAFs - l1bData%firstMAF
    end if

    if ( DEEBug ) print *, 'l1bData%noMAFs ', l1bData%noMAFs
    l1bData%L1BName = quantityName

    noMAFs = l1bData%noMAFs
    if ( DEEBug ) print *, 'noMAFs ', noMAFs

    call Allocate_test ( l1bData%counterMaf, l1bData%noMAFs, &
      & 'l1bData%counterMAF', ModuleName )
    ! Find data sets for counterMAF & quantity by name

    if ( .not. IsHDF5DSPresent(L1FileHandle, '/counterMAF') ) then
      if ( DEEBUG ) print *, 'no counterMAF array in file'
      if ( .not. JUSTLIKEL2AUX ) then
        flag = NOCOUNTERMAFINDX
        call MLSMessage ( MLSMsgLevel, ModuleName, &
        & 'Failed to find index of counterMAF data set.', MLSFile=L1BFile)
        go to 9
      else
        if ( .not. isL2AUX ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Failed to find index of counterMAF data set.')
        ! Since we aren't reading these, just make them internally consistent
        do i = 1, l1bData%noMAFs
          l1bData%counterMAF(i) = l1bData%firstMAF + i - 1
        end do
        ! Have we damaged L1BFile?
        if ( trim(Quantityname) == '/MAFStartTimeTAI' .and. .false. ) then
          call GetAllHDF5DSNames( L1BFile, DSNames )
          call Dump ( DSNames, 'DSNames' )
        endif
      end if
    else
      if ( DEEBUG) print *, 'Getting counterMAF rank'
      call GetHDF5DSRank(L1FileHandle, '/counterMAF', cmrank)
      if ( DEEBUG) print *, cmrank
      allocate ( cmdims(cmrank), cmmaxDims(cmrank) )
      if ( DEEBUG) print *, 'getting counterMAF dims'
      call GetHDF5DSDims(L1FileHandle, '/counterMAF', cmdims, cmmaxDims)
      if ( DEEBUG) print *, cmdims, cmmaxDims
      if ( DEEBUG) print *, 'l1bData%noMAFs', l1bData%noMAFs
      ! allocate(countermaf_ptr(MAX_NOMAFS))
      ! countermaf_ptr = 0
      if ( present(FirstMAF) ) then
        if ( DEEBUG) print *, 'reading counterMAF ', MAFoffset, l1bData%noMAFs
        call LoadFromHDF5DS(L1FileHandle, '/counterMAF', l1bData%counterMaf, &
          & (/MAFoffset/), (/l1bData%noMAFs/) )
      else if ( cmdims(1) /= l1bData%noMAFs ) then
        flag = CANTREADCOUNTERMAF
        if ( MyNeverFail ) then
          ! deallocate(dims, maxDims, cmdims, cmmaxdims)
          ! go to 9
          ! Since we aren't reading these, just make them internally consistent
          do i = 1, l1bData%noMAFs
            l1bData%counterMAF(i) = l1bData%firstMAF + i - 1
          end do
          flag = 0
        end if
        if ( DEEBug ) then
          call output('Quantity name: ', advance = 'no')
          call output(Quantityname, advance = 'yes')
          call output('Quantity rank: ', advance = 'no')
          call output(rank, advance = 'yes')
          call output('Quantity dims: ', advance = 'no')
          call output(int(dims), advance = 'yes')
          call output('Quantity noMAFs: ', advance = 'no')
          call output(l1bData%noMAFs, advance = 'yes')
          call output('counterMAF dims: ', advance = 'no')
          call output(int(cmdims), advance = 'yes')
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Sorry--ReadL1BData_hdf5 says counterMaf sized differently from ' &
            & // trim(QuantityName), MLSFile=L1BFile )
        endif
      else
        if ( DEEBUG) print *, 'reading counterMAF '
        ! This intermediate cm_array shouldn't be necessary
        ! unfortunately, w/o it sometimes hdf5 bombs
        ! allocate(cm_array(cmdims(1)), stat=status)
        ! allocate(cm_array(MAX_NOMAFS), stat=status)
        ! call LoadFromHDF5DS(L1FileHandle, '/counterMAF', cm_array)
        ! l1bData%counterMaf = cm_array(1:cmdims(1))
        ! deallocate(cm_array)
        call LoadFromHDF5DS(L1FileHandle, '/counterMAF', l1bData%counterMaf)
      end if
      if ( DEEBUG) print *, 'deallocating counterMAF dims'
      deallocate(cmdims, cmmaxdims)
    end if

    if ( DEEBUG) print *, 'computing FirstMAFCtr'
    l1bData%FirstMAFCtr = myminval(l1bData%counterMAF)
    if ( DEEBUG) print *, 'computing LastMAFCtr'
    l1bData%LastMAFCtr = maxval(l1bData%counterMAF)
    if ( DEEBUG) print *, 'l1bData%FirstMAFCtr ', l1bData%FirstMAFCtr
    if ( DEEBUG) print *, 'l1bData%LastMAFCtr ', l1bData%LastMAFCtr
    if ( DEEBUG) print *, 'About to use LoadFromHDF5DS to read ', trim(QuantityName)
    if ( DEEBUG) print *, 'dims ', dims
    if ( DEEBUG) print *, 'noMAFs ', l1bData%noMAFs
    write(Char_rank, '(i1)') rank
    if ( DEEBUG) print *, trim(Qtype) // Char_rank
    if ( DEEBUG .and. present(FirstMAF) ) then
      print *, 'FirstMAF-1 ', FirstMAF-1
      print *, 'MAFoffset ', MAFoffset
      print *, 'l1bData%noMAFs ', l1bData%noMAFs
    end if

    ! The following is a crude and despicable hack
    ! Please repair GetHDF5DSQType and delete these lines
    if ( Qtype == 'unknown' ) Qtype = 'character'

    select case (trim(Qtype) // Char_rank)
    case ('real1')
      call allocate_test ( l1bData%DpField, l1bData%noMAFs, 1, 1, "l1bData%DpField", &
        & moduleName )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,1,1), &
          & (/MAFoffset/), (/l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,1,1))
      end if
      l1bdata%data_type = 'double'
    case ('real2')
      call allocate_test ( l1bData%DpField, dims(1), l1bData%noMAFs, 1, "l1bData%DpField", &
        & moduleName )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,:,1), &
          & (/0,MAFoffset/), (/dims(1),l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,:,1))
      end if
      l1bdata%data_type = 'double'
      if ( index(QuantityName, 'Angle') < 1 .or. .true. ) then
      elseif ( any(isFillValue(l1bData%dpField) ) ) then
        call output( 'Fill values among 2d real l1bdata', advance='yes' )
        call outputNamedValue( 'shape(l1bData%dpField)', shape(l1bData%dpField) )
        call dump( l1bData%dpField, 'l1bData%dpField' )
      else
        call output( '2d real l1bdata ' // trim(QuantityName) // 'are clean', advance='yes' )
      endif
    case ('real3')
      call allocate_test ( l1bData%DpField, dims(1), dims(2), l1bData%noMAFs, &
        & "l1bData%DpField", moduleName )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField, &
          & (/0,0,MAFoffset/), (/dims(1),dims(2),l1bData%noMAFs/) )
      else
         call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField)
      end if
      if ( index(QuantityName, 'Angle') < 1 .or. .true. ) then
      elseif ( any(isFillValue(l1bData%dpField) ) ) then
        call output( 'Fill values among 3d real l1bdata', advance='yes' )
        call outputNamedValue( 'shape(l1bData%dpField)', shape(l1bData%dpField) )
        call dump( l1bData%dpField, 'l1bData%dpField' )
      else
        call output( '3d real l1bdata are clean', advance='yes' )
      endif
      l1bdata%data_type = 'double'
    case ('real4')
      call allocate_test ( l1bData%DpField, dims(1)*dims(2), dims(3), l1bData%noMAFs, &
        & "l1bData%DpField", moduleName )
      call allocate_test( DP4Buf, dims(1), dims(2), dims(3), l1bData%noMAFs, &
        & 'DP4Buf', ModuleName )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS( L1FileHandle, QuantityName, DP4Buf, &
          & (/0,0,0,MAFoffset/), &
          & (/dims(1),dims(2),dims(3),l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS( L1FileHandle, QuantityName, DP4Buf)
      end if
      l1bData%DpField = reshape( DP4Buf, &
        & (/dims(1)*dims(2), dims(3), l1bData%noMAFs /) )
      call deallocate_test( DP4Buf, 'DP4Buf', ModuleName )
      l1bdata%data_type = 'double'
    case ('double1')
      call allocate_test ( l1bData%DpField, l1bData%noMAFs, 1, 1, "l1bData%DpField", &
        & moduleName )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,1,1), &
          & (/MAFoffset/), (/l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,1,1))
      end if
      l1bdata%data_type = 'double'
    case ('double2')
      call allocate_test ( l1bData%DpField, dims(1), l1bData%noMAFs, 1, "l1bData%DpField", &
        & moduleName )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,:,1), &
          & (/0,MAFoffset/), (/dims(1),l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,:,1))
      end if
      l1bdata%data_type = 'double'
    case ('double3')
      call allocate_test ( l1bData%DpField, dims(1), dims(2), l1bData%noMAFs, &
        & "l1bData%DpField", moduleName )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField, &
          & (/0,0,MAFoffset/), (/ dims(1),dims(2),l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField)
      end if
      l1bdata%data_type = 'double'
    case ('double4')
      call allocate_test ( l1bData%DpField, dims(1)*dims(2), dims(3), l1bData%noMAFs, &
        & "l1bData%DpField", moduleName )
      call allocate_test( DP4Buf, dims(1), dims(2), dims(3), l1bData%noMAFs, &
        & 'DP4Buf', ModuleName )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS( L1FileHandle, QuantityName, DP4Buf, &
          & (/0,0,0,MAFoffset/), &
          & (/dims(1),dims(2),dims(3),l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS( L1FileHandle, QuantityName, DP4Buf)
      end if
      l1bData%DpField = reshape( DP4Buf, &
        & (/ dims(1)*dims(2), dims(3), l1bData%noMAFs /) )
      call deallocate_test( DP4Buf, 'DP4Buf', ModuleName )
      l1bdata%data_type = 'double'
    case ('integer1')
      allocate( l1bData%intField(l1bData%noMAFs, 1, 1),stat=status)
      call test_allocate ( status, moduleName, "l1bData%intField", &
        & uBounds = [l1bData%noMAFs, 1, 1], &
        & elementSize = storage_size(l1bData%intField) / 8 )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%intField(:,1,1), &
          & (/MAFoffset/), (/l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%intField(:,1,1))
      end if
      l1bdata%data_type = 'integer'
    case ('integer2')
      allocate( l1bData%IntField(dims(1),l1bData%noMAFs, 1),stat=status)
      call test_allocate ( status, moduleName, "l1bData%intField", &
        & uBounds = [int(dims(1)),l1bData%noMAFs, 1], &
        & elementSize = storage_size(l1bData%intField) / 8 )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField(:,:,1), &
          & (/0,MAFoffset/), (/int(dims(1)),l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField(:,:,1))
      end if
      l1bdata%data_type = 'integer'
    case ('integer3')
      allocate( l1bData%IntField(dims(1),dims(2),l1bData%noMAFs),stat=status)
      call test_allocate ( status, moduleName, "l1bData%intField", &
        & uBounds = [int(dims(1:2)),l1bData%noMAFs], &
        & elementSize = storage_size(l1bData%intField) / 8 )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField, &
          & (/0,0,MAFoffset/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField)
      end if
!     call MLSMessage ( MLSMSG_Error, ModuleName, &
!     & 'Sorry--LoadFromHDF5DS not yet written for type integer(:,:,:).', MLSFile=L1BFile)
      l1bdata%data_type = 'integer'
    case ('character1')
      allocate( l1bData%charField(l1bData%noMAFs, 1, 1),stat=status)
      call test_allocate ( status, moduleName, "l1bData%charField", &
        & uBounds = [l1bData%noMAFs, 1, 1], &
        & elementSize = storage_size(l1bData%charField) / 8 )
      if ( present(FirstMAF) ) then
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%charField(:,1,1), &
          & (/MAFoffset/), (/l1bData%noMAFs/) )
      else
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%charField(:,1,1))
      end if
      ! call MLSMessage ( MLSMSG_Error, ModuleName, &
      ! & 'Sorry--LoadFromHDF5DS not yet written for type character(:).')
      l1bdata%data_type = 'character'
    case ('character3')
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--LoadFromHDF5DS not yet rewritten for type char(:,:,:).', MLSFile=L1BFile)
      l1bdata%data_type = 'integer'
    case default
      l1bdata%data_type = trim(Qtype) // Char_rank ! 'unknown'
      flag = UNKNOWNDATATYPE
      deallocate(dims, maxDims)
      call MLSMessage ( MLSMsgLevel, ModuleName, &
        & 'Sorry--ReadL1BData_hdf5 has encountered an unknown data type: ' &
        & // trim(Qtype) // Char_rank, MLSFile=L1BFile)
      go to 9
    end select
    if ( DEEBUG ) call dump(l1bData, 0)

9    continue
    ! No need to deallocate cmdims, cmmaxdims, dims and maxdims
    ! to avoid memory leaks because they're allocatable
    call trace_end ( "ReadL1BData_MF_hdf5", &
      & cond=toggle(gen) .and. levels(gen) > 1 )
  end subroutine ReadL1BData_MF_hdf5

  ! -------------------------------------------  Reshape_For_HDF4  -----
  subroutine Reshape_For_HDF4 ( L1bData )

    ! Here's what we'll assume:
    ! If the true rank of l1bdata is 3 or 0, no need to reshape
    ! If it's 1 or 2 then one of the following apply
    !  hdfVERSION         rank 1       rank 2(a)     rank 2(b)
    !      4               1 1 5         10 1 5       1 10 5
    !      5               5 1 1         10 5 1       10 5 1
    !   reorder            2 3 1         1  3 2       3  1 2
    ! (depending on whether it's (a) or (b) methods that apply;
    !   not sure which so we'll code for either; uh-oh, looking like it's (b))
    ! Arguments
    use MLSFillValues, only: IsFillValue
    type(l1bdata_t), intent(inout) :: L1BDATA ! Result
    ! Local variables
    character(len=MaxCharFieldLen), &
      &        dimension(:,:,:), pointer :: CharField => NULL()
    real(r8),  dimension(:,:,:), pointer :: DpField => NULL()
    integer,   dimension(:,:,:), pointer :: IntField => NULL()
    integer, dimension(3)                :: old_shape
    integer, dimension(3)                :: new_shape
    integer, dimension(3)                :: new_order
    integer, dimension(3, 3), parameter  :: reorder = &
      & reshape( &
      & source = (/ 2, 3, 1, 1, 3, 2, 1, 2, 3 /), &
      & shape = (/ 3, 3 /) &
      & )
!     & source = (/ 2, 3, 1, 1, 3, 2, 3, 1, 2 /), &  ! This transposed desired
    integer                              :: status   ! result (don't know why)
    logical, parameter           :: DEEBUG = .FALSE.
    logical                      :: FillInNew
    logical                      :: FillInOld
    character(len=1), parameter  :: method = 'b'
    integer                      :: mord
    integer                      :: S ! Size in bytes of object to deallocate

    ! Executable
    if ( DEEBUG ) then
      print *, 'l1b data_type: ', trim(l1bData%data_type)
      print *, 'rank: ', l1bData%TrueRank
    end if
    if ( l1bData%TrueRank > 2 .or. l1bData%TrueRank < 1 ) return
    new_shape = 1
    if ( method == 'a' .or. l1bData%TrueRank == 1 ) then
      new_order = reorder(:,l1bData%TrueRank)
      mord = 1
    else
      new_order = reorder(:,l1bData%TrueRank+1)
      mord = 2
    end if
    if ( DEEBUG ) then
      print *, 'new_order: ', new_order
      print *, 'mord: ', mord
      print *, '     o l d   f o r m'
      call DumpL1BData(l1bData)
    end if
    select case (l1bData%data_type)
    case('character')
      if ( .not. associated(l1bData%CharField) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 found ' // trim(l1bData%data_type) // &
        & 'unassociated')
      old_shape = shape(l1bData%CharField)
      new_shape(3) = old_shape(l1bData%TrueRank)
      if ( l1bData%TrueRank == 2 ) new_shape(mord) = old_shape(1)
      allocate(CharField(new_shape(1), new_shape(2), new_shape(3)), stat=status)
      call test_allocate ( status, moduleName, trim(l1bData%data_type), &
        & uBounds = new_shape(1:3), elementSize = storage_size(charField) / 8 )
      CharField = reshape(source=l1bData%CharField, &
        & shape=new_shape, order=new_order)
      s = size(l1bData%CharField) * storage_size(l1bData%CharField) / 8
      deallocate(l1bData%CharField, stat=status)
      call test_deallocate ( status, moduleName, trim(l1bData%data_type), s )
      l1bData%CharField => CharField
    case('double')
      if ( .not. associated(l1bData%DpField) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 found ' // trim(l1bData%data_type) // &
        & 'unassociated')
      old_shape = shape(l1bData%DpField)
      new_shape(3) = old_shape(l1bData%TrueRank)
      FillInOld = any(isFillValue(l1bData%DpField))
      if ( l1bData%TrueRank == 2 ) new_shape(mord) = old_shape(1)
      allocate(DpField(new_shape(1), new_shape(2), new_shape(3)), stat=status)
      call test_allocate ( status, moduleName, trim(l1bData%data_type), &
        & uBounds = new_shape(1:3), elementSize = storage_size(dpField) / 8 )
      DpField = reshape(source=l1bData%DpField, &
        & shape=new_shape, order=new_order)
      s = size(l1bData%DpField) * storage_size(l1bData%DpField) / 8
      deallocate(l1bData%DpField, stat=status)
      call test_deallocate ( status, moduleName, trim(l1bData%data_type), s )
      l1bData%DpField => DpField
      FillInNew = any(isFillValue(l1bData%DpField))
      if ( (FillInOld .neqv. FillInNew) .and. DEEBUG ) then
        call outputNamedValue( 'Fill values before reshaping', FillInOld )
        call outputNamedValue( 'Fill values after reshaping', FillInNew )
        call outputNamedValue( 'old shape', old_shape )
        call outputNamedValue( 'new shape', new_shape )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 has iuntroduced or removed Fill values')
      endif
      if ( DEEBUG ) then
        print *, 'old_shape: ', old_shape
        print *, 'new_shape: ', new_shape
      end if
    case('integer')
      if ( .not. associated(l1bData%IntField) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 found ' // trim(l1bData%data_type) // &
        & 'unassociated')
      old_shape = shape(l1bData%IntField)
      new_shape(3) = old_shape(l1bData%TrueRank)
      if ( l1bData%TrueRank == 2 ) new_shape(mord) = old_shape(1)
      allocate(IntField(new_shape(1), new_shape(2), new_shape(3)), stat=status)
      call test_allocate ( status, moduleName, trim(l1bData%data_type), &
        & uBounds = new_shape(1:3), elementSize = storage_size(intField) / 8 )
      IntField = reshape(source=l1bData%IntField, &
        & shape=new_shape, order=new_order)
      s = size(l1bData%IntField) * storage_size(l1bData%IntField) / 8
      deallocate(l1bData%IntField, stat=status)
      call test_deallocate ( status, moduleName, trim(l1bData%data_type), s )
      l1bData%IntField => IntField
    case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 has encountered an unknown data type: ' &
        & // trim(l1bData%data_type))
    end select
    if ( DEEBUG ) then
      print *, '     n e w   f o r m'
      call DumpL1BData(l1bData)
    end if
  end subroutine Reshape_For_HDF4

  ! ----------------------------------------------------  cpField  -----
  subroutine cpField(l1bDataIn, nIn, l1bdataOut, nOut, m)
    ! copy data from l1bDataIn to l1bdataOut starting from index n(In, Out)
    ! where the starting point may be different for the two
    ! Optionally continue copying for m indices
    ! (thus default is m==1)
    ! Arguments
    type (L1BData_T), intent(in)    :: l1bDataIn
    type (L1BData_T), intent(inout) :: l1bDataOut
    integer, intent(in)             :: nIn
    integer, intent(in)             :: nOut
    integer, optional, intent(in)   :: m
    ! Internal variables
    integer :: nn  ! number of indices to copy
    integer :: c1, c2, m1, m2 ! starting, ending channel nums and mif nums
    ! Executable
    nn = 0
    if ( present(m) ) nn=m-1
    ! print *, 'Copying from to ', nIn, nOut
    if ( associated(l1BDataIn%charField) .and. &
      & associated(l1BDataOut%charField) ) then
        c1 = 1
        c2 = min( size(l1BDataIn%charField, 1), size(l1BDataOut%charField, 1) )
        m1 = 1
        m2 = min( size(l1BDataIn%charField, 2), size(l1BDataOut%charField, 2) )
        l1BDataOut%charField(c1:c2,m1:m2,nOut:nOut+nn) = &
        & l1BDataIn%charField(c1:c2,m1:m2,nIn:nIn+nn)
    end if
    if ( associated(l1BDataIn%intField) .and. &
      & associated(l1BDataOut%intField) ) then
        c1 = 1
        c2 = min( size(l1BDataIn%intField, 1), size(l1BDataOut%intField, 1) )
        m1 = 1
        m2 = min( size(l1BDataIn%intField, 2), size(l1BDataOut%intField, 2) )
        l1BDataOut%intField(c1:c2,m1:m2,nOut:nOut+nn) = &
        & l1BDataIn%intField(c1:c2,m1:m2,nIn:nIn+nn)
    end if
    if ( associated(l1BDataIn%dpField) .and. &
      & associated(l1BDataOut%dpField) ) then
        if ( nOut+nn > size(l1BDataOut%dpField, 3) ) then
          call output('size(l1BDataOut%dpField, 3) ', advance='no')
          call output(size(l1BDataOut%dpField, 3), advance='yes')
          call output('nOut+nn ', advance='no')
          call output(nOut+nn, advance='yes')
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Tried to copy past size of output field in cpField')
        else if ( nIn+nn > size(l1BDataIn%dpField, 3) ) then
          call output('size(l1BDataIn%dpField, 3) ', advance='no')
          call output(size(l1BDataIn%dpField, 3), advance='yes')
          call output('nIn+nn ', advance='no')
          call output(nIn+nn, advance='yes')
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Tried to copy past size of input field in cpField')
        end if
        c1 = 1
        c2 = min( size(l1BDataIn%dpField, 1), size(l1BDataOut%dpField, 1) )
        m1 = 1
        m2 = min( size(l1BDataIn%dpField, 2), size(l1BDataOut%dpField, 2) )
        l1BDataOut%dpField(c1:c2,m1:m2,nOut:nOut+nn) = &
        & l1BDataIn%dpField(c1:c2,m1:m2,nIn:nIn+nn)
    ! print *, l1BDataIn%dpField(1,1,nIn:nIn+nn)
    end if
  end subroutine cpField

  ! --------------------------------------------------  ZeroField  -----
  subroutine ZeroField(l1bData, n, value, m, chValue)
    ! Set l1bData to zero starting from index n
    ! Optionally continue zeroing for m indices
    ! (thus default is m==1)
    ! Arguments
    type (L1BData_T), intent(inout)         :: l1bData
    integer, intent(in)                     :: n
    real, optional, intent(in)              :: value   ! default is 0.
    integer, optional, intent(in)           :: m
    character(len=1), optional, intent(in)  :: chValue ! default is ' '
    ! Internal variables
    real             :: zero
    character(len=1) :: blank
    integer          :: nn  ! number of indices to copy
    ! Executable
    nn = 0
    if ( present(m) ) nn=m-1
    zero = 0.
    if ( present(value) ) zero = value
    blank = ' '
    if ( present(chValue) ) blank = chValue
    if ( associated(l1BData%charField)  ) then
        l1BData%charField(:,:,n:n+nn) = blank
    end if
    if ( associated(l1BData%intField)  ) then
        l1BData%intField(:,:,n:n+nn) = int(zero)
    end if
    if ( associated(l1BData%dpField)  ) then
        l1BData%dpField(:,:,n:n+nn) = zero
    end if
  end subroutine ZeroField

  ! ---------------------------------------------------  MyMinval  -----
  function MyMinval ( ints ) result ( mymin )
  ! find minimum value of integer array ints
  ! subject to constraint that none is < 0
  ! (so we avoid picking any undefined, i.e. -999)
  ! Args
    integer, dimension(:), intent(in)  :: ints
    integer                            :: mymin
    ! Internal variables
    integer :: i
    ! Executable
    mymin= maxval(ints)
    if ( size(ints) < 2 ) return
    do i=1, size(ints)
      if ( ints(i) > 0 ) mymin=min(mymin, ints(i))
    end do
  end function MyMinval

  ! ---------------------------------------------  Announce_Error  -----
  subroutine Announce_Error ( lcf_where, full_message, use_toolkit, &
    & error_number )
    ! Arguments

    integer, intent(in)    :: lcf_where
    character(LEN=*), intent(in)    :: full_message
    logical, intent(in), optional :: use_toolkit
    integer, intent(in), optional    :: error_number
    ! Local
    !    character (len=80) :: msg, mnemonic
    !    integer :: status
    logical :: just_print_it
    logical, parameter :: default_output_by_toolkit = .true.

    if ( present(use_toolkit) ) then
      just_print_it = .not. use_toolkit
    else if ( default_output_by_toolkit ) then
      just_print_it = .false.
    else
      just_print_it = .true.
    end if

    if ( .not. just_print_it ) then
      error = max(error,1)
      call output ( '***** At ' )

      if ( lcf_where > 0 ) then
        call print_source ( where(lcf_where) )
      else
        call output ( '(no lcf node available)' )
      end if

      call output ( ': ' )
      call output ( "The " );
      if ( lcf_where > 0 ) then
        call dump_tree_node ( lcf_where, 0 )
      else
        call output ( '(no lcf tree available)' )
      end if

      call output ( " Caused the following error: ", advance='yes', &
        & from_where=ModuleName )
      call output ( trim(full_message), advance='yes', &
        & from_where=ModuleName )
      if ( present(error_number) ) then
        call output ( 'error number ', advance='no' )
        call output ( error_number, places=9, advance='yes' )
      end if
    else
      call output ( '***Error in module ' )
      call output ( ModuleName, advance='yes' )
      call output ( trim(full_message), advance='yes' )
      if ( present(error_number) ) then
        call output ( 'Error number ' )
        call output ( error_number, advance='yes' )
      end if
    end if
  end subroutine Announce_Error

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: L1BData.f90,v 2.127 2020/01/16 00:18:45 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------
end module L1BData

! $Log: L1BData.f90,v $
! Revision 2.127  2020/01/16 00:18:45  pwagner
! Can now convert l1boa ds names between file hdf versions
!
! Revision 2.126  2020/01/09 22:24:05  pwagner
! Extra steps so AssembleL1BQtyName wont munge sids-related DS names
!
! Revision 2.125  2019/05/13 20:55:49  pwagner
! Prints less unless debugging
!
! Revision 2.124  2018/08/03 23:23:08  vsnyder
! Announce which file is being checked in CheckForCorruptFileDatabase.
! Instead of ignoring errors in ReadL1BData_MF_... if NeverFail is present
! and true, reduce message level from MLSMSG_Error to MLSMSG_Warning.
!
! Revision 2.123  2018/04/19 23:41:09  pwagner
! Dont crash in ReadL1BData if NeverFail set
!
! Revision 2.122  2018/04/19 02:00:36  vsnyder
! Compute address for allocate/deallocate tracking.  Remove USE statements for
! unused names.
!
! Revision 2.121  2018/03/05 19:25:38  pwagner
! Reduce non-debug printing
!
! Revision 2.120  2017/11/03 19:59:37  pwagner
! Most array gymnastics moved from MLSFillValues to HyperSlabs module
!
! Revision 2.119  2017/10/18 22:46:52  pwagner
! Dont crash if a DS has more/fewer MAFs than counterMAF
!
! Revision 2.118  2017/02/09 23:46:46  pwagner
! Made more uses CamelCase
!
! Revision 2.117  2016/10/19 00:09:15  pwagner
! Added ConvertL1BData
!
! Revision 2.116  2016/10/11 23:27:18  pwagner
! Commented-out the crash_burn
!
! Revision 2.115  2016/10/05 20:13:58  pwagner
! Implemented Au (Gold) option
!
! Revision 2.114  2016/08/12 00:35:18  pwagner
! Seems to restore tthe gold brick
!
! Revision 2.113  2016/08/09 18:15:29  pwagner
! Made FindMaxMAF generic; survives encounter with non-satellite data files
!
! Revision 2.112  2016/07/28 19:23:10  pwagner
! Fixed error in GetAllHDF5GroupNames
!
! Revision 2.111  2016/07/28 01:42:27  vsnyder
! Refactoring dump and diff
!
! Revision 2.110  2016/07/22 20:03:52  pwagner
! Fixed errors in AssembleL1BQtyName, ReadL1BData_MLSFile
!
! Revision 2.109  2016/07/22 00:22:58  pwagner
! Improved pattern recognition
!
! Revision 2.108  2016/07/21 20:27:06  pwagner
! Can now handle ASMLS data better
!
! Revision 2.107  2016/04/20 00:05:15  pwagner
! cpL1BData now copies l1b datasets between files
!
! Revision 2.106  2016/03/23 00:19:31  pwagner
! DiffL1BData now able to print name on each line
!
! Revision 2.105  2015/07/31 20:40:34  pwagner
! Fixed error added with last commit
!
! Revision 2.104  2015/07/14 23:19:32  pwagner
! May debug case where gap in counterMAF causes Fill values in dp Field
!
! Revision 2.103  2015/03/28 01:07:53  vsnyder
! Changed the kind of dims to allow using ALlocate_Test.  Some spiffing.
! Added stuff to trace allocate/deallocate addresses -- mostly commented out
! because NAG build 1017 doesn't yet allow arrays as arguments to C_LOC.
!
! Revision 2.102  2014/09/04 23:46:21  vsnyder
! More complete and accurate allocate/deallocate size tracking.  Plug a
! memory leak using a final subroutine for L1BData_T.  Add some tracing.
! Convert some local pointers to allocatables.
!
! Revision 2.101  2014/07/23 21:57:59  pwagner
! Attempted to match names passed to allocate/deallocate
!
! Revision 2.100  2014/03/07 19:12:49  pwagner
! Name_Len changed to nameLen; got from MLSCommon
!
! Revision 2.99  2014/01/09 00:25:06  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.98  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.97  2013/08/31 01:24:53  vsnyder
! Replace MLSMessageCalls with trace_begin and trace_end
!
! Revision 2.96  2013/06/29 00:16:37  pwagner
! Added -SL1bread switch
!
! Revision 2.95  2013/05/31 00:40:31  vsnyder
! Make test for SC case insensitive
!
! Revision 2.94  2012/09/11 18:53:40  pwagner
! Anonymized diffed arrays
!
! Revision 2.93  2012/09/05 21:41:20  pwagner
! Removed calls to suspend, resumeOutput when Silent
!
! Revision 2.92  2012/06/07 23:57:17  pwagner
! Limit printing while reading attributes to DEEBUGging
!
! Revision 2.91  2011/07/15 23:31:06  pwagner
! Can now read 4d l1b data types; removed redundant code
!
! Revision 2.90  2011/07/07 00:30:03  pwagner
! Treats diffs of l1bdata types with periods
!
! Revision 2.89  2011/02/05 01:37:05  pwagner
! Passes options to dump routines
!
! Revision 2.88  2010/03/12 21:12:07  pwagner
! Note when diffing if integer arrays are equal
!
! Revision 2.87  2010/01/11 18:33:19  pwagner
! Changed a comment
!
! Revision 2.86  2009/10/30 23:03:50  pwagner
! Commented-out more debugging lines
!
! Revision 2.85  2009/08/24 18:34:45  pwagner
! Repaired syntax errors only NAG complained about
!
! Revision 2.84  2009/08/17 16:53:40  pwagner
! May contract L1BData along any of its dimensions
!
! Revision 2.83  2009/08/04 20:43:18  pwagner
! Replaced silent optional arg
!
! Revision 2.82  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.81  2009/06/16 17:15:55  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.80  2008/06/06 22:52:21  pwagner
! EssentiallyEqual moved to MLSFillValues
!
! Revision 2.79  2008/02/08 00:00:04  pwagner
! Coded around another Intel compiler bug
!
! Revision 2.78  2008/02/07 18:48:16  pwagner
! Prevent appearance of non-ascii when diffing char valued l1bdata
!
! Revision 2.77  2008/01/07 21:37:05  pwagner
! Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
!
! Revision 2.76  2007/08/13 17:36:13  pwagner
! Push some procedures onto new MLSCallStack
!
! Revision 2.75  2007/07/17 00:25:50  pwagner
! Deal more gracefully with attempt to read rank 0 datasets
!
! Revision 2.74  2007/06/21 00:49:51  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.73  2007/02/07 20:56:38  pwagner
! Avoid opening hdf5-type groups in hdf4 files
!
! Revision 2.72  2007/01/26 23:58:02  pwagner
! Fixed bug affecting GetL1BFile
!
! Revision 2.71  2006/11/22 18:12:37  pwagner
! New optional args to diff l1b files with different number MAFs
!
! Revision 2.70  2006/04/11 23:13:29  pwagner
! More room needed in dumping counterMAF array
!
! Revision 2.69  2006/02/06 22:54:51  pwagner
! Should print warnings, not bomb if l1b files not found
!
! Revision 2.68  2006/01/26 00:33:09  pwagner
! demoted more use statements from module level to speed Lahey compiles
!
! Revision 2.67  2006/01/04 20:31:18  pwagner
! Diff procedures may keep silent, returning num of diffs only
!
! Revision 2.66  2005/11/18 01:25:16  pwagner
! L1BData%charField no longer of unit length (hope this breaks nothing else)
!
! Revision 2.65  2005/11/17 20:10:44  pwagner
! Can now read 2d and 3d integer-valued l1bdata; charaacter still fails
!
! Revision 2.64  2005/10/22 00:50:30  pwagner
! Warns but continues if attributes sought in hdf4 file
!
! Revision 2.63  2005/10/19 20:47:29  pwagner
! Fixed bug in GetL1BFile (do others remain?)
!
! Revision 2.62  2005/10/18 23:05:11  pwagner
! Added GetL1BFile to get MLSFile with DS, attribute, or group name
!
! Revision 2.61  2005/09/21 23:12:28  pwagner
! Unnecessary changes
!
! Revision 2.60  2005/08/05 20:36:29  pwagner
! L1BFile arg to ReadL1BData now a pointer
!
! Revision 2.59  2005/07/21 23:36:28  pwagner
! Simplified L1bradSetup
!
! Revision 2.58  2005/06/22 17:25:49  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.57  2005/06/14 20:37:54  pwagner
! Many changes to accommodate the new fields in MLSFile_T
!
! Revision 2.56  2005/06/01 17:29:06  pwagner
! Disabled some superfluous printing
!
! Revision 2.55  2005/05/31 17:50:20  pwagner
! Began switch from passing file handles to passing MLSFiles
!
! Revision 2.54  2005/05/12 20:44:52  pwagner
! Uses dump0_m/diff to do diff
!
! Revision 2.53  2005/01/12 23:59:45  pwagner
! diff accepts options to print only stats, rms
!
! Revision 2.52  2004/12/21 22:05:14  pwagner
! Removed clunky temparray introduced to bypass memory issue
!
! Revision 2.51  2004/12/14 21:37:11  pwagner
! Some unnecessary debug printing and a temp array
!
! Revision 2.50  2004/08/26 22:34:41  pwagner
! No time to repair overly ambitious PadL1BData; quick patch instituted instead
!
! Revision 2.49  2004/08/19 00:10:43  pwagner
! L2AUX option to ReadL1BData stops warning msgs about counterMAF
!
! Revision 2.48  2004/08/17 23:47:48  pwagner
! Another guard against inappripriate padding
!
! Revision 2.47  2004/08/16 17:04:23  pwagner
! Pads L1bData after reading gappy data
!
! Revision 2.46  2004/08/04 23:19:01  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.45  2004/08/03 17:59:35  pwagner
! Gets DEFAULTUNDEFINEDVALUE from MLSCommon
!
! Revision 2.44  2004/03/12 00:36:33  pwagner
! Added diff subroutine; hdf version default increased to 5
!
! Revision 2.43  2003/09/12 16:37:10  cvuu
! add subroutine to read L1BOA attributes
!
! Revision 2.42  2003/05/07 01:05:57  vsnyder
! Remove three duplicated lines
!
! Revision 2.41  2003/05/05 23:00:04  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.40  2003/04/02 23:52:34  pwagner
! Checks for FILENOTFOUND
!
! Revision 2.39  2003/04/02 00:38:09  pwagner
! Cater for L1B quantities of rank > 3
!
! Revision 2.38  2003/03/10 17:27:10  pwagner
! Fixed same bug aslast; is it really fixed this time?
!
! Revision 2.37  2003/03/07 00:35:15  pwagner
! Fixed bad bug in reading hdf5 files with FirstMAF > 1
!
! Revision 2.36.2.1  2003/03/27 23:21:31  vsnyder
! Cater for L1B quantities of rank > 3, cosmetic changes
!
! Revision 2.36  2003/02/12 21:49:06  pwagner
! Some small fixes; seems to work with latest hdf5-formats
!
! Revision 2.35  2002/12/11 22:22:15  pwagner
! broadened error check on sd_id to any value lt 1
!
! Revision 2.34  2002/12/10 00:42:15  pwagner
! Stopped printing debugging stuff
!
! Revision 2.33  2002/12/06 01:10:08  pwagner
! No longer transposes hdf5-formatted 2d arrays
!
! Revision 2.32  2002/12/05 19:43:47  pwagner
! Unsuccessful at reading hdf5 so far; speeds up compiling tree-walker, however
!
! Revision 2.31  2002/12/04 01:15:11  pwagner
! Many changes; closer to be able to read hdf5 successfully
!
! Revision 2.30  2002/12/02 23:38:32  pwagner
! Should catch unknown data_type errors
!
! Revision 2.29  2002/11/22 21:48:54  pwagner
! Commented out USE of MLSAUXData
!
! Revision 2.28  2002/11/13 01:02:16  pwagner
! Actually reads hdf5 radiances
!
! Revision 2.27  2002/10/29 18:50:03  pwagner
! Modified AssembleL1BQtyName to convert complete hdf4-style names to hdf5
!
! Revision 2.26  2002/10/10 23:50:57  pwagner
! Passed 1st tests to read l1bdata from hdf5
!
! Revision 2.25  2002/10/09 00:05:02  pwagner
! Added trim function to fieldName
!
! Revision 2.24  2002/10/07 23:21:20  pwagner
! replaced undefined dim_sizes with dims
!
! Revision 2.23  2002/10/05 00:09:16  pwagner
! Finished hdf5 version of readl1bdata; untested however ..
!
! Revision 2.22  2002/10/03 23:04:11  pwagner
! hdfVersion now inout instead of intent(in)
!
! Revision 2.21  2002/09/27 23:37:54  pwagner
! More progress toward hdf5-capable l1b files
!
! Revision 2.20  2002/09/27 00:00:39  pwagner
! Began addings hdf5 functionality; incomplete
!
! Revision 2.19  2002/07/23 23:16:06  pwagner
! Added suggested cause of firstMAF error being bad chunk num
!
! Revision 2.18  2002/07/01 23:48:00  vsnyder
! Plug memory leaks, cosmetic changes
!
! Revision 2.17  2002/05/28 22:34:47  livesey
! Bug fix, wasn't properly allocating counterMAF in some circumstances.
!
! Revision 2.16  2002/01/09 23:42:23  pwagner
! Replaced discouraged print statements with favored calls to output
!
! Revision 2.15  2001/11/01 21:02:31  pwagner
! Willing to read l2aux files as if l1brad (untested); alphabetized procedures; added toc
!
! Revision 2.14  2001/10/26 23:11:10  pwagner
! Provides a single dump module interface
!
! Revision 2.13  2001/10/25 23:31:28  pwagner
! Fixed dump; readl1bData takes neverfail option
!
! Revision 2.12  2001/10/23 22:44:15  pwagner
! Added DumpL1BData
!
! Revision 2.11  2001/10/23 17:09:04  pwagner
! Added PRECISIONSUFFIX as parameter
!
! Revision 2.10  2001/10/03 22:50:03  vsnyder
! Add unfound-quantity name to an error message
!
! Revision 2.9  2001/06/01 02:06:45  livesey
! Bug fix with counterMAF
!
! Revision 2.8  2001/05/30 23:51:48  livesey
! New version, uses new HDF, also cleaner
!
! Revision 2.7  2001/05/06 20:53:47  pwagner
! Allocates l1binfo%filenames along with ids
!
! Revision 2.6  2001/05/04 22:51:06  pwagner
! Now sets L1B..FileName components in ..Setup
!
! Revision 2.5  2001/05/03 23:58:38  vsnyder
! Remove conflicts from merge
!
! Revision 2.4  2001/05/03 23:16:57  livesey
! Added use statement for lexer_core
!
! Revision 2.3  2001/05/03 22:32:25  pwagner
! Added L1B..Setup for Rad and OA
!
! Revision 2.2  2001/03/03 00:06:23  livesey
! Added FindL1BData
!
! Revision 2.1  2000/10/04 01:27:34  vsnyder
! Put ONLY clauses into the USE statements
!
! Revision 2.0  2000/09/05 17:41:06  dcuddy
! Change revision to 2.0
!
! Revision 1.11  2000/06/06 21:11:55  vsnyder
! Declare EXTERNAL attribute for HDF's sf* functions
!
@


2.127
log
@Can now convert l1boa ds names between file hdf versions
@
text
@d108 1
a108 1
! char*32 AssembleL1BQtyName (char name, int hdfVersion, log isTngtQty,
d341 52
a392 1
    & InstrumentName, dont_compress_name) &
d537 1
a537 1
  end function AssembleL1BQtyName
d3140 1
a3140 1
       "$Id: L1BData.f90,v 2.126 2020/01/09 22:24:05 pwagner Exp $"
d3149 3
@


2.126
log
@Extra steps so AssembleL1BQtyName wont munge sids-related DS names
@
text
@d38 1
d43 1
a43 1
  use MLSStrings, only: Indexes, Streq
d78 4
a81 3
! contractL1BData                 Contract an l1bData to just a range of mafs
! convertL1BData                  Convert an l1bData from integer-valued to d.p.
! cpL1BData                       Duplicate an l1bData
d83 1
a83 1
! dupL1BData                      Duplicate an l1bData
d86 2
a87 2
! findl1bdata                     Which file handle contains a given sd name
! findMaxMAF                      What is the maximum MAF number in the file?
d90 2
d114 1
d117 1
a117 1
! dupL1BData ( l1bData_T l1bData1, l1bData_T l1bData2, int offsetMAF )
d125 2
d138 7
a144 6
  public :: L1BData_T, nameLen, precisionSuffix, &
    & allocateL1BData, AssembleL1BQtyName, &
    & CheckForCorruptFileDatabase, ContractL1BData, ConvertL1BData, CpL1BData, &
    & DeallocateL1BData, diff, dump, dupL1BData, &
    & findL1BData, FindMaxMAF, GetL1BFile, &
    & L1BRadSetup, L1BOASetup, PadL1BData, &
d153 1
a153 1
  interface DIFF
d157 1
a157 1
  interface DUMP
d243 3
d252 4
a255 1
    ! Allocate arrays in l1bData type
d350 3
d605 31
d681 2
a682 2
  ! --------------------------------------------------  dupL1BData  -----
  subroutine dupL1BData ( l1bData1, l1bData2, offsetMAF )
d703 1
a703 1
  end subroutine dupL1BData
d1471 26
d3089 1
a3089 1
       "$Id: L1BData.f90,v 2.125 2019/05/13 20:55:49 pwagner Exp $"
d3098 3
@


2.125
log
@Prints less unless debugging
@
text
@d329 1
a329 1
    use MLSStrings, only: CompressString
d407 1
a407 1
      else if ( DROPTPSUBGROUP ) then
d422 1
a422 1
    if ( isTngtQty ) then
d431 3
d435 2
d3015 1
a3015 1
       "$Id: L1BData.f90,v 2.124 2018/08/03 23:23:08 vsnyder Exp $"
d3024 3
@


2.124
log
@Announce which file is being checked in CheckForCorruptFileDatabase.
Instead of ignoring errors in ReadL1BData_MF_... if NeverFail is present
and true, reduce message level from MLSMSG_Error to MLSMSG_Warning.
@
text
@d1288 1
a1288 1
    logical :: haveCtrMAF
d1299 2
a1300 2
      haveCtrMAF = sfn2index(L1BFile%FileID%f_id,trim(fieldName)) /= -1
      if ( haveCtrMAF ) then
d1305 1
a1305 1
      haveCtrMAF = IsHDF5DSPresent( L1BFile, trim(fieldName) )
d1307 3
a1309 3
      call outputNamedValue( 'haveCtrMAF', haveCtrMAF )
      call outputNamedValue( 'haveMAFStartTimeTAI', haveMAFStartTimeTAI )
      if ( haveCtrMAF ) then
d1317 1
a1317 1
    if ( haveCtrMAF ) then
d3010 1
a3010 1
       "$Id: L1BData.f90,v 2.123 2018/04/19 23:41:09 pwagner Exp $"
d3019 5
@


2.123
log
@Dont crash in ReadL1BData if NeverFail set
@
text
@a474 1
    call output( 'Checking for corrupt file database', advance='yes' )
d476 13
a488 7
    call GetAllHDF5DSNames ( L1BFile, DSNames )
    call Dump ( DSNames, 'DSNames from MLSFile type' )
    call newLine
    !call GetAllHDF5DSNames ( L1BFile%name, '/', DSNames )
    !call Dump ( DSNames, 'DSNames from MLSFile name' )
    !call newLine
    ! call crash_burn
d1796 1
a1796 1
    & FirstMAF, LastMAF, NEVERFAIL, hdfVersion, dontPad, L2AUX )
d1836 1
a1836 1
      & FirstMAF, LastMAF, NEVERFAIL, dontPad, L2AUX )
d1843 1
a1843 1
    & FirstMAF, LastMAF, NEVERFAIL, dontPad, L2AUX )
d1907 1
a1907 1
      & NoMAFs, Flag, FirstMAF, LastMAF, NEVERFAIL, L2AUX )
d1911 1
a1911 1
      & NoMAFs, Flag, FirstMAF, LastMAF, NEVERFAIL, L2AUX )
d1927 1
a1927 1
        if ( .not. Default( NEVERFAIL, .false. ) ) call crash_burn
d1987 1
a1987 1
    & NoMAFs, Flag, FirstMAF, LastMAF, NEVERFAIL, L2AUX )
d2016 1
d2041 1
d2049 1
a2049 2
        if ( MyNeverFail ) go to 9
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d2051 1
a2051 2
      else
        sds1_id = SD_NO_COUNTERMAF
d2053 1
d2059 1
a2059 2
        if ( MyNeverFail ) go to 9
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d2061 1
a2061 1
        return
a2067 1
      if ( MyNeverFail ) go to 9
d2070 2
a2071 2
      call MLSMessage ( MLSMSG_Error, ModuleName, dummy, MLSFile=L1BFile )
      return
d2077 1
a2077 2
      if ( MyNeverFail ) go to 9
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d2079 1
a2079 1
      return
d2088 1
a2088 2
      if ( MyNeverFail ) go to 9
      call MLSMessage ( MLSMSG_Error, ModuleName,&
d2090 1
a2090 1
      return
d2118 1
a2118 2
        if ( MyNeverFail ) go to 9
        call MLSMEssage ( MLSMSG_Error, ModuleName, &
d2120 1
d2130 1
a2130 2
        if ( MyNeverFail ) go to 9
        call MLSMEssage ( MLSMSG_Error, ModuleName, &
d2132 1
d2155 1
a2155 2
        if ( MyNeverFail ) go to 9
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d2157 1
a2157 1
        return
a2175 1
        if ( MyNeverFail ) go to 9
d2178 1
d2232 1
a2232 2
      if ( MyNeverFail ) go to 9
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d2234 1
a2234 1
      return
d2237 1
a2237 2
      if ( MyNeverFail ) go to 9
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d2239 1
a2239 1
      return
a2247 1
        if ( MyNeverFail ) go to 9
d2251 1
a2257 1
      if ( MyNeverFail ) go to 9
d2272 1
a2272 1
    & Flag, FirstMAF, LastMAF, NEVERFAIL, L2AUX )
d2301 1
d2337 1
a2343 1
      if ( MyNeverFail ) go to 9
d2346 2
a2347 2
      call MLSMessage ( MLSMSG_Error, ModuleName, dummy, MLSFile=L1BFile )
      return
d2382 1
a2382 1
        call MLSMEssage ( MLSMSG_Error, ModuleName, &
d2384 1
a2393 1
        if ( MyNeverFail ) go to 9
d2395 1
a2395 1
        call MLSMEssage ( MLSMSG_Error, ModuleName, &
d2397 1
d2422 1
a2422 2
        if ( MyNeverFail ) go to 9
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d2424 1
d2684 1
a2684 2
      if ( MyNeverFail ) go to 9
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d2687 1
d3010 1
a3010 1
       "$Id: L1BData.f90,v 2.122 2018/04/19 02:00:36 vsnyder Exp $"
d3019 3
@


2.122
log
@Compute address for allocate/deallocate tracking.  Remove USE statements for
unused names.
@
text
@d1841 1
d1922 1
a1922 1
        call crash_burn
d3010 1
a3010 1
       "$Id: L1BData.f90,v 2.121 2018/03/05 19:25:38 pwagner Exp $"
d3019 4
@


2.121
log
@Reduce non-debug printing
@
text
@d2180 2
a2181 2
!       if ( size(l1bData%charField) > 0 ) &
!         & addr = transfer(c_loc(l1bData%charField(1,1,1)), addr)
d3009 1
a3009 1
       "$Id: L1BData.f90,v 2.120 2017/11/03 19:59:37 pwagner Exp $"
d3018 3
@


2.120
log
@Most array gymnastics moved from MLSFillValues to HyperSlabs module
@
text
@d1540 1
a1540 1
          call output ('get attribute', advance='no')
d1595 4
a1598 2
        call output ('get attribute', advance='no')
        call output (AttrName, advance='yes')
d3009 1
a3009 1
       "$Id: L1BData.f90,v 2.119 2017/10/18 22:46:52 pwagner Exp $"
d3018 3
@


2.119
log
@Dont crash if a DS has more/fewer MAFs than counterMAF
@
text
@d18 1
a662 1
  use MLSFillValues, only: EssentiallyEqual
d3007 1
a3007 1
       "$Id: L1BData.f90,v 2.118 2017/02/09 23:46:46 pwagner Exp $"
d3016 3
@


2.118
log
@Made more uses CamelCase
@
text
@d16 2
a17 1
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Test_Allocate
d37 1
a37 1
  use MLSHDF5, only: GetAllHDF5DSNames, SaveAsHDF5DS
d46 1
d328 1
a328 1
    use MLSStrings, only: CompressString, Streq
a579 2
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
a1789 2
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
a1839 2
    use Toggles, only: Gen, Levels, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
d1855 1
a1855 1
    character(len=1024) :: DSNames
d1914 2
a1918 2
        call GetAllHDF5DSNames( L1BFile%name, '/', DSNames )
        call Dump ( DSNames, 'DSNames' )
a1979 2
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
a2271 1
    use Allocate_Deallocate, only: Test_Allocate
a2275 2
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
d2443 1
d2453 7
a2459 2
          deallocate(dims, maxDims, cmdims, cmmaxdims)
          go to 9
d2461 15
a2475 13
        call output('Quantity name: ', advance = 'no')
        call output(Quantityname, advance = 'yes')
        call output('Quantity rank: ', advance = 'no')
        call output(rank, advance = 'yes')
        call output('Quantity dims: ', advance = 'no')
        call output(int(dims), advance = 'yes')
        call output('Quantity noMAFs: ', advance = 'no')
        call output(l1bData%noMAFs, advance = 'yes')
        call output('counterMAF dims: ', advance = 'no')
        call output(int(cmdims), advance = 'yes')
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Sorry--ReadL1BData_hdf5 says counterMaf sized differently from ' &
          & // trim(QuantityName), MLSFile=L1BFile )
d2678 1
a2678 1
      l1bdata%data_type = 'unknown'
a2707 1
    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
d3007 1
a3007 1
       "$Id: L1BData.f90,v 2.117 2016/10/19 00:09:15 pwagner Exp $"
d3016 3
@


2.117
log
@Added ConvertL1BData
@
text
@d16 2
a17 2
  use Allocate_Deallocate, only: Allocate_test, Deallocate_test, Test_Allocate
  use Diff_1, only: Diff, Diff_fun
d22 1
a22 1
    & SFRData_f90, &
d27 8
a34 8
  use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
  use Intrinsic, only: l_HDF
  use Lexer_core, only: print_source
  use machine, only: crash_burn
  use MLSCommon, only: MLSFile_t, &
    & UnDefinedValue, fileNameLen, nameLen
  use MLSFiles, only: fileNotFound, HDFVersion_4, HDFVersion_5, &
    & AddFileToDatabase, getMLSFileByType, initializeMLSfile, &
d37 1
a37 1
  use MLSKinds, only: r4, r8
d40 7
a46 7
  use MLSStrings, only: indexes, streq
  use MLSStringLists, only: numStringElements, ReplaceSubstring, switchDetail
  use Moretree, only: get_field_id
  use Output_m, only: newLine, output
  use String_table, only: get_string
  use Trace_m, only: trace_begin, trace_end
  use Tree, only: nsons, sub_rosa, subtree, dump_tree_node, where
d326 1
a326 1
    use MLSStrings, only: compressString, streq
d578 2
a579 2
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
d662 2
a663 2
  use MLSFillValues, only: essentiallyEqual
  use MLSStrings, only: asciify, isAllAscii
d1045 2
a1046 2
    use MLSHDF5, only: isHDF5ItemPresent
    use MLSFiles, only: dump
d1182 1
a1182 1
  use MLSHDF5, only: isHDF5DSPresent
d1267 1
a1267 1
  use MLSHDF5, only: isHDF5DSPresent
d1341 1
a1341 1
  use PCFHdr, only: globalAttributes
d1376 1
a1376 1
  use PCFHdr, only: globalAttributes
d1502 1
a1502 1
    use MLSHDF5, only: isHDF5AttributePresent, getHDF5Attribute
d1558 1
a1558 1
    use MLSHDF5, only: isHDF5AttributePresent, getHDF5Attribute
d1790 2
a1791 2
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
d1840 4
a1843 4
    use MLSFillValues, only: isFillValue
    use PCFHdr, only: globalAttributes
    use toggles, only: gen, levels, switches, toggle
    use trace_m, only: trace_begin, trace_end
d1984 2
a1985 2
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
d2279 6
a2284 6
    use MLSFillValues, only: isFillValue
    use HDF5, only: HSize_t
    use MLSHDF5, only: isHDF5DSPresent, loadFromHDF5DS, &
      & getHDF5DSRank, getHDF5DSDims, getHDF5DSQType
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
d3009 1
a3009 1
       "$Id: L1BData.f90,v 2.116 2016/10/11 23:27:18 pwagner Exp $"
d3018 3
@


2.116
log
@Commented-out the crash_burn
@
text
@d74 2
d103 4
d130 1
a130 1
    & CheckForCorruptFileDatabase, ContractL1BData, CpL1BData, &
d477 3
a479 3
    call GetAllHDF5DSNames ( L1BFile%name, '/', DSNames )
    call Dump ( DSNames, 'DSNames from MLSFile name' )
    call newLine
d559 16
d3009 1
a3009 1
       "$Id: L1BData.f90,v 2.115 2016/10/05 20:13:58 pwagner Exp $"
d3018 3
@


2.115
log
@Implemented Au (Gold) option
@
text
@d474 1
a474 1
    call crash_burn
d2987 1
a2987 1
       "$Id: L1BData.f90,v 2.114 2016/08/12 00:35:18 pwagner Exp $"
d2996 3
@


2.114
log
@Seems to restore tthe gold brick
@
text
@d679 1
a679 1
      hideAssocStatus = any(indexes(options, (/'s','r'/)) > 0 )
d2987 1
a2987 1
       "$Id: L1BData.f90,v 2.113 2016/08/09 18:15:29 pwagner Exp $"
d2996 3
@


2.113
log
@Made FindMaxMAF generic; survives encounter with non-satellite data files
@
text
@d41 1
a41 1
  use MLSStringLists, only: numStringElements, switchDetail
d410 1
d422 1
d426 29
d1844 1
d1853 1
d2987 1
a2987 1
       "$Id: L1BData.f90,v 2.112 2016/07/28 19:23:10 pwagner Exp $"
d2996 3
@


2.112
log
@Fixed error in GetAllHDF5GroupNames
@
text
@d17 1
a17 1
  use Diff_1, only: diff, diff_fun
d20 1
d28 3
a30 2
  use intrinsic, only: l_HDF
  use lexer_core, only: print_source
d32 5
a36 5
    & unDefinedValue, fileNameLen, nameLen
  use MLSFiles, only: filenotfound, HDFversion_4, HDFversion_5, &
    & addFileToDatabase, initializeMLSfile, &
    & MLS_openFile, MLS_closeFile
  use MLSHDF5, only: SaveAsHDF5DS
d42 5
a46 5
  use moretree, only: get_field_id
  use output_m, only: output
  use string_table, only: get_string
  use trace_m, only: trace_begin, trace_end
  use tree, only: nsons, sub_rosa, subtree, dump_tree_node, where
d80 1
d109 1
d123 2
a124 1
    & allocateL1BData, AssembleL1BQtyName, ContractL1BData, CpL1BData, &
d144 4
d426 20
d1177 2
a1178 2
  ! -------------------------------------------------  FindMaxMAF  -----
  integer function FindMaxMAF ( files, minMAF )
d1181 2
a1182 7
  use MLSHDF5, only: isHDF5DSPresent

    type(MLSFile_T), dimension(:), intent(in), target :: files ! File handles
    integer, optional, intent(out) :: minMAF

    ! Externals
    integer, external :: SFN2INDEX
a1184 1
    logical :: alreadyOpen
a1185 3
    integer :: myhdfVersion
    character(len=*), parameter :: fieldname = 'counterMAF'
    type(L1BData_T) :: l1bData
a1186 1
    integer :: noMAFs
d1188 1
a1188 1
    integer :: status
d1193 1
a1193 1
    FindMaxMAF=0
d1198 1
a1198 1
      if ( streq(files(i)%content, 'l1b*', '-w') ) then
d1200 2
a1201 31
        alreadyOpen = files(i)%StillOpen
        if ( .not. alreadyOpen ) &
          & call mls_openFile(files(i), status)
        myHDFVersion = files(i)%HDFVersion
        if ( myhdfVersion == HDFVERSION_4 ) then
          haveCtrMAF = sfn2index(files(i)%FileID%f_id,trim(fieldName)) /= -1
          if ( haveCtrMAF ) then
            call ReadL1BData ( L1BFile, fieldName, L1bData, noMAFs, status, &
              & dontPad=.true.)
          end if
        else
          haveCtrMAF = IsHDF5DSPresent(files(i)%FileID%f_id, trim(fieldName))
          if ( haveCtrMAF ) then
            call ReadL1BData ( L1BFile, fieldName, L1bData, noMAFs, status, &
              & dontPad=.true.)
          end if
        end if
        if ( haveCtrMAF ) then
          FindMaxMAF = max(FindMaxMAF, maxval(l1bData%counterMAF))
          myMinMAF = min(myMinMAF, myminval(l1bData%counterMAF))
          if ( DEEBug ) print *, 'counterMAF ', l1bData%counterMAF
          ! call output('Shape L1b counterMAF ')
          ! call output(shape(l1bData%intField), advance='yes')
          call deallocatel1bdata(L1bData)
        else
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Failed to find '//trim(fieldName)// &
          & ' in l1b files while FindMaxMAF', MLSFile=files(i))
        end if
        if ( .not. alreadyOpen ) &
          & call mls_closeFile(files(i), status)
d1204 1
a1204 1
    if ( DEEBug ) print *, 'FindMaxMAF ', FindMaxMAF
d1207 77
a1283 1
  end function FindMaxMAF
d1786 1
a1786 1

d1806 1
d1819 1
a1819 1
        return
d1824 8
a1831 3
    if ( .not. alreadyOpen ) then
      ! print *, 'Oops--need to open l1b file before reading'
      call mls_openFile(L1BFile, returnStatus)
d1862 7
a1868 2
        & 'Failed to find '//trim(QuantityName)//' in l1b files')
        if ( .not. alreadyOpen )  call mls_closeFile(L1BFile, returnStatus)
a2245 2

    integer(c_intptr_t) :: Addr         ! For tracing
a2246 1

d2249 1
d2274 7
d2294 1
a2294 1
      ! print *, 'Oops--' // trim(QuantityName) // ' not here'
d2383 5
d2954 1
a2954 1
       "$Id: L1BData.f90,v 2.111 2016/07/28 01:42:27 vsnyder Exp $"
d2963 3
@


2.111
log
@Refactoring dump and diff
@
text
@a369 4
      ! 1st--is there an instrument prefixed to name?
      if ( name(1:2) == 'sc' ) then
        my_instrument = 'sc'
        the_rest = name(3:)
d371 1
a371 1
      elseif ( streq(name, '*.tp*', options='-wc' ) ) then
d375 4
d2867 1
a2867 1
       "$Id: L1BData.f90,v 2.110 2016/07/22 20:03:52 pwagner Exp $"
d2876 3
@


2.110
log
@Fixed errors in AssembleL1BQtyName, ReadL1BData_MLSFile
@
text
@d17 3
a19 1
  use Dump_0, only: nameOnEachLine, statsOnOneLine, Diff, Diff_fun, Dump
d2867 1
a2867 1
       "$Id: L1BData.f90,v 2.109 2016/07/22 00:22:58 pwagner Exp $"
d2876 3
@


2.109
log
@Improved pattern recognition
@
text
@d328 1
a328 1
    logical, parameter     :: DEEBUG = .true.
d1746 2
a1747 2
    if ( .not. associated(L1BFile) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1751 1
d2865 1
a2865 1
       "$Id: L1BData.f90,v 2.108 2016/07/21 20:27:06 pwagner Exp $"
d2874 3
@


2.108
log
@Can now handle ASMLS data better
@
text
@d328 1
a328 1
    logical, parameter     :: DEEBUG = .false.
d333 1
d372 5
a376 20
      else if ( name(1:4) == 'GHz.' ) then
        my_instrument = 'GHz'
        the_rest = name(5:)
      else if ( name(1:4) == 'THz.' ) then
        my_instrument = 'THz'
        the_rest = name(5:)
      ! ASMLS? 
      ! Shouldn't we cook up something more flexible? Less of a crude hack?
      elseif ( streq(name, 'ASMLS*', options='-wc' ) ) then
        my_instrument = 'ASMLS'
        the_rest = name(6:)
      elseif ( streq(name, 'ER2*', options='-wc' ) ) then
        my_instrument = 'ER2'
        the_rest = name(4:)
      else if ( streq(name, 'Spectrometer1*', options='-wc' ) ) then
        my_instrument = 'Spectrometer1'
        the_rest = name(15:)
      else if ( streq(name, 'Spectrometer2*', options='-wc' ) ) then
        my_instrument = 'Spectrometer2'
        the_rest = name(15:)
d2864 1
a2864 1
       "$Id: L1BData.f90,v 2.107 2016/04/20 00:05:15 pwagner Exp $"
d2873 3
@


2.107
log
@cpL1BData now copies l1b datasets between files
@
text
@d309 1
a309 1
    use MLSStrings, only: compressString
d321 1
a321 2
    character(len=namelen)      :: QtyName
    logical, parameter           :: DEEBUG = .FALSE.
d328 5
a332 4
    character(len=1) :: head
    character(len=1) :: instr_tail
    character(len=1) :: tp_tail
    character(len=4) :: my_instrument
d334 2
a335 2
    logical          :: is_a_signal
    logical          :: compress
d356 3
d377 14
a1759 2
    call trace_begin ( me, "ReadL1BData_MLSFile", &
      & cond=toggle(gen) .and. levels(gen) > 1 )
d1764 3
d1938 1
d1949 1
d1958 1
d1970 1
d2038 1
d2116 1
d2122 1
d2228 1
d2878 1
a2878 1
       "$Id: L1BData.f90,v 2.106 2016/03/23 00:19:31 pwagner Exp $"
d2887 3
@


2.106
log
@DiffL1BData now able to print name on each line
@
text
@d27 1
a27 1
  use MLSCommon, only: MLSfile_t, &
d32 1
d34 2
a35 2
  use MLSMessagemodule, only: MLSmsg_error, &
    & MLSMsg_l1bread, MLSmsg_warning, MLSmessage
d44 1
a44 1
  implicit NONE
d70 1
d72 1
d96 3
d116 4
a119 4
  public :: L1BData_T, namelen, PRECISIONSUFFIX, &
    & allocateL1BData, AssembleL1BQtyName, ContractL1BData, cpL1bData, &
    & DeallocateL1BData, DIFF, DUMP, GetL1BFile, &
    & FINDL1BDATA, FindMaxMAF, &
d309 1
a309 1
    use MLSStrings, only: COMPRESSSTRING
d488 49
a536 2
  ! --------------------------------------------------  cpL1BData  -----
  subroutine cpL1BData ( l1bData1, l1bData2, offsetMAF )
d557 1
a557 1
  end subroutine cpL1BData
d575 2
a576 2
  use MLSFillValues, only: ESSENTIALLYEQUAL
  use MLSStrings, only: ASCIIFY, ISALLASCII
d958 3
a960 3
    use MLSHDF5, only: ISHDF5ITEMPRESENT
    use MLSFILES, only: DUMP
    use HDF5, only: H5DOPEN_F, H5GCLOSE_F, H5GOPEN_F
d1095 1
a1095 1
  use MLSHDF5, only: ISHDF5DSPRESENT
d1147 1
a1147 1
  use MLSHDF5, only: ISHDF5DSPRESENT
d1217 1
a1217 1
  use PCFHdr, only: GLOBALATTRIBUTES
d1252 1
a1252 1
  use PCFHdr, only: GLOBALATTRIBUTES
d1378 2
a1379 2
    use MLSHDF5, only: ISHDF5ATTRIBUTEPRESENT, GETHDF5ATTRIBUTE
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F
d1434 2
a1435 2
    use MLSHDF5, only: ISHDF5ATTRIBUTEPRESENT, GETHDF5ATTRIBUTE
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F
d1666 2
a1667 2
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d1717 3
a1719 3
    use PCFHdr, only: GLOBALATTRIBUTES
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d1723 2
a1729 2
    integer, intent(out) :: FLAG        ! Error flag
    integer, intent(out) :: NOMAFS      ! Number actually read
d1734 1
a1734 1
    logical, parameter :: DEEBug = .false.
d1742 1
d1804 1
a1804 1
    call cpL1bData(l1bdata, l1bdataTmp)
d1831 1
a1831 1
    call cpL1bData(l1bdata, l1bdataTmp)
d1845 2
a1846 2
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d2134 1
a2134 1
    use HDF5, only: hsize_t
d2852 1
a2852 1
       "$Id: L1BData.f90,v 2.105 2015/07/31 20:40:34 pwagner Exp $"
d2861 3
@


2.105
log
@Fixed error added with last commit
@
text
@d17 1
a17 1
  use Dump_0, only: Diff, Diff_fun, Dump
d587 1
d670 2
a671 2
      if ( any(l1bData1%counterMAF /= l1bData2%counterMAF)) then
        call dump ( l1bData1%counterMAF - l1bData2%counterMAF, &
d685 1
d723 1
d814 1
d2219 1
a2219 1
      if ( DEEBUG) print *, 'no counterMAF array in file'
d2798 1
a2798 1
       "$Id: L1BData.f90,v 2.104 2015/07/14 23:19:32 pwagner Exp $"
d2807 3
@


2.104
log
@May debug case where gap in counterMAF causes Fill values in dp Field
@
text
@d27 3
a29 3
  use MLScommon, only: MLSfile_t, &
    & undefinedValue, fileNameLen, nameLen
  use MLSfiles, only: filenotfound, HDFversion_4, HDFversion_5, &
d32 5
a36 5
  use MLSkinds, only: r4, r8
  use MLSmessagemodule, only: MLSmsg_error, &
    & MLSmsg_l1bread, MLSmsg_warning, MLSmessage
  use MLSstrings, only: indexes, streq
  use MLSstringLists, only: numStringElements, switchDetail
d2076 5
a2080 6
    use HDF5, only: HSIZE_T
    use MLSHDF5, only: ISHDF5DSPRESENT, LOADFROMHDF5DS, &
      & GETHDF5DSRANK, GETHDF5DSDIMS, GETHDF5DSQTYPE
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
! use MLSAuxData, only: MLSAuxData_T, Read_MLSAuxData, Deallocate_MLSAuxData
d2151 4
a2154 1
    allocate ( dims(rank), Hdims(rank), maxDims(rank) )
d2334 1
a2334 1
        call output( '3d real l1bdata ' // trim(QuantityName) // 'are clean', advance='yes' )
d2794 1
a2794 1
       "$Id: L1BData.f90,v 2.103 2015/03/28 01:07:53 vsnyder Exp $"
d2803 3
@


2.103
log
@Changed the kind of dims to allow using ALlocate_Test.  Some spiffing.
Added stuff to trace allocate/deallocate addresses -- mostly commented out
because NAG build 1017 doesn't yet allow arrays as arguments to C_LOC.
@
text
@d1192 40
d1659 1
d1732 6
d1765 5
d2075 1
d2317 8
d2332 1
a2332 1
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField)
d2334 8
d2493 1
d2511 2
d2562 1
d2573 9
d2792 1
a2792 1
       "$Id: L1BData.f90,v 2.102 2014/09/04 23:46:21 vsnyder Exp $"
d2801 5
@


2.102
log
@More complete and accurate allocate/deallocate size tracking.  Plug a
memory leak using a final subroutine for L1BData_T.  Add some tracing.
Convert some local pointers to allocatables.
@
text
@d17 8
a24 7
  use Dump_0, only: diff, diff_fun, dump
  use HDF, only: dfacc_rdonly, sfginfo, sfn2index, sfselect, &
    & sfrdata_f90, &
    & sfrcdata, sfendacc, dfnt_char8, dfnt_int32, dfnt_float64, &
    & dfnt_float32
  use highoutput, only: outputnamedvalue
  use ieee_arithmetic, only: ieee_is_finite
d78 1
a78 1
! ReadL1BAttribute                Read attributes 
d84 1
a84 1
!             *int CounterMAF(:), 
d88 1
a88 1
!             ) 
d92 2
a93 2
!                         [char InstrumentName] ) 
! DeallocateL1BData (l1bData_T l1bData) 
d97 2
a98 2
! int FindL1BData (int files(:), char fieldName, [int hdfVersion]) 
! MLSFile_T GetL1BFile (MLSFile_t filedatabase(:), char fieldName, [char options]) 
d103 3
a105 3
!               [log NeverFail], [int hdfVersion]) 
! ReadL1BAttribute (int L1FileHandle, value(:), nchar AttributeName, 
!               int Flag, [int hdfVersion]) 
d120 1
a120 1
  private :: not_used_here 
d151 1
a151 1
  ! 4 corresponds to hdf4, 5 to hdf5 in L2GP, L2AUX, etc. 
d176 1
a176 1
    character (len=16) :: NameInst = ' '     
d188 1
a188 1
  
d191 1
a191 1
  
d293 3
a295 3
    l1bData%MaxMIFs                = l1bDataSibling%MaxMIFs         
    l1bData%NoAuxInds              = l1bDataSibling%NoAuxInds       
    l1bData%TrueRank               = l1bDataSibling%TrueRank        
d401 3
a403 3
    if ( DEEBUG ) then                            
      print *, 'more converted name: ', trim(QtyName)  
    end if                                         
d411 1
a411 1
    ! Remember 1st maf of full l1bData is numbered 0 
d413 1
a413 1
    
d578 1
a578 1
    
d593 1
a593 1
    
d689 1
a689 1
        !  l1bData1%CharField = asciify( l1bData1%CharField, 'snip') 
d695 1
a695 1
              l1bData1%CharField(i,j,k) = asciify( l1bData1%CharField(i,j,k), 'snip') 
d700 1
a700 1
        !  l1bData2%CharField = asciify( l1bData2%CharField, 'snip') 
d706 1
a706 1
              l1bData2%CharField(i,j,k) = asciify( l1bData2%CharField(i,j,k), 'snip') 
d731 1
a731 1
    
d831 1
a831 1
    
d883 1
a883 1
  !                                  
d896 1
a896 1
  
d971 1
a971 1
        
d1280 1
a1280 1
    
d1306 1
a1306 1
    else 
d1312 1
a1312 1
      end if  
d1328 1
a1328 1
      end if 
d1336 1
a1336 1
    
d1362 1
a1362 1
    else 
d1368 1
a1368 1
      end if  
d1373 1
a1373 1
      else 
d1382 1
a1382 1
      end if 
d1394 2
a1395 2
    ! If optionally supplied PrecisionIn it will return padded PrecisionOut  
    ! where the padded values will all be cleverly set negative 
d1449 2
a1450 2
    ! If optionally supplied PrecisionIn it will return padded PrecisionOut  
    ! where the padded values will all be cleverly set negative 
d1463 1
a1463 1
    logical, optional, intent(in) :: force   ! Relax assumption 
d1465 9
a1473 9
    logical :: myForce
    integer, dimension(3) :: dims
    integer :: gap
    integer :: i
    integer :: indexOut
    integer :: cmindex
    integer :: current
    integer :: maf
    integer :: rank
d1601 1
a1601 1
    
d1618 1
a1618 1
    
d1758 1
d1929 3
d1934 1
a1934 1
        & elementSize = storage_size(l1bData%charField) / 8 )
d1971 1
a1971 1
      
d1991 1
a1991 1
    
d2029 1
a2029 1
    
d2046 1
d2062 2
a2063 1
    integer(kind=hSize_t), dimension(:), allocatable :: DIMS
d2094 1
a2094 1
    
d2099 3
a2101 2
    allocate ( dims(rank), maxDims(rank) )
    call GetHDF5DSDims(L1FileHandle, QuantityName, dims, maxDims)
d2209 1
a2209 1
        ! This intermediate cm_array shouldn't be necessary 
d2245 3
a2247 5
      allocate( l1bData%DpField(l1bData%noMAFs, 1, 1),stat=status)
      call test_allocate ( status, moduleName, "l1bData%DpField", &
        & uBounds = [l1bData%noMAFs, 1, 1], &
        & elementSize = storage_size(l1bData%DpField) / 8 )
      if ( present(FirstMAF) ) then                                          
d2249 4
a2252 4
          & (/MAFoffset/), (/l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,1,1))  
      end if                                                                  
d2255 3
a2257 5
      allocate( l1bData%DpField(dims(1),l1bData%noMAFs, 1),stat=status)
      call test_allocate ( status, moduleName, "l1bData%DpField", &
        & uBounds = [l1bData%noMAFs, l1bData%noMAFs, 1], &
        & elementSize = storage_size(l1bData%DpField) / 8 )
      if ( present(FirstMAF) ) then                                          
d2259 4
a2262 4
          & (/0,MAFoffset/), (/int(dims(1)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,:,1))  
      end if                                                                  
d2265 3
a2267 5
      allocate( l1bData%DpField(dims(1),dims(2),l1bData%noMAFs),stat=status)
      call test_allocate ( status, moduleName, "l1bData%DpField", &
        & uBounds = [int(dims(1:2)),l1bData%noMAFs], &
        & elementSize = storage_size(l1bData%DpField) / 8 )
      if ( present(FirstMAF) ) then                                          
d2269 4
a2272 4
          & (/0,0,MAFoffset/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField)  
      end if                                                                  
d2274 4
a2277 9
    case ('real4')    
      allocate( &
        & l1bData%DpField(dims(1)*dims(2),dims(3),l1bData%noMAFs),stat=status &
        & )
      call test_allocate ( status, moduleName, "l1bData%DpField", &
        & uBounds = [int(dims(1)*dims(2)),int(dims(3)),l1bData%noMAFs], &
        & elementSize = storage_size(l1bData%DpField) / 8 )
      call allocate_test( DP4Buf, &
        & int(dims(1)), int(dims(2)), int(dims(3)), int(dims(4)), &
d2279 1
a2279 1
      if ( present(FirstMAF) ) then                                          
d2282 3
a2284 3
          & (/int(dims(1)),int(dims(2)),int(dims(3)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS( L1FileHandle, QuantityName, DP4Buf)   
d2287 2
a2288 3
        & (/ int(dims(1)*dims(2)), int(dims(3)), l1bData%noMAFs /) )
      call deallocate_test( DP4Buf, &
        & 'DP4Buf', ModuleName )
d2291 3
a2293 5
      allocate( l1bData%DpField(l1bData%noMAFs, 1, 1),stat=status)
      call test_allocate ( status, moduleName, "l1bData%DpField", &
        & uBounds = [l1bData%noMAFs, 1, 1], &
        & elementSize = storage_size(l1bData%DpField) / 8 )
      if ( present(FirstMAF) ) then                                          
d2295 4
a2298 4
          & (/MAFoffset/), (/l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,1,1))  
      end if                                                                  
d2301 3
a2303 5
      allocate( l1bData%DpField(dims(1),l1bData%noMAFs, 1),stat=status)
      call test_allocate ( status, moduleName, "l1bData%DpField", &
        & uBounds = [int(dims(1)),l1bData%noMAFs, 1], &
        & elementSize = storage_size(l1bData%DpField) / 8 )
      if ( present(FirstMAF) ) then                                          
d2305 4
a2308 4
          & (/0,MAFoffset/), (/int(dims(1)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,:,1))  
      end if                                                                  
d2310 4
a2313 6
    case ('double3')    
      allocate( l1bData%DpField(dims(1),dims(2),l1bData%noMAFs),stat=status)
      call test_allocate ( status, moduleName, "l1bData%DpField", &
        & uBounds = [int(dims(1:2)),l1bData%noMAFs], &
        & elementSize = storage_size(l1bData%DpField) / 8 )
      if ( present(FirstMAF) ) then                                          
d2315 4
a2318 4
          & (/0,0,MAFoffset/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField)  
      end if                                                                  
d2320 4
a2323 9
    case ('double4')    
      allocate( &
        & l1bData%DpField(dims(1)*dims(2),dims(3),l1bData%noMAFs),stat=status &
        & )
      call test_allocate ( status, moduleName, "l1bData%DpField", &
        & uBounds = [int(dims(1)*dims(2)),int(dims(3)),l1bData%noMAFs], &
        & elementSize = storage_size(l1bData%DpField) / 8 )
      call allocate_test( DP4Buf, &
        & int(dims(1)), int(dims(2)), int(dims(3)), int(dims(4)), &
d2325 1
a2325 1
      if ( present(FirstMAF) ) then                                          
d2328 3
a2330 3
          & (/int(dims(1)),int(dims(2)),int(dims(3)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS( L1FileHandle, QuantityName, DP4Buf)   
d2333 2
a2334 3
        & (/ int(dims(1)*dims(2)), int(dims(3)), l1bData%noMAFs /) )
      call deallocate_test( DP4Buf, &
        & 'DP4Buf', ModuleName )
d2336 1
a2336 1
    case ('integer1')  
d2341 1
a2341 1
      if ( present(FirstMAF) ) then                                          
d2343 4
a2346 4
          & (/MAFoffset/), (/l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%intField(:,1,1))  
      end if                                                                  
d2353 1
a2353 1
      if ( present(FirstMAF) ) then                                          
d2355 4
a2358 4
          & (/0,MAFoffset/), (/int(dims(1)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField(:,:,1))  
      end if                                                                  
d2360 1
a2360 1
    case ('integer3')  
d2365 1
a2365 1
      if ( present(FirstMAF) ) then                                          
d2367 4
a2370 4
          & (/0,0,MAFoffset/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField)  
      end if                                                                  
d2374 1
a2374 1
    case ('character1')  
d2379 1
a2379 1
      if ( present(FirstMAF) ) then                                          
d2381 4
a2384 4
          & (/MAFoffset/), (/l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%charField(:,1,1))  
      end if                                                                  
d2388 1
a2388 1
    case ('character3') 
d2392 1
a2392 1
    case default 
d2416 5
a2420 5
    !  hdfVERSION         rank 1       rank 2(a)     rank 2(b)   
    !      4               1 1 5         10 1 5       1 10 5   
    !      5               5 1 1         10 5 1       10 5 1   
    !   reorder            2 3 1         1  3 2       3  1 2   
    ! (depending on whether it's (a) or (b) methods that apply; 
d2430 1
a2430 1
    integer, dimension(3)                :: old_shape    
d2444 1
a2444 1
    
d2521 1
a2521 1
    case default 
d2710 1
a2710 1
       "$Id: L1BData.f90,v 2.101 2014/07/23 21:57:59 pwagner Exp $"
d2719 5
@


2.101
log
@Attempted to match names passed to allocate/deallocate
@
text
@d16 2
a17 2
  use allocate_deallocate, only: allocate_test, deallocate_test
  use dump_0, only: diff, diff_fun, dump
d32 1
a32 1
  use MLSmessagemodule, only: MLSmsg_allocate, MLSmsg_error, &
a38 1
  use toggles, only: switches
d184 2
d232 1
a232 1
    elseif( present(L1bDataSibling) ) then
d238 1
a238 1
      elseif ( associated(L1bDataSibling%intField)) then
d240 1
a240 1
      elseif ( associated(L1bDataSibling%dpField)) then
d245 1
a245 1
      endif
d249 1
a249 1
    endif
d253 1
a253 1
    endif
d264 1
a264 1
    endif
d439 1
a439 1
    endif
d444 1
a444 1
    elseif ( associated(l1bDataIn%intField)) then
d446 1
a446 1
    elseif ( associated(l1bDataIn%dpField)) then
d451 1
a451 1
    endif
d476 1
a476 1
    enddo
d498 1
a498 1
    endif
d507 1
a507 1
    ! This should be called when an l1bData is finished with
d561 1
a561 1
    endif
d569 1
a569 1
    endif
d576 1
a576 1
    endif
d590 1
a590 1
    endif
d598 1
a598 1
    endif
d605 1
a605 1
    endif
d609 1
a609 1
    endif
d616 1
a616 1
    endif
d623 1
a623 1
    endif
d630 1
a630 1
    endif
d637 1
a637 1
    endif
d644 1
a644 1
    endif
d651 1
a651 1
    endif
d654 1
a654 1
    elseif ( L1bData1%FirstMAFCtr > L1bData2%FirstMAFCtr ) then
d656 1
a656 1
    endif
d659 1
a659 1
    elseif ( L1bData1%LastMAFCtr > L1bData2%LastMAFCtr ) then
d661 1
a661 1
    endif
d665 1
a665 1
    endif
d672 1
a672 1
       endif
d682 1
a682 1
    endif
d695 3
a697 3
            enddo
          enddo
        enddo
d706 3
a708 3
            enddo
          enddo
        enddo
d723 1
a723 1
      elseif ( .not. mySilent ) then
d725 1
a725 1
      endif
d736 1
a736 1
      elseif ( l1b1NotFinite ) then
d738 1
a738 1
      elseif ( l1b2NotFinite ) then
d753 3
a755 3
        endif
      endif
    endif
d765 1
a765 1
      endif
d768 1
a768 1
      elseif ( l1b1NotFinite ) then
d770 1
a770 1
      elseif ( l1b2NotFinite ) then
d772 1
a772 1
      elseif ( myPeriodic ) then
d778 1
a778 1
      elseif ( myDirect ) then
d789 1
a789 1
      elseif ( .not. EssentiallyEqual(l1bData1%dpField, l1bData2%dpField, &
d798 1
a798 1
      endif
d954 1
a954 1
          elseif ( index(myOptions, 'f') > 0 ) then
d956 1
a956 1
          elseif ( index(myOptions, '/') > 0 ) then
d960 1
a960 1
          elseif ( index(myOptions, 's') > 0 ) then
d968 2
a969 2
          endif
        endif
d976 1
a976 1
          endif
d990 1
a990 1
            elseif ( index(myOptions, '/') > 0 ) then
d992 1
a992 1
            elseif ( index(myOptions, 's') > 0 ) then
d996 1
a996 1
            endif
d999 1
a999 1
          endif
d1067 1
a1067 1
      elseif ( myhdfVersion == HDFVERSION_4 ) then
d1146 1
a1146 1
        endif
d1149 1
a1149 1
      endif
d1180 1
a1180 1
    endif
d1187 1
a1187 1
    enddo
d1225 1
a1225 1
        endif
d1268 1
a1268 1
        endif
d1320 1
a1320 1
        endif
d1414 1
a1414 1
    elseif ( associated(l1bDataIn%intField)) then
d1416 1
a1416 1
    elseif ( associated(l1bDataIn%dpField)) then
d1421 1
a1421 1
    endif
d1436 1
a1436 1
    enddo
d1481 1
a1481 1
    elseif ( present(PrecisionOut) .and. .not. present(PrecisionIn) ) then
d1484 1
a1484 1
    endif
d1487 1
a1487 1
    elseif ( associated(l1bDataIn%intField)) then
d1489 1
a1489 1
    elseif ( associated(l1bDataIn%dpField)) then
d1494 1
a1494 1
    endif
d1510 1
a1510 1
    enddo
d1521 1
a1521 1
      elseif ( l1bDataIn%counterMAF(cmindex) == maf ) then
d1541 1
a1541 1
        enddo
d1550 2
a1551 2
      endif
    enddo
d1561 1
a1561 1
    enddo
d1568 2
d1586 1
d1592 3
d1610 2
a1611 1
    return
d1618 3
a1620 1
  use PCFHdr, only: GLOBALATTRIBUTES
d1638 1
d1643 2
d1686 1
a1686 1
        return
d1691 2
a1692 2
      & (GlobalAttributes%FirstMAFCtr > GlobalAttributes%LastMAFCtr) ) return
    if ( .not. IsL1BGappy(l1bData) ) return
d1697 1
a1697 1
    endif
d1702 1
a1702 1
    endif
d1714 2
a1715 2
      return
    endif
d1718 1
a1718 1
    if ( .not. present(firstMAF) .and. .not. present(lastMAF) ) return
d1726 3
d1734 3
a1736 1
    
d1762 1
d1772 3
a1774 3
    integer, dimension(:), pointer :: EDGE
    integer, dimension(:), pointer :: START
    integer, dimension(:), pointer :: STRIDE
d1779 2
a1783 1
    nullify ( edge, start, stride, tmpR4Field )
d1794 1
a1794 1
        if ( MyNeverFail ) return
d1805 1
a1805 1
        if ( MyNeverFail ) return
d1814 1
a1814 1
      if ( MyNeverFail ) return
d1823 1
a1823 1
      if ( MyNeverFail ) return
d1834 1
a1834 1
      if ( MyNeverFail ) return
d1839 3
a1841 4
    ! allocate, based on above SD, dim info
    call allocate_test ( edge,   rank, 'edge',   ModuleName )
    call allocate_test ( start,  rank, 'start',  ModuleName )
    call allocate_test ( stride, rank, 'stride', ModuleName )
d1864 1
a1864 1
        if ( MyNeverFail ) return
d1876 1
a1876 1
        if ( MyNeverFail ) return
d1901 1
a1901 1
        if ( MyNeverFail ) return
d1922 8
a1929 4
        if ( MyNeverFail ) return
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_allocate // ' charField pointer.', MLSFile=L1BFile )
      end if
d1957 1
a1957 1
      nullify ( l1bData%charField, l1bData%intField )
d1975 1
a1975 1
      if ( MyNeverFail ) return
d1980 1
a1980 1
      if ( MyNeverFail ) return
d1991 1
a1991 1
        if ( MyNeverFail ) return
d2001 1
a2001 1
      if ( MyNeverFail ) return
d2007 4
a2010 4
    ! deallocate local variables
    call Deallocate_test ( edge,   'edge',   ModuleName )
    call Deallocate_test ( start,  'start',  ModuleName )
    call Deallocate_test ( stride, 'stride', ModuleName )
d2017 1
d2021 2
d2048 1
d2056 4
a2059 4
    integer(kind=hSize_t), dimension(:), pointer :: DIMS
    integer(kind=hSize_t), dimension(:), pointer :: MAXDIMS
    integer(kind=hSize_t), dimension(:), pointer :: CMDIMS
    integer(kind=hSize_t), dimension(:), pointer :: CMMAXDIMS
d2065 2
d2070 1
a2070 1
    endif
d2082 1
a2082 1
      if ( MyNeverFail ) return
d2115 1
a2115 1
        if ( MyNeverFail ) return
d2127 1
a2127 1
        if ( MyNeverFail ) return
d2155 1
a2155 1
        if ( MyNeverFail ) return
d2180 1
a2180 1
      elseif ( cmdims(1) /= l1bData%noMAFs ) then
d2184 2
a2185 2
          return
        endif
d2229 1
a2229 1
    endif
d2238 3
d2250 3
d2262 3
d2270 1
a2270 1
      endif                                                                  
d2276 3
d2288 1
a2288 1
      endif
d2296 3
d2308 3
d2320 3
d2328 1
a2328 1
      endif                                                                  
d2334 3
d2346 1
a2346 1
      endif
d2354 3
d2366 3
d2378 3
d2386 1
a2386 1
      endif                                                                  
d2392 3
d2412 1
a2412 1
      if ( MyNeverFail ) return
d2418 6
a2423 3
    
    ! Avoid memory leaks
    deallocate(dims, maxDims)
d2439 1
d2459 1
d2491 2
a2492 4
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not allocate ' // &
        & trim(l1bData%data_type))
d2495 1
d2497 1
a2497 4
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not deallocate ' // &
        & trim(l1bData%data_type))
d2508 2
a2509 4
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not allocate ' // &
        & trim(l1bData%data_type))
d2512 1
d2514 1
a2514 4
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not deallocate ' // &
        & trim(l1bData%data_type))
d2529 2
a2530 4
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not allocate ' // &
        & trim(l1bData%data_type))
d2533 1
d2535 1
a2535 4
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not deallocate ' // &
        & trim(l1bData%data_type))
d2575 1
a2575 1
    endif
d2584 1
a2584 1
    endif
d2594 1
a2594 1
        elseif ( nIn+nn > size(l1BDataIn%dpField, 3) ) then
d2601 1
a2601 1
        endif
d2609 1
a2609 1
    endif
d2636 1
a2636 1
    endif
d2639 1
a2639 1
    endif
d2642 1
a2642 1
    endif
d2660 1
a2660 1
    enddo
d2726 1
a2726 1
       "$Id: L1BData.f90,v 2.100 2014/03/07 19:12:49 pwagner Exp $"
d2735 3
@


2.100
log
@Name_Len changed to nameLen; got from MLSCommon
@
text
@d16 26
a41 26
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only: DIFF, DIFF_FUN, DUMP
  use HDF, only: DFACC_RDonly, SFGINFO, SFN2INDEX, SFSELECT, &
    & SFRDATA_F90, &
    & SFRCDATA, SFENDACC, DFNT_CHAR8, DFNT_INT32, DFNT_FLOAT64, &
    & DFNT_FLOAT32
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use IEEE_ARITHMETIC, only: IEEE_IS_FINITE
  use INTRINSIC, only: L_HDF
  use LEXER_CORE, only: PRINT_SOURCE
  use MLSCOMMON, only: MLSFILE_T, &
    & UNDEFINEDVALUE, FILENAMELEN, namelen
  use MLSFILES, only: FILENOTFOUND, HDFVERSION_4, HDFVERSION_5, &
    & ADDFILETODATABASE, INITIALIZEMLSFILE, &
    & MLS_OPENFILE, MLS_CLOSEFILE
  use MLSKINDS, only: R4, R8
  use MLSMESSAGEMODULE, only: MLSMSG_ALLOCATE, MLSMSG_ERROR, &
    & MLSMSG_L1BREAD, MLSMSG_WARNING, MLSMESSAGE
  use MLSSTRINGS, only: INDEXES, STREQ
  use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, SWITCHDETAIL
  use MORETREE, only: GET_FIELD_ID
  use OUTPUT_M, only: OUTPUT
  use STRING_TABLE, only: GET_STRING
  use TOGGLES, only: SWITCHES
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TREE, only: NSONS, SUB_ROSA, SUBTREE, DUMP_TREE_NODE, WHERE
d1876 1
a1876 1
      & 'counterMAF', ModuleName )
d2119 1
a2119 1
      & 'counterMAF', ModuleName )
d2668 1
a2668 1
       "$Id: L1BData.f90,v 2.99 2014/01/09 00:25:06 pwagner Exp $"
d2677 3
@


2.99
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d27 1
a27 1
    & UNDEFINEDVALUE, FILENAMELEN
a50 1
! NAME_LEN                        Max length of l1b sds array name
d110 1
a110 1
  public :: L1BData_T, NAME_LEN, PRECISIONSUFFIX, &
a141 1
  integer, parameter :: NAME_LEN = 64  ! Max len of SDS array name
d167 1
a167 1
    character (len=name_len) :: L1BName ! Name of field in file
d313 1
a313 1
    character(len=NAME_LEN)      :: QtyName
d325 1
a325 1
    character(len=NAME_LEN) :: the_rest
a907 1
    logical, parameter :: TRUSTDATABASE = .true.
a2011 3
    ! integer, parameter :: MAX_NOMAFS = 7000     ! Expect ~3500 in one day
    integer, parameter :: SD_NO_COUNTERMAF = -2
    ! integer, dimension(:), pointer :: cm_array
d2668 1
a2668 1
       "$Id: L1BData.f90,v 2.98 2013/09/24 23:27:14 vsnyder Exp $"
d2677 3
@


2.98
log
@Use Get_Where or Print_Source to start error messages
@
text
@d22 1
d37 1
a37 1
  use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
d2674 1
a2674 1
       "$Id: L1BData.f90,v 2.97 2013/08/31 01:24:53 vsnyder Exp $"
d2683 3
@


2.97
log
@Replace MLSMessageCalls with trace_begin and trace_end
@
text
@d40 1
a40 1
  use TREE, only: NSONS, SUB_ROSA, SUBTREE, DUMP_TREE_NODE, SOURCE_REF
d2638 1
a2638 1
        call print_source ( source_ref(lcf_where) )
d2673 1
a2673 1
       "$Id: L1BData.f90,v 2.96 2013/06/29 00:16:37 pwagner Exp $"
d2682 3
@


2.96
log
@Added -SL1bread switch
@
text
@d32 1
a32 2
    & MLSMSG_L1BREAD, MLSMSG_WARNING, &
    & MLSMESSAGE, MLSMESSAGECALLS
d39 1
d210 2
a211 2
  !-------------------------------------------  allocateL1BData  -----
  subroutine allocateL1BData ( l1bData, &
d296 1
a296 1
  end subroutine allocateL1BData
d298 1
a298 1
  !-------------------------------------------  AssembleL1BQtyName  -----
d405 1
a405 1
  !-------------------------------------------------  ContractL1BData  -----
d481 1
a481 1
  !-------------------------------------------  cpL1BData  -----
d505 1
a505 1
  !-------------------------------------------  DeallocateL1BData  -----
d517 1
a517 1
  !-------------------------------------------------  DiffL1BData  -----
d813 1
a813 1
  !-------------------------------------------------  DumpL1BData  -----
d878 1
a878 1
  ! ------------------------------------------------  GetL1BFile  -----
d919 1
d925 1
d928 1
a928 1
    call MLSMessageCalls( 'push', constantName='GetL1BFile' )
d982 1
a982 1
            call MLSMessageCalls( 'pop' )
d1007 1
a1007 1
            call MLSMessageCalls( 'pop' )
d1014 1
a1014 1
    call MLSMessageCalls( 'pop' )
d1016 1
d1018 1
d1051 1
d1055 1
a1055 1
    call MLSMessageCalls( 'push', constantName='FindL1BData' )
d1082 2
a1083 1
    call MLSMessageCalls( 'pop' )
d1086 1
a1086 1
  ! ------------------------------------------------  FindMaxMAF  -----
d1157 1
a1157 1
  !--------------------------------------------------  IsL1BGappy  -----
d1278 1
a1278 1
  !-------------------------------------ReadL1BAttribute_intarr1l---------
d1334 1
a1334 1
  !-------------------------------------ReadL1BAttribute_dblarr1---------
d1388 1
a1388 1
  !-------------------------------------------------  PadL1BData  -----
d1442 1
a1442 1
  !-------------------------------------------------  BadPadL1BData  -----
d1565 1
a1565 1
  !-------------------------------------------------  ReadL1BData_fileHandle  -----
d1608 1
a1608 1
  !-------------------------------------------------  ReadL1BData_MLSFile  -----
d1717 1
a1717 1
  !--------------------------------------------  ReadL1BData_MF_hdf4  -----
d1993 1
a1993 1
  !--------------------------------------------  ReadL1BData_MF_hdf5  -----
d2495 1
a2495 1
  ! ---------------------------------------------  cpField  -----
d2559 2
a2560 2
  ! ---------------------------------------------  zeroField  -----
  subroutine zeroField(l1bData, n, value, m, chValue)
d2590 1
a2590 1
  end subroutine zeroField
d2592 2
a2593 2
  ! ---------------------------------------------  myminval  -----
  function myminval(ints) result(mymin)
d2598 11
a2608 11
  integer, dimension(:), intent(in)  :: ints
  integer                            :: mymin
  ! Internal variables
  integer :: i
  ! Executable
  mymin= maxval(ints)
  if ( size(ints) < 2 ) return
  do i=1, size(ints)
    if ( ints(i) > 0 ) mymin=min(mymin, ints(i))
  enddo
  end function myminval
d2673 1
a2673 1
       "$Id: L1BData.f90,v 2.95 2013/05/31 00:40:31 vsnyder Exp $"
d2682 3
@


2.95
log
@Make test for SC case insensitive
@
text
@d35 1
a35 1
  use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS
d37 1
a37 1
  use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE, RESUMEOUTPUT, SUSPENDOUTPUT
d39 1
a1463 1
    integer :: lastMAF
a1507 1
    lastmaf = maf - 1
d1645 4
a1753 1
    logical :: isL2AUX
a1762 2
    isL2AUX = .false.
    if ( present(l2AUX) ) isL2AUX = L2AUX
a2025 1
    integer :: SDS1_ID
a2041 1
    sds1_id = 0
a2130 1
        sds1_id = SD_NO_COUNTERMAF
d2667 1
a2667 1
       "$Id: L1BData.f90,v 2.94 2012/09/11 18:53:40 pwagner Exp $"
d2676 3
@


2.94
log
@Anonymized diffed arrays
@
text
@d317 4
d339 4
a342 11
    if ( hdfVersion == HDFVERSION_5 ) then
      head = '/'
      instr_tail = '/'
      tp_tail = '/'
    else
      head = ''
      instr_tail = '.'
      if ( present(InstrumentName) ) then
        if ( trim(InstrumentName) == 'sc' ) instr_tail = ''
      end if
      tp_tail = ''
d344 4
d349 1
a349 1
      QtyName = head // trim(InstrumentName) // instr_tail
d2670 1
a2670 1
       "$Id: L1BData.f90,v 2.93 2012/09/05 21:41:20 pwagner Exp $"
d2679 3
@


2.93
log
@Removed calls to suspend, resumeOutput when Silent
@
text
@d743 2
a744 2
            & l1bValues1, '(1)', &
            & l1bValues2, '(2)', &
d784 2
a785 2
          & l1bData1%dpField, '(1)', &
          & l1bData2%dpField, '(2)', &
d791 2
a792 2
        & l1bData1%dpField(:,:,mafStart1:mafEnd1), '(1)', &
        & l1bData2%dpField(:,:,mafStart2:mafEnd2), '(2)', &
d2669 1
a2669 1
       "$Id: L1BData.f90,v 2.92 2012/06/07 23:57:17 pwagner Exp $"
d2678 3
@


2.92
log
@Limit printing while reading attributes to DEEBUGging
@
text
@d585 1
d589 1
a589 1
    if ( mySilent ) call suspendOutput
d801 1
d806 1
a806 1
      call resumeOutput
d2669 1
a2669 1
       "$Id: L1BData.f90,v 2.91 2011/07/15 23:31:06 pwagner Exp $"
d2678 3
@


2.91
log
@Can now read 4d l1b data types; removed redundant code
@
text
@d188 1
d1307 5
a1311 3
      else 
        call output ('get attribute', advance='no')
        call output (AttrName, advance='yes')
d2667 1
a2667 1
       "$Id: L1BData.f90,v 2.90 2011/07/07 00:30:03 pwagner Exp $"
d2676 3
@


2.90
log
@Treats diffs of l1bdata types with periods
@
text
@d1555 1
a1557 2
    
  use PCFHdr, only: GLOBALATTRIBUTES
d1571 6
a1576 454
    ! Local variables
    integer :: myhdfVersion
    logical :: myDontPad
    type(l1bdata_t) :: L1BDATATMP
    logical :: isScalar
    logical, parameter :: DEEBug = .false.

    ! Executable code
    if ( present(hdfVersion) ) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L1BDEFAULT_HDFVERSION
    end if
    ! print * 'hdfVersion: ', hdfVersion
    myDontPad = .false.
    if ( present(firstMAF) ) myDontPad = .true.
    if ( present(dontPad) ) myDontPad = dontPad

    if ( myhdfVersion == HDFVERSION_4 ) then
      call ReadL1BData_FH_hdf4 ( L1FileHandle, trim(QuantityName), L1bData, &
      & NoMAFs, Flag, FirstMAF, LastMAF, NEVERFAIL, L2AUX )
      if ( flag /= 0 ) NOMAFS = -1
    else
      call ReadL1BData_FH_hdf5 ( L1FileHandle, trim(QuantityName), L1bData, &
      & NoMAFs, Flag, FirstMAF, LastMAF, NEVERFAIL, L2AUX )
      !Unfortunately, hdf5-formatted l1b data have different shapes from hdf4
      ! E.g., for MAFStartTimeTAI we obtain the following
      !  hdfVERSION      shape
      !     4           1   1   5
      !     5           5   1   1
      if ( Flag == 0 ) then
        call Reshape_for_hdf4(L1bData)
      else
        call MLSMessage ( MLSMSG_Warning, ModuleName // '/ReadL1BData_fileHandle', &
        & 'Failed to find '//trim(QuantityName)//' in l1b files')
        NOMAFS = -1
        ! call outputNamedValue( 'noMAFs', noMAFs )
        ! call outputNamedValue( 'Flag', Flag )
        ! call output( 'returning now', advance='yes' )
        return
      end if
    end if
    isScalar = ( l1bData%noMAFs < 2 ) ! There may be a better way to decide
    if ( myDontPad .or. flag /= 0 .or. isScalar .or. &
      & (GlobalAttributes%FirstMAFCtr > GlobalAttributes%LastMAFCtr) ) return
    if ( .not. IsL1BGappy(l1bData) ) return
    ! Must pad l1bdata; so first copy to temp l1bData
    if ( associated(l1bdata%dpField) .and. DEEBug ) then
      ! print *, 'max(l1bdata) ', maxval(l1bdata%dpField(1,1,:))
      ! print *, 'min(l1bdata) ', minval(l1bdata%dpField(1,1,:))
    endif
    call cpL1bData(l1bdata, l1bdataTmp)
    if ( associated(l1bdatatmp%dpField) .and. DEEBug ) then
      ! print *, 'max(l1bdatatmp) ', maxval(l1bdatatmp%dpField(1,1,:))
      ! print *, 'min(l1bdatatmp) ', minval(l1bdatatmp%dpField(1,1,:))
    endif
    call deallocatel1bData(l1bdata)
    if ( GlobalAttributes%LastMAFCtr > 0 ) &
      & NoMAFs = GlobalAttributes%LastMAFCtr - GlobalAttributes%FirstMAFCtr + 1
    if ( DEEBug ) print *, 'preparing to pad'
    if ( DEEBug ) print *, 'GlobalAttributes%FirstMAFCtr ', GlobalAttributes%FirstMAFCtr
    if ( DEEBug ) print *, 'GlobalAttributes%LastMAFCtr ', GlobalAttributes%LastMAFCtr
    if ( DEEBug ) print *, 'NoMAFs ', NoMAFs
    if ( present(firstMAF) .and. present(lastMAF)) then
      call PadL1BData(l1bdataTmp, l1bData, FirstMAF, LastMAF, NoMAFs)
      call deallocatel1bData(l1bdataTmp)
      return
    endif
    call BadPadL1BData(l1bdataTmp, l1bData, GlobalAttributes%FirstMAFCtr, NoMAFs)
    call deallocatel1bData(l1bdataTmp)
    if ( .not. present(firstMAF) .and. .not. present(lastMAF) ) return
    ! Need to contract padded l1bdata to just those MAFs requested
    call cpL1bData(l1bdata, l1bdataTmp)
    call deallocatel1bData(l1bdata)
    if ( DEEBug ) print *, 'preparing to contract'
    call ContractL1BData(l1bdataTmp, l1bData, noMAFs, firstMAF, lastMAF)
    call deallocatel1bData(l1bdataTmp)
  end subroutine ReadL1BData_fileHandle

  !--------------------------------------------  ReadL1BData_FH_hdf4  -----
  subroutine ReadL1BData_FH_hdf4 ( L1FileHandle, QuantityName, L1bData, &
    & NoMAFs, Flag, FirstMAF, LastMAF, NEVERFAIL, L2AUX )
    
    ! Dummy arguments
    character(len=*), intent(in)   :: QUANTITYNAME ! Name of SD to read
    integer, intent(in)            :: L1FILEHANDLE ! From HDF
    integer, intent(in), optional  :: FIRSTMAF ! First to read (default 0)
    integer, intent(in), optional  :: LASTMAF ! Last to read (default last in file)
    logical, intent(in), optional  :: NEVERFAIL ! Don't quit if TRUE
    logical, intent(in), optional  :: L2AUX     ! Don't even warn if TRUE
    type(l1bdata_t), intent(inout) :: L1BDATA ! Result
    integer, intent(out) :: FLAG        ! Error flag
    integer, intent(out) :: NOMAFS      ! Number actually read

    ! Local Parameters
    character (len=*), parameter :: INPUT_ERR = 'Error in input argument '
    integer, parameter :: MAX_VAR_DIMS = 32
    integer, parameter :: SD_NO_COUNTERMAF = -2

    ! Local Variables

    character (len=128) :: DUMMY        ! Dummy quantity name

    integer :: ALLOC_ERR
    integer :: DATA_TYPE
    integer :: DIM_SIZES(MAX_VAR_DIMS)
    integer :: I
    logical :: MyNeverFail
    integer :: N_ATTRS
    integer :: NUMMAFS
    integer :: RANK
    integer :: SDS1_ID
    integer :: SDS2_ID
    integer :: SDS_INDEX
    integer :: STATUS

    integer, dimension(:), pointer :: EDGE
    integer, dimension(:), pointer :: START
    integer, dimension(:), pointer :: STRIDE

    real(r4), pointer, dimension(:,:,:) :: tmpR4Field
    logical :: isL2AUX

    ! Executable code
    call deallocateL1BData ( l1bData ) ! Avoid memory leaks

    nullify ( edge, start, stride, tmpR4Field )
    flag = 0
    MyNeverFail = .false.
    if ( present(NeverFail) ) MyNeverFail = NeverFail
    isL2AUX = .false.
    if ( present(l2AUX) ) isL2AUX = L2AUX

    ! Find data sets for counterMAF & quantity by name

    sds_index = sfn2index(L1FileHandle, 'counterMAF')
    if ( sds_index == -1 ) then
      if ( .not. JUSTLIKEL2AUX ) then
        flag = NOCOUNTERMAFINDX
        if ( MyNeverFail ) return
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Failed to find index of counterMAF data set.')
      else
        sds1_id = SD_NO_COUNTERMAF
      end if
    else

      sds1_id = sfselect(L1FileHandle, sds_index)
      if ( sds1_id == -1 ) then
        flag = NOCOUNTERMAFID
        if ( MyNeverFail ) return
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Failed to find identifier of counterMAF data set.')
      end if
    end if

    sds_index = sfn2index(L1FileHandle, quantityName)
    if ( sds_index == -1 ) then
      flag = NOQUANTITYINDEX
      if ( MyNeverFail ) return
      dummy = 'Failed to find index of quantity "' // trim(quantityName) // &
        & '" data set.'
      call MLSMessage ( MLSMSG_Error, ModuleName, dummy )
    end if

    sds2_id = sfselect(L1FileHandle, sds_index)
    if ( sds2_id == -1 ) then
      flag = NODATASETID
      if ( MyNeverFail ) return
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Failed to find identifier of data set matching the index.')
    end if

    ! Find rank (# of dimensions), dimension sizes of quantity data set
    status = sfginfo ( sds2_id, dummy, rank, dim_sizes, data_type, &
      n_attrs )

    if ( status == -1 ) then
      flag = NODATASETRANK
      if ( MyNeverFail ) return
      call MLSMessage ( MLSMSG_Error, ModuleName,&
      & 'Failed to find rank of data set.')
    end if

    ! allocate, based on above SD, dim info
    call allocate_test ( edge,   rank, 'edge',   ModuleName )
    call allocate_test ( start,  rank, 'start',  ModuleName )
    call allocate_test ( stride, rank, 'stride', ModuleName )

    ! Set "slab" dimensions
    edge = dim_sizes(1:rank)
    start = 0
    stride = 1

    ! Fill in "indexing" values of l1b object

    l1bData%L1BName = quantityName
    l1bData%TrueRank = rank

    l1bData%noAuxInds = product(dim_sizes(1:rank-2))
    l1bData%maxMIFs = 1
    if ( rank > 1 ) l1bData%maxMIFs = dim_sizes(rank-1)

    ! Check input arguments, set noMAFs

    numMAFs = dim_sizes(rank)

    if ( present ( firstMAF ) ) then
      if ( (firstMAF >= numMAFs) .or. (firstMAF < 0) ) then
        flag = FIRSTMAFNOTFOUND
        if ( MyNeverFail ) return
        call MLSMEssage ( MLSMSG_Error, ModuleName, &
        & input_err // 'firstMAF (bad chunkNo?)' )
      end if
      l1bData%firstMAF = firstMAF
    else
      l1bData%firstMAF = 0
    end if

    if ( present (lastMAF) ) then
      if ( lastMAF < l1bData%firstMAF ) then
        flag = LASTMAFNOTFOUND
        if ( MyNeverFail ) return
        call MLSMEssage ( MLSMSG_Error, ModuleName, &
        & input_err // 'last' )
      end if
      if ( lastMAF >= numMAFs ) then
        l1bData%noMAFs = numMAFs - l1bData%firstMAF
      else
        l1bData%noMAFs = lastMAF - l1bData%firstMAF + 1
      end if
    else
      l1bData%noMAFs = numMAFs - l1bData%firstMAF
    end if

    noMAFs = l1bData%noMAFs
    edge(rank) = l1bData%noMAFs
    start(rank) = l1bData%firstMAF

    ! allocate, read counterMAF
    call Allocate_test ( l1bData%counterMaf, l1bData%noMAFs, &
      & 'counterMAF', ModuleName )
    if ( sds1_id /= SD_NO_COUNTERMAF ) then
      status = sfrdata_f90(sds1_id,  (/ l1bData%firstMAF /) , (/1/), &
        & (/l1bData%noMAFs/), l1bData%counterMAF )
      if ( status == -1 ) then
        flag = CANTREADCOUNTERMAF
        if ( MyNeverFail ) return
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_L1BRead // 'counterMAF.' )
      end if
    else
      ! Since we aren't reading these, just make them internally consistent
      do i = 1, l1bData%noMAFs
        l1bData%counterMAF(i) = l1bData%firstMAF + i - 1
      end do
    end if

    l1bData%FirstMAFCtr = myminval(l1bData%counterMAF)
    l1bData%LastMAFCtr = maxval(l1bData%counterMAF)
    ! allocate, read according to field type; nullify unused pointers
    select case ( data_type )

    case ( DFNT_CHAR8 ) ! ----------------------- character
      allocate ( l1bData%charField(l1bData%noAuxInds,l1bData%maxMIFs, &
        & l1bData%noMAFs), STAT=alloc_err )
      if ( alloc_err /= 0 ) then
        flag = CANTALLOCATECHARS
        if ( MyNeverFail ) return
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_allocate // ' charField pointer.' )
      end if
      nullify (l1bData%intField, l1bData%dpField)
      l1bdata%data_type = 'character'
      status = sfrcdata ( sds2_id, start, stride, edge, &
        & l1bData%charField )

    case ( DFNT_INT32 ) ! ------------------------------ integer
      call allocate_test ( l1bData%intField, &
        & l1bData%noAuxInds, l1bData%maxMIFs, l1bData%noMAFs, &
        & 'l1bData%intField', ModuleName )
      nullify ( l1bData%charField, l1bData%dpField )
      l1bdata%data_type = 'integer'
      status = sfrdata_f90 ( sds2_id, start, stride, edge, &
          l1bData%intField )

    case ( DFNT_FLOAT64 ) ! ------------------------------ real (r8)
      call allocate_test ( l1bData%dpField, &
        & l1bData%noAuxInds, l1bData%maxMIFs, l1bData%noMAFs, &
        & 'l1bData%dpField', ModuleName )
      nullify ( l1bData%charField, l1bData%intField )
      l1bdata%data_type = 'double'
      status = sfrdata_f90 ( sds2_id, start, stride, edge, &
          l1bData%dpField )

    case ( DFNT_FLOAT32 ) ! ------------------------------ real (r4)
      call allocate_test ( l1bData%dpField, &
        & l1bData%noAuxInds, l1bData%maxMIFs, l1bData%noMAFs, &
        & 'l1bData%dpField', ModuleName )
      nullify ( l1bData%charField, l1bData%intField )
      l1bdata%data_type = 'double'

      call allocate_test ( tmpr4Field, &
        & l1bData%noAuxInds, l1bData%maxMIFs, l1bData%noMAFs, &
        & 'tmpR4Field', ModuleName )
      status = sfrdata_f90 ( sds2_id, start, stride, edge, &
          tmpR4Field )
      l1bData%dpField = tmpR4Field
      
      call deallocate_test ( tmpr4Field, 'tmpr4Field', ModuleName )

    case default
      status = -2
    end select ! ----------------------------------------------------

    if ( status == -1 ) then
      flag = CANTREAD3DFIELD
      if ( MyNeverFail ) return
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_L1BRead // quantityName )
    else if ( status == -2 ) then
      flag = UNKNOWNDATATYPE
      if ( MyNeverFail ) return
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unknown data type in readl1bData'   )
    end if

    ! Terminate access to the data sets
    
    if ( sds1_id /= SD_NO_COUNTERMAF ) then
      status = sfendacc(sds1_id)
      if ( status == -1 ) then
        flag = CANTENDCOUNTERMAF
        if ( MyNeverFail ) return
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Failed to terminate access to data sets.' )
        flag = -1
      end if
    end if

    status = sfendacc(sds2_id)
    if ( status == -1 ) then
      flag = CANTENDQUANTITY
      if ( MyNeverFail ) return
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Failed to terminate access to data sets.' )
      flag = -1
    end if

    ! deallocate local variables
    call Deallocate_test ( edge,   'edge',   ModuleName )
    call Deallocate_test ( start,  'start',  ModuleName )
    call Deallocate_test ( stride, 'stride', ModuleName )

  end subroutine ReadL1BData_FH_hdf4

  !--------------------------------------------  ReadL1BData_FH_hdf5  -----
  subroutine ReadL1BData_FH_hdf5 ( L1FileHandle, QuantityName, L1bData, NoMAFs, &
    & Flag, FirstMAF, LastMAF, NEVERFAIL, L2AUX )
    use HDF5, only: HSIZE_T
    use MLSHDF5, only: ISHDF5DSPRESENT, LOADFROMHDF5DS, &
      & GETHDF5DSRANK, GETHDF5DSDIMS, GETHDF5DSQTYPE
! use MLSAuxData, only: MLSAuxData_T, Read_MLSAuxData, Deallocate_MLSAuxData
    
    ! Dummy arguments
    character(len=*), intent(in)   :: QUANTITYNAME ! Name of SD to read
    integer, intent(in)            :: L1FILEHANDLE ! From HDF
    integer, intent(in), optional  :: FIRSTMAF ! First to read (default 0)
    integer, intent(in), optional  :: LASTMAF ! Last to read (default last/file)
    logical, intent(in), optional  :: NEVERFAIL ! Don't quit if TRUE
    logical, intent(in), optional  :: L2AUX     ! Don't even warn if TRUE
    type(l1bdata_t), intent(inout) :: L1BDATA ! Result
    integer, intent(out) :: FLAG        ! Error flag
    integer, intent(out) :: NOMAFS      ! Number actually read

    ! Local Parameters
    character (len=*), parameter :: INPUT_ERR = 'Error in input argument '
    ! integer, parameter :: MAX_NOMAFS = 7000     ! Expect ~3500 in one day
    integer, parameter :: SD_NO_COUNTERMAF = -2
    ! integer, dimension(:), pointer :: cm_array

    ! Local Variables

    character (len=128) :: DUMMY        ! Dummy quantity name

    character(len=1) :: Char_rank
    integer :: I
    integer :: MAFoffset
    logical :: MyNeverFail
    integer :: NUMMAFS
    integer :: RANK
    integer :: CMRANK
    character(len=16) :: QTYPE
    integer :: SDS1_ID
    integer :: STATUS

    integer(kind=hSize_t), dimension(:), pointer :: DIMS
    integer(kind=hSize_t), dimension(:), pointer :: MAXDIMS
    integer(kind=hSize_t), dimension(:), pointer :: CMDIMS
    integer(kind=hSize_t), dimension(:), pointer :: CMMAXDIMS

    logical, parameter           :: DEEBUG = .false.
    logical :: isL2AUX

    ! Executable code
    call MLSMessageCalls( 'push', constantName='ReadL1BData_FH_hdf5' )
    if ( present(FirstMAF) ) then
      MAFoffset = max(0, FirstMAF)   ! Never let this be < 0
    endif
    call deallocateL1BData ( l1bData ) ! Avoid memory leaks
    sds1_id = 0

    flag = 0
    MyNeverFail = .false.
    if ( present(NeverFail) ) MyNeverFail = NeverFail
    isL2AUX = .false.
    if ( present(l2AUX) ) isL2AUX = L2AUX

    if ( .not. IsHDF5DSPresent(L1FileHandle, QuantityName) ) then
      flag = NOQUANTITYINDEX
      ! print *, 'Oops--' // trim(QuantityName) // ' not here'
      if ( MyNeverFail ) return
      dummy = 'Failed to find index of quantity "' // trim(quantityName) // &
        & '" data set.'
      call MLSMessage ( MLSMSG_Error, ModuleName, dummy )
    end if
    
    ! Find Qtype, rank and dimensions of QuantityName
    ! print*, ' Find Qtype, rank and dimensions of QuantityName ', trim(QuantityName)
    call GetHDF5DSRank(L1FileHandle, QuantityName, rank)
    ! Note yet able to read scalar datasets (a bug or a feature?)
    if ( rank < 1 ) then
      flag = CANTREADSCALARDS
      if ( MyNeverFail ) return
      dummy = 'Not yet able to read apparently scalar quantity "' // trim(quantityName) // &
        & '" data set.'
      call MLSMessage ( MLSMSG_Error, ModuleName, dummy )
    endif
    l1bData%TrueRank = rank
    allocate ( dims(rank), maxDims(rank) )
    call GetHDF5DSDims(L1FileHandle, QuantityName, dims, maxDims)
    call GetHDF5DSQType ( L1FileHandle, QuantityName, Qtype )
    if ( DEEBug ) print *, 'L1FileHandle ', L1FileHandle
    if ( DEEBug ) print *, 'QuantityName ', trim(QuantityName)
    if ( DEEBug ) print *, 'rank ', rank
    if ( DEEBug ) print *, 'maxDims ', maxDims
    if ( DEEBug ) print *, 'dims ', dims
    if ( DEEBug ) print *, 'Qtype ', Qtype
    if ( present(firstMAF) .and. DEEBug ) print *, 'firstMAF ', firstMAF
    if ( present(LastMAF) .and. DEEBug ) print *, 'LastMAF ', LastMAF

    l1bData%noAuxInds = product(dims(1:rank-2))
    l1bData%maxMIFs = 1
    if ( rank > 1 ) l1bData%maxMIFs = dims(rank-1)
d1578 3
a1580 12
    ! Check input arguments, set noMAFs

    numMAFs = dims(rank)

    if ( present ( firstMAF ) ) then
      if ( (firstMAF >= numMAFs) .or. (firstMAF < 0) ) then
        flag = FIRSTMAFNOTFOUND
        if ( MyNeverFail ) return
        call MLSMEssage ( MLSMSG_Error, ModuleName, &
        & input_err // 'firstMAF (bad chunkNo?)' )
      end if
      l1bData%firstMAF = firstMAF
d1582 1
a1582 92
      l1bData%firstMAF = 0
    end if

    if ( present (lastMAF) ) then
      if ( lastMAF < l1bData%firstMAF ) then
        flag = LASTMAFNOTFOUND
        if ( MyNeverFail ) return
        call dump( (/lastMAF, l1bData%firstMAF/), 'lastMAF, l1bData%firstMAF')
        call MLSMEssage ( MLSMSG_Error, ModuleName, &
        & input_err // 'last' )
      end if
      if ( lastMAF >= numMAFs ) then
        l1bData%noMAFs = numMAFs - l1bData%firstMAF
      else
        l1bData%noMAFs = lastMAF - l1bData%firstMAF + 1
      end if
    else
      l1bData%noMAFs = numMAFs - l1bData%firstMAF
    end if

    if ( DEEBug ) print *, 'l1bData%noMAFs ', l1bData%noMAFs
    l1bData%L1BName = quantityName

    noMAFs = l1bData%noMAFs
    if ( DEEBug ) print *, 'noMAFs ', noMAFs

    call Allocate_test ( l1bData%counterMaf, l1bData%noMAFs, &
      & 'counterMAF', ModuleName )
    ! Find data sets for counterMAF & quantity by name

    if ( .not. IsHDF5DSPresent(L1FileHandle, '/counterMAF') ) then
      if ( DEEBUG) print *, 'no counterMAF array in file'
      if ( .not. JUSTLIKEL2AUX ) then
        flag = NOCOUNTERMAFINDX
        if ( MyNeverFail ) return
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Failed to find index of counterMAF data set.')
      else
        if ( .not. isL2AUX ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Failed to find index of counterMAF data set.')
        sds1_id = SD_NO_COUNTERMAF
        ! Since we aren't reading these, just make them internally consistent
        do i = 1, l1bData%noMAFs
          l1bData%counterMAF(i) = l1bData%firstMAF + i - 1
        end do
      end if
    else
      if ( DEEBUG) print *, 'Getting counterMAF rank'
      call GetHDF5DSRank(L1FileHandle, '/counterMAF', cmrank)
      if ( DEEBUG) print *, cmrank
      allocate ( cmdims(cmrank), cmmaxDims(cmrank) )
      if ( DEEBUG) print *, 'getting counterMAF dims'
      call GetHDF5DSDims(L1FileHandle, '/counterMAF', cmdims, cmmaxDims)
      if ( DEEBUG) print *, cmdims, cmmaxDims
      ! allocate(countermaf_ptr(MAX_NOMAFS))
      ! countermaf_ptr = 0
      if ( present(FirstMAF) ) then
        if ( DEEBUG) print *, 'reading counterMAF ', MAFoffset, l1bData%noMAFs
        call LoadFromHDF5DS(L1FileHandle, '/counterMAF', l1bData%counterMaf, &
          & (/MAFoffset/), (/l1bData%noMAFs/) )
      elseif ( cmdims(1) /= l1bData%noMAFs ) then
        flag = CANTREADCOUNTERMAF
        if ( MyNeverFail ) then
          deallocate(dims, maxDims, cmdims, cmmaxdims)
          return
        endif
        call output('Quantity name: ', advance = 'no')
        call output(Quantityname, advance = 'yes')
        call output('Quantity rank: ', advance = 'no')
        call output(rank, advance = 'yes')
        call output('Quantity dims: ', advance = 'no')
        call output(int(dims), advance = 'yes')
        call output('Quantity noMAFs: ', advance = 'no')
        call output(l1bData%noMAFs, advance = 'yes')
        call output('counterMAF dims: ', advance = 'no')
        call output(int(cmdims), advance = 'yes')
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Sorry--ReadL1BData_hdf5 says counterMaf sized differently from ' &
          & // trim(QuantityName) )
      else
        if ( DEEBUG) print *, 'reading counterMAF '
        ! This intermediate cm_array shouldn't be necessary 
        ! unfortunately, w/o it sometimes hdf5 bombs
        ! allocate(cm_array(cmdims(1)), stat=status)
        ! allocate(cm_array(MAX_NOMAFS), stat=status)
        ! call LoadFromHDF5DS(L1FileHandle, '/counterMAF', cm_array)
        ! l1bData%counterMaf = cm_array(1:cmdims(1))
        ! deallocate(cm_array)
        call LoadFromHDF5DS(L1FileHandle, '/counterMAF', l1bData%counterMaf)
      end if
      if ( DEEBUG) print *, 'deallocating counterMAF dims'
      deallocate(cmdims, cmmaxdims)
a1583 17

    if ( DEEBUG) print *, 'computing FirstMAFCtr'
    l1bData%FirstMAFCtr = myminval(l1bData%counterMAF)
    if ( DEEBUG) print *, 'computing LastMAFCtr'
    l1bData%LastMAFCtr = maxval(l1bData%counterMAF)
    if ( DEEBUG) print *, 'l1bData%FirstMAFCtr ', l1bData%FirstMAFCtr
    if ( DEEBUG) print *, 'l1bData%LastMAFCtr ', l1bData%LastMAFCtr
    if ( DEEBUG) print *, 'About to use LoadFromHDF5DS to read ', trim(QuantityName)
    if ( DEEBUG) print *, 'dims ', dims
    if ( DEEBUG) print *, 'noMAFs ', l1bData%noMAFs
    write(Char_rank, '(i1)') rank
    if ( DEEBUG) print *, trim(Qtype) // Char_rank
    if ( DEEBUG .and. present(FirstMAF) ) then
      print *, 'FirstMAF-1 ', FirstMAF-1
      print *, 'MAFoffset ', MAFoffset
      print *, 'l1bData%noMAFs ', l1bData%noMAFs
    endif
d1585 11
a1595 120
    ! The following is a crude and despicable hack
    ! Please repair GetHDF5DSQType and delete these lines
    if ( Qtype == 'unknown' ) Qtype = 'character'

    select case (trim(Qtype) // Char_rank)
    case ('real1')
      allocate( l1bData%DpField(l1bData%noMAFs, 1, 1),stat=status)
      if ( present(FirstMAF) ) then                                          
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,1,1), &
          & (/MAFoffset/), (/l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,1,1))  
      end if                                                                  
      l1bdata%data_type = 'double'
    case ('real2')
      allocate( l1bData%DpField(dims(1),l1bData%noMAFs, 1),stat=status)
      if ( present(FirstMAF) ) then                                          
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,:,1), &
          & (/0,MAFoffset/), (/int(dims(1)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,:,1))  
      end if                                                                  
      l1bdata%data_type = 'double'
    case ('real3')
      allocate( l1bData%DpField(dims(1),dims(2),l1bData%noMAFs),stat=status)
      if ( present(FirstMAF) ) then                                          
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField, &
          & (/0,0,MAFoffset/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField)  
      endif                                                                  
      l1bdata%data_type = 'double'
    case ('double1')
      allocate( l1bData%DpField(l1bData%noMAFs, 1, 1),stat=status)
      if ( present(FirstMAF) ) then                                          
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,1,1), &
          & (/MAFoffset/), (/l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,1,1))  
      end if                                                                  
      l1bdata%data_type = 'double'
    case ('double2')
      allocate( l1bData%DpField(dims(1),l1bData%noMAFs, 1),stat=status)
      if ( present(FirstMAF) ) then                                          
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,:,1), &
          & (/0,MAFoffset/), (/int(dims(1)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField(:,:,1))  
      end if                                                                  
      l1bdata%data_type = 'double'
    case ('double3')    
      allocate( l1bData%DpField(dims(1),dims(2),l1bData%noMAFs),stat=status)
      if ( present(FirstMAF) ) then                                          
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField, &
          & (/0,0,MAFoffset/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%DpField)  
      endif                                                                  
      l1bdata%data_type = 'double'
    case ('integer1')  
      allocate( l1bData%intField(l1bData%noMAFs, 1, 1),stat=status)
      if ( present(FirstMAF) ) then                                          
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%intField(:,1,1), &
          & (/MAFoffset/), (/l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%intField(:,1,1))  
      end if                                                                  
      ! call MLSMessage ( MLSMSG_Error, ModuleName, &
      ! & 'Sorry--LoadFromHDF5DS not yet written for type integer(:).')
      l1bdata%data_type = 'integer'
    case ('integer2')
      allocate( l1bData%IntField(dims(1),l1bData%noMAFs, 1),stat=status)
      if ( present(FirstMAF) ) then                                          
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField(:,:,1), &
          & (/0,MAFoffset/), (/int(dims(1)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField(:,:,1))  
      end if                                                                  
      l1bdata%data_type = 'integer'
    case ('integer3')  
      allocate( l1bData%IntField(dims(1),dims(2),l1bData%noMAFs),stat=status)
      if ( present(FirstMAF) ) then                                          
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField, &
          & (/0,0,MAFoffset/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField)  
      endif                                                                  
!     call MLSMessage ( MLSMSG_Error, ModuleName, &
!     & 'Sorry--LoadFromHDF5DS not yet written for type integer(:,:,:).')
      l1bdata%data_type = 'integer'
    case ('character1')  
      allocate( l1bData%charField(l1bData%noMAFs, 1, 1),stat=status)
      if ( present(FirstMAF) ) then                                          
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%charField(:,1,1), &
          & (/MAFoffset/), (/l1bData%noMAFs/) )                                      
      else                                                                   
        call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%charField(:,1,1))  
      end if                                                                  
      ! call MLSMessage ( MLSMSG_Error, ModuleName, &
      ! & 'Sorry--LoadFromHDF5DS not yet written for type character(:).')
      l1bdata%data_type = 'character'
    case ('character3') 
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--LoadFromHDF5DS not yet rewritten for type char(:,:,:).')
      l1bdata%data_type = 'integer'
    case default 
      l1bdata%data_type = 'unknown'
      flag = UNKNOWNDATATYPE
      deallocate(dims, maxDims)
      if ( MyNeverFail ) return
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--ReadL1BData_hdf5 has encountered an unknown data type: ' &
        & // trim(Qtype) // Char_rank)
    end select
    if ( DEEBUG ) call dump(l1bData, 0)
    
    ! Avoid memory leaks
    deallocate(dims, maxDims)
    call MLSMessageCalls( 'pop' )
  end subroutine ReadL1BData_FH_hdf5
d2011 1
d2230 19
d2276 19
d2664 1
a2664 1
       "$Id: L1BData.f90,v 2.89 2011/02/05 01:37:05 pwagner Exp $"
d2673 3
@


2.89
log
@Passes options to dump routines
@
text
@d16 4
a19 4
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use Dump_0, only: DIFF, DUMP
  use Hdf, only: DFACC_RDONLY, SFGINFO, SFN2INDEX, SFSELECT, &
    & SFRDATA_f90, &
d22 17
a38 16
  use ieee_arithmetic, only: ieee_is_finite
  use intrinsic, only: l_hdf
  use Lexer_Core, only: PRINT_SOURCE
  use MLSCommon, only: MLSFile_T, &
    & R4, R8, undefinedValue, FILENAMELEN
  use MLSFiles, only: FILENOTFOUND, HDFVERSION_4, HDFVERSION_5, &
    & addFileToDatabase, InitializeMLSFile, &
    & mls_openFile, mls_closeFile
  use MLSMessageModule, only: MLSMSG_Allocate, MLSMSG_Error, &
    & MLSMSG_L1BREAD, MLSMSG_Warning, &
    & MLSMessage, MLSMessageCalls
  use MLSStrings, only: indexes, streq
  use MLSStringLists, only: NumStringElements
  use MoreTree, only: Get_Field_ID
  use Output_M, only: Output, outputnamedValue, resumeOutput, suspendOutput
  use String_Table, only: Get_String
d300 1
a300 1
    use MLSStrings, only: CompressString
d516 2
a517 1
    & details, options, numDiffs, mafStart, mafEnd, l1bValues1, l1bValues2 )
d519 1
a519 1
  use MLSStrings, only: asciify, isAllAscii
d534 1
d544 1
d547 1
d579 4
d739 11
a749 4
        call DIFF ( &
          & l1bValues1, '(1)', &
          & l1bValues2, '(2)', &
          & options=options )
d768 6
d895 3
a897 3
    use MLSHDF5, only: IsHDF5ItemPresent
    use MLSFiles, only: dump
    use HDF5, only: h5dopen_f, h5gclose_f, h5gopen_f
d1029 1
a1029 1
  use MLSHDF5, only: IsHDF5DSPresent
d1079 1
a1079 1
  use MLSHDF5, only: IsHDF5DSPresent
d1149 1
a1149 1
  use PCFHdr, only: GlobalAttributes
a1267 1
  ! subroutine ReadL1BAttribute_intarr1 ( L1FileHandle, value, AttrName, Flag, &
d1270 1
a1270 1
    use MLSHDF5, only: IsHDF5AttributePresent, GetHDF5Attribute
a1321 1
  ! subroutine ReadL1BAttribute_dblarr1 ( L1FileHandle, value, AttrName, Flag, &
d1324 1
a1324 1
    use MLSHDF5, only: IsHDF5AttributePresent, GetHDF5Attribute
d1558 1
a1558 1
  use PCFHdr, only: GlobalAttributes
d1932 2
a1933 2
    use MLSHDF5, only: IsHDF5DSPresent, LoadFromHDF5DS, &
      & GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType
d2276 1
a2276 1
  use PCFHdr, only: GlobalAttributes
d2660 2
a2661 2
    use MLSHDF5, only: IsHDF5DSPresent, LoadFromHDF5DS, &
      & GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType
d3300 1
a3300 1
       "$Id: L1BData.f90,v 2.88 2010/03/12 21:12:07 pwagner Exp $"
d3309 3
@


2.88
log
@Note when diffing if integer arrays are equal
@
text
@d787 1
a787 1
  subroutine DumpL1BData ( l1bData, details )
d795 1
d838 1
a838 1
        & fillValue = int(undefinedValue) )
d845 1
a845 1
        & fillValue=undefinedValue*1.d0 )
d3280 1
a3280 1
       "$Id: L1BData.f90,v 2.87 2010/01/11 18:33:19 pwagner Exp $"
d3289 3
@


2.87
log
@Changed a comment
@
text
@d709 3
a711 1
        myNumDiffs = myNumDiffs + count(l1bData1%charField /= l1bData2%charField)
d3279 1
a3279 1
       "$Id: L1BData.f90,v 2.86 2009/10/30 23:03:50 pwagner Exp $"
d3288 3
@


2.86
log
@Commented-out more debugging lines
@
text
@d726 1
a726 1
        if ( DEBUG ) call output( 'Calling direct diff', advance='yes' )
d3277 1
a3277 1
       "$Id: L1BData.f90,v 2.85 2009/08/24 18:34:45 pwagner Exp $"
d3286 3
@


2.85
log
@Repaired syntax errors only NAG complained about
@
text
@d1585 3
a1587 3
        call outputNamedValue( 'noMAFs', noMAFs )
        call outputNamedValue( 'Flag', Flag )
        call output( 'returning now', advance='yes' )
d3277 1
a3277 1
       "$Id: L1BData.f90,v 2.84 2009/08/17 16:53:40 pwagner Exp $"
d3286 3
@


2.84
log
@May contract L1BData along any of its dimensions
@
text
@d571 1
a571 1
    if ( present(options) ) mySilent = index( options, 'h' )
d573 1
a573 1
    if ( present(options) ) myDirect = index( options, 'd' )
d3277 1
a3277 1
       "$Id: L1BData.f90,v 2.83 2009/08/04 20:43:18 pwagner Exp $"
d3286 3
@


2.83
log
@Replaced silent optional arg
@
text
@d402 2
a403 1
  subroutine ContractL1BData ( L1BDataIn, L1BDataOut, noMAFs, firstMAF, lastMAF )
d417 4
d432 4
a435 1
    if ( present(firstMAF) ) myFirstMAF = firstMAF
d453 4
d466 1
a466 1
    mafOffSet = firstMAF
d515 1
a515 1
    & details, options, numDiffs, mafStart, mafEnd )
d530 2
d533 1
a533 1

d540 1
d572 2
d715 19
d745 1
a745 1
          call output('both dpField arrays all NaNs', advance='yes')
d747 1
a747 1
          call output('l1bData1%dpField array all NaNs', advance='yes')
d749 12
a760 1
          call output('l1bData2%dpField array all NaNs', advance='yes')
d763 2
a764 2
          if ( DEBUG ) call output( 'Calling diff', advance='yes' )
          call diff ( &
d1570 1
d1582 1
a1582 2
        ! print *, 'Warning: ', trim(QuantityName) // ' not found in l1b files'
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1584 4
a2108 7
      ! if ( sds1_id == -1 ) then
      !   flag = NOCOUNTERMAFID
      !   deallocate(dims, maxdims)
      !   if ( MyNeverFail ) return
      !   call MLSMessage ( MLSMSG_Error, ModuleName, &
      !   & 'Failed to find identifier of counterMAF data set.')
      ! end if
d2296 1
d2308 1
a2308 2
        ! print *, 'Warning: ', trim(QuantityName) // ' not found in l1b files'
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2311 1
a2829 7
      ! if ( sds1_id == -1 ) then
      !   flag = NOCOUNTERMAFID
      !   deallocate(dims, maxdims)
      !   if ( MyNeverFail ) return
      !   call MLSMessage ( MLSMSG_Error, ModuleName, &
      !   & 'Failed to find identifier of counterMAF data set.')
      ! end if
d3113 1
d3120 6
a3125 2
        l1BDataOut%charField(:,:,nOut:nOut+nn) = &
        & l1BDataIn%charField(:,:,nIn:nIn+nn)
d3129 6
a3134 2
        l1BDataOut%intField(:,:,nOut:nOut+nn) = &
        & l1BDataIn%intField(:,:,nIn:nIn+nn)
d3153 6
a3158 2
        l1BDataOut%dpField(:,:,nOut:nOut+nn) = &
        & l1BDataIn%dpField(:,:,nIn:nIn+nn)
d3277 1
a3277 1
       "$Id: L1BData.f90,v 2.82 2009/06/23 18:25:42 pwagner Exp $"
d3286 3
@


2.82
log
@Prevent Intel from optimizing ident string away
@
text
@d93 1
a93 1
!   [char options], [log silent], [int numDiffs], [int mafStart], [int mafEnd])
d117 1
a117 1
       "$RCSfile: $"
d503 1
a503 1
    & details, options, silent, numDiffs, mafStart, mafEnd )
d515 1
a515 1
    logical, intent(in), optional :: silent  ! don't print anything
d556 1
a556 1
    if ( present(silent) ) mySilent = silent
d3226 1
a3226 1
       "$Id: read_apriori.f90 is it here $"
d3235 3
@


2.81
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d117 1
a117 1
       "$RCSfile: L1BData.f90,v $"
d3223 1
a3224 1
!---------------------------- RCS Ident Info -------------------------------
d3226 2
a3227 3
       "$Id: L1BData.f90,v 2.80 2008/06/06 22:52:21 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d3229 1
d3231 1
d3235 3
@


2.80
log
@EssentiallyEqual moved to MLSFillValues
@
text
@d33 1
a33 1
  use MLSStrings, only: streq
d68 1
d92 2
d503 1
a503 1
    & details, stats, rms, silent, numDiffs, mafStart, mafEnd )
d514 1
a514 2
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: RMS     ! if TRUE, just print mean, rms
d518 1
a518 1
    ! If either of stats or rms is present and TRUE, print much less
d536 3
a538 2
    if ( present(stats) ) hideAssocStatus = stats
    if ( present(rms) ) hideAssocStatus = hideAssocStatus .or. rms
d691 1
a691 1
          & 'l1bData%intField (diff)', stats=stats, rms=rms )
d721 1
a721 1
        & stats=stats, rms=rms )
d3226 1
a3226 1
       "$Id: L1BData.f90,v 2.79 2008/02/08 00:00:04 pwagner Exp $"
d3234 3
@


2.79
log
@Coded around another Intel compiler bug
@
text
@d501 1
a501 1
  use MLSNumerics, only: EssentiallyEqual
d3223 1
a3223 1
       "$Id: L1BData.f90,v 2.78 2008/02/07 18:48:16 pwagner Exp $"
d3231 3
@


2.78
log
@Prevent appearance of non-ascii when diffing char valued l1bdata
@
text
@d18 1
a18 1
  use Hdf, only: DFACC_RDONLY, DFACC_READ, SFSTART, SFGINFO, SFN2INDEX, SFSELECT, &
d28 1
a28 1
    & addFileToDatabase, InitializeMLSFile, MLS_HDF_VERSION, &
d30 1
a30 1
  use MLSMessageModule, only: MLSMSG_Allocate, MLSMSG_DeAllocate, MLSMSG_Error, &
d33 1
a33 1
  use MLSStrings, only: asciify, CompressString, isAllAscii, streq
a36 1
  use SDPToolkit, only: max_orbits
d296 1
d502 1
d519 1
d654 22
a675 6
        where ( .not. isAllAscii(l1bData1%CharField) )
          l1bData1%CharField = asciify( l1bData1%CharField, 'snip') 
        end where
        where ( .not. isAllAscii(l1bData2%CharField) )
          l1bData2%CharField = asciify( l1bData2%CharField, 'snip') 
        end where
d822 1
a822 1
    use HDF5, only: h5dclose_f, h5dopen_f, h5gclose_f, h5gopen_f
a1164 1
    integer :: STATUS                   ! Flag
a1387 1
    integer :: maxMAF
d1874 1
a1874 1
    integer, dimension(:), pointer :: cm_array
d2608 1
a2608 1
    integer, dimension(:), pointer :: cm_array
d3223 1
a3223 1
       "$Id: L1BData.f90,v 2.77 2008/01/07 21:37:05 pwagner Exp $"
d3231 3
@


2.77
log
@Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
@
text
@d33 1
a33 1
  use MLSStrings, only: CompressString, streq
d651 7
a659 1
        myNumDiffs = myNumDiffs + count(l1bData1%charField /= l1bData2%charField)
d3207 1
a3207 1
       "$Id: L1BData.f90,v 2.76 2007/08/13 17:36:13 pwagner Exp $"
d3215 3
@


2.76
log
@Push some procedures onto new MLSCallStack
@
text
@d26 1
a26 1
    & R4, R8, DEFAULTUNDEFINEDVALUE, FILENAMELEN
d141 1
a141 2
  ! The following should be same as l2/Fill
  real, parameter ::    UNDEFINED_VALUE = DEFAULTUNDEFINEDVALUE ! -999.99 
d262 1
a262 1
    l1bData%counterMAF = int(DEFAULTUNDEFINEDVALUE)
d273 1
a273 1
      l1bData%intField = int(DEFAULTUNDEFINEDVALUE)
d277 1
a277 1
      l1bData%dpField = DEFAULTUNDEFINEDVALUE
d688 1
a688 1
        & FillValue=REAL(DEFAULTUNDEFINEDVALUE, R8)) ) then
d693 1
a693 1
        & FillValue=REAL(DEFAULTUNDEFINEDVALUE, R8), &
d761 1
a761 1
        & fillValue = int(DEFAULTUNDEFINEDVALUE) )
d768 1
a768 1
        & fillValue=DEFAULTUNDEFINEDVALUE*1.d0 )
d1329 1
a1329 1
    call zeroField(l1bdataOut, 1, DEFAULTUNDEFINEDVALUE, m=NoMAFs)
d1433 1
a1433 1
          call zeroField(l1bdataOut, indexOut+i, DEFAULTUNDEFINEDVALUE)
d1435 1
a1435 1
            & call zeroField(PrecisionOut, indexOut+i, DEFAULTUNDEFINEDVALUE)
d1453 1
a1453 1
      call zeroField(l1bdataOut, indexOut+i, DEFAULTUNDEFINEDVALUE)
d1455 1
a1455 1
        & call zeroField(PrecisionOut, indexOut+i, DEFAULTUNDEFINEDVALUE)
d3201 1
a3201 1
       "$Id: L1BData.f90,v 2.75 2007/07/17 00:25:50 pwagner Exp $"
d3209 3
@


2.75
log
@Deal more gracefully with attempt to read rank 0 datasets
@
text
@d30 3
a32 2
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ALLOCATE, MLSMSG_ERROR, &
    & MLSMSG_WARNING, MLSMSG_L1BREAD, MLSMSG_WARNING, MLSMSG_DEALLOCATE
a820 1

d823 1
d877 1
d902 1
d909 1
d947 1
d974 1
d1879 1
d2178 1
d3202 1
a3202 1
       "$Id: L1BData.f90,v 2.74 2007/06/21 00:49:51 vsnyder Exp $"
d3210 3
@


2.74
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d196 2
a197 1
  integer, public, parameter :: CANTALLOCATECHARS =  CANTREADCOUNTERMAF + 1
d527 1
d552 4
d644 1
d677 4
d689 1
d691 2
a692 2
        & l1bData1%dpField(:,:,mafStart1:mafEnd1), 'l1bData%dpField', &
        & l1bData2%dpField(:,:,mafStart2:mafEnd2), 'l1bData%dpField', &
d1897 8
d3194 1
a3194 1
       "$Id: L1BData.f90,v 2.73 2007/02/07 20:56:38 pwagner Exp $"
d3202 3
@


2.73
log
@Avoid opening hdf5-type groups in hdf4 files
@
text
@d128 1
a128 1
	& ReadL1BAttribute_dblarr1
d1180 1
a1180 1
	    Flag = -1
d1182 1
a1182 1
	   call h5gOpen_f (L1BFile%FileID%f_id,'/', aID, status)
d1184 1
a1184 1
	    call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1186 4
a1189 4
	   Flag = -1
	   end if  
     	if ( .not. IsHDF5AttributePresent(aID, AttrName) ) then
     	  Flag = -1
d1192 1
a1192 1
	   else 
d1196 2
a1197 2
    	end if
	   call h5gClose_f (aID, status)
d1199 1
a1199 1
	       call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1201 1
a1201 1
	   end if 
d1233 3
a1235 3
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Not implemented in hdf4 l1boa file', MLSFile=L1bFile)
	    Flag = -1
d1237 1
a1237 1
	   call h5gOpen_f (L1BFile%FileID%f_id,'/', aID, status)
d1239 1
a1239 1
	    call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1241 4
a1244 4
	   Flag = -1
	   end if  
     	if ( .not. IsHDF5AttributePresent(aID, AttrName) ) then
     	  Flag = -1
d1247 1
a1247 1
	   else 
d1251 2
a1252 2
    	end if
	   call h5gClose_f (aID, status)
d1254 1
a1254 1
	       call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1256 1
a1256 1
	   end if 
d3174 1
a3174 1
       "$Id: L1BData.f90,v 2.72 2007/01/26 23:58:02 pwagner Exp $"
d3182 3
@


2.72
log
@Fixed bug affecting GetL1BFile
@
text
@d830 1
d834 2
d837 1
a837 1
          if ( index(myOptions, 'f') > 0 ) then
a852 1
        myHDFVersion = filedatabase(i)%HDFVersion
d3174 1
a3174 1
       "$Id: L1BData.f90,v 2.71 2006/11/22 18:12:37 pwagner Exp $"
d3182 3
@


2.71
log
@New optional args to diff l1b files with different number MAFs
@
text
@d35 1
a35 1
  use Output_M, only: Output, resumeOutput, suspendOutput
d780 4
d794 1
d810 1
d818 1
d820 1
d823 25
a847 26
        if ( .not. alreadyOpen ) then
          call mls_openFile(filedatabase(i), returnStatus)
          ! print *, 'Oops--must open file?'
          if ( returnStatus /= 0 ) &
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'unable to open L1BFile searching for ' // trim(fieldname), &
              & MLSFile=filedatabase(i) )
          ! Are we looking for an attribute?
          ! (Then we may need an object name)
          if ( index(myoptions, 'a') > 0 ) then
            ! What object would the attribute be attached to?
            if ( index(myOptions, 'f') > 0 ) then
              openedCode = 'f'
            elseif ( index(myOptions, '/') > 0 ) then
              call h5gopen_f ( filedatabase(i)%fileID%f_id, trim(myObject), &
                & filedatabase(i)%fileID%grp_id, returnStatus )
              openedCode = 'g'
            elseif ( index(myOptions, 's') > 0 ) then
              call h5dopen_f ( filedatabase(i)%fileID%f_id, trim(myObject), &
                & filedatabase(i)%fileID%sd_id, returnStatus )
              openedCode = 's'
            else
              call h5dopen_f ( filedatabase(i)%fileID%f_id, trim(myObject), &
                & filedatabase(i)%fileID%sd_id, returnStatus )
              openedCode = 's'
            endif
d880 1
a880 2
          ! call dump(filedatabase(i), details=1)
          ! print *, 'locID ', locID
d892 1
d904 1
d3172 1
a3172 1
       "$Id: L1BData.f90,v 2.70 2006/04/11 23:13:29 pwagner Exp $"
d3180 3
@


2.70
log
@More room needed in dumping counterMAF array
@
text
@d499 1
a499 1
    & details, stats, rms, silent, numDiffs )
d513 1
d521 1
d533 14
d611 10
a620 1

d678 3
a680 2
          call diff ( l1bData1%dpField, 'l1bData%dpField', &
        & l1bData2%dpField, 'l1bData%dpField', &
d3164 1
a3164 1
       "$Id: L1BData.f90,v 2.69 2006/02/06 22:54:51 pwagner Exp $"
d3172 3
@


2.69
log
@Should print warnings, not bomb if l1b files not found
@
text
@d709 1
a709 1
      call dump ( l1bData%counterMAF, 'l1bData%counterMAF' )
d3138 1
a3138 1
       "$Id: L1BData.f90,v 2.68 2006/01/26 00:33:09 pwagner Exp $"
d3146 3
@


2.68
log
@demoted more use statements from module level to speed Lahey compiles
@
text
@d94 2
a95 2
! L1boaSetup (int root, L1BInfo_T L1BInfo, int f_file, [int hdfVersion])
! L1bradSetup (int root, L1BInfo_T L1BInfo, int f_file, [int hdfVersion])
a1029 1
  ! subroutine L1boaSetup ( root, l1bInfo, F_FILE, hdfVersion )
d1031 1
a1031 1
    ! Take file name from l2cf, open, and store unit no. in l1bInfo
a1034 1
    ! type (L1BInfo_T) :: L1BINFO         ! File handles etc. for L1B dataset
d1051 1
d1062 1
a1063 23
!         the_hdf_version = mls_hdf_version(FileName)
!         if ( the_hdf_Version == FILENOTFOUND ) &
!           call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & 'File not found; make sure the name and path are correct' &
!             & // trim(fileName) )
!         if ( present(hdfVersion) ) then
!           sd_id = mls_io_gen_openF('hg', .true., error, &
!             & record_length, DFACC_READ, &
!             & FileName, hdfVersion=the_hdf_version, debugOption=.false.)
!         else
!           sd_id = mls_io_gen_openF('hg', .true., error, &
!             & record_length, DFACC_READ, &
!             & FileName)
!         end if
!         if ( sd_id <= 0 ) then
!           call announce_error ( son, &
!             & 'Error opening L1BOA file: ' //Filename)
!         else
!           l1bInfo%L1BOAID = sd_id
!           l1bInfo%L1BOAFileName = Filename
!           if ( present(hdfVersion) ) hdfVersion = the_hdf_version
!         end if
           if ( present(hdfVersion) ) hdfVersion = L1BFile%HDFVersion
d1074 1
a1074 1
    ! Take file name from l2cf, open, and store unit no. in l1bInfo
d1094 1
d1106 1
a1107 1
           if ( present(hdfVersion) ) hdfVersion = L1BFile%HDFVersion
d3138 1
a3138 1
       "$Id: L1BData.f90,v 2.67 2006/01/04 20:31:18 pwagner Exp $"
d3146 3
@


2.67
log
@Diff procedures may keep silent, returning num of diffs only
@
text
@a31 1
  use MLSNumerics, only: EssentiallyEqual
a35 1
  use PCFHdr, only: GlobalAttributes
d500 1
d997 1
d1432 1
d2143 1
d3160 1
a3160 1
       "$Id: L1BData.f90,v 2.66 2005/11/18 01:25:16 pwagner Exp $"
d3168 3
@


2.66
log
@L1BData%charField no longer of unit length (hope this breaks nothing else)
@
text
@d36 1
a36 1
  use Output_M, only: Output
d500 2
a501 1
  subroutine DiffL1BData ( l1bData1, l1bData2, details, stats, rms )
d512 2
d521 2
d532 6
d541 1
d548 5
a553 1
    if ( myDetails < -1 ) return
d559 1
d566 1
d573 1
d580 1
d587 1
d594 1
d597 4
a600 1
    if ( myDetails < 0 ) return
d606 1
d613 4
a616 1
    if ( myDetails < 1 ) return
d622 1
d634 1
d658 1
a658 2
        ! & call dump ( l1bData1%dpField-l1bData2%dpField, &
        ! & 'l1bData%dpField (diff)', stats=stats, rms=rms )
d665 6
d3158 1
a3158 1
       "$Id: L1BData.f90,v 2.65 2005/11/17 20:10:44 pwagner Exp $"
d3166 3
@


2.65
log
@Can now read 2d and 3d integer-valued l1bdata; charaacter still fails
@
text
@d162 2
d178 2
a179 1
    character, dimension(:,:,:), pointer :: CharField => NULL()
a841 1
  ! integer function FindL1BData ( files, fieldName, hdfVersion )
a929 2
            ! call ReadL1BData ( files(i), fieldName, L1bData, noMAFs, status, &
            !   & dontPad=.true.)
a933 2
            ! call ReadL1BData ( files(i), fieldName, L1bData, noMAFs, status, &
            !   & dontPad=.true.)
d942 2
d2840 2
a2841 1
    character, dimension(:,:,:), pointer :: CharField => NULL()
d3122 1
a3122 1
       "$Id: L1BData.f90,v 2.64 2005/10/22 00:50:30 pwagner Exp $"
d3130 3
@


2.64
log
@Warns but continues if attributes sought in hdf4 file
@
text
@d1981 5
d2052 9
d2062 9
a2070 2
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--LoadFromHDF5DS not yet written for type integer(:,:,:).')
d2072 11
d2706 5
d2775 9
d2785 9
a2793 2
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--LoadFromHDF5DS not yet written for type integer(:,:,:).', MLSFile=L1BFile)
d2795 11
d3121 1
a3121 1
       "$Id: L1BData.f90,v 2.63 2005/10/19 20:47:29 pwagner Exp $"
d3129 3
@


2.63
log
@Fixed bug in GetL1BFile (do others remain?)
@
text
@d782 2
a783 2
          if ( index(myOptions, 'a') > 0 ) &
            call MLSMessage ( MLSMSG_Error, ModuleName, &
d785 3
a787 1
            if ( sfn2index(filedatabase(i)%FileID%f_id, trim(fieldName)) /= -1 ) then
d3057 1
a3057 1
       "$Id: L1BData.f90,v 2.62 2005/10/18 23:05:11 pwagner Exp $"
d3065 3
@


2.62
log
@Added GetL1BFile to get MLSFile with DS, attribute, or group name
@
text
@d717 1
d802 1
a802 1
              locID = filedatabase(i)%FileID%sd_id
d804 2
d807 2
d810 1
a810 1
            & locID, trim(fieldName), options ) &
d813 1
a813 2
            if ( .not. alreadyOpen ) &
              & call mls_closeFile(filedatabase(i), returnStatus)
d817 1
a817 9
        if ( .not. alreadyOpen ) then
          select case (openedCode)
          case ('s')
            call h5gclose_f ( filedatabase(i)%fileID%sd_id, returnStatus )
          case ('g')
            call h5gclose_f ( filedatabase(i)%fileID%grp_id, returnStatus )
          end select
          call mls_closeFile(filedatabase(i), returnStatus)
        end if
d820 14
d3055 1
a3055 1
       "$Id: L1BData.f90,v 2.61 2005/09/21 23:12:28 pwagner Exp $"
d3063 3
@


2.61
log
@Unnecessary changes
@
text
@d73 1
d94 2
a95 1
! int FindL1BData (int files(:), char filedName, [int hdfVersion]) 
d699 1
a699 1
  function GetL1BFile ( filedatabase, fieldName ) &
d701 17
d719 5
a723 5
  use MLSHDF5, only: IsHDF5DSPresent

    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    character (len=*), intent(in) :: fieldName ! Name of field
    type(MLSFile_T), pointer                 :: item
d732 1
d734 3
d741 5
d750 28
a777 4
        if ( .not. alreadyOpen ) &
          & call mls_openFile(filedatabase(i), returnStatus)
        if ( .not. alreadyOpen ) &
          & print *, 'Oops--must open file?'
d781 4
a784 1
          if ( sfn2index(filedatabase(i)%FileID%f_id, trim(fieldName)) /= -1 ) then
d791 16
a806 1
          if ( IsHDF5DSPresent(filedatabase(i)%FileID%f_id, trim(fieldName)) ) then
d813 9
a821 2
        if ( .not. alreadyOpen ) &
          & call mls_closeFile(filedatabase(i), returnStatus)
d3045 1
a3045 1
       "$Id: L1BData.f90,v 2.60 2005/08/05 20:36:29 pwagner Exp $"
d3053 3
@


2.60
log
@L1BFile arg to ReadL1BData now a pointer
@
text
@d72 1
d565 1
a565 1
      call output(L1bData1%FirstMAFCtr, advance='yes')
d2968 1
a2968 1
       "$Id: L1BData.f90,v 2.59 2005/07/21 23:36:28 pwagner Exp $"
d2976 3
@


2.59
log
@Simplified L1bradSetup
@
text
@a796 1
  ! integer function FindMaxMAF ( files, hdfVersion, minMAF )
d802 1
a802 1
    type(MLSFile_T), dimension(:), intent(in) :: files ! File handles
d814 1
d826 1
d836 1
a836 1
            call ReadL1BData ( files(i), fieldName, L1bData, noMAFs, status, &
d838 2
d844 3
a846 1
            call ReadL1BData ( files(i), fieldName, L1bData, noMAFs, status, &
d1986 1
a1986 1
    type(MLSFile_T)                :: L1BFile
d2005 4
d2089 1
a2089 1
    type(MLSFile_T)                :: L1BFile
d2372 1
a2372 1
    type(MLSFile_T)                :: L1BFile
d2967 1
a2967 1
       "$Id: L1BData.f90,v 2.58 2005/06/22 17:25:49 pwagner Exp $"
d2975 3
@


2.58
log
@Reworded Copyright statement, moved rcs id
@
text
@d94 1
a94 2
! L1bradSetup (int root, L1BInfo_T L1BInfo, int f_file, 
!               int MaxNumL1BRadIDs, int illegalL1BRadID, [int hdfVersion])
d113 1
a113 1
       "$RCSfile: $"
d964 2
a965 3
  ! subroutine L1bradSetup ( Root, L1bInfo, F_File, MaxNumL1BRadIDs, &
  subroutine L1bradSetup ( Root, filedatabase, F_File, MaxNumL1BRadIDs, &
    & illegalL1BRadID, hdfVersion )
a968 1
    ! type (L1BInfo_T) :: L1BINFO         ! File handles etc. for L1B dataset
a970 2
    integer, intent(in) :: MAXNUML1BRADIDS
    integer, intent(in) :: ILLEGALL1BRADID
a997 34
!         if ( .NOT. associated(l1bInfo%L1BRADIDs) ) then
!           allocate ( l1bInfo%L1BRADIDs(MAXNUML1BRADIDS), stat=status )
!           allocate ( l1bInfo%L1BRADFileNames(MAXNUML1BRADIDS), stat=status )
!           l1bInfo%L1BRADIDs = ILLEGALL1BRADID
!           if ( status /= 0 ) &
!             & call announce_error ( son, 'Allocation failed for l1bInfo' )
!         endif
!         the_hdf_version = mls_hdf_version(FileName)
!         if ( the_hdf_Version == FILENOTFOUND ) &
!           call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & 'File not found; make sure the name and path are correct' &
!             & // trim(fileName) )
! 
!         if ( present(hdfVersion) ) then
!           sd_id = mls_io_gen_openF('hg', .true., error, &
!             & record_length, DFACC_READ, &
!             & FileName, hdfVersion=the_hdf_version, debugOption=.false.)
!         else
!           sd_id = mls_io_gen_openF('hg', .true., error, &
!             & record_length, DFACC_READ, &
!             & FileName)
!         end if
!         if ( sd_id <= 0 ) then
!           call announce_error ( son, &
!             & 'Error opening L1BRAD file: ' //Filename)
!         else if ( ifl1 == MAXNUML1BRADIDS ) then
!           call announce_error ( son, "Cannot open any more L1BRAD files" )
!           exit
!         else
!           ifl1 = ifl1 + 1
!           l1bInfo%L1BRADIDs(ifl1) = sd_id
!           l1bInfo%L1BRADFileNames(ifl1) = Filename
!           if ( present(hdfVersion) ) hdfVersion = the_hdf_version
!         end if
d2958 1
a2958 1
       "$Id: $"
d2966 3
@


2.57
log
@Many changes to accommodate the new fields in MLSFile_T
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d112 1
a112 4
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
    "$Id: L1BData.f90,v 2.56 2005/06/01 17:29:06 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d114 3
a116 3
    "$RCSfile: L1BData.f90,v $"
  private not_used_here
  !---------------------------------------------------------------------------
d2995 5
d3005 3
@


2.56
log
@Disabled some superfluous printing
@
text
@d10 1
a10 1
  use Hdf, only: DFACC_READ, SFSTART, SFGINFO, SFN2INDEX, SFSELECT, &
d15 1
d106 1
a106 1
    "$Id: L1BData.f90,v 2.55 2005/05/31 17:50:20 pwagner Exp $"
d924 1
a924 1
          & type='hdf', access='rdonly', name=fileName)
d993 1
a993 1
          & type='hdf', access='rdonly', name=fileName)
d2995 3
@


2.55
log
@Began switch from passing file handles to passing MLSFiles
@
text
@d105 1
a105 1
    "$Id: L1BData.f90,v 2.54 2005/05/12 20:44:52 pwagner Exp $"
d770 1
a770 1
    print *, 'Looking for ', trim(fieldname)
d781 1
a781 1
        print *, 'Looking in ', trim(filedatabase(i)%name)
d784 1
a784 1
          print *, 'Eureka '
d1391 2
a1392 2
      print *, 'max(l1bdata) ', maxval(l1bdata%dpField(1,1,:))
      print *, 'min(l1bdata) ', minval(l1bdata%dpField(1,1,:))
d1396 2
a1397 2
      print *, 'max(l1bdatatmp) ', maxval(l1bdatatmp%dpField(1,1,:))
      print *, 'min(l1bdatatmp) ', minval(l1bdatatmp%dpField(1,1,:))
d2035 1
a2035 1
      print *, 'Oops--need to open l1b file before reading'
d2074 2
a2075 2
      print *, 'max(l1bdata) ', maxval(l1bdata%dpField(1,1,:))
      print *, 'min(l1bdata) ', minval(l1bdata%dpField(1,1,:))
d2079 2
a2080 2
      print *, 'max(l1bdatatmp) ', maxval(l1bdatatmp%dpField(1,1,:))
      print *, 'min(l1bdatatmp) ', minval(l1bdatatmp%dpField(1,1,:))
d2994 3
@


2.54
log
@Uses dump0_m/diff to do diff
@
text
@d6 1
a6 1
  ! Reading and interacting with Level 1B data (HDF4)
d16 2
a17 1
  use MLSCommon, only: R4, R8, L1BINFO_T, DEFAULTUNDEFINEDVALUE, FILENAMELEN
d19 2
a20 1
    & MLS_HDF_VERSION, MLS_IO_GEN_OPENF
d24 1
a24 1
  use MLSStrings, only: CompressString
d98 1
a98 1
    & DeallocateL1BData, DIFF, DUMP, &
d105 1
a105 1
    "$Id: L1BData.f90,v 2.53 2005/01/12 23:59:45 pwagner Exp $"
d125 5
d690 53
d744 2
a745 1
  integer function FindL1BData ( files, fieldName, hdfVersion )
d749 2
a750 1
    integer, dimension(:), intent(in) :: files ! File handles
d753 1
d770 8
a777 4
    do i = 1, size(files)
      if ( myhdfVersion == HDFVERSION_4 ) then
        if ( sfn2index(files(i),trim(fieldName)) /= -1 ) then
          findL1BData = files(i)
d781 4
a784 2
        if ( IsHDF5DSPresent(files(i),trim(fieldName)) ) then
          findL1BData = files(i)
d792 2
a793 1
  integer function FindMaxMAF ( files, hdfVersion, minMAF )
d798 1
a798 2
    integer, dimension(:), intent(in) :: files ! File handles
    integer, optional, intent(in) :: hdfVersion
d805 1
a815 5
    if ( present(hdfVersion) ) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L1BDEFAULT_HDFVERSION
    end if
d821 18
a838 5
      if ( myhdfVersion == HDFVERSION_4 ) then
        haveCtrMAF = sfn2index(files(i),trim(fieldName)) /= -1
        if ( haveCtrMAF ) then
          call ReadL1BData ( files(i), fieldName, L1bData, noMAFs, status, &
            & hdfVersion=HDFVERSION_4, dontPad=.true.)
a839 2
      else
        haveCtrMAF = IsHDF5DSPresent(files(i),trim(fieldName))
d841 11
a851 12
          call ReadL1BData ( files(i), fieldName, L1bData, noMAFs, status, &
            & hdfVersion=HDFVERSION_5, dontPad=.true.)
        end if
      end if
      if ( haveCtrMAF ) then
        FindMaxMAF = max(FindMaxMAF, maxval(l1bData%counterMAF))
        myMinMAF = min(myMinMAF, myminval(l1bData%counterMAF))
        if ( DEEBug ) print *, 'counterMAF ', l1bData%counterMAF
        call deallocatel1bdata(L1bData)
      else
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Failed to find '//trim(fieldName)//' in l1b files while FindMaxMAF')
d894 2
a895 1
  subroutine L1boaSetup ( root, l1bInfo, F_FILE, hdfVersion )
d899 2
a900 1
    type (L1BInfo_T) :: L1BINFO         ! File handles etc. for L1B dataset
d910 2
a911 1
    integer :: record_length
d913 1
a913 2
    integer :: SD_ID                    ! From HDF
    integer :: the_hdf_version
d922 29
a950 22
        the_hdf_version = mls_hdf_version(FileName)
        if ( the_hdf_Version == FILENOTFOUND ) &
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'File not found; make sure the name and path are correct' &
            & // trim(fileName) )
        if ( present(hdfVersion) ) then
          sd_id = mls_io_gen_openF('hg', .true., error, &
            & record_length, DFACC_READ, &
            & FileName, hdfVersion=the_hdf_version, debugOption=.false.)
        else
          sd_id = mls_io_gen_openF('hg', .true., error, &
            & record_length, DFACC_READ, &
            & FileName)
        end if
        if ( sd_id <= 0 ) then
          call announce_error ( son, &
            & 'Error opening L1BOA file: ' //Filename)
        else
          l1bInfo%L1BOAID = sd_id
          l1bInfo%L1BOAFileName = Filename
          if ( present(hdfVersion) ) hdfVersion = the_hdf_version
        end if
d959 2
a960 1
  subroutine L1bradSetup ( Root, L1bInfo, F_File, MaxNumL1BRadIDs, &
d964 2
a965 1
    type (L1BInfo_T) :: L1BINFO         ! File handles etc. for L1B dataset
d976 2
a979 1
    integer :: SD_ID                    ! ID from HDF
d981 1
a981 2
    integer, save :: IFL1 = 0           ! num. of L1brad files opened so far
    integer :: record_length, the_hdf_version
d991 5
a995 6
        if ( .NOT. associated(l1bInfo%L1BRADIDs) ) then
          allocate ( l1bInfo%L1BRADIDs(MAXNUML1BRADIDS), stat=status )
          allocate ( l1bInfo%L1BRADFileNames(MAXNUML1BRADIDS), stat=status )
          l1bInfo%L1BRADIDs = ILLEGALL1BRADID
          if ( status /= 0 ) &
            & call announce_error ( son, 'Allocation failed for l1bInfo' )
d997 35
a1031 27
        the_hdf_version = mls_hdf_version(FileName)
        if ( the_hdf_Version == FILENOTFOUND ) &
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'File not found; make sure the name and path are correct' &
            & // trim(fileName) )

        if ( present(hdfVersion) ) then
          sd_id = mls_io_gen_openF('hg', .true., error, &
            & record_length, DFACC_READ, &
            & FileName, hdfVersion=the_hdf_version, debugOption=.false.)
        else
          sd_id = mls_io_gen_openF('hg', .true., error, &
            & record_length, DFACC_READ, &
            & FileName)
        end if
        if ( sd_id <= 0 ) then
          call announce_error ( son, &
            & 'Error opening L1BRAD file: ' //Filename)
        else if ( ifl1 == MAXNUML1BRADIDS ) then
          call announce_error ( son, "Cannot open any more L1BRAD files" )
          exit
        else
          ifl1 = ifl1 + 1
          l1bInfo%L1BRADIDs(ifl1) = sd_id
          l1bInfo%L1BRADFileNames(ifl1) = Filename
          if ( present(hdfVersion) ) hdfVersion = the_hdf_version
        end if
d1041 2
a1042 2
  subroutine ReadL1BAttribute_intarr1 ( L1FileHandle, value, AttrName, Flag, &
     & hdfVersion )
d1048 1
a1048 1
    integer, intent(in)            :: L1FileHandle ! From HDF
a1051 1
    integer, optional, intent(in) :: hdfVersion
d1056 1
a1056 1

d1058 4
a1061 5
    if ( present(hdfVersion) ) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L1BDEFAULT_HDFVERSION
    end if
d1067 1
a1067 1
        & 'Not implement in l1boa file')
d1070 6
a1075 6
	    call h5gOpen_f (L1FileHandle,'/', aID, status)
        if ( status /= 0 ) then
	      call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to open group attribute in l1boa file' )
	      Flag = -1
	    end if	
d1077 3
a1079 3
     	   Flag = -1
           call MLSMessage ( MLSMSG_Warning, ModuleName, &
             & 'Failed to find attribute in l1boa file'//AttrName)
d1081 3
a1083 3
           call output ('get attribute', advance='no')
           call output (AttrName, advance='yes')
           call GetHDF5Attribute(aID, AttrName, value)
d1086 4
a1089 4
        if ( status /= 0 ) then
	         call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to close group attribute in l1boa file' )
	     end if	
d1091 2
d1095 3
a1097 3
  !-------------------------------------ReadL1BAttribute_dbtarr1l---------
  subroutine ReadL1BAttribute_dblarr1 ( L1FileHandle, value, AttrName, Flag, &
     & hdfVersion )
d1103 1
a1103 1
    integer, intent(in)            :: L1FileHandle ! From HDF
d1105 1
a1105 1
    character(len=*), intent(in) :: AttrName   ! attribute name to retrieve
a1106 1
    integer, optional, intent(in) :: hdfVersion
d1111 1
a1111 1

d1113 4
a1116 5
    if ( present(hdfVersion) ) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L1BDEFAULT_HDFVERSION
    end if
d1122 2
a1123 2
        & 'Not implement in l1boa file')
	Flag = -1
d1125 4
a1128 4
	call h5gOpen_f (L1FileHandle,'/', aID, status)
        if ( status /= 0 ) then
	   call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to open group attribute in l1boa file' )
d1130 1
a1130 1
	end if	
d1132 7
a1138 7
     	   Flag = -1
           call MLSMessage ( MLSMSG_Warning, ModuleName, &
		& 'Failed to find attribute in l1boa file'//AttrName)
	else 
           call output ('get attribute', advance='no')
           call output (AttrName, advance='yes')
           call GetHDF5Attribute(aID, AttrName, value)
d1140 5
a1144 5
	call h5gClose_f (aID, status)
        if ( status /= 0 ) then
	   call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to close group attribute in l1boa file' )
	end if	
d1146 2
d1330 2
a1331 2
  !-------------------------------------------------  ReadL1BData  -----
  subroutine ReadL1BData ( L1FileHandle, QuantityName, L1bData, NoMAFs, Flag, &
d1366 1
a1366 1
      call ReadL1BData_hdf4 ( L1FileHandle, trim(QuantityName), L1bData, &
d1369 1
a1369 1
      call ReadL1BData_hdf5 ( L1FileHandle, trim(QuantityName), L1bData, &
d1420 1
a1420 1
  end subroutine ReadL1BData
d1422 2
a1423 2
  !--------------------------------------------  ReadL1BData_hdf4  -----
  subroutine ReadL1BData_hdf4 ( L1FileHandle, QuantityName, L1bData, &
d1697 1
a1697 1
  end subroutine ReadL1BData_hdf4
d1699 2
a1700 2
  !--------------------------------------------  ReadL1BData_hdf5  -----
  subroutine ReadL1BData_hdf5 ( L1FileHandle, QuantityName, L1bData, NoMAFs, &
d2006 1
a2006 1
  end subroutine ReadL1BData_hdf5
d2008 15
a2022 2
  ! -------------------------------------------  Reshape_For_HDF4  -----
  subroutine Reshape_For_HDF4 ( L1bData )
a2023 11
    ! Here's what we'll assume:
    ! If the true rank of l1bdata is 3 or 0, no need to reshape
    ! If it's 1 or 2 then one of the following apply
    !  hdfVERSION         rank 1       rank 2(a)     rank 2(b)   
    !      4               1 1 5         10 1 5       1 10 5   
    !      5               5 1 1         10 5 1       10 5 1   
    !   reorder            2 3 1         1  3 2       3  1 2   
    ! (depending on whether it's (a) or (b) methods that apply; 
    !   not sure which so we'll code for either; uh-oh, looking like it's (b))
    ! Arguments
    type(l1bdata_t), intent(inout) :: L1BDATA ! Result
d2025 15
a2039 21
    character, dimension(:,:,:), pointer :: CharField => NULL()
    real(r8),  dimension(:,:,:), pointer :: DpField => NULL()
    integer,   dimension(:,:,:), pointer :: IntField => NULL()
    integer, dimension(3)                :: old_shape    
    integer, dimension(3)                :: new_shape
    integer, dimension(3)                :: new_order
    integer, dimension(3, 3), parameter  :: reorder = &
      & reshape( &
      & source = (/ 2, 3, 1, 1, 3, 2, 1, 2, 3 /), &
      & shape = (/ 3, 3 /) &
      & )
!     & source = (/ 2, 3, 1, 1, 3, 2, 3, 1, 2 /), &  ! This transposed desired
    integer                              :: status   ! result (don't know why)
    logical, parameter           :: DEEBUG = .FALSE.
    character(len=1), parameter  :: method = 'b'
    integer                      :: mord
    
    ! Executable
    if ( DEEBUG ) then
      print *, 'l1b data_type: ', trim(l1bData%data_type)
      print *, 'rank: ', l1bData%TrueRank
d2041 9
a2049 5
    if ( l1bData%TrueRank > 2 .or. l1bData%TrueRank < 1 ) return
    new_shape = 1
    if ( method == 'a' .or. l1bData%TrueRank == 1 ) then
      new_order = reorder(:,l1bData%TrueRank)
      mord = 1
d2051 15
a2065 55
      new_order = reorder(:,l1bData%TrueRank+1)
      mord = 2
    end if
    if ( DEEBUG ) then
      print *, 'new_order: ', new_order
      print *, 'mord: ', mord
      print *, '     o l d   f o r m'
      call DumpL1BData(l1bData)
    end if
    select case (l1bData%data_type)
    case('character')
      if ( .not. associated(l1bData%CharField) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 found ' // trim(l1bData%data_type) // &
        & 'unassociated')
      old_shape = shape(l1bData%CharField)
      new_shape(3) = old_shape(l1bData%TrueRank)
      if ( l1bData%TrueRank == 2 ) new_shape(mord) = old_shape(1)
      allocate(CharField(new_shape(1), new_shape(2), new_shape(3)), stat=status)
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not allocate ' // &
        & trim(l1bData%data_type))
      CharField = reshape(source=l1bData%CharField, &
        & shape=new_shape, order=new_order)
      deallocate(l1bData%CharField, stat=status)
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not deallocate ' // &
        & trim(l1bData%data_type))
      l1bData%CharField => CharField
    case('double')
      if ( .not. associated(l1bData%DpField) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 found ' // trim(l1bData%data_type) // &
        & 'unassociated')
      old_shape = shape(l1bData%DpField)
      new_shape(3) = old_shape(l1bData%TrueRank)
      if ( l1bData%TrueRank == 2 ) new_shape(mord) = old_shape(1)
      allocate(DpField(new_shape(1), new_shape(2), new_shape(3)), stat=status)
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not allocate ' // &
        & trim(l1bData%data_type))
      DpField = reshape(source=l1bData%DpField, &
        & shape=new_shape, order=new_order)
      deallocate(l1bData%DpField, stat=status)
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not deallocate ' // &
        & trim(l1bData%data_type))
      l1bData%DpField => DpField
      if ( DEEBUG ) then
        print *, 'old_shape: ', old_shape
        print *, 'new_shape: ', new_shape
d2067 756
a2822 29
    case('integer')
      if ( .not. associated(l1bData%IntField) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 found ' // trim(l1bData%data_type) // &
        & 'unassociated')
      old_shape = shape(l1bData%IntField)
      new_shape(3) = old_shape(l1bData%TrueRank)
      if ( l1bData%TrueRank == 2 ) new_shape(mord) = old_shape(1)
      allocate(IntField(new_shape(1), new_shape(2), new_shape(3)), stat=status)
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not allocate ' // &
        & trim(l1bData%data_type))
      IntField = reshape(source=l1bData%IntField, &
        & shape=new_shape, order=new_order)
      deallocate(l1bData%IntField, stat=status)
      if ( status /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 could not deallocate ' // &
        & trim(l1bData%data_type))
      l1bData%IntField => IntField
    case default 
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Sorry--reshape_for_hdf4 has encountered an unknown data type: ' &
        & // trim(l1bData%data_type))
    end select
    if ( DEEBUG ) then
      print *, '     n e w   f o r m'
      call DumpL1BData(l1bData)
d2994 3
@


2.53
log
@diff accepts options to print only stats, rms
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d9 1
a9 1
  use Dump_0, only: DUMP
d14 1
d21 1
d103 1
a103 1
    "$Id: L1BData.f90,v 2.52 2004/12/21 22:05:14 pwagner Exp $"
d497 2
d594 18
a611 3
      if ( any(l1bData1%dpField /= l1bData2%dpField) ) &
        & call dump ( l1bData1%dpField-l1bData2%dpField, &
        & 'l1bData%dpField (diff)', stats=stats, rms=rms )
d776 1
a776 1
        & 'Failed to find '//trim(fieldName)//' in l1b files')
d977 1
a977 1
	Flag = -1
d979 1
a979 1
	call h5gOpen_f (L1FileHandle,'/', aID, status)
d981 1
a981 1
	   call MLSMessage ( MLSMSG_Warning, ModuleName, &
d983 2
a984 2
	   Flag = -1
	end if	
d988 2
a989 2
		& 'Failed to find attribute in l1boa file'//AttrName)
	else 
d994 1
a994 1
	call h5gClose_f (aID, status)
d996 1
a996 1
	   call MLSMessage ( MLSMSG_Warning, ModuleName, &
d998 1
a998 1
	end if	
d1289 1
d2214 3
@


2.52
log
@Removed clunky temparray introduced to bypass memory issue
@
text
@d101 1
a101 1
    "$Id: L1BData.f90,v 2.51 2004/12/14 21:37:11 pwagner Exp $"
d480 2
a481 2
  subroutine DiffL1BData ( l1bData1, l1bData2, details )
    ! Diiff two l1brad quantities
d489 3
d494 1
d496 2
a497 1

d501 4
d561 2
a562 1
      call output('(CounterMAF arrays not associated)', advance='yes')
d573 2
a574 1
      call output('(CharField arrays not associated)', advance='yes')
d581 1
a581 1
          & 'l1bData%intField (diff)' )
d584 2
a585 1
      call output('(intField arrays not associated)', advance='yes')
d592 1
a592 1
        & 'l1bData%dpField (diff)' )
d594 2
a595 1
      call output('(dpField arrays not associated)', advance='yes')
d2194 3
@


2.51
log
@Some unnecessary debug printing and a temp array
@
text
@d101 1
a101 1
    "$Id: L1BData.f90,v 2.50 2004/08/26 22:34:41 pwagner Exp $"
d1594 1
a1594 1
    integer, parameter :: MAX_NOMAFS = 7000     ! Expect ~3500 in one day
d1760 5
a1764 4
        allocate(cm_array(MAX_NOMAFS), stat=status)
        call LoadFromHDF5DS(L1FileHandle, '/counterMAF', cm_array)
        l1bData%counterMaf = cm_array(1:cmdims(1))
        deallocate(cm_array)
d2181 3
@


2.50
log
@No time to repair overly ambitious PadL1BData; quick patch instituted instead
@
text
@d101 1
a101 1
    "$Id: L1BData.f90,v 2.49 2004/08/19 00:10:43 pwagner Exp $"
d1594 1
a1594 1
!   integer, parameter :: MAX_NOMAFS = 7000     ! Expect ~3500 in one day
d1596 1
d1626 1
d1683 1
d1707 1
d1723 1
d1725 1
d1727 1
d1729 1
d1733 1
d1756 8
a1763 1
        call LoadFromHDF5DS(L1FileHandle, '/counterMAF', l1bData%counterMaf)
d1765 1
d1767 7
a1773 7
      if ( sds1_id == -1 ) then
        flag = NOCOUNTERMAFID
        deallocate(dims, maxdims)
        if ( MyNeverFail ) return
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Failed to find identifier of counterMAF data set.')
      end if
d1776 1
d1778 1
d2180 3
@


2.49
log
@L2AUX option to ReadL1BData stops warning msgs about counterMAF
@
text
@d101 1
a101 1
    "$Id: L1BData.f90,v 2.48 2004/08/17 23:47:48 pwagner Exp $"
d1026 55
a1080 1
  subroutine PadL1BData ( L1BDataIn, L1BDataOut, FirstMAFCtr, NoMAFs, &
d1133 1
a1133 1
        & 'Padl1bData was passed l1bDataIn w/o allocating it' )
d1203 1
a1203 1
  end subroutine PadL1BData
d1280 6
a1285 1
    call PadL1BData(l1bdataTmp, l1bData, GlobalAttributes%FirstMAFCtr, NoMAFs)
d2161 3
@


2.48
log
@Another guard against inappripriate padding
@
text
@d101 1
a101 1
    "$Id: L1BData.f90,v 2.47 2004/08/16 17:04:23 pwagner Exp $"
d1153 1
a1153 1
    & FirstMAF, LastMAF, NEVERFAIL, hdfVersion, dontPad )
d1160 2
a1161 1
    logical, intent(in), optional  :: NEVERFAIL ! Don't call MLSMessage if TRUE
d1188 1
a1188 1
      & NoMAFs, Flag, FirstMAF, LastMAF, NEVERFAIL )
d1191 1
a1191 1
      & NoMAFs, Flag, FirstMAF, LastMAF, NEVERFAIL )
d1239 1
a1239 1
    & NoMAFs, Flag, FirstMAF, LastMAF, NEVERFAIL )
d1246 2
a1247 1
    logical, intent(in), optional  :: NEVERFAIL ! Don't call MLSMessage if TRUE
d1279 1
d1288 2
d1516 1
a1516 1
    & Flag, FirstMAF, LastMAF, NEVERFAIL )
d1527 2
a1528 1
    logical, intent(in), optional  :: NEVERFAIL ! Don't call MLSMessage if TRUE
d1559 1
d1570 2
d1651 1
a1651 1
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2102 3
@


2.47
log
@Pads L1bData after reading gappy data
@
text
@d101 1
a101 1
    "$Id: L1BData.f90,v 2.46 2004/08/04 23:19:01 pwagner Exp $"
d1205 2
a1206 1
    if ( myDontPad .or. flag /= 0 .or. isScalar ) return
d2093 3
@


2.46
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d24 1
d92 6
a97 3
  public :: L1BData_T, L1BRadSetup, L1BOASetup, DeallocateL1BData, DIFF, DUMP, &
    & FINDL1BDATA, NAME_LEN, PRECISIONSUFFIX, ReadL1BData, &
    & AssembleL1BQtyName, ReadL1BAttribute
d101 1
a101 1
    "$Id: L1BData.f90,v 2.45 2004/08/03 17:59:35 pwagner Exp $"
d141 2
a142 1
  ! Max number for Orbit Number and Orbit period
d149 3
a151 1
    integer :: FirstMAF                 ! First major frame read
d156 1
a156 1
    character (len=16) :: NameInst     
d163 1
d186 87
d379 88
d531 12
d604 3
a606 2
    call output(trim(L1bData%NameInst), advance='yes')
    call output('L1B rad quantity Name = ', advance='no')
d617 4
d637 2
a638 1
      call dump ( l1bData%intField, 'l1bData%intField' )
d644 2
a645 1
      call dump ( l1bData%dpField, 'l1bData%dpField' )
d690 96
d1025 126
d1153 1
a1153 1
    & FirstMAF, LastMAF, NEVERFAIL, hdfVersion )
d1164 2
a1165 1
    integer, optional, intent(in) :: hdfVersion
d1169 4
d1181 3
d1204 29
d1410 2
d1541 1
a1545 1
    ! integer, dimension(:), pointer :: COUNTERMAF_PTR
d1548 2
d1579 8
a1586 4
    if ( DEEBUG) print *, 'rank ', rank
    if ( DEEBUG) print *, 'maxDims ', maxDims
    if ( DEEBUG) print *, 'dims ', dims
    if ( DEEBUG) print *, 'Qtype ', Qtype
d1624 1
a1624 1
    if ( DEEBUG) print *, 'l1bData%noMAFs ', l1bData%noMAFs
d1628 1
a1628 1
    if ( DEEBUG)  print *, 'noMAFs ', noMAFs
d1634 1
a1634 1
    if ( .not. IsHDF5DSPresent(L1FileHandle, 'CounterMAF') ) then
d1641 2
d1650 3
a1652 1

d1656 1
a1656 1
        call LoadFromHDF5DS(L1FileHandle, 'CounterMAF', l1bData%counterMaf, &
d1658 19
d1678 1
a1678 1
        call LoadFromHDF5DS(L1FileHandle, 'CounterMAF', l1bData%counterMaf)
d1680 1
d1683 1
d1690 4
d1781 1
d1924 102
d2092 3
@


2.45
log
@Gets DEFAULTUNDEFINEDVALUE from MLSCommon
@
text
@d20 2
a21 1
  use MLSStrings, only: CompressString, NumStringElements
d97 1
a97 1
    "$Id: L1BData.f90,v 2.44 2004/03/12 00:36:33 pwagner Exp $"
d1491 3
@


2.44
log
@Added diff subroutine; hdf version default increased to 5
@
text
@d15 1
a15 1
  use MLSCommon, only: R4, R8, L1BINFO_T, FILENAMELEN
d96 1
a96 1
    "$Id: L1BData.f90,v 2.43 2003/09/12 16:37:10 cvuu Exp $"
d120 2
a121 1
  real, parameter ::    UNDEFINED_VALUE = -999.99 ! Same as l2/templates, Fill
d1490 3
@


2.43
log
@add subroutine to read L1BOA attributes
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
a13 1
  ! use HDF5, only: HSIZE_T
d90 1
a90 1
  public :: Dump, L1BData_T, L1BRadSetup, L1BOASetup, DeallocateL1BData, &
d96 1
a96 1
    "$Id: L1BData.f90,v 2.42 2003/05/07 01:05:57 vsnyder Exp $"
d103 4
d128 1
a128 1
  integer, parameter :: L1BDEFAULT_HDFVERSION = HDFVERSION_4
d177 1
a177 1
  !-------------------------------------------  DeallocateL1BData  -----
d294 96
a1071 1
! > >      type(MLSAuxData_T) :: MLSAuxData
d1259 11
d1279 4
a1282 1
        call MLSMessage ( MLSMSG_Error, ModuleName, &
a1284 1
      l1bdata%data_type = 'unknown'
d1489 3
@


2.42
log
@Remove three duplicated lines
@
text
@d24 1
d61 1
d85 2
d93 1
a93 1
    & AssembleL1BQtyName
d97 1
a97 1
    "$Id: L1BData.f90,v 2.41 2003/05/05 23:00:04 livesey Exp $"
d108 5
d132 2
d144 1
a146 1

d308 1
d516 110
d1378 3
@


2.41
log
@Merged in feb03 newfwm branch
@
text
@d93 1
a93 1
    "$Id$"
d96 1
a96 1
    "$RCSfile$"
a900 4
    l1bData%noAuxInds = product(dims(1:rank-2))
    l1bData%maxMIFs = 1
    if ( rank > 1 ) l1bData%maxMIFs = dims(rank-1)

d1255 4
a1258 1
! $Log$
@


2.40
log
@Checks for FILENOTFOUND
@
text
@d93 1
a93 1
    "$Id: L1BData.f90,v 2.39 2003/04/02 00:38:09 pwagner Exp $"
d96 1
a96 1
    "$RCSfile: L1BData.f90,v $"
d141 1
a141 1

d199 1
a199 1
    endif
d209 1
a209 1
      endif
d211 1
a211 1
    endif
d214 1
a214 1
    elseif ( is_a_signal .or. hdfVersion /= HDFVERSION_5 ) then
d224 1
a224 1
      elseif ( name(1:4) == 'GHz.' ) then
d227 1
a227 1
      elseif ( name(1:4) == 'THz.' ) then
d233 1
a233 1
      endif
d237 1
a237 1
      elseif ( the_rest(1:2) /= 'tp' ) then
d240 1
a240 1
      elseif (DROPTPSUBGROUP) then
d247 1
a247 1
      endif
d251 1
a251 1
      endif
d253 1
a253 1
    endif
d255 1
a255 1
      if ( DROPTPSUBGROUP .and. hdfVersion == HDFVERSION_5) then
d259 2
a260 2
      endif
    endif
d265 1
a265 1
    endif                                         
d297 2
a299 2
    call output('L1B rad quantity Name = ', advance='no')
    call output(L1bData%L1BName, advance='yes')
d311 1
a311 2
      call dump ( l1bData%counterMAF,&
      & 'l1bData%counterMAF' )
d313 2
a314 2
      call output('(CounterMAF array unassociated)', advance='yes')
    endif
d318 1
a318 2
      call dump ( l1bData%CharField,&
      & 'l1bData%CharField' )
d320 2
a321 2
      call output('(CharField array unassociated)', advance='yes')
    endif
d324 1
a324 2
      call dump ( l1bData%intField,&
      & 'l1bData%intField' )
d326 2
a327 2
      call output('(intField array unassociated)', advance='yes')
    endif
d330 1
a330 2
      call dump ( l1bData%dpField,&
      & 'l1bData%dpField' )
d332 2
a333 2
      call output('(dpField array unassociated)', advance='yes')
    endif
d336 1
a336 1
  ! -------------------------------------------------  FindL1BData  ----
d353 1
a353 1
    if (present(hdfVersion)) then
d357 1
a357 1
    endif
d400 1
a400 1
      if(get_field_id(son) == f_file) then
d415 1
a415 1
        endif
d427 1
a427 1
      endif
d460 1
a460 1
      if(get_field_id(son) == f_file) then
d462 1
a462 1
        if(.NOT. associated(l1bInfo%L1BRADIDs)) then
d474 1
d483 1
a483 1
        endif
d487 1
a487 1
        elseif(ifl1 == MAXNUML1BRADIDS) then
d499 1
a499 1
      endif
d523 1
a523 1
    if (present(hdfVersion)) then
d527 1
a527 1
    endif
d547 2
a548 2
      endif
    endif
d551 1
a551 1
  !-------------------------------------------------  ReadL1BData_hdf4  -----
d604 1
a604 1
    if ( sds_index == -1) then
d612 1
a612 1
      endif
d616 1
a616 1
      if ( sds1_id == -1) then
d621 2
a622 2
      endif
    endif
d625 1
a625 1
    if ( sds_index == -1) then
d634 1
a634 1
    if ( sds2_id == -1) then
d639 1
a639 1
    endif
d645 1
a645 1
    if ( status == -1) then
d650 1
a650 1
    endif
d681 1
a681 1
      endif
d693 1
a693 1
      endif
d718 1
a718 1
      endif
d723 2
a724 2
      enddo
    endif
d737 1
a737 1
      endif
d786 1
a786 1
    elseif ( status == -2 ) then
d791 1
a791 1
    endif
d822 1
a822 1
  !-------------------------------------------------  ReadL1BData_hdf5  -----
d825 3
a827 3
  use HDF5, only: HSIZE_T
  use MLSHDF5, only: IsHDF5DSPresent, LoadFromHDF5DS, &
    & GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType
d842 1
a842 2
    integer, parameter :: MAX_VAR_DIMS = 32
    integer, parameter :: MAX_NOMAFS = 7000     ! Expect ~3500 in one day
a848 1
    integer :: ALLOC_ERR
a849 1
    integer :: DATA_TYPE
a853 1
    integer :: N_ATTRS
a857 2
    integer :: SDS2_ID
    integer :: SDS_INDEX
a863 1
    real(r4), pointer, dimension(:,:,:) :: tmpR4Field
d889 1
a889 1
    allocate(dims(rank), maxDims(rank))
d901 4
d915 1
a915 1
      endif
d927 1
a927 1
      endif
d958 2
a959 2
        enddo
      endif
d969 2
a970 2
      endif
      if ( sds1_id == -1) then
d975 2
a976 2
      endif
    endif
d996 1
a996 1
      endif                                                                  
d1005 1
a1005 1
      endif                                                                  
d1023 1
a1023 1
      endif                                                                  
d1032 1
a1032 1
      endif                                                                  
d1063 2
a1064 2
  ! ---------------------------------------------  reshape_for_hdf4  -----
  subroutine reshape_for_hdf4(L1bData)
d1099 1
a1099 1
    endif
d1108 1
a1108 1
    endif
d1114 1
a1114 1
    endif
d1161 1
a1161 1
      endif
d1191 2
a1192 2
    endif
  end subroutine reshape_for_hdf4
d1194 2
a1195 2
  ! ---------------------------------------------  announce_error  -----
  subroutine announce_error ( lcf_where, full_message, use_toolkit, &
d1252 1
a1252 1
  end subroutine announce_error
d1259 4
a1262 1
! $Log: L1BData.f90,v $
d1271 3
@


2.39
log
@Cater for L1B quantities of rank > 3
@
text
@d17 1
a17 1
  use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
d93 1
a93 1
    "$Id: L1BData.f90,v 2.38 2003/03/10 17:27:10 pwagner Exp $"
d406 5
a410 1
        ! sd_id = sfstart(Filename, DFACC_READ)
a411 1
          the_hdf_version = mls_hdf_version(FileName)
d473 5
a477 1
        ! sd_id = sfstart(Filename, DFACC_READ)
a478 1
          the_hdf_version = mls_hdf_version(FileName)
d1266 3
@


2.38
log
@Fixed same bug aslast; is it really fixed this time?
@
text
@d93 1
a93 1
    "$Id: L1BData.f90,v 2.37 2003/03/07 00:35:15 pwagner Exp $"
d664 3
a666 13
    if ( rank < 2 ) then
      l1bData%maxMIFs = 1
    else if ( rank > 2 ) then
      l1bData%maxMIFs = dim_sizes(2)
    else
      l1bData%maxMIFs = dim_sizes(1)
    end if

    if ( rank > 2 ) then
      l1bData%noAuxInds = dim_sizes(1)
    else
      l1bData%noAuxInds = 1
    end if
d900 5
a942 16
    if ( rank < 2 ) then
      l1bData%maxMIFs = 1
    else if ( rank > 2 ) then
      l1bData%maxMIFs = dims(2)
    else
      l1bData%maxMIFs = dims(1)
    end if
    if ( DEEBUG) print *, 'l1bData%maxMIFs ', l1bData%maxMIFs

    if ( rank > 2 ) then
      l1bData%noAuxInds = dims(1)
    else
      l1bData%noAuxInds = 1
    end if


d1260 3
@


2.37
log
@Fixed bad bug in reading hdf5 files with FirstMAF > 1
@
text
@d93 1
a93 1
    "$Id: L1BData.f90,v 2.36 2003/02/12 21:49:06 pwagner Exp $"
d862 1
d878 1
a878 1
    logical, parameter           :: DEEBUG = .FALSE.
d881 3
a909 17
! > >     nullify(MLSAuxData%RealField, MLSAuxData%DpField, &
! > >       & MLSAuxData%IntField, MLSAuxData%CharField)
! > >     select case (trim(Qtype))
! > >     case ('real')
! > >       allocate( MLSAuxData%RealField(dims(1),dims(2),dims(3)),stat=status)
! > >       MLSAuxData%RealField = UNDEFINED_VALUE
! > >     case ('double')    
! > >       allocate( MLSAuxData%DpField(dims(1),dims(2),dims(3)),stat=status)
! > >       MLSAuxData%DpField = UNDEFINED_VALUE
! > >     case ('integer')  
! > >       allocate( MLSAuxData%IntField(dims(1),dims(2),dims(3)),stat=status)
! > >       MLSAuxData%IntField = int(UNDEFINED_VALUE)
! > >     case ('character') 
! > >       allocate( MLSAuxData%CharField(dims(1),dims(2),dims(3)),stat=status)
! > >       MLSAuxData%CharField = '(undefined)'
! > >     end select

d987 1
a987 2
          & (/FirstMAF-1/), (/l1bData%noMAFs/) )
          ! & (/0/), (/l1bData%noMAFs/) )
d999 3
a1001 6
!    print *, 'About to use Read_MLSAuxData to read ', trim(QuantityName)
!    call Read_MLSAuxData(L1FileHandle, QuantityName, 'unknown', & 
!      & MLSAuxData, error, FirstMAF, LastMAF, read_attributes=.false.)
    ! print *, 'About to use LoadFromHDF5DS to read ', trim(QuantityName)
    ! print *, 'dims ', dims
    ! print * 'noMAFs ', l1bData%noMAFs
d1003 6
d1014 1
a1014 2
          & (/FirstMAF-1/), (/l1bData%noMAFs/) )                                      
          ! & (/0/), (/l1bData%noMAFs/) )                                      
d1023 1
a1023 2
          & (/0,FirstMAF-1/), (/int(dims(1)),l1bData%noMAFs/) )                                      
          ! & (/0,0/), (/int(dims(1)),l1bData%noMAFs/) )                                      
d1032 1
a1032 2
          & (/0,0,FirstMAF-1/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
          ! & (/0,0,0/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
a1035 1
!      l1bData%DpField = MLSAuxData%RealField
d1041 1
a1041 2
          & (/FirstMAF-1/), (/l1bData%noMAFs/) )                                      
          ! & (/0/), (/l1bData%noMAFs/) )                                      
d1050 1
a1050 2
          & (/0,FirstMAF-1/), (/int(dims(1)),l1bData%noMAFs/) )                                      
          ! & (/0,0/), (/int(dims(1)),l1bData%noMAFs/) )                                      
d1059 1
a1059 2
          & (/0,0,FirstMAF-1/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
          ! & (/0,0,0/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
a1062 1
!      l1bData%DpField = MLSAuxData%DpField
a1064 8
! > >       allocate( l1bdata%IntField(dims(1),dims(2),l1bData%noMAFs),stat=status)
! > >       if ( present(FirstMAF) ) then                                          
! > >         call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField, &
! > >           & (/0,0,0/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
! > >       else                                                                   
! > >         call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%IntField)  
! > >       endif                                                                  
! > !      l1bdata%IntField = MLSAuxData%IntField
a1068 8
! > >       allocate ( l1bData%charField(dims(1),dims(2),dims(3)), STAT=alloc_err )
! > >       if ( present(FirstMAF) ) then                                          
! > >         call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%CharField, &
! > >           & (/0,0,0/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
! > >       else                                                                   
! > >         call LoadFromHDF5DS(L1FileHandle, QuantityName, l1bData%CharField)  
! > >       endif                                                                  
!      l1bData%charField = MLSAuxData%CharField
a1077 1
    ! print * 'datatype ', l1bdata%data_type
a1081 1
! > >      call Deallocate_MLSAuxData(MLSAuxData)
d1281 3
@


2.36
log
@Some small fixes; seems to work with latest hdf5-formats
@
text
@d93 1
a93 1
    "$Id: L1BData.f90,v 2.35 2002/12/11 22:22:15 pwagner Exp $"
d1000 2
a1001 1
          & (/0/), (/l1bData%noMAFs/) )
d1025 2
a1026 1
          & (/0/), (/l1bData%noMAFs/) )                                      
d1035 2
a1036 1
          & (/0,0/), (/int(dims(1)),l1bData%noMAFs/) )                                      
d1045 2
a1046 1
          & (/0,0,0/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
d1056 2
a1057 1
          & (/0/), (/l1bData%noMAFs/) )                                      
d1066 2
a1067 1
          & (/0,0/), (/int(dims(1)),l1bData%noMAFs/) )                                      
d1076 2
a1077 1
          & (/0,0,0/), (/int(dims(1)),int(dims(2)),l1bData%noMAFs/) )                                      
d1318 3
@


2.36.2.1
log
@Cater for L1B quantities of rank > 3, cosmetic changes
@
text
@d93 1
a93 1
    "$Id: L1BData.f90,v 2.36 2003/02/12 21:49:06 pwagner Exp $"
d199 1
a199 1
    end if
d209 1
a209 1
      end if
d211 1
a211 1
    end if
d214 1
a214 1
    else if ( is_a_signal .or. hdfVersion /= HDFVERSION_5 ) then
d224 1
a224 1
      else if ( name(1:4) == 'GHz.' ) then
d227 1
a227 1
      else if ( name(1:4) == 'THz.' ) then
d233 1
a233 1
      end if
d237 1
a237 1
      else if ( the_rest(1:2) /= 'tp' ) then
d240 1
a240 1
      else if ( DROPTPSUBGROUP ) then
d247 1
a247 1
      end if
d251 1
a251 1
      end if
d253 1
a253 1
    end if
d255 1
a255 1
      if ( DROPTPSUBGROUP .and. hdfVersion == HDFVERSION_5 ) then
d259 2
a260 2
      end if
    end if
d265 1
a265 1
    end if                                         
d297 1
d299 1
a299 2
    call output(trim(L1bData%L1BName), advance='yes')
    if ( myDetails < -1 ) return
d311 2
a312 1
      call dump ( l1bData%counterMAF, 'l1bData%counterMAF' )
d314 2
a315 2
      call output('(CounterMAF array not associated)', advance='yes')
    end if
d319 2
a320 1
      call dump ( l1bData%CharField, 'l1bData%CharField' )
d322 2
a323 2
      call output('(CharField array not associated)', advance='yes')
    end if
d326 2
a327 1
      call dump ( l1bData%intField, 'l1bData%intField' )
d329 2
a330 2
      call output('(intField array not associated)', advance='yes')
    end if
d333 2
a334 1
      call dump ( l1bData%dpField, 'l1bData%dpField' )
d336 2
a337 2
      call output('(dpField array not associated)', advance='yes')
    end if
d340 1
a340 1
  ! ------------------------------------------------  FindL1BData  -----
d357 1
a357 1
    if ( present(hdfVersion) ) then
d361 1
a361 1
    end if
d404 1
a404 1
      if ( get_field_id(son) == f_file ) then
d416 1
a416 1
        end if
d428 1
a428 1
      end if
d461 1
a461 1
      if ( get_field_id(son) == f_file ) then
d463 1
a463 1
        if ( .NOT. associated(l1bInfo%L1BRADIDs) ) then
d469 1
a469 1
        end if
d480 1
a480 1
        end if
d484 1
a484 1
        else if ( ifl1 == MAXNUML1BRADIDS ) then
d496 1
a496 1
      end if
d520 1
a520 1
    if ( present(hdfVersion) ) then
d524 1
a524 1
    end if
d544 2
a545 2
      end if
    end if
d548 1
a548 1
  !--------------------------------------------  ReadL1BData_hdf4  -----
d601 1
a601 1
    if ( sds_index == -1 ) then
d609 1
a609 1
      end if
d613 1
a613 1
      if ( sds1_id == -1 ) then
d618 2
a619 2
      end if
    end if
d622 1
a622 1
    if ( sds_index == -1 ) then
d631 1
a631 1
    if ( sds2_id == -1 ) then
d636 1
a636 1
    end if
d642 1
a642 1
    if ( status == -1 ) then
d647 1
a647 1
    end if
d664 13
a676 3
    l1bData%noAuxInds = product(dim_sizes(1:rank-2))
    l1bData%maxMIFs = 1
    if ( rank > 1 ) l1bData%maxMIFs = dim_sizes(rank-1)
d688 1
a688 1
      end if
d700 1
a700 1
      end if
d725 1
a725 1
      end if
d730 2
a731 2
      end do
    end if
d744 1
a744 1
      end if
d793 1
a793 1
    else if ( status == -2 ) then
d798 1
a798 1
    end if
d829 1
a829 1
  !--------------------------------------------  ReadL1BData_hdf5  -----
d832 3
a834 3
    use HDF5, only: HSIZE_T
    use MLSHDF5, only: IsHDF5DSPresent, LoadFromHDF5DS, &
      & GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType
d849 2
a850 1
!   integer, parameter :: MAX_NOMAFS = 7000     ! Expect ~3500 in one day
d857 1
d859 1
d863 1
d868 2
d876 1
d899 1
a899 1
    allocate ( dims(rank), maxDims(rank) )
a922 4
    l1bData%noAuxInds = product(dims(1:rank-2))
    l1bData%maxMIFs = 1
    if ( rank > 1 ) l1bData%maxMIFs = dims(rank-1)

d933 1
a933 1
      end if
d945 1
a945 1
      end if
d961 16
d992 2
a993 2
        end do
      end if
d1003 2
a1004 2
      end if
      if ( sds1_id == -1 ) then
d1009 2
a1010 2
      end if
    end if
d1027 1
a1027 1
      end if                                                                  
d1036 1
a1036 1
      end if                                                                  
d1045 1
a1045 1
      end if                                                                  
d1055 1
a1055 1
      end if                                                                  
d1064 1
a1064 1
      end if                                                                  
d1073 1
a1073 1
      end if                                                                  
d1083 1
a1083 1
! > >       end if                                                                  
d1095 1
a1095 1
! > >       end if                                                                  
d1114 2
a1115 2
  ! -------------------------------------------  Reshape_For_HDF4  -----
  subroutine Reshape_For_HDF4 ( L1bData )
d1150 1
a1150 1
    end if
d1159 1
a1159 1
    end if
d1165 1
a1165 1
    end if
d1212 1
a1212 1
      end if
d1242 2
a1243 2
    end if
  end subroutine Reshape_For_HDF4
d1245 2
a1246 2
  ! ---------------------------------------------  Announce_Error  -----
  subroutine Announce_Error ( lcf_where, full_message, use_toolkit, &
d1303 1
a1303 1
  end subroutine Announce_Error
a1310 3
! Revision 2.36  2003/02/12 21:49:06  pwagner
! Some small fixes; seems to work with latest hdf5-formats
!
@


2.35
log
@broadened error check on sd_id to any value lt 1
@
text
@d16 1
a16 1
  use MLSCommon, only: R4, R8, L1BINFO_T, FILENAMELEN, NameLen
d20 1
a20 1
    & MLSMSG_L1BREAD, MLSMSG_WARNING, MLSMSG_DEALLOCATE
d93 1
a93 1
    "$Id: L1BData.f90,v 2.34 2002/12/10 00:42:15 pwagner Exp $"
d164 2
a165 1
  function AssembleL1BQtyName ( name, hdfVersion, isTngtQty, InstrumentName ) &
d177 2
a178 1
    character(len=NameLen)       :: QtyName
d186 1
a186 1
    character(len=NameLen) :: the_rest
d188 1
d190 2
d262 1
a262 1
    QtyName = CompressString(QtyName)
d509 1
a509 1
    integer, intent(in), optional  :: LASTMAF ! Last to read (default last in file)
d525 1
d528 2
a529 2
      call ReadL1BData_hdf4 ( L1FileHandle, QuantityName, L1bData, NoMAFs, Flag, &
      & FirstMAF, LastMAF, NEVERFAIL )
d531 2
a532 2
      call ReadL1BData_hdf5 ( L1FileHandle, QuantityName, L1bData, NoMAFs, Flag, &
      & FirstMAF, LastMAF, NEVERFAIL )
d538 7
a544 1
      call Reshape_for_hdf4(L1bData)
d549 2
a550 2
  subroutine ReadL1BData_hdf4 ( L1FileHandle, QuantityName, L1bData, NoMAFs, Flag, &
    & FirstMAF, LastMAF, NEVERFAIL )
d830 2
a831 2
  subroutine ReadL1BData_hdf5 ( L1FileHandle, QuantityName, L1bData, NoMAFs, Flag, &
    & FirstMAF, LastMAF, NEVERFAIL )
d841 1
a841 1
    integer, intent(in), optional  :: LASTMAF ! Last to read (default last in file)
d888 1
d1017 1
a1017 1
    ! print *, 'noMAFs ', l1bData%noMAFs
d1106 1
d1311 3
@


2.34
log
@Stopped printing debugging stuff
@
text
@d93 1
a93 1
    "$Id: L1BData.f90,v 2.33 2002/12/06 01:10:08 pwagner Exp $"
d412 1
a412 1
        if ( sd_id == -1 .or. sd_id == -99 ) then
d476 1
a476 1
        if ( sd_id == -1 .or. sd_id == -99 ) then
d1297 3
@


2.33
log
@No longer transposes hdf5-formatted 2d arrays
@
text
@d93 1
a93 1
    "$Id: L1BData.f90,v 2.32 2002/12/05 19:43:47 pwagner Exp $"
d865 1
d883 1
a883 1
    print*, ' Find Qtype, rank and dimensions of QuantityName ', trim(QuantityName)
d889 4
a892 4
    print *, 'rank ', rank
    print *, 'maxDims ', maxDims
    print *, 'dims ', dims
    print *, 'Qtype ', Qtype
d942 1
a942 1
    print *, 'l1bData%noMAFs ', l1bData%noMAFs
d946 1
a946 1
    print *, 'noMAFs ', noMAFs
d955 1
a955 1
    print *, 'l1bData%maxMIFs ', l1bData%maxMIFs
d1002 3
a1004 3
    print *, 'About to use LoadFromHDF5DS to read ', trim(QuantityName)
    print *, 'dims ', dims
    print *, 'noMAFs ', l1bData%noMAFs
d1093 1
a1093 1
    call dump(l1bData, 0)
d1297 3
@


2.32
log
@Unsuccessful at reading hdf5 so far; speeds up compiling tree-walker, however
@
text
@d93 1
a93 1
    "$Id: L1BData.f90,v 2.31 2002/12/04 01:15:11 pwagner Exp $"
d1121 7
a1127 4
      & reshape( source = (/ 2, 3, 1, 1, 3, 2, 3, 1, 2 /), &
      & shape = (/ 3, 3 /) )
    integer                              :: status
    logical, parameter           :: DEEBUG = .TRUE.
d1145 6
d1224 4
d1296 3
@


2.31
log
@Many changes; closer to be able to read hdf5 successfully
@
text
@d14 1
a14 1
  use HDF5, only: HSIZE_T
a18 2
  use MLSHDF5, only: IsHDF5DSPresent, LoadFromHDF5DS, &
    & GetHDF5DSRank, GetHDF5DSDims, GetHDF5DSQType
d93 1
a93 1
    "$Id: L1BData.f90,v 2.30 2002/12/02 23:38:32 pwagner Exp $"
d127 1
d132 1
d177 1
d188 7
d244 3
d258 3
d337 3
d394 1
a394 1
    ! Exectuable code
d527 6
d650 1
d734 1
d743 1
d752 1
d761 1
d820 3
d884 1
d1014 1
d1023 1
d1033 1
d1042 1
d1051 1
d1061 1
d1073 1
d1085 1
d1090 1
d1099 118
a1219 1

d1283 3
@


2.30
log
@Should catch unknown data_type errors
@
text
@d95 1
a95 1
    "$Id: L1BData.f90,v 2.29 2002/11/22 21:48:54 pwagner Exp $"
d119 6
d227 3
d239 5
a243 1
      QtyName = trim(QtyName) // 'tp' // tp_tail
d815 1
d970 21
a990 2
    select case (trim(Qtype))
    case ('real')
d999 17
a1015 1
    case ('double')    
d1024 1
a1024 1
    case ('integer')  
d1035 1
a1035 1
    case ('character') 
d1048 2
a1049 1
        & 'Sorry--ReadL1BData_hdf5 has encountered an unknown data type')
d1125 3
@


2.29
log
@Commented out USE of MLSAUXData
@
text
@d50 1
d95 1
a95 1
    "$Id: L1BData.f90,v 2.28 2002/11/13 01:02:16 pwagner Exp $"
d150 2
a151 1
  integer, public, parameter :: CANTENDCOUNTERMAF =  CANTREAD3DFIELD + 1
d731 2
d740 5
d997 3
d1075 3
@


2.28
log
@Actually reads hdf5 radiances
@
text
@a15 1
  use MLSAuxData, only: MLSAuxData_T, Read_MLSAuxData, Deallocate_MLSAuxData
d94 1
a94 1
    "$Id: L1BData.f90,v 2.27 2002/10/29 18:50:03 pwagner Exp $"
d770 1
d1063 3
@


2.27
log
@Modified AssembleL1BQtyName to convert complete hdf4-style names to hdf5
@
text
@d95 1
a95 1
    "$Id: L1BData.f90,v 2.26 2002/10/10 23:50:57 pwagner Exp $"
d371 11
a381 5
        the_hdf_version = mls_hdf_version(FileName)
        sd_id = mls_io_gen_openF('hg', .true., error, &
          & record_length, DFACC_READ, &
          & FileName, hdfVersion=hdfVersion)
        if ( sd_id == -1 ) then
d435 11
a445 5
        the_hdf_version = mls_hdf_version(FileName)
        sd_id = mls_io_gen_openF('hg', .true., error, &
          & record_length, DFACC_READ, &
          & FileName, hdfVersion=hdfVersion)
        if ( sd_id == -1 ) then
d828 1
d833 4
d886 1
d889 19
d989 1
d1063 3
@


2.26
log
@Passed 1st tests to read l1bdata from hdf5
@
text
@d24 1
a24 1
  use MLSStrings, only: CompressString
d40 13
d95 1
a95 1
    "$Id: L1BData.f90,v 2.25 2002/10/09 00:05:02 pwagner Exp $"
d160 5
d166 1
a166 1
    integer, intent(in)          :: hdfVersion
d175 3
d179 1
d194 2
d197 2
d200 27
d1025 3
@


2.25
log
@Added trim function to fieldName
@
text
@d17 1
a17 1
  use MLSCommon, only: R4, R8, L1BINFO_T, FILENAMELEN
d24 1
d42 1
d61 2
d76 3
a78 2
  public :: L1BData_T, L1BRadSetup, L1BOASetup, ReadL1BData, DeallocateL1BData, &
    & FINDL1BDATA, NAME_LEN, PRECISIONSUFFIX, Dump
d82 1
a82 1
    "$Id: L1BData.f90,v 2.24 2002/10/07 23:21:20 pwagner Exp $"
d144 39
d730 1
a730 1
    type(MLSAuxData_T) :: MLSAuxData
d767 16
a782 16
    nullify(MLSAuxData%RealField, MLSAuxData%DpField, &
      & MLSAuxData%IntField, MLSAuxData%CharField)
    select case (trim(Qtype))
    case ('real')
      allocate( MLSAuxData%RealField(dims(1),dims(2),dims(3)),stat=status)
      MLSAuxData%RealField = UNDEFINED_VALUE
    case ('double')    
      allocate( MLSAuxData%DpField(dims(1),dims(2),dims(3)),stat=status)
      MLSAuxData%DpField = UNDEFINED_VALUE
    case ('integer')  
      allocate( MLSAuxData%IntField(dims(1),dims(2),dims(3)),stat=status)
      MLSAuxData%IntField = int(UNDEFINED_VALUE)
    case ('character') 
      allocate( MLSAuxData%CharField(dims(1),dims(2),dims(3)),stat=status)
      MLSAuxData%CharField = '(undefined)'
    end select
d839 6
a844 1
      call LoadFromHDF5DS(L1FileHandle, 'CounterMAF', l1bData%counterMaf)
d853 4
a856 2
    call Read_MLSAuxData(L1FileHandle, QuantityName, 'unknown', & 
      & MLSAuxData, error, FirstMAF, LastMAF, read_attributes=.false.)
d859 8
a866 2
      allocate( l1bData%DpField(dims(1),dims(2),dims(3)),stat=status)
      l1bData%DpField = MLSAuxData%RealField
d868 8
a875 2
      allocate( l1bData%DpField(dims(1),dims(2),dims(3)),stat=status)
      l1bData%DpField = MLSAuxData%DpField
d877 10
a886 2
      allocate( l1bdata%IntField(dims(1),dims(2),dims(3)),stat=status)
      l1bdata%IntField = MLSAuxData%IntField
d888 10
a897 2
      allocate ( l1bData%charField(dims(1),dims(2),dims(3)), STAT=alloc_err )
      l1bData%charField = MLSAuxData%CharField
d901 2
a902 1
    call Deallocate_MLSAuxData(MLSAuxData)
d972 3
@


2.24
log
@replaced undefined dim_sizes with dims
@
text
@d49 21
d77 1
a77 1
    "$Id: L1BData.f90,v 2.23 2002/10/05 00:09:16 pwagner Exp $"
d233 1
a233 1
        if ( sfn2index(files(i),fieldName) /= -1 ) then
d238 1
a238 1
        if ( IsHDF5DSPresent(files(i),fieldName) ) then
d892 3
@


2.23
log
@Finished hdf5 version of readl1bdata; untested however ..
@
text
@d56 1
a56 1
    "$Id: L1BData.f90,v 2.22 2002/10/03 23:04:11 pwagner Exp $"
d60 1
a663 1
    integer :: DIM_SIZES(MAX_VAR_DIMS)
d721 1
a721 1
    numMAFs = dim_sizes(rank)
d865 3
d871 3
@


2.22
log
@hdfVersion now inout instead of intent(in)
@
text
@d16 1
a16 1
  use MLSAuxData, only: MLSAuxData_T, Read_MLSAuxData
d56 1
a56 1
    "$Id: L1BData.f90,v 2.21 2002/09/27 23:37:54 pwagner Exp $"
d676 1
a676 1
    integer, dimension(:), pointer :: COUNTERMAF_PTR
a688 25
    ! Find data sets for counterMAF & quantity by name

    if ( .not. IsHDF5DSPresent(L1FileHandle, 'CounterMAF') ) then
      if ( .not. JUSTLIKEL2AUX ) then
        flag = NOCOUNTERMAFINDX
        if ( MyNeverFail ) return
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Failed to find index of counterMAF data set.')
      else
        sds1_id = SD_NO_COUNTERMAF
      endif
    else

      l1bData%L1BName = quantityName
      allocate(countermaf_ptr(MAX_NOMAFS))
      countermaf_ptr = 0
      call LoadFromHDF5DS(L1FileHandle, 'CounterMAF', countermaf_ptr)
      if ( sds1_id == -1) then
        flag = NOCOUNTERMAFID
        if ( MyNeverFail ) return
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Failed to find identifier of counterMAF data set.')
      endif
    endif

d702 2
d718 65
d785 17
d868 3
@


2.21
log
@More progress toward hdf5-capable l1b files
@
text
@d19 1
a19 1
    & MLS_IO_GEN_OPENF
d56 1
a56 1
    "$Id: L1BData.f90,v 2.20 2002/09/27 00:00:39 pwagner Exp $"
d232 1
a232 1
    integer, optional, intent(in) :: hdfVersion
d242 1
d252 1
d262 1
d281 1
a281 1
    integer, optional, intent(in) :: hdfVersion
d284 1
a284 1
    character(len=FileNameLen) :: FILENAME       ! Duh
d292 1
a292 1
    integer :: record_length
d310 1
d324 1
d809 3
@


2.20
log
@Began addings hdf5 functionality; incomplete
@
text
@d10 2
a11 1
  use Hdf, only: DFACC_READ, SFSTART, SFGINFO, SFN2INDEX, SFSELECT, SFRDATA_f90, &
d14 1
d20 2
a21 1
  use MLSHDF5, only: IsHDF5DSPresent, LoadFromHDF5DS
d31 1
d47 1
d56 1
a56 1
    "$Id: L1BData.f90,v 2.19 2002/07/23 23:16:06 pwagner Exp $"
d70 1
a70 1

d665 1
d672 2
a673 2
    integer, dimension(:), pointer :: START
    integer, dimension(:), pointer :: STRIDE
d716 20
d737 1
a737 1
       MLSAuxData, error, FirstMAF, LastMAF, read_attributes=.false.)
d804 3
@


2.19
log
@Added suggested cause of firstMAF error being bad chunk num
@
text
@d8 1
d14 1
d16 3
a18 1
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
d51 1
a51 1
    "$Id: L1BData.f90,v 2.18 2002/07/01 23:48:00 vsnyder Exp $"
d71 3
d184 1
a184 1
  integer function FindL1BData ( files, fieldName )
d187 1
d194 1
d197 6
d205 10
a214 3
      if ( sfn2index(files(i),fieldName) /= -1 ) then
        findL1BData = files(i)
        return
d220 1
a220 1
  subroutine L1boaSetup ( root, l1bInfo, F_FILE )
d227 1
d231 1
a231 1
    character(len=FileNameLen) :: FileName ! Duh
d234 1
d245 4
a248 1
        sd_id = sfstart(Filename, DFACC_READ)
d264 2
a265 1
  subroutine L1bradSetup ( Root, L1bInfo, F_File, MaxNumL1BRadIDs, illegalL1BRadID )
d273 1
d284 1
d286 1
a286 1
    ! Exectuable code
d301 4
a304 1
        sd_id = sfstart(Filename, DFACC_READ)
d326 34
d625 88
a712 1
  end subroutine ReadL1BData
d778 3
@


2.18
log
@Plug memory leaks, cosmetic changes
@
text
@d47 1
a47 1
    "$Id: L1BData.f90,v 2.17 2002/05/28 22:34:47 livesey Exp $"
d429 1
a429 1
        & input_err // 'firstMAF' )
d624 3
@


2.17
log
@Bug fix, wasn't properly allocating counterMAF in some circumstances.
@
text
@d8 1
a8 1
  use dump_0, only: DUMP
d22 1
a22 1
  implicit none
d47 1
a47 1
    "$Id: L1BData.f90,v 2.16 2002/01/09 23:42:23 pwagner Exp $"
d104 1
a104 1
  !---------------------------------------------------- DeallocateL1BData ----
a108 3
    ! Local variables
    integer :: DEALLOC_ERR              ! Flag

d110 4
a113 14
    if ( associated(l1bData%counterMAF) ) &
      call deallocate_test ( l1bData%counterMAF,&
      & 'l1bData%counterMAF', ModuleName )
    if ( associated(l1bData%charField) ) then
      deallocate ( l1bData%charField, STAT=dealloc_err )
      if ( dealloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'l1bData%charField' )
    end if
    if ( associated(l1bData%intField) ) &
      call deallocate_test ( l1bData%intField,&
      & 'l1bData%intField', ModuleName )
    if ( associated(l1bData%dpField) ) &
      call deallocate_test ( l1bData%dpField,&
      & 'l1bData%dpField', ModuleName )
d116 1
a116 1
  !---------------------------------------------------- DumpL1BData ----
d176 1
a176 1
  ! ------------------------------------------- FindL1BData ----
d197 1
a197 1
  !--------------------------------------------------- L1BOASetup --------------
d236 1
a236 1
  ! ------------------------------------------- L1BRadSetup ------------
d291 1
a291 1
  !---------------------------------------------------- ReadL1BData -------------
d301 1
a301 1
    type(l1bdata_t), intent(out)   :: L1BDATA ! Result
d334 2
d560 1
a560 1
  ! ------------------------------------------------  announce_error  -----
d624 3
@


2.16
log
@Replaced discouraged print statements with favored calls to output
@
text
@d47 1
a47 1
    "$Id: L1BData.f90,v 2.15 2001/11/01 21:02:31 pwagner Exp $"
d468 2
a470 2
      call Allocate_test ( l1bData%counterMaf, l1bData%noMAFs, &
        & 'counterMAF', ModuleName )
d635 3
@


2.15
log
@Willing to read l2aux files as if l1brad (untested); alphabetized procedures; added toc
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d47 1
a47 1
    "$Id: L1BData.f90,v 2.14 2001/10/26 23:11:10 pwagner Exp $"
d622 3
a624 2
      print*, '***Error in module ', ModuleName
      print*, trim(full_message)
d626 2
a627 1
        print*, 'error number ', error_number
d635 3
@


2.14
log
@Provides a single dump module interface
@
text
@d17 1
a17 1
  use MoreTree, only: Get_Boolean, Get_Field_ID
d24 16
d47 1
a47 1
    "$Id: L1BData.f90,v 2.13 2001/10/25 23:31:28 pwagner Exp $"
d62 5
d104 145
a303 40
  !--------------------------------------------------- L1BOASetup --------------
  subroutine L1boaSetup ( root, l1bInfo, F_FILE )
    ! Take file name from l2cf, open, and store unit no. in l1bInfo

    ! Dummy arguments
    type (L1BInfo_T) :: L1BINFO         ! File handles etc. for L1B dataset
    integer, intent(in) :: ROOT         ! of the l1brad file specification.
    integer, intent(in) :: F_FILE       ! From init_tables_module

    ! Local variables

    character(len=FileNameLen) :: FileName ! Duh

    integer :: I                        ! Loop inductor, subscript
    integer :: SON                      ! Some subtree of root.
    integer :: STATUS                   ! Flag
    integer :: SD_ID                    ! From HDF

    ! Exectuable code
    error = 0
    ! Collect data from the fields. (only one legal field: file='...')
    do i = 2, nsons(root)
      son = subtree(i,root)
      if(get_field_id(son) == f_file) then
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        sd_id = sfstart(Filename, DFACC_READ)
        if ( sd_id == -1 ) then
          call announce_error ( son, &
            & 'Error opening L1BOA file: ' //Filename)
        else
          l1bInfo%L1BOAID = sd_id
          l1bInfo%L1BOAFileName = Filename
        end if
      else
        call announce_error ( son, &
          & 'Unknown field specified in read l1boa' )
      endif
    end do
  end subroutine L1boaSetup

d321 1
d356 9
a364 5
      flag = NOCOUNTERMAFINDX
      if ( MyNeverFail ) return
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Failed to find index of counterMAF data set.')
    endif
d366 7
a372 6
    sds1_id = sfselect(L1FileHandle, sds_index)
    if ( sds1_id == -1) then
      flag = NOCOUNTERMAFID
      if ( MyNeverFail ) return
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Failed to find identifier of counterMAF data set.')
d468 16
a483 9
    call Allocate_test ( l1bData%counterMaf, l1bData%noMAFs, &
      & 'counterMAF', ModuleName )
    status = sfrdata_f90(sds1_id,  (/ l1bData%firstMAF /) , (/1/), &
      & (/l1bData%noMAFs/), l1bData%counterMAF )
    if ( status == -1 ) then
      flag = CANTREADCOUNTERMAF
      if ( MyNeverFail ) return
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_L1BRead // 'counterMAF.' )
d543 10
a552 7
    status = sfendacc(sds1_id)
    if ( status == -1 ) then
      flag = CANTENDCOUNTERMAF
      if ( MyNeverFail ) return
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Failed to terminate access to data sets.' )
      flag = -1
a570 107
  !---------------------------------------------------- DeallocateL1BData ----
  subroutine DeallocateL1BData ( l1bData )
    ! This should be called when an l1bData is finished with
    type( L1BData_T ), intent(inout) :: L1bData

    ! Local variables
    integer :: DEALLOC_ERR              ! Flag

    ! Executable code
    if ( associated(l1bData%counterMAF) ) &
      call deallocate_test ( l1bData%counterMAF,&
      & 'l1bData%counterMAF', ModuleName )
    if ( associated(l1bData%charField) ) then
      deallocate ( l1bData%charField, STAT=dealloc_err )
      if ( dealloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'l1bData%charField' )
    end if
    if ( associated(l1bData%intField) ) &
      call deallocate_test ( l1bData%intField,&
      & 'l1bData%intField', ModuleName )
    if ( associated(l1bData%dpField) ) &
      call deallocate_test ( l1bData%dpField,&
      & 'l1bData%dpField', ModuleName )
  end subroutine DeallocateL1BData

  !---------------------------------------------------- DumpL1BData ----
  subroutine DumpL1BData ( l1bData, details )
    ! Disclose pertinent, perhaps damning facts about an l1brad quantity
    type( L1BData_T ), intent(inout) :: L1bData
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even counterMAF
    !                                        ! -2 Skip all but name
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 1

    ! Local variables
    integer :: MYDETAILS

    ! Executable code
    myDetails = 1
    if ( present(details) ) myDetails = details
    
    if ( myDetails < -1 ) return
    call output('L1B rad quantity Name = ', advance='no')
    call output(L1bData%L1BName, advance='yes')
    call output('  First major frame read = ', advance='no')
    call output(L1bData%FirstMAF, advance='yes')
    call output('  Num of MAFs read = ', advance='no')
    call output(L1bData%NoMAFs, advance='yes')
    call output('  Max # of MIFs/MAF in SD array = ', advance='no')
    call output(L1bData%MaxMIFs, advance='yes')
    call output('  Num of auxilliary indices = ', advance='no')
    call output(L1bData%NoAuxInds, advance='yes')

    if ( myDetails < 0 ) return
    if ( associated(l1bData%counterMAF) ) then
      call dump ( l1bData%counterMAF,&
      & 'l1bData%counterMAF' )
    else
      call output('(CounterMAF array unassociated)', advance='yes')
    endif

    if ( myDetails < 1 ) return
    if ( associated(l1bData%charField) ) then
      call dump ( l1bData%CharField,&
      & 'l1bData%CharField' )
    else
      call output('(CharField array unassociated)', advance='yes')
    endif

    if ( associated(l1bData%intField) ) then
      call dump ( l1bData%intField,&
      & 'l1bData%intField' )
    else
      call output('(intField array unassociated)', advance='yes')
    endif

    if ( associated(l1bData%dpField) ) then
      call dump ( l1bData%dpField,&
      & 'l1bData%dpField' )
    else
      call output('(dpField array unassociated)', advance='yes')
    endif
  end subroutine DumpL1BData

  ! ------------------------------------------- FindL1BData ----
  integer function FindL1BData ( files, fieldName )
    integer, dimension(:), intent(in) :: files ! File handles
    character (len=*), intent(in) :: fieldName ! Name of field

    ! Externals
    integer, external :: SFN2INDEX

    ! Local variables
    integer :: i

    ! Executable code
    findL1BData=0
    do i = 1, size(files)
      if ( sfn2index(files(i),fieldName) /= -1 ) then
        findL1BData = files(i)
        return
      end if
    end do
  end function FindL1BData


d633 3
@


2.13
log
@Fixed dump; readl1bData takes neverfail option
@
text
@d27 1
a27 1
    & FINDL1BDATA, NAME_LEN, PRECISIONSUFFIX, DumpL1BData
d31 1
a31 1
    "$Id: L1BData.f90,v 2.12 2001/10/23 22:44:15 pwagner Exp $"
d37 4
d598 3
@


2.12
log
@Added DumpL1BData
@
text
@d23 1
d31 1
a31 1
    "$Id: L1BData.f90,v 2.11 2001/10/23 17:09:04 pwagner Exp $"
d60 15
d176 1
a176 1
    & FirstMAF, LastMAF )
d183 1
d200 1
d218 2
d224 4
a227 1
    if ( sds_index == -1) call MLSMessage ( MLSMSG_Error, ModuleName, &
d229 1
d232 4
a235 1
    if ( sds1_id == -1) call MLSMessage ( MLSMSG_Error, ModuleName, &
d237 1
d241 2
d249 4
a252 1
    if ( sds2_id == -1) call MLSMessage ( MLSMSG_Error, ModuleName, &
d254 1
d260 4
a263 1
    if ( status == -1) call MLSMessage ( MLSMSG_Error, ModuleName,&
d265 1
d300 4
a303 2
      if ( (firstMAF >= numMAFs) .or. (firstMAF < 0) ) &
        & call MLSMEssage ( MLSMSG_Error, ModuleName, &
d305 1
d312 4
a315 2
      if ( lastMAF < l1bData%firstMAF )  &
        & call MLSMEssage ( MLSMSG_Error, ModuleName, &
d317 1
d336 4
a339 1
    if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d341 1
d349 4
a352 2
      if ( alloc_err /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d354 1
d392 4
a395 1
    if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d397 1
d402 2
d411 2
d594 3
@


2.11
log
@Added PRECISIONSUFFIX as parameter
@
text
@d8 1
d26 1
a26 1
    & FINDL1BDATA, NAME_LEN, PRECISIONSUFFIX
d30 1
a30 1
    "$Id: L1BData.f90,v 2.10 2001/10/03 22:50:03 vsnyder Exp $"
d391 60
d535 3
@


2.10
log
@Add unfound-quantity name to an error message
@
text
@d25 1
a25 1
    & FINDL1BDATA, NAME_LEN
d29 1
a29 1
    "$Id: L1BData.f90,v 2.9 2001/06/01 02:06:45 livesey Exp $"
d37 2
d474 3
@


2.9
log
@Bug fix with counterMAF
@
text
@d29 1
a29 1
    "$Id: L1BData.f90,v 2.8 2001/05/30 23:51:48 livesey Exp $"
d178 1
a186 1
    integer :: DIM_SIZES(MAX_VAR_DIMS)
d209 5
a213 2
    if ( sds_index == -1) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Failed to find index of quantity data set.')
d472 3
@


2.8
log
@New version, uses new HDF, also cleaner
@
text
@d29 1
a29 1
    "$Id: L1BData.f90,v 2.7 2001/05/06 20:53:47 pwagner Exp $"
a223 1

d284 2
a285 2
    status = sfrdata_f90(sds1_id,  start , stride, &
      & edge, l1bData%counterMAF )
d469 3
@


2.7
log
@Allocates l1binfo%filenames along with ids
@
text
@a3 1
!===============================================================================
a4 1
!===============================================================================
d6 5
a10 1
  use Hdf, only: DFACC_READ, SFSTART
d12 4
a15 3
  use MLSCommon, only: R8, L1BInfo_T, FileNameLen
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Error, &
    & MLSMSG_L1Bread, MLSMSG_Warning
d19 2
a20 2
  use TREE, only: NSONS, &
    &             SUB_ROSA, SUBTREE, DUMP_TREE_NODE, SOURCE_REF
d22 1
a22 1
  public
d24 4
a27 1
!---------------------------- RCS Ident Info -------------------------------
d29 1
a29 1
       "$Id: L1BData.f90,v 2.6 2001/05/04 22:51:06 pwagner Exp $"
d32 2
a33 4
       "$RCSfile: L1BData.f90,v $"
!---------------------------------------------------------------------------

! Contents:
d35 2
a36 4
! Definition -- L1BData_T
! subroutines -- ReadL1BData
!                deallocateL1BData
!                FindL1BData
d38 1
a38 8
! Remarks:  This is a prototype module containing parameters, a derived type
!           definition, and a subroutine for reading the L1B data.

! Parameters

   integer, parameter :: NAME_LEN = 64		! Max len of SDS array name

! This data type is used to store quantities from an L1B data file.
d41 5
a45 5
    character (LEN=NAME_LEN) :: L1BName        ! Name of field in file
    integer :: FirstMAF                        ! First major frame read
    integer :: NoMAFs                          ! # of MAFs read
    integer :: MaxMIFs                 ! Max # of MIFs/MAF in SD array
    integer :: NoAuxInds                       ! # of auxilliary indices
d50 3
a52 3
    real(r8), dimension(:,:,:), pointer :: DpField => NULL()
    integer, dimension(:,:,:), pointer :: IntField => NULL()
		      ! dimensioned (noAuxInds,maxMIFs,noMAFs)
d55 3
a57 2
  private ::  announce_error
  integer, private :: Error            ! Error level -- 0 = OK
a58 1
contains
d60 6
a65 11
  subroutine L1bradSetup ( Root, L1bInfo, F_FILE, &
   & MAXNUML1BRADIDS, ILLEGALL1BRADID )
!------------------------------------------------------------------------------

! Brief description of subroutine
! Take file name from l2cf, open, and store unit no. in l1bInfo

! Arguments
    type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
    integer, intent(in) :: Root         ! of the l1brad file specification.
    !                                     Indexes a "spec_args" vertex.
d70 3
d74 3
a76 4
    character(len=FileNameLen) :: FileName      ! Duh
    integer :: Son                      ! Some subtree of root.
    integer :: status, sd_id
    integer, save :: ifl1=0             ! num. of L1brad files opened so far
d78 1
a78 1
    ! Error message codes
d80 1
a83 1

a84 1

a85 3
!      select case ( get_field_id(son) )

!      case ( f_file )
a86 1
      
d93 1
a93 1
          & call announce_error ( son, 'Allocation failed for l1bInfo' )
a106 2

!      case default
d108 2
a109 5
          call announce_error ( son, &
            & 'Unknown field specified in read l1brad' )
        ! Can't get here if the type checker worked

!      end select
a110 1

a112 1
!----------------------------
a113 1
!----------------------------
d115 1
a115 1
!------------------------------------------------------------------------------
d117 1
a117 1
!------------------------------------------------------------------------------
d119 6
a124 2
! Brief description of subroutine
! Take file name from l2cf, open, and store unit no. in l1bInfo
d126 1
a126 5
! Arguments
    type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
    integer, intent(in) :: Root         ! of the l1brad file specification.
    !                                     Indexes a "spec_args" vertex.
    integer, intent(in) :: F_FILE
d129 3
a131 5
    character(len=FileNameLen) :: FileName      ! Duh
    integer :: Son                      ! Some subtree of root.
    integer :: status, sd_id

    ! Error message codes
d133 1
a134 1

a135 1

a136 1

a137 3
!      select case ( get_field_id(son) )

!      case ( f_file )
a138 2

!      case ( f_file )
a147 2

!      case default
d149 2
a150 4
          call announce_error ( son, &
            & 'Unknown field specified in read l1boa' )
        ! Can't get here if the type checker worked

a151 2
!      end select

a152 2

!----------------------------
a153 2
!----------------------------

d155 1
a155 1
!------------------------------------------------------------------------------
d157 34
a190 2
    &                       FirstMAF, LastMAF )
!------------------------------------------------------------------------------
d192 1
a192 1
! Brief description of subroutine
d194 3
a196 1
! This is a prototype for the ReadL1BData subroutine in the Open/Init task.
d198 1
a198 1
! Arguments
d200 3
a202 1
      character (len=*), intent(in) :: quantityName
d204 3
a206 1
      integer, intent(in) :: L1FileHandle
d208 3
a210 3
      integer, intent(in), optional :: firstMAF, lastMAF
 
      type( l1bdata_t ), intent(out) :: l1bData
d212 3
a214 1
      integer, intent(out) :: flag, noMAFs
d216 3
a218 1
! Parameters
d220 2
a221 1
      character (len=*), parameter :: INPUT_ERR = 'Error in input argument '
d223 1
a223 1
      integer, parameter :: MAX_VAR_DIMS = 32
d225 3
a227 1
! Functions
d229 4
a232 2
      integer, external :: sfginfo, sfn2index, sfselect, sfrdata, sfrcdata
      integer, external :: sfendacc
d234 1
a234 1
! Variables
d236 1
a236 1
      character (len=480) :: msr
d238 7
a244 4
      integer :: Alloc_err, Data_type, Dealloc_err, I, N_attrs, NumMAFs, Rank
      integer :: Sds1_id, Sds2_id, Sds_index, Status
      integer :: Dim_sizes(MAX_VAR_DIMS)
      integer, allocatable :: Edge(:), Start(:), Stride(:)
d246 5
a250 1
      logical :: FirstCheck, LastCheck
d252 1
a252 1
      real, allocatable :: RealField(:,:,:)
d254 1
a254 1
      flag = 0
d256 8
a263 22
! Find data sets for counterMAF & quantity by name

      sds_index = sfn2index(L1FileHandle, 'counterMAF')
      if ( sds_index == -1) call MLSMessage ( MLSMSG_Error, ModuleName, 'Failed &
                                       &to find index of counterMAF data set.')

      sds1_id = sfselect(L1FileHandle, sds_index)
      if ( sds1_id == -1) call MLSMessage ( MLSMSG_Error, ModuleName, 'Failed to &
                                     &find identifier of counterMAF data set.')

      sds_index = sfn2index(L1FileHandle, quantityName)
      if ( sds_index == -1) call MLSMessage ( MLSMSG_Error, ModuleName, 'Failed &
                                         &to find index of quantity data set.')

      sds2_id = sfselect(L1FileHandle, sds_index)
      if ( sds2_id == -1) call MLSMessage ( MLSMSG_Error, ModuleName, 'Failed to &
                             &find identifier of data set matching the index.')

! Find rank (# of dimensions), dimension sizes of quantity data set

      status = sfginfo(sds2_id, quantityName, rank, dim_sizes, data_type, &
                       n_attrs)
d265 6
a270 31
      if ( status == -1) call MLSMessage ( MLSMSG_Error, ModuleName, 'Failed to &
                                                      &find rank of data set.')

! allocate, based on above SD, dim info

      allocate (edge(rank), start(rank), stride(rank), STAT=alloc_err)

      if ( alloc_err /= 0 ) then
         msr = MLSMSG_allocate // '  slab dimensions.'
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if

! Set "slab" dimensions

      DO i = 1, rank
         edge(i) = dim_sizes(i)
      end do
      edge(rank) = 1

      start = 0

      stride = 1

! Fill in "indexing" values of l1b object

      l1bData%L1BName = quantityName

      if ( rank < 2 ) then
         l1bData%maxMIFs = 1
      else if ( rank > 2 ) then
         l1bData%maxMIFs = dim_sizes(2)
d272 1
a272 1
         l1bData%maxMIFs = dim_sizes(1)
d274 3
d278 55
a332 5
      if ( rank > 2 ) then
         l1bData%noAuxInds = dim_sizes(1)
      else
         l1bData%noAuxInds = 1
      end if
d334 1
a334 1
! Check input arguments, set noMAFs
d336 2
a337 1
      numMAFs = dim_sizes(rank)
d339 7
a345 2
      firstCheck = PRESENT(firstMAF)
      lastCheck = PRESENT(lastMAF)
d347 6
a352 154
      if ( firstCheck ) then

          if ( (firstMAF >= numMAFs) .OR. (firstMAF < 0) ) then
             msr = INPUT_ERR // 'firstMAF'
             call MLSMessage ( MLSMSG_Error, ModuleName, msr )
          end if

          l1bData%firstMAF = firstMAF

      else

          l1bData%firstMAF = 0

      end if

      if ( lastCheck ) then

          if ( lastMAF < l1bData%firstMAF ) then
             msr = INPUT_ERR // 'lastMAF'
             call MLSMessage ( MLSMSG_Error, ModuleName, msr )
          end if

          if ( lastMAF >= numMAFs ) then
             l1bData%noMAFs = numMAFs - l1bData%firstMAF
          else
             l1bData%noMAFs = lastMAF - l1bData%firstMAF + 1
          end if

      else

         l1bData%noMAFs = numMAFs - l1bData%firstMAF

      end if

      noMAFs = l1bData%noMAFs

! allocate, read counterMAF

      allocate(l1bData%counterMAF(l1bData%noMAFs), STAT=alloc_err)
      if ( alloc_err /= 0 ) then
         msr = MLSMSG_allocate // '  counterMAF pointer.'
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if

      status = sfrdata(sds1_id,  l1bData%firstMAF , stride, &
        & l1bData%noMAFs, l1bData%counterMAF )
      if ( status == -1 ) then
         msr = MLSMSG_L1BRead // 'counterMAF.'
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if

! allocate, read according to field type; nullify unused pointers

      if ( data_type == 4 ) then

! character (DFNT_CHAR8)

         allocate ( l1bData%charField(l1bData%noAuxInds,l1bData%maxMIFs,&
                   &l1bData%noMAFs), STAT=alloc_err )
         if ( alloc_err /= 0 ) then
            msr = MLSMSG_allocate // ' charField pointer.'
            call MLSMessage ( MLSMSG_Error, ModuleName, msr )
         end if
         nullify (l1bData%intField, l1bData%dpField)

         DO i = 1, l1bData%noMAFs
            start(rank) = l1bData%firstMAF + (i-1)
            status = sfrcdata( sds2_id, start, stride, edge, &
                               l1bData%charField(:,:,i) )
            if ( status == -1 ) then
               msr = MLSMSG_L1BRead // quantityName
               call MLSMessage ( MLSMSG_Error, ModuleName, msr )
            end if
         end do

      else if ( data_type == 24 ) then

! integer (DFNT_INT32)

         allocate (l1bData%intField(l1bData%noAuxInds,l1bData%maxMIFs,&
                  &l1bData%noMAFs), STAT=alloc_err)
         if ( alloc_err /= 0 ) then
            msr = MLSMSG_allocate // ' intField pointer.'
            call MLSMessage ( MLSMSG_Error, ModuleName, msr )
         end if
         nullify ( l1bData%charField, l1bData%dpField )

         DO i = 1, l1bData%noMAFs
            start(rank) = l1bData%firstMAF + (i-1)
            status = sfrdata( sds2_id, start, stride, edge, &
                              l1bData%intField(:,:,i) )
            if ( status == -1 ) then
               msr = MLSMSG_L1BRead // quantityName
               call MLSMessage ( MLSMSG_Error, ModuleName, msr )
            end if
         end do

      else

! float (REAL or DOUBLE PRECISION)

         allocate ( l1bData%dpField(l1bData%noAuxInds,l1bData%maxMIFs,&
                   & l1bData%noMAFs), STAT=alloc_err )
         if ( alloc_err /= 0 ) then
            msr = MLSMSG_allocate // ' dpField pointer.'
            call MLSMessage ( MLSMSG_Error, ModuleName, msr )
         end if
         nullify ( l1bData%charField, l1bData%intField )

! If real (DFNT_FLOAT32), allocate real variable and then move to dp pointer

         if ( data_type == 5 ) then

            allocate ( realField(l1bData%noAuxInds,l1bData%maxMIFs,&
                     & l1bData%noMAFs), STAT=alloc_err )
            if ( alloc_err /= 0 ) then
               msr = MLSMSG_allocate // ' realField pointer.'
               call MLSMessage ( MLSMSG_Error, ModuleName, msr )
            end if

            do i = 1, l1bData%noMAFs
               start(rank) = l1bData%firstMAF + (i-1)
               status = sfrdata( sds2_id, start, stride, edge, &
                                realField(:,:,i) )
               if ( status == -1 ) then
                  msr = MLSMSG_L1BRead // quantityName
                  call MLSMessage ( MLSMSG_Error, ModuleName, msr )
               end if
            end do

            l1bData%dpField = DBLE(realField)

            deallocate ( realField, STAT=dealloc_err )
            if ( dealloc_err /= 0 ) then
               call MLSMessage ( MLSMSG_Warning, ModuleName, 'Failed &
                                     &deallocation of local real variable.' )
               flag = -1
            end if


         else

! double precision (DFNT_FLOAT64)


            do i = 1, l1bData%noMAFs
               start(rank) = l1bData%firstMAF + (i-1)
               status = sfrdata(sds2_id, start, stride, edge, &
                                l1bData%dpField(:,:,i))
               if ( status == -1 ) then
                  msr = MLSMSG_L1BRead // quantityName
                  call MLSMessage ( MLSMSG_Error, ModuleName, msr )
               end if
            end do
d354 4
a357 1
         end if
a358 23
      end if

! Terminate access to the data sets

      status = sfendacc(sds1_id)
      status = sfendacc(sds2_id)
      if ( status == -1 ) then
         call MLSMessage ( MLSMSG_Warning, ModuleName, 'Failed to terminate &
                                                     &access to data sets.' )
         flag = -1
      end if

! deallocate local variables

      deallocate (edge, start, stride, STAT=dealloc_err )

      if ( dealloc_err /= 0 ) then
         call MLSMessage ( MLSMSG_Warning, ModuleName, 'Failed deallocation of &
                                                     &local variables.' )
         flag = -1
      end if

!----------------------------
a359 1
!----------------------------
d361 4
a364 3
!----------------------------------------------
  subroutine DeallocateL1BData ( l1bData, flag )
!----------------------------------------------
d366 2
a367 3
! Brief description of subroutine
! This subroutine deallocates the internal field pointers of the L1BData_T
! derived type, after the calling program has finished with the data.
d369 15
a383 33
! Arguments

      type( L1BData_T ), intent(inout) :: L1bData

      integer, intent(out) :: Flag

! Parameters

! Functions

! Variables

      integer :: Dealloc_err

      flag = 0

      if ( associated(l1bData%counterMAF) ) deallocate ( l1bData%counterMAF, &
        &                                               STAT=dealloc_err )
      if ( associated(l1bData%charField) ) then
         deallocate ( l1bData%charField, STAT=dealloc_err )
      else if ( associated(l1bData%intField) ) then
         deallocate ( l1bData%intField, STAT=dealloc_err )
      else
         deallocate ( l1bData%dpField, STAT=dealloc_err )
      end if

      if ( dealloc_err /= 0 ) then
         call MLSMessage ( MLSMSG_Warning, ModuleName, 'Failed deallocation of &
                                                     &L1BData pointers.' )
         flag = -1
      end if

!----------------------------------
a384 1
!----------------------------------
d411 3
a413 3
  
   ! Arguments
  
d419 2
a420 2
!    character (len=80) :: msg, mnemonic
!    integer :: status
d423 1
a423 1
 
d431 1
a431 1
 
d437 1
a437 1
          call print_source ( source_ref(lcf_where) )
a464 2

!===========================
a465 1
!===========================
a466 1
!=================
a467 1
!=================
d470 3
@


2.6
log
@Now sets L1B..FileName components in ..Setup
@
text
@d23 1
a23 1
       "$Id: L1BData.f90,v 2.5 2001/05/03 23:58:38 vsnyder Exp $"
d103 1
d106 1
a106 1
          & call announce_error ( son, 'Allocation failed for L1BRADIDs' )
d629 3
@


2.5
log
@Remove conflicts from merge
@
text
@d23 1
a23 1
       "$Id: $"
d26 1
a26 1
       "$RCSfile: $"
d117 1
d175 1
d628 3
@


2.4
log
@Added use statement for lexer_core
@
text
@a0 1

d5 1
a5 1
MODULE L1BData
d9 4
a12 4
   USE MLSCommon, only: R8, L1BInfo_T, FileNameLen
   USE MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Error, &
     & MLSMSG_L1Bread, MLSMSG_Warning
   use Lexer_Core, only: PRINT_SOURCE
d18 2
a19 4
   IMPLICIT NONE
   PUBLIC

   PRIVATE :: ID, ModuleName
d21 7
a27 5
!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &
   "$Id: L1BData.f90,v 2.3 2001/05/03 22:32:25 pwagner Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: L1BData.f90,v $"
!----------------------------------------------------------
d32 2
a33 2
! Subroutines -- ReadL1BData
!                DeallocateL1BData
d41 1
a41 1
   INTEGER, PARAMETER :: NAME_LEN = 64		! Max len of SDS array name
d45 14
a58 14
   TYPE L1BData_T
      CHARACTER (LEN=NAME_LEN) :: L1BName	! Name of field in file
      INTEGER :: firstMAF   			! First major frame read
      INTEGER :: noMAFs				! # of MAFs read
      INTEGER :: maxMIFs			! Max # of MIFs/MAF in SD array
      INTEGER :: noAuxInds			! # of auxilliary indices

      INTEGER, DIMENSION(:), POINTER :: counterMAF	! dimensioned (noMAFs)

      CHARACTER, DIMENSION(:,:,:), POINTER :: charField
      REAL(r8), DIMENSION(:,:,:), POINTER :: dpField
      INTEGER, DIMENSION(:,:,:), POINTER :: intField
			! dimensioned (noAuxInds,maxMIFs,noMAFs)
   END TYPE L1BData_T
d63 1
a63 1
CONTAINS
d65 1
a65 2
!------------------------------------------------------------------------------
   SUBROUTINE l1bradSetup ( root, l1bInfo, F_FILE, &
d131 1
a131 1
   END SUBROUTINE l1bradSetup
d135 1
a135 1
   SUBROUTINE l1boaSetup ( root, l1bInfo, F_FILE )
d188 1
a188 1
   END SUBROUTINE l1boaSetup
d191 1
d193 2
a194 2
   SUBROUTINE ReadL1BData (L1FileHandle, quantityName, l1bData, noMAFs, flag, &
                           firstMAF, lastMAF)
d198 1
d203 1
a203 1
      CHARACTER (LEN=*), INTENT(IN) :: quantityName
d205 1
a205 1
      INTEGER, INTENT(IN) :: L1FileHandle
d207 3
a209 3
      INTEGER, INTENT(IN), OPTIONAL :: firstMAF, lastMAF
   
      TYPE( L1BData_T ), INTENT(OUT) :: l1bData
d211 1
a211 1
      INTEGER, INTENT(OUT) :: flag, noMAFs
d215 1
a215 1
      CHARACTER (LEN=*), PARAMETER :: INPUT_ERR = 'Error in input argument '
d217 1
a217 1
      INTEGER, PARAMETER :: MAX_VAR_DIMS = 32
d221 2
a222 2
      INTEGER, EXTERNAL :: sfginfo, sfn2index, sfselect, sfrdata, sfrcdata
      INTEGER, EXTERNAL :: sfendacc
d226 1
a226 1
      CHARACTER (LEN=480) :: msr
d228 4
a231 4
      INTEGER :: alloc_err, data_type, dealloc_err, i, n_attrs, numMAFs, rank
      INTEGER :: sds1_id, sds2_id, sds_index, status
      INTEGER :: dim_sizes(MAX_VAR_DIMS)
      INTEGER, ALLOCATABLE :: edge(:), start(:), stride(:)
d233 1
a233 1
      LOGICAL :: firstCheck, lastCheck
d235 1
a235 1
      REAL, ALLOCATABLE :: realField(:,:,:)
d242 1
a242 1
      IF (sds_index == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
d246 1
a246 1
      IF (sds1_id == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d250 1
a250 1
      IF (sds_index == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
d254 1
a254 1
      IF (sds2_id == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d262 1
a262 1
      IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d265 1
a265 1
! Allocate, based on above SD, dim info
d267 1
a267 1
      ALLOCATE (edge(rank), start(rank), stride(rank), STAT=alloc_err)
d269 4
a272 4
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  slab dimensions.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d278 1
a278 1
      ENDDO
d289 1
a289 1
      IF (rank < 2) THEN
d291 1
a291 1
      ELSE IF (rank > 2) THEN
d293 1
a293 1
      ELSE
d295 1
a295 1
      ENDIF
d297 1
a297 1
      IF (rank > 2) THEN
d299 1
a299 1
      ELSE
d301 1
a301 1
      ENDIF
d310 1
a310 1
      IF (firstCheck) THEN
d312 1
a312 1
          IF ( (firstMAF >= numMAFs) .OR. (firstMAF < 0) ) THEN
d314 2
a315 2
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
d319 1
a319 1
      ELSE
d323 1
a323 1
      ENDIF
d325 1
a325 1
      IF (lastCheck) THEN
d327 1
a327 1
          IF (lastMAF < l1bData%firstMAF) THEN
d329 2
a330 2
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
d332 1
a332 1
          IF (lastMAF >= numMAFs) THEN
d334 1
a334 1
          ELSE
d336 1
a336 1
          ENDIF
d338 1
a338 1
      ELSE
d342 1
a342 1
      ENDIF
d346 1
a346 1
! Allocate, read counterMAF
d348 5
a352 5
      ALLOCATE(l1bData%counterMAF(l1bData%noMAFs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  counterMAF pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d356 1
a356 1
      IF (status == -1) THEN
d358 2
a359 2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d361 1
a361 1
! Allocate, read according to field type; nullify unused pointers
d363 1
a363 1
      IF (data_type == 4) THEN
d367 1
a367 1
         ALLOCATE ( l1bData%charField(l1bData%noAuxInds,l1bData%maxMIFs,&
d369 5
a373 5
         IF ( alloc_err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' charField pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         NULLIFY (l1bData%intField, l1bData%dpField)
d379 1
a379 1
            IF (status == -1) THEN
d381 3
a383 3
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDDO
d385 1
a385 1
      ELSE IF (data_type == 24) THEN
d389 1
a389 1
         ALLOCATE (l1bData%intField(l1bData%noAuxInds,l1bData%maxMIFs,&
d391 5
a395 5
         IF ( alloc_err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' intField pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         NULLIFY (l1bData%charField, l1bData%dpField)
d401 1
a401 1
            IF (status == -1) THEN
d403 3
a405 3
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDDO
d407 1
a407 1
      ELSE
d411 7
a417 7
         ALLOCATE (l1bData%dpField(l1bData%noAuxInds,l1bData%maxMIFs,&
                  &l1bData%noMAFs), STAT=alloc_err)
         IF ( alloc_err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' dpField pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         NULLIFY (l1bData%charField, l1bData%intField)
d421 1
a421 1
         IF (data_type == 5) THEN
d423 6
a428 6
            ALLOCATE (realField(l1bData%noAuxInds,l1bData%maxMIFs,&
                     &l1bData%noMAFs), STAT=alloc_err)
            IF ( alloc_err /= 0 ) THEN
               msr = MLSMSG_Allocate // ' realField pointer.'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
d430 1
a430 1
            DO i = 1, l1bData%noMAFs
d434 1
a434 1
               IF (status == -1) THEN
d436 3
a438 3
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF
            ENDDO
d442 4
a445 4
            DEALLOCATE(realField, STAT=dealloc_err)
            IF ( dealloc_err /= 0 ) THEN
               CALL MLSMessage(MLSMSG_Warning, ModuleName, 'Failed &
                                     &deallocation of local real variable.')
d447 1
a447 1
            ENDIF
d450 1
a450 1
         ELSE
d455 1
a455 1
            DO i = 1, l1bData%noMAFs
d459 1
a459 1
               IF (status == -1) THEN
d461 3
a463 3
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF
            ENDDO
d465 1
a465 1
         ENDIF
d467 1
a467 1
      ENDIF
d473 3
a475 3
      IF (status == -1) THEN
         CALL MLSMessage(MLSMSG_Warning, ModuleName, 'Failed to terminate &
                                                     &access to data sets.')
d477 1
a477 1
      ENDIF
d479 1
a479 1
! Deallocate local variables
d481 1
a481 1
      DEALLOCATE (edge, start, stride, STAT=dealloc_err )
d483 3
a485 3
      IF ( dealloc_err /= 0 ) THEN
         CALL MLSMessage(MLSMSG_Warning, ModuleName, 'Failed deallocation of &
                                                     &local variables.')
d487 1
a487 1
      ENDIF
d490 1
a490 1
   END SUBROUTINE ReadL1BData
d494 1
a494 1
   SUBROUTINE DeallocateL1BData (l1bData, flag)
d503 1
a503 1
      TYPE( L1BData_T ), intent(INOUT) :: l1bData
d505 1
a505 1
      INTEGER, INTENT(OUT) :: flag
d513 1
a513 1
      INTEGER :: dealloc_err
d517 13
a529 13
      IF ( ASSOCIATED(l1bData%counterMAF) ) DEALLOCATE (l1bData%counterMAF, &
                                                        STAT=dealloc_err)
      IF ( ASSOCIATED(l1bData%charField) ) THEN
         DEALLOCATE (l1bData%charField, STAT=dealloc_err)
      ELSE IF ( ASSOCIATED(l1bData%intField) ) THEN
         DEALLOCATE (l1bData%intField, STAT=dealloc_err)
      ELSE
         DEALLOCATE (l1bData%dpField, STAT=dealloc_err)
      ENDIF

      IF ( dealloc_err /= 0 ) THEN
         CALL MLSMessage(MLSMSG_Warning, ModuleName, 'Failed deallocation of &
                                                     &L1BData pointers.')
d531 1
a531 1
      ENDIF
d534 1
a534 1
   END SUBROUTINE DeallocateL1BData
d537 20
a556 20
   ! ------------------------------------------- FindL1BData ----
   integer function FindL1BData( files, fieldName )
     integer, dimension(:), intent(in) :: files ! File handles
     character (len=*), intent(in) :: fieldName ! Name of field
     
     ! Externals
     integer, external :: SFN2INDEX

     ! Local variables
     integer :: i

     ! Executable code
     FindL1BData=0
     do i=1,size(files)
       if ( sfn2index(files(i),fieldName) /= -1) then
         FindL1BData=files(i)
         return
       end if
     end do
   end function FindL1BData
d561 1
a561 1
  & error_number )
d622 1
a622 1
END MODULE L1BData
d626 3
@


2.3
log
@Added L1B..Setup for Rad and OA
@
text
@d13 1
d26 1
a26 1
   "$Id: L1BData.f90,v 2.2 2001/03/03 00:06:23 livesey Exp $"
d626 3
@


2.2
log
@Added FindL1BData
@
text
@d9 2
a10 1
   USE MLSCommon, only: R8
d13 5
d25 1
a25 1
   "$Id: L1BData.f90,v 2.1 2000/10/04 01:27:34 vsnyder Exp $"
d60 3
d66 127
d557 63
d625 3
@


2.1
log
@Put ONLY clauses into the USE statements
@
text
@d19 1
a19 1
   "$Id: L1BData.f90,v 2.0 2000/09/05 17:41:06 dcuddy Exp $"
d28 1
d400 21
d426 3
@


2.0
log
@Change revision to 2.0
@
text
@d9 3
a11 2
   USE MLSCommon
   USE MLSMessageModule
d19 1
a19 1
   "$Id: L1BData.f90,v 1.11 2000/06/06 21:11:55 vsnyder Exp $"
d216 2
a217 2
      status = sfrdata(sds1_id, l1bData%firstMAF, stride, l1bData%noMAFs, &
                       l1bData%counterMAF)
d404 3
@


1.11
log
@Declare EXTERNAL attribute for HDF's sf* functions
@
text
@d18 1
a18 1
   "$Id: L1BData.f90,v 1.11 2000/06/06 21:11:55 vsnyder Exp $"
d403 3
a408 31
! Revision 1.10  2000/04/14 20:27:28  vsnyder
! OOPS -- Replaced unspecified INTENT with INTENT(INOUT) -- see previous rev.
!
! Revision 1.9  2000/04/13 23:55:10  vsnyder
! Removed INTENT(IN) for "l1bData" argument of "DeallocateL1BData" because
! components of it are deallocated.
!
! Revision 1.8  2000/02/16 19:32:50  nakamura
! Removed superfluous USE statements; read counterMAF as an SD, rather than a dimension scale.
!
! Revision 1.7  2000/01/07 19:57:40  nakamura
! Made ModuleName PRIVATE.
!
! Revision 1.6  2000/01/07 16:19:32  nakamura
! Changed error-handling to MLSMessageModule; tried to fix problem with Log keyword.
!
! Revision 1.5  1999/12/16 17:50:54  livesey
! Changed quantityName to LEN=*
!
! Revision 1.4  1999/12/14 00:52:14  livesey
! Problem with Log information? Perhaps inherited from Lori's RCS stuff
! incorrectly?
!
! Revision 1.3  1999/12/14 00:51:01  livesey
! Changed DOUBLE PRECISION to REAL (r8)
!
! Revision 1.2  1999/12/01 21:04:48  nakamura
! Changed name of module Inc to SDPToolkit; removed USE statement for unused module Sd.
!
! Revision 1.1  1999/11/18 17:50:15  nakamura
! Prototype module containing L1BData derived type definition and subroutines.
@


