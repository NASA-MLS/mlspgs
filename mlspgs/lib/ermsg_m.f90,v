head	2.7;
access;
symbols
	v5-02-NRT-19:2.7
	v6-00:2.7
	v5-02-NRT-18:2.7
	v5-02:2.7
	v5-01-NRT-17:2.7
	v5-01-NRT-16:2.7
	v5-01-NRT-15:2.7
	v5-01-NRT-14:2.7
	neuralnetworks-1-0:2.7.0.14
	cfm-single-freq-0-1:2.7.0.12
	v5-01:2.7
	v5-00:2.7
	v4-23-TA133:2.7.0.10
	mus-emls-1-70:2.7.0.8
	rel-1-0-englocks-work:2.7.0.6
	VUMLS1-00:2.7
	VPL1-00:2.7
	V4-22-NRT-08:2.7
	VAM1-00:2.7
	V4-21:2.7.0.4
	V4-13:2.7
	V4-12:2.7
	V4-11:2.7
	V4-10:2.7
	V3-43:2.7
	M4-00:2.7
	V3-41:2.7
	V3-40-PlusGM57:2.7.0.2
	V2-24-NRT-04:2.6
	V3-33:2.7
	V2-24:2.6
	V3-31:2.7
	V3-30-NRT-05:2.7
	cfm-01-00:2.7
	V3-30:2.7
	V3-20:2.7
	V3-10:2.7
	V2-23-NRT-02:2.6
	V2-23:2.6
	V2-22-NRT-01:2.6
	V2-22:2.6
	V2-21:2.5
	V2-20:2.5
	V2-11:2.5
	V2-10:2.5
	V2-00:2.5
	V1-51:2.4
	V1-50:2.4
	V1-45:2.4
	V1-44:2.4
	V1-43:2.4
	V1-42:2.4
	V1-41:2.4
	V1-32:2.4
	V1-40:2.4
	V1-31:2.4
	V1-30:2.3;
locks; strict;
comment	@# @;


2.7
date	2009.06.23.18.25.43;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2007.05.17.17.24.04;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2005.06.22.17.25.48;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2003.10.16.19.00.26;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2003.07.15.21.58.38;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2002.01.09.22.43.32;	author pwagner;	state dead;
branches;
next	2.1;

2.1
date	2001.09.20.22.58.55;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.7
log
@Prevent Intel from optimizing ident string away
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=======================================================================================

MODULE ERMSG_M

!=======================================================================================
! We've endeavored to make this independent of the normal "write(*,*)" idiom
! Also we don't merely "stop", we call MLSMessageExit
! Note that, depending on MLSMessageConfig, the program may halt after the first
! output (probably not what you want)
! Also each line might be prefixed by some string and/or time-stamped

  use MLSMessageModule, only: MLSMessage, MLSMessageExit, MLSMSG_Warning
  IMPLICIT NONE

  PRIVATE

  PUBLIC ERFIN, ERM1, IERM1, SERM1, DERM1
  INTERFACE ERM1; MODULE PROCEDURE IERM1, SERM1, DERM1; END INTERFACE
  PUBLIC ERMN, IERMN, SERMN, DERMN
  INTERFACE ERMN; MODULE PROCEDURE IERMN, SERMN, DERMN; END INTERFACE
  PUBLIC ERMOR, ERMSET, ERMSG, ERV1, IERV1, SERV1, DERV1
  INTERFACE ERV1; MODULE PROCEDURE IERV1, SERV1, DERV1; END INTERFACE
  PUBLIC ERVN, IERVN, SERVN, DERVN
  INTERFACE ERVN; MODULE PROCEDURE IERVN, SERVN, DERVN; END INTERFACE

  INTEGER, SAVE, PUBLIC :: IDELTA=0 ! increment to LEVEL to calculate
                                    ! IALPHA in ERMSG, q.v.
  INTEGER, SAVE, PUBLIC :: OLDLEV=0 ! last value of LEVEL passed to ERMSG

  INTEGER, SAVE, PRIVATE :: IALPHA  ! = IDELTA + LEVEL; used to determine
                                    ! whether to print
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  interface output
    module procedure output_dble, output_int, output_real, output_char
  end interface

CONTAINS
  SUBROUTINE ERFIN
!>> 1998-04-13 ERFIN  Snyder  Convert to F90
!>> 1994-11-11 ERFIN  CLL     Typing all variables.
!>> 1985-09-23 ERFIN  Lawson  Initial code.
 
    ! WRITE (*,"(1X,72('$')/' ')")
    ! IF (ialpha >= 2) STOP
    call output('$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$')
    if ( ialpha > 1 ) call MLSMessageExit( 1 )
    RETURN
  END SUBROUTINE ERFIN
!=======================================================================
  SUBROUTINE IERM1 (SUBNAM, INDIC, LEVEL, MSG, LABEL, VALUE, FLAG)
!>> 1998-04-13 IERM1  Snyder  Convert to F90
!>> 1990-01-18 IERM1  CLL     Typed all variables.
!>> 1985-08-02 IERM1  Lawson  Initial code.
    INTEGER, INTENT(in) :: INDIC, LEVEL, VALUE
    CHARACTER(LEN=*), INTENT(in) :: SUBNAM, MSG, LABEL
    CHARACTER(LEN=1), INTENT(in) :: FLAG
    CALL ERMSG (SUBNAM, INDIC, LEVEL, MSG, ',')
    CALL ERV1 (LABEL, VALUE, FLAG)
    RETURN
  END SUBROUTINE IERM1

  SUBROUTINE SERM1 (SUBNAM, INDIC, LEVEL, MSG, LABEL, VALUE, FLAG)
!>> 1998-04-13 SERM1  Snyder  Convert to F90
!>> 1990-01-18 SERM1  CLL     Typed all variables.
!>> 1985-08-02 SERM1  Lawson  Initial code.
    INTEGER, INTENT(in) :: INDIC, LEVEL
    REAL, INTENT(IN) :: VALUE
    CHARACTER(LEN=*), INTENT(in) :: SUBNAM, MSG, LABEL
    CHARACTER(LEN=1), INTENT(in) :: FLAG
    CALL ERMSG (SUBNAM, INDIC, LEVEL, MSG, ',')
    CALL ERV1 (LABEL, VALUE, FLAG)
    RETURN
  END SUBROUTINE SERM1

  SUBROUTINE DERM1 (SUBNAM, INDIC, LEVEL, MSG, LABEL, VALUE, FLAG)
!>> 1998-04-13 DERM1  Snyder  Convert to F90
!>> 1990-01-18 DERM1  CLL     Typed all variables.
!>> 1985-08-02 DERM1  Lawson  Initial code.
    INTEGER, INTENT(in) :: INDIC, LEVEL
    DOUBLE PRECISION, INTENT(IN) :: VALUE
    CHARACTER(LEN=*), INTENT(in) :: SUBNAM, MSG, LABEL
    CHARACTER(LEN=1), INTENT(in) :: FLAG
    CALL ERMSG (SUBNAM, INDIC, LEVEL, MSG, ',')
    CALL ERV1 (LABEL, VALUE, FLAG)
    RETURN
  END SUBROUTINE DERM1
!=======================================================================

! These subroutines call ERMSG to initiate an error message and then
! call ERVN to print an array of values with labels.
!
! ------------------------------------------------------------------
! SUBROUTINE ARGUMENTS
! --------------------
! SUBNAM   A name that identifies the subprogram in which
!          the error occurs.
!
! INDIC    An integer printed as part of the mininal error
!          message. It together with SUBNAM can be used to
!          uniquely identify an error.
!
! LEVEL    The user sets LEVEL=2,0,or -2 to specify the
!          nominal action to be taken.
!          See subr ERMSG for interpretation of LEVEL.
!
! MSG      Message to be printed to describe the error.
!
! LABELS() An array of character data to identify the individual
!          scalars.  There must be one character label for each scal
!          The character string length is used to determine how many
!          labelled scalars can be output on a single line (of 132).
!
! VALUES() An array of scalars to be printed with their identifiers.
!
! FLAG     A single character, which when set to '.' will
!          call the subroutine ERFIN and will just RETURN
!          when set to any other character.
!
! ------------------------------------------------------------------
!
! Kris Stewart, JPL, 1983 July.
! C.Lawson & S.Chan, JPL, 1983,Nov.
!
! ------------------------------------------------------------------

  SUBROUTINE IERMN (SUBNAM, INDIC, LEVEL, MSG, LABELS, VALUES, FLAG)
!>> 1998-04-13 IERMN  Snyder  Convert to F90
!>> 1994-10-20 IERMN  Krogh   Changes to use M77CON
!>> 1987-10-02 IERMN  Lawson  Initial code.
    INTEGER, INTENT(in) :: LEVEL, INDIC
    CHARACTER(len=*), INTENT(in) :: SUBNAM, MSG, LABELS(:)
    CHARACTER(len=1), INTENT(in) :: FLAG
    INTEGER, INTENT(in) :: VALUES(:)

    CALL ermsg (subnam, indic, level,msg, ',')
    CALL ervn (labels, values, flag)
    RETURN
  END SUBROUTINE IERMN

  SUBROUTINE SERMN (SUBNAM, INDIC, LEVEL, MSG, LABELS, VALUES, FLAG)
!>> 1998-04-13 SERMN  Snyder  Convert to F90
!>> 1994-10-20 SERMN  Krogh   Changes to use M77CON
!>> 1987-10-02 SERMN  Lawson  Initial code.
    INTEGER, INTENT(in) :: LEVEL, INDIC
    CHARACTER(len=*), INTENT(in) :: SUBNAM, MSG, LABELS(:)
    CHARACTER(len=1), INTENT(in) :: FLAG
    REAL, INTENT(in) :: VALUES(:)

    CALL ermsg (subnam, indic, level,msg, ',')
    CALL ervn (labels, values, flag)
    RETURN
  END SUBROUTINE SERMN

  SUBROUTINE DERMN (SUBNAM, INDIC, LEVEL, MSG, LABELS, VALUES, FLAG)
!>> 1998-04-13 DERMN  Snyder  Convert to F90
!>> 1994-10-20 DERMN  Krogh   Changes to use M77CON
!>> 1987-10-02 DERMN  Lawson  Initial code.
    INTEGER, INTENT(in) :: LEVEL, INDIC
    CHARACTER(len=*), INTENT(in) :: SUBNAM, MSG, LABELS(:)
    CHARACTER(len=1), INTENT(in) :: FLAG
    DOUBLE PRECISION, INTENT(in) :: VALUES(:)

    CALL ermsg (subnam, indic, level,msg, ',')
    CALL ervn (labels, values, flag)
    RETURN
  END SUBROUTINE DERMN
!=======================================================================
  SUBROUTINE ERMOR (MSG, FLAG)
!>> 1998-04-13 ERMOR  WVSnyder  Convert to F90
!>> 1985-09-20 ERMOR  Lawson  Initial code.

! --------------------------------------------------------------
! SUBROUTINE ARGUMENTS
! --------------------
! MSG      Message to be printed as part of the diagnostic.
!
! FLAG     A single character,which when set to '.' will
!          call the subroutine ERFIN and will just RETURN
!          when set to any other character.
!
! --------------------------------------------------------------
!
    CHARACTER(len=*), INTENT(in) :: MSG
    CHARACTER(len=1), INTENT(in) :: FLAG

    IF (ialpha >= -1) THEN
      ! WRITE (*,*) msg
      call output( msg )
      IF (flag == '.') CALL erfin
    END IF
    RETURN
  END SUBROUTINE ERMOR
!=======================================================================
! ERMSET resets IDELTA.
  SUBROUTINE ERMSET (IDEL)
    INTEGER, INTENT(in) :: IDEL
    idelta = idel
    RETURN
  END SUBROUTINE ERMSET
!=======================================================================
  SUBROUTINE ERMSG (SUBNAM, INDIC, LEVEL, MSG, FLAG)
!>> 1998-04-13 ERMSG  WVSnyder  Convert to F90
!>> 1994-11-11 ERMSG  Krogh     Declared all vars.
!>> 1992-10-20 ERMSG  WVSnyder  added ERLSET, ERLGET
!>> 1985-09-25 ERMSG  Lawson    Initial code.

!     --------------------------------------------------------------

! ERMSG initiates an error message, and manages the saved values IDELTA
! and IALPHA to control the level of action. This is intended to
! be the only subroutine that assigns a value to IALPHA.

!
!     --------------------------------------------------------------
!     SUBROUTINE ARGUMENTS
!     --------------------
!     SUBNAM   A name that identifies the subprogram in which
!              the error occurs.
!
!     INDIC    An integer printed as part of the mininal error
!              message. It together with SUBNAM can be used to
!              uniquely identify an error.
!
!     LEVEL    The user sets LEVEL=2,0,or -2 to specify the
!              nominal action to be taken by ERMSG. The
!              module ERMSG_M contains a private variable
!              IDELTA, whose nominal value is zero. The
!              subroutine will compute IALPHA = LEVEL + IDELTA
!              and proceed as follows:
!              If (IALPHA >= 2)        Print message and STOP.
!              If (IALPHA=-1,0,1)      Print message and return.
!              If (IALPHA <= -2)       Just RETURN.
!
!     MSG      Message to be printed as part of the diagnostic.
!
!     FLAG     A single character,which when set to '.' will
!              call the subroutine ERFIN and will just RETURN
!              when set to any other character.
!
!     --------------------------------------------------------------
!
!     C.Lawson & S.Chan, JPL, 1983 Nov
!
!     ------------------------------------------------------------------
    INTEGER, INTENT(in) :: LEVEL, INDIC
    CHARACTER(len=*), INTENT(in) :: SUBNAM, MSG
    CHARACTER(len=1), INTENT(in) :: FLAG

    oldlev = level
    ialpha = level + idelta
    IF (ialpha >= -1) THEN
      ! WRITE (*,"('0',72('$')/' SUBPROGRAM ',A,' REPORTS ERROR NO. ',I4)") &
      !  subnam, indic
      ! WRITE (*,*) msg
      call newline
      call output( '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$' )
      call output( ' reports error number ', subnam, advance='no' )
      call output( indic )
      IF (flag == '.') CALL erfin
    ENDIF
    RETURN
  END SUBROUTINE ERMSG
!=======================================================================
! ------------------------------------------------------------
! SUBROUTINE ARGUMENTS
! --------------------
! LABEL     An identifing name to be printed with VALUE.
!
! VALUE     A integer to be printed.
!
! FLAG      See write up for FLAG in ERMSG.
!
! ------------------------------------------------------------

  SUBROUTINE IERV1 (LABEL, VALUE, FLAG)
!>> 1998-04-13 IERV1  Snyder  Convert to F90
!>> 1985-09-20 IERV1  Lawson  Initial code.
    INTEGER, INTENT(in) :: VALUE
    CHARACTER(len=*), INTENT(in) ::  LABEL
    CHARACTER(len=1), INTENT(in) ::  FLAG

    IF (ialpha >= -1) THEN
      WRITE (*,*) label, ' = ', value
      IF (flag == '.') CALL erfin
    END IF
    RETURN
  END SUBROUTINE IERV1

  SUBROUTINE SERV1 (LABEL, VALUE, FLAG)
!>> 1998-04-13 SERV1  Snyder  Convert to F90
!>> 1985-09-20 SERV1  Lawson  Initial code.
    REAL, INTENT(in) :: VALUE
    CHARACTER(len=*), INTENT(in) ::  LABEL
    CHARACTER(len=1), INTENT(in) ::  FLAG

    IF (ialpha >= -1) THEN
      WRITE (*,*) label, ' = ', value
      IF (flag == '.') CALL erfin
    END IF
    RETURN
  END SUBROUTINE SERV1

  SUBROUTINE DERV1 (LABEL, VALUE, FLAG)
!>> 1998-04-13 DERV1  Snyder  Convert to F90
!>> 1985-09-20 DERV1  Lawson  Initial code.
    DOUBLE PRECISION, INTENT(in) :: VALUE
    CHARACTER(len=*), INTENT(in) ::  LABEL
    CHARACTER(len=1), INTENT(in) ::  FLAG

    IF (ialpha >= -1) THEN
      WRITE (*,*) label, ' = ', value
      IF (flag == '.') CALL erfin
    END IF
    RETURN
  END SUBROUTINE DERV1
!=======================================================================

! These subroutines print an array of values with labels as part of an
! error msg. Uses IALPHA that must have been previously set by ERMSG.

!     ------------------------------------------------------------------
!
! LABELS() An array of character data to identify the individual
!          scalars.  There must be one character label for each scal
!          The character string length is used to determine how many
!          labelled scalars can be output on a single line (of 132).
!
! VALUES() An array of single precision scalars to be printed with
!          their identifiers.
!
! FLAG     A single character, which when set to '.' will
!          call the subroutine ERFIN and will just RETURN
!          when set to any other character.

  SUBROUTINE IERVN (LABELS, VALUES, FLAG)
!>> 1998-04-13 IERVN  Snyder Convert to F90
!>> 1994-10-20 IERVN  Krogh  Changes to use M77CON
!>> 1989-11-10 IERVN  CLL
!>> 1987-10-02 IERVN  Lawson  Initial code.
! ----------------------------------------------------------------------
! 1989-11-10 CLL  Changed to keep length of printed line not
! greater than MAXCOL = 75 characters.
! ----------------------------------------------------------------------
    CHARACTER(LEN=*), INTENT(in) :: LABELS(:)
    INTEGER, INTENT(in) :: VALUES(SIZE(LABELS))
    CHARACTER(LEN=1), INTENT(in) :: FLAG

    INTEGER I, K, LENIDV, NUMBER
    INTEGER, PARAMETER :: MAXCOL = 75

    IF (ialpha >= -1) THEN
      lenidv = LEN (labels)
      number = maxcol / (lenidv+17)
      DO i = 1, SIZE(labels), number
        WRITE(*,"(4(2x,a,'=',i14))") &
          (labels(k), values(k), k = i, MIN(SIZE(labels), i+number-1) )
      END DO
      IF (flag == '.') CALL erfin
    ENDIF
    RETURN
  END SUBROUTINE IERVN

  SUBROUTINE SERVN (LABELS, VALUES, FLAG)
!>> 1998-04-13 SERVN  Snyder Convert to F90
!>> 1994-10-20 SERVN  Krogh  Changes to use M77CON
!>> 1989-11-10 SERVN  CLL
!>> 1987-10-02 SERVN  Lawson  Initial code.
! ----------------------------------------------------------------------
! 1989-11-10 CLL  Changed to keep length of printed line not
! greater than MAXCOL = 75 characters.
! ----------------------------------------------------------------------
    CHARACTER(LEN=*), INTENT(in) :: LABELS(:)
    REAL, INTENT(in) :: VALUES(SIZE(LABELS))
    CHARACTER(LEN=1), INTENT(in) :: FLAG

    INTEGER I, K, LENIDV, NUMBER
    INTEGER, PARAMETER :: MAXCOL = 75

    IF (ialpha >= -1) THEN
      lenidv = LEN (labels)
      number = maxcol / (lenidv+17)
      DO i = 1, SIZE(labels), number
        WRITE(*,"(4(2x,a,'=',g14.7))") &
          (labels(k), values(k), k = i, MIN(SIZE(labels), i+number-1) )
      END DO
      IF (flag == '.') CALL erfin
    ENDIF
    RETURN
  END SUBROUTINE SERVN

  SUBROUTINE DERVN (LABELS, VALUES, FLAG)
!>> 1998-04-13 DERVN  Snyder Convert to F90
!>> 1994-10-20 DERVN  Krogh  Changes to use M77CON
!>> 1989-11-10 DERVN  CLL
!>> 1987-10-02 DERVN  Lawson  Initial code.
! ----------------------------------------------------------------------
! 1989-11-10 CLL  Changed to keep length of printed line not
! greater than MAXCOL = 75 characters.
! ----------------------------------------------------------------------
    CHARACTER(LEN=*), INTENT(in) :: LABELS(:)
    DOUBLE PRECISION, INTENT(in) :: VALUES(SIZE(LABELS))
    CHARACTER(LEN=1), INTENT(in) :: FLAG

    INTEGER I, K, LENIDV, NUMBER
    INTEGER, PARAMETER :: MAXCOL = 75

    IF (ialpha >= -1) THEN
      lenidv = LEN (labels)
      number = maxcol / (lenidv+17)
      DO i = 1, SIZE(labels), number
        do k=i, MIN(SIZE(labels), i+number-1)
          call output( labels(k) // ' = ', advance='no' )
          call output( values(k), advance='no' )
        END DO
        call newline
        ! WRITE(*,"(4(2x,a,'=',g14.7))") &
        !  (labels(k), values(k), k = i, MIN(SIZE(labels), i+number-1) )
      END DO
      IF (flag == '.') CALL erfin
    ENDIF
    RETURN
  END SUBROUTINE DERVN

  subroutine newline
    call output( ' ', advance='yes' )
  end subroutine newline

  subroutine output_char( chars, subnam, advance )
    character(len=*), intent(in) :: chars
    character (len=*), optional, intent(in) :: subnam ! Name of module (see below)
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    ! Internal variables
    character(len=32) :: name
    ! Executable
    name = 'Anonymous'
    if ( present(subnam) ) name = subnam
    call MLSMessage( MLSMSG_Warning, name, chars, advance )
  end subroutine output_char

  subroutine output_dble( x, subnam, advance )
    double precision, intent(in) :: x
    character (len=*), optional, intent(in) :: subnam ! Name of module (see below)
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    ! Internal variables
    character(len=16) :: chars
    write(chars, *) x
    call output_char( chars, subnam, advance )
  end subroutine output_dble

  subroutine output_int( x, subnam, advance )
    integer, intent(in) :: x
    character (len=*), optional, intent(in) :: subnam ! Name of module (see below)
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    ! Internal variables
    character(len=16) :: chars
    write(chars, *) x
    call output_char( chars, subnam, advance )
  end subroutine output_int

  subroutine output_real( x, subnam, advance )
    real, intent(in) :: x
    character (len=*), optional, intent(in) :: subnam ! Name of module (see below)
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    ! Internal variables
    character(len=16) :: chars
    write(chars, *) x
    call output_char( chars, subnam, advance )
  end subroutine output_real

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: read_apriori.f90 is it here $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

END MODULE ERMSG_M

! $Log: ermsg_m.f90,v $
! Revision 2.6  2007/05/17 17:24:04  pwagner
! Forced to output via MLSMessage calls
!
! Revision 2.5  2005/06/22 17:25:48  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.4  2003/10/16 19:00:26  pwagner
! This version moved here from l1
!
! Revision 2.2  2003/01/31 18:13:34  perun
! Version 1.1 commit
!
! Then moved from l2 to lib
!
! Then removed
!
! Originally a Math77 routine
@


2.6
log
@Forced to output via MLSMessage calls
@
text
@d45 1
a45 1
       "$RCSfile: ermsg_m.f90,v $"
d494 1
a495 1
!---------------------------- RCS Ident Info -------------------------------
d497 2
a498 3
       "$Id: ermsg_m.f90,v 2.5 2005/06/22 17:25:48 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d500 1
d502 1
d507 3
@


2.5
log
@Reworded Copyright statement, moved rcs id
@
text
@d17 5
d23 1
d45 1
a45 1
       "$RCSfile: $"
d49 4
d59 4
a62 2
    WRITE (*,"(1X,72('$')/' ')")
    IF (ialpha >= 2) STOP
d203 2
a204 1
      WRITE (*,*) msg
d268 7
a274 3
      WRITE (*,"('0',72('$')/' SUBPROGRAM ',A,' REPORTS ERROR NO. ',I4)") &
        subnam, indic
      WRITE (*,*) msg
d427 7
a433 2
        WRITE(*,"(4(2x,a,'=',g14.7))") &
          (labels(k), values(k), k = i, MIN(SIZE(labels), i+number-1) )
d440 54
d497 1
a497 1
       "$Id: $"
d506 3
@


2.4
log
@This version moved here from l1
@
text
@d1 10
a10 2
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d37 3
a39 6
  !------------------------------- RCS Ident Info ------------------------------
  character(len=*), parameter :: IdParm = &
    & "$Id: DirectWrite_m.f90,v 2.12 2003/08/28 23:51:39 livesey Exp $"
  character(len=len(idParm)) :: Id = idParm
  character(len=*), parameter :: ModuleName = &
    & "$RCSfile: DirectWrite_m.f90,v $"
d41 1
a41 1
  !-----------------------------------------------------------------------------
d419 5
d430 3
@


2.3
log
@Moved from l2
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d4 1
a4 17
!=============================================================================
module ERMSG_M
!=============================================================================

  use OUTPUT_M, only: OUTPUT

  implicit NONE
  private

  public ERFIN, ERM1
  interface ERM1; module procedure IERM1, SERM1, DERM1; end interface
  public ERMN
  interface ERMN; module procedure IERMN, SERMN, DERMN; end interface
  public ERMOR, ERMSET, ERMSG, ERV1
  interface ERV1; module procedure IERV1, SERV1, DERV1; end interface
  public ERVN
  interface ERVN; module procedure IERVN, SERVN, DERVN; end interface
d6 18
a23 1
  integer, save, public :: IDELTA=0 ! increment to LEVEL to calculate
d25 1
a25 1
  integer, save, public :: OLDLEV=0 ! last value of LEVEL passed to ERMSG
d27 1
a27 1
  integer, save, private :: IALPHA  ! = IDELTA + LEVEL; used to determine
d29 1
a29 5

  integer, private, parameter :: MAXCOL = 75
  character(LEN=maxcol), private :: Output_line

!---------------------------- RCS Ident Info -------------------------------
d31 4
a34 4
       "$Id: ermsg_m.f90,v 2.6 2002/10/08 17:36:20 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: ermsg_m.f90,v $"
d36 1
a36 1
!---------------------------------------------------------------------------
d38 2
a39 2
contains
  subroutine ERFIN
d44 4
a47 7
!    write (*,"(1X,72('$')/' ')")
    write (output_line,"(1X,72('$'))")
    call output ( trim(output_line), advance='yes' )
    call output ( '', advance='yes' )
    if (ialpha >= 2) stop
    return
  end subroutine ERFIN
d49 1
a49 1
  subroutine IERM1 (SUBNAM, INDIC, LEVEL, MSG, LABEL, VALUE, FLAG)
d53 7
a59 7
    integer, intent(in) :: INDIC, LEVEL, VALUE
    character(LEN=*), intent(in) :: SUBNAM, MSG, LABEL
    character(LEN=1), intent(in) :: FLAG
    call ERMSG (SUBNAM, INDIC, LEVEL, MSG, ',')
    call ERV1 (LABEL, VALUE, FLAG)
    return
  end subroutine IERM1
d61 1
a61 1
  subroutine SERM1 (SUBNAM, INDIC, LEVEL, MSG, LABEL, VALUE, FLAG)
d65 8
a72 8
    integer, intent(in) :: INDIC, LEVEL
    real, intent(IN) :: VALUE
    character(LEN=*), intent(in) :: SUBNAM, MSG, LABEL
    character(LEN=1), intent(in) :: FLAG
    call ERMSG (SUBNAM, INDIC, LEVEL, MSG, ',')
    call ERV1 (LABEL, VALUE, FLAG)
    return
  end subroutine SERM1
d74 1
a74 1
  subroutine DERM1 (SUBNAM, INDIC, LEVEL, MSG, LABEL, VALUE, FLAG)
d78 8
a85 8
    integer, intent(in) :: INDIC, LEVEL
    double precision, intent(IN) :: VALUE
    character(LEN=*), intent(in) :: SUBNAM, MSG, LABEL
    character(LEN=1), intent(in) :: FLAG
    call ERMSG (SUBNAM, INDIC, LEVEL, MSG, ',')
    call ERV1 (LABEL, VALUE, FLAG)
    return
  end subroutine DERM1
d125 1
a125 1
  subroutine IERMN (SUBNAM, INDIC, LEVEL, MSG, LABELS, VALUES, FLAG)
d129 9
a137 9
    integer, intent(in) :: LEVEL, INDIC
    character(len=*), intent(in) :: SUBNAM, MSG, LABELS(:)
    character(len=1), intent(in) :: FLAG
    integer, intent(in) :: VALUES(:)

    call ermsg (subnam, indic, level,msg, ',')
    call ervn (labels, values, flag)
    return
  end subroutine IERMN
d139 1
a139 1
  subroutine SERMN (SUBNAM, INDIC, LEVEL, MSG, LABELS, VALUES, FLAG)
d143 9
a151 9
    integer, intent(in) :: LEVEL, INDIC
    character(len=*), intent(in) :: SUBNAM, MSG, LABELS(:)
    character(len=1), intent(in) :: FLAG
    real, intent(in) :: VALUES(:)

    call ermsg (subnam, indic, level,msg, ',')
    call ervn (labels, values, flag)
    return
  end subroutine SERMN
d153 1
a153 1
  subroutine DERMN (SUBNAM, INDIC, LEVEL, MSG, LABELS, VALUES, FLAG)
d157 9
a165 9
    integer, intent(in) :: LEVEL, INDIC
    character(len=*), intent(in) :: SUBNAM, MSG, LABELS(:)
    character(len=1), intent(in) :: FLAG
    double precision, intent(in) :: VALUES(:)

    call ermsg (subnam, indic, level,msg, ',')
    call ervn (labels, values, flag)
    return
  end subroutine DERMN
d167 1
a167 1
  subroutine ERMOR (MSG, FLAG)
d182 2
a183 2
    character(len=*), intent(in) :: MSG
    character(len=1), intent(in) :: FLAG
d185 6
a190 7
    if (ialpha >= -1) then
!     write (*,*) msg
      call output ( trim(msg), advance='yes' )
      if (flag == '.') call erfin
    end if
    return
  end subroutine ERMOR
d193 2
a194 2
  subroutine ERMSET (IDEL)
    integer, intent(in) :: IDEL
d196 2
a197 2
    return
  end subroutine ERMSET
d199 1
a199 1
  subroutine ERMSG (SUBNAM, INDIC, LEVEL, MSG, FLAG)
d243 3
a245 3
    integer, intent(in) :: LEVEL, INDIC
    character(len=*), intent(in) :: SUBNAM, MSG
    character(len=1), intent(in) :: FLAG
d249 8
a256 14
    if (ialpha >= -1) then
!      write (*,"('0',72('$')/' SUBPROGRAM ',A,' REPORTS ERROR NO. ',I4)") &
!        subnam, indic
!      write (*,*) msg
      write (output_line,"('0',72('$'))")
      call output ( trim(output_line), advance='yes' )
      write (output_line,"(' SUBPROGRAM ',A,' REPORTS ERROR NO. ', I4)") &
        & subnam, indic
      call output ( trim(output_line), advance='yes' )
      call output ( trim(msg), advance='yes' )
      if (flag == '.') call erfin
    end if
    return
  end subroutine ERMSG
d269 1
a269 1
  subroutine IERV1 (LABEL, VALUE, FLAG)
d272 10
a281 12
    integer, intent(in) :: VALUE
    character(len=*), intent(in) ::  LABEL
    character(len=1), intent(in) ::  FLAG

    if (ialpha >= -1) then
!      write (*,*) label, ' = ', value
      write (output_line,*) label, ' = ', value
      call output ( trim(output_line), advance='yes' )
      if (flag == '.') call erfin
    end if
    return
  end subroutine IERV1
d283 1
a283 1
  subroutine SERV1 (LABEL, VALUE, FLAG)
d286 10
a295 12
    real, intent(in) :: VALUE
    character(len=*), intent(in) ::  LABEL
    character(len=1), intent(in) ::  FLAG

    if (ialpha >= -1) then
!      write (*,*) label, ' = ', value
      write (output_line,*) label, ' = ', value
      call output ( trim(output_line), advance='yes' )
      if (flag == '.') call erfin
    end if
    return
  end subroutine SERV1
d297 1
a297 1
  subroutine DERV1 (LABEL, VALUE, FLAG)
d300 10
a309 12
    double precision, intent(in) :: VALUE
    character(len=*), intent(in) ::  LABEL
    character(len=1), intent(in) ::  FLAG

    if (ialpha >= -1) then
!      write (*,*) label, ' = ', value
      write (output_line,*) label, ' = ', value
      call output ( trim(output_line), advance='yes' )
      if (flag == '.') call erfin
    end if
    return
  end subroutine DERV1
d329 1
a329 1
  subroutine IERVN (LABELS, VALUES, FLAG)
d338 3
a340 3
    character(LEN=*), intent(in) :: LABELS(:)
    integer, intent(in) :: VALUES(SIZE(LABELS))
    character(LEN=1), intent(in) :: FLAG
d342 2
a343 1
    integer I, K, LENIDV, NUMBER
d345 2
a346 2
    if (ialpha >= -1) then
      lenidv = len (labels)
d348 8
a355 9
      do i = 1, size(labels), number
        write (output_line,"(4(2x,a,'=',i14))") &
          (labels(k), values(k), k = i, min(size(labels), i+number-1) )
        call output ( trim(output_line), advance='yes' )
      end do
      if (flag == '.') call erfin
    end if
    return
  end subroutine IERVN
d357 1
a357 1
  subroutine SERVN (LABELS, VALUES, FLAG)
d366 3
a368 3
    character(LEN=*), intent(in) :: LABELS(:)
    real, intent(in) :: VALUES(SIZE(LABELS))
    character(LEN=1), intent(in) :: FLAG
d370 2
a371 1
    integer I, K, LENIDV, NUMBER
d373 2
a374 2
    if (ialpha >= -1) then
      lenidv = len (labels)
d376 8
a383 9
      do i = 1, size(labels), number
        write (output_line,"(4(2x,a,'=',g14.7))") &
          (labels(k), values(k), k = i, min(size(labels), i+number-1) )
        call output ( trim(output_line), advance='yes' )
      end do
      if (flag == '.') call erfin
    end if
    return
  end subroutine SERVN
d385 1
a385 1
  subroutine DERVN (LABELS, VALUES, FLAG)
d394 3
a396 3
    character(LEN=*), intent(in) :: LABELS(:)
    double precision, intent(in) :: VALUES(SIZE(LABELS))
    character(LEN=1), intent(in) :: FLAG
d398 2
a399 1
    integer I, K, LENIDV, NUMBER
d401 2
a402 2
    if (ialpha >= -1) then
      lenidv = len (labels)
d404 9
a412 9
      do i = 1, size(labels), number
        write (output_line,"(4(2x,a,'=',g14.7))") &
          (labels(k), values(k), k = i, min(size(labels), i+number-1) )
        call output ( trim(output_line), advance='yes' )
      end do
      if (flag == '.') call erfin
    end if
    return
  end subroutine DERVN
d417 1
a417 1
end module ERMSG_M
d420 2
a421 14
! Revision 2.6  2002/10/08 17:36:20  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.5  2002/01/18 00:28:39  vsnyder
! Account for '/' in formats
!
! Revision 2.4  2002/01/18 00:25:17  livesey
! Another attempt to fix the string bug, seems to work now.
!
! Revision 2.3  2002/01/17 17:32:53  livesey
! Made output_line a lot bigger
!
! Revision 2.2  2002/01/09 00:00:04  pwagner
! Replaced write or print statements with calls to output
d423 1
a423 2
! Revision 2.1  2001/02/06 23:21:28  vsnyder
! Initial conversion from Math77 to Fortran 90
d425 1
a425 2
! Revision 1.2  2000/05/04 23:39:24  vsnyder
! Initial conversion to Fortran 90 from Math 77 library
d427 1
@


2.2
log
@Superseded by the copy in l2
@
text
@d1 4
d6 4
a9 3
!     .  Copyright (C) 1989-1999, California Institute of Technology.
!     .  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.
d13 1
a13 1
  public ERFIN, ERM1, IERM1, SERM1, DERM1
d15 1
a15 1
  public ERMN, IERMN, SERMN, DERMN
d17 1
a17 1
  public ERMOR, ERMSET, ERMSG, ERV1, IERV1, SERV1, DERV1
d19 1
a19 1
  public ERVN, IERVN, SERVN, DERVN
d29 3
d33 4
a36 4
  character (len=*), private, parameter :: IdParm = &
       "$Id: ermsg_m.f90,v 2.1 2001/09/20 22:58:55 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
  character (len=*), private, parameter :: ModuleName= &
d38 1
d47 4
a50 1
    write (*,"(1X,72('$')/' ')")
d192 2
a193 1
      write (*,*) msg
d257 9
a265 3
      write (*,"('0',72('$')/' SUBPROGRAM ',A,' REPORTS ERROR NO. ',I4)") &
        subnam, indic
      write (*,*) msg
d267 1
a267 1
    endif
d290 3
a292 1
      write (*,*) label, ' = ', value
d306 3
a308 1
      write (*,*) label, ' = ', value
d322 3
a324 1
      write (*,*) label, ' = ', value
a361 1
    integer, parameter :: MAXCOL = 75
d367 1
a367 1
        write(*,"(4(2x,a,'=',i14))") &
d369 1
d372 1
a372 1
    endif
a389 1
    integer, parameter :: MAXCOL = 75
d395 1
a395 1
        write(*,"(4(2x,a,'=',g14.7))") &
d397 1
d400 1
a400 1
    endif
a417 1
    integer, parameter :: MAXCOL = 75
d423 1
a423 1
        write(*,"(4(2x,a,'=',g14.7))") &
d425 1
d428 1
a428 1
    endif
d431 4
d436 23
@


2.1
log
@Original commit of converted Math77 routine
@
text
@d26 1
a26 1
       "$Id: VectorsModule.f90,v 2.52 2001/09/20 20:56:34 pwagner Exp $"
d29 1
a29 1
       "$RCSfile: VectorsModule.f90,v $"
@

