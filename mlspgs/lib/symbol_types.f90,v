head	2.21;
access;
symbols
	v5-02-NRT-19:2.21
	v6-00:2.21
	v5-02-NRT-18:2.21
	v5-02:2.21
	v5-01-NRT-17:2.21
	v5-01-NRT-16:2.21
	v5-01-NRT-15:2.21
	v5-01-NRT-14:2.21
	neuralnetworks-1-0:2.21.0.4
	cfm-single-freq-0-1:2.21.0.2
	v5-01:2.21
	v5-00:2.21
	v4-23-TA133:2.20.0.8
	mus-emls-1-70:2.20.0.6
	rel-1-0-englocks-work:2.20.0.4
	VUMLS1-00:2.20
	VPL1-00:2.20
	V4-22-NRT-08:2.20
	VAM1-00:2.20
	V4-21:2.20.0.2
	V4-13:2.20
	V4-12:2.20
	V4-11:2.20
	V4-10:2.20
	V3-43:2.10
	M4-00:2.15
	V3-41:2.10
	V3-40-PlusGM57:2.10.0.2
	V2-24-NRT-04:2.9
	V3-33:2.10
	V2-24:2.9
	V3-31:2.10
	V3-30-NRT-05:2.10
	cfm-01-00:2.10
	V3-30:2.10
	V3-20:2.10
	V3-10:2.10
	V2-23-NRT-02:2.9
	V2-23:2.9
	V2-22-NRT-01:2.9
	V2-22:2.9
	V2-21:2.9
	V2-20:2.9
	V2-11:2.9
	V2-10:2.9
	V2-00:2.9
	V1-51:2.8
	V1-50:2.8
	V1-45:2.8
	V1-44:2.8
	V1-43:2.7
	V1-42:2.5
	V1-41:2.5
	V1-32:2.5
	V1-40:2.5
	V1-31:2.5
	V1-30:2.5
	V1-13:2.5
	V1-12:2.5
	V1-11:2.5
	V1-10:2.5
	newfwm-feb03:2.5.0.2
	V1-04:2.4
	V1-03:2.4
	V1-02:2.4
	V1-00:2.4
	newfwm-sep01:2.4.0.2
	V0-7:2.4
	V0-5-Level2:2.4
	V0-5-SIPS:2.4;
locks; strict;
comment	@# @;


2.21
date	2019.06.12.00.14.19;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2014.02.21.19.22.15;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2013.12.12.01.58.00;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2013.11.26.22.42.32;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2013.10.02.01.33.10;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2013.09.24.23.27.14;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2012.05.05.00.11.51;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2012.05.01.22.12.43;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2012.05.01.22.10.26;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2011.04.19.01.59.43;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2011.04.18.19.33.26;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2009.06.23.18.25.44;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2004.05.28.23.12.21;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2004.04.26.21.55.29;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2004.01.14.18.32.58;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2002.10.08.00.09.14;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2000.11.30.20.18.47;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2000.11.30.00.31.12;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2000.11.30.00.23.10;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.11.18.33.25;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.21
log
@Mostly repairing comments
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module SYMBOL_TYPES

!  Type definitions for the symbol table.


  use STRING_TABLE, only: ADD_CHAR

  implicit NONE
  public

  ! Terminal symbol identifiers.  These depend on the language.

  ! The named constants declared here are related to the terminal symbols of
  ! the grammar using the table before the productions in l2cf.grm.

  ! If this list changes, you need to change the array TERM_TYPES below.

  integer, parameter :: T_NULL             = 0    ! MUST be present and first
  integer, parameter :: T_LEFT_PARENTHESIS = T_NULL + 1
  integer, parameter :: T_RIGHT_PARENTHESIS = T_LEFT_PARENTHESIS + 1
  integer, parameter :: T_LEFT_BRACKET =     T_RIGHT_PARENTHESIS + 1
  integer, parameter :: T_RIGHT_BRACKET =    T_LEFT_BRACKET + 1
  integer, parameter :: T_PLUS =             T_RIGHT_BRACKET + 1
  integer, parameter :: T_MINUS =            T_PLUS + 1
  integer, parameter :: T_STAR =             T_MINUS + 1
  integer, parameter :: T_SLASH =            T_STAR + 1
  integer, parameter :: T_ASSIGN =           T_SLASH + 1
  integer, parameter :: T_BACKSLASH =        T_ASSIGN + 1
  integer, parameter :: T_BANG =             T_BACKSLASH + 1
  integer, parameter :: T_COND =             T_BANG + 1
  integer, parameter :: T_DOT =              T_COND + 1
  integer, parameter :: T_COLON =            T_DOT + 1
  integer, parameter :: T_COLON_LESS =       T_COLON + 1
  integer, parameter :: T_LESS_COLON =       T_COLON_LESS + 1
  integer, parameter :: T_LESS_COLON_LESS =  T_LESS_COLON + 1
  integer, parameter :: T_EQUAL =            T_LESS_COLON_LESS + 1
  integer, parameter :: T_EQUAL_EQUAL =      T_EQUAL + 1
  integer, parameter :: T_NOT_EQUAL =        T_EQUAL_EQUAL + 1
  integer, parameter :: T_LESS =             T_NOT_EQUAL + 1
  integer, parameter :: T_LESS_EQ =          T_LESS + 1
  integer, parameter :: T_GREATER =          T_LESS_EQ + 1
  integer, parameter :: T_GREATER_EQ =       T_GREATER + 1
  integer, parameter :: T_COMMA =            T_GREATER_EQ + 1
  integer, parameter :: T_HAT =              T_COMMA + 1
  integer, parameter :: T_BEGIN =            T_HAT + 1           ! BEGIN
  integer, parameter :: T_CYCLE =            T_BEGIN + 1         ! CYCLE
  integer, parameter :: T_DO =               T_CYCLE + 1         ! DO
  integer, parameter :: T_END =              T_DO + 1            ! END
  integer, parameter :: T_EXIT =             T_END + 1           ! EXIT
  integer, parameter :: T_AND =              T_EXIT + 1          ! AND
  integer, parameter :: T_OR =               T_AND + 1           ! OR
  integer, parameter :: T_NOT =              T_OR + 1            ! NOT
  integer, parameter :: T_CASE =             T_NOT + 1           ! CASE
  integer, parameter :: T_DEFAULT =          T_CASE + 1          ! DEFAULT
  integer, parameter :: T_ELSE =             T_DEFAULT + 1       ! ELSE
  integer, parameter :: T_IF =               T_ELSE + 1          ! IF
  integer, parameter :: T_SELECT =           T_IF + 1            ! SELECT
  integer, parameter :: T_THEN =             T_SELECT + 1        ! THEN
  integer, parameter :: T_WHILE =            T_THEN + 1          ! WHILE
  integer, parameter :: T_END_OF_INPUT =     T_WHILE + 1         ! <EOF>
  integer, parameter :: T_END_OF_STMT =      T_END_OF_INPUT + 1  ! <EOS>
  ! T_IDENTIFIER, T_NUMBER, T_STRING must be consecutive
  integer, parameter :: T_IDENTIFIER =       T_END_OF_STMT + 1   ! <IDENTIFIER>
  integer, parameter :: T_NUMBER =           T_IDENTIFIER + 1    ! <NUMBER>
  integer, parameter :: T_STRING =           T_NUMBER + 1        ! <STRING>
  integer, parameter :: T_INCLUDE =          T_STRING + 1        ! #include
  integer, parameter :: T_UNK_OP =           T_INCLUDE + 1       ! unknown operator
  integer, parameter :: T_UNK_PUN =          T_UNK_OP + 1        ! unknown punctuator
  integer, parameter :: T_UNK_CH =           T_UNK_PUN + 1       ! unknown character
  integer, parameter :: T_INC_NUM =          T_UNK_CH + 1        ! incomplete number
  integer, parameter :: T_INC_STR =          T_INC_NUM + 1       ! incomplete string
  integer, parameter :: T_AFT_CONT =         T_INC_STR + 1       ! junk after continuation

! The parameters T_LAST_TERMINAL, MIN_PSEUDO, MAX_PSEUDO and CASELESS_LOOK
! MUST be defined.
  integer, parameter :: T_LAST_TERMINAL = T_AFT_CONT

  integer, parameter :: MIN_PSEUDO = T_IDENTIFIER
  integer, parameter :: MAX_PSEUDO = T_STRING

  integer, private :: I ! Only a loop inductor in the next declaration
! Indicates which terminals use caseless lookup
  logical, parameter :: CASELESS_LOOK(t_null:t_last_terminal) = &
    (/ ( .false., i = t_null, min_pseudo-1 ), &
       ( .true., i = min_pseudo, t_string-1 ), &
       .false., & ! t_string is case sensitive
       ( .true., i = t_string+1, max_pseudo ), &
       ( .false., i = max_pseudo+1, t_last_terminal ) /)

! Terminal symbol types.

  integer, parameter :: RES_WORD = 1              ! Reserved word
  integer, parameter :: IDENT =    RES_WORD + 1   ! Identifier
  integer, parameter :: NUMCON =   IDENT + 1      ! Numeric constant
  integer, parameter :: STRING =   NUMCON + 1     ! String in quotes
  integer, parameter :: UNIT =     STRING + 1     ! A unit name, e.g. mb
  integer, parameter :: DEF_OP =   UNIT + 1       ! Defined operator
  integer, parameter :: UNK_OP =   DEF_OP + 1     ! Unefined operator
  integer, parameter :: DEF_PUN =  UNK_OP + 1     ! Defined punctuator
  integer, parameter :: UNK_PUN =  DEF_PUN + 1    ! Undefined punctuator
  integer, parameter :: INC_NUM =  UNK_PUN + 1    ! Incomplete number
  integer, parameter :: INC_STR =  INC_NUM + 1    ! Incomplete string
  integer, parameter :: UNK_CH =   INC_STR + 1    ! Unknown character
  integer, parameter :: AFT_CONT = UNK_CH + 1     ! After continuation
  integer, parameter :: TREENODE = AFT_CONT + 1   ! Tree node
  integer, parameter :: OBJECT =   TREENODE + 1   ! None of the above

  integer, parameter :: FIRST_TYPE = RES_WORD
  integer, parameter :: LAST_TYPE = OBJECT

! The array TERM_TYPES gives the terminal type of each class of terminal. It
! must be defined.  It is indexed by the terminal symbol names declared
! above.  The lists MUST correspond.  It might be more reliable to use a DATA
! statement, and make TERM_TYPES a protected variable instead of a named
! constant.  If using DATA statements, maybe one for each element, you would
! need to be careful to define every element of the array.  Pay your money
! and take your choice.
  integer, parameter :: TERM_TYPES(t_null: t_last_terminal) = &
  !                                          
  (/ object,   &  ! t_null     T_NULL
     def_pun,  &  ! (          T_LEFT_PARENTHESIS
     def_pun,  &  ! )          T_RIGHT_PARENTHESIS
     def_pun,  &  ! [          T_LEFT_BRACKET
     def_pun,  &  ! ]          T_RIGHT_BRACKET
     def_op,   &  ! +          T_PLUS
     def_op,   &  ! -          T_MINUS
     def_op,   &  ! *          T_STAR
     def_op,   &  ! /          T_SLASH
     def_op,   &  ! :=         T_ASSIGN
     def_op,   &  ! \          T_BACKSLASH
     def_op,   &  ! !          T_BANG
     def_op,   &  ! ?          T_COND
     def_op,   &  ! .          T_DOT
     def_op,   &  ! :          T_COLON
     def_op,   &  ! :<         T_COLON_LESS
     def_op,   &  ! <:         T_LESS_COLON
     def_op,   &  ! <:<        T_LESS_COLON_LESS
     def_op,   &  ! =          T_EQUAL
     def_op,   &  ! ==         T_EQUAL_EQUAL
     def_op,   &  ! /=         T_NOT_EQUAL
     def_op,   &  ! <          T_LESS
     def_op,   &  ! <=         T_LESS_EQ
     def_op,   &  ! >          T_GREATER
     def_op,   &  ! >=         T_GREATER_EQ
     def_pun,  &  ! ,          T_COMMA
     def_op,   &  ! ^          T_HAT
     res_word, &  ! begin      T_BEGIN
     res_word, &  ! cycle      T_CYCLE
     res_word, &  ! do         T_DO
     res_word, &  ! end        T_END
     res_word, &  ! exit       T_EXIT
     res_word, &  ! and        T_AND
     res_word, &  ! or         T_OR
     res_word, &  ! not        T_NOT
     res_word, &  ! case       T_CASE
     res_word, &  ! default    T_DEFAULT
     res_word, &  ! else       T_ELSE
     res_word, &  ! if         T_IF
     res_word, &  ! select     T_SELECT
     res_word, &  ! then       T_THEN
     res_word, &  ! while      T_WHILE
     object,   &  ! <eof>      T_END_OF_INPUT
     object,   &  ! <eos>      T_END_OF_STMT
     ident,    &  ! <ident>    T_IDENTIFIER
     numcon,   &  ! <numcon>   T_NUMBER
     string,   &  ! <string>   T_STRING
     def_op,   &  ! include    T_INCLUDE
     unk_op,   &  ! unk_op     T_UNK_OP
     unk_pun,  &  ! unk_pun    T_UNK_PUN
     unk_ch,   &  ! unk_ch     T_UNK_CH
     inc_num,  &  ! inc_num    T_INC_NUM
     inc_str,  &  ! inc_str    T_INC_STR
     aft_cont  /) ! junk       T_AFT_CONT

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: symbol_types.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  subroutine INIT_TERMINAL ( TERMINAL )
  ! Put the text of a terminal symbol into the string table. It isn't
  ! necessary to have more than zero characters of text for things that
  ! aren't terminals (e.g. t_null and errors), or for things that are
  ! pseudo-terminals (e.g. identifier, integer).  Texts consisting of
  ! "< description >" cannot possibly be created by the lexer
    integer, intent(in) :: TERMINAL
    select case ( terminal )
    case ( t_null );              call add_char ( '' )
    case ( t_left_parenthesis );  call add_char ( '(' )
    case ( t_right_parenthesis ); call add_char ( ')' )
    case ( t_left_bracket );      call add_char ( '[' )
    case ( t_right_bracket );     call add_char ( ']' )
    case ( t_plus );              call add_char ( '+' )
    case ( t_minus );             call add_char ( '-' )
    case ( t_star );              call add_char ( '*' )
    case ( t_slash );             call add_char ( '/' )
    case ( t_assign );            call add_char ( ':=' )
    case ( t_backslash );         call add_char ( '\' )
    case ( t_bang );              call add_char ( '!' )
    case ( t_cond );              call add_char ( '?' )
    case ( t_dot );               call add_char ( '.' )
    case ( t_colon );             call add_char ( ':' )
    case ( t_less_colon );        call add_char ( '<:' )
    case ( t_colon_less );        call add_char ( ':<' )
    case ( t_less_colon_less );   call add_char ( '<:<' )
    case ( t_equal );             call add_char ( '=' )
    case ( t_equal_equal );       call add_char ( '==' )
    case ( t_not_equal );         call add_char ( '/=' )
    case ( t_less );              call add_char ( '<' )
    case ( t_less_eq );           call add_char ( '<=' )
    case ( t_greater );           call add_char ( '>' )
    case ( t_greater_eq );        call add_char ( '>=' )
    case ( t_comma );             call add_char ( ',' )
    case ( t_hat );               call add_char ( '^' )
    case ( t_begin );             call add_char ( 'BEGIN' )
    case ( t_cycle );             call add_char ( 'CYCLE' )
    case ( t_do );                call add_char ( 'DO' )
    case ( t_end );               call add_char ( 'END' )
    case ( t_exit );              call add_char ( 'EXIT' )
    case ( t_and );               call add_char ( 'AND' )
    case ( t_or );                call add_char ( 'OR' )
    case ( t_not );               call add_char ( 'NOT' )
    case ( t_case );              call add_char ( 'CASE' )
    case ( t_default );           call add_char ( 'DEFAULT' )
    case ( t_else );              call add_char ( 'ELSE' )
    case ( t_if );                call add_char ( 'IF' )
    case ( t_select );            call add_char ( 'SELECT' )
    case ( t_then );              call add_char ( 'THEN' )
    case ( t_while );             call add_char ( 'WHILE' )
    case ( t_end_of_input );      call add_char ( '<eof>' )
    case ( t_end_of_stmt );       call add_char ( '<eos>' )
    case ( t_identifier );        call add_char ( '<identifier>' )
    case ( t_number );            call add_char ( '<number>' )
    case ( t_string );            call add_char ( '<string>' )
    case ( t_include );           call add_char ( '#include' )
    case ( t_unk_op );            call add_char ( '<unk_op>' )
    case ( t_unk_pun );           call add_char ( '<unk_pun>' )
    case ( t_unk_ch );            call add_char ( '<unk_ch>' )
    case ( t_inc_num );           call add_char ( '<inc num>' )
    case ( t_inc_str );           call add_char ( '<inc str>' )
    case ( t_aft_cont );          call add_char ( '<aft>' )
    case default
      write ( *, * ) 'SYMBOL_TYPES%INIT_TERMINAL-E- No initializer for &
                     &terminal symbol with index ', terminal
      stop
    end select
  end subroutine INIT_TERMINAL

  subroutine INIT_TYPE ( TYPE )
  ! Put the text of a terminal symbol type into the string table.  These
  ! are used only for debugging output.
    integer, intent(in) :: TYPE
    select case ( type )
    case ( res_word );  call add_char ( '<reserved word>' )
    case ( ident );     call add_char ( '<identifier>' )
    case ( numcon );    call add_char ( '<number>' )
    case ( string );    call add_char ( '<string>' )
    case ( unit );      call add_char ( '<unit name>' )
    case ( def_op );    call add_char ( '<defined operator>' )
    case ( unk_op );    call add_char ( '<undefined operator>' )
    case ( def_pun );   call add_char ( '<defined punctuator>' )
    case ( unk_pun );   call add_char ( '<undefined punctuator>' )
    case ( inc_num );   call add_char ( '<incomplete number>' )
    case ( inc_str );   call add_char ( '<incomplete string>' )
    case ( unk_ch );    call add_char ( '<unrecognized character>' )
    case ( aft_cont );  call add_char ( '<after continuation>' )
    case ( treeNode);   call add_char ( '<tree node>' )
    case ( object );    call add_char ( '<object>' )
    case default
      write ( *, * ) 'SYMBOL_TYPES%INIT_TYPE-E- No initializer for &
                     &terminal symbol type with index ', type
      stop
    end select
  end subroutine INIT_TYPE

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: symbol_types.f90,v 2.20 2014/02/21 19:22:15 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module SYMBOL_TYPES

! $Log: symbol_types.f90,v $
! Revision 2.20  2014/02/21 19:22:15  vsnyder
! Add CYCLE, DO, EXIT, WHILE
!
! Revision 2.19  2013/12/12 01:58:00  vsnyder
! Add variable definition, and IF and SELECT constructs
!
! Revision 2.18  2013/11/26 22:42:32  vsnyder
! Add CASE, DEFAULT, ELSE, IF, SELECT, THEN reserved words
!
! Revision 2.17  2013/10/02 01:33:10  vsnyder
! Add :=, ? and ! symbols for variable assignment  and conditional expressions
!
! Revision 2.16  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.15  2012/05/05 00:11:51  vsnyder
! Add support for 'not' operator
!
! Revision 2.14  2012/05/01 22:12:43  vsnyder
! Add comment about token names being used in parser
!
! Revision 2.13  2012/05/01 22:10:26  vsnyder
! Add TrueList subroutine
!
! Revision 2.12  2011/04/19 01:59:43  vsnyder
! Support == and /= relational operators too
!
! Revision 2.11  2011/04/18 19:33:26  vsnyder
! Add support for relational operators and boolean-valued expressions
!
! Revision 2.10  2009/06/23 18:25:44  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.9  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.8  2004/05/28 23:12:21  vsnyder
! Add power (^) operator
!
! Revision 2.7  2004/04/26 21:55:29  vsnyder
! Make strings case sensitive
!
! Revision 2.6  2004/01/14 18:32:58  vsnyder
! Stuff for Algebra module
!
! Revision 2.5  2002/10/08 00:09:14  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.4  2000/11/30 20:18:47  vsnyder
! Added <: :< and <:< operators.
!
! Revision 2.3  2000/11/30 00:31:12  vsnyder
! Make [] punctuators instead of operators.
!
! Revision 2.2  2000/11/30 00:23:10  vsnyder
! Implement [] syntax for arrays
!
! Revision 2.1  2000/10/11 18:33:25  vsnyder
! Move from lib/cf_parser to lib; insert copyright notice
!
! Revision 2.0  2000/09/05 17:41:51  dcuddy
! Change revision to 2.0
!
! Revision 1.1  2000/07/06 01:43:12  vsnyder
! Initial check-in
!
@


2.20
log
@Add CYCLE, DO, EXIT, WHILE
@
text
@a15 2
!  The terminal symbols of the grammar.  The corresponding constants
!  must be typed into the grammar as integer literal values.
d22 7
a28 3
  ! Terminal symbol class numbers.  These depend on the language. If this
  ! list changes, you need to change the array TERM_TYPES below, and might
  ! need to change the table GEN, indexed by them, in parser.
d122 7
a128 2
! The array TERM_TYPES gives the terminal type of each class of terminal.
! It must be defined.
d198 2
a199 1
  ! pseudo-terminals (e.g. identifier, integer).
a260 1
    return
d285 1
a285 1
                     &type with index ', type
a287 1
    return
d293 1
a293 1
       "$Id: symbol_types.f90,v 2.19 2013/12/12 01:58:00 vsnyder Exp $"
d303 3
@


2.19
log
@Add variable definition, and IF and SELECT constructs
@
text
@d27 1
a27 1
  integer, parameter :: T_NULL = 0                ! MUST be present and first
d55 5
a59 2
  integer, parameter :: T_END =              T_BEGIN + 1         ! END
  integer, parameter :: T_AND =              T_END + 1           ! AND
d67 3
a69 2
  integer, parameter :: T_THEN =             T_SELECT + 1        ! THRN
  integer, parameter :: T_END_OF_INPUT =     T_THEN + 1          ! <EOF>
d123 55
a177 16
  !  t_null    (         )         [         ]         +         -
  (/ object,   def_pun,  def_pun,  def_pun,  def_pun,  def_op,   def_op,   &
  !  *         /         :=        \         !         ?         .         
     def_op,   def_op,   def_op,   def_op,   def_op,   def_op,   def_op,   &
  !  :         :<        <:        <:<       =         ==        /=        
     def_op,   def_op,   def_op,   def_op,   def_op,   def_op,   def_op,   &
  !  <         <=        >         >=        ,         ^         begin     
     def_op,   def_op,   def_op,   def_op,   def_pun,  def_op,   res_word, &
  !  end       and       or        not       case      default   else      
     res_word, res_word, res_word, res_word, res_word, res_word, res_word, &
  !  if        select    then      <eof>     <eos>     <ident>   <numcon>  
     res_word, res_word, res_word, object,   object,   ident,    numcon,   &
  !  <string>  include   unk_op    unk_pun   unk_ch    inc_num   inc_str   
     string,   def_op,   unk_op,   unk_pun,  unk_ch,   inc_num,  inc_str,  &
  !  junk
     aft_cont  /)
d222 2
d225 1
d235 1
d287 1
a287 1
       "$Id: symbol_types.f90,v 2.18 2013/11/26 22:42:32 vsnyder Exp $"
d297 3
@


2.18
log
@Add CASE, DEFAULT, ELSE, IF, SELECT, THEN reserved words
@
text
@d95 1
a95 1
! Terminal symbol types.  These are used for debug printing.
d110 2
a111 1
  integer, parameter :: OBJECT =   AFT_CONT + 1   ! None of the above
a222 1
    case ( unk_ch );    call add_char ( '<unrecognized character>' )
d225 1
d227 1
d240 1
a240 1
       "$Id: symbol_types.f90,v 2.17 2013/10/02 01:33:10 vsnyder Exp $"
d250 3
@


2.17
log
@Add :=, ? and ! symbols for variable assignment  and conditional expressions
@
text
@d59 7
a65 1
  integer, parameter :: T_END_OF_INPUT =     T_NOT + 1           ! <EOF>
d126 9
a134 6
  !  end       and       or        not       <eof>     <eos>     <ident>   
     res_word, res_word, res_word, res_word, object,   object,   ident,    &
  !  <numcon>  <string>  include   unk_op    unk_pun   unk_ch    inc_num   
     numcon,   string,   def_op,   unk_op,   unk_pun,  unk_ch,   inc_num,  &
  !  inc_str   junk
     inc_str,  aft_cont  /)
d182 6
d238 1
a238 1
       "$Id: symbol_types.f90,v 2.16 2013/09/24 23:27:14 vsnyder Exp $"
d248 3
@


2.16
log
@Use Get_Where or Print_Source to start error messages
@
text
@d36 5
a40 2
  integer, parameter :: T_BACKSLASH =        T_SLASH + 1
  integer, parameter :: T_DOT =              T_BACKSLASH + 1
d114 1
a114 1
  !  *         /         \         .         :         :<        <:      
d116 1
a116 1
  !  <:<       =         ==        /=        <         <=        >
d118 8
a125 7
  !  >=        ,         ^         begin     end       and       or
     def_op,   def_pun,  def_op,   res_word, res_word, res_word, res_word, &
  !  or        <eof>     <eos>     <ident>   <numcon>  <string>  include 
     res_word, object,   object,   ident,    numcon,   string,   def_op,   &
  !  unk_op  unk_pun   unk_ch    inc_num   inc_str   junk
     unk_op, unk_pun,  unk_ch,   inc_num,  inc_str,  aft_cont /)

d150 1
d152 2
d219 1
d223 1
a223 1
       "$Id: symbol_types.f90,v 2.15 2012/05/05 00:11:51 vsnyder Exp $"
d233 3
@


2.15
log
@Add support for 'not' operator
@
text
@d62 2
a63 1
  integer, parameter :: T_UNK_OP =           T_STRING + 1        ! unknown operator
d117 4
a120 4
  !  or        <eof>     <eos>     <ident>   <numcon>  <string>  unk_op  
     res_word, object,   object,   ident,    numcon,   string,   unk_op,   &
  !  unk_pun   unk_ch    inc_num   inc_str   junk
     unk_pun,  unk_ch,   inc_num,  inc_str,  aft_cont /)
d171 1
d215 1
a215 1
       "$Id: symbol_types.f90,v 2.14 2012/05/01 22:12:43 vsnyder Exp $"
d225 3
@


2.14
log
@Add comment about token names being used in parser
@
text
@d25 2
a26 1
  ! list changes, you might need to change the table indexed by them in parser.
d55 2
a56 1
  integer, parameter :: T_END_OF_INPUT =     T_OR + 1            ! <EOF>
d116 4
a119 4
  !  <eof>     <eos>     <ident>   <numcon>  <string>  unk_op    unk_pun
     object,   object,   ident,    numcon,   string,   unk_op,   unk_pun,  &
  !  unk_ch    inc_num   inc_str   junk
     unk_ch,   inc_num,  inc_str,  aft_cont /)
d164 1
d213 1
a213 1
       "$Id: symbol_types.f90,v 2.13 2012/05/01 22:10:26 vsnyder Exp $"
d223 3
@


2.13
log
@Add TrueList subroutine
@
text
@d24 2
a25 2
  ! Terminal symbol class numbers.  These depend on the language.
  ! If this list changes, change the table indexed by them in parser.
d210 1
a210 1
       "$Id: symbol_types.f90,v 2.12 2011/04/19 01:59:43 vsnyder Exp $"
d220 3
@


2.12
log
@Support == and /= relational operators too
@
text
@d25 1
d108 1
a108 1
  !  *         /         \         .         :         <:        :<      
d210 1
a210 1
       "$Id: symbol_types.f90,v 2.11 2011/04/18 19:33:26 vsnyder Exp $"
d220 3
@


2.11
log
@Add support for relational operators and boolean-valued expressions
@
text
@d41 3
a43 1
  integer, parameter :: T_LESS =             T_EQUAL + 1
d109 8
a116 8
  !  <:<       =         <         <=        >         >=        ,
     def_op,   def_op,   def_op,   def_op,   def_op,   def_op,   def_pun,  &
  !  ^         begin     end       and       or        <eof>     <eos>
     def_op,   res_word, res_word, res_word, res_word, object,   object,   &
  !  <ident>   <numcon>  <string>  unk_op    unk_pun     unk_ch    inc_num
     ident,    numcon,   string,   unk_op,   unk_pun,    unk_ch,   inc_num,&
  !  inc_str   junk
     inc_str,  aft_cont /)
d149 2
d209 1
a209 1
       "$Id: symbol_types.f90,v 2.10 2009/06/23 18:25:44 pwagner Exp $"
d219 3
@


2.10
log
@Prevent Intel from optimizing ident string away
@
text
@d26 37
a62 32
  integer, parameter :: T_LEFT_PARENTHESIS = 1
  integer, parameter :: T_RIGHT_PARENTHESIS = 2
  integer, parameter :: T_LEFT_BRACKET = 3
  integer, parameter :: T_RIGHT_BRACKET = 4
  integer, parameter :: T_PLUS = 5
  integer, parameter :: T_MINUS = 6
  integer, parameter :: T_STAR = 7
  integer, parameter :: T_SLASH = 8
  integer, parameter :: T_BACKSLASH = 9
  integer, parameter :: T_DOT = 10
  integer, parameter :: T_COLON = 11
  integer, parameter :: T_COLON_LESS = 12
  integer, parameter :: T_LESS_COLON = 13
  integer, parameter :: T_LESS_COLON_LESS = 14
  integer, parameter :: T_EQUAL = 15
  integer, parameter :: T_COMMA = 16
  integer, parameter :: T_HAT = 17
  integer, parameter :: T_BEGIN = 18              ! BEGIN
  integer, parameter :: T_END = 19                ! END
  integer, parameter :: T_AND = 20                ! AND
  integer, parameter :: T_OR = 21                 ! OR
  integer, parameter :: T_END_OF_INPUT = 22       ! <EOF>
  integer, parameter :: T_END_OF_STMT = 23        ! <EOS>
  integer, parameter :: T_IDENTIFIER = 24         ! <IDENTIFIER>
  integer, parameter :: T_NUMBER = 25             ! <NUMBER>
  integer, parameter :: T_STRING = 26             ! <STRING>
  integer, parameter :: T_UNK_OP = 27             ! unknown operator
  integer, parameter :: T_UNK_PUN = 28            ! unknown punctuator
  integer, parameter :: T_UNK_CH = 29             ! unknown character
  integer, parameter :: T_INC_NUM = 30            ! incomplete number
  integer, parameter :: T_INC_STR = 31            ! incomplete string
  integer, parameter :: T_AFT_CONT = 32           ! junk after continuation
d83 13
a95 13
  integer, parameter :: IDENT = 2                 ! Identifier
  integer, parameter :: NUMCON = 3                ! Numeric constant
  integer, parameter :: STRING = 4                ! String in quotes
  integer, parameter :: UNIT = 5                  ! A unit name, e.g. mb
  integer, parameter :: DEF_OP = 6                ! Defined operator
  integer, parameter :: UNK_OP = 7                ! Unefined operator
  integer, parameter :: DEF_PUN = 8               ! Defined punctuator
  integer, parameter :: UNK_PUN = 9               ! Undefined punctuator
  integer, parameter :: INC_NUM = 10              ! Incomplete number
  integer, parameter :: INC_STR = 11              ! Incomplete string
  integer, parameter :: UNK_CH = 12               ! Unknown character
  integer, parameter :: AFT_CONT = 13             ! After continuation
  integer, parameter :: OBJECT = 14               ! None of the above
d107 8
a114 6
  !  <:<       =         ,         ^         begin
     def_op,   def_op,   def_pun,  def_op,   res_word, &
  !  end       and       or        <eof>     <eos>     <ident>   <numcon>
     res_word, res_word, res_word, object,   object,   ident,    numcon,   &
  !  <string>  unk_op    unk_pun     unk_ch    inc_num   inc_str   junk
     string,   unk_op,   unk_pun,    unk_ch,   inc_num,  inc_str,  aft_cont /)
d118 1
a118 1
       "$RCSfile: $"
d147 4
d205 1
a205 1
       "$Id: read_apriori.f90 is it here $"
d215 3
@


2.9
log
@Reworded Copyright statement, moved rcs id
@
text
@d191 1
a192 1
!---------------------------- RCS Ident Info -------------------------------
d194 2
a195 3
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d197 1
d199 1
d204 3
@


2.8
log
@Add power (^) operator
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d109 1
a109 3
!---------------------------- RCS Ident Info -------------------------------
  character (len=256), private :: Id = &
       "$Id: symbol_types.f90,v 2.7 2004/04/26 21:55:29 vsnyder Exp $"
d111 1
a111 1
       "$RCSfile: symbol_types.f90,v $"
d192 5
d203 3
@


2.7
log
@Make strings case sensitive
@
text
@d34 16
a49 15
  integer, parameter :: T_BEGIN = 17              ! BEGIN
  integer, parameter :: T_END = 18                ! END
  integer, parameter :: T_AND = 19                ! AND
  integer, parameter :: T_OR = 20                 ! OR
  integer, parameter :: T_END_OF_INPUT = 21       ! <EOF>
  integer, parameter :: T_END_OF_STMT = 22        ! <EOS>
  integer, parameter :: T_IDENTIFIER = 23         ! <IDENTIFIER>
  integer, parameter :: T_NUMBER = 24             ! <NUMBER>
  integer, parameter :: T_STRING = 25             ! <STRING>
  integer, parameter :: T_UNK_OP = 26             ! unknown operator
  integer, parameter :: T_UNK_PUN = 27            ! unknown punctuator
  integer, parameter :: T_UNK_CH = 28             ! unknown character
  integer, parameter :: T_INC_NUM = 29            ! incomplete number
  integer, parameter :: T_INC_STR = 30            ! incomplete string
  integer, parameter :: T_AFT_CONT = 31           ! junk after continuation
d94 2
a95 2
  !  <:<       =         ,         begin
     def_op,   def_op,   def_pun,  res_word, &
d103 1
a103 1
       "$Id: symbol_types.f90,v 2.6 2004/01/14 18:32:58 vsnyder Exp $"
d135 1
d192 3
@


2.6
log
@Stuff for Algebra module
@
text
@d61 3
a63 1
       ( .true., i = min_pseudo, max_pseudo ), &
d102 1
a102 1
       "$Id: symbol_types.f90,v 2.5 2002/10/08 00:09:14 pwagner Exp $"
d190 3
@


2.5
log
@Added idents to survive zealous Lahey optimizer
@
text
@d26 23
a48 22
  integer, parameter :: T_DOT = 9
  integer, parameter :: T_COLON = 10
  integer, parameter :: T_COLON_LESS = 11
  integer, parameter :: T_LESS_COLON = 12
  integer, parameter :: T_LESS_COLON_LESS = 13
  integer, parameter :: T_EQUAL = 14
  integer, parameter :: T_COMMA = 15
  integer, parameter :: T_BEGIN = 16              ! BEGIN
  integer, parameter :: T_END = 17                ! END
  integer, parameter :: T_AND = 18                ! AND
  integer, parameter :: T_OR = 19                 ! OR
  integer, parameter :: T_END_OF_INPUT = 20       ! <EOF>
  integer, parameter :: T_END_OF_STMT = 21        ! <EOS>
  integer, parameter :: T_IDENTIFIER = 22         ! <IDENTIFIER>
  integer, parameter :: T_NUMBER = 23             ! <NUMBER>
  integer, parameter :: T_STRING = 24             ! <STRING>
  integer, parameter :: T_UNK_OP = 25             ! unknown operator
  integer, parameter :: T_UNK_PUN = 26            ! unknown punctuator
  integer, parameter :: T_UNK_CH = 27             ! unknown character
  integer, parameter :: T_INC_NUM = 28            ! incomplete number
  integer, parameter :: T_INC_STR = 29            ! incomplete string
  integer, parameter :: T_AFT_CONT = 30           ! junk after continuation
d89 1
a89 1
  !  *         /         .         :         <:        :<        <:<
d91 2
a92 2
  !  =         ,         begin
     def_op,   def_pun,  res_word, &
d100 1
a100 1
       "$Id: symbol_types.f90,v 2.4 2000/11/30 20:18:47 vsnyder Exp $"
d124 1
d188 3
@


2.4
log
@Added <: :< and <:< operators.
@
text
@d99 1
a99 1
       "$Id: symbol_types.f90,v 2.3 2000/11/30 00:31:12 vsnyder Exp $"
d102 1
d179 4
d186 3
@


2.3
log
@Make [] punctuators instead of operators.
@
text
@d28 20
a47 17
  integer, parameter :: T_EQUAL = 11
  integer, parameter :: T_COMMA = 12
  integer, parameter :: T_BEGIN = 13              ! BEGIN
  integer, parameter :: T_END = 14                ! END
  integer, parameter :: T_AND = 15                ! AND
  integer, parameter :: T_OR = 16                 ! OR
  integer, parameter :: T_END_OF_INPUT = 17       ! <EOF>
  integer, parameter :: T_END_OF_STMT = 18        ! <EOS>
  integer, parameter :: T_IDENTIFIER = 19         ! <IDENTIFIER>
  integer, parameter :: T_NUMBER = 20             ! <NUMBER>
  integer, parameter :: T_STRING = 21             ! <STRING>
  integer, parameter :: T_UNK_OP = 22             ! unknown operator
  integer, parameter :: T_UNK_PUN = 23            ! unknown punctuator
  integer, parameter :: T_UNK_CH = 24             ! unknown character
  integer, parameter :: T_INC_NUM = 25            ! incomplete number
  integer, parameter :: T_INC_STR = 26            ! incomplete string
  integer, parameter :: T_AFT_CONT = 27           ! junk after continuation
d88 4
a91 2
  !  *         /         .         :         =         ,         begin
     def_op,   def_op,   def_op,   def_op,   def_op,   def_pun,  res_word, &
d99 1
a99 1
       "$Id: symbol_types.f90,v 2.2 2000/11/30 00:23:10 vsnyder Exp $"
d123 4
a126 1
    case ( t_colon   );           call add_char ( ':' )
d181 3
@


2.2
log
@Implement [] syntax for arrays
@
text
@d84 1
a84 1
  (/ object,   def_pun,  def_pun,  def_op,   def_op,   def_op,   def_op,   &
d94 1
a94 1
       "$Id: symbol_types.f90,v 2.1 2000/10/11 18:33:25 vsnyder Exp $"
d173 3
@


2.1
log
@Move from lib/cf_parser to lib; insert copyright notice
@
text
@d20 25
a44 23
  integer, parameter :: T_PLUS = 3
  integer, parameter :: T_MINUS = 4
  integer, parameter :: T_STAR = 5
  integer, parameter :: T_SLASH = 6
  integer, parameter :: T_DOT = 7
  integer, parameter :: T_COLON = 8
  integer, parameter :: T_EQUAL = 9
  integer, parameter :: T_COMMA = 10
  integer, parameter :: T_BEGIN = 11              ! BEGIN
  integer, parameter :: T_END = 12                ! END
  integer, parameter :: T_AND = 13                ! AND
  integer, parameter :: T_OR = 14                 ! OR
  integer, parameter :: T_END_OF_INPUT = 15       ! <EOF>
  integer, parameter :: T_END_OF_STMT = 16        ! <EOS>
  integer, parameter :: T_IDENTIFIER = 17         ! <IDENTIFIER>
  integer, parameter :: T_NUMBER = 18             ! <NUMBER>
  integer, parameter :: T_STRING = 19             ! <STRING>
  integer, parameter :: T_UNK_OP = 20             ! unknown operator
  integer, parameter :: T_UNK_PUN = 21            ! unknown punctuator
  integer, parameter :: T_UNK_CH = 22             ! unknown character
  integer, parameter :: T_INC_NUM = 23            ! incomplete number
  integer, parameter :: T_INC_STR = 24            ! incomplete string
  integer, parameter :: T_AFT_CONT = 25           ! junk after continuation
d83 1
a83 1
  !  t_null    (         )         +         -         *         / 
d85 6
a90 6
  !  .         :         =         ,         begin     end       and
     def_op,   def_op,   def_op,   def_pun,  res_word, res_word, res_word, &
  !  or        <eof>     <eos>     <ident>   <numcon>  <string>  unk_op
     res_word, object,   object,   ident,    numcon,   string,   unk_op,   &
  !  unk_pun     unk_ch    inc_num   inc_str   junk
     unk_pun,    unk_ch,   inc_num,  inc_str,  aft_cont /)
d94 1
a94 1
       "$Id: symbol_types.f90,v 2.0 2000/09/05 17:41:51 dcuddy Exp $"
d111 2
d173 3
@

