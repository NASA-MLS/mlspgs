head	2.90;
access;
symbols
	v5-02-NRT-19:2.90
	v6-00:2.90
	v5-02-NRT-18:2.90
	v5-02:2.85
	v5-01-NRT-17:2.90
	v5-01-NRT-16:2.90
	v5-01-NRT-15:2.90
	v5-01-NRT-14:2.90
	neuralnetworks-1-0:2.89.0.4
	cfm-single-freq-0-1:2.89.0.2
	v5-01:2.85
	v5-00:2.85
	v4-23-TA133:2.83.0.6
	mus-emls-1-70:2.83.0.4
	rel-1-0-englocks-work:2.83.0.2
	VUMLS1-00:2.80
	VPL1-00:2.80
	V4-22-NRT-08:2.79
	VAM1-00:2.79
	V4-21:2.78.0.2
	V4-13:2.77
	V4-12:2.76
	V4-11:2.75
	V4-10:2.74
	V3-43:2.65.2.1
	M4-00:2.70
	V3-41:2.65.2.1
	V3-40-PlusGM57:2.65.0.2
	V2-24-NRT-04:2.50
	V3-33:2.60
	V2-24:2.50
	V3-31:2.60
	V3-30-NRT-05:2.60
	cfm-01-00:2.60
	V3-30:2.60
	V3-20:2.60
	V3-10:2.56
	V2-23-NRT-02:2.50
	V2-23:2.50
	V2-22-NRT-01:2.50
	V2-22:2.50
	V2-21:2.42
	V2-20:2.42
	V2-11:2.41
	V2-10:2.41
	V2-00:2.41
	V1-51:2.33
	V1-50:2.33
	V1-45:2.33
	V1-44:2.33
	V1-43:2.31
	V1-42:2.31
	V1-41:2.31
	V1-32:2.31
	V1-40:2.31
	V1-31:2.31
	V1-30:2.30
	V1-13:2.24
	V1-12:2.24
	V1-11:2.24
	V1-10:2.18
	newfwm-feb03:2.18.0.2
	V1-04:2.13
	V1-03:2.13
	V1-02:2.13
	V1-00:2.13
	newfwm-sep01:2.11.0.2
	V0-7:2.11
	V0-5-Level2:2.11
	V0-5-SIPS:2.11
	V0_1:1.5;
locks; strict;
comment	@# @;


2.90
date	2021.07.08.23.27.24;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2020.05.29.21.54.49;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2020.04.30.23.20.59;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2020.04.27.21.34.51;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2019.10.03.17.31.24;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2019.09.23.20.38.32;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2019.09.05.17.50.13;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2017.11.03.20.01.16;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2017.08.23.16.45.25;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2017.03.17.00.10.49;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2016.07.28.01.42.27;	author vsnyder;	state Exp;
branches;
next	2.79;

2.79
date	2015.03.28.01.01.03;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2015.01.21.19.29.15;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2014.09.04.23.38.45;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2014.07.18.22.00.24;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2014.05.29.18.28.26;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2014.01.09.00.25.06;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2013.08.31.01.24.53;	author vsnyder;	state Exp;
branches;
next	2.72;

2.72
date	2013.08.30.03.56.01;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2013.06.12.02.17.27;	author vsnyder;	state Exp;
branches;
next	2.70;

2.70
date	2012.10.11.21.00.28;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2012.03.06.19.32.39;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2012.03.06.19.12.32;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2012.03.01.20.01.40;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2011.08.30.22.22.29;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2011.06.29.21.37.17;	author pwagner;	state Exp;
branches
	2.65.2.1;
next	2.64;

2.64
date	2011.06.16.23.00.09;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2011.05.05.15.21.34;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2011.04.27.17.34.25;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2011.04.20.00.25.18;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2010.02.09.16.24.12;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2010.02.03.23.09.23;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2009.10.30.23.04.50;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2009.06.16.17.25.13;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2009.01.12.18.45.46;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2008.09.16.21.05.10;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2008.06.06.22.52.21;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2008.01.07.21.36.33;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2007.10.04.01.49.14;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2007.08.17.00.27.23;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2007.08.13.17.35.24;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2007.07.27.00.23.57;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2007.06.07.20.26.16;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2007.03.23.00.10.49;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2007.01.30.21.57.44;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2007.01.11.20.31.53;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2006.11.01.20.27.05;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2006.06.14.23.58.46;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2006.06.13.22.10.19;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2006.05.12.21.24.13;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2006.05.09.00.13.32;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2006.05.02.19.00.42;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2006.02.10.21.21.20;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2006.01.19.00.24.17;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2005.06.22.17.25.48;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2004.08.03.17.59.34;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2004.05.19.18.54.44;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2003.12.16.01.13.47;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2003.05.19.19.37.41;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2003.05.09.01.54.58;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2003.05.08.05.27.18;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2003.04.04.23.01.26;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2003.04.04.19.10.58;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2003.04.04.00.09.32;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2003.03.01.00.22.30;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2003.02.28.02.26.42;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2003.02.27.18.38.13;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2003.02.21.20.59.53;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2003.02.20.21.22.20;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2003.02.19.19.13.28;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2002.11.22.12.46.26;	author mjf;	state Exp;
branches;
next	2.17;

2.17
date	2002.10.08.00.09.09;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2002.07.01.23.57.18;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2002.06.27.00.09.50;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2002.06.26.22.03.31;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.10.26.23.17.14;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2001.09.10.23.36.56;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.10.20.04.54;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.03.30.00.24.40;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2001.03.15.21.28.08;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.15.00.37.13;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.14.00.32.47;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.10.00.33.16;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.09.01.02.55;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.08.01.08.35;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.07.01.03.19;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.21.00.36.43;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.20.21.51.39;	author pwagner;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.17.41.05;	author dcuddy;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.20.22.19.22;	author lungu;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.07.02.02.25;	author lungu;	state Exp;
branches;
next	;

2.65.2.1
date	2011.11.16.23.33.51;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.90
log
@Correct unbalanced trace for DestroyGriddedData
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module GriddedData ! Contains the derived TYPE GriddedData_T

  use Allocate_Deallocate, only: Allocate_Test, Byte_Size, Bytes, &
    & Deallocate_Test, NoBytesAllocated, &
    & Test_Allocate, Test_Deallocate
  use HyperSlabs, only: EssentiallyEqual
  use Dates_Module, only: TAI2CCSDS
  use Dump_0, only: Dump
  use Dump_1, only: DumpDates
  use HighOutput, only: OutputNamedValue
  use Intrinsic, only: L_GeodAltitude, L_GPH, L_Eta, L_Pressure, &
    & L_Theta
  use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
  use MLSCommon, only: LineLen, NameLen, UndefinedValue
  ! r4 corresponds to sing. prec. :: same as stored in files
  ! (except for dao dimensions)
  use MLSKinds, only: RGR=>R4, R8
  use MLSMessageModule, only: MLSMSG_Error, &
    & MLSMSG_Warning, MLSMessageConfig, MLSMessage
  use MLSStringLists, only: SnipList, SwitchDetail
  use MLSStrings, only: LowerCase, ReadIntsFromChars
  use Output_m, only: OutputOptions, Blanks, Output, NewLine, &
    & ResumeOutput, SuspendOutput
  use Toggles, only: Gen, Levels, Switches, Toggle
  use Trace_m, only: Trace_Begin, Trace_End

  implicit none
  private

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: GriddedData.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (parameters and data)
! GriddedData_T            The data type to hold climatology, gmao, etc.

!     (subroutines and functions)
! AddGriddedDataToDatabase What the name says
!                          
! ConcatenateGriddedData   Produce a a combination of two grids, 
!                           an earlier and a later
! ConvertFromEtaLevelGrids Convert two eta-level grids, one of them pressures,
!                           to a pressure-level Grid
! DestroyGriddedData       Deallocate all the pointer components
! DestroyGriddedDataDatabase
!                          Destroy all the elements of the database
! Diff                     Print differences between two grids
! DoGriddeddataMatch       Same shapes, are on same geolocations, etc.?
! DownsampleGriddeddata    Resample grid onto coarser grid derived by step sizes
! Dump                     Print details, values of a grid
! NullifyGriddedData       Nullify all its pointer components
! SetupNewGriddedData
!                          What the name says
! SliceGriddedData         Resample grid at supplied coords (Consider renaming it)
! WrapGriddedData          Add extra points in longitude beyond +/-180
!                           and in solar time beyond 0..24 to aid in interpolations
! === (end of toc) ===

! === (start of api) ===
! === (end of api) ===
  public :: GriddedData_T, AddgriddedDatatoDatabase, &
    & ConcatenategriddedData, Convertfrometalevelgrids, Copygrid, &
    & DestroygriddedData, DestroygriddedDataDatabase, &
    & Diff, DogriddedDatamatch, DownsamplegriddedData, Dump, &
    & NullifygriddedData, Rgr, SetupnewgriddedData, SlicegriddedData, &
    & WrapgriddedData
  
  logical, private, parameter :: MaydumpfieldValues = .true.

  interface ConcatenategriddedData
    module procedure ConcatenateGriddedData_2
    module procedure ConcatenateGriddedData_array
  end interface

  interface Diff
    module procedure DiffGriddedData
  end interface

  interface Dump
    module procedure DumpGriddedData
    module procedure DumpGriddedDatabase
  end interface

  ! These are 'enumerated types' consistent with hph's
  ! work in l3ascii_read_field
  public :: V_Is_Pressure, V_Is_Altitude, V_Is_Gph, V_Is_Theta, V_Is_Eta

  integer, parameter :: V_is_pressure = L_PRESSURE ! 1
  integer, parameter :: V_is_altitude = L_GEODALTITUDE ! v_is_pressure+1
  integer, parameter :: V_is_GPH      = L_GPH ! v_is_altitude+1
  integer, parameter :: V_is_theta    = L_THETA ! v_is_gph+1
  integer, parameter :: V_is_eta      = L_ETA ! V_is_theta+1
  
  ! If dumping gridded data, always give some details of any matching these
  character(len=*), parameter :: ALWAYSDUMPTHESE = ' ' ! 'dao,ncep,geos5'
  ! and for these automatically dumped ones, this level of detail for multi-dim
  integer, parameter :: AUTOMATICDETAILS = 0 ! 1 means dump, 0 means no
  
  ! Dump datebase memory footprint after every op
  logical, parameter, public :: DumpDBFootPrint = .true.

  ! This type reflects the format of the Level 3 ASCII files, though note that
  ! these files can store multiple quantities such as these.

  type GriddedData_T

    ! First the comment line(s) from the relevant input file
    logical :: EMPTY                    ! Set for example when file read failed
    logical :: deferReading             ! Set when to be read later
    character (len=LineLen), pointer, dimension(:) :: fileComments => NULL()

    ! Now the name, description and units information
    integer                 :: fileType = 0 ! From spec_indices, e.g. s_gridded
    character (len=LineLen) :: sourceFileName ! Input file name
    character (len=NameLen) :: quantityName ! From input file
    character (len=LineLen) :: description ! Quantity description
    character (len=LineLen) :: dimList
    character (len=LineLen) :: fieldNames
    character (len=NameLen) :: units ! Units for quantity

    ! Now define the various coordinate systems, first vertical
    integer :: verticalCoordinate ! An 'enumerated' type (e.g., V_is_...)
    integer :: noHeights         ! Number of surfaces
    real (rgr), pointer, dimension(:) :: heights  => NULL()
    ! Surfaces (e.g. pressures etc.) [noHeights]
    character (len=NameLen) :: heightsUnits ! Units for heights, e.g. 'Pa'

    ! Now the latitudinal coordinate
    logical :: equivalentLatitude       ! If set, coordinate is equivalent latitude
    logical :: noYear                   ! If set, field is for any year
    integer :: noLats                   ! Number of latitudes
    real (rgr), pointer, dimension(:) :: Lats => NULL() ! Latitudes [noLats]
    integer :: noLons                   ! Number of longitudes
    real (rgr), pointer, dimension(:) :: Lons => NULL() ! Longitudes [noLons]
    integer :: noLsts                      ! Number of local times
    real (rgr), pointer, dimension(:) :: Lsts => NULL() ! Local times [noLsts]
    integer :: noSzas                      ! Number of solar zenith angles
    real (rgr), pointer, dimension(:) :: Szas => NULL() ! Zenith angles [noSzas]
    integer :: noDates                     ! Number of dates in data
    real (r8), pointer, dimension(:) :: DateStarts => NULL()
    ! Starting dates in SDP toolkit format tai
    real (r8), pointer, dimension(:) :: DateEnds => NULL()
    ! Ending dates in SDP toolkit format tai

    ! The data itself.  This is stored as
    !  [noHeights, noLats, noLons, noLsts, noSzas, noDates]
    real (rgr), pointer, dimension(:,:,:,:,:,:) :: field => NULL()
    real (rgr) :: missingValue

  end type GriddedData_T

! ======================================================================
contains

  ! -----------------------------------  AddGriddedDataToDatabase  -----
  integer function AddGriddedDataToDatabase ( Database, Item )
  ! This subroutine adds a quantity template to a database, or creates the
  ! database if it doesn't yet exist

    ! Dummy arguments
    type (GriddedData_T), dimension(:), pointer :: Database
    type (GriddedData_T), intent(in) :: Item

    ! Local variables
    type (GriddedData_T), dimension(:), pointer :: tempDatabase

    ! Executable code

    include "addItemToDatabase.f9h"
    AddGriddedDataToDatabase = newSize

  end function AddGriddedDataToDatabase

  ! -------------------------------------------- ConcatenateGriddedData
  subroutine ConcatenateGriddedData_2 ( A, B, X )
    ! This routine takes two grids A and B, B dated after A and tries
    ! to produce a third grid which is a combination of A and B
    type ( GriddedData_T ), intent(in) :: A
    type ( GriddedData_T ), intent(in) :: B
    type ( GriddedData_T ), intent(inout) :: X ! inout to let us deallocate it

    ! Local variables
    logical, parameter :: DEEBUG = .false.
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'ConcatenateGriddedData_2', &
      & cond=toggle(gen) .and. levels(gen) > 1 )
    ! First, check that the grids A and B are conformable.
    if ( (a%verticalCoordinate /= b%verticalCoordinate) .or. &
      & (a%equivalentLatitude .neqv. b%equivalentLatitude) .or. &
      & (a%noYear .neqv. b%noYear) ) then
        call output( 'Gridded Data a', advance='yes' )
        call dump( a )
        call output( 'Gridded Data b', advance='yes' )
        call dump( b )
        call outputNamedValue ( 'a%verticalCoordinate', a%verticalCoordinate )
        call outputNamedValue ( 'b%verticalCoordinate', b%verticalCoordinate )
        call outputNamedValue ( '=?', &
          & a%verticalCoordinate == b%verticalCoordinate )
        call outputNamedValue ( 'a%equivalentLatitude', a%equivalentLatitude )
        call outputNamedValue ( 'b%equivalentLatitude', b%equivalentLatitude )
        call outputNamedValue ( '=?', &
          & a%equivalentLatitude .eqv. b%equivalentLatitude )
        call outputNamedValue ( 'a%noYear', a%noYear )
        call outputNamedValue ( 'b%noYear', b%noYear )
        call outputNamedValue ( '=?', &
          & a%noYear .eqv. b%noYear )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Grids for Concatenate are not compatible' )
    endif
    if ( .not. all ( EssentiallyEqual ( a%heights, b%heights ) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Grids for Concatenate do not share heights' )
    if ( .not. all ( EssentiallyEqual ( a%lats, b%lats ) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Grids for Concatenate do not share lats' )
    if ( .not. all ( EssentiallyEqual ( a%lons, b%lons ) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Grids for Concatenate do not share lons' )
    if ( .not. all ( EssentiallyEqual ( a%lsts, b%lsts ) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Grids for Concatenate do not share lsts' )
    if ( .not. all ( EssentiallyEqual ( a%szas, b%szas ) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Grids for Concatenate do not share szas' )
    if ( .not. EssentiallyEqual ( a%missingValue, b%missingValue ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Grids for Concatenate have different missing values' )

    ! Check that the dates are going to work out
    if ( maxval ( a%dateEnds ) > minval ( b%dateStarts ) ) then
      call Dump( a, details=0 )
      call Dump( b, details=0 )
      call output( 'Ending date of a: ', advance='no' )
      call output( maxval ( a%dateEnds ), format='(1pe16.9)', advance='yes' )
      call output( 'Starting date of b: ', advance='no' )
      call output( minval ( b%dateStarts ), format='(1pe16.9)', advance='yes' )
      call output( 'Difference: ', advance='no' )
      call output( maxval ( a%dateEnds ) - minval ( b%dateStarts ), format='(1pe16.9)', advance='yes' )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Grids for concatenation are not in correct time order' )
    endif

    ! OK, now we're ready
    call DestroyGriddedData ( X )
    call SetupNewGriddedData ( X, source=A, noDates= a%noDates + b%noDates )
    if ( DEEBUG ) then
    call output( 'source%verticalCoordinate: ', advance='no' )
    call output( a%verticalCoordinate, advance='no' )
    call blanks(3)
    call output( v_is_pressure, advance='yes' )
    call output( 'result%verticalCoordinate: ', advance='no' )
    call output( x%verticalCoordinate, advance='no' )
    call blanks(3)
    call output( v_is_pressure, advance='yes' )
    endif
    ! Copy over the unchanged position data
    x%heights = a%heights
    x%lats = a%lats
    x%lons = a%lons
    x%lsts = a%lsts
    x%szas = a%szas
    x%dateStarts = (/ a%dateStarts, b%dateStarts /)
    x%dateEnds = (/ a%dateEnds, b%dateEnds /) 

    x%field ( :, :, :, :, :, 1:a%noDates ) = a%field
    x%field ( :, :, :, :, :, a%noDates+1:x%noDates ) = b%field
    call trace_end ( 'ConcatenateGriddedData_2' , cond=toggle(gen) )
  end subroutine ConcatenateGriddedData_2

  subroutine ConcatenateGriddedData_array ( Database, indices, X )
    ! This routine takes an array of grids and a set of index values
    ! to produce a third grid which is a combination database elements
    ! at the index values
    type ( GriddedData_T ), dimension(:), intent(in) :: database
    integer, dimension(:), intent(in) :: indices ! index values
    type ( GriddedData_T ), intent(inout) :: X ! inout to let us deallocate it
    ! Local variables
    logical, parameter :: DEEBUG = .false.
    integer :: i
    integer, dimension(size(indices)) :: i1
    integer, dimension(size(indices)) :: i2
    integer :: index1
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: noDates
    ! Executable code
    call trace_begin ( me, 'ConcatenateGriddedData_array', &
      & cond=toggle(gen) .and. levels(gen) > 1 )
    call DestroyGriddedData ( X )
    if ( size(indices) < 1 .or. size(database) < 1 ) go to 9
    index1 = indices(1)
    if ( index1 < 1 .or. index1 > size(Database) ) go to 9
    if ( size(indices) < 2 ) then
      call CopyGrid ( X, Database(index1) )
      go to 9
    endif
    noDates = 0
    do i=1, size(indices)
      i1(i) = noDates + 1
      noDates = noDates + Database(indices(i))%noDates
      i2(i) = noDates
    enddo
    call SetupNewGriddedData ( X, source=Database(index1), noDates= noDates )
    ! Copy over the unchanged position data
    x%heights = Database(index1)%heights
    x%lats = Database(index1)%lats
    x%lons = Database(index1)%lons
    x%lsts = Database(index1)%lsts
    x%szas = Database(index1)%szas

    x%dateStarts(1:i2(1)) = Database(index1)%dateStarts
    x%dateEnds  (1:i2(1)) = Database(index1)%dateEnds

    x%field ( :, :, :, :, :, 1:i2(1) ) = Database(index1)%field
    do i=2, size(indices)
      index1 = indices(i)
      if ( index1 < 1 .or. index1 > size(database) ) cycle
      ! First, check that the grids A and B are conformable.
      if ( Database(index1)%verticalCoordinate /= x%verticalCoordinate .or. &
        & Database(index1)%equivalentLatitude .neqv. x%equivalentLatitude &
        & .or. &
        & Database(index1)%noYear .neqv. x%noYear ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Grids for Concatenate are not compatible' )
      if ( .not. all ( EssentiallyEqual &
        & ( Database(index1)%heights, x%heights ) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Grids for Concatenate do not share heights' )
      if ( .not. all ( EssentiallyEqual ( Database(index1)%lats, x%lats ) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Grids for Concatenate do not share lats' )
      if ( .not. all ( EssentiallyEqual ( Database(index1)%lons, x%lons ) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Grids for Concatenate do not share lons' )
      if ( .not. all ( EssentiallyEqual ( Database(index1)%lsts, x%lsts ) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Grids for Concatenate do not share lsts' )
      if ( .not. all ( EssentiallyEqual ( Database(index1)%szas, x%szas ) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Grids for Concatenate do not share szas' )
      if ( .not. EssentiallyEqual &
        & ( Database(index1)%missingValue, x%missingValue ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Grids for Concatenate have different missing values' )

      ! Check that the dates are going to work out
      if ( maxval ( x%dateEnds(:i1(i)-1) ) > &
        & minval ( Database(index1)%dateStarts ) ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Grids for concatenation are not in correct time order' )
      endif

      x%dateStarts(i1(i):i2(i)) = Database(index1)%dateStarts
      x%dateEnds(i1(i):i2(i)) = Database(index1)%dateEnds
      x%field ( :, :, :, :, :, i1(i):i2(i) ) = Database(index1)%field
    enddo
  9 call trace_end ( 'ConcatenateGriddedData_array' , cond=toggle(gen) )

  end subroutine ConcatenateGriddedData_array

  ! ---------------------------------------- ConvertFromEtaLevelGrids ------------------
  subroutine ConvertFromEtaLevelGrids ( TGrid, PGrid, NGrid, OutGrid, &
    & VGrid, ByLog )
    ! Converts two eta-level grids, one of them pressures, 
    ! to a pressure-level Grid
    use MLSNumerics, only: Interpolatevalues, Uselookuptable
    use Dump_0, only: Dump
    use VGridsDatabase, only: VGrid_T
    type ( GriddedData_T ), intent(in)  :: TGrid  ! E.g., T on eta surfaces
    type ( GriddedData_T ), intent(in)  :: PGrid  ! Pressures on eta surfaces
    type ( GriddedData_T ), intent(in)  :: NGrid  ! What surfaces to use
    type ( GriddedData_T ), intent(out) :: OutGrid ! T on pressure level
    type ( VGrid_T ), pointer           :: VGrid  ! What surfaces to use
    logical, optional, intent(in)       :: ByLog  ! Interpolate using zeta

    ! Internal variables
    integer :: iDate, iSza, iLst, iLon, iLat, iHeight
    integer :: Me = -1                  ! String index for trace cacheing
    real(rgr), dimension(TGrid%noHeights) :: pEta
    logical, parameter                    :: DEEBUG = .false.
    logical                               :: GotVgrid ! Are heights supplied by a VGrid?
    logical                               :: why
    logical                               :: ZetaSurfaces
    real (rgr), pointer, dimension(:)     :: heights  => NULL()

    ! Executable code
    call trace_begin ( me, 'ConvertFromEtaLevelGrids', &
      & cond=toggle(gen) .and. levels(gen) > 1 )
    ZetaSurfaces = .false.
    if ( present(ByLog) ) ZetaSurfaces = ByLog
    GotVgrid = associated(VGrid)

    ! GriddedData must match
    if ( .not. DoGriddeddataMatch( PGrid, TGrid ) ) then
      call DumpGriddedData( PGrid )
      call DumpGriddedData( TGrid )
      why = DoGriddeddataMatch( PGrid, TGrid, SayWhyNot=.true. )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Gridded T,P data must match' )
    endif
    call DestroyGriddedData ( OutGrid )
    ! Copy the information over
    if ( GotVgrid ) then
      call SetupNewGriddedData ( OutGrid, source=TGrid, noHeights=VGrid%noSurfs )
      OutGrid%verticalCoordinate = VGrid%VerticalCoordinate
      OutGrid%heights(1:OutGrid%noHeights) = VGrid%Surfs(1:OutGrid%noHeights,1)
    else
      call SetupNewGriddedData ( OutGrid, source=TGrid, noHeights=NGrid%noHeights )
      OutGrid%verticalCoordinate = NGrid%VerticalCoordinate
      if ( size(OutGrid%heights) /= size(NGrid%heights) ) then
        call outputNamedValue('num heights(outGrid)', size(OutGrid%heights), advance='yes' )
        call outputNamedValue('num heights(NGrid)', size(NGrid%heights), advance='yes' )
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Grid shapes do not conform' )
        go to 9
      endif
      OutGrid%heights(1:OutGrid%noHeights) = NGrid%heights(1:OutGrid%noHeights)
    endif
    if ( PGrid%empty .or. TGrid%empty) then
      call MLSMessage ( MLSMSG_Warning, moduleName, &
        & 'Temperatures or Pressures grid was empty' )
      go to 9
    endif
    OutGrid%lats = TGrid%lats
    OutGrid%lons = TGrid%lons
    OutGrid%lsts = TGrid%lsts
    OutGrid%szas = TGrid%szas
    OutGrid%dateStarts = TGrid%dateStarts
    OutGrid%dateEnds = TGrid%dateEnds
    heights => OutGrid%heights
    ! Now we'll interpolate to the OutGrid surfaces
    do idate=1, TGrid%noDates
      do iSza=1, TGrid%noSzas
        do iLst=1, TGrid%noLsts
          do iLon=1, TGrid%noLons
            do iLat=1, TGrid%noLats
              ! But do we need to convert pressures from one system to another?
              ! Because we're in a hurry, we won't use ConvertVGrid
              ! but just do it by hand
              ! What we'll do is assume
              ! The grid we need OutGrid is in 'hPa'
              ! The eta-level pressures are either already in hPa or else in pa
              if ( lowercase(PGrid%units) == 'hpa' ) then
                pEta = PGrid%field( :, iLat, iLon, iLst, iSza, iDate )
              elseif ( lowercase(PGrid%units) == 'pa' ) then
                pEta = PGrid%field( :, iLat, iLon, iLst, iSza, iDate ) / 100
              else
                call MLSMessage(MLSMSG_Error, ModuleName, &
                  & 'unrecognized quantity for eta-level pressures '// trim(PGrid%units) )
              endif
              if ( ZetaSurfaces ) then
                call InterpolateValues( &
                & log10(pEta), TGrid%field( :, iLat, iLon, iLst, iSza, iDate ), &
                & log10(heights), OutGrid%field( :, iLat, iLon, iLst, iSza, iDate ), &
                & 'L', 'B', TGrid%missingValue )
              else
                call InterpolateValues( &
                & pEta, TGrid%field( :, iLat, iLon, iLst, iSza, iDate ), &
                & heights, OutGrid%field( :, iLat, iLon, iLst, iSza, iDate ), &
                & 'L', 'B', TGrid%missingValue )
              endif
            enddo
          enddo
        enddo
      enddo
    enddo
    if ( DEEBUG ) then
      call outputNamedValue( 'PGrid%units', PGrid%units )
      call dump( TGrid%field( :, 1, 1, 1, 1, 1 ), 'T' )
      call dump( PGrid%field( :, 1, 1, 1, 1, 1 ), 'P' )
      call dump( heights, 'heights' )
      call dump( OutGrid%field( :, 1, 1, 1, 1, 1 ), 'T out' )
      pEta = PGrid%field( :, 1, 1, 1, 1, 1 ) / 100
      call dump( pEta, 'heights(eta)' )
      do iHeight = 1, OutGrid%noHeights
        call outputNamedValue( 'height', heights(iHeight) )
        OutGrid%field( iHeight, 1, 1, 1, 1, 1 ) = &
        & UseLookUpTable ( heights(iHeight), TGrid%field( :, 1, 1, 1, 1, 1 ), &
        & xtable=pEta, missingValue=TGrid%missingValue, options='ip' )
      enddo
      call dump( OutGrid%field( :, 1, 1, 1, 1, 1 ), 'T out (2)' )
      stop
    endif
  9 call trace_end ( 'ConvertFromEtaLevelGrids' , cond=toggle(gen) )
  end subroutine ConvertFromEtaLevelGrids

  ! ---------------------------------------- CopyGrid ------------------
  subroutine CopyGrid ( Z, X )
    ! Does a deep copy of X into Z
    type ( GriddedData_T ), intent(inout) :: Z
    type ( GriddedData_T ), intent(in) :: X
    ! Executable code
    call DestroyGriddedData ( Z )
    call SetupNewGriddedData ( Z, source=X )
    ! Copy the information over
    z%heights = x%heights
    z%lats = x%lats
    z%lons = x%lons
    z%lsts = x%lsts
    z%szas = x%szas
    z%dateStarts = x%dateStarts
    z%dateEnds = x%dateEnds
    z%field = x%field
  end subroutine CopyGrid

  ! -----------------------------------------  DestroyGriddedData  -----
  subroutine DestroyGriddedData ( Qty )
    ! This subroutine deallocates all the pointer components
    use Trace_M, only: Trace_begin, Trace_end

    ! Dummy argument
    type (GriddedData_T), intent(inout) :: Qty

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: S ! Size in bytes of a deallocated field
    integer :: STATUS
    logical :: verbose
    integer :: Me = -1           ! String index for trace

    ! Executable code
    call trace_begin ( me, "DestroyGriddedData", &
      & cond=toggle(gen) .and. levels(gen) > 1  )

    verbose = switchDetail(switches, 'grid') > -1
    call Deallocate_test ( qty%heights, "griddedQty%heights", ModuleName )
    call Deallocate_test ( qty%lats, "griddedQty%lats", ModuleName )
    call Deallocate_test ( qty%lons, "griddedQty%lons", ModuleName )
    call Deallocate_test ( qty%lsts, "griddedQty%lsts", ModuleName )
    call Deallocate_test ( qty%szas, "griddedQty%szas", ModuleName )

    ! Now the temporal coordinates
    call Deallocate_test ( qty%dateStarts, "griddedQty%dateStarts", ModuleName )
    call Deallocate_test ( qty%dateEnds, "griddedQty%dateEnds", ModuleName )

    ! Now the data itself
    if ( associated(qty%field) ) then
      s = byte_size(qty%field)
      if ( verbose ) then
        call outputnamedValue ( 'Grid size to be destroyed', shape(qty%field) )
        call outputnamedValue ( 'Its size in MB', s/1.e6 )
      endif
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(qty%field(1,1,1,1,1,1)), addr)
      deallocate(qty%field, STAT=status)
      call test_deallocate ( status, moduleName, "griddedQty%field", s, address=addr )
    else if ( verbose ) then
      call output( 'This grid not allocated', advance='true' )
    end if
    qty%empty = .true.
    call trace_end ( "DestroyGriddedData", &
      & cond=toggle(gen) .and. levels(gen) > 1  )

  end subroutine DestroyGriddedData

  ! ----------------------------------  DestroyGriddedDataDatabase -----
  subroutine DestroyGriddedDataDatabase ( Database )
  ! This subroutine destroys a quantity template database

    use Allocate_Deallocate, only: Test_Deallocate

    use Trace_M, only: Trace_begin, Trace_end

    ! Dummy argument
    type (GriddedData_T), dimension(:), pointer :: Database

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: Me = -1           ! String index for trace
    integer :: qtyIndex, s, status

    call trace_begin ( me, "DestroyGriddedDataDatabase", &
      & cond=toggle(gen) .and. levels(gen) > 1 )

    if (associated(database)) then
      do qtyIndex=1,size(database)
        call DestroyGriddedData(database(qtyIndex))
      end do
      s = size(database) * storage_size(database) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(database(1)), addr)
      deallocate(database, stat=status)
      call test_deallocate ( status, ModuleName, "database", s, address=addr )
    end if
    call trace_end ( "DestroyGriddedDataDatabase", cond=toggle(gen) )

  end subroutine DestroyGriddedDataDatabase

   ! --------------------------------------------  DiffGriddedData  -----
  subroutine DiffGriddedData ( GriddedData1, GriddedData2, options )
    use Diff_1, only: Diff

    ! Imitating what dump_pointing_grid_database does, but for gridded data
    ! which may come from climatology, ncep, dao
    type (GriddedData_T) :: GriddedData1, GriddedData2
    character(len=*), intent(in), optional :: options

    ! Local Variables
    integer :: date
    integer :: details
    character(len=4) :: dateChar

    ! Executable code
    if ( GriddedData1%empty .or. GriddedData2%empty ) then
      call output('At least one Gridded quantity was empty (perhaps the file name' &
        & // ' was wrong)', advance='yes')
      return
    endif
    details = 0
    if ( present(options) ) then
      call readIntsFromChars( options, details, ignore='-*' )
      call outputNamedValue('options', &
      & options, advance='yes')
    endif
    call output('Gridded quantity (1) name ' // &
      & GriddedData1%quantityName, advance='yes')
    call output('Gridded quantity (2) name ' // &
      & GriddedData2%quantityName, advance='yes')
    call outputNamedValue('details', &
      & details, advance='yes')
   ! May dump a 3-d slice of 6-d array
    if ( details == 1 ) then
      call diff ( &
        & GriddedData1%field(:,1,1,1,1,1), &
        & GriddedData1%quantityName, &
        & GriddedData2%field(:,1,1,1,1,1), &
        & GriddedData2%quantityName, &
        & options=options )
    elseif ( details == 2 ) then
      call diff ( &
        & GriddedData1%field(:,:,1,1,1,1), &
        & GriddedData1%quantityName, &
        & GriddedData2%field(:,:,1,1,1,1), &
        & GriddedData2%quantityName, &
        & options=options )
    elseif ( GriddedData1%noDates == 1 .and. GriddedData1%noSzas == 1 &
      & .and. GriddedData1%noLsts == 1 ) then
      call diff ( &
        & GriddedData1%field(:,:,:,1,1,1), &
        & GriddedData1%quantityName, &
        & GriddedData2%field(:,:,:,1,1,1), &
        & GriddedData2%quantityName, &
        & options=options )
    elseif ( GriddedData1%noSzas == 1 .and. GriddedData1%noLsts == 1 ) then
   ! May dump a 4-d array as noDates instances of 3-d arrays
      do date=1, GriddedData1%noDates
        write(dateChar, '(i4)') date
        call diff ( &
          & GriddedData1%field(:,:,:,1,1,date), &
          & GriddedData1%quantityName, &
          & GriddedData2%field(:,:,:,1,1,date), &
          & GriddedData2%quantityName, &
          & options=options )
      enddo
    else
      call output ( ' *(Sorry, diff_6d_... not yet coded)* ' , &
        & advance='yes')
    endif

  end subroutine DiffGriddedData

  ! ----------------------------------------  DoGriddeddataMatch  -----
  function DoGriddeddataMatch ( a, b, sayWhyNot ) result( match )
    ! Test whether two griddeddata have same shapes, are on same geolocations
    ! and so on
    ! They may have different name, description, and unit information
    ! And the field values may differ
    type(GriddedData_T), intent(in) :: a
    type(GriddedData_T), intent(in) :: b
    logical, optional, intent(in)   :: sayWhyNot
    logical                         :: match
    ! local variables
    logical                         :: verbose
    ! Executable
    verbose = .false.
    if ( present(sayWhyNot) ) verbose = sayWhyNot
    match = .true.
    if ( verbose ) then
      if ( a%empty .or. b%empty ) call explain( 'One empty, the other not' )
      if ( any( shape(a%field) /= shape(b%field) ) ) call explain( 'shapes dont match' )
      if ( a%verticalCoordinate /= b%verticalcoordinate ) call explain( 'vertical coords diff' )
      if ( a%noHeights /= b%noHeights ) call explain( 'noHeights diff' )
      if ( any( a%Heights /= b%Heights ) ) call explain( 'Heights diff' )
      if ( lowercase(a%heightsUnits) /= lowercase(b%heightsUnits) ) call explain( 'height units idff' )
      ! if ( lowercase(a%Units) /= lowercase(b%Units) ) call explain( 'One empty, the other not' )
      if ( a%noLats /= b%noLats ) call explain( 'noLats diff' )
      if ( a%noLons /= b%noLons ) call explain( 'nolens diff' )
      if ( a%noLsts /= b%noLsts ) call explain( 'noLsts diff' )
      if ( a%noSzas /= b%noSzas ) call explain( 'noSzas diff' )
      if ( a%noDates /= b%noDates ) call explain( 'nodates difft' )
      if ( a%missingValue /= b%missingValue ) call explain( 'missing values diff' )
      if ( any( a%Lats /= b%Lats ) ) call explain( 'lats diff' )
      if ( any( a%Lons /= b%Lons ) ) call explain( 'lons diff' )
      if ( any( a%Lsts /= b%Lsts ) ) call explain( 'lsts diff' )
      if ( any( a%Szas /= b%Szas ) ) call explain( 'szas diff' )
      if ( any( a%DateStarts /= b%DateStarts ) ) call explain( 'dateStarts diff' )
      if ( any( a%DateEnds /= b%DateEnds ) ) call explain( 'DateEnds diff' )
    endif
    if ( a%empty .and. b%empty ) return
    match = .false.
    if ( a%empty .or. b%empty ) return
    if ( any( shape(a%field) /= shape(b%field) ) ) return
    if ( a%verticalCoordinate /= b%verticalcoordinate ) return
    if ( a%noHeights /= b%noHeights ) return
    if ( any( a%Heights /= b%Heights ) ) return
    if ( lowercase(a%heightsUnits) /= lowercase(b%heightsUnits) ) return
    ! if ( lowercase(a%Units) /= lowercase(b%Units) ) return
    if ( a%noLats /= b%noLats ) return
    if ( a%noLons /= b%noLons ) return
    if ( a%noLsts /= b%noLsts ) return
    if ( a%noSzas /= b%noSzas ) return
    if ( a%noDates /= b%noDates ) return
    if ( a%missingValue /= b%missingValue ) return
    if ( any( a%Lats /= b%Lats ) ) return
    if ( any( a%Lons /= b%Lons ) ) return
    if ( any( a%Lsts /= b%Lsts ) ) return
    if ( any( a%Szas /= b%Szas ) ) return
    if ( any( a%DateStarts /= b%DateStarts ) ) return
    if ( any( a%DateEnds /= b%DateEnds ) ) return
    match = .true.
  contains
    subroutine explain( message )
      character(len=*), intent(in) :: message
      call output( trim(message), advance='yes' )
    end subroutine explain
  end function DoGriddeddataMatch

  ! ---------------------------------------- DownSampleGriddedData ------
  ! Given a gridded data type on a (too-)fine resolution, create a new
  ! one on a coarser mesh defined by steps through the finer mesh
  ! E.g., a latsStep of 2 means choosing every 2nd latitude
  
  ! See also SliceGriddeddata
  ! Why did we choose 2, 4, 6, .. instead of 1, 3, 5 ?
  ! Also what if number of steps does not divide mesh points
  ! into whole number?
  
  ! Suggested improvement:
  ! we already have various implementations of hyperslab in the software
  ! so just reuse one of them;
  ! i.e., pass in start, stride, and edge arrays
  subroutine DownSampleGriddedData ( Grid, Newgrid, &
    & heightsStep, latsStep, lonsStep, lstsStep, szasStep, datesStep, &
    & firstheights, firstlats, firstlons, firstlsts, firstszas, firstdates )

    type ( GriddedData_T ), intent(inout) :: Grid ! Input grid
    type ( GriddedData_T ), intent(out)   :: Newgrid ! Result
    integer, intent(in)                   :: heightsStep
    integer, intent(in)                   :: latsStep
    integer, intent(in)                   :: lonsStep
    integer, intent(in)                   :: lstsStep
    integer, intent(in)                   :: szasStep
    integer, intent(in)                   :: datesStep
    integer, intent(in)                   :: firstheights
    integer, intent(in)                   :: firstlats
    integer, intent(in)                   :: firstlons
    integer, intent(in)                   :: firstlsts
    integer, intent(in)                   :: firstszas
    integer, intent(in)                   :: firstdates
    ! Internal variables
    integer                   :: noheights
    integer                   :: nolats
    integer                   :: nolons
    integer                   :: nolsts
    integer                   :: noszas
    integer                   :: nodates
    ! Executable
    noheights = (grid%noheights - 1)/heightsStep + 1
    nolats    = (grid%nolats - 1   )/latsStep    + 1
    nolons    = (grid%nolons - 1   )/lonsStep    + 1
    nolsts    = (grid%nolsts - 1   )/lstsStep    + 1
    noszas    = (grid%noszas - 1   )/szasStep    + 1
    nodates   = (grid%nodates - 1  )/datesStep   + 1
    ! call outputNamedValue( 'grid%noheights ', grid%noheights )
    ! call outputNamedValue( 'heightsStep ', heightsStep )
    ! call outputNamedValue( 'noheights ', noheights )
    ! call outputNamedValue( 'nolats    ', nolats    )
    ! call outputNamedValue( 'nolons    ', nolons    )
    ! call outputNamedValue( 'nolsts    ', nolsts    )
    ! call outputNamedValue( 'noszas    ', noszas    )
    ! call outputNamedValue( 'nodates   ', nodates   )
    ! call dump( grid, details=1 )
    ! Set up newgrid
    call SetupNewGriddedData ( newgrid, grid, NoHeights, NoLats, &
      & NoLons, NoLsts, NoSzas, NoDates )
    ! Now fill its geo-fields
    newgrid%heights = grid%heights( heightsStep::heightsStep )
    newgrid%lats = grid%lats( firstlats::latsStep )
    newgrid%lons = grid%lons( firstlons::lonsStep )
    newgrid%lsts = grid%lsts( firstlsts::lstsStep )
    newgrid%szas = grid%szas( firstszas::szasStep )
    newgrid%dateStarts = grid%dateStarts( datesStep::datesStep )
    newgrid%dateEnds = grid%dateEnds( datesStep::datesStep )
    ! Now the multidimension gridded field values
    newgrid%field = grid%field( &
      & firstheights::heightsStep, &
      & firstlats   ::latsStep, &
      & firstlons   ::lonsStep, &
      & firstlsts   ::lstsStep, &
      & firstszas   ::szasStep, &
      & firstdates  ::datesStep &
      & )
    ! call dump( newgrid, details=1 )
  end subroutine DownSampleGriddedData

  ! ----------------------------------------  DumpGriddedDatabase  -----
  subroutine DumpGriddedDatabase ( GriddedData, Details, options )

    ! Imitating what dump_pointing_grid_database does, but for gridded data
    ! which may come from climatology, ncep, dao

    type (GriddedData_T), dimension(:), pointer :: GriddedData 

    integer, intent(in), optional               :: DETAILS ! If -4, just show footprint
    character(len=*), intent(in), optional      :: OPTIONS
    
    ! Local Variables
    integer            :: i
    integer            :: MYDETAILS
    real               :: total

    myDetails = 0
    if ( present(details) ) myDetails = details
    if ( .not. associated(GriddedData)) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Gridded database still null')

    if ( myDetails < -3 ) call SuspendOutput
    call output ( '============ Gridded Data Base ============', advance='yes' )
    call output ( ' ', advance='yes' )
    call output ( 'database: a priori grids: SIZE = ' )
    call output ( size(GriddedData), advance='yes' )
    if ( size(GriddedData) < 1 ) return
    total = 0.
    do i = 1, size(GriddedData)

      call outputNamedValue ( 'item number', i, advance='no' )
      if ( myDetails < -2 ) then
        call outputNamedValue('  Gridded quantity name ', &
          & trim(GriddedData(i)%quantityName), advance='no')
        call OutputNamedValue ( '  empty', GriddedData(i)%empty )
      else
        call DumpGriddedData( GriddedData(i), Details, Options )
      endif
      if ( .not. associated(GriddedData(i)%field) ) cycle
      total = total + product(shape(GriddedData(i)%field))
    end do ! i
    if ( myDetails < -3 ) call ResumeOutput
    call outputNamedValue( 'Database Total Memory Footprint', &
      & bytes(GriddedData(1)%field) * total )
  end subroutine DumpGriddedDatabase

  ! --------------------------------------------  DumpGriddedData  -----
  subroutine DumpGriddedData ( GriddedData, Details, options )
    use Dump_0, only: Dump
    use Ieee_Arithmetic, only: Ieee_Is_Finite, Ieee_Is_Nan
    use Intrinsic, only: Lit_Indices, Spec_Indices
    use String_Table, only: Display_String

    ! Imitating what dump_pointing_grid_database does, but for gridded data
    ! which may come from climatology, ncep, dao
    type (GriddedData_T) :: GriddedData 
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but name
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 0
    !                                        ! > 2 Climatology text file format
    character(len=*), intent(in), optional      :: OPTIONS
    ! Options, if present, says which of the 6 possible dimensions
    ! to include in the multi-dim dump of the gridded field
    ! E.g., if options = 'lat, height, time' then just dump the 3-d array
    !   field (:,:,1,1,1,:)
    ! Local Variables
    integer :: caseID
    character(len=8) :: ccsds
    integer :: date
    character(len=4) :: dateChar
    integer :: FIELDVALUESDETAILS
    integer :: i
    logical :: lookLikeClimatologyTxtfile
    integer :: MYDETAILS
    character(len=16) :: myOptions
    integer :: numElmnts
    integer :: numSurfs
    character(len=32) :: oldInfo

    ! Executable code
    myDetails = 0
    if ( present(details) ) myDetails = details
    fieldvaluesdetails = myDetails
    if ( index(ALWAYSDUMPTHESE, trim(GriddedData%description)) > 0 ) then
      myDetails = max( myDetails, 1 )
      fieldvaluesdetails = max(fieldvaluesdetails, AUTOMATICDETAILS)
    endif
    lookLikeClimatologyTxtfile = ( myDetails > 2 ) .and. .not. present(options)
    myOptions = ' '
    if ( present(options) ) myOptions = lowerCase(options)
    if ( myOptions == '-' ) myOptions = ' '
    if ( GriddedData%empty ) then
      call output('This Gridded quantity was empty', advance='yes')
      return
    endif
    if ( lookLikeClimatologyTxtfile ) then
      call newLine
      ! Format dump to look like Climatology text file
      call output('Field ' // trim(GriddedData%quantityName), advance='no')
      call blanks (3)
      call output(trim(GriddedData%units), advance='yes')
      ! Vertical coords
      outputOptions%arrayElmntSeparator = ','
      outputOptions%nArrayElmntsPerLine = 6
      call output('; Define vertical coordinates', advance='yes')
      call output('Pressure ', advance='no')
      call output('Explicit ', advance='no')
      call output('( ', advance='yes')
      call output(GriddedData%heights, advance='no')
      call output(') ', advance='yes')
      ! Horizontal coords
      call output('; Define horizontal coordinates etc.', advance='yes')
      call output('Latitude ', advance='no')
      call output('Explicit ', advance='no')
      call output('( ', advance='yes')
      call output(GriddedData%Lats, advance='no')
      call output(') ', advance='yes')
      call output('Longitude ', advance='no')
      call output('Explicit ', advance='no')
      call output('( ', advance='yes')
      call output(GriddedData%Lons, advance='no')
      call output(') ', advance='yes')
      if ( associated(GriddedData%Lsts) ) then
        call output('lst ', advance='no')
        call output('Explicit ', advance='no')
        call output('( ', advance='yes')
        call output(GriddedData%Lsts, advance='no')
        call output(') ', advance='yes')
      endif
      if ( associated(GriddedData%Szas) ) then
        call output('sza ', advance='no')
        call output('Explicit ', advance='no')
        call output('( ', advance='yes')
        call output(GriddedData%Szas, advance='no')
        call output(') ', advance='yes')
      endif
      outputOptions%arrayElmntSeparator = ' '
      outputOptions%nArrayElmntsPerLine = 7
      outputOptions%nBlanksBtwnElmnts   = 1
      outputOptions%sdFormatDefault     = '(1pe10.3)'
      numElmnts = GriddedData%noHeights * &
        & max(1, size(GriddedData%Lats)) * &
        & max(1, size(GriddedData%Lons)) * &
        & max(1, size(GriddedData%Lsts)) * &
        & max(1, size(GriddedData%Szas))
      do i=1, size(GriddedData%DateStarts)
        ccsds = tai2ccsds( int(GriddedData%DateStarts(i) / 86400 + 0.5) )
        !if ( i > 1 ) then
        !   date = (GriddedData%DateStarts(i) - GriddedData%DateStarts(1)) / 86400 + 1.5
        !else
        !  date = 1
        !endif
        read( ccsds(6:8), *) date
        call output('Date Single ', advance='no')
        call output(-date, advance='yes')
        call output( reshape( GriddedData%field(:,:,:,:,:,i), (/numElmnts/) ), &
          & advance='no')
        call newLine
      enddo
      outputOptions%sdFormatDefault     = '*' ! Restore default format
      outputOptions%nBlanksBtwnElmnts   = 3
      return
    endif
    call output('Gridded quantity name ' // GriddedData%quantityName, advance='yes')
    if ( associated(GriddedData%field)) then
      call OutputNamedValue ( 'shape(field)', &
        &  shape(GriddedData%field) )
      call OutputNamedValue ( 'Grid Memory Footprint', &
        &  byte_size(GriddedData%field) )
    endif
    if ( myDetails < -1 ) return
    oldInfo = MLSMessageConfig%Info
    MLSMessageConfig%Info = GriddedData%quantityName
    call output( 'fileType: ')
    if ( GriddedData%fileType < 1 ) then
      call output( '(unknown)', advance='yes' )
    else
      call display_string( spec_indices(GriddedData%fileType), advance='yes' )
    endif
    call output(' description ' // GriddedData%description, advance='yes')
    call output(' units ' // trim(GriddedData%units), advance='yes')
    call output(' missing value ', advance='no')
    call output(GriddedData%missingValue, advance='yes')

    call output ( ' ************ Geometry ********** ' ,advance='yes')

    call output ( ' Vertical coordinate = ' )
    if ( GriddedData%verticalCoordinate > 0 ) then
      call display_string ( lit_indices(GriddedData%verticalCoordinate), advance='yes' )
    else
      call output ( GriddedData%verticalCoordinate, advance='yes' )
    end if
    call output(' heights units ' // trim(GriddedData%heightsUnits), advance='yes')
    numSurfs = GriddedData%noHeights
    call output ( ' No. of heights = ' )
    call output ( GriddedData%noHeights, advance='yes' )
    if ( myDetails >= 0 ) call dump ( GriddedData%heights, &
      & '    Heights =' )

    call output ( ' Equivalent latitude = ' )
    call output ( GriddedData%equivalentLatitude, advance='yes' )
    call output ( ' No. of latitudes = ' )
    call output ( GriddedData%noLats, advance='yes' )
    if ( myDetails >= 0 ) call dump ( GriddedData%lats, &
      & '    latitudes =' )

    call output ( ' No. of longitudes = ' )
    call output ( GriddedData%noLons, advance='yes' )
    if ( myDetails >= 0 ) call dump ( GriddedData%lons, &
      & '    longitudes =' )

    call output ( ' No. of local times = ' )
    call output ( GriddedData%noLsts, advance='yes' )
    if ( myDetails >= 0 ) call dump ( GriddedData%lsts, &
      & '    local times =' )

    call output ( ' No. of solar zenith angles = ' )
    call output ( GriddedData%noSzas, advance='yes' )
    if ( myDetails >= 0 ) call dump ( GriddedData%szas, &
      & '    solar zenith angles =' )

    call output ( ' No. of dates = ' )
    call output ( GriddedData%noDates, advance='yes' )

    call dumpDates( GriddedData%dateStarts, 'starting dates' )
    call dumpDates( GriddedData%dateEnds, 'ending dates' )
    
    call output( 'No year in date? ' )
    call output( GriddedData%NoYear, advance='yes' )

    call output( 'Seasonal cyclic symmetry? ' )
    call output( GriddedData%NoYear .and. Griddeddata%noDates > 1, &
      & advance='yes' )

    if ( .not. all(ieee_is_finite(GriddedData%field)) ) &
      & call output ( '*** Gridded Data contains non-finite values', &
        & advance='yes' )
    if ( any(ieee_is_nan(GriddedData%field)) ) &
      & call output ( '*** Gridded Data contains nans', advance='yes' )
    if ( .not. associated(GriddedData%field) ) then
      call output ( ' Gridded Data field values empty', advance='yes' )
      return
    endif
    call outputNamedValue( 'max(values)', maxval(GriddedData%field) )
    call outputNamedValue( 'min(values)', minval(GriddedData%field) )
    call outputNamedValue( 'shape(values)', shape(GriddedData%field) )
    if ( len_trim(myOptions) > 0 ) then
      if ( GriddedData%noLons < 2 .and. index( myOptions, 'lon') > 0 ) &
        & myOptions = SnipList( myOptions, 'lon' )
      if ( GriddedData%noheights < 2 .and. index( myOptions, 'height') > 0 ) &
        & myOptions = SnipList( myOptions, 'height' )
      if ( GriddedData%nolats < 2 .and. index( myOptions, 'lat') > 0 ) &
        & myOptions = SnipList( myOptions, 'lat' )
      if ( GriddedData%noDates < 2 .and. index( myOptions, 'date') > 0 ) &
        & myOptions = SnipList( myOptions, 'date' )
      if ( GriddedData%nolsts < 2 .and. index( myOptions, 'lst') > 0 ) &
        & myOptions = SnipList( myOptions, 'lst' )
      if ( GriddedData%noszas < 2 .and. index( myOptions, 'sza') > 0 ) &
        & myOptions = SnipList( myOptions, 'sza' )
      caseID = 0
      if ( index(myOptions, 'height') > 0 ) caseID = caseID + 1
      if ( index(myOptions, 'lat') > 0 ) caseID = caseID + 2
      if ( index(myOptions, 'lon') > 0 ) caseID = caseID + 4
      if ( index(myOptions, 'lst') > 0 ) caseID = caseID + 8
      if ( index(myOptions, 'sza') > 0 ) caseID = caseID + 16
      if ( index(myOptions, 'date') > 0 ) caseID = caseID + 32
      call outputNamedValue( 'values dump options', trim(myOptions) )
      call outputNamedValue( 'caseID', caseID )
      select case (caseID)
      case ( 0 )
        call output( 'Default options for dumping values', advance='yes' )
        call outputNamedValue( 'values(1,1,..,1)', GriddedData%field(1,1,1,1,1,1) )
      case ( 1 )
        call dump ( GriddedData%field(:,1,1,1,1,1), &
          & '    gridded field values', FillValue=GriddedData%MissingValue )
      case ( 2 )
        call dump ( GriddedData%field(1,:,1,1,1,1), &
          & '    gridded field values', FillValue=GriddedData%MissingValue )
      case ( 3 )
        call dump ( GriddedData%field(:,:,1,1,1,1), &
          & '    gridded field values', FillValue=GriddedData%MissingValue )
      case ( 4 )
        call dump ( GriddedData%field(1,1,:,1,1,1), &
          & '    gridded field values', FillValue=GriddedData%MissingValue )
      case ( 7 )
        call dump ( GriddedData%field(:,:,:,1,1,1), &
          & '    gridded field values', FillValue=GriddedData%MissingValue )
      case ( 35 )
        ! call dump ( shape(GriddedData%field), 'shape(values)' )
        ! call dump ( shape(GriddedData%field(:,:,1,1,1,:)), 'shape(dumped values)' )
        call dump ( GriddedData%field(:,:,1,1,1,:), &
          & '    gridded field values', FillValue=GriddedData%MissingValue )
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'This case not coded' )
      end select
    elseif ( MAYDUMPFIELDVALUES .and. fieldvaluesdetails > 0 ) then
      call output ( ' ************ tabulated field values ********** ' ,advance='yes')
      if ( fieldvaluesdetails < 2 ) then
      ! Do 1d slices through data
        if ( size(GriddedData%field, 1 ) > 1 ) &
          & call dump ( GriddedData%field(:,1,1,1,1,1), &
          & '    gridded field values sliced through heights =', &
          & FillValue=GriddedData%MissingValue )
        if ( size(GriddedData%field, 2 ) > 1 ) &
          & call dump ( GriddedData%field(numSurfs,:,1,1,1,1), &
          & '    gridded field values sliced through lats =', &
          & FillValue=GriddedData%MissingValue )
        if ( size(GriddedData%field, 3 ) > 1 ) &
          & call dump ( GriddedData%field(numSurfs,1,:,1,1,1), &
          & '    gridded field values sliced through lons =', &
          & FillValue=GriddedData%MissingValue )
        if ( size(GriddedData%field, 4 ) > 1 ) &
          & call dump ( GriddedData%field(1,1,1,:,1,1), &
          & '    gridded field values sliced through sol times =', &
          & FillValue=GriddedData%MissingValue )
        if ( size(GriddedData%field, 5 ) > 1 ) &
          & call dump ( GriddedData%field(1,1,1,1,:,1), &
          & '    gridded field values sliced through sol zeniths =', &
          & FillValue=GriddedData%MissingValue )
        if ( size(GriddedData%field, 6 ) > 1 ) &
          & call dump ( GriddedData%field(1,1,1,1,1,:), &
          & '    gridded field values sliced through dates =', &
          & FillValue=GriddedData%MissingValue )
     ! May dump a 3-d slice of 6-d array
      elseif ( GriddedData%noDates == 1 .and. GriddedData%noSzas == 1 &
        & .and. GriddedData%noLsts == 1 ) then
        call dump ( GriddedData%field(:,:,:,1,1,1), &
          & '    gridded field values =', &
          & FillValue=GriddedData%MissingValue )
      elseif ( GriddedData%noDates == 1 .and. GriddedData%noSzas == 1 ) then
     ! May dump a 3-d slices through this 4-d array
        call dump ( GriddedData%field(:,:,:,1,1,1), &
          & '    gridded field values (1st solar time) =' , &
          & FillValue=GriddedData%MissingValue )
        call dump ( GriddedData%field(:,:,1,:,1,1), &
          & '    gridded field values (1st longitude) =' , &
          & FillValue=GriddedData%MissingValue )
        call dump ( GriddedData%field(:,1,:,:,1,1), &
          & '    gridded field values (1st latitude) =' )
        call dump ( GriddedData%field(1,:,:,:,1,1), &
          & '    gridded field values (1st height) =' , &
          & FillValue=GriddedData%MissingValue )
      elseif ( GriddedData%noSzas == 1 .and. GriddedData%noLsts == 1 ) then
     ! May dump a 4-d array as noDates instances of 3-d arrays
        do date=1, GriddedData%noDates
          write(dateChar, '(i4)') date
          call dump ( GriddedData%field(:,:,:,1,1,date), &
            & '    gridded field values (' // &
            & trim(dateChar) // 'th solar time) =' , &
            & FillValue=GriddedData%MissingValue )
        enddo
      else
        ! No dump for 6-dimensional double arrays yet, anyway
        !     call dump ( GriddedData%field, &
        !      & '    gridded field values =' )
        call output ( ' *(Sorry, dump_6d_... not yet coded)* ' , &
          & advance='yes')
      endif
    endif
    MLSMessageConfig%Info = oldInfo
  end subroutine DumpGriddedData

  ! ----------------------------------------  SetupNewGriddedData  -----
  subroutine SetupNewGriddedData ( Qty, Source, NoHeights, NoLats, &
    & NoLons, NoLsts, NoSzas, NoDates, missingValue, verticalCoordinate, &
    & units, heightsUnits, Empty )
  ! This first routine sets up a new grid according to the user
  ! input.  This may be based partly on an already-defined source
  ! or created from scratch.
    ! Dummy arguments
    type (GriddedData_T) :: QTY ! Result
    type (GriddedData_T), optional, intent(in) :: SOURCE ! Template
    integer, optional, intent(in) :: NOHEIGHTS, NOLATS, NOLONS, NOLSTS, NOSZAS, NODATES
    integer, optional, intent(in) :: verticalCoordinate
    character(len=*), optional, intent(in) :: units
    character(len=*), optional, intent(in) :: heightsUnits
    logical, optional, intent(in) :: EMPTY
    real(rgr), optional, intent(in) :: missingValue
    ! Local parameters
    ! real(rgr), parameter :: DefaultMissingValue = undefinedValue ! -999.99
    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: status                   ! Status from allocates etc.
    logical :: myEmpty                  ! Copy of empty possibly
    logical :: verbose

    ! Executable code
    verbose = switchDetail(switches, 'grid') > -1
    qty%description    = '(unknown)'
    qty%sourceFileName = '(unknown)'
    qty%quantityName   = '(unknown)'
    qty%units          = '(unknown)'
    qty%heightsUnits   = '(unknown)'
    qty%dimList        = '(unknown)'
    qty%deferReading   = .false.

    myEmpty = .false.
    if ( present ( empty ) ) myEmpty = empty
    if ( present ( source ) .and. .not. present ( empty )  ) myEmpty = source%empty
    if ( myEmpty ) then
      qty%empty = .true.
      qty%noHeights = 0
      qty%noLats = 0
      qty%noLons = 0
      qty%noLsts = 0
      qty%noSzas = 0
      qty%noDates = 0
    else
      qty%empty = .false.
      
      ! Set sensible values for some parameters
      ! First, if we have a template setup according to that
      if (present(source)) then
        qty%noHeights = source%noHeights
        qty%noLats = source%noLats
        qty%noLons = source%noLons
        qty%noLsts = source%noLsts
        qty%noSzas = source%noSzas
        qty%noDates = source%noDates
        qty%equivalentLatitude = source%equivalentLatitude
        qty%noYear = source%noYear
        qty%missingValue = source%missingValue
        qty%verticalCoordinate = source%verticalCoordinate
        qty%units = source%units
        qty%quantityName = source%quantityName
        qty%heightsUnits = source%heightsUnits
        qty%dimList = source%dimList
      else ! We have no template, setup a very bare quantity
        qty%noHeights = 1
        qty%noLats = 1
        qty%noLons = 1
        qty%noLsts = 1
        qty%noSzas = 1
        qty%noDates = 1
        qty%equivalentLatitude = .false.
        qty%noYear = .false.
        qty%missingValue = undefinedValue ! defaultMissingValue
        qty%verticalCoordinate = -1
        qty%units = '(unknown)'
        qty%heightsUnits = '(unknown)'
      endif
      
      ! Now, see if the user asked for modifications to this
      if (present(noHeights)) qty%noHeights = noHeights
      if (present(noLats)) qty%noLats = noLats
      if (present(noLons)) qty%noLons = noLons
      if (present(noLsts)) qty%noLsts = noLsts
      if (present(noSzas)) qty%noSzas = noSzas
      if (present(noDates)) qty%noDates = noDates
      if ( present ( missingValue ) ) qty%missingValue = missingValue
      if ( present ( verticalCoordinate ) ) qty%verticalCoordinate = verticalCoordinate
      if ( present ( units ) ) qty%units = units
      if ( present ( heightsunits ) ) qty%heightsunits = heightsunits
    end if

    ! First the vertical/horizontal coordinates
    if ( verbose .and. qty%noHeights > 0 ) then
      call outputNamedValue( 'qty%noHeights', qty%noHeights )
      call outputNamedValue( 'qty%noLats', qty%noLats )
      call outputNamedValue( 'qty%noLons', qty%noLons )
      call outputNamedValue( 'qty%noLsts', qty%noLsts )
      call outputNamedValue( 'qty%noSzas', qty%noSzas )
      call outputNamedValue( 'qty%noDates', qty%noDates )
      call outputNamedValue( 'Bytes before allocating vertical/horizontal coordinates', &
        & NoBytesAllocated )
    endif
    call Allocate_test ( qty%heights, qty%noHeights, "griddedQty%heights", ModuleName )
    call Allocate_test ( qty%lats, qty%noLats, "griddedQty%lats", ModuleName )
    call Allocate_test ( qty%lons, qty%noLons, "griddedQty%lons", ModuleName )
    call Allocate_test ( qty%lsts, qty%noLsts, "griddedQty%lsts", ModuleName )
    call Allocate_test ( qty%szas, qty%noSzas, "griddedQty%szas", ModuleName )

    ! Now the temporal coordinates
    call Allocate_test ( qty%dateStarts, qty%noDates, "griddedQty%dateStarts", ModuleName )
    call Allocate_test ( qty%dateEnds, qty%noDates, "griddedQty%dateEnds", ModuleName )

    ! Now the data itself
    if ( verbose ) call outputNamedValue( 'Bytes before allocating grid%field', NoBytesAllocated )
    allocate(qty%field(qty%noHeights, qty%noLats, qty%noLons,  &
      qty%noLsts, qty%noSzas, qty%noDates), STAT=status)
    if ( status == 0 ) then
      if ( size(qty%field) > 0 ) addr = transfer(c_loc(qty%field(1,1,1,1,1,1)), addr)
    end if
    call test_allocate ( status, moduleName, "griddedQty%field", (/1,1,1,1,1,1/), &
      & (/ qty%noHeights, qty%noLats, qty%noLons, qty%noLsts, qty%noSzas, &
      &    qty%noDates /), bytes(qty%field), address=addr )
    if ( verbose ) then
      call outputNamedValue( 'Bytes after allocating grid%field', NoBytesAllocated )
      call outputNamedValue( 'Size of field (elements)', product(shape(qty%field)) )
      call outputNamedValue( 'Byte Size of field', byte_size(qty%field) )
    endif
  
  end subroutine SetupNewGriddedData

  ! ----------------------------------------NullifyGriddedData -----
  subroutine NullifyGriddedData ( G )
    ! Given a GriddedData, nullify all the pointers associated with it
    type ( GriddedData_T ) :: G

    ! Executable code
    nullify ( g%fileComments )
    nullify ( g%heights )
    nullify ( g%lats )
    nullify ( g%lons )
    nullify ( g%lsts )
    nullify ( g%szas )
    nullify ( g%dateStarts )
    nullify ( g%dateEnds )
    nullify ( g%field )
  end subroutine NullifyGriddedData

  ! ---------------------------------------- SliceGriddedData ------
  ! 1st suggestion:
  ! Rename this procedure something more apt
  ! E.g., 'Regrid' or 'Resample'
  ! Here would be a good place to describe the purpose and method of this
  ! procedure (hint, hint)
  ! I (paw) did not write this but I can take a stab at it
  ! return an array with values of the griddeddata's field at mesh
  ! points defined by the supplied heights, lats, etc.
  ! Where and if the new mesh points do not exactly line up with the old
  ! produce a weighted average from the corners (vertices) of the smallest
  ! 6-dimensional hypercube of old mesh points surrounding each new mesh point
  ! Confusing? Maybe a picture would help ..
  ! If we had not 6 dimensions but only 2, let lowercase letters be the old mesh
  ! points and upper case letters be the new mesh points. Then we would look
  ! for points a, b, c, and d such that for point P
  !
  !   a            b
  !
  !       P
  !
  !   c            d
  ! and determine the value at P by weighting the values at a, b, c, and d
  ! according to a mysterious formula I have not taken the trouble to
  ! understand, but which, among other wrinkles, treats heights logarithmically
  ! and makes an effort to avoid allowing undefined values to exert a
  ! corrupting and baleful influence if they should be found at a, b, c, or d
  
  ! See also DownSampleGriddeddata
  subroutine SliceGriddedData ( grid, slice, &
    & heights, lats, lons, lsts, szas, dates, missingValue )

    use MLSNumerics, only: Hunt

    type ( GriddedData_T ), intent(inout) :: GRID ! Input grid
    real(rgr), dimension(:,:,:,:,:,:), intent(out) :: SLICE ! Result
    real(rgr), dimension(:), intent(in) :: HEIGHTS
    real(rgr), dimension(:), intent(in) :: LATS
    real(rgr), dimension(:), intent(in) :: LONS
    real(rgr), dimension(:), intent(in) :: LSTS
    real(rgr), dimension(:), intent(in) :: SZAS
    real(r8),  dimension(:), intent(in) :: DATES
    real(rgr), optional, intent(in) :: MISSINGVALUE

    ! Local parameters
    logical, parameter :: DEEBUG = .false.
    real(r8), parameter :: NOSECONDSINMEANYEAR = 9.55+60.0*(9.0+60.0*(6.0+24.0*365.0))
    ! 365 days, 6 hours, 9 minutes, 9.55 seconds

    ! Local variables
    integer :: Me = -1                  ! String index for trace cacheing
    ! Dimensions of the slice
    integer :: NOHEIGHTS, NOLATS, NOLONS, NOLSTS, NOSZAS, NODATES
    ! Number of corners
    integer :: NOCORNERS
    ! Missing value to use
    real(r8) :: MYMISSINGVALUE

    ! Now the indices for each corner
    integer, dimension(size(heights),2) :: HEIGHTI
    integer, dimension(size(lats),2)    :: LATI
    integer, dimension(size(lons),2)    :: LONI
    integer, dimension(size(lsts),2)    :: LSTI
    integer, dimension(size(szas),2)    :: SZAI
    integer, dimension(size(dates),2)   :: DATEI

    ! Now the weights for each corner
    real(r8), dimension(size(heights),2) :: HEIGHTW
    real(r8), dimension(size(lats),2)    :: LATW
    real(r8), dimension(size(lons),2)    :: LONW
    real(r8), dimension(size(lsts),2)    :: LSTW
    real(r8), dimension(size(szas),2)    :: SZAW
    real(r8), dimension(size(dates),2)   :: DATEW

    ! Some extra special stuff for the dates
    real(r8), dimension(grid%noDates) :: MEANGRIDDATES
    real(r8), dimension(size(dates)) :: MODIFIEDINDATES
    integer :: YEARNUMBER

    ! Indices and loop counters
    integer :: C
    integer :: HEIGHT, LAT, LON, LST, SZA, DATE
    integer :: HEIGHTFAC, LATFAC, LONFAC, LSTFAC, SZAFAC, DATEFAC
    ! Indices of corner stuff
    integer, dimension(:), pointer :: HEIGHTC
    integer, dimension(:), pointer :: LATC
    integer, dimension(:), pointer :: LONC
    integer, dimension(:), pointer :: LSTC
    integer, dimension(:), pointer :: SZAC
    integer, dimension(:), pointer :: DATEC
    ! One result
    real(r8) :: VAL
    real(r8), dimension(size(heights)) :: subSlice

    ! Executable code
    call trace_begin ( me, 'SliceGriddedData' , cond=.false. )
    myMissingValue = grid%missingValue
    if ( present ( missingValue ) ) myMissingValue = missingValue
    ! Get size of problem and check things out
    noHeights = size(heights)
    noLats = size(lats)
    noLons = size(lons)
    noLsts = size(lsts)
    noSzas = size(szas)
    noDates = size(dates)
    
    if ( any ( shape(slice) /= &
      &  (/ noHeights, noLats, noLons, noLsts, noSzas, noDates /) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Inappropriate size for slice' )

    ! Ensure the the input grid is 'wrapped'
    call WrapGriddedData ( grid )

    ! Now work out vertices and weights, and the number of corners
    noCorners = 1

    ! Height:
    if ( grid%noHeights == 1 ) then
      heightI = 1
      heightW(:,1) = 1.0_r8
      heightW(:,2) = 0.0_r8
      heightFac = 0
    else
      if ( grid%verticalCoordinate == v_is_pressure ) then
        call Hunt ( -log10(grid%heights), -log10(heights), heightI(:,1) )
        heightI(:,2) = heightI(:,1) + 1
        heightW(:,1) = max ( 0.0_rgr, min ( 1.0_rgr, &
          & ( -log10(grid%heights(heightI(:,2))) + log10(heights) ) / &
          & ( -log10(grid%heights(heightI(:,2))) + &
          &    log10(grid%heights(heightI(:,1))) ) ))
        heightW(:,2) = 1.0_rgr - heightW(:,1)
        
      else
        call Hunt ( grid%heights, heights, heightI(:,1) )
        heightI(:,2) = heightI(:,1) + 1
        heightW(:,1) = max ( 0.0_rgr, min ( 1.0_rgr, &
          & ( grid%heights(heightI(:,2)) - heights ) / &
          & ( grid%heights(heightI(:,2)) - grid%heights(heightI(:,1)) ) ))
        heightW(:,2) = 1.0_rgr - heightW(:,1)
      end if
      heightFac = noCorners
      noCorners = noCorners * 2
    end if

    ! Latitude
    if ( grid%noLats == 1 ) then
      latI = 1
      latW(:,1) = 1.0_r8
      latW(:,2) = 0.0_r8
      latFac = 0
    else
      call Hunt ( grid%lats, lats, latI(:,1) )
      latI(:,2) = latI(:,1) + 1
      latW(:,1) = max ( 0.0_rgr, min ( 1.0_rgr, &
        & ( grid%lats(latI(:,2)) - lats ) / &
        & ( grid%lats(latI(:,2)) - grid%lats(latI(:,1)) ) ))
      latW(:,2) = 1.0_rgr - latW(:,1)
      latFac = noCorners
      noCorners = noCorners * 2
    end if

    ! Longitude
    if ( grid%noLons == 1 ) then
      lonI = 1
      lonW(:,1) = 1.0_r8
      lonW(:,2) = 0.0_r8
      lonFac = 0
    else
      call Hunt ( grid%lons, lons, lonI(:,1) )
      lonI(:,2) = lonI(:,1) + 1
      lonW(:,1) = max ( 0.0_rgr, min ( 1.0_rgr, &
        & ( grid%lons(lonI(:,2)) - lons ) / &
        & ( grid%lons(lonI(:,2)) - grid%lons(lonI(:,1)) ) ))
      lonW(:,2) = 1.0_rgr - lonW(:,1)
      lonFac = noCorners
      noCorners = noCorners * 2
    end if
    
    ! Local solar time
    if ( grid%noLsts == 1 ) then
      lstI = 1
      lstW(:,1) = 1.0_r8
      lstW(:,2) = 0.0_r8
      lstFac = 0
    else
      call Hunt ( grid%lsts, lsts, lstI(:,1) )
      lstI(:,2) = lstI(:,1) + 1
      lstW(:,1) = max ( 0.0_rgr, min ( 1.0_rgr, &
        & ( grid%lsts(lstI(:,2)) - lsts ) / &
        & ( grid%lsts(lstI(:,2)) - grid%lsts(lstI(:,1)) ) ))
      lstW(:,2) = 1.0_rgr - lstW(:,1)
      lstFac = noCorners
      noCorners = noCorners * 2
    end if
    
    ! Solar zenith angle
    if ( grid%noSzas == 1 ) then
      szaI = 1
      szaW(:,1) = 1.0_r8
      szaW(:,2) = 0.0_r8
      szaFac = 0
    else
      call Hunt ( grid%szas, szas, szaI(:,1) )
      szaI(:,2) = szaI(:,1) + 1
      szaW(:,1) = max ( 0.0_rgr, min ( 1.0_rgr, &
        & ( grid%szas(szaI(:,2)) - szas ) / &
        & ( grid%szas(szaI(:,2)) - grid%szas(szaI(:,1)) ) ))
      szaW(:,2) = 1.0_rgr - szaW(:,1)
      szaFac = noCorners
      noCorners = noCorners * 2
    end if

    ! Dates.  Here we have to be a little clever
    meanGridDates = ( grid%dateStarts + grid%dateEnds ) / 2.0
    modifiedInDates = dates
    if ( grid%noYear ) then
      ! For 'noYear' grids, subtract the year of the dates
      ! Note, I'm not going to be terribly graceful about going over the
      ! year boundary, or for that matter leap years etc.
      yearNumber = int ( minval(modifiedInDates) / noSecondsInMeanYear )
      if ( minval(modifiedInDates) < 0. ) yearNumber = yearNumber - 1
      modifiedInDates = modifiedInDates - yearNumber * noSecondsInMeanYear
      if ( deebug ) then
        call outputNamedValue( 'yearNumber', yearNumber )
        call outputNamedValue( 'modifiedInDates', modifiedInDates(1) )
        call outputNamedValue( 'meanGridDates', meanGridDates(1) )
      endif
    endif
    if ( grid%noDates == 1 ) then
      dateI = 1
      dateW(:,1) = 1.0_r8
      dateW(:,2) = 0.0_r8
      dateFac = 0
    else
      call Hunt ( meanGridDates, modifiedInDates, dateI(:,1) )
      dateI(:,2) = dateI(:,1) + 1
      dateW(:,1) = max ( 0.0_r8, min ( 1.0_r8, &
        & ( meanGridDates(dateI(:,2)) - modifiedInDates ) / &
        & ( meanGridDates(dateI(:,2)) - meanGridDates(dateI(:,1)) ) ))
      dateW(:,2) = 1.0_r8 - dateW(:,1)
      dateFac = noCorners
      noCorners = noCorners * 2
    end if

    ! Now work out the corner information
    nullify ( heightC, latC, lonC, lstC, szaC, dateC )
    call Allocate_test ( heightC, noCorners, 'heightC', ModuleName )
    call Allocate_test ( latC, noCorners, 'latC', ModuleName )
    call Allocate_test ( lonC, noCorners, 'lonC', ModuleName )
    call Allocate_test ( lstC, noCorners, 'lstC', ModuleName )
    call Allocate_test ( szaC, noCorners, 'szaC', ModuleName )
    call Allocate_test ( dateC, noCorners, 'dateC', ModuleName )

    do c = 1, noCorners
      if ( heightFac == 0 ) then
        heightC(c) = 1
      else
        heightC(c) = merge ( 1, 2, mod((c-1)/heightFac,2) == 0 )
      end if

      if ( latFac == 0 ) then
        latC(c) = 1
      else
        latC(c) = merge ( 1, 2, mod((c-1)/latFac,2) == 0 )
      end if

      if ( lonFac == 0 ) then
        lonC(c) = 1
      else
        lonC(c) = merge ( 1, 2, mod((c-1)/lonFac,2) == 0 )
      end if

      if ( lstFac == 0 ) then
        lstC(c) = 1
      else
        lstC(c) = merge ( 1, 2, mod((c-1)/lstFac,2) == 0 )
      end if

      if ( szaFac == 0 ) then
        szaC(c) = 1
      else
        szaC(c) = merge ( 1, 2, mod((c-1)/szaFac,2) == 0 )
      end if

      if ( dateFac == 0 ) then
        dateC(c) = 1
      else
        dateC(c) = merge ( 1, 2, mod((c-1)/dateFac,2) == 0 )
      end if
    end do

    if ( DEEBUG ) then
    call output('slicing .. ' , advance='yes' )
    call outputNamedValue ( 'num corners', noCorners )
    call outputNamedValue ( 'heightFac', heightFac )
    call dump( heightC, 'heightC' )
    call dump( heightI, 'heightI' )
    call dump( heightW, 'heightW' )
    call outputNamedValue ( 'latFac', latFac )
    call dump( latC, 'latC' )
    call dump( latI, 'latI' )
    call dump( latW, 'latW' )
    call outputNamedValue ( 'lonFac', lonFac )
    call dump( lonC, 'lonC' )
    call dump( lonI, 'lonI' )
    call dump( lonW, 'lonW' )
    call outputNamedValue ( 'dateFac', dateFac )
    call dump( dateC, 'dateC' )
    call dump( dateI, 'dateI' )
    call dump( dateW, 'dateW' )
    call outputNamedValue ( 'szaFac', szaFac )
    call dump( szaC, 'szaC' )
    call dump( szaI, 'szaI' )
    call dump( szaW, 'szaW' )
    call outputNamedValue ( 'lstFac', lstFac )
    call dump( lstC, 'lstC' )
    call dump( lstI, 'lstI' )
    call dump( lstW, 'lstW' )
    call outputNamedValue ( 'missing value', grid%missingValue ) 
    call outputNamedValue ( 'any missing value?', any ( EssentiallyEqual ( grid%field, grid%missingValue ) ) )
    endif
    ! OK, now we do the work.
    ! We have two possibilities here.  If there are no bad datapoints
    ! then we can storm through, otherwise we have to be careful
    if ( any ( EssentiallyEqual ( grid%field, grid%missingValue ) ) ) then
      ! There are some missing values be very careful going throug the grid
      do date = 1, noDates
        do sza = 1, noSzas
          do lst = 1, noLsts
            do lon = 1, noLons
              do lat = 1, noLats
                subSlice = 0._r8
                do height = 1, noHeights
                  ! slice(height,lat,lon,lst,sza,date) = 0.0
                  cornerLoopMissing: do c = 1, noCorners
                    val = grid%field ( &
                      & heightI(height,heightC(c)), latI(lat,latC(c)), lonI(lon,lonC(c)), &
                      & lstI(lst,lstC(c)), szaI(sza,szaC(c)), dateI(date,dateC(c)) )
                    if ( EssentiallyEqual ( val, real(grid%missingValue, r8) ) ) then
                      ! slice(height,lat,lon,lst,sza,date) = myMissingValue
                      subSlice(height) = myMissingValue
                      exit cornerLoopMissing
                    end if
                    ! slice(height,lat,lon,lst,sza,date) = &
                      ! & slice(height,lat,lon,lst,sza,date) + val * &
                    subSlice(height) = subSlice(height) + val * &
                      & heightW(height,heightC(c)) * latW(lat,latC(c)) * lonW(lon,lonC(c)) * &
                      & lstW(lst,lstC(c)) * szaW(sza,szaC(c)) * dateW(date,dateC(c))
                  end do cornerLoopMissing
                end do
                slice(:,lat,lon,lst,sza,date) = subSlice
              end do
            end do
          end do
        end do
      end do
    else
      ! Otherwise there are none, storm through
      do date = 1, noDates
        do sza = 1, noSzas
          do lst = 1, noLsts
            do lon = 1, noLons
              do lat = 1, noLats
                subSlice = 0._r8
                do height = 1, noHeights
                  ! slice(height,lat,lon,lst,sza,date) = 0.0
                  do c = 1, noCorners
                    val = grid%field ( &
                      & heightI(height,heightC(c)), latI(lat,latC(c)), lonI(lon,lonC(c)), &
                      & lstI(lst,lstC(c)), szaI(sza,szaC(c)), dateI(date,dateC(c)) )
                    ! slice(height,lat,lon,lst,sza,date) = &
                    !  & slice(height,lat,lon,lst,sza,date) + val * &
                    subSlice(height) = subSlice(height) + val * &
                      & heightW(height,heightC(c)) * latW(lat,latC(c)) * lonW(lon,lonC(c)) * &
                      & lstW(lst,lstC(c)) * szaW(sza,szaC(c)) * dateW(date,dateC(c))
                    if ( height == 8 .and. lat == 1 .and. lon == 1 .and. &
                      & lst == 1 .and. sza == 1 .and. date == 1 .and. DEEBUG ) &
                      & call output ( (/ val, heightW(height,heightC(c)), &
                        & latW(lat,latC(c)), lonW(lon,lonC(c)), &
                        & lstW(lst,lstC(c)), szaW(sza,szaC(c)), dateW(date,dateC(c)) /), &
                        & advance='yes' )
                  end do
                end do
                slice(:,lat,lon,lst,sza,date) = subSlice
                if ( lat == 1 .and. lon == 1 .and. &
                  & lst == 1 .and. sza == 1 .and. date == 1 .and. DEEBUG ) &
                  & call output ( subSlice, advance='yes' )
              end do
            end do
          end do
        end do
      end do
    end if

    ! Tidy up
    call Deallocate_test ( heightC, 'heightC', ModuleName )
    call Deallocate_test ( latC, 'latC', ModuleName )
    call Deallocate_test ( lonC, 'lonC', ModuleName )
    call Deallocate_test ( lstC, 'lstC', ModuleName )
    call Deallocate_test ( szaC, 'szaC', ModuleName )
    call Deallocate_test ( dateC, 'dateC', ModuleName )
    if ( DEEBUG ) call dump ( slice(:,1:10,1,:,1,1), &
        & '    sliced field values (1st longitude) =' , &
        & FillValue=Grid%MissingValue )
    call trace_end ( 'SliceGriddedData' , cond=.false. )

  end subroutine SliceGriddedData

  ! -------------------------------------------- WrapGriddedData ---
  subroutine WrapGriddedData ( GRID )
    ! Given a grid, possibly add extra points in longitude beyond +/-180
    ! and in solar time beyond 0..24 to aid in interpolations.
    ! Dummy arguments
    type ( GriddedData_T ), intent(inout) :: GRID

    ! Local variables
    real (rgr), dimension(:), pointer :: NEWLONS
    real (rgr), dimension(:), pointer :: NEWLSTS
    real (rgr), dimension(:,:,:,:,:,:), pointer :: NEWFIELD
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: LOWERLON
    integer :: LOWERLST
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: S ! Size in bytes of a deallocated field
    integer :: STATUS
    integer :: UPPERLON
    integer :: UPPERLST

    ! Executable code
    call trace_begin ( me, 'WrapGriddedData' , cond=.false. )
    ! Don't bother with quantities that have no lon or lst variation.
    if ( grid%noLons <= 1 .and. grid%noLsts <= 1 ) go to 9

    ! Check that this field is appropriate
    ! These integers are the number of points at or beyond our boundaries
    lowerLon = count ( grid%lons <= -180.0 )
    upperLon = count ( grid%lons >= 180.0 )
    lowerLst = count ( grid%lsts <= 0.0 )
    upperLst = count ( grid%lsts >= 24.0 )

    ! Check for unconventional grids.  We'll allow the case of 1 point at or
    ! beyond our boundaries, as that could just mean it's already been wrapped.
    ! More than that however is a problem.
    if ( lowerLon > 1 .or. upperLon > 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Gridded data disobeys EOS convention of -180..180 longitude' )
    endif
    if ( lowerLst > 1 .or. upperLst > 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Gridded data disobeys EOS convention of 0..24 local time' )
    end if

    ! From this point on the integers are the number of points
    ! we need to add (0 or 1)
    lowerLon = 0
    upperLon = 0
    lowerLst = 0
    upperLst = 0

    if ( grid%noLons > 1 ) then
      if ( grid%lons(1) > -180.0 ) lowerLon = 1
      if ( grid%lons(grid%noLons) < 180.0 ) upperLon = 1
    end if
    if ( grid%noLsts > 1 ) then
      if ( grid%lsts(1) > 0.0 ) lowerLst = 1
      if ( grid%lsts(grid%noLsts ) < 24.0 ) upperLst = 1
    end if

    ! If these are all zero then there's nothing to do so we might
    ! as well quit and save time
    if ( all ( (/ lowerLon, upperLon, lowerLst, upperLst /) == 0 ) ) go to 9

    ! Create new arrays
    nullify ( newLons, newLSTs, newField )
    call Allocate_test ( newLons, grid%noLons + lowerLon + upperLon, &
      & 'newLons', ModuleName )
    call Allocate_test ( newLsts, grid%noLsts + lowerLst + upperLst, &
      & 'newLsts', ModuleName )
    allocate ( newField ( grid%noHeights, grid%noLats, &
      & grid%noLons + lowerLon + upperLon, &
      & grid%noLsts + lowerLst + upperLst, &
      & grid%noSzas, grid%noDates ), STAT=status )
    addr = 0
    if ( status==0 ) then
      if ( size(newField) > 0 ) addr = transfer(c_loc(newField(1,1,1,1,1,1)), addr)
    end if
    call test_allocate ( status, moduleName, 'newField', (/1,1,1,1,1,1/), &
      & (/ grid%noHeights, grid%noLats, &
      &    grid%noLons + lowerLon + upperLon, &
      &    grid%noLsts + lowerLst + upperLst, &
      &    grid%noSzas, grid%noDates /), bytes(newField), address=addr )

    ! Fill the 'central' part of the fields
    newLons ( 1+lowerLon : lowerLon+grid%noLons ) = grid%lons
    newLsts ( 1+lowerLst : lowerLst+grid%noLsts ) = grid%lsts

    ! Wrap edges
    if ( lowerLon == 1 ) then
      newLons(1) = grid%lons ( grid%noLons ) - 360.0
    end if
    if ( upperLon == 1 ) then
      newLons ( grid%noLons + lowerLon + 1 ) = grid%lons ( 1 ) + 360.0
    end if

    if ( lowerLst == 1 ) then
      newLsts(1) = grid%lsts ( grid%noLsts ) - 24.0
    end if
    if ( upperLst == 1 ) then
      newLsts ( grid%noLsts + lowerLst + 1 ) = grid%lsts ( 1 ) + 24.0
    end if

    call wraparrays( grid%field, newfield, lowerLon, upperLon, lowerLst, upperLst, &
    & grid%noLons, grid%noLsts )
    ! Tidy up
    call Deallocate_test ( grid%lons, 'grid%lons', ModuleName )
    call Deallocate_test ( grid%lsts, 'grid%lsts', ModuleName )
    s = byte_size(grid%field)
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(grid%field(1,1,1,1,1,1)), addr)
    deallocate ( grid%field, stat=status )
    call test_deallocate ( status, moduleName, 'grid%field', s, address=addr )

    ! Make grid use new values
    grid%noLons = grid%noLons + lowerLon + upperLon
    grid%noLsts = grid%noLsts + lowerLst + upperLst
    grid%lons => newLons
    grid%lsts => newLsts
    grid%field => newField
  9 call trace_end ( 'WrapGriddedData' , cond=.false. )

  end subroutine WrapGriddedData

  ! -------- Private ---------------
  subroutine wrapArrays ( old, new, lowerLon, upperLon, lowerLst, upperLst, &
    & oldNoLons, oldNoLsts )
  ! Hide our array shenanigans to
  ! (1) prevent compilers like NAG from using a temp array and running out
  !     of memory
  ! (2) prevent cleverer compilers like Intel from checking whether they
  !     need a temp array
  ! Args
    real (rgr), dimension(:,:,:,:,:,:) :: old
    real (rgr), dimension(:,:,:,:,:,:) :: new
    integer, intent(in) :: lowerLon, upperLon, lowerLst, upperLst, &
    & oldNoLons, oldNoLsts
    new ( :, :, &
      & 1+lowerLon : lowerLon+oldNoLons, &
      & 1+lowerLst : lowerLst+oldNoLsts, &
      & :, : ) = old
    ! Wrap edges
    if ( lowerLon == 1 ) then
      new ( :, :, 1, :, :, : ) = old ( :, :, oldNoLons, :, :, : )
    end if
    if ( upperLon == 1 ) then
      new ( :, :, oldNoLons + lowerLon + 1, :, :, : ) = &
        & old ( :, :, 1, :, : ,: )
    end if

    if ( lowerLst == 1 ) then
      new ( :, :, :, 1, :, : ) = old ( :, :, :, oldNoLsts, :, : )
    end if
    if ( upperLst == 1 ) then
      new ( :, :, :, oldNoLsts + lowerLst + 1, :, : ) = &
        & old ( :, :, :, 1, : ,: )
    end if
  end subroutine wrapArrays

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: GriddedData.f90,v 2.89 2020/05/29 21:54:49 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module GriddedData

!
! $Log: GriddedData.f90,v $
! Revision 2.89  2020/05/29 21:54:49  pwagner
! More detailed tracing of memory usage
!
! Revision 2.88  2020/04/30 23:20:59  pwagner
! If Details lt -2 will dump only name and whether empty
!
! Revision 2.87  2020/04/27 21:34:51  pwagner
! trace_.. added to more carefully track memory usage
!
! Revision 2.86  2019/10/03 17:31:24  pwagner
! Convert from eta levels may now take a vGrid field
!
! Revision 2.85  2019/09/23 20:38:32  pwagner
! Conversion from Eta surfaces may optionally be logarithmic
!
! Revision 2.84  2019/09/05 17:50:13  pwagner
! SetUp with sources quantityName, dimList, too
!
! Revision 2.83  2017/11/03 20:01:16  pwagner
! Most array gymnastics moved from MLSFillValues to HyperSlabs module
!
! Revision 2.82  2017/08/23 16:45:25  pwagner
! Fixed bug when Dates are before 1993
!
! Revision 2.81  2017/03/17 00:10:49  pwagner
! Optionally sayWhyNot if not DoGriddeddataMatch
!
! Revision 2.80  2016/07/28 01:42:27  vsnyder
! Refactoring dump and diff
!
! Revision 2.79  2015/03/28 01:01:03  vsnyder
! Stuff to trace allocate/deallocate addresses -- mostly commented out
! because NAG build 1017 doesn't yet allow arrays as arguments to C_LOC.
!
! Revision 2.78  2015/01/21 19:29:15  pwagner
! More debugging if PGrid, TGrid dont match
!
! Revision 2.77  2014/09/04 23:38:45  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.76  2014/07/18 22:00:24  pwagner
! Aimed for consistency in names passed to allocate_test
!
! Revision 2.75  2014/05/29 18:28:26  pwagner
! Correctly compute memory usage
!
! Revision 2.74  2014/01/09 00:25:06  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.73  2013/08/31 01:24:53  vsnyder
! Replace MLSMessageCalls with trace_begin and trace_end
!
! Revision 2.72  2013/08/30 03:56:01  vsnyder
! Revise use of trace_begin and trace_end
!
! Revision 2.71  2013/06/12 02:17:27  vsnyder
! UBYTES and BYTE_SIZE from Allocate_Deallocate
!
! Revision 2.70  2012/10/11 21:00:28  pwagner
! Print quantityName instead of moduleName during Dump
!
! Revision 2.69  2012/03/06 19:32:39  pwagner
! Remove more unused local variables
!
! Revision 2.68  2012/03/06 19:12:32  pwagner
! Say whether dumped grid has seasonal cyclic symmetry
!
! Revision 2.67  2012/03/01 20:01:40  pwagner
! When dumped, say whether grid is for no year
!
! Revision 2.66  2011/08/30 22:22:29  pwagner
! Destroying a Griddeddata now sets empty to TRUE so we can dump it later w/o error
!
! Revision 2.65  2011/06/29 21:37:17  pwagner
! Corrected bug in recalculating downsized dim sizes
!
! Revision 2.64  2011/06/16 23:00:09  pwagner
! Added DownSampleGriddedData
!
! Revision 2.63  2011/05/05 15:21:34  pwagner
! Added fileType field to datatype
!
! Revision 2.62  2011/04/27 17:34:25  pwagner
! dateStarts and -Ends now dumped as dates, not doubles
!
! Revision 2.61  2011/04/20 00:25:18  pwagner
! Dump now responds to options arg
!
! Revision 2.60  2010/02/09 16:24:12  pwagner
! Hide large array section assignments in subroutine to prevent NAG from creating temps
!
! Revision 2.59  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.58  2010/02/03 23:09:23  vsnyder
! Use Test_Deallocate
!
! Revision 2.57  2009/10/30 23:04:50  pwagner
! Added diff of gridded data
!
! Revision 2.56  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.55  2009/06/16 17:25:13  pwagner
! Can dump Gridded data to look like Climatology file
!
! Revision 2.54  2009/01/12 18:45:46  pwagner
! Added print statement to not_used_here
!
! Revision 2.53  2008/09/16 21:05:10  pwagner
! Improved dumps
!
! Revision 2.52  2008/06/06 22:52:21  pwagner
! EssentiallyEqual moved to MLSFillValues
!
! Revision 2.51  2008/01/07 21:36:33  pwagner
! Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
!
! Revision 2.50  2007/10/04 01:49:14  vsnyder
! Don't overflow the call stack
!
! Revision 2.49  2007/08/17 00:27:23  pwagner
! push more procedures onto MLSCallStack
!
! Revision 2.48  2007/08/13 17:35:24  pwagner
! Push SliceGriddedData onto new MLSSCallStack
!
! Revision 2.47  2007/07/27 00:23:57  vsnyder
! Use Test_Allocate after allocations
!
! Revision 2.46  2007/06/07 20:26:16  pwagner
! Prevents some crashes, writing non-ascii chars to stdout
!
! Revision 2.45  2007/03/23 00:10:49  pwagner
! Valiant attempts to bring two Lahey version results closer
!
! Revision 2.44  2007/01/30 21:57:44  pwagner
! Avoids a bug with empty grids in ConvertFromEtaLevelGrids
!
! Revision 2.43  2007/01/11 20:31:53  vsnyder
! Spiff up the dump
!
! Revision 2.42  2006/11/01 20:27:05  pwagner
! Hasty fix to units bug in eta-level conversion
!
! Revision 2.41  2006/06/14 23:58:46  pwagner
! Concatenate can take array of grids
!
! Revision 2.40  2006/06/13 22:10:19  pwagner
! changed interface to ConvertFromEtaLevelGrids
!
! Revision 2.39  2006/05/12 21:24:13  pwagner
! Added extra debugging statements
!
! Revision 2.38  2006/05/09 00:13:32  pwagner
! Added DoGriddeddataMatch; heightsUnits as component of GriddedData_T
!
! Revision 2.37  2006/05/02 19:00:42  pwagner
! Added ConvertFromEtaLevelGrids; preliminary, untested
!
! Revision 2.36  2006/02/10 21:21:20  pwagner
! Added V_is_eta verticalCoordinate
!
! Revision 2.35  2006/01/19 00:24:17  pwagner
! Small improvements to dump routine
!
! Revision 2.34  2005/06/22 17:25:48  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.33  2004/08/03 17:59:34  pwagner
! Gets DEFAULTUNDEFINEDVALUE from MLSCommon
!
! Revision 2.32  2004/05/19 18:54:44  vsnyder
! Remove declaration for unused variable
!
! Revision 2.31  2003/12/16 01:13:47  livesey
! Changed name in trace call
!
! Revision 2.30  2003/05/19 19:37:41  vsnyder
! Remove USE's for unreferenced names
!
! Revision 2.29  2003/05/09 01:54:58  livesey
! Got SliceGriddedData working
!
! Revision 2.28  2003/05/08 05:27:18  livesey
! Added the slicing
!
! Revision 2.27  2003/04/04 23:01:26  pwagner
! Short-curcuits dump for empty GriddedDatas
!
! Revision 2.26  2003/04/04 19:10:58  livesey
! Bug fix
!
! Revision 2.25  2003/04/04 00:09:32  livesey
! Added empty field, ConcatenateGriddedData, CopyGrid, WrapGriddedData,
! and appropriate changes to SetupNewGriddedData
!
! Revision 2.24  2003/03/01 00:22:30  pwagner
! Dump also prints missing value for that grid
!
! Revision 2.23  2003/02/28 02:26:42  livesey
! Added missingValue field
!
! Revision 2.22  2003/02/27 18:38:13  pwagner
! Removed some intent(out); Lahey takes perverse delight in resetting such to undefined
!
! Revision 2.21  2003/02/21 20:59:53  pwagner
! Tweaked dump settings
!
! Revision 2.20  2003/02/20 21:22:20  pwagner
! Changed default dump details to no for multidim arrays
!
! Revision 2.19  2003/02/19 19:13:28  pwagner
! new GriddedData_T with reduced precision
!
! Revision 2.18  2002/11/22 12:46:26  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.17  2002/10/08 00:09:09  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.16  2002/07/01 23:57:18  livesey
! Added the noYear field
!
! Revision 2.15  2002/06/27 00:09:50  vsnyder
! Don't deallocate qty%field if it's not associated.  Don't say allocate
! failed when the deallocate fails.
!
! Revision 2.14  2002/06/26 22:03:31  vsnyder
! Cosmetic changes
!
! Revision 2.13  2001/10/26 23:17:14  pwagner
! Provides a single dump module interface and details
!
! Revision 2.12  2001/09/10 23:36:56  livesey
! Expanded and tidied up.  Stuff that was in ncep_dao is now here
!
! Revision 2.11  2001/04/10 20:04:54  livesey
! Changed some NameLens to LineLens
!
! Revision 2.10  2001/03/30 00:24:40  pwagner
! Added sourceFileName
!
! Revision 2.9  2001/03/15 21:28:08  pwagner
! Now only the data type
!
! Revision 2.8  2001/03/15 00:37:13  pwagner
! Still not complete; missing gdrdfld
!
! Revision 2.7  2001/03/14 00:32:47  pwagner
! More changes--still wrong, though
!
! Revision 2.6  2001/03/10 00:33:16  pwagner
! Some corrections in ReadGriddedData
!
! Revision 2.5  2001/03/09 01:02:55  pwagner
! Fixed announce_error
!
! Revision 2.4  2001/03/08 01:08:35  pwagner
! Added announce_error
!
! Revision 2.3  2001/03/07 01:03:19  pwagner
! ReadGriddedData added
!
! Revision 2.2  2001/02/21 00:36:43  pwagner
! l3ascii_read_field now has eof as intent(out) arg
!
! Revision 2.1  2001/02/20 21:51:39  pwagner
! Functions absorbed from gridded_data_module
!
! Revision 2.0  2000/09/05 17:41:05  dcuddy
! Change revision to 2.0
!
! Revision 1.5  2000/06/20 22:19:22  lungu
! Changed DOUBBLE PRECISION to REAL (r8).
!
@


2.89
log
@More detailed tracing of memory usage
@
text
@d569 2
a570 1
    call trace_end ( "DestroyGriddedData", cond=toggle(gen) )
d1908 1
a1908 1
       "$Id: GriddedData.f90,v 2.88 2020/04/30 23:20:59 pwagner Exp $"
d1919 3
@


2.88
log
@If Details lt -2 will dump only name and whether empty
@
text
@d33 3
a35 2
  use Output_m, only: OutputOptions, Blanks, Output, NewLine
  use Toggles, only: Switches
d115 3
d127 1
a127 1
    character (LEN=LineLen), pointer, dimension(:) :: fileComments => NULL()
d131 6
a136 6
    character (LEN=LineLen) :: sourceFileName ! Input file name
    character (LEN=NameLen) :: quantityName ! From input file
    character (LEN=LineLen) :: description ! Quantity description
    character (LEN=LineLen) :: dimList
    character (LEN=LineLen) :: fieldNames
    character (LEN=NameLen) :: units ! Units for quantity
d143 1
a143 1
    character (LEN=NameLen) :: heightsUnits ! Units for heights, e.g. 'Pa'
d204 2
a205 1
    call trace_begin ( me, 'ConcatenateGriddedData_2' , cond=.false. )
d286 1
a286 1
    call trace_end ( 'ConcatenateGriddedData_2' , cond=.false. )
d305 2
a306 1
    call trace_begin ( me, 'ConcatenateGriddedData_array' , cond=.false. )
d375 1
a375 1
  9 call trace_end ( 'ConcatenateGriddedData_array' , cond=.false. )
d405 2
a406 1
    call trace_begin ( me, 'ConvertFromEtaLevelGrids' , cond=.false. )
d502 1
a502 1
  9 call trace_end ( 'ConvertFromEtaLevelGrids' , cond=.false. )
a526 1
    use Toggles, only: Toggle, Gen, Levels
a578 1
    use Toggles, only: Toggle, Gen, Levels
d590 1
a590 1
      & cond=toggle(gen) )
d754 6
a759 1
  subroutine DownSampleGriddedData ( grid, newgrid, &
d763 2
a764 2
    type ( GriddedData_T ), intent(inout) :: GRID ! Input grid
    type ( GriddedData_T ), intent(out)   :: NEWGRID ! Result
d831 1
a831 1
    integer, intent(in), optional               :: DETAILS
d844 1
d853 1
a853 2
      call output ( 'item number ' )
      call output ( i, advance='no' )
d855 3
a857 3
        call output('Gridded quantity name ' // &
          & trim(GriddedData(i)%quantityName), advance='yes')
        call OutputNamedValue ( 'empty', GriddedData%empty )
d864 1
d989 6
a994 3
    if ( associated(GriddedData%field)) &
      &  call outputnamedvalue ( 'Grid Memory Footprint', &
      &  byte_size(GriddedData%field) )
d1282 1
a1282 1
    if ( verbose ) then
d1907 1
a1907 1
       "$Id: GriddedData.f90,v 2.87 2020/04/27 21:34:51 pwagner Exp $"
d1918 3
@


2.87
log
@trace_.. added to more carefully track memory usage
@
text
@d826 1
d829 2
d844 7
a850 2

      call DumpGriddedData( GriddedData(i), Details, Options )
d1893 1
a1893 1
       "$Id: GriddedData.f90,v 2.86 2019/10/03 17:31:24 pwagner Exp $"
d1904 3
@


2.86
log
@Convert from eta levels may now take a vGrid field
@
text
@d520 2
d524 1
a524 1
    type (GriddedData_T), intent(INOUT) :: Qty
d531 1
d534 3
d551 4
a554 1
      if ( verbose ) call outputnamedValue ( 'Grid size to be destroyed', shape(qty%field) )
d563 1
d573 1
a573 1
    use Toggles, only: Toggle, Gen
d584 2
a585 1
    call trace_begin ( me, "DestroyGriddedDataDatabase", cond=toggle(gen) )
d601 1
a601 1
  ! --------------------------------------------  DiffGriddedData  -----
d1885 1
a1885 1
       "$Id: GriddedData.f90,v 2.85 2019/09/23 20:38:32 pwagner Exp $"
d1896 3
@


2.85
log
@Conversion from Eta surfaces may optionally be logarithmic
@
text
@d26 2
a27 2
  ! R4 CORRESPONDS TO SING. PREC. :: SAME AS STORED IN FILES
  ! (EXCEPT FOR DAO DIMENSIONS)
d60 1
a60 1
! DestroyGriddedData Deallocate all the pointer components
d62 6
a67 6
!                    Destroy all the elements of the database
! Diff               Print differences between two grids
! DoGriddeddataMatch Same shapes, are on same geolocations, etc.?
! DownsampleGriddeddata Resample grid onto coarser grid derived by step sizes
! Dump               Print details, values of a grid
! NullifyGriddedData Nullify all its pointer components
d69 4
a72 4
!                    What the name says
! SliceGriddedData   Resample grid at supplied coords (Consider renaming it)
! WrapGriddedData    Add extra points in longitude beyond +/-180
!                     and in solar time beyond 0..24 to aid in interpolations
d77 8
a84 8
  public :: GRIDDEDDATA_T, ADDGRIDDEDDATATODATABASE, &
    & CONCATENATEGRIDDEDDATA, CONVERTFROMETALEVELGRIDS, COPYGRID, &
    & DESTROYGRIDDEDDATA, DESTROYGRIDDEDDATADATABASE, &
    & DIFF, DOGRIDDEDDATAMATCH, DOWNSAMPLEGRIDDEDDATA, DUMP, &
    & NULLIFYGRIDDEDDATA, RGR, SETUPNEWGRIDDEDDATA, SLICEGRIDDEDDATA, &
    & WRAPGRIDDEDDATA

  logical, private, parameter :: MAYDUMPFIELDVALUES = .true.
d86 1
a86 1
  interface CONCATENATEGRIDDEDDATA
d91 1
a91 1
  interface DIFF
d95 1
a95 1
  interface DUMP
d102 1
a102 1
  public :: V_IS_PRESSURE, V_IS_ALTITUDE, V_IS_GPH, V_IS_THETA, V_IS_ETA
d374 2
a375 1
  subroutine ConvertFromEtaLevelGrids ( TGrid, PGrid, NGrid, OutGrid, ByLog )
d379 2
a380 1
    use dump_0, only: Dump
d385 1
d392 5
a396 3
    logical, parameter :: DEEBUG = .false.
    logical            :: why
    logical            :: ZetaSurfaces
d402 1
a412 1
    call SetupNewGriddedData ( OutGrid, source=TGrid, noHeights=NGrid%noHeights )
d414 16
a429 1
    OutGrid%verticalCoordinate = NGrid%VerticalCoordinate
a434 8
    if ( size(OutGrid%heights) /= size(NGrid%heights) ) then
      call outputNamedValue('num heights(outGrid)', size(OutGrid%heights), advance='yes' )
      call outputNamedValue('num heights(NGrid)', size(NGrid%heights), advance='yes' )
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Grid shapes do not conform' )
      go to 9
    endif
    OutGrid%heights(1:OutGrid%noHeights) = NGrid%heights(1:OutGrid%noHeights)
d441 2
a442 1
    ! Now we'll interpolate to the NGrid surfaces
d452 1
a452 1
              ! The grid we need NGrid is in 'hPa'
d465 1
a465 1
                & log10(NGrid%heights), OutGrid%field( :, iLat, iLon, iLst, iSza, iDate ), &
d470 1
a470 1
                & NGrid%heights, OutGrid%field( :, iLat, iLon, iLst, iSza, iDate ), &
d482 1
a482 1
      call dump( NGrid%heights, 'heights' )
d486 2
a487 2
      do iHeight = 1, NGrid%noHeights
        call outputNamedValue( 'height', NGrid%heights(iHeight) )
d489 1
a489 1
        & UseLookUpTable ( NGrid%heights(iHeight), TGrid%field( :, 1, 1, 1, 1, 1 ), &
d1874 1
a1874 1
       "$Id: GriddedData.f90,v 2.84 2019/09/05 17:50:13 pwagner Exp $"
d1885 3
@


2.84
log
@SetUp with sources quantityName, dimList, too
@
text
@d374 1
a374 1
  subroutine ConvertFromEtaLevelGrids ( TGrid, PGrid, NGrid, OutGrid )
d383 1
d391 1
d395 2
d449 7
a455 1
              call InterpolateValues( &
d459 1
d1861 1
a1861 1
       "$Id: GriddedData.f90,v 2.83 2017/11/03 20:01:16 pwagner Exp $"
d1872 3
@


2.83
log
@Most array gymnastics moved from MLSFillValues to HyperSlabs module
@
text
@d1193 1
d1195 1
d1850 1
a1850 1
       "$Id: GriddedData.f90,v 2.82 2017/08/23 16:45:25 pwagner Exp $"
d1861 3
@


2.82
log
@Fixed bug when Dates are before 1993
@
text
@d17 1
a190 1
    use MLSFillValues, only: EssentiallyEqual
a287 1
    use MLSFillValues, only: EssentiallyEqual
d378 1
a378 1
    use dump_0, only: DUMP
d539 2
a540 2
    use Toggles, only: TOGGLE, GEN
    use Trace_M, only: TRACE_BEGIN, TRACE_END
d817 4
a820 4
    use Dump_0, only: dump
    use ieee_arithmetic, only: ieee_is_finite, ieee_is_nan
    use Intrinsic, only: lit_indices, spec_indices
    use String_Table, only: display_string
d1310 1
a1310 2
    use MLSFillValues, only: EssentiallyEqual
    use MLSNumerics, only: HUNT
d1848 1
a1848 1
       "$Id: GriddedData.f90,v 2.81 2017/03/17 00:10:49 pwagner Exp $"
d1859 3
@


2.81
log
@Optionally sayWhyNot if not DoGriddeddataMatch
@
text
@d69 1
a69 1
! SliceGriddedData   Resample grid at supplied coords
d190 1
a190 1
    use MLSFILLVALUES, only: ESSENTIALLYEQUAL
d288 1
a288 1
    use MLSFILLVALUES, only: ESSENTIALLYEQUAL
d378 1
a378 1
    use MLSNUMERICS, only: INTERPOLATEVALUES, USELOOKUPTABLE
d569 1
a569 1
    use Diff_1, only: DIFF
d848 1
d962 1
d1074 1
a1074 1
          & call dump ( GriddedData%field(1,:,1,1,1,1), &
d1078 1
a1078 1
          & call dump ( GriddedData%field(1,1,:,1,1,1), &
d1280 3
d1311 1
a1311 1
    use MLSFillValues, only: ESSENTIALLYEQUAL
d1500 1
d1502 5
d1850 1
a1850 1
       "$Id: GriddedData.f90,v 2.80 2016/07/28 01:42:27 vsnyder Exp $"
d1861 3
@


2.80
log
@Refactoring dump and diff
@
text
@d245 2
d390 1
d399 1
d641 1
a641 1
  function DoGriddeddataMatch ( a, b ) result( match )
d648 1
d651 1
d653 2
d656 21
d699 5
d1839 1
a1839 1
       "$Id: GriddedData.f90,v 2.79 2015/03/28 01:01:03 vsnyder Exp $"
d1850 3
@


2.79
log
@Stuff to trace allocate/deallocate addresses -- mostly commented out
because NAG build 1017 doesn't yet allow arrays as arguments to C_LOC.
@
text
@d17 6
a22 5
  use DATES_MODULE, only: TAI2CCSDS
  use DUMP_0, only: DUMP, DUMPDATES
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use INTRINSIC, only: L_GEODALTITUDE, L_GPH, L_ETA, L_PRESSURE, &
    & L_THETA
d24 1
a24 1
  use MLSCOMMON, only: LINELEN, NAMELEN, UNDEFINEDVALUE
d27 8
a34 8
  use MLSKINDS, only: RGR=>R4, R8
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, &
    & MLSMSG_WARNING, MLSMESSAGECONFIG, MLSMESSAGE
  use MLSSTRINGLISTS, only: SNIPLIST, SWITCHDETAIL
  use MLSSTRINGS, only: LOWERCASE, READINTSFROMCHARS
  use OUTPUT_M, only: OUTPUTOPTIONS, BLANKS, OUTPUT, NEWLINE
  use TOGGLES, only: SWITCHES
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
d565 1
a565 1
    use Dump_0, only: DIFF
d1805 1
a1805 1
       "$Id: GriddedData.f90,v 2.78 2015/01/21 19:29:15 pwagner Exp $"
d1816 4
@


2.78
log
@More debugging if PGrid, TGrid dont match
@
text
@d14 3
a16 3
  use allocate_deallocate, only: allocate_test, byte_size, bytes, &
    & deallocate_test, NoBytesAllocated, &
    & test_allocate, test_deallocate
d22 1
d497 1
d518 2
d521 1
a521 1
      call test_deallocate ( status, moduleName, "griddedQty%field", s )
d542 1
d553 2
d556 1
a556 1
      call test_deallocate ( status, ModuleName, "database", s )
d1114 1
d1211 3
d1216 1
a1216 1
      &    qty%noDates /), bytes(qty%field) )
d1653 4
d1658 1
a1658 2
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: LOWERLON
a1659 1
    integer :: LOWERLST
a1660 1
    integer :: STATUS
d1684 1
a1684 1
    endif
d1716 4
d1724 1
a1724 1
      &    grid%noSzas, grid%noDates /), bytes(newField) )
d1751 2
d1754 1
a1754 1
    call test_deallocate ( status, moduleName, 'grid%field', s )
d1804 1
a1804 1
       "$Id: GriddedData.f90,v 2.77 2014/09/04 23:38:45 vsnyder Exp $"
d1815 3
@


2.77
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d391 4
a394 2
    if ( .not. DoGriddeddataMatch( PGrid, TGrid ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d396 1
d1786 1
a1786 1
       "$Id: GriddedData.f90,v 2.76 2014/07/18 22:00:24 pwagner Exp $"
d1797 3
@


2.76
log
@Aimed for consistency in names passed to allocate_test
@
text
@d15 1
a15 1
    & deallocate_test, memory_units, NoBytesAllocated, &
d26 1
a26 1
  use MLSMESSAGEMODULE, only: MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMSG_ERROR, &
d493 1
a493 1
    real :: S ! Size in bytes of a deallocated field
d511 1
a511 1
      s = byte_size(qty%field) / MEMORY_UNITS
d515 1
a515 1
    elseif ( verbose ) then
d526 2
d536 1
a536 1
    integer :: qtyIndex, status
d543 2
a544 1
      enddo
d546 2
a547 3
      if (status /= 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//"database")
    endif
d765 1
a765 2
      total = total + &
        & product(shape(GriddedData(i)%field))/MEMORY_UNITS
d891 2
a892 4
      &  call outputnamedvalue( 'Grid Memory Footprint', &
      &  bytes(GriddedData%field) * &
      & (product(shape(GriddedData%field))/MEMORY_UNITS) &
      & )
d1184 1
a1184 1
        & NoBytesAllocated/MEMORY_UNITS )
d1197 1
a1197 1
    if ( verbose ) call outputNamedValue( 'Bytes before allocating grid%field', NoBytesAllocated/memory_units )
d1204 1
a1204 1
      call outputNamedValue( 'Bytes after allocating grid%field', NoBytesAllocated/memory_units )
d1206 1
a1206 1
      call outputNamedValue( 'Byte Size of field', byte_size(qty%field)/memory_units )
d1639 1
a1639 1
    real :: S ! Size in bytes of a deallocated field
d1731 1
a1731 1
    s = byte_size(grid%field) / MEMORY_UNITS
d1783 1
a1783 1
       "$Id: GriddedData.f90,v 2.75 2014/05/29 18:28:26 pwagner Exp $"
d1794 3
@


2.75
log
@Correctly compute memory usage
@
text
@d499 5
a503 5
    call Deallocate_test ( qty%heights, "qty%heights", ModuleName )
    call Deallocate_test ( qty%lats, "qty%lats", ModuleName )
    call Deallocate_test ( qty%lons, "qty%lons", ModuleName )
    call Deallocate_test ( qty%lsts, "qty%lsts", ModuleName )
    call Deallocate_test ( qty%szas, "qty%szas", ModuleName )
d506 2
a507 2
    call Deallocate_test ( qty%dateStarts, "qty%dateStarts", ModuleName )
    call Deallocate_test ( qty%dateEnds, "qty%dateEnds", ModuleName )
d514 1
a514 1
      call test_deallocate ( status, moduleName, 'grid%field', s )
d1187 5
a1191 5
    call Allocate_test ( qty%heights, qty%noHeights, "qty%heights", ModuleName )
    call Allocate_test ( qty%lats, qty%noLats, "qty%lats", ModuleName )
    call Allocate_test ( qty%lons, qty%noLons, "qty%lons", ModuleName )
    call Allocate_test ( qty%lsts, qty%noLsts, "qty%lsts", ModuleName )
    call Allocate_test ( qty%szas, qty%noSzas, "qty%szas", ModuleName )
d1194 2
a1195 2
    call Allocate_test ( qty%dateStarts, qty%noDates, "qty%dateStarts", ModuleName )
    call Allocate_test ( qty%dateEnds, qty%noDates, "qty%dateEnds", ModuleName )
d1201 1
a1201 1
    call test_allocate ( status, moduleName, 'qty%field', (/1,1,1,1,1,1/), &
d1784 1
a1784 1
       "$Id: GriddedData.f90,v 2.74 2014/01/09 00:25:06 pwagner Exp $"
d1795 3
@


2.74
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d14 3
a16 1
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
d28 1
a28 1
  use MLSSTRINGLISTS, only: SNIPLIST
d31 1
d119 1
d127 2
d200 22
a221 4
    if ( a%verticalCoordinate /= b%verticalCoordinate .or. &
      & a%equivalentLatitude .neqv. b%equivalentLatitude .or. &
      & a%noYear .neqv. b%noYear ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Grids for Concatenate are not compatible' )
d493 1
d495 1
d498 1
d511 2
d514 3
a516 3

      if (status /= 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//"qty%field")
d745 1
d755 1
d759 1
a759 1
      call output ( i, advance='yes' )
d762 3
d766 2
d772 4
a775 4
    use Dump_0, only: DUMP
    use ieee_arithmetic, only: IEEE_IS_FINITE, IEEE_IS_NAN
    use Intrinsic, only: LIT_INDICES, SPEC_INDICES
    use String_Table, only: DISPLAY_STRING
d817 1
a817 2
      call output('This Gridded quantity was empty (perhaps the file name' &
        & // ' was wrong)', advance='yes')
d821 1
d889 5
a1092 1
    use Allocate_Deallocate, only: BYTE_SIZE, TEST_ALLOCATE
d1107 1
d1110 1
d1116 2
d1177 10
d1198 1
d1203 6
a1208 1
      &    qty%noDates /), byte_size(qty%field) )
a1633 2
    use Allocate_Deallocate, only: BYTE_SIZE, BYTES, MEMORY_UNITS, &
      & TEST_ALLOCATE, TEST_DEALLOCATE
d1784 1
a1784 1
       "$Id: GriddedData.f90,v 2.73 2013/08/31 01:24:53 vsnyder Exp $"
d1795 3
@


2.73
log
@Replace MLSMessageCalls with trace_begin and trace_end
@
text
@d17 1
d28 1
a28 1
  use OUTPUT_M, only: OUTPUTOPTIONS, BLANKS, OUTPUT, OUTPUTNAMEDVALUE, NEWLINE
d1726 1
a1726 1
       "$Id: GriddedData.f90,v 2.72 2013/08/30 03:56:01 vsnyder Exp $"
d1737 3
@


2.72
log
@Revise use of trace_begin and trace_end
@
text
@d24 1
a24 1
    & MLSMSG_WARNING, MLSMESSAGECONFIG, MLSMESSAGE, MLSMESSAGECALLS
d28 1
d185 1
d188 2
d191 1
a191 1
    call MLSMessageCalls( 'push', constantName='ConcatenateGriddedData_2' )
d252 1
a252 1
    call MLSMessageCalls( 'pop' )
d269 1
d272 1
a272 1
    call MLSMessageCalls( 'push', constantName='ConcatenateGriddedData_array' )
d341 2
a342 1
  9 call MLSMessageCalls( 'pop' )
d355 1
d358 2
a359 1
    real(rgr), dimension(:), pointer    :: pEta => null()
d361 1
d363 2
a364 1
    nullify( pEta )
a365 1
    call MLSMessageCalls( 'push', constantName='ConvertFromEtaLevelGrids' )
d368 1
a368 1
      & 'Gridded T,P data must match' )
a384 1
    call allocate_test( pEta, TGrid%noHeights, 'pEta', moduleName )
d438 1
a438 2
    call deallocate_test( pEta,   'pEta', moduleName )
  9 call MLSMessageCalls( 'pop' )
d1216 2
a1217 1
    ! First the dimensions of the slice
d1219 1
a1219 1
    ! Now the number of corners
d1261 1
a1261 1
    call MLSMessageCalls( 'push', constantName='SliceGriddedData' )
d1564 2
a1565 1
    call MLSMessageCalls( 'pop' )
d1576 1
d1582 1
d1588 1
d1590 1
a1590 1
    call MLSMessageCalls( 'push', constantName='WrapGriddedData' )
d1683 2
a1684 1
  9 call MLSMessageCalls( 'pop' )
d1725 1
a1725 1
       "$Id: GriddedData.f90,v 2.71 2013/06/12 02:17:27 vsnyder Exp $"
d1736 3
@


2.71
log
@UBYTES and BYTE_SIZE from Allocate_Deallocate
@
text
@d496 1
d499 1
a499 1
    if ( toggle(gen) ) call trace_begin ( "DestroyGriddedDataDatabase" )
d509 2
a510 3
    if ( toggle(gen) ) then
      call trace_end ( "DestroyGriddedDataDatabase" )
    end if
d1712 1
a1712 1
       "$Id: GriddedData.f90,v 2.70 2012/10/11 21:00:28 pwagner Exp $"
d1723 3
@


2.70
log
@Print quantityName instead of moduleName during Dump
@
text
@d14 1
a14 1
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST, E_DEF, E_DP
d1044 1
a1044 1
    use Allocate_Deallocate, only: TEST_ALLOCATE
d1140 1
a1140 1
      &    qty%noDates /), merge(e_dp,e_def,rgr==r8) )
d1564 2
a1565 1
    use Allocate_Deallocate, only: MEMORY_UNITS, TEST_ALLOCATE, TEST_DEALLOCATE
d1635 1
a1635 1
      &    grid%noSzas, grid%noDates /), merge(e_dp,e_def,rgr==r8) )
d1661 1
a1661 1
    s = real(merge(e_dp,e_def,rgr==r8))/memory_units * size(grid%field)
d1663 1
a1663 1
    call test_deallocate ( status, moduleName, 'grid%values', s )
d1712 1
a1712 1
       "$Id: GriddedData.f90,v 2.69 2012/03/06 19:32:39 pwagner Exp $"
d1723 3
@


2.69
log
@Remove more unused local variables
@
text
@d24 1
a24 1
    & MLSMSG_WARNING, MLSMESSAGE, MLSMESSAGECALLS
d69 6
a74 6
  public :: GriddedData_T, AddGriddedDataToDatabase, &
    & ConcatenateGriddedData, ConvertFromEtaLevelGrids, CopyGrid, &
    & DestroyGriddedData, DestroyGriddedDataDatabase, &
    & Diff, DoGriddeddataMatch, DownSampleGriddedData, Dump, &
    & NullifyGriddedData, RGR, SetupNewGriddedData, SliceGriddedData, &
    & WrapGriddedData
d78 1
a78 1
  interface ConcatenateGriddedData
d94 1
a94 1
  public :: V_is_pressure, V_is_altitude, V_is_GPH, V_is_theta, V_is_eta
d758 1
d846 2
d1034 1
a1034 1

d1711 1
a1711 1
       "$Id: GriddedData.f90,v 2.68 2012/03/06 19:12:32 pwagner Exp $"
d1722 3
@


2.68
log
@Say whether dumped grid has seasonal cyclic symmetry
@
text
@a649 6
    integer                   :: iheights
    integer                   :: ilats
    integer                   :: ilons
    integer                   :: ilsts
    integer                   :: iszas
    integer                   :: idates
d1708 1
a1708 1
       "$Id: GriddedData.f90,v 2.67 2012/03/01 20:01:40 pwagner Exp $"
d1719 3
@


2.67
log
@When dumped, say whether grid is for no year
@
text
@d904 1
a904 1
    call output( 'no year in date? ' )
d907 4
d912 2
a913 1
      & call output ( '*** Gridded Data contains non-finite values', advance='yes' )
d1714 1
a1714 1
       "$Id: GriddedData.f90,v 2.66 2011/08/30 22:22:29 pwagner Exp $"
d1725 3
@


2.66
log
@Destroying a Griddeddata now sets empty to TRUE so we can dump it later w/o error
@
text
@d903 3
d1709 1
a1709 1
       "$Id: GriddedData.f90,v 2.65 2011/06/29 21:37:17 pwagner Exp $"
d1720 3
@


2.65
log
@Corrected bug in recalculating downsized dim sizes
@
text
@d481 1
d1706 1
a1706 1
       "$Id: GriddedData.f90,v 2.64 2011/06/16 23:00:09 pwagner Exp $"
d1717 3
@


2.65.2.1
log
@Can Read GEOS5.7.2 meteorology; based on v3.33
@
text
@d16 1
a16 1
  use DUMP_0, only: DUMP
d25 1
a480 1
    qty%empty = .true.
d727 1
a727 1
      call DumpGriddedData( GriddedData(i), Details )
d732 5
a736 5
  subroutine DumpGriddedData ( GriddedData, Details )
    use Dump_0, only: Dump
    use ieee_arithmetic, only: ieee_is_finite, ieee_is_nan
    use Intrinsic, only: Lit_Indices
    use String_Table, only: Display_String
d747 5
a751 1

d753 1
d761 1
d772 4
a775 1
    lookLikeClimatologyTxtfile = ( myDetails > 2 )
d849 7
a855 1
      if ( myDetails < -1 ) return
d899 3
a901 6
    if ( myDetails >= 0 .or. GriddedData%noDates < 6 )&
      &  call dump ( GriddedData%dateStarts, &
      & '    starting dates =', format='(1pg17.9)' )
    if ( myDetails >= 0 .or. GriddedData%noDates < 6 ) &
      & call dump ( GriddedData%dateEnds, &
      & '    ending dates =', format='(1pg17.9)' )
d911 54
a964 1
    if ( MAYDUMPFIELDVALUES .and. fieldvaluesdetails > 0 ) then
d1705 1
a1705 1
       "$Id: GriddedData.f90,v 2.65 2011/06/29 21:37:17 pwagner Exp $"
a1715 3
! Revision 2.65  2011/06/29 21:37:17  pwagner
! Corrected bug in recalculating downsized dim sizes
!
@


2.64
log
@Added DownSampleGriddedData
@
text
@d662 6
a667 6
    noheights = grid%noheights/heightsStep
    nolats    = grid%nolats   /latsStep
    nolons    = grid%nolons   /lonsStep
    nolsts    = grid%nolsts   /lstsStep
    noszas    = grid%noszas   /szasStep
    nodates   = grid%nodates  /datesStep
d1705 1
a1705 1
       "$Id: GriddedData.f90,v 2.63 2011/05/05 15:21:34 pwagner Exp $"
d1716 3
@


2.63
log
@Added fileType field to datatype
@
text
@d14 4
a17 4
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST, E_Def, E_Dp
  use dates_module, only: tai2ccsds
  use Dump_0, only: DUMP, DUMPDATES
  use intrinsic, only: L_GEODALTITUDE, L_GPH, L_ETA, L_PRESSURE, &
d19 9
a27 8
  use MLSCommon, only: RGR=>R4, R8, LINELEN, NAMELEN, undefinedValue
  ! r4 corresponds to sing. prec. :: same as stored in files
  ! (except for dao dimensions)
  use MLSMessageModule, only: MLSMSG_Allocate, MLSMSG_DeAllocate, MLSMSG_Error, &
    & MLSMSG_Warning, MLSMessage, MLSMessageCalls
  use MLSStringLists, only: SNIPLIST
  use MLSStrings, only: LOWERCASE, READINTSFROMCHARS
  use Output_m, only: OUTPUTOPTIONS, BLANKS, OUTPUT, OUTPUTNAMEDVALUE, NEWLINE
d29 1
a29 1
  implicit NONE
d57 1
d72 1
a72 1
    & Diff, DoGriddeddataMatch, Dump, &
d180 1
a180 1
    use MLSFillValues, only: ESSENTIALLYEQUAL
d255 1
a255 1
    use MLSFillValues, only: ESSENTIALLYEQUAL
d343 2
a344 2
    use MLSNumerics, only: InterpolateValues, UseLookUpTable
    use dump_0, only: dump
d514 1
a514 1
    use Dump_0, only: Diff
d621 79
d1038 1
a1038 1
    use Allocate_Deallocate, only: Test_Allocate
d1156 25
d1558 1
a1558 1
    use Allocate_Deallocate, only: Memory_Units, Test_Allocate, Test_DeAllocate
d1705 1
a1705 1
       "$Id: GriddedData.f90,v 2.62 2011/04/27 17:34:25 pwagner Exp $"
d1716 3
@


2.62
log
@dateStarts and -Ends now dumped as dates, not doubles
@
text
@d115 1
d652 4
a655 4
    use Dump_0, only: Dump
    use ieee_arithmetic, only: ieee_is_finite, ieee_is_nan
    use Intrinsic, only: Lit_Indices
    use String_Table, only: Display_String
d768 7
a774 1
      if ( myDetails < -1 ) return
d830 3
d1599 1
a1599 1
       "$Id: GriddedData.f90,v 2.61 2011/04/20 00:25:18 pwagner Exp $"
d1610 3
@


2.61
log
@Dump now responds to options arg
@
text
@d16 1
a16 1
  use Dump_0, only: dump
d693 1
d811 3
a813 6
    if ( myDetails >= 0 .or. GriddedData%noDates < 6 )&
      &  call dump ( GriddedData%dateStarts, &
      & '    starting dates =', format='(1pg17.9)' )
    if ( myDetails >= 0 .or. GriddedData%noDates < 6 ) &
      & call dump ( GriddedData%dateEnds, &
      & '    ending dates =', format='(1pg17.9)' )
d846 3
d1589 1
a1589 1
       "$Id: GriddedData.f90,v 2.60 2010/02/09 16:24:12 pwagner Exp $"
d1600 3
@


2.60
log
@Hide large array section assignments in subroutine to prevent NAG from creating temps
@
text
@d24 1
d140 1
a140 1
    ! Starting dates in SDP toolkit format
d142 1
a142 1
    ! Ending dates in SDP toolkit format
d619 1
a619 1
  subroutine DumpGriddedDatabase ( GriddedData, Details )
d626 2
a627 1
    integer, intent(in), optional :: DETAILS
d645 1
a645 1
      call DumpGriddedData(GriddedData(i), Details)
d650 1
a650 1
  subroutine DumpGriddedData ( GriddedData, Details )
d665 5
a669 1

d671 1
d679 1
d690 3
a692 1
    lookLikeClimatologyTxtfile = ( myDetails > 2 )
d825 48
a872 1
    if ( MAYDUMPFIELDVALUES .and. fieldvaluesdetails > 0 ) then
d1588 1
a1588 1
       "$Id: GriddedData.f90,v 2.59 2010/02/04 23:08:00 vsnyder Exp $"
d1599 3
@


2.59
log
@Remove USE or declaration for unused names
@
text
@a1458 4
    newField ( :, :, &
      & 1+lowerLon : lowerLon+grid%noLons, &
      & 1+lowerLst : lowerLst+grid%noLsts, &
      & :, : ) = grid%field
a1462 1
      newField ( :, :, 1, :, :, : ) = grid%field ( :, :, grid%noLons, :, :, : )
a1465 2
      newField ( :, :, grid%noLons + lowerLon + 1, :, :, : ) = &
        & grid%field ( :, :, 1, :, : ,: )
a1469 1
      newField ( :, :, :, 1, :, : ) = grid%field ( :, :, :, grid%noLsts, :, : )
a1472 2
      newField ( :, :, :, grid%noLsts + lowerLst + 1, :, : ) = &
        & grid%field ( :, :, :, 1, : ,: )
d1475 2
d1494 34
d1531 1
a1531 1
       "$Id: GriddedData.f90,v 2.58 2010/02/03 23:09:23 vsnyder Exp $"
d1542 3
@


2.58
log
@Use Test_Deallocate
@
text
@d510 1
a510 4
    use Dump_0, only: Diff, Dump
    use ieee_arithmetic, only: ieee_is_finite, ieee_is_nan
    use Intrinsic, only: Lit_Indices
    use String_Table, only: Display_String
a517 1
    character(len=8) :: ccsds
a520 3
    integer :: i
    logical :: lookLikeClimatologyTxtfile
    integer :: numElmnts
d1505 1
a1505 1
       "$Id: GriddedData.f90,v 2.57 2009/10/30 23:04:50 pwagner Exp $"
d1516 3
@


2.57
log
@Added diff of gridded data
@
text
@d1391 1
a1391 1
    use Allocate_Deallocate, only: Test_Allocate
d1397 1
d1495 1
d1497 1
a1497 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'grid%values' )
d1512 1
a1512 1
       "$Id: GriddedData.f90,v 2.56 2009/06/23 18:25:42 pwagner Exp $"
d1523 3
@


2.56
log
@Prevent Intel from optimizing ident string away
@
text
@d24 1
a24 1
  use MLSStrings, only: LOWERCASE
d32 1
a32 1
       "$RCSfile: $"
d36 30
d68 2
a69 1
    & DestroyGriddedData, DestroyGriddedDataDatabase, DoGriddeddataMatch, Dump, &
d80 4
d451 1
a451 1
    ! This subroutine destroys a quantity template
d508 80
d893 3
a895 3
  ! This first routine sets up a new quantity template according to the user
  ! input.  This may be based on a previously supplied template (with possible
  ! modifications), or created from scratch.
d1043 1
a1043 1
    ! Now the indcies for each corner
d1511 1
a1511 1
       "$Id: read_apriori.f90 is it here $"
d1522 3
@


2.55
log
@Can dump Gridded data to look like Climatology file
@
text
@d32 1
a32 1
       "$RCSfile: GriddedData.f90,v $"
d1393 1
a1394 1
!---------------------------- RCS Ident Info -------------------------------
d1396 2
a1397 3
       "$Id: GriddedData.f90,v 2.54 2009/01/12 18:45:46 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1399 1
a1399 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1401 1
d1407 3
@


2.54
log
@Added print statement to not_used_here
@
text
@d15 1
d25 1
a25 1
  use Output_m, only: BLANKS, OUTPUT, outputNamedValue
d98 1
a98 1
    integer noLsts                      ! Number of local times
d100 1
a100 1
    integer noSzas                      ! Number of solar zenith angles
d102 1
a102 1
    integer noDates                     ! Number of dates in data
d554 1
d557 1
a557 2
    integer :: MYDETAILS
    integer :: FIELDVALUESDETAILS
d560 5
d571 1
a571 1
      myDetails = 1
d574 1
d580 67
d1396 1
a1396 1
       "$Id: GriddedData.f90,v 2.53 2008/09/16 21:05:10 pwagner Exp $"
d1407 3
@


2.53
log
@Improved dumps
@
text
@d1322 1
a1322 1
       "$Id: GriddedData.f90,v 2.52 2008/06/06 22:52:21 pwagner Exp $"
d1326 1
d1333 3
@


2.52
log
@EssentiallyEqual moved to MLSFillValues
@
text
@d385 1
a385 1
        & xtable=pEta, missingValue=TGrid%missingValue, options='i' )
d620 1
a620 1
      & '    starting dates =' )
d623 1
a623 1
      & '    ending dates =' )
d635 26
d662 1
a662 1
      if ( GriddedData%noDates == 1 .and. GriddedData%noSzas == 1 &
d1322 1
a1322 1
       "$Id: GriddedData.f90,v 2.51 2008/01/07 21:36:33 pwagner Exp $"
d1332 3
@


2.51
log
@Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
@
text
@d140 1
a140 1
    use MLSNumerics, only: EssentiallyEqual
d215 1
a215 1
    use MLSNumerics, only: EssentiallyEqual
d802 2
a803 1
    use MLSNumerics, only: HUNT, ESSENTIALLYEQUAL
d1296 1
a1296 1
       "$Id: GriddedData.f90,v 2.50 2007/10/04 01:49:14 vsnyder Exp $"
d1306 3
@


2.50
log
@Don't overflow the call stack
@
text
@d18 1
a18 1
  use MLSCommon, only: RGR=>R4, R8, LINELEN, NAMELEN, DEFAULTUNDEFINEDVALUE
d692 1
a692 1
    real(rgr), parameter :: DefaultMissingValue = DEFAULTUNDEFINEDVALUE ! -999.99
d742 1
a742 1
        qty%missingValue = defaultMissingValue
d1295 1
a1295 1
       "$Id: GriddedData.f90,v 2.49 2007/08/17 00:27:23 pwagner Exp $"
d1305 3
@


2.49
log
@push more procedures onto MLSCallStack
@
text
@d229 1
a229 1
    if ( size(indices) < 1 .or. size(database) < 1 ) return
d231 1
a231 1
    if ( index1 < 1 .or. index1 > size(Database) ) return
d234 1
a234 1
      return
d296 1
a296 1
    call MLSMessageCalls( 'pop' )
d327 1
a327 1
      return
d334 1
a334 1
      return
d391 1
a391 1
    call MLSMessageCalls( 'pop' )
d1189 1
a1189 1
    if ( grid%noLons <= 1 .and. grid%noLsts <= 1 ) return
d1228 1
a1228 1
    if ( all ( (/ lowerLon, upperLon, lowerLst, upperLst /) == 0 ) ) return
d1288 1
a1288 1
    call MLSMessageCalls( 'pop' )
d1295 1
a1295 1
       "$Id: GriddedData.f90,v 2.48 2007/08/13 17:35:24 pwagner Exp $"
d1305 3
@


2.48
log
@Push SliceGriddedData onto new MLSSCallStack
@
text
@d147 1
d208 1
d227 1
d296 1
d316 1
d391 1
d698 1
d1187 1
d1288 1
d1295 1
a1295 1
       "$Id: GriddedData.f90,v 2.47 2007/07/27 00:23:57 vsnyder Exp $"
d1305 3
@


2.47
log
@Use Test_Allocate after allocations
@
text
@d21 2
a22 2
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ALLOCATE, MLSMSG_ERROR, &
    & MLSMSG_DEALLOCATE, MLSMSG_Warning
d857 1
d1160 1
d1282 1
d1286 1
a1286 1
       "$Id: GriddedData.f90,v 2.46 2007/06/07 20:26:16 pwagner Exp $"
d1296 3
@


2.46
log
@Prevents some crashes, writing non-ascii chars to stdout
@
text
@d14 1
a14 1
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
d675 1
d688 1
a688 1
    integer :: status           ! Status from allocates etc.
d768 3
a770 2
    if ( status /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'qty%field')
d1166 1
d1230 5
a1234 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'newField' )
d1283 1
a1283 1
       "$Id: GriddedData.f90,v 2.45 2007/03/23 00:10:49 pwagner Exp $"
d1293 3
@


2.45
log
@Valiant attempts to bring two Lahey version results closer
@
text
@d477 2
d480 1
d691 4
d1277 1
a1277 1
       "$Id: GriddedData.f90,v 2.44 2007/01/30 21:57:44 pwagner Exp $"
d1287 3
@


2.44
log
@Avoids a bug with empty grids in ConvertFromEtaLevelGrids
@
text
@d15 1
d299 1
a299 1
    use MLSNumerics, only: InterpolateValues
d306 1
a306 1
    integer :: iDate, iSza, iLst, iLon, iLat
a314 1
    call allocate_test( pEta, TGrid%noHeights, 'pEta', moduleName )
d319 5
d331 2
a332 1
    OutGrid%heights = NGrid%heights
d369 1
d374 9
d799 1
d809 1
a809 1
    real(rgr) :: MYMISSINGVALUE
d820 6
a825 6
    real(rgr), dimension(size(heights),2) :: HEIGHTW
    real(rgr), dimension(size(lats),2)    :: LATW
    real(rgr), dimension(size(lons),2)    :: LONW
    real(rgr), dimension(size(lsts),2)    :: LSTW
    real(rgr), dimension(size(szas),2)    :: SZAW
    real(rgr), dimension(size(dates),2)   :: DATEW
d844 2
a845 1
    real(rgr) :: VAL
d871 2
a872 2
      heightW(:,1) = 1.0_rgr
      heightW(:,2) = 0.0_rgr
d899 2
a900 2
      latW(:,1) = 1.0_rgr
      latW(:,2) = 0.0_rgr
d916 2
a917 2
      lonW(:,1) = 1.0_rgr
      lonW(:,2) = 0.0_rgr
d933 2
a934 2
      lstW(:,1) = 1.0_rgr
      lstW(:,2) = 0.0_rgr
d950 2
a951 2
      szaW(:,1) = 1.0_rgr
      szaW(:,2) = 0.0_rgr
d976 2
a977 2
      dateW(:,1) = 1.0_rgr
      dateW(:,2) = 0.0_rgr
d985 1
a985 1
      dateW(:,2) = 1.0_rgr - dateW(:,1)
d1037 30
a1066 1

d1077 1
d1079 1
a1079 1
                  slice(height,lat,lon,lst,sza,date) = 0.0
d1084 3
a1086 2
                    if ( EssentiallyEqual ( val, grid%missingValue ) ) then
                      slice(height,lat,lon,lst,sza,date) = myMissingValue
d1089 3
a1091 2
                    slice(height,lat,lon,lst,sza,date) = &
                      & slice(height,lat,lon,lst,sza,date) + val * &
d1096 1
d1109 1
d1111 1
a1111 1
                  slice(height,lat,lon,lst,sza,date) = 0.0
d1116 3
a1118 2
                    slice(height,lat,lon,lst,sza,date) = &
                      & slice(height,lat,lon,lst,sza,date) + val * &
d1121 6
d1129 4
d1147 3
d1270 1
a1270 1
       "$Id: GriddedData.f90,v 2.43 2007/01/11 20:31:53 vsnyder Exp $"
d1280 3
@


2.43
log
@Spiff up the dump
@
text
@d21 1
a21 1
    & MLSMSG_DEALLOCATE
d23 1
a23 1
  use Output_m, only: BLANKS, OUTPUT
d319 7
d1204 1
a1204 1
       "$Id: GriddedData.f90,v 2.42 2006/11/01 20:27:05 pwagner Exp $"
d1214 3
@


2.42
log
@Hasty fix to units bug in eta-level conversion
@
text
@d510 2
d543 3
a545 3
    call output('description ' // GriddedData%description, advance='yes')
    call output('units ' // trim(GriddedData%units), advance='yes')
    call output('missing value ', advance='no')
d551 6
a556 2
    call output ( GriddedData%verticalCoordinate, advance='yes' )
    call output('heights units ' // trim(GriddedData%heightsUnits), advance='yes')
d1197 1
a1197 1
       "$Id: GriddedData.f90,v 2.41 2006/06/14 23:58:46 pwagner Exp $"
d1207 3
@


2.41
log
@Concatenate can take array of grids
@
text
@d299 1
d307 1
d332 14
a345 1
              pEta = PGrid%field( :, iLat, iLon, iLst, iSza, iDate )
d355 7
d1191 1
a1191 1
       "$Id: GriddedData.f90,v 2.40 2006/06/13 22:10:19 pwagner Exp $"
d1201 3
@


2.40
log
@changed interface to ConvertFromEtaLevelGrids
@
text
@d15 1
a15 1
  use intrinsic, only: L_ANGLE, L_GEODALTITUDE, L_GPH, L_ETA, L_PRESSURE, &
d42 5
d63 1
a63 1
  character(len=*), parameter :: ALWAYSDUMPTHESE = 'dao,ncep,geos5' ! -> ' '
d136 1
a136 1
  subroutine ConcatenateGriddedData ( A, B, X )
d171 8
a178 2
    if ( maxval ( a%dateEnds ) > minval ( b%dateStarts ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d180 1
d206 87
a292 1
  end subroutine ConcatenateGriddedData
d558 2
a559 1
    if ( myDetails >= 0 ) call dump ( GriddedData%dateStarts, &
d561 2
a562 1
    if ( myDetails >= 0 ) call dump ( GriddedData%dateEnds, &
d1169 1
a1169 1
       "$Id: GriddedData.f90,v 2.39 2006/05/12 21:24:13 pwagner Exp $"
d1179 3
@


2.39
log
@Added extra debugging statements
@
text
@d58 1
a58 1
  character(len=*), parameter :: ALWAYSDUMPTHESE = 'dao,ncep' ! -> ' '
d197 1
a197 1
  subroutine ConvertFromEtaLevelGrids ( TGrid, PGrid, VGrid, OutGrid )
a200 1
    use VGridsDatabase, only: VGrid_T, ConvertVGrid
d203 1
a203 1
    type ( VGrid_T ), intent(in)        :: VGrid  ! What surfaces to use
a207 1
    real(rgr), dimension(:), pointer    :: pVGrid => null()
d209 1
a209 1
    nullify( pEta, pVGrid )
a213 1
    nullify( pEta, pVGrid )
a214 1
    call allocate_test( pVGrid, VGrid%noSurfs, 'pVGrid', moduleName )
d216 1
a216 1
    call SetupNewGriddedData ( OutGrid, source=TGrid, noHeights=VGrid%NoSurfs )
d218 2
a219 2
    OutGrid%verticalCoordinate = VGrid%VerticalCoordinate
    OutGrid%heights = VGrid%surfs(:,1)
d226 1
a226 2
    ! Now we'll interpolate to the VGrid surfaces
    ! pVGrid = vGrid%Surfs
a232 1
              call convertVGrid( VGrid, l_pressure, pVGrid )
d235 1
a235 1
                & pVGrid, OutGrid%field( :, iLat, iLon, iLst, iSza, iDate ), &
a242 1
    call deallocate_test( pVGrid, 'pVGrid', moduleName )
d389 1
d465 8
d1069 1
a1069 1
       "$Id: GriddedData.f90,v 2.38 2006/05/09 00:13:32 pwagner Exp $"
d1079 3
@


2.38
log
@Added DoGriddeddataMatch; heightsUnits as component of GriddedData_T
@
text
@d23 1
a23 1
  use Output_m, only: OUTPUT
d139 1
a139 1

d173 10
d1067 1
a1067 1
       "$Id: GriddedData.f90,v 2.37 2006/05/02 19:00:42 pwagner Exp $"
d1077 3
@


2.37
log
@Added ConvertFromEtaLevelGrids; preliminary, untested
@
text
@d22 1
d34 1
a34 1
  public :: AddGriddedDataToDatabase, &
d36 1
a36 1
    & DestroyGriddedData, DestroyGriddedDataDatabase, Dump, GriddedData_T, &
d82 1
d202 5
d320 33
d418 1
a418 1
    call output('units ' // GriddedData%units, advance='yes')
d426 1
d504 2
a505 2
    & NoLons, NoLsts, NoSzas, NoDates, missingValue, &
    & Empty )
d513 3
d553 2
d565 3
d578 3
d1057 1
a1057 1
       "$Id: GriddedData.f90,v 2.36 2006/02/10 21:21:20 pwagner Exp $"
d1067 3
@


2.36
log
@Added V_is_eta verticalCoordinate
@
text
@d14 3
a22 1
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
d33 2
a34 1
  public :: AddGriddedDataToDatabase, ConcatenateGriddedData, CopyGrid, &
d50 5
a54 5
  integer, parameter :: V_is_pressure = 1
  integer, parameter :: V_is_altitude = v_is_pressure+1
  integer, parameter :: V_is_GPH      = v_is_altitude+1
  integer, parameter :: V_is_theta    = v_is_gph+1
  integer, parameter :: V_is_eta      = V_is_theta+1
d184 51
d1005 1
a1005 1
       "$Id: GriddedData.f90,v 2.35 2006/01/19 00:24:17 pwagner Exp $"
d1015 3
@


2.35
log
@Small improvements to dump routine
@
text
@d45 1
a45 1
  public :: V_is_pressure, V_is_altitude, V_is_GPH, V_is_theta
d49 3
a51 2
  integer, parameter :: V_is_GPH = v_is_altitude+1
  integer, parameter :: V_is_theta = v_is_gph+1
d74 1
a74 1
    integer :: verticalCoordinate ! An 'enumerated' type
d951 1
a951 1
       "$Id: GriddedData.f90,v 2.34 2005/06/22 17:25:48 pwagner Exp $"
d961 3
@


2.34
log
@Reworded Copyright statement, moved rcs id
@
text
@d27 1
a27 1
       "$RCSfile: $"
d304 2
d371 2
a372 1
          & '    gridded field values =' )
d374 1
d376 2
a377 1
          & '    gridded field values (1st solar time) =' )
d379 2
a380 1
          & '    gridded field values (1st longitude) =' )
d384 11
a394 1
          & '    gridded field values (1st height) =' )
d950 1
a950 1
       "$Id: $"
d960 3
@


2.33
log
@Gets DEFAULTUNDEFINEDVALUE from MLSCommon
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d25 3
a27 5
  !------------------------------- RCS Ident Info ------------------------------
  character(LEN=*), parameter :: IdParm = & 
    "$Id: GriddedData.f90,v 2.32 2004/05/19 18:54:44 vsnyder Exp $"
  character(len=len(idParm)), private :: Id = idParm
  character(LEN=*), parameter :: ModuleName="$RCSfile: GriddedData.f90,v $"
d29 1
a29 1
  !-----------------------------------------------------------------------------
d932 5
d944 3
@


2.32
log
@Remove declaration for unused variable
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d6 1
a6 1
  use MLSCommon, only: RGR=>R4, R8, LINELEN, NAMELEN
d19 1
a19 1
    "$Id: GriddedData.f90,v 2.31 2003/12/16 01:13:47 livesey Exp $"
d398 1
a398 1
    real(rgr), parameter :: DefaultMissingValue = -999.99
d933 3
@


2.31
log
@Changed name in trace call
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.30 2003/05/19 19:37:41 vsnyder Exp $"
d540 1
a540 1
    integer :: I, C
d933 3
@


2.30
log
@Remove USE's for unreferenced names
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.29 2003/05/09 01:54:58 livesey Exp $"
d237 1
a237 1
    if ( toggle(gen) ) call trace_begin ( "DestroyGridTemplateDatabase" )
d248 1
a248 1
      call trace_end ( "DestroyGridTemplateDatabase" )
d933 3
@


2.29
log
@Got SliceGriddedData working
@
text
@d6 3
a8 1
  use MLSCommon, only: R4, R8, LINELEN, NAMELEN, RP
a10 1
  use Toggles, only: TOGGLE, GEN
a12 1
  use Trace_M, only: TRACE_BEGIN, TRACE_END
d19 1
a19 1
    "$Id: GriddedData.f90,v 2.28 2003/05/08 05:27:18 livesey Exp $"
d26 3
a28 2
    & Dump, DestroyGriddedData, DestroyGriddedDataDatabase, GriddedData_T, &
    & SetupNewGriddedData, NullifyGriddedData, WrapGriddedData, SliceGriddedData
a36 4
  ! r4 corresponds to sing. prec. :: same as stored in files
  ! (except for dao dimensions)
  integer, public, parameter :: rgr = r4

d228 3
d254 1
a254 1
    use Dump_0, only: Dump
d933 3
@


2.28
log
@Added the slicing
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.27 2003/04/04 23:01:26 pwagner Exp $"
d27 1
a27 1
    & SetupNewGriddedData, NullifyGriddedData, WrapGriddedData
d497 1
a497 1
    real(rgr), dimension(:), intent(out) :: SLICE ! Result
d563 3
a565 2

    if ( noHeights*noLats*noLons*noLsts*noSzas*noDates /= size(slice) ) &
d598 1
a598 1
      heightFac = 1
d615 1
a616 1
      latFac = noCorners
d632 1
a633 1
      lonFac = noCorners
d649 1
a650 1
      lstFac = noCorners
d666 1
a667 1
      szaFac = noCorners
d692 1
a693 1
      dateFac = noCorners
d709 1
a709 1
        heightC(c) = merge ( 1, 2, mod(c/heightFac,2) == 0 )
d715 1
a715 1
        latC(c) = merge ( 1, 2, mod(c/latFac,2) == 0 )
d721 1
a721 1
        lonC(c) = merge ( 1, 2, mod(c/lonFac,2) == 0 )
d727 1
a727 1
        lstC(c) = merge ( 1, 2, mod(c/lstFac,2) == 0 )
d733 1
a733 1
        szaC(c) = merge ( 1, 2, mod(c/szaFac,2) == 0 )
d739 1
a739 1
        dateC(c) = merge ( 1, 2, mod(c/dateFac,2) == 0 )
d743 1
d745 55
a799 44
    height = 1
    lat = 1
    lon = 1
    lst = 1
    sza = 1
    date = 1
    do i = 1, size(slice) 
      slice(i) = 0.0
      cornerLoop: do c = 1, noCorners
        val = grid%field ( &
          & heightI(height,heightC(c)), latI(lat,latC(c)), lonI(lon,lonC(c)), &
          & lstI(lst,lstC(c)), szaI(sza,szaC(c)), dateI(date,dateC(c)) )
        if ( EssentiallyEqual ( val, grid%missingValue ) ) then
          slice(i) = myMissingValue
          exit cornerLoop
        end if
        slice(i) = slice(i) + val * &
          & heightW(height,heightC(c)) * latW(lat,latC(c)) * lonW(lon,lonC(c)) * &
          & lstW(lst,lstC(c)) * szaW(sza,szaC(c)) * dateW(date,dateC(c))
      end do cornerLoop

      ! This is really hokey, but it should save too many ifs in loops
      height = height + 1
      if ( height > noHeights ) then
        height = 1
        lat = lat + 1
        if ( lat > noLats ) then
          lat = 1
          lon = lon + 1
          if ( lon > noLons ) then
            lon = 1
            lst = lst + 1
            if ( lst > noLsts ) then
              lst = 1
              sza = sza + 1
              if ( sza > noSzas ) then
                sza = 1
                date = date + 1
              end if
            end if
          end if
        end if
      end if

a800 2
    end do
 
d933 3
@


2.27
log
@Short-curcuits dump for empty GriddedDatas
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.26 2003/04/04 19:10:58 livesey Exp $"
a196 1

d490 309
d922 3
@


2.26
log
@Bug fix
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.25 2003/04/04 00:09:32 livesey Exp $"
d308 5
d614 3
@


2.25
log
@Added empty field, ConcatenateGriddedData, CopyGrid, WrapGriddedData,
and appropriate changes to SetupNewGriddedData
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.24 2003/03/01 00:22:30 pwagner Exp $"
d488 2
a489 4
    ! Given a grid add an extra longitude which helps when interpolating
    ! over the +/- 180 degree region
    ! One could do the same for local time, but I can't get too excited about
    ! that I'm afraid.
d494 1
d496 4
a499 2
    integer :: LOWER
    integer :: UPPER
d502 2
a503 2
    ! Don't bother with 'zonal mean' type quantities
    if ( grid%noLons <= 1 ) return
d505 33
a537 11
    ! Check that this field is as we expect
    lower = count ( grid%lons < -180.0 )
    upper = count ( grid%lons > 180.0 )
    if ( lower > 0 .or. upper > 0 ) then
      ! This is either unconventional or it's already been wrapped
      ! in either case, we're not going to do anything.
      if ( lower > 1 .or. upper > 1 ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Gridded data disobeys EOS convention of -180..180 longitude' )
      endif
      return
d540 3
a542 5
    ! Do we need one or two more points
    lower = 0
    upper = 0
    if ( grid%lons(1) > -180.0 ) lower = 1
    if ( grid%lons(grid%noLons) < 180.0 ) upper = 1
d545 2
a546 2
    nullify ( newLons, newField )
    call Allocate_test ( newLons, grid%noLons + lower + upper, &
d548 2
d551 3
a553 2
      & grid%noLons + lower + upper, &
      & grid%noLsts, grid%noSzas, grid%noDates ), STAT=status )
d557 10
a566 4
    ! Fill them
    newLons ( 1+lower : lower+grid%noLons ) = grid%lons
    newField ( :, :, 1+lower : lower+grid%noLons, :, :, : ) = grid%field
    if ( lower == 1 ) then
d570 14
a583 4
    if ( upper == 1 ) then
      newLons ( grid%noLons + lower + 1 ) = grid%lons ( 1 ) + 360.0
      newField ( :, :, grid%noLons + lower + 1, :, :, : ) = &
        & grid%field ( :, :, 1, : , : ,: )
d588 1
d594 2
a595 1
    grid%noLons = grid%noLons + lower + upper
d597 1
d609 4
@


2.24
log
@Dump also prints missing value for that grid
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.23 2003/02/28 02:26:42 livesey Exp $"
d25 3
a27 3
  public :: AddGriddedDataToDatabase, Dump, DestroyGriddedData, &
    & DestroyGriddedDataDatabase, GriddedData_T, SetupNewGriddedData, &
    & NullifyGriddedData
d60 1
d121 75
d382 2
a383 1
    & NoLons, NoLsts, NoSzas, NoDates, missingValue )
d391 1
d397 1
d401 48
a448 26
    ! First, if we have a template setup according to that
    if (present(source)) then
      qty%noHeights=source%noHeights
      qty%noLats=source%noLats
      qty%noLons=source%noLons
      qty%noLsts=source%noLsts
      qty%noSzas=source%noSzas
      qty%noDates=source%noDates
    else ! We have no template, setup a very bare quantity
      qty%noHeights=1
      qty%noLats=1
      qty%noLons=1
      qty%noLsts=1
      qty%noSzas=1
      qty%noDates=1
    endif

    ! Now, see if the user asked for modifications to this
    if (present(noHeights)) qty%noHeights=noHeights
    if (present(noLats)) qty%noLats=noLats
    if (present(noLons)) qty%noLons=noLons
    if (present(noLsts)) qty%noLsts=noLsts
    if (present(noSzas)) qty%noSzas=noSzas
    if (present(noDates)) qty%noDates=noDates
    qty%missingValue = defaultMissingValue
    if ( present ( missingValue ) ) qty%missingValue = missingValue
d486 72
d566 3
@


2.23
log
@Added missingValue field
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.22 2003/02/27 18:38:13 pwagner Exp $"
d236 2
d393 3
@


2.22
log
@Removed some intent(out); Lahey takes perverse delight in resetting such to undefined
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.21 2003/02/21 20:59:53 pwagner Exp $"
d94 1
d304 1
a304 1
    & NoLons, NoLsts, NoSzas, NoDates )
d312 3
a314 1

d344 2
d391 3
@


2.21
log
@Tweaked dump settings
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.20 2003/02/20 21:22:20 pwagner Exp $"
d52 1
a52 1
  integer, parameter :: AUTOMATICDETAILS = 1 ! 1 menas dump, 0 menas no
d308 1
a308 1
    type (GriddedData_T), intent(OUT) :: QTY ! Result
d364 1
a364 1
    type ( GriddedData_T ), intent(out) :: G
d386 3
@


2.20
log
@Changed default dump details to no for multidim arrays
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.19 2003/02/19 19:13:28 pwagner Exp $"
d49 1
a49 1
  ! If dumping gridded data, always give full details of any matching these
d51 2
d227 4
a230 3
    if ( index(ALWAYSDUMPTHESE, trim(GriddedData%description)) > 0 ) &
      & myDetails = 1

d281 9
d386 3
@


2.19
log
@new GriddedData_T with reduced precision
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.18 2002/11/22 12:46:26 mjf Exp $"
d49 2
a50 2
  ! If dumping gridded dataa, always give full details of any matching these
  character(len=*), parameter :: ALWAYSDUMPTHESE = 'dao,ncep'
d215 1
a215 1
    !                                        ! Default 1
d219 1
d222 1
a222 1
    myDetails = 1
d224 1
d271 1
a271 1
    if ( MAYDUMPFIELDVALUES .and. myDetails > 0 ) then
d374 3
@


2.18
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d6 1
a6 1
  use MLSCommon, only: R8, LINELEN, NAMELEN, RP
d19 1
a19 1
    "$Id: GriddedData.f90,v 2.17 2002/10/08 00:09:09 pwagner Exp $"
d29 1
a29 1
  logical, private, parameter :: MAYDUMPFIELDVALUES = .false.
d36 4
d48 3
d69 1
a69 1
    real (rp), pointer, dimension(:) :: heights  => NULL()
d76 1
a76 1
    real (rp), pointer, dimension(:) :: Lats => NULL() ! Latitudes [noLats]
d78 1
a78 1
    real (rp), pointer, dimension(:) :: Lons => NULL() ! Longitudes [noLons]
d80 1
a80 1
    real (rp), pointer, dimension(:) :: Lsts => NULL() ! Local times [noLsts]
d82 1
a82 1
    real (rp), pointer, dimension(:) :: Szas => NULL() ! Zenith angles [noSzas]
d84 1
a84 1
    real (rp), pointer, dimension(:) :: DateStarts => NULL()
d86 1
a86 1
    real (rp), pointer, dimension(:) :: DateEnds => NULL()
d91 1
a91 1
    real (rp), pointer, dimension(:,:,:,:,:,:) :: field => NULL()
d223 2
d271 12
a282 5

      ! No dump for 6-dimensional double arrays yet, anyway
      !     call dump ( GriddedData%field, &
      !      & '    gridded field values =' )
      call output ( ' *(Sorry, dump_6d_double not yet coded)* ' ,advance='yes')
d372 4
@


2.17
log
@Added idents to survive zealous Lahey optimizer
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.16 2002/07/01 23:57:18 livesey Exp $"
d26 2
a27 1
    & DestroyGriddedDataDatabase, GriddedData_T, SetupNewGriddedData
d331 17
d356 3
@


2.16
log
@Added the noYear field
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.15 2002/06/27 00:09:50 vsnyder Exp $"
d22 1
d330 4
d338 3
@


2.15
log
@Don't deallocate qty%field if it's not associated.  Don't say allocate
failed when the deallocate fails.
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.14 2002/06/26 22:03:31 vsnyder Exp $"
d65 1
d333 4
@


2.14
log
@Cosmetic changes
@
text
@d19 1
a19 1
    "$Id: GriddedData.f90,v 2.13 2001/10/26 23:17:14 pwagner Exp $"
d130 2
a131 1
    deallocate(qty%field, STAT=status)
d133 3
a135 2
    if (status /= 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//"field")
d332 3
@


2.13
log
@Provides a single dump module interface and details
@
text
@d14 2
a15 2
  implicit none
  public
a16 1
  private :: Id,ModuleName
d18 3
a20 2
  character(LEN=130) :: id = & 
    "$Id: GriddedData.f90,v 2.12 2001/09/10 23:36:56 livesey Exp $"
d24 2
a25 2
  public::GriddedData_T, SetupNewGriddedData, DestroyGriddedData, &
    & AddGriddedDataToDatabase, DestroyGriddedDataDatabase, Dump
d27 1
a27 1
    logical, private, parameter :: MAYDUMPFIELDVALUES = .false.
d36 1
a36 1
  public::v_is_pressure,v_is_altitude,v_is_gph,v_is_theta
d38 4
a41 4
  integer, parameter :: v_is_pressure = 1
  integer, parameter :: v_is_altitude = v_is_pressure+1
  integer, parameter :: v_is_gph = v_is_altitude+1
  integer, parameter :: v_is_theta = v_is_gph+1
d66 1
a66 1
    real (rp), pointer, dimension(:) :: lats => NULL() ! Latitudes [noLats]
d68 1
a68 1
    real (rp), pointer, dimension(:) :: lons => NULL() ! Longitudes [noLons]
d70 1
a70 1
    real (rp), pointer, dimension(:) :: lsts => NULL() ! Local times [noLsts]
d72 1
a72 1
    real (rp), pointer, dimension(:) :: szas => NULL() ! Zenith angles [noSzas]
d74 1
a74 1
    real (rp), pointer, dimension(:) :: dateStarts => NULL()
d76 1
a76 1
    real (rp), pointer, dimension(:) :: dateEnds => NULL()
d85 1
a85 1
! ============================================================================
d88 2
a89 2
  ! ---------------------------------------------------AddGridTemplateToDatabase --
  integer function AddGriddedDataToDatabase(database,item)
d94 2
a95 2
    type (GriddedData_T), dimension(:), pointer :: database
    type (GriddedData_T), intent(in) :: item
d107 1
a107 1
  ! ------------------------------------------------ DestroyGriddedData ------
d109 1
a109 1
  subroutine DestroyGriddedData(qty)
d113 1
a113 1
    type (GriddedData_T), intent(INOUT) :: qty
d137 2
a138 2
  ! ------------------------------------------- DestroyGridTemplateDatabase --
  subroutine DestroyGriddedDataDatabase(database)
d142 1
a142 1
    type (GriddedData_T), dimension(:), pointer :: database
d162 2
a163 2
  ! --------------------------------  DumpGriddedDatabase  -----
  subroutine DumpGriddedDatabase(GriddedData, Details)
d192 2
a193 2
  ! --------------------------------  DumpGriddedData  -----
  subroutine DumpGriddedData(GriddedData, Details)
d266 3
a268 3
  ! ------------------------------------------- SetupNewGriddedData ---------
  subroutine SetupNewGriddedData(qty, source, noHeights, noLats, &
    & noLons, noLsts, noSzas, noDates)
d330 3
@


2.12
log
@Expanded and tidied up.  Stuff that was in ncep_dao is now here
@
text
@d20 1
a20 1
    "$Id: GriddedData.f90,v 2.11 2001/04/10 20:04:54 livesey Exp $"
d25 8
a32 1
    & AddGriddedDataToDatabase, DestroyGriddedDataDatabase
d163 1
a163 1
  subroutine DumpGriddedDatabase(GriddedData, root)
d170 2
a171 2
    integer, intent(in) :: ROOT        ! Root of the L2CF abstract syntax tree

a172 1
    logical, parameter :: MAYDUMPFIELDVALUES = .false.
d178 2
d182 1
d188 1
a188 1
      call DumpGriddedData(GriddedData(i), root)
d193 1
a193 1
  subroutine DumpGriddedData(GriddedData, root)
d199 5
a203 1
    integer, intent(in) :: ROOT        ! Root of the L2CF abstract syntax tree
d206 1
a206 1
    logical, parameter :: MAYDUMPFIELDVALUES = .false.
d208 6
a213 1
    call output('quantity name ' // GriddedData%quantityName, advance='yes')
d223 1
a223 1
    call dump ( GriddedData%heights, &
d230 1
a230 1
    call dump ( GriddedData%lats, &
d235 1
a235 1
    call dump ( GriddedData%lons, &
d240 1
a240 1
    call dump ( GriddedData%lsts, &
d245 1
a245 1
    call dump ( GriddedData%szas, &
d250 1
a250 1
    call dump ( GriddedData%dateStarts, &
d252 1
a252 1
    call dump ( GriddedData%dateEnds, &
d255 1
a255 1
    if(MAYDUMPFIELDVALUES) then
d261 1
d330 3
@


2.11
log
@Changed some NameLens to LineLens
@
text
@a0 2


d4 1
a4 3
!=============================================================================
MODULE GriddedData ! Contains the derived TYPE GriddedData_T
!=============================================================================
d6 7
a12 1
  USE MLSCommon, only: R8, LineLen, NameLen
d14 2
a15 2
  IMPLICIT NONE
  PUBLIC
d17 1
a17 1
  PRIVATE :: Id,ModuleName
d19 3
a21 3
  CHARACTER(LEN=130) :: id = & 
       "$Id: GriddedData.f90,v 2.10 2001/03/30 00:24:40 pwagner Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: GriddedData.f90,v $"
d24 2
a25 1
  public::GriddedData_T
d27 2
d30 278
a307 64
	! These are 'enumerated types' consistent with hph's
	! work in l3ascii_read_field
	
	integer, parameter :: v_is_pressure = 1
	integer, parameter :: v_is_altitude = v_is_pressure+1
	integer, parameter :: v_is_gph = v_is_altitude+1
	integer, parameter :: v_is_theta = v_is_gph+1
	
!
! This type reflects the format of the Level 3 ASCII files, though note that
! these files can store multiple quantities such as these.
!
TYPE GriddedData_T
   !
   ! First the comment line(s) from the relevant input file
   !
   CHARACTER (LEN=LineLen), POINTER, DIMENSION(:) :: fileComments => NULL()
   !
   ! Now the name, description and units information
   !
   CHARACTER (LEN=LineLen) :: sourceFileName ! Input file name
   CHARACTER (LEN=NameLen) :: quantityName ! From input file
   CHARACTER (LEN=LineLen) :: description ! Quantity description
   CHARACTER (LEN=NameLen) :: units ! Units for quantity
   !
   ! Now define the various coordinate systems, first vertical
   !
   INTEGER :: verticalCoordinate ! An 'enumerated' type
   INTEGER :: noHeights         ! Number of surfaces
   REAL (R8), POINTER, DIMENSION(:) :: heights  => NULL()
             ! Surfaces (e.g. pressures etc.) [noHeights]
   !
   ! Now the latitudinal coordinate
   !
   LOGICAL :: equivalentLatitude ! If set, coordinate is equivalent latitude
   INTEGER :: noLats            ! Number of latitudes
   REAL (R8), POINTER, DIMENSION(:) :: lats => NULL() ! Latitudes [noLats]
   !
   INTEGER :: noLons            ! Number of longitudes
   REAL (R8), POINTER, DIMENSION(:) :: lons => NULL() ! Longitudes [noLons]
   !
   INTEGER noLsts               ! Number of local times
   REAL (R8), POINTER, DIMENSION(:) :: lsts => NULL() ! Local times [noLsts]
   !
   INTEGER noSzas               ! Number of solar zenith angles
   REAL (R8), POINTER, DIMENSION(:) :: szas => NULL() ! Zenith angles [noSzas]
   !
   INTEGER noDates              ! Number of dates in data
   REAL (R8), POINTER, DIMENSION(:) :: dateStarts => NULL()
      ! Starting dates in SDP toolkit format
   REAL (R8), POINTER, DIMENSION(:) :: dateEnds => NULL()
      ! Ending dates in SDP toolkit format
   !
   REAL (R8), POINTER, DIMENSION(:,:,:,:,:,:) :: field => NULL()
   !
   ! The data itself.  This is stored as
   !  [noHeights, noLats, noLons, noLsts, noSzas, noDates]
   !
END TYPE GriddedData_T


!=============================================================================
END MODULE GriddedData
!=============================================================================
d311 3
@


2.10
log
@Added sourceFileName
@
text
@d18 1
a18 1
       "$Id: GriddedData.f90,v 2.9 2001/03/15 21:28:08 pwagner Exp $"
d45 1
a45 1
   CHARACTER (LEN=NameLen) :: sourceFileName ! Input file name
d92 3
@


2.9
log
@Now only the data type
@
text
@d18 1
a18 1
       "$Id: GriddedData.f90,v 2.8 2001/03/15 00:37:13 pwagner Exp $"
d45 1
d92 32
@


2.8
log
@Still not complete; missing gdrdfld
@
text
@d7 1
a7 1
MODULE GriddedData ! Collections of subroutines to handle TYPE GriddedData_T
a9 6

  use HDFEOS, only: HDFE_NENTDIM, HDFE_NENTDFLD, &
  & gdopen, gdattach, gddetach, gdclose, gdfldinfo, &
  & gdinqgrid, gdnentries, gdinqdims, gdinqflds, gddiminfo
  use Hdf, only: SUCCEED, DFACC_RDONLY
  use LEXER_CORE, only: PRINT_SOURCE
a10 9
  USE MLSFiles, only: GetPCFromRef
  USE MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Allocate, &
  & MLSMSG_Deallocate, MLSMSG_Warning
  USE MLSStrings, only: GetStringElement, NumStringElements, Capitalize, &
  & Count_words, ReadCompleteLineWithoutComments, GetIntHashElement
  use OUTPUT_M, only: OUTPUT
  USE SDPToolkit, only: PGS_S_SUCCESS, PGS_PC_GETREFERENCE, &
  & PGS_IO_GEN_OPENF, PGSD_IO_GEN_RSEQFRM
  use TREE, only: DUMP_TREE_NODE, SOURCE_REF
d18 1
a18 1
       "$Id: GriddedData.f90,v 2.7 2001/03/14 00:32:47 pwagner Exp $"
d22 1
a22 1
 
a23 12
  public::GriddedData_T
  public::SetupNewGridTemplate, DestroyGridTemplateContents, &
	&   AddGridTemplateToDatabase, DestroyGridTemplateDatabase
  public::OBTAIN_CLIM, READ_CLIMATOLOGY, OBTAIN_DAO, Obtain_NCEP
  public::l3ascii_open,l3ascii_read_field,l3ascii_interp_field,make_log_axis
  public::l3ascii_get_multiplier
  !private::get_next_noncomment_line, 
  private :: make_linear_axis
  private::read_explicit_axis,ilocate
  public::ReadGriddedData
  private::announce_error
  integer, private :: ERROR
a32 12

  ! First we'll define some global parameters and data types.

   CHARACTER (len=*), PARAMETER :: DEFAULTFIELDNAME = 'TMPU'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD1 = 'Latitude'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD2 = 'Longitude'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD3 = 'Height'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD4 = 'Time'

! This datatype stores a single gridded atmospheric quantity.  For example
! temperature, if an uncertainty field is also required, this is stored in a
! separate quantity.
a84 1461


  ! --------------------------------------------------------------------------

  CONTAINS

  ! Now we have some subroutines to deal with these quantitites

  ! This first routine sets up a new quantity template according to the user
  ! input.  This may be based on a previously supplied template (with possible
  ! modifications), or created from scratch.

  SUBROUTINE SetupNewGridTemplate(qty, source, noHeights, noLats, noLons, noLsts, noSzas, noDates)

    ! Dummy arguments
    TYPE (GriddedData_T), INTENT(OUT) :: qty ! Result

    TYPE (GriddedData_T), OPTIONAL, INTENT(IN) :: source ! Template

    INTEGER, OPTIONAL, INTENT(IN) :: noHeights, noLats, noLons, noLsts, noSzas, noDates

    ! Local variables
    INTEGER :: status           ! Status from allocates etc.

    ! Executable code

    ! First, if we have a template setup according to that
    IF (PRESENT(source)) THEN
       qty%noHeights=source%noHeights
       qty%noLats=source%noLats
       qty%noLons=source%noLons
       qty%noLsts=source%noLsts
       qty%noSzas=source%noSzas
       qty%noDates=source%noDates

      
    ELSE ! We have no template, setup a very bare quantity
       qty%noHeights=1
       qty%noLats=1
       qty%noLons=1
       qty%noLsts=1
       qty%noSzas=1
       qty%noDates=1

    ENDIF

    ! Now, see if the user asked for modifications to this
    IF (PRESENT(noHeights)) qty%noHeights=noHeights
    IF (PRESENT(noLats)) qty%noLats=noLats
    IF (PRESENT(noLons)) qty%noLons=noLons
    IF (PRESENT(noLsts)) qty%noLsts=noLsts
    IF (PRESENT(noSzas)) qty%noSzas=noSzas
    IF (PRESENT(noDates)) qty%noDates=noDates
    ! First the vertical coordinates

    ALLOCATE (qty%heights(qty%noHeights),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"heights")

    ! Now the geolocation coordinates
    ALLOCATE (qty%lats(qty%noLats),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"lats")

    ALLOCATE (qty%lons(qty%noLons),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"lons")

    ALLOCATE (qty%lsts(qty%noLsts),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"lsts")

    ALLOCATE (qty%szas(qty%noSzas),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"szas")

    !Now the temporal coordinates
    ALLOCATE (qty%DateStarts(qty%noDates),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"DateStarts")

    ALLOCATE (qty%DateEnds(qty%noDates),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"DateEnds")

    !Now the data itself
    ALLOCATE(qty%field(qty%noHeights, qty%noLats, qty%noLons,  &
             qty%noLsts, qty%noSzas, qty%noDates), STAT=status)

    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"field")


  END SUBROUTINE SetupNewGridTemplate

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a quantity template

  SUBROUTINE DestroyGridTemplateContents(qty)

    ! Dummy argument
    TYPE (GriddedData_T), INTENT(INOUT) :: qty
    ! Local variables
    INTEGER status

    ! Executable code

    DEALLOCATE (qty%heights, STAT=status)

    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"heights")

    DEALLOCATE (qty%lats, STAT=status)

    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"lats")

    DEALLOCATE (qty%lons, STAT=status)

    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"lons")

    DEALLOCATE (qty%lsts, STAT=status)

    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"lsts")

    DEALLOCATE (qty%szas, STAT=status)

    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"szas")

    DEALLOCATE (qty%DateStarts, STAT=status)

    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"DateStarts")

    DEALLOCATE (qty%DateEnds, STAT=status)

    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"DateEnds")

    DEALLOCATE (qty%field, STAT=status)

    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"field")    


  END SUBROUTINE DestroyGridTemplateContents

  ! --------------------------------------------------------------------------

  ! This subroutine adds a quantity template to a database, or creates the
  ! database if it doesn't yet exist

!  SUBROUTINE AddGridTemplateToDatabase(database,qty)
  INTEGER FUNCTION AddGridTemplateToDatabase(database,item)

    ! Dummy arguments
    TYPE (GriddedData_T), DIMENSION(:), POINTER :: database
    TYPE (GriddedData_T), INTENT(IN) :: item
!    TYPE (GriddedData_T), INTENT(IN) :: qty

    ! Local variables
    TYPE (GriddedData_T), DIMENSION(:), POINTER :: tempDatabase
!    INTEGER :: newSize,status

    ! Executable code

!    IF (ASSOCIATED(database)) THEN
       ! Check we don't already have one of this name
!       IF (LinearSearchStringArray(database%quantityName, qty%quantityName, &
!            & caseInsensitive=.TRUE.)/=0) CALL MLSMessage(MLSMSG_Error,&
!            & ModuleName,MLSMSG_Duplicate//qty%quantityName)
!       newSize=SIZE(database)+1
!    ELSE
!       newSize=1
!    ENDIF
!    ALLOCATE(tempDatabase(newSize),STAT=status)
!    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
!         & "Allocation failed for tempDatabase")

!    IF (newSize>1) tempDatabase(1:newSize-1)=database
!    tempDatabase(newSize)=qty
!    IF (ASSOCIATED(database)) THEN
!       DEALLOCATE(database, STAT=status)
!       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
!         & MLSMSG_DeAllocate//"database")
!    end if
!    database=>tempDatabase

    include "addItemToDatabase.f9h"
    AddGridTemplateToDatabase = newSize

  END FUNCTION AddGridTemplateToDatabase

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a quantity template database

  SUBROUTINE DestroyGridTemplateDatabase(database)

    ! Dummy argument
    TYPE (GriddedData_T), DIMENSION(:), POINTER :: database

    ! Local variables
    INTEGER :: qtyIndex, status

    IF (ASSOCIATED(database)) THEN
       DO qtyIndex=1,SIZE(database)
          CALL DestroyGridTemplateContents(database(qtyIndex))
       ENDDO
       DEALLOCATE(database, stat=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"database")
    ENDIF
  END SUBROUTINE DestroyGridTemplateDatabase


!----------------- Beginning of Hugh's code ------------------

  subroutine l3ascii_open(filename,unit)
    ! opens a l3ascii file, reads, prints and discards the annoying
    ! header line and returns the unit it chose. No special close routine.
    ! just do close(unit=unit)
    !--------- argument ----------!
    character(len=*),intent(in)::filename
    integer,intent(out)::unit
    !-------locals------!
    logical:: tiedup, found
    integer:: j
    !character(len=LineLen)::headerline
    !----executables----!
    !----- Find first unattached unit -----!
    found = .false.
    do j = 1, 30
      inquire ( unit=j, opened=tiedup )
      if (.not. tiedup) then
        found = .true.
        unit = j
        open ( unit=unit, file=filename, status="old", action="read" )
        exit
      end if
    end do
    if ( .not. found ) then
      unit = -1
      call MLSMessage ( MLSMSG_Error, ModuleName,&
           "in subroutine l3ascii_open: No units left" )
    end if

    !First line is not prefaced with ; nor is it of any use. 
    ! we read it to move the file position past it
    !read(unit=unit,fmt="(a)")headerline
    !    print*,headerline
  end subroutine l3ascii_open

  subroutine l3ascii_read_field(unit, field, end_of_file)
    use dates_module    ! Shoud use SDP Toolkit eventually. 
    ! ----Arguments ----!
    integer, intent(in) :: unit
    type(GriddedData_T), intent(inout) :: field
    logical , intent(out) :: end_of_file
    !-------Local Variables --------!
    character(len=*),parameter :: dummyyear="1993"
    logical :: opened
    character(len=LineLen) :: inline
    character(len=30) :: linetype, axistype, sdstring, edstring
    character(len=80) :: filename, unitstring
    real(kind=r8), pointer, dimension(:) :: tmpaxis, dateStarts, dateEnds
    integer :: tmpaxis_len, idate, word_count
    integer,parameter :: maxNoDates = 30
    real(kind=r8), allocatable, dimension(:,:,:,:,:,:) :: tmpfield
    !---- Executable statements ----! 
    nullify(tmpaxis)
	 end_of_file = .TRUE.	! Terminate loops based around this on error

    write(unit=unitstring,fmt="(i3)") unit ! For use in error reporting
    inquire(unit=unit,opened=opened)
    if (.not. opened) then
        call MLSMessage(MLSMSG_Error,ModuleName,&
       " in subroutine l3ascii_read_field, Unit "//trim(unitstring)//&
       "is not connected to a file. Do call l3ascii_open(filename,unit) first")
       return
    endif
    inquire(unit=unit,name=filename) ! find the file name connected to this
    ! unit for use in error messages.

    ! Fix axis arrays: set to default values with length 1 and a sensible 
    ! value. These will be used if the file does not have variation 
    ! along that axis

    ! Unfortunately, we can't tell if this defined type has
    ! been used before by testing a pointer for being associated as for 
    ! a new  struct they are in the undefined state. (This will change with 
    ! Fortran 95, where you can define a pointer to be initialised to the 
    ! nullified state)
    ! We therefore use a special number field%reusing to test whether 
    ! this defined type has been used before.  
!    if (field%reusing==313323435) then
    if (associated(field%field)) then
       !       print*,"This struct has been used before : deallocating"
       deallocate(field%heights)
       deallocate(field%lats)
       deallocate(field%lons)
       deallocate(field%lsts)
       deallocate(field%szas)
       deallocate(field%dateStarts)
       deallocate(field%dateEnds)
       deallocate(field%field)
!    else
       !       print*,"This is a new struct"
!       field%reusing=313323435
    endif
    allocate(field%heights(1:1))
    field%heights(1)=1000.0
    field%noHeights=1
    field%verticalCoordinate=1
    allocate(field%lats(1:1))
    field%lats(1)=0.0
    field%noLats=1
    field%equivalentLatitude=.false.
    allocate(field%lons(1:1))
    field%lons(1)=0.0
    field%noLons=1
    allocate(field%lsts(1:1))
    field%lsts(1)=12.0
    field%noLsts=1
    allocate(field%szas(1:1))
    field%szas(1)=30.0
    field%noSzas=1
    ! Dates are mandatory, so we don't have to give them a default value

    !--- Read field info and all the axis info ---!
!    call get_next_noncomment_line(unit,inline)
    end_of_file=.false.
    call ReadCompleteLineWithoutComments(unit,inline,eof=end_of_file)
!    print*,"Read line"
!    print*,inline
   if(Capitalize(inline(1:5)) /= "FIELD" ) then
      call MLSMessage(MLSMSG_Error,ModuleName,&
           "in subroutine l3ascii_read_field, File "//trim(filename)// &
           "on unit"//trim(unitstring)//" contains no more Fields")
       return
    endif
    
    if(end_of_file) then
       call MLSMessage(MLSMSG_Error,ModuleName,&
       "In subroutine l3ascii_read_field, End of File"//trim(filename)// &
       " on unit"//trim(unitstring))
       return
    endif

    read(unit=inline,fmt=*)linetype,field%quantityName, &
         field%description,field%units
    axesloop:do

        call ReadCompleteLineWithoutComments(unit,inline)
        !print*,inline
        read(unit=inline,fmt=*)linetype,axistype
        linetype=Capitalize(linetype)
        axistype=Capitalize(axistype)
        if(linetype(1:4) == "DATE") then ! This is always the last "axis"
           exit axesloop                 ! and is different from the others
        endif
        if (axistype(1:6) =="LINEAR") then
!           print*,"Doing linear axis"
           call make_linear_axis(inline,tmpaxis,tmpaxis_len)
!           print*,"Done linear axis"
        else if (axistype(1:3) =="LOG") then
           !print*,"Doing log axis"
           call make_log_axis(inline,tmpaxis,tmpaxis_len)
           !print*,"Done log axis"
        else if (axistype(1:8) =="EXPLICIT") then
!           print*,"Doing explicit axis"
           backspace(unit=unit)
           call read_explicit_axis(unit,tmpaxis,tmpaxis_len)
!           print*,"Done explicit axis"
        else
           call MLSMessage(MLSMSG_Error,ModuleName,&
                "in subroutine l3ascii_read_field,File"//trim(filename)//&
                " on unit"//trim(unitstring)//" contains coordinate"//&
                " of invalid type "//trim(axistype)//"for axis"//&
                trim(linetype))
           return
        endif

        ! I do not entirely grok what NJL intended verticalCoordinate to be. 
        if(linetype(1:8) == "PRESSURE" .or. linetype(1:8) == "ALTITUDE" &
             .or. linetype(1:3) == "GPH" .or. linetype(1:5) == "THETA") then
           field%noHeights=tmpaxis_len
           deallocate(field%heights)
           allocate(field%heights(1:tmpaxis_len))
           field%heights=tmpaxis

           if(linetype(1:8) == "PRESSURE") then
              field%verticalCoordinate=1
           else if (linetype(1:8) == "ALTITUDE") then
              field%verticalCoordinate=2
           else if (linetype(1:3) == "GPH") then
              field%verticalCoordinate=3
           else if (linetype(1:5) == "THETA") then
              field%verticalCoordinate=4
           endif
        else if(linetype(1:8) == "LATITUDE" .or. &
             linetype(1:8) == "EQUIVLAT") then
           field%noLats=tmpaxis_len
           deallocate(field%lats)
           allocate(field%lats(1:tmpaxis_len))
           field%lats=tmpaxis
           if (linetype(1:8) == "LATITUDE") then
              field%equivalentLatitude=.false.
           else 
              field%equivalentLatitude=.true.
           endif
        else if(linetype(1:9) == "LONGITUDE") then
           field%noLons=tmpaxis_len
           deallocate(field%lons)
           allocate(field%lons(1:tmpaxis_len))
           field%lons=tmpaxis
        else if(linetype(1:9) == "LST") then
           field%noLsts=tmpaxis_len
           deallocate(field%lsts)
           allocate(field%lsts(1:tmpaxis_len))
           field%lsts=tmpaxis
        else if(linetype(1:9) == "SZA") then
           field%noSzas=tmpaxis_len
           deallocate(field%szas)
           allocate(field%szas(1:tmpaxis_len))
           field%szas=tmpaxis
        endif
    enddo axesloop
    deallocate(tmpaxis)

    ! We already have the first date line read and the axis type extracted
    ! It was the existence of a date line that caused us to exit from 
    ! the loop axesloop. We don't know how many dates there are so we have to 
    ! allocate large arrays and copy their contents to an array of the 
    ! right size 
    field%noDates=1
    allocate(tmpfield(1:field%noHeights,1:field%noLats,1:field%noLons, &
         1:field%noLsts,1:field%noSzas,1:maxNoDates))
    allocate(dateStarts(1:maxNoDates),dateEnds(1:maxNoDates))

    ! Loop to read in the data for the current date and check to see if 
    ! there is another date
    datesloop: do idate=1,maxNoDates
       !print*,"Datesloop: idate=",idate
       word_count=count_words(inline)
       if (word_count == 3) then
          read(unit=inline,fmt=*)linetype,axistype,sdstring
          sdstring=adjustl(sdstring)
          edstring=sdstring
       else if(word_count >= 4 ) then
          read(unit=inline,fmt=*)linetype,axistype,sdstring,edstring
          sdstring=adjustl(sdstring)
          edstring=adjustl(edstring)
       else
          call MLSMessage(MLSMSG_Error,ModuleName,&
               "in subroutine l3ascii_read_field: File"//trim(filename)//&
               "on unit"//trim(unitstring)//" contains a line beginning"//&
               trim(linetype)//"Date with too few words ")
       endif
       
        ! Date strings can begin with - indicating the year is 
        ! missing and that the file belongs to no year in particular.
        ! To convert dates to SDP toolkit (TAI) times (Seconds since start of 
        ! 1 Jan 1993) we need to stick on a dummy year
        if (sdstring(1:1) == "-") then
           sdstring=dummyyear//sdstring
        endif
        if (edstring(1:1) == "-") then
           edstring=dummyyear//edstring
        endif
        ! ccsds2tai returns days since 1 Jan 1993. 86400==no of secs per day
        dateStarts(idate)=86400*ccsds2tai(sdstring)
        dateEnds(idate)  =86400*ccsds2tai(edstring)
        call ReadCompleteLineWithoutComments(unit,inline)
        backspace(unit=unit)
        !print*,"About to read data: inline=",inline
        !print*,"tmpfield has size:",size(tmpfield),shape(tmpfield)
        
        read(unit=unit,fmt=*)tmpfield(:,:,:,:,:,idate)
        !print*,"Read data"
        end_of_file=.false.
        call ReadCompleteLineWithoutComments(unit,inline,eof=end_of_file)
        !print*,"Next date line:",inline,"EOF=",end_of_file
        if(end_of_file) then 
           ! No more dates and nothing else either
           exit datesloop
        endif
        read(unit=inline,fmt=*)linetype,axistype        
        linetype=Capitalize(linetype)
        axistype=Capitalize(axistype)
        if(end_of_file .or. &
             linetype(1:5) == "FIELD" .or. linetype(1:3)=="END") then 
           !Oops! There were no more dates, but there is another field
           backspace(unit=unit)
           exit datesloop                 
        endif
        if(linetype(1:4) /= "DATE") then ! There should be another date here
           call MLSMessage(MLSMSG_Error,ModuleName,&
                "in subroutine l3ascii_read_field: File"//trim(filename)//&
                "on unit"//trim(unitstring)//" contains a line beginning"//&
                trim(linetype)//"where I expected a line beginning Date ")
           return
        endif
        field%noDates=field%noDates+1

    enddo datesloop

    allocate(field%field(1:field%noHeights,1:field%noLats,&
         1:field%noLons,1:field%noLsts,1:field%noSzas,1:field%noDates))
    allocate(field%dateStarts(1:field%noDates),&
         field%dateEnds(1:field%noDates))
    field%dateStarts=dateStarts(1:field%noDates)
    field%dateEnds=dateEnds(1:field%noDates)
    field%field=tmpfield(:,:,:,:,:,1:field%noDates)
    deallocate(tmpfield,dateStarts,dateEnds)

  end subroutine l3ascii_read_field

  subroutine l3ascii_interp_field(field,outval,pressure,lat,lon,lst,sza,date)
    ! Returns a value in outval containing the value of the 
    ! gridded data set "field" at the pressure, lat, etc specified by 
    ! the other args. Co-ordinates are 
    ! all optional and suitably dull defaults are chosen if no 
    ! arg is supplied. The date is supplied in tai format i.e. seconds since
    ! Midnite, 1 Jan 1993. 
    ! At the moment the height coord has to be pressure.
    !--------------Arguments------------!
    type(GriddedData_T),intent(in)::field
    real(kind=r8),intent(in),optional::pressure
    real(kind=r8),intent(in),optional::lat,lon,lst,sza,date
    real(kind=r8),intent(out)::outval
    !---- local vars: optional arg values ------!
    real(kind=r8):: inlat,inlon,inlst,insza,indate,inpressure,inalt
    !---- local vars: others--------!
    integer:: ilat1,ilat2,ilon1,ilon2,isza1,isza2,ilst1,ilst2,idate1,idate2
    integer:: ialt1,ialt2,i0,i1,i2,i3,i4
    integer,dimension(1:6)::hcshape 
    real(kind=r8),pointer,dimension(:)::tmpalt,tmpdate
    real(kind=r8),allocatable,dimension(:,:,:,:,:,:)::hcube

    !----Executable code ---- !

    ! --- Set default values for all optional parameters
    if(present(lat)) then
       inlat=lat
    else
       inlat=30.0
    endif

    if(present(pressure)) then
       inpressure=pressure
    else
       inpressure=10.0
    endif

    if(present(lon)) then
       inlon=lon
    else
       inlon=0.0
    endif

    if(present(sza)) then
       insza=sza
    else
       insza=30.0
    endif

    if(present(lst)) then
       inlst=lst
    else
       inlst=12.0
    endif

    if(present(date)) then
       indate=date
    else
       indate=15768000.0 ! This should be June (ish)
    endif

    ! OK, that's the optional arguments sorted. 
    ! Now, we have to find which two indices the chosen value lies between
    ! for each of the six values.
    call ilocate(field%lats,inlat,ilat1,ilat2)
    call ilocate(field%lons,inlon,ilon1,ilon2)
    call ilocate(field%szas,insza,isza1,isza2)
    call ilocate(field%lsts,inlst,ilst1,ilst2)
    ! We can't interpolate dates and prssures as they are. We construct
    ! a mean date and a log pressure
    allocate(tmpdate(1:field%noDates),tmpalt(1:field%noHeights))
    tmpdate=(field%dateStarts+field%dateEnds)/2.0
    tmpalt=-log10(field%heights)
    inalt=-log10(inpressure)
    call ilocate(tmpdate,indate,idate1,idate2)
    call ilocate(tmpalt,inalt,ialt1,ialt2)
    ! We now know that the desired point is inside the 6-D hypercuboid 
    ! bin of the array field%field(ialt1:ialt2, ilat1:ilat2, .......)
    ! Time to do the actual interpolation. Yuck. 
    ! There are up to 2^6=64 values
    ! to be taken into account. 

    ! Lets try allocating a cube of the right shape.
    if (ialt1==ialt2) then !test whether the altitude is between two of the 
       hcshape(1)=1        ! grid values (so we interpolate) or if there
    else                   ! is only one value (so we just return that value)
       hcshape(1)=2
    endif
    if (ilat1==ilat2) then
       hcshape(2)=1
    else
       hcshape(2)=2
    endif
    if (ilon1==ilon2) then
       hcshape(3)=1
    else
       hcshape(3)=2
    endif
    if (ilst1==ilst2) then
       hcshape(4)=1
    else
       hcshape(4)=2
    endif
    if (isza1==isza2) then
       hcshape(5)=1
    else
       hcshape(5)=2
    endif
    if (idate1==idate2) then
       hcshape(6)=1
    else
       hcshape(6)=2
    endif


    ! Allocate a 6-D hypercube that our point lies in. Some of the 
    ! dimensions may be "collapsed" 
    allocate(hcube(1:hcshape(1),1:hcshape(2),1:hcshape(3), &
         1:hcshape(4),1:hcshape(5),1:hcshape(6)))
    ! Copy data into hypercube
    hcube=field%field(ialt1:ialt2, ilat1:ilat2, ilon1:ilon2, &
         ilst1:ilst2,isza1:isza2, idate1:idate2)

    ! Now we interpolate along eahc of the axes where this is needed
    ! Reduce 6-d to 5-d
    if (hcshape(6) == 2 )then !Interpolate in date 
       do i0=1,hcshape(1)
          do i1=1,hcshape(2)
             do i2=1,hcshape(3)
                do i3=1,hcshape(4)
                   do i4=1,hcshape(5)
                      hcube(i0,i1,i2,i3,i4,1)=hcube(i0,i1,i2,i3,i4,1)+ &
                           (hcube(i0,i1,i2,i3,i4,2)- &
                           hcube(i0,i1,i2,i3,i4,1))* &
                           (indate-tmpdate(idate1))/ &
                           (tmpdate(idate2)-tmpdate(idate1))
                   enddo
                enddo
             enddo
          enddo
       enddo
    endif
    ! Reduce  5-d to 4d
    if (hcshape(5) == 2 )then !Interpolate in local Solar zenith ang  SZA
       do i0=1,hcshape(1)
          do i1=1,hcshape(2)
             do i2=1,hcshape(3)
                do i3=1,hcshape(4)
                   hcube(i0,i1,i2,i3,1,1)=hcube(i0,i1,i2,i3,1,1)+ &
                        (hcube(i0,i1,i2,i3,2,1)- &
                        hcube(i0,i1,i2,i3,1,1))* &
                        (insza-field%szas(isza1))/ &
                        (field%szas(isza2)-field%szas(isza1))
                enddo
             enddo
          enddo
       enddo
    endif
    ! Reduce  4-d to 3d
    if (hcshape(4) == 2 )then !Interpolate in local solar time
       do i0=1,hcshape(1)
          do i1=1,hcshape(2)
             do i2=1,hcshape(3)
                hcube(i0,i1,i2,1,1,1)=hcube(i0,i1,i2,1,1,1)+ &
                     (hcube(i0,i1,i2,2,1,1)- &
                     hcube(i0,i1,i2,1,1,1))* &
                     (inlst-field%lsts(ilst1))/ &
                     (field%lsts(ilst2)-field%lsts(ilst1))
             enddo
          enddo
       enddo
    endif
    ! Reduce  3-d to 2d
    if (hcshape(3) == 2 )then !Interpolate in longitude
       do i0=1,hcshape(1)
          do i1=1,hcshape(2)
             hcube(i0,i1,1,1,1,1)=hcube(i0,i1,1,1,1,1)+ &
                  (hcube(i0,i1,2,1,1,1)- &
                  hcube(i0,i1,1,1,1,1))* &
                  (inlon-field%lons(ilon1))/ &
                  (field%lons(ilon2)-field%lons(ilon1))
          enddo
       enddo
    endif
    ! Reduce  2-d to 1d
    if (hcshape(2) == 2 )then !Interpolate in latitude
       do i0=1,hcshape(1)
          hcube(i0,1,1,1,1,1)=hcube(i0,1,1,1,1,1)+ &
               (hcube(i0,2,1,1,1,1)- &
               hcube(i0,1,1,1,1,1))* &
               (inlat-field%lats(ilat1))/ &
               (field%lats(ilat2)-field%lats(ilat1))
       enddo
    endif

    ! Reduce  1-d to 0d
    if (hcshape(1) == 2 )then !interpolate in altitude
       hcube(1,1,1,1,1,1)=hcube(1,1,1,1,1,1)+ &
            (hcube(2,1,1,1,1,1)- &
            hcube(1,1,1,1,1,1))* &
            (inalt-tmpalt(ialt1))/ &
            (tmpalt(ialt2)-tmpalt(ialt1))
    endif
    outval=hcube(1,1,1,1,1,1)
    deallocate(tmpdate,tmpalt,hcube)
  end subroutine l3ascii_interp_field

  subroutine ilocate(x,xval,ix1,ix2)
    ! This finds which two elements of x lie on either side of xval
    ! x is assumed to be 1-based. 
    !     *** arguments *** 
    real(kind=r8),pointer,dimension(:):: x
    real(kind=r8),intent(in)::xval
    integer, intent(out)::ix1,ix2
    !     *** other variables ***                                           
    integer ::j,dj,n 
    !     *** executable statements ***                                     
    n=size(x)
    if (n <=1) then ! x has only one element: no interpolating to be done
       ix1=1
       ix2=1
    else
       if (xval > x(n)) then ! off top . Use end value
          ix1=n
          ix2=n
       else if (xval < x(1)) then ! of bottom. Use end value
          ix1=1
          ix2=1
       else ! in range of x. Do binary search.
          j=n/2 
          dj = n/2 
          binsearch: do  
             if (dj > 1) then 
                dj=dj/2 
             else 
                dj=1 
             end if
             if(x(j) > xval .and. x(j+1) > xval) then 
                j=j-dj 
                cycle
             else  if (x(j) < xval .and. x(j+1) < xval) then 
                j=j+dj 
                cycle 
             else 
                exit
             endif
          enddo binsearch
          ix1=j
          ix2=j+1
       end if
    endif
  end subroutine ilocate

!  subroutine get_next_noncomment_line(unit,line)
!    !---Arguments----!
!    integer,intent(in)::unit
!    character(len=*),intent(out)::line
!    !---------Local vars------!
!    integer:: ioinfo
!    !---Executable bit -----!
!    line(1:1)=" "
!    ioinfo=0
!    rdloop:do
!       read(unit=unit,fmt="(a)",iostat=ioinfo)line      !read a line
!       if (ioinfo /= 0) then
!          line="End of File Found"
!          exit rdloop
!       else
!          line=adjustl(line)                 ! remove blanks from start
!          if(line(1:1) /= ";" .and. line(1:1) /= " ") then !not a comment
!             exit rdloop                     ! so exit loop and return line
!          end if
!       endif
!       !        print*,line(1:80)
!    enddo rdloop

    !    print*,"Got non-comment line"
    !    print*,line(1:80)

!  end subroutine get_next_noncomment_line

  subroutine make_log_axis(inline,axis,axis_len)
    !--------args------------!
    character(len=*),intent(in)::inline
    real(kind=r8),pointer,dimension(:)::axis
    integer,intent(out)::axis_len
    !-------locals--------------!
    character(len=30)::linetype,axistype
    real(kind=r8)::basepressure
    integer,dimension(:),allocatable::n_levs_in_sec,n_levs_per_dec,axints
    integer::nwords,j,nsections,stind,st,i
    real(kind=r8)::gridstep
    !-------Executable----------!

    ! Warning: axis must be nullified or associated!
    if (associated(axis)) then 
       deallocate(axis)
    endif

    !Count words in inline. 
    nwords=1
    do j=2,len(inline)
       if(inline(j:j) /= " " .and. inline(j-1:j-1) == " ") then
          nwords=nwords+1
       endif
    enddo
    nsections=(nwords-3)/2
!    print*,"Inline=",inline
!    print*,"Nwords=",nwords
    allocate(n_levs_in_sec(1:nsections),n_levs_per_dec(1:nsections),&
         axints(1:nsections*2))
    read(unit=inline,fmt=*)linetype,axistype,basepressure,axints
!    print*,"Linetype=",linetype," axistype=",axistype
!    print*,"basepressure=",basepressure," Axints=",axints
    n_levs_in_sec=axints(1:nsections*2-1:2)
    n_levs_per_dec=axints(2:nsections*2:2)

    axis_len=sum(n_levs_in_sec)

    allocate(axis(1:axis_len))
    axis(1)=-log10(basepressure)
    stind=0
    do j=1,nsections
       gridstep=1.0_r8/n_levs_per_dec(j)
       if (j == 1) then
          st=2
       else
          st=1
       endif
       do i=st,n_levs_in_sec(j)
          axis(stind+i)=axis(stind+i-1)+gridstep
       end do
       stind=stind+n_levs_in_sec(j)
    end do
    axis=10.0_r8**(-axis)
    deallocate(n_levs_in_sec, n_levs_per_dec,axints)

  end subroutine make_log_axis

  subroutine make_linear_axis(inline,axis,axis_len)
    !--------args------------!
    character(len=*),intent(in)::inline
    real(kind=r8),pointer,dimension(:)::axis
    integer,intent(out)::axis_len
    !-------locals--------------!
    character(len=30)::linetype,axistype
    real(kind=r8)::baseval
    integer,dimension(:),allocatable::n_levs_in_sec
    real(kind=r8),dimension(:),allocatable::gridstep,axints
    integer::nwords,j,nsections,stind,st,i
    !-------Executable----------!
    ! Warning: axis must be nullified or associated!
    if (associated(axis)) then 
       deallocate(axis)
    endif

    !Count words in inline. 

    nwords=1
    do j=2,len(inline)
       if(inline(j:j) /= " " .and. inline(j-1:j-1) == " ") then
          nwords=nwords+1
       endif
    enddo
    nsections=(nwords-3)/2

    allocate(n_levs_in_sec(1:nsections),gridstep(1:nsections),&
         axints(1:nsections*2))

    read(unit=inline,fmt=*)linetype,axistype,baseval,axints
    n_levs_in_sec=nint(axints(1:nsections*2-1:2))
    gridstep=axints(2:nsections*2:2)

    axis_len=sum(n_levs_in_sec)

    allocate(axis(1:axis_len))
    axis(1)=baseval
    stind=0
    do j=1,nsections
       if (j == 1) then
          st=2
       else
          st=1
       endif
       do i=st,n_levs_in_sec(j)
          axis(stind+i)=axis(stind+i-1)+gridstep(j)
       end do
       stind=stind+n_levs_in_sec(j)
    end do
    deallocate(axints,gridstep,n_levs_in_sec)

  end subroutine make_linear_axis

  subroutine read_explicit_axis(unit,axis,axis_len)
    !--------args------------!
    integer,intent(in)::unit
    real(kind=r8),pointer,dimension(:)::axis
    integer,intent(out)::axis_len
    !------- Local vars ---------!
    integer,parameter::ri_len=30
    character(len=ri_len)::readitem
    character(len=1)::rdchar
    real(kind=r8),dimension(1:200)::tmpaxis
    integer::i,iotest
    logical::foundcb
    !Executables
    ! Warning: axis must be nullified or associated!
    if (associated(axis)) then 
       deallocate(axis)
    endif
    ! readitem needs to be initialised or there is a point where it 
    ! can be used before being set.
    readitem=""
    ! An explicit axis is supplied as a parenthesised list, spread 
    ! over several lines. This is a Royal PIA.
    ! Read chars till we get to the (
    do 
       read(unit=unit,fmt="(a)",advance="no")rdchar
       !        write(unit=*,fmt="(a)",advance="no")rdchar 
       if(rdchar=="(") then
          exit 
       endif
    enddo
    !    print*,"Got open paren"
    ! now read items and add them to the axis until we get to the )
    axis_len=0
    foundcb=.false.
    itemsloop:do
       i=1
       charsloop:do
          read(unit=unit,fmt="(a)",advance="no",iostat=iotest)rdchar
          !write(unit=*,fmt="(a)",advance="no")rdchar 
          if(rdchar==")") then
             !print*,"Found ) at end of explicit axis"
             foundcb=.true.
             exit charsloop
          endif
          if (rdchar==" ") then
             exit charsloop
          endif
          readitem(i:i)=rdchar
          i=i+1
       enddo charsloop
       if ((i<=1 .and. .not.foundcb) .or. (i==2 .and. readitem(1:1)==" ")) then
          cycle itemsloop
       endif
       if ( i <= 1 .and. foundcb) then
          exit itemsloop
       endif
       !print*,"Axis item is",readitem(1:i-1)
       axis_len=axis_len+1
       read(unit=readitem(1:i-1),fmt=*)tmpaxis(axis_len)
        !print*,"Element",axis_len," is ",tmpaxis(axis_len)
        if (foundcb) then
           exit itemsloop
        endif
    end do itemsloop
    allocate(axis(1:axis_len))
    axis=tmpaxis(1:axis_len)
  end subroutine read_explicit_axis

  function l3ascii_get_multiplier(field) result(multiplier)
    ! This function attempts to return the number by which the mixing ratio
    ! in the file was multiplied. If the data are mixing ratio or Kelvin, it 
    ! returns 1, if they are ppmv, it returns 1.e6, if they are ppbv, it
    ! returns 1.e9, if they are pptv it returns 1.e12. This is  just done by
    ! parsing the "units" string in the file. If that is wrong, the function
    ! won't be right either.
    !------Argument)------!
    type(GriddedData_T), intent(in) :: field
    !---Function result-----!
    real(kind=r8) :: multiplier
    !---other vars-------!
    character(len=NameLen) :: ucunits
    integer :: ix
    !----Executable functions---!
    ucunits = Capitalize(field%units)
    ix = index(ucunits,"VMR ")
    if (ix > 0) then
       multiplier=1.0_r8
       return
    endif
    ix=index(ucunits,"PPM")
    if (ix > 0) then
       multiplier=1.0e6_r8
       return
    endif
    ix=index(ucunits,"PPB")
    if (ix > 0) then
       multiplier=1.0e9_r8
       return
    endif
    ix=index(ucunits,"PPT")
    if (ix > 0) then
       multiplier=1.0e12_r8
       return
    endif
    ix=index(ucunits,"K ")
    if (ix > 0) then
       multiplier=1.0_r8
       return
    endif
    call MLSMessage(MLSMSG_Warning,ModuleName,&
         "in function l3ascii_get_multiplier: Units "//&
         trim(field%units)//" for field "//trim(field%quantityName)//&
         "not known. Guessing multiplier=1.0")
    !print*,"in function l3ascii_get_multiplier: Units "//&
    !     trim(field%units)//" for field "//trim(field%quantityName)//&
    !     "not known. Guessing multiplier=1.0"
   multiplier=1.0_r8
  end function l3ascii_get_multiplier

!----------------- Beginning of Paul's code ------------------

    !---------------------------- ReadGriddedData ---------------------
  SUBROUTINE ReadGriddedData(FileName, lcf_where, description, v_type, &
  & the_g_data, GeoDimList, fieldName)
    !------------------------------------------------------------------------

    ! This routine reads a Gridded Data file, returning a filled data structure and the !
	! appropriate for 'ncep' or 'dao'

	! FileName and the_g_data are required args
	! GeoDimList, if present, should be the Dimensions' short names
	! as a comma-delimited character string in the order:
	! longitude, latitude, vertical level, time
	
	! fieldName, if present, should be the rank 3 or higher object
	! like temperature

    ! Arguments

    CHARACTER (LEN=*), INTENT(IN) :: FileName ! Name of the file containing the grid(s)
    INTEGER, INTENT(IN) :: lcf_where			! node of the lcf that provoked me
    INTEGER, INTENT(IN) :: v_type			! vertical coordinate; an 'enumerated' type
     TYPE( GriddedData_T ), INTENT(OUT) :: the_g_data ! Result
    CHARACTER (LEN=*), INTENT(IN) :: description ! e.g., 'dao'
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN) :: GeoDimList ! Comma-delimited dim names
	 CHARACTER (LEN=*), OPTIONAL, INTENT(IN) :: fieldName ! Name of gridded field

    ! Local Variables

  integer :: edges(4)
  integer :: file_id, gd_id
  integer :: inq_success
  integer :: i
  integer :: nentries, ngrids, ndims, nfields
  integer :: strbufsize
!  character (len=80) :: msg, mnemonic
!  integer :: status

    LOGICAL,  PARAMETER       :: CASESENSITIVE = .FALSE.
  integer, parameter :: GRIDORDER=1				! What order grid written to file
  integer, parameter :: MAXLISTLENGTH=LineLen		! Max length list of grid names
  integer, parameter :: NENTRIESMAX=20		   ! Max num of entries
  character (len=MAXLISTLENGTH) :: gridlist
  character (len=MAXLISTLENGTH) :: dimlist, actual_dim_list
  character (len=MAXLISTLENGTH), DIMENSION(1) :: dimlists
  character (len=MAXLISTLENGTH) :: fieldlist
  integer, parameter :: MAXNAMELENGTH=NameLen		! Max length of grid name
  character (len=MAXNAMELENGTH) :: gridname, actual_field_name, the_dim
  INTEGER, DIMENSION(NENTRIESMAX) :: dims, rank, numberTypes, start, stride
  INTEGER                        :: our_rank, size, numberType
	!                                  These start out initialized to one
  INTEGER                        :: nlon=1, nlat=1, nlev=1, ntime=1
  INTEGER, PARAMETER             :: i_longitude=1
  INTEGER, PARAMETER             :: i_latitude=i_longitude+1
  INTEGER, PARAMETER             :: i_vertical=i_latitude+1
  INTEGER, PARAMETER             :: i_time=i_vertical+1
  ! External functions
!  integer, external :: gdopen, gdattach, gdrdfld, gddetach, gdclose
!  integer, external :: gdinqgrid, gdnentries, gdinqdims, gdinqflds
  INTEGER, EXTERNAL :: GDRDFLD
  logical, parameter :: COUNTEMPTY=.TRUE.

  ! - - - begin - - -

    error = 0
  file_id = gdopen(FileName, DFACC_RDONLY)

  IF (file_id < 0) THEN
	CALL announce_error(lcf_where, "Could not open "// FileName)
  END IF

! Find list of grid names on this file
  inq_success = gdinqgrid(FileName, gridlist, strbufsize)
  IF (inq_success < 0) THEN
	CALL announce_error(lcf_where, "Could not inquire gridlist "// FileName)
  END IF

! Find grid name corresponding to the GRIDORDER'th one
	ngrids = NumStringElements(gridlist, COUNTEMPTY)
	
	IF(ngrids <= 0) THEN
		CALL announce_error(lcf_where, "NumStringElements of gridlist <= 0")
	ELSEIF(ngrids /= inq_success) THEN
		CALL announce_error(lcf_where, "NumStringElements of gridlist /= inq_success")
	ELSEIF(ngrids < GRIDORDER) THEN
		CALL announce_error(lcf_where, "NumStringElements of gridlist < GRIDORDER")
	ENDIF
	
	CALL GetStringElement(gridlist, gridname, GRIDORDER, COUNTEMPTY)

  gd_id = gdattach(file_id, gridname)
  IF (gd_id < 0) THEN
		CALL announce_error(lcf_where, "Could not attach "//FileName)
  END IF

! Now find dimsize(), dimname(), etc.
	nentries = gdnentries(gd_id, HDFE_NENTDIM, strbufsize)

	IF(nentries <= 0) THEN
		CALL announce_error(lcf_where, "nentries of gd_id <= 0")
	ELSEIF(nentries > NENTRIESMAX) THEN
		CALL announce_error(lcf_where, "nentries of gd_id > NENTRIESMAX")
	ENDIF

	ndims = gdinqdims(gd_id, dimlist, dims)

	IF(ndims <= 0) THEN
		CALL announce_error(lcf_where, "ndims of gd_id <= 0")
	ELSEIF(ndims > NENTRIESMAX) THEN
		CALL announce_error(lcf_where, "ndims of gd_id > NENTRIESMAX")
	ENDIF

	nfields = gdinqflds(gd_id, fieldlist, rank, numberTypes)

	IF(nfields <= 0) THEN
		CALL announce_error(lcf_where, "nfields of gd_id <= 0")
	ELSEIF(nfields > NENTRIESMAX) THEN
		CALL announce_error(lcf_where, "nfields of gd_id > NENTRIESMAX")
	ENDIF
	
	IF(.NOT. CASESENSITIVE) THEN
		fieldlist = Capitalize(fieldlist)
	ENDIF

	IF(PRESENT(fieldName)) THEN
		actual_field_name=fieldName
	ELSE
		actual_field_name=DEFAULTFIELDNAME
	ENDIF

	IF(PRESENT(GeoDimList)) THEN
		actual_dim_list=GeoDimList
	ELSE
		actual_dim_list=GEO_FIELD1 // ',' // &
		& GEO_FIELD2 // ',' // &
		& GEO_FIELD3 // ',' // &
		& GEO_FIELD4
	ENDIF

	! Now find the rank of our field
	
	inq_success = gdfldinfo(gd_id, TRIM(actual_field_name), our_rank, dims, &
	& numbertype, dimlists(1))

	dimlist = TRIM(dimlists(1))

	nlon = dims(1)
	nlat = dims(2)
	nlev = dims(3)
	ntime = dims(4)
		  
	the_g_data%quantityName = actual_field_name
	the_g_data%description = description
	the_g_data%verticalCoordinate = v_type
	  
	the_g_data%noLons = nlon
	the_g_data%noLats = nlat
	the_g_data%noHeights = nlev
	the_g_data%noLsts = ntime

  !-----------------------------
  END SUBROUTINE ReadGriddedData
  !-----------------------------

  ! ------------------------------------------------  OBTAIN_CLIM  -----
  !=====================================================================
  subroutine OBTAIN_CLIM ( aprioriData, root, &
  & mlspcf_l2clim_start, mlspcf_l2clim_end )
  !=====================================================================

	! An atavism--
	! a throwback to when ncep files were opened
	! independently of being required by the lcf

    !Arguments 
    type (GriddedData_T), dimension(:), pointer :: aprioriData 
    ! Input a priori database
    integer, intent(in) :: root        ! Root of the L2CF abstract syntax tree
    integer, intent(in) :: mlspcf_l2clim_start, mlspcf_l2clim_end

    !Local Variables

    type (GriddedData_T):: qty
    character (LEN=256) :: msg, mnemonic
    integer:: CliUnit, processCli, returnStatus, version

    logical :: end_of_file = .FALSE.

    do CliUnit = mlspcf_l2clim_start, mlspcf_l2clim_end

!     Open one Climatology file as a generic file for reading
      version = 1
      returnStatus = Pgs_io_gen_openF ( CliUnit, PGSd_IO_Gen_RSeqFrm, 0, &
                                        processCli, version )
      if ( returnStatus == PGS_S_SUCCESS ) then

      do while (.NOT. end_of_file)

        call l3ascii_read_field ( processCli, qty, end_of_file)
        returnStatus = AddGridTemplateToDatabase(aprioriData, qty)
        call DestroyGridTemplateContents ( qty )

      end do !(.not. end_of_file)
		
		end_of_file = .FALSE.

      end if

    end do ! CliUnit = mlspcf_l2clim_start, mlspcf_l2clim_end

  return
  !============================
  end subroutine OBTAIN_CLIM
  !============================


  ! --------------------------------------------------  READ_CLIMATOLOGY  -----
  SUBROUTINE READ_CLIMATOLOGY ( fname, aprioriData, &
  & mlspcf_l2clim_start, mlspcf_l2clim_end )
  ! --------------------------------------------------
  ! Brief description of program
  ! This subroutine reads a l3ascii file and returns
  ! the data_array to the caller

  ! Arguments

  character*(*), intent(in) :: fname			! Physical file name
    type (GriddedData_T), dimension(:), pointer :: aprioriData 
	 INTEGER, INTENT(IN) :: mlspcf_l2clim_start, mlspcf_l2clim_end
	 
	 ! Local
    type (GriddedData_T)        :: gddata 
	 INTEGER :: thePC, ErrType
	 INTEGER, PARAMETER :: version=1
	 LOGICAL :: end_of_file=.FALSE.
    integer:: processCli, CliUnit
	 
	 thePC = GetPCFromRef(fname, mlspcf_l2clim_start, mlspcf_l2clim_end, &
  & .TRUE., ErrType, version)
  
  IF(ErrType /= 0) THEN
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"Climatology file name unmatched in PCF")
	RETURN
  ENDIF

      ErrType = Pgs_io_gen_openF ( CliUnit, PGSd_IO_Gen_RSeqFrm, 0, &
                                        processCli, version )
      if ( ErrType == PGS_S_SUCCESS ) then

      do while (.NOT. end_of_file)

        call l3ascii_read_field ( processCli, gddata, end_of_file)
        ErrType = AddGridTemplateToDatabase(aprioriData, gddata)
        call DestroyGridTemplateContents ( gddata )

      end do !(.not. end_of_file)
		
		endif

	END SUBROUTINE READ_CLIMATOLOGY

  ! -------------------------------------------------  OBTAIN_DAO  -----
  subroutine OBTAIN_DAO ( aprioriData, root, &
  & mlspcf_l2dao_start, mlspcf_l2dao_end )
 
	! An atavism--
	! a throwback to when ncep files were opened
	! independently of being required by the lcf

    type (GriddedData_T), dimension(:), pointer :: aprioriData 
    ! Input a priori database
    integer, intent(in) :: ROOT        ! Root of L2CF abstract syntax tree
	 INTEGER, INTENT(IN) :: mlspcf_l2dao_start, mlspcf_l2dao_end

! Local Variables

!    real(R8) :: data_array(XDIM, YDIM, ZDIM)
    integer :: DAOFileHandle, DAO_Version
    character (LEN=132) :: DAOphysicalFilename
    character (len=256) :: mnemonic, msg
    type (GriddedData_T):: qty
    integer :: returnStatus
!   integer :: sd_id
    character (LEN=80) :: vname

!    ALLOCATE (data_array(XDIM, YDIM, ZDIM), stat=returnStatus)

    DAO_Version = 1
    vname = "TMPU" ! for now


! Get the DAO file name from the PCF

    do DAOFileHandle = mlspcf_l2dao_start, mlspcf_l2dao_end

      returnStatus = Pgs_pc_getReference ( DAOFileHandle, DAO_Version, &
                                           DAOphysicalFilename )

      if ( returnStatus == PGS_S_SUCCESS ) then

! Open the HDF-EOS file and read gridded data
        returnStatus = AddGridTemplateToDatabase(aprioriData, qty)

!        call read_dao ( DAOphysicalFilename, vname, data_array )
			IF(returnStatus > 0) THEN
				call ReadGriddedData ( DAOphysicalFilename, root, &
				& 'dao', v_is_pressure, aprioriData(returnStatus) )
			ENDIF

      end if

    end do ! DAOFileHandle = mlspcf_l2_dao_start, mlspcf_l2_dao_end

!===========================
  end subroutine Obtain_DAO
!===========================

  ! ------------------------------------------------  Obtain_NCEP  -----
  subroutine Obtain_NCEP ( aprioriData, root, &
  & mlspcf_l2ncep_start, mlspcf_l2ncep_end )

	! An atavism--
	! a throwback to when ncep files were opened
	! independently of being required by the lcf

	    ! Arguments
    type (GriddedData_T), dimension(:), pointer :: aprioriData 
    ! Input a priori database
    integer, intent(in) :: ROOT        ! Root of the L2CF abstract syntax tree
	 INTEGER, INTENT(IN) :: mlspcf_l2ncep_start, mlspcf_l2ncep_end

    ! Local Variables
!    character (len=80) :: MSG, MNEMONIC
    integer :: NCEPFileHandle, NCEP_Version
    character (len=132) :: NCEPphysicalFilename
    type (GriddedData_T):: QTY
    integer :: RETURNSTATUS
!    character (len=80) :: VNAME

!   allocate ( data_array(XDIM, YDIM, ZDIM), stat=returnStatus )

    NCEP_Version = 1
!    vname = "TMP_3" ! for now
! Get the NCEP file name from the PCF

    do NCEPFileHandle = mlspcf_l2ncep_start, mlspcf_l2ncep_end

      returnStatus = Pgs_pc_getReference ( NCEPFileHandle, NCEP_Version, &
                                           NCEPphysicalFilename )

      if ( returnStatus == PGS_S_SUCCESS ) then

! Open the HDF-EOS file and read gridded data

        returnStatus = AddGridTemplateToDatabase(aprioriData, qty)

!        call read_ncep ( NCEPphysicalFilename, data_array )
			IF(returnStatus > 0) THEN
				call ReadGriddedData ( NCEPphysicalFilename, root, &
				& 'ncep', v_is_pressure, aprioriData(returnStatus) )
			ENDIF

      end if

    end do ! NCEPFileHandle = mlspcf_l2_ncep_start, mlspcf_l2_ncep_end
!===========================
  end subroutine Obtain_NCEP
!===========================

  ! ------------------------------------------------  announce_error  -----
  subroutine announce_error ( lcf_where, full_message, use_toolkit )
  
   ! Arguments
	
	integer, intent(in)    :: lcf_where
	character(LEN=*), intent(in)    :: full_message
	logical, intent(in), optional :: use_toolkit
	! Local
!  character (len=80) :: msg, mnemonic
!  integer :: status
  logical :: just_print_it
  logical, parameter :: default_output_by_toolkit = .true.
	
	if(present(use_toolkit)) then
		just_print_it = use_toolkit
	elseif(default_output_by_toolkit) then
		just_print_it = .false.
	else
		just_print_it = .true.
	endif
	
	if(.not. just_print_it) then
!    CALL Pgs_smf_getMsg(status, mnemonic, msg)
!    CALL MLSMessage (level, ModuleName, &
!              &trim(full_message)//" "//mnemonic//" "//msg)
    error = max(error,1)
    call output ( '***** At ' )

	if(lcf_where > 0) then
	    call print_source ( source_ref(lcf_where) )
		else
    call output ( '(no lcf node available)' )
		endif

    call output ( ': ' )
    call output ( "The " );
	if(lcf_where > 0) then
    call dump_tree_node ( lcf_where, 0 )
		else
    call output ( '(no lcf tree available)' )
		endif

		CALL output("Caused the following error:", advance='yes', &
		& from_where=ModuleName)
		CALL output(trim(full_message), advance='yes', &
		& from_where=ModuleName)
	else
		print*, '***Error in module ', ModuleName
		print*, trim(full_message)
	endif

!===========================
  end subroutine announce_error
!===========================

a90 26
! Revision 2.7  2001/03/14 00:32:47  pwagner
! More changes--still wrong, though
!
! Revision 2.6  2001/03/10 00:33:16  pwagner
! Some corrections in ReadGriddedData
!
! Revision 2.5  2001/03/09 01:02:55  pwagner
! Fixed announce_error
!
! Revision 2.4  2001/03/08 01:08:35  pwagner
! Added announce_error
!
! Revision 2.3  2001/03/07 01:03:19  pwagner
! ReadGriddedData added
!
! Revision 2.2  2001/02/21 00:36:43  pwagner
! l3ascii_read_field now has eof as intent(out) arg
!
! Revision 2.1  2001/02/20 21:51:39  pwagner
! Functions absorbed from gridded_data_module
!
! Revision 2.0  2000/09/05 17:41:05  dcuddy
! Change revision to 2.0
!
! Revision 1.5  2000/06/20 22:19:22  lungu
! Changed DOUBBLE PRECISION to REAL (r8).
@


2.7
log
@More changes--still wrong, though
@
text
@d12 1
a12 1
  & gdopen, gdattach, gddetach, gdclose, &
d15 1
d25 1
d33 1
a33 1
       "$Id: GriddedData.f90,v 2.6 2001/03/10 00:33:16 pwagner Exp $"
d50 10
a59 1

d1161 2
a1162 1
  SUBROUTINE ReadGriddedData(FileName, the_g_data, GeoDimList, fieldName)
d1179 2
d1182 1
d1194 2
a1195 2
  character (len=80) :: msg, mnemonic
  integer :: status
d1203 1
d1207 2
a1208 2
  INTEGER, DIMENSION(NENTRIESMAX) :: dims, rank, numberType, start, stride
  INTEGER                        :: our_rank, size
d1223 1
d1227 1
a1227 4
!    CALL Pgs_smf_getMsg(status, mnemonic, msg)
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"Could not open "// FileName//" "//mnemonic//" "//msg)
	CALL announce_error(MLSMSG_Error, "Could not open "// FileName)
d1233 1
a1233 4
!    CALL Pgs_smf_getMsg(status, mnemonic, msg)
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"Could not inquire gridlist "// FileName//" "//mnemonic//" "//msg)
	CALL announce_error(MLSMSG_Error, "Could not inquire gridlist "// FileName)
d1240 1
a1240 3
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"NumStringElements of gridlist <= 0")
		CALL announce_error(MLSMSG_Error, "NumStringElements of gridlist <= 0")
d1242 1
a1242 3
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"NumStringElements of gridlist < GRIDORDER")
		CALL announce_error(MLSMSG_Error, "NumStringElements of gridlist /= inq_success")
d1244 1
a1244 3
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"NumStringElements of gridlist < GRIDORDER")
		CALL announce_error(MLSMSG_Error, "NumStringElements of gridlist < GRIDORDER")
d1251 1
a1251 4
!    CALL Pgs_smf_getMsg(status, mnemonic, msg)
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!               "Could not attach "//FileName//" "//mnemonic//" "//msg)
		CALL announce_error(MLSMSG_Error, "Could not attach "//FileName)
d1258 1
a1258 3
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"nentries of gd_id <= 0")
		CALL announce_error(MLSMSG_Error, "nentries of gd_id <= 0")
d1260 1
a1260 3
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"nentries of gd_id > NENTRIESMAX")
		CALL announce_error(MLSMSG_Error, "nentries of gd_id > NENTRIESMAX")
d1266 1
a1266 3
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"ndims of gd_id <= 0")
		CALL announce_error(MLSMSG_Error, "ndims of gd_id <= 0")
d1268 1
a1268 3
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"ndims of gd_id > NENTRIESMAX")
		CALL announce_error(MLSMSG_Error, "ndims of gd_id > NENTRIESMAX")
d1271 1
a1271 1
	nfields = gdinqflds(gd_id, fieldlist, rank, numberType)
d1274 1
a1274 3
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"nfields of gd_id <= 0")
		CALL announce_error(MLSMSG_Error, "nfields of gd_id <= 0")
d1276 1
a1276 3
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"nfields of gd_id > NENTRIESMAX")
		CALL announce_error(MLSMSG_Error, "nfields of gd_id > NENTRIESMAX")
d1300 4
a1303 6
	our_rank = GetIntHashElement(fieldlist, rank, actual_field_name, status, &
  & countEmpty)
  IF (status /= 0) THEN
		CALL announce_error(MLSMSG_Error, &
		& actual_field_name // " not in " // fieldlist)
  END IF
d1305 4
a1308 25
	! The following accounts for possibly different ordering between dimlist
	! and actual_dim_list
	DO i=1, our_rank
		CALL GetStringElement(actual_dim_list, the_dim, i, countEmpty)
		size = gddiminfo(gd_id, the_dim)
	  IF (size <= 0) THEN
			CALL announce_error(MLSMSG_Error, &
			& the_dim // " size <= 0")
	  END IF
	  
        select case ( i )
        case ( i_longitude )
          nlon=size
        case ( i_latitude )
          nlat=size
        case ( i_vertical )
          nlev=size
        case ( i_time )
          ntime=size
        end select
		  
		  the_g_data%noLats = nlat
		  the_g_data%noLons = nlon
		  the_g_data%noLsts = ntime
		  the_g_data%noSzas = nlev
d1310 3
a1312 1
		  the_g_data%quantityName = actual_field_name
a1313 2
	ENDDO

d1465 2
a1466 1
				call ReadGriddedData ( DAOphysicalFilename, aprioriData(returnStatus) )
d1492 1
a1492 1
    character (len=80) :: MSG, MNEMONIC
d1518 2
a1519 1
				call ReadGriddedData ( NCEPphysicalFilename, aprioriData(returnStatus) )
d1530 1
a1530 1
  subroutine announce_error ( level, full_message, use_toolkit )
d1534 2
a1535 1
	integer, intent(in)    :: level
a1536 1
	character(LEN=*), intent(in)    :: full_message
d1538 2
a1539 2
  character (len=80) :: msg, mnemonic
  integer :: status
d1555 18
a1572 4
		CALL output("An error of level ", advance='no', &
		& from_where=ModuleName)
		CALL output(level, advance='no' )
		CALL output(" occurred; more specifically", advance='yes', &
d1577 1
a1577 1
		print*, '***Error: level ', level, ' in module ', ModuleName
d1591 3
@


2.6
log
@Some corrections in ReadGriddedData
@
text
@d21 1
d31 1
a31 1
       "$Id: GriddedData.f90,v 2.5 2001/03/09 01:02:55 pwagner Exp $"
d1337 7
d1572 1
a1572 1
  logical, parameter :: default_output_by_toolkit = .false.
d1583 10
a1592 3
    CALL Pgs_smf_getMsg(status, mnemonic, msg)
    CALL MLSMessage (level, ModuleName, &
              &trim(full_message)//" "//mnemonic//" "//msg)
d1608 3
@


2.5
log
@Fixed announce_error
@
text
@d13 1
a13 1
  & gdinqgrid, gdnentries, gdinqdims, gdinqflds
d20 1
a20 1
  & Count_words, ReadCompleteLineWithoutComments
d30 1
a30 1
       "$Id: GriddedData.f90,v 2.4 2001/03/08 01:08:35 pwagner Exp $"
d36 4
d45 2
d51 1
d1155 8
a1178 1
  integer :: start(4)
a1179 1
  integer :: stride(4)
d1186 1
a1186 1
  character (len=MAXLISTLENGTH) :: dimlist
d1189 9
a1197 2
  character (len=MAXNAMELENGTH) :: gridname
  INTEGER, DIMENSION(NENTRIESMAX) :: dims, rank, numberType
d1208 1
a1208 1
  IF (file_id /= SUCCEED) THEN
d1217 1
a1217 1
  IF (inq_success /= SUCCEED) THEN
d1231 4
d1244 1
a1244 1
  IF (gd_id /= SUCCEED) THEN
d1293 7
d1301 4
d1307 38
a1344 1
    !-----------------------------
d1593 3
@


2.4
log
@Added announce_error
@
text
@d30 1
a30 1
       "$Id: GriddedData.f90,v 2.3 2001/03/07 01:03:19 pwagner Exp $"
d1246 1
d1508 1
a1508 1
		print*, trim(full_message)//" "//mnemonic//" "//msg
d1521 3
@


2.3
log
@ReadGriddedData added
@
text
@d30 1
a30 1
       "$Id: GriddedData.f90,v 2.2 2001/02/21 00:36:43 pwagner Exp $"
d45 5
d1142 1
a1142 1
  SUBROUTINE ReadGriddedData(FileName, the_g_data, fieldName)
d1146 1
d1152 2
a1153 1
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN) :: fieldName ! Name of gridded field
d1168 1
d1170 1
a1170 1
  integer, parameter :: MAXLISTLENGTH=80		! Max length list of grid names
d1175 1
a1175 1
  integer, parameter :: MAXNAMELENGTH=16		! Max length of grid name
d1189 4
a1192 3
    CALL Pgs_smf_getMsg(status, mnemonic, msg)
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"Could not open "// FileName//" "//mnemonic//" "//msg)
d1198 4
a1201 3
    CALL Pgs_smf_getMsg(status, mnemonic, msg)
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"Could not inquire gridlist "// FileName//" "//mnemonic//" "//msg)
d1208 3
a1210 2
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"NumStringElements of gridlist <= 0")
d1212 3
a1214 2
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"NumStringElements of gridlist < GRIDORDER")
d1221 4
a1224 3
    CALL Pgs_smf_getMsg(status, mnemonic, msg)
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
               "Could not attach "//FileName//" "//mnemonic//" "//msg)
d1231 3
a1233 2
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"nentries of gd_id <= 0")
d1235 3
a1237 2
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"nentries of gd_id > NENTRIESMAX")
d1243 6
a1248 5
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"ndims of gd_id <= 0")
	ELSEIF(ndims > NENTRIESMAX) THEN
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"ndims of gd_id > NENTRIESMAX")
d1254 3
a1256 2
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"nfields of gd_id <= 0")
d1258 11
a1268 2
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"nfields of gd_id > NENTRIESMAX")
d1270 1
d1479 35
d1520 3
@


2.2
log
@l3ascii_read_field now has eof as intent(out) arg
@
text
@d11 12
a22 3
  USE MLSCommon
  USE MLSMessageModule
  USE MLSStrings
d30 1
a30 1
       "$Id: GriddedData.f90,v 2.1 2001/02/20 21:51:39 pwagner Exp $"
d1134 318
d1458 3
@


2.1
log
@Functions absorbed from gridded_data_module
@
text
@d21 1
a21 1
       "$Id: GriddedData.f90,v 2.0 2000/09/05 17:41:05 dcuddy Exp $"
d247 2
a248 1
  SUBROUTINE AddGridTemplateToDatabase(database,qty)
d252 2
a253 1
    TYPE (GriddedData_T), INTENT(IN) :: qty
d257 1
a257 1
    INTEGER :: newSize,status
d261 1
a261 1
    IF (ASSOCIATED(database)) THEN
d263 22
a284 10
       IF (LinearSearchStringArray(database%quantityName, qty%quantityName, &
            & caseInsensitive=.TRUE.)/=0) CALL MLSMessage(MLSMSG_Error,&
            & ModuleName,MLSMSG_Duplicate//qty%quantityName)
       newSize=SIZE(database)+1
    ELSE
       newSize=1
    ENDIF
    ALLOCATE(tempDatabase(newSize),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Allocation failed for tempDatabase")
d286 1
a286 9
    IF (newSize>1) tempDatabase(1:newSize-1)=database
    tempDatabase(newSize)=qty
    IF (ASSOCIATED(database)) THEN
       DEALLOCATE(database, STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"database")
    end if
    database=>tempDatabase
  END SUBROUTINE AddGridTemplateToDatabase
d348 1
a348 1
  subroutine l3ascii_read_field(unit,field)
d353 1
a363 1
    logical :: end_of_file
d366 1
d401 1
a401 1
    else
d1131 3
@


2.0
log
@Change revision to 2.0
@
text
@d21 1
a21 1
       "$Id: GriddedData.f90,v 1.5 2000/06/20 22:19:22 lungu Exp $"
d27 6
a32 1
 
d47 1
a47 1
   CHARACTER (LEN=LineLen), POINTER, DIMENSION(:) :: fileComments
d59 1
a59 1
   REAL (R8), POINTER, DIMENSION(:) :: heights 
d66 1
a66 1
   REAL (R8), POINTER, DIMENSION(:) :: lats ! Latitudes [noLats]
d69 1
a69 1
   REAL (R8), POINTER, DIMENSION(:) :: lons ! Longitudes [noLons]
d72 1
a72 1
   REAL (R8), POINTER, DIMENSION(:) :: lsts ! Local times [noLsts]
d75 1
a75 1
   REAL (R8), POINTER, DIMENSION(:) :: szas ! Zenith angles [noSzas]
d78 1
a78 1
   REAL (R8), POINTER, DIMENSION(:) :: dateStarts
d80 1
a80 1
   REAL (R8), POINTER, DIMENSION(:) :: dateEnds
d83 1
a83 1
   REAL (R8), POINTER, DIMENSION(:,:,:,:,:,:) :: field
d304 814
d1124 3
@


1.5
log
@Changed DOUBBLE PRECISION to REAL (r8).
@
text
@d21 1
a21 1
       "$Id: GriddedData.f90,v 1.5 2000/06/20 22:19:22 lungu Exp $"
d305 3
a310 25
! Revision 1.4  2000/06/19 22:55:00  lungu
! Added status check after each DEALLOCATE.
!
! Revision 1.3  2000/01/12 01:16:35  lungu
! Finalised code.
!
! Revision 1.2  2000/01/07 02:04:11  lungu
! Changed Id
!
! Revision 1.1  2000/01/07 02:02:25  lungu
! Separate module from open_init
!
! Revision 1.1  2000/01/05 02:12:39  lungu
! Added subroutines to handle GriddedData
!

!








@


1.1
log
@Separate module from open_init
@
text
@d7 1
a7 2
MODULE GriddedData ! Opens and reads l2cf info, NCEP, DAO and climatology(ies) file
s
d13 1
a13 2
  USE MLSSignalNomenclature
  USE VGrid
d21 2
a22 2
       "$Id:"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCS$"
d54 1
a54 1
   DOUBLE PRECISION, POINTER, DIMENSION(:) :: heights 
d61 1
a61 1
   DOUBLE PRECISION, POINTER, DIMENSION(:) :: lats ! Latitudes [noLats]
d64 1
a64 1
   DOUBLE PRECISION, POINTER, DIMENSION(:) :: lons ! Longitudes [noLons]
d67 1
a67 1
   DOUBLE PRECISION, POINTER, DIMENSION(:) :: lsts ! Local times [noLsts]
d70 1
a70 1
   DOUBLE PRECISION, POINTER, DIMENSION(:) :: szas ! Zenith angles [noSzas]
d73 1
a73 1
   DOUBLE PRECISION, POINTER, DIMENSION(:) :: dateStarts
d75 1
a75 1
   DOUBLE PRECISION, POINTER, DIMENSION(:) :: dateEnds
d78 1
a78 1
   DOUBLE PRECISION, POINTER, DIMENSION(:,:,:,:,:,:) :: field
d98 1
a98 1
  SUBROUTINE SetupNewGridTemplate(qty, source)
d105 2
d117 4
d126 3
d136 3
a138 2


d141 1
a141 1
    ALLOCATE (qty%surfs(qty%noLats,noHeightsToAllocate),STAT=status)
d143 1
a143 1
         & MLSMSG_Allocate//"surfs")
d145 2
a146 3
    ! Now the horizontal coordinates

    ALLOCATE (qty%phi(noLatsToAllocate,qty%noHeights),STAT=status)
d148 1
a148 1
         & MLSMSG_Allocate//"phi")
d150 1
a150 1
    ALLOCATE (qty%geodLat(noLatsToAllocate,qty%noHeights),STAT=status)
d152 1
a152 1
         & MLSMSG_Allocate//"geodLat")
d154 1
a154 1
    ALLOCATE (qty%lon(noLatsToAllocate,qty%noHeights),STAT=status)
d156 1
a156 1
         & MLSMSG_Allocate//"lon")
d158 1
a158 1
    ALLOCATE (qty%time(noLatsToAllocate,qty%noHeights),STAT=status)
d160 1
a160 1
         & MLSMSG_Allocate//"time")
d162 2
a163 1
    ALLOCATE (qty%solarTime(noLatsToAllocate,qty%noHeights),STAT=status)
d165 1
a165 1
         & MLSMSG_Allocate//"solarTime")
d167 1
a167 1
    ALLOCATE (qty%solarZenith(noLatsToAllocate,qty%noHeights),STAT=status)
d169 1
a169 1
         & MLSMSG_Allocate//"solarZenith")
d171 3
a173 3
    ALLOCATE (qty%losAngle(noLatsToAllocate,qty%noHeights),STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"losAngle")
a174 2
    ! Now some other stuff to allocate
    ALLOCATE (qty%subVectorIndex(qty%noHeights),STAT=status)
d176 1
a176 1
         & MLSMSG_Allocate//"subVectorIndex")
a177 4
    IF (.NOT. qty%regular) THEN
       ALLOCATE (qty%surfIndex(qty%subVectorLen,qty%noHeights),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"surfIndex")
d179 1
a179 9
       ALLOCATE (qty%chanIndex(qty%subVectorLen,qty%noHeights),STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"chanIndex")
    ENDIF

    ! Se the id field and increment the counter
    qty%id=quantityTemplateCounter
    quantityTemplateCounter=quantityTemplateCounter+1
  END SUBROUTINE SetupNewGriddedDataTemplate
d185 1
a185 1
  SUBROUTINE DestroyGriddedDataTemplateContents(qty)
d189 2
d194 40
a233 14
    DEALLOCATE (qty%surfs)
    DEALLOCATE (qty%phi)
    DEALLOCATE (qty%geodLat)
    DEALLOCATE (qty%lon)
    DEALLOCATE (qty%time)
    DEALLOCATE (qty%solarTime)
    DEALLOCATE (qty%solarZenith)
    DEALLOCATE (qty%losAngle)
    DEALLOCATE (qty%subVectorIndex)
    
    IF (.NOT. qty%regular) THEN
       DEALLOCATE (qty%surfIndex)
       DEALLOCATE (qty%chanIndex)
    ENDIF
d235 1
a235 1
  END SUBROUTINE DestroyGriddedDataTemplateContents
d242 1
a242 1
  SUBROUTINE AddGriddedDataTemplateToDatabase(database,qty)
d256 1
a256 1
       IF (LinearSearchStringArray(database%name,qty%name, &
d258 1
a258 1
            & ModuleName,MLSMSG_Duplicate//qty%name)
a262 1

d269 5
a273 1
    DEALLOCATE(database)
d275 1
a275 1
  END SUBROUTINE AddGriddedDataTemplateToDatabase
d281 1
a281 1
  SUBROUTINE DestroyGriddedDataTemplateDatabase(database)
d287 1
a287 1
    INTEGER :: qtyIndex
d291 1
a291 1
          CALL DestroyGriddedDataTemplateContents(database(qtyIndex))
d293 3
a295 1
       DEALLOCATE(database)
d297 1
a297 1
  END SUBROUTINE DestroyGriddedDataTemplateDatabase
d305 12
d325 7
@


