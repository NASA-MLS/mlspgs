head	2.10;
access;
symbols
	v5-02-NRT-19:2.10
	v6-00:2.10
	v5-02-NRT-18:2.10
	v5-02:2.10
	v5-01-NRT-17:2.10
	v5-01-NRT-16:2.10
	v5-01-NRT-15:2.10
	v5-01-NRT-14:2.10
	neuralnetworks-1-0:2.10.0.10
	cfm-single-freq-0-1:2.10.0.8
	v5-01:2.10
	v5-00:2.10
	v4-23-TA133:2.10.0.6
	mus-emls-1-70:2.10.0.4
	rel-1-0-englocks-work:2.10.0.2
	VUMLS1-00:2.10
	VPL1-00:2.10
	V4-22-NRT-08:2.10
	VAM1-00:2.10
	V4-21:2.9.0.2
	V4-13:2.9
	V4-12:2.9
	V4-11:2.9
	V4-10:2.9
	V3-43:2.4
	M4-00:2.7
	V3-41:2.4
	V3-40-PlusGM57:2.4.0.2
	V2-24-NRT-04:2.3
	V3-33:2.4
	V2-24:2.3
	V3-31:2.4
	V3-30-NRT-05:2.4
	cfm-01-00:2.4
	V3-30:2.4
	V3-20:2.4
	V3-10:2.4
	V2-23-NRT-02:2.3
	V2-23:2.3
	V2-22-NRT-01:2.3
	V2-22:2.3
	V2-21:2.3
	V2-20:2.3
	V2-11:2.3
	V2-10:2.3
	V2-00:2.3;
locks; strict;
comment	@# @;


2.10
date	2015.05.29.00.33.56;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2013.09.24.23.27.14;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2013.06.12.02.13.10;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2011.08.20.02.32.10;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2011.08.10.01.47.17;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2011.07.22.18.29.51;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2006.04.20.01.08.32;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2005.06.03.01.52.30;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2005.05.02.22.55.13;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.10
log
@Don't look past the end of the message
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!==============================================================================
module MoreMessage ! Messaging with extra functionality
!==============================================================================

  implicit none
  private

  public :: MLSMessage
  public :: MessageWithDouble, MessageWithDoubleArray
  public :: MessageWithInteger, MessageWithIntegerArray
  public :: MessageWithSingle, MessageWithSingleArray
  public :: MessageWithWhere

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MoreMessage.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! This module provides nearly-low-level messaging for the MLSPGS suite.
  ! The extra functionality is that it allows to insert numbers or
  ! strings from the string table into the message.

  interface MLSMessage
    module procedure MessageWithDouble, MessageWithDoubleArray
    module procedure MessageWithInteger, MessageWithIntegerArray
    module procedure MessageWithSingle, MessageWithSingleArray
    module procedure MessageWithWhere
  end interface

contains

  ! ------------------------------------------  MessageWithDouble  -----
  subroutine MessageWithDouble ( Severity, ModuleNameIn, Message, Datum, &
    & Where, Advance )
    ! Insert "Datum" into "Message" in place of "%r" or "%R" and the
    ! position in files indicated by Where, if present, in place of "%w"
    ! or "%W". then call MLSMessage.
    use Lexer_Core, only: Get_Where, Where_t
    use MLSMessageModule, only: MLSMessage
    integer, parameter :: RK = kind(0.0d0)
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module
    character (len=*), intent(in) :: Message ! Line of text
    real(rk), intent(in) :: Datum
    type(where_t), intent(in), optional :: Where
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    include 'MoreMessageScalar.f9h'
  end subroutine MessageWithDouble

  ! -------------------------------------  MessageWithDoubleArray  -----
  subroutine MessageWithDoubleArray ( Severity, ModuleNameIn, Message, Datum, &
    & Where, Advance )
    ! Insert "Datum" into "Message" in place of "%r" or "%R" and the
    ! position in files indicated by Where, if present, in place of "%w"
    ! or "%W". then call MLSMessage.
    use Lexer_Core, only: Get_Where, Where_t
    use MLSMessageModule, only: MLSMessage
    integer, parameter :: RK = kind(0.0d0)
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module
    character (len=*), intent(in) :: Message ! Line of text
    real(rk), intent(in) :: Datum(:)
    type(where_t), intent(in), optional :: Where
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    include 'MoreMessageArray.f9h'
  end subroutine MessageWithDoubleArray

  ! -----------------------------------------  MessageWithInteger  -----
  subroutine MessageWithInteger ( Severity, ModuleNameIn, Message, Datum, &
    & Where, Advance )
    ! Insert "Datum" into "Message" in place of "%d" or "%D". Insert the
    ! string indexed by "Datum" into "Message" in place of "%s" or "%S". 
    ! Insert the line and column number represented by "Datum" in place of
    ! "%l" or "%L".  Insert the signal indexed by "Datum" in place of "%g" or
    ! "%G".  Insert the position in files indicated by Where, if present, in
    ! place of "%w" or "%W".  Then call MLSMessage.
    use Lexer_Core, only: Get_Where, Where_t
    use MLSMessageModule, only: MLSMessage
    use MLSSignals_m, only: GetSignalName
    use String_Table, only: Get_String, String_Length
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module
    character (len=*), intent(in) :: Message ! Line of text
    integer, intent(in) :: Datum
    type(where_t), intent(in), optional :: Where
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    character(512) :: Line ! Should be long enough
    integer :: I, L        ! Next positions in input, Line
    integer :: IERR        ! Status from Get_String
    integer :: N           ! Len_Trim(Message)
    logical :: OK          ! OK to insert

    n = len_trim(message)
    ok = .true.
    i = 1
    l = 1
    do while ( i <= n )
      line(l:l) = message(i:i)
      if ( i >= n ) exit
      if ( (message(i:i+1) == '%d' .or. message(i:i+1) == '%D') .and. ok ) then
        i = i + 2
        write ( line(l:), * ) datum
        line(l:) = adjustl(line(l:))
        l = len_trim(line) + 1
        ok = .false.
      else if ( (message(i:i+1) == '%g' .or. message(i:i+1) == '%G') .and. ok ) then
        i = i + 2
        call getSignalName ( datum, line(l:) )
        l = len_trim(line) + 1
        ok = .false.
      else if ( (message(i:i+1) == '%l' .or. message(i:i+1) == '%L') .and. ok ) then
        i = i + 2
        write ( line(l:), '("line ", i0, ", column ", i0)' ) &
          & datum/256, mod(datum,256)
        l = len_trim(line) + 1
        ok = .false.
      else if ( (message(i:i+1) == '%s' .or. message(i:i+1) == '%S') .and. ok ) then
        i = i + 2
        call get_string ( datum, line(l:), strip=.false., noerror=.true., ierr=ierr )
        if ( ierr == 0 ) then
          l = l + string_length ( datum )
        else
          l = len_trim(line) + 1
        end if
        ok = .false.
      else if ( (message(i:i+1) == '%w' .or. message(i:i+1) == '%W') .and. &
        & present(where) ) then
        i = i + 2
        call get_where ( where, line(l:) )
        l = len_trim(line) + 1
      else
        i = i + 1
        l = l + 1
      end if
    end do
    call MLSMessage ( severity, moduleNameIn, line(:l), advance )
  end subroutine MessageWithInteger

  ! ------------------------------------  MessageWithIntegerArray  -----
  subroutine MessageWithIntegerArray ( Severity, ModuleNameIn, Message, Datum, &
    & Where, Advance )
    ! Insert "Datum" into "Message" in place of "%d" or "%D". Insert the
    ! string indexed by "Datum" into "Message" in place of "%s" or "%S". 
    ! Insert the line and column number represented by "Datum" in place of
    ! "%l" or "%L".  Insert the signal indexed by "Datum" in place of "%g" or
    ! "%G".  Insert the position in files indicated by Where, if present, in
    ! place of "%w" or "%W".  Then call MLSMessage.
    use Lexer_Core, only: Get_Where, Where_t
    use MLSMessageModule, only: MLSMessage
    use MLSSignals_m, only: GetSignalName
    use String_Table, only: Get_String, String_Length
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module
    character (len=*), intent(in) :: Message ! Line of text
    integer, intent(in) :: Datum(:)
    type(where_t), intent(in), optional :: Where
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    character(512) :: Line ! Should be long enough
    integer :: I, L        ! Next positions in input, Line
    integer :: IERR        ! Status from Get_String
    integer :: N           ! Len_Trim(Message)
    integer :: ND          ! Next element of Datum

    n = len_trim(message)
    nd = 1
    i = 1
    l = 1
    do while ( i <= n )
      line(l:l) = message(i:i)
      if ( i >= n ) exit
      if ( (message(i:i+1) == '%d' .or. message(i:i+1) == '%D') .and. &
        & nd <= size(datum) ) then
        i = i + 2
        write ( line(l:), * ) datum(nd)
        line(l:) = adjustl(line(l:))
        l = len_trim(line) + 1
        nd = nd + 1
      else if ( (message(i:i+1) == '%g' .or. message(i:i+1) == '%G') .and. &
        & nd <= size(datum) ) then
        i = i + 2
        call getSignalName ( datum(nd), line(l:) )
        l = len_trim(line) + 1
        nd = nd + 1
      else if ( (message(i:i+1) == '%l' .or. message(i:i+1) == '%L') .and. &
        & nd <= size(datum) ) then
        i = i + 2
        write ( line(l:), '("line ", i0, ", column ", i0)' ) &
          & datum(nd)/256, mod(datum(nd),256)
        l = len_trim(line) + 1
        nd = nd + 1
      else if ( (message(i:i+1) == '%s' .or. message(i:i+1) == '%S') .and. &
        & nd <= size(datum) ) then
        i = i + 2
        call get_string ( datum(nd), line(l:), strip=.false., noerror=.true., ierr=ierr )
        if ( ierr == 0 ) then
          l = l + string_length ( datum(nd) )
        else
          l = len_trim(line) + 1
        end if
        nd = nd + 1
      else if ( (message(i:i+1) == '%w' .or. message(i:i+1) == '%W') .and. &
        & present(where) ) then
        i = i + 2
        call get_where ( where, line(l:) )
        l = len_trim(line) + 1
      else
        i = i + 1
        l = l + 1
      end if
    end do
    call MLSMessage ( severity, moduleNameIn, line(:l), advance )
  end subroutine MessageWithIntegerArray

  ! ------------------------------------------  MessageWithSingle  -----
  subroutine MessageWithSingle ( Severity, ModuleNameIn, Message, Datum, &
    & Where, Advance )
    ! Insert "Datum" into "Message" in place of "%r" or "%R" and the
    ! position in files indicated by Where, if present, in place of "%w"
    ! or "%W". then call MLSMessage.
    use Lexer_Core, only: Get_Where, Where_t
    use MLSMessageModule, only: MLSMessage
    integer, parameter :: RK = kind(0.0e0)
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module
    character (len=*), intent(in) :: Message ! Line of text
    real(rk), intent(in) :: Datum
    type(where_t), intent(in), optional :: Where
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    include 'MoreMessageScalar.f9h'
  end subroutine MessageWithSingle

  ! -------------------------------------  MessageWithSingleArray  -----
  subroutine MessageWithSingleArray ( Severity, ModuleNameIn, Message, Datum, &
    & Where, Advance )
    ! Insert "Datum" into "Message" in place of "%r" or "%R" and the
    ! position in files indicated by Where, if present, in place of "%w"
    ! or "%W". then call MLSMessage.
    use Lexer_Core, only: Get_Where, Where_t
    use MLSMessageModule, only: MLSMessage
    integer, parameter :: RK = kind(0.0e0)
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module
    character (len=*), intent(in) :: Message ! Line of text
    real(rk), intent(in) :: Datum(:)
    type(where_t), intent(in), optional :: Where
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    include 'MoreMessageArray.f9h'
  end subroutine MessageWithSingleArray

  ! -------------------------------------------  MessageWithWhere  -----
  subroutine MessageWithWhere ( Severity, ModuleNameIn, Message, Where, &
    & Advance )
    ! Insert "Where" into "Message" in place of "%w" or "%W". then call
    ! MLSMessage.
    use Lexer_Core, only: Get_Where, Where_t
    use MLSMessageModule, only: MLSMessage
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module
    character (len=*), intent(in) :: Message ! Line of text
    type(where_t), intent(in) :: Where
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'

    character(512) :: Line ! Should be long enough
    integer :: I, L        ! Next positions in input, Line
    integer :: N           ! Len_Trim(Message)

    n = len_trim(message)
    i = 1
    l = 1
    do
      line(l:l) = message(i:i)
      if ( i >= n ) exit
      if ( (message(i:i+1) == '%w' .or. message(i:i+1) == '%W') ) then
        i = i + 2
        call get_where ( where, line(l:) )
        l = len_trim(line) + 1
      else
        i = i + 1
        l = l + 1
      end if
    end do
    call MLSMessage ( severity, moduleNameIn, line(:l), advance )

  end subroutine MessageWithWhere

!=======================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MoreMessage.f90,v 2.9 2013/09/24 23:27:14 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MoreMessage

! $Log: MoreMessage.f90,v $
! Revision 2.9  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.8  2013/06/12 02:13:10  vsnyder
! Cruft removal
!
! Revision 2.7  2011/08/20 02:32:10  vsnyder
! Don't go off the end of Message string
!
! Revision 2.6  2011/08/10 01:47:17  vsnyder
! Correct some comments
!
! Revision 2.5  2011/07/22 18:29:51  vsnyder
! Make more robust to string errors
!
! Revision 2.4  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.3  2006/04/20 01:08:32  vsnyder
! Don't look past the end of the input
!
! Revision 2.2  2005/06/03 01:52:30  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! %g switch to dump signals.
!
! Revision 2.1  2005/05/02 22:55:13  vsnyder
! Initial commit
!
@


2.9
log
@Use Get_Where or Print_Source to start error messages
@
text
@d117 1
d139 1
a139 1
          l = l + string_length ( datum ) + 1
d216 1
a216 1
          l = l + string_length ( datum(nd) ) + 1
d316 1
a316 1
       "$Id: MoreMessage.f90,v 2.8 2013/06/12 02:13:10 vsnyder Exp $"
d326 3
@


2.8
log
@Cruft removal
@
text
@d23 1
d39 1
d46 5
a50 3
    & Advance )
    ! Insert "Datum" into "Message" in place of "%r" or "%R", then call
    ! MLSMessage.
d57 1
d66 5
a70 3
    & Advance )
    ! Insert "Datum" into "Message" in place of "%r" or "%R", then call
    ! MLSMessage.
d77 1
d86 8
a93 6
    & Advance )
    ! Insert "Datum" into "Message" in place of "%d" or "%D".
    ! Insert the string indexed by "Datum" into "Message" in place of
    ! "%s" or "%S".  Insert the line and column number represented by "Datum"
    ! in place of "%l" or "%L".  Insert the signal indexed by "Datum"
    ! in place of "%g" or "%G".  Then call MLSMessage.
d101 1
d138 1
a138 1
          l = l + string_length ( datum )
d140 1
a140 1
          l = len_trim(line)
d143 5
d158 8
a165 6
    & Advance )
    ! Insert "Datum" into "Message" in place of "%d" or "%D".
    ! Insert the string indexed by "Datum" into "Message" in place of
    ! "%s" or "%S".  Insert the line and column number represented by "Datum"
    ! in place of "%l" or "%L".  Insert the signal indexed by "Datum"
    ! in place of "%g" or "%G".  Then call MLSMessage.
d173 1
d215 1
a215 1
          l = l + string_length ( datum(nd) )
d217 1
a217 1
          l = len_trim(line)
d220 5
d235 5
a239 3
    & Advance )
    ! Insert "Datum" into "Message" in place of "%r" or "%R", then call
    ! MLSMessage.
d246 1
d255 5
a259 3
    & Advance )
    ! Insert "Datum" into "Message" in place of "%r" or "%R", then call
    ! MLSMessage.
d266 1
d273 38
d315 1
a315 1
       "$Id: MoreMessage.f90,v 2.7 2011/08/20 02:32:10 vsnyder Exp $"
d325 3
@


2.7
log
@Don't go off the end of Message string
@
text
@d86 1
a86 1
    use String_Table, only: Get_String, How_Many_Strings, String_Length
d247 1
a247 1
       "$Id: MoreMessage.f90,v 2.6 2011/08/10 01:47:17 vsnyder Exp $"
d257 3
@


2.6
log
@Correct some comments
@
text
@d104 1
a104 1
    do
a105 1
      if ( i >= n ) exit
d247 1
a247 1
       "$Id: MoreMessage.f90,v 2.5 2011/07/22 18:29:51 vsnyder Exp $"
d257 3
@


2.5
log
@Make more robust to string errors
@
text
@d81 3
a83 1
    ! "%s" or "%S".  Then call MLSMessage.
d146 3
a148 2
    ! "%s" or "%S".  Insert the line and cokumn number represented by "Datum"
    ! in place of "%l" or "%L".  Then call MLSMessage.
d248 1
a248 1
       "$Id: MoreMessage.f90,v 2.4 2009/06/23 18:25:42 pwagner Exp $"
d258 3
@


2.4
log
@Prevent Intel from optimizing ident string away
@
text
@d84 1
a84 1
    use String_Table, only: Get_String, String_Length
d94 1
d124 6
a129 2
        call get_string ( datum, line(l:), strip=.false. )
        l = l + string_length ( datum )
d158 1
d192 6
a197 2
        call get_string ( datum(nd), line(l:), strip=.false. )
        l = l + string_length ( datum(nd) )
d245 1
a245 1
       "$Id: read_apriori.f90 is it here $"
d255 3
@


2.3
log
@Don't look past the end of the input
@
text
@d232 1
d234 3
a236 5
    !---------------------------- RCS Ident Info -----------------------
    character (len=*), parameter :: IdParm = &
       "$Id: MoreMessage.f90,v 2.2 2005/06/03 01:52:30 vsnyder Exp $"
    character (len=len(idParm)) :: Id = idParm
    !-------------------------------------------------------------------
d238 1
d240 1
d245 3
@


2.2
log
@New copyright notice, move Id to not_used_here to avoid cascades,
%g switch to dump signals.
@
text
@d160 1
a160 1
    do
d235 1
a235 1
       "$Id: MoreMessage.f90,v 2.1 2005/05/02 22:55:13 vsnyder Exp $"
d244 4
@


2.1
log
@Initial commit
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
a24 2
  character (len=*), private, parameter :: IdParm = &
       "$Id: MLSMessageModule.f90,v 2.18 2005/03/15 23:47:52 pwagner Exp $"
d26 1
a26 1
       "$RCSfile: MLSMessageModule.f90,v $"
d83 1
d110 1
a110 1
      else if ( (message(i:i+1) == '%s' .or. message(i:i+1) == '%S') .and. ok ) then
d112 2
a113 2
        call get_string ( datum, line(l:), strip=.true. )
        l = l + string_length ( datum ) - 2
d121 5
d142 1
d170 1
a170 1
      else if ( (message(i:i+1) == '%s' .or. message(i:i+1) == '%S') .and. &
d173 2
a174 2
        call get_string ( datum(nd), line(l:), strip=.true. )
        l = l + string_length ( datum(nd) ) - 2
d183 6
d234 2
d243 4
a246 1
! $Log: $
@

