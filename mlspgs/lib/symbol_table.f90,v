head	2.17;
access;
symbols
	v5-02-NRT-19:2.17
	v6-00:2.17
	v5-02-NRT-18:2.17
	v5-02:2.17
	v5-01-NRT-17:2.17
	v5-01-NRT-16:2.17
	v5-01-NRT-15:2.17
	v5-01-NRT-14:2.17
	neuralnetworks-1-0:2.17.0.4
	cfm-single-freq-0-1:2.17.0.2
	v5-01:2.17
	v5-00:2.17
	v4-23-TA133:2.16.0.8
	mus-emls-1-70:2.16.0.6
	rel-1-0-englocks-work:2.16.0.4
	VUMLS1-00:2.16
	VPL1-00:2.16
	V4-22-NRT-08:2.16
	VAM1-00:2.16
	V4-21:2.16.0.2
	V4-13:2.16
	V4-12:2.16
	V4-11:2.16
	V4-10:2.16
	V3-43:2.13
	M4-00:2.13
	V3-41:2.13
	V3-40-PlusGM57:2.13.0.2
	V2-24-NRT-04:2.12
	V3-33:2.13
	V2-24:2.12
	V3-31:2.13
	V3-30-NRT-05:2.13
	cfm-01-00:2.13
	V3-30:2.13
	V3-20:2.13
	V3-10:2.13
	V2-23-NRT-02:2.12
	V2-23:2.12
	V2-22-NRT-01:2.12
	V2-22:2.12
	V2-21:2.12
	V2-20:2.12
	V2-11:2.12
	V2-10:2.12
	V2-00:2.12
	V1-51:2.11
	V1-50:2.11
	V1-45:2.10
	V1-44:2.10
	V1-43:2.10
	V1-42:2.9
	V1-41:2.9
	V1-32:2.10
	V1-40:2.9
	V1-31:2.9
	V1-30:2.9
	V1-13:2.6
	V1-12:2.6
	V1-11:2.6
	V1-10:2.6
	newfwm-feb03:2.6.0.2
	V1-04:2.4
	V1-03:2.4
	V1-02:2.4
	V1-00:2.4
	newfwm-sep01:2.4.0.2
	V0-7:2.4
	V0-5-Level2:2.2
	V0-5-SIPS:2.1;
locks; strict;
comment	@# @;


2.17
date	2019.07.31.20.02.36;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2013.12.12.23.38.21;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2013.12.12.01.59.06;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2013.10.02.01.31.41;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2009.06.23.18.25.44;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2004.10.30.00.19.56;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2004.01.22.00.43.12;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2003.05.14.06.44.24;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2003.05.14.01.42.25;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2003.05.12.02.05.06;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2002.10.08.00.09.14;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2002.08.21.20.37.48;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.06.08.18.00.35;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2001.06.06.17.33.03;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2001.04.21.00.37.30;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.11.18.33.24;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.17
log
@Make Class_Texts public and protected
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module SYMBOL_TABLE

  use MACHINE, only: IO_ERROR
  use STRING_TABLE, only: ALLOCATE_CHAR_TABLE, ALLOCATE_STRING_TABLE, &
                          DISPLAY_STRING, ADD_CHAR, HOW_MANY_STRINGS, &
                          LOOKUP_AND_INSERT, STRING_TABLE_SIZE
  use SYMBOL_TYPES, only: CASELESS_LOOK, FIRST_TYPE, INIT_TERMINAL, &
                          INIT_TYPE, LAST_TYPE, T_NULL, T_LAST_TERMINAL, &
                          TERM_TYPES
  use OUTPUT_M, only: OUTPUT
  use TOGGLES, only: TAB, TOGGLE

  implicit NONE
  private

  public :: ADD_TERMINAL, ALLOCATE_SYMBOL_TABLE, Class_Texts
  public :: DESTROY_SYMBOL_TABLE, DUMP_1_SYMBOL, DUMP_SYMBOL_CLASS
  public :: DUMP_SYMBOL_TABLE, DUMP_SYMBOL_TYPE, ENTER_TERMINAL
  public :: INIT_SYMBOL_TABLE, SET_SYMBOL, SYMBOL

  integer, save, protected :: CLASS_TEXTS(T_NULL: T_LAST_TERMINAL)
  integer, save, private, allocatable :: SYMBOLS(:)
  integer, save, private :: TYPE_TEXTS(FIRST_TYPE: LAST_TYPE) = 0

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: symbol_table.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains
  ! =========================================     ADD_TERMINAL     =====
  integer function ADD_TERMINAL ( TERMINAL, DEBUG, CASESENSITIVE )
  ! Add a terminal symbol with token index TERMINAL to the symbol table.
  ! Its text has already been entered into the string table by
  ! STRING_TABLE % ADD_CHAR.
    integer, intent(in) :: TERMINAL
    integer, optional, intent(in) :: DEBUG
    logical, optional, intent(in) :: CASESENSITIVE

    integer :: WHERE
    logical :: FOUND
    integer :: myDEBUG
    logical :: myCASESENSITIVE
    
    myDEBUG = 0
    if ( present(DEBUG) ) myDEBUG = DEBUG

    myCaseSensitive = .not. caseless_look(terminal)
    if ( present ( caseSensitive ) ) myCaseSensitive = caseSensitive

    call lookup_and_insert ( where, found, .not. myCaseSensitive, DEBUG )
    if ( where > size(symbols) ) then
      call increase_symbols ! String table was expanded
    end if
    if ( .not. found ) then; symbols(where) = terminal; end if
    if ( toggle(tab) .OR. myDEBUG > 0 ) then
      call output ( 'Looked up ' ); call output ( terminal )
      call output ( ' ' ); call display_string ( where )
      if ( caseless_look(terminal) ) then; call output ( ' caseless' ); end if
      if ( found ) then
        call output ( ' and found it at ' )
      else
        call output ( ' and inserted it at ' )
      end if
      call output ( where )
      call output ( symbols(where), before=' with symbol ', advance='yes' )
    end if
    add_terminal = where
  end function ADD_TERMINAL
  ! ================================     ALLOCATE_SYMBOL_TABLE     =====
  subroutine ALLOCATE_SYMBOL_TABLE ( N_CHARS, N_SYMBOLS, STATUS, DEBUG )
  ! Allocate character, string and symbol tables.
  ! Also does INIT_SYMBOL_TABLE
    integer, intent(in) :: N_CHARS      ! Size of character table
    integer, intent(in) :: N_SYMBOLS    ! Size of string and symbol tables
    integer, intent(out), optional :: STATUS      ! from ALLOCATE
    integer, intent(in), optional :: DEBUG

    integer :: STAT
    if ( allocated(symbols) ) then; deallocate ( symbols ); end if
    call allocate_char_table ( n_chars, status )
    if ( present(status) ) then
      if ( status /= 0 ) then; return; end if
    end if
    call allocate_string_table ( n_symbols, status )
    if ( present(status) ) then
      if ( status /= 0 ) then; return; end if
    end if
    allocate ( symbols(n_symbols), stat=stat )
    if ( present(status) ) then
      status = stat
      if ( status /= 0 ) then; return; end if
    end if
    if ( stat /= 0 ) then
      call io_error &
      ( 'SYMBOL_TABLE%ALLOCATE_SYMBOL_TABLE-E- Unable to allocate storage', &
      stat, '' )
      stop
    end if
    call init_symbol_table ( debug )
  end subroutine ALLOCATE_SYMBOL_TABLE
  ! =================================     DESTROY_SYMBOL_TABLE     =====
  subroutine DESTROY_SYMBOL_TABLE ( Status )
    integer, intent(out), optional :: Status ! From deallocate
    if ( present(status) ) then
      deallocate ( symbols, stat=status )
    else
      deallocate ( symbols )
    end if
  end subroutine DESTROY_SYMBOL_TABLE
  ! ========================================     DUMP_1_SYMBOL     =====
  subroutine DUMP_1_SYMBOL ( SYMBOL, ADVANCE, BEFORE )
  ! Print the symbol index, type and text.
    integer, intent(in) :: SYMBOL
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: BEFORE
    if ( present(before) ) call output ( before )
    call output ( symbol ); call output ( ': ' )
    call display_string ( type_texts(term_types(symbols(symbol))) )
    call output ( ' ' )
    call display_string ( symbol, advance=advance )
  end subroutine DUMP_1_SYMBOL
  ! ====================================     DUMP_SYMBOL_CLASS     =====
  subroutine DUMP_SYMBOL_CLASS ( SYM_CLASS, ADVANCE )
  ! Print the symbol text, given its class, e.g. T_IDENTIFIER
    integer, intent(in) :: SYM_CLASS
    character(len=*), intent(in), optional :: ADVANCE
    call display_string ( class_texts(sym_class), advance )
  end subroutine DUMP_SYMBOL_CLASS
  ! ====================================     DUMP_SYMBOL_TABLE     =====
  subroutine DUMP_SYMBOL_TABLE
  ! Print the entire symbol table, using DUMP_1_SYMBOL
    integer :: I
    do i = 1, how_many_strings()
      call dump_1_symbol ( i, advance='yes' )
    end do
  end subroutine DUMP_SYMBOL_TABLE
  ! =====================================     DUMP_SYMBOL_TYPE     =====
  subroutine DUMP_SYMBOL_TYPE ( SYMTYP, ADVANCE )
  ! Print the symbol type, e.g. <reserved_word>.
    integer, intent(in) :: SYMTYP
    character(len=*), intent(in), optional :: ADVANCE
    call display_string ( type_texts(term_types(symbols(symtyp))), &
                          advance )
  end subroutine DUMP_SYMBOL_TYPE
  ! =======================================     ENTER_TERMINAL     =====
  integer function ENTER_TERMINAL ( TEXT, TERMINAL, DEBUG, CASESENSITIVE )
  ! Put the text of a terminal symbol at the end of the character table,
  ! then enter it and its terminal index into the symbol table.
    character(len=*), intent(in) :: TEXT
    integer, intent(in) :: TERMINAL
    integer, optional, intent(in) :: DEBUG
    logical, optional, intent(in) :: CASESENSITIVE
    call add_char ( text )
    enter_terminal = add_terminal ( terminal, DEBUG=DEBUG, CASESENSITIVE=CASESENSITIVE )
  end function ENTER_TERMINAL
  ! ====================================     INIT_SYMBOL_TABLE     =====
  subroutine INIT_SYMBOL_TABLE ( DEBUG )
  ! Initialize the symbol table, the table of string indices of terminal
  ! names, and the table of terminal type names.
    integer, intent(in), optional :: DEBUG
    logical :: FOUND          ! Argument for LOOKUP_AND_INSERT
    integer :: I              ! Loop inductor
    integer :: WHERE          ! Where was the symbol inserted?
    do i = t_null, t_last_terminal
      call init_terminal ( i )
      where = add_terminal ( i, debug=debug )
      class_texts(i) = where
    end do
    ! This loop puts token types into the string table.
    ! They're only used for debugging output.
    do i = first_type, last_type
      call init_type ( i )
      call lookup_and_insert ( where, found, .false. )
      ! It's OK if it found one -- maybe it's a terminal text, too.
      if ( .not. found ) then; symbols(where) = t_null; end if
      type_texts(i) = where
    end do
    symbols(how_many_strings()+1:) = t_null
    if ( present(debug) ) then
      if ( debug > 0 ) call dump_symbol_table
    end if
  end subroutine INIT_SYMBOL_TABLE
  ! ===========================================     SET_SYMBOL     =====
  subroutine SET_SYMBOL ( STRING, CLASS )
  ! Set the class of the symbol at STRING to CLASS
    integer, intent(in) :: STRING
    integer, intent(in) :: CLASS
    if ( string > size(symbols) ) then
      call increase_symbols ! String table was expanded
    end if
    symbols(string) = class
  end subroutine SET_SYMBOL
  ! ===============================================     SYMBOL     =====
  integer function SYMBOL ( STRING )
  ! Return the symbol class of the STRING
    integer, intent(in) :: STRING
    symbol = symbols(string)
  end function SYMBOL

! =====     Private procedures    ======================================
  ! -------------------------------------     INCREASE_SYMBOLS     -----
  subroutine INCREASE_SYMBOLS ( STAT )
  ! Increase the upper bound for the symbol table to the upper bound of
  ! the string table.
    integer, optional, intent(out) :: STAT
    integer :: MY_STAT
    integer, allocatable :: OLD_SYMBOL(:)
    allocate ( old_symbol(size(symbols)), stat=my_stat )
    if ( my_stat /= 0 ) then
      if ( present(stat) ) then
        stat = my_stat
        return
      end if
      call io_error &
      ( 'SYMBOL_TABLE%INCREASE_SYMBOLS-E- Unable to allocate storage', &
      stat, '' )
      stop
    end if
    old_symbol = symbols
    deallocate ( symbols )
    allocate( symbols(string_table_size()), stat=my_stat )
    if ( my_stat /= 0 ) then
      if ( present(stat) ) then
        stat = my_stat
        return
      end if
      call io_error &
      ( 'SYMBOL_TABLE%INCREASE_SYMBOLS-E- Unable to allocate storage', &
      stat, '' )
      stop
    end if
    symbols(:size(old_symbol)) = old_symbol
    symbols(size(old_symbol)+1:) = t_null
    deallocate ( old_symbol )
  end subroutine INCREASE_SYMBOLS

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: symbol_table.f90,v 2.16 2013/12/12 23:38:21 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module SYMBOL_TABLE

! $Log: symbol_table.f90,v $
! Revision 2.16  2013/12/12 23:38:21  vsnyder
! Don't look at DEBUG in INIT_SYMBOL_TABLE without first making sure it's present
!
! Revision 2.15  2013/12/12 01:59:06  vsnyder
! Change type of debug from logical to integer, add more dumps
!
! Revision 2.14  2013/10/02 01:31:41  vsnyder
! Add Before argument to Dump_1_Symbol
!
! Revision 2.13  2009/06/23 18:25:44  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.12  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.11  2004/10/30 00:19:56  vsnyder
! Revised the CVS stuff
!
! Revision 2.10  2004/01/22 00:43:12  pwagner
! Fixed bug in passing args from enter_terminal to add_terminal
!
! Revision 2.9  2003/05/14 06:44:24  vsnyder
! Make sure new elements of 'symbols' are not undefined
!
! Revision 2.8  2003/05/14 01:42:25  vsnyder
! Add Dump_Symbol_Table
!
! Revision 2.7  2003/05/12 02:05:06  livesey
! Added optional case sensitivity to enter_terminal
!
! Revision 2.6  2002/10/08 00:09:14  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.5  2002/08/21 20:37:48  vsnyder
! Cosmetic changes
!
! Revision 2.4  2001/06/08 18:00:35  pwagner
! add_terminal diagnostic print depends on myDEBUG
!
! Revision 2.3  2001/06/06 17:33:03  pwagner
! DEBUG optional arg to (add, enter)_terminal
!
! Revision 2.2  2001/04/21 00:37:30  vsnyder
! Add 'Destroy_Symbol_Table' routine
!
! Revision 2.1  2000/10/11 18:33:24  vsnyder
! Move from lib/cf_parser to lib; insert copyright notice
!
! Revision 2.0  2000/09/05 17:41:51  dcuddy
! Change revision to 2.0
!
@


2.16
log
@Don't look at DEBUG in INIT_SYMBOL_TABLE without first making sure it's present
@
text
@d27 4
a30 4
  public :: ADD_TERMINAL, ALLOCATE_SYMBOL_TABLE, DESTROY_SYMBOL_TABLE
  public :: DUMP_1_SYMBOL, DUMP_SYMBOL_CLASS, DUMP_SYMBOL_TABLE
  public :: DUMP_SYMBOL_TYPE, ENTER_TERMINAL, INIT_SYMBOL_TABLE, SET_SYMBOL
  public :: SYMBOL
d32 1
a32 1
  integer, save, private :: CLASS_TEXTS(T_NULL: T_LAST_TERMINAL)
d253 1
a253 1
       "$Id: symbol_table.f90,v 2.15 2013/12/12 01:59:06 vsnyder Exp $"
d263 3
@


2.15
log
@Change type of debug from logical to integer, add more dumps
@
text
@d192 3
a194 1
    if ( debug > 0 ) call dump_symbol_table
d253 1
a253 1
       "$Id: symbol_table.f90,v 2.14 2013/10/02 01:31:41 vsnyder Exp $"
d263 3
@


2.14
log
@Add Before argument to Dump_1_Symbol
@
text
@d28 3
a30 2
  public :: DUMP_1_SYMBOL, DUMP_SYMBOL_CLASS, DUMP_SYMBOL_TYPE
  public :: ENTER_TERMINAL, INIT_SYMBOL_TABLE, SET_SYMBOL, SYMBOL
d49 1
a49 1
    logical, optional, intent(in) :: DEBUG
d54 1
a54 1
    logical :: myDEBUG
d57 1
a57 1
    myDEBUG = .false.
d67 2
a68 1
    if ( toggle(tab) .OR. myDEBUG ) then
d77 2
a78 1
      call output ( where, advance='yes' )
a79 1
    if ( .not. found ) then; symbols(where) = terminal; end if
a80 1
    return
d83 1
a83 1
  subroutine ALLOCATE_SYMBOL_TABLE ( N_CHARS, N_SYMBOLS, STATUS )
d89 1
d112 1
a112 2
    call init_symbol_table
    return
a133 1
    return
a140 1
    return
a156 1
    return
d164 1
a164 1
    logical, optional, intent(in) :: DEBUG
a167 1
    return
d170 1
a170 1
  subroutine INIT_SYMBOL_TABLE
d173 1
d179 1
a179 1
      where = add_terminal ( i )
d192 1
a208 1
    return
a245 1
    return
d251 1
a251 1
       "$Id: symbol_table.f90,v 2.13 2009/06/23 18:25:44 pwagner Exp $"
d261 3
@


2.13
log
@Prevent Intel from optimizing ident string away
@
text
@d37 1
a37 1
       "$RCSfile: $"
d123 1
a123 1
  subroutine DUMP_1_SYMBOL ( SYMBOL, ADVANCE )
d127 2
d254 1
a254 1
       "$Id: read_apriori.f90 is it here $"
d264 3
@


2.12
log
@Reworded Copyright statement, moved rcs id
@
text
@d249 1
a250 1
!---------------------------- RCS Ident Info -------------------------------
d252 2
a253 3
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d255 1
d257 1
d262 3
@


2.11
log
@Revised the CVS stuff
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d35 3
a37 6
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
    & "$Id: ForwardModelSupport.f90,v 2.100 2004/10/13 02:24:56 livesey Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName= &
    & "$RCSfile: ForwardModelSupport.f90,v $"
d250 5
d261 3
@


2.10
log
@Fixed bug in passing args from enter_terminal to add_terminal
@
text
@d28 5
a32 4
  character (len=256), private :: Id = &
       "$Id: symbol_table.f90,v 2.9 2003/05/14 06:44:24 vsnyder Exp $"
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: symbol_table.f90,v $"
d251 3
@


2.9
log
@Make sure new elements of 'symbols' are not undefined
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d29 1
a29 1
       "$Id: symbol_table.f90,v 2.8 2003/05/14 01:42:25 vsnyder Exp $"
d161 1
a161 1
    enter_terminal = add_terminal ( terminal, DEBUG, CASESENSITIVE )
d250 3
@


2.8
log
@Add Dump_Symbol_Table
@
text
@d29 1
a29 1
       "$Id: symbol_table.f90,v 2.7 2003/05/12 02:05:06 livesey Exp $"
d238 1
d250 3
@


2.7
log
@Added optional case sensitivity to enter_terminal
@
text
@d8 2
a9 2
                          DISPLAY_STRING, ADD_CHAR, LOOKUP_AND_INSERT, &
                          STRING_TABLE_SIZE
d29 1
a29 1
       "$Id: symbol_table.f90,v 2.6 2002/10/08 00:09:14 pwagner Exp $"
d127 1
a127 1
  ! =====================================     DUMP_SYMBOL_CLASS     =====
d135 8
d185 1
d249 3
@


2.6
log
@Added idents to survive zealous Lahey optimizer
@
text
@d29 1
a29 1
       "$Id: symbol_table.f90,v 2.5 2002/08/21 20:37:48 vsnyder Exp $"
d37 1
a37 1
  integer function ADD_TERMINAL ( TERMINAL, DEBUG )
d43 1
d48 1
d53 4
a56 1
    call lookup_and_insert ( where, found, caseless_look(terminal), DEBUG )
d145 1
a145 1
  integer function ENTER_TERMINAL ( TEXT, TERMINAL, DEBUG )
d151 1
d153 1
a153 1
    enter_terminal = add_terminal ( terminal, DEBUG )
d240 3
@


2.5
log
@Cosmetic changes
@
text
@d29 1
a29 1
       "$Id: symbol_table.f90,v 2.4 2001/06/08 18:00:35 pwagner Exp $"
d32 1
d227 4
d234 3
@


2.4
log
@add_terminal diagnostic print depends on myDEBUG
@
text
@d29 1
a29 1
       "$Id: symbol_table.f90,v 2.3 2001/06/06 17:33:03 pwagner Exp $"
d48 1
a48 1
    if(present(DEBUG)) myDEBUG = DEBUG
d54 1
a54 1
    if ( toggle(tab) .OR. myDEBUG) then
d229 3
@


2.3
log
@DEBUG optional arg to (add, enter)_terminal
@
text
@d29 1
a29 1
       "$Id: symbol_table.f90,v 2.2 2001/04/21 00:37:30 vsnyder Exp $"
d45 4
d54 1
a54 1
    if ( toggle(tab) .OR. present(DEBUG)) then
d229 3
@


2.2
log
@Add 'Destroy_Symbol_Table' routine
@
text
@d29 1
a29 1
       "$Id: symbol_table.f90,v 2.1 2000/10/11 18:33:24 vsnyder Exp $"
d36 1
a36 1
  integer function ADD_TERMINAL ( TERMINAL )
d41 1
d46 1
a46 1
    call lookup_and_insert ( where, found, caseless_look(terminal) )
d50 1
a50 1
    if ( toggle(tab) ) then
d135 1
a135 1
  integer function ENTER_TERMINAL ( TEXT, TERMINAL )
d140 1
d142 1
a142 1
    enter_terminal = add_terminal ( terminal )
d225 3
@


2.1
log
@Move from lib/cf_parser to lib; insert copyright notice
@
text
@d19 2
a20 2
  public :: ADD_TERMINAL, ALLOCATE_SYMBOL_TABLE, DUMP_1_SYMBOL
  public :: DUMP_SYMBOL_CLASS, DUMP_SYMBOL_TYPE
d29 1
a29 1
       "$Id: symbol_table.f90,v 2.0 2000/09/05 17:41:51 dcuddy Exp $"
d64 1
a64 1
  ! =================================     ALLOCATE_SYMBOL_TABLE     =====
d96 9
d223 3
@

