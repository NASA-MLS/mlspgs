head	2.1;
access;
symbols
	v5-02-NRT-19:2.1
	v6-00:2.1
	v5-02-NRT-18:2.1
	v5-01-NRT-17:2.1
	v5-01-NRT-16:2.1;
locks; strict;
comment	@# @;


2.1
date	2022.03.24.21.44.38;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.1
log
@First commit
@
text
@! Copyright 2022, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module MLSGroups

! Various abstract operations on Finite Groups

! Note:
! A group in mathematics consists of elements and a group operation
! They satisfy the following axioms
! (where we denote elements as a, b, c, .. and the group operation
! as a "product", e.g. "a b" is the product of a "multiplied" by b)

! (i) a (b c) = (a b) c
! (ii) there is a unique element e such that for any a
!     e a = a e = a
! (ii) For any a there is a unique inverse z such tha
!      a z = z a = e

! We represent Groups two ways
! (1)
! For groups whose elements are permutations it is customary to write an
! element in a form like the following
!     1 2 3 .. n
!    (          )
!     3 2 1 .. k

! where in the case shown above the permutation acts on a set of objects
! {x[i], i=1 .. n} by sending
! x[1] -> x[3]
! x[2] -> x[2]
! x[3] -> x[1]
! . . .
! x[n] -> x[k]

! Since the first row is always 1 .. n,
! the second row alone is sufficient to uniquely identify the permutation.
! So we represent each permutation by a rank-1 array of integers

! (2)
! For abstract groups whose only given structure is their mutual products
! if we let the elements be denoted a[i], it suffices to define the rank-2
! array of integers
!   p[i][k]
! where
!   p[i][k] = a[i] a[k]

! Then each element of the group may be uniquely represented by its index.

! It might be convenient to always sort a[i] so that the identity
! element is first, but we don't enforce that.

! We don't traffic in checking that the group axioms are satisfied
! or that the inputs are legal. Nor do we traffic in subgroups,
! quotient groups, homomorphisms, or anything else. If you want any of that
! you can add to this module or start a new one yourself.

  use MLSFinds, only: FindFirst

  implicit none
  private

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (subroutines and functions)
! Abelian       Does a*b = b*a for all a, b?
! AreEqual      Are the two elements equal
! Commute       Does a*b = b*a?
! Cyclic        Generate the (sub)group {a, a*a, a^3, .., e}
! Identity      Returns the identity element
! Inverse       Returns the inverse element
! === (end of toc) ===

! === (start of api) ===
! log Abelian  (  P(:,:) )
! log AreEqual (  a, b )
! log Commute (  a, b )
! group_element(:) Cyclic (  a, P )
! group_element Identity (  a, P )
! group_element Inverse (  a, P )
! === (end of api) ===

  public :: Abelian, AreEqual, Cyclic, Commute, Identity, Inverse, Product

  interface AreEqual
    module procedure AreEqual_Perm, AreEqual_Abs
  end interface

  interface Commute
    module procedure Commute_Perm, Commute_Abs
  end interface

  interface Identity
    module procedure Identity_Perm, Identity_Abs
  end interface

  interface Cyclic
    module procedure Cyclic_Perm, Cyclic_Abs
  end interface

  interface Inverse
    module procedure Inverse_Perm, Inverse_Abs
  end interface

  interface Product
    module procedure Product_Perm, Product_Abs
  end interface

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSGroups.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

contains ! =====     Public Procedures     =============================

  ! --------------------------------------------------  Abelian  -----
  ! This family of functions returns TRUE if all Elements A and B commute
  logical function Abelian ( P )
    integer, intent(in) :: P(:,:)
    integer             :: E
    Abelian = all ( P == transpose(P) )
  end function Abelian

  ! --------------------------------------------------  AreEqual  -----
  ! This family of functions returns TRUE if the Elements A and B are the same
  logical function AreEqual_Perm ( A, B )
    integer, intent(in) :: A(:), B(:)
    AreEqual_Perm = all ( A == B )
  end function AreEqual_Perm

  logical function AreEqual_Abs ( A, B )
    integer, intent(in) :: A, B
    AreEqual_Abs = ( A == B )
  end function AreEqual_Abs

  ! --------------------------------------------------  Commute  -----
  ! This family of functions returns TRUE if the Elements A and B are the same
  logical function Commute_Perm ( A, B )
    integer, intent(in) :: A(:), B(:)
    Commute_Perm = AreEqual ( Product( a, b ), Product( b, a ) )
  end function Commute_Perm

  logical function Commute_Abs ( A, B, P )
    integer, intent(in) :: A, B
    integer, intent(in) :: P(:,:)
    Commute_Abs = AreEqual ( Product( a, b, P ), Product( b, a, P ) )
  end function Commute_Abs

  ! --------------------------------------------------  Cyclic  -----
  ! This family of functions returns the Cyclic (sub)group 
  ! generated by the element a
  function Cyclic_Perm ( A, m ) result ( G )
    integer, intent(in) :: A(:)
    integer             :: G(size(A), size(A))
    !
    integer             :: E(size(A))
    integer             :: m
    m = 1
    e = Identity( a )
    g(:,1) = a
    ! Now loop forever until we either
    ! (1) Recover the identity element e; or
    ! (2) Blow past the array limit for g
    do
      if ( AreEqual( g(:,m), e ) ) return
      m = m + 1
      if ( m > size(A) ) then
        m = 0
        return
      endif
      g(:,m) = Product( a, g(:,m-1) )
    enddo
  end function Cyclic_Perm

  function Cyclic_Abs ( a, P, m ) result ( G )
    integer, intent(in) :: P(:,:)
    integer             :: G(size(P,1))
    integer             :: A
    !
    integer             :: E
    integer             :: m
    m = 1
    e = Identity( P )
    g(1) = a
    ! Now loop forever until we either
    ! (1) Recover the identity element e; or
    ! (2) Blow past the array limit for g
    do
      if ( AreEqual( g(m), e ) ) return
      m = m + 1
      if ( m > size(P,1) ) then
        m = 0
        return
      endif
      g(m) = Product( a, g(m-1), P )
    enddo
  end function Cyclic_Abs

  ! --------------------------------------------------  Identity  -----
  ! This family of functions returns the identity element e
  function Identity_Perm ( A ) result ( E )
    integer, intent(in) :: A(:)
    integer             :: E(size(A))
    !
    integer             :: i
    do i=1, size(a)
      e(i) = i
    enddo
  end function Identity_Perm

  function Identity_Abs ( P ) result ( E )
    ! e is the index of the identity element among a[i]
    ! We'll search for a row of p that is 
    ! ( 1 2 3 4 .. n )
    integer, intent(in) :: P(:,:)
    integer             :: E
    !
    logical             :: C(size(P,1))
    integer             :: i, ident(size(P,1))
    do i=1, size(P,1)
      ident(i) = i
    enddo
    c = .false.
    do i=1, size(P,1)
      c(i) = all ( P(i,:) == ident )
    enddo
    e = FindFirst ( c )
  end function Identity_Abs

  ! --------------------------------------------------  Inverse  -----
  ! This family of functions returns the inverse element of a
  function Inverse_Perm ( A ) result ( inv )
    integer, intent(in) :: A(:)
    integer             :: inv(size(A))
    !
    ! Our plan is to return an array such that
    ! inv[a[i]] = i
    ! which we get by inverting the identity
    ! a[i] = a[i]
    integer             :: i
    do i=1, size(A)
      inv(a(i)) = i
    enddo
  end function Inverse_Perm

  function Inverse_Abs ( A, P ) result( inv )
    ! Our plan is to 
    ! (1) Find the identity element e
    ! (2) Find inv such that P(a,inv) = e
    integer, intent(in) :: A, P(:,:)
    integer             :: inv
    !
    integer             :: e
    e = Identity ( p )
    inv = FindFirst ( p(a,:) == e )
  end function Inverse_Abs

  ! --------------------------------------------------  Product  -----
  ! This family of functions returns the product of A and B
  function Product_Perm ( A, B ) result ( C )
    ! Our plan is to compose the permutations a and b
    integer, intent(in) :: A(:), B(:)
    integer             :: C(size(A))
    !
    integer             :: i
    do i=1, size(A)
      c(i) = a(b(i))
    enddo
  end function Product_Perm

  function Product_Abs ( A, B, P ) result ( c )
    ! Our plan is to return p(a,b)
    ! based on the definition of p as 
    ! the product matrix of the group elements a[i]
    integer, intent(in) :: A, B, P(:,:)
    integer             :: C
    c = p(a,b)
  end function Product_Abs

! =====     Private Procedures     =====================================

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSGroups.f90,v 2.40 2019/11/22 00:35:11 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MLSGroups

! $Log: MLSGroups.f90,v $
@
