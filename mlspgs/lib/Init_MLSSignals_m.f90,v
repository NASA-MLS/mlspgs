head	2.36;
access;
symbols
	v5-02-NRT-19:2.36
	v6-00:2.36
	v5-02-NRT-18:2.36
	v5-02:2.35
	v5-01-NRT-17:2.36
	v5-01-NRT-16:2.36
	v5-01-NRT-15:2.36
	v5-01-NRT-14:2.36
	neuralnetworks-1-0:2.36.0.4
	cfm-single-freq-0-1:2.36.0.2
	v5-01:2.35
	v5-00:2.35
	v4-23-TA133:2.35.0.6
	mus-emls-1-70:2.35.0.4
	rel-1-0-englocks-work:2.35.0.2
	VUMLS1-00:2.33
	VPL1-00:2.32
	V4-22-NRT-08:2.32
	VAM1-00:2.32
	V4-21:2.32.0.2
	V4-13:2.32
	V4-12:2.32
	V4-11:2.32
	V4-10:2.32
	V3-43:2.27
	M4-00:2.28
	V3-41:2.27
	V3-40-PlusGM57:2.27.0.2
	V2-24-NRT-04:2.26
	V3-33:2.28
	V2-24:2.26
	V3-31:2.28
	V3-30-NRT-05:2.27
	cfm-01-00:2.27
	V3-30:2.27
	V3-20:2.27
	V3-10:2.27
	V2-23-NRT-02:2.26
	V2-23:2.26
	V2-22-NRT-01:2.26
	V2-22:2.26
	V2-21:2.26
	V2-20:2.26
	V2-11:2.26
	V2-10:2.26
	V2-00:2.26
	V1-51:2.25
	V1-50:2.25
	V1-45:2.25
	V1-44:2.25
	V1-43:2.24
	V1-42:2.23
	V1-41:2.23
	V1-32:2.23
	V1-40:2.23
	V1-31:2.23
	V1-30:2.23
	V1-13:2.18
	V1-12:2.18
	V1-11:2.18
	V1-10:2.18
	newfwm-feb03:2.18.0.2
	V1-04:2.15
	V1-03:2.15
	V1-02:2.15
	V1-00:2.15
	newfwm-sep01:2.15.0.2
	V0-7:2.15
	V0-5-Level2:2.14
	V0-5-SIPS:2.12;
locks; strict;
comment	@# @;


2.36
date	2020.07.05.20.20.47;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2018.02.27.00.49.43;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2017.09.15.15.44.18;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2016.12.15.18.23.27;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2014.04.22.00.07.48;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2013.11.06.01.46.30;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2013.09.04.00.00.59;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2013.08.23.23.23.11;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2011.01.29.00.46.42;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2005.06.22.17.25.49;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2004.05.29.02.42.59;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2004.01.16.21.37.23;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2003.08.16.01.14.03;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2003.07.23.18.02.30;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2003.07.23.07.17.46;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2003.07.18.20.23.26;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2003.05.16.02.44.18;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2002.10.08.00.09.10;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2002.05.14.22.31.47;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2002.05.03.22.38.55;	author livesey;	state Exp;
branches
	2.16.2.1;
next	2.15;

2.15
date	2001.06.07.21.59.41;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2001.04.26.02.33.03;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.23.20.57.42;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.11.20.19.27;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.11.18.31.04;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.10.18.51.25;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.04.10.17.59.53;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.04.04.17.56.42;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.04.03.19.09.12;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.28.19.50.43;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.16.02.00.40;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.16.01.02.32;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.16.01.01.18;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2001.03.16.01.00.05;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2001.03.14.02.05.52;	author vsnyder;	state Exp;
branches;
next	;

2.16.2.1
date	2002.05.24.21.29.40;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.36
log
@Remove frequency field because it's not used
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Init_MLSSignals_m

  use intrinsic, only: add_ident, begin, d, f, field_first, g, l, &
    & last_intrinsic_lit, last_intrinsic_spec, n, nadp, ndp, np, nr, p, s, &
    & spec_first, t, t_boolean, t_numeric, t_numeric_range, t_polarization, &
    & t_string, z

  use intrinsic, only: data_type_indices, du, field_indices, func_indices, &
    & lit_indices, parm_indices, phyq_dimensionless, phyq_frequency, &
    & section_indices, spec_indices

  use intrinsic, only: l_asmls, l_emls, l_umls, l_xptl1
  use molecules, only: init_molecules, last_molecule, last_molecule_type
  implicit none

  public

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Init_MLSSignals_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! Fields used in signal specifications:
  integer, parameter :: F_Aura              = field_First
  integer, parameter :: F_band              = f_Aura + 1
  integer, parameter :: F_centerFrequency   = f_band + 1
  integer, parameter :: F_channel           = f_centerFrequency + 1
  integer, parameter :: F_channels          = f_channel + 1
  integer, parameter :: F_dacs              = f_channels + 1
  integer, parameter :: F_deferred          = f_dacs + 1
  integer, parameter :: F_direction         = f_deferred + 1
  integer, parameter :: F_first             = f_direction + 1
  integer, parameter :: F_instrument        = f_first + 1
  integer, parameter :: F_last              = f_instrument + 1
  integer, parameter :: F_lo                = f_last + 1
  integer, parameter :: F_module            = f_lo + 1
  integer, parameter :: F_polarization      = f_module + 1
  integer, parameter :: F_radiometer        = f_polarization + 1
  integer, parameter :: F_singleSideband    = f_radiometer + 1
  integer, parameter :: F_spacecraft        = f_singleSideband + 1
  integer, parameter :: F_spectrometer      = f_spacecraft + 1
  integer, parameter :: F_spectrometerType  = f_spectrometer + 1
  integer, parameter :: F_start             = f_spectrometerType + 1
  integer, parameter :: F_step              = f_start + 1
  integer, parameter :: F_suffix            = f_step + 1
  integer, parameter :: F_supportedModule   = f_suffix + 1
  integer, parameter :: F_switch            = f_supportedModule + 1
  integer, parameter :: F_width             = f_switch + 1
  integer, parameter :: Last_Signal_Field   = f_width

  ! Literals used in signal specifications:
  integer, parameter :: Last_Signal_Lit     = last_molecule

  ! Enumeration types:
  integer, parameter :: T_InstrumentType    = last_molecule_type+1
  integer, parameter :: Last_signal_type    = t_instrumenttype

  ! Signal specifications:
  integer, parameter :: S_band              = t_instrumenttype + 1
  integer, parameter :: S_module            = s_band + 1
  integer, parameter :: S_radiometer        = s_module + 1
  integer, parameter :: S_signal            = s_radiometer + 1
  integer, parameter :: S_spectrometerType  = s_signal + 1
  integer, parameter :: Last_Signal_Spec    = s_spectrometerType

  ! The MLSSignals section is NOT defined here, because it appears
  ! in the section ordering requirements array in init_tables_module.

contains

  ! --------------------------------------------  Init_MLSSignals  -----
  subroutine Init_MLSSignals ( N_DATA_TYPE_INDICES, N_FIELD_INDICES, &
    & N_LIT_INDICES, FIRST_PARM_INDEX, LAST_PARM_INDEX, N_SECTION_INDICES, &
    & N_SPEC_INDICES )

    ! "use Tree" really belongs in make_tree, but "make depends" can't see it there
    ! (because of the "include"):
    use TREE, only:
    use TREE_TYPES, only: N_FIELD_SPEC, N_FIELD_TYPE, N_SPEC_DEF, N_DT_DEF

    integer, intent(in) :: N_DATA_TYPE_INDICES
    integer, intent(in) :: N_FIELD_INDICES
    integer, intent(in) :: N_LIT_INDICES
    integer, intent(in) :: FIRST_PARM_INDEX, LAST_PARM_INDEX
    integer, intent(in) :: N_SECTION_INDICES
    integer, intent(in) :: N_SPEC_INDICES

    call init_molecules ( n_data_type_indices, n_field_indices, n_lit_indices, &
      & first_parm_index, last_parm_index, n_section_indices, n_spec_indices )

    ! Put field names into the symbol table
    field_indices(f_Aura) =                add_ident ( 'Aura' )
    field_indices(f_band) =                add_ident ( 'band' )
    field_indices(f_centerFrequency) =     add_ident ( 'centerFrequency' )
    field_indices(f_channel) =             add_ident ( 'channel' )
    field_indices(f_channels) =            add_ident ( 'channels' )
    field_indices(f_dacs) =                add_ident ( 'dacs' )
    field_indices(f_deferred) =            add_ident ( 'deferred' )
    field_indices(f_direction) =           add_ident ( 'direction' )
    field_indices(f_first) =               add_ident ( 'first' )
    field_indices(f_instrument) =          add_ident ( 'instrument' )
    field_indices(f_last) =                add_ident ( 'last' )
    field_indices(f_lo) =                  add_ident ( 'lo' )
    field_indices(f_module) =              add_ident ( 'module' )
    field_indices(f_polarization) =        add_ident ( 'polarization' )
    field_indices(f_radiometer) =          add_ident ( 'radiometer' )
    field_indices(f_singleSideband) =      add_ident ( 'singleSideband' )
    field_indices(f_spacecraft) =          add_ident ( 'spacecraft' )
    field_indices(f_spectrometer) =        add_ident ( 'spectrometer' )
    field_indices(f_spectrometerType) =    add_ident ( 'spectrometerType' )
    field_indices(f_start) =               add_ident ( 'start' )
    field_indices(f_step) =                add_ident ( 'step' )
    field_indices(f_suffix) =              add_ident ( 'suffix' )
    field_indices(f_supportedModule) =     add_ident ( 'supportedModule' )
    field_indices(f_switch) =              add_ident ( 'switch' )
    field_indices(f_width) =               add_ident ( 'width' )

    ! Put enumeration type names into the symbol table
    data_type_indices(t_instrumenttype) =  add_ident ( 'instrumenttype' )
    ! Put spec names into the symbol table
    spec_indices(s_band) =                 add_ident ( 'band' )
    spec_indices(s_module) =               add_ident ( 'module' )
    spec_indices(s_radiometer) =           add_ident ( 'radiometer' )
    spec_indices(s_signal) =               add_ident ( 'signal' )
    spec_indices(s_spectrometerType) =     add_ident ( 'spectrometerType' )

    ! Definitions are represented by trees.  The notation in the comments
    ! for the trees is < root first_son ... last_son >.  This is sometimes
    ! called "Cambridge Polish Notation."  It was developed to represent
    ! LISP by McCarthy et. al. at MIT (in Cambridge, MA).

    ! Notice that in the argument for make_tree, the tree node id is at
    ! the END of the subtree, while in Cambridge Polish Notation it is at
    ! the BEGINNING of the subtree!

    ! Put the definition trees into the tree space before the parser runs.
    ! After the parsing is done, they're automatically "glued in" to the
    ! "left" of the trees that represent the input.  The tree-walker
    ! stumbles upon them in its normal course of operation, never really
    ! realizing they're special (because by then they're not).

    ! Define the relations between specs and fields, and the field types
    ! or names of other specifications allowed.  These are represented by
    ! trees of the form
    !  < n_spec_def s_spec_name
    !               < n_field_type f_field_name t_type ... t_type > ...
    !               < n_field_spec f_field_name s_spec ... s_spec > ...
    !               < n_dot f_field_name s_spec f_field_name ... >
    !  >
    ! The n_field_type, n_field_spec, and n_dot subtrees may appear in
    ! any quantity or order.
    ! The n_field_type subtree indicates the types allowed for a field.
    ! The n_field_spec subtree indicates the specifications whose names
    ! are allowed to appear for a field.
    ! The n_dot subtree indicates that the field given by the first
    ! f_field_name is required to be of the form spec_name.field_name,
    ! where spec_name is required to be a label of a specification of the
    ! type given by the s_spec son, and field_name is required to be
    ! present in the field given by the last f_field_name, which is
    ! required to be in a specification named by the next-to-last
    ! f_field_name ... of the specification named by the spec_name.

    call make_tree ( (/ &
             begin, t+t_instrumentType, &
             l+l_asmls, l+l_emls, l+l_umls, l+l_xptl1, n+n_dt_def /) )
    call make_tree ( (/ &
      begin, s+s_module, &          ! Must be after module
             begin, f+f_Aura, t+t_boolean, n+n_field_type, &
             begin, f+f_instrument, t+t_instrumentType, n+n_field_type, &
             begin, f+f_spacecraft, t+t_boolean, n+n_field_type, &
             begin, f+f_supportedModule, s+s_module, n+n_field_spec, &
             np+n_spec_def, &
      begin, s+s_radiometer, &          ! Must be after module
             begin, f+f_lo, t+t_numeric, nr+n_field_type+du*PHYQ_FREQUENCY, &
             begin, f+f_suffix, t+t_string, nr+n_field_type, &
             begin, f+f_module, s+s_module, n+n_field_spec, &
             begin, f+f_polarization, t+t_polarization, n+n_field_type, &
             begin, f+f_singleSideband, t+t_numeric, nr+n_field_type+du*PHYQ_DIMENSIONLESS, &
             ndp+n_spec_def, &
      begin, s+s_spectrometerType, &
             begin, f+f_channels, t+t_numeric_range, n+n_field_type+du*PHYQ_FREQUENCY, &
             begin, f+f_dacs, t+t_boolean, n+n_field_type, &
             begin, f+f_deferred, t+t_boolean, n+n_field_type, &
             begin, f+f_first, t+t_numeric, n+n_field_type+du*PHYQ_DIMENSIONLESS, &
             begin, f+f_last, t+t_numeric, n+n_field_type+du*PHYQ_DIMENSIONLESS, &
             begin, f+f_start, t+t_numeric, n+n_field_type+du*PHYQ_FREQUENCY, &
             begin, f+f_step, t+t_numeric, n+n_field_type+du*PHYQ_FREQUENCY, &
             begin, f+f_width, t+t_numeric, n+n_field_type+du*PHYQ_FREQUENCY, &
             ndp+n_spec_def, &
      begin, s+s_band, &                ! Must be after radiometer and spectrometerType
             begin, f+f_suffix, t+t_string, n+n_field_type, &
             begin, f+f_spectrometerType, s+s_spectrometerType, nr+n_field_spec, &
             begin, f+f_radiometer, s+s_radiometer, n+n_field_spec, &
             begin, f+f_centerfrequency, t+t_numeric, n+n_field_type+du*PHYQ_FREQUENCY, &
             ndp+n_spec_def, &
      begin, s+s_signal, &              ! Must be after band
             begin, f+f_band, s+s_band, nr+n_field_spec, &
             begin, f+f_channels, t+t_numeric_range, n+n_field_type+du*PHYQ_FREQUENCY, &
             begin, f+f_direction, t+t_numeric, nr+n_field_type+du*PHYQ_DIMENSIONLESS, &
             begin, f+f_radiometer, s+s_radiometer, n+n_field_spec+du*PHYQ_DIMENSIONLESS, &
             begin, f+f_module, s+s_module, n+n_field_spec, &
             begin, f+f_spectrometer, t+t_numeric, nr+n_field_type+du*PHYQ_DIMENSIONLESS, &
             begin, f+f_switch, t+t_numeric, nr+n_field_type+du*PHYQ_DIMENSIONLESS, &
             ndp+n_spec_def /) )

  contains
    ! --------------------------------------------------  MAKE_TREE  -----
    include "make_tree.f9h"

  end subroutine Init_MLSSignals

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Init_MLSSignals_m.f90,v 2.35 2018/02/27 00:49:43 livesey Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Init_MLSSignals_m

! $Log: Init_MLSSignals_m.f90,v $
! Revision 2.35  2018/02/27 00:49:43  livesey
! Added the supportedModule functionality to support ASMLS
!
! Revision 2.34  2017/09/15 15:44:18  livesey
! Updated to allow modules to be defferred until signal definition
!
! Revision 2.33  2016/12/15 18:23:27  pwagner
! Added asmls instrument
!
! Revision 2.32  2014/04/22 00:07:48  vsnyder
! Put InstrumentType's index in the range of type indices
!
! Revision 2.31  2013/11/06 01:46:30  pwagner
! May read instrument field of module; e.g. emls
!
! Revision 2.30  2013/09/04 00:00:59  pwagner
! Comments preceding use TREE made more uniform across modules
!
! Revision 2.29  2013/08/23 23:23:11  pwagner
! Added Aura field to Module spec
!
! Revision 2.28  2011/01/29 00:46:42  vsnyder
! Add units checking
!
! Revision 2.27  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.26  2005/06/22 17:25:49  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.25  2004/05/29 02:42:59  vsnyder
! Rearrange function definition stuff
!
! Revision 2.24  2004/01/16 21:37:23  livesey
! Added the ability to defer the connection between bands and radiometers
! until you define the signal.  This is to support some SMLS related
! research work.
!
! Revision 2.23  2003/08/16 01:14:03  vsnyder
! Add optional 'polarization' field to 'radiometer' spec
!
! Revision 2.22  2003/07/23 18:02:30  livesey
! Reverted DACS back to lower case
!
! Revision 2.21  2003/07/23 07:17:46  livesey
! Capitalized DACS
!
! Revision 2.20  2003/07/18 20:23:26  livesey
! Added DACS flags etc.
!
! Revision 2.19  2003/05/16 02:44:18  vsnyder
! Removed USE's for unreferenced symbols
!
! Revision 2.18  2002/10/08 00:09:10  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.17  2002/05/14 22:31:47  livesey
! Added singleSideband
!
! Revision 2.16  2002/05/03 22:38:55  livesey
! Added direction field
!
! Revision 2.15  2001/06/07 21:59:41  pwagner
! Added Copyright statement
!
! Revision 2.14  2001/04/26 02:33:03  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.13  2001/04/23 20:57:42  vsnyder
! Move the first spec (time) to 'intrinsic'
!
! Revision 2.12  2001/04/11 20:19:27  vsnyder
! Undo changes to 'deferred'
!
! Revision 2.11  2001/04/11 18:31:04  vsnyder
! Change 'deferred' from boolean to numeric
!
! Revision 2.10  2001/04/10 18:51:25  vsnyder
! Finish removing sideband stuff
!
! Revision 2.9  2001/04/10 17:59:53  vsnyder
! Remove sideband field from signal
!
! Revision 2.8  2001/04/04 17:56:42  vsnyder
! Insert "USE TREE" because "make depends" can't see the one in "make_tree"
! (because of the "include").
!
! Revision 2.7  2001/04/03 19:09:12  vsnyder
! Change the order of initialization to intrinsic, Molecules, MLSSignals.
! Use the revised make_tree.f9h, which requires revision of init...
! calling sequences.
!
! Revision 2.6  2001/03/28 19:50:43  vsnyder
! Remove frequencies and widths fields
!
! Revision 2.5  2001/03/16 02:00:40  vsnyder
! Add support for literals to Make_Tree (duh!)
!
! Revision 2.4  2001/03/16 01:02:32  vsnyder
! ... Including the Log at the end.
!
@


2.35
log
@Added the supportedModule functionality to support ASMLS
@
text
@d45 1
a45 2
  integer, parameter :: F_frequency         = f_first + 1
  integer, parameter :: F_instrument        = f_frequency + 1
a112 1
    field_indices(f_frequency) =           add_ident ( 'frequency' )
d227 1
a227 1
       "$Id: Init_MLSSignals_m.f90,v 2.34 2017/09/15 15:44:18 livesey Exp $"
d237 3
@


2.34
log
@Updated to allow modules to be defferred until signal definition
@
text
@d59 2
a60 1
  integer, parameter :: F_switch            = f_suffix + 1
d128 1
d185 1
d229 1
a229 1
       "$Id: Init_MLSSignals_m.f90,v 2.33 2016/12/15 18:23:27 pwagner Exp $"
d239 3
@


2.33
log
@Added asmls instrument
@
text
@d187 1
a187 1
             begin, f+f_module, s+s_module, nr+n_field_spec, &
d212 1
d226 1
a226 1
       "$Id: Init_MLSSignals_m.f90,v 2.32 2014/04/22 00:07:48 vsnyder Exp $"
d236 3
@


2.32
log
@Put InstrumentType's index in the range of type indices
@
text
@d14 12
a25 12
  use INTRINSIC, only: ADD_IDENT, BEGIN, D, F, FIELD_FIRST, G, L, &
    & LAST_INTRINSIC_LIT, LAST_INTRINSIC_SPEC, N, NADP, NDP, NP, NR, P, S, &
    & SPEC_FIRST, T, T_BOOLEAN, T_NUMERIC, T_NUMERIC_RANGE, T_POLARIZATION, &
    & T_STRING, Z

  use INTRINSIC, only: DATA_TYPE_INDICES, DU, FIELD_INDICES, FUNC_INDICES, &
    & LIT_INDICES, PARM_INDICES, PHYQ_DIMENSIONLESS, PHYQ_FREQUENCY, &
    & SECTION_INDICES, SPEC_INDICES

  use INTRINSIC, only: L_EMLS, L_UMLS, L_XPTL1
  use MOLECULES, only: INIT_MOLECULES, LAST_MOLECULE, LAST_MOLECULE_TYPE
  implicit NONE
d177 1
a177 1
             l+l_emls, l+l_umls, l+l_xptl1, n+n_dt_def /) )
d225 1
a225 1
       "$Id: Init_MLSSignals_m.f90,v 2.31 2013/11/06 01:46:30 pwagner Exp $"
d235 3
@


2.31
log
@May read instrument field of module; e.g. emls
@
text
@a34 3
  ! Types used in signal specifications:
  integer, parameter :: Last_signal_type = last_molecule_type

d64 1
a64 1
  integer, parameter :: Last_Signal_Lit    = last_molecule
d67 2
a68 1
  integer, parameter :: T_INSTRUMENTTYPE   = last_intrinsic_spec+1
d71 6
a76 6
  integer, parameter :: S_band             = t_instrumenttype + 1
  integer, parameter :: S_module           = s_band + 1
  integer, parameter :: S_radiometer       = s_module + 1
  integer, parameter :: S_signal           = s_radiometer + 1
  integer, parameter :: S_spectrometerType = s_signal + 1
  integer, parameter :: Last_Signal_Spec = s_spectrometerType
d82 1
d225 1
a225 1
       "$Id: Init_MLSSignals_m.f90,v 2.30 2013/09/04 00:00:59 pwagner Exp $"
d235 3
@


2.30
log
@Comments preceding use TREE made more uniform across modules
@
text
@d23 1
d49 2
a50 1
  integer, parameter :: F_last              = f_frequency + 1
d67 4
a70 1
  integer, parameter :: Last_Signal_Lit     = last_molecule
d73 1
a73 1
  integer, parameter :: S_band             = last_intrinsic_spec + 1
d92 1
a92 1
    use TREE_TYPES, only: N_FIELD_SPEC, N_FIELD_TYPE, N_SPEC_DEF
d115 1
d130 3
d177 4
a180 1
      begin, s+s_module, &
d182 1
d226 1
a226 1
       "$Id: Init_MLSSignals_m.f90,v 2.29 2013/08/23 23:23:11 pwagner Exp $"
d236 3
@


2.29
log
@Added Aura field to Module spec
@
text
@d14 4
a17 4
  use INTRINSIC, only: Add_Ident, Begin, D, F, Field_First, G, L, &
    & Last_Intrinsic_Lit, Last_Intrinsic_Spec, N, NADP, NDP, NP, NR, P, S, &
    & Spec_First, T, T_Boolean, T_Numeric, T_Numeric_Range, T_Polarization, &
    & T_String, Z
d23 1
a23 1
  use MOLECULES, only: Init_Molecules, Last_Molecule, Last_Molecule_Type
d84 1
a84 1
    ! This really belongs in make_tree, but "make depends" can't see it there
d213 1
a213 1
       "$Id: Init_MLSSignals_m.f90,v 2.28 2011/01/29 00:46:42 vsnyder Exp $"
d223 3
@


2.28
log
@Add units checking
@
text
@d38 2
a39 1
  integer, parameter :: F_band = field_First
d100 1
d169 1
d213 1
a213 1
       "$Id: Init_MLSSignals_m.f90,v 2.27 2009/06/23 18:25:42 pwagner Exp $"
d223 3
@


2.27
log
@Prevent Intel from optimizing ident string away
@
text
@d19 3
a21 2
  use INTRINSIC, only: DATA_TYPE_INDICES, FIELD_INDICES, FUNC_INDICES, &
    & LIT_INDICES, PARM_INDICES, SECTION_INDICES, SPEC_INDICES
d30 1
a30 1
       "$RCSfile: $"
d170 1
a170 1
             begin, f+f_lo, t+t_numeric, nr+n_field_type, &
d174 1
a174 1
             begin, f+f_singleSideband, t+t_numeric, nr+n_field_type, &
d177 1
a177 1
             begin, f+f_channels, t+t_numeric_range, n+n_field_type, &
d180 5
a184 5
             begin, f+f_first, t+t_numeric, n+n_field_type, &
             begin, f+f_last, t+t_numeric, n+n_field_type, &
             begin, f+f_start, t+t_numeric, n+n_field_type, &
             begin, f+f_step, t+t_numeric, n+n_field_type, &
             begin, f+f_width, t+t_numeric, n+n_field_type, &
d190 1
a190 1
             begin, f+f_centerfrequency, t+t_numeric, n+n_field_type, &
d194 5
a198 5
             begin, f+f_channels, t+t_numeric_range, n+n_field_type, &
             begin, f+f_direction, t+t_numeric, nr+n_field_type, &
             begin, f+f_radiometer, s+s_radiometer, n+n_field_spec, &
             begin, f+f_spectrometer, t+t_numeric, nr+n_field_type, &
             begin, f+f_switch, t+t_numeric, nr+n_field_type, &
d210 1
a210 1
       "$Id: read_apriori.f90 is it here $"
d220 3
@


2.26
log
@Reworded Copyright statement, moved rcs id
@
text
@d206 1
a207 1
!---------------------------- RCS Ident Info -------------------------------
d209 2
a210 3
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d212 1
d214 1
d219 3
@


2.25
log
@Rearrange function definition stuff
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d27 1
a27 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: Init_MLSSignals_m.f90,v 2.24 2004/01/16 21:37:23 livesey Exp $"
  character (len=len(idParm)), private :: Id = idParm
d29 1
a29 1
       "$RCSfile: Init_MLSSignals_m.f90,v $"
d207 5
d218 3
@


2.24
log
@Added the ability to defer the connection between bands and radiometers
until you define the signal.  This is to support some SMLS related
research work.
@
text
@d6 1
a6 1
  use INTRINSIC, only: Add_Ident, Begin, D, F, Field_First, L, &
d11 1
a11 1
  use INTRINSIC, only: DATA_TYPE_INDICES, FIELD_INDICES, &
d21 1
a21 1
       "$Id: Init_MLSSignals_m.f90,v 2.23 2003/08/16 01:14:03 vsnyder Exp $"
d208 5
@


2.23
log
@Add optional 'polarization' field to 'radiometer' spec
@
text
@d21 1
a21 1
       "$Id: Init_MLSSignals_m.f90,v 2.22 2003/07/23 18:02:30 livesey Exp $"
d183 1
a183 1
             begin, f+f_radiometer, s+s_radiometer, nr+n_field_spec, &
d190 1
d208 3
@


2.22
log
@Reverted DACS back to lower case
@
text
@d8 2
a9 1
    & Spec_First, T, T_Boolean, T_Numeric, T_Numeric_Range, T_String, Z
d21 1
a21 1
       "$Id: Init_MLSSignals_m.f90,v 2.21 2003/07/23 07:17:46 livesey Exp $"
d44 2
a45 1
  integer, parameter :: F_radiometer        = f_module + 1
d105 1
d164 6
a169 5
             begin, f+f_lo, t+t_numeric, n+n_field_type, &
             begin, f+f_suffix, t+t_string, n+n_field_type, &
             begin, f+f_module, s+s_module, n+n_field_spec, &
             begin, f+f_singleSideband, t+t_numeric, n+n_field_type, &
             nadp+n_spec_def, &
d207 3
@


2.21
log
@Capitalized DACS
@
text
@d20 1
a20 1
       "$Id: Init_MLSSignals_m.f90,v 2.20 2003/07/18 20:23:26 livesey Exp $"
d95 1
a95 1
    field_indices(f_dacs) =                add_ident ( 'DACS' )
d203 3
@


2.20
log
@Added DACS flags etc.
@
text
@d20 1
a20 1
       "$Id: Init_MLSSignals_m.f90,v 2.19 2003/05/16 02:44:18 vsnyder Exp $"
d95 1
a95 1
    field_indices(f_dacs) =                add_ident ( 'dacs' )
d203 3
@


2.19
log
@Removed USE's for unreferenced symbols
@
text
@d20 1
a20 1
       "$Id: Init_MLSSignals_m.f90,v 2.18 2002/10/08 00:09:10 pwagner Exp $"
d35 2
a36 1
  integer, parameter :: F_deferred          = f_channels + 1
d95 1
d168 1
d203 3
@


2.18
log
@Added idents to survive zealous Lahey optimizer
@
text
@d20 1
a20 1
       "$Id: Init_MLSSignals_m.f90,v 2.17 2002/05/14 22:31:47 livesey Exp $"
d76 2
a77 2
    use TREE, only: BUILD_TREE, PUSH_PSEUDO_TERMINAL
    use TREE_TYPES, only: N_DT_DEF, N_FIELD_SPEC, N_FIELD_TYPE, N_SPEC_DEF
d200 3
@


2.17
log
@Added singleSideband
@
text
@d20 1
a20 1
       "$Id: Init_MLSSignals_m.f90,v 2.16 2002/05/03 22:38:55 livesey Exp $"
d24 1
d193 4
d200 3
@


2.16
log
@Added direction field
@
text
@d20 1
a20 1
       "$Id: Init_MLSSignals_m.f90,v 2.15 2001/06/07 21:59:41 pwagner Exp $"
d42 2
a43 1
  integer, parameter :: F_spacecraft        = f_radiometer + 1
d101 1
d161 1
d195 3
@


2.16.2.1
log
@*** empty log message ***
@
text
@d20 1
a20 1
       "$Id: Init_MLSSignals_m.f90,v 2.17 2002/05/14 22:31:47 livesey Exp $"
d42 1
a42 2
  integer, parameter :: F_singleSideband    = f_radiometer + 1
  integer, parameter :: F_spacecraft        = f_singleSideband + 1
a99 1
    field_indices(f_singleSideband) =      add_ident ( 'singleSideband' )
a158 1
             begin, f+f_singleSideband, t+t_numeric, n+n_field_type, &
a191 6
! Revision 2.17  2002/05/14 22:31:47  livesey
! Added singleSideband
!
! Revision 2.16  2002/05/03 22:38:55  livesey
! Added direction field
!
@


2.15
log
@Added Copyright statement
@
text
@d20 1
a20 1
       "$Id: Init_MLSSignals_m.f90,v 2.14 2001/04/26 02:33:03 vsnyder Exp $"
d35 2
a36 1
  integer, parameter :: F_first             = f_deferred + 1
d93 1
d178 1
d192 3
@


2.14
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d1 3
d20 1
a20 1
       "$Id: Init_MLSSignals_m.f90,v 2.13 2001/04/23 20:57:42 vsnyder Exp $"
d189 3
@


2.13
log
@Move the first spec (time) to 'intrinsic'
@
text
@d3 6
a8 3
  use INTRINSIC, only: Add_Ident, Begin, D, F, L, Last_Intrinsic_Lit, &
    & Last_Intrinsic_Spec, N, NADP, NDP, NP, NR, P, S, Spec_First, T, &
    & T_Boolean, T_Numeric, T_Numeric_Range, T_String, Z
d17 1
a17 1
       "$Id: Init_MLSSignals_m.f90,v 2.12 2001/04/11 20:19:27 vsnyder Exp $"
a26 1
  integer, parameter :: Field_First = 1
d64 3
a66 2
  subroutine Init_MLSSignals ( Data_Type_Indices, Field_Indices, Lit_Indices, &
    & Parm_Indices, Section_Indices, Spec_Indices )
d73 6
a78 6
    integer, intent(inout) :: Data_Type_Indices(:)
    integer, intent(inout) :: Lit_Indices(:)
    integer, intent(inout) :: Field_Indices(field_First:last_Signal_Field)
    integer, intent(inout) :: Parm_Indices(:)
    integer, intent(inout) :: Section_Indices(:)
    integer, intent(inout) :: Spec_Indices(spec_First:last_Signal_Spec)
d80 2
a81 2
    call init_molecules ( data_type_indices, field_indices, lit_indices, &
      & parm_indices, section_indices, spec_indices )
d186 3
@


2.12
log
@Undo changes to 'deferred'
@
text
@d3 3
a5 3
  use INTRINSIC, only: Add_Ident, Begin, D, F, L, Last_Intrinsic_Lit, N, &
    & NADP, NDP, NP, NR, P, S, T, T_Boolean, T_Numeric, &
    & T_Numeric_Range, T_String, Z
d14 1
a14 1
       "$Id: Init_MLSSignals_m.f90,v 2.11 2001/04/11 18:31:04 vsnyder Exp $"
d50 1
a50 2
  integer, parameter :: Spec_First = 1
  integer, parameter :: S_band             = spec_First
d183 3
@


2.11
log
@Change 'deferred' from boolean to numeric
@
text
@d14 1
a14 1
       "$Id: Init_MLSSignals_m.f90,v 2.10 2001/04/10 18:51:25 vsnyder Exp $"
d155 1
a155 1
             begin, f+f_deferred, t+t_numeric, n+n_field_type, &
d184 3
@


2.10
log
@Finish removing sideband stuff
@
text
@d14 1
a14 1
       "$Id: Init_MLSSignals_m.f90,v 2.9 2001/04/10 17:59:53 vsnyder Exp $"
d155 1
a155 1
             begin, f+f_deferred, t+t_boolean, n+n_field_type, &
d184 3
@


2.9
log
@Remove sideband field from signal
@
text
@d14 1
a14 1
       "$Id: Init_MLSSignals_m.f90,v 2.8 2001/04/04 17:56:42 vsnyder Exp $"
d21 1
a21 2
  integer, parameter :: T_sideband = Last_molecule_type + 1
  integer, parameter :: Last_signal_type = t_sideband
d47 1
a47 4
  integer, parameter :: L_FOLDED            = last_molecule + 1
  integer, parameter :: L_LOWER             = l_folded + 1
  integer, parameter :: L_UPPER             = l_lower + 1
  integer, parameter :: Last_Signal_Lit     = l_upper
a80 2
    ! Put type names into the symbol table
    data_type_indices(t_sideband) =        add_ident ( 'sideband' )
a100 4
    ! Put literal names into the symbol table
    lit_indices(l_folded) =                add_ident ( 'folded' )
    lit_indices(l_lower) =                 add_ident ( 'lower' )
    lit_indices(l_upper) =                 add_ident ( 'upper' )
a122 8
  ! Start with the definitions of types. These are represented by trees of
  ! the form  < n_dt_def t_type_name l_lit ... l_lit >
    ! The intrinsic data types are defined in the intrinsic module
    ! Define the nonintrinsic enumerated types

    call make_tree ( (/ &
      begin, t+t_sideband, l+l_folded, l+l_lower, l+l_upper, n+n_dt_def /) )

d184 3
@


2.8
log
@Insert "USE TREE" because "make depends" can't see the one in "make_tree"
(because of the "include").
@
text
@d14 1
a14 1
       "$Id: Init_MLSSignals_m.f90,v 2.7 2001/04/03 19:09:12 vsnyder Exp $"
d37 1
a37 2
  integer, parameter :: F_sideband          = f_radiometer + 1
  integer, parameter :: F_spacecraft        = f_sideband + 1
a98 1
    field_indices(f_sideband) =            add_ident ( 'sideband' )
a188 1
             begin, f+f_sideband, t+t_sideband, n+n_field_type, &
d202 4
@


2.7
log
@Change the order of initialization to intrinsic, Molecules, MLSSignals.
Use the revised make_tree.f9h, which requires revision of init...
calling sequences.
@
text
@d14 1
a14 1
       "$Id: Init_MLSSignals_m.f90,v 2.6 2001/03/28 19:50:43 vsnyder Exp $"
d71 3
d205 5
@


2.6
log
@Remove frequencies and widths fields
@
text
@d4 1
a4 1
    & NADP, NDP, NP, NR, S, T, T_Boolean, T_Last_Intrinsic, T_Numeric, &
d7 3
a10 1
  private :: Make_Tree
d14 1
a14 1
       "$Id: Init_MLSSignals_m.f90,v 2.5 2001/03/16 02:00:40 vsnyder Exp $"
d21 2
a22 2
  integer, parameter :: t_sideband = t_last_intrinsic + 1
  integer, parameter :: t_last_signal = t_sideband
d49 1
a49 1
  integer, parameter :: L_FOLDED            = last_intrinsic_lit + 1
d69 2
a70 1
    & Spec_Indices )
d72 1
d76 2
d79 4
d195 1
a195 68
    subroutine MAKE_TREE ( IDS )
    ! Build a tree specified by the "ids" array.  "begin" marks the
    ! beginning of a tree.  A tree-node marks the end of the corresponding
    ! tree.  Pseudo-terminals are decorated with their indices.
      use TREE, only: BUILD_TREE, PUSH_PSEUDO_TERMINAL
      implicit NONE

      integer, intent(in) :: IDS(:)

      integer, save :: CALLNO = 0    ! Which call to Make_Tree -- for error msg.
      integer :: DECOR, I, ITEM, M, N_IDS, STACK(0:30), STRING, WHICH

      callno = callno + 1
      n_ids = size(ids)
      m = 0
      stack(0) = 0 ! just so it's defined, in case it gets incremented
                   ! after build_tree
      if ( ids(1) >= 0 ) then
        m = 1
        stack(1) = 0
      end if
      do i = 1, n_ids
        if ( ids(i) == begin ) then
          m = m + 1
          if ( m > ubound(stack,1) ) then
            print *, 'INIT_MLSSIGNALS_M%MAKE_TREE-E- Stack overflow!'
            print *, 'Your tree is taller than ', ubound(stack,1), &
              &      '.  Detected while'
            print *, 'processing element ', i, ' of the list for call ', callno
            stop
          end if
          stack(m) = 0
        else
          item = mod(ids(i), 1000)
          which = mod(ids(i) / 1000, 1000)
          decor = ids(i) / 1000000
          select case ( which )
          case ( f/1000 ) ! Fields
            string = field_indices(item)
          case ( l/1000 ) ! Enumeration literals
            string = lit_indices(item)
          case ( s/1000 ) ! Specs
            string = spec_indices(item)
          case ( t/1000 ) ! Intrinsic data types
            string = data_type_indices(item)
          case ( n/1000 ) ! Tree nodes
            call build_tree ( item, stack(m), decor )
            m = m - 1
            if ( m < lbound(stack,1) ) then
              print *, 'INIT_MLSSIGNALS_M%MAKE_TREE-E- Stack underflow!'
              print *, 'You probably forgot a "begin" somewhere.  Detected while'
              print *, 'processing element ', i, ' of the list for call ', callno
              stop
            end if
            stack(m) = stack(m) + 1
      cycle
          end select
          if ( string == 0 ) then
            print *, 'INIT_MLSSIGNALS_M%MAKE_TREE-E- The string for element ', &
              & i, ' of a list'
            print *, 'is undefined.  Detected on call ', callno, ' to Make_Tree.'
            stop
          end if
          call push_pseudo_terminal ( string, 0, decor = item )
          stack(m) = stack(m) + 1
        end if
      end do
    end subroutine MAKE_TREE
d202 3
@


2.5
log
@Add support for literals to Make_Tree (duh!)
@
text
@d5 1
a5 1
    & T_String, Z
d12 1
a12 1
       "$Id: Init_MLSSignals_m.f90,v 2.4 2001/03/16 01:02:32 vsnyder Exp $"
d30 1
a30 2
  integer, parameter :: F_frequencies       = f_first + 1
  integer, parameter :: F_frequency         = f_frequencies + 1
d44 1
a44 2
  integer, parameter :: F_widths            = f_width + 1
  integer, parameter :: Last_Signal_Field   = f_widths
a81 1
    field_indices(f_frequencies) =         add_ident ( 'frequencies' )
a95 1
    field_indices(f_widths) =              add_ident ( 'widths' )
d161 1
a163 1
             begin, f+f_frequencies, t+t_numeric, n+n_field_type, &
a167 1
             begin, f+f_widths, t+t_numeric, n+n_field_type, &
d177 1
a179 2
             begin, f+f_frequencies, t+t_numeric, n+n_field_type, &
             begin, f+f_widths, t+t_numeric, n+n_field_type, &
d259 3
@


2.4
log
@... Including the Log at the end.
@
text
@d12 1
a12 1
       "$Id: Init_MLSSignals_m.f90,v 2.3 2001/03/16 01:01:18 vsnyder Exp $"
d36 2
a37 1
  integer, parameter :: F_spacecraft        = f_radiometer + 1
d90 1
d182 1
d230 2
d264 4
a267 1
! $Log: $
@


2.3
log
@It wouldn't hurt to have some CVS variables...
@
text
@d12 1
a12 1
       "$Id: init_tables_module.f90,v 2.50 2001/03/16 00:59:43 vsnyder Exp $"
d15 1
a15 1
       "$RCSfile: init_tables_module.f90,v $"
d259 1
a259 1
! $Log $
@


2.2
log
@Define t_sideband and its lits
@
text
@d10 8
d258 2
@


2.1
log
@Moved MLSSignals_m to mlspgs/lib.
@
text
@d3 3
a5 2
  use INTRINSIC, only: Add_Ident, Begin, D, F, L, N, NADP, NDP, NP, &
    & NR, S, T, T_Boolean, T_Numeric, T_String, Z
d7 1
d10 4
d15 29
a43 23
  integer, parameter, public :: Field_First = 1
  integer, parameter, public :: F_band = field_First
  integer, parameter, public :: F_centerFrequency   = f_band + 1
  integer, parameter, public :: F_channel           = f_centerFrequency + 1
  integer, parameter, public :: F_channels          = f_channel + 1
  integer, parameter, public :: F_deferred          = f_channels + 1
  integer, parameter, public :: F_first             = f_deferred + 1
  integer, parameter, public :: F_frequencies       = f_first + 1
  integer, parameter, public :: F_frequency         = f_frequencies + 1
  integer, parameter, public :: F_last              = f_frequency + 1
  integer, parameter, public :: F_lo                = f_last + 1
  integer, parameter, public :: F_module            = f_lo + 1
  integer, parameter, public :: F_radiometer        = f_module + 1
  integer, parameter, public :: F_spacecraft        = f_radiometer + 1
  integer, parameter, public :: F_spectrometer      = f_spacecraft + 1
  integer, parameter, public :: F_spectrometerType  = f_spectrometer + 1
  integer, parameter, public :: F_start             = f_spectrometerType + 1
  integer, parameter, public :: F_step              = f_start + 1
  integer, parameter, public :: F_suffix            = f_step + 1
  integer, parameter, public :: F_switch            = f_suffix + 1
  integer, parameter, public :: F_width             = f_switch + 1
  integer, parameter, public :: F_widths            = f_width + 1
  integer, parameter, public :: Last_Signal_Field = f_widths
d46 7
a52 7
  integer, parameter, public :: Spec_First = 1
  integer, parameter, public :: S_band             = spec_First
  integer, parameter, public :: S_module           = s_band + 1
  integer, parameter, public :: S_radiometer       = s_module + 1
  integer, parameter, public :: S_signal           = s_radiometer + 1
  integer, parameter, public :: S_spectrometerType = s_signal + 1
  integer, parameter, public :: Last_Signal_Spec = s_spectrometerType
d59 5
a63 2
  subroutine Init_MLSSignals ( Field_Indices, Spec_Indices, Data_Type_Indices )
    use TREE_TYPES, only: N_FIELD_SPEC, N_FIELD_TYPE, N_SPEC_DEF
d66 2
a67 1
    integer, intent(in) :: Data_Type_Indices(:)
d90 4
d115 8
@

