head	2.1;
access;
symbols
	v5-02-NRT-19:2.1
	v6-00:2.1
	v5-02-NRT-18:2.1
	v5-02:2.1
	v5-01-NRT-17:2.1
	v5-01-NRT-16:2.1
	v5-01-NRT-15:2.1
	v5-01-NRT-14:2.1
	neuralnetworks-1-0:2.1.0.10
	cfm-single-freq-0-1:2.1.0.8
	v5-01:2.1
	v5-00:2.1
	v4-23-TA133:2.1.0.6
	mus-emls-1-70:2.1.0.4
	rel-1-0-englocks-work:2.1.0.2
	VUMLS1-00:2.1
	VPL1-00:2.1
	V4-22-NRT-08:2.1
	VAM1-00:2.1;
locks; strict;
comment	@# @;


2.1
date	2015.04.04.01.38.25;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.1
log
@Initial commit
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id: Get_Monotone.f9h,v 2.2 2015/03/27 02:07:05 vsnyder Exp $

! subroutine Longest_Monotone_Subsequence ( A, Seq, Dir )
!   type(?), intent(in) :: A(:)
!   integer, allocatable :: Seq(:)
!   integer, intent(in), optional :: Dir ! Direction, default +1 => increasing

! This was adapted from a web page where zero-origin indexing was used.  That's
! why A, P and M have zero-origin arrays.  At the end, SEQ is computed for
! 1-origin indexing.

    integer :: P(0:size(a)-1), M(0:size(a))
    integer :: Hi, I, K, L, Lo, Mid, MyDir, NewL

    myDir = +1
    if ( present(dir) ) myDir = sign(1,dir)

    l = 0
    m(1) = 0
    do i = 0, size(a)-1
      ! Binary search for largest positive j <= l such that a(m(j)) < a(i)
      lo = 1
      hi = l
      do while ( lo <= hi )
        mid = ( lo + hi + 1 ) / 2
        if ( myDir*a(m(mid)) < myDir*a(i) ) then
          lo = mid + 1
        else
          hi = mid -1
        end if
      end do

      ! Lo is now 1 greater than the length of the longest prefix of a(i)

      newL = lo

      ! The predecessor of a(i) is the last index of the subsequence of
      ! length newL - 1

      p(i) = m(newL-1)
      m(newL) = i

      ! If we found a subsequence longer than any we've found, update L
      l = max(l, newL)

    end do

    ! Construct indices of the longest monotone subsequence
    if ( allocated(seq) ) then
      if ( size(seq) /= l ) deallocate ( seq )
    end if
    if ( .not. allocated(seq) ) allocate ( seq(l) )
    k = m(l)
    do i = l, 1, -1
      seq(i) = k + 1
      k = p(k)
    end do

! $Log: $
@
