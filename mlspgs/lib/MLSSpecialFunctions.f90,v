head	2.9;
access;
symbols
	v5-02-NRT-19:2.9
	v6-00:2.9
	v5-02-NRT-18:2.9
	v5-02:2.9
	v5-01-NRT-17:2.9
	v5-01-NRT-16:2.9
	v5-01-NRT-15:2.9
	v5-01-NRT-14:2.9
	neuralnetworks-1-0:2.9.0.10
	cfm-single-freq-0-1:2.9.0.8
	v5-01:2.9
	v5-00:2.9
	v4-23-TA133:2.9.0.6
	mus-emls-1-70:2.9.0.4
	rel-1-0-englocks-work:2.9.0.2
	VUMLS1-00:2.9
	VPL1-00:2.9
	V4-22-NRT-08:2.9
	VAM1-00:2.9
	V4-21:2.8.0.2
	V4-13:2.8
	V4-12:2.8
	V4-11:2.8
	V4-10:2.8
	V3-43:2.7
	M4-00:2.7
	V3-41:2.7
	V3-40-PlusGM57:2.7.0.2
	V2-24-NRT-04:2.4
	V3-33:2.7
	V2-24:2.4
	V3-31:2.7
	V3-30-NRT-05:2.7
	cfm-01-00:2.7
	V3-30:2.7
	V3-20:2.7
	V3-10:2.5
	V2-23-NRT-02:2.4
	V2-23:2.4
	V2-22-NRT-01:2.4
	V2-22:2.4
	V2-21:2.2
	V2-20:2.2
	V2-11:2.2
	V2-10:2.2
	V2-00:2.2
	V1-51:2.1
	V1-50:2.1
	V1-45:2.1
	V1-44:2.1;
locks; strict;
comment	@# @;


2.9
date	2015.06.11.22.58.30;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2009.10.21.22.47.36;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2009.06.23.18.24.06;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2007.07.25.20.09.42;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2007.05.17.17.25.17;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2004.06.02.21.03.16;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.9
log
@Prime number-related things moved to another module
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module MLSSpecialFunctions              ! Some special functions
!=============================================================================

  use Ermsg_m, only: derm1, serm1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error

  implicit none

  private
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSSpecialFunctions.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!         Functions, operations, routines
! gamma                    Gamma function; Gamma(n+1) = n!
! [ds]erfi                 Error function ([double,single] precision)
! [ds]erfci                Complementary Error function ([double,single] precision)
! === (end of toc) ===

! === (start of api) ===
! nprec gamma ( nprec x )
! real serfi (real x)
! real serfci (real x)
! double serfi (double x)
! double serfci (double x)
! === (end of api) ===

  public :: gamma
  public :: derfci, derfi, serfci, serfi, d1mach, i1mach, r1mach

  interface gamma
    module procedure sgamma, dgamma
  end interface
  
contains
      double precision function DGAMMA(X)
!>> 1996-03-30 DGAMMA Krogh  Added external statement.
!>> 1994-10-20 DGAMMA Krogh  Changes to use M77CON
!>> 1991-10-21 DGAMMA CLL Eliminated DGAM1 as a separate subroutine.
!>> 1991-01-16 DGAMMA Lawson  Replaced D2MACH/R2MACH with DGAM1.
!>> 1985-08-02 DGAMMA Lawson  Initial code.
!--D replaces "?": ?GAMMA, ?ERM1, ?ERV1
!
! ----------------------------------------------------------------------
!
!  THIS ROUTINE CALCULATES THE GAMMA FUNCTION FOR A double precision
!      ARGUMENT X. PERMITS NEGATIVE AS WELL AS POSITIVE X. NOTE
!      THAT THE GAMMA FUNCTION HAS POLES AT ZERO AND AT NEGATIVE
!      ARGUMENTS. COMPUTATION IS BASED ON AN ALGORITHN OUTLINED IN
!      W.J.CODY, 'AN OVERVIEW OF SOFTWARE DEVELOPMENT FOR SPECIAL
!      FUNCTIONS', LECTURE NOTES IN MATHEMATICS, 506, NUMERICAL ANALYSIS
!      DUNDEE, 1975, G. A. WATSON (ED.),SPRINGER VERLAG, BERLIN, 1976.
!      THE PROGRAM USES RATIONAL FUNCTIONS THAT APPROXIMATE THE GAMMA
!      FUNCTION TO AT LEAST 20 SIGNIFICANT DECIMAL DIGITS. COEFFICIENTS
!      FOR THE APPROXIMATION OVER THE INTERVAL (1,2) ARE UNPUBLISHED.
!      THOSE FOR THE APPROXIMATION FOR X .GE. 12 ARE FROM HART, ET. AL.,
!      COMPUTER APPROXIMATIONS, WILEY AND SONS, NEW YORK, 1968.
!      LOWER ORDER APPROXIMATIONS CAN BE SUBSTITUTED FOR THESE ON
!      MACHINES WITH LESS PRECISE ARITHMETIC.
!
!  Designed & programmed by W.J.CODY, Argonne National Lab.,1982.
!  Minor changes for the JPL library by C.L.LAWSON & S.CHAN,JPL,1983.
!
!***********************************************************************
!
!-- Begin mask code changes
!  EXPLANATION OF MACHINE-DEPENDENT CONSTANTS
!
!  EPS    - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!           1.0 + EPS .GT. 1.0  (EPS = [D/R]1MACH(4).)
!  XINF   - THE LARGEST MACHINE REPRESENTABLE FLOATING-POINT NUMBER.
!           XINF = [D/R]1MACH(2).
!  XMININ - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!           both XMININ and 1/XMININ are representable.  This is
!           the larger of [D/R]1MACH(1) and 1.0 / [D/R]1MACH(2).
!  XGBIG  - A value such that    Gamma(XGBIG) = 0.875 * XINF.
!           (Computed and used in [D/S]GAMMA.)
!  XLBIG  - A value such that LogGamma(XLBIG) = 0.875 * XINF.
!           (Computed and used in [D/S]LGAMA.)
!
!      Values of XINF, XGBIG, and XLBIG for some machines:
!
!        XINF              XGBIG     XLBIG       Machines
!
!  2**127  = 0.170e39      34.81  0.180e37     Vax SP & DP; Unisys SP
!  2**128  = 0.340e39      35.00  0.358e37     IEEE SP
!  2**252  = 0.723e76      57.54  0.376e74     IBM30xx DP
!  2**1023 = 0.899e308    171.46  0.112e306    Unisys DP
!  2**1024 = 0.180e309    171.60  0.2216e306   IEEE DP
!  2**1070 = 0.126e323    177.78  0.1501e320   CDC/7600 SP
!  2**8191 = 0.550e2466   966.94  0.8464e2462  Cray SP & DP
!-- End mask code changes
!
!***********************************************************************
!
!  ERROR RETURNS
!
!  THE PROGRAM RETURNS THE VALUE XINF FOR SINGULARITIES OR
!     WHEN OVERFLOW WOULD OCCUR. THE COMPUTATION IS BELIEVED
!     TO BE FREE OF UNDERFLOW AND OVERFLOW.
!
!  AUTHOR:W. J. CODY
!         APPLIED MATHMATICS DIVISION
!         ARGONNE NATIONAL LABORATORY
!         ARGONNE, IL 60439
!
!  LATEST MODIFICATION by Cody: MAY 18, 1982
!
!     ------------------------------------------------------------------
      double precision C(7), CONST, DEL, EPS, F, FACT, FP, HALF
      double precision ONE,P(8), PI,Q(8), RES,C1
      double precision SUM,TEMP, TWELVE,TWO
      double precision X,X1, X2, XGBIG,XDEN,XINF,XMININ,XNUM
      double precision Y,Y1,YSQ,Z,ZERO
      integer I,J,N
      logical PARITY
!
      save EPS, XGBIG, XMININ, XINF
!
      parameter( ONE = 1.0D0, HALF = 0.5D0, TWO = 2.0d0)
      parameter( ZERO = 0.0D0, TWELVE = 12.0D0)
!
!                      C1 = LOG base e of SQRT(2*PI)
!
      parameter( C1 = 0.9189385332046727417803297D0)
!
      parameter( PI = 3.1415926535897932384626434D0)
!
      data XINF/0.0D0/
!
! ----------------------------------------------------------------------
!  NUMERATOR AND DENOMINATOR COEFFICIENTS FOR RATIONAL MINIMAX
!     APPROXIMATION OVER (1,2).
! ----------------------------------------------------------------------
      DATA P/-1.71618513886549492533811D+0,2.47656508055759199108314D+1,&
            -3.79804256470945635097577D+2,6.29331155312818442661052D+2,&
            8.66966202790413211295064D+2,-3.14512729688483675254357D+4,&
            -3.61444134186911729807069D+4,6.64561438202405440627855D+4/
      DATA Q/-3.08402300119738975254353D+1,3.15350626979604161529144D+2,&
           -1.01515636749021914166146D+3,-3.10777167157231109440444D+3,&
             2.25381184209801510330112D+4,4.75584627752788110767815D+3,&
           -1.34659959864969306392456D+5,-1.15132259675553483497211D+5/
! ----------------------------------------------------------------------
!  COEFFICIENTS FOR MINIMAX APPROXIMATION OVER (12, INF).
! ----------------------------------------------------------------------
      DATA C/-1.910444077728D-03,8.4171387781295D-04,&
          -5.952379913043012D-04,7.93650793500350248D-04,&
          -2.777777777777681622553D-03,8.333333333333333331554247D-02,&
           5.7083835261D-03/
! ----------------------------------------------------------------------
!
      IF (XINF .EQ. ZERO) THEN
        EPS = epsilon(x)   ! D1MACH(4)
        XINF = huge(x)     ! D1MACH(2)
         ! if(D1MACH(1) * D1MACH(2) .ge. ONE) then
         !   XMININ = D1MACH(1)
         ! else
         !   XMININ = ONE / D1MACH(2)
         ! endif
         XMININ = tiny(x)
!
!                         Compute XGBIG
!
!        XGBIG will satisfy Gamma(XGBIG) = 0.875 * XINF.
!        Use a Newton iteration and the following approximation for
!        the gamma function:
!        log(gamma(x)) ~ (x - .5)*log(x) - x + 0.5 * log(2 * PI)
!
         TEMP = log(0.875d0 * XINF)
         CONST = HALF * log(TWO * PI) - TEMP
         X1 = TEMP * 0.34d0
         do 40 J=1,7
            F = (X1-HALF)*log(X1) - X1 + CONST
            FP = ((X1-HALF)/X1)  + log(X1) - ONE
            DEL = -F/FP
            X2 = X1+DEL
            if(abs(DEL) .lt. 0.5d-5 * X2) go to 45
            X1 = X2
   40    continue
   45    continue
         XGBIG = X2
      END IF
      PARITY = .FALSE.
      FACT = ONE
      N = 0
      Y = X
      IF (Y .GT. ZERO) GO TO 200
! ----------------------------------------------------------------------
!  ARGUMENT IS NEGATIVE OR ZERO
! ----------------------------------------------------------------------
      Y = -X
      J = INT(Y)
      RES = Y - dble(J)
      IF (RES .EQ. ZERO) GO TO 700
      IF (J .NE. (J/2)*2) PARITY = .TRUE.
      FACT = -PI / sin(PI*RES)
      Y = Y + ONE
! ----------------------------------------------------------------------
!  ARGUMENT IS POSITIVE
! ----------------------------------------------------------------------
  200 IF (Y .LT. EPS) GO TO 650
      IF (Y .GE. TWELVE) GO TO 300
      Y1 = Y
      IF (Y .GE. ONE) GO TO 210
! ----------------------------------------------------------------------
!  0.0 .LT. ARGUMENT .LT. 1.0
! ----------------------------------------------------------------------
      Z = Y
      Y = Y + ONE
      GO TO 250
! ----------------------------------------------------------------------
!  1.0 .LT. ARGUMENT .LT. 12.0, REDUCE ARGUMENT IF NECESSARY
! ----------------------------------------------------------------------
  210 N= int(Y) - 1
      Y = Y - dble(N)
      Z = Y - ONE
! ----------------------------------------------------------------------
!  EVALUATE APPROXIMATION FOR 1.0 .LT. ARGUMENT .LT. 2.0
! ----------------------------------------------------------------------
  250 XNUM = ZERO
      XDEN = ONE
      DO 260 I = 1, 8
         XNUM = (XNUM + P(I)) * Z
         XDEN = XDEN * Z + Q(I)
  260 CONTINUE
      RES = (XNUM / XDEN + HALF) + HALF
      IF (Y .EQ. Y1) GO TO 900
      IF (Y1 .GT. Y) GO TO 280
! ----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE 0.0 .LT. ARGUMENT .LT. 1.0
! ----------------------------------------------------------------------
      RES = RES / Y1
      GO TO 900
! ----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE 2.0 .LT. 12.0
! ----------------------------------------------------------------------
  280 DO 290 I = 1, N
         RES = RES * Y
         Y = Y + ONE
  290 CONTINUE
      GO TO 900
! ----------------------------------------------------------------------
!  EVALUATE FOR ARGUMENT .GE. 12.0
! ----------------------------------------------------------------------
  300 IF (Y .GT. XGBIG) GO TO 720
      YSQ = Y * Y
      SUM = C(7)
      DO 350 I = 1, 6
         SUM = SUM / YSQ + C(I)
  350 CONTINUE
      SUM = ((SUM/Y + C1) - Y) + (Y - HALF) * log(Y)
      RES = exp(SUM)
      GO TO 900
! ----------------------------------------------------------------------
!  ARGUMENT .LT. EPS
! ----------------------------------------------------------------------
  650 IF (Y .LT. XMININ) GO TO 740
      RES = ONE / Y
      GO TO 900
! ----------------------------------------------------------------------
!  RETURN FOR SINGULARITIES,EXTREME ARGUMENTS, ETC.
! ----------------------------------------------------------------------
  700 CALL MLSMessage ( MLSMSG_Error, ModuleName, &
                      & "POLE AT 0 AND NEG INTEGERS" )
      GO TO 780
!
  720 CALL MLSMessage ( MLSMSG_Error, ModuleName, &
                      & "arg SO LARGE VALUE WOULD OVERFLOW" )
      GO TO 780
!
  740 CALL MLSMessage ( MLSMSG_Error, ModuleName, &
                      & "arg too near a sinularity--VALUE WOULD OVERFLOW" )
!
  780 DGAMMA = XINF
      GO TO 950
! ----------------------------------------------------------------------
!  FINAL ADJUSTMENTS AND RETURN
! ----------------------------------------------------------------------
  900 IF (PARITY) RES = -RES
      IF (FACT .NE. ONE) RES = FACT / RES
      DGAMMA = RES
  950 RETURN
    end function DGAMMA
      real             function SGAMMA(X)
!>> 1996-03-30 SGAMMA Krogh  Added external statement.
!>> 1994-10-20 SGAMMA Krogh  Changes to use M77CON
!>> 1991-10-21 SGAMMA CLL Eliminated DGAM1 as a separate subroutine.
!>> 1991-01-16 SGAMMA Lawson  Replaced D2MACH/R2MACH with DGAM1.
!>> 1985-08-02 SGAMMA Lawson  Initial code.
!--S replaces "?": ?GAMMA, ?ERM1, ?ERV1
!
! ----------------------------------------------------------------------
!
!  THIS ROUTINE CALCULATES THE GAMMA FUNCTION FOR A double precision
!      ARGUMENT X. PERMITS NEGATIVE AS WELL AS POSITIVE X. NOTE
!      THAT THE GAMMA FUNCTION HAS POLES AT ZERO AND AT NEGATIVE
!      ARGUMENTS. COMPUTATION IS BASED ON AN ALGORITHN OUTLINED IN
!      W.J.CODY, 'AN OVERVIEW OF SOFTWARE DEVELOPMENT FOR SPECIAL
!      FUNCTIONS', LECTURE NOTES IN MATHEMATICS, 506, NUMERICAL ANALYSIS
!      DUNDEE, 1975, G. A. WATSON (ED.),SPRINGER VERLAG, BERLIN, 1976.
!      THE PROGRAM USES RATIONAL FUNCTIONS THAT APPROXIMATE THE GAMMA
!      FUNCTION TO AT LEAST 20 SIGNIFICANT DECIMAL DIGITS. COEFFICIENTS
!      FOR THE APPROXIMATION OVER THE INTERVAL (1,2) ARE UNPUBLISHED.
!      THOSE FOR THE APPROXIMATION FOR X .GE. 12 ARE FROM HART, ET. AL.,
!      COMPUTER APPROXIMATIONS, WILEY AND SONS, NEW YORK, 1968.
!      LOWER ORDER APPROXIMATIONS CAN BE SUBSTITUTED FOR THESE ON
!      MACHINES WITH LESS PRECISE ARITHMETIC.
!
!  Designed & programmed by W.J.CODY, Argonne National Lab.,1982.
!  Minor changes for the JPL library by C.L.LAWSON & S.CHAN,JPL,1983.
!
!***********************************************************************
!
!-- Begin mask code changes
!  EXPLANATION OF MACHINE-DEPENDENT CONSTANTS
!
!  EPS    - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!           1.0 + EPS .GT. 1.0  (EPS = [D/R]1MACH(4).)
!  XINF   - THE LARGEST MACHINE REPRESENTABLE FLOATING-POINT NUMBER.
!           XINF = [D/R]1MACH(2).
!  XMININ - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!           both XMININ and 1/XMININ are representable.  This is
!           the larger of [D/R]1MACH(1) and 1.0 / [D/R]1MACH(2).
!  XGBIG  - A value such that    Gamma(XGBIG) = 0.875 * XINF.
!           (Computed and used in [D/S]GAMMA.)
!  XLBIG  - A value such that LogGamma(XLBIG) = 0.875 * XINF.
!           (Computed and used in [D/S]LGAMA.)
!
!      Values of XINF, XGBIG, and XLBIG for some machines:
!
!        XINF              XGBIG     XLBIG       Machines
!
!  2**127  = 0.170e39      34.81  0.180e37     Vax SP & DP; Unisys SP
!  2**128  = 0.340e39      35.00  0.358e37     IEEE SP
!  2**252  = 0.723e76      57.54  0.376e74     IBM30xx DP
!  2**1023 = 0.899e308    171.46  0.112e306    Unisys DP
!  2**1024 = 0.180e309    171.60  0.2216e306   IEEE DP
!  2**1070 = 0.126e323    177.78  0.1501e320   CDC/7600 SP
!  2**8191 = 0.550e2466   966.94  0.8464e2462  Cray SP & DP
!-- End mask code changes
!
!***********************************************************************
!
!  ERROR RETURNS
!
!  THE PROGRAM RETURNS THE VALUE XINF FOR SINGULARITIES OR
!     WHEN OVERFLOW WOULD OCCUR. THE COMPUTATION IS BELIEVED
!     TO BE FREE OF UNDERFLOW AND OVERFLOW.
!
!  AUTHOR:W. J. CODY
!         APPLIED MATHMATICS DIVISION
!         ARGONNE NATIONAL LABORATORY
!         ARGONNE, IL 60439
!
!  LATEST MODIFICATION by Cody: MAY 18, 1982
!
!     ------------------------------------------------------------------
      real             C(7), CONST, DEL, EPS, F, FACT, FP, HALF
      real             ONE,P(8), PI,Q(8), RES,C1
      real             SUM,TEMP, TWELVE,TWO
      real             X,X1, X2, XGBIG,XDEN,XINF,XMININ,XNUM
      real             Y,Y1,YSQ,Z,ZERO
      integer I,J,N
      logical PARITY
!
      save EPS, XGBIG, XMININ, XINF
!
      parameter( ONE = 1.0E0, HALF = 0.5E0, TWO = 2.0e0)
      parameter( ZERO = 0.0E0, TWELVE = 12.0E0)
!
!                      C1 = LOG base e of SQRT(2*PI)
!
      parameter( C1 = 0.9189385332046727417803297E0)
!
      parameter( PI = 3.1415926535897932384626434E0)
!
      data XINF/0.0E0/
!
! ----------------------------------------------------------------------
!  NUMERATOR AND DENOMINATOR COEFFICIENTS FOR RATIONAL MINIMAX
!     APPROXIMATION OVER (1,2).
! ----------------------------------------------------------------------
      DATA P/-1.71618513886549492533811E+0,2.47656508055759199108314E+1,&
            -3.79804256470945635097577E+2,6.29331155312818442661052E+2,&
            8.66966202790413211295064E+2,-3.14512729688483675254357E+4,&
            -3.61444134186911729807069E+4,6.64561438202405440627855E+4/
      DATA Q/-3.08402300119738975254353E+1,3.15350626979604161529144E+2,&
           -1.01515636749021914166146E+3,-3.10777167157231109440444E+3,&
             2.25381184209801510330112E+4,4.75584627752788110767815E+3,&
           -1.34659959864969306392456E+5,-1.15132259675553483497211E+5/
! ----------------------------------------------------------------------
!  COEFFICIENTS FOR MINIMAX APPROXIMATION OVER (12, INF).
! ----------------------------------------------------------------------
      DATA C/-1.910444077728E-03,8.4171387781295E-04,&
          -5.952379913043012E-04,7.93650793500350248E-04,&
          -2.777777777777681622553E-03,8.333333333333333331554247E-02,&
           5.7083835261E-03/
! ----------------------------------------------------------------------
!
      IF (XINF .EQ. ZERO) THEN
        EPS = epsilon(x)   ! R1MACH(4)
        XINF = huge(x)     ! R1MACH(2)
         ! if(R1MACH(1) * R1MACH(2) .ge. ONE) then
         !   XMININ = R1MACH(1)
         !  else
         !   XMININ = ONE / R1MACH(2)
         ! endif
         XMININ = tiny(x)
!
!                         Compute XGBIG
!
!        XGBIG will satisfy Gamma(XGBIG) = 0.875 * XINF.
!        Use a Newton iteration and the following approximation for
!        the gamma function:
!        log(gamma(x)) ~ (x - .5)*log(x) - x + 0.5 * log(2 * PI)
!
         TEMP = log(0.875e0 * XINF)
         CONST = HALF * log(TWO * PI) - TEMP
         X1 = TEMP * 0.34e0
         do 40 J=1,7
            F = (X1-HALF)*log(X1) - X1 + CONST
            FP = ((X1-HALF)/X1)  + log(X1) - ONE
            DEL = -F/FP
            X2 = X1+DEL
            if(abs(DEL) .lt. 0.5e-5 * X2) go to 45
            X1 = X2
   40    continue
   45    continue
         XGBIG = X2
      END IF
      PARITY = .FALSE.
      FACT = ONE
      N = 0
      Y = X
      IF (Y .GT. ZERO) GO TO 200
! ----------------------------------------------------------------------
!  ARGUMENT IS NEGATIVE OR ZERO
! ----------------------------------------------------------------------
      Y = -X
      J = INT(Y)
      RES = Y - real(J)
      IF (RES .EQ. ZERO) GO TO 700
      IF (J .NE. (J/2)*2) PARITY = .TRUE.
      FACT = -PI / sin(PI*RES)
      Y = Y + ONE
! ----------------------------------------------------------------------
!  ARGUMENT IS POSITIVE
! ----------------------------------------------------------------------
  200 IF (Y .LT. EPS) GO TO 650
      IF (Y .GE. TWELVE) GO TO 300
      Y1 = Y
      IF (Y .GE. ONE) GO TO 210
! ----------------------------------------------------------------------
!  0.0 .LT. ARGUMENT .LT. 1.0
! ----------------------------------------------------------------------
      Z = Y
      Y = Y + ONE
      GO TO 250
! ----------------------------------------------------------------------
!  1.0 .LT. ARGUMENT .LT. 12.0, REDUCE ARGUMENT IF NECESSARY
! ----------------------------------------------------------------------
  210 N= int(Y) - 1
      Y = Y - real(N)
      Z = Y - ONE
! ----------------------------------------------------------------------
!  EVALUATE APPROXIMATION FOR 1.0 .LT. ARGUMENT .LT. 2.0
! ----------------------------------------------------------------------
  250 XNUM = ZERO
      XDEN = ONE
      DO 260 I = 1, 8
         XNUM = (XNUM + P(I)) * Z
         XDEN = XDEN * Z + Q(I)
  260 CONTINUE
      RES = (XNUM / XDEN + HALF) + HALF
      IF (Y .EQ. Y1) GO TO 900
      IF (Y1 .GT. Y) GO TO 280
! ----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE 0.0 .LT. ARGUMENT .LT. 1.0
! ----------------------------------------------------------------------
      RES = RES / Y1
      GO TO 900
! ----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE 2.0 .LT. 12.0
! ----------------------------------------------------------------------
  280 DO 290 I = 1, N
         RES = RES * Y
         Y = Y + ONE
  290 CONTINUE
      GO TO 900
! ----------------------------------------------------------------------
!  EVALUATE FOR ARGUMENT .GE. 12.0
! ----------------------------------------------------------------------
  300 IF (Y .GT. XGBIG) GO TO 720
      YSQ = Y * Y
      SUM = C(7)
      DO 350 I = 1, 6
         SUM = SUM / YSQ + C(I)
  350 CONTINUE
      SUM = ((SUM/Y + C1) - Y) + (Y - HALF) * log(Y)
      RES = exp(SUM)
      GO TO 900
! ----------------------------------------------------------------------
!  ARGUMENT .LT. EPS
! ----------------------------------------------------------------------
  650 IF (Y .LT. XMININ) GO TO 740
      RES = ONE / Y
      GO TO 900
! ----------------------------------------------------------------------
!  RETURN FOR SINGULARITIES,EXTREME ARGUMENTS, ETC.
! ----------------------------------------------------------------------
  700 CALL MLSMessage ( MLSMSG_Error, ModuleName, &
                      & "POLE AT 0 AND NEG INTEGERS" )
      GO TO 780
!
  720 CALL MLSMessage ( MLSMSG_Error, ModuleName, &
                      & "arg SO LARGE VALUE WOULD OVERFLOW" )
      GO TO 780
!
  740 CALL MLSMessage ( MLSMSG_Error, ModuleName, &
                      & "arg too near a sinularity--VALUE WOULD OVERFLOW" )
!
  780 SGAMMA = XINF
      GO TO 950
! ----------------------------------------------------------------------
!  FINAL ADJUSTMENTS AND RETURN
! ----------------------------------------------------------------------
  900 IF (PARITY) RES = -RES
      IF (FACT .NE. ONE) RES = FACT / RES
      SGAMMA = RES
  950 RETURN
      end function sgamma

  ! --------------------------------------------------------  AMACH  -----
  SUBROUTINE AMACH (MODE, I, I1, R1, D1)
!>> 1996-03-30 AMACH  Krogh   Added external statement.
!>> 1994-10-26 AMACH  Krogh   Changes to use M77CON
!>> 1994-09-23 AMACH  Snyder  Add VAX G parameters
!>> 1994-06-21 AMACH  Snyder  Compute only round-off and u-flow at first
!>> 1994-05-25 AMACH  Snyder  Added an option to compute at run time.
!>> 1992-04-07 AMACH  Oken    Removed ^Z at EOF (error found by VAX comp
!>> 1992-02-20 AMACH  Snyder  Added Cray-YMP stuff, q.v.
!>> 1990-06-11 AMACH  Snyder  Added Apollo DN-10000 stuff, q.v.
!>> 1990-12-14 AMACH  Lawson  Changed to eliminate ENTRY statements.
!>> 1990-08-21 AMACH  Krogh   No test was getting done for bad machine.
!>> 1990-02-28 AMACH  Krogh   Correct missing DOUBLE PRECISION AMSUB1
!>> 1989-08-14 AMACH  Krogh   Parameterized everything -- Massive change
!>> 1989-03-30 AMACH  Snyder  Correct missing "/" line 921
!>> 1989-01-30 AMACH  Snyder  Incorporate more constants from NETLIB.
!>> 1988-05-19 AMACH  Lawson  Initial code.
! File AMACH.FOR contains user-callable functions I1MACH, D1MACH, and
! R1MACH, plus second-level subroutines AMACH, AMTEST, and AMSUB1.
! Appropriate lines must be switched between comment and non-comment
! status when this code is moved to a different computer system.
!     These changes can be done with any text editor, however the "c++"
! lines permit automation of the change using the M77CON processor.
! Note that when the M77CON processor activates a line it shifts
! Columns 2-72 to 1-71 and puts a blank in Column 72.  When it inactiv-
! ates a line it shifts Columns 1-71 to 2-72 and puts a C in Column 1.
!     The possible choices using M77CON (don't include parenthetical
!     comments) are:
!      c++ CURRENT HAS SYS = IEEE
!      c++ CURRENT HAS SYS = ALPHA_D3
!      c++ CURRENT HAS SYS = AMDAHL
!      c++ CURRENT HAS SYS = APOLLO_10000
!      c++ CURRENT HAS SYS = BUR1700
!      c++ CURRENT HAS SYS = BUR5700
!      c++ CURRENT HAS SYS = BUR67_7700
!      c++ CURRENT HAS SYS = CDC60_7000
!      c++ CURRENT HAS SYS = CONVEXC_1
!      c++ CURRENT HAS SYS = CRAY1
!      c++ CURRENT HAS SYS = CRAY1_SD (Sngl prec.arith. used for dble.)
!      c++ CURRENT HAS SYS = CRAY1_64 (64 bit integers)
!      c++ CURRENT HAS SYS = CRAY1_SD_64 (64 bit int, SP used for DP)
!      c++ CURRENT HAS SYS = CRAY_T3D
!      c++ CURRENT HAS SYS = CRAY_YMP
!      c++ CURRENT HAS SYS = CRAY_YMP_SD (Sngl prec. used for dble.)
!      c++ CURRENT HAS SYS = DG_S2000
!      c++ CURRENT HAS SYS = HARRIS220
!      c++ CURRENT HAS SYS = HON600_6000
!      c++ CURRENT HAS SYS = HON_DPS_8_70
!      c++ CURRENT HAS SYS = HP700Q
!      c++ CURRENT HAS SYS = IBM360_370
!      c++ CURRENT HAS SYS = INTERDATA_8_32
!      c++ CURRENT HAS SYS = PDP10_KA
!      c++ CURRENT HAS SYS = PDP10_KB
!      c++ CURRENT HAS SYS = PDP11
!      c++ CURRENT HAS SYS = PRIME50
!      c++ CURRENT HAS SYS = SEQ_BAL_8000
!      c++ CURRENT HAS SYS = UNIVAC
!      c++ CURRENT HAS SYS = VAX
!      c++ CURRENT HAS SYS = VAX_G
!     The current choice is:
!++ CURRENT HAS SYS = IEEE
!
!     One can also select whether floating point constants are created
!     by the compiler or created at run time.  The choices using M77CON
!     are:
!      c++ CURRENT HAS HOW = COMPILER
!      c++ CURRENT HAS HOW = RUN
!     The current choice is:
!++ CURRENT HAS HOW = COMPILER
!
!     If the constants are created at run time, and they fail the run-
!     time check for reasonableness, they are re-created assuming IEEE.
!     If they still fail, the program stops.
!
!  I/O UNIT NUMBERS:
!
!    IM1 = I1MACH( 1) = THE STANDARD INPUT UNIT.
!    IM2 = I1MACH( 2) = THE STANDARD OUTPUT UNIT.
!    IM3 = I1MACH( 3) = THE STANDARD PUNCH UNIT.
!    IM4 = I1MACH( 4) = THE STANDARD ERROR MESSAGE UNIT.
!
!  WORDS:
!
!    IM5 = I1MACH( 5) = THE NUMBER OF BITS PER INTEGER STORAGE UNIT.
!    IM6 = I1MACH( 6) = THE NUMBER OF CHARACTERS/INTEGER STORAGE UNIT.
!
!  INTEGERS:
!
!    ASSUME INTEGERS ARE REPRESENTED IN THE S-DIGIT, BASE-A FORM
!
!               SIGN ( X(S-1)*A**(S-1) + ... + X(1)*A + X(0) )
!
!               WHERE 0 .LE. X(I) .LT. A FOR I=0,...,S-1.
!
!    IM7 = I1MACH( 7) = A, THE BASE.
!    IM8 = I1MACH( 8) = S, THE NUMBER OF BASE-A DIGITS.
!    IM9 = I1MACH( 9) = A**S - 1, THE LARGEST MAGNITUDE.
!
!  FLOATING-POINT NUMBERS:
!
!    ASSUME FLOATING-POINT NUMBERS ARE REPRESENTED IN THE T-DIGIT,
!    BASE-B FORM
!
!               SIGN (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
!
!               WHERE 0 .LE. X(I) .LT. B FOR I=1,...,T,
!               0 .LT. X(1), AND EMIN .LE. E .LE. EMAX.
!
!    IM10 = I1MACH(10) = B, THE BASE.
!
!  SINGLE-PRECISION:
!
!    IM11 = I1MACH(11) = T, THE NUMBER OF BASE-B DIGITS.
!    IM12 = I1MACH(12) = EMIN, THE SMALLEST EXPONENT E.
!    IM13 = I1MACH(13) = EMAX, THE LARGEST EXPONENT E.
!
!  DOUBLE-PRECISION:
!
!    IM14 = I1MACH(14) = T, THE NUMBER OF BASE-B DIGITS.
!    IM15 = I1MACH(15) = EMIN, THE SMALLEST EXPONENT E.
!    IM16 = I1MACH(16) = EMAX, THE LARGEST EXPONENT E.
!
!  CONVERSION FROM FUNCTIONAL TO STRUCTURAL FLOATING POINT CONSTANTS
!
!    IM17 = CONSTANT SUCH THAT IM14 + IM17 = ACTUAL NUMBER OF BASE-B
!           DIGITS IN DOUBLE PRECISION, USED FOR CHECKING THAT CORRECT
!           VERSION OF THIS PROGRAM IS INSTALLED.  (SEE DEFINITION OF
!           DM6, AND THE USE OF DM6 IN CALLING AMTEST.)
!
!  TO ALTER THIS FUNCTION FOR A PARTICULAR ENVIRONMENT,
!  THE DESIRED SET OF PARAMETER STATEMENTS SHOULD BE ACTIVATED BY
!  REMOVING THE C FROM COLUMN 1.  ALSO, THE VALUES OF
!  IM1 - IM4 SHOULD BE CHECKED FOR CONSISTENCY
!  WITH THE LOCAL OPERATING SYSTEM.
!     -----------------------------------------------------------------
!     Original design and code due to P. A. Fox, A. D. Hall, and
!     N. L. Schryer, Bell Laboratories.  See ACM TOMS, 4,(1978),177-188.
!     Adapted to Univac 1100 by Kris Stewart, JPL, 7/30/81.
!     Adapted for the JPL MATH77 library by C. L. Lawson and F. T. Krogh
!     Sept, 1987.
!     1989-08-14 AMACH  Krogh   Parameterized everything. Major changes.
!     1990 Dec. CLL reorganized code to avoid using ENTRY statements
!     for functions of different types.  Also added save statements.
!     -----------------------------------------------------------------
!     On the first call to this function, tests are done to verify that
!     IM10 and IM14 are not grossly wrong for the host environment.
!     This gives some protection against using the wrong version of this
!     subprogram.
!     -----------------------------------------------------------------
      INTEGER MODE, I, I1
      REAL R1
      DOUBLE PRECISION D1, TEST
!
      INTEGER IMACH(17)
      INTEGER IM1, IM2, IM3, IM4, IM5, IM6, IM7, IM8, IM9, IM10, IM11, &
                  IM12, IM13, IM14, IM15, IM16, IM17
!++ Code for HOW=RUN is INACTIVE
!      integer IEEE
!      integer ID1, ID2, ID3, ID4, ID5, ID6, ID7, ID8, ID10, ID11,
!     1   ID12, ID13, ID14, ID15, ID16, ID17
!++ Code for (HOW=RUN) | SYS=IEEE is ACTIVE
      INTEGER IE1, IE2, IE3, IE4, IE5, IE6, IE7, IE8, IE10, IE11, &
         IE12, IE13, IE14, IE15, IE16, IE17
!++ end
      REAL             RMACH(5), RM1, RM2, RM3, RM4, RM5, &
                       RMA, RMB, RBASE
      DOUBLE PRECISION DMACH(5), DM1, DM2, DM3, DM4, DM5, DM6, &
                       DMA, DMB, DBASE
      SAVE TEST, IMACH, RMACH, DMACH
!     -----------------------------------------------------------------
!     Machine constants for IEEE standard binary floating-point
!     processors.  This includes PC's and work-stations using the
!     Intel 8087, 80287, 80387, ... processors or the
!     Motorola 68881, 68882, ... processors.
!     Note:  We are setting the "most negative exponent" (IMACH(12) and
!     IMACH(15)) to be the exponent of the smallest normalized number.
!     An IEEE processor actually handles smaller numbers before
!     underflowing, however these "unnormalized" numbers have
!     diminished precision.
!
!++ Code for (HOW=RUN) | SYS=IEEE is ACTIVE
!     Parameters for IEEE when generating at run time:
      PARAMETER (IE1 =5, IE2 =6, IE3 =7, IE4 =6)
      PARAMETER (IE5 =32, IE6 =4, IE7 =2, IE8 =31)
      PARAMETER (IE10 =2, IE11 =24, IE12 =-125, IE13 =128)
      PARAMETER (IE14 =53, IE15 =-1021, IE16 =1024, IE17=0)
!++ Code for SYS = IEEE is ACTIVE
      PARAMETER (IM1 = IE1, IM2 = IE2, IM3 = IE3, IM4 = IE4)
      PARAMETER (IM5 = IE5, IM6 = IE6, IM7 = IE7, IM8 = IE8)
      PARAMETER (IM10 = IE10, IM11 = IE11, IM12 = IE12, IM13 = IE13)
      PARAMETER (IM14 = IE14, IM15 = IE15, IM16 = IE16, IM17 = IE17)
!     -----------------------------------------------------------------
!++ Code for SYS = ALPHA_D3 is INACTIVE
!c     MACHINE CONSTANTS for the VAX/VMS F and D-3 format for Alpha

!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =2, IM11 =24, IM12 =-127, IM13 =127)
!      PARAMETER (IM14 =53, IM15 =-127, IM16 =127, IM17=0)
!++ end
!     -----------------------------------------------------------------
!++ Code for HOW = RUN is INACTIVE
!c     MACHINE CONSTANTS for the VAX/VMS F and D-3 format for Alpha

!      PARAMETER (ID1 =5, ID2 =6, ID3 =7, ID4 =6)
!      PARAMETER (ID5 =32, ID6 =4, ID7 =2, ID8 =31)
!      PARAMETER (ID10 =2, ID11 =24, ID12 =-127, ID13 =127)
!      PARAMETER (ID14 =53, ID15 =-127, ID16 =127, ID17=0)
!++ end
!     -----------------------------------------------------------------
!++ Code for SYS = AMDAHL is INACTIVE
!C     MACHINE CONSTANTS FOR AMDAHL MACHINES.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =16, IM11 =6, IM12 =-64, IM13 =63)
!      PARAMETER (IM14 =14, IM15 =-64, IM16 =63, IM17=0)
!      -----------------------------------------------------------------
!++ Code for SYS = APOLLO_10000 is INACTIVE
!c     MACHINE CONSTANTS FOR APOLLO DN_10000 MACHINES.
!c     The only difference from IEEE is IM13.  This difference has
!c     nothing to do with the arithmetic or representation used by the
!c     machine.  It is caused by a bug in the compiler:  The right-hand
!c     side of RM2 (below) is apparently evaluated in double precision.
!c     When the compiler is ready to store the resulting value into its
!c     internal data structures, it compares it to an incorrect value
!c     of the overflow limit.  It appears the incorrect value has the
!c     correct exponent, but the fraction is 1.5 instead of 2-2**(-p),
!c     where p is the precision in bits.  You can get the correct result
!c     by changing IM13 to 128, changing RM2 from a parameter to a
!c     variable, and changing the parameter statement that assigns a
!c     value to RM2 into an ordinary assignment statement.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =2, IM11 =24, IM12 =-125, IM13 =127)
!      PARAMETER (IM14 =53, IM15 =-1021, IM16 =1024, IM17 =0)
!C     -----------------------------------------------------------------
!++ Code for SYS = BUR1700 is INACTIVE
!C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM.
!C
!      PARAMETER (IM1 =7, IM2 =2, IM3 =2, IM4 =2)
!      PARAMETER (IM5 =36, IM6 =4, IM7 =2, IM8 =33)
!      PARAMETER (IM10 =2, IM11 =24, IM12 =-256, IM13 =255)
!      PARAMETER (IM14 =60, IM15 =-256, IM16 =255, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = BUR5700 is INACTIVE
!C     MACHINE CONSTANTS FOR THE BURROUGHS 5700 SYSTEM.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =48, IM6 =6, IM7 =2, IM8 =39)
!      PARAMETER (IM10 =8, IM11 =13, IM12 =-50, IM13 =76)
!      PARAMETER (IM14 =26, IM15 =-50, IM16 =76, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = BUR67_7700 is INACTIVE
!C     MACHINE CONSTANTS FOR THE BURROUGHS 6700/7700 SYSTEMS.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =48, IM6 =6, IM7 =2, IM8 =39)
!      PARAMETER (IM10 =8, IM11 =13, IM12 =-50, IM13 =76)
!      PARAMETER (IM14 =26, IM15 =-32754, IM16 =32780, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = CDC60_7000 is INACTIVE
!C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =60, IM6 =10, IM7 =2, IM8 =48)
!      PARAMETER (IM10 =2, IM11 =47, IM12 =-929, IM13 =1070)
!      PARAMETER (IM14 =94, IM15 =-929, IM16 =1069, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = CONVEXC_1 is INACTIVE
!C     MACHINE CONSTANTS FOR CONVEX C-1.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =2, IM11 =24, IM12 =-128, IM13 =127)
!      PARAMETER (IM14 =53, IM15 =-1024, IM16 =1023, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = CRAY1 is INACTIVE
!C     MACHINE CONSTANTS FOR THE CRAY 1, XMP, 2, AND 3.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =102, IM4 =6)
!      PARAMETER (IM5 =64, IM6 =8, IM7 =2, IM8 =46)
!      PARAMETER (IM10 =2, IM11 =47, IM12 =-8189, IM13 =8190)
!      PARAMETER (IM14 =94, IM15 =-8099, IM16 =8190, IM17=2)
!C     -----------------------------------------------------------------
!++ Code for SYS = CRAY_T3D is INACTIVE
!c     Machine constants for Cray T3D.  IEEE double for both precisions.
!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =2, IM11 =53, IM12 =-1021, IM13 =1024)
!      PARAMETER (IM14 =53, IM15 =-1021, IM16 =1024, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = CRAY_YMP is INACTIVE
!C     MACHINE CONSTANTS FOR THE CRAY YMP
!C     Cray claims the overflow exponent (IM13 and IM16) is 8189, and
!C     the underflow exponent (IM12 and IM15) is -8189, but these values
!C     don't seem to work in cf77:  the underflow limit underflows, and
!C     the overflow limit overflows when using Cray's values.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =102, IM4 =6)
!      PARAMETER (IM5 =64, IM6 =8, IM7 =2, IM8 =46)
!      PARAMETER (IM10 =2, IM11 =47, IM12 =-8188, IM13 =8189)
!      PARAMETER (IM14 =94, IM15 =-8188, IM16 =8189, IM17=2)
!C     -----------------------------------------------------------------
!++ Code for SYS = CRAY_YMP_SD is INACTIVE
!C     MACHINE CONSTANTS FOR THE CRAY YMP
!C     Cray claims the overflow exponent (IM13 and IM16) is 8189, and
!C     the underflow exponent (IM12 and IM15) is -8189, but these
!C     values don't seem to work in cf77:  the underflow limit under-
!C     flows, and the overflow limit overflows when using Cray's values.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =102, IM4 =6)
!      PARAMETER (IM5 =64, IM6 =8, IM7 =2, IM8 =46)
!      PARAMETER (IM10 =2, IM11 =47, IM12 =-8188, IM13 =8189)
!      PARAMETER (IM14 =47, IM15 =-8188, IM16 =8189, IM17=1)
!C     -----------------------------------------------------------------
!++ Code for SYS = CRAY1_SD is INACTIVE
!C     MACHINE CONSTANTS FOR THE CRAY 1, XMP, 2, AND 3, WHEN DOUBLE
!C     PRECISION IS TO USE SINGLE PRECISION ARITHMETIC.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =102, IM4 =6)
!      PARAMETER (IM5 =64, IM6 =8, IM7 =2, IM8 =46)
!      PARAMETER (IM10 =2, IM11 =47, IM12 =-8189, IM13 =8190)
!      PARAMETER (IM14 =47, IM15 =-8189, IM16 =8190, IM17=1)
!C     -----------------------------------------------------------------
!++ Code for SYS = CRAY1_64 is INACTIVE
!C     MACHINE CONSTANTS FOR THE CRAY 1, XMP, 2, AND 3.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =102, IM4 =6)
!      PARAMETER (IM5 =64, IM6 =8, IM7 =2, IM8 =63)
!      PARAMETER (IM10 =2, IM11 =47, IM12 =-8189, IM13 =8190)
!      PARAMETER (IM14 =94, IM15 =-8099, IM16 =8190, IM17=2)
!C     -----------------------------------------------------------------
!++ Code for SYS = CRAY1_SD_64 is INACTIVE
!C     MACHINE CONSTANTS FOR THE CRAY 1, XMP, 2, AND 3, WHEN DOUBLE
!C     PRECISION IS TO USE SINGLE PRECISION ARITHMETIC.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =102, IM4 =6)
!      PARAMETER (IM5 =64, IM6 =8, IM7 =2, IM8 =63)
!      PARAMETER (IM10 =2, IM11 =47, IM12 =-8189, IM13 =8190)
!      PARAMETER (IM14 =47, IM15 =-8189, IM16 =8190, IM17=1)
!C     -----------------------------------------------------------------
!++ Code for SYS = DG_S2000 is INACTIVE
!C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
!C
!      PARAMETER (IM1 =11, IM2 =12, IM3 =8, IM4 =10)
!      PARAMETER (IM5 =16, IM6 =2, IM7 =2, IM8 =15)
!      PARAMETER (IM10 =16, IM11 =6, IM12 =-64, IM13 =63)
!      PARAMETER (IM14 =14, IM15 =-64, IM16 =63, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = HARRIS220 is INACTIVE
!C     MACHINE CONSTANTS FOR THE HARRIS 220, SLASH 6, SLASH 7.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =0, IM4 =6)
!      PARAMETER (IM5 =24, IM6 =3, IM7 =2, IM8 =23)
!      PARAMETER (IM10 =2, IM11 =23, IM12 =-127, IM13 =127)
!      PARAMETER (IM14 =38, IM15 =-127, IM16 =127, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = HON600_6000 is INACTIVE
!C     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =43, IM4 =6)
!      PARAMETER (IM5 =36, IM6 =6, IM7 =2, IM8 =35)
!      PARAMETER (IM10 =2, IM11 =27, IM12 =-127, IM13 =127)
!      PARAMETER (IM14 =63, IM15 =-127, IM16 =127, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = HON_DPS_8_70 is INACTIVE
!C     MACHINE CONSTANTS FOR THE HONEYWELL DPS 8/70 SERIES.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =43, IM4 =6)
!      PARAMETER (IM5 =36, IM6 =4, IM7 =2, IM8 =35)
!      PARAMETER (IM10 =2, IM11 =27, IM12 =-127, IM13 =127)
!      PARAMETER (IM14 =63, IM15 =-127, IM16 =127, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = HP700Q is INACTIVE
!c     Machine constants for HP-700 using the +autodblpad option,
!c     which automatically increases DOUBLE PRECISION to REAL*16, and
!c     REAL to DOUBLE PRECISION.
!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =2, IM11 =53, IM12 =-1021, IM13 =1024)
!      PARAMETER (IM14 = 113, IM15 = -16381, IM16 = 16384, IM17 = 0)
!C     -----------------------------------------------------------------
!++ Code for SYS = IBM360_370 is INACTIVE
!C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
!C     THE XEROX SIGMA 5/7/9 AND THE SEL SYSTEMS 85/86.

!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =16, IM11 =6, IM12 =-64, IM13 =63)
!      PARAMETER (IM14 =14, IM15 =-64, IM16 =63, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = INTERDATA_8_32 is INACTIVE
!C     MACHINE CONSTANTS FOR THE INTERDATA 8/32
!C     WITH THE UNIX SYSTEM FORTRAN 77 COMPILER.
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =6, IM4 =6)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =16, IM11 =6, IM12 =-64, IM13 =62)
!      PARAMETER (IM14 =14, IM15 =-64, IM16 =62, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = PDP10_KA is INACTIVE
!C     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR).
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =36, IM6 =5, IM7 =2, IM8 =35)
!      PARAMETER (IM10 =2, IM11 =27, IM12 =-128, IM13 =127)
!      PARAMETER (IM14 =54, IM15 =-101, IM16 =127, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = PDP10_KB is INACTIVE
!C     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR).
!C
!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =36, IM6 =5, IM7 =2, IM8 =35)
!      PARAMETER (IM10 =2, IM11 =27, IM12 =-128, IM13 =127)
!      PARAMETER (IM14 =62, IM15 =-128, IM16 =127, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = PDP11 is INACTIVE
!C     MACHINE CONSTANTS FOR PDP-11 FORTRAN'S SUPPORTING
!C     16-BIT INTEGER ARITHMETIC.

!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =16, IM6 =2, IM7 =2, IM8 =15)
!      PARAMETER (IM10 =2, IM11 =24, IM12 =-127, IM13 =127)
!      PARAMETER (IM14 =56, IM15 =-127, IM16 =127, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = PRIME50 is INACTIVE
!C     MACHINE CONSTANTS FOR THE PRIME 50 SERIES SYSTEMS
!C     WITH 32-BIT INTEGERS AND 64V MODE INSTRUCTIONS,
!C     SUPPLIED BY IGOR BRAY.

!      PARAMETER (IM1 =1, IM2 =1, IM3 =2, IM4 =1)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =2, IM11 =23, IM12 =-127, IM13 =127)
!      PARAMETER (IM14 =47, IM15 =-32895, IM16 =32637, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = SEQ_BAL_8000 is INACTIVE
!C     MACHINE CONSTANTS FOR THE SEQUENT BALANCE 8000.
!C
!      PARAMETER (IM1 =0, IM2 =0, IM3 =7, IM4 =0)
!      PARAMETER (IM5 =32, IM6 =1, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =2, IM11 =24, IM12 =-125, IM13 =128)
!      PARAMETER (IM14 =53, IM15 =-1021, IM16 =1024, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = UNIVAC is INACTIVE
!C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES.
!C
!C     NOTE THAT THE PUNCH UNIT, I1MACH(3), HAS BEEN SET TO 1
!C     WHICH IS APPROPRIATE FOR THE UNIVAC-FTN SYSTEM.
!C     IF YOU HAVE THE UNIVAC-FOR SYSTEM, SET IT TO 7.
!C     IM6 = 4 for FTN (4 chars per word), 6 for FOR (6 chars per word).
!c
!      PARAMETER (IM1 =5, IM2 =6, IM3 =1, IM4 =6)
!      PARAMETER (IM5 =36, IM6 =4, IM7 =2, IM8 =35)
!      PARAMETER (IM10 =2, IM11 =27, IM12 =-128, IM13 =127)
!      PARAMETER (IM14 =60, IM15 =-1024, IM16 =1023, IM17=0)
!C     -----------------------------------------------------------------
!++ Code for SYS = VAX is INACTIVE
!c     MACHINE CONSTANTS for the VAX/VMS F and D formats
!c     and for PDP-11 FORTRAN SUPPORTING 32-BIT INTEGER ARITHMETIC.

!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =2, IM11 =24, IM12 =-127, IM13 =127)
!      PARAMETER (IM14 =56, IM15 =-127, IM16 =127, IM17=0)
!++ end
!     -----------------------------------------------------------------
!++ Code for SYS = VAX_G is INACTIVE
!c     MACHINE CONSTANTS for the VAX/VMS F and G formats
!c     and for PDP-11 FORTRAN SUPPORTING 32-BIT INTEGER ARITHMETIC.

!      PARAMETER (IM1 =5, IM2 =6, IM3 =7, IM4 =6)
!      PARAMETER (IM5 =32, IM6 =4, IM7 =2, IM8 =31)
!      PARAMETER (IM10 =2, IM11 =24, IM12 =-127, IM13 =127)
!      PARAMETER (IM14 =53, IM15 =-1023, IM16 =1023, IM17=0)
!++ end
!     -----------------------------------------------------------------
!
!
! Real parameters
!
!  RM1 = R1MACH(1) = B**(EMIN-1), The smallest positive number, i.e.,
!                    the underflow limit.
!  RM2 = R1MACH(2) = B**EMAX*(1 - B**(-T)), The largest number, i.e.,
!                    the overflow limit.
!  RM3 = R1MACH(3) = B**(-T), The smallest relative spacing, i.e., the
!                    difference between 1.0 and the next smaller number.
!  RM4 = R1MACH(4) = B**(1-T), The largest relative spacing, i.e., the
!                     difference between 1.0 and the next larger number.
!  RM5 = R1MACH(5) = LOG10(B).  When B = 2 this value is
!              Log10(2) = 0.30102_99956_63981_19521_37388_94724
!
! Parameter RMA and RMB are selected so that for values of the base =
! 2, 8, 16, 10, RMA has the values 1, 3, 4, 0, and RMB has the values 0,
! 0, 0, 1.  These values are used in computing RM5.
! $$$$ Note that if other bases are to be supported, the calculation of
! $$$$ RMA and RMB will have to be generalized.
!
!++   Code for HOW = COMPILER is ACTIVE
      PARAMETER (IM9 = 2 * (2**(IM8-1) - 1) + 1)
      PARAMETER (RMA = ((IM10 - 10) * (-3 + ((IM10 - 2) * (-77 + &
          12 * (IM10 - 8))) / 14)) / 24)
      PARAMETER (RMB = ((IM10 - 2) * (IM10 - 8) * (16 - IM10)) / 96)
      PARAMETER (RBASE = IM10)
!
!     Weird subterfuges below are NECESSARY to compute DM1 and DM2 on
!     some systems.  DON'T SIMPLIFY THEM.  We compute RM1 and RM2 using
!     these subterfuges so it will be clear we're computing the REAL
!     and DOUBLE PRECISION characteristics in the same way.
      PARAMETER (RM1 = (RBASE**(IM12/2)) * (RBASE**(IM12-IM12/2-1)))
      PARAMETER (RM2 = RBASE**(IM13-IM11) * ((RBASE**IM11 - RBASE) &
                     + (RBASE - 1.0E0)))
      PARAMETER (RM3 = RBASE**(-IM11))
      PARAMETER (RM4 = RBASE**(1-IM11))
!     PARAMETER (RM5 = RMA*0.30102 99956 63981 19521 37388 94724E0+RMB)
      PARAMETER (RM5 = RMA*0.301029995663981195213738894724E0+RMB)
!
! Double precision parameters -- (Defined like the real ones.)
!
      PARAMETER (DMA = ((IM10 - 10) * (-3 + ((IM10 - 2) * (-77 + &
          12 * (IM10 - 8))) / 14)) / 24)
      PARAMETER (DMB = ((IM10 - 2) * (IM10 - 8) * (16 - IM10)) / 96)
      PARAMETER (DBASE = IM10)
!
!     Weird subterfuges below are NECESSARY to compute DM1 and DM2 on
!     some systems.  DON'T SIMPLIFY THEM.
      PARAMETER (DM1 = (DBASE**(IM15/2)) * (DBASE**(IM15-IM15/2-1)))
      PARAMETER (DM2 = DBASE**(IM16-IM14) * ((DBASE**IM14 - DBASE) &
                     + (DBASE - 1.0D0)))
      PARAMETER (DM3 = DBASE**(-IM14))
      PARAMETER (DM4 = DBASE**(1-IM14))
!     PARAMETER (DM5 = DMA *
!    1 0.30102 99956 63981 19521 37388 94724 49302 67681 89881 46211 D0
!    2 + DMB)
!
      PARAMETER (DM5 = DMA* &
       0.30102999566398119521373889472449302676818988146211D0 + DMB)
! DM6 and TEST are used in checking that the correct constants have
! been selected.
      PARAMETER (DM6 = DBASE**(-IM14-IM17))
!++   END
      DATA TEST / 0.D0 /
!
!     DATA IMACH / IM1, IM2, IM3, IM4, IM5, IM6, IM7, IM8, IM9, IM10,
!    1   IM11, IM12, IM13, IM14, IM15, IM16 /
!     DATA RMACH / RM1, RM2, RM3, RM4, RM5 /
!     DATA DMACH / DM1, DM2, DM3, DM4, DM5 /
!     -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

      IF (TEST .EQ. 0.0D0) THEN
!         IM9 = 2 * (2**(IM8-1) - 1) + 1
         IMACH(1) = IM1
         IMACH(2) = IM2
         IMACH(3) = IM3
         IMACH(4) = IM4
         IMACH(5) = IM5
         IMACH(6) = IM6
         IMACH(7) = IM7
         IMACH(8) = IM8
         IMACH(10) = IM10
         IMACH(11) = IM11
         IMACH(12) = IM12
         IMACH(13) = IM13
         IMACH(14) = IM14
         IMACH(15) = IM15
         IMACH(16) = IM16
         IMACH(17) = IM17
!++   Code for HOW = RUN is INACTIVE
!         IEEE = 0
!100      continue
!      DBASE = IMACH(10)
!C
!C     Weird subterfuge below is NECESSARY to compute DM1 on
!C     some systems.  DON'T SIMPLIFY IT.
!      DM1=(DBASE**(IMACH(15)/2)) * (DBASE**(IMACH(15)-IMACH(15)/2-1))
!C DM6 and TEST are used in checking that the correct constants have
!C been selected.
!      DM6 = DBASE**(-IMACH(14)-IMACH(17))
!++   end
         CALL AMTEST (TEST, DM6)
         IF (dm1 .EQ. 0.0d0 .OR. test .EQ. 0.0d0) THEN
!++   Code for HOW = RUN is INACTIVE
!           if (IEEE .eq. 0) then
!              IEEE = 1
!              IMACH(1) = IE1
!              IMACH(2) = IE2
!              IMACH(3) = IE3
!              IMACH(4) = IE4
!              IMACH(5) = IE5
!              IMACH(6) = IE6
!              IMACH(7) = IE7
!              IMACH(8) = IE8
!              IMACH(10) = IE10
!              IMACH(11) = IE11
!              IMACH(12) = IE12
!              IMACH(13) = IE13
!              IMACH(14) = IE14
!              IMACH(15) = IE15
!              IMACH(16) = IE16
!              IMACH(17) = IE17
!              go to 100
!           end if
!           if (IEEE .eq. 1) then
!              IEEE = 2
!              IMACH(1) = ID1
!              IMACH(2) = ID2
!              IMACH(3) = ID3
!              IMACH(4) = ID4
!              IMACH(5) = ID5
!              IMACH(6) = ID6
!              IMACH(7) = ID7
!              IMACH(8) = ID8
!              IMACH(10) = ID10
!              IMACH(11) = ID11
!              IMACH(12) = ID12
!              IMACH(13) = ID13
!              IMACH(14) = ID14
!              IMACH(15) = ID15
!              IMACH(16) = ID16
!              IMACH(17) = ID17
!              go to 100
!           end if
!++   END
            PRINT*,'AMACH has bad parameters for current environment.'
            STOP
         END IF
!++   Code for HOW = RUN is INACTIVE
!         IM9 = 2 * (2**(IMACH(8)-1) - 1) + 1
!         RMA = ((IMACH(10) - 10) * (-3 + ((IMACH(10) - 2) * (-77 +
!     1       12 * (IMACH(10) - 8))) / 14)) / 24
!         RMB = ((IMACH(10)-2) * (IMACH(10)-8) * (16-IMACH(10)))/96
!         RBASE = IMACH(10)
!C
!C        Weird subterfuges below are NECESSARY to compute DM1 and DM2
!C        on some systems.  DON'T SIMPLIFY THEM.  We compute RM1 and
!C        RM2 using these subterfuges so it will be clear we're
!C        computing the REAL and DOUBLE PRECISION characteristics in
!c        the same way.
!         RM1=(RBASE**(IMACH(12)/2))*(RBASE**(IMACH(12)-IMACH(12)/2-1))
!         RM2 = RBASE**(IMACH(13)-IMACH(11))*((RBASE**IMACH(11) - RBASE)
!     1                  + (RBASE - 1.0E0))
!         RM3 = RBASE**(-IMACH(11))
!         RM4 = RBASE**(1-IMACH(11))
!c        RM5 = RMA*0.30102 99956 63981 19521 37388 94724E0+RMB
!         RM5 = RMA*0.301029995663981195213738894724E0+RMB
!C
!C Double precision parameters -- (Defined like the real ones.)
!C
!         DMA = ((IMACH(10) - 10) * (-3 + ((IMACH(10) - 2) * (-77 +
!     1       12 * (IMACH(10) - 8))) / 14)) / 24
!         DMB = ((IMACH(10)-2) * (IMACH(10)-8) * (16-IMACH(10)))/96
!C
!C        Weird subterfuge below is NECESSARY to compute DM2 on
!C        some systems.  DON'T SIMPLIFY IT.
!         DM2 = DBASE**(IMACH(16)-IMACH(14))*((DBASE**IMACH(14) - DBASE)
!     1                  + (DBASE - 1.0D0))
!         DM3 = DBASE**(-IMACH(14))
!         DM4 = DBASE**(1-IMACH(14))
!c        DM5 = DMA*0.30102 99956 63981 19521 37388 94724D0+DMB
!         DM5 = DMA*0.301029995663981195213738894724D0+DMB
!++   END
         IMACH(9) = IM9
         RMACH(1) = RM1
         RMACH(2) = RM2
         RMACH(3) = RM3
         RMACH(4) = RM4
         RMACH(5) = RM5
         DMACH(1) = DM1
         DMACH(2) = DM2
         DMACH(3) = DM3
         DMACH(4) = DM4
         DMACH(5) = DM5
      END IF

      IF (MODE .EQ. 0) THEN
         I1=IMACH(I)
      ELSE IF (MODE .EQ. 1) THEN
         R1=RMACH(I)
!                                  Here we assume MODE = 2.
      ELSE
         D1=DMACH(I)
      END IF
      RETURN
  END SUBROUTINE AMACH
  ! -------------------------------------------------------  I1MACH  -----
  INTEGER FUNCTION I1MACH(I)
      INTEGER I, I1
      REAL R1
      DOUBLE PRECISION D1
      IF (I .LT. 1  .OR.  I .GT. 16) THEN
         PRINT*,'I1MACH.. Bad argument: I =',I
         STOP 'I1MACH error'
      END IF
      CALL AMACH (0, I, I1, R1, D1)
      I1MACH = I1
      RETURN
  END FUNCTION I1MACH

  ! -------------------------------------------------------  R1MACH  -----
  REAL FUNCTION R1MACH(I)
      INTEGER I, I1
      REAL R1
      DOUBLE PRECISION D1
      IF (I .LT. 1  .OR.  I .GT. 5) THEN
         PRINT*,'R1MACH.. Bad argument: I = ',I
         STOP 'R1MACH error'
      END IF
      CALL AMACH (1, I, I1, R1, D1)
      R1MACH = R1
      RETURN
  END FUNCTION R1MACH

  ! -------------------------------------------------------  D1MACH  -----
  DOUBLE PRECISION FUNCTION D1MACH(I)
      INTEGER I, I1
      REAL R1
      DOUBLE PRECISION D1
      IF (I .LT. 1  .OR.  I .GT. 5) THEN
         PRINT*,'D1MACH.. Bad argument: I = ',I
         STOP 'D1MACH error'
      END IF
      CALL AMACH (2, I, I1, R1, D1)
      D1MACH = D1
      RETURN
  END FUNCTION D1MACH

  ! -------------------------------------------------------  AMTEST  -----
  SUBROUTINE AMTEST (TEST, D6)
! Verifies that D6 is an appropriate value for DM6.
! Returns TEST = D6 + D6 - 1, .ne. 0 if D6 is an appropriate value for
! DM6, else returns TEST = 0.  The caller uses TEST = 0 as a signal to
! try again with IEEE settings (unless that's already been done).

      DOUBLE PRECISION D6, TEST
      TEST = AMSUB1(1.D0 + D6)
!
! The comparison with 1.875E0*D6 in the line below is to guard
! against the possibility that TEST is > 0 as a result of rounding
! up in the addition of D6 to 1.
!
      IF ((TEST .EQ. 0.D0) .OR. (TEST .GT. 1.875D0*D6)) THEN
         TEST = (D6 + D6) + 1.D0
         IF (AMSUB1(TEST) .NE. 0.D0) RETURN
      END IF
      test = 0.0d0
  END SUBROUTINE AMTEST

  ! -------------------------------------------------------  AMSUB1  -----
  DOUBLE PRECISION FUNCTION AMSUB1 (TEST1)
      DOUBLE PRECISION TEST1
!     Returns the value of TEST1 - 1.
      AMSUB1 = TEST1 - 1.0D0
      RETURN
  END FUNCTION AMSUB1

  ! --------------------------------------------------------  DERFI  -----
  DOUBLE PRECISION FUNCTION DERFI (X)
!     .  Copyright (C) 1989, California Institute of Technology.
!     .  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.
!--D replaces "?": ?ERFI, ?ERFCI, ?ERFIX, ?ERM1
!>> 1996-06-18 DERFI Krogh  Changes to use .C. and C%%. J not changed.
!>> 1996-03-30 DERFI Krogh  Added external statements.
!>> 1995-11-28 DERFI Krogh  Removed multiple entries.
!>> 1995-11-03 DERFI Krogh  Removed blanks in numbers for C conversion.
!>> 1994-10-20 DERFI Krogh  Changes to use M77CON
!>> 1994-04-20 DERFI CLL Edited type stmts to make DP & SP files similar
!>> 1987-10-29 DERFI Snyder  Initial code.
!
!     For -1.0 .LT. X .LT. 1.0 calculate the inverse of the error
!     function.  That is, X = ERF(ERFI).
!
!     For 0.0 .LT. X .LT. 2.0 calculate the inverse of the
!     complementary error function.  that is, X = ERFC(ERFCI).  This
!     calculation is carried out by invoking the alternate entry *ERFCI.
!
!     If X is out of range, program execution is terminated by calling
!     the error message processor.
!
!     This subprogram uses approximations due to A. Strecok from
!     Mathematics of Computation 22, (1968) pp 144-158.
!

      DOUBLE PRECISION X
      DOUBLE PRECISION ARG, D(6), FSIGN, S
      INTEGER J
!
!     *****     Parameters     *****************************************
!
! MAX...  is the position in C of the last coefficient of a Chebyshev
!         polynomial expansion.
! MIN...  is the position in C of the first coefficient of a Chebyshev
!         polynomial expansion.
! NC      is the upper dimension of the array of coefficients.
! NDELTA  is the number of coefficients of the Chebyshev polynomial
!         expansion used to approximate R(X) in the range
!         0.9975 .LT. X .LE. 1-5.0D-16
! NLAMDA  is the number of coefficients of the Chebyshev polynomial
!         expansion used to approximate R(X) in the range
!         0.8 .LT. X .LE. 0.9975.
! NMU     is the number of coefficients of the Chebyshev polynomial
!         expansion used to approximate R(X) in the range
!         5.0D-16 .GT. 1-X .GE. 1.D-300.
! NXI     is the number of coefficients of the Chebyshev polynomial
!         expansion used to approximate DERFCI(X)/X in the
!         range 0.0 .LE. X .LE. 0.8.
!
!
!     *****     External References     ********************************
!
! D1MACH   Provides the round-off level.  Used to calculate the number
!          of coefficients to retain in each Chebyshev expansion.
! DERM1    Prints an error message and stops if X .LE. -1.0 or
!          X .GE. 1.0 (ERFI) or X .LE. 0.0 or X .GE. 2.0 (ERFCI).
! LOG      Calculates the natural logarithm.
! SQRT     Calculates the square root.
!
!
!     *****     Local Variables      ***********************************
!
! ARG     If ERFI or ERFCI is being approximated by a Chebyshev
!         expansion then ARG is the argument of ERFI or the argument
!         that would be used if ERFCI(X) were computed as ERFC(1-X),
!         that is, ARG = X if ERFI is being computed, or ARG = 1-X if
!         ERFCI is being computed.  If ERFI or ERFCI is being computed
!         using the initial approximation ERFI=SQRT(-LOG((1-X)*(1+X))),
!         then ARG is that initial approximation.
! C       contains the coefficients of polynomial expansions.  They are
!         stored in C in the order DELTA(0..37), LAMDA(0..26),
!         MU(0..25), XI(0..38).
! D       are used to scale the argument of the Chebyshev polynomial
!         expansion in the range 1.D-300 .LT. 1-X .LT. 0.2.
! DELTA   are coefficients of the Chebyshev polynomial expansion of R(X)
!         for 0.9975 .LT. X .LE. 1-5.0D-16.
! FIRST   is a logical SAVE variable indicating whether it is necessary
!         to calculate the number of coefficients to use for each
!         Chebyshev expansion.
! FSIGN   is X or 1.0 - X.  It is used to remember the sign to be
!         assigned to the function value.
! I, J    are used as indices.
! IMIN    is the minimum index of a coefficient in the Chebyshev
!         polynomial expansion to be used.
! JIX     is an array containing MINXI, MAXXI, MINLAM, MAXLAM, MINDEL,
!         MAXDEL, MINMU, MAXMU in locations -1..6
! LAMDA   are coefficients of the Chebyshev polynomial expansion of R(X)
!         for 0.8 .LT. X .LE. 0.9975.
! MU      are coefficients of the Chebyshev polynomial expansion of R(X)
!         for 5.0D-16 .GT. 1-X .GE. 1.D-300.
! S2      is 2.0 * S.
! S       is the argument of the Chebyshev polynomial expansion.
! W1..W3  are adjacent elements of the recurrence used to evaluate the
!         Chebyshev polynomial expansion.
! XI      are coefficients of the Chebyshev polynomial expansion of
!         ERFC(X)/X for 0.0 .LE. X .LE. 0.8.
!
      DATA D /-1.548813042373261659512742D0, &
               2.565490123147816151928163D0, &
              -.5594576313298323225436913D0, &
               2.287915716263357638965891D0, &
              -9.199992358830151031278420D0, &
               2.794990820124599493768426D0/
!
      fsign = x
      arg = ABS(x)
      IF (arg.LT.0.0d0 .OR. arg.GE.1.0d0)THEN
         CALL derm1 ('DERFI',1,2,'Argument out of range','X',x,'.')
!     In case the error level is shifted to zero by the caller:
         derfi = 0.0d0
         RETURN
      END IF
      IF (arg.EQ.0.0d0) THEN
         derfi = 0.0d0
         RETURN
      END IF
      IF (arg.LE.0.8d0) THEN
         s = 3.125d0*arg*arg - 1.0d0
         j = -1
      ELSE
         IF (arg.LE.0.9975d0) THEN
            j = 1
         ELSE
            j = 3
         END IF
         arg = SQRT(-LOG((1.0d0-arg)*(1.0d0+arg)))
         s = d(j)*arg + d(j+1)
      END IF
      DERFI = SIGN(arg*DERFIX(s, j), fsign)
      RETURN
  END FUNCTION DERFI

  ! -------------------------------------------------------  DERFCI  -----
  DOUBLE PRECISION FUNCTION DERFCI(X)
!     Calculate the inverse of the complementary error function.

      DOUBLE PRECISION X
      DOUBLE PRECISION ARG, D(6), FSIGN, S
      INTEGER J
      DATA D /-1.548813042373261659512742D0, &
               2.565490123147816151928163D0, &
              -.5594576313298323225436913D0, &
               2.287915716263357638965891D0, &
              -9.199992358830151031278420D0, &
               2.794990820124599493768426D0/
!
!     Decide which approximation to use, and calculate the argument of
!     the Chebyshev polynomial expansion.
!
      IF (x.LE.0.0d0 .OR. x.GE.2.0d0) THEN
         CALL derm1('DERFCI',1,2,'Argument out of range','X',x,'.')
!     In case the error level is shifted to zero by the caller:
         derfci = 0.0d0
      END IF
      IF (x.EQ.1.0d0) THEN
         derfci = 0.0d0
         RETURN
      END IF
      fsign = 1.0d0 - x
      arg = ABS(fsign)
      IF (arg.LE.0.8d0) THEN
         s = 3.125d0*arg*arg - 1.0d0
         j = -1
      ELSE
         arg = 2.0d0 - x
         IF (x.LT.1.0d0) THEN
            s = x
         ELSE
            s = arg
         END IF
         arg = SQRT(-LOG(x*arg))
         IF (s.LT.5.0d-16) THEN
            j = 5
            s = d(5)/SQRT(arg) + d(6)
         ELSE
            IF (s.GE.0.0025d0) THEN
               j = 1
            ELSE IF (s.GE.5.0d-16) THEN
               j = 3
            END IF
            s = d(j)*arg + d(j+1)
         END IF
      END IF
      DERFCI = SIGN(arg*DERFIX(s, j), fsign)
      RETURN
  END FUNCTION DERFCI

  ! -------------------------------------------------------  DERFIX  -----
  DOUBLE PRECISION FUNCTION DERFIX(S, J)
!             Subroutine where most of calculations are done.

      INTEGER MAXDEL, MAXLAM, MAXMU, MAXXI, MINDEL, MINLAM
      INTEGER MINMU, MINXI, NC, NDELTA, NLAMDA, NMU, NXI
      PARAMETER (MINDEL = 0)
      PARAMETER (NDELTA = 37)
      PARAMETER (MAXDEL = MINDEL + NDELTA)
      PARAMETER (MINLAM = MAXDEL + 1)
      PARAMETER (NLAMDA = 26)
      PARAMETER (MAXLAM = MINLAM + NLAMDA)
      PARAMETER (MINMU = MAXLAM + 1)
      PARAMETER (NMU = 25)
      PARAMETER (MAXMU = MINMU + NMU)
      PARAMETER (MINXI = MAXMU + 1)
      PARAMETER (NXI = 38)
      PARAMETER (MAXXI = MINXI + NXI)
      PARAMETER (NC = MAXXI)
      DOUBLE PRECISION C(0:NC), DELTA(0:NDELTA)
      LOGICAL FIRST
      SAVE FIRST
      INTEGER I, J, JIX(-1:6)
      SAVE JIX
      INTEGER IMIN
      DOUBLE PRECISION LAMDA(0:NLAMDA), MU(0:NMU), S, S2
      DOUBLE PRECISION W1, W2, W3
      DOUBLE PRECISION XI(0:NXI)
!
!     *****     Equivalence Statements     *****************************
!
      EQUIVALENCE (C(MINDEL),DELTA(0))
      EQUIVALENCE (C(MINLAM),LAMDA(0))
      EQUIVALENCE (C(MINMU),MU(0))
      EQUIVALENCE (C(MINXI),XI(0))
!
!     *****     Data Statements     ************************************
!
!     DELTA(J), J = 0..NDELTA
!
!++ With first index 0, save data by elements if ~.C.
      DATA DELTA(0) /  .9566797090204925274526373D0 /
      DATA DELTA(1) / -.0231070043090649036999908D0 /
      DATA DELTA(2) / -.0043742360975084077333218D0 /
      DATA DELTA(3) / -.0005765034226511854809364D0 /
      DATA DELTA(4) / -.0000109610223070923931242D0 /
      DATA DELTA(5) /  .0000251085470246442787982D0 /
      DATA DELTA(6) /  .0000105623360679477511955D0 /
      DATA DELTA(7) /  .0000027544123300306391503D0 /
      DATA DELTA(8) /  .0000004324844983283380689D0 /
      DATA DELTA(9) /   -.0000000205303366552086916D0 /
      DATA DELTA(10) / -.0000000438915366654316784D0 /
      DATA DELTA(11) / -.0000000176840095080881795D0 /
      DATA DELTA(12) / -.0000000039912890280463420D0 /
      DATA DELTA(13) / -.0000000001869324124559212D0 /
      DATA DELTA(14) /  .0000000002729227396746077D0 /
      DATA DELTA(15) /  .0000000001328172131565497D0 /
      DATA DELTA(16) /  .0000000000318342484482286D0 /
      DATA DELTA(17) /  .0000000000016700607751926D0 /
      DATA DELTA(18) / -.0000000000020364649611537D0 /
      DATA DELTA(19) / -.0000000000009648468127965D0 /
      DATA DELTA(20) / -.0000000000002195672778128D0 /
      DATA DELTA(21) / -.0000000000000095689813014D0 /
      DATA DELTA(22) /  .0000000000000137032572230D0 /
      DATA DELTA(23) /  .0000000000000062538505417D0 /
      DATA DELTA(24) /  .0000000000000014584615266D0 /
      DATA DELTA(25) /  .0000000000000001078123993D0 /
      DATA DELTA(26) / -.0000000000000000709229988D0 /
      DATA DELTA(27) / -.0000000000000000391411775D0 /
      DATA DELTA(28) / -.0000000000000000111659209D0 /
      DATA DELTA(29) / -.0000000000000000015770366D0 /
      DATA DELTA(30) /  .0000000000000000002853149D0 /
      DATA DELTA(31) /  .0000000000000000002716662D0 /
      DATA DELTA(32) /  .0000000000000000000957770D0 /
      DATA DELTA(33) /  .0000000000000000000176835D0 /
      DATA DELTA(34) / -.0000000000000000000009828D0 /
      DATA DELTA(35) / -.0000000000000000000020464D0 /
      DATA DELTA(36) / -.0000000000000000000008020D0 /
      DATA DELTA(37) / -.0000000000000000000001650D0 /
!
!     LAMDA(J), J = 0..NLAMDA
!
!++ With first index 0, save data by elements if ~.C.
      DATA LAMDA(0) /  .9121588034175537733059200D0 /
      DATA LAMDA(1) / -.0162662818676636958546661D0 /
      DATA LAMDA(2) /  .0004335564729494453650589D0 /
      DATA LAMDA(3) /  .0002144385700744592065205D0 /
      DATA LAMDA(4) /  .0000026257510757648130176D0 /
      DATA LAMDA(5) / -.0000030210910501037969912D0 /
      DATA LAMDA(6) / -.0000000124060618367572157D0 /
      DATA LAMDA(7) /  .0000000624066092999917380D0 /
      DATA LAMDA(8) / -.0000000005401247900957858D0 /
      DATA LAMDA(9) /   -.0000000014232078975315910D0 /
      DATA LAMDA(10) /  .0000000000343840281955305D0 /
      DATA LAMDA(11) /  .0000000000335848703900138D0 /
      DATA LAMDA(12) / -.0000000000014584288516512D0 /
      DATA LAMDA(13) / -.0000000000008102174258833D0 /
      DATA LAMDA(14) /  .0000000000000525324085874D0 /
      DATA LAMDA(15) /  .0000000000000197115408612D0 /
      DATA LAMDA(16) / -.0000000000000017494333828D0 /
      DATA LAMDA(17) / -.0000000000000004800596619D0 /
      DATA LAMDA(18) /  .0000000000000000557302987D0 /
      DATA LAMDA(19) /  .0000000000000000116326054D0 /
      DATA LAMDA(20) / -.0000000000000000017262489D0 /
      DATA LAMDA(21) / -.0000000000000000002784973D0 /
      DATA LAMDA(22) /  .0000000000000000000524481D0 /
      DATA LAMDA(23) /  .0000000000000000000065270D0 /
      DATA LAMDA(24) / -.0000000000000000000015707D0 /
      DATA LAMDA(25) / -.0000000000000000000001475D0 /
      DATA LAMDA(26) /  .0000000000000000000000450D0 /
!
!     MU(J), J = 0..NMU
!
!++ With first index 0, save data by elements if ~.C.
      DATA MU(0) /  .9885750640661893136460358D0 /
      DATA MU(1) /  .0108577051845994776160281D0 /
      DATA MU(2) / -.0017511651027627952494825D0 /
      DATA MU(3) /  .0000211969932065633437984D0 /
      DATA MU(4) /  .0000156648714042435087911D0 /
      DATA MU(5) / -.0000005190416869103124261D0 /
      DATA MU(6) / -.0000000371357897426717780D0 /
      DATA MU(7) /  .0000000012174308662357429D0 /
      DATA MU(8) / -.0000000001768115526613442D0 /
      DATA MU(9) /   -.0000000000119372182556161D0 /
      DATA MU(10) /  .0000000000003802505358299D0 /
      DATA MU(11) / -.0000000000000660188322362D0 /
      DATA MU(12) / -.0000000000000087917055170D0 /
      DATA MU(13) / -.0000000000000003506869329D0 /
      DATA MU(14) / -.0000000000000000697221497D0 /
      DATA MU(15) / -.0000000000000000109567941D0 /
      DATA MU(16) / -.0000000000000000011536390D0 /
      DATA MU(17) / -.0000000000000000001326235D0 /
      DATA MU(18) / -.0000000000000000000263938D0 /
      DATA MU(19) /  .0000000000000000000005341D0 /
      DATA MU(20) / -.0000000000000000000022610D0 /
      DATA MU(21) /  .0000000000000000000009552D0 /
      DATA MU(22) / -.0000000000000000000005250D0 /
      DATA MU(23) /  .0000000000000000000002487D0 /
      DATA MU(24) / -.0000000000000000000001134D0 /
      DATA MU(25) /  .0000000000000000000000420D0 /
!
!     XI(J), J = 0..NXI
!
!++ With first index 0, save data by elements if ~.C.
      DATA XI(0) /  .9928853766189408231495800D0 /
      DATA XI(1) /  .1204675161431044864647846D0 /
      DATA XI(2) /  .0160781993420999447257039D0 /
      DATA XI(3) /  .0026867044371623158279591D0 /
      DATA XI(4) /  .0004996347302357262947170D0 /
      DATA XI(5) /  .0000988982185991204409911D0 /
      DATA XI(6) /  .0000203918127639944337340D0 /
      DATA XI(7) /  .0000043272716177354218758D0 /
      DATA XI(8) /  .0000009380814128593406758D0 /
      DATA XI(9) /  .0000002067347208683427411D0 /
      DATA XI(10) /  .0000000461596991054300078D0 /
      DATA XI(11) /  .0000000104166797027146217D0 /
      DATA XI(12) /  .0000000023715009995921222D0 /
      DATA XI(13) /  .0000000005439284068471390D0 /
      DATA XI(14) /  .0000000001255489864097987D0 /
      DATA XI(15) /  .0000000000291381803663201D0 /
      DATA XI(16) /  .0000000000067949421808797D0 /
      DATA XI(17) /  .0000000000015912343331469D0 /
      DATA XI(18) /  .0000000000003740250585245D0 /
      DATA XI(19) /  .0000000000000882087762421D0 /
      DATA XI(20) /  .0000000000000208650897725D0 /
      DATA XI(21) /  .0000000000000049488041039D0 /
      DATA XI(22) /  .0000000000000011766394740D0 /
      DATA XI(23) /  .0000000000000002803855725D0 /
      DATA XI(24) /  .0000000000000000669506638D0 /
      DATA XI(25) /  .0000000000000000160165495D0 /
      DATA XI(26) /  .0000000000000000038382583D0 /
      DATA XI(27) /  .0000000000000000009212851D0 /
      DATA XI(28) /  .0000000000000000002214615D0 /
      DATA XI(29) /  .0000000000000000000533091D0 /
      DATA XI(30) /  .0000000000000000000128488D0 /
      DATA XI(31) /  .0000000000000000000031006D0 /
      DATA XI(32) /  .0000000000000000000007491D0 /
      DATA XI(33) /  .0000000000000000000001812D0 /
      DATA XI(34) /  .0000000000000000000000439D0 /
      DATA XI(35) /  .0000000000000000000000106D0 /
      DATA XI(36) /  .0000000000000000000000026D0 /
      DATA XI(37) /  .0000000000000000000000006D0 /
      DATA XI(38) /  .0000000000000000000000002D0 /
!
      DATA FIRST /.TRUE./
!
      DATA JIX /MINXI, MAXXI, MINLAM, MAXLAM, MINDEL, MAXDEL, &
                MINMU, MAXMU/
!
!     *****     Procedures     *****************************************
!
!     Decide which approximation to use, and calculate the argument of
!     the Chebyshev polynomial expansion.
!
!
!     If this is the first call, calculate the degree of each expansion.
!
      IF (first) THEN
         first = .FALSE.
         s2 = 0.5d0*d1mach(3)
         DO 120 imin = -1, 5, 2
            DO 110 i = jix(imin), jix(imin+1)
               IF (ABS(c(i)).LT.s2) THEN
                  jix(imin+1) = i
                  go to 120
               END IF
110         CONTINUE
120      CONTINUE
      END IF
!
!     Evaluate the Chebyshev polynomial expansion.
!
      s2 = s + s
      w1 = 0.0d0
      w2 = 0.0d0
      imin = jix(j)
      i = jix(j+1)
200      w3 = w2
         w2 = w1
         w1 = (s2*w2 - w3) + c(i)
         i = i - 1
         IF (i.GT.imin) go to 200
      derfix = (s*w1 - w2) + c(imin)
      RETURN
  END FUNCTION DERFIX

  ! --------------------------------------------------------  SERFI  -----
  REAL             FUNCTION SERFI (X)
!     .  Copyright (C) 1989, California Institute of Technology.
!     .  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.
!--S replaces "?": ?ERFI, ?ERFCI, ?ERFIX, ?ERM1
!>> 1996-06-18 SERFI Krogh  Changes to use .C. and C%%. J not changed.
!>> 1996-03-30 SERFI Krogh  Added external statements.
!>> 1995-11-28 SERFI Krogh  Removed multiple entries.
!>> 1995-11-03 SERFI Krogh  Removed blanks in numbers for C conversion.
!>> 1994-10-20 SERFI Krogh  Changes to use M77CON
!>> 1994-04-20 SERFI CLL Edited type stmts to make DP & SP files similar
!>> 1987-10-29 SERFI Snyder  Initial code.
!
!     For -1.0 .LT. X .LT. 1.0 calculate the inverse of the error
!     function.  That is, X = ERF(ERFI).
!
!     For 0.0 .LT. X .LT. 2.0 calculate the inverse of the
!     complementary error function.  that is, X = ERFC(ERFCI).  This
!     calculation is carried out by invoking the alternate entry *ERFCI.
!
!     If X is out of range, program execution is terminated by calling
!     the error message processor.
!
!     This subprogram uses approximations due to A. Strecok from
!     Mathematics of Computation 22, (1968) pp 144-158.
!

      REAL             X
      REAL             ARG, D(6), FSIGN, S
      INTEGER J
!
!     *****     Parameters     *****************************************
!
! MAX...  is the position in C of the last coefficient of a Chebyshev
!         polynomial expansion.
! MIN...  is the position in C of the first coefficient of a Chebyshev
!         polynomial expansion.
! NC      is the upper dimension of the array of coefficients.
! NDELTA  is the number of coefficients of the Chebyshev polynomial
!         expansion used to approximate R(X) in the range
!         0.9975 .LT. X .LE. 1-5.0E-16
! NLAMDA  is the number of coefficients of the Chebyshev polynomial
!         expansion used to approximate R(X) in the range
!         0.8 .LT. X .LE. 0.9975.
! NMU     is the number of coefficients of the Chebyshev polynomial
!         expansion used to approximate R(X) in the range
!         5.0E-16 .GT. 1-X .GE. 1.E-300.
! NXI     is the number of coefficients of the Chebyshev polynomial
!         expansion used to approximate SERFCI(X)/X in the
!         range 0.0 .LE. X .LE. 0.8.
!
!
!     *****     External References     ********************************
!
! R1MACH   Provides the round-off level.  Used to calculate the number
!          of coefficients to retain in each Chebyshev expansion.
! SERM1    Prints an error message and stops if X .LE. -1.0 or
!          X .GE. 1.0 (ERFI) or X .LE. 0.0 or X .GE. 2.0 (ERFCI).
! LOG      Calculates the natural logarithm.
! SQRT     Calculates the square root.
!
!
!     *****     Local Variables      ***********************************
!
! ARG     If ERFI or ERFCI is being approximated by a Chebyshev
!         expansion then ARG is the argument of ERFI or the argument
!         that would be used if ERFCI(X) were computed as ERFC(1-X),
!         that is, ARG = X if ERFI is being computed, or ARG = 1-X if
!         ERFCI is being computed.  If ERFI or ERFCI is being computed
!         using the initial approximation ERFI=SQRT(-LOG((1-X)*(1+X))),
!         then ARG is that initial approximation.
! C       contains the coefficients of polynomial expansions.  They are
!         stored in C in the order DELTA(0..37), LAMDA(0..26),
!         MU(0..25), XI(0..38).
! D       are used to scale the argument of the Chebyshev polynomial
!         expansion in the range 1.E-300 .LT. 1-X .LT. 0.2.
! DELTA   are coefficients of the Chebyshev polynomial expansion of R(X)
!         for 0.9975 .LT. X .LE. 1-5.0E-16.
! FIRST   is a logical SAVE variable indicating whether it is necessary
!         to calculate the number of coefficients to use for each
!         Chebyshev expansion.
! FSIGN   is X or 1.0 - X.  It is used to remember the sign to be
!         assigned to the function value.
! I, J    are used as indices.
! IMIN    is the minimum index of a coefficient in the Chebyshev
!         polynomial expansion to be used.
! JIX     is an array containing MINXI, MAXXI, MINLAM, MAXLAM, MINDEL,
!         MAXDEL, MINMU, MAXMU in locations -1..6
! LAMDA   are coefficients of the Chebyshev polynomial expansion of R(X)
!         for 0.8 .LT. X .LE. 0.9975.
! MU      are coefficients of the Chebyshev polynomial expansion of R(X)
!         for 5.0E-16 .GT. 1-X .GE. 1.E-300.
! S2      is 2.0 * S.
! S       is the argument of the Chebyshev polynomial expansion.
! W1..W3  are adjacent elements of the recurrence used to evaluate the
!         Chebyshev polynomial expansion.
! XI      are coefficients of the Chebyshev polynomial expansion of
!         ERFC(X)/X for 0.0 .LE. X .LE. 0.8.
!
      DATA D /-1.548813042373261659512742E0, &
               2.565490123147816151928163E0, &
              -.5594576313298323225436913E0, &
               2.287915716263357638965891E0, &
              -9.199992358830151031278420E0, &
               2.794990820124599493768426E0/
!
      fsign = x
      arg = ABS(x)
      IF (arg.LT.0.0e0 .OR. arg.GE.1.0e0)THEN
         CALL serm1 ('SERFI',1,2,'Argument out of range','X',x,'.')
!     In case the error level is shifted to zero by the caller:
         serfi = 0.0e0
         RETURN
      END IF
      IF (arg.EQ.0.0e0) THEN
         serfi = 0.0e0
         RETURN
      END IF
      IF (arg.LE.0.8e0) THEN
         s = 3.125e0*arg*arg - 1.0e0
         j = -1
      ELSE
         IF (arg.LE.0.9975e0) THEN
            j = 1
         ELSE
            j = 3
         END IF
         arg = SQRT(-LOG((1.0e0-arg)*(1.0e0+arg)))
         s = d(j)*arg + d(j+1)
      END IF
      SERFI = SIGN(arg*SERFIX(s, j), fsign)
      RETURN
    END FUNCTION SERFI

  ! -------------------------------------------------------  SERFCI  -----
  REAL             FUNCTION SERFCI(X)
!     Calculate the inverse of the complementary error function.
!

      REAL             X
      REAL             ARG, D(6), FSIGN, S
      INTEGER J
      DATA D /-1.548813042373261659512742E0, &
               2.565490123147816151928163E0, &
              -.5594576313298323225436913E0, &
               2.287915716263357638965891E0, &
              -9.199992358830151031278420E0, &
               2.794990820124599493768426E0/
!
!     Decide which approximation to use, and calculate the argument of
!     the Chebyshev polynomial expansion.
!
      IF (x.LE.0.0e0 .OR. x.GE.2.0e0) THEN
         CALL serm1('SERFCI',1,2,'Argument out of range','X',x,'.')
!     In case the error level is shifted to zero by the caller:
         serfci = 0.0e0
      END IF
      IF (x.EQ.1.0e0) THEN
         serfci = 0.0e0
         RETURN
      END IF
      fsign = 1.0e0 - x
      arg = ABS(fsign)
      IF (arg.LE.0.8e0) THEN
         s = 3.125e0*arg*arg - 1.0e0
         j = -1
      ELSE
         arg = 2.0e0 - x
         IF (x.LT.1.0e0) THEN
            s = x
         ELSE
            s = arg
         END IF
         arg = SQRT(-LOG(x*arg))
         IF (s.LT.5.0e-16) THEN
            j = 5
            s = d(5)/SQRT(arg) + d(6)
         ELSE
            IF (s.GE.0.0025e0) THEN
               j = 1
            ELSE IF (s.GE.5.0e-16) THEN
               j = 3
            END IF
            s = d(j)*arg + d(j+1)
         END IF
      END IF
      SERFCI = SIGN(arg*SERFIX(s, j), fsign)
      RETURN
  END FUNCTION SERFCI

  ! -------------------------------------------------------  SERFIX  -----
  REAL             FUNCTION SERFIX(S, J)
!             Subroutine where most of calculations are done.

      INTEGER MAXDEL, MAXLAM, MAXMU, MAXXI, MINDEL, MINLAM
      INTEGER MINMU, MINXI, NC, NDELTA, NLAMDA, NMU, NXI
      PARAMETER (MINDEL = 0)
      PARAMETER (NDELTA = 37)
      PARAMETER (MAXDEL = MINDEL + NDELTA)
      PARAMETER (MINLAM = MAXDEL + 1)
      PARAMETER (NLAMDA = 26)
      PARAMETER (MAXLAM = MINLAM + NLAMDA)
      PARAMETER (MINMU = MAXLAM + 1)
      PARAMETER (NMU = 25)
      PARAMETER (MAXMU = MINMU + NMU)
      PARAMETER (MINXI = MAXMU + 1)
      PARAMETER (NXI = 38)
      PARAMETER (MAXXI = MINXI + NXI)
      PARAMETER (NC = MAXXI)

      REAL             C(0:NC), DELTA(0:NDELTA)
      LOGICAL FIRST
      SAVE FIRST
      INTEGER I, J, JIX(-1:6)
      SAVE JIX
      INTEGER IMIN
      REAL             LAMDA(0:NLAMDA), MU(0:NMU), S, S2
      REAL             W1, W2, W3
      REAL             XI(0:NXI)
!
!     *****     Equivalence Statements     *****************************
!
      EQUIVALENCE (C(MINDEL),DELTA(0))
      EQUIVALENCE (C(MINLAM),LAMDA(0))
      EQUIVALENCE (C(MINMU),MU(0))
      EQUIVALENCE (C(MINXI),XI(0))
!
!     *****     Data Statements     ************************************
!
!     DELTA(J), J = 0..NDELTA
!
!++ With first index 0, save data by elements if ~.C.
      DATA DELTA(0) /  .9566797090204925274526373E0 /
      DATA DELTA(1) / -.0231070043090649036999908E0 /
      DATA DELTA(2) / -.0043742360975084077333218E0 /
      DATA DELTA(3) / -.0005765034226511854809364E0 /
      DATA DELTA(4) / -.0000109610223070923931242E0 /
      DATA DELTA(5) /  .0000251085470246442787982E0 /
      DATA DELTA(6) /  .0000105623360679477511955E0 /
      DATA DELTA(7) /  .0000027544123300306391503E0 /
      DATA DELTA(8) /  .0000004324844983283380689E0 /
      DATA DELTA(9) /   -.0000000205303366552086916E0 /
      DATA DELTA(10) / -.0000000438915366654316784E0 /
      DATA DELTA(11) / -.0000000176840095080881795E0 /
      DATA DELTA(12) / -.0000000039912890280463420E0 /
      DATA DELTA(13) / -.0000000001869324124559212E0 /
      DATA DELTA(14) /  .0000000002729227396746077E0 /
      DATA DELTA(15) /  .0000000001328172131565497E0 /
      DATA DELTA(16) /  .0000000000318342484482286E0 /
      DATA DELTA(17) /  .0000000000016700607751926E0 /
      DATA DELTA(18) / -.0000000000020364649611537E0 /
      DATA DELTA(19) / -.0000000000009648468127965E0 /
      DATA DELTA(20) / -.0000000000002195672778128E0 /
      DATA DELTA(21) / -.0000000000000095689813014E0 /
      DATA DELTA(22) /  .0000000000000137032572230E0 /
      DATA DELTA(23) /  .0000000000000062538505417E0 /
      DATA DELTA(24) /  .0000000000000014584615266E0 /
      DATA DELTA(25) /  .0000000000000001078123993E0 /
      DATA DELTA(26) / -.0000000000000000709229988E0 /
      DATA DELTA(27) / -.0000000000000000391411775E0 /
      DATA DELTA(28) / -.0000000000000000111659209E0 /
      DATA DELTA(29) / -.0000000000000000015770366E0 /
      DATA DELTA(30) /  .0000000000000000002853149E0 /
      DATA DELTA(31) /  .0000000000000000002716662E0 /
      DATA DELTA(32) /  .0000000000000000000957770E0 /
      DATA DELTA(33) /  .0000000000000000000176835E0 /
      DATA DELTA(34) / -.0000000000000000000009828E0 /
      DATA DELTA(35) / -.0000000000000000000020464E0 /
      DATA DELTA(36) / -.0000000000000000000008020E0 /
      DATA DELTA(37) / -.0000000000000000000001650E0 /
!
!     LAMDA(J), J = 0..NLAMDA
!
!++ With first index 0, save data by elements if ~.C.
      DATA LAMDA(0) /  .9121588034175537733059200E0 /
      DATA LAMDA(1) / -.0162662818676636958546661E0 /
      DATA LAMDA(2) /  .0004335564729494453650589E0 /
      DATA LAMDA(3) /  .0002144385700744592065205E0 /
      DATA LAMDA(4) /  .0000026257510757648130176E0 /
      DATA LAMDA(5) / -.0000030210910501037969912E0 /
      DATA LAMDA(6) / -.0000000124060618367572157E0 /
      DATA LAMDA(7) /  .0000000624066092999917380E0 /
      DATA LAMDA(8) / -.0000000005401247900957858E0 /
      DATA LAMDA(9) /   -.0000000014232078975315910E0 /
      DATA LAMDA(10) /  .0000000000343840281955305E0 /
      DATA LAMDA(11) /  .0000000000335848703900138E0 /
      DATA LAMDA(12) / -.0000000000014584288516512E0 /
      DATA LAMDA(13) / -.0000000000008102174258833E0 /
      DATA LAMDA(14) /  .0000000000000525324085874E0 /
      DATA LAMDA(15) /  .0000000000000197115408612E0 /
      DATA LAMDA(16) / -.0000000000000017494333828E0 /
      DATA LAMDA(17) / -.0000000000000004800596619E0 /
      DATA LAMDA(18) /  .0000000000000000557302987E0 /
      DATA LAMDA(19) /  .0000000000000000116326054E0 /
      DATA LAMDA(20) / -.0000000000000000017262489E0 /
      DATA LAMDA(21) / -.0000000000000000002784973E0 /
      DATA LAMDA(22) /  .0000000000000000000524481E0 /
      DATA LAMDA(23) /  .0000000000000000000065270E0 /
      DATA LAMDA(24) / -.0000000000000000000015707E0 /
      DATA LAMDA(25) / -.0000000000000000000001475E0 /
      DATA LAMDA(26) /  .0000000000000000000000450E0 /
!
!     MU(J), J = 0..NMU
!
!++ With first index 0, save data by elements if ~.C.
      DATA MU(0) /  .9885750640661893136460358E0 /
      DATA MU(1) /  .0108577051845994776160281E0 /
      DATA MU(2) / -.0017511651027627952494825E0 /
      DATA MU(3) /  .0000211969932065633437984E0 /
      DATA MU(4) /  .0000156648714042435087911E0 /
      DATA MU(5) / -.0000005190416869103124261E0 /
      DATA MU(6) / -.0000000371357897426717780E0 /
      DATA MU(7) /  .0000000012174308662357429E0 /
      DATA MU(8) / -.0000000001768115526613442E0 /
      DATA MU(9) /   -.0000000000119372182556161E0 /
      DATA MU(10) /  .0000000000003802505358299E0 /
      DATA MU(11) / -.0000000000000660188322362E0 /
      DATA MU(12) / -.0000000000000087917055170E0 /
      DATA MU(13) / -.0000000000000003506869329E0 /
      DATA MU(14) / -.0000000000000000697221497E0 /
      DATA MU(15) / -.0000000000000000109567941E0 /
      DATA MU(16) / -.0000000000000000011536390E0 /
      DATA MU(17) / -.0000000000000000001326235E0 /
      DATA MU(18) / -.0000000000000000000263938E0 /
      DATA MU(19) /  .0000000000000000000005341E0 /
      DATA MU(20) / -.0000000000000000000022610E0 /
      DATA MU(21) /  .0000000000000000000009552E0 /
      DATA MU(22) / -.0000000000000000000005250E0 /
      DATA MU(23) /  .0000000000000000000002487E0 /
      DATA MU(24) / -.0000000000000000000001134E0 /
      DATA MU(25) /  .0000000000000000000000420E0 /
!
!     XI(J), J = 0..NXI
!
!++ With first index 0, save data by elements if ~.C.
      DATA XI(0) /  .9928853766189408231495800E0 /
      DATA XI(1) /  .1204675161431044864647846E0 /
      DATA XI(2) /  .0160781993420999447257039E0 /
      DATA XI(3) /  .0026867044371623158279591E0 /
      DATA XI(4) /  .0004996347302357262947170E0 /
      DATA XI(5) /  .0000988982185991204409911E0 /
      DATA XI(6) /  .0000203918127639944337340E0 /
      DATA XI(7) /  .0000043272716177354218758E0 /
      DATA XI(8) /  .0000009380814128593406758E0 /
      DATA XI(9) /  .0000002067347208683427411E0 /
      DATA XI(10) /  .0000000461596991054300078E0 /
      DATA XI(11) /  .0000000104166797027146217E0 /
      DATA XI(12) /  .0000000023715009995921222E0 /
      DATA XI(13) /  .0000000005439284068471390E0 /
      DATA XI(14) /  .0000000001255489864097987E0 /
      DATA XI(15) /  .0000000000291381803663201E0 /
      DATA XI(16) /  .0000000000067949421808797E0 /
      DATA XI(17) /  .0000000000015912343331469E0 /
      DATA XI(18) /  .0000000000003740250585245E0 /
      DATA XI(19) /  .0000000000000882087762421E0 /
      DATA XI(20) /  .0000000000000208650897725E0 /
      DATA XI(21) /  .0000000000000049488041039E0 /
      DATA XI(22) /  .0000000000000011766394740E0 /
      DATA XI(23) /  .0000000000000002803855725E0 /
      DATA XI(24) /  .0000000000000000669506638E0 /
      DATA XI(25) /  .0000000000000000160165495E0 /
      DATA XI(26) /  .0000000000000000038382583E0 /
      DATA XI(27) /  .0000000000000000009212851E0 /
      DATA XI(28) /  .0000000000000000002214615E0 /
      DATA XI(29) /  .0000000000000000000533091E0 /
      DATA XI(30) /  .0000000000000000000128488E0 /
      DATA XI(31) /  .0000000000000000000031006E0 /
      DATA XI(32) /  .0000000000000000000007491E0 /
      DATA XI(33) /  .0000000000000000000001812E0 /
      DATA XI(34) /  .0000000000000000000000439E0 /
      DATA XI(35) /  .0000000000000000000000106E0 /
      DATA XI(36) /  .0000000000000000000000026E0 /
      DATA XI(37) /  .0000000000000000000000006E0 /
      DATA XI(38) /  .0000000000000000000000002E0 /
!
      DATA FIRST /.TRUE./
!
      DATA JIX /MINXI, MAXXI, MINLAM, MAXLAM, MINDEL, MAXDEL, &
                MINMU, MAXMU/
!
!     *****     Procedures     *****************************************
!
!     Decide which approximation to use, and calculate the argument of
!     the Chebyshev polynomial expansion.
!
!
!     If this is the first call, calculate the degree of each expansion.
!
      IF (first) THEN
         first = .FALSE.
         s2 = 0.5e0*r1mach(3)
         DO 120 imin = -1, 5, 2
            DO 110 i = jix(imin), jix(imin+1)
               IF (ABS(c(i)).LT.s2) THEN
                  jix(imin+1) = i
                  go to 120
               END IF
110         CONTINUE
120      CONTINUE
      END IF
!
!     Evaluate the Chebyshev polynomial expansion.
!
      s2 = s + s
      w1 = 0.0e0
      w2 = 0.0e0
      imin = jix(j)
      i = jix(j+1)
200      w3 = w2
         w2 = w1
         w1 = (s2*w2 - w3) + c(i)
         i = i - 1
         IF (i.GT.imin) go to 200
      serfix = (s*w1 - w2) + c(imin)
      RETURN
  END FUNCTION SERFIX
  
!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSSpecialFunctions.f90,v 2.8 2013/08/12 23:47:25 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MLSSpecialFunctions
!=============================================================================

!
! $Log: MLSSpecialFunctions.f90,v $
! Revision 2.8  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.7  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.6  2009/10/21 22:47:36  pwagner
! primeFactors breaks down composite integers
!
! Revision 2.5  2009/06/23 18:24:06  pwagner
! Added prime, isPrime, nextPrime
!
! Revision 2.4  2007/07/25 20:09:42  vsnyder
! Delete USE for unused entity
!
! Revision 2.3  2007/05/17 17:25:17  pwagner
! error function stuff from l1/MathUtils.f90 moved here
!
! Revision 2.2  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.1  2004/06/02 21:03:16  pwagner
! First commit
!
@


2.8
log
@FindSomethings moved to MLSFinds module
@
text
@d16 2
a17 4
  USE ERMSG_M, ONLY: DERM1, SERM1
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
  use MLSFINDS, only: FINDFIRST, FINDLAST
  use MLSStringLists, only: READINTSFROMLIST
a35 4
! isPrime                  Is arg prime?
! nextPrime                Next prime > arg
! prime                    nth prime
! primeFactors             break arg into its prime factors
a43 4
! log isPrime(int n)
! int nextPrime(int n)
! int prime(int n)
! int primeFactors( int n, int[:] factors, [int[:] powers] )
a47 1
  public :: isPrime, nextPrime, prime, primeFactors
a52 2
  integer, parameter :: MAXNUMPRIMES = 1229
  integer, dimension(MAXNUMPRIMES), save :: primenumbers = -999
a53 260

  logical function isPrime(n)
    ! Return TRUE if arg is prime, FALSE if not
    ! Method:
    ! if n is < M (largest of stored array) primenumbers, 
    ! just check if n is an element of the array
    ! Otherwise, check if arg is divisible by any of them
    ! Obvious bug:
    ! If n is too large (i.e., n > M^2) it might be divisible
    ! by a prime too large to be in the array
    ! Args
    integer, intent(in) :: n
    ! Internal variables
    integer :: kM
    integer :: sqrtn
    ! Executable
    isPrime = .false.
    if ( n < 2 ) return
    ! Due to poor coding practices, we must initialize the primenumbers array
    ! by attempting to access it via the prime function
    kM = prime(1)
    ! print *, 'maxval(primenumbers): ', maxval(primenumbers)
    if ( n < maxval(primenumbers)+1 ) then
      isPrime = any(n == primenumbers)
      return
    endif
    sqrtn = sqrt(n * 1.0)
    kM = FindFirst( primenumbers > sqrtn )
    if ( kM < 1 ) kM = MAXNUMPRIMES
    ! print *, 'kM: ', kM
    isPrime = all( mod(n, primenumbers) > 0 )
  end function isPrime

  function NextPrime(n) result(next)
    ! Returns the next prime number greater than the arg n
    ! Method:
    ! Starting with n, we'll check each integer until we find one that is prime
    ! Args
    integer, intent(in) :: n ! E.g., if n=100 returns 101 which is next prime > 100
    integer :: next
    ! Executable
    next = 2
    if ( n < 3 ) return
    ! The following trick starts at the next odd integer in case n is even
    ! (Because no even integer > 2 is prime)
    next = n + ( 1 - mod(n, 2) )
    do
      if ( isPrime(next) ) return
      next = next + 2
    enddo
  end function NextPrime

  integer function prime(n)
    ! Returns the nth prime number
    ! Args
    integer, intent(in) :: n ! E.g., if n=1 returns 2 which is first prime
    prime = -999
    if ( n < 1 .or. n > MAXNUMPRIMES ) return
    if ( primenumbers(1) > 0 ) then
      prime = primenumbers(n)
      return
    endif
    ! Initializing
    ! We need to build array of primenumbers
    call appendValues(primenumbers, '    2     3     5     7    11    13    17    19    23    29')
    call appendValues(primenumbers, '   31    37    41    43    47    53    59    61    67    71')
    call appendValues(primenumbers, '   73    79    83    89    97   101   103   107   109   113')
    call appendValues(primenumbers, '  127   131   137   139   149   151   157   163   167   173')
    call appendValues(primenumbers, '  179   181   191   193   197   199   211   223   227   229')
    call appendValues(primenumbers, '  233   239   241   251   257   263   269   271   277   281')
    call appendValues(primenumbers, '  283   293   307   311   313   317   331   337   347   349')
    call appendValues(primenumbers, '  353   359   367   373   379   383   389   397   401   409')
    call appendValues(primenumbers, '  419   421   431   433   439   443   449   457   461   463')
    call appendValues(primenumbers, '  467   479   487   491   499   503   509   521   523   541')
    call appendValues(primenumbers, '  547   557   563   569   571   577   587   593   599   601')
    call appendValues(primenumbers, '  607   613   617   619   631   641   643   647   653   659')
    call appendValues(primenumbers, '  661   673   677   683   691   701   709   719   727   733')
    call appendValues(primenumbers, '  739   743   751   757   761   769   773   787   797   809')
    call appendValues(primenumbers, '  811   821   823   827   829   839   853   857   859   863')
    call appendValues(primenumbers, '  877   881   883   887   907   911   919   929   937   941')
    call appendValues(primenumbers, '  947   953   967   971   977   983   991   997  1009  1013')
    call appendValues(primenumbers, ' 1019  1021  1031  1033  1039  1049  1051  1061  1063  1069')
    call appendValues(primenumbers, ' 1087  1091  1093  1097  1103  1109  1117  1123  1129  1151')
    call appendValues(primenumbers, ' 1153  1163  1171  1181  1187  1193  1201  1213  1217  1223')
    call appendValues(primenumbers, ' 1229  1231  1237  1249  1259  1277  1279  1283  1289  1291')
    call appendValues(primenumbers, ' 1297  1301  1303  1307  1319  1321  1327  1361  1367  1373')
    call appendValues(primenumbers, ' 1381  1399  1409  1423  1427  1429  1433  1439  1447  1451')
    call appendValues(primenumbers, ' 1453  1459  1471  1481  1483  1487  1489  1493  1499  1511')
    call appendValues(primenumbers, ' 1523  1531  1543  1549  1553  1559  1567  1571  1579  1583')
    call appendValues(primenumbers, ' 1597  1601  1607  1609  1613  1619  1621  1627  1637  1657')
    call appendValues(primenumbers, ' 1663  1667  1669  1693  1697  1699  1709  1721  1723  1733')
    call appendValues(primenumbers, ' 1741  1747  1753  1759  1777  1783  1787  1789  1801  1811')
    call appendValues(primenumbers, ' 1823  1831  1847  1861  1867  1871  1873  1877  1879  1889')
    call appendValues(primenumbers, ' 1901  1907  1913  1931  1933  1949  1951  1973  1979  1987')
    call appendValues(primenumbers, ' 1993  1997  1999  2003  2011  2017  2027  2029  2039  2053')
    call appendValues(primenumbers, ' 2063  2069  2081  2083  2087  2089  2099  2111  2113  2129')
    call appendValues(primenumbers, ' 2131  2137  2141  2143  2153  2161  2179  2203  2207  2213')
    call appendValues(primenumbers, ' 2221  2237  2239  2243  2251  2267  2269  2273  2281  2287')
    call appendValues(primenumbers, ' 2293  2297  2309  2311  2333  2339  2341  2347  2351  2357')
    call appendValues(primenumbers, ' 2371  2377  2381  2383  2389  2393  2399  2411  2417  2423')
    call appendValues(primenumbers, ' 2437  2441  2447  2459  2467  2473  2477  2503  2521  2531')
    call appendValues(primenumbers, ' 2539  2543  2549  2551  2557  2579  2591  2593  2609  2617')
    call appendValues(primenumbers, ' 2621  2633  2647  2657  2659  2663  2671  2677  2683  2687')
    call appendValues(primenumbers, ' 2689  2693  2699  2707  2711  2713  2719  2729  2731  2741')
    call appendValues(primenumbers, ' 2749  2753  2767  2777  2789  2791  2797  2801  2803  2819')
    call appendValues(primenumbers, ' 2833  2837  2843  2851  2857  2861  2879  2887  2897  2903')
    call appendValues(primenumbers, ' 2909  2917  2927  2939  2953  2957  2963  2969  2971  2999')
    call appendValues(primenumbers, ' 3001  3011  3019  3023  3037  3041  3049  3061  3067  3079')
    call appendValues(primenumbers, ' 3083  3089  3109  3119  3121  3137  3163  3167  3169  3181')
    call appendValues(primenumbers, ' 3187  3191  3203  3209  3217  3221  3229  3251  3253  3257')
    call appendValues(primenumbers, ' 3259  3271  3299  3301  3307  3313  3319  3323  3329  3331')
    call appendValues(primenumbers, ' 3343  3347  3359  3361  3371  3373  3389  3391  3407  3413')
    call appendValues(primenumbers, ' 3433  3449  3457  3461  3463  3467  3469  3491  3499  3511')
    call appendValues(primenumbers, ' 3517  3527  3529  3533  3539  3541  3547  3557  3559  3571')
    call appendValues(primenumbers, ' 3581  3583  3593  3607  3613  3617  3623  3631  3637  3643')
    call appendValues(primenumbers, ' 3659  3671  3673  3677  3691  3697  3701  3709  3719  3727')
    call appendValues(primenumbers, ' 3733  3739  3761  3767  3769  3779  3793  3797  3803  3821')
    call appendValues(primenumbers, ' 3823  3833  3847  3851  3853  3863  3877  3881  3889  3907')
    call appendValues(primenumbers, ' 3911  3917  3919  3923  3929  3931  3943  3947  3967  3989')
    call appendValues(primenumbers, ' 4001  4003  4007  4013  4019  4021  4027  4049  4051  4057')
    call appendValues(primenumbers, ' 4073  4079  4091  4093  4099  4111  4127  4129  4133  4139')
    call appendValues(primenumbers, ' 4153  4157  4159  4177  4201  4211  4217  4219  4229  4231')
    call appendValues(primenumbers, ' 4241  4243  4253  4259  4261  4271  4273  4283  4289  4297')
    call appendValues(primenumbers, ' 4327  4337  4339  4349  4357  4363  4373  4391  4397  4409')
    call appendValues(primenumbers, ' 4421  4423  4441  4447  4451  4457  4463  4481  4483  4493')
    call appendValues(primenumbers, ' 4507  4513  4517  4519  4523  4547  4549  4561  4567  4583')
    call appendValues(primenumbers, ' 4591  4597  4603  4621  4637  4639  4643  4649  4651  4657')
    call appendValues(primenumbers, ' 4663  4673  4679  4691  4703  4721  4723  4729  4733  4751')
    call appendValues(primenumbers, ' 4759  4783  4787  4789  4793  4799  4801  4813  4817  4831')
    call appendValues(primenumbers, ' 4861  4871  4877  4889  4903  4909  4919  4931  4933  4937')
    call appendValues(primenumbers, ' 4943  4951  4957  4967  4969  4973  4987  4993  4999  5003')
    call appendValues(primenumbers, ' 5009  5011  5021  5023  5039  5051  5059  5077  5081  5087')
    call appendValues(primenumbers, ' 5099  5101  5107  5113  5119  5147  5153  5167  5171  5179')
    call appendValues(primenumbers, ' 5189  5197  5209  5227  5231  5233  5237  5261  5273  5279')
    call appendValues(primenumbers, ' 5281  5297  5303  5309  5323  5333  5347  5351  5381  5387')
    call appendValues(primenumbers, ' 5393  5399  5407  5413  5417  5419  5431  5437  5441  5443')
    call appendValues(primenumbers, ' 5449  5471  5477  5479  5483  5501  5503  5507  5519  5521')
    call appendValues(primenumbers, ' 5527  5531  5557  5563  5569  5573  5581  5591  5623  5639')
    call appendValues(primenumbers, ' 5641  5647  5651  5653  5657  5659  5669  5683  5689  5693')
    call appendValues(primenumbers, ' 5701  5711  5717  5737  5741  5743  5749  5779  5783  5791')
    call appendValues(primenumbers, ' 5801  5807  5813  5821  5827  5839  5843  5849  5851  5857')
    call appendValues(primenumbers, ' 5861  5867  5869  5879  5881  5897  5903  5923  5927  5939')
    call appendValues(primenumbers, ' 5953  5981  5987  6007  6011  6029  6037  6043  6047  6053')
    call appendValues(primenumbers, ' 6067  6073  6079  6089  6091  6101  6113  6121  6131  6133')
    call appendValues(primenumbers, ' 6143  6151  6163  6173  6197  6199  6203  6211  6217  6221')
    call appendValues(primenumbers, ' 6229  6247  6257  6263  6269  6271  6277  6287  6299  6301')
    call appendValues(primenumbers, ' 6311  6317  6323  6329  6337  6343  6353  6359  6361  6367')
    call appendValues(primenumbers, ' 6373  6379  6389  6397  6421  6427  6449  6451  6469  6473')
    call appendValues(primenumbers, ' 6481  6491  6521  6529  6547  6551  6553  6563  6569  6571')
    call appendValues(primenumbers, ' 6577  6581  6599  6607  6619  6637  6653  6659  6661  6673')
    call appendValues(primenumbers, ' 6679  6689  6691  6701  6703  6709  6719  6733  6737  6761')
    call appendValues(primenumbers, ' 6763  6779  6781  6791  6793  6803  6823  6827  6829  6833')
    call appendValues(primenumbers, ' 6841  6857  6863  6869  6871  6883  6899  6907  6911  6917')
    call appendValues(primenumbers, ' 6947  6949  6959  6961  6967  6971  6977  6983  6991  6997')
    call appendValues(primenumbers, ' 7001  7013  7019  7027  7039  7043  7057  7069  7079  7103')
    call appendValues(primenumbers, ' 7109  7121  7127  7129  7151  7159  7177  7187  7193  7207')
    call appendValues(primenumbers, ' 7211  7213  7219  7229  7237  7243  7247  7253  7283  7297')
    call appendValues(primenumbers, ' 7307  7309  7321  7331  7333  7349  7351  7369  7393  7411')
    call appendValues(primenumbers, ' 7417  7433  7451  7457  7459  7477  7481  7487  7489  7499')
    call appendValues(primenumbers, ' 7507  7517  7523  7529  7537  7541  7547  7549  7559  7561')
    call appendValues(primenumbers, ' 7573  7577  7583  7589  7591  7603  7607  7621  7639  7643')
    call appendValues(primenumbers, ' 7649  7669  7673  7681  7687  7691  7699  7703  7717  7723')
    call appendValues(primenumbers, ' 7727  7741  7753  7757  7759  7789  7793  7817  7823  7829')
    call appendValues(primenumbers, ' 7841  7853  7867  7873  7877  7879  7883  7901  7907  7919')
    call appendValues(primenumbers, ' 7927  7933  7937  7949  7951  7963  7993  8009  8011  8017')
    call appendValues(primenumbers, ' 8039  8053  8059  8069  8081  8087  8089  8093  8101  8111')
    call appendValues(primenumbers, ' 8117  8123  8147  8161  8167  8171  8179  8191  8209  8219')
    call appendValues(primenumbers, ' 8221  8231  8233  8237  8243  8263  8269  8273  8287  8291')
    call appendValues(primenumbers, ' 8293  8297  8311  8317  8329  8353  8363  8369  8377  8387')
    call appendValues(primenumbers, ' 8389  8419  8423  8429  8431  8443  8447  8461  8467  8501')
    call appendValues(primenumbers, ' 8513  8521  8527  8537  8539  8543  8563  8573  8581  8597')
    call appendValues(primenumbers, ' 8599  8609  8623  8627  8629  8641  8647  8663  8669  8677')
    call appendValues(primenumbers, ' 8681  8689  8693  8699  8707  8713  8719  8731  8737  8741')
    call appendValues(primenumbers, ' 8747  8753  8761  8779  8783  8803  8807  8819  8821  8831')
    call appendValues(primenumbers, ' 8837  8839  8849  8861  8863  8867  8887  8893  8923  8929')
    call appendValues(primenumbers, ' 8933  8941  8951  8963  8969  8971  8999  9001  9007  9011')
    call appendValues(primenumbers, ' 9013  9029  9041  9043  9049  9059  9067  9091  9103  9109')
    call appendValues(primenumbers, ' 9127  9133  9137  9151  9157  9161  9173  9181  9187  9199')
    call appendValues(primenumbers, ' 9203  9209  9221  9227  9239  9241  9257  9277  9281  9283')
    call appendValues(primenumbers, ' 9293  9311  9319  9323  9337  9341  9343  9349  9371  9377')
    call appendValues(primenumbers, ' 9391  9397  9403  9413  9419  9421  9431  9433  9437  9439')
    call appendValues(primenumbers, ' 9461  9463  9467  9473  9479  9491  9497  9511  9521  9533')
    call appendValues(primenumbers, ' 9539  9547  9551  9587  9601  9613  9619  9623  9629  9631')
    call appendValues(primenumbers, ' 9643  9649  9661  9677  9679  9689  9697  9719  9721  9733')
    call appendValues(primenumbers, ' 9739  9743  9749  9767  9769  9781  9787  9791  9803  9811')
    call appendValues(primenumbers, ' 9817  9829  9833  9839  9851  9857  9859  9871  9883  9887')
    call appendValues(primenumbers, ' 9901  9907  9923  9929  9931  9941  9949  9967  9973')

    prime = primenumbers(n)
  end function prime

  function primeFactors( n, factors, powers ) result(nFactors)
    ! Break n into its prime factors and, optionally, their powers
    ! E.g., called with 200, returns 2 (the number of prime factors) 
    ! along with:
    ! factors = (/ 2, 5 /)
    ! powers  = (/ 3, 2 /)
    ! for 200 = (2^3) (5^2)
    ! Args
    integer, intent(in)                              :: n
    integer, dimension(:), intent(out)               :: factors
    integer, dimension(:), optional, intent(out)     :: powers
    integer                                          :: nFactors
    ! Internal variables
    logical :: addOneTok
    integer :: i ! check prime(i)
    integer :: k ! counts which factor
    integer :: m
    integer :: primo
    ! Executable
    nFactors = 0
    factors = 1
    if ( present(powers) ) powers = 0
    if ( isPrime(n) .or. n < 2 ) then
      factors(1) = n
      if ( present(powers) ) powers(1) = 1
      nFactors = 1
      return
    endif
    m = n
    k = 1
    do i = 1, n
      if ( m < 2 .or. k > size(factors) ) then
        return
      endif
      ! Now check to see if prime(i) divides m
      if ( prime(i) < 0 ) then
        primo = nextPrime(primo+1)
      else
        primo = prime(i)
      endif
      ! print *, 'm, primo', m, primo
      if ( primo < 0 ) return
      addOneTok = .false.
      do
        if ( mod(m, primo) /= 0 .or. m < primo ) exit
        addOneTok = .true.
        factors(k) = primo
        if ( present(powers) ) powers(k) = powers(k) + 1
        nFactors = k
        m = m / primo
      enddo
      if ( addOneTok ) k = k + 1
    enddo
  end function primeFactors

  function PrimeIndex(n) result(i)
    ! Returns the index i of prime number prime(i) greater than the arg n
    ! Method:
    ! Starting with n, we'll check each integer until we find one that is prime
    ! Args
    integer, intent(in) :: n ! E.g., if n=100 returns 101 which is next prime > 100
    integer :: i
    ! Executable
    ! First, some intializing
    if ( primenumbers(1) < 0 ) i = prime(n)
    i = findFirst( primenumbers > n )
  end function PrimeIndex


a2140 19
  subroutine appendValues( array, chars )
    ! Append new values to end of array where new values
    ! are encoded by chars
    ! Args
    integer, dimension(:), intent(inout) :: array
    character(len=*), intent(in)         :: chars
    ! Internal variables
    integer :: error, nBegin, nEnd, nRead
    integer, dimension(10) :: ints
    ! Executable
    nBegin = FindFirst( array, -999 )
    if ( nBegin < 1 ) return
    call readIntsFromList( chars, ints, error )
    nRead = FindLast( ints /= -999 )
    if ( nRead < 1 ) return
    nEnd = min( size(array), nBegin+nRead-1 )
    array(nBegin:nEnd) = ints(:nEnd-nBegin+1)
  end subroutine appendValues
  
d2145 1
a2145 1
       "$Id: MLSSpecialFunctions.f90,v 2.7 2010/02/04 23:08:00 vsnyder Exp $"
d2157 3
@


2.7
log
@Remove USE or declaration for unused names
@
text
@d17 3
a19 3
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
  use MLSSets, only: FindFirst, FindLast
  use MLSStringLists, only: ReadIntsFromList
d2437 1
a2437 1
       "$Id: MLSSpecialFunctions.f90,v 2.6 2009/10/21 22:47:36 pwagner Exp $"
d2449 3
@


2.6
log
@primeFactors breaks down composite integers
@
text
@a106 2
    ! Internal variables
    integer :: mp
a319 2
    ! Internal variables
    integer :: mp
d2437 1
a2437 1
       "$Id: MLSSpecialFunctions.f90,v 2.5 2009/06/23 18:24:06 pwagner Exp $"
d2449 3
@


2.5
log
@Added prime, isPrime, nextPrime
@
text
@d26 1
a26 1
       "$RCSfile: $"
d41 1
d53 1
d58 1
a58 1
  public :: isPrime, nextPrime, prime
a120 1

d260 71
d2441 1
a2441 1
       "$Id: read_apriori.f90 is it here $"
d2453 3
@


2.4
log
@Delete USE for unused entity
@
text
@d18 2
a23 2
  public :: gamma
  public :: derfci, derfi, serfci, serfi, d1mach, i1mach, r1mach
d26 1
a26 1
       "$RCSfile: MLSSpecialFunctions.f90,v $"
d30 28
d61 3
d66 193
d2345 20
a2364 1

d2366 1
a2367 1
!---------------------------- RCS Ident Info -------------------------------
d2369 2
a2370 3
       "$Id: MLSSpecialFunctions.f90,v 2.3 2007/05/17 17:25:17 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2372 1
d2374 1
d2381 3
@


2.3
log
@error function stuff from l1/MathUtils.f90 moved here
@
text
@d16 1
a16 1
  USE ERMSG_M, ONLY: DERM1, DERV1, ERFIN, ERMSG, SERM1, SERV1
d2126 1
a2126 1
       "$Id: MLSSpecialFunctions.f90,v 2.2 2005/06/22 17:25:50 pwagner Exp $"
d2137 3
@


2.2
log
@Reworded Copyright statement, moved rcs id
@
text
@d16 1
d23 1
d26 1
a26 1
       "$RCSfile: $"
d531 1591
d2126 1
a2126 1
       "$Id: $"
d2137 3
@


2.1
log
@First commit
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d22 1
a22 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: MLSRandomNumber.f90,v 2.9 2002/10/08 00:09:12 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d24 1
a24 1
       "$RCSfile: MLSRandomNumber.f90,v $"
d531 5
d543 4
a546 1
! $Log: MLSRandomNumber.f90,v $
@

