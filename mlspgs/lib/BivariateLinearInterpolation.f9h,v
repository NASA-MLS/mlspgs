head	2.1;
access;
symbols
	v5-02-NRT-19:2.1
	v6-00:2.1
	v5-02-NRT-18:2.1
	v5-02:2.1
	v5-01-NRT-17:2.1
	v5-01-NRT-16:2.1
	v5-01-NRT-15:2.1
	v5-01-NRT-14:2.1
	neuralnetworks-1-0:2.1.0.12
	cfm-single-freq-0-1:2.1.0.10
	v5-01:2.1
	v5-00:2.1
	v4-23-TA133:2.1.0.8
	mus-emls-1-70:2.1.0.6
	rel-1-0-englocks-work:2.1.0.4
	VUMLS1-00:2.1
	VPL1-00:2.1
	V4-22-NRT-08:2.1
	VAM1-00:2.1
	V4-21:2.1.0.2
	V4-13:2.1
	V4-12:2.1
	V4-11:2.1
	V4-10:2.1
	M4-00:2.1
	V3-33:2.1
	V3-31:2.1
	V3-30-NRT-05:2.1
	cfm-01-00:2.1;
locks; strict;
comment	@# @;


2.1
date	2010.06.08.19.26.47;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.1
log
@Initial commit
@
text
@! subroutine BivariateLinearInterp_?_? ( X_Basis, Y_Basis, Table_2d, &
!   & X_Grid, Y_Grid, Out )
! 
!   ! Interpolate linearly in Table_2d whose coordinates are (X_Basis,Y_Basis),
!   ! which are assumed to be sorted, to Out at each (X_Grid,Y_Grid), which
!   ! are not necessarily sorted.  The Hunt routine assumes X_Grid and Y_Grid
!   ! change slowly and smoothly.
! 
!   integer, parameter :: KT = kind(0.0*0) ! Kind for table and basis
!   integer, parameter :: KO = kind(0.0*0) ! Kind for out and grids
! 
!   ! Extents for Table_2d are (size(X_basis,1),size(Y_Basis,1))
!   real(kt), intent(in) :: X_Basis(:), Y_Basis(:), Table_2D(:,:)
! 
!   ! Extents for X_Grid, Y_Grid, Out are all the same.
!   real(ko), intent(in) :: X_Grid(:), Y_Grid(:)
!   real(ko), intent(out) :: Out(:)

    ! Local variables
    integer :: I, J  ! Subscripts for X_Basis, Y_Basis
    integer :: K     ! Subscript for X_Grid, Y_Grid, Out

    real(kt) :: Eta_x(2), Eta_y(2) ! Interpolating coefficients

    i = 1
    j = 1
    do k = 1, size(out,1)
      call hunt_eta ( x_Basis, x_grid(k), i, eta_x )
      call hunt_eta ( y_Basis, y_grid(k), j, eta_y )
      out(k) = eta_x(1) * eta_y(1) * table_2d(i  ,j  ) + &
             & eta_x(1) * eta_y(2) * table_2d(i  ,j+1) + &
             & eta_x(2) * eta_y(1) * table_2d(i+1,j  ) + &
             & eta_x(2) * eta_y(2) * table_2d(i+1,j+1)
    end do

  contains

    subroutine Hunt_Eta ( Basis, Grid, L, Eta )
      ! Hunt for L such that Basis(L) <= Grid < Basis(L+1)
      ! and compute linear interpolation coefficients Eta.
      ! If Grid < Basis(1) then L = 1 and Eta = (/ 1.0, 0.0 /).
      ! If Grid >= Basis(size(basis,1)) then L = size(basis,1)-1 and
      ! Eta = (/ 0.0, 1.0 /).  That is, outside the range of Basis(:),
      ! constant extrapolation is used.
      real(kt), intent(in) :: Basis(:)
      real(ko), intent(in) :: Grid
      integer, intent(inout) :: L
      real(kt), intent(out) :: Eta(2)
      do ! hunt for Grid in Basis(:) from previous place
        if ( basis(l) <= grid ) then
          if ( grid < basis(l+1) ) then
            eta(1) = ( basis(l+1) - grid ) / &
                   & ( basis(l+1) - basis(l) )
            eta(2) = 1.0 - eta(1)
            exit
          end if
          if ( l == size(basis,1)-1 ) then
            eta = (/ 0.0, 1.0 /)
            exit
          end if
          l = l + 1
        else if ( l > 1 ) then
          l = l - 1
        else
          eta = (/ 1.0, 0.0 /)
          exit
        end if
      end do ! Hunt
    end subroutine Hunt_Eta

! end subroutine BivariateLinearInterp_?_?
@
