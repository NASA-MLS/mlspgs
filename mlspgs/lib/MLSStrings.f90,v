head	2.112;
access;
symbols
	v5-02-NRT-19:2.112
	v6-00:2.112
	v5-02-NRT-18:2.112
	v5-02:2.109
	v5-01-NRT-17:2.112
	v5-01-NRT-16:2.112
	v5-01-NRT-15:2.112
	v5-01-NRT-14:2.112
	neuralnetworks-1-0:2.111.0.4
	cfm-single-freq-0-1:2.111.0.2
	v5-01:2.109
	v5-00:2.109
	v4-23-TA133:2.108.0.2
	mus-emls-1-70:2.105.0.4
	rel-1-0-englocks-work:2.105.0.2
	VUMLS1-00:2.103
	VPL1-00:2.101
	V4-22-NRT-08:2.101
	VAM1-00:2.101
	V4-21:2.101.0.2
	V4-13:2.101
	V4-12:2.99
	V4-11:2.98
	V4-10:2.98
	V3-43:2.77
	M4-00:2.88
	V3-41:2.77
	V3-40-PlusGM57:2.77.0.2
	V2-24-NRT-04:2.71
	V3-33:2.81
	V2-24:2.71
	V3-31:2.81
	V3-30-NRT-05:2.78
	cfm-01-00:2.78
	V3-30:2.77
	V3-20:2.77
	V3-10:2.76
	V2-23-NRT-02:2.71
	V2-23:2.71
	V2-22-NRT-01:2.71
	V2-22:2.71
	V2-21:2.64
	V2-20:2.63
	V2-11:2.62
	V2-10:2.62
	V2-00:2.62
	V1-51:2.51
	V1-50:2.51
	V1-45:2.45
	V1-44:2.45
	V1-43:2.39
	V1-42:2.38
	V1-41:2.38
	V1-32:2.39
	V1-40:2.38
	V1-31:2.38
	V1-30:2.30
	V1-13:2.29
	V1-12:2.29
	V1-11:2.29
	V1-10:2.27
	newfwm-feb03:2.27.0.2
	V1-04:2.22
	V1-03:2.22
	V1-02:2.22
	V1-00:2.21
	newfwm-sep01:2.16.0.2
	V0-7:2.16
	V0-5-Level2:2.6
	V0-5-SIPS:2.6
	V0_1:1.20;
locks; strict;
comment	@# @;


2.112
date	2021.07.09.21.48.27;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2019.10.30.20.04.31;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2019.10.16.20.50.13;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2019.07.17.20.13.42;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2019.04.09.20.35.17;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2019.03.21.23.44.38;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2019.01.24.18.31.12;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2018.03.27.22.06.52;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2017.12.08.00.28.44;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2017.01.25.21.10.17;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2016.12.08.00.15.41;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2014.09.11.18.23.57;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2014.09.05.00.12.11;	author vsnyder;	state Exp;
branches;
next	2.99;

2.99
date	2014.07.25.21.42.37;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2014.02.21.01.24.54;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2014.02.12.23.59.34;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2013.08.09.00.43.06;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2013.07.30.23.26.44;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2013.07.24.19.02.43;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2013.06.28.23.56.47;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2013.06.17.21.35.26;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2013.06.14.03.02.37;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2013.06.13.00.39.21;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2012.12.04.00.11.55;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2012.09.05.21.43.55;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2012.08.07.18.02.37;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2012.07.10.15.15.33;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2012.05.01.22.10.26;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2011.06.23.17.25.50;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2011.06.16.00.14.51;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2011.02.18.17.58.10;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2011.02.05.01.34.23;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2010.09.24.23.45.45;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2010.06.23.20.42.21;	author honghanh;	state Exp;
branches;
next	2.77;

2.77
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2009.06.16.17.08.42;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2008.06.04.21.44.43;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2008.05.09.00.22.37;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2008.02.07.18.46.55;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2007.09.13.21.06.25;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2007.08.29.19.52.18;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2007.07.31.22.46.08;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2007.07.25.21.58.16;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2007.07.18.00.06.46;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2007.05.22.20.57.18;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2007.04.26.20.32.15;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2007.01.03.20.40.25;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2006.10.05.23.34.13;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2006.05.09.00.14.23;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2006.02.24.01.14.02;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2006.02.16.00.58.12;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2005.09.22.23.33.58;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2005.07.21.23.37.22;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2005.06.14.18.31.41;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2005.05.31.17.46.01;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2005.04.12.17.34.53;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2005.03.15.23.45.05;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2005.01.20.01.29.42;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2004.10.13.20.25.45;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2004.10.13.16.23.03;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2004.10.13.00.52.20;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2004.10.05.23.08.04;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2004.09.23.22.56.38;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2004.09.16.00.15.52;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2004.08.04.23.19.01;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2004.06.29.00.06.13;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2004.06.16.22.15.28;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2004.06.16.01.25.08;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2004.06.10.00.57.47;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2004.06.09.00.02.35;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2004.01.27.21.34.02;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2003.12.11.23.02.35;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2003.12.07.23.10.42;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2003.12.05.00.52.18;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2003.10.28.19.28.32;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2003.10.15.00.34.19;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2003.10.14.18.17.02;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2003.10.09.23.33.11;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2003.09.15.23.04.06;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2003.04.11.23.29.30;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2003.02.27.18.36.57;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2003.02.19.19.08.40;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2003.02.01.00.28.32;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2003.01.15.21.20.00;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2002.10.29.19.55.39;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2002.10.29.01.00.05;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2002.10.08.00.09.12;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2002.04.29.17.39.31;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2002.02.22.23.35.42;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2002.02.22.01.19.57;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2002.02.19.23.12.03;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2002.02.15.01.06.12;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2002.01.09.23.46.05;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2001.08.03.00.03.08;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2001.06.20.23.23.39;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2001.06.20.23.21.49;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.06.07.21.59.41;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2001.05.29.21.17.03;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.05.26.00.21.59;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.05.24.23.36.17;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2001.05.15.23.44.42;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2001.05.11.23.41.31;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2001.05.11.00.06.54;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.14.17.34.00;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.02.19.33.14;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2001.02.24.01.02.45;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.23.00.05.56;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2000.12.01.22.38.00;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.11.30.00.24.49;	author pwagner;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.17.41.06;	author dcuddy;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.05.20.25.38;	author perun;	state Exp;
branches;
next	1.1;

1.1
date	99.11.03.23.53.57;	author livesey;	state Exp;
branches;
next	;


desc
@@


2.112
log
@Clearer comments in CompressString
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module MLSStrings               ! Some low level string handling stuff
!=============================================================================
  use MLSFinds, only: FindFirst, FindNext, FindLast
  use MLSStrings_0, only: Asciify, Capitalize, DecimalCode, &
    & IsAllAscii, IsAlphabet, &
    & NCharsInFormat, ReplaceNonAscii, Lowercase, &
    & MNemonicCode, OctalCode, &
    & ReadIntsFromChars, Stretch, Trim_Safe
  implicit none
  private

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSStrings.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

!
! This module contains some low level string handling stuff for mls

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (parameters and data)
! StringOptions      Default options string

!     (subroutines and functions)
! Asciify            purify chars to be within printing range [32,126]
!                      (no binary) (see also ReplaceNonAscii, unAsciify)
! Capitalize         tr[a-z] -> [A-Z]
! CatStrings         Concatenate strings with a specified separator
! CharToInt          Convert a single char to its corresponding integer
!                      tr['1'-'9'] -> [1-9]
! ShiftLRC           Shift string to left, center, or right
! CompressString     Removes all leading and embedded blanks
!                      (should rename to 'unstretch'?)
! Count_quotes       Counts the number of quotes-surrounded phrases in a string
! Count_words        Counts the number of space-separated words in a string
! Delete             Deletes each instance of a char
! Depunctuate        Replaces punctuation with blanks
! Enclosure          Finds outermost indices of substring enclosing an arg
!                      with '(' and ')'; optionally some other brackets
! FlushArrayLeft     Flush character array left over blank elements
! Hhmmss_value       Converts 'hh:mm:ss' formatted string to a real r8
!                    (See also PGS_TD_UTCtoTAI and mls_UTCtoTAI)
! Indexes            Indexes an array of substrings of a string into an array
! Ints2Strings       Converts an array of integers to strings using "char" ftn
! IsAllAscii         Is a string composed entirely of ascii, i.e. non-binary
! isAlphabet         Is the arg an alphabetical character?
! IsComment          Does the string begin with a Comment character?
! IsDigits           Is the string composed entirely of digits?
! IsRepeat           Is a string composed entirely of one substring repeated?
! Justify            Return the string str Justified to fit the available length
! LenTrimToAscii     len_trim of string ignoring all non-ascii chars
! LinearSearchStringArray     
!                    Finds string index of substring in array of strings
! LowerCase          tr[A-Z] -> [a-z]
! NAppearances       The number of times each substring appears in string
! NCharsInFormat     How many characters in a format spec
! NCopies            How many copies of a substring in a string
! ReadCompleteLineWithoutComments     
!                    Knits continuations, snips comments
! ReadNumFromBaseN   Interprets a string as base n representation; returns float
! ReadIntFromBaseN   Interprets a string as base n representation
! ReadIntsFromChars  Converts an [array of] strings to int[s] using Fortran read
! ReadNumsFromChars  Converts an [array of] strings to num[s] using Fortran read
! ReadRomanNumerals  Converts a Roman numeral (e.g. 'ix') to its integer value
! Remap              Replaces every instance in str of char old[k] with 
!                       corresponding new[k]
! Replace            Replaces every instance of oldChar with newChar
! ReplaceNonAscii    Replaces every non-ascii char with newChar (see also Asciify)
! Reverse            Turns 'a string' -> 'gnirts a'
! Reverse_trim       (Reverses after first trimming its argument)
! Rot13              Like ROT13 but for general integer nn
! Size_trim          Returns len_trim of equivalent character scalar for array
! SplitDetails       Splits 'pro1' into 'pro' and 1
! SplitNest          Splits 'part 1 (part 2) part 3' -> 'part 1', 'part 2', 'part 3'
! SplitWords         Splits 'first, the, rest, last' -> 'first', 'the, rest', 'last'
! Squeeze            Snip excess spaces from between words; optionally snip all
! StartCase          Capitalize first letter of each (space-separated) word
! Streq              Generalized strings "==" (optionally ignoring case,
!                      leading blanks, and allowing wildcard matches)
! Stretch            Insert spaces between words; optionally between letters, too
! Strings2Ints       Converts an array of strings to ints using "ichar" ftn
! Swap               Swaps every instance of c1 with c2 and vice versa
! Trim_safe          trims string down, but never to length 0
! TrueList           describe where elements of an array are true
! UnAsciify          restore non-ascii characters in place of their coded forms
!                       (see Asciify)
! UnWrapLines        undo the splitting of commands across multiple lines
! WriteIntAsBaseN    Converts an integer to base n representation
! WriteIntsToChars   Converts an array of ints to strings using Fortran write
! WriteRomanNumerals Converts an integer to Roman numeral (e.g. 9 to 'ix')
! === (end of toc) ===

! === (start of api) ===
! char* Asciify ( char* str, [char* how] )
! char* Capitalize (char* str)
! CatStrings ( char* strings(:), char* sep, char* stringsCat, &
!      & int L, [char* options] )
! int charToInt (char str)
! char* CompressString (char* str)
! int count_quotes (char* str, char lquote, char rquote)
! int count_words (char* str)
! char* delete (char* str, char ch, [int max])
! char* depunctuate (char* str)
! Enclosure ( char* str, int i1, int i2, [ char brackets(:)] )
! FlushArrayLeft ( char* a(:), char* b(:), [char* options] )
! int(:) indexes (char* string, char* substrings, [char* mode])
! ints2Strings (int ints(:,:), char* strs(:))
! log(:) isAllAscii( char* arg(:) )
! log isAlphabet( char arg )
! log(:) isComment( char* arg(:), [char Comment] )
! log(:) isDigits( char* arg(:) )
! log IsRepeat ( char* str, [char* subtring] )
! char* Justify ( char* str, int length, [char mode] )
! int lenTrimToAscii (char* str)
! int LinearSearchStringArray (char* list(:), char* string, 
!   [log caseInsensitive, [log testSubstring], [log listInString])
! char* LowerCase (char* str)
! int(:) NAppearances (char* string, char* substrings)
! int nCharsinFormat ( char* Format )
! int NCopies (char* str, char* substring, [log overlap])
! ReadCompleteLineWithoutComments (int unit, char* fullLine, [log eof], &
!       & [char commentChar], [char continuationChar])
! ReadNumFromBaseN ( char* strs, real float, int N, [char* options] )
! ReadIntFromBaseN ( char* strs, int int, int N, [char* options] )
! ReadIntsFromChars ( char* strs[(:)], int ints[(:)], &
!       & [char* forbiddens], [char* ignore] )
! ReadNumsFromChars ( char* strs[(:)], num num[(:)], &
!       & [char* forbiddens], [char* ignore] )
! ReadRomanNumerals ( char* strs, int int )
! char* remap ( char* str, char* old, char* new )
! char* Replace ( char* str, char oldChar, char newChar, &
!      & [int max], [log reverse] )
! char* ReplaceNonAscii ( char* str, char newChar, [char* exceptions] )
! char* Reverse ( char* str )
! char* Reverse_trim ( char* str )
! char* Rot13 ( char* str, [int nn], [char* otp], [log inverse] )
! char* shiftLRC ( char* str, [char* position], [char fillChar] )
! int size_trim ( char* str(:) )
! SplitDetails ( char *str, char* switch, int details )
! SplitNest ( char *str, char* part1, char* part2, char* part3, [char* parens] )
! SplitWords (char *line, char* first, char* rest, [char* last], &
!       & [log threeWay], [char* delimiter])
! char* squeeze (char* str, [char* options])
! char* StartCase (char* str, [char separator])
! log streq ( [char* str1], [char* str2], [char* options] )
! log streq ( char* str1(:), char* str2, [char* options] )
! log streq ( char* str1, char* str2(:), [char* options] )
! char* stretch ( char* str, [char* options] )
! strings2Ints ( char* strs(:), int ints(:,:) )
! char* Swap ( char* str, char c1, char c2 )
! char* trim_safe ( char* str )
! TrueList ( logical* list, char* str )
! char* unAsciify ( char* str, [char* how] )
! unWrapLines ( char* inLines(:), char* outLines(:), &
!              [int nout], [char escape], [char comment] )
! writeIntAsBaseN (int int, int N, char* strs, [char* options])
! writeIntsToChars (int ints(:), char* strs(:))
! writeRomanNumerals (int int, char* strs)
! Many of these routines take optional arguments that greatly modify
! their default operation

! One standard is the character flag "options" which affects how loosely
! string matches may be interpreted
! it may include any of the following (poss. in combination, e.g. "-wc")
! w    Wildcard * which allows 'a*' to equal 'abcd'
! c    case insensitive which allows 'ABCD' to equal 'abcd'
! e    permit empty string elements
! f    flush left which allows 'abcd' to equal '  abcd'
! h    check only that the heads match; allows 'oldman' to match 'old'
! n    reverse sense of match (where appropriate)
! (These are different in streq_array1, however--either redo that function
! to make it conform, or rename the options flag there to prevent
! unnecessary confusion)

! We hope eventually that options will replace the countEmpty, caseSensitive, 
! etc. separate optional args to many of the current module procedures

! Warnings: 
! (1) in the routine LinearSearchStringArray
! the input arguments include an array of strings;
! This array is of assumed-size
! I.e., all elements from array(1:size(array)) are relevant
! Therefore in calling one of these you probably need to use the format
!   call SortArray(myArray(1:mySize), ..
! to avoid operating on undefined array elements
! (2) in some routines trailing blanks are ignored,
!   while in others they are significant
! How trailing blanks in argument(s) treated
! Ignored                   Significant
! -------                   -----------
! CatStrings                Capitalize
! Depunctuate               CompressString
! HHMMSS_value              Count_words
! Indexes                   LowerCase
! IsRepeat                  Reverse
! LinearSearchStringArray   Strings2Ints
! Nappearances              Trim_safe
! Ncopies
! ReadIntsFromChars         
! ReFormatDate              
! ReFormatTime              
! Reverse_trim              
! SplitWords                
! Streq                     
! === (end of api) ===

  public :: Asciify, &
    & Capitalize, CatStrings, CharToInt, CompressString, Count_Words, &
    & Delete, Depunctuate, Enclosure, FlushArrayLeft, Hhmmss_Value, &
    & Indexes, Ints2Strings, &
    & IsAllAscii, IsAlphabet, IsComment, IsDigits, IsRepeat, Justify, &
    & LenTrimToAscii, LinearSearchStringArray, Lowercase, &
    & NAppearances, NCharsInFormat, NCopies, &
    & ReadCompleteLineWithoutComments, ReadIntFromBaseN, ReadIntsFromChars, &
    & ReadNumFromBaseN, ReadNumsFromChars, ReadRomanNumerals, &
    & Remap, Replace, ReplaceNonAscii, Reverse, Reverse_Trim, &
    & Rot13, &
    & Shiftlrc, Size_Trim, SplitDetails, SplitNest, SplitWords, Squeeze, &
    & StartCase, Streq, Stretch, Strings2Ints, &
    & Swap, Trim_Safe, TrueList, UnAsciify, UnWrapLines, &
    & WriteIntasBaseN, WriteIntsToChars, WriteRomanNumerals

  interface ReadNumFromBaseN
    module procedure ReadFloatFromBaseN, ReadIntFromBaseN
  end interface

  interface ReadNumsFromChars
    module procedure ReadADoubleFromChars, ReadDoubleArrayFromChars
    module procedure ReadARealFromChars, ReadRealArrayFromChars
    module procedure ReadAnIntFromChars, ReadIntArrayFromChars
  end interface

  interface Streq
    module procedure Streq_Scalar, Streq_Array1, Streq_Array2
  end interface

  interface WriteIntsToChars
    module procedure WriteAnIntToChars, WriteIntsToChars_1d, WriteIntsToChars_2d
  end interface

  ! Public data
  character(len=16), public, save :: StringOptions = ' '

  ! hhmmss_value
  integer, public, parameter      :: Invalidhhmmssstring = 1
  ! readAnIntFromChars
  integer, public, parameter      :: StringContainsForbiddens=-999
  ! strings2Ints
  integer, public, parameter      :: LenOrSizeTooSmall=-999
  ! streq max input str lengths
  ! (We had to resort to this hard-wired limit after we made
  ! the possibly bone-headed decision to let
  ! str1 and str2 be optional args)
  integer, public, parameter      :: MaxStreqLen  = 2048
  integer, public, parameter      :: MaxSubstrLen = 256

  logical, private, save          :: CaseSensitive       
  logical, private, save          :: IgnoreLeadingSpaces

contains

  ! -------------------------------------------------  CatStrings  -----
  subroutine CatStrings ( Strings, Sep, StringsCat, L, options )
  ! Concatenate Strings with Sep between them, giving StringsCat(:L-1)
    character(len=*), intent(in) :: Strings(:)
    character(len=*), intent(in) :: Sep
    character(len=*), intent(out) :: StringsCat
    integer, intent(out) :: L
    character(len=*), optional, intent(in) :: options
    ! Internal variables
    logical :: CountEmpty
    integer :: I, N, T, W
    ! Executable
    !countEmpty = ( index( Default( Options, StringOptions), 'e') > 0 )
    countEmpty = index( StringOptions, 'e' ) > 0
    if ( present(options) ) countEmpty = index( options, 'e' ) > 0
    w = len(sep)
    l = len_trim(strings(1)) + 1
    stringsCat(:l-1) = strings(1)(:l-1)
    do i = 2, size(strings)
      t = len_trim(strings(i))
      if ( t < 1 .and. .not. CountEmpty ) cycle
      n = l + t + w
      n = min( len(StringsCat) + 1, n )
      stringsCat(l:n-1) = sep // strings(i)(:t)
      l = n
      if ( l > len(StringsCat) ) return
    end do
  end subroutine CatStrings

  ! ------------------------------------------------  CharToInt  -----
  elemental function CharToInt (str) result (int)
    ! This converts the input character to its integer value, if
    ! it has one
    ! e.g., '9' returns 9
    ! 'a' or '0' or ' ' , indeed anything else all return 0
    !--------Argument--------!
    character (len=1), intent(in) :: str
    !---------result---------!
    integer :: int
    !-----local-variables------!
    character(len=9), parameter :: allChars = &
      & '123456789'
    !-------executable-code----!
    int = index( allChars, str )
  end function CharToInt

  ! ---------------------------------------------  CompressString  -----
  function CompressString ( str ) result ( outstr )

    ! Removes all leading and embedded blanks from a string.
    ! This undoes what the function stretch does.
    ! Should we rename it 'unstretch'?
    ! Well, a truer implementation of an unstretch function would
    ! (1) turn 'a b' -> 'ab'
    ! (2) turn 'a  b' -> 'a b'
    ! (3) turn 'a  .. b' -> 'a b'
    ! i.e., turn every sequence of 2 or more blanks into a single blank
    ! while deleting any singleton blank.
    ! 
    !--------Argument--------!

    character (len=*), intent(in) :: str
    character (len=len(str)) :: outstr

    !----------Local vars----------!
    integer :: i, n

    !----------Executable part----------!

    outstr = " "
    n = 0
    DO i = 1, LEN(str)
       IF (str(i:i) /= " ") THEN
          n = n + 1
          outstr(n:n) = str(i:i)
       END IF
    END DO

  end function CompressString

  ! ------------------------------------------------  count_quotes  -----
  function count_quotes ( str, lquote, rquote ) result (no_of_quotes)
    ! This counts the number of quotes in a string 
    ! For our purposes, quotes consist of any non-space characters
    ! surrounded by an {lquote. rquote} pair

    ! method:
    ! step through string, each stride positioned between
    ! j1, where leftmost lquote is, and j2, where leftmost rquote is
    ! cut off both stride and evrything leftward, call remainder "remainder"
    ! Contrast this approach with what is is done in MLSStringLists module
    ! which uses string slicing and index arithmetic
    ! Should we go back and simplify the latter?
    !--------Argument--------!
    character (len=*), intent(in) :: str
    character (len=1), intent(in) :: lquote
    character (len=1), intent(in) :: rquote
    !---------result---------!
    integer::no_of_quotes
    !-----local-variables------!
    integer::j1
    integer::j2
    character(len=len(str)) :: remaining
    !-------Executable-code----!
    no_of_quotes = 0
    IF (index(str, lquote) < 1 .or. index(str, rquote) < 1) return
    remaining = str
    DO
       j1 = index( remaining, lquote)
       if ( j1 < 1 ) exit
       j2 = index( remaining, rquote)
       if ( j2 < 1 ) exit
       no_of_quotes = no_of_quotes + 1
       if ( j2 >= len_trim(remaining) ) exit
       remaining = remaining(j2+1:)
    END DO
  end function count_quotes

  ! ------------------------------------------------  COUNT_WORDS  -----
  function count_words (str) result (no_of_words)
    ! This counts the number of words in a string 
    ! For our purposes, words consist of any non-space characters
    ! and are separated by one or more spaces
    ! -----Added by HCP-------- 
    !--------Argument--------!
    character (len=*), intent(in) :: str
    !---------result---------!
    integer::no_of_words
    !-----local-variables------!
    integer::j
    !-------Executable-code----!
    IF (str(1:1) /= " ") THEN
       no_of_words=1
    ELSE
       no_of_words=0
    END IF
    DO j = 2, LEN(str)
       IF(str(j:j) /= " " .AND. str(j-1:j-1) == " ") THEN
          no_of_words=no_of_words+1
       END IF
    END DO
  end function count_words

  ! ------------------------------------------------  Delete  -----
  function Delete ( str, ch, max ) result ( outstr )
    ! function that removes every instance of a char
    !--------Argument--------!
    character(len=*), intent(in) :: str
    character(len=1), intent(in) :: ch
    integer, optional, intent(in) :: max ! up to how many such deletions?
    character(len=len(str)) :: outstr
    !----------Local vars----------!
    integer :: i, iout
    integer :: myMax
    integer :: dels
    !----------Executable part----------!
    outstr = str
    if ( index(str, ch) < 1 ) return
    myMax = Huge(0) / 2
    if ( present(max) ) myMax = max
    dels = 0
    outstr = ' '
    iout = 0
    do i = 1, len_trim(str)
      if ( str(i:i) == ch ) then
        dels = dels + 1
        if ( dels <= myMax ) cycle
      endif
      iout = iout + 1
      outstr(iout:iout) = str(i:i)
    end do

  end function Delete

  ! ------------------------------------------------  DEPUNCTUATE  -----
  function Depunctuate ( str ) result ( outstr )
    ! function that removes punctuation and replaces with blanks
    ! Added by HCP. This depends on the native character set being 
    ! ASCII. 
    !--------Argument--------!
    character(len=*),intent(in) :: str
    character(len=len(str)) :: outstr
    !----------Local vars----------!
    integer :: i, icode
    !----------Executable part----------!
    outstr=str
    do i = 1 ,len(str)
        icode=iachar(str(i:i))
        if(  (icode >= 33 .and. icode <= 47).or.&
             (icode >= 58 .and. icode <=64).or. &
             (icode >= 91 .and. icode <=96).or. &
             (icode >= 123)) then
           outstr(i:i)=" "
        end if
    end do

  end function Depunctuate

  ! ------------------------------------------------  Enclosure  -----
  subroutine Enclosure ( str, i1, i2, brackets )
    ! Find outermost substring indices enclosing an arg
    ! with "(" and ")"; any failure returns 0 and 0
    ! E.g., if
    !   str = 'abs(a+(b+c)/d)'
    !          123456789012345
    ! returns i1=4 and i2=14
    ! Optionally will use 
    !   brackets(1) instead of "(" and 
    !   brackets(2) instead of ")"
    !
    ! Method:
    ! Each '(' adds 1, each ')' subtracts 1, though never going negative
    ! If 0 when done, we're balanced, not if not
    !
    ! brackets(1) and (2) must not be th same
    ! Args
    character(len=*), intent(in)                  :: str
    integer, intent(out)                          :: i1
    integer, intent(out)                          :: i2
    character, dimension(:), optional, intent(in) :: brackets
    ! Internal variables
    integer                                       :: i
    integer                                       :: balance
    character                                     :: lef ! "("
    character                                     :: rig ! ")"
    ! Executable
    lef = '('
    rig = ')'
    i1 = 0
    i2 = 0
    if ( present(brackets) ) then
      if ( size(brackets) > 1 ) then
        lef = brackets(1)
        rig = brackets(2)
      endif
    endif
    if ( lef == rig ) then
      ! print *, 'The lef and rig brackets must not be the same'
      return
    endif
    i1 = index( str, lef )
    if ( i1 < 1 ) then
      ! Failed right off the bat to find a 1st "("
      i1 = 0
      i2 = 0
      return
    endif
    balance = 1
    do i = index( str, lef ) + 1, len_trim(str)
      select case(str(i:i))
      case ('(')
        balance = balance + 1
      case (')')
        balance = max( 0, balance - 1 )
      ! case default (leaves balance unchanged)
      end select
      if ( balance < 1 ) exit
    enddo
    if ( i > len_trim(str) ) then
      ! Failed to find the matching ")"
      i1 = 0
      i2 = 0
    else
      i2 = i
    endif
  end subroutine Enclosure

  ! ------------------------------------------------  FlushArrayLeft  -----
  subroutine FlushArrayLeft ( a, b, options )
    ! Flush array "a" over by leading blanks, returning result as "b"
    ! according to options
    ! options           meaning
    ! -------           -------
    !  a (default)     array-wise: skip over leading blank array elements
    !  e               element-wise: skip over leading blanks in each element
    ! thus, -ae would both skip over leading blank array elements
    ! and also flush each element left
    !
    !--------Argument--------!
    character (len=*), dimension(:), intent(in)  :: a
    character (len=*), dimension(:), intent(out) :: b
    character (len=*), optional, intent(in)      :: options
    !---------local variables---------!
    integer::i, n
    character(len=8) :: myOptions
    !-------Executable-code----!
    myOptions = '-a'
    if ( present(options) ) myOptions = options
    if ( index( lowercase(myOptions), 'a' ) > 0 ) then
      b = ' '
      n = 0
      do i=1, size(a)
        if ( a(i) == ' ' .and. n < 1 ) cycle
        n = n + 1
        b(n) = a(i)
      enddo
    else
      b = a
    endif
    if ( index( lowercase(myOptions), 'e' ) < 1 ) return
    do i=1, size(a)
      b(i) = adjustl(b(i))
    enddo
  end subroutine FlushArrayLeft

  ! ------------------------------------------------  HHMMSS_value  -----
  function HHMMSS_value ( str, ErrTyp, separator, strict ) result ( value )
    ! function that returns the value in seconds of a string 'hh:mm:ss'
    ! where the field separator ':' divides the string into two
    ! integer-like strings 'hh' and 'mm', as well as one float-like
    ! string 'ss' which may have a decimal point plus fractional part
    ! E.g., ss=59.9999

    ! Requires 0 <= hh <= 24
    ! Requires 0 <= mm < 60
    ! Requires 0. <= ss < 60.

    ! Returns ErrTyp == 0 unless an error occurs

    ! Lenient wrt utc and non-compliant formats:
    ! ignores chars in front of 'hh' and a terminal,
    ! non-numerical char: e.g., '2000-01-01T00:00:00.000000Z'
    ! will be treated the same as '00:00:00.0000000'

    ! If given optional arg strict and it's true, not lenient
    ! i.e., non-compliant str always returns non-zero ErrTyp

    ! If not strict, some of the fields can be null, e.g. 12:00 and 12:00:
    ! and 12::0 and ::12 are allowed.

    ! If given optional arg separator, uses separator as field separator

    ! Useful to allow an added way to input time

    ! (See also PGS_TD_UTCtoTAI and mls_UTCtoTAI)
    !--------Arguments--------!
    character(len=*), intent(in) :: Str
    integer, intent(out) :: ErrTyp
    character(len=1), intent(in), optional :: Separator
    logical, intent(in), optional :: Strict
    double precision :: value
    !----------Locals----------!
    character(len=1), parameter :: Colon=':'
    character(len=1) :: MyColon
    character(len=*), parameter :: Digits='0123456789.'
    integer :: HValue, MValue
    character(len=len_trim(str)+1) :: MyStr
    logical :: MyStrict
    integer :: H1, Sep1, Sep2, S2  ! Indices in STR
    !----------Executable part----------!

    myColon = colon
    if ( present(separator) ) myColon = separator

    myStrict = .false.
    if ( present(strict) ) myStrict = strict

    s2 = len_trim(str)
    value = 0.0
    errTyp = INVALIDHHMMSSSTRING
    if ( s2 == 0 ) then
      if ( .not. myStrict ) errTyp = 0
      return
    end if
    myStr = str(:s2)
    if ( verify(myStr(s2:s2),digits) /= 0 ) then ! Junk at the end
      if ( myStrict ) return
    else
      s2 = s2 + 1
    end if
    myStr(s2:s2) = '/' ! list-directed I/O terminator, might replace junk at end

    sep1 = index(myStr,myColon)
    if ( sep1 == 0 ) then
      if ( myStrict ) return
      sep1 = s2
    else
      myStr(sep1:sep1) = ',' ! list-directed I/O separator
    end if

    h1 = verify(myStr(:sep1-1),digits(1:10),back=.true.) ! '.' not allowed
    if ( h1 /= 0 .and. myStrict ) return ! Junk before hours
    if ( verify(myStr(h1+1:sep1-1),digits(1:10)) /= 0 ) return ! catch blank/comma

    sep2 = index(myStr(sep1+1:),myColon) + sep1
    if ( sep2 == sep1 ) then
      if ( myStrict ) return
      sep2 = s2
    else
      myStr(sep2:sep2) = ',' ! list-directed I/O separator
    end if
    if ( verify(myStr(sep1+1:sep2-1),digits(1:10)) /= 0 ) return ! catch blank/comma
    if ( verify(myStr(sep2+1:s2-1),digits) /= 0 ) return ! catch blank/comma

    if ( myStrict .and. & ! check for null fields
      & ( h1+1 == sep1 .or. sep1+1 == sep2 ) ) return

    ! myStr(h1+1:sep1-1) is hours, myStr(sep1+1:sep2-1) is minutes,
    ! myStr(sep2+1:s2) is seconds
    hvalue=0; mvalue=0 ! Fortran doesn't update null fields
    read ( myStr(h1+1:s2), *, iostat=errTyp ) hvalue, mvalue, value
    if ( errTyp /= 0 ) return

    errTyp = INVALIDHHMMSSSTRING
    if ( hvalue < 0 .or. hvalue >= 24 .or. &
      &  mvalue < 0 .or. mvalue >= 60 .or. &
      &  value < 0 .or. value >= 60 ) return

    errTyp = 0
    value = value + 60 * (mvalue + 60 * hvalue )

  end function HHMMSS_value

  ! ---------------------------------------------------  indexes  -----
  function indexes(str, substrings, mode) result(array)
    character(len=*), intent(in) :: str
    character(len=*), intent(in), dimension(:) :: substrings
    character(len=*), optional :: mode
    integer, dimension(size(substrings)) :: array
    ! Returns the array of indexes of each element of substrings in str
    ! The mode determines how consecutive elements of array are ordered
    ! (default is first)
    ! mode          order
    ! ------        -----
    ! first         always find first occurrence of substrings(i) in str
    ! last          always find last occurrence of substrings(i) in str
    ! left          progressively find next substrings(i) after substrings(i-1)
    ! right         progressively find next substrings(i) before substrings(i-1)
    ! wrap          left-right, meeting in middle
    !
    ! E.g., if str='ababababababa' and substrings = (/'a', 'a', 'a', 'a', 'a'/)
    ! mode            result
    ! ------          ------
    ! first        (/1, 1, 1, 1, 1/)
    ! last         (/13, 13, 13, 13, 13/)
    ! left         (/1, 3, 5, 7, 9/)
    ! right        (/13, 11, 9, 7, 5/)
    ! wrap         (/1, 3, 7, 11, 13/) ! Currently, we give (/1,3,9,11,13/)
    !
    ! Notes:
    ! mode='wrap' does not return true middle value yet--do we care?
    ! we trim each element of the sub-strings--should we allow an option not to?
    ! (Probably)
     integer :: i
     integer :: ipos
     integer :: lpos
     integer :: n
     integer :: rpos
     integer, dimension(size(substrings)) :: left
     integer, dimension(size(substrings)) :: right
     character(len=5) :: myMode
     !
     myMode = 'first'
     if ( present(mode) ) myMode = mode
     n = size(substrings)
     ! Simple modes
     if ( lowercase(myMode(1:2)) == 'fi' ) then
       do i = 1, n
         array(i) = index(str, trim(substrings(i)))
       enddo
       return
     elseif ( lowercase(myMode(1:2)) == 'la' ) then
       do i = 1, n
         array(i) = index(str, trim(substrings(i)), back=.true.)
       enddo
       return
     endif
     ! Progressive Modes (which accumulate *pos)
     lpos = 1
     rpos = max(len_trim(str), 1) ! len(trim_safe(str))
     left = 0
     do i = 1, n
       ipos = index(str(lpos:), trim_safe(substrings(i)))
       if ( ipos < 1 ) exit
       left(i) = lpos + ipos - 1
       lpos = left(i) + max(len_trim(substrings(i)), 1) ! len(trim_safe(substrings(i)))
       if ( lpos > len(str) ) exit
     enddo
     right = 0
     do i = 1, n
       ipos = index(str(:rpos), trim_safe(substrings(i)), back=.true.)
       if ( ipos < 1 ) exit
       right(i) = ipos
       rpos = right(i) - 1
       if ( rpos < 1 ) exit
     enddo
     select case (lowercase(myMode(1:2)))
     case ('le')
       array = left
     case ('ri')
       array = right
     case ('wr')
       array(1:n) = right(n:1:-1)
       lpos = n/2
       rpos = lpos + 1
       do i = 1, lpos
         array(i) = left(i)
       enddo
       ! Is n an odd number?
       !if ( 2*lpos < n ) &
       !  & array(rpos) = (left(rpos) + right(rpos) ) / 2 ! No, this won't work
     case default
       array = left
     end select
  end function indexes

  ! --------------------------------------------------  Int2Strings  -----
  subroutine Ints2Strings ( ints, strs )
    ! takes an array of integers and returns string array
    ! using "char"
    ! Useful due to bug in toolbox swrfld
    !
    ! See also strings2Ints
    !--------Argument--------!
    !    dimensions are (len(strs(1)), size(strs(:)))
    integer, intent(in), dimension(:,:) ::          ints
    character (len=*), intent(out), dimension(:) :: strs

    !----------Local vars----------!
    integer :: i, substr, strLen, arrSize
    !----------Executable part----------!

   ! Check that all is well (if not returns blanks)
   strLen = MIN(len(strs(1)), size(ints, dim=1))
   arrSize = MIN(size(strs), size(ints, dim=2))
   strs = ' '
   if ( strLen <= 0 .or. arrSize <= 0 ) return
   do i=1, arrSize
      do substr=1, strLen
         strs(i)(substr:substr) = achar(ints(substr, i))
      end do
   end do

  end subroutine Ints2Strings

  ! ---------------------------------------------------  isRepeat  -----
  logical function isRepeat(str, substr)
    character(len=*), intent(in) :: str
    character(len=*), intent(in), optional :: substr
     ! Is str formed purely of repeated blocks of substr?
     ! If substr not supplied, 
     ! then is str any one character repeated over and over?
     ! Special cases:
     ! str = ' ' => TRUE 
     ! str != ' ' and substr = ' ' => FALSE
     ! Note that otherwise we're ignoring trailing blanks
     integer :: strlen
     integer :: substrlen
     character(len=1) :: aChar
     isRepeat = .false.
     if ( len_trim(str) < 1 ) then
       isRepeat = .true.
       return
     endif
     strlen = len_trim(str)
     if ( present(substr) ) then
       substrlen = len_trim(substr)
       if ( substrlen < 1 ) return
       isRepeat = (substrlen*ncopies(trim(str), trim(substr)) >= strlen)
       return
     endif
     aChar = str(1:1)
     isRepeat = (ncopies(trim(str), aChar) >= strlen)
  end function isRepeat

  ! ------------------------------------------------  Justify  -----
  function Justify ( str, length, mode ) result ( Justified )
    ! Return the string str Justified to fit the supplied length
    ! by padding its interior spaces. 
    ! Thus it turns
!The first line                                                                *
    ! into 
!The                                 final                                 line*
   
    ! Note:
    !      meaning both left-right justified; we aim to distribute
    !      any padding fairly, by which we mean not favoring gaps due their
    !      position but only their occurrence number.
    !      An alternate strategy would be based on the substring index number
    !      instead of the gap occurrence number. Could we implement both
    !      and allow the user to choose? Let's use the optional arg 'mode':
    !      mode           means
    !      ----           -----
    !       g             count gaps
    !       s             count substrings
    !
    ! See also Stretch
    ! Args
    character (len=*), intent(in)                :: str
    integer, intent(in)                          :: length
    character, intent(in), optional              :: mode ! 's' or 'g'
    character (len=length)                       :: justified
    ! Local variables
    character(len=length)                        :: newStr ! A temp
    integer                                      :: i ! substring index of str
    integer                                      :: j ! index of last gap
    integer                                      :: k ! index of justified
    character                                    :: myMode
    integer                                      :: n ! integer part of x
    integer                                      :: nWords
    logical                                      :: stillInGap ! Was last char blank?
    integer                                      :: surplus ! how many extra
    real                                         :: dx ! density of extra
    real                                         :: x  ! accumulated extra
    ! Executable
    justified = str
    ! print *, 'length, len_trim(justified): ', length, len_trim(justified)
    if ( length <= len_trim(justified) ) return
    nWords = count_words ( str )
    ! print *, 'nWords: ', nWords
    if ( nWords < 2 ) return
    myMode = 'g' ! Defaults to counting gaps, not substrings
    if ( present(mode) ) myMode = mode
    newStr = adjustl(str)
    surplus = length - len_trim(newstr)
    if ( myMode == 'g' ) then
      ! dx is the avg number of spaces to add to each gap
      dx = surplus / (nWords - 1.0)
    else
      ! dx is the avg number of spaces to add at each char
      dx = surplus / real(len_trim(newStr))
    endif
    ! print *, 'surplus, dx: ', surplus, dx
    ! We'll accumulate them at each gap, 
    ! acting only when we have enough to add an extra space
    x = 0.
    stillInGap = .false.
    k = 0
    do i=1, len_trim(newStr)
      if ( myMode /= 'g' ) x = x + dx
      if ( newStr(i:i) /= ' ' .or. stillInGap ) then
        k = k + 1
        justified(k:k) = newStr(i:i)
        stillInGap = ( newStr(i:i) == ' ' )
        if ( myMode /= 'g'  .and. x > 1. .and. stillInGap ) then
          ! Yes, we must add more spaces. How many?
          n = x
          ! print *, 'Adding spaces: ', n
          justified(k+1:k+n) = ' '
          x = x - n
          k = k + n
        endif
        cycle
      endif
      ! We're starting a new gap--must we add spaces?
      if ( myMode == 'g' ) x = x + dx
      if ( x > 1. ) then
        ! Yes, we must. How many?
        n = x
        ! print *, 'Adding spaces: ', n
        justified(k+1:k+n) = ' '
        x = x - n
        k = k + n
      endif
      stillInGap = .true.
      k = k + 1
      justified(k:k) = newStr(i:i)
    enddo
    ! Did we end at length?
    ! Probably not, so must add more spaces
    ! print *, 'k, length: ', k, length
    if ( k >= length ) return
    newStr = justified
    i = FindFirst( newStr, ' ' )
    n = length - k
    ! print *, 'i, n: ', i, n
    if ( nWords < 3 .or. n < 2 ) then
      ! crowd all n extra spaces inside the first gap
      justified = ' '
      justified = newStr(1:i) // repeat( ' ', n ) // newStr(i+1:)
    else
      ! Put (n/2) extra spaces inside the first gap
      ! and the other (n/2) inside the last gap
      j = FindLast( trim(newStr), ' ' )
      justified = ' '
      justified = newStr(1:i) // repeat( ' ', n/2 ) // newStr(i+1:j) // &
        & repeat( ' ', n - (n/2) ) // newStr(j+1:)
    endif
  end function Justify

  ! ------------------------------------------------  lenTrimToAscii  -----
  function lenTrimToAscii (str) result (trimmedLength)
    ! Return the len_trim of a string treating all non-Ascii as blanks
    ! -----added by hcp-------- 
    !--------argument--------!
    character (len=*), intent(in) :: str
    !---------result---------!
    integer :: trimmedLength
    !-----local-variables------!
    character(len=len(str)) :: newStr
    !-------executable-code----!
    newStr = ReplaceNonAscii( str, char(32) )
    trimmedLength = len_trim( newStr )
  end function lenTrimToAscii

  ! ------------------------------------  LinearSearchStringArray  -----

  ! This routine does a simple linear search for a string in an array.
  ! If the case insensitive flag is set the strings are capitalized first.
  ! If the test substring flag is set, the string is tested as a substring.
  ! If the listInString flag is set, the array list is tested as substrings
  !  against the string; otherwise, the string is tested as a substring
  !  against the array list.
  ! If the string is not found, 0 is returned

  function LinearSearchStringArray (list, string, caseInsensitive, &
       & testSubstring, listInString) result (sindex)

    ! Dummy arguments
    character (len=*), dimension(:) :: list
    character (len=*) :: string
    logical, intent (in), optional :: caseInsensitive
    logical, intent (in), optional :: testSubstring
    logical, intent (in), optional :: listInString


    ! function result
    integer :: sindex   ! matching string index (0 = not found)

    ! Local variables
    integer :: i
    logical :: useCaseInsensitive
    logical :: testForSubstring
    logical :: testForList
    logical :: found

    ! Executable code

    IF (PRESENT(caseInsensitive)) THEN
       useCaseInsensitive = caseInsensitive
    ELSE
       useCaseInsensitive = .FALSE.
    END IF

    IF (PRESENT(testSubstring)) THEN
       testForSubstring = testSubstring
    ELSE
       testForSubstring = .FALSE.
    END IF

    IF (PRESENT(listInString)) THEN
       testForList = listInString
    ELSE
       testForList = .FALSE.
    END IF

    found = .FALSE.
    sindex = 0

    ! Put the conditional outside the loop for speed (not that it will make 
    ! much difference for strings)

    IF (useCaseInsensitive) THEN
       linSearchStringInsens: DO i = 1, SIZE(list)
          IF (testForSubstring) THEN
             IF (testForList) THEN
                found = (INDEX (Capitalize(TRIM(string)), &
                     & Capitalize(TRIM(list(i)))) /= 0)
             ELSE
                found = (INDEX (Capitalize(TRIM(list(i))), &
                     & Capitalize(TRIM(string))) /= 0)
             END IF
          ELSE
             found = (Capitalize(TRIM(list(i))) == Capitalize(TRIM(string)))
          END IF
          IF (found) THEN
             sindex = i
             EXIT linSearchStringInsens
          END IF
       END DO linSearchStringInsens
    ELSE
       linSearchStringSens: DO i = 1, SIZE(list)
          IF (testForSubstring) THEN
             IF (testForList) THEN
                found = (INDEX (TRIM(string), TRIM(list(i))) /= 0)
             ELSE
                found = (INDEX (TRIM(list(i)), TRIM(string)) /= 0)
             END IF
          ELSE
             found = (TRIM(list(i)) == TRIM(string))
          END IF
          IF (found) THEN
             sindex = i
             EXIT linSearchStringSens
          END IF
       END DO linSearchStringSens
    END IF

  end function LinearSearchStringArray

  ! ---------------------------------------------------  NAppearances  -----
  function NAppearances( str, substrings, dontTrim ) result(array)
    character(len=*), intent(in) :: str
    character(len=*), intent(in), dimension(:) :: substrings
    logical, optional, intent(in) :: dontTrim
    integer, dimension(size(substrings)) :: array
    ! Returns the array of the number of times each element of substrings
    ! appears in str
    ! E.g., if str='ababababababa' and substrings = (/'a', 'ab', 'abab', 'b'/)
    !      result
    !      ------
    !   (/7, 6, 3, 6/)
    !
    ! Method:
    ! Use indexes function to find successive indexes of a single substring
    !
    ! Note:
    !     these are distinct, non-overlapping occurrences of each sub-string
    !     the dontTrim option not yet passed to indexes
    ! Internal variables
    integer, dimension(len(str)) :: tmpArray
    character(len=len(substrings)), dimension(len(str)) :: tmpSubs
    integer :: i
    logical :: myDontTrim
    ! Executable
    myDontTrim = .false.
    if ( present(dontTrim) ) myDontTrim = dontTrim
    do i=1, size(substrings)
      tmpArray = 0
      tmpSubs = substrings(i)
      if ( myDontTrim ) then
        tmpArray = indexes( str, tmpSubs, 'left' )
      else
        tmpArray = indexes( trim_safe(str), tmpSubs, 'left' )
      endif
      array(i) = count( tmpArray > 0 )
    enddo
  end function NAppearances

  ! ---------------------------------------------------  ncopies  -----
  integer function ncopies(str, substr, overlap)
    character(len=*), intent(in) :: str
    character(len=*), intent(in) :: substr
    logical, optional, intent(in) :: overlap
     ! How many copies of substr are in str?
     ! The copies may optionally overlap
     ! E.g., str = 'aaaa', substr = 'aa'
     ! overlap = FALSE => ncopies = 2
     ! overlap = TRUE => ncopies = 3
     integer :: ipos
     integer :: next
     logical :: mayOverlap
     !
     mayOverlap = .false.
     if ( present(overlap) ) mayOverlap = overlap
     ncopies = 0
     ipos = 1
     do
       if ( ipos > len_trim(str) ) return
       next = index(str(ipos:), substr)
       if ( next < 1 ) then
         return
       endif
       ncopies = ncopies + 1
       if ( .not. mayOverlap ) then
         ipos = ipos + next + len(substr) - 1
       else
         ipos = ipos + next
       endif
     enddo
  end function ncopies

  ! ----------------------------  ReadCompleteLineWithoutComments  -----

  ! This funtion reads a line or set of lines from a text file and returns a
  ! string giving the full command with continuation lines joined, and comments
  ! removed.

  ! EOF can be returned if requested

  ! Note that this doesn't consider quotation marks, comments within quoted
  ! strings are considered comments, and continuation marks can apply within
  ! quoted strings.  Later versions of this routine may be more intelligent.

  subroutine ReadCompleteLineWithoutComments(unit,fullLine,eof, &
       & commentChar,continuationChar)

    ! Dummy arguments

    integer, intent(in) :: unit ! Input file unit
    ! fullLine changed to intent InOut by HCP. Some (but not all) 
    ! F90 compilers won't let this be intent(out) because the declaration
    ! of inputLine makes use of the length of fullLine even if its _contents_
    ! are immaterial
    character(len=*), intent(inout) :: fullLine ! Output line
    character(len=*), optional :: commentChar
    character(len=*), optional :: continuationChar
    logical, intent(out), optional :: eof ! Set if got to eof

    ! Local variables

    integer :: ioInfo           ! IOSTAT result
    character(len=len(fullLine)) :: inputLine ! One line from file
    integer :: commentStart     ! Start of a comment in line
    integer :: lastChar         ! Last character position in line
    integer :: gotContinuation  ! 1 if continuation needed, 0 if not
    logical :: firstLine        ! A correction to be applied

    character(len=1) :: useCommentChar
    character(len=1) :: useContinuationChar

    ! Executable code

    ! Set default values for arguments
    
    IF (.NOT. PRESENT(commentChar)) THEN
       useCommentChar=";"
    ELSE
       useCommentChar=commentChar
    END IF

    IF (.NOT. PRESENT(continuationChar)) THEN
       useContinuationChar="$"
    ELSE
       useContinuationChar=continuationChar
    END IF

    ! Set up for loop

    fullLine=""
    firstLine=.TRUE.
    IF (PRESENT(eof)) eof=.FALSE.

    readLoop: DO

       ! Try to read a line of text

       READ (UNIT=unit,FMT="(a)",IOSTAT=ioInfo) inputLine
       IF (ioInfo /= 0) THEN 
          IF (PRESENT(eof)) eof=.TRUE.
          EXIT readLoop
       END IF

       ! Now we look for the start of a comment and remove any following text
       ! from this line.

       commentStart=INDEX(inputLine,useCommentChar)
       IF (commentStart /= 0) inputLine=inputLine(1:commentStart-1)

       ! See if the last non blank character is a contination

       lastChar=LEN_TRIM(inputLine)
       ! if bloc inserted by HCP because inputline(lastchar:lastchar:) 
       ! caused errors with array bounds checking turned on with
       ! some f90 compilers.
       if (lastChar > 0) then 
          gotContinuation=INDEX(inputLine(lastChar:lastChar),&
               useContinuationChar)
       else
          gotContinuation=0
       end if
       ! Concatenate this with what we have so far, make sure there's an extra
       ! space there though (not for first line though)

       ! If block inserted 5 Sept. 2000 by HCP to prevent an out-of-range 
       ! error when the input line has 0 length and you have bounds-checking
       ! turned on
       if(LEN_TRIM(inputLine) > 0) then 
          inputLine=inputLine(1:LEN_TRIM(inputLine)-gotContinuation)
       end if
       IF (firstLine) THEN
          fullLine=inputLine
          firstLine=.FALSE.
       ELSE
          fullLine=fullLine(1:LEN_TRIM(fullLine)+1)//inputLine
       END IF
       
       ! If we have a continuation mark, or a blank line then keep reading
       IF ((gotContinuation==0).AND.(LEN_TRIM(fullLine) /= 0)) EXIT readLoop
    END DO readLoop

    ! Do a final trim and exit

    fullLine=TRIM(ADJUSTL(fullLine))

  end subroutine ReadCompleteLineWithoutComments

  ! ----------------  readNumFromBaseN  -----
  ! read a number which had been reexpressed in base n from a string
  
  ! Use:
  ! Return e.g. the number 1989 in base 5 from str='3 0 4 2 4'
  ! i.e., 4 + 5*(2 + 5*(4 + 5*(0 + 5*3)))
  ! According to the options string, the intermediate integer coefficients
  ! will be based on
  !  options contain            coefficient string
  !    ---                      ------------------
  !   (default)                 decimal integers, separated by spaces
  !                              e.g., ''13 4 29 6''
  !      x                      "Extended" hexadecimal-style (hex if N = 16)
  !                               e.g., '9 b d 2 f 0 0 0'
  !      c                      compressed str; otherwise like 'x'
  !                               i.e. no spaces separate each digit
  !                               e.g., '9bd2f000'
  ! 0123456789012345678901234567890123456789012345678901234567890123456789
  ! 0123456789abcdefghijklmnopqrstuvwxyz;'[]ABCDEFGHIJKLMNOPQRSTUVWXYZ:"{}
  !                              (good only up to base 70)
  !
  ! The default representation can handle arbitrarily large moduli
  ! a or A is limited to the unique range of achar
  ! x is good only up to a modulus of 70.

  ! Notes
  ! (1) we do not check that the str is a valid number in base N
  !     E.g., you can enter '10 0 1' in base 5 and get back a numerical
  !     result of 251 instead of an error message
  ! (2) we do not check that str would be converted to an integer
  !     outside the largest representable
  ! (3) At first we intended to include the following options; however
  !     it never became clear that there was an urgent need they satisfied
  !      a                      achar(c[m]) in the same order
  !                              e.g., CR // EOT // GS // ACR   
  !      A                      like a but converted to ascii
  !                              e.g., '<CR>' // '<EOT>' // '<GS>' // <ACR>   

  subroutine readIntFromBaseN ( STR, K, N, OPTIONS )
    ! reads an integer from a string
    ! using poorly-tested but hopefully non-critical code
    
    ! Note: beware of integer overflow; if str would be converted
    ! to an int > max integer representable, you must
    ! use the api which reads a float from str instead

    !--------Argument--------!
    character (len=*), intent(in)           ::   str
    integer, intent(out)                    ::   k ! integer result
    integer, intent(in)                     ::   N ! the base
    character(len=*), optional, intent(in)  ::   options
    include "ReadNumFromBaseN.f9h"
  end subroutine readIntFromBaseN

  subroutine readFloatFromBaseN ( STR, k, N, OPTIONS )
    ! reads an f.p. number from a string
    ! using poorly-tested but hopefully non-critical code

    !--------Argument--------!
    character (len=*), intent(in)           ::   str
    real, intent(out)                       ::   k ! integer result
    integer, intent(in)                     ::   N ! the base
    character(len=*), optional, intent(in)  ::   options
    include "ReadNumFromBaseN.f9h"
  end subroutine readFloatFromBaseN

  subroutine readARealFromChars (str, num, forbiddens, ignore)
    !--------Argument--------!
    character (len=*), intent(in) ::   str
    real, intent(out)             ::   num
    include 'ReadANumFromChars.f9h'
  end subroutine readARealFromChars

  subroutine readADoubleFromChars (str, num, forbiddens, ignore)
    !--------Argument--------!
    character (len=*), intent(in) ::   str
    double precision, intent(out)             ::   num
    include 'ReadANumFromChars.f9h'
  end subroutine readADoubleFromChars

  subroutine ReadRealArrayFromChars (strs, nums, forbiddens, ignore)
    character (len=*), intent(in), dimension(:) ::   strs
    real, intent(out), dimension(:)             ::   nums
    character (len=*), intent(in), optional     ::   forbiddens
    character (len=*), optional, intent(in)     :: ignore

    !----------Local vars----------!
    integer :: i, arrSize
    !----------Executable part----------!

   ! Check that all is well (if not returns blanks)
   arrSize = MIN(size(strs), size(nums))
   if ( arrSize <= 0 ) then
     nums = LENORSIZETOOSMALL
     return
   endif
   do i=1, arrSize
     call readARealFromChars(strs(i), nums(i), forbiddens, ignore)
   enddo

  end subroutine ReadRealArrayFromChars

  subroutine ReadDoubleArrayFromChars (strs, nums, forbiddens, ignore)
    character (len=*), intent(in), dimension(:) ::   strs
    double precision, intent(out), dimension(:) ::   nums
    character (len=*), intent(in), optional     ::   forbiddens
    character (len=*), optional, intent(in)     :: ignore

    !----------Local vars----------!
    integer :: i, arrSize
    !----------Executable part----------!

   ! Check that all is well (if not returns blanks)
   arrSize = MIN(size(strs), size(nums))
   if ( arrSize <= 0 ) then
     nums = LENORSIZETOOSMALL
     return
   endif
   do i=1, arrSize
     call readADoubleFromChars(strs(i), nums(i), forbiddens, ignore)
   enddo

  end subroutine ReadDoubleArrayFromChars

  ! ----------------  readRomanNumerals  -----
  ! Read a string composed of roman numerals into an int
  
  ! Use:
  ! Given e.g. str='MCMLXXXIX ' return in num the value 1989
  subroutine readRomanNumerals ( str, num )
    ! takes a string and returns an integer
    ! using poorly-tested but hopefully non-critical code

    ! Method:
    ! Process string left to right looking first for highest-valued char
    ! then working down to lowest valued
    ! When ever a lower-valued char is found to left of a higher valued
    ! one, it and all chars up to higher value are azxsigned negative value
    ! e.g., 'cm' is -100 + 'm', or 'xm' i -10 + 'm'
    ! The second example is non-standard roman numerals; we can read them
    ! anyway

    ! Limitation: we treat upper case and lowercase equivalently
    ! we ignore non-roman strings
    !
    !--------Argument--------!
    character (len=*), intent(in) ::   str
    integer, intent(out)          ::   num
    ! Internal variables
    character(len=1), dimension(7), parameter :: romans = &
      & (/  'm', 'd', 'c', 'l', 'x', 'v', 'i' /)
    integer, dimension(7), parameter :: values = &
      & (/ 1000, 500, 100, 50,  10,   5,   1 /)
    integer :: strpos  ! What str character we're on
    integer :: r_index ! What romans index we're searching for
    ! Executable
    num = 0
    if ( len_trim(str) < 1 ) return
    ! Outer loop: string character number
    do strpos=1, len_trim(str)
      ! Inner loop: romans index
      do r_index=1, 7
        if ( lowercase(str(strpos:strpos)) /= romans(r_index) ) cycle
        ! OK, we've found it--but is there a higher-valued one to the right?
        if ( r_index == 1 .or. strpos == len_trim(str) ) then
          num = num + values(r_index)
        elseif ( any(indexes( lowercase(str(strpos+1:)), romans(1:r_index-1)) > 0 ) ) then
          num = num - values(r_index)
        else
          num = num + values(r_index)
        endif
      enddo
    enddo
  end subroutine readRomanNumerals

   ! --------------------------------------------------  remap  -----
  function remap ( str, old, new ) result (outstr)
    ! Replaces every old in the input str with the corresponding new char
    ! E.g., given 
    ! str = 'Four score and seven years' and
    ! old = 'osa' and new = '0$9', then the result will be
    ! result = 'F0ur $c0re 9nd $even year$'
    ! Notes
    ! (1) characters in str not found in old will be left unchanged
    ! (2) if new is shorter than old, some old characters may be replaced by blanks
    ! (3) See also Rot13 and Replace
    !--------Argument--------!
    character (len=*), intent(in) :: str
    character (len=*), intent(in) :: old
    character (len=*), intent(in) :: new
    character (len=max(len_trim(str), 1)) :: outstr

    !----------local vars----------!
    integer :: i
    integer :: it
    !----------executable part----------!
    outstr = str
    if( len_trim(str) < 1 .or. len(old) < 1 ) return
    do i = 1, len_trim(str)
       it = index( old, str(i:i) )
       if ( it > 0 .and. it < len_trim(new)+1 ) then
         outstr(i:i) = new(it:it)
       elseif ( it > len_trim(new) ) then
         outstr(i:i) = ' '
       endif
    end do

  end function remap

   ! --------------------------------------------------  Replace  -----
  function Replace ( str, oldChar, newchar, max, reverse ) result ( outstr )
    ! takes a string and returns one with oldChar replaced by newChar
    ! E.g., to replace every char(0), which is the NUL character, with a blank
    ! arg = Replace( arg, char(0), char(32) )
    !
    ! If TRUE, the optional arg reverse replaces all the chars /= oldChar
    ! E.g., the following can be used to underline chars
    !  underlineChars = Replace( chars, ' ', '-', reverse=.true. )
    character(len=*), intent(in)  :: str
    character(len=1), intent(in)  :: oldChar
    character(len=1), intent(in)  :: newChar
    integer, optional, intent(in) :: max ! up to how many such replacements?
    logical, optional, intent(in) :: reverse ! Replace if /= oldChar?
    character(len=len(str))       :: outstr
    ! Internal variables
    integer :: i, n
    integer :: myMax
    logical :: myReverse
    integer :: reps
    ! Executable
    outstr = str
    if ( len(str) < 1 ) return
    if ( index(str, oldChar) < 1 ) return
    myMax = Huge(0) / 2
    if ( present(max) ) myMax = max
    myReverse = .false.
    if ( present(reverse) ) myReverse = reverse
    n = len(str)
    reps = 0
    do i=1, n
      if ( .not. myReverse ) then
        if ( str(i:i) == oldChar ) then
          reps = reps + 1
          if ( reps > myMax ) exit
          outstr(i:i) = newChar
        endif
      else
        ! Reverse sense: replace only the chars /= oldChar
        if ( str(i:i) /= oldChar ) then
          reps = reps + 1
          if ( reps > myMax ) exit
          outstr(i:i) = newChar
        endif
      endif
    enddo
  end function Replace

   ! --------------------------------------------------  Reverse  -----
  elemental function Reverse (str) result (outstr)
    ! takes a string and returns one with chars in reversed order
    ! Useful in certain contexts:
    ! e.g., to remove leading blanks
    ! arg = Reverse(TRIM(Reverse(arg)))
    !
    ! See also Reverse_trim, ReverseList
    !--------Argument--------!
    character (len=*), intent(in) :: str
    character (len=len(str)) :: outstr

    !----------Local vars----------!
    integer :: i, istr, irev
    character (len=1) :: strChar
    !----------Executable part----------!
    outstr=str
    IF(LEN(str) == 1) RETURN

    DO i = 1, LEN(str)-1, 2
       istr = 1 + (i-1)/2                       ! 1, 2, ..
       irev = LEN(str) - (i-1)/2                ! N, N-1, ..
       strChar = str(istr:istr)
       outstr(istr:istr) = str(irev:irev)
       outstr(irev:irev) = strChar
    END DO

! Special case: str contains odd number of chars
    IF(MOD(LEN(str), 2) == 1) THEN
       istr = 1 + (LEN(str)-1)/2                ! 1, 2, ..
        outstr(istr:istr) = str(istr:istr)
    ENDIF

  end function Reverse

   ! --------------------------------------------------  Reverse_trim  -----
  function Reverse_trim (str) result (outstr)
    ! takes a string, trims it then returns one with chars in reversed order
    ! See also Reverse which omits the trim step
    !
    ! E.g., given 'A string    ' reverse_trim returns 'gnirst A   ' while
    ! a simple Reverse returns '   gnirst A'
    !
    ! Uses:
    ! To find the last non-blank character in a string str
    !   rev = reverse_trim(str)
    !   it = rev(1:1)
    !--------Argument--------!
    character (len=*), intent(in) :: str
    character (len=max(len_trim(str), 1)) :: outstr

    !----------Local vars----------!
    integer :: i, istr, irev
    character (len=1) :: strchar
    !----------Executable part----------!
    outstr=str
    IF(LEN_TRIM(str) <= 1) RETURN

    DO i = 1, LEN_TRIM(str)-1, 2
       istr = 1 + (i-1)/2                       ! 1, 2, ..
       irev = LEN_TRIM(str) - (i-1)/2           ! N, N-1, ..
       strChar = str(istr:istr)
       outstr(istr:istr) = str(irev:irev)
       outstr(irev:irev) = strChar
    END DO

! Special case: str contains odd number of chars
    IF(MOD(LEN_TRIM(str), 2) == 1) THEN
       istr = 1 + (LEN_TRIM(str)-1)/2           ! 1, 2, ..
        outstr(istr:istr) = str(istr:istr)
    ENDIF

  end function Reverse_trim

   ! --------------------------------------------------  Rot13  -----
  function Rot13 ( str, nn, otp, inverse ) result (outstr)
    ! performs generalized ROT13 on the input str
    ! E.g., given 
    ! 'Look, a cryptic message!' Rot13 returns 'Ybbx, n pelcgvp zrffntr!'
    ! Rot13 is self-inverting
    ! ROT(nn) is more general shift by nn, 0 < nn < 26
    ! If ROT(nn) and ROT(mm) are inverses, then nn + mm = 26
    
    ! The optional arg "inverse" if TRUE performs the inverse shift
    
    ! In principle use of a one-time pad makes an encrypted message
    ! unbreakable. The string of characters in otp will be used one-by-one
    ! to shift the input str
    !--------Argument--------!
    character (len=*), intent(in) :: str
    integer, optional, intent(in)         :: nn
    logical, optional, intent(in)         :: inverse
    character (len=*), optional, intent(in) :: otp
    character (len=max(len_trim(str), 1)) :: outstr

    !----------local vars----------!
    integer :: i, it, nprime, o, oprime
    logical :: inv
    !----------executable part----------!
    outstr = ' '
    if(len_trim(str) < 1) return
    nprime = 13
    if ( present(nn) ) nprime = nn
    inv = .false.
    if ( present(inverse) ) inv = inverse
    if ( inv ) nprime = 26 - nprime
    do i = 1, len_trim(str)
       o = iachar( str(i:i) )
       ! Leave non-printing characters alone
       if ( o < 32 ) then
         oprime = o
       elseif ( present(otp) ) then
         if ( len_trim(otp) < i ) then
           it = mod( i-1, len_trim(otp) ) + 1
           nprime = iachar( otp(it:it) )
         else
           nprime = iachar( otp(i:i) )
         endif
         if ( nprime < 32 ) nprime = 32 + nprime
         if ( .not. inv ) then
           oprime = 32 + mod(o-32 + nprime-32, 95)
         else
           oprime = 32 + mod(o-32 - nprime+32+95, 95)
         endif
       elseif ( 64 < o ) then
         if ( o < 91 - nprime ) then
           oprime = o + nprime
         elseif ( o < 91 ) then
           oprime = o + nprime - 26
         elseif ( o < 97 ) then
           oprime = o
         elseif ( o < 123 - nprime ) then
           oprime = o + nprime
         elseif ( o < 123 ) then
           oprime = o + nprime - 26
         else
           oprime = o
         endif
       else
         oprime = o
       endif
       outstr(i:i) = achar(oprime)
    end do

  end function Rot13

   ! --------------------------------------------------  shiftLRC  -----
  elemental function shiftLRC (str, position, fillChar) result (outstr)
    ! shifts the characters in a string with leading or trailing blanks to:
    ! position
    !  'l[eft]'    all the way to the left
    !  'c[enter]'  so that they are centered within the string
    !  'r[ight]'   all the way to the right (default)
    ! optionally, replaces the surrounding blanks with fillChar
    !--------Argument--------!
    character (len=*), intent(in)           :: str
    character (len=*), optional, intent(in) :: position
    character (len=1), optional, intent(in) :: fillChar
    character (len=len(str))                :: outstr

    !----------Local vars----------!
    integer :: i_average
    integer :: i_leading
    integer :: i_trailing
    character(len=1) :: myPosition
    !----------Executable part----------!
    outstr=str
    if( len_trim(str) < 2 .or. len(str) == len_trim(str) ) return
    myPosition = 'r'
    if ( present(position) ) myPosition = lowerCase(position(1:1))
    select case (myPosition)
    case ('l')
      outstr = adjustl(str)
      if ( present(fillChar) ) then
        i_trailing = len(outstr) - len_trim(outstr)
        outstr = trim(outstr) // repeat(fillChar, i_trailing)
      endif
    case ('r')
      outstr = adjustr(str)
      if ( present(fillChar) ) then
        i_leading = len_trim(outstr) - len_trim(adjustl(outstr))
        outstr = repeat(fillChar, i_leading) // adjustl(outstr)
      endif
    case ('c')
      ! Method: average the number of leading and trailing blanks
      i_leading = len_trim(str) - len_trim(adjustl(str))
      i_trailing = len(str) - len_trim(str)
      i_average = (i_leading+i_trailing)/2
      if ( .not. present(fillChar) ) then
        outstr = ' '
        outstr(i_average+1:) = adjustl(str)
      else
        outstr = repeat(fillChar, i_average) // trim(adjustl(outstr)) // &
          &         repeat(fillChar, i_average)
      endif
    case default
      outstr = adjustr(str)
      if ( present(fillChar) ) then
        i_leading = len_trim(outstr) - len_trim(adjustl(outstr))
        outstr = repeat(fillChar, i_leading) // adjustl(outstr)
      endif
    end select
  end function shiftLRC

  ! ------------------------------------------------  size_trim  -----
  function size_trim ( strs, safe ) result (length)
    ! This performs len_trim of character scalar equivalent to 
    !--------Argument--------!
    character (len=*), dimension(:), intent(in) :: strs
    logical, optional, intent(in)               :: safe
    !---------result---------!
    integer::length
    !-----local-variables------!
    character(len=size(strs)*len(strs)) :: together, ttogether
    !-------Executable-code----!
    together = transfer( strs, ttogether )
    length = len_trim( together )
    if ( .not. present(safe) ) return
    if ( safe ) length = max( length, 1 )
  end function size_trim

  ! ---------------------------------------------  SplitDetails  -----

  ! This subroutine splits an input string into 2 parts:
  ! a string which is the switch
  ! and an integer which is the details
  ! It assumes that they are catenated as in the example
  !     'pro1' => 
  !         {string = 'pro', 
  !          details = 1}
  ! This corresponds directly to how the Switches data is
  ! encoded and used by level 2
  ! Any other usefulness would be purest serendipity
  ! (a tempting name for this subroutine, but for once
  ! we succeeded in resisting temptation--for each 'serendipity' we
  ! would have a thousand 'crudeButUsefulHack's)

  subroutine SplitDetails( str, switch, details )
    character(len=*), intent(in)           :: str
    character(len=*), intent(out)          :: switch
    integer, intent(out)                   :: details
    ! Local variables
    character(len=*), parameter :: digits    = '1234567890'
    character(len=*), parameter :: nondigits = 'abcdefghijklmnopqrstuvwxyz' // &
      &                                        'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    integer                     :: firstDigitPosition
    integer                     :: lastNonDigitPosition
    ! Executable
    switch = ' '
    details = 0   ! If details is absent, this is its default
    if ( len_trim(str) < 1 ) return
    firstDigitPosition = scan( str, digits )
    if ( firstDigitPosition < 1 ) then
      ! No details present
      switch = str
    elseif ( firstDigitPosition == 1 ) then
      ! No switch present
      call readAnIntFromChars ( str, details )
    else
      ! OK, we can't naively assume what we found marks the switch detail start
      ! because there might be internal digits in the switch, e.g. 'l1bread'
      ! Therefore, we must determine the last non-digit position
      lastNonDigitPosition = scan( str, nondigits, back=.true. )
      firstDigitPosition = lastNonDigitPosition + 1
      if ( firstDigitPosition > len_trim(str) ) then
        ! No details present
        switch = str
      else
        switch = str(:firstDigitPosition-1)
        call readAnIntFromChars ( str(firstDigitPosition:), details )
      endif
    endif
  end subroutine SplitDetails

  ! ---------------------------------------------  SplitNest  -----

  ! This subroutine splits an input string into 3 parts; it is most
  ! easily described with the following diagram:
  ! Given "part 1 (part 2) part 3"
  ! it returns "part 1" "part 2" "part 3"
  ! Note the paramount role played by the nesting parentheses
  ! If given "No parentheses here", part 2 and part 3 will be empty
  ! If given "(part 2)" part 1 and part 3 will be empty
  ! The cases where only part 1 or only part 3 would be empty are obvious
  ! To permit recursive passes, the split is made at the rightmost pair
  ! of nesting parentheses
  ! Thus given
  ! "(((a))) (b (c))"
  ! it will return "(((a))) (b " "c" and ")"
  ! The motivation is to recursively parse expressions such as
  ! "p or not (q and (r or s))"
  ! by turning this by successive steps of collapsing the nesting parentheses
  ! "p or not (q and t)"
  ! "p or not u"
  ! Since we collapse one nesting level each time, we are assured of
  ! arriving at an expression without nests in a finite number of steps

  subroutine SplitNest( str, part1, part2, part3, parens )
    character(len=*), intent(in)           :: str
    character(len=*), intent(out)          :: part1
    character(len=*), intent(out)          :: part2
    character(len=*), intent(out)          :: part3
    character(len=*), intent(in), optional :: parens
    ! Local variables
    character(len=1) :: closeParen ! Usu. right parenthesis
    integer          :: firstOpen
    integer          :: matchingClose
    character(len=1) :: openParen  ! Usu. left parenthesis
    ! Executable
    if ( present(parens) ) then
      openParen  = parens(1:1)
      closeParen = openParen
      if ( len_trim(parens) > 1 ) closeParen = parens(2:2)
    else
      openParen  = '('
      closeParen = ')'
    endif
    part1 = ' '
    part2 = ' '
    part3 = ' '
    if ( str == ' ' ) return
    firstOpen = index( str, openParen, back=.true. )
    if ( firstOpen < 1 ) then
      part1 = str
      return
    endif
    matchingClose = index( str(firstOpen+1:), closeParen )
    if ( matchingClose < 1 ) then
      ! This probably means an ill-formed expression with an unmatched '('
      part1 = str
      return
    endif
    matchingClose = matchingClose + firstOpen ! Referenced back to original
    if ( firstOpen > 1 ) part1 = str(1:firstOpen-1)
    if ( matchingClose < len_trim(str) ) part3 = str(matchingClose+1:)
    part2 = str(firstOpen+1:matchingClose-1)
  end subroutine SplitNest

  ! -------------------------------------------------  SplitWords  -----

  ! This subroutine is based on my IDL one of the same name.
  ! A line of input is split into sets of words.  There are two ways in which
  ! this can be invoked.  Typically it is split into `first' and 'rest'
  ! However, if the threeway option is given it is split to first, rest and
  ! last.

  ! Note that there is a slight subtlety here, spaces are treated specially
  ! due to the use of TRIM.  Thus while two commas in a row would count as
  ! two separators, two spaces would count as one. Also if , is the separator
  ! then ,<space> counts as complete separator.
  
  ! Apologies--I have replaced almost all uses of the word "delimiter" with
  ! the word "separator" in a global manner, excepting only
  ! the optional last arg to this subroutine

  elemental subroutine SplitWords(line,first,rest,last,&
       & threeWay,delimiter)

    ! Dummy arguments

    character (len=*), intent(in) :: line
    character (len=*), intent(out) :: first
    character (len=*), intent(out) :: rest
    character (len=*), intent(out), optional :: last

    logical, intent(in), optional :: threeWay
    character (len=*), intent(in), optional :: delimiter ! really separator

    ! Local variables

    character (len=1) :: useseparator
    logical :: useThreeWay
    character (len=len(line)) useLine ! Line with leading spaces removed

    integer :: firstseparatorPos,lastseparatorPos,trimmedLen

    ! Executable code

    useLine=ADJUSTL(line)
    trimmedLen=LEN_TRIM(useLine)

    IF (PRESENT(delimiter)) THEN
       useseparator=delimiter
    ELSE
       useseparator=","
    END IF

    IF (PRESENT(threeWay)) THEN
       useThreeWay=threeWay 
    ELSE 
       useThreeWay=.FALSE.
    END IF

    ! Clear some results by default

    IF (PRESENT(last)) last=""
    rest=""

    ! Find the first separator

    firstseparatorPos=INDEX(useLine,useseparator)

    IF (firstseparatorPos == 0) THEN
       first=useLine
    ELSE
       first=useLine(1:firstseparatorPos-1)
       IF (useThreeWay) THEN
          ! In three way mode, find the last separator
          lastseparatorPos=INDEX(TRIM(useLine),useseparator,back=.TRUE.)
          IF (PRESENT(last) .AND. &
               & lastseparatorPos /= trimmedLen) THEN
             last=TRIM(useLine(lastseparatorPos+1:))
          END IF
          IF (firstseparatorPos+1 <= lastseparatorPos-1) THEN
             rest=TRIM(useLine(firstseparatorPos+1:lastseparatorPos-1))
          END IF
       ELSE
          IF (firstseparatorPos /= trimmedLen) THEN
             rest=TRIM(useLine(firstseparatorPos+1:))
          END IF
       END IF
    END IF

  end subroutine SplitWords
  
  ! ------------------------------------------------- squeeze --------
  ! Snip excess spaces between words
  ! E.g., turns ' a   man   from   Sai- Pan' into ' a man from Sai- Pan'
  ! optionally snips all spaces making it 'amanfromSai-Pan'
  
  ! options, if present, can contain the following characters
  !  character                 effect
  !     a                   snip all spaces (see CompressString)
  function squeeze( str, options ) result( squeezed )
    ! Args
    character(len=*), intent(in)           :: str
    character(len=*), optional, intent(in) :: options
    character(len=len(str))                :: squeezed
    ! Internal variables
    integer                                :: cpos ! current position in str
    integer                                :: cposq ! current position in squeezed
    logical                                :: newWord
    logical                                :: snipAll
    character(len=1)                       :: space
    ! Executable
    snipAll = .false.
    if ( present(options) ) snipAll = ( index(options, 'a') > 0 )
    space = ' '
    squeezed = str
    if ( len_trim(str) < 2 ) return
    squeezed = ' '
    if ( snipAll ) then
      if ( .true. ) then
        cposq = 0
        do cpos = 1, len_trim(str)
          ! This is easy -- snip every space no matter where
          if ( str(cpos:cpos) /= space ) then
            cposq = cposq + 1
            squeezed(cposq:cposq) = str(cpos:cpos)
          endif
        enddo
      else
        squeezed = CompressString( str )
      endif
    else
      squeezed(1:1) = str(1:1)
      cposq = 1
      newWord = ( str(1:1) == space )
      do cpos = 2, len_trim(str)
        if ( newWord ) then
          ! Already have at least one space, so must snip any others
          ! i.e., snip unless not a space
          if ( str(cpos:cpos) /= space ) then
            cposq = cposq + 1
            squeezed(cposq:cposq) = str(cpos:cpos)
            newWord = .false.
          endif
        else
          ! don't snip, even if a space
          cposq = cposq + 1
          squeezed(cposq:cposq) = str(cpos:cpos)
          ! Have we reached a space which divides words?
          newWord = ( str(cpos:cpos) == space )
        endif
      enddo
    endif
  end function squeeze
       
  ! -------------------------------------------------  StartCase  -----
  elemental function StartCase ( STR, SEPARATOR ) result (OUTSTR)
    ! Capitalize first letter of each (space-separated) word
    !--------Argument--------!
    character (len=*), intent(in)           :: STR
    character (len=1), optional, intent(in) :: SEPARATOR
    character (len=len(str))                :: OUTSTR
    ! Internal variables
    character(len=1) :: space
    integer :: i
    ! Executable
    outstr = lowercase(adjustl(str))
    if ( len_trim(str) < 1 ) return
    space = ' '
    if ( present(separator) ) space=separator
    outstr(1:1) = Capitalize(outstr(1:1))
    if ( index(trim(outstr), space) < 1 .or. len_trim(outstr) < 3 ) return
    do i = 3, len_trim(outstr)
       if( outstr(i:i) /= space .and. outstr(i-1:i-1) == space ) then
          outstr(i:i) = Capitalize(outstr(i:i))
       end if
    enddo
  end function StartCase

  ! -------------------------------------------------  streq_array1  -----
  function streq_array1 (STR1, STR2, OPTIONS) result (relation)
    ! Array version of streq
    ! May return multiple TRUEs (except see 's', 'l' options)
    ! Extra options
    ! 'P' is partial match (each STR1(i) is replaced by '*' // STR1(i) // '*')
    ! 'p' is partial match (STR2 is replaced by '*' // STR2 // '*')
    ! 's' returns TRUE only in element corresponding to shortest STR1
    ! 'l' returns TRUE only in element corresponding to longest STR1
    character (len=*), dimension(:), intent(in) :: STR1
    character (len=*), intent(in)               :: STR2
    character (len=*), intent(in), optional     :: OPTIONS
    logical, dimension(size(STR1))              :: RELATION
    ! Internal variables
    integer :: candidate
    integer :: candidateLength
    integer :: i
    integer, dimension(size(STR1))              :: lengths
    character(len=8) :: myOptions
    character(len=len(str1)+2) :: mystr1
    character(len=len(str2)+2) :: mystr2
    ! Executable
    myOptions = ''
    if ( present(options) ) myOptions = options
    mystr2 = str2
    if ( index(myOptions, 'p') > 0 ) mystr2 = '*' // trim_safe(str2) // '*'
    do i=1, size(str1)
      mystr1 = str1(i)
      if ( index(myOptions, 'P') > 0 ) mystr1 = '*' // trim_safe(str1(i)) // '*'
      relation(i) = streq( mystr1, mystr2, OPTIONS )
      ! print *, trim(mystr1)
      ! print *, trim(mystr2)
      ! print *, relation(i)
    enddo
    if ( .not. present(options) .or. count(relation) < 2 ) return
    lengths = len_trim(str1)
    if ( index(myOptions, 's') > 0 ) then
      candidate = findFirst(relation)
      candidateLength = lengths(candidate)
      do i=1, size(str1)
        if ( relation(i) .and. lengths(i) < candidateLength ) then
          candidate = i
          candidateLength = lengths(candidate)
        endif
      enddo
      relation = .false.
      relation(candidate) = .true.
    elseif ( index(myOptions, 'l') > 0 ) then
      candidate = findFirst(relation)
      candidateLength = lengths(candidate)
      do i=1, size(str1)
        if ( relation(i) .and. lengths(i) > candidateLength ) then
          candidate = i
          candidateLength = lengths(candidate)
        endif
      enddo
      relation = .false.
      relation(candidate) = .true.
    endif
  end function streq_array1

  ! -------------------------------------------------  streq_array2  -----
  function streq_array2 (STR1, STR2, OPTIONS) result (relation)
    ! Array version of streq
    ! (see streq_array1)
    ! Here str2 is array, not str1
    character (len=*), dimension(:), intent(in) :: STR2
    character (len=*), intent(in)               :: STR1
    character (len=*), intent(in), optional     :: OPTIONS
    logical, dimension(size(STR2))              :: RELATION
    relation = streq_array1(str2, str1, options)
  end function streq_array2

  ! -------------------------------------------------  streq_scalar  -----
  function streq_scalar ( str1, str2, options ) result ( relation )
    ! Are two strings "equal" where equality is modified by
    ! (w) Wildcard * (off by default) which allows 'a*' to equal 'abcd'
    ! (c) case insensitive (off by default) which allows 'ABCD' to equal 'abcd'
    ! (f) flush left (off by default) which allows 'abcd' to equal '  abcd'
    ! (h) head match (off by default) which allows 'abcd' to equal 'abc '
    ! (n) reverse sense ("Are two strings unequal?")
    !
    ! Defaults to standard (str1 == str2), but options broaden cases of TRUE
    ! To turn options on, supply optional arg options which is a character
    ! string containing: 
    ! 'w' => turns on (1); 'c' => (2); 'f' => (3); 'n' => (4)
    ! e.g., streq('Ab*', 'abcd', '-wc') is TRUE
    !
    ! Notes:
    ! The '-' character in options is ignored and therefore not necessary
    ! A more powerful version can be imagined that would permit full regexp
    ! Trailing spaces are always ignored; e.g. streq('abcd ', 'abcd') is TRUE
    ! Only one of str1, str2 may contain wildcards
    !--------Argument--------!
    ! str1 and str2 are optional so we can streq on optional args
    ! and always return false
    ! (But should we return false even when the sense is reversed?)
    character (len=*), intent(in), optional  :: str1
    character (len=*), intent(in), optional  :: str2
    character (len=*), intent(in), optional  :: options
    logical                                  :: relation

    ! Internal variables
    integer, parameter :: MAXNUMWILDCARDS = 10 ! How many '*' in the pattern
    character(len=*), parameter :: star = '*'  ! Should we allow others?
    logical :: flushleft
    integer :: i
    logical :: ignorecase
    integer, dimension(MAXNUMWILDCARDS) :: istars
    character(len=8) :: myOptions
    integer :: nstars
    logical :: reverseSense
    integer :: spos
    ! If len(str) is used for ptrn and substrs, Intel Fortran 10.0.023 crashes
    character(len=MaxStreqLen)    :: str
    character(len=MaxStreqLen)    :: ptrn  ! The one with '*'
    character(len=MaxSubstrLen), dimension(MAXNUMWILDCARDS+1) :: substrs
    logical :: head
    logical :: wildcard
    logical, parameter :: deebug = .false.
    !----------Executable part----------!
    ! Check for any absent atr1, str2
    relation = ( present(str1) .and. present(str2) )
    if ( .not. relation ) return
    ! Check for length violations
    relation = ( len(str1) <= MaxStreqLen .and. len(str2) <= MaxStreqLen )
    if ( .not. relation ) return
    !
    relation = .FALSE.
    myOptions = ' '
    if ( present(options) ) myOptions = lowercase(options)
    wildcard = (index(myoptions, 'w') > 0)
    head = (index(myoptions, 'h') > 0)
    ignorecase = (index(myoptions, 'c') > 0)
    flushleft  = (index(myoptions, 'f') > 0)
    reverseSense  = (index(myoptions, 'n') > 0)
    ! Now the wildcard(s) should be in ptrn
    if ( index(str1, star) > 0 ) then
      str = str2
      ptrn = str1
    elseif ( index(str2, star) > 0 ) then
      str = str1
      ptrn = str2
    else
      ! Whoops--don't need wild card after all
      wildcard = .false.
    endif
    ! Special cases: emptry strings or a bare vanilla match
    if ( len_trim(str1 // str2) < 1 ) then
      relation = .true.
      goto 90 ! return
    elseif ( len_trim(str1) < 1 ) then
      relation = ( str2 == star .and. wildcard ) 
      goto 90 ! return
    elseif ( len_trim(str2) < 1 ) then
      relation = ( str1 == star .and. wildcard ) 
      goto 90 ! return
    elseif ( str2 == str1 ) then
      relation = .true.
      goto 90 ! return
    endif

    if ( head ) then
      ! Check only that the heads of each string match, i.e.
      ! up to the rightmost non-blank character of the shorter string
      if ( ignorecase ) then
        str  = lowercase(str1)
        ptrn = lowercase(str2)
      else
        str  = str1
        ptrn = str2
      endif
      if ( flushleft ) then
        str  = adjustl(str )
        ptrn = adjustl(ptrn)
      endif
      i = min( len_trim(str), len_trim(ptrn) )
      relation = ( str(:i) == ptrn(:i) )
      goto 90
    elseif ( .not. wildcard ) then
      if ( ignorecase ) then
        if ( flushleft ) then
          relation = (adjustl(lowercase(str1)) == adjustl(lowercase(str2)))
        else
          relation = (lowercase(str1) == lowercase(str2))
        endif
      else
        if ( flushleft ) then
          relation = (adjustl(str1) == adjustl(str2))
        ! else plain vanilla case already handled as special case above
        endif    
      endif    
      goto 90 ! return
    endif    

    ! How to handle the wildcard? Use it to split ptrn into sub-patterns
    if ( ignorecase ) then
      str = lowercase(str)
      ptrn = lowercase(ptrn)
    endif
    if ( flushleft ) then
      str = adjustl(str)
      ptrn = adjustl(ptrn)
    endif
    if ( deebug ) print *, 'str: ', trim(str), '  ptrn: ', trim(ptrn)
    if ( ptrn == star ) then
      relation = .true.
      goto 90 ! return
    elseif ( isRepeat(ptrn, star) ) then
      relation = .true.
      goto 90 ! return
    endif

    ! 1st -- how many stars?
    nstars =     ncopies(ptrn, star)
    if ( deebug ) print *, 'num of * ', nstars
    ! 2nd -- extract substrings from inbetween the wildcards
    substrs = star
    istars(1:nstars) = indexes(ptrn, substrs(1:nstars), mode='left')
    if ( deebug ) print *, 'where? ', istars(1:nstars)
    substrs = ' '
    spos = 1
    do i=1, nstars
      if ( spos > len(ptrn) ) exit
      substrs(i) = firstsubstr(ptrn(spos:), star)
      spos = max(spos, istars(i)) + 1
    enddo
    substrs(nstars+1) = Reverse_trim(firstsubstr(Reverse_trim(ptrn), star))
    if ( deebug ) then
      do i=1, nstars+1
        print *, trim_safe(substrs(i))
      enddo
    endif
    ! Deal specifically with empty elements of substrs
    if ( deebug ) print *, 'Deal specifically with empty elements of substrs'
    relation = .true.
    if ( deebug ) print *, 'Is substr(1) non-blank? ', substrs(1) /= ' '
    if ( substrs(1) /= ' ' ) then
      if ( deebug ) then
        print *, 'About to check index'
        print *, 'str ', str
        print *, 'trim(substrs(1)) ', trim(substrs(1))
        print *, 'len(str) ', len(str)
        print *, 'len(trim(substrs(1))) ', len(trim(substrs(1)))
        print *, 'index: ', index( str, trim(substrs(1)) )
      endif
      if ( index(str, trim(substrs(1))) /= 1 ) then
        relation = .false.
        goto 90 ! return
      endif
    endif
    if ( deebug ) print *, 'passed 1st sub-test'
    ! firstSSindex = 2
    if ( substrs(nstars+1) /= ' ' ) then
      if ( index(Reverse_trim(str), Reverse_trim(substrs(nstars+1))) /= 1 ) then
        relation = .false.
        ! if ( deebug ) print *, 'failed 2nd sub-test: ', Reverse_trim(str), Reverse_trim(substrs(nstars+1))
        goto 90 ! return
      endif
    endif
    ! lastSSindex = nstars
    if ( deebug ) print *, 'passed 2nd sub-test'
    if ( nstars < 2 ) goto 90 ! return
    ! Now find the indexes of these sub-patterns according to mode='wrap'
    istars(1:nstars-1) = indexes(str, substrs(2:nstars), mode='wrap')
    ! What we want to do is to check that no istars < 1
    relation = all ( istars(1:nstars-1) > 0 )
    ! Do the options instruct us to reverse the sense?
90  if ( reverseSense ) relation = .not. relation
  end function streq_scalar

  ! --------------------------------------------------  strings2Ints  -----
  subroutine strings2Ints (strs, ints)
    ! takes an array of strings and returns integer array
    ! using "ichar"
    ! Useful due to bug in toolbox swrfld
    !
    ! See also ints2Strings
    !--------Argument--------!
    !    dimensions are (len(strs(1)), size(strs(:)))
    character (len=*), intent(in), dimension(:) ::   strs
    integer, intent(out), dimension(:,:) ::          ints

    !----------Local vars----------!
    integer :: i, substr, strLen, arrSize
    !----------Executable part----------!

   ! Check that all is well (if not returns blanks)
   strLen = MIN(len(strs(1)), size(ints, dim=1))
   arrSize = MIN(size(strs), size(ints, dim=2))
   ints = LENORSIZETOOSMALL
   if(strLen <= 0 .or. arrSize <= 0) return
   ints=iachar(' ')
   do i=1, arrSize
      do substr=1, strLen
         ints(substr, i) = iachar(strs(i)(substr:substr))
      enddo
   enddo

  end subroutine strings2Ints

   ! --------------------------------------------------  Swap  -----
  function Swap ( str, c1, c2 ) result ( outstr )
    ! Takes a string and returns one with c1 c2 swapped for each other
    ! E.g., to Swap every 'p' with a 'q' and every 'q' with a 'p'
    ! would transform 'perquisite' to 'qerpuisite'
    character(len=*), intent(in)  :: str
    character(len=1), intent(in)  :: c1
    character(len=1), intent(in)  :: c2
    character(len=len(str))       :: outstr
    ! Internal variables
    integer :: i, n
    ! Executable
    outstr = str
    if ( len(str) < 1 ) return
    do i=1, len(str)
      if ( str(i:i) == c1 ) then
        outstr(i:i) = c2
      elseif ( str(i:i) == c2 ) then
        outstr(i:i) = c1
      endif
    enddo
  end function Swap

  ! --------------------------------------------------  TrueList  -----
  subroutine TrueList ( Array, Str )
    ! Return Str with integers describing where Array has true values.
    ! Sequences of more than two consecutive true values are represented
    ! by n1:n2.
    logical, intent(in) :: Array(:)
    character(len=*), intent(out) :: Str
    integer :: L, N1, N2
    character :: Before
    before = ''
    l = 1
    n1 = 0
    str = ''
    do while ( n1 < size(array) )
      n1 = n1 + 1
      if ( .not. array(n1) ) cycle
      do n2 = n1, size(array)-1
        if ( .not. array(n2+1) ) exit
      end do
      ! n1 .. n2 are true
      if ( n1 == n2 ) then
        write ( str(l:), '(a,i0,:,":",i0)' ) trim(before), n1
      else
        write ( str(l:), '(a,i0,:,":",i0)' ) trim(before), n1, n2
      end if
      before = ','
      l = len_trim(str) + 1
      n1 = n2 + 1
    end do
  end subroutine TrueList
    
  ! -------------------------------------------------  unAsciify  -----
  function unAsciify ( str, how ) result ( outstr )
  ! takes input string and replaces any coded forms non-printing characters
  ! with corresponding binary characters outside ascii range
  ! leaving other chars alone
  ! This reverses the effect of the Asciify procedure which recoded
  ! non-ascii characters as '<something>'
  !
  ! How the decoding is done is according to the optional arg
  !    how         coding
  !    ---         -------
  !  'decimal'    <nnn> where nnn is the decimal value (e.g. 0)
  !  'octal'      <nnn> where nnn is the octal value (e.g. 000)
  !  'mnemonic'   <ID> where ID is the mnemonic code (e.g. NUL)
  ! Note that we may output a shorter string than the input

  ! method:
  ! (a) step through str, each stride positioned between
  ! j1, where leftmost lquote is, and j2, where leftmost rquote is
  ! (b) decode the current stride
  ! (c) accumulate evrything leftward plus decoded portion
  ! (d) cut off both stride and everything leftward. Call remainder "remainder"
  ! Contrast this approach with what is is done in MLSStringLists module
  ! which uses string slicing and index arithmetic
  ! Should we go back and simplify the latter?

  ! (see also ReplaceNonAscii, Asciify)
    !--------Argument--------!
    character (len=*), intent(in)           :: STR
    character (len=len(str))                :: OUTSTR
    character (len=*), optional, intent(in) :: HOW
    ! Internal variables
    character(len=1) :: bchar  ! A non-ascii character
    character(len=5) :: codedStr
    integer :: J1
    integer :: J2
    character(len=8) :: myHow
    character(len=len(str)) :: remaining
    character(len=1), parameter :: LQUOTE = '<'
    character(len=1), parameter :: RQUOTE = '>'
    ! Executable
    outstr=str
    myHow = 'mnemonic'
    if ( present(how) ) myHow = how
    ! print *, 'count_quotes ', count_quotes(str, LQUOTE, RQUOTE )
    if ( count_quotes(str, LQUOTE, RQUOTE ) < 1 ) return
    outstr = ' '
    remaining = str
    do
       j1 = index( remaining, lquote)
       if ( j1 < 1 ) exit
       j2 = index( remaining, rquote)
       if ( j2 < 1 ) exit
       codedStr = remaining(j1:j2)
       ! print *, 'j1, j2 ', j1, j2
       ! print *, 'codedStr ', codedStr
       bChar = decoder( codedStr, myHow )
       if ( j1 == 1 ) then
         outstr = trim(outstr) // bChar
       else
         outstr = trim(outstr) // remaining(:j1-1) // bChar
       endif
       if ( j2 < len_trim(remaining) ) then
         remaining = remaining(j2+1:)
       else
         remaining = ' '
         exit
       endif
    enddo
    if ( len_trim(remaining) > 1 ) &
      & outstr = trim(outstr) // remaining
    ! print *, 'unAsciify returning char-valued ', iachar(outstr(1:1))
  end function unAsciify

  ! --------------------------------------------------  unWrapLines  -----
  ! undo the splitting of commands across multiple lines by escaping line feeds
  ! i.e, a special escape character at line's end to denote a continuation
  ! to the following line
  ! optionally remove comment lines, i.e. lines beginning with comment character
  subroutine unWrapLines ( inLines, outLines, nOut, escape, comment )
    !
    character (len=*), dimension(:), intent(in)            ::   inLines
    character (len=*), dimension(:), intent(out)           ::   outLines
    integer, optional, intent(out)                         ::   nOut
    character (len=*), optional, intent(in)                ::   escape
    character (len=*), optional, intent(in)                ::   comment

    !----------Local vars----------!
    integer                      :: i, j, k, line
    character(len=len(outLines)) :: inLine
    character(len=1)             :: myComment
    character(len=1)             :: myEscape
    character(len=len(outLines)) :: outLine
    !----------Executable part----------!
    myEscape = '\'
    if ( present(escape) ) myEscape = escape
    myComment = achar(0)
    if ( present(comment) ) myComment = comment
    outlines = ' '
    line = 0
    k = 0
    do i=1, size(inLines)
      if ( line > size(outLines) - 1 ) exit
      inLine = adjustl(inLines(i))
      j = len_trim(inLine)
      if ( j < 1 ) then
        if ( k < 1 ) cycle
        ! We are done with the line
        line = line + 1
        outLines(line) = outLine
        k = 0
      else
        if ( inLine(1:1) == myComment ) cycle
        if ( inLine(j:j) == myEscape ) then
          if ( j < 2 ) then
            cycle
          elseif ( k < 1 ) then
            outline = inLine(:j-1)
            k = j-1
          else
            outLine = outLine(:k) // inLine(:j-1)
            k = k + j - 1
          endif
        elseif ( k < 1 ) then
          line = line + 1
          outLines(line) = inLine
        else
          line = line + 1
          outLines(line) = outLine(:k) // inLine
          k = 0
        endif
      endif
    enddo
    if ( present(nOut) ) nOut = line
  end subroutine unWrapLines

  ! --------------------------------------------------  writeAnIntToChars  -----
  ! takes an integer and returns a string
  ! using Fortran "write"
  ! Unless integer is one of specialInts, in which case
  ! we return corresponding one of specialChars
  ! (So that we can treat -1 as "unlimited' or -999 as 'FillValue')
  ! We'll just assume both special arrays are of same size
  ! and, in case of array versions of 
  subroutine writeAnIntToChars (int, str, fmt, specialInts, specialChars)
    !
    integer, intent(in)                                    ::   int
    character (len=*), intent(out)                         ::   str
    character (len=*), optional, intent(in)                ::   fmt
    integer, intent(in), dimension(:), optional            ::   specialInts
    character (len=*), intent(in), dimension(:), optional  ::   specialChars

    !----------Local vars----------!
    integer :: i
    character(len=16) :: MyStr
    !----------Executable part----------!

   ! Check that we don't have one of special cases
   if ( present(specialInts) ) then
     do i=1, size(specialInts)
       if ( int == specialInts(i) ) then
         str = specialChars(i)
         return
       endif
     enddo
   endif
   if ( present(fmt) ) then
     write(str, fmt=fmt) int
   else ! Don't use *; RTL can legally insert any number of leading blanks
     write ( myStr,'(i16)' ) int
     str = adjustl(myStr)
   endif

  end subroutine writeAnIntToChars

  subroutine writeIntsToChars_1d (ints, strs, fmt, specialInts, specialChars)
    ! takes an array of integers and returns string array
    integer, intent(in), dimension(:)            ::   ints
    character (len=*), intent(out), dimension(:) ::   strs
    character (len=*), intent(in), optional      ::   fmt
    integer, intent(in), dimension(:), optional  ::   specialInts
    character (len=*), intent(in), dimension(:), optional  ::   specialChars

    !----------Local vars----------!
    integer :: i, arrSize
    !----------Executable part----------!

   ! Check that all is well (if not returns blanks)
   arrSize = MIN(size(strs), size(ints))
   if ( arrSize <= 0 ) then
     strs = ' '
     return
   endif
   do i=1, arrSize
      call writeAnIntToChars(ints(i), strs(i), fmt, specialInts, specialChars)
   enddo

  end subroutine writeIntsToChars_1d

  subroutine writeIntsToChars_2d (ints, strs, fmt, specialInts, specialChars)
    integer, intent(in), dimension(:,:)            ::   ints
    character (len=*), intent(out), dimension(:,:) ::   strs
    character (len=*), intent(in), optional      ::   fmt
    integer, intent(in), dimension(:), optional  ::   specialInts
    character (len=*), intent(in), dimension(:), optional  ::   specialChars

    !----------Local vars----------!
    integer :: i, j, shp(2)
    !----------Executable part----------!

   ! Check that all is well (if not returns blanks)
   shp = shape(ints)
   if ( any(shp <= 0) ) then
     strs = ' '
     return
   endif
   do j=1, shp(2)
     do i=1, shp(1)
       call writeAnIntToChars(ints(i,j), strs(i,j), &
         & fmt, specialInts, specialChars)
     enddo
   enddo

  end subroutine writeIntsToChars_2d

  ! ----------------  writeIntAsBaseN  -----
  ! write an integer reexpressed in base n as a string
  
  ! Use:
  ! Given e.g. the number 1989 in base 5 return str='30424'
  ! i.e., 4 + 5*(2 + 5*(4 + 5*(0 + 5*3)))
  subroutine writeIntAsBaseN ( K, N, STR, OPTIONS )
    ! takes an integer and returns a string
    ! using poorly-tested but hopefully non-critical code

    ! Method:
    ! First determine how many terms in expansion, or equivalently,
    ! highest power of N; thus want N^m < num
    ! m < (log k) / (log N)
    ! For its coefficient c[m], must have
    ! c[m] < k / N^m
    ! FFor succeeding coefficients
    ! c[m-1] < k / N^(m-1) - N c[m]
    ! c[m-2] < k / N^(m-2) - N^2 c[m] - N c[m-1]
    ! ...    ...    ...    ...    ...
    ! c[m-j] < k / N^(m-j) - N^j c[m] - N^(j-1) c[m-1] - .. - N c[m-j+1]
    ! until for j up to m
    
    ! According to the options string, the resulting integer coefficients
    ! will be returned as
    !  options contain            coefficient string
    !    ---                      ------------------
    !   (default)                 decimal integers, separated by spaces
    !                              e.g., ''13 4 29 6''
    !      a                      achar(c[m]) in the same order
    !                              e.g., CR // EOT // GS // ACR   
    !      A                      like a but converted to ascii
    !                              e.g., '<CR>' // '<EOT>' // '<GS>' // <ACR>   
    !      x                      "Extended" hexadecimal
    ! 0123456789012345678901234567890123456789012345678901234567890123456789
    ! 0123456789abcdefghijklmnopqrstuvwxyz;'[]ABCDEFGHIJKLMNOPQRSTUVWXYZ:"{}
    !                              (good only up to base 70)
    !
    ! The default representation can handle arbitrarily large moduli
    ! a or A is limited to the unique range of achar
    ! x is good only up to a modulus of 70.
    
    ! Note that the returned string is in normal order. The coefficient of the
    ! highest power comes first, then the next highest power, and
    ! so on. If you want the coeffieicents in reversed order, call
    ! this module's Reverse function afterward.
    
    ! If you want to remove the embedded spaces from one of the non-default
    ! representations, call CompressString with the result
    
    ! If you want to convert a floating number, say '4.523' to another base,
    ! (i) multiply it by the base as many times as you will want after
    !     that base's "decimal" point. So for base 13 to 3 places, form
    !    13*13*13*4.523
    ! (ii) takes the integer part of the result
    ! (iii) call this subroutine with that integer
    ! (iv) Insert the "decimal" point 3places before the result's last char
    !
    !--------Argument--------!
    integer, intent(in)                     ::   k ! integer to be reexpressed
    integer, intent(in)                     ::   N ! the new base
    character (len=*), intent(out)          ::   str
    character(len=*), optional, intent(in)  ::   options
    ! Internal variables
    integer, dimension(0:128)               :: C ! One for each digit of K
    integer                                 :: j
    integer                                 :: m
    character(len=8)                        :: myOptions
    double precision                        :: S, SHigher
    character(len=8)                        :: substr
    character(len=*), parameter             :: xtended = &
      & '0123456789abcdefghijklmnopqrstuvwxyz;''[]ABCDEFGHIJKLMNOPQRSTUVWXYZ:"{}'
    ! Executable
    str = ' '
    if ( k < 0 .or. N < 2 ) return
    myOptions = ' '
    if ( present(options) ) myOptions = options
    ! What is the highest power needed of N?
    m = 0
    if ( k > 1 ) m = ( log (k*1.d0) / log (N*1.d0) ) + 1.d-3
    if ( k < N ) then
      C(0) = k
    else
      ! Recursively define
      ! S[m]     = k / N^m
      ! S[m-1] = N ( S[m] - c[m] )
      ! S[m-j] = N ( S[m-j+1] - c[m-j+1] )
      ! but we'll restate this for each j as
      ! S = N ( SHigher - c[m-j=1] )
      SHigher = k*1.d0 / N**m
      j = 0
      do
        if ( (m - j) < 0 ) exit
        c(m-j) = SHigher + 1.d-3
        S = N*( SHigher - c(m-j) )
        SHigher = S
        j = j + 1
      end do
    end if
    ! print *, 'm ', m
    ! call dump( c, 'coeffs' )
    ! Now we turn the integers into a character string
    ! in an appropriate way
    if ( index(myOptions, 'a') > 0 .or. index(myOptions, 'A') > 0 ) then
      do j = m, 0, -1
        if ( c(j) < 177 ) str = trim(str) // ' ' // achar(c(j))
        ! print *, 'str ', Asciify(str)
      end do
      str = adjustl(str)
      if ( index(myOptions, 'A') > 0 ) str = Asciify(str, 'mnemonic')
    else if ( index(myOptions, 'x') > 0 ) then
      do j = m, 0, -1
        if ( c(j) < 71 ) str = trim(str) // ' ' // xtended(c(j)+1:c(j)+1)
        ! print *, 'str ', str
      end do
      str = adjustl(str)
    else
      ! default
      do j = m, 0, -1
        call writeIntsToChars ( c(j), substr )
        str = trim(str) // ' ' // adjustl(substr)
        ! print *, 'substr ', substr
        ! print *, 'str ', str
      end do
      str = adjustl(str)
    end if
  end subroutine writeIntAsBaseN

  subroutine writeRomanNumerals ( num, str, options )
    ! takes an integer and returns a string
    ! using poorly-tested but hopefully non-critical code

    ! Method:
    ! Peel off values from num, working from highest to lowest,
    ! each time appending the corresponding romans to the end of str
    
    ! The optional string options may control the following
    ! if options contains  meaning
    ! 4     use 'iiii' for 4 instead of 'iv'; seen in some clock faces
    ! n     non-standard

    ! If non_standard is chosen, check for exceptional abbreviations
    ! like 'im' for 999, or 'cic' for 199
    !
    ! Note: The '4' option mnioned above doesn't seem tto be operative.
    ! Did you change your mind?
    !--------Argument--------!
    integer, intent(in)                     ::   num
    character (len=*), intent(out)          ::   str
    character(len=*), optional, intent(in)  ::   options
    ! Internal variables
    character(len=2), dimension(13), parameter :: romans = &
      & (/  'm ','cm','d ','cd', 'c ','xc','l ','xl','x ','ix','v ','iv','i ' /)
    integer, dimension(13), parameter :: values = &
      & (/ 1000, 900,  500, 400,  100, 90, 50,  40,  10,   9,   5,   4,   1 /)
    integer :: remainder
    integer :: r_index ! What romans index we're searching for
    logical :: non_standard
    ! Executable
    str = ' '
    if ( len(str) < 1 .or. num < 1 ) return
    non_standard = .false.
    if ( present(options) ) non_standard = index(lowercase(options), 'n') > 0
    remainder = num
    ! Outer loop: romans index
    do r_index=1, 13
      ! Will adding an 'i' or 'x' boost the remainder above values(r_index)?
      if ( non_standard .and. remainder < values(r_index) ) then
        select case (r_index)
        case (1,3,5,7) ! m, d, c, l
          if ( remainder + values(13) >= values(r_index) ) then
            str = trim(str) // romans(13)
            remainder = remainder + values(13)
          elseif( remainder + values(9) >= values(r_index) ) then
            str = trim(str) // romans(9)
            remainder = remainder + values(9)
          endif
        end select
      endif
      do while ( remainder >= values(r_index) )
        str = trim(str) // romans(r_index)
        remainder = remainder - values(r_index)
      enddo
    enddo
    ! print *, 'Remainder: ', remainder
  end subroutine writeRomanNumerals

  ! Private procedures and functions
!============================ Private ==============================
  subroutine prepOptions( options )
    ! Process options into separate optional args
    ! You should call this at the start of every procedure
    ! that uses options to set countEmpty, etc.
    ! Args:
    character(len=*), intent(in), optional  :: options
    ! Internal variables
    character(len=16) :: myOptions
    ! Executable
    caseSensitive       = .true.
    ignoreLeadingSpaces = .false.
    myOptions = STRINGOPTIONS
    if ( present(options) ) myOptions = options
    if ( len_trim(myOptions) > 0 ) then
      caseSensitive       = ( index(myOptions, 'c') < 1 )
      ignoreLeadingSpaces = ( index(myOptions, 'f') > 0 )
    endif
  end subroutine prepOptions

  ! ---------------------------------------------------  isComment  -----
  elemental function isComment( arg, Comment ) result( itIs )
    ! Returns TRUE if first non-blank char is comment
    ! Args
    character(len=*), intent(in)    :: arg
    character, optional, intent(in) :: Comment
    logical                         :: itIs
    ! Internal variables
    character :: first
    character :: myComment
    ! Executable
    myComment = '#'
    if ( present(Comment) ) myComment = Comment
    first = adjustl(arg)
    itIs = ( first == myComment )
  end function isComment

  ! ---------------------------------------------------  isDigit  -----
  elemental function isDigit(arg) result(itIs)
    ! Returns TRUE if arg is one of {'1', '2', ..}
    ! Args
    character(len=1), intent(in) :: arg
    logical                      :: itIs
    ! Internal variables
    character(len=*), parameter :: list='1234567890'
    ! Executable
    itIs = ( index(list, arg) > 0 )
  end function isDigit

  ! ---------------------------------------------------  isDigits  -----
  elemental function isDigits(arg) result(itIs)
    ! Returns TRUE if arg is made up of {'1', '2', ..} and trailing space(s)
    ! Args
    character(len=*), intent(in) :: arg
    logical                      :: itIs
    ! Internal variables
    integer :: i
    ! Executable
    itIs = .false.
    if ( len_trim(arg) < 1 ) return
    do i=1, len_trim(arg)
      if ( .not. isDigit(arg(i:i)) ) return
    enddo
    itIs = .true.
  end function isDigits

  ! ---------------------------------------------------  lastChar  -----
  character function lastChar(str)
    character(len=*), intent(in) :: str
     ! Returns the last non-blank character of str (unless str itself is blank)
     integer :: strlen
     lastchar = ' '
     strlen = len_trim(str)
     if ( strlen < 1 ) return
     lastchar = str(strlen:strlen)
  end function lastChar

  ! ---------------------------------------------------  decoder  -----
  function decoder( said, how ) result ( meant )
    ! decode what you said, a coded ascii string like this
    ! '<NUL>'
    ! into what you actually meant, i.e. a null char
    character(len=*), intent(in)           :: said
    character(len=*), intent(in)           :: how
    character(len=1)                       :: meant
    ! Executable
    ! print *, 'said ', said
    ! print *, 'how ', how
    if ( How == 'decimal' ) then
      meant = decimalCode( said, invert=.true. )
    elseif ( How == 'octal' ) then
      meant = octalCode( said, invert=.true. )
    elseif ( How == 'mnemonic' ) then
      meant = mnemonicCode( said, invert=.true. )
    else
      ! Uh-oh, that is not a recognized how
      ! print *, 'Uh-oh, that is not a recognized how'
      meant = achar(0) ! return a NUL char; should we crash, instead?
    endif
  end function decoder

  ! ---------------------------------------------------  firstsubstr  -----
  elemental function firstsubstr(str, star) result(substr)
    character(len=*), intent(in) :: str
    character(len=1), intent(in) :: star
    character(len=len(str)) :: substr
    ! Returns the substr between the start of str and the 1st occurrence of star
     integer :: strlen
     integer :: ipos
     substr = ' '
     strlen = len_trim(str)
     if ( strlen < 1 ) return
     ipos = index(str, star)
     if ( ipos < 1 ) then
       substr = str
     elseif ( ipos == 1 ) then
       substr = ' '
     else
       substr = str(:ipos-1)
     endif
  end function firstsubstr

  subroutine readAnIntFromChars (str, num, forbiddens, ignore)
    !--------Argument--------!
    character (len=*), intent(in)               ::   str
    integer, intent(out)                        ::   num
    character (len=*), intent(in), optional     ::   forbiddens
    character (len=*), optional, intent(in)     ::   ignore
    call ReadIntsFromChars (str, num, forbiddens, ignore)
  end subroutine readAnIntFromChars

  subroutine readIntArrayFromChars (strs, ints, forbiddens, ignore)
    !--------Argument--------!
    !    dimensions are (len(strs(1)), size(strs(:)))
    character (len=*), intent(in), dimension(:) ::   strs
    integer, intent(out), dimension(:)          ::   ints
    character (len=*), intent(in), optional     ::   forbiddens
    character (len=*), optional, intent(in)     ::   ignore

    !----------Local vars----------!
    integer :: i, arrSize
    !----------Executable part----------!
    call ReadIntsFromChars (strs, ints, forbiddens, ignore)
  end subroutine readIntArrayFromChars

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSStrings.f90,v 2.111 2019/10/30 20:04:31 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MLSStrings
!=============================================================================

! $Log: MLSStrings.f90,v $
! Revision 2.111  2019/10/30 20:04:31  pwagner
! Added Justify function
!
! Revision 2.110  2019/10/16 20:50:13  pwagner
! Added Enclosure
!
! Revision 2.109  2019/07/17 20:13:42  pwagner
! Replace may now take the arg reverse to replace non-matching oldChar; added Swap
!
! Revision 2.108  2019/04/09 20:35:17  pwagner
! Moved some procedures from MLSStrings to new MLSStrings_0
!
! Revision 2.107  2019/03/21 23:44:38  pwagner
! Fixed error in nCharsinFormat; cosmetic improvements
!
! Revision 2.106  2019/01/24 18:31:12  pwagner
! Reorganized modules that print to simplify toolkit-free builds
!
! Revision 2.105  2018/03/27 22:06:52  pwagner
! No longer uses optional_m; now one less module needed to build toolkitlessly
!
! Revision 2.104  2017/12/08 00:28:44  pwagner
! Add optional 'options' arg to CatStrings; by default will not cat empty string
!
! Revision 2.103  2017/01/25 21:10:17  pwagner
! str1 and str2 args to streq now optional
!
! Revision 2.102  2016/12/08 00:15:41  pwagner
! readNumsFromChars can now ignore non-numerical stuff
!
! Revision 2.101  2014/09/11 18:23:57  pwagner
! Added isDigits
!
! Revision 2.100  2014/09/05 00:12:11  vsnyder
! Convert pointer temp to explicit shape.
!
! Revision 2.99  2014/07/25 21:42:37  pwagner
! Fixed bugs in readIntFromBaseN; now generic as readNumFromBaseN; added remap
!
! Revision 2.98  2014/02/21 01:24:54  pwagner
! Added CharToInt; made SplitWords elemental
!
! Revision 2.97  2014/02/12 23:59:34  pwagner
! isAlphabet now public
!
! Revision 2.96  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.95  2013/08/09 00:43:06  pwagner
! Added count_quotes and unAsciify
!
! Revision 2.94  2013/07/30 23:26:44  pwagner
! New procedures to read/write base N integers
!
! Revision 2.93  2013/07/24 19:02:43  pwagner
! Added isComment function; streq adds new option 'h' to match string heads
!
! Revision 2.92  2013/06/28 23:56:47  pwagner
! Fixed an old bug in SplitDetails
!
! Revision 2.91  2013/06/17 21:35:26  pwagner
! You may specify better where stretch adds space
!
! Revision 2.90  2013/06/14 03:02:37  vsnyder
! Simplify ReplaceNonAscii
!
! Revision 2.89  2013/06/13 00:39:21  pwagner
! Removed two unused params
!
! Revision 2.88  2012/12/04 00:11:55  pwagner
! Improved comments
!
! Revision 2.87  2012/09/05 21:43:55  pwagner
! streq options now case sensitive; 'P'artial match means str1(i) is the part
!
! Revision 2.86  2012/08/07 18:02:37  pwagner
! ReplaceNonAscii now takes optional arg exceptions which dont get replaced
!
! Revision 2.85  2012/07/10 15:15:33  pwagner
! Added SplitDetails
!
! Revision 2.84  2012/05/01 22:10:26  vsnyder
! Add TrueList subroutine
!
! Revision 2.83  2011/06/23 17:25:50  pwagner
! Added ability to read, write Roman numerals
!
! Revision 2.82  2011/06/16 00:14:51  pwagner
! Added new procedures to unwrap commands and Start Case strings
!
! Revision 2.81  2011/02/18 17:58:10  pwagner
! Replace, Delete no take an optional arg; added shiftLRC
!
! Revision 2.80  2011/02/05 01:34:23  pwagner
! Added Delete function
!
! Revision 2.79  2010/09/24 23:45:45  pwagner
! Removed dependence on MLSCommon by substituting double for r8
!
! Revision 2.78  2010/06/23 20:42:21  honghanh
! Change readAnIntFromChars to only read the first number in the string
! if there are many numbers separated by ignored characters.
! Update comment of the method.
!
! Revision 2.77  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.76  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.75  2009/06/16 17:08:42  pwagner
! Added ReadNumsFromChars, squeeze, stretch functions
!
! Revision 2.74  2008/06/04 21:44:43  pwagner
! Added lenTrimToAscii and ReplaceNonAscii
!
! Revision 2.73  2008/05/09 00:22:37  pwagner
! Nappearances has new optional arg to not trim substrings
!
! Revision 2.72  2008/02/07 18:46:55  pwagner
! isAllAscii, isAscii now public; Asciify generic
!
! Revision 2.71  2007/09/13 21:06:25  pwagner
! Added 2-d array interface for writeIntsToChars
!
! Revision 2.70  2007/08/29 19:52:18  pwagner
! Added Asciify function
!
! Revision 2.69  2007/07/31 22:46:08  pwagner
! undefined status now defined in readAnIntFromChars ;'n' option added to streq
!
! Revision 2.68  2007/07/25 21:58:16  vsnyder
! Replace tabs by spaces because tabs are not standard
!
! Revision 2.67  2007/07/18 00:06:46  pwagner
! Added Rot13 function
!
! Revision 2.66  2007/05/22 20:57:18  vsnyder
! Don't use the length of one automatic variable to specify the length of
! another one: Intel ifort 10.0.023 crashes at run time on this.
! Don't use list-directed output to internal files.
!
! Revision 2.65  2007/04/26 20:32:15  pwagner
! Coded around bug in Intel compiler causing streq to bomb
!
! Revision 2.64  2007/01/03 20:40:25  pwagner
! Added NAppearances
!
! Revision 2.63  2006/10/05 23:34:13  pwagner
! Fixed bug in streq making identity comparisons
!
! Revision 2.62  2006/05/09 00:14:23  pwagner
! Added Replace; useful to replace null chars with blanks
!
! Revision 2.61  2006/02/24 01:14:02  pwagner
! Added SplitNest (is this the best name)
!
! Revision 2.60  2006/02/16 00:58:12  pwagner
! ignore arg to ReadIntsFromChars may include * plus others
!
! Revision 2.59  2005/09/22 23:33:58  pwagner
! date conversion procedures and functions all moved into dates module
!
! Revision 2.58  2005/07/21 23:37:22  pwagner
! Added explanation of to-be-standard character flag options
!
! Revision 2.57  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.56  2005/06/14 18:31:41  pwagner
! readIntsFromChars can now ignore certain chars
!
! Revision 2.55  2005/05/31 17:46:01  pwagner
! Added array  interfaces for streq
!
! Revision 2.54  2005/04/12 17:34:53  pwagner
! isRepeat, streq, ncopies, reverse_trim, scalar versions of read/write intchar
!
! Revision 2.53  2005/03/15 23:45:05  pwagner
! Added trim_safe to stop trimming at length 1
!
! Revision 2.52  2005/01/20 01:29:42  vsnyder
! Add CatStrings
!
! Revision 2.51  2004/10/13 20:25:45  pwagner
! In reFormatDate allow day of year w/o letter d; e.g. 2004-274
!
! Revision 2.50  2004/10/13 16:23:03  pwagner
! Moved declaration of hhmmss_value result to after use statement
!
! Revision 2.49  2004/10/13 00:52:20  vsnyder
! Move HHMMSS_value here from MLSStringLists and simplify it.
! Remove AnyForbiddenChars and AllAllowedChars because intrinsic Scan and
! Verify can do them, and they weren't used anyway.
!
! Revision 2.48  2004/10/05 23:08:04  pwagner
! Added AnyForbiddenChars and AllApprovedChars; improved reFormatDate
!
! Revision 2.47  2004/09/23 22:56:38  pwagner
! Added reformats of date, time
!
! Revision 2.46  2004/09/16 00:15:52  pwagner
! Added writeIntsToChars
!
! Revision 2.45  2004/08/04 23:19:01  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.44  2004/06/29 00:06:13  pwagner
! Tried to straighten out delimiter-separator terms in comments
!
! Revision 2.43  2004/06/16 22:15:28  pwagner
! Make lowerCase elemental
!
! Revision 2.42  2004/06/16 01:25:08  vsnyder
! Make Capitalize elemental
!
! Revision 2.41  2004/06/10 00:57:47  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.40  2004/06/09 00:02:35  pwagner
! GetUniqueList now accepts optional arg str2 returning str not in str2
!
! Revision 2.39  2004/01/27 21:34:02  pwagner
! Fixed some bugs in ExtractSubString
!
! Revision 2.38  2003/12/11 23:02:35  pwagner
! yyyymmdd_to_dai may take 3 ints or str
!
! Revision 2.37  2003/12/07 23:10:42  pwagner
! Added RemoveElemFromList; bug fixes in ReplaceSubString
!
! Revision 2.36  2003/12/05 00:52:18  pwagner
! Added yyyymmdd_to_dai (though arguably this belongs in time_m)
!
! Revision 2.35  2003/10/28 19:28:32  vsnyder
! Make sure outStr always has a value
!
! Revision 2.34  2003/10/15 00:34:19  pwagner
! Fixed the real bug in NumStringElements
!
! Revision 2.33  2003/10/14 18:17:02  pwagner
! Fixed problem with reducing switches to unique list
!
! Revision 2.32  2003/10/09 23:33:11  pwagner
! Added GetUniqueList
!
! Revision 2.31  2003/09/15 23:04:06  vsnyder
! Remove unused local variable
!
! Revision 2.30  2003/04/11 23:29:30  pwagner
! Fixed bug in ReplaceSubString; added ExtractSubString
!
! Revision 2.29  2003/02/27 18:36:57  pwagner
! utc_to_yyyymmdd optionally returns yy-mm-ddT00:00:00Z
!
! Revision 2.28  2003/02/19 19:08:40  pwagner
! Added ReplaceSubString
!
! Revision 2.27  2003/02/01 00:28:32  pwagner
! Added utc_to_yyyymmdd
!
! Revision 2.26  2003/01/15 21:20:00  pwagner
! Added readIntsFromChars
!
! Revision 2.25  2002/10/29 19:55:39  pwagner
! Fixed mistake in StringElementNum that caused crashes
!
! Revision 2.24  2002/10/29 01:00:05  pwagner
! optional param part_match added to str element routines
!
! Revision 2.23  2002/10/08 00:09:12  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.22  2002/04/29 17:39:31  pwagner
! Comments re hhmmss_value mention mls_utctotai
!
! Revision 2.21  2002/02/22 23:35:42  pwagner
! SortList checks on lax elem length, not number of elems
!
! Revision 2.20  2002/02/22 01:19:57  pwagner
! SortArray not limited to array sizes lt MAXELEM
!
! Revision 2.19  2002/02/19 23:12:03  pwagner
! New optional args to Sorting routines
!
! Revision 2.18  2002/02/15 01:06:12  pwagner
! Added new array and sorting routines
!
! Revision 2.17  2002/01/09 23:46:05  pwagner
! Removed debugging stuff
!
! Revision 2.16  2001/08/03 00:03:08  pwagner
! Added ints2Strings and strings2Ints
!
! Revision 2.15  2001/06/20 23:23:39  vsnyder
! Same as last time, but for LowerCase instead of Capitalize.
!
! Revision 2.14  2001/06/20 23:21:49  vsnyder
! Replace ICHAR with IACHAR and CHAR with ACHAR, to improve portability.
! Make "offset" a parameter.
!
! Revision 2.13  2001/06/07 21:59:41  pwagner
! Added Copyright statement
!
! Revision 2.12  2001/05/29 21:17:03  pwagner
! Removed Downcase; added table of contents
!
! Revision 2.11  2001/05/26 00:21:59  livesey
! Added downcase
!
! Revision 2.10  2001/05/24 23:36:17  pwagner
! Fixed problem with hhmmss_value
!
! Revision 2.9  2001/05/15 23:44:42  pwagner
! Added hhmmss_value
!
! Revision 2.8  2001/05/11 23:41:31  pwagner
! Improved unquote
!
! Revision 2.7  2001/05/11 00:06:54  pwagner
! Added unquote
!
! Revision 2.6  2001/03/14 17:34:00  pwagner
! Removed some of the dross, left all of the gold
!
! Revision 2.5  2001/03/02 19:33:14  pwagner
! Added GetIntHashElement
!
! Revision 2.4  2001/02/24 01:02:45  pwagner
! Added GetStringHashElement; alphabetized entries
!
! Revision 2.3  2001/02/23 00:05:56  pwagner
! Added 4 StringList functions
!
! Revision 2.2  2000/12/01 22:38:00  vsnyder
! Add lowercase function, alphabetize procedures, add "bookmarks"
!
! Revision 2.0  2000/09/05 17:41:06  dcuddy
! Change revision to 2.0
!
! Revision 1.21  2000/09/05 10:59:32  pumphrey
! HCP Fixed an out-of-bounds error
!
@


2.111
log
@Added Justify function
@
text
@d49 1
d325 1
a325 1
  function CompressString (str) result (outstr)
d327 10
a336 1
    ! Removes all leading and embedded blanks from a string
d2380 1
a2380 1
  function unAsciify (STR, HOW) result (OUTSTR)
d2400 1
a2400 1
  ! (d) cut off both stride and evrything leftward, call remainder "remainder"
d2940 1
a2940 1
       "$Id: MLSStrings.f90,v 2.110 2019/10/16 20:50:13 pwagner Exp $"
d2951 3
@


2.110
log
@Added Enclosure
@
text
@d15 1
a15 1
  use MLSFinds, only: FindFirst, FindNext
d20 1
a20 1
    & Readintsfromchars, Stretch, Trim_Safe
d65 1
a79 1
! Replace            Replaces every instance of oldChar with newChar
d82 1
d85 1
a85 1
! Reverse_trim       (Reverses after trimming its argument)
d128 1
d138 3
a140 3
! readNumFromBaseN ( char* strs, real float, int N, [char* options] )
! readIntFromBaseN ( char* strs, int int, int N, [char* options] )
! readIntsFromChars ( char* strs[(:)], int ints[(:)], &
d142 1
a142 1
! readNumsFromChars ( char* strs[(:)], num num[(:)], &
d144 1
a144 1
! readRomanNumerals ( char* strs, int int )
d208 9
a216 9
! HHMMSS_value              count_words
! indexes                   LowerCase
! isRepeat                  Reverse
! LinearSearchStringArray   strings2Ints
! nappearances              trim_safe
! ncopies
! readIntsFromChars         
! reFormatDate              
! reFormatTime              
d219 1
a219 1
! streq                     
d226 1
a226 1
    & IsAllAscii, IsAlphabet, IsComment, IsDigits, IsRepeat, &
d833 115
d2930 1
a2930 1
       "$Id: MLSStrings.f90,v 2.109 2019/07/17 20:13:42 pwagner Exp $"
d2941 3
@


2.109
log
@Replace may now take the arg reverse to replace non-matching oldChar; added Swap
@
text
@d53 2
d118 1
d222 1
a222 1
    & Delete, Depunctuate, FlushArrayLeft, Hhmmss_Value, &
d464 69
d1427 5
d2813 1
a2813 1
       "$Id: MLSStrings.f90,v 2.108 2019/04/09 20:35:17 pwagner Exp $"
d2824 3
@


2.108
log
@Moved some procedures from MLSStrings to new MLSStrings_0
@
text
@d38 1
a38 1
! STRINGOPTIONS      Default options string
d63 1
a63 1
! lenTrimToAscii     len_trim of string ignoring all non-ascii chars
d72 1
a72 1
! readNumFromBaseN   Interprets a string as base n representation; returns float
d78 2
a79 1
! remap              Replaces every instance of char in old with corresponding nw
d84 1
a84 1
! size_trim          Returns len_trim of equivalent character scalar for array
d88 1
a88 1
! squeeze            Snip excess spaces from between words; optionally snip all
d90 1
a90 1
! streq              Generalized strings "==" (optionally ignoring case,
d92 1
a92 1
! stretch            Insert spaces between words; optionally between letters
d94 2
a95 1
! trim_safe          trims string down, but never to length 0
d97 1
a97 1
! unAsciify          restore non-ascii characters in place of their coded forms
d99 1
a99 1
! unWrapLines        undo the splitting of commands across multiple lines
d141 2
a142 1
! char* Replace ( char* str, char oldChar, char newChar, [int max] )
d160 1
d230 1
a230 1
    & Trim_Safe, TrueList, UnAsciify, UnWrapLines, &
d252 1
a252 1
  character(len=16), public, save :: Stringoptions = ' '
d257 1
a257 1
  integer, public, parameter      :: Stringcontainsforbiddens=-999
d259 1
a259 1
  integer, public, parameter      :: Lenorsizetoosmall=-999
d301 2
a302 2
  ! ------------------------------------------------  CHARTOINT  -----
  elemental function CHARTOINT (str) result (int)
d316 1
a316 1
  end function CHARTOINT
d343 1
a343 1
  ! ------------------------------------------------  COUNT_quotes  -----
d1266 1
a1266 1
  function Replace (str, oldChar, newchar, max) result (outstr)
d1270 4
d1278 1
d1283 1
d1291 2
d1296 13
a1308 4
      if ( str(i:i) == oldChar ) then
        reps = reps + 1
        if ( reps > myMax ) exit
        outstr(i:i) = newChar
d1663 1
a1663 1
  elemental SUBROUTINE SplitWords(line,first,rest,last,&
d2121 23
d2736 1
a2736 1
       "$Id: MLSStrings.f90,v 2.107 2019/03/21 23:44:38 pwagner Exp $"
d2747 3
@


2.107
log
@Fixed error in nCharsinFormat; cosmetic improvements
@
text
@a14 1
  use Machine, only: Crash_Burn, Exit_With_Status, NeverCrash
d16 5
a59 1
! IsAscii            Is each array element ascii, i.e. non-binary
a118 1
! log(:) isAscii( char arg(:) )
a228 8
  interface Asciify
    module procedure Asciify_Scalar, Asciify_1d, Asciify_2d, Asciify_3d
  end interface

  interface ReadIntsFromChars
    module procedure ReadAnIntFromChars, ReadIntArrayFromChars
  end interface

d265 1
a265 36
  ! The following array is used to encode non-ascii characters mnemonically
  character(len=*), dimension(33), private, parameter :: MnemonicCodes = (/ &
   & 'nul', &
   & 'soh', &
   & 'stx', &
   & 'etx', &
   & 'eot', &
   & 'enq', &
   & 'ack', &
   & 'bel', &
   & 'bs ', &
   & 'ht ', &
   & '1f ', &
   & 'vt ', &
   & 'ff ', &
   & 'cr ', &
   & 'so ', &
   & 'si ', &
   & 'dle', &
   & 'dcl', &
   & 'dc2', &
   & 'dc3', &
   & 'dc4', &
   & 'nak', &
   & 'syn', &
   & 'etb', &
   & 'can', &
   & 'em ', &
   & 'sub', &
   & 'esc', &
   & 'fs ', &
   & 'gs ', &
   & 'rs ', &
   & 'us ', &
   & 'del' /)
  
a267 128
  ! -------------------------------------------------  Asciify  -----
  ! takes input string and replaces any non-printing characters
  ! with corresponding ones in range [32,126]
  ! leaving other chars alone
  !
  ! How the replacement is done is according to the optional arg
  !    how         meaning
  !    ---         -------
  !  'shift'       shift to the character with matching modulus (default)
  !                  (a poor choice for a default, in my opinion)
  !  'snip'        remove the offending character (shortening the string)
  !  'decimal'     return <nnn> where nnn is the decimal value (e.g. 0)
  !  'octal'       return <nnn> where nnn is the octal value (e.g. 000)
  !  'mnemonic'    return <ID> where ID is the mnemonic code (e.g. NUL)
  !  '*'           replace with whatever character how was (e.g., '*')
  ! Note that some of these options may output a longer string than the input

  ! (see also ReplaceNonAscii, unAsciify)
  function Asciify_scalar (STR, HOW) result (OUTSTR)
    !--------Argument--------!
    character (len=*), intent(in)           :: STR
    character (len=5*len(str))              :: OUTSTR
    character (len=*), optional, intent(in) :: HOW

    !----------Local vars----------!
    integer :: I, K
    character(len=5) :: insert
    character(len=1), dimension(len(str)) :: mold
    character(len=8) :: myHow
    !----------Executable part----------!
    outstr=str
    myHow = 'shift'
    if ( present(how) ) myHow = how
    mold = transfer(str,mold,size=len(str))
    if ( all(isAscii(mold)) ) return
    outstr = ' '
    select case (myHow)
    case ('shift')
      do i=1, len(str)
        if ( isAscii(str(i:i)) ) cycle
        outstr(i:i) = ShiftChar(str(i:i))
      end do
    case ('snip')
      k = 1
      do i=1, len(str)
        if ( isAscii(str(i:i)) ) then
          outstr(k:k) = str(i:i)
          k = k + 1
        endif
      end do
    case default
    ! case ('decimal', 'octal', 'mnemonic')
      k = 1
      do i=1, len(str)
        if ( isAscii(str(i:i)) ) then
          outstr(k:k) = str(i:i)
          k = k + 1
        else
          if ( myHow == 'decimal' ) then
            insert = decimalCode( str(i:i) )
          elseif ( myHow == 'octal' ) then
            insert = octalCode( str(i:i) )
          elseif ( myHow == 'mnemonic' ) then
            insert = mnemonicCode( str(i:i) )
          else
            insert = myHow(1:1)
          endif
          outstr(k:) = insert
          k = k + len_trim(insert)
        endif
      end do
    end select
  end function Asciify_scalar

  function Asciify_1d (STR, HOW) result (OUTSTR)
    character (len=*), dimension(:), intent(in)           :: STR
    character (len=5*len(str)), dimension(size(str))      :: OUTSTR
    character (len=*), optional, intent(in) :: HOW
    integer :: i
    do i=1, size(str)
      outstr(i) = Asciify( str(i), how )
    enddo
  end function Asciify_1d

  function Asciify_2d (STR, HOW) result (OUTSTR)
    character (len=*), dimension(:,:), intent(in)                  :: STR
    character (len=5*len(str)), dimension(size(str,1),size(str,2)) :: OUTSTR
    character (len=*), optional, intent(in) :: HOW
    integer :: i
    do i=1, size(str,2)
      outstr(:,i) = Asciify( str(:,i), how )
    enddo
  end function Asciify_2d

  function Asciify_3d (STR, HOW) result (OUTSTR)
    character (len=*), dimension(:,:,:), intent(in)                  :: STR
    character (len=5*len(str)), dimension(size(str,1),size(str,2),size(str,3))&
      &  :: OUTSTR
    character (len=*), optional, intent(in) :: HOW
    integer :: i
    do i=1, size(str,3)
      outstr(:,:,i) = Asciify( str(:,:,i), how )
    enddo
  end function Asciify_3d

  ! -------------------------------------------------  CAPITALIZE  -----
  elemental function Capitalize (STR) result (OUTSTR)
    ! takes a-z and replaces with A-Z 
    ! leaving other chars alone
    !--------Argument--------!
    character (len=*), intent(in) :: STR
    character (len=len(str)) :: OUTSTR

    !----------Local vars----------!
    integer :: I, ICODE
    integer, parameter :: OFFSET=iachar("A")-iachar("a")
    !----------Executable part----------!
    outstr=str

    do i=1, len_trim(str) ! Won't need to Capitalize trailing spaces
       icode=iachar(outstr(i:i))
       if ( icode >=iachar("a") .and. icode <= iachar("z")) then
          outstr(i:i)=achar(icode+offset)
       end if
    end do

  end function Capitalize

a864 23
  ! --------------------------------------------------  LowerCase  -----
  elemental function LowerCase (str) result (outstr)
    ! takes A-Z  and replaces with a-z
    ! leaving other chars alone
    !--------Argument--------!
    character (len=*), intent(in) :: STR
    character (len=len(str))      :: OUTSTR

    !----------Local vars----------!
    integer            :: i, icode
    integer, parameter :: offset=IACHAR("a")-IACHAR("A")
    !----------Executable part----------!
    outstr=str

    DO i = 1, len_trim(str) ! Won't need to Lowercase trailing spaces
       icode=IACHAR(outstr(i:i))
       IF ( icode >=IACHAR("A") .AND. icode <= IACHAR("Z")) THEN
          outstr(i:i)=achar(icode+offset)
       END IF
    END DO

  end function LowerCase

a903 59
  ! ---------------------------------------------------  nCharsinFormat  -----
  function nCharsinFormat ( Format ) result( nplusm )
    ! Utility to calculate how many characters in a format spec:         
    ! [n{xX}][,]{DEFGdefg}m.b                                             
    ! where n, m, and b are digits (we care only about n and m)           
    ! return (n+m)
    ! Tested for specs: sci. format esm.b and eng. format enm.b
    ! Also for min. width spec: 'f0.b' it will silently return 0
    ! (It's up to you to handle that correctly)
    ! Args                                                                
    character(len=*), intent(in) ::  Format                               
    integer :: nplusm                                                     
    ! Local variables                                                     
    character(len=20) :: kChar                               
    integer :: n, m, p, q
    ! Executable                                                          
    nplusm = 0                                                            
    kChar=lowerCase(Format)
    if ( index( KChar, 'es' ) > 0 ) then
      p = index( KChar, 'es' )
      kChar = kChar(:p-1) // 'f' // KChar(p+2:)
    elseif ( index( KChar, 'en' ) > 0 ) then
      p = index( KChar, 'en' )
      kChar = kChar(:p-1) // 'f' // KChar(p+2:)
    elseif ( index( KChar, 'g' ) > 0 ) then
      p = index( KChar, 'g' )
      kChar = kChar(:p-1) // 'f' // KChar(p+1:)
    elseif ( index( KChar, 'e' ) > 0 ) then
      p = index( KChar, 'e' )
      kChar = kChar(:p-1) // 'f' // KChar(p+1:)
    elseif ( index( KChar, 'd' ) > 0 ) then
      p = index( KChar, 'd' )
      kChar = kChar(:p-1) // 'f' // KChar(p+1:)
    endif
    p = index( KChar, 'f' )
    if ( p < 1 ) return
    call readIntsFromChars ( KChar(p+1:), m, ignore='.,*' )
    if (m < 1) then
      print *, 'Format: ', trim(Format)
      call PrintMessage ( ModuleName, &              
      & 'Bad conversion to m in OUTPUT_xxxLE (format not "{defg}"' )      
    endif
    if ( index(TRIM(Format), 'x' ) == 0 ) then                          
      n = 0                                                               
    else                                                                  
      p = index( KChar, '(' )
      q = index( KChar, 'x' )
      call readIntsFromChars ( KChar(p+1:q-1), n, ignore='.,*' )
      if (n < 1) then                                                     
        print *, 'Format: ', trim(Format)
        print *, trim(kChar)                                              
        print *, trim(Format)                                           
        call PrintMessage ( ModuleName, &                     
          & 'Bad conversion to n in OUTPUT_xxxLE (format not "(nx)"' )  
      end if                                                              
    end if                                                                 
    nplusm = n + m                                                        
  end function nCharsinFormat

a1117 83
  ! ----------------  readIntsFromChars  ----- readNumsFromChars  -----
  ! This family of routines reads either a single number or an array
  ! depending on the shape of its args
  ! If called with type integer (real, double) return args, it will try to read
  ! the string data as integers (reals, doubles)
  
  ! Use:
  ! Depending on optional arguments you can numerical part from a combination
  ! of number and unit, e.g. 6.3km
  
  ! Beware of mixing e-type format with dimensions
  ! E.g., '3.2e0ppmv' will very likely confuse the subroutine
  ! (is the unit string 'ppmv' or is it 'e0ppmv'?)
  subroutine readAnIntFromChars (str, num, forbiddens, ignore)
    ! takes a string and returns an integer
    ! using Fortran "read"
    ! (which could cause an io error--that's why this
    ! subroutine exists)
    ! If the string is blank or contains one of forbiddens
    ! the int is STRINGCONTAINSFORBIDDENS
    
    ! Then snip away any from the set ignore before the first digit
    ! if ignore is present.
    ! If ignore is '*', that means ignore all alphabetical chars
    ! If ignore contains '*', that means ignore all alphabetical chars
    ! plus any other chars among ignore.
    ! Note that '*' will only escape alphabetical chars.
    ! If you want to escape any other chars in addition to alphabeticals,
    ! you should add that char to the escape string 
    ! (e.g. ':*' to escape all alphabeticals and to escape ':', too)
    ! If the string is composed entirely of ignorable chars, int is 0
    ! If the string contains multiple numbers, separated by ignorables.
    ! only the first number is returned.
    
    ! Finally attempt to read as an int what remains
    ! If that should fail as a last resort return STRINGCONTAINSFORBIDDENS

    ! Examples:
    ! (1) if str='band13a' and ignore='*', int will be 13
    ! (2) if str='3 cm' and forbiddens='c', int will be left undefined
    !     because of the 'm'
    ! (3) if str='b7f2' and ignore='*', int will be 7

    ! Limitation: you're unable to "escape" a * so you'll have to
    ! preprocess the * away if you really want to read a string which has
    ! a * in it somewhere
    !
    !--------Argument--------!
    character (len=*), intent(in) ::   str
    integer, intent(out)          ::   num
    include 'ReadANumFromChars.f9h'
  end subroutine readAnIntFromChars

  subroutine readIntArrayFromChars (strs, ints, forbiddens, ignore)
    ! takes an array of strings and returns integer array
    ! using Fortran "read"
    ! If any element of string array is blank or contains one of forbiddens
    ! the corresponding element of ints is left undefined
    ! Not useful yet
    !
    !--------Argument--------!
    !    dimensions are (len(strs(1)), size(strs(:)))
    character (len=*), intent(in), dimension(:) ::   strs
    integer, intent(out), dimension(:)          ::   ints
    character (len=*), intent(in), optional     ::   forbiddens
    character (len=*), optional, intent(in)     ::   ignore

    !----------Local vars----------!
    integer :: i, arrSize
    !----------Executable part----------!

   ! Check that all is well (if not returns blanks)
   arrSize = MIN(size(strs), size(ints))
   if ( arrSize <= 0 ) then
     ints = LENORSIZETOOSMALL
     return
   endif
   do i=1, arrSize
     call readAnIntFromChars(strs(i), ints(i), forbiddens, ignore)
   enddo

  end subroutine readIntArrayFromChars

a1291 27
   ! --------------------------------------------------  ReplaceNonAscii  -----
  function ReplaceNonAscii (str, newchar, exceptions) result (outstr)
    ! takes a string and returns one with non-ascii chars replaced by newChar
    ! E.g., to replace every char(0), which is the NUL character, 
    ! and a trailing char(13), which is a line feed,
    ! with blanks, which is char(32)
    ! arg = ReplaceNonAscii( arg, char(32) )
    
    ! If exceptions are present, don't replace them
    
    ! (see also Asciify)
    character(len=*), intent(in)           :: str
    character(len=1), intent(in)           :: newChar
    character(len=*), intent(in), optional :: exceptions
    character(len=len(str))                :: outstr
    ! Internal variables
    integer :: i
    ! Executable
    outstr = str
    do i=1, len(str)
      if ( present(exceptions) ) then
        if ( index(exceptions, str(i:i)) > 0 ) cycle
      endif
      if ( .not. isAscii(str(i:i)) ) outstr(i:i) = newChar
    enddo
  end function ReplaceNonAscii

a2069 87
  ! ------------------------------------------------- stretch --------
  ! Insert extra spaces between words
  ! E.g., turns 'How long, America' into 'How  long,  America'
  ! optionally inserts a space after every character
  ! making it 'H o w   l o n g ,   A m e r i c a'
  
  ! options, if present, can contain the following characters
  !  character                 effect
  !     a                   insert space after every character
  !    o[xyz..]             insert space only after x or y or z or ..
  function stretch( str, options ) result( stretched )
    ! Args
    character(len=*), intent(in)           :: str
    character(len=*), optional, intent(in) :: options
    character(len=2*len(str)+1)                :: stretched
    ! Internal variables
    integer                                :: cpos ! current position in str
    integer                                :: cposq ! current position in stretched
    logical                                :: newWord
    logical                                :: everywhere
    character(len=1)                       :: space
    character(len=256)                     :: onlyAfter
    ! Executable
    everywhere = .false.
    if ( present(options) ) everywhere = ( index(options, 'a') > 0 )
    onlyAfter = ' '
    if ( present(options) ) then
      cpos = index(options, 'o')
      if ( cpos > 0 ) then
        cpos = index(options, '[')
        cposq = index(options, ']')
        onlyAfter = options(cpos:cposq)
      endif
    endif
    space = ' '
    stretched = str
    if ( len_trim(str) < 2 ) return
    stretched = ' '
    if ( everywhere ) then
      cpos = len_trim(str)
    ! Fortran does not support (start : end : stride) syntax for substrings
    ! stretched(1:2*cpos+1:2) = str(1:cpos)
    ! stretched(2:2*cpos:2) = ' '
      do cpos = 1, len_trim(str)
        ! This is easy -- snip every space no matter where
        stretched(2*cpos-1:2*cpos) = str(cpos:cpos) // ' '
      enddo
    elseif( len_trim(onlyAfter) > 0 ) then
      stretched = str
      cposq = 1
      if ( len_trim(str) < 2 ) return
      do cpos = 2, len_trim(str)
        cposq = cposq + 1
        stretched(cposq:cposq) = str(cpos:cpos)
        if ( cpos == len_trim(str) ) then
          cposq = cposq + 1
          stretched(cposq:cposq) = ' '
        elseif ( index(trim(onlyAfter), str(cpos:cpos)) > 0 .and. &
          & str(cpos+1:cpos+1) /= ' ' ) then
          cposq = cposq + 1
          stretched(cposq:cposq) = ' '
        endif
      enddo
    else
      stretched(1:1) = str(1:1)
      cposq = 1
      newWord = ( str(1:1) == space )
      do cpos = 2, len_trim(str)
        if ( newWord ) then
          ! Already have at least one space, so add one more
          cposq = cposq + 1
          stretched(cposq:cposq) = ' '
          if ( str(cpos:cpos) /= space ) then
            cposq = cposq + 1
            stretched(cposq:cposq) = str(cpos:cpos)
          endif
        else
          ! don't insert
          cposq = cposq + 1
          stretched(cposq:cposq) = str(cpos:cpos)
        endif
        ! Have we reached a space which divides words?
        newWord = ( str(cpos:cpos) == space )
      enddo
    endif
  end function stretch
       
a2130 18
  ! -------------------------------------------------  TRIM_SAFE  -----
  function trim_safe (STR) result (OUTSTR)
    ! trims str returning a string of length no less than 1
    ! similar to trim, but will return a single blank character
    ! Useful in those cases where trim would result in strings of length 0
    ! E.g., MakeHDFAttribute(trim(' ')) fails but
    ! E.g., MakeHDFAttribute(trim_safe(' ')) succeeds
    !--------Argument--------!
    character (len=*), intent(in) :: STR
    character (len=max(len_trim(str), 1)) :: OUTSTR

    !----------Executable part----------!
    outstr=' '

    if ( len_trim(str) > 0 ) outstr=trim(str)

  end function trim_safe

a2544 24
  ! ------------------------------------  PrintMessage  -----
  subroutine PrintMessage ( name, line, advance )
    ! Args
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: line
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    ! Local variables
    integer :: nChars
    character(len=len(line) + len(name) + 3) :: thus
    ! Executable
    nChars = len(line)
    thus = line
    if ( len_trim(name) > 0 ) then
      nChars = len(line) + len(name) + 3
      thus = '(' // trim(name) // ') ' // line
    endif
    print *, 'thus(1:nChars): ' 
    print *, thus(1:nChars)
    NeverCrash = .false.
    call Crash_Burn
  end subroutine PrintMessage

a2562 65
  !
  ! ---------------------------------------------------  isAlphabet  -----
  elemental function isAlphabet(arg, inputcase) result(itIs)
    ! Returns TRUE if arg alphabetical; 
    ! i.e.is one of {'a', 'b', ..}
    ! Note: to check if input is UPPER  lower, either, set
    ! inputcase          case
    ! ----------         ----
    !   UPPER             u
    !   lower             l
    !   either            e (default)
    ! Args
    character(len=1), intent(in) :: arg
    character(len=1), optional, intent(in) :: inputcase
    logical                      :: itIs
    ! Internal variables
    logical :: itsEither
    logical :: itsLower
    character(len=*), parameter :: list='abcdefghijklmnopqrstuvwxyz'
    character(len=1)            :: myCase
    ! Executable
    myCase = 'e'
    if ( present(inputcase) ) myCase = inputcase
    itsLower = ( index(list, arg) > 0 )
    itsEither = ( index(list, lowercase(arg)) > 0 )
    select case(myCase)
    case ('u')
      itIs = itsEither .and. .not. itsLower
    case ('l')
      itIs = itsLower
    case default
      itis = itsEither
    end select    
  end function isAlphabet

  ! ---------------------------------------------------  isAllAscii  -----
  elemental function isAllAscii(arg) result(itIs)
    ! Returns TRUE if each substring of arg is in range of printing chars [32,126]
    ! Args
    character(len=*), intent(in) :: arg
    logical                      :: itIs
    ! Internal variables
    integer :: i
    ! Executable
    itIs = isAscii(arg(1:1))
    if ( len(arg) < 2 .or. .not. itIs ) return
    do i=2, len(arg)
      itis = itIs .and. isAscii(arg(i:i))
    enddo
  end function isAllAscii

  ! ---------------------------------------------------  isAscii  -----
  elemental function isAscii(arg) result(itIs)
    ! Returns TRUE if arg is in range of printing chars [32,126]
    ! Args
    character(len=1), intent(in) :: arg
    logical                      :: itIs
    ! Internal variables
    integer, parameter :: pcMin = iachar(' ')
    integer, parameter :: pcMax = iachar('~')
    integer :: icode
    ! Executable
    icode = iachar(arg)
    itis = .not. ( icode < pcMin .or. icode > pcMax )
  end function isAscii
a2644 101
  ! ---------------------------------------------------  octalCode  -----
  function octalCode(arg, invert) result(theCode)
    character(len=*), intent(in)  :: arg
    logical, optional, intent(in) :: invert
    character(len=5) :: theCode
    ! Returns '<nnn>' where nnn is the octal code of arg
    integer :: iCode
    character(len=3) :: nnn
    logical :: myInvert
    ! Executable
    ! print *, 'octal arg ', arg
    myInvert = .false.
    if ( present(invert) ) myInvert = invert
    if ( myInvert ) then
      read( arg(2:len_trim(arg)-1),'(o3.3)') iCode
      ! print *, 'arg(2:len_trim(arg)-1) ', arg(2:len_trim(arg)-1)
      ! print *, 'iCode ', iCode
      theCode = achar(iCode)
    else
      write(nnn,'(o3.3)') iachar(arg)
      theCode = '<' // nnn // '>'
    endif
  end function octalCode

  ! ---------------------------------------------------  decimalCode  -----
  function decimalCode(arg, invert) result(theCode)
    character(len=*), intent(in)  :: arg
    logical, optional, intent(in) :: invert
    character(len=5) :: theCode
    ! Returns '<n>' where n is iachar(arg)
    integer :: iCode
    character(len=3) :: n
    logical :: myInvert
    ! Executable
    ! print *, 'decimal arg ', arg
    myInvert = .false.
    if ( present(invert) ) myInvert = invert
    if ( myInvert ) then
      call readIntsFromChars( arg(2:len_trim(arg)-1), iCode )
      theCode = achar(iCode)
      ! print *, 'arg(2:len_trim(arg)-1) ', arg(2:len_trim(arg)-1)
      ! print *, 'iCode ', iCode
    else
      write(n,'(i3)') iachar(arg)
      theCode = '<' // trim(adjustl(n)) // '>'
    endif
  end function decimalCode

  ! ---------------------------------------------------  mnemonicCode  -----
  function mnemonicCode(arg, invert) result(theCode)
    character(len=*), intent(in) :: arg
    logical, optional, intent(in) :: invert
    character(len=5) :: theCode
    ! Returns '<mnc>' where mnc is a mnemonic code like NUL
    integer :: icode
    logical :: myInvert
    ! Executable
    ! print *, 'mnemonic ', arg
    myInvert = .false.
    if ( present(invert) ) myInvert = invert
    if ( myInvert ) then
      iCode = FindFirst( MNEMONICCODES == lowercase(arg(2:len_trim(arg)-1)) )
      if ( iCode == 33 ) iCode = 128
      theCode = achar(max(iCode - 1, 0))
      ! print *, 'arg(2:len_trim(arg)-1) ', arg(2:len_trim(arg)-1)
      ! print *, 'iCode ', iCode
    else
      theCode = arg
      if ( isAscii(arg) ) return
      icode = iachar(arg) + 1
      icode = min(icode, size(MNEMONICCODES))
      theCode = '<' // trim( MNEMONICCODES(icode) ) // '>'
    endif
  end function mnemonicCode

  ! ---------------------------------------------------  shiftChar  -----
  elemental character function shiftChar( arg, char1, char2 )
    character(len=1), intent(in)           :: arg
    character(len=1), optional, intent(in) :: char1
    character(len=1), optional, intent(in) :: char2
    ! shift the character so its value lies in the range [char1,char2]
    ! (by default char1 = ' ', char2 = '~')
    integer :: m1, m2
    integer :: icode
    integer :: resultcode
    ! Executable
    m1 = iachar(' ')
    if ( present(char1) ) m1 = iachar(char1)
    m2 = iachar('~')
    if ( present(char2) ) m2 = iachar(char2)
    icode = iachar(arg)
    shiftChar = arg
    resultcode = -1 ! This means the character did not need shifting
    if ( icode < m1 ) then
      resultcode = m1 + mod( icode+256, m2-m1 )
    elseif ( icode > m2 ) then
      resultcode = m1 + mod( icode, m2-m1 )
    endif
    if ( resultcode > -1 ) shiftChar = achar(resultcode)
  end function shiftChar

d2666 23
d2692 1
a2692 1
       "$Id: MLSStrings.f90,v 2.106 2019/01/24 18:31:12 pwagner Exp $"
d2703 3
@


2.106
log
@Reorganized modules that print to simplify toolkit-free builds
@
text
@d254 1
a254 1
  character(len=16), public, save :: STRINGOPTIONS = ' '
d257 1
a257 1
  integer, public, parameter :: INVALIDHHMMSSSTRING = 1
d259 1
a259 1
  integer, public, parameter :: STRINGCONTAINSFORBIDDENS=-999
d261 1
a261 1
  integer, public, parameter :: LENORSIZETOOSMALL=-999
d266 2
a267 2
  integer, public, parameter :: MaxStreqLen  = 2048
  integer, public, parameter :: MaxSubstrLen = 256
d269 2
a270 2
  logical, private, save          :: caseSensitive       
  logical, private, save          :: ignoreLeadingSpaces
d272 1
a272 1
  character(len=*), dimension(33), private, parameter :: MNEMONICCODES = (/ &
d489 1
a489 1
    character (len=*), INTENT(IN) :: str
d522 3
a524 3
    character (len=*), INTENT(in) :: str
    character (len=1), INTENT(in) :: lquote
    character (len=1), INTENT(in) :: rquote
d553 1
a553 1
    character (len=*), INTENT(in) :: str
d1097 1
a1097 1
  function nCharsinFormat ( Format ) result(nplusm)
d1109 1
a1109 1
    character(len=20) :: kChar, myFormat                                  
d1138 1
a1138 1
    if ( index(TRIM(myFormat), 'x' ) == 0 ) then                          
d1147 1
a1147 1
        print *, trim(myFormat)                                           
d1205 1
a1205 1
    integer, INTENT(IN) :: unit ! Input file unit
d1210 4
a1213 4
    CHARACTER(LEN=*), INTENT(INOUT) :: fullLine ! Output line
    CHARACTER(LEN=*), optional :: commentChar
    CHARACTER(LEN=*), optional :: continuationChar
    logical, INTENT(OUT), optional :: eof ! Set if got to eof
d1218 1
a1218 1
    CHARACTER(LEN=len(fullLine)) :: inputLine ! One line from file
d1224 2
a1225 2
    CHARACTER(LEN=1) :: useCommentChar
    CHARACTER(LEN=1) :: useContinuationChar
d1395 4
a1398 4
    ! Note that '*' will only escape alphabetical chars, if you want
    ! to escape any other chars in addition to alphabeticals, you
    ! should add that char to the escape string (e.g. ':*' to escape
    ! alphabeticals and ':')
d1409 1
d1417 1
a1417 1
    character (len=*), INTENT(in) ::   str
d1431 1
a1431 1
    character (len=*), INTENT(in), dimension(:) ::   strs
d1433 2
a1434 2
    character (len=*), INTENT(in), optional     ::   forbiddens
    character (len=*), optional, intent(in)     :: ignore
d1454 1
a1454 1
    character (len=*), INTENT(in) ::   str
d1461 1
a1461 1
    character (len=*), INTENT(in) ::   str
d1662 1
a1662 1
    character (len=*), INTENT(IN) :: str
d2008 4
a2011 4
    character (len=*), INTENT(IN) :: line
    character (len=*), INTENT(OUT) :: first
    character (len=*), INTENT(OUT) :: rest
    character (len=*), INTENT(OUT), optional :: last
d2013 2
a2014 2
    logical, INTENT(IN), optional :: threeWay
    character (len=*), INTENT(IN), optional :: delimiter ! really separator
d2527 1
a2527 1
    character (len=*), INTENT(in), dimension(:) ::   strs
d3325 1
a3325 1
       "$Id: MLSStrings.f90,v 2.105 2018/03/27 22:06:52 pwagner Exp $"
d3336 3
@


2.105
log
@No longer uses Optional_m; now one less module needed to build toolkitlessly
@
text
@d13 1
a13 1
MODULE MLSStrings               ! Some low level string handling stuff
d15 1
d37 2
a38 2
! asciify            purify chars to be within printing range [32,126]
!                      (no binary) (see also ReplaceNonAscii, unasciify)
d65 1
d76 1
a76 1
! ReplaceNonAscii    Replaces every non-ascii char with newChar (see also asciify)
d92 2
a93 2
! unasciify          restore non-ascii characters in place of their coded forms
!                       (see asciify)
d101 1
a101 1
! char* asciify ( char* str, [char* how] )
d125 1
d157 1
a157 1
! char* unasciify ( char* str, [char* how] )
d217 1
a217 1
    & NAppearances, NCopies, &
d309 1
a309 1
  ! -------------------------------------------------  ASCIIFY  -----
d318 1
a318 1
  !                  (a poor choice for default, in my opinion)
d326 2
a327 2
  ! (see also ReplaceNonAscii, unasciify)
  function ASCIIFY_scalar (STR, HOW) result (OUTSTR)
d381 1
a381 1
  end function ASCIIFY_scalar
d383 1
a383 1
  function ASCIIFY_1d (STR, HOW) result (OUTSTR)
d389 1
a389 1
      outstr(i) = asciify( str(i), how )
d391 1
a391 1
  end function ASCIIFY_1d
d393 1
a393 1
  function ASCIIFY_2d (STR, HOW) result (OUTSTR)
d399 1
a399 1
      outstr(:,i) = asciify( str(:,i), how )
d401 1
a401 1
  end function ASCIIFY_2d
d403 1
a403 1
  function ASCIIFY_3d (STR, HOW) result (OUTSTR)
d410 1
a410 1
      outstr(:,:,i) = asciify( str(:,:,i), how )
d412 1
a412 1
  end function ASCIIFY_3d
d484 1
a484 1
  FUNCTION CompressString (str) RESULT (outstr)
d489 2
a490 2
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr
d493 1
a493 1
    INTEGER :: i, n
d506 1
a506 1
  END FUNCTION CompressString
d509 1
a509 1
  FUNCTION count_quotes ( str, lquote, rquote ) RESULT (no_of_quotes)
d522 3
a524 3
    CHARACTER (len=*), INTENT(in) :: str
    CHARACTER (len=1), INTENT(in) :: lquote
    CHARACTER (len=1), INTENT(in) :: rquote
d526 1
a526 1
    INTEGER::no_of_quotes
d528 2
a529 2
    INTEGER::j1
    INTEGER::j2
d544 1
a544 1
  END FUNCTION count_quotes
d547 1
a547 1
  FUNCTION count_words (str) RESULT (no_of_words)
d553 1
a553 1
    CHARACTER (len=*), INTENT(in) :: str
d555 1
a555 1
    INTEGER::no_of_words
d557 1
a557 1
    INTEGER::j
d569 1
a569 1
  END FUNCTION count_words
d572 2
a573 2
  Function Delete ( str, ch, max ) result ( outstr )
    ! Function that removes every instance of a char
d600 1
a600 1
  end Function Delete
d603 2
a604 2
  Function Depunctuate ( str ) result ( outstr )
    ! Function that removes punctuation and replaces with blanks
d624 1
a624 1
  end Function Depunctuate
d666 1
a666 1
    ! Function that returns the value in seconds of a string 'hh:mm:ss'
d949 2
a950 2
  FUNCTION LinearSearchStringArray (list, string, caseInsensitive, &
       & testSubstring, listInString) RESULT (sindex)
d953 5
a957 5
    CHARACTER (LEN=*), DIMENSION(:) :: list
    CHARACTER (LEN=*) :: string
    LOGICAL, intent (in), OPTIONAL :: caseInsensitive
    LOGICAL, intent (in), OPTIONAL :: testSubstring
    LOGICAL, intent (in), OPTIONAL :: listInString
d960 2
a961 2
    ! Function result
    INTEGER :: sindex   ! matching string index (0 = not found)
d964 5
a968 5
    INTEGER :: i
    LOGICAL :: useCaseInsensitive
    LOGICAL :: testForSubstring
    LOGICAL :: testForList
    LOGICAL :: found
d1032 1
a1032 1
  END FUNCTION LinearSearchStringArray
d1055 1
a1055 1
  END FUNCTION LowerCase
d1096 59
d1200 1
a1200 1
  SUBROUTINE ReadCompleteLineWithoutComments(unit,fullLine,eof, &
d1205 1
a1205 1
    INTEGER, INTENT(IN) :: unit ! Input file unit
d1211 3
a1213 3
    CHARACTER(LEN=*), OPTIONAL :: commentChar
    CHARACTER(LEN=*), OPTIONAL :: continuationChar
    LOGICAL, INTENT(OUT), OPTIONAL :: eof ! Set if got to eof
d1217 6
a1222 6
    INTEGER :: ioInfo           ! IOSTAT result
    CHARACTER(LEN=LEN(fullLine)) :: inputLine ! One line from file
    INTEGER :: commentStart     ! Start of a comment in line
    INTEGER :: lastChar         ! Last character position in line
    INTEGER :: gotContinuation  ! 1 if continuation needed, 0 if not
    LOGICAL :: firstLine        ! A correction to be applied
d1301 1
a1301 1
  END SUBROUTINE ReadCompleteLineWithoutComments
d1391 1
a1391 1
    ! if ingore is present.
d1416 1
a1416 1
    CHARACTER (LEN=*), INTENT(in) ::   str
d1421 1
a1421 1
  SUBROUTINE readIntArrayFromChars (strs, ints, forbiddens, ignore)
d1430 1
a1430 1
    CHARACTER (LEN=*), INTENT(in), dimension(:) ::   strs
d1432 1
a1432 1
    CHARACTER (LEN=*), INTENT(in), optional     ::   forbiddens
d1436 1
a1436 1
    INTEGER :: i, arrSize
d1449 1
a1449 1
  END SUBROUTINE readIntArrayFromChars
d1453 1
a1453 1
    CHARACTER (LEN=*), INTENT(in) ::   str
d1460 1
a1460 1
    CHARACTER (LEN=*), INTENT(in) ::   str
d1465 1
a1465 1
  SUBROUTINE ReadRealArrayFromChars (strs, nums, forbiddens, ignore)
d1485 1
a1485 1
  END SUBROUTINE ReadRealArrayFromChars
d1487 1
a1487 1
  SUBROUTINE ReadDoubleArrayFromChars (strs, nums, forbiddens, ignore)
d1507 1
a1507 1
  END SUBROUTINE ReadDoubleArrayFromChars
d1595 1
a1595 1
  function Replace (str, oldChar, newchar, max) RESULT (outstr)
d1626 1
a1626 1
  function ReplaceNonAscii (str, newchar, exceptions) RESULT (outstr)
d1635 1
a1635 1
    ! (see also asciify)
d1653 1
a1653 1
  elemental function Reverse (str) RESULT (outstr)
d1661 2
a1662 2
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr
d1665 2
a1666 2
    INTEGER :: i, istr, irev
    CHARACTER (LEN=1) :: strChar
d1688 1
a1688 1
  function Reverse_trim (str) RESULT (outstr)
d2007 4
a2010 4
    CHARACTER (LEN=*), INTENT(IN) :: line
    CHARACTER (LEN=*), INTENT(OUT) :: first
    CHARACTER (LEN=*), INTENT(OUT) :: rest
    CHARACTER (LEN=*), INTENT(OUT), OPTIONAL :: last
d2012 2
a2013 2
    LOGICAL, INTENT(IN), OPTIONAL :: threeWay
    CHARACTER (LEN=*), INTENT(IN), OPTIONAL :: delimiter ! really separator
d2017 3
a2019 3
    CHARACTER (LEN=1) :: useseparator
    LOGICAL :: useThreeWay
    CHARACTER (LEN=LEN(line)) useLine ! Line with leading spaces removed
d2021 1
a2021 1
    INTEGER :: firstseparatorPos,lastseparatorPos,trimmedLen
d2070 1
a2070 1
  END SUBROUTINE SplitWords
d2075 1
a2075 1
  ! Optionally snips all spaces making it 'amanfromSai-Pan'
d2433 1
a2433 1
  ! Optionally inserts a space after every character
d2518 1
a2518 1
  SUBROUTINE strings2Ints (strs, ints)
d2526 1
a2526 1
    CHARACTER (LEN=*), INTENT(in), dimension(:) ::   strs
d2530 1
a2530 1
    INTEGER :: i, substr, strLen, arrSize
d2545 1
a2545 1
  END SUBROUTINE strings2Ints
d2601 1
a2601 1
  ! This reverses the effect of the asciify procedure which recoded
d2622 1
a2622 1
  ! (see also ReplaceNonAscii, asciify)
d2667 1
a2667 1
    ! print *, 'unasciify returning char-valued ', iachar(outstr(1:1))
d2675 1
a2675 1
  SUBROUTINE unWrapLines ( inLines, outLines, nOut, escape, comment )
d2677 2
a2678 2
    character (LEN=*), dimension(:), intent(in)            ::   inLines
    character (LEN=*), dimension(:), intent(out)           ::   outLines
d2680 2
a2681 2
    character (LEN=*), optional, intent(in)                ::   escape
    character (LEN=*), optional, intent(in)                ::   comment
d2730 1
a2730 1
  END SUBROUTINE unWrapLines
d2740 1
a2740 1
  SUBROUTINE writeAnIntToChars (int, str, fmt, specialInts, specialChars)
d2743 2
a2744 2
    character (LEN=*), intent(out)                         ::   str
    character (LEN=*), optional, intent(in)                ::   fmt
d2746 1
a2746 1
    character (LEN=*), intent(in), dimension(:), optional  ::   specialChars
d2769 1
a2769 1
  END SUBROUTINE writeAnIntToChars
d2771 1
a2771 1
  SUBROUTINE writeIntsToChars_1d (ints, strs, fmt, specialInts, specialChars)
d2774 2
a2775 2
    character (LEN=*), intent(out), dimension(:) ::   strs
    character (LEN=*), intent(in), optional      ::   fmt
d2777 1
a2777 1
    character (LEN=*), intent(in), dimension(:), optional  ::   specialChars
d2793 1
a2793 1
  END SUBROUTINE writeIntsToChars_1d
d2795 1
a2795 1
  SUBROUTINE writeIntsToChars_2d (ints, strs, fmt, specialInts, specialChars)
d2797 2
a2798 2
    character (LEN=*), intent(out), dimension(:,:) ::   strs
    character (LEN=*), intent(in), optional      ::   fmt
d2800 1
a2800 1
    character (LEN=*), intent(in), dimension(:), optional  ::   specialChars
d2819 1
a2819 1
  END SUBROUTINE writeIntsToChars_2d
d2927 1
a2927 1
        ! print *, 'str ', asciify(str)
d2930 1
a2930 1
      if ( index(myOptions, 'A') > 0 ) str = asciify(str, 'mnemonic')
d3010 24
d3324 1
a3324 1
       "$Id: MLSStrings.f90,v 2.104 2017/12/08 00:28:44 pwagner Exp $"
d3335 3
d3366 1
a3366 1
! Added count_quotes and unasciify
d3437 1
a3437 1
! isAllAscii, isAscii now public; asciify generic
d3443 1
a3443 1
! Added asciify function
@


2.104
log
@Add optional 'options' arg to CatStrings; by default will not cat empty string
@
text
@a15 1
  use Optional_M, only: Default
d208 15
a222 15
  public :: asciify, &
    & capitalize, catStrings, charToInt, compressString, count_words, &
    & delete, depunctuate, flushArrayLeft, hhmmss_value, &
    & indexes, ints2Strings, &
    & isAllAscii, isAlphabet, isComment, isDigits, isRepeat, &
    & lenTrimToAscii, linearSearchStringArray, lowercase, &
    & nAppearances, nCopies, &
    & readCompleteLineWithoutComments, readIntFromBaseN, readIntsFromChars, &
    & readNumFromBaseN, readNumsFromChars, readRomanNumerals, &
    & remap, replace, replaceNonAscii, reverse, reverse_trim, &
    & rot13, &
    & shiftlrc, size_trim, splitDetails, splitNest, splitWords, squeeze, &
    & startCase, streq, stretch, strings2Ints, &
    & trim_safe, trueList, unAsciify, unWrapLines, &
    & writeIntasBaseN, writeIntsToChars, writeRomanNumerals
d224 2
a225 2
  interface asciify
    module procedure asciify_scalar, asciify_1d, asciify_2d, asciify_3d
d228 2
a229 2
  interface readIntsFromChars
    module procedure readAnIntFromChars, readIntArrayFromChars
d232 2
a233 2
  interface readNumFromBaseN
    module procedure readFloatFromBaseN, readIntFromBaseN
d236 4
a239 4
  interface readNumsFromChars
    module procedure readADoubleFromChars, ReadDoubleArrayFromChars
    module procedure readARealFromChars, ReadRealArrayFromChars
    module procedure readAnIntFromChars, readIntArrayFromChars
d242 2
a243 2
  interface streq
    module procedure streq_scalar, streq_array1, streq_array2
d246 2
a247 2
  interface writeIntsToChars
    module procedure writeAnIntToChars, writeIntsToChars_1d, writeIntsToChars_2d
d446 3
a448 1
    countEmpty = ( index( Default( Options, StringOptions), 'e') > 0 )
d3238 1
a3238 1
       "$Id: MLSStrings.f90,v 2.103 2017/01/25 21:10:17 pwagner Exp $"
d3249 3
@


2.103
log
@str1 and str2 args to streq now optional
@
text
@d16 1
d102 2
a103 1
! CatStrings ( char* strings(:), char* sep, char* stringsCat, int L )
d169 1
d426 1
a426 1
    do i=1, len(str)
d436 1
a436 1
  subroutine CatStrings ( Strings, Sep, StringsCat, L )
d442 3
d446 2
d453 1
d455 1
d458 1
d467 1
a467 1
    ! 'a' or '0' or ' ' all return 0
d1044 1
a1044 1
    DO i = 1, LEN(str)
d3237 1
a3237 1
       "$Id: MLSStrings.f90,v 2.102 2016/12/08 00:15:41 pwagner Exp $"
d3248 3
@


2.102
log
@readNumsFromChars can now ignore non-numerical stuff
@
text
@d15 1
a15 1
  use MLSFinds, only: findFirst, findNext
d138 1
a138 1
! char* shiftLRC (char* str, [char* position], [char fillChar])
d146 6
a151 6
! log streq (char* str1, char* str2, [char* options])
! log streq (char* str1(:), char* str2, [char* options])
! log streq (char* str1, char* str2(:), [char* options])
! char* stretch (char* str, [char* options])
! strings2Ints (char* strs(:), int ints(:,:))
! char* trim_safe (char* str)
d154 2
a155 2
! unWrapLines (char* inLines(:), char* outLines(:), &
!              [int nout], [char escape], [char comment])
d257 6
d2159 1
a2159 1
  function streq_scalar (STR1, STR2, OPTIONS) result (relation)
d2179 7
a2185 4
    character (len=*), intent(in) :: STR1
    character (len=*), intent(in) :: STR2
    character (len=*), intent(in), optional  :: OPTIONS
    logical                       :: RELATION
d2199 3
a2201 3
    character(len=max(len(str1), len(str2))) :: str
    character(len=max(len(str1), len(str2))) :: ptrn  ! The one with '*'
    character(len=max(len(str1), len(str2))), dimension(MAXNUMWILDCARDS+1) :: substrs
d2206 7
d2891 2
d3226 1
a3226 1
       "$Id: MLSStrings.f90,v 2.101 2014/09/11 18:23:57 pwagner Exp $"
d3237 3
@


2.101
log
@Added isDigits
@
text
@d125 7
a131 5
! readNumFromBaseN (char* strs, real float, int N, [char* options])
! readIntFromBaseN (char* strs, int int, int N, [char* options])
! readIntsFromChars (char* strs[(:)], int ints[(:)], char* forbiddens)
! readNumsFromChars (char* strs[(:)], num num[(:)], char* forbiddens)
! readRomanNumerals (char* strs, int int)
d1341 1
a1341 1
  SUBROUTINE readIntArrayFromChars (strs, ints, forbiddens)
d1353 1
d1366 1
a1366 1
     call readAnIntFromChars(strs(i), ints(i), forbiddens)
d1385 1
a1385 1
  SUBROUTINE ReadRealArrayFromChars (strs, nums, forbiddens)
d1389 1
d1402 1
a1402 1
     call readARealFromChars(strs(i), nums(i), forbiddens)
d1407 1
a1407 1
  SUBROUTINE ReadDoubleArrayFromChars (strs, nums, forbiddens)
d1409 1
a1409 1
    double precision, intent(out), dimension(:)             ::   nums
d1411 1
d1424 1
a1424 1
     call readADoubleFromChars(strs(i), nums(i), forbiddens)
d3208 1
a3208 1
       "$Id: MLSStrings.f90,v 2.100 2014/09/05 00:12:11 vsnyder Exp $"
d3219 3
@


2.100
log
@Convert pointer temp to explicit shape.
@
text
@d57 1
d115 1
d207 2
a208 1
    & indexes, ints2Strings, isAllAscii, isAlphabet, isComment, isRepeat, &
d3026 17
d3203 1
a3203 1
       "$Id: MLSStrings.f90,v 2.99 2014/07/25 21:42:37 pwagner Exp $"
d3214 3
@


2.99
log
@Fixed bugs in readIntFromBaseN; now generic as readNumFromBaseN; added remap
@
text
@d2787 1
a2787 1
    integer, dimension(:), pointer          :: C => null()
a2791 1
    integer                                 :: status
a2802 1
    allocate( C(0:m), stat=status )
d2820 2
a2821 2
      enddo
    endif
d2830 1
a2830 1
      enddo
d2833 1
a2833 1
    elseif ( index(myOptions, 'x') > 0 ) then
d2837 1
a2837 1
      enddo
d2846 1
a2846 1
      enddo
d2848 1
a2848 2
    endif
    deallocate( C, stat=status )
d3183 1
a3183 1
       "$Id: MLSStrings.f90,v 2.98 2014/02/21 01:24:54 pwagner Exp $"
d3194 3
@


2.98
log
@Added CharToInt; made SplitWords elemental
@
text
@d15 1
a15 1
  use MLSFINDS, only: FINDFIRST, FINDNEXT
d66 1
d72 1
d123 1
d128 2
a129 1
! char* Replace (char* str, char oldChar, char newChar, [int max])
d131 2
a132 2
! char* Reverse (char* str)
! char* Reverse_trim (char* str)
d202 14
a215 14
  public :: ASCIIFY, &
    & CAPITALIZE, CATSTRINGS, CHARTOINT, COMPRESSSTRING, COUNT_WORDS, &
    & DELETE, DEPUNCTUATE, FLUSHARRAYLEFT, HHMMSS_VALUE, &
    & INDEXES, INTS2STRINGS, ISALLASCII, ISALPHABET, ISCOMMENT, ISREPEAT, &
    & LENTRIMTOASCII, LINEARSEARCHSTRINGARRAY, LOWERCASE, &
    & NAPPEARANCES, NCOPIES, &
    & READCOMPLETELINEWITHOUTCOMMENTS, READINTFROMBASEN, READINTSFROMCHARS, &
    & READNUMSFROMCHARS, READROMANNUMERALS, &
    & REPLACE, REPLACENONASCII, REVERSE, REVERSE_TRIM, &
    & ROT13, &
    & SHIFTLRC, SIZE_TRIM, SPLITDETAILS, SPLITNEST, SPLITWORDS, SQUEEZE, &
    & STARTCASE, STREQ, STRETCH, STRINGS2INTS, &
    & TRIM_SAFE, TRUELIST, UNASCIIFY, UNWRAPLINES, &
    & WRITEINTASBASEN, WRITEINTSTOCHARS, WRITEROMANNUMERALS
d225 4
d1218 2
a1219 2
  ! ----------------  readIntFromBaseN  -----
  ! read an integer which had been reexpressed in base n from a string
d1222 1
a1222 1
  ! Return e.g. the number 1989 in base 5 from str='30424'
d1224 32
d1257 1
a1257 1
    ! returns an integer and from a string
a1258 19

    ! According to the options string, the intermediate integer coefficients
    ! will be based on
    !  options contain            coefficient string
    !    ---                      ------------------
    !   (default)                 decimal integers, separated by spaces
    !                              e.g., ''13 4 29 6''
    !      a                      achar(c[m]) in the same order
    !                              e.g., CR // EOT // GS // ACR   
    !      A                      like a but converted to ascii
    !                              e.g., '<CR>' // '<EOT>' // '<GS>' // <ACR>   
    !      x                      "Extended" hexadecimal
    ! 0123456789012345678901234567890123456789012345678901234567890123456789
    ! 0123456789abcdefghijklmnopqrstuvwxyz;'[]ABCDEFGHIJKLMNOPQRSTUVWXYZ:"{}
    !                              (good only up to base 70)
    !
    ! The default representation can handle arbitrarily large moduli
    ! a or A is limited to the unique range of achar
    ! x is good only up to a modulus of 70.
d1260 3
a1262 3
    ! Note that we do not check that the str is a valid number in base N
    ! E.g., you can enter '10 0 1' in base 5 and get back a numerical
    ! result of 251 instead of an error message
d1269 1
a1269 47
    ! Internal variables
    integer, dimension(:), pointer          :: C => null()
    integer                                 :: i
    integer                                 :: i1
    integer                                 :: i2
    integer                                 :: j
    integer                                 :: m
    character(len=8)                        :: myOptions
    integer                                 :: status
    character(len=8)                        :: substr
    character(len=1)                        :: subsub
    character(len=*), parameter             :: xtended = &
      & '0123456789abcdefghijklmnopqrstuvwxyz;''[]ABCDEFGHIJKLMNOPQRSTUVWXYZ:"{}'
    ! Executable
    k = 0
    if ( N < 2 .or. len_trim(str) < 1 ) return
    myOptions = ' '
    if ( present(options) ) myOptions = options
    ! First we must obtain m
    m = ncopies( trim(str), ' ' )
    allocate( C(0:m), stat=status )
    i2 = 1
    do j=m, 0, -1
      i1 = i2
      i2 = FindNext( str, ' ', i1 )
      substr = str(i1:i2)
      i1 = i2
      ! Read each substr as an integer
      if ( index(myOptions, 'a') > 0 .or. index(myOptions, 'A') > 0 ) then
        ! We won't bother coding this case--it would be ridiculous anyway
        stop
      elseif ( index(myOptions, 'x') > 0 ) then
        ! 'Extended' hexadecimal
        subsub = adjustl(substr)
        C(j) = FindFirst( (/ (xtended(i:i), i=1, len(xtended)) /) == subsub )
        C(j) = max(0, C(j) - 1)
      else
        ! Plain vanilla decimal integers
        call readIntsFromChars( substr, C(j) )
      endif
    enddo
    ! call dump(C, 'coefficients')
    k = 0
    do j=m, 0, -1
      k = N*k + C(j)
    enddo
    deallocate( C, stat=status )
d1272 12
d1472 34
d3026 2
a3027 2
  ! ---------------------------------------------------  lastchar  -----
  character function lastchar(str)
d3035 1
a3035 1
  end function lastchar
d3186 1
a3186 1
       "$Id: MLSStrings.f90,v 2.97 2014/02/12 23:59:34 pwagner Exp $"
d3197 3
@


2.97
log
@isAlphabet now public
@
text
@d40 2
d99 1
d199 1
a199 1
    & CAPITALIZE, CATSTRINGS, COMPRESSSTRING, COUNT_WORDS, &
d432 17
d1893 1
a1893 1
  SUBROUTINE SplitWords(line,first,rest,last,&
d3165 1
a3165 1
       "$Id: MLSStrings.f90,v 2.96 2013/08/12 23:47:25 pwagner Exp $"
d3176 3
@


2.96
log
@FindSomethings moved to MLSFinds module
@
text
@d52 1
d106 1
d198 1
a198 1
    & INDEXES, INTS2STRINGS, ISALLASCII, ISCOMMENT, ISREPEAT, &
d2892 1
a2892 1
  function isAlphabet(arg, inputcase) result(itIs)
d3145 1
a3145 1
       "$Id: MLSStrings.f90,v 2.95 2013/08/09 00:43:06 pwagner Exp $"
d3156 3
@


2.95
log
@Added count_quotes and unasciify
@
text
@d15 1
a15 1

a3118 41
  ! -------------------------------------------  FindFirst  -----
  ! We were forced to put a redundant copy here to avoid circular make dependence
  ! that resulted when this module used MLSSets
  integer function FindFirst ( condition )
    ! Find the first logical in the array that is true
    logical, dimension(:), intent(in) :: CONDITION

    ! Executable code
    do FindFirst = 1, size(condition)
      if ( condition(FindFirst) ) return
    end do
    FindFirst = 0
  end function FindFirst

  ! -------------------------------------------  FindNext  -----
  ! We were forced to put a redundant copy here to avoid circular make dependence
  ! that resulted when this module used MLSSets
  integer function FindNext ( Set, Probe, Current )
    ! Find the next substring in the string Set that is equal to Probe after the
    ! current one
    character(len=*), intent(in) :: Set
    character(len=1), intent(in) :: Probe
    integer, intent(in) :: Current
    ! Local variables
    integer :: i

     ! Executable code
    FindNext = 0
    if ( current < 1 .or. current > len(set)) return
    ! Now check for current already at end of array
    if ( current < len(set) ) then
      do i = current+1, len(set)
        if ( set(i:i) == probe ) then
          FindNext = i
          return
        end if
      end do
    end if
    ! Uh-oh, this means current is last true, or at array end--so we return 0
  end function FindNext

d3143 1
a3143 1
       "$Id: MLSStrings.f90,v 2.94 2013/07/30 23:26:44 pwagner Exp $"
d3154 3
@


2.94
log
@New procedures to read/write base N integers
@
text
@d37 1
a37 1
!                      (no binary) (see also ReplaceNonAscii)
d42 1
d84 2
d97 1
d140 1
d205 1
a205 1
    & TRIM_SAFE, TRUELIST, UNWRAPLINES, &
d241 2
a242 1
  logical, private, save          :: ignoreLeadingSpaces 
d297 1
a297 1
  ! (see also ReplaceNonAscii)
d452 38
d2455 74
d2994 24
d3019 3
a3021 2
  function octalCode(arg) result(theCode)
    character(len=1), intent(in) :: arg
d3024 1
d3026 14
a3039 2
    write(nnn,'(o3.3)') iachar(arg)
    theCode = '<' // nnn // '>'
d3043 3
a3045 2
  function decimalCode(arg) result(theCode)
    character(len=1), intent(in) :: arg
d3048 1
d3050 14
a3063 2
    write(n,'(i3)') iachar(arg)
    theCode = '<' // trim(adjustl(n)) // '>'
d3067 3
a3069 2
  function mnemonicCode(arg) result(theCode)
    character(len=1), intent(in) :: arg
d3073 18
a3090 6
    theCode = arg
    if ( isAscii(arg) ) return
    icode = iachar(arg) + 1
    icode = min(icode, size(MNEMONICCODES))
    
    theCode = '<' // trim( MNEMONICCODES(icode) ) // '>'
d3184 1
a3184 1
       "$Id: MLSStrings.f90,v 2.93 2013/07/24 19:02:43 pwagner Exp $"
d3195 3
@


2.93
log
@Added isComment function; streq adds new option 'h' to match string heads
@
text
@d62 1
d84 1
d112 1
d138 1
d188 14
a201 13
  public :: asciify, &
    & Capitalize, CatStrings, CompressString, count_words, &
    & delete, depunctuate, FlushArrayLeft, hhmmss_value, &
    & indexes, ints2Strings, isAllAscii, IsComment, IsRepeat, &
    & LenTrimToAscii, LinearSearchStringArray, LowerCase, &
    & NAppearances, NCopies, &
    & ReadCompleteLineWithoutComments, readNumsFromChars, readIntsFromChars, &
    & ReadRomanNumerals, Replace, ReplaceNonAscii, Reverse, Reverse_trim, &
    & Rot13, &
    & shiftLRC, size_trim, SplitDetails, SplitNest, SplitWords, squeeze, &
    & StartCase, streq, stretch, strings2Ints, &
    & trim_safe, TrueList, unWrapLines, &
    & writeIntsToChars, writeRomanNumerals
d1144 87
d2562 2
a2563 2
  ! ----------------  writeRomanNumerals  -----
  ! write an integer as a string composed of roman numerals
d2566 127
a2692 1
  ! Given e.g. the number 1989 return str='MCMLXXXIX '
d2950 27
d3001 1
a3001 1
       "$Id: MLSStrings.f90,v 2.92 2013/06/28 23:56:47 pwagner Exp $"
d3012 3
@


2.92
log
@Fixed an old bug in SplitDetails
@
text
@d52 1
d100 1
d146 1
d187 1
a187 1
    & indexes, ints2Strings, isAllAscii, IsAscii, IsRepeat, &
d1968 5
a1972 4
    ! (1) Wildcard * (off by default) which allows 'a*' to equal 'abcd'
    ! (2) case insensitive (off by default) which allows 'ABCD' to equal 'abcd'
    ! (3) flush left (off by default) which allows 'abcd' to equal '  abcd'
    ! (4) reverse sense ("Are two strings unequal?")
d2006 1
d2014 1
d2044 18
a2061 1
    if ( .not. wildcard ) then
d2618 17
d2756 1
a2756 1
       "$Id: MLSStrings.f90,v 2.91 2013/06/17 21:35:26 pwagner Exp $"
d2767 3
@


2.91
log
@You may specify better where stretch adds space
@
text
@d1611 2
a1612 1
  ! we succeeded in resisting temptation)
d1619 3
a1621 1
    character(len=*), parameter :: digits='1234567890'
d1623 1
d1636 12
a1647 2
      switch = str(:firstDigitPosition-1)
      call readAnIntFromChars ( str(firstDigitPosition:), details )
d2716 1
a2716 1
       "$Id: MLSStrings.f90,v 2.90 2013/06/14 03:02:37 vsnyder Exp $"
d2727 3
@


2.90
log
@Simplify ReplaceNonAscii
@
text
@d2125 1
d2137 1
d2141 9
d2155 1
a2155 1
    cpos = len_trim(str)
d2163 16
d2702 1
a2702 1
       "$Id: MLSStrings.f90,v 2.89 2013/06/13 00:39:21 pwagner Exp $"
d2713 3
@


2.89
log
@Removed two unused params
@
text
@d1371 1
a1371 1
    integer :: i, n
d1374 1
a1374 3
    if ( len(str) < 1 ) return
    n = len(str)
    do i=1, n
d2675 1
a2675 1
       "$Id: MLSStrings.f90,v 2.88 2012/12/04 00:11:55 pwagner Exp $"
d2686 3
@


2.88
log
@Improved comments
@
text
@a2531 2
    integer, parameter :: pcMin = iachar(' ')
    integer, parameter :: pcMax = iachar('~')
d2677 1
a2677 1
       "$Id: MLSStrings.f90,v 2.87 2012/09/05 21:43:55 pwagner Exp $"
d2688 3
@


2.87
log
@streq options now case sensitive; 'P'artial match means str1(i) is the part
@
text
@d2259 2
a2260 2
  ! ie.e, a special escape character at line's end to denote a continuation
  ! tio the following line
d2679 1
a2679 1
       "$Id: MLSStrings.f90,v 2.86 2012/08/07 18:02:37 pwagner Exp $"
d2690 3
@


2.86
log
@ReplaceNonAscii now takes optional arg exceptions which dont get replaced
@
text
@d1882 2
a1883 1
    ! 'p' is partial match (STR2 is replaced by '*' // STR2 // '*'
d1896 1
d1900 1
a1900 1
    if ( present(options) ) myOptions = lowercase(options)
d1904 6
a1909 1
      relation(i) = streq(str1(i), mystr2, OPTIONS)
d2679 1
a2679 1
       "$Id: MLSStrings.f90,v 2.85 2012/07/10 15:15:33 pwagner Exp $"
d2690 3
@


2.85
log
@Added SplitDetails
@
text
@d37 1
a37 1
!                      (no binary)
d65 1
a65 1
! ReplaceNonAscii    Replaces every non-ascii char with newChar
d87 1
a87 1
! char* asciify (char* str)
d112 1
a112 1
! char* ReplaceNonAscii (char* str, char newChar)
a818 2
    ! for our purposes, words consist of any non-space characters
    ! and are separated by one or more spaces
d1356 1
a1356 1
  function ReplaceNonAscii (str, newchar) RESULT (outstr)
d1363 2
d1366 4
a1369 3
    character(len=*), intent(in) :: str
    character(len=1), intent(in) :: newChar
    character(len=len(str))      :: outstr
d1377 3
d2672 1
a2672 1
       "$Id: MLSStrings.f90,v 2.84 2012/05/01 22:10:26 vsnyder Exp $"
d2683 3
@


2.84
log
@Add TrueList subroutine
@
text
@d70 1
d118 1
d190 2
a191 2
    & shiftLRC, size_trim, SplitNest, SplitWords, squeeze, StartCase, streq, &
    & stretch, strings2Ints, &
d1596 39
d2548 1
a2548 1
  function isDigit(arg) result(itIs)
d2668 1
a2668 1
       "$Id: MLSStrings.f90,v 2.83 2011/06/23 17:25:50 pwagner Exp $"
d2679 3
@


2.83
log
@Added ability to read, write Roman numerals
@
text
@d79 1
d128 1
d190 1
a190 1
    & trim_safe, unWrapLines, &
d2156 31
d2627 1
a2627 1
       "$Id: MLSStrings.f90,v 2.82 2011/06/16 00:14:51 pwagner Exp $"
d2638 3
@


2.82
log
@Added new procedures to unwrap commands and Start Case strings
@
text
@d63 1
d79 1
a79 1
! unWrapLines       undo the splitting of commands across multiple lines
d81 1
d108 1
d130 1
d184 2
a185 1
    & Replace, ReplaceNonAscii, Reverse, Reverse_trim, Rot13, &
d189 1
a189 1
    & writeIntsToChars
d1271 51
d2323 62
d2594 1
a2594 1
       "$Id: MLSStrings.f90,v 2.81 2011/02/18 17:58:10 pwagner Exp $"
d2605 3
@


2.81
log
@Replace, Delete no take an optional arg; added shiftLRC
@
text
@d72 1
d78 1
d117 1
d124 2
d173 12
a184 10
  public :: asciify, Capitalize, CatStrings, CompressString, count_words, &
   & delete, depunctuate, FlushArrayLeft, hhmmss_value, &
   & indexes, ints2Strings, isAllAscii, IsAscii, IsRepeat, &
   & LenTrimToAscii, LinearSearchStringArray, LowerCase, NAppearances, NCopies, &
   & ReadCompleteLineWithoutComments, readNumsFromChars, readIntsFromChars, &
   & Replace, ReplaceNonAscii, Reverse, Reverse_trim, Rot13, &
   & shiftLRC, size_trim, SplitNest, SplitWords, squeeze, streq, &
   & stretch, strings2Ints, &
   & trim_safe, &
   & writeIntsToChars
d1750 24
d2116 62
a2186 1
    ! Not useful yet
d2476 1
a2476 1
       "$Id: MLSStrings.f90,v 2.80 2011/02/05 01:34:23 pwagner Exp $"
d2487 3
@


2.80
log
@Added Delete function
@
text
@d40 1
d86 1
a86 1
! char* delete (char* str, char ch)
d93 1
a93 1
! log IsRepeat ( char* str, [char* ssubtring] )
d104 1
a104 1
! char* Replace (char* str, char oldChar, char newChar)
d109 1
d174 2
a175 1
   & size_trim, SplitNest, SplitWords, squeeze, streq, stretch, strings2Ints, &
d265 1
a265 1
  ! Note that these last 3 options may output a longer string than the input
d448 1
a448 1
  Function Delete ( str, ch ) result ( outstr )
d453 1
d457 2
d462 3
d468 6
a473 4
      if ( str(i:i) /= ch ) then
        iout = iout + 1
        outstr(iout:iout) = str(i:i)
      end if
d1260 1
a1260 1
  function Replace (str, oldChar, newchar) RESULT (outstr)
d1264 5
a1268 4
    character(len=*), intent(in) :: str
    character(len=1), intent(in) :: oldChar
    character(len=1), intent(in) :: newChar
    character(len=len(str))      :: outstr
d1271 2
d1277 2
d1280 1
d1282 5
a1286 1
      if ( str(i:i) == oldChar ) outstr(i:i) = newChar
d1356 2
a1357 2
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=max(LEN_TRIM(str), 1)) :: outstr
d1360 2
a1361 2
    INTEGER :: i, istr, irev
    CHARACTER (LEN=1) :: strChar
d1454 58
d2384 1
a2384 1
       "$Id: MLSStrings.f90,v 2.79 2010/09/24 23:45:45 pwagner Exp $"
d2395 3
@


2.79
log
@Removed dependence on MLSCommon by substituting double for r8
@
text
@d42 1
d85 1
d167 1
a167 1
   & depunctuate, FlushArrayLeft, hhmmss_value, &
d444 23
d2305 1
a2305 1
       "$Id: MLSStrings.f90,v 2.78 2010/06/23 20:42:21 honghanh Exp $"
d2316 3
@


2.78
log
@Change readAnIntFromChars to only read the first number in the string
if there are many numbers separated by ignored characters.
Update comment of the method.
@
text
@a505 1
    use MLSCommon, only: R8
d539 1
a539 1
    real(r8) :: value
d557 1
a557 1
    value = 0.0_r8
d2280 1
a2280 1
       "$Id: MLSStrings.f90,v 2.77 2010/02/04 23:08:00 vsnyder Exp $"
d2291 5
@


2.77
log
@Remove USE or declaration for unused names
@
text
@d1108 2
a1109 1
    ! Then snip away any from the set ignore if present
d1112 5
a1116 1
    ! plus any other chars among ignore
d1118 2
d1127 1
d2281 1
a2281 1
       "$Id: MLSStrings.f90,v 2.76 2009/06/23 18:25:42 pwagner Exp $"
d2292 3
@


2.76
log
@Prevent Intel from optimizing ident string away
@
text
@d21 1
a21 1
       "$RCSfile: $"
a618 1
    character(len=len(str)) :: substr
d624 4
a627 4
    ! first         always find first occurrence of substr(i) in str
    ! last          always find last occurrence of substr(i) in str
    ! left          progressively find next substr(i) after substr(i-1)
    ! right         progressively find next substr(i) before substr(i-1)
d675 1
a675 1
       lpos = left(i) + max(len_trim(substrings(i)), 1) ! len(trim_safe(substr(i)))
a905 1
    character(len=len(str)) :: substr
a2072 1
    integer :: sepIndex
d2273 1
a2273 1
       "$Id: read_apriori.f90 is it here $"
d2284 3
@


2.75
log
@Added ReadNumsFromChars, squeeze, stretch functions
@
text
@d21 1
a21 1
       "$RCSfile: MLSStrings.f90,v $"
d2273 1
a2274 1
!---------------------------- RCS Ident Info -------------------------------
d2276 2
a2277 3
       "$Id: MLSStrings.f90,v 2.74 2008/06/04 21:44:43 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2279 1
d2281 1
d2287 3
@


2.74
log
@Added lenTrimToAscii and ReplaceNonAscii
@
text
@d59 2
a60 1
! ReadIntsFromChars  Converts an array of strings to ints using Fortran read
d69 1
d72 1
d99 2
a100 1
! readIntsFromChars (char* strs(:), int ints(:), char* forbiddens)
d110 1
d114 1
d168 1
a168 1
   & ReadCompleteLineWithoutComments, readIntsFromChars, &
d170 2
a171 1
   & size_trim, SplitNest, SplitWords, streq, strings2Ints, trim_safe, &
d182 6
d1089 14
a1102 2
  ! --------------------------------------------------  readAnIntFromChars  -----
  subroutine readAnIntFromChars (str, int, forbiddens, ignore)
d1129 2
a1130 70
    integer, intent(out)          ::   int
    CHARACTER (LEN=*), INTENT(in), optional     ::   forbiddens
    CHARACTER (LEN=*), INTENT(in), optional     ::   ignore

    !----------Local vars----------!
    INTEGER :: j, k, status
    LOGICAL :: leave_undef
    character(len=40)                           ::   myForbiddens
    character(len=40)                           ::   myIgnore
    character(len=len(str))                     ::   myStr
    !----------Executable part----------!
   status = 0
   ! Check that all is well (if not returns STRINGCONTAINSFORBIDDENS)
   int = STRINGCONTAINSFORBIDDENS
   if ( present(forbiddens) ) then
     myForbiddens = adjustl(forbiddens)
   else
     myForbiddens = ' '
   endif
   if ( present(ignore) ) then
     myignore = adjustl(ignore)
   else
     myignore = ' '
   endif
   leave_undef = (str == ' ')
   if ( myForbiddens /= ' ' ) then
     do j=1, len(trim(myForbiddens))
        leave_undef = leave_undef &
         & .or. &
         & ( &
         &    index(str, myForbiddens(j:j)) > 0 &
         &  .and. &
         &    myForbiddens(j:j) /= ' ' &
         & )
     enddo
   endif
   if ( leave_undef ) then
     return
   elseif (  myIgnore == "" ) then
     read( str, *, iostat=status, err=100 ) int
     if ( status /= 0 ) int = STRINGCONTAINSFORBIDDENS
   ! elseif (  myIgnore == "*" ) then
   elseif (  index(myIgnore, "*") /= 0 ) then
     int = 0  ! a str made up entirely of ignorables means "0"
     k = 1
     myStr = ""
     do j = 1, len(str)
       if ( .not. isAlphabet(str(j:j)) .and. &
         & index(myIgnore, str(j:j)) < 1 ) then
         myStr(k:k) = str(j:j)
         k = k + 1
       endif
     enddo
     if ( myStr /= "" ) read( mystr, *, iostat=status, err=100 ) int
   else
     int = 0  ! a str made up entirely of ignorables means "0"
     k = 1
     myStr = ""
     do j = 1, len(str)
       if ( index(myIgnore, str(j:j)) < 1 ) then
         myStr(k:k) = str(j:j)
         k = k + 1
       endif
     enddo
     if ( myStr /= "" ) read( mystr, *, iostat=status, err=100 ) int
   endif
   if ( status /= 0 ) int = STRINGCONTAINSFORBIDDENS
   return
100   int = STRINGCONTAINSFORBIDDENS

a1132 1
  ! --------------------------------------------------  readIntArrayFromChars  -----
d1147 1
a1147 2
    INTEGER :: i, j, arrSize
    LOGICAL :: leave_undef
d1162 56
d1570 63
d1868 60
d2276 1
a2276 1
       "$Id: MLSStrings.f90,v 2.73 2008/05/09 00:22:37 pwagner Exp $"
d2286 3
@


2.73
log
@Nappearances has new optional arg to not trim substrings
@
text
@d51 1
d61 1
d78 1
a84 2
! int LinearSearchStringArray (char* list(:), char* string, 
!   [log caseInsensitive, [log testSubstring], [log listInString])
d88 3
a93 1
! readIntsFromChars (char* strs(:), int ints(:), char* forbiddens)
d96 1
d98 1
d161 1
a161 1
   & LinearSearchStringArray, LowerCase, NAppearances, NCopies, &
d163 1
a163 1
   & Replace, Reverse, Reverse_trim, Rot13, &
d233 17
a250 15
    ! takes input string and replaces any non-printing characters
    ! with ones in range [32,126]
    ! leaving other chars alone
    !
    ! How the replacement is done is according to the optional arg
    !    how         meaning
    !    ---         -------
    !  'shift'       shift to the character with matching modulus (default)
    !                  (a poor choice for default, in my opinion)
    !  'snip'        remove the offending character (shortening the string)
    !  'decimal'     return <nnn> where nnn is the decimal value (e.g. 0)
    !  'octal'       return <nnn> where nnn is the octal value (e.g. 000)
    !  'mnemonic'    return <ID> where ID is the mnemonic code (e.g. NUL)
    !  '*'           replace with whatever character how was (e.g., '*')
    ! Note that these last 3 options may output a longer string than the input
d753 17
d1228 23
d2142 1
a2142 1
       "$Id: MLSStrings.f90,v 2.72 2008/02/07 18:46:55 pwagner Exp $"
d2152 3
@


2.72
log
@isAllAscii, isAscii now public; asciify generic
@
text
@d623 1
d865 1
a865 1
  function NAppearances(str, substrings) result(array)
d868 1
d878 3
d883 1
a883 3
    !
    ! Method:
    ! Use indexes function to find successive indexes of a single substring
d888 1
d890 2
d895 5
a899 1
      tmpArray = indexes(str, tmpSubs, 'left')
d2095 1
a2095 1
       "$Id: MLSStrings.f90,v 2.71 2007/09/13 21:06:25 pwagner Exp $"
d2105 3
@


2.71
log
@Added 2-d array interface for writeIntsToChars
@
text
@d48 2
d84 2
d155 1
a155 1
   & indexes, ints2Strings, IsRepeat, &
d162 4
d228 1
a228 1
  function ASCIIFY (STR, HOW) result (OUTSTR)
d297 32
a328 1
  end function ASCIIFY
d1931 18
d2085 1
a2085 1
       "$Id: MLSStrings.f90,v 2.70 2007/08/29 19:52:18 pwagner Exp $"
d2095 3
@


2.70
log
@Added asciify function
@
text
@d167 1
a167 1
    module procedure writeAnIntToChars, writeIntArrayToChars
d1747 7
a1754 6
    ! takes an integer and returns a string
    ! using Fortran "write"
    ! Unless integer is one of specialInts, in which case
    ! we return corresponding one of specialChars
    ! (So that we can treat -1 as "unlimited' or -999 as 'FillValue')
    ! We'll just assume both special arrays are of same size
a1756 2
    !--------Argument--------!
    !    dimensions are (len(strs(1)), size(strs(:)))
d1786 1
a1786 2
  ! --------------------------------------------------  writeIntArrayToChars  -----
  SUBROUTINE writeIntArrayToChars (ints, strs, fmt, specialInts, specialChars)
a1787 5
    ! using Fortran "write"
    ! Not useful yet
    !
    !--------Argument--------!
    !    dimensions are (len(strs(1)), size(strs(:)))
d1795 1
a1795 2
    integer :: i, j, arrSize
    logical :: leave_undef
d1808 27
a1834 1
  END SUBROUTINE writeIntArrayToChars
d2028 1
a2028 1
       "$Id: MLSStrings.f90,v 2.69 2007/07/31 22:46:08 pwagner Exp $"
d2038 3
@


2.69
log
@undefined status now defined in readAnIntFromChars ;'n' option added to streq
@
text
@d36 2
d72 1
d149 1
a149 1
  public :: Capitalize, CatStrings, CompressString, count_words, &
d182 34
d219 72
a1471 1
    use MLSSets, only: findFirst
d1874 15
d1912 74
d2010 1
a2010 1
       "$Id: MLSStrings.f90,v 2.68 2007/07/25 21:58:16 vsnyder Exp $"
d2020 3
@


2.68
log
@Replace tabs by spaces because tabs are not standard
@
text
@d32 3
d109 1
d114 2
a115 2
! The above is to replace the countEmpty, caseSensitive, etc. that are
! separate optional args to many of the current module procedures
d167 3
d176 3
d933 1
a933 1

d1428 1
d1432 2
a1433 1
    ! string containing: 'w' => turns on (1); 'c' => turns on (2); 'f' => (3)
d1456 1
d1471 1
d1486 1
a1486 1
      return
d1489 1
a1489 1
      return
d1492 1
a1492 1
      return
d1495 1
a1495 1
      return
d1511 1
a1511 1
      return
d1526 1
a1526 1
      return
d1529 1
a1529 1
      return
d1567 1
a1567 1
        return
d1576 1
a1576 1
        return
d1581 1
a1581 1
    if ( nstars < 2 ) return
d1586 2
d1711 20
d1813 1
a1813 1
       "$Id: MLSStrings.f90,v 2.67 2007/07/18 00:06:46 pwagner Exp $"
d1823 3
@


2.67
log
@Added Rot13 function
@
text
@d532 3
a534 3
	 ! Useful due to bug in toolbox swrfld
	 !
	 ! See also strings2Ints
d909 1
a909 1
	 !
d990 2
a991 2
	 ! Not useful yet
	 !
d1019 1
a1019 1
	 ! arg = Replace( arg, char(0), char(32) )
a1035 1
	 !
d1039 5
a1043 5
	 ! Useful in certain contexts:
	 ! e.g., to remove leading blanks
	 ! arg = Reverse(TRIM(Reverse(arg)))
	 !
	 ! See also Reverse_trim, ReverseList
d1050 1
a1050 1
	 CHARACTER (LEN=1) :: strChar
d1056 2
a1057 2
       istr = 1 + (i-1)/2				! 1, 2, ..
       irev = LEN(str) - (i-1)/2		! N, N-1, ..
d1059 2
a1060 2
		 outstr(istr:istr) = str(irev:irev)
		 outstr(irev:irev) = strChar
d1065 1
a1065 1
       istr = 1 + (LEN(str)-1)/2				! 1, 2, ..
d1067 1
a1067 1
	ENDIF
d1074 1
a1074 1
	 ! See also Reverse which omits the trim step
d1084 1
a1084 1
	 CHARACTER (LEN=1) :: strChar
d1090 2
a1091 2
       istr = 1 + (i-1)/2				! 1, 2, ..
       irev = LEN_TRIM(str) - (i-1)/2		! N, N-1, ..
d1093 2
a1094 2
		 outstr(istr:istr) = str(irev:irev)
		 outstr(irev:irev) = strChar
d1099 1
a1099 1
       istr = 1 + (LEN_TRIM(str)-1)/2				! 1, 2, ..
d1101 1
a1101 1
	ENDIF
d1128 1
a1128 1
	 logical :: inv
d1172 1
a1172 1
		 outstr(i:i) = achar(oprime)
d1578 3
a1580 3
	 ! Useful due to bug in toolbox swrfld
	 !
	 ! See also ints2Strings
d1629 3
a1631 3
	 ! We'll just assume both special arrays are of same size
	 ! Not useful yet
	 !
d1667 2
a1668 2
	 ! Not useful yet
	 !
d1777 1
a1777 1
       "$Id: MLSStrings.f90,v 2.66 2007/05/22 20:57:18 vsnyder Exp $"
d1787 3
@


2.66
log
@Don't use the length of one automatic variable to specify the length of
another one: Intel ifort 10.0.023 crashes at run time on this.
Don't use list-directed output to internal files.
@
text
@d55 1
d86 1
d147 1
a147 1
   & Replace, Reverse, Reverse_trim, &
d1106 72
d1778 1
a1778 1
       "$Id: MLSStrings.f90,v 2.65 2007/04/26 20:32:15 pwagner Exp $"
d1788 5
@


2.65
log
@Coded around bug in Intel compiler causing streq to bomb
@
text
@d1372 4
a1375 6
    ! Intel compiler has been crashing here
    integer, parameter :: strLengthMax = 64
    ! character(len=max(len(str1), len(str2))) :: str
    character(len=strLengthMax) :: str
    character(len=len(str)) :: ptrn  ! The one with '*'
    character(len=len(str)), dimension(MAXNUMWILDCARDS+1) :: substrs
d1569 1
d1583 3
a1585 2
   else
     write(str, *) int
d1704 1
a1704 1
       "$Id: MLSStrings.f90,v 2.64 2007/01/03 20:40:25 pwagner Exp $"
d1714 3
@


2.64
log
@Added NAppearances
@
text
@d38 1
d55 1
d70 1
d77 1
d85 1
a92 1
! int(:) NAppearances (char* string, char* substrings)
d141 1
a141 1
   & depunctuate, hhmmss_value, &
d146 1
a146 1
   & SplitNest, SplitWords, streq, strings2Ints, trim_safe, &
d163 2
a261 3
  ! This one converts a string to all upper case (taken from HCP routine
  ! of same name) (Except that HCP can spell capitalise, that is. Fnord.)

d286 38
d883 1
a883 1
  SUBROUTINE readAnIntFromChars (str, int, forbiddens, ignore)
d887 1
a887 1
    ! subroutine exists, to filter out invalid characters)
d889 1
a889 1
    ! the int is left undefined
d898 1
d915 1
a915 1
    INTEGER :: j, k
d922 2
a923 1
   ! Check that all is well (if not returns blanks)
d949 2
a950 1
     read(str, *) int
d963 1
a963 1
     if ( myStr /= "" ) read(mystr, *) int
d974 1
a974 1
     if ( myStr /= "" ) read(mystr, *) int
d976 3
d980 1
a980 1
  END SUBROUTINE readAnIntFromChars
d1104 17
d1372 4
a1375 1
    character(len=max(len(str1), len(str2))) :: str
d1438 1
a1438 1
    ! if ( deebug ) print *, 'str: ', trim(str), '  ptrn: ', trim(ptrn)
d1449 1
a1449 1
    ! if ( deebug ) print *, 'num of * ', nstars
d1453 1
a1453 1
    ! if ( deebug ) print *, 'where? ', istars(1:nstars)
d1462 5
a1466 5
!     if ( deebug ) then
!       do i=1, nstars+1
!         print *, trim(substrs(i))
!       enddo
!     endif
d1468 1
d1470 1
d1472 8
d1485 1
a1485 1
    ! if ( deebug ) print *, 'passed 1st sub-test'
d1495 1
a1495 1
    ! if ( deebug ) print *, 'passed 2nd sub-test'
d1704 1
a1704 1
       "$Id: MLSStrings.f90,v 2.63 2006/10/05 23:34:13 pwagner Exp $"
d1714 3
@


2.63
log
@Fixed bug in streq making identity comparisons
@
text
@d46 1
d88 1
d126 2
a127 1
! ncopies                   trim_safe
d139 1
a139 1
   & LinearSearchStringArray, LowerCase, NCopies, &
d421 1
d662 31
d1627 1
a1627 1
       "$Id: MLSStrings.f90,v 2.62 2006/05/09 00:14:23 pwagner Exp $"
d1637 3
@


2.62
log
@Added Replace; useful to replace null chars with blanks
@
text
@d1314 1
a1314 1
          relation = (adjustl(lowercase(str1)) == adjustl(lowercase(str1)))
d1316 1
a1316 1
          relation = (lowercase(str1) == lowercase(str1))
d1320 1
a1320 1
          relation = (adjustl(str1) == adjustl(str1))
d1592 1
a1592 1
       "$Id: MLSStrings.f90,v 2.61 2006/02/24 01:14:02 pwagner Exp $"
d1602 3
@


2.61
log
@Added SplitNest (is this the best name)
@
text
@d50 1
d77 1
d138 1
a138 1
   & Reverse, Reverse_trim, &
d931 22
d1592 1
a1592 1
       "$Id: MLSStrings.f90,v 2.60 2006/02/16 00:58:12 pwagner Exp $"
d1602 3
@


2.60
log
@ignore arg to ReadIntsFromChars may include * plus others
@
text
@d52 1
d78 1
d137 1
a137 1
   & SplitWords, streq, strings2Ints, trim_safe, &
d998 64
d1568 1
a1568 1
       "$Id: MLSStrings.f90,v 2.59 2005/09/22 23:33:58 pwagner Exp $"
d1578 3
@


2.59
log
@date conversion procedures and functions all moved into dates module
@
text
@d806 2
d810 2
a811 1
    ! Snip away any from the set ignore if present
d813 13
a825 1
	 ! Not useful yet
d868 3
a870 2
   elseif (  myIgnore == "*" ) then
     int = 0  ! Assume all ignorables means "0"
d874 2
a875 1
       if ( .not. isAlphabet(str(j:j)) ) then
d882 1
a882 1
     int = 0  ! Assume all ignorables means "0"
d1502 1
a1502 1
       "$Id: MLSStrings.f90,v 2.58 2005/07/21 23:37:22 pwagner Exp $"
d1512 3
@


2.58
log
@Added explanation of to-be-standard character flag options
@
text
@a49 2
! ReformatDate       Turns 'yyyymmdd' -> 'yyyy-mm-dd'; or more general format
! ReformatTime       Turns 'hhmmss.sss' -> 'hh:mm:ss'
a74 2
! char* ReformatDate (char* date, [char* fromForm], [char* toForm])
! char* ReformatTime (char* time, [char* form])
a126 2
! yyyymmdd_to_doy           
! yyyydoy_to_yyyymmdd_str   
d134 1
a134 1
   & reformatDate, reformatTime, Reverse, Reverse_trim, &
a154 13
  integer, parameter :: YEARMAX = 4999  ! Conversion invalid after 4999 AD
  ! The following arrays contains the maximum permissible day for each month
  ! where month=-1 means the whole year, month=1..12 means Jan, .., Dec
  integer, dimension(-1:12), parameter :: DAYMAXLY = (/ &
    & 366, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &
    & /)
  integer, dimension(-1:12), parameter :: DAYMAXNY = (/ &
    & 365, 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &
    & /)
  character(len=*), dimension(12), parameter :: MONTHNAME = (/ &
    & 'January  ', 'February ', 'March    ', 'April    ', 'May      ', &
    & 'June     ', 'July     ', 'August   ', 'September', 'October  ', &
    & 'November ', 'December '/)
a909 193
  ! --------------------------------------------------  reFormatDate  -----
  function reFormatDate(date, fromForm, toForm) result(reFormat)
    ! Reformat yyyymmdd as yyyy-mm-dd
    ! Wouldn't it be clever to allow an optional string arg defining
    ! the output format; E.g. 'dd M yyyy' for '03 September 2005'
    ! (Thus 'M' expands into the full month name)
    ! or 'yyyy-doy' for '2005-d245' (note the inclusion of the letter 'd')
    ! or 'yyyy-Doy' for '2005-245' (note the absence of the letter 'd')
    ! And yet another optional string to hold the input format
    ! in case it wasn't yyyymmdd?
    ! Args
    character(len=*), intent(in)            :: date
    character(len=len(date)+24)             :: reFormat
    character(len=*), optional, intent(in)  :: fromform ! output format
    character(len=*), optional, intent(in)  :: toform   ! input format
    ! Internal variables
    character(len=1), parameter             :: ymSpacer = '-'
    character(len=1), parameter             :: mdSpacer = '-'
    integer                                 :: i ! format string index
    integer                                 :: j ! date string index
    integer                                 :: doy
    character(len=4)                        :: doyString
    character(len=4)                        :: yyyyString
    integer                                 :: month
    character(len=len(date)+24)             :: tempFormat
    logical                                 :: inputWasDoy
    character(len=1), parameter             :: SPACESUBSTITUTE = '?'
    ! Executable
    ! print *, 'date: ', trim(date)
    tempFormat = date
    if ( present(fromform) ) then
      ! print *, 'fromForm: ', trim(fromForm)
      if ( len_trim(fromform) > 0 ) then
        inputWasDoy = .false.
        tempFormat = ' '
        i = 0
        j = 0
        do
          if ( i >= len_trim(fromform) ) exit
          i = i + 1
          j = j + 1
          ! print *, fromform(i:i)
          select case (fromform(i:i))
          case ('y')
            tempFormat(1:4) = date(j:j+3)
            i = i + 3
            j = j + 3
          case ('m')
            tempFormat(5:6) = date(j:j+1)
            i = i + 1
            j = j + 1
          case ('M')
            month = monthNameToNumber(date(j:))
            if ( month < 1 .or. month > 12 ) then
              reFormat = 'month name uncrecognized'
              return
            endif
            j = j + len_trim(MONTHNAME(month)) - 1
            write(tempFormat(5:6),'(i2.2)') month
          case ('D')
            inputWasDoy = .true.
            doyString = 'd' // date(j:j+2)
            i = i + 2
            j = j + 2
          case ('d')
            if ( fromform(i:i+1) == 'dd' ) then
              tempFormat(7:8) = date(j:j+1)
              i = i + 1
              j = j + 1
            else
              inputWasDoy = .true.
              doyString = date(j:j+3)
              i = i + 2
              j = j + 2
            endif
          case default
            ! i = i + 1
          end select
        enddo
        if ( inputWasDoy ) then
          ! Need to convert from yyyydoy to yyyymmdd
          ! print *, ' Need to convert from yyyydoy to yyyymmdd'
          yyyyString = tempFormat(1:4)
          call yyyydoy_to_yyyymmdd_str(yyyyString, doyString(2:4), tempFormat)
          ! print *, yyyyString, doyString(2:4), tempFormat
        endif
      endif
    endif
    ! print *, tempFormat
    reFormat = tempFormat(1:4) // ymSpacer // tempFormat(5:6) // mdSpacer // tempFormat(7:8)
    if ( .not. present(toform) ) return
    if ( len_trim(toform) < 1 ) return
    reFormat = ' '
    i = 0
    do
      if ( i >= len_trim(toform) ) exit
      i = i + 1
      select case (toform(i:i))
      case ('y')
        reFormat = trim(reFormat) // tempFormat(1:4)
        i = i + 3
      case ('m')
        reFormat = trim(reFormat) // tempFormat(5:6)
        i = i + 1
      case ('M')
        read(tempFormat(5:6), *) month
        reFormat = trim(reFormat) // trim(MONTHNAME(month))
      case ('D')
        call yyyymmdd_to_doy_str(tempFormat, doy)
        write(doyString, '(i3.3)') doy
        reFormat = trim(reFormat) // doyString
        i = i + 2
      case ('d')
        if ( toform(i:i+1) == 'dd' ) then
          reFormat = trim(reFormat) // tempFormat(7:8)
          i = i + 1
        else
          call yyyymmdd_to_doy_str(tempFormat, doy)
          write(doyString, '(a1, i3.3)') 'd', doy
          reFormat = trim(reFormat) // doyString
          i = i + 2
        endif
      case (' ')
        ! Foolish me--it can't handle spaces because of all the trims
        reFormat = trim(reFormat) // SPACESUBSTITUTE
      case default
        reFormat = trim(reFormat) // toform(i:i)
      end select
    enddo
    if ( index(reFormat, SPACESUBSTITUTE) < 1 ) return
    ! Need to substitute a space for every occurrence of SPACESUBSTITUTE
    do
      i = index(reFormat, SPACESUBSTITUTE)
      if ( i < 1 ) return
      reFormat(i:i) = ' '
    enddo
  end function reFormatDate

  ! --------------------------------------------------  reFormatTime  -----
  function reFormatTime(time, form) result(reFormat)
    ! Reformat hhmmss.sss as hh:mm:ss
    ! (Note it truncates instead of rounding)
    ! Wouldn't it be clever to allow an optional string arg defining
    ! the output format; E.g. 'hh:mm' for '13:23' (note 24-hour time)
    ! or 'HH:mm' for '01:23 PM' (note AM/PM marking)
    ! Args
    character(len=*), intent(in)            :: time
    character(len=len(time)+24)             :: reFormat
    character(len=*), optional, intent(in)  :: form
    ! Internal variables
    character(len=1), parameter             :: hmSpacer = ':'
    character(len=1), parameter             :: msSpacer = ':'
    integer                                 :: hours
    integer                                 :: i
    character(len=2)                        :: ampm
    character(len=2)                        :: hh
    ! Executable
    reFormat = time(1:2) // hmSpacer // time(3:4) // msSpacer // time(5:6)
    if ( .not. present(form) ) return
    if ( len_trim(form) < 1 ) return
    ampm = ' '
    reFormat = ' '
    i = 0
    do
      if ( i >= len_trim(form) ) exit
      i = i + 1
      select case (form(i:i))
      case ('h')
        reFormat = trim(reFormat) // time(1:2)
        i = i + 1
      case ('H')
        read(time(1:2), *) hours
        ampm = 'AM'
        if ( hours > 12 ) then
          hours = hours - 12
          ampm = 'PM'
        endif
        write(hh, '(i2.2)') hours
        reFormat = trim(reFormat) // hh
        i = i + 1
      case ('m')
        reFormat = trim(reFormat) // time(3:4)
        i = i + 1
      case ('s')
        reFormat = trim(reFormat) // time(5:6)
        i = i + 1
      case default
        reFormat = trim(reFormat) // form(i:i)
      end select
    enddo
    if ( ampm /= ' ' ) reFormat = trim(reFormat) // ' ' // ampm
  end function reFormatTime

a1401 103
  ! ---------------------------------------------  yyyymmdd_to_doy_ints  -----
  subroutine yyyymmdd_to_doy_ints(year, month, day, doy)
    ! Routine that returns the number of days after the year's start
    ! for year, month, day
    !--------Argument--------!
    integer, intent(in) :: year, month, day
    integer, intent(out) :: doy
    !----------Local vars----------!
    integer :: m
    integer, dimension(-1:12) :: DAYMAX
    !----------Executable part----------!
     if ( year < 0 .or. year > YEARMAX ) then
       doy = -1
     endif
     doy = day
     if ( month <= 1 ) then
       return
     endif
     if ( leapyear(year) ) then
       DAYMAX = DAYMAXLY
     else
       DAYMAX = DAYMAXNY
     endif
     do m=1, month-1
       doy = doy + DAYMAX(m)
     enddo
     
  end subroutine yyyymmdd_to_doy_ints

  ! ---------------------------------------------  yyyymmdd_to_doy_str  -----
  subroutine yyyymmdd_to_doy_str(str, doy)
    ! Routine that returns the number of days after the year's start
    ! for a string of the form yyyymmdd
    !--------Argument--------!
    character(len=*),intent(in) :: str
    integer,intent(out) :: doy
    !----------Local vars----------!
    integer :: year, month, day
    integer :: ErrTyp
    !----------Executable part----------!
     ! call utc_to_yyyymmdd_ints(str, ErrTyp, year, month, day, nodash=.true.)
     doy = -1
     if ( len_trim(str) < 8 ) return
     ! print *, 'str: ', str
     read(str(1:4), *) year
     read(str(5:6), *) month
     read(str(7:8), *) day
     call yyyymmdd_to_doy_ints(year, month, day, doy)
  end subroutine yyyymmdd_to_doy_str

  ! ---------------------------------------------  yyyydoy_to_yyyymmdd_str  -----
  subroutine yyyydoy_to_yyyymmdd_str(yyyy, doy, yyyymmdd)
    ! Routine that converts the string encoding the number of days 
    ! after the year's start, input as yyyydoy,
    ! for a string of the form yyyymmdd
    !--------Argument--------!
    character(len=*),intent(in) :: yyyy
    character(len=*),intent(in) :: doy ! w/o the letter 'd'
    character(len=*),intent(out) :: yyyymmdd
    !----------Local vars----------!
    integer :: year, month, day, doynum
    !----------Executable part----------!
     read(yyyy, *) year
     read(doy, *) doynum
     call yeardoy_to_yyyymmdd_ints(year, doynum, yyyymmdd)
  end subroutine yyyydoy_to_yyyymmdd_str

  ! ---------------------------------------------  yeardoy_to_yyyymmdd_ints  -----
  subroutine yeardoy_to_yyyymmdd_ints(year, doy, yyyymmdd)
    ! Routine that converts the string encoding the number of days 
    ! after the year's start, input as yyyydoy,
    ! for a string of the form yyyymmdd
    !--------Argument--------!
    integer,intent(in)           :: year
    integer,intent(in)           :: doy
    character(len=*),intent(out) :: yyyymmdd
    !----------Local vars----------!
    integer :: day
    integer :: daysum
    integer :: m
    integer, dimension(-1:12) :: DAYMAX
    !----------Executable part----------!
     if ( year < 0 .or. year > YEARMAX ) then
       yyyymmdd = 'year not in range'
     endif
     daysum = 0
     if ( leapyear(year) ) then
       DAYMAX = DAYMAXLY
     else
       DAYMAX = DAYMAXNY
     endif
     do m=1, 12
       if ( daysum + DAYMAX(m) >= doy ) exit
       daysum = daysum + DAYMAX(m)
     enddo
     if ( m > 12 ) then
       yyyymmdd = 'doy not in range'
       return
     endif
     day = doy - daysum
     write(yyyymmdd,'(I4.4, 2i2.2)') year, m, day
  end subroutine yeardoy_to_yyyymmdd_ints

a1449 27
  ! ---------------------------------------------------  Leapyear  -----
  logical function leapyear(year)
    integer,intent(in) :: year
     ! This is to capture the rule that centuries are leap only
     ! if divisible by 400
     ! Otherwise, as perhaps you knew, leapyears are those years divisible by 4
     leapyear = mod(year,4) == 0 .and. & ! Processor might short-circuit this
       & ( (mod(year,100) /= 0) .or. (mod(year,400) == 0) )
  end function leapyear

  ! ------------------------------------------  monthNameToNumber  -----
  function monthNameToNumber(name) result(number)
    ! Convert month name to corresponding number
    ! E.g., given 'March', returns 3
    ! As a courtesy, name may be case-insensitive
    ! As a further courtesy, name may be followed by any junk you like
    ! Thus 'March 23, 2004 01:59:59.999' still returns 3
    ! If no such month is found, returns -1
    ! Args
    character(len=*), intent(in)             :: name
    integer                                  :: number
    do number=1, size(MONTHNAME)
      if ( index(lowerCase(name), lowercase(trim(MONTHNAME(number)))) > 0 ) return
    enddo
    number = -1
  end function monthNameToNumber

d1485 1
a1485 1
       "$Id: MLSStrings.f90,v 2.57 2005/06/22 17:25:50 pwagner Exp $"
d1495 3
@


2.57
log
@Reworded Copyright statement, moved rcs id
@
text
@d21 1
a21 1
       "$RCSfile: $"
d92 13
d1827 1
a1827 1
       "$Id: $"
d1837 3
@


2.56
log
@readIntsFromChars can now ignore certain chars
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d19 1
a19 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: MLSStrings.f90,v 2.55 2005/05/31 17:46:01 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d21 1
a21 1
       "$RCSfile: MLSStrings.f90,v $"
d1812 5
d1824 3
@


2.55
log
@Added array  interfaces for streq
@
text
@d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.54 2005/04/12 17:34:53 pwagner Exp $"
d804 1
a804 1
  SUBROUTINE readAnIntFromChars (str, int, forbiddens)
d809 2
d817 1
a817 1
    character(len=40)                           ::   myForbiddens
d820 1
a820 1
    INTEGER :: j
d822 3
d833 5
d850 27
a876 1
   if ( .not. leave_undef ) read(str, *) int
d1699 48
d1814 3
@


2.54
log
@isRepeat, streq, ncopies, reverse_trim, scalar versions of read/write intchar
@
text
@d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.53 2005/03/15 23:45:05 pwagner Exp $"
d79 2
d130 4
d1069 1
a1069 1
  FUNCTION Reverse (str) RESULT (outstr)
d1101 1
a1101 1
  END FUNCTION Reverse
d1104 1
a1104 1
  FUNCTION Reverse_trim (str) RESULT (outstr)
d1135 1
a1135 1
  END FUNCTION Reverse_trim
d1224 69
a1292 2
  ! -------------------------------------------------  streq  -----
  function streq (STR1, STR2, OPTIONS) result (relation)
d1321 1
a1321 1
    character(len=4) :: myOptions
d1440 1
a1440 1
  end function streq
d1702 1
a1702 1
  function firstsubstr(str, star) result(substr)
d1730 3
@


2.53
log
@Added trim_safe to stop trimming at length 1
@
text
@d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.52 2005/01/20 01:29:42 vsnyder Exp $"
d35 1
d37 1
d41 1
d48 1
d50 2
d62 1
d66 1
d68 1
d75 1
d78 1
d93 20
d117 2
a118 2
   & ints2Strings, LinearSearchStringArray, &
   & LowerCase, &
d120 2
a121 2
   & reformatDate, reformatTime, Reverse, &
   & SplitWords, strings2Ints, trim_safe, &
d124 8
d380 92
d501 30
d649 33
d797 43
a839 2
  ! --------------------------------------------------  readIntsFromChars  -----
  SUBROUTINE readIntsFromChars (strs, ints, forbiddens)
a850 1
    character(len=40)                           ::   myForbiddens
a862 5
   if ( present(forbiddens) ) then
     myForbiddens = adjustl(forbiddens)
   else
     myForbiddens = ' '
   endif
d864 1
a864 13
      leave_undef = (strs(i) == ' ')
      if ( myForbiddens /= ' ' ) then
        do j=1, len(trim(myForbiddens))
           leave_undef = leave_undef &
            & .or. &
            & ( &
            &    index(strs(i), myForbiddens(j:j)) > 0 &
            &  .and. &
            &    myForbiddens(j:j) /= ' ' &
            & )
        enddo
      endif
      if ( .not. leave_undef ) read(strs(i), *) ints(i)
d867 1
a867 1
  END SUBROUTINE readIntsFromChars
d1069 1
a1069 1
	 ! See also ReverseList
d1097 34
d1218 151
d1417 41
a1457 2
  ! --------------------------------------------------  writeIntsToChars  -----
  SUBROUTINE writeIntsToChars (ints, strs)
a1459 2
    ! If any element of string array is blank or contains one of forbiddens
    ! the corresponding element of ints is left undefined
d1464 1
d1466 3
a1468 1
    integer, intent(in), dimension(:)            ::   ints
d1482 1
a1482 1
      write(strs(i), *) ints(i)
d1485 1
a1485 1
  END SUBROUTINE writeIntsToChars
d1617 32
d1657 3
@


2.52
log
@Add CatStrings
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.51 2004/10/13 20:25:45 pwagner Exp $"
d47 1
d69 1
d90 1
a90 1
   & SplitWords, strings2Ints, &
d997 18
d1183 3
@


2.51
log
@In reFormatDate allow day of year w/o letter d; e.g. 2004-274
@
text
@d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.50 2004/10/13 16:23:03 pwagner Exp $"
d29 1
d82 1
a82 1
  public :: Capitalize, CompressString, count_words, &
d134 19
d1163 3
@


2.50
log
@Moved declaration of hhmmss_value result to after use statement
@
text
@d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.49 2004/10/13 00:52:20 vsnyder Exp $"
d635 3
a637 1
    ! or 'yyyy-doy' for '2005-d245'
d658 1
a681 1
            ! print *, j, trim(date), trim(date(j:))
d689 5
a693 1
            ! print *, j, trim(date), trim(date(j:))
a694 1
            ! print *, fromform(i:i+1)
a734 1
        ! print *, 'Now trying to convert to month name ', trim(tempFormat), ' ', tempFormat(5:6)
d737 5
d773 2
a774 2
    ! the output format; E.g. 'hh:mm' for '13:23'
    ! or 'HH:mm' for '01:23 PM'
d1047 2
a1048 1
     if ( len_trim(str) < 8 ) return 
d1062 1
a1062 1
    character(len=*),intent(in) :: doy
d1143 3
@


2.49
log
@Move HHMMSS_value here from MLSStringLists and simplify it.
Remove AnyForbiddenChars and AllAllowedChars because intrinsic Scan and
Verify can do them, and they weren't used anyway.
@
text
@d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.48 2004/10/05 23:08:04 pwagner Exp $"
d211 1
a211 1
  real(r8) function HHMMSS_value ( str, ErrTyp, separator, strict ) result ( value )
d246 1
d1133 5
@


2.48
log
@Added AnyForbiddenChars and AllApprovedChars; improved reFormatDate
@
text
@d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.47 2004/09/23 22:56:38 pwagner Exp $"
a27 2
! AllApprovedChars   Does str1 contain only chars from str2?
! AnyForbiddenChars  Does str1 contain any chars from str2?
d30 5
a34 3
! count_words        Counts the number of space-separated words in a string
! depunctuate        Replaces punctuation with blanks
! ints2Strings       Converts an array of integers to strings using "char" ftn
d40 1
a40 1
! readIntsFromChars  Converts an array of strings to ints using Fortran read
d45 2
a46 2
! strings2Ints       Converts an array of strings to ints using "ichar" ftn
! writeIntsToChars   Converts an array of ints to strings using Fortran write
a49 2
! log AllApprovedChars (char* str1, char* str2)
! log AnyForbiddenChars (char* str1, char* str2)
d81 2
a82 3
  public :: AllApprovedChars, AnyForbiddenChars, &
   & Capitalize, CompressString, count_words, &
   & depunctuate, &
d90 2
a109 42
  ! -------------------------------------------------  AllApprovedChars  -----
  elemental logical function AllApprovedChars (STR1, STR2)
    ! Check that every char in str1 is "approved" by also being in str2
    !--------Argument--------!
    character (len=*), intent(in) :: STR1, STR2

    !----------Local vars----------!
    integer :: I
    !----------Executable part----------!
    AllApprovedChars = .false.
    if ( len_trim(str2) < 1 ) return
    AllApprovedChars = .true.

    do i=1, len_trim(str1)
       if ( index(trim(str2), str1(i:i)) < 1 ) then
          AllApprovedChars = .false.
          return
       end if
    end do

  end function AllApprovedChars

  ! -------------------------------------------------  AllApprovedChars  -----
  elemental logical function AnyForbiddenChars (STR1, STR2)
    ! Check if any char in str2 (the "forbiddens") is in str1
    !--------Argument--------!
    character (len=*), intent(in) :: STR1, STR2

    !----------Local vars----------!
    integer :: I
    !----------Executable part----------!
    AnyForbiddenChars = .false.
    if ( len_trim(str1) < 1 ) return
    AnyForbiddenChars = .true.

    do i=1, len_trim(str2)
       if ( index(trim(str1), str2(i:i)) > 0 ) return
    end do
    AnyForbiddenChars = .false.

  end function AnyForbiddenChars

d187 1
a187 1
  Function depunctuate(str) result (outstr)
d208 109
a316 1
  end Function depunctuate
d318 2
a319 2
  ! --------------------------------------------------  int2Strings  -----
  SUBROUTINE ints2Strings (ints, strs)
d328 1
a328 1
    CHARACTER (LEN=*), INTENT(OUT), dimension(:) :: strs
d331 1
a331 1
    INTEGER :: i, substr, strLen, arrSize
d338 1
a338 1
   if(strLen <= 0 .or. arrSize <= 0) return
d342 2
a343 2
      enddo
   enddo
d345 1
a345 1
  END SUBROUTINE ints2Strings
d1097 1
d1100 1
a1100 1
     ! This is to capture rule that centuries are leap only
d1103 2
a1104 5
     if ( 100 * (year/100) >= year ) then
       leapyear = ( 400 * (year/400) >= year )
     else
       leapyear = ( 4 * (year/4) >= year )
     endif
d1107 1
d1132 3
@


2.47
log
@Added reformats of date, time
@
text
@d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.46 2004/09/16 00:15:52 pwagner Exp $"
d28 2
d41 1
a41 1
! ReformatDate       Turns 'yyyymmdd' -> 'yyyy-mm-dd'
d50 2
d63 1
a63 1
! char* ReformatDate (char* date, [char* form])
d83 2
a84 1
  public :: Capitalize, CompressString, count_words, &
d111 42
d564 2
a565 2

  function reFormatDate(date, form) result(reFormat)
d570 2
d575 2
a576 1
    character(len=*), optional, intent(in)  :: form
d580 2
a581 1
    integer                                 :: i
d584 1
d586 3
d590 61
a650 3
    reFormat = date(1:4) // ymSpacer // date(5:6) // mdSpacer // date(7:8)
    if ( .not. present(form) ) return
    if ( len_trim(form) < 1 ) return
d654 1
a654 1
      if ( i >= len_trim(form) ) exit
d656 1
a656 1
      select case (form(i:i))
d658 1
a658 1
        reFormat = trim(reFormat) // date(1:4)
d661 1
a661 1
        reFormat = trim(reFormat) // date(5:6)
d664 2
a665 1
        read(date(5:6), *) month
d668 2
a669 2
        if ( form(i:i+1) == 'dd' ) then
          reFormat = trim(reFormat) // date(7:8)
d672 1
a672 1
          call yyyymmdd_to_doy_str(date, doy)
d677 3
d681 1
a681 1
        reFormat = trim(reFormat) // form(i:i)
d684 7
d693 1
d971 2
d979 53
d1044 16
d1068 3
@


2.46
log
@Added writeIntsToChars
@
text
@d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.45 2004/08/04 23:19:01 pwagner Exp $"
d39 2
d59 2
d84 1
a84 1
   & Reverse, &
d91 13
d517 107
a623 1
  ! --------------------------------------------------  Reverse  -----
d805 59
d872 3
@


2.45
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.44 2004/06/29 00:06:13 pwagner Exp $"
d42 1
d61 1
d81 2
a82 1
   & SplitWords, strings2Ints
d652 30
d690 3
@


2.44
log
@Tried to straighten out delimiter-separator terms in comments
@
text
@d8 1
a8 6
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, &
    & MLSMSG_Allocate, MLSMSG_DeAllocate
  use MLSCommon, only: i4, r8, NameLen, BareFNLen
  use MLSSets, only: FindFirst

  implicit NONE
d13 1
a13 1
       "$Id: MLSStrings.f90,v 2.43 2004/06/16 22:15:28 pwagner Exp $"
a26 7
!     (parameters)
! KEYNOTFOUND        key not found among keyList
! KEYBEYONDHASHSIZE  index of key in keyList > size(hash array)
! INVALIDHHMMSSSTRING
!                    (if strict) str not in format '00:00:00.0000000'
! LENORSIZETOOSMALL  Either charsize of strs or size(ints) too small

a27 1
! Array2List         Converts an array of strings to a single string list
a28 1
! catLists           cats 2 string lists, taking care if either one is blank
a31 9
! ExtractSubString   Extracts portion of string sandwiched between sub1 and sub2
! GetIntHashElement  Returns int from hash array corresponding to key string
! GetStringElement   Returns n'th element of string list
! GetStringHashElement   
!                    Returns string from hash list corresponding to key string
! GetUniqueList      Returns str list of only unique entries from input list
! GetUniqueStrings   Returns array of only unique entries from input array
! hhmmss_value       Converts 'hh:mm:ss' formatted string to a real r8
!                    (See also PGS_TD_UTCtoTAI and mls_UTCtoTAI)
a34 1
! List2Array         Converts a single string list to an array of strings
a35 1
! NumStringElements  Returns number of elements in string list
a38 2
! RemoveElemFromList removes occurrence(s) of elem in a string list
! ReplaceSubString   replaces occurrence(s) of sub1 with sub2 in a string
a39 3
! ReverseList        Turns 'abc,def,ghi' -> 'ghi,def,abc'
! SortArray          Turns (/'def','ghi','abc'/) -> (/'abc','def','ghi'/)
! SortList           Turns 'def,ghi,abc' -> 'abc,def,ghi'
a41 4
! StringElementNum   Returns element number of test string in string list
! unquote            Removes surrounding [quotes]
! utc_to_yyyymmdd    Parses yyyy-mm-ddThh:mm:ss.sss or yyyy-dddThh:mm:ss.sss
! yyyymmdd_to_dai    Converts yyyymmdd to days after Jan 1, 2001
a44 2
! Array2List (char* inArray(:), char* outList(:), &
!   & [char inseparator], [int ordering], [char leftRight]) 
a45 1
! char* catLists (char* str1, char* str2)
a48 12
! ExtractSubString (char* str, char* outstr, char* sub1, char* sub2, &
!       & [char* how], [log no_trim])
! GetIntHashElement (strlist keyList, hashArray(:), char* key, 
!   int ErrType, log countEmpty, [char inseparator], [log part_match])
! GetStringElement (strlist inList, char* outElement,
!   i4 nElement, log countEmpty, [char inseparator])
! GetStringHashElement (strlist keyList, strlist hashList, char* key, 
!   char* outElement, log countEmpty, [char inseparator], [log part_match])
! GetUniqueList (char* str, char* outstr(:), int noUnique, &
!   & log countEmpty, [char inseparator], [log IgnoreLeadingSpaces]) 
! GetUniqueStrings (char* inList(:), char* outList(:), int noUnique) 
! r8 hhmmss_value (char* str, int ErrTyp, [char separator], [log strict])
a51 2
! List2Array (strlist inList, char* outArray(:), log countEmpty, [char inseparator],
!    [log IgnoreLeadingSpaces])
a52 2
! int NumStringElements(strlist inList, log countEmpty, &
!   & [char inseparator], [int LongestLen])
a55 2
! ReplaceSubString (char* str, char* outstr, char* sub1, char* sub2, &
!       & [char* which], [log no_trim])
a56 6
! strlist ReverseList (strlist str, [char inseparator])
! SortArray (char* inStrArray(:), int outIntArray(:), log CaseSensitive, &
!   & [char* sortedArray(:)], [log shorterFirst], [char leftRight])
! SortList (strlist inStrArray, int outIntArray(:), log CaseSensitive, &
!   & log countEmpty, [char inseparator], [log IgnoreLeadingSpaces], 
!     [strlist sortedList], [char leftRight])
a59 11
! int StringElementNum(strlist inList, char* test_string, log countEmpty, &
!    & [char inseparator], [log part_match])
! char* unquote (char* str, [char* quotes], [char* cquotes], [log strict])

! in the above, a string list is a string of elements (usu. comma-separated)
! e.g., units='cm,m,in,ft'
! an array is a Fortran array of strings or integers
! a hash is a list of key strings and either
! (1) a list of associated strings
! (2) an array of associated integers
! (an idea called a hash in perl or a dictionary in python)
d64 1
a64 1
! (1) in the routines LinearSearchStringArray, Array2List, and SortArray
a70 2
! (2) In operating on string lists it is sometimes assumed that no
! element is longer than a limit: MAXSTRELEMENTLENGTH
d73 4
a76 6
  public :: catLists, Array2List, Capitalize, CompressString, count_words, &
   & depunctuate, ExtractSubString, &
   & GetIntHashElement, GetStringElement, GetStringHashElement, &
   & GetUniqueStrings, GetUniqueList, &
   & hhmmss_value, ints2Strings, LinearSearchStringArray, &
   & List2Array, LowerCase, NumStringElements, &
d78 3
a80 25
   & RemoveElemFromList, ReplaceSubString, Reverse, ReverseList, &
   & SortArray, SortList, SplitWords, strings2Ints, &
   & StringElementNum, unquote, utc_to_yyyymmdd, yyyymmdd_to_dai

  interface switch
    module procedure switch_ints
  end interface

  interface utc_to_yyyymmdd
    module procedure utc_to_yyyymmdd_strs, utc_to_yyyymmdd_ints
  end interface

  interface yyyymmdd_to_dai
    module procedure yyyymmdd_to_dai_str, yyyymmdd_to_dai_ints
  end interface

  ! Error return values from:
  ! GetIntHashElement
!  public :: KEYNOTFOUND, KEYBEYONDHASHSIZE
  integer, public, parameter :: KEYNOTFOUND=-1
  integer, public, parameter :: KEYBEYONDHASHSIZE=KEYNOTFOUND-1
  ! hhmmss_value
  integer, public, parameter :: INVALIDHHMMSSSTRING = 1
  ! utc_to_yyyymmdd
  integer, public, parameter :: INVALIDUTCSTRING = 1
d84 1
a84 83
  ! A limitation among string list operations
  integer, private, parameter :: MAXSTRELEMENTLENGTH = BareFNLen

  integer, parameter :: YEARMAX = 4999  ! Conversion invalid after 4999 AD
  ! The following arrys contains the maximum permissible day for each month
  ! where month=-1 means the whole year, month=1..12 means Jan, .., Dec
  integer, dimension(-1:12), parameter :: DAYMAXLY = (/ &
    & 366, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &
    & /)
  integer, dimension(-1:12), parameter :: DAYMAXNY = (/ &
    & 365, 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &
    & /)
CONTAINS

  ! ---------------------------------------------  Array2List  -----

  ! This subroutine returns a (usually) comma-separated string list, interpreted it
  ! as a list of individual elements, given an equivalent array of
  ! sub-strings in which the n'th element becomes the n'th element

  ! As an optional arg the separator may supplied, in case it isn't a comma
  ! As an optional arg the ordering in which the array elements are to be
  ! taken may be supplied; e.g. (/4, 1, 3, 2/) means 1st take 4th element,
  ! then 1st, then 3rd, and finally 2nd: list[k] = array[ordering[k]]
  ! (unless the further optional arg leftRight is also supplied and equals
  ! one of {"l", "L"} in which case list[ordering[k]] = array[k])

  SUBROUTINE Array2List ( inArray, outList, inseparator, ordering, leftRight )
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(OUT)                :: outList
    CHARACTER (LEN=*), DIMENSION(:), INTENT(IN)   :: inArray
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
    INTEGER, DIMENSION(:), OPTIONAL, INTENT(IN)   :: ordering
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: leftRight

    ! Local variables
    INTEGER(i4) :: listElem, arrayElem, nElems

    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=1), PARAMETER    :: BLANK = ' '   ! Returned for any element empty
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
    CHARACTER (LEN=1)               :: myLeftRight
    ! Executable code

    IF(PRESENT(inseparator)) THEN
      separator = inseparator
    ELSE
      separator = COMMA
    END IF

    IF(PRESENT(leftRight)) THEN
      myleftRight = Capitalize(leftRight)
    ELSE
      myleftRight = "R"
    ENDIF

    if ( len(outList) <= 0 ) return
    outList = BLANK
    nElems = size(inArray)
    if ( nElems <= 0 ) return
	 listElem = 1
    DO
      if (.not. present(ordering) ) then
        arrayElem = ListElem
      elseif (myLeftRight == "R") then
        arrayElem = ordering(ListElem)
      else
        ! Try to invert ordering function
        do arrayElem=1, nElems
          if ( ordering(arrayElem) == listElem ) exit
        enddo
        arrayElem = min(arrayElem, nElems)
      endif
      if ( listElem == 1 ) then
        outList = trim(inArray(arrayElem))
      else
        outList = trim(outList) // separator // trim(inArray(arrayElem))
      endif
      listElem = listElem + 1
      if ( listElem > min(nElems, len(outList)) ) return
    ENDDO

  END SUBROUTINE Array2List
a108 31
  ! -------------------------------------------------  catLists  -----
  function catLists (STR1, STR2, inseparator) result (OUTSTR)
    ! cats 2 string lists, taking care if either is blank
    ! E.g., given str1 = 'a,b,c' and str2 = 'd,e,f'
    ! returns 'a,b,c,d,e,f'
    ! If either is blank, returns the other
    ! If both blank, returns a blank
    !--------Argument--------!
    character (len=*), intent(in) :: STR1
    character (len=*), intent(in) :: STR2
    character (len=1), optional, intent(in)       :: inseparator
    character (len=len(str1)+len(str2)+1) :: OUTSTR

    !----------Local vars----------!
    character (len=1), parameter    :: COMMA = ','
    character (len=1)               :: separator
    !----------executable part----------!
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = comma
    end if
    if ( len_trim(str2) < 1 ) then
      outstr=str1
    elseif ( len_trim(str1) < 1 ) then
      outstr=str2
    else
      outstr = trim(str1) // separator // trim(str2)
    endif
  end function catLists

a185 724
  ! --------------------------------------------------  ExtractSubString  -----
  SUBROUTINE ExtractSubString (instr, outstr, sub1, sub2, how, no_trim)
    ! Takes a string and extracts what is sandwiched between sub1 and sub2
	 ! Defaults to choosing only the first occurrence of sub1 and sub2
    ! But if how == 'greedy' chooses last occurrence of sub2
    ! or if how == 'stingy' chooses last occurrence of sub1
    ! Note that, depending on how, we extract:
    !    (let sub1='abc' sub2='def' str='abcabc123defdef')
    ! (a) if how == default => 'abc123'
    ! (b) if how == greedy => 'abc123def'
    ! (c) if how == stingy => '123'
    ! If no_trim is TRUE, sub1 and sub2 may have trailing spaces
    ! that will not be trimmed before attempting to match
    ! Method:
    ! Replace substrings sub1 and sub2 with separator character
    ! and then use GetStringElement to get subelement number 2
    !  
    ! A fundamental issue arises if sub2 occurs before sub1 in the string
    ! Do we want to interpret the request such that we
    ! (1) return a blank
    ! (2) look for occurrences of sub2 in the string after sub1
    ! I think we should aim for 2, as it produces a generalization
    ! of picking elements out of a comma-separated list
    !
    ! Will this still work if sub1 has leading or trailing blanks? 
    ! How about sub2?
    ! Do we need an optional arg, no_trim, say, that will leave them?
    ! Tried coding it, but can't say for sure it works
    ! What if sub1 is a substring of sub2, or vice versa?
    !--------Argument--------!
    CHARACTER (LEN=*), INTENT(IN) :: instr
    CHARACTER (LEN=*), INTENT(IN) :: sub1
    CHARACTER (LEN=*), INTENT(IN) :: sub2
    CHARACTER (LEN=*), INTENT(INOUT) :: outstr
    character (len=*), intent(in), optional :: how
    logical, intent(in), optional :: no_trim

    !----------Local vars----------!
    CHARACTER (LEN=len(instr)) :: str
    integer, parameter         :: MAXREPLACEMENTS = 100
    integer, parameter         :: EARLYSUB2INTERPRETATION = 2 ! 2 or 1
    INTEGER :: i, isub1, isub2, strlen, tmpstrlen
    character (len=7) :: my_how
    character(len=1) :: separator
    character(len=*), parameter :: separators =',.$%#{}()'
    character (len=max(len(str), len(outstr))) :: tmpstr
    character (len=max(len(str), len(outstr))) :: tmpstr2
    logical :: my_no_trim, trimming
    !----------Executable part----------!
    my_how = 'first'
    if ( present(how) ) my_how = lowercase(how)
    my_no_trim = .false.
    if ( present(no_trim) ) my_no_trim = no_trim
    trimming = .not. my_no_trim
    outstr = ' '
    strlen = LEN_trim(instr)
    if (strlen < 1 .or. instr == ' ') return
    ! print *, 'instr: ', trim(instr)
    ! print *, 'strlen: ', strlen
    ! Which interpretation of sub2 occurring before sub1 do we make?
    isub1 = index(instr, trim(sub1))
    isub2 = index(instr, trim(sub2))
    ! print *, 'sub1: ', trim(sub1)
    ! print *, 'isub1: ', isub1
    ! print *, 'sub2: ', trim(sub2)
    ! print *, 'isub2: ', isub2
    if ( isub2 < isub1 ) then
      if ( isub2 == 0 ) then
        return
      elseif ( EARLYSUB2INTERPRETATION == 2 ) then
        ! zap every occurrence of sub2 up to position isub1
        ! print *, 'zap every occurrence of sub2 up to position isub1'
        ! print *, 'before zapping: ', instr(1:isub1-1)
        ! print *, 'tail: ', instr(isub1:strlen)
        call ReplaceSubString (instr(1:isub1-1), tmpstr, sub2, '', &
          & which='all', no_trim=.false.)
        ! print *, 'afterzapping: ', trim(tmpstr), '//', instr(isub1:strlen)
        tmpstrlen = len_trim(tmpstr)
        ! print *, 'tmpstrlen: ', tmpstrlen
        tmpstrlen = len(trim(tmpstr))
        ! print *, 'tmpstrlen(2): ', tmpstrlen
        str = ''
        if ( tmpstrlen < 1 ) then
          str = instr(isub1:strlen)
        else
          str = tmpstr(1:tmpstrlen) // instr(isub1:strlen)
          ! str = tmpstr(1:tmpstrlen)
          ! print *, tmpstr(1:tmpstrlen)
          ! print *, str(1:tmpstrlen)
          ! str(tmpstrlen+1:) = instr(isub1:strlen)
          ! print *, instr(isub1:strlen)
          ! print *, trim(str(tmpstrlen+1:))
        endif
      else
        str = instr
      endif
    else
      str = instr
    endif
    ! print *, 'str: ', trim(str)
    if ( trimming ) then
      if (len_trim(sub1) < 1 &
        & .or. &
        & len_trim(sub2) < 1 .or. index(str, trim(sub1)) == 0 &
        & .or. &
        & index(str, trim(sub2)) == 0 ) RETURN
    else
      if (index(str, sub1) == 0 &
        & .or. &
        & index(str, sub2) == 0 ) RETURN
    endif
    do i=1, len(separators)
      if ( index(str, separators(i:i)) == 0 ) exit
    enddo
    if ( i > len(separators) ) return   ! This means our method will fail
    separator = separators(i:i)
    ! print *, 'separator: ', separator
    select case (trim(my_how))
    case ('greedy')
      if ( trimming ) then
        call ReplaceSubString (Reverse(trim(str)), tmpstr, &
          & Reverse(trim(sub2)), separator)
        tmpstr2 = Reverse(trim(tmpstr))
        call ReplaceSubString (tmpstr2, tmpstr, sub1, separator)
      else
        call ReplaceSubString (Reverse(str), tmpstr, &
          & Reverse(sub2), separator, no_trim=.true.)
        tmpstr2 = Reverse(tmpstr)
        call ReplaceSubString (tmpstr2, tmpstr, sub1, separator, no_trim=.true.)
      endif
    case ('stingy')
      if ( trimming ) then
        call ReplaceSubString (Reverse(trim(str)), tmpstr, &
          & Reverse(trim(sub1)), separator)
        tmpstr2 = Reverse(trim(tmpstr))
        call ReplaceSubString (tmpstr2, tmpstr, sub2, separator)
      else
        call ReplaceSubString (Reverse(str), tmpstr, &
          & Reverse(sub1), separator, no_trim=.true.)
        tmpstr2 = Reverse(tmpstr)
        call ReplaceSubString (tmpstr2, tmpstr, sub2, separator, no_trim=.true.)
      endif
    case default
      ! print *, 'Replacing: ', sub1, ' with ', separator
      ! print *, 'in: ', trim(str)
      call ReplaceSubString (str, tmpstr2, sub1, separator, &
        & which='first', no_trim=no_trim)
      ! print *, 'results in: ', trim(tmpstr2)
      ! print *, 'Replacing: ', sub2, ' with ', separator
      call ReplaceSubString (tmpstr2, tmpstr, sub2, separator, &
        & which='first', no_trim=no_trim)
      ! print *, 'results in: ', trim(tmpstr)
    end select
    call GetStringElement (tmpstr, outstr, 2, .true., &
      & inseparator=separator )

  END SUBROUTINE ExtractSubString

  ! ---------------------------------------------  GetIntHashElement  -----

  ! This function takes one (usually) comma-separated string list, interprets it
  ! it as a list of elements, and an array of ints
  ! treating the list as keys and the array as
  ! a hash table, associative array or dictionary
  ! It returns the int from the hash table corresponding to the key
  ! If the key is not found in the array of keys, it sets ErrType=KEYNOTFOUND
  ! otherwise ErrType=0
  
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists

  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! Another optional arg, part_match, returns a match for the 
  ! first hash element merely found in the key; e.g.
  ! 'won, to, tree' and key 'protocol.dat' matches 'to'

  ! Basic premise: Use StringElementNum on key in keyList to find index
  ! Use this index for the array of ints
  
  FUNCTION GetIntHashElement(keyList, hashArray, key, ErrType, &
  & countEmpty, inseparator, part_match) RESULT (hashInt)
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(IN)             :: keyList
    INTEGER, DIMENSION(:), INTENT(IN)         :: hashArray
    INTEGER                                   :: hashInt
    CHARACTER (LEN=*), INTENT(IN)             :: key
    INTEGER, INTENT(OUT)                      :: ErrType
    LOGICAL, INTENT(IN)                       :: countEmpty
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
    LOGICAL, OPTIONAL, INTENT(IN)             :: part_match

    ! Local variables
	INTEGER :: elem

    ! Executable code

   ErrType = 0
	elem = StringElementNum(keyList, key, countEmpty, inseparator, part_match)
	hashInt = elem
	IF(elem <= 0) THEN
		ErrType = KEYNOTFOUND
	ELSEIF(elem > SIZE(hashArray)) THEN
		ErrType = KEYBEYONDHASHSIZE
	ELSE
		hashInt = hashArray(elem)
	ENDIF

  END FUNCTION GetIntHashElement

  ! ---------------------------------------------  GetStringElement  -----

  ! This subroutine takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements and returns the
  ! sub-string which is the n'th element
  ! if n is too large or small, it returns the separator
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists

  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! See also SplitWords

  SUBROUTINE GetStringElement(inList, outElement, nElement, countEmpty, inseparator)
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(IN)   :: inList
    CHARACTER (LEN=*), INTENT(OUT)  :: outElement
    INTEGER(i4), INTENT(IN)         :: nElement 	! Entry number to return
    LOGICAL, INTENT(IN)   :: countEmpty
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator

    ! Local variables
    INTEGER(i4) :: i           ! Loop counters
    INTEGER(i4) :: elem, nextseparator

    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=1), PARAMETER    :: BLANK = ' '   ! Returned if element empty
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
    ! Executable code

    IF(PRESENT(inseparator)) THEN
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF

	 IF(nElement.LE.0) THEN
	     outElement = separator
	 ELSEIF(LEN(inList) < nElement) THEN
	     outElement = separator
    ENDIF
    i = 1
	 elem = 1
    DO
	     nextseparator = i - 1 + INDEX(inList(i:), separator)

	! No more separators
		  IF(nextseparator == i - 1) THEN
		      IF(elem >= nElement) THEN
				    outElement = inList(i:)
			    ELSE
				    outElement = separator
			    ENDIF
				 RETURN

	! Next separator is the adjacent char
			ELSEIF(nextseparator == i) THEN
				IF(countEmpty) THEN
		     	 IF(elem >= nElement) THEN
				    	outElement = BLANK
						RETURN
			   	 ELSE
					 	elem = elem+1
			    	ENDIF
				ENDIF

	! Until next separator is the next element
			ELSE
		      IF(elem >= nElement) THEN
				    IF(i < nextseparator) THEN
				       outElement = inList(i:nextseparator-1)
						ELSE
				       outElement = separator
						ENDIF
   				 RETURN
			    ELSEIF(nextseparator >= LEN(inList)) THEN
				    outElement = separator
				    RETURN
			    ELSE
					 elem = elem+1
			    ENDIF
			ENDIF
			i = nextseparator+1
	 ENDDO

  END SUBROUTINE GetStringElement

  ! ---------------------------------------------  GetStringHashElement  -----

  ! This subroutine takes two (usually) comma-separated string lists, interprets it
  ! each as a list of elements, treating the first as keys and the second as
  ! a hash table, associative array or dictionary
  ! It returns the sub-string from the hash table corresponding to the key
  ! If the key is not found in the array of keys, it returns the separator
  
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists

  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! Another optional arg, part_match, returns a match for the 
  ! first hash element merely found in the key; e.g.
  ! 'won, to, tree' and key 'protocol.dat' matches 'to'

  ! Basic premise: Use StringElementNum on key in keyList to find index
  ! Use this index to GetStringElement from HashList

  ! Someday you may wish to define a StringHash_T made up of the two
  ! strings
  
  SUBROUTINE GetStringHashElement(keyList, hashList, key, outElement, &
  & countEmpty, inseparator, part_match)
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(IN)   :: keyList
    CHARACTER (LEN=*), INTENT(IN)   :: hashList
    CHARACTER (LEN=*), INTENT(IN)   :: key
    CHARACTER (LEN=*), INTENT(OUT)  :: outElement
    LOGICAL, INTENT(IN)   :: countEmpty
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
    LOGICAL, OPTIONAL, INTENT(IN)             :: part_match

    ! Local variables
	INTEGER(i4) :: elem
    CHARACTER (LEN=1)                          :: separator
    CHARACTER (LEN=1), PARAMETER               :: COMMA = ','

    ! Executable code

    IF(PRESENT(inseparator)) THEN
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF

	elem = StringElementNum(keyList, key, countEmpty, inseparator, part_match)
	IF(elem <= 0) THEN
		outElement = separator
	ELSE
		CALL GetStringElement(hashList, outElement, elem, &
        & countEmpty, inseparator)
	ENDIF

  END SUBROUTINE GetStringHashElement

  ! ---------------------------------------------  GetUniqueList  -----

  ! This subroutine takes a string list and returns another containing
  ! only the unique entries. The resulting list is supplied by the caller
  ! (You may safely use the same variable for str and outStr)
  ! E.g., given 'one,two,three,one,four' returns 'one,two,three,four'
  ! If optional string list str2 is supplied, instead
  ! returns list from str that are not also in str2

  SUBROUTINE GetUniqueList(str, outStr, noUnique, countEmpty, &
    & inseparator, IgnoreLeadingSpaces, str2)
    ! Dummy arguments
    CHARACTER (LEN=*), intent(in) :: str
    CHARACTER (LEN=*), intent(out) :: outstr
    INTEGER :: noUnique ! Number of unique entries
    LOGICAL, INTENT(IN)                           :: countEmpty
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
    LOGICAL, OPTIONAL, INTENT(IN)       :: IgnoreLeadingSpaces
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN)       :: str2

    ! Local variables
    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
    CHARACTER (LEN=MAXSTRELEMENTLENGTH), DIMENSION(:), ALLOCATABLE    &
      &                             :: inStringArray, outStringArray, inStrAr2
    integer :: nElems
    integer :: nElems2
    integer :: LongestLen
    integer :: status

    ! Executable code
    IF(PRESENT(inseparator)) THEN
      separator = inseparator
    ELSE
      separator = COMMA
    ENDIF
    if ( len(str) <= 0 .or. len(outstr) <= 0 ) return
    nElems = NumStringElements(str, countEmpty, inseparator, LongestLen)
    noUnique = nElems
    if ( present(str2) ) then
      outStr = ''
      if ( nElems < 1 ) return
    else
      outStr = str
      if ( nElems <= 1 ) return
    endif
    if ( LongestLen > MAXSTRELEMENTLENGTH ) then
      ! print *, 'str: ', trim(str)
      ! print *, 'len(str): ', len(str)
      ! print *, 'LongestLen: ', LongestLen
      ! print *, 'nElems: ', nElems
      call MLSMessage(MLSMSG_Error, ModuleName, &
         & "Element length too long in GetUniqueList")
      return
    end if
    ALLOCATE (inStringArray(nElems), outStringArray(nElems), STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"stringArray in GetUniqueList")
    call list2Array(str, inStringArray, countEmpty, inseparator, &
     & IgnoreLeadingSpaces)
    if ( present(str2) ) then
      nElems2 = NumStringElements(str2, countEmpty, inseparator, LongestLen)
      ALLOCATE (inStrAr2(nElems2), STAT=status)
      IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
           & MLSMSG_Allocate//"stringArray2 in GetUniqueList")
      call list2Array(str2, inStrAr2, countEmpty, inseparator, &
       & IgnoreLeadingSpaces)
      call GetUniqueStrings(inStringArray, outStringArray, noUnique, inStrAr2)
      if ( noUnique > 0 ) then
        call Array2List(outStringArray(1:noUnique), outStr, &
         & inseparator)
      else
        outStr=''
      endif
      DEALLOCATE(inStringArray, outStringArray, inStrAr2)
    else
      call GetUniqueStrings(inStringArray, outStringArray, noUnique)
      if ( noUnique > 0 ) then
        call Array2List(outStringArray(1:noUnique), outStr, &
         & inseparator)
      else
        outStr=''
      endif
      DEALLOCATE(inStringArray, outStringArray)
    endif
  END SUBROUTINE GetUniqueList

  ! ---------------------------------------------  GetUniqueStrings  -----

  ! This subroutine takes an array of strings and returns another containing
  ! only the unique entries. The resulting array is supplied by the caller
  ! If optional extra array is supplied, instead
  ! returns entries from first array not also found in second
  ! Some checking is done to make sure it's appropriate

  SUBROUTINE GetUniqueStrings(inList, outList, noUnique, extra)
    ! Dummy arguments
    CHARACTER (LEN=*), DIMENSION(:) :: inList
    CHARACTER (LEN=*), DIMENSION(:) :: outList
    INTEGER :: noUnique ! Number of unique entries
    CHARACTER (LEN=*), optional, DIMENSION(:) :: extra

    ! Local variables
    INTEGER :: i,j,k           ! Loop counters
    LOGICAL, DIMENSION(:), ALLOCATABLE :: duplicate ! Set if already found
    INTEGER :: status        ! Status from allocate

    INTEGER :: extraSize
    integer :: howManyMax
    INTEGER :: inSize

    ! Executable code, setup arrays
    inSize=SIZE(inList)
    ALLOCATE (duplicate(inSize), STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"duplicate")
    if ( present(extra) ) then
      extraSize=size(extra)
      howManyMax = inSize
      ! print *, 'SIZE(inList) ', inSize
      ! print *, 'SIZE(extra) ', extraSize
    else
      extraSize = -1
      howManyMax = inSize-1 ! Don't bother with last one
    endif
    duplicate = .FALSE.

    ! Go through and find duplicates

    DO i = 1, howManyMax
       IF (.NOT. duplicate(i)) THEN
         if ( extraSize < 1 ) then
          DO j = i+1, inSize
             IF (inList(j)==inList(i)) duplicate(j)=.TRUE.
          END DO
         else
          DO j = 1, extraSize
             IF (extra(j)==inList(i)) duplicate(i)=.TRUE.
          END DO
         endif
       END IF
    END DO

    ! Count how many unique ones there are

    noUnique=count(.NOT. duplicate)

    IF (noUnique>SIZE(outList)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "outList too small")
    IF (LEN(outList)<LEN(inList)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "outList strings to small")
    outList=""

    if ( noUnique > 0 ) then
      ! do j=1, inSize, 20
      !   print *, (duplicate(j+i), i=0, min(19, inSize-j))
      ! enddo
      j=1
      UniqueLoop: DO i = 1, noUnique
         ! UniqueHuntLoop: DO
         !   IF (.NOT. duplicate(j)) EXIT UniqueHuntLoop
         !   j=j+1
         !   if ( j > inSize ) exit UniqueLoop
         ! END DO UniqueHuntLoop
         k = findFirst(.not. duplicate(j:))
         ! print *, 'j: ', j, '   k: ', k
         if ( k+j-1 > inSize ) then
           call MLSMessage(MLSMSG_Error, ModuleName, &
             & "k goes past array end in GetUniqueStrings")
           outList(i)=inList(inSize)
           return
         elseif ( k > 0 ) then
           outList(i)=inList(k+j-1)  ! was inList(j)
           j = j + k
         else
           exit UniqueLoop
         endif
         ! j=j+1
         if ( j > inSize ) exit UniqueLoop
      END DO UniqueLoop
    endif

    DEALLOCATE(duplicate)
  END SUBROUTINE GetUniqueStrings

  ! ------------------------------------------------  hhmmss_value  -----
  Function hhmmss_value(str, ErrTyp, separator, strict) result (value)
    ! Function that returns the value in seconds of a string 'hh:mm:ss'
    ! where the field separator ':' divides the string into two
    ! integer-like strings 'hh' and 'mm', as well as one float-like
    ! string 'ss' which may have a decimal point plus fractional part
    ! E.g., ss=59.9999
    
    ! Requires 0 <= hh <= 24
    ! Requires 0 <= mm < 60
    ! Requires 0. <= ss < 60.

    ! Returns ErrTyp=0 unless an error occurs

    ! Lenient wrt utc and non-compliant formats:
    ! ignores chars in front of 'hh' and a terminal,
    ! non-numerical char: e.g., '2000-01-01T00:00:00.000000Z'
    ! will be treated the same as '00:00:00.0000000'

    ! If given optional arg strict, not lenient
    ! i.e., non-compliant str always returns non-zero ErrTyp
    
    ! If given optional arg separator, uses separator as field separator
    
    ! Useful to allow an added way to input time
    
    ! (See also PGS_TD_UTCtoTAI and mls_UTCtoTAI)
    !--------Argument--------!
    character(len=*),intent(in) :: str
    real(r8) :: value
    integer, intent(out) :: ErrTyp
    character(len=1),intent(in), optional :: separator
    logical,intent(in), optional :: strict
    !----------Local vars----------!
    character(len=1), parameter :: colon=':'
    character(len=1) :: myColon
    character(len=2) :: mm
    character(len=NameLen) :: ss
    character(len=NameLen) :: hh
    character(len=10), parameter :: digits='0123456789'
    character(LEN=*), parameter :: time_conversion='(I2)'
    character(LEN=*), parameter :: real_conversion='(F32.0)'
    integer :: i
    logical :: mystrict
    integer :: hvalue, mvalue
    !----------Executable part----------!

   if(present(separator)) then
      myColon=separator
   else
      myColon=colon
   endif
         
   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
         
   if(len_trim(str) <= 0) then
      value=0.
      if(mystrict) then
         ErrTyp=INVALIDHHMMSSSTRING
      else
         ErrTyp=0
      endif
      return
   endif
   
   ErrTyp=INVALIDHHMMSSSTRING
   value=0.
   
   call GetStringElement(str, hh, 1, countEmpty=.true., inseparator=myColon)
   call GetStringElement(str, mm, 2, countEmpty=.true., inseparator=myColon)
   call GetStringElement(str, ss, 3, countEmpty=.true., inseparator=myColon)
   
   ! Check if ss terminates in a non-digit
   ss=Reverse(trim(ss))
   
   if(len_trim(ss) <= 0) then
      if(mystrict) then
         return
      endif      
   elseif( .not. (index(digits, ss(1:1)) > 0) ) then
      if(mystrict) then
         return
      else
         ss=Reverse(trim(ss(2:)))
      endif
   else
      ss=Reverse(trim(ss))
   endif

   do i=1, len_trim(ss)
      if( .not. (index(digits, ss(i:i)) > 0 .or. ss(i:i) == '.') ) return
   enddo

   ! Check if mm complies
   if(len_trim(mm) <= 0) then
      if(mystrict) then
         return
      endif      
   else
      do i=1, len_trim(mm)
        if( .not. (index(digits, mm(i:i)) > 0) ) return
      enddo
   endif      

   ! Check if hh complies
   hh=Reverse(trim(hh))
   
   if(len_trim(hh) <= 0) then
      if(mystrict) then
         return
      endif      
   elseif(mystrict) then
      do i=1, len_trim(hh)
        if( .not. (index(digits, hh(i:i)) > 0) ) return
      enddo
   endif

   hh=Reverse(hh(:2))
   
   ErrTyp=0
   
   ! Convert to value
   if(hh == ' ') then
      hvalue=0
   else
      read(hh(1:2), time_conversion, iostat=ErrTyp) hvalue
   endif
   
   if(ErrTyp /= 0) then
      return
   elseif(hvalue < 0 .or. hvalue > 24) then
      ErrTyp=INVALIDHHMMSSSTRING
      return
   endif

   if(mm == ' ') then
      mvalue=0
   else
      read(mm, time_conversion, iostat=ErrTyp) mvalue
   endif

   if(ErrTyp /= 0) then
      return
   elseif(mvalue < 0 .or. mvalue > 59) then
      ErrTyp=INVALIDHHMMSSSTRING
      return
   endif

   ! Convert to value
   if(ss == ' ') then
      value=0
   else
      read(ss, real_conversion, iostat=ErrTyp) value
   endif
   
   if(ErrTyp /= 0) then
      return
   elseif(value < 0. .or. value > 60.) then
      ErrTyp=INVALIDHHMMSSSTRING
      return
   endif
   
   value = value + 60*(mvalue + 60*hvalue)

  end Function hhmmss_value

a309 60
  ! ---------------------------------------------  List2Array  -----

  ! This subroutine takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements and returns an equivalent array of
  ! sub-strings in which the n'th element is the n'th element

  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! If the optional arg ignoreLeadingSpaces is TRUE, "a, b, c" is
  ! treated like "a,b,c"; otherwise the leading spaces are retained

  SUBROUTINE List2Array(inList, outArray, countEmpty, inseparator, &
   & IgnoreLeadingSpaces)
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(IN)                 :: inList
    CHARACTER (LEN=*), DIMENSION(:), INTENT(OUT)  :: outArray
    LOGICAL, INTENT(IN)                           :: countEmpty
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
    LOGICAL, OPTIONAL, INTENT(IN)                 :: IgnoreLeadingSpaces

    ! Local variables
    INTEGER(i4) :: elem, nElems

    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=1), PARAMETER    :: BLANK = ' '   ! Returned for any element empty
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
    logical                         :: myIgnoreLeadingSpaces
    ! Executable code

    IF(PRESENT(inseparator)) THEN
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF

    IF(PRESENT(IgnoreLeadingSpaces)) THEN
	     myIgnoreLeadingSpaces = IgnoreLeadingSpaces
	 ELSE
	     myIgnoreLeadingSpaces = .false.
	 ENDIF

    if ( size(outArray) <= 0 ) return
    outArray = BLANK
	 elem = 1
    nElems = NumStringElements(inList, countEmpty, inseparator)
    if ( nElems <= 0 ) return
    DO
      call GetStringElement(inList, outArray(elem), elem, countEmpty, inseparator)
      if ( myIgnoreLeadingSpaces ) outArray(elem) = adjustl(outArray(elem))
      elem = elem + 1
      if ( elem > min(nElems, size(outArray)) ) return
	 ENDDO

  END SUBROUTINE List2Array

a332 72
  ! ---------------------------------------------  NumStringElements  -----

  ! This function takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements and returns the
  ! number of elements
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists
  !
  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE  

  ! As an optional arg the separator may supplied, in case it isn't comma

  ! See also GetStringElement

  FUNCTION NumStringElements(inList, countEmpty, &
   & inseparator, LongestLen) RESULT (nElements)
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(IN)             :: inList
    LOGICAL, INTENT(IN)                       :: countEmpty
	 INTEGER                                   :: nElements
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
    INTEGER, OPTIONAL, INTENT(OUT)            :: LongestLen  ! Length of longest

    ! Local variables
    INTEGER :: i, sinceLastseparated           ! Loop counters
	 LOGICAL :: lastWasNotseparated

    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
    ! Executable code

    IF(PRESENT(inseparator)) THEN
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF

	! Count the number of separators
   if ( present(LongestLen) ) &
     & LongestLen =0
	! nElements-1 = number of separators
	IF(LEN_TRIM(inList) <= 0) THEN
		nElements=0
      if ( present(LongestLen) ) LongestLen = 0
		RETURN
	ENDIF
	
	lastWasNotseparated = .FALSE.
	nElements = 1
   sinceLastseparated = 0
	DO i=1, LEN_TRIM(inList)
		IF(inList(i:i) == separator) THEN
			IF(countEmpty .OR. lastWasNotseparated) THEN
				nElements = nElements+1
            if ( present(LongestLen) ) &
             & LongestLen = max(LongestLen, sinceLastseparated)
			ENDIF
			lastWasNotseparated = .FALSE.
         sinceLastseparated = 0
		ELSE
			lastWasNotseparated = .TRUE.
         sinceLastseparated = sinceLastseparated + 1
		ENDIF
	ENDDO
   if ( present(LongestLen) ) &
     & LongestLen = max(LongestLen, sinceLastseparated)

  END FUNCTION NumStringElements

a496 232
  ! --------------------------------------------------  RemoveElemFromList  -----
  SUBROUTINE RemoveElemFromList (inList, outList, elem, inseparator)
    ! Takes a list and removes all occurrence(s) of elem
	 ! E.g., given 'a,b,c,d,..,z' and asked to remove 'c' returns 'a,b,d,..z'
    !--------Argument--------!
    CHARACTER (LEN=*), INTENT(IN) :: inList
    CHARACTER (LEN=*), INTENT(IN) :: elem
    CHARACTER (LEN=*), INTENT(OUT)                :: outList
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
    ! Method:
    ! Prepend elem onto start of list, make it unique,
    ! Then snip it back off
    !----------Local vars----------!
    character(len=len(inList)+len(elem)+1) :: temp_list, unique_list
    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=1), PARAMETER    :: BLANK = ' '   ! Returned for any element empty
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
    integer :: numUnique
    !----------Executable part----------!
    IF(PRESENT(inseparator)) THEN
      separator = inseparator
    ELSE
      separator = COMMA
    END IF

    outList = inList
    IF (LEN_trim(elem) < 1 .or. len_trim(inList) < 1 &
      & .or. StringElementNum(inList, elem, countEmpty=.true., &
    & inseparator=inseparator) < 1 ) RETURN
    temp_list = trim(elem) // separator // trim(inList)
    call GetUniqueList(temp_list, unique_list, numUnique, countEmpty=.true., &
    & inseparator=inseparator, ignoreLeadingSpaces=.true.)
    outList = unique_list(len(elem)+1:)
  END SUBROUTINE RemoveElemFromList

  ! --------------------------------------------------  ReplaceSubString  -----
  SUBROUTINE ReplaceSubString (str, outstr, sub1, sub2, which, no_trim)
    ! Takes a string and replaces occurrence(s) of sub1 with sub2
	 ! Defaults to replacing only the first
    ! But if which == 'all' replaces all
    ! or if which == 'last' replaces last
    ! Note that, depending on no_trim, 'all' does the following:
    ! (a) if no_trim == TRUE, multiple passes (up to 100) until no
    !     further replacements are possible
    !     ( which could be bad; e.g., if sub1 is 'sub1' and sub2 is 'sub11'
    !     then (blah)sub1(blah)sub1..' becomes '(blah)sub1111...' )
    ! (b) if no_trim is FALSE or missing, a single pass after chopping
    !     the string up into separate sub1-containing pieces
    !     ( e.g., '(blah)sub1(blah)sub1(blah)..' becomes
    !      '(blah)sub2(blah)sub2(blah)..' )
    !  
    ! Will this still work if sub1 has leading or trailing blanks? 
    ! How about sub2?
    ! Do we need an optional arg, no_trim, say, that will leave them?
    ! Tried coding it, but can't say for sure it works
    !--------Argument--------!
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=*), INTENT(IN) :: sub1
    CHARACTER (LEN=*), INTENT(IN) :: sub2
    CHARACTER (LEN=*) :: outstr
    character (len=*), intent(in), optional :: which
    logical, intent(in), optional :: no_trim

    !----------Local vars----------!
    integer, parameter         :: MAXREPLACEMENTS = 100
    INTEGER :: i, array_size
    character (len=5) :: my_which
    character(len=max(len(str), len(outstr))) :: head
    character(len=max(len(str), len(outstr))) :: tail
    character(len=max(len(str), len(outstr))) :: sub_str
    character(len=max(len(str), len(outstr))), dimension(MAXREPLACEMENTS) &
      &                                      :: str_array
    logical :: my_no_trim
    !----------Executable part----------!
    head = ''
    tail = ''
    sub_str = ''
    outstr = str
    IF (LEN_trim(str) < 1 .or. len_trim(sub1) < 1) RETURN
    my_which = 'first'
    if ( present(which) ) my_which = lowercase(which)
    my_no_trim = .false.
    if ( present(no_trim) ) my_no_trim = no_trim

    select case (my_no_trim)
    case (.false.)
      if ( index(str, trim(sub1)) < 1 ) return
      select case (my_which)
      case ('first')
        call Replace_me ( str, outstr, .false. )
      case ('last')
        call Replace_me ( str, outstr, .true. )
      case ('all')
        outstr = ' '
        str_array = ' '
        call Split_me
        do i=1, array_size
          ! print *, i, ' ', trim(str_array(i))
          call Replace_me ( trim(str_array(i)), sub_str, .false. )
          outstr = adjustl( trim(outstr) // sub_str )
        enddo
      end select
    case (.true.)
      if ( index(str, sub1) < 1 ) return
      select case (my_which)
      case ('first')
        call Replace_me_no_trim ( str, outstr, .false. )
      case ('last')
        call Replace_me_no_trim ( str, outstr, .true. )
      case ('all')
        ! Originally, I despaired of solving this
        ! CALL MLSMessage(MLSMSG_Error, ModuleName, &
        ! & 'Unable to ReplaceSubStrings with which=all and no_trim=TRUE yet')
        ! Then I had an idea: Why not reinterpret this as multiple passes?
        i = 0
        str_array(1) = str
        do
          i = i + 1
          ! print *, 'i ', i
          ! print *, 'str_array(1) ', str_array(1)
          call Replace_me_no_trim ( str_array(1), str_array(2), .false. )
          ! print *, 'str_array(2) ', str_array(2)
          if ( str_array(2) == str_array(1) .or. i > MAXREPLACEMENTS ) exit
          str_array(1) = str_array(2)
        enddo
        outstr = str_array(2)
      end select
    end select
    
    contains
      subroutine Replace_me ( the_orig, after_sub, back )
        ! This replaces an instance of sub1 with sub2 in
        ! the string the_orig
        ! Either the first instance (if back == FALSE) or the last
        ! Arguments
        character(len=*), intent(in)  :: the_orig
        character(len=*), intent(inout) :: after_sub
        logical, intent(in)           :: back
        ! Local variables
        integer :: istrt1, istrt2, ihead
        if ( index(the_orig, trim(sub1)) == 0 ) then
          after_sub = the_orig
          return
        endif
        istrt1 = index(the_orig, trim(sub1), back=back)
        istrt2 = istrt1 + len_trim(sub1)
        ihead = 1
        head = ' '
        tail = ' '
        if ( istrt1 > 1 ) then
          head = the_orig(1:istrt1-1)
          ihead = istrt1 - 1
        endif
        if ( istrt2 < len_trim(the_orig)+1 ) then
          tail = the_orig(istrt2:)
        endif
        ! print *, 'len(after_sub): ', len(after_sub)
        ! print *, 'len(head): ', len(head)
        ! print *, 'len(tail): ', len(tail)
        ! print *, 'head: ', trim(head), '  ihead: ', ihead
        ! print *, 'tail: ', trim(tail), len_trim(tail)
        ! print *, 'sub1: ', trim(sub1), len_trim(sub1)
        ! print *, 'sub2: ', trim(sub2), len_trim(sub2)
        if ( sub2 /= ' ' ) then
          after_sub = adjustl(head(1:ihead) // trim(sub2) // trim(tail))
        else
          after_sub = adjustl(head(1:ihead) // trim(tail))
        endif
      end subroutine Replace_me
      subroutine Replace_me_no_trim ( the_orig, after_sub, back )
        ! This replaces an instance of sub1 with sub2 in
        ! the string the_orig -- w/o trimming leading or trailing blanks
        ! Either the first instance (if back == FALSE) or the last
        ! Arguments
        character(len=*), intent(in)  :: the_orig
        character(len=*), intent(inout) :: after_sub
        logical, intent(in)           :: back
        ! Local variables
        integer :: istrt1, istrt2, ihead
        if ( index(the_orig, sub1) == 0 ) then
          after_sub = the_orig
          return
        endif
        istrt1 = index(the_orig, sub1, back=back)
        istrt2 = istrt1 + len(sub1)
        ihead = 0
        head = ' '
        tail = ' '
        if ( istrt1 > 1 ) then
          head = the_orig(1:istrt1-1)
          ihead = istrt1 - 1
        endif
        if ( istrt2 < len(the_orig)+1 ) then
          tail = the_orig(istrt2:)
        endif
        ! Now all the possibilities:
        ! (1) the_orig = sub1
        if ( ihead == 0 .and. istrt2 > len(the_orig) ) then
          after_sub = sub2
        ! (2) the_orig = (head)sub1
        elseif ( istrt2 > len(the_orig) ) then
          after_sub = head(1:ihead) // sub2
        ! (3) the_orig = sub1(tail)
        elseif ( ihead == 0 ) then
          after_sub = sub2 // tail
        ! (4) the_orig = (head)sub1(tail)
        else
          after_sub = head(1:ihead) // sub2 // tail
        endif
      end subroutine Replace_me_no_trim
      subroutine Split_me
        ! Will this still work if some of the str_arrays end in one or more ' '?
        ! Arguments (none)
        ! Local variables
        integer :: istrt1, istrt2
        array_size = 0
        istrt2 = 0
        do
          if ( istrt2 > len_trim(str) - 1 ) return
          if ( index(str(istrt2+1:), trim(sub1)) < 1 ) then
            array_size = min(array_size+1, MAXREPLACEMENTS)
            str_array(array_size) = str(istrt2+1:)
            return
          endif
          istrt1 = istrt2 + index(str(istrt2+1:), trim(sub1))
          array_size = min(array_size+1, MAXREPLACEMENTS)
          str_array(array_size) = str(istrt2+1:istrt1 + len_trim(sub1) - 1)
          istrt2 = istrt1 + len_trim(sub1) - 1
        enddo
      end subroutine Split_me
  END SUBROUTINE ReplaceSubString

a531 453
  ! --------------------------------------------------  ReverseList  -----
  FUNCTION ReverseList (str, inseparator) RESULT (outstr)
    ! takes a string list, usually comma-separated,
	 ! and returns one with elements in reversed order

	 ! E.g., given "alpha, beta, gamma" => "gamma, beta, alpha"

	 ! Limitation:
	 ! No element may be longer than MAXWORDLENGTH
    !--------Argument--------!
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator

    !----------Local vars----------!
    INTEGER(i4) :: i, istr, irev, elem, iBuf
    INTEGER, PARAMETER :: MAXWORDLENGTH=80
    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
    CHARACTER (LEN=1), DIMENSION(:), ALLOCATABLE :: charBuf
    CHARACTER (LEN=MAXWORDLENGTH) :: word
! Treat consecutive separators as if enclosing an empty element
	LOGICAL, PARAMETER :: countEmpty = .TRUE.    

    !----------Executable part----------!
    IF(PRESENT(inseparator)) THEN
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF

!  Special case--only one element of str
    outstr = str
    IF(LEN(str) == 1 .OR. INDEX(str, separator) == 0) RETURN
	 
! General case
	 ALLOCATE(charBuf(LEN(str)+1), STAT=istr)
    IF (istr /= 0) THEN
	 	CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"charBuf")
		RETURN
	ENDIF

    outstr = ' '

! Loop over elements
	elem = 1
	iBuf=0
	DO
		CALL GetStringElement(str, word, elem, countEmpty, separator)
		IF(word == separator) THEN
			EXIT
		ELSEIF(iBuf > LEN(str)) THEN
			EXIT
		ELSE
			istr = MAX(LEN_TRIM(word), 1)
			word = Reverse(word(:istr))
			DO i=1, istr
				iBuf=iBuf+1
				charBuf(iBuf) = word(i:i)
			ENDDO
			iBuf=iBuf+1
			charBuf(iBuf) = separator
			elem = elem+1
		ENDIF
	ENDDO
	
	IF(charBuf(iBuf) == separator) THEN
		iBuf = iBuf-1
	ENDIF
	
	DO i=1, iBuf
		irev = iBuf - i + 1
		outstr(irev:irev) = charBuf(i)
	ENDDO

	DEALLOCATE(charBuf)

  END FUNCTION ReverseList

  ! ---------------------------------------------  SortArray  -----

  ! This subroutine takes an array of strings
  ! and returns the array of ordered integers
  ! sorting the array; i.e., if ss[n] is the sub-string which is
  ! the n'th element, and ia[k] is the k'th element of the integer array
  ! then {psl[ia[k]]=ss[k], k=1..n} yields the properly sorted array
  ! (unless the further optional arg leftRight is also supplied and equals
  ! one of {"r", "R"} in which case {psl[k]=ss[ia[k]], k=1..n})
  ! Parallel use of ia is how you would normally 
  ! sort any other arrays associated with ss
  
  ! The sorting is ordered by ascii collating sequence:
  ! "0" < "9" < "A" < "Z" < "a" < "z"
  ! unless caseSensitive is FALSE, when "0" < "9" < "A" < "a" < "Z" < "z"

  ! As an optional arg the properly sorted array is returned, too
  ! You may safely supply the same arg for both inStrArray and sortedArray
  ! If the optional arg shorterFirst is TRUE, the sorting is modified
  ! so that shorter strings come first
  ! e.g., (/'abc', 'st', 'Z', '1'/) -> (/'1', 'Z', 'st', 'abc'/)
  
  ! If shorterFirst, leading spaces are always ignored
  ! otherwise they are always significant
  ! (See SortList for contrasting treatment options)
  !  (If you want them ignored, it's easy enough: create a tempArray
  !     tempArray(1:N) = adjustl(strArray(1:N))
  !   and pass it in instead)

  ! Method:
  ! The strings are sifted one character at a time through a series
  ! of ever-finer bins using the selection sort embodied in
  ! subroutine tie_breaker (which see; it surely can be easily improved
  ! upon, but the overall computational gains would be modest)
  ! until each bin is occupied by no more than one string
  ! The bin number is the ranking index of that string which
  ! is returned as outIntArray
  SUBROUTINE SortArray(inStrArray, outIntArray, CaseSensitive, &
   & sortedArray, shorterFirst, leftRight)
    ! Dummy arguments
    CHARACTER (LEN=*), DIMENSION(:), INTENT(IN)   :: inStrArray
    INTEGER, DIMENSION(:), INTENT(OUT)            :: outIntArray
    LOGICAL, INTENT(IN)                           :: caseSensitive
    CHARACTER (LEN=*), DIMENSION(:), OPTIONAL, INTENT(OUT)  &
     &                                            :: sortedArray
    LOGICAL, OPTIONAL, INTENT(IN)                 :: shorterFirst
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: leftRight

    ! Local variables
    INTEGER(i4) :: elem, nElems
    integer, parameter                     :: MAXCHARVALUE = 256
    integer, parameter                     :: MAXELEM = MAXSTRELEMENTLENGTH
!    integer, dimension(MAXELEM)           :: chValue, cvInvBN
!    integer, dimension(MAXELEM)           :: binNumber, invBinNumber
!    integer, dimension(MAXELEM)           :: jsort, inTheBin
    integer, dimension(:), allocatable     :: chValue, cvInvBN
    integer, dimension(:), allocatable     :: binNumber, invBinNumber 
    integer, dimension(:), allocatable     :: jsort, inTheBin
    integer                                :: numBins, oldNumBins
    integer                                :: i, bin, ck, strPos
    integer                                :: status
    integer                                :: maxStrPos
    logical                                :: allTheSameInThisBin
    logical                                :: myShorterFirst
    CHARACTER (LEN=1)                      :: theChar  
    CHARACTER (LEN=1), PARAMETER           :: BLANK = ' '
    CHARACTER (LEN=MAXSTRELEMENTLENGTH), DIMENSION(:), ALLOCATABLE    &
      &                                    :: stringArray
    CHARACTER (LEN=MAXSTRELEMENTLENGTH)    :: theString  
    CHARACTER (LEN=1)                      :: myLeftRight
    logical, parameter                     :: DeeBUG = .false.

    ! Executable code
    IF(PRESENT(shorterFirst)) THEN
	     myshorterFirst = shorterFirst
	 ELSE
	     myshorterFirst = .false.
	 ENDIF
    IF(PRESENT(leftRight)) THEN
	     myleftRight = Capitalize(leftRight)
	 ELSE
	     myleftRight = "L"
	 ENDIF

    nElems = size(inStrArray)
    if ( size(outIntArray) <= 0 .or. nElems <= 0 ) then
      return
!    elseif ( nElems > MAXELEM ) then
!       CALL MLSMessage(MLSMSG_Error, ModuleName, &
!         & 'Too many elements in inStrArray in SortArray')
!       return
    endif
!    ALLOCATE (stringArray(nElems), STAT=status)
    ALLOCATE (stringArray(nElems), chValue(nElems), cvInvBN(nElems), &
     & binNumber(nElems), invBinNumber(nElems), &
     & jsort(nElems), inTheBin(nElems), &
     & STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
         & MLSMSG_Allocate//"stringArray, etc. in SortArray")
    outIntArray = 0
    numBins = 1
    maxStrPos = 1                ! This will hold max string length needed
    do elem = 1, nElems    
      outIntArray(elem) = 1
      if ( myShorterFirst ) then
        maxStrPos = max(maxStrPos, len_trim(adjustl(inStrArray(elem))))
      else
        maxStrPos = max(maxStrPos, len_trim(inStrArray(elem)))
      endif
    enddo                  
    if ( DEEBUG ) then
      do elem = 1, nElems    
        print *, 'Array element ', elem, ' ', trim(inStrArray(elem))
      enddo                  
    endif
    do elem = 1, nElems    
      if ( myshorterFirst ) then
        ! This causes shorter strings to have more leading spaces
        ! and therefore come up first when sorted
        ! (which is why we always ignore leading spaces in inStrArray)
        theString = adjustl(inStrArray(elem))
        stringArray(elem) = adjustr(theString(1:maxStrPos))
      else
        stringArray(elem) = inStrArray(elem)
      endif
    enddo                  
    DO strPos = 1, maxStrPos
      
      if ( DEEBUG ) then
        print *, 'string position: ', strPos
        print *, 'array of bins: ', (outIntArray(elem), elem=1, nElems)
      endif
      do elem = 1, nElems
        theChar = stringArray(elem)(strPos:strPos)
        if ( stringArray(elem) == ' ' ) then
          chValue(elem) = MAXCHARVALUE
        elseif ( theChar == ' ' ) then
          chValue(elem) = 0
        elseif ( CaseSensitive ) then
          chValue(elem) = IACHAR(theChar)
        elseif (IACHAR("a") <= IACHAR(theChar) .and. &
          & IACHAR(theChar) <= IACHAR("z") ) then
          chValue(elem) = 2*IACHAR(Capitalize(theChar)) - IACHAR("A") + 1
        elseif (IACHAR("A") <= IACHAR(theChar) .and. &
          & IACHAR(theChar) <= IACHAR("Z") ) then
          chValue(elem) = 2*IACHAR(theChar) - IACHAR("A")
        elseif (IACHAR("Z") < IACHAR(theChar) ) then
          chValue(elem) = 2*IACHAR(theChar)
        else
          chValue(elem) = IACHAR(theChar)
        endif
      enddo
      if ( DEEBUG ) print *, 'array of chValues: ', (chValue(elem), elem=1, nElems)
      oldNumBins = numBins
      do elem=1, nElems
        binNumber(elem) = outIntArray(elem)
      enddo
      numBins = 0
      ck = 0
      if ( DEEBUG ) print *, 'number of bins: ', oldNumBins
      do bin=1, oldNumBins
        if ( DEEBUG ) print *, 'bin number: ', bin
        call warm_up(bin)
        if ( DEEBUG ) then
          print *, 'number in bin: ', inTheBin(bin)
          print *, 'array of invBinNumber: ', &
           & (invBinNumber(elem), elem=1, inTheBin(bin))
          print *, 'array of cvInvBN: ', (cvInvBN(elem), elem=1, inTheBin(bin))
        endif
        call tie_breaker(bin)
        if ( DEEBUG ) print *, 'array of jsort: ', (jsort(elem), elem=1, inTheBin(bin))
        numBins = numBins + 1
        ck = cvInvBN(jsort(1))
        do i=1, inTheBin(bin)
          if ( ck /= cvInvBN(jsort(i)) .or. &
           & ( &
           &  allTheSameInThisBin .and. i > 1 &
           & ) &
           & ) then
            numBins = numBins + 1
            ck = cvInvBN(jsort(i))
          endif
          outIntArray(invBinNumber(jsort(i))) = numBins
        enddo
      enddo
      if ( numBins >= min(nElems, size(outIntArray)) ) exit
	 ENDDO
    if ( DEEBUG ) then
      print *, 'Final number of bins: ', numBins
      print *, 'Sorting order: ', (outIntArray(i), i=1, nElems)
    endif

    if ( present(sortedArray) ) then
      do elem=1, nElems
        i = max(1, outIntArray(elem))
        i = min(i, nElems, size(sortedArray))
        if ( myShorterFirst ) then
          sortedArray(i) = adjustl(stringArray(elem))
        else
          sortedArray(i) = stringArray(elem)
        endif
      enddo
    endif
    if ( myLeftRight == 'R' ) then
      ! Need to 'invert' outIntArray
      do elem=1, nElems
        do i=1, nElems
          if ( outIntArray(i) == elem ) invBinNumber(elem) = i
        enddo
      enddo
      do elem=1, nElems
        outIntArray(elem) = invBinNumber(elem)
      enddo
    endif
    DEALLOCATE(stringArray, chValue, cvInvBN, binNumber, invBinNumber, &
     & jsort, inTheBin, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
         & MLSMSG_DeAllocate//"stringArray, etc. in SortArray")

   contains
     subroutine warm_up(theBin)
       ! Form array invBinNumber = {i[j], j=1 .. }
       ! such that binNumber[i] = theBin
       ! Then form cvInvBN = {c[j] = chValue[i[j]], j=1..}
       integer, intent(in) :: theBin
       integer :: j, i
       j=0
       do i=1, nElems
         if ( binNumber(i) == theBin ) then
           j=j+1
           invBinNumber(j) = i
           cvInvBN(j) = chValue(i)
         endif
       enddo
       inTheBin(theBin) = j
     end subroutine warm_up
     subroutine tie_breaker(theBin)
       ! Form array jsort = j[k] = {j_1, j_2, .., j_N}
       ! sorted so that c[j_1} <= c[j_2] <= .. <= c{j_N]
       ! This is a naive selection sort--make any improvements you wish
       ! (Order N^2 sorting algorithms are inefficient)
       integer, intent(in)      :: theBin
       integer                  :: kp, k, ck, jsortie
       CHARACTER (LEN=MAXSTRELEMENTLENGTH)  :: stringElement  
       allTheSameInThisBin = (inTheBin(theBin) /= 1)
       stringElement = stringArray(invBinNumber(1))
       do k=1, inTheBin(theBin)
         jsort(k) = k
         allTheSameInThisBin = allTheSameInThisBin .and. &
           & stringElement == stringArray(invBinNumber(k))
       enddo
       if ( inTheBin(theBin) == 1 .or. allTheSameInThisBin) return
       do k=1, inTheBin(theBin) - 1
         ck = cvInvBN(jsort(k))
         do kp=k+1, inTheBin(theBin)
           if ( cvInvBN(jsort(kp)) < ck ) then
           ! Pull the old switcheroo
             ck = cvInvBN(jsort(kp))
             jsortie = jsort(kp)
             jsort(kp) = jsort(k)
             jsort(k) = jsortie
           endif
         enddo
       enddo
     end subroutine tie_breaker

  END SUBROUTINE SortArray

  ! ---------------------------------------------  SortList  -----

  ! This subroutine takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements and returns the array of ordered integers
  ! sorting the list; i.e., if ss[n] is the sub-string which is
  ! the n'th element, and ia[k] is the k'th element of the integer array
  ! then {psl[ia[k]]=ss[k], k=1..n} yields the properly sorted list
  ! (unless the further optional arg leftRight is also supplied and equals
  ! one of {"r", "R"} in which case {psl[k]=ss[ia[k]], k=1..n})
  ! Parallel use of ia is how you would normally 
  ! sort any other arrays associated with ss
  
  ! The sorting is ordered by ascii collating sequence:
  ! "0" < "9" < "A" < "Z" < "a" < "z"
  ! unless caseSensitive is FALSE, when "0" < "9" < "A" < "a" < "Z" < "z"

  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the properly sorted list is returned, too
  ! You may safely supply the same arg for both inList and sortedList
  ! As an optional arg the separator may supplied, in case it isn't comma
  ! If the optional arg ignoreLeadingSpaces is TRUE, "a, b, c" is
  ! sorted like "a,b,c"; otherwise the leading spaces make" b, c,a"

  ! Method:
  ! (see SortArray)
  SUBROUTINE SortList(inList, outArray, CaseSensitive, countEmpty, &
   & ignoreLeadingSpaces, inseparator, sortedList, leftRight)
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(IN)                 :: inList
    INTEGER, DIMENSION(:), INTENT(OUT)            :: outArray
    LOGICAL, INTENT(IN)                           :: CaseSensitive
    LOGICAL, INTENT(IN)                           :: countEmpty
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
    CHARACTER (LEN=*), OPTIONAL, INTENT(OUT)      :: sortedList
    LOGICAL, OPTIONAL, INTENT(IN)                 :: IgnoreLeadingSpaces
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: leftRight

    ! Local variables
    integer, parameter              :: MAXELEM = MAXSTRELEMENTLENGTH
    INTEGER(i4) :: nElems, status, LongestLen

    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
    CHARACTER (LEN=MAXSTRELEMENTLENGTH), DIMENSION(:), ALLOCATABLE    &
      &                             :: stringArray
    CHARACTER (LEN=1)               :: myLeftRight
    logical, parameter              :: DeeBUG = .false.
    ! Executable code
    IF(PRESENT(inseparator)) THEN
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF

    IF(PRESENT(leftRight)) THEN
	     myleftRight = Capitalize(leftRight)
	 ELSE
	     myleftRight = "L"
	 ENDIF

    if ( DEEBUG ) then
       print *, 'Entered SortList'
       print *, 'present(inseparator)?: ', PRESENT(inseparator)
       print *, 'separator: ', separator
       print *, 'string: ', trim(inList)
    endif
    if ( size(outArray) <= 0 ) return
    outArray = 0
    nElems = NumStringElements(inList, countEmpty, inseparator, LongestLen)
    if ( nElems <= 0 ) then
      return
    elseif ( LongestLen > MAXSTRELEMENTLENGTH ) then
      call MLSMessage(MLSMSG_Error, ModuleName, &
         & "Element length too long in SortList")
      return
!    elseif ( nElems > MAXELEM ) then
!      call MLSMessage(MLSMSG_Error, ModuleName, &
!         & "Too many elements needed in SortList")
!      return
    endif
    ALLOCATE (stringArray(nElems), STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"stringArray in SortList")
    call list2Array(inList, stringArray, countEmpty, inseparator, &
     & IgnoreLeadingSpaces)
    call SortArray(stringArray(1:nElems), outArray, CaseSensitive, &
     & leftRight=leftRight)
    if ( present(sortedList) ) then
      if ( myLeftRight == 'R' ) then
        call Array2List(stringArray(1:nElems), sortedList, &
         & inseparator, outArray, leftRight='R')
      else
        call Array2List(stringArray(1:nElems), sortedList, &
         & inseparator, outArray, leftRight='L')
      endif
    endif
    DEALLOCATE(stringArray)

  END SUBROUTINE SortList

a648 631
  ! ---------------------------------------------  StringElementNum  -----

  ! This function takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements, and a test string which may be an element
  ! It returns the element number of the test string in the string list
  ! or, 0 if the test string is not found
  
  ! Any leading blanks are disregarded before making the comparison;
  ! e.g., 'stare' is the same as ' stare' and is the second element of 
  ! the list 'lex, stare, decisis'
  
  ! Note: if there are multiple matches between the test string and elements
  ! of inList we return only the first
  
  ! If you want the last instead, use ReverseList on inList && subtract
  ! the answer from nElements
  
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists
  
  ! It will be the immediate precursor function in a hash table
  ! == aka associative array == aka dictionary
  !
  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE  

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! Another optional arg, part_match, returns the number of the 
  ! first element merely found in the test string; e.g.
  ! 'won, to, tree' and test 'protocol.dat' returns 2

  ! See also GetStringElement, NumStringElements

  FUNCTION StringElementNum(inList, test_string, countEmpty, &
    & inseparator, part_match) RESULT (elem)
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(IN)             :: inList
    CHARACTER (LEN=*), INTENT(IN)             :: test_string
    LOGICAL, INTENT(IN)                       :: countEmpty
	 INTEGER                                   :: elem
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
    LOGICAL, OPTIONAL, INTENT(IN)             :: part_match

    ! Local variables
    INTEGER :: nElements
    INTEGER , PARAMETER :: MAXELEMENTLENGTH = 80

    CHARACTER (LEN=MAXELEMENTLENGTH)           :: listElement
    logical ::                                    match
!    CHARACTER (LEN=1)                          :: separator
!    CHARACTER (LEN=1), PARAMETER               :: COMMA = ','
    ! Executable code

	nElements = NumStringElements(inList, countEmpty, inseparator)
	
	IF(nElements <= 0) THEN
		elem = 0
		RETURN
	ENDIF
   match = .false.
   if ( present(part_match) ) match = part_match

	! Check for matches--snipping off any leading blanks
	DO elem=1, nElements
		CALL GetStringElement(inList, listElement, elem, countEmpty, inseparator)
      if ( match ) then
        if (trim(listElement) /= ' ' .and. &
          & index(trim(test_string), trim(listElement)) > 0) RETURN
      else
  	     IF(adjustl(listElement) == adjustl(test_string)) RETURN
      endif
	ENDDO
	
	elem = 0

  END FUNCTION StringElementNum

  ! ------------------------------------------------  unquote  -----
  Function unquote(str, quotes, cquotes, strict, stripany) result (outstr)
    ! Function that removes a single pair of surrounding quotes from string

    ! E.g., given "Let me see." or 'Let me see.' returns
    !    Let me see.
    ! If no surrounding quotes are found, returns string unchanged; unless
    ! (1) mismatched quotes, e.g. 'Let me see." will:
    !     remove leading quote but leave trailing quote
    ! (2) a single unpaired quote found at beginning or end, will:
    !  (a) remove it if the resulting string is non-empty; or
    !  (b) return the single unpaired quote if that was the entire str
    
    ! If given optional arg strict, options (1) and (2) above disregarded
    ! i.e., surrounding quotes must match, else returns string unchanged
    
    ! If given optional arg stripany, any quotes, surrounding or internal,
    ! will be removed
    
    ! If given optional arg quotes, removes only surrounding pair:
    ! quotes[i:i] for each i=1..len[quotes]
    ! E.g., given /a\ regexp/ with quotes='/' returns
    !    a\ regexp
    
    ! If given optional args quotes & cquotes, removes only surrounding pair:
    ! quotes[i:i] on the left, cquotes[i:i] on the right, i=1..len[quotes]
    ! E.g., given [a particle] with quotes='[' cquotes=']' returns
    !    a particle
    ! (For this case, strict matching is always on)
    
    ! Useful because the parser will return quote-surrounded strings if that's
    ! how they appear in the lcf
    
    ! Calling get_string with "strip=.true." renders this unnecessary.
    ! However, you might find another use for it, especially with
    ! feature of being able to trim other, user-supplied detritus:
    ! e.g., braces, parentheses, extraneous separators
    
    ! (Aside from switches, we haven't found such a use so far;
    ! instead see more powerful ExtractSubString or ReplaceSubString)
    !--------Argument--------!
    character(len=*),intent(in) :: str
    character(len=len(str)) :: outstr, tmpstr
    character(len=*),intent(in), optional :: quotes
    character(len=*),intent(in), optional :: cquotes
    logical,intent(in), optional :: strict
    logical,intent(in), optional :: stripany
    !----------Local vars----------!
    character(len=1), parameter :: sq=''''
    character(len=1), parameter :: dq='"'
    integer :: first, last, ult, prim
    character(len=1) :: quote, cquote
    integer :: i
    logical :: mystrict
    logical :: mystripany
    !----------Executable part----------!

   ult = len_trim(str)    ! Position of last non-blank char
   prim = ult - len_trim(adjustl(str)) + 1    ! Position of 1st non-blank char
   outstr=str
      
   ! length of non-blank portion of string to be trimmed must be at least 2
   if(ult-prim+1 <= 1) then
      outstr=str
      return
   endif

   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
   
   if(present(stripany)) then
      mystripany=stripany
   else
      mystripany=.false.
   endif
   
   ! These are initialized so that if no matching quotes found
   ! we will return    outstr = adjustl(str)
   first = prim
   last = ult

   ! trim surrounding user-supplied marks?

   if(present(quotes)) then
      if(len_trim(quotes) <= 0) then
       outstr=str
       return
      endif
      
      ! Loop over char class in string quotes
      do i=1, len_trim(quotes)
      
         quote = quotes(i:i)
         
         ! Stripany option in force?
         if ( mystripany ) then
            ! print *, 'Replacing ', quote, ' in ', trim(outstr)
            call ReplaceSubString(outstr, tmpstr, quote, '', 'all')
            outstr = tmpstr
            ! print *, trim(outstr)
            cycle
         endif

         ! Supplied with paired left and right quotes?
         if(present(cquotes)) then
            cquote=cquotes(i:i)
            mystrict=.true.
         else
            cquote=quote
         endif

         if(mystrict) then
           if(str(prim:prim) == quote .and. str(ult:ult) == cquote) then
               outstr=str(prim+1:ult-1)
               return
          endif
      
        else
         if(str(prim:prim) == quote) then
           first=prim+1
          endif

          if(str(ult:ult) == cquote) then
             last=ult-1
           endif
        endif

      enddo

   ! insist surrounding marks match?
   elseif(present(strict)) then
      if( &
      & str(prim:prim) == str(ult:ult) &
      & .and. &
        & (str(prim:prim) == sq .or. str(prim:prim) == dq) &
        & ) then
            outstr=str(prim+1:ult-1)
          else
            outstr=str
          endif
         return
      
   elseif(str(prim:prim) == sq) then
      first=prim+1
      if(str(ult:ult) == sq) then
         last=ult-1
      endif
      
   elseif(str(prim:prim) == dq) then
      first=prim+1
      if(str(ult:ult) == dq) then
         last=ult-1
      endif

   else
      first=prim
      if(str(ult:ult) == dq .or. str(ult:ult) == sq) then
         last=ult-1
      endif

   endif
   if ( mystripany ) then
       return
   elseif(last >= first) then
       outstr=str(first:last)
   else
       outstr=str
   endif
      
  end Function unquote

  ! ---------------------------------------------  utc_to_yyyymmdd_ints  -----
  subroutine utc_to_yyyymmdd_ints(str, ErrTyp, year, month, day, strict, nodash)
    ! Routine that returns the year, month, and day from a string of the form
    ! (A) yyyy-mm-ddThh:mm:ss.sss
    ! (B) yyyy-dddThh:mm:ss.sss
    ! where the field separator 'T' divides the string into two
    ! sub-strings encoding the date and time
    ! The date substring in subdivided by the separator '-'
    ! into either two or three fields
    ! In case (A), the 3 fields are year, month, and day of month
    ! in case (B) the two fields are year and day of year
    
    ! For case (A) returns year, month, and day=day of month
    ! For case (B) returns year, month=-1, and day=day of year
    ! Useful to decode utc inputs into attribute values
    
    ! (See also PGS_TD_UTCtoTAI and mls_UTCtoTAI)
    !--------Argument--------!
    character(len=*),intent(in) :: str
    integer, intent(out) :: ErrTyp
    integer, intent(out) :: year
    integer, intent(out) :: month
    integer, intent(out) :: day
    logical, intent(in), optional :: strict
    logical, intent(in), optional :: nodash   ! No dash separating date fields
    !----------Local vars----------!
    character(len=1), parameter :: dash='-'
    character(len=NameLen) :: date
    character(len=NameLen) :: yyyy
    character(len=NameLen) :: mm
    character(len=NameLen) :: dd
    character(LEN=*), parameter :: time_conversion='(I4)'
    logical :: mystrict
    logical :: mynodash
    character(len=1) :: utc_format        ! 'a' or 'b'
    ! The following arrys contains the maximum permissible day for each month
    ! where month=-1 means the whole year, month=1..12 means Jan, .., Dec
    integer, dimension(-1:12), parameter :: DAYMAX = (/ &
      & 366, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &
      & /)
    !----------Executable part----------!

   year = -1
   month = -1
   day = -1
   mm = ' '

   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
         
   if(present(nodash)) then
      mynodash=nodash
   else
      mynodash=.false.
   endif
         
   if(len_trim(str) <= 0) then
      if(mystrict) then
         ErrTyp=INVALIDUTCSTRING
      else
         ErrTyp=0
      endif
      return
   endif
   
   ErrTyp=INVALIDUTCSTRING
   ! Snip off time fields from date fields
   call GetStringElement(lowercase(str), date, 1, &
     & countEmpty=.true., inseparator='t')
   if ( date == ' ' ) then
     if ( .not. mystrict) Errtyp = 0
     return
   endif
   if ( myNoDash ) then
     yyyy = date(1:4)
     mm = date(5:6)
     dd = date(7:8)
   else
     call GetStringElement(trim(date), yyyy, 1, countEmpty=.true., inseparator=dash)
     if ( &
       & NumStringElements(trim(date), countEmpty=.true., inseparator=dash) == 2) then
       call GetStringElement(trim(date), dd, 2, countEmpty=.true., inseparator=dash)
       utc_format = 'b'
     else
       call GetStringElement(trim(date), mm, 2, countEmpty=.true., inseparator=dash)
       call GetStringElement(trim(date), dd, 3, countEmpty=.true., inseparator=dash)
       utc_format = 'a'
     endif
   endif
   
   ErrTyp=0
   
   ! Convert to value
   if(yyyy /= ' ') then
      read(yyyy, time_conversion, iostat=ErrTyp) year
   endif
   
   if(ErrTyp /= 0) then
      return
   elseif(year < 0 .or. year > YEARMAX) then
      ErrTyp=INVALIDUTCSTRING
      return
   endif

   if(mm /= ' ') then
      read(mm, time_conversion, iostat=ErrTyp) month
   endif

   if(utc_format == 'b') then
     ErrTyp = 0
     month = -1
   elseif(ErrTyp /= 0) then
      return
   elseif(month < 1 .or. month > 12) then
      ErrTyp=INVALIDUTCSTRING
      return
   endif
   ! Coming out of the above, month should be in the interval [-1, 12]

   if(dd /= ' ') then
      read(dd, time_conversion, iostat=ErrTyp) day
   endif

   if(ErrTyp /= 0) then
      return
   elseif(day < 1 .or. day > DAYMAX(month)) then
      ErrTyp=INVALIDUTCSTRING
      return
   endif
  end subroutine utc_to_yyyymmdd_ints

  ! ---------------------------------------------  utc_to_yyyymmdd_strs  -----
  subroutine utc_to_yyyymmdd_strs(str, ErrTyp, year, month, day, &
    & strict, utcAt0z)
    ! Routine that returns the year, month, and day from a string of the form
    ! (A) yyyy-mm-ddThh:mm:ss.sss
    ! (B) yyyy-dddThh:mm:ss.sss
    ! where the field separator 'T' divides the string into two
    ! sub-strings encoding the date and time
    ! The date substring in subdivided by the separator '-'
    ! into either two or three fields
    ! In case (A), the 3 fields are year, month, and day of month
    ! in case (B) the two fields are year and day of year
    
    ! For case (A) returns year, month, and day=day of month
    ! For case (B) returns year, month=-1, and day=day of year
    ! Useful to decode utc inputs into attribute values
    
    ! Optionally returns the input string in utcAt0z modified so that 
    ! the hh:mm:ss.sss is 00:00:00Z
    
    ! (See also PGS_TD_UTCtoTAI and mls_UTCtoTAI)
    !--------Argument--------!
    character(len=*),intent(in)   :: str
    integer, intent(out)          :: ErrTyp
    character(len=*), intent(out) :: year
    character(len=*), intent(out) :: month
    character(len=*), intent(out) :: day
    logical,intent(in), optional  :: strict
    character(len=*),intent(out), optional   :: utcAt0z
    !----------Local vars----------!
    character(len=1), parameter :: dash='-'
    character(len=NameLen) :: date
    logical :: mystrict
    character(len=1) :: utc_format        ! 'a' or 'b'
    character(len=*), parameter :: chars_0z = 'T00:00:00Z'
    !----------Executable part----------!

   year = ' '
   month = ' '
   day = ' '

   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
         
   if(len_trim(str) <= 0) then
      if(mystrict) then
         ErrTyp=INVALIDUTCSTRING
      else
         ErrTyp=0
      endif
      return
   endif
   
   ErrTyp=INVALIDUTCSTRING
   ! Snip off time fields from date fields
   call GetStringElement(lowercase(str), date, 1, &
     & countEmpty=.true., inseparator='t')
   if ( date == ' ' ) then
     if ( .not. mystrict) Errtyp = 0
     if ( present(utcAt0z) ) utcAt0z = ' '
     return
   endif
   if ( present(utcAt0z) ) utcAt0z = trim(date) // chars_0z
   call GetStringElement(trim(date), year, 1, countEmpty=.true., inseparator=dash)
   if ( &
     & NumStringElements(trim(date), countEmpty=.true., inseparator=dash) == 2) then
     call GetStringElement(trim(date), day, 2, countEmpty=.true., inseparator=dash)
     utc_format = 'b'
   else
     call GetStringElement(trim(date), month, 2, countEmpty=.true., inseparator=dash)
     call GetStringElement(trim(date), day, 3, countEmpty=.true., inseparator=dash)
     utc_format = 'a'
   endif
   
   ErrTyp=0
   
  end subroutine utc_to_yyyymmdd_strs

  ! ---------------------------------------------  yyyymmdd_to_dai_ints  -----
  subroutine yyyymmdd_to_dai_ints(yyyy, mm, dd, dai, startingDate)
    ! Routine that returns the number of days after a starting date
    ! from 3 ints: the form yyyymmdd
    !--------Argument--------!
    integer ,intent(in) :: yyyy
    integer ,intent(in) :: mm
    integer ,intent(in) :: dd
    integer,intent(out) :: dai
    character(len=*),intent(in),optional :: startingDate  ! If not Jan 1 2001
    !----------Local vars----------!
    character(len=8) :: mystartingDate
    integer :: yyyy1, mm1, dd1, doy1
    integer :: yyyy2, doy2
    integer :: ErrTyp
    logical :: daiNegative
    integer :: y
    !----------Executable part----------!
   if(present(startingDate)) then
      mystartingDate=startingDate
   else
      mystartingDate='20010101'
   endif
   call utc_to_yyyymmdd_ints(mystartingDate, ErrTyp, yyyy1, mm1, dd1, nodash=.true.)
   call yyyymmdd_to_doy_str(mystartingDate, doy1)
   call yyyymmdd_to_doy_ints(yyyy, mm, dd, doy2)
   yyyy2 = yyyy
   daiNegative = yyyy1 > yyyy2
   if ( daiNegative ) then
     call switch(yyyy1, yyyy2)
     call switch(doy1, doy2)
   elseif ( yyyy1 == yyyy2 ) then
     dai = doy2 - doy1
     return
   endif
   dai = doy2 - doy1
   do y = yyyy1, yyyy2 - 1
     if ( leapyear(y) ) then
       dai = dai + DAYMAXLY(-1)
     else
       dai = dai + DAYMAXNY(-1)
     endif
   enddo
   if ( daiNegative ) dai = -dai
  end subroutine yyyymmdd_to_dai_ints

  ! ---------------------------------------------  yyyymmdd_to_dai_str  -----
  subroutine yyyymmdd_to_dai_str(str, dai, startingDate)
    ! Routine that returns the number of days after a starting date
    ! from a string of the form yyyymmdd
    !--------Argument--------!
    character(len=*),intent(in) :: str
    integer,intent(out) :: dai
    character(len=*),intent(in),optional :: startingDate  ! If not Jan 1 2001
    !----------Local vars----------!
    character(len=8) :: mystartingDate
    integer :: yyyy1, mm1, dd1, doy1
    integer :: yyyy2, mm2, dd2, doy2
    integer :: ErrTyp
    logical :: daiNegative
    integer :: y
    !----------Executable part----------!
   if(present(startingDate)) then
      mystartingDate=startingDate
   else
      mystartingDate='20010101'
   endif
   call utc_to_yyyymmdd_ints(mystartingDate, ErrTyp, yyyy1, mm1, dd1, nodash=.true.)
   call utc_to_yyyymmdd_ints(str, ErrTyp, yyyy2, mm2, dd2, nodash=.true.)
   call yyyymmdd_to_doy_str(mystartingDate, doy1)
   call yyyymmdd_to_doy_str(str, doy2)
   daiNegative = yyyy1 > yyyy2
   if ( daiNegative ) then
     call switch(yyyy1, yyyy2)
     call switch(doy1, doy2)
   elseif ( yyyy1 == yyyy2 ) then
     dai = doy2 - doy1
     return
   endif
   dai = doy2 - doy1
   do y = yyyy1, yyyy2 - 1
     if ( leapyear(y) ) then
       dai = dai + DAYMAXLY(-1)
     else
       dai = dai + DAYMAXNY(-1)
     endif
   enddo
   if ( daiNegative ) dai = -dai
  end subroutine yyyymmdd_to_dai_str

!=============================================================================
  ! ---------------------------------------------  switch_ints  -----
  subroutine switch_ints(x1, x2)
    ! Switch args x1 <=> x2
    !--------Argument--------!
    integer,intent(inout) :: x1
    integer,intent(inout) :: x2
    !----------Local vars----------!
    integer :: x
    x = x1
    x1 = x2
    x2 = x
  end subroutine switch_ints

  ! ---------------------------------------------  yyyymmdd_to_doy_ints  -----
  subroutine yyyymmdd_to_doy_ints(year, month, day, doy)
    ! Routine that returns the number of days after the year's start
    ! for year, month, day
    !--------Argument--------!
    integer, intent(in) :: year, month, day
    integer, intent(out) :: doy
    !----------Local vars----------!
    integer :: ErrTyp
    integer :: m
    integer, dimension(-1:12) :: DAYMAX
    !----------Executable part----------!
     if ( year < 0 .or. year > YEARMAX ) then
       doy = -1
     endif
     doy = day
     if ( month <= 1 ) then
       return
     endif
     if ( leapyear(year) ) then
       DAYMAX = DAYMAXLY
     else
       DAYMAX = DAYMAXNY
     endif
     do m=1, month-1
       doy = doy + DAYMAX(m)
     enddo
     
  end subroutine yyyymmdd_to_doy_ints

  ! ---------------------------------------------  yyyymmdd_to_doy_str  -----
  subroutine yyyymmdd_to_doy_str(str, doy)
    ! Routine that returns the number of days after the year's start
    ! for a string of the form yyyymmdd
    !--------Argument--------!
    character(len=*),intent(in) :: str
    integer,intent(out) :: doy
    !----------Local vars----------!
    integer :: year, month, day
    integer :: ErrTyp
    integer :: m
    integer, dimension(-1:12) :: DAYMAX
    !----------Executable part----------!
     call utc_to_yyyymmdd_ints(str, ErrTyp, year, month, day, nodash=.true.)
     call yyyymmdd_to_doy_ints(year, month, day, doy)
  end subroutine yyyymmdd_to_doy_str

  logical function leapyear(year)
    integer,intent(in) :: year
     ! This is to capture rule that centuries are leap only
     ! if divisible by 400
     ! Otherwise, as prehaps you knew, leapyears are those years divisible by 4
     if ( 100 * (year/100) >= year ) then
       leapyear = ( 400 * (year/400) >= year )
     else
       leapyear = ( 4 * (year/4) >= year )
     endif
  end function leapyear

d657 3
@


2.43
log
@Make lowerCase elemental
@
text
@d18 1
a18 1
       "$Id: MLSStrings.f90,v 2.42 2004/06/16 01:25:08 vsnyder Exp $"
d42 1
d44 1
a44 1
! count_words        Counts the number of space-delimited words in a string
d80 1
a80 1
!   & [char inDelim], [int ordering], [char leftRight]) 
d82 1
d89 1
a89 1
!   int ErrType, log countEmpty, [char inDelim], [log part_match])
d91 1
a91 1
!   i4 nElement, log countEmpty, [char inDelim])
d93 1
a93 1
!   char* outElement, log countEmpty, [char inDelim], [log part_match])
d95 1
a95 1
!   & log countEmpty, [char inDelim], [log IgnoreLeadingSpaces]) 
d101 1
a101 1
! List2Array (strlist inList, char* outArray(:), log countEmpty, [char inDelim],
d105 1
a105 1
!   & [char inDelim], [int LongestLen])
d112 1
a112 1
! strlist ReverseList (strlist str, [char inDelim])
d116 1
a116 1
!   & log countEmpty, [char inDelim], [log IgnoreLeadingSpaces], 
d122 1
a122 1
!    & [char inDelim], [log part_match])
d125 1
a125 1
! in the above, a string list is a string of elements (usu. comma-delimited)
d147 1
a147 1
  public :: Array2List, Capitalize, CompressString, count_words, &
d198 1
a198 1
  ! This subroutine returns a (usually) comma-delimited string list, interpreted it
d202 1
a202 1
  ! As an optional arg the delimiter may supplied, in case it isn't a comma
d209 1
a209 1
  SUBROUTINE Array2List ( inArray, outList, inDelim, ordering, leftRight )
d213 1
a213 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inDelim
d220 1
a220 1
    CHARACTER (LEN=1)               :: Delim
d226 2
a227 2
    IF(PRESENT(inDelim)) THEN
      Delim = inDelim
d229 1
a229 1
      Delim = COMMA
d258 1
a258 1
        outList = trim(outList) // Delim // trim(inArray(arrayElem))
d289 31
d551 1
a551 1
      & inDelim=separator )
d557 1
a557 1
  ! This function takes one (usually) comma-delimited string list, interprets it
d566 1
a566 1
  ! comma-delimited lists
d568 1
a568 1
  ! If countEmpty is TRUE, consecutive delimiters, with no chars in between,
d570 1
a570 1
  ! Otherwise, they are treated the same as a single delimiter
d574 1
a574 1
  ! As an optional arg the delimiter may supplied, in case it isn't comma
d583 1
a583 1
  & countEmpty, inDelim, part_match) RESULT (hashInt)
d591 1
a591 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inDelim
d600 1
a600 1
	elem = StringElementNum(keyList, key, countEmpty, inDelim, part_match)
d614 1
a614 1
  ! This subroutine takes a (usually) comma-delimited string list, interprets it
d617 1
a617 1
  ! if n is too large or small, it returns the delimiter
d619 1
a619 1
  ! comma-delimited lists
d621 1
a621 1
  ! If countEmpty is TRUE, consecutive delimiters, with no chars in between,
d623 1
a623 1
  ! Otherwise, they are treated the same as a single delimiter
d627 1
a627 1
  ! As an optional arg the delimiter may supplied, in case it isn't comma
d630 1
a630 1
  SUBROUTINE GetStringElement(inList, outElement, nElement, countEmpty, inDelim)
d636 1
a636 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inDelim
d640 1
a640 1
    INTEGER(i4) :: elem, nextDelim
d642 1
a642 1
    CHARACTER (LEN=1)               :: Delim
d647 2
a648 2
    IF(PRESENT(inDelim)) THEN
	     Delim = inDelim
d650 1
a650 1
	     Delim = COMMA
d654 1
a654 1
	     outElement = Delim
d656 1
a656 1
	     outElement = Delim
d661 1
a661 1
	     nextDelim = i - 1 + INDEX(inList(i:), Delim)
d663 2
a664 2
	! No more delimiters
		  IF(nextDelim == i - 1) THEN
d668 1
a668 1
				    outElement = Delim
d672 2
a673 2
	! Next delimiter is the adjacent char
			ELSEIF(nextDelim == i) THEN
d683 1
a683 1
	! Until next delimiter is the next element
d686 2
a687 2
				    IF(i < nextDelim) THEN
				       outElement = inList(i:nextDelim-1)
d689 1
a689 1
				       outElement = Delim
d692 2
a693 2
			    ELSEIF(nextDelim >= LEN(inList)) THEN
				    outElement = Delim
d699 1
a699 1
			i = nextDelim+1
d706 1
a706 1
  ! This subroutine takes two (usually) comma-delimited string lists, interprets it
d710 1
a710 1
  ! If the key is not found in the array of keys, it returns the delimiter
d713 1
a713 1
  ! comma-delimited lists
d715 1
a715 1
  ! If countEmpty is TRUE, consecutive delimiters, with no chars in between,
d717 1
a717 1
  ! Otherwise, they are treated the same as a single delimiter
d721 1
a721 1
  ! As an optional arg the delimiter may supplied, in case it isn't comma
d733 1
a733 1
  & countEmpty, inDelim, part_match)
d740 1
a740 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inDelim
d745 1
a745 1
    CHARACTER (LEN=1)                          :: Delim
d750 2
a751 2
    IF(PRESENT(inDelim)) THEN
	     Delim = inDelim
d753 1
a753 1
	     Delim = COMMA
d756 1
a756 1
	elem = StringElementNum(keyList, key, countEmpty, inDelim, part_match)
d758 1
a758 1
		outElement = Delim
d761 1
a761 1
        & countEmpty, inDelim)
d776 1
a776 1
    & inDelim, IgnoreLeadingSpaces, str2)
d782 1
a782 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inDelim
d787 1
a787 1
    CHARACTER (LEN=1)               :: Delim
d797 2
a798 2
    IF(PRESENT(inDelim)) THEN
      Delim = inDelim
d800 1
a800 1
      Delim = COMMA
d803 1
a803 1
    nElems = NumStringElements(str, countEmpty, inDelim, LongestLen)
d824 1
a824 1
    call list2Array(str, inStringArray, countEmpty, inDelim, &
d827 1
a827 1
      nElems2 = NumStringElements(str2, countEmpty, inDelim, LongestLen)
d831 1
a831 1
      call list2Array(str2, inStrAr2, countEmpty, inDelim, &
d836 1
a836 1
         & inDelim)
d845 1
a845 1
         & inDelim)
d1023 3
a1025 3
   call GetStringElement(str, hh, 1, countEmpty=.true., inDelim=myColon)
   call GetStringElement(str, mm, 2, countEmpty=.true., inDelim=myColon)
   call GetStringElement(str, ss, 3, countEmpty=.true., inDelim=myColon)
d1247 1
a1247 1
  ! This subroutine takes a (usually) comma-delimited string list, interprets it
d1251 1
a1251 1
  ! If countEmpty is TRUE, consecutive delimiters, with no chars in between,
d1253 1
a1253 1
  ! Otherwise, they are treated the same as a single delimiter
d1257 1
a1257 1
  ! As an optional arg the delimiter may supplied, in case it isn't comma
d1261 1
a1261 1
  SUBROUTINE List2Array(inList, outArray, countEmpty, inDelim, &
d1267 1
a1267 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inDelim
d1273 1
a1273 1
    CHARACTER (LEN=1)               :: Delim
d1279 2
a1280 2
    IF(PRESENT(inDelim)) THEN
	     Delim = inDelim
d1282 1
a1282 1
	     Delim = COMMA
d1294 1
a1294 1
    nElems = NumStringElements(inList, countEmpty, inDelim)
d1297 1
a1297 1
      call GetStringElement(inList, outArray(elem), elem, countEmpty, inDelim)
d1330 1
a1330 1
  ! This function takes a (usually) comma-delimited string list, interprets it
d1334 1
a1334 1
  ! comma-delimited lists
d1336 1
a1336 1
  ! If countEmpty is TRUE, consecutive delimiters, with no chars in between,
d1338 1
a1338 1
  ! Otherwise, they are treated the same as a single delimiter
d1341 1
a1341 1
  ! As an optional arg the delimiter may supplied, in case it isn't comma
d1346 1
a1346 1
   & inDelim, LongestLen) RESULT (nElements)
d1351 1
a1351 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inDelim
d1355 2
a1356 2
    INTEGER :: i, sinceLastDelim           ! Loop counters
	 LOGICAL :: lastWasNotDelim
d1358 1
a1358 1
    CHARACTER (LEN=1)               :: Delim
d1362 2
a1363 2
    IF(PRESENT(inDelim)) THEN
	     Delim = inDelim
d1365 1
a1365 1
	     Delim = COMMA
d1368 1
a1368 1
	! Count the number of delimiters
d1371 1
a1371 1
	! nElements-1 = number of delimiters
d1378 1
a1378 1
	lastWasNotDelim = .FALSE.
d1380 1
a1380 1
   sinceLastDelim = 0
d1382 2
a1383 2
		IF(inList(i:i) == Delim) THEN
			IF(countEmpty .OR. lastWasNotDelim) THEN
d1386 1
a1386 1
             & LongestLen = max(LongestLen, sinceLastDelim)
d1388 2
a1389 2
			lastWasNotDelim = .FALSE.
         sinceLastDelim = 0
d1391 2
a1392 2
			lastWasNotDelim = .TRUE.
         sinceLastDelim = sinceLastDelim + 1
d1396 1
a1396 1
     & LongestLen = max(LongestLen, sinceLastDelim)
d1565 1
a1565 1
  SUBROUTINE RemoveElemFromList (inList, outList, elem, inDelim)
d1572 1
a1572 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inDelim
d1578 1
a1578 1
    CHARACTER (LEN=1)               :: Delim
d1583 2
a1584 2
    IF(PRESENT(inDelim)) THEN
      Delim = inDelim
d1586 1
a1586 1
      Delim = COMMA
d1592 2
a1593 2
    & inDelim=inDelim) < 1 ) RETURN
    temp_list = trim(elem) // Delim // trim(inList)
d1595 1
a1595 1
    & inDelim=inDelim, ignoreLeadingSpaces=.true.)
d1832 2
a1833 2
  FUNCTION ReverseList (str, inDelim) RESULT (outstr)
    ! takes a string list, usually comma-delimited,
d1843 1
a1843 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inDelim
d1848 1
a1848 1
    CHARACTER (LEN=1)               :: Delim
d1852 1
a1852 1
! Treat consecutive delimiters as if enclosing an empty element
d1856 2
a1857 2
    IF(PRESENT(inDelim)) THEN
	     Delim = inDelim
d1859 1
a1859 1
	     Delim = COMMA
d1864 1
a1864 1
    IF(LEN(str) == 1 .OR. INDEX(str, Delim) == 0) RETURN
d1880 2
a1881 2
		CALL GetStringElement(str, word, elem, countEmpty, Delim)
		IF(word == Delim) THEN
d1893 1
a1893 1
			charBuf(iBuf) = Delim
d1898 1
a1898 1
	IF(charBuf(iBuf) == Delim) THEN
d2181 1
a2181 1
  ! This subroutine takes a (usually) comma-delimited string list, interprets it
d2195 1
a2195 1
  ! If countEmpty is TRUE, consecutive delimiters, with no chars in between,
d2197 1
a2197 1
  ! Otherwise, they are treated the same as a single delimiter
d2203 1
a2203 1
  ! As an optional arg the delimiter may supplied, in case it isn't comma
d2210 1
a2210 1
   & ignoreLeadingSpaces, inDelim, sortedList, leftRight)
d2216 1
a2216 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inDelim
d2225 1
a2225 1
    CHARACTER (LEN=1)               :: Delim
d2232 2
a2233 2
    IF(PRESENT(inDelim)) THEN
	     Delim = inDelim
d2235 1
a2235 1
	     Delim = COMMA
d2246 2
a2247 2
       print *, 'present(inDelim)?: ', PRESENT(inDelim)
       print *, 'Delim: ', Delim
d2252 1
a2252 1
    nElems = NumStringElements(inList, countEmpty, inDelim, LongestLen)
d2267 1
a2267 1
    call list2Array(inList, stringArray, countEmpty, inDelim, &
d2274 1
a2274 1
         & inDelim, outArray, leftRight='R')
d2277 1
a2277 1
         & inDelim, outArray, leftRight='L')
d2294 6
a2299 2
  ! two delimters, two spaces would count as one. Also if , is the delimeter
  ! then ,<space> counts as complete delimiter.
d2312 1
a2312 1
    CHARACTER (LEN=*), INTENT(IN), OPTIONAL :: delimiter
d2316 1
a2316 1
    CHARACTER (LEN=1) :: useDelimiter
d2320 1
a2320 1
    INTEGER :: firstDelimiterPos,lastDelimiterPos,trimmedLen
d2328 1
a2328 1
       useDelimiter=delimiter
d2330 1
a2330 1
       useDelimiter=","
d2344 1
a2344 1
    ! Find the first delimiter
d2346 1
a2346 1
    firstDelimiterPos=INDEX(useLine,useDelimiter)
d2348 1
a2348 1
    IF (firstDelimiterPos == 0) THEN
d2351 1
a2351 1
       first=useLine(1:firstDelimiterPos-1)
d2353 2
a2354 2
          ! In three way mode, find the last delimiter
          lastDelimiterPos=INDEX(TRIM(useLine),useDelimiter,back=.TRUE.)
d2356 2
a2357 2
               & lastDelimiterPos /= trimmedLen) THEN
             last=TRIM(useLine(lastDelimiterPos+1:))
d2359 2
a2360 2
          IF (firstDelimiterPos+1 <= lastDelimiterPos-1) THEN
             rest=TRIM(useLine(firstDelimiterPos+1:lastDelimiterPos-1))
d2363 2
a2364 2
          IF (firstDelimiterPos /= trimmedLen) THEN
             rest=TRIM(useLine(firstDelimiterPos+1:))
d2403 1
a2403 1
  ! This function takes a (usually) comma-delimited string list, interprets it
d2419 1
a2419 1
  ! comma-delimited lists
d2424 1
a2424 1
  ! If countEmpty is TRUE, consecutive delimiters, with no chars in between,
d2426 1
a2426 1
  ! Otherwise, they are treated the same as a single delimiter
d2429 1
a2429 1
  ! As an optional arg the delimiter may supplied, in case it isn't comma
d2437 1
a2437 1
    & inDelim, part_match) RESULT (elem)
d2443 1
a2443 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inDelim
d2452 1
a2452 1
!    CHARACTER (LEN=1)                          :: Delim
d2456 1
a2456 1
	nElements = NumStringElements(inList, countEmpty, inDelim)
d2467 1
a2467 1
		CALL GetStringElement(inList, listElement, elem, countEmpty, inDelim)
d2510 1
a2510 1
    ! Useful because the parser will return quote-delimited strings if that's
d2516 4
a2519 1
    ! e.g., braces, parentheses, extraneous delimiters
d2725 1
a2725 1
     & countEmpty=.true., inDelim='t')
d2735 1
a2735 1
     call GetStringElement(trim(date), yyyy, 1, countEmpty=.true., inDelim=dash)
d2737 2
a2738 2
       & NumStringElements(trim(date), countEmpty=.true., inDelim=dash) == 2) then
       call GetStringElement(trim(date), dd, 2, countEmpty=.true., inDelim=dash)
d2741 2
a2742 2
       call GetStringElement(trim(date), mm, 2, countEmpty=.true., inDelim=dash)
       call GetStringElement(trim(date), dd, 3, countEmpty=.true., inDelim=dash)
d2847 1
a2847 1
     & countEmpty=.true., inDelim='t')
d2854 1
a2854 1
   call GetStringElement(trim(date), year, 1, countEmpty=.true., inDelim=dash)
d2856 2
a2857 2
     & NumStringElements(trim(date), countEmpty=.true., inDelim=dash) == 2) then
     call GetStringElement(trim(date), day, 2, countEmpty=.true., inDelim=dash)
d2860 2
a2861 2
     call GetStringElement(trim(date), month, 2, countEmpty=.true., inDelim=dash)
     call GetStringElement(trim(date), day, 3, countEmpty=.true., inDelim=dash)
d3040 3
@


2.42
log
@Make Capitalize elemental
@
text
@d18 1
a18 1
       "$Id: MLSStrings.f90,v 2.41 2004/06/10 00:57:47 vsnyder Exp $"
d1273 1
a1273 1
  FUNCTION LowerCase (str) RESULT (outstr)
d1277 2
a1278 2
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr
d1281 2
a1282 2
    INTEGER :: i, icode
    INTEGER, parameter :: offset=IACHAR("a")-IACHAR("A")
d3000 3
@


2.41
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d18 1
a18 1
       "$Id: PFADataBase.f90,v 2.2 2004/06/09 17:53:13 vsnyder Exp $"
d21 1
a21 1
       "$RCSfile: PFADataBase.f90,v $"
d265 1
a265 1
  FUNCTION Capitalize (str) RESULT (outstr)
d269 2
a270 2
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr
d273 2
a274 2
    INTEGER :: i, icode
    integer, parameter :: offset=IACHAR("A")-IACHAR("a")
d278 3
a280 3
    DO i=1, LEN(str)
       icode=IACHAR(outstr(i:i))
       IF ( icode >=IACHAR("a") .AND. icode <= IACHAR("z")) THEN
d282 2
a283 2
       END IF
    END DO
d285 1
a285 1
  END FUNCTION Capitalize
d3000 3
@


2.40
log
@GetUniqueList now accepts optional arg str2 returning str not in str2
@
text
@d8 14
a21 11
  USE MLSMessageModule, only: MLSMessage, MLSMSG_Error, &
   & MLSMSG_Allocate, MLSMSG_DeAllocate
  USE MLSCommon, only: i4, r8, NameLen, BareFNLen, findFirst

  IMPLICIT NONE
  PRIVATE

!------------------------------- RCS Ident Info ------------------------------
CHARACTER(LEN=130) :: id = & 
   "$Id: MLSStrings.f90,v 2.39 2004/01/27 21:34:02 pwagner Exp $"
CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: MLSStrings.f90,v $"
d23 1
a23 1
!-----------------------------------------------------------------------------
d3000 3
@


2.39
log
@Fixed some bugs in ExtractSubString
@
text
@d10 1
a10 1
  USE MLSCommon, only: i4, r8, NameLen, BareFNLen
d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.38 2003/12/11 23:02:35 pwagner Exp $"
d732 1
a732 1
  ! This subroutine takes an string list and returns another containing
d736 2
d740 1
a740 1
    & inDelim, IgnoreLeadingSpaces)
d748 1
d754 1
a754 1
      &                             :: inStringArray, outStringArray
d756 1
d768 2
a769 1
    if ( nElems <= 1 ) then
d771 5
a775 2
      return
    end if
d790 25
a814 4
    call GetUniqueStrings(inStringArray, outStringArray, noUnique)
    call Array2List(outStringArray(1:nElems), outStr, &
     & inDelim)
    DEALLOCATE(inStringArray, outStringArray)
d821 2
d825 1
a825 1
  SUBROUTINE GetUniqueStrings(inList,outList,noUnique)
d830 1
d833 1
a833 1
    INTEGER :: i,j           ! Loop counters
d837 2
a841 1

d846 10
a855 3
    DO i = 1, inSize
       duplicate(i)=.FALSE.
    END DO
d859 1
a859 1
    DO i = 1, inSize-1 ! Don't bother with last one
d861 1
d865 5
d875 1
a875 4
    noUnique=0
    DO i = 1, inSize
       IF (.NOT. duplicate(i)) noUnique=noUnique+1
    END DO
d883 28
a910 9
    j=1
    DO i = 1, noUnique
       UniqueHuntLoop: DO
          IF (.NOT. duplicate(j)) EXIT UniqueHuntLoop
          j=j+1
       END DO UniqueHuntLoop
       outList(i)=inList(j)
       j=j+1
    END DO
d2997 3
@


2.38
log
@yyyymmdd_to_dai may take 3 ints or str
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.37 2003/12/07 23:10:42 pwagner Exp $"
d362 1
a362 1
  SUBROUTINE ExtractSubString (str, outstr, sub1, sub2, how, no_trim)
d378 7
d391 1
a391 1
    CHARACTER (LEN=*), INTENT(IN) :: str
d394 1
a394 1
    CHARACTER (LEN=LEN(str)) :: outstr
d399 1
d401 2
a402 1
    INTEGER :: i
d406 3
a408 2
    character (len=len(str)) :: tmpstr
    logical :: my_no_trim
d414 1
d416 47
a462 2
    if ( .not. my_no_trim) then
      if (LEN_trim(str) < 1 .or. len_trim(sub1) < 1 &
d477 1
d480 1
a480 1
      if ( .not. my_no_trim) then
d483 2
a484 2
        outstr = Reverse(trim(tmpstr))
        call ReplaceSubString (outstr, tmpstr, sub1, separator)
d488 2
a489 2
        outstr = Reverse(tmpstr)
        call ReplaceSubString (outstr, tmpstr, sub1, separator, no_trim=.true.)
d492 1
a492 1
      if ( .not. my_no_trim) then
d495 2
a496 2
        outstr = Reverse(trim(tmpstr))
        call ReplaceSubString (outstr, tmpstr, sub2, separator)
d500 2
a501 2
        outstr = Reverse(tmpstr)
        call ReplaceSubString (outstr, tmpstr, sub2, separator, no_trim=.true.)
d504 3
a506 1
      call ReplaceSubString (str, outstr, sub1, separator, &
d508 3
a510 1
      call ReplaceSubString (outstr, tmpstr, sub2, separator, &
d512 1
d1525 1
a1525 1
    CHARACTER (LEN=LEN(str)) :: outstr
d1533 5
a1537 4
    character(len=len(str)) :: head
    character(len=len(str)) :: tail
    character(len=len(str)) :: sub_str
    character(len=len(str)), dimension(MAXREPLACEMENTS) :: str_array
d1540 3
d1602 1
a1602 1
        character(len=*), intent(out) :: after_sub
d1622 3
d1626 3
a1628 1
        ! print *, 'tail: ', trim(tail), ' sub2: ', sub2
d1641 1
a1641 1
        character(len=*), intent(out) :: after_sub
d2935 3
@


2.37
log
@Added RemoveElemFromList; bug fixes in ReplaceSubString
@
text
@d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.36 2003/12/05 00:52:18 pwagner Exp $"
d161 4
d180 1
a2512 1
    integer, parameter :: YEARMAX = 4999  ! Conversion invalid after 4999 AD
d2693 48
a2740 2
  ! ---------------------------------------------  yyyymmdd_to_dai  -----
  subroutine yyyymmdd_to_dai(str, dai, startingDate)
d2762 2
a2763 2
   call yyymmdd_to_doy(mystartingDate, doy1)
   call yyymmdd_to_doy(str, doy2)
d2781 1
a2781 1
  end subroutine yyyymmdd_to_dai
d2797 2
a2798 2
  ! ---------------------------------------------  yyymmdd_to_doy  -----
  subroutine yyymmdd_to_doy(str, doy)
d2800 1
a2800 1
    ! for a string of the form yyyymmdd
d2802 2
a2803 2
    character(len=*),intent(in) :: str
    integer,intent(out) :: doy
a2804 1
    integer :: year, month, day
a2806 1
    integer, parameter :: YEARMAX = 4999  ! Conversion invalid after 4999 AD
a2808 1
     call utc_to_yyyymmdd_ints(str, ErrTyp, year, month, day, nodash=.true.)
d2825 18
a2842 1
  end subroutine yyymmdd_to_doy
d2864 3
@


2.36
log
@Added yyyymmdd_to_dai (though arguably this belongs in time_m)
@
text
@d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.35 2003/10/28 19:28:32 vsnyder Exp $"
d60 1
d148 3
a150 2
   & ReadCompleteLineWithoutComments, readIntsFromChars, ReplaceSubString, &
   & Reverse, ReverseList, SortArray, SortList, SplitWords, strings2Ints, &
d1399 35
a1487 1
        call Split_me
d1490 1
d1492 1
d1551 2
d1617 1
a1617 1
          istrt2 = istrt1 + len_trim(sub1)
d2303 1
a2303 1
  Function unquote(str, quotes, cquotes, strict) result (outstr)
d2318 3
d2341 1
a2341 1
    character(len=len(str)) :: outstr
d2345 1
d2353 1
d2358 1
d2372 6
d2395 9
d2463 3
a2465 2

   if(last >= first) then
d2800 3
@


2.35
log
@Make sure outStr always has a value
@
text
@d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.34 2003/10/15 00:34:19 pwagner Exp $"
d69 2
d149 5
a153 1
   & StringElementNum, unquote, utc_to_yyyymmdd
d174 8
d2412 1
a2412 1
  subroutine utc_to_yyyymmdd_ints(str, ErrTyp, year, month, day, strict)
d2419 1
a2419 1
    ! into either two or three fileds
d2421 1
a2421 1
    ! in case (B) the two fileds are year and day of year
d2434 2
a2435 1
    logical,intent(in), optional :: strict
d2444 1
d2465 6
d2488 4
a2491 5
   call GetStringElement(trim(date), yyyy, 1, countEmpty=.true., inDelim=dash)
   if ( &
     & NumStringElements(trim(date), countEmpty=.true., inDelim=dash) == 2) then
     call GetStringElement(trim(date), dd, 2, countEmpty=.true., inDelim=dash)
     utc_format = 'b'
d2493 10
a2502 3
     call GetStringElement(trim(date), mm, 2, countEmpty=.true., inDelim=dash)
     call GetStringElement(trim(date), dd, 3, countEmpty=.true., inDelim=dash)
     utc_format = 'a'
d2627 44
d2672 58
d2738 3
@


2.34
log
@Fixed the real bug in NumStringElements
@
text
@d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.33 2003/10/14 18:17:02 pwagner Exp $"
d183 1
a183 2
  SUBROUTINE Array2List(inArray, outList, &
   & inDelim, ordering, leftRight)
d201 4
a204 4
	     Delim = inDelim
	 ELSE
	     Delim = COMMA
	 ENDIF
d207 4
a210 4
	     myleftRight = Capitalize(leftRight)
	 ELSE
	     myleftRight = "R"
	 ENDIF
d236 1
a236 1
	 ENDDO
d675 4
a678 4
	     Delim = inDelim
	 ELSE
	     Delim = COMMA
	 ENDIF
d682 1
d684 2
a685 1
    elseif ( LongestLen > MAXSTRELEMENTLENGTH ) then
d693 1
a693 1
    endif
d2608 3
@


2.33
log
@Fixed problem with reducing switches to unique list
@
text
@d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.32 2003/10/09 23:33:11 pwagner Exp $"
d685 4
d1187 2
d2607 3
@


2.32
log
@Added GetUniqueList
@
text
@d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.31 2003/09/15 23:04:06 vsnyder Exp $"
d658 2
a659 2
    CHARACTER (LEN=*) :: str
    CHARACTER (LEN=*) :: outstr
d2601 3
@


2.31
log
@Remove unused local variable
@
text
@a14 1
!  PRIVATE :: id, ModuleName
d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.30 2003/04/11 23:29:30 pwagner Exp $"
d47 1
d86 2
d127 2
a128 1
! Warning: in the routines LinearSearchStringArray, Array2List, and SortArray
d135 2
d142 2
a143 1
   & GetUniqueStrings, hhmmss_value, ints2Strings, LinearSearchStringArray, &
d164 3
d648 52
d1727 1
a1727 1
    integer, parameter                     :: MAXELEM = BareFNLen
d1742 1
a1742 1
    CHARACTER (LEN=BareFNLen), DIMENSION(:), ALLOCATABLE    &
d1744 1
a1744 1
    CHARACTER (LEN=BareFNLen)              :: theString  
d1919 1
a1919 1
       CHARACTER (LEN=BareFNLen)  :: stringElement  
d1987 1
a1987 1
    integer, parameter              :: MAXELEM = BareFNLen
d1992 1
a1992 1
    CHARACTER (LEN=BareFNLen), DIMENSION(:), ALLOCATABLE    &
d2020 1
a2020 1
    elseif ( LongestLen > BareFNLen ) then
d2601 3
@


2.30
log
@Fixed bug in ReplaceSubString; added ExtractSubString
@
text
@d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.29 2003/02/27 18:36:57 pwagner Exp $"
a1345 1
	 CHARACTER (LEN=1) :: strChar
d2540 3
@


2.29
log
@utc_to_yyyymmdd optionally returns yy-mm-ddT00:00:00Z
@
text
@d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.28 2003/02/19 19:08:40 pwagner Exp $"
d43 1
d78 2
d100 1
a100 1
!       & [char* which])
d135 2
a136 1
   & depunctuate, GetIntHashElement, GetStringElement, GetStringHashElement, &
d332 96
d1416 1
a1416 1
        if ( index(the_orig, sub1) == 0 ) then
d2541 3
@


2.28
log
@Added ReplaceSubString
@
text
@d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.27 2003/02/01 00:28:32 pwagner Exp $"
d2352 2
a2353 1
  subroutine utc_to_yyyymmdd_strs(str, ErrTyp, year, month, day, strict)
d2368 3
d2379 1
d2385 1
d2413 1
d2416 1
d2441 3
@


2.27
log
@Added utc_to_yyyymmdd
@
text
@d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.26 2003/01/15 21:20:00 pwagner Exp $"
d59 1
d96 2
d135 1
a135 1
   & ReadCompleteLineWithoutComments, readIntsFromChars, &
d1215 186
d2433 3
@


2.26
log
@Added readIntsFromChars
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.25 2002/10/29 19:55:39 pwagner Exp $"
d134 6
a139 1
   & StringElementNum, unquote
d147 2
d2041 194
d2244 3
@


2.25
log
@Fixed mistake in StringElementNum that caused crashes
@
text
@d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.24 2002/10/29 01:00:05 pwagner Exp $"
d58 1
d92 1
d131 2
a132 1
   & List2Array, LowerCase, NumStringElements, ReadCompleteLineWithoutComments,&
d1156 49
d1776 1
a1776 1
  ! --------------------------------------------------  int2String  -----
d2043 3
@


2.24
log
@optional param part_match added to str element routines
@
text
@d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.23 2002/10/08 00:09:12 pwagner Exp $"
d1821 1
a1821 1
      if ( part_match ) then
d1991 3
@


2.23
log
@Added idents to survive zealous Lahey optimizer
@
text
@d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.22 2002/04/29 17:39:31 pwagner Exp $"
d26 1
d30 8
d43 1
a43 1
! GetIntHashElement  Returns int from array of hashes corresponding to key string
d66 40
d119 1
a119 1
! it is assumed that this array is of assumed-size
d124 1
d335 3
d343 1
a343 1
  & countEmpty, inDelim) RESULT (hashInt)
d345 6
a350 6
    CHARACTER (LEN=*), INTENT(IN)   :: keyList
    INTEGER(i4), DIMENSION(:), INTENT(IN)   :: hashArray
    INTEGER(i4)                             :: hashInt
    CHARACTER (LEN=*), INTENT(IN)   :: key
    INTEGER, INTENT(OUT)  :: ErrType
    LOGICAL, INTENT(IN)   :: countEmpty
d352 1
d359 2
a360 1
	elem = StringElementNum(keyList, key, countEmpty, inDelim)
d482 3
d493 1
a493 1
  & countEmpty, inDelim)
d501 1
d516 1
a516 1
	elem = StringElementNum(keyList, key, countEmpty, inDelim)
d520 2
a521 1
		CALL GetStringElement(hashList, outElement, elem, countEmpty, inDelim)
d611 1
a611 1
    ! i.e., non-complient str always returns non-zero ErrTyp
d761 1
a761 1
  ! --------------------------------------------------  int2String  -----
d1783 3
d1789 2
a1790 1
  FUNCTION StringElementNum(inList, element, countEmpty, inDelim) RESULT (elem)
d1793 1
a1793 1
    CHARACTER (LEN=*), INTENT(IN)             :: element
d1797 1
d1804 1
d1815 2
d1821 6
a1826 1
		IF(adjustl(listElement) == adjustl(element)) RETURN
d1991 3
@


2.22
log
@Comments re hhmmss_value mention mls_utctotai
@
text
@d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.21 2002/02/22 23:35:42 pwagner Exp $"
d20 1
d1910 5
a1914 1
END MODULE MLSStrings
d1918 3
@


2.21
log
@SortList checks on lax elem length, not number of elems
@
text
@d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.20 2002/02/22 01:19:57 pwagner Exp $"
d39 1
a86 1
!  public :: INVALIDHHMMSSSTRING
a88 1
!  public :: LENORSIZETOOSMALL
d544 1
a544 1
    ! Lenient wrt non-compilant formats:
d555 2
d1913 3
@


2.20
log
@SortArray not limited to array sizes lt MAXELEM
@
text
@d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.19 2002/02/19 23:12:03 pwagner Exp $"
d923 2
a924 1
  FUNCTION NumStringElements(inList, countEmpty, inDelim) RESULT (nElements)
d930 1
d933 1
a933 1
    INTEGER :: i           ! Loop counters
d950 1
d955 2
a956 1
	nElements=1
d961 2
d965 1
d968 1
d971 2
d1518 1
a1518 1
    INTEGER(i4) :: nElems, status
d1547 1
a1547 1
    nElems = NumStringElements(inList, countEmpty, inDelim)
d1550 1
a1550 1
    elseif ( nElems > MAXELEM ) then
d1552 1
a1552 1
         & "Too many elements needed in SortList")
d1554 4
d1912 3
@


2.19
log
@New optional args to Sorting routines
@
text
@d8 2
a9 1
  USE MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Allocate
d18 1
a18 1
   "$Id: MLSStrings.f90,v 2.18 2002/02/15 01:06:12 pwagner Exp $"
d1246 16
a1261 13
    integer, parameter              :: MAXCHARVALUE = 256
    integer, parameter              :: MAXELEM = BareFNLen
    integer, dimension(MAXELEM)     :: chValue, cvInvBN
    integer, dimension(MAXELEM)     :: binNumber, invBinNumber 
    integer, dimension(MAXELEM)     :: jsort, inTheBin
    integer                         :: numBins, oldNumBins
    integer                         :: i, bin, ck, strPos
    integer                         :: status
    integer                         :: maxStrPos
    logical                         :: allTheSameInThisBin
    logical                         :: myShorterFirst
    CHARACTER (LEN=1)               :: theChar  
    CHARACTER (LEN=1), PARAMETER    :: BLANK = ' '
d1263 4
a1266 4
      &                             :: stringArray
    CHARACTER (LEN=BareFNLen)         :: theString  
    CHARACTER (LEN=1)               :: myLeftRight
    logical, parameter              :: DeeBUG = .false.
d1283 4
a1286 4
    elseif ( nElems > MAXELEM ) then
       CALL MLSMessage(MLSMSG_Error, ModuleName, &
         & 'Too many elements in inStrArray in SortArray')
       return
d1288 7
a1294 3
    ALLOCATE (stringArray(nElems), STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"stringArray in SortArray")
a1398 1
    DEALLOCATE(stringArray)
d1410 4
d1898 3
@


2.18
log
@Added new array and sorting routines
@
text
@d9 1
a9 1
  USE MLSCommon, only: i4, r8, NameLen
d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.17 2002/01/09 23:46:05 pwagner Exp $"
d43 1
a43 1
! NumStringElements  Returns number of elements in list of strings
d48 1
a48 1
! SortArray          Similar to SortList, but for an array of strings
d55 2
a56 1
! in the above, a list is a string of words (usu. comma-delimited)
d61 3
d67 1
a67 1
! it is assumed that this array is og assumed-size
d71 1
d79 11
d96 2
a97 2
  ! as a list of individual elements, given returns an equivalent array of
  ! sub-strings in which the n'th element is the n'th element
d99 1
a99 1
  ! As an optional arg the delimiter may supplied, in case it isn't comma
a299 2
	INTEGER, PARAMETER :: KEYNOTFOUND=-1
	INTEGER, PARAMETER :: KEYBEYONDHASHSIZE=KEYNOTFOUND-1
a300 2
!    CHARACTER (LEN=1)                          :: Delim
!    CHARACTER (LEN=1), PARAMETER               :: COMMA = ','
a562 1
    integer, parameter :: INVALIDHHMMSSSTRING = 1
d1202 4
d1212 22
a1233 2

  SUBROUTINE SortArray(inStrArray, outIntArray, CaseSensitive, sortedArray)
d1237 1
a1237 1
    LOGICAL, INTENT(IN)                           :: CaseSensitive
d1240 2
d1246 1
a1246 1
    integer, parameter              :: MAXELEM = NameLen
d1252 1
d1255 1
d1258 4
d1265 11
d1284 3
d1289 1
a1289 1
    maxStrPos = 1
d1292 5
a1296 1
      maxStrPos = max(maxStrPos, len_trim(inStrArray(elem)))
d1302 12
a1313 1
    endif    
d1321 2
a1322 2
        theChar = inStrArray(elem)(strPos:strPos)
        if ( inStrArray(elem) == ' ' ) then
d1327 9
a1335 9
          chValue(elem) = ichar(theChar)
        elseif (ichar("a") <= ichar(theChar) .and. &
          & ichar(theChar) <= ichar("z") ) then
          chValue(elem) = 2*ichar(Capitalize(theChar)) - ichar("A") + 1
        elseif (ichar("A") <= ichar(theChar) .and. &
          & ichar(theChar) <= ichar("Z") ) then
          chValue(elem) = 2*ichar(theChar) - ichar("A")
        elseif (ichar("Z") < ichar(theChar) ) then
          chValue(elem) = 2*ichar(theChar)
d1337 1
a1337 1
          chValue(elem) = ichar(theChar)
d1380 23
a1402 6
    if ( .not. present(sortedArray) ) return
    do elem=1, nElems
      i = max(1, outIntArray(elem))
      i = min(i, nElems, size(sortedArray))
      sortedArray(i) = inStrArray(elem)
    enddo
d1424 2
d1428 1
a1428 1
       CHARACTER (LEN=NameLen)  :: stringElement  
d1430 1
a1430 1
       stringElement = inStrArray(invBinNumber(1))
d1434 1
a1434 1
           & stringElement == inStrArray(invBinNumber(k))
d1460 4
d1476 1
d1481 2
d1484 1
a1484 1
   & ignoreLeadingSpaces, inDelim, sortedList)
d1493 1
d1496 1
a1496 1
    integer, parameter              :: MAXELEM = NameLen
d1501 1
a1501 1
    CHARACTER (LEN=NameLen), DIMENSION(:), ALLOCATABLE    &
d1503 1
a1505 1

d1512 6
d1539 2
a1540 1
    call SortArray(stringArray(1:nElems), outArray, CaseSensitive)
d1542 7
a1548 2
      call Array2List(stringArray(1:nElems), sortedList, &
       & inDelim, outArray, leftRight='L')
a1649 1
    integer, parameter :: LENORSIZETOOSMALL=-999
d1887 3
@


2.17
log
@Removed debugging stuff
@
text
@d12 1
a12 1
  PUBLIC
d14 1
a14 1
  PRIVATE :: id, ModuleName
d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.16 2001/08/03 00:03:08 pwagner Exp $"
d27 1
d30 1
a30 1
! count_words        Counts the number of words in a string
d34 2
a35 1
! GetStringHashElement   Returns string from hash list corresponding to key string
d39 3
a41 1
! LinearSearchStringArray     Finds string index of substring in array of strings
d44 6
a49 3
! ReadCompleteLineWithoutComments     Knits continuations, snips comments
! Reverse            turns 'a string' -> 'gnirts a'
! ReverseList        turns 'abc, def, ghi' -> 'ghi, def, abc'
d55 1
a55 1
! in the above, a list is a string of usu. comma-delimited words
d60 14
a73 1
!
d77 71
a561 1
!    logical, parameter :: DeeBUG = .false.
d718 1
a718 1
  ! This routine does a simple linear search for a string in a list.
d811 60
d1184 259
d1777 3
@


2.16
log
@Added ints2Strings and strings2Ints
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.15 2001/06/20 23:23:39 vsnyder Exp $"
d471 1
a471 1
    logical, parameter :: DeeBUG = .false.
a519 5
   if(DeeBUG) then
      print *, 'hh ', hh
      print *, 'mm ', mm
      print *, 'ss ', trim(ss)
   endif
a523 3
   if(DeeBUG) then
      print *, 'ss passed first test'
   endif
a533 3
   if(DeeBUG) then
      print *, 'mm passed first test'
   endif
a557 3
   if(DeeBUG) then
      print *, 'hh value conversion error ', ErrTyp
   endif
a571 3
   if(DeeBUG) then
      print *, 'mm value conversion error ', ErrTyp
   endif
a585 3
   if(DeeBUG) then
      print *, 'ss value conversion error ', ErrTyp
   endif
d1368 3
@


2.15
log
@Same as last time, but for LowerCase instead of Capitalize.
@
text
@d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.14 2001/06/20 23:21:49 vsnyder Exp $"
d36 1
d44 1
d617 29
d1137 31
d1388 3
@


2.14
log
@Replace ICHAR with IACHAR and CHAR with ACHAR, to improve portability.
Make "offset" a parameter.
@
text
@d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.13 2001/06/07 21:59:41 pwagner Exp $"
d719 2
a720 1
    INTEGER :: i, icode, offset
a722 1
    offset=ICHAR("a")-ICHAR("A")
d725 3
a727 3
       icode=ICHAR(outstr(i:i))
       IF ( icode >=ICHAR("A") .AND. icode <= ICHAR("Z")) THEN
          outstr(i:i)=char(icode+offset)
d1326 4
@


2.13
log
@Added Copyright statement
@
text
@d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.12 2001/05/29 21:17:03 pwagner Exp $"
d64 2
a65 1
    INTEGER :: i, icode, offset
a67 1
    offset=ICHAR("A")-ICHAR("a")
d70 3
a72 3
       icode=ICHAR(outstr(i:i))
       IF ( icode >=ICHAR("a") .AND. icode <= ICHAR("z")) THEN
          outstr(i:i)=char(icode+offset)
d1326 3
@


2.12
log
@Removed Downcase; added table of contents
@
text
@d1 3
d17 1
a17 1
   "$Id: MLSStrings.f90,v 2.11 2001/05/26 00:21:59 livesey Exp $"
d1326 3
@


2.11
log
@Added downcase
@
text
@d14 1
a14 1
   "$Id: MLSStrings.f90,v 2.10 2001/05/24 23:36:17 pwagner Exp $"
d19 29
a47 1
! This module contains some low level string handling stuff
a74 23
  ! -------------------------------------------------  CAPITALIZE  -----
  FUNCTION Downcase (str) RESULT (outstr)
    ! takes a-z and replaces with A-Z 
    ! leaving other chars alone
    !--------Argument--------!
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr

    !----------Local vars----------!
    INTEGER :: i, icode, offset
    !----------Executable part----------!
    outstr=str
    offset=ICHAR("A")-ICHAR("a")

    DO i=1, LEN(str)
       icode=ICHAR(outstr(i:i))
       IF ( icode >=ICHAR("A") .AND. icode <= ICHAR("Z")) THEN
          outstr(i:i)=char(icode-offset)
       END IF
    END DO

  END FUNCTION Downcase

d1323 3
@


2.10
log
@Fixed problem with hhmmss_value
@
text
@d14 1
a14 1
   "$Id: MLSStrings.f90,v 2.9 2001/05/15 23:44:42 pwagner Exp $"
d47 23
d1318 3
@


2.9
log
@Added hhmmss_value
@
text
@d14 1
a14 1
   "$Id: MLSStrings.f90,v 2.8 2001/05/11 23:41:31 pwagner Exp $"
d438 1
d486 6
d496 3
d505 2
a506 2
      do i=1, len_trim(ss)
        if( .not. (index(digits, mm(i:i)) > 0 .or. mm(i:i) == '.') ) return
d509 3
d536 3
d553 3
d564 2
a565 2
   if(hh == ' ') then
      hvalue=0
d570 3
d1295 3
@


2.8
log
@Improved unquote
@
text
@d6 1
a6 1
  USE MLSCommon, only: i4
d14 1
a14 1
   "$Id: MLSStrings.f90,v 2.7 2001/05/11 00:06:54 pwagner Exp $"
a123 149
  ! ------------------------------------------------  DEPUNCTUATE  -----
  Function unquote(str, quotes, cquotes, strict) result (outstr)
    ! Function that removes a single pair of surrounding quotes from string

    ! E.g., given "Let me see." or 'Let me see.' returns
    !    Let me see.
    ! If no surrounding quotes are found, returns string unchanged; unless
    ! (1) mismatched quotes, e.g. 'Let me see." will:
    !     remove leading quote but leave trailing quote
    ! (2) a single unpaired quote found at beginning or end, will:
    !  (a) remove it if the resulting string is non-empty; or
    !  (b) return the single unpaired quote if that was the entire str
    
    ! If given optional arg strict, options (1) and (2) above disregarded
    ! i.e., surrounding quotes must match, else returns string unchanged
    
    ! If given optional arg quotes, removes only surrounding pair:
    ! quotes[i:i] for each i=1..len[quotes]
    ! E.g., given /a\ regexp/ with quotes='/' returns
    !    a\ regexp
    
    ! If given optional args quotes & cquotes, removes only surrounding pair:
    ! quotes[i:i] on the left, cquotes[i:i] on the right, i=1..len[quotes]
    ! E.g., given [a particle] with quotes='[' cquotes=']' returns
    !    a particle
    ! (For this case, strict matching is always on)
    
    ! Useful because the parser will return quote-delimited strings if that's
    ! how they appear in the lcf
    
    ! Calling get_string with "strip=.true." renders this unnecessary.
    ! However, you might find another use for it, especially with
    ! feature of being able to trim other, user-supplied detritus:
    ! e.g., braces, parentheses, extraneous delimiters
    !--------Argument--------!
    character(len=*),intent(in) :: str
    character(len=len(str)) :: outstr
    character(len=*),intent(in), optional :: quotes
    character(len=*),intent(in), optional :: cquotes
    logical,intent(in), optional :: strict
    !----------Local vars----------!
    character(len=1), parameter :: sq=''''
    character(len=1), parameter :: dq='"'
    integer :: first, last, ult, prim
    character(len=1) :: quote, cquote
    integer :: i
    logical :: mystrict
    !----------Executable part----------!

   ult = len_trim(str)    ! Position of last non-blank char
   prim = ult - len_trim(adjustl(str)) + 1    ! Position of 1st non-blank char
      
   ! length of non-blank portion of string to be trimmed must be at least 2
   if(ult-prim+1 <= 1) then
      outstr=str
      return
   endif

   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
   
   ! These are initialized so that if no matching quotes found
   ! we will return    outstr = adjustl(str)
   first = prim
   last = ult

   ! trim surrounding user-supplied marks?

   if(present(quotes)) then
      if(len_trim(quotes) <= 0) then
       outstr=str
       return
      endif
      
      ! Loop over char class in string quotes
      do i=1, len_trim(quotes)
      
         quote = quotes(i:i)

         ! Supplied with paired left and right quotes?
         if(present(cquotes)) then
            cquote=cquotes(i:i)
            mystrict=.true.
         else
            cquote=quote
         endif

         if(mystrict) then
           if(str(prim:prim) == quote .and. str(ult:ult) == cquote) then
               outstr=str(prim+1:ult-1)
               return
          endif
      
        else
         if(str(prim:prim) == quote) then
           first=prim+1
          endif

          if(str(ult:ult) == cquote) then
             last=ult-1
           endif
        endif

      enddo

   ! insist surrounding marks match?
   elseif(present(strict)) then
      if( &
      & str(prim:prim) == str(ult:ult) &
      & .and. &
        & (str(prim:prim) == sq .or. str(prim:prim) == dq) &
        & ) then
            outstr=str(prim+1:ult-1)
          else
            outstr=str
          endif
         return
      
   elseif(str(prim:prim) == sq) then
      first=prim+1
      if(str(ult:ult) == sq) then
         last=ult-1
      endif
      
   elseif(str(prim:prim) == dq) then
      first=prim+1
      if(str(ult:ult) == dq) then
         last=ult-1
      endif

   else
      first=prim
      if(str(ult:ult) == dq .or. str(ult:ult) == sq) then
         last=ult-1
      endif

   endif

   if(last >= first) then
       outstr=str(first:last)
   else
       outstr=str
   endif
      
  end Function unquote

d394 168
d1119 149
d1273 3
@


2.7
log
@Added unquote
@
text
@d14 1
a14 1
   "$Id: MLSStrings.f90,v 2.6 2001/03/14 17:34:00 pwagner Exp $"
d125 1
a125 1
  Function unquote(str, quote, strict) result (outstr)
d129 1
a129 1
    ! Let me see.
a136 2
    ! If given optional arg quote, removes only surrounding pair of quotes
    
d140 11
d153 5
d161 2
a162 1
    character(len=1),intent(in), optional :: quote
d167 4
a170 1
    integer :: first, last, ult
d173 2
a174 1
   ult = LEN(TRIM(str))
d176 2
a177 1
   if(ult <= 1) then
d182 23
a204 1
   if(present(quote)) then
d206 4
a209 3
      if(present(strict)) then
         if(str(1:1) == quote .and. str(ult:ult) == quote) then
            outstr=str(2:ult-1)
d211 1
a211 1
            outstr=str
d213 6
a218 2
         return
      endif
d220 9
a228 5
      if(str(1:1) == quote) then
         first=2
      else
         first=1
      endif
d230 1
a230 5
      if(str(ult:ult) == quote) then
         last=ult-1
      else
         last=ult
      endif
d232 2
a233 1
   if(present(strict)) then
d235 1
a235 1
      & str(1:1) == str(ult:ult) &
d237 1
a237 1
        & (str(1:1) == sq .or. str(1:1) == dq) &
d239 1
a239 1
            outstr=str(2:ult-1)
a243 1
   endif
d245 2
a246 2
   elseif(str(1:1) == sq) then
      first=2
a248 2
      else
         last=ult
d251 2
a252 2
   elseif(str(1:1) == dq) then
      first=2
a254 2
      else
         last=ult
d258 1
a258 1
      first=1
a260 2
      else
         last=ult
d1105 3
@


2.6
log
@Removed some of the dross, left all of the gold
@
text
@d14 1
a14 1
   "$Id: MLSStrings.f90,v 2.5 2001/03/02 19:33:14 pwagner Exp $"
d124 108
d1064 3
@


2.5
log
@Added GetIntHashElement
@
text
@d14 1
a14 1
   "$Id: MLSStrings.f90,v 2.4 2001/02/24 01:02:45 pwagner Exp $"
d163 2
a164 2
    CHARACTER (LEN=1)                          :: Delim
    CHARACTER (LEN=1), PARAMETER               :: COMMA = ','
a167 6
    IF(PRESENT(inDelim)) THEN
	     Delim = inDelim
	 ELSE
	     Delim = COMMA
	 ENDIF

a537 1
    INTEGER :: elem, nextDelim
a925 1
    INTEGER :: i           ! Loop counters
d930 2
a931 2
    CHARACTER (LEN=1)                          :: Delim
    CHARACTER (LEN=1), PARAMETER               :: COMMA = ','
a933 6
    IF(PRESENT(inDelim)) THEN
	     Delim = inDelim
	 ELSE
	     Delim = COMMA
	 ENDIF

d956 3
@


2.4
log
@Added GetStringHashElement; alphabetized entries
@
text
@d5 2
a6 1
  USE MLSMessageModule
d14 1
a14 1
   "$Id: MLSStrings.f90,v 2.3 2001/02/23 00:05:56 pwagner Exp $"
d124 62
d208 1
a208 1
    INTEGER, INTENT(IN)             :: nElement ! Number of unique entries
d213 2
a214 2
    INTEGER :: i           ! Loop counters
    INTEGER :: elem, nextDelim
d282 1
a282 1
  ! a hash table or associative array or dictionary
d314 1
a314 1
	INTEGER :: elem
d744 1
a744 1
    INTEGER :: i, istr, irev, elem, iBuf
d970 3
@


2.3
log
@Added 4 StringList functions
@
text
@d13 1
a13 1
   "$Id: MLSStrings.f90,v 2.2 2000/12/01 22:38:00 vsnyder Exp $"
a122 134
  ! ---------------------------------------------  StringElementNum  -----

  ! This function takes a (usually) comma-delimited string list, interprets it
  ! as a list of individual elements, and a test string which may be an element
  ! It returns the element number of the test string in the string list
  ! or, 0 if the test string is not found
  
  ! Any leading blanks are disregarded before making the comparison;
  ! e.g., 'stare' is the same as ' stare' and is the second element of 
  ! the list 'lex, stare, decisis'
  
  ! Note: if there are multiple matches between the test string and elements
  ! of inList we return only the first
  
  ! If you want the last instead, use ReverseList on inList && subtract
  ! the answer from nElements
  
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-delimited lists
  
  ! It will be the immediate precursor function in a hash table
  ! == aka associative array == aka dictionary
  !
  ! If kountEmpty is TRUE, consecutive delimiters, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single delimiter
  ! E.g., "a,b,,d" has 4 elements if kountEmpty TRUE, 3 if FALSE  

  ! As an optional arg the delimiter may supplied, in case it isn't comma

  ! See also GetStringElement, NumStringElements

  FUNCTION StringElementNum(inList, element, kountEmpty, inDelim) RESULT (elem)
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(IN)             :: inList
    CHARACTER (LEN=*), INTENT(IN)             :: element
    LOGICAL, INTENT(IN)                       :: kountEmpty
	 INTEGER                                   :: elem
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inDelim

    ! Local variables
    INTEGER :: i           ! Loop counters
    INTEGER :: nElements
    INTEGER , PARAMETER :: MAXELEMENTLENGTH = 80

    CHARACTER (LEN=MAXELEMENTLENGTH)           :: listElement
    CHARACTER (LEN=1)                          :: Delim
    CHARACTER (LEN=1), PARAMETER               :: COMMA = ','
    ! Executable code

    IF(PRESENT(inDelim)) THEN
	     Delim = inDelim
	 ELSE
	     Delim = COMMA
	 ENDIF

	nElements = NumStringElements(inList, kountEmpty, inDelim)
	
	IF(nElements <= 0) THEN
		elem = 0
		RETURN
	ENDIF

	! Check for matches--snipping off any leading blanks
	DO elem=1, nElements
		CALL GetStringElement(inList, listElement, elem, kountEmpty, inDelim)
		IF(adjustl(listElement) == adjustl(element)) RETURN
	ENDDO
	
	elem = 0

  END FUNCTION StringElementNum

  ! ---------------------------------------------  NumStringElements  -----

  ! This function takes a (usually) comma-delimited string list, interprets it
  ! as a list of individual elements and returns the
  ! number of elements
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-delimited lists
  !
  ! If kountEmpty is TRUE, consecutive delimiters, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single delimiter
  ! E.g., "a,b,,d" has 4 elements if kountEmpty TRUE, 3 if FALSE  

  ! As an optional arg the delimiter may supplied, in case it isn't comma

  ! See also GetStringElement

  FUNCTION NumStringElements(inList, kountEmpty, inDelim) RESULT (nElements)
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(IN)             :: inList
    LOGICAL, INTENT(IN)                       :: kountEmpty
	 INTEGER                                   :: nElements
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inDelim

    ! Local variables
    INTEGER :: i           ! Loop counters
    INTEGER :: elem, nextDelim
	 LOGICAL :: lastWasNotDelim

    CHARACTER (LEN=1)               :: Delim
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
    ! Executable code

    IF(PRESENT(inDelim)) THEN
	     Delim = inDelim
	 ELSE
	     Delim = COMMA
	 ENDIF

	! Count the number of delimiters
	! nElements-1 = number of delimiters
	IF(LEN_TRIM(inList) <= 0) THEN
		nElements=0
		RETURN
	ENDIF
	
	lastWasNotDelim = .FALSE.
	nElements=1
	DO i=1, LEN_TRIM(inList)
		IF(inList(i:i) == Delim) THEN
			IF(kountEmpty .OR. lastWasNotDelim) THEN
				nElements = nElements+1
			ENDIF
			lastWasNotDelim = .FALSE.
		ELSE
			lastWasNotDelim = .TRUE.
		ENDIF
	ENDDO

  END FUNCTION NumStringElements

d132 1
a132 1
  ! If kountEmpty is TRUE, consecutive delimiters, with no chars in between,
d135 1
a135 1
  ! E.g., "a,b,,d" has 4 elements if kountEmpty TRUE, 3 if FALSE
d141 1
a141 1
  SUBROUTINE GetStringElement(inList, outElement, nElement, kountEmpty, inDelim)
d146 1
a146 1
    LOGICAL, INTENT(IN)   :: kountEmpty
d185 1
a185 1
				IF(kountEmpty) THEN
d215 57
d455 1
a455 11
  ! --------------------------------------------------  Reverse  -----
  FUNCTION Reverse (str) RESULT (outstr)
    ! takes a string and returns one with chars in reversed order
	 ! Useful in certain contexts:
	 ! e.g., to remove leading blanks
	 ! arg = Reverse(TRIM(Reverse(arg)))
	 !
	 ! See also ReverseList
    !--------Argument--------!
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr
d457 10
a466 6
    !----------Local vars----------!
    INTEGER :: i, istr, irev
	 CHARACTER (LEN=1) :: strChar
    !----------Executable part----------!
    outstr=str
    IF(LEN(str) == 1) RETURN
d468 1
a468 7
    DO i = 1, LEN(str)-1, 2
       istr = 1 + (i-1)/2				! 1, 2, ..
       irev = LEN(str) - (i-1)/2		! N, N-1, ..
       strChar = str(istr:istr)
		 outstr(istr:istr) = str(irev:irev)
		 outstr(irev:irev) = strChar
    END DO
d470 1
a470 5
! Special case: str contains odd number of chars
    IF(MOD(LEN(str), 2) == 1) THEN
       istr = 1 + (LEN(str)-1)/2				! 1, 2, ..
        outstr(istr:istr) = str(istr:istr)
	ENDIF
d472 6
a477 1
  END FUNCTION Reverse
d479 4
a482 13
  ! --------------------------------------------------  ReverseList  -----
  FUNCTION ReverseList (str, inDelim) RESULT (outstr)
    ! takes a string list, usually comma-delimited,
	 ! and returns one with elements in reversed order

	 ! E.g., given "alpha, beta, gamma" => "gamma, beta, alpha"

	 ! Limitation:
	 ! No element may be longer than MAXWORDLENGTH
    !--------Argument--------!
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inDelim
a483 3
    !----------Local vars----------!
    INTEGER :: i, istr, irev, elem, iBuf
    INTEGER, PARAMETER :: MAXWORDLENGTH=80
d486 1
a486 4
    CHARACTER (LEN=1), DIMENSION(:), ALLOCATABLE :: charBuf
    CHARACTER (LEN=MAXWORDLENGTH) :: word
! Treat consecutive delimiters as if enclosing an empty element
	LOGICAL, PARAMETER :: kountEmpty = .TRUE.    
a487 1
    !----------Executable part----------!
d494 4
a497 9
!  Special case--only one element of str
    outstr = str
    IF(LEN(str) == 1 .OR. INDEX(str, Delim) == 0) RETURN
	 
! General case
	 ALLOCATE(charBuf(LEN(str)+1), STAT=istr)
    IF (istr /= 0) THEN
	 	CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"charBuf")
d500 9
a508 12

    outstr = ' '

! Loop over elements
	elem = 1
	iBuf=0
	DO
		CALL GetStringElement(str, word, elem, kountEmpty, Delim)
		IF(word == Delim) THEN
			EXIT
		ELSEIF(iBuf > LEN(str)) THEN
			EXIT
d510 1
a510 9
			istr = MAX(LEN_TRIM(word), 1)
			word = Reverse(word(:istr))
			DO i=1, istr
				iBuf=iBuf+1
				charBuf(iBuf) = word(i:i)
			ENDDO
			iBuf=iBuf+1
			charBuf(iBuf) = Delim
			elem = elem+1
a512 9
	
	IF(charBuf(iBuf) == Delim) THEN
		iBuf = iBuf-1
	ENDIF
	
	DO i=1, iBuf
		irev = iBuf - i + 1
		outstr(irev:irev) = charBuf(i)
	ENDDO
d514 1
a514 2
	DEALLOCATE(charBuf)
  END FUNCTION ReverseList
d631 115
d829 73
d907 3
@


2.2
log
@Add lowercase function, alphabetize procedures, add "bookmarks"
@
text
@d13 1
a13 1
   "$Id: MLSStrings.f90,v 2.0 2000/09/05 17:41:06 dcuddy Exp $"
d123 226
d532 114
d849 3
@


2.1
log
@lowercase function moved here from Fill
@
text
@d10 1
a10 1
  PRIVATE :: id,ModuleName
d22 51
a72 1
  FUNCTION count_words(str) RESULT (no_of_words)
d88 2
a89 2
    ENDIF
    DO j=2,LEN(str)
d92 2
a93 2
       ENDIF
    ENDDO
d99 5
a103 3
  FUNCTION Capitalize(str) RESULT (outstr)
    ! takes a-z and replaces with A-Z 
    ! leaving other chars alone
d105 2
a106 3
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr

d108 1
a108 2
    CHARACTER(LEN=LEN(STR))::capstr
    INTEGER::i,icode,offset
d110 134
a243 2
    capstr=str
    offset=ICHAR("A")-ICHAR("a")
d245 35
a279 6
    DO i=1,LEN(str)
       icode=ICHAR(capstr(i:i))
       IF ( icode >=ICHAR("a") .AND. icode <= ICHAR("z")) THEN
          capstr(i:i)=char(icode+offset)
       ENDIF
    ENDDO
d281 1
a281 2
    outstr=capstr
  END FUNCTION Capitalize
d283 3
a285 4
!=============================== lowercase ==========================
FUNCTION lowercase(str) RESULT (outstr)
!=============================== lowercase ==========================
    ! takes A-Z and replaces with a-z 
a286 1
! (Obviously, a crude theft from the above)
d292 1
a292 2
    CHARACTER(LEN=LEN(STR))::capstr
    INTEGER::i,icode,offset
d294 1
a294 1
    capstr=str
d297 2
a298 2
    DO i=1,LEN(str)
       icode=ICHAR(capstr(i:i))
d300 3
a302 27
          capstr(i:i)=char(icode+offset)
       ENDIF
    ENDDO

    outstr=capstr
END FUNCTION lowercase

  Function depunctuate(str) result (outstr)
    ! Function that removes punctuation and replaces with blanks
    ! Added by HCP. This depends on the native character set being 
    ! ASCII. 
    !--------Argument--------!
    character(len=*),intent(in)::str
    character(len=len(str))::outstr
    !----------Local vars----------!
    integer::i,icode
    !----------Executable part----------!
    outstr=str
    do i=1 ,len(str)
        icode=ichar(str(i:i))
        if(  (icode >= 33 .and. icode <= 47).or.&
             (icode >= 58 .and. icode <=64).or. &
             (icode >= 91 .and. icode <=96).or. &
             (icode >= 123)) then
           outstr(i:i)=" "
        endif
    enddo
d304 1
a304 1
  end Function depunctuate
d306 1
a306 1
  !---------------------------------------------------------------------------
d353 1
a353 1
    ENDIF
d359 1
a359 1
    ENDIF
d375 1
a375 1
       ENDIF
d394 1
a394 1
       endif
d403 1
a403 1
       endif
d409 1
a409 1
       ENDIF
d419 1
a419 1
    END SUBROUTINE ReadCompleteLineWithoutComments
d421 1
a421 1
    !---------------------------------------------------------------------------
d423 23
a445 121
    ! This subroutine is based on my IDL one of the same name.
    ! A line of input is split into sets of words.  There are two ways in which
    ! this can be invoked.  Typically it is split into `first' and 'rest'
    ! However, if the threeway option is given it is split to first, rest and
    ! last.

    ! Note that there is a slight subtlety here, spaces are treated specially
    ! due to the use of TRIM.  Thus while two commas in a row would count as
    ! two delimters, two spaces would count as one. Also if , is the delimeter
    ! then ,<space> counts as complete delimiter.

    SUBROUTINE SplitWords(line,first,rest,last,&
         & threeWay,delimiter)

      ! Dummy arguments

      CHARACTER (LEN=*), INTENT(IN) :: line
      CHARACTER (LEN=*), INTENT(OUT) :: first
      CHARACTER (LEN=*), INTENT(OUT) :: rest
      CHARACTER (LEN=*), INTENT(OUT), OPTIONAL :: last

      LOGICAL, INTENT(IN), OPTIONAL :: threeWay
      CHARACTER (LEN=*), INTENT(IN), OPTIONAL :: delimiter

      ! Local variables

      CHARACTER (LEN=1) :: useDelimiter
      LOGICAL :: useThreeWay
      CHARACTER (LEN=LEN(line)) useLine ! Line with leading spaces removed

      INTEGER :: firstDelimiterPos,lastDelimiterPos,trimmedLen

      ! Executable code

      useLine=ADJUSTL(line)
      trimmedLen=LEN_TRIM(useLine)

      IF (PRESENT(delimiter)) THEN
         useDelimiter=delimiter
      ELSE
         useDelimiter=","
      ENDIF

      IF (PRESENT(threeWay)) THEN
         useThreeWay=threeWay 
      ELSE 
         useThreeWay=.FALSE.
      ENDIF

      ! Clear some results by default

      IF (PRESENT(last)) last=""
      rest=""

      ! Find the first delimiter

      firstDelimiterPos=INDEX(useLine,useDelimiter)

      IF (firstDelimiterPos == 0) THEN
         first=useLine
      ELSE
         first=useLine(1:firstDelimiterPos-1)
         IF (useThreeWay) THEN
            ! In three way mode, find the last delimiter
            lastDelimiterPos=INDEX(TRIM(useLine),useDelimiter,back=.TRUE.)
            IF (PRESENT(last) .AND. &
                 & lastDelimiterPos /= trimmedLen) THEN
               last=TRIM(useLine(lastDelimiterPos+1:))
            ENDIF
            IF (firstDelimiterPos+1 <= lastDelimiterPos-1) THEN
               rest=TRIM(useLine(firstDelimiterPos+1:lastDelimiterPos-1))
            ENDIF
         ELSE
            IF (firstDelimiterPos /= trimmedLen) THEN
               rest=TRIM(useLine(firstDelimiterPos+1:))
            ENDIF
         ENDIF
      ENDIF

     END SUBROUTINE SplitWords

     ! ------------------------------------------------------------------------
     
     ! This subroutine takes an array of strings and returns another containing
     ! only the unique entries. The resulting array is supplied by the caller
     ! Some checking is done to make sure it's appropriate
     
     SUBROUTINE GetUniqueStrings(inList,outList,noUnique)
       ! Dummy arguments
       CHARACTER (LEN=*), DIMENSION(:) :: inList
       CHARACTER (LEN=*), DIMENSION(:) :: outList
       INTEGER :: noUnique ! Number of unique entries
       
       ! Local variables
       INTEGER :: i,j           ! Loop counters
       LOGICAL, DIMENSION(:), ALLOCATABLE :: duplicate ! Set if already found
       INTEGER :: status        ! Status from allocate

       INTEGER :: inSize

       ! Executable code, setup arrays

       inSize=SIZE(inList)
       ALLOCATE (duplicate(inSize), STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"duplicate")
       DO i=1,inSize
          duplicate(i)=.FALSE.
       END DO

       ! Go through and find duplicates

       DO i=1,inSize-1 ! Don't bother with last one
          IF (.NOT. duplicate(i)) THEN
             DO j=i+1,inSize
                IF (inList(j)==inList(i)) duplicate(j)=.TRUE.
             END DO
          ENDIF
       END DO
       
       ! Count how many unique ones there are
d447 1
a447 20
       noUnique=0
       DO i=1,inSize
          IF (.NOT. duplicate(i)) noUnique=noUnique+1
       END DO
       
       IF (noUnique>SIZE(outList)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & "outList too small")
       IF (LEN(outList)<LEN(inList)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & "outList strings to small")
       outList=""

       j=1
       DO i=1,noUnique
          UniqueHuntLoop: DO
             IF (.NOT. duplicate(j)) EXIT UniqueHuntLoop
             j=j+1
          END DO UniqueHuntLoop
          outList(i)=inList(j)
          j=j+1
       ENDDO
d449 3
a451 2
       DEALLOCATE(duplicate)
     END SUBROUTINE GetUniqueStrings
d453 1
a453 1
     ! ------------------------------------------------------------------------
d455 1
a455 7
     ! This routine does a simple linear search for a string in a list.
     ! If the case insensitive flag is set the strings are capitalized first.
     ! If the test substring flag is set, the string is tested as a substring.
     ! If the listInString flag is set, the array list is tested as substrings
     !  against the string; otherwise, the string is tested as a substring
     !  against the array list.
     ! If the string is not found, 0 is returned
d457 2
a458 20
     FUNCTION LinearSearchStringArray (list, string, caseInsensitive, &
          & testSubstring, listInString) RESULT (sindex)
       
       ! Dummy arguments
       CHARACTER (LEN=*), DIMENSION(:) :: list
       CHARACTER (LEN=*) :: string
       LOGICAL, intent (in), OPTIONAL :: caseInsensitive
       LOGICAL, intent (in), OPTIONAL :: testSubstring
       LOGICAL, intent (in), OPTIONAL :: listInString


       ! Function result
       INTEGER :: sindex   ! matching string index (0 = not found)

       ! Local variables
       INTEGER :: i
       LOGICAL :: useCaseInsensitive
       LOGICAL :: testForSubstring
       LOGICAL :: testForList
       LOGICAL :: found
d460 5
a464 1
       ! Executable code
d466 5
a470 5
       IF (PRESENT(caseInsensitive)) THEN
          useCaseInsensitive = caseInsensitive
       ELSE
          useCaseInsensitive = .FALSE.
       ENDIF
d472 1
a472 5
       IF (PRESENT(testSubstring)) THEN
          testForSubstring = testSubstring
       ELSE
          testForSubstring = .FALSE.
       ENDIF
d474 2
a475 5
       IF (PRESENT(listInString)) THEN
          testForList = listInString
       ELSE
          testForList = .FALSE.
       ENDIF
d477 1
a477 2
       found = .FALSE.
       sindex = 0
d479 1
a479 2
       ! Put the conditional outside the loop for speed (not that it will make 
       ! much difference for strings)
d481 14
a494 18
       IF (useCaseInsensitive) THEN
          linSearchStringInsens: DO i = 1, SIZE(list)
             IF (testForSubstring) THEN
                IF (testForList) THEN
                   found = (INDEX (Capitalize(TRIM(string)), &
                        & Capitalize(TRIM(list(i)))) /= 0)
                ELSE
                   found = (INDEX (Capitalize(TRIM(list(i))), &
                        & Capitalize(TRIM(string))) /= 0)
                END IF
             ELSE
                found = (Capitalize(TRIM(list(i))) == Capitalize(TRIM(string)))
             ENDIF
             IF (found) THEN
                sindex = i
                EXIT linSearchStringInsens
             ENDIF
          END DO linSearchStringInsens
d496 2
a497 38
          linSearchStringSens: DO i = 1, SIZE(list)
             IF (testForSubstring) THEN
                IF (testForList) THEN
                   found = (INDEX (TRIM(string), TRIM(list(i))) /= 0)
                ELSE
                   found = (INDEX (TRIM(list(i)), TRIM(string)) /= 0)
                ENDIF
             ELSE
                found = (TRIM(list(i)) == TRIM(string))
             ENDIF
             IF (found) THEN
                sindex = i
                EXIT linSearchStringSens
             ENDIF
          END DO linSearchStringSens
       ENDIF

     END FUNCTION LinearSearchStringArray

     FUNCTION CompressString (str) RESULT (outstr)

       ! Removes all leading and embedded blanks from a string
       !--------Argument--------!

       CHARACTER (LEN=*), INTENT(IN) :: str
       CHARACTER (LEN=LEN(str)) :: outstr

       !----------Local vars----------!
       INTEGER :: i, n

       !----------Executable part----------!

       outstr = " "
       n = 0
       DO i = 1, LEN(str)
          IF (str(i:i) /= " ") THEN
             n = n + 1
             outstr(n:n) = str(i:i)
d499 2
a500 1
       END DO
d502 1
a502 1
     END FUNCTION CompressString
@


2.0
log
@Change revision to 2.0
@
text
@d13 1
a13 1
   "$Id: MLSStrings.f90,v 1.21 2000/09/05 10:59:32 pumphrey Exp $"
d73 27
d510 3
@


1.20
log
@Added listInString flag in LinearSearchStringArray to determine whether to test
the list array for a substring match against the string or to determine whether
to test the string for a substring match in the list array.
@
text
@d13 1
a13 1
   "$Id: MLSStrings.f90,v 1.20 2000/05/05 20:25:38 perun Exp $"
d187 7
a193 2
       
       inputLine=inputLine(1:LEN_TRIM(inputLine)-gotContinuation)
d483 2
a484 59
! Revision 1.20  2000/05/05 20:25:38  perun
! Added listInString flag in LinearSearchStringArray to determine whether to test
! the list array for a substring match against the string or to determine whether
! to test the string for a substring match in the list array.
!
! Revision 1.19  2000/05/05 19:46:47  perun
! Corrected call to INDEX for LinearSearchStringArray
!
! Revision 1.18  2000/05/05 14:30:06  perun
! Added testSubstring flag to LinearSearchStringArray
!
! Revision 1.17  2000/02/02 16:48:59  pumphrey
! Added function to count words in a string (hcp)
!
! Revision 1.16  2000/02/02 14:42:08  perun
! Made CompressString more compact
!
! Revision 1.15  2000/01/31 20:58:16  perun
! Added CompressString
!
! Revision 1.14  1999/12/08 20:33:18  pumphrey
! HCP Fixed tiny bug in ReadCompleteLineWithoutComments
!
! Revision 1.13  1999/12/06 15:57:59  pumphrey
! Changed fullLine arg of ReadCompleteLineWithoutComments to InOut
!
! Revision 1.12  1999/12/06 14:19:17  pumphrey
! HCP added function depunctuate to replace non-alphanumeric chars in a
! string with blanks
!
! Revision 1.11  1999/12/01 23:01:41  livesey
! Before renaming things to upper/lower case
!
! Revision 1.10  1999/12/01 20:42:24  livesey
! Spelt RCSfile right!
!
! Revision 1.9  1999/12/01 20:42:08  livesey
! Tried File
!
! Revision 1.8  1999/12/01 20:41:04  livesey
! Tried RCSFile instead
!
! Revision 1.7  1999/12/01 20:40:22  livesey
! Changed dollar name dollar to dollar file dollar
!
! Revision 1.6  1999/12/01 20:39:18  livesey
! Changed usage of MLSMessage
!
! Revision 1.5  1999/11/11 01:38:28  livesey
! Changed indices to 1:n from 0:n-1
!
! Revision 1.4  1999/11/09 00:29:28  livesey
! Added LinearSearchStringArray
!
! Revision 1.3  1999/11/04 00:06:12  livesey
! Undid DTC's test change.
!
! Revision 1.2  1999/11/04 00:00:10  dcuddy
! dtc made change
d486 2
a487 2
! Revision 1.1  1999/11/03 23:53:57  livesey
! Added mlsstrings and signalsfile
@


1.1
log
@Added mlsstrings and signalsfile
@
text
@d5 2
d10 1
a10 1
  PRIVATE :: id
d13 2
a14 1
   "$Id: MLSStrings.f90,v 1.1 1999/11/03 23:53:57 livesey Exp $"
d22 23
d47 1
a47 1
  ! of same name)
d73 23
d114 5
a118 1
    CHARACTER(LEN=*), INTENT(OUT) :: fullLine ! Output line
d176 9
a184 2
       gotContinuation=INDEX(inputLine(lastChar:lastChar),useContinuationChar)
       
d292 2
a293 2
     ! only the unique entries.  The resulting array is dimensioned in the same
     ! manner as the input array (i.e. from 0 or 1 or anything for that matter)
d295 1
a295 1
     SUBROUTINE GetUniqueStrings(inList,outList)
d298 2
a299 1
       CHARACTER (LEN=LEN(inList)), DIMENSION(:), POINTER :: outList
a302 1
       INTEGER :: noUnique      ! Number of unique entries
d306 2
d310 5
a314 4
       ALLOCATE (duplicate(LBOUND(inList,1):UBOUND(inList,1)), STAT=status)
       IF (status /= 0) CALL MLSMessage("Allocation failed for duplicate", &
            & error=.TRUE.)
       DO i=LBOUND(inList,1),UBOUND(inList,1)
d320 1
a320 1
       DO i=LBOUND(inList,1),UBOUND(inList,1)-1 ! Don't bother with last one
d322 1
a322 1
             DO j=i+1,UBOUND(inList,1)
d327 2
a329 1
       ! Count how many unique ones there are
d331 1
a331 1
       DO i=LBOUND(inList,1),UBOUND(inList,1)
d334 6
d341 2
a342 9
       ! Setup the result
       DEALLOCATE(outList,STAT=status)      ! Tidy up just in case

       ALLOCATE(outList(LBOUND(inList,1):LBOUND(inList,1)+noUnique),STAT=status)
       IF (status /= 0) CALL MLSMessage("Allocation failed for outList", &
            & error=.TRUE.)

       j=LBOUND(inList,1)
       DO i=LBOUND(outList,1),UBOUND(outList,1)
d348 1
d351 1
a351 1
       !DEALLOCATE(duplicate)
d353 1
d355 11
a365 5
     
       ! This one doesn't belong here!
     SUBROUTINE MLSMessage(message,error)
       CHARACTER (LEN=*), INTENT(IN) :: message
       LOGICAL, INTENT(IN), OPTIONAL :: error
d367 31
a397 1
       LOGICAL :: useError
d399 2
a400 3
       PRINT*,message
       IF (PRESENT(error)) THEN 
          useError=error
d402 1
a402 1
          useError=.FALSE.
a403 2
       IF (useError) STOP
     END SUBROUTINE MLSMessage
d405 68
d478 50
a527 2
! Revision 1.1  1999/11/03 23:53:57  livesey
! Added mlsstrings and signalsfile
d529 2
a530 2
! Revision 1.4  1999/11/03 03:59:26  livesey
! Transfer home
d532 2
a533 2
! Revision 1.3  1999/11/03 03:42:28  livesey
! Transfer home
d535 2
a536 2
! Revision 1.2  1999/11/03 03:40:17  livesey
! Changed LEN for first,last,rest in SplitWords
d538 2
a539 2
! Revision 1.1  1999/11/03 02:53:56  livesey
! Added f90 stuff
@

