head	2.5;
access;
symbols
	v5-02-NRT-19:2.5
	v6-00:2.5
	v5-02-NRT-18:2.5
	v5-02:2.5
	v5-01-NRT-17:2.5
	v5-01-NRT-16:2.5
	v5-01-NRT-15:2.5
	v5-01-NRT-14:2.5
	neuralnetworks-1-0:2.5.0.12
	cfm-single-freq-0-1:2.5.0.10
	v5-01:2.5
	v5-00:2.5
	v4-23-TA133:2.5.0.8
	mus-emls-1-70:2.5.0.6
	rel-1-0-englocks-work:2.5.0.4
	VUMLS1-00:2.5
	VPL1-00:2.5
	V4-22-NRT-08:2.5
	VAM1-00:2.5
	V4-21:2.5.0.2
	V4-13:2.5
	V4-12:2.5
	V4-11:2.5
	V4-10:2.5
	V3-43:2.4
	M4-00:2.4
	V3-41:2.4
	V3-40-PlusGM57:2.4.0.2
	V2-24-NRT-04:2.3
	V3-33:2.4
	V2-24:2.3
	V3-31:2.4
	V3-30-NRT-05:2.4
	cfm-01-00:2.4
	V3-30:2.4
	V3-20:2.4
	V3-10:2.4
	V2-23-NRT-02:2.3
	V2-23:2.3
	V2-22-NRT-01:2.3
	V2-22:2.3
	V2-21:2.2
	V2-20:2.2
	V2-11:2.2
	V2-10:2.2
	V2-00:2.2;
locks; strict;
comment	@# @;


2.5
date	2013.06.12.02.16.15;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2009.06.23.18.25.44;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2007.07.25.20.10.07;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2006.02.10.21.20.25;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2006.02.07.00.58.18;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.5
log
@Cruft removal
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module wmoTropopause ! Based on stuff from Reichler et al
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_WARNING
  implicit none
  private

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: wmoTropopause.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  public:: extraTropics, tropo, twmo
  real, parameter                           :: gamma=-0.002 ! K/m

  interface extraTropics
    module procedure extraTropics_real, extraTropics_double
  end interface
contains

subroutine tropo(temp, nlon, nlat, nlev, pres, plimu, pliml, plimlex, &
  & dofill, tp, tperr)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! determination of tropopause height from gridded temperature data
!
! reference: Reichler, T., M. Dameris, and R. Sausen (2003)
!
! input:    temp(nlon,nlat,nlev)    3D-temperature field (K)
!           nlon                    grid points in x
!           nlat                    grid points in y
!           pres(nlev)              pressure levels in hPa
!           plimu                   upper limit for tropopause pressure (Pa)
!           pliml                   lower limit for tropopause pressure (Pa)
!           plimlex                 lower limit in extratropics (+/-15%) (Pa)
!           dofill                  fill undefined values with neighboring points if .true.
!
! output:   tp(nlon, nlat)          tropopause pressure in Pa
!           tperr                   # of undetermined values
!
!  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  
!  - Note: -
! Do not use this  subroutine directly, at least
! not without understanding its assumptions
! For example, the input pressure levels pres(nlev) must be
! in hPa, sorted (either increasing or decreasing), and the same for
! every longitude and latitude
! The temperatures must be in Kelvin and must not include any fill values
! (e.g., -999.99 or 1.e12)
! The latitudinal grid must be ordered from pole to pole, evenly spaced
! The three limits plimu, pliml, and plimlex should be in Pa
! How plimlex is applied deserves even more careful explanation:
! (From an email Gloria Manney sent)
!   I suspect that the polar regions are, however, the only place where
!   you'd want something like this if you did at all.  The situation I
!   can think of it happening in is one where there is a very deep isothermal
!   layer in the lower stratosphere, which makes it difficult to define
!   the tropopause - this happens sometimes in the polar regions in SH
!   winter and in very cold NH winters.  And if it is that sort of case,
!   the tropopause isn't well-defined anyway.
! 
! If plimlex <= pliml, the special definition of extra-tropics won't
! matter. Whenever the tropopause pressure would fall below pliml, it is
! replaced with a fill value. If, however, plimlex > pliml, then
! in "extratropical" regions the tropopause pressure is not allowed
! to fall below plimlex. Assuming the latitudes range from pole to pole,
! This extratropics means for lat < -63 deg or lat > 63 deg.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

implicit none

integer,intent(in)                        :: nlon, nlat, nlev
real,intent(in),dimension(nlon,nlat,nlev) :: temp
real,intent(in),dimension(nlev)           :: pres
real, intent(in)                          :: plimu, pliml, plimlex
logical, intent(in)                       :: dofill
real,intent(out),dimension(nlon,nlat)     :: tp
integer,intent(out)                       :: tperr

integer                                   :: i, invert, ifil
integer                                   :: lon, lat
real,dimension(nlev)                      :: t
real,dimension(nlev)                      :: p
real                                      :: trp

! check vertical orientation of data
if (pres(1) .gt. pres(2)) then
  invert=1
  do i=1,nlev
    p(i)=pres(nlev+1-i)*100.  ! hPa > Pa
  enddo
else
  invert=0
  do i=1,nlev
    p(i)=pres(i)*100.         ! hPa > Pa
  enddo
endif

tperr = 0
do lon=1,nlon
do lat=1,nlat
  if (invert.eq.1) then
    do i=1,nlev
      t(i)=temp(lon,lat,nlev+1-i)
    enddo
  else
    do i=1,nlev
      t(i)=temp(lon,lat,i)
    enddo
  endif
  ! call twmo(nlev, t, p, plimu, pliml, gamma, trp)
  call twmo(nlev, t, p, plimu, pliml, trp)
  if (lat.lt..15*nlat.and.trp.lt.plimlex) trp=min(-99., trp)
  if (lat.gt..85*nlat.and.trp.lt.plimlex) trp=min(-99., trp)
  tp(lon,lat)=trp
  if(trp.lt..0) then
    tperr = tperr+1    
  endif
end do
end do

! fill holes
if (dofill) then
  call fill(tp, nlon, nlat, ifil)
  if (ifil.ne.tperr) then
    print*, 'Inconsistent'
    stop
  endif
endif

return
end subroutine tropo

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! twmo
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! subroutine twmo(level, t, p, plimu, pliml, gamma, trp)
subroutine twmo(level, t, p, plimu, pliml, trp)

implicit none
integer,intent(in)                  :: level
real,intent(in),dimension(level)    :: t, p
real,intent(in)                     :: plimu, pliml !, gamma
real,intent(out)                    :: trp

real,parameter                      :: kap=0.286
real,parameter                      :: faktor = -9.81/287.0
real,parameter                      :: deltaz = 2000.0
real,parameter                      :: ka1=kap-1.

real                                :: pmk, pm, a, b, tm, dtdp, dtdz
real                                :: ag, bg, ptph
real                                :: pmk0, dtdz0
real                                :: p2km, asum, aquer
real                                :: pmk2, pm2, a2, b2, tm2, dtdp2, dtdz2
integer                             :: icount, jj
integer                             :: j


trp=-999.0                          ! negative means not valid
if( maxval(t) > 10000. .or. minval(t) < 0. ) return
trp=-99.0                           ! negative means not valid
do j=level,2,-1

   ! dt/dz
   pmk= .5 * (p(j-1)**kap+p(j)**kap)
   pm = pmk**(1/kap)              
   a = (t(j-1)-t(j))/(p(j-1)**kap-p(j)**kap)
   b = t(j)-(a*p(j)**kap)
   tm = a * pmk + b              
   dtdp = a * kap * (pm**ka1)
   dtdz = faktor*dtdp*pm/tm

   ! dt/dz valid?
   if (j.eq.level)    go to 999     ! no, start level, initialize first
   if (dtdz.le.gamma) go to 999     ! no, dt/dz < -2 K/km
   if (pm.gt.plimu)   go to 999     ! no, too low

   ! dtdz is valid, calculate tropopause pressure
   if (dtdz0.lt.gamma) then
      ag = (dtdz-dtdz0) / (pmk-pmk0)    
      bg = dtdz0 - (ag * pmk0)         
      ptph = exp(log((gamma-bg)/ag)/kap)
   else
      ptph = pm
   endif

   if (ptph.lt.pliml) go to 999    
   if (ptph.gt.plimu) go to 999          

   ! 2nd test: dtdz above 2 km must not exceed gamma
   p2km = ptph + deltaz*(pm/tm)*faktor          ! p at ptph + 2km
   asum = 0.0                                   ! dtdz above
   icount = 0                                   ! number of levels above

   ! test until apm < p2km
   do jj=j,2,-1

       pmk2 = .5 * (p(jj-1)**kap+p(jj)**kap)    ! p mean ^kappa
       pm2 = pmk2**(1/kap)                      ! p mean
       if(pm2.gt.ptph) go to 110                ! doesn't happen
       if(pm2.lt.p2km) go to 888                ! ptropo is valid

       a2 = (t(jj-1)-t(jj))                     ! a
       a2 = a2/(p(jj-1)**kap-p(jj)**kap)
       b2 = t(jj)-(a2*p(jj)**kap)               ! b
       tm2 = a2 * pmk2 + b2                     ! T mean
       dtdp2 = a2 * kap * (pm2**(kap-1))        ! dt/dp
       dtdz2 = faktor*dtdp2*pm2/tm2
       asum = asum+dtdz2
       icount = icount+1
       aquer = asum/float(icount)               ! dt/dz mean
  
       ! discard ptropo ?
        if (aquer.le.gamma) go to 999           ! dt/dz above < gamma

110 continue
    enddo                           ! test next level

888 continue                        ! ptph is valid
    trp = ptph
    return

999 continue                        ! continue search at next higher level
    pmk0 = pmk
    dtdz0  = dtdz

enddo

! no tropopouse found
return
end subroutine twmo

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine fill(dat, ix, iy, ir)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

integer, intent(in)                 :: ix, iy
integer, intent(out)                :: ir
real, dimension(ix,iy)              :: dat
real, dimension(4)                  :: help
integer                             :: jx, jy, icount, ipk, ic
real                                :: drop, sum
integer                             :: jj
icount = 0
do jx=1,ix
do jy=1,iy
  if (loch(dat(jx,jy))) icount = icount+1
enddo
enddo
if (icount.gt.(ix*iy)/2) then
  call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'ERROR: Too many holes (>50%)' )
endif
ir = icount
if (icount.eq.0) return

ipk = 0
10   continue
do jx=1,ix
do jy=1,iy
     if(loch(dat(jx,jy))) then
          drop = dat(jx,jy)

        ! left edge
          if (jx.eq.1) then
          if (jy.eq.1) then
          help(1) = dat(jx,jy+1)
          help(2) = dat(jx+1,jy)
          help(3) = drop
          help(4) = drop
          go to 200
          endif
          if (jy.eq.iy) then
          help(1) = drop
          help(2) = dat(jx+1,jy)
          help(3) = dat(jx,jy-1)
          help(4) = drop
          go to 200
          endif
          help(1) = dat(jx,jy+1)
          help(2) = dat(jx+1,jy)
          help(3) = dat(jx,jy-1)
          help(4) = drop
          go to 200
          endif

          ! right edge
          if (jx.eq.ix) then
          if (jy.eq.1) then
          help(1) = dat(jx,jy+1)
          help(2) = drop
          help(3) = drop
          help(4) = dat(jx-1,jy)
          go to 200
          endif
          if (jy.eq.iy) then
          help(1) = drop
          help(2) = drop
          help(3) = dat(jx,jy-1)
          help(4) = dat(jx-1,jy)
          go to 200
          endif
          help(1) = dat(jx,jy+1)
          help(2) = drop
          help(3) = dat(jx,jy-1)
          help(4) = dat(jx-1,jy)
          go to 200
          endif

        ! bottom edge
          if (jy.eq.1) then
          help(1) = dat(jx,jy+1)
          help(2) = dat(jx+1,jy)
          help(3) = drop
          help(4) = dat(jx-1,jy)
          go to 200
          endif

          ! upper edge
          if(jy.eq.iy) then
          help(1) = drop
          help(2) = dat(jx+1,jy)
          help(3) = dat(jx,jy-1)
          help(4) = dat(jx-1,jy)
          go to 200
          endif

        ! no edge
          help(1) = dat(jx,jy+1)
          help(2) = dat(jx+1,jy)
          help(3) = dat(jx,jy-1)
          help(4) = dat(jx-1,jy)

 200      continue

          ic = 0
          sum = 0.0
          do jj=1,4
            if(.not.loch(help(jj))) then
              sum = sum+help(jj)
              ic = ic+1
            endif
          enddo

          if (ic.gt.0) then
            dat(jx,jy) = sum/float(ic)  ! fill with mean of valid
            ipk = ipk+1                 ! neighbourpoints
          endif

     endif
     if (ipk .ge. icount) return    ! until all filled
enddo
enddo
go to 10
contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
logical function loch(x)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

real, intent(in)        :: x

real, parameter         :: edge = -98.0
if (x.lt.edge) then
  loch = .true.
else
  loch = .false.
endif
return
end function loch
end subroutine fill

   !-------------------- ExtraTropics ---------------------
   ! This family of functions answers the question
   ! Is the latitude outside the Northern Hemisphere and
   ! Southern Hemisphere Boundaries marking the extra-tropics
   ! These are equivalent to the values Reichler uses
   ! if (lat.lt..15*nlat.and.trp.lt.plimlex) trp=min(-99., trp)
   ! if (lat.gt..85*nlat.and.trp.lt.plimlex) trp=min(-99., trp)
   ! Assuming nlat spans the range from the South Pole to the North
   ! Note that this definition of "extra tropical" differs from
   ! others, e.g. < -30 or > 30
   !
   ! So far we have always used the same values for pliml and plimlex
   ! So this has had no effect
   function extraTropics_real(lat) result(sooDesu)
     ! Dummy args
     real, intent(in) :: lat ! latitude in degrees
     logical :: sooDesu
     ! Local variables
     real, parameter :: NHBoundary =  180 * 0.85 - 90.
     real, parameter :: SHBoundary =  180 * 0.15 - 90.
     ! Executable
     SooDesu = ( lat < SHBoundary .or. lat > NHBoundary )
   end function extraTropics_real

   function extraTropics_double(lat) result(sooDesu)
     ! Dummy args
     double precision, intent(in) :: lat ! latitude in degrees
     logical :: sooDesu
     ! Local variables
     double precision, parameter :: NHBoundary =  180 * 0.85 - 90.
     double precision, parameter :: SHBoundary =  180 * 0.15 - 90.
     ! Executable
     SooDesu = ( lat < SHBoundary .or. lat > NHBoundary )
   end function extraTropics_double

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: wmoTropopause.f90,v 2.4 2009/06/23 18:25:44 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module wmoTropopause

! $Log: wmoTropopause.f90,v $
! Revision 2.4  2009/06/23 18:25:44  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.3  2007/07/25 20:10:07  vsnyder
! Delete declaration for unused variable
!
! Revision 2.2  2006/02/10 21:20:25  pwagner
! Added ExtraTropics function
!
! Revision 2.1  2006/02/07 00:58:18  pwagner
! First commit
!
@


2.4
log
@Prevent Intel from optimizing ident string away
@
text
@d19 1
a19 1
       "$RCSfile: $"
d165 1
a165 1
real                                :: pm0, pmk0, dtdz0
a236 1
    pm0 = pm
d424 1
a424 1
       "$Id: read_apriori.f90 is it here $"
d434 3
@


2.3
log
@Delete declaration for unused variable
@
text
@d19 1
a19 1
       "$RCSfile: wmoTropopause.f90,v $"
d422 1
a423 1
!---------------------------- RCS Ident Info -------------------------------
d425 2
a426 3
       "$Id: wmoTropopause.f90,v 2.2 2006/02/10 21:20:25 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d428 1
d430 1
d435 3
@


2.2
log
@Added ExtraTropics function
@
text
@d91 1
a91 1
integer                                   :: i, j, invert, ifil
d425 1
a425 1
       "$Id: wmoTropopause.f90,v 2.1 2006/02/07 00:58:18 pwagner Exp $"
d434 3
@


2.1
log
@First commit
@
text
@d19 1
a19 1
       "$RCSfile: ncep_dao.f90,v $"
d23 1
a23 1
  public:: tropo, twmo
d26 3
d387 35
d425 1
a425 1
       "$Id: wmoTropopause.f90,v 2.39 2005/06/22 17:24:59 pwagner Exp $"
d434 3
@

