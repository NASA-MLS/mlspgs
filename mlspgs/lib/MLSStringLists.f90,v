head	2.92;
access;
symbols
	v5-02-NRT-19:2.92
	v6-00:2.92
	v5-02-NRT-18:2.92
	v5-02:2.82
	v5-01-NRT-17:2.91
	v5-01-NRT-16:2.91
	v5-01-NRT-15:2.90
	v5-01-NRT-14:2.90
	neuralnetworks-1-0:2.89.0.4
	cfm-single-freq-0-1:2.89.0.2
	v5-01:2.82
	v5-00:2.82
	v4-23-TA133:2.81.0.2
	mus-emls-1-70:2.79.0.2
	rel-1-0-englocks-work:2.78.0.2
	VUMLS1-00:2.74
	VPL1-00:2.70
	V4-22-NRT-08:2.70
	VAM1-00:2.69
	V4-21:2.66.0.2
	V4-13:2.66
	V4-12:2.64
	V4-11:2.64
	V4-10:2.64
	V3-43:2.38
	M4-00:2.54
	V3-41:2.38
	V3-40-PlusGM57:2.38.0.2
	V2-24-NRT-04:2.30
	V3-33:2.43
	V2-24:2.30
	V3-31:2.43
	V3-30-NRT-05:2.40
	cfm-01-00:2.40
	V3-30:2.38
	V3-20:2.38
	V3-10:2.38
	V2-23-NRT-02:2.30
	V2-23:2.30
	V2-22-NRT-01:2.30
	V2-22:2.30
	V2-21:2.23
	V2-20:2.23
	V2-11:2.23
	V2-10:2.23
	V2-00:2.22
	V1-51:2.5
	V1-50:2.5
	V1-45:2.2
	V1-44:2.2;
locks; strict;
comment	@# @;


2.92
date	2022.11.16.23.10.21;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2022.01.04.23.44.11;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2021.04.29.22.52.13;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2020.06.24.20.52.33;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2020.06.09.21.55.10;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2020.06.03.23.39.49;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2020.05.20.23.33.33;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2019.11.11.21.17.45;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2019.10.22.18.50.27;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2019.10.21.23.18.01;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2019.07.09.22.59.54;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2019.01.10.21.42.39;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2018.12.11.01.21.43;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2018.06.26.23.59.09;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2017.12.12.21.22.12;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2017.12.07.22.06.12;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2017.09.25.17.24.19;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2017.08.23.16.43.48;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2017.01.25.21.12.36;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2016.12.16.21.57.09;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2016.12.14.01.23.21;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2016.12.08.00.16.41;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2016.01.20.00.20.44;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2015.09.03.20.22.21;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2015.05.06.20.46.11;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2015.03.31.22.11.25;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2014.08.19.23.15.16;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2014.08.05.00.16.28;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2014.01.09.00.25.42;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2013.09.14.01.20.25;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2013.09.12.23.26.47;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2013.08.28.00.38.17;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2013.06.13.00.41.27;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2013.05.23.16.08.20;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2013.05.22.20.25.44;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2013.05.16.18.18.37;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2013.05.07.21.01.21;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2013.04.05.00.47.42;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2013.04.04.22.31.05;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2012.08.30.20.51.45;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2012.08.27.22.54.58;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2012.07.20.17.01.06;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2012.07.11.20.01.43;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2012.07.10.15.17.15;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2012.06.27.17.51.57;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2012.05.08.17.44.30;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2012.01.05.01.18.33;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2011.04.20.16.35.15;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2011.02.18.18.00.10;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2010.11.05.22.23.01;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2010.11.03.18.29.07;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2010.06.22.16.51.32;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2010.04.16.23.38.34;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2009.06.23.18.22.49;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2009.06.16.17.07.05;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2008.12.11.19.39.20;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2008.05.21.20.00.19;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2008.05.09.00.24.08;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2008.05.02.00.08.13;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2008.01.23.21.24.43;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2007.12.19.01.28.29;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2007.09.20.17.39.59;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2007.07.31.22.46.51;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2007.06.26.00.19.21;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2007.06.21.00.49.52;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2007.05.22.20.56.02;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2007.05.14.21.51.51;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2007.04.20.22.27.49;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2006.07.12.20.37.44;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2006.04.21.23.57.05;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2006.03.03.23.06.35;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2006.02.24.01.14.54;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2006.02.21.19.06.25;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2006.02.16.00.59.08;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2006.01.26.00.31.46;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2005.11.11.21.39.12;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2005.10.18.22.52.04;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2005.09.22.23.33.58;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2005.09.14.22.53.26;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2005.08.08.23.53.18;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2005.08.05.16.31.07;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2005.07.21.23.38.18;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2005.06.14.18.32.25;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2005.03.26.00.06.54;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2005.02.03.19.04.58;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2004.10.19.22.59.08;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2004.10.13.00.51.09;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2004.09.16.00.16.46;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2004.08.05.22.47.02;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2004.08.04.23.17.30;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.92
log
@Fix bug in SwitchDetail when inList has embedded spaces
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module MLSStringLists               ! Module to treat string lists
!=============================================================================

  use IO_Stuff, only: PrintMessage
  use MLSCommon, only: BareFNLen, MLSMSG_Error
  use MLSFinds, only: FindFirst, FindLast
  use MLSStrings, only: Capitalize, CompressString, IsAlphabet, LowerCase, &
    & NCopies, ReadIntsFromChars, ReadNumsFromChars, Replace, Reverse, &
    & Reverse_Trim, SplitDetails, Squeeze, StrEq, Trim_Safe, WriteIntsToChars
  use Sort_M, only: Sortp
  implicit none
  private

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSStringLists.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

!

! === (start of toc) ===
! This module contains some higher-level string handling stuff for mls
! See below for what we mean by a stringList
! Applications include hdf, the Switches string, and command line arguments

!     c o n t e n t s
!     - - - - - - - -

!     (parameters and data)
! STRINGLISTOPTIONS  Default options string
! KEYNOTFOUND        key not found among keyList
! KEYBEYONDHASHSIZE  index of key in keyList > size(hash array)
! LENORSIZETOOSMALL  Either charsize of strs or size(ints) too small

!     (subroutines and functions)
! Array2List         Converts an array of strings to a single string list
! BooleanValue       Evaluate a boolean formula: e.g. 'p and not {q or r)'
! BuildHash          Builds a hash out of a hash constructor like
!                     [ 100mb : 0.5ppmv, 50mb : 0.1ppmv, 31mb : 0.12ppmv ]
! CapitalizeArray    Capitalize each line of an array of lists
! CapitalizeList     Capitalize the 1st char in each element of a list
! CatLists           cats 2 string lists, taking care if either one is blank
! EvaluateFormula    Evaluates a string formula, substituting character values
!                      for occurrences like ${3} with 3rd arg
! ExpandStringRange  Turns '1,2-5,7' into '1,2,3,4,5,7' or ints or logicals
! ExtractSubString   Extracts portion of string sandwiched between sub1 and sub2
! GetHashElement     Returns value from hash list corresponding to key string
! GetMatchedParens   Returns indexes of matched parens '(' ')'
! GetStringElement   Returns n'th element of string list
! GetUniqueInts      Returns array of only unique entries from input array
! GetUniqueList      Returns str list of only unique entries from input list
! GetUniqueStrings   Returns array of only unique entries from input array
! insertHashElement  Insert a scalar or array-valued element into a hash
! Intersection       Return the intersection of two stringlists; may return blank
! IsInList           Is string in list? options may expand criteria
! List2Array         Converts a single string list to an array of strings
! listMatches        Return list of matches for string in a list
! LoopOverFormula    Looping while it evaluates a string formula, substituting
!                      for occurrences like ${arg} with value of arg
! NCharsInFormat     How many characters in a format spec
! NumStringElements  Returns number of elements in string list
! OptionDetail       Returns detail or arg of option in list of options
! ParseOptions       Parse options from commandline
! PutHashElement     Puts value into hash list corresponding to key string
! ReadIntsFromList   Read an array of ints from a string list
! ReadNumsFromList   Read an array of floats from a string list
! RemoveElemFromList Removes occurrence(s) of elem from a string list
! RemoveHashArray    Removes key strings and corresponding values
!                      based on a named array
! RemoveHashElement  Removes key string and corresponding value
! RemoveListFromList Removes occurrence(s) of elems in a string list from another
! RemoveNumFromList  Removes a numbered elem from a string list
! RemoveOption       Removes an option from a list of options
! RemoveSwitchFromList  
!                    Removes a switch from a list of switches
! ReplaceSubString   Replaces occurrence(s) of sub1 with sub2 in a string
! ReverseList        Turns 'abc,def,ghi' -> 'ghi,def,abc'
! ReverseStrings     Turns (/'abc','def','ghi'/) -> (/'ghi','def','abc'/)
! SnipList           Like RemoveElemFromList, but a function
! SortArray          Turns (/'def','ghi','abc'/) -> (/'abc','def','ghi'/)
! SortList           Turns 'def,ghi,abc' -> 'abc,def,ghi'
! StringElement      Returns string element in string list at index number
! StringElementNum   Returns element number of test string in string list
! SwitchDetail       Returns detail level of switch in list of switches
! Unquote            Removes surrounding [quotes]
! Unwrap             Unwrap a multi-line string to a single line
! Wrap               Wrap a string to fit within prescribed width
!                      using separator as newline
! WriteIntsToList    Write an array of ints as a string list
! === (end of toc) ===

! === (start of api) ===
! Array2List (char* inArray(:), char* outList(:), &
!   & [char inseparator], [int ordering], [char leftRight]) 
! log BooleanValue ( char* str, char* lkeys, log lvalues[:] )
! BuildHash (char* Constructor, char* values, &
!   & [char* operator], [char separator], [char* options])
! char* CatLists (char* str1, char* str2)
! CapitalizeArray ( char* inArray(:), char* outArray(:), &
!   & [char inseparator], [char* ignore] )
! char* CapitalizeList ( char* str, [char inseparator], [char* ignore] )
! ExpandStringRange (char* str, char* outst)
! ExtractSubString (char* str, char* outstr, char* sub1, char* sub2, &
!       & [char* how], [log no_trim])
! char* EvaluateFormula (char* formula, char* values(:), [char* values(:)])
! GetHashElement (hash {keys = values}, char* key, 
!   char* outElement, log countEmpty, [char inseparator], [log part_match])
! GetMatchedParens ( char* str, int pairs(2,:) )
! GetStringElement (strlist inList, char* outElement,
!   nElement, log countEmpty, [char inseparator], [int SeparatorLocation] )
! GetUniqueInts (int ints(:), int outs(:), int noUnique, 
!    [int extra(:)], [int fillValue], [int minValue]) 
! GetUniqueList (char* str, char* outstr(:), int noUnique, &
!   & [char inseparator], [log IgnoreLeadingSpaces], [char* fillValue], &
!   & [char* options])
! GetUniqueStrings (char* inList(:), char* outList(:), int noUnique, 
!   [char* extra(:)], [char* fillValue], [char* options])
! char* intersection ( char* str1, char* str2, [char* options] )
! log IsInList ( strlist stringList, char* string, [char* options] )
! List2Array (strlist inList, char* outArray(:), log countEmpty,
!   [char inseparator], [log IgnoreLeadingSpaces])
! char* listMatches (strlist stringList, char* string, [char* options] )
! LoopOverFormula (char* formula, char* arg, char* values(:), char* results(:))
! int nCharsinFormat ( char* Format )
! int NumStringElements(strlist inList, log countEmpty, &
!   & [char inseparator], [int Longestlen])
! char* optionDetail ( strlist inList, &
!     [char single_option], [char* multi_option], [int pattern], &
!     [char delims(2)] )
! ParseOptions(strlist cmdline, char* opts_out(:), &
!     char single_options(:), int pattern, char* multi_options(:), &
!     [char delims(2)], [char* cmdargs(:)] )
! PutHashElement (hash {keys = values}, char* key, 
!   char* elem, log countEmpty, [char inseparator], [log part_match])
! ReadIntsFromList(strlist inList, int ints(:), &
!    & [char inseparator])
! ReadNumsFromList(strlist inList, num nums(:), &
!    & [char inseparator], [char* ignore], [int error])
! RemoveElemFromList(strlist inList, strlist outList, char* elem, &
!    & [char inseparator], [char* options])
! RemoveHashArray (hash {keys = values}, char* key, 
!   log countEmpty, [char inseparator], [log part_match])
! RemoveHashElement (hash {keys = values}, char* key, 
!   log countEmpty, [char inseparator], [log part_match])
! RemoveListFromList(strlist inList, strlist outList, strlist exclude, &
!    & [char inseparator], [char* options])
! RemoveNumFromList(strlist inList, strlist outList, int nElement, &
!    & [char inseparator], [char* options])
! char* RemoveOption ( strlist inList, strlist outList, char* option, &
!    & [int pattern], [char delims(2)] )
! RemoveSwitchFromList( strlist inList, strlist outList, char* switch, &
!    & [char inseparator], [char* options] )
! ReplaceSubString (char* str, char* outstr, char* sub1, char* sub2, &
!       & [char* which], [log no_trim])
! strlist ReverseList (strlist str, [char inseparator])
! ReverseStrings (char* str[*], char* reverse[*])
! strlist SnipList (strlist str, char* elem, [char inseparator])
! SortArray (char* inStrArray(:), int outIntArray(:), &
!   & [char* sortedArray(:)], [char* options])
! SortList (strlist inStrArray, int outIntArray(:), &
!     [char inseparator], [strlist inStrArray],  [char* options])
! char* StringElement (strlist inList, &
!   nElement, log countEmpty, [char inseparator])
! int StringElementNum(strlist inList, char* test_string, log countEmpty, &
!   & [char inseparator], [log part_match])
! int SwitchDetail(strlist inList, char* test_switch, [char* options])
!      by default, options is "-f" to ignore leading spaces
! char* unquote (char* str, [char* quotes], [char* cquotes], [char* options])
! char* unwrap ( char* str )
! wrap ( char* str, char* outstr, int width, [char inseparator], &
!   & [char break], [char mode], [char* quotes], [int addedLines], &
!   & [log dontSqueeze] )
! WriteIntsToList( int ints(:), strlist List )

! in the above, a string list is a string of elements (usu. comma-separated)
! e.g., units='cm,m,in,ft'
! an array is a Fortran array of strings or integers
! a hash is a list of key strings and their associated values
! (a string list, or array of ints or logicals)
! Many of these routines take optional arguments that greatly modify
! their default operation

! One area of possible improvement, or change, anyway, is the choice of
! commas for separators between elements of a string. This is in accord
! with hdfeos dimension fields, etc. It is not ideal for the most general
! case where, for example, a string element might itself contain a comma.
! In the most general case we ought to allow for, and consider moving
! the default to, a non-ascii character to use for separator, e.g., achar(0)
! or NULL.

! One standard is the character flag "options" which affects how loosely
! string matches may be interpreted, quotes treated, and how string elements are
! counted in lists
! it may include any of the following (poss. in combination, e.g. "-wc")
! w    Wildcard * which allows 'a*' to equal 'abcd'
! b    backward search when that makes sense
! c    case insensitive which allows 'ABCD' to equal 'abcd'
! f    flush left which allows 'abcd' to equal '  abcd'
! e    count consecutive separators as enclosing an empty element
! n    reverse sense of match (where appropriate)
! s{.} use character between braces (here a ".") instead of "," as separator
! k    strict; i.e. remove quotes only if they match
! p    stripany; remove any quotes
! r    remove any quoted sub-strings
! x    extract any quoted substrings
! S    match strings as if Switches; e.g. 'pro' matches 'pro1'
! L    keep Last match in GetUnique instead of first match

! We hope eventually that options will replace the countEmpty, caseSensitive, 
! etc. separate optional args to many of the current module procedures

! An argument can be made that countEmpty should be TRUE by default 
! rather than FALSE
! One example is which FALSE seems best is the slash in file paths
! where we want /data/a.dat and /data//a.dat to be synonyms

! The two procedures EvaluateFormula and LoopOverFormula deserve some
! careful explanation
! We intend them to help pry mlsl2's l2cf away from its chemical dependence
! on m4. Two hurdles to the intervention are m4's statement functions
! and the idea of a loop. Our replacements: EvaluateFormula and LoopOverFormula.
! A typical formula in m4 might look something like
!     T h e   m 4   w a y
!   !define(writeStandardProductWithColumn,{
!   Label, quantity=state.$1, label='$1'
!   Label, quantity=state.column_$1, label='$1 column'
!   DirectWrite, type=l2gp, hdfVersion=!hdfVersion, $
!     file='!l2gpFilename($1)', $
!     source=state.$1, precision=outputPrecision.$1, $
!     status=otherDiagnostics.status$1, quality=otherDiagnostics.quality$1, $
!     source=state.column_$1, precision=outputPrecision.column_$1!nl})
! The equivalent using MLSStringLists would be
!     T h e   M L S S t r i n g L i s t s   w a y
!   character(len=80), dimension(:), parameter :: (/                              &
! "Label, quantity=state.${1}, label='${1}'                                    ", &
! "source=state.${1}, precision=outputPrecision.${1}, $                        ", &
! "status=otherDiagnostics.status${1}, quality=otherDiagnostics.quality${1}, $ ", &
! "source=state.column_${1}, precision=outputPrecision.column_${1}!nl})        "  &
! /)
! You will note that instead of "$1" the argument to be substituted must be
! represented using the "${1}" idiom. In case we were preparing to loop over
! the formula with multiple qtys of the state vector, we would use
! the "${qty}" idiom instead of "${1}".

! Warnings: 
! (1) In the routines Array2List, and SortArray
!     the input arguments include an array of strings;
!     This array is of assumed-size
!     I.e., all elements from array(1:size(array)) are relevant
!     Therefore in calling one of these you probably need to call it as
!       call SortArray(myArray(1:mySize), ..
!     to avoid operating on undefined array elements
! (2) In operating on string lists it is sometimes assumed that no
!     element is longer than a limit: MAXSTRELEMENTLENGTH
! (3) Integer hashes should not be used if some negative
!     values are expected. The value KEYNOTFOUND=-1 is used to indicate
!     "no such key."
! (4) "No such key" is indicated by FALSE for logical values and "," strings
! (5) If the optional extra array or list is supplied to the GetUnique...
!     function, repeated elements purely in the first arg are left undeleted;
!     if you want uniqueness among them, too, you must invoke it twice:
!     first w/o the extra arg, and the second time with the extra arg
! === (end of api) ===

  public :: Array2List, BooleanValue, BuildHash, &
    & CapitalizeArray, CapitalizeList, CatLists, &
    & EvaluateFormula, ExpandStringRange, ExtractSubstring, &
    & GetHashElement, GetMatchedParens, GetStringElement, &
    & GetUniqueInts, GetUniqueStrings, GetUniqueList, &
    & InsertHashElement, Intersection, IsInList, &
    & List2Array, LoopOverFormula, ListMatches, &
    & NCharsInFormat, NumStringElements, &
    & OptionDetail, ParseOptions, PutHashElement, &
    & ReadIntsFromList, ReadNumsFromList, &
    & RemoveElemFromList, RemoveListFromList, RemoveNumFromList, &
    & RemoveHashArray, RemoveHashElement, RemoveOption, RemoveSwitchFromList, &
    & ReplaceSubstring, ReverseList, ReverseStrings, &
    & SnipList, SortArray, SortList, StringElement, StringElementNum, &
    & SwitchDetail, &
    & Unquote, Unwrap, Wrap, WriteIntsToList

! A private type
  type :: Index_Stack_t
    integer :: Index = -1              ! into the expresion
    double precision :: Memory = 0.0d0 ! As accounted in Allocate_Deallocate
    integer :: Sys_Memory = 0          ! In use, in kB (1024), as accounted by
                                       ! the system and accessed by Memory_Used
    integer :: String = 0              ! Index in string table
    integer :: Text = 0                ! Index in string table
    integer :: Tree = 0                ! Where in l2cf, -1 if stack not allocated,
                                       ! -2 if stack index < 1, -3 if stack index
                                       ! > stack_ptr.
  end type
  type(Index_Stack_t), allocatable, save :: Stack(:)
  type(Index_Stack_t)                    :: frame
  integer, save                    :: stack_ptr

  interface BooleanValue
    module procedure BooleanValue_log, BooleanValue_str
  end interface

  interface CatLists
    module procedure CatLists_str, CatLists_int, CatLists_intarray
  end interface

  interface EvaluateFormula
    module procedure EvaluateFormula_string, EvaluateFormula_array
  end interface

  interface GetHashElement
    module procedure GetHashElement_str
    module procedure GetHashElement_strarray
    module procedure GetHashElement_int
    module procedure GetHashElement_log
  end interface

  interface GetStringHashElement
    module procedure GetHashElement_str
    module procedure GetHashElement_strarray
  end interface

  interface ExpandStringRange
    module procedure ExpandStringRange_str, ExpandStringRange_ints, &
      & ExpandStringRange_log, ExpandStringRange_real
  end interface

  interface PutHashElement
    module procedure PutHashElement_str
    module procedure PutHashElement_int
    module procedure PutHashElement_log
    module procedure PutHashElement_strarray
  end interface

  interface MakeStringHashElement
    module procedure PutHashElement_str
    module procedure PutHashElement_strarray
  end interface

  interface ReadNumsFromList
    module procedure ReadRealArrayFromString
    module procedure ReadDoubleArrayFromString
  end interface

  interface RemoveHashElement
    module procedure RemoveHashElement_str
    ! module procedure RemoveHashElement_int
    ! module procedure RemoveHashElement_log
  end interface

  interface Unwrap
    module procedure Unwrap_array, Unwrap_list
  end interface

  interface Wrap
    module procedure Wrap_array, Wrap_sca
  end interface

  ! Public data
  character(len=16), public, save :: STRINGLISTOPTIONS = ' '

  ! Error return values from:
  ! GetHashElement (int args)
  integer, public, parameter      :: KEYNOTFOUND = -1
  integer, public, parameter      :: KEYBEYONDHASHSIZE = KEYNOTFOUND-1
  ! strings2Ints
  integer, public, parameter      :: lenORSIZETOOSMALL = -999
  
  ! A limitation among string list operations
  integer , parameter             :: MAXELEMENTLENGTH    = 80
  integer, private, parameter     :: MaxNumSwitches      = 256
  integer, private, parameter     :: MAXSTRLISTLENGTH    = 4*4096
  integer, private, parameter     :: MAXSTRELEMENTLENGTH = BareFNlen

  character (len=1), parameter    :: COMMA = ','
  character (len=1), parameter    :: BLANK = ' '   ! Returned for any element empty

  logical, private, save          :: countEmpty          
  logical, private, save          :: caseSensitive       
  logical, private, save          :: ignoreLeadingSpaces 
  character(len=1), private, save :: separator           
  logical, parameter              :: deeBug = .false.
  character (len=*), public, parameter :: MLSMSG_Allocate = &
     & "Allocation failed: "
  character (len=*), public, parameter :: MLSMSG_DeAllocate = &
     & "Deallocation failed: "
contains

  ! ---------------------------------------------  Array2List  -----

  ! This subroutine returns a (usually) comma-separated string list, interpreted it
  ! as a list of individual elements, given an equivalent array of
  ! sub-strings in which the n'th element becomes the n'th element

  ! As an optional arg the separator may supplied, in case it isn't a comma
  ! As an optional arg the ordering in which the array elements are to be
  ! taken may be supplied; e.g. (/4, 1, 3, 2/) means 1st take 4th element,
  ! then 1st, then 3rd, and finally 2nd: list[k] = array[ordering[k]]
  ! (unless the further optional arg leftRight is also supplied and equals
  ! one of {"l", "L"} in which case list[ordering[k]] = array[k])

  subroutine Array2List ( inArray, outList, inseparator, ordering, leftRight )
    ! Dummy arguments
    character (len=*), intent(out)                :: outList
    character (len=*), dimension(:), intent(in)   :: inArray
    character (len=*), optional, intent(in)       :: inseparator
    integer, dimension(:), optional, intent(in)   :: ordering
    character (len=1), optional, intent(in)       :: leftRight

    ! Local variables
    integer :: listElem, arrayElem, nElems

    character (len=1)               :: separator
    character (len=1)               :: myLeftRight
    ! Executable code

    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif

    if(present(leftRight)) then
      myleftRight = Capitalize(leftRight)
    else
      myleftRight = "R"
    endif

    if ( len(outList) <= 0 ) return
    outList = BLANK
    nElems = size(inArray)
    if ( nElems <= 0 ) return
      listElem = 1
    do
      if (.not. present(ordering) ) then
        arrayElem = ListElem
      elseif (myLeftRight == "R") then
        arrayElem = ordering(ListElem)
      else
        ! Try to invert ordering function
        do arrayElem=1, nElems
          if ( ordering(arrayElem) == listElem ) exit
        enddo
        arrayElem = min(arrayElem, nElems)
      endif
      if ( listElem == 1 ) then
        outList = trim(inArray(arrayElem))
      else
        outList = trim(outList) // separator // trim(inArray(arrayElem))
      endif
      listElem = listElem + 1
      if ( listElem > min(nElems, len(outList)) ) return
    enddo

  end subroutine Array2List

  ! ----------------------------------------  BooleanValue  -----
  ! Takes a well-formed formula and returns its value
  ! given a hash of variables and their values
  ! E.g., given 'p and not (q or r)' 
  ! and p=q=TRUE, r=FALSE, returns FALSE
  ! The str and lkeys are all of type character
  ! lvalues may be either an array of logicals or else
  ! a stringlist like lkeys
  ! if a stringlist, it will be converted into an array of logicals
  ! in a natural way
  ! '[tT]*'       -> .true.
  ! anything else -> .false.
  function BooleanValue_log ( str, lkeys, lvalues, separator ) result(BooleanValue)

    ! Method:
    ! Progressively collapse all the '(..)' pairs into their values
    ! until only primitives remain
    ! then evaluate the primitives
    !
    ! Limitations:
    ! does not check for unmatched parens or other illegal syntax
    !
    ! What about precedence? Does it assign higher precedence
    ! to "not" than to "and"? Higher precedence to "and" than to "or"?

    ! Originally it did not. Now it does.

    ! To see what we're talking about
    ! consider the following logical expression
    !    not a and b or c
    ! It should be evaluated the same as
    !    ((not a) and b) or c   <-- right
    ! instead of, e.g.
    !    not (a and (b or c))   <-- wrong
    
    !--------Argument--------!
    character (len=*), intent(in)           :: str
    character (len=*), intent(in)           :: lkeys
    logical, dimension(:), intent(in)       :: lvalues
    logical                                 :: BooleanValue
    character (len=1), optional, intent(in) :: separator
    ! Internal variables
    logical, parameter              :: deeBug = .false.
    integer                         :: level
    integer                         :: level2
    integer, parameter :: MAXNESTINGS=64 ! Max number of '(..)' pairs
    character(len=MAXSTRLISTLENGTH) :: collapsedstr
    integer, dimension(2,1)         :: pairs
    character(len=MAXSTRLISTLENGTH) :: part1
    character(len=MAXSTRLISTLENGTH) :: part2
    character(len=MAXSTRLISTLENGTH) :: part3
    character(len=MAXSTRLISTLENGTH) :: part21
    character(len=MAXSTRLISTLENGTH) :: part22
    character(len=MAXSTRLISTLENGTH) :: part23
    character(len=MAXSTRLISTLENGTH) :: mstr
    logical :: pvalue
    character(len=16) :: vChar

    ! Executable
    BooleanValue = .FALSE.
    if ( str == ' ' ) return
    if ( min(len_trim(lkeys), size(lvalues)) < 1 ) return

    mstr = lowerCase(str)
    ! We're unable to ensure operator precedence
    ! so we'll attempt to identify "and"s and "not"s
    ! and surround such subexpressions with extra parentheses
    
    ! This wasn't sufficient alone,
    ! so we duplicated it inside the endless loop
    ! over nested matched pairs of parentheses.

    call ReorderPrecedence( mstr, collapsedstr )
    if ( DeeBUG ) then
      print *, 'incoming ', trim(mstr)
      print *, 'after reordering precedence ', trim(collapsedstr)
    endif

    ! Collapse every sub-formula nested within parentheses
    do level =1, MAXNESTINGS ! To prevent endlessly looping if ill-formed
      if ( DEEBug ) print *, 'collapsedstr: ', trim(collapsedstr)
      if ( index( collapsedstr, '(' ) < 1 ) exit
      ! call SplitNest ( collapsedstr, part1, part2, part3 )
      call GetMatchedParens( collapsedstr, pairs )
      part1 = ' '
      part2 = ' '
      part3 = ' '
      if ( pairs(1, 1) < 1 ) then
        part2 = collapsedstr
      elseif ( pairs(1, 1) == 1 ) then
        part2 = collapsedstr(2:pairs(2,1)-1)
        if ( pairs(2, 1) < len_trim(collapsedstr) ) &
          & part3 = collapsedstr(pairs(2,1)+1:)
      elseif ( pairs(2, 1) == len_trim(collapsedstr) ) then
        part1 = collapsedstr(1:pairs(1,1)-1)
        part2 = collapsedstr(pairs(1,1)+1:pairs(2,1)-1)
      else
        part1 = collapsedstr(1:pairs(1,1)-1)
        part2 = collapsedstr(pairs(1,1)+1:pairs(2,1)-1)
        part3 = collapsedstr(pairs(2,1)+1:)
      endif
      ! Now evaluate the part2
      if ( DeeBUG ) then
        print *, 'part1 ', trim(part1)
        print *, 'part2 ', trim(part2)
        print *, 'part3 ', trim(part3)
      endif
      ! Hackery-quackery alert:

      ! We're unable to ensure operator precedence
      ! (being too inept or lacking in ideas)
      ! so we'll attempt to identify "and"s and "not"s
      ! and surround such subexpressions with extra parentheses

      call ReorderPrecedence( part2, mstr )
      if ( DEEBug ) then
        print *, 'incoming ', trim(part2)
        print *, 'after reordering precedence ', trim(mstr)
      endif
      
      ! The next block of code is in an endless loop
      ! of its own until there are no more parens in mstr
      ! (which were created in ReorderPrecedence as explained above)
      precedence: do level2 =1, MAXNESTINGS ! To prevent endlessly looping
        if ( DEEBug ) print *, 'mstr: ', trim(mstr)
        if ( index( mstr, '(' ) < 1 ) exit precedence
        ! if ( mstr /= part2 ) then
        call GetMatchedParens( mstr, pairs )
        part21 = ' '
        part22 = ' '
        part23 = ' '
        if ( pairs(1, 1) < 1 ) then
          part22 = mstr
        elseif ( pairs(1, 1) == 1 ) then
          part22 = mstr(2:pairs(2,1)-1)
          if ( pairs(2, 1) < len_trim(mstr) ) &
            & part23 = mstr(pairs(2,1)+1:)
        elseif ( pairs(2, 1) == len_trim(mstr) ) then
          part21 = mstr(1:pairs(1,1)-1)
          part22 = mstr(pairs(1,1)+1:pairs(2,1)-1)
        else
          part21 = mstr(1:pairs(1,1)-1)
          part22 = mstr(pairs(1,1)+1:pairs(2,1)-1)
          part23 = mstr(pairs(2,1)+1:)
        endif
        if ( deeBug ) print *, 'Evaluate part22 primitive ', trim(part22)
        pvalue = evaluatePrimitive( trim(part22) )
        vChar = 'true'
        if ( .not. pvalue ) vChar = 'false'
        if ( DEEBug ) then
          print *, 'part21 ', trim(part21)
          print *, 'part22 ', trim(part22)
          print *, 'part23 ', trim(part23)
          print *, '1st vchar ', trim(vchar)
        endif
        ! And substitute its value for the spaces it occupied
        if (  part21 // part23 == ' ' ) then
          mstr = vChar
        elseif (  part21 == ' ' ) then
          mstr = trim(vChar) // ' ' // part3
        elseif ( part23 == ' ' ) then
          mstr = trim(part21) // ' ' //  vChar
        else
          mstr = trim(part21) // ' ' //  vChar // ' ' // part23
          if ( DEEBug ) then
            print *, 'part21 ', trim(part21)
            print *, '2nd vchar ', trim(vchar)
            print *, 'part23 ', trim(part23)
          endif
        endif
        if ( DEEBug ) then
          print *, 'mstr ', trim(mstr)
        endif
      enddo precedence ! precedence loop
      if ( DEEBug ) then
        print *, 'mstr (after precedence loop)', trim(mstr)
      endif
      part2 = mstr
      if ( part2 == ' ' ) then
        ! This should never happen with well-formed formulas
        collapsedstr = part1
        cycle
      else
        pvalue = evaluatePrimitive( trim(part2) )
        vChar = 'true'
        if ( .not. pvalue ) vChar = 'false'
      endif
      ! And substitute its value for the spaces it occupied
      if (  part1 == ' ' ) then
        collapsedstr = trim(vChar) // ' ' // part3
      elseif ( part3 == ' ' ) then
        collapsedstr = trim(part1) // ' ' // vChar
      else
        collapsedstr = trim(part1) // ' ' // trim(vChar) // &
          & ' ' // part3
      endif
      if ( DeeBUG ) then
        print *, 'collapsedstr ', trim(collapsedstr)
      endif
    enddo
    ! Presumably we have collapsed all the nested '(..)' pairs by now
    BooleanValue = evaluatePrimitive( trim(collapsedstr) )
  contains
  function isBalanced ( str ) result ( itIs )
    ! Are numbers of '(' and ')' in str equal?
    ! See also Enclosure subroutine in MLSStrings
    character(len=*), intent(in) :: str
    logical                      :: itIs
    ! Internal variables
    integer :: i
    integer :: balance
    ! Executable
    ! 1st--Just count
    ! Not as strict as "do they balance", but easier to check
    itIs = ncopies( trim(str), '('           ) ==  &
      &    ncopies( trim(str), ')'           ) 
    if ( .not. itIs ) return
    ! Now look more closely
    ! Each '(' adds 1, each ')' subtracts 1, though never going negative
    ! If 0 when done, we're balanced, != 0 if not
    balance = 0
    do i=1, len_trim(str)
      select case(str(i:i))
      case ('(')
        balance = balance + 1
      case (')')
        balance = max( 0, balance - 1 )
      ! case default (leaves balance unchanged)
      end select
    enddo
    itIs = ( balance == 0 )
  end function isBalanced

  function isParenthetical ( str ) result ( itIs )
    ! TRUE if 1st non-blank is '(' and last non-blank is ')'
    ! Do we really need to make this a recursive function?
    character(len=*), intent(in) :: str
    logical                      :: itIs
    itIs = index( adjustl(str), '('           ) == 1 .and. &
      &    index( trim(str), ')', back=.true. ) == len_trim(str)
  end function isParenthetical

    subroutine ReorderPrecedence ( arg, sult )
      character(len=*), intent(in)                  :: arg
      character(len=*), intent(out)                 :: sult
      !
      integer                                       :: i
      integer                                       :: n
      character                                     :: separator
      character(len=MAXSTRLISTLENGTH)               :: element
      character(len=MAXSTRLISTLENGTH)               :: rev
      character(len=MAXSTRLISTLENGTH)               :: tmp
      !
      sult = ' '
      if ( len_trim(arg) < 1 ) then
        return
      endif
      separator = '+'
      ! 1st, replace each instance of ' or ' with '+'
      !      replace each instance of ' and ' with '*'
      call ReplaceSubString( arg, rev, ' or ', ' + ', &
        & which='all', no_trim=.true. )
      call ReplaceSubString( rev, tmp, ' and ', ' * ', &
        & which='all', no_trim=.true. )
      if ( DeeBUG ) print *, 'arg in ReorderPrecedence: ', trim(arg)
      n = NumStringElements( tmp, COUNTEMPTY, inseparator='+' )
      do i=1, n
        call GetStringElement ( tmp, element, i, countEmpty, inseparator='+' )
        ! Be careful not to surround a string that ends with an op
        ! (Why does this keep happening?)
        rev = Reverse_trim(element)
        ! Is it an op?
        if ( index( '+-*/', rev(1:1) ) > 0 ) then
          sult = catLists( sult, element, inseparator='+' )
          cycle
        endif
        ! Surround term with parentheses if it's a product or quotient or '^'
        ! but not if it's (already) parenthetical or parentheses are not balanced
        if ( ( index(element, '*') > 0  ) .and. &
          & ( &
          &   .not. isParenthetical(element) .and. isBalanced(element) &
          & ) &
          & ) then
          if ( DEEBug ) then
          print *, 'element to be parenthesized: ', trim(element)
          print *, 'isParenthetical(element): ', isParenthetical(element)
          print *, 'isBalanced(element): ', isBalanced(element)
          print *, 'ncopies( trim(element), "("): ', ncopies( trim(element), '(')
          print *, 'ncopies( trim(element), ")"): ', ncopies( trim(element), ')')
          endif
          element = '(' // trim(element) // ')'
        endif
        ! Avoid producing two consecutive ops, like '+ +' or '* +'
        ! which would happen if collapsedstr ends with an op
        ! Begin by finding its last non-blank char
        !
        rev = Reverse_trim(element)
        ! Is it an op?
        if ( index( '+-*/', rev(1:1) ) > 0 ) then
          sult = trim(sult) // element
        else
          sult = catLists( sult, element, inseparator='+' )
        endif
      enddo
      ! Now replace each '+' with ' or '
      ! and each '*' with ' and '
      call ReplaceSubString( sult, rev, '+', ' or ', &
        & which='all', no_trim=.true. )
      call ReplaceSubString( rev, sult, '*', ' and ', &
        & which='all', no_trim=.true. )
    end subroutine ReorderPrecedence

    function evaluatePrimitive(primitive) result(value)
      ! Evaluate an expression composed entirely of
      ! (0) constants (e.g., 'true')
      ! (1) primitives (e.g., 'p')
      ! (2) unary operators ('not')
      ! (3) binary operators ('or', 'and', 'xor')
      ! Dummy args
      character(len=*) :: primitive
      logical          :: value
      ! Internal variables
      logical          :: done
      integer          :: elem
      logical          :: hit
      character(len=3) :: lastOp ! "or", "and", "xor"
      integer          :: n
      logical          :: negating
      logical          :: part
      character(len=32) :: variable
      ! Executable
      value = .true.
      done = .false.
      negating = .false.
      elem = 0
      lastOp = 'nul' ! 'or'
      n = NumStringElements( trim(primitive), countEmpty=.false., inseparator=' ' )
      do
        ! go through the elements, re-evaluating every time we "hit" a primitive
        ! Otherwise revising our lastOp or negating status
        elem = elem + 1
        call GetStringElement ( trim(primitive), variable, elem, &
          & countEmpty=.false., inseparator=' ' )
        select case(trim(variable))
        case ('t', 'true')
          part = .true.
          hit = .true.
        case ('f', 'false')
          part = .false.
          hit = .true.
        case ('or')
          lastOp = 'or'
          hit = .false.
        case ('xor')
          lastOp = 'xor'
          hit = .false.
        case ('and')
          lastOp = 'and'
          hit = .false.
        case ('not', '~')
          negating = .true.
          hit = .false.
        case default
          call GetHashElement( lkeys, lvalues, trim(variable), part, &
            & countEmpty=.true., inseparator=separator )
          hit = .true.
          if ( DeeBug ) then
            print *, trim(variable), ' is ', part
            if ( present(separator) ) print *, 'iachar(separator)', ' is ', iachar(separator)
            ! print *, 'keys', ' is ', trim(lkeys)
            ! print *, 'values', ' is ', lvalues
          endif
        end select
        if ( hit ) then
          if ( negating ) part = .not. part
          select case(lastOp)
          case ('nul')
              value = part
          case ('or')
              value = value .or. part
          case ('and')
              value = value .and. part
          case ('xor')
              value = ( value .or. part ) .and. &
                & .not. ( value .and. part )
          case default
            ! How could this happen?
              call PrintMessage( MLSMSG_Error, ModuleName, &
                & lastOp // ' not a legal binary op in evaluatePrimitive' )
          end select
          negating = .false.
        endif
        if ( DeeBUG ) then
          print *, 'variable ', variable
          print *, 'part ', part
          if ( hit ) print *, 'hit ', hit
          if ( negating ) print *, 'negating ', negating
          print *, 'value ', value
        endif
        done = ( elem >= n )
        if ( done ) exit
      enddo
    end function evaluatePrimitive
  end function BooleanValue_log

  function BooleanValue_str ( str, lkeys, strvalues, separator ) result(BooleanValue)
    !--------Argument--------!
    character (len=*), intent(in)           :: str
    character (len=*), intent(in)           :: lkeys
    character (len=*), intent(in)           :: strvalues
    logical                                 :: BooleanValue
    character (len=1), optional, intent(in) :: separator
    ! Internal variables
    logical, parameter                :: countEmpty = .true.
    logical, dimension(:), pointer    :: lvalues
    integer :: key
    integer :: nkeys
    integer :: status
    ! Executable
    BooleanValue = .false.
    if ( len_trim(str) < 1 ) return
    nkeys = NumStringElements( lkeys, countEmpty, inseparator=separator )
    if ( nkeys < 1 ) return
    nullify( lvalues )
    allocate( lvalues(nkeys), stat=status )
    if ( status /= 0 ) call PrintMessage( MLSMSG_Error, ModuleName, &
      & 'Unable to allocate lvalues in BooleanValue_str' )
    do key = 1, nkeys
      ! print *, 'value(key) ', &
      !   & adjustl(lowercase(StringElement ( strvalues, key, countEmpty, inseparator=separator )))
      lvalues(key) = index( &
        & adjustl(lowercase(&
        & StringElement ( strvalues, key, countEmpty, inseparator=separator )&
        & )) &
        & , 't') == 1
    enddo
    BooleanValue = BooleanValue_log ( str, lkeys, lvalues, separator )
    deallocate ( lvalues, stat=status )
    if ( status /= 0 ) call PrintMessage( MLSMSG_Error, ModuleName, &
      & 'Unable to deallocate lvalues in BooleanValue_str' )
  end function BooleanValue_str

  ! -------------------------------------------------  BuildHash  -----
  ! Build a hash from a constructor
  ! E.g., given '[ 100mb : 0.5ppmv, 50mb : 0.1ppmv, 31mb : 0.12ppmv ]'
  ! Returns 
  ! keys = '100mb, 50mb, 31mb'  
  ! hash = '0.5ppmv, 0.1ppmv, 0.12ppmv'
  ! operator   optionally use something other than ':'
  ! separator  optionally use something other than ','
  ! options    'a' append to existing keys, values
  ! Use:
  ! The constructor example shown above is used in level 2 profile Fills
  subroutine BuildHash( Constructor, Keys, values, operator, separator, options )
    ! Dummy arguments
    character (len=*), intent(in)             :: Constructor
    character (len=*), intent(inout)          :: Keys
    character (len=*), intent(inout)          :: values
    character (len=*), optional, intent(in)   :: operator ! defaults to ':'
    character (len=*), optional, intent(in)   :: separator ! defaults to ','
    character (len=*), optional, intent(in)   :: options
    ! Internal variables
    logical :: append
    logical, parameter :: countEmpty = .false.
    integer :: i
    character(len=128) :: istr
    character(len=3) :: op
    character(len=1) :: sep
    character(len=MAXSTRLISTLENGTH) :: str
    ! Executable
    op = ':'
    if ( present(operator) ) op = operator
    sep = ','
    if ( present(separator) ) sep = separator
    append = .false.
    if ( present(options) ) append = ( index(options, 'a') > 0 )
    if ( .not. append ) then
      keys = ' '
      values = ' '
    endif
    str = unquote( Constructor, quotes='[]$', options='-p' )
    do i=1, NumStringElements( str, countEmpty, inseparator=trim(sep) )
      call GetStringElement( str, istr, i, countEmpty, inseparator=trim(sep) )
      if ( len_trim(istr) < 1 ) cycle
      keys = CatLists( keys, stringElement( istr, 1, countEmpty, inseparator=trim(op) ) )
      values = CatLists( values, stringElement( istr, 2, countEmpty, inseparator=trim(op) ) )
    enddo
  end subroutine BuildHash

  ! -------------------------------------------------  CapitalizeArray  -----
  subroutine CapitalizeArray ( inArray, outArray, inseparator, ignore )
    ! Capitalize the 1st char of line of an array
    ! If size(inseparator) > 1, do the same for each of its elements
    !--------Argument--------!
    character (len=*), dimension(:), intent(in)            :: inArray
    character (len=*), dimension(:), intent(out)           :: outArray
    character (len=*), optional, intent(in)                :: ignore ! Don't change any of these
    character (len=1), dimension(:), optional, intent(in)  :: inseparator
    ! Local variables
    integer                                                :: i
    integer                                                :: j
    ! Executable
    if ( .not. present(inseparator) ) then
      do i=1, size(inArray)
        outArray(i) = CapitalizeList( inArray(i), ignore=ignore )
      enddo
      return
    endif
    do i=1, size(inArray)
      outArray(i) = CapitalizeList( inArray(i), inseparator(1), ignore )
    enddo
    if ( size(inseparator) < 2 ) return
    do j=2, size(inseparator)
      do i=1, size(inArray)
        outArray(i) = CapitalizeList( outArray(i), inseparator(j), ignore )
      enddo
    enddo
  end subroutine CapitalizeArray

  ! -------------------------------------------------  CapitalizeList  -----
  function CapitalizeList ( STR, inseparator, ignore ) result ( OUTSTR )
    ! Capitalize the 1st char of each element of a list
    ! E.g., given str = 'hot,dog,2tommy' 
    ! returns 'Hot,Dog,2Tommy'
    !--------Argument--------!
    character (len=*), intent(in)                 :: STR
    character (len=1), optional, intent(in)       :: inseparator
    character (len=*), optional, intent(in)       :: ignore ! Don't change any of these
    character (len=len(str)+9) :: OUTSTR

    !----------Local vars----------!
    integer                             :: i
    integer                             :: j
    integer                             :: m
    integer                             :: n
    character (len=len(str)+9)          :: temp
    character (len=1)                   :: separator
    character, dimension(len(str)+9)    :: temp1d
    !----------executable part----------!
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = comma
    endif
    n = NumStringElements ( str, countEmpty, inseparator )
    outstr = ' '
    if ( n < 1 ) return
    do i=1, n
      call GetStringElement ( str, temp, i, countEmpty, inSeparator )
      m = len_trim(temp)
      temp1d(1:m) = temp(1:m)
      j = FindFirst ( IsAlphabet(temp1d(1:m)) )
      if ( IsInList ( ignore, temp, options='-fc' ) ) then
        ! Nothing to do here
      elseif ( j > 0 ) then
        temp(j:j) = Capitalize(temp(j:j))
      endif
      outstr = CatLists( outstr, trim_safe(temp), inseparator=inseparator )
    enddo
  end function CapitalizeList

  ! -------------------------------------------------  CatLists  -----
  ! This family lets you Build up a String List from scratch
  ! Typical usage
  ! List = ' ' ! Intialize String List
  ! do i = 1, n
  !   List = CatLists ( List, str(i) ) ! Cat str(i) ono List end
  ! enddo
  !
  ! -------------------------------------------------  CatLists_int  -----
  function CatLists_int (STR1, INT, inseparator) result (OUTSTR)
    ! appends an int onto end of a string list, taking care if it is blank
    ! E.g., given str1 = 'a,b,c' and int = 4
    ! returns 'a,b,c,4'
    ! if str1 is blank, returns just '4'
    !--------Argument--------!
    character (len=*), intent(in) :: STR1
    integer, intent(in)           :: INT
    character (len=*), optional, intent(in)       :: inseparator
    character (len=len(str1)+9) :: OUTSTR

    !----------Local vars----------!
    character (len=1)                :: separator
    character (len=32), dimension(1) :: str2
    !----------executable part----------!
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = comma
    endif
    call writeIntsToChars( (/int/), str2 )
    str2(1) = adjustl(str2(1))
    if ( len_trim(str2(1)) < 1 ) then
      outstr=str1
    elseif ( len_trim(str1) < 1 ) then
      outstr=str2(1)
    else
      outstr = trim(str1) // separator // trim(str2(1))
    endif
  end function CatLists_int

  ! ---------------------------------------------  CatLists_intarray  -----
  function CatLists_intarray (STR1, INTS, inseparator) result (OUTSTR)
    ! appends array of ints onto end of a string list, 
    ! taking care if it is blank
    ! E.g., given str1 = 'a,b,c' and ints = (/4,5,5,0/)
    ! returns 'a,b,c,4,5,5,0'
    ! if str1 is blank, returns just '4,5,5,0'
    !--------Argument--------!
    character (len=*), intent(in)                 :: STR1
    integer, dimension(:), intent(in)             :: INTS
    character (len=*), optional, intent(in)       :: inseparator
    character (len=len(str1)+8*size(ints))        :: OUTSTR, TMPSTR

    !----------Local vars----------!
    integer :: i
    !----------executable part----------!
    outstr = str1
    if ( size(ints) < 1 ) then
      return
    endif
    do i = 1, size(ints)
      tmpstr = outstr
      outstr = CatLists_int(tmpstr, ints(i))
    enddo
  end function CatLists_intarray

  ! -------------------------------------------------  CatLists_str  -----
  function CatLists_str (STR1, STR2, inseparator) result (OUTSTR)
    ! cats 2 string lists, taking care if either is blank
    ! E.g., given str1 = 'a,b,c' and str2 = 'd,e,f'
    ! returns 'a,b,c,d,e,f'
    ! if either is blank, returns the other
    ! if both blank, returns a blank
    !
    !--------Argument--------!
    character (len=*), intent(in) :: STR1
    character (len=*), intent(in) :: STR2
    character (len=*), optional, intent(in)       :: inseparator
    character (len=len(str1)+len(str2)+1) :: OUTSTR

    !----------Local vars----------!
    character (len=1)               :: separator
    !----------executable part----------!
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = comma
    endif
    if ( len_trim(str2) < 1 ) then
      outstr=str1
    elseif ( len_trim(str1) < 1 ) then
      outstr=str2
    else
      outstr = trim(str1) // separator // trim(str2)
    endif
  end function CatLists_str

  ! -------------------------------------------------  EvaluateFormula  -----
  ! Evaluates a string formula, plugging in the nth value for
  ! each occurrence of the nth arg appearing as '${n}'
  ! E.g., if strFun is 
  ! "x${1}: vector, template=state"
  ! and the first arg is "InitPtan" then outStr will be
  ! "xInitPtan: vector, template=state"
  ! 
  ! If keys is present, then instead of '${n}' substitute for
  ! each occurrence of the nth arg appearing as '${key(n)}'
  function EvaluateFormula_array ( FORMULA, VALUES, KEYS ) result (OUTSTR)
    !--------Argument--------!
    character (len=*), intent(in)                         :: FORMULA
    character (len=*), dimension(:), intent(in)           :: VALUES
    character (len=*), dimension(:), optional, intent(in) :: KEYS
    character (len=len(formula)+size(values)*len(values)) :: OUTSTR

    !----------Local vars----------!
    integer :: i, n
    character (len=len(formula)+size(values)*len(values)) :: tmpstr
    character (len=len(values))                           :: value       
    character(len=128)                                    :: variable    
    !----------executable part----------!
    n = size(values)
    outstr = formula
    ! Check whether we have any work to do
    if ( n < 1 .or. index( formula, '${' ) < 1 ) return
    do i=1, n
      value = values(i)
      if ( present(keys) ) then
        variable = '${' // trim(keys(i)) // '}'
      else
        call WriteIntsToChars( i, variable )
        variable = '${' // trim(adjustl(variable)) // '}'
      endif
      tmpstr = outstr
      call ReplaceSubString( tmpStr, outstr, trim(variable), trim(value), &
        & which='all', no_trim=.true. )
    enddo
  end function EvaluateFormula_array

  function EvaluateFormula_string ( formula, values, keys, separator ) &
    & result (outstr)
    !--------Argument--------!
    character (len=*), intent(in)                     :: formula
    character (len=*), intent(in)                     :: values
    character (len=*), optional, intent(in)           :: keys
    character (len=1), optional, intent(in)           :: separator
    character (len=len(formula)+len(values))          :: outstr

    !----------Local vars----------!
    integer :: status, n
    character (len(values)), dimension(:), pointer    :: valuesArray              
    character (len(values)), dimension(:), pointer    :: keysArray                
    logical, parameter                                :: countEmpty = .true.
    !----------executable part----------!
    outstr = formula
    ! Check whether we have any work to do
    if ( len_trim(values) < 1 .or. index( formula, '${' ) < 1 ) return
    n = NumStringElements( values, countEmpty, separator )
    allocate ( valuesArray(n), STAT=status )
    call list2Array( values, valuesArray, countEmpty, inseparator=separator )
    if ( present(keys) ) then
      allocate ( keysArray(n), STAT=status )
      call list2Array( keys, keysArray, countEmpty, inseparator=separator )
      outstr = EvaluateFormula_array ( formula, valuesArray, keysArray )
      deallocate( keysArray, stat=status )
    else
      outstr = EvaluateFormula_array ( formula, valuesArray )
    endif
    deallocate( valuesArray, stat=status )
  end function EvaluateFormula_string

  ! ----------------------------------------  ExpandStringRange_ints  -----
  subroutine ExpandStringRange_ints (instr, ints, LENGTH)
    ! Takes a range and returns an array of integers
    ! E.g., given '1,2-5,7' returns (/1,2,3,4,5,7/)
    !--------Argument--------!
    character (len=*), intent(in) :: instr
    integer, dimension(:), intent(out) :: ints
    integer, optional, intent(out) :: LENGTH  ! number of ints returned
    ! Internal variables
    integer :: elem
    integer :: ErrTyp
    integer :: nelem
    character(len=MAXSTRLISTLENGTH) :: expandedstr
    character(len=16) :: iChar
    logical, parameter :: countEmpty=.true.
    ! Executable
    ints = 0
    if ( present(LENGTH) ) LENGTH = 0
    if ( min(len_trim(instr), size(ints)) < 1 ) return
    call ExpandStringRange_str (instr, expandedstr)
    nelem = NumStringElements(trim(expandedstr), countEmpty)
    if ( nelem < 1 ) return
    do elem = 1, min(nelem, size(ints))
      call GetStringElement (trim(expandedstr), iChar, elem, countEmpty)
      read(iChar, *, iostat=ErrTyp) ints(elem)
    enddo
    if ( present(LENGTH) ) LENGTH = min(nelem, size(ints))
  end subroutine ExpandStringRange_ints

  ! ----------------------------------------  ExpandStringRange_log  -----
  subroutine ExpandStringRange_log (instr, logs, fits, highfit, sense)
    ! Takes a range and returns an array of logicals true for indices
    ! fitting the range (unless sense is false)
    ! E.g., given '1,2-5,7' returns (/T,T,T,T,T,F,T/) (because '6' is outside)
    !--------Argument--------!
    character (len=*), intent(in) :: instr
    logical, dimension(:), intent(out) :: logs
    integer, optional, intent(out) :: fits  ! number of fits in range (trues)
    integer, optional, intent(out) :: highfit  ! index of highest fit
    logical, optional, intent(in) :: sense   ! if false, return F for fits
    ! Internal variables
    integer :: elem
    integer :: ErrTyp
    integer :: indx
    integer :: nelem
    integer :: nfits
    integer :: hfit
    character(len=MAXSTRLISTLENGTH) :: expandedstr
    character(len=16) :: iChar
    logical, parameter :: countEmpty=.true.
    logical :: mySense
    ! Executable
    mySense = .true.
    if ( present(sense) ) mySense = sense
    logs = .not. mySense ! .false.
    if ( present(fits) ) fits = 0
    if ( present(highfit) ) highfit = 0
    if ( min(len_trim(instr), size(logs)) < 1 ) return
    call ExpandStringRange_str (instr, expandedstr)
    nelem = NumStringElements(trim(expandedstr), countEmpty)
    if ( nelem < 1 ) return
    nfits = 0
    hfit = 0
    do elem = 1, min(nelem, size(logs))
      call GetStringElement (trim(expandedstr), iChar, elem, countEmpty)
      read(iChar, *, iostat=ErrTyp) indx
      if ( indx > 0 .and. indx <= size(logs) ) then
        if ( logs(indx) .neqv. mySense ) nfits = nfits + 1
        logs(indx) = mySense ! .true.
        hfit = max(hfit, indx)
      endif
    enddo
    if ( present(fits) ) fits = nfits
    if ( present(highfit) ) highfit = hfit
  end subroutine ExpandStringRange_log

  ! ----------------------------------------  ExpandStringRange_real  -----
  subroutine ExpandStringRange_real (instr, reals, LENGTH)
    ! Takes a range and returns an array of reals
    ! E.g., given '1,2.5-3.5+0.5,7' returns (/1.0,2.5,3.0,3.5,7.0/)
    !--------Argument--------!
    character (len=*), intent(in) :: instr
    real, dimension(:), intent(out) :: reals
    integer, optional, intent(out) :: LENGTH  ! number of reals returned
    ! Internal variables
    integer :: elem
    integer :: ErrTyp
    integer :: nelem
    character(len=MAXSTRLISTLENGTH) :: expandedstr
    character(len=16) :: iChar
    logical, parameter :: countEmpty=.true.
    ! Executable
    reals = -999.99
    if ( present(LENGTH) ) LENGTH = 0
    if ( min(len_trim(instr), size(reals)) < 1 ) return
    call ExpandStringRange_str (instr, expandedstr)
    nelem = NumStringElements(trim(expandedstr), countEmpty)
    if ( nelem < 1 ) return
    do elem = 1, min(nelem, size(reals))
      call GetStringElement (trim(expandedstr), iChar, elem, countEmpty)
      read(iChar, *, iostat=ErrTyp) reals(elem)
    enddo
    if ( present(LENGTH) ) LENGTH = min(nelem, size(reals))
  end subroutine ExpandStringRange_real

  ! --------------------------------------------------  ExpandStringRange_str  -----
  subroutine ExpandStringRange_str (instr, outstr)
    ! Takes a string list and expands any ranges found within:
    ! Ranges are marked by patterns
    ! (1a--simple) 'n-m' integers from n to m inclusive, where m > n
    ! (1b--stride) 'n-m+s' integers from n to m with stride s, where s > 0
    ! (2a--simple) 'n-m' reals from n to m inclusive, where m > n
    ! (2b--stride) 'n-m+s' reals from n to m with stride s, where s > 0
    ! Examples:
    ! '1-10' becomes '1,2,3,4,5,6,7,8,9,10'
    ! '1-5+0.5' becomes '1,1.5,2,2.5,3,3.5,4,4.5,5'
    ! '2-21+2' bcecomes '2,4,6,8,10,12,14,16,18,20' (missing '21')

    ! Errors and limitations:
    ! '5-5' becomes simply '5' (range is inclusive, but not duplicative)
    ! '6-4' becomes '' (we can't go backward)
    ! m, n must be non-negative
    ! The separator between elements must be ','
    ! Although countEmpty set to .true. below, actual behavior
    ! ignores blank elements; e.g. 
    ! '0,1,,2,,4-6,,' becomes '0,1,2,4,5,6'
    ! '1.e-3' type notation confuses the range finder, so we will
    ! go through and replace 
    ! 'e-' -> 'em'
    ! 'e+' -> 'ep'
    ! Args
    character (len=*), intent(in) :: instr
    character (len=*), intent(inout) :: outstr
    ! Internal variables
    character (len=len(outstr)) :: str
    character (len=len(outstr)) :: tempstr
    integer :: dashpos
    integer :: elem
    character(len=*), parameter :: em     = 'em'
    character(len=*), parameter :: eminus = 'e-'
    character(len=*), parameter :: ep     = 'ep'
    character(len=*), parameter :: eplus  = 'e+'
    integer :: ErrTyp
    integer :: m                    ! if substring is of form 'n-m'
    character (len=16) :: mChar
    integer :: n                    ! substring is '..,n[-..],'
    character (len=16) :: nChar
    integer :: nelem
    integer :: pluspos
    integer :: s                    ! if substring is of form 'n-m+s'
    character (len=16) :: sChar
    integer :: t
    character (len=16) :: tChar
    ! These are the real counterparts of n, m s
    real :: rm, rn, rs
    integer :: ns
    logical, parameter :: countEmpty=.true.
    ! Executable
    outstr = instr
    nelem = NumStringElements(instr, countEmpty)
    ! Try to deal with '1.e-(+)..' problem
    str = lowercase(instr)
    call ReplaceSubString( str, tempstr, eminus, em, which='all' )
    call ReplaceSubString( tempstr, str, eminus, em, which='all' )
    dashpos = index(str, '-')
    if ( nelem < 1 .or. dashpos < 1 ) return
    outstr = ' '
    do elem = 1, nelem
      call GetStringElement (str, tempstr, elem, countEmpty)
      dashpos = index(trim(tempstr), '-')
      if ( dashpos < 1 ) then
        ! Must reverse any '1.e-(+)' substitutions we might have made
        call ReplaceSubString( tempstr, nChar, ep, eplus, which='first' )
        call ReplaceSubString( nChar, tempstr, em, eminus, which='first' )
      else
        ! The range operator '-' is invoked
        n = -999
        m = -999
        s = 1
        call GetStringElement (trim(tempstr), nChar, 1, countEmpty, &
          & inseparator='-')
        pluspos = index(trim(tempstr), '+')
        ! print *, 'pluspos: ', pluspos
        if ( pluspos > 0 ) then
          call ExtractSubString (trim(tempstr), mChar, '-', '+')
          ! print *, 'mChar: ', mChar
          call GetStringElement (trim(tempstr), sChar, 2, countEmpty, &
            & inseparator='+')
          ! print *, 'sChar: ', sChar
          ! non-simple pattern is 'n-m+s'
        else
          ! simple pattern is 'n-m'
          call GetStringElement (trim(tempstr), mChar, 2, countEmpty, &
            & inseparator='-')
          sChar = ''
        endif
        ! print *, 'nChar: ', trim(nChar)
        ! print *, 'mChar: ', trim(mChar)
        ! print *, 'sChar: ', trim(sChar)
        if ( index(tempstr, '.') < 1 ) then
          ! print *, 'Case (1a) or (1b)'
          read(nChar, *, iostat=ErrTyp) n
          if ( ErrTyp == 0 ) read(mChar, *, iostat=ErrTyp) m
          if ( ErrTyp == 0 .and. sChar /= '') read(sChar, *, iostat=ErrTyp) s
          ! print *, 'n, m, s: ', n, m, s
          tempstr = ''
          if ( m >= n ) then
            do t=n, m, s
              write(tChar, '(i16)') t
              ! print *, 'tChar: ', trim(tChar)
              tempstr = CatLists(trim(tempstr), adjustl(tChar))
            enddo
          endif
        else
          ! print *, 'Case (2a) or (2b)'
          ! Must reverse any '1.e-(+)' substitutions we might have made
          call ReplaceSubString( nChar, tempstr, em, eminus, which='first' )
          call ReplaceSubString( tempstr, nChar, ep, eplus, which='first' )
          read(nChar, *, iostat=ErrTyp) rn
          call ReplaceSubString( mChar, tempstr, em, eminus, which='first' )
          call ReplaceSubString( tempstr, mChar, ep, eplus, which='first' )
          if ( ErrTyp == 0 ) read(mChar, *, iostat=ErrTyp) rm
          rs = 1.0
          call ReplaceSubString( sChar, tempstr, em, eminus, which='first' )
          call ReplaceSubString( tempstr, sChar, ep, eplus, which='first' )
          if ( ErrTyp == 0 .and. sChar /= '') read(sChar, *, iostat=ErrTyp) rs
          ! print *, 'n, m, s: ', rn, rm, rs
          ns = (rm - rn) / rs + 1.1 ! To deal with roundoff
          tempstr = ''
          do s=1, ns
            write(tChar, '(g10.3)') rn + (s-1)*rs
            ! print *, 'tChar: ', trim(tChar)
            tempstr = CatLists(trim(tempstr), adjustl(tChar))
          enddo
        endif
      endif
      outstr = CatLists(trim(outstr), adjustl(tempstr))
    enddo
  end subroutine ExpandStringRange_str

  ! --------------------------------------------------  ExtractSubString  -----
  subroutine ExtractSubString (instr, outstr, sub1, sub2, how, no_trim)
    ! Takes a string and extracts what is sandwiched between sub1 and sub2
    ! Defaults to choosing only the first occurrence of sub1 and sub2
    ! But if how == 'greedy' chooses last occurrence of sub2
    ! or if how == 'stingy' chooses last occurrence of sub1
    ! Note that, depending on how, we extract:
    !    (let sub1='abc' sub2='def' str='abcabc123defdef')
    ! (a) if how == default => 'abc123'
    ! (b) if how == greedy => 'abc123def'
    ! (c) if how == stingy => '123'
    ! if no_trim is TRUE, sub1 and sub2 may have trailing spaces
    ! that will not be trimmed before attempting to match
    ! Method:
    ! Replace substrings sub1 and sub2 with separator character
    ! and then use GetStringElement to get subelement number 2
    ! We are careful to choose as separator one that is not already present
    ! in the string
    !  
    ! Notes and limitations:
    ! A fundamental issue arises if sub2 occurs before sub1 in the string
    ! do we want to interpret the request such that we
    ! (1) return a blank
    ! (2) look for occurrences of sub2 in the string after sub1
    ! I think we should aim for 2, as it produces a generalization
    ! of picking elements out of a comma-separated list
    !
    ! Misc questions
    ! (1) Will this still work if sub1 has leading or trailing blanks? 
    ! (2) How about sub2?
    ! (3) do we need an optional arg, no_trim, say, that will leave them?
    !     Tried coding it, but can't say for sure it works
    ! (4) What if sub1 is a substring of sub2, or vice versa?
    ! (5) Should we switch to non-ascii characters for use as separator?
    !--------Argument--------!
    character (len=*), intent(in) :: instr
    character (len=*), intent(in) :: sub1
    character (len=*), intent(in) :: sub2
    character (len=*), intent(INOUT) :: outstr
    character (len=*), intent(in), optional :: how
    logical, intent(in), optional :: no_trim

    !----------Local vars----------!
    character (len=len(instr)) :: str
    integer, parameter         :: EARLYSUB2INTERPRETATION = 2 ! 2 or 1
    integer :: i, isub1, isub2, strlen, tmpstrlen
    character (len=7) :: my_how
    character(len=1) :: separator
    character(len=*), parameter :: separators =',.$%#{}()'
    character (len=max(len(instr), len(outstr))) :: tmpstr
    character (len=max(len(instr), len(outstr))) :: tmpstr2
    logical :: my_no_trim, trimming
    !----------Executable part----------!
    my_how = 'first'
    if ( present(how) ) my_how = lowercase(how)
    my_no_trim = .false.
    if ( present(no_trim) ) my_no_trim = no_trim
    trimming = .not. my_no_trim
    outstr = ' '
    strlen = len_trim(instr)
    if (strlen < 1 .or. instr == ' ') return
    ! Which interpretation of sub2 occurring before sub1 do we make?
    isub1 = index(instr, trim(sub1))
    isub2 = index(instr, trim(sub2))
    if ( isub2 < isub1 ) then
      if ( isub2 == 0 ) then
        return
      elseif ( EARLYSUB2INTERPRETATION == 2 ) then
        ! zap every occurrence of sub2 up to position isub1
        call ReplaceSubString (instr(1:isub1-1), tmpstr, sub2, '', &
          & which='all', no_trim=.false.)
        tmpstrlen = len_trim(tmpstr)
        tmpstrlen = len(trim(tmpstr))
        str = ''
        if ( tmpstrlen < 1 ) then
          str = instr(isub1:strlen)
        else
          str = tmpstr(1:tmpstrlen) // instr(isub1:strlen)
        endif
      else
        str = instr
      endif
    else
      str = instr
    endif
    if ( trimming ) then
      if (len_trim(sub1) < 1 &
        & .or. &
        & len_trim(sub2) < 1 .or. index(str, trim(sub1)) == 0 &
        & .or. &
        & index(str, trim(sub2)) == 0 ) RETURN
    else
      if (index(str, sub1) == 0 &
        & .or. &
        & index(str, sub2) == 0 ) RETURN
    endif
    do i=1, len(separators)
      if ( index(str, separators(i:i)) == 0 ) exit
    enddo
    if ( i > len(separators) ) return   ! This means our method will fail
    separator = separators(i:i)
    select case (trim(my_how))
    case ('greedy')
      if ( trimming ) then
        call ReplaceSubString (Reverse(trim(str)), tmpstr, &
          & Reverse(trim(sub2)), separator)
        tmpstr2 = Reverse(trim(tmpstr))
        call ReplaceSubString (tmpstr2, tmpstr, sub1, separator)
      else
        call ReplaceSubString (Reverse(str), tmpstr, &
          & Reverse(sub2), separator, no_trim=.true.)
        tmpstr2 = Reverse(tmpstr)
        call ReplaceSubString (tmpstr2, tmpstr, sub1, separator, no_trim=.true.)
      endif
    case ('stingy')
      if ( trimming ) then
        call ReplaceSubString (Reverse(trim(str)), tmpstr, &
          & Reverse(trim(sub1)), separator)
        tmpstr2 = Reverse(trim(tmpstr))
        call ReplaceSubString (tmpstr2, tmpstr, sub2, separator)
      else
        call ReplaceSubString (Reverse(str), tmpstr, &
          & Reverse(sub1), separator, no_trim=.true.)
        tmpstr2 = Reverse(tmpstr)
        call ReplaceSubString (tmpstr2, tmpstr, sub2, separator, no_trim=.true.)
      endif
    case default
      call ReplaceSubString (str, tmpstr2, sub1, separator, &
        & which='first', no_trim=no_trim)
      call ReplaceSubString (tmpstr2, tmpstr, sub2, separator, &
        & which='first', no_trim=no_trim)
    end select
    call GetStringElement (tmpstr, outstr, 2, .true., &
      & inseparator=separator )

  end subroutine ExtractSubString

  ! ---------------------------------------------  GetStringElement  -----

  ! This subroutine takes a (usually) comma-separated string list,
  ! interprets it as a list of individual elements and returns the
  ! sub-string which is the n'th element
  ! if n is too large or small, it returns the separator
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists

  ! if countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! if TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma.
  ! Its length can be more than one, in which case any element of it is
  ! a separator.  For example, it could be ", " to find string elements
  ! separated either by commas or spaces.

  ! See also SplitWords

  subroutine GetStringElement ( inList, outElement, nElement, countEmpty, &
    & inseparator, SeparatorLocation )
    ! Dummy arguments
    character (len=*), intent(in)   :: inList
    character (len=*), intent(out)  :: outElement
    integer, intent(in)             :: nElement ! Entry number to return
    logical, intent(in)             :: countEmpty
    character (len=*), optional, intent(in)       :: inseparator
    integer, optional, intent(out)  :: SeparatorLocation ! -1 if no element

    ! Local variables
    integer :: i           ! Loop counters
    integer :: elem, nextseparator

    character (len=1)               :: separator
    ! Executable code

    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif

    if(nElement.LE.0) then
      outElement = separator
      return
    elseif(len(inList) < nElement) then
      outElement = separator
      return
    endif
    i = 1
    elem = 1
    if ( present(separatorLocation) ) separatorLocation = -1
    do
      if ( i > len(inList) ) then
        outElement = separator
        return
      endif
      nextseparator = i - 1 + SCAN(inList(i:), separator)

      ! No more separators
      if(nextseparator == i - 1) then
        if(elem >= nElement) then
          outElement = inList(i:)
          if ( present(separatorLocation) ) separatorLocation = i
        else
          outElement = separator
        endif
        RETURN

        ! Next separator is the adjacent char
      elseif(nextseparator == i) then
        if(countEmpty) then
          if(elem >= nElement) then
            outElement = BLANK
            RETURN
          else
            elem = elem+1
          endif
        endif

        ! Until next separator is the next element
        else
          if(elem >= nElement) then
            if(i < nextseparator) then
              outElement = inList(i:nextseparator-1)
              if ( present(separatorLocation) ) separatorLocation = i
            else
              outElement = separator
            endif
            RETURN
          elseif(nextseparator >= len(inList)) then
            outElement = separator
            RETURN
          else
            elem = elem+1
          endif
        endif
        i = nextseparator+1
      enddo

  end subroutine GetStringElement

  ! ---------------------------------------------  GetHashElement  -----

  ! This family of subroutines interpret two arguments as a set
  ! of {key = value} pairs

  ! Takes two (usually) comma-separated string lists, interprets
  ! each as a list of elements, treating the first as keys and the second as
  ! a hash table, associative array or dictionary
  ! It returns the sub-string from the hash table corresponding to the key
  ! if the key is not found in the array of keys, it returns the separator
  
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists

  ! if countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! if TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! Another optional arg, part_match, returns a match for the 
  ! first hash element merely found in the key; e.g.
  ! 'won, to, tree' and key 'protocol.dat' matches 'to'

  ! Basic premise: Use StringElementNum on key in keyList to find index
  ! Use this index to GetStringElement from HashList

  ! Someday you may wish to define a StringHash_T made up of the two
  ! strings
  
  subroutine GetHashElement_int( KEYS, VALUES, KEY, VALUE, &
  & COUNTEMPTY, INSEPARATOR, PART_MATCH )

  ! if no match found, return KEYNOTFOUND

  ! Someday you may wish to define a StringHash_T made up of the two
  ! strings
  
    ! Dummy arguments
    character (len=*), intent(in)             :: keys
    integer, dimension(:), intent(in)         :: values
    character (len=*), intent(in)             :: key
    integer, intent(out)                      :: value
    logical, intent(in)                       :: countEmpty
    character (len=*), optional, intent(in)       :: inseparator
    logical, optional, intent(in)             :: part_match

    ! Local variables
    integer :: elem

    ! Executable code

    value = KEYNOTFOUND
    elem = StringElementNum(keys, key, countEmpty, inseparator, part_match)
    if( elem <= 0 ) then
    elseif( elem > size(values) ) then
      value = KEYBEYONDHASHSIZE
    else
      value = values(elem)
    endif

  end subroutine GetHashElement_int

  subroutine GetHashElement_log( KEYS, VALUES, KEY, VALUE, &
  & COUNTEMPTY, INSEPARATOR, PART_MATCH )

  ! if no match found, return FALSE

  ! Someday you may wish to define a StringHash_T made up of the two
  ! strings
  
    ! Dummy arguments
    character (len=*), intent(in)             :: keys
    logical, dimension(:), intent(in)         :: values
    character (len=*), intent(in)             :: key
    logical, intent(out)                      :: value
    logical, intent(in)                       :: countEmpty
    character (len=*), optional, intent(in)       :: inseparator
    logical, optional, intent(in)             :: part_match

    ! Local variables
    integer :: elem

    ! Executable code

    value = .FALSE.
    elem = StringElementNum(keys, key, countEmpty, inseparator, part_match)
    if( elem <= 0 ) then
    elseif( elem > size(values) ) then
      value = .false.
    else
      value = values(elem)
    endif

  end subroutine GetHashElement_log

  subroutine GetHashElement_str( KEYLIST, HASHLIST, KEY, OUTELEMENT, &
  & COUNTEMPTY, INSEPARATOR, PART_MATCH )
  
    ! Dummy arguments
    character (len=*), intent(in)   :: keyList
    character (len=*), intent(in)   :: hashList
    character (len=*), intent(in)   :: key
    character (len=*), intent(out)  :: outElement
    logical, intent(in)   :: countEmpty
    character (len=*), optional, intent(in)       :: inseparator
    logical, optional, intent(in)             :: part_match

    ! Local variables
    integer :: elem
    character (len=1)                          :: separator

    ! Executable code

    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif

    elem = StringElementNum(keyList, key, countEmpty, inseparator, part_match)
    if(elem <= 0) then
      outElement = separator
    else
      CALL GetStringElement(hashList, outElement, elem, &
        & countEmpty, inseparator)
    endif

  end subroutine GetHashElement_str

  subroutine GetHashElement_strarray( KEYLIST, HASHLIST, KEY, ARRAY, &
  & COUNTEMPTY, INSEPARATOR, PART_MATCH )
    ! We fill an array of values from a hash
    ! assuming the array is stored like this
    ! array "name" contains "value_1", "value_2" .. "nalue_n"
    !    key        value
    !    ---        -----
    ! "namen"        "n" (number of elements)
    ! "name(1)"   "value_1"
    ! "name(2)"   "value_2"
    !    .    .    .
    ! "name(n)"   "value_n"
    ! Dummy arguments
    character (len=*), intent(in)                 :: KEYLIST
    character (len=*), intent(in)                 :: HASHLIST
    character (len=*), intent(in)                 :: KEY
    character (len=*), dimension(:), intent(out)  :: ARRAY
    logical, intent(in)                           :: COUNTEMPTY
    character (len=*), optional, intent(in)       :: INSEPARATOR
    logical, optional, intent(in)                 :: PART_MATCH

    ! Local variables
    integer                                       :: j
    character (len=16)                            :: keyString
    integer                                       :: n
    character (len=8)                             :: nCh
    character (len=1)                             :: separator

    ! Executable code

    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif
    
    array = separator
    keyString = trim(key) // 'n'
    call GetHashElement_str(keyList, hashList, keyString, nCh, &
      & countEmpty, inseparator, part_match)
    if ( nCh == separator ) return
    call readIntsFromChars ( nCh, n )
    
    do j=1, n
      call writeIntsToChars( j, nCh )
      keyString = trim(key) // '(' // trim(adjustl(nCh)) // ')'
      call GetHashElement_str( keyList, hashList, keyString, array(j), &
        & countEmpty, inseparator, part_match )
    enddo

  end subroutine GetHashElement_strarray

! -------------------------------------------------  GetMatchedParens  -----
  subroutine GetMatchedParens ( str, pairs, numpairs )
    ! Get the indexes of Matched Parens in str
    ! sorted so that the most deeply nested comes first.
    ! If shape(pairs) = (/2, 1/)
    ! then return only that most deeply nested pair.
    ! Args:
    character(len=*), intent(in)              :: str
    integer, dimension(:,:), intent(out)      :: pairs
    integer, optional      , intent(out)      :: numpairs
    ! Internal variables
    integer                                   :: i
    integer                                   :: n
    integer                                   :: k ! shape(pairs) = (2,k)
    type(Index_Stack_t)                       :: frame
    ! Executable
    k = size(pairs, 2)
    pairs = 0
    n = 0
    if ( present(numpairs) ) numpairs = 0
    do i=1, len_trim(str)
      if ( str(i:i) == '(' ) then
        call Push ( i )
      elseif ( str(i:i) == ')' ) then
        call Pop ( frame )
        ! call outputnamedvalue ( 'matched parens', (/ frame%index, i /) )
        ! call outputnamedvalue ( 'sub-str', &
        !  & str(frame%index+1:i-1) )
        n = n + 1
        pairs(1, n) = frame%index
        pairs(2, n) = i
        if ( present(numpairs) ) numpairs = n
        if ( n >= k ) exit
      endif
    enddo
    call Deallocate_Index_Stack
  end subroutine GetMatchedParens

  ! ---------------------------------------------  GetUniqueInts  -----

  ! This subroutine takes an array of ints and returns another containing
  ! only the unique entries. The resulting array is supplied by the caller
  ! Its first noUnique entries return the unique values found
  ! Later entries are returned unchanged
  ! if optional extra array is supplied, instead
  ! returns entries from first array not also found in second
  ! if optional fillValue is supplied, values = fillValue are ignored
  ! else if optional minValue is supplied, values < minValue are ignored
  ! Some checking is done to make sure it's appropriate

  subroutine GetUniqueInts(ints, outs, noUnique, extra, fillValue, minValue)
    ! Dummy arguments
    integer, dimension(:) :: ints
    integer, dimension(:) :: outs
    integer :: nounique ! number of unique entries
    integer, optional, dimension(:) :: extra
    integer, optional               :: fillValue
    integer, optional               :: minValue

    ! Local variables
    integer :: i,j,k           ! Loop counters
    logical, dimension(:), allocatable :: duplicate ! Set if already found
    integer :: status        ! Status from allocate

    integer :: extrasize
    integer :: howmanymax
    integer :: insize

    ! Executable code, setup arrays
    inSize=SIZE(ints)
    allocate (duplicate(inSize), STAT=status)
    if (status /= 0) CALL PrintMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"duplicate in GetUniqueInts")
    if ( present(extra) ) then
      extraSize=size(extra)
      howManyMax = inSize
      ! print *, 'SIZE(inList) ', inSize
      ! print *, 'SIZE(extra) ', extraSize
    else
      extraSize = -1
      howManyMax = inSize-1 ! don't bother with last one
    endif
    duplicate = .FALSE.

    ! Go through and find duplicates

    do i = 1, howManyMax
       if (.NOT. duplicate(i)) then
         if ( extraSize < 1 ) then
          do j = i+1, inSize
             if (ints(j)==ints(i)) duplicate(j)=.TRUE.
          end do
         else
          do j = 1, extraSize
             if (extra(j)==ints(i)) duplicate(i)=.TRUE.
          end do
         endif
       endif
    end do

    ! Ignore any values = fillValue
    if ( present(fillValue) ) then
      duplicate = duplicate .or. (ints == fillValue)
    elseif ( present(minValue) ) then
      duplicate = duplicate .or. (ints < minValue)
    endif
    ! Count how many unique ones there are

    noUnique=count(.NOT. duplicate)

    if (noUnique>SIZE(outs)) CALL PrintMessage(MLSMSG_Error,ModuleName, &
         & "outs too small in GetUniqueInts")

    if ( noUnique > 0 ) then
      j=1
      UniqueLoop: do i = 1, noUnique
         k = findFirst(.not. duplicate(j:))
         ! print *, 'j: ', j, '   k: ', k
         if ( k+j-1 > inSize ) then
           call PrintMessage(MLSMSG_Error, ModuleName, &
             & "k goes past array end in GetUniqueInts")
           outs(i)=ints(inSize)
           return
         elseif ( k > 0 ) then
           outs(i)=ints(k+j-1)  ! was ints(j)
           j = j + k
         else
           exit UniqueLoop
         endif
         ! j=j+1
         if ( j > inSize ) exit UniqueLoop
      end do UniqueLoop
    endif

    deallocate ( duplicate )
  end subroutine GetUniqueInts

  ! ---------------------------------------------  GetUniqueList  -----

  ! This subroutine takes a string list and returns another containing
  ! only the unique entries. The resulting list is supplied by the caller
  ! (You may safely use the same variable for str and outStr) (?? f95 std??)
  ! E.g., given 'one,two,three,one,four' returns 'one,two,three,four'
  ! if optional string list str2 is supplied, instead
  ! returns list from str that are not also in str2
  ! if optional FillValue supplied, ignores any entries = fillvalue

  subroutine GetUniqueList( str, outStr, noUnique, &
    & inseparator, IgnoreLeadingSpaces, str2, fillValue, options )
    ! Dummy arguments
    character (len=*), intent(in) :: str
    character (len=*), intent(out) :: outstr
    integer :: nounique ! number of unique entries
    ! logical, intent(in)                           :: countEmpty
    character (len=*), optional, intent(in)       :: inseparator
    logical, optional, intent(in)       :: IgnoreLeadingSpaces
    character (len=*), optional, intent(in)       :: str2
    character (len=*), optional, intent(in)       :: fillValue
    character (len=*), optional, intent(in)       :: options

    ! Local variables
    logical :: countEmpty
    character(len=8) :: myOptions
    character (len=MAXSTRELEMENTLENGTH), dimension(:), allocatable    &
      &                             :: inStringArray, outStringArray, inStrAr2
    integer :: nElems
    integer :: nElems2
    integer :: Longestlen
    integer :: status

    ! Executable code
    myOptions = ' '
    if ( present(options) ) myOptions = options
    countEmpty = ( index(myOptions, 'e') > 0 ) 
    if ( len(str) <= 0 .or. len(outstr) <= 0 ) return
    nElems = NumStringElements(str, countEmpty, inseparator, Longestlen)
    noUnique = nElems
    if ( present(str2) ) then
      outStr = ''
      if ( nElems < 1 ) return
    else
      outStr = str
      if ( nElems <= 1 ) return
    endif
    if ( Longestlen > MAXSTRELEMENTLENGTH ) then
      ! print *, 'str: ', trim(str)
      ! print *, 'len(str): ', len(str)
      ! print *, 'Longestlen: ', Longestlen
      ! print *, 'nElems: ', nElems
      call PrintMessage(MLSMSG_Error, ModuleName, &
         & "Element LENGTH too long in GetUniqueList")
      return
    endif
    allocate (inStringArray(nElems), outStringArray(nElems), STAT=status)
    ! print *, 'shapes: ', &
    !   & (/ size(inStringArray), size(outStringArray) /)
    if (status /= 0) CALL PrintMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"stringArray in GetUniqueList")
    call list2Array(str, inStringArray, countEmpty, inseparator, &
     & IgnoreLeadingSpaces)
    ! print *, 'str ', str
    ! print *, 'nElems ', nElems
    ! do status=1, nElems
    !   print *,  inStringArray( status )
    ! enddo
    if ( present(str2) ) then
      nElems2 = NumStringElements(str2, countEmpty, inseparator, Longestlen)
      allocate (inStrAr2(nElems2), STAT=status)
      if (status /= 0) CALL PrintMessage(MLSMSG_Error,ModuleName, &
           & MLSMSG_Allocate//"stringArray2 in GetUniqueList")
      call list2Array(str2, inStrAr2, countEmpty, inseparator, &
       & IgnoreLeadingSpaces)
      call GetUniqueStrings( inStringArray, outStringArray, noUnique, &
       & inStrAr2, fillValue, options )
      if ( noUnique > 0 ) then
        call Array2List(outStringArray(1:noUnique), outStr, &
         & inseparator)
      else
        outStr=''
      endif
      deallocate (inStringArray, outStringArray, inStrAr2)
    else
      ! print *, 'About to getUniqueStrings'
      call GetUniqueStrings( inStringArray, outStringArray, noUnique, &
      & fillValue=fillValue, options=options )
      ! print *, 'noUnique: ', noUnique
      ! do status=1, noUnique
      !   print *,  outStringArray( status )
      ! enddo
      if ( noUnique > 0 ) then
        call Array2List(outStringArray(1:noUnique), outStr, &
         & inseparator)
      else
        outStr=''
      endif
      deallocate (inStringArray, outStringArray)
    endif
      ! print *, 'done with getUniqueList'
  end subroutine GetUniqueList

  ! ---------------------------------------------  GetUniqueStrings  -----

  ! This subroutine takes an array of strings and returns another containing
  ! only the unique entries. The resulting array is supplied by the caller
  ! if optional extra array is supplied, instead
  ! returns entries from first array not also found in second
  ! if optional FillValue supplied, ignores any entries = fillvalue
  ! Some checking is done to make sure it's appropriate

  subroutine GetUniqueStrings( inList, outList, noUnique, &
    & extra, fillValue, options )
    ! Dummy arguments
    character (len=*), dimension(:) :: inList
    character (len=*), dimension(:) :: outList
    integer :: noUnique ! Number of unique entries
    character (len=*), optional, dimension(:) :: extra
    character (len=*), optional, intent(in)       :: fillValue
    character (len=*), optional, intent(in)       :: options

    ! Local variables
    logical, dimension(:), allocatable :: duplicate ! Set if already found

    integer :: extraSize
    integer :: howManyMax
    integer :: i,j,k           ! Loop counters
    integer :: inSize
    logical :: keepLast
    character(len=len(inList)), dimension(size(inList)) :: list
    character(len=8) :: myOptions
    integer :: status        ! Status from allocate
    logical :: Switchable

    ! Executable code, setup arrays
    ! print *, 'Now ino getUniqueStrings'
    myOptions = ' '
    if ( present(options) ) myOptions = options
    Switchable = ( index(myOptions, 'S') > 0 )
    keepLast = ( index(myOptions, 'L') > 0 )
    inSize=SIZE(inList)
    allocate (duplicate(inSize), STAT=status)
    if (status /= 0) CALL PrintMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"duplicate")
    if ( present(extra) ) then
      extraSize=size(extra)
      howManyMax = inSize
      ! print *, 'SIZE(inList) ', inSize
      ! print *, 'SIZE(extra) ', extraSize
    else
      extraSize = -1
      howManyMax = inSize-1 ! don't bother with last one
    endif
    duplicate = .FALSE.

    ! if we are keeping the last instance of a duplicated string, we'll
    ! simply reverse the order of the list, keep the first instance of that
    ! reversed list, then reverse again at the end
    if ( keepLast ) then
      call reverseStrings( inList, list )
    else
      list = inList
    endif
    ! Go through and find duplicates
    do i = 1, howManyMax
       if (.NOT. duplicate(i)) then
         if ( extraSize < 1 ) then
          do j = i+1, inSize
             ! if (List(j)==List(i)) duplicate(j)=.TRUE.
             duplicate(j) = duplicate(j) .or. matchem( List(j), List(i) )
             ! if ( duplicate(j) ) print *, List(j), List(i)
          end do
         else
          do j = 1, extraSize
             ! if (extra(j)==List(i)) duplicate(i)=.TRUE.
             duplicate(j) = duplicate(j) .or. matchem( extra(j), List(i) )
          end do
         endif
       endif
       ! print *, i, duplicate(i)
    end do

    ! Ignore any values = fillValue
    if ( present(fillValue) ) then
      ! duplicate = duplicate .or. (List == fillValue)
    do i = 1, size(duplicate)
      duplicate(i) = duplicate(i) .or. matchem( List(i), fillValue )
    enddo
    endif
    ! Count how many unique ones there are

    noUnique=count(.NOT. duplicate)

    if (noUnique>SIZE(outList)) CALL PrintMessage(MLSMSG_Error,ModuleName, &
         & "outList too small")
    if (len(outList)<len(List)) CALL PrintMessage(MLSMSG_Error,ModuleName, &
         & "outList strings too small")
    outList=""

    ! print *, 'NoUnique: ', noUnique
    if ( noUnique > 0 ) then
      ! do j=1, inSize, 20
      !   print *, (duplicate(j+i), i=0, min(19, inSize-j))
      ! enddo
      j=1
      UniqueLoop: do i = 1, noUnique
         ! UniqueHuntLoop: do
         !   if (.NOT. duplicate(j)) EXIT UniqueHuntLoop
         !   j=j+1
         !   if ( j > inSize ) exit UniqueLoop
         ! end do UniqueHuntLoop
         k = findFirst(.not. duplicate(j:))
         ! print *, 'j: ', j, '   k: ', k
         if ( k+j-1 > inSize ) then
           call PrintMessage(MLSMSG_Error, ModuleName, &
             & "k goes past array end in GetUniqueStrings")
           outList(i)=List(inSize)
           return
         elseif ( k > 0 ) then
           outList(i)=List(k+j-1)  ! was List(j)
           j = j + k
         else
           exit UniqueLoop
         endif
         ! j=j+1
         if ( j > inSize ) exit UniqueLoop
      end do UniqueLoop
    endif
    ! print *, 'done with UniqueLoop'
    ! if we reversed the order, recover the original order
    if ( keepLast ) then
      list = outList
      ! print *, 'reversing strings'
      call reverseStrings( list(1:noUnique), outList(1:noUnique) )
    endif

    deallocate ( duplicate )
    ! print *, 'Leaving getUniqueStrings'
    contains
    function matchem( str1, str2 ) result ( match )
      ! Test for match between str1 and str2 according to options
      ! Args
      character(len=*), intent(in) :: str1
      character(len=*), intent(in) :: str2
      logical                      :: match
      ! Internal variables
      character(len=len(str1)) :: switch1, switch2
      integer :: details1, details2
      ! Executable
      match = .false.
      if ( .not. Switchable ) then
        match = (str1 == str2)
      else
        call SplitDetails( str1, switch1, details1 )
        call SplitDetails( str2, switch2, details2 )
        match = (switch1 == switch2)
      endif
    end function matchem
  end subroutine GetUniqueStrings

  ! -------------------------------------------------  inserthashlement  -----
  subroutine INSERTHASHELEMENT ( NAME, VALUE, KEYS, VALUES, INSEPARATOR )
    ! Dummy args
    character(len=*), intent(in)           :: NAME
    character(len=*), intent(in)           :: VALUE
    character(len=*), intent(inout)        :: KEYS
    character(len=*), intent(inout)        :: VALUES
    character(len=1), intent(in), optional :: INSEPARATOR
    ! Local variables
    character(len=64) :: cvalue
    character (len=16)                            :: keyString
    character (len=8)                             :: nCh
    character (len=1)                             :: separator
    ! Executable
    separator = ','
    if ( present(inseparator) ) separator = inseparator
    ! 1st--is name an array-valued hash key?
    keyString = trim(name) // 'n'
    call GetHashElement( keys, values, keyString, nCh, &
      & countEmpty, inseparator=separator )
    if ( nCh == separator ) then
      ! No, it's just a scalar
      call PutHashElement ( keys, values, &
      & trim(name), value, countEmpty=countEmpty, inseparator=separator )
    else
      ! Yes, it's an array, so we must put it in two places:
      ! "name(cvalue)" and "name(n)" where
      ! cvalue is the actual value of "count"
      ! and "name(n)" is literally that (i.e., don't evaluate "n")
      call GetHashElement( keys, values, &
        & 'count', cvalue, countEmpty=countEmpty, inseparator=separator )
      keyString = trim(name) // '(n)'
      ! if ( DEEBUG ) then
      !  call outputnamedValue( 'keyString', trim(keyString) )
      !  call outputnamedValue( 'value', trim(value) )
      ! endif
      call PutHashElement ( keys, values, &
        & trim(keyString), value, countEmpty=countEmpty, inseparator=separator )
      keyString = trim(name) // '(' // trim(adjustl(cvalue)) // ')'
      ! if ( DEEBUG ) then
      !   call outputnamedValue( 'keyString', trim(keyString) )
      !   call outputnamedValue( 'value', trim(value) )
      ! endif
      call PutHashElement ( keys, values, &
        & trim(keyString), value, countEmpty=countEmpty, inseparator=separator )
    endif

  end subroutine INSERTHASHELEMENT

  ! -------------------------------------------------  Intersection  -----
  function Intersection ( str1, str2, options ) result ( outstr )
    ! return intersection of 2 string lists, blank means empty set
    ! E.g., given str1 = 'a,b,c' and str2 = 'd,e,f,c,a'
    ! returns 'a,c'
    ! options
    ! '-w' combined with wildcard '*' lets 'a*' match any string 'a..'
    !--------Argument--------!
    character (len=*), intent(in)                 :: str1
    character (len=*), intent(in)                 :: str2
    character (len=*), optional, intent(in)       :: options
    character (len=len(str1)+len(str2)+1)         :: outstr

    !----------Local vars----------!
    logical, parameter :: countEmpty = .true.
    logical, parameter :: ignoreLeadingSpaces = .true.
    character(len=len(str1)) :: elem
    character(len=len(str1)) :: uniq1
    character(len=len(str2)) :: uniq2
    integer :: n1, n2
    integer :: i
    !----------executable part----------!

    if ( str1 == ' ' .or. str2 == ' ' ) then
      outstr = ' '
      return
    endif
    
    call GetUniqueList( str1, uniq1, n1, &
      & ignoreLeadingSpaces=ignoreLeadingSpaces, options='-e' )
    call GetUniqueList( str2, uniq2, n2, &
      & ignoreLeadingSpaces=ignoreLeadingSpaces, options='-e' )
    outstr = ' '
    do i=1, n1
      call GetStringElement( uniq1, elem, i, countEmpty )
      if ( IsInList( uniq2, trim(elem), options) ) &
        & outstr = CatLists( outstr, elem )
    enddo

  end function Intersection

  ! ---------------------------------------------  IsInList  -----

  ! Is string in the stringList? options may expand criteria
  ! See notes above about options
  ! options
  ! Warning: wildcard may be found in either stringList or string
  ! which may or may not be what you intended
  ! E.g.
  ! stringList = 'abcd,a*,bcd,cd,d' and string='acd' with options = '-w'
  !              returns TRUE because 'a*' matches 'acd'
  ! Special cases:
  ! string == ' '      => always FALSE
  ! stringList == ' '  => always FALSE
  function IsInList( stringList, string, options ) result(itIs)
    ! Dummy arguments
    character (len=*), optional, intent(in)       :: stringlist
    character (len=*), intent(in)                 :: string
    character (len=*), optional, intent(in)       :: options
    logical                                       :: itIs
    ! Internal variables
    logical, parameter :: countEmpty = .true.
    integer :: i
    integer :: n
    character(len=MAXELEMENTLENGTH) :: element
    ! Executable
    itIs = .false.
    if ( .not. present(stringList) ) return
    if ( len_trim(stringList) < 1 .or. len_trim(string) < 1 ) return
    n = NumStringElements( stringList, countEmpty )
    do i=1, n
      call GetStringElement( stringList, element, i, countEmpty )
      if ( element == ' ' ) cycle
      itIs = streq( trim(element), trim(string), options )
      if ( itIs ) return
    enddo
  end function IsInList

  ! ---------------------------------------------  List2Array  -----

  ! This subroutine takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements and returns an equivalent array of
  ! sub-strings in which the n'th element is the n'th element

  ! if countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! if TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! if the optional arg ignoreLeadingSpaces is TRUE, "a, b, c" is
  ! treated like "a,b,c"; otherwise the leading spaces are retained

  subroutine List2Array( inList, outArray, countEmpty, inseparator, &
   & IgnoreLeadingSpaces )
    ! Dummy arguments
    character (len=*), intent(in)                 :: inList
    character (len=*), dimension(:), intent(out)  :: outArray
    logical, intent(in)                           :: countEmpty
    character (len=*), optional, intent(in)       :: inseparator
    logical, optional, intent(in)                 :: IgnoreLeadingSpaces

    ! Local variables
    integer :: elem, nElems

    logical                         :: myIgnoreLeadingSpaces
    ! Executable code

    if(present(IgnoreLeadingSpaces)) then
      myIgnoreLeadingSpaces = IgnoreLeadingSpaces
    else
      myIgnoreLeadingSpaces = .false.
    endif

    if ( size(outArray) <= 0 ) return
    outArray = BLANK
    elem = 1
    nElems = NumStringElements(inList, countEmpty, inseparator)
    if ( nElems <= 0 ) return
    do
      call GetStringElement(inList, outArray(elem), elem, countEmpty, inseparator)
      if ( myIgnoreLeadingSpaces ) outArray(elem) = adjustl(outArray(elem))
      elem = elem + 1
      if ( elem > min(nElems, size(outArray)) ) return
    enddo

  end subroutine List2Array

  ! ---------------------------------------------  listMatches  -----

  ! Return list of matches for string in the stringList. 
  ! options may expand criteria
  ! See notes above about options
  ! options
  ! Warning: wildcard may be found in either stringList or string
  ! which may or may not be what you intended
  ! E.g.
  ! stringList = 'abcd,a*,bcd,cd,d' and string='acd' with options = '-w'
  !              returns 'a*' because 'a*' matches 'acd'
  ! Special cases:
  ! string == ' '      => always ' '
  ! stringList == ' '  => always ' '
  function listMatches( stringList, string, options ) result(matches)
    ! Dummy arguments
    character (len=*), intent(in)                 :: stringlist
    character (len=*), intent(in)                 :: string
    character (len=*), optional, intent(in)       :: options
    character (len=len(stringList))               :: matches
    ! Internal variables
    ! logical, parameter :: countEmpty = .true.
    integer :: i
    logical :: itMatches
    integer :: n
    character(len=max(len(stringList), len(string))) :: element
    ! Executable
    call prepOptions( options )
    matches = ' '
    if ( len_trim(stringList) < 1 .or. len_trim(string) < 1 ) return
    n = NumStringElements( stringList, countEmpty )
    do i=1, n
      call GetStringElement( stringList, element, i, countEmpty )
      if ( element == ' ' ) cycle
      itMatches = streq( trim(element), trim(string), options )
      if ( itMatches ) then
        matches = CatLists( matches, element )
      endif
    enddo
  end function listMatches

  ! -------------------------------------------------  LoopOverFormula  -----
  subroutine LoopOverFormula ( formula, arg, values, results )
    ! Looping while it evaluates a formula, plugging in the nth value for
    ! each occurrence of the arg appearing as '${arg}'
    ! E.g., if arg is "phase", formula is 
    ! "x${phase}: vector, template=state"
    ! and the values of arg are (/"InitPtan ", "FinalPtan"/) 
    ! then the results array will be
    ! (/
    ! "xInitPtan: vector, template=state", 
    ! "xFinalPtan: vector, template=state"
    ! /)
    !--------Argument--------!
    character (len=*), intent(in)                :: formula
    character (len=*), intent(in)                :: arg
    character (len=*), dimension(:), intent(in)  :: values
    character (len=*), dimension(:), intent(out) :: results

    !----------Local vars----------!
    integer :: i, n
    character (len=len(formula)+len(values)) :: tmpstr
    character (len=len(values))              :: value
    character(len=len_trim(arg)+8)           :: variable
    !----------executable part----------!
    n = min( size(values), size(results) )
    results = formula
    ! Check whether we have any work to do
    if ( n < 1 .or. index( formula, '${' ) < 1 ) return
    variable = '${' // trim(adjustl(arg)) // '}'
    do i=1, n
      value = values(i)
      tmpstr = results(i)
      call ReplaceSubString( tmpStr, results(i), trim(variable), trim(value), &
        & which='all', no_trim=.true. )
    enddo
  end subroutine LoopOverFormula

  ! .............................................  nCharsinFormat  .....
  function nCharsinFormat ( Format ) result(nplusm)
    ! Utility to calculate how many characters in a format spec:         
    ! [n{xX}][,]{DEFGdefg}m.b                                             
    ! where n, m, and b are digits (we care only about n and m)           
    ! return (n+m)
    ! Tested for specs: sci. format esm.b and eng. format enm.b
    ! Also for min. width spec: 'f0.b' it will silently return 0
    ! (It's up to you to handle that correctly)
    ! Args                                                                
    character(len=*), intent(in) ::  Format                               
    integer :: nplusm                                                     
    ! Local variables                                                     
    character(len=20) :: kChar, myFormat                                  
    integer :: n, m
    ! Executable                                                          
    nplusm = 0                                                            
    kChar=lowerCase(Format)
    call ReplaceSubString(kChar, myFormat, 'es', 'f')                   
    call ReplaceSubString(myFormat, kChar, 'en', 'f')                   
    call ReplaceSubString(kChar, myFormat, 'g', 'f')                   
    call ReplaceSubString(myFormat, kChar, 'e', 'f')                   
    call ReplaceSubString(kChar, myFormat, 'd', 'f')                   
    call ExtractSubString(TRIM(myFormat), kChar, 'f', '.')             
    if ( kChar == '0' ) return ! Special case of e.g. 'f0.3'
    read (kChar, '(i2)') m                                                
    if (m < 1) call PrintMessage ( MLSMSG_Error, ModuleName, &              
      & 'Bad conversion to m in OUTPUT_xxxLE (format not "{defg}"' )      
    if ( index(TRIM(myFormat), 'x' ) == 0 ) then                          
      n = 0                                                               
    else                                                                  
      call ExtractSubString(TRIM(myFormat), kChar, '(', 'x')           
      read (kChar, '(i2)') n                                              
      if (n < 1) then                                                     
        print *, trim(kChar)                                              
        print *, trim(myFormat)                                           
        call PrintMessage ( MLSMSG_Error, ModuleName, &                     
          & 'Bad conversion to n in OUTPUT_xxxLE (format not "{defg}"' )  
      end if                                                              
    end if                                                                 
    nplusm = n + m                                                        
  end function nCharsinFormat

  ! ---------------------------------------------  NumStringElements  -----

  ! This function takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements and returns the
  ! number of elements
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists
  !
  ! if countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE  

  ! As an optional arg the separator may supplied, in case it isn't comma

  ! See also GetStringElement

  function NumStringElements(inList, countEmpty, &
   & inseparator, Longestlen) RESULT (nElements)
    ! Dummy arguments
    character (len=*), intent(in)             :: inList
    logical, intent(in)                       :: countEmpty
    integer                                   :: nElements
    character (len=*), optional, intent(in)       :: inseparator
    integer, optional, intent(out)            :: Longestlen  ! LENGTH of longest

    ! Local variables
    integer :: i, sinceLastseparated           ! Loop counters
    logical :: lastWasNotseparated

    character (len=1)               :: separator
    ! Executable code

    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif

   ! Count the number of separators
   if ( present(Longestlen) ) &
     & Longestlen =0
   ! nElements-1 = number of separators
   if(len_TRIM(inList) <= 0) then
     nElements=0
      if ( present(Longestlen) ) Longestlen = 0
      RETURN
   endif

   lastWasNotseparated = .FALSE.
   nElements = 1
   sinceLastseparated = 0
   do i=1, len_TRIM(inList)
     if(inList(i:i) == separator) then
       if(countEmpty .OR. lastWasNotseparated) then
         nElements = nElements+1
            if ( present(Longestlen) ) &
             & Longestlen = max(Longestlen, sinceLastseparated)
       endif
       lastWasNotseparated = .FALSE.
       sinceLastseparated = 0
     else
       lastWasNotseparated = .TRUE.
       sinceLastseparated = sinceLastseparated + 1
     endif
   enddo
   if ( present(Longestlen) ) &
     & Longestlen = max(Longestlen, sinceLastseparated)

  end function NumStringElements

  ! ---------------------------------------------  optionDetail  -----

  ! This function takes a string, interprets it
  ! as a list of individual one-character options, and a test option
  ! It returns
  !  'yes' if the option is present
  !  'no'  if the option is absent
  !  'arg' if the option is present and completed by (takes as argument) 'arg'
  !    
  ! single_option is a one-character option
  ! multi_option is a multi-character alternate form
  ! E.g., single_option might be 'a' while multi_option might be 'answer'
  ! so the option could be set in either form '-a' or '--answer'
  ! if patterns is present, it determines whether options must be preceded
  ! by an '-' and how args are to be denoted
  ! Recognized values of pattern are
  ! 0: '-ab[arg] --xyz=arg' means  '(default)'
  !    may catenate single-char single_options; any arg is surrounded by "[]"
  !    multiple-char multi_option preceded by '--'; any arg set off by "="
  ! 1: '-a -b arg --xyz=arg' means 
  !    each single_option preceded by '-'; any arg is set off by a space
  !    multiple-char multi_option preceded by '--'; any arg set off by "="
  ! 2: '-a -b arg -xyz arg' means 
  !    each single_option preceded by '-'; any arg is set off by a space
  !    multiple-char multi_option preceded by '-'; any arg set off by a space
  ! 3: '-a -b arg --xyz arg' means 
  !    each single_option preceded by '-'; any arg is set off by a space
  !    multiple-char multi_option preceded by '--'; any arg set off by a space
  
  ! 4: '-a -barg --xyz arg' means 
  !    each single_option preceded by '-'; followed immediately by any arg
  !    multiple-char multi_option preceded by '--'; any arg set off by a space
  
  ! As an example, say the list of options is
  ! "-ab[arg1]c[arg2]d"
  ! and the test option is "b"
  ! The returned value would be 'arg1'
  ! if the test option were "a" the returned value would be 'yes'
  ! if the test option were "c" the returned value would be 'arg2'
  ! if the test option were "g" the returned value would be 'no'
  ! (because g doesn't count except outside the '[]' chars)
  
  ! The behavior may be modified by pattern and delims args
  ! For which see comment above
  
  ! Notes:
  ! (1) if the string list is absent then the test option is automatically absent
  ! (2) if the string list is "*" then
  ! the test option is automatically present (would you like to override that?)
  ! (3) Why don't you let the '[]' pair that set off args be
  ! overridden, say by other optional args?
  
  function optionDetail( inList, single_option, multi_option, &
    & pattern, delims ) RESULT (detail)
    ! Dummy arguments
    character (len=*), optional, intent(in)   :: inlist
    character (len=1), optional, intent(in)   :: single_option
    character (len=*), optional, intent(in)   :: multi_option
    integer, optional, intent(in)             :: pattern
    character (len=1), dimension(2), optional, &
     & intent(in)                             :: delims
    character (len=MAXELEMENTLENGTH)               :: detail
    ! Local variables
    integer :: bloc
    logical, parameter :: COUNTEMPTY = .true.
    character :: cquotes, quotes
    integer :: k
    character (len=MAXELEMENTLENGTH)           :: element
    character (len=MAXELEMENTLENGTH)           :: listBloc ! space-separated
    logical :: multi
    integer :: myPattern
    character(len=16) :: test_multi
    character :: test_option
    character(len=*), dimension(0:4), parameter :: multi_prefix = &
      & (/ '--', '--', '- ', '--' , '--' /)

    ! Executable code
    detail = 'no'
    if ( .not. present(inList) ) return
    test_option = char(0) ! NULL
    test_multi = char(0) ! NULL
    if ( present(single_option) ) test_option = single_option
    if ( test_option == ' ' ) test_option = char(0) ! NULL
    if ( present(multi_option) ) test_multi = multi_option
    if ( test_multi == ' ' ) test_multi = char(0) ! NULL
    myPattern = 0
    if ( present(pattern) ) then
      if ( any(Pattern == (/0, 1, 2, 3, 4 /)) &  ! accept legal values only
        & ) myPattern = pattern
    endif
    if ( adjustl(inList) == '*' ) then
      detail = 'yes'
      return
    endif
    quotes = '['
    cquotes = ']'
    if ( present(delims) ) then
      quotes = delims(1)
      cquotes = delims(2)
    endif
    if ( .not. present(single_option) .and. .not. present(multi_option) ) return
    select case (myPattern)
    case ( 0 )
      ! '-ab[arg] --xyz=arg
      if ( index( inList, test_option ) < 1 ) then
        if ( .not. present(multi_option) ) return
      endif

      ! OK, test_option or its alt may be present, but where? 
      ! does it have an arg?

      do bloc = 1, NumStringElements( inList, countEmpty, inseparator=' ' )
        listBloc = StringElement( inList, bloc, countEmpty, inseparator=' ' )
        ! does this block begin with one "-" or two?
        multi = ( index( listBloc, trim(multi_prefix(myPattern)) ) > 0 )
        if ( multi ) then
          if ( .not. present(multi_option) ) cycle
          k = index(listBloc, trim(multi_prefix(myPattern)) // &
            & trim(test_multi) // '=' )
          if ( k > 0 ) then
            k = index(listBloc, '=' )
            detail = listBloc(k+1:)
            return
          elseif ( index(listBloc, trim(multi_prefix(myPattern)) // &
            & trim(test_multi) // ' ' ) > 0 ) then
            detail = 'yes'
            return
          endif
        else
          ! 1st--rid ourselves of everything bracketed by '[]'
          ! element = unquote( listBloc, quotes='[', cquotes=']', &
          element = unquote( listBloc, quotes=quotes, cquotes=cquotes, &
            & options='-r' )
          ! print *, 'After unquote: ', trim(element)
          if ( index(element, test_option) < 1 ) cycle
          call extractSubstring( listBloc, element, &
            & test_option // quotes, cquotes )
          ! print *, 'After extracting: ', trim(element)
          if ( len_trim(element) > 0 ) then
            detail = element
          else
            detail = 'yes'
          endif
          return
        endif
      enddo

    case ( 1 )
      ! '-a -b arg --xyz=arg'
      if ( index( inList, test_option ) < 1 ) then
        if ( .not. present(multi_option) ) return
      endif

      ! OK, test_option or its alt may be present, but where? 
      ! does it have an arg?

      do bloc = 1, NumStringElements( inList, countEmpty, inseparator=' ' )
        listBloc = StringElement( inList, bloc, countEmpty, inseparator=' ' )
        ! does this block begin with one "-" or two?
        multi = ( index( listBloc, trim(multi_prefix(myPattern)) ) > 0 )
        if ( multi ) then
          if ( .not. present(multi_option) ) cycle
          k = index(listBloc, trim(multi_prefix(myPattern)) // &
            & trim(test_multi) // '=' )
          if ( k > 0 ) then
            k = index(listBloc, '=' )
            detail = listBloc(k+1:)
            return
          elseif ( index(listBloc, trim(multi_prefix(myPattern)) // &
            & trim(test_multi) // ' ' ) > 0 ) then
            detail = 'yes'
            return
          endif
        else
          if ( index(listBloc, '-' // test_option) > 0 ) then
            ! OK, we've got the option all right; but is the next block an arg?
            detail = 'yes'
            if ( bloc == NumStringElements( inList, countEmpty, inseparator=' ' ) ) &
              & return
            element = StringElement( inList, bloc+1, countEmpty, inseparator=' ' )
            if ( index(adjustl(element), '-') == 1 ) then
              return
            else
              detail = element
              return
            endif
          endif
        endif
      enddo

    case ( 2, 3 )
      ! '-a -b arg -xyz arg' or
      ! '-a -b arg --xyz arg'
      if ( index( inList, test_option ) < 1 ) then
        if ( .not. present(multi_option) ) return
      endif

      ! OK, test_option or its alt may be present, but where? 
      ! does it have an arg?

      do bloc = 1, NumStringElements( inList, countEmpty, inseparator=' ' )
        listBloc = StringElement( inList, bloc, countEmpty, inseparator=' ' )
        ! does this block begin with one "-" or not?
        if ( index(adjustl(listbloc), '-') == 1 ) then
          if ( adjustl(listBloc) == '-' // test_option ) then
            detail='yes' ! keep going--next we'll check for an arg
          elseif( .not. present(multi_option) ) then
            cycle
          elseif ( adjustl(listBloc) == trim(multi_prefix(myPattern)) // &
            & test_multi ) then
            detail='yes' ! keep going--next we'll check for an arg
          else
            cycle
          endif
          ! Now check if next bloc is an arg
          if ( bloc == NumStringElements( inList, countEmpty, inseparator=' ' ) ) &
            & return
          element = StringElement( inList, bloc+1, countEmpty, inseparator=' ' )
          if ( index(adjustl(element), '-') == 1 ) then
            return
          else
            detail = element
            return
          endif
        endif
      enddo
    case ( 4 )
      ! '-a -barg --xyz arg'
      if ( index( inList, '-' // test_option ) < 1 ) then
        if ( .not. present(multi_option) ) return
      endif

      ! OK, test_option or its alt may be present, but where? 
      ! does it have an arg?

      do bloc = 1, NumStringElements( inList, countEmpty, inseparator=' ' )
        listBloc = StringElement( inList, bloc, countEmpty, inseparator=' ' )
        ! does this block begin with one "-" or two?
        multi = ( index( listBloc, trim(multi_prefix(myPattern)) ) > 0 )
        if ( multi ) then
          if ( .not. present(multi_option) ) cycle
          if ( index( listBloc, trim(multi_prefix(myPattern)) // &
            & trim(multi_option) ) < 1 ) cycle
          detail = StringElement( inList, bloc+1, countEmpty, inseparator=' ' )
          if ( detail == ' ' .or. detail(1:1) == '-' ) detail = 'yes'
        else
          if ( index(listBloc, '-' // test_option) > 0 ) then
            ! OK, we've got the option all right; but is it followed by an arg?
            detail = 'yes'
            if ( listBloc(3:3) == ' ' ) cycle
            detail = listBloc(3:)
          endif
        endif
      enddo
    case default
    end select
  end function optionDetail

  ! ---------------------------------------------  ParseOptions  -----

  ! Parse a commandline, checking for the presence of single-character
  ! options or multi-character options, returning in opts_out for each
  !  'yes' if the option is present
  !  'no'  if the option is absent
  !  'arg' if the option is present and completed by its needed 'arg'
  !  ' '   if the option is present but missing its needed 'arg'
  !    
  ! single_options are all the one-character options
  ! multi_options are multi-character alternate forms
  ! whether it needs an arg is determined by needs_arg
  
  ! cmdargs, if present, will return any remaining commandline args

  ! The behavior may be modified by pattern and delims args
  ! For which see comment above
  
  ! Notes:
  ! (1) See also optionDetail, switchDetail
  
  subroutine ParseOptions( cmdline, opts_out, pattern, single_options, &
    & multi_options, needs_arg, delims, cmdargs )
    ! Dummy arguments
    character (len=*), intent(in)                  :: cmdline
    character (len=*), dimension(:), intent(out)   :: opts_out
    character (len=1), dimension(:), intent(in)    :: single_options
    integer, intent(in)                            :: pattern
    character (len=*),  dimension(:), intent(in)   :: multi_options
    logical,  dimension(:), intent(in)             :: needs_arg
    character (len=1), dimension(2), optional, &
      & intent(in)                                 :: delims
    character (len=*), dimension(:), optional, intent(out)&
      &                                            :: cmdargs

    ! Local variables
    logical, parameter :: COUNTEMPTY = .true.
    integer :: i, j, k
    character(len=16)  :: lastOption
    logical            :: lastOptionNeededArg
    integer :: nopts
    ! Begin executable
    if ( size(opts_out) > 0 ) opts_out = 'no'
    if ( present(cmdargs) ) cmdargs = ' '
    if ( size(opts_out) < 1 ) return
    if ( len_trim(cmdline) < 1 ) return
    nopts = min( size(single_options), size(multi_options) )
    nopts = min( nopts, size(opts_out) )
    do i = 1, nopts
      opts_out(i) = optionDetail( cmdline, single_options(i), &
        & multi_options(i), pattern, delims )
      ! Now check for needed args
      if ( needs_arg(i) ) then
        if ( opts_out(i) == 'yes' ) opts_out(i) = ' '
      else
        if ( .not. IsInList('yes,no', trim(opts_out(i))) ) opts_out(i) = 'yes'
      endif
    enddo
    if ( .not. present(cmdargs) ) return
    ! Must find last option
    k = index( cmdline, '-', back=.true. )
    if ( k < 1 ) then
      ! No options on cmdline--everything is a cmdarg
      do i = 1, NumStringElements( cmdline, countEmpty, inseparator=' ' )
        cmdargs(i) = StringElement( cmdline, i, countEmpty, inseparator=' ' )
      enddo
      return
    endif
    ! Now must find which option that was
    lastOption = StringElement( cmdline(k+1:), 1, countEmpty, inseparator=' ' )
    i = FindFirst( single_options, trim(lastOption) )
    if ( i < 1 ) i = FindFirst( multi_options, trim(lastOption) )
    if ( i < 1 ) then
      ! Whoa, option not recognized, but we'll just carry on nonetheless
      lastOptionNeededArg = .false.
    else
      lastOptionNeededArg = needs_arg(i)
    endif
    i = 0
    do j=1, NumStringElements( cmdline(k+1:), countEmpty, inseparator=' ' )
      if ( j == 1 ) cycle ! skip last option
      if ( j == 2 .and. lastOptionNeededArg ) cycle ! skip last option's arg
      if ( i >= size(cmdargs) ) cycle
      i = i + 1
      cmdargs(i) = StringElement( cmdline(k+1:), j, countEmpty, inseparator=' ' )
    enddo
  end subroutine ParseOptions

  ! ---------------------------------------------  PutHashElement  -----

  ! This family of subroutines interprets two arguments as
  ! a set of {key = value} pairs
  ! Given a (possibly new) key and value, insert or replace the value
  ! This subroutine takes two (usually) comma-separated string lists, interprets it
  ! each as a list of elements, treating the first as keys and the second as
  ! a hash table, associative array or dictionary
  ! It replaces with elem the sub-string from the hash table corresponding to the key
  ! if the key is not found in the array of keys, it adds a new key

  ! if countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! if TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! Another optional arg, part_match, returns a match for the 
  ! first hash element merely found in the key; e.g.
  ! 'won, to, tree' and key 'protocol.dat' matches 'to'

  ! Basic premise: Find the element number corresponding to the key
  ! if found remove that element from both key and hash list
  ! then add new key and hash to lists

  ! Someday you may wish to define a StringHash_T made up of the two
  ! strings
  

  subroutine PutHashElement_int( keys, values, key, value, &
  & countEmpty, inseparator, part_match )
    ! Dummy arguments
    character (len=*), intent(inout)          :: keys
    integer, dimension(:), intent(inout)      :: values
    character (len=*), intent(in)             :: key
    integer, intent(in)                       :: value
    logical, intent(in)                       :: countEmpty
    character (len=*), optional, intent(in)   :: inseparator
    logical, optional, intent(in)             :: part_match

    ! Local variables
    integer                                    :: N
    integer                                    :: num

    ! Executable code

    num = StringElementNum(keys, key, countEmpty, inseparator, part_match)
    if( num > 0 .and. num <= size(values) ) then
      values(num) = value
    elseif( num > size(values) ) then
      ! Can't handle arrays this big
    else
      ! key not found :: must add to keys, values
      N = NumStringElements( keys, countEmpty, inseparator )
      keys = CatLists( keys, key, inseparator )
      values(N+1) = value
    endif

  end subroutine PutHashElement_int

  subroutine PutHashElement_log( keys, values, key, value, &
  & countEmpty, inseparator, part_match )
    ! Dummy arguments
    character (len=*), intent(inout)          :: keys
    logical, dimension(:), intent(inout)      :: values
    character (len=*), intent(in)             :: key
    logical, intent(in)                       :: value
    logical, intent(in)                       :: countEmpty
    character (len=*), optional, intent(in)   :: inseparator
    logical, optional, intent(in)             :: part_match

    ! Local variables
    integer                                    :: N
    integer                                    :: num

    ! Executable code
    num = StringElementNum( keys, key, countEmpty, inseparator, part_match )
    if( num > 0 .and. num <= size(values) ) then
      values(num) = value
    elseif( num > size(values) ) then
      ! Can't handle arrays this big
    else
      ! key not found :: must add to keys, values
      N = NumStringElements( keys, countEmpty, inseparator )
      keys = CatLists( keys, key, inseparator )
      values(N+1) = value
    endif

  end subroutine PutHashElement_log

  subroutine PutHashElement_str( keyList, hashList, key, elem, &
  & countEmpty, inseparator, part_match )
    ! Dummy arguments
    character (len=*), intent(inout)          :: keyList
    character (len=*), intent(inout)          :: hashList
    character (len=*), intent(in)             :: key
    character (len=*), intent(in)             :: elem
    logical, intent(in)                       :: countEmpty
    character (len=*), optional, intent(in)   :: inseparator
    logical, optional, intent(in)             :: part_match

    ! Local variables
    integer                                    :: num
    character(len=len(keyList)+len(key)+1)     :: keys
    character(len=len(hashList)+len(elem)+1)   :: hash

    ! Executable code
    num = StringElementNum( keyList, key, countEmpty, inseparator, part_match )
    if( num > 0) then
      call RemoveNumFromList( keyList, keys, num, inseparator )
      call RemoveNumFromList( hashList, hash, num, inseparator )
    else
      keys = keyList
      hash = hashList
    endif
    keyList = CatLists( keys, key, inseparator )
    hashList = CatLists( hash, elem, inseparator )

  end subroutine PutHashElement_str

  subroutine PutHashElement_strarray( KEYLIST, HASHLIST, KEY, ARRAY, &
  & COUNTEMPTY, INSEPARATOR, PART_MATCH )
    ! We insert an array of values onto a hash
    ! storing the array like this
    ! array "name" contains "value_1", "value_2" .. "nalue_n"
    !    key        value
    !    ---        -----
    ! "namen"        "n" (number of elements)
    ! "name(1)"   "value_1"
    ! "name(2)"   "value_2"
    !    .    .    .
    ! "name(n)"   "value_n"
    ! Dummy arguments
    character (len=*), intent(inout)              :: KEYLIST
    character (len=*), intent(inout)              :: HASHLIST
    character (len=*), intent(in)                 :: KEY
    character (len=*), dimension(:), intent(in)   :: ARRAY
    logical, intent(in)                           :: COUNTEMPTY
    character (len=*), optional, intent(in)       :: INSEPARATOR
    logical, optional, intent(in)                 :: PART_MATCH

    ! Local variables
    integer                                       :: j
    character (len=16)                            :: keyString
    integer                                       :: n
    character (len=8)                             :: nCh

    ! Executable code
    n = size(array)
    if ( n < 1 ) return
    call writeIntsToChars( n, nCh )
    keyString = trim(key) // 'n'
    call PutHashElement_str( keyList, hashList, keyString, nCh, &
      & countEmpty, inseparator, part_match )
    
    do j=1, n
      call writeIntsToChars( j, nCh )
      keyString = trim(key) // '(' // trim(adjustl(nCh)) // ')'
      call PutHashElement_str( keyList, hashList, keyString, array(j), &
        & countEmpty, inseparator, part_match )
    enddo

  end subroutine PutHashElement_strarray

  ! --------------------------------------------------  ReadIntsFromList  -----
  subroutine ReadIntsFromList ( inList, ints, error )
    ! Takes a list and reads it as an array of ints
    ! E.g., given '1 2 2 3 4 5'  returns (/ 1, 2, 2, 3, 4, 5 /)
    ! (Inverse of WriteIntsToList)
    !--------Argument--------!
    character (len=*), intent(in)      :: inList
    integer, dimension(:), intent(out) :: ints
    integer, optional, intent(out)     :: error
    ! Method:
    ! Use Fortran read
    integer :: status
    ints = -999
    status = 0
    if ( len_trim(inList) > 0 ) read(inList, *, iostat=status, err=100, end=100) ints
100   continue
    if ( present(error) ) error = status
  end subroutine ReadIntsFromList

  ! --------------------------------------------------  ReadNumsFromList  -----
  subroutine ReadDoubleArrayFromString ( inList, nums, separator, ignore, error )
    ! Takes a list and reads it as an array of floats
    ! E.g., given '6.32 0 9.05'  returns (/ 6.32, 0., 9.05 /)
    ! Ignores any non-numerical stuff found in ignore if you supply ignore
    !--------Argument--------!
    character (len=*), intent(in)                        :: inList
    double precision, dimension(:), intent(out)          :: nums
    integer, optional, intent(out)                       :: error
    character (len=*), optional, intent(in)              :: separator
    character (len=*), optional, intent(in)              :: ignore
    ! Method:
    ! (1) Turn list to an array
    ! (2) Read each array element separately into a float
    integer                                              :: nElems
    character(len=16), dimension(MAXSTRELEMENTLENGTH)    :: strArray
    !
    if ( present(error) ) error = 0
    call List2Array( inList, strArray, &
      & countEmpty=.false., inseparator=separator )
    nElems = FindLast ( strArray, ' ', reverse=.true. )
    if ( nElems < 1 ) then
      if ( present(error) ) error = -999
      return
    endif
    call readNumsFromChars( strArray(:nElems), nums(:nElems), ignore=ignore )
  end subroutine ReadDoubleArrayFromString

  subroutine ReadRealArrayFromString ( inList, nums, separator, ignore, error )
    ! Takes a list and reads it as an array of floats
    ! E.g., given '6.32 0 9.05'  returns (/ 6.32, 0., 9.05 /)
    ! Ignores any non-numerical stuff found in ignore if you supply ignore
    !--------Argument--------!
    character (len=*), intent(in)                        :: inList
    real, dimension(:), intent(out)                      :: nums
    integer, optional, intent(out)                       :: error
    character (len=*), optional, intent(in)              :: separator
    character (len=*), optional, intent(in)              :: ignore
    ! Method:
    ! (1) Turn list to an array
    ! (2) Read each array element separately into a float
    integer                                              :: nElems
    character(len=16), dimension(MAXSTRELEMENTLENGTH)    :: strArray
    !
    if ( present(error) ) error = 0
    call List2Array( inList, strArray, &
      & countEmpty=.false., inseparator=separator )
    nElems = FindLast ( strArray, ' ', reverse=.true. )
    if ( nElems < 1 ) then
      if ( present(error) ) error = -999
      return
    endif
    call readNumsFromChars( strArray(:nElems), nums(:nElems), ignore=ignore )
  end subroutine ReadRealArrayFromString

  ! --------------------------------------------------  RemoveElemFromList  -----
  subroutine RemoveElemFromList ( inList, outList, elem, inseparator, &
    & options )
    ! Takes a list and removes all occurrence(s) of elem
    ! E.g., given 'a,b,c,d,..,z' and asked to remove 'c' returns 'a,b,d,..z'
    !--------Argument--------!
    character (len=*), intent(in) :: inList
    character (len=*), intent(in) :: elem
    character (len=*), intent(out)                :: outList
    character (len=*), optional, intent(in)       :: inseparator
    character (len=*), optional, intent(in)       :: options
    ! Method:
    ! Prepend elem onto start of list, make it unique,
    ! then snip it back off
    !----------Local vars----------!
    logical :: myCountEmpty
    character(len=8) :: myOptions
    integer :: numUnique
    character(len=len(inList)+len(elem)+1) :: temp_list, unique_list
    character (len=1)               :: separator
    !----------Executable part----------!
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif
    myOptions = ' '
    if ( present(options) ) myOptions = options
    myCountEmpty = index( myOptions, 'e' ) > 0  ! .true.

    outList = inList
    if (len_trim(elem) < 1 .or. len_trim(inList) < 1 &
      & .or. StringElementNum(inList, elem, myCountEmpty, &
    & inseparator=inseparator) < 1 ) RETURN
    temp_list = trim(elem) // separator // trim(inList)
    call GetUniqueList( temp_list, unique_list, numUnique, &
    & inseparator=inseparator, ignoreLeadingSpaces=.true., options=options )
    ! outList = unique_list(len(elem)+1:)
    ! The following is evidence of poor programming habits
    ! (As if any more evidence was needed)
    if ( unique_list(len_trim(elem)+1:len_trim(elem)+1) == separator ) then
      outList = unique_list(len_trim(elem)+2:)
    else
      outList = unique_list(len_trim(elem)+1:)
    endif
  end subroutine RemoveElemFromList

  ! ---------------------------------------------  RemoveHashArray  -----
  subroutine RemoveHashArray( KEYLIST, HASHLIST, KEY, &
  & COUNTEMPTY, INSEPARATOR, PART_MATCH )
    ! We remove an array of values from a hash
    ! storing the array like this
    ! array "name" contains "value_1", "value_2" .. "nalue_n"
    !    key        value
    !    ---        -----
    ! "namen"        "n" (number of elements)
    ! "name(1)"   "value_1"
    ! "name(2)"   "value_2"
    !    .    .    .
    ! "name(n)"   "value_n"
    ! Dummy arguments
    character (len=*), intent(inout)              :: KEYLIST
    character (len=*), intent(inout)              :: HASHLIST
    character (len=*), intent(in)                 :: KEY
    logical, intent(in)                           :: COUNTEMPTY
    character (len=*), optional, intent(in)       :: INSEPARATOR
    logical, optional, intent(in)                 :: PART_MATCH

    ! Local variables
    integer                                       :: j
    character (len=16)                            :: keyString
    integer                                       :: n
    character (len=8)                             :: nCh
    character (len=1)                             :: separator

    ! Executable code

    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif
    
    keyString = trim(key) // 'n'
    call GetHashElement_str( keyList, hashList, keyString, nCh, &
      & countEmpty, inseparator, part_match )
    if ( nCh == separator ) return
    call readIntsFromChars( nCh, n )
    call RemoveHashElement_str( keyList, hashList, keyString, &
      & countEmpty, inseparator, part_match )
    do j=1, n
      call writeIntsToChars( j, nCh )
      keyString = trim(key) // '(' // trim(adjustl(nCh)) // ')'
      call RemoveHashElement_str( keyList, hashList, keyString, &
        & countEmpty, inseparator, part_match )
    enddo

  end subroutine RemoveHashArray

  ! ---------------------------------------------  RemoveHashElement  -----

  ! This subroutine removes the key and corresponding value from a hash
  ! if key is not found among the keyList, it does nothing
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists

  ! if countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! if TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! See also SplitWords

  subroutine RemoveHashElement_str( keyList, hashList, key, &
  & countEmpty, inseparator, part_match )
    ! Dummy arguments
    character (len=*), intent(inout)          :: keyList
    character (len=*), intent(inout)          :: hashList
    character (len=*), intent(in)             :: key
    logical, intent(in)                       :: countEmpty
    character (len=*), optional, intent(in)   :: inseparator
    logical, optional, intent(in)             :: part_match

    ! Local variables
    integer                                    :: num
    character(len=len(keyList)+1)              :: keys
    character(len=len(hashList)+1)             :: hash

    ! Executable code
    num = StringElementNum( keyList, key, countEmpty, inseparator, part_match )
    if( num > 0) then
      call RemoveNumFromList( keyList, keys, num, inseparator )
      call RemoveNumFromList( hashList, hash, num, inseparator )
      keyList = keys
      hashList = hash
    endif

  end subroutine RemoveHashElement_str

  ! ------------------------------------------------  RemoveListFromList  -----
  subroutine RemoveListFromList ( inList, outList, exclude, &
    & inseparator, options )
    ! Takes one list and removes from it all occurrence(s) 
    ! of each elem in another list called "exclude"
    ! E.g., given 'a,b,c,d,..,z' and asked to remove 'c,a' returns 'b,d,..z'
    !--------Argument--------!
    character (len=*), intent(in) :: inList
    character (len=*), intent(in) :: exclude ! What to exclude
    character (len=*), intent(out)                :: outList
    character (len=*), optional, intent(in)       :: inseparator
    character (len=*), optional, intent(in)       :: options
    ! Method:
    ! Repeatedly call RemoveElemFromList for each elem of exclude
    !----------Local vars----------!
    integer :: i
    character(len=max(len(inList), len(exclude)) + 1) :: elem
    logical :: myCountEmpty
    character(len=8) :: myOptions
    integer :: numElems
    character(len=len(inList)+1) :: temp_list
    character(len=len(inList)+1) :: temp_list2
    logical :: verbose
    !----------Executable part----------!
    myOptions = ' '
    if ( present(options) ) myOptions = options
    myCountEmpty = index( myOptions, 'e' ) > 0  ! .true.
    verbose = index( myOptions, 'v' ) > 0  ! .true.
    ! if ( present(countEmpty) ) myCountEmpty = countEmpty
    outList = inList
    if ( len_trim(exclude) < 1 .or. len_trim(inList) < 1 ) return
    numElems = NumStringElements( exclude, myCountEmpty, inseparator )
    if ( verbose ) print *, 'numElems in exclude ', numElems
    if ( numElems < 1 ) return
    temp_list = inList
    do i=1, numElems
      call GetStringElement( exclude, elem, i, myCountEmpty, inseparator )
      call RemoveElemFromList( temp_list, temp_list2, elem, &
        & inseparator, options )
      if ( verbose ) then
        print *, 'After excluding ' // trim(elem)
        print *, 'list was ' // trim(temp_list)
        print *, 'now ' // trim(temp_list2)
      endif
      temp_list = temp_list2
    enddo
    outList = temp_list
  end subroutine RemoveListFromList

  ! --------------------------------------------------  RemoveNumFromList  -----
  subroutine RemoveNumFromList ( inList, outList, nElement, inseparator, &
    & options )
    ! Removes a numbered element from a list
    ! E.g., given 'a,b,c,d,..,z' and asked to remove number 3 returns 'a,b,d,..z'
    !--------Argument--------!
    character (len=*), intent(in) :: inlist
    integer          , intent(in) :: nElement
    character (len=*), intent(out)                :: outList
    character (len=*), optional, intent(in)       :: inseparator
    character (len=*), optional, intent(in)       :: options
    ! Method:
    ! Loop through list, forming new one
    !----------Local vars----------!
    character(len=len(inList)+1) :: elem
    integer :: i
    logical :: myCountEmpty
    character(len=8) :: myOptions
    integer :: num
    !----------Executable part----------!
    myOptions = ' '
    if ( present(options) ) myOptions = options
    myCountEmpty = index( myOptions, 'e' ) > 0  ! .true.

    outList = inList
    if ( len_trim(inList) < 1 .or. nElement < 1 ) return
    num = NumStringElements( inList, myCountEmpty, inSeparator=inSeparator )
    if ( nElement < 1 .or. nElement > num ) return
    outList = ' '
    do i=1, num
      if ( i == nElement ) cycle
      call GetStringElement(inList, elem, i, &
        & myCountEmpty, inSeparator=inSeparator )
      outList = CatLists( outList, trim(elem), inseparator )
    enddo
  end subroutine RemoveNumFromList

  ! --------------------------------------------------  RemoveOption  -----
  subroutine RemoveOption( inOptions, outOptions, option, &
    & pattern, delims )
    ! Args
    character(len=*), intent(in)              :: inOptions
    character(len=*), intent(in)              :: option
    character(len=*), intent(out)             :: outOptions
    integer, optional, intent(in)             :: pattern
    character (len=1), dimension(2), optional, &
     & intent(in)                             :: delims
    ! Internal variables
    integer :: bloc
    logical, parameter :: COUNTEMPTY = .true.
    character (len=len(inOptions))             :: listBloc ! space-separated
    integer :: j
    integer :: myPattern
    integer :: numDashes
    ! Executable
    outOptions = inOptions
    if ( len_trim(option) < 1 ) return
    outOptions = ' '
    myPattern = 0
    if ( present(pattern) ) then
      if ( any(Pattern == (/0, 1, 2, 3, 4 /)) &  ! accept legal values only
        & ) myPattern = pattern
    endif
    if ( option(1:2) == '--' ) then
      numDashes = 2
    elseif ( option(1:1) == '-' ) then
      numDashes = 1
    else
      numDashes = 0
    endif
    select case (myPattern)
    case ( 0,1 )
      ! '-ab[arg] --xyz=arg
      ! '-a -b arg --xyz=arg'
      do bloc = 1, NumStringElements( inOptions, countEmpty, inseparator=' ' )
        listBloc = StringElement( inOptions, bloc, countEmpty, inseparator=' ' )
        ! does this block begin with one "-" or two?
        if ( numDashes == 2 .and. listBloc(1:2) == '--' ) then
          if ( listBloc == option ) listBloc = ' '
        elseif ( listBloc(1:2) == '--' ) then
          ! no match
        elseif ( numDashes == 1 .and. listBloc(1:1) == '-' ) then
          j = index( listBloc, option(2:2) )
          listBloc = listBloc(1:j-1) // listBloc(j+1:)
        endif
        outOptions = trim(outOptions) // ' ' // listBloc
      enddo
    case ( 2, 3 )
      ! '-a -b arg -xyz arg' or
      ! '-a -b arg --xyz arg'
      print *, 'Sorry--unable to remove option for pattern ', myPattern
      stop
    case ( 4 )
      ! '-a -barg --xyz arg'
      print *, 'Sorry--unable to remove option for pattern ', myPattern
      stop
    case default
      print *, 'Sorry--unable to remove option for pattern ', myPattern
      stop
    end select
  end subroutine RemoveOption

  ! --------------------------------------------------  RemoveSwitchFromList  -----
  subroutine RemoveSwitchFromList( inSwitches, outSwitches, switch, &
    & inseparator, options )
    ! Args
    character(len=*), intent(in)              :: inSwitches
    character(len=*), intent(in)              :: switch
    character(len=*), intent(out)             :: outSwitches
    character (len=*), optional, intent(in)   :: inseparator
    character (len=*), optional, intent(in)   :: options
    ! Internal variables
    integer :: i, n, details
    logical :: countEmpty
    character(len=len(inSwitches)) :: aSwitch, bareSwitch
    character(len=8) :: myOptions
    ! Executable
    myOptions = ' '
    if ( present(options) ) myOptions = options
    CountEmpty = index( myOptions, 'e' ) > 0  ! .true.
    outSwitches = ' '
    n = NumStringElements( inSwitches, countEmpty )
    if ( n < 1 ) return
    do i=1, n
      call GetStringElement( trim(inSwitches), aSwitch, i, countEmpty )
      call SplitDetails( aSwitch, bareSwitch, details )
      if ( .not. streq( Switch, bareSwitch, '-f' ) ) &
        & outSwitches = CatLists( outSwitches, aSwitch )
    enddo
  end subroutine RemoveSwitchFromList

  ! --------------------------------------------------  ReplaceSubString  -----
  subroutine ReplaceSubString (str, outstr, sub1, sub2, which, no_trim)
    ! Takes a string and replaces occurrence(s) of sub1 with sub2
    ! Defaults to replacing only the first
    ! But if which == 'all' replaces all
    ! or if which == 'last' replaces last
    ! Note that, depending on no_trim, 'all' does the following:
    ! (a) if no_trim == TRUE, multiple passes (up to 100) until no
    !     further replacements are possible
    !     ( which could be bad; e.g., if sub1 is 'sub1' and sub2 is 'sub11'
    !     then (blah)sub1(blah)sub1..' becomes '(blah)sub1111...' )
    ! (b) if no_trim is FALSE or missing, a single pass after chopping
    !     the string up into separate sub1-containing pieces
    !     ( e.g., '(blah)sub1(blah)sub1(blah)..' becomes
    !      '(blah)sub2(blah)sub2(blah)..' )
    !  
    ! Will this still work if sub1 has leading or trailing blanks? 
    ! How about sub2?
    ! do we need an optional arg, no_trim, say, that will leave them?
    ! Tried coding it, but can't say for sure it works
    !--------Argument--------!
    character (len=*), intent(in) :: str
    character (len=*), intent(in) :: sub1
    character (len=*), intent(in) :: sub2
    character (len=*) :: outstr
    character (len=*), intent(in), optional :: which
    logical, intent(in), optional :: no_trim

    !----------Local vars----------!
    integer, parameter         :: MAXREPLACEMENTS = 100
    integer :: i, array_size
    character (len=5) :: my_which
    character(len=max(len(str), len(outstr))) :: head
    character(len=max(len(str), len(outstr))) :: tail
    character(len=max(len(str), len(outstr))) :: sub_str
    character(len=max(len(str), len(outstr))), dimension(MAXREPLACEMENTS) &
      &                                      :: str_array
    logical :: my_no_trim
    !----------Executable part----------!
    head = ''
    tail = ''
    sub_str = ''
    outstr = str
    if (len_trim(str) < 1 .or. len_trim(sub1) < 1) RETURN
    my_which = 'first'
    if ( present(which) ) my_which = lowercase(which)
    my_no_trim = .false.
    if ( present(no_trim) ) my_no_trim = no_trim

    select case (my_no_trim)
    case (.false.)
      if ( index(str, trim(sub1)) < 1 ) return
      select case (my_which)
      case ('first')
        call Replace_me ( str, outstr, .false. )
      case ('last')
        call Replace_me ( str, outstr, .true. )
      case ('all')
        outstr = ' '
        str_array = ' '
        call Split_me
        do i=1, array_size
          ! print *, i, ' ', trim(str_array(i))
          call Replace_me ( trim(str_array(i)), sub_str, .false. )
          outstr = adjustl( trim(outstr) // sub_str )
        enddo
      end select
    case (.true.)
      if ( index(str, sub1) < 1 ) return
      select case (my_which)
      case ('first')
        call Replace_me_no_trim ( str, outstr, .false. )
      case ('last')
        call Replace_me_no_trim ( str, outstr, .true. )
      case ('all')
        ! Originally, I despaired of solving this
        ! CALL MLSMessage(MLSMSG_Error, ModuleName, &
        ! & 'Unable to ReplaceSubStrings with which=all and no_trim=TRUE yet')
        ! then I had an idea: Why not reinterpret this as multiple passes?
        i = 0
        str_array(1) = str
        do
          i = i + 1
          ! print *, 'i ', i
          ! print *, 'str_array(1) ', str_array(1)
          call Replace_me_no_trim ( str_array(1), str_array(2), .false. )
          ! print *, 'str_array(2) ', str_array(2)
          if ( str_array(2) == str_array(1) .or. i > MAXREPLACEMENTS ) exit
          str_array(1) = str_array(2)
        enddo
        outstr = str_array(2)
      end select
    end select
    
    contains
      subroutine Replace_me ( the_orig, after_sub, back )
        ! This replaces an instance of sub1 with sub2 in
        ! the string the_orig
        ! Either the first instance (if back == FALSE) or the last
        ! Arguments
        character(len=*), intent(in)  :: the_orig
        character(len=*), intent(inout) :: after_sub
        logical, intent(in)           :: back
        ! Local variables
        integer :: istrt1, istrt2, ihead
        if ( index(the_orig, trim(sub1)) == 0 ) then
          after_sub = the_orig
          return
        endif
        istrt1 = index(the_orig, trim(sub1), back=back)
        istrt2 = istrt1 + len_trim(sub1)
        ihead = 1
        head = ' '
        tail = ' '
        if ( istrt1 > 1 ) then
          head = the_orig(1:istrt1-1)
          ihead = istrt1 - 1
        endif
        if ( istrt2 < len_trim(the_orig)+1 ) then
          tail = the_orig(istrt2:)
        endif
        ! print *, 'len(after_sub): ', len(after_sub)
        ! print *, 'len(head): ', len(head)
        ! print *, 'len(tail): ', len(tail)
        ! print *, 'head: ', trim(head), '  ihead: ', ihead
        ! print *, 'tail: ', trim(tail), len_trim(tail)
        ! print *, 'sub1: ', trim(sub1), len_trim(sub1)
        ! print *, 'sub2: ', trim(sub2), len_trim(sub2)
        if ( sub2 /= ' ' ) then
          after_sub = adjustl(head(1:ihead) // trim(sub2) // trim(tail))
        else
          after_sub = adjustl(head(1:ihead) // trim(tail))
        endif
      end subroutine Replace_me
      subroutine Replace_me_no_trim ( the_orig, after_sub, back )
        ! This replaces an instance of sub1 with sub2 in
        ! the string the_orig -- w/o trimming leading or trailing blanks
        ! Either the first instance (if back == FALSE) or the last
        ! Arguments
        character(len=*), intent(in)  :: the_orig
        character(len=*), intent(inout) :: after_sub
        logical, intent(in)           :: back
        ! Local variables
        integer :: istrt1, istrt2, ihead
        if ( index(the_orig, sub1) == 0 ) then
          after_sub = the_orig
          return
        endif
        istrt1 = index(the_orig, sub1, back=back)
        istrt2 = istrt1 + len(sub1)
        ihead = 0
        head = ' '
        tail = ' '
        if ( istrt1 > 1 ) then
          head = the_orig(1:istrt1-1)
          ihead = istrt1 - 1
        endif
        if ( istrt2 < len(the_orig)+1 ) then
          tail = the_orig(istrt2:)
        endif
        ! Now all the possibilities:
        ! (1) the_orig = sub1
        if ( ihead == 0 .and. istrt2 > len(the_orig) ) then
          after_sub = sub2
        ! (2) the_orig = (head)sub1
        elseif ( istrt2 > len(the_orig) ) then
          after_sub = head(1:ihead) // sub2
        ! (3) the_orig = sub1(tail)
        elseif ( ihead == 0 ) then
          after_sub = sub2 // tail
        ! (4) the_orig = (head)sub1(tail)
        else
          after_sub = head(1:ihead) // sub2 // tail
        endif
      end subroutine Replace_me_no_trim
      subroutine Split_me
        ! Will this still work if some of the str_arrays end in one or more ' '?
        ! Arguments (none)
        ! Local variables
        integer :: istrt1, istrt2
        array_size = 0
        istrt2 = 0
        do
          if ( istrt2 > len_trim(str) - 1 ) return
          if ( index(str(istrt2+1:), trim(sub1)) < 1 ) then
            array_size = min(array_size+1, MAXREPLACEMENTS)
            str_array(array_size) = str(istrt2+1:)
            return
          endif
          istrt1 = istrt2 + index(str(istrt2+1:), trim(sub1))
          array_size = min(array_size+1, MAXREPLACEMENTS)
          str_array(array_size) = str(istrt2+1:istrt1 + len_trim(sub1) - 1)
          istrt2 = istrt1 + len_trim(sub1) - 1
        enddo
      end subroutine Split_me
  end subroutine ReplaceSubString

  ! --------------------------------------------------  ReverseList  -----
  function ReverseList (str, inseparator) RESULT (outstr)
    ! takes a string list, usually comma-separated,
    ! and returns one with elements in reversed order

    ! E.g., given "alpha, beta, gamma" => "gamma, beta, alpha"

    ! Limitation:
    ! No element may be longer than MAXWORDLENGTH
    !--------Argument--------!
    character (len=*), intent(in) :: str
    character (len=len(str)) :: outstr
    character (len=*), optional, intent(in)       :: inseparator

    !----------Local vars----------!
    integer :: i, istr, irev, elem, iBuf
    integer, parameter :: MAXWORDLENGTH=80
    character (len=1)               :: separator
    character (len=1), dimension(:), allocatable :: charBuf
    character (len=MAXWORDLENGTH) :: word
! Treat consecutive separators as if enclosing an empty element
    logical, parameter :: countEmpty = .TRUE.    

    !----------Executable part----------!
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif

!  Special case--only one element of str
    outstr = str
    if(len(str) == 1 .OR. INDEX(str, separator) == 0) RETURN
 
! General case
    ALLOCATE(charBuf(len(str)+1), STAT=istr)
    if (istr /= 0) then
      CALL PrintMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"charBuf")
      RETURN
    endif

    outstr = ' '

! Loop over elements
    elem = 1
    iBuf=0
    do
      CALL GetStringElement(str, word, elem, countEmpty, separator)
        if(word == separator) then
          EXIT
        elseif(iBuf > len(str)) then
          EXIT
        else
          istr = MAX(len_TRIM(word), 1)
          word = Reverse(word(:istr))
        do i=1, istr
          iBuf=iBuf+1
          charBuf(iBuf) = word(i:i)
        enddo
        iBuf=iBuf+1
        charBuf(iBuf) = separator
        elem = elem+1
      endif
    enddo

    if(charBuf(iBuf) == separator) then
      iBuf = iBuf-1
    endif

    do i=1, iBuf
      irev = iBuf - i + 1
      outstr(irev:irev) = charBuf(i)
    enddo

    deallocate (charBuf)

  end function ReverseList

  ! --------------------------------------------------  ReverseStrings  -----
  subroutine ReverseStrings (str, reverse)
    ! takes an arrays of strings
    ! and returns one with elements in reversed order

    ! E.g., given (/"alpha", "beta", "gamma"/) => (/"gamma", "beta", "alpha"/)

    !--------Argument--------!
    character (len=*), dimension(:), intent(in)  :: str
    character (len=*), dimension(:), intent(out) :: reverse

    !----------Local vars----------!
    integer :: i, n
    ! Executable
    reverse = str
    n = min( size(str), size(reverse) )
    if ( n < 2 ) return
    do i=1, n
      reverse( n - i + 1 ) = str(i)
    enddo
  end subroutine ReverseStrings

  ! --------------------------------------------------  SnipList  -----
  function SnipList (str, elem, inseparator) RESULT (outstr)
    ! takes a string list, usually comma-separated,
    ! and returns one with elem removed

    ! E.g., given 
    ! str = "alpha, beta, gamma" and elem = 'gamma' => "alpha, beta"

    ! Limitation:
    ! No element may be longer than MAXWORDLENGTH
    !--------Argument--------!
    character (len=*), intent(in) :: str
    character (len=*), intent(in) :: elem
    character (len=len(str)) :: outstr
    character (len=*), optional, intent(in)       :: inseparator

    !----------Local vars----------!
    !----------Executable part----------!
!  Special case--elem not in str
    outstr = str
    if ( len_trim(elem) < 1 ) return
    if ( index(str, trim(elem) ) < 1 )  return
 
! General case
    call RemoveElemFromList( str, outstr, elem, inseparator )

  end function SnipList

  ! ---------------------------------------------  SortArray  -----

  ! This subroutine takes an array of strings
  ! and returns the array of ordered integers
  ! sorting the array; i.e., if ss[n] is the sub-string which is
  ! the n'th element, and ia[k] is the k'th element of the integer array
  ! then 
  !         {psl[ia[k]]=ss[k], k=1..n} 
  ! yields the properly sorted array
  ! (unless leftRight equals one of {"r", "R"} 
  ! in which case 
  !         {psl[k]=ss[ia[k]], k=1..n}
  ! does the job)
  ! Identical use of ia is how you would normally 
  ! sort any other arrays associated with ss
  
  ! The sorting is ordered by ascii collating sequence:
  ! "0" < "9" < "A" < "Z" < "a" < "z"
  ! unless caseSensitive is FALSE, when "0" < "9" < "A" < "a" < "Z" < "z"

  ! As an optional arg the properly sorted array is returned, too.
  ! You may safely supply the same arg for both inStrArray and sortedArray
  
  ! The optional arg options may be used to set
  ! options contains           meaning
  ! ----------------           -------
  !        c                   case insensitive
  !        s                   shorter first
  !        r                   reverse the sorting order (of both returned arrays)
  !        S                   sort as if switches
  !        L                   LeftRight is "L" (default)
  !        R                   LeftRight is "R"
  ! if the shorterFirst is TRUE, the sorting is modified
  ! so that shorter strings come first
  ! e.g., (/'abc', 'st', 'Z', '1'/) -> (/'1', 'Z', 'st', 'abc'/)
  
  ! if shorterFirst, leading spaces are always ignored
  ! otherwise they are always significant
  ! (See SortList for contrasting treatment options)
  !  (if you want them ignored, it's easy enough: create a tempArray
  !     tempArray(1:N) = adjustl(strArray(1:N))
  !   and pass it in instead)
  
  ! "Sort as if switches" is an explanation staggering in its failure
  ! to explain. What we do is to Replace each ' ' with achar(127) which
  ! has the effect of moving shorter strings from the head of the line 
  ! to the back of the line; 
  ! e.g., 'switch4' would be sorted ahead of 'sort' instead of behind it

  ! Method:
  ! The older method was removed--instead we rely on sortp which now
  ! can sort characters, too.
  
  ! Is the distinction between 'L' and 'R' sufficiently intuitive? 
  ! 'L' means that the ia[k] appears on the Left-hand side of '='
  ! 'R' means that the ia[k] appears on the Right
  subroutine SortArray( inStrArray, outIntArray, &
    & sortedArray, options )
    ! Dummy arguments
    character (len=*), dimension(:), intent(in)   :: instrarray
    integer, dimension(:), intent(out)            :: outintarray
    character (len=*), optional, intent(in)       :: options
    character (len=*), dimension(:), optional, intent(out)  &
     &                                            :: sortedarray

    ! Local variables
    logical                                :: casesensitive
    logical, parameter                     :: DeeBUG = .false.
    integer                                :: elem, nElems
    character(len=1)                       :: LeftRight
    logical                                :: reverse
    logical                                :: shorterfirst
    logical                                :: switchable
    integer, dimension(:), allocatable     :: invBinNumber 
    integer                                :: maxStrPos
    character (len=16)                     :: myOptions  
    ! integer, dimension(size(outintarray))  :: originalintarray
    integer                                :: status
    character (len=len(inStrArray)), dimension(:), allocatable    &
      &                                    :: stringArray
    character (len=len(inStrArray))        :: theString  

    ! Executable code
    myOptions = ' '
    if ( present(options) ) myOptions = options
    caseSensitive = index(myOptions, 'c' ) == 0
    reverse = index(myOptions, 'r' ) > 0
    shorterFirst = index(myOptions, 's' ) > 0
    switchable = index(myOptions, 'S' ) > 0
    leftRight = 'L'
    if ( index(myOptions, 'R' ) > 0 ) leftRight = 'R'

    nElems = size(inStrArray)
    if ( size(outIntArray) <= 0 .or. nElems <= 0 ) then
      return
    endif
    allocate (stringArray(nElems), &
     & invBinNumber(nElems), &
     & STAT=status)
    if (status /= 0) CALL PrintMessage(MLSMSG_Error, ModuleName, &
         & MLSMSG_Allocate//"stringArray, etc. in SortArray")
    outIntArray = 0
    maxStrPos = 1                ! This will hold max string LENGTH needed
    do elem = 1, nElems    
      outIntArray(elem) = 1
      if ( ShorterFirst ) then
        maxStrPos = max(maxStrPos, len_trim(adjustl(inStrArray(elem))))
      else
        maxStrPos = max(maxStrPos, len_trim(inStrArray(elem)))
      endif
    enddo                  
    if ( DEEBUG ) then
      do elem = 1, nElems    
        print *, 'Array element ', elem, ' ', trim(inStrArray(elem))
      enddo                  
    endif
    do elem = 1, nElems
      if ( Switchable ) then
        stringArray(elem) = Replace( inStrArray(elem), ' ', achar(127) )
      else
        stringArray(elem) = inStrArray(elem)
      endif
      if ( shorterFirst ) then
        ! Trickery alert!
        ! This causes shorter strings to have more leading spaces
        ! and therefore come up first when sorted
        ! (which is why we always ignore leading spaces in inStrArray)
        theString = adjustl(stringArray(elem))
        stringArray(elem) = adjustr(theString(1:maxStrPos))
      endif
    enddo
    ! Are we case-sensitive?
    if ( .not. caseSensitive ) then
      stringArray = lowercase( stringArray )
    endif

    ! Now we let asortp do the work
    call sortp( stringArray, 1, nElems, outIntArray ) ! This is OriginalIntArray
    ! Now the outIntArray is inversely related to the OriginalIntArray:
    ! (1) stringArray(OriginalIntArray(i)) = inStrArray(i)
    ! (2) stringArray(i) = inStrArray(outIntArray(i))
    ! So: inStrArray(outIntArray(OriginalIntArray(i))) =
    ! stringArray(OriginalIntArray(i)) = inStrArray(i)
    ! Or outIntArray(OriginalIntArray(i)) = i
    ! do elem = 1, nElems  
    !   outIntArray(OriginalIntArray(elem)) = elem
    ! enddo

    ! Were we asked to reverse the sorting order?
    if ( reverse ) then
      invBinNumber = outIntArray
      outIntArray = invBinNumber( NElems:1:-1 )
    endif
    
    ! Were we asked to return the sorted array, too?
    if ( present(sortedArray) ) sortedArray = inStrArray( outIntArray )
    
    ! What about left-right inversion?
    if ( LeftRight == 'L' ) then
      ! Need to 'invert' outIntArray
      invBinNumber = outIntArray
      do elem=1, nElems
        outIntArray(invBinNumber(elem)) = elem
      enddo
    endif
    deallocate (stringArray, invBinNumber, &
     & STAT=status)
    if (status /= 0) CALL PrintMessage(MLSMSG_Error, ModuleName, &
         & MLSMSG_DeAllocate//"stringArray, etc. in SortArray")

  end subroutine SortArray

  ! ---------------------------------------------  SortList  -----

  ! This subroutine takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements and returns the array of ordered integers
  ! sorting the list; i.e., if ss[n] is the sub-string which is
  ! the n'th element, and ia[k] is the k'th element of the integer array
  ! then {psl[ia[k]]=ss[k], k=1..n} yields the properly sorted list
  ! (unless the further optional arg leftRight is also supplied and equals
  ! one of {"r", "R"} in which case {psl[k]=ss[ia[k]], k=1..n})
  ! Parallel use of ia is how you would normally 
  ! sort any other arrays associated with ss
  
  ! The sorting is ordered by ascii collating sequence:
  ! "0" < "9" < "A" < "Z" < "a" < "z"
  ! unless caseSensitive is FALSE, when "0" < "9" < "A" < "a" < "Z" < "z"

  ! if countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! if TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the properly sorted list is returned, too
  ! You may safely supply the same arg for both inList and sortedList
  ! As an optional arg the separator may supplied, in case it isn't comma
  ! if the optional arg ignoreLeadingSpaces is TRUE, "a, b, c" is
  ! sorted like "a,b,c"; otherwise the leading spaces make" b, c,a"

  ! Meaning of options:
  ! (see SortArray)

  ! Method:
  ! (see SortArray)
  subroutine SortList( inList, outArray, inseparator, sortedList, options )
    ! Dummy arguments
    character (len=*), intent(in)                 :: inList
    integer, dimension(:), intent(out)            :: outArray
    character (len=*), optional, intent(in)       :: inseparator
    character (len=*), optional, intent(out)      :: sortedList
    character (len=*), optional, intent(in)       :: options

    ! Local variables
    logical                                       :: countEmpty
    logical                                       :: IgnoreLeadingSpaces
    character(len=1)                              :: LeftRight
    character (len=16)                            :: myOptions  
    integer :: nElems, status, Longestlen

    character (len=1)               :: separator
    character (len=MAXSTRELEMENTLENGTH), dimension(:), allocatable    &
      &                             :: stringArray
    logical, parameter              :: DeeBUG = .false.
    ! Executable code
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif
    myOptions = ' '
    if ( present(options) ) myOptions = options
    countEmpty = index(myOptions, 'e' ) /= 0
    IgnoreLeadingSpaces = index(myOptions, 'f' ) /= 0
    leftRight = 'L'
    if ( index(lowercase(myOptions), 'r' ) > 0 ) leftRight = 'R'

    if ( DEEBUG ) then
       print *, 'Entered SortList'
       print *, 'present(inseparator)?: ', present(inseparator)
       print *, 'separator: ', separator
       print *, 'string: ', trim(inList)
    endif
    if ( size(outArray) <= 0 ) return
    outArray = 0
    nElems = NumStringElements(inList, countEmpty, inseparator, Longestlen)
    if ( nElems <= 0 ) then
      return
    elseif ( Longestlen > MAXSTRELEMENTLENGTH ) then
      call PrintMessage(MLSMSG_Error, ModuleName, &
         & "Element LENGTH too long in SortList")
      return
    endif
    allocate (stringArray(nElems), STAT=status)
    if (status /= 0) CALL PrintMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"stringArray in SortList")
    call list2Array( inList, stringArray, countEmpty, inseparator, &
     & IgnoreLeadingSpaces )
    call SortArray( stringArray(1:nElems), outArray, options=options )
    if ( present(sortedList) ) then
      if ( LeftRight == 'R' ) then
        call Array2List(stringArray(1:nElems), sortedList, &
         & inseparator, outArray, leftRight='R')
      else
        call Array2List(stringArray(1:nElems), sortedList, &
         & inseparator, outArray, leftRight='L')
      endif
    endif
    deallocate (stringArray)

  end subroutine SortList

  ! ---------------------------------------------  StringElement  -----

  ! This function takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements and returns the
  ! sub-string which is the n'th element
  ! if n is too large or small, it returns blank
  ! See also GetStringElement 
  ! (which however returns separator if n too large or small)

  function StringElement(inList, nElement, countEmpty, inseparator) &
    & result(outElement)
    ! Dummy arguments
    character (len=*), intent(in)   :: inList
    integer, intent(in)         :: nElement  ! Entry number to return
    logical, intent(in)   :: countEmpty
    character (len=*), optional, intent(in)       :: inseparator
    character (len=len(inList))  :: outElement

    ! Local variables
    character (len=1)               :: separator

    ! Executable code
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif
    call GetStringElement(inList, outElement, nElement, countEmpty, inseparator)
    if ( outElement == separator ) outElement = ' '
  end function StringElement

  ! ---------------------------------------------  StringElementNum  -----

  ! This function takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements, and a test string which may be an element
  ! It returns the element number of the test string in the string list
  ! or, 0 if the test string is not found
  
  ! Any leading blanks are disregarded before making the comparison;
  ! e.g., 'stare' is the same as ' stare' and is the second element of 
  ! the list 'lex, stare, decisis'
  
  ! Note: if there are multiple matches between the test string and elements
  ! of inList we return only the first
  
  ! if you want the last instead, use ReverseList on inList && subtract
  ! the answer from nElements
  
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists
  
  ! It will be the immediate precursor function in a hash table
  ! == aka associative array == aka dictionary
  !
  ! if countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE  

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! Another optional arg, part_match, returns the number of the 
  ! first element merely found in the test string; e.g.
  ! 'won, to, tree' and test 'protocol.dat' returns 2

  ! See also GetStringElement, NumStringElements

  function StringElementNum(inList, test_string, countEmpty, &
    & inseparator, part_match) result (elem)
    ! Dummy arguments
    character (len=*), intent(in)             :: inList
    character (len=*), intent(in)             :: test_string
    logical, intent(in)                       :: countEmpty
    integer                                   :: elem
    character (len=*), optional, intent(in)   :: inseparator
    logical, optional, intent(in)             :: part_match

    ! Local variables
    integer :: nElements

    character (len=MAXELEMENTLENGTH)           :: listElement
    logical ::                                    match
    ! Executable code

    nElements = NumStringElements(inList, countEmpty, inseparator)

    if(nElements <= 0) then
      elem = 0
      RETURN
    endif
    match = .false.
    if ( present(part_match) ) match = part_match

    ! Check for matches--snipping off any leading blanks
    do elem=1, nElements
      CALL GetStringElement(inList, listElement, elem, countEmpty, inseparator)
      if ( match ) then
        if (trim(listElement) /= ' ' .and. &
          & index(trim(test_string), trim(listElement)) > 0) RETURN
      else
        if(adjustl(listElement) == adjustl(test_string)) RETURN
      endif
    enddo

    elem = 0

  end function StringElementNum

  ! ---------------------------------------------  SwitchDetail  -----

  ! This function takes a (usually) comma-separated string list, interprets it
  ! as a list of individual switches, and a test switch
  ! It returns the greatest detail number of the test switch in the list
  ! or, -1 if it is not found
  
  ! As an example, say the list of switches is
  ! "abc,def,ghi2"
  ! and the test switch is "ghi"
  ! The returned value would be 2
  ! if the test switch were "abc" the returned value would be 0
  ! if the test switch were "xyz" the returned value would be -1
  ! if the test switch were "hi2" the returned value would be -1
  ! (because the start of test doesn't match the start of any list element)
  
  ! The behavior may be modified by options flag
  ! For which see comment above
  ! A special option is -R which restores an older behavior
  ! finding the Detail of the first matched string in Inlist
  ! instead of the current method which begins by sorting Inlist
  ! and then removing any duplicate switches.
  
  ! Note:
  ! By default, options automatically includes "f", for backwards compatibility
  ! If more than one switch matches the test_switch, the results are sorted
  ! and the highest match is returned.
  !   unless one of the options is "R" (see above)
  ! If the string list contains a "*" and one of the options is "w" then
  ! the test switch is automatically present
  
  function SwitchDetail( Inlist, Test_switch, Options ) result ( Detail )
    ! Dummy arguments
    character (len=*), intent(in)             :: Inlist
    character (len=*), intent(in)             :: Test_switch
    character (len=*), intent(in), optional   :: Options
    integer                                   :: Detail

    ! Local variables
    logical, parameter                        :: COUNTEMPTY = .true.
    logical                                   :: back     
    logical                                   :: dontsort 
    integer                                   :: elem     
    integer, dimension(MaxNumSwitches)        :: iarray
    integer                                   :: k   
    character (len=MAXELEMENTLENGTH)          :: listElement
    character(len=8)                          :: myOptions
    integer                                   :: nElements
    integer                                   :: startOfDetails  ! index where 
    character (len=len(test_switch)+2)        :: switch          ! the detail number 
    character (len=len(Inlist)+2)             :: Switches        ! would start
    character (len=len(Inlist)+2)             :: tempSwitches

    ! Executable code
    myOptions = '-f'
    if ( present(options) ) myOptions = trim(lowercase(options))
    detail = -1
    
    ! May return immediately under special circumstances
    ! Are either blank?
    if ( len_trim(InList) < 1 .or. len_trim(test_switch) < 1 ) return
    ! Can we tell by 1st that principles the test_switch isn't there?
    ! 1st principles means
    ! (a) no wild cards
    ! (b) comma-separated InList
    ! (c) ',switch' not found in ',switch1,switch2,..,switchn'
    if ( index(MyOptions, '*') < 1 ) then
      if ( index(MyOptions, 'c') < 1 ) then
        tempSwitches = ',' // CompressString(InList)
        switch = ',' // test_switch
      else
        tempSwitches = ',' // CompressString(lowercase(InList))
        switch = ',' // lowercase(test_switch)
      endif
      k = index(tempSwitches, trim(switch))
      if ( k < 1 ) return
      
      ! Another short cut
      ! Available only if the switch does not appear more than once
      ! because, if it did, we would want to detect its highest Detail
      ! So, if switch appears only once, then index will always return the same
      ! k value, both when back is TRUE or FALSE
      if ( index(tempSwitches, trim(switch), back=.true.) == k ) then
        ! (d) now check if ',switch,' found in ',switch1,switch2,..,switchn,'
        tempSwitches = trim(tempSwitches) // ','
        switch = trim(switch) // ','
        if ( index(tempSwitches, trim(switch)) > 0 ) then
          ! The ',switch,' is present; 
          ! the Detail has been left unspecified, which defaults to 0
          Detail = 0
          return
        endif
      endif
    endif

    nElements = NumStringElements(inList, countEmpty)

    if ( nElements <= 0 ) Return

    back = ( index(myOptions, 'b') > 0 ) 
    if ( index(myOptions, 'c') > 0 ) then
      switch = lowercase(test_switch)
    else
      switch = test_switch
    endif
    if ( index(myOptions, 'f') > 0 ) switch = adjustl(switch)
    dontsort = ( index(myOptions, 'R') > 0 )
    if ( dontsort ) then
      Switches = InList
    else
    ! Now we want to keep only the switch with the highest details level
    ! Sort the switches to pick out the highest detail
    ! if multiple matches are found
      call sortList( CompressString(InList), iarray, ',', switches )
      tempSwitches = switches
      call GetUniqueList( tempSwitches, Switches, nElements, &
            & ignoreLeadingSpaces=.true., options='-eSL' )
    endif

   ! Check for matches
    ! print *, 'switch:', trim(switch)
    do elem=1, nElements
      if ( back ) then
        call GetStringElement( Switches, listElement, nElements-elem+1, countEmpty )
      else
        call GetStringElement( Switches, listElement, elem, countEmpty )
      endif
      if ( index(myOptions, 'c') > 0 ) listElement = lowercase(listElement)
      if ( index(myOptions, 'f') > 0 ) listElement = adjustl(listElement)
      ! print *, 'element:', trim(listElement)
      if ( trim(listElement) /= ' ' .and. &
          & index(trim(listElement), trim(switch)) == 1 ) then
        startOfDetails = len_trim( switch ) + 1
        if ( startOfDetails > len_trim( listElement ) ) then
          detail = 0
          exit
        endif
        ! To prevent false matches, like "walk" being matched by "walker"
        if ( isAlphabet( listElement(startOfDetails:startOfDetails) ) ) cycle
        ! Because we have sometimes allowed a "?" to be a switch
        ! (Perhaps too permissive of us)
        call ReadIntsFromChars( trim(listElement(startOfDetails:)), detail, &
          & ignore="*?")
        return
      endif
    enddo

    if ( index(myOptions, 'w') > 0 .and. index(inList, '*') > 0 ) &
     & detail = max(detail, 0)

  end function SwitchDetail

  ! ------------------------------------------------  unquote  -----
  function unquote( str, quotes, cquotes, options ) &
    & result ( outstr )
    ! function that removes a single pair of surrounding quotes from string

    ! E.g., given "Let me see." or 'Let me see.' returns
    !    Let me see.
    ! if no surrounding quotes are found, returns string unchanged; unless
    ! (1) mismatched quotes, e.g. 'Let me see." will:
    !     remove leading quote but leave trailing quote
    ! (2) a single unpaired quote found at beginning or end, will:
    !  (a) remove it if the resulting string is non-empty; or
    !  (b) return the single unpaired quote if that was the entire str
    
    ! optional arg options controls the following behaviors
    ! if options contains          meaning
    !    -----------               -------
    !         k                    strict
    !         p                    stripany
    !         r                    reverse
    !         x                    extract
    ! if strict, exceptions (1) and (2) above disregarded
    ! i.e., surrounding quotes must match, else returns string unchanged
    
    ! if stripany, any quotes, surrounding or internal,
    ! will be removed
    
    ! if extract, returns first substring surrounded by
    ! quotes; E.g., given ([a1 a2], [a3 a4]) with quotes='[' cquotes=']' returns
    !   a1 a2
    ! (This option supersedes stripany, and is automatically strict)
    
    ! if reverse, removes any quoted strings; 
    ! E.g., given 'b[a1 a2], c[a3 a4]' with quotes='[' cquotes=']' returns
    !   'b, c'
    ! (This option supersedes stripany, and is automatically strict)
    
    ! if given optional arg quotes, removes only surrounding pair:
    ! quotes[i:i] for each i=1..len[quotes]
    ! E.g., given /a\ regexp/ with quotes='/' returns
    !    a\ regexp
    
    ! if given optional args quotes & cquotes, removes only surrounding pair:
    ! quotes[i:i] on the left, cquotes[i:i] on the right, i=1..len[quotes]
    ! E.g., given [a particle] with quotes='[' cquotes=']' returns
    !    a particle
    ! (For this case, strict matching is always on)
    
    ! Useful because the parser will return quote-surrounded strings if that's
    ! how they appear in the lcf
    
    ! Calling get_string with "strip=.true." renders this unnecessary.
    ! However, you might find another use for it, especially with
    ! feature of being able to trim other, user-supplied detritus:
    ! e.g., braces, parentheses, extraneous separators
    
    ! (Aside from switches, we haven't found such a use so far;
    ! instead see more powerful ExtractSubString or ReplaceSubString)
    
    ! Note:
    ! (1) By default, if no quotes found returns input string unchanged unless
    !     extract=TRUE, in which case returns blank
    ! (2) if len(quotes) > 1, processes them in order quotes(i:i), i=1 2 ..
    !     unless extract=TRUE in which case returns after first one found
    ! (3) Perhaps extract=TRUE should be moved from here to ExtractSubString

    !--------Argument--------!
    character(len=*), intent(in) :: str
    character(len=len(str)) :: outstr
    character(len=*), intent(in), optional :: quotes
    character(len=*), intent(in), optional :: cquotes
    ! logical, intent(in), optional :: strict
    ! logical, intent(in), optional :: stripany
    ! logical, intent(in), optional :: extract
    character(len=*), intent(in), optional :: options
    !----------Local vars----------!
    character(len=len(str)) :: tmpstr
    character(len=1), parameter :: sq=''''
    character(len=1), parameter :: dq='"'
    integer :: first, last, ult, prim
    character(len=1) :: quote, cquote
    integer :: i
    logical :: mystrict
    logical :: mystripany
    logical :: myextract
    logical :: myreverse
    !----------Executable part----------!

   ult = len_trim(str)    ! Position of last non-blank char
   prim = ult - len_trim(adjustl(str)) + 1    ! Position of 1st non-blank char
   outstr=str
      
   ! LENGTH of non-blank portion of string to be trimmed must be at least 2
   if(ult-prim+1 <= 1) then
      outstr=str
      return
   endif

   myextract=.false.
   mystrict=.false.
   mystripany=.false.
   if(present(options)) then
      myextract = index(options, 'x') > 0
      mystrict = index(options, 'k') > 0
      mystripany = index(options, 'p') > 0
      myreverse = index(options, 'r') > 0
   endif
   
   mystripany = mystripany .and. (.not. myextract) .and. (.not. myreverse)
   
   ! These are initialized so that if no matching quotes found
   ! we will return    outstr = adjustl(str)
   first = prim
   last = ult

   ! trim surrounding user-supplied marks?

   if(present(quotes)) then
      if(len_trim(quotes) <= 0) then
       outstr=str
       return
      endif
      
      ! Loop over char class in string quotes
      do i=1, len_trim(quotes)
      
         quote = quotes(i:i)
         
         ! Stripany option in force?
         if ( mystripany ) then
            ! print *, 'Replacing ', quote, ' in ', trim(outstr)
            call ReplaceSubString(outstr, tmpstr, quote, '', 'all')
            outstr = tmpstr
            ! print *, trim(outstr)
            cycle
         endif

         ! Supplied with paired left and right quotes?
         if(present(cquotes)) then
            cquote=cquotes(i:i)
            mystrict=.true.
         else
            cquote=quote
         endif

        if(myreverse) then
          tmpstr = outstr
          call RemoveAnyQuotedStrings( tmpstr, outstr, quote, cquote )
          cycle
        endif
        if(myextract) then
          if ( index(str, quote) > 0 .and. index(str, cquote) > 0 ) then
            call ExtractSubString (str, outstr, quote, cquote)
            return
          endif
        elseif(mystrict) then
          if(str(prim:prim) == quote .and. str(ult:ult) == cquote) then
               outstr=str(prim+1:ult-1)
               return
          endif
      
        else
          if(str(prim:prim) == quote) then
           first=prim+1
          endif

          if(str(ult:ult) == cquote) then
             last=ult-1
          endif
        endif

      enddo
      if ( myreverse ) return

   ! Removing substring within quotes
   elseif(myreverse) then
     tmpstr = outstr
     call RemoveAnyQuotedStrings( tmpstr, outstr, sq, sq )
     tmpstr = outstr
     call RemoveAnyQuotedStrings( tmpstr, outstr, dq, dq )
     return

   ! Extracting substring within quotes
   elseif(myextract) then
     if ( index(str, sq) > 0 ) then
        call ExtractSubString (str, outstr, sq, sq)
     elseif ( index(str, dq) > 0 ) then
        call ExtractSubString (str, outstr, dq, dq)
     endif
     return

   ! insist surrounding marks match?
   elseif(mystrict) then
      if( &
      & str(prim:prim) == str(ult:ult) &
      & .and. &
        & (str(prim:prim) == sq .or. str(prim:prim) == dq) &
        & ) then
            outstr=str(prim+1:ult-1)
          else
            outstr=str
          endif
         return
      
   elseif(str(prim:prim) == sq) then
      first=prim+1
      if(str(ult:ult) == sq) then
         last=ult-1
      endif
      
   elseif(str(prim:prim) == dq) then
      first=prim+1
      if(str(ult:ult) == dq) then
         last=ult-1
      endif

   else
      first=prim
      if(str(ult:ult) == dq .or. str(ult:ult) == sq) then
         last=ult-1
      endif

   endif

   ! Still here?
   
   if ( myextract ) then
     outstr = ' '
       return
   elseif ( mystripany ) then
       return
   elseif(last >= first) then
       outstr=str(first:last)
   else
       outstr=str
   endif
      
  contains
    subroutine RemoveAnyQuotedStrings( str, out, q, cq )
      ! Args
      character(len=*), intent(in)  :: str
      character(len=*), intent(out) :: out
      character(len=1), intent(in)  :: q, cq
      ! Internal variables
      integer :: k1, k2
      character(len=len(str)) :: tmpstr
      ! Begin
      out=str
      do
        tmpstr = out
        k1 = index(tmpstr, q)
        k2 = index(tmpstr, cq)
        if ( k2 < k1+1 .or. k2 < 1 .or. k1 < 1 ) return
        if ( k1 == 1 .and. k2 == len_trim(tmpstr) ) then
          out = ' '
          return
        elseif ( k1 == 1 ) then
          out = tmpstr(k2+1:)
        elseif ( k2 == len_trim(tmpstr) ) then
          out = tmpstr(:k1-1)
        else
          out = tmpstr(:k1-1) // tmpstr(k2+1:)
        endif
      enddo
    end subroutine RemoveAnyQuotedStrings
  end function unquote

  ! ---------------------unwrap ---------------
  ! Unwrap str by replacing separators (meaning line feeds) between 2 breaks
  ! with a single break
  ! option         values                             default     
  ! inseparator --                                      ','       
  ! break       --                                      ' '       
  ! mode        -- 'soft' or 'hard'                    'hard'
  ! mode        -- don't break within quoted strings   (none)     
  function unwrap_array( strings ) result( outstr )
    ! Args
    character (len=*), dimension(:), intent(in)   :: strings
    character (len=MAXSTRLISTLENGTH)              :: outstr
    ! Internal variables
    integer                                       :: i
    ! Executable
    outstr = ' '
    if ( size(strings) < 1 ) return
    outstr = strings(1)
    do i=2, size(strings)
      outstr = trim(outstr) // ' ' // strings(i)
    enddo
  end function unwrap_array

  function unwrap_list( str, inseparator, break ) result( outstr )
    ! Args
    character (len=*), intent(in)                 :: str
    character (len=MAXSTRLISTLENGTH)              :: outstr
    character (len=*), optional, intent(in)       :: inseparator ! if not ','
    character (len=*), optional, intent(in)       :: break ! if not ' '
    ! Internal variables
    logical, parameter                            :: countEmpty = .true.
    integer                                       :: n
    character (len=256), dimension(:), pointer    :: strings => null()
    ! Executable
    outstr = ' '
    n = NumStringElements( str, countEmpty, inseparator )
    if ( n < 1 ) return
    allocate( strings(1:n) )
    call list2Array( str, strings, countEmpty, inseparator=inseparator )
    outstr = unwrap( strings )
    deallocate( strings )
  end function unwrap_list

  ! ---------------------wrap ---------------
  ! Wrap str by putting separators (meaning line feeds) between 2 breaks
  ! so no line exceeds width
  ! option         values                             default     
  ! inseparator --                                      ','       
  ! break       --                                      ' '       
  ! mode        -- 'soft' or 'hard'                    'hard'
  ! mode        -- don't break within quoted strings   (none)     
  ! dontsqueeze -- don't squeeze consecutive spaces    false (make it true?)  
  subroutine wrap_sca( str, outstr, width, &
    & inseparator, break, mode, quotes, addedLines, dontSqueeze )
    ! Args
    character (len=*), intent(in)                 :: str
    character (len=*), intent(out)                :: outstr
    integer, intent(in)                           :: width
    character (len=*), optional, intent(in)       :: inseparator ! if not ','
    character (len=*), optional, intent(in)       :: break ! if not ' '
    character (len=*), optional, intent(in)       :: mode ! if not 'hard'
    character (len=*), optional, intent(in)       :: quotes ! don't break quoted
    integer, optional, intent(out)                :: addedLines ! by wrapping
    logical, optional, intent(in)                 :: dontSqueeze
    ! Internal variables
    logical, parameter         :: countEmpty = .true.
    logical, parameter         :: deebug = .false.
    integer                    :: i
    integer                    :: j
    integer                    :: lastPos
    logical                    :: noQuotes
    integer                    :: offset
    character(len=len(outstr)) :: partstr
    character(len=1)           :: quote
    character(len=len(outstr)) :: wrpartstr
    ! Executable
    if ( present(addedLines) ) addedLines = 0
    outstr = str
    if ( len_trim(str) <= width ) return
    if ( .not. present(quotes) ) then
      call wrap_noQuotes( str, width, outstr, &
        & inseparator=inseparator, break=break, mode=mode, &
        & addedLines=addedLines, dontSqueeze=dontSqueeze )
    else
      ! We will assume that no more than one kind of quote will appear in a str
      ! if this assumption needs to be relaxed the following will be inadequate
      noQuotes = .true.
      do i=1, len_trim(quotes)
        quote = quotes(i:i)
        if ( index(str, quote) < 1 ) cycle
        ! Quoted strings require that quotes appear in pairs
        ! therefore there cannot be an odd number of them
        if ( mod( ncopies(str, quote), 2) == 1 ) cycle
        noQuotes = .false.
        lastPos = 0
        outstr = ' '
        if ( deebug ) print *, 'quote: ' // trim(quote), &
          & 'number ', NumStringElements( str, countEmpty, quote )
        ! What we'll do is to wrap only the odd-numbered elements
        do j=1, NumStringElements( str, countEmpty, quote )
          offset = lastPos
          call GetStringElement ( str, partstr, j, countEmpty, quote )
          if ( deebug ) print *, 'j ', j, ' part: ' // trim(partstr)
          if ( mod(j, 2) == 1 ) then
            call wrap_noQuotes( partstr, width, wrpartstr, &
              & inseparator=inseparator, break=break, mode=mode, offset=offset, lastPos=lastPos, &
              & addedLines=addedLines )
            if ( deebug ) print *, 'wrapped part: ' // trim(wrpartstr)
            if ( j == 1 ) then
              outstr = wrpartstr
            else
              outstr = trim(outstr) // wrpartstr
            endif
          else
            if ( deebug ) print *, '(must not wrap quoted part)'
            outstr = trim(outstr) // quote // trim(partstr) // quote
            lastPos = lastPos + len_trim(partstr) + 2
          endif
          if ( deebug ) print *, trim(outstr)
        enddo
        exit
      enddo
      ! How did we arrive here?
      if ( noQuotes ) &
        & call wrap_noQuotes( str, width, outstr, &
        & inseparator=inseparator, break=break, mode=mode, &
        & addedLines=addedLines, dontSqueeze=dontSqueeze )
    endif
  end subroutine wrap_sca

  subroutine wrap_array( str, outstrs, width, &
    & inseparator, break, mode, quotes, addedLines, dontSqueeze )
  ! Wrap str by putting each block in separate element of output array outstrs
  ! so no element exceeds width
    ! Args
    character (len=*), intent(in)                 :: str
    character (len=*), dimension(:), intent(out)  :: outstrs
    integer, intent(in)                           :: width
    character (len=*), optional, intent(in)       :: inseparator ! if not ','
    character (len=*), optional, intent(in)       :: break ! if not ' '
    character (len=*), optional, intent(in)       :: mode ! if not 'hard'
    character (len=*), optional, intent(in)       :: quotes ! don't break quoted
    integer, optional, intent(out)                :: addedLines ! by wrapping
    logical, optional, intent(in)                 :: dontSqueeze
    ! Internal variables
    ! Executable
    if ( present(addedLines) ) addedLines = 0
    outstrs(1) = str
    if ( len_trim(str) <= width ) return
    if ( .not. present(quotes) ) then
      call wrap_noQuotes( str, width, outstrs=outstrs, &
        & inseparator=inseparator, break=break, mode=mode, &
        & addedLines=addedLines, dontSqueeze=dontSqueeze )
    else
      print *, 'We cant really wrap arrays with quotes yet'
      call wrap_noQuotes( str, width, outstrs=outstrs, &
        & inseparator=inseparator, break=break, mode=mode, &
        & addedLines=addedLines, dontSqueeze=dontSqueeze )
    endif
  end subroutine wrap_array

  subroutine wrap_noQuotes( str, width, outstr, outstrs, &
    & inseparator, break, mode, offset, lastPos, addedLines, dontSqueeze )
    ! Args
    character (len=*), intent(in)                 :: str
    integer, intent(in)                           :: width
    character (len=*), optional, intent(out)                :: outstr
    character (len=*), dimension(:), optional, intent(out)  :: outstrs
    character (len=*), optional, intent(in)       :: inseparator ! if not ','
    character (len=*), optional, intent(in)       :: break ! if not ' '
    character (len=*), optional, intent(in)       :: mode ! if not 'hard', then 'soft'
    integer, optional, intent(in)                 :: offset
    integer, optional, intent(out)                :: lastPos
    integer, optional, intent(inout)              :: addedLines ! by wrapping
    logical, optional, intent(in)                 :: dontSqueeze
    ! Internal variables
    integer                                       :: dsnext    
    integer                                       :: dsp       
    integer                                       :: istr      
    integer                                       :: ko        
    integer                                       :: kp        
    character(len=1)                              :: myBreak   
    character(len=1)                              :: myMode    
    integer                                       :: myLastPos 
    integer                                       :: myOffset  
    integer                                       :: nextwidth 
    logical                                       :: NoConsecutiveSpaces
    integer                                       :: so        
    integer                                       :: sp        
    character(len=4)                              :: separator 
    ! Executable
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = comma
    endif
    myBreak = ' '
    if ( present(break) ) myBreak = break
    myMode = 'h' ! hard
    if ( present(mode) ) myMode = mode
    myOffset = 0
    if ( present(offset) ) myOffset = offset
    if ( present(outstr) ) outstr = str
    if ( present(outstrs) ) outstrs(1) = str
    if ( present(addedLines) ) addedLines = 0
    NoConsecutiveSpaces = .true.
    if ( present(dontSqueeze) ) NoConsecutiveSpaces = .not. dontSqueeze
    ! print *, 'str ', trim(str)
    ! print *, 'myMode ', myMode
    ! print *, 'separator ', separator
    ! print *, 'len_trim(separator) ', len_trim(separator)
    istr = 0
    if ( len_trim(str) <= width ) return
    so = 1 ! this is the current character number of str
    ko = 1 ! this is the current character number of outstr
    myLastPos = ko + myOffset
    do
      ! how big is next width?
      nextwidth = min(width, len_trim(str) - so + 1)
      if ( so == 1 ) nextwidth = max( 1, nextwidth-myOffset )
      ! print *, 'nextwidth ', nextwidth
      if ( nextwidth < 1 ) exit
      ! does the rest of str fit within nextwidth? If so, copy it to outstr, and we're done
      if ( nextwidth >= len_trim(str) - so + 1 ) then
        if ( present(outstr) ) outstr(ko:ko + nextwidth - 1) = str(so:so + nextwidth - 1)
        if ( present(outstrs) ) then
          istr = istr + 1
          outstrs(istr) = str(so:so + nextwidth - 1)
        endif
        myLastPos = myLastPos + nextWidth
        exit
      endif
      ! Is there a separator between here and nextwidth?
      dsp = ( index( str(so:so+nextwidth-1), trim(separator), back=.true. ) )
      if ( dsp > 0 ) then
        ! Yes, so we break there
        myLastPos = 1
        sp = so + dsp - 2 + len_trim(separator)
        kp = ko + dsp - 2 + len_trim(separator)
        if ( present(outstr) ) outstr(ko:kp) = str(so:sp)
        if ( present(outstrs) ) then
          istr = istr + 1
          outstrs(istr) = str(so:sp)
        endif
        ko = kp + 1
        so = sp + 1
        if ( present(addedLines) ) addedLines = addedLines + 1
        cycle
      endif
      select case (lowerCase(myMode))
      case ('h')
        ! 'hard' wrap
        ! we will wrap to exactly width or less, even if we have to hyphenate
        ! do we have any breakable spaces in next width?
        ! dsp = index( str(so:so+nextwidth-1), ' ', back=.true. )
        dsp = index( str(so:so+nextwidth-1), myBreak, back=.true. )
        ! print *, 'so, ko ', so, ko
        ! print *, 'dsp ', dsp
        if ( dsp > 0 .and. dsp < nextwidth+1 ) then
          ! Yes, so we break there
          myLastPos = 1
          sp = so - 1 + dsp
          kp = ko + dsp - 2 + len_trim(separator)
          if ( present(outstr) ) outstr(ko:kp) = str(so:sp-1) // trim(separator)
          ko = ko + dsp + len_trim(separator) - 1
          if ( present(addedLines) ) addedLines = addedLines + 1
          ! Now treat possibility that next chars might be spaces, too
          if ( len_trim(myBreak) > 0 ) sp = sp + 1
          dsnext = findFirst( trim_safe(str(sp:)), ' ', reverse=.true. )
          if ( dsnext < 1 ) exit
          so = sp + dsnext - 1
        else
          ! No, so we hyphenate
          myLastPos = 1
          kp = ko + nextwidth - 2 + len_trim(separator)
          ! print *, 'ko, kp ', ko, kp
          ! print *, 'so, so+nextwidth-3 ', so, so+nextwidth-3
          if ( present(outstr) ) outstr(ko:kp) = str(so:so+nextwidth-3) // '-' // trim(separator)
          ko = ko + nextwidth
          so = so + nextwidth - 2
          if ( present(addedLines) ) addedLines = addedLines + 1
        endif
      case ('s')
        ! 'soft' wrap
        ! We will find the next break and wrap to that
        ! even though the resulting width may be slightly greater than planned
        ! 1st: try to wrap within width
        dsp = index( str(so:so+nextwidth-1), myBreak, back=.true. )
        ! print *, '(nextwidth+1: ', nextwidth+1
        ! print *, '(break) dsp: ', dsp
        if ( dsp > 0 .and. dsp < nextwidth+1 ) then
          myLastPos = 1
          ! Yes, so we break there
          sp = so + dsp - 1
          kp = ko + dsp - 1 + len_trim(separator)
          if ( present(outstr) ) outstr(ko:) = str(so:sp) // trim(separator)
          ! print *, 'in:  ', str(so:sp)
          ! print *, 'out: ', outstr(ko:kp)
          ko = kp + 1
          if ( present(addedLines) ) addedLines = addedLines + 1
          ! Now treat possibility that next chars might be spaces, too
          if ( len_trim(myBreak) > 0 ) sp = sp + 1
          dsnext = findFirst( trim_safe(str(sp:)), ' ', reverse=.true. )
          if ( dsnext < 1 ) exit
          sp = sp + dsnext
          so = sp - 1
        else
          ! Look for next break starting with width
          dsp = index( trim_safe(str(so+nextwidth-1:)), myBreak )
          ! print *, '(break in width) dsp: ', dsp
          if ( dsp > 0 ) then
            myLastPos = 1
            ! Yes, so we break there
            dsp = dsp + nextwidth - 1
            sp = so - 1 + dsp
            kp = ko + dsp - 2 + len_trim(separator)
            if ( present(outstr) ) outstr(ko:kp) = str(so:sp-1) // trim(separator)
            ! print *, outstr(ko:kp)
            ko = ko + dsp + len_trim(separator) - 1
            if ( present(addedLines) ) addedLines = addedLines + 1
            ! Now treat possibility that next chars might be spaces, too
            if ( len_trim(myBreak) > 0 ) sp = sp + 1
            dsnext = findFirst( trim_safe(str(sp:)), ' ', reverse=.true. )
            if ( dsnext < 1 ) exit
            sp = sp + dsnext
            so = sp - 1
          else
            ! No, so we must give up any further wrapping
            dsnext = min( len(str) - so, len(outstr) - ko )
            if ( present(outstr) ) outstr(ko:ko+dsnext) = str(so:so+dsnext)
            ! print *, outstr(ko:ko+dsnext)
            myLastPos = myLastPos + dsnext
            exit
          endif
        endif
      case default
        ! What were you thinking? 'h' or 's' are the only modes we coded
      end select
    enddo
    ! Remove consecutive spaces?
    ! print *, 'Leaving wrap_noQuotes'
    ! print *, trim(outstr)
    ! print *, 'NoConsecutiveSpaces ', NoConsecutiveSpaces
    ! print *, 'dontSqueeze ', dontSqueeze
    ! stop
    if ( len_trim(myBreak) == 0 .and. NoConsecutiveSpaces ) then
      if ( present(outstr) ) outstr = squeeze( outstr )
    endif
    if ( present(lastPos) ) lastPos = myLastPos
  end subroutine wrap_noQuotes

  ! --------------------------------------------------  WriteIntsToList  -----
  subroutine WriteIntsToList ( ints, List )
    ! Takes an array of ints and writes it as a string list
    ! E.g., given (/ 1, 2, 2, 3, 4, 5 /) returns '1 2 2 3 4 5'
    ! (Inverse of ReadIntsFromList)
    !--------Argument--------!
    character (len=*), intent(out)     :: List
    integer, dimension(:), intent(in)  :: ints
    ! Method:
    ! Use writeIntsToChars
    character(len=32), dimension(size(ints)) :: strs
    call WriteIntsToChars( ints, strs )
    call Array2List ( strs, List )
  end subroutine WriteIntsToList

!============================ Private ==============================
! ---------------------------------------  Deallocate_Index_Stack  -----
  subroutine Deallocate_Index_Stack
    ! internal variables
    integer :: stat
    ! Executable
    if ( .not. allocated(stack) ) return
    deallocate ( stack, stat=stat )
    stack_ptr = 0
  end subroutine Deallocate_Index_Stack

  subroutine prepOptions( options )
    ! Process options into separate optional args
    ! You should call this at the start of every procedure
    ! that uses options to set countEmpty, etc.
    ! Args:
    character(len=*), intent(in), optional  :: options
    ! Internal variables
    integer :: sepIndex
    character(len=16) :: myOptions
    ! Executable
    countEmpty          = .false.
    caseSensitive       = .true.
    ignoreLeadingSpaces = .false.
    separator           = ','
    myOptions = STRINGLISTOPTIONS
    if ( present(options) ) myOptions = options
    if ( len_trim(myOptions) > 0 ) then
      countEmpty          = ( index(myOptions, 'e') > 0 )
      caseSensitive       = ( index(myOptions, 'c') < 1 )
      ignoreLeadingSpaces = ( index(myOptions, 'f') > 0 )
      sepIndex = index(myOptions, 's')
      if ( sepIndex > 0 ) then
        sepIndex = sepIndex + 1
        if ( len_trim(myOptions) > sepIndex + 1 ) then
          if ( myOptions(sepIndex:sepIndex) == '{' ) &
            & separator = myOptions(sepIndex+1:sepIndex+1)
        elseif ( len_trim(myOptions) == sepIndex ) then
          separator = myOptions(sepIndex:sepIndex)
        endif
      else
        sepIndex = index(myOptions, '{')
        if ( sepIndex > 0 .and. len_trim(myOptions) > sepIndex ) &
          & separator = myOptions(sepIndex+1:sepIndex+1)
      endif
    endif
  end subroutine prepOptions

! -------------------------------------------------  Push  -----
  subroutine Push ( Index )
    ! Push the stack.  

    integer, intent(in) :: Index ! Whatever caller wants to send

    integer :: Stat
    type(Index_Stack_t), allocatable :: Temp_Stack(:)
    ! Executable

    if ( .not. allocated(stack) ) then
      ! If you allocate with lbound < 0, other stuff won't work.
      allocate ( stack(1), stat=stat )
      if ( stat /= 0 ) then
        print *, 'Unable to allocate stack'
        return
      end if
      ! call test_allocate ( stat, moduleName, 'Stack', &
      !   & ubounds=(/startingStackSize/), elementSize=storage_size(stack) / 8 )
      stack_ptr = 1
      stack(1)%index=index
    else
      ! Must increase stack size
      ! so we double it
      ! But limit number doublings to MAXDOUBLINGS
      allocate ( temp_stack(stack_ptr+1), stat=stat )
      if ( stat /= 0 ) then
        print *, 'Unable to allocate temp_stack'
        return
      end if
      temp_stack(:stack_ptr) = stack
      call move_alloc ( temp_stack, stack )
      stack_ptr = stack_ptr + 1
      stack(stack_ptr)%index =  index
    end if
  end subroutine Push

  subroutine Pop ( Frame )

    type(Index_Stack_t), intent(out) :: Frame

    double precision :: Delta ! Memory change, as accounted by Allocate_Deallocate
    logical :: HaveStack
    integer :: IDelta         ! Memory change, as accounted by system in kB
    logical :: MySilent
    logical :: MySysSize
    real :: T
    integer :: Total_used     ! Memory used in kilobytes (1024)
    character(len=10) :: Used

    ! Executable
    haveStack = allocated(stack)
    if ( haveStack ) haveStack = stack_ptr >= lbound(stack,1)

    if ( haveStack ) then
      frame = stack(stack_ptr)
      stack_ptr = stack_ptr - 1
    end if

  end subroutine Pop

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSStringLists.f90,v 2.91 2022/01/04 23:44:11 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MLSStringLists
!=============================================================================

! $Log: MLSStringLists.f90,v $
! Revision 2.91  2022/01/04 23:44:11  pwagner
! Changes to appease gfortran
!
! Revision 2.90  2021/04/29 22:52:13  pwagner
! Added WriteIntsToList
!
! Revision 2.89  2020/06/24 20:52:33  pwagner
! BooleanValue_log now respects precedence of 'and' over 'or'
!
! Revision 2.88  2020/06/09 21:55:10  pwagner
! Fix error caused by failure to Deallocate_Index_Stack
!
! Revision 2.87  2020/06/03 23:39:49  pwagner
! Improve BooleanValue_log; implemented GetMatchedParens
!
! Revision 2.86  2020/05/20 23:33:33  pwagner
! Tried to speed up SwitchDetail
!
! Revision 2.85  2019/11/11 21:17:45  pwagner
! subroutine wrap now takes optional arg dontSueeze
!
! Revision 2.84  2019/10/22 18:50:27  pwagner
! Fixed bug confusing r and R options in SortArray
!
! Revision 2.83  2019/10/21 23:18:01  pwagner
! SortArray may now reverse its sort order
!
! Revision 2.82  2019/07/09 22:59:54  pwagner
! Wrap may now put its output in an array
!
! Revision 2.81  2019/01/10 21:42:39  pwagner
! SwitchDetail returns the greatest Detail if multiple matches
!
! Revision 2.80  2018/12/11 01:21:43  pwagner
! No longer uses Printit_M
!
! Revision 2.79  2018/06/26 23:59:09  pwagner
! Dont go past end of inList in GetStringElement
!
! Revision 2.78  2017/12/12 21:22:12  pwagner
! Remove limit on character lengths in SortArray
!
! Revision 2.77  2017/12/07 22:06:12  pwagner
! Using sort_m instead of LexicalSort
!
! Revision 2.76  2017/09/25 17:24:19  pwagner
! New subroutine to RemoveOption from option string
!
! Revision 2.75  2017/08/23 16:43:48  pwagner
! Fixed bugs in SortArray; now Uses LexicalSort
!
! Revision 2.74  2017/01/25 21:12:36  pwagner
! Corrected bug in SwitchDetail; added CapitalizeList
!
! Revision 2.73  2016/12/16 21:57:09  pwagner
! Fixed a long-standing error in wrap; hopefully w/o committing new ones
!
! Revision 2.72  2016/12/14 01:23:21  pwagner
! Added unwrap
!
! Revision 2.71  2016/12/08 00:16:41  pwagner
! Added ReadNumsFromList
!
! Revision 2.70  2016/01/20 00:20:44  pwagner
! Added optional arg options to Intersection to allow wildcard matches
!
! Revision 2.69  2015/09/03 20:22:21  pwagner
! Fixed error in RemoveElemFromList
!
! Revision 2.68  2015/05/06 20:46:11  pwagner
! Repaired some error msgs
!
! Revision 2.67  2015/03/31 22:11:25  pwagner
! All args to optionDetail are optional now
!
! Revision 2.66  2014/08/19 23:15:16  vsnyder
! Added SeparatorLocation argument to GetStringElement
!
! Revision 2.65  2014/08/05 00:16:28  pwagner
! EvaluateFormula geberic: can work with Lists or Arrays
!
! Revision 2.64  2014/01/09 00:25:42  pwagner
! Added nCharsinFormat function
!
! Revision 2.63  2013/09/14 01:20:25  vsnyder
! Delete unused use name
!
! Revision 2.62  2013/09/12 23:26:47  pwagner
! Fixed bug in converting strvalues to lvalues in BooleanValue_str
!
! Revision 2.61  2013/08/28 00:38:17  pwagner
! Added a local version of PrintMessage to evade possible circular dependency
!
! Revision 2.60  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.59  2013/06/13 00:41:27  pwagner
! Removed lots of unused orts
!
! Revision 2.58  2013/05/23 16:08:20  pwagner
! Fixed bug calling unused procedure--why didn't NAG catch this?
!
! Revision 2.57  2013/05/22 20:25:44  pwagner
! Can insert, remove hash elements, scalar or array-valued
!
! Revision 2.56  2013/05/16 18:18:37  pwagner
! Corrected bugs in BooleanValue, HashElement procedures
!
! Revision 2.55  2013/05/07 21:01:21  pwagner
! Added array versions of Get, Put hash elements
!
! Revision 2.54  2013/04/05 00:47:42  pwagner
! Increased MAXSTRLISTLENGTH by factor of 4
!
! Revision 2.53  2013/04/04 22:31:05  pwagner
! Added "b"ackward option to switchDetail
!
! Revision 2.52  2012/08/30 20:51:45  pwagner
! Added RemoveSwitchFromList
!
! Revision 2.51  2012/08/27 22:54:58  pwagner
! Changed api for sorts, more useful for sorting switches
!
! Revision 2.50  2012/07/20 17:01:06  pwagner
! Added EvaluateFormula and LoopOverFormula
!
! Revision 2.49  2012/07/11 20:01:43  pwagner
! Fixed something only NAG complained about
!
! Revision 2.48  2012/07/10 15:17:15  pwagner
! Changes to GetUnique.. to work with Switches better
!
! Revision 2.47  2012/06/27 17:51:57  pwagner
! countEmpty now optional arg to remove..FromList
!
! Revision 2.46  2012/05/08 17:44:30  pwagner
! BooleanValue now a generic: values may be a string list
!
! Revision 2.45  2012/01/05 01:18:33  pwagner
! Capitalized USEd stuff
!
! Revision 2.44  2011/04/20 16:35:15  pwagner
! Added SnipList
!
! Revision 2.43  2011/02/18 18:00:10  pwagner
! Improved optionDetail; added parseOptions to fully parse commandline
!
! Revision 2.42  2010/11/05 22:23:01  pwagner
! Fixed bugs in optionDetail
!
! Revision 2.41  2010/11/03 18:29:07  pwagner
! Added optionDetail to tell whether an option is present
!
! Revision 2.40  2010/06/22 16:51:32  pwagner
! default options for switchDetail is '-f'
!
! Revision 2.39  2010/04/16 23:38:34  pwagner
! Repaired bug in switchDetail which, e.g., caused '-Sl2pc' to always return '2'
!
! Revision 2.38  2009/06/23 18:22:49  pwagner
! Added ReadIntsfromList
!
! Revision 2.37  2009/06/16 17:07:05  pwagner
! Added BuildHash to build keys, values arrays from Constructor
!
! Revision 2.36  2008/12/11 19:39:20  pwagner
! Added print statement to not_used_here
!
! Revision 2.35  2008/05/21 20:00:19  pwagner
! Must not increment optional arg unless present
!
! Revision 2.34  2008/05/09 00:24:08  pwagner
! New features added to wrap; useful for wrapLines and l2cf
!
! Revision 2.33  2008/05/02 00:08:13  pwagner
! wrap subroutine may now operate in soft mode
!
! Revision 2.32  2008/01/23 21:24:43  pwagner
! RemoveNumFromList works with inseparator correctly
!
! Revision 2.31  2007/12/19 01:28:29  pwagner
! Removed unused variables
!
! Revision 2.30  2007/09/20 17:39:59  pwagner
! Added wrap procedure
!
! Revision 2.29  2007/07/31 22:46:51  pwagner
! Added listMatches
!
! Revision 2.28  2007/06/26 00:19:21  pwagner
! Workaround another Intel bug; may expand string range into reals
!
! Revision 2.27  2007/06/21 00:49:52  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.26  2007/05/22 20:56:02  vsnyder
! don't use list-directed write to internal files
!
! Revision 2.25  2007/05/14 21:51:51  pwagner
! Bugfix for way ifc writes ints to strings
!
! Revision 2.24  2007/04/20 22:27:49  pwagner
! Minor change to keep buggy Intel compiler from producing code that bombs
!
! Revision 2.23  2006/07/12 20:37:44  pwagner
! inseparator may be any length; even 0
!
! Revision 2.22  2006/04/21 23:57:05  pwagner
! Small correction to comments on api for SwitchDetail
!
! Revision 2.21  2006/03/03 23:06:35  pwagner
! Added Intersection function
!
! Revision 2.20  2006/02/24 01:14:54  pwagner
! Added BooleanValue to evaluate boolean formulas
!
! Revision 2.19  2006/02/21 19:06:25  pwagner
! Made Get, PutHashElement routines generic
!
! Revision 2.18  2006/02/16 00:59:08  pwagner
! Fixed bug preventing "?" switch from working properly
!
! Revision 2.17  2006/01/26 00:31:46  pwagner
! Added RemoveNumFromList, MakeStringHashElement
!
! Revision 2.16  2005/11/11 21:39:12  pwagner
! added stringElement function (should we keep GetStringElement?)
!
! Revision 2.15  2005/10/18 22:52:04  pwagner
! Added IsInList function
!
! Revision 2.14  2005/09/22 23:33:58  pwagner
! date conversion procedures and functions all moved into dates module
!
! Revision 2.13  2005/09/14 22:53:26  pwagner
! Added dai_to_yyyymmdd
!
! Revision 2.12  2005/08/08 23:53:18  pwagner
! utc_format never undefined in utc_to_yyyymmdd_ints
!
! Revision 2.11  2005/08/05 16:31:07  pwagner
! Added RemoveListFromList
!
! Revision 2.10  2005/07/21 23:38:18  pwagner
! Added explanation of to-be-standard character flag options
!
! Revision 2.9  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.8  2005/06/14 18:32:25  pwagner
! Added SwitchDetail
!
! Revision 2.7  2005/03/26 00:06:54  pwagner
! Repaired RemoveElemFromList; added extract option to unquote
!
! Revision 2.6  2005/02/03 19:04:58  pwagner
! Added GetUniqueInts, utc_to_date, utc_to_time
!
! Revision 2.5  2004/10/19 22:59:08  vsnyder
! Remove USE for unused R8
!
! Revision 2.4  2004/10/13 00:51:09  vsnyder
! Move HHMMSS_value to MLSStrings
!
! Revision 2.3  2004/09/16 00:16:46  pwagner
! CatLists may cat integers onto end of stringLists
!
! Revision 2.2  2004/08/05 22:47:02  pwagner
! New interfaces to ExpandStringList for ints and logicals
!
! Revision 2.1  2004/08/04 23:17:30  pwagner
! First commit
!
@


2.91
log
@Changes to appease gfortran
@
text
@d4312 1
a4312 1
        tempSwitches = ',' // InList
d4315 1
a4315 1
        tempSwitches = ',' // lowercase(InList)
d4364 1
d4373 1
d5141 1
a5141 1
       "$Id: MLSStringLists.f90,v 2.90 2021/04/29 22:52:13 pwagner Exp $"
d5152 3
@


2.90
log
@Added WriteIntsToList
@
text
@d2376 1
a2376 1
    character(len=max(len(stringList), len(string))) :: element
d2694 1
a2694 1
    character (len=len(inList))               :: detail
d2700 2
a2701 2
    character (len=len(inList)+2)           :: element
    character (len=len(inList))             :: listBloc ! space-separated
d5139 1
a5139 1
       "$Id: MLSStringLists.f90,v 2.89 2020/06/24 20:52:33 pwagner Exp $"
d5150 3
@


2.89
log
@BooleanValue_log now respects precedence of 'and' over 'or'
@
text
@d102 1
d186 1
d293 1
a293 1
    & Unquote, Unwrap, Wrap
d3147 2
a3148 1
    ! E.g., given '1 2 2 3 4 4'  returns (/ 1, 2, 2, 3, 4, 5 /)
d5012 15
d5139 1
a5139 1
       "$Id: MLSStringLists.f90,v 2.88 2020/06/09 21:55:10 pwagner Exp $"
d5150 3
@


2.88
log
@Fix error caused by failure to Deallocate_Index_Stack
@
text
@d21 1
a21 1
    & SplitDetails, Squeeze, StrEq, Trim_Safe, WriteIntsToChars
d488 14
d509 3
a511 2
    logical, parameter          :: deeBug = .false.
    integer :: level
d518 4
d529 16
a545 1
    collapsedstr = lowerCase(str)
d574 71
d670 109
d836 2
a837 2
            print *, 'keys', ' is ', trim(lkeys)
            print *, 'values', ' is ', lvalues
d862 2
a863 2
          print *, 'hit ', hit
          print *, 'negating ', negating
d5121 1
a5121 1
       "$Id: MLSStringLists.f90,v 2.87 2020/06/03 23:39:49 pwagner Exp $"
d5132 3
@


2.87
log
@Improve BooleanValue_log; implemented GetMatchedParens
@
text
@d21 1
a21 1
    & SplitDetails, SplitNest, Squeeze, StrEq, Trim_Safe, WriteIntsToChars
d513 1
d1681 1
a1681 1
        if ( n >= k ) return
d1684 1
d4796 10
d4907 1
a4907 1
       "$Id: MLSStringLists.f90,v 2.86 2020/05/20 23:33:33 pwagner Exp $"
d4918 3
@


2.86
log
@Tried to speed up SwitchDetail
@
text
@d60 2
a62 1
! GetHashElement     Returns value from hash list corresponding to key string
d118 3
a122 2
! GetHashElement (hash {keys = values}, char* key, 
!   char* outElement, log countEmpty, [char inseparator], [log part_match])
d279 1
a279 1
    & GetHashElement, GetStringElement, &
d293 16
d499 1
d514 19
a532 1
      call SplitNest ( collapsedstr, part1, part2, part3 )
d1648 37
d4831 61
d4895 1
a4895 1
       "$Id: MLSStringLists.f90,v 2.85 2019/11/11 21:17:45 pwagner Exp $"
d4906 3
@


2.85
log
@subroutine wrap now takes optional arg dontSueeze
@
text
@d3976 4
a3979 4
  ! if more than one switch matches the test_switch, the result from the first
  ! match is shown
  !   unless one of the options is "b" (for "back") when the last match is used
  ! if the string list contains a "*" and one of the options is "w" then
d3995 1
d4000 3
a4002 3
    character (len=len(test_switch))          :: switch          ! the detail number 
    character (len=len(Inlist))               :: Switches        ! would start
    character (len=len(Inlist))               :: tempSwitches
d4008 37
d4048 1
a4048 1
    if ( nElements <= 0 .or. test_switch == "" ) Return
d4760 1
a4760 1
       "$Id: MLSStringLists.f90,v 2.84 2019/10/22 18:50:27 pwagner Exp $"
d4771 3
@


2.84
log
@Fixed bug confusing r and R options in SortArray
@
text
@d55 1
a55 1
! catLists           cats 2 string lists, taking care if either one is blank
d97 3
a99 3
! unquote            Removes surrounding [quotes]
! unwrap             Unwrap a multi-line string to a single line
! wrap               Wrap a string to fit within prescribed width
d109 1
a109 1
! char* catLists (char* str1, char* str2)
d181 2
a182 1
!   & [char break], [char mode], [char* quotes], [int addedLines] )
d295 2
a296 2
  interface catLists
    module procedure catLists_str, catLists_int, catLists_intarray
d699 2
a700 2
      keys = catlists( keys, stringElement( istr, 1, countEmpty, inseparator=trim(op) ) )
      values = catlists( values, stringElement( istr, 2, countEmpty, inseparator=trim(op) ) )
d772 1
a772 1
      outstr = catLists( outstr, trim_safe(temp), inseparator=inseparator )
d776 1
a776 1
  ! -------------------------------------------------  catLists  -----
d781 1
a781 1
  !   List = catLists ( List, str(i) ) ! Cat str(i) ono List end
d784 2
a785 2
  ! -------------------------------------------------  catLists_int  -----
  function catLists_int (STR1, INT, inseparator) result (OUTSTR)
d814 1
a814 1
  end function catLists_int
d816 2
a817 2
  ! ---------------------------------------------  catLists_intarray  -----
  function catLists_intarray (STR1, INTS, inseparator) result (OUTSTR)
d838 1
a838 1
      outstr = catlists_int(tmpstr, ints(i))
d840 1
a840 1
  end function catLists_intarray
d842 2
a843 2
  ! -------------------------------------------------  catLists_str  -----
  function catLists_str (STR1, STR2, inseparator) result (OUTSTR)
d871 1
a871 1
  end function catLists_str
d1156 1
a1156 1
              tempstr = catLists(trim(tempstr), adjustl(tChar))
d1178 1
a1178 1
            tempstr = catLists(trim(tempstr), adjustl(tChar))
d1182 1
a1182 1
      outstr = catLists(trim(outstr), adjustl(tempstr))
d2056 1
a2056 1
        & outstr = catLists( outstr, elem )
d2185 1
a2185 1
        matches = catLists( matches, element )
d2742 1
a2742 1
      keys = catlists( keys, key, inseparator )
d2772 1
a2772 1
      keys = catlists( keys, key, inseparator )
d2803 2
a2804 2
    keyList = catLists( keys, key, inseparator )
    hashList = catLists( hash, elem, inseparator )
d3148 1
a3148 1
      outList = catLists( outList, trim(elem), inseparator )
d3242 1
a3242 1
        & outSwitches = catLists( outSwitches, aSwitch )
a4342 1
    logical, parameter                            :: countEmpty = .true.
d4381 1
d4383 1
a4383 1
    & inseparator, break, mode, quotes, addedLines )
d4393 1
d4411 2
a4412 1
        & inseparator=inseparator, break=break, mode=mode, addedLines=addedLines )
d4455 2
a4456 1
          & inseparator=inseparator, break=break, mode=mode, addedLines=addedLines )
d4461 1
a4461 1
    & inseparator, break, mode, quotes, addedLines )
d4473 1
d4481 2
a4482 1
        & inseparator=inseparator, break=break, mode=mode, addedLines=addedLines )
d4486 2
a4487 1
        & inseparator=inseparator, break=break, mode=mode, addedLines=addedLines )
d4492 1
a4492 1
    & inseparator, break, mode, offset, lastPos, addedLines )
d4504 1
d4516 1
a4516 1
    logical, parameter                            :: NoConsecutiveSpaces = .true.
d4535 6
a4549 2
      ! print *, 'separator ', separator
      ! print *, 'len_trim(separator) ', len_trim(separator)
d4670 5
d4722 1
a4722 1
       "$Id: MLSStringLists.f90,v 2.83 2019/10/21 23:18:01 pwagner Exp $"
d4733 3
d4977 1
a4977 1
! catLists may cat integers onto end of stringLists
@


2.83
log
@SortArray may now reverse its sort order
@
text
@d3661 1
a3661 1
    if ( index(lowercase(myOptions), 'r' ) > 0 ) leftRight = 'R'
d4705 1
a4705 1
       "$Id: MLSStringLists.f90,v 2.82 2019/07/09 22:59:54 pwagner Exp $"
d4716 3
@


2.82
log
@Wrap may now put its output in an array
@
text
@d254 7
a260 7
! (1) in the routines Array2List, and SortArray
! the input arguments include an array of strings;
! This array is of assumed-size
! I.e., all elements from array(1:size(array)) are relevant
! Therefore in calling one of these you probably need to use the format
!   call SortArray(myArray(1:mySize), ..
! to avoid operating on undefined array elements
d262 4
a265 4
! element is longer than a limit: MAXSTRELEMENTLENGTH
! (3) integer hashes should not be used if some negative
! values are expected. The value KEYNOTFOUND=-1 is used to indicate
! "no such key."
d267 1
a267 1
! (5) if the optional extra array or list is supplied to the GetUnique...
d3577 3
a3579 1
  ! then {psl[ia[k]]=ss[k], k=1..n} yields the properly sorted array
d3581 4
a3584 2
  ! in which case {psl[k]=ss[ia[k]], k=1..n})
  ! Parallel use of ia is how you would normally 
d3591 1
a3591 1
  ! As an optional arg the properly sorted array is returned, too
d3599 1
d3613 6
d3621 6
a3626 7
  ! The strings are sifted one character at a time through a series
  ! of ever-finer bins using the selection sort embodied in
  ! subroutine tie_breaker (which see; it surely can be easily improved
  ! upon, but the overall computational gains would be modest)
  ! until each bin is occupied by no more than one string
  ! The bin number is the ranking index of that string which
  ! is returned as outIntArray
d3628 1
a3628 1
   & sortedArray, options )
d3641 1
d3657 1
d3694 1
d3719 7
a3725 1
    ! Were we asked to return the sorted array?
d3728 1
a3728 1
    ! What about left-right?
d3771 3
d4705 1
a4705 1
       "$Id: MLSStringLists.f90,v 2.81 2019/01/10 21:42:39 pwagner Exp $"
d4716 3
@


2.81
log
@SwitchDetail returns the greatest Detail if multiple matches
@
text
@d346 4
d4359 1
a4359 1
  subroutine wrap( str, outstr, width, &
d4386 2
a4387 2
      call wrap_noQuotes( str, outstr, width, &
        & inseparator, break, mode, addedLines=addedLines )
d4409 2
a4410 2
            call wrap_noQuotes( partstr, wrpartstr, width, &
              & inseparator, break, mode, offset=offset, lastPos=lastPos, &
d4429 30
a4458 2
        & call wrap_noQuotes( str, outstr, width, &
          & inseparator, break, mode, addedLines=addedLines )
d4460 1
a4460 1
  end subroutine wrap
d4462 1
a4462 1
  subroutine wrap_noQuotes( str, outstr, width, &
a4465 1
    character (len=*), intent(out)                :: outstr
d4467 2
d4478 1
d4502 4
a4505 1
    outstr = str
d4520 5
a4524 1
        outstr(ko:ko + nextwidth - 1) = str(so:so + nextwidth - 1)
d4535 5
a4539 1
        outstr(ko:kp) = str(so:sp)
d4559 1
a4559 1
          outstr(ko:kp) = str(so:sp-1) // trim(separator)
d4573 1
a4573 1
          outstr(ko:kp) = str(so:so+nextwidth-3) // '-' // trim(separator)
d4591 1
a4591 1
          outstr(ko:) = str(so:sp) // trim(separator)
d4612 1
a4612 1
            outstr(ko:kp) = str(so:sp-1) // trim(separator)
d4625 1
a4625 1
            outstr(ko:ko+dsnext) = str(so:so+dsnext)
d4637 1
a4637 1
      outstr = squeeze( outstr )
d4683 1
a4683 1
       "$Id: MLSStringLists.f90,v 2.80 2018/12/11 01:21:43 pwagner Exp $"
d4694 3
@


2.80
log
@No longer uses Printit_M
@
text
@d19 2
a20 2
  use MLSStrings, only: Capitalize, IsAlphabet, LowerCase, NCopies, &
    & ReadIntsFromChars, ReadNumsFromChars, Replace, Reverse, &
d273 16
a288 16
  public :: array2List, booleanValue, buildHash, &
   & CapitalizeArray, CapitalizeList, catLists, &
   & evaluateFormula, expandStringRange, extractSubstring, &
   & getHashElement, getStringElement, &
   & getUniqueInts, getUniqueStrings, getUniqueList, &
   & insertHashElement, intersection, isInList, &
   & list2Array, loopOverFormula, listMatches, &
   & nCharsInFormat, numStringElements, &
   & optionDetail, parseOptions, putHashElement, &
   & readIntsFromList, ReadNumsFromList, &
   & removeElemFromList, removeListFromList, removeNumFromList, &
   & removeHashArray, removeHashElement, removeOption, removeSwitchFromList, &
   & replaceSubstring, reverseList, reverseStrings, &
   & snipList, sortArray, sortList, stringElement, stringElementNum, &
   & switchDetail, &
   & unquote, unwrap, wrap
d342 2
a343 2
  interface unwrap
    module procedure unwrap_array, unwrap_list
d357 2
a358 1
  integer, private, parameter     :: MaxNumStrings       = 4096
a742 1
    integer                             :: k
d2594 1
a2594 1
  ! ---------------------------------------------  parseOptions  -----
d2615 1
a2615 1
  subroutine parseOptions( cmdline, opts_out, pattern, single_options, &
d2680 1
a2680 1
  end subroutine parseOptions
a2878 1
    integer                                              :: elem
a2905 1
    integer                                              :: elem
a3159 1
    character :: cquotes, quotes
a3172 6
    quotes = '['
    cquotes = ']'
    if ( present(delims) ) then
      quotes = delims(1)
      cquotes = delims(2)
    endif
a3628 1
    integer, parameter                     :: MAXCHARVALUE = 256
d3884 1
a3884 1
    & inseparator, part_match) RESULT (elem)
d3890 1
a3890 1
    character (len=*), optional, intent(in)       :: inseparator
a3894 1
    integer , parameter :: MAXELEMENTLENGTH = 80
d3928 1
a3928 1
  ! It returns the detail number of the test switch in the list
d3942 4
d3955 1
a3955 1
  function SwitchDetail( INLIST, TEST_SWITCH, OPTIONS ) result ( DETAIL )
d3957 4
a3960 4
    character (len=*), intent(in)             :: INLIST
    character (len=*), intent(in)             :: TEST_SWITCH
    character (len=*), intent(in), optional   :: OPTIONS
    integer                                   :: DETAIL
d3963 12
a3974 9
    logical :: back
    logical, parameter :: COUNTEMPTY = .true.
    integer :: elem
    integer, parameter :: MAXELEMENTLENGTH = 80
    character (len=MAXELEMENTLENGTH)           :: listElement
    character(len=8) :: myOptions
    integer :: nElements
    integer :: startOfDetails     ! index where the detail number would start
    character (len=len(test_switch))           :: switch
d3992 12
d4008 1
a4008 1
        call GetStringElement(inList, listElement, nElements-elem+1, countEmpty)
d4010 1
a4010 1
        call GetStringElement(inList, listElement, elem, countEmpty)
d4638 1
a4638 1
       "$Id: MLSStringLists.f90,v 2.79 2018/06/26 23:59:09 pwagner Exp $"
d4649 3
@


2.79
log
@Dont go past end of inList in GetStringElement
@
text
@d16 2
a17 1
  use MLSCommon, only: BareFNLen
a21 2
  use PrintIt_M, only: MLSMSG_Allocate, MLSMSG_Deallocate, &
    & MLSMSG_Error, MLSMSG_Warning, PrintItOut
d369 4
a372 1
  
d596 1
a596 1
              call myMessage( MLSMSG_Error, ModuleName, &
d634 1
a634 1
    if ( status /= 0 ) call myMessage( MLSMSG_Error, ModuleName, &
d647 1
a647 1
    if ( status /= 0 ) call myMessage( MLSMSG_Error, ModuleName, &
d1639 1
a1639 1
    if (status /= 0) CALL myMessage(MLSMSG_Error,ModuleName, &
d1678 1
a1678 1
    if (noUnique>SIZE(outs)) CALL myMessage(MLSMSG_Error,ModuleName, &
d1687 1
a1687 1
           call myMessage(MLSMSG_Error, ModuleName, &
d1757 1
a1757 1
      call myMessage(MLSMSG_Error, ModuleName, &
d1764 1
a1764 1
    if (status /= 0) CALL myMessage(MLSMSG_Error,ModuleName, &
d1776 1
a1776 1
      if (status /= 0) CALL myMessage(MLSMSG_Error,ModuleName, &
d1848 1
a1848 1
    if (status /= 0) CALL myMessage(MLSMSG_Error,ModuleName, &
d1899 1
a1899 1
    if (noUnique>SIZE(outList)) CALL myMessage(MLSMSG_Error,ModuleName, &
d1901 1
a1901 1
    if (len(outList)<len(List)) CALL myMessage(MLSMSG_Error,ModuleName, &
d1920 1
a1920 1
           call myMessage(MLSMSG_Error, ModuleName, &
d2248 1
a2248 1
    if (m < 1) call myMessage ( MLSMSG_Error, ModuleName, &              
d2258 1
a2258 1
        call myMessage ( MLSMSG_Error, ModuleName, &                     
d3484 1
a3484 1
      CALL myMessage(MLSMSG_Error,ModuleName, &
d3664 1
a3664 1
    if (status /= 0) CALL myMessage(MLSMSG_Error, ModuleName, &
d3725 1
a3725 1
    if (status /= 0) CALL myMessage(MLSMSG_Error, ModuleName, &
d3804 1
a3804 1
      call myMessage(MLSMSG_Error, ModuleName, &
d3809 1
a3809 1
    if (status /= 0) CALL myMessage(MLSMSG_Error,ModuleName, &
a4589 26
  ! ------------------------------------  myMessage  -----
  subroutine myMessage ( severity, name, line, advance )
    ! Args
    integer, intent(in)           :: severity
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: line
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    ! Local variables
    integer :: nChars
    character(len=len(line) + len(name) + 3) :: thus
    ! Executable
    nChars = len(line)
    thus = line
    if ( len_trim(name) > 0 ) then
      nChars = len(line) + len(name) + 3
      thus = '(' // trim(name) // ') ' // line
    endif
    if ( severity > MLSMSG_Warning ) then
      call PrintItOut( thus(1:nChars), SEVERITY, exitStatus = 1  )
    else
      call PrintItOut( thus(1:nChars), SEVERITY  )
    endif
  end subroutine myMessage

d4630 1
a4630 1
       "$Id: MLSStringLists.f90,v 2.78 2017/12/12 21:22:12 pwagner Exp $"
d4641 3
d4696 1
a4696 1
! Added a local version of MyMessage to evade possible circular dependency
@


2.78
log
@Remove limit on character lengths in SortArray
@
text
@d389 1
a389 1
    character (len=*), DIMENSION(:), intent(in)   :: inArray
d391 2
a392 2
    integer, DIMENSION(:), OPTIONAL, intent(in)   :: ordering
    character (len=1), OPTIONAL, intent(in)       :: leftRight
d1363 1
d1366 1
d1372 4
d2287 1
a2287 1
    integer, OPTIONAL, intent(out)            :: Longestlen  ! LENGTH of longest
d3463 1
a3463 1
    character (len=1), DIMENSION(:), ALLOCATABLE :: charBuf
d3774 1
a3774 1
    character (len=MAXSTRELEMENTLENGTH), DIMENSION(:), ALLOCATABLE    &
d3899 1
a3899 1
    logical, OPTIONAL, intent(in)             :: part_match
d4654 1
a4654 1
       "$Id: MLSStringLists.f90,v 2.77 2017/12/07 22:06:12 pwagner Exp $"
d4665 3
@


2.77
log
@Using sort_m instead of LexicalSort
@
text
@d3634 1
d3636 1
a3636 1
    character (len=MAXSTRELEMENTLENGTH), dimension(:), allocatable    &
d3638 1
a3638 1
    character (len=MAXSTRELEMENTLENGTH)    :: theString  
d3693 10
a3702 1
    call sortp( stringArray, 1, nElems, outIntArray )
d4648 1
a4648 1
       "$Id: MLSStringLists.f90,v 2.76 2017/09/25 17:24:19 pwagner Exp $"
d4659 3
@


2.76
log
@New subroutine to RemoveOption from option string
@
text
@a15 1
  use LexicalSort, only: Sort
d20 2
a21 2
    & SplitDetails, SplitNest, Squeeze, StrEq, Trim_safe, WriteIntsToChars
  use PrintIt_m, only: MLSMSG_Allocate, MLSMSG_Deallocate, &
d23 1
a23 1

d3685 5
a3689 1
    enddo                  
d3691 2
a3692 2
    ! Now we let sort do the work
    call sort( stringArray, .not. caseSensitive, outIntArray )
d4638 1
a4638 1
       "$Id: MLSStringLists.f90,v 2.75 2017/08/23 16:43:48 pwagner Exp $"
d4649 3
@


2.75
log
@Fixed bugs in SortArray; now Uses LexicalSort
@
text
@d78 1
a78 1
! PutHashElement     puts value into hash list corresponding to key string
d81 1
a81 1
! RemoveElemFromList removes occurrence(s) of elem from a string list
d85 3
a87 2
! RemoveListFromList removes occurrence(s) of elems in a string list from another
! RemoveNumFromList  removes a numbered elem from a string list
d89 2
a90 2
!                    removes a switch from a list of switches
! ReplaceSubString   replaces occurrence(s) of sub1 with sub2 in a string
d139 1
a139 1
! char* optionDetail(strlist inList, &
d161 4
a164 2
! RemoveSwitchFromList(strlist inList, strlist outList, char* switch, &
!    & [char inseparator], [char* options])
d286 1
a286 1
   & removeHashArray, removeHashElement, removeSwitchFromList, &
d2415 4
a2418 3
    if ( present(pattern) .and. &
      & any(myPattern == (/0, 1, 2, 3, 4 /)) &  ! accept legal values only
      & ) myPattern = pattern
d3142 72
d4635 1
a4635 1
       "$Id: MLSStringLists.f90,v 2.74 2017/01/25 21:12:36 pwagner Exp $"
d4646 3
@


2.74
log
@Corrected bug in SwitchDetail; added CapitalizeList
@
text
@d16 1
d3550 2
a3554 1
    integer                                :: elem, nElems
d3556 1
a3556 6
    integer, dimension(:), allocatable     :: chValue, cvInvBN
    integer, dimension(:), allocatable     :: binNumber, invBinNumber 
    integer, dimension(:), allocatable     :: jsort, inTheBin
    integer                                :: numBins, oldNumBins
    integer                                :: i, bin, ck, strPos
    integer                                :: status
a3557 1
    logical                                :: allTheSameInThisBin
d3559 1
a3559 1
    character (len=1)                      :: theChar  
a3562 1
    logical, parameter                     :: DeeBUG = .false.
d3577 2
a3578 3
    allocate (stringArray(nElems), chValue(nElems), cvInvBN(nElems), &
     & binNumber(nElems), invBinNumber(nElems), &
     & jsort(nElems), inTheBin(nElems), &
a3582 1
    numBins = 1
a3610 65
    do strPos = 1, maxStrPos
      
      if ( DEEBUG ) then
        print *, 'string position: ', strPos
        print *, 'array of bins: ', (outIntArray(elem), elem=1, nElems)
      endif
      do elem = 1, nElems
        theChar = stringArray(elem)(strPos:strPos)
        if ( stringArray(elem) == ' ' ) then
          chValue(elem) = MAXCHARVALUE
        elseif ( theChar == ' ' ) then
          chValue(elem) = 0
        elseif ( CaseSensitive ) then
          chValue(elem) = IACHAR(theChar)
        elseif (IACHAR("a") <= IACHAR(theChar) .and. &
          & IACHAR(theChar) <= IACHAR("z") ) then
          chValue(elem) = 2*IACHAR(Capitalize(theChar)) - IACHAR("A") + 1
        elseif (IACHAR("A") <= IACHAR(theChar) .and. &
          & IACHAR(theChar) <= IACHAR("Z") ) then
          chValue(elem) = 2*IACHAR(theChar) - IACHAR("A")
        elseif (IACHAR("Z") < IACHAR(theChar) ) then
          chValue(elem) = 2*IACHAR(theChar)
        else
          chValue(elem) = IACHAR(theChar)
        endif
      enddo
      if ( DEEBUG ) print *, 'array of chValues: ', (chValue(elem), elem=1, nElems)
      oldNumBins = numBins
      do elem=1, nElems
        binNumber(elem) = outIntArray(elem)
      enddo
      numBins = 0
      ck = 0
      if ( DEEBUG ) print *, 'number of bins: ', oldNumBins
      do bin=1, oldNumBins
        if ( DEEBUG ) print *, 'bin number: ', bin
        call warm_up(bin)
        if ( DEEBUG ) then
          print *, 'number in bin: ', inTheBin(bin)
          print *, 'array of invBinNumber: ', &
           & (invBinNumber(elem), elem=1, inTheBin(bin))
          print *, 'array of cvInvBN: ', (cvInvBN(elem), elem=1, inTheBin(bin))
        endif
        call tie_breaker(bin)
        if ( DEEBUG ) print *, 'array of jsort: ', (jsort(elem), elem=1, inTheBin(bin))
        numBins = numBins + 1
        ck = cvInvBN(jsort(1))
        do i=1, inTheBin(bin)
          if ( ck /= cvInvBN(jsort(i)) .or. &
           & ( &
           &  allTheSameInThisBin .and. i > 1 &
           & ) &
           & ) then
            numBins = numBins + 1
            ck = cvInvBN(jsort(i))
          endif
          outIntArray(invBinNumber(jsort(i))) = numBins
        enddo
      enddo
      if ( numBins >= min(nElems, size(outIntArray)) ) exit
    enddo
    if ( DEEBUG ) then
      print *, 'Final number of bins: ', numBins
      print *, 'Sorting order: ', (outIntArray(i), i=1, nElems)
    endif
d3612 8
a3619 18
    ! Undo the tricky business of turning spaced into DELs
    if ( Switchable ) then
      do elem = 1, nElems
          stringArray(elem) = Replace( inStrArray(elem), achar(127), ' ' )
      enddo
    endif
    if ( present(sortedArray) ) then
      do elem=1, nElems
        i = max(1, outIntArray(elem))
        i = min(i, nElems, size(sortedArray))
        if ( ShorterFirst ) then
          sortedArray(i) = adjustl(stringArray(elem))
        else
          sortedArray(i) = stringArray(elem)
        endif
      enddo
    endif
    if ( LeftRight == 'R' ) then
d3621 1
d3623 1
a3623 6
        do i=1, nElems
          if ( outIntArray(i) == elem ) invBinNumber(elem) = i
        enddo
      enddo
      do elem=1, nElems
        outIntArray(elem) = invBinNumber(elem)
d3626 2
a3627 2
    deallocate (stringArray, chValue, cvInvBN, binNumber, invBinNumber, &
     & jsort, inTheBin, STAT=status)
a3630 47
   contains
     subroutine warm_up(theBin)
       ! Form array invBinNumber = {i[j], j=1 .. }
       ! such that binNumber[i] = theBin
       ! then form cvInvBN = {c[j] = chValue[i[j]], j=1..}
       integer, intent(in) :: theBin
       integer :: j, i
       j=0
       do i=1, nElems
         if ( binNumber(i) == theBin ) then
           j=j+1
           invBinNumber(j) = i
           cvInvBN(j) = chValue(i)
         endif
       enddo
       inTheBin(theBin) = j
     end subroutine warm_up
     subroutine tie_breaker(theBin)
       ! Form array jsort = j[k] = {j_1, j_2, .., j_N}
       ! sorted so that c[j_1} <= c[j_2] <= .. <= c{j_N]
       ! This is a naive selection sort--make any improvements you wish
       ! (Order N^2 sorting algorithms are inefficient)
       integer, intent(in)      :: theBin
       integer                  :: kp, k, ck, jsortie
       character (len=MAXSTRELEMENTLENGTH)  :: stringElement  
       allTheSameInThisBin = (inTheBin(theBin) /= 1)
       stringElement = stringArray(invBinNumber(1))
       do k=1, inTheBin(theBin)
         jsort(k) = k
         allTheSameInThisBin = allTheSameInThisBin .and. &
           & stringElement == stringArray(invBinNumber(k))
       enddo
       if ( inTheBin(theBin) == 1 .or. allTheSameInThisBin) return
       do k=1, inTheBin(theBin) - 1
         ck = cvInvBN(jsort(k))
         do kp=k+1, inTheBin(theBin)
           if ( cvInvBN(jsort(kp)) < ck ) then
           ! Pull the old switcheroo
             ck = cvInvBN(jsort(kp))
             jsortie = jsort(kp)
             jsort(kp) = jsort(k)
             jsort(k) = jsortie
           endif
         enddo
       enddo
     end subroutine tie_breaker

d4559 1
a4559 1
       "$Id: MLSStringLists.f90,v 2.73 2016/12/16 21:57:09 pwagner Exp $"
d4570 3
@


2.73
log
@Fixed a long-standing error in wrap; hopefully w/o committing new ones
@
text
@d16 5
a20 5
  use MLSCommon, only: bareFNLen
  use MLSFinds, only: findFirst, findLast
  use MLSStrings, only: capitalize, lowerCase, nCopies, &
    & ReadIntsFromChars, ReadNumsFromChars, replace, reverse, &
    & SplitDetails, splitNest, squeeze, streq, trim_safe, writeIntsToChars
d22 1
a22 1
    & MLSMSG_Error, MLSMSG_Warning, printItOut
d54 2
d110 3
d129 1
a129 1
! log IsInList(strlist stringList, char* string, [char* options])
d271 2
a272 1
  public :: array2List, booleanValue, buildHash, catLists, &
d349 2
a350 2
  integer, public, parameter :: KEYNOTFOUND=-1
  integer, public, parameter :: KEYBEYONDHASHSIZE=KEYNOTFOUND-1
d352 1
a352 1
  integer, public, parameter :: lenORSIZETOOSMALL=-999
d355 3
a357 3
  integer, private, parameter :: MaxNumStrings       = 4096
  integer, private, parameter :: MAXSTRLISTLENGTH    = 4*4096
  integer, private, parameter :: MAXSTRELEMENTLENGTH = BareFNlen
d366 1
a366 1
  logical, parameter          :: deeBug = .false.
d693 81
d839 1
d2060 1
a2060 1
    character (len=*), intent(in)                 :: stringlist
d2071 1
a4043 1
        detail = 0
d4045 6
a4050 1
        if ( startOfDetails > len_trim( listElement ) ) exit
d4692 1
a4692 1
       "$Id: MLSStringLists.f90,v 2.72 2016/12/14 01:23:21 pwagner Exp $"
d4703 3
@


2.72
log
@Added unwrap
@
text
@d20 1
a20 1
    & SplitDetails, splitNest, streq, trim_safe, writeIntsToChars
d4387 1
d4390 1
a4390 1
    character (len=2)                             :: separator 
d4412 2
d4474 2
d4479 6
a4484 4
          sp = so - 1 + dsp
          kp = ko + dsp - 2 + len_trim(separator)
          outstr(ko:kp) = str(so:sp-1) // trim(separator)
          ko = ko + dsp + len_trim(separator) - 1
d4490 2
a4491 1
          so = sp + dsnext - 1
d4495 1
d4503 1
d4510 2
a4511 1
            so = sp + dsnext - 1
d4516 1
d4525 4
d4599 1
a4599 1
       "$Id: MLSStringLists.f90,v 2.71 2016/12/08 00:16:41 pwagner Exp $"
d4610 3
@


2.71
log
@Added ReadNumsFromList
@
text
@d21 1
a21 1
  use Printit_m, only: MLSMSG_allocate, MLSMSG_deallocate, &
d96 1
d172 1
d280 1
a280 1
   & unquote, wrap
d334 4
d349 2
a350 1
  integer, private, parameter :: MAXSTRLISTLENGTH = 4*4096
d4238 44
d4373 1
a4373 1
    character (len=*), optional, intent(in)       :: mode ! if not 'hard'
d4378 12
a4389 12
    character (len=4)               :: separator
    integer :: dsnext
    integer :: dsp
    integer :: ko
    integer :: kp
    character(len=1) :: myBreak
    integer :: myLastPos
    character(len=1) :: myMode
    integer :: myOffset
    integer :: nextwidth
    integer :: so
    integer :: sp
a4403 3
    ! print *, 'str ', str
    ! print *, 'len_trim(str) ', len_trim(str)
    ! print *, 'len(outstr) ', len(outstr)
d4413 1
a4413 1
      ! does the rest of str fit within nextwidth?
d4419 13
d4441 1
a4441 1
        if ( dsp > 0 .and. dsp < nextwidth ) then
d4471 1
a4471 1
        if ( dsp > 0 .and. dsp < nextwidth ) then
d4583 1
a4583 1
       "$Id: MLSStringLists.f90,v 2.70 2016/01/20 00:20:44 pwagner Exp $"
d4594 3
@


2.70
log
@Added optional arg options to Intersection to allow wildcard matches
@
text
@a15 2
  use Printit_m, only: MLSMSG_allocate, MLSMSG_deallocate, &
    & MLSMSG_Error, MLSMSG_Warning, printItOut
d17 1
a17 1
  use MLSFinds, only: findFirst
d19 1
a19 1
    & ReadIntsFromChars, replace, reverse, &
d21 2
d77 1
d141 2
d271 2
a272 1
   & optionDetail, parseOptions, putHashElement, readIntsFromList, &
d321 5
d2002 2
a2003 2
  subroutine List2Array(inList, outArray, countEmpty, inseparator, &
   & IgnoreLeadingSpaces)
d2757 57
d4522 1
a4522 1
       "$Id: MLSStringLists.f90,v 2.69 2015/09/03 20:22:21 pwagner Exp $"
d4533 3
@


2.69
log
@Fixed error in RemoveElemFromList
@
text
@d17 1
a17 1
    & MLSMSG_error, MLSMSG_warning, printitout
d121 1
a121 1
! char* intersection (char* str1, char* str2)
d261 14
a274 14
  public :: ARRAY2LIST, BOOLEANVALUE, BUILDHASH, CATLISTS, &
   & EVALUATEFORMULA, EXPANDSTRINGRANGE, EXTRACTSUBSTRING, &
   & GETHASHELEMENT, GETSTRINGELEMENT, &
   & GETUNIQUEINTS, GETUNIQUESTRINGS, GETUNIQUELIST, &
   & INSERTHASHELEMENT, INTERSECTION, ISINLIST, &
   & LIST2ARRAY, LOOPOVERFORMULA, LISTMATCHES, &
   & NCHARSINFORMAT, NUMSTRINGELEMENTS, &
   & OPTIONDETAIL, PARSEOPTIONS, PUTHASHELEMENT, READINTSFROMLIST, &
   & REMOVEELEMFROMLIST, REMOVELISTFROMLIST, REMOVENUMFROMLIST, &
   & REMOVEHASHARRAY, REMOVEHASHELEMENT, REMOVESWITCHFROMLIST, &
   & REPLACESUBSTRING, REVERSELIST, REVERSESTRINGS, &
   & SNIPLIST, SORTARRAY, SORTLIST, STRINGELEMENT, STRINGELEMENTNUM, &
   & SWITCHDETAIL, &
   & UNQUOTE, WRAP
d1901 1
a1901 1
  function Intersection (STR1, STR2) result (OUTSTR)
d1905 2
d1908 4
a1911 3
    character (len=*), intent(in) :: STR1
    character (len=*), intent(in) :: STR2
    character (len=len(str1)+len(str2)+1) :: OUTSTR
d1935 1
a1935 1
      if ( IsInList( uniq2, trim(elem) ) ) &
d1954 1
a1954 1
  function IsInList(stringList, string, options) result(itIs)
d4456 1
a4456 1
       "$Id: MLSStringLists.f90,v 2.68 2015/05/06 20:46:11 pwagner Exp $"
d4467 3
@


2.68
log
@Repaired some error msgs
@
text
@d2785 2
a2786 2
    if ( unique_list(len(elem)+1:len(elem)+1) == separator ) then
      outList = unique_list(len(elem)+2:)
d2788 1
a2788 1
      outList = unique_list(len(elem)+1:)
d2908 1
d2913 1
d2918 1
d2925 5
d4453 1
a4453 1
       "$Id: MLSStringLists.f90,v 2.67 2015/03/31 22:11:25 pwagner Exp $"
d4464 3
@


2.67
log
@All args to optionDetail are optional now
@
text
@d16 7
a22 7
  use PRINTIT_M, only: MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, &
    & MLSMSG_ERROR, MLSMSG_WARNING, PRINTITOUT
  use MLSCOMMON, only: BAREFNLEN
  use MLSFINDS, only: FINDFIRST
  use MLSSTRINGS, only: CAPITALIZE, LOWERCASE, NCOPIES, &
    & READINTSFROMCHARS, REPLACE, REVERSE, &
    & SPLITDETAILS, SPLITNEST, STREQ, TRIM_SAFE, WRITEINTSTOCHARS
d1525 1
a1525 1
         & MLSMSG_Allocate//"duplicate")
d1564 1
a1564 1
         & "outs too small")
d1787 1
a1787 1
         & "outList strings to small")
d2233 1
a2233 1
  ! 0: '-ab[arg] --xyz=arg' means  (default)
a3887 1
  ! function unquote(str, quotes, cquotes, strict, stripany, extract) &
d4445 1
a4445 1
       "$Id: MLSStringLists.f90,v 2.66 2014/08/19 23:15:16 vsnyder Exp $"
d4456 3
@


2.66
log
@Added SeparatorLocation argument to GetStringElement
@
text
@d2263 2
a2264 1
  ! (1) if the string list is "*" then
d2266 1
a2266 1
  ! (2) Why don't you let the '[]' pair that set off args be
d2272 1
a2272 1
    character (len=*), intent(in)             :: inlist
d2294 2
a2305 1
    detail = 'no'
d4446 1
a4446 1
       "$Id: MLSStringLists.f90,v 2.65 2014/08/05 00:16:28 pwagner Exp $"
d4457 3
@


2.65
log
@EvaluateFormula geberic: can work with Lists or Arrays
@
text
@d111 1
a111 1
!   nElement, log countEmpty, [char inseparator])
d1211 2
a1212 2
  ! This subroutine takes a (usually) comma-separated string list, interprets it
  ! as a list of individual elements and returns the
d1224 5
a1228 1
  ! As an optional arg the separator may supplied, in case it isn't comma
d1231 2
a1232 1
  subroutine GetStringElement(inList, outElement, nElement, countEmpty, inseparator)
d1236 2
a1237 2
    integer, intent(in)         :: nElement ! Entry number to return
    logical, intent(in)   :: countEmpty
d1239 1
d1261 1
d1263 1
a1263 1
      nextseparator = i - 1 + INDEX(inList(i:), separator)
d1269 1
d1291 1
d4444 1
a4444 1
       "$Id: MLSStringLists.f90,v 2.64 2014/01/09 00:25:42 pwagner Exp $"
d4455 3
@


2.64
log
@Added nCharsinFormat function
@
text
@d284 4
d760 10
a769 10
  function EvaluateFormula ( FORMULA, VALUES, KEYS ) result (OUTSTR)
    ! Evaluates a string formula, plugging in the nth value for
    ! each occurrence of the nth arg appearing as '${n}'
    ! E.g., if strFun is 
    ! "x${1}: vector, template=state"
    ! and the first arg is "InitPtan" then outStr will be
    ! "xInitPtan: vector, template=state"
    ! 
    ! If keys is present, then instead of '${n}' substitute for
    ! each occurrence of the nth arg appearing as '${key(n)}'
d798 33
a830 1
  end function EvaluateFormula
d4435 1
a4435 1
       "$Id: MLSStringLists.f90,v 2.63 2013/09/14 01:20:25 vsnyder Exp $"
d4446 3
@


2.63
log
@Delete unused use name
@
text
@d71 1
d127 1
d266 2
a267 1
   & LIST2ARRAY, LOOPOVERFORMULA, LISTMATCHES, NUMSTRINGELEMENTS, &
d2058 43
d4399 1
a4399 1
       "$Id: MLSStringLists.f90,v 2.62 2013/09/12 23:26:47 pwagner Exp $"
d4410 3
@


2.62
log
@Fixed bug in converting strvalues to lvalues in BooleanValue_str
@
text
@d20 1
a20 1
  use MLSSTRINGS, only: ASCIIFY, CAPITALIZE, LOWERCASE, NCOPIES, &
d4353 1
a4353 1
       "$Id: MLSStringLists.f90,v 2.61 2013/08/28 00:38:17 pwagner Exp $"
d4364 3
@


2.61
log
@Added a local version of MyMessage to evade possible circular dependency
@
text
@d20 1
a20 1
  use MLSSTRINGS, only: CAPITALIZE, LOWERCASE, NCOPIES, &
d458 3
a460 3
        print *, 'part1 ', part1
        print *, 'part2 ', part2
        print *, 'part3 ', part3
d481 1
a481 1
        print *, 'collapsedstr ', collapsedstr
d541 6
d603 2
d606 4
a609 1
        & adjustl(lowercase(StringElement ( strvalues, key, countEmpty ))), 't') == 1
d4353 1
a4353 1
       "$Id: MLSStringLists.f90,v 2.60 2013/08/12 23:47:25 pwagner Exp $"
d4364 3
@


2.60
log
@FindSomethings moved to MLSFinds module
@
text
@d16 2
a17 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, &
    & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE
d556 1
a556 1
              call MLSMessage( MLSMSG_Error, ModuleName, &
d594 1
a594 1
    if ( status /= 0 ) call MLSMessage( MLSMSG_Error, ModuleName, &
d602 1
a602 1
    if ( status /= 0 ) call MLSMessage( MLSMSG_Error, ModuleName, &
d1465 1
a1465 1
    if (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1504 1
a1504 1
    if (noUnique>SIZE(outs)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1513 1
a1513 1
           call MLSMessage(MLSMSG_Error, ModuleName, &
d1583 1
a1583 1
      call MLSMessage(MLSMSG_Error, ModuleName, &
d1590 1
a1590 1
    if (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1602 1
a1602 1
      if (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1674 1
a1674 1
    if (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1725 1
a1725 1
    if (noUnique>SIZE(outList)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1727 1
a1727 1
    if (len(outList)<len(List)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1746 1
a1746 1
           call MLSMessage(MLSMSG_Error, ModuleName, &
d3123 1
a3123 1
      CALL MLSMessage(MLSMSG_Error,ModuleName, &
d3309 1
a3309 1
    if (status /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
d3437 1
a3437 1
    if (status /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
d3563 1
a3563 1
      call MLSMessage(MLSMSG_Error, ModuleName, &
d3568 1
a3568 1
    if (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d4276 26
d4342 1
a4342 1
       "$Id: MLSStringLists.f90,v 2.59 2013/06/13 00:41:27 pwagner Exp $"
d4353 3
@


2.59
log
@Removed lots of unused orts
@
text
@d19 1
a19 1
  use MLSSETS, only: FINDFIRST
d1594 5
d1620 3
d1702 1
d1711 1
d4316 1
a4316 1
       "$Id: MLSStringLists.f90,v 2.58 2013/05/23 16:08:20 pwagner Exp $"
d4327 3
@


2.58
log
@Fixed bug calling unused procedure--why didn't NAG catch this?
@
text
@d446 1
a446 1
    logical, parameter :: countEmpty=.true.
a1065 1
    integer, parameter         :: MAXREPLACEMENTS = 100
a1298 1
    character (len=1)                          :: separator
a1301 5
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = comma
    endif
a1331 1
    character (len=1)                          :: separator
a1334 5
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif
a1556 1
    character (len=1)               :: separator
a1564 5
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif
a1791 1
    integer :: c
a1792 1
    integer                                       :: n
a1932 1
    character (len=1)               :: separator
a1935 6
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif

a2172 1
    integer, parameter :: MAXELEMENTLENGTH = 80
a2176 1
    logical, parameter :: USEEXTRACT = .true.
a2491 1
    character (len=1)                          :: separator
a2494 6
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = comma
    endif

a2522 1
    character (len=1)                          :: separator
a2524 7

    if(present(inseparator)) then
      separator = inseparator
    else
      separator = comma
    endif

a2551 1
    character (len=1)                          :: separator
a2555 7

    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif

a2594 1
    character (len=1)                             :: separator
a2596 7

    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif
    
a2650 1
    logical :: Switchable
a2659 2
    Switchable = index( myOptions, 'S' ) > 0 ! .true.
    ! if ( present(countEmpty) ) myCountEmpty = countEmpty
a2757 1
    character (len=1)                          :: separator
a2761 7

    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif

a2791 1
    logical :: Switchable
a2797 1
    Switchable = index( myOptions, 'S' ) > 0  ! .true.
a2831 3
    character (len=1)               :: separator
    logical :: Switchable
    character(len=len(inList)+1) :: temp_list
a2832 5
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif
a2835 2
    Switchable = index( myOptions, 'S' ) > 0  ! .true.
    ! if ( present(countEmpty) ) myCountEmpty = countEmpty
a2845 1
      temp_list = outList
a2863 1
    character (len=1)               :: separator
a2864 5
    if(present(inseparator)) then
      separator = inseparator
    else
      separator = COMMA
    endif
a3266 1
    integer, parameter                     :: MAXELEM = MAXSTRELEMENTLENGTH
a3517 1
    integer, parameter                            :: MAXELEM = MAXSTRELEMENTLENGTH
a4036 1
        cycle
d4306 1
a4306 1
       "$Id: MLSStringLists.f90,v 2.57 2013/05/22 20:25:44 pwagner Exp $"
d4317 3
@


2.57
log
@Can insert, remove hash elements, scalar or array-valued
@
text
@d1835 4
a1838 4
      if ( DEEBUG ) then
        call outputnamedValue( 'keyString', trim(keyString) )
        call outputnamedValue( 'value', trim(value) )
      endif
d1842 4
a1845 4
      if ( DEEBUG ) then
        call outputnamedValue( 'keyString', trim(keyString) )
        call outputnamedValue( 'value', trim(value) )
      endif
d4400 1
a4400 1
       "$Id: MLSStringLists.f90,v 2.56 2013/05/16 18:18:37 pwagner Exp $"
d4411 3
@


2.56
log
@Corrected bugs in BooleanValue, HashElement procedures
@
text
@d64 1
d77 3
d140 4
d262 2
a263 1
   & GETUNIQUEINTS, GETUNIQUESTRINGS, GETUNIQUELIST, INTERSECTION, ISINLIST, &
d267 2
a268 1
   & REMOVESWITCHFROMLIST, REPLACESUBSTRING, REVERSELIST, REVERSESTRINGS, &
d310 6
d337 1
d1801 51
d2742 102
d4400 1
a4400 1
       "$Id: MLSStringLists.f90,v 2.55 2013/05/07 21:01:21 pwagner Exp $"
d4411 3
@


2.55
log
@Added array versions of Get, Put hash elements
@
text
@d18 1
a18 1
  use MLSCOMMON, only: BAREFNlen
d104 1
a104 1
! char* EvaluateFormula (char* formula, char* values(:))
d251 11
a261 11
  public :: Array2List, BooleanValue, BuildHash, catLists, &
   & EvaluateFormula, ExpandStringRange, ExtractSubString, &
   & GetHashElement, GetStringElement, &
   & GetUniqueInts, GetUniqueStrings, GetUniqueList, Intersection, IsInList, &
   & List2Array, LoopOverFormula, listMatches, NumStringElements, &
   & optionDetail, ParseOptions, PutHashElement, ReadIntsFromList, &
   & RemoveElemFromList, RemoveListFromList, RemoveNumFromList, &
   & RemoveSwitchFromList, ReplaceSubString, ReverseList, ReverseStrings, &
   & SnipList, SortArray, SortList, StringElement, StringElementNum, &
   & SwitchDetail, &
   & unquote, wrap
d404 1
a404 1
  function BooleanValue_log (str, lkeys, lvalues) result(BooleanValue)
d414 5
a418 4
    character (len=*), intent(in)     :: str
    character (len=*), intent(in)     :: lkeys
    logical, dimension(:), intent(in) :: lvalues
    logical                           :: BooleanValue
d522 1
a522 1
            & countEmpty=.true. )
d557 1
a557 1
  function BooleanValue_str (str, lkeys, strvalues) result(BooleanValue)
d559 5
a563 4
    character (len=*), intent(in)     :: str
    character (len=*), intent(in)     :: lkeys
    character (len=*), intent(in)     :: strvalues
    logical                           :: BooleanValue
d573 1
a573 1
    nkeys = NumStringElements( lkeys, countEmpty )
d583 1
a583 1
    BooleanValue = BooleanValue_log ( str, lkeys, lvalues )
d725 2
a726 2
  function EvaluateFormula ( formula, values ) result (OUTSTR)
    ! Evaluates a string function, plugging in the nth value for
d732 3
d736 3
a738 2
    character (len=*), intent(in)               :: formula
    character (len=*), dimension(:), intent(in) :: values
d745 1
a745 1
    character(len=8)                                      :: variable    
d753 6
a758 2
      call WriteIntsToChars( i, variable )
      variable = '${' // trim(adjustl(variable)) // '}'
d2440 2
a2441 2
  subroutine PutHashElement_int(keys, values, key, value, &
  & countEmpty, inseparator, part_match)
d2448 1
a2448 1
    character (len=*), optional, intent(in)       :: inseparator
d2471 2
a2472 2
      N = NumStringElements(keys, countEmpty)
      keys = catlists(keys, key)
d2478 2
a2479 2
  subroutine PutHashElement_log(keys, values, key, value, &
  & countEmpty, inseparator, part_match)
d2486 1
a2486 1
    character (len=*), optional, intent(in)       :: inseparator
d2502 1
a2502 1
    num = StringElementNum(keys, key, countEmpty, inseparator, part_match)
d2509 2
a2510 2
      N = NumStringElements(keys, countEmpty)
      keys = catlists(keys, key)
d2516 2
a2517 2
  subroutine PutHashElement_str(keyList, hashList, key, elem, &
  & countEmpty, inseparator, part_match)
d2519 6
a2524 6
    character (len=*), intent(inout)   :: keyList
    character (len=*), intent(inout)   :: hashList
    character (len=*), intent(in)      :: key
    character (len=*), intent(in)      :: elem
    logical, intent(in)   :: countEmpty
    character (len=*), optional, intent(in)       :: inseparator
d2541 1
a2541 1
    num = StringElementNum(keyList, key, countEmpty, inseparator, part_match)
d2549 2
a2550 2
    keyList = catLists(keys, key)
    hashList = catLists(hash, elem)
d4230 1
a4230 1
       "$Id: MLSStringLists.f90,v 2.54 2013/04/05 00:47:42 pwagner Exp $"
d4241 3
@


2.54
log
@Increased MAXSTRLISTLENGTH by factor of 4
@
text
@d47 1
a47 1
! lenORSIZETOOSMALL  Either charsize of strs or size(ints) too small
d273 1
d280 1
d292 1
d297 1
d1227 26
d1254 2
a1255 2
  subroutine GetHashElement_int(keys, values, key, value, &
  & countEmpty, inseparator, part_match)
d1293 2
a1294 2
  subroutine GetHashElement_log(keys, values, key, value, &
  & countEmpty, inseparator, part_match)
d1332 2
a1333 27
  subroutine GetHashElement_str(keyList, hashList, key, outElement, &
  & countEmpty, inseparator, part_match)
  ! subroutine takes two (usually) comma-separated string lists, interprets it
  ! each as a list of elements, treating the first as keys and the second as
  ! a hash table, associative array or dictionary
  ! It returns the sub-string from the hash table corresponding to the key
  ! if the key is not found in the array of keys, it returns the separator
  
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists

  ! if countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! if TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! Another optional arg, part_match, returns a match for the 
  ! first hash element merely found in the key; e.g.
  ! 'won, to, tree' and key 'protocol.dat' matches 'to'

  ! Basic premise: Use StringElementNum on key in keyList to find index
  ! Use this index to GetStringElement from HashList

  ! Someday you may wish to define a StringHash_T made up of the two
  ! strings
d1342 1
a1342 1
    logical, OPTIONAL, intent(in)             :: part_match
d1366 52
d2405 24
a2507 24
  ! This subroutine takes two (usually) comma-separated string lists, interprets it
  ! each as a list of elements, treating the first as keys and the second as
  ! a hash table, associative array or dictionary
  ! It replaces with elem the sub-string from the hash table corresponding to the key
  ! if the key is not found in the array of keys, it adds a new key

  ! if countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! if TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! Another optional arg, part_match, returns a match for the 
  ! first hash element merely found in the key; e.g.
  ! 'won, to, tree' and key 'protocol.dat' matches 'to'

  ! Basic premise: Find the element number corresponding to the key
  ! if found remove that element from both key and hash list
  ! then add new key and hash to lists

  ! Someday you may wish to define a StringHash_T made up of the two
  ! strings
  
d2544 52
d4220 1
a4220 1
       "$Id: MLSStringLists.f90,v 2.53 2013/04/04 22:31:05 pwagner Exp $"
d4231 3
@


2.53
log
@Added "b"ackward option to switchDetail
@
text
@d307 1
a307 1
  integer, private, parameter :: MAXSTRLISTLENGTH = 4096
d4111 1
a4111 1
       "$Id: MLSStringLists.f90,v 2.52 2012/08/30 20:51:45 pwagner Exp $"
d4122 3
@


2.52
log
@Added RemoveSwitchFromList
@
text
@d18 1
a18 1
  use MLSCOMMON, only: BAREFNLEN
d47 1
a47 1
! LENORSIZETOOSMALL  Either charsize of strs or size(ints) too small
d123 1
a123 1
!   & [char inseparator], [int LongestLen])
d182 1
d214 1
a214 1
!     file='!l2gpFileName($1)', $
d245 1
a245 1
! (5) If the optional extra array or list is supplied to the GetUnique...
d304 1
a304 1
  integer, public, parameter :: LENORSIZETOOSMALL=-999
d308 1
a308 1
  integer, private, parameter :: MAXSTRELEMENTLENGTH = BareFNLen
d365 1
a365 1
    DO
d396 1
a396 1
  ! If a stringlist, it will be converted into an array of logicals
d408 1
a408 1
    ! Does not check for unmatched parens or other illegal syntax
d635 1
a635 1
    ! If str1 is blank, returns just '4'
d668 1
a668 1
    ! If str1 is blank, returns just '4,5,5,0'
d693 2
a694 2
    ! If either is blank, returns the other
    ! If both blank, returns a blank
d752 1
a752 1
  subroutine ExpandStringRange_ints (instr, ints, length)
d758 1
a758 1
    integer, optional, intent(out) :: length  ! number of ints returned
d768 1
a768 1
    if ( present(length) ) length = 0
d777 1
a777 1
    if ( present(length) ) length = min(nelem, size(ints))
d828 1
a828 1
  subroutine ExpandStringRange_real (instr, reals, length)
d834 1
a834 1
    integer, optional, intent(out) :: length  ! number of reals returned
d844 1
a844 1
    if ( present(length) ) length = 0
d853 1
a853 1
    if ( present(length) ) length = min(nelem, size(reals))
d1002 1
a1002 1
    ! If no_trim is TRUE, sub1 and sub2 may have trailing spaces
d1012 1
a1012 1
    ! Do we want to interpret the request such that we
d1021 1
a1021 1
    ! (3) Do we need an optional arg, no_trim, say, that will leave them?
d1051 1
a1051 1
    strlen = LEN_trim(instr)
d1138 1
a1138 1
  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
d1142 1
a1142 1
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}
d1170 1
a1170 1
    elseif(LEN(inList) < nElement) then
d1175 1
a1175 1
    DO
d1207 1
a1207 1
          elseif(nextseparator >= LEN(inList)) then
d1227 1
a1227 1
  ! If no match found, return KEYNOTFOUND
d1266 1
a1266 1
  ! If no match found, return FALSE
d1308 1
a1308 1
  ! If the key is not found in the array of keys, it returns the separator
d1313 1
a1313 1
  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
d1317 1
a1317 1
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}
d1367 1
a1367 1
  ! If optional extra array is supplied, instead
d1369 1
a1369 1
  ! If optional fillValue is supplied, values = fillValue are ignored
d1394 1
a1394 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1403 1
a1403 1
      howManyMax = inSize-1 ! Don't bother with last one
d1409 2
a1410 2
    DO i = 1, howManyMax
       IF (.NOT. duplicate(i)) then
d1412 3
a1414 3
          DO j = i+1, inSize
             IF (ints(j)==ints(i)) duplicate(j)=.TRUE.
          END DO
d1416 3
a1418 3
          DO j = 1, extraSize
             IF (extra(j)==ints(i)) duplicate(i)=.TRUE.
          END DO
d1421 1
a1421 1
    END DO
d1433 1
a1433 1
    IF (noUnique>SIZE(outs)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1438 1
a1438 1
      UniqueLoop: DO i = 1, noUnique
d1454 1
a1454 1
      END DO UniqueLoop
d1466 1
a1466 1
  ! If optional string list str2 is supplied, instead
d1468 1
a1468 1
  ! If optional FillValue supplied, ignores any entries = fillvalue
d1491 1
a1491 1
    integer :: LongestLen
d1504 1
a1504 1
    nElems = NumStringElements(str, countEmpty, inseparator, LongestLen)
d1513 1
a1513 1
    if ( LongestLen > MAXSTRELEMENTLENGTH ) then
d1516 1
a1516 1
      ! print *, 'LongestLen: ', LongestLen
d1519 1
a1519 1
         & "Element length too long in GetUniqueList")
d1525 1
a1525 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1530 1
a1530 1
      nElems2 = NumStringElements(str2, countEmpty, inseparator, LongestLen)
d1532 1
a1532 1
      IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1558 1
a1558 1
      ! print *, 'Done with getUniqueList'
d1565 1
a1565 1
  ! If optional extra array is supplied, instead
d1567 1
a1567 1
  ! If optional FillValue supplied, ignores any entries = fillvalue
d1601 1
a1601 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1610 1
a1610 1
      howManyMax = inSize-1 ! Don't bother with last one
d1614 1
a1614 1
    ! If we are keeping the last instance of a duplicated string, we'll
d1623 2
a1624 2
    DO i = 1, howManyMax
       IF (.NOT. duplicate(i)) then
d1626 2
a1627 2
          DO j = i+1, inSize
             ! IF (List(j)==List(i)) duplicate(j)=.TRUE.
d1629 1
a1629 1
          END DO
d1631 2
a1632 2
          DO j = 1, extraSize
             ! IF (extra(j)==List(i)) duplicate(i)=.TRUE.
d1634 1
a1634 1
          END DO
d1637 1
a1637 1
    END DO
d1650 1
a1650 1
    IF (noUnique>SIZE(outList)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1652 1
a1652 1
    IF (LEN(outList)<LEN(List)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1662 3
a1664 3
      UniqueLoop: DO i = 1, noUnique
         ! UniqueHuntLoop: DO
         !   IF (.NOT. duplicate(j)) EXIT UniqueHuntLoop
d1667 1
a1667 1
         ! END DO UniqueHuntLoop
d1683 1
a1683 1
      END DO UniqueLoop
d1685 2
a1686 2
    ! print *, 'Done with UniqueLoop'
    ! If we reversed the order, recover the original order
d1797 1
a1797 1
  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
d1801 1
a1801 1
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}
d1804 1
a1804 1
  ! If the optional arg ignoreLeadingSpaces is TRUE, "a, b, c" is
d1840 1
a1840 1
    DO
d1935 1
a1935 1
  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
d1945 1
a1945 1
   & inseparator, LongestLen) RESULT (nElements)
d1951 1
a1951 1
    integer, OPTIONAL, intent(out)            :: LongestLen  ! Length of longest
d1967 2
a1968 2
   if ( present(LongestLen) ) &
     & LongestLen =0
d1970 1
a1970 1
   if(LEN_TRIM(inList) <= 0) then
d1972 1
a1972 1
      if ( present(LongestLen) ) LongestLen = 0
d1979 1
a1979 1
   DO i=1, LEN_TRIM(inList)
d1983 2
a1984 2
            if ( present(LongestLen) ) &
             & LongestLen = max(LongestLen, sinceLastseparated)
d1993 2
a1994 2
   if ( present(LongestLen) ) &
     & LongestLen = max(LongestLen, sinceLastseparated)
d2011 1
a2011 1
  ! If patterns is present, it determines whether options must be preceded
d2035 3
a2037 3
  ! If the test option were "a" the returned value would be 'yes'
  ! If the test option were "c" the returned value would be 'arg2'
  ! If the test option were "g" the returned value would be 'no'
d2044 1
a2044 1
  ! (1) If the string list is "*" then
d2106 1
a2106 1
      ! Does it have an arg?
d2110 1
a2110 1
        ! Does this block begin with one "-" or two?
d2151 1
a2151 1
      ! Does it have an arg?
d2155 1
a2155 1
        ! Does this block begin with one "-" or two?
d2195 1
a2195 1
      ! Does it have an arg?
d2199 1
a2199 1
        ! Does this block begin with one "-" or not?
d2230 1
a2230 1
      ! Does it have an arg?
d2234 1
a2234 1
        ! Does this block begin with one "-" or two?
d2431 1
a2431 1
  ! If the key is not found in the array of keys, it adds a new key
d2433 1
a2433 1
  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
d2437 1
a2437 1
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}
d2445 1
a2445 1
  ! If found remove that element from both key and hash list
d2539 1
a2539 1
    IF (LEN_trim(elem) < 1 .or. len_trim(inList) < 1 &
d2699 1
a2699 1
    ! Do we need an optional arg, no_trim, say, that will leave them?
d2724 1
a2724 1
    IF (LEN_trim(str) < 1 .or. len_trim(sub1) < 1) RETURN
d2889 1
a2889 1
    character (len=LEN(str)) :: outstr
d2910 1
a2910 1
    if(LEN(str) == 1 .OR. INDEX(str, separator) == 0) RETURN
d2913 2
a2914 2
    ALLOCATE(charBuf(LEN(str)+1), STAT=istr)
    IF (istr /= 0) then
d2925 1
a2925 1
    DO
d2929 1
a2929 1
        elseif(iBuf > LEN(str)) then
d2932 1
a2932 1
          istr = MAX(LEN_TRIM(word), 1)
d2934 1
a2934 1
        DO i=1, istr
d2948 1
a2948 1
    DO i=1, iBuf
d2992 1
a2992 1
    character (len=LEN(str)) :: outstr
d3034 1
a3034 1
  ! If the shorterFirst is TRUE, the sorting is modified
d3038 1
a3038 1
  ! If shorterFirst, leading spaces are always ignored
d3041 1
a3041 1
  !  (If you want them ignored, it's easy enough: create a tempArray
d3102 1
a3102 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
d3106 1
a3106 1
    maxStrPos = 1                ! This will hold max string length needed
d3230 1
a3230 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
d3298 1
a3298 1
  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
d3302 1
a3302 1
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}
d3307 1
a3307 1
  ! If the optional arg ignoreLeadingSpaces is TRUE, "a, b, c" is
d3326 1
a3326 1
    integer :: nElems, status, LongestLen
d3353 1
a3353 1
    nElems = NumStringElements(inList, countEmpty, inseparator, LongestLen)
d3356 1
a3356 1
    elseif ( LongestLen > MAXSTRELEMENTLENGTH ) then
d3358 1
a3358 1
         & "Element length too long in SortList")
d3362 1
a3362 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d3425 1
a3425 1
  ! If you want the last instead, use ReverseList on inList && subtract
d3434 1
a3434 1
  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
d3474 1
a3474 1
    DO elem=1, nElements
d3499 3
a3501 3
  ! If the test switch were "abc" the returned value would be 0
  ! If the test switch were "xyz" the returned value would be -1
  ! If the test switch were "hi2" the returned value would be -1
d3509 4
a3512 2
  !
  ! If the string list contains a "*" and one of the options is "w" then
d3515 1
a3515 1
  function SwitchDetail(inList, test_switch, options) RESULT (detail)
d3517 4
a3520 4
    character (len=*), intent(in)             :: inList
    character (len=*), intent(in)             :: test_switch
    integer                                   :: detail
    character (len=*), intent(in), optional  :: OPTIONS
d3523 1
d3540 1
a3540 1
    IF ( nElements <= 0 .or. test_switch == "" ) Return
d3542 1
d3551 6
a3556 2
    DO elem=1, nElements
      CALL GetStringElement(inList, listElement, elem, countEmpty)
d3585 1
a3585 1
    ! If no surrounding quotes are found, returns string unchanged; unless
d3599 1
a3599 1
    ! If strict, exceptions (1) and (2) above disregarded
d3602 1
a3602 1
    ! If stripany, any quotes, surrounding or internal,
d3605 1
a3605 1
    ! If extract, returns first substring surrounded by
d3610 1
a3610 1
    ! If reverse, removes any quoted strings; 
d3615 1
a3615 1
    ! If given optional arg quotes, removes only surrounding pair:
d3620 1
a3620 1
    ! If given optional args quotes & cquotes, removes only surrounding pair:
d3640 1
a3640 1
    ! (2) If len(quotes) > 1, processes them in order quotes(i:i), i=1 2 ..
d3670 1
a3670 1
   ! length of non-blank portion of string to be trimmed must be at least 2
d3885 1
a3885 1
      ! If this assumption needs to be relaxed the following will be inadequate
d3980 1
a3980 1
      ! Does the rest of str fit within nextwidth?
d3990 1
a3990 1
        ! Do we have any breakable spaces in next width?
d4111 1
a4111 1
       "$Id: MLSStringLists.f90,v 2.51 2012/08/27 22:54:58 pwagner Exp $"
d4122 3
d4201 1
a4201 1
! Don't use list-directed write to internal files
@


2.51
log
@Changed api for sorts, more useful for sorting switches
@
text
@d78 2
d140 2
d257 3
a259 2
   & ReplaceSubString, ReverseList, ReverseStrings, SnipList, &
   & SortArray, SortList, StringElement, StringElementNum, SwitchDetail, &
d2645 35
d4102 1
a4102 1
       "$Id: MLSStringLists.f90,v 2.50 2012/07/20 17:01:06 pwagner Exp $"
d4113 3
@


2.50
log
@Added EvaluateFormula and LoopOverFormula
@
text
@d21 1
a21 1
    & READINTSFROMCHARS, REVERSE, &
d143 4
a146 5
! SortArray (char* inStrArray(:), int outIntArray(:), log CaseSensitive, &
!   & [char* sortedArray(:)], [log shorterFirst], [char leftRight])
! SortList (strlist inStrArray, int outIntArray(:), log CaseSensitive, &
!   & log countEmpty, [char inseparator], [log IgnoreLeadingSpaces], 
!     [strlist sortedList], [char leftRight])
d236 1
a236 1
! (3) Integer hashes should not be used if some negative
d329 2
a330 2
    CHARACTER (LEN=*), INTENT(OUT)                :: outList
    CHARACTER (LEN=*), DIMENSION(:), INTENT(IN)   :: inArray
d332 2
a333 2
    INTEGER, DIMENSION(:), OPTIONAL, INTENT(IN)   :: ordering
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: leftRight
d338 2
a339 2
    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=1)               :: myLeftRight
d342 1
a342 1
    IF(PRESENT(inseparator)) THEN
d344 1
a344 1
    ELSE
d346 1
a346 1
    END IF
d348 1
a348 1
    IF(PRESENT(leftRight)) THEN
d350 1
a350 1
    ELSE
d352 1
a352 1
    ENDIF
d378 1
a378 1
    ENDDO
d399 1
a399 1
    ! Then evaluate the primitives
d572 1
a572 1
    deallocate( lvalues, stat=status )
d644 1
a644 1
    end if
d702 1
a702 1
    end if
d1020 4
a1023 4
    CHARACTER (LEN=*), INTENT(IN) :: instr
    CHARACTER (LEN=*), INTENT(IN) :: sub1
    CHARACTER (LEN=*), INTENT(IN) :: sub2
    CHARACTER (LEN=*), INTENT(INOUT) :: outstr
d1028 1
a1028 1
    CHARACTER (LEN=len(instr)) :: str
d1031 1
a1031 1
    INTEGER :: i, isub1, isub2, strlen, tmpstrlen
d1143 4
a1146 4
    CHARACTER (LEN=*), INTENT(IN)   :: inList
    CHARACTER (LEN=*), INTENT(OUT)  :: outElement
    integer, INTENT(IN)         :: nElement ! Entry number to return
    LOGICAL, INTENT(IN)   :: countEmpty
d1153 1
a1153 1
    CHARACTER (LEN=1)               :: separator
d1156 1
a1156 1
    IF(PRESENT(inseparator)) THEN
d1158 1
a1158 1
    ELSE
d1160 1
a1160 1
    ENDIF
d1162 1
a1162 1
    IF(nElement.LE.0) THEN
d1164 1
a1164 1
    ELSEIF(LEN(inList) < nElement) THEN
d1166 1
a1166 1
    ENDIF
d1173 2
a1174 2
      IF(nextseparator == i - 1) THEN
        IF(elem >= nElement) THEN
d1176 1
a1176 1
        ELSE
d1178 1
a1178 1
        ENDIF
d1182 3
a1184 3
      ELSEIF(nextseparator == i) THEN
        IF(countEmpty) THEN
          IF(elem >= nElement) THEN
d1187 1
a1187 1
          ELSE
d1189 2
a1190 2
          ENDIF
        ENDIF
d1193 3
a1195 3
        ELSE
          IF(elem >= nElement) THEN
            IF(i < nextseparator) THEN
d1197 1
a1197 1
            ELSE
d1199 1
a1199 1
            ENDIF
d1201 1
a1201 1
          ELSEIF(nextseparator >= LEN(inList)) THEN
d1204 1
a1204 1
          ELSE
d1206 2
a1207 2
          ENDIF
        ENDIF
d1209 1
a1209 1
      ENDDO
d1280 1
a1280 1
    IF(PRESENT(inseparator)) THEN
d1282 1
a1282 1
    ELSE
d1284 1
a1284 1
    ENDIF
d1325 5
a1329 5
    CHARACTER (LEN=*), INTENT(IN)   :: keyList
    CHARACTER (LEN=*), INTENT(IN)   :: hashList
    CHARACTER (LEN=*), INTENT(IN)   :: key
    CHARACTER (LEN=*), INTENT(OUT)  :: outElement
    LOGICAL, INTENT(IN)   :: countEmpty
d1331 1
a1331 1
    LOGICAL, OPTIONAL, INTENT(IN)             :: part_match
d1335 1
a1335 1
    CHARACTER (LEN=1)                          :: separator
d1339 1
a1339 1
    IF(PRESENT(inseparator)) THEN
d1341 1
a1341 1
    ELSE
d1343 1
a1343 1
    ENDIF
d1346 1
a1346 1
    IF(elem <= 0) THEN
d1348 1
a1348 1
    ELSE
d1351 1
a1351 1
    ENDIF
d1387 1
a1387 1
    ALLOCATE (duplicate(inSize), STAT=status)
d1404 1
a1404 1
       IF (.NOT. duplicate(i)) THEN
d1414 1
a1414 1
       END IF
d1489 1
a1489 1
    IF(PRESENT(inseparator)) THEN
d1491 1
a1491 1
    ELSE
d1493 1
a1493 1
    ENDIF
d1515 2
a1516 2
    end if
    ALLOCATE (inStringArray(nElems), outStringArray(nElems), STAT=status)
d1525 1
a1525 1
      ALLOCATE (inStrAr2(nElems2), STAT=status)
d1538 1
a1538 1
      DEALLOCATE(inStringArray, outStringArray, inStrAr2)
d1550 1
a1550 1
      DEALLOCATE(inStringArray, outStringArray)
d1584 1
a1584 1
    INTEGER :: status        ! Status from allocate
d1594 1
a1594 1
    ALLOCATE (duplicate(inSize), STAT=status)
d1618 1
a1618 1
       IF (.NOT. duplicate(i)) THEN
d1630 1
a1630 1
       END IF
d1817 1
a1817 1
    IF(PRESENT(inseparator)) THEN
d1819 1
a1819 1
    ELSE
d1821 1
a1821 1
    ENDIF
d1823 1
a1823 1
    IF(PRESENT(IgnoreLeadingSpaces)) THEN
d1825 1
a1825 1
    ELSE
d1827 1
a1827 1
    ENDIF
d1839 1
a1839 1
    ENDDO
d1941 3
a1943 3
    CHARACTER (LEN=*), INTENT(IN)             :: inList
    LOGICAL, INTENT(IN)                       :: countEmpty
    INTEGER                                   :: nElements
d1945 1
a1945 1
    INTEGER, OPTIONAL, INTENT(OUT)            :: LongestLen  ! Length of longest
d1948 2
a1949 2
    INTEGER :: i, sinceLastseparated           ! Loop counters
    LOGICAL :: lastWasNotseparated
d1951 1
a1951 1
    CHARACTER (LEN=1)               :: separator
d1954 1
a1954 1
    IF(PRESENT(inseparator)) THEN
d1956 1
a1956 1
    ELSE
d1958 1
a1958 1
    ENDIF
d1964 1
a1964 1
   IF(LEN_TRIM(inList) <= 0) THEN
d1968 1
a1968 1
   ENDIF
d1974 2
a1975 2
     IF(inList(i:i) == separator) THEN
       IF(countEmpty .OR. lastWasNotseparated) THEN
d1979 1
a1979 1
       ENDIF
d1982 1
a1982 1
     ELSE
d1985 2
a1986 2
     ENDIF
   ENDDO
d2357 1
a2357 1
    character (LEN=1)                          :: separator
d2395 1
a2395 1
    character (LEN=1)                          :: separator
d2440 1
a2440 1
  ! Then add new key and hash to lists
d2456 1
a2456 1
    character (LEN=1)                          :: separator
d2462 1
a2462 1
    IF(PRESENT(inseparator)) THEN
d2464 1
a2464 1
    ELSE
d2466 1
a2466 1
    ENDIF
d2486 3
a2488 3
    CHARACTER (LEN=*), INTENT(IN)      :: inList
    integer, dimension(:), INTENT(OUT) :: ints
    integer, optional, INTENT(OUT)     :: error
d2505 3
a2507 3
    CHARACTER (LEN=*), INTENT(IN) :: inList
    CHARACTER (LEN=*), INTENT(IN) :: elem
    CHARACTER (LEN=*), INTENT(OUT)                :: outList
d2512 1
a2512 1
    ! Then snip it back off
d2521 1
a2521 1
    IF(PRESENT(inseparator)) THEN
d2523 1
a2523 1
    ELSE
d2525 1
a2525 1
    END IF
d2556 3
a2558 3
    CHARACTER (LEN=*), INTENT(IN) :: inList
    CHARACTER (LEN=*), INTENT(IN) :: exclude ! What to exclude
    CHARACTER (LEN=*), INTENT(OUT)                :: outList
d2615 1
a2615 1
    IF(PRESENT(inseparator)) THEN
d2617 1
a2617 1
    ELSE
d2619 1
a2619 1
    END IF
d2661 4
a2664 4
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=*), INTENT(IN) :: sub1
    CHARACTER (LEN=*), INTENT(IN) :: sub2
    CHARACTER (LEN=*) :: outstr
d2670 1
a2670 1
    INTEGER :: i, array_size
d2718 1
a2718 1
        ! Then I had an idea: Why not reinterpret this as multiple passes?
d2847 2
a2848 2
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr
d2853 4
a2856 4
    INTEGER, PARAMETER :: MAXWORDLENGTH=80
    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=1), DIMENSION(:), ALLOCATABLE :: charBuf
    CHARACTER (LEN=MAXWORDLENGTH) :: word
d2858 1
a2858 1
    LOGICAL, PARAMETER :: countEmpty = .TRUE.    
d2861 1
a2861 1
    IF(PRESENT(inseparator)) THEN
d2863 1
a2863 1
    ELSE
d2865 1
a2865 1
    ENDIF
d2869 1
a2869 1
    IF(LEN(str) == 1 .OR. INDEX(str, separator) == 0) RETURN
d2873 1
a2873 1
    IF (istr /= 0) THEN
d2877 1
a2877 1
    ENDIF
d2886 1
a2886 1
        IF(word == separator) THEN
d2888 1
a2888 1
        ELSEIF(iBuf > LEN(str)) THEN
d2890 1
a2890 1
        ELSE
d2896 1
a2896 1
        ENDDO
d2900 2
a2901 2
      ENDIF
    ENDDO
d2903 1
a2903 1
    IF(charBuf(iBuf) == separator) THEN
d2905 1
a2905 1
    ENDIF
d2910 1
a2910 1
    ENDDO
d2912 1
a2912 1
    DEALLOCATE(charBuf)
d2949 3
a2951 3
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=*), INTENT(IN) :: elem
    CHARACTER (LEN=LEN(str)) :: outstr
d2973 2
a2974 2
  ! (unless the further optional arg leftRight is also supplied and equals
  ! one of {"r", "R"} in which case {psl[k]=ss[ia[k]], k=1..n})
d2984 10
a2993 1
  ! If the optional arg shorterFirst is TRUE, the sorting is modified
d3012 2
a3013 2
  subroutine SortArray(inStrArray, outIntArray, CaseSensitive, &
   & sortedArray, shorterFirst, leftRight)
d3015 5
a3019 7
    CHARACTER (LEN=*), DIMENSION(:), INTENT(IN)   :: inStrArray
    INTEGER, DIMENSION(:), INTENT(OUT)            :: outIntArray
    LOGICAL, INTENT(IN)                           :: caseSensitive
    CHARACTER (LEN=*), DIMENSION(:), OPTIONAL, INTENT(OUT)  &
     &                                            :: sortedArray
    LOGICAL, OPTIONAL, INTENT(IN)                 :: shorterFirst
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: leftRight
d3022 5
a3026 1
    integer :: elem, nElems
d3037 3
a3039 3
    logical                                :: myShorterFirst
    CHARACTER (LEN=1)                      :: theChar  
    CHARACTER (LEN=MAXSTRELEMENTLENGTH), DIMENSION(:), ALLOCATABLE    &
d3041 1
a3041 2
    CHARACTER (LEN=MAXSTRELEMENTLENGTH)    :: theString  
    CHARACTER (LEN=1)                      :: myLeftRight
d3045 7
a3051 10
    IF(PRESENT(shorterFirst)) THEN
      myshorterFirst = shorterFirst
    ELSE
      myshorterFirst = .false.
    ENDIF
    IF(PRESENT(leftRight)) THEN
      myleftRight = Capitalize(leftRight)
    ELSE
      myleftRight = "L"
    ENDIF
a3055 4
!    elseif ( nElems > MAXELEM ) then
!       CALL MLSMessage(MLSMSG_Error, ModuleName, &
!         & 'Too many elements in inStrArray in SortArray')
!       return
d3057 1
a3057 2
!    ALLOCATE (stringArray(nElems), STAT=status)
    ALLOCATE (stringArray(nElems), chValue(nElems), cvInvBN(nElems), &
d3068 1
a3068 1
      if ( myShorterFirst ) then
d3079 7
a3085 2
    do elem = 1, nElems    
      if ( myshorterFirst ) then
d3089 1
a3089 1
        theString = adjustl(inStrArray(elem))
a3090 2
      else
        stringArray(elem) = inStrArray(elem)
d3093 1
a3093 1
    DO strPos = 1, maxStrPos
d3153 1
a3153 1
    ENDDO
d3159 6
d3169 1
a3169 1
        if ( myShorterFirst ) then
d3176 1
a3176 1
    if ( myLeftRight == 'R' ) then
d3187 1
a3187 1
    DEALLOCATE(stringArray, chValue, cvInvBN, binNumber, invBinNumber, &
d3196 1
a3196 1
       ! Then form cvInvBN = {c[j] = chValue[i[j]], j=1..}
d3216 1
a3216 1
       CHARACTER (LEN=MAXSTRELEMENTLENGTH)  :: stringElement  
d3271 1
a3271 2
  subroutine SortList(inList, outArray, CaseSensitive, countEmpty, &
   & ignoreLeadingSpaces, inseparator, sortedList, leftRight)
d3273 2
a3274 4
    CHARACTER (LEN=*), INTENT(IN)                 :: inList
    INTEGER, DIMENSION(:), INTENT(OUT)            :: outArray
    LOGICAL, INTENT(IN)                           :: CaseSensitive
    LOGICAL, INTENT(IN)                           :: countEmpty
d3276 2
a3277 3
    CHARACTER (LEN=*), OPTIONAL, INTENT(OUT)      :: sortedList
    LOGICAL, OPTIONAL, INTENT(IN)                 :: IgnoreLeadingSpaces
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: leftRight
d3280 5
a3284 1
    integer, parameter              :: MAXELEM = MAXSTRELEMENTLENGTH
d3287 2
a3288 2
    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=MAXSTRELEMENTLENGTH), DIMENSION(:), ALLOCATABLE    &
a3289 1
    CHARACTER (LEN=1)               :: myLeftRight
d3292 1
a3292 1
    IF(PRESENT(inseparator)) THEN
d3294 1
a3294 1
    ELSE
d3296 7
a3302 7
    ENDIF

    IF(PRESENT(leftRight)) THEN
      myleftRight = Capitalize(leftRight)
    ELSE
      myleftRight = "L"
    ENDIF
d3306 1
a3306 1
       print *, 'present(inseparator)?: ', PRESENT(inseparator)
a3318 4
!    elseif ( nElems > MAXELEM ) then
!      call MLSMessage(MLSMSG_Error, ModuleName, &
!         & "Too many elements needed in SortList")
!      return
d3320 1
a3320 1
    ALLOCATE (stringArray(nElems), STAT=status)
d3323 3
a3325 4
    call list2Array(inList, stringArray, countEmpty, inseparator, &
     & IgnoreLeadingSpaces)
    call SortArray(stringArray(1:nElems), outArray, CaseSensitive, &
     & leftRight=leftRight)
d3327 1
a3327 1
      if ( myLeftRight == 'R' ) then
d3335 1
a3335 1
    DEALLOCATE(stringArray)
d3351 3
a3353 3
    CHARACTER (LEN=*), INTENT(IN)   :: inList
    integer, INTENT(IN)         :: nElement  ! Entry number to return
    LOGICAL, INTENT(IN)   :: countEmpty
d3355 1
a3355 1
    CHARACTER (LEN=len(inList))  :: outElement
d3358 1
a3358 1
    CHARACTER (LEN=1)               :: separator
d3361 1
a3361 1
    IF(PRESENT(inseparator)) THEN
d3363 1
a3363 1
    ELSE
d3365 1
a3365 1
    ENDIF
d3408 4
a3411 4
    CHARACTER (LEN=*), INTENT(IN)             :: inList
    CHARACTER (LEN=*), INTENT(IN)             :: test_string
    LOGICAL, INTENT(IN)                       :: countEmpty
    INTEGER                                   :: elem
d3413 1
a3413 1
    LOGICAL, OPTIONAL, INTENT(IN)             :: part_match
d3416 2
a3417 2
    INTEGER :: nElements
    INTEGER , PARAMETER :: MAXELEMENTLENGTH = 80
d3419 1
a3419 1
    CHARACTER (LEN=MAXELEMENTLENGTH)           :: listElement
d3425 1
a3425 1
    IF(nElements <= 0) THEN
d3428 1
a3428 1
    ENDIF
d3439 1
a3439 1
        IF(adjustl(listElement) == adjustl(test_string)) RETURN
d3441 1
a3441 1
    ENDDO
d3474 2
a3475 2
    CHARACTER (LEN=*), INTENT(IN)             :: inList
    CHARACTER (LEN=*), INTENT(IN)             :: test_switch
d3483 1
a3483 1
    CHARACTER (LEN=MAXELEMENTLENGTH)           :: listElement
d3521 1
a3521 1
    ENDDO
d3910 1
a3910 1
    end if
d3946 1
a3946 1
        if ( dsp > 0 ) then
d3976 1
a3976 1
        if ( dsp > 0 ) then
d4062 1
a4062 1
       "$Id: MLSStringLists.f90,v 2.49 2012/07/11 20:01:43 pwagner Exp $"
d4073 3
@


2.49
log
@Fixed something only NAG complained about
@
text
@d55 2
d68 2
d102 1
d119 1
d199 28
d248 1
a248 1
   & ExpandStringRange, ExtractSubString, &
d251 2
a252 2
   & List2Array, listMatches, NumStringElements, optionDetail, &
   & ParseOptions, PutHashElement, ReadIntsFromList, &
d713 33
d1885 37
d4058 1
a4058 1
       "$Id: MLSStringLists.f90,v 2.48 2012/07/10 15:17:15 pwagner Exp $"
d4069 3
@


2.48
log
@Changes to GetUnique.. to work with Switches better
@
text
@a33 3
! This module contains some low level string handling stuff for mls
! (Perhaps the date and time conversions should be moved out of here
! and MLSStrings and put into time_m? Or into a stand-alone module?)
d36 4
d76 1
d1451 2
d1474 1
d1477 1
d1486 1
d1522 1
d1584 1
d1613 1
d1617 2
a1618 1
      call reverseStrings( list(1:noUnique), outList )
d1622 1
d3954 1
a3954 1
       "$Id: MLSStringLists.f90,v 2.47 2012/06/27 17:51:57 pwagner Exp $"
d3965 3
@


2.47
log
@countEmpty now optional arg to remove..FromList
@
text
@d22 1
a22 1
    & SPLITNEST, STREQ, TRIM_SAFE, WRITEINTSTOCHARS
d102 3
a104 2
! GetUniqueList (char* str, char* outstr(:), int noUnique, log countEmpty, &
!   & [char inseparator], [log IgnoreLeadingSpaces], [char* fillValue]) 
d106 1
a106 1
!   [char* extra(:)], [char* fillValue])
d125 1
a125 1
!    & [char inseparator], [log countEmpty])
d127 1
a127 1
!    & [char inseparator], [log countEmpty])
d129 1
a129 1
!    & [char inseparator], [log countEmpty])
d133 2
a134 1
! strlist SnupList (strlist str, char* elem, [char inseparator])
d180 2
d218 1
a218 1
   & ReplaceSubString, ReverseList, SnipList, &
d1396 2
a1397 2
  subroutine GetUniqueList(str, outStr, noUnique, countEmpty, &
    & inseparator, IgnoreLeadingSpaces, str2, fillValue)
d1399 4
a1402 4
    CHARACTER (LEN=*), intent(in) :: str
    CHARACTER (LEN=*), intent(out) :: outstr
    INTEGER :: noUnique ! Number of unique entries
    LOGICAL, INTENT(IN)                           :: countEmpty
d1404 4
a1407 3
    LOGICAL, OPTIONAL, INTENT(IN)       :: IgnoreLeadingSpaces
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN)       :: str2
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN)       :: fillValue
d1410 4
a1413 2
    CHARACTER (LEN=1)               :: separator
    CHARACTER (LEN=MAXSTRELEMENTLENGTH), DIMENSION(:), ALLOCATABLE    &
d1426 3
d1460 2
a1461 2
      call GetUniqueStrings(inStringArray, outStringArray, noUnique, &
       & inStrAr2, fillValue)
d1470 2
a1471 2
      call GetUniqueStrings(inStringArray, outStringArray, noUnique, &
      & fillValue=fillValue)
d1491 2
a1492 1
  subroutine GetUniqueStrings(inList, outList, noUnique, extra, fillValue)
d1494 6
a1499 5
    CHARACTER (LEN=*), DIMENSION(:) :: inList
    CHARACTER (LEN=*), DIMENSION(:) :: outList
    INTEGER :: noUnique ! Number of unique entries
    CHARACTER (LEN=*), optional, DIMENSION(:) :: extra
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN)       :: fillValue
d1502 1
a1502 3
    INTEGER :: i,j,k           ! Loop counters
    LOGICAL, DIMENSION(:), ALLOCATABLE :: duplicate ! Set if already found
    INTEGER :: status        ! Status from allocate
d1504 1
a1504 1
    INTEGER :: extraSize
d1506 7
a1512 1
    INTEGER :: inSize
d1515 4
d1534 8
a1542 1

d1547 2
a1548 1
             IF (inList(j)==inList(i)) duplicate(j)=.TRUE.
d1552 2
a1553 1
             IF (extra(j)==inList(i)) duplicate(i)=.TRUE.
d1561 4
a1564 1
      duplicate = duplicate .or. (inList == fillValue)
d1572 1
a1572 1
    IF (LEN(outList)<LEN(inList)) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d1592 1
a1592 1
           outList(i)=inList(inSize)
d1595 1
a1595 1
           outList(i)=inList(k+j-1)  ! was inList(j)
d1604 5
d1611 20
d1659 1
a1659 1
      & countEmpty=countEmpty, ignoreLeadingSpaces=ignoreLeadingSpaces )
d1661 1
a1661 1
      & countEmpty=countEmpty, ignoreLeadingSpaces=ignoreLeadingSpaces )
d1726 3
a1728 3
    CHARACTER (LEN=*), INTENT(IN)                 :: inList
    CHARACTER (LEN=*), DIMENSION(:), INTENT(OUT)  :: outArray
    LOGICAL, INTENT(IN)                           :: countEmpty
d1730 1
a1730 1
    LOGICAL, OPTIONAL, INTENT(IN)                 :: IgnoreLeadingSpaces
d1735 1
a1735 1
    CHARACTER (LEN=1)               :: separator
d2386 1
a2386 1
    & countEmpty )
d2394 1
a2394 1
    logical, optional, intent(in)                 :: countEmpty
d2400 2
d2404 1
a2404 1
    integer :: numUnique
d2411 5
a2415 2
    myCountEmpty = .true.
    if ( present(countEmpty) ) myCountEmpty = countEmpty
d2422 2
a2423 2
    call GetUniqueList(temp_list, unique_list, numUnique, myCountEmpty, &
    & inseparator=inseparator, ignoreLeadingSpaces=.true.)
d2434 3
a2436 2
  ! --------------------------------------------------  RemoveListFromList  -----
  subroutine RemoveListFromList ( inList, outList, exclude, inseparator, countEmpty )
d2445 1
a2445 1
    logical, optional, intent(in)                 :: countEmpty
d2452 1
d2454 1
d2458 5
a2462 2
    myCountEmpty = .true.
    if ( present(countEmpty) ) myCountEmpty = countEmpty
d2470 2
a2471 1
      call RemoveElemFromList( temp_list, temp_list2, elem, inseparator, countEmpty )
d2479 1
a2479 1
    & countEmpty )
d2487 1
a2487 1
    logical, optional, intent(in)                 :: countEmpty
d2494 1
d2497 1
d2505 5
a2509 2
    myCountEmpty = .true.
    if ( present(countEmpty) ) myCountEmpty = countEmpty
d2801 22
d3942 1
a3942 1
       "$Id: MLSStringLists.f90,v 2.46 2012/05/08 17:44:30 pwagner Exp $"
d3953 3
@


2.46
log
@BooleanValue now a generic: values may be a string list
@
text
@d124 1
a124 1
!    & [char inseparator])
d126 1
a126 1
!    & [char inseparator])
d128 1
a128 1
!    & [char inseparator])
d2328 2
a2329 1
  subroutine RemoveElemFromList (inList, outList, elem, inseparator)
d2337 1
d2342 1
d2344 1
a2344 1
    CHARACTER (LEN=1)               :: separator
d2352 2
d2357 1
a2357 1
      & .or. StringElementNum(inList, elem, countEmpty=.true., &
d2360 1
a2360 1
    call GetUniqueList(temp_list, unique_list, numUnique, countEmpty=.true., &
d2364 1
d2373 1
a2373 1
  subroutine RemoveListFromList (inList, outList, exclude, inseparator)
d2382 1
a2385 1
    logical, parameter :: countEmpty = .true.
d2388 1
d2393 2
d2397 1
a2397 1
    numElems = NumStringElements(exclude, countEmpty, inseparator)
d2401 2
a2402 2
      call GetStringElement(exclude, elem, i, countEmpty, inseparator)
      call RemoveElemFromList(temp_list, temp_list2, elem, inseparator)
d2409 2
a2410 1
  subroutine RemoveNumFromList (inList, outList, nElement, inseparator)
d2418 1
a2422 2
    character(len=len(inList)+1) :: temp_list
    character (len=1)               :: separator
d2424 1
d2426 2
d2434 2
d2439 1
a2439 1
    num = NumStringElements( inList, countEmpty=.true., inSeparator=inSeparator )
d2445 1
a2445 1
        & countEmpty=.true., inSeparator=inSeparator )
d3846 1
a3846 1
       "$Id: MLSStringLists.f90,v 2.45 2012/01/05 01:18:33 pwagner Exp $"
d3857 3
@


2.45
log
@Capitalized USEd stuff
@
text
@d21 1
a21 1
    & READINTSFROMCHARS, REPLACE, REVERSE, &
d218 4
d344 12
a355 5
  function BooleanValue (str, lkeys, lvalues)
    ! Takes a well-formed formula and returns its value
    ! given a hash of variables and their values
    ! E.g., given 'p and not (q or r)' 
    ! and p=q=TRUE, r=FALSE, returns FALSE
d505 32
a536 1
  end function BooleanValue
d1885 1
a1885 1
    integer :: elem, k
a1890 2
    integer :: nElements
    character (len=len(inList)+2)           :: optionsList ! comma-separated
d3832 1
a3832 1
       "$Id: MLSStringLists.f90,v 2.44 2011/04/20 16:35:15 pwagner Exp $"
d3843 3
@


2.44
log
@Added SnipList
@
text
@d16 7
a22 7
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, &
    & MLSMSG_Allocate, MLSMSG_DeAllocate
  use MLSCommon, only: BareFNLen
  use MLSSets, only: FindFirst
  use MLSStrings, only: Capitalize, lowerCase, ncopies, &
    & ReadIntsFromChars, Replace, reverse, &
    & SplitNest, streq, trim_safe, writeIntsToChars
d3792 1
a3792 1
       "$Id: MLSStringLists.f90,v 2.43 2011/02/18 18:00:10 pwagner Exp $"
d3803 3
@


2.43
log
@Improved optionDetail; added parseOptions to fully parse commandline
@
text
@d75 1
d132 1
d214 1
a214 1
   & ReplaceSubString, ReverseList, &
d2673 28
d3792 1
a3792 1
       "$Id: MLSStringLists.f90,v 2.42 2010/11/05 22:23:01 pwagner Exp $"
d3803 3
@


2.42
log
@Fixed bugs in optionDetail
@
text
@d67 1
d112 6
a117 1
! char* optionDetail(strlist inList, char test_switch, int pattern, char* alt_option )
d210 1
a210 1
   & PutHashElement, ReadIntsFromList, &
d1783 5
a1787 4
  !  'arg' if the option is present and followed immediately by '[arg]'
  ! test_option is a one-character option
  ! alt_option is a multi-character alternate form
  ! E.g., test_option might be 'a' while alt_option might be 'answer'
d1793 2
a1794 2
  !    may catenate single-char test_options; any arg is surrounded by "[]"
  !    multiple-char alt_option preceded by '--'; any arg set off by "="
d1796 2
a1797 2
  !    each single-char test_option preceded by '-'; any arg is set off by a space
  !    multiple-char alt_option preceded by '--'; any arg set off by "="
d1799 9
a1807 2
  !    each single-char test_option preceded by '-'; any arg is set off by a space
  !    multiple-char alt_option preceded by '-'; any arg set off by a space
d1816 1
a1816 1
  ! (because g doesn't outside the '[]' chars)
d1818 1
a1818 1
  ! The behavior may be modified by pattern and alt_option args
d1822 1
a1822 1
  ! (1) If the string list contains a "*" then
d1827 2
a1828 2
  function optionDetail( inList, test_option,&
    & pattern, alt_option ) RESULT (detail)
d1831 5
a1835 1
    character (len=1), intent(in)             :: test_option
a1836 3
    integer, optional, intent(in)             :: pattern
    character (len=*), optional, intent(in)   :: alt_option

d1840 1
d1849 2
d1852 2
d1856 6
d1863 3
a1865 1
    if ( present(pattern) ) myPattern = pattern
d1871 7
d1882 1
a1882 1
        if ( .not. present(alt_option) ) return
d1891 1
a1891 1
        multi = ( index( listBloc, "--" ) > 0 )
d1893 3
a1895 2
          if ( .not. present(alt_option) ) cycle
          k = index(listBloc, '--' // trim(alt_option) // '=' )
d1897 1
d1900 2
a1901 1
          elseif ( index(listBloc, '--' // trim(alt_option) // ' ' ) > 0 ) then
d1907 2
a1908 1
          element = unquote( listBloc, quotes='[', cquotes=']', &
d1912 2
a1913 1
          call extractSubstring( listBloc, element, test_option // '[', ']' )
d1927 1
a1927 1
        if ( .not. present(alt_option) ) return
d1936 1
a1936 1
        multi = ( index( listBloc, "--" ) > 0 )
d1938 3
a1940 2
          if ( .not. present(alt_option) ) cycle
          k = index(listBloc, '--' // trim(alt_option) // '=' )
d1942 1
d1945 2
a1946 1
          elseif ( index(listBloc, '--' // trim(alt_option) // ' ' ) > 0 ) then
d1967 3
a1969 2
    case ( 2 )
      ! '-a -b arg -xyz arg'
d1971 1
a1971 1
        if ( .not. present(alt_option) ) return
d1983 1
a1983 1
          elseif( .not. present(alt_option) ) then
d1985 2
a1986 1
          elseif ( adjustl(listBloc) == '-' // alt_option ) then
d2003 28
d2035 88
d3762 1
a3762 1
       "$Id: MLSStringLists.f90,v 2.41 2010/11/03 18:29:07 pwagner Exp $"
d3773 3
@


2.41
log
@Added optionDetail to tell whether an option is present
@
text
@d66 1
a66 1
! OptionDetail       Returns detail level of option in list of option
d111 1
a111 1
! char* optionDetail(strlist inList, char* test_switch)
d136 1
a136 1
! char* unquote (char* str, [char* quotes], [char* cquotes], [log strict])
d148 8
d157 1
a157 1
! string matches may be interpreted and how string elements are
d166 4
d526 1
a526 1
    str = unquote( Constructor, quotes='[]$', stripany=.true. )
d879 2
d882 1
d890 7
a896 5
    ! Will this still work if sub1 has leading or trailing blanks? 
    ! How about sub2?
    ! Do we need an optional arg, no_trim, say, that will leave them?
    ! Tried coding it, but can't say for sure it works
    ! What if sub1 is a substring of sub2, or vice versa?
d1778 16
d1796 1
a1796 1
  ! "ab[arg1]c[arg2]d"
d1802 1
a1802 1
  ! (because test doesn't outside the '[]' chars)
d1804 1
a1804 1
  ! The behavior may be modified by options flag
d1809 3
a1811 3
  ! the test option is automatically present
  ! (2) Why don't you let the '[]' pair that set off option args be
  ! overridden, say by spaces?
d1813 2
a1814 9
  function optionDetail( inList, test_option ) RESULT (detail)
    ! Method:
    ! (1) Replace all instances of '[] and ']' with ','
    ! (2) Interpret result as string list
    ! (3) Loop over odd-numbered elements of string list
    !     if test_option found among one of them and
    !       it is not the last, then option = 'yes'
    !       it is the last, but so is the element number, then option = 'yes'
    !       it is the last, then option = the next element
d1816 2
a1817 2
    CHARACTER (LEN=*), INTENT(IN)             :: inList
    CHARACTER (LEN=1), INTENT(IN)             :: test_option
d1819 2
d1823 1
d1826 2
d1829 2
a1831 1
    character (len=len(inList)+2)           :: element
d1833 1
d1836 2
d1843 40
a1882 3
    if ( index( inList, test_option ) < 1 ) return
    
    ! OK, test_option is present, but where? Does it have an arg?
d1884 39
a1922 18
    element = Replace( inList, '[', ',' )
    optionsList = Replace( element, ']', ',' )
    do elem = 1, NumStringElements( optionsList, countEmpty ), 2
      element = StringElement(optionsList, elem, countEmpty)
      k = index( element, test_option )
      if ( k < 1 ) then
        cycle
      elseif ( k < len_trim(element) ) then
        detail = 'yes'
        return
      elseif ( elem == NumStringElements( optionsList, countEmpty ) ) then
        detail = 'yes'
        return
      else
        detail = StringElement(optionsList, elem+1, countEmpty)
        return
      endif
    enddo
d1924 36
d3068 3
a3070 2
  function unquote(str, quotes, cquotes, strict, stripany, extract) &
    & result (outstr)
d3082 8
a3089 1
    ! If given optional arg strict, options (1) and (2) above disregarded
d3092 1
a3092 1
    ! If given optional arg stripany, any quotes, surrounding or internal,
d3095 10
a3115 5
    ! If given optional arg extract, returns first substring surrounded by
    ! quotes; E.g., given ([a1 a2], [a3 a4]) with quotes='[' cquotes=']' returns
    !   a1 a2
    ! (This option supersedes stripany, and is automatically strict)
    
d3139 4
a3142 3
    logical, intent(in), optional :: strict
    logical, intent(in), optional :: stripany
    logical, intent(in), optional :: extract
d3153 1
d3166 8
a3173 16
   if(present(extract)) then
      myextract=extract
   else
      myextract=.false.
   endif
   
   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
   
   if(present(stripany)) then
      mystripany=stripany
   else
      mystripany=.false.
d3176 1
a3176 1
   mystripany = mystripany .and. (.not. myextract)
d3213 5
d3240 9
d3260 1
a3260 1
   elseif(present(strict)) then
d3305 29
d3601 1
a3601 1
       "$Id: MLSStringLists.f90,v 2.40 2010/06/22 16:51:32 pwagner Exp $"
d3612 3
@


2.40
log
@default options for switchDetail is '-f'
@
text
@d21 2
a22 1
    & ReadIntsFromChars, reverse, SplitNest, streq, trim_safe, writeIntsToChars
d66 1
d111 1
d191 2
a192 2
   & List2Array, listMatches, PutHashElement, NumStringElements, &
   & ReadIntsFromList, &
d1753 80
a2856 1

d3422 1
a3422 1
       "$Id: MLSStringLists.f90,v 2.39 2010/04/16 23:38:34 pwagner Exp $"
d3433 3
@


2.39
log
@Repaired bug in switchDetail which, e.g., caused '-Sl2pc' to always return '2'
@
text
@d132 1
d2793 3
d2818 2
a2819 2
    myOptions = ''
    if ( present(options) ) myOptions = lowercase(options)
d2831 1
d2833 1
a2833 2
   ! Check for matches--snipping off any leading blanks
   ! (That means 'f' is by default on, contradicting notes above)
d2837 1
d3340 1
a3340 1
       "$Id: MLSStringLists.f90,v 2.38 2009/06/23 18:22:49 pwagner Exp $"
d3351 3
@


2.38
log
@Added ReadIntsfromList
@
text
@d28 1
a28 1
       "$RCSfile: $"
d2787 2
d2810 1
d2833 5
a2837 2
      if (trim(listElement) /= ' ' .and. &
          & index(trim(listElement), trim(switch)) > 0) then
d2840 2
a2841 1
        call ReadIntsFromChars(trim(listElement), detail, ignore="*?")
d3335 1
a3335 1
       "$Id: read_apriori.f90 is it here $"
d3346 3
@


2.37
log
@Added BuildHash to build keys, values arrays from Constructor
@
text
@d28 1
a28 1
       "$RCSfile: MLSStringLists.f90,v $"
d66 1
d111 2
d188 1
d1893 18
d3325 1
a3326 1
!---------------------------- RCS Ident Info -------------------------------
d3328 2
a3329 3
       "$Id: MLSStringLists.f90,v 2.36 2008/12/11 19:39:20 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d3331 1
a3331 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d3333 1
d3339 3
@


2.36
log
@Added print statement to not_used_here
@
text
@d50 2
d85 2
d180 1
a180 1
  public :: Array2List, BooleanValue, catLists, &
d468 47
d3306 1
a3306 1
       "$Id: MLSStringLists.f90,v 2.35 2008/05/21 20:00:19 pwagner Exp $"
d3317 3
@


2.35
log
@Must not increment optional arg unless present
@
text
@d18 1
a18 1
  use MLSCommon, only: i4, BareFNLen
d88 1
a88 1
!   i4 nElement, log countEmpty, [char inseparator])
d121 1
a121 1
!   i4 nElement, log countEmpty, [char inseparator])
d261 1
a261 1
    INTEGER(i4) :: listElem, arrayElem, nElems
d947 1
a947 1
    INTEGER(i4), INTENT(IN)         :: nElement ! Entry number to return
d952 2
a953 2
    INTEGER(i4) :: i           ! Loop counters
    INTEGER(i4) :: elem, nextseparator
d1038 1
a1038 1
    integer(i4) :: elem
d1077 1
a1077 1
    integer(i4) :: elem
d1136 1
a1136 1
    INTEGER(i4) :: elem
d1550 1
a1550 1
    INTEGER(i4) :: elem, nElems
d2160 1
a2160 1
    INTEGER(i4) :: i, istr, irev, elem, iBuf
d2273 1
a2273 1
    INTEGER(i4) :: elem, nElems
a2275 3
!    integer, dimension(MAXELEM)           :: chValue, cvInvBN
!    integer, dimension(MAXELEM)           :: binNumber, invBinNumber
!    integer, dimension(MAXELEM)           :: jsort, inTheBin
d2532 1
a2532 1
    INTEGER(i4) :: nElems, status, LongestLen
d2605 1
a2605 1
    INTEGER(i4), INTENT(IN)         :: nElement  ! Entry number to return
d3255 1
a3255 1
       "$Id: MLSStringLists.f90,v 2.34 2008/05/09 00:24:08 pwagner Exp $"
d3259 1
d3266 3
@


2.34
log
@New features added to wrap; useful for wrapLines and l2cf
@
text
@d3117 1
d3149 1
a3149 1
          addedLines = addedLines + 1
d3159 2
d3164 1
a3164 1
          addedLines = addedLines + 1
d3179 1
a3179 1
          addedLines= addedLines + 1
d3196 1
a3196 1
            addedLines= addedLines + 1
d3258 1
a3258 1
       "$Id: MLSStringLists.f90,v 2.33 2008/05/02 00:08:13 pwagner Exp $"
d3268 3
@


2.33
log
@wrap subroutine may now operate in soft mode
@
text
@d20 2
a21 2
  use MLSStrings, only: Capitalize, lowerCase, &
    & ReadIntsFromChars, reverse, SplitNest, streq, writeIntsToChars
d123 1
a123 1
!    & [char inseparator], [log part_match])
d126 2
a127 1
! wrap ( char* str, char* outstr, int width, [char inseparator] )
d2994 9
a3002 3
  subroutine wrap( str, outstr, width, inseparator, break, mode )
    ! Wrap str by putting separators as line feed so no
    ! line exceeds width
d3010 78
d3095 1
d3097 1
d3111 2
d3119 1
d3123 1
d3129 1
d3143 1
d3148 1
d3151 1
a3151 1
          dsnext = findFirst( str(sp:), ' ', reverse=.true. )
d3156 1
d3161 1
d3170 1
d3176 1
d3179 1
a3179 1
          dsnext = findFirst( str(sp:), ' ', reverse=.true. )
d3184 1
a3184 1
          dsp = index( str(so+nextwidth-1:), myBreak )
d3186 1
d3193 1
d3196 1
a3196 1
            dsnext = findFirst( str(sp:), ' ', reverse=.true. )
d3203 1
d3211 2
a3212 1
  end subroutine wrap
d3255 1
a3255 1
       "$Id: MLSStringLists.f90,v 2.32 2008/01/23 21:24:43 pwagner Exp $"
d3265 3
@


2.32
log
@RemoveNumFromList works with inseparator correctly
@
text
@d2993 1
a2993 1
  subroutine wrap( str, outstr, width, inseparator )
d3000 3
a3002 1
    character (len=*), optional, intent(in)       :: inseparator
d3004 1
a3004 1
    character (len=1)               :: separator
d3008 3
d3020 4
d3040 69
a3108 19
      ! Do we have any breakable spaces in next width?
      dsp = index( str(so:so+nextwidth-1), ' ', back=.true. )
      ! print *, 'so, ko ', so, ko
      ! print *, 'dsp ', dsp
      if ( dsp > 0 ) then
        ! Yes, so we break there
        sp = so - 1 + dsp
        outstr(ko:ko+dsp-1) = str(so:sp-1) // separator
        ko = ko + dsp
        ! Now treat possibility that next chars might be spaces, too
        dsnext = findFirst( str(sp:), ' ', reverse=.true. )
        if ( dsnext < 1 ) exit
        so = sp + dsnext - 1
      else
        ! No, so we hyphenate
        outstr(ko:ko+nextwidth-1) = str(so:so+nextwidth-3) // '-' // separator
        ko = ko + nextwidth
        so = so + nextwidth - 2
      endif
d3153 1
a3153 1
       "$Id: MLSStringLists.f90,v 2.31 2007/12/19 01:28:29 pwagner Exp $"
d3163 3
@


2.31
log
@Removed unused variables
@
text
@d1943 1
a1943 1
      outList = catLists( outList, trim(elem) )
d3094 1
a3094 1
       "$Id: MLSStringLists.f90,v 2.30 2007/09/20 17:39:59 pwagner Exp $"
d3104 3
@


2.30
log
@Added wrap procedure
@
text
@d18 1
a18 1
  use MLSCommon, only: i4, NameLen, BareFNLen
a2612 3
    INTEGER(i4) :: i           ! Loop counters
    INTEGER(i4) :: elem, nextseparator

d3094 1
a3094 1
       "$Id: MLSStringLists.f90,v 2.29 2007/07/31 22:46:51 pwagner Exp $"
d3104 3
@


2.29
log
@Added listMatches
@
text
@d75 2
d126 1
d183 1
a183 1
   & unquote
d2995 61
d3097 1
a3097 1
       "$Id: MLSStringLists.f90,v 2.28 2007/06/26 00:19:21 pwagner Exp $"
d3107 3
@


2.28
log
@Workaround another Intel bug; may expand string range into reals
@
text
@d41 2
a42 1
!     (parameters)
d61 1
d99 1
d141 2
d144 2
a145 2
! The above is to replace the countEmpty, caseSensitive, etc. that are
! separate optional args to many of the current module procedures
d176 1
a176 1
   & List2Array, PutHashElement, NumStringElements, &
d211 3
d227 6
d1578 41
d2992 38
a3029 1
!=============================================================================
d3033 1
a3033 1
       "$Id: MLSStringLists.f90,v 2.27 2007/06/21 00:49:52 vsnyder Exp $"
d3043 3
@


2.27
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d193 1
a193 1
      & ExpandStringRange_log
d610 29
d643 4
a646 2
    ! (simple) 'n-m' integers from n to m inclusive, where m > n
    ! (stride) 'n-m+s' integers from n to m with stride s, where s > 0
d649 1
d660 4
d668 1
d672 4
d677 1
a677 1
    integer :: m
d679 1
a679 1
    integer :: n
d683 1
a683 1
    integer :: s
d687 3
d694 5
a698 1
    dashpos = index(instr, '-')
d702 1
a702 1
      call GetStringElement (instr, tempstr, elem, countEmpty)
d704 6
a709 1
      if ( dashpos > 0 ) then
d716 1
d719 1
d722 1
a729 3
        read(nChar, *, iostat=ErrTyp) n
        if ( ErrTyp == 0 ) read(mChar, *, iostat=ErrTyp) m
        if ( ErrTyp == 0 .and. sChar /= '') read(sChar, *, iostat=ErrTyp) s
d733 32
a764 5
        ! print *, 'n, m, s: ', n, m, s
        tempstr = ''
        if ( m >= n ) then
          do t=n, m, s
            write(tChar, '(i16)') t
d819 2
a820 2
    character (len=max(len(str), len(outstr))) :: tmpstr
    character (len=max(len(str), len(outstr))) :: tmpstr2
d2941 1
a2941 1
       "$Id: MLSStringLists.f90,v 2.26 2007/05/22 20:56:02 vsnyder Exp $"
d2951 3
@


2.26
log
@Don't use list-directed write to internal files
@
text
@d265 1
a265 1
	 listElem = 1
d697 1
a697 1
	 ! Defaults to choosing only the first occurrence of sub1 and sub2
d849 1
a849 1
    INTEGER(i4), INTENT(IN)         :: nElement 	! Entry number to return
d861 9
a869 9
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF

	 IF(nElement.LE.0) THEN
	     outElement = separator
	 ELSEIF(LEN(inList) < nElement) THEN
	     outElement = separator
d872 1
a872 1
	 elem = 1
d874 1
a874 1
	     nextseparator = i - 1 + INDEX(inList(i:), separator)
d876 38
a913 38
	! No more separators
		  IF(nextseparator == i - 1) THEN
		      IF(elem >= nElement) THEN
				    outElement = inList(i:)
			    ELSE
				    outElement = separator
			    ENDIF
				 RETURN

	! Next separator is the adjacent char
			ELSEIF(nextseparator == i) THEN
				IF(countEmpty) THEN
		     	 IF(elem >= nElement) THEN
				    	outElement = BLANK
						RETURN
			   	 ELSE
					 	elem = elem+1
			    	ENDIF
				ENDIF

	! Until next separator is the next element
			ELSE
		      IF(elem >= nElement) THEN
				    IF(i < nextseparator) THEN
				       outElement = inList(i:nextseparator-1)
						ELSE
				       outElement = separator
						ENDIF
   				 RETURN
			    ELSEIF(nextseparator >= LEN(inList)) THEN
				    outElement = separator
				    RETURN
			    ELSE
					 elem = elem+1
			    ENDIF
			ENDIF
			i = nextseparator+1
	 ENDDO
d946 4
a949 4
	     separator = inseparator
	 else
	     separator = comma
	 endif
d951 3
a953 3
	 elem = StringElementNum(keys, key, countEmpty, inseparator, part_match)
	 if( elem <= 0 ) then
	 elseif( elem > size(values) ) then
d955 1
a955 1
	 else
d957 1
a957 1
	 endif
d985 4
a988 4
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF
d990 3
a992 3
	 elem = StringElementNum(keys, key, countEmpty, inseparator, part_match)
	 if( elem <= 0 ) then
	 elseif( elem > size(values) ) then
d994 1
a994 1
	 else
d996 1
a996 1
	 endif
d1044 10
a1053 10
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF

	elem = StringElementNum(keyList, key, countEmpty, inseparator, part_match)
	IF(elem <= 0) THEN
		outElement = separator
	ELSE
		CALL GetStringElement(hashList, outElement, elem, &
d1055 1
a1055 1
	ENDIF
d1459 4
a1462 4
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF
d1465 4
a1468 4
	     myIgnoreLeadingSpaces = IgnoreLeadingSpaces
	 ELSE
	     myIgnoreLeadingSpaces = .false.
	 ENDIF
d1472 1
a1472 1
	 elem = 1
d1480 1
a1480 1
	 ENDDO
d1506 1
a1506 1
	 INTEGER                                   :: nElements
d1512 1
a1512 1
	 LOGICAL :: lastWasNotseparated
d1518 4
a1521 4
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF
d1523 1
a1523 1
	! Count the number of separators
d1526 3
a1528 3
	! nElements-1 = number of separators
	IF(LEN_TRIM(inList) <= 0) THEN
		nElements=0
d1530 5
a1534 5
		RETURN
	ENDIF
	
	lastWasNotseparated = .FALSE.
	nElements = 1
d1536 4
a1539 4
	DO i=1, LEN_TRIM(inList)
		IF(inList(i:i) == separator) THEN
			IF(countEmpty .OR. lastWasNotseparated) THEN
				nElements = nElements+1
d1542 8
a1549 8
			ENDIF
			lastWasNotseparated = .FALSE.
         sinceLastseparated = 0
		ELSE
			lastWasNotseparated = .TRUE.
         sinceLastseparated = sinceLastseparated + 1
		ENDIF
	ENDDO
d1580 4
a1583 4
	     separator = inseparator
	 else
	     separator = comma
	 endif
d1585 2
a1586 2
	 num = StringElementNum(keys, key, countEmpty, inseparator, part_match)
	 if( num > 0 .and. num <= size(values) ) then
d1590 1
a1590 1
	 else
d1595 1
a1595 1
	endif
d1618 4
a1621 4
	     separator = inseparator
	 else
	     separator = comma
	 endif
d1623 2
a1624 2
	 num = StringElementNum(keys, key, countEmpty, inseparator, part_match)
	 if( num > 0 .and. num <= size(values) ) then
d1628 1
a1628 1
	 else
d1633 1
a1633 1
	endif
d1681 11
a1691 11
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF

	num = StringElementNum(keyList, key, countEmpty, inseparator, part_match)
	if( num > 0) then
		call RemoveNumFromList( keyList, keys, num, inseparator )
		call RemoveNumFromList( hashList, hash, num, inseparator )
	else
		keys = keyList
d1693 3
a1695 3
	endif
   keyList = catLists(keys, key)
   hashList = catLists(hash, elem)
d1702 1
a1702 1
	 ! E.g., given 'a,b,c,d,..,z' and asked to remove 'c' returns 'a,b,d,..z'
d1742 1
a1742 1
	 ! E.g., given 'a,b,c,d,..,z' and asked to remove 'c,a' returns 'b,d,..z'
d1774 1
a1774 1
	 ! E.g., given 'a,b,c,d,..,z' and asked to remove number 3 returns 'a,b,d,..z'
d1812 1
a1812 1
	 ! Defaults to replacing only the first
d2009 1
a2009 1
	 ! and returns one with elements in reversed order
d2011 1
a2011 1
	 ! E.g., given "alpha, beta, gamma" => "gamma, beta, alpha"
d2013 2
a2014 2
	 ! Limitation:
	 ! No element may be longer than MAXWORDLENGTH
d2027 1
a2027 1
	LOGICAL, PARAMETER :: countEmpty = .TRUE.    
d2031 4
a2034 4
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF
d2039 1
a2039 1
	 
d2041 1
a2041 1
	 ALLOCATE(charBuf(LEN(str)+1), STAT=istr)
d2043 1
a2043 1
	 	CALL MLSMessage(MLSMSG_Error,ModuleName, &
d2045 2
a2046 2
		RETURN
	ENDIF
d2051 29
a2079 29
	elem = 1
	iBuf=0
	DO
		CALL GetStringElement(str, word, elem, countEmpty, separator)
		IF(word == separator) THEN
			EXIT
		ELSEIF(iBuf > LEN(str)) THEN
			EXIT
		ELSE
			istr = MAX(LEN_TRIM(word), 1)
			word = Reverse(word(:istr))
			DO i=1, istr
				iBuf=iBuf+1
				charBuf(iBuf) = word(i:i)
			ENDDO
			iBuf=iBuf+1
			charBuf(iBuf) = separator
			elem = elem+1
		ENDIF
	ENDDO
	
	IF(charBuf(iBuf) == separator) THEN
		iBuf = iBuf-1
	ENDIF
	
	DO i=1, iBuf
		irev = iBuf - i + 1
		outstr(irev:irev) = charBuf(i)
	ENDDO
d2081 1
a2081 1
	DEALLOCATE(charBuf)
d2158 4
a2161 4
	     myshorterFirst = shorterFirst
	 ELSE
	     myshorterFirst = .false.
	 ENDIF
d2163 4
a2166 4
	     myleftRight = Capitalize(leftRight)
	 ELSE
	     myleftRight = "L"
	 ENDIF
d2270 1
a2270 1
	 ENDDO
d2405 4
a2408 4
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF
d2411 4
a2414 4
	     myleftRight = Capitalize(leftRight)
	 ELSE
	     myleftRight = "L"
	 ENDIF
d2469 1
a2469 1
    INTEGER(i4), INTENT(IN)         :: nElement 	! Entry number to return
d2482 4
a2485 4
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF
d2531 1
a2531 1
	 INTEGER                                   :: elem
d2543 12
a2554 12
	nElements = NumStringElements(inList, countEmpty, inseparator)
	
	IF(nElements <= 0) THEN
		elem = 0
		RETURN
	ENDIF
   match = .false.
   if ( present(part_match) ) match = part_match

	! Check for matches--snipping off any leading blanks
	DO elem=1, nElements
		CALL GetStringElement(inList, listElement, elem, countEmpty, inseparator)
d2559 1
a2559 1
  	     IF(adjustl(listElement) == adjustl(test_string)) RETURN
d2561 3
a2563 3
	ENDDO
	
	elem = 0
d2609 9
a2617 9
	nElements = NumStringElements(inList, countEmpty)
	
	IF ( nElements <= 0 .or. test_switch == "" ) Return
   
   if ( index(myOptions, 'c') > 0 ) then
     switch = lowercase(test_switch)
   else
     switch = test_switch
   endif
d2619 1
a2619 1
	! Check for matches--snipping off any leading blanks
d2621 2
a2622 2
	DO elem=1, nElements
		CALL GetStringElement(inList, listElement, elem, countEmpty)
d2631 1
a2631 1
	ENDDO
d2633 1
a2633 1
  	if ( index(myOptions, 'w') > 0 .and. index(inList, '*') > 0 ) &
d2861 1
a2861 1
       "$Id: MLSStringLists.f90,v 2.25 2007/05/14 21:51:51 pwagner Exp $"
d2871 3
@


2.25
log
@Bugfix for way ifc writes ints to strings
@
text
@d684 1
a684 1
            write(tChar, *) t
d2861 1
a2861 1
       "$Id: MLSStringLists.f90,v 2.24 2007/04/20 22:27:49 pwagner Exp $"
d2871 3
@


2.24
log
@Minor change to keep buggy Intel compiler from producing code that bombs
@
text
@d317 1
a317 1
    character(len=8) :: vChar
d547 1
a547 1
    character(len=8) :: iChar
d582 1
a582 1
    character(len=8) :: iChar
d637 1
a637 1
    character (len=8) :: mChar
d639 1
a639 1
    character (len=8) :: nChar
d643 1
a643 1
    character (len=8) :: sChar
d645 1
a645 1
    character (len=8) :: tChar
d2861 1
a2861 1
       "$Id: MLSStringLists.f90,v 2.23 2006/07/12 20:37:44 pwagner Exp $"
d2871 3
@


2.23
log
@inseparator may be any length; even 0
@
text
@d459 2
a460 2
    character (len=1)               :: separator
    character (len=8), dimension(1) :: str2
d2861 1
a2861 1
       "$Id: MLSStringLists.f90,v 2.22 2006/04/21 23:57:05 pwagner Exp $"
d2871 3
@


2.22
log
@Small correction to comments on api for SwitchDetail
@
text
@d238 1
a238 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
d455 1
a455 1
    character (len=1), optional, intent(in)       :: inseparator
d488 1
a488 1
    character (len=1), optional, intent(in)       :: inseparator
d514 1
a514 1
    character (len=1), optional, intent(in)       :: inseparator
d851 1
a851 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
d936 1
a936 1
    character (len=1), optional, intent(in)   :: inseparator
d975 1
a975 1
    character (len=1), optional, intent(in)   :: inseparator
d1034 1
a1034 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
d1175 1
a1175 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
d1448 1
a1448 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
d1507 1
a1507 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
d1569 1
a1569 1
    character (len=1), optional, intent(in)   :: inseparator
d1607 1
a1607 1
    character (len=1), optional, intent(in)   :: inseparator
d1669 1
a1669 1
    character (len=1), optional, intent(in)   :: inseparator
d1707 1
a1707 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
d1747 1
a1747 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
d1779 1
a1779 1
    character (len=1), optional, intent(in)       :: inseparator
d2018 1
a2018 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
d2389 1
a2389 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)       :: inseparator
d2471 1
a2471 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
d2532 1
a2532 1
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
d2861 1
a2861 1
       "$Id: MLSStringLists.f90,v 2.21 2006/03/03 23:06:35 pwagner Exp $"
d2871 3
@


2.21
log
@Added Intersection function
@
text
@d119 1
a119 1
! int SwitchDetail(strlist inList, char* test_switch)
d2584 3
d2607 1
d2611 1
a2611 4
	IF ( nElements <= 0 .or. test_switch == "" ) THEN
		detail = -1
		RETURN
	ENDIF
d2633 2
a2634 5
  	if ( index(myOptions, 'w') > 0 .and. index(inList, '*') > 0 ) then
     detail = 0
   else
     detail = -1
   endif
d2861 1
a2861 1
       "$Id: MLSStringLists.f90,v 2.20 2006/02/24 01:14:54 pwagner Exp $"
d2871 3
@


2.20
log
@Added BooleanValue to evaluate boolean formulas
@
text
@d57 1
d93 1
d161 4
d170 1
a170 1
   & GetUniqueInts, GetUniqueStrings, GetUniqueList, IsInList, &
d1352 38
d2863 1
a2863 1
       "$Id: MLSStringLists.f90,v 2.19 2006/02/21 19:06:25 pwagner Exp $"
d2873 3
@


2.19
log
@Made Get, PutHashElement routines generic
@
text
@d21 1
a21 1
    & ReadIntsFromChars, reverse, streq, writeIntsToChars
d48 1
d77 1
d161 1
a161 1
  public :: Array2List, catLists, &
d283 157
d2653 1
a2653 1
    character(len=*),intent(in), optional :: quotes
d2819 1
a2819 1
       "$Id: MLSStringLists.f90,v 2.18 2006/02/16 00:59:08 pwagner Exp $"
d2829 3
@


2.18
log
@Fixed bug preventing "?" switch from working properly
@
text
@a50 1
! GetIntHashElement  Returns int from hash array corresponding to key string
d52 1
a52 2
! GetStringHashElement   
!                    Returns string from hash list corresponding to key string
a57 2
! MakeStringHashElement   
!                    Replaces string from hash list corresponding to key string
d59 1
a79 2
! int GetIntHashElement (strlist keyList, hashArray(:), char* key, 
!   int ErrType, log countEmpty, [char inseparator], [log part_match])
d82 1
a82 1
! GetStringHashElement (strlist keyList, strlist hashList, char* key, 
a92 2
! MakeStringHashElement (strlist keyList, strlist hashList, char* key, 
!   char* elem, log countEmpty, [char inseparator], [log part_match])
d95 2
d121 2
a122 4
! a hash is a list of key strings and either
! (1) a list of associated strings
! (2) an array of associated integers
! (an idea called a hash in perl or a dictionary in python)
d153 4
d161 1
a161 1
   & GetIntHashElement, GetStringElement, GetStringHashElement, &
d163 1
a163 1
   & List2Array, MakeStringHashElement, NumStringElements, &
d173 10
d188 10
d199 1
a199 1
  ! GetIntHashElement
a661 57
  ! ---------------------------------------------  GetIntHashElement  -----

  ! This function takes one (usually) comma-separated string list, interprets it
  ! it as a list of elements, and an array of ints
  ! treating the list as keys and the array as
  ! a hash table, associative array or dictionary
  ! It returns the int from the hash table corresponding to the key
  ! If the key is not found in the array of keys, it sets ErrType=KEYNOTFOUND
  ! otherwise ErrType=0
  
  ! This is useful because many of the hdfeos routines *inq*() return
  ! comma-separated lists

  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! Another optional arg, part_match, returns a match for the 
  ! first hash element merely found in the key; e.g.
  ! 'won, to, tree' and key 'protocol.dat' matches 'to'

  ! Basic premise: Use StringElementNum on key in keyList to find index
  ! Use this index for the array of ints

  function GetIntHashElement(keyList, hashArray, key, ErrType, &
  & countEmpty, inseparator, part_match) RESULT (hashInt)
    ! Dummy arguments
    CHARACTER (LEN=*), INTENT(IN)             :: keyList
    INTEGER, DIMENSION(:), INTENT(IN)         :: hashArray
    INTEGER                                   :: hashInt
    CHARACTER (LEN=*), INTENT(IN)             :: key
    INTEGER, INTENT(OUT)                      :: ErrType
    LOGICAL, INTENT(IN)                       :: countEmpty
    CHARACTER (LEN=1), OPTIONAL, INTENT(IN)   :: inseparator
    LOGICAL, OPTIONAL, INTENT(IN)             :: part_match

    ! Local variables
	INTEGER :: elem

    ! Executable code

   ErrType = 0
	elem = StringElementNum(keyList, key, countEmpty, inseparator, part_match)
	hashInt = elem
	IF(elem <= 0) THEN
		ErrType = KEYNOTFOUND
	ELSEIF(elem > SIZE(hashArray)) THEN
		ErrType = KEYBEYONDHASHSIZE
	ELSE
		hashInt = hashArray(elem)
	ENDIF

  end function GetIntHashElement

d752 66
a817 1
  ! ---------------------------------------------  GetStringHashElement  -----
d819 19
a837 1
  ! This subroutine takes two (usually) comma-separated string lists, interprets it
a862 2
  subroutine GetStringHashElement(keyList, hashList, key, outElement, &
  & countEmpty, inseparator, part_match)
d892 1
a892 1
  end subroutine GetStringHashElement
a1280 64
  ! ---------------------------------------------  MakeStringHashElement  -----

  ! This subroutine takes two (usually) comma-separated string lists, interprets it
  ! each as a list of elements, treating the first as keys and the second as
  ! a hash table, associative array or dictionary
  ! It replaces with elem the sub-string from the hash table corresponding to the key
  ! If the key is not found in the array of keys, it adds a new key

  ! If countEmpty is TRUE, consecutive separators, with no chars in between,
  ! are treated as enclosing an empty element
  ! Otherwise, they are treated the same as a single separator
  ! E.g., "a,b,,d" has 4 elements if countEmpty TRUE, 3 if FALSE
  ! If TRUE, the elements would be {'a', 'b', ' ', 'd'}

  ! As an optional arg the separator may supplied, in case it isn't comma
  ! Another optional arg, part_match, returns a match for the 
  ! first hash element merely found in the key; e.g.
  ! 'won, to, tree' and key 'protocol.dat' matches 'to'

  ! Basic premise: Find the element number corresponding to the key
  ! If found remove that element from both key and hash list
  ! Then add new key and hash to lists

  ! Someday you may wish to define a StringHash_T made up of the two
  ! strings
  
  subroutine MakeStringHashElement(keyList, hashList, key, elem, &
  & countEmpty, inseparator, part_match)
    ! Dummy arguments
    character (len=*), intent(inout)   :: keyList
    character (len=*), intent(inout)   :: hashList
    character (len=*), intent(in)      :: key
    character (len=*), intent(in)      :: elem
    logical, intent(in)   :: countEmpty
    character (len=1), optional, intent(in)   :: inseparator
    logical, optional, intent(in)             :: part_match

    ! Local variables
    integer                                    :: num
    character (LEN=1)                          :: separator
    character(len=len(keyList)+len(key)+1)     :: keys
    character(len=len(hashList)+len(elem)+1)   :: hash

    ! Executable code

    IF(PRESENT(inseparator)) THEN
	     separator = inseparator
	 ELSE
	     separator = COMMA
	 ENDIF

	num = StringElementNum(keyList, key, countEmpty, inseparator, part_match)
	if( num > 0) then
		call RemoveNumFromList( keyList, keys, num, inseparator )
		call RemoveNumFromList( hashList, hash, num, inseparator )
	else
		keys = keyList
      hash = hashList
	endif
   keyList = catLists(keys, key)
   hashList = catLists(hash, elem)

  end subroutine MakeStringHashElement

d1352 144
d2660 1
a2660 1
       "$Id: MLSStringLists.f90,v 2.17 2006/01/26 00:31:46 pwagner Exp $"
d2670 3
@


2.17
log
@Added RemoveNumFromList, MakeStringHashElement
@
text
@d2301 3
a2303 1
        call ReadIntsFromChars(trim(listElement), detail, ignore="*")
a2368 1
    
d2539 1
a2539 1
       "$Id: MLSStringLists.f90,v 2.16 2005/11/11 21:39:12 pwagner Exp $"
d2549 3
@


2.16
log
@added stringElement function (should we keep GetStringElement?)
@
text
@d60 2
d63 1
a63 1
! RemoveElemFromList removes occurrence(s) of elem in a string list
d65 1
d98 2
d106 2
d166 3
a168 2
   & List2Array, NumStringElements, &
   & RemoveElemFromList, RemoveListFromList, ReplaceSubString, ReverseList, &
d192 2
a220 2
    CHARACTER (LEN=1), PARAMETER    :: BLANK = ' '   ! Returned for any element empty
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
a276 1
    character (len=1), parameter    :: COMMA = ','
a335 1
    character (len=1), parameter    :: COMMA = ','
a732 2
    CHARACTER (LEN=1), PARAMETER    :: BLANK = ' '   ! Returned if element empty
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
d832 1
a832 1
	INTEGER(i4) :: elem
a833 1
    CHARACTER (LEN=1), PARAMETER               :: COMMA = ','
a975 1
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
a1210 2
    CHARACTER (LEN=1), PARAMETER    :: BLANK = ' '   ! Returned for any element empty
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
d1240 64
a1334 1
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
a1389 2
    CHARACTER (LEN=1), PARAMETER    :: BLANK = ' '   ! Returned for any element empty
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
d1447 38
a1699 1
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
a1825 1
    CHARACTER (LEN=1), PARAMETER           :: BLANK = ' '
a2074 1
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
a2154 2
    CHARACTER (LEN=1), PARAMETER    :: BLANK = ' '   ! Returned if element empty
    CHARACTER (LEN=1), PARAMETER    :: COMMA = ','
d2538 1
a2538 1
       "$Id: MLSStringLists.f90,v 2.15 2005/10/18 22:52:04 pwagner Exp $"
d2548 3
@


2.15
log
@Added IsInList function
@
text
@d67 1
d109 2
d127 2
a128 1
! string matches may be interpreted
d133 1
d138 5
d161 1
a161 1
   & SortArray, SortList, StringElementNum, SwitchDetail, &
d2036 36
d2444 1
a2444 1
       "$Id: MLSStringLists.f90,v 2.14 2005/09/22 23:33:58 pwagner Exp $"
d2454 3
@


2.14
log
@date conversion procedures and functions all moved into dates module
@
text
@d21 1
a21 1
    & ReadIntsFromChars, reverse, writeIntsToChars
d58 1
d91 1
d148 1
a148 1
   & GetUniqueInts, GetUniqueStrings, GetUniqueList, &
d1134 36
d2398 1
a2398 1
       "$Id: MLSStringLists.f90,v 2.13 2005/09/14 22:53:26 pwagner Exp $"
d2408 3
@


2.13
log
@Added dai_to_yyyymmdd
@
text
@a48 1
! dai_to_yyyymmdd    Converts days after Jan 1, 2001 to yyyymmdd
a68 4
! utc_to_date        Returns date portion from dateTtime; e.g. yyyy-dddThh:mm:ss
! utc_to_time        Returns time portion from dateTtime; e.g. yyyy-dddThh:mm:ss
! utc_to_yyyymmdd    Parses yyyy-mm-ddThh:mm:ss.sss or yyyy-dddThh:mm:ss.sss
! yyyymmdd_to_dai    Converts yyyymmdd to days after Jan 1, 2001
a74 2
! dai_to_yyyymmdd (int dai, int yyyy, int mm, int dd, [char* startingDate])
! dai_to_yyyymmdd (int dai, char* str, [char* startingDate])
a109 2
! yyyymmdd_to_dai (int yyyy, int mm, int dd, int dai, [char* startingDate])
! yyyymmdd_to_dai (char* str, int dai, [char* startingDate])
d144 1
a144 1
   & dai_to_yyyymmdd, ExpandStringRange, ExtractSubString, &
d150 1
a150 1
   & unquote, utc_to_date, utc_to_time, utc_to_yyyymmdd, yyyymmdd_to_dai
a155 4
  interface dai_to_yyyymmdd
    module procedure dai_to_yyyymmdd_str, dai_to_yyyymmdd_ints
  end interface

a160 12
  interface switch
    module procedure switch_ints
  end interface

  interface utc_to_yyyymmdd
    module procedure utc_to_yyyymmdd_strs, utc_to_yyyymmdd_ints
  end interface

  interface yyyymmdd_to_dai
    module procedure yyyymmdd_to_dai_str, yyyymmdd_to_dai_ints
  end interface

a164 2
  ! utc_to_yyyymmdd
  integer, public, parameter :: INVALIDUTCSTRING = 1
d172 1
a172 10
  integer, parameter :: YEARMAX = 4999  ! Conversion invalid after 4999 AD
  ! The following arrys contains the maximum permissible day for each month
  ! where month=-1 means the whole year, month=1..12 means Jan, .., Dec
  integer, dimension(-1:12), parameter :: DAYMAXLY = (/ &
    & 366, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &
    & /)
  integer, dimension(-1:12), parameter :: DAYMAXNY = (/ &
    & 365, 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &
    & /)
CONTAINS
d187 1
a187 1
  SUBROUTINE Array2List ( inArray, outList, inseparator, ordering, leftRight )
d242 1
a242 1
  END SUBROUTINE Array2List
a333 81
  ! ---------------------------------------------  dai_to_yyyymmdd_ints  -----
  subroutine dai_to_yyyymmdd_ints(dai, yyyy, mm, dd, startingDate)
    ! Routine that given the number of days after a starting date
    ! returns 3 ints: the form yyyymmdd
    !--------Argument--------!
    integer, intent(in)  :: dai
    integer, intent(out) :: yyyy
    integer, intent(out) :: mm
    integer, intent(out) :: dd
    character(len=*), intent(in), optional :: startingDate  ! If not Jan 1 2001
    !----------Local vars----------!
    integer :: doy1
    integer :: ErrTyp
    integer :: loss
    integer :: mydai
    character(len=8) :: mystartingDate
    !----------Executable part----------!
   if(present(startingDate)) then
      mystartingDate=startingDate
   else
      mystartingDate='20010101'
   endif
   call utc_to_yyyymmdd_ints(mystartingDate, ErrTyp, yyyy, mm, dd, nodash=.true.)
   if ( dai < 1 ) return
   call yyyymmdd_to_doy_str(mystartingDate, doy1)
   ! Here's what we do:
   ! Given doy1 (the day-of-year of the starting date)
   ! we keep trying to add dai to it
   ! If the result is greater than the number of days in that year (yyyy),
   ! we increment the starting date's year counter (yyyy), its doy1,
   ! and reduce the dai accordingly and try again
   ! If the result is less than the number of days in that year
   ! Then compute mm and dd for yyyy-(doy1+dai)
   mydai = dai
   do
     if ( mydai + doy1 <= daysinyear(yyyy) ) exit
     ! What we said we'd do
     loss = daysinyear(yyyy) - doy1 + 1
     yyyy = yyyy + 1
     doy1 = 1
     mydai = mydai - loss
   enddo
   ! Now convert from doy to mmdd
   doy1 = 0 ! How many days into year yyyy added by prior months
   do mm=1, 12
     if ( leapyear(yyyy) ) then
       if ( doy1 + DAYMAXLY(mm) > mydai ) exit
       doy1 = doy1 + DAYMAXLY(mm)
     else
       if ( doy1 + DAYMAXNY(mm) > mydai ) exit
       doy1 = doy1 + DAYMAXNY(mm)
     endif
   enddo
   dd = mydai - doy1 + 1
  end subroutine dai_to_yyyymmdd_ints

  ! ---------------------------------------------  dai_to_yyyymmdd_str  -----
  subroutine dai_to_yyyymmdd_str(dai, str, startingDate)
    ! Routine that given the number of days after a starting date
    ! returns a string: the form yyyymmdd
    !--------Argument--------!
    integer, intent(in)           :: dai
    character(len=*), intent(out) :: str
    character(len=*), intent(in), optional :: startingDate  ! If not Jan 1 2001
    ! Internal variables
    integer :: yyyy, mm, dd
    character(len=8) :: year, month, day
    ! executable
    call dai_to_yyyymmdd(dai, yyyy, mm, dd, startingDate)
    ! print *, 'dai: ', dai
    ! print *, 'yyyy: ', yyyy
    ! print *, 'mm: ', mm
    ! print *, 'dd: ', dd
    call writeIntsToChars(yyyy , year )
    call writeIntsToChars(mm   , month, fmt='(i2.2)')
    call writeIntsToChars(dd   , day  , fmt='(i2.2)')
    str(1:4) = adjustl(year )
    str(5:6) = adjustl(month)
    str(7:8) = adjustl(day  )
  end subroutine dai_to_yyyymmdd_str

d495 1
a495 1
  SUBROUTINE ExtractSubString (instr, outstr, sub1, sub2, how, no_trim)
d625 1
a625 1
  END SUBROUTINE ExtractSubString
d654 1
a654 1
  FUNCTION GetIntHashElement(keyList, hashArray, key, ErrType, &
d682 1
a682 1
  END FUNCTION GetIntHashElement
d702 1
a702 1
  SUBROUTINE GetStringElement(inList, outElement, nElement, countEmpty, inseparator)
d774 1
a774 1
  END SUBROUTINE GetStringElement
d804 1
a804 1
  SUBROUTINE GetStringHashElement(keyList, hashList, key, outElement, &
d836 1
a836 1
  END SUBROUTINE GetStringHashElement
d850 1
a850 1
  SUBROUTINE GetUniqueInts(ints, outs, noUnique, extra, fillValue, minValue)
d947 1
a947 1
  SUBROUTINE GetUniqueList(str, outStr, noUnique, countEmpty, &
d1026 1
a1026 1
  END SUBROUTINE GetUniqueList
d1037 1
a1037 1
  SUBROUTINE GetUniqueStrings(inList, outList, noUnique, extra, fillValue)
d1148 1
a1148 1
  SUBROUTINE List2Array(inList, outArray, countEmpty, inseparator, &
d1190 1
a1190 1
  END SUBROUTINE List2Array
d1209 1
a1209 1
  FUNCTION NumStringElements(inList, countEmpty, &
d1262 1
a1262 1
  END FUNCTION NumStringElements
d1265 1
a1265 1
  SUBROUTINE RemoveElemFromList (inList, outList, elem, inseparator)
d1303 1
a1303 1
  END SUBROUTINE RemoveElemFromList
d1306 1
a1306 1
  SUBROUTINE RemoveListFromList (inList, outList, exclude, inseparator)
d1336 1
a1336 1
  END SUBROUTINE RemoveListFromList
d1339 1
a1339 1
  SUBROUTINE ReplaceSubString (str, outstr, sub1, sub2, which, no_trim)
d1533 1
a1533 1
  END SUBROUTINE ReplaceSubString
d1536 1
a1536 1
  FUNCTION ReverseList (str, inseparator) RESULT (outstr)
d1613 1
a1613 1
  END FUNCTION ReverseList
d1652 1
a1652 1
  SUBROUTINE SortArray(inStrArray, outIntArray, CaseSensitive, &
d1881 1
a1881 1
  END SUBROUTINE SortArray
d1913 1
a1913 1
  SUBROUTINE SortList(inList, outArray, CaseSensitive, countEmpty, &
d1986 1
a1986 1
  END SUBROUTINE SortList
d2023 1
a2023 1
  FUNCTION StringElementNum(inList, test_string, countEmpty, &
d2063 1
a2063 1
  END FUNCTION StringElementNum
d2083 1
a2083 1
  FUNCTION SwitchDetail(inList, test_switch, options) RESULT (detail)
d2134 1
a2134 1
  END FUNCTION SwitchDetail
d2137 1
a2137 1
  Function unquote(str, quotes, cquotes, strict, stripany, extract) &
d2139 1
a2139 1
    ! Function that removes a single pair of surrounding quotes from string
d2354 1
a2354 388
  end Function unquote

  ! ---------------------------------------------  utc_to_date  -----
  subroutine utc_to_date(str, ErrTyp, date, &
    & strict, utcAt0z)
    ! Routine that returns the date portion from a string of the form
    ! (A) yyyy-mm-ddThh:mm:ss.sss
    ! (B) yyyy-dddThh:mm:ss.sss
    ! where the field separator 'T' divides the string into two
    ! sub-strings encoding the date and time
    ! The date substring in subdivided by the separator '-'
    ! into either two or three fields
    ! In case (A), the 3 fields are year, month, and day of month
    ! in case (B) the two fields are year and day of year
    
    ! For case (A) returns year, month, and day=day of month
    ! For case (B) returns year, month=-1, and day=day of year
    ! Useful to decode utc inputs into attribute values
    
    ! Optionally returns the input string in utcAt0z modified so that 
    ! the hh:mm:ss.sss is 00:00:00Z
    
    ! (See also utc_to_time and utc_to_yyymmdd)
    !--------Argument--------!
    character(len=*),intent(in)   :: str
    integer, intent(out)          :: ErrTyp
    character(len=*), intent(out) :: date
    logical,intent(in), optional  :: strict
    character(len=*),intent(out), optional   :: utcAt0z
    !----------Local vars----------!
    character(len=1), parameter :: dash='-'
    logical :: mystrict
    character(len=1) :: utc_format        ! 'a' or 'b'
    character(len=*), parameter :: chars_0z = 'T00:00:00Z'
    !----------Executable part----------!

   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
         
   if(len_trim(str) <= 0) then
      if(mystrict) then
         ErrTyp=INVALIDUTCSTRING
      else
         ErrTyp=0
      endif
      return
   endif
   
   ErrTyp=INVALIDUTCSTRING
   ! Snip off time fields from date fields
   call GetStringElement(lowercase(str), date, 1, &
     & countEmpty=.true., inseparator='t')
   if ( date == ' ' ) then
     if ( .not. mystrict) Errtyp = 0
     if ( present(utcAt0z) ) utcAt0z = ' '
     return
   endif
   if ( present(utcAt0z) ) utcAt0z = trim(date) // chars_0z
   ErrTyp=0
   
  end subroutine utc_to_date

  ! ---------------------------------------------  utc_to_time  -----
  subroutine utc_to_time(str, ErrTyp, time, strict)
    ! Routine that returns the time portion from a string of the form
    ! (A) yyyy-mm-ddThh:mm:ss.sss
    ! (B) yyyy-dddThh:mm:ss.sss
    ! where the field separator 'T' divides the string into two
    ! sub-strings encoding the date and time
    ! (See also utc_to_date and utc_to_yyymmdd)
    !--------Argument--------!
    character(len=*),intent(in)   :: str
    integer, intent(out)          :: ErrTyp
    character(len=*), intent(out) :: time
    logical,intent(in), optional  :: strict
    !----------Local vars----------!
    character(len=1), parameter :: dash='-'
    logical :: mystrict
    character(len=1) :: utc_format        ! 'a' or 'b'
    character(len=*), parameter :: chars_0z = 'T00:00:00Z'
    !----------Executable part----------!

   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
         
   if(len_trim(str) <= 0) then
      if(mystrict) then
         ErrTyp=INVALIDUTCSTRING
      else
         ErrTyp=0
      endif
      return
   endif
   
   ErrTyp=INVALIDUTCSTRING
   ! Snip off time fields from date fields
   call GetStringElement(lowercase(str), time, 2, &
     & countEmpty=.true., inseparator='t')
   if ( time == ' ' ) then
     if ( .not. mystrict) Errtyp = 0
     return
   endif
   ErrTyp=0
   
  end subroutine utc_to_time

  ! ---------------------------------------------  utc_to_yyyymmdd_ints  -----
  subroutine utc_to_yyyymmdd_ints(str, ErrTyp, year, month, day, strict, nodash)
    ! Routine that returns the year, month, and day from a string of the form
    ! (A) yyyy-mm-ddThh:mm:ss.sss
    ! (B) yyyy-dddThh:mm:ss.sss
    ! (N) yyyydddThh:mm:ss.sss (no-dash)
    ! where the field separator 'T' divides the string into two
    ! sub-strings encoding the date and time
    ! The date substring in subdivided by the separator '-'
    ! into either two or three fields
    ! In case (A), the 3 fields are year, month, and day of month
    ! in case (B) the two fields are year and day of year
    
    ! For case (A) returns year, month, and day=day of month
    ! For case (B) returns year, month=-1, and day=day of year
    ! Useful to decode utc inputs into attribute values
    
    ! (See also PGS_TD_UTCtoTAI and mls_UTCtoTAI)
    !--------Argument--------!
    character(len=*),intent(in) :: str
    integer, intent(out) :: ErrTyp
    integer, intent(out) :: year
    integer, intent(out) :: month
    integer, intent(out) :: day
    logical, intent(in), optional :: strict
    logical, intent(in), optional :: nodash   ! No dash separating date fields
    !----------Local vars----------!
    character(len=1), parameter :: dash='-'
    character(len=NameLen) :: date
    character(len=NameLen) :: yyyy
    character(len=NameLen) :: mm
    character(len=NameLen) :: dd
    character(LEN=*), parameter :: time_conversion='(I4)'
    logical :: mystrict
    logical :: mynodash
    character(len=1) :: utc_format        ! 'a' or 'b' or 'n' (no-dash)
    ! The following arrys contains the maximum permissible day for each month
    ! where month=-1 means the whole year, month=1..12 means Jan, .., Dec
    integer, dimension(-1:12), parameter :: DAYMAX = (/ &
      & 366, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &
      & /)
    !----------Executable part----------!

   year = -1
   month = -1
   day = -1
   mm = ' '

   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
         
   if(present(nodash)) then
      mynodash=nodash
   else
      mynodash=.false.
   endif
         
   call utc_to_date(str, ErrTyp, date, strict= .true.)
   if ( ErrTyp /= 0 ) then
     if ( .not. mystrict ) ErrTyp = 0
     return
   endif
   if ( myNoDash ) then
     yyyy = date(1:4)
     mm = date(5:6)
     dd = date(7:8)
     utc_format = 'n'
   else
     call GetStringElement(trim(date), yyyy, 1, countEmpty=.true., inseparator=dash)
     if ( &
       & NumStringElements(trim(date), countEmpty=.true., inseparator=dash) == 2) then
       call GetStringElement(trim(date), dd, 2, countEmpty=.true., inseparator=dash)
       utc_format = 'b'
     else
       call GetStringElement(trim(date), mm, 2, countEmpty=.true., inseparator=dash)
       call GetStringElement(trim(date), dd, 3, countEmpty=.true., inseparator=dash)
       utc_format = 'a'
     endif
   endif
   
   ErrTyp=0
   
   ! Convert to value
   if(yyyy /= ' ') then
      read(yyyy, time_conversion, iostat=ErrTyp) year
   endif
   
   if(ErrTyp /= 0) then
      return
   elseif(year < 0 .or. year > YEARMAX) then
      ErrTyp=INVALIDUTCSTRING
      return
   endif

   if(mm /= ' ') then
      read(mm, time_conversion, iostat=ErrTyp) month
   endif

   if(utc_format == 'b') then
     ErrTyp = 0
     month = -1
   elseif(ErrTyp /= 0) then
      return
   elseif(month < 1 .or. month > 12) then
      ErrTyp=INVALIDUTCSTRING
      return
   endif
   ! Coming out of the above, month should be in the interval [-1, 12]

   if(dd /= ' ') then
      read(dd, time_conversion, iostat=ErrTyp) day
   endif

   if(ErrTyp /= 0) then
      return
   elseif(day < 1 .or. day > DAYMAX(month)) then
      ErrTyp=INVALIDUTCSTRING
      return
   endif
  end subroutine utc_to_yyyymmdd_ints

  ! ---------------------------------------------  utc_to_yyyymmdd_strs  -----
  subroutine utc_to_yyyymmdd_strs(str, ErrTyp, year, month, day, &
    & strict)
    ! Routine that returns the year, month, and day from a string of the form
    ! (A) yyyy-mm-ddThh:mm:ss.sss
    ! (B) yyyy-dddThh:mm:ss.sss
    ! where the field separator 'T' divides the string into two
    ! sub-strings encoding the date and time
    ! The date substring in subdivided by the separator '-'
    ! into either two or three fields
    ! In case (A), the 3 fields are year, month, and day of month
    ! in case (B) the two fields are year and day of year
    
    ! For case (A) returns year, month, and day=day of month
    ! For case (B) returns year, month=-1, and day=day of year
    ! Useful to decode utc inputs into attribute values
    
    ! (See also PGS_TD_UTCtoTAI and mls_UTCtoTAI)
    !--------Argument--------!
    character(len=*),intent(in)   :: str
    integer, intent(out)          :: ErrTyp
    character(len=*), intent(out) :: year
    character(len=*), intent(out) :: month
    character(len=*), intent(out) :: day
    logical,intent(in), optional  :: strict
    !----------Local vars----------!
    character(len=1), parameter :: dash='-'
    character(len=NameLen) :: date
    logical :: mystrict
    character(len=1) :: utc_format        ! 'a' or 'b'
    !----------Executable part----------!

   year = ' '
   month = ' '
   day = ' '

   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
         
   call utc_to_date(str, ErrTyp, date, strict= .true.)
   if ( ErrTyp /= 0 ) then
     if ( .not. mystrict ) ErrTyp = 0
     return
   endif
   call GetStringElement(trim(date), year, 1, countEmpty=.true., inseparator=dash)
   if ( &
     & NumStringElements(trim(date), countEmpty=.true., inseparator=dash) == 2) then
     call GetStringElement(trim(date), day, 2, countEmpty=.true., inseparator=dash)
     utc_format = 'b'
   else
     call GetStringElement(trim(date), month, 2, countEmpty=.true., inseparator=dash)
     call GetStringElement(trim(date), day, 3, countEmpty=.true., inseparator=dash)
     utc_format = 'a'
   endif
   
   ErrTyp=0
   
  end subroutine utc_to_yyyymmdd_strs

  ! ---------------------------------------------  yyyymmdd_to_dai_ints  -----

  subroutine yyyymmdd_to_dai_ints(yyyy, mm, dd, dai, startingDate)
    ! Routine that returns the number of days after a starting date
    ! from 3 ints: the form yyyymmdd
    !--------Argument--------!
    integer ,intent(in) :: yyyy
    integer ,intent(in) :: mm
    integer ,intent(in) :: dd
    integer,intent(out) :: dai
    character(len=*),intent(in),optional :: startingDate  ! If not Jan 1 2001
    !----------Local vars----------!
    character(len=8) :: mystartingDate
    integer :: yyyy1, mm1, dd1, doy1
    integer :: yyyy2, doy2
    integer :: ErrTyp
    logical :: daiNegative
    integer :: y
    !----------Executable part----------!
   if(present(startingDate)) then
      mystartingDate=startingDate
   else
      mystartingDate='20010101'
   endif
   call utc_to_yyyymmdd_ints(mystartingDate, ErrTyp, yyyy1, mm1, dd1, nodash=.true.)
   call yyyymmdd_to_doy_str(mystartingDate, doy1)
   call yyyymmdd_to_doy_ints(yyyy, mm, dd, doy2)
   yyyy2 = yyyy
   daiNegative = yyyy1 > yyyy2
   if ( daiNegative ) then
     call switch(yyyy1, yyyy2)
     call switch(doy1, doy2)
   elseif ( yyyy1 == yyyy2 ) then
     dai = doy2 - doy1
     return
   endif
   dai = doy2 - doy1
   do y = yyyy1, yyyy2 - 1
     if ( leapyear(y) ) then
       dai = dai + DAYMAXLY(-1)
     else
       dai = dai + DAYMAXNY(-1)
     endif
   enddo
   if ( daiNegative ) dai = -dai
  end subroutine yyyymmdd_to_dai_ints

  ! ---------------------------------------------  yyyymmdd_to_dai_str  -----
  subroutine yyyymmdd_to_dai_str(str, dai, startingDate)
    ! Routine that returns the number of days after a starting date
    ! from a string of the form yyyymmdd
    !--------Argument--------!
    character(len=*),intent(in) :: str
    integer,intent(out) :: dai
    character(len=*),intent(in),optional :: startingDate  ! If not Jan 1 2001
    !----------Local vars----------!
    character(len=8) :: mystartingDate
    integer :: yyyy1, mm1, dd1, doy1
    integer :: yyyy2, mm2, dd2, doy2
    integer :: ErrTyp
    logical :: daiNegative
    integer :: y
    !----------Executable part----------!
   if(present(startingDate)) then
      mystartingDate=startingDate
   else
      mystartingDate='20010101'
   endif
   call utc_to_yyyymmdd_ints(mystartingDate, ErrTyp, yyyy1, mm1, dd1, nodash=.true.)
   call utc_to_yyyymmdd_ints(str, ErrTyp, yyyy2, mm2, dd2, nodash=.true.)
   call yyyymmdd_to_doy_str(mystartingDate, doy1)
   call yyyymmdd_to_doy_str(str, doy2)
   daiNegative = yyyy1 > yyyy2
   if ( daiNegative ) then
     call switch(yyyy1, yyyy2)
     call switch(doy1, doy2)
   elseif ( yyyy1 == yyyy2 ) then
     dai = doy2 - doy1
     return
   endif
   dai = doy2 - doy1
   do y = yyyy1, yyyy2 - 1
     if ( leapyear(y) ) then
       dai = dai + DAYMAXLY(-1)
     else
       dai = dai + DAYMAXNY(-1)
     endif
   enddo
   if ( daiNegative ) dai = -dai
  end subroutine yyyymmdd_to_dai_str
a2356 82
  ! ---------------------------------------------  switch_ints  -----
  subroutine switch_ints(x1, x2)
    ! Switch args x1 <=> x2
    !--------Argument--------!
    integer,intent(inout) :: x1
    integer,intent(inout) :: x2
    !----------Local vars----------!
    integer :: x
    x = x1
    x1 = x2
    x2 = x
  end subroutine switch_ints

  ! ---------------------------------------------  yyyymmdd_to_doy_ints  -----
  subroutine yyyymmdd_to_doy_ints(year, month, day, doy)
    ! Routine that returns the number of days after the year's start
    ! for year, month, day
    !--------Argument--------!
    integer, intent(in) :: year, month, day
    integer, intent(out) :: doy
    !----------Local vars----------!
    integer :: m
    integer, dimension(-1:12) :: DAYMAX
    !----------Executable part----------!
     if ( year < 0 .or. year > YEARMAX ) then
       doy = -1
     endif
     doy = day
     if ( month <= 1 ) then
       return
     endif
     if ( leapyear(year) ) then
       DAYMAX = DAYMAXLY
     else
       DAYMAX = DAYMAXNY
     endif
     do m=1, month-1
       doy = doy + DAYMAX(m)
     enddo
     
  end subroutine yyyymmdd_to_doy_ints

  ! ---------------------------------------------  yyyymmdd_to_doy_str  -----
  subroutine yyyymmdd_to_doy_str(str, doy)
    ! Routine that returns the number of days after the year's start
    ! for a string of the form yyyymmdd
    !--------Argument--------!
    character(len=*),intent(in) :: str
    integer,intent(out) :: doy
    !----------Local vars----------!
    integer :: year, month, day
    integer :: ErrTyp
    ! integer :: m
    ! integer, dimension(-1:12) :: DAYMAX
    !----------Executable part----------!
     call utc_to_yyyymmdd_ints(str, ErrTyp, year, month, day, nodash=.true.)
     call yyyymmdd_to_doy_ints(year, month, day, doy)
  end subroutine yyyymmdd_to_doy_str

  function daysinyear(year) result(days)
    integer, intent(in) :: year
    integer :: days
     ! How many days in the particular year
     if ( leapyear(year) ) then
       days = 366
     else
       days = 365
     endif
  end function daysinyear

  logical function leapyear(year)
    integer,intent(in) :: year
     ! This is to capture rule that centuries are leap only
     ! if divisible by 400
     ! Otherwise, as perhaps you knew, leapyears are those years divisible by 4
     if ( 100 * (year/100) >= year ) then
       leapyear = ( 400 * (year/400) >= year )
     else
       leapyear = ( 4 * (year/4) >= year )
     endif
  end function leapyear

d2360 1
a2360 1
       "$Id: MLSStringLists.f90,v 2.12 2005/08/08 23:53:18 pwagner Exp $"
d2370 3
@


2.12
log
@utc_format never undefined in utc_to_yyyymmdd_ints
@
text
@d13 1
a13 1
MODULE MLSStringLists               ! Module to treat string lists
d23 1
a23 1
  implicit NONE
d34 2
d49 1
d80 2
d117 2
d152 2
a153 1
  public :: catLists, Array2List, ExpandStringRange, ExtractSubString, &
d165 4
d370 81
d2770 1
d2920 11
d2935 1
a2935 1
     ! Otherwise, as prehaps you knew, leapyears are those years divisible by 4
d2946 1
a2946 1
       "$Id: MLSStringLists.f90,v 2.11 2005/08/05 16:31:07 pwagner Exp $"
d2956 3
@


2.11
log
@Added RemoveListFromList
@
text
@d2495 1
d2525 1
a2525 1
    character(len=1) :: utc_format        ! 'a' or 'b'
d2559 1
d2841 1
a2841 1
       "$Id: MLSStringLists.f90,v 2.10 2005/07/21 23:38:18 pwagner Exp $"
d2851 3
@


2.10
log
@Added explanation of to-be-standard character flag options
@
text
@d59 1
d96 4
d149 1
a149 1
   & RemoveElemFromList, ReplaceSubString, ReverseList, &
d1329 33
d2839 1
a2839 1
       "$Id: MLSStringLists.f90,v 2.9 2005/06/22 17:25:50 pwagner Exp $"
d2849 3
@


2.9
log
@Reworded Copyright statement, moved rcs id
@
text
@d28 1
a28 1
       "$RCSfile: $"
d118 10
d2066 4
a2069 1
  FUNCTION SwitchDetail(inList, test_switch) RESULT (detail)
d2074 1
d2077 1
d2079 3
d2083 1
a2083 2
    integer, parameter :: MAXELEMENTLENGTH = 80
    logical, parameter :: COUNTEMPTY = .true.
a2084 1
    CHARACTER (LEN=MAXELEMENTLENGTH)           :: listElement
d2086 2
d2095 6
d2103 1
d2106 1
d2108 1
a2108 1
          & index(trim(listElement), trim(test_switch)) > 0) then
d2113 6
a2118 2
	
	detail = -1
d2801 1
a2801 1
       "$Id: $"
d2811 3
@


2.8
log
@Added SwitchDetail
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d26 1
a26 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: MLSStringLists.f90,v 2.7 2005/03/26 00:06:54 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d28 1
a28 1
       "$RCSfile: MLSStringLists.f90,v $"
d2769 5
d2781 3
@


2.7
log
@Repaired RemoveElemFromList; added extract option to unquote
@
text
@d12 2
a13 1
  use MLSStrings, only: lowerCase, Capitalize, reverse, writeIntsToChars
d20 1
a20 1
       "$Id: MLSStringLists.f90,v 2.6 2005/02/03 19:04:58 pwagner Exp $"
d59 1
d74 1
a74 1
! GetIntHashElement (strlist keyList, hashArray(:), char* key, 
d100 1
d130 1
a130 1
   & SortArray, SortList, StringElementNum, &
d2036 51
d2771 3
@


2.6
log
@Added GetUniqueInts, utc_to_date, utc_to_time
@
text
@d19 1
a19 1
       "$Id: MLSStringLists.f90,v 2.5 2004/10/19 22:59:08 vsnyder Exp $"
a551 2
    ! print *, 'instr: ', trim(instr)
    ! print *, 'strlen: ', strlen
a554 4
    ! print *, 'sub1: ', trim(sub1)
    ! print *, 'isub1: ', isub1
    ! print *, 'sub2: ', trim(sub2)
    ! print *, 'isub2: ', isub2
a559 3
        ! print *, 'zap every occurrence of sub2 up to position isub1'
        ! print *, 'before zapping: ', instr(1:isub1-1)
        ! print *, 'tail: ', instr(isub1:strlen)
a561 1
        ! print *, 'afterzapping: ', trim(tmpstr), '//', instr(isub1:strlen)
a562 1
        ! print *, 'tmpstrlen: ', tmpstrlen
a563 1
        ! print *, 'tmpstrlen(2): ', tmpstrlen
a568 6
          ! str = tmpstr(1:tmpstrlen)
          ! print *, tmpstr(1:tmpstrlen)
          ! print *, str(1:tmpstrlen)
          ! str(tmpstrlen+1:) = instr(isub1:strlen)
          ! print *, instr(isub1:strlen)
          ! print *, trim(str(tmpstrlen+1:))
a575 1
    ! print *, 'str: ', trim(str)
a591 1
    ! print *, 'separator: ', separator
a617 2
      ! print *, 'Replacing: ', sub1, ' with ', separator
      ! print *, 'in: ', trim(str)
a619 2
      ! print *, 'results in: ', trim(tmpstr2)
      ! print *, 'Replacing: ', sub2, ' with ', separator
a621 1
      ! print *, 'results in: ', trim(tmpstr)
d1297 7
a1303 1
    outList = unique_list(len(elem)+1:)
a2006 2
!    CHARACTER (LEN=1)                          :: separator
!    CHARACTER (LEN=1), PARAMETER               :: COMMA = ','
d2034 2
a2035 1
  Function unquote(str, quotes, cquotes, strict, stripany) result (outstr)
d2064 5
d2079 9
d2089 2
a2090 2
    character(len=*),intent(in) :: str
    character(len=len(str)) :: outstr, tmpstr
d2092 4
a2095 3
    character(len=*),intent(in), optional :: cquotes
    logical,intent(in), optional :: strict
    logical,intent(in), optional :: stripany
d2097 1
d2105 1
d2118 6
d2136 2
d2173 7
a2179 2
         if(mystrict) then
           if(str(prim:prim) == quote .and. str(ult:ult) == cquote) then
d2185 1
a2185 1
         if(str(prim:prim) == quote) then
d2191 1
a2191 1
           endif
d2196 9
d2237 7
a2243 1
   if ( mystripany ) then
d2717 3
@


2.5
log
@Remove USE for unused R8
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d19 1
a19 1
       "$Id: MLSStringLists.f90,v 2.4 2004/10/13 00:51:09 vsnyder Exp $"
d47 1
d59 2
d78 8
a85 5
! GetUniqueList (char* str, char* outstr(:), int noUnique, &
!   & log countEmpty, [char inseparator], [log IgnoreLeadingSpaces]) 
! GetUniqueStrings (char* inList(:), char* outList(:), int noUnique) 
! List2Array (strlist inList, char* outArray(:), log countEmpty, [char inseparator],
!    [log IgnoreLeadingSpaces])
d124 1
a124 1
   & GetUniqueStrings, GetUniqueList, &
d128 1
a128 1
   & unquote, utc_to_yyyymmdd, yyyymmdd_to_dai
d864 99
d967 1
a967 1
  ! (You may safely use the same variable for str and outStr)
d971 1
d974 1
a974 1
    & inseparator, IgnoreLeadingSpaces, str2)
d983 1
d1032 2
a1033 1
      call GetUniqueStrings(inStringArray, outStringArray, noUnique, inStrAr2)
d1042 2
a1043 1
      call GetUniqueStrings(inStringArray, outStringArray, noUnique)
d1060 1
d1063 1
a1063 1
  SUBROUTINE GetUniqueStrings(inList, outList, noUnique, extra)
d1069 1
d1112 4
d2228 110
d2397 3
a2399 15
   if(len_trim(str) <= 0) then
      if(mystrict) then
         ErrTyp=INVALIDUTCSTRING
      else
         ErrTyp=0
      endif
      return
   endif
   
   ErrTyp=INVALIDUTCSTRING
   ! Snip off time fields from date fields
   call GetStringElement(lowercase(str), date, 1, &
     & countEmpty=.true., inseparator='t')
   if ( date == ' ' ) then
     if ( .not. mystrict) Errtyp = 0
d2462 1
a2462 1
    & strict, utcAt0z)
a2476 3
    ! Optionally returns the input string in utcAt0z modified so that 
    ! the hh:mm:ss.sss is 00:00:00Z
    
a2484 1
    character(len=*),intent(out), optional   :: utcAt0z
a2489 1
    character(len=*), parameter :: chars_0z = 'T00:00:00Z'
d2502 3
a2504 16
   if(len_trim(str) <= 0) then
      if(mystrict) then
         ErrTyp=INVALIDUTCSTRING
      else
         ErrTyp=0
      endif
      return
   endif
   
   ErrTyp=INVALIDUTCSTRING
   ! Snip off time fields from date fields
   call GetStringElement(lowercase(str), date, 1, &
     & countEmpty=.true., inseparator='t')
   if ( date == ' ' ) then
     if ( .not. mystrict) Errtyp = 0
     if ( present(utcAt0z) ) utcAt0z = ' '
a2506 1
   if ( present(utcAt0z) ) utcAt0z = trim(date) // chars_0z
d2692 3
@


2.4
log
@Move HHMMSS_value to MLSStrings
@
text
@d10 1
a10 1
  use MLSCommon, only: i4, r8, NameLen, BareFNLen
d19 1
a19 1
       "$Id: MLSStringLists.f90,v 2.3 2004/09/16 00:16:46 pwagner Exp $"
d673 1
a673 1
  
d2498 3
@


2.3
log
@catLists may cat integers onto end of stringLists
@
text
@d19 1
a19 1
       "$Id: MLSStringLists.f90,v 2.2 2004/08/05 22:47:02 pwagner Exp $"
a35 2
! INVALIDHHMMSSSTRING
!                    (if strict) str not in format '00:00:00.0000000'
a48 2
! hhmmss_value       Converts 'hh:mm:ss' formatted string to a real r8
!                    (See also PGS_TD_UTCtoTAI and mls_UTCtoTAI)
a77 1
! r8 hhmmss_value (char* str, int ErrTyp, [char separator], [log strict])
a118 1
   & hhmmss_value, &
a148 2
  ! hhmmss_value
  integer, public, parameter :: INVALIDHHMMSSSTRING = 1
d1040 2
a1041 172
    DEALLOCATE(duplicate)
  END SUBROUTINE GetUniqueStrings

  ! ------------------------------------------------  hhmmss_value  -----
  Function hhmmss_value(str, ErrTyp, separator, strict) result (value)
    ! Function that returns the value in seconds of a string 'hh:mm:ss'
    ! where the field separator ':' divides the string into two
    ! integer-like strings 'hh' and 'mm', as well as one float-like
    ! string 'ss' which may have a decimal point plus fractional part
    ! E.g., ss=59.9999
    
    ! Requires 0 <= hh <= 24
    ! Requires 0 <= mm < 60
    ! Requires 0. <= ss < 60.

    ! Returns ErrTyp=0 unless an error occurs

    ! Lenient wrt utc and non-compliant formats:
    ! ignores chars in front of 'hh' and a terminal,
    ! non-numerical char: e.g., '2000-01-01T00:00:00.000000Z'
    ! will be treated the same as '00:00:00.0000000'

    ! If given optional arg strict, not lenient
    ! i.e., non-compliant str always returns non-zero ErrTyp
    
    ! If given optional arg separator, uses separator as field separator
    
    ! Useful to allow an added way to input time
    
    ! (See also PGS_TD_UTCtoTAI and mls_UTCtoTAI)
    !--------Argument--------!
    character(len=*),intent(in) :: str
    real(r8) :: value
    integer, intent(out) :: ErrTyp
    character(len=1),intent(in), optional :: separator
    logical,intent(in), optional :: strict
    !----------Local vars----------!
    character(len=1), parameter :: colon=':'
    character(len=1) :: myColon
    character(len=2) :: mm
    character(len=NameLen) :: ss
    character(len=NameLen) :: hh
    character(len=10), parameter :: digits='0123456789'
    character(LEN=*), parameter :: time_conversion='(I2)'
    character(LEN=*), parameter :: real_conversion='(F32.0)'
    integer :: i
    logical :: mystrict
    integer :: hvalue, mvalue
    !----------Executable part----------!

   if(present(separator)) then
      myColon=separator
   else
      myColon=colon
   endif
         
   if(present(strict)) then
      mystrict=strict
   else
      mystrict=.false.
   endif
         
   if(len_trim(str) <= 0) then
      value=0.
      if(mystrict) then
         ErrTyp=INVALIDHHMMSSSTRING
      else
         ErrTyp=0
      endif
      return
   endif
   
   ErrTyp=INVALIDHHMMSSSTRING
   value=0.
   
   call GetStringElement(str, hh, 1, countEmpty=.true., inseparator=myColon)
   call GetStringElement(str, mm, 2, countEmpty=.true., inseparator=myColon)
   call GetStringElement(str, ss, 3, countEmpty=.true., inseparator=myColon)
   
   ! Check if ss terminates in a non-digit
   ss=Reverse(trim(ss))
   
   if(len_trim(ss) <= 0) then
      if(mystrict) then
         return
      endif      
   elseif( .not. (index(digits, ss(1:1)) > 0) ) then
      if(mystrict) then
         return
      else
         ss=Reverse(trim(ss(2:)))
      endif
   else
      ss=Reverse(trim(ss))
   endif

   do i=1, len_trim(ss)
      if( .not. (index(digits, ss(i:i)) > 0 .or. ss(i:i) == '.') ) return
   enddo

   ! Check if mm complies
   if(len_trim(mm) <= 0) then
      if(mystrict) then
         return
      endif      
   else
      do i=1, len_trim(mm)
        if( .not. (index(digits, mm(i:i)) > 0) ) return
      enddo
   endif      

   ! Check if hh complies
   hh=Reverse(trim(hh))
   
   if(len_trim(hh) <= 0) then
      if(mystrict) then
         return
      endif      
   elseif(mystrict) then
      do i=1, len_trim(hh)
        if( .not. (index(digits, hh(i:i)) > 0) ) return
      enddo
   endif

   hh=Reverse(hh(:2))
   
   ErrTyp=0
   
   ! Convert to value
   if(hh == ' ') then
      hvalue=0
   else
      read(hh(1:2), time_conversion, iostat=ErrTyp) hvalue
   endif
   
   if(ErrTyp /= 0) then
      return
   elseif(hvalue < 0 .or. hvalue > 24) then
      ErrTyp=INVALIDHHMMSSSTRING
      return
   endif

   if(mm == ' ') then
      mvalue=0
   else
      read(mm, time_conversion, iostat=ErrTyp) mvalue
   endif

   if(ErrTyp /= 0) then
      return
   elseif(mvalue < 0 .or. mvalue > 59) then
      ErrTyp=INVALIDHHMMSSSTRING
      return
   endif

   ! Convert to value
   if(ss == ' ') then
      value=0
   else
      read(ss, real_conversion, iostat=ErrTyp) value
   endif
   
   if(ErrTyp /= 0) then
      return
   elseif(value < 0. .or. value > 60.) then
      ErrTyp=INVALIDHHMMSSSTRING
      return
   endif
   
   value = value + 60*(mvalue + 60*hvalue)

  end Function hhmmss_value
d2498 3
@


2.2
log
@New interfaces to ExpandStringList for ints and logicals
@
text
@d12 1
a12 1
  use MLSStrings, only: lowerCase, Capitalize, reverse
d19 1
a19 1
       "$Id: MLSStringLists.f90,v 2.1 2004/08/04 23:17:30 pwagner Exp $"
d130 4
d247 61
a307 2
  ! -------------------------------------------------  catLists  -----
  function catLists (STR1, STR2, inseparator) result (OUTSTR)
d335 1
a335 1
  end function catLists
d2676 3
@


2.1
log
@First commit
@
text
@d19 1
a19 1
       "$Id: MLSStringLists.f90,v 2.44 2004/06/29 00:06:13 pwagner Exp $"
d43 1
a43 1
! ExpandStringRange  Turns '1,2-5,7' into '1,2,3,4,5,7'
d130 5
d159 1
d274 78
a351 2
  ! --------------------------------------------------  ExpandStringRange  -----
  subroutine ExpandStringRange (instr, outstr)
d432 1
a432 1
  end subroutine ExpandStringRange
a2554 1
    integer :: ErrTyp
d2613 3
@

