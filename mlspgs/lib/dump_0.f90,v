head	2.163;
access;
symbols
	v5-02-NRT-19:2.163
	v6-00:2.163
	v5-02-NRT-18:2.163
	v5-02:2.160
	v5-01-NRT-17:2.163
	v5-01-NRT-16:2.163
	v5-01-NRT-15:2.163
	v5-01-NRT-14:2.162
	neuralnetworks-1-0:2.161.0.4
	cfm-single-freq-0-1:2.161.0.2
	v5-01:2.160
	v5-00:2.160
	v4-23-TA133:2.158.0.2
	mus-emls-1-70:2.155.0.2
	rel-1-0-englocks-work:2.153.0.2
	VUMLS1-00:2.140
	VPL1-00:2.139
	V4-22-NRT-08:2.137
	VAM1-00:2.133
	V4-21:2.132.0.2
	V4-13:2.131
	V4-12:2.130
	V4-11:2.130
	V4-10:2.130
	V3-43:2.101.2.1
	M4-00:2.125
	V3-41:2.101.2.1
	V3-40-PlusGM57:2.101.0.2
	V2-24-NRT-04:2.75
	V3-33:2.105
	V2-24:2.75
	V3-31:2.105
	V3-30-NRT-05:2.101
	cfm-01-00:2.101
	V3-30:2.101
	V3-20:2.101
	V3-10:2.90
	V2-23-NRT-02:2.75
	V2-23:2.75
	V2-22-NRT-01:2.75
	V2-22:2.75
	V2-21:2.64
	V2-20:2.63
	V2-11:2.61
	V2-10:2.61
	V2-00:2.59
	V1-51:2.43
	V1-50:2.43
	V1-45:2.42
	V1-44:2.42
	V1-43:2.36
	V1-42:2.30
	V1-41:2.30
	V1-32:2.32
	V1-40:2.30
	V1-31:2.30
	V1-30:2.28
	V1-13:2.21
	V1-12:2.21
	V1-11:2.21
	V1-10:2.20
	newfwm-feb03:2.20.0.2
	V1-04:2.17
	V1-03:2.17
	V1-02:2.17
	V1-00:2.17
	newfwm-sep01:2.8.0.2
	V0-7:2.8
	V0-5-Level2:2.5
	V0-5-SIPS:2.4;
locks; strict;
comment	@# @;


2.163
date	2021.09.09.22.58.02;	author pwagner;	state Exp;
branches;
next	2.162;

2.162
date	2021.04.01.23.45.18;	author pwagner;	state Exp;
branches;
next	2.161;

2.161
date	2019.10.25.20.54.58;	author pwagner;	state Exp;
branches;
next	2.160;

2.160
date	2019.07.22.22.21.38;	author pwagner;	state Exp;
branches;
next	2.159;

2.159
date	2019.04.24.19.17.01;	author vsnyder;	state Exp;
branches;
next	2.158;

2.158
date	2018.10.27.01.37.20;	author vsnyder;	state Exp;
branches;
next	2.157;

2.157
date	2018.08.21.01.52.14;	author vsnyder;	state Exp;
branches;
next	2.156;

2.156
date	2018.08.16.02.17.43;	author vsnyder;	state Exp;
branches;
next	2.155;

2.155
date	2018.04.25.01.47.43;	author vsnyder;	state Exp;
branches;
next	2.154;

2.154
date	2018.04.13.00.22.49;	author pwagner;	state Exp;
branches;
next	2.153;

2.153
date	2018.02.28.19.51.35;	author pwagner;	state Exp;
branches;
next	2.152;

2.152
date	2017.12.07.02.40.10;	author vsnyder;	state Exp;
branches;
next	2.151;

2.151
date	2017.11.30.20.46.19;	author pwagner;	state Exp;
branches;
next	2.150;

2.150
date	2017.11.03.20.01.40;	author pwagner;	state Exp;
branches;
next	2.149;

2.149
date	2017.10.11.20.56.23;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2017.09.15.22.37.55;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2017.09.14.18.31.14;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2017.09.07.23.44.30;	author pwagner;	state Exp;
branches;
next	2.145;

2.145
date	2017.09.07.20.59.35;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2017.08.03.20.37.31;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2017.07.31.23.05.47;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2017.07.31.22.18.22;	author vsnyder;	state Exp;
branches;
next	2.141;

2.141
date	2017.07.19.22.42.53;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2016.10.20.23.05.41;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2016.07.28.03.28.17;	author vsnyder;	state Exp;
branches;
next	2.138;

2.138
date	2016.07.28.01.42.27;	author vsnyder;	state Exp;
branches;
next	2.137;

2.137
date	2016.04.05.23.54.57;	author pwagner;	state Exp;
branches;
next	2.136;

2.136
date	2016.03.31.22.59.03;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2016.03.23.00.22.17;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2016.01.12.00.46.51;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2015.08.25.18.38.27;	author vsnyder;	state Exp;
branches;
next	2.132;

2.132
date	2015.01.29.01.23.29;	author vsnyder;	state Exp;
branches;
next	2.131;

2.131
date	2014.08.06.23.02.21;	author vsnyder;	state Exp;
branches;
next	2.130;

2.130
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2013.09.26.15.25.41;	author pwagner;	state Exp;
branches;
next	2.128;

2.128
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2013.06.28.18.08.38;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2013.06.19.23.14.39;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2013.01.10.00.18.43;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2012.09.11.21.10.24;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2012.07.05.23.47.31;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2012.06.22.20.25.52;	author pwagner;	state Exp;
branches;
next	2.121;

2.121
date	2012.06.13.23.59.37;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2012.01.09.22.25.55;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2011.12.15.01.47.45;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2011.12.07.01.14.44;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2011.11.11.00.30.22;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2011.07.26.20.40.24;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2011.07.23.00.16.25;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2011.07.15.23.23.43;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2011.07.12.00.15.01;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2011.06.23.17.27.41;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2011.04.26.20.54.12;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2011.04.20.22.27.09;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2011.04.18.19.12.54;	author vsnyder;	state Exp;
branches;
next	2.108;

2.108
date	2011.04.04.23.08.27;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2011.03.08.00.04.40;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2011.02.25.18.50.26;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2011.02.05.01.01.41;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2011.01.20.01.16.01;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2011.01.04.00.48.26;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2010.10.14.18.44.01;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2010.02.04.23.05.39;	author vsnyder;	state Exp;
branches
	2.101.2.1;
next	2.100;

2.100
date	2010.01.29.21.08.21;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2009.11.20.01.15.11;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2009.11.20.01.12.50;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2009.10.30.23.02.41;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2009.10.26.18.53.33;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2009.10.19.17.33.26;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2009.10.13.00.09.04;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2009.09.10.20.58.00;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2009.08.18.20.41.17;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2009.08.17.16.55.41;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2009.06.26.00.15.18;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2009.06.24.22.36.32;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2009.06.23.18.25.43;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2009.06.16.17.12.55;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2009.05.14.21.59.04;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2009.05.08.00.40.09;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2009.04.01.23.30.49;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2008.11.24.19.34.47;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2008.10.24.23.21.49;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2008.08.27.16.23.41;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2008.07.10.00.13.30;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2008.07.09.16.30.21;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2008.06.18.20.56.18;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2008.01.09.20.53.22;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2008.01.07.21.37.57;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2007.10.18.23.37.41;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2007.10.12.23.34.49;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2007.09.20.18.39.37;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2007.09.13.21.09.57;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2007.07.17.00.21.58;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2007.07.11.22.29.23;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2007.06.14.18.38.36;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2007.04.14.00.32.47;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2007.04.03.02.49.23;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2007.03.23.00.14.30;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2007.03.07.21.01.45;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2007.01.31.00.05.43;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2006.08.23.20.06.25;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2006.08.22.20.40.04;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2006.07.11.00.24.04;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2006.06.24.23.07.04;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2006.06.09.18.50.12;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2006.05.24.20.38.14;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2006.04.20.01.09.30;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2006.03.22.23.48.52;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2006.03.15.17.34.28;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2006.03.03.23.04.55;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2006.02.28.21.42.29;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2006.01.27.01.01.37;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2005.12.17.00.58.56;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2005.12.16.23.25.13;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2005.12.16.00.04.06;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2005.11.04.18.49.02;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2005.10.03.18.05.52;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2005.07.20.01.33.47;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2005.06.22.17.25.48;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2005.05.12.20.43.54;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2004.12.14.21.31.59;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2004.08.16.17.09.14;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2004.08.04.23.19.01;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2004.07.23.19.47.20;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2004.07.23.18.34.59;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2004.07.21.19.57.21;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2004.06.11.19.04.29;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2004.05.27.23.25.33;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2004.04.05.17.47.43;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2004.04.03.05.43.23;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2004.03.30.00.44.10;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2004.02.26.21.53.31;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2004.01.21.22.02.19;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2003.09.19.02.00.14;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2003.09.15.17.43.41;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2003.09.06.00.48.40;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2003.08.08.20.45.42;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2003.07.04.02.41.33;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2003.07.02.01.07.27;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2003.05.21.19.20.40;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2003.05.06.00.15.03;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2003.04.17.23.05.44;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2003.02.19.18.33.38;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2002.12.02.23.34.14;	author pwagner;	state Exp;
branches
	2.20.2.1;
next	2.19;

2.19
date	2002.10.08.00.09.08;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2002.09.13.18.08.12;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2002.02.14.23.21.18;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2001.12.08.00.47.51;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2001.11.29.23.50.53;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2001.11.28.23.32.01;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.10.25.23.30.39;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2001.10.24.18.11.14;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.10.23.22.40.37;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.09.28.22.43.20;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.09.11.22.52.32;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.05.11.22.44.54;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.05.08.20.27.24;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.05.08.17.21.02;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.05.03.02.12.34;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.10.03.39.58;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.02.01.32.08;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.28.21.35.27;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2000.09.13.20.38.50;	author vsnyder;	state Exp;
branches;
next	;

2.101.2.1
date	2011.11.16.23.33.51;	author pwagner;	state Exp;
branches;
next	;

2.20.2.1
date	2003.03.14.00.25.47;	author vsnyder;	state Exp;
branches;
next	2.20.2.2;

2.20.2.2
date	2003.03.27.23.18.33;	author vsnyder;	state Exp;
branches;
next	2.20.2.3;

2.20.2.3
date	2003.04.18.20.26.05;	author vsnyder;	state Exp;
branches;
next	2.20.2.4;

2.20.2.4
date	2003.05.05.23.00.05;	author livesey;	state Exp;
branches;
next	;


desc
@@


2.163
log
@Added subroutine AsExplicitValues
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Dump_0

! Low-level dump routines -- for some arrays of intrinsic type.
! It should handle most combinations of rank and type
! Its behavior depends on optional parameters
! The actual output device determined by output_m module
!
! In general, dumping a whole array of values will be presented as a matrix
! up to 10 values across
! Instead of a whole array, or in addition, one may dump a condensed summary
! showing min, max, percentages of non-zero values, etc.

! We take special care when dumping arrays whose values are
! logical-valued
!   bit-valued
!   character strings
!   rank > 1 (only for integer, single, double, or complex)

! See also dump_1.f90

  use HyperSlabs, only: Bandwidth, Collapse
  use BitStuff, only: MaxBitNumber, WhichBitsAreSet
  use Dump_Options, only: AfterSub, AuBrick, MyBandwidth=>Bandwidth, &
    & Clean, CollapseIt, CollapseOptions, &
    & DefaultDumpOptions, DefaultMaxLon, DefaultPCTFormat, &
    & DefaultWidth, Dopt_Collapse, Dopt_Transpose, Dot, DiffRMSMeansRMS, &
    & DontDumpIfAllEqual, Dopts, Gaps, IntPlaces, Laconic, MaxNumNANs, &
    & NameHasBeenPrinted, NameOnEachLine, NaNs, &
    & PCTFormat, PrintFillValue, PrintName, PrintNameAtLineEnd, &
    & Ratios, RMS, RMSFormat, &
    & SDFormatDefault, SDFormatDefaultCmplx, Stats, StatsOnOneLine, &
    & TheDumpBegins, TheDumpEnds, ItsShape, MyTranspose=>Transpose, &
    & TrimIt, Unique, WholeArray
  use HighOutput, only: BlanksToColumn, NumNeedsFormat, OutputNamedValue
  use MLSFillValues, only: InfFunction, IsFinite, IsInfinite, IsNaN, NaNFunction, &
    & WhereAreTheInfs, WhereAreTheNaNs
  use MLSFinds, only: FindAll, FindUnique
  use MLSStats1, only: FillValueRelation, &
    & MLSMax, MLSMean, MLSMin, MLSStdDev
  use MLSStringLists, only: CatLists, NumStringElements, OptionDetail
  use MLSStrings, only: Delete, Indexes, ReadIntsFromChars
  use Optional_m, only: Default
  use Output_m, only: OutputOptions, &
    & Blanks, GetOutputStatus, Newline, Output

  implicit none
  private

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (subroutines and functions)
! AsExplicitValues         Dump an array in a form suitable for pasting into
!                            an l2cf as values for an explicit Fill; e.g.
!                            [ 258.0K, 312.1K, .. ]
! Dump                     Dump an array to output
! Dump_2x2xN               Dump polarized incremental optical depth
! Empty                    Print mesg that array is empty
! FinishLine               Print a newLine, optionally echoing the item name
! ILog10                   Returns integer part of base-10 log of an int
! Name_And_Size            Print array name and its shape

! PrintName                Print the item name unless already done so
! PrintRMSetc              Prints a nicely-formatted list of min, max, etc
! === (end of toc) ===

! === (start of api) ===
! AsExplicitValues  ( Array,
!      [char* unit,], [char separator], [char brackets[2] )
! Dump ( Array, char* name,
!      [fillvalue], [int width], [char* format],
!      [int lbound], [char* options] ) 
!       where array can be a 1, 2, or 3d array of
!       chars, ints, reals, or doubles,
!       and fillValue is a scalar of the same type, if present
! Dump_2x2xN ( cmplx array(2, 2, :) &
!      [, char* name] [, char* Format] [, char* Options] )
! Empty ( [ char* Name ] )
! FinishLine
! int ILog10 ( int int )
! PrintName ( char* Name [, log nameHasBeenPrintedAlready] )
! PrintRMSetc ( char* Name, num min, num max, num rms, num mean )
!
! Options are described in Dump_Options
! By their judicious use you might choose to print an entire array or
! instead just a statistical sampling.
!
! Note that the appearance of Name may be affected by the use
! of any of 3 possible flags in the Name field of Dump. The method
! of appending the flags has an air of hackery-quackery about it. E.g.,
! If Name = 'MyName\h'
! then Dump might print this
! ---------------------------MyName---------------------
!    (:) all 3500 values are 0
! So the flags are separated from the final character of Name by a '\'
! flag             effect
!  b               print Name in a Banner
!  h               print Name as a Headline
!  n               omit Newline after printing name
! === (end of api) ===

  public :: &
    & AsExplicitValues, &
    & Dump, Dump_Sparse, Dump_2x2xN, Empty, FinishLine, ILog10, Name_And_Size, &
    & PrintName, PrintRMSEtc

  ! =====     Public Generics     ======================================

  interface Dump        ! Dump n-d arrays of homogeneous type
    module procedure Dump_1D_BIT, Dump_1D_Char, Dump_1D_Complex, Dump_1D_DComplex
    module procedure Dump_1D_Double, Dump_1D_Integer, Dump_1D_Integer_2B
    module procedure Dump_1D_Logical, Dump_1D_Real
    module procedure Dump_2D_Char, Dump_2D_Complex, Dump_2D_DComplex
    module procedure Dump_2D_Double, Dump_2D_Integer, Dump_2D_Integer_2B
    module procedure Dump_2D_Logical, Dump_2D_Real
    module procedure Dump_3D_Char, Dump_3D_Double, Dump_3D_Integer
    module procedure Dump_3D_Real, Dump_3D_Complex, Dump_3D_DComplex
    module procedure Dump_4D_Double, Dump_4D_Real
  end interface

  interface Dump_Sparse ! Dump only the nonzeroes in 1D arrays
    module procedure Dump_1D_Sparse_Double, Dump_1D_Sparse_Real
    module procedure Dump_2D_Row_Sparse_Double, Dump_2D_Row_Sparse_Real
  end interface

  interface Dump_2x2xN  ! For polarized incremental optical depth
    module procedure Dump_2x2xN_Complex, Dump_2x2xN_DComplex
  end interface

  ! =====     Private Generics     =====================================
  interface DumpCollapsedArray
    module procedure DumpCollapsedArray_1D_Double, DumpCollapsedArray_1D_Real
    module procedure DumpCollapsedArray_2D_Double, DumpCollapsedArray_2D_Real
    module procedure DumpCollapsedArray_3D_Double, DumpCollapsedArray_3D_Real
    module procedure DumpCollapsedArray_1D_Integer
    module procedure DumpCollapsedArray_2D_Integer
    module procedure DumpCollapsedArray_3D_Integer
  end interface

  Interface PrintIt
    module procedure PrintIt_Char, PrintIt_Double, PrintIt_Int, PrintIt_Real
    module procedure PrintIt_Complex, PrintIt_DComplex
  end Interface

  Interface PrintRMSEtc
    module procedure PrintRMSEtc_Double, PrintRMSEtc_int, PrintRMSEtc_Real
  end Interface

  Interface Say_Fill
    module procedure Say_Fill_Char, Say_Fill_Double, Say_Fill_Int
    module procedure Say_Fill_Real, Say_Fill_Complex, Say_Fill_DComplex
  end Interface

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: dump_0.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! These public parameters can't be reconfigured outside the module
  ! --------------------------------------------------------------------------

  ! --------------------------------------------------------------------------

  ! These are private variables declared module-wide purely for convenience
  integer, parameter          :: MaxNumElements    = 2000 
  logical                     :: DumpTheseZeros           
  character(len=16)           :: MyOptions                
  character(len=16)           :: MyPCTFormat              
  integer                     :: Bwidth                   
  integer                     :: myRank                   
  integer                     :: numFill               
  integer                     :: numNonFill               
  integer                     :: indx2BSliced             
  real                        :: Pctnzero                 
  logical, save               :: ThisIsADiff = .false.    
  integer                     :: How_many                 
  integer, dimension(1024)    :: which                    
  complex, parameter          :: one_c4 = (1., 0.)        
  character(len=*), parameter :: OldNameOnEachLine = ' ' ! Should be in dump_options

contains

  ! -----------------------------------------------  AsExplicitValues  -----
  ! Print lines that can be pasted into an l2cf as part of an
  ! explicit Fill using values of a 1d array.
  ! The defaults are chosen aptly. Change them only if you know
  ! what you're doing.
  subroutine AsExplicitValues ( Array, Unit, Separator, Brackets )
    ! Args
    real, intent(in)                       :: Array(:)
    character(len=*), intent(in), optional :: Unit      ! E.g., 'K'
    character(len=1), intent(in), optional :: Separator ! E.g., ','
    character(len=*), intent(in), optional :: Brackets  ! E.g., '[]'
    ! Internal variables
    integer                                :: Column
    integer                                :: i
    character(len=8)                       :: myUnit
    character(len=1)                       :: mySeparator
    character(len=2)                       :: myBrackets 
    ! Executable
    myUnit = Default( Unit, ' ' )
    mySeparator = Default( Separator, ',' )
    myBrackets = Default( Brackets, '[]' )
    if ( size(array) < 1 ) return
    call output ( myBrackets(1:1), advance='no' )
    call output ( ' $', advance='yes' )
    do i=1, size(array)
      call output( array(i), advance='no' )
      if ( len_trim(myUnit) > 0 ) call output( trim(myUnit), advance='no' )
      if ( i < size(array) ) then
        call output ( mySeparator, advance='no' )
        if ( len_trim(mySeparator) > 0 ) call Blanks( 1 )
      endif
      Column = getOutputStatus( 'column' )
      if ( Column > 72 ) then
        call output ( ' $', advance='yes' )
      endif

    enddo
    if ( getOutputStatus( 'start' ) /= 1 ) call output ( ' $', advance='yes' )
    call output ( myBrackets(2:2), advance='yes' )
    
  end subroutine AsExplicitValues

  ! -----------------------------------------------  Dump_1D_Bit  -----
  subroutine Dump_1D_Bit ( Array, Name, BITNameS, FillValue, Options )
    integer, intent(in) :: Array(:)
    character(len=*), intent(in) :: Name
    character(len=*), intent(in) :: BITNameS
    integer, intent(in), optional :: FillValue
    character(len=*), optional, intent(in) :: options

    integer :: howMany, J, K
    integer, dimension(MAXBITNUMBER) :: ints
    integer :: myFillValue
    integer :: NumBitNames
    integer :: NumZeroRows
    integer, dimension(MAXBITNUMBER+1) :: set
    ! Executable
    call theDumpBegins ( options )
    myFillValue = 0
    if ( present(FillValue) ) myFillValue = FillValue

    NumBitNames = NumStringElements( bitNames, countEmpty=.true. )
    if ( NumBitNames < 1 ) NumBitNames = MAXBITNUMBER+1
    NumBitNames = min( numBitNames, MAXBITNUMBER+1 )
    numZeroRows = 0
    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else
      call name_and_size ( name, dopts(clean)%v, size(array) )
      call newline
      call output( trim(BitNames), advance='yes' )
      do j=1, size(array)
        if ( array(j) == myFillValue ) then
          numZeroRows = numZeroRows + 1
        else
          call WhichBitsAreSet( array(j), set, howMany )
          ints = 0
          do k=1, howMany
            ints( 1 + set(k) ) = 1
          end do
          if ( numZeroRows > 0 ) then
            call output ( ' ' , advance='no' )
            call output ( numZeroRows , advance='no' )
            call output ( ' lines of ', advance='no' )
            call output ( myFillValue , advance='no' )
            call output ( ' not printed', advance='no' )
            call finishLine
          end if
          call output( ints(1:numBitNames), format='(i3)', advance='no' )
          call finishLine
          numZeroRows = 0
        end if
      end do
    end if
    call theDumpEnds
  end subroutine Dump_1D_Bit

  ! -----------------------------------------------  Dump_1D_Char  -----
  subroutine Dump_1D_Char ( Array, Name, FillValue, Width, Options, Maxlon, &
    & TheShape )
    character(len=*), intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    character(len=*), intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), optional, intent(in) :: Options
    integer, intent(in), optional :: Maxlon
    character(len=*), intent(in), optional :: TheShape

    integer :: J, K
    integer :: LON
    integer :: NumZeroRows
    character(len=len(array)) :: MyFillValue
    integer :: MyWidth

    call theDumpBegins ( options )
    myFillValue = ' '
    if ( present(FillValue) ) myFillValue = FillValue
    MyWidth = DefaultWidth ! 10
    if ( present(width) ) MyWidth = width

    lon = len(array(1))
    if ( dopts(trimIt)%v ) lon = maxval(len_trim(array))
    if ( present(maxlon) ) then
      lon = min(lon, maxlon)
    else if ( .not. dopts(trimIt)%v ) then
      lon = min(lon, DEFAULTMaxlon)
    end if

    numZeroRows = 0
    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else if ( size(array) == 1 ) then
      call name_and_size ( name, dopts(clean)%v, 1, TheShape )
      call output ( array(1)(1:lon), advance='no' )
      call finishLine
    else
      call name_and_size ( name, dopts(clean)%v, size(array) )
      if ( getOutputStatus( 'start' ) /= 1 ) call newLine
      do j = 1, size(array), MyWidth
        DumpTheseZeros = dopts(clean)%v .or. &
          & any(array(j:min(j+2*myWidth-1, size(array))) /= myFillValue) &
          & .or. &
          & size(array) <= myWidth
        if (.not. dopts(clean)%v) then
          if ( DumpTheseZeros ) then
            call say_fill ( (/ j-1, size(array) /), numZeroRows, &
              & myFillValue, inc=1 )
          else
            numZeroRows = numZeroRows + 1
          end if
        end if
        if ( DumpTheseZeros ) then
          do k = j, min(j+MyWidth-1, size(array))
              call output ( ' ' // array(k)(1:lon) // ' ' , advance='no' )
          end do
          call newLine
          numZeroRows = 0
        end if
      end do ! j
      call say_fill ( (/ j-MyWidth, size(array) /), numZeroRows, &
        & myFillValue )
    end if
    call theDumpEnds
  end subroutine Dump_1D_Char

  ! --------------------------------------------  Dump_1D_Complex  -----
  subroutine Dump_1D_Complex ( Array, Name, Width, Format, &
    & FillValue, Lbound, Options, TheShape )
    integer, parameter :: RK = kind(0.0e0)
    complex(rk), intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    real(rk), intent(in), optional :: FillValue
    integer, intent(in), optional :: Lbound ! Low bound for Array             
    character(len=*), optional, intent(in) :: Options
    character(len=*), intent(in), optional :: TheShape

    integer :: J, K, MyWidth
    character(len=64) :: MyFormat
    complex(rk) :: myFillValue
    integer :: Base
    integer :: NumZeroRows
    ! Executable
    myFormat = sdFormatDefaultCmplx
    call theDumpBegins ( options )
    myFillValue = 0.
    myWidth = 3
    if ( present(width) ) myWidth = width
    if ( present(format) ) myFormat = format
    if ( index(myFormat, '*') > 0 ) &
      & myFormat = numNeedsFormat( one_c4*maxval(abs(array)), format )
    base = 0
    if ( present(lbound) ) base = lbound - 1

    include 'dump1db.f9h'
  end subroutine Dump_1D_Complex

  ! --------------------------------------------  Dump_1D_DComplex  -----
  subroutine Dump_1D_DComplex ( Array, Name, Width, Format, &
    & FillValue, Lbound, Options, TheShape )
    integer, parameter :: RK = kind(0.0d0)
    complex(rk), intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    real(rk), intent(in), optional :: FillValue
    integer, intent(in), optional :: Lbound ! Low bound for Array             
    character(len=*), optional, intent(in) :: Options
    character(len=*), intent(in), optional :: TheShape

    integer :: J, K, MyWidth
    character(len=64) :: MyFormat
    complex(rk) :: myFillValue
    integer :: Base
    integer :: NumZeroRows
    ! Executable
    myFormat = sdFormatDefaultCmplx
    call theDumpBegins ( options )
    myFillValue = 0.
    myWidth = 3
    if ( present(width) ) myWidth = width
    if ( present(format) ) myFormat = format
    if ( index(myFormat, '*') > 0 ) &
      & myFormat = numNeedsFormat( one_c4*maxval(abs(array)), format )
    base = 0
    if ( present(lbound) ) base = lbound - 1

    include 'dump1db.f9h'
  end subroutine Dump_1D_DComplex

 ! ---------------------------------------------  Dump_1D_Double  -----
  subroutine Dump_1D_Double ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape, Unit )
    double precision, intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    double precision, intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Lbound ! Low bound for Array
    character(len=*), optional, intent(in) :: Options
    character(len=*), intent(in), optional :: TheShape
    integer, intent(in), optional :: Unit

    integer, dimension(MaxNumElements) :: Counts
    double precision, dimension(MaxNumElements) :: Elements
    double precision :: MyFillValue
    integer :: Base, J, K
    character(len=64) :: MyFormat
    integer :: MyWidth
    integer :: NumZeroRows
    integer :: nUnique
    integer :: SU                ! Save unit
    su = outputOptions%prUnit
    if ( present(unit) ) outputOptions%prUnit = unit
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue
    myFormat = sdFormatDefault
    include 'dump1d.f9h'
    include 'dump1db.f9h'
    outputOptions%prUnit = su
  end subroutine Dump_1D_Double

  ! --------------------------------------------  Dump_1D_Integer  -----
  subroutine Dump_1D_Integer ( Array, Name, &
    & FillValue, Format, Width, Lbound, Options, TheShape, Unit )
    integer, intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Width ! How many numbers per line (10)?
    integer, intent(in), optional :: Lbound ! Low bound for Array
    character(len=*), optional, intent(in) :: Options
    character(len=*), intent(in), optional :: TheShape
    integer, intent(in), optional :: Unit

    integer, dimension(MaxNumElements) :: counts
    integer, dimension(MaxNumElements) :: elements
    integer :: MyFillValue
    integer :: Base, J, K
    character(len=64) :: MyFormat
    integer :: MyWidth
    integer :: NumZeroRows
    integer :: nUnique
    integer :: SU                ! Save unit
    if ( present( Format ) ) call outputNamedValue ( 'format', format )
    su = outputOptions%prUnit
    if ( present(unit) ) outputOptions%prUnit = unit
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue
    myFormat = 'places=' // INTPLACES ! To sneak places arg into call to output
    include 'dump1d.f9h'
    include 'dump1db.f9h'
    outputOptions%prUnit = su
  end subroutine Dump_1D_Integer

  ! --------------------------------------------  Dump_1D_Integer_2B  -----
  subroutine Dump_1D_Integer_2B ( Array, Name, &
    & FillValue, Format, Width, Lbound, Options, TheShape, Unit )
    use ISO_C_BINDING, only: C_int16_t
    integer(C_int16_t), intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Width ! How many numbers per line (10)?
    integer, intent(in), optional :: Lbound ! Low bound for Array
    character(len=*), optional, intent(in) :: Options
    character(len=*), intent(in), optional :: TheShape
    integer, intent(in), optional :: Unit

    call dump( int(array), Name, &
    & FillValue, Format, Width, Lbound, Options, TheShape, Unit )
  end subroutine Dump_1D_Integer_2B

  ! ----------------------------------------------  Dump_1D_Logical ----
  subroutine Dump_1D_Logical ( Array, Name, Lbound, Options, TheShape )
    logical, intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: Lbound ! Low bound of Array
    character(len=*), optional, intent(in) :: Options
    character(len=*), intent(in), optional :: TheShape

    integer :: Base, J, K, N, Ntrue, Nfalse
    integer, dimension(size(Array))        :: whereTrue, whereFalse

    ! Executable
    call theDumpBegins ( options )
    base = 0
    if ( present(lbound) ) base = lbound - 1

    if ( any(shape(array) == 0) ) then
      call empty ( name ) ! The array appears to have no elements at all
    else if ( size(array) == 1 .and. base == 0 ) then
      ! The array appears to have only a single element
      call name_and_size ( name, dopts(clean)%v, 1 )
      call output ( array(1), advance='no' )
      call finishLine
    else if ( all(array .eqv. .true.) ) then
      ! The array appears to have only true elements
      call name_and_size ( name, dopts(clean)%v, size(array) )
      call output ( '(' )
      if ( present(lbound) ) call output ( lbound )
      call output ( ':) all ', advance='no' )
      call output( trim(arrayShapeToString(shape(array))), advance='no' )
      call output( ' values are T', advance='no' )
      call finishLine
    else if ( all(array .eqv. .false.) ) then
      ! The array appears to have only false elements
      call name_and_size ( name, dopts(clean)%v, size(array) )
      call output ( '(' )
      if ( present(lbound) ) call output ( lbound )
      call output ( ':) all ', advance='no' )
      call output( trim(arrayShapeToString(shape(array))), advance='no' )
      call output( ' values are F', advance='no' )
      call finishLine
    else if ( dopts(NaNs)%v ) then
      ! Display the indices where true and the indices where false
      call PrintName ( Name, NameHasBeenPrinted )
      call FindAll( array, whereTrue, Ntrue, whereFalse )
      Nfalse = size(array) - Ntrue
      NameHasBeenPrinted = .false.
      call dump( whereTrue(1:Ntrue), 'Indices where TRUE' )
      call dump( whereFalse(1:Nfalse), 'Indices where FALSE' )
    else if ( dopts(gaps)%v ) then
      ! Display gaps, i.e. only the exceptional elements;
      ! T among a host of otherwise F's
      ! or F among a host of otherwise T's
      call name_and_size ( name, dopts(clean)%v, size(array) )
      if ( getOutputStatus( 'start' ) /= 1 ) call newLine
      k = 0
      if ( size(array)/100 > 100 )  call showColumnNums( 100 )
      do j=1, size(array), 100
        N = min(k+100, size(array)) - k
        call output( k+1 , advance='no' )
        call output ( ' through ', advance='no' )
        call output( k+N, advance='no' )
        call finishLine
        ntrue = count( array(k+1 : min(k+100, size(array))) )
        nfalse = n - ntrue
        ! Special cases if all true or all false
        if ( nfalse < 1 ) then
          call output( 'all values are T', advance='no' )
        elseif ( ntrue < 1 ) then
          call output( 'all values are F', advance='no' )
        elseif ( ntrue > 0 .and. ( ntrue < nfalse .or. nfalse < 1 ) ) then
          call output( array(k+1 : k+N), onlyif=.true., advance='no' )
        else
          call output( array(k+1 : k+N), onlyif=.false., advance='no' )
        end if
        call finishLine
        k = k + 100
      end do
      call showColumnNums( 100 )
    else
      ! Run-of-the-mill matrix dumps of 'T' and 'F'
      call name_and_size ( name, dopts(clean)%v, size(array) )
      if ( getOutputStatus( 'start' ) /= 1 ) call newLine
      do j = 1, size(array), 34
        if (.not. dopts(clean)%v) then
          call output ( j+base, max(4,ilog10(size(array))+1) , advance='no' )
          call output ( afterSub , advance='no' )
        end if
        if ( dopts(dot)%v ) then ! print .false. as a dot
          do k = j, min(j+33, size(array))
            call output ( merge('T','.',array(k)) , advance='no' )
          end do
        else
          do k = j, min(j+33, size(array))
            call output ( array(k) , advance='no' )
          end do
        end if
        call newLine
      end do
    end if
    call theDumpEnds
  end subroutine Dump_1D_Logical

  ! -----------------------------------------------  Dump_1D_Real  -----
  subroutine Dump_1D_Real ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape, Unit )
    real, intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    real, intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Lbound ! Low bound for Array
    character(len=*), optional, intent(in) :: Options
    character(len=*), intent(in), optional :: TheShape
    integer, intent(in), optional :: Unit

    integer, dimension(MaxNumElements) :: Counts
    real, dimension(MaxNumElements) :: Elements
    real :: MyFillValue
    integer :: Base, J, K
    character(len=64) :: MyFormat
    integer :: MyWidth
    integer :: NumZeroRows
    integer :: nUnique
    integer :: SU                ! Save unit
    su = outputOptions%prUnit
    if ( present(unit) ) outputOptions%prUnit = unit
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue
    myFormat = sdFormatDefault
    include 'dump1d.f9h'
    include 'dump1db.f9h'
    outputOptions%prUnit = su
  end subroutine Dump_1D_Real

  ! -----------------------------------------------  Dump_2D_Char  -----
  recursive subroutine Dump_2D_Char ( Array, Name, FillValue, Width, Maxlon, &
    & Options, TheShape )
    character(len=*), intent(in) :: Array(:,:)
    character(len=*), intent(in), optional :: Name
    character(len=*), intent(in), optional :: FillValue
    integer, intent(in), optional :: Maxlon
    character(len=*), optional, intent(in) :: options
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: TheShape

    integer :: I, J, K
    integer :: Lon
    integer :: NumZeroRows
    character(len=len(array)) :: MyFillValue
    integer :: MyWidth

    call theDumpBegins ( options )
    if ( dopts(myTranspose)%v ) then
      call dump ( transpose(array), name, &
        & fillvalue, width, &
        & options=snipoption(options, dopt_transpose) )
      return
    end if
    myFillValue = ' '
    if ( present(FillValue) ) myFillValue = FillValue
    MyWidth = DefaultWidth ! 10
    if ( present(width) ) MyWidth = width
    lon = len(array(1,1))
    if ( dopts(trimIt)%v ) lon = maxval(len_trim(array))
    if ( present(maxlon) ) lon = min(lon, maxlon)

    numZeroRows = 0
    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else if ( size( Array,1) == 1 ) then
      call name_and_size ( name, dopts(clean)%v, 1, TheShape )
      call output ( array(1,:), advance='no' )
      call finishLine
    else if ( size( Array,2) == 1 ) then
      call dump ( array(:,1), name, fillValue=fillValue, maxlon=maxlon, options=options )
    else
      call name_and_size ( name, dopts(clean)%v, size(array) )
      if ( getOutputStatus( 'start' ) /= 1 ) call newLine
      do i = 1, size( Array,1)
        do j = 1, size( Array,2), MyWidth
          DumpTheseZeros = dopts(clean)%v .or. &
            & any(array(i,j:min(j+2*MyWidth-1, size( Array,2))) /= myFillValue) &
            & .or. &
            & ( j+MyWidth >= size( Array,2) .and. &
            & any(array(min(i+1, size( Array,1)),1:min(1+MyWidth-1, size( Array,2))) &
            & /= myFillValue) &
            & )
          if (.not. dopts(clean)%v) then
            if ( DumpTheseZeros ) then
              call say_fill ( (/ i, size( Array,1), j-1, size( Array,2) /), &
                & numZeroRows, myFillValue, inc=3 )
            else
              numZeroRows = numZeroRows + 1
            end if
          end if
          if ( DumpTheseZeros ) then
            do k = j, min(j+myWidth-1, size( Array,2))
                call output ( ' ' // array(i,k)(1:lon) // ' ' , advance='no' )
            end do
            call newLine
            numZeroRows = 0
          end if
        end do ! j
      end do ! i
      call say_fill ( (/ i-1, size( Array,1), j-MyWidth, size( Array,2) /), &
        & numZeroRows, myFillValue )
    end if
    call theDumpEnds
  end subroutine Dump_2D_Char

  ! --------------------------------------------  Dump_2D_Complex  -----
  recursive subroutine Dump_2D_Complex ( Array, Name, Width, Format, &
    & FillValue, Options, Lbound, TheShape )
    integer, parameter :: RK = kind(0.0e0)
    complex(rk), intent(in) :: Array(:,:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: Width ! How many per line?
    character(len=*), optional :: Format
    real, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    integer, intent(in), optional :: LBound ! to print for first dimension
    character(len=*), intent(in), optional :: TheShape

    integer :: Base, I, J, K
    integer :: MyWidth
    integer :: NumZeroRows
    complex(rk) :: MyFillValue
    character(len=64) :: MyFormat
    ! Executable

    myFormat = sdFormatDefaultCmplx
    call theDumpBegins ( options )
    if ( dopts(myTranspose)%v ) then
      call dump ( transpose(array), name, &
        & width, format, fillvalue, &
        & options=snipoption(options, dopt_transpose) )
      return
    end if

    myWidth = 3
    if ( present(width) ) myWidth = width

    if ( present(format) ) myFormat = format
    if ( index(myFormat, '*') > 0 ) &
      & myFormat = numNeedsFormat( one_c4*maxval(abs(array)), format )

    myFillValue = 0.0_rk
    if ( present(fillValue) ) myFillValue = fillValue

    base = 1
    if ( present(lbound) ) base = lbound

    include 'dump2db.f9h'
  end subroutine Dump_2D_Complex

  ! --------------------------------------------  Dump_2D_DComplex  -----
  recursive subroutine Dump_2D_DComplex ( Array, Name, Width, Format, &
    & FillValue, Options, Lbound, TheShape )
    integer, parameter :: RK = kind(0.0d0)
    complex(rk), intent(in) :: Array(:,:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: Width ! How many per line?
    character(len=*), optional :: Format
    real(rk), intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    integer, intent(in), optional :: LBound ! to print for first dimension
    character(len=*), intent(in), optional :: TheShape

    integer :: Base, I, J, K
    integer :: myWidth
    integer :: NumZeroRows
    complex(rk) :: myFillValue
    character(len=64) :: MyFormat

    ! Executable

    myFormat = sdFormatDefaultCmplx
    call theDumpBegins ( options )
    if ( dopts(myTranspose)%v ) then
      call dump ( transpose(array), name, &
        & width, format, fillvalue, &
        & options=snipoption(options, dopt_transpose) )
      return
    end if

    myWidth = 3
    if ( present(width) ) myWidth = width

    if ( present(format) ) myFormat = format
    if ( index(myFormat, '*') > 0 ) &
      & myFormat = numNeedsFormat( one_c4*maxval(abs(array)), format )

    myFillValue = 0.0_rk
    if ( present(fillValue) ) myFillValue = fillValue

    base = 1
    if ( present(lbound) ) base = lbound

    include 'dump2db.f9h'
  end subroutine Dump_2D_DComplex

  ! ---------------------------------------------  Dump_2D_Double  -----
 recursive subroutine Dump_2D_Double ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape, Unit )
    double precision, intent(in) :: Array(:,:)
    character(len=*), intent(in), optional :: Name
    double precision, intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Lbound ! to print for first dimension
    character(len=*), intent(in), optional :: Options
    character(len=*), intent(in), optional :: TheShape
    integer, intent(in), optional :: Unit

    integer :: Base, I, J, K
    integer :: NumZeroRows
    double precision :: MyFillValue
    character(len=64) :: MyFormat
    integer :: nUnique
    integer :: MyWidth
    integer, dimension(MaxNumElements) :: Counts
    double precision, dimension(MaxNumElements) :: Elements
    integer :: SU                ! Save unit

    myFormat = sdFormatDefault
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue

    su = outputOptions%prUnit
    if ( present(unit) ) outputOptions%prUnit = unit
    base = 1
    if ( present(lbound) ) base = lbound
    include 'dump2d.f9h'
    include 'dump2db.f9h'
    outputOptions%prUnit = su
  end subroutine Dump_2D_Double

  ! --------------------------------------------  Dump_2D_Integer  -----
  recursive subroutine Dump_2D_Integer ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape, Unit )
    integer, intent(in) :: Array(:,:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Width ! How many numbers per line (10)?
    integer, intent(in), optional :: Lbound ! to print for first dimension
    character(len=*), intent(in), optional :: Options
    character(len=*), intent(in), optional :: TheShape
    integer, intent(in), optional :: Unit

    integer :: Base, I, J, K
    integer :: MyWidth
    integer :: NumZeroRows
    integer :: myFillValue
    character(len=64) :: MyFormat
    integer :: nUnique
    integer, dimension(MaxNumElements) :: Counts
    integer, dimension(MaxNumElements) :: Elements
    integer :: SU                ! Save unit

    myFormat = 'places=' // INTPLACES ! To sneak places arg into call to output
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue

    su = outputOptions%prUnit
    if ( present(unit) ) outputOptions%prUnit = unit
    base = 1
    if ( present(lbound) ) base = lbound

    include 'dump2d.f9h'
    include 'dump2db.f9h'
    outputOptions%prUnit = su
  end subroutine Dump_2D_Integer

  ! --------------------------------------------  Dump_2D_Integer_2B  -----
  recursive subroutine Dump_2D_Integer_2B ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape, Unit )
    use ISO_C_BINDING, only: C_int16_t
    integer(C_int16_t), intent(in) :: Array(:,:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Width ! How many numbers per line (10)?
    integer, intent(in), optional :: Lbound ! to print for first dimension
    character(len=*), intent(in), optional :: Options
    character(len=*), intent(in), optional :: TheShape
    integer, intent(in), optional :: Unit

    call dump( int(array), Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape, Unit )
  end subroutine Dump_2D_Integer_2B

  ! --------------------------------------------  Dump_2D_Logical  -----
  recursive subroutine Dump_2D_Logical ( Array, Name, Options, TheShape )
    logical, intent(in) :: Array(:,:)
    character(len=*), intent(in), optional :: Name
    character(len=*), intent(in), optional :: Options
    character(len=*), intent(in), optional :: TheShape

    integer :: I, J, K
    integer, parameter :: MyWidth = 34

    call theDumpBegins ( options )
    if ( dopts(myTranspose)%v ) then
      call dump ( transpose(array), name, &
        & options=snipoption(options, dopt_transpose) )
      return
    end if

    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else if ( size(array) == 1 ) then
      call name_and_size ( name, dopts(clean)%v, 1, TheShape )
      call output ( array(1,1), advance='no' )
      call finishLine
    else if ( size( Array,2) == 1 ) then
      call dump ( array(:,1), name, options=options )
    else if ( all(array .eqv. .true.) ) then
      call name_and_size ( name, dopts(clean)%v, size(array), TheShape )
      call output ( ': all ', advance='no' )
      call output( trim(arrayShapeToString(shape(array))), advance='no' )
      call output( ' values are T', advance='no' )
      call finishLine
    else if ( all(array .eqv. .false.) ) then
      call name_and_size ( name, dopts(clean)%v, size(array), TheShape )
      call output ( ': all ', advance='no' )
      call output( trim(arrayShapeToString(shape(array))), advance='no' )
      call output( ' values are F', advance='no' )
      call finishLine
    else
      call name_and_size ( name, dopts(clean)%v, size(array) )
      if ( getOutputStatus( 'start' ) /= 1 ) call newLine
      do i = 1, size( Array,1)
        do j = 1, size( Array,2), myWidth
          if (.not. dopts(clean)%v) then
            call output ( i, places=max(4,ilog10(size( Array,1))+1) , advance='no' )
            call output ( j, places=max(4,ilog10(size( Array,2))+1) , advance='no' )
            call output ( afterSub , advance='no' )
          end if
          if ( dopts(dot)%v ) then
            do k = j, min(j+33, size(array,2))
              call output ( merge('T','.',array(i,k)) , advance='no' )
            end do
          else
            do k = j, min(j+33, size(array,2))
              call output ( array(i,k) , advance='no' )
            end do
          end if
          call newLine
        end do ! j
      end do ! i
    end if
    call theDumpEnds
  end subroutine Dump_2D_Logical

  ! -----------------------------------------------  Dump_2D_Real  -----
  recursive subroutine Dump_2D_Real ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape, Unit )
    real, intent(in) :: Array(:,:)
    character(len=*), intent(in), optional :: Name
    real, intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Lbound
    character(len=*), intent(in), optional :: Options
    character(len=*), intent(in), optional :: TheShape
    integer, intent(in), optional :: Unit

    integer :: Base, I, J, K
    integer :: NumZeroRows
    real :: MyFillValue
    character(len=64) :: MyFormat
    integer :: nUnique
    integer :: MyWidth
    integer, dimension(MaxNumElements) :: Counts
    real, dimension(MaxNumElements) :: Elements
    integer :: SU                ! Save unit

    myFormat = sdFormatDefault
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue

    su = outputOptions%prUnit
    if ( present(unit) ) outputOptions%prUnit = unit
    base = 1
    if ( present(lbound) ) base = lbound

    include 'dump2d.f9h'
    include 'dump2db.f9h'
    outputOptions%prUnit = su
  end subroutine Dump_2D_Real

  ! --------------------------------------  Dump_1D_Sparse_Double  -----
  subroutine Dump_1D_Sparse_Double ( Array, Name, Format, Width, Parens, &
                                   & RowNum, Exclude, DidOne )
    double precision, intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Width   ! Items per line, default 5
    logical, intent(in), optional :: Parens
    integer, intent(in), optional :: RowNum  ! Print this first
    double precision, intent(in), optional :: Exclude ! Don't print these
    logical, intent(out), optional :: DidOne ! Printed a value

    logical :: NeedRow ! Need to print RowNum
    integer :: J, N, W
    character(len=64) :: MyFormat
    logical :: MyParens ! Enclose element number in parens instead of colon after

    myFormat = sdFormatDefault
    if ( present(format) ) myFormat = format
    w = 5
    if ( present(width) ) w = width
    myParens = .false.
    if ( present(parens) ) myParens = parens
    if ( present(name) ) call output ( trim(name), advance='yes' )
    needRow = present(rowNum)

    n = 0 ! Number on the line so far
    if ( present(didOne) ) didOne = .false.
    do j = 1, size(array)
      if ( array(j) == 0 ) cycle
      if ( present(exclude) ) then
        if ( array(j) == exclude ) cycle
      end if
      if ( needRow ) call output ( rowNum, places=4, after='#' )
      needRow = .false.
      if ( n >= w ) then
        call newLine
        call blanks ( 5 )
        n = 0
      end if
      n = n + 1
      if ( myParens ) then
        call output ( j, before=' (', after=') ' )
      else
        call output ( j, places=4, after=': ' )
      end if
      call output ( array(j), format=myFormat )
      if ( present(didOne) ) didOne = .true.
    end do
    if ( n /= 0 ) call newLine

  end subroutine Dump_1D_Sparse_Double

  ! ----------------------------------------  Dump_1D_Sparse_Real  -----
  subroutine Dump_1D_Sparse_Real ( Array, Name, Format, Width, Parens, &
                                 & RowNum, Exclude, DidOne )
    real, intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Width  ! Items per line, default 5
    logical, intent(in), optional :: Parens
    integer, intent(in), optional :: RowNum ! Print this first
    real, intent(in), optional :: Exclude   ! Don't print these
    logical, intent(out), optional :: DidOne ! Printed a value

    logical :: NeedRow ! Need to print RowNum
    integer :: J, N, W
    character(len=64) :: MyFormat
    logical :: MyParens ! Enclose element number in parens instead of colon after
    needRow = present(rowNum)

    myFormat = sdFormatDefault
    if ( present(format) ) myFormat = format
    w = 5
    if ( present(width) ) w = width
    myParens = .false.
    if ( present(parens) ) myParens = parens
    if ( present(name) ) call output ( trim(name), advance='yes' )

    n = 0 ! Number on the line so far
    if ( present(didOne) ) didOne = .false.
    do j = 1, size(array)
      if ( array(j) == 0 ) cycle
      if ( present(exclude) ) then
        if ( array(j) == exclude ) cycle
      end if
      if ( needRow ) call output ( rowNum, places=4, after='#' )
      needRow = .false.
      if ( n >= w ) then
        call newLine
        call blanks ( 5 )
        n = 0
      end if
      n = n + 1
      if ( myParens ) then
        call output ( j, before=' (', after=') ' )
      else
        call output ( j, places=4, after=': ' )
      end if
      call output ( array(j), format=myFormat )
      if ( present(didOne) ) didOne = .true.
    end do
    if ( n /= 0 ) call newLine

  end subroutine Dump_1D_Sparse_Real

  ! ----------------------------------  Dump_2D_Row_Sparse_Double  -----
  subroutine Dump_2D_Row_Sparse_Double ( Array, Name, Format, Width, Exclude )
    double precision, intent(in) :: Array(:,:)
    character(len=*), intent(in), optional :: Name
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Width ! Items per line, default 5
    double precision, intent(in), optional :: Exclude ! Don't print these

    logical :: DidAnyRow, DidOne
    integer :: I ! Row number

    if ( present(name) ) call output ( trim(name), advance='yes' )
    didAnyRow = .false.
    do i = 1, size(array,1)
      call dump_sparse ( array(i,:), format=format, width=width, parens=.true., &
        & rowNum=i, exclude=exclude, didOne = didOne )
      didAnyRow = didAnyRow .or. didOne
    end do
    if ( .not. didAnyRow ) then
      if ( present(exclude) ) then
        call output ( exclude, &
          & before="Either there are no nonzero elements, or they're all = ", &
          & advance="yes" )
      else
        call output ( "There are no nonzero elements", advance="yes" )
      end if
    end if

  end subroutine Dump_2D_Row_Sparse_Double

  ! ------------------------------------  Dump_2D_Row_Sparse_Real  -----
  subroutine Dump_2D_Row_Sparse_Real ( Array, Name, Format, Width, Exclude )
    real, intent(in) :: Array(:,:)
    character(len=*), intent(in), optional :: Name
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Width ! Items per line, default 5
    real, intent(in), optional :: Exclude  ! Don't print these

    logical :: DidAnyRow, DidOne
    integer :: I ! Row number

    if ( present(name) ) call output ( trim(name), advance='yes' )
    didAnyRow = .false.
    do i = 1, size(array,1)
      call dump_sparse ( array(i,:), format=format, width=width, parens=.true., &
        & rowNum=i, exclude=exclude, didOne = didOne )
      didAnyRow = didAnyRow .or. didOne
    end do
    if ( .not. didAnyRow ) then
      if ( present(exclude) ) then
        call output ( exclude, &
          & before="Either there are no nonzero elements, or they're all = ", &
          & advance="yes" )
      else
        call output ( "There are no nonzero elements", advance="yes" )
      end if
    end if

  end subroutine Dump_2D_Row_Sparse_Real

  ! -----------------------------------------  Dump_2x2xN_Complex  -----
  subroutine Dump_2x2xN_Complex ( Array, Name, Format, Options )
  ! This is for dumping polarized incremental optical depth
    integer, parameter :: RK = kind(0.0e0)
    complex(rk), intent(in) :: Array(:,:,:) ! Better be 2x2xn
    character(len=*), intent(in), optional :: Name
    character(len=*), intent(in), optional :: Format
    character(len=*), intent(in), optional :: Options

    integer :: J
    character(len=64) :: MyFormat

    call theDumpBegins ( options )
    myFormat = sdFormatDefaultCmplx
    if ( present(format) ) myFormat = format
    if ( index(myFormat, '*') > 0 ) &
      & myFormat = numNeedsFormat( one_c4*maxval(abs(array)), format )

    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else
      call name_and_size ( name, dopts(clean)%v, size(array) )
      if ( getOutputStatus( 'start' ) /= 1 ) call newLine
      do j = 1, size( Array,3)
        if (.not. dopts(clean)%v) then
          call output ( j, max(3,ilog10(size(array))+1) , advance='no' )
          call output ( afterSub , advance='no' )
        end if
        call output ( array(1,1,j), myFormat , advance='no' )
        call output ( array(1,2,j), myFormat, advance='no' )
        call finishLine
        call blanks ( max(3,ilog10(size(array))+1) + len(afterSub) )
        call output ( array(2,1,j), myFormat , advance='no' )
        call output ( array(2,2,j), myFormat, advance='no' )
        call finishLine
      end do
    end if
    call theDumpEnds
  end subroutine Dump_2x2xN_Complex

  ! ----------------------------------------  Dump_2x2xN_DComplex  -----
  subroutine Dump_2x2xN_DComplex ( Array, Name, Format, Options )
  ! This is for dumping polarized incremental optical depth
    integer, parameter :: RK = kind(0.0d0)
    complex(rk), intent(in) :: Array(:,:,:) ! Better be 2x2xn
    character(len=*), intent(in), optional :: Name
    character(len=*), intent(in), optional :: Format
    character(len=*), intent(in), optional :: Options

    integer :: J
    character(len=64) :: MyFormat

    call theDumpBegins ( options )
    myFormat = sdFormatDefaultCmplx
    if ( present(format) ) myFormat = format
    if ( index(myFormat, '*') > 0 ) &
      & myFormat = numNeedsFormat( one_c4*maxval(abs(array)), format )

    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else
      call name_and_size ( name, dopts(clean)%v, size(array) )
      if ( getOutputStatus( 'start' ) /= 1 ) call newLine
      do j = 1, size( Array,3)
        if (.not. dopts(clean)%v) then
          call output ( j, max(3,ilog10(size(array))+1) , advance='no' )
          call output ( afterSub , advance='no' )
        end if
        call output ( array(1,1,j), myFormat , advance='no' )
        call output ( array(1,2,j), myFormat, advance='no' )
        call finishLine
        call blanks ( max(3,ilog10(size(array))+1) + len(afterSub) )
        call output ( array(2,1,j), myFormat , advance='no' )
        call output ( array(2,2,j), myFormat, advance='no' )
        call finishLine
      end do
    end if
    call theDumpEnds
  end subroutine Dump_2x2xN_DComplex

  ! -----------------------------------------------  Dump_3D_Char  -----
  subroutine Dump_3D_Char ( Array, Name, FillValue, Width, &
    & Maxlon, Options, TheShape )
    character(len=*), intent(in) :: Array(:,:,:)
    character(len=*), intent(in), optional :: Name
    character(len=*), intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    integer, intent(in), optional :: Maxlon
    character(len=*), intent(in), optional :: Options
    character(len=*), intent(in), optional :: TheShape

    integer :: LON
    integer :: I, J, K, L
    integer :: NumZeroRows
    character(len=len(array)) :: MyFillValue
    integer :: MyWidth

    call theDumpBegins ( options )
    myFillValue = ' '
    if ( present(FillValue) ) myFillValue = FillValue

    lon = len(array(1,1,1))
    if ( dopts(trimIt)%v ) lon = maxval(len_trim(array))
    if ( present(maxlon) ) lon = min(lon, maxlon)
    MyWidth = DefaultWidth ! 10
    if ( present(width) ) MyWidth = width

    numZeroRows = 0
    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else if ( size( Array,1) == 1 ) then
      call dump ( array(1,:,:), name, fillValue=fillValue, &
        & maxlon=maxlon, options=options, width=width )
    else if ( size( Array,2) == 1 ) then
      call dump ( array(:,1,:), name, fillValue=fillValue, &
        & maxlon=maxlon, options=options, width=width )
    else if ( size( Array,3) == 1 ) then
      call dump ( array(:,:,1), name, fillValue=fillValue, &
        & maxlon=maxlon, options=options, width=width )
    else
      call name_and_size ( name, dopts(clean)%v, size(array) )
      if ( getOutputStatus( 'start' ) /= 1 ) call newLine
      do i = 1, size( Array,1)
        do j = 1, size( Array,2)
          do k = 1, size( Array,3), MyWidth
            DumpTheseZeros = dopts(clean)%v .or. &
              & any(array(i,j,k:min(k+2*MyWidth-1, size( Array,3))) /= myFillValue) &
              & .or. &
              & ( k+MyWidth >= size( Array,3) .and. &
              & any(array(i,min(j+1, size( Array,2)),1:min(1+MyWidth-1, size( Array,3))) &
              & /= myFillValue) &
              & )
            if (.not. dopts(clean)%v) then
              if ( DumpTheseZeros ) then
                call say_fill ( (/ i, size( Array,1), j-1, size( Array,2), &
                  & k, size( Array,3) /), numZeroRows, myFillValue, inc=3 )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
          if ( DumpTheseZeros ) then
              do l = k, min(k+MyWidth-1, size( Array,3))
                  call output ( ' ' // array(i,j,l)(1:lon) // ' ' , advance='no' )
              end do
              call newLine
              numZeroRows = 0
            end if
          end do
        end do
      end do
      call say_fill ( (/ i-1, size( Array,1), j-1, size( Array,2), &
        & k-MyWidth, size( Array,3) /), numZeroRows, myFillValue )
    end if
    call theDumpEnds
  end subroutine Dump_3D_Char

  ! --------------------------------------------  Dump_3D_Complex  -----
  subroutine Dump_3D_Complex ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape )
    integer, parameter :: RK = kind(0.0e0)
    complex(rk), intent(in) :: Array(:,:,:)
    character(len=*), intent(in), optional :: Name
    real, intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Lbound
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: TheShape

    integer :: Base, I, ISlice, J, K, L
    integer :: NumZeroRows
    complex(rk) :: myFillValue
    character(len=64) :: MyFormat
    integer :: MyWidth

    ! Executable
    myFormat = sdFormatDefaultCmplx
    call theDumpBegins ( options )
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue

    if ( present(format) ) myFormat = format
    if ( index(myFormat, '*') > 0 ) &
      & myFormat = numNeedsFormat( one_c4*maxval(abs(array)), format )
    
    MyWidth = 3
    if ( present(width) ) MyWidth = width

    include 'dump3db.f9h'
  end subroutine Dump_3D_Complex

  ! -------------------------------------------  Dump_3D_DComplex  -----
  subroutine Dump_3D_DComplex ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape )
    integer, parameter :: RK = kind(0.0d0)
    complex(rk), intent(in) :: Array(:,:,:)
    character(len=*), intent(in), optional :: Name
    real(rk), intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Lbound
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: TheShape

    integer :: Base, I, ISlice, J, K, L
    integer :: NumZeroRows
    complex(rk) :: myFillValue
    character(len=64) :: MyFormat
    integer :: myWidth

    ! Executable
    myFormat = sdFormatDefaultCmplx
    call theDumpBegins ( options )
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue

    if ( present(format) ) myFormat = format
    if ( index(myFormat, '*') > 0 ) &
      & myFormat = numNeedsFormat( one_c4*maxval(abs(array)), format )
    
    MyWidth = 3
    if ( present(width) ) MyWidth = width

    include 'dump3db.f9h'
  end subroutine Dump_3D_DComplex

  ! ---------------------------------------------  Dump_3D_Double  -----
  subroutine Dump_3D_Double ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape )
    double precision, intent(in) :: Array(:,:,:)
    character(len=*), intent(in), optional :: Name
    double precision, intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Lbound
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: TheShape

    integer :: Base, I, ISlice, J, K, L
    integer :: NumZeroRows
    double precision :: myFillValue
    character(len=64) :: myFormat
    integer :: nUnique
    integer :: MyWidth
    integer, dimension(MaxNumElements) :: counts
    double precision, dimension(MaxNumElements) :: elements
    myFormat = sdFormatDefault
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue
    include 'dump3d.f9h'
    include 'dump3db.f9h'
  end subroutine Dump_3D_Double

  ! --------------------------------------------  Dump_3D_Integer  -----
  subroutine Dump_3D_Integer ( Array, Name, &
    & FillValue, Format, Width, Lbound, Options, TheShape )
    integer, intent(in) :: Array(:,:,:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Width ! How many numbers per line (10)?
    integer, intent(in), optional :: Lbound ! Low bound for Array
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: TheShape

    integer :: Base, I, ISlice, J, K, L
    integer :: NumZeroRows
    integer, dimension(3) :: which
    integer :: how_many

    character(len=64) :: MyFormat
    integer :: myFillValue
    integer :: nUnique
    integer :: MyWidth
    integer, dimension(MaxNumElements) :: counts
    integer, dimension(MaxNumElements) :: elements
    myFormat = 'places=' // INTPLACES ! To sneak places arg into call to output
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue
    include 'dump3d.f9h'
    include 'dump3db.f9h'
  end subroutine Dump_3D_Integer

  ! ---------------------------------------------  Dump_3D_Real  -----
  subroutine Dump_3D_Real ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options, TheShape )
    real, intent(in) :: Array(:,:,:)
    character(len=*), intent(in), optional :: Name
    real, intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Lbound
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: TheShape

    integer :: Base, I, ISlice, J, K, L
    integer :: NumZeroRows
    real    :: myFillValue
    character(len=64) :: MyFormat
    integer :: myWidth
    integer :: nUnique
    integer, dimension(MaxNumElements) :: counts
    real, dimension(MaxNumElements) :: elements
    myFormat = sdFormatDefault
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue
    include 'dump3d.f9h'
    include 'dump3db.f9h'
  end subroutine Dump_3D_Real

  ! ---------------------------------------------  Dump_4D_Double  -----
  subroutine Dump_4D_Double ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options )
    double precision, intent(in) :: Array(:,:,:,:)
    character(len=*), intent(in), optional :: Name
    double precision, intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Lbound
    character(len=*), intent(in), optional :: Options

    integer :: ISlice, J
    character(len=64) :: MyFormat
    integer :: nUnique
    integer, dimension(MaxNumElements) :: Counts
    double precision, dimension(MaxNumElements) :: Elements
    myFormat = sdFormatDefault
    include 'dump4d.f9h'
    include 'dump4db.f9h'
  end subroutine Dump_4D_Double

  ! ---------------------------------------------  Dump_4D_Real  -----
  subroutine Dump_4D_Real ( Array, Name, &
    & FillValue, Width, Format, Lbound, Options )
    real, intent(in) :: Array(:,:,:,:)
    character(len=*), intent(in), optional :: Name
    real, intent(in), optional :: FillValue
    integer, intent(in), optional :: Width
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Lbound
    character(len=*), intent(in), optional :: Options

    integer :: ISlice, J
    character(len=64) :: MyFormat
    integer :: nUnique
    integer, dimension(MaxNumElements) :: Counts
    real, dimension(MaxNumElements) :: Elements
    myFormat = sdFormatDefault
    include 'dump4d.f9h'
    include 'dump4db.f9h'
  end subroutine Dump_4D_Real

  ! ------------------------------------------------------  Empty  -----
  subroutine Empty ( Name )
    character(len=*), intent(in), optional :: Name

    if ( present(name) .and. .not. NameHasBeenPrinted ) then
      call output ( name , advance='no' )
      call output ( ' is ' , advance='no' )
      nameHasBeenPrinted = .true.
    end if
    call output ( 'empty', advance='yes' )

  end subroutine Empty

  ! -------------------------------------------------  FinishLine  -----
  ! Print a newLine, optionally echoing the item name
  subroutine FinishLine
    ! Executable
    if ( len_trim(nameOnEachLine) < 1 ) then
    ! No op
    elseif( PrintNameAtLineEnd ) then
      call blanksToColumn ( 80-len_trim(nameOnEachLine) )
      call output ( trim(nameOnEachLine), advance='no' )
    else
      call blanks (2)
      call output ( trim(nameOnEachLine), advance='no' )
    end if
    call newLine ( dont_make_blank_line=.true. )
  end subroutine FinishLine

  ! -----------------------------------------------------  ILOG10  -----
  integer function ILOG10(int)
    integer, intent(in) :: int
    ilog10=nint(log10(real(int)))
  end function ILOG10

  ! ----------------------------------------------  Name_And_Size  -----
  subroutine Name_And_Size ( Name, Clean, Size, TheShape )
    character(len=*), intent(in), optional :: Name
    logical, intent(in) :: Clean
    integer, intent(in) :: Size
    character(len=*), intent(in), optional :: TheShape

    if ( present(name) .and. .not. dopts(laconic)%v ) then
      if ( len_trim(name) < 1 ) return
      if ( .not. nameHasBeenPrinted ) then
        if ( .not. clean .and. .not. present(theShape) ) then
          call PrintName ( Name, NameHasBeenPrinted )
          return
        else
          call output ( name , advance='no' )
        endif
        if ( present(theShape) ) call output ( theShape , advance='no' )
      end if
      if ( clean ) then 
        call output ( trim(" \ ") ) ! This goofiness is to outwit an incorrect
                                    ! Intel compiler.
        call output ( size , advance='no' )
      end if
      if ( size == 1 ) call output ( ' ' , advance='no' )
      nameHasBeenPrinted = .true.
    end if

  end subroutine Name_And_Size

  ! =====     Private Procedures     ===================================

  ! -------------------------------------------------  Dump_Bogus  -----
  ! Never used--just here to tell Makefiles that dumpstats.f9h is
  ! a prerequisite for Dump_0 because perl script f90makedep.pl
  ! won't follow .f9h files to look for more uses and includes.
  ! When will we repair the perl script?
  !
  subroutine Dump_Bogus ( Array, Name, &
    & FillValue, Format, Width, Lbound, Options )
    integer, intent(in) :: Array(:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: Format
    integer, intent(in), optional :: Width ! How many numbers per line (10)?
    integer, intent(in), optional :: Lbound ! Low bound for Array
    character(len=*), optional, intent(in) :: options
    integer :: myFillValue
    myFillValue = 0
    myRank = 0
    include 'dumpstats.f9h'
  end subroutine Dump_Bogus

  ! -----------------------------------------  DumpCollapsedArray  -----
  ! This family of subroutines dumps a lower-rank representation of
  ! an array
  subroutine DumpCollapsedArray_1D_Integer ( Array, Name, FillValue, Options )
    INTEGER, intent(in) :: Array(:)
    character(len=*), intent(in) :: Name
    INTEGER, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    call output( 'Did not expect to dump collapsed 1d array', advance='yes' )
  end subroutine DumpCollapsedArray_1D_Integer

  subroutine DumpCollapsedArray_1D_Double ( Array, Name, FillValue, Options )
    double precision, intent(in) :: Array(:)
    character(len=*), intent(in) :: Name
    double precision, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    call output( 'Did not expect to dump collapsed 1d array', advance='yes' )
  end subroutine DumpCollapsedArray_1D_Double

  subroutine DumpCollapsedArray_1D_Real ( Array, Name, FillValue, Options )
    real, intent(in) :: Array(:)
    character(len=*), intent(in) :: Name
    real, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    call output( 'Did not expect to dump collapsed 1d array', advance='yes' )
  end subroutine DumpCollapsedArray_1D_Real

  subroutine DumpCollapsedArray_2D_Double ( Array, Name, FillValue, Options )
    double precision, intent(in) :: Array(:,:)
    character(len=*), intent(in) :: Name
    double precision, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    ! For dumping lower-rank collapsed representations
    double precision, dimension(size( Array, 1)) :: nums
    logical, dimension(size( Array, 1))          :: logs

    ! dump numerical representation
    if ( index(collapseOptions, 'num') > 0 ) then
      call collapse( Array, nums, options=collapseOptions )
      call dump( nums, name, fillvalue, Options=options )
    end if
    if ( index(collapseOptions, 'any') > 0 .or. &
      &  index(collapseOptions, 'all') > 0 ) then
      call collapse( Array, logs=logs, options=collapseOptions )
      call dump( logs, name, options=options )
    end if
  end subroutine DumpCollapsedArray_2D_Double

  subroutine DumpCollapsedArray_2D_Real ( Array, Name, FillValue, Options )
    real, intent(in) :: Array(:,:)
    character(len=*), intent(in) :: Name
    real, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    ! For dumping lower-rank collapsed representations
    real, dimension(size( Array, 1)) :: nums
    logical, dimension(size( Array, 1))          :: logs

    ! dump numerical representation
    if ( index(collapseOptions, 'num') > 0 ) then
      call collapse( Array, nums, options=collapseOptions )
      call dump( nums, name, fillvalue, Options=options )
    end if
    if ( index(collapseOptions, 'any') > 0 .or. &
      &  index(collapseOptions, 'all') > 0 ) then
      call collapse( Array, logs=logs, options=collapseOptions )
      call dump( logs, name, options=options )
    end if
  end subroutine DumpCollapsedArray_2D_Real

  subroutine DumpCollapsedArray_2D_Integer ( Array, Name, FillValue, Options )
    INTEGER, intent(in) :: Array(:,:)
    character(len=*), intent(in) :: Name
    INTEGER, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    ! For dumping lower-rank collapsed representations
    INTEGER, dimension(size( Array, 1)) :: nums
    logical, dimension(size( Array, 1))          :: logs

    ! dump numerical representation
    if ( index(collapseOptions, 'num') > 0 ) then
      call collapse( Array, nums, options=collapseOptions )
      call dump( nums, name, fillvalue, Options=options )
    end if
    if ( index(collapseOptions, 'any') > 0 .or. &
      &  index(collapseOptions, 'all') > 0 ) then
      call collapse( Array, logs=logs, options=collapseOptions )
      call dump( logs, name, options=options )
    end if
  end subroutine DumpCollapsedArray_2D_Integer

  subroutine DumpCollapsedArray_3D_Double ( Array, Name, FillValue, Options )
    double precision, intent(in) :: Array(:,:,:)
    character(len=*), intent(in) :: Name
    double precision, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    ! For dumping lower-rank collapsed representations
    double precision, dimension(size( Array, 1),size( Array, 2)) :: nums
    logical, dimension(size( Array, 1),size( Array, 2))          :: logs

    ! dump numerical representation
    if ( index(collapseOptions, 'num') > 0 ) then
      call collapse( Array, nums, options=collapseOptions )
      call dump( nums, name, fillvalue, Options=options )
    end if
    if ( index(collapseOptions, 'any') > 0 .or. &
      &  index(collapseOptions, 'all') > 0 ) then
      call collapse( Array, logs=logs, options=collapseOptions )
      call dump( logs, name, options=options )
    end if
  end subroutine DumpCollapsedArray_3D_Double

  subroutine DumpCollapsedArray_3D_Real ( Array, Name, FillValue, Options )
    real, intent(in) :: Array(:,:,:)
    character(len=*), intent(in) :: Name
    real, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    ! For dumping lower-rank collapsed representations
    real, dimension(size( Array, 1),size( Array, 2)) :: nums
    logical, dimension(size( Array, 1),size( Array, 2))          :: logs

    ! dump numerical representation
    if ( index(collapseOptions, 'num') > 0 ) then
      call collapse( Array, nums, options=collapseOptions )
      call dump( nums, name, fillvalue, Options=options )
    end if
    if ( index(collapseOptions, 'any') > 0 .or. &
      &  index(collapseOptions, 'all') > 0 ) then
      call collapse( Array, logs=logs, options=collapseOptions )
      call dump( logs, name, options=options )
    end if
  end subroutine DumpCollapsedArray_3D_Real

  subroutine DumpCollapsedArray_3D_Integer ( Array, Name, FillValue, Options )
    INTEGER, intent(in) :: Array(:,:,:)
    character(len=*), intent(in) :: Name
    INTEGER, intent(in), optional :: FillValue
    character(len=*), intent(in), optional :: options
    ! For dumping lower-rank collapsed representations
    INTEGER, dimension(size( Array, 1),size( Array, 2)) :: nums
    logical, dimension(size( Array, 1),size( Array, 2))          :: logs

    ! dump numerical representation
    if ( index(collapseOptions, 'num') > 0 ) then
      call collapse( Array, nums, options=collapseOptions )
      call dump( nums, name, fillvalue, Options=options )
    end if
    if ( index(collapseOptions, 'any') > 0 .or. &
      &  index(collapseOptions, 'all') > 0 ) then
      call collapse( Array, logs=logs, options=collapseOptions )
      call dump( logs, name, options=options )
    end if
  end subroutine DumpCollapsedArray_3D_Integer

  ! -----------------------------------------  ArrayShapeToString  -----
  function ArrayShapeToString ( ArrayShape ) result ( String )
    ! Given an array of integers return the shape as a string
    ! E.g., given (/4,2,6/) return '4*2*6'
    integer, dimension(:), intent(in) :: ArrayShape
    character(len=16) :: String
    ! Internal variables
    integer :: i
    ! Executable
    string = ' '
    if ( size(arrayShape) < 1 ) return
    do i=1, size( arrayshape )
      string = catLists( string, arrayShape(i), inseparator='*' )
    end do
    
  end function ArrayShapeToString
  
  ! ----------------------------------------------------  PrintIt  -----
  ! This family of subroutines exists only so that we can generically call
  ! output with either a numeric arg or a character string, 
  ! trimming if the latter
  subroutine PrintIt_Char ( it, format )
    character(len=*) :: it
    character(len=*), intent(in), optional :: Format
    call output ( trim(it), advance='no' )
  end subroutine PrintIt_Char

  subroutine PrintIt_int ( it, format )
    integer :: it
    character(len=*), intent(in), optional :: Format
    call output ( it, format=format, advance='no' )
  end subroutine PrintIt_int

  subroutine PrintIt_Real ( it, format )
    real :: it
    character(len=*), intent(in), optional :: Format
    call output ( it, format=format, advance='no' )
  end subroutine PrintIt_Real

  subroutine PrintIt_Double ( it, format )
    double precision :: it
    character(len=*), intent(in), optional :: Format
    call output ( it, format=format, advance='no' )
  end subroutine PrintIt_Double

  subroutine PrintIt_Complex ( it, format )
    integer, parameter :: RK = kind(0.0e0)
    complex(rk) :: it
    character(len=*), intent(in), optional :: Format
    call output ( it, format=format, advance='no' )
  end subroutine PrintIt_Complex

  subroutine PrintIt_DComplex ( it, format )
    integer, parameter :: RK = kind(0.0d0)
    complex(rk) :: it
    character(len=*), intent(in), optional :: Format
    call output ( it, format=format, advance='no' )
  end subroutine PrintIt_DComplex

  ! -------------------------------------------  PrintPercentages  -----
  ! Prints a nicely-formatted summary of equal, unequal, etc.
  ! using output
  subroutine PrintPercentages ( name, equal, unequal )
    character(len=*), intent(in), optional :: Name
    integer, intent(in) :: equal
    integer, intent(in) :: unequal
    if ( equal+unequal < 1 ) return
    myPCTFormat  = DefaultPCTFormat
    if ( PCTFormat /= '*' ) myPCTFormat = PCTFormat
    if ( present(name) ) call output ( trim(name), advance='no' )
    call blanks( 1, advance='no' )
    call output( fillvaluerelation, advance='no' )
    call output ( ', !', advance='no' )
    call output( fillvaluerelation, advance='no' )
    call output ( ' (%) ', advance='no' )
    call output ( equal, advance='no' )
    call output ( ': ', advance='no' )
    call output ( unequal, advance='no' )
    if ( .not. statsOnOneLine ) then
      call newline
      call blanks(10)
    end if
    call output ( '( ', advance='no' )
    call output ( 100*equal/(equal+unequal+0.), format = myPCTFormat, advance='no' )
    call output ( ': ', advance='no' )
    call output ( 100*unequal/(equal+unequal+0.), format = myPCTFormat, advance='no' )
    call output ( ' )', advance='no' )
    call finishLine
  end subroutine PrintPercentages

  ! ------------------------------------------------  PrintRMSetc  -----
  ! This family of routines prints a nicely-formatted list of min, max, etc.
  ! using output
  subroutine PrintRMSetc_Double ( Name, min, max, rms, mean )
    character(len=*), intent(in), optional :: Name
    double precision, intent(in) :: min
    double precision, intent(in) :: max
    double precision, intent(in) :: rms
    double precision, intent(in), optional :: mean
    !
    character(len=16) :: originalSDFormat
    !
    originalSDFormat = outputOptions%sdFormatDefault
    outputOptions%sdFormatDefault = rmsFormat
    include 'printRMSetc.f9h'
    outputOptions%sdFormatDefault = originalSDFormat
  end subroutine PrintRMSetc_Double

  subroutine PrintRMSetc_Real ( Name, min, max, rms, mean )
    character(len=*), intent(in), optional :: Name
    real, intent(in) :: min
    real, intent(in) :: max
    real, intent(in) :: rms
    real, intent(in), optional :: mean
    character(len=16) :: originalSDFormat
    !
    originalSDFormat = outputOptions%sdFormatDefault
    outputOptions%sdFormatDefault = rmsFormat
    include 'printRMSetc.f9h'
    outputOptions%sdFormatDefault = originalSDFormat
  end subroutine PrintRMSetc_Real

  subroutine PrintRMSetc_int ( Name, in_min, in_max, rms, mean )
    character(len=*), intent(in), optional :: Name
    integer, intent(in)        :: in_min
    integer, intent(in)        :: in_max
    real, intent(in)           :: rms
    real, intent(in), optional :: mean
    ! Internal variables
    real                       :: min
    real                       :: max
    ! Executable
    min = in_min
    max = in_max
    include 'printRMSetc.f9h'
  end subroutine PrintRMSetc_int

  ! This family of subroutines print subscripts to the left
  ! of each dumped row, sometimes noting that repeated lines
  ! that have been omitted for brevity
  ! ----------------------------------------------  Say_Fill_Char  -----
  subroutine Say_Fill_Char ( Subs, NumZeroRows, Fill, Inc, Format  )
    character(len=*), intent(in) :: Fill
    include 'Say_Fill.f9h'
  end subroutine Say_Fill_Char

  ! -------------------------------------------  Say_Fill_Complex  -----
  subroutine Say_Fill_Complex ( Subs, NumZeroRows, Fill, Inc, Format )
    integer, parameter :: RK = kind(0.0e0)
    complex(rk), intent(in) :: Fill
    include 'Say_Fill.f9h'
  end subroutine Say_Fill_Complex

  ! ------------------------------------------  Say_Fill_DComplex  -----
  subroutine Say_Fill_DComplex ( Subs, NumZeroRows, Fill, Inc, Format )
    integer, parameter :: RK = kind(0.0d0)
    complex(rk), intent(in) :: Fill
    include 'Say_Fill.f9h'
  end subroutine Say_Fill_DComplex

  ! --------------------------------------------  Say_Fill_Double  -----
  subroutine Say_Fill_Double ( Subs, NumZeroRows, Fill, Inc, Format )
    double precision, intent(in) :: Fill
    include 'Say_Fill.f9h'
  end subroutine Say_Fill_Double

  ! -----------------------------------------------  Say_Fill_Int  -----
  subroutine Say_Fill_Int ( Subs, NumZeroRows, Fill, Inc, Format )
    integer, intent(in) :: Fill
    include 'Say_Fill.f9h'
  end subroutine Say_Fill_Int

  ! ----------------------------------------------  Say_Fill_Real  -----
  subroutine Say_Fill_Real ( Subs, NumZeroRows, Fill, Inc, Format )
    real, intent(in) :: Fill
    include 'Say_Fill.f9h'
  end subroutine Say_Fill_Real

  ! ----------------------------------------------------  Say_Subs -----
  subroutine Say_Subs ( Subs, NumZeroRows )
    integer, intent(in) :: Subs(:)
    integer, intent(in) :: NumZeroRows
    call say_subs_only ( subs )
    call output ( ' ' , advance='no' )
    call output ( numZeroRows , advance='no' )
    call output ( ' lines of ', advance='no' )
  end subroutine Say_Subs

  ! -----------------------------------------------  Say_Subs_Only -----
  subroutine Say_Subs_Only ( Subs )
    integer, intent(in) :: Subs(:)
    integer :: I
    do i = 1, size(subs), 2
      call output ( subs(i), places=max(4,ilog10(subs(i+1))+2) , advance='no' )
    end do
    call output ( afterSub , advance='no' )
  end subroutine Say_Subs_Only
  
  ! ----------------------------------------------  ShowColumnNums -----
  subroutine ShowColumnNums( lineLength, skip )
    ! show column numbers
    ! usu. printed below other data to help guide the eye as to where
    ! stuff actually is
    ! E.g.,
    !   TTTT  TT  T
    !       FF  FF FFFF
    !   12345678901234567890          <-- These are the 
    !            1         2          <-- two lines we print here
    ! Args:
    integer, intent(in)           :: lineLength ! How many per line
    integer, intent(in), optional :: skip       ! start numbering after skip
    ! Internal variables
    integer                          :: bloc
    character(len=10), dimension(2)  :: line
    integer                          :: multiple
    integer                          :: mySkip
    integer                          :: numBlocs
    ! Executable
    numBlocs = 1 + (lineLength-1)/10
    mySkip = 0
    if ( present(skip) ) mySkip = skip
    line(1) = '1234567890'
!   line(2) = '         1'
    do multiple=1, 2
      if ( mySkip > 0 ) call blanks(mySkip)
      do bloc = 1, numBlocs
        write(line(2), '(i10)' ) bloc
        call output( line(multiple), advance='no' )
      end do
      call newline
    end do
  end subroutine ShowColumnNums

  ! --------------------------------------------------  SnipOption -----
  function SnipOption ( options, particular ) result ( snipped )
    ! Snip from options a particular option commanding dump or diff
    ! Args:
    character(len=*), optional, intent(in) :: options
    character(len=1), optional, intent(in) :: particular
    character(len=16)                      :: snipped
    ! Executable
    snipped = ' '
    if ( .not. present(options) .or. .not. present(particular) ) return
    snipped = delete( options, particular )
  end function SnipOption

  ! --------------------------------------------------  UniqueOnly -----
  logical function UniqueOnly ( options )
    character(len=*), intent(in), optional :: options
    ! Executable
    uniqueonly = .true.
    if ( .not. present(options) ) return
    uniqueonly = uniqueonly .and. &
      & .not. any( indexes(options, (/'w','s','r'/)) > 0 )

  end function UniqueOnly

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: dump_0.f90,v 2.162 2021/04/01 23:45:18 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Dump_0

! $Log: dump_0.f90,v $
! Revision 2.162  2021/04/01 23:45:18  pwagner
! DefaultWidth allplied consistently to all character-values
!
! Revision 2.161  2019/10/25 20:54:58  pwagner
! Dump full row of zeros if narrower than my width
!
! Revision 2.160  2019/07/22 22:21:38  pwagner
! -N opt now will display the indices where true and the indices where false if array is logical-valued
!
! Revision 2.159  2019/04/24 19:17:01  vsnyder
! Add Unit argument to several dumps
!
! Revision 2.158  2018/10/27 01:37:20  vsnyder
! Spiff sparse dumps
!
! Revision 2.157  2018/08/21 01:52:14  vsnyder
! Add Exclude argument to sparse dumps
!
! Revision 2.156  2018/08/16 02:17:43  vsnyder
! Add row sparse dump
!
! Revision 2.155  2018/04/25 01:47:43  vsnyder
! Add 1D sparse real and double precision dumps
!
! Revision 2.154  2018/04/13 00:22:49  pwagner
! Improved comments; explain use of appearance flags like 'MyName\h'
!
! Revision 2.153  2018/02/28 19:51:35  pwagner
! Moved PrintName to dump_options
!
! Revision 2.152  2017/12/07 02:40:10  vsnyder
! Remove some unreferenced use named.  Delete some unreferenced variable
! declarations.  Don't use host-associated DO index variables; make them
! local.
!
! Revision 2.151  2017/11/30 20:46:19  pwagner
! Avoid leaving OldNameOnEachLine undefined
!
! Revision 2.150  2017/11/03 20:01:40  pwagner
! Most array gymnastics moved from MLSFillValues to HyperSlabs module
!
! Revision 2.149  2017/10/11 20:56:23  pwagner
! Fixed bug in Dump_2D_Logical
!
! Revision 2.148  2017/09/15 22:37:55  pwagner
! Dont repeat name if empty
!
! Revision 2.147  2017/09/14 18:31:14  pwagner
! Take care to skip a space when dumping chars; aso not to print an unwanted blank line
!
! Revision 2.146  2017/09/07 23:44:30  pwagner
! Added PrintNameAsHeadline and PrintNameInBanner options to dump
!
! Revision 2.145  2017/09/07 20:59:35  pwagner
! Dont print 2 spaces before name
!
! Revision 2.144  2017/08/03 20:37:31  pwagner
! Try harder to avoid messing up dumps called with 'c(lean)'
!
! Revision 2.143  2017/07/31 23:05:47  pwagner
! Moved TheDumpEnds to dump_options; try to avoid blank lines
!
! Revision 2.142  2017/07/31 22:18:22  vsnyder
! Option to print FALSE as dot to make it easier to see TRUE
!
! Revision 2.141  2017/07/19 22:42:53  pwagner
! Added PrintName; may PrintNameAtLineEnd; PrintRMSetc now public
!
! Revision 2.140  2016/10/20 23:05:41  pwagner
! Separated row, column indexes in 2d arrays
!
! Revision 2.139  2016/07/28 03:28:17  vsnyder
! Moved comments to Dump_1 and Dump_Options
!
! Revision 2.138  2016/07/28 01:42:27  vsnyder
! Refactoring dump and diff
!
! Revision 2.137  2016/04/05 23:54:57  pwagner
! -v verbose option added; usu. will print name on each line
!
! Revision 2.136  2016/03/31 22:59:03  pwagner
! Added dumpTextfile
!
! Revision 2.135  2016/03/23 00:22:17  pwagner
! Diff now able to print name on each line; repaired error in printRMSEtc when array is integer
!
! Revision 2.134  2016/01/12 00:46:51  pwagner
! May override DEFAULTWidth when dumping char array
!
! Revision 2.133  2015/08/25 18:38:27  vsnyder
! Include Lbound in 'all values are the same' dumps
!
! Revision 2.132  2015/01/29 01:23:29  vsnyder
! Make sure MyFillValue has a value before references
!
! Revision 2.131  2014/08/06 23:02:21  vsnyder
! Use kind C_Int16_t from ISO_C_Bindings instead of INTEGER*2
!
! Revision 2.130  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.129  2013/09/26 15:25:41  pwagner
! Added 2-byte integer dumps
!
! Revision 2.128  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.127  2013/06/28 18:08:38  pwagner
! Note if all logical elements equal
!
! Revision 2.126  2013/06/19 23:14:39  pwagner
! Remove more unused stuff; give default value to myDirect
!
! Revision 2.125  2013/01/10 00:18:43  pwagner
! Dumps with -N just show where NaNs are
!
! Revision 2.124  2012/09/11 21:10:24  pwagner
! Requires 'N' option to show where NaNs, Infs are located
!
! Revision 2.123  2012/07/05 23:47:31  pwagner
! Added restoreDumpConfig
!
! Revision 2.122  2012/06/22 20:25:52  pwagner
! Specify advance arg because we may now set default to 'yes'
!
! Revision 2.121  2012/06/13 23:59:37  pwagner
! dumpDumpOptions optionally dumps available diff/dump options
!
! Revision 2.120  2012/01/09 22:25:55  pwagner
! Distinguish 'r' option to print rms of ratios and 'R' option for rms of values
!
! Revision 2.119  2011/12/15 01:47:45  pwagner
! Accepts W[i] option; deletes more prolix notices of rank reduction
!
! Revision 2.118  2011/12/07 01:14:44  pwagner
! Added option to show bandwidth of banded arrays
!
! Revision 2.117  2011/11/11 00:30:22  vsnyder
! Simplify notice of rank reduction
!
! Revision 2.116  2011/07/26 20:40:24  pwagner
! Added 4d diffs, too
!
! Revision 2.115  2011/07/23 00:16:25  vsnyder
! Use (1.,0.) instead of CMPLX(1.,0.) to avoid Intel gripe
!
! Revision 2.114  2011/07/15 23:23:43  pwagner
! Can now dump 4d arrays, with certain restrictions
!
! Revision 2.113  2011/07/12 00:15:01  pwagner
! Improved dumps; format option now more flexible; complex arrays parallel real ones
!
! Revision 2.112  2011/06/23 17:27:41  pwagner
! Added function to difference args with option to supply fillvalue or period
!
! Revision 2.111  2011/04/26 20:54:12  pwagner
! Can now dump dates
!
! Revision 2.110  2011/04/20 22:27:09  pwagner
! Fixed long-standing bug in dumping 2d char array
!
! Revision 2.109  2011/04/18 19:12:54  vsnyder
! Turn on nameHasBeenPrinted in more places
!
! Revision 2.108  2011/04/04 23:08:27  pwagner
! May diff 2d integer arrays
!
! Revision 2.107  2011/03/08 00:04:40  pwagner
! Skip printing row of zeros only if multiple
!
! Revision 2.106  2011/02/25 18:50:26  pwagner
! Added optional width arg to char array dumps
!
! Revision 2.105  2011/02/05 01:01:41  pwagner
! Added new dopt_ dump options; transpose and collapse work better
!
! Revision 2.104  2011/01/20 01:16:01  pwagner
! New '-l' option dumps collapsed representation of higher ranked array
!
! Revision 2.103  2011/01/04 00:48:26  pwagner
! DEFAULTMaxlon can now set max width of 1d char array dumps
!
! Revision 2.102  2010/10/14 18:44:01  pwagner
! Can now dump lists
!
! Revision 2.101  2010/02/04 23:05:39  vsnyder
! Remove USE and declaration for unreferenced names.
! Declare a kind parameter in unfiltereddiff*
!
! Revision 2.100  2010/01/29 21:08:21  pwagner
! gave myFillValue a value to stop lf95 complaints
!
! Revision 2.99  2009/11/20 01:15:11  pwagner
! Decided against using allFinite
!
! Revision 2.98  2009/11/20 01:12:50  pwagner
! Added new option H or 'shape' to just show array rank, Shape
!
! Revision 2.97  2009/10/30 23:02:41  pwagner
! Should not double-print name if only whole array diff
!
! Revision 2.96  2009/10/26 18:53:33  pwagner
! Fixed bug only NAG found
!
! Revision 2.95  2009/10/19 17:33:26  pwagner
! Trying to prevent double-printing of name
!
! Revision 2.94  2009/10/13 00:09:04  pwagner
! Percentages printed with better format; dumpstats.f9h now a direct prerequisite
!
! Revision 2.93  2009/09/10 20:58:00  pwagner
! 3 ways to summarize diffs: 'b' (table), 'r' (rms), 's' (number of differences)
!
! Revision 2.92  2009/08/18 20:41:17  pwagner
! making INTPLACES public can change appearance of dumped ints
!
! Revision 2.91  2009/08/17 16:55:41  pwagner
! Among options string 'd' means 'direct'
!
! Revision 2.90  2009/06/26 00:15:18  pwagner
! Added dumpDumpOptions
!
! Revision 2.89  2009/06/24 22:36:32  pwagner
! Make use of dump1-3.f9h include files
!
! Revision 2.88  2009/06/23 18:25:43  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.87  2009/06/16 17:12:55  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.86  2009/05/14 21:59:04  pwagner
! New optional arg AS_GAPS dor dumping 1d bit logicals
!
! Revision 2.85  2009/05/08 00:40:09  pwagner
! Avoid printing blank name when dumped with empty name string
!
! Revision 2.84  2009/04/01 23:30:49  pwagner
! Improved appearance when printing 'nnn lines of xxx not printed.'
!
! Revision 2.83  2008/11/24 19:34:47  pwagner
! Less wasteful of memory; should not segment dault so often
!
! Revision 2.82  2008/10/24 23:21:49  pwagner
! Limits 3d diffs to prevent segment faults
!
! Revision 2.81  2008/08/27 16:23:41  pwagner
! Added dumpSums
!
! Revision 2.80  2008/07/10 00:13:30  pwagner
! SelfDiff can now print half wave lengths
!
! Revision 2.79  2008/07/09 16:30:21  pwagner
! selfdiff can take optional arg unique
!
! Revision 2.78  2008/06/18 20:56:18  pwagner
! New optional arg 'unique' dumps print unique elements, counts only
!
! Revision 2.77  2008/01/09 20:53:22  pwagner
! When NaNs short-circuit dump or diff, print how many and where
!
! Revision 2.76  2008/01/07 21:37:57  pwagner
! Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
!
! Revision 2.75  2007/10/18 23:37:41  pwagner
! Added dumpTable
!
! Revision 2.74  2007/10/12 23:34:49  pwagner
! Using new howfar procedure to summarize diffs after peeling away outliers
!
! Revision 2.73  2007/09/20 18:39:37  pwagner
! Dont interrupt tables of dumped numbers with stamping
!
! Revision 2.72  2007/09/13 21:09:57  pwagner
! -rms and -s combined add new info about & how near
!
! Revision 2.71  2007/07/17 00:21:58  pwagner
! diff stats when rms concentrate on showing ratios
!
! Revision 2.70  2007/07/11 22:29:23  vsnyder
! Add more dumps for complex, add 2x2xN dumps
!
! Revision 2.69  2007/06/14 18:38:36  pwagner
! Allow separate rmsFormat to be set at class level
!
! Revision 2.68  2007/04/14 00:32:47  vsnyder
! Remove OPTIONAL attribute from Name1 and Name args of DIFF_...
!
! Revision 2.67  2007/04/03 02:49:23  vsnyder
! Don't look at non-present dummy argument
!
! Revision 2.66  2007/03/23 00:14:30  pwagner
! new optional maxlon arg to dumping n-d chars; sdFormatDefault for numeric dumps public and changeable
!
! Revision 2.65  2007/03/07 21:01:45  pwagner
! Some small changes unrelated to real bugs elsewhere
!
! Revision 2.64  2007/01/31 00:05:43  pwagner
! Added interface for dumping bit arrays
!
! Revision 2.63  2006/08/23 20:06:25  pwagner
! Restored more backward-compatible arglist to Dump_STRLIST
!
! Revision 2.62  2006/08/22 20:40:04  pwagner
! Added required arg=separator to Dump_STRLIST
!
! Revision 2.61  2006/07/11 00:24:04  pwagner
! use fillValue properly when computing rms etc.
!
! Revision 2.60  2006/06/24 23:07:04  pwagner
! Changes to reduce memory footprint computing statistics
!
! Revision 2.59  2006/06/09 18:50:12  pwagner
! Avoid dumping an entire array if all elements the same
!
! Revision 2.58  2006/05/24 20:38:14  pwagner
! Allow any of 3 ordering relations for dumping pct
!
! Revision 2.57  2006/04/20 01:09:30  vsnyder
! Don't print lines of zeroes in complex dumps
!
! Revision 2.56  2006/03/22 23:48:52  vsnyder
! Print 'lines ... not printed' instead of 'rows...' to avoid confusion with matrices
!
! Revision 2.55  2006/03/15 17:34:28  pwagner
! Fixed bug causing incorrect rms when diffing with fill values
!
! Revision 2.54  2006/03/03 23:04:55  pwagner
! May dump logical-valued hashes
!
! Revision 2.53  2006/02/28 21:42:29  pwagner
! Replace fillvalues with 0 before computing rms (should actually remove)
!
! Revision 2.52  2006/01/27 01:01:37  pwagner
! Can now dump hashes
!
! Revision 2.51  2005/12/17 00:58:56  pwagner
! dumps of rms, etc. should appear uniform
!
! Revision 2.50  2005/12/16 23:25:13  pwagner
! dumpSize moved from dump0 to output_m
!
! Revision 2.49  2005/12/16 00:04:06  pwagner
! Changes to reflect new MLSFillValues module
!
! Revision 2.48  2005/11/04 18:49:02  pwagner
! Added SelfDiff procedures to dump diffs among consecutive 1d array elems
!
! Revision 2.47  2005/10/03 18:05:52  pwagner
! Allocated memory now dumped in units of MEMORY_UNITS
!
! Revision 2.46  2005/07/20 01:33:47  vsnyder
! Simplify DumpSize routines
!
! Revision 2.45  2005/06/22 17:25:48  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.44  2005/05/12 20:43:54  pwagner
! Added diff routines
!
! Revision 2.43  2004/12/14 21:31:59  pwagner
! Optional trim arg added to multi-dim char dumps
!
! Revision 2.42  2004/08/16 17:09:14  pwagner
! 3d integer dumps interface redone like others
!
! Revision 2.41  2004/08/04 23:19:01  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.40  2004/07/23 19:47:20  vsnyder
! Add Lbound to Dump_1d_[double,integer,real]
!
! Revision 2.39  2004/07/23 18:34:59  vsnyder
! Add Lbound argument to Dump_1d_Logical
!
! Revision 2.38  2004/07/21 19:57:21  pwagner
! New rms, wholeArray options to some dumps
!
! Revision 2.37  2004/06/11 19:04:29  pwagner
! which_ints_are_it renamed findAll, moved MLSSets.f90
!
! Revision 2.36  2004/05/27 23:25:33  pwagner
! Added stats parameter; also more 1-d get fillvalue
!
! Revision 2.35  2004/04/05 17:47:43  livesey
! Split dumpsize into real and integer versions
!
! Revision 2.34  2004/04/03 05:43:23  livesey
! Added DumpSize
!
! Revision 2.33  2004/03/30 00:44:10  vsnyder
! Remove unused variable declaration
!
! Revision 2.32  2004/02/26 21:53:31  pwagner
! Can dump ,-separated string list
!
! Revision 2.31  2004/01/21 22:02:19  vsnyder
! Don't use number of entities per line as default width for counter
!
! Revision 2.30  2003/09/19 02:00:14  vsnyder
! More about the goofy Intel compiler
!
! Revision 2.29  2003/09/15 17:43:41  livesey
! Cosmetic change for fussy (and wrong) intel compiler
!
! Revision 2.28  2003/09/06 00:48:40  vsnyder
! Specify default formats with a module parameter instead of literals.
! Change default (1x,1pg13.6) to (1pg14.6) to avoid problems with length
! calculation in output_m.
!
! Revision 2.27  2003/08/08 20:45:42  vsnyder
! Made say_fill_* generic, made them test for numZeroRows, and made them
! optionally do say_subs_only.  This simplified several dump routines.
! Added optional Format arguments in several more routines.
!
! Revision 2.26  2003/07/04 02:41:33  vsnyder
! Substantial simplification by putting little things into subroutines
!
! Revision 2.25  2003/07/02 01:07:27  vsnyder
! Add complex output
!
! Revision 2.24  2003/05/21 19:20:40  vsnyder
! Start a new line after \ 1 if size==1 and clean
!
! Revision 2.23  2003/05/06 00:15:03  pwagner
! Fixed incompatibility with FilterShapes
!
! Revision 2.20.2.4  2003/05/05 23:00:05  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.20.2.3  2003/04/18 20:26:05  vsnyder
! Add Width and Format arguments to 1D_Real and 1D_Double
!
! Revision 2.20.2.2  2003/03/27 23:18:33  vsnyder
! Put new-lines in better places
!
! Revision 2.20.2.1  2003/03/14 00:25:47  vsnyder
! Add Dump_2D_Logical, cosmetic changes
!
! Revision 2.20  2002/12/02 23:34:14  pwagner
! Now can dump name/value pairs
!
! Revision 2.19  2002/10/08 00:09:08  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.18  2002/09/13 18:08:12  pwagner
! May change matrix precision rm from r8
!
! Revision 2.17  2002/02/14 23:21:18  vsnyder
! Work on dumping masks
!
! Revision 2.16  2001/12/08 00:47:51  pwagner
! Added Dump_1d_Real for s.p. arrays
!
! Revision 2.15  2001/11/29 23:50:53  pwagner
! Added optional blase arg to Dump_nd_Char; fixed bug where optional
! format not passed from Dump_3d_int
!
! Revision 2.14  2001/11/28 23:32:01  livesey
! Fixed bug where Dump_2d_Integer didn't pass format to 1d dump.
!
! Revision 2.13  2001/10/25 23:30:39  pwagner
! Improved Dump_nd_Double to skip rows (e.g., of zeros)
!
! Revision 2.12  2001/10/24 18:11:14  pwagner
! which_ints_are_it now works properly
!
! Revision 2.11  2001/10/23 22:40:37  pwagner
! Now dumps 1d,2d,3d char arrays and 3d ints
!
! Revision 2.10  2001/09/28 22:43:20  vsnyder
! Don't print rows of zeroes
!
! Revision 2.9  2001/09/11 22:52:32  livesey
! Added printing of sizes
!
! Revision 2.8  2001/05/11 22:44:54  vsnyder
! Print transpose of 2d-double if it would take fewer lines.  Get rid of
! double printing of "without mask"
!
! Revision 2.7  2001/05/08 20:27:24  vsnyder
! Added an optional 'format' argument in a few more places
!
! Revision 2.6  2001/05/08 17:21:02  livesey
! Added a `clean' option to the array dumps.  This omits the indices at
! the start, making it easier for other programs to read output.
!
! Revision 2.5  2001/05/03 02:12:34  vsnyder
! Insert copyright notice, clean up CVS stuff, cosmetics
!
! Revision 2.4  2001/03/10 03:39:58  vsnyder
! Improve handling of "name" if size==1 or size==0
!
! Revision 2.3  2001/03/02 01:32:08  livesey
! Handles larger arrays better
!
! Revision 2.2  2001/02/28 21:35:27  livesey
! Added dump logical 1d
!
! Revision 2.1  2000/09/13 20:38:50  vsnyder
! Initial code
!
@


2.162
log
@DefaultWidth allplied consistently to all character-values
@
text
@d52 2
a53 1
  use MLSStrings, only: delete, Indexes, ReadIntsFromChars
d65 3
d80 2
d115 1
d196 42
d2021 1
a2021 1
       "$Id: dump_0.f90,v 2.161 2019/10/25 20:54:58 pwagner Exp $"
d2031 3
@


2.161
log
@Dump full row of zeros if narrower than my width
@
text
@d264 1
a264 1
    MyWidth = DEFAULTWidth ! 10
d622 1
a622 1
    MyWidth = 10
d1224 1
a1224 1
    MyWidth = 10
d1972 1
a1972 1
       "$Id: dump_0.f90,v 2.160 2019/07/22 22:21:38 pwagner Exp $"
d1982 3
@


2.160
log
@-N opt now will display the indices where true and the indices where false if array is logical-valued
@
text
@d171 14
a184 4
  integer, parameter :: MaxNumElements          = 2000
  logical           :: DumpTheseZeros
  character(len=16) :: MyOptions
  character(len=16) :: MyPCTFormat
a185 6
  integer           :: Bwidth, myRank, numNonFill, numFill, indx2BSliced
  real              :: Pctnzero
  logical, save     :: ThisIsADiff = .false.
  integer           :: How_many
  integer, dimension(1024) :: which
  complex, parameter       :: one_c4 = (1., 0.)
d287 3
a289 1
          & any(array(j:min(j+2*myWidth-1, size(array))) /= myFillValue)
d1972 1
a1972 1
       "$Id: dump_0.f90,v 2.159 2019/04/24 19:17:01 vsnyder Exp $"
d1982 3
@


2.159
log
@Add Unit argument to several dumps
@
text
@d15 3
a17 3
! Should handle most combinations of rank and type
! Behavior depends on optional parameters
! Actual output device determined by output_m module
d24 8
d48 1
a48 1
  use MLSFinds, only: FindUnique
d464 1
d472 1
a472 1
      call empty ( name )
d474 1
d479 1
d488 1
d496 8
d505 3
d520 6
a525 1
        if ( ntrue > 0 .and. ( ntrue < nfalse .or. nfalse < 1 ) ) then
d535 1
d1966 1
a1966 1
       "$Id: dump_0.f90,v 2.158 2018/10/27 01:37:20 vsnyder Exp $"
d1976 3
@


2.158
log
@Spiff sparse dumps
@
text
@d366 1
a366 1
    & FillValue, Width, Format, Lbound, Options, TheShape )
d375 1
d385 3
d393 1
d398 1
a398 1
    & FillValue, Format, Width, Lbound, Options, TheShape )
d407 1
d417 1
d419 2
d426 1
d431 1
a431 1
    & FillValue, Format, Width, Lbound, Options, TheShape )
d441 1
d444 1
a444 1
    & FillValue, Format, Width, Lbound, Options, TheShape )
d531 1
a531 1
    & FillValue, Width, Format, Lbound, Options, TheShape )
d540 1
d550 3
d558 1
d730 1
a730 1
    & FillValue, Width, Format, Lbound, Options, TheShape )
d739 1
d749 1
d755 2
d761 1
d766 1
a766 1
    & FillValue, Width, Format, Lbound, Options, TheShape )
d775 1
d785 1
d791 2
d798 1
d803 1
a803 1
    & FillValue, Width, Format, Lbound, Options, TheShape )
d813 1
d816 1
a816 1
    & FillValue, Width, Format, Lbound, Options, TheShape )
d884 1
a884 1
    & FillValue, Width, Format, Lbound, Options, TheShape )
d893 1
d903 1
d909 2
d916 1
d1937 1
a1937 1
       "$Id: dump_0.f90,v 2.157 2018/08/21 01:52:14 vsnyder Exp $"
d1947 3
@


2.157
log
@Add Exclude argument to sparse dumps
@
text
@d922 6
a934 5
      n = n + 1
      if ( n >= w ) then
        call newLine
        n = 0
      end if
d975 6
a987 5
      n = n + 1
      if ( n >= w ) then
        call newLine
        n = 0
      end if
d1905 1
a1905 1
       "$Id: dump_0.f90,v 2.156 2018/08/16 02:17:43 vsnyder Exp $"
d1915 3
@


2.156
log
@Add row sparse dump
@
text
@d888 2
a889 1
  subroutine Dump_1D_Sparse_Double ( Array, Name, Format, Width, Parens )
d893 1
a893 1
    integer, intent(in), optional :: Width ! Items per line, default 5
d895 3
a897 1
    logical :: MyParens ! Enclose element number in parens instead of colon after
d899 1
d902 1
d911 1
d914 1
d916 17
a932 12
      if ( array(j) /= 0 ) then
        if ( myParens ) then
          call output ( j, before=' (', after=') ' )
        else
          call output ( j, places=4, after=': ' )
        end if
        call output ( array(j), format=myFormat )
        n = n + 1
        if ( n >= w ) then
          call newLine
          n = 0
        end if
d940 2
a941 1
  subroutine Dump_1D_Sparse_Real ( Array, Name, Format, Width, Parens )
d945 1
a945 1
    integer, intent(in), optional :: Width ! Items per line, default 5
d947 3
d951 1
d955 1
d966 1
d968 17
a984 12
      if ( array(j) /= 0 ) then
        if ( myParens ) then
          call output ( j, before=' (', after=') ' )
        else
          call output ( j, places=4, after=': ' )
        end if
        call output ( array(j), format=myFormat )
        n = n + 1
        if ( n >= w ) then
          call newLine
          n = 0
        end if
d992 1
a992 1
  subroutine Dump_2D_Row_Sparse_Double ( Array, Name, Format, Width )
d997 1
d999 1
d1003 1
d1005 3
a1007 2
      call output ( i, places=4, after='#' )
      call dump_sparse ( array(i,:), format=format, width=width, parens=.true. )
d1009 9
d1022 1
a1022 1
  subroutine Dump_2D_Row_Sparse_Real ( Array, Name, Format, Width )
d1027 1
d1029 1
d1033 1
d1035 3
a1037 2
      call output ( i, places=4, after='#' )
      call dump_sparse ( array(i,:), format=format, width=width, parens=.true. )
d1039 9
d1903 1
a1903 1
       "$Id: dump_0.f90,v 2.155 2018/04/25 01:47:43 vsnyder Exp $"
d1913 3
@


2.155
log
@Add 1D sparse real and double precision dumps
@
text
@d120 1
d888 1
a888 1
  subroutine Dump_1D_Sparse_Double ( Array, Name, Format, Width )
d893 2
d903 2
d910 5
a914 1
        call output ( j, places=4, after=': ' )
d928 1
a928 1
  subroutine Dump_1D_Sparse_Real ( Array, Name, Format, Width )
d933 1
d937 1
d943 2
d950 5
a954 1
        call output ( j, places=4, after=': ' )
d967 34
d1853 1
a1853 1
       "$Id: dump_0.f90,v 2.154 2018/04/13 00:22:49 pwagner Exp $"
d1863 3
@


2.154
log
@Improved comments; explain use of appearance flags like 'MyName\h'
@
text
@d101 1
a101 1
    & Dump, Dump_2x2xN, Empty, FinishLine, ILog10, Name_And_Size, &
d118 5
a122 1
  interface Dump_2x2xN ! For polarized incremental optical depth
d886 64
d1802 1
a1802 1
       "$Id: dump_0.f90,v 2.153 2018/02/28 19:51:35 pwagner Exp $"
d1812 3
@


2.153
log
@Moved PrintName to dump_options
@
text
@a23 3
! This has become too long--we may split it, putting diffs into a higher-level
! and separate Dump_1.f90 module

d68 1
a68 1
! dump ( Array, char* name,
d83 15
d1734 1
a1734 1
       "$Id: dump_0.f90,v 2.152 2017/12/07 02:40:10 vsnyder Exp $"
d1744 3
@


2.152
log
@Remove some unreferenced use named.  Delete some unreferenced variable
declarations.  Don't use host-associated DO index variables; make them
local.
@
text
@d30 1
a30 1
    & Clean, CollapseIt, CollapseOptions,  &
d35 2
a36 2
    & PCTFormat, PrintFillValue, PrintNameAsHeadline, PrintNameAtLineEnd, &
    & PrintNameInBanner, Ratios, RMS, RMSFormat, &
d40 1
a40 2
  use HighOutput, only: Banner, BlanksToColumn, Headline, &
    & NumNeedsFormat, OutputNamedValue
a1250 32
  ! -------------------------------------------------  PrintName  -----
  ! Print the item name unless already done so
  subroutine PrintName ( Name, nameHasBeenPrintedAlready )
    character(len=*), intent(in), optional        :: Name
    logical, optional                             :: nameHasBeenPrintedAlready
    ! Local variables
    logical                                       :: atLineStart
    character(len=64)                             :: myName
    ! Executable
    if ( present(nameHasBeenPrintedAlready) ) then
      if ( nameHasBeenPrintedAlready ) return
    endif
    myName = NameOnEachLine
    if ( present(name) ) myName = name
    if ( len_trim(myName) < 1 ) return
    atLineStart = ( getOutputStatus( 'start' ) == 1 )
    if( PrintNameAsHeadline .and. atLineStart ) then
      call Headline( trim(myName), FillChar='-', before='* ', after=' *' )
    elseif( PrintNameInBanner .and. atLineStart ) then
      call Banner( trim(myName) )
    elseif( PrintNameAtLineEnd ) then
      call blanksToColumn ( 80-len_trim(myName) )
      call output ( trim(myName), advance='no' )
      if ( .not. dopts(Clean)%v ) call newLine
    else
      if ( .not. dopts(Clean)%v .and. .not. atLineStart ) call blanks (2)
      call output ( trim(myName), advance='no' )
      if ( .not. dopts(Clean)%v ) call newLine
    end if
    if ( present(nameHasBeenPrintedAlready) ) nameHasBeenPrintedAlready = .true.
  end subroutine PrintName

d1722 1
a1722 1
       "$Id: dump_0.f90,v 2.151 2017/11/30 20:46:19 pwagner Exp $"
d1732 5
@


2.151
log
@Avoid leaving OldNameOnEachLine undefined
@
text
@d34 1
a34 1
    & NameHasBeenPrinted, NameOnEachLine, NaNs, OnlyWholeArray, &
d36 1
a36 1
    & PrintNameIfDiff, PrintNameInBanner, Ratios, RMS, RMSFormat, &
d39 1
a39 1
    & TrimIt, Unique, Verbose, WholeArray
d49 1
a49 1
  use Output_m, only: OutputOptions, StampOptions, &
a147 1
  logical, parameter :: DEEBUG                  = .false.
d152 1
a152 1
  integer           :: Bwidth, myRank, numNonFill, numFill, indx2BSliced, iSlice
d1040 1
a1040 1
    integer :: Base, I, J, K, L
d1075 1
a1075 1
    integer :: Base, I, J, K, L
d1109 1
a1109 1
    integer :: Base, I, J, K, L
d1136 1
a1136 1
    integer :: Base, I, J, K, L
d1166 1
a1166 1
    integer :: Base, I, J, K, L
d1192 1
a1192 1
    integer :: J
d1213 1
a1213 1
    integer :: J
d1755 1
a1755 1
       "$Id: dump_0.f90,v 2.150 2017/11/03 20:01:40 pwagner Exp $"
d1765 3
@


2.150
log
@Most array gymnastics moved from MLSFillValues to HyperSlabs module
@
text
@d152 1
a152 1
  character(len=64) :: OldNameOnEachLine
d1756 1
a1756 1
       "$Id: dump_0.f90,v 2.149 2017/10/11 20:56:23 pwagner Exp $"
d1766 3
@


2.149
log
@Fixed bug in Dump_2D_Logical
@
text
@d27 1
d42 1
a42 2
  use MLSFillValues, only: Bandwidth, Collapse, &
    & InfFunction, IsFinite, IsInfinite, IsNaN, NaNFunction, &
d1756 1
a1756 1
       "$Id: dump_0.f90,v 2.148 2017/09/15 22:37:55 pwagner Exp $"
d1766 3
@


2.148
log
@Dont repeat name if empty
@
text
@d825 1
a825 1
            do k = j, min(j+33, size(array))
d829 1
a829 1
            do k = j, min(j+33, size(array))
d1756 1
a1756 1
       "$Id: dump_0.f90,v 2.147 2017/09/14 18:31:14 pwagner Exp $"
d1766 3
@


2.147
log
@Take care to skip a space when dumping chars; aso not to print an unwanted blank line
@
text
@d1228 1
a1228 1
    if ( present(name) ) then
d1756 1
a1756 1
       "$Id: dump_0.f90,v 2.146 2017/09/07 23:44:30 pwagner Exp $"
d1766 3
@


2.146
log
@Added PrintNameAsHeadline and PrintNameInBanner options to dump
@
text
@d257 1
a257 1
      if ( present(name) .and. .not. dopts(laconic)%v ) call newLine
d271 1
a271 1
              call output ( array(k)(1:lon) // ' ' , advance='no' )
d460 1
a460 1
      if ( present(name) .and. .not. dopts(laconic)%v ) call newLine
d482 1
a482 1
      if ( present(name) .and. .not. dopts(laconic)%v ) call newLine
d573 1
a573 1
      if ( present(name) .and. .not. dopts(laconic)%v ) call newLine
d593 1
a593 1
                call output ( array(i,k)(1:lon) // ' ' , advance='no' )
d816 1
a816 1
      if ( present(name) .and. .not. dopts(laconic)%v ) call newLine
d894 1
a894 1
      if ( present(name) .and. .not. dopts(laconic)%v ) call newLine
d934 1
a934 1
      if ( present(name) .and. .not. dopts(laconic)%v ) call newLine
d993 1
a993 1
      if ( present(name) .and. .not. dopts(laconic)%v ) call newLine
d1014 1
a1014 1
                  call output ( array(i,j,l)(1:lon) // ' ' , advance='no' )
d1301 6
a1306 1
        call output ( name , advance='no' )
d1756 1
a1756 1
       "$Id: dump_0.f90,v 2.145 2017/09/07 20:59:35 pwagner Exp $"
d1766 3
@


2.145
log
@Dont print 2 spaces before name
@
text
@d33 3
a35 3
    & NameHasBeenPrinted, NameOnEachLine, NaNs, OnlyWholeArray, PCTFormat, &
    & PrintFillValue, PrintNameAtLineEnd, PrintNameIfDiff, &
    & Ratios, RMS, RMSFormat, &
d39 2
a40 1
  use HighOutput, only: BlanksToColumn, NumNeedsFormat, OutputNamedValue
d1267 1
d1269 5
a1273 1
    if( PrintNameAtLineEnd ) then
d1276 1
d1280 1
a1281 1
    if ( .not. dopts(Clean)%v ) call newLine
d1751 1
a1751 1
       "$Id: dump_0.f90,v 2.144 2017/08/03 20:37:31 pwagner Exp $"
d1761 3
@


2.144
log
@Try harder to avoid messing up dumps called with 'c(lean)'
@
text
@d49 1
a49 1
    & Blanks, Newline, Output
d1257 2
d1266 1
d1271 1
a1271 1
      if ( .not. dopts(Clean)%v ) call blanks (2)
d1744 1
a1744 1
       "$Id: dump_0.f90,v 2.143 2017/07/31 23:05:47 pwagner Exp $"
d1754 3
@


2.143
log
@Moved TheDumpEnds to dump_options; try to avoid blank lines
@
text
@d1268 1
a1268 1
      call blanks (2)
d1271 1
a1271 1
    call newLine
d1741 1
a1741 1
       "$Id: dump_0.f90,v 2.141 2017/07/19 22:42:53 pwagner Exp $"
d1751 3
@


2.142
log
@Option to print FALSE as dot to make it easier to see TRUE
@
text
@d37 1
a37 1
    & TheDumpBegins, ItsShape, MyTranspose=>Transpose, &
a67 1
! TheDumpEnds              Housekeeping
a83 1
! TheDumpEnds
d90 1
a90 1
    & PrintName, PrintRMSEtc, TheDumpEnds
d1249 1
a1249 1
    call newLine
a1304 5
  ! -------------------------------------------------  TheDumpEnds -----
  subroutine TheDumpEnds
    stampOptions%neverStamp = .false.
  end subroutine TheDumpEnds

d1751 3
@


2.141
log
@Added PrintName; may PrintNameAtLineEnd; PrintRMSetc now public
@
text
@d31 1
a31 1
    & DefaultWidth, Dopt_Collapse, Dopt_Transpose, DiffRMSMeansRMS, &
d489 9
a497 3
        do k = j, min(j+33, size(array))
          call output ( array(k) , advance='no' )
        end do
d825 9
a833 3
          do k = j, min(j+myWidth-1, size( Array,2))
            call output ( array(i,k) , advance='no' )
          end do
d1748 1
a1748 1
       "$Id: dump_0.f90,v 2.140 2016/10/20 23:05:41 pwagner Exp $"
d1758 3
@


2.140
log
@Separated row, column indexes in 2d arrays
@
text
@d28 3
a30 2
  use Dump_Options, only: AfterSub, MyBandwidth=>Bandwidth, Clean, CollapseIt, &
    & CollapseOptions,  DefaultDumpOptions, DefaultMaxLon, DefaultPCTFormat, &
d34 6
a39 4
    & PrintFillValue, PrintNameIfDiff, Ratios, RMS, RMSFormat, SDFormatDefault, &
    & SDFormatDefaultCmplx, Stats, StatsOnOneLine, &
    & TheDumpBegins, ItsShape, MyTranspose=>Transpose, TrimIt, Unique, Verbose, WholeArray
  use HighOutput, only: NumNeedsFormat, OutputNamedValue
d51 1
a51 1
  implicit NONE
d59 10
a68 1
! Dump                     dump an array to output
d78 8
d92 1
a92 1
    & TheDumpEnds
d153 1
d1230 6
a1235 1
    if ( len_trim(nameOnEachLine) > 1 ) then
d1242 23
d1569 1
a1569 1
  subroutine PrintRMSetc_Double ( Name, min, max, rms, mean  )
d1584 1
a1584 1
  subroutine PrintRMSetc_Real ( Name, min, max, rms, mean  )
d1598 1
a1598 1
  subroutine PrintRMSetc_int ( Name, in_min, in_max, rms, mean  )
d1736 1
a1736 1
       "$Id: dump_0.f90,v 2.139 2016/07/28 03:28:17 vsnyder Exp $"
d1746 3
@


2.139
log
@Moved comments to Dump_1 and Dump_Options
@
text
@d1620 1
a1620 1
      call output ( subs(i), places=max(4,ilog10(subs(i+1))+1) , advance='no' )
d1687 1
a1687 1
       "$Id: dump_0.f90,v 2.138 2016/07/28 01:42:27 vsnyder Exp $"
d1697 3
@


2.138
log
@Refactoring dump and diff
@
text
@a54 19
!     (parameters)
! AFTERSUB                 character printed between row, col id and data
! CollapseOptions          options determining what and how to dump collapsed
!                           representations of multidimensional arrays
! DEFAULTDIFFOPTIONS       switches to set default DIFF values for CLEAN, TRIM, etc.
! DEFAULTDUMPOPTIONS       same as above, but for DUMP
! DIFFRMSMEANSRMS          print abs min, max, etc. when DIFF has RMS set TRUE
! DONTDUMPIFALLEQUAL       don't dump every element of a constant array
! DUMPTABLESIDE            what side to place headers when dumping tables
! FILTERFILLSFROMRMS       exclude fill values when calculating rms, etc.
!                           (not implemented yet)
! INTPLACES                How many places to print when dumping integer values
! MAXNUMNANS               How many NaNs can we show where they are
! NAMEONEACHLINE           item name to print on each output line
! PCTFORMAT                use this format to print % with '-s' diff option
! RMSFORMAT                use this format to print min, max, rms, etc.
! SDFORMATDEFAULT          use this format to print s.p., d.p. by default
! STATSONONELINE           stats, rms each printed on a single line

d56 1
a56 1
! DUMP                     dump an array to output
d66 2
a67 63
! dump ( strlist string, char* name, [char* fillvalue], [char* options] )
! dump ( log countEmpty, strlist keys, strlist values, char* name, 
!       [char* separator], [char* options] )
! restoreDumpConfig

! Note that most of the optional parameters have default values
! logically set to FALSE or 0, ' ',  or '*' where appropriate

!  optional args
!  (dumps and diffs if the same)
!      arg            meaning                                     default
!      ---            -------                                     -------
!    fillvalue        skip dumping lines containg only fillValues    0
!    width            how many values printed per line            depends
!    format           fortran format used to print                depends
!    lbound           lower bound of 1st index                       1
!    options          (see below)                                    ''

!  (diffs)
!      arg            meaning                                     default
!      ---            -------                                     -------
!    fillvalue        don't diff where array elements are this    -999.99

! The format optional arg defaults to SDFORMATDEFAULT for floating pt. arrys
! For integer arrays it defaults to i6 or i_INTPLACES_
! For complex arrays it defaults to SDFORMATDEFAULTCMPLX
! If set to '(*)', for floating point and complex arrays it
! will be the least number of spaces wide enough to contain the
! largest array element printed according to the default format
! If set to '(*.m)', for floating point and complex arrays it
! will be the least number of spaces wide enough to contain the
! largest array element with m spaces after the decimal point

! The meaning of options has replaced the older logical arguments
! if the options is present and contains the following characters:
! (for dump or diff)
!   character         meaning
!      ---            -------
!       B              show Bandwidth, % of array that is non-zero
!       H              show rank, TheShape of array
!       L              laconic; skip printing name, size of array
!       N              Show where NaNs and Infs are located
!       R              rms       -- min, max, etc.
!       b              table of % vs. amount of differences (pdf)
!       c              clean
!       g              gaps      
!       l              collapse (last index)
!       r              ratios    -- min, max, etc. of differences' ratios
!       s              stats     -- number of differences
!       p              transpose 
!       t              trim      
!       u              unique    
!       v              verbose
!       w              wholearray
!       W[i]           wholearray, looping over ith index (for rank 3 and 4 arrays only)
!       1 or 2 or ..   ignored; calling routine is free to interpret

! An exception is the behavior of wholearray:
! if all {HRblrs} are FALSE, i.e. unset, the whole array is dumped (or diffed)
! if any is TRUE the whole array will be dumped only if
! w or wholearray is set to TRUE

! in the above, a string list is a string of elements (usu. comma-separated)
d71 1
a71 2
    & Dump, Dump_2x2xN, Empty, FinishLine, &
    & ILog10, Name_And_Size, &
d118 1
a118 1
       "$RCSfile: Dump_0.f90,v $"
d143 1
a143 1
  subroutine Dump_1D_Bit ( ARRay, Name, BITNAMES, FillValue, OptIONS )
d145 2
a146 2
    character(len=*), intent(in) :: NAME
    character(len=*), intent(in) :: BITNAMES
d198 1
a198 1
  subroutine Dump_1D_Char ( ARRay, Name, FillValue, WIDTH, OPTIONS, MAXLON, &
d201 1
a201 1
    character(len=*), intent(in), optional :: NAME
d203 3
a205 3
    integer, intent(in), optional :: WIDTH
    character(len=*), optional, intent(in) :: OPTIONS
    integer, intent(in), optional :: MAXLON
d211 1
a211 1
    character(len=len(array)) :: myFillValue
d217 1
a217 1
    MyWidth = DEFAULTWIDTH ! 10
d225 1
a225 1
      lon = min(lon, DEFAULTMAXLON)
d264 2
a265 2
  subroutine Dump_1D_Complex ( ARRay, Name, WIDTH, FORMAT, &
    & FillValue, LBOUND, OPTIONS, TheShape )
d268 3
a270 3
    character(len=*), intent(in), optional :: NAME
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
d272 2
a273 2
    integer, intent(in), optional :: LBOUND ! Low bound for Array             
    character(len=*), optional, intent(in) :: OPTIONS
d279 1
a279 1
    integer :: BASE
d297 2
a298 2
  subroutine Dump_1D_DComplex ( ARRay, Name, WIDTH, FORMAT, &
    & FillValue, LBOUND, OPTIONS, TheShape )
d301 3
a303 3
    character(len=*), intent(in), optional :: NAME
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
d305 2
a306 2
    integer, intent(in), optional :: LBOUND ! Low bound for Array             
    character(len=*), optional, intent(in) :: OPTIONS
d312 1
a312 1
    integer :: BASE
d330 2
a331 2
  subroutine Dump_1D_Double ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d333 1
a333 1
    character(len=*), intent(in), optional :: NAME
d335 4
a338 4
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), optional, intent(in) :: OPTIONS
d341 3
a343 3
    integer, dimension(MAXNUMELEMENTS) :: counts
    double precision, dimension(MAXNUMELEMENTS) :: elements
    double precision :: myFillValue
d357 2
a358 2
  subroutine Dump_1D_Integer ( ARRay, Name, &
    & FillValue, FORMAT, WIDTH, LBOUND, OPTIONS, TheShape )
d360 1
a360 1
    character(len=*), intent(in), optional :: NAME
d362 4
a365 4
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: WIDTH ! How many numbers per line (10)?
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), optional, intent(in) :: OPTIONS
d368 3
a370 3
    integer, dimension(MAXNUMELEMENTS) :: counts
    integer, dimension(MAXNUMELEMENTS) :: elements
    integer :: myFillValue
d376 1
a376 1
    if ( present( FORMAT ) ) call outputNamedValue ( 'format', format )
d385 2
a386 2
  subroutine Dump_1D_Integer_2B ( ARRay, Name, &
    & FillValue, FORMAT, WIDTH, LBOUND, OPTIONS, TheShape )
d389 1
a389 1
    character(len=*), intent(in), optional :: NAME
d391 4
a394 4
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: WIDTH ! How many numbers per line (10)?
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), optional, intent(in) :: OPTIONS
d397 2
a398 2
    call dump( int(array), NAME, &
    & FillValue, FORMAT, WIDTH, LBOUND, OPTIONS, TheShape )
d402 1
a402 1
  subroutine Dump_1D_Logical ( ARRay, Name, LBOUND, OPTIONS, TheShape )
d404 3
a406 3
    character(len=*), intent(in), optional :: NAME
    integer, intent(in), optional :: LBOUND ! Low bound of Array
    character(len=*), optional, intent(in) :: OPTIONS
d409 1
a409 1
    integer :: Base, J, K, N, NTRUE, NFALSE
d478 2
a479 2
  subroutine Dump_1D_Real ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d481 1
a481 1
    character(len=*), intent(in), optional :: NAME
d483 4
a486 4
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), optional, intent(in) :: OPTIONS
d489 3
a491 3
    integer, dimension(MAXNUMELEMENTS) :: counts
    real, dimension(MAXNUMELEMENTS) :: elements
    real :: myFillValue
d505 2
a506 2
  recursive subroutine Dump_2D_Char ( ARRay, Name, FillValue, WIDTH, MAXLON, &
    & OPTIONS, TheShape )
d508 1
a508 1
    character(len=*), intent(in), optional :: NAME
d510 1
a510 1
    integer, intent(in), optional :: MAXLON
d512 1
a512 1
    integer, intent(in), optional :: WIDTH
d516 1
a516 1
    integer :: LON
d518 1
a518 1
    character(len=len(array)) :: myFillValue
d581 2
a582 2
  recursive subroutine Dump_2D_Complex ( ARRay, Name, WIDTH, FORMAT, &
    & FillValue, OptIONS, LBOUND, TheShape )
d585 3
a587 3
    character(len=*), intent(in), optional :: NAME
    integer, intent(in), optional :: WIDTH ! How many per line?
    character(len=*), optional :: FORMAT
d594 1
a594 1
    integer :: myWidth
d596 1
a596 1
    complex(rk) :: myFillValue
d626 2
a627 2
  recursive subroutine Dump_2D_DComplex ( ARRay, Name, WIDTH, FORMAT, &
    & FillValue, OptIONS, LBOUND, TheShape )
d630 3
a632 3
    character(len=*), intent(in), optional :: NAME
    integer, intent(in), optional :: WIDTH ! How many per line?
    character(len=*), optional :: FORMAT
d672 2
a673 2
 recursive subroutine Dump_2D_Double ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d675 1
a675 1
    character(len=*), intent(in), optional :: NAME
d677 4
a680 4
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! to print for first dimension
    character(len=*), intent(in), optional :: options
d685 1
a685 1
    double precision :: myFillValue
d689 2
a690 2
    integer, dimension(MAXNUMELEMENTS) :: counts
    double precision, dimension(MAXNUMELEMENTS) :: elements
a697 1

d703 2
a704 2
  recursive subroutine Dump_2D_Integer ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d706 1
a706 1
    character(len=*), intent(in), optional :: NAME
d708 4
a711 4
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: WIDTH ! How many numbers per line (10)?
    integer, intent(in), optional :: LBOUND ! to print for first dimension
    character(len=*), intent(in), optional :: options
d720 2
a721 2
    integer, dimension(MAXNUMELEMENTS) :: counts
    integer, dimension(MAXNUMELEMENTS) :: elements
d735 2
a736 2
  recursive subroutine Dump_2D_Integer_2B ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d739 1
a739 1
    character(len=*), intent(in), optional :: NAME
d741 4
a744 4
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: WIDTH ! How many numbers per line (10)?
    integer, intent(in), optional :: LBOUND ! to print for first dimension
    character(len=*), intent(in), optional :: options
d747 2
a748 2
    call dump( int(array), NAME, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d752 1
a752 1
  recursive subroutine Dump_2D_Logical ( ARRay, Name, OPTIONS, THESHAPE )
d754 2
a755 2
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: options
d809 2
a810 2
  recursive subroutine Dump_2D_Real ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, THESHAPE )
d812 1
a812 1
    character(len=*), intent(in), optional :: NAME
d814 4
a817 4
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options
d822 1
a822 1
    real :: myFillValue
d826 2
a827 2
    integer, dimension(MAXNUMELEMENTS) :: counts
    real, dimension(MAXNUMELEMENTS) :: elements
d841 1
a841 1
  subroutine Dump_2x2xN_Complex ( ARRay, Name, FORMAT, OPTIONS )
d845 3
a847 3
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: FORMAT
    character(len=*), intent(in), optional :: options
d881 1
a881 1
  subroutine Dump_2x2xN_DComplex ( ARRay, Name, FORMAT, OPTIONS )
d885 3
a887 3
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: FORMAT
    character(len=*), intent(in), optional :: options
d921 2
a922 2
  subroutine Dump_3D_Char ( ARRay, Name, FillValue, WIDTH, &
    & MAXLON, OPTIONS, THESHAPE )
d924 1
a924 1
    character(len=*), intent(in), optional :: NAME
d926 3
a928 3
    integer, intent(in), optional :: WIDTH
    integer, intent(in), optional :: MAXLON
    character(len=*), intent(in), optional :: options
d934 1
a934 1
    character(len=len(array)) :: myFillValue
d997 2
a998 2
  subroutine Dump_3D_Complex ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, THESHAPE )
d1001 1
a1001 1
    character(len=*), intent(in), optional :: NAME
d1003 3
a1005 3
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
d1007 1
a1007 1
    character(len=*), intent(in), optional :: THESHAPE
d1032 2
a1033 2
  subroutine Dump_3D_DComplex ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, THESHAPE )
d1036 1
a1036 1
    character(len=*), intent(in), optional :: NAME
d1038 3
a1040 3
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
d1067 2
a1068 2
  subroutine Dump_3D_Double ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, THESHAPE )
d1070 1
a1070 1
    character(len=*), intent(in), optional :: NAME
d1072 3
a1074 3
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
d1084 2
a1085 2
    integer, dimension(MAXNUMELEMENTS) :: counts
    double precision, dimension(MAXNUMELEMENTS) :: elements
d1094 2
a1095 2
  subroutine Dump_3D_Integer ( ARRay, Name, &
    & FillValue, FORMAT, WIDTH, LBOUND, OPTIONS, THESHAPE )
d1097 1
a1097 1
    character(len=*), intent(in), optional :: NAME
d1099 3
a1101 3
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: WIDTH ! How many numbers per line (10)?
    integer, intent(in), optional :: LBOUND ! Low bound for Array
d1114 2
a1115 2
    integer, dimension(MAXNUMELEMENTS) :: counts
    integer, dimension(MAXNUMELEMENTS) :: elements
d1124 2
a1125 2
  subroutine Dump_3D_Real ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS, THESHAPE )
d1127 1
a1127 1
    character(len=*), intent(in), optional :: NAME
d1129 3
a1131 3
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
d1141 2
a1142 2
    integer, dimension(MAXNUMELEMENTS) :: counts
    real, dimension(MAXNUMELEMENTS) :: elements
d1151 2
a1152 2
  subroutine Dump_4D_Double ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS )
d1154 1
a1154 1
    character(len=*), intent(in), optional :: NAME
d1156 4
a1159 4
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options
d1162 1
a1162 1
    character(len=64) :: myFormat
d1164 2
a1165 2
    integer, dimension(MAXNUMELEMENTS) :: counts
    double precision, dimension(MAXNUMELEMENTS) :: elements
d1172 2
a1173 2
  subroutine Dump_4D_Real ( ARRay, Name, &
    & FillValue, WIDTH, FORMAT, LBOUND, OPTIONS )
d1175 1
a1175 1
    character(len=*), intent(in), optional :: NAME
d1177 4
a1180 4
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options
d1183 1
a1183 1
    character(len=64) :: myFormat
d1185 2
a1186 2
    integer, dimension(MAXNUMELEMENTS) :: counts
    real, dimension(MAXNUMELEMENTS) :: elements
d1223 1
a1223 1
  subroutine Name_And_Size ( NAME, CLEAN, SIZE, THESHAPE )
d1259 2
a1260 2
  subroutine Dump_Bogus ( ARRay, Name, &
    & FillValue, FORMAT, WIDTH, LBOUND, OPTIONS )
d1262 1
a1262 1
    character(len=*), intent(in), optional :: NAME
d1264 3
a1266 3
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: WIDTH ! How many numbers per line (10)?
    integer, intent(in), optional :: LBOUND ! Low bound for Array
d1279 1
a1279 1
    character(len=*), intent(in) :: NAME
d1287 1
a1287 1
    character(len=*), intent(in) :: NAME
d1295 1
a1295 1
    character(len=*), intent(in) :: NAME
d1303 1
a1303 1
    character(len=*), intent(in) :: NAME
d1324 1
a1324 1
    character(len=*), intent(in) :: NAME
d1345 1
a1345 1
    character(len=*), intent(in) :: NAME
d1366 1
a1366 1
    character(len=*), intent(in) :: NAME
d1387 1
a1387 1
    character(len=*), intent(in) :: NAME
d1408 1
a1408 1
    character(len=*), intent(in) :: NAME
d1450 1
a1450 1
    character(len=*), intent(in), optional :: FORMAT
d1456 1
a1456 1
    character(len=*), intent(in), optional :: FORMAT
d1462 1
a1462 1
    character(len=*), intent(in), optional :: FORMAT
d1468 1
a1468 1
    character(len=*), intent(in), optional :: FORMAT
d1475 1
a1475 1
    character(len=*), intent(in), optional :: FORMAT
d1482 1
a1482 1
    character(len=*), intent(in), optional :: FORMAT
d1687 1
a1687 1
       "$Id: Dump_0.f90,v 2.137 2016/04/05 23:54:57 pwagner Exp $"
d1696 4
a1699 1
! $Log: Dump_0.f90,v $
d1710 1
a1710 1
! May override DEFAULTWIDTH when dumping char array
d1713 1
a1713 1
! Include LBOUND in 'all values are the same' dumps
d1803 1
a1803 1
! DEFAULTMAXLON can now set max width of 1d char array dumps
d1909 1
a1909 1
! Remove OPTIONAL attribute from NAME1 and NAME args of DIFF_...
d1993 1
a1993 1
! Add LBOUND to Dump_1d_[double,integer,real]
d1996 1
a1996 1
! Add LBOUND argument to Dump_1d_Logical
d2036 1
a2036 1
! Added optional FORMAT arguments in several more routines.
d2054 1
a2054 1
! Add WIDTH and FORMAT arguments to 1D_Real and 1D_Double
@


2.137
log
@-v verbose option added; usu. will print name on each line
@
text
@d12 1
a12 1
module DUMP_0
d25 1
a25 1
! and separate dump_1.f90 module
d27 20
a46 24
  use bitStuff, only: maxBitNumber, whichBitsAreSet
  use dates_module, only: maxUTCStrLength, &
    & reformatDate, reformatTime, splitDateTime, tai93s2utc
  use highOutput, only: alignToFit, blanksToTab, &
    & numNeedsFormat, numToChars, &
    & outputList, outputNamedValue, resetTabs, setTabs
  use ieee_arithmetic, only: ieee_is_finite
  use mlsfillvalues, only : bandWidth, collapse, filterValues, halfWaves, &
    & isFinite, isInfinite, isNaN, &
    & infFunction, NaNFunction, reorderFillValues, replaceFillValues, &
    & whereAreTheInfs, whereAreTheNaNs
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
  use MLSFinds, only: findUnique
  use MLSStats1, only: Stat_t, &
    & AllStats, fillValueRelation, howFar, howNear, &
    & MLSMax, MLSMean, MLSMin, MLSStddev, ratios, reset
  use MLSStringLists, only: catLists, getStringElement, numStringElements, &
    & OptionDetail
  use MLSStrings, only: delete, indexes, lowercase, &
    & readIntsFromChars, trim_safe, &
    & writeIntsToChars
  use output_m, only: outputOptions, stampOptions, &
    & blanks, newline, output
  use time_m, only: time_now
d48 1
a48 1
  implicit none
d50 1
d57 1
a57 1
! COLLAPSEOPTIONS          options determining what and how to dump collapsed
a74 2
! DIFF_FUN                 returns differences between scalars, arrays, etc.
! DIFF                     dump diffs between pair of arrays of numeric type
a75 10
! DUMPDATES                dump 1-d array of tai93 (s. after 1 jan 1993)
! DUMPDUMPOPTIONS          dump module settings for dump, diff, etc.
! DUMPLISTS                dump 2-d array as a set of lists
! DUMPNAMEDVALUES          dump an array of paired names and values
! DUMPSUMS                 dump after summing successive array values
!                            ("inverse" of selfDiff)
! DUMPTABLE                dump a 2-d table of values with headers
! DUMPTEXTFILE             dump contents of a text file
! RESTOREDUMPCONFIG        restore default values to dump configuration
! SELFDIFF                 dump increments between successive array values
d79 1
a79 8
! num diff_fun ( num value1, num value2, num auxvalue, char* options )
! diff ( array1, char* name1, array2, char* name2,
!      [fillvalue], [int width], [char* format],
!      [int lbound], [char* options] ) 
!       where array1, array2 can be 1, 2, or 3d arrays of 
!       ints, reals, or doubles, compatible in size and type
!       and fillValue is a scalar of the same type, if present
! dump ( array, char* name,
a87 21
! dumpDates ( dble dates(:), [int width], [char* dateFormat], [char* timeFormat] )
! dumpDumpOptions ( [char* options] )
! dumpLists ( array, char* name,
!      [int width], [char* sep],
!      [char* delims] ) 
!       where array can be a 2d array of
!       chars or ints
! dumpNamedValues ( values, strlist names,
!      [char* format, [int width], [char* options] ) 
!       where values can be a 1d array of ints or reals, and
!       names is a string list of corresponding names
! dumpSums ( array, char* name,
!      [fillvalue], [int width], [char* format],
!      [int lbound], [char* options] )
! dumpTable ( values, headers, char* headside
!      [char* format, [char* formats(:)] ) 
!       where values can be a 2d array of ints or reals, and
!       headers is an array the same size as the 2nd index of values
!       format optionally overrides the default format for the numeric type
!       formats allows you to specify a format separately column-by-column
! dumpTextfile ( char* fileName, [char* options] )
a88 3
! selfdiff ( array, char* name,
!      [fillvalue], [int width], [char* format],
!      [log waves], [int lbound], [char* options] )
a146 10
! (for diff_fun)
!   character      meaning
!    ---           -------
!     a            diff the absolute values
!     r            divide the difference by the max abs of the 2 values
!     f            treat auxvalue as a fillvalue: return fillvalue if either
!                    value is fillvalue
!     p            treat auxvalue as a period: return 
!                       min(value1 - value2 + n*period)

d150 17
a166 81
  public :: DIFF, DIFF_FUN, &
    & DUMP, DUMP_2x2xN, DUMPDATES, DUMPDUMPOPTIONS, DUMPLISTS, DUMPNAMEDVALUES, &
    & DUMPSUMS, DUMPTABLE, DUMPTEXTFILE, RESTOREDUMPCONFIG, SELFDIFF

  interface DIFF        ! dump diffs between pair of n-d arrays of numeric type
    module procedure DIFF_1D_DOUBLE, DIFF_1D_INTEGER, DIFF_1D_REAL
    module procedure DIFF_2D_DOUBLE, DIFF_2D_INTEGER, DIFF_2D_REAL
    module procedure DIFF_3D_DOUBLE, DIFF_3D_REAL
    module procedure DIFF_4D_DOUBLE, DIFF_4D_REAL
  end interface

  interface DIFF_FUN    ! return diffs between args or arrays of numeric type
    module procedure DIFF_SCALAR_DOUBLE, DIFF_SCALAR_REAL
  end interface

  interface FILTEREDDIFF        ! dump FILTEREDDIFFs between pair of n-d arrays of numeric type
    module procedure FILTEREDDIFF_1D_DOUBLE, FILTEREDDIFF_1D_INTEGER, FILTEREDDIFF_1D_REAL
    module procedure FILTEREDDIFF_2D_DOUBLE, FILTEREDDIFF_2D_INTEGER, FILTEREDDIFF_2D_REAL
    module procedure FILTEREDDIFF_3D_DOUBLE, FILTEREDDIFF_3D_REAL
    module procedure FILTEREDDIFF_4D_DOUBLE, FILTEREDDIFF_4D_REAL
  end interface

  interface DUMP        ! dump n-d arrays of homogeneous type
    module procedure DUMP_1D_BIT, DUMP_1D_CHAR, DUMP_1D_COMPLEX, DUMP_1D_DCOMPLEX
    module procedure DUMP_1D_DOUBLE, DUMP_1D_INTEGER, DUMP_1D_INTEGER_2B
    module procedure DUMP_1D_LOGICAL, DUMP_1D_REAL
    module procedure DUMP_2D_CHAR, DUMP_2D_COMPLEX, DUMP_2D_DCOMPLEX
    module procedure DUMP_2D_DOUBLE, DUMP_2D_INTEGER, DUMP_2D_INTEGER_2B
    module procedure DUMP_2D_LOGICAL, DUMP_2D_REAL
    module procedure DUMP_3D_CHAR, DUMP_3D_DOUBLE, DUMP_3D_INTEGER
    module procedure DUMP_3D_REAL, DUMP_3D_COMPLEX, DUMP_3D_DCOMPLEX
    module procedure DUMP_HASH_LOG, DUMP_HASH_STR, DUMP_STRLIST
    module procedure DUMP_4D_DOUBLE, DUMP_4D_REAL
  end interface

  interface DUMP_2x2xN ! For polarized incremental optical depth
    module procedure DUMP_2x2xN_COMPLEX, DUMP_2x2xN_DCOMPLEX
  end interface

  interface DUMPCOLLAPSEDARRAY
    module procedure DUMPCOLLAPSEDARRAY_1D_DOUBLE, DUMPCOLLAPSEDARRAY_1D_REAL
    module procedure DUMPCOLLAPSEDARRAY_2D_DOUBLE, DUMPCOLLAPSEDARRAY_2D_REAL
    module procedure DUMPCOLLAPSEDARRAY_3D_DOUBLE, DUMPCOLLAPSEDARRAY_3D_REAL
    module procedure DUMPCOLLAPSEDARRAY_1D_INTEGER
    module procedure DUMPCOLLAPSEDARRAY_2D_INTEGER
    module procedure DUMPCOLLAPSEDARRAY_3D_INTEGER
  end interface

  interface dumpDates
    module procedure dump_tai
  end interface

  interface DUMPLISTS
    module procedure DUMPLISTS_CHARS, DUMPLISTS_INTS
  end interface

  interface DUMPNAMEDVALUES   ! dump name-value pairs, names in string list
    module procedure DUMPNAMEDVALUES_DOUBLE, DUMPNAMEDVALUES_INTEGER
    module procedure DUMPNAMEDVALUES_REAL
  end interface

  interface DUMPTABLE   ! dump table of values, headers
    module procedure DUMPTABLE_DOUBLE, DUMPTABLE_INTEGER
    module procedure DUMPTABLE_REAL
  end interface

  interface SELFDIFF       ! dump increments between successive array values
    module procedure SELFDIFF_INTEGER
    module procedure SELFDIFF_REAL
    module procedure SELFDIFF_DOUBLE
  end interface

  interface DUMPSUMS       ! dump after summing successive array values
    module procedure DUMPSUMS_INTEGER
    module procedure DUMPSUMS_REAL
    module procedure DUMPSUMS_DOUBLE
  end interface

  interface PRINTIT
    module procedure PRINTIT_CHAR, PRINTIT_DOUBLE, PRINTIT_INT, PRINTIT_REAL
    module procedure PRINTIT_COMPLEX, PRINTIT_DCOMPLEX
d169 2
a170 2
  interface PRINTRMSETC
    module procedure PRINTRMSETC_DOUBLE, PRINTRMSETC_INT, PRINTRMSETC_REAL
d173 8
a180 3
  interface SAY_FILL
    module procedure SAY_FILL_CHAR, SAY_FILL_DOUBLE, SAY_FILL_INT
    module procedure SAY_FILL_REAL, SAY_FILL_COMPLEX, SAY_FILL_DCOMPLEX
d183 13
a195 6
  interface UNFILTEREDDIFF        ! dump UNFILTEREDDIFFs between pair of n-d arrays of numeric type
    module procedure UNFILTEREDDIFF_1D_DOUBLE, UNFILTEREDDIFF_1D_INTEGER, UNFILTEREDDIFF_1D_REAL
    module procedure UNFILTEREDDIFF_2D_DOUBLE, UNFILTEREDDIFF_2D_INTEGER, UNFILTEREDDIFF_2D_REAL
    module procedure UNFILTEREDDIFF_3D_DOUBLE, UNFILTEREDDIFF_3D_REAL
    module procedure UNFILTEREDDIFF_4D_DOUBLE, UNFILTEREDDIFF_4D_REAL
  end interface
d199 1
a199 1
       "$RCSfile: dump_0.f90,v $"
d205 1
a205 47
  character, public, parameter :: AFTERSUB = '#'
  character(len=*), parameter :: DEFAULTPCTFORMAT = '(0pf6.1)'
  ! These are the possible options to dumps, diffs
  character, public, parameter :: dopt_bandwidth   = 'B'
  character, public, parameter :: dopt_clean       = 'c'
  character, public, parameter :: dopt_collapse    = 'l'
  character, public, parameter :: dopt_cyclic      = 'y'
  character, public, parameter :: dopt_gaps        = 'g'
  character, public, parameter :: dopt_laconic     = 'L'
  character, public, parameter :: dopt_NaNs        = 'N'
  character, public, parameter :: dopt_ratios      = 'r'
  character, public, parameter :: dopt_rms         = 'R'
  character, public, parameter :: dopt_verbose     = 'v'
  character, public, parameter :: dopt_shape       = 'H'
  character, public, parameter :: dopt_stats       = 's'
  character, public, parameter :: dopt_table       = 'b'
  character, public, parameter :: dopt_transpose   = 'p'
  character, public, parameter :: dopt_trim        = 't'
  character, public, parameter :: dopt_unique      = 'u'
  character, public, parameter :: dopt_wholearray  = 'w'
  ! The following character strings can include one or more options listed above
  !
  ! E.g., '-crt' turns on CLEAN, RMS, and TRIM
  character(len=8), public, save :: DEFAULTDIFFOPTIONS = ' '
  character(len=8), public, save :: DEFAULTDUMPOPTIONS = ' '
  integer, public, save          :: DEFAULTMAXLON      = 128
  integer, public, save          :: DEFAULTWIDTH       = 10
  character(len=8), public, save :: DUMPTABLESIDE      = 'top'
  logical, public, save ::   DIFFRMSMEANSRMS           = .false.
  logical, public, save ::   DONTDUMPIFALLEQUAL        = .true.
  logical, public, save ::   FILTERFILLSFROMRMS        = .false.
  logical, public, save ::   PRINTFILLVALUE            = .true.
  logical, public, save ::   PRINTNAMEIFDIFF           = .true.
  logical, public, save ::   STATSONONELINE            = .true.
  character(len=16), public, save ::   NAMEONEACHLINE  = ' '

  ! This determines how a higher-rank array is collapsed to a lower-rank one
  character(len=16), public, save :: COLLAPSEOPTIONS = 'num[+]all[+]'

  ! These determine how dumped numerical data (s.p. or d.p.) will be formatted
  character(len=2), public, save  :: INTPLACES = '6' ! how many places
  integer,          public, save  :: MAXNUMNANS= 60  ! how many NaNs to show
  character(len=16), public, save :: PCTFORMAT = '*' ! * means default format
  character(len=16), public, save :: RMSFORMAT = '*' ! * means default format
  character(len=16), public, save :: SDFORMATDEFAULT = '(1pg14.6)'
  character(*), parameter :: sdFormatDefaultCmplx = &
    & '(1x,"(",1pg13.6,",",1pg13.6,")")'
d209 1
a209 5
  integer, parameter :: MAXLINELEN              = 120
  integer, parameter :: MAXTEXTFILELINELEN      = 255
  integer, parameter :: MAXTEXTFILELINES        = 600
  integer, parameter :: MAXNUMELEMENTS          = 2000
  integer, parameter :: TOOMANYELEMENTS         = 125*50*3500 ! Don't try to diff l1b DACS
d211 7
a217 14
  logical, parameter :: SHORTCUTDIFFS           = .false.
  logical :: DUMPTHESEZEROS
  logical :: myBandwidth, myClean, myCollapse, myCyclic, myDirect, myGaps, &
    & myLaconic, myNaNs, myRatios, myRMS, myShape, myStats, &
    & myTable, myTranspose, myTrim, myUnique, myVerbose, myWholeArray, &
    & onlyWholeArray
  character(len=16) :: myOptions
  character(len=16) :: myPCTFormat
  character(len=16) :: nameToPrint
  logical, save     :: nameHasBeenPrinted = .false.
  integer           :: bwidth, myRank, numNonFill, numFill, indx2BSliced, iSlice
  real              :: pctnzero
  logical, save     :: thisIsADiff = .false.
  integer           :: how_many
d223 3
a225 355
 ! ---------------------------------------------  DIFF  -----
 ! This family of routines dumps the differences between two arrays
 ! with the same shape and numeric type
 ! Its behavior is modified by the following optional parameters
 ! FillValue   Ignore these values when computing min, max
 ! Width       Row size when dumping wholearrays
 ! Format      Output format when printing wholearray
 ! LBound      Lower bound when printing wholearray indices
 !
 ! The following optional params are now set by options
 ! Wholearray  Whether to print whole array of differences
 ! Stats       Dump number of differences found, %
 ! RMS         Dump min, max, rms
 ! Clean       Clean up after any prior dumps
  subroutine DIFF_1D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    double precision, intent(in) :: ARRAY1(:)
    character(len=*), intent(in) :: NAME1
    double precision, intent(in) :: ARRAY2(:)
    character(len=*), intent(in) :: NAME2
    double precision, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    if ( .not. present(FillValue) ) then
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    elseif ( product(shape(array1)) > TOOMANYELEMENTS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'array size of ' // trim(name1) // ' too large to filter Fill values' )
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    else
      call FilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    endif
  end subroutine DIFF_1D_DOUBLE

  subroutine DIFF_1D_INTEGER ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, intent(in) :: ARRAY1(:)
    character(len=*), intent(in) :: NAME1
    integer, intent(in) :: ARRAY2(:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    if ( .not. present(FillValue) ) then
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    elseif ( product(shape(array1)) > TOOMANYELEMENTS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'array size of ' // trim(name1) // ' too large to filter Fill values' )
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    else
      call FilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    endif
  end subroutine DIFF_1D_INTEGER

  subroutine DIFF_1D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    real, intent(in) :: ARRAY1(:)
    character(len=*), intent(in) :: NAME1
    real, intent(in) :: ARRAY2(:)
    character(len=*), intent(in) :: NAME2
    real, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    if ( .not. present(FillValue) ) then
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    elseif ( product(shape(array1)) > TOOMANYELEMENTS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'array size of ' // trim(name1) // ' too large to filter Fill values' )
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    else
      call FilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    endif
  end subroutine DIFF_1D_REAL

  subroutine DIFF_2D_INTEGER ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, intent(in) :: ARRAY1(:,:)
    character(len=*), intent(in) :: NAME1
    integer, intent(in) :: ARRAY2(:,:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    if ( .not. present(FillValue) ) then
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    elseif ( product(shape(array1)) > TOOMANYELEMENTS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'array size of ' // trim(name1) // ' too large to filter Fill values' )
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    else
      call FilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    endif
  end subroutine DIFF_2D_INTEGER

  subroutine DIFF_2D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    double precision, intent(in) :: ARRAY1(:,:)
    character(len=*), intent(in) :: NAME1
    double precision, intent(in) :: ARRAY2(:,:)
    character(len=*), intent(in) :: NAME2
    double precision, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    if ( .not. present(FillValue) ) then
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    elseif ( product(shape(array1)) > TOOMANYELEMENTS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'array size of ' // trim(name1) // ' too large to filter Fill values' )
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    else
      call FilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    endif
  end subroutine DIFF_2D_DOUBLE

  subroutine DIFF_2D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    real, intent(in) :: ARRAY1(:,:)
    character(len=*), intent(in) :: NAME1
    real, intent(in) :: ARRAY2(:,:)
    character(len=*), intent(in) :: NAME2
    real, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    if ( .not. present(FillValue) ) then
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    elseif ( product(shape(array1)) > TOOMANYELEMENTS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'array size of ' // trim(name1) // ' too large to filter Fill values' )
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    else
      call FilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    endif
  end subroutine DIFF_2D_REAL

  subroutine DIFF_3D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    double precision, intent(in) :: ARRAY1(:,:,:)
    character(len=*), intent(in) :: NAME1
    double precision, intent(in) :: ARRAY2(:,:,:)
    character(len=*), intent(in) :: NAME2
    double precision, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    if ( .not. present(FillValue) ) then
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    elseif ( product(shape(array1)) > TOOMANYELEMENTS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'array size of ' // trim(name1) // ' too large to filter Fill values' )
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    else
      call FilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    endif
  end subroutine DIFF_3D_DOUBLE

  subroutine DIFF_3D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    real, intent(in) :: ARRAY1(:,:,:)
    character(len=*), intent(in) :: NAME1
    real, intent(in) :: ARRAY2(:,:,:)
    character(len=*), intent(in) :: NAME2
    real, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    if ( .not. present(FillValue) ) then
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    elseif ( product(shape(array1)) > TOOMANYELEMENTS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'array size of ' // trim(name1) // ' too large to filter Fill values' )
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    else
      call FilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    endif
  end subroutine DIFF_3D_REAL

  subroutine DIFF_4D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    double precision, intent(in) :: ARRAY1(:,:,:,:)
    character(len=*), intent(in) :: NAME1
    double precision, intent(in) :: ARRAY2(:,:,:,:)
    character(len=*), intent(in) :: NAME2
    double precision, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    call theDumpBegins ( options )
    if ( any(shape(array1) == 0) ) then
      call output( 'array sizes are 0', advance='yes' )
    else if ( size(array1,1) == 1 ) then
      if ( myWholeArray ) call output( '1st size is 1: reducing rank to 3', advance='yes' )
      call diff ( array1(1,:,:,:), name1, array2(1,:,:,:), name2, &
        & fillvalue, width, format, lbound, options )
    else if ( size(array1,2) == 1 ) then
      if ( myWholeArray ) call output( '2nd size is 1: reducing rank to 3', advance='yes' )
      call diff ( array1(:,1,:,:), name1, array2(:,1,:,:), name2, &
        & fillvalue, width, format, lbound, options )
    else if ( size(array1,3) == 1 ) then
      if ( myWholeArray ) call output( '3rd size is 1: reducing rank to 3', advance='yes' )
      call diff ( array1(:,:,1,:), name1, array2(:,:,1,:), name2, &
        & fillvalue, width, format, lbound, options )
    else if ( size(array1,4) == 1 ) then
      if ( myWholeArray ) call output( '4th size is 1: reducing rank to 3', advance='yes' )
      call diff ( array1(:,:,:,1), name1, array2(:,:,:,1), name2, &
        & fillvalue, width, format, lbound, options )
    elseif ( .not. present(FillValue) ) then
      if ( myWholeArray ) call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    elseif ( product(shape(array1)) > TOOMANYELEMENTS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'array size of ' // trim(name1) // ' too large to filter Fill values' )
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    else
      call FilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    endif
  end subroutine DIFF_4D_DOUBLE

  subroutine DIFF_4D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    real, intent(in) :: ARRAY1(:,:,:,:)
    character(len=*), intent(in) :: NAME1
    real, intent(in) :: ARRAY2(:,:,:,:)
    character(len=*), intent(in) :: NAME2
    real, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    call theDumpBegins ( options )
    if ( any(shape(array1) == 0) ) then
      call output( 'array sizes are 0', advance='yes' )
    else if ( size(array1,1) == 1 ) then
      if ( myWholeArray ) call output( '1st size is 1: reducing rank to 3', advance='yes' )
      call diff ( array1(1,:,:,:), name1, array2(1,:,:,:), name2, &
        & fillvalue, width, format, lbound, options )
    else if ( size(array1,2) == 1 ) then
      if ( myWholeArray ) call output( '2nd size is 1: reducing rank to 3', advance='yes' )
      call diff ( array1(:,1,:,:), name1, array2(:,1,:,:), name2, &
        & fillvalue, width, format, lbound, options )
    else if ( size(array1,3) == 1 ) then
      if ( myWholeArray ) call output( '3rd size is 1: reducing rank to 3', advance='yes' )
      call diff ( array1(:,:,1,:), name1, array2(:,:,1,:), name2, &
        & fillvalue, width, format, lbound, options )
    else if ( size(array1,4) == 1 ) then
      if ( myWholeArray ) call output( '4th size is 1: reducing rank to 3', advance='yes' )
      call diff ( array1(:,:,:,1), name1, array2(:,:,:,1), name2, &
        & fillvalue, width, format, lbound, options )
    elseif ( .not. present(FillValue) ) then
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    elseif ( product(shape(array1)) > TOOMANYELEMENTS ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'array size of ' // trim(name1) // ' too large to filter Fill values' )
      call UnfilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & WIDTH, FORMAT, LBOUND, OPTIONS )
    else
      call FilteredDiff( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    endif
  end subroutine DIFF_4D_REAL

  ! -----------------------------------------------  DIFF_SCALAR  -----
  ! This family of functions differences two values and returns
  ! according to options:
  ! if options contains
  ! character        meaning
  ! ---------        -------
  !     a            diff the absolute values
  !     r            divide the difference by the max abs of the 2 values
  !     f            treat auxvalue as a fillvalue: return fillvalue if either
  !                    value is fillvalue
  !     p            treat auxvalue as a period: return 
  !                    min(value1 - value2 + n*period)
  elemental function DIFF_SCALAR_DOUBLE ( VALUE1, VALUE2, AUXVALUE, OPTIONS ) &
    & result(d)
    ! Args
    double precision, intent(in)           :: value1
    double precision, intent(in)           :: value2
    double precision, optional, intent(in) :: auxvalue
    character(len=*), optional, intent(in) :: options
    double precision                       :: d
    ! Internal variables
    integer, parameter :: RK = kind(0.0d0)
    ! Executable
    include 'diff_scalar.f9h'
  end function DIFF_SCALAR_DOUBLE

  elemental function DIFF_SCALAR_REAL ( VALUE1, VALUE2, AUXVALUE, OPTIONS ) &
    & result(d)
    ! Args
    real, intent(in)                       :: value1
    real, intent(in)                       :: value2
    real, optional, intent(in)             :: auxvalue
    character(len=*), optional, intent(in) :: options
    real                                   :: d
    ! Internal variables
    integer, parameter :: RK = kind(0.0e0)
    ! Executable
    include 'diff_scalar.f9h'
  end function DIFF_SCALAR_REAL

  ! -----------------------------------------------  DUMP_1D_BIT  -----
  subroutine DUMP_1D_BIT ( ARRAY, NAME, BITNAMES, FILLVALUE, OPTIONS )
    integer, intent(in) :: ARRAY(:)
d228 1
a228 1
    integer, intent(in), optional :: FILLVALUE
d249 1
a249 1
      call name_and_size ( name, myClean, size(array) )
d260 1
a260 1
          enddo
d268 1
a268 1
          endif
d272 3
a274 3
        endif
      enddo
    endif
d276 1
a276 1
  end subroutine DUMP_1D_BIT
d278 4
a281 4
  ! -----------------------------------------------  DUMP_1D_CHAR  -----
  subroutine DUMP_1D_CHAR ( ARRAY, NAME, FILLVALUE, WIDTH, OPTIONS, MAXLON, &
    & TheSHAPE )
    character(len=*), intent(in) :: ARRAY(:)
d283 1
a283 1
    character(len=*), intent(in), optional :: FILLVALUE
d302 1
a302 1
    if ( myTrim ) lon = maxval(len_trim(array))
d305 1
a305 1
    else if ( .not. myTrim ) then
d313 1
a313 1
      call name_and_size ( name, myClean, 1, TheShape )
d317 2
a318 2
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
d320 1
a320 1
        DumpTheseZeros = myClean .or. &
d322 1
a322 1
        if (.not. myClean) then
d342 1
a342 1
  end subroutine DUMP_1D_CHAR
d344 3
a346 3
  ! --------------------------------------------  DUMP_1D_COMPLEX  -----
  subroutine DUMP_1D_COMPLEX ( ARRAY, NAME, WIDTH, FORMAT, &
    & FILLVALUE, LBOUND, OPTIONS, TheShape )
d348 1
a348 1
    complex(rk), intent(in) :: ARRAY(:)
d375 1
a375 1
  end subroutine DUMP_1D_COMPLEX
d377 3
a379 3
  ! --------------------------------------------  DUMP_1D_DCOMPLEX  -----
  subroutine DUMP_1D_DCOMPLEX ( ARRAY, NAME, WIDTH, FORMAT, &
    & FILLVALUE, LBOUND, OPTIONS, TheShape )
d381 1
a381 1
    complex(rk), intent(in) :: ARRAY(:)
d408 1
a408 1
  end subroutine DUMP_1D_DCOMPLEX
d410 4
a413 4
 ! ---------------------------------------------  DUMP_1D_DOUBLE  -----
  subroutine DUMP_1D_DOUBLE ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
    double precision, intent(in) :: ARRAY(:)
d415 1
a415 1
    double precision, intent(in), optional :: FILLVALUE
d435 1
a435 22
  end subroutine DUMP_1D_DOUBLE

  ! --------------------------------------------  DUMP_BOGUS  -----
  ! Never used--just here to tell Makefiles that dumpstats.f9h is
  ! a prerequisite for dump_0 because perl script f90makedep.pl
  ! won't follow .f9h files to look for more uses and includes.
  ! When will we repair the perl script?
  !
  subroutine DUMP_BOGUS ( ARRAY, NAME, &
    & FILLVALUE, FORMAT, WIDTH, LBOUND, OPTIONS )
    integer, intent(in) :: ARRAY(:)
    character(len=*), intent(in), optional :: NAME
    integer, intent(in), optional :: FILLVALUE
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: WIDTH ! How many numbers per line (10)?
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), optional, intent(in) :: options
    integer :: myFillValue
    myFillValue = 0
    myRank = 0
    include 'dumpstats.f9h'
  end subroutine DUMP_BOGUS
d437 4
a440 4
  ! --------------------------------------------  DUMP_1D_INTEGER  -----
  subroutine DUMP_1D_INTEGER ( ARRAY, NAME, &
    & FILLVALUE, FORMAT, WIDTH, LBOUND, OPTIONS, TheShape )
    integer, intent(in) :: ARRAY(:)
d442 1
a442 1
    integer, intent(in), optional :: FILLVALUE
d463 1
a463 1
  end subroutine DUMP_1D_INTEGER
d465 3
a467 3
  ! --------------------------------------------  DUMP_1D_INTEGER_2B  -----
  subroutine DUMP_1D_INTEGER_2B ( ARRAY, NAME, &
    & FILLVALUE, FORMAT, WIDTH, LBOUND, OPTIONS, TheShape )
d469 1
a469 1
    integer(C_int16_t), intent(in) :: ARRAY(:)
d471 1
a471 1
    integer, intent(in), optional :: FILLVALUE
a477 8
    integer, dimension(MAXNUMELEMENTS) :: counts
    integer, dimension(MAXNUMELEMENTS) :: elements
    integer :: myFillValue
    integer :: Base, J, K
    character(len=64) :: MyFormat
    integer :: MyWidth
    integer :: NumZeroRows
    integer :: nUnique
d479 2
a480 2
    & FILLVALUE, FORMAT, WIDTH, LBOUND, OPTIONS, TheShape )
  end subroutine DUMP_1D_INTEGER_2B
d482 3
a484 3
  ! ----------------------------------------------  DUMP_1D_LOGICAL ----
  subroutine DUMP_1D_LOGICAL ( ARRAY, NAME, LBOUND, OPTIONS, TheShape )
    logical, intent(in) :: ARRAY(:)
d491 1
a492 1

d500 1
a500 1
      call name_and_size ( name, myClean, 1 )
d504 1
a504 1
      call name_and_size ( name, myClean, size(array) )
d512 1
a512 1
      call name_and_size ( name, myClean, size(array) )
d519 3
a521 3
    elseif ( myGaps ) then
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
d536 1
a536 1
        endif
d539 1
a539 1
      enddo
d542 2
a543 2
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
d545 1
a545 1
        if (.not. myClean) then
d556 1
a556 1
  end subroutine DUMP_1D_LOGICAL
d558 4
a561 4
  ! -----------------------------------------------  DUMP_1D_REAL  -----
  subroutine DUMP_1D_REAL ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
    real, intent(in) :: ARRAY(:)
d563 1
a563 1
    real, intent(in), optional :: FILLVALUE
d583 1
a583 1
  end subroutine DUMP_1D_REAL
d585 2
a586 2
  ! -----------------------------------------------  DUMP_2D_CHAR  -----
  recursive subroutine DUMP_2D_CHAR ( ARRAY, NAME, FILLVALUE, WIDTH, MAXLON, &
d588 1
a588 1
    character(len=*), intent(in) :: ARRAY(:,:)
d590 1
a590 1
    character(len=*), intent(in), optional :: FILLVALUE
d603 1
a603 1
    if ( myTranspose ) then
d608 1
a608 1
    endif
d614 1
a614 1
    if ( myTrim ) lon = maxval(len_trim(array))
d620 2
a621 2
    else if ( size(array,1) == 1 ) then
      call name_and_size ( name, myClean, 1, TheShape )
d624 1
a624 1
    else if ( size(array,2) == 1 ) then
d627 6
a632 6
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do i = 1, size(array,1)
        do j = 1, size(array,2), MyWidth
          DumpTheseZeros = myClean .or. &
            & any(array(i,j:min(j+2*MyWidth-1, size(array,2))) /= myFillValue) &
d634 2
a635 2
            & ( j+MyWidth >= size(array,2) .and. &
            & any(array(min(i+1, size(array,1)),1:min(1+MyWidth-1, size(array,2))) &
d638 1
a638 1
          if (.not. myClean) then
d640 1
a640 1
              call say_fill ( (/ i, size(array,1), j-1, size(array,2) /), &
d647 1
a647 1
            do k = j, min(j+myWidth-1, size(array,2))
d655 1
a655 1
      call say_fill ( (/ i-1, size(array,1), j-MyWidth, size(array,2) /), &
d659 1
a659 1
  end subroutine DUMP_2D_CHAR
d661 3
a663 3
  ! --------------------------------------------  DUMP_2D_COMPLEX  -----
  recursive subroutine DUMP_2D_COMPLEX ( ARRAY, NAME, WIDTH, FORMAT, &
    & FILLVALUE, OPTIONS, LBOUND, TheShape )
d665 1
a665 1
    complex(rk), intent(in) :: ARRAY(:,:)
d683 1
a683 1
    if ( myTranspose ) then
d688 1
a688 1
    endif
d704 1
a704 1
  end subroutine DUMP_2D_COMPLEX
d706 3
a708 3
  ! --------------------------------------------  DUMP_2D_DCOMPLEX  -----
  recursive subroutine DUMP_2D_DCOMPLEX ( ARRAY, NAME, WIDTH, FORMAT, &
    & FILLVALUE, OPTIONS, LBOUND, TheShape )
d710 1
a710 1
    complex(rk), intent(in) :: ARRAY(:,:)
d729 1
a729 1
    if ( myTranspose ) then
d734 1
a734 1
    endif
d750 1
a750 1
  end subroutine DUMP_2D_DCOMPLEX
d752 4
a755 4
  ! ---------------------------------------------  DUMP_2D_DOUBLE  -----
 recursive subroutine DUMP_2D_DOUBLE ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
    double precision, intent(in) :: ARRAY(:,:)
d757 1
a757 1
    double precision, intent(in), optional :: FILLVALUE
d782 1
a782 1
  end subroutine DUMP_2D_DOUBLE
d784 4
a787 4
  ! --------------------------------------------  DUMP_2D_INTEGER  -----
  recursive subroutine DUMP_2D_INTEGER ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
    integer, intent(in) :: ARRAY(:,:)
d789 1
a789 1
    integer, intent(in), optional :: FILLVALUE
d814 1
a814 1
  end subroutine DUMP_2D_INTEGER
d816 3
a818 3
  ! --------------------------------------------  DUMP_2D_INTEGER_2B  -----
  recursive subroutine DUMP_2D_INTEGER_2B ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d820 1
a820 1
    integer(C_int16_t), intent(in) :: ARRAY(:,:)
d822 1
a822 1
    integer, intent(in), optional :: FILLVALUE
a828 9
    integer :: Base, I, J, K
    integer :: MyWidth
    integer :: NumZeroRows
    integer :: myFillValue
    character(len=64) :: MyFormat
    integer :: nUnique
    integer, dimension(MAXNUMELEMENTS) :: counts
    integer, dimension(MAXNUMELEMENTS) :: elements

d830 2
a831 2
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
  end subroutine DUMP_2D_INTEGER_2B
d833 3
a835 3
  ! --------------------------------------------  DUMP_2D_LOGICAL  -----
  recursive subroutine DUMP_2D_LOGICAL ( ARRAY, NAME, OPTIONS, THESHAPE )
    logical, intent(in) :: ARRAY(:,:)
d844 1
a844 1
    if ( myTranspose ) then
d848 1
a848 1
    endif
d853 1
a853 1
      call name_and_size ( name, myClean, 1, TheShape )
d856 1
a856 1
    else if ( size(array,2) == 1 ) then
d859 1
a859 1
      call name_and_size ( name, myClean, size(array), TheShape )
d865 1
a865 1
      call name_and_size ( name, myClean, size(array), TheShape )
d871 7
a877 7
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do i = 1, size(array,1)
        do j = 1, size(array,2), myWidth
          if (.not. myClean) then
            call output ( i, places=max(4,ilog10(size(array,1))+1) , advance='no' )
            call output ( j, places=max(4,ilog10(size(array,2))+1) , advance='no' )
d880 1
a880 1
          do k = j, min(j+myWidth-1, size(array,2))
d888 1
a888 1
  end subroutine DUMP_2D_LOGICAL
d890 4
a893 4
  ! -----------------------------------------------  DUMP_2D_REAL  -----
  recursive subroutine DUMP_2D_REAL ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, THESHAPE )
    real, intent(in) :: ARRAY(:,:)
d895 1
a895 1
    real, intent(in), optional :: FILLVALUE
d920 1
a920 1
  end subroutine DUMP_2D_REAL
d922 2
a923 2
  ! -----------------------------------------  DUMP_2x2xN_COMPLEX  -----
  subroutine DUMP_2x2xN_COMPLEX ( ARRAY, NAME, FORMAT, OPTIONS )
d926 1
a926 1
    complex(rk), intent(in) :: ARRAY(:,:,:) ! Better be 2x2xn
d943 4
a946 4
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do j = 1, size(array,3)
        if (.not. myClean) then
d960 1
a960 1
  end subroutine DUMP_2x2xN_COMPLEX
d962 2
a963 2
  ! ----------------------------------------  DUMP_2x2xN_DCOMPLEX  -----
  subroutine DUMP_2x2xN_DCOMPLEX ( ARRAY, NAME, FORMAT, OPTIONS )
d966 1
a966 1
    complex(rk), intent(in) :: ARRAY(:,:,:) ! Better be 2x2xn
d983 4
a986 4
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do j = 1, size(array,3)
        if (.not. myClean) then
d1000 1
a1000 1
  end subroutine DUMP_2x2xN_DCOMPLEX
d1002 2
a1003 2
  ! -----------------------------------------------  DUMP_3D_CHAR  -----
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, FILLVALUE, WIDTH, &
d1005 1
a1005 1
    character(len=*), intent(in) :: ARRAY(:,:,:)
d1007 1
a1007 1
    character(len=*), intent(in), optional :: FILLVALUE
d1024 1
a1024 1
    if ( myTrim ) lon = maxval(len_trim(array))
d1032 1
a1032 1
    else if ( size(array,1) == 1 ) then
d1035 1
a1035 1
    else if ( size(array,2) == 1 ) then
d1038 1
a1038 1
    else if ( size(array,3) == 1 ) then
d1042 7
a1048 7
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do i = 1, size(array,1)
        do j = 1, size(array,2)
          do k = 1, size(array,3), MyWidth
            DumpTheseZeros = myClean .or. &
              & any(array(i,j,k:min(k+2*MyWidth-1, size(array,3))) /= myFillValue) &
d1050 2
a1051 2
              & ( k+MyWidth >= size(array,3) .and. &
              & any(array(i,min(j+1, size(array,2)),1:min(1+MyWidth-1, size(array,3))) &
d1054 1
a1054 1
            if (.not. myClean) then
d1056 2
a1057 2
                call say_fill ( (/ i, size(array,1), j-1, size(array,2), &
                  & k, size(array,3) /), numZeroRows, myFillValue, inc=3 )
d1063 1
a1063 1
              do l = k, min(k+MyWidth-1, size(array,3))
d1072 2
a1073 2
      call say_fill ( (/ i-1, size(array,1), j-1, size(array,2), &
        & k-MyWidth, size(array,3) /), numZeroRows, myFillValue )
d1076 1
a1076 1
  end subroutine DUMP_3D_CHAR
d1078 3
a1080 3
  ! --------------------------------------------  DUMP_3D_COMPLEX  -----
  subroutine DUMP_3D_COMPLEX ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, THESHAPE )
d1082 1
a1082 1
    complex(rk), intent(in) :: ARRAY(:,:,:)
d1084 1
a1084 1
    real, intent(in), optional :: FILLVALUE
d1111 1
a1111 1
  end subroutine DUMP_3D_COMPLEX
d1113 3
a1115 3
  ! -------------------------------------------  DUMP_3D_DCOMPLEX  -----
  subroutine DUMP_3D_DCOMPLEX ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, THESHAPE )
d1117 1
a1117 1
    complex(rk), intent(in) :: ARRAY(:,:,:)
d1119 1
a1119 1
    real(rk), intent(in), optional :: FILLVALUE
d1146 1
a1146 1
  end subroutine DUMP_3D_DCOMPLEX
d1148 4
a1151 4
  ! ---------------------------------------------  DUMP_3D_DOUBLE  -----
  subroutine DUMP_3D_DOUBLE ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, THESHAPE )
    double precision, intent(in) :: ARRAY(:,:,:)
d1153 1
a1153 1
    double precision, intent(in), optional :: FILLVALUE
d1173 1
a1173 1
  end subroutine DUMP_3D_DOUBLE
d1175 4
a1178 4
  ! --------------------------------------------  DUMP_3D_INTEGER  -----
  subroutine DUMP_3D_INTEGER ( ARRAY, NAME, &
    & FILLVALUE, FORMAT, WIDTH, LBOUND, OPTIONS, THESHAPE )
    integer, intent(in) :: ARRAY(:,:,:)
d1180 1
a1180 1
    integer, intent(in), optional :: FILLVALUE
d1203 1
a1203 1
  end subroutine DUMP_3D_INTEGER
d1205 4
a1208 4
  ! ---------------------------------------------  DUMP_3D_REAL  -----
  subroutine DUMP_3D_REAL ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, THESHAPE )
    real, intent(in) :: ARRAY(:,:,:)
d1210 1
a1210 1
    real, intent(in), optional :: FILLVALUE
d1230 1
a1230 1
  end subroutine DUMP_3D_REAL
d1232 4
a1235 4
  ! ---------------------------------------------  DUMP_4D_DOUBLE  -----
  subroutine DUMP_4D_DOUBLE ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    double precision, intent(in) :: ARRAY(:,:,:,:)
d1237 1
a1237 1
    double precision, intent(in), optional :: FILLVALUE
d1251 1
a1251 1
  end subroutine DUMP_4D_DOUBLE
d1253 4
a1256 4
  ! ---------------------------------------------  DUMP_4D_REAL  -----
  subroutine DUMP_4D_REAL ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    real, intent(in) :: ARRAY(:,:,:,:)
d1258 1
a1258 1
    real, intent(in), optional :: FILLVALUE
d1272 1
a1272 1
  end subroutine DUMP_4D_real
d1274 3
a1276 9
  ! -----------------------------------------------  DUMP_HASH_STR  -----
  subroutine DUMP_HASH_STR ( COUNTEMPTY, KEYS, VALUES, NAME, SEPARATOR, OPTIONS )
    ! Dumps a hash composed of two string lists: keys and values
    logical, intent(in)          :: COUNTEMPTY
    character(len=*), intent(in) :: KEYS
    character(len=*), intent(in) :: VALUES
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: SEPARATOR
    character(len=*), intent(in), optional :: options
d1278 6
a1283 4
    character( len=max(len(values), len(keys)) ) :: element
    integer :: J
    integer :: NumElements
    character(len=*), parameter :: COMMA = ','
d1285 1
a1285 1
    call theDumpBegins ( options )
d1287 7
a1293 16
    NumElements = NumStringElements(keys, countEmpty, &
     & separator)
    if ( NumElements == 0 ) then
      call empty ( name )
    else
      call name_and_size ( name, .false., NumElements )
      if ( present(name) .and. .not. mylaconic ) call newLine
      call output ( '(key)    =   (value)', advance='yes' )
      do j = 1, NumElements
        call GetStringElement( keys, element, j, countEmpty, separator)
        call output ( trim(element), advance='no' )
        call output( ' = ', advance='no' )
        call GetStringElement( values, element, j, countEmpty, separator)
        call output ( trim(element), advance='no' )
        call finishLine
      end do ! j
d1295 2
a1296 2
    call theDumpEnds
  end subroutine DUMP_HASH_STR
d1298 5
a1302 9
  ! -----------------------------------------------  DUMP_HASH_LOG  -----
  subroutine DUMP_HASH_LOG ( COUNTEMPTY, KEYS, VALUES, NAME, SEPARATOR, OPTIONS )
    ! Dumps a hash composed of two string lists: keys and values
    logical, intent(in)          :: COUNTEMPTY
    character(len=*), intent(in) :: KEYS
    logical, dimension(:), intent(in) :: VALUES
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: SEPARATOR
    character(len=*), intent(in), optional :: OPTIONS
d1304 6
a1309 4
    character( len=len(keys)) :: element
    integer :: J
    integer :: NumElements
    character(len=*), parameter :: COMMA = ','
d1311 13
a1323 17
    call theDumpBegins ( options )

    NumElements = NumStringElements(keys, countEmpty, &
     & separator)
    if ( NumElements == 0 ) then
      call empty ( name )
    else
      call name_and_size ( name, .false., NumElements )
      if ( present(name) .and. .not. mylaconic ) call newLine
      call output ( '(key)    =   (value)', advance='yes' )
      do j = 1, NumElements
        call GetStringElement( keys, element, j, countEmpty, separator)
        call output ( trim(element), advance='no' )
        call output( ' = ', advance='no' )
        call output ( values(j), advance='no' )
        call finishLine
      end do ! j
a1324 2
    call theDumpEnds
  end subroutine DUMP_HASH_LOG
d1326 1
a1326 9
  ! -----------------------------------------------  DUMP_STRLIST  -----
  subroutine DUMP_STRLIST ( STRING, NAME, FILLVALUE, OPTIONS, INSEPARATOR )
    ! Dumps a ','-separated string list, one item per lines
    ! (Unless it consists of multiple lines)
    character(len=*), intent(in) :: STRING
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: FILLVALUE
    character(len=*), intent(in), optional :: OPTIONS
    character(len=*), optional, intent(in) :: INSEPARATOR
d1328 4
a1331 15
    integer :: J
    integer :: NumElements
    character(len=len(string)) :: myFillValue
    character(len=1), parameter :: CR = ACHAR(13) ! Carriage return
    character(len=1), parameter :: LF = ACHAR(10) ! Line feed
    character(len=1) :: SEPARATOR
    logical, parameter :: COUNTEMPTY = .true.
    ! Executable
    if( index(string, CR) > 0 ) then
      call dump( (/ trim(string) /), name, fillvalue, options=options )
      return
    elseif( index(string, LF) > 0 ) then
      call dump( (/ trim(string) /), name, fillvalue, options=options )
      return
    endif
d1333 1
a1333 3
    call theDumpBegins ( options )
    myFillValue = ' '
    if ( present(FillValue) ) myFillValue = FillValue
d1335 14
a1348 80
    SEPARATOR = ','
    if ( present(INSEPARATOR) ) SEPARATOR = INSEPARATOR
    
    NumElements = NumStringElements(string, countEmpty, &
     & separator)
    if ( NumElements == 0 ) then
      call empty ( name )
    else if ( NumElements == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( trim(string), advance='no' )
      call finishLine
    else
      call name_and_size ( name, myClean, NumElements )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do j = 1, NumElements
        call GetStringElement(string, myFillValue, j, countEmpty, separator)
        call output ( trim(myFillValue), advance='no' )
        call finishLine
      end do ! j
    end if
    call theDumpEnds
  end subroutine DUMP_STRLIST

  ! ---------------------------------------------- DumpDates -----
  ! This family dumps dates (re)formatted according to dates_module
  subroutine dump_tai( taiDates, name, width, dateFormat, timeFormat )
    ! Dump an array of tai dates in whatever formats the user specifies
    ! Warning: does not bother with leap seconds
    ! By default we dump both date and time fields
    ! If dateFormat is present and blank or 'none', don't print date
    ! If timeFormat is present and blank or 'none', don't print time
    ! Args
    double precision, dimension(:)       :: taiDates ! tai93 (s)
    character(len=*), optional           :: name
    integer, intent(in), optional        :: WIDTH
    character(len=*), optional           :: dateFormat
    character(len=*), optional           :: timeFormat
    ! Internal variables
    character(len=16)                            :: date, time
    character(len=MAXUTCSTRLENGTH), dimension(size(taiDates)) &
      &                                          :: dates
    integer                                      :: error
    integer                                      :: i
    ! Executable
    if ( size(taidates) < 1 ) then
      call dump ( taiDates, name )
      return
    endif
    do i = 1, size(taiDates)
      dates(i) = tai93s2utc( taiDates(i) )
    enddo
    if ( present(dateFormat) .or. present(timeFormat) ) then
      do i = 1, size(taiDates)
        call splitDateTime( dates(i), error, date, time )
        if ( present(dateFormat) ) then
          if ( len_trim(dateFormat) < 1 .or. lowercase(dateFormat) == 'none' ) then
            date = ' '
          else
            date = ReformatDate( date, toForm=dateFormat )
          endif
        endif
        if ( present(timeFormat) ) then
          if ( len_trim(timeFormat) < 1 .or. lowercase(timeFormat) == 'none' ) then
            time = ' '
          else
            time = ReformatTime( time, Form=timeFormat )
          endif
        endif
        dates(i) = trim(date) // time
      enddo
    endif
    call dump( dates, name, width=width )
  end subroutine dump_tai
  
  ! ---------------------------------------------- DumpDumpOptions -----
  subroutine DumpDumpOptions( options )
    ! Show 
    ! (if current options supplied) actual dump, diff options
    ! (if arg is "?") available options and their meanings
    ! (if no arg) default options
d1350 5
a1354 189
    character(len=1), parameter :: fillChar = '1' ! fill blanks with '. .'
     if ( .not. present(options) ) then
       call blanks(90, fillChar='-', advance='yes')
       call output(' ------------------------ Summary of automatic Dump, Diff options'      , advance='no')
       call output(' ------------------------ ', advance='yes')
       call outputNamedValue ( 'character printed between row, col id and data', aftersub, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'default DIFF switches for CLEAN, TRIM, etc.', trim_safe(DEFAULTDIFFOPTIONS), advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'default DUMP switches for CLEAN, TRIM, etc.', trim_safe(DEFAULTDUMPOPTIONS), advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'print abs min, max, etc. when DIFF has RMS set TRUE?', DIFFRMSMEANSRMS, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'skip dumping every element of a constant array?', DIFFRMSMEANSRMS, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'what side to place headers when dumping tables', trim(DUMPTABLESIDE), advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'print stats all on one line?', STATSONONELINE, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'pct output format', trim_safe(PCTFORMAT), advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'rms output format', trim_safe(RMSFORMAT), advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'numeric output format', trim_safe(SDFORMATDEFAULT), advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'complex output format', trim_safe(sdFormatDefaultCmplx), advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call blanks(90, fillChar='-', advance='yes')
     elseif ( index( options, "?" ) > 0 ) then
       call output( 'The meaning of options is determined by the presence or absence', advance='yes' )
       call output( 'of specific characters in the options string', advance='yes' )
       call output( 'If options is present and contains the following characters:', advance='yes' )
       call output( '(for dump or diff)', advance='yes' )
       call output( '  character         meaning', advance='yes' )
       call output( '     ---            -------', advance='yes' )
       call output( '      B              show Bandwidth, % of array that is non-zero', advance='yes' )
       call output( '      H              show rank, TheShape of array', advance='yes' )
       call output( '      L              laconic; skip printing name, size of array', advance='yes' )
       call output( '      N              show where NaNs and Infs are located', advance='yes' )
       call output( '      R              rms       -- min, max, etc.', advance='yes' )
       call output( '      b              table of % vs. amount of differences (pdf)', advance='yes' )
       call output( '      c              clean', advance='yes' )
       call output( '      g              gaps      ', advance='yes' )
       call output( '      l              collapse (last index)', advance='yes' )
       call output( '      r              ratios    -- min, max, etc. of difference ratios', advance='yes' )
       call output( '      s              stats     -- number of differences', advance='yes' )
       call output( '      p              transpose (for rank 2 arrays only)', advance='yes' )
       call output( '      t              trim      ', advance='yes' )
       call output( '      u              unique    ', advance='yes' )
       call output( '      w              wholearray', advance='yes' )
       call output( '      W[i]           wholearray, looping over ith index', advance='yes' )
       call output( '                     (for rank 3 and 4 arrays only)', advance='yes' )
       call output( '      1 or 2 or ..   ignored; calling routine is free to interpret', advance='yes' )
       call output( ' ', advance='yes' )
       call output( 'An exception is the behavior of w (wholearray):', advance='yes' )
       call output( 'if all {HNRblrs} are FALSE, i.e. unset, the whole array is dumped (or diffed)', advance='yes' )
       call output( 'if any are TRUE the whole array will be dumped only if', advance='yes' )
       call output( 'w is present or wholearray is set to TRUE', advance='yes' )
     else
       call outputNamedValue ( 'options', trim_safe(options), advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'thisIsADiff?', thisIsADiff, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'myClean?', myClean, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'myCollapse?', myCollapse, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'myCyclic?', myCyclic, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'myRMS?', myRMS, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'myRatios?', myRatios, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
       call outputNamedValue ( 'myWholeArray?', myWholeArray, advance='yes', &
         & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     endif
  end subroutine DumpDumpOptions

  ! -----------------------------------  dumpLists  -----
  ! Dump a 2d array as a set of lists
  ! Show names and related (numerical) values
  subroutine dumpLists_chars ( ARRAY, NAME, WIDTH, SEP, DELIMS )
    ! Args
    character(len=*), dimension(:,:), intent(in)   :: array
    character(len=*), intent(in), optional         :: NAME
    integer, optional, intent(in)                  :: width
    character(len=*), optional, intent(in)         :: sep
    character(len=*), optional, intent(in)         :: delims
    ! Internal variables
    character(len=8) :: intChars
    integer :: leftMargin
    integer :: line
    integer :: m
    integer :: myWidth ! how wide to make each list
    integer :: n
    integer :: n1
    integer :: n2
    integer :: nElemsPerLine
    integer :: nlines
    character(len=32) :: tabRange
    ! Executable
    call theDumpBegins ( options=' ' )
    if ( size(array, 2) < 1 ) then
      call empty(name)
    endif
    call name_and_size( name, clean=.false., size=size(array, 2) )
    m = size(array,1) ! num of elements in each list
    myWidth = (len(array(1,1))+2) * m + 3
    if ( present(width) ) myWidth = width
    leftMargin = max(4,ilog10(size(array,2)+1)) + 2
    nElemsPerLine = max( 1, (MAXLINELEN-leftMargin-1)/myWidth )
    nLines = 1 + (size(array,2)-1)/nElemsPerLine
    call writeIntsToChars( leftMargin, intChars )
    tabRange = intChars
    call writeIntsToChars( MAXLINELEN, intChars )
    tabRange = trim(tabRange) // '-' // intChars
    call writeIntsToChars( myWidth, intChars )
    tabRange = trim(tabRange) // '+' // intChars
    call setTabs( range=tabRange )
    n2 = 0
    do line=1, nLines
      n1 = n2 + 1
      n2 = min( n2 + nElemsPerLine, size(array,2) )
      call newLine
      call output ( n1, places=max(4,ilog10(size(array,2)+1)) , advance='no' )
      call output ( afterSub , advance='no' )
      do n=n1, n2
        call blanksToTab
        call outputList( array(:,n), sep, delims)
      enddo
    enddo
  end subroutine dumpLists_chars

  subroutine dumpLists_ints ( ARRAY, NAME, WIDTH, SEP, DELIMS )
    ! Args
    integer, dimension(:,:), intent(in)            :: array
    character(len=*), intent(in), optional         :: NAME
    character(len=*), optional, intent(in)         :: sep
    integer, optional, intent(in)                  :: width
    character(len=*), optional, intent(in)         :: delims
    ! Internal variables
    integer :: arrayMax
    character(len=8) :: intChars
    integer :: leftMargin
    integer :: line
    integer :: m
    integer :: myWidth ! how wide to make each list
    integer :: n
    integer :: n1
    integer :: n2
    integer :: nElemsPerLine
    integer :: nlines
    character(len=32) :: tabRange
    ! Executable
    call theDumpBegins ( options=' ' )
    if ( size(array, 2) < 1 ) then
      call empty(name)
    endif
    call name_and_size( name, clean=.false., size=size(array, 2) )
    m = size(array,1) ! num of elements in each list
    arrayMax = maxval(abs(array)) + 1
    myWidth = ( ilog10(arrayMax) + 1 ) * m + 3
    if ( present(width) ) myWidth = width
    leftMargin = max(4,ilog10(size(array,2)+1)) + 2
    nElemsPerLine = max( 1, (MAXLINELEN-leftMargin-1)/myWidth )
    nLines = 1 + (size(array,2)-1)/nElemsPerLine
    call writeIntsToChars( max(4,ilog10(size(array,2)+1)) + 4, intChars )
    tabRange = intChars
    call writeIntsToChars( MAXLINELEN, intChars )
    tabRange = trim(tabRange) // '-' // intChars
    call writeIntsToChars( myWidth, intChars )
    tabRange = trim(tabRange) // '+' // intChars
    call setTabs( range=tabRange )
    n2 = 0
    do line=1, nLines
      n1 = n2 + 1
      n2 = min( n2 + nElemsPerLine, size(array,2) )
      call newLine
      call output ( n1, places=max(4,ilog10(size(array,2)+1)) , advance='no' )
      call output ( afterSub , advance='no' )
      do n=n1, n2
        call blanksToTab
        call outputList( array(:,n), sep, delims)
      enddo
    enddo
    ! Reset tabs
    call newLine
    call resetTabs
  end subroutine dumpLists_ints
d1356 1
a1356 356
  ! -----------------------------------  dumpNamedValues  -----
  ! Another hash-like dump:
  ! Show names and related (numerical) values
  ! -----------------------------------  dumpNamedValues_DOUBLE  -----
  subroutine dumpNamedValues_DOUBLE ( VALUES, NAMES, FORMAT, WIDTH, OPTIONS )
    double precision, intent(in)                         :: values(:)
    character(len=*), intent(in), optional :: NAMES
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: WIDTH ! How many pairs per line (1)?
    character(len=*), intent(in), optional :: options
    
    integer :: J, K, L
    integer :: MyWidth
    character(len=24) :: myName
    call theDumpBegins ( options )
    MyWidth = 1
    if ( present(width) ) myWidth = max(width, 1)
    if ( size(values) < 1 ) return
    if ( myClean ) call output(' ', advance='yes')
    l = 0
    do j=1, size(values), MyWidth
      do k=1, MyWidth
        call blanks(3, advance='no')
        l = l + 1
        if ( l <= size(values) ) then
          if ( present (names) ) then
            call GetStringElement(names, myName, l, .true.)
          else
            write(myName, *) 'double # ', l, ': '
          end if
          call output(myName,  advance='no')
          call blanks(3, advance='no')
          call output(values(l), format, advance='no')
        end if
      end do
      call output(' ', advance='yes')
    end do
    call theDumpEnds

  end subroutine dumpNamedValues_DOUBLE

  ! ----------------------------------  dumpNamedValues_INTEGER  -----
  subroutine dumpNamedValues_INTEGER ( VALUES, NAMES, FORMAT, WIDTH, OPTIONS )
    integer, intent(in)                         :: values(:)
    character(len=*), intent(in), optional :: NAMES
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: WIDTH ! How many pairs per line (1)?
    character(len=*), intent(in), optional :: options
    
    integer :: J, K, L
    integer :: MyWidth
    character(len=24) :: myName
    call theDumpBegins ( options )
    MyWidth = 1
    if ( present(width) ) myWidth = max(width, 1)
    if ( size(values) < 1 ) return
    if ( myClean ) call output(' ', advance='yes')
    l = 0
    do j=1, size(values), MyWidth
      do k=1, MyWidth
        call blanks(3, advance='no')
        l = l + 1
        if ( l <= size(values) ) then
          if ( present (names) ) then
            call GetStringElement(names, myName, l, .true.)
          else
            write(myName, *) 'integer # ', l, ': '
          end if
          call output(myName,  advance='no')
          call blanks(3, advance='no')
          call output(values(l), format=format, advance='no')
        end if
      end do
      call output(' ', advance='yes')
    end do
    call theDumpEnds

  end subroutine dumpNamedValues_INTEGER

  ! -------------------------------------  dumpNamedValues_REAL  -----
  subroutine dumpNamedValues_REAL ( VALUES, NAMES, FORMAT, WIDTH, OPTIONS )
    real, intent(in)                         :: values(:)
    character(len=*), intent(in), optional :: NAMES
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: WIDTH ! How many pairs per line (1)?
    character(len=*), intent(in), optional :: options
    
    integer :: J, K, L
    integer :: MyWidth
    character(len=24) :: myName
    call theDumpBegins ( options )
    MyWidth = 1
    if ( present(width) ) myWidth = max(width, 1)
    if ( size(values) < 1 ) return
    if ( myClean ) call output(' ', advance='yes')
    l = 0
    do j=1, size(values), MyWidth
      do k=1, MyWidth
        call blanks(3, advance='no')
        l = l + 1
        if ( l <= size(values) ) then
          if ( present (names) ) then
            call GetStringElement(names, myName, l, .true.)
          else
            write(myName, *) 'single # ', l, ': '
          end if
          call output(myName,  advance='no')
          call blanks(3, advance='no')
          call output(values(l), format, advance='no')
        end if
      end do
      call output(' ', advance='yes')
    end do
    call theDumpEnds

  end subroutine dumpNamedValues_REAL

 ! ---------------------------------------------  DUMPSUMS  -----
 ! This family of routines dumps the running sum:
 ! summed(i) == ( array(i) + summed(i-1) )
  subroutine DUMPSUMS_DOUBLE ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    double precision, intent(in) :: ARRAY(:)
    character(len=*), intent(in), optional :: NAME
    double precision, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options
    ! Local variables
    integer                                  :: i
    double precision, dimension(size(array)) :: summed
    ! Executable
    if ( size(array) < 1 ) return
    summed(1) = array(1)
    if ( size(array) > 1 ) then
      do i=2, size(array)
        summed(i) = array(i) + summed(i-1)
      enddo
    endif
    call dump ( summed, NAME, &
      & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
  end subroutine DUMPSUMS_DOUBLE

  subroutine DUMPSUMS_INTEGER ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, intent(in) :: ARRAY(:)
    character(len=*), intent(in), optional :: NAME
    integer, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options
    ! Local variables
    integer                                  :: i
    integer, dimension(size(array)) :: summed
    ! Executable
    if ( size(array) < 1 ) return
    summed(1) = array(1)
    if ( size(array) > 1 ) then
      do i=2, size(array)
        summed(i) = array(i) + summed(i-1)
      enddo
    endif
    call dump ( summed, NAME, &
      & FILLVALUE, FORMAT, WIDTH, LBOUND, OPTIONS )
  end subroutine DUMPSUMS_INTEGER

  subroutine DUMPSUMS_REAL ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    real, intent(in) :: ARRAY(:)
    character(len=*), intent(in), optional :: NAME
    real, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options
    ! Local variables
    integer                                  :: i
    real, dimension(size(array)) :: summed
    ! Executable
    if ( size(array) < 1 ) return
    summed(1) = array(1)
    if ( size(array) > 1 ) then
      do i=2, size(array)
        summed(i) = array(i) + summed(i-1)
      enddo
    endif
    call dump ( summed, NAME, &
      & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
  end subroutine DUMPSUMS_REAL

  ! -----------------------------------  dumpTable  -----
  ! This family of routines dumps a table of values and headers
  ! The headside determines on which of the 4 sides 
  ! ('top', 'left', 'right', 'bottom') we place the headers
  subroutine dumpTable_DOUBLE ( VALUES, HEADERS, HEADSIDE, FORMAT, FORMATS )
    double precision, dimension(:,:), intent(in) :: values
    character(len=*), dimension(:), intent(in)   :: HEADERS
    character(len=*), intent(in)                 :: HEADSIDE
    character(len=*), intent(in), optional       :: FORMAT
    character(len=*), dimension(:), intent(in), optional :: FORMATS
    include 'dumpTable.f9h'
  end subroutine dumpTable_DOUBLE

  subroutine dumpTable_INTEGER ( VALUES, HEADERS, HEADSIDE, FORMAT, FORMATS )
    integer, dimension(:,:), intent(in)          :: values
    character(len=*), dimension(:), intent(in)   :: HEADERS
    character(len=*), intent(in)                 :: HEADSIDE
    character(len=*), intent(in), optional       :: FORMAT
    character(len=*), dimension(:), intent(in), optional :: FORMATS
    include 'dumpTable.f9h'
  end subroutine dumpTable_INTEGER

  subroutine dumpTable_REAL ( VALUES, HEADERS, HEADSIDE, FORMAT, FORMATS )
    real, dimension(:,:), intent(in)             :: values
    character(len=*), dimension(:), intent(in)   :: HEADERS
    character(len=*), intent(in)                 :: HEADSIDE
    character(len=*), intent(in), optional       :: FORMAT
    character(len=*), dimension(:), intent(in), optional :: FORMATS
    include 'dumpTable.f9h'
  end subroutine dumpTable_REAL

  ! -----------------------------------  dumpTextfile  -----
  ! This family of routines dumps a table of values and headers
  ! The headside determines on which of the 4 sides 
  ! ('top', 'left', 'right', 'bottom') we place the headers
  subroutine dumpTextfile ( FileName, Options )
    use io_stuff, only: read_textfile
    character(len=*), intent(in)           :: FileName
    character(len=*), intent(in), optional :: options
    ! Internal variables
    character(len=MAXTEXTFILELINELEN), dimension(MAXTEXTFILELINES) :: lines
    integer :: k, nLines
    ! Executable
    lines = ' '
    call read_textfile( FileName, lines, nLines=nLines )
    call outputNamedValue ( 'text file name', trim(FileName) )
    call outputNamedValue ( 'number of lines', nLines )
    call blanks( 80, fillChar='-', advance='yes' )
    do k=1, nLines
      call output ( trim(lines(k)), advance='yes' )
    enddo
    call blanks( 80, fillChar='-', advance='yes' )
  end subroutine dumpTextfile

 ! ---------------------------------------------  SELFDIFF_DOUBLE  -----
  subroutine SELFDIFF_DOUBLE ( ARRAY, NAME, &
    & FILLVALUE, WIDTH, FORMAT, waves, LBOUND, OPTIONS )
    ! dump the running increment == ( array(i) - array(i-1) )
    double precision, intent(in) :: ARRAY(:)
    character(len=*), intent(in), optional :: NAME
    double precision, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    logical, intent(in), optional :: WAVES
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options
    ! Local variables
    integer                                  :: i
    double precision, dimension(size(array)-1) :: increment
    integer, dimension(100) :: lengths
    logical :: myWaves
    integer :: nWaves
    ! Executable
    myWaves = .false.
    if ( present(waves) ) myWaves = waves
    if ( size(array) < 2 ) return
    do i=2, size(array)
      increment(i-1) = array(i) - array(i-1)
    enddo
    if ( myWaves ) then
      call halfWaves( increment, lengths, nWaves )
      if ( nWaves > 0 ) then
        call dump( lengths(1:nWaves), 'half-waves of ' // NAME )
      endif
      return
    endif
    call dump ( increment, NAME, &
      & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
  end subroutine SELFDIFF_DOUBLE

 ! ---------------------------------------------  SELFDIFF_INTEGER  -----
  subroutine SELFDIFF_INTEGER ( ARRAY, NAME, &
    & FILLVALUE, FORMAT, WIDTH, waves, LBOUND, OPTIONS )
    ! dump the running increment == ( array(i) - array(i-1) )
    integer, intent(in) :: ARRAY(:)
    character(len=*), intent(in), optional :: NAME
    integer, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    logical, intent(in), optional :: WAVES
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options
    ! Local variables
    integer                                  :: i
    integer, dimension(size(array)-1) :: increment
    ! Executable
    if ( size(array) < 2 ) return
    do i=2, size(array)
      increment(i-1) = array(i) - array(i-1)
    enddo
    call dump ( increment, NAME, &
      & FILLVALUE, FORMAT, WIDTH, LBOUND, OPTIONS )
  end subroutine SELFDIFF_INTEGER

 ! ---------------------------------------------  SELFDIFF_REAL  -----
  subroutine SELFDIFF_REAL ( ARRAY, NAME, &
    & FILLVALUE, FORMAT, WIDTH, waves, LBOUND, OPTIONS )
    ! dump the running increment == ( array(i) - array(i-1) )
    real, intent(in) :: ARRAY(:)
    character(len=*), intent(in), optional :: NAME
    real, intent(in), optional :: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    logical, intent(in), optional :: WAVES
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options
    ! Local variables
    integer                                  :: i
    real, dimension(size(array)-1) :: increment
    ! logical, parameter :: unique = .false. 
    integer, dimension(100) :: lengths
    logical :: myWaves
    integer :: nWaves
    ! Executable
    myWaves = .false.
    if ( present(waves) ) myWaves = waves
    if ( size(array) < 2 ) return
    do i=2, size(array)
      increment(i-1) = array(i) - array(i-1)
    enddo
    if ( myWaves ) then
      call halfWaves( increment, lengths, nWaves )
      if ( nWaves > 0 ) then
        call dump( lengths(1:nWaves), 'half-waves of ' // NAME )
      endif
      return
    endif
    call dump ( increment, NAME, &
      & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
  end subroutine SELFDIFF_REAL

  ! --- Private procedures ---
  ! --- finishLine ---
  ! Print a newLine, optionally echoing the item name
  subroutine finishLine
    ! Executable
    if ( len_trim(nameOnEachLine) > 1 ) then
      call blanks (2)
      call output ( trim(nameOnEachLine), advance='no' )
    endif
    call newLine
  end subroutine finishLine

  ! --- DumpCollapsedArray ---
d1359 2
a1360 2
  subroutine DUMPCOLLAPSEDARRAY_1D_INTEGER (  array, name, fillValue, options )
    INTEGER, intent(in) :: ARRAY(:)
d1362 1
a1362 1
    INTEGER, intent(in), optional :: FILLVALUE
d1365 1
a1365 1
  end subroutine DUMPCOLLAPSEDARRAY_1D_INTEGER
d1367 2
a1368 2
  subroutine DUMPCOLLAPSEDARRAY_1D_DOUBLE (  array, name, fillValue, options )
    double precision, intent(in) :: ARRAY(:)
d1370 1
a1370 1
    double precision, intent(in), optional :: FILLVALUE
d1373 1
a1373 1
  end subroutine DUMPCOLLAPSEDARRAY_1D_DOUBLE
d1375 2
a1376 2
  subroutine DUMPCOLLAPSEDARRAY_1D_REAL (  array, name, fillValue, options )
    real, intent(in) :: ARRAY(:)
d1378 1
a1378 1
    real, intent(in), optional :: FILLVALUE
d1381 1
a1381 1
  end subroutine DUMPCOLLAPSEDARRAY_1D_REAL
d1383 2
a1384 2
  subroutine DUMPCOLLAPSEDARRAY_2D_DOUBLE (  array, name, fillValue, options )
    double precision, intent(in) :: ARRAY(:,:)
d1386 1
a1386 1
    double precision, intent(in), optional :: FILLVALUE
d1389 2
a1390 2
    double precision, dimension(size(array, 1)) :: nums
    logical, dimension(size(array, 1))          :: logs
d1393 7
a1399 7
    if ( index(COLLAPSEOPTIONS, 'num') > 0 ) then
      call collapse( array, nums, options=COLLAPSEOPTIONS )
      call dump( nums, name, fillvalue, options=options )
    endif
    if ( index(COLLAPSEOPTIONS, 'any') > 0 .or. &
      &  index(COLLAPSEOPTIONS, 'all') > 0 ) then
      call collapse( array, logs=logs, options=COLLAPSEOPTIONS )
d1401 2
a1402 2
    endif
  end subroutine DUMPCOLLAPSEDARRAY_2D_DOUBLE
d1404 2
a1405 2
  subroutine DUMPCOLLAPSEDARRAY_2D_REAL (  array, name, fillValue, options )
    real, intent(in) :: ARRAY(:,:)
d1407 1
a1407 1
    real, intent(in), optional :: FILLVALUE
d1410 2
a1411 2
    real, dimension(size(array, 1)) :: nums
    logical, dimension(size(array, 1))          :: logs
d1414 7
a1420 7
    if ( index(COLLAPSEOPTIONS, 'num') > 0 ) then
      call collapse( array, nums, options=COLLAPSEOPTIONS )
      call dump( nums, name, fillvalue, options=options )
    endif
    if ( index(COLLAPSEOPTIONS, 'any') > 0 .or. &
      &  index(COLLAPSEOPTIONS, 'all') > 0 ) then
      call collapse( array, logs=logs, options=COLLAPSEOPTIONS )
d1422 2
a1423 2
    endif
  end subroutine DUMPCOLLAPSEDARRAY_2D_REAL
d1425 2
a1426 2
  subroutine DUMPCOLLAPSEDARRAY_2D_INTEGER (  array, name, fillValue, options )
    INTEGER, intent(in) :: ARRAY(:,:)
d1428 1
a1428 1
    INTEGER, intent(in), optional :: FILLVALUE
d1431 2
a1432 2
    INTEGER, dimension(size(array, 1)) :: nums
    logical, dimension(size(array, 1))          :: logs
d1435 7
a1441 7
    if ( index(COLLAPSEOPTIONS, 'num') > 0 ) then
      call collapse( array, nums, options=COLLAPSEOPTIONS )
      call dump( nums, name, fillvalue, options=options )
    endif
    if ( index(COLLAPSEOPTIONS, 'any') > 0 .or. &
      &  index(COLLAPSEOPTIONS, 'all') > 0 ) then
      call collapse( array, logs=logs, options=COLLAPSEOPTIONS )
d1443 2
a1444 2
    endif
  end subroutine DUMPCOLLAPSEDARRAY_2D_INTEGER
d1446 2
a1447 2
  subroutine DUMPCOLLAPSEDARRAY_3D_DOUBLE (  array, name, fillValue, options )
    double precision, intent(in) :: ARRAY(:,:,:)
d1449 1
a1449 1
    double precision, intent(in), optional :: FILLVALUE
d1452 2
a1453 2
    double precision, dimension(size(array, 1),size(array, 2)) :: nums
    logical, dimension(size(array, 1),size(array, 2))          :: logs
d1456 7
a1462 7
    if ( index(COLLAPSEOPTIONS, 'num') > 0 ) then
      call collapse( array, nums, options=COLLAPSEOPTIONS )
      call dump( nums, name, fillvalue, options=options )
    endif
    if ( index(COLLAPSEOPTIONS, 'any') > 0 .or. &
      &  index(COLLAPSEOPTIONS, 'all') > 0 ) then
      call collapse( array, logs=logs, options=COLLAPSEOPTIONS )
d1464 2
a1465 2
    endif
  end subroutine DUMPCOLLAPSEDARRAY_3D_DOUBLE
d1467 2
a1468 2
  subroutine DUMPCOLLAPSEDARRAY_3D_REAL (  array, name, fillValue, options )
    real, intent(in) :: ARRAY(:,:,:)
d1470 1
a1470 1
    real, intent(in), optional :: FILLVALUE
d1473 2
a1474 2
    real, dimension(size(array, 1),size(array, 2)) :: nums
    logical, dimension(size(array, 1),size(array, 2))          :: logs
d1477 7
a1483 7
    if ( index(COLLAPSEOPTIONS, 'num') > 0 ) then
      call collapse( array, nums, options=COLLAPSEOPTIONS )
      call dump( nums, name, fillvalue, options=options )
    endif
    if ( index(COLLAPSEOPTIONS, 'any') > 0 .or. &
      &  index(COLLAPSEOPTIONS, 'all') > 0 ) then
      call collapse( array, logs=logs, options=COLLAPSEOPTIONS )
d1485 2
a1486 2
    endif
  end subroutine DUMPCOLLAPSEDARRAY_3D_REAL
d1488 2
a1489 2
  subroutine DUMPCOLLAPSEDARRAY_3D_INTEGER (  array, name, fillValue, options )
    INTEGER, intent(in) :: ARRAY(:,:,:)
d1491 1
a1491 1
    INTEGER, intent(in), optional :: FILLVALUE
d1494 2
a1495 2
    INTEGER, dimension(size(array, 1),size(array, 2)) :: nums
    logical, dimension(size(array, 1),size(array, 2))          :: logs
d1498 7
a1504 7
    if ( index(COLLAPSEOPTIONS, 'num') > 0 ) then
      call collapse( array, nums, options=COLLAPSEOPTIONS )
      call dump( nums, name, fillvalue, options=options )
    endif
    if ( index(COLLAPSEOPTIONS, 'any') > 0 .or. &
      &  index(COLLAPSEOPTIONS, 'all') > 0 ) then
      call collapse( array, logs=logs, options=COLLAPSEOPTIONS )
d1506 2
a1507 56
    endif
  end subroutine DUMPCOLLAPSEDARRAY_3D_INTEGER

  !
  subroutine FILTEREDDIFF_1D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    double precision, intent(in) :: ARRAY1(:)
    character(len=*), intent(in) :: NAME1
    double precision, intent(in) :: ARRAY2(:)
    character(len=*), intent(in) :: NAME2
    double precision, intent(in):: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    double precision, dimension(size(array1)) :: filtered1
    double precision, dimension(size(array2)) :: filtered2
    double precision :: refmin, refmax, refrms
    include "diff.f9h"
  end subroutine FILTEREDDIFF_1D_DOUBLE

  subroutine FILTEREDDIFF_1D_INTEGER ( IARRAY1, NAME1, IARRAY2, NAME2, &
    & IFILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, intent(in) :: IARRAY1(:)
    character(len=*), intent(in) :: NAME1
    integer, intent(in) :: IARRAY2(:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: IFILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    real, dimension(size(iarray1)) :: array1
    real, dimension(size(iarray2)) :: array2
    real :: fillValue
    ! So we don't have to write an integer-version of allstats
    array1 = iarray1
    array2 = iarray2
    fillValue = iFillValue
    call DIFF ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
  end subroutine FILTEREDDIFF_1D_INTEGER

  subroutine FILTEREDDIFF_1D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    real, intent(in) :: ARRAY1(:)
    character(len=*), intent(in) :: NAME1
    real, intent(in) :: ARRAY2(:)
    character(len=*), intent(in) :: NAME2
    real, intent(in):: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options
d1509 2
a1510 160
    real, dimension(size(array1)) :: filtered1
    real, dimension(size(array2)) :: filtered2
    real :: refmin, refmax, refrms
    include "diff.f9h"
  end subroutine FILTEREDDIFF_1D_REAL

  subroutine FILTEREDDIFF_2D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    double precision, intent(in) :: ARRAY1(:,:)
    character(len=*), intent(in) :: NAME1
    double precision, intent(in) :: ARRAY2(:,:)
    character(len=*), intent(in) :: NAME2
    double precision, intent(in):: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options
    !
    double precision, dimension(product(shape(array1))) :: filtered1
    double precision, dimension(product(shape(array2))) :: filtered2
    double precision :: refmin, refmax, refrms
    include "diff.f9h"
  end subroutine FILTEREDDIFF_2D_DOUBLE

  subroutine FILTEREDDIFF_2D_INTEGER ( IARRAY1, NAME1, IARRAY2, NAME2, &
    & IFILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, intent(in) :: IARRAY1(:,:)
    character(len=*), intent(in) :: NAME1
    integer, intent(in) :: IARRAY2(:,:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: IFILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    real, dimension(size(iarray1,1), size(iarray1,2)) :: array1
    real, dimension(size(iarray1,1), size(iarray1,2)) :: array2
    real :: fillValue
    ! So we don't have to write an integer-version of allstats
    array1 = iarray1
    array2 = iarray2
    fillValue = iFillValue
    call DIFF ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
  end subroutine FILTEREDDIFF_2D_INTEGER

  subroutine FILTEREDDIFF_2D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    real, intent(in) :: ARRAY1(:,:)
    character(len=*), intent(in) :: NAME1
    real, intent(in) :: ARRAY2(:,:)
    character(len=*), intent(in) :: NAME2
    real, intent(in):: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options
    !
    real, dimension(product(shape(array1))) :: filtered1
    real, dimension(product(shape(array2))) :: filtered2
    real :: refmin, refmax, refrms
    include "diff.f9h"
  end subroutine FILTEREDDIFF_2D_REAL

  subroutine FILTEREDDIFF_3D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    double precision, intent(in) :: ARRAY1(:,:,:)
    character(len=*), intent(in) :: NAME1
    double precision, intent(in) :: ARRAY2(:,:,:)
    character(len=*), intent(in) :: NAME2
    double precision, intent(in):: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options

    double precision, dimension(product(shape(array1))) :: filtered1
    double precision, dimension(product(shape(array2))) :: filtered2
    double precision :: refmin, refmax, refrms
    include "diff.f9h"
  end subroutine FILTEREDDIFF_3D_DOUBLE

  subroutine FILTEREDDIFF_3D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    real, intent(in) :: ARRAY1(:,:,:)
    character(len=*), intent(in) :: NAME1
    real, intent(in) :: ARRAY2(:,:,:)
    character(len=*), intent(in) :: NAME2
    real, intent(in):: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options

    real, dimension(product(shape(array1))) :: filtered1
    real, dimension(product(shape(array2))) :: filtered2
    real :: refmin, refmax, refrms
    include "diff.f9h"
  end subroutine FILTEREDDIFF_3D_REAL

  subroutine FILTEREDDIFF_4D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    double precision, intent(in) :: ARRAY1(:,:,:,:)
    character(len=*), intent(in) :: NAME1
    double precision, intent(in) :: ARRAY2(:,:,:,:)
    character(len=*), intent(in) :: NAME2
    double precision, intent(in):: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options

    double precision, dimension(product(shape(array1))) :: filtered1
    double precision, dimension(product(shape(array2))) :: filtered2
    double precision :: refmin, refmax, refrms
    include "diff.f9h"
  end subroutine FILTEREDDIFF_4D_DOUBLE

  subroutine FILTEREDDIFF_4D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
    real, intent(in) :: ARRAY1(:,:,:,:)
    character(len=*), intent(in) :: NAME1
    real, intent(in) :: ARRAY2(:,:,:,:)
    character(len=*), intent(in) :: NAME2
    real, intent(in):: FILLVALUE
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options

    real, dimension(product(shape(array1))) :: filtered1
    real, dimension(product(shape(array2))) :: filtered2
    real :: refmin, refmax, refrms
    include "diff.f9h"
  end subroutine FILTEREDDIFF_4D_REAL

  ! ---------------------------------------------  restoreDumpConfig  -----
  ! Restore default values for dump settings
  subroutine RESTOREDUMPCONFIG
    DEFAULTDIFFOPTIONS        = ' '
    DEFAULTDUMPOPTIONS        = ' '
    DEFAULTMAXLON             = 128
    DEFAULTWIDTH              = 10
    DUMPTABLESIDE             = 'top'
    DIFFRMSMEANSRMS           = .false.
    DONTDUMPIFALLEQUAL        = .true.
    FILTERFILLSFROMRMS        = .false.
    PRINTFILLVALUE            = .true.
    PRINTNAMEIFDIFF           = .true.
    STATSONONELINE            = .true.
    COLLAPSEOPTIONS           = 'num[+]all[+]'
    INTPLACES                 = '6' ! how many places
    PCTFORMAT                 = '*' ! * means default format
    RMSFORMAT                 = '*' ! * means default format
    SDFORMATDEFAULT           = '(1pg14.6)'
  end subroutine RESTOREDUMPCONFIG

  ! ---------------------------------------------  arrayShapeToString  -----
  function arrayShapeToString ( arrayShape ) result ( string )
d1513 2
a1514 2
    integer, dimension(:), intent(in) :: arrayShape
    character(len=16) :: string
d1522 1
a1522 1
    enddo
d1524 1
a1524 43
  end function arrayShapeToString
  ! ------------------------------------------------------  Empty  -----
  subroutine Empty ( Name )
    character(len=*), intent(in), optional :: Name

    if ( present(name) ) then
      call output ( name , advance='no' )
      call output ( ' is ' , advance='no' )
      nameHasBeenPrinted = .true.
    end if
    call output ( 'empty', advance='yes' )

  end subroutine Empty

  ! -----------------------------------------------------  ILOG10  -----
  integer function ILOG10(int)
    integer, intent(in) :: int
    ilog10=nint(log10(real(int)))
  end function ILOG10

  ! ----------------------------------------------  Name_And_Size  -----
  subroutine Name_And_Size ( NAME, CLEAN, SIZE, THESHAPE )
    character(len=*), intent(in), optional :: Name
    logical, intent(in) :: Clean
    integer, intent(in) :: Size
    character(len=*), intent(in), optional :: TheShape

    if ( present(name) .and. .not. myLaconic ) then
      if ( len_trim(name) < 1 ) return
      if ( .not. nameHasBeenPrinted ) then
        call output ( name , advance='no' )
        if ( present(theShape) ) call output ( theShape , advance='no' )
      end if
      if ( clean ) then 
        call output ( trim(" \ ") ) ! This goofiness is to outwit an incorrect
                                    ! Intel compiler.
        call output ( size , advance='no' )
      end if
      if ( size == 1 ) call output ( ' ' , advance='no' )
      nameHasBeenPrinted = .true.
    end if

  end subroutine Name_And_Size
d1526 1
a1526 1
  ! -------------------- PrintIt ---------------------
d1530 1
a1530 1
  subroutine PrintIt_char ( it, format )
d1534 1
a1534 1
  end subroutine PrintIt_char
d1542 1
a1542 1
  subroutine PrintIt_real ( it, format )
d1546 1
a1546 1
  end subroutine PrintIt_real
d1548 1
a1548 1
  subroutine PrintIt_double ( it, format )
d1552 1
a1552 1
  end subroutine PrintIt_double
d1554 1
a1554 1
  subroutine PrintIt_complex ( it, format )
d1559 1
a1559 1
  end subroutine PrintIt_complex
d1561 1
a1561 1
  subroutine PrintIt_dcomplex ( it, format )
d1566 1
a1566 1
  end subroutine PrintIt_dcomplex
d1568 1
a1568 1
  ! ----------------------------------------------  printPercentages  -----
d1571 1
a1571 1
  subroutine printPercentages ( name, equal, unequal )
d1576 2
a1577 2
    myPCTFormat  = DEFAULTPCTFORMAT
    if ( PCTFORMAT /= '*' ) myPCTFormat = PCTFORMAT
d1587 1
a1587 1
    if ( .not. STATSONONELINE ) then
d1590 1
a1590 1
    endif
d1597 1
a1597 1
  end subroutine printPercentages
d1599 1
a1599 1
  ! ----------------------------------------------  printRMSetc  -----
d1602 1
a1602 1
  subroutine printRMSetc_double ( Name, min, max, rms, mean  )
d1615 1
a1615 1
  end subroutine printRMSetc_double
d1617 1
a1617 1
  subroutine printRMSetc_real ( Name, min, max, rms, mean  )
d1629 1
a1629 1
  end subroutine printRMSetc_real
d1631 1
a1631 1
  subroutine printRMSetc_int ( Name, in_min, in_max, rms, mean  )
d1644 1
a1644 1
  end subroutine printRMSetc_int
d1655 1
a1655 1
  ! --------------------------------------------  Say_Fill_Complex  -----
d1662 2
a1663 2
  ! --------------------------------------------  Say_Fill_Dcomplex  -----
  subroutine Say_Fill_Dcomplex ( Subs, NumZeroRows, Fill, Inc, Format )
d1667 1
a1667 1
  end subroutine Say_Fill_Dcomplex
d1707 2
a1708 1
  subroutine showColumnNums( lineLength, skip )
d1737 1
a1737 1
      enddo
d1739 5
a1743 4
    enddo
  end subroutine showColumnNums
  
  function snipOption( options, particular ) result ( snipped )
d1753 1
a1753 130
  end function snipOption
  
  subroutine theDumpBegins(options)
    character(len=*), intent(in), optional :: options
    nameHasBeenPrinted = .false.
    stampOptions%neverStamp = .true. ! So we don't interrupt tables of numbers
    myBandwidth  = theDefault('bandwidth') ! .false.
    myClean      = theDefault('clean') ! .false.
    myCollapse   = theDefault('collapse') ! .false.
    myCyclic     = theDefault('cyclic') ! .false.
    myDirect     = theDefault('direct') ! .false.
    myGaps       = theDefault('gaps')
    myLaconic    = theDefault('laconic')
    myNaNs       = theDefault('nans')
    myRMS        = theDefault('rms')   ! .false.
    MyRatios     = theDefault('ratios')   ! .false.
    myShape      = theDefault('shape')  ! .false.
    myStats      = theDefault('stat')  ! .false.
    myTable      = theDefault('table')  ! .false.
    myTranspose  = theDefault('transpose')  ! .false.
    myTrim       = theDefault('trim')  ! .false.
    myUnique     = theDefault('unique')
    myWholeArray = theDefault('wholearray')
    if ( present(options) ) then
      myBandwidth   =   index( options, dopt_bandwidth  ) > 0
      myClean       =   index( options, dopt_clean      ) > 0
      myCollapse    =   index( options, dopt_collapse   ) > 0
      myCyclic      =   index( options, dopt_cyclic     ) > 0
      myGaps        =   index( options, dopt_gaps       ) > 0
      myLaconic     =   index( options, dopt_laconic    ) > 0
      myNaNs        =   index( options, dopt_NaNs       ) > 0
      myRatios      =   index( options, dopt_ratios     ) > 0
      myRMS         =   index( options, dopt_rms        ) > 0
      myShape       =   index( options, dopt_shape      ) > 0
      myStats       =   index( options, dopt_stats      ) > 0
      myTable       =   index( options, dopt_table      ) > 0
      myTranspose   =   index( options, dopt_transpose  ) > 0
      myTrim        =   index( options, dopt_trim       ) > 0
      myUnique      =   index( options, dopt_unique     ) > 0
      myVerbose     =   index( options, dopt_verbose    ) > 0
      myWholeArray  = ( index( options, dopt_wholearray ) > 0 )
    endif
    myWholeArray = myWholeArray .or. &
      & .not. (myBandwidth.or. myCollapse .or. myRatios .or. myRMS .or. myShape .or. myStats &
      & .or. myTable .or. myNaNs)
    onlyWholeArray = myWholeArray .and. &
      & .not. (myBandwidth.or. myCollapse .or. myRatios .or. myRMS .or. myShape .or. myStats &
      & .or. myTable .or. myNaNs)
    nameHasBeenPrinted = nameHasBeenPrinted .or. myLaconic
  end subroutine theDumpBegins

  subroutine theDumpEnds
    stampOptions%neverStamp = .false.
  end subroutine theDumpEnds

  function theDefault( code ) result ( isit )
    ! Return the default value for a given code, e.g. 'clean'
    ! Args
    character(len=*), intent(in)    :: code
    logical                         :: isit
    !
    character(len=8) :: defaultString
    ! Executable
    if ( thisIsADiff ) then
      defaultString = DEFAULTDIFFOPTIONS
    else
      defaultString = DEFAULTDUMPOPTIONS
    endif
    select case ( code )
    case ('clean')
      isit = index( defaultstring, dopt_clean      ) > 0
    case ('cyclic')
      isit = index( defaultstring, dopt_cyclic     ) > 0
    case ('direct')
      isit = index( defaultstring, dopt_collapse   ) > 0
    case ('gaps')
      isit = index( defaultstring, dopt_gaps       ) > 0
    case ('laconic')
      isit = index( defaultstring, dopt_laconic    ) > 0
    case ('nans')
      isit = index( defaultstring, dopt_NaNs       ) > 0
    case ('rms')
      isit = index( defaultstring, dopt_rms        ) > 0
    case ('shape')
      isit = index( defaultstring, dopt_shape      ) > 0
    case ('stat')
      isit = index( defaultstring, dopt_stats      ) > 0
    case ('table')
      isit = index( defaultstring, dopt_table      ) > 0
    case ('transpose')
      isit = index( defaultstring, dopt_transpose  ) > 0
    case ('trim')
      isit = index( defaultstring, dopt_trim       ) > 0
    case ('unique')
      isit = index( defaultstring, dopt_unique     ) > 0
    case ('verbose')
      isit = index( defaultstring, dopt_verbose    ) > 0
    case ('wholearray')
      isit = index( defaultstring, dopt_wholearray ) > 0

    case default
      isit = .false.
    end select
  end function theDefault
  
  subroutine UNFILTEREDDIFF_1D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, parameter :: RK = kind(1.0d0)
    real(rk), intent(in) :: ARRAY1(:)
    character(len=*), intent(in) :: NAME1
    real(rk), intent(in) :: ARRAY2(:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    include "unfiltereddiff.f9h"
  end subroutine UNFILTEREDDIFF_1D_DOUBLE

  subroutine UNFILTEREDDIFF_1D_INTEGER ( IARRAY1, NAME1, IARRAY2, NAME2, &
    & WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, intent(in) :: IARRAY1(:)
    character(len=*), intent(in) :: NAME1
    integer, intent(in) :: IARRAY2(:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options
d1755 2
a1756 137
    real, dimension(size(iarray1)) :: array1
    real, dimension(size(iarray2)) :: array2
    ! So we don't have to write an integer-version of allstats
    array1 = iarray1
    array2 = iarray2
    call DIFF ( ARRAY1, NAME1, ARRAY2, NAME2, &
      & WIDTH=WIDTH, FORMAT=FORMAT, &
      & LBOUND=LBOUND, OPTIONS=OPTIONS )
  end subroutine UNFILTEREDDIFF_1D_INTEGER

  subroutine UNFILTEREDDIFF_1D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, parameter :: RK = kind(1.0e0)
    real(rk), intent(in) :: ARRAY1(:)
    character(len=*), intent(in) :: NAME1
    real(rk), intent(in) :: ARRAY2(:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    include "unfiltereddiff.f9h"
  end subroutine UNFILTEREDDIFF_1D_REAL

  subroutine UNFILTEREDDIFF_2D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, parameter :: RK = kind(1.0d0)
    real(rk), intent(in) :: ARRAY1(:,:)
    character(len=*), intent(in) :: NAME1
    real(rk), intent(in) :: ARRAY2(:,:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options

    include "unfiltereddiff.f9h"
  end subroutine UNFILTEREDDIFF_2D_DOUBLE

  subroutine UNFILTEREDDIFF_2D_INTEGER ( IARRAY1, NAME1, IARRAY2, NAME2, &
    & WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, intent(in) :: IARRAY1(:,:)
    character(len=*), intent(in) :: NAME1
    integer, intent(in) :: IARRAY2(:,:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND ! Low bound for Array
    character(len=*), intent(in), optional :: options

    real, dimension(size(iarray1,1), size(iarray1,2)) :: array1
    real, dimension(size(iarray1,1), size(iarray1,2)) :: array2
    ! So we don't have to write an integer-version of allstats
    array1 = iarray1
    array2 = iarray2
    call DIFF ( ARRAY1, NAME1, ARRAY2, NAME2, &
      & WIDTH=WIDTH, FORMAT=FORMAT, &
      & LBOUND=LBOUND, OPTIONS=OPTIONS )
  end subroutine UNFILTEREDDIFF_2D_INTEGER

  subroutine UNFILTEREDDIFF_2D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, parameter :: RK = kind(1.0e0)
    real(rk), intent(in) :: ARRAY1(:,:)
    character(len=*), intent(in) :: NAME1
    real(rk), intent(in) :: ARRAY2(:,:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options

    include "unfiltereddiff.f9h"
  end subroutine UNFILTEREDDIFF_2D_REAL

  subroutine UNFILTEREDDIFF_3D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, parameter :: RK = kind(1.0d0)
    real(rk), intent(in) :: ARRAY1(:,:,:)
    character(len=*), intent(in) :: NAME1
    real(rk), intent(in) :: ARRAY2(:,:,:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options

    include "unfiltereddiff.f9h"
  end subroutine UNFILTEREDDIFF_3D_DOUBLE

  subroutine UNFILTEREDDIFF_3D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, parameter :: RK = kind(1.0e0)
    real(rk), intent(in) :: ARRAY1(:,:,:)
    character(len=*), intent(in) :: NAME1
    real(rk), intent(in) :: ARRAY2(:,:,:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options

    include "unfiltereddiff.f9h"
  end subroutine UNFILTEREDDIFF_3D_REAL

  subroutine UNFILTEREDDIFF_4D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, parameter :: RK = kind(1.0d0)
    real(rk), intent(in) :: ARRAY1(:,:,:,:)
    character(len=*), intent(in) :: NAME1
    real(rk), intent(in) :: ARRAY2(:,:,:,:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options

    include "unfiltereddiff.f9h"
  end subroutine UNFILTEREDDIFF_4D_DOUBLE

  subroutine UNFILTEREDDIFF_4D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & WIDTH, FORMAT, LBOUND, OPTIONS )
    integer, parameter :: RK = kind(1.0e0)
    real(rk), intent(in) :: ARRAY1(:,:,:,:)
    character(len=*), intent(in) :: NAME1
    real(rk), intent(in) :: ARRAY2(:,:,:,:)
    character(len=*), intent(in) :: NAME2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    integer, intent(in), optional :: LBOUND
    character(len=*), intent(in), optional :: options

    include "unfiltereddiff.f9h"
  end subroutine UNFILTEREDDIFF_4D_REAL

  logical function uniqueonly ( options )
d1764 1
a1764 1
  end function uniqueonly
d1769 1
a1769 1
       "$Id: dump_0.f90,v 2.136 2016/03/31 22:59:03 pwagner Exp $"
d1776 1
a1776 1
end module DUMP_0
d1778 4
a1781 1
! $Log: dump_0.f90,v $
d2003 1
a2003 1
! Restored more backward-compatible arglist to DUMP_STRLIST
d2006 1
a2006 1
! Added required arg=separator to DUMP_STRLIST
d2072 1
a2072 1
! Add LBOUND to dump_1d_[double,integer,real]
d2075 1
a2075 1
! Add LBOUND argument to Dump_1d_logical
d2133 1
a2133 1
! Add WIDTH and FORMAT arguments to 1D_REAL and 1D_DOUBLE
d2154 1
a2154 1
! Added dump_1d_real for s.p. arrays
d2157 2
a2158 2
! Added optional blase arg to dump_nd_char; fixed bug where optional
! format not passed from dump_3d_int
d2161 1
a2161 1
! Fixed bug where dump_2d_integer didn't pass format to 1d dump.
d2164 1
a2164 1
! Improved dump_nd_double to skip rows (e.g., of zeros)
@


2.136
log
@Added dumpTextfile
@
text
@d183 1
d325 1
d373 2
a374 1
    & myTable, myTranspose, myTrim, myUnique, myWholeArray, onlyWholeArray
d3051 2
a3052 1
    call output ( ' )', advance='yes' )
d3246 1
d3302 2
d3487 1
a3487 1
       "$Id: dump_0.f90,v 2.135 2016/03/23 00:22:17 pwagner Exp $"
d3497 3
@


2.135
log
@Diff now able to print name on each line; repaired error in printRMSEtc when array is integer
@
text
@d88 1
d130 1
d207 1
a207 1
    & DUMPSUMS, DUMPTABLE, RESTOREDUMPCONFIG, SELFDIFF
d361 7
a367 5
  integer, parameter :: MAXLINELEN      = 120
  integer, parameter :: MAXNUMELEMENTS  = 2000
  integer, parameter :: TOOMANYELEMENTS = 125*50*3500 ! Don't try to diff l1b DACS
  logical, parameter :: DEEBUG          = .false.
  logical, parameter :: SHORTCUTDIFFS   = .false.
d2423 23
d3480 1
a3480 1
       "$Id: dump_0.f90,v 2.134 2016/01/12 00:46:51 pwagner Exp $"
d3490 3
@


2.134
log
@May override DEFAULTWIDTH when dumping char array
@
text
@d27 24
a50 24
  use BITSTUFF, only: MAXBITNUMBER, WHICHBITSARESET
  use DATES_MODULE, only: MAXUTCSTRLENGTH, &
    & REFORMATDATE, REFORMATTIME, SPLITDATETIME, TAI93S2UTC
  use HIGHOUTPUT, only: ALIGNTOFIT, BLANKSTOTAB, &
    & NUMNEEDSFORMAT, NUMTOCHARS, &
    & OUTPUTLIST, OUTPUTNAMEDVALUE, RESETTABS, SETTABS
  use IEEE_ARITHMETIC, only: IEEE_IS_FINITE
  use MLSFILLVALUES, only : BANDWIDTH, COLLAPSE, FILTERVALUES, HALFWAVES, &
    & ISFINITE, ISINFINITE, ISNAN, &
    & INFFUNCTION, NANFUNCTION, REORDERFILLVALUES, REPLACEFILLVALUES, &
    & WHEREARETHEINFS, WHEREARETHENANS
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
  use MLSFINDS, only: FINDUNIQUE
  use MLSSTATS1, only: STAT_T, &
    & ALLSTATS, FILLVALUERELATION, HOWFAR, HOWNEAR, &
    & MLSMAX, MLSMEAN, MLSMIN, MLSSTDDEV, RATIOS, RESET
  use MLSSTRINGLISTS, only: CATLISTS, GETSTRINGELEMENT, NUMSTRINGELEMENTS, &
    & OPTIONDETAIL
  use MLSSTRINGS, only: DELETE, INDEXES, LOWERCASE, &
    & READINTSFROMCHARS, TRIM_SAFE, &
    & WRITEINTSTOCHARS
  use OUTPUT_M, only: OUTPUTOPTIONS, STAMPOPTIONS, &
    & BLANKS, NEWLINE, OUTPUT
  use TIME_M, only: TIME_NOW
d71 1
d343 1
d359 2
a360 2
  integer, parameter :: MAXLINELEN = 120
  integer, parameter :: MAXNUMELEMENTS = 2000
d362 2
a363 3
  logical, parameter ::   DEEBUG = .false.
  logical, parameter ::   SHORTCUTDIFFS = .false.
  ! character(len=MAXLINELEN) :: LINEOFZEROS
d370 6
a375 5
  logical, save :: nameHasBeenPrinted = .false.
  integer :: bwidth, myRank, numNonFill, numFill, indx2BSliced, iSlice
  real :: pctnzero
  logical, save :: thisIsADiff = .false.
  integer :: how_many
d377 1
a377 1
  complex, parameter :: one_c4 = (1., 0.)
d776 2
a777 1
            call output ( ' not printed', advance='yes' )
d779 2
a780 1
          call output( ints(1:numBitNames), format='(i3)', advance='yes' )
d824 2
a825 1
      call output ( array(1)(1:lon), advance='yes' )
d988 1
d1040 2
a1041 1
      call output ( array(1), advance='yes' )
d1048 2
a1049 1
      call output( ' values are T', advance='yes' )
d1056 2
a1057 1
      call output( ' values are F', advance='yes' )
d1067 2
a1068 1
        call output( k+N, advance='yes' )
d1072 1
a1072 1
          call output( array(k+1 : k+N), onlyif=.true., advance='yes' )
d1074 1
a1074 1
          call output( array(k+1 : k+N), onlyif=.false., advance='yes' )
d1076 1
d1161 2
a1162 1
      call output ( array(1,:), advance='yes' )
d1402 2
a1403 1
      call output ( array(1,1), advance='yes' )
d1410 2
a1411 1
      call output( ' values are T', advance='yes' )
d1416 2
a1417 1
      call output( ' values are F', advance='yes' )
d1499 2
a1500 1
        call output ( array(1,2,j), myFormat, advance='yes' )
d1503 2
a1504 1
        call output ( array(2,2,j), myFormat, advance='yes' )
d1539 2
a1540 1
        call output ( array(1,2,j), myFormat, advance='yes' )
d1543 2
a1544 1
        call output ( array(2,2,j), myFormat, advance='yes' )
d1852 2
a1853 1
        call output ( trim(element), advance='yes' )
d1888 2
a1889 1
        call output ( values(j), advance='yes' )
d1934 2
a1935 1
      call output ( trim(string), advance='yes' )
d1941 2
a1942 1
        call output ( trim(myFillValue), advance='yes' )
d2517 11
d3056 1
a3056 1
  subroutine printRMSetc_int ( Name, min, max, rms, mean  )
d3058 3
a3060 3
    integer, intent(in) :: min
    integer, intent(in) :: max
    real, intent(in) :: rms
d3062 6
d3453 1
a3453 1
       "$Id: dump_0.f90,v 2.133 2015/08/25 18:38:27 vsnyder Exp $"
d3463 3
@


2.133
log
@Include LBOUND in 'all values are the same' dumps
@
text
@d333 2
a334 1
  integer, public, save          :: DEFAULTMAXLON = 128
d804 1
a804 1
    MyWidth = 10
d2844 1
d3413 1
a3413 1
       "$Id: dump_0.f90,v 2.132 2015/01/29 01:23:29 vsnyder Exp $"
d3423 3
@


2.132
log
@Make sure MyFillValue has a value before references
@
text
@d1036 3
a1038 1
      call output ( ': all ', advance='no' )
d1043 3
a1045 1
      call output ( ': all ', advance='no' )
d3411 1
a3411 1
       "$Id: dump_0.f90,v 2.131 2014/08/06 23:02:21 vsnyder Exp $"
d3421 3
@


2.131
log
@Use kind C_Int16_t from ISO_C_Bindings instead of INTEGER*2
@
text
@d934 2
d982 2
d1101 2
d1296 2
d1328 2
d1440 2
d1693 2
d1723 2
d1750 2
d3407 1
a3407 1
       "$Id: dump_0.f90,v 2.130 2014/01/09 00:24:29 pwagner Exp $"
d3417 3
@


2.130
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d988 2
a989 1
    integer*2, intent(in) :: ARRAY(:)
d1331 2
a1332 1
    integer*2, intent(in) :: ARRAY(:,:)
d3389 1
a3389 1
       "$Id: dump_0.f90,v 2.129 2013/09/26 15:25:41 pwagner Exp $"
d3399 3
@


2.129
log
@Added 2-byte integer dumps
@
text
@d30 3
d49 1
a49 3
    & ALIGNTOFIT, BLANKS, BLANKSTOTAB, &
    & NEWLINE, NUMNEEDSFORMAT, NUMTOCHARS, &
    & OUTPUT, OUTPUTLIST, OUTPUTNAMEDVALUE, RESETTABS, SETTABS
d3387 1
a3387 1
       "$Id: dump_0.f90,v 2.128 2013/08/12 23:47:25 pwagner Exp $"
d3397 3
@


2.128
log
@FindSomethings moved to MLSFinds module
@
text
@d225 1
a225 1
    module procedure DUMP_1D_DOUBLE, DUMP_1D_INTEGER
d228 1
a228 1
    module procedure DUMP_2D_DOUBLE, DUMP_2D_INTEGER
d984 24
d1326 25
d3386 1
a3386 1
       "$Id: dump_0.f90,v 2.127 2013/06/28 18:08:38 pwagner Exp $"
d3396 3
@


2.127
log
@Note if all logical elements equal
@
text
@d36 1
a36 1
  use MLSSETS, only: FINDUNIQUE
d3337 1
a3337 1
       "$Id: dump_0.f90,v 2.126 2013/06/19 23:14:39 pwagner Exp $"
d3347 3
@


2.126
log
@Remove more unused stuff; give default value to myDirect
@
text
@d1004 10
d1303 1
a1303 1
  recursive subroutine DUMP_2D_LOGICAL ( ARRAY, NAME, OPTIONS, TheShape )
d1326 10
d1358 1
a1358 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d1464 1
a1464 1
    & MAXLON, OPTIONS, TheShape )
d1540 1
a1540 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d1549 1
a1549 1
    character(len=*), intent(in), optional :: TheShape
d1575 1
a1575 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d1610 1
a1610 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d1635 1
a1635 1
    & FILLVALUE, FORMAT, WIDTH, LBOUND, OPTIONS, TheShape )
d1663 1
a1663 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS, TheShape )
d2819 1
a2819 1
  subroutine Name_And_Size ( Name, Clean, Size, TheShape )
d3337 1
a3337 1
       "$Id: dump_0.f90,v 2.125 2013/01/10 00:18:43 pwagner Exp $"
d3347 3
@


2.125
log
@Dumps with -N just show where NaNs are
@
text
@d46 1
a46 1
    & ALIGNTOFIT, BLANKS, BLANKSTOTAB, DUMPTABS, &
d180 1
a180 1
!       W[i]           wholearray, looping over ith index
d1454 1
a1454 1
    integer :: Base, I, J, K, L
d1657 1
a1658 1
    integer :: MyWidth
d1677 1
a1677 3
    integer :: I, J, K, L
    integer :: NumZeroRows
    double precision :: myFillValue
a1679 1
    integer :: MyWidth
d1698 1
a1698 3
    integer :: I, J, K, L
    integer :: NumZeroRows
    real :: myFillValue
a1700 1
    integer :: MyWidth
a1720 1
    character(len=1) :: mySeparator
a1723 2
    mySeparator = COMMA
    if ( present(SEPARATOR) ) mySeparator = SEPARATOR
a1756 1
    character(len=1) :: mySeparator
a1759 2
    mySeparator = COMMA
    if ( present(SEPARATOR) ) mySeparator = SEPARATOR
d1934 1
a1934 1
       call output( '      p              transpose ', advance='yes' )
d1939 1
a2060 1
    ! call dumpTabs
a2075 1
    ! call dumpTabs
a2351 1
    logical :: myWaves
a2352 2
    myWaves = .false.
    if ( present(waves) ) myWaves = waves
d3050 1
d3317 1
a3317 1
       "$Id: dump_0.f90,v 2.124 2012/09/11 21:10:24 pwagner Exp $"
d3327 3
@


2.124
log
@Requires 'N' option to show where NaNs, Infs are located
@
text
@d69 1
d346 1
a381 1
 ! Clean       Clean up after any prior dumps
d384 3
d390 1
a390 1
 ! LBound      Lower bound when printing wholearray indices
d1954 1
a1954 1
       call output( 'if all {HRblrs} are FALSE, i.e. unset, the whole array is dumped (or diffed)', advance='yes' )
d3098 1
a3098 1
      & .or. myTable)
d3101 1
a3101 1
      & .or. myTable)
d3332 1
a3332 1
       "$Id: dump_0.f90,v 2.123 2012/07/05 23:47:31 pwagner Exp $"
d3342 3
@


2.123
log
@Added restoreDumpConfig
@
text
@d167 1
d278 3
a280 3
  interface printIt
    module procedure printIt_char, printIt_DOUBLE, printIt_INT, printIt_REAL
    module procedure printIt_complex, printIt_dcomplex
d283 2
a284 2
  interface printRMSetc
    module procedure printRMSetc_DOUBLE, printRMSetc_INT, printRMSetc_REAL
d287 3
a289 3
  interface say_fill
    module procedure say_fill_char, say_fill_double, say_fill_int
    module procedure say_fill_real, say_fill_complex, say_fill_dcomplex
d316 1
d361 1
a361 1
    & myLaconic, myRatios, myRMS, myShape, myStats, &
d1934 1
d3064 1
d3081 1
d3129 2
d3328 1
a3328 1
       "$Id: dump_0.f90,v 2.122 2012/06/22 20:25:52 pwagner Exp $"
d3338 3
@


2.122
log
@Specify advance arg because we may now set default to 'yes'
@
text
@d85 1
d126 1
d201 1
a201 1
    & DUMPSUMS, DUMPTABLE, SELFDIFF
d2752 21
a2772 2
  
  ! ------------------------------------------------------  Empty  -----
d3321 1
a3321 1
       "$Id: dump_0.f90,v 2.121 2012/06/13 23:59:37 pwagner Exp $"
d3331 3
@


2.121
log
@dumpDumpOptions optionally dumps available diff/dump options
@
text
@d760 2
a761 2
            call output ( ' ' )
            call output ( numZeroRows )
d763 1
a763 1
            call output ( myFillValue )
d827 1
a827 1
              call output ( array(k)(1:lon) // ' ' )
d1003 2
a1004 2
        call output( k+1 )
        call output ( ' through ')
d1021 2
a1022 2
          call output ( j+base, max(4,ilog10(size(array))+1) )
          call output ( afterSub )
d1025 1
a1025 1
          call output ( array(k) )
d1120 1
a1120 1
                call output ( array(i,k)(1:lon) // ' ' )
d1314 3
a1316 3
            call output ( i, places=max(4,ilog10(size(array,1))+1) )
            call output ( j, places=max(4,ilog10(size(array,2))+1) )
            call output ( afterSub )
d1319 1
a1319 1
            call output ( array(i,k) )
d1383 2
a1384 2
          call output ( j, max(3,ilog10(size(array))+1) )
          call output ( afterSub )
d1386 1
a1386 1
        call output ( array(1,1,j), myFormat )
d1389 1
a1389 1
        call output ( array(2,1,j), myFormat )
d1421 2
a1422 2
          call output ( j, max(3,ilog10(size(array))+1) )
          call output ( afterSub )
d1424 1
a1424 1
        call output ( array(1,1,j), myFormat )
d1427 1
a1427 1
        call output ( array(2,1,j), myFormat )
d1496 1
a1496 1
                  call output ( array(i,j,l)(1:lon) // ' ' )
d2014 2
a2015 2
      call output ( n1, places=max(4,ilog10(size(array,2)+1)) )
      call output ( afterSub )
d2069 2
a2070 2
      call output ( n1, places=max(4,ilog10(size(array,2)+1)) )
      call output ( afterSub )
d2772 2
a2773 2
      call output ( name )
      call output ( ' is ' )
d2796 2
a2797 2
        call output ( name )
        if ( present(theShape) ) call output ( theShape )
d2802 1
a2802 1
        call output ( size )
d2804 1
a2804 1
      if ( size == 1 ) call output ( ' ' )
d2969 2
a2970 2
    call output ( ' ' )
    call output ( numZeroRows )
d2979 1
a2979 1
      call output ( subs(i), places=max(4,ilog10(subs(i+1))+1) )
d2981 1
a2981 1
    call output ( afterSub )
d3300 1
a3300 1
       "$Id: dump_0.f90,v 2.120 2012/01/09 22:25:55 pwagner Exp $"
d3310 3
@


2.120
log
@Distinguish 'r' option to print rms of ratios and 'R' option for rms of values
@
text
@d106 1
a106 1
! dumpDumpOptions
d123 1
a123 1
!       format optioanally overrides the default format for the numeric type
d1887 4
a1890 1
    ! Show dump, diff options
d1920 28
d3300 1
a3300 1
       "$Id: dump_0.f90,v 2.119 2011/12/15 01:47:45 pwagner Exp $"
d3310 3
@


2.119
log
@Accepts W[i] option; deletes more prolix notices of rank reduction
@
text
@d35 1
a35 1
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_WARNING
d165 1
d170 1
a170 1
!       r              rms       -- min, max, etc. of differences
d180 1
a180 1
! if all {Hlrs} are FALSE, i.e. unset, the whole array is dumped (or diffed)
d313 2
a314 1
  character, public, parameter :: dopt_rms         = 'r'
d357 1
a357 1
    & myLaconic, myRMS, myShape, myStats, &
d1930 2
d3010 1
d3025 1
d3036 1
a3036 1
      & .not. (myBandwidth.or. myCollapse .or. myRMS .or. myShape .or. myStats &
d3039 1
a3039 1
      & .not. (myBandwidth.or. myCollapse .or. myRMS .or. myShape .or. myStats &
d3269 1
a3269 1
       "$Id: dump_0.f90,v 2.118 2011/12/07 01:14:44 pwagner Exp $"
d3279 3
@


2.118
log
@Added option to show bandwidth of banded arrays
@
text
@d24 3
d40 4
a43 2
  use MLSSTRINGLISTS, only: CATLISTS, GETSTRINGELEMENT, NUMSTRINGELEMENTS
  use MLSSTRINGS, only: DELETE, INDEXES, LOWERCASE, TRIM_SAFE, &
a64 2
! DUMPDATES                dump 1-d array of tai93 (s. after 1 jan 1993)
! DUMPLISTS                dump 2-d array as a set of lists
d78 1
d80 1
d175 1
d357 1
d360 1
a360 1
  integer :: bwidth, myRank, numNonFill, numFill
d1058 1
a1058 1
    & OPTIONS )
d1065 1
d1092 1
a1092 1
      call name_and_size ( name, myClean, 1 )
d1133 1
a1133 1
    & FILLVALUE, OPTIONS, LBOUND )
d1142 1
d1178 1
a1178 1
    & FILLVALUE, OPTIONS, LBOUND )
d1187 1
d1224 1
a1224 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
d1232 1
d1254 1
a1254 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
d1262 1
d1283 1
a1283 1
  recursive subroutine DUMP_2D_LOGICAL ( ARRAY, NAME, OPTIONS )
d1287 1
d1302 1
a1302 1
      call name_and_size ( name, myClean, 1 )
d1328 1
a1328 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
d1336 1
d1433 2
a1434 1
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, FILLVALUE, WIDTH, MAXLON, OPTIONS )
d1438 1
d1441 1
a1441 1
    integer, intent(in), optional :: WIDTH
d1444 1
a1444 1
    integer :: I, J, K, L
d1510 1
a1510 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
d1519 1
d1521 1
a1521 1
    integer :: I, J, K, L
d1545 1
a1545 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
d1554 1
d1556 1
a1556 1
    integer :: I, J, K, L
d1580 1
a1580 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
d1588 1
d1590 1
a1590 1
    integer :: I, J, K, L
d1605 1
a1605 1
    & FILLVALUE, FORMAT, WIDTH, LBOUND, OPTIONS )
d1613 1
d1615 1
a1615 1
    integer :: I, J, K, L
d1633 1
a1633 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
d1641 1
d1643 1
a1643 1
    integer :: I, J, K, L
d3263 1
a3263 1
       "$Id: dump_0.f90,v 2.117 2011/11/11 00:30:22 vsnyder Exp $"
d3273 3
@


2.117
log
@Simplify notice of rank reduction
@
text
@d28 1
a28 1
  use MLSFILLVALUES, only : COLLAPSE, FILTERVALUES, HALFWAVES, &
d157 1
d300 1
d348 2
a349 2
  logical :: myClean, myCollapse, myCyclic, myDirect, myGaps, myLaconic, &
    & myRMS, myShape, myStats, &
d353 2
a354 1
  integer :: myRank, numNonFill, numFill
d2978 1
d2991 1
a2991 2
    myWholeArray = theDefault('wholearray') .or. &
        & .not. (myStats .or. myRMS .or. myTable .or. myShape )
d2993 1
d3006 1
a3006 2
      myWholeArray  = ( index( options, dopt_wholearray ) > 0 ) .or. &
        & .not. (myCollapse .or. myStats .or. myRMS.or. myTable .or. myShape )
d3008 3
d3012 2
a3013 1
      & .not. (myCollapse .or. myRMS .or. myStats .or. myTable .or. myShape)
d3242 1
a3242 1
       "$Id: dump_0.f90,v 2.116 2011/07/26 20:40:24 pwagner Exp $"
d3252 3
@


2.116
log
@Added 4d diffs, too
@
text
@d157 1
a157 1
!       H              show rank, shape of array
d763 2
a764 1
  subroutine DUMP_1D_CHAR ( ARRAY, NAME, FILLVALUE, WIDTH, OPTIONS, MAXLON )
d768 2
a769 1
    character(len=*), optional, intent(in) :: options
d771 1
a771 1
    integer, intent(in), optional :: WIDTH
d789 1
a789 1
    elseif ( .not. myTrim ) then
d791 1
a791 1
    endif
d797 1
a797 1
      call name_and_size ( name, myClean, 1 )
d829 1
a829 1
    & FILLVALUE, LBOUND, OPTIONS )
d837 2
a838 1
    character(len=*), optional, intent(in) :: options
d862 1
a862 1
    & FILLVALUE, LBOUND, OPTIONS )
d870 2
a871 1
    character(len=*), optional, intent(in) :: options
d895 1
a895 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
d902 3
a904 1
    character(len=*), optional, intent(in) :: options
d941 1
a941 1
    & FILLVALUE, FORMAT, WIDTH, LBOUND, OPTIONS )
d948 3
a950 1
    character(len=*), optional, intent(in) :: options
d965 1
a965 1
  subroutine DUMP_1D_LOGICAL ( ARRAY, NAME, LBOUND, OPTIONS )
d969 2
a970 1
    character(len=*), optional, intent(in) :: options
d1023 1
a1023 1
    & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
d1030 3
a1032 1
    character(len=*), optional, intent(in) :: options
d1122 1
a1122 1
    & FILLVALUE, OPTIONS )
d1130 1
d1132 1
a1132 1
    integer :: I, J, K
d1158 3
d1165 2
a1166 1
  recursive subroutine DUMP_2D_DCOMPLEX ( ARRAY, NAME, WIDTH, FORMAT, FILLVALUE, OPTIONS )
d1174 1
d1176 1
a1176 1
    integer :: I, J, K
d1203 3
d1217 1
a1217 1
    integer, intent(in), optional :: LBOUND
d1220 1
a1220 1
    integer :: I, J, K
d1228 1
d1230 4
d1246 1
a1246 1
    integer, intent(in), optional :: LBOUND
d1249 1
a1249 1
    integer :: I, J, K
d1257 1
d1259 4
d1321 1
a1321 1
    integer :: I, J, K
d1329 1
d1331 4
d2728 1
a2728 1
  subroutine Name_And_Size ( Name, Clean, Size )
d2732 1
d2736 4
a2739 1
      if ( .not. nameHasBeenPrinted ) call output ( name )
d2988 1
a2988 1
        & .not. (myStats .or. myRMS.or. myTable .or. myShape )
d3235 1
a3235 1
       "$Id: dump_0.f90,v 2.114 2011/07/15 23:23:43 pwagner Exp $"
d3245 3
d3301 1
a3301 1
! Added new option H or 'shape' to just show array rank, shape
@


2.115
log
@Use (1.,0.) instead of CMPLX(1.,0.) to avoid Intel gripe
@
text
@d197 1
d208 1
d285 1
d322 1
d579 90
d1825 1
a1825 1
  subroutine DumpDumpOptions
d1827 1
d1829 43
a1871 26
     call blanks(90, fillChar='-', advance='yes')
     call output(' ------------------------ Summary of automatic Dump, Diff options'      , advance='no')
     call output(' ------------------------ ', advance='yes')
     call outputNamedValue ( 'character printed between row, col id and data', aftersub, advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call outputNamedValue ( 'default DIFF switches for CLEAN, TRIM, etc.', trim_safe(DEFAULTDIFFOPTIONS), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call outputNamedValue ( 'default DUMP switches for CLEAN, TRIM, etc.', trim_safe(DEFAULTDUMPOPTIONS), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call outputNamedValue ( 'print abs min, max, etc. when DIFF has RMS set TRUE?', DIFFRMSMEANSRMS, advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call outputNamedValue ( 'skip dumping every element of a constant array?', DIFFRMSMEANSRMS, advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call outputNamedValue ( 'what side to place headers when dumping tables', trim(DUMPTABLESIDE), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call outputNamedValue ( 'print stats all on one line?', STATSONONELINE, advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call outputNamedValue ( 'pct output format', trim_safe(PCTFORMAT), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call outputNamedValue ( 'rms output format', trim_safe(RMSFORMAT), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call outputNamedValue ( 'numeric output format', trim_safe(SDFORMATDEFAULT), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call outputNamedValue ( 'complex output format', trim_safe(sdFormatDefaultCmplx), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=90 )
     call blanks(90, fillChar='-', advance='yes')
d2620 36
d2757 1
a2757 1
  subroutine printPercentages ( name, equal, unequal  )
d3153 30
d3206 3
@


2.114
log
@Can now dump 4d arrays, with certain restrictions
@
text
@d351 1
a351 1
  complex, parameter :: one_c4 = CMPLX(1., 0.)
d3018 1
a3018 1
       "$Id: dump_0.f90,v 2.113 2011/07/12 00:15:01 pwagner Exp $"
d3028 3
@


2.113
log
@Improved dumps; format option now more flexible; complex arrays parallel real ones
@
text
@d219 1
d1503 48
d3018 1
a3018 1
       "$Id: dump_0.f90,v 2.112 2011/06/23 17:27:41 pwagner Exp $"
d3028 3
@


2.112
log
@Added function to difference args with option to supply fillvalue or period
@
text
@d24 2
a25 2
  use BitStuff, only: MAXBITNUMBER, WHICHBITSARESET
  use dates_module, only: MAXUTCSTRLENGTH, &
d27 2
a28 2
  use ieee_arithmetic, only: IEEE_IS_FINITE
  use MLSFillValues, only : COLLAPSE, FILTERVALUES, HALFWAVES, &
d32 3
a34 3
  use MLSMessageModule, only: MLSMessage, MLSMSG_Warning
  use MLSSets, only: FindUnique
  use MLSStats1, only: STAT_T, &
d37 2
a38 2
  use MLSStringLists, only: catLists, GetStringElement, NumStringElements
  use MLSStrings, only: DELETE, INDEXES, LOWERCASE, TRIM_SAFE, &
d41 2
a42 1
    & ALIGNTOFIT, BLANKS, BLANKSTOTAB, DUMPTABS, NEWLINE, NUMTOCHARS, &
d44 1
a44 1
  use Time_M, only: Time_Now
d127 25
d154 1
d176 10
d266 1
d274 2
a275 1
    module procedure say_fill_char, say_fill_double, say_fill_int, say_fill_real
d350 1
d710 2
a711 1
            call say_fill ( (/ j-1, size(array) /), numZeroRows, myFillValue, inc=1 )
d724 2
a725 1
      call say_fill ( (/ j-MyWidth, size(array) /), numZeroRows, myFillValue )
d732 1
a732 1
    & FILLVALUE, OPTIONS )
d739 1
d744 5
a748 1

d750 1
a752 1
    myFormat = sdFormatDefaultCmplx
d754 4
d759 1
a759 20
    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1), myFormat, advance='yes' )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do j = 1, size(array), myWidth
        if (.not. myClean) then
          call output ( j, max(myWidth-1,ilog10(size(array))+1) )
          call output ( afterSub )
        end if
        do k = j, min(j+myWidth-1, size(array))
          call output ( array(k), myFormat )
        end do
        call newLine
      end do
    end if
    call theDumpEnds
d762 1
a762 1
  ! -------------------------------------------  DUMP_1D_DCOMPLEX  -----
d764 1
a764 1
    & FILLVALUE, OPTIONS )
d771 1
d776 5
a780 1

d782 1
a784 1
    myFormat = sdFormatDefaultCmplx
d786 4
d791 1
a791 20
    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1), myFormat, advance='yes' )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do j = 1, size(array), myWidth
        if (.not. myClean) then
          call output ( j, max(myWidth-1,ilog10(size(array))+1) )
          call output ( afterSub )
        end if
        do k = j, min(j+myWidth-1, size(array))
          call output ( array(k), myFormat )
        end do
        call newLine
      end do
    end if
    call theDumpEnds
d814 1
d858 1
d937 1
d1028 1
a1028 1
    real :: MyFillValue
d1030 1
d1032 1
a1043 1
    myFormat = sdFormatDefaultCmplx
d1045 2
d1051 1
a1051 43
    numZeroRows = 0
    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else if ( product(shape(array)) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1), format=myFormat, advance='yes' )
    else if ( size(array, 1) == 1 ) then
      call dump ( array(1,:), name, &
        & fillValue=fillValue, format=format, options=options )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1), name, &
        & fillValue=fillValue, format=format, options=options )
    else 
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do i = 1, size(array,1)
        do j = 1, size(array,2), myWidth
          DumpTheseZeros = myClean .or. &
            & any(array(i,j:min(j+2*MyWidth-1, size(array,2))) /= myFillValue) &
            & .or. &
            & ( j+MyWidth >= size(array,2) .and. &
            & any(array(min(i+1, size(array,1)),1:min(1+MyWidth-1, size(array,2))) &
            & /= myFillValue) &
            & )
          if (.not. myClean) then
            if ( DumpTheseZeros ) then
              call say_fill ( (/ i, size(array,1), j-1, size(array,2) /), &
                & numZeroRows, myFillValue, inc=3 )
            else
              numZeroRows = numZeroRows + 1
            end if
          end if
          if ( DumpTheseZeros ) then
            do k = j, min(j+myWidth-1, size(array,2))
              call output ( array(i,k), myFormat )
            end do
            call newLine
            numZeroRows = 0
          end if
        end do
      end do
    end if
    call theDumpEnds
d1067 1
a1067 1
    real(rk) :: MyFillValue
d1070 3
a1083 1
    myFormat = sdFormatDefaultCmplx
d1085 2
d1091 1
a1091 43
    numZeroRows = 0
    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else if ( product(shape(array)) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1), format=myFormat, advance='yes' )
    else if ( size(array, 1) == 1 ) then
      call dump ( array(1,:), name, &
        & fillValue=fillValue, format=format, options=options )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1), name, &
        & fillValue=fillValue, format=format, options=options )
    else 
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do i = 1, size(array,1)
        do j = 1, size(array,2), myWidth
          DumpTheseZeros = myClean .or. &
            & any(array(i,j:min(j+2*MyWidth-1, size(array,2))) /= myFillValue) &
            & .or. &
            & ( j+MyWidth >= size(array,2) .and. &
            & any(array(min(i+1, size(array,1)),1:min(1+MyWidth-1, size(array,2))) &
            & /= myFillValue) &
            & )
          if (.not. myClean) then
            if ( DumpTheseZeros ) then
              call say_fill ( (/ i, size(array,1), j-1, size(array,2) /), &
                & numZeroRows, myFillValue, inc=3 )
            else
              numZeroRows = numZeroRows + 1
            end if
          end if
          if ( DumpTheseZeros ) then
            do k = j, min(j+myWidth-1, size(array,2))
              call output ( array(i,k), myFormat )
            end do
            call newLine
            numZeroRows = 0
          end if
        end do
      end do
    end if
    call theDumpEnds
d1115 1
d1139 1
d1206 1
d1224 2
d1262 2
d1362 2
a1363 1
    complex, intent(in) :: ARRAY(:,:,:)
d1373 1
a1373 1
    real    :: myFillValue
d1378 1
a1382 1
    myFormat = sdFormatDefaultCmplx
d1384 2
d1387 1
a1387 1
    MyWidth = 5
d1390 1
a1390 47
    numZeroRows = 0
    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else if ( size(array,1) == 1 ) then
      call dump ( array(1,:,:), name, &
        & fillValue=fillValue, format=format, options=options )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1,:), name, &
        & fillValue=fillValue, format=format, options=options )
    else if ( size(array,3) == 1 ) then
      call dump ( array(:,:,1), name, &
        & fillValue=fillValue, format=format, options=options )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do i = 1, size(array,1)
        do j = 1, size(array,2)
          do k = 1, size(array,3), myWidth
            DumpTheseZeros = myClean .or. &
              & any(array(i,j,k:min(k+2*MyWidth-1, size(array,3))) /= myFillValue) &
              & .or. &
              & ( k+MyWidth >= size(array,3) .and. &
              & any(array(i,min(j+1, size(array,2)),1:min(1+MyWidth-1, size(array,3))) &
              & /= myFillValue) &
              & )
            if (.not. myClean) then
              if ( DumpTheseZeros ) then
                call say_fill ( (/ i, size(array,1), j-1, size(array,2), &
                  & k, size(array,3) /), numZeroRows, myFillValue, inc=3 )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( DumpTheseZeros ) then
              do l = k, min(k+myWidth-1, size(array,3))
                call output ( array(i,j,l), myFormat )
              end do
              call newLine
              numZeroRows = 0
            endif
          end do
        end do
      end do
      call say_fill ( (/ i-1, size(array,1), j-1, size(array,2), &
        & k-myWidth, size(array,3) /), numZeroRows, myFillValue )
   end if
    call theDumpEnds
d1407 1
a1407 1
    real(rk)    :: myFillValue
d1412 1
a1416 1
    myFormat = sdFormatDefaultCmplx
d1418 4
a1421 1
    MyWidth = 5
d1424 1
a1424 47
    numZeroRows = 0
    if ( any(shape(array) == 0) ) then
      call empty ( name )
    else if ( size(array,1) == 1 ) then
      call dump ( array(1,:,:), name, &
        & fillValue=fillValue, format=format, options=options )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1,:), name, &
        & fillValue=fillValue, format=format, options=options )
    else if ( size(array,3) == 1 ) then
      call dump ( array(:,:,1), name, &
        & fillValue=fillValue, format=format, options=options )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) .and. .not. mylaconic ) call newLine
      do i = 1, size(array,1)
        do j = 1, size(array,2)
          do k = 1, size(array,3), myWidth
            DumpTheseZeros = myClean .or. &
              & any(array(i,j,k:min(k+2*MyWidth-1, size(array,3))) /= myFillValue) &
              & .or. &
              & ( k+MyWidth >= size(array,3) .and. &
              & any(array(i,min(j+1, size(array,2)),1:min(1+MyWidth-1, size(array,3))) &
              & /= myFillValue) &
              & )
            if (.not. myClean) then
              if ( DumpTheseZeros ) then
                call say_fill ( (/ i, size(array,1), j-1, size(array,2), &
                  & k, size(array,3) /), numZeroRows, myFillValue, inc=3 )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( DumpTheseZeros ) then
              do l = k, min(k+myWidth-1, size(array,3))
                call output ( array(i,j,l), myFormat )
              end do
              call newLine
              numZeroRows = 0
            endif
          end do
        end do
      end do
      call say_fill ( (/ i-1, size(array,1), j-1, size(array,2), &
        & k-myWidth, size(array,3) /), numZeroRows, myFillValue )
   end if
    call theDumpEnds
d1448 1
d1475 1
d1499 1
d2519 1
a2519 1
  subroutine PrintIt_char (it)
d2521 1
d2525 1
a2525 1
  subroutine PrintIt_int (it)
d2527 2
a2528 1
    call output ( it, advance='no' )
d2531 1
a2531 1
  subroutine PrintIt_real (it)
d2533 2
a2534 1
    call output ( it, advance='no' )
d2537 1
a2537 1
  subroutine PrintIt_double (it)
d2539 2
a2540 1
    call output ( it, advance='no' )
d2543 14
d2632 1
a2632 1
  subroutine Say_Fill_Char ( Subs, NumZeroRows, Fill, Inc  )
d2637 14
d2652 1
a2652 1
  subroutine Say_Fill_Double ( Subs, NumZeroRows, Fill, Inc )
d2658 1
a2658 1
  subroutine Say_Fill_Int ( Subs, NumZeroRows, Fill, Inc )
d2664 1
a2664 1
  subroutine Say_Fill_Real ( Subs, NumZeroRows, Fill, Inc )
d2969 1
a2969 1
       "$Id: dump_0.f90,v 2.111 2011/04/26 20:54:12 pwagner Exp $"
d2979 3
@


2.111
log
@Can now dump dates
@
text
@d71 1
d83 1
d152 1
a152 1
  public :: DIFF, &
d162 4
d258 1
d302 1
a302 1
  logical :: myClean, myCollapse, myDirect, myGaps, myLaconic, &
d534 40
d2837 1
d2852 1
d2890 2
d3065 1
a3065 1
       "$Id: dump_0.f90,v 2.110 2011/04/20 22:27:09 pwagner Exp $"
d3075 3
@


2.110
log
@Fixed long-standing bug in dumping 2d char array
@
text
@d25 2
d59 1
d97 1
d151 1
a151 1
    & DUMP, DUMP_2x2xN, DUMPDUMPOPTIONS, DUMPLISTS, DUMPNAMEDVALUES, &
d191 4
d1711 51
d3014 1
a3014 1
       "$Id: dump_0.f90,v 2.109 2011/04/18 19:12:54 vsnyder Exp $"
d3024 3
@


2.109
log
@Turn on nameHasBeenPrinted in more places
@
text
@d31 1
a31 1
  use MLSSets, only: FindAll, FindUnique
d542 1
a542 1
    if ( size(array) == 0 ) then
d602 1
a602 1
    if ( size(array) == 0 ) then
d634 2
a635 1
  subroutine DUMP_1D_COMPLEX ( ARRAY, NAME, WIDTH, FORMAT, OPTIONS )
d641 1
d653 1
a653 1
    if ( size(array) == 0 ) then
d676 2
a677 1
  subroutine DUMP_1D_DCOMPLEX ( ARRAY, NAME, WIDTH, FORMAT, OPTIONS )
d683 1
d695 1
a695 1
    if ( size(array) == 0 ) then
d796 1
a796 1
    if ( size(array) == 0 ) then
d892 1
a892 1
    if ( size(array) == 0 ) then
d894 1
a894 1
    else if ( size(array) == 1 ) then
d896 1
a896 1
      call output ( array(1,1)(1:lon), advance='yes' )
d913 2
a914 2
              call say_fill ( (/ i-1, size(array,1), j, size(array,2) /), &
                & numZeroRows, myFillValue, inc=1 )
d920 1
a920 1
            do k = j, min(myWidth-1, size(array,2))
d969 1
a969 1
    if ( size(array) == 0 ) then
d971 1
a971 1
    else if ( size(array) == 1 ) then
d974 3
d978 2
a979 1
      call dump ( array(:,1), name, format=myFormat, options=options )
d981 1
a981 1
    call name_and_size ( name, myClean, size(array) )
d1047 1
a1047 1
    if ( size(array) == 0 ) then
d1049 1
a1049 1
    else if ( size(array) == 1 ) then
d1052 3
d1056 2
a1057 1
      call dump ( array(:,1), name, format=myFormat, options=options )
d1153 1
a1153 1
    if ( size(array) == 0 ) then
d1219 1
a1219 1
    if ( size(array) == 0 ) then
d1255 1
a1255 1
    if ( size(array) == 0 ) then
a1286 2
    integer, dimension(3) :: which, re_mainder
    integer :: how_many
a1298 2
    call FindAll( (/ size(array, 1), size(array, 2), size(array, 3)/), &
      & 1, which, how_many, re_mainder=re_mainder)
d1301 1
a1301 1
    if ( size(array) == 0 ) then
d1303 8
a1310 5
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1,1)(1:lon), advance='yes' )
    else if ( how_many == 2 ) then
      call dump ( reshape(array, (/ re_mainder(1) /)), name, fillValue=fillValue, &
a1311 3
    else if ( how_many == 1 ) then
      call dump ( reshape(array, (/ re_mainder(1), re_mainder(2) /)), &
        & name, fillValue=fillValue, options=options, width=width )
d1378 1
a1378 1
    if ( size(array) == 0 ) then
d1380 6
a1385 5
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1,1), myFormat, advance='yes' )
    else if ( size(array,2) == 1 .and. size(array,3) == 1 ) then
      call dump ( array(:,1,1), name, options=options )
d1387 2
a1388 1
      call dump ( array(:,:,1), name, fillValue=fillValue, options=options )
d1421 1
a1421 1
        & k-5, size(array,3) /), numZeroRows, myFillValue )
d1455 1
a1455 1
    if ( size(array) == 0 ) then
d1457 6
a1462 5
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1,1), myFormat, advance='yes' )
    else if ( size(array,2) == 1 .and. size(array,3) == 1 ) then
      call dump ( array(:,1,1), name, options=options )
d1464 2
a1465 1
      call dump ( array(:,:,1), name, fillValue=fillValue, options=options )
d1498 1
a1498 1
        & k-5, size(array,3) /), numZeroRows, myFillValue )
d2955 1
a2955 1
       "$Id: dump_0.f90,v 2.108 2011/04/04 23:08:27 pwagner Exp $"
d2965 3
@


2.108
log
@May diff 2d integer arrays
@
text
@d2493 1
d2520 1
d2943 1
a2943 1
       "$Id: dump_0.f90,v 2.107 2011/03/08 00:04:40 pwagner Exp $"
d2953 3
@


2.107
log
@Skip printing row of zeros only if multiple
@
text
@d152 1
a152 1
    module procedure DIFF_2D_DOUBLE, DIFF_2D_REAL
d158 1
a158 1
    module procedure FILTEREDDIFF_2D_DOUBLE, FILTEREDDIFF_2D_REAL
d227 1
a227 1
    module procedure UNFILTEREDDIFF_2D_DOUBLE, UNFILTEREDDIFF_2D_REAL
d389 26
d2392 23
d2862 21
d2941 1
a2941 1
       "$Id: dump_0.f90,v 2.106 2011/02/25 18:50:26 pwagner Exp $"
d2951 3
@


2.106
log
@Added optional width arg to char array dumps
@
text
@d285 2
d585 2
d588 1
a588 1
          if ( any(array(j:min(j+MyWidth-1, size(array))) /= myFillValue) ) then
d594 1
a594 1
        if ( myClean .or. any(array(j:min(j+MyWidth-1, size(array))) /= myFillValue) ) then
d599 1
d831 2
a832 1
  subroutine DUMP_2D_CHAR ( ARRAY, NAME, FILLVALUE, WIDTH, MAXLON, OPTIONS )
d847 6
d874 7
d882 1
a882 1
            if ( any(array(i,j:min(j+MyWidth-1, size(array,2))) /= myFillValue) ) then
d889 1
a889 1
          if ( myClean .or. any(array(i,j:min(j+MyWidth-1, size(array,2))) /= myFillValue) ) then
d894 1
d905 2
a906 1
  subroutine DUMP_2D_COMPLEX ( ARRAY, NAME, WIDTH, FORMAT, FILLVALUE, OPTIONS )
d922 6
d947 13
a959 27
      call name_and_size ( name, myClean, size(array) )
      if ( .not. myTranspose ) then
        if ( present(name) .and. .not. mylaconic ) call newLine
        do i = 1, size(array,1)
          do j = 1, size(array,2), myWidth
            if (.not. myClean) then
              if ( any(array(i,j:min(j+myWidth-1, size(array,2))) /= myFillValue) ) then
                call say_fill ( (/ i, size(array,1), j-1, size(array,2) /), &
                  & numZeroRows, myFillValue, inc=3 )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( myClean .or. any(array(i,j:min(j+myWidth-1, size(array,2))) /= myFillValue) ) then
              do k = j, min(j+myWidth-1, size(array,2))
                call output ( array(i,k), myFormat )
              end do
              call newLine
            end if
          end do
        end do
      else ! Dump the transpose
        if ( present(name) ) call output ( ' ' )
        call output ( '(transposed)', advance='yes' )
        do j = 1, size(array,2)
          do i = 1, size(array,1), myWidth
            if ( any(array(i:min(i+myWidth-1, size(array,1)),j) /= myFillValue) ) then  
d962 11
a972 10
            else                                                            
              numZeroRows = numZeroRows + 1                                 
            end if                                                          
            if ( myClean .or. any(array(i:min(i+myWidth-1, size(array,1)),j) /= myFillValue) ) then
              do k = i, min(i+myWidth-1, size(array,1))
                call output ( array(k,j), myFormat )
              end do
              call newLine
            end if                                                          
          end do
d974 1
a974 1
      end if
d979 2
a980 2
  ! --------------------------------------------  DUMP_2D_COMPLEX  -----
  subroutine DUMP_2D_DCOMPLEX ( ARRAY, NAME, WIDTH, FORMAT, FILLVALUE, OPTIONS )
d996 6
d1022 12
a1033 26
      if ( .not. myTranspose ) then
        if ( present(name) .and. .not. mylaconic ) call newLine
        do i = 1, size(array,1)
          do j = 1, size(array,2), myWidth
            if (.not. myClean) then
              if ( any(array(i,j:min(j+myWidth-1, size(array,2))) /= myFillValue) ) then
                call say_fill ( (/ i, size(array,1), j-1, size(array,2) /), &
                  & numZeroRows, myFillValue, inc=3 )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( myClean .or. any(array(i,j:min(j+myWidth-1, size(array,2))) /= myFillValue) ) then
              do k = j, min(j+myWidth-1, size(array,2))
                call output ( array(i,k), myFormat )
              end do
              call newLine
            end if
          end do
        end do
      else ! Dump the transpose
        if ( present(name) ) call output ( ' ' )
        call output ( '(transposed)', advance='yes' )
        do j = 1, size(array,2)
          do i = 1, size(array,1), myWidth
            if ( any(array(i:min(i+myWidth-1, size(array,1)),j) /= myFillValue) ) then  
d1036 2
a1037 8
            else                                                            
              numZeroRows = numZeroRows + 1                                 
            end if                                                          
            if ( myClean .or. any(array(i:min(i+myWidth-1, size(array,1)),j) /= myFillValue) ) then
              do k = i, min(i+myWidth-1, size(array,1))
                call output ( array(k,j), myFormat )
              end do
              call newLine
d1039 8
a1046 1
          end do
d1048 1
a1048 1
      end if
d1069 1
d1100 1
a1100 1
  subroutine DUMP_2D_LOGICAL ( ARRAY, NAME, OPTIONS )
d1109 5
d1158 1
d1284 7
d1292 1
a1292 1
              if ( any(array(i,j,k:min(k+MyWidth-1, size(array,3))) /= myFillValue) ) then
d1299 1
a1299 1
            if ( myClean .or. any(array(i,j,k:min(k+MyWidth-1, size(array,3))) /= myFillValue) ) then
d1304 1
d1330 1
d1339 3
d1358 8
a1365 1
          do k = 1, size(array,3), 5
d1367 1
a1367 1
              if ( any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
d1374 2
a1375 2
            if ( myClean .or. any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
              do l = k, min(k+4, size(array,3))
d1379 1
d1406 1
d1415 2
d1433 8
a1440 1
          do k = 1, size(array,3), 5
d1442 1
a1442 1
              if ( any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
d1449 2
a1450 2
            if ( myClean .or. any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
              do l = k, min(k+4, size(array,3))
d1454 1
d1481 1
d1507 1
d1530 1
d2463 1
a2463 1
      call output ( name )
d2871 1
a2871 1
       "$Id: dump_0.f90,v 2.105 2011/02/05 01:01:41 pwagner Exp $"
d2881 3
@


2.105
log
@Added new dopt_ dump options; transpose and collapse work better
@
text
@d18 5
d61 1
d545 1
a545 1
  subroutine DUMP_1D_CHAR ( ARRAY, NAME, FILLVALUE, OPTIONS, MAXLON )
d551 1
d557 1
d562 2
d582 1
a582 1
      do j = 1, size(array), 10
d584 1
a584 1
          if ( any(array(j:min(j+9, size(array))) /= myFillValue) ) then
d590 2
a591 2
        if ( myClean .or. any(array(j:min(j+9, size(array))) /= myFillValue) ) then
          do k = j, min(j+9, size(array))
d597 1
a597 1
      call say_fill ( (/ j-10, size(array) /), numZeroRows, myFillValue )
d826 1
a826 1
  subroutine DUMP_2D_CHAR ( ARRAY, NAME, FILLVALUE, MAXLON, OPTIONS )
d832 1
d838 1
d843 2
a844 1

d861 1
a861 1
        do j = 1, size(array,2), 10
d863 1
a863 1
            if ( any(array(i,j:min(j+9, size(array,2))) /= myFillValue) ) then
d870 2
a871 2
          if ( myClean .or. any(array(i,j:min(j+9, size(array,2))) /= myFillValue) ) then
            do k = j, min(j+9, size(array,2))
d878 1
a878 1
      call say_fill ( (/ i-1, size(array,1), j-10, size(array,2) /), &
d1224 1
a1224 1
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, FILLVALUE, MAXLON, OPTIONS )
d1230 1
d1238 1
d1247 2
d1260 1
a1260 1
        & maxlon=maxlon, options=options )
d1263 1
a1263 1
        & name, fillValue=fillValue, options=options )
d1269 1
a1269 1
          do k = 1, size(array,3), 10
d1271 1
a1271 1
              if ( any(array(i,j,k:min(k+9, size(array,3))) /= myFillValue) ) then
d1278 2
a1279 2
            if ( myClean .or. any(array(i,j,k:min(k+9, size(array,3))) /= myFillValue) ) then
              do l = k, min(k+9, size(array,3))
d1288 1
a1288 1
        & k-10, size(array,3) /), numZeroRows, myFillValue )
d1585 1
a1585 1
      call dump( (/ trim(string) /), name, fillvalue, options )
d1588 1
a1588 1
      call dump( (/ trim(string) /), name, fillvalue, options )
d2823 1
a2823 1
       "$Id: dump_0.f90,v 2.104 2011/01/20 01:16:01 pwagner Exp $"
d2833 3
@


2.104
log
@New '-l' option dumps collapsed representation of higher ranked array
@
text
@d31 2
a32 1
  use MLSStrings, only: INDEXES, LOWERCASE, TRIM_SAFE, WRITEINTSTOCHARS
d119 1
d124 2
a125 2
!       r              rms -- min, max, etc. of differences
!       s              stats -- number of differences
d231 1
a231 1
  ! These public parameters can be reconfigured outside the module
d235 13
a247 1

d279 2
a280 1
  logical :: myClean, myCollapse, myDirect, myGaps, myStats, myShape, myRMS, &
d571 1
a571 1
      if ( present(name) ) call output ( '', advance='yes' )
d584 1
a584 1
          call output ( '', advance='yes' )
d617 1
a617 1
      if ( present(name) ) call output ( '', advance='yes' )
d626 1
a626 1
        call output ( '', advance='yes' )
d657 1
a657 1
      if ( present(name) ) call output ( '', advance='yes' )
d666 1
a666 1
        call output ( '', advance='yes' )
d758 1
a758 1
      if ( present(name) ) call output ( '', advance='yes' )
d778 1
a778 1
      if ( present(name) ) call output ( '', advance='yes' )
d787 1
a787 1
        call output ( '', advance='yes' )
d846 1
a846 1
      if ( present(name) ) call output ( '', advance='yes' )
d861 1
a861 1
            call output ( '', advance='yes' )
d909 1
a909 1
        if ( present(name) ) call output ( '', advance='yes' )
d924 1
a924 1
              call output ( '', advance='yes' )
d943 1
a943 1
              call output ( '', advance='yes' )
d990 1
a990 1
        if ( present(name) ) call output ( '', advance='yes' )
d1005 1
a1005 1
              call output ( '', advance='yes' )
d1024 1
a1024 1
              call output ( '', advance='yes' )
d1034 1
a1034 1
  subroutine DUMP_2D_DOUBLE ( ARRAY, NAME, &
d1056 1
a1056 1
  subroutine DUMP_2D_INTEGER ( ARRAY, NAME, &
d1098 1
a1098 1
      if ( present(name) ) call output ( '', advance='yes' )
d1109 1
a1109 1
          call output ( '', advance='yes' )
d1117 1
a1117 1
  subroutine DUMP_2D_REAL ( ARRAY, NAME, &
d1158 1
a1158 1
      if ( present(name) ) call output ( '', advance='yes' )
d1194 1
a1194 1
      if ( present(name) ) call output ( '', advance='yes' )
d1249 1
a1249 1
      if ( present(name) ) call output ( '', advance='yes' )
d1265 1
a1265 1
              call output ( '', advance='yes' )
d1312 1
a1312 1
      if ( present(name) ) call output ( '', advance='yes' )
d1328 1
a1328 1
              call output ( '', advance='yes' )
d1376 1
a1376 1
      if ( present(name) ) call output ( '', advance='yes' )
d1392 1
a1392 1
              call output ( '', advance='yes' )
d1498 1
a1498 1
      if ( present(name) ) call output ( '', advance='yes' )
d1537 1
a1537 1
      if ( present(name) ) call output ( '', advance='yes' )
d1591 1
a1591 1
      if ( present(name) ) call output ( '', advance='yes' )
d1655 1
d1708 1
d2073 1
a2073 1
  subroutine DUMPCOLLAPSEDARRAY_1D_INTEGER (  array, name, fillValue )
d2077 1
d2081 1
a2081 1
  subroutine DUMPCOLLAPSEDARRAY_1D_DOUBLE (  array, name, fillValue )
d2085 1
d2089 1
a2089 1
  subroutine DUMPCOLLAPSEDARRAY_1D_REAL (  array, name, fillValue )
d2093 1
d2097 1
a2097 1
  subroutine DUMPCOLLAPSEDARRAY_2D_DOUBLE (  array, name, fillValue )
d2101 1
a2106 1
    ! call outputNamedValue( 'CollapseOptions', COLLAPSEOPTIONS )
d2109 1
a2109 1
      call dump( nums, name, fillvalue )
d2114 1
a2114 1
      call dump( logs, name )
d2118 1
a2118 1
  subroutine DUMPCOLLAPSEDARRAY_2D_REAL (  array, name, fillValue )
d2122 1
d2130 1
a2130 1
      call dump( nums, name, fillvalue )
d2135 1
a2135 1
      call dump( logs, name )
d2139 1
a2139 1
  subroutine DUMPCOLLAPSEDARRAY_2D_INTEGER (  array, name, fillValue )
d2143 1
d2151 1
a2151 1
      call dump( nums, name, fillvalue )
d2156 1
a2156 1
      call dump( logs, name )
d2160 1
a2160 1
  subroutine DUMPCOLLAPSEDARRAY_3D_DOUBLE (  array, name, fillValue )
d2164 1
d2172 1
a2172 1
      call dump( nums, name, fillvalue )
d2177 1
a2177 1
      call dump( logs, name )
d2181 1
a2181 1
  subroutine DUMPCOLLAPSEDARRAY_3D_REAL (  array, name, fillValue )
d2185 1
d2193 1
a2193 1
      call dump( nums, name, fillvalue )
d2198 1
a2198 1
      call dump( logs, name )
d2202 1
a2202 1
  subroutine DUMPCOLLAPSEDARRAY_3D_INTEGER (  array, name, fillValue )
d2206 1
d2214 1
a2214 1
      call dump( nums, name, fillvalue )
d2219 1
a2219 1
      call dump( logs, name )
d2396 1
a2396 1
    if ( present(name) ) then
d2585 12
d2604 1
d2615 12
a2626 11
      myClean       = index( options, 'c' ) > 0
      myCollapse    = index( options, 'l' ) > 0
      myGaps        = index( options, 'g' ) > 0
      myRMS         = index( options, 'r' ) > 0
      myShape       = index( options, 'H' ) > 0
      myStats       = index( options, 's' ) > 0
      myTable       = index( options, 'b' ) > 0
      myTranspose   = index( options, 'p' ) > 0
      myTrim        = index( options, 't' ) > 0
      myUnique      = index( options, 'u' ) > 0
      myWholeArray  = ( index( options, 'w' ) > 0 ) .or. &
d2631 1
d2653 1
a2653 1
      isit = index( defaultstring, 'c' ) > 0
d2655 1
a2655 1
      isit = index( defaultstring, 'd' ) > 0
d2657 3
a2659 1
      isit = index( defaultstring, 'g' ) > 0
d2661 1
a2661 1
      isit = index( defaultstring, 'r' ) > 0
d2663 1
a2663 1
      isit = index( defaultstring, 'H' ) > 0
d2665 1
a2665 1
      isit = index( defaultstring, 's' ) > 0
d2667 1
a2667 1
      isit = index( defaultstring, 'b' ) > 0
d2669 1
a2669 1
      isit = index( defaultstring, 'p' ) > 0
d2671 1
a2671 1
      isit = index( defaultstring, 't' ) > 0
d2673 1
a2673 1
      isit = index( defaultstring, 'u' ) > 0
d2675 2
a2676 1
      isit = index( defaultstring, 'w' ) > 0
d2806 1
a2806 1
       "$Id: dump_0.f90,v 2.103 2011/01/04 00:48:26 pwagner Exp $"
d2816 3
@


2.103
log
@DEFAULTMAXLON can now set max width of 1d char array dumps
@
text
@d19 6
a24 6
  use BitStuff, only: MAXBITNUMBER, WhichBitsAreSet
  use ieee_arithmetic, only: ieee_is_finite
  use MLSFillValues, only : FilterValues, HalfWaves, &
    & IsFinite, IsInfinite, IsNaN, &
    & InfFunction, NaNFunction, ReorderFillValues, ReplaceFillValues, &
    & WhereAreTheInfs, WhereAreTheNaNs
d45 2
d121 1
d131 3
a133 3
! if both {rms, stats} are FALSE or unset, the whole array is dumped (or diffed)
! if either or both is TRUE the whole array will be dumped only if
! wholearray is set to TRUE
d170 9
d247 3
d265 2
a266 2
  logical :: myClean, myDirect, myGaps, myStats, myShape, myRMS, myTable, &
    & myTranspose, myTrim, myUnique, myWholeArray, onlyWholeArray
d2053 146
d2565 1
d2578 1
d2588 1
a2588 1
        & .not. (myStats .or. myRMS.or. myTable .or. myShape )
d2591 1
a2591 1
      & .not. (myRMS .or. myStats .or. myTable .or. myShape)
d2763 1
a2763 1
       "$Id: dump_0.f90,v 2.102 2010/10/14 18:44:01 pwagner Exp $"
d2773 3
@


2.102
log
@Can now dump lists
@
text
@d227 1
d527 5
a531 1
    if ( present(maxlon) ) lon = min(lon, maxlon)
d2600 1
a2600 1
       "$Id: dump_0.f90,v 2.101 2010/02/04 23:05:39 vsnyder Exp $"
d2610 3
@


2.101
log
@Remove USE and declaration for unreferenced names.
Declare a kind parameter in unfiltereddiff*
@
text
@d31 4
a34 3
  use MLSStrings, only: indexes, lowercase, trim_safe
  use OUTPUT_M, only: outputOptions, stampOptions, &
    & ALIGNTOFIT, BLANKS, NEWLINE, NUMTOCHARS, OUTPUT, OUTPUTNAMEDVALUE
d49 1
d86 5
d135 2
a136 1
  public :: DIFF, DUMP, DUMP_2x2xN, DUMPDUMPOPTIONS, DUMPNAMEDVALUES, &
d144 1
d150 1
d162 1
d166 5
d175 1
d180 1
d186 1
d192 1
d196 1
d200 1
d204 1
d244 1
d1597 112
d2595 1
a2595 1
       "$Id: dump_0.f90,v 2.100 2010/01/29 21:08:21 pwagner Exp $"
d2605 4
@


2.101.2.1
log
@Can Read GEOS5.7.2 meteorology; based on v3.33
@
text
@a197 14
  ! These are the possible options to dumps, diffs
  character, public, parameter :: dopt_clean       = 'c'
  character, public, parameter :: dopt_collapse    = 'l'
  character, public, parameter :: dopt_cyclic      = 'y'
  character, public, parameter :: dopt_gaps        = 'g'
  character, public, parameter :: dopt_laconic     = 'L'
  character, public, parameter :: dopt_rms         = 'r'
  character, public, parameter :: dopt_shape       = 'H'
  character, public, parameter :: dopt_stats       = 's'
  character, public, parameter :: dopt_table       = 'b'
  character, public, parameter :: dopt_transpose   = 'p'
  character, public, parameter :: dopt_trim        = 't'
  character, public, parameter :: dopt_unique      = 'u'
  character, public, parameter :: dopt_wholearray  = 'w'
d2459 1
a2459 1
       "$Id: dump_0.f90,v 2.101 2010/02/04 23:05:39 vsnyder Exp $"
a2468 4
! Revision 2.101  2010/02/04 23:05:39  vsnyder
! Remove USE and declaration for unreferenced names.
! Declare a kind parameter in unfiltereddiff*
!
@


2.100
log
@gave myFillValue a value to stop lf95 complaints
@
text
@a20 1
  use MLSCommon, only: undefinedValue
d34 1
a34 1
  use Time_M, only: Time_Now, time_config
a1377 1
    integer :: MyWidth
d1379 1
a1379 1
    integer, dimension(3) :: which, re_mainder
d2337 2
a2338 1
    double precision, intent(in) :: ARRAY1(:)
d2340 1
a2340 1
    double precision, intent(in) :: ARRAY2(:)
a2346 3
    double precision, dimension(size(array1)) :: filtered1
    double precision, dimension(size(array2)) :: filtered2
    double precision :: refmin, refmax, refrms
d2373 2
a2374 1
    real, intent(in) :: ARRAY1(:)
d2376 1
a2376 1
    real, intent(in) :: ARRAY2(:)
a2382 3
    real, dimension(size(array1)) :: filtered1
    real, dimension(size(array2)) :: filtered2
    real :: refmin, refmax, refrms
d2388 2
a2389 1
    double precision, intent(in) :: ARRAY1(:,:)
d2391 1
a2391 1
    double precision, intent(in) :: ARRAY2(:,:)
d2397 1
a2397 2
    !
    double precision :: refmin, refmax, refrms
d2403 2
a2404 1
    real, intent(in) :: ARRAY1(:,:)
d2406 1
a2406 1
    real, intent(in) :: ARRAY2(:,:)
d2412 1
a2412 2
    !
    real :: refmin, refmax, refrms
d2418 2
a2419 1
    double precision, intent(in) :: ARRAY1(:,:,:)
d2421 1
a2421 1
    double precision, intent(in) :: ARRAY2(:,:,:)
a2427 1
    double precision :: refmin, refmax, refrms
d2433 2
a2434 1
    real, intent(in) :: ARRAY1(:,:,:)
d2436 1
a2436 1
    real, intent(in) :: ARRAY2(:,:,:)
a2442 1
    real :: refmin, refmax, refrms
d2459 1
a2459 1
       "$Id: dump_0.f90,v 2.99 2009/11/20 01:15:11 pwagner Exp $"
d2469 3
@


2.99
log
@Decided against using allFinite
@
text
@d652 1
d2465 1
a2465 1
       "$Id: dump_0.f90,v 2.98 2009/11/20 01:12:50 pwagner Exp $"
d2475 3
@


2.98
log
@Added new option H or 'shape' to just show array rank, shape
@
text
@d22 1
a22 1
  use MLSFillValues, only : allFinite, FilterValues, HalfWaves, &
d2464 1
a2464 1
       "$Id: dump_0.f90,v 2.97 2009/10/30 23:02:41 pwagner Exp $"
d2474 3
@


2.97
log
@Should not double-print name if only whole array diff
@
text
@d22 1
a22 1
  use MLSFillValues, only : FilterValues, HalfWaves, &
d109 1
d226 1
a226 1
  logical :: myClean, myDirect, myGaps, myStats, myRMS, myTable, &
d230 1
a230 1
  integer :: numNonFill, numFill
d652 1
d2178 3
d2266 1
d2273 1
a2273 1
        & .not. (myStats .or. myRMS.or. myTable)
d2278 1
d2285 1
a2285 1
        & .not. (myStats .or. myRMS.or. myTable)
d2288 1
a2288 1
      & .not. (myRMS .or. myStats .or. myTable)
d2313 2
d2317 2
d2321 4
d2327 2
d2464 1
a2464 1
       "$Id: dump_0.f90,v 2.96 2009/10/26 18:53:33 pwagner Exp $"
d2474 3
@


2.96
log
@Fixed bug only NAG found
@
text
@d118 1
a118 1
!                      
d226 1
a226 1
    & myTranspose, myTrim, myUnique, myWholeArray
d2262 1
d2273 1
d2280 2
d2301 1
a2301 1
    select case ( lowercase(code) )
d2447 1
a2447 1
       "$Id: dump_0.f90,v 2.95 2009/10/19 17:33:26 pwagner Exp $"
d2457 3
@


2.95
log
@Trying to prevent double-printing of name
@
text
@d225 1
a225 1
  logical :: myClean, myDirect, myFillValue, myGaps, myStats, myRMS, myTable, &
d650 1
d2443 1
a2443 1
       "$Id: dump_0.f90,v 2.94 2009/10/13 00:09:04 pwagner Exp $"
d2453 3
@


2.94
log
@Percentages printed with better format; dumpstats.f9h now a direct prerequisite
@
text
@d228 1
d2255 1
d2442 1
a2442 1
       "$Id: dump_0.f90,v 2.93 2009/09/10 20:58:00 pwagner Exp $"
d2452 3
@


2.93
log
@3 ways to summarize diffs: 'b' (table), 'r' (rms), 's' (number of differences)
@
text
@d205 5
a209 4
  logical, public, save ::   DIFFRMSMEANSRMS = .false.
  logical, public, save ::   DONTDUMPIFALLEQUAL = .true.
  logical, public, save ::   FILTERFILLSFROMRMS = .false.
  logical, public, save ::   STATSONONELINE = .true.
d634 18
d2111 20
a2130 18
      if ( present(name) ) call output ( trim(name), advance='no' )
      call blanks( 1, advance='no' )
      call output( fillvaluerelation, advance='no' )
      call output ( ', !', advance='no' )
      call output( fillvaluerelation, advance='no' )
      call output ( ' (%) ', advance='no' )
      call output ( equal, advance='no' )
      call output ( ': ', advance='no' )
      call output ( unequal, advance='no' )
      if ( .not. STATSONONELINE ) then
        call newline
        call blanks(10)
      endif
      call output ( '( ', advance='no' )
      call output ( 100*equal/(equal+unequal+0.), advance='no' )
      call output ( ': ', advance='no' )
      call output ( 100*unequal/(equal+unequal+0.), advance='no' )
      call output ( ' )', advance='yes' )
d2440 1
a2440 1
       "$Id: dump_0.f90,v 2.92 2009/08/18 20:41:17 pwagner Exp $"
d2450 3
@


2.92
log
@making INTPLACES public can change appearance of dumped ints
@
text
@d52 1
d109 1
d112 2
a113 2
!       r              rms       
!       s              stats     
d197 1
d212 1
d223 2
a224 1
  logical :: myClean, myDirect, myFillValue, myGaps, myStats, myRMS, &
d226 1
d1540 2
d2242 1
a2242 1
        & .not. (myStats .or. myRMS)
d2252 1
a2252 1
        & .not. (myStats .or. myRMS)
d2419 1
a2419 1
       "$Id: dump_0.f90,v 2.91 2009/08/17 16:55:41 pwagner Exp $"
d2429 3
@


2.91
log
@Among options string 'd' means 'direct'
@
text
@d208 1
d645 1
a645 1
    myFormat = 'places=6' ! To sneak places arg into call to output
d986 1
a986 1
    myFormat = 'places=6' ! To sneak places arg into call to output
d1359 1
a1359 1
    myFormat = 'places=6' ! To sneak places arg into call to output
d2411 1
a2411 1
       "$Id: dump_0.f90,v 2.90 2009/06/26 00:15:18 pwagner Exp $"
d2421 3
@


2.90
log
@Added dumpDumpOptions
@
text
@d35 1
d218 1
a218 1
  logical :: myClean, myFillValue, myGaps, myStats, myRMS, &
d2267 2
d2410 1
a2410 1
       "$Id: dump_0.f90,v 2.89 2009/06/24 22:36:32 pwagner Exp $"
d2420 3
@


2.89
log
@Make use of dump1-3.f9h include files
@
text
@d32 1
a32 1
  use MLSStrings, only: indexes, lowercase
d58 1
d82 1
d125 2
a126 2
  public :: DIFF, DUMP, DUMP_2x2xN, DUMPNAMEDVALUES, DUMPTABLE, &
    & SELFDIFF, DUMPSUMS
d1511 30
d2407 1
a2407 1
       "$Id: dump_0.f90,v 2.88 2009/06/23 18:25:43 pwagner Exp $"
d2417 3
@


2.88
log
@Prevent Intel from optimizing ident string away
@
text
@d185 1
a185 1
       "$RCSfile: $"
a610 6

    integer :: Base
    integer, parameter :: DefaultWidth = 5
    integer :: J, K, MyWidth
    double precision :: myFillValue
    integer :: nUnique
d613 2
d616 1
d618 1
a618 25

    ! Executable
    call theDumpBegins ( options )
    myFillValue = 0.d0
    if ( present(FillValue) ) myFillValue=FillValue
    if ( myUnique ) then
      call FindUnique( array, elements, nUnique, counts )
      if ( nUnique < 2 ) then
        call output( 'Every value is ', advance='no' )
        call output( elements(1), advance='yes' )
      else
        call output( '    value             counts', advance='yes' )
        do j=1, nUnique
          call output( j )
          call blanks( 3 )
          call output( elements(j) )
          call blanks( 3 )
          call output( counts(j), advance='yes' )
        enddo
      endif
      if ( uniqueonly ( options ) ) return
    endif
    include 'dumpstats.f9h'
    myWidth = defaultWidth
    if ( present(width) ) myWidth = width
d620 1
a620 38
    if ( present(format) ) myFormat = format
    base = 0
    if ( present(lbound) ) base = lbound - 1

    numZeroRows = 0
    if ( size(array) == 0 ) then
      call empty ( name )
    else if ( size(array) == 1 .and. base == 0 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1), myFormat, advance='yes' )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) ) call output ( '', advance='yes' )
      do j = 1, size(array), myWidth
!         if (.not. myClean) then
!           call output ( j, max(defaultWidth-1,ilog10(size(array))+1) )
!           call output ( afterSub )
!         end if
!         do k = j, min(j+myWidth-1, size(array))
!           call output ( array(k), myFormat )
!         end do
        if (.not. myClean) then
          if ( any(array(j:min(j+myWidth-1, size(array))) /= myFillValue) ) then
            call say_fill ( (/ j-1+base, size(array) /), numZeroRows, myFillValue, inc=1 )
          else
            numZeroRows = numZeroRows + 1
          end if
        end if
        if ( myClean .or. any(array(j:min(j+myWidth-1, size(array))) /= myFillValue) ) then
          do k = j, min(j+myWidth-1, size(array))
           call output ( array(k), myFormat )
          end do
          call output ( '', advance='yes' )
        endif
      end do
      call say_fill ( (/ j-myWidth, size(array) /), numZeroRows, myFillValue )
    end if
    call theDumpEnds
d633 3
a635 1

d637 1
a639 1

d641 2
a642 61
    integer, dimension(MAXNUMELEMENTS) :: counts
    integer, dimension(MAXNUMELEMENTS) :: elements
    integer :: myFillValue
    ! Executable
    call theDumpBegins ( options )
    myFillValue = 0
    if ( present(FillValue) ) myFillValue=FillValue
    if ( myUnique ) then
      call FindUnique( array, elements, nUnique, counts )
      if ( nUnique < 2 ) then
        call output( 'Every value is ', advance='no' )
        call output( elements(1), advance='yes' )
      else
        call output( '    value             counts', advance='yes' )
        do j=1, nUnique
          call output( j )
          call blanks( 3 )
          call output( elements(j) )
          call blanks( 3 )
          call output( counts(j), advance='yes' )
        enddo
      endif
      if ( uniqueonly ( options ) ) return
    endif
    include 'dumpstats.f9h'
    myWidth = 10
    if ( present(width) ) myWidth = width
    base = 0
    if ( present(lbound) ) base = lbound - 1

    numZeroRows = 0
    if ( size(array) == 0 ) then
      call empty ( name )
    else if ( size(array) == 1 .and. base == 0 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1), advance='yes' )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) ) call output ( '', advance='yes' )
      do j = 1, size(array), myWidth
        if (.not. myClean) then
          if ( any(array(j:min(j+myWidth-1, size(array))) /= myFillValue) ) then
            call say_fill ( (/ j-1+base, size(array) /), numZeroRows, myFillValue, inc=1 )
          else
            numZeroRows = numZeroRows + 1
          end if
        end if
        if ( myClean .or. any(array(j:min(j+myWidth-1, size(array))) /= myFillValue) ) then
          do k = j, min(j+myWidth-1, size(array))
            if ( present(format) ) then
              call output ( array(k), format=format )
            else
              call output ( array(k), places=6 )
            end if
          end do
          call output ( '', advance='yes' )
        end if
      end do ! j
      call say_fill ( (/ j-myWidth, size(array) /), numZeroRows, myFillValue )
    end if
    call theDumpEnds
d711 4
a714 4

    integer :: Base
    integer, parameter :: DefaultWidth = 5
    integer :: J, K, MyWidth
d716 1
a717 2

    real :: myFillValue
a718 27
    integer, dimension(MAXNUMELEMENTS) :: counts
    real, dimension(MAXNUMELEMENTS) :: elements
    ! Executable
    call theDumpBegins ( options )
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue
    if ( myUnique ) then
      call FindUnique( array, elements, nUnique, counts )
      if ( nUnique < 2 ) then
        call output( 'Every value is ', advance='no' )
        call output( elements(1), advance='yes' )
      else
        call output( '    value             counts', advance='yes' )
        do j=1, nUnique
          call output( j )
          call blanks( 3 )
          call output( elements(j) )
          call blanks( 3 )
          call output( counts(j), advance='yes' )
        enddo
      endif
      if ( uniqueonly ( options ) ) return
    endif
    include 'dumpstats.f9h'

    myWidth = defaultWidth
    if ( present(width) ) myWidth = width
d720 1
a720 31
    if ( present(format) ) myFormat = format
    base = 0
    if ( present(lbound) ) base = lbound - 1

    numZeroRows = 0
    if ( size(array) == 0 ) then
      call empty ( name )
    else if ( size(array) == 1 .and. base == 0 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1), myFormat, advance='yes' )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) ) call output ( '', advance='yes' )
      do j = 1, size(array), myWidth
        if (.not. myClean) then
          if ( any(array(j:min(j+myWidth-1, size(array))) /= myFillValue) ) then
            call say_fill ( (/ j-1+base, size(array) /), numZeroRows, myFillValue, inc=1 )
          else
            numZeroRows = numZeroRows + 1
          end if
        end if
        if ( myClean .or. any(array(j:min(j+myWidth-1, size(array))) /= myFillValue) ) then
          do k = j, min(j+myWidth-1, size(array))
           call output ( array(k), myFormat )
          end do
          call output ( '', advance='yes' )
        endif
      end do
      call say_fill ( (/ j-myWidth, size(array) /), numZeroRows, myFillValue )
    end if
    call theDumpEnds
a958 25
    ! Executable
    call theDumpBegins ( options )

    myFillValue = 0.0d0
    if ( present(FillValue) ) myFillValue = FillValue
    if ( myUnique ) then
      call FindUnique( reshape( array, (/ product(shape(array)) /) ), &
        & elements, nUnique, counts )
      if ( nUnique < 2 ) then
        call output( 'Every value is ', advance='no' )
        call output( elements(1), advance='yes' )
      else
        call output( '    value             counts', advance='yes' )
        do j=1, nUnique
          call output( j )
          call blanks( 3 )
          call output( elements(j) )
          call blanks( 3 )
          call output( counts(j), advance='yes' )
        enddo
      endif
      if ( uniqueonly ( options ) ) return
    endif
    include 'dumpstats.f9h'

d960 1
a960 58
    if ( present(format) ) myFormat = format

    numZeroRows = 0
    if ( size(array) == 0 ) then
      call empty ( name )
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1), myFormat, advance='yes' )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1), name, options=options )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( .not. myTranspose ) then
        if ( present(name) ) call output ( '', advance='yes' )
        do i = 1, size(array,1)
          do j = 1, size(array,2), 5
            if (.not. myClean) then
              if ( any(array(i,j:min(j+4, size(array,2))) /= myFillValue) ) then
                call say_fill ( (/ i, size(array,1), j-1, size(array,2) /), &
                  & numZeroRows, myFillValue, inc=3 )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( myClean .or. any(array(i,j:min(j+4, size(array,2))) /= myFillValue) ) then
              do k = j, min(j+4, size(array,2))
                call output ( array(i,k), myFormat )
              end do
              call output ( '', advance='yes' )
            end if
          end do
        end do
        call say_fill ( (/ i-1, size(array,1), j-5, size(array,2) /), &
          & numZeroRows, myFillValue )
      else ! Dump the transpose
        if ( present(name) ) call output ( ' ' )
        call output ( '(transposed)', advance='yes' )
        do j = 1, size(array,2)
          do i = 1, size(array,1), 5
            if ( any(array(i:min(i+4, size(array,1)),j) /= myFillValue) ) then  
              call say_fill ( (/ i, size(array,1), j-1, size(array,2) /), &
                & numZeroRows, myFillValue, inc=3 )
            else                                                            
              numZeroRows = numZeroRows + 1                                 
            end if                                                          
            if ( myClean .or. any(array(i:min(i+4, size(array,1)),j) /= myFillValue) ) then
              do k = i, min(i+4, size(array,1))
                call output ( array(k,j), myFormat )
              end do
              call output ( '', advance='yes' )
            end if                                                          
          end do
        end do
      end if
      call say_fill ( (/ i-5, size(array,1), j-1, size(array,2) /), &
        & numZeroRows, myFillValue )
    end if
    call theDumpEnds
d982 2
a983 64
    ! Executable
    call theDumpBegins ( options )
    myFillValue = 0
    if ( present(FillValue) ) myFillValue = FillValue
    if ( myUnique ) then
      call FindUnique( reshape( array, (/ product(shape(array)) /) ), &
        & elements, nUnique, counts )
      if ( nUnique < 2 ) then
        call output( 'Every value is ', advance='no' )
        call output( elements(1), advance='yes' )
      else
        call output( '    value             counts', advance='yes' )
        do j=1, nUnique
          call output( j )
          call blanks( 3 )
          call output( elements(j) )
          call blanks( 3 )
          call output( counts(j), advance='yes' )
        enddo
      endif
      if ( uniqueonly ( options ) ) return
    endif
    include 'dumpstats.f9h'
    myWidth = 10
    if ( present(width) ) myWidth = width

    numZeroRows = 0
    if ( size(array) == 0 ) then
      call empty ( name )
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1), advance='yes' )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1), name, &
        & fillvalue=fillvalue, format=format, width=width, options=options )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) ) call output ( '', advance='yes' )
      do i = 1, size(array,1)
        do j = 1, size(array,2), myWidth
          if (.not. myClean) then
            if ( any(array(i,j:min(j+myWidth-1, size(array,2))) /= myFillValue) ) then
              call say_fill ( (/ i, size(array,1), j-1, size(array,2) /), &
                & numZeroRows, myFillValue, inc=3 )
            else
              numZeroRows = numZeroRows + 1
            end if
          end if
          if ( myClean .or. any(array(i,j:min(j+myWidth-1, size(array,2))) /= myFillValue) ) then
            do k = j, min(j+myWidth-1, size(array,2))
              if ( present(format) ) then
                call output ( array(i,k), format=format )
              else
                call output ( array(i,k), places=6 )
              end if
            end do
            call output ( '', advance='yes' )
          end if
        end do ! j
      end do ! i
      call say_fill ( (/ i-1, size(array,1), j-myWidth, size(array,2) /), &
        & numZeroRows, myFillValue )
    end if
    call theDumpEnds
a1041 25
    ! Executable
    call theDumpBegins ( options )

    myFillValue = 0.0e0
    if ( present(FillValue) ) myFillValue = FillValue
    if ( myUnique ) then
      call FindUnique( reshape( array, (/ product(shape(array)) /) ), &
        & elements, nUnique, counts )
      if ( nUnique < 2 ) then
        call output( 'Every value is ', advance='no' )
        call output( elements(1), advance='yes' )
      else
        call output( '    value             counts', advance='yes' )
        do j=1, nUnique
          call output( j )
          call blanks( 3 )
          call output( elements(j) )
          call blanks( 3 )
          call output( counts(j), advance='yes' )
        enddo
      endif
      if ( uniqueonly ( options ) ) return
    endif
    include 'dumpstats.f9h'

d1043 1
a1043 58
    if ( present(format) ) myFormat = format

    numZeroRows = 0
    if ( size(array) == 0 ) then
      call empty ( name )
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1), myFormat, advance='yes' )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1), name, options=options )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( .not. myTranspose ) then
        if ( present(name) ) call output ( '', advance='yes' )
        do i = 1, size(array,1)
          do j = 1, size(array,2), 5
            if (.not. myClean) then
              if ( any(array(i,j:min(j+4, size(array,2))) /= myFillValue) ) then
                call say_fill ( (/ i, size(array,1), j-1, size(array,2) /), &
                  & numZeroRows, myFillValue, inc=3 )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( myClean .or. any(array(i,j:min(j+4, size(array,2))) /= myFillValue) ) then
              do k = j, min(j+4, size(array,2))
                call output ( array(i,k), myFormat )
              end do
              call output ( '', advance='yes' )
            end if
          end do
        end do
        call say_fill ( (/ i-1, size(array,1), j-5, size(array,2) /), &
          & numZeroRows, myFillValue )
      else ! Dump the transpose
        if ( present(name) ) call output ( ' ' )
        call output ( '(transposed)', advance='yes' )
        do j = 1, size(array,2)
          do i = 1, size(array,1), 5
            if ( any(array(i:min(i+4, size(array,1)),j) /= myFillValue) ) then  
              call say_fill ( (/ i-1, size(array,1), j, size(array,2) /), &
                & numZeroRows, myFillValue, inc=1 )
            else                                                            
              numZeroRows = numZeroRows + 1                                 
            end if                                                          
            if ( myClean .or. any(array(i:min(i+4, size(array,1)),j) /= myFillValue) ) then
              do k = i, min(i+4, size(array,1))
                call output ( array(k,j), myFormat )
              end do
              call output ( '', advance='yes' )
            end if                                                          
          end do
        end do
      end if
      call say_fill ( (/ i-5, size(array,1), j-1, size(array,2) /), &
        & numZeroRows, myFillValue )
    end if
    call theDumpEnds
a1328 25

    ! Executable
    call theDumpBegins ( options )
    myFillValue = 0.d0
    if ( present(FillValue) ) myFillValue=FillValue
    if ( myUnique ) then
      call FindUnique( reshape( array, (/ product(shape(array)) /) ), &
        & elements, nUnique, counts )
      if ( nUnique < 2 ) then
        call output( 'Every value is ', advance='no' )
        call output( elements(1), advance='yes' )
      else
        call output( '    value             counts', advance='yes' )
        do j=1, nUnique
          call output( j )
          call blanks( 3 )
          call output( elements(j) )
          call blanks( 3 )
          call output( counts(j), advance='yes' )
        enddo
      endif
      if ( uniqueonly ( options ) ) return
    endif
    include 'dumpstats.f9h'

d1330 1
a1330 39
    if ( present(format) ) myFormat = format

    numZeroRows = 0
    if ( size(array) == 0 ) then
      call empty ( name )
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1,1), myFormat, advance='yes' )
    else if ( size(array,2) == 1 .and. size(array,3) == 1 ) then
      call dump ( array(:,1,1), name, options=options )
    else if ( size(array,3) == 1 ) then
      call dump ( array(:,:,1), name, fillValue=fillValue, options=options )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) ) call output ( '', advance='yes' )
      do i = 1, size(array,1)
        do j = 1, size(array,2)
          do k = 1, size(array,3), 5
            if (.not. myClean) then
              if ( any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
                call say_fill ( (/ i, size(array,1), j-1, size(array,2), &
                  & k, size(array,3) /), numZeroRows, myFillValue, inc=3 )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( myClean .or. any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
              do l = k, min(k+4, size(array,3))
                call output ( array(i,j,l), myFormat )
              end do
              call output ( '', advance='yes' )
            end if
          end do
        end do
      end do
      call say_fill ( (/ i-1, size(array,1), j-1, size(array,2), &
        & k-5, size(array,3) /), numZeroRows, myFillValue )
   end if
    call theDumpEnds
d1350 1
d1355 2
a1356 71
    ! Executable
    call theDumpBegins ( options )
    myFillValue = 0
    if ( present(FillValue) ) myFillValue=FillValue
    if ( myUnique ) then
      call FindUnique( reshape( array, (/ product(shape(array)) /) ), &
        & elements, nUnique, counts )
      if ( nUnique < 2 ) then
        call output( 'Every value is ', advance='no' )
        call output( elements(1), advance='yes' )
      else
        call output( '    value             counts', advance='yes' )
        do j=1, nUnique
          call output( j )
          call blanks( 3 )
          call output( elements(j) )
          call blanks( 3 )
          call output( counts(j), advance='yes' )
        enddo
      endif
      if ( uniqueonly ( options ) ) return
    endif
    include 'dumpstats.f9h'
    myWidth = 10
    if ( present(width) ) myWidth = width
    call FindAll( (/ size(array, 1), size(array, 2), size(array, 3)/), &
      & 1, which, how_many, re_mainder=re_mainder)

    numZeroRows = 0
    if ( size(array) == 0 ) then
      call empty ( name )
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1,1), advance='yes' )
    else if ( how_many == 2 ) then
      call dump ( reshape(array, (/ re_mainder(1) /)), name, &
      & format=format, options=options )
    else if ( how_many == 1 ) then
      call dump ( reshape(array, (/ re_mainder(1), re_mainder(2) /)), &
        & name, format=format, options=options )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) ) call output ( '', advance='yes' )
      do i = 1, size(array,1)
        do j = 1, size(array,2)
          do k = 1, size(array,3), myWidth
            if (.not. myClean) then
              if ( any(array(i,j,k:min(k+myWidth-1, size(array,3))) /= myFillValue) ) then
                call say_fill ( (/ i, size(array,1), j-1, size(array,2), &
                  & k, size(array,3) /), numZeroRows, myFillValue, inc=3 )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( myClean .or. any(array(i,j,k:min(k+myWidth-1, size(array,3))) /= myFillValue) ) then
              do l = k, min(k+myWidth-1, size(array,3))
                if ( present(format) ) then
                  call output ( array(i,j,l), format=format )
                else
                  call output ( array(i,j,l), places=6 )
                end if
              end do
              call output ( '', advance='yes' )
            end if
          end do
        end do
      end do
      call say_fill ( (/ i-1, size(array,1), j-1, size(array,2), &
        & k-myWidth, size(array,3) /), numZeroRows, myFillValue )
    end if
    call theDumpEnds
a1376 25

    ! Executable
    call theDumpBegins ( options )
    myFillValue = 0.
    if ( present(FillValue) ) myFillValue=FillValue
    if ( myUnique ) then
      call FindUnique( reshape( array, (/ product(shape(array)) /) ), &
        & elements, nUnique, counts )
      if ( nUnique < 2 ) then
        call output( 'Every value is ', advance='no' )
        call output( elements(1), advance='yes' )
      else
        call output( '    value             counts', advance='yes' )
        do j=1, nUnique
          call output( j )
          call blanks( 3 )
          call output( elements(j) )
          call blanks( 3 )
          call output( counts(j), advance='yes' )
        enddo
      endif
      if ( uniqueonly ( options ) ) return
    endif
    include 'dumpstats.f9h'

d1378 1
a1378 39
    if ( present(format) ) myFormat = format

    numZeroRows = 0
    if ( size(array) == 0 ) then
      call empty ( name )
    else if ( size(array) == 1 ) then
      call name_and_size ( name, myClean, 1 )
      call output ( array(1,1,1), myFormat, advance='yes' )
    else if ( size(array,2) == 1 .and. size(array,3) == 1 ) then
      call dump ( array(:,1,1), name, options=options )
    else if ( size(array,3) == 1 ) then
      call dump ( array(:,:,1), name, fillValue=fillValue, options=options )
    else
      call name_and_size ( name, myClean, size(array) )
      if ( present(name) ) call output ( '', advance='yes' )
      do i = 1, size(array,1)
        do j = 1, size(array,2)
          do k = 1, size(array,3), 5
            if (.not. myClean) then
              if ( any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
                call say_fill ( (/ i, size(array,1), j-1, size(array,2), &
                  & k, size(array,3) /), numZeroRows, myFillValue, inc=3 )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( myClean .or. any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
              do l = k, min(k+4, size(array,3))
                call output ( array(i,j,l), myFormat )
              end do
              call output ( '', advance='yes' )
            endif
          end do
        end do
      end do
      call say_fill ( (/ i-1, size(array,1), j-1, size(array,2), &
        & k-5, size(array,3) /), numZeroRows, myFillValue )
   end if
    call theDumpEnds
d2375 1
a2375 1
       "$Id: read_apriori.f90 is it here $"
d2385 3
@


2.87
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d185 1
a185 1
       "$RCSfile: dump_0.f90,v $"
d2971 1
a2972 1
!---------------------------- RCS Ident Info -------------------------------
d2974 2
a2975 3
       "$Id: dump_0.f90,v 2.86 2009/05/14 21:59:04 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2977 1
a2977 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d2979 1
d2984 3
@


2.86
log
@New optional arg AS_GAPS dor dumping 1d bit logicals
@
text
@d32 1
a32 1
  use MLSStrings, only: lowercase
d67 2
a68 2
!      [fillvalue], [log clean], [int width], [char* format],
!      [log wholearray], [log stats], [log rms], [int lbound] ) 
d73 2
a74 2
!      [fillvalue], [log clean], [int width], [char* format],
!      [log wholearray], [log stats], [log rms], [log unique], [int lbound] ) 
d78 1
a78 1
! dump ( strlist string, char* name, [char* fillvalue], [log clean] )
d80 1
a80 1
!       [char* separator] )
d82 1
a82 1
!      [log clean], [char* format, [int width] ) 
d86 2
a87 3
!      [fillvalue], [log clean], [int width], [char* format],
!      [log wholearray], [log stats], [log rms], [log unique],
!      [int lbound] ) 
d95 2
a96 3
!      [fillvalue], [log clean], [int width], [char* format],
!      [log wholearray], [log stats], [log rms], [log unique],
!      [log waves], [int lbound] ) 
d99 15
a113 1
! logically set to FALSE or 0 or '*' where appropriate
d193 1
a193 8
  ! The following character strings can include one or more options to:
  ! option             effect
  ! ------             ------
  !  c             clean = TRUE
  !  r             rms = TRUE
  !  s             stats = TRUE
  !  t             trim = TRUE
  !  w             wholearray = TRUE
d215 2
a216 1
  logical :: myStats, myRMS, myWholeArray
d237 1
a237 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a242 1
    logical, intent(in), optional :: CLEAN
a244 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
d246 1
d250 1
a250 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d255 1
a255 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d258 1
a258 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d263 1
a263 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a268 1
    logical, intent(in), optional :: CLEAN
a270 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
d272 1
d275 2
a276 2
      call UnfilteredDiff_1D_INTEGER( ARRAY1, NAME1, ARRAY2, NAME2, &
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d281 1
a281 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d284 1
a284 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d289 1
a289 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a294 1
    logical, intent(in), optional :: CLEAN
a296 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
d298 1
d302 1
a302 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d307 1
a307 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d310 1
a310 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d315 1
a315 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a320 1
    logical, intent(in), optional :: CLEAN
d323 3
a325 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    integer, intent(in), optional :: LBOUND
d328 1
a328 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d333 1
a333 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d336 1
a336 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d340 2
a341 2
  subroutine DIFF_2D_REAL ( ARRAY1, NAME1, ARRAY2, Name2, &
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a346 1
    logical, intent(in), optional :: CLEAN
d349 3
a351 5
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    integer, intent(in), optional :: LBOUND
    !
d354 1
a354 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d359 1
a359 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d362 1
a362 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d367 1
a367 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a372 1
    logical, intent(in), optional :: CLEAN
d375 2
a376 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    integer, intent(in), optional :: LBOUND
d380 1
a380 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d385 1
a385 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d388 1
a388 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d393 1
a393 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a398 1
    logical, intent(in), optional :: CLEAN
d401 2
a402 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    integer, intent(in), optional :: LBOUND
d406 1
a406 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d411 1
a411 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d414 1
a414 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d419 1
a419 1
  subroutine DUMP_1D_BIT ( ARRAY, NAME, BITNAMES, FILLVALUE, CLEAN, UNIQUE )
d424 1
a424 2
    logical, intent(in), optional :: CLEAN
    logical, intent(in), optional :: UNIQUE
a427 1
    logical :: MyClean
d433 1
a433 1
    call theDumpBegins
a436 2
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d472 1
a472 1
  subroutine DUMP_1D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN, TRIM, MAXLON )
d476 1
a476 2
    logical, intent(in), optional :: CLEAN
    logical, intent(in), optional :: TRIM
a480 2
    logical :: MyClean
    logical :: MyTRIM
d484 1
a484 1
    call theDumpBegins
a487 4
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
    myTrim = theDefault('trim') ! .false.
    if ( present(trim) ) myTrim = trim
d522 1
a522 1
  subroutine DUMP_1D_COMPLEX ( ARRAY, NAME, CLEAN, WIDTH, FORMAT )
a525 1
    logical, intent(in), optional :: CLEAN
d528 1
a529 1
    logical :: MyClean
d533 1
a533 3
    call theDumpBegins
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d562 1
a562 1
  subroutine DUMP_1D_DCOMPLEX ( ARRAY, NAME, CLEAN, WIDTH, FORMAT )
a565 1
    logical, intent(in), optional :: CLEAN
d568 1
a569 1
    logical :: MyClean
d573 1
a573 3
    call theDumpBegins
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d603 1
a603 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, UNIQUE, LBOUND )
a606 1
    logical, intent(in), optional :: CLEAN
a608 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d610 1
a614 1
    logical :: MyClean
a619 1
    logical :: MyUnique
d623 1
a623 1
    call theDumpBegins
a625 2
    myUnique = theDefault('unique')
    if ( present(unique) ) myUnique = unique
d641 1
a641 1
      if ( uniqueonly ( WHOLEARRAY, STATS, RMS ) ) return
a643 2
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d689 1
a689 1
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, UNIQUE, LBOUND )
a692 1
    logical, intent(in), optional :: CLEAN
a694 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d696 1
a698 2
    logical :: MyClean
    logical :: MyUnique
d707 1
a707 1
    call theDumpBegins
a709 2
    myUnique = theDefault('unique')
    if ( present(unique) ) myUnique = unique
d725 1
a725 1
      if ( uniqueonly ( WHOLEARRAY, STATS, RMS ) ) return
a727 2
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d767 1
a767 1
  subroutine DUMP_1D_LOGICAL ( ARRAY, NAME, CLEAN, LBOUND, AS_GAPS )
a769 1
    logical, intent(in), optional :: CLEAN
d771 1
a771 1
    logical, intent(in), optional :: AS_GAPS ! Use gaps in true to show false (or vice versa)
a773 2
    logical :: myClean
    logical :: myGaps
a774 2
    myGaps = .false.
    if ( present(as_gaps) ) myGaps = as_gaps
d776 1
a776 1
    call theDumpBegins
a779 3
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean

d824 1
a824 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, UNIQUE, LBOUND )
a827 1
    logical, intent(in), optional :: CLEAN
a829 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d831 1
a835 1
    logical :: myClean
a839 1
    logical :: MyUnique
d844 1
a844 1
    call theDumpBegins
a846 2
    myUnique = theDefault('unique')
    if ( present(unique) ) myUnique = unique
d862 1
a862 1
      if ( uniqueonly ( WHOLEARRAY, STATS, RMS ) ) return
a865 2
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d903 1
a903 1
  subroutine DUMP_2D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN, TRIM, MAXLON )
a906 2
    logical, intent(in), optional :: CLEAN
    logical, intent(in), optional :: TRIM
d908 1
a911 2
    logical :: MyClean
    logical :: MyTRIM
d915 1
a915 1
    call theDumpBegins
a918 4
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
    myTrim = theDefault('trim') ! .false.
    if ( present(trim) ) myTrim = trim
d930 1
a930 1
      call dump ( array(:,1), name, fillValue=fillValue, clean=clean, trim=trim, maxlon=maxlon )
d959 1
a959 2
  subroutine DUMP_2D_COMPLEX ( ARRAY, NAME, CLEAN, WIDTH, FORMAT, FILLVALUE, &
    & TRANSPOSE )
a962 1
    logical, intent(in), optional :: CLEAN
d966 1
a966 1
    logical, intent(in), optional :: TRANSPOSE
a967 1
    logical :: myClean, myTranspose
d974 1
a974 3
    call theDumpBegins
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
a984 3
    myTranspose = .not.(size(array,2) >= min(5,size(array,1)) .or. myClean)
    if ( present(transpose) ) myTranspose = transpose
    
d992 1
a992 1
      call dump ( array(:,1), name, clean=clean, format=myFormat )
d1040 1
a1040 2
  subroutine DUMP_2D_DCOMPLEX ( ARRAY, NAME, CLEAN, WIDTH, FORMAT, FILLVALUE, &
    & TRANSPOSE )
a1043 1
    logical, intent(in), optional :: CLEAN
d1047 1
a1047 1
    logical, intent(in), optional :: TRANSPOSE
a1048 1
    logical :: myClean, myTranspose
d1055 1
a1055 3
    call theDumpBegins
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
a1065 3
    myTranspose = .not.(size(array,2) >= min(5,size(array,1)) .or. myClean)
    if ( present(transpose) ) myTranspose = transpose

d1073 1
a1073 1
      call dump ( array(:,1), name, clean=clean, format=myFormat )
d1122 1
a1122 2
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, UNIQUE, LBOUND, &
    & TRANSPOSE )
a1125 1
    logical, intent(in), optional :: CLEAN
a1127 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d1129 1
a1129 1
    logical, intent(in), optional :: TRANSPOSE
a1130 1
    logical :: myClean, myTranspose
a1134 1
    logical :: MyUnique
d1139 1
a1139 3
    call theDumpBegins
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
a1142 2
    myUnique = theDefault('unique')
    if ( present(unique) ) myUnique = unique
d1159 1
a1159 1
      if ( uniqueonly ( WHOLEARRAY, STATS, RMS ) ) return
a1165 3
    myTranspose = .not.(size(array,2) >= min(5,size(array,1)) .or. myClean)
    if ( present(transpose) ) myTranspose = transpose

d1173 1
a1173 1
      call dump ( array(:,1), name, clean=clean )
d1226 1
a1226 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, UNIQUE, LBOUND )
a1229 1
    logical, intent(in), optional :: CLEAN
a1231 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d1233 1
a1235 1
    logical :: MyClean
a1239 1
    logical :: MyUnique
d1244 1
a1244 1
    call theDumpBegins
a1246 2
    myUnique = theDefault('unique')
    if ( present(unique) ) myUnique = unique
d1263 1
a1263 1
      if ( uniqueonly ( WHOLEARRAY, STATS, RMS ) ) return
a1265 2
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d1277 1
a1277 1
        & fillvalue=fillvalue, clean=clean, format=format, width=width )
d1310 1
a1310 1
  subroutine DUMP_2D_LOGICAL ( ARRAY, NAME, CLEAN )
d1313 1
a1313 1
    logical, intent(in), optional :: CLEAN
a1315 1
    logical :: MyClean
d1318 1
a1318 3
    call theDumpBegins
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d1326 1
a1326 1
      call dump ( array(:,1), name, clean=clean )
d1349 1
a1349 2
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, UNIQUE, LBOUND, &
    & TRANSPOSE )
a1352 1
    logical, intent(in), optional :: CLEAN
a1354 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d1356 1
a1356 1
    logical, intent(in), optional :: TRANSPOSE
a1357 1
    logical :: myClean, myTranspose
a1361 1
    logical :: MyUnique
d1366 1
a1366 3
    call theDumpBegins
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
a1369 2
    myUnique = theDefault('unique')
    if ( present(unique) ) myUnique = unique
d1386 1
a1386 1
      if ( uniqueonly ( WHOLEARRAY, STATS, RMS ) ) return
a1392 3
    myTranspose = .not.(size(array,2) >= min(5,size(array,1)) .or. myClean)
    if ( present(transpose) ) myTranspose = transpose

d1400 1
a1400 1
      call dump ( array(:,1), name, clean=clean )
d1452 1
a1452 1
  subroutine DUMP_2x2xN_COMPLEX ( ARRAY, NAME, CLEAN, FORMAT )
a1456 1
    logical, intent(in), optional :: CLEAN
d1458 1
a1459 1
    logical :: MyClean
d1463 1
a1463 3
    call theDumpBegins
    myClean = .false.
    if ( present(clean) ) myClean = clean
d1488 1
a1488 1
  subroutine DUMP_2x2xN_DCOMPLEX ( ARRAY, NAME, CLEAN, FORMAT )
a1492 1
    logical, intent(in), optional :: CLEAN
d1494 1
a1495 1
    logical :: MyClean
d1499 1
a1499 3
    call theDumpBegins
    myClean = .false.
    if ( present(clean) ) myClean = clean
d1524 1
a1524 1
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN, TRIM, MAXLON )
a1527 2
    logical, intent(in), optional :: CLEAN
    logical, intent(in), optional :: TRIM
d1529 1
a1531 2
    logical :: MyClean
    logical :: MyTRIM
d1538 1
a1538 1
    call theDumpBegins
a1541 4
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
    myTrim = theDefault('trim') ! .false.
    if ( present(trim) ) myTrim = trim
d1556 1
a1556 1
        & clean=clean, trim=trim, maxlon=maxlon )
d1559 1
a1559 1
        & name, fillValue=fillValue, clean=clean, trim=trim )
d1591 1
a1591 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a1594 1
    logical, intent(in), optional :: CLEAN
a1596 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
d1598 1
a1599 1
    logical :: myClean
d1606 1
a1606 1
    call theDumpBegins
a1608 2
    myClean = .false.
    if ( present(clean) ) myClean = clean
d1620 1
a1620 1
      call dump ( array(:,1,1), name, clean=clean )
d1622 1
a1622 1
      call dump ( array(:,:,1), name, fillValue=fillValue, clean=clean )
d1654 1
a1654 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a1658 1
    logical, intent(in), optional :: CLEAN
a1660 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
d1662 1
a1663 1
    logical :: myClean
d1670 1
a1670 1
    call theDumpBegins
a1672 2
    myClean = .false.
    if ( present(clean) ) myClean = clean
d1684 1
a1684 1
      call dump ( array(:,1,1), name, clean=clean )
d1686 1
a1686 1
      call dump ( array(:,:,1), name, fillValue=fillValue, clean=clean )
d1718 1
a1718 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, UNIQUE, LBOUND )
a1721 1
    logical, intent(in), optional :: CLEAN
a1723 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d1725 1
a1726 1
    logical :: myClean
a1730 1
    logical :: MyUnique
d1736 1
a1736 1
    call theDumpBegins
a1738 2
    myUnique = theDefault('unique')
    if ( present(unique) ) myUnique = unique
d1755 1
a1755 1
      if ( uniqueonly ( WHOLEARRAY, STATS, RMS ) ) return
a1758 2
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d1769 1
a1769 1
      call dump ( array(:,1,1), name, clean=clean )
d1771 1
a1771 1
      call dump ( array(:,:,1), name, fillValue=fillValue, clean=clean )
d1803 1
a1803 1
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, UNIQUE, LBOUND )
a1806 1
    logical, intent(in), optional :: CLEAN
a1808 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d1810 1
a1812 1
    logical :: myClean
a1818 1
    logical :: MyUnique
d1823 1
a1823 1
    call theDumpBegins
a1825 2
    myUnique = theDefault('unique')
    if ( present(unique) ) myUnique = unique
d1842 1
a1842 1
      if ( uniqueonly ( WHOLEARRAY, STATS, RMS ) ) return
a1844 2
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d1857 2
a1858 2
      call dump ( reshape(array, (/ re_mainder(1) /)), name, clean=clean, &
      & format=format )
d1861 1
a1861 1
        & name, clean=clean, format=format )
d1897 1
a1897 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, UNIQUE, LBOUND )
a1900 1
    logical, intent(in), optional :: CLEAN
a1902 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d1904 1
a1905 1
    logical :: myClean
a1909 1
    logical :: MyUnique
d1915 1
a1915 1
    call theDumpBegins
a1917 4
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
    myUnique = theDefault('unique')
    if ( present(unique) ) myUnique = unique
d1934 1
a1934 1
      if ( uniqueonly ( WHOLEARRAY, STATS, RMS ) ) return
d1948 1
a1948 1
      call dump ( array(:,1,1), name, clean=clean )
d1950 1
a1950 1
      call dump ( array(:,:,1), name, fillValue=fillValue, clean=clean )
d1981 1
a1981 1
  subroutine DUMP_HASH_STR ( COUNTEMPTY, KEYS, VALUES, NAME, SEPARATOR )
d1988 1
d1996 1
a1996 1
    call theDumpBegins
d2020 1
a2020 1
  subroutine DUMP_HASH_LOG ( COUNTEMPTY, KEYS, VALUES, NAME, SEPARATOR )
d2027 1
d2035 1
a2035 1
    call theDumpBegins
d2058 1
a2058 1
  subroutine DUMP_STRLIST ( STRING, NAME, FILLVALUE, CLEAN, INSEPARATOR )
d2064 1
a2064 1
    logical, intent(in), optional :: CLEAN
a2067 1
    logical :: MyClean
d2076 1
a2076 1
      call dump( (/ trim(string) /), name, fillvalue, clean )
d2079 1
a2079 1
      call dump( (/ trim(string) /), name, fillvalue, clean )
d2083 1
a2083 1
    call theDumpBegins
a2086 3
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
    
d2112 1
a2112 1
  subroutine dumpNamedValues_DOUBLE ( VALUES, NAMES, CLEAN, FORMAT, WIDTH )
a2114 1
    logical, intent(in), optional :: CLEAN
d2117 1
a2119 1
    logical :: MyClean
d2122 1
a2122 3
    call theDumpBegins
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d2150 1
a2150 1
  subroutine dumpNamedValues_INTEGER ( VALUES, NAMES, CLEAN, FORMAT, WIDTH )
a2152 1
    logical, intent(in), optional :: CLEAN
d2155 1
a2157 1
    logical :: MyClean
d2160 1
a2160 3
    call theDumpBegins
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d2188 1
a2188 1
  subroutine dumpNamedValues_REAL ( VALUES, NAMES, CLEAN, FORMAT, WIDTH )
a2190 1
    logical, intent(in), optional :: CLEAN
d2193 1
a2195 1
    logical :: MyClean
d2198 1
a2198 3
    call theDumpBegins
    myClean = theDefault('clean') ! .false.
    if ( present(clean) ) myClean = clean
d2229 1
a2229 2
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, &
    & unique, LBOUND )
a2232 1
    logical, intent(in), optional :: CLEAN
a2234 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d2236 1
a2236 1
    ! logical, parameter :: unique = .false. 
d2249 1
a2249 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, unique, LBOUND )
d2253 1
a2253 2
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, &
    & unique, LBOUND )
a2256 1
    logical, intent(in), optional :: CLEAN
a2258 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d2260 1
a2263 1
    ! logical, parameter :: unique = .false. 
d2273 1
a2273 1
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, unique, LBOUND )
d2277 1
a2277 2
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, &
    & unique, LBOUND )
a2280 1
    logical, intent(in), optional :: CLEAN
a2282 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d2284 1
d2297 1
a2297 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, unique, LBOUND )
d2333 1
a2333 2
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, &
    & unique, waves, LBOUND )
a2337 1
    logical, intent(in), optional :: CLEAN
a2339 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d2342 1
a2342 1
    ! logical, parameter :: unique = .false. 
d2364 1
a2364 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, unique, LBOUND )
d2369 1
a2369 2
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, &
    & unique, waves, LBOUND )
a2373 1
    logical, intent(in), optional :: CLEAN
a2375 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d2378 1
a2381 1
    ! logical, parameter :: unique = .false. 
d2391 1
a2391 1
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, unique, LBOUND )
d2396 1
a2396 2
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, &
    & unique, waves, LBOUND )
a2400 1
    logical, intent(in), optional :: CLEAN
a2402 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
    logical, intent(in), optional :: UNIQUE
d2405 1
d2428 1
a2428 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, unique, LBOUND )
d2433 1
a2433 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2438 1
    logical, intent(in), optional :: CLEAN
a2440 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
d2442 1
d2451 1
a2451 1
    & IFILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2456 1
    logical, intent(in), optional :: CLEAN
a2458 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
d2460 1
d2470 1
a2470 2
      & FILLVALUE=FILLVALUE, CLEAN=CLEAN, WIDTH=WIDTH, FORMAT=FORMAT, &
      & WHOLEARRAY=WHOLEARRAY, STATS=STATS, RMS=RMS, LBOUND=LBOUND )
d2474 1
a2474 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2479 1
    logical, intent(in), optional :: CLEAN
a2481 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
d2483 1
d2492 1
a2492 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2497 1
    logical, intent(in), optional :: CLEAN
a2499 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
d2501 1
d2509 2
a2510 2
  subroutine FILTEREDDIFF_2D_REAL ( ARRAY1, NAME1, ARRAY2, Name2, &
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2515 1
    logical, intent(in), optional :: CLEAN
a2517 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
d2519 1
d2528 1
a2528 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2533 1
    logical, intent(in), optional :: CLEAN
a2535 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
d2537 1
d2546 1
a2546 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2551 1
    logical, intent(in), optional :: CLEAN
a2553 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
d2555 1
d2788 2
a2789 1
  subroutine theDumpBegins
d2791 20
d2847 1
a2847 1
    & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2851 1
    logical, intent(in), optional :: CLEAN
a2853 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
d2855 1
d2857 2
d2864 1
a2864 1
    & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2868 1
    logical, intent(in), optional :: CLEAN
a2870 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
d2872 1
d2880 2
a2881 2
      & CLEAN=CLEAN, WIDTH=WIDTH, FORMAT=FORMAT, &
      & WHOLEARRAY=WHOLEARRAY, STATS=STATS, RMS=RMS, LBOUND=LBOUND )
d2885 1
a2885 1
    & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2889 1
    logical, intent(in), optional :: CLEAN
a2891 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: STATS
    logical, intent(in), optional :: RMS
d2893 1
d2895 2
d2902 1
a2902 1
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2906 1
    logical, intent(in), optional :: CLEAN
a2908 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
d2910 1
d2916 2
a2917 2
  subroutine UNFILTEREDDIFF_2D_REAL ( ARRAY1, NAME1, ARRAY2, Name2, &
      & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2921 1
    logical, intent(in), optional :: CLEAN
a2923 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
d2925 1
d2932 1
a2932 1
    & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2936 1
    logical, intent(in), optional :: CLEAN
a2938 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
d2940 1
d2947 1
a2947 1
    & CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a2951 1
    logical, intent(in), optional :: CLEAN
a2953 3
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
d2955 1
d2961 2
a2962 2
  logical function uniqueonly ( WHOLEARRAY, STATS, RMS )
    logical, intent(in), optional :: WHOLEARRAY, STATS, RMS
d2965 3
a2967 3
    if ( present(wholeArray) ) uniqueonly = .not. wholeArray
    if ( present(stats) ) uniqueonly = uniqueonly .and. .not. stats
    if ( present(rms) ) uniqueonly = uniqueonly .and. .not. rms
d2974 1
a2974 1
       "$Id: dump_0.f90,v 2.85 2009/05/08 00:40:09 pwagner Exp $"
d2984 3
@


2.85
log
@Avoid printing blank name when dumped with empty name string
@
text
@d818 1
a818 1
  subroutine DUMP_1D_LOGICAL ( ARRAY, NAME, CLEAN, LBOUND )
d823 1
d825 1
a825 1
    integer :: Base, J, K
d827 4
d844 20
d3011 34
d3227 1
a3227 1
       "$Id: dump_0.f90,v 2.84 2009/04/01 23:30:49 pwagner Exp $"
d3237 3
@


2.84
log
@Improved appearance when printing 'nnn lines of xxx not printed.'
@
text
@d2837 1
d3168 1
a3168 1
       "$Id: dump_0.f90,v 2.83 2008/11/24 19:34:47 pwagner Exp $"
d3178 3
@


2.83
log
@Less wasteful of memory; should not segment dault so often
@
text
@d156 3
d2847 24
a2942 2
    integer, intent(in) :: Subs(:)
    integer, intent(inout) :: NumZeroRows
d2944 1
a2944 10
    integer, intent(in), optional :: Inc
    if ( numZeroRows /= 0 ) then
      call say_subs ( subs, numZeroRows  )
      call output ( '"', advance='no' )
      call output ( trim(fill), advance='no' )
      call output ( '" not printed.', advance='yes' )
      numZeroRows = 0
    end if
    if ( present(inc) ) &
      & call say_subs_only ( (/ subs(:inc-1), subs(inc)+1, subs(inc+1:) /) )
a2948 2
    integer, intent(in) :: Subs(:)
    integer, intent(inout) :: NumZeroRows
d2950 1
a2950 9
    integer, intent(in), optional :: Inc
    if ( numZeroRows /= 0 ) then
      call say_subs ( subs, numZeroRows )
      call output ( fill, advance='no' )
      call output ( ' not printed.', advance='yes' )
      numZeroRows = 0
    end if
    if ( present(inc) ) &
      & call say_subs_only ( (/ subs(:inc-1), subs(inc)+1, subs(inc+1:) /) )
a2954 2
    integer, intent(in) :: Subs(:)
    integer, intent(inout) :: NumZeroRows
d2956 1
a2956 9
    integer, intent(in), optional :: Inc
    if ( numZeroRows /= 0 ) then
      call say_subs ( subs, numZeroRows )
      call output ( fill, advance='no' )
      call output ( ' not printed.', advance='yes' )
      numZeroRows = 0
    end if
    if ( present(inc) ) &
      & call say_subs_only ( (/ subs(:inc-1), subs(inc)+1, subs(inc+1:) /) )
a2960 2
    integer, intent(in) :: Subs(:)
    integer, intent(inout) :: NumZeroRows
d2962 1
a2962 9
    integer, intent(in), optional :: Inc
    if ( numZeroRows /= 0 ) then
      call say_subs ( subs, numZeroRows )
      call output ( fill, advance='no' )
      call output ( ' not printed.', advance='yes' )
      numZeroRows = 0
    end if
    if ( present(inc) ) &
      & call say_subs_only ( (/ subs(:inc-1), subs(inc)+1, subs(inc+1:) /) )
d3167 1
a3167 1
       "$Id: dump_0.f90,v 2.82 2008/10/24 23:21:49 pwagner Exp $"
d3177 3
@


2.82
log
@Limits 3d diffs to prevent segment faults
@
text
@d26 1
d119 5
d162 5
d242 12
a253 4
    double precision, dimension(size(array1)) :: filtered1
    double precision, dimension(size(array2)) :: filtered2
    double precision :: refmin, refmax, refrms
    include "diff.f9h"
d256 3
a258 3
  subroutine DIFF_1D_INTEGER ( IARRAY1, NAME1, IARRAY2, NAME2, &
    & IFILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
    integer, intent(in) :: IARRAY1(:)
d260 1
a260 1
    integer, intent(in) :: IARRAY2(:)
d262 1
a262 1
    integer, intent(in), optional :: IFILLVALUE
d271 8
a278 8
    real, dimension(size(iarray1)) :: array1
    real, dimension(size(iarray2)) :: array2
    real :: fillValue
    ! So we don't have to write an integer-version of allstats
    array1 = iarray1
    array2 = iarray2
    if ( present(iFillValue) ) then
      fillValue = iFillValue
d280 2
a281 1
      fillValue = int(undefinedValue)
a282 3
    call DIFF ( ARRAY1, NAME1, ARRAY2, NAME2, &
      & FILLVALUE=FILLVALUE, CLEAN=CLEAN, WIDTH=WIDTH, FORMAT=FORMAT, &
      & WHOLEARRAY=WHOLEARRAY, STATS=STATS, RMS=RMS, LBOUND=LBOUND )
d300 12
a311 4
    real, dimension(size(array1)) :: filtered1
    real, dimension(size(array2)) :: filtered2
    real :: refmin, refmax, refrms
    include "diff.f9h"
d328 12
a339 5
    !
    double precision, dimension(product(shape(array1))) :: filtered1
    double precision, dimension(product(shape(array2))) :: filtered2
    double precision :: refmin, refmax, refrms
    include "diff.f9h"
d357 12
a368 4
    real, dimension(product(shape(array1))) :: filtered1
    real, dimension(product(shape(array2))) :: filtered2
    real :: refmin, refmax, refrms
    include "diff.f9h"
d386 8
a393 17
    real :: sizeFactor
    integer, dimension(3) :: shp
    shp = shape(array1)
    if ( product(shape(array1)) > TOOMANYELEMENTS ) then
      sizeFactor = product(shape(array1))/TOOMANYELEMENTS + 1.
      if ( shp(2) > sizeFactor ) then
        shp(2) = shp(2) / sizeFactor
      elseif ( shp(1) > sizeFactor ) then
        shp(1) = shp(1) / sizeFactor
      elseif ( shp(3) > sizeFactor ) then
        shp(3) = shp(3) / sizeFactor
      else
        return
      endif
      call DO_DIFF_3D_DOUBLE ( ARRAY1(1:shp(1), 1:shp(2), 1:shp(3)), NAME1, &
        & ARRAY2(1:shp(1), 1:shp(2), 1:shp(3)), NAME2, &
        & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d395 2
a396 2
      call DO_DIFF_3D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a399 21
  subroutine DO_DIFF_3D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
    double precision, intent(in) :: ARRAY1(:,:,:)
    character(len=*), intent(in) :: NAME1
    double precision, intent(in) :: ARRAY2(:,:,:)
    character(len=*), intent(in) :: NAME2
    double precision, intent(in), optional :: FILLVALUE
    logical, intent(in), optional :: CLEAN
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    integer, intent(in), optional :: LBOUND

    double precision, dimension(product(shape(array1))) :: filtered1
    double precision, dimension(product(shape(array2))) :: filtered2
    double precision :: refmin, refmax, refrms
    include "diff.f9h"
  end subroutine DO_DIFF_3D_DOUBLE

d415 8
a422 17
    real :: sizeFactor
    integer, dimension(3) :: shp
    shp = shape(array1)
    if ( product(shape(array1)) > TOOMANYELEMENTS ) then
      sizeFactor = product(shape(array1))/TOOMANYELEMENTS + 1.
      if ( shp(2) > sizeFactor ) then
        shp(2) = shp(2) / sizeFactor
      elseif ( shp(1) > sizeFactor ) then
        shp(1) = shp(1) / sizeFactor
      elseif ( shp(3) > sizeFactor ) then
        shp(3) = shp(3) / sizeFactor
      else
        return
      endif
      call DO_DIFF_3D_REAL ( ARRAY1(1:shp(1), 1:shp(2), 1:shp(3)), NAME1, &
        & ARRAY2(1:shp(1), 1:shp(2), 1:shp(3)), NAME2, &
        & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d424 2
a425 2
      call DO_DIFF_3D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
        & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
a428 21
  subroutine DO_DIFF_3D_REAL ( ARRAY1, NAME1, ARRAY2, NAME2, &
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
    real, intent(in) :: ARRAY1(:,:,:)
    character(len=*), intent(in) :: NAME1
    real, intent(in) :: ARRAY2(:,:,:)
    character(len=*), intent(in) :: NAME2
    real, intent(in), optional :: FILLVALUE
    logical, intent(in), optional :: CLEAN
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
    logical, intent(in), optional :: WHOLEARRAY
    logical, optional, intent(in) :: STATS
    logical, intent(in), optional :: RMS
    integer, intent(in), optional :: LBOUND

    real, dimension(product(shape(array1))) :: filtered1
    real, dimension(product(shape(array2))) :: filtered2
    real :: refmin, refmax, refrms
    include "diff.f9h"
  end subroutine DO_DIFF_3D_REAL

d2638 155
d3036 132
d3181 1
a3181 1
       "$Id: dump_0.f90,v 2.81 2008/08/27 16:23:41 pwagner Exp $"
d3185 1
d3191 3
@


2.81
log
@Added dumpSums
@
text
@d194 1
d346 38
d388 1
a388 1
  end subroutine DIFF_3D_DOUBLE
d405 38
d447 1
a447 1
  end subroutine DIFF_3D_REAL
d2914 1
a2914 1
       "$Id: dump_0.f90,v 2.80 2008/07/10 00:13:30 pwagner Exp $"
d2923 3
@


2.80
log
@SelfDiff can now print half wave lengths
@
text
@d58 2
d84 4
d110 2
a111 1
  public :: DIFF, DUMP, DUMP_2x2xN, DUMPNAMEDVALUES, DUMPTABLE, SELFDIFF
d145 5
d1511 1
a1511 1
    integer :: J, K
d1550 1
a1550 1
    integer :: J, K
d2341 92
a2825 1
    logical :: myWHOLEARRAY, mySTATS, myRMS
d2837 1
a2837 1
       "$Id: dump_0.f90,v 2.79 2008/07/09 16:30:21 pwagner Exp $"
d2846 3
@


2.79
log
@selfdiff can take optional arg unique
@
text
@d22 2
a23 1
  use MLSFillValues, only : FilterValues, IsFinite, IsInfinite, IsNaN, &
d90 2
a91 1
!      [log wholearray], [log stats], [log rms], [int lbound] ) 
d2362 2
a2363 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, unique, LBOUND )
d2375 1
d2381 3
d2385 2
d2391 7
d2404 2
a2405 1
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, unique, LBOUND )
d2417 1
d2423 1
d2425 2
d2437 2
a2438 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, unique, LBOUND )
d2450 1
d2456 3
d2460 2
d2466 7
d2734 1
a2734 1
       "$Id: dump_0.f90,v 2.78 2008/06/18 20:56:18 pwagner Exp $"
d2743 3
@


2.78
log
@New optional arg 'unique' dumps print unique elements, counts only
@
text
@d2360 1
a2360 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d2371 1
d2373 1
a2373 1
    logical, parameter :: unique = .false. 
d2376 1
a2376 1
    double precision, dimension(size(array)) :: increment
d2388 1
a2388 1
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, LBOUND )
d2399 1
d2403 2
a2404 2
    integer, dimension(size(array)) :: increment
    logical, parameter :: unique = .false. 
d2416 1
a2416 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d2427 1
d2431 2
a2432 2
    real, dimension(size(array)) :: increment
    logical, parameter :: unique = .false. 
d2699 1
a2699 1
       "$Id: dump_0.f90,v 2.77 2008/01/09 20:53:22 pwagner Exp $"
d2708 3
@


2.77
log
@When NaNs short-circuit dump or diff, print how many and where
@
text
@d25 1
a25 1
  use MLSSets, only: FindAll
d70 1
a70 1
!      [log wholearray], [log stats], [log rms], [int lbound] ) 
d179 1
d359 1
a359 1
  subroutine DUMP_1D_BIT ( ARRAY, NAME, BITNAMES, FILLVALUE, CLEAN )
d365 1
d560 1
a560 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d570 1
d578 3
d582 1
d589 19
d656 1
a656 1
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, LBOUND )
d666 1
d671 1
d675 3
d683 19
d784 1
a784 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d794 1
d805 4
d813 19
d1115 1
a1115 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND, &
d1126 1
d1135 5
a1139 1

d1146 20
d1234 1
a1234 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d1244 1
d1253 4
d1261 20
d1370 1
a1370 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND, &
d1381 1
d1390 5
a1394 1

d1401 20
d1779 1
a1779 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d1789 1
d1797 4
d1806 20
d1874 1
a1874 1
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, LBOUND )
d1884 1
d1895 4
d1903 20
d1978 1
a1978 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d1988 1
d1996 4
d2007 20
d2372 1
d2382 1
a2382 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d2402 1
d2409 1
a2409 1
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS, LBOUND )
d2429 1
d2436 1
a2436 1
      & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d2681 11
d2696 1
a2696 1
       "$Id: dump_0.f90,v 2.76 2008/01/07 21:37:57 pwagner Exp $"
d2705 3
@


2.76
log
@Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
@
text
@d23 2
a24 1
    & InfFunction, NaNFunction, ReorderFillValues, ReplaceFillValues
d48 1
d183 2
d2458 1
a2458 1
       "$Id: dump_0.f90,v 2.75 2007/10/18 23:37:41 pwagner Exp $"
d2467 3
@


2.75
log
@Added dumpTable
@
text
@d21 3
a23 3
  use MLSCommon, only: DEFAULTUNDEFINEDVALUE
  use MLSFillValues, only : FilterValues, IsFinite, &
    & ReorderFillValues, ReplaceFillValues
d241 1
a241 1
      fillValue = int(DEFAULTUNDEFINEDVALUE)
d2454 1
a2454 1
       "$Id: dump_0.f90,v 2.74 2007/10/12 23:34:49 pwagner Exp $"
d2463 3
@


2.74
log
@Using new howfar procedure to summarize diffs after peeling away outliers
@
text
@d31 1
a31 1
    & BLANKS, NEWLINE, OUTPUT, OUTPUTNAMEDVALUE
d45 1
d55 1
d76 1
a76 1
!      [[log clean], [char* format, [int width]] ) 
d79 6
d100 1
a100 1
  public :: DIFF, DUMP,DUMP_2x2xN,  DUMPNAMEDVALUES, SELFDIFF
d125 4
d163 1
a362 1
    integer :: LON
a364 1
    integer :: MyWidth
d2099 31
d2454 1
a2454 1
       "$Id: dump_0.f90,v 2.73 2007/09/20 18:39:37 pwagner Exp $"
d2463 3
@


2.73
log
@Dont interrupt tables of dumped numbers with stamping
@
text
@d25 3
a27 2
  use MLSStats1, only: ALLSTATS, FILLVALUERELATION, HOWNEAR, &
    & MLSMAX, MLSMEAN, MLSMIN, MLSSTDDEV, RATIOS
d2412 1
a2412 1
       "$Id: dump_0.f90,v 2.72 2007/09/13 21:09:57 pwagner Exp $"
d2421 3
@


2.72
log
@-rms and -s combined add new info about & how near
@
text
@d29 1
a29 1
  use OUTPUT_M, only: outputOptions, &
d357 1
d394 1
d413 1
d451 1
d467 1
d494 1
d510 1
d537 1
d563 1
d609 1
d633 1
d674 1
d687 1
d713 1
d739 1
d779 1
d798 1
d842 1
d864 1
d931 1
d953 1
d1020 1
d1045 1
d1114 1
d1138 1
d1184 1
d1197 1
d1225 1
d1250 1
d1319 1
d1335 1
d1358 1
d1374 1
d1397 1
d1418 1
d1470 1
d1494 1
d1539 1
d1564 1
d1609 1
d1633 1
d1679 1
d1705 1
d1758 1
d1782 1
d1828 1
d1846 1
d1866 1
d1884 1
d1903 1
d1933 1
d1958 1
d1976 1
d2001 1
d2017 1
d2042 1
d2058 1
d2083 1
d2370 8
d2411 1
a2411 1
       "$Id: dump_0.f90,v 2.71 2007/07/17 00:21:58 pwagner Exp $"
d2420 3
@


2.71
log
@diff stats when rms concentrate on showing ratios
@
text
@d25 2
a26 2
  use MLSStats1, only: ALLSTATS, RATIOS, FILLVALUERELATION, &
    & MLSMAX, MLSMEAN, MLSMIN, MLSSTDDEV
d2345 1
a2345 1
       "$Id: dump_0.f90,v 2.69 2007/06/14 18:38:36 pwagner Exp $"
d2354 3
@


2.70
log
@Add more dumps for complex, add 2x2xN dumps
@
text
@d25 1
a25 1
  use MLSStats1, only: ALLSTATS, FILLVALUERELATION, &
d28 1
d39 4
a42 1
! AfterSub                 character printed between row, col id and data
d45 2
d52 1
a52 1
! dumpNamedValues          dump an array of paired names and values
d76 11
d91 1
a91 1
  public :: DIFF, DUMP, DUMP_2x2xN, dumpNamedValues, SELFDIFF
d112 3
a114 3
  interface dumpNamedValues   ! dump name-value pairs, names in string list
    module procedure dumpNamedValues_DOUBLE, dumpNamedValues_INTEGER
    module procedure dumpNamedValues_REAL
d124 2
a125 2
  interface SAY_FILL
    module procedure SAY_FILL_CHAR, SAY_FILL_DOUBLE, SAY_FILL_INT, SAY_FILL_REAL
d135 16
a150 1
  character, public, parameter :: AfterSub = '#'
d152 1
a153 1
  logical, public, save ::   FILTERFILLSFROMRMS = .false.
d155 8
d166 1
a166 5

  character(len=16), public, save :: rmsFormat = '*' ! * means default format
  character(len=16), public, save :: sdFormatDefault = '(1pg14.6)'
  character(*), parameter :: sdFormatDefaultCmplx = &
    & '(1x,"(",1pg13.6,",",1pg13.6,")")'
d360 1
a360 1
    myClean = .false.
d414 1
a414 1
    myClean = .false.
d416 1
a416 1
    myTrim = .false.
d463 1
a463 1
    myClean = .false.
d504 1
a504 1
    myClean = .false.
d558 1
a558 1
    myClean = .false.
d626 1
a626 1
    myClean = .false.
d678 1
a678 1
    myClean = .false.
d729 1
a729 1
    myClean = .false.
d785 1
a785 1
    myClean = .false.
d787 1
a787 1
    myTrim = .false.
d846 1
a846 1
    myClean = .false.
d933 1
a933 1
    myClean = .false.
d1023 1
a1023 1
    myClean = .false.
d1117 1
a1117 1
    myClean = .false.
d1171 1
a1171 1
    myClean = .false.
d1222 1
a1222 1
    myClean = .false.
d1387 1
a1387 1
    myClean = .false.
d1389 1
a1389 1
    myTrim = .false.
d1597 1
a1597 1
    myClean = .false.
d1666 1
a1666 1
    myClean = .false.
d1740 1
a1740 1
    myClean = .false.
d1886 1
a1886 1
    myClean = .false.
d1924 1
a1924 1
    myClean = .false.
d1963 1
a1963 1
    myClean = .false.
d2002 1
a2002 1
    myClean = .false.
d2201 1
a2201 25
    if ( STATSONONELINE ) then
      if ( present(name) ) call output ( trim(name), advance='no' )
      call output ( ' min : max, rms: ', advance='no' )
      if ( present(mean) ) call output ( ' mean: ', advance='no' )
      call output(min, advance='no')
      call output(' : ', advance='no')
      call output(max, advance='no')
      call output(', ', advance='no')
      call output(rms, advance='no')
      if ( present(mean) ) then
        call output ( ': ', advance='no' )
        call output ( mean, advance='no' )
      end if
      call newline
    else
      if ( present(name) ) call output ( trim(name), advance='no' )
      call output ( ' min      max        rms', advance='no' )
      if ( present(mean) ) call output ( '       mean ', advance='no' )
      call newline
      call output(min, advance='no')
      call output(max, advance='no')
      call output(rms, advance='no')
      if ( present(mean) ) call output ( mean, advance='no' )
      call newline
    end if
d2215 1
a2215 25
    if ( STATSONONELINE ) then
      if ( present(name) ) call output ( trim(name), advance='no' )
      call output ( ' min : max, rms: ', advance='no' )
      if ( present(mean) ) call output ( ' mean: ', advance='no' )
      call output(min, advance='no')
      call output(' : ', advance='no')
      call output(max, advance='no')
      call output(', ', advance='no')
      call output(rms, advance='no')
      if ( present(mean) ) then
        call output ( ': ', advance='no' )
        call output ( mean, advance='no' )
      end if
      call newline
    else
      if ( present(name) ) call output ( trim(name), advance='no' )
      call output ( ' min      max        rms', advance='no' )
      if ( present(mean) ) call output ( '       mean ', advance='no' )
      call newline
      call output(min, advance='no')
      call output(max, advance='no')
      call output(rms, advance='no')
      if ( present(mean) ) call output ( mean, advance='no' )
      call newline
    end if
d2225 1
a2225 25
    if ( STATSONONELINE ) then
      if ( present(name) ) call output ( trim(name), advance='no' )
      call output ( ' min : max, rms: ', advance='no' )
      if ( present(mean) ) call output ( ' mean: ', advance='no' )
      call output(min, advance='no')
      call output(' : ', advance='no')
      call output(max, advance='no')
      call output(', ', advance='no')
      call output(rms, advance='no')
      if ( present(mean) ) then
        call output ( ': ', advance='no' )
        call output ( mean, advance='no' )
      end if
      call newline
    else
      if ( present(name) ) call output ( trim(name), advance='no' )
      call output ( ' min      max        rms', advance='no' )
      if ( present(mean) ) call output ( '       mean ', advance='no' )
      call newline
      call output(min, advance='no')
      call output(max, advance='no')
      call output(rms, advance='no')
      if ( present(mean) ) call output ( mean, advance='no' )
      call newline
    end if
d2313 29
d2354 3
@


2.69
log
@Allow separate rmsFormat to be set at class level
@
text
@d74 1
a74 1
  public :: DIFF, DUMP, dumpNamedValues, SELFDIFF
d89 1
a89 1
    module procedure DUMP_3D_REAL
d92 3
d792 2
a793 1
  subroutine DUMP_2D_COMPLEX ( ARRAY, NAME, CLEAN, WIDTH, FORMAT )
d800 2
d803 1
a803 1
    logical :: myClean
d807 1
a807 1
    real(rk), parameter :: MyFillValue = 0.0_rk
d819 6
d835 1
a835 1
      if ( size(array,2) >= min(5,size(array,1)) .or. myClean ) then
d879 2
a880 1
  subroutine DUMP_2D_DCOMPLEX ( ARRAY, NAME, CLEAN, WIDTH, FORMAT )
d887 2
d890 1
a890 1
    logical :: myClean
d894 1
a894 1
    real(rk), parameter :: MyFillValue = 0.0_rk
d906 6
d922 1
a922 1
      if ( size(array,2) >= min(5,size(array,1)) .or. myClean ) then
d967 2
a968 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d979 1
d981 1
a981 1
    logical :: myClean
d997 3
d1010 1
a1010 1
      if ( size(array,2) >= min(5,size(array,1)) .or. myClean ) then
d1166 2
a1167 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
d1178 1
d1180 1
a1180 1
    logical :: myClean
d1196 3
d1209 1
a1209 1
      if ( size(array,2) >= min(5,size(array,1)) .or. myClean ) then
d1256 74
d1401 135
d2352 1
a2352 1
       "$Id: dump_0.f90,v 2.68 2007/04/14 00:32:47 vsnyder Exp $"
d2361 3
@


2.68
log
@Remove OPTIONAL attribute from NAME1 and NAME args of DIFF_...
@
text
@d28 2
a29 1
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, OUTPUTNAMEDVALUE
d124 1
d1920 5
d1950 1
d1959 4
d1988 1
d2112 1
a2112 1
       "$Id: dump_0.f90,v 2.67 2007/04/03 02:49:23 vsnyder Exp $"
d2121 3
@


2.67
log
@Don't look at non-present dummy argument
@
text
@d144 1
a144 1
    character(len=*), intent(in), optional :: NAME1
d146 1
a146 1
    character(len=*), intent(in), optional :: NAME2
d165 1
a165 1
    character(len=*), intent(in), optional :: NAME1
d167 1
a167 1
    character(len=*), intent(in), optional :: NAME2
d196 1
a196 1
    character(len=*), intent(in), optional :: NAME1
d198 1
a198 1
    character(len=*), intent(in), optional :: NAME2
d217 1
a217 1
    character(len=*), intent(in), optional :: NAME1
d219 1
a219 1
    character(len=*), intent(in), optional :: NAME2
d238 1
a238 1
    character(len=*), intent(in), optional :: NAME1
d240 1
a240 1
    character(len=*), intent(in), optional :: NAME2
d259 1
a259 1
    character(len=*), intent(in), optional :: NAME1
d261 1
a261 1
    character(len=*), intent(in), optional :: NAME2
d280 1
a280 1
    character(len=*), intent(in), optional :: NAME1
d282 1
a282 1
    character(len=*), intent(in), optional :: NAME2
d2099 1
a2099 1
       "$Id: dump_0.f90,v 2.66 2007/03/23 00:14:30 pwagner Exp $"
d2108 3
@


2.66
log
@new optional maxlon arg to dumping n-d chars; sdFormatDefault for numeric dumps public and changeable
@
text
@d980 1
a980 1
    else 
d1174 1
a1174 1
    else 
d1885 1
a1885 1
    character(len=*), intent(in) :: Name
d1889 1
a1889 1
      call output ( trim(name), advance='no' )
d1913 1
a1913 1
    character(len=*), intent(in) :: Name
d1919 1
a1919 1
      call output ( trim(name), advance='no' )
d1933 1
a1933 1
      call output ( trim(name), advance='no' )
d1946 1
a1946 1
    character(len=*), intent(in) :: Name
d1952 1
a1952 1
      call output ( trim(name), advance='no' )
d1966 1
a1966 1
      call output ( trim(name), advance='no' )
d1979 1
a1979 1
    character(len=*), intent(in) :: Name
d1985 1
a1985 1
      call output ( trim(name), advance='no' )
d1999 1
a1999 1
      call output ( trim(name), advance='no' )
d2099 1
a2099 1
       "$Id: dump_0.f90,v 2.65 2007/03/07 21:01:45 pwagner Exp $"
d2108 3
@


2.65
log
@Some small changes unrelated to real bugs elsewhere
@
text
@d123 2
a124 2
  character(*), parameter :: MyFormatDefault = '(1pg14.6)'
  character(*), parameter :: MyFormatDefaultCmplx = &
d355 1
a355 1
  subroutine DUMP_1D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN, TRIM )
d361 1
d379 1
d426 1
a426 1
    myFormat = MyFormatDefaultCmplx
d467 1
a467 1
    myFormat = MyFormatDefaultCmplx
d521 1
a521 1
    myFormat = myFormatDefault
d692 1
a692 1
    myFormat = myFormatDefault
d726 1
a726 1
  subroutine DUMP_2D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN, TRIM )
d732 1
d750 1
d759 1
a759 1
      call dump ( array(:,1), name, fillValue=fillValue, clean=clean, trim=trim )
d808 1
a808 1
    myFormat = MyFormatDefaultCmplx
d886 1
a886 1
    myFormat = MyFormatDefaultCmplx
d969 1
a969 1
    myFormat = MyFormatDefault
d1163 1
a1163 1
    myFormat = MyFormatDefault
d1224 1
a1224 1
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN, TRIM )
d1230 1
d1250 1
d1262 1
a1262 1
        & clean=clean, trim=trim )
d1321 1
a1321 1
    myFormat = MyFormatDefault
d1466 1
a1466 1
    myFormat = MyFormatDefault
d2099 1
a2099 1
       "$Id: dump_0.f90,v 2.64 2007/01/31 00:05:43 pwagner Exp $"
d2108 3
@


2.64
log
@Added interface for dumping bit arrays
@
text
@d28 1
a28 1
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT
d2093 1
a2093 1
       "$Id: dump_0.f90,v 2.63 2006/08/23 20:06:25 pwagner Exp $"
d2102 3
@


2.63
log
@Restored more backward-compatible arglist to DUMP_STRLIST
@
text
@d19 1
d45 1
a45 1
! DUMP_NAME_V_PAIRS        dump an array of paired names and values
d65 1
a65 1
! dump_name_v_pairs ( values, strlist names,
d73 1
a73 1
  public :: DIFF, DUMP, DUMP_NAME_V_PAIRS, SELFDIFF
d81 1
a81 1
    module procedure DUMP_1D_CHAR, DUMP_1D_COMPLEX, DUMP_1D_DCOMPLEX
d91 3
a93 3
  interface DUMP_NAME_V_PAIRS   ! dump name-value pairs, names in string list
    module procedure DUMP_NAME_V_PAIRS_DOUBLE, DUMP_NAME_V_PAIRS_INTEGER
    module procedure DUMP_NAME_V_PAIRS_REAL
d298 56
d1625 1
a1625 1
  ! -----------------------------------  DUMP_NAME_V_PAIRS  -----
d1628 2
a1629 2
  ! -----------------------------------  DUMP_NAME_V_PAIRS_DOUBLE  -----
  subroutine DUMP_NAME_V_PAIRS_DOUBLE ( VALUES, NAMES, CLEAN, FORMAT, WIDTH )
d1665 1
a1665 1
  end subroutine DUMP_NAME_V_PAIRS_DOUBLE
d1667 2
a1668 2
  ! ----------------------------------  DUMP_NAME_V_PAIRS_INTEGER  -----
  subroutine DUMP_NAME_V_PAIRS_INTEGER ( VALUES, NAMES, CLEAN, FORMAT, WIDTH )
d1704 1
a1704 1
  end subroutine DUMP_NAME_V_PAIRS_INTEGER
d1706 2
a1707 2
  ! -------------------------------------  DUMP_NAME_V_PAIRS_REAL  -----
  subroutine DUMP_NAME_V_PAIRS_REAL ( VALUES, NAMES, CLEAN, FORMAT, WIDTH )
d1743 1
a1743 1
  end subroutine DUMP_NAME_V_PAIRS_REAL
d2093 1
a2093 1
       "$Id: dump_0.f90,v 2.62 2006/08/22 20:40:04 pwagner Exp $"
d2102 3
@


2.62
log
@Added required arg=separator to DUMP_STRLIST
@
text
@a38 2
! FILLVALUERELATION        consider whether one of {"=" (default), "<", ">"}
!                            when calculating %ages (and possibly rms, etc.)
a115 1
  ! character(len=1), public, save ::   FILLVALUERELATION = '=' ! {'=','<','>'}
d1516 3
a1518 3
  subroutine DUMP_STRLIST ( STRING, SEPARATOR, NAME, FILLVALUE, CLEAN )
    ! Dumps a ','-separated list of strings
    character(len=*), intent(in) :: SEPARATOR
d1523 1
d1529 3
a1531 1
    ! character(len=1), parameter :: SEPARATOR = ','
d1533 8
d1548 2
a1549 5
    if ( len(SEPARATOR) > 1 ) then
      call output( 'Illegal args to DUMP_STRLIST', advance='yes' )
      call output( 'expect ( char* STRING, char SEPARATOR, [NAME], [FILLVALUE], [CLEAN] )', advance='yes' )
      return
    endif
d2036 1
a2036 1
       "$Id: dump_0.f90,v 2.61 2006/07/11 00:24:04 pwagner Exp $"
d2045 3
@


2.61
log
@use fillValue properly when computing rms etc.
@
text
@d1519 1
a1519 1
  subroutine DUMP_STRLIST ( STRING, NAME, FILLVALUE, CLEAN )
d1521 1
d1531 1
a1531 1
    character(len=*), parameter :: SEPARATOR = ','
d1539 7
a1545 1

d2031 1
a2031 1
       "$Id: dump_0.f90,v 2.60 2006/06/24 23:07:04 pwagner Exp $"
d2040 3
@


2.60
log
@Changes to reduce memory footprint computing statistics
@
text
@d24 2
a25 1
  use MLSStats1, only: ALLSTATS
d37 4
d118 2
a119 1
  character(len=1), public, save ::   RELATIONFORPCTAGES = '=' ! {'=','<','>'}
d1816 1
a1816 1
      call output( RelationForPctages, advance='no' )
d1818 1
a1818 1
      call output( RelationForPctages, advance='no' )
d2024 1
a2024 1
       "$Id: dump_0.f90,v 2.59 2006/06/09 18:50:12 pwagner Exp $"
d2033 3
@


2.59
log
@Avoid dumping an entire array if all elements the same
@
text
@d22 1
a22 1
    & RemoveFillValues, ReplaceFillValues
a153 2
    double precision, dimension(size(array1)) :: prestats1
    double precision, dimension(size(array2)) :: prestats2
a205 2
    real, dimension(size(array1)) :: prestats1
    real, dimension(size(array2)) :: prestats2
d225 2
a226 4
    double precision, dimension(size(array1,1), size(array1,2)) :: filtered1
    double precision, dimension(size(array2,1), size(array2,2)) :: filtered2
    double precision, dimension(product(shape(array1))) :: prestats1
    double precision, dimension(product(shape(array2))) :: prestats2
d246 2
a247 4
    real, dimension(size(array1,1), size(array1,2)) :: filtered1
    real, dimension(size(array2,1), size(array2,2)) :: filtered2
    real, dimension(product(shape(array1))) :: prestats1
    real, dimension(product(shape(array2))) :: prestats2
d267 2
a268 4
    double precision, dimension(size(array1,1), size(array1,2), size(array1,3)) :: filtered1
    double precision, dimension(size(array2,1), size(array2,2), size(array2,3)) :: filtered2
    double precision, dimension(product(shape(array1))) :: prestats1
    double precision, dimension(product(shape(array2))) :: prestats2
d288 2
a289 4
    real, dimension(size(array1,1), size(array1,2), size(array1,3)) :: filtered1
    real, dimension(size(array2,1), size(array2,2), size(array2,3)) :: filtered2
    real, dimension(product(shape(array1))) :: prestats1
    real, dimension(product(shape(array2))) :: prestats2
d966 2
a967 1
  subroutine DUMP_2D_INTEGER ( ARRAY, NAME, CLEAN, FORMAT, WIDTH )
d970 1
d974 4
d983 6
a988 1

d1001 2
a1002 1
      call dump ( array(:,1), name, clean=clean, format=format, width=width )
d1009 1
a1009 1
            if ( any(array(i,j:min(j+myWidth-1, size(array,2))) /= 0) ) then
d1011 1
a1011 1
                & numZeroRows, 0, inc=3 )
d1016 1
a1016 1
          if ( myClean .or. any(array(i,j:min(j+myWidth-1, size(array,2))) /= 0) ) then
d1029 1
a1029 1
        & numZeroRows, 0 )
d2018 1
a2018 1
       "$Id: dump_0.f90,v 2.58 2006/05/24 20:38:14 pwagner Exp $"
d2027 3
@


2.58
log
@Allow any of 3 ordering relations for dumping pct
@
text
@d25 1
a25 1
  use MLSStringLists, only: GetStringElement, NumStringElements
d111 1
d1749 16
d2018 1
a2018 1
       "$Id: dump_0.f90,v 2.57 2006/04/20 01:09:30 vsnyder Exp $"
d2027 3
@


2.57
log
@Don't print lines of zeroes in complex dumps
@
text
@d109 1
d112 2
d1792 5
a1796 1
      call output ( ' =, != (%) ', advance='no' )
d2001 1
a2001 1
       "$Id: dump_0.f90,v 2.56 2006/03/22 23:48:52 vsnyder Exp $"
d2010 3
@


2.56
log
@Print 'lines ... not printed' instead of 'rows...' to avoid confusion with matrices
@
text
@d742 2
d755 1
d770 12
a781 3
              call output ( i, places=max(4,ilog10(size(array,1))+1) )
              call output ( j, places=max(4,ilog10(size(array,2))+1) )
              call output ( afterSub )
a782 4
            do k = j, min(j+myWidth-1, size(array,2))
              call output ( array(i,k), format=myFormat )
            end do
            call output ( '', advance='yes' )
d789 13
a801 8
          do i = 1, size(array,1), width
            call output ( i, places=max(4,ilog10(size(array,1))+1) )      
            call output ( j, places=max(4,ilog10(size(array,2))+1) )      
            call output ( afterSub )                                      
            do k = i, min(i+width-1, size(array,1))
              call output ( array(k,j), format=myFormat )
            end do
            call output ( '', advance='yes' )
d820 2
d833 1
d848 12
a859 3
              call output ( i, places=max(4,ilog10(size(array,1))+1) )
              call output ( j, places=max(4,ilog10(size(array,2))+1) )
              call output ( afterSub )
a860 4
            do k = j, min(j+myWidth-1, size(array,2))
              call output ( array(i,k), format=myFormat )
            end do
            call output ( '', advance='yes' )
d867 13
a879 8
          do i = 1, size(array,1), width
            call output ( i, places=max(4,ilog10(size(array,1))+1) )      
            call output ( j, places=max(4,ilog10(size(array,2))+1) )      
            call output ( afterSub )                                      
            do k = i, min(i+width-1, size(array,1))
              call output ( array(k,j), format=myFormat )
            end do
            call output ( '', advance='yes' )
d1994 1
a1994 1
       "$Id: dump_0.f90,v 2.55 2006/03/15 17:34:28 pwagner Exp $"
d2003 3
@


2.55
log
@Fixed bug causing incorrect rms when diffing with fill values
@
text
@d1952 1
a1952 1
    call output ( ' rows of ', advance='no' )
d1968 1
a1968 1
       "$Id: dump_0.f90,v 2.54 2006/03/03 23:04:55 pwagner Exp $"
d1977 3
@


2.54
log
@May dump logical-valued hashes
@
text
@d21 2
a22 1
  use MLSFillValues, only : FilterValues, IsFinite, ReplaceFillValues
d150 2
d204 2
d227 2
d250 2
d273 2
d296 2
d1968 1
a1968 1
       "$Id: dump_0.f90,v 2.53 2006/02/28 21:42:29 pwagner Exp $"
d1977 3
@


2.53
log
@Replace fillvalues with 0 before computing rms (should actually remove)
@
text
@d84 1
a84 1
    module procedure DUMP_HASH, DUMP_STRLIST
d1398 2
a1399 2
  ! -----------------------------------------------  DUMP_HASH  -----
  subroutine DUMP_HASH ( COUNTEMPTY, KEYS, VALUES, NAME, SEPARATOR )
d1432 36
a1467 1
  end subroutine DUMP_HASH
d1955 1
a1955 1
       "$Id: dump_0.f90,v 2.52 2006/01/27 01:01:37 pwagner Exp $"
d1964 3
@


2.52
log
@Can now dump hashes
@
text
@d21 1
a21 1
  use MLSFillValues, only : FilterValues, IsFinite
a112 1
  real :: pctNonFill, pctFill
d120 12
a131 1
 ! ---------------------------------------------  DIFF_1D_DOUBLE  -----
a152 1
 ! ---------------------------------------------  DIFF_1D_INTEGER  -----
a183 1
 ! ---------------------------------------------  DIFF_1D_REAL  -----
a204 1
  ! ---------------------------------------------  DIFF_2D_DOUBLE  -----
a225 1
  ! ---------------------------------------------  DIFF_2D_REAL  -----
a246 1
  ! ---------------------------------------------  DIFF_3D_DOUBLE  -----
a267 1
  ! ---------------------------------------------  DIFF_3D_REAL  -----
d1706 24
d1920 1
a1920 1
       "$Id: dump_0.f90,v 2.51 2005/12/17 00:58:56 pwagner Exp $"
d1929 3
@


2.51
log
@dumps of rms, etc. should appear uniform
@
text
@d57 4
a60 1
! dump_name_v_pairs ( values, char* names,
d63 3
a65 1
!       names is a comma-separated list of corresponding names
d84 1
a84 1
    module procedure DUMP_STRING
d1394 39
a1432 2
  ! -----------------------------------------------  DUMP_STRING  -----
  subroutine DUMP_STRING ( STRING, NAME, FILLVALUE, CLEAN )
d1466 1
a1466 1
  end subroutine DUMP_STRING
d1468 3
d1892 1
a1892 1
       "$Id: dump_0.f90,v 2.50 2005/12/16 23:25:13 pwagner Exp $"
d1901 3
@


2.50
log
@dumpSize moved from dump0 to output_m
@
text
@d1730 2
a1731 2
    integer, intent(in) :: rms
    integer, intent(in), optional :: mean
d1847 1
a1847 1
       "$Id: dump_0.f90,v 2.49 2005/12/16 00:04:06 pwagner Exp $"
d1856 3
@


2.49
log
@Changes to reflect new MLSFillValues module
@
text
@d25 1
a25 1
  use OUTPUT_M, only: BLANKS, OUTPUT
a40 2
! DUMPSIZE                 print a nicely-formatted memory size 
!                             (should be moved to output_M?)
a60 3
! DumpSize ( n, [char* advance], [units] )
!       where n can be an int or a real, and 
!       units is a scalar of the same type, if present
d63 1
a63 1
  public :: DIFF, DUMP, DUMP_NAME_V_PAIRS, DUMPSIZE, SELFDIFF
d90 2
a91 2
  interface DUMPSIZE
    module procedure DUMPSIZE_INTEGER, DUMPSIZE_REAL
a92 1

a1542 50
  ! --------------------------------------------- DumpSize_integer -----
  subroutine DumpSize_integer ( n, advance, units )
    integer, intent(in) :: N
    character(len=*), intent(in), optional :: ADVANCE
    integer, intent(in), optional :: units ! E.g., 1024 for kB
    ! Executable
    if ( present(units) ) then
      call dumpSize ( n*1.0, advance=advance, units=units*1.0 )
    else
      call dumpSize ( n*1.0, advance=advance )
    endif
  end subroutine DumpSize_integer

  ! ------------------------------------------------ DumpSize_real -----
  subroutine DumpSize_real ( n, advance, units )
    real, intent(in) :: N
    character(len=*), intent(in), optional :: ADVANCE
    real, intent(in), optional :: units
    ! Local parameters
    real, parameter :: KB = 1024.0
    real, parameter :: MB = KB * 1024.0
    real, parameter :: GB = MB * 1024.0
    real, parameter :: TB = GB * 1024.0
    real            :: myUnits
    ! Make a 'nice' output
    myUnits = 1.0
    if ( present(units) ) myUnits = units
    if ( myUnits == 0.0 ) then
      call output ( n, format='(e12.1)' )
      call output ( ' (illegal units)', advance=advance )
      return
    endif
    if ( n < kb/myUnits ) then
      call output ( n*myUnits, format='(f6.1)' )
      call output ( ' bytes', advance=advance )
    else if ( n < Mb/myUnits ) then
      call output ( n*myUnits/kb, format='(f6.1)' )
      call output ( ' kb', advance=advance )
    else if ( n < Gb/myUnits ) then
      call output ( n*myUnits/Mb, format='(f6.1)' )
      call output ( ' Mb', advance=advance )
    else if ( n < Tb/myUnits ) then
      call output ( n*myUnits/Gb, format='(f6.1)' )
      call output ( ' Gb', advance=advance )
    else
      call output ( n*myUnits/Tb, format='(f6.1)' )
      call output ( ' Tb', advance=advance )
    end if
  end subroutine DumpSize_real

d1657 102
d1847 1
a1847 1
       "$Id: dump_0.f90,v 2.48 2005/11/04 18:49:02 pwagner Exp $"
d1856 3
@


2.48
log
@Added SelfDiff procedures to dump diffs among consecutive 1d array elems
@
text
@d20 2
a21 1
  use MLSCommon, only : FilterValues, IsFinite
d23 1
d27 1
a27 1
  implicit NONE
d29 38
a66 1
  public :: AfterSub, DIFF, DUMP, DUMP_NAME_V_PAIRS, DUMPSIZE, SELFDIFF
d68 4
a71 2
  interface DIFF        ! dump diffs n-d arrays of numeric type
    module procedure DIFF_1D_DOUBLE, DIFF_1D_REAL
d109 1
a109 1
  character, parameter :: AfterSub = '#'
d140 1
d144 32
d194 1
d216 1
d238 1
d260 1
d282 1
d1352 2
d1801 1
a1801 1
       "$Id: dump_0.f90,v 2.47 2005/10/03 18:05:52 pwagner Exp $"
d1810 3
@


2.47
log
@Allocated memory now dumped in units of MEMORY_UNITS
@
text
@d27 1
a27 1
  public :: AfterSub, DIFF, DUMP, DUMP_NAME_V_PAIRS, DUMPSIZE
d49 5
d1518 78
d1720 1
a1720 1
       "$Id: dump_0.f90,v 2.46 2005/07/20 01:33:47 vsnyder Exp $"
d1729 3
@


2.46
log
@Simplify DumpSize routines
@
text
@d1464 1
a1464 1
  subroutine DumpSize_integer ( n, advance )
d1467 7
a1473 2
    ! Local parameters
    call dumpSize ( n*1.0, advance )
d1477 1
a1477 1
  subroutine DumpSize_real ( n, advance )
d1480 1
d1485 2
d1488 9
a1496 2
    if ( n < kb ) then
      call output ( n, format='(f6.1)' )
d1498 2
a1499 2
    else if ( n < Mb ) then
      call output ( n/kb, format='(f6.1)' )
d1501 2
a1502 2
    else if ( n < Gb ) then
      call output ( n/Mb, format='(f6.1)' )
d1504 3
d1508 2
a1509 2
      call output ( n/Gb, format='(f6.1)' )
      call output ( ' Gb', advance=advance )
d1637 1
a1637 1
       "$Id: dump_0.f90,v 2.45 2005/06/22 17:25:48 pwagner Exp $"
d1646 3
@


2.45
log
@Reworded Copyright statement, moved rcs id
@
text
@d59 1
a59 1
       "$RCSfile: $"
d1463 1
a1463 1
  ! ----------------------------------------------------- DumpSize_integer -----
d1468 1
a1468 17
    integer, parameter :: KB = 1024
    integer, parameter :: MB = KB * 1024
    integer, parameter :: GB = MB * 1024
    ! Make a 'nice' output
    if ( n < kb ) then
      call output ( n*1.0, format='(f6.1)' )
      call output ( ' bytes', advance=advance )
    else if ( n < Mb ) then
      call output ( n*1.0/kb, format='(f6.1)' )
      call output ( ' kb', advance=advance )
    else if ( n < Gb ) then
      call output ( n*1.0/Mb, format='(f6.1)' )
      call output ( ' Mb', advance=advance )
    else
      call output ( n*1.0/Gb, format='(f6.1)' )
      call output ( ' Gb', advance=advance )
    end if
d1471 1
a1471 1
  ! ----------------------------------------------------- DumpSize_real -----
d1476 3
a1478 3
    integer, parameter :: KB = 1024
    integer, parameter :: MB = KB * 1024
    integer, parameter :: GB = MB * 1024
d1481 1
a1481 1
      call output ( n*1.0, format='(f6.1)' )
d1484 1
a1484 1
      call output ( n*1.0/kb, format='(f6.1)' )
d1487 1
a1487 1
      call output ( n*1.0/Mb, format='(f6.1)' )
d1490 1
a1490 1
      call output ( n*1.0/Gb, format='(f6.1)' )
d1619 1
a1619 1
       "$Id: $"
d1628 3
@


2.44
log
@Added diff routines
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d57 1
a57 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: dump_0.f90,v 2.43 2004/12/14 21:31:59 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d59 1
a59 1
       "$RCSfile: dump_0.f90,v $"
d1633 5
d1644 3
@


2.43
log
@Optional trim arg added to multi-dim char dumps
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d11 2
d19 1
a19 1
  public :: AfterSub, DUMP, DUMP_NAME_V_PAIRS, DUMPSIZE
d21 5
d51 1
a51 1
       "$Id: dump_0.f90,v 2.42 2004/08/16 17:09:14 pwagner Exp $"
d71 126
d756 2
a757 1
  subroutine DUMP_2D_DOUBLE ( ARRAY, NAME, FILLVALUE, CLEAN, FORMAT )
d762 1
d764 4
d780 1
d939 1
a939 1
    & FILLVALUE, CLEAN, FORMAT, WHOLEARRAY, STATS, RMS )
d944 1
d949 1
d1095 1
a1095 1
    & FILLVALUE, CLEAN, FORMAT, WHOLEARRAY, STATS, RMS )
d1100 1
d1105 1
d1240 1
a1240 1
    & FILLVALUE, CLEAN, FORMAT, WHOLEARRAY, STATS, RMS )
d1245 1
d1250 2
d1634 3
@


2.42
log
@3d integer dumps interface redone like others
@
text
@d44 1
a44 1
       "$Id: dump_0.f90,v 2.41 2004/08/04 23:19:01 pwagner Exp $"
d65 1
a65 1
  subroutine DUMP_1D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN )
d70 1
d73 1
d75 1
d84 4
d94 1
a94 1
      call output ( array(1), advance='yes' )
d108 1
a108 1
              call output ( array(k) // ' ' )
d434 1
a434 1
  subroutine DUMP_2D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN )
d439 1
d442 1
d444 1
d453 4
d463 1
a463 1
      call output ( array(1,1), advance='yes' )
d465 1
a465 1
      call dump ( array(:,1), name, fillValue=fillValue, clean=clean )
d481 1
a481 1
                call output ( array(i,k) // ' ' )
d883 1
a883 1
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN )
d888 1
d890 3
a892 1
    logical :: myClean
d904 4
d916 1
a916 1
      call output ( array(1,1,1), advance='yes' )
d919 1
a919 1
        & clean=clean )
d922 1
a922 1
        & name, fillValue=fillValue, clean=clean )
d939 1
a939 1
                  call output ( array(i,j,l) // ' ' )
d1487 3
@


2.41
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d44 1
a44 1
       "$Id: dump_0.f90,v 2.40 2004/07/23 19:47:20 vsnyder Exp $"
d997 2
a998 1
  subroutine DUMP_3D_INTEGER ( ARRAY, NAME, CLEAN, FORMAT, WIDTH )
d1001 1
d1005 4
d1017 5
d1048 1
a1048 1
              if ( any(array(i,j,k:min(k+myWidth-1, size(array,3))) /= 0) ) then
d1050 1
a1050 1
                  & k, size(array,3) /), numZeroRows, 0, inc=3 )
d1055 1
a1055 1
            if ( myClean .or. any(array(i,j,k:min(k+myWidth-1, size(array,3))) /= 0) ) then
d1069 1
a1069 1
        & k-myWidth, size(array,3) /), numZeroRows, 0 )
d1466 3
@


2.40
log
@Add LBOUND to dump_1d_[double,integer,real]
@
text
@d12 1
a12 1
  use MLSStrings, only: GetStringElement, NumStringElements
d44 1
a44 1
       "$Id: dump_0.f90,v 2.39 2004/07/23 18:34:59 vsnyder Exp $"
d1455 3
@


2.39
log
@Add LBOUND argument to Dump_1d_logical
@
text
@d44 1
a44 1
       "$Id: dump_0.f90,v 2.38 2004/07/21 19:57:21 pwagner Exp $"
d194 1
a194 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS )
d204 1
d206 3
a209 2
    integer :: J, K, MyWidth
    integer, parameter :: DefaultWidth = 5
d224 2
d230 1
a230 1
    else if ( size(array) == 1 ) then
d246 1
a246 1
            call say_fill ( (/ j-1, size(array) /), numZeroRows, myFillValue, inc=1 )
d264 1
a264 1
    & FILLVALUE, CLEAN, FORMAT, WIDTH, WHOLEARRAY, STATS, RMS )
d274 1
d276 1
a276 1
    integer :: J, K
d290 2
d296 1
a296 1
    else if ( size(array) == 1 ) then
d305 1
a305 1
            call say_fill ( (/ j-1, size(array) /), numZeroRows, myFillValue, inc=1 )
d364 1
a364 1
    & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS )
d374 1
d376 3
a379 2
    integer :: J, K, MyWidth
    integer, parameter :: DefaultWidth = 5
d395 2
d401 1
a401 1
    else if ( size(array) == 1 ) then
d410 1
a410 1
            call say_fill ( (/ j-1, size(array) /), numZeroRows, myFillValue, inc=1 )
d1455 3
@


2.38
log
@New rms, wholeArray options to some dumps
@
text
@d44 1
a44 1
       "$Id: dump_0.f90,v 2.37 2004/06/11 19:04:29 pwagner Exp $"
d319 1
a319 1
  subroutine DUMP_1D_LOGICAL ( ARRAY, NAME, CLEAN )
d323 1
d325 1
d327 3
a329 1
    integer :: J, K
d336 1
a336 1
    else if ( size(array) == 1 ) then
d344 1
a344 1
          call output ( j, max(4,ilog10(size(array))+1) )
d1444 3
@


2.37
log
@which_ints_are_it renamed findAll, moved MLSSets.f90
@
text
@d7 3
d44 1
a44 1
       "$Id: dump_0.f90,v 2.36 2004/05/27 23:25:33 pwagner Exp $"
d54 3
d193 2
a194 1
  subroutine DUMP_1D_DOUBLE ( ARRAY, NAME, FILLVALUE, CLEAN, WIDTH, FORMAT, STATS )
d201 1
d203 1
a211 3
    logical :: MyStats
    integer :: numNonFill, numFill
    real :: pctNonFill, pctFill
a212 2
    myStats=.false.
    if ( present(stats) ) myStats=stats
d259 2
a260 1
  subroutine DUMP_1D_INTEGER ( ARRAY, NAME, FILLVALUE, CLEAN, FORMAT, WIDTH, STATS )
d267 1
d269 1
a275 3
    logical :: MyStats
    integer :: numNonFill, numFill
    real :: pctNonFill, pctFill
a277 2
    myStats=.false.
    if ( present(stats) ) myStats=stats
d352 2
a353 1
  subroutine DUMP_1D_REAL ( ARRAY, NAME, FILLVALUE, CLEAN, WIDTH, FORMAT, STATS )
d360 1
d362 1
a369 3
    logical :: MyStats
    integer :: numNonFill, numFill
    real :: pctNonFill, pctFill
a371 2
    myStats=.false.
    if ( present(stats) ) myStats=stats
d769 2
a770 1
  subroutine DUMP_2D_REAL ( ARRAY, NAME, FILLVALUE, CLEAN, FORMAT )
d776 3
d791 1
d916 2
a917 1
  subroutine DUMP_3D_DOUBLE ( ARRAY, NAME, FILLVALUE, CLEAN, FORMAT, STATS )
d923 1
d925 1
a932 3
    logical :: MyStats
    integer :: numNonFill, numFill
    real :: pctNonFill, pctFill
a933 2
    myStats=.false.
    if ( present(stats) ) myStats=stats
d1048 2
a1049 1
  subroutine DUMP_3D_REAL ( ARRAY, NAME, FILLVALUE, CLEAN, FORMAT, STATS )
d1055 1
d1057 1
a1063 3
    logical :: MyStats
    integer :: numNonFill, numFill
    real :: pctNonFill, pctFill
a1064 2
    myStats=.false.
    if ( present(stats) ) myStats=stats
d1440 3
@


2.36
log
@Added stats parameter; also more 1-d get fillvalue
@
text
@d8 1
d41 1
a41 1
       "$Id: dump_0.f90,v 2.35 2004/04/05 17:47:43 livesey Exp $"
d49 1
d211 1
a211 20
    if ( myStats ) then
      numNonFill = count(array /= myFillValue)
      numFill = size(array) - numNonFill
      pctNonFill = numNonFill / ( 0.01 * (numNonFill+numFill) )
      pctFill = 100.0 - pctNonFill
      if ( present(name) ) call output(trim(name) // ' ', advance='no')
      call output('Statistics on elements = or != ', advance='no')
      call output(myFillValue, advance='yes')
      call output('"!=" ', advance='no')
      call output(numNonFill, advance='no')
      call output('( ', advance='no')
      call output(pctNonFill, advance='no')
      call output('%)   ', advance='no')
      call output(' "=" ', advance='no')
      call output(numFill, advance='no')
      call output('( ', advance='no')
      call output(pctFill, advance='no')
      call output('%)   ', advance='yes')
      return
    endif
d278 1
a278 20
    if ( myStats ) then
      numNonFill = count(array /= myFillValue)
      numFill = size(array) - numNonFill
      pctNonFill = numNonFill / ( 0.01 * (numNonFill+numFill) )
      pctFill = 100.0 - pctNonFill
      if ( present(name) ) call output(trim(name) // ' ', advance='no')
      call output('Statistics on elements = or != ', advance='no')
      call output(myFillValue, advance='yes')
      call output('"!=" ', advance='no')
      call output(numNonFill, advance='no')
      call output('( ', advance='no')
      call output(pctNonFill, advance='no')
      call output('%)   ', advance='no')
      call output(' "=" ', advance='no')
      call output(numFill, advance='no')
      call output('( ', advance='no')
      call output(pctFill, advance='no')
      call output('%)   ', advance='yes')
      return
    endif
d374 1
a374 20
    if ( myStats ) then
      numNonFill = count(array /= myFillValue)
      numFill = size(array) - numNonFill
      pctNonFill = numNonFill / ( 0.01 * (numNonFill+numFill) )
      pctFill = 100.0 - pctNonFill
      if ( present(name) ) call output(trim(name) // ' ', advance='no')
      call output('Statistics on elements = or != ', advance='no')
      call output(myFillValue, advance='yes')
      call output('"!=" ', advance='no')
      call output(numNonFill, advance='no')
      call output('( ', advance='no')
      call output(pctNonFill, advance='no')
      call output('%)   ', advance='no')
      call output(' "=" ', advance='no')
      call output(numFill, advance='no')
      call output('( ', advance='no')
      call output(pctFill, advance='no')
      call output('%)   ', advance='yes')
      return
    endif
a392 8
!         if (.not. myClean) then
!           call output ( j, max(defaultWidth-1,ilog10(size(array))+1) )
!           call output ( afterSub )
!         end if
!         do k = j, min(j+myWidth-1, size(array))
!           call output ( array(k), myFormat )
!         end do
!        call output ( '', advance='yes' )
d867 1
a867 1
    call which_ints_are_it( (/ size(array, 1), size(array, 2), size(array, 3)/), &
d933 2
a934 20
    if ( myStats ) then
      numNonFill = count(array /= myFillValue)
      numFill = size(array) - numNonFill
      pctNonFill = numNonFill / ( 0.01 * (numNonFill+numFill) )
      pctFill = 100.0 - pctNonFill
      if ( present(name) ) call output(trim(name) // ' ', advance='no')
      call output('Statistics on elements = or != ', advance='no')
      call output(myFillValue, advance='yes')
      call output('"!=" ', advance='no')
      call output(numNonFill, advance='no')
      call output('( ', advance='no')
      call output(pctNonFill, advance='no')
      call output('%)   ', advance='no')
      call output(' "=" ', advance='no')
      call output(numFill, advance='no')
      call output('( ', advance='no')
      call output(pctFill, advance='no')
      call output('%)   ', advance='yes')
      return
    endif
d997 1
a997 1
    call which_ints_are_it( (/ size(array, 1), size(array, 2), size(array, 3)/), &
a1065 20
    if ( myStats ) then
      numNonFill = count(array /= myFillValue)
      numFill = size(array) - numNonFill
      pctNonFill = numNonFill / ( 0.01 * (numNonFill+numFill) )
      pctFill = 100.0 - pctNonFill
      if ( present(name) ) call output(trim(name) // ' ', advance='no')
      call output('Statistics on elements = or != ', advance='no')
      call output(myFillValue, advance='yes')
      call output('"!=" ', advance='no')
      call output(numNonFill, advance='no')
      call output('( ', advance='no')
      call output(pctNonFill, advance='no')
      call output('%)   ', advance='no')
      call output(' "=" ', advance='no')
      call output(numFill, advance='no')
      call output('( ', advance='no')
      call output(pctFill, advance='no')
      call output('%)   ', advance='yes')
      return
    endif
a1431 79
  ! ------------------------------------------  WHICH_INTS_ARE_IT  -----
  ! Along with a (yet unwritten) fraternal subr. 'which_strings_are_it'
  ! this is possibly better aligned with MLSNumerics or MLSStrings
  ! themes; however, for now we leave it here
  subroutine WHICH_INTS_ARE_IT ( INTS, IT, WHICH, HOW_MANY, RE_MAINDER, WHICH_NOT )
    ! Return which i of ints[i] = it
    ! optionally, return also how many of them do
    ! which_not of them (which don't)
    ! and the re_mainder of the ints != it
    ! e.g. given ints = /(4, 3, 1, 2, 1, 3 )/ and it = 1
    ! produces which = /(3, 5)/, 
    !      which_not = /(1, 2, 4, 6)/, 
    !       how_many = 2,
    !     re_mainder = /(4, 3, 2, 3)/
    
    ! This may be useful in reshaping an array to suppress any dims 
    ! that are identically 1

    ! Formal arguments
    integer, intent(in), dimension(:)  ::           ints
    integer, intent(in)                ::           it
    integer, intent(out), dimension(:) ::           which
    integer, intent(out), optional ::               how_many
    integer, intent(out), dimension(:), optional :: re_mainder
    integer, intent(out), dimension(:), optional :: which_not

    ! local variables
    integer :: i, i_which, i_re_mainder
    
    if ( size(ints) < 1 .or. size(which) < 1 ) then
      if ( present(how_many) ) how_many = 0
      if ( present(re_mainder) ) re_mainder = 0
      if ( DEEBUG ) then
        call output('size of ints or which too small', advance='yes')
        call output('ints: ')
        call output(ints, advance='yes')
        call output('which: ')
        call output(which, advance='yes')
      end if
      return
    end if
    i_which = 0
    i_re_mainder = 0
    do i=1, size(ints)
      if ( ints(i) == it ) then
        i_which = i_which+1
        which(min(size(which), i_which)) = i
      else
        i_re_mainder = i_re_mainder+1
        if ( present(which_not) ) &
          & re_mainder(min(size(which_not), i_re_mainder)) = i
        if ( present(re_mainder) ) &
          & re_mainder(min(size(re_mainder), i_re_mainder)) = ints(i)
      end if
    end do
    if ( present(how_many) ) how_many = i_which
    if ( DEEBUG ) then
        call output('ints: ')
        call output(ints, advance='yes')
        call output('it: ')
        call output(it, advance='yes')
        call output('which: ')
        call output(which, advance='yes')
        if ( present(how_many) ) then
          call output('how_many: ')
          call output(how_many, advance='yes')
        end if
        if ( present(which_not) ) then
          call output('which_not: ')
          call output(which_not, advance='yes')
        end if
        if ( present(re_mainder) ) then
          call output('re_mainder: ')
          call output(re_mainder, advance='yes')
        end if
    end if

  end subroutine WHICH_INTS_ARE_IT

d1439 3
@


2.35
log
@Split dumpsize into real and integer versions
@
text
@d40 1
a40 1
       "$Id: dump_0.f90,v 2.34 2004/04/03 05:43:23 livesey Exp $"
d185 1
a185 1
  subroutine DUMP_1D_DOUBLE ( ARRAY, NAME, CLEAN, WIDTH, FORMAT )
d188 1
d192 1
d197 1
d199 1
d201 28
d236 1
d246 7
d254 5
a258 2
          call output ( j, max(defaultWidth-1,ilog10(size(array))+1) )
          call output ( afterSub )
d260 6
a265 4
        do k = j, min(j+myWidth-1, size(array))
          call output ( array(k), myFormat )
        end do
        call output ( '', advance='yes' )
d267 1
d272 1
a272 1
  subroutine DUMP_1D_INTEGER ( ARRAY, NAME, CLEAN, FORMAT, WIDTH )
d275 1
d279 1
d286 29
d331 2
a332 2
          if ( any(array(j:min(j+myWidth-1, size(array))) /= 0) ) then
            call say_fill ( (/ j-1, size(array) /), numZeroRows, 0, inc=1 )
d337 1
a337 1
        if ( myClean .or. any(array(j:min(j+myWidth-1, size(array))) /= 0) ) then
d348 1
a348 1
      call say_fill ( (/ j-myWidth, size(array) /), numZeroRows, 0 )
d386 1
a386 1
  subroutine DUMP_1D_REAL ( ARRAY, NAME, CLEAN, WIDTH, FORMAT )
d389 1
d393 1
d399 31
d438 1
d448 8
d457 5
a461 2
          call output ( j, max(defaultWidth-1,ilog10(size(array))+1) )
          call output ( afterSub )
d463 6
a468 4
        do k = j, min(j+myWidth-1, size(array))
          call output ( array(k), myFormat )
        end do
        call output ( '', advance='yes' )
d470 1
d974 1
a974 1
  subroutine DUMP_3D_DOUBLE ( ARRAY, NAME, FILLVALUE, CLEAN, FORMAT )
d980 1
d988 6
d995 21
a1015 1
    if ( present(FillValue) ) myFillValue = FillValue
d1126 1
a1126 1
  subroutine DUMP_3D_REAL ( ARRAY, NAME, FILLVALUE, CLEAN, FORMAT )
d1132 1
a1132 1

d1139 28
a1166 2
    myFillValue = 0.e0
    if ( present(FillValue) ) myFillValue = FillValue
d1619 3
@


2.34
log
@Added DumpSize
@
text
@d30 3
d40 1
a40 1
       "$Id: dump_0.f90,v 2.33 2004/03/30 00:44:10 vsnyder Exp $"
d1186 2
a1187 2
  ! ----------------------------------------------------- DumpSize -----
  subroutine DumpSize ( n, advance )
d1208 25
a1232 1
  end subroutine DumpSize
d1441 3
@


2.33
log
@Remove unused variable declaration
@
text
@d13 1
a13 1
  public :: AfterSub, DUMP, DUMP_NAME_V_PAIRS
d37 1
a37 1
       "$Id: dump_0.f90,v 2.32 2004/02/26 21:53:31 pwagner Exp $"
d1183 24
d1414 3
@


2.32
log
@Can dump ,-separated string list
@
text
@d37 1
a37 1
       "$Id: dump_0.f90,v 2.31 2004/01/21 22:02:19 vsnyder Exp $"
d1036 1
a1036 1
    integer :: J, K
d1390 3
@


2.31
log
@Don't use number of entities per line as default width for counter
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d8 1
a8 1
  use MLSStrings, only: GetStringElement
d24 1
d37 1
a37 1
       "$Id: dump_0.f90,v 2.30 2003/09/19 02:00:14 vsnyder Exp $"
d1029 36
d1390 3
@


2.30
log
@More about the goofy Intel compiler
@
text
@d36 1
a36 1
       "$Id: dump_0.f90,v 2.29 2003/09/15 17:43:41 livesey Exp $"
d190 1
d195 1
a195 1
    myWidth = 5
d197 1
a197 1
    myFormat = MyFormatDefault
d210 1
a210 1
          call output ( j, max(myWidth-1,ilog10(size(array))+1) )
d314 1
d319 1
a319 1
    myWidth = 5
d321 1
a321 1
    myFormat = MyFormatDefault
d334 1
a334 1
          call output ( j, max(myWidth-1,ilog10(size(array))+1) )
d1353 3
@


2.29
log
@Cosmetic change for fussy (and wrong) intel compiler
@
text
@d36 1
a36 1
       "$Id: dump_0.f90,v 2.28 2003/09/06 00:48:40 vsnyder Exp $"
d1171 2
a1172 1
        call output ( " \ " )
d1351 3
@


2.28
log
@Specify default formats with a module parameter instead of literals.
Change default (1x,1pg13.6) to (1pg14.6) to avoid problems with length
calculation in output_m.
@
text
@d36 1
a36 1
       "$Id: dump_0.f90,v 2.27 2003/08/08 20:45:42 vsnyder Exp $"
d1171 1
a1171 1
        call output ( ' \' )
d1350 5
@


2.27
log
@Made say_fill_* generic, made them test for numZeroRows, and made them
optionally do say_subs_only.  This simplified several dump routines.
Added optional FORMAT arguments in several more routines.
@
text
@d36 1
a36 1
       "$Id: dump_0.f90,v 2.26 2003/07/04 02:41:33 vsnyder Exp $"
d46 4
d115 1
a115 1
    myFormat = '(1x,"(",1pg13.6,",",1pg13.6,")")'
d156 1
a156 1
    myFormat = '(1x,"(",1pg13.6,",",1pg13.6,")")'
d196 1
a196 1
    myFormat = '(1x,1pg13.6)'
d319 1
a319 1
    myFormat = '(1x,1pg13.6)'
d415 1
a415 1
    myFormat = '(1x,"(",1pg13.6,",",1pg13.6,")")'
d480 1
a480 1
    myFormat = '(1x,"(",1pg13.6,",",1pg13.6,")")'
d545 1
a545 1
    myFormat = '(1x,1pg13.6)'
d553 1
a553 1
      call output ( array(1,1), '(1x,1pg13.6)', advance='yes' )
d720 1
a720 1
    myFormat = '(1x,1pg13.g)'
d728 1
a728 1
      call output ( array(1,1), '(1x,1pg13.6)', advance='yes' )
d860 1
a860 1
    myFormat = '(1x,1pg13.6)'
d868 1
a868 1
      call output ( array(1,1,1), '(1x,1pg13.6)', advance='yes' )
d985 1
a985 1
    myFormat = '(1x,1pg13.6)'
d993 1
a993 1
      call output ( array(1,1,1), '(1x,1pg13.6)', advance='yes' )
d1350 5
@


2.26
log
@Substantial simplification by putting little things into subroutines
@
text
@d30 4
d36 1
a36 1
       "$Id: dump_0.f90,v 2.25 2003/07/02 01:07:27 vsnyder Exp $"
d78 1
a78 3
            if ( numZeroRows /= 0 ) &
              & call say_fill_char ( (/ j-1, size(array) /), numZeroRows, myFillValue )
            call say_subs_only ( (/ j, size(array) /) )
d90 1
a90 2
      if ( numZeroRows /= 0 ) &
        & call say_fill_char ( (/ j-1, size(array) /), numZeroRows, myFillValue )
d246 1
a246 3
            if ( numZeroRows /= 0 ) &
              & call say_fill_int ( (/ j-1, size(array) /), numZeroRows )
            call say_subs_only ( (/ j, size(array) /) )
d262 1
a262 2
      if ( numZeroRows /= 0 ) &
        & call say_fill_int ( (/ j-1, size(array) /), numZeroRows )
d372 2
a373 4
              if ( numZeroRows /= 0 ) &
                & call say_fill_char ( (/ i-1, size(array,1), j-1, size(array,2) /), &
                  & numZeroRows, myFillValue )
              call say_subs_only ( (/ i, size(array,1), j, size(array,2) /) )
d386 2
a387 3
      if ( numZeroRows /= 0 ) &
        & call say_fill_char ( (/ i-1, size(array,1), j-1, size(array,2) /), &
           & numZeroRows, myFillValue )
d522 1
a522 1
  subroutine DUMP_2D_DOUBLE ( ARRAY, NAME, FILLVALUE, CLEAN )
d527 1
d533 4
d538 1
a538 1
    myFillValue = 0.d0
d541 2
a542 2
    myClean = .false.
    if ( present(clean) ) myClean = clean
d560 2
a561 4
                if ( numZeroRows /= 0 ) &
                  & call say_fill_double ( (/ i-1, size(array,1), j, size(array,2) /), &
                    & numZeroRows, myFillValue )
                call say_subs_only ( (/ i, size(array,1), j, size(array,2) /) )
d568 1
a568 1
                call output ( array(i,k), '(1x,1pg13.6)' )
d574 2
a575 3
        if ( numZeroRows /= 0 ) &
          & call say_fill_double ( (/ i-1, size(array,1), j-1, size(array,2) /), &
                    & numZeroRows, myFillValue )
d582 2
a583 4
              if ( numZeroRows /= 0 ) &
                & call say_fill_double ( (/ i-1, size(array,1), j, size(array,2) /), &
                  & numZeroRows, myFillValue )
              call say_subs_only ( (/ i, size(array,1), j, size(array,2) /) )
d589 1
a589 1
                call output ( array(k,j), '(1x,1pg13.6)' )
d596 2
a597 3
      if ( numZeroRows /= 0 ) &
        & call say_fill_double ( (/ i-1, size(array,1), j-1, size(array,2) /), &
           & numZeroRows, myFillValue )
d634 2
a635 4
              if ( numZeroRows /= 0 ) &
                & call say_fill_int ( (/ i, size(array,1), j-1, size(array,2) /), &
                  & numZeroRows )
              call say_subs_only ( (/ i, size(array,1), j, size(array,2) /) )
d652 2
a653 3
      if ( numZeroRows /= 0 ) &
        & call say_fill_int ( (/ i-1, size(array,1), j-1, size(array,2) /), &
          & numZeroRows )
d697 1
a697 1
  subroutine DUMP_2D_REAL ( ARRAY, NAME, FILLVALUE, CLEAN )
d702 1
d708 1
d710 4
a713 1
    myFillValue = 0.e0
d716 2
a717 2
    myClean = .false.
    if ( present(clean) ) myClean = clean
d735 2
a736 4
                if ( numZeroRows /= 0 ) &
                  & call say_fill_real ( (/ i, size(array,1), j-1, size(array,2) /), &
                    & numZeroRows, myFillValue )
                call say_subs_only ( (/ i, size(array,1), j, size(array,2) /) )
d743 1
a743 1
                call output ( array(i,k), '(1x,1pg13.6)' )
d749 2
a750 3
        if ( numZeroRows /= 0 ) &
          & call say_fill_real ( (/ i-1, size(array,1), j-1, size(array,2) /), &
            & numZeroRows, myFillValue )
d757 2
a758 4
              if ( numZeroRows /= 0 ) &   
                & call say_fill_real ( (/ i-1, size(array,1), j, size(array,2) /), &
                  & numZeroRows, myFillValue )
              call say_subs_only ( (/ i, size(array,1), j, size(array,2) /) )
d764 1
a764 1
                call output ( array(k,j), '(1x,1pg13.6)' )
d771 2
a772 3
      if ( numZeroRows /= 0 ) &   
        & call say_fill_real ( (/ i-1, size(array,1), j-1, size(array,2) /), &
          & numZeroRows, myFillValue )
d818 2
a819 5
                if ( numZeroRows /= 0 ) &
                  & call say_fill_char ( (/ i, size(array,1), j, size(array,2), &
                    & k-1, size(array,3) /), numZeroRows, myFillValue )
                call say_subs_only ( (/ i, size(array,1), j, size(array,2), &
                  & k, size(array,3) /) )
d833 2
a834 3
      if ( numZeroRows /= 0 ) &
        & call say_fill_char ( (/ i-1, size(array,1), j-1, size(array,2), &
          & k-1, size(array,3) /), numZeroRows, myFillValue )
d839 1
a839 1
  subroutine DUMP_3D_DOUBLE ( ARRAY, NAME, FILLVALUE, CLEAN )
d844 1
d850 1
d856 2
d877 2
a878 5
                if ( numZeroRows /= 0 ) &
                  & call say_fill_double ( (/ i, size(array,1), j, size(array,2), &
                    & k-1, size(array,3) /), numZeroRows, myFillValue )
                call say_subs_only ( (/ i, size(array,1), j, size(array,2), &
                  & k, size(array,3) /) )
d885 1
a885 1
                call output ( array(i,j,l), '(1x,1pg13.6)' )
d892 2
a893 3
      if ( numZeroRows /= 0 ) &
        & call say_fill_double ( (/ i-1, size(array,1), j-1, size(array,2), &
          & k-1, size(array,3) /), numZeroRows, myFillValue )
d939 2
a940 5
                if ( numZeroRows /= 0 ) &
                  & call say_fill_int ( (/ i, size(array,1), j, size(array,2), &
                    & k-1, size(array,3) /), numZeroRows )
                call say_subs_only ( (/ i, size(array,1), j, size(array,2), &
                  & k, size(array,3) /) )
d958 2
a959 3
      if ( numZeroRows /= 0 ) &
        & call say_fill_int ( (/ i-1, size(array,1), j-1, size(array,2), &
          & k-1, size(array,3) /), numZeroRows )
d964 1
a964 1
  subroutine DUMP_3D_REAL ( ARRAY, NAME, FILLVALUE, CLEAN )
d969 1
d975 1
d981 2
d1002 2
a1003 5
                if ( numZeroRows /= 0 ) &
                  & call say_fill_real ( (/ i, size(array,1), j, size(array,2), &
                    & k-1, size(array,3) /), numZeroRows, myFillValue )
                call say_subs_only ( (/ i, size(array,1), j, size(array,2), &
                  & k, size(array,3) /) )
d1010 1
a1010 1
                call output ( array(i,j,l), '(1x,1pg13.6)' )
d1017 2
a1018 3
      if ( numZeroRows /= 0 ) &
        & call say_fill_real ( (/ i-1, size(array,1), j-1, size(array,2), &
          & k-1, size(array,3) /), numZeroRows, myFillValue )
d1176 1
a1176 1
  subroutine Say_Fill_Char ( Subs, NumZeroRows, Fill )
d1180 10
a1189 5
    call say_subs ( subs, numZeroRows  )
    call output ( '"', advance='no' )
    call output ( trim(fill), advance='no' )
    call output ( '" not printed.', advance='yes' )
    numZeroRows = 0
d1193 1
a1193 1
  subroutine Say_Fill_Double ( Subs, NumZeroRows, Fill )
d1197 9
a1205 4
    call say_subs ( subs, numZeroRows )
    call output ( fill, advance='no' )
    call output ( ' not printed.', advance='yes' )
    numZeroRows = 0
d1209 1
a1209 1
  subroutine Say_Fill_Int ( Subs, NumZeroRows )
d1212 10
a1221 3
    call say_subs ( subs, numZeroRows )
    call output ( 'zeros not printed.', advance='yes' )
    numZeroRows = 0
d1225 1
a1225 1
  subroutine Say_Fill_Real ( Subs, NumZeroRows, Fill )
d1229 9
a1237 4
    call say_subs ( subs, numZeroRows )
    call output ( fill, advance='no' )
    call output ( ' not printed.', advance='yes' )
    numZeroRows = 0
d1346 3
@


2.25
log
@Add complex output
@
text
@d32 1
a32 1
       "$Id: dump_0.f90,v 2.24 2003/05/21 19:20:40 vsnyder Exp $"
d64 1
a64 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d66 1
a66 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d69 2
a70 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d74 3
a76 12
            if ( numZeroRows /= 0 ) then
              call output ( j-1, places=max(4,ilog10(size(array))+1) )
              call output ( afterSub )
              call output ( ' ' )
              call output ( numZeroRows )
              call output ( ' rows of "', advance='no' )
              call output ( trim(myFillValue), advance='no' )
              call output ( '" not printed.', advance='yes' )
              numZeroRows = 0
            end if
            call output ( j, places=max(4,ilog10(size(array))+1) )
            call output ( afterSub )
d88 2
a89 10
      if ( numZeroRows /= 0 ) then
        call output ( j-1, places=max(4,ilog10(size(array))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of "', advance='no' )           
        call output ( trim(myFillValue), advance='no' )          
        call output ( '" not printed.', advance='yes' )      
        numZeroRows = 0
      end if
d114 1
a114 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d116 1
a116 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d119 2
a120 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d155 1
a155 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d157 1
a157 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d160 2
a161 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d195 1
a195 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d197 1
a197 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d200 2
a201 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d235 1
a235 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d237 1
a237 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d240 2
a241 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d245 3
a247 10
            if ( numZeroRows /= 0 ) then
              call output ( j-1, places=max(4,ilog10(size(array))+1) )
              call output ( afterSub )
              call output ( ' ' )
              call output ( numZeroRows )
              call output ( ' rows of zeros not printed.', advance='yes' )
              numZeroRows = 0
            end if
            call output ( j, places=max(4,ilog10(size(array))+1) )
            call output ( afterSub )
d263 2
a264 8
      if ( numZeroRows /= 0 ) then
        call output ( j-1, places=max(4,ilog10(size(array))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of zeros not printed.', advance='yes' )
        numZeroRows = 0
      end if
d281 1
a281 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d283 1
a283 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d286 2
a287 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d321 1
a321 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d323 1
a323 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d326 2
a327 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d361 1
a361 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d363 1
a363 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d368 2
a369 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d374 4
a377 14
              if ( numZeroRows /= 0 ) then
                call output ( i, places=max(4,ilog10(size(array,1))+1) )
                call output ( j-1, places=max(4,ilog10(size(array))+1) )
                call output ( afterSub )
                call output ( ' ' )
                call output ( numZeroRows )
                call output ( ' rows of "', advance='no' )
                call output ( trim(myFillValue), advance='no' )
                call output ( '" not printed.', advance='yes' )
                numZeroRows = 0
              end if
              call output ( i, places=max(4,ilog10(size(array,1))+1) )
              call output ( j, places=max(4,ilog10(size(array,2))+1) )
              call output ( afterSub )
d390 3
a392 11
      if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of "', advance='no' )           
        call output ( trim(myFillValue), advance='no' )          
        call output ( '" not printed.', advance='yes' )      
        numZeroRows = 0
      end if
d420 1
a420 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d422 1
a422 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d427 1
a427 7
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
      end if
d429 1
a429 1
        call output ( '', advance='yes' )
d444 2
a445 1
        call output ( ' (transposed)', advance='yes' )
d485 1
a485 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d487 1
a487 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d492 1
a492 7
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
      end if
d494 1
a494 1
        call output ( '', advance='yes' )
d509 2
a510 1
        call output ( ' (transposed)', advance='yes' )
d546 1
a546 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d548 1
a548 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d553 1
a553 7
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
      end if
d555 1
a555 1
        call output ( '', advance='yes' )
a558 3
              !call output ( i, max(4,ilog10(size(array,1))+1) )
              !call output ( j, max(4,ilog10(size(array,2))+1) )
              !call output ( afterSub )
d560 4
a563 14
                if ( numZeroRows /= 0 ) then
                  call output ( i, places=max(4,ilog10(size(array,1))+1) )
                  call output ( j-1, places=max(4,ilog10(size(array))+1) )
                  call output ( afterSub )
                  call output ( ' ' )
                  call output ( numZeroRows )
                  call output ( ' rows of ')
                  call output ( myFillValue , advance='no' )
                  call output ( ' not printed.', advance='yes' )
                  numZeroRows = 0
                end if
                call output ( i, places=max(4,ilog10(size(array,1))+1) )
                call output ( j, places=max(4,ilog10(size(array,2))+1) )
                call output ( afterSub )
d576 3
a578 11
        if ( numZeroRows /= 0 ) then
          call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
          call output ( j-1, places=max(4,ilog10(size(array))+1) )
          call output ( afterSub )
          call output ( ' ' )
          call output ( numZeroRows )
          call output ( ' rows of ')                            
          call output ( myFillValue , advance='no' )                
          call output ( ' not printed.', advance='yes' )        
          numZeroRows = 0
        end if
d580 2
a581 1
        call output ( ' (transposed)', advance='yes' )
a583 3
            !call output ( i, max(4,ilog10(size(array,1))+1) )
            !call output ( j, max(4,ilog10(size(array,2))+1) )
            !call output ( afterSub )
d585 4
a588 14
              if ( numZeroRows /= 0 ) then                                  
                call output ( i, places=max(4,ilog10(size(array,1))+1) )    
                call output ( j-1, places=max(4,ilog10(size(array))+1) )    
                call output ( afterSub )                                    
                call output ( ' ' )                                         
                call output ( numZeroRows )                                 
                call output ( ' rows of ')                                  
                call output ( myFillValue , advance='no' )                      
                call output ( ' not printed.', advance='yes' )              
                numZeroRows = 0                                             
              end if                                                        
              call output ( i, places=max(4,ilog10(size(array,1))+1) )      
              call output ( j, places=max(4,ilog10(size(array,2))+1) )      
              call output ( afterSub )                                      
d601 3
a603 11
      if ( numZeroRows /= 0 ) then                                  
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )  
        call output ( j-1, places=max(4,ilog10(size(array))+1) )    
        call output ( afterSub )                                    
        call output ( ' ' )                                         
        call output ( numZeroRows )                                 
        call output ( ' rows of ')                                  
        call output ( myFillValue , advance='no' )                      
        call output ( ' not printed.', advance='yes' )              
        numZeroRows = 0                                             
      end if                                                        
d627 1
a627 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d629 1
a629 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d634 2
a635 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d640 4
a643 12
              if ( numZeroRows /= 0 ) then
                call output ( i, places=max(4,ilog10(size(array,1))+1) )
                call output ( j-1, places=max(4,ilog10(size(array))+1) )
                call output ( afterSub )
                call output ( ' ' )
                call output ( numZeroRows )
                call output ( ' rows of zeros not printed.', advance='yes' )
                numZeroRows = 0
              end if
              call output ( i, places=max(4,ilog10(size(array,1))+1) )
              call output ( j, places=max(4,ilog10(size(array,2))+1) )
              call output ( afterSub )
d660 3
a662 9
      if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of zeros not printed.', advance='yes' )
        numZeroRows = 0
      end if
d680 1
a680 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d682 1
a682 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d687 2
a688 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d715 1
a715 1
    double precision :: myFillValue
d725 1
a725 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d727 1
a727 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d732 1
a732 7
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
      end if
d734 1
a734 1
        call output ( '', advance='yes' )
a737 3
              !call output ( i, max(4,ilog10(size(array,1))+1) )
              !call output ( j, max(4,ilog10(size(array,2))+1) )
              !call output ( afterSub )
d739 4
a742 14
                if ( numZeroRows /= 0 ) then
                  call output ( i, places=max(4,ilog10(size(array,1))+1) )
                  call output ( j-1, places=max(4,ilog10(size(array))+1) )
                  call output ( afterSub )
                  call output ( ' ' )
                  call output ( numZeroRows )
                  call output ( ' rows of ')
                  call output ( myFillValue , advance='no' )
                  call output ( ' not printed.', advance='yes' )
                  numZeroRows = 0
                end if
                call output ( i, places=max(4,ilog10(size(array,1))+1) )
                call output ( j, places=max(4,ilog10(size(array,2))+1) )
                call output ( afterSub )
d755 3
a757 11
        if ( numZeroRows /= 0 ) then
          call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
          call output ( j-1, places=max(4,ilog10(size(array))+1) )
          call output ( afterSub )
          call output ( ' ' )
          call output ( numZeroRows )
          call output ( ' rows of ')                            
          call output ( myFillValue , advance='no' )                
          call output ( ' not printed.', advance='yes' )        
          numZeroRows = 0
        end if
d759 2
a760 1
        call output ( ' (transposed)', advance='yes' )
a762 3
            !call output ( i, max(4,ilog10(size(array,1))+1) )
            !call output ( j, max(4,ilog10(size(array,2))+1) )
            !call output ( afterSub )
d764 4
a767 14
              if ( numZeroRows /= 0 ) then                                  
                call output ( i, places=max(4,ilog10(size(array,1))+1) )    
                call output ( j-1, places=max(4,ilog10(size(array))+1) )    
                call output ( afterSub )                                    
                call output ( ' ' )                                         
                call output ( numZeroRows )                                 
                call output ( ' rows of ')                                  
                call output ( myFillValue , advance='no' )                      
                call output ( ' not printed.', advance='yes' )              
                numZeroRows = 0                                             
              end if                                                        
              call output ( i, places=max(4,ilog10(size(array,1))+1) )      
              call output ( j, places=max(4,ilog10(size(array,2))+1) )      
              call output ( afterSub )                                      
d780 3
a782 11
      if ( numZeroRows /= 0 ) then                                  
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )  
        call output ( j-1, places=max(4,ilog10(size(array))+1) )    
        call output ( afterSub )                                    
        call output ( ' ' )                                         
        call output ( numZeroRows )                                 
        call output ( ' rows of ')                                  
        call output ( myFillValue , advance='no' )                      
        call output ( ' not printed.', advance='yes' )              
        numZeroRows = 0                                             
      end if                                                        
d810 1
a810 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d812 1
a812 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d821 2
a822 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d828 5
a832 16
                if ( numZeroRows /= 0 ) then
                  call output ( i, places=max(4,ilog10(size(array,1))+1) )
                  call output ( j, places=max(4,ilog10(size(array,2))+1) )
                  call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
                  call output ( afterSub )
                  call output ( ' ' )
                  call output ( numZeroRows )
                  call output ( ' rows of "', advance='no' )
                  call output ( trim(myFillValue), advance='no' )
                  call output ( '" not printed.', advance='yes' )
                  numZeroRows = 0
                end if
                call output ( i, max(4,ilog10(size(array,1))+1) )
                call output ( j, max(4,ilog10(size(array,2))+1) )
                call output ( k, max(4,ilog10(size(array,3))+1) )
                call output ( afterSub )
d846 3
a848 12
      if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array,2))+1) )
        call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of "', advance='no' )           
        call output ( trim(myFillValue), advance='no' )          
        call output ( '" not printed.', advance='yes' )      
        numZeroRows = 0
      end if
d871 1
a871 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d873 1
a873 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d880 2
a881 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
a885 4
              !call output ( i, max(4,ilog10(size(array,1))+1) )
              !call output ( j, max(4,ilog10(size(array,2))+1) )
              !call output ( k, max(4,ilog10(size(array,3))+1) )
              !call output ( afterSub )
d887 5
a891 16
                if ( numZeroRows /= 0 ) then
                  call output ( i, places=max(4,ilog10(size(array,1))+1) )
                  call output ( j, places=max(4,ilog10(size(array,2))+1) )
                  call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
                  call output ( afterSub )
                  call output ( ' ' )
                  call output ( numZeroRows )
                  call output ( ' rows of ')
                  call output ( myFillValue , advance='no' )
                  call output ( ' not printed.', advance='yes' )
                  numZeroRows = 0
                end if
                call output ( i, max(4,ilog10(size(array,1))+1) )
                call output ( j, max(4,ilog10(size(array,2))+1) )
                call output ( k, max(4,ilog10(size(array,3))+1) )
                call output ( afterSub )
d905 3
a907 12
       if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array,2))+1) )
        call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of ')                              
        call output ( myFillValue , advance='no' )                  
        call output ( ' not printed.', advance='yes' )          
        numZeroRows = 0
      end if
d935 1
a935 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d937 1
a937 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d946 2
a947 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
d953 5
a957 14
                if ( numZeroRows /= 0 ) then
                  call output ( i, places=max(4,ilog10(size(array,1))+1) )
                  call output ( j, places=max(4,ilog10(size(array,2))+1) )
                  call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
                  call output ( afterSub )
                  call output ( ' ' )
                  call output ( numZeroRows )
                  call output ( ' rows of zeros not printed.', advance='yes' )
                  numZeroRows = 0
                end if
                call output ( i, max(4,ilog10(size(array,1))+1) )
                call output ( j, max(4,ilog10(size(array,2))+1) )
                call output ( k, max(4,ilog10(size(array,3))+1) )
                call output ( afterSub )
d975 3
a977 10
      if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array,2))+1) )
        call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of zeros not printed.', advance='yes' )
        numZeroRows = 0
      end if
d1000 1
a1000 5
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
d1002 1
a1002 8
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) then
          call output ( ' \ 1', advance='yes' )
        else
          call output ( ' ' )
        end if
      end if
d1009 2
a1010 8
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
a1014 4
              !call output ( i, max(4,ilog10(size(array,1))+1) )
              !call output ( j, max(4,ilog10(size(array,2))+1) )
              !call output ( k, max(4,ilog10(size(array,3))+1) )
              !call output ( afterSub )
d1016 5
a1020 16
                if ( numZeroRows /= 0 ) then
                  call output ( i, places=max(4,ilog10(size(array,1))+1) )
                  call output ( j, places=max(4,ilog10(size(array,2))+1) )
                  call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
                  call output ( afterSub )
                  call output ( ' ' )
                  call output ( numZeroRows )
                  call output ( ' rows of ')
                  call output ( myFillValue , advance='no' )
                  call output ( ' not printed.', advance='yes' )
                  numZeroRows = 0
                end if
                call output ( i, max(4,ilog10(size(array,1))+1) )
                call output ( j, max(4,ilog10(size(array,2))+1) )
                call output ( k, max(4,ilog10(size(array,3))+1) )
                call output ( afterSub )
d1034 3
a1036 12
       if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array,2))+1) )
        call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of ')                              
        call output ( myFillValue , advance='no' )                  
        call output ( ' not printed.', advance='yes' )          
        numZeroRows = 0
      end if
d1158 12
d1176 80
d1342 3
@


2.24
log
@Start a new line after \ 1 if size==1 and clean
@
text
@d16 6
a21 4
    module procedure DUMP_1D_CHAR, DUMP_1D_DOUBLE
    module procedure DUMP_1D_INTEGER, DUMP_1D_LOGICAL, DUMP_1D_REAL
    module procedure DUMP_2D_CHAR, DUMP_2D_DOUBLE
    module procedure DUMP_2D_INTEGER, DUMP_2D_LOGICAL, DUMP_2D_REAL
d32 1
a32 1
       "$Id: dump_0.f90,v 2.23 2003/05/06 00:15:03 pwagner Exp $"
d127 117
a243 1
  ! ---------------------------------------------  DUMP_1D_DOUBLE  -----
d580 162
d1782 3
@


2.23
log
@Fixed incompatibility with FilterShapes
@
text
@d30 1
a30 1
       "$Id$"
d33 1
a33 1
       "$RCSfile$"
d70 5
a74 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d153 5
a157 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d210 5
a214 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d286 5
a290 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d343 5
a347 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d400 5
a404 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d490 5
a494 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d629 5
a633 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d713 5
a717 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d775 5
a779 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d918 5
a922 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d1016 5
a1020 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d1121 5
a1125 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d1219 5
a1223 2
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
d1501 4
a1504 1
! $Log$
@


2.22
log
@Renamed optional blase arg to FillValue
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d16 6
a21 5
    module procedure DUMP_1D_DOUBLE, DUMP_1D_INTEGER, DUMP_1D_LOGICAL
    module procedure DUMP_2D_DOUBLE, DUMP_2D_INTEGER, DUMP_3D_DOUBLE
    module procedure DUMP_3D_INTEGER
    module procedure DUMP_1D_CHAR, DUMP_2D_CHAR, DUMP_3D_CHAR
    module procedure DUMP_1D_REAL, DUMP_2D_REAL, DUMP_3D_REAL
d30 1
a30 1
       "$Id: dump_0.f90,v 2.21 2003/02/19 18:33:38 pwagner Exp $"
d33 1
a33 1
       "$RCSfile: dump_0.f90,v $"
d42 2
a43 2
  ! --------------------------------------------  DUMP_1D_CHAR  -----
  subroutine DUMP_1D_CHAR ( ARRAY, NAME, FillValue, CLEAN )
d46 1
a46 1
    character(len=*), intent(in), optional :: FillValue
a121 187
  ! --------------------------------------------  DUMP_2D_CHAR  -----
  subroutine DUMP_2D_CHAR ( ARRAY, NAME, FillValue, CLEAN )
    character(len=*), intent(in) :: ARRAY(:,:)
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: FillValue
    logical, intent(in), optional :: CLEAN

    integer :: I, J, K
    logical :: MyClean
    integer :: NumZeroRows
    character(len=len(array)) :: myFillValue

    myFillValue = ' '
    if ( present(FillValue) ) myFillValue = FillValue

    myClean = .false.
    if ( present(clean) ) myClean = clean

    numZeroRows = 0
    if ( size(array) == 0 ) then
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
    else if ( size(array) == 1 ) then
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
      end if
      call output ( array(1,1), advance='yes' )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1), name, FillValue=FillValue, clean=clean )
    else
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
      do i = 1, size(array,1)
        do j = 1, size(array,2), 10
          if (.not. myClean) then
            if ( any(array(i,j:min(j+9, size(array,2))) /= myFillValue) ) then
              if ( numZeroRows /= 0 ) then
                call output ( i, places=max(4,ilog10(size(array,1))+1) )
                call output ( j-1, places=max(4,ilog10(size(array))+1) )
                call output ( afterSub )
                call output ( ' ' )
                call output ( numZeroRows )
                call output ( ' rows of "', advance='no' )
                call output ( trim(myFillValue), advance='no' )
                call output ( '" not printed.', advance='yes' )
                numZeroRows = 0
              end if
              call output ( i, places=max(4,ilog10(size(array,1))+1) )
              call output ( j, places=max(4,ilog10(size(array,2))+1) )
              call output ( afterSub )
            else
              numZeroRows = numZeroRows + 1
            end if
          end if
          if ( myClean .or. any(array(i,j:min(j+9, size(array,2))) /= myFillValue) ) then
            do k = j, min(j+9, size(array,2))
                call output ( array(i,k) // ' ' )
            end do
            call output ( '', advance='yes' )
          end if
        end do ! j
      end do ! i
      if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of "', advance='no' )           
        call output ( trim(myFillValue), advance='no' )          
        call output ( '" not printed.', advance='yes' )      
        numZeroRows = 0
      end if
    end if
  end subroutine DUMP_2D_CHAR

  ! ---------------------------------------------  DUMP_3D_CHAR  -----
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, FillValue, CLEAN )
    character(len=*), intent(in) :: ARRAY(:,:,:)
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: FillValue
    logical, intent(in), optional :: CLEAN

    logical :: myClean
    integer :: I, J, K, L
    integer :: NumZeroRows
    integer, dimension(3) :: which, re_mainder
    integer :: how_many
    character(len=len(array)) :: myFillValue

    myFillValue = ' '
    if ( present(FillValue) ) myFillValue = FillValue

    myClean = .false.
    if ( present(clean) ) myClean = clean
    call which_ints_are_it( (/ size(array, 1), size(array, 2), size(array, 3)/), &
      & 1, which, how_many, re_mainder=re_mainder)

    numZeroRows = 0
    if ( size(array) == 0 ) then
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
    else if ( size(array) == 1 ) then
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
      end if
      call output ( array(1,1,1), advance='yes' )
    else if ( how_many == 2 ) then
      call dump ( reshape(array, (/ re_mainder(1) /)), name, FillValue=FillValue, &
        & clean=clean )
    else if ( how_many == 1 ) then
      call dump ( reshape(array, (/ re_mainder(1), re_mainder(2) /)), &
        & name, FillValue=FillValue, clean=clean )
    else
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
      do i = 1, size(array,1)
        do j = 1, size(array,2)
          do k = 1, size(array,3), 10
            if (.not. myClean) then
              if ( any(array(i,j,k:min(k+9, size(array,3))) /= myFillValue) ) then
                if ( numZeroRows /= 0 ) then
                  call output ( i, places=max(4,ilog10(size(array,1))+1) )
                  call output ( j, places=max(4,ilog10(size(array,2))+1) )
                  call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
                  call output ( afterSub )
                  call output ( ' ' )
                  call output ( numZeroRows )
                  call output ( ' rows of "', advance='no' )
                  call output ( trim(myFillValue), advance='no' )
                  call output ( '" not printed.', advance='yes' )
                  numZeroRows = 0
                end if
                call output ( i, max(4,ilog10(size(array,1))+1) )
                call output ( j, max(4,ilog10(size(array,2))+1) )
                call output ( k, max(4,ilog10(size(array,3))+1) )
                call output ( afterSub )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( myClean .or. any(array(i,j,k:min(k+9, size(array,3))) /= myFillValue) ) then
              do l = k, min(k+9, size(array,3))
                  call output ( array(i,j,l) // ' ' )
              end do
              call output ( '', advance='yes' )
            end if
          end do
        end do
      end do
      if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array,2))+1) )
        call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of "', advance='no' )           
        call output ( trim(myFillValue), advance='no' )          
        call output ( '" not printed.', advance='yes' )      
        numZeroRows = 0
      end if
    end if
  end subroutine DUMP_3D_CHAR

d123 1
a123 1
  subroutine DUMP_1D_DOUBLE ( ARRAY, NAME, CLEAN )
d127 2
d130 3
a132 2
    logical :: myClean
    integer :: J, K
d136 4
d153 1
a153 1
      call output ( array(1), '(1x,1pg13.6)', advance='yes' )
d163 1
a163 1
      do j = 1, size(array), 5
d165 1
a165 1
          call output ( j, max(4,ilog10(size(array))+1) )
d168 2
a169 2
        do k = j, min(j+4, size(array))
          call output ( array(k), '(1x,1pg13.6)' )
d256 1
a256 1
  ! --------------------------------------------  DUMP_1D_LOGICAL ----
d303 2
a304 2
  ! ---------------------------------------------  DUMP_1D_REAL  -----
  subroutine DUMP_1D_REAL ( ARRAY, NAME, CLEAN )
d308 2
d312 2
a313 1
    integer :: J, K
d317 4
d334 1
a334 1
      call output ( array(1), '(1x,1pg13.6)', advance='yes' )
d344 1
a344 1
      do j = 1, size(array), 5
d346 1
a346 1
          call output ( j, max(4,ilog10(size(array))+1) )
d349 2
a350 2
        do k = j, min(j+4, size(array))
          call output ( array(k), '(1x,1pg13.6)' )
d357 87
d445 1
a445 1
  subroutine DUMP_2D_DOUBLE ( ARRAY, NAME, FillValue, CLEAN )
d448 1
a448 1
    double precision, intent(in), optional :: FillValue
a484 1
        call output ( '', advance='yes' )
d518 1
a518 1
            endif
d533 1
a533 1
        call output ( ', transposed', advance='yes' )
d667 55
a721 2
  ! ---------------------------------------------  DUMP_2D_REAL  -----
  subroutine DUMP_2D_REAL ( ARRAY, NAME, FillValue, CLEAN )
d724 1
a724 1
    real, intent(in), optional :: FillValue
d730 1
a730 1
    real :: myFillValue
a760 1
        call output ( '', advance='yes' )
d794 1
a794 1
            endif
d809 1
a809 1
        call output ( ', transposed', advance='yes' )
d856 100
d957 1
a957 1
  subroutine DUMP_3D_DOUBLE ( ARRAY, NAME, FillValue, CLEAN )
d960 1
a960 1
    double precision, intent(in), optional :: FillValue
d990 1
a990 1
      call dump ( array(:,:,1), name, FillValue=FillValue, clean=clean )
d1034 1
a1034 1
            endif
d1053 1
a1053 1
  ! ---------------------------------------------  DUMP_3D_INTEGER  -----
d1133 1
a1133 1
                endif
d1154 1
a1154 1
  subroutine DUMP_3D_REAL ( ARRAY, NAME, FillValue, CLEAN )
d1157 1
a1157 1
    real, intent(in), optional :: FillValue
d1187 1
a1187 1
      call dump ( array(:,:,1), name, FillValue=FillValue, clean=clean )
d1250 3
a1252 2
  ! ---------------------------------------------  DUMP_NAME_V_PAIRS_DOUBLE  -----
  subroutine DUMP_NAME_V_PAIRS_DOUBLE ( values, NAMES, CLEAN, FORMAT, WIDTH )
d1279 1
a1279 1
          endif
d1283 2
a1284 2
        endif
      enddo
d1286 1
a1286 1
    enddo
d1290 2
a1291 2
  ! ---------------------------------------------  DUMP_NAME_V_PAIRS_INTEGER  -----
  subroutine DUMP_NAME_V_PAIRS_INTEGER ( values, NAMES, CLEAN, FORMAT, WIDTH )
d1318 1
a1318 1
          endif
d1322 2
a1323 2
        endif
      enddo
d1325 1
a1325 1
    enddo
d1329 2
a1330 2
  ! ---------------------------------------------  DUMP_NAME_V_PAIRS_REAL  -----
  subroutine DUMP_NAME_V_PAIRS_REAL ( values, NAMES, CLEAN, FORMAT, WIDTH )
d1357 1
a1357 1
          endif
d1361 2
a1362 2
        endif
      enddo
d1364 1
a1364 1
    enddo
d1368 2
a1369 2
  ! ---------------------------------------------  ilog10  -----
  integer function ilog10(int)
d1372 1
a1372 1
  end function ilog10
d1374 1
d1378 1
a1378 2
  ! -------------------------  which_ints_are_it  -----
  subroutine which_ints_are_it(ints, it, which, how_many, re_mainder, which_not)
d1412 1
a1412 1
      endif
d1414 1
a1414 1
    endif
d1427 2
a1428 2
      endif
    enddo
d1440 1
a1440 1
        endif
d1444 1
a1444 1
        endif
d1448 2
a1449 2
        endif
    endif
d1451 1
a1451 1
  end subroutine which_ints_are_it
d1459 12
a1470 3
! $Log: dump_0.f90,v $
! Revision 2.21  2003/02/19 18:33:38  pwagner
! Can now dump 3d reals
d1488 2
a1489 1
! Added optional FillValue arg to dump_nd_char; fixed bug where optional format not passed from dump_3d_int
@


2.21
log
@Can now dump 3d reals
@
text
@d29 1
a29 1
       "$Id: dump_0.f90,v 2.20 2002/12/02 23:34:14 pwagner Exp $"
d42 1
a42 1
  subroutine DUMP_1D_CHAR ( ARRAY, NAME, BLASE, CLEAN )
d45 1
a45 1
    character(len=*), intent(in), optional :: BLASE
d51 1
a51 1
    character(len=len(array)) :: myBlase
d53 2
a54 2
    myBlase = ' '
    if ( present(Blase) ) myBlase = Blase
d84 1
a84 1
          if ( any(array(j:min(j+9, size(array))) /= myBlase) ) then
d91 1
a91 1
              call output ( trim(myBlase), advance='no' )
d101 1
a101 1
        if ( myClean .or. any(array(j:min(j+9, size(array))) /= myBlase) ) then
d114 1
a114 1
        call output ( trim(myBlase), advance='no' )          
d122 1
a122 1
  subroutine DUMP_2D_CHAR ( ARRAY, NAME, BLASE, CLEAN )
d125 1
a125 1
    character(len=*), intent(in), optional :: BLASE
d131 1
a131 1
    character(len=len(array)) :: myBlase
d133 2
a134 2
    myBlase = ' '
    if ( present(Blase) ) myBlase = Blase
d154 1
a154 1
      call dump ( array(:,1), name, blase=blase, clean=clean )
d167 1
a167 1
            if ( any(array(i,j:min(j+9, size(array,2))) /= myBlase) ) then
d175 1
a175 1
                call output ( trim(myBlase), advance='no' )
d186 1
a186 1
          if ( myClean .or. any(array(i,j:min(j+9, size(array,2))) /= myBlase) ) then
d201 1
a201 1
        call output ( trim(myBlase), advance='no' )          
d209 1
a209 1
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, BLASE, CLEAN )
d212 1
a212 1
    character(len=*), intent(in), optional :: BLASE
d220 1
a220 1
    character(len=len(array)) :: myBlase
d222 2
a223 2
    myBlase = ' '
    if ( present(Blase) ) myBlase = Blase
d245 1
a245 1
      call dump ( reshape(array, (/ re_mainder(1) /)), name, blase=blase, &
d249 1
a249 1
        & name, blase=blase, clean=clean )
d263 1
a263 1
              if ( any(array(i,j,k:min(k+9, size(array,3))) /= myBlase) ) then
d272 1
a272 1
                  call output ( trim(myBlase), advance='no' )
d284 1
a284 1
            if ( myClean .or. any(array(i,j,k:min(k+9, size(array,3))) /= myBlase) ) then
d301 1
a301 1
        call output ( trim(myBlase), advance='no' )          
d530 1
a530 1
  subroutine DUMP_2D_DOUBLE ( ARRAY, NAME, BLASE, CLEAN )
d533 1
a533 1
    double precision, intent(in), optional :: BLASE
d539 1
a539 1
    double precision :: myBlase
d541 2
a542 2
    myBlase = 0.d0
    if ( present(Blase) ) myBlase = Blase
d580 1
a580 1
              if ( any(array(i,j:min(j+4, size(array,2))) /= myBlase) ) then
d588 1
a588 1
                  call output ( myBlase , advance='no' )
d599 1
a599 1
            if ( myClean .or. any(array(i,j:min(j+4, size(array,2))) /= myBlase) ) then
d614 1
a614 1
          call output ( myBlase , advance='no' )                
d625 1
a625 1
            if ( any(array(i:min(i+4, size(array,1)),j) /= myBlase) ) then  
d633 1
a633 1
                call output ( myBlase , advance='no' )                      
d643 1
a643 1
            if ( myClean .or. any(array(i:min(i+4, size(array,1)),j) /= myBlase) ) then
d659 1
a659 1
        call output ( myBlase , advance='no' )                      
d754 1
a754 1
  subroutine DUMP_2D_REAL ( ARRAY, NAME, BLASE, CLEAN )
d757 1
a757 1
    real, intent(in), optional :: BLASE
d763 1
a763 1
    real :: myBlase
d765 2
a766 2
    myBlase = 0.e0
    if ( present(Blase) ) myBlase = Blase
d804 1
a804 1
              if ( any(array(i,j:min(j+4, size(array,2))) /= myBlase) ) then
d812 1
a812 1
                  call output ( myBlase , advance='no' )
d823 1
a823 1
            if ( myClean .or. any(array(i,j:min(j+4, size(array,2))) /= myBlase) ) then
d838 1
a838 1
          call output ( myBlase , advance='no' )                
d849 1
a849 1
            if ( any(array(i:min(i+4, size(array,1)),j) /= myBlase) ) then  
d857 1
a857 1
                call output ( myBlase , advance='no' )                      
d867 1
a867 1
            if ( myClean .or. any(array(i:min(i+4, size(array,1)),j) /= myBlase) ) then
d883 1
a883 1
        call output ( myBlase , advance='no' )                      
d891 1
a891 1
  subroutine DUMP_3D_DOUBLE ( ARRAY, NAME, BLASE, CLEAN )
d894 1
a894 1
    double precision, intent(in), optional :: BLASE
d900 1
a900 1
    double precision :: myBlase
d902 2
a903 2
    myBlase = 0.d0
    if ( present(Blase) ) myBlase = Blase
d924 1
a924 1
      call dump ( array(:,:,1), name, blase=blase, clean=clean )
d942 1
a942 1
              if ( any(array(i,j,k:min(k+4, size(array,3))) /= myBlase) ) then
d951 1
a951 1
                  call output ( myBlase , advance='no' )
d963 1
a963 1
            if ( myClean .or. any(array(i,j,k:min(k+4, size(array,3))) /= myBlase) ) then
d980 1
a980 1
        call output ( myBlase , advance='no' )                  
d1088 1
a1088 1
  subroutine DUMP_3D_REAL ( ARRAY, NAME, BLASE, CLEAN )
d1091 1
a1091 1
    real, intent(in), optional :: BLASE
d1097 1
a1097 1
    real    :: myBlase
d1099 2
a1100 2
    myBlase = 0.e0
    if ( present(Blase) ) myBlase = Blase
d1121 1
a1121 1
      call dump ( array(:,:,1), name, blase=blase, clean=clean )
d1139 1
a1139 1
              if ( any(array(i,j,k:min(k+4, size(array,3))) /= myBlase) ) then
d1148 1
a1148 1
                  call output ( myBlase , advance='no' )
d1160 1
a1160 1
            if ( myClean .or. any(array(i,j,k:min(k+4, size(array,3))) /= myBlase) ) then
d1177 1
a1177 1
        call output ( myBlase , advance='no' )                  
d1393 3
d1412 1
a1412 1
! Added optional blase arg to dump_nd_char; fixed bug where optional format not passed from dump_3d_int
@


2.20
log
@Now can dump name/value pairs
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d20 1
a20 1
    module procedure DUMP_1D_REAL, DUMP_2D_REAL
d29 1
a29 1
       "$Id: dump_0.f90,v 2.19 2002/10/08 00:09:08 pwagner Exp $"
d763 1
a763 1
    double precision :: myBlase
d1087 97
d1393 3
@


2.20.2.1
log
@Add Dump_2D_Logical, cosmetic changes
@
text
@d16 5
a20 5
    module procedure DUMP_1D_CHAR, DUMP_1D_DOUBLE
    module procedure DUMP_1D_INTEGER, DUMP_1D_LOGICAL, DUMP_1D_REAL
    module procedure DUMP_2D_CHAR, DUMP_2D_DOUBLE
    module procedure DUMP_2D_INTEGER, DUMP_2D_LOGICAL, DUMP_2D_REAL
    module procedure DUMP_3D_CHAR, DUMP_3D_DOUBLE, DUMP_3D_INTEGER
d29 1
a29 1
       "$Id: dump_0.f90,v 2.20 2002/12/02 23:34:14 pwagner Exp $"
d41 1
a41 1
  ! -----------------------------------------------  DUMP_1D_CHAR  -----
d121 187
d435 1
a435 1
  ! ----------------------------------------------  DUMP_1D_LOGICAL ----
d482 1
a482 1
  ! -----------------------------------------------  DUMP_1D_REAL  -----
a528 87
  ! -----------------------------------------------  DUMP_2D_CHAR  -----
  subroutine DUMP_2D_CHAR ( ARRAY, NAME, BLASE, CLEAN )
    character(len=*), intent(in) :: ARRAY(:,:)
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: BLASE
    logical, intent(in), optional :: CLEAN

    integer :: I, J, K
    logical :: MyClean
    integer :: NumZeroRows
    character(len=len(array)) :: myBlase

    myBlase = ' '
    if ( present(Blase) ) myBlase = Blase

    myClean = .false.
    if ( present(clean) ) myClean = clean

    numZeroRows = 0
    if ( size(array) == 0 ) then
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
    else if ( size(array) == 1 ) then
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
      end if
      call output ( array(1,1), advance='yes' )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1), name, blase=blase, clean=clean )
    else
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
      do i = 1, size(array,1)
        do j = 1, size(array,2), 10
          if (.not. myClean) then
            if ( any(array(i,j:min(j+9, size(array,2))) /= myBlase) ) then
              if ( numZeroRows /= 0 ) then
                call output ( i, places=max(4,ilog10(size(array,1))+1) )
                call output ( j-1, places=max(4,ilog10(size(array))+1) )
                call output ( afterSub )
                call output ( ' ' )
                call output ( numZeroRows )
                call output ( ' rows of "', advance='no' )
                call output ( trim(myBlase), advance='no' )
                call output ( '" not printed.', advance='yes' )
                numZeroRows = 0
              end if
              call output ( i, places=max(4,ilog10(size(array,1))+1) )
              call output ( j, places=max(4,ilog10(size(array,2))+1) )
              call output ( afterSub )
            else
              numZeroRows = numZeroRows + 1
            end if
          end if
          if ( myClean .or. any(array(i,j:min(j+9, size(array,2))) /= myBlase) ) then
            do k = j, min(j+9, size(array,2))
                call output ( array(i,k) // ' ' )
            end do
            call output ( '', advance='yes' )
          end if
        end do ! j
      end do ! i
      if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of "', advance='no' )           
        call output ( trim(myBlase), advance='no' )          
        call output ( '" not printed.', advance='yes' )      
        numZeroRows = 0
      end if
    end if
  end subroutine DUMP_2D_CHAR

d604 1
a604 1
            end if
d753 1
a753 54
  ! --------------------------------------------  DUMP_2D_LOGICAL  -----
  subroutine DUMP_2D_LOGICAL ( ARRAY, NAME, CLEAN )
    logical, intent(in) :: ARRAY(:,:)
    character(len=*), intent(in), optional :: NAME
    logical, intent(in), optional :: CLEAN

    integer :: I, J, K
    logical :: MyClean
    integer, parameter :: MyWidth = 34

    myClean = .false.
    if ( present(clean) ) myClean = clean

    if ( size(array) == 0 ) then
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
    else if ( size(array) == 1 ) then
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
      end if
      call output ( array(1,1), advance='yes' )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1), name, clean=clean )
    else
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
      do i = 1, size(array,1)
        do j = 1, size(array,2), myWidth
          if (.not. myClean) then
            call output ( i, places=max(4,ilog10(size(array,1))+1) )
            call output ( j, places=max(4,ilog10(size(array,2))+1) )
            call output ( afterSub )
          end if
          do k = j, min(j+myWidth-1, size(array,2))
            call output ( array(i,k) )
          end do
          call output ( '', advance='yes' )
        end do ! j
      end do ! i
    end if
  end subroutine DUMP_2D_LOGICAL

  ! -----------------------------------------------  DUMP_2D_REAL  -----
d828 1
a828 1
            end if
a889 100
  ! -----------------------------------------------  DUMP_3D_CHAR  -----
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, BLASE, CLEAN )
    character(len=*), intent(in) :: ARRAY(:,:,:)
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: BLASE
    logical, intent(in), optional :: CLEAN

    logical :: myClean
    integer :: I, J, K, L
    integer :: NumZeroRows
    integer, dimension(3) :: which, re_mainder
    integer :: how_many
    character(len=len(array)) :: myBlase

    myBlase = ' '
    if ( present(Blase) ) myBlase = Blase

    myClean = .false.
    if ( present(clean) ) myClean = clean
    call which_ints_are_it( (/ size(array, 1), size(array, 2), size(array, 3)/), &
      & 1, which, how_many, re_mainder=re_mainder)

    numZeroRows = 0
    if ( size(array) == 0 ) then
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
    else if ( size(array) == 1 ) then
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
      end if
      call output ( array(1,1,1), advance='yes' )
    else if ( how_many == 2 ) then
      call dump ( reshape(array, (/ re_mainder(1) /)), name, blase=blase, &
        & clean=clean )
    else if ( how_many == 1 ) then
      call dump ( reshape(array, (/ re_mainder(1), re_mainder(2) /)), &
        & name, blase=blase, clean=clean )
    else
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
      do i = 1, size(array,1)
        do j = 1, size(array,2)
          do k = 1, size(array,3), 10
            if (.not. myClean) then
              if ( any(array(i,j,k:min(k+9, size(array,3))) /= myBlase) ) then
                if ( numZeroRows /= 0 ) then
                  call output ( i, places=max(4,ilog10(size(array,1))+1) )
                  call output ( j, places=max(4,ilog10(size(array,2))+1) )
                  call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
                  call output ( afterSub )
                  call output ( ' ' )
                  call output ( numZeroRows )
                  call output ( ' rows of "', advance='no' )
                  call output ( trim(myBlase), advance='no' )
                  call output ( '" not printed.', advance='yes' )
                  numZeroRows = 0
                end if
                call output ( i, max(4,ilog10(size(array,1))+1) )
                call output ( j, max(4,ilog10(size(array,2))+1) )
                call output ( k, max(4,ilog10(size(array,3))+1) )
                call output ( afterSub )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( myClean .or. any(array(i,j,k:min(k+9, size(array,3))) /= myBlase) ) then
              do l = k, min(k+9, size(array,3))
                  call output ( array(i,j,l) // ' ' )
              end do
              call output ( '', advance='yes' )
            end if
          end do
        end do
      end do
      if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array,2))+1) )
        call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of "', advance='no' )           
        call output ( trim(myBlase), advance='no' )          
        call output ( '" not printed.', advance='yes' )      
        numZeroRows = 0
      end if
    end if
  end subroutine DUMP_3D_CHAR

d968 1
a968 1
            end if
d987 1
a987 1
  ! --------------------------------------------  DUMP_3D_INTEGER  -----
d1067 1
a1067 1
                end if
d1087 2
a1088 2
  ! -----------------------------------  DUMP_NAME_V_PAIRS_DOUBLE  -----
  subroutine DUMP_NAME_V_PAIRS_DOUBLE ( VALUES, NAMES, CLEAN, FORMAT, WIDTH )
d1115 1
a1115 1
          end if
d1119 2
a1120 2
        end if
      end do
d1122 1
a1122 1
    end do
d1126 2
a1127 2
  ! ----------------------------------  DUMP_NAME_V_PAIRS_INTEGER  -----
  subroutine DUMP_NAME_V_PAIRS_INTEGER ( VALUES, NAMES, CLEAN, FORMAT, WIDTH )
d1154 1
a1154 1
          end if
d1158 2
a1159 2
        end if
      end do
d1161 1
a1161 1
    end do
d1165 2
a1166 2
  ! -------------------------------------  DUMP_NAME_V_PAIRS_REAL  -----
  subroutine DUMP_NAME_V_PAIRS_REAL ( VALUES, NAMES, CLEAN, FORMAT, WIDTH )
d1193 1
a1193 1
          end if
d1197 2
a1198 2
        end if
      end do
d1200 1
a1200 1
    end do
d1204 2
a1205 2
  ! -----------------------------------------------------  ILOG10  -----
  integer function ILOG10(int)
d1208 1
a1208 1
  end function ILOG10
a1209 1
  ! ------------------------------------------  WHICH_INTS_ARE_IT  -----
d1213 2
a1214 1
  subroutine WHICH_INTS_ARE_IT ( INTS, IT, WHICH, HOW_MANY, RE_MAINDER, WHICH_NOT )
d1248 1
a1248 1
      end if
d1250 1
a1250 1
    end if
d1263 2
a1264 2
      end if
    end do
d1276 1
a1276 1
        end if
d1280 1
a1280 1
        end if
d1284 2
a1285 2
        end if
    end if
d1287 1
a1287 1
  end subroutine WHICH_INTS_ARE_IT
a1295 3
! Revision 2.20  2002/12/02 23:34:14  pwagner
! Now can dump name/value pairs
!
@


2.20.2.2
log
@Put new-lines in better places
@
text
@d29 1
a29 1
       "$Id: dump_0.f90,v 2.20.2.1 2003/03/14 00:25:47 vsnyder Exp $"
d470 1
d519 1
a519 1
        call output ( ' (transposed)', advance='yes' )
d747 1
d796 1
a796 1
        call output ( ' (transposed)', advance='yes' )
a1348 3
! Revision 2.20.2.1  2003/03/14 00:25:47  vsnyder
! Add Dump_2D_Logical, cosmetic changes
!
@


2.20.2.3
log
@Add WIDTH and FORMAT arguments to 1D_REAL and 1D_DOUBLE
@
text
@d29 1
a29 1
       "$Id: dump_0.f90,v 2.20.2.2 2003/03/27 23:18:33 vsnyder Exp $"
d122 1
a122 1
  subroutine DUMP_1D_DOUBLE ( ARRAY, NAME, CLEAN, WIDTH, FORMAT )
a125 2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
d127 2
a128 3
    logical :: MyClean
    integer :: J, K, MyWidth
    character(len=64) :: MyFormat
a131 4
    myWidth = 5
    if ( present(width) ) myWidth = width
    myFormat = '(1x,1pg13.6)'
    if ( present(format) ) myFormat = format
d145 1
a145 1
      call output ( array(1), myFormat, advance='yes' )
d155 1
a155 1
      do j = 1, size(array), myWidth
d157 1
a157 1
          call output ( j, max(myWidth-1,ilog10(size(array))+1) )
d160 2
a161 2
        do k = j, min(j+myWidth-1, size(array))
          call output ( array(k), myFormat )
d296 1
a296 1
  subroutine DUMP_1D_REAL ( ARRAY, NAME, CLEAN, WIDTH, FORMAT )
a299 2
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: FORMAT
d302 1
a302 2
    integer :: J, K, MyWidth
    character(len=64) :: MyFormat
a305 4
    myWidth = 5
    if ( present(width) ) myWidth = width
    myFormat = '(1x,1pg13.6)'
    if ( present(format) ) myFormat = format
d319 1
a319 1
      call output ( array(1), myFormat, advance='yes' )
d329 1
a329 1
      do j = 1, size(array), myWidth
d331 1
a331 1
          call output ( j, max(myWidth-1,ilog10(size(array))+1) )
d334 2
a335 2
        do k = j, min(j+myWidth-1, size(array))
          call output ( array(k), myFormat )
a1346 3
! Revision 2.20.2.2  2003/03/27 23:18:33  vsnyder
! Put new-lines in better places
!
@


2.20.2.4
log
@Merged in feb03 newfwm branch
@
text
@a20 1
    module procedure DUMP_3D_REAL
d29 1
a29 1
       "$Id: dump_0.f90,v 2.20.2.3 2003/04/18 20:26:05 vsnyder Exp $"
d42 1
a42 1
  subroutine DUMP_1D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN )
d45 1
a45 1
    character(len=*), intent(in), optional :: FILLVALUE
d51 1
a51 1
    character(len=len(array)) :: myFillValue
d53 2
a54 2
    myFillValue = ' '
    if ( present(FillValue) ) myFillValue = FillValue
d84 1
a84 1
          if ( any(array(j:min(j+9, size(array))) /= myFillValue) ) then
d91 1
a91 1
              call output ( trim(myFillValue), advance='no' )
d101 1
a101 1
        if ( myClean .or. any(array(j:min(j+9, size(array))) /= myFillValue) ) then
d114 1
a114 1
        call output ( trim(myFillValue), advance='no' )          
d357 1
a357 1
  subroutine DUMP_2D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN )
d360 1
a360 1
    character(len=*), intent(in), optional :: FILLVALUE
d366 1
a366 1
    character(len=len(array)) :: myFillValue
d368 2
a369 2
    myFillValue = ' '
    if ( present(FillValue) ) myFillValue = FillValue
d389 1
a389 1
      call dump ( array(:,1), name, fillValue=fillValue, clean=clean )
d402 1
a402 1
            if ( any(array(i,j:min(j+9, size(array,2))) /= myFillValue) ) then
d410 1
a410 1
                call output ( trim(myFillValue), advance='no' )
d421 1
a421 1
          if ( myClean .or. any(array(i,j:min(j+9, size(array,2))) /= myFillValue) ) then
d436 1
a436 1
        call output ( trim(myFillValue), advance='no' )          
d444 1
a444 1
  subroutine DUMP_2D_DOUBLE ( ARRAY, NAME, FILLVALUE, CLEAN )
d447 1
a447 1
    double precision, intent(in), optional :: FILLVALUE
d453 1
a453 1
    double precision :: myFillValue
d455 2
a456 2
    myFillValue = 0.d0
    if ( present(FillValue) ) myFillValue = FillValue
d493 1
a493 1
              if ( any(array(i,j:min(j+4, size(array,2))) /= myFillValue) ) then
d501 1
a501 1
                  call output ( myFillValue , advance='no' )
d512 1
a512 1
            if ( myClean .or. any(array(i,j:min(j+4, size(array,2))) /= myFillValue) ) then
d527 1
a527 1
          call output ( myFillValue , advance='no' )                
d538 1
a538 1
            if ( any(array(i:min(i+4, size(array,1)),j) /= myFillValue) ) then  
d546 1
a546 1
                call output ( myFillValue , advance='no' )                      
d556 1
a556 1
            if ( myClean .or. any(array(i:min(i+4, size(array,1)),j) /= myFillValue) ) then
d572 1
a572 1
        call output ( myFillValue , advance='no' )                      
d720 1
a720 1
  subroutine DUMP_2D_REAL ( ARRAY, NAME, FILLVALUE, CLEAN )
d723 1
a723 1
    real, intent(in), optional :: FILLVALUE
d729 1
a729 1
    double precision :: myFillValue
d731 2
a732 2
    myFillValue = 0.e0
    if ( present(FillValue) ) myFillValue = FillValue
d769 1
a769 1
              if ( any(array(i,j:min(j+4, size(array,2))) /= myFillValue) ) then
d777 1
a777 1
                  call output ( myFillValue , advance='no' )
d788 1
a788 1
            if ( myClean .or. any(array(i,j:min(j+4, size(array,2))) /= myFillValue) ) then
d803 1
a803 1
          call output ( myFillValue , advance='no' )                
d814 1
a814 1
            if ( any(array(i:min(i+4, size(array,1)),j) /= myFillValue) ) then  
d822 1
a822 1
                call output ( myFillValue , advance='no' )                      
d832 1
a832 1
            if ( myClean .or. any(array(i:min(i+4, size(array,1)),j) /= myFillValue) ) then
d848 1
a848 1
        call output ( myFillValue , advance='no' )                      
d856 1
a856 1
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, FILLVALUE, CLEAN )
d859 1
a859 1
    character(len=*), intent(in), optional :: FILLVALUE
d867 1
a867 1
    character(len=len(array)) :: myFillValue
d869 2
a870 2
    myFillValue = ' '
    if ( present(FillValue) ) myFillValue = FillValue
d892 1
a892 1
      call dump ( reshape(array, (/ re_mainder(1) /)), name, fillValue=fillValue, &
d896 1
a896 1
        & name, fillValue=fillValue, clean=clean )
d910 1
a910 1
              if ( any(array(i,j,k:min(k+9, size(array,3))) /= myFillValue) ) then
d919 1
a919 1
                  call output ( trim(myFillValue), advance='no' )
d931 1
a931 1
            if ( myClean .or. any(array(i,j,k:min(k+9, size(array,3))) /= myFillValue) ) then
d948 1
a948 1
        call output ( trim(myFillValue), advance='no' )          
d956 1
a956 1
  subroutine DUMP_3D_DOUBLE ( ARRAY, NAME, FILLVALUE, CLEAN )
d959 1
a959 1
    double precision, intent(in), optional :: FILLVALUE
d965 1
a965 1
    double precision :: myFillValue
d967 2
a968 2
    myFillValue = 0.d0
    if ( present(FillValue) ) myFillValue = FillValue
d989 1
a989 1
      call dump ( array(:,:,1), name, fillValue=fillValue, clean=clean )
d1007 1
a1007 1
              if ( any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
d1016 1
a1016 1
                  call output ( myFillValue , advance='no' )
d1028 1
a1028 1
            if ( myClean .or. any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
d1045 1
a1045 1
        call output ( myFillValue , advance='no' )                  
a1151 98
  ! ---------------------------------------------  DUMP_3D_REAL  -----
  subroutine DUMP_3D_REAL ( ARRAY, NAME, FILLVALUE, CLEAN )
    real, intent(in) :: ARRAY(:,:,:)
    character(len=*), intent(in), optional :: NAME
    real, intent(in), optional :: FILLVALUE
    logical, intent(in), optional :: CLEAN

    logical :: myClean
    integer :: I, J, K, L
    integer :: NumZeroRows
    real    :: myFillValue

    myFillValue = 0.e0
    if ( present(FillValue) ) myFillValue = FillValue
    myClean = .false.
    if ( present(clean) ) myClean = clean

    numZeroRows = 0
    if ( size(array) == 0 ) then
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
    else if ( size(array) == 1 ) then
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
      end if
      call output ( array(1,1,1), '(1x,1pg13.6)', advance='yes' )
    else if ( size(array,2) == 1 .and. size(array,3) == 1 ) then
      call dump ( array(:,1,1), name, clean=clean )
    else if ( size(array,3) == 1 ) then
      call dump ( array(:,:,1), name, fillValue=fillValue, clean=clean )
    else
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
      do i = 1, size(array,1)
        do j = 1, size(array,2)
          do k = 1, size(array,3), 5
            if (.not. myClean) then
              !call output ( i, max(4,ilog10(size(array,1))+1) )
              !call output ( j, max(4,ilog10(size(array,2))+1) )
              !call output ( k, max(4,ilog10(size(array,3))+1) )
              !call output ( afterSub )
              if ( any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
                if ( numZeroRows /= 0 ) then
                  call output ( i, places=max(4,ilog10(size(array,1))+1) )
                  call output ( j, places=max(4,ilog10(size(array,2))+1) )
                  call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
                  call output ( afterSub )
                  call output ( ' ' )
                  call output ( numZeroRows )
                  call output ( ' rows of ')
                  call output ( myFillValue , advance='no' )
                  call output ( ' not printed.', advance='yes' )
                  numZeroRows = 0
                end if
                call output ( i, max(4,ilog10(size(array,1))+1) )
                call output ( j, max(4,ilog10(size(array,2))+1) )
                call output ( k, max(4,ilog10(size(array,3))+1) )
                call output ( afterSub )
              else
                numZeroRows = numZeroRows + 1
              end if
            end if
            if ( myClean .or. any(array(i,j,k:min(k+4, size(array,3))) /= myFillValue) ) then
              do l = k, min(k+4, size(array,3))
                call output ( array(i,j,l), '(1x,1pg13.6)' )
              end do
              call output ( '', advance='yes' )
            endif
          end do
        end do
      end do
       if ( numZeroRows /= 0 ) then
        call output ( i-1, places=max(4,ilog10(size(array,1))+1) )
        call output ( j-1, places=max(4,ilog10(size(array,2))+1) )
        call output ( k-1, places=max(4,ilog10(size(array,3))+1) )
        call output ( afterSub )
        call output ( ' ' )
        call output ( numZeroRows )
        call output ( ' rows of ')                              
        call output ( myFillValue , advance='no' )                  
        call output ( ' not printed.', advance='yes' )          
        numZeroRows = 0
      end if
   end if
  end subroutine DUMP_3D_REAL


a1360 3
! Revision 2.20.2.3  2003/04/18 20:26:05  vsnyder
! Add WIDTH and FORMAT arguments to 1D_REAL and 1D_DOUBLE
!
d1383 1
a1383 2
! Added optional blase arg to dump_nd_char; fixed bug where optional
! format not passed from dump_3d_int
@


2.19
log
@Added idents to survive zealous Lahey optimizer
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d8 2
a9 1
  use OUTPUT_M, only: OUTPUT
d13 1
a13 1
  public :: AfterSub, DUMP
d15 1
a15 1
  interface DUMP
d22 4
d29 1
a29 1
       "$Id: dump_0.f90,v 2.18 2002/09/13 18:08:12 pwagner Exp $"
d1087 118
d1296 3
@


2.18
log
@May change matrix precision rm from r8
@
text
@d24 1
a24 1
       "$Id: dump_0.f90,v 2.17 2002/02/14 23:21:18 vsnyder Exp $"
d28 1
d1166 4
d1173 3
@


2.17
log
@Work on dumping masks
@
text
@d19 1
a19 1
    module procedure DUMP_1D_REAL
d24 1
a24 1
       "$Id: dump_0.f90,v 2.16 2001/12/08 00:47:51 pwagner Exp $"
d476 47
d747 137
a1080 47
  ! ---------------------------------------------  DUMP_1D_REAL  -----
  subroutine DUMP_1D_REAL ( ARRAY, NAME, CLEAN )
    real, intent(in) :: ARRAY(:)
    character(len=*), intent(in), optional :: NAME
    logical, intent(in), optional :: CLEAN

    logical :: myClean
    integer :: J, K

    myClean = .false.
    if ( present(clean) ) myClean = clean

    if ( size(array) == 0 ) then
      if ( present(name) ) then
        call output ( name )
        call output ( ' is ' )
      end if
      call output ( 'empty', advance='yes' )
    else if ( size(array) == 1 ) then
      if ( present(name) ) then
        call output ( name )
        if ( myClean ) call output ( ' \ 1 ' )
        call output ( ' ' )
      end if
      call output ( array(1), '(1x,1pg13.6)', advance='yes' )
    else
      if ( present(name) ) then 
        call output ( name )
        if ( myClean ) then 
          call output ( ' \ ' )
          call output ( size(array) )
        end if
        call output ( '', advance='yes' )
      end if
      do j = 1, size(array), 5
        if (.not. myClean) then
          call output ( j, max(4,ilog10(size(array))+1) )
          call output ( afterSub )
        end if
        do k = j, min(j+4, size(array))
          call output ( array(k), '(1x,1pg13.6)' )
        end do
        call output ( '', advance='yes' )
      end do
    end if
  end subroutine DUMP_1D_REAL

d1168 3
@


2.16
log
@Added dump_1d_real for s.p. arrays
@
text
@d24 1
a24 1
       "$Id: dump_0.f90,v 2.15 2001/11/29 23:50:53 pwagner Exp $"
d350 1
a350 1
  subroutine DUMP_1D_INTEGER ( ARRAY, NAME, CLEAN, FORMAT )
d355 1
d359 1
d364 2
d390 1
a390 1
      do j = 1, size(array), 10
d392 1
a392 1
          if ( any(array(j:min(j+9, size(array))) /= 0) ) then
d407 2
a408 2
        if ( myClean .or. any(array(j:min(j+9, size(array))) /= 0) ) then
          do k = j, min(j+9, size(array))
d614 1
a614 1
  subroutine DUMP_2D_INTEGER ( ARRAY, NAME, CLEAN, FORMAT )
d619 1
d623 1
d628 2
d646 1
a646 1
      call dump ( array(:,1), name, clean=clean, format=format )
d657 1
a657 1
        do j = 1, size(array,2), 10
d659 1
a659 1
            if ( any(array(i,j:min(j+9, size(array,2))) /= 0) ) then
d676 2
a677 2
          if ( myClean .or. any(array(i,j:min(j+9, size(array,2))) /= 0) ) then
            do k = j, min(j+9, size(array,2))
d798 1
a798 1
  subroutine DUMP_3D_INTEGER ( ARRAY, NAME, CLEAN, FORMAT )
d803 1
d805 1
d807 1
a807 1
    integer :: I, J, K, L
d814 2
d850 1
a850 1
          do k = 1, size(array,3), 10
d852 1
a852 1
              if ( any(array(i,j,k:min(k+9, size(array,3))) /= 0) ) then
d871 2
a872 2
            if ( myClean .or. any(array(i,j,k:min(k+9, size(array,3))) /= 0) ) then
              do l = k, min(k+9, size(array,3))
d1031 3
@


2.15
log
@Added optional blase arg to dump_nd_char; fixed bug where optional format not passed from dump_3d_int
@
text
@d19 1
d24 1
a24 1
       "$Id: dump_0.f90,v 2.14 2001/11/28 23:32:01 livesey Exp $"
d885 47
d1019 3
@


2.14
log
@Fixed bug where dump_2d_integer didn't pass format to 1d dump.
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d23 1
a23 1
       "$Id: dump_0.f90,v 2.13 2001/10/25 23:30:39 pwagner Exp $"
d35 1
a35 1
  subroutine DUMP_1D_CHAR ( ARRAY, NAME, CLEAN )
d38 1
d44 4
d77 1
a77 1
          if ( any(array(j:min(j+9, size(array))) /= ' ') ) then
d83 3
a85 1
              call output ( ' rows of blanks not printed.', advance='yes' )
d94 1
a94 1
        if ( myClean .or. any(array(j:min(j+9, size(array))) /= ' ') ) then
d106 3
a108 1
        call output ( ' rows of blanks not printed.', advance='yes' )
d115 1
a115 1
  subroutine DUMP_2D_CHAR ( ARRAY, NAME, CLEAN )
d118 1
d124 4
d147 1
a147 1
      call dump ( array(:,1), name, clean=clean )
d160 1
a160 1
            if ( any(array(i,j:min(j+9, size(array,2))) /= ' ') ) then
d167 3
a169 1
                call output ( ' rows of blanks not printed.', advance='yes' )
d179 1
a179 1
          if ( myClean .or. any(array(i,j:min(j+9, size(array,2))) /= ' ') ) then
d193 3
a195 1
        call output ( ' rows of blanks not printed.', advance='yes' )
d202 1
a202 1
  subroutine DUMP_3D_CHAR ( ARRAY, NAME, CLEAN )
d205 1
d213 4
d238 2
a239 1
      call dump ( reshape(array, (/ re_mainder(1) /)), name, clean=clean )
d242 1
a242 1
        & name, clean=clean )
d256 1
a256 1
              if ( any(array(i,j,k:min(k+9, size(array,3))) /= ' ') ) then
d264 3
a266 1
                  call output ( ' rows of blanks not printed.', advance='yes' )
d277 1
a277 1
            if ( myClean .or. any(array(i,j,k:min(k+9, size(array,3))) /= ' ') ) then
d293 3
a295 1
        call output ( ' rows of blanks not printed.', advance='yes' )
d725 1
a725 1
      call dump ( array(:,:,1), name, clean=clean )
d821 2
a822 1
      call dump ( reshape(array, (/ re_mainder(1) /)), name, clean=clean )
d825 1
a825 1
        & name, clean=clean )
d971 3
@


2.13
log
@Improved dump_nd_double to skip rows (e.g., of zeros)
@
text
@d23 1
a23 1
       "$Id: dump_0.f90,v 2.12 2001/10/24 18:11:14 pwagner Exp $"
d609 1
a609 1
      call dump ( array(:,1), name, clean=clean )
d942 3
@


2.12
log
@which_ints_are_it now works properly
@
text
@d23 1
a23 1
       "$Id: dump_0.f90,v 2.11 2001/10/23 22:40:37 pwagner Exp $"
d444 1
a444 1
  subroutine DUMP_2D_DOUBLE ( ARRAY, NAME, CLEAN )
d447 1
d452 5
d461 1
d491 21
a511 3
              call output ( i, max(4,ilog10(size(array,1))+1) )
              call output ( j, max(4,ilog10(size(array,2))+1) )
              call output ( afterSub )
d513 6
a518 4
            do k = j, min(j+4, size(array,2))
              call output ( array(i,k), '(1x,1pg13.6)' )
            end do
            call output ( '', advance='yes' )
d521 11
d536 27
a562 7
            call output ( i, max(4,ilog10(size(array,1))+1) )
            call output ( j, max(4,ilog10(size(array,2))+1) )
            call output ( afterSub )
            do k = i, min(i+4, size(array,1))
              call output ( array(k,j), '(1x,1pg13.6)' )
            end do
            call output ( '', advance='yes' )
d566 11
d664 1
a664 1
  subroutine DUMP_3D_DOUBLE ( ARRAY, NAME, CLEAN )
d667 1
d672 2
d675 2
d680 1
d711 24
a734 4
              call output ( i, max(4,ilog10(size(array,1))+1) )
              call output ( j, max(4,ilog10(size(array,2))+1) )
              call output ( k, max(4,ilog10(size(array,3))+1) )
              call output ( afterSub )
d736 6
a741 4
            do l = k, min(k+4, size(array,3))
              call output ( array(i,j,l), '(1x,1pg13.6)' )
            end do
            call output ( '', advance='yes' )
d745 13
a757 1
    end if
d810 1
a810 1
              if ( any(array(i,j,k:min(k+9, size(array,k))) /= 0) ) then
d942 3
@


2.11
log
@Now dumps 1d,2d,3d char arrays and 3d ints
@
text
@d23 1
a23 1
       "$Id: dump_0.f90,v 2.10 2001/09/28 22:43:20 vsnyder Exp $"
d30 1
d198 1
a198 1
      & 1, which, how_many, re_mainder)
d667 1
a667 1
      & 1, which, how_many, re_mainder)
d755 2
a756 2
  subroutine which_ints_are_it(ints, it, which, how_many, re_mainder)
    ! Return which of ints = it
d758 1
d761 4
a764 1
    ! produces which = /(3, 5)/, how_many = 2, re_mainder = /(4, 3, 2, 3)/
d775 1
d782 8
d800 2
d803 1
a803 1
          & re_mainder(min(size(re_mainder), i_re_mainder)) = i
d807 20
d833 3
@


2.10
log
@Don't print rows of zeroes
@
text
@d17 2
d23 1
a23 1
       "$Id: dump_0.f90,v 2.9 2001/09/11 22:52:32 livesey Exp $"
d33 239
d650 95
d750 44
d797 3
@


2.9
log
@Added printing of sizes
@
text
@d21 1
a21 1
       "$Id: dump_0.f90,v 2.8 2001/05/11 22:44:54 vsnyder Exp $"
d62 1
a62 1
        endif
d64 1
a64 1
      endif
d69 1
a69 1
        endif
a84 1
    logical :: myClean
d86 2
d92 1
d112 1
a112 1
        endif
d114 1
a114 1
      endif
d117 11
a127 6
          call output ( j, places=max(4,ilog10(size(array))+1) )
          call output ( afterSub )
        endif
        do k = j, min(j+9, size(array))
          if ( present(format) ) then
            call output ( array(k), format=format )
d129 1
a129 1
            call output ( array(k), places=6 )
d131 20
a150 3
        end do
        call output ( '', advance='yes' )
      end do
d185 1
a185 1
        endif
d187 1
a187 1
      endif
d192 1
a192 1
        endif
d234 1
a234 1
        endif
d236 1
a236 1
      endif
a275 1
    logical :: myClean
d277 2
d283 1
d305 1
a305 1
        endif
d307 1
a307 1
      endif
d311 13
a323 7
             call output ( i, places=max(4,ilog10(size(array,1))+1) )
             call output ( j, places=max(4,ilog10(size(array,2))+1) )
             call output ( afterSub )
          end if
          do k = j, min(j+9, size(array,2))
            if ( present(format) ) then
              call output ( array(i,k), format=format )
d325 1
a325 1
              call output ( array(i,k), places=6 )
d327 22
a348 4
          end do
          call output ( '', advance='yes' )
        end do
      end do
d387 1
a387 1
        endif
d389 1
a389 1
      endif
d398 1
a398 1
            endif
d417 3
@


2.8
log
@Print transpose of 2d-double if it would take fewer lines.  Get rid of
double printing of "without mask"
@
text
@d21 1
a21 1
       "$Id: dump_0.f90,v 2.7 2001/05/08 20:27:24 vsnyder Exp $"
d52 1
d57 8
a64 1
      if ( present(name) ) call output ( name, advance='yes' )
d100 1
d105 8
a112 1
      if ( present(name) ) call output ( name, advance='yes' )
d151 1
d156 8
a163 1
      if ( present(name) ) call output ( name, advance='yes' )
d198 1
d203 10
a212 3
      call dump ( array(:,1), name )
    else
      if ( present(name) ) call output ( name )
d267 1
d272 1
a272 1
      call dump ( array(:,1), name )
d274 8
a281 1
      if ( present(name) ) call output ( name, advance='yes' )
d323 1
d328 1
a328 1
      call dump ( array(:,1,1), name )
d330 1
a330 1
      call dump ( array(:,:,1), name )
d332 8
a339 1
      if ( present(name) ) call output ( name, advance='yes' )
d367 4
@


2.7
log
@Added an optional 'format' argument in a few more places
@
text
@d21 1
a21 1
       "$Id: dump_0.f90,v 2.6 2001/05/08 17:21:02 livesey Exp $"
d180 20
a199 4
      if ( present(name) ) call output ( name, advance='yes' )
      do i = 1, size(array,1)
        do j = 1, size(array,2), 5
          if (.not. myClean) then
d203 4
a206 3
          endif
          do k = j, min(j+4, size(array,2))
            call output ( array(i,k), '(1x,1pg13.6)' )
a207 1
          call output ( '', advance='yes' )
d209 1
a209 1
      end do
d319 3
@


2.6
log
@Added a `clean' option to the array dumps.  This omits the indices at
the start, making it easier for other programs to read output.
@
text
@d21 1
a21 1
       "$Id: dump_0.f90,v 2.5 2001/05/03 02:12:34 vsnyder Exp $"
d71 1
a71 1
  subroutine DUMP_1D_INTEGER ( ARRAY, NAME, CLEAN )
d75 1
d99 1
a99 1
          call output ( j, max(4,ilog10(size(array))+1) )
d103 5
a107 1
          call output ( array(k), 6 )
d198 1
a198 1
  subroutine DUMP_2D_INTEGER ( ARRAY, NAME, CLEAN )
d202 1
d229 3
a231 3
            call output ( i, max(4,ilog10(size(array,1))+1) )
            call output ( j, max(4,ilog10(size(array,2))+1) )
            call output ( afterSub )
d234 5
a238 1
            call output ( array(i,k), 6 )
d303 4
@


2.5
log
@Insert copyright notice, clean up CVS stuff, cosmetics
@
text
@d21 1
a21 1
       "$Id: $"
d24 1
a24 1
       "$RCSfile: $"
d32 1
a32 1
  subroutine DUMP_1D_DOUBLE ( ARRAY, NAME )
d35 3
d39 4
d58 4
a61 1
        call output ( j, max(4,ilog10(size(array))+1) ); call output ( afterSub )
d71 1
a71 1
  subroutine DUMP_1D_INTEGER ( ARRAY, NAME )
d74 3
d78 4
d97 4
a100 1
        call output ( j, max(4,ilog10(size(array))+1) ); call output ( afterSub )
d110 1
a110 1
  subroutine DUMP_1D_LOGICAL ( ARRAY, NAME )
d113 3
d117 4
d136 4
a139 1
        call output ( j, max(4,ilog10(size(array))+1) ); call output ( afterSub )
d149 1
a149 1
  subroutine DUMP_2D_DOUBLE ( ARRAY, NAME )
d152 3
d156 4
d178 5
a182 3
          call output ( i, max(4,ilog10(size(array,1))+1) )
          call output ( j, max(4,ilog10(size(array,2))+1) )
          call output ( afterSub )
d193 1
a193 1
  subroutine DUMP_2D_INTEGER ( ARRAY, NAME )
d196 3
d200 4
d222 5
a226 2
          call output ( i, max(4,ilog10(size(array,1))+1) )
          call output ( j, max(4,ilog10(size(array,2))+1) ); call output ( afterSub )
d237 1
a237 1
  subroutine DUMP_3D_DOUBLE ( ARRAY, NAME )
d240 3
d244 4
d269 6
a274 4
            call output ( i, max(4,ilog10(size(array,1))+1) )
            call output ( j, max(4,ilog10(size(array,2))+1) )
            call output ( k, max(4,ilog10(size(array,3))+1) )
            call output ( afterSub )
d293 3
@


2.4
log
@Improve handling of "name" if size==1 or size==0
@
text
@d1 3
d8 1
a8 1
use OUTPUT_M, only: OUTPUT
d10 16
a25 15
implicit NONE
private
public :: AfterSub, DUMP

interface DUMP
  module procedure DUMP_1D_DOUBLE, DUMP_1D_INTEGER, DUMP_1D_LOGICAL
  module procedure DUMP_2D_DOUBLE, DUMP_2D_INTEGER, DUMP_3D_DOUBLE
end interface

!---------------------------- RCS Ident Info ---------------------------
  character (len=256) :: Id = &
       "$Id: dump_0.f90,v 2.3 2001/03/02 01:32:08 livesey Exp $"
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: dump_0.f90,v $"
!-----------------------------------------------------------------------
d235 3
@


2.3
log
@Handles larger arrays better
@
text
@d18 1
a18 1
       "$Id: dump_0.f90,v 2.2 2001/02/28 21:35:27 livesey Exp $"
d32 11
a42 2
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
d61 11
a71 2
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
d90 11
a100 2
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
d119 11
a129 2
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
d154 11
a164 2
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
d188 11
a198 2
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
d231 3
@


2.2
log
@Added dump logical 1d
@
text
@d18 1
a18 1
       "$Id: dump_0.f90,v 2.1 2000/09/13 20:38:50 vsnyder Exp $"
d38 1
a38 1
        call output ( j, 4 ); call output ( afterSub )
d58 1
a58 1
        call output ( j, 4 ); call output ( afterSub )
d78 1
a78 1
        call output ( j, 4 ); call output ( afterSub )
d101 3
a103 2
          call output ( i, 4 )
          call output ( j, 4 ); call output ( afterSub )
d127 2
a128 2
          call output ( i, 4 )
          call output ( j, 4 ); call output ( afterSub )
d155 4
a158 3
            call output ( i, 4 )
            call output ( j, 4 )
            call output ( k, 4 ); call output ( afterSub )
d168 6
d177 3
@


2.1
log
@Initial code
@
text
@d12 2
a13 2
  module procedure DUMP_1D_DOUBLE, DUMP_1D_INTEGER, DUMP_2D_DOUBLE
  module procedure DUMP_2D_INTEGER, DUMP_3D_DOUBLE
d18 1
a18 1
       "$Id: dumper.f90,v 2.0 2000/09/05 18:57:05 ahanzel Exp $"
d20 1
a20 1
       "$RCSfile: dumper.f90,v $"
d67 20
d168 4
a171 1
! $Log: $
@

