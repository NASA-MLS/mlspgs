head	2.3;
access;
symbols
	V0_1:1.1;
locks; strict;
comment	@# @;


2.3
date	2000.10.11.00.02.16;	author vsnyder;	state dead;
branches;
next	2.2;

2.2
date	2000.10.09.23.29.54;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.04.18.07.04;	author vsnyder;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.17.41.50;	author dcuddy;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.06.01.43.12;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.3
log
@Moved to ~/mlspgs/lib
@
text
@module OUTPUT_M

  use MLSMessageModule, only: MLSMessage, MLSMSG_Info
  implicit NONE
  private

  integer, save, public :: LINE_WIDTH = 120 ! Not used here, but a convenient
                                        ! place to store it
  integer, save, public :: PRUNIT = -1  ! Unit for output.  "printer" unit, *
                                        ! if -1, MLSMessage if -2, both
                                        ! printer and MLSMSG if < -2.

  public :: BLANKS, OUTPUT
  interface OUTPUT
    module procedure output_char, output_char_array, output_double
    module procedure output_integer
  end interface

  integer, save, public :: MLSMSG_Level = MLSMSG_Info

!---------------------------- RCS Ident Info -------------------------------
  character (len=256), private :: Id = &
       "$Id: output_m.f90,v 2.2 2000/10/09 23:29:54 vsnyder Exp $"
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: output_m.f90,v $"
!---------------------------------------------------------------------------

contains

  subroutine BLANKS ( N_BLANKS, ADVANCE )
  ! Output N_BLANKS blanks to PRUNIT.
    integer, intent(in) :: N_BLANKS
    character(len=*), intent(in), optional :: ADVANCE
    character(len=3) :: ADV
    character(len=*), parameter :: B = &
    '                                                                    '
    integer :: I    ! Blanks to write in next WRITE statement
    integer :: N    ! Blanks remaining to write
    character(len=3) :: MY_ADV
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    n = n_blanks
    adv = 'no'
    do
      i = min(n,len(b))
      n = n - i
      if ( n == 0 ) adv = my_adv
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, '(a)', advance=adv ) b(:i)
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, b(:i), advance=adv )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=adv ) b(:i)
      if ( n == 0 ) exit
    end do
    return
  end subroutine BLANKS

  subroutine OUTPUT_CHAR ( CHARS, ADVANCE )
  ! Output CHARS to PRUNIT.
    character(len=*), intent(in) :: CHARS
    character(len=*), intent(in), optional :: ADVANCE
    character(len=3) :: MY_ADV
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    if ( prunit == -1 .or. prunit < -2 ) &
      & write ( *, '(a)', advance=my_adv ) chars
    if ( prunit < -1 ) &
      & call MLSMessage ( MLSMSG_Level, ModuleName, chars, advance=my_adv )
    if ( prunit >= 0 ) &
      & write ( prunit, '(a)', advance=my_adv ) chars
  end subroutine OUTPUT_CHAR

  subroutine OUTPUT_CHAR_ARRAY ( CHARS, ADVANCE )
  ! Output CHARS to PRUNIT.
    character(len=*), intent(in) :: CHARS(:)
    character(len=*), intent(in), optional :: ADVANCE
    integer :: I ! loop inductor
    do i = 1, size(chars)
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, '(a)', advance='no' ) chars(i)
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, chars(i), advance='no' )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance='no' ) chars(i)
    end do
    if ( present(advance) ) then
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, '(a)', advance=advance )
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, '', advance=advance )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=advance )
    end if
  end subroutine OUTPUT_CHAR_ARRAY

  subroutine OUTPUT_DOUBLE ( VALUE, FORMAT, ADVANCE )
  ! Output "double" to "prunit" using * format, trimmed of insignificant
  ! trailing zeroes, and trimmed of blanks at both ends.
    double precision, intent(in) :: VALUE
    character(len=*), intent(in), optional :: FORMAT
    character(len=*), intent(in), optional :: ADVANCE
    integer :: I, J, K
    character(len=30) :: LINE
    character(len=3) :: MY_ADV
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    if ( present(format) ) then
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, format, advance=my_adv ) value
      if ( prunit < -1 ) then
        write ( line, * ) value
        call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
          & advance=advance )
      end if
      if ( prunit >= 0 ) &
        & write ( prunit, format, advance=my_adv ) value
    else
      write ( line, * ) value
      i = index(line,'.')
      j = scan(line(i:),'DdEe ') + i - 1
      if ( i /= 0 ) then
        if ( j == i ) j = len(line)
        i = i + 2
        k = j
        do while ( j > i )
          j = j - 1
          if ( line(j:j) /= '0' .and. line(j:j) /= ' ') exit
        end do
        line(j:) = line(k:)
      end if
      line = adjustl(line)
      k = len_trim(line)
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, '(a)', advance=my_adv ) line(:k)
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, line(:k), &
          & advance=advance )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=my_adv ) line(:k)
    end if
  end subroutine OUTPUT_DOUBLE

  subroutine OUTPUT_INTEGER ( INT, PLACES, ADVANCE )
  ! Output INT to PRUNIT using at most PLACES (default zero) places
    integer, intent(in) :: INT
    integer, intent(in), optional :: PLACES
    character(len=*), intent(in), optional :: ADVANCE
    integer :: I
    character(len=6) :: LINE
    character(len=3) :: MY_ADV
    integer :: MY_PLACES
    my_places = 0
    if ( present(places) ) then; my_places = places; end if
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    write ( line, '(i6)' ) int
    i = max( 1, min(len(line)+1-my_places, index(line,' ',back=.true.)+1) )
    if ( prunit == -1 .or. prunit < -2 ) &
      & write ( *, '(a)', advance=my_adv ) line(i:)
    if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, line(i:), &
          & advance=advance )
    if ( prunit >= 0 ) &
      & write ( prunit, '(a)', advance=my_adv ) line(i:)
    return
  end subroutine OUTPUT_INTEGER

  subroutine OUTPUT_SINGLE ( VALUE, FORMAT, ADVANCE )
  ! Output "SINGLE" to "prunit" using * format, trimmed of insignificant
  ! trailing zeroes, and trimmed of blanks at both ends.
    real, intent(in) :: VALUE
    character(len=*), intent(in), optional :: FORMAT
    character(len=*), intent(in), optional :: ADVANCE
    integer :: I, J, K
    character(len=30) :: LINE
    character(len=3) :: MY_ADV
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    if ( present(format) ) then
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, format, advance=my_adv ) value
      if ( prunit < -1 ) then
        write ( line, * ) value
        call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
          & advance=advance )
      end if
      if ( prunit >= 0 ) &
        & write ( prunit, format, advance=my_adv ) value
    else
      write ( line, * ) value
      i = index(line,'.')
      j = scan(line(i:),'DdEe ') + i - 1
      if ( i /= 0 ) then
        if ( j == i ) j = len(line)
        i = i + 2
        k = j
        do while ( j > i )
          j = j - 1
          if ( line(j:j) /= '0' .and. line(j:j) /= ' ') exit
        end do
        line(j:) = line(k:)
      end if
      line = adjustl(line)
      k = len_trim(line)
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, '(a)', advance=my_adv ) line(:k)
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, line(:k), &
          & advance=advance )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=my_adv ) line(:k)
    end if
  end subroutine OUTPUT_SINGLE
end module OUTPUT_M

! $Log: output_m.f90,v $
! Revision 2.2  2000/10/09 23:29:54  vsnyder
! Must have updated something -- permissions weren't r--r--r--.
!
! Revision 2.1  2000/10/04 18:07:04  vsnyder
! Added capability to output through MLSMessage
!
! Revision 2.0  2000/09/05 17:41:50  dcuddy
! Change revision to 2.0
!
! Revision 1.1  2000/07/06 01:43:12  vsnyder
! Initial check-in
!
@


2.2
log
@Must have updated something -- permissions weren't r--r--r--.
@
text
@d23 1
a23 1
       "$Id: output_m.f90,v 2.1 2000/10/04 18:07:04 vsnyder Exp $"
d218 3
@


2.1
log
@Added capability to output through MLSMessage
@
text
@d19 1
a19 2
! integer, save, public :: MLSMSG_Level = MLSMSG_Info
  integer, save, public :: MLSMSG_Level = 2
d23 1
a23 1
       "$Id: output_m.f90,v 2.0 2000/09/05 17:41:50 dcuddy Exp $"
d218 3
@


2.0
log
@Change revision to 2.0
@
text
@d3 1
d9 3
a11 1
  integer, save, public :: PRUNIT = -1  ! "printer" unit, * if < 0.
d19 3
d24 1
a24 1
       "$Id: output_m.f90,v 1.1 2000/07/06 01:43:12 vsnyder Exp $"
d49 6
a54 5
      if ( prunit < 0 ) then
        write ( *, '(a)', advance=adv ) b(:i)
      else
        write ( prunit, '(a)', advance=adv ) b(:i)
      end if
d67 6
a72 5
    if ( prunit < 0 ) then
      write ( *, '(a)', advance=my_adv ) chars
    else
      write ( prunit, '(a)', advance=my_adv ) chars
    end if
d81 6
a86 5
      if ( prunit < 0 ) then
        write ( *, '(a)', advance='no' ) chars(i:i)
      else
        write ( prunit, '(a)', advance='no' ) chars(i:i)
      end if
d89 6
a94 5
      if ( prunit < 0 ) then
        write ( *, '(a)', advance=advance )
      else
        write ( prunit, '(a)', advance=advance )
      end if
d110 6
a115 4
      if ( prunit < 0 ) then
        write ( *, format, advance=my_adv ) value
      else
        write ( prunit, format, advance=my_adv ) value
d117 2
d135 7
a141 5
      if ( prunit < 0 ) then
        write ( *, '(a)', advance=my_adv ) line(:k)
      else
        write ( prunit, '(a)', advance=my_adv ) line(:k)
      end if
d160 7
a166 5
    if ( prunit < 0 ) then
      write ( *, '(a)', advance=my_adv ) line(i:)
    else
      write ( prunit, '(a)', advance=my_adv ) line(i:)
    end if
d182 6
a187 4
      if ( prunit < 0 ) then
        write ( *, format, advance=my_adv ) value
      else
        write ( prunit, format, advance=my_adv ) value
d189 2
d207 7
a213 5
      if ( prunit < 0 ) then
        write ( *, '(a)', advance=my_adv ) line(:k)
      else
        write ( prunit, '(a)', advance=my_adv ) line(:k)
      end if
d219 3
@


1.1
log
@Initial check-in
@
text
@d18 1
a18 1
       "$Id: output_m.f90,v 1.1 2000/07/06 01:43:12 vsnyder Exp $"
d195 3
@


