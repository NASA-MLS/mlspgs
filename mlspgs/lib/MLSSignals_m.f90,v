head	2.116;
access;
symbols
	v5-02-NRT-19:2.116
	v6-00:2.116
	v5-02-NRT-18:2.116
	v5-02:2.115
	v5-01-NRT-17:2.116
	v5-01-NRT-16:2.116
	v5-01-NRT-15:2.116
	v5-01-NRT-14:2.116
	neuralnetworks-1-0:2.116.0.4
	cfm-single-freq-0-1:2.116.0.2
	v5-01:2.115
	v5-00:2.115
	v4-23-TA133:2.115.0.4
	mus-emls-1-70:2.115.0.2
	rel-1-0-englocks-work:2.114.0.2
	VUMLS1-00:2.111
	VPL1-00:2.110
	V4-22-NRT-08:2.108
	VAM1-00:2.108
	V4-21:2.107.0.2
	V4-13:2.107
	V4-12:2.106
	V4-11:2.106
	V4-10:2.104
	V3-43:2.90
	M4-00:2.94
	V3-41:2.90
	V3-40-PlusGM57:2.90.0.2
	V2-24-NRT-04:2.83
	V3-33:2.91
	V2-24:2.83
	V3-31:2.91
	V3-30-NRT-05:2.90
	cfm-01-00:2.90
	V3-30:2.90
	V3-20:2.90
	V3-10:2.86
	V2-23-NRT-02:2.83
	V2-23:2.83
	V2-22-NRT-01:2.83
	V2-22:2.83
	V2-21:2.81
	V2-20:2.81
	V2-11:2.81
	V2-10:2.81
	V2-00:2.81
	V1-51:2.76
	V1-50:2.76
	V1-45:2.74
	V1-44:2.74
	V1-43:2.70
	V1-42:2.61
	V1-41:2.61
	V1-32:2.61
	V1-40:2.61
	V1-31:2.61
	V1-30:2.61
	V1-13:2.55
	V1-12:2.55
	V1-11:2.55
	V1-10:2.54
	newfwm-feb03:2.54.0.2
	V1-04:2.45
	V1-03:2.45
	V1-02:2.45
	V1-00:2.45
	newfwm-sep01:2.39.0.2
	V0-7:2.39
	V0-5-Level2:2.37
	V0-5-SIPS:2.25;
locks; strict;
comment	@# @;


2.116
date	2020.01.27.21.32.47;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2018.04.19.00.53.09;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2018.03.05.19.24.39;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2018.02.27.00.50.00;	author livesey;	state Exp;
branches;
next	2.112;

2.112
date	2017.09.15.15.44.18;	author livesey;	state Exp;
branches;
next	2.111;

2.111
date	2016.09.21.00.38.09;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2016.07.27.22.14.59;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2016.07.25.23.15.41;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2015.03.28.01.18.43;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2014.09.05.00.11.11;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2014.06.02.23.15.35;	author livesey;	state Exp;
branches;
next	2.105;

2.105
date	2014.05.24.01.30.17;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2014.02.07.02.28.06;	author vsnyder;	state Exp;
branches;
next	2.103;

2.103
date	2014.01.11.01.41.02;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2013.12.12.02.08.36;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2013.11.06.01.47.26;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2013.10.09.01.08.03;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2013.08.30.03.56.02;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2013.08.23.23.27.48;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2013.06.28.18.10.45;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2013.06.12.02.12.23;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2012.05.01.20.52.09;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2011.06.02.19.22.35;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2011.05.09.17.24.55;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2011.01.29.00.51.38;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2009.10.26.17.08.02;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2009.10.01.00.49.13;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2009.09.25.02.44.14;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2008.09.29.22.56.40;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2008.09.29.22.55.17;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2007.05.22.02.28.28;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2007.04.26.20.30.53;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2006.04.20.01.07.57;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2005.04.06.23.15.31;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2005.03.15.23.48.55;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2005.01.12.03.07.37;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2004.10.30.00.24.34;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2004.10.06.21.16.26;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2004.08.03.21.49.05;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2004.07.23.19.48.12;	author vsnyder;	state Exp;
branches;
next	2.72;

2.72
date	2004.07.23.18.35.17;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2004.05.29.02.45.28;	author vsnyder;	state Exp;
branches;
next	2.70;

2.70
date	2004.05.01.04.07.44;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2004.04.16.00.44.24;	author livesey;	state Exp;
branches;
next	2.68;

2.68
date	2004.03.24.23.08.58;	author livesey;	state Exp;
branches;
next	2.67;

2.67
date	2004.03.24.01.02.17;	author livesey;	state Exp;
branches;
next	2.66;

2.66
date	2004.03.22.18.22.59;	author livesey;	state Exp;
branches;
next	2.65;

2.65
date	2004.02.11.02.24.18;	author livesey;	state Exp;
branches;
next	2.64;

2.64
date	2004.01.28.02.10.07;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2004.01.28.01.17.36;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2004.01.16.21.36.28;	author livesey;	state Exp;
branches;
next	2.61;

2.61
date	2003.08.16.01.14.03;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2003.07.23.21.51.36;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2003.07.23.18.04.32;	author livesey;	state Exp;
branches;
next	2.58;

2.58
date	2003.07.18.20.23.34;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2003.05.16.02.44.18;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2003.05.10.22.21.12;	author livesey;	state Exp;
branches;
next	2.55;

2.55
date	2003.03.07.03.17.50;	author livesey;	state Exp;
branches;
next	2.54;

2.54
date	2002.10.08.17.42.10;	author livesey;	state Exp;
branches;
next	2.53;

2.53
date	2002.10.08.00.09.12;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2002.10.05.00.40.28;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2002.10.03.05.38.11;	author livesey;	state Exp;
branches;
next	2.50;

2.50
date	2002.09.05.20.27.39;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2002.07.17.06.00.40;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2002.05.15.17.29.48;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2002.05.14.22.31.59;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2002.05.03.22.38.41;	author livesey;	state Exp;
branches
	2.46.2.1;
next	2.45;

2.45
date	2002.02.14.23.00.45;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2002.02.14.18.37.40;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2002.02.13.23.57.34;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2001.11.09.23.14.08;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2001.10.12.23.07.23;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2001.09.17.22.53.46;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2001.05.16.23.05.06;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2001.05.16.01.24.06;	author livesey;	state Exp;
branches;
next	2.37;

2.37
date	2001.05.03.02.06.07;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2001.05.02.21.50.26;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2001.05.02.19.12.11;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2001.04.26.19.33.25;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2001.04.26.02.33.03;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2001.04.24.22.36.27;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2001.04.23.23.12.45;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2001.04.23.23.10.37;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2001.04.21.01.06.37;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2001.04.21.01.05.26;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2001.04.20.22.41.25;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2001.04.19.20.29.24;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2001.04.13.23.54.06;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2001.04.13.23.28.59;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2001.04.13.20.40.23;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2001.04.12.18.14.19;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2001.04.11.20.19.27;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2001.04.11.19.57.55;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2001.04.11.19.54.00;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2001.04.11.18.31.04;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.04.10.23.20.05;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2001.04.10.17.59.53;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2001.04.09.20.30.46;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2001.04.09.20.16.40;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.07.01.52.58;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.03.01.48.25;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.03.29.23.52.31;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.03.28.19.51.58;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.03.16.21.32.23;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.16.02.10.32;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.16.01.54.47;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.16.00.30.49;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.15.21.02.07;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.15.18.42.58;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.15.18.39.42;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2001.03.14.23.44.47;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2001.03.14.02.05.52;	author vsnyder;	state Exp;
branches;
next	;

2.46.2.1
date	2002.05.24.21.30.39;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.116
log
@Dump_Signals may now dump only signal names if Details negative
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module MLSSignals_M

  ! Process the MLSSignals section of the L2 configuration file and deal with
  ! parsing signal request strings.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Dump_0, only: Dump
  use Expr_M, only: Expr
  use HighOutput, only: HeadLine, OutputNamedValue, OutputTable, Tab
  use Init_MLSSignals_M ! Everything
  use Intrinsic, only: Field_First, Field_Indices, Lit_Indices, &
    & Phyq_Dimensionless, Phyq_Frequency, Phyq_Indices, S_Time, L_A, L_EMLS
  use MLSKinds, only: R8
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, PVMErrorMessage
  use MLSStrings, only: Lowercase, Capitalize
  use Output_M, only: Blanks, Newline, Output
  use String_Table, only: Display_String, Get_String

  implicit none

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

! AddBandToDatabase               As the name implies
! AddModuleToDatabase             ...
! AddRadiometerToDatabase         ...
! AddSignalToDatabase             ...
! AddSpectrometerTypeToDatabase   ...
! AreSignalsSuperset              ...
! DestroyBandDatabase             ...
! DestroyModuleDatabase           ...
! DestroyRadiometerDatabase       ...
! DestroySignal                   ...
! DestroySignalDatabase           ...
! DestroySpectrometerType         ...
! DestroySpectrometerTypeDatabase ...
! DisplayRadiometer               ... given its index in radiometer database
! DisplaySignalName               ...
! DisplaySignalName_index         ... given a signal index
! DisplaySignalName_signal        ... given a signal structure
! Dump                            ...
! Dump_All                        ...
! Dump_Bands                      ...
! Dump_Modules                    ...
! Dump_Radiometers                ...
! Dump_Signal                     ...
! Dump_Signals                    ...
! Dump_Spectrometertypes          ...
! GetAllModules                   Return tree nodes for all modules
! GetBandName                     Given an index in the Bands database, place band name in string
! GetModuleFromRadiometer         Returns module field from given radiometer given as database index
! GetModuleIndex                  Returns the index in the module database, given module name in mixed case
! GetModuleFromSignal             Returns module field from given signal given as database index
! GetModuleName                   Given the index in the module database, returns module name in mixed case
! GetNameOfSignal                 Given a signal object, this routine constructs a full signal name
! GetRadiometerFromSignal         Returns radiometer field from given signal given as database index
! GetRadiometerName               Given an index in the Radiometers database, place radiometer name
! GetRadiometerIndex              Returns index in the Radiometers database, given radiometer name
! GetSidebandStartStop            Given a signal, compute SidebandStart and SidebandStop
! GetSignal                       Given the database index, this routine returns the signal data structure
! GetSignalIndex                  Returns the index in the signals database, given signal name in mixed case
! GetSignalName                   Given an index in the signals database, constructs full signal name.
! GetSpectrometerTypeName         Place spectrometer name and number in string
! IsAnyModuleSpacecraft           Returns true if any module is really the spacecraft
! IsModuleSpacecraft              Returns true if the module is really the spacecraft
! IsSpacecraftAura                Returns true if the s/c is really Aura
! MatchSignal                     Given an array Signals, find the matching one
! MatchSignalPair                 Determine whether two signals match
! MLSSignals                      Process the MLSSignals section of the L2 configuration file
! === (end of toc) ===

! === (start of api) ===
! === (end of api) ===

  private ! So as not to re-export everything accessed by USE association.

  ! Public procedures and interfaces:
  public :: AddbandtoDatabase, AddModuletoDatabase, AddradiometertoDatabase
  public :: AddsignaltoDatabase, AddspectrometertypetoDatabase, Aresignalssuperset
  public :: DestroybandDatabase, DestroyModuleDatabase
  public :: DestroyradiometerDatabase, Destroysignal, DestroysignalDatabase
  public :: Destroyspectrometertype, DestroyspectrometertypeDatabase
  public :: Displayradiometer, DisplaysignalName
  public :: DisplaysignalName_Index, DisplaysignalName_Signal
  public :: Dump, Dump_Bands, Dump_Radiometers, Dump_Signal, Dump_Signals
  public :: Dump_All, Dump_Modules, Dump_Spectrometertypes
  public :: GetallModules, GetbandName, GetfirstChannel, GetModulefromradiometer
  public :: GetModuleindex, Getsidebandloop, Getsidebandstartstop, Getsignalindex
  public :: GetModulefromsignal, GetModuleName, GetNameofsignal
  public :: Getradiometerfromsignal, GetradiometerName, Getradiometerindex
  public :: Getsignal, GetsignalName, GetspectrometertypeName
  public :: Isspacecraftaura, IsanyModulespacecraft, IsModulespacecraft
  public :: Matchsignal, Matchsignalpair, MLSSignals
  public :: Pvmpacksignal, Pvmunpacksignal

  integer, public, parameter :: MaxSigLen = 80 ! Maximum length of a signal name

  interface DisplaySignalName
    module procedure DisplaySignalName_index, DisplaySignalName_signal
  end interface

  interface MatchSignal
    module procedure MatchSignals, MatchSignalPair
  end interface

  ! =====     Defined Operators and Generic Identifiers     ==============
  
  interface Dump
    module procedure Dump_Bands, Dump_Modules, Dump_Oneradiometer, &
      & Dump_Radiometers, Dump_Signal, Dump_Signals, &
      & Dump_Spectrometertype, Dump_Spectrometertypes
  end interface

  ! This boring type defines a module
  type, public :: Module_T
    integer :: Name                     ! Sub_rosa index of declaration's label
    integer :: Node                     ! Node of tree where module declared
    logical :: spaceCraft               ! Set if module is in fact s/c
    integer :: supportedModule          ! See discssion below
    logical :: Aura  = .true.           ! Set if s/c is in fact Aura
    character(len=32) :: NameString = ' '  ! If not get_string (e.g., camelCase)
  end type Module_T
  ! A-SMLS does things in a more complicated way, as the timing of the
  ! different spectrometer modules varies.  This means that there need
  ! to be multiple Spacecraft modules, with timings that are on the
  ! same cadence as the corresponding spectrometer.  In these cases,
  ! supportedModule is an index into the corresponding module.  That
  ! is to say for each Spectrometer there will be two Module_Ts: one
  ! containing the tangent pointing information as usual, the other
  ! containing the spacecraft information on the same timing, for
  ! which the "supportedModule" entry will point to the tangent
  ! information

  ! This type defines a radiometer.

  type, public :: Radiometer_T
    real(r8) :: LO                      ! Local oscillator in MHz
    integer :: InstrumentModule         ! Index in Modules database
    integer :: Polarization             ! L_A or L_B, default is L_A
    integer :: Prefix                   ! Sub_rosa index of declaration's label
    integer :: Suffix                   ! Sub_rosa index
    integer :: SingleSideband           ! +/-1 indicates indicates single sideband 0 folded
  end type Radiometer_T

  ! The second type describes a band within that radiometer

  type, public :: Band_T
    real(r8) :: CenterFrequency         ! Zero if not present (wide filter)
    integer :: Prefix                   ! Sub_rosa index of declaration's label
    integer :: Radiometer               ! Index in Radiometers database, or none if deferred
    integer :: SpectrometerType         ! Index in SpectrometerTypes database
    integer :: Suffix                   ! Sub_rosa index
  end type Band_T

  ! This type gives the information for specific spectrometer families.  For
  ! all apart from the WF4 spectrometers, we list frequencies and widths. 
  ! Otherwise, the arrays are empty.

  type, public :: SpectrometerType_T
    real(r8), pointer, dimension(:) :: Frequencies => NULL(), Widths => NULL()
    integer :: Name                     ! Sub_rosa index of declaration's label
    logical :: Deferred=.false.         ! "Frequencies/widths are deferred"
    logical :: DACS=.false.             ! Set if this spectrometer is a DACS
  end type SpectrometerType_T

  ! This is the key type; it describes a complete signal (one band, or a
  ! subset of the channels in one band).

  type, public :: Signal_T
    real(r8) :: CenterFrequency         ! Band local oscillator
    real(r8) :: LO                      ! Radiometer local oscillator
    real(r8), pointer, dimension(:) :: Frequencies=>NULL() ! Mainly a shallow copy
    real(r8), pointer, dimension(:) :: Widths=>NULL()  ! Mainly a shallow copy
    logical, pointer, dimension(:) :: Channels=>NULL() ! The ones actually used
    !                                   (This is for derived signals.  Every
    !                                   element is true for "real" signals).

    integer :: Band                     ! Index in Bands database
    logical :: DACS = .false.           ! This signal is a DACS
    logical :: Deferred = .false.       ! "Frequencies/widths are deferred"
    integer :: Direction                ! +1 Channel 1 closest to lo, -1 reverse.
    integer :: Index                    ! Index into master signals database
    integer :: InstrumentModule         ! Index in Modules database
    integer :: Name                     ! Sub_rosa index of declaration's label
    integer :: Radiometer               ! Index in Radiometers database
    integer :: SideBand                 ! -1=lower, +1=upper, 0=folded
    integer :: SingleSideband           ! Indicates only sideband for this radiometer
    integer :: Spectrometer             ! Just a spectrometer number
    integer :: SpectrometerType         ! Index in SpectrometerTypes database
    integer :: Switch                   ! Just a switch number
  end type Signal_T

  ! Now some databases, the first are fairly obvious.
  !??? Should these be public ???

  type(module_T), public, save, pointer, dimension(:)  :: Modules => null()   
  type(band_T), public, save, pointer, dimension(:)    :: Bands => null()     
  type(radiometer_T), public, save, pointer, dimension(:) &
    &                                                  :: Radiometers => null()
  type(spectrometerType_T), public, save, pointer, dimension(:) &
    &                                                  :: Spectrometertypes => null()

  ! This array is the signals database.  The first entries are the official
  ! `valid' signals in the instrument.  Later one can derive things from that.
  ! for subsets of channels etc.
  type(signal_T), public, save, pointer, dimension(:)  :: Signals => null()           
  integer, public, save                                :: Instrument = l_emls         
  integer, parameter                                   :: Maxradiometernamelen = 16   

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSSignals_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  ! -------------------------------------------------  MLSSignals  -----
  subroutine MLSSignals ( ROOT )
    ! Process the MLSSignals section of the L2 configuration file.

    use MLSStringLists, only: Switchdetail
    use MoreTree, only: Get_Boolean, Get_Label_And_Spec, StarterrorMessage
    use Next_Tree_Node_M, only: Next_Tree_Node, Next_Tree_Node_State
    use Time_M, only: Time_Now
    use Toggles, only: Gen, Levels, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decorate, Decoration, Nsons, Sub_Rosa, Subtree

    integer, intent(in) :: ROOT         ! The "cf" vertex for the section

    type(band_T) :: Band                ! To be added to the database
    integer :: Channels                 ! subtree index of field
    logical :: DACS                     ! This spectrometer type is a DACS
    logical :: Deferred                 ! "Frequencies/widths are deferred"
    integer :: Error                    ! Error level seen so far
    integer :: Field                    ! Field index -- f_something
    integer :: First                    ! "first" field of "spectrometer"
    logical :: Got(field_first:last_Signal_Field)   ! "Got this field already"
    integer :: Gson                     ! Son of Son.
    integer :: J, K                     ! Subscript and loop inductor.
    integer :: Key                      ! Indexes the spec_args vertex.
    integer :: Last                     ! "last" field of "spectrometer"
    integer :: Me = -1                  ! String index for trace
    integer :: Me_Band = -1             ! String index for trace
    integer :: Me_Module = -1           ! String index for trace
    integer :: Me_Radiometer = -1       ! String index for trace
    integer :: Me_Signal = -1           ! String index for trace
    integer :: Me_SpectrometerType = -1 ! String index for trace
    integer :: Name                     ! sub_rosa of label of specification,
                                        ! if any, else zero.
    type(radiometer_T) :: Radiometer    ! To be added to the database
    integer :: Son                      ! Some subtree of root.
    type(signal_T) :: Signal            ! To be added to the database
    type(spectrometerType_T) :: SpectrometerType ! To be added to the database
    real(r8) :: Start                   ! "start" field of "spectrometer"
    type(next_tree_node_state) :: State ! of tree traverser
    real(r8) :: Step                    ! "step" field of "spectrometer"
    type(module_T) :: thisModule        ! To be added to database
    logical :: TIMING                   ! For S_Time
    real :: T1, T2                      ! For S_Time
    integer :: Units(2)                 ! of an expression
    double precision :: Value(2)        ! of an expression
    real(r8) :: Width                   ! "width" field of "spectrometer"

    ! Error message codes
    integer, parameter :: AllOrNone = 1 ! All of a set of fields, or none
    integer, parameter :: AtLeastOne = allOrNone + 1   ! At least one
    integer, parameter :: DeferredChannels = atLeastone + 1 ! Deferred .neqv channels
    integer, parameter :: BadMix = deferredChannels + 1 ! Disallowed mixture of
    !                                     fields.
    integer, parameter :: WrongUnits = badMix + 1 ! Field has wrong units
    integer, parameter :: UnneededRadiometer = WrongUnits + 1 ! Radiomter spec in wrong place
    integer, parameter :: NoDeferredRadiometer = UnneededRadiometer + 1 ! Radiometer spec needed
    integer, parameter :: PriorTrouble = NoDeferredRadiometer + 1
    integer, parameter :: noModuleSpecified = PriorTrouble + 1 ! No module in either signal or radimoeter
    integer, parameter :: conflictingModules = noModuleSpecified + 1 ! Module in signal and radiometer differ
    integer, parameter :: notSpacecraft = conflictingModules + 1 ! Had supportedModule set innappropriately

    error = 0
    timing = .false.
    call trace_begin ( me, "MLSSignals", root, cond=toggle(gen) )
    do
      son = next_tree_node(root,state)
      if ( son == 0 ) exit
      call get_label_and_spec ( son, name, key )
      ! node_id(key) is now n_spec_args

      got = .false.
      select case ( decoration(subtree(1,decoration(subtree(1,key)))) )

      case ( s_band ) ! ...................................  BAND  .....
        call trace_begin ( me_band, "MLSSignals.band", son, &
          & cond=toggle(gen) .and. levels(gen) > 0 )
        band%prefix = name
        band%centerFrequency = 0.0_r8 ! "The 'frequency' field is absent"
        band%radiometer = 0             ! No radiometer defined at first.
        do j = 2, nsons(key)
          son = subtree(j,key)
          field = decoration(subtree(1,son))
          gson = subtree(2,son)
          got(field) = .true.
          select case ( field )
          case ( f_centerFrequency )
            ! Front end should be checking units now, but just in case....
            call expr_check ( gson, units, value, field, phyq_frequency )
            band%centerFrequency = value(1)
          case ( f_suffix )
            band%suffix = sub_rosa(gson)
          case ( f_radiometer )
            band%radiometer = decoration(decoration(gson))
          case ( f_spectrometerType )
            band%spectrometerType = decoration(decoration(gson))
          case default
            ! Shouldn't get here if the type checker worked
          end select
        end do ! j = 2, nsons(key)
        call decorate ( key, addBandToDatabase ( bands, band ) )
        call trace_end ( "MLSSignals.band", &
          & cond=toggle(gen) .and. levels(gen) > 0 )

      case ( s_module ) ! ............................  MODULE  ........
        call trace_begin ( me_module, "MLSSignals.module", son, &
          & cond=toggle(gen) .and. levels(gen) > 0 )
        thisModule%name = name
        thisModule%spaceCraft = .false.
        thisModule%node = decoration(name)
        thisModule%supportedModule = 0
        do j = 2,nsons(key)
          son = subtree(j,key)
          field = decoration(subtree(1,son))
          if ( nsons(son) > 1 ) then
            gson = subtree(2,son)
          else
            gson = son
          end if
          got(field) = .true.
          select case ( field )
          case (f_Aura)
            thisModule%Aura = get_boolean(son)
          case (f_instrument)
            instrument = decoration(gson)
          case (f_spaceCraft)
            thisModule%spacecraft = get_boolean(son)
          case (f_supportedModule)
            thisModule%supportedModule = decoration(decoration(gson))
          case default
            ! Shouldn't get here if parser worked
          end select
        end do
        if ( .not. thisModule%spacecraft .and. thisModule%supportedModule /= 0 ) &
          call announceError ( notSpacecraft )
        call decorate ( key, AddModuleToDatabase (modules, thisModule ) )
        call trace_end ( "MLSSignals.module", &
          & cond=toggle(gen) .and. levels(gen) > 0 )

      case ( s_radiometer ) ! .......................  RADIOMETER  .....
        call trace_begin ( me_radiometer, "MLSSignals.radiometer", son, &
          & cond=toggle(gen) .and. levels(gen) > 0 )
        radiometer%polarization = l_a
        radiometer%prefix = name
        radiometer%singleSideband = 0
        radiometer%instrumentModule = 0
        do j = 2, nsons(key)
          son = subtree(j,key)
          field = decoration(subtree(1,son))
          gson = subtree(2,son)
          select case ( field )
          case ( f_lo )
            ! Front end should be checking units now, but just in case....
            call expr_check ( gson, units, value, field, phyq_frequency )
            radiometer%lo = value(1)
          case ( f_module )
            radiometer%instrumentModule = decoration(decoration(gson))
          case ( f_polarization )
            radiometer%polarization = decoration(gson)
          case ( f_singlesideband )
            ! Front end should be checking units now, but just in case....
            call expr_check ( gson, units, value, field, phyq_dimensionless )
            radiometer%singleSideband = nint ( value(1) )
          case ( f_suffix )
            radiometer%suffix = sub_rosa(gson)
          case default
            ! Shouldn't get here if the type checker worked
          end select
        end do ! j = 2, nsons(key)
        call decorate ( key, addRadiometerToDatabase ( radiometers, radiometer ) )
        call trace_end ( "MLSSignals.radiometer", &
          & cond=toggle(gen) .and. levels(gen) > 0 )

      case ( s_signal ) ! ..........................  VALIDSIGNAL  .....
        call trace_begin ( me_signal, "MLSSignals.signal", son, &
          & cond=toggle(gen) .and. levels(gen) > 0 )
        signal%sideband = 0
        signal%radiometer = 0
        signal%instrumentModule = 0
        do j = 2, nsons(key)
          son = subtree(j,key)
          field = decoration(subtree(1,son))
          gson = subtree(2,son)
          got(field) = .true.
          select case ( field )
          case ( f_band )
            signal%band = decoration(decoration(gson))
          case ( f_channels )
            channels = son
          case ( f_direction )
            ! Front end should be checking units now, but just in case....
            call expr_check ( gson, units, value, field, phyq_dimensionless )
            signal%direction = nint(value(1))
          case ( f_radiometer )
            signal%radiometer = decoration(decoration(gson))
          case ( f_module )
            signal%instrumentModule = decoration(decoration(gson))
          case ( f_spectrometer )
            ! Front end should be checking units now, but just in case....
            call expr_check ( gson, units, value, field, phyq_dimensionless )
            signal%spectrometer = value(1)
          case ( f_switch )
            ! Front end should be checking units now, but just in case....
            call expr_check ( gson, units, value, field, phyq_dimensionless )
            signal%switch = value(1)
          case default
            ! Shouldn't get here if the type checker worked
          end select
        end do ! j = 2, nsons(key)
        signal%name = name
        ! Did this band have a radiometer spec deferred to this point?
        if ( bands(signal%band)%radiometer == 0 ) then
          ! The radiometer was deferred in the band definition
          if ( signal%radiometer == 0 ) call announceError ( noDeferredRadiometer )
        else
          ! Didn't need to supply radiometer then.
          if ( got(f_radiometer) ) call announceError ( unneededRadiometer )
          signal%radiometer = bands(signal%band)%radiometer
        end if
        if ( associated(radiometers) .and. associated(bands) .and. &
           & associated(spectrometerTypes) ) then
          signal%lo = radiometers(signal%radiometer)%lo
          ! The instrument module may have been supplied here, or as part of the radiometer specification
          ! either way, make sure they're consistent
          if ( signal%instrumentModule == 0 ) then
            if ( radiometers(signal%radiometer)%instrumentModule == 0 ) &
              & call announceError ( noModuleSpecified )
            signal%instrumentModule = radiometers(signal%radiometer)%instrumentModule
          else
            if ( ( radiometers(signal%radiometer)%instrumentModule /= 0 ) .and. &
                 ( radiometers(signal%radiometer)%instrumentModule /= signal%instrumentModule ) ) &
              & call announceError ( conflictingModules )
          end if
          signal%spectrometerType = bands(signal%band)%spectrometerType
          signal%singleSideband = radiometers(signal%radiometer)%singleSideband
          signal%centerFrequency = bands(signal%band)%centerFrequency
          signal%deferred = spectrometerTypes(signal%spectrometerType)%deferred
          signal%dacs = spectrometerTypes(signal%spectrometerType)%dacs
          if ( signal%deferred .neqv. got(f_channels) ) &
            & call announceError ( deferredChannels )
          ! For the wide filters, we specify frequency etc. here.
          if ( got(f_channels) ) then
            if ( error == 0 ) then
              call allocate_Test ( signal%frequencies, nsons(channels)-1, &
                & 'signal%frequencies', moduleName )
              call allocate_Test ( signal%widths, nsons(channels)-1, &
                & 'signal%widths', moduleName)
              do k = 2, nsons(channels)
                call expr ( subtree(k,channels), units, value )
                signal%frequencies(k-1) = value(1)
                signal%widths(k-1) = value(2)
              end do
              if ( any(units /= phyq_frequency) ) &
                ! Front end should be checking units now, but just in case....
                & call announceError ( wrongUnits, f_channels, &
                  & (/ phyq_frequency /) )
            end if
          else
            signal%frequencies => spectrometerTypes(signal%spectrometerType)% &
              & frequencies
            signal%widths => spectrometerTypes(signal%spectrometerType)%widths
          end if
          call decorate ( key, addSignalToDatabase ( signals, signal ) )
          signals(size(signals))%index = size(signals)
        else
          call announceError ( priorTrouble )
        end if
        ! Now nullify pointers so they don't get hosed later by allocate_test
        nullify ( signal%frequencies )
        nullify ( signal%widths )
        call trace_end ( "MLSSignals.signal", &
          & cond=toggle(gen) .and. levels(gen) > 0 )

      case ( s_spectrometerType ) ! ...........  SPECTROMETERTYPE  .....
        call trace_begin ( me_spectrometertype, "MLSSignals.spectrometerType", &
          & son, cond=toggle(gen) .and. levels(gen) > 0 )
        spectrometerType%name = name
        deferred = .false.
        dacs = .false.
        first = 0
        do j = 2, nsons(key)
          son = subtree(j,key)
          field = decoration(subtree(1,son))
          if ( nsons(son) > 1 ) then
            gson = subtree(2,son)
          else
            gson = son                  ! For case of /deferred
          end if
          got(field) = .true.
          select case ( field )
          case ( f_channels )
            channels = son
          case ( f_deferred )
            deferred = get_boolean(son)
          case ( f_dacs )
            dacs = get_boolean(son)
          case ( f_first, f_last )
            ! Front end should be checking units now, but just in case....
            call expr_check ( gson, units, value, field, phyq_dimensionless )
            select case ( field )
            case ( f_first )
              first = value(1)
            case ( f_last )
              last = value(1)
            end select
          case ( f_start, f_step, f_width )
            ! Front end should be checking units now, but just in case....
            call expr_check ( gson, units, value, field, phyq_frequency )
            select case ( field )
            case ( f_start )
              start = value(1)
            case ( f_step )
              step = value(1)
            case ( f_width )
              width = value(1)
            end select
          case default
            ! Shouldn't get here if the type checker worked
          end select
        end do ! j = 2, nsons(key)
        if ( got(f_channels) ) then
          if ( any(got( (/ f_last, f_start, f_step, f_width /) )) ) &
            & call announceError ( badMix, f_channels, &
            & (/ f_last, f_start, f_step, f_width /) )
          if ( error == 0 ) then
            call allocate_Test ( spectrometerType%frequencies, &
              & nsons(channels)-2+first, 'spectrometerType%frequencies', &
              & moduleName, lowBound = first )
            call allocate_Test ( spectrometerType%widths, &
              & nsons(channels)-2+first, 'spectrometerType%widths', &
              & moduleName, lowBound = first )
            do k = 2, nsons(channels)
              call expr ( subtree(k,channels), units, value )
              spectrometerType%frequencies(k-2 +first) = value(1)
              spectrometerType%widths(k-2+first) = value(2)
            end do
            if ( any(units /= phyq_frequency) ) &
              ! Front end should be checking units now, but just in case....
              & call announceError ( wrongUnits, f_channels, &
                & (/ phyq_frequency /) )
          end if
        end if
        if ( got(f_start) ) then
          if ( .not. all( got((/ f_last, f_step, &
          & f_width /)) ) ) call announceError ( allOrNone, f_start, &
          & (/ f_last, f_step, f_width /) )
          if ( error == 0 ) then
            call allocate_Test ( spectrometerType%frequencies, last, &
              & 'spectrometerType%frequencies', moduleName, lowBound = first )
            call allocate_Test ( spectrometerType%widths, last, &
              & 'spectrometerType%widths', moduleName, lowBound = first )
            spectrometerType%widths = width
            spectrometerType%frequencies(first) = start
            do k = first+1, last
              spectrometerType%frequencies(k) = start + (k-first) * step
            end do ! k
          end if
        end if
        if ( deferred ) then            ! For deferred types, wait till later
          if ( any(got( (/ f_channels, f_last, f_start, f_step, f_width /) )) ) &
            & call announceError ( badMix, f_channels, &
            & (/ f_last, f_start, f_step, f_width /) )
          if ( error == 0 ) then
            spectrometerType%deferred = deferred
            nullify(spectrometerType%frequencies)
            nullify(spectrometerType%widths)
          end if
        end if
        if ( .not. any(got( (/ f_channels, f_deferred, f_start /) )) ) &
          & call announceError ( atLeastOne, f_channels, (/ f_deferred, f_start /) )
        spectrometerType%dacs = dacs
        if ( error == 0 ) call decorate ( key, addSpectrometerTypeToDatabase ( &
          & spectrometerTypes, spectrometerType ) )

        ! Nullify pointers to temporary stuff so it doesn't get hosed later
        nullify ( spectrometerType%frequencies )
        nullify ( spectrometerType%widths )
        call trace_end ( "MLSSignals.spectrometerType", &
          & cond=toggle(gen) .and. levels(gen) > 0 )

      case ( s_time ) ! ...................................  TIME  .....
        if ( timing ) then
          call sayTime
        else
          call time_now ( t1 )
          timing = .true.
        end if
      case default
        ! Shouldn't get here if the type checker worked
      end select

    end do

    if ( error > 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "Unable to create MLSSignals database" )

    if ( switchDetail(switches, 'sig') > -1 ) then
      call dump ( radiometers )
      call dump ( spectrometerTypes )
      call dump ( bands )
      call dump ( signals )
    end if
    call trace_end ( "MLSSignals", cond=toggle(gen) )
    if ( timing ) call sayTime

  contains
    ! --------------------------------------------  AnnounceError  -----
    subroutine AnnounceError ( Code, FieldIndex, MoreFields )
      integer, intent(in) :: Code       ! Index of error message
      integer, intent(in), optional :: FieldIndex ! f_...
      integer, intent(in), optional :: MoreFields(:)

      integer :: I

      error = max(error,1)
      call startErrorMessage ( son ) ! print '***** At <where>: '
      call output ( 'MLSSignals complained: ' )
      select case ( code )
      case ( allOrNone )
        call output ( 'Either all of the fields ' )
        call display_string ( field_indices(fieldIndex) )
        do i = 1, size(moreFields)
          if ( i == size(moreFields) ) then
            call output ( ' and ' )
          else
            call output ( ', ' )
          end if
          call display_string ( field_indices(moreFields(i)) )
        end do ! i
        call output ( ' shall appear, or none of them shall.', advance = 'yes' )
      case ( atLeastOne )
        call output ( 'At least one of the fields ' )
        call display_string ( field_indices(fieldIndex) )
        do i = 1, size(moreFields)
          if ( i == size(moreFields) ) then
            call output ( ' or ' )
          else
            call output ( ', ' )
          end if
          call display_string ( field_indices(moreFields(i)) )
        end do ! i
        call output ( ' shall appear.', advance='yes' )
      case ( badMix )
        call output ( 'If the ' )
        call display_string ( field_indices(fieldIndex) )
        call output ( ' field appears, no other field except ' )
        do i = 1, size(moreFields)
          if ( i == size(moreFields) ) then
            if ( i > 1 ) call output ( ' or ' )
          else if ( i > 1 ) then
            call output ( ', ' )
          end if
          call display_string ( field_indices(moreFields(i)) )
        end do ! i
        call output ( ' shall appear.', advance='yes' )
      case ( deferredChannels )
        call output ( "Channels shall be specified if and only if the band's" )
        call output ( ' radiometer has deferred channels', advance='yes' )
      case ( priorTrouble )
        call output ( 'Unable to finish Signals because of prior trouble', &
          & advance='yes' )
      case ( wrongUnits )
        call output ( 'The values of the ' )
        call display_string ( field_indices(fieldIndex) )
        call output ( ' field have the wrong units -- ' )
        call display_string ( phyq_indices(moreFields(1)) )
        call output ( ' required.', advance='yes' )
      case ( unneededRadiometer )
        call output ( 'Radiometer field supplied when not necessary', advance='yes' )
      case ( noDeferredRadiometer )
        call output ( 'Radiometer field neeed for this signal as not specified in band', advance='yes' )
      case ( noModuleSpecified )
        call output ( 'No module found in either signal or radiometer definition', advance='yes' )
      case ( conflictingModules )
        call output ( 'Module given in signal and in radiometer conflict', advance='yes' )
      case ( notSpacecraft )
        call output ( 'Should only supply supportedModule for spacecraft modules', advance='yes' )
      end select
    end subroutine AnnounceError

    ! -----------------------------------------------  Expr_Check  -----
    subroutine Expr_Check ( Root, Units, Value, Field, NeededUnits )
    ! Evaluate an expression and check its units.
      integer, intent(in) :: Root, Field, NeededUnits
      integer, intent(out) :: Units(2)
      real(r8), intent(out) :: Value(2)
      call expr ( root, units, value )
      if ( units(1) /= neededUnits ) &
        & call announceError ( wrongUnits, field, (/ neededUnits /) )
    end subroutine Expr_Check

    ! --------------------------------------------------  SayTime  -----
    subroutine SayTime
      call time_now ( t2 )
      call output ( "Timing for MLSSignals = " )
      call output ( dble(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime

  end subroutine MLSSignals

  ! ------------------------------------------  AddBandToDatabase  -----
  integer function AddBandToDatabase ( Database, Item )

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    type(band_T), dimension(:), pointer :: Database
    type(band_T), intent(in) :: Item

    ! Local variables
    type (Band_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddBandToDatabase = newSize
  end function AddBandToDatabase

  ! ----------------------------------------  AddModuleToDatabase  -----
  integer function AddModuleToDatabase ( Database, Item )

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    type(module_T), dimension(:), pointer :: Database
    type(module_T), intent(in) :: Item

    ! Local variables
    type (Module_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddModuleToDatabase = newSize
  end function AddModuleToDatabase

  ! ------------------------------------  AddRadiometerToDatabase  -----
  integer function AddRadiometerToDatabase ( Database, Item )

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    type(radiometer_T), dimension(:), pointer :: Database
    type(radiometer_T), intent(in) :: Item

    ! Local variables
    type (Radiometer_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddRadiometerToDatabase = newSize
  end function AddRadiometerToDatabase

  ! ----------------------------------------  AddSignalToDatabase  -----
  integer function AddSignalToDatabase ( Database, Item )

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    type(signal_T), dimension(:), pointer :: Database
    type(signal_T), intent(in) :: Item

    ! Local variables
    type (Signal_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddSignalToDatabase = newSize
  end function AddSignalToDatabase

  ! ------------------------------  AddSpectrometerTypeToDatabase  -----
  integer function AddSpectrometerTypeToDatabase ( Database, Item )

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    type(spectrometerType_T), dimension(:), pointer :: Database
    type(spectrometerType_T), intent(in) :: Item

    ! Local variables
    type (spectrometerType_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddSpectrometerTypeToDatabase = newSize
  end function AddSpectrometerTypeToDatabase

  ! ----------------------------------------  DestroyBandDatabase  -----
  subroutine DestroyBandDatabase ( Bands )

    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(band_T), dimension(:), pointer :: Bands
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: S, Status
    if ( associated(bands) ) then
      s = size(bands) * storage_size(bands) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(bands(1)), addr)
      deallocate ( bands, stat = status )
      call test_deallocate ( status, moduleName, 'Band database', s, address=addr )
    end if

  end subroutine DestroyBandDatabase

  ! --------------------------------------  DestroyModuleDatabase  -----
  subroutine DestroyModuleDatabase ( Modules )

    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(module_T), dimension(:), pointer :: Modules
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: S, Status
    if ( associated(modules) ) then
      s = size(modules) * storage_size(modules) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(modules(1)), addr)
      deallocate ( modules, stat = status )
      call test_deallocate ( status, moduleName, 'Modules database', s, address=addr )
    end if
  end subroutine DestroyModuleDatabase

  ! ----------------------------------  DestroyRadiometerDatabase  -----
  subroutine DestroyRadiometerDatabase ( Radiometers )

    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(radiometer_T), dimension(:), pointer :: Radiometers
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: S, Status
    if ( associated(radiometers) ) then
      s = size(radiometers) * storage_size(radiometers) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(radiometers(1)), addr)
      deallocate ( radiometers, stat = status )
      call test_deallocate ( status, moduleName, 'Radiometer database', s, address=addr )
    end if
  end subroutine DestroyRadiometerDatabase

  ! ----------------------------------------------  DestroySignal  -----
  subroutine DestroySignal ( Signal, justChannels )
    ! Destroy one signal in the signals database (or elsewhere)
    ! If justChannels is set, don't destroy frequencies/widths, even
    ! for deferred, as it is a copy of the master.
    type(signal_T), intent(inout) :: SIGNAL
    logical, intent(in), optional :: JUSTCHANNELS

    logical :: MYJUSTCHANNELS

    myJustChannels = .false.
    if ( present(justChannels) ) myJustChannels = justChannels
    call deallocate_test ( signal%channels, 'Signal%channels', moduleName )
    ! Don't destroy Frequencies or Widths unless signal%Deferred.  Those
    ! fields are shallow copies here.  They're destroyed in
    ! DestroySpectrometerType.
    if ( signal%deferred .and. .not. myJustChannels ) then
      call deallocate_test ( signal%frequencies, "signal%frequencies", &
        & moduleName )
      call deallocate_test ( signal%widths, "signal%widths", moduleName )
    end if
  end subroutine DestroySignal

  ! --------------------------------------  DestroySignalDatabase  -----
  subroutine DestroySignalDatabase ( Signals, justChannels )

    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(signal_T), dimension(:), pointer :: Signals
    logical, intent(in), optional :: JUSTCHANNELS
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: I, S, Status

    ! Executable code
    if ( associated(signals) ) then
      do i = 1, size(signals)
        call destroySignal ( signals(i), justChannels )
      end do
      s = size(signals) * storage_size(signals) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(signals(1)), addr)
      deallocate ( signals, stat = status )
      call test_deallocate ( status, moduleName, 'Signal database', s, address=addr )
    end if
  end subroutine DestroySignalDatabase

  ! ------------------------------------  DestroySpectrometerType  -----
  subroutine DestroySpectrometerType ( SpectrometerType )
    ! Destroy one SpectrometerType object.
    type(spectrometerType_T), intent(inout) :: SpectrometerType
    call deallocate_Test ( spectrometerType%frequencies, &
      & 'Spectrometer%frequencies', moduleName )
    call deallocate_Test ( spectrometerType%widths, 'Spectrometer%widths', &
      &  moduleName )
  end subroutine DestroySpectrometerType

  ! ----------------------------  DestroySpectrometerTypeDatabase  -----
  subroutine DestroySpectrometerTypeDatabase ( SpectrometerTypes )

    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(spectrometerType_T), dimension(:), pointer :: spectrometerTypes
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: I, S, Status
    if ( associated(spectrometerTypes) ) then
      do i = 1, size(spectrometerTypes)
        call destroySpectrometerType ( spectrometerTypes(i) )
      end do
      s = size(spectrometerTypes) * storage_size(spectrometerTypes) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(spectrometerTypes(1)), addr)
      deallocate ( spectrometerTypes, stat = status )
      call test_deallocate ( status, moduleName, 'Spectrometer database', s, &
        & address=addr )
    end if
  end subroutine DestroySpectrometerTypeDatabase

  ! ------------------------------------------  DisplayRadiometer  -----
  subroutine DisplayRadiometer ( Index )
    integer, intent(in) :: Index ! in radiometer database
    call display_string ( radiometers(index)%prefix )
    call output ( ':' )
    call display_string ( radiometers(index)%suffix, strip=.true. )
  end subroutine

  ! ------------------------------------  DisplaySignalName_index  -----
  subroutine DisplaySignalName_index ( Signal, Advance, Before, Sideband, &
                                     & Channel, OtherChannels )
    ! Given a signal object, this routine displays a full signal name.
    integer, intent(in) :: SIGNAL
    character(len=*), intent(in), optional :: Advance, Before
    integer, intent(in), optional :: Sideband ! Use this instead of Signal's
    integer, intent(in), optional :: Channel  ! Use this instead of Signal's
    logical, pointer, optional :: OtherChannels(:) ! Use these instead of Signal's
    call displaySignalName ( signals(signal), advance, before, sideband, channel, &
                           & otherChannels )
   end subroutine DisplaySignalName_index

  ! -----------------------------------  DisplaySignalName_signal  -----
  subroutine DisplaySignalName_signal ( Signal, Advance, Before, Sideband, &
                                      & Channel, OtherChannels )
    ! Given a signal object, this routine displays a full signal name.
    use String_Table, only: Display_String
    type(signal_T), intent(in) :: SIGNAL
    character(len=*), intent(in), optional :: Advance, Before
    integer, intent(in), optional :: Sideband ! Use this instead of Signal's
    integer, intent(in), optional :: Channel  ! Use this instead of Signal's
    logical, pointer, optional :: OtherChannels(:) ! Use these instead of Signal's
    character(len=15) :: BandName
    logical, pointer :: Channels(:)
    logical :: First
    integer :: I, J, SB

    if ( present(before) ) call output ( before )
    if ( present(sideband) ) then
      sb = sideband
    else
      sb = signal%sideband
    end if
    call displayRadiometer ( signal%radiometer )
    call output ( '.' )
    call GetBandName ( signal%band, bandName, sideband=sb )
    call output ( trim(bandName) )
    call output ( signal%switch, before='.S', after='.' )
    call display_string ( spectrometerTypes(signal%spectrometerType)%name )
    call output ( signal%spectrometer, before='-' )
    if ( present(channel) ) then
      call output ( channel, before='.C' )
    else
      channels => signal%channels
      if ( present(otherChannels) ) channels => otherChannels
      if ( associated(channels) ) then
        if ( .not. all(channels) .or. &
          & lbound(channels,1) /= lbound(signal%frequencies,1) .or. &
          & ubound(channels,1) /= ubound(signal%frequencies,1) ) then
          first = .true.
          call output ( '.C' )
          i = lbound(channels, 1)
oc:       do
            do
              if ( i > ubound(channels, 1) ) exit oc
              if ( channels(i) ) exit
              i = i + 1
            end do
            if ( .not. first ) call output ( '+' )
            first = .false.
            j = i
            do while ( j < ubound(channels, 1) )
              if ( .not. channels(j+1) ) exit
              j = j + 1
            end do
            if ( j > i ) then
              call output ( i, after = ':' )
              call output ( j )
            else
              call output ( i )
            end if
            i = j + 1
          end do oc
        end if
      end if
    end if
    call output ( '', advance=advance )
  end subroutine DisplaySignalName_signal

  ! -------------------------------------------------  Dump_Bands  -----
  subroutine DUMP_BANDS ( BANDS )
    type (Band_T), intent(in) :: BANDS(:)
    integer :: i
    call output ( 'BANDS: SIZE = ')
    call output ( size(bands), advance='yes' )
    do i = 1, size(bands)
      call output ( i )
      call output ( ': ' )
      call display_string (bands(i)%prefix)
      call output ( ':' )
      call display_string (bands(i)%suffix, strip=.true. )
      call output ( '   Radiometer: ')
      if ( bands(i)%radiometer /= 0 ) then
        call output ( bands(i)%radiometer )
        call output ( ' - ' )
        call display_string ( radiometers(bands(i)%radiometer)%prefix )
      else
        call output ( ' deferred' )
      end if
      call output ( '   SpectrometerType: ' )
      call output ( bands(i)%spectrometerType )
      call output ( ' - ' )
      call display_string ( spectrometerTypes(bands(i)%spectrometerType)%name, &
        & advance='yes' )
      call output ( '   Frequency: ')
      call output ( bands(i)%centerFrequency, advance='yes' )
    end do
  end subroutine DUMP_BANDS

  ! -------------------------------------------  Dump_All  -----
  ! Dump all databases related to Signals, Modules, etc.
  subroutine Dump_All
    !
    call headline( 'All databases related to Signals', &
      & fillChar='-', before='*', after='*' )
    call output ( '   Instrument: ', advance='no' )
    call display_string ( lit_indices(instrument) )
    call newLine
    call dump_modules
    call dump_radiometers ( radiometers )
    call dump_bands( bands )
    call dump_spectrometerTypes( spectrometerTypes )
    call Dump_Signals( signals )
  end subroutine Dump_All

  ! -------------------------------------------  Dump_Modules  -----
  subroutine Dump_Modules
    !
    character(len=16), dimension(:,:), pointer :: array
    integer :: i
    integer :: n
    ! Executable
    if ( .not. associated(modules) ) then
      call output( '(modules not associated)', advance='yes' )
      return
    endif
    call headline( 'modules' )
    nullify( array )
    n = size(modules)
    allocate( array(n+1, 4 ) )
    array(1,1) = 'name'
    array(1,2) = 's/c'
    array(1,3) = 'Aura'
    array(1,4) = 'Supports'
    array(2:n+1,1) = modules(:)%nameString
    do i=1, n
      if ( len_trim(modules(i)%nameString) < 1 ) &
        & call get_string( modules(i)%name, array(i+1,1) )
      if ( modules(i)%supportedModule == 0 ) then
        array(i+1,4) = '<none>'
      else
        call get_string ( modules(modules(i)%supportedModule)%name,&
          & array(i+1,4) )
      end if
    enddo
    array(2:n+1,2) = merge( 'T', 'F', modules(:)%spaceCraft )
    array(2:n+1,3) = merge( 'T', 'F', modules(:)%Aura )
    call outputTable( array, border='-', headliner='-' )
    deallocate( array )
  end subroutine Dump_Modules

  ! -------------------------------------------  Dump_OneRadiometer  -----
  subroutine Dump_OneRadiometer ( RADIOMETER )
    type (Radiometer_T), intent(in) :: RADIOMETER
    call display_string (radiometer%prefix)
    call output ( ':' )
    call display_string (radiometer%suffix, advance='yes', strip=.true. )
    call output ( '   Polarization: ' )
    call display_string (lit_indices(radiometer%polarization))
    call output ( '   Module: ')
    if ( radiometer%instrumentModule /= 0 ) then
      call output ( radiometer%instrumentModule )
      call output ( ' - ' )
      call display_string ( modules(radiometer%instrumentModule)%name, advance='yes' ) 
    else
      call output ( '<undefined>', advance='yes' )
    end if
    call output ( '   LO: ')
    call output ( radiometer%lo )
    call output ( '   Single sideband: ' )
    call output ( radiometer%singleSideband, advance='yes' )
  end subroutine Dump_OneRadiometer

  ! -------------------------------------------  Dump_Radiometers  -----
  subroutine DUMP_RADIOMETERS ( RADIOMETERS )
    type (Radiometer_T), intent(in) :: RADIOMETERS(:)
    integer :: i
    call output ( 'RADIOMETERS: SIZE = ')
    call output ( size(radiometers), advance='yes' )
    do i = 1, size(radiometers)
      call output ( i,1 )
      call output ( ': ')
      call dump_OneRadiometer( radiometers(i) )
    end do
  end subroutine DUMP_RADIOMETERS

  ! ------------------------------------------------  Dump_Signal  -----
  subroutine Dump_Signal ( Signal, Details, OtherChannels )
    type (signal_T), intent(in) :: SIGNAL
    integer, intent(in), optional :: Details ! 0  => don't dump frequencies
                                             ! -1 => dump only name
    logical, pointer, optional :: OtherChannels(:)
    logical, pointer :: Channels(:)
    integer :: My_Details
    character (len=80) :: Str
    my_details = 0
    if ( present(details) ) my_details = details
    channels => signal%channels
    if ( present(otherChannels) ) channels => otherChannels
    if ( signal%name > 0 ) call display_string ( signal%name, advance='yes' )
    call output ( '   Signal: ' )
    call displaySignalName ( signal, otherChannels=otherChannels )
    if ( My_Details < 0 ) then
      call NewLine 
      return
    endif
    call output ( '   Module: ')
    call output ( signal%instrumentModule )
    call output ( ' - ' )
    if ( associated(modules) ) then
      call display_string ( modules(signal%instrumentModule)%name, &
        & advance='yes' )
    else
      call output ( 'Cannot get module name', advance='yes' )
    end if
    call output ( '   Radiometer: ')
    call output ( signal%radiometer )
    call output ( ' - ' )
    if ( associated(radiometers) ) then
      call getRadiometerName ( signal%radiometer, str )
      call output ( TRIM(str) )
    else
      call output ( 'Cannot get radiometer name', advance='yes' )
    end if
    call output ( '   First LO: ')
    call output ( signal%lo, after=' MHz', advance='yes' )
    call output ( '   Band: ')
    call output ( signal%band )
    call output (' - ')
    if ( associated(bands) ) then
      call getBandName ( signal%band, str )
      call output ( TRIM(str) )
    else
      call output ( 'Cannot get band name', advance='yes' )
    end if
    call output ( '   Band center frequency: ')
    call output ( signal%centerFrequency, after=' MHz', advance='yes' )
    call output ( '   SpectrometerType: ')
    call output ( signal%spectrometerType )
    call output ( ' - ' )
    if ( associated(spectrometerTypes) ) then
      call display_string ( spectrometerTypes(signal%spectrometerType)%name )
    else
      call output ( 'Cannot get spectrometer type name', advance='yes' )
    end if
    call output ( '   DACS?: ' )
    call output ( signal%dacs )
    call output ( '   Channels: ' )
    call output ( lbound(signal%frequencies,1), 3 )
    call output ( ':' )
    call output ( ubound(signal%frequencies,1), 3, advance='yes' )
    call output ( '   Sideband: ' )
    call output ( signal%sideband )
    call output ( '   Single Sideband: ' )
    call output ( signal%singleSideband, advance='yes')
    if ( my_details > 0) then
      call output ( '   Frequencies (MHz)' )
      if ( signal%deferred ) call output ( ' (deferred)' )
      call output ( ':', advance='yes' )
      call dump ( signal%frequencies )
      call output ( '   Widths' )
      if ( signal%deferred ) call output ( '(deferred)' )
      call output ( ':', advance='yes' )
      call dump ( signal%widths )
    else
      call output ( '   Frequencies and widths are' )
      if ( .not. signal%deferred ) call output ( ' not' )
      call output ( ' deferred', advance='yes' )
    end if ! my_details
    if (associated(channels)) then
      call output ( '   Channel Flags:', advance='yes' )
      call dump ( channels, lbound=lbound(channels,1) )
    else
      call output ( '   All channels selected', advance='yes' )
    end if
  end subroutine Dump_Signal

  ! -----------------------------------------------  Dump_Signals  -----
  subroutine Dump_Signals ( Signals, isSignalCritical, Details, OtherChannels )
    type (signal_T), intent(in)                 :: Signals(:)
    logical, dimension(:), intent(in), optional :: isSignalCritical
    integer, intent(in), optional               :: Details ! How verbose?
    logical, pointer, optional                  :: OtherChannels(:)
    integer :: I
!   character(len=*), parameter                 :: The80 = &
!     & '12345678901234567890123456789012345678901234567890123456789012345678901234567890'
!   character(len=*), parameter                 :: TheDecades = &
!     & '         1         2         3         4         5         6         7         8'
    character(len=2) :: str
    integer :: myDetails
    ! Executable
    myDetails = 0
    if ( present(Details) ) myDetails = Details
    call outputNamedValue ( 'Size(signals)', size(signals), options='--Headline' )
    if ( myDetails < 0 ) then
      do i=1, size(signals)
        call output( i, advance='no' )
        call blanks ( 2 )
        call Dump_Signal ( signals(i), Details )
      enddo
      return
    endif
    ! call output( The80, advance='yes' )
    ! call output( TheDecades, advance='yes' )
    ! Column headers: 4 columns
    ! Index   signal  band  critical module
    call output( 'Index', advance='no' )
    call tab ( 3 )
    call output( 'signal', advance='no' )
    call tab ( 7 )
    call output( 'band', advance='no' )
    call tab ( 9 )
    call output( 'critical', advance='no' )
    call tab ( 11 )
    call output( 'module', advance='no' )
    if ( myDetails > 0 ) then
      call tab ( 13 )
      call output( 'DACS', advance='no' )
      call tab ( 15 )
      call output( 'Sideband', advance='no' )
      call tab ( 17 )
      call output( 'Spectrometer', advance='no' )
      call tab ( 19 )
      call output( 'Channels', advance='no' )
    endif
    call NewLine
    do i = 1, size(signals)
      call output ( i )
      call tab
      call displaySignalName ( signals(i), otherChannels=otherChannels )
      call tab ( 7 )
      call output ( signals(i)%Band )
      if ( present( isSignalCritical ) ) then
        str = merge( 'y', 'n', isSignalCritical(i) )
      else
        str = '?'
      endif
      call tab ( 9 )
      call output ( str )
      call tab ( 11 )
      call display_string ( modules(signals(i)%instrumentModule)%name, &
        & advance='no' )
      if ( myDetails > 0 ) then
        call tab ( 13 )
        call output ( signals(i)%dacs )
        call tab ( 15 )
        call output ( signals(i)%sideband )
        call tab ( 17 )
        call display_string ( spectrometerTypes(signals(i)%spectrometerType)%name )
        call tab ( 19 )
        call output( lbound(signals(i)%frequencies,1) )
        call output( ':' )
        call output( ubound(signals(i)%frequencies,1) )
      endif
      call NewLine
    end do
  end subroutine Dump_Signals

  ! --------------------------------------  Dump_SpectrometerType  -----
  subroutine DUMP_SPECTROMETERTYPE ( SPECTROMETERTYPE, N )
    type (SpectrometerType_T), intent(in) :: SPECTROMETERTYPE
    integer, intent(in), optional :: N

    if ( present(n) ) then
      call output ( n, 1 )
      call output ( ': ')
    end if
    call display_string ( spectrometerType%name, advance='yes' )
    if ( associated(spectrometerType%frequencies) ) then
      call output ( '  Channels: ' )
      call output ( lbound(spectrometerType%frequencies,1), 3 )
      call output ( ':' )
      call output ( ubound(spectrometerType%frequencies,1), 3 )
      call output ( '  DACS?: ' )
      call output ( spectrometerType%dacs, advance='yes' )
      call output ( '  Frequencies:', advance='yes' )
      call dump ( spectrometerType%frequencies )
      call output ( '  Widths:', advance='yes' )
      call dump ( spectrometerType%widths )
    else
      call output ('   Frequencies and widths deferred.' )
      call output ( '  DACS?: ' )
      call output ( spectrometerType%dacs, advance='yes' )
    end if

  end subroutine DUMP_SPECTROMETERTYPE

  ! -------------------------------------  Dump_SpectrometerTypes  -----
  subroutine DUMP_SPECTROMETERTYPES ( SPECTROMETERTYPES )
    type (SpectrometerType_T), intent(in) :: SPECTROMETERTYPES(:)
    integer :: i
    call output ( 'SPECTROMETERTYPES: SIZE = ')
    call output ( size(spectrometerTypes), advance='yes' )
    do i = 1, size(spectrometerTypes)
      call dump ( spectrometerTypes(i), i )
    end do
  end subroutine DUMP_SPECTROMETERTYPES

  ! ----------------------------------------------  GetAllModules  -----
  subroutine GetAllModules(moduleNodes)
    ! Return tree nodes for all modules
    integer, dimension(:), pointer :: moduleNodes
    
    call Allocate_Test ( moduleNodes, size(modules), 'ModuleNodes', ModuleName )
    moduleNodes = modules%node
  end subroutine GetAllModules

  ! ------------------------------------------------  GetBandName  -----
  subroutine GetBandName(band, string_text, sideband, noSuffix)
    ! Given an index in the Bands database, place band name in string
    integer, intent(in) :: BAND                   ! Database index
    character(len=*), intent(out) :: STRING_TEXT  ! Result
    integer, intent(in), optional :: SIDEBAND     ! L_Folded, L_Lower, L_Upper
    logical, intent(in), optional :: NOSUFFIX     ! Omit suffix if present and true

    ! Local variables
    logical :: MY_NOSUFFIX
    integer :: MY_SIDEBAND
    integer :: ENDOFFIRSTNUMBER
    logical :: FOUNDEND
    character (len=1) :: SB_CHAR        ! U/L for sideband
    character (len=1) :: SB_CHARS(-1:1) = (/ 'L', ' ', 'U' /)

    ! Executable code
    my_noSuffix = .false.
    my_sideband = 0
    if ( present(noSuffix) ) my_noSuffix = noSuffix
    if ( present(sideband) ) my_sideband = sideband

    if ( my_sideband < -1 .or. my_sideband > 1 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Illegal sideband' )
    sb_char = sb_chars(my_sideband)
    
    call get_string ( bands(band)%prefix, string_text, cap=.true. )
    foundEnd = .false.
    do endOfFirstNumber = 2, len_trim ( string_text )
      if ( index ( '0123456789', string_text(endOfFirstNumber:endOfFirstNumber) ) == 0 ) &
        & foundEnd = .true.
      if ( foundEnd ) exit
    end do
    if ( .not. foundEnd ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Cannot understand band name' )
    string_text = string_text(1:endOfFirstNumber-1) // TRIM(sb_char) // &
      & string_text(endOfFirstNumber:LEN_TRIM(string_text))
    if ( (.not. my_noSuffix) .and. &
      &  (len_trim(string_text) < len(string_text)) ) then
      string_text = TRIM(string_text) // ':'
      call get_string ( bands(band)%suffix,&
        & string_text(LEN_TRIM(string_text)+1:), cap=.true., strip=.true. )
    end if

  end subroutine GetBandName

  ! ------------------------------------  GetFirstChannel --------------
  integer function GetFirstChannel ( signal )
    integer, intent(in) :: SIGNAL
    GetFirstchannel = lbound ( signals(signal)%frequencies, 1 )
  end function GetFirstChannel

  ! ------------------------------------  GetModuleFromRadiometer  -----
  integer function GetModuleFromRadiometer(radiometer)
    ! Returns module field from given radiometer given as database index
    integer, intent(in) :: radiometer
    GetModuleFromRadiometer = radiometers(radiometer)%instrumentModule
  end function GetModuleFromRadiometer

  ! ----------------------------------------  GetModuleFromSignal  -----
  integer function GetModuleFromSignal(signal)
    ! Returns module field from given signal given as database index
    integer, intent(in) :: signal
    GetModuleFromSignal = signals(signal)%instrumentModule
  end function GetModuleFromSignal

  ! ----------------------------------------------  GetModuleIndex  -----
  subroutine GetModuleIndex(string_text, instrumentModule)
    ! Returns the index in the module database, given module name in mixed case
    ! Returns 0 if module name not found
    ! (inverse function: GetModuleName)
    integer, intent(out) :: instrumentModule
    character (len=*), intent(in) :: string_text
    ! Local variables
    character (len=len(string_text))             :: string_test
    if ( size(modules) < 1 ) then
      instrumentModule = 0
      return
    end if
    do instrumentModule=1, size(modules)
      if ( modules(instrumentModule)%name > 0 ) then
        call Get_String ( modules(instrumentModule)%name, string_test )
        if ( LowerCase(trim(string_text)) == LowerCase(trim(string_test))) &
          & return
      elseif ( len_trim(modules(instrumentModule)%nameString) > 0 ) then
        string_test = modules(instrumentModule)%nameString
        if ( LowerCase(trim(string_text)) == LowerCase(trim(string_test))) &
          & return
      end if
    end do
    instrumentModule = 0
  end subroutine GetModuleIndex

  ! ----------------------------------------------  GetModuleName  -----
  subroutine GetModuleName(instrumentModule, string_text)
    ! Given the index in the module database, returns module name in mixed case
    ! (inverse function: GetModuleIndex)
    integer, intent(in) :: instrumentModule
    character (len=*), intent(out) :: string_text
    if ( modules(instrumentModule)%name < 1 .or. &
      & len_trim(modules(instrumentModule)%nameString) > 0 ) then
      string_text =  modules(instrumentModule)%nameString
    else
      call Get_String ( modules(instrumentModule)%name, string_text )
    endif
    ! call outputNamedValue ( 'got module name', trim(string_text) )
  end subroutine GetModuleName

  ! ----------------------------------------------  GetSignalIndex  -----
  subroutine GetSignalIndex(string_text, signal_index)
    ! Returns the index in the signals database, given signal name in mixed case
    ! Returns 0 if signal name not found
    ! (inverse function: GetSignalName)
    integer, intent(out) :: signal_index
    character (len=*), intent(in) :: string_text
    ! Local variables
    character (len=len(string_text))             :: string_test
    if ( size(signals) < 1 ) then
      signal_index = 0
      return
    end if
    do signal_index=1, size(signals)
      if ( signals(signal_index)%name > 0 .and. .false. ) then
        call Get_String ( signals(signal_index)%name, string_test )
        if ( LowerCase(trim(string_text)) == LowerCase(trim(string_test))) &
          & return
      else
        call GetNameOfSignal ( signals(signal_index), string_test )
        if ( LowerCase(trim(string_text)) == LowerCase(trim(string_test))) &
          & return
      end if
    end do
    signal_index = 0
  end subroutine GetSignalIndex

  ! --------------------------------------------  GetNameOfSignal  -----
  subroutine GetNameOfSignal ( Signal, String_text, NoRadiometer, NoBand, &
    & NoSwitch, NoSpectrometer, NoChannels, NoSuffix, sideband, channel, &
    & OtherChannels )
    ! Given a signal object, this routine constructs a full signal name.
    type(signal_T), intent(in) :: SIGNAL
    character(len=*), intent(inout) :: STRING_TEXT
    logical, intent(in), optional :: NORADIOMETER
    logical, intent(in), optional :: NOBAND
    logical, intent(in), optional :: NOSWITCH
    logical, intent(in), optional :: NOSPECTROMETER
    logical, intent(in), optional :: NOCHANNELS
    logical, intent(in), optional :: NOSUFFIX
    integer, intent(in), optional :: SIDEBAND
    integer, intent(in), optional :: CHANNEL ! Only this channel, noChannels overrides it
    logical, pointer, optional :: OtherChannels(:) ! instead of from Signal,
                                                   ! Channel overrides this

    ! Local variables
    logical :: First     ! First channel in signal text
    logical, pointer :: Channels(:) ! From signal or OtherChannels
    integer :: I, J, L
    logical :: MY_NORADIOMETER, MY_NOBAND, MY_NOSWITCH
    logical :: MY_NOSPECTROMETER, MY_NOCHANNELS
    integer :: MY_SIDEBAND
    character (len=8) :: word

    ! Executable code
    string_text       = ''
    my_noRadiometer   = .false.
    my_noBand         = .false.
    my_noSwitch       = .false.
    my_noSpectrometer = .false.
    my_noChannels     = .false.
    my_sideband       = signal%sideband

    if ( present(noRadiometer) )   my_noRadiometer =   noRadiometer
    if ( present(noBand) )         my_noBand =         noBand
    if ( present(noSwitch) )       my_noSwitch =       noSwitch
    if ( present(noSpectrometer) ) my_noSpectrometer = noSpectrometer
    if ( present(noChannels) )     my_noChannels =     noChannels
    if ( present(sideband) )       my_sideband =       sideband

    if ( .not. my_noRadiometer ) call GetRadiometerName ( signal%radiometer, &
      & string_text, noSuffix=noSuffix )

    if ( .not. my_noBand ) then
      if ( (len_trim(string_text) /= 0) .and. &
        &  (len_trim(string_text)<len(string_text)) ) &
        &  string_text = TRIM(string_text) // '.'
      call GetBandName ( signal%band, &
        & string_text(LEN_TRIM(string_text)+1:), sideband=my_sideband, &
        & noSuffix=noSuffix )
    end if

    if ( .not. my_noSwitch ) then
      if ( (len_trim(string_text) /= 0) .and. &
        &  (len_trim(string_text)+1<len(string_text)) ) &
        &  string_text = TRIM(string_text) // '.S'
      write (word,'(I8)') signal%switch
      word = adjustl(word)
      if ( len_trim(string_text)+len_trim(word) < len(string_text) )&
        & string_text = TRIM(string_text) // TRIM(word)
    end if

    if ( .not. my_noSpectrometer ) then
      if ( (len_trim(string_text) /= 0) .and. &
        &  (len_trim(string_text)<len(string_text)) ) &
        &  string_text = TRIM(string_text) // '.'
      call GetSpectrometerTypeName ( signal%spectrometerType, &
        & signal%spectrometer, string_text(LEN_TRIM(string_text)+1:) )
    end if

    if ( .not. my_noChannels ) then
      channels => signal%channels
      if ( present(otherChannels) ) channels => otherChannels
      if ( present(channel) ) then
        l = len_trim(string_text)
        call addToSignalString ( '.C' )
        write ( word,'(I8)') channel
        call addToSignalString ( word )
      else if ( associated(channels) ) then
        if ( .not. all(channels) .or. &
          & lbound(channels,1) /= lbound(signal%frequencies,1) .or. &
          & ubound(channels,1) /= ubound(signal%frequencies,1) ) then
          l = len_trim(string_text)
          call addToSignalString ( '.C' )
          i = lbound(channels, 1)
          first = .true.
          oc: do
            do
              if ( i > ubound(channels, 1) ) exit oc
              if ( channels(i) ) exit
              i = i + 1
            end do
            if ( .not. first ) call addToSignalString ( '+' )
            first = .false.
            j = i
            do while ( j < ubound(channels, 1) )
              if ( .not. channels(j+1) ) exit
              j = j + 1
            end do
            if ( j > i ) then
              write ( word,'(I8)') i
              call addToSignalString ( word )
              call addToSignalString ( ':' )
              write ( word,'(I8)') j
              call addToSignalString ( word )
            else
              write ( word,'(I8)') i
              call addToSignalString ( word )
            end if
            i = j + 1
          end do oc
        end if
      end if
    end if

  contains
    subroutine AddToSignalString ( Text )
      ! Assumes L = len_trim(string_text) on entry, preserves it
      character(len=*), intent(in) :: Text
      integer :: Lt
      lt = len_trim(adjustl(text))
      if ( l+lt <= len(string_text) ) &
        & string_text(l+1:l+lt) = trim(adjustl(text))
      l = l + lt
    end subroutine AddToSignalString
  end subroutine GetNameOfSignal

  ! ------------------------------------  GetRadiometerFromSignal  -----
  integer function GetRadiometerFromSignal(signal)
    ! Returns radiometer field from given signal given as database index
    integer, intent(in) :: signal
    GetRadiometerFromSignal = signals(signal)%radiometer
  end function GetRadiometerFromSignal

  ! ----------------------------------------------  GetRadiometerIndex  -----
  subroutine GetRadiometerIndex(string_text, radiometer)
    ! Returns the index in the radiometer database, 
    ! given radiometer name in mixed case
    ! Returns 0 if radiometer name not found
    ! Examples of string_text:
    ! 'R1A:118', 'R3:240', 'R3',  (yes, we may omit suffix or prefix)
    ! Note: beware of an ambiguous string_tetxt;
    ! e.g., if you just use a suffix, e.g., '118', you will end up with
    ! the first match, 'R1A:118' and not 'R1B:118'
    ! (inverse function: GetradiometerName)
    integer, intent(out) :: radiometer
    character (len=*), intent(in)        :: string_text
    ! Local variables
    character (len=MAXRADIOMETERNAMELEN) :: prefix
    character (len=MAXRADIOMETERNAMELEN) :: suffix
    ! Executable
    radiometer = 0 ! If no matching radiometer found
    if ( size(radiometers) < 1 ) then
      return
    end if
    do radiometer=1, size(radiometers)
      ! Return first match
      if ( radiometers(radiometer)%prefix > 0 ) then
        call Get_String ( radiometers(radiometer)%prefix, prefix )
        ! Did we just try the prefix?
        if ( LowerCase(trim(string_text)) == LowerCase(trim(prefix))) &
          & return
        call get_string ( radiometers(radiometer)%suffix, &
          & suffix, cap=.true., strip=.true. )
        ! Did we just try the suffix?
        if ( LowerCase(trim(string_text)) == LowerCase(trim(suffix))) &
          & return
        ! Did we go for prefix:suffix?
        if ( LowerCase( trim(string_text) ) == &
          & LowerCase( trim(prefix) // ':' // trim(suffix) ) ) &
          & return
      end if
    end do
    ! Oops, sorry no match found
  end subroutine GetRadiometerIndex

  ! ------------------------------------------  GetRadiometerName  -----
  subroutine GetRadiometerName(radiometer, string_text, noSuffix)
    ! Given an index in the Radiometers database, place radiometer name
    ! in string
    integer, intent(in) :: RADIOMETER             ! Database index
    character(len=*), intent(out) :: STRING_TEXT  ! Result
    logical, intent(in), optional :: NOSUFFIX     ! Omit suffix if present and true

    ! Local variables
    logical :: MY_NOSUFFIX

    ! Executable code
    my_noSuffix = .false.
    if ( present(noSuffix) ) my_noSuffix = noSuffix

    call get_string ( radiometers(radiometer)%prefix, string_text, cap=.true., &
      & strip=.true. )
    if ( (.not. my_noSuffix) .and. &
      &  (len_trim(string_text) < len(string_text)) ) then
      string_text = TRIM(string_text) // ':'
      call get_string ( radiometers(radiometer)%suffix, &
        & string_text(LEN_TRIM(string_text)+1:), cap=.true., strip=.true. )
    end if

  end subroutine GetRadiometerName

  ! --------------------------------------------  GetSidebandLoop  -----
  subroutine GetSidebandLoop ( signal, sideband, split, &
    & sidebandStart, sidebandStop, sidebandStep )
    ! This routine gets the loop limits for a loop over sidebands from
    ! a signal in the database.
    integer, intent(in) :: SIGNAL       ! Index into signals
    integer, intent(in) :: SIDEBAND     ! -1,0,1
    logical, intent(in) :: SPLIT        ! If set do a split sideband loop for folded
    integer, intent(out) :: SIDEBANDSTART ! Loop lower limit
    integer, intent(out) :: SIDEBANDSTOP ! Loop upper limit
    integer, intent(out) :: SIDEBANDSTEP ! Loop step

    ! Executable code
    if ( sideband == 0 ) then
      if ( split ) then
        if ( signals(signal)%singleSideband /= 0 ) then
          sidebandStart = signals(signal)%singleSideband
          sidebandStop = sidebandStart
          sidebandStep = 1
        else
          sidebandStart = -1
          sidebandStop = 1
          sidebandStep = 2
        end if
      else
        sidebandStart = 0
        sidebandStop = sidebandStart
        sidebandStep = 1
      end if
    else
      sidebandStart = sideband
      sidebandStop = sidebandStart
      sidebandStep = 1
    end if
  end subroutine GetSidebandLoop

  ! ---------------------------------------  GetSidebandStartStop  -----
  subroutine GetSidebandStartStop ( Signal, SidebandStart, SidebandStop )
    ! This routine also gets the sideband start and stop, but from any
    ! signal, including one parsed from a config.  We don't bother to
    ! compute the step, because if SidebandStart == SidebandStop it doesn't
    ! matter what the step is, and otherwise the step should be 2. So users
    ! should always just use 2.
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    type(signal_t), intent(in) :: Signal
    integer, intent(out) :: SidebandStart, SidebandStop
    if ( ( signal%sideband == 0 ) .and. &
      &  ( signal%singleSideband == 0 ) ) then
      ! Do a folded measurement
      sidebandStart = -1
      sidebandStop = 1
    else
      ! It's either a single sideband radiometer, or the user requested a
      ! specific sideband.
      ! Check sanity, if they are both non zero they should be the same.
      if ( ( signal%singleSideband /= 0 ) .and. &
        &  ( signal%sideband /= 0 ) .and. &
        &  ( signal%singleSideband /= &
        &    signal%sideband ) ) call MLSMessage ( &
        &      MLSMSG_Error, ModuleName, &
        &      "User requested a sideband that doesn't exist" )
      ! OK, use whichever one is given
      if ( signal%singleSideband /= 0 ) then
        sidebandStart = signal%singleSideband
      else
        sidebandStart = signal%sideband
      end if
      sidebandStop = sidebandStart
    end if
  end subroutine GetSidebandStartStop

  ! --------------------------------------------------  GetSignal  -----
  type (Signal_T) function GetSignal(signal)
    ! Given the database index, this routine returns the signal data structure
    integer, intent(in) :: SIGNAL       ! Requested signal
    
    GetSignal = signals(signal)
  end function GetSignal    

  ! ----------------------------------------------  GetSignalName  -----
  subroutine GetSignalName ( Signal, String_text, NoRadiometer, NoBand, &
    & NoSwitch, NoSpectrometer, NoChannels, NoSuffix, Sideband, Channel, &
    & OtherChannels )
    ! Given an index in the signals database, this routine constructs a
    ! full signal name.
    integer, intent(in) :: SIGNAL                 ! Database index
    character(len=*), intent(inout) :: STRING_TEXT
    logical, intent(in), optional :: NORADIOMETER
    logical, intent(in), optional :: NOBAND
    logical, intent(in), optional :: NOSWITCH
    logical, intent(in), optional :: NOSPECTROMETER
    logical, intent(in), optional :: NOCHANNELS
    logical, intent(in), optional :: NOSUFFIX
    integer, intent(in), optional :: SIDEBAND
    integer, intent(in), optional :: CHANNEL ! Only this channel, noChannels overrides this
    logical, pointer, optional :: OtherChannels(:) ! instead of from Signal,
                                                   ! Channel overrides this

    call getNameOfSignal ( signals(signal), string_text, noRadiometer, noBand, &
      & noSwitch, noSpectrometer, noChannels, noSuffix, sideband, channel, &
      & otherChannels )
  end subroutine GetSignalName 

  ! ----------------------------------------  GetSpectrometerName  -----
  subroutine GetSpectrometerTypeName(spectrometerType, number, string_text)
    ! Place spectrometer name and number in string
    integer, intent(in) :: SPECTROMETERTYPE
    integer, intent(in) :: NUMBER
    character (len=*), intent(out) :: STRING_TEXT

    ! Local variables
    character (len=8) :: word

    ! Executable code
    call get_string ( spectrometerTypes(spectrometerType)%name, string_text )
    if ( len_trim(string_text) < len(string_text) ) &
      & string_text = TRIM(string_text) // '-'
    write ( word,'(I8)' ) number
    word = adjustl(Capitalize(word))
    if ( len_trim(string_text)+len_trim(word) < len(string_text) ) &
      & string_text = TRIM(string_text) // TRIM(word)
    string_text = Capitalize(string_text)
  end subroutine GetSpectrometerTypeName

  ! -----------------------------------------  IsAnyModuleSpacecraft  -----
  logical function IsAnyModuleSpacecraft()
    ! Returns true if any module is really the spacecraft
    integer :: i
    IsAnyModuleSpacecraft = modules(1)%spacecraft
    do i = 2, size(modules)
      IsAnyModuleSpacecraft = IsAnyModuleSpacecraft &
        & .or. modules(i)%spacecraft
    enddo
  end function IsAnyModuleSpacecraft

  ! -----------------------------------------  IsModuleSpacecraft  -----
  logical function IsModuleSpacecraft(thisModule)
    ! Returns true if the module is really the spacecraft
    integer, intent(in) :: thisModule
    IsModuleSpacecraft = modules(thisModule)%spacecraft
  end function IsModuleSpacecraft

  ! -----------------------------------------  IsSpaceCraftAura  -----
  logical function IsSpaceCraftAura()
    ! Returns true if the s/c is really the Aura spacecraft
    IsSpaceCraftAura = associated( modules )
    if ( IsSpaceCraftAura ) IsSpaceCraftAura = all( modules%Aura )
  end function IsSpaceCraftAura

  ! -----------------------------------------------  MatchSignals  -----
  integer function MatchSignals ( Signals, Probe, sideband, channel, matchFlags, &
    & NoMatchFails, FromWhere, DSBSSB )
    ! Given an array Signals, find the one in the array that provides
    ! the smallest superset of features of the signal Probe.  The result
    ! is zero if no signals match.
    ! If sideband or channel are present they are used for the probe, instead
    ! of the values in probe.

    type(signal_T), dimension(:), intent(in) :: Signals
    type(signal_T), intent(in) :: Probe
    integer, intent(in), optional :: sideband     ! Use this instead of probe%sideband
    logical, dimension(size(signals)), intent(out), optional :: matchFlags
    integer, intent(in), optional :: CHANNEL      ! Just this channel
    logical, intent(in), optional :: NoMatchFails ! Fail if no match
    character(len=*), intent(in), optional :: FromWhere ! For an error message
    logical, intent(in), optional :: DSBSSB       ! OK if one sig is DSB, other is SSB

    integer :: BestMatch                ! The smallest number of 
    integer :: I                        ! Loop inductors, subscripts
    integer :: NumChannelsMatch

    if ( present(matchFlags) ) matchFlags = .false.

    bestMatch = huge(bestMatch)
    matchSignals = 0
    do i = 1, size(signals)
      numChannelsMatch = matchSignalPair ( signals(i), probe, sideband, &
        & channel, DSBSSB=DSBSSB )
      if ( numChannelsMatch > 0 ) then
        if ( present( matchFlags ) ) matchFlags(i) = .true.
        if ( numChannelsMatch < bestMatch ) then
          matchSignals = i
          bestMatch = numChannelsMatch
        end if
      end if
    end do
    if ( present(noMatchFails) ) then
      if ( noMatchFails .and. matchSignals == 0 ) then
        if ( present(fromWhere) ) then
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'No match for requested signal from ' // trim(fromWhere) )
        else
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'No match for requested signal' )
        end if
      end if
    end if
  end function MatchSignals

  ! --------------------------------------------  MatchSignalPair  -----
  integer function MatchSignalPair ( Signal, Probe, sideband, channel, &
    & DSBSSB, NoMatchFails, FromWhere )
    ! Given a Signal and a Probe, determine whether they match.
    ! If Sideband or Channel are present they are used for the probe, instead
    ! of the values in Probe.
    ! The result is -1 if not, else the number of matching channels.

    type(signal_T), intent(in) :: Signal, Probe
    integer, intent(in), optional :: sideband     ! Use this instead of probe%sideband
    integer, intent(in), optional :: CHANNEL      ! Just this channel
    logical, intent(in), optional :: DSBSSB       ! OK if one DSB, one SSB
    logical, intent(in), optional :: NoMatchFails ! Fail if no match
    character(len=*), intent(in), optional :: FromWhere ! For an error message

    logical :: Match
    logical :: MyDSBSSB
    integer :: MySideband               ! Either sideband or probe%sideband
    logical :: SidebandOK

    matchSignalPair = -1

    mySideband = probe%sideband
    if ( present(sideband) ) mySideband = sideband

    myDSBSSB = .false.
    if ( present(DSBSSB) ) myDSBSSB = DSBSSB

    ! First, the signal must have the same band, instrument module,
    ! radiometer, spectrometer, spectrometer type and switch number as
    ! the probe signal
    sidebandOK = (signal%sideband == mySideband) .or. &
      &          myDSBSSB .and. (signal%sideband * mySideband == 0)
    match = signal%band == probe%band .and. &
      &  signal%instrumentModule == probe%instrumentModule.and. &
      &  signal%radiometer == probe%radiometer .and. &
      &  sidebandOK .and. &
      &  signal%spectrometer == probe%spectrometer .and. &
      &  signal%spectrometerType == probe%spectrometerType .and. &
      &  signal%switch == probe%switch
    if ( match ) then
      ! Now the channels in Probe all have to be present in signal
      if (present(channel)) then        ! User asked for a specific channel
        if ( associated(signal%channels) ) then
          if ( channel < lbound(signal%channels,1) ) then
            match = .false.
          else if ( channel > ubound(signal%channels,1) ) then
            match = .false.
          else
            match = signal%channels(channel)
          end if
        else
          match = .true.
        end if
      else
        match = (.not. associated(probe%channels)) .or. &
          & (.not. associated(signal%channels) )
        if ( .not. match ) match = all( (probe%channels .and. &
          & signal%channels(lbound(probe%channels,1):ubound(probe%channels,1)) ) &
          & .eqv. probe%channels )
      end if
      if ( match ) then
        if ( associated(signal%channels) ) then
          matchSignalPair = count(signal%channels)
        else
          matchSignalPair = size( signal%frequencies )
        end if
      end if
    end if
    if ( .not. match .and. present(noMatchFails) ) then
      if ( noMatchFails ) then
        if ( present(fromWhere) ) then
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'No match for requested signal from ' // trim(fromWhere) )
        else
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'No match for requested signal' )
        end if
      end if
    end if
  end function MatchSignalPair

  ! ----------------------------------------- AreSignalsSubset ----------
  integer function AreSignalsSuperset ( signals, probe, sideband, channel )
    ! This is related to MatchSignal.  Given two arrays of signals: signals and
    ! probe, it returns -1 if probe is not a subset of signals, otherwise, it
    ! returns the number of channels by which signals is a superset of probe.
    ! If sideband and channel are present, they are taken to override the
    ! values in probe, if that makes sense.

    ! Dummy arguments
    type (Signal_T), dimension(:), intent(in) :: SIGNALS ! Signals to search
    type (Signal_T), dimension(:), intent(in) :: PROBE ! Potential subset
    integer, intent(in), optional :: SIDEBAND ! If present overrides one in probe
    integer, intent(in), optional :: CHANNEL ! If present overrides one in probe

    ! Local variables
    integer :: I                        ! Loop counter
    integer :: MATCH                    ! Result of call to match signal
    integer :: NOPBCHANNELS             ! Total channels in probe
    integer :: NOSIGCHANNELS            ! Total channels in signals

    ! Executable code

    AreSignalsSuperset = -1               ! Default to no
    noPbChannels = 0
    noSigChannels = 0
    
    ! First we identify whether they are a superset or not
    do i = 1, size(probe)
      ! Is this probe in signals?
      match = MatchSignal ( signals, probe(i), sideband=sideband, channel=channel )
      if ( match == 0 ) return
      ! OK, now how big is this probe
      if ( present(channel) ) then
        noPbChannels = 1
      else
        if ( associated(probe(i)%channels ) ) then
          noPbChannels = noPbChannels + count( probe(i)%channels )
        else
          noPbChannels = noPbChannels + size ( probe(i)%frequencies )
        end if
      end if
    end do
    ! OK, if we got here, then we know we're a superset
    ! How many channels in signals
    do i = 1, size(signals)
      if ( associated(signals(i)%channels ) ) then
        noSigChannels = noSigChannels + count( signals(i)%channels )
      else
        noSigChannels = noSigChannels + size ( signals(i)%frequencies )
      end if
    end do

    ! Now return the difference
    AreSignalsSuperset = noSigChannels - noPbChannels

  end function AreSignalsSuperset

  ! ------------------------------------------------ PVMPackSignal ---
  subroutine PVMPackSignal ( signal )
    use PVMIDL, only: PVMIDLpack
    ! Dummy arguments
    type ( Signal_T ), intent(in) :: SIGNAL

    ! Local variables
    integer :: INFO                     ! Flag from PVM

    ! Executable code
    ! Let's pack things by type do scalars first
    call PVMIDLPack ( (/ signal%centerFrequency, signal%LO /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Packing signal lo/cf' )
    call PVMIDLPack ( (/ signal%band, signal%direction, signal%index, &
      & signal%instrumentModule, signal%name, signal%radiometer, signal%sideband, &
      & signal%singleSideband, signal%spectrometer, signal%spectrometerType, &
      & signal%switch /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Packing integers from signal' )
    call PVMIDLPack ( signal%deferred, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Packing signal deferred flag' )

    ! Now do each vector
    if ( associated ( signal%frequencies ) ) then
      call PVMIDLPack ( size(signal%frequencies), info )
      if ( info == 0 ) call PVMIDLPack ( signal%frequencies, info )
    else
      call PVMIDLPack ( 0, info )
    end if
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Packing signal frequencies/size' )

    if ( associated ( signal%widths ) ) then
      call PVMIDLPack ( size(signal%widths), info )
      if ( info == 0 ) call PVMIDLPack ( signal%widths, info )
    else
      call PVMIDLPack ( 0, info )
    end if
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Packing signal widths' )

    if ( associated ( signal%channels ) ) then
      call PVMIDLPack ( size(signal%channels), info )
      if ( info == 0 ) call PVMIDLPack ( signal%channels, info )
    else
      call PVMIDLPack ( 0, info )
    end if
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Packing signal channels' )

    ! That's it
  end subroutine PVMPackSignal
    
  ! ------------------------------------------------ PVMUnpackSignal ---
  subroutine PVMUnpackSignal ( signal )
    use PVMIDL, only: PVMIDLunpack
    ! Dummy arguments
    type ( Signal_T ), intent(out) :: SIGNAL

    ! Local variables
    integer :: INFO                     ! Flag from PVM
    integer, dimension(11) :: i11       ! Temporary array
    real(r8), dimension(2) :: f2        ! Temporary array
    integer :: SZ

    ! Executable code
    ! Unpack in mirror image to above pack
    call PVMIDLUnpack ( f2, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Unpacking signal lo/cf' )
    signal%centerFrequency = f2(1)
    signal%lo = f2(2)

    call PVMIDLUnpack ( i11, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Unpacking integers from signal' )
    signal%band = i11(1)
    signal%direction = i11(2)
    signal%index = i11(3)
    signal%instrumentModule = i11(4)
    signal%name = i11(5)
    signal%radiometer = i11(6)
    signal%sideband = i11(7)
    signal%singleSideband = i11(8)
    signal%spectrometer = i11(9)
    signal%spectrometerType = i11(10)
    signal%switch = i11(11)
    call PVMIDLUnpack ( signal%deferred, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Unpacking signal deferred flag' )

    ! Now do each vector
    call PVMIDLUnpack ( sz, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Unpacking size of frequencies' )
    call Allocate_test ( signal%frequencies, sz, 'signal%frequencies', ModuleName )
    if ( sz > 0 ) then
      call PVMIDLUnpack ( signal%frequencies, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, 'Unpacking frequencies' )
    end if
    
    call PVMIDLUnpack ( sz, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Unpacking size of widths' )
    call Allocate_test ( signal%widths, sz, 'signal%widths', ModuleName )
    if ( sz > 0 ) then
      call PVMIDLUnpack ( signal%widths, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, 'Unpacking widths' )
    end if
    
    call PVMIDLUnpack ( sz, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Unpacking size of channels' )
    call Allocate_test ( signal%channels, sz, 'signal%channels', ModuleName )
    if ( sz > 0 ) then
      call PVMIDLUnpack ( signal%channels, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, 'Unpacking channels' )
    end if
    
    ! That's it
  end subroutine PVMUnpackSignal

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSSignals_m.f90,v 2.115 2018/04/19 00:53:09 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MLSSignals_M

! $Log: MLSSignals_m.f90,v $
! Revision 2.115  2018/04/19 00:53:09  vsnyder
! Remove USE statements and declarations for unused names.  Add OtherChannels
! to call to displaySignalName in DisplaySignalName_index.  Remove Channels
! pointer in Dump_Signals because it's not used.
!
! Revision 2.114  2018/03/05 19:24:39  pwagner
! Improved DUMP_SIGNALS
!
! Revision 2.113  2018/02/27 00:50:00  livesey
! Added the supportedModule functionality to support A-SMLS
!
! Revision 2.112  2017/09/15 15:44:18  livesey
! Updated to allow modules to be defferred until signal definition
!
! Revision 2.111  2016/09/21 00:38:09  pwagner
! Change appearance of Dump_Modules
!
! Revision 2.110  2016/07/27 22:14:59  pwagner
! Added NameString component to module type
!
! Revision 2.109  2016/07/25 23:15:41  pwagner
! Added IsAnyModuleSpacecraft function
!
! Revision 2.108  2015/03/28 01:18:43  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.107  2014/09/05 00:11:11  vsnyder
! More complete and accurate allocate/deallocate size tracking.  Get
! kinds from MLSKinds instead of MLSCommon.
!
! Revision 2.106  2014/06/02 23:15:35  livesey
! Fix bug with radiometer%singleSideband not being initialized
!
! Revision 2.105  2014/05/24 01:30:17  vsnyder
! Calculate upper bound of frequencies and widths correctly
!
! Revision 2.104  2014/02/07 02:28:06  vsnyder
! Fail gracefully in case a database didn't get allocated due to prior
! trouble.  Add more tracing at -g1 level.
!
! Revision 2.103  2014/01/11 01:41:02  vsnyder
! Decruftification
!
! Revision 2.102  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.101  2013/12/12 02:08:36  vsnyder
! Use iterator to handle variables, and IF and SELECT constructs
!
! Revision 2.100  2013/11/06 01:47:26  pwagner
! May read instrument field of module; e.g. emls
!
! Revision 2.99  2013/10/09 01:08:03  vsnyder
! Add call to Evaluate_Variable
!
! Revision 2.98  2013/08/30 03:56:02  vsnyder
! Revise use of trace_begin and trace_end
!
! Revision 2.97  2013/08/23 23:27:48  pwagner
! Added function to return whether or not s/c is Aura
!
! Revision 2.96  2013/06/28 18:10:45  pwagner
! Correct erroneous GetSignalIndex; do we ever need signal_T%name?
!
! Revision 2.95  2013/06/12 02:12:23  vsnyder
! Cruft removal
!
! Revision 2.94  2012/05/01 20:52:09  vsnyder
! Remove unused assignment
!
! Revision 2.93  2011/06/02 19:22:35  pwagner
! Fixed bug in getRadiometerIndex
!
! Revision 2.92  2011/05/09 17:24:55  pwagner
! Converted to using switchDetail
!
! Revision 2.91  2011/01/29 00:51:38  vsnyder
! Add comments about units checking in front end
!
! Revision 2.90  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.89  2009/10/26 17:08:02  pwagner
! Added GetRadiometerIndex
!
! Revision 2.88  2009/10/01 00:49:13  vsnyder
! Add OtherSignals to DisplaySignalName_*
!
! Revision 2.87  2009/09/25 02:44:14  vsnyder
! Added OtherChannels to dump and getSignalName routines to use specific
! channels instead of the ones in the data structure (because sometimes
! we have a signals database index plus channels from some other source)
!
! Revision 2.86  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.85  2008/09/29 22:56:40  vsnyder
! Add PRINT statement in Not_Used_Here to reduce compilation cascades
!
! Revision 2.84  2008/09/29 22:55:17  vsnyder
! Add DisplayRadiometer subroutine
!
! Revision 2.83  2007/05/22 02:28:28  vsnyder
! Don't use list-directed formatting for internal writes.  The standard
! allows a processor to insert any number of blanks it wishes, which might
! overflow the length of the internal file.
!
! Revision 2.82  2007/04/26 20:30:53  pwagner
! Bugfix for way ifc writes ints to strings
!
! Revision 2.81  2006/04/20 01:07:57  vsnyder
! Display a signal name given either a signal structure or an index
!
! Revision 2.80  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.79  2005/04/06 23:15:31  vsnyder
! Add Before, Sideband and Channel arguments for Display_Signal_Name
!
! Revision 2.78  2005/03/15 23:48:55  pwagner
! PVMERRORMESSAGE now part of MLSMessageModule
!
! Revision 2.77  2005/01/12 03:07:37  vsnyder
! Added CHANNEL argument to GetNameOfSignal and GetSignalName
!
! Revision 2.76  2004/10/30 00:24:34  vsnyder
! Add GetSidebandStartStop
!
! Revision 2.75  2004/10/06 21:16:26  vsnyder
! Add MatchSignalPair, use it for MatchSignals
!
! Revision 2.74  2004/08/03 21:49:05  vsnyder
! Inching toward PFA
!
! Revision 2.73  2004/07/23 19:48:12  vsnyder
! Some cannonball polishing
!
! Revision 2.72  2004/07/23 18:35:17  vsnyder
! Dump low bound of channels array
!
! Revision 2.71  2004/05/29 02:45:28  vsnyder
! Add DisplaySignalName, fix a bug in GetNameOfSignal
!
! Revision 2.70  2004/05/01 04:07:44  vsnyder
! Rearranged some dumping stuff
!
! Revision 2.69  2004/04/16 00:44:24  livesey
! Added GetFirstChannel
!
! Revision 2.68  2004/03/24 23:08:58  livesey
! Bug fix in getBandName
!
! Revision 2.67  2004/03/24 01:02:17  livesey
! Slight change in GetBandName to make smls stuff easier.
!
! Revision 2.66  2004/03/22 18:22:59  livesey
! Bug fixes, only relevant for smls
!
! Revision 2.65  2004/02/11 02:24:18  livesey
! Added (probably unnecessary) initialization for DACS in
! SpectromterType_T
!
! Revision 2.64  2004/01/28 02:10:07  vsnyder
! Polish up some dump routines, other cosmetics
!
! Revision 2.63  2004/01/28 01:17:36  vsnyder
! Do spectrometerType%dacs = dacs BEFORE putting spectrometerType in the database
!
! Revision 2.62  2004/01/16 21:36:28  livesey
! Added the ability to defer the connection between bands and radiometers
! until you define the signal.  This is to support some SMLS related
! research work.
!
! Revision 2.61  2003/08/16 01:14:03  vsnyder
! Add optional 'polarization' field to 'radiometer' spec
!
! Revision 2.60  2003/07/23 21:51:36  pwagner
! Tried to fix problem with lower case dacs
!
! Revision 2.59  2003/07/23 18:04:32  livesey
! Ensure that the spectrometer names are capitalized when outputing them.
!
! Revision 2.58  2003/07/18 20:23:34  livesey
! Added DACS flag
!
! Revision 2.57  2003/05/16 02:44:18  vsnyder
! Removed USE's for unreferenced symbols
!
! Revision 2.56  2003/05/10 22:21:12  livesey
! Tried to calm down -g1..
!
! Revision 2.55  2003/03/07 03:17:50  livesey
! Add optional justchannels argument to DestroySignalDatabase
!
! Revision 2.54  2002/10/08 17:42:10  livesey
! Bug fixes in pack/unpack
!
! Revision 2.53  2002/10/08 00:09:12  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.52  2002/10/05 00:40:28  livesey
! Added pvm packing and unpacking of signals, and deep option on destroy
!
! Revision 2.51  2002/10/03 05:38:11  livesey
! Infinite loop fix
!
! Revision 2.50  2002/09/05 20:27:39  livesey
! Got rid of print statement left over from long ago.
!
! Revision 2.49  2002/07/17 06:00:40  livesey
! Added GetSidebandLoop routine
!
! Revision 2.48  2002/05/15 17:29:48  livesey
! Fixed channels related bug in MatchSignal
!
! Revision 2.47  2002/05/14 22:31:59  livesey
! Added singleSideband
!
! Revision 2.46  2002/05/03 22:38:41  livesey
! Added direction field to bands.
!
! Revision 2.45  2002/02/14 23:00:45  livesey
! Added justChannels optional argument to destroySignal
!
! Revision 2.44  2002/02/14 18:37:40  livesey
! Big fix for AreSignalsSuperset
!
! Revision 2.43  2002/02/13 23:57:34  livesey
! Tidied up a bit.  Channels doesn't need to be set for
! defered signals.  Made getSignalName skip channels field
! if appropriate.  However, possible bug lurking in channel
! printing loop.
!
! Revision 2.42  2001/11/09 23:14:08  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.41  2001/10/12 23:07:23  pwagner
! Added two inverse functions to signal (module) indexes
!
! Revision 2.40  2001/09/17 22:53:46  livesey
! Added Instrument variable
!
! Revision 2.39  2001/05/16 23:05:06  livesey
! Added channel argument to AreSignalsSuperset
!
! Revision 2.38  2001/05/16 01:24:06  livesey
! Added AreSignalsSuperset routine
!
! Revision 2.37  2001/05/03 02:06:07  vsnyder
! Insert copyright notice
!
! Revision 2.36  2001/05/02 21:50:26  livesey
! Added initialization to deferred
!
! Revision 2.35  2001/05/02 19:12:11  vsnyder
! Nullify signal%channels so it won't get hosed by subsequent allocate_test
! Spiffify dump_signals and make it work if modules etc. are already gone
! Get label into name field of signals.
!
! Revision 2.34  2001/04/26 19:33:25  livesey
! Add sideband field to getSignalName etc.
!
! Revision 2.33  2001/04/26 02:33:03  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.32  2001/04/24 22:36:27  vsnyder
! Correct the 'what' argument to deallocate_test
!
! Revision 2.31  2001/04/23 23:12:45  vsnyder
! Finish adding 'time' command
!
! Revision 2.30  2001/04/23 23:10:37  vsnyder
! Add 'time' command
!
! Revision 2.29  2001/04/21 01:06:37  vsnyder
! Make Signal%Deferred initially false
!
! Revision 2.28  2001/04/21 01:05:26  vsnyder
! Deallocate Frequencies and Widths in DestroySignal if it's deferred
!
! Revision 2.27  2001/04/20 22:41:25  vsnyder
! Publish DestroySignal
!
! Revision 2.26  2001/04/19 20:29:24  livesey
! Added sideband argument to MatchSignal and made MatchSignal look at it or
! probe%sideband
!
! Revision 2.25  2001/04/13 23:54:06  livesey
! Change intent inout to intent out for matchFlags in MatchSignal
!
! Revision 2.24  2001/04/13 23:28:59  livesey
! Tidied up some gothcas in MatchSignal.
!
! Revision 2.23  2001/04/13 20:40:23  vsnyder
! Create GetNameOfSignal that returns the name of a Signal_T object (the
! already-present subroutine GetSignalName takes a signals-database index).
! Add DestroySignal to destroy one Signal_T object.
!
! Revision 2.22  2001/04/12 18:14:19  vsnyder
! Get the right vertex for 'deferred'
!
! Revision 2.21  2001/04/11 20:19:27  vsnyder
! Undo changes to 'deferred'
!
! Revision 2.20  2001/04/11 19:57:55  vsnyder
! OOPS! More work on 'deferred' spectrometers
!
! Revision 2.19  2001/04/11 19:54:00  vsnyder
! More work on 'deferred' spectrometers
!
! Revision 2.18  2001/04/11 18:31:04  vsnyder
! Change 'deferred' from boolean to numeric
!
! Revision 2.17  2001/04/10 23:20:05  livesey
! Added index field
!
! Revision 2.16  2001/04/10 17:59:53  vsnyder
! Remove sideband field from signal
!
! Revision 2.15  2001/04/09 20:30:46  vsnyder
! More work on MatchSignal
!
! Revision 2.14  2001/04/09 20:16:40  vsnyder
! Correct numChannelsMatch calculation
!
! Revision 2.13  2001/04/07 01:52:58  vsnyder
! Initial cut at MatchSignal
!
! Revision 2.12  2001/04/03 01:48:25  vsnyder
! No need to declare Make_Tree private -- It's internal!
!
! Revision 2.11  2001/03/29 23:52:31  vsnyder
! Added MaxSigLen parameter
!
! Revision 2.10  2001/03/28 19:51:58  vsnyder
! Remove "frequencies" and "widths" fields.  Use range instead in a "channels"
! field.  Put in units checking for every numeric field.
!
! Revision 2.9  2001/03/16 21:32:23  vsnyder
! Add 'Switches' test for dumping
!
! Revision 2.8  2001/03/16 02:10:32  vsnyder
! Put the sideband character in the correct place
!
! Revision 2.7  2001/03/16 01:54:47  vsnyder
! Use enumerated type instead of numbers for sideband; add a field for it
! in the "signal" spec.
!
! Revision 2.6  2001/03/16 00:30:49  vsnyder
! Make way for the pointing grid
!
! Revision 2.5  2001/03/15 21:02:07  vsnyder
! Cross-references between databases are by database index, not tree index
!
! Revision 2.4  2001/03/15 18:42:58  livesey
! Added GetSignal
!
! Revision 2.3  2001/03/15 18:39:42  vsnyder
! Periodic commit
!
! Revision 2.2  2001/03/14 23:44:47  vsnyder
! Correct a comment, other cosmetic changes in comments
!
! Revision 2.1  2001/03/14 02:05:52  vsnyder
! Moved MLSSignals_m to mlspgs/lib.
!
! Revision 2.11  2001/03/03 00:08:23  livesey
! Minor changes to module_t
!
! Revision 2.10  2001/03/02 01:29:31  livesey
! Added option of spacecraft module
!
! Revision 2.9  2001/02/28 21:44:21  livesey
! Moved back into L2, whoops!
!

! Tried to move this into lib, but failed, needs init_tables_module
! ----------------------------------------------------------
! Revision 2.7  2001/02/28 21:36:02  livesey
! Another plateau
!
! Revision 2.6  2001/02/28 01:16:11  livesey
! Interim version
!
! Revision 2.5  2001/02/27 01:28:34  vsnyder
! Rearranged a comment
!
! Revision 2.4  2001/02/27 00:23:48  livesey
! Very interim version
!
! Revision 2.3  2001/02/15 22:03:00  vsnyder
! Remove checking for ranges -- the type checker does it
!
@


2.115
log
@Remove USE statements and declarations for unused names.  Add OtherChannels
to call to displaySignalName in DisplaySignalName_index.  Remove Channels
pointer in Dump_Signals because it's not used.
@
text
@d27 1
a27 1
  use Output_M, only: Newline, Output
d54 1
a54 1
! Dump_All                            ...
d56 1
a56 1
! Dump_Modules                      ...
d58 1
d90 17
a106 17
  public :: ADDBANDTODATABASE, ADDMODULETODATABASE, ADDRADIOMETERTODATABASE
  public :: ADDSIGNALTODATABASE, ADDSPECTROMETERTYPETODATABASE, ARESIGNALSSUPERSET
  public :: DESTROYBANDDATABASE, DESTROYMODULEDATABASE
  public :: DESTROYRADIOMETERDATABASE, DESTROYSIGNAL, DESTROYSIGNALDATABASE
  public :: DESTROYSPECTROMETERTYPE, DESTROYSPECTROMETERTYPEDATABASE
  public :: DISPLAYRADIOMETER, DISPLAYSIGNALNAME
  public :: DISPLAYSIGNALNAME_INDEX, DISPLAYSIGNALNAME_SIGNAL
  public :: DUMP, DUMP_BANDS, DUMP_RADIOMETERS, DUMP_SIGNAL, DUMP_SIGNALS
  public :: DUMP_ALL, DUMP_MODULES, DUMP_SPECTROMETERTYPES
  public :: GETALLMODULES, GETBANDNAME, GETFIRSTCHANNEL, GETMODULEFROMRADIOMETER
  public :: GETMODULEINDEX, GETSIDEBANDLOOP, GETSIDEBANDSTARTSTOP, GETSIGNALINDEX
  public :: GETMODULEFROMSIGNAL, GETMODULENAME, GETNAMEOFSIGNAL
  public :: GETRADIOMETERFROMSIGNAL, GETRADIOMETERNAME, GETRADIOMETERINDEX
  public :: GETSIGNAL, GETSIGNALNAME, GETSPECTROMETERTYPENAME
  public :: ISSPACECRAFTAURA, ISANYMODULESPACECRAFT, ISMODULESPACECRAFT
  public :: MATCHSIGNAL, MATCHSIGNALPAIR, MLSSIGNALS
  public :: PVMPACKSIGNAL, PVMUNPACKSIGNAL
d121 3
a123 3
    module procedure DUMP_BANDS, DUMP_MODULES, DUMP_ONERADIOMETER, &
      & DUMP_RADIOMETERS, DUMP_SIGNAL, DUMP_SIGNALS, &
      & DUMP_SPECTROMETERTYPE, DUMP_SPECTROMETERTYPES
d208 2
a209 2
  type(module_T), public, save, pointer, dimension(:)  :: MODULES => NULL()   
  type(band_T), public, save, pointer, dimension(:)    :: BANDS => NULL()     
d211 1
a211 1
    &                                                  :: RADIOMETERS => NULL()
d213 1
a213 1
    &                                                  :: SPECTROMETERTYPES => NULL()
d218 3
a220 3
  type(signal_T), public, save, pointer, dimension(:)  :: SIGNALS => NULL()           
  integer, public, save                                :: INSTRUMENT = l_emls         
  integer, parameter                                   :: MAXRADIOMETERNAMELEN = 16   
d1071 1
a1071 1
    call dump_signals( signals )
d1146 1
a1146 1
  subroutine DUMP_SIGNAL ( SIGNAL, DETAILS, OtherChannels )
d1148 2
a1149 2
    logical, intent(in), optional :: Details ! false => don't dump frequencies
                                             ! default true.
d1152 1
a1152 1
    logical :: My_Details
d1154 1
a1154 1
    my_details = .true.
d1161 4
d1214 1
a1214 1
    if ( my_details ) then
d1234 1
a1234 1
  end subroutine DUMP_SIGNAL
d1237 1
a1237 1
  subroutine DUMP_SIGNALS ( Signals, isSignalCritical, Details, OtherChannels )
d1243 4
a1246 4
    character(len=*), parameter                 :: The80 = &
      & '12345678901234567890123456789012345678901234567890123456789012345678901234567890'
    character(len=*), parameter                 :: TheDecades = &
      & '         1         2         3         4         5         6         7         8'
d1253 11
a1263 3
    call output( The80, advance='yes' )
    call output( TheDecades, advance='yes' )
    ! Column headers: 3 lines
d1315 1
a1315 19
  end subroutine DUMP_SIGNALS

  subroutine DUMP_SIGNALS_old ( SIGNALS, DETAILS )
    type (signal_T), intent(in) :: SIGNALS(:)
    logical, intent(in), optional :: Details ! false => don't dump frequencies
    integer :: I
    call output ( 'SIGNALS: SIZE = ')
    call output ( size(signals), advance='yes' )
    do i = 1, size(signals)
      call output ( 'Signal ' )
      call output ( i )
      if ( signals(i)%name > 0 ) then
        call output ( ': ' )
      else
        call output ( '', advance='yes' )
      end if
      call dump ( signals(i), details )
    end do
  end subroutine DUMP_SIGNALS_old
d2159 1
a2159 1
       "$Id: MLSSignals_m.f90,v 2.114 2018/03/05 19:24:39 pwagner Exp $"
d2169 5
@


2.114
log
@Improved DUMP_SIGNALS
@
text
@a18 1
  use Dump_1, only: DumpLists
d27 1
a27 1
  use Output_M, only: Blanks, Newline, Output
a733 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a749 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a765 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a781 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a797 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d956 2
a957 1
    call displaySignalName ( signals(signal), advance, before, sideband, channel )
a1236 1
    logical, pointer                            :: Channels(:)
a1272 1
      channels => signals(i)%channels
d2164 1
a2164 1
       "$Id: MLSSignals_m.f90,v 2.113 2018/02/27 00:50:00 livesey Exp $"
d2174 3
@


2.113
log
@Added the supportedModule functionality to support A-SMLS
@
text
@d17 9
a25 9
  use Allocate_deallocate, only: allocate_test, deallocate_test
  use Dump_0, only: dump
  use Dump_1, only: dumpLists
  use Expr_m, only: expr
  use HighOutput, only: headLine, outputNamedValue, OutputTable
  use Init_MLSSignals_m ! everything
  use Intrinsic, only: field_first, field_indices, lit_indices, &
    & Phyq_dimensionless, phyq_frequency, phyq_indices, s_time, l_a, l_emls
  use MLSKinds, only: r8
d27 3
a29 3
  use MLSStrings, only: lowercase, capitalize
  use Output_m, only: blanks, newline, output
  use String_table, only: display_string, get_string
d234 7
a240 7
    use MLSStringLists, only: switchdetail
    use moreTree, only: get_boolean, get_label_and_spec, starterrormessage
    use next_tree_node_m, only: next_tree_node, next_tree_node_state
    use time_m, only: time_now
    use toggles, only: gen, levels, switches, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: decorate, decoration, nsons, sub_rosa, subtree
d1237 75
a1311 1
  subroutine DUMP_SIGNALS ( SIGNALS, DETAILS )
d1327 1
a1327 1
  end subroutine DUMP_SIGNALS
d2171 1
a2171 1
       "$Id: MLSSignals_m.f90,v 2.112 2017/09/15 15:44:18 livesey Exp $"
d2181 3
@


2.112
log
@Updated to allow modules to be defferred until signal definition
@
text
@d131 1
d135 10
d290 1
d340 1
d353 1
a353 1
          case ( f_instrument )
d357 2
d363 2
d705 2
d1092 1
a1092 1
    allocate( array(n+1, 3 ) )
d1096 1
d1101 6
d2097 1
a2097 1
       "$Id: MLSSignals_m.f90,v 2.111 2016/09/21 00:38:09 pwagner Exp $"
d2107 3
@


2.111
log
@Change appearance of Dump_Modules
@
text
@d277 2
d358 1
d391 1
d408 2
d435 11
a445 1
          signal%instrumentModule = radiometers(signal%radiometer)%instrumentModule
d684 4
d1097 7
a1103 3
    call output ( radiometer%instrumentModule )
    call output ( ' - ' )
    call display_string ( modules(radiometer%instrumentModule)%name, advance='yes' ) 
d2071 1
a2071 1
       "$Id: MLSSignals_m.f90,v 2.110 2016/07/27 22:14:59 pwagner Exp $"
d2081 3
@


2.110
log
@Added NameString component to module type
@
text
@d17 8
a24 7
  use allocate_deallocate, only: allocate_test, deallocate_test
  use dump_0, only: dump
  use expr_m, only: expr
  use highOutput, only: headLine, outputNamedValue
  use init_MLSSignals_m ! everything
  use intrinsic, only: field_first, field_indices, lit_indices, &
    & phyq_dimensionless, phyq_frequency, phyq_indices, s_time, l_a, l_emls
d28 2
a29 2
  use output_m, only: blanks, newline, output
  use string_table, only: display_string, get_string
d1033 1
a1033 1
    call dump_radiometers (radiometers )
d1042 1
d1044 2
d1051 10
a1060 14
    do i=1, size(modules)
      call output( i , advance='no' )
      call blanks( 3 )
      if ( len_trim(modules(i)%nameString) < 1 ) then
        call display_string ( modules(i)%name, advance='no' ) 
      else
        call output( trim(modules(i)%nameString) )
      endif
      call blanks( 3 )
      call output( 's/c? ', advance='no' )
      call output( modules(i)%spaceCraft, advance='no' ) 
      call blanks( 3 )
      call output( 'Aura? ', advance='no' )
      call output( modules(i)%Aura, advance='yes' ) 
d1062 4
d2047 1
a2047 1
       "$Id: MLSSignals_m.f90,v 2.109 2016/07/25 23:15:41 pwagner Exp $"
d2057 3
@


2.109
log
@Added IsAnyModuleSpacecraft function
@
text
@d20 1
a20 1
  use highOutput, only: headLine
d131 1
d1050 5
a1054 1
      call display_string ( modules(i)%name, advance='no' ) 
d1334 4
d1349 7
a1355 1
    call Get_String ( modules(instrumentModule)%name, string_text )
d2043 1
a2043 1
       "$Id: MLSSignals_m.f90,v 2.108 2015/03/28 01:18:43 vsnyder Exp $"
d2053 3
@


2.108
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d17 12
a28 12
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only: DUMP
  use EXPR_M, only: EXPR
  use HIGHOUTPUT, only: HEADLINE
  use INIT_MLSSIGNALS_M ! EVERYTHING
  use INTRINSIC, only: FIELD_FIRST, FIELD_INDICES, LIT_INDICES, &
    & PHYQ_DIMENSIONLESS, PHYQ_FREQUENCY, PHYQ_INDICES, S_TIME, L_A, L_EMLS
  use MLSKinds, only: R8
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, PVMERRORMESSAGE
  use MLSSTRINGS, only: LOWERCASE, CAPITALIZE
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT
  use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
d75 1
d102 2
a103 2
  public :: GETSIGNAL, GETSIGNALNAME
  public :: GETSPECTROMETERTYPENAME, ISSPACECRAFTAURA, ISMODULESPACECRAFT
d221 7
a227 7
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MORETREE, only: GET_BOOLEAN, Get_Label_And_Spec, STARTERRORMESSAGE
    use Next_Tree_Node_m, only: Next_Tree_Node, Next_Tree_Node_State
    use TIME_M, only: TIME_NOW
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATE, DECORATION, NSONS, SUB_ROSA, SUBTREE
d1699 11
d2028 1
a2028 1
       "$Id: MLSSignals_m.f90,v 2.107 2014/09/05 00:11:11 vsnyder Exp $"
d2038 3
@


2.107
log
@More complete and accurate allocate/deallocate size tracking.  Get
kinds from MLSKinds instead of MLSCommon.
@
text
@d693 1
d710 1
d727 1
d744 1
d761 1
d778 1
d780 1
d784 2
d787 1
a787 1
      call test_deallocate ( status, moduleName, 'Band database', s )
d796 1
d798 1
d802 2
d805 1
a805 1
      call test_deallocate ( status, moduleName, 'Modules database', s )
d813 1
d815 1
d819 2
d822 1
a822 1
      call test_deallocate ( status, moduleName, 'Radiometer database', s )
d853 1
d856 1
d865 2
d868 1
a868 1
      call test_deallocate ( status, moduleName, 'Signal database', s )
d886 1
d888 1
d895 2
d898 2
a899 1
      call test_deallocate ( status, moduleName, 'Spectrometer database', s )
d2016 1
a2016 1
       "$Id: MLSSignals_m.f90,v 2.106 2014/06/02 23:15:35 livesey Exp $"
d2026 4
@


2.106
log
@Fix bug with radiometer%singleSideband not being initialized
@
text
@d24 2
a25 3
  use MLSCOMMON, only: R8
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, &
    & MLSMSG_ERROR, PVMERRORMESSAGE
d691 3
d707 3
d723 3
d739 3
d755 3
d771 2
d774 1
a774 1
    integer :: Status
d776 1
d778 1
a778 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_DeAllocate // 'Band database' )
d780 1
d785 2
d788 1
a788 1
    integer :: Status
d790 1
d792 1
a792 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_DeAllocate // 'Module database' )
d798 2
d801 1
a801 1
    integer :: Status
d803 1
d805 1
a805 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_DeAllocate // 'Radiometer database' )
d834 2
d838 1
a838 1
    integer :: I, Status
d845 1
d847 1
a847 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_DeAllocate // 'Signal database' )
d863 2
d866 1
a866 1
    integer :: I, Status
d871 1
d873 1
a873 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_DeAllocate // 'Spectrometer database' )
d1990 1
a1990 1
       "$Id: MLSSignals_m.f90,v 2.105 2014/05/24 01:30:17 vsnyder Exp $"
d2000 3
@


2.105
log
@Calculate upper bound of frequencies and widths correctly
@
text
@d353 1
d1965 1
a1965 1
       "$Id: MLSSignals_m.f90,v 2.104 2014/02/07 02:28:06 vsnyder Exp $"
d1975 3
@


2.104
log
@Fail gracefully in case a database didn't get allocated due to prior
trouble.  Add more tracing at -g1 level.
@
text
@d520 1
a520 1
              & nsons(channels)-first, 'spectrometerType%frequencies', &
d523 1
a523 1
              & nsons(channels)-first, 'spectrometerType%widths', &
d1964 1
a1964 1
       "$Id: MLSSignals_m.f90,v 2.103 2014/01/11 01:41:02 vsnyder Exp $"
d1974 4
@


2.103
log
@Decruftification
@
text
@d225 1
a225 1
    use TOGGLES, only: GEN, SWITCHES, TOGGLE
d243 6
a248 1
    integer :: Me = -1                  ! Signal index for trace
d274 1
d289 2
d315 2
d319 2
d345 2
d349 2
d377 2
d381 2
d423 32
a454 25
        signal%lo = radiometers(signal%radiometer)%lo
        signal%instrumentModule = radiometers(signal%radiometer)%instrumentModule
        signal%spectrometerType = bands(signal%band)%spectrometerType
        signal%singleSideband = radiometers(signal%radiometer)%singleSideband
        signal%centerFrequency = bands(signal%band)%centerFrequency
        signal%deferred = spectrometerTypes(signal%spectrometerType)%deferred
        signal%dacs = spectrometerTypes(signal%spectrometerType)%dacs
        if ( signal%deferred .neqv. got(f_channels) ) &
          & call announceError ( deferredChannels )
        ! For the wide filters, we specify frequency etc. here.
        if ( got(f_channels) ) then
          if ( error == 0 ) then
            call allocate_Test ( signal%frequencies, nsons(channels)-1, &
              & 'signal%frequencies', moduleName )
            call allocate_Test ( signal%widths, nsons(channels)-1, &
              & 'signal%widths', moduleName)
            do k = 2, nsons(channels)
              call expr ( subtree(k,channels), units, value )
              signal%frequencies(k-1) = value(1)
              signal%widths(k-1) = value(2)
            end do
            if ( any(units /= phyq_frequency) ) &
              ! Front end should be checking units now, but just in case....
              & call announceError ( wrongUnits, f_channels, &
                & (/ phyq_frequency /) )
d456 2
d459 1
a459 3
          signal%frequencies => spectrometerTypes(signal%spectrometerType)% &
            & frequencies
          signal%widths => spectrometerTypes(signal%spectrometerType)%widths
a460 2
        call decorate ( key, addSignalToDatabase ( signals, signal ) )
        signals(size(signals))%index = size(signals)
d464 2
d468 2
d571 2
d652 3
d1964 1
a1964 1
       "$Id: MLSSignals_m.f90,v 2.102 2014/01/09 00:24:29 pwagner Exp $"
d1974 3
@


2.102
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d227 1
a227 2
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, &
      & SUB_ROSA, SUBTREE
d240 1
a240 1
    integer :: I, J, K                  ! Subscript and loop inductor.
d305 1
a305 1
        end do ! i = 2, nsons(key)
d359 1
a359 1
        end do ! i = 2, nsons(key)
d392 1
a392 1
        end do ! i = 2, nsons(key)
d484 1
a484 1
        end do ! i = 2, nsons(key)
d1930 1
a1930 1
       "$Id: MLSSignals_m.f90,v 2.101 2013/12/12 02:08:36 vsnyder Exp $"
d1940 3
@


2.101
log
@Use iterator to handle variables, and IF and SELECT constructs
@
text
@d20 1
d28 1
a28 1
  use OUTPUT_M, only: BLANKS, HEADLINE, NEWLINE, OUTPUT
d1931 1
a1931 1
       "$Id: MLSSignals_m.f90,v 2.100 2013/11/06 01:47:26 pwagner Exp $"
d1941 3
@


2.100
log
@May read instrument field of module; e.g. emls
@
text
@a219 1
    use EVALUATE_VARIABLE_M, only: EVALUATE_VARIABLE
d221 2
a222 1
    use MORETREE, only: GET_BOOLEAN, STARTERRORMESSAGE
a227 1
    use TREE_TYPES, only: N_NAMED, N_VARIABLE
d251 1
d273 4
a276 13
    do i = 2, nsons(root)-1 ! skip "MLSSignals" at "begin" and "end"
      son = subtree(i,root) ! A spec_args vertex now
      if ( node_id(son) == n_variable ) then
        call evaluate_variable ( son )
    cycle
      end if
      if ( node_id(son) == n_named ) then
        name = sub_rosa(subtree(1, son))
        key = subtree(2, son)
      else
        name = 0
        key = son
      end if
d1930 1
a1930 1
       "$Id: MLSSignals_m.f90,v 2.99 2013/10/09 01:08:03 vsnyder Exp $"
d1940 3
@


2.99
log
@Add call to Evaluate_Variable
@
text
@d27 1
a27 1
  use OUTPUT_M, only: BLANKS, HEADLINE, OUTPUT
d54 1
d96 1
a96 1
  public :: DUMP_MODULES, DUMP_SPECTROMETERTYPES
d194 6
a199 5
  type(module_T), public, save, pointer, dimension(:)     :: Modules => NULL()
  type(band_T), public, save, pointer, dimension(:)       :: Bands => NULL()
  type(radiometer_T), public, save, pointer, dimension(:) :: Radiometers => NULL()
  type(spectrometerType_T), public, save, pointer, dimension(:) ::&
    & SpectrometerTypes => NULL()
d204 3
a206 3
  type(signal_T), public, save, pointer, dimension(:)     :: Signals => NULL()
  integer, public, save :: Instrument = l_emls
  integer, parameter :: MAXRADIOMETERNAMELEN = 16
d220 1
a220 1
    use Evaluate_Variable_m, only: Evaluate_Variable
d228 1
a228 1
    use TREE_TYPES, only: N_NAMED, N_Variable
d333 2
d943 16
d1939 1
a1939 1
       "$Id: MLSSignals_m.f90,v 2.98 2013/08/30 03:56:02 vsnyder Exp $"
d1949 3
@


2.98
log
@Revise use of trace_begin and trace_end
@
text
@d218 1
d226 1
a226 1
    use TREE_TYPES, only: N_NAMED
d273 4
d1919 1
a1919 1
       "$Id: MLSSignals_m.f90,v 2.97 2013/08/23 23:27:48 pwagner Exp $"
d1929 3
@


2.97
log
@Added function to return whether or not s/c is Aura
@
text
@a25 1
  use MLSSTRINGLISTS, only: SWITCHDETAIL
a26 1
  use MORETREE, only: GET_BOOLEAN, STARTERRORMESSAGE
a28 6
  use TIME_M, only: TIME_NOW
  use TOGGLES, only: GEN, SWITCHES, TOGGLE
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, &
    & SUB_ROSA, SUBTREE
  use TREE_TYPES, only: N_NAMED
d217 10
d241 1
d269 1
a269 1
    if ( toggle(gen) ) call trace_begin ( "MLSSignals", root )
d565 1
a565 3
    if ( toggle(gen) ) then
      call trace_end ( "MLSSignals" )
    end if
d568 1
a568 1
    contains
d1914 1
a1914 1
       "$Id: MLSSignals_m.f90,v 2.96 2013/06/28 18:10:45 pwagner Exp $"
d1924 3
@


2.96
log
@Correct erroneous GetSignalIndex; do we ever need signal_T%name?
@
text
@d29 1
a29 1
  use OUTPUT_M, only: OUTPUT
d63 1
d83 1
d95 17
a111 17
  public :: AddBandToDatabase, AddModuleToDatabase, AddRadiometerToDatabase
  public :: AddSignalToDatabase, AddSpectrometerTypeToDatabase, AreSignalsSuperset
  public :: DestroyBandDatabase, DestroyModuleDatabase
  public :: DestroyRadiometerDatabase, DestroySignal, DestroySignalDatabase
  public :: DestroySpectrometerType, DestroySpectrometerTypeDatabase
  public :: DisplayRadiometer, DisplaySignalName
  public :: DisplaySignalName_index, DisplaySignalName_signal
  public :: Dump, Dump_Bands, Dump_Radiometers, Dump_Signal, Dump_Signals
  public :: Dump_Spectrometertypes
  public :: GetAllModules, GetBandName, GetFirstChannel, GetModuleFromRadiometer
  public :: GetModuleIndex, GetSidebandLoop, GetSidebandStartStop, GetSignalIndex
  public :: GetModuleFromSignal, GetModuleName, GetNameOfSignal
  public :: GetRadiometerFromSignal, GetRadiometerName, GetRadiometerIndex
  public :: GetSignal, GetSignalName
  public :: GetSpectrometerTypeName, IsModuleSpacecraft, MatchSignal
  public :: MatchSignalPair, MLSSignals
  public :: PVMPackSignal, PVMUnpackSignal
d126 3
a128 3
    module procedure Dump_Bands, Dump_OneRadiometer, Dump_Radiometers, &
      & Dump_Signal, Dump_Signals, &
      & Dump_SpectrometerType, Dump_SpectrometerTypes
d135 2
a136 1
    logical :: spaceCraft               ! Set if `module' is in fact s/c
d201 2
a202 2
  type(module_T), public, save, pointer, dimension(:) :: Modules => NULL()
  type(band_T), public, save, pointer, dimension(:) :: Bands => NULL()
d210 1
a210 1
  type(signal_T), public, save, pointer, dimension(:) :: Signals => NULL()
d321 2
d933 22
d1602 7
d1913 1
a1913 1
       "$Id: MLSSignals_m.f90,v 2.95 2013/06/12 02:12:23 vsnyder Exp $"
d1923 3
@


2.95
log
@Cruft removal
@
text
@d1226 1
a1226 1
      if ( signals(signal_index)%name > 0 ) then
d1230 4
d1879 1
a1879 1
       "$Id: MLSSignals_m.f90,v 2.94 2012/05/01 20:52:09 vsnyder Exp $"
d1889 3
@


2.94
log
@Remove unused assignment
@
text
@a1591 2
    logical :: MyDSBSSB
    integer :: MySideband               ! Either sideband or probe%sideband
a1594 6
    mySideband = probe%sideband
    if ( present(sideband) ) mySideband = sideband

    myDSBSSB = .false.
    if ( present(DSBSSB) ) myDSBSSB = DSBSSB

d1875 1
a1875 1
       "$Id: MLSSignals_m.f90,v 2.93 2011/06/02 19:22:35 pwagner Exp $"
d1885 3
@


2.93
log
@Fixed bug in getRadiometerIndex
@
text
@a503 1
            k = last - first 
d1883 1
a1883 1
       "$Id: MLSSignals_m.f90,v 2.92 2011/05/09 17:24:55 pwagner Exp $"
d1893 3
@


2.92
log
@Converted to using switchDetail
@
text
@d124 2
a125 1
    module procedure Dump_Bands, Dump_Radiometers, Dump_Signal, Dump_Signals, &
d209 1
d929 18
d956 1
a956 13
      call display_string (radiometers(i)%prefix)
      call output ( ':' )
      call display_string (radiometers(i)%suffix, advance='yes', strip=.true. )
      call output ( '   Polarization: ' )
      call display_string (lit_indices(radiometers(i)%polarization))
      call output ( '   Module: ')
      call output ( radiometers(i)%instrumentModule )
      call output ( ' - ' )
      call display_string ( modules(radiometers(i)%instrumentModule)%name, advance='yes' ) 
      call output ( '   LO: ')
      call output ( radiometers(i)%lo )
      call output ( '   Single sideband: ' )
      call output ( radiometers(i)%singleSideband, advance='yes' )
d1375 2
a1376 1
    ! Returns the index in the radiometer database, given radiometer name in mixed case
d1378 5
d1385 1
a1385 1
    character (len=*), intent(in) :: string_text
d1387 4
a1390 1
    character (len=len(string_text))             :: string_test
a1391 1
      radiometer = 0
d1395 1
d1397 3
a1399 2
        call Get_String ( radiometers(radiometer)%prefix, string_test )
        if ( LowerCase(trim(string_text)) == LowerCase(trim(string_test))) &
d1402 7
a1408 2
          & string_test(LEN_TRIM(string_test)+1:), cap=.true., strip=.true. )
        if ( LowerCase(trim(string_text)) == LowerCase(trim(string_test))) &
d1412 1
a1412 1
    radiometer = 0
d1884 1
a1884 1
       "$Id: MLSSignals_m.f90,v 2.91 2011/01/29 00:51:38 vsnyder Exp $"
d1894 3
@


2.91
log
@Add comments about units checking in front end
@
text
@d17 1
a17 1
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d19 18
a36 17
  use Expr_M, only: Expr
  use Init_MLSSignals_m ! Everything
  use Intrinsic, only: Field_First, Field_indices, Lit_Indices, &
    & PHYQ_Dimensionless, PHYQ_Frequency, PHYQ_Indices, S_Time, L_A, l_emls
  use MLSCommon, only: R8
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    & MLSMSG_Error, PVMErrorMessage
  use MLSStrings, only: LowerCase, Capitalize
  use MoreTree, only: Get_Boolean, StartErrorMessage
  use Output_M, only: Output
  use String_Table, only: Display_String, Get_String
  use Time_M, only: Time_Now
  use Toggles, only: Gen, Switches, Toggle
  use Trace_M, only: Trace_begin, Trace_end
  use Tree, only: Decorate, Decoration, Node_ID, Nsons, &
    & Sub_Rosa, Subtree
  use Tree_Types, only: N_named
d550 1
a550 1
    if ( index(switches, 'sig') /= 0 ) then
d1861 1
a1861 1
       "$Id: MLSSignals_m.f90,v 2.90 2010/02/04 23:08:00 vsnyder Exp $"
d1871 3
@


2.90
log
@Remove USE or declaration for unused names
@
text
@d286 1
d332 1
d340 1
d365 1
d371 1
d375 1
d414 1
d451 1
d460 1
d491 1
d1860 1
a1860 1
       "$Id: MLSSignals_m.f90,v 2.89 2009/10/26 17:08:02 pwagner Exp $"
d1870 3
@


2.89
log
@Added GetRadiometerIndex
@
text
@a22 1
  use Lexer_Core, only: Print_Source
d33 1
a33 1
  use Tree, only: Decorate, Decoration, Node_ID, Nsons, Source_Ref, &
d1850 1
a1850 1
       "$Id: MLSSignals_m.f90,v 2.88 2009/10/01 00:49:13 vsnyder Exp $"
d1860 3
@


2.88
log
@Add OtherSignals to DisplaySignalName_*
@
text
@d40 1
d75 1
d85 4
d105 2
a106 1
  public :: GetRadiometerFromSignal, GetRadiometerName, GetSignal, GetSignalName
d1355 27
d1851 1
a1851 1
       "$Id: MLSSignals_m.f90,v 2.87 2009/09/25 02:44:14 vsnyder Exp $"
d1861 3
@


2.87
log
@Added OtherChannels to dump and getSignalName routines to use specific
channels instead of the ones in the data structure (because sometimes
we have a signals database index plus channels from some other source)
@
text
@d28 1
a28 1
  use MoreTree, only: Get_Boolean
d34 2
a35 2
  use Tree, only: Decorate, Decoration, Node_ID, Nsons, Source_Ref, Sub_Rosa, &
    & Subtree
a551 1
      integer :: Source
d554 2
a555 4
      source = source_ref ( son )
      call output ( 'At ' )
      call print_source ( source )
      call output ( ' MLSSignals complained: ' )
d802 2
a803 1
  subroutine DisplaySignalName_index ( Signal, Advance, Before, Sideband, Channel )
d809 1
d814 2
a815 1
  subroutine DisplaySignalName_signal ( Signal, Advance, Before, Sideband, Channel )
d822 1
d824 1
d843 32
a874 28
    else if ( associated(signal%channels) ) then
      if ( .not. all(signal%channels) .or. &
        & lbound(signal%channels,1) /= lbound(signal%frequencies,1) .or. &
        & ubound(signal%channels,1) /= ubound(signal%frequencies,1) ) then
        first = .true.
        call output ( '.C' )
        i = lbound(signal%channels, 1)
oc:     do
          do
            if ( i > ubound(signal%channels, 1) ) exit oc
            if ( signal%channels(i) ) exit
            i = i + 1
          end do
          if ( .not. first ) call output ( '+' )
          first = .false.
          j = i
          do while ( j < ubound(signal%channels, 1) )
            if ( .not. signal%channels(j+1) ) exit
            j = j + 1
          end do
          if ( j > i ) then
            call output ( i, after = ':' )
            call output ( j )
          else
            call output ( i )
          end if
          i = j + 1
        end do oc
d940 1
a940 1
    logical, optional, pointer :: OtherChannels(:)
d946 2
d950 1
a950 1
    call displaySignalName ( signal )
a1013 2
    channels => signal%channels
    if ( present(otherChannels) ) channels => otherChannels
d1817 1
a1817 1
       "$Id: MLSSignals_m.f90,v 2.86 2009/06/23 18:25:42 pwagner Exp $"
d1827 5
@


2.86
log
@Prevent Intel from optimizing ident string away
@
text
@d204 1
a204 1
       "$RCSfile: $"
d930 1
a930 1
  subroutine DUMP_SIGNAL ( SIGNAL, DETAILS )
d934 2
d1006 3
a1008 1
    if (associated(signal%channels)) then
d1010 1
a1010 1
      call dump ( signal%channels, lbound=lbound(signal%channels,1) )
d1207 2
a1208 1
    & NoSwitch, NoSpectrometer, NoChannels, NoSuffix, sideband, channel )
d1220 2
d1225 1
d1279 2
d1286 4
a1289 4
      else if ( associated(signal%channels) ) then
        if ( .not. all(signal%channels) .or. &
          & lbound(signal%channels,1) /= lbound(signal%frequencies,1) .or. &
          & ubound(signal%channels,1) /= ubound(signal%frequencies,1) ) then
d1292 1
a1292 1
          i = lbound(signal%channels, 1)
d1296 2
a1297 2
              if ( i > ubound(signal%channels, 1) ) exit oc
              if ( signal%channels(i) ) exit
d1303 2
a1304 2
            do while ( j < ubound(signal%channels, 1) )
              if ( .not. signal%channels(j+1) ) exit
d1449 2
a1450 1
    & NoSwitch, NoSpectrometer, NoChannels, NoSuffix, Sideband, Channel )
d1463 2
d1467 2
a1468 1
      & noSwitch, noSpectrometer, noChannels, noSuffix, sideband, channel )
d1811 1
a1811 1
       "$Id: read_apriori.f90 is it here $"
d1821 3
@


2.85
log
@Add PRINT statement in Not_Used_Here to reduce compilation cascades
@
text
@d204 1
a204 1
       "$RCSfile: MLSSignals_m.f90,v $"
d1794 1
a1795 1
!---------------------------- RCS Ident Info -------------------------------
d1797 2
a1798 3
       "$Id: MLSSignals_m.f90,v 2.84 2008/09/29 22:55:17 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1800 1
a1800 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1802 1
d1807 3
@


2.84
log
@Add DisplayRadiometer subroutine
@
text
@d1797 1
a1797 1
       "$Id: MLSSignals_m.f90,v 2.83 2007/05/22 02:28:28 vsnyder Exp $"
d1801 1
d1807 3
@


2.83
log
@Don't use list-directed formatting for internal writes.  The standard
allows a processor to insert any number of blanks it wishes, which might
overflow the length of the internal file.
@
text
@d56 1
d92 2
a93 1
  public :: DisplaySignalName, DisplaySignalName_index, DisplaySignalName_signal
d796 8
d832 1
a832 3
    call display_string ( radiometers(signal%radiometer)%prefix )
    call output ( ':' )
    call display_string ( radiometers(signal%radiometer)%suffix, strip=.true. )
d1797 1
a1797 1
       "$Id: MLSSignals_m.f90,v 2.82 2007/04/26 20:30:53 pwagner Exp $"
d1806 5
@


2.82
log
@Bugfix for way ifc writes ints to strings
@
text
@d1214 1
a1214 2
    ! character (len=8) :: word
    character (len=16) :: word
d1266 1
a1266 1
        write ( word, * ) channel
d1290 1
a1290 1
              write ( word, * ) i
d1293 1
a1293 1
              write ( word, * ) j
d1296 1
a1296 1
              write ( word, * ) i
d1789 1
a1789 1
       "$Id: MLSSignals_m.f90,v 2.81 2006/04/20 01:07:57 vsnyder Exp $"
d1798 3
@


2.81
log
@Display a signal name given either a signal structure or an index
@
text
@d1214 2
a1215 1
    character (len=8) :: word
d1790 1
a1790 1
       "$Id: MLSSignals_m.f90,v 2.80 2005/06/22 17:25:50 pwagner Exp $"
d1799 3
@


2.80
log
@Reworded Copyright statement, moved rcs id
@
text
@d57 2
d91 1
a91 1
  public :: DisplaySignalName
d104 4
d202 1
a202 1
       "$RCSfile: $"
d794 12
a805 2
  ! ------------------------------------------  DisplaySignalName  -----
  subroutine DisplaySignalName ( Signal, Advance, Before, Sideband, Channel )
d864 1
a864 1
  end subroutine DisplaySignalName
d1789 1
a1789 1
       "$Id: $"
d1798 3
@


2.79
log
@Add Before, Sideband and Channel arguments for Display_Signal_Name
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d194 3
a196 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
    & "$Id: MLSSignals_m.f90,v 2.78 2005/03/15 23:48:55 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter, private :: ModuleName = &
    & "$RCSfile: MLSSignals_m.f90,v $"
d198 1
a198 1
  !---------------------------------------------------------------------------
d1771 5
d1782 3
@


2.78
log
@PVMERRORMESSAGE now part of MLSMessageModule
@
text
@d188 1
a188 1
    & "$Id: MLSSignals_m.f90,v 2.77 2005/01/12 03:07:37 vsnyder Exp $"
d784 1
a784 1
  subroutine DisplaySignalName ( Signal, Advance )
d788 3
a790 1
    character(len=*), intent(in), optional :: Advance
d793 1
a793 1
    integer :: I, J
d795 6
d805 1
a805 1
    call GetBandName ( signal%band, bandName, sideband=signal%sideband )
d810 3
a812 1
    if ( associated(signal%channels) ) then
d1772 3
@


2.77
log
@Added CHANNEL argument to GetNameOfSignal and GetSignalName
@
text
@d1 2
a2 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d18 1
a18 1
    & MLSMSG_Error
d188 1
a188 1
    & "$Id: MLSSignals_m.f90,v 2.76 2004/10/30 00:24:34 vsnyder Exp $"
a1645 1
    use PVM, only: PVMErrorMessage
a1694 1
    use PVM, only: PVMErrorMessage
d1762 3
@


2.76
log
@Add GetSidebandStartStop
@
text
@d188 1
a188 1
    & "$Id: MLSSignals_m.f90,v 2.75 2004/10/06 21:16:26 vsnyder Exp $"
d1164 1
a1164 1
    & NoSwitch, NoSpectrometer, NoChannels, NoSuffix, sideband )
d1175 1
d1231 2
a1232 4
    if ( .not. my_noChannels .and. associated(signal%channels) ) then
      if ( .not. all(signal%channels) .or. &
        & lbound(signal%channels,1) /= lbound(signal%frequencies,1) .or. &
        & ubound(signal%channels,1) /= ubound(signal%frequencies,1) ) then
d1235 36
a1270 27
        i = lbound(signal%channels, 1)
        first = .true.
        oc: do
          do
            if ( i > ubound(signal%channels, 1) ) exit oc
            if ( signal%channels(i) ) exit
            i = i + 1
          end do
          if ( .not. first ) call addToSignalString ( '+' )
          first = .false.
          j = i
          do while ( j < ubound(signal%channels, 1) )
            if ( .not. signal%channels(j+1) ) exit
            j = j + 1
          end do
          if ( j > i ) then
            write ( word, * ) i
            call addToSignalString ( word )
            call addToSignalString ( ':' )
            write ( word, * ) j
            call addToSignalString ( word )
          else
            write ( word, * ) i
            call addToSignalString ( word )
          end if
          i = j + 1
        end do oc
d1400 1
a1400 1
    & NoSwitch, NoSpectrometer, NoChannels, NoSuffix, SIDEBAND )
d1412 1
d1415 1
a1415 1
      & noSwitch, noSpectrometer, noChannels, noSuffix, sideband )
d1764 3
@


2.75
log
@Add MatchSignalPair, use it for MatchSignals
@
text
@d63 1
d85 1
a85 1
  public :: GetModuleIndex, GetSidebandLoop, GetSignalIndex
d188 1
a188 1
    & "$Id: MLSSignals_m.f90,v 2.74 2004/08/03 21:49:05 vsnyder Exp $"
d1311 1
a1311 1
  ! --------------------------------------------------- GetSidebandLoop --
d1314 2
a1315 1
    ! This routine gets the loop limits for a loop over sidebands
d1347 36
a1382 1
  ! --------------------------------------------------- GetSignal ------
d1755 3
@


2.74
log
@Inching toward PFA
@
text
@d69 1
d87 2
a88 1
  public :: GetSpectrometerTypeName, IsModuleSpacecraft, MatchSignal, MLSSignals
d93 4
d187 1
a187 1
    & "$Id: MLSSignals_m.f90,v 2.73 2004/07/23 19:48:12 vsnyder Exp $"
d1400 2
a1401 2
  ! ------------------------------------------------  MatchSignal  -----
  integer function MatchSignal ( Signals, Probe, sideband, channel, matchFlags, &
a1419 1
    logical :: Match                    ! Channels in probe are in signal
a1422 1
    logical :: SidebandOK
d1433 1
a1433 1
    matchSignal = 0
d1435 65
a1499 13
      ! First, the signal must have the same band, instrument module,
      ! radiometer, spectrometer, spectrometer type and switch number as
      ! the probe signal
      sidebandOK = (signals(i)%sideband == mySideband) .or. &
        &          myDSBSSB .and. (signals(i)%sideband * mySideband == 0)
      if ( signals(i)%band /= probe%band .or. &
        &  signals(i)%instrumentModule /= probe%instrumentModule.or. &
        &  signals(i)%radiometer /= probe%radiometer .or. &
        &  .not. sidebandOK .or. &
        &  signals(i)%spectrometer /= probe%spectrometer .or. &
        &  signals(i)%spectrometerType /= probe%spectrometerType .or. &
        &  signals(i)%switch /= probe%switch ) cycle
      ! Now the channels in Probe all have to be present in Signals(i)
d1501 2
a1502 2
        if ( associated(signals(i)%channels) ) then
          if ( channel < lbound(signals(i)%channels,1) ) then
d1504 1
a1504 1
          else if ( channel > ubound(signals(i)%channels,1) ) then
d1507 1
a1507 1
            match = signals(i)%channels(channel)
d1514 1
a1514 1
          & (.not. associated(signals(i)%channels) )
d1516 1
a1516 1
          & signals(i)%channels(lbound(probe%channels,1):ubound(probe%channels,1)) ) &
d1520 2
a1521 3
        if ( present( matchFlags ) ) matchFlags(i) = .true.
        if ( associated(signals(i)%channels) ) then
          numChannelsMatch = count(signals(i)%channels)
d1523 1
a1523 5
          numChannelsMatch = size( signals(i)%frequencies )
        end if
        if ( numChannelsMatch < bestMatch ) then
          matchSignal = i
          bestMatch = numChannelsMatch
d1526 9
a1534 9
      if ( present(noMatchFails) ) then
        if ( noMatchFails .and. matchSignal == 0 ) then
          if ( present(fromWhere) ) then
            call MLSMessage ( MLSMSG_Error, moduleName, &
              & 'No match for requested signal from ' // trim(fromWhere) )
          else
            call MLSMessage ( MLSMSG_Error, moduleName, &
              & 'No match for requested signal' )
          end if
d1537 2
a1538 2
    end do
  end function MatchSignal
d1718 3
@


2.73
log
@Some cannonball polishing
@
text
@d181 1
a181 1
    & "$Id: MLSSignals_m.f90,v 2.72 2004/07/23 18:35:17 vsnyder Exp $"
d1396 1
a1396 1
    & NoMatchFails, FromWhere )
d1410 1
d1416 3
a1418 1
    integer :: mySideband               ! Either sideband or probe%sideband
d1422 5
a1426 5
    if ( present(sideband) ) then
      mySideband = sideband
    else
      mySideband = probe%sideband
    end if
d1434 2
d1439 1
a1439 1
        &  signals(i)%sideband /= mySideband .or. &
d1667 3
@


2.72
log
@Dump low bound of channels array
@
text
@d181 1
a181 1
    & "$Id: MLSSignals_m.f90,v 2.71 2004/05/29 02:45:28 vsnyder Exp $"
d887 1
d893 2
d914 1
a914 1
    call output ( signal%lo, advance='yes')
d925 1
a925 1
    call output ( signal%centerFrequency, advance='yes')
d945 2
a946 2
      call output ( '   Frequencies' )
      if ( signal%deferred ) call output ( '(deferred)' )
d1662 3
@


2.71
log
@Add DisplaySignalName, fix a bug in GetNameOfSignal
@
text
@d13 1
a13 1
  use Intrinsic, only: Field_First, Field_indices, &
d181 1
a181 1
    & "$Id: MLSSignals_m.f90,v 2.70 2004/05/01 04:07:44 vsnyder Exp $"
d870 2
a871 2
      call output ( '   Polarization:' )
      call display_string (radiometers(i)%polarization)
d957 1
a957 1
      call dump( signal%channels )
d1659 3
@


2.70
log
@Rearranged some dumping stuff
@
text
@d48 1
d78 3
a80 2
  public :: DestroySpectrometerType, DestroySpectrometerTypeDatabase, Dump
  public :: Dump_Bands, Dump_Radiometers, Dump_Signal, Dump_Signals
d181 1
a181 1
    & "$Id: MLSSignals_m.f90,v 2.69 2004/04/16 00:44:24 livesey Exp $"
d776 52
d1221 3
a1223 1
      if ( .not. all(signal%channels) ) then
d1659 3
@


2.69
log
@Added GetFirstChannel
@
text
@d78 2
a79 1
  public :: Dump_Bands, Dump_Radiometers, Dump_Signals, Dump_Spectrometertypes
d92 1
a92 1
    module procedure Dump_Bands, Dump_Radiometers, Dump_Signals, &
d179 1
a179 1
    & "$Id: MLSSignals_m.f90,v 2.68 2004/03/24 23:08:58 livesey Exp $"
d829 80
a913 4
    logical :: My_Details
    character (len=80) :: Str
    my_details = .true.
    if ( present(details) ) my_details = details
a920 1
        call display_string ( signals(i)%name, advance='yes' )
d924 1
a924 69
      call output ( '   Module: ')
      call output ( signals(i)%instrumentModule )
      call output ( ' - ' )
      if ( associated(modules) ) then
        call display_string ( modules(signals(i)%instrumentModule)%name, &
          & advance='yes' )
      else
        call output ( 'Cannot get module name', advance='yes' )
      end if
      call output ( '   Radiometer: ')
      call output ( signals(i)%radiometer )
      call output ( ' - ' )
      if ( associated(radiometers) ) then
        call getRadiometerName ( signals(i)%radiometer, str )
        call output ( TRIM(str) )
      else
        call output ( 'Cannot get radiometer name', advance='yes' )
      end if
      call output ( '   First LO: ')
      call output ( signals(i)%lo, advance='yes')
      call output ( '   Band: ')
      call output ( signals(i)%band )
      call output (' - ')
      if ( associated(bands) ) then
        call getBandName ( signals(i)%band, str )
        call output ( TRIM(str) )
      else
        call output ( 'Cannot get band name', advance='yes' )
      end if
      call output ( '   Band center frequency: ')
      call output ( signals(i)%centerFrequency, advance='yes')
      call output ( '   SpectrometerType: ')
      call output ( signals(i)%spectrometerType )
      call output ( ' - ' )
      if ( associated(spectrometerTypes) ) then
        call display_string ( spectrometerTypes(signals(i)%spectrometerType)%name )
      else
        call output ( 'Cannot get spectrometer type name', advance='yes' )
      end if
      call output ( '   DACS?: ' )
      call output ( signals(i)%dacs )
      call output ( '   Channels: ' )
      call output ( lbound(signals(i)%frequencies,1), 3 )
      call output ( ':' )
      call output ( ubound(signals(i)%frequencies,1), 3, advance='yes' )
      call output ( '   Sideband: ' )
      call output ( signals(i)%sideband )
      call output ( '   Single Sideband: ' )
      call output ( signals(i)%singleSideband, advance='yes')
      if ( my_details ) then
        call output ( '   Frequencies' )
        if ( signals(i)%deferred ) call output ( '(deferred)' )
        call output ( ':', advance='yes' )
        call dump ( signals(i)%frequencies )
        call output ( '   Widths' )
        if ( signals(i)%deferred ) call output ( '(deferred)' )
        call output ( ':', advance='yes' )
        call dump ( signals(i)%widths )
      else
        call output ( '   Frequencies and widths are' )
        if ( .not. signals(i)%deferred ) call output ( ' not' )
        call output ( ' deferred', advance='yes' )
      end if ! my_details
      if (associated(signals(i)%channels)) then
        call output ( '   Channel Flags:', advance='yes' )
        call dump( signals(i)%channels )
      else
        call output ( '   All channels selected', advance='yes' )
      end if
d1603 3
@


2.68
log
@Bug fix in getBandName
@
text
@d79 1
a79 1
  public :: GetAllModules, GetBandName, GetModuleFromRadiometer
d178 1
a178 1
    & "$Id: MLSSignals_m.f90,v 2.67 2004/03/24 01:02:17 livesey Exp $"
d1015 6
d1595 3
@


2.67
log
@Slight change in GetBandName to make smls stuff easier.
@
text
@d178 1
a178 1
    & "$Id: MLSSignals_m.f90,v 2.66 2004/03/22 18:22:59 livesey Exp $"
d998 1
a998 1
      if ( index ( '0123456789', string_text(endOfFirstNumber:endOfFirstNumber) ) /= 0 ) &
d1004 2
a1005 2
    string_text = string_text(1:endOfFirstNumber) // TRIM(sb_char) // &
      & string_text(endOfFirstNumber+1:LEN_TRIM(string_text))
d1589 3
@


2.66
log
@Bug fixes, only relevant for smls
@
text
@d178 1
a178 1
    & "$Id: MLSSignals_m.f90,v 2.65 2004/02/11 02:24:18 livesey Exp $"
d980 2
d996 10
a1005 2
    string_text = string_text(1:LEN_TRIM(string_text)-1) // TRIM(sb_char) // &
      & string_text(LEN_TRIM(string_text):LEN_TRIM(string_text))
d1589 3
@


2.65
log
@Added (probably unnecessary) initialization for DACS in
SpectromterType_T
@
text
@d178 1
a178 1
    & "$Id: MLSSignals_m.f90,v 2.64 2004/01/28 02:10:07 vsnyder Exp $"
d249 1
d463 1
a463 1
            call allocate_Test ( spectrometerType%frequencies, k-first, &
d465 1
a465 1
            call allocate_Test ( spectrometerType%widths, k-first, &
d786 7
a792 3
      call output ( bands(i)%radiometer )
      call output ( ' - ' )
      call display_string ( radiometers(bands(i)%radiometer)%prefix )
d1579 4
@


2.64
log
@Polish up some dump routines, other cosmetics
@
text
@d131 1
a131 1
    logical :: DACS                     ! Set if this spectrometer is a DACS
d178 1
a178 1
    & "$Id: MLSSignals_m.f90,v 2.63 2004/01/28 01:17:36 vsnyder Exp $"
d1574 3
@


2.63
log
@Do spectrometerType%dacs = dacs BEFORE putting spectrometerType in the database
@
text
@d178 1
a178 1
    & "$Id: MLSSignals_m.f90,v 2.62 2004/01/16 21:36:28 livesey Exp $"
a245 1

a269 1

a291 1

a317 1

d355 1
a355 1
        endif
d772 1
a772 1
  ! --------------------------------------------------  DumpBands  -----
d779 1
a779 1
      call output ( i, 2 )
d783 1
a783 1
      call display_string (bands(i)%suffix, advance='yes', strip=.true. )
d794 1
a794 1
      call output ( bands(i)%centerFrequency )
d823 1
a823 1
  ! ------------------------------------------------  DumpSignals  -----
d897 1
a897 1
        call output ( '   Widths:' )
d937 3
a939 1
      call output ('   Frequencies and widths deferred.', advance='yes' )
d996 1
a996 1
    endif
d1026 1
a1026 1
    endif
d1032 2
a1033 2
      endif
    enddo
d1058 1
a1058 1
    endif
d1064 2
a1065 2
      endif
    enddo
d1212 1
a1212 1
    endif
d1238 1
a1238 1
        endif
d1307 2
a1308 1
  integer function MatchSignal ( Signals, Probe, sideband, channel, matchFlags )
d1319 3
a1321 1
    integer, intent(in), optional :: CHANNEL ! Just this channel
d1362 1
a1362 1
        endif
d1369 1
a1369 1
      endif
d1376 1
a1376 1
        endif
d1382 11
d1574 3
@


2.62
log
@Added the ability to defer the connection between bands and radiometers
until you define the signal.  This is to support some SMLS related
research work.
@
text
@d92 1
a92 1
      & Dump_SpectrometerTypes
d178 1
a178 1
    & "$Id: MLSSignals_m.f90,v 2.61 2003/08/16 01:14:03 vsnyder Exp $"
d489 1
a491 1
        spectrometerType%dacs = dacs
d886 2
d893 1
a893 1
      call output ( signals(i)%sideband, advance='yes')
d919 28
a946 1
  ! --------------------------------------  DumpSpectrometerTypes  -----
d953 1
a953 16
      call output ( i,1 )
      call output ( ': ')
      call display_string ( spectrometerTypes(i)%name, advance='yes' )
      if ( associated(spectrometerTypes(i)%frequencies) ) then
        call output ( '  Channels: ' )
        call output ( lbound(spectrometerTypes(i)%frequencies,1), 3 )
        call output ( ':' )
        call output ( ubound(spectrometerTypes(i)%frequencies,1), 3, &
          & advance='yes' )
        call output ( '  Frequencies:', advance='yes' )
        call dump ( spectrometerTypes(i)%frequencies )
        call output ( '  Widths:', advance='yes' )
        call dump ( spectrometerTypes(i)%widths )
      else
        call output ('   Frequencies and widths deferred.', advance='yes' )
      end if
d1562 5
@


2.61
log
@Add optional 'polarization' field to 'radiometer' spec
@
text
@d118 1
a118 1
    integer :: Radiometer               ! Index in Radiometers database
d178 1
a178 1
    & "$Id: MLSSignals_m.f90,v 2.60 2003/07/23 21:51:36 pwagner Exp $"
d226 2
d324 1
d338 2
d351 9
a359 2
        ! Set default values for remaining parameters
        signal%radiometer = bands(signal%band)%radiometer
d586 4
d1548 3
@


2.60
log
@Tried to fix problem with lower case dacs
@
text
@d14 1
a14 1
    & PHYQ_Dimensionless, PHYQ_Frequency, PHYQ_Indices, S_Time, l_emls
d107 1
d178 1
a178 1
    & "$Id: MLSSignals_m.f90,v 2.59 2003/07/23 18:04:32 livesey Exp $"
d294 1
a303 2
          case ( f_suffix )
            radiometer%suffix = sub_rosa(gson)
d306 2
d311 2
d798 2
d1532 3
@


2.59
log
@Ensure that the spectrometer names are capitalized when outputing them.
@
text
@d177 1
a177 1
    & "$Id: MLSSignals_m.f90,v 2.58 2003/07/18 20:23:34 livesey Exp $"
d1262 1
d1526 3
@


2.58
log
@Added DACS flag
@
text
@d19 1
a19 1
  use MLSStrings, only: LowerCase
d177 1
a177 1
    & "$Id: MLSSignals_m.f90,v 2.57 2003/05/16 02:44:18 vsnyder Exp $"
d1259 1
a1259 1
    word = adjustl(word)
d1525 3
@


2.57
log
@Removed USE's for unreferenced symbols
@
text
@d130 1
d146 1
d177 1
a177 1
    & "$Id: MLSSignals_m.f90,v 2.56 2003/05/10 22:21:12 livesey Exp $"
d193 1
d350 1
d383 1
d399 2
d475 1
d1525 3
@


2.56
log
@Tried to calm down -g1..
@
text
@d24 1
a24 1
  use Toggles, only: Gen, Levels, Switches, Toggle
d28 1
a28 1
  use Tree_Types, only: N_named, N_Set_One
d175 1
a175 1
    & "$Id: MLSSignals_m.f90,v 2.55 2003/03/07 03:17:50 livesey Exp $"
d1517 3
@


2.55
log
@Add optional justchannels argument to DestroySignalDatabase
@
text
@d175 1
a175 1
    & "$Id: MLSSignals_m.f90,v 2.54 2002/10/08 17:42:10 livesey Exp $"
d489 6
a495 6
      if ( levels(gen) > 0 .or. index(switches, 'S') /= 0 ) then
        call dump ( radiometers )
        call dump ( spectrometerTypes )
        call dump ( bands )
        call dump ( signals )
      end if
d1517 3
@


2.54
log
@Bug fixes in pack/unpack
@
text
@d175 1
a175 1
    & "$Id: MLSSignals_m.f90,v 2.53 2002/10/08 00:09:12 pwagner Exp $"
d708 1
a708 1
  subroutine DestroySignalDatabase ( Signals )
d710 1
d716 1
a716 1
        call destroySignal ( signals(i) )
d1517 3
@


2.53
log
@Added idents to survive zealous Lahey optimizer
@
text
@d175 1
a175 1
    & "$Id: MLSSignals_m.f90,v 2.52 2002/10/05 00:40:28 livesey Exp $"
d1420 1
a1420 1
      if ( info /= 0 ) call PVMIDLPack ( signal%frequencies, info )
d1424 1
a1424 1
    if ( info /= 0 ) call PVMErrorMessage ( info, 'Packing signal frequencies' )
d1428 1
a1428 1
      if ( info /= 0 ) call PVMIDLPack ( signal%widths, info )
d1436 1
a1436 1
      if ( info /= 0 ) call PVMIDLPack ( signal%channels, info )
d1516 3
@


2.52
log
@Added pvm packing and unpacking of signals, and deep option on destroy
@
text
@d175 1
a175 1
    & "$Id: MLSSignals_m.f90,v 2.51 2002/10/03 05:38:11 livesey Exp $"
d179 1
d1509 4
d1516 3
@


2.51
log
@Infinite loop fix
@
text
@d84 1
d175 1
a175 1
    & "$Id: MLSSignals_m.f90,v 2.50 2002/09/05 20:27:39 livesey Exp $"
d1394 114
d1511 3
@


2.50
log
@Got rid of print statement left over from long ago.
@
text
@d174 1
a174 1
    & "$Id: MLSSignals_m.f90,v 2.49 2002/07/17 06:00:40 livesey Exp $"
d1109 1
d1396 3
@


2.49
log
@Added GetSidebandLoop routine
@
text
@d174 1
a174 1
    & "$Id: MLSSignals_m.f90,v 2.48 2002/05/15 17:29:48 livesey Exp $"
a1107 1
            print*,j
d1395 3
@


2.48
log
@Fixed channels related bug in MatchSignal
@
text
@d80 1
a80 1
  public :: GetModuleIndex, GetSignalIndex
d174 1
a174 1
    & "$Id: MLSSignals_m.f90,v 2.47 2002/05/14 22:31:59 livesey Exp $"
d1171 35
d1396 3
@


2.47
log
@Added singleSideband
@
text
@d174 1
a174 1
    & "$Id: MLSSignals_m.f90,v 2.46 2002/05/03 22:38:41 livesey Exp $"
d1269 7
a1275 1
          match = signals(i)%channels(channel)
d1361 3
@


2.46
log
@Added direction field to bands.
@
text
@d108 1
d151 1
d174 1
a174 1
    & "$Id: MLSSignals_m.f90,v 2.45 2002/02/14 23:00:45 livesey Exp $"
d301 3
d342 1
d788 3
a790 1
      call output ( radiometers(i)%lo,advance='yes' )
d859 2
d1355 3
@


2.46.2.1
log
@*** empty log message ***
@
text
@a107 1
    integer :: SingleSideband           ! +/-1 indicates indicates single sideband 0 folded
a149 1
    integer :: SingleSideband           ! Indicates only sideband for this radiometer
d172 1
a172 1
    & "$Id: MLSSignals_m.f90,v 2.48 2002/05/15 17:29:48 livesey Exp $"
a298 3
          case ( f_singlesideband )
            call expr_check ( gson, units, value, field, phyq_dimensionless )
            radiometer%singleSideband = nint ( value(1) )
a336 1
        signal%singleSideband = radiometers(signal%radiometer)%singleSideband
d782 1
a782 3
      call output ( radiometers(i)%lo )
      call output ( '   Single sideband: ' )
      call output ( radiometers(i)%singleSideband, advance='yes' )
a850 2
      call output ( '   Single Sideband: ' )
      call output ( signals(i)%singleSideband, advance='yes')
d1259 1
a1259 7
          if ( channel < lbound(signals(i)%channels,1) ) then
            match = .false.
          else if ( channel > ubound(signals(i)%channels,1) ) then
            match = .false.
          else
            match = signals(i)%channels(channel)
          end if
a1344 9
! Revision 2.48  2002/05/15 17:29:48  livesey
! Fixed channels related bug in MatchSignal
!
! Revision 2.47  2002/05/14 22:31:59  livesey
! Added singleSideband
!
! Revision 2.46  2002/05/03 22:38:41  livesey
! Added direction field to bands.
!
@


2.45
log
@Added justChannels optional argument to destroySignal
@
text
@d144 1
d172 1
a172 1
    & "$Id: MLSSignals_m.f90,v 2.44 2002/02/14 18:37:40 livesey Exp $"
d318 3
a367 1

d421 1
a421 1
              spectrometerType%frequencies(k-2+first) = value(1)
d1345 3
@


2.44
log
@Big fix for AreSignalsSuperset
@
text
@d171 1
a171 1
    & "$Id: MLSSignals_m.f90,v 2.43 2002/02/13 23:57:34 livesey Exp $"
d674 1
a674 1
  subroutine DestroySignal ( Signal )
d676 4
a679 1
    type(signal_T), intent(inout) :: Signal
d681 4
d689 1
a689 1
    if ( signal%deferred ) then
d1342 3
@


2.43
log
@Tidied up a bit.  Channels doesn't need to be set for
defered signals.  Made getSignalName skip channels field
if appropriate.  However, possible bug lurking in channel
printing loop.
@
text
@d171 1
a171 1
    & "$Id: MLSSignals_m.f90,v 2.42 2001/11/09 23:14:08 vsnyder Exp $"
a1305 1

d1307 2
a1308 2
      if ( associated(probe(i)%channels ) ) then
        noPbChannels = noPbChannels + count( probe(i)%channels )
d1310 5
a1314 1
        noPbChannels = noPbChannels + size ( probe(i)%frequencies )
a1316 1
  
d1335 6
@


2.42
log
@Use Time_Now instead of CPU_TIME
@
text
@d113 1
a113 1
    real(r8) :: CenterFrequency         ! Negative if not present (wide filter)
d171 1
a171 1
    & "$Id: MLSSignals_m.f90,v 2.41 2001/10/12 23:07:23 pwagner Exp $"
d238 1
a238 1
        band%centerFrequency = -1.0_r8 ! "The 'frequency' field is absent"
a343 2
            call allocate_Test ( signal%channels, nsons(channels)-1, &
              & 'signal%channels', moduleName)
a351 1
            signal%channels = .true.
a360 1
        nullify ( signal%channels )
d1073 31
a1103 28
      l = len_trim(string_text)
      call addToSignalString ( '.C' )
      i = lbound(signal%channels, 1)
      first = .true.
oc:   do
        do
          if ( i > ubound(signal%channels, 1) ) exit oc
          if ( signal%channels(i) ) exit
          i = i + 1
        end do
        if ( .not. first ) call addToSignalString ( '+' )
        first = .false.
        j = i
        do while ( j < ubound(signal%channels, 1) )
          if ( .not. signal%channels(j+1) ) exit
        end do
        if ( j > i ) then
          write ( word, * ) i
          call addToSignalString ( word )
          call addToSignalString ( ':' )
          write ( word, * ) j
          call addToSignalString ( word )
        else
          write ( word, * ) i
          call addToSignalString ( word )
        end if
        i = j + 1
      end do oc
d1333 3
@


2.41
log
@Added two inverse functions to signal (module) indexes
@
text
@d23 1
d171 1
a171 1
    & "$Id: MLSSignals_m.f90,v 2.40 2001/09/17 22:53:46 livesey Exp $"
d470 1
a470 1
          call cpu_time ( t1 )
d571 1
a571 1
      call cpu_time ( t2 )
d1334 3
@


2.40
log
@Added Instrument variable
@
text
@d19 1
d31 38
d79 1
d170 1
a170 1
    & "$Id: MLSSignals_m.f90,v 2.39 2001/05/16 23:05:06 livesey Exp $"
d952 23
d978 1
d984 23
d1333 3
@


2.39
log
@Added channel argument to AreSignalsSuperset
@
text
@d14 1
a14 1
    & PHYQ_Dimensionless, PHYQ_Frequency, PHYQ_Indices, S_Time
d126 1
d130 1
a130 1
    & "$Id: MLSSignals_m.f90,v 2.38 2001/05/16 01:24:06 livesey Exp $"
d1246 3
@


2.38
log
@Added AreSignalsSuperset routine
@
text
@d129 1
a129 1
    & "$Id: MLSSignals_m.f90,v 2.37 2001/05/03 02:06:07 vsnyder Exp $"
d1188 1
a1188 1
  integer function AreSignalsSuperset ( signals, probe )
d1198 2
d1216 1
a1216 1
      match = MatchSignal ( signals, probe(i) )
d1245 3
@


2.37
log
@Insert copyright notice
@
text
@d34 1
a34 1
  public :: AddSignalToDatabase, AddSpectrometerTypeToDatabase
d129 1
a129 1
    & "$Id: MLSSignals_m.f90,v 2.36 2001/05/02 21:50:26 livesey Exp $"
d1118 1
a1118 1
  integer function MatchSignal ( Signals, Probe, sideband, matchFlags )
d1122 2
d1129 1
d1159 13
a1171 5
      match = (.not. associated(probe%channels)) .or. &
        & (.not. associated(signals(i)%channels) )
      if ( .not. match ) match = all( (probe%channels .and. &
        & signals(i)%channels(lbound(probe%channels,1):ubound(probe%channels,1)) ) &
        & .eqv. probe%channels )
d1187 53
d1243 3
@


2.36
log
@Added initialization to deferred
@
text
@d1 3
d129 1
a129 1
    & "$Id: MLSSignals_m.f90,v 2.35 2001/05/02 19:12:11 vsnyder Exp $"
d1179 3
@


2.35
log
@Nullify signal%channels so it won't get hosed by subsequent allocate_test
Spiffify dump_signals and make it work if modules etc. are already gone
Get label into name field of signals.
@
text
@d83 1
a83 1
    logical :: Deferred                 ! "Frequencies/widths are deferred"
d126 1
a126 1
    & "$Id: MLSSignals_m.f90,v 2.34 2001/04/26 19:33:25 livesey Exp $"
d1176 5
@


2.34
log
@Add sideband field to getSignalName etc.
@
text
@d126 1
a126 1
    & "$Id: MLSSignals_m.f90,v 2.33 2001/04/26 02:33:03 vsnyder Exp $"
d168 2
a169 1
    integer, parameter :: BadMix = atLeastone + 1 ! Disallowed mixture of
d179 1
a179 1
        name = subtree(1, son)
d192 1
a192 1
        band%prefix = sub_rosa(name)
d217 1
a217 1
        thisModule%name = sub_rosa(name)
d240 1
a240 1
        radiometer%prefix = sub_rosa(name)
d282 1
d290 2
d318 2
a319 1
        ! Now nullify pointers so they don't get hosed later
d325 1
a325 1
        spectrometerType%name = sub_rosa(name)
d501 3
d735 2
a736 2
  ! --------------------------------------  DumpSpectrometerTypes  -----
  subroutine DUMP_SIGNALS ( SIGNALS )
d738 6
a743 2
    integer :: i
    character (len=80) :: str
d747 8
a754 1
      call output ( i, advance='yes' )
d758 6
a763 2
      call display_string ( modules(signals(i)%instrumentModule)%name, &
        & advance='yes' )
d767 6
a772 2
      call getRadiometerName ( signals(i)%radiometer, str )
      call output ( TRIM(str) )
d778 6
a783 2
      call getBandName ( signals(i)%band, str )
      call output ( TRIM(str) )
d789 5
a793 1
      call display_string ( spectrometerTypes(signals(i)%spectrometerType)%name )
d798 1
a798 1
      call output ( 'Sideband: ' )
d800 14
a813 4
      call output ( '   Frequencies:', advance='yes' )
      call dump ( signals(i)%frequencies )
      call output ( '   Widths:', advance='yes' )
      call dump ( signals(i)%widths )
d815 1
a815 1
        call output ( '    Channel Flags:', advance='yes' )
d818 1
a818 1
        call output ( 'All channels selected', advance='yes' )
d1176 3
@


2.33
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d126 1
a126 1
    & "$Id: MLSSignals_m.f90,v 2.32 2001/04/24 22:36:27 vsnyder Exp $"
d873 1
a873 1
    & NoSwitch, NoSpectrometer, NoChannels, NoSuffix )
d883 1
d890 1
d900 1
d907 1
d917 1
a917 1
        & string_text(LEN_TRIM(string_text)+1:), sideband=signal%sideband, &
d1025 1
a1025 1
    & NoSwitch, NoSpectrometer, NoChannels, NoSuffix )
d1036 1
d1039 1
a1039 1
      & noSwitch, noSpectrometer, noChannels, noSuffix )
d1131 3
@


2.32
log
@Correct the 'what' argument to deallocate_test
@
text
@d10 2
a11 1
  use Intrinsic, only: PHYQ_Dimensionless, PHYQ_Frequency, PHYQ_Indices, S_Time
d126 1
a126 1
    & "$Id: MLSSignals_m.f90,v 2.31 2001/04/23 23:12:45 vsnyder Exp $"
d135 1
a135 1
  subroutine MLSSignals ( ROOT, Field_Indices )
a137 1
    integer, intent(in) :: Field_Indices(field_first:)
d1126 3
@


2.31
log
@Finish adding 'time' command
@
text
@d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.30 2001/04/23 23:10:37 vsnyder Exp $"
d629 1
a629 1
    call deallocate_test ( signal%channels, 'Signal', moduleName )
d1126 3
@


2.30
log
@Add 'time' command
@
text
@d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.29 2001/04/21 01:06:37 vsnyder Exp $"
d173 1
d1126 3
@


2.29
log
@Make Signal%Deferred initially false
@
text
@d10 1
a10 1
  use Intrinsic, only: PHYQ_Dimensionless, PHYQ_Frequency, PHYQ_Indices
d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.28 2001/04/21 01:05:26 vsnyder Exp $"
d159 2
d214 1
a214 1
      case ( s_module ) ! .............................. MODULE ........
d318 1
a318 1
      case ( s_spectrometerType ) ! .............  SPECTROMETERTYPE .....
d414 8
d440 1
d515 8
d1125 3
@


2.28
log
@Deallocate Frequencies and Widths in DestroySignal if it's deferred
@
text
@d98 1
a98 1
    logical :: Deferred                 ! "Frequencies/widths are deferred"
d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.27 2001/04/20 22:41:25 vsnyder Exp $"
d1106 3
@


2.27
log
@Publish DestroySignal
@
text
@d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.26 2001/04/19 20:29:24 livesey Exp $"
d610 8
a617 2
    ! Don't destroy Frequencies or Widths.  Those fields are shallow
    ! copies here.  They're destroyed in DestroySpectrometerType.
d1106 3
@


2.26
log
@Added sideband argument to MatchSignal and made MatchSignal look at it or
probe%sideband
@
text
@d32 1
a32 1
  public :: DestroyRadiometerDatabase, DestroySignalDatabase
d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.25 2001/04/13 23:54:06 livesey Exp $"
d1100 4
@


2.25
log
@Change intent inout to intent out for matchFlags in MatchSignal
@
text
@d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.24 2001/04/13 23:28:59 livesey Exp $"
d1039 1
a1039 1
  integer function MatchSignal ( Signals, Probe, matchFlags )
d1046 1
d1053 1
d1057 6
d1072 1
d1100 3
@


2.24
log
@Tidied up some gothcas in MatchSignal.
@
text
@d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.23 2001/04/13 20:40:23 vsnyder Exp $"
d1046 1
a1046 1
    logical, dimension(size(signals)), intent(inout), optional :: matchFlags
d1091 3
@


2.23
log
@Create GetNameOfSignal that returns the name of a Signal_T object (the
already-present subroutine GetSignalName takes a signals-database index).
Add DestroySignal to destroy one Signal_T object.
@
text
@d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.22 2001/04/12 18:14:19 vsnyder Exp $"
d736 3
a738 1
      call output ( ubound(signals(i)%frequencies,1), 3 )
d743 6
d1039 1
a1039 1
  integer function MatchSignal ( Signals, Probe )
d1046 1
d1053 2
d1068 2
a1069 1
      match = .not. associated(probe%channels)
d1074 6
a1079 1
        numChannelsMatch = count(signals(i)%channels)
d1091 5
@


2.22
log
@Get the right vertex for 'deferred'
@
text
@d36 2
a37 2
  public :: GetModuleFromSignal, GetModuleName, GetRadiometerFromSignal
  public :: GetRadiometerName, GetSignal, GetSignalName
a68 1
    integer :: PointingGrid = 0         ! Database index -- see PointingGrid_m
a101 1
    integer :: PointingGrid = 0         ! Database index -- see PointingGrid_m
d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.21 2001/04/11 20:19:27 vsnyder Exp $"
d604 10
d617 1
a617 1
    integer :: Status
d621 3
d632 2
a633 1
    type(spectrometerType_T) :: SpectrometerType
a676 2
      call output ( '   PointingGrid: ' )
      call output ( bands(i)%pointingGrid, advance='yes' )
a736 2
      call output ( '   PointingGrid: ' )
      call output ( signals(i)%pointingGrid, advance='yes' )
d837 107
d986 2
a987 2
  subroutine GetSignalName(signal, string_text, noRadiometer, noBand, &
    & noSwitch, noSpectrometer, noChannels, noSuffix)
d999 3
a1001 51
    ! Local variables
    logical :: MY_NORADIOMETER, MY_NOBAND, MY_NOSWITCH
    logical :: MY_NOSPECTROMETER, MY_NOCHANNELS
    type (signal_T), pointer :: sig
    character (len=8) :: word

    ! Executable code
    sig => signals(signal)
    string_text       = ''
    my_noRadiometer   = .false.
    my_noBand         = .false.
    my_noSwitch       = .false.
    my_noSpectrometer = .false.
    my_noChannels     = .false.

    if ( present(noRadiometer) )   my_noRadiometer =   noRadiometer
    if ( present(noBand) )         my_noBand =         noBand
    if ( present(noSwitch) )       my_noSwitch =       noSwitch
    if ( present(noSpectrometer) ) my_noSpectrometer = noSpectrometer
    if ( present(noChannels) )     my_noChannels =     noChannels

    if ( .not. my_noRadiometer ) &
      & call GetRadiometerName ( sig%radiometer, string_text, noSuffix=noSuffix )

    if ( .not. my_noBand ) then
      if ( (len_trim(string_text) /= 0) .and. &
        &  (len_trim(string_text)<len(string_text)) ) &
        &  string_text = TRIM(string_text) // '.'
      call GetBandName ( sig%band, &
        & string_text(LEN_TRIM(string_text)+1:), sideband=sig%sideband, &
        & noSuffix=noSuffix )
    end if

    if ( .not. my_noSwitch ) then
      if ( (len_trim(string_text) /= 0) .and. &
        &  (len_trim(string_text)+1<len(string_text)) ) &
        &  string_text = TRIM(string_text) // '.S'
      write (word,'(I8)') sig%switch
      word = adjustl(word)
      if ( len_trim(string_text)+len_trim(word) < len(string_text) )&
        & string_text = TRIM(string_text) // TRIM(word)
    end if

    if ( .not. my_noSpectrometer ) then
      if ( (len_trim(string_text) /= 0) .and. &
        &  (len_trim(string_text)<len(string_text)) ) &
        &  string_text = TRIM(string_text) // '.'
      call GetSpectrometerTypeName ( sig%spectrometerType, sig%spectrometer, &
        & string_text(LEN_TRIM(string_text)+1:) )
    end if
  end subroutine GetSignalName
d1032 1
a1032 1
    ! Givan an array Signals, find the one in the array that privides
d1074 3
@


2.21
log
@Undo changes to 'deferred'
@
text
@d127 1
a127 1
    & "$Id: MLSSignals_m.f90,v 2.20 2001/04/11 19:57:55 vsnyder Exp $"
d335 1
a335 1
            deferred = get_boolean(gson)
d1007 3
@


2.20
log
@OOPS! More work on 'deferred' spectrometers
@
text
@d83 1
a83 1
    integer :: Deferred                 ! size(Frequencies) if deferred
d99 1
a99 1
    integer :: Deferred                 ! size(Frequencies) if deferred
d127 1
a127 1
    & "$Id: MLSSignals_m.f90,v 2.19 2001/04/11 19:54:00 vsnyder Exp $"
d143 1
a143 2
    integer :: Deferred                 ! Set nonzero if frequencies/widths
                                        ! deferred
d320 1
a320 1
        deferred = 0
d335 1
a335 2
            call expr_check ( gson, units, value, field, phyq_dimensionless )
            deferred = value(1)
d396 1
a396 1
        if ( deferred > 0 ) then        ! For deferred types, wait till later
a401 7
            call allocate_test ( spectrometerType%frequencies, deferred, &
              & 'spectrometerType%frequencies', moduleName )
            call allocate_test ( spectrometerType%widths, deferred, &
              & 'spectrometerType%widths', moduleName )
            spectrometerType%frequencies = 0.0
            spectrometerType%widths = 0.0
          else
d1007 3
@


2.19
log
@More work on 'deferred' spectrometers
@
text
@d83 1
d98 2
a100 1
    integer :: Band                     ! Index in Bands database
d127 1
a127 1
    & "$Id: MLSSignals_m.f90,v 2.18 2001/04/11 18:31:04 vsnyder Exp $"
d287 1
d1016 3
@


2.18
log
@Change 'deferred' from boolean to numeric
@
text
@d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.17 2001/04/10 23:20:05 livesey Exp $"
d400 1
d1013 3
@


2.17
log
@Added index field
@
text
@d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.16 2001/04/10 17:59:53 vsnyder Exp $"
d141 2
a142 1
    logical :: Deferred                 ! Set if frequencies/widths deferred
d318 1
a318 1
        deferred = .false.
d333 2
a334 1
            deferred = get_boolean(son)
d395 15
a409 3
        if ( deferred ) then            ! For deferred types, wait till later
          nullify(spectrometerType%frequencies)
          nullify(spectrometerType%widths)
d411 2
a412 3
        if ( .not. any(got( (/ f_channels, f_start /) )) .and. &
          & (.not. deferred) ) &
          & call announceError ( atLeastOne, f_channels, (/ f_start /) )
d1012 3
@


2.16
log
@Remove sideband field from signal
@
text
@d97 1
d125 1
a125 1
    & "$Id: MLSSignals_m.f90,v 2.15 2001/04/09 20:30:46 vsnyder Exp $"
d309 1
d999 3
@


2.15
log
@More work on MatchSignal
@
text
@d102 1
a102 1
    integer :: SideBand                 ! L_lower, L_upper, L_folded
d124 1
a124 1
    & "$Id: MLSSignals_m.f90,v 2.14 2001/04/09 20:16:40 vsnyder Exp $"
d256 1
a256 1
        signal%sideband = l_folded
a266 2
          case ( f_sideband )
            signal%sideband = decoration(gson)
d773 1
d777 1
a777 1
    my_sideband = l_folded
d781 3
a783 7
    select case ( my_sideband )
    case ( l_folded ); sb_char = ' '
    case ( l_upper );  sb_char = 'U'
    case ( l_lower ); sb_char = 'L'
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, 'Illegal sideband' )
    end select
d964 1
d980 2
a981 1
      if ( all( (probe%channels .and. &
d983 2
a984 1
        & .eqv. probe%channels ) ) then
d997 3
@


2.14
log
@Correct numChannelsMatch calculation
@
text
@d124 1
a124 1
    & "$Id: MLSSignals_m.f90,v 2.13 2001/04/07 01:52:58 vsnyder Exp $"
d986 7
a992 2
        & .eqv. probe%channels ) ) numChannelsMatch = count(signals(i)%channels)
      if ( numChannelsMatch < bestMatch ) matchSignal = i
d999 3
@


2.13
log
@Initial cut at MatchSignal
@
text
@d124 1
a124 1
    & "$Id: MLSSignals_m.f90,v 2.12 2001/04/03 01:48:25 vsnyder Exp $"
d968 1
a968 1
    integer :: I, J                     ! Loop inductors, subscripts
d973 1
a973 1
o:  do i = 1, size(signals)
d984 3
a986 9
      numChannelsMatch = 0
      do j = lbound(probe%channels,1), ubound(probe%channels,1)
        if ( probe%channels(j) ) then
          if ( j < lbound(signals(i)%channels,1) .or. &
            &  j > ubound(signals(i)%channels,1) ) cycle o
          if ( .not. signals(i)%channels(j) ) cycle o
          numChannelsMatch = numChannelsMatch + 1
        end if
      end do ! j
d988 1
a988 1
    end do o
d994 3
@


2.12
log
@No need to declare Make_Tree private -- It's internal!
@
text
@d38 1
a38 1
  public :: GetSpectrometerTypeName, IsModuleSpacecraft, MLSSignals
d124 1
a124 1
    & "$Id: MLSSignals_m.f90,v 2.11 2001/03/29 23:52:31 vsnyder Exp $"
d951 1
a951 1
  ! ------------------------------------------  IsModuleSpacecraft  ----
d958 39
d1000 3
@


2.11
log
@Added MaxSigLen parameter
@
text
@d85 2
a86 3
  ! This is the key type, it describes a complete signal (one band, or a
  ! subset of the channels in one band).  We have to main variables of this
  ! type flying around, see later.
d92 4
a95 1
    real(r8), pointer, dimension(:) :: Widths=>NULL() ! Mainly a shallow copy
d124 1
a124 1
    & "$Id: MLSSignals_m.f90,v 2.10 2001/03/28 19:51:58 vsnyder Exp $"
d292 2
d302 1
d961 3
@


2.10
log
@Remove "frequencies" and "widths" fields.  Use range instead in a "channels"
field.  Put in units checking for every numeric field.
@
text
@d40 2
d122 1
a122 1
    & "$Id: MLSSignals_m.f90,v 2.9 2001/03/16 21:32:23 vsnyder Exp $"
d956 4
@


2.9
log
@Add 'Switches' test for dumping
@
text
@d10 2
d120 1
a120 1
    & "$Id: MLSSignals_m.f90,v 2.8 2001/03/16 02:10:32 vsnyder Exp $"
d135 1
a135 1
    integer :: MyChannels               ! subtree index of field
a139 1
    integer :: Frequencies              ! subtree index of field
a156 1
    integer :: Widths                   ! subtree index of field
d163 1
a163 1
    integer, parameter :: Sizes = badMix + 1 ! Fields don't have same sizes
d192 1
a192 1
            call expr ( gson, units, value )
d238 1
a238 1
            call expr ( gson, units, value )
d261 2
d266 1
a266 1
            call expr ( gson, units, value )
d269 1
a269 1
            call expr ( gson, units, value )
a270 4
          case ( f_frequencies )
            frequencies = son
          case ( f_widths ) 
            widths = son
d282 1
a282 5
        if ( got(f_frequencies) .neqv. got(f_widths) ) call announceError ( &
          & allOrNone, f_frequencies, (/ f_widths /) )
        if ( got(f_frequencies) ) then
          if ( nsons(frequencies) /= nsons(widths) ) &
            call announceError ( sizes, f_frequency, (/ f_widths /) )
d284 1
a284 1
            call allocate_Test ( signal%frequencies, nsons(son)-1, &
d286 1
a286 1
            call allocate_Test ( signal%widths, nsons(son)-1, &
d288 2
a289 2
            do k = 2, nsons(frequencies)
              call expr ( subtree(k,frequencies), units, value )
d291 1
a291 2
              call expr ( subtree(k,widths), units, value )
              signal%widths(k-1) = value(1)
d293 3
d322 6
a327 2
          case ( f_first, f_last, f_start, f_step, f_width )
            call expr ( gson, units, value )
d333 4
a343 6
          case ( f_frequencies )   ! Postpone processing until later, so that
            frequencies = son      ! we can verify that Frequencies and
          case ( f_widths )        ! Widths have the same number of values
            widths = son
          case ( f_deferred )
            deferred = get_boolean(son)
d348 1
a348 3
        if ( got(f_frequencies) .neqv. got(f_widths) ) call announceError ( &
          & allOrNone, f_frequencies, (/ f_widths /) )
        if ( got(f_frequencies) ) then
d350 1
a350 1
            & call announceError ( badMix, f_frequencies, &
a351 2
          if ( nsons(frequencies) /= nsons(widths) ) &
            call announceError ( sizes, f_frequency, (/ f_widths /) )
d353 8
a360 6
            call allocate_Test ( spectrometerType%frequencies, nsons(son)-first, &
              & 'spectrometerType%frequencies', moduleName, lowBound = first )
            call allocate_Test ( spectrometerType%widths, nsons(son)-first, &
              & 'spectrometerType%widths', moduleName, lowBound = first )
            do k = 2, nsons(frequencies)
              call expr ( subtree(k,frequencies), units, value )
d362 1
a362 2
              call expr ( subtree(k,widths), units, value )
              spectrometerType%widths(k-2+first) = value(1)
d364 3
d390 1
a390 1
        if ( .not. any(got( (/ f_frequencies, f_start /) )) .and. &
d392 1
a392 1
          & call announceError ( atLeastOne, f_frequencies, (/ f_start /) )
d405 3
d430 2
a431 4
      call output ( 'At line '  )
      call output ( mod(source,256) )
      call output ( ', column ' )
      call output ( source/256 )
d468 1
a468 1
          CALL display_string ( field_indices(moreFields(i)) )
d471 6
a476 11
      case ( sizes )
        call output ( 'The fields ' )
        do i = 1, size(moreFields)
          if ( i == size(moreFields) ) then
            call output ( ' and ' )
          else
            call output ( ', ' )
          end if
          call display_string ( field_indices(moreFields(i)) )
        end do ! i
        call output ( ' shall all have the same size.', advance='yes' )
d480 11
d954 3
@


2.8
log
@Put the sideband character in the correct place
@
text
@d16 1
a16 1
  use Toggles, only: Gen, Toggle, Levels
d118 1
a118 1
    & "$Id: MLSSignals_m.f90,v 2.7 2001/03/16 01:54:47 vsnyder Exp $"
d407 9
a415 8
    if ( levels(gen) > 0 ) then
      call dump ( radiometers )
      call dump ( spectrometerTypes )
      call dump ( bands )
      call dump ( signals )
    endif

    if ( toggle(gen) ) call trace_end ( "MLSSignals" )
d637 2
a638 2
      call display_string ( radiometers(bands(i)%radiometer)%prefix, advance='yes' )
      call output ( '   SpectrometerType: ')
d644 3
a646 1
      call output ( bands(i)%centerFrequency, advance='yes' )
d702 1
a702 2
      call display_string ( spectrometerTypes(signals(i)%spectrometerType)%name, &
        & advance='yes' )
d706 3
a708 1
      call output ( ubound(signals(i)%frequencies,1), 3, advance='yes' )
d949 3
@


2.7
log
@Use enumerated type instead of numbers for sideband; add a field for it
in the "signal" spec.
@
text
@d118 1
a118 1
    & "$Id: MLSSignals_m.f90,v 2.6 2001/03/16 00:30:49 vsnyder Exp $"
d775 2
a781 2
      string_text = string_text(1:LEN_TRIM(string_text)-1) // TRIM(sb_char) // &
        & string_text(LEN_TRIM(string_text):LEN_TRIM(string_text))
d892 2
a893 1
        & string_text(LEN_TRIM(string_text)+1:), noSuffix=noSuffix )
d945 4
@


2.6
log
@Make way for the pointing grid
@
text
@d96 1
a96 1
    integer :: SideBand                 ! -1:lower, +1:upper, 0:folded
d118 1
a118 1
    & "$Id: MLSSignals_m.f90,v 2.5 2001/03/15 21:02:07 vsnyder Exp $"
d252 1
d261 2
a277 1
        signal%sideband = 0
d752 1
a752 1
    integer, intent(in), optional :: SIDEBAND     ! -1, 0 or 1
d762 1
a762 1
    my_sideband = 0
d767 3
a769 3
    case ( 0 ) ! Do nothing
    case ( 1 );  sb_char = 'U'
    case ( -1 ); sb_char = 'L'
d780 2
a781 4
      if ( my_sideband /= 0 ) then        ! Do surgery to add sideband
        string_text = string_text(1:LEN_TRIM(string_text)-1) // sb_char // &
          & string_text(LEN_TRIM(string_text):LEN_TRIM(string_text))
      end if
d944 3
@


2.5
log
@Cross-references between databases are by database index, not tree index
@
text
@d65 1
d94 1
d118 1
a118 1
    & "$Id: MLSSignals_m.f90,v 2.4 2001/03/15 18:42:58 livesey Exp $"
d944 3
@


2.4
log
@Added GetSignal
@
text
@a9 1
  use Intrinsic, only: L_true
d13 1
d34 2
a35 2
  public :: GetModuleFromSignal, GetModuleIndex, GetModuleName
  public :: GetRadiometerFromSignal, GetRadiometerName, GetSignal, GetSignalName
d56 1
a56 1
    integer :: InstrumentModule         ! Tree index
d66 2
a67 2
    integer :: Radiometer               ! Tree index
    integer :: SpectrometerType         ! Tree index
d90 2
a91 2
    integer :: Band                     ! Tree index
    integer :: InstrumentModule         ! Tree index
d93 1
a93 1
    integer :: Radiometer               ! Tree index
d96 1
a96 1
    integer :: SpectrometerType         ! Tree index
d116 1
a116 1
    & "$Id: MLSSignals_m.f90,v 2.3 2001/03/15 18:39:42 vsnyder Exp $"
d118 1
a118 1
  character (len=*), parameter, private :: ModuleName= &
d181 1
a181 1
        band%prefix= sub_rosa(name)
d195 1
a195 1
            band%radiometer = gson
d197 1
a197 1
            band%spectrometerType= gson
d212 1
a212 1
          if (nsons(son) > 1) then
d220 1
a220 5
            if (node_id(son) == n_set_one) then
              thisModule%spacecraft=.true.
            else
              thisModule%spacecraft=decoration(gson) == l_true
            endif
d229 1
a229 1
        radiometer%prefix= sub_rosa(name)
d241 1
a241 1
            radiometer%instrumentModule=gson
d254 1
a254 1
          got(field)=.true.
d257 1
a257 1
            signal%band = gson
d265 1
a265 1
            frequencies=son
d267 1
a267 1
            widths=son
d273 6
a278 11
        signal%sideband=0
        signal%radiometer=bands( &
          & decoration(decoration(signal%band)))%radiometer
        signal%lo=radiometers( &
          & decoration(decoration(signal%radiometer)))%lo
        signal%instrumentModule=radiometers( &
          & decoration(decoration(signal%radiometer)))%instrumentModule
        signal%spectrometerType=bands( &
          & decoration(decoration(signal%band)))%spectrometerType
        signal%centerFrequency=bands( &
          & decoration(decoration(signal%band)))%centerFrequency
d298 3
a300 4
          signal%frequencies=> spectrometerTypes( &
            & decoration(decoration(signal%spectrometerType)))%frequencies
          signal%widths=> spectrometerTypes( &
            & decoration(decoration(signal%spectrometerType)))%widths
d309 2
a310 2
        spectrometerType%name=sub_rosa(name)
        deferred=.false.
d315 1
a315 1
          if (nsons(son) > 1) then
d341 1
a341 5
            if (node_id(son) == n_set_one) then
              deferred=.true.
            else
              deferred=decoration(gson) == l_true
            endif
a402 2
    if ( toggle(gen) ) call trace_end ( "MLSSignals" )

d404 4
a407 4
      call dump(radiometers)
      call dump(spectrometerTypes)
      call dump(bands)
      call dump(signals)
d410 2
d441 1
a441 1
        call output ( ' shall appear, or none of them shall.', advance='yes' )
a629 1
      call output ( decoration(bands(i)%radiometer))
d632 1
a632 1
      call display_string ( sub_rosa(bands(i)%radiometer), advance='yes' )
d634 1
a634 1
      call output ( decoration(bands(i)%spectrometerType) )
d636 2
a637 1
      call display_string ( sub_rosa(bands(i)%spectrometerType),advance='yes' )
d639 1
a639 1
      call output ( bands(i)%centerFrequency,advance='yes' )
d656 1
a656 1
      call output ( decoration(radiometers(i)%instrumentModule) )
d658 1
a658 1
      call display_string ( sub_rosa(radiometers(i)%instrumentModule), advance='yes' ) 
d674 1
a674 1
      call output ( decoration(signals(i)%instrumentModule ) )
d676 2
a677 1
      call display_string ( sub_rosa(signals(i)%instrumentModule), advance='yes' )
d679 1
a679 1
      call output ( decoration(decoration(signals(i)%radiometer)) )
d681 1
a681 1
      call getRadiometerName(signals(i)%radiometer,str)
d686 1
a686 1
      call output ( decoration(signals(i)%band ) )
d693 1
a693 1
      call output ( decoration( signals(i)%spectrometerType ) )
d695 2
a696 1
      call display_string ( sub_rosa(signals(i)%spectrometerType),advance='yes' )
d717 2
a718 2
      call display_string (spectrometerTypes(i)%name,advance='yes')
      if (associated(spectrometerTypes(i)%frequencies)) then
d722 2
a723 1
        call output ( ubound(spectrometerTypes(i)%frequencies,1), 3, advance='yes' )
d739 2
a740 2
    call Allocate_Test(moduleNodes, size(modules), 'ModuleNodes', ModuleName)
    moduleNodes=modules%node
a742 33
  ! ------------------------------------  GetModuleFromRadiometer  -----
  integer function GetModuleFromRadiometer(radiometer)
    ! Returns module field from given radiometer given as tree index
    integer, intent(in) :: radiometer
    GetModuleFromRadiometer=radiometers(decoration(decoration(radiometer)))%instrumentModule
  end function GetModuleFromRadiometer

  ! ----------------------------------------  GetModuleFromSignal  -----
  integer function GetModuleFromSignal(signal)
    ! Returns module field from given signal given as tree index
    integer, intent(in) :: signal
    GetModuleFromSignal=signals(decoration(decoration(signal)))%instrumentModule
  end function GetModuleFromSignal

  ! ---------------------------------------------  GetModuleIndex  -----
  integer function GetModuleIndex(thisModule)
    ! Returns module field from given radiometer given as tree index
    integer, intent(in) :: thisModule
    integer :: i
    GetModuleIndex=0
    do i=1,size(modules)
      if (modules(i)%node==thisModule) GetModuleIndex=i
    end do
  end function GetModuleIndex

  ! ----------------------------------------------  GetModuleName  -----
  subroutine GetModuleName(instrumentModule, string_text)
    ! Returns module name in mixed case
    integer, intent(in) :: instrumentModule
    character (len=*), intent(out) :: string_text
    call Get_String(modules(decoration(decoration(instrumentModule)))%name, string_text)
  end subroutine GetModuleName

d745 5
a749 5
    ! Place band name in string
    integer, intent(in) :: BAND   ! Tree index
    character(len=*), intent(out) :: STRING_TEXT ! Result
    integer, intent(in), optional :: SIDEBAND ! -1, 0 or 1
    logical, intent(in), optional :: NOSUFFIX ! Omit suffix if set
d759 2
a760 2
    if (present(noSuffix)) my_noSuffix = noSuffix
    if (present(sideband)) my_sideband = sideband
d767 1
a767 1
      call MLSMessage(MLSMSG_Error,ModuleName,'Illegal sideband')
d770 1
a770 1
    call get_string(sub_rosa(band), string_text, cap=.true.)
d773 5
a777 5
      string_text=TRIM(string_text)//':'
      call get_string(bands(decoration(decoration(band)))%suffix,&
        & string_text(LEN_TRIM(string_text)+1:), cap=.true., strip=.true.)
      if (my_sideband /= 0) then        ! Do surgery to add sideband
        string_text=string_text(1:LEN_TRIM(string_text)-1)//sb_char// &
d784 22
d808 1
a808 1
    ! Returns radiometer field from given signal given as tree index
d810 1
a810 1
    GetRadiometerFromSignal=signals(decoration(decoration(signal)))%radiometer
d815 5
a819 4
    ! Place radiometer name in string
    integer, intent(in) :: RADIOMETER   ! Tree index
    character(len=*), intent(out) :: STRING_TEXT ! Result
    logical, intent(in), optional :: NOSUFFIX ! Omit suffix if set
d826 1
a826 1
    if (present(noSuffix)) my_noSuffix = noSuffix
d828 2
a829 1
    call get_string(sub_rosa(radiometer), string_text, cap=.true., strip=.true.)
d832 3
a834 3
      string_text=TRIM(string_text)//':'
      call get_string(radiometers(decoration(decoration(radiometer)))%suffix,&
        & string_text(LEN_TRIM(string_text)+1:), cap=.true., strip=.true.)
d841 1
a841 1
    ! This routine simply returns the signal data structure
d844 1
a844 1
    GetSignal=signals(decoration(decoration(signal)))
d850 3
a852 2
    ! This routine constructs a full signal name
    integer, intent(in) :: SIGNAL
d868 1
a868 1
    sig => signals(decoration(decoration(signal)))
d876 5
a880 5
    if (present(noRadiometer))   my_noRadiometer =   noRadiometer
    if (present(noBand))         my_noBand =         noBand
    if (present(noSwitch))       my_noSwitch =       noSwitch
    if (present(noSpectrometer)) my_noSpectrometer = noSpectrometer
    if (present(noChannels))     my_noChannels =     noChannels
d882 2
a883 2
    if (.not. my_noRadiometer) &
      & call GetRadiometerName(sig%radiometer, string_text, noSuffix=noSuffix)
d885 1
a885 1
    if (.not. my_noBand) then
d888 3
a890 3
        &  string_text=TRIM(string_text)//'.'
      call GetBandName(sig%band, &
        & string_text(LEN_TRIM(string_text)+1:),noSuffix=noSuffix)
d893 1
a893 1
    if (.not. my_noSwitch) then
d896 1
a896 1
        &  string_text=TRIM(string_text)//'.S'
d898 1
a898 1
      word=adjustl(word)
d900 1
a900 1
        & string_text=TRIM(string_text)//TRIM(word)
d903 1
a903 1
    if (.not. my_noSpectrometer) then
d906 3
a908 3
        &  string_text=TRIM(string_text)//'.'
      call GetSpectrometerTypeName(sig%spectrometerType, sig%spectrometer, &
        & string_text(LEN_TRIM(string_text)+1:))
d923 2
a924 2
    call get_string(sub_rosa(spectrometerType), string_text)
    if (len_trim(string_text) < len(string_text) ) &
d926 3
a928 3
    write(word,'(I8)') number
    word=adjustl(word)
    if (len_trim(string_text)+len_trim(word) < len(string_text)) &
d936 1
a936 1
    IsModuleSpacecraft=modules(decoration(decoration(thisModule)))%spacecraft
d942 3
@


2.3
log
@Periodic commit
@
text
@d35 1
a35 1
  public :: GetRadiometerFromSignal, GetRadiometerName, GetSignalName
d116 1
a116 1
    & "$Id: MLSSignals_m.f90,v 2.2 2001/03/14 23:44:47 vsnyder Exp $"
d859 8
d961 3
@


2.2
log
@Correct a comment, other cosmetic changes in comments
@
text
@d40 3
a42 3
  interface DUMP
    module procedure DUMP_BANDS, DUMP_RADIOMETERS, DUMP_SIGNALS, &
      & DUMP_SPECTROMETERTYPES
d47 1
a48 1
    integer :: Name                     ! Sub_rosa index
d55 1
d57 1
a57 1
    integer :: Prefix                   ! Sub_rosa index
a58 1
    real(r8) :: LO                      ! Local oscillator in MHz
d64 2
a65 1
    integer :: Prefix                   ! Sub_rosa index
a68 1
    real(r8) :: CenterFrequency         ! Negative if not present (wide filter)
a75 1
    integer :: Name                     ! Name for spectrometer type
d77 1
d85 5
d92 1
a97 5

    real(r8) :: LO                      ! Radiometer local oscillator
    real(r8) :: CenterFrequency         ! Band local oscillator
    real(r8), pointer, dimension(:) :: Frequencies=>NULL() ! Mainly a shallow copy
    real(r8), pointer, dimension(:) :: Widths=>NULL() ! Mainly a shallow copy
d116 1
a116 1
    & "$Id: MLSSignals_m.f90,v 2.1 2001/03/14 02:05:52 vsnyder Exp $"
d125 1
a125 1
  subroutine MLSSignals ( ROOT, Field_Indices, Spec_Indices )
a128 1
    integer, intent(in) :: Spec_Indices(spec_first:)
d953 3
@


2.1
log
@Moved MLSSignals_m to mlspgs/lib.
@
text
@d95 2
a96 2
    real(r8), POINTER, DIMENSION(:) :: Frequencies=>NULL() ! Mainly a shallow copy
    real(r8), POINTER, DIMENSION(:) :: Widths=>NULL() ! Mainly a shallow copy
d115 1
a115 1
    & "$Id: MLSSignals_m.f90,v 2.11 2001/03/03 00:08:23 livesey Exp $"
d497 1
a497 1
  ! ----------------------------------  AddBandToDatabase  -----
d510 1
a510 1
  ! ----------------------------------  AddModuleToDatabase  -----
d523 1
a523 1
  ! ----------------------------------  AddRadiometerToDatabase  -----
d536 1
a536 1
  ! ----------------------------------  AddSignalToDatabase  -----
d549 1
a549 1
  ! -------------------------------  AddSpectrometerTypeToDatabase  -----
d562 1
a562 1
  ! --------------------------------  DestroyBandDatabase  -----
d573 1
a573 1
  ! --------------------------------  DestroyModuleDatabase  -----
d584 1
a584 1
  ! --------------------------------  DestroyRadiometerDatabase  -----
d595 1
a595 1
  ! --------------------------------  DestroySignalDatabase  -----
d631 1
a631 1
  ! ------------------------------------------------ DumpBands -----
d657 1
a657 1
  ! ----------------------------------------------- Dump_Radiometers --
d678 1
a678 1
  ! ------------------------------------------- DumpSpectrometerTypes --
d720 1
a720 1
  ! ------------------------------------------- DumpSpectrometerTypes --
d745 1
a745 1
  ! ---------------------------------------------- GetAllModules -------
d754 1
a754 1
  ! --------------------------------------- GetModuleFromRadiometer ----
d761 1
a761 1
  ! --------------------------------------- GetModuleFromSignal ----
d768 1
a768 1
  ! --------------------------------------- GetModuleIndex -----
d779 1
a779 1
  ! --------------------------------------- GetModuleName -----
d787 1
a787 1
  ! --------------------------------------- GetRadiometerName ------
d828 1
a828 1
  ! -------------------------------------- GetRadiometerFromSignal ---
d835 1
a835 1
  ! --------------------------------------- GetRadiometerName --------
d859 1
a859 2
  ! ------------------------------------ GetSignalName ---------

d923 1
a923 1
  ! -------------------------------------- GetSpectrometerName -----
d943 1
a943 1
  ! ----------------------------------------- IsModuleSpacecraft ----
d953 3
@

