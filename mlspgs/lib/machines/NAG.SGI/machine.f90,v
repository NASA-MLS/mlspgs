head	1.10;
access;
symbols
	v5-02-NRT-19:1.10
	v6-00:1.10
	v5-02-NRT-18:1.10
	v5-02:1.10
	v5-01-NRT-17:1.10
	v5-01-NRT-16:1.10
	v5-01-NRT-15:1.10
	v5-01-NRT-14:1.10
	neuralnetworks-1-0:1.10.0.14
	cfm-single-freq-0-1:1.10.0.12
	v5-01:1.10
	v5-00:1.10
	v4-23-TA133:1.10.0.10
	mus-emls-1-70:1.10.0.8
	rel-1-0-englocks-work:1.10.0.6
	VUMLS1-00:1.10
	VPL1-00:1.10
	V4-22-NRT-08:1.10
	VAM1-00:1.10
	V4-21:1.10.0.4
	V4-13:1.10
	V4-12:1.10
	V4-11:1.10
	V4-10:1.10
	V3-43:1.10
	M4-00:1.10
	V3-41:1.10
	V3-40-PlusGM57:1.10.0.2
	V2-24-NRT-04:1.9
	V3-33:1.10
	V2-24:1.9
	V3-31:1.10
	V3-30-NRT-05:1.10
	cfm-01-00:1.10
	V3-30:1.10
	V3-20:1.10
	V3-10:1.10
	V2-23-NRT-02:1.9
	V2-23:1.9
	V2-22-NRT-01:1.9
	V2-22:1.9
	V2-21:1.9
	V2-20:1.9
	V2-11:1.9
	V2-10:1.9
	V2-00:1.9
	V1-51:1.8
	V1-50:1.8
	V1-45:1.8
	V1-44:1.7
	V1-43:1.7
	V1-42:1.7
	V1-41:1.7
	V1-32:1.7
	V1-40:1.7
	V1-31:1.7
	V1-30:1.7
	V1-13:1.7
	V1-12:1.7
	V1-11:1.7
	V1-10:1.7
	newfwm-feb03:1.7.0.2
	V1-04:1.7
	V1-03:1.7
	V1-02:1.7
	V1-00:1.7
	newfwm-sep01:1.4.0.2
	V0-7:1.4
	V0-5-Level2:1.2
	V0-5-SIPS:1.2;
locks; strict;
comment	@# @;


1.10
date	2009.06.23.19.58.53;	author pwagner;	state Exp;
branches;
next	1.9;

1.9
date	2005.06.22.20.26.22;	author pwagner;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.19.00.13.13;	author pwagner;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.08.18.31.50;	author pwagner;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.05.00.37.19;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.31.19.16.28;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.15.20.34.37;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.08.22.10.28;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.21.00.42.34;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.13.00.29.44;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Prevent Intel from optimizing ident string away
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module MACHINE
! This file must be preprocessed through a makefile
! containing sed commands to snip out offending lines
! (delimited by BAD_MATCH) depending upon whether to build 
! (1) a version allowing garbage collection (-gc on the link line); or
! (2) a version not allowing garbage collection
!
! The recipe for getting each of the versions above is
!     if  (1) set BAD_MATCH='no -gc'
! else if (2) set BAD_MATCH='-gc'
!
!     sed "/Start $BAD_MATCH/,/End $BAD_MATCH/ d" machine.f90 \
!       > my_machine.f90
! and then just compile my_machine.f90

!---------- Start -gc section
!           requires -gc among LDOPTS
!   (the following lines automatically deleted for version (2))
  use F90_GC, only: GCOLLECT, NCOLLECTIONS, &
   & DONT_EXPAND, DONT_GC, FULL_FREQUENCY, MAX_RETRIES, SILENT_GC
!---------- End -gc section
  use F90_IOSTAT				! everything; see iostat_msg_NAG
  use F90_UNIX_ENV, only: IARGC, NAG_GETARG => GETARG
  ! Exit and return an integer status to the invoking process
  use F90_UNIX_PROC, only: EXIT_WITH_STATUS => EXIT, SYSTEM
  implicit none

  character(LEN=2) :: END_LINE = ' ' // char(10)
  character(LEN=1) :: FILSEP = '/'      ! '/' for Unix, '\' for DOS or NT
  integer, parameter :: HP = 0          ! Offset for first argument for GETARG

  interface IO_ERROR; module procedure IO_ERROR_; end interface
  private IO_ERROR_
  public :: SHELL_COMMAND
  public :: MLS_DISABLE_AUTOGC, MLS_GC_NOW, MLS_HOWMANY_GC, MLS_CONFIG_GC

  logical, public, save :: NEVERCRASH = .true. ! Change to false for testing

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  ! -------------------------------------------------  CRASH_BURN  -----
  subroutine CRASH_BURN ( CODE, MSG, OPT )
  ! Print CODE and MSG if they're present.
  ! Try to make the processor crash, so it produces a walkback if it
  ! supports such a thing.
  ! DON'T put an optional argument corresponding to OPT.  It may be
  ! referenced on some systems in an attempt to make the processor crash.
  ! STOP as a last resort.
  ! Compile everything with -gline to get a walkback -- even with -O.
  
  ! Crash is provoked by one of available methods:
  ! (a) rewind illegal unit number (default)
  ! (b) acos(2.)
  ! You may select which method to use by setting msg = '!x (rest of message)'
  ! where x is the method
    integer, intent(in), optional :: CODE
    character(len=*), intent(in), optional :: MSG
    integer, intent(in), optional :: OPT(:)
    integer :: I = -huge(0)
    real :: arg
    character(len=*), parameter :: DEFAULTMETHOD = 'b' ! 'a' or 'b'
    character(len=1) :: method
    if ( present(code) ) print *, 'In NAG MACHINE%CRASH_BURN, CODE =', code
    if ( present(msg) ) print *, 'In NAG MACHINE%CRASH_BURN, MSG = ', trim(msg)
    method = DEFAULTMETHOD
    if ( NEVERCRASH ) then
      method = 's' ! Just stop, don't crash nor burn
    elseif ( present(msg) ) then
      if ( msg(1:1) == '!' ) method = adjustl(msg(2:))
    endif
    select case (method)
    case (' ', 'a', 'A')
      rewind i
    case ('b', 'B')
      arg = 1.
      if ( .not. present(opt) ) arg = arg + 1.
      arg = acos(arg)
      if ( arg > 0. ) print *, 'arg ', arg
    case default
      ! When you just want to land safely; e.g., a sips production run
    end select
    stop
  end subroutine CRASH_BURN

  subroutine IO_ERROR_ ( MESSAGE, IOSTAT, FILE )
  ! Print MESSAGE and FILE, and then do something reasonable with IOSTAT.
    character(LEN=*), intent(in) :: MESSAGE
    integer, intent(in) :: IOSTAT
    character(LEN=*), intent(in), optional :: FILE

    integer :: L
!   character(LEN=127) :: MSG

    write (*,*) message(:len_trim(message))
    if ( present(file) ) then
      l = len_trim(file)
      if ( l /= 0 ) write (*,*) file(:l)
    end if
   call print_iostat_msg_NAG (iostat)       ! my version of a Lahey intrinsic
!   write (*,*) msg(:len_trim(msg))    ! Print the error message
    write (*,*) 'Error status code =', iostat
    return
  end subroutine IO_ERROR_

  subroutine GETARG ( ARGNUM, ARGVAL )
    integer, intent(in) :: ARGNUM  ! 0 = command name, 1 = first arg, etc.
    character(len=*), intent(out) :: ARGVAL   ! Blank if argnum out-of-range
    integer :: STATUS
    call nag_getarg ( argnum, argval, errno = status )
    if ( status /= 0 ) argval = ' '
  end subroutine GETARG

  subroutine print_iostat_msg_NAG ( iostat )
    integer, intent(in) :: iostat

	! This subroutine was made from NAG's own f90_iostat.f90
	! found in /usr/local/lib/NAGWare
	! then edited via the following 2 steps:
	
	! sed -n -f machines/iostat.sed machines/f90_iostat.f90
	!                            > machines/iostat.f90
	
	! cat -n machines/iostat.f90 | sort -n -r 
	!               | sed -n 's/^.......//p' > machines/iostat_rev.f90
	
	! where the file iostat.sed contains the following 5 lines
	! (w/o the leading !):
	
	!s/integer, parameter :: \([A-Za-z_][A-Za-z_0-9]*\)/case(\1)/
	!s/'//g
	!s/^! [A-Z].*$/		print*, '&'/
	!s/=/!/
	!p
	
	! after this lines from iostat_rev.f90 were copied and pasted below
	
select case (iostat)

	! start of included file iostat_rev.f90
    case(IOERR_SCALE_FOLLOWED_BY_REPEAT)  ! 217
		print*, '! Scale factors cannot be followed by repeat count in FMT! specifier'
    case(IOERR_DIRECT_POSITION_INCOMPAT)  ! 216
		print*, '! Direct access is incompatible with the POSITION! specifier'
    case(IOERR_REAL_INPUT_OVERFLOW)       ! 215
		print*, '! Floating overflow on real number input'
    case(IOERR_END_OF_DIRECT_ACCESS)      ! 214
		print*, '! READ beyond end of direct access file on unit %d'
    case(IOERR_RECL_LE_ZERO)              ! 213
		print*, '! Invalid value for RECL! specifier (must be positive)'
    case(IOERR_REPLACE_OR_NEW_NEED_FILE)  ! 212
		print*, '! No FILE! specifier with STATUS=REPLACE or STATUS=NEW'
    case(IOERR_INTEGER64_TOO_BIG)         ! 211
		print*, '! Input value too large for 64-bit integer'
    case(IOERR_RW_AFTER_ENDFILE)          ! 210
		print*, '! READ/WRITE attempted after ENDFILE on unit %d'
    case(IOERR_TRUNCATE_FAILED)           ! 209
		print*, '! File truncation on unit %d failed'
    case(IOERR_CORRUPT_UNFORMATTED_FILE)  ! 208
		print*, '! Unformatted data file open on unit %d is corrupt'
    case(IOERR_RECORD_TOO_SHORT)          ! 207
		print*, '! Record too short for format requirement and PAD!NO on unit %d'
    case(IOERR_INPUT_LIST_TOO_BIG)        ! 206
		print*, '! Input list bigger than record length in unformatted READ on unit %d'
    case(IOERR_NO_NAMELIST_GROUP_NAME)    ! 205
		print*, '! Missing namelist group name in input of NAMELIST/%s/'
    case(IOERR_ZERO_STRIDE)               ! 204
		print*, '! Section stride has value zero in input for object %s of NAMELIST/%s/'
    case(IOERR_ZERO_SIZE_INPUT)           ! 203
		print*, '! Array section has zero size in input for object %s of NAMELIST/%s/'
    case(IOERR_SUBSCRIPT_OUT_OF_RANGE)    ! 202
		print*, '! Subscript (%d) out of range in input for object %s of NAMELIST/%s/'
    case(IOERR_EXPECTED_RPAREN)           ! 201
		print*, '! Expected ) but found %c in input for object %s of NAMELIST/%s/'
    case(IOERR_EXPECTED_COMMA)            ! 200
		print*, '! Expected , but found %c in input for object %s of NAMELIST/%s/'
    case(IOERR_SUBSTRING_OUT_OF_BOUNDS)   ! 199
		print*, '! Substring (%d:%d) out of bounds in input for object %s of NAMELIST/%s/'
    case(IOERR_ZERO_LENGTH_INPUT)         ! 198
		print*, '! Substring has zero length in input for object %s of NAMELIST/%s/'
    case(IOERR_EXPECTED_COLON)            ! 197
		print*, '! Expected : but found %c in input for object %s of NAMELIST/%s/'
    case(IOERR_BAD_INTEGER_LITERAL)       ! 196
		print*, '! Invalid integer literal in input for object %s of NAMELIST/%s/'
    case(IOERR_ARRAY_OF_ARRAY)            ! 195
		print*, '! Array component of array parent in input for object %s of NAMELIST/%s/'
    case(IOERR_UNKNOWN_COMPONENT)         ! 194
		print*, '! Unknown component \"%s\" in input for object %s of NAMELIST/%s/'
    case(IOERR_COMPONENT_NAME_TOO_LONG)   ! 193
		print*, '! Component name too long in input for object %s of NAMELIST/%s/'
    case(IOERR_UNEXPECTED_COMPONENT)      ! 192
		print*, '! Unexpected component specifier for object %s of NAMELIST/%s/'
    case(IOERR_UNEXPECTED_SUBSCRIPT)      ! 191
		print*, '! Unexpected subscript for object %s of NAMELIST/%s/'
    case(IOERR_UNKNOWN_OBJECT_NAME)       ! 190
		print*, '! Unknown group object \"%s\" in input for NAMELIST/%s/'
    case(IOERR_EXPECTED_EQUALS)           ! 189
		print*, '! Expected ! but found %c in NAMELIST input'
    case(IOERR_OBJECT_NAME_TOO_LONG)      ! 188
		print*, '! NAMELIST group name in input of NAMELIST/%s/ is too long'
    case(IOERR_NAMELIST_BAD_CHAR)         ! 187
		print*, '! Invalid character %c in NAMELIST input'
    case(IOERR_WRONG_NAMELIST)            ! 186
		print*, '! Expected NAMELIST group /%s/ but found /%s/'
    case(IOERR_GROUP_NAME_TOO_LONG)       ! 185
		print*, '! NAMELIST group name in input is too long'
    case(IOERR_NO_AMPERSAND)              ! 184
		print*, '! Expected & but found %c in NAMELIST input'
    case(IOERR_CANNOT_OPEN)               ! 183
		print*, '! Unknown OPEN failure on unit'
    case(IOERR_NO_INPUT_LOGICAL)          ! 182
		print*, '! No value found in LOGICAL input field'
    case(IOERR_BAD_INPUT_LOGICAL)         ! 181
		print*, '! Illegal character in LOGICAL input field'
    case(IOERR_BAD_REC)                   ! 180
		print*, '! Record number out of range'
    case(IOERR_NOT_DIRECT)                ! 179
		print*, '! Unit is not connected for DIRECT i/o'
    case(IOERR_BACKSPACE_FAILED)          ! 178
		print*, '! BACKSPACE failed to find the beginning of the previous record'
    case(IOERR_CANNOT_REWIND)             ! 177
		print*, '! File connected to unit is not capable of REWIND'
    case(IOERR_NEW_FILE_EXISTS)           ! 176
		print*, '! NeW file already exists'
    case(IOERR_NO_OLD_FILE)               ! 175
		print*, '! Cannot find OLD file'
    case(IOERR_NAME_TOO_LONG)             ! 174
		print*, '! File name too long'
    case(IOERR_ENDFILE_TWICE)             ! 173
		print*, '! ENDFILE applied twice to unit with no intervening file positioning'
    case(IOERR_CANNOT_KEEP)               ! 172
		print*, '! STATUS!KEEP is invalid for a SCRATCH file'
    case(IOERR_NO_RECL)                   ! 171
		print*, '! The RECL! specifier must be given for DIRECT access OPEN'
    case(IOERR_BAD_PAD)                   ! 170
		print*, '! Invalid value for PAD! specifier'
    case(IOERR_BAD_DELIM)                 ! 169
		print*, '! Invalid value for DELIM! specifier'
    case(IOERR_BAD_ACTION)                ! 168
		print*, '! INvalid value for ACTION! specifier'
    case(IOERR_BAD_POSITION)              ! 167
		print*, '! Invalid value for POSITION! specifier'
    case(IOERR_BAD_BLANKS)                ! 166
		print*, '! Invalid value for BLANKS! specifier'
    case(IOERR_BAD_FORM)                  ! 165
		print*, '! Invalid value for FORM! specifier'
    case(IOERR_BAD_ACCESS)                ! 164
		print*, '! Invalid value for ACCESS! specifier'
    case(IOERR_BAD_STATUS)                ! 163
		print*, '! Invalid value for STATUS! specifier'
    case(IOERR_DIFFERENT_POSITION)        ! 162
		print*, '! OPEN on connected unit has different POSITION! specifier'
    case(IOERR_DIFFERENT_ACTION)          ! 161
		print*, '! OPEN on connected unit has different ACTION! specifier'
    case(IOERR_DIFFERENT_RECL)            ! 160
		print*, '! OPEN on connected unit has different RECL! specifier'
    case(IOERR_DIFFERENT_FORM)            ! 159
		print*, '! OPEN on connected unit has different FORM! specifier'
    case(IOERR_DIFFERENT_ACCESS)          ! 158
		print*, '! OPEN on connected unit has different ACCESS! specifier'
    case(IOERR_DIFFERENT_STATUS)          ! 157
		print*, '! OPEN on connected unit with STATUS! specifier must have STATUS=OLD'
    case(IOERR_SCRATCH_NAMED)             ! 156
		print*, '! FILE! specifier on OPEN with STATUS=SCRATCH'
    case(IOERR_OLD_UNCONNECTED_NEED_FILE) ! 155
		print*, '! Unit is not connected on OPEN with STATUS!OLD and no FILE= specifier'
    case(IOERR_NOT_UNFORMATTED)           ! 154
		print*, '! Unit is not connected for UNFORMATTED i/o'
    case(IOERR_NOT_WRITE)                 ! 153
		print*, '! Unit is not connected for WRITE action'
    case(IOERR_NOT_FORMATTED)             ! 152
		print*, '! Unit is not connected for FORMATTED i/o'
    case(IOERR_NOT_READ)                  ! 151
		print*, '! Unit is not connected for READ action'
    case(IOERR_NOT_SEQUENTIAL)            ! 150
		print*, '! Unit is not connected for SEQUENTIAL i/o'
    case(IOERR_CANNOT_BACKSPACE)          ! 149
		print*, '! File connected to unit is not capable of BACKSPACE'
    case(IOERR_NOT_CONNECTED)             ! 148
		print*, '! Unit is not connected'
    case(IOERR_BAD_UNIT)                  ! 147
		print*, '! Unit number out of range'
    case(IOERR_READ_AFTER_WRITE)          ! 146
		print*, '! READ after WRITE with no intervening file positioning'
    case(IOERR_BAD_EDIT_FOR_CHARACTER)    ! 145
		print*, '! Invalid edit descriptor for character i/o-list item'
    case(IOERR_BAD_HEX)                   ! 144
		print*, '! Invalid character in hexadecimal integer input field'
    case(IOERR_BAD_OCTAL)                 ! 143
		print*, '! Invalid character in octal integer input field'
    case(IOERR_BAD_BINARY)                ! 142
		print*, '! Invalid character in binary integer input field'
    case(IOERR_BAD_INPUT_INTEGER)         ! 141
		print*, '! Invalid character in integer input field'
    case(IOERR_BAD_INPUT_REAL)            ! 140
		print*, '! Invalid character in real input field'
    case(IOERR_BAD_INPUT_EXPONENT)        ! 139
		print*, '! Invalid exponent in real input field'
    case(IOERR_ONLY_SIGN_FOUND)           ! 138
		print*, '! Sign in a numeric input field not followed by any digits'
    case(IOERR_CHAR_OVERLAPS_END)         ! 137
		print*, '! Character string edit descriptor does not terminate before format end'
    case(IOERR_BAD_EDIT_FOR_LOGICAL)      ! 136
		print*, '! Invalid edit descriptor for logical i/o-list item'
    case(IOERR_BAD_EDIT_FOR_INTEGER)      ! 135
		print*, '! Invalid edit descriptor for integer i/o-list item'
    case(IOERR_BAD_EDIT_FOR_REAL)         ! 134
		print*, '! Invalid edit descriptor for real i/o-list item'
    case(IOERR_CHAR_EDIT_IN_READ)         ! 133
		print*, '! Character string edit descriptor used on input'
    case(IOERR_REPEAT_FOR_POSITION)       ! 132
		print*, '! Repeat factor given for position edit descriptor'
    case(IOERR_NO_SPACING_FOR_X)          ! 131
		print*, '! No spacing specified for X edit descriptor'
    case(IOERR_REPEAT_FOR_CHAR_EDIT)      ! 130
		print*, '! Repeat factor given for character string edit descriptor'
    case(IOERR_MISSING_HOLLERITH_LENGTH)  ! 129
		print*, '! Missing length of H edit descriptor'
    case(IOERR_REPEAT_FOR_BLANK_INTERP)   ! 128
		print*, '! Repeat factor given for blank-interpretation edit descriptor'
    case(IOERR_REPEAT_FOR_SIGN)           ! 127
		print*, '! Repeat factor given for sign edit descriptor'
    case(IOERR_NO_EDIT_FOR_REPEAT)        ! 126
		print*, '! No edit descriptor following repeat factor'
    case(IOERR_BAD_EDIT)                  ! 125
		print*, '! Invalid edit descriptor'
    case(IOERR_BAD_BNBZ)                  ! 124
		print*, '! Expected N or Z following B in format specification'
    case(IOERR_EXPECTED_P)                ! 123
		print*, '! Expected P following signed integer constant in format specification'
    case(IOERR_EXPECTED_PERIOD)           ! 122
		print*, '! Expected decimal point in format specification'
    case(IOERR_FORMAT_MBNZ)               ! 121
		print*, '! Field/exponent width or repeat in format specification must be non-zero'
    case(IOERR_EXPECTED_INTEGER_VALUE)    ! 120
		print*, '! Expected integer literal constant in format specification'
    case(IOERR_UNEXPECTED_FORMAT_END)     ! 119
		print*, '! Unexpected end of format specification'
    case(IOERR_SUBFMT_TOO_DEEP)           ! 118
		print*, '! Sub-format groups nested too deeply'
    case(IOERR_NO_DATA_EDIT_IN_REVERSION) ! 117
		print*, '! No data edit descriptor in tail of format specification after reversion'
    case(IOERR_FORMAT_NO_ENDING_RPAREN)   ! 116
		print*, '! Format specification does not end with a right parenthesis'
    case(IOERR_FORMAT_NO_LPAREN)          ! 115
		print*, '! Format specification does not begin with a left parenthesis'
    case(IOERR_BAD_CHAR)                  ! 114
		print*, '! Invalid input for character editing'
    case(IOERR_BAD_COMPLEX)               ! 113
		print*, '! Invalid input for complex editing'
    case(IOERR_BAD_LOGICAL)               ! 112
		print*, '! Invalid input for logical editing'
    case(IOERR_BAD_REAL)                  ! 111
		print*, '! Invalid input for real editing'
    case(IOERR_INTEGER_TOO_BIG)           ! 110
		print*, '! Input value too large for default INTEGER type'
    case(IOERR_INTEGER_OVERFLOW_REPEAT)   ! 109
		print*, '! Repeat factor in list-directed input larger than HUGE(0)'
    case(IOERR_INTEGER2_TOO_BIG)          ! 108
		print*, '! Input value too large for INTEGER(KIND!2)'
    case(IOERR_INTEGER1_TOO_BIG)          ! 107
		print*, '! Input value too large for INTEGER(KIND!1)'
    case(IOERR_BAD_INTEGER)               ! 106
		print*, '! Invalid input for integer editing'
    case(IOERR_ZERO_REPEAT)               ! 105
		print*, '! Zero repeat factor in list-directed input'
    case(IOERR_INPUT_BUFFER_OVERFLOW)     ! 104
		print*, '! Record too long for input buffer'
    case(IOERR_BAD_EXPONENT)              ! 103
		print*, '! Exponent too large for w.d format'
    case(IOERR_BAD_SCALE)                 ! 102
		print*, '! Scale factor out of range'
    case(IOERR_INTERNAL_FILE_OVERFLOW)    ! 101
		print*, '! Internal file overflow'
    case(IOERR_BUFFER_OVERFLOW)           ! 100
		print*, '! Buffer overflow on output    '
! 
!  Compiler run-time system
!  The following IOSTAT values are defined for the NAGWare f90
!
!  /usr/include/sys/errno.h.
!  status returns.  These are usually documented in the file
!  IOSTAT values between 1 and 99 are reserved for host system
!
    case(IOERR_OK)                        !   0
    case(IOERR_EOF)                       !  -1
    case(IOERR_EOR)                       !  -2             
!
!  The following IOSTAT values are always 
!

! end of included file iostat_rev.f90
    case default           ! 100
		print*, '! iostat not defined in f90_iostat.f90    '
	
end select

  end subroutine print_iostat_msg_NAG

  subroutine SHELL_COMMAND ( Command, Status, Error )
  ! Submit a character variable to the system as a shell command.

    character(len=*), intent(in) :: Command  ! The command
    integer, intent(out), optional :: Status ! Its status, if the system
                                        !  has such a concept, else zero
    integer, intent(out), optional :: Error  ! Status of the routine to submit
                                        ! the command, if the system has
                                        ! such a concept, else zero

    integer :: MyError, MyStatus

    call system ( command, myStatus, myError)
    if ( present(error) ) error = myError
    if ( present(status) ) status = myStatus
  end subroutine SHELL_COMMAND

!---------- Start -gc section
!           requires -gc among LDOPTS
!   (the following lines automatically deleted for version (2))
  subroutine MLS_CONFIG_GC ( EXPAND, FREQUENCY, RETRIES, SILENT )
  ! Configures various parameters affecting garbage collection

    logical, optional, intent(in) :: expand    ! Autoexpand heap?
    integer, optional, intent(in) :: frequency ! How many incremental colls. betw. fulls
    integer, optional, intent(in) :: retries   ! How many attempts before giving up
    logical, optional, intent(in) :: silent    ! Quash report on each collection?
    if ( present(expand) ) dont_expand = .not. expand
    if ( present(frequency) ) full_frequency = frequency
    if ( present(retries) ) max_retries = retries
    if ( present(silent) ) silent_gc = silent
  end subroutine MLS_CONFIG_GC

  subroutine MLS_DISABLE_AUTOGC ( Which )
  ! Turns automatic garbage collection on/off

    character(len=*), intent(in) :: Which  ! 'On' or 'Off'
    if ( Which == 'On' .or. Which == 'ON' &
      & .or. Which == 'on' ) then
      DONT_GC = .false.
    else
      DONT_GC = .true.
    endif
  end subroutine MLS_DISABLE_AUTOGC

  subroutine MLS_GC_NOW
  ! Manually collects garbage when called

    CALL GCOLLECT
  end subroutine MLS_GC_NOW

  integer function MLS_HOWMANY_GC()
  ! Returns how many garbage collections have been performed

    MLS_HOWMANY_GC = NCOLLECTIONS()
  end function MLS_HOWMANY_GC
!---------- End -gc section
!---------- Start no -gc section
!           forbids -gc among LDOPTS
!   (the following lines automatically deleted for version (1))
  ! ----------------------------------------------
  ! The following are merely introduced to satisfy 
  ! NAG call interfaces to f90_gc
  ! Because we're assuming the link statement will lack -gc
  ! we have non-functional substitutes
  subroutine MLS_CONFIG_GC ( EXPAND, FREQUENCY, RETRIES, SILENT )
  ! Configures various parameters affecting garbage collection
   logical dont_EXPAND, SILENT_GC
   integer full_frequency, max_retries
    logical, optional, intent(in) :: expand    ! Autoexpand heap?
    integer, optional, intent(in) :: frequency ! How many incremental colls. betw. fulls
    integer, optional, intent(in) :: retries   ! How many attempts before giving up
    logical, optional, intent(in) :: silent    ! Quash report on each collection?
    if ( present(expand) ) dont_expand = .not. expand
    if ( present(frequency) ) full_frequency = frequency
    if ( present(retries) ) max_retries = retries
    if ( present(silent) ) silent_gc = silent
  end subroutine MLS_CONFIG_GC

  subroutine MLS_DISABLE_AUTOGC ( Which )
  ! Turns automatic garbage collection on/off
    character(len=*), intent(in) :: Which  ! 'On' or 'Off'
    logical dont_gc
    if ( Which == 'On' .or. Which == 'ON' &
      & .or. Which == 'on' ) then
      DONT_GC = .false.
    else
      DONT_GC = .true.
    endif
  end subroutine MLS_DISABLE_AUTOGC

  subroutine MLS_GC_NOW
  ! Manually collects garbage when called
  !    CALL GCOLLECT
  end subroutine MLS_GC_NOW

  integer function MLS_HOWMANY_GC()
  ! Returns how many garbage collections have been performed
    MLS_HOWMANY_GC = 0 ! NCOLLECTIONS()
  end function MLS_HOWMANY_GC
!---------- End no -gc section

  ! ----------------------------------------------  not_used_here  -----
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: read_apriori.f90 is it here $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MACHINE

! $Log: machine.f90,v $
! Revision 1.9  2005/06/22 20:26:22  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.8  2004/08/19 00:13:13  pwagner
! Added crash_burn to provoke crash with walkback
!
! Revision 1.7  2002/02/08 18:31:50  pwagner
! Now stores -gc and no-gc versions in same machine.f90
!
! Revision 1.6  2002/02/05 00:37:19  pwagner
! Added garbage collection features
!
! Revision 1.5  2002/01/31 19:16:28  pwagner
! Brought up-to-date with shell_command using library as appropriate; untested
!
! Revision 1.4  2001/05/15 20:34:37  pwagner
! Compatible with NAG f95-V4.1
!
! Revision 1.3  2001/05/08 22:10:28  pwagner
! Imitated Exit_With_Status routine for Linux
!
! Revision 1.2  2001/03/21 00:42:34  pwagner
! Added print_iostat_msg_NAG
!
! Revision 1.1  2001/01/13 00:29:44  pwagner
! moved to lib/machines/MLSCONFG/machine.f90
@


1.9
log
@Reworded Copyright statement, moved rcs id
@
text
@d519 1
a520 1
!---------------------------- RCS Ident Info -------------------------------
d522 2
a523 3
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d525 1
d527 1
d532 3
@


1.8
log
@Added crash_burn to provoke crash with walkback
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d50 1
a50 5
  private :: NOT_USED_HERE

!---------------------------- RCS Ident Info -------------------------------
  character (len=256), private :: Id = &
       "$Id: machine.f90,v 1.7 2002/02/08 18:31:50 pwagner Exp $"
d52 2
a53 1
       "$RCSfile: machine.f90,v $"
d520 5
d531 3
@


1.7
log
@Now stores -gc and no-gc versions in same machine.f90
@
text
@d40 4
d46 1
a46 1
       "$Id: machine.f90,v 1.6 2002/02/05 00:37:19 pwagner Exp $"
d53 44
d513 5
d521 3
@


1.6
log
@Added garbage collection features
@
text
@d5 17
d24 1
d42 1
a42 1
       "$Id: machine.f90,v 1.5 2002/01/31 19:16:28 pwagner Exp $"
d380 3
d415 1
a415 1
  ! Retuyrns how many garbage collections have been performed
d419 45
d468 3
@


1.5
log
@Brought up-to-date with shell_command using library as appropriate; untested
@
text
@d5 2
d20 1
d24 1
a24 1
       "$Id: machine.f90,v 1.4 2001/05/15 20:34:37 pwagner Exp $"
d362 37
d402 3
a415 16
!
! Revision 1.1  2000/10/19 17:40:52  pwagner
! first commit
!
! Revision 1.2  2000/10/12 22:54:12  vsnyder
! Correct a commented-out line that may get commented-in for another
! computer/os/compiler combination
!
! Revision 1.1  2000/10/12 22:21:11  vsnyder
! Change directory name from NAG to pclinuxNAG
!
! Revision 1.3  2000/10/09 22:15:55  vsnyder
! Moved machine.f90 from l2 to lib
!
! Revision 2.0  2000/09/05 18:58:04  ahanzel
! Changing file revision to 2.0.
@


1.4
log
@Compatible with NAG f95-V4.1
@
text
@d1 3
d5 1
a6 1
  use F90_iostat				! everything; see iostat_msg_NAG
d8 1
a8 1
  use F90_UNIX_PROC, only: EXIT_WITH_STATUS => EXIT
d17 1
d21 1
a21 1
       "$Id: machine.f90,v 1.3 2001/05/08 22:10:28 pwagner Exp $"
d342 17
d362 3
@


1.3
log
@Imitated Exit_With_Status routine for Linux
@
text
@d17 1
a17 1
       "$Id: machine.f90,v 1.2 2001/03/21 00:42:34 pwagner Exp $"
d79 2
d89 2
a90 2
!    case(IOERR_NO_FILE_WITH_REPLACE)      ! 212
!		print*, '! No FILE! specifier with STATUS=REPLACE'
d200 1
a200 1
		print*, '! OPEN on connected unit has different STATUS! specifier'
d203 2
a204 2
!    case(IOERR_NOT_CONNECTED_NO_FILENAME) ! 155
!		print*, '! Unit is not connected and no FILE! specifier on OPEN'
d341 3
@


1.2
log
@Added print_iostat_msg_NAG
@
text
@d4 2
d17 1
a17 1
       "$Id: machine.f90,v 1.1 2001/01/13 00:29:44 pwagner Exp $"
d87 2
a88 2
    case(IOERR_NO_FILE_WITH_REPLACE)      ! 212
		print*, '! No FILE! specifier with STATUS=REPLACE'
d201 2
a202 2
    case(IOERR_NOT_CONNECTED_NO_FILENAME) ! 155
		print*, '! Unit is not connected and no FILE! specifier on OPEN'
d339 3
@


1.1
log
@moved to lib/machines/MLSCONFG/machine.f90
@
text
@d3 1
d15 1
a15 1
       "$Id: NAG.SGI.machine,v 1.1 2000/10/21 00:16:25 pwagner Exp $"
d17 1
a17 1
       "$RCSfile: NAG.SGI.machine,v $"
d36 1
a36 1
!   call iostat_msg (iostat, msg)       ! Lahey intrinsic
d50 284
d336 3
a338 3
! $Log: NAG.SGI.machine,v $
! Revision 1.1  2000/10/21 00:16:25  pwagner
! First commit
@

