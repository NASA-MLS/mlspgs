head	1.5;
access;
symbols
	v5-02-NRT-19:1.5
	v6-00:1.5
	v5-02-NRT-18:1.5
	v5-02:1.5
	v5-01-NRT-17:1.5
	v5-01-NRT-16:1.5
	v5-01-NRT-15:1.5
	v5-01-NRT-14:1.5
	neuralnetworks-1-0:1.5.0.14
	cfm-single-freq-0-1:1.5.0.12
	v5-01:1.5
	v5-00:1.5
	v4-23-TA133:1.5.0.10
	mus-emls-1-70:1.5.0.8
	rel-1-0-englocks-work:1.5.0.6
	VUMLS1-00:1.5
	VPL1-00:1.5
	V4-22-NRT-08:1.5
	VAM1-00:1.5
	V4-21:1.5.0.4
	V4-13:1.5
	V4-12:1.5
	V4-11:1.5
	V4-10:1.5
	V3-43:1.5
	M4-00:1.5
	V3-41:1.5
	V3-40-PlusGM57:1.5.0.2
	V2-24-NRT-04:1.3
	V3-33:1.5
	V2-24:1.3
	V3-31:1.5
	V3-30-NRT-05:1.5
	cfm-01-00:1.5
	V3-30:1.5
	V3-20:1.5
	V3-10:1.5
	V2-23-NRT-02:1.3
	V2-23:1.3
	V2-22-NRT-01:1.3
	V2-22:1.3
	V2-21:1.3
	V2-20:1.3
	V2-11:1.3
	V2-10:1.3
	V2-00:1.3
	V1-51:1.2
	V1-50:1.2
	V1-45:1.2
	V1-44:1.2
	V1-43:1.2;
locks; strict;
comment	@# @;


1.5
date	2009.06.23.19.58.52;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.23.18.25.44;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.22.20.26.22;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.29.18.49.56;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2004.03.26.21.15.00;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Prevent Intel from optimizing ident string away
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module Inf_NaN_Detection 
  !(Because Lahey fails to conform to ISO/IEC TR15580:1998(E).
  ! If we should ever obtain one that conforms we may cheerfully
  ! dispose of this crude hack. At least they had the grace to supply it
!=============================================================================

!!     Inf_NaN_Detection module 
!!     Originally Copyright(c) 2003, Lahey Computer Systems, Inc.
!!     Copies of this source code, or standalone compiled files 
!!     derived from this source may not be sold without permission
!!     from Lahey Computers Systems. All or part of this module may be 
!!     freely incorporated into executable programs which are offered
!!     for sale. Otherwise, distribution of all or part of this file is
!!     permitted, provided this copyright notice and header are included.

!!     This module exposes four elemental functions:
!!
!!     isnan(x)    - test for a "not a number" value
!!
!!     isinf(x)    - test for either a positive or negative "infinite" value
!!
!!     isposinf(x) - test for a positive "infinite" value
!!
!!     isneginf(x) - test for a negative "infinite" value
!!
!!     Each function accepts a single or double precision real argument, and
!!     returns a true or false value to indicate the presence of the value 
!!     being tested for. If the argument is array valued, the function returns
!!     a conformable logical array, suitable for use with the ANY function, or
!!     as a logical mask.
!!
!!     Each function operates by transferring the bit pattern from a real 
!!     variable to an integer container. Unless testing for + or - infinity,
!!     the sign bit is cleared to zero. The value is exclusive ORed with
!!     the value being tested for. The integer result of the IEOR function is
!!     converted to a logical result by comparing it to zero.
!!

    implicit none

    private

    public :: isnan, isinf, isposinf, isneginf

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: $"
  private :: not_used_here 
!---------------------------------------------------------------------------

    ! Kind numbers for single and double precision integer containers
    integer, parameter :: Single = selected_int_kind(precision(1.e0))
    integer, parameter :: Double = selected_int_kind(precision(1.d0))

    ! Single precision IEEE values
    integer(Single), parameter :: sNaN    = Z"7FC00000"
    integer(Single), parameter :: sPosInf = Z"7F800000"
    integer(Single), parameter :: sNegInf = Z"FF800000"

    ! Double precision IEEE values
    integer(Double), parameter :: dNaN    = Z"7FF8000000000000"
    integer(Double), parameter :: dPosInf = Z"7FF0000000000000"
    integer(Double), parameter :: dNegInf = Z"FFF0000000000000"

    ! Locatation of single and double precision sign bit (Intel)
    ! Subtract one because bit numbering starts at zero
    integer, parameter :: SPSB = bit_size(sNaN) - 1
    integer, parameter :: DPSB = bit_size(dNaN) - 1
    
    logical, parameter :: USELAHEYSOWNBUGGYTESTS = .false. ! Should tell 'em
    logical, parameter :: USEIOSTRING = .false. ! Something of a hack

   interface isnan
      module procedure sisnan
      module procedure disnan
   end interface   

   interface isinf
      module procedure sisinf
      module procedure disinf
   end interface   
   
   interface isposinf
      module procedure sisposinf
      module procedure disposinf
   end interface   
   
   interface isneginf
      module procedure sisneginf
      module procedure disneginf
   end interface   
   
contains    

  ! Single precision test for NaN
  elemental function sisnan(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    if ( USELAHEYSOWNBUGGYTESTS ) then
      res = sisnan_lahey(x)
    elseif ( USEIOSTRING ) then
      res = sisnan_io(x)
    else
      res = sisnan_jpl(x)
    endif
  end function  

  ! Double precision test for NaN
  elemental function disnan(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    if ( USELAHEYSOWNBUGGYTESTS ) then
      res = disnan_lahey(d)
    elseif ( USEIOSTRING ) then
      res = disnan_io(d)
    else
      res = disnan_jpl(d)
    endif
  end function  
  
  ! Single precision test for NaN
  elemental function sisnan_io(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    character(len=80) :: reschar
    write(reschar, *) x
    res = ( index(reschar, 'NaN') > 0 )
  end function  

  ! Double precision test for NaN
  elemental function disnan_io(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    character(len=80) :: reschar
    write(reschar, *) d
    res = ( index(reschar, 'NaN') > 0 )
  end function  
  
  ! Single precision test for NaN
  elemental function sisnan_jpl(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    res = ( x /= x )
  end function  

  ! Double precision test for NaN
  elemental function disnan_jpl(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    res = ( d /= d )
  end function  
  
  ! Single precision test for NaN
  elemental function sisnan_lahey(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    res = ieor(ibclr(transfer(x,sNan),SPSB), sNaN) == 0
  end function  

  ! Double precision test for NaN
  elemental function disnan_lahey(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    res = ieor(ibclr(transfer(d,dNaN),DPSB), dNaN) == 0
  end function  
  
  ! Single precision test for Inf
  elemental function sisinf(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    res = ieor(ibclr(transfer(x,sPosInf),SPSB), sPosInf) == 0
  end function  

  ! Double precision test for Inf
  elemental function disinf(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    res = ieor(ibclr(transfer(d,dPosInf),DPSB), dPosInf) == 0
  end function  
  
  ! Single precision test for +Inf
  elemental function sisposinf(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    res = ieor(transfer(x,sPosInf), sPosInf) == 0
  end function  

  ! Double precision test for +Inf
  elemental function disposinf(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    res = ieor(transfer(d,dPosInf), dPosInf) == 0
  end function  
  
  ! Single precision test for -Inf
  elemental function sisneginf(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    res = ieor(transfer(x,sNegInf), sNegInf) == 0
  end function  

  ! Double precision test for -Inf
  elemental function disneginf(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    res = ieor(transfer(d,dNegInf), dNegInf) == 0
  end function  
  
!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: read_apriori.f90 is it here $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

!=============================================================================
end module Inf_NaN_Detection
!=============================================================================

!
! $Log: infnan.f90,v $
! Revision 1.4  2009/06/23 18:25:44  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 1.3  2005/06/22 20:26:22  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.2  2004/03/29 18:49:56  pwagner
! Fixed buggy Lahey NaN detection
!
! Revision 1.1  2004/03/26 21:15:00  pwagner
! FIrst commit
!
@


1.4
log
@Prevent Intel from optimizing ident string away
@
text
@d59 1
a59 1
       "$RCSfile: infnan.f90,v $"
d222 1
a223 1
!---------------------------- RCS Ident Info -------------------------------
d225 2
a226 3
       "$Id: infnan.f90,v 1.3 2005/06/22 20:26:22 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d228 1
d230 1
d238 3
@


1.3
log
@Reworded Copyright statement, moved rcs id
@
text
@d11 46
a56 46

!=============================================================================
module Inf_NaN_Detection 
  !(Because Lahey fails to conform to ISO/IEC TR15580:1998(E).
  ! If we should ever obtain one that conforms we may cheerfully
  ! dispose of this crude hack. At least they had the grace to supply it
!=============================================================================

!!     Inf_NaN_Detection module 
!!     Originally Copyright(c) 2003, Lahey Computer Systems, Inc.
!!     Copies of this source code, or standalone compiled files 
!!     derived from this source may not be sold without permission
!!     from Lahey Computers Systems. All or part of this module may be 
!!     freely incorporated into executable programs which are offered
!!     for sale. Otherwise, distribution of all or part of this file is
!!     permitted, provided this copyright notice and header are included.

!!     This module exposes four elemental functions:
!!
!!     isnan(x)    - test for a "not a number" value
!!
!!     isinf(x)    - test for either a positive or negative "infinite" value
!!
!!     isposinf(x) - test for a positive "infinite" value
!!
!!     isneginf(x) - test for a negative "infinite" value
!!
!!     Each function accepts a single or double precision real argument, and
!!     returns a true or false value to indicate the presence of the value 
!!     being tested for. If the argument is array valued, the function returns
!!     a conformable logical array, suitable for use with the ANY function, or
!!     as a logical mask.
!!
!!     Each function operates by transferring the bit pattern from a real 
!!     variable to an integer container. Unless testing for + or - infinity,
!!     the sign bit is cleared to zero. The value is exclusive ORed with
!!     the value being tested for. The integer result of the IEOR function is
!!     converted to a logical result by comparing it to zero.
!!

    implicit none

    private

    public :: isnan, isinf, isposinf, isneginf

d59 1
a59 1
       "$RCSfile: $"
d62 160
a221 160

    ! Kind numbers for single and double precision integer containers
    integer, parameter :: Single = selected_int_kind(precision(1.e0))
    integer, parameter :: Double = selected_int_kind(precision(1.d0))

    ! Single precision IEEE values
    integer(Single), parameter :: sNaN    = Z"7FC00000"
    integer(Single), parameter :: sPosInf = Z"7F800000"
    integer(Single), parameter :: sNegInf = Z"FF800000"

    ! Double precision IEEE values
    integer(Double), parameter :: dNaN    = Z"7FF8000000000000"
    integer(Double), parameter :: dPosInf = Z"7FF0000000000000"
    integer(Double), parameter :: dNegInf = Z"FFF0000000000000"

    ! Locatation of single and double precision sign bit (Intel)
    ! Subtract one because bit numbering starts at zero
    integer, parameter :: SPSB = bit_size(sNaN) - 1
    integer, parameter :: DPSB = bit_size(dNaN) - 1
    
    logical, parameter :: USELAHEYSOWNBUGGYTESTS = .false. ! Should tell 'em
    logical, parameter :: USEIOSTRING = .false. ! Something of a hack

   interface isnan
      module procedure sisnan
      module procedure disnan
   end interface   

   interface isinf
      module procedure sisinf
      module procedure disinf
   end interface   
   
   interface isposinf
      module procedure sisposinf
      module procedure disposinf
   end interface   
   
   interface isneginf
      module procedure sisneginf
      module procedure disneginf
   end interface   
   
contains    

  ! Single precision test for NaN
  elemental function sisnan(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    if ( USELAHEYSOWNBUGGYTESTS ) then
      res = sisnan_lahey(x)
    elseif ( USEIOSTRING ) then
      res = sisnan_io(x)
    else
      res = sisnan_jpl(x)
    endif
  end function  

  ! Double precision test for NaN
  elemental function disnan(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    if ( USELAHEYSOWNBUGGYTESTS ) then
      res = disnan_lahey(d)
    elseif ( USEIOSTRING ) then
      res = disnan_io(d)
    else
      res = disnan_jpl(d)
    endif
  end function  
  
  ! Single precision test for NaN
  elemental function sisnan_io(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    character(len=80) :: reschar
    write(reschar, *) x
    res = ( index(reschar, 'NaN') > 0 )
  end function  

  ! Double precision test for NaN
  elemental function disnan_io(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    character(len=80) :: reschar
    write(reschar, *) d
    res = ( index(reschar, 'NaN') > 0 )
  end function  
  
  ! Single precision test for NaN
  elemental function sisnan_jpl(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    res = ( x /= x )
  end function  

  ! Double precision test for NaN
  elemental function disnan_jpl(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    res = ( d /= d )
  end function  
  
  ! Single precision test for NaN
  elemental function sisnan_lahey(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    res = ieor(ibclr(transfer(x,sNan),SPSB), sNaN) == 0
  end function  

  ! Double precision test for NaN
  elemental function disnan_lahey(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    res = ieor(ibclr(transfer(d,dNaN),DPSB), dNaN) == 0
  end function  
  
  ! Single precision test for Inf
  elemental function sisinf(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    res = ieor(ibclr(transfer(x,sPosInf),SPSB), sPosInf) == 0
  end function  

  ! Double precision test for Inf
  elemental function disinf(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    res = ieor(ibclr(transfer(d,dPosInf),DPSB), dPosInf) == 0
  end function  
  
  ! Single precision test for +Inf
  elemental function sisposinf(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    res = ieor(transfer(x,sPosInf), sPosInf) == 0
  end function  

  ! Double precision test for +Inf
  elemental function disposinf(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    res = ieor(transfer(d,dPosInf), dPosInf) == 0
  end function  
  
  ! Single precision test for -Inf
  elemental function sisneginf(x) result(res)
    real(kind(1.e0)), intent(in) :: x
    logical :: res
    res = ieor(transfer(x,sNegInf), sNegInf) == 0
  end function  

  ! Double precision test for -Inf
  elemental function disneginf(d) result(res)
    real(kind(1.d0)), intent(in) :: d
    logical :: res
    res = ieor(transfer(d,dNegInf), dNegInf) == 0
  end function  
  
!=============================================================================
d225 1
a225 1
       "$Id: $"
d230 6
a235 6

!=============================================================================
end module Inf_NaN_Detection
!=============================================================================

!
d237 3
d242 4
a245 4
!
! Revision 1.1  2004/03/26 21:15:00  pwagner
! FIrst commit
!
@


1.2
log
@Fixed buggy Lahey NaN detection
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d57 5
a61 8
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       & "$Id: infnan.f90,v 1.1 2004/03/26 21:15:00 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
  character(len=*), parameter, private :: ModuleName = &
       & "$RCSfile: infnan.f90,v $"
  private :: not_used_here 
  !---------------------------------------------------------------------------
d222 8
a229 3
  logical function not_used_here()
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
d236 4
a239 1
! $Log: infnan.f90,v $
@


1.1
log
@FIrst commit
@
text
@d51 1
a51 1
       & "$Id: L2GPData.f90,v 2.98 2004/03/24 23:53:02 pwagner Exp $"
d54 1
a54 1
       & "$RCSfile: L2GPData.f90,v $"
d77 3
d106 58
d168 1
a168 1
  elemental function disnan(d) result(res)
d226 4
a229 1
! $Log: L2GPData.f90,v $
@

