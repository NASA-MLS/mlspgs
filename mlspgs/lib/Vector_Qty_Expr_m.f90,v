head	2.5;
access;
symbols
	v5-02-NRT-19:2.5
	v6-00:2.5
	v5-02-NRT-18:2.5
	v5-02:2.5
	v5-01-NRT-17:2.5
	v5-01-NRT-16:2.5
	v5-01-NRT-15:2.5
	v5-01-NRT-14:2.5
	neuralnetworks-1-0:2.5.0.12
	cfm-single-freq-0-1:2.5.0.10
	v5-01:2.5
	v5-00:2.5
	v4-23-TA133:2.5.0.8
	mus-emls-1-70:2.5.0.6
	rel-1-0-englocks-work:2.5.0.4
	VUMLS1-00:2.5
	VPL1-00:2.5
	V4-22-NRT-08:2.5
	VAM1-00:2.5
	V4-21:2.5.0.2
	V4-13:2.5
	V4-12:2.5
	V4-11:2.5
	V4-10:2.5;
locks; strict;
comment	@# @;


2.5
date	2014.03.20.01.39.47;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2013.09.24.23.27.14;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2013.09.21.00.36.23;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2013.09.19.23.24.11;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2013.09.19.23.23.10;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.5
log
@Unified types in Intrinsic
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

module Vector_Qty_Expr_m

  ! Evaluate an expression for which the value is a vector quantity
  ! or a number.

  ! Descriptions of expression results.  If Dot the result is a vector
  ! quantity.  If T_Boolean or T_Numeric the result is a number, being
  ! either L_True or L_False in the T_Boolean case.  If negative, an error
  ! occurred.

  use Intrinsic, only: L_False, L_True, Dot => T_A_dot_B, T_Boolean, T_Numeric

  implicit NONE
  private

  public :: Dot, Vector_Qty_Expr

  ! Error codes
  integer, private, parameter :: Bad_Operator = 1
  integer, private, parameter :: Bad_Terminal = bad_operator + 1
  integer, private, parameter :: Incompatible = bad_terminal + 1
  integer, private, parameter :: NotFunc = incompatible + 1
  integer, private, parameter :: OutOfRange = notFunc + 1
  integer, private, parameter :: UnsupportedFunc = outOfRange + 1
  integer, private, parameter :: WrongNumArgs = unsupportedFunc + 1
  integer, private, parameter :: WrongUnits = wrongNumArgs + 1

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Vector_Qty_Expr_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains ! ====     Public Procedures     ==============================

  ! --------------------------------------------  Vector_Qty_Expr  -----
  recursive integer function Vector_Qty_Expr ( Root, Vectors, Qty, Number, &
    & Units, ForWhom ) result ( Stat )

    ! Evaluate an expression.  The result is
    !   Dot => result is a vector quantity, and Qty is that quantity;
    !          this is always a new quantity, and needs to be destroyed.
    !          Number is undefined.
    !   T_Numeric => result is a number, and Number is its value.  Qty is
    !          undefined.
    !   T_Boolean => result is boolean and Number is either L_True or L_False
    !  <0 =>   an error occurred, and both Qty and Number are undefined; the
    !          value is the negative of the error code.
    ! Range (colon, etc.) and power (^) are not supported.  The only
    ! functions supported are exp, ln, log, log10, and sqrt.
    ! Boolean-valued operators set values to l_true for true, l_false for false

    use Declaration_Table, only: Decls, Function, Get_Decl, Units_Name
    use Functions, only: F_Exp, F_Ln, F_Log, F_Log10, F_Sqrt
    use Intrinsic, only: PHYQ_Dimensionless, PHYQ_Invalid
    use QuantityTemplates, only: NullifyQuantityTemplate, QuantitiesAreCompatible
    use String_Table, only: Float_Value
    use Toggles, only: Gen, Toggle
    use Trace_m, only: Trace_Begin, Trace_End
    use Tree, only: Decoration, Node_ID, NSons, Sub_Rosa, Subtree
    use Tree_Types, only: Last_Tree_Node, N_And, N_Div, N_Dot, N_Equal_Equal, &
      N_Func_Ref, N_Greater, N_Greater_Eq, N_Identifier, N_Into, N_Less,      &
      N_Less_eq, N_Minus, N_Mult, N_Not, N_Not_Equal, N_Null, N_Number, N_Or, &
      N_Plus, N_String, N_Unit
    use VectorsModule, only: CloneVectorQuantity, &
      & DestroyVectorQuantityMask, &
      & DestroyVectorQuantityValue, GetVectorQtyByTemplateIndex, &
      & Vector_t, VectorValue_t
    integer, intent(in) :: Root               ! Tree node index
    type(vector_t), intent(in) :: Vectors(:)  ! Vectors database
    type(vectorValue_t), intent(out) :: Qty   ! Result quantity
    double precision, intent(out) :: Number   ! Result number
    integer, intent(out) :: Units             ! PHYQ_... if numeric result,
                                              ! else PHYQ_Invalid
    character(*), intent(in), optional :: ForWhom

    integer, parameter :: Neither = 0, Both = 1, Left = 2, Right = 3 ! Values for Case
    integer :: Case                      ! Which operands are vector quantities
    type(decls) :: Decl                  ! Of a function reference
    integer :: Me = -1                   ! String index for trace cacheing
    integer :: Qty_Index                 ! in the vector
    type(vectorValue_t) :: Qty_1, Qty_2  ! Vector quantity operands
    integer :: Son1, Son2                ! Function name, arg tree nodes
    integer :: Stat_1, Stat_2            ! Function result statuses
    integer :: String                    ! Function name
    integer :: Types(n_null+1:last_tree_node)
    integer :: Units_1, Units_2
    double precision :: Value_1, Value_2 ! Numeric operands
    integer :: Vector_Index              ! in the Vectors database
    integer :: What                      ! Tree node ID

    data types(n_and)         / t_boolean /
    data types(n_dot)         / dot /
    data types(n_div)         / t_numeric /
    data types(n_equal_equal) / t_boolean /
    data types(n_greater_eq)  / t_boolean /
    data types(n_greater)     / t_boolean /
    data types(n_into)        / t_numeric /
    data types(n_less_eq)     / t_boolean /
    data types(n_less)        / t_boolean /
    data types(n_minus)       / t_numeric /
    data types(n_mult)        / t_numeric /
    data types(n_not_equal)   / t_boolean /
    data types(n_not)         / t_boolean /
    data types(n_number)      / t_numeric /
    data types(n_or)          / t_boolean /
    data types(n_plus)        / t_numeric /

    call trace_begin ( me, 'Vector_Qty_Expr', root, cond=toggle(gen) )
    what = node_id(root)
    if ( any(what == (/ n_and,        n_div,    n_dot,     n_equal_equal, &
                      & n_greater,    n_into,   n_less_eq, n_less,        &
                      & n_greater_eq, n_minus,  n_mult,    n_not_equal,   &
                      & n_not,        n_number, n_or,      n_plus /) )  ) &
      & stat=types(what)
    call nullifyQuantityTemplate ( qty%template )
    units = phyq_invalid

    if ( nsons(root) <= 1 ) then
      select case ( what )
      case ( n_number ) ! ----------------------------------------------
        number = float_value(sub_rosa(root))
        units = phyq_dimensionless
      case ( n_not ) ! -------------------------------------------------
        stat = vector_qty_expr ( subtree(1,root), vectors, qty, value_1, units_1 )
        select case ( stat )
        case ( dot )
          qty%values = 1 - qty%values
        case ( t_boolean )
          number = merge(l_false,l_true,value_1==l_true)
        end select
      case ( n_minus ) ! -----------------------------------------------
        stat = vector_qty_expr ( subtree(1,root), vectors, qty, value_1, units )
        select case ( stat )
        case ( dot )
          qty%values = - qty%values
        case ( t_numeric )
          number = - value_1
        end select
      case ( n_plus ) ! ------------------------------------------------
        stat = vector_qty_expr ( subtree(1,root), vectors, qty, value_1, units )
        select case ( stat )
        case ( dot )
          qty%values = qty%values
        case ( t_numeric )
          number = value_1
        end select
      case default
        stat = announce_error ( root, bad_operator )
      end select
    else
      select case ( what )
      case ( n_func_ref ) ! --------------------------------------------
        son1 = subtree(1,root)
        ! Look up the function name
        string = sub_rosa(son1)
        decl = get_decl(string,function)
        if ( decl%type /= function ) then
          stat = announce_error ( son1, notFunc )
        else
          if ( nsons(root) /= 2 ) then
            stat = announce_error ( root, wrongNumArgs )
          else
            son2 = subtree(2,root)
            stat = vector_qty_expr ( son2, vectors, qty, value_1, units )
            if ( stat /= dot .and. units /= phyq_dimensionless ) then
              stat = announce_error ( son1, wrongUnits )
    go to 9
            end if
            select case ( decl%units )
            case ( f_exp ) ! ...........................................
              select case ( stat )
              case ( dot )
                if ( any(qty%values > log(huge(qty%values(1,1)))) ) then
                  stat = announce_error ( son2, outOfRange )
                else
                  qty%values = exp(qty%values)
                end if
              case ( t_numeric )
                if ( number > log(huge(number)) ) then
                  stat = announce_error ( son2, outOfRange, number=number )
                else
                  number = exp(value_1)
                end if
              end select
            case ( f_ln, f_log ) ! .....................................
              select case ( stat )
              case ( dot )
                if ( any(qty%values <= 0.0) ) then
                  stat = announce_error ( son2, outOfRange )
                else
                  qty%values = log(qty%values)
                end if
              case ( t_numeric )
                if ( number < 0.0 ) then
                  stat = announce_error ( son2, outOfRange, number=number )
                else
                  number = log(value_1)
                end if
              end select
            case ( f_log10 ) ! .........................................
              select case ( stat )
              case ( dot )
                if ( any(qty%values <= 0.0) ) then
                  stat = announce_error ( son2, outOfRange )
                else
                  qty%values = log10(qty%values)
                end if
              case ( t_numeric )
                if ( number < 0.0 ) then
                  stat = announce_error ( son2, outOfRange, number=number )
                else
                  number = log10(value_1)
                end if
              end select
            case ( f_sqrt ) ! ..........................................
              select case ( stat )
              case ( dot )
                if ( any(qty%values < 0.0) ) then
                  stat = announce_error ( son2, outOfRange )
                else
                  qty%values = sqrt(qty%values)
                end if
              case ( t_numeric )
                if ( number < 0.0 ) then
                  stat = announce_error ( son2, outOfRange, number=number )
                else
                  number = sqrt(value_1)
                end if
              end select
            case default
              stat = announce_error ( son1, unsupportedFunc )
            end select
          end if
        end if
      case ( n_less, n_less_eq, n_greater, n_greater_eq, n_equal_equal, &
           & n_not_equal, n_and, n_or, n_plus, n_minus, n_mult, n_div,  &
           & n_into ) ! ------------------------------------------------
        stat_1 = vector_qty_expr ( subtree(1,root), vectors, qty_1, value_1, units_1 )
        units = units_1
        stat = stat_1
        stat_2 = vector_qty_expr ( subtree(2,root), vectors, qty_2, value_2, units_2 )
        if ( stat_1 == dot .and. stat_2 == dot ) then
          if ( .not. QuantitiesAreCompatible(qty_1%template, qty_2%template) ) then
            stat = announce_error ( root, incompatible )
    go to 9
          end if
  !??? Do we want to check masks here?
          call cloneVectorQuantity ( qty, qty_1, options='d' )
          qty%label = 0
          if ( qty_1%template%name /= qty_2%template%name ) qty%template%name = 0
          case = both
        else if ( stat_1 == dot ) then
          call cloneVectorQuantity ( qty, qty_1, options='d' )
          qty%label = 0
          case = left
        else if ( stat_2 == dot ) then
          call cloneVectorQuantity ( qty, qty_2, options='d' )
          qty%label = 0
          stat = dot
          case = right
        else
          case = neither
          select case ( what )
          case ( n_less, n_less_eq, n_greater, n_greater_eq, n_equal_equal, &
            & n_not_equal, n_plus, n_minus )
            if ( units_1 /= units_2 ) stat = announce_error ( root, wrongUnits )
          end select
        end if
        if ( case /= both ) qty%template%name = 0
        select case ( what )
        case ( n_less ) ! ----------------------------------------------
          select case ( case )
          case ( neither )
            number = merge(1, 0, value_1 < value_2)
          case ( both )
            where ( qty_1%values < qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( left )
            where ( qty_1%values < value_2 )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( right )
            where ( value_1 < qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          end select
        case ( n_less_eq ) ! -------------------------------------------
          select case ( case )
          case ( neither )
            number = merge(1, 0, value_1 <= value_2)
          case ( both )
            where ( qty_1%values <= qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( left )
            where ( qty_1%values <= value_2 )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( right )
            where ( value_1 <= qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          end select
        case ( n_greater ) ! -------------------------------------------
          select case ( case )
          case ( neither )
            number = merge(1, 0, value_1 > value_2)
          case ( both )
            where ( qty_1%values > qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( left )
            where ( qty_1%values > value_2 )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( right )
            where ( value_1 > qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          end select
        case ( n_greater_eq ) ! ----------------------------------------
          select case ( case )
          case ( neither )
            number = merge(1, 0, value_1 >= value_2)
          case ( both )
            where ( qty_1%values > qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( left )
            where ( qty_1%values > value_2 )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( right )
            where ( value_1 > qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          end select
        case ( n_equal_equal ) ! ---------------------------------------
          select case ( case )
          case ( neither )
            number = merge(1, 0, value_1 == value_2)
          case ( both )
            where ( qty_1%values == qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( left )
            where ( qty_1%values == value_2 )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( right )
            where ( value_1 == qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          end select
        case ( n_not_equal ) ! -----------------------------------------
          select case ( case )
          case ( neither )
            number = merge(1, 0, value_1 /= value_2)
          case ( both )
            where ( qty_1%values /= qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( left )
            where ( qty_1%values /= value_2 )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          case ( right )
            where ( value_1 /= qty_2%values )
              qty%values = 1
            elsewhere
              qty%values = 0
            end where
          end select
        case ( n_and ) ! -----------------------------------------------
          select case ( case )
          case ( neither )
            number = merge(l_true,l_false,value_1==l_true .and. value_2==l_true)
          case ( both )
            qty%values = merge(l_true,l_false,qty_1%values==l_true .and. &
                                              qty_2%values==l_true)
          case ( left )
            qty%values = merge(l_true,l_false,qty_1%values==l_true .and. &
                                              value_2==l_true)
          case ( right )
            qty%values = merge(l_true,l_false,value_1==l_true .and. &
                                              qty_2%values==l_true)
          end select
        case ( n_or ) ! ------------------------------------------------
          select case ( case )
          case ( neither )
            number = merge(l_true,l_false,value_1==l_true .or. value_2==l_true)
          case ( both )
            qty%values = merge(l_true,l_false,qty_1%values==l_true .or. &
                                              qty_2%values==l_true)
          case ( left )
            qty%values = merge(l_true,l_false,qty_1%values==l_true .or. &
                                              value_2==l_true)
          case ( right )
            qty%values = merge(l_true,l_false,value_1==l_true .or. &
                                              qty_2%values==l_true)
          end select
        case ( n_plus ) ! ----------------------------------------------
          select case ( case )
          case ( neither )
            number = value_1 + value_2
          case ( both )
            qty%values = qty_1%values + qty_2%values
          case ( left )
            qty%values = qty_1%values + value_2
          case ( right )
            qty%values = value_1 + qty_2%values
          end select
        case ( n_minus ) ! ---------------------------------------------
          select case ( case )
          case ( neither )
            number = value_1 - value_2
          case ( both )
            qty%values = qty_1%values - qty_2%values
          case ( left )
            qty%values = qty_1%values - value_2
          case ( right )
            qty%values = value_1 - qty_2%values
          end select
        case ( n_mult ) ! ----------------------------------------------
          select case ( case )
          case ( neither )
            if ( units_1 /= phyq_dimensionless .and. units_2 /= phyq_dimensionless ) &
              stat = announce_error ( root, wrongUnits )
            units = merge(units_1, units_2, units_1 /= phyq_dimensionless)
            number = value_1 * value_2
          case ( both )
            qty%values = qty_1%values * qty_2%values
          case ( left )
            qty%values = qty_1%values * value_2
          case ( right )
            qty%values = value_1 * qty_2%values
          end select
        case ( n_div ) ! -----------------------------------------------
          select case ( case )
          case ( neither )
            if ( units_2 == phyq_dimensionless ) then
              units = units_1
            else if ( units_1 == units_2 ) then
              units = phyq_dimensionless
            else
              stat = announce_error ( root, wrongUnits )
            end if
            number = value_1 / value_2
          case ( both )
            qty%values = qty_1%values / qty_2%values
          case ( left )
            qty%values = qty_1%values / value_2
          case ( right )
            qty%values = value_1 / qty_2%values
          end select
        case ( n_into ) ! ----------------------------------------------
          select case ( case )
          case ( neither )
            if ( units_1 == phyq_dimensionless ) then
              units = units_2
            else if ( units_1 == units_2 ) then
              units = phyq_dimensionless
            else
              stat = announce_error ( root, wrongUnits )
            end if
            number = value_2 / value_1
          case ( both )
            qty%values = qty_2%values / qty_1%values
          case ( left )
            qty%values = value_2 / qty_1%values
          case ( right )
            qty%values = qty_2%values / value_1
          end select
        end select
        if ( stat_1 == dot ) then
          call destroyVectorQuantityMask ( qty_1 )
          call destroyVectorQuantityValue ( qty_1 )
        end if
        if ( stat_2 == dot ) then
          call destroyVectorQuantityMask ( qty_2 )
          call destroyVectorQuantityValue ( qty_2 )
        end if
      case ( n_dot ) ! -------------------------------------------------
        vector_index = decoration(decoration(subtree(1,root)))
        qty_index = decoration(decoration(decoration(subtree(2,root))))
        call nullifyQuantityTemplate ( qty%template )
        call cloneVectorQuantity ( qty, &
          & GetVectorQtyByTemplateIndex( &
          & vectors(vector_index), qty_index ), options='d' )
      case ( n_identifier, n_string ) ! --------------------------------
        stat = announce_error ( root, bad_terminal )
      case ( n_unit ) ! ------------------------------------------------
        stat = vector_qty_expr ( subtree(1,root), vectors, qty, value_1, units )
        decl = get_decl(sub_rosa(subtree(2,root)), units_name)
        units = decl%units
        if ( decl%value > 0.0 ) then
          number = value_1 * decl%value
        else
          number = value_1 - decl%value
        end if
      case default ! ---------------------------------------------------
        stat = announce_error ( root, bad_operator )
      end select

    end if

  9 call trace_end ( 'Vector_Qty_Expr', cond=toggle(gen) )

  contains

    integer function Announce_Error ( Where, What, Number )
      use Lexer_Core, only: Where_t
      use MLSMessageModule, only: MLSMessage, MLSMSG_Error
      use String_Table, only: Get_String, String_Length
      use Tree, only: Node_id, Subtree, Sub_Rosa, Tree_Text, Where_At=>Where
      integer, intent(in) :: Where ! Tree node index
      integer, intent(in) :: What  ! Error code
      double precision, intent(in), optional :: Number

      type(where_t) :: Where_is
      integer :: L, N
      character(len=127) :: Name, QtyNames(2,2), String

      announce_error = -what
      where_is = where_at(where)
      write ( string, 1 ) where_is%source/256, mod(where_is%source,256)
      1 format ( 'At line ', i0, ', column ', i0 )
      l = len_trim(string) + 1
      if ( where_is%file /= 0 ) then
        string(l:l+3) = ' in '
        call get_string ( where_is%file, string(l+5:), strip=.true. )
        l = len_trim(string) + 1
      end if
      select case ( what )
      case ( bad_operator )
        call get_string ( tree_text(node_id(where)), name )
        n = string_length ( tree_text(node_id(where)) )
        write ( string(l:), 3 ) name(:n)
      3 format ( ', cannot handle ', a, ' in this context.' )
      case ( bad_terminal )
        call get_string ( sub_rosa(where), name )
        n = string_length ( tree_text(node_id(where)) )
        write ( string, 3 ) name(:n)
      case ( incompatible )
        call get_string ( subtree(1,subtree(1,where)), qtyNames(1,1) )
        call get_string ( subtree(2,subtree(1,where)), qtyNames(2,1) )
        call get_string ( subtree(1,subtree(2,where)), qtyNames(1,2) )
        call get_string ( subtree(2,subtree(2,where)), qtyNames(2,2) )
        write ( string(l:), 4 ) trim(qtyNames(1,1)), trim(qtyNames(2,1)), &
                              & trim(qtyNames(1,2)), trim(qtyNames(2,2))
      4 format ( ', the quantities "', a, '.', a, '" and "', a, '.', a, &
          & '" are incompatible.' )
      case ( notFunc )
        call get_string ( sub_rosa(where), name )
        write ( string(l:), 5 ) trim(name)
      5 format ( ', "', a, '" is not a function name.' )
      case ( outOfRange )
        if ( present(number) ) then
          write ( string(l:), 6 ) number
      6   format ( ', the function argument ', g15.7, ' is out of range.' )
        else
          string(l:) = ', the function argument is out of range.'
        end if
      case ( unsupportedFunc )
        call get_string ( sub_rosa(where), name )
        write ( string(l:), 8 ) trim(name)
      8 format ( ', "', a, '" is not a supported function.' )
      case ( wrongNumArgs )
        string(l:) = ', the function has the wrong number of arguments.'
      case ( wrongUnits )
        string(l:) = ', the units are incorrect.'
      end select

      if ( present(forWhom) ) then
        call MLSMessage ( MLSMSG_Error, forWhom, trim(string) )
      else
        call MLSMessage ( MLSMSG_Error, moduleName, trim(string) )
      end if

    end function Announce_Error

  end function Vector_Qty_Expr

! ====     Private Procedures     ======================================

!--------------------------- end bloc --------------------------------------
 logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: Vector_Qty_Expr_m.f90,v 2.4 2013/09/24 23:27:14 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here

end module Vector_Qty_Expr_m

! $Log: Vector_Qty_Expr_m.f90,v $
! Revision 2.4  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.3  2013/09/21 00:36:23  vsnyder
! Cannonball polishing
!
! Revision 2.2  2013/09/19 23:24:11  vsnyder
! Remove debugging print
!
! Revision 2.1  2013/09/19 23:23:10  vsnyder
! Initial commit
!
@


2.4
log
@Use Get_Where or Print_Source to start error messages
@
text
@d21 3
a23 2
  ! quantity.  If Log_Value or Num_Value the result is a number, zero being
  ! false in the Log_Value case.  If negative, an error occurred.
d25 1
a25 1
  use Declaration_Table, only: Dot, Log_Value, Num_Value
d30 1
a30 1
  public :: Dot, Log_Value, Num_Value, Vector_Qty_Expr
d58 1
a58 1
    !   Num_Value => result is a number, and Number is its value.  Qty is
d60 1
d65 1
a65 1
    ! Boolean-valued operators set values to 1 for true, zero for false
d106 1
a106 1
    data types(n_and)         / log_value /
d108 14
a121 14
    data types(n_div)         / num_value /
    data types(n_equal_equal) / log_value /
    data types(n_greater_eq)  / log_value /
    data types(n_greater)     / log_value /
    data types(n_into)        / num_value /
    data types(n_less_eq)     / log_value /
    data types(n_less)        / log_value /
    data types(n_minus)       / num_value /
    data types(n_mult)        / num_value /
    data types(n_not_equal)   / log_value /
    data types(n_not)         / log_value /
    data types(n_number)      / num_value /
    data types(n_or)          / log_value /
    data types(n_plus)        / num_value /
d143 2
a144 2
        case ( num_value )
          number = 1 - value_1
d151 1
a151 1
        case ( num_value )
d159 1
a159 1
        case ( num_value )
d193 1
a193 1
              case ( num_value )
d208 1
a208 1
              case ( num_value )
d223 1
a223 1
              case ( num_value )
d238 1
a238 1
              case ( num_value )
d427 1
a427 1
            number = value_1 * value_2
d429 2
a430 1
            qty%values = qty_1%values * qty_2%values
d432 2
a433 1
            qty%values = qty_1%values * value_2
d435 2
a436 1
            qty%values = value_1 * qty_2%values
d441 1
a441 1
            number = max(value_1, value_2)
d443 2
a444 1
            qty%values = max(qty_1%values, qty_2%values)
d446 2
a447 1
            qty%values = max(qty_1%values, value_2)
d449 2
a450 1
            qty%values = max(value_1, qty_2%values)
d640 1
a640 1
       "$Id: Vector_Qty_Expr_m.f90,v 2.3 2013/09/21 00:36:23 vsnyder Exp $"
d649 3
@


2.3
log
@Cannonball polishing
@
text
@d193 1
a193 1
                  stat = announce_error ( son2, outOfRange )
d208 1
a208 1
                  stat = announce_error ( son2, outOfRange )
d223 1
a223 1
                  stat = announce_error ( son2, outOfRange )
d238 1
a238 1
                  stat = announce_error ( son2, outOfRange )
d553 2
a554 1
    integer function Announce_Error ( Where, What )
d556 2
a557 2
      use String_Table, only: Get_String
      use Tree, only: Node_id, Source_Ref, Subtree, Sub_Rosa, Tree_Text
d560 1
d562 2
a563 1
      integer :: Column, Line
d567 9
a575 3
      line = source_ref (where)
      column = mod(line,256)
      line = line/256
d579 3
a581 3
        write ( string, 1 ) line, column, trim(name)
      1 format ( 'At line ', i0, ', column ', i0, ', cannot handle ', a, &
               & ' in this context.' )
d584 2
a585 1
        write ( string, 1 ) line, column, trim(name)
d591 4
a594 5
        write ( string, 3 ) line, column, &
          & trim(qtyNames(1,1)), trim(qtyNames(2,1)), &
          & trim(qtyNames(1,2)), trim(qtyNames(2,2))
      3 format ( 'At line ', i0, ', column ', i0, ' the quantities "', a, &
          & '.', a, '" and "', a, '.', a, '" are incompatible.' )
d597 2
a598 3
        write ( string, 4 ) line, column, trim(name)
      4 format ( 'At line ', i0, ', column ', i0, '"', a, &
               & '" is not a function name.' )
d600 6
a605 3
        write ( string, 5 ) line, column
      5 format ( 'At line ', i0, ', column ', i0, &
               & ', the function argument is out of range.' )
d608 2
a609 3
        write ( string, 6 ) line, column, trim(name)
      6 format ( 'At line ', i0, ', column ', i0, '"', a, &
               & '" is not a supported function.' )
d611 1
a611 3
        write ( string, 7 ) line, column
      7 format ( 'At line ', i0, ', column ', i0, &
               & ', the function has the wrong number of arguments.' )
d613 1
a613 2
        write ( string, 8 ) line, column
      8 format ( 'At line ', i0, ', column ', i0, ', the units are incorrect.' )
d632 1
a632 1
       "$Id: Vector_Qty_Expr_m.f90,v 2.2 2013/09/19 23:24:11 vsnyder Exp $"
d641 3
@


2.2
log
@Remove debugging print
@
text
@d52 1
d54 9
a62 7
    !   0 => result is a vector quantity, and Qty is that quantity;
    !        this is always a new quantity, and needs to be destroyed
    !   1 => result is a number, and Number is its value
    !  <0 => an error occurred, and both Qty and Number are undefined; the
    !        value is the negative of the error code.
    ! Range (colon, etc.), power (^), and function reference are not
    ! supported.
d64 1
d183 1
a183 1
            case ( f_exp ) ! .............................................
d198 1
a198 1
            case ( f_ln, f_log ) ! .......................................
d213 1
a213 1
            case ( f_log10 ) ! ...........................................
d228 1
a228 1
            case ( f_sqrt ) ! ............................................
d625 1
a625 1
       "$Id: Vector_Qty_Expr_m.f90,v 2.1 2013/09/19 23:23:10 vsnyder Exp $"
d634 3
@


2.1
log
@Initial commit
@
text
@a524 1
print '(a,i0)', 'Cloning vector quantity at ', root
d621 1
a621 1
       "$Id: tree_checker.f90,v 1.38 2013/08/31 01:26:06 vsnyder Exp $"
d629 4
a632 1
! $Log: $
@

