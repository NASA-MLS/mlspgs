head	2.1;
access;
symbols
	v5-02-NRT-19:2.1
	v6-00:2.1
	v5-02-NRT-18:2.1
	v5-02:2.1
	v5-01-NRT-17:2.1
	v5-01-NRT-16:2.1
	v5-01-NRT-15:2.1
	v5-01-NRT-14:2.1
	neuralnetworks-1-0:2.1.0.14
	cfm-single-freq-0-1:2.1.0.12
	v5-01:2.1
	v5-00:2.1
	v4-23-TA133:2.1.0.10
	mus-emls-1-70:2.1.0.8
	rel-1-0-englocks-work:2.1.0.6
	VUMLS1-00:2.1
	VPL1-00:2.1
	V4-22-NRT-08:2.1
	VAM1-00:2.1
	V4-21:2.1.0.4
	V4-13:2.1
	V4-12:2.1
	V4-11:2.1
	V4-10:2.1
	V3-43:2.1
	M4-00:2.1
	V3-41:2.1
	V3-40-PlusGM57:2.1.0.2
	V2-24-NRT-04:2.1
	V3-33:2.1
	V2-24:2.1
	V3-31:2.1
	V3-30-NRT-05:2.1
	cfm-01-00:2.1
	V3-30:2.1
	V3-20:2.1
	V3-10:2.1
	V2-23-NRT-02:2.1
	V2-23:2.1
	V2-22-NRT-01:2.1
	V2-22:2.1;
locks; strict;
comment	@# @;


2.1
date	2007.09.07.01.35.04;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.1
log
@Initial commit
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!     subroutine *ZERO ( X1, F1, X2, F2, MODE, TOL )
! Copyright (c) 1996, California Institute of Technology. U.S.
! Government Sponsorship under NASA Contract NAS7-1260 is acknowledged.
!>> 2000-12-01 DZERO  Krogh  Removed unused variable C1P01.
!>> 1998-11-01 DZERO  Krogh  Set so errors stop less easily.
!>> 1998-11-01 DZERO  Krogh  For "mangle", INDIC replaced with MACT(3).
!>> 1996-03-30 DZERO  Krogh  Added external statement.
!>> 1995-11-09 DZERO  Krogh  Fixed so char. data at col. 72 is not ' '.
!>> 1994-11-11 DZERO  Krogh  Declared all vars.
!>> 1994-10-20 DZERO  Krogh  Changes to use M77CON
!>> 1994-09-08 DZERO  Krogh  Added CHGTYP code.
!>> 1993-04-27 DZERO  Krogh  Additions for Conversion to C.
!>> 1993-04-13 DZERO  Krogh  Minor change for new MESS.
!>> 1992-04-08 DZERO  Krogh  Unused label 400 removed.
!>> 1992-01-09 DZERO  Krogh  Moved calc. of XXMXO up (for error msg.)
!>> 1991-11-26 DZERO  Krogh  Converted to new error processor.
!>> 1988-08-14 DZERO  Krogh  Labels runumbered.
!>> 1988-03-07 DZERO  Krogh  Initial code.

!--D replaces "?": ?ZERO, ?MESS

! SUBROUTINE TO FIND A BOUNDED ZERO

! analysis and coding by Fred T.Krogh at the Jet Propulsion
! Laboratory, Pasadena, Calif.  April 25, 1972.
! Modified for portability, April 1984 by Krogh.
! Algorithmic changes, vars. added to save stmt., Sept. 1987 by Krogh

! Parameters in the calling sequence are defined as follows:

!  X1  = independent variable
!  F1  = dependent variable --  initially   F1=F(X1).
!        When MODE=1 (or 5) the user is to compute F(X1) given X1
!  X2  = second value of independent variable
!  F2  = F(X2) on the initial entry.  When MODE = 2-4, F2=F(X2) and
!        F1*F2 <= 0.
!  MODE  is a parameter used for communication between this
!        subroutine and the user. (The user should set MODE
!        only to initialize it to 0 before the first call)
!      =1  compute F(X1) and call $ZERO
!      =2  F(X1) is approximately 0, the iteration is finished
!          and the error criterion is satisfied.
!      =3  same as MODE=2, except the error criterion can
!          not be satisfied.
!      =4  apparently the function has a discontinuity
!          between X1 and X2 -- No zero can be found
!      =5  F1*F2 was greater than zero on the first call, and an attempt
!          to bound the zero on both sides have failed.
!      =6  fatal error -- $ZERO was called after mode was set >=2.
!          If $ZERO is called again, the program will be stopped.
!          (Unless MODE is set to 0)
!      <0  If MODE is set <0 and $ZERO is called, no action is taken
!          except that print is turned on for -MODE calls to $ZERO.
!          This print gives all values of X and F used in the iteration.
!  TOL    is the error tolerance
!     TOL>0  Iterate until values of X1 and X2 are known
!              for which abs(X1-X2) <= tol and F1*F2 <= 0.
!     TOL<0  Iterate until a value of X1 is found for which
!              abs(F1) <= abs(TOL).
!     TOL  = 0  Iterate until the zero is determined as
!              precisely as possible.  MODE = 3 is impossible
!              in this case.

! Parameters in the calling sequence have the following types

      integer MODE
      real(rk) X1, X2, F1, F2, TOL

! Usage is as follows (of course, variations are possible.)
!         Somehow one has available X1, F1, X2, and F2 such
!         that F1 = F(X1), F2 = F(X2) and F1*F2 <= 0.
!         In addition, one should assign a value to TOL.
!     MODE = 0
!***  In the statement below, $ is replaced by an 'S' for single
!***  precision and a 'D' for double.
! XXX call $ZERO(X1,F1,X2,F2,MODE,TOL)
!     go to  (N1,N2,N3,N4,N5,N6), MODE
!  N1 COMPUTE  F1=F(X1)
!     go to XXX

!  N4 continue
!  N5 continue
!  N6 stop
!  N3 If you want to -- print results to note that error
!                       is too big.
!  N2 zero is found, do whatever you want to with it.

! End of comments explaining usage.

! ************************* Usage of internal variables ****************

! C0     Parameter = 0.
! C1     Parameter = 1.
! C1P25  Parameter = 1.25
! C2     Parameter = 2.
! C4     Parameter = 4.
! CP01   Parameter = 0.01
! CP125  Parameter = 1.25
! CP25   Parameter = 0.25
! CP5    Parameter = 0.5
! CP75   Parameter = 0.75
! CP99   Parameter = 0.99
! DFDXXX = (XXMXL/FFMFL) * (est. deriv. of f w.r.t. x at x = XX).  All
!   derivatives are base on a second degree polynonial that interpolates
!   the last three points generated.
! DFDXXX = (XXMXO/FFMFL) * (est. deriv. of f w.r.t. x at x = X0).
! DIV    If artificial subdivision of the interval is used, determines
!   the amount of the sudivision.  (-XXMXOO * DIV / (1. + DIV))
! DMESS  Prints error messages.
! DXDFFF = (FFMFL/XXMXL) * (est. deriv. of x w.r.t. f at f = FF).
! DXDFFO = (FFMFO/XXMXL) * (est. deriv. of x w.r.t. f at f = FO).
! F1     (formal arg.) The last value of F computed, on return the value
!   of F(X1).
! F2     (formal arg.) The other initial value provided for F.  Set to
!   the value of F(X2) on returns.
! FDAT   Temporary storage for floating point values for messages.
! FF     Value of F1 after F is computed.
! FFDFO  FF / FO
! FFMFB  FFMFL + FLMFB = FF - value of FF 2 iterations back.
! FFMFL  FF - FL
! FL     Value of FF from the previous iteration.
! FLMFB  Value of FFMFL from the previous iteration
! FO     F(XO)
! I      Comments for LCHNG define how I is set.
! IDAT   Temporary storage for integer values for messages.
! J      This is 1 if FF <= 0., and is 2 if FF > 0.
! KNKP   KNKP(J) (see J above) is set to 0 whenever there are signs of
!   decent convergence.  It is counted up when convergence is slow.
! KS     =-1  initially,
!        = 0  whenever F changes sign, otherwise
!        = number of times the sign of F has remained the same
! KTYP   = 1 if interpolation was used to get the last iterate, = 0 if
!   an artificial subdivision was used.
! LCHG  the J-th continuation in the data statement for LCHG below gives
! new states for the case when the state number is J-1.  State 0 is the
! initial state.  The I-th entry on a row gives the state for case on I
! as follows:  (TP is the ratio (new f) / (last f of same sign)
!    I = 1   TP < 0.01
!    I = 2   .01 <= TP < 1
!    I = 3   TP = 1
!    I = 4   1 < TP <= 4
!    I = 5   TP > 4.
! States are as follows:
!    0   initial state, or big increase, or small increase in state 0
!    1   after big decrease, perhaps followed by small decreases
!    2   after one or more small decreases from state 0
!    3   one or more small increases from state 2
!    4   one or more small decreases from state 3
!    5   decision made that noise is a problem on this side of zero.
! LINIT  - the maximum number of iterations that can be taken with out
!   getting a sign change in F.
! LMODE  The value of MODE the last time in this routine.
! LNLP
! LTXTxx Names of this form are used in setting up data statements for
!   error messages.  These names are generated automatically by PMESS,
!   the program that makes up these messages.
! MACT   This array difines the actions to be taken by the error message
!   program.  See comments in MESS for details.  MODE is set to MACT(3)
!   on exit.
! MACT1  As for MACT except used for the diagnostic print.
! MExxxx Parameters defining constants used for interaction with the
!   error message program MESS.  See comments there for definitions.
! MLOC   Contains locations in MTXTAA for error messages.
! MODE   (formal) See comments above.
! MTXTAA Text for error messages.
! MTXTAB Text for diagnostic message.
! MTXTAC Text for diagnostic message.
! NP     If > 0, gives number of iterations till diagnostic print stops.
! QFM
! QXM
! RND    Largest relative difference between succesive floating point
!   numbers.
! SMALL  .5 / (RND * largest floating point number)
! TOL    (Formal) See description above.
! TOLX   Actually tolerance required for accuracy in X.  Usually =
!   max(TOL, XRND).  It can be cut by a factor of 2 for use in setting
!   bounds on an acceptable interval.
! TP     Ordinarily the ratio (FF / prev. FF of the same sign.
! TP1    Used for temporary storage.
! X1     (Formal) Value of x where F is to be computed, and value
!   returned for the zero after convergence.
! X2     (Formal) Initially other value of x where F is given.  After
!   convergence gives the other closest x which gives an F of opposite
!   sign from that given by x1.
! XL     Value of XX from the previous iteration.
! XLMXB  Value of XXMXL from the previous iteration.
! XO     Value of x on opposite side of the zero from the current x.
! XRND   Best accuracy that one could hope for based on the finite
!   precision of floating point numbers.
! XX     Current x, the last value of X1 where F was computed.
! XXMXL  XX - XL
! XXMXO  XX - XO = length of interval in which 0 lies.
! XXMXOL Value of XXMXO from a previous iteration.

      integer LINIT, KS, KTYP, J, I
      parameter (LINIT = -40)
      integer KNKP(2), LCHG(30), LMODE, LNLP(2), NP
      real(rk) XX, XO, XL, FF, FO, FL, FFDFO
      real(rk) DIV, QFM, QXM, TP, TP1, XXMXO, XXMXOL
      real(rk) RND, XRND, SMALL, TOLX
      real(rk) XXMXL, XLMXB, FFMFL, FFMFB, FLMFB
      real(rk) DXDFFF, DXDFFO, DFDXXX, DFDXXO
      real(rk) C0, C1, C2, C4, CP125, CP25, CP5, CP75, C1P25
      real(rk) C8, CP01, CP99, CP001, C1P031

      parameter (C0 = 0.0_rk, C1 = 1.0_rk, C2 = 2.0_rk, C4 = 4.0_rk)
      parameter (C8 = 8.0_rk)
      parameter (CP125 = 0.125_rk, CP25 = 0.25_rk, CP75 = 0.75_rk)
      parameter (CP5 = 0.5_rk)
      parameter (C1P25 = 1.25_rk)
      parameter (CP01 = 0.01_rk)
      parameter (CP001 = 0.001_rk)
      parameter (CP99 = 0.99_rk)
      parameter (C1P031 = 1.03125_rk)

!                      Declarations for error message processing.

      integer MERET, MEEMES, METEXT
      real(rk) FDAT(4)
      integer MACT(5), MACT1(2), MLOC(4), IDAT(2)
      save DIV, FL, FLMFB, FO, KNKP, KS, KTYP, LCHG, LMODE,             &
     &   LNLP, MACT, NP, RND, SMALL, XL, XLMXB, XO, XX, XXMXOL
      parameter (MERET  =51)
      parameter (MEEMES =52)
      parameter (METEXT =53)

! ********* Error message text ***************
![Last 2 letters of Param. name]  [Text generating message.]
!AA DZERO$B
!AB Best bound for zero is [$F, $F], but tolerance is $F.$E
!AC Apparent discontinuity in function near X = $F.$E
!AD Can not find a sign change: X1=$F, X2=$F, F1=$F, F2=$F$E
!AE Called with MODE = $I.$E
!   $
!AF In DZERO -- X1=$F F1=$(E11.4) KTYP=$I DIV=$G KS=$I$E
!   $
!AG             X2=$F F2=$G$E
      integer LTXTAA,LTXTAB,LTXTAC,LTXTAD,LTXTAE,LTXTAF,LTXTAG
      parameter (LTXTAA=  1,LTXTAB=  8,LTXTAC= 63,LTXTAD=112,LTXTAE=169,&
     & LTXTAF=  1,LTXTAG=  1)
      character MTXTAA(1) * (193)
      character MTXTAB(1) * (52)
      character MTXTAC(1) * (25)
      data MTXTAA/'DZERO$BBest bound for zero is [$F, $F], but tolerance&
     & is $F.$EApparent discontinuity in function near X = $F.$ECan not$&
     & find a sign change: X1=$F, X2=$F, F1=$F, F2=$F$ECalled with MODE$&
     & = $I.$E'/
      data MTXTAB/'In DZERO -- X1=$F F1=$(E11.4) KTYP=$I DIV=$G KS=$I$E'&
     &/
      data MTXTAC/'            X2=$F F2=$G$E'/

!                      1  2  3  4      5
      data MACT / MEEMES, 0, 0, 0, MERET /
      data MACT1 / METEXT, MERET /
      data MLOC / LTXTAB, LTXTAC, LTXTAD, LTXTAE /

      data RND / C0 /
      data KS, KTYP, LMODE, DIV / 0, 0, 2, C0 /
      data LCHG /                                                       &
     &   1, 2, 0, 0, 0,                                                 &
     &   1, 1, 4, 5, 0,                                                 &
     &   1, 2, 3, 3, 0,                                                 &
     &   1, 4, 4, 3, 0,                                                 &
     &   1, 4, 5, 5, 0,                                                 &
     &   1, 5, 5, 5, 0 /
      data NP / 0 /

!---------------------------- RCS Module Info ------------------------------
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: refraction_m.f90,v $"
!---------------------------------------------------------------------------

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: Zero_m.f90,v 2.31 2007/07/31 23:48:10 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------

! INITIALIZE

      if (MODE < 0) then
         NP = -1 - MODE
         return
      end if
      if (NP > 0) then
         NP = NP - 1
         FDAT(1) = X1
         FDAT(2) = F1
         FDAT(3) = DIV
         IDAT(1) = KTYP
         IDAT(2) = KS
         call MESS(MACT1, MTXTAB, IDAT, FDAT)
         if (MODE /= 0) if (LMODE - 1) 70, 80, 450
         FDAT(1) = X2
         FDAT(2) = F2
         call MESS(MACT1, MTXTAC, IDAT, FDAT)
      else if (MODE /= 0) then
         if (LMODE - 1) 70, 80, 450
      end if

      if (RND == C0) then
         RND = epsilon(c1)
         SMALL = CP5 / (RND * huge(c1))
      end if
      XL = X2
      FL = F2
   30 TP = C1
      MODE = 1
      MACT(3) = 2
      XXMXOL = C0
      KNKP(1) = 0
      KNKP(2) = 0
      LNLP(1) = 0
      LNLP(2) = 0
      KS = -1
      XX = X1
      FF = F1
      if (FL) 40, 75, 50
   40 if (FF) 60, 230, 100
   50 if (FF) 100, 230, 60
   60 LMODE = 0
!             Take care of points on same side of zero.
   70 FF = F1
      XX = X1
      TP = FF / FL
      if (TP < C0) go to 30
      LMODE = LMODE - 1
      if (LMODE < LINIT) then
         MACT(3) = 5
         FDAT(1) = XX
         FDAT(2) = XL
         FDAT(3) = FF
         FDAT(4) = FL
         go to 250
      end if
      if (TP > C1) then
         FF = FL
         XX = XL
         FL = F1
         XL = X1
      end if
      if (abs(FF) >= C8 * abs(FL-FF)) then
         TP = C8
      else
         TP = max(-CP25*real(LMODE,rk), FF / (FL - FF))
      end if
      FL = FF
      XO = XL
      XL = XX
      if (XX == XO) XO = C1P031 * XX + sign(CP001, XX)
      XX = XX + TP * (XX - XO)
      X1 = XX
      MODE = 1
      return

   75 X1 = XL
      F1 = FL
      go to 250
! END OF INITIALIZATION


! ENTRY AFTER COMPUTING F FOR THE LAST ITERATE
   80 FF = F1
      TP = FF / FL
      if (TP) 90, 230, 110
   90 TP = FF / FO
      KS = 0
  100 FO = FL
      XO = XL
      go to 120
  110 KS = KS + 1
  120 J = 1
      if (FF > C0) J = 2
      if (TP - C1) 150, 140, 130
  130 I = 4
      if (TP > C4) I = 5
      go to 160
  140 I = 3
      go to 160
  150 I = 2
      if (TP < CP01) I = 1
      if (TP < CP99) go to 170
  160 KNKP(J) = KNKP(J) + 1
      go to 180
  170 KNKP(J) = 0
  180 XXMXO = XX - XO
      LNLP(J) = LCHG(5*LNLP(J) + I)
      if (LNLP(J) >= 4) then
         if (LNLP(3 - J) >= 4) go to 210
      end if
! XXMXO GIVES THE LENGTH OF THE INTERVAL INSIDE WHICH
! THE ZERO IS KNOWN TO LIE.
      if (C2 * abs(XXMXO) < abs(XXMXOL)) then
         KNKP(1) = 0
         KNKP(2) = 0
      end if
      XXMXOL = XXMXO
      XRND = RND * (abs(XX) + abs(XO) + SMALL)

! TEST FOR CONVERGENCE
      if (TOL) 190, 200, 200
  190 continue
      if (abs(FF) <= abs(TOL)) go to 220
  200 continue
      TOLX = max(TOL, XRND)
      if (abs(XXMXO) > TOLX) go to 310

! CONVERGENCE -- PREPARE FOR FINAL EXIT
  210 if ((abs(XXMXO) > TOL) .and. (TOL /= C0)) then
         MACT(3) = 3
         FDAT(3) = TOL
         if (XXMXO > 0) then
            FDAT(2) = XX
            FDAT(1) = XO
         else
            FDAT(1) = XX
            FDAT(2) = XO
         end if
      end if
! SET FINAL VALUES FOR X1,F1,X2,AND F2
  220 continue
      if (abs(FF) <= abs(FO)) go to 240
      F1 = FO
      X1 = XO
  230 FO = FF
      XO = XX
  240 X2 = XO
      F2 = FO
! TEST FOR DISCONTINUITY
      if ((KNKP(1) > 5) .or. (KNKP(2) > 5)) then
        MACT(3) = 4
        FDAT(1) = XX
      end if
  250 MODE = MACT(3)
      if (MACT(3) - 2) 420, 420, 430
! END OF CODE FOR FINAL EXIT

! F NOT DECREASING (OR THE FIRST ITERATE)
! PREPARE TO DIVIDE THE INTERVAL
  260 TP = C1
      if (KS) 370, 280, 270
  270 if (KTYP == 0) go to 290
  280 DIV = C2
  290 continue
      DIV = max(DIV, FFDFO)
! KTYP=0 IF AND ONLY IF THE INTERVAL WAS DIVIDED (USING DIV)
! ON THE LAST ITERATION
      if (KTYP == 0) DIV = DIV * (C1P25 / (C1P25 - TP))
! DIVIDE THE INTERVAL AS SPECIFIED BY DIV
  300 TP1 = -XXMXO * (DIV/(DIV+C1))
      KTYP = 0
      go to 410

  310 continue
      XXMXL = XX - XL
      FFMFL = FF - FL
      FFDFO = abs(FF / FO)
      TOLX = CP5 * TOLX
      if (TP >= C1) go to 260
! DIVIDE THE INTERVAL IF F HAS HAD THE SAME SIGN FOR
! FOUR OR MORE TIMES IN SUCCESSION
      if (KS - 4) 320, 340, 290
  320 continue
      if (FLMFB == C0) go to 340
! BEGINNING OF CODE TO DETERMINE IF INVERSE QUADRATIC
! INTERPOLATION IS TO BE USED.
      FFMFB = FFMFL + FLMFB
      if (FFMFB == C0) go to 330
      QFM = C1 - (FFMFL / FLMFB) * (XLMXB / XXMXL)
      QXM = C1 - (XXMXL / XLMXB) * (FLMFB / FFMFL)
      DXDFFF = C1 + (FFMFL / FFMFB) * QFM
      DXDFFO = DXDFFF + C2 * ((FO - FF) / FFMFB) * QFM
      TP1 = XXMXL + XLMXB
      DFDXXX = C1 + (XXMXL / TP1) * QXM
      DFDXXO = DFDXXX + C2 * ((XO - XX) / TP1) * QXM
      TP1 = DXDFFF * DFDXXX
      if ((TP1 <= CP25) .or. (TP1 >= C4)) go to 330
      TP1 = DXDFFO * DFDXXO
      if ((TP1 > CP25) .and. (TP1 < C4)) go to 380

! DERIVATIVES DO NOT MATCH WELL ENOUGH
  330 continue
      if (KS == 0) if (FFDFO - C1) 350, 370, 360
  340 continue
      if ((KTYP == 0) .and. (TP >= CP75)) go to 290
      continue
      TP = C1 - TP
      if (TP <= FFDFO) go to 280
      FFDFO = FFDFO / TP
      DIV = CP125
      go to 290
  350 continue
      DIV = CP5 * max(max(CP25, FFDFO), TP / (C1P25 - min(TP, C1)))
      go to 300
  360 continue
      DIV = min(C4, CP5 * FFDFO)
      go to 300
! INTERPOLATE WITH SECANT METHOD
  370 TP1 = -XXMXL
      go to 390

! DERIVATIVES MATCH UP PRETTY WELL.
  380 continue
! INTERPOLATE USING THE INVERSE QUADRATIC
      TP1 = XXMXL * (QFM * (FL / FFMFB) - C1)
  390 TP1 = (FF/FFMFL) * TP1
      KTYP = 1

! EXIT TO GET F(X)
  410 continue
      FL = FF
      FLMFB = FFMFL
      XLMXB = XXMXL
      XL = XX
! COMPUTE X1, INSURING THAT IT IS NOT TOO CLOSE TO THE
! ENDS OF THE INTERVAL
      XX = min(max(XL + TP1, min(XL, XO) + TOLX), max(XL, XO) - TOLX)
      X1 = XX
  420 LMODE = MODE
      return

  430 MACT(2) = 11*MACT(3)  - 19
  440 MACT(4) = MLOC(MACT(3)-2)
      call MESS(MACT, MTXTAA, IDAT, FDAT)
      go to 420

! A CALL TO THE SUBROUTINE HAS BEEN MADE WITH MODE/=1
  450 IDAT(1) = MODE
      MACT(3) = 6
      MODE = 6
      if (LMODE /= 6) go to 430
      MACT(2) = 99
      go to 440
!     end subroutine *ZERO

! $Log: $
@
