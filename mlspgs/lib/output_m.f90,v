head	2.147;
access;
symbols
	v5-02-NRT-19:2.147
	v6-00:2.147
	v5-02-NRT-18:2.147
	v5-02:2.146
	v5-01-NRT-17:2.147
	v5-01-NRT-16:2.147
	v5-01-NRT-15:2.147
	v5-01-NRT-14:2.147
	neuralnetworks-1-0:2.147.0.4
	cfm-single-freq-0-1:2.147.0.2
	v5-01:2.146
	v5-00:2.146
	v4-23-TA133:2.143.0.2
	mus-emls-1-70:2.137.0.2
	rel-1-0-englocks-work:2.136.0.2
	VUMLS1-00:2.128
	VPL1-00:2.125
	V4-22-NRT-08:2.125
	VAM1-00:2.125
	V4-21:2.120.0.2
	V4-13:2.115
	V4-12:2.112
	V4-11:2.111
	V4-10:2.111
	V3-43:2.88
	M4-00:2.98
	V3-41:2.88
	V3-40-PlusGM57:2.88.0.2
	V2-24-NRT-04:2.67
	V3-33:2.83
	V2-24:2.67
	V3-31:2.83
	V3-30-NRT-05:2.82
	cfm-01-00:2.82
	V3-30:2.82
	V3-20:2.82
	V3-10:2.80
	V2-23-NRT-02:2.67
	V2-23:2.67
	V2-22-NRT-01:2.67
	V2-22:2.67
	V2-21:2.55
	V2-20:2.53
	V2-11:2.53
	V2-10:2.53
	V2-00:2.49
	V1-51:2.39
	V1-50:2.37
	V1-45:2.31
	V1-44:2.31
	V1-43:2.29
	V1-42:2.28
	V1-41:2.28
	V1-32:2.28
	V1-40:2.28
	V1-31:2.28
	V1-30:2.26
	V1-13:2.19
	V1-12:2.19
	V1-11:2.18
	V1-10:2.17
	newfwm-feb03:2.17.0.2
	V1-04:2.16
	V1-03:2.16
	V1-02:2.16
	V1-00:2.16
	newfwm-sep01:2.13.0.2
	V0-7:2.13
	V0-5-Level2:2.8
	V0-5-SIPS:2.6;
locks; strict;
comment	@# @;


2.147
date	2019.10.01.23.40.52;	author vsnyder;	state Exp;
branches;
next	2.146;

2.146
date	2019.08.01.23.42.33;	author pwagner;	state Exp;
branches;
next	2.145;

2.145
date	2019.07.22.22.12.43;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2019.07.17.20.16.47;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2019.04.09.20.30.40;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2019.03.18.22.05.12;	author pwagner;	state Exp;
branches;
next	2.141;

2.141
date	2019.01.24.18.38.05;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2018.10.25.23.25.20;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2018.10.17.23.03.10;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2018.09.13.20.18.20;	author pwagner;	state Exp;
branches;
next	2.137;

2.137
date	2018.05.11.20.33.05;	author pwagner;	state Exp;
branches;
next	2.136;

2.136
date	2018.04.05.16.55.05;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2017.12.22.00.23.23;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2017.11.30.20.50.13;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2017.11.15.00.00.17;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2017.10.03.21.42.54;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2017.09.29.00.19.01;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2017.09.07.20.58.29;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2017.07.31.23.01.22;	author pwagner;	state Exp;
branches;
next	2.128;

2.128
date	2017.01.25.17.13.44;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2016.10.18.17.46.28;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2016.09.22.22.51.48;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2015.09.24.18.52.28;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2015.08.26.23.25.11;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2015.08.25.18.36.56;	author vsnyder;	state Exp;
branches;
next	2.122;

2.122
date	2015.07.14.23.26.54;	author pwagner;	state Exp;
branches;
next	2.121;

2.121
date	2015.05.18.17.40.03;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2015.03.06.21.37.42;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2015.02.13.00.16.24;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2015.02.10.00.59.36;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2015.02.06.00.45.54;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2015.01.12.22.20.55;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2014.09.05.00.28.05;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2014.08.06.19.26.49;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2014.08.05.18.23.24;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2014.07.21.20.56.47;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2014.01.11.01.41.02;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2014.01.09.00.22.18;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2013.11.21.21.21.41;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2013.11.04.22.53.51;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2013.09.12.01.56.50;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2013.08.28.00.35.39;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2013.08.23.02.51.04;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2013.07.18.22.34.31;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2013.07.13.00.01.09;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2013.06.28.17.53.44;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2013.06.14.01.26.11;	author vsnyder;	state Exp;
branches;
next	2.99;

2.99
date	2013.04.17.00.03.44;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2013.02.04.21.57.06;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2012.09.11.18.52.26;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2012.08.16.17.36.30;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2012.08.07.18.01.22;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2012.08.02.21.09.53;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2012.08.01.00.08.21;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2012.07.18.00.33.45;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2012.07.17.16.38.01;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2012.06.22.00.04.02;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2012.04.20.01.27.14;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2011.08.11.22.24.59;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2011.07.12.00.12.25;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2011.05.26.20.38.32;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2011.04.29.02.16.32;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2011.03.12.00.39.31;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2010.10.14.18.43.02;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2010.01.26.17.49.42;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2009.06.24.22.35.44;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2009.06.23.18.25.43;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2009.06.16.17.22.42;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2009.05.14.22.00.28;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2008.11.24.19.29.43;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2008.10.17.00.04.22;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2008.06.17.00.01.53;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2008.05.02.00.07.20;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2008.04.18.16.34.37;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2008.03.07.01.34.57;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2008.02.22.21.24.14;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2008.01.09.20.52.03;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2007.12.19.01.29.05;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2007.11.30.18.19.48;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2007.10.18.23.39.46;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2007.09.24.20.22.08;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2007.09.20.17.38.09;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2007.09.14.00.15.42;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2007.09.06.22.27.06;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2007.08.27.23.55.01;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2007.07.27.00.21.59;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2007.07.17.00.24.18;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2007.06.14.18.40.04;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2007.04.14.00.37.16;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2007.03.23.00.08.21;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2007.01.13.01.49.48;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2007.01.12.00.31.00;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2006.07.28.01.58.53;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2006.07.19.22.25.14;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2006.06.27.23.58.01;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2006.06.24.23.05.07;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2006.06.03.00.17.29;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2006.02.21.19.08.36;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2006.02.15.18.10.44;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2006.02.15.00.00.07;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2006.02.10.21.23.05;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2006.01.04.20.28.51;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2005.12.16.23.25.13;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2005.09.22.23.34.56;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2005.03.19.01.14.41;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2005.01.20.23.17.51;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2005.01.19.01.09.49;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2005.01.07.01.26.04;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2004.12.31.02.39.51;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2004.12.28.19.29.57;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2004.12.14.00.00.50;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2004.12.13.20.30.19;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2004.09.23.22.57.36;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2004.08.04.23.19.02;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2004.06.10.23.59.29;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2004.02.26.21.51.15;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2003.10.07.01.12.59;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2003.09.15.23.08.44;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2003.09.08.17.43.25;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2003.09.06.01.35.55;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2003.08.25.17.48.37;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2003.08.25.17.06.50;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2003.08.23.00.11.46;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2003.08.21.21.20.35;	author cvuu;	state Exp;
branches;
next	2.20;

2.20
date	2003.07.02.01.07.27;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2003.03.20.19.20.17;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2003.02.27.18.35.30;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2002.10.08.00.09.13;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2001.10.19.22.31.36;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2001.10.08.23.43.28;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2001.09.26.02.16.22;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.05.24.22.39.07;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.05.24.22.22.48;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.05.10.22.52.03;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.05.10.18.22.00;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2001.05.08.20.27.24;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.04.25.00.08.01;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.04.18.23.28.10;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2001.04.07.01.53.28;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.16.23.14.16;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.02.28.21.35.34;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.22.23.54.27;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.22.23.27.16;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.11.18.33.24;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.147
log
@Add Trim optional argument to floating-point output
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Output_M

  ! Normal level printing and formatting
  ! Directs output to either stddout or PrUnit
  ! See also dump_0 and Printit_m
  ! For higher-level procedures, see HighOutput
  
  ! Overview:
  ! Text, scalars, and arrays of numbers may be output
  ! in a controlled way according a number of settings
  ! contained in ..Options  datatypes or by arguments
  ! passed during the call
  ! Major features include whether or when to
  !   (*) direct the output to stdout or elsewhere @@
  !   (*) time stamp each line #
  !   (*) indent each line
  !   (*) apply a special format
  !   (*) advance to the next line after printing
  !   (*) defer and store up output in a temporary buffer
  !   (*) pause, exit, or crash hard after printing
  !   (*) go 'silent' until commanded to resume printing
  !   (@@) If we don't print to stdout, we may use the MLSMessaging facility
  !       or we may do both
  !   (#) Stamping may be applied automatically or on command

  use Machine, only: Crash_Burn, Exit_With_Status, NeverCrash
  use MLSCommon, only: Filenamelen, Finite_Signal, &
    & Is_What_Ieee
  use MLSStrings_0, only: NCharsInFormat, ReplaceNonAscii, Lowercase, &
    & Readintsfromchars, Stretch, Trim_Safe
  use PrintIt_M, only: Assemblefullline, Get_Config, &
    & MLSMSG_Crash, MLSMSG_Debug, MLSMSG_Info, MLSMSG_Error, &
    & MLSMSG_Severity_To_Quit, &
    & InvalidPrUnit          => InvalidLogUnit, &  
    & StdoutPrUnit           => StdoutLogUnit, &   
    & MsgLogPrUnit           => DefaultLogUnit, &  
    & BothPrUnit             => BothLogUnit, &     
    & OutputLinesPrUnit      => BufferedLogUnit, & 
    & PrUnitName             => LogUnitName, &
    & PrintItOut, MLSMessageConfig
  use IO_Stuff, only: Pause

  implicit none
  private

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -
!     (data types and parameters)
! OutputLines              If PrUnit = OUTPUTLINESPRUNIT, 
!                            this is where we store the output until flushed
! OutputOptions            where to send output and how to format it
! (some components)
! MLSMSG_Level             MLSMessage level if so logged
! PrUnit                   How to direct output:
!                          OUTPUTLINESPRUNIT :: held in outputLines
!                          MSGLOGPRUNIT      :: logged via MLSMessage
!                          STDOUTPRUNIT      :: print stdout
!                          BOTHPRUNIT        :: both stdout and logged
!                          > 0 :: print to Fortran unit number PrUnit
! SkipMLSMSGLogging        whether to skip MLSMessage by default
! StampOptions             whether and how to stamp each output automatically
! TimeStampOptions         how to stamp when calling timeStamp

!     (subroutines and functions)
! Advance_is_yes_or_no     parse the advance=.. field
!                            to say whether to advance to the next line
!                            and optionally to set advanced formatting
! AddToIndent              add to the number of blanks indented; subtract if < 0
! Beep                     print message to error_unit
! Blanks                   print specified number of blanks [or fill chars]
! FlushOutputLines         print the current outputLines; then reset to ''
! FlushStdout              flush any buffered lines to stdout
! GetOutputStatus          returns normally private data
! IsOutputSuspended        returns TRUE if output is suspended; i.e. running silent
! Newline                  print a newline
! Output                   print argument
! PrintOutputStatus        print normally private settings and options
! PrUnitName               Where output is directed
! ResetIndent              set indenting back to 0
! RestoreSettings          restore default settings for output, stamps, tabs
! RevertOutput             revert output to file used before switchOutput
!                           if you will revert, keepOldUnitOpen when switching
! ResumeOutput             resume suspended output
! SetFillPattern           set a special Fill pattern 
!                           (that can be used in call to blanks, banner, etc.)
! SetTruthPattern          set the chars that will be printed in place of 'T' 'F'
! SetOutputStatus          sets normally private data
! SetAdvancedOption        sets advanced or miscellaneous option values
! SuspendOutput            suspend output; run silent
! SwitchOutput             switch output to a new named file, 
!                            or else to 'stdout'
! === (end of toc) ===

! === (start of api) ===
! char* Advance_is_yes_or_no ( [char* str] )
! Beep ( [char* chars] )
! Blanks ( int n_blanks, [char fillChar], [char* advance] )
! FlushStdout
! FlushOutputLines ( [int prUnit] )
! int GetOutputStatus( char* name, [char* value] )
! log IsOutputSuspended ()
! NewLine ( [log dont_make_blank_line] )
! Output ( char* chars, [char* advance], [char* from_where], 
!          [log dont_log], [char* log_chars], [char* insteadOfBlank],
!          [log dont_stamp], [int newlineval] )
! Output ( char* chars(:), [char* advance],
!          [char* insteadOfBlank], [int newlineval] )
! Output ( value, [char* format], [char* advance],
!          [char* Before], [char* After] )
!       where value can be any numerical type, either scalar or 1-d array
!       advance may be
!       'y[es]', 't[rue]'  advance to next line after printing
!       'n[o]', 'f[alse]'  don't advance to next line after printing
!       'stderr'  print to stderr instead of default
! PrintOutputStatus ( [char* keywords] )
! ResumeOutput
! RevertOutput
! RestoreSettings ( [char* settings] )
! SetFillPattern ( pattern, [fillChar] )
! SetTruthPattern ( char* TrueFalse[2] )
! SetAdvancedOption ( [char* str] )
! SetOutputStatus( char* name, int value )
! SuspendOutput
! SwitchOutput ( char* filename, [int unit] )
! === (end of api) ===
!
! Notes:
! (1) By calling appropriate functions and procedures you can adjust aspects of
! how and where we output, and others can be changed by setting various
! public global parameters directly
! (in OO-speak they are class-level rather than instance-level)
! (2) Sometimes there is more than one way to accomplish the same thing
! E.g., calling timeStamp or using setStamp before calling output
! (Should we remove one of these?)
! (3) Another example is the advance argument which may be composed of multiple
! sub-arguments, each to set an advanced feature
! (see advancedOptions below)
! (4) To understand the codes for dateformat and timeFormat, see dates_module
! 
  ! Where to output?
  ! These apply if we don't output to a fortran unit number (which is > 0)
  ! See also Beep command, and advance='stderr' or advance='arg1 ..'
  ! Possible values for PrUnit
  public :: InvalidPrUnit    
  public :: StdoutPrUnit     
  public :: MsglogPrUnit     
  public :: BothPrUnit       
  public :: OutputlinesPrUnit

  ! Which of the above would involve stdout
  logical, parameter, private :: UseStdout(OutputlinesPrUnit:InvalidPrUnit) = &
    !    OUTPUTLINESPRUNIT  BOTHPRUNIT  MSGLOGPRUNIT  STDOUTPRUNIT
    & (/ .false.,           .true.,     .false.,      .true., &
    !    INVALIDPRUNIT
    &    .false. /)

  integer, save, private :: OLDUNIT = -1 ! Previous PrUnit for output.
  logical, save, private :: OLDUNITSTILLOPEN = .TRUE.

  public :: AddToIndent, Advance_Is_Yes_Or_No, Beep, Blanks, &
    & FlushOutputLines, FlushStdout, GetOutputStatus, IsOutputSuspended, &
    & Newline, Output, Output_Char_NoCR, PrintOutputStatus, PrUnitName, &
    & ResetIndent, RestoreSettings, ResumeOutput, RevertOutput, &
    & SetFillPattern, SetAdvancedOption, SetOutputStatus, SetTruthPattern, &
    & SuspendOutput, SwitchOutput

  ! These types made public because the class instances are public
  public :: OutputOptions_T
  public :: PatternOptions_T
  public :: StampOptions_T
  public :: TimeStampOptions_T

  ! We can use the advance=.. mechanism to convey extra formatting info
  interface getOption
    module procedure getOption_char, getOption_log
  end interface

  ! Embeddded <cr> print multiple lines
  interface Output
    module procedure Output_Char, Output_Char_array, output_complex
    module procedure Output_Dcomplex, output_double
    module procedure Output_Integer, output_integer_array
    module procedure Output_Logical, output_logical_array
    module procedure Output_Single, output_double_array, output_single_array
    module procedure Output_String
  end interface

  ! This won't filter for <cr>
  interface Output_
    module procedure Output_Char_NoCR
  end interface

  ! We can use the OutputLines mechanism for user-controlled
  ! buffering, filtering, grep-ing, or whatever
  integer, parameter :: numPatterns = 13 ! How many special patterns may we store
  integer, public, parameter :: MaxOutputlinesLen = 2048 ! How many chars it can hold
  character(len=MAXOUTPUTLINESLEN), public, save     :: OutputLines = ' '

  ! This is the type for configuring how to automatically format
  ! lines and whether they should be sent to stdout or elsewhere
  ! The default values work well; be cautious in overriding them
  type OutputOptions_T
    integer :: PrUnit = StdoutPrUnit    ! Unit for output (see comments above).  
    integer :: MLSMSG_Level        = MLSMSG_Info ! What level if logging
    integer :: NewLineVal          = 10 ! 13 means <cr> becomes new line; -999 means ignore
    integer :: NArrayElmntsPerLine = 7
    integer :: NBlanksBtwnElmnts   = 3
    integer :: WrapPastColumn      = 0
    logical :: AlwaysWrap          = .false. ! Lines longer than WrapPastColumn
    logical :: Buffered            = .true.
    logical :: LogParent           = .false. ! Show who called output, not output
    logical :: PrUnitLiteral       = .false. ! output to prUnit even if < 0
    logical :: SkipMLSMsgLogging   = .false.
    character(len=FileNameLen) :: name = 'stdout'
    character(len=3)  :: AdvanceDefault = 'no' ! if advance=.. missing
    character(len=12) :: SdFormatDefault = '*' ! * means default format spec
    character(len=1)  :: ArrayElmntSeparator = ' '
    character(len=27) :: ParentName = "$RCSfile: output_m.f90,v $"
  end type

  ! This is the type for advanced formatting options from the optional arg
  !    advance=..
  ! Note:
  ! Pausing to wait for user input may hang that job running at the sips
  ! Remember to strip out any debugging use of 
  !    advance='.. pause ..'
  ! before delivery
  type AdvancedOptions_T
    logical :: stretch             = .false. ! p r i n t  l i k e  t h i s   ?
    logical :: bannered            = .false. ! print as a banner
    logical :: headered            = .false. ! print as a headline
    logical :: pause               = .false. ! pause and wait for user input
    type(OutputOptions_T) :: originalOptions
  end type

  ! This is the type for showing special patterns in blanks or other occasions
  ! where something interesting and eye-catching is desired.
  ! These predefined settings should normally suit us well; don't change them
  ! without testing!
  type patternOptions_T
    logical :: usePatternedBlanks  = .true. ! Use patterns for special fillChars
    character(len=numPatterns) :: specialFillChars = '0123456789ABC'
    character(len=numPatterns) :: lineupFillChars =  'yynnnnynnnyyn' ! whether they line up
    character(len=16), dimension(numPatterns) :: patterns = (/ & ! on consecutive lines
                                            &  '                ' , &
                                            &  '(. )            ' , &
                                            &  '(. .)           ' , &
                                            &  '(.  .)          ' , &
                                            &  '(.   .)         ' , &
                                            &  '(.. ..)         ' , &
                                            &  '(- )            ' , &
                                            &  '(- -)           ' , &
                                            &  '(-  -)          ' , &
                                            &  '(- .. )         ' , &
                                            &  '(= )            ' , &
                                            &  '(~ )            ' , &
                                            &  '(= ~ )          ' /)
                                            !   12345678901234567890
    ! Here are samples of the special pre-defined patterns above
    !       Special patterns used in blanks
    ! pattern
    !  0                                                                 
    !  1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   
    !  2  . .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .   
    !  3  .  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  .   
    !  4  .   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   ..   .   
    !  5  .. .... .... .... .... .... .... .... .... .... .... .... ..   
    !  6 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   
    !  7  - -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -   
    !  8  -  --  --  --  --  --  --  --  --  --  --  --  --  --  --  -   
    !  9  - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - .. - ..    
    !  A = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   
    !  B ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~   
    !  C  = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~ = ~    
  end type

  type(AdvancedOptions_T), public, save :: AdvancedOptions
  type(AdvancedOptions_T), private, save :: DefaultAdvancedOptions
  type(OutputOptions_T), public, save   :: OutputOptions
  type(PatternOptions_T), public, save  :: PatternOptions
  type(OutputOptions_T), private, save  :: DefaultOutputOptions

  ! This is the type for configuring whether and how to automatically stamp
  ! lines sent to stdout
  ! If interval > 1 only a fraction of lines will be stamped
  ! If interval > 10, the stamps will not be in-line, instead
  ! they will appear alone as page headers
  ! (As an alternative, use timeStamp to stamp only individual lines)
  type stampOptions_T
    logical :: neverStamp = .true.  ! if true, forget about automatic stamping
    logical :: post       = .true.      ! Put stamp at end of line?
    logical :: showTime   = .false. ! Don't show date or time unless TRUE
    character(len=24) :: textCode = ' '
    ! Don't show date unless dateFormat is non-blank
    character(len=16) :: dateFormat = ' '
    character(len=16) :: timeFormat = 'hh:mm'
    integer :: interval = 1 ! 1 means stamp every line; n means every nth line
    character(len=8) :: timeStampStyle = 'post' ! 'pre' or 'post'
  end type

  type(stampOptions_T), public, save :: stampOptions ! Could leave this private
  type(stampOptions_T), private, save :: DefaultStampOptions

  ! This is the type for configuring how the timeStamp stamps its lines)
  type timeStampOptions_T
    logical           :: post = .true.      ! Put stamp at end of line?
    logical           :: showDate = .false. ! Don't show date unless TRUE
    character(len=24) :: textCode = ' '
    ! Don't show date unless dateFormat is non-blank
    character(len=16) :: DateFormat     = 'yyyy-mm-dd'
    character(len=16) :: TimeFormat     = 'hh:mm:ss'
    character(len=8)  :: TimeStampStyle = 'post' ! 'pre' or 'post'
  end type

  type(timeStampOptions_T), public, save :: TimeStampOptions ! Could leave this private
  type(timeStampOptions_T), private, save :: DefaultTimeStampOptions
  logical, public, save                   :: MustRestoreAdvOpts = .false.

  ! Private parameters
  logical :: alreadyLogged ! Would we need to print again?
  logical, save :: DeeBug = .false.
  character(len=2), parameter :: defaultNewLineCode = achar(0) // 'n' ! not '%n'
  logical, save, private :: SWITCHTOSTDOUT = .false.! Temp'ly all to stdout
  logical, save, private :: SILENTRUNNING  = .false. ! Suspend all further output
  integer, save, private :: ATCOLUMNNUMBER = 1  ! Where we'll print next
  ! See below for uses of indentBy
  integer, save, private :: INDENTBY       = 0  ! How many spaces to indent
  logical, save, private :: ATLINESTART = .true.! Are we at the line's start?
  integer, save, private :: LINESSINCELASTSTAMP = 0
  logical, private, parameter :: LOGEXTRABLANKS = .false.
  integer, private, parameter :: RECLMAX = 1024  ! This is NAG's limit
  ! logical, save, private :: AlwaysWrap          = .false. ! once past WrapPastColumn
  ! integer, save, private :: WrapPastColumn = 0  ! Don't print beyond (if > 0)

  ! For certain numerical values we will use list directed '*' format
  ! unless optional FORMAT specifier supplied
  double precision, parameter, dimension(3) :: DPREFERDEFAULTFORMAT = &
    & (/ -1.d0, 0.d0, 1.d0 /)  ! For which values to use default format '*'
  real, parameter, dimension(3) :: RPREFERDEFAULTFORMAT = &
    & (/ -1., 0., 1. /)  ! For which values to use default format '*'
  character(len=16), private, save :: NONFINITEFORMAT = '(1pg14.6)' ! 'NaN, Inf'
  ! For printing logical-valued arguments
  integer, private, parameter          :: true  = 1 ! Index in TruthValues
  integer, private, parameter          :: false = 2
  character(len=2), dimension(2), save :: TruthValues = &
    & (/ 'T ', 'F ' /)
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: output_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  ! --------- Indenting procedures --------
  ! The idea is to have a virtual printed page offset 
  ! from the actual physical page by an amount, indentBy
  ! So if we print something to column k, it shows up
  ! printed in column (k+indentBy)
  !
  ! The indents will affect all calls to:
  !   blanks
  !   output
  ! and subroutines in other modules that USE them.
  ! Indents will not affect logged output or 'print *,'
  ! or calls made directly to PrintItOut
  ! -----------------------------------------------------  addToIndent  -----
  subroutine addToIndent ( n )
  ! add n blanks To Indent
    integer, intent(in) :: n
    indentBy = max( indentBy + n, 0 )
  end subroutine addToIndent

  ! -----------------------------------------------------  resetIndent  -----
  subroutine resetIndent
  ! Reset Indent back to 0
    indentBy = 0
  end subroutine resetIndent

  ! .......................................  Advance_is_yes_or_no  .....
  function Advance_is_yes_or_no ( str ) result ( outstr )
    ! Process the advance argument in
    !   call output( something, [advance='arg1 [arg2] .. [argn]' )
    ! takes '[Yy]...' or '[Nn..] and returns 'yes' or 'no' respectively
    ! also does the same with '[Tt]..' and '[Ff]..'
    ! Returns OutputOptions%advanceDefault if the argument is absent.
    !        A d v a n c e d   u s a g e
    ! All the other usagess require a longer explanation:
    ! (1)
    ! 'beep', 'stderr' or just 'err' is special case--we return 'beep'
    ! trusting that the caller will print to stderr instead of stdout
    ! (2)
    ! if the initial character isn't one of [YyNn], or (1), we return 
    ! OutputOptions%advanceDefault (just as if it were missing)
    ! (3)
    ! We are allowing the argument str to do multiple duties by being
    ! composed of multiple space-separated sub-arguments, e.g. 
    !   'arg1 [arg2] .. [argn]'
    ! the first arg1 is treated as before, basically 'yes' or 'no' or 'beep'.
    ! arg2 and beyond set AdvancedOptions to the
    ! output command:
    !   sub-arg                   meaning
    !   -------                   -------
    !      (These options take effect permanently)
    !     save         save original OutputOptions to be restored later
    !    restore       restore original OutputOptions
    !    unit n        set print unit to n
    !    level k       set severity level to k if calling MLSMessage
    !   newline m      use achar(m) as character for newLine
    !    wrap          Wrap lines longer than WrapPast Column
    !    wrappast col  Set WrapPast Column to col
    !
    !      (These options take effect only temporarily)
    !     pause        pause and wait for user input
    !    stretch       s t r e t c h  characters before printing
    !                  * -------------------------------------- *
    !    banner        *   surround characters with a banner    *
    !                  * -------------------------------------- *
    !    header        *-- surround characters with a header ---*
    !--------Argument--------!
    character (len=*), intent(in), optional :: Str
    character (len=4) :: Outstr ! 'yes', 'no', or 'beep'

    !----------Local vars----------!
    character (len=*), parameter :: yeses = 'YyTt'
    character (len=*), parameter :: nose = 'NnFf'
    integer                      :: kSpace
    ! Executable
    if ( .not. present(str)  ) then
      outstr = outputoptions%advanceDefault ! 'no'
      if ( OutputOptions%AlwaysWrap .and. AtColumnNumber > OutputOptions%WrapPastColumn .and. &
        & OutputOptions%WrapPastColumn > 0 ) &
        & outstr = 'yes'
      return
    end if
    outstr = adjustl(str)
    kSpace = index( outstr, ',' ) ! Did we separate args with a ',' ?
    if ( kspace < 1 ) kSpace = index( outstr, ' ' )
    if ( kSpace > 1 ) outstr = outstr(:kSpace) ! To snip off arg2 ..
    if ( index( yeses, outstr(:1)) > 0  ) then
      outstr = 'yes'
    else if ( index( nose, outstr(:1)) > 0  ) then
      outstr = 'no'
    else if ( index( lowercase(outstr), 'beep' ) > 0  ) then
      outstr = 'beep'
    else if ( index( lowercase(outstr), 'err' ) > 0  ) then
      outstr = 'beep'
    else if ( index( lowercase(outstr), 'stde' ) > 0  ) then
      outstr = 'beep'
    else
      outstr = outputoptions%advanceDefault ! str
    end if
    if ( OutputOptions%AlwaysWrap .and. AtColumnNumber > OutputOptions%WrapPastColumn .and. &
      & OutputOptions%WrapPastColumn > 0 ) &
      & outstr = 'yes'
    if ( len_trim(str) < 4 ) return
    ! write(*,*) 'str       = ', str
    ! Now set more advanced options based on str
    call SetAdvancedOption( str )
    ! Remember to restore previous advanced options
    MustRestoreAdvOpts = .true.
  end function Advance_is_yes_or_no

  ! -----------------------------------------------------  Beep  -----
  subroutine Beep ( chars )
    use, intrinsic :: ISO_Fortran_Env, only: Error_Unit
  ! Print chars to stderr
    character(len=*), intent(in), optional :: chars
    if ( present(chars) ) then
      write( Error_Unit, * ) trim(chars)
    else
      write( Error_Unit, * ) 'Beep'
    endif
  end subroutine Beep

  ! -----------------------------------------------------  Blanks  -----
  subroutine Blanks ( N_Blanks, Fillchar, Advance, Dont_Stamp )
  ! Output N_Blanks blanks to PRUNIT.
  ! or optionally that many copies of fillChar.
  ! If FillChar is one of the SpecialFillChars maintained in outputOptions
  ! we print the corresponding pattern instead of blanks.
    integer, intent(in) :: N_BlankS
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: Fillchar  ! default is ' '
    logical, intent(in), optional          :: Dont_stamp ! Prevent double-stamping
    integer :: I    ! Blanks to write in next Write statement
    logical :: lineup
    integer :: ntimes
    integer :: numSoFar
    character(len=16) :: pattern
    integer :: patternLength
    integer :: patternNum
    integer :: theRest
    ! Executable
    if ( present(fillChar) ) then
      if ( patternOptions%usePatternedBlanks .and. &
        & index(patternOptions%specialFillChars, FILLCHAR) > 0 ) then
        ! We need to try to fit our called-for pattern into n_Blanks
        ! The 1st question is, how many times could it be done?
        patternNum = index( patternOptions%specialFillChars, FillChar )
        pattern = patternOptions%patterns(patternNum)
        ! The pattern length (adjusted for enclosing parentheses)
        patternLength = len_trim(pattern) - 2
        ! Now we assume we'll always want the first and Blanks of n_Blanks to be
        ! purely Blank
        if ( patternLength > n_blanks - 2 ) then
          ! n_blanks too short--just print blanks
          call Pr_Blanks ( n_blanks, advance=advance, dont_stamp=dont_stamp )
          return
        end if
        ntimes = (n_blanks-2)/patternLength
        ! In case we want latterns on consecutive lines to line up; viz
        ! a: . . . . . . Something
        ! xy:. . . . . . Something else
        lineup = ( patternOptions%lineupFillChars(patternNum:patternNum) == 'y' )
        if ( lineup ) then
          numSoFar = 0
          ! Make sure that we always begin on an even-numbered column
          ! (This only works for patterns like '. . . ' or '- - - '
          if ( mod(atColumnNumber, 2) /= 0 ) then
            call Pr_Blanks ( 1, advance='no' )
            numSoFar = 1
          end if
        else
          call Pr_Blanks ( 1, advance='no' )
          numSoFar = 1
        end if
        do i=1, ntimes
          call output_ ( pattern(2:patternLength+1), advance='no' )
          ! if ( xtraBlanks > 0 ) call Pr_Blanks ( xtraBlanks, advance='no' )
          numSoFar = numSoFar + patternLength
        enddo
        theRest = n_blanks - numSoFar
        if ( theRest > 0 ) call Pr_Blanks ( theRest, advance=advance, dont_stamp=dont_stamp )
        return
      end if
    end if
    call Pr_Blanks ( n_blanks, fillChar=fillChar, advance=advance, dont_stamp=dont_stamp )
  end subroutine Blanks

  ! ----------------------------------------------  flushOutputLines  -----
  ! print or log OutputLines
  ! then reset to ''
  subroutine flushOutputLines ( prUnit )
    ! use, intrinsic :: ISO_Fortran_Env, only: Output_Unit
    ! Args
    integer, optional, intent(in) :: prUnit ! How do you want 'em?
    ! Local arguments
    integer :: kNull  ! 1 past where the end of str occurs
    integer :: myPrUnit
    integer :: oldPrUnit
    ! Executable
    myPrUnit = -1 ! By default, just print to stdout
    if ( present(prUnit) ) myPrUnit = prUnit
    oldprUnit = outputOptions%prUnit
    outputOptions%prUnit = myPrUnit
    kNull = index( OutputLines, achar(0), back=.true. )
    if ( kNull >= 2 .and. kNull <= len(OutputLines) ) &
      & call output( OutputLines(1:kNull-1) )
    OutputLines = ' '
    ! flush ( merge ( output_Unit, outputOptions%prUnit, outputOptions%prUnit < 0 ) )
    outputOptions%prUnit = oldPrUnit
  end subroutine flushOutputLines

  ! ----------------------------------------------  FlushStdout  -----
  ! Flush Whichever output unit is being used
  subroutine FlushStdout
    use, intrinsic :: ISO_Fortran_Env, only: Output_Unit
    ! Executable
    flush( Output_Unit )
  end subroutine FlushStdout

  ! ---------------------------------------------- GetOutputStatus
  ! Returns certain normally private data
  ! intended for modules like highOutput and maybe some others
  ! result will be an integer
  ! equal to the value of integer-valued data
  ! or to 1 if the logical-valued data is TRUE, 0 if FALSE
  function GetOutputStatus( name, value ) result( status )
    ! Args
    character(len=*), intent(in)            :: name
    character(len=*), intent(out), optional :: value
    integer                                 :: status
    ! Executable
    status = -999 ! meaning name was not recognized
    if ( present(value) ) value = 'value not relevant for this name'
    if ( index(lowercase(name), 'physicalcolumn' ) > 0 ) then
      status = atColumnNumber            ! This is the "physical" column
    elseif ( index(lowercase(name), 'column' ) > 0 ) then
      status = atColumnNumber - indentBy ! This is the "virtual" column
    elseif( index(lowercase(name), 'indent' ) > 0 ) then
      status = indentBy
    elseif( index(lowercase(name), 'start' ) > 0 ) then
      status = merge(1, 0, atLineStart)
    elseif( index(lowercase(name), 'lines' ) > 0 ) then
      status = linesSincelastStamp
    elseif( index(lowercase(name), 'silent' ) > 0 ) then
      status = merge(1, 0, silentRunning)
    elseif( index(lowercase(name), 'wrappast' ) > 0 ) then
      status = OutputOptions%WrapPastColumn
    elseif( index(lowercase(name), 'wrap' ) > 0 ) then
      status = merge(1, 0, OutputOptions%AlwaysWrap)
    elseif( index(lowercase(name), 'true' ) > 0 .and. present(value)) then
      status = true
      value = TruthValues (true)
    elseif( index(lowercase(name), 'false' ) > 0 .and. present(value)) then
      status = false
      value = TruthValues (false)
    endif
  end function GetOutputStatus

  ! ---------------------------------------------- printOutputStatus
  ! Prints certain normally private data
  ! revealing what settings and options are in force
  subroutine printOutputStatus ( keywords )
    ! Args
    character(len=*), optional, intent(in) :: keywords
    ! Internal variables
    integer                                :: i
    ! Executable
    print *,  'atColumnNumber ', atColumnNumber            ! This is the "physical" column
    print *,  'atColumnNumber - indentBy ', atColumnNumber - indentBy ! This is the "virtual" column
    print *,  'indentBy ', indentBy
    print *,  'atLineStart? ', merge(1, 0, atLineStart)
    print *,  'linesSincelastStamp ', linesSincelastStamp
    print *,  'silentRunning ', merge(1, 0, silentRunning)
    if ( .not. present(keywords) ) return
    ! keyword tells which Output Options to print
    if ( ok ( 'unit'   ) )  print *, 'prUnit          ', outputOptions%prUnit
    if ( ok ( 'name'   ) )  print *, 'name            ', trim(outputOptions%name)
    if ( ok ( 'newlin' ) )  print *, 'newLineVal      ', outputOptions%newLineVal
    if ( ok ( 'sddef ' ) )  print *, 'sdFormatDefault ', outputOptions%sdFormatDefault
    if ( ok ( 'parent' ) )  print *, 'parentName      ', outputOptions%parentName
    if ( ok ( 'pattern' ))  then
      call output( 'Special patterns used in blanks ', advance='yes' )
      do i=1, numPatterns
        call output( 'pattern: ', advance='no' )
        call output( patternOptions%specialFillChars( i:i ), advance='no' )
        call blanks(1)
        call blanks( 64, FillChar=patternOptions%specialFillChars( i:i ) )
        call NewLine
      enddo
    endif
  contains
    logical function ok ( arg )
      ! Tell us whether keyword means it's ok to print arg
      ! '*' is the wildcard
      character(len=*), intent(in)   :: arg
      ok = ( keywords == '*' .or. index( lowercase(keywords), arg ) > 0 )
    end function ok
  end subroutine printOutputStatus

  ! ----------------------------------------------  IsOutputSuspended  -----
  logical function IsOutputSuspended ()
  ! Have we suspended outputting to PRUNIT?
    IsOutputSuspended = silentRunning
  end function IsOutputSuspended

  ! ----------------------------------------------------  NewLine  -----
  subroutine NewLine ( dont_make_blank_line )
    ! Go on to the next printed line
    ! unless already at column 1 and dont_make_blank_line is true
    ! Args
    ! If the following is TRUE, avoid
    ! adding a blank line; that means don't add
    ! a new line if at column 1
    logical, optional, intent(in) :: dont_make_blank_line
    ! Executable
    if ( present( dont_make_blank_line ) ) then
      if ( dont_make_blank_line .and. ATCOLUMNNUMBER == 1 ) return
    endif
    call output_ ( '', advance='yes' )
  end subroutine NewLine

  ! ------------------------------------------------  Output_Char  -----
  ! Output CHARS to PRUNIT.
  subroutine Output_Char ( Chars, &
    & advance, from_where, dont_log, log_chars, insteadofblank, dont_stamp, &
    & NewLineVal, dont_asciify, format )
    ! We will 1st check to see whether any internal characters are
    ! codes for newlines
    ! If any are, we will call newLine in place of printing
    ! them
    ! (This is a new default behavior; you can restore
    ! the old by passing an impossible value for NewLineVal, e.g. -999)
    !
    ! If NewLineVal is present, we'll use it as the code for new lines
    ! Otherwise, we default to outputOptions%newlineVal
    character(len=*), intent(in)           :: Chars
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: From_Where
    logical, intent(in), optional          :: Dont_Log ! prevent double-logging
    character(len=*), intent(in), optional :: Log_Chars
    character(len=*), intent(in), optional :: InsteadOfBlank ! What to output
    logical, intent(in), optional          :: Dont_Stamp ! prevent double-stamping
    integer, intent(in), optional          :: Newlineval ! What char val to treat as <cr>
    logical, intent(in), optional          :: Dont_asciify ! output binary
    character(len=*), intent(in), optional :: Format ! consistent with generic
    ! Internal variables
    integer :: I ! loop inductor
    integer :: BannerLen
    integer :: indent ! Should have chosen different name
    integer :: LineLen ! How many chars to print
    character(len=4) :: MY_ADV ! 'yes' if advance
    integer :: myNewLineVal
    logical :: myAsciify ! Convert non-printing chars to ascii?
    character(len=max(90, 2*(len(chars)+15))) :: newChars ! What to print
    ! Executable
    my_adv = Advance_is_yes_or_no(advance)
    ! call Dump_AdvancedOptions
    myNewLineVal = outputOptions%newlineVal
    if ( present(newLineVal) ) myNewLineVal = newLineVal
    myAsciify = .true.
    if ( present(dont_asciify) ) myAsciify = .not. dont_asciify
    ! If bannered, how large
    BannerLen = max( 80, 4 + len_trim(chars) )
    LineLen = len(chars)
    indent = ( BannerLen - LineLen ) / 2 ! spaces beetween '*' and start of chars
    newChars = chars
    if ( advancedOptions%bannered ) then
      call Output_Char_NoCR ( '*', advance='no' )
      call Output_Char_NoCR ( Repeat('-', BannerLen-2 ), advance='no' )
      call Output_Char_NoCR ( '*', advance='yes' )
    endif
    if ( advancedOptions%headered ) then
      newChars = '* ---- ' // newChars(:LineLen) // ' ---- *'
      LineLen = LineLen + 2*7
    endif
    if ( advancedOptions%stretch ) then
      newChars = stretch( newChars, options='-a' )
      LineLen = 2*LineLen - 1
      BannerLen = max( 80, 4 + LineLen )
      indent = ( BannerLen - LineLen ) / 2
    endif
    ! write (*,*) 'bannered            =  ', advancedOptions%bannered 
    if ( advancedOptions%bannered ) then
      newChars = '*' // Repeat( ' ', indent-1 ) // newChars
      LineLen = Linelen + indent
      newChars(BannerLen:BannerLen) = '*'
      LineLen = Bannerlen
      ! print *, 'newChars ', newChars
    endif
    ! Are any internal chars new line vals?
    i = index( chars, achar(myNewLineVal) )
    if ( i < 1 ) then
      ! No internal new lines
      if ( myAsciify ) newChars = ReplaceNonAscii( newChars, '@@', exceptions=achar(9))
      if ( myAsciify ) then
        call Output_Char_NoCR ( newChars(:LineLen), &
          & advance, from_where, dont_log, log_chars, insteadofblank, dont_stamp )
      else
        call Output_Char_NoCR ( newChars(:LineLen), &
          & advance, from_where, dont_log, log_chars, insteadofblank, dont_stamp )
      endif
    else
      ! Print every character one-by-one except internal new lines, at
      ! which we'll call NewLine instead
      do i=1, len(chars)
        if ( chars(i:i) /= achar(myNewLineVal) ) then
          if ( myAsciify ) then
            call Output_Char_NoCR ( ReplaceNonAscii(CHARS(i:i), '@@', exceptions=achar(9)), &
              & advance='no', from_where=from_where, dont_log=dont_log, &
              & log_chars=log_chars, insteadofblank=insteadofblank, &
              & dont_stamp=dont_stamp )
          else
            call Output_Char_NoCR ( CHARS(i:i), &
              & advance='no', from_where=from_where, dont_log=dont_log, &
              & log_chars=log_chars, insteadofblank=insteadofblank, &
              & dont_stamp=dont_stamp )
          endif
        else
          call newLine
        endif
      enddo
      if ( my_adv == 'yes' ) call newLine
    endif
    ! write (*,*) 'bannered            =  ', advancedOptions%bannered 
    if ( advancedOptions%bannered ) then
      call Output_Char_NoCR ( '*', advance='no' )
      call Output_Char_NoCR ( Repeat('-', BannerLen-2 ), advance='no' )
      call Output_Char_NoCR ( '*', advance='yes' )
    endif
    if ( MustRestoreAdvOpts ) then
      AdvancedOptions = DefaultAdvancedOptions
      MustRestoreAdvOpts = .false.
    endif
  end subroutine Output_Char

  subroutine Output_Char_NoCR ( Chars, &
    & advance, from_where, dont_log, log_chars, insteadofblank, dont_stamp )
    character(len=*), intent(in)           :: Chars
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: From_Where
    logical, intent(in), optional          :: Dont_Log ! prevent double-logging
    character(len=*), intent(in), optional :: Log_Chars
    character(len=*), intent(in), optional :: InsteadOfBlank ! What to output
    logical, intent(in), optional          :: Dont_Stamp ! prevent double-stamping
    !
    character(len=4) :: MY_ADV
    ! Executable
    my_adv = Advance_is_yes_or_no(advance)
    atLineStart = (my_adv == 'yes')
    if ( indentBy > 0 .and. atColumnNumber == 1 ) then
      call Output_Char_NoCR_indented ( repeat( ' ', indentby ) // chars, &
        & advance, from_where, dont_log, log_chars, insteadofblank, dont_stamp )
    else
      call Output_Char_NoCR_indented ( chars, &
        & advance, from_where, dont_log, log_chars, insteadofblank, dont_stamp )
    endif
    ! Were we asked to Pause?
    ! If so read 1 char from stdin
    ! Note: this may hang a job running under sips control so strip
    ! out any debugging use of this before delivery
    ! print *, 'pause: ', advancedOptions%pause
    if ( advancedOptions%pause ) then
      ! print *, '(P a u s e d .. e n t e r   o k   t o   r e s u m e, p   t o   s t e p)'
      ! read (*,'(a)') my_adv(1:1)
      ! Reset--unless told to ste'p', must explicitly request next pause
      call Pause ( my_adv, Prompts=(/ &
        & '(P a u s e d .. e n t e r   o k   t o   r e s u m e, p   t o   s t e p)' &
        & /) )
      if ( index('pP', my_adv(1:1)) < 1 ) advancedOptions%pause = .false. 
    endif
    if ( MustRestoreAdvOpts ) then
      AdvancedOptions = DefaultAdvancedOptions
      MustRestoreAdvOpts = .false.
    endif
  end subroutine Output_Char_NoCR

  subroutine Output_Char_NoCR_Indented ( chars, &
    & advance, from_where, dont_log, log_chars, insteadofblank, dont_stamp )
    ! -------------------------------------------------------------------
    ! We have arrived at
    !   T h e   w o r k h o r s e
    ! We have taken care of linefeeds, indents, and numeric conversions
    ! so now we do one of
    ! (1) print to stderr if advance = 'stderr' or 'beep'
    ! (2) go silent if we are skipping all output
    ! (3) write to a file unit if PrUnit is to be taken literally
    ! (4) append to our accumulated OutputLines if we are deferring output
    ! (5) print immediately if we have been switched to stdout
    ! (6) wade through a thicket of sub-choices involving possibly
    !     (a) time stamps, either individually or grouped
    !     (b) logging, either instead of printing or in addition
    ! -------------------------------------------------------------------
    ! Should we rename this subroutine something less opaque, less obscure?
    ! Not precisely the lowest level, because we may call 
    !   Beep
    !   MyMesssage
    !   PrintItOut
    use, intrinsic :: ISO_Fortran_Env, only: Output_Unit
    use SDPToolkit, only: Stamp
    character(len=*), intent(in)           :: Chars
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: From_Where
    logical, intent(in), optional          :: Dont_Log ! prevent double-logging
    character(len=*), intent(in), optional :: Log_Chars
    character(len=*), intent(in), optional :: InsteadOfBlank ! What to output
    logical, intent(in), optional          :: Dont_Stamp ! prevent double-stamping
    !
    ! logical :: alreadyLogged
    logical :: DoIt    ! TheUnit /= 0 .or. outputOptions%prUnitLiteral
    integer :: i1, i2
    integer :: IOBloc
    integer :: nIOBlocs
    character(len=max(16,len(chars)+1)) :: my_chars
    character(len=len(chars)+64) :: stamped_chars ! What to print to stdout
    character(len=max(16,len(chars)+1)) :: the_chars
    logical :: my_dont_log
    logical :: my_dont_stamp
    character(len=4) :: MY_ADV
    integer :: n_chars
    integer :: n_stamp ! How much of stamped_chars to print
    logical :: stamp_header
    logical :: stamped
    integer :: status
    integer :: TheUnit ! zero for PrUnit == MSGLOGPRUNIT, else unit number
    ! Executable
    n_chars = len(chars)
    alreadyLogged = .false.
    my_adv = Advance_is_yes_or_no( advance )
    ! Print to stderr instead?
    if ( my_adv == 'beep' ) then
      call Beep( chars )
      if ( MustRestoreAdvOpts ) then
        AdvancedOptions = DefaultAdvancedOptions
        MustRestoreAdvOpts = .false.
      endif
      return
    endif
    if ( SILENTRUNNING ) go to 9 ! When we skip all output
    ! print *, 'outputOptions%prUnit: ', outputOptions%prUnit
    ! print *, 'outputOptions%prUnitLiteral: ', outputOptions%prUnitLiteral
    ! Do any special orders apply to this output?
    if ( outputOptions%prunit ==  OutputLinesPrUnit ) then
      ! Append to OutputLines; maybe print later on
      call append_chars( OutputLines, chars )
      if ( my_adv == 'yes' ) &
        &  call append_chars( OutputLines, achar(outputOptions%NewLineVal) )
      ! print *, 'Appending to OutputLines; now ', trim(OutputLines)
      go to 9
    elseif ( outputOptions%prUnitLiteral ) then
      write( outputOptions%prUnit, '(a)', advance=my_adv ) chars
      ! print *, chars
      go to 9
    elseif ( SWITCHTOSTDOUT ) then
      write( *, '(a)', advance=my_adv ) chars
      ! print *, chars
      go to 9
    end if
    ! If we're not advancing and we've been a string of length 0 to print ..
    if ( my_adv == 'no' .and. len(chars) < 1 ) return
    my_dont_stamp = stampOptions%neverStamp ! .false.
    if ( present(dont_stamp) ) my_dont_stamp = dont_stamp
    my_dont_stamp = ( my_dont_stamp .or. &
      & linesSinceLastStamp < (stampOptions%interval - 1) )
    stamped = .false.
    stamp_header = .false.
    stamped_chars = chars
    theUnit = 0
    if ( outputOptions%prUnit > 0 .or. outputOptions%prUnitLiteral ) then
      theUnit = outputOptions%prUnit
    else if ( useStdout(outputOptions%prUnit) ) then
      theUnit = output_unit
    end if
    doIt = TheUnit /= 0 .or. outputOptions%prUnitLiteral
    ! Are we trying to avoid buffered output?
    ! The good part is that if we crash hard we won't lose that
    ! last line.
    if ( (.not. outputOptions%buffered) .and. doIt .and. &
      & ( atcolumnnumber == 1 ) ) then
      flush ( theUnit, iostat=status )
      if ( status /= 0 ) call PrintItOut ( &
        & trim('Unable to flush prUnit ' // outputOptions%name), &
        & 1, exitStatus=1 )
    endif
    ! Do we need to stamp this line? If so, at beginning or at end?
    if ( my_dont_stamp ) then
    elseif ( stampoptions%interval > 9 ) then
      stamp_header = (my_adv == 'yes')
    elseif ( stampoptions%post ) then
      if ( my_adv == 'yes' ) then
        stamped_chars = stamp ( chars, stampOptions%dateFormat, &
          & stampOptions%timeFormat, stampOptions%textCode, &
          & stampOptions%post, stampOptions%showTime )
        stamped = .true.
      end if
    elseif( ATLINESTART ) then
      stamped_chars = stamp ( chars, stampOptions%dateFormat, &
          & stampOptions%timeFormat, stampOptions%textCode, &
          & stampOptions%post, stampOptions%showTime )
      stamped = .true.
    end if

    if (LOGEXTRABLANKS) n_chars = max(len(chars), 1)
    my_dont_log = outputOptions%skipmlsmsglogging ! .false.
    if ( present(dont_log) ) my_dont_log = dont_log
    n_stamp = len_trim(stamped_chars)
    if ( my_adv == 'no' ) n_stamp = n_stamp + len(chars) - len_trim(chars)
    ! Special case: if chars is blank (chars are blank?)
    ! we'll want to print anyway
    if ( len_trim(chars) < 1 ) n_stamp = max(n_stamp, 1)
    ! print *, 'n_stamp: ', n_stamp
    ! print *, 'len(chars): ', len(chars)
    alreadyLogged = .true.
    if ( doIt .and. n_stamp > RECLMAX ) then
      nIOBlocs = 1 + (n_stamp-1)/RECLMAX
      i2 = 0
      do IOBloc=1, nIOBlocs
        i1 = i2 + 1
        i2 = min(i2+RECLMAX, n_stamp)
        write ( theUnit, '(a)', advance='no' ) stamped_chars(i1:i2)
      enddo
      if ( my_adv == 'yes' ) write ( theUnit, '(a)' )
    elseif ( doIt .and. len(chars) < 1 .and. my_adv == 'yes' ) then
      write ( theUnit, '(a)', advance=my_adv )
      ! print *, 'wrote: ', stamped_chars(1:n_stamp), ' to ', theUnit
    elseif ( doIt .and. n_stamp > 0 ) then
      write ( theUnit, '(a)', advance=my_adv ) stamped_chars(1:n_stamp)
      ! print *, 'wrote: ', stamped_chars(1:n_stamp), ' to ', theUnit
    else
      alreadyLogged = .false.
    endif
    if ( any(outputOptions%prunit == (/MSGLOGPRUNIT, BOTHPRUNIT/)) .and. &
      & .not. my_dont_log .and. .not. outputOptions%prUnitLiteral ) then
      ! We must use MLSMessage to log the chars
      the_chars = chars // ' '
      if (LOGEXTRABLANKS) n_chars = max(len(chars), 1)
      if ( present(log_chars) ) then
        if ( len_trim(log_chars) > 0 ) then
          n_chars = len_trim(log_chars) + 1
          the_chars = log_chars(:n_chars-1) // ' '
        end if
      end if
      if ( the_chars == ' ' .and. present(insteadofblank)  ) then
        my_chars = trim(insteadofblank) // ' '
        if (LOGEXTRABLANKS) n_chars = max(len(insteadofblank), 1)
      else
        my_chars = the_chars
      end if
      if ( my_adv == 'no' .and. LOGEXTRABLANKS ) n_chars = n_chars+1
      n_chars = min(n_chars, len(my_chars))
      if ( my_adv == 'yes' ) n_chars = max(n_chars, 1)
      if ( n_chars < 1 ) then
      elseif ( present(from_where)  ) then
        call myMessage ( outputOptions%MLSMSG_Level, from_where, &
          & my_chars(1:n_chars), &
          & advance=my_adv )
      elseif ( outputOptions%logParent ) then
        call myMessage ( outputOptions%MLSMSG_Level, &
          & outputOptions%parentName, &
          & my_chars(1:n_chars), &
          & advance=my_adv )
      else
        call myMessage ( outputOptions%MLSMSG_Level, &
          & ModuleName, &
          & my_chars(1:n_chars), &
          & advance=my_adv )
      end if
    end if

    ! print *, 'alreadyLogged: ', alreadyLogged
    ! print *, 'theUnit: ', theUnit
    if ( (outputOptions%prunit <= 0 .and. .not. outputOptions%prunitLiteral) &
      & .or. alreadyLogged ) then
      ! Already logged; no output to stdout
    else if ( stamped_chars == ' ' .and. present(insteadofblank)  ) then
      write ( outputOptions%prunit, '(a)', advance=my_adv ) trim_safe(insteadofblank)
    else if ( stamped_chars == ' ' .and. my_adv == 'no' ) then
      write ( outputOptions%prunit, '(a)', advance='no' ) ' '
    elseif ( len_trim(chars) < 1 .and. n_stamp == 1 ) then
      write ( outputOptions%prunit, '(a)', advance=my_adv )
    else
      write ( outputOptions%prunit, '(a)', advance=my_adv ) stamped_chars(1:n_stamp)
    end if
    if ( alreadyLogged .and. outputOptions%prunitLiteral ) &
      & flush ( theUnit, iostat=status )
    atLineStart = (my_adv == 'yes')
    if ( atLineStart ) then
      ! Are we trying to avoid buffered output?
      if ( (.not. outputOptions%buffered) .and. doIt ) then
        flush ( theUnit, iostat=status )
        if ( status /= 0 ) call myMessage ( MLSMSG_Error, ModuleName, &
          & trim('Unable to flush prUnit ' // outputOptions%name) )
      endif
      if ( stamp_header ) then
        ! Time to add stamp as a page header on its own line
        stamped_chars = stamp ( ' ', stampOptions%dateFormat, &
          & stampOptions%timeFormat, stampOptions%textCode, &
          & stampOptions%post, stampOptions%showTime )
        stamped = .true.
        if ( doIt .and. len_trim(stamped_chars) > 0 ) then
          write ( theUnit, '(a)', advance='yes' ) trim(stamped_chars)
        end if
      end if
      if ( stamped ) then
        linesSinceLastStamp = 0
      else
        linesSinceLastStamp = linesSinceLastStamp + 1
      end if
    end if
9   continue
    atColumnNumber = atColumnNumber + n_chars
    if ( atLineStart ) atColumnNumber = 1
    if ( MustRestoreAdvOpts ) then
      AdvancedOptions = DefaultAdvancedOptions
      MustRestoreAdvOpts = .false.
    endif
  contains
    subroutine append_chars ( str, chars )
      ! Append chars to end of str
      ! where end is marked by the last null character (achar(0))
      ! Args
      character(len=*), intent(inout) :: str
      character(len=*), intent(in)    :: chars
      ! Local variables
      integer :: kNull  ! 1 past where the end of str occurs
      ! Executable
      kNull = index( str, achar(0), back=.true. ) + 1
      if ( kNull < 2 ) then
        ! str hasn't been defined yet
        str = chars // achar(0)
      elseif ( kNull > len(str) + 1) then
        ! Something very wrong
        str = achar(0)
      else
        str(kNull-1:) = chars // achar(0)
      endif
    end subroutine append_chars
  end subroutine Output_Char_NoCR_INDENTED

  ! ------------------------------------------  Output_Char_ARRAY  -----
  subroutine Output_Char_ARRAY ( CHARS, ADVANCE_AFTER_EACH, ADVANCE, &
    & INSTEADOFBLANK, NEWLINEVAL, format )
  ! Output CHARS to PRUNIT.
    character(len=*), intent(in) :: CHARS(:)
    character(len=*), intent(in), optional :: Advance_after_each
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: Insteadofblank ! what to output
    integer, intent(in), optional          :: Newlineval ! what char val to treat as <cr>
    character(len=*), intent(in), optional :: Format ! consistent with generic
    ! Internal variables
    integer :: I ! loop inductor
    ! Executable
    do i = 1, size(chars)
      call output ( chars(i), &
        & insteadofblank=insteadofblank, &
        & newLineVal=newLineVal, advance=ADVANCE_AFTER_EACH )
      if ( len(chars(1)) > 1 .and. .not. present(ADVANCE_AFTER_EACH) ) &
        & call SeparateElements( i, size(chars) )
    end do
    if ( present(advance)  ) then
      call output_ ( '', advance=advance )
    end if
  end subroutine Output_Char_ARRAY

  ! ---------------------------------------------  OUTPUT_COMPLEX  -----
  subroutine OUTPUT_COMPLEX ( VALUE, Format, Advance, Before, After, dont_stamp )
    complex, intent(in) :: VALUE
    character(len=*), intent(in), optional :: Format    ! How to print
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: Before, After ! text to print
    logical, intent(in), optional :: Dont_Stamp
    character(len=60) :: LINE

    if ( present(Format)  ) then
      write ( line, format ) value
    else
      write ( line, '("(",1pg15.7,",",1pg15.7,")")' ) value
    end if
    if ( present(before) ) call output_ ( before, dont_log = .true. )
    if ( present(after)  ) then
      call output_ ( trim(line), dont_log = .true. )
      call output_ ( after, advance=advance, dont_log = .true., &
        & dont_stamp=dont_stamp )
    else
      call output_ ( trim(line), advance=advance, dont_log = .true., &
        & dont_stamp=dont_stamp )
    end if
  end subroutine OUTPUT_COMPLEX

  ! --------------------------------------------  OUTPUT_DCOMPLEX  -----
  subroutine OUTPUT_DCOMPLEX ( VALUE, Format, Advance, Before, After )
    integer, parameter :: RK = kind(0.0d0)
    complex(rk), intent(in) :: VALUE
    character(len=*), intent(in), optional :: Format    ! How to print
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: Before, After ! text to print
    character(len=60) :: LINE

    if ( present(Format)  ) then
      write ( line, format ) value
    else
      write ( line, '("(",1pg22.14,",",1pg22.14,")")' ) value
    end if
    if ( present(before) ) call output_ ( before, dont_log = .true. )
    if ( present(after)  ) then
      call output_ ( trim(line), dont_log = .true. )
      call output_ ( after, advance=advance, dont_log = .true. )
    else
      call output_ ( trim(line), advance=advance, dont_log = .true. )
    end if
  end subroutine OUTPUT_DCOMPLEX

  ! ----------------------------------------------  OUTPUT_DOUBLE  -----
  subroutine OUTPUT_DOUBLE ( VALUE, Format, LogFormat, Advance, &
    & Before, After, dont_stamp, Trim )
  ! Output "double" to "prunit" using * format, trimmed of insignificant
  ! trailing zeroes, and trimmed of blanks at both ends.
    double precision, intent(in) :: VALUE
    character(len=*), intent(in), optional :: Format    ! How to print
    character(len=*), intent(in), optional :: LogFormat ! How to post to Log
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: Before, After ! text to print
    logical, intent(in), optional :: Dont_Stamp
    logical, intent(in), optional :: Trim ! Trim blanks even if Format present
    logical :: Do_Trim
    integer :: I, J, K
    character(len=30) :: LINE, LOG_CHARS, FormatSpec

    FormatSpec = outputOptions%sdFormatDefault
    if ( any( value == DPREFERDEFAULTFORMAT ) )  FormatSpec = '*'
    if ( .not. is_what_ieee(finite_signal, value) ) FormatSpec = NONFINITEFORMAT
    if ( present(Format)  ) FormatSpec = Format
    include 'numToChars.f9h'
    log_chars = ' ' ! line
    if ( present(LogFormat)  ) then
      write ( log_chars, LogFormat ) value
    end if
    if ( present(before) ) call output_ ( before )
    if ( present(after)  ) then
      call output_ ( line(:k), log_chars=log_chars )
      call output_ ( after, advance=advance, dont_stamp=dont_stamp )
    else
      call output_ ( line(:k), advance=advance, log_chars=log_chars, &
        & dont_stamp=dont_stamp )
    end if

  end subroutine OUTPUT_DOUBLE

  ! ----------------------------------------  OUTPUT_DOUBLE_ARRAY  -----
  subroutine OUTPUT_DOUBLE_ARRAY ( values, FORMAT, LogFormat, ADVANCE, DONT_STAMP )
  ! Output double-precision values to PRUNIT.
    double precision, intent(in) :: values(:)
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: FORMAT
    character(len=*), intent(in), optional :: LogFormat     ! How to post to Log
    logical, intent(in), optional          :: DONT_STAMP ! Prevent double-stamping
    integer :: I ! loop inductor
    do i = 1, size(values)
      call output ( values(i), advance='no', format=format, logFormat=logFormat )
      call SeparateElements( i, size(values) )
    end do
    if ( present(advance)  ) then
      call output_ ( '', advance=advance, DONT_STAMP=DONT_STAMP )
    end if
  end subroutine OUTPUT_DOUBLE_ARRAY

  ! ---------------------------------------------  OUTPUT_INTEGER  -----
  subroutine OUTPUT_INTEGER ( INT, PLACES, ADVANCE, FILL, FORMAT, &
    & Before, After, DONT_STAMP )
  ! Output INT to PRUNIT using at most PLACES (default zero) places
  ! If 'fill' is present and true, fill leading blanks with zeroes (only
  ! makes sense if 'places' is specified).

  ! Note that we never have places and format specified simultaneously
  ! we therefore institute the following trick:
  ! if format is present and contains the string 'PLACES=', the integer
  ! following the '=' will be taken to be places
    integer, intent(in) :: INT
    integer, intent(in), optional :: PLACES
    character(len=*), intent(in), optional :: Advance
    logical, intent(in), optional :: FILL
    character(len=*), intent(in), optional :: FORMAT
    character(len=*), intent(in), optional :: Before, After ! text to print
    logical, intent(in), optional :: Dont_Stamp
    !
    logical :: My_Fill
    integer :: I, J
    character(len=12) :: LINE
    character(len=12) :: myFormat
    integer :: MY_PLACES
    logical :: formatEncodesPlaces ! Have we used format to encode places?
    my_places = 0
    if ( present(places)  ) then; my_places = places; end if
    my_fill = .false.
    if ( present(places) .and. present(fill) ) my_fill = fill
    formatEncodesPlaces = .false.
    if ( present(format) ) then
      if ( index( lowercase(format), 'places=' ) > 0 ) then
        formatEncodesPlaces = .true.
        call readIntsFromChars ( format, my_places, ignore='*=' )
      endif
    endif
    if ( present(format) .and. .not. formatEncodesPlaces ) then
      line = ' '
      myFormat = '(i7)'
      if ( len_trim(format) > 1 ) myFormat = format
      write ( line, myFormat ) int
      i = 1
      j = len_trim(line)
    else if ( my_fill  ) then
      write ( line, '(i6.6)' ) int
      i = 1
      j = 6
    else
      write ( line, '(i12)' ) int
      i = max( 1, min(len(line)+1-my_places, index(line,' ',back=.true.)+1) )
      j = len(line)
    end if
    if ( present(before) ) call output_ ( before )
    if ( present(after)  ) then
      call output_ ( line(i:j), DONT_STAMP=DONT_STAMP )
      call output_ ( after, advance=advance, DONT_STAMP=DONT_STAMP )
    else
      call output_ ( line(i:j), advance=advance, DONT_STAMP=DONT_STAMP )
    end if
  end subroutine OUTPUT_INTEGER

  ! ---------------------------------------  OUTPUT_INTEGER_ARRAY  -----
  subroutine OUTPUT_INTEGER_ARRAY ( INTEGERS, ADVANCE, FORMAT, DONT_STAMP )
  ! Output INTEGERS to PRUNIT.
    integer, intent(in) :: INTEGERS(:)
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: FORMAT
    logical, optional, intent(in) :: DONT_STAMP
    integer :: I ! loop inductor
    do i = 1, size(integers)
      call output ( integers(i), advance='no', format=format )
      call SeparateElements( i, size(integers) )
    end do
    if ( present(advance)  ) then
      call output_ ( '', advance=advance, DONT_STAMP=DONT_STAMP )
    end if
  end subroutine OUTPUT_INTEGER_ARRAY

  ! ---------------------------------------------  OUTPUT_LOGICAL  -----
  subroutine OUTPUT_LOGICAL ( LOG, Advance, Before, DONT_STAMP, format )
  ! Output LOG to PRUNIT using at most PLACES (default zero) places
    logical, intent(in) :: LOG
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: BEFORE
    logical, optional, intent(in) :: DONT_STAMP
    character(len=*), intent(in), optional :: format ! consistent with generic
    character(len=2) :: LINE
    if ( log ) then
      line = TruthValues( true ) ! ' T'
    else
      line = TruthValues( false ) ! ' F'
    end if
    if ( present(before) ) call output_ ( before, DONT_STAMP=DONT_STAMP )
    call output_ ( line, advance=advance, DONT_STAMP=DONT_STAMP )
  end subroutine OUTPUT_LOGICAL

  ! ---------------------------------------------  OUTPUT_LOGICAL  -----
  subroutine OUTPUT_LOGICAL_ARRAY ( logs, &
    & Advance, Before, DONT_STAMP, ONLYIF, format )
    ! Output LOG to PRUNIT using at most PLACES (default zero) places
    ! Optionally, print non-blank only if T (or F)
    logical, dimension(:), intent(in) :: logs
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: BEFORE
    logical, optional, intent(in) :: DONT_STAMP
    logical, optional, intent(in) :: ONLYIF ! Print only if true (false)
    character(len=*), intent(in), optional :: format ! consistent with generic
    ! Internal variables
    character(len=1), dimension(size(logs)) :: clogs
    character(len=size(logs)) :: logChars
    integer :: I ! loop inductor
    character(len=1) :: ifonlyWhat
    ! Executable
    if ( present(before) ) call output_ ( before, DONT_STAMP=DONT_STAMP )
    if ( present(onlyif) ) then
      if ( onlyif ) then
        ifonlyWhat = TruthValues( true ) ! ' T'
      else
        ifonlyWhat = TruthValues( false ) ! ' F'
      endif
      clogs = ' '
      where (logs .eqv. onlyif)
        clogs = ifonlyWhat
      end where
      logChars = transfer( clogs, logChars )
      call output( logChars, advance='no' )
    else
      do i = 1, size(logs)
        call output ( logs(i), advance='no' )
        call SeparateElements( i, size(logs) )
      end do
    endif
    if ( present(advance) ) &
      & call output_ ( '', advance=advance, DONT_STAMP=DONT_STAMP )
  end subroutine OUTPUT_LOGICAL_ARRAY

  ! ----------------------------------------------  OUTPUT_SINGLE  -----
  subroutine OUTPUT_SINGLE ( VALUE, FORMAT, LogFormat, ADVANCE, &
    & Before, After, DONT_STAMP, Trim )
  ! Output "SINGLE" to "prunit" using * format, trimmed of insignificant
  ! trailing zeroes, and trimmed of blanks at both ends.
    real, intent(in) :: VALUE
    character(len=*), intent(in), optional :: Format  ! How to print
    character(len=*), intent(in), optional :: LogFormat     ! How to post to Log
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: Before, After ! text to print
    logical, optional, intent(in) :: DONT_STAMP
    logical, intent(in), optional :: Trim ! Trim blanks even if Format present
    logical :: Do_Trim
    integer :: I, J, K
    character(len=30) :: LINE, LOG_CHARS, FormatSpec

    FormatSpec = outputOptions%sdFormatDefault
    if ( any( value == RPREFERDEFAULTFORMAT ) )  FormatSpec = '*'
    if ( .not. is_what_ieee(finite_signal, value) ) FormatSpec = NONFINITEFORMAT
    if ( present(Format)  ) FormatSpec = Format
    include 'numToChars.f9h'
    log_chars = ' ' ! line
    if ( present(LogFormat)  ) then
      write ( log_chars, LogFormat ) value
    end if
    if ( present(before) ) call output_ ( before, DONT_STAMP=DONT_STAMP )
    if ( present(after)  ) then
      call output_ ( line(:k), log_chars=log_chars, DONT_STAMP=DONT_STAMP )
      call output_ ( after, advance=advance, DONT_STAMP=DONT_STAMP )
    else
      call output_ ( line(:k), advance=advance, log_chars=log_chars, &
        & DONT_STAMP=DONT_STAMP )
    end if
  end subroutine OUTPUT_SINGLE

  ! ----------------------------------------  OUTPUT_SINGLE_ARRAY  -----
  subroutine OUTPUT_SINGLE_ARRAY ( values, FORMAT, LogFormat, ADVANCE, DONT_STAMP )
  ! Output single-precision values to PRUNIT.
    real, intent(in) :: values(:)
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: FORMAT
    character(len=*), intent(in), optional :: LogFormat     ! How to post to Log
    logical, intent(in), optional          :: DONT_STAMP ! Prevent double-stamping
    integer :: I ! loop inductor
    do i = 1, size(values)
      call output ( values(i), advance='no', format=format, logFormat=logFormat )
      call SeparateElements( i, size(values) )
    end do
    if ( present(advance)  ) then
      call output_ ( '', advance=advance, DONT_STAMP=DONT_STAMP )
    end if
  end subroutine OUTPUT_SINGLE_ARRAY

  ! ----------------------------------------------  OUTPUT_STRING  -----
  subroutine OUTPUT_STRING ( STRING, LENSTRING, ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, format )
  ! Output STRING to PRUNIT.
    character(len=*), intent(in) :: STRING
    integer, intent(in) :: LENSTRING
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: FROM_WHERE
    logical, intent(in), optional          :: DONT_LOG ! Prevent double-logging
    character(len=*), intent(in), optional :: LOG_CHARS
    character(len=*), intent(in), optional :: format ! consistent with generic
    integer :: n_chars
    !
    n_chars = min(len(string), lenstring)
    if ( len(string) < 1  ) then
      call myMessage ( MLSMSG_Error, ModuleName, &
        & 'Bad string arg in OUTPUT_STRING' )
    else if ( len_trim(string) < 1 .or. LENSTRING < 1  ) then
      call output_ ( '', advance )
    else
      call output_ ( string(:n_chars), advance, from_where, dont_log, log_chars )
    end if
  end subroutine OUTPUT_STRING

  ! ----------------------------------------------  restoreSettings  -----
  subroutine restoreSettings ( settings )
  ! resume outputting to PRUNIT.
  ! optionally set to use or ignore Toolkit
    use PrintIt_m, only: DefaultLogUnit, Set_Config, StdoutLogUnit
    character(len=*), optional, intent(in) :: settings
    ! Local variables
    character(len=*), parameter            :: allSettings = &
      & 'toolkit,stamp,output,time'
    character(len=len(allSettings))        :: mySettings 
    logical                                :: useToolkit
    ! Executable
    mySettings = ' '
    if ( present(settings) ) mySettings = settings
    if ( index(mySettings, '*') > 0 ) mySettings = allSettings
    mySettings = lowercase(mySettings)
    if ( index(mySettings, 'output') > 0 ) outputOptions = DefaultOutputOptions

    if ( index(mySettings, 'stamp') > 0 ) stampOptions = DefaultStampOptions

    if ( index(mySettings, 'time') > 0 ) timeStampOptions = DefaultTimeStampOptions
    useToolkit = ( index(mySettings, 'toolkit') > 0 )
    if ( .not. useToolkit ) return
    call set_config ( useToolkit = useToolkit, &
      & logFileUnit=merge(defaultLogUnit, stdoutLogUnit, useToolkit) )
  end subroutine restoreSettings

  ! ----------------------------------------------  resumeOutput  -----
  subroutine resumeOutput 
  ! resume outputting to PRUNIT.
  ! Reverses effect of suspendOutput
    silentRunning = .false.
  end subroutine resumeOutput

  ! ----------------------------------------------  revertOutput  -----
  subroutine revertOutput
  ! revert to outputting to OLDUNIT. Close current PRUNIT (if > 0 and open)
  ! Unless switchOutput was called with filename == 'stdout'
    ! Local variables
    logical :: itsOpen
    ! Executable
    if ( SWITCHTOSTDOUT ) then
      SWITCHTOSTDOUT = .false.
      return
    endif
    call resumeOutput
    if ( .not. OLDUNITSTILLOPEN ) then
      call output_( 'Unable to Revert output--old unit not open', advance='yes' )
      return
    end if
    if ( outputOptions%prunit > 0 ) then
      inquire( unit=outputOptions%prunit, opened=itsOpen )
      if ( itsOpen ) then
        close(outputOptions%prunit)
      end if
    end if
    outputOptions%prunit = OLDUNIT    
    call output_( 'Reverting output to unit: ', advance='no' )
    call output( OLDUNIT, advance='yes' )

  end subroutine revertOutput

  ! ----------------------------------------------  setFillPattern  -----
  subroutine SetFillPattern ( pattern, fillChar )
  ! Override and set a special Fill pattern that can be used in a call to blanks
  ! e.g., by call blanks, FillChar='0' )
    character(len=1), optional, intent(in) :: fillChar
    character(len=*), optional, intent(in) :: pattern
    ! Local variables
    integer :: patternNum
    ! Executable
    patternNum = 1
    if ( present(fillChar) ) &
      & patternNum = index( patternOptions%specialFillChars, fillChar )
    patternOptions%patterns(patternNum) = pattern
    if ( index( pattern, '(' ) < 1 ) &
      & patternOptions%patterns(patternNum) = '(' // pattern // ')'
  end subroutine SetFillPattern

  ! -----------------------------------------------------  SetAdvancedOption  -----
  subroutine SetAdvancedOption ( str )
  ! Set advanced or miscellaneous options
  
  ! Note: these may be more conveniently done via setOutputStatus
  ! The way we do it is to painfully try picking str apart
  ! See how the options explained under Advance_is_yes_or_no
    character (len=*), intent(in), optional :: Str
    ! Local variables
    ! character (len=3)                       :: adv
    character (len=32)                      :: val
    logical                                 :: logval
    ! Executable
    ! adv =  Advance_is_yes_or_no ( str )
    ! AdvancedOptions%originalOptions = outputOptions
    ! Now check for changing the advanced options
    call getOption ( lowercase(str), 'save', logval, initialize=.true. )
    if ( logval ) then
      advancedOptions%originalOptions = outputOptions
    endif
    call getOption ( lowercase(str), 'restore', logval, initialize=.true. )
    if ( logval ) then
      outputOptions = advancedOptions%originalOptions
    endif
    call getOption ( lowercase(str), 'unit', val, initialize=.true. )
    if ( len_trim(val) > 0 ) read ( val, * ) outputOptions%prUnit
    call getOption ( lowercase(str), 'level', val, initialize=.true. )
    if ( len_trim(val) > 0 ) read ( val, * ) outputOptions%MLSMSG_Level
    call getOption ( lowercase(str), 'newline', val, initialize=.true. )
    if ( len_trim(val) > 0 ) read ( val, * ) outputOptions%newLineVal
    call getOption ( lowercase(str), 'wrappast', val, initialize=.true. )
    if ( len_trim(val) > 0 ) read ( val, * ) OutputOptions%WrapPastColumn
    call getOption ( lowercase(str), 'stretch', advancedOptions%stretch )
    call getOption ( lowercase(str), 'banner', advancedOptions%bannered )
    call getOption ( lowercase(str), 'header', advancedOptions%headered )
    call getOption ( lowercase(str), 'wrap', OutputOptions%AlwaysWrap )
    if ( .not. advancedOptions%pause ) &
      & call getOption ( str, 'pause', advancedOptions%pause )
    ! print *, 'pause: ', advancedOptions%pause
    if ( DeeBug ) print *, 'WrapPastColumn: ', OutputOptions%WrapPastColumn
    if ( DeeBug ) print *, 'AlwaysWrap: ', OutputOptions%AlwaysWrap
  end subroutine SetAdvancedOption

  ! ---------------------------------------------- setOutputStatus
  ! Sets certain normally private data
  ! Sets for modules like highOutput and maybe some others
  ! Effect will be an integer
  ! equal to value if integer-valued data
  ! or to TRUE if value is 1
  subroutine SetOutputStatus( name, value )
    ! Args
    character(len=*), intent(in) :: name
    integer, intent(in)          :: value
    ! Executable
    if ( index(lowercase(name), 'physicalcolumn' ) > 0 ) then
      atColumnNumber = value           ! This is the "physical" column
    elseif( index(lowercase(name), 'indent' ) > 0 ) then
      indentBy = value
    elseif( index(lowercase(name), 'start' ) > 0 ) then
      atLineStart = ( value == 1 )
    elseif( index(lowercase(name), 'lines' ) > 0 ) then
      linesSincelastStamp = value
    elseif( index(lowercase(name), 'silent' ) > 0 ) then
      silentRunning = ( value == 1 )
    elseif( index(lowercase(name), 'wrappast' ) > 0 ) then
      OutputOptions%WrapPastColumn = value
    elseif( index(lowercase(name), 'wrap' ) > 0 ) then
      OutputOptions%AlwaysWrap = ( value == 1 )
    endif
  end subroutine SetOutputStatus

  ! ----------------------------------------------  setTruthPattern  -----
  subroutine SetTruthPattern ( TrueFalse )
  ! Override and set a special Truth pattern that can be used in calls to
  ! output logical-valued scalars and arrays e.g., 
  !  call output( logs, ..)
    character(len=2), dimension(2), intent(in) :: TrueFalse ! (/ 'T ', 'F ' /)
    TruthValues = TrueFalse
  end subroutine SetTruthPattern

  ! ----------------------------------------------  suspendOutput  -----
  subroutine SuspendOutput 
  ! suspend outputting to PRUNIT. Run silent.
  ! Reversible by calling resumeOutput
    silentRunning = .true.
  end subroutine SuspendOutput

  ! ----------------------------------------------  switchOutput  -----
  subroutine SwitchOutput ( filename, unit, keepOldUnitOpen )
  ! stop outputting to PRUNIT. Switch to filename [using unit if supplied]
  ! Special use: if filename == 'stdout', just temporarily print to stdout
    ! Args
    character(len=*), intent(in)    :: filename
    integer, optional, intent(in)   :: unit
    logical, optional, intent(in)   :: keepOldUnitOpen
    ! Internal variables
    integer, parameter :: DEFAULTSWITCHUNIT = 59
    logical :: dontCloseOldUnit
    logical, save :: NeedToAppend = .false. ! 1st time here overwrite; append later
    integer :: switchUnit
    ! Executable
    ! Check for filename == 'stdout'
    if ( lowercase(filename) == 'stdout' ) then
      SWITCHTOSTDOUT = .true.
      return
    endif
    dontCloseOldUnit = .false.
    if ( present(keepOldUnitOpen) ) dontCloseOldUnit = keepOldUnitOpen
    oldUnit = outputOptions%prunit
    switchUnit = DEFAULTSWITCHUNIT
    call resumeOutput
    if ( present(unit) ) then
      call output_('Switching further output to: ', advance='no')
      call output_(trim(filename), advance='yes')
      call output_('using unit number: ', advance='no')
      call output(unit, advance='yes')
      switchUnit = unit
    else
      call output_('Switching further output to: ', advance='no')
      call output_(trim(filename), advance='yes')
      ! if ( PRUNIT > 0 ) switchUnit = PRUNIT
    end if
    if ( outputOptions%prunit > 0 .and. .not. dontCloseOldUnit ) then
      close(outputOptions%prunit)
      OLDUNIT = outputOptions%prunit
      OLDUNITSTILLOPEN = .false.
    end if
    if ( NeedToAppend ) then
      open( unit=switchUnit, file=filename, status='old', position='append' )
    else
      open( unit=switchUnit, file=filename, status='replace' )
    end if
    outputOptions%prunit = SwitchUnit
    NeedToAppend = .true.
  end subroutine SwitchOutput

  ! ------------------ Private procedures -------------------------
  ! ----------------- Dump_AdvancedOptions
  subroutine Dump_AdvancedOptions
    write (*,*) 'stretch             =  ', advancedOptions%stretch  
    write (*,*) 'bannered            =  ', advancedOptions%bannered 
    write (*,*) 'headered            =  ', advancedOptions%headered 
    ! write (*,*) '                       ', advancedOptions
  end subroutine Dump_AdvancedOptions
  
  ! .............................................  getOption  .....
  ! This family of subroutines parses a multipart advance arg into
  ! its components, returning an appropriate value
  ! Example, say the component is marked by the '-S' flag
  ! value type     component   returned value
  !  logical          -S         true
  ! character       -Sxyz        xyz
  !
  ! You may optionally insert a space between S and its value, e.g.
  !                 "-S xyz" also returns "xyz"
  subroutine getOption_char ( arg, flag, val, initialize )
    ! Args
    character(len=*), intent(in)      :: arg
    character(len=*), intent(in)      :: flag
    character(len=*), intent(inout)   :: val
    logical, optional, intent(in)     :: initialize
    ! Local variables
    integer :: kFlag, kNext, flagLen
    ! Executable
    if ( present(initialize) ) val = ' '
    kFlag = index( arg, trim(flag) )
    ! DeeBug = ( index(lowercase(arg), 'wrappast' ) > 0 )
    if ( DeeBug ) print *, 'arg: ', trim(arg)
    if ( DeeBug ) print *, 'flag: ', trim(flag)
    if ( DeeBug ) print *, 'kFlag: ', kFlag
    if ( kFlag < 1 ) return
    val = ' '
    flagLen = len(flag)
    if ( DeeBug ) print *, 'flagLen: ', flagLen
    ! Find start of next component
    kNext = index( arg(kFlag+flagLen+1:), ' ' )
    if ( kNext < 1 ) then
      val = arg(kFlag+flagLen+1:)
    else
      val = arg(kFlag+flagLen+1:kFlag+flagLen+kNext)
    endif
    if ( index(arg, 'wrappast' ) < 1 ) return
    if ( DeeBug ) print *, trim(arg), kflag, flagLen, kNext
    if ( DeeBug ) print *, trim(flag)
    if ( DeeBug ) print *, trim(val)
    if ( DeeBug ) print *, 'Returning'
  end subroutine getOption_char

  subroutine getOption_log ( arg, flag, val, initialize )
    ! Args
    character(len=*), intent(in)      :: arg  
    character(len=*), intent(in)      :: flag 
    logical, intent(inout)            :: val  
    logical, optional, intent(in)     :: initialize
    ! Local variables
    integer :: kFlag
    ! Executable
    if ( present(initialize) ) val = .false.
    kFlag = index( arg, trim(flag) )
    if ( kFlag > 0 ) val = .true.
  end subroutine getOption_log

  ! ------------------------------------  SeparateElements  -----
  ! insert blanks or separator between consecutive elements while outputting
  subroutine SeparateElements (i, n )
    ! Args
    integer, intent(in) :: i ! Element number
    integer, intent(in) :: n ! Number of elements
    ! Executable
    if ( i >= n ) return
    if ( OutputOptions%WrapPastColumn > 0 .and. AtColumnNumber >= OutputOptions%WrapPastColumn ) then
      call newLine
      return
    endif
    if ( OutputOptions%WrapPastColumn == 0 .and. &
      & mod(i, outputOptions%nArrayElmntsPerLine) == 0 ) then
      call output_ ( '', advance='yes', DONT_STAMP=.true. )
      return
    endif
    if ( len_trim(outputOptions%arrayElmntSeparator) > 0 ) then
      call output_( outputOptions%arrayElmntSeparator, advance='no' )
    else
      call blanks ( outputOptions%nBlanksBtwnElmnts, advance='no' )
    endif
  end subroutine SeparateElements

  ! ------------------------------------  myMessage  -----
  subroutine myMessage ( Severity, ModuleNameIn, Message, &
    & Advance, newLineCode )

    ! Print a message (unless printing is suppressed).  If it has %[Nn]
    ! in it, replace that with newline.

    ! We use defaultNewLineCode instead of '%n' because there were some
    ! circumstances where we actally printed '%n'; e.g., 
    ! 'hGrid%noProfsUpperOverlap'

    ! Dummy arguments
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text
    character (len=*), intent(in), optional :: Advance ! Do not advance
    character (len=*), intent(in), optional :: newLineCode ! Instead of %n
    !                                 if present and the first character is 'N'
    !                                 or 'n'

    ! Local variables
    logical :: AllOfIt                  ! Print all of it (no %n or %N remains)
    integer :: L1, L2                   ! How far in the line have we printed?
    character (len=512), save :: Line   ! Line to output, should be long enough
    integer, save :: Line_len=0         ! Number of saved characters in line.
    integer :: LogFileUnit
    logical :: My_adv
    character(len=2) :: myNewLineCode

    ! Executable code
    my_adv = .true.
    if ( present(advance) ) &
      & my_adv = advance(1:1) /= 'n' .and. advance(1:1) /= 'N'
    myNewLineCode = defaultNewLineCode
    if ( present(newLineCode) ) myNewLineCode = newLineCode

    my_adv = my_adv .and. ( severity >= MLSMessageConfig%skipMessageThr )
    if ( (.not. MLSMessageConfig%suppressDebugs).OR. &
         & (severity /= MLSMSG_Debug) ) then
      l1 = 0
      do
        l2 = index( Message(l1+1:),myNewLineCode )
        if ( l2 == 0 ) l2 = index( Message(l1+1:),myNewLineCode )
        allOfIt = l2 == 0
        l2 = l2 + l1 - 1 ! Last character before %n or %N, if any
        if ( allOfIt ) l2 = len(Message) ! no %n or %N
        call assembleFullLine( Severity, ModuleNameIn, Message(l1+1:l2), &
          & line, line_len )
        l1 = l2 + 2 ! "n" or "N" of %n or %N
         ! Log the message using the toolkit routine
         ! (or its substitute )
         ! if either using toolkit or severity is sufficient to
         ! quit (which means we might have been called directly
         ! rather than from output module )

        if ( my_adv .or. .not. allOfIt ) then
          call PrintItOut( line, severity, line_len, &
            & alreadyLogged=alreadyLogged )
          line_len = 0
          line = ' '
        end if
        if ( allOfIt ) exit
      end do

    end if

    ! Now if it's an error, and the message is complete, then try to close
    ! log file if any and quit (or crash)

    if ( my_adv .and. severity >= MLSMSG_Severity_to_quit ) then
      call get_config ( logFileUnit = logFileUnit )
      if ( logFileUnit > 0 ) close ( logFileUnit  )
      if ( severity >= MLSMSG_Crash .or. MLSMessageConfig%CrashOnAnyError ) then
        NEVERCRASH = .false.
        call crash_burn
      endif
      call exit_with_status ( 1  )
    end if
    if ( MustRestoreAdvOpts ) then
      AdvancedOptions = DefaultAdvancedOptions
      MustRestoreAdvOpts = .false.
    endif
  end subroutine myMessage

  ! -----------------------------------------------------  Pr_Blanks  -----
  subroutine Pr_Blanks ( N_BLANKS, FILLCHAR, ADVANCE, DONT_STAMP )
  ! Output N_BLANKS blanks to PRUNIT.
  ! (or optionally that many copies of fillChar)
    integer, intent(in) :: N_BLANKS
    character(len=*), intent(in), optional :: Advance
    character(len=*), intent(in), optional :: FILLCHAR  ! default is ' '
    logical, intent(in), optional          :: DONT_STAMP ! Prevent double-stamping
    character(len=3) :: ADV
    character(len=*), parameter :: BLANKSPACE = &
    '                                                                    '
    character(len=len(BlankSpace)) :: b
    integer :: I    ! Blanks to write in next WRITE statement
    integer :: N    ! Blanks remaining to write
    character(len=4) :: MY_ADV
    ! Executable
    my_adv = Advance_is_yes_or_no(advance)
    if ( n_blanks < 1 ) then
      if ( my_adv == 'yes' ) &
        & call output_ ( '', advance='yes', dont_stamp=dont_stamp )
      return
    end if
    n = max(n_blanks, 1)
    if ( present(fillChar)  ) then
      do i=1, min(n, len(BlankSpace))
        b(i:i) = fillChar
      end do
    else
      b = BLANKSPACE
    end if
    adv = 'no'
    do
      i = min(n,len(b))
      n = n - i
      if ( n == 0 ) adv = my_adv
      call output_ ( b(:i), advance=adv )
      if ( n < 1 ) exit   ! was if n == 0, but this should be safer
    end do
    if ( MustRestoreAdvOpts ) then
      AdvancedOptions = DefaultAdvancedOptions
      MustRestoreAdvOpts = .false.
    endif
  end subroutine Pr_Blanks

  ! ..............................................  not_used_here  .....
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: output_m.f90,v 2.146 2019/08/01 23:42:33 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Output_M

! $Log: output_m.f90,v $
! Revision 2.146  2019/08/01 23:42:33  pwagner
! Added SetAdvancedOption, new components to OutputOptions, numerous other changes
!
! Revision 2.145  2019/07/22 22:12:43  pwagner
! Can now setTruthPattern to something other than T and F
!
! Revision 2.144  2019/07/17 20:16:47  pwagner
! Light housekeping
!
! Revision 2.143  2019/04/09 20:30:40  pwagner
! Moved some procedures from MLSStrings to new MLSStrings_0
!
! Revision 2.142  2019/03/18 22:05:12  pwagner
! Dont print again if alreadylogged
!
! Revision 2.141  2019/01/24 18:38:05  pwagner
! Reorganized modules that print to simplify toolkit-free builds
!
! Revision 2.140  2018/10/25 23:25:20  pwagner
! Uses Pause from Io_Stuff
!
! Revision 2.139  2018/10/17 23:03:10  pwagner
! advance=.. can be used to make program pause, e.g. for debugging
!
! Revision 2.138  2018/09/13 20:18:20  pwagner
! Now gets PrUnits from similarly-named units of PrintIt_m; PrUnitname, too
!
! Revision 2.137  2018/05/11 20:33:05  pwagner
! make MAXOUTPUTLINESLEN public
!
! Revision 2.136  2018/04/05 16:55:05  pwagner
! Corrected comments; hopefully made them clearer, too
!
! Revision 2.135  2017/12/22 00:23:23  pwagner
! Move some items from output to new patternOptions; add flushOutputLines
!
! Revision 2.134  2017/11/30 20:50:13  pwagner
! RestoreSettings may now restore all or just some
!
! Revision 2.133  2017/11/15 00:00:17  pwagner
! Avoid adding unwanted blank lines when stamping
!
! Revision 2.132  2017/10/03 21:42:54  pwagner
! Added printOutputStatus; improved comments showing patterns
!
! Revision 2.131  2017/09/29 00:19:01  pwagner
! Added setOutputStatus
!
! Revision 2.130  2017/09/07 20:58:29  pwagner
! Added printOutputStatus
!
! Revision 2.129  2017/07/31 23:01:22  pwagner
! NewLine can be asked not to make a blank line
!
! Revision 2.128  2017/01/25 17:13:44  pwagner
! Output logicals so they line up with integers
!
! Revision 2.127  2016/10/18 17:46:28  pwagner
! Added advancedOptions; may insert extra args in advance='..'
!
! Revision 2.126  2016/09/22 22:51:48  pwagner
! optional format arg now in generic output api
!
! Revision 2.125  2015/09/24 18:52:28  pwagner
! Expanded special Fill patterns; allow user to set own special pattern '0'
!
! Revision 2.124  2015/08/26 23:25:11  pwagner
! Added Beep and advance='stderr' to print to stderr
!
! Revision 2.123  2015/08/25 18:36:56  vsnyder
! Add a FLUSH statement to FlushOutputLines
!
! Revision 2.122  2015/07/14 23:26:54  pwagner
! New advance_after_each arg to output of char arry; note that Reverting output now appears in old unit, e.g. stdout
!
! Revision 2.121  2015/05/18 17:40:03  pwagner
! Made Advance_is_yes_or_no public; reordered where to print
!
! Revision 2.120  2015/03/06 21:37:42  pwagner
! "%n" in output string could trigger unintended new line; fixed
!
! Revision 2.119  2015/02/13 00:16:24  pwagner
! Reordered tests in Output_Char_NoCR_INDENTED more understandably, we hope
!
! Revision 2.118  2015/02/10 00:59:36  pwagner
! Repaired error introduced by last change
!
! Revision 2.117  2015/02/06 00:45:54  pwagner
! Can now print to virtual page indented w.r.t. physical page
!
! Revision 2.116  2015/01/12 22:20:55  pwagner
! swichOutput can switch to 'stdout'
!
! Revision 2.115  2014/09/05 00:28:05  vsnyder
! Better handling of literal output unit
!
! Revision 2.114  2014/08/06 19:26:49  pwagner
! Bugfixes plus one workaround for an ifort v13 bug
!
! Revision 2.113  2014/08/05 18:23:24  pwagner
! prUnitLiteral field lets prUnit go negative
!
! Revision 2.112  2014/07/21 20:56:47  pwagner
! Should not bomb so easily
!
! Revision 2.111  2014/01/11 01:41:02  vsnyder
! Decruftification
!
! Revision 2.110  2014/01/09 00:22:18  pwagner
! Split output module procedures between it and new highOutput
!
! Revision 2.109  2013/11/21 21:21:41  pwagner
! Wrap lines at the right-hand border when outputting named arrays with borders
!
! Revision 2.108  2013/11/04 22:53:51  pwagner
! Added beVerbose, letsDebug
!
! Revision 2.107  2013/09/12 01:56:50  vsnyder
! Change f6.1 format to f8.1 format in DumpSize_Double
!
! Revision 2.106  2013/08/28 00:35:39  pwagner
! Moved more stuff from MLSMessage down to PrintIt module
!
! Revision 2.105  2013/08/23 02:51:04  vsnyder
! Move PrintItOut to PrintIt_m
!
! Revision 2.104  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.103  2013/07/18 22:34:31  pwagner
! Avoid double-printing when prUnit > 0
!
! Revision 2.102  2013/07/13 00:01:09  vsnyder
! Remove old comments about how unbuffering was done
!
! Revision 2.101  2013/06/28 17:53:44  pwagner
! logParent, parentName added to show who called output module
!
! Revision 2.100  2013/06/14 01:26:11  vsnyder
! Use FLUSH to unbuffer output
!
! Revision 2.99  2013/04/17 00:03:44  pwagner
! Removed LINE_WIDTH; comments note possible solution to unwieldy module
!
! Revision 2.98  2013/02/04 21:57:06  pwagner
! Fixed bug sending invalidPRUnit output to stderr
!
! Revision 2.97  2012/09/11 18:52:26  pwagner
! Added isOutputSuspended
!
! Revision 2.96  2012/08/16 17:36:30  pwagner
! Removed more unused stuff
!
! Revision 2.95  2012/08/07 18:01:22  pwagner
! output simply prints tab character as is instead of as '@@'
!
! Revision 2.94  2012/08/02 21:09:53  pwagner
! Added RestoreSettings
!
! Revision 2.93  2012/08/01 00:08:21  pwagner
! Uses same . . pattern in option dumps
!
! Revision 2.92  2012/07/18 00:33:45  pwagner
! Fixed bug causing double printing
!
! Revision 2.91  2012/07/17 16:38:01  pwagner
! OutputLines mechanism introduced to defer printing; new HeadLine subroutine
!
! Revision 2.90  2012/06/22 00:04:02  pwagner
! May now change default advance option to 'yes'
!
! Revision 2.89  2012/04/20 01:27:14  vsnyder
! Add CPU_Seconds to Output_Date_and_Time
!
! Revision 2.88  2011/08/11 22:24:59  pwagner
! Added banner to set off message with stars and stripes
!
! Revision 2.87  2011/07/12 00:12:25  pwagner
! Added numNeedsFormat
!
! Revision 2.86  2011/05/26 20:38:32  pwagner
! By default, outputting chars substitutes for non-ascii, except for newlines
!
! Revision 2.85  2011/04/29 02:16:32  vsnyder
! Prefill dateString and timeString with blanks to compensate for Intel bug
!
! Revision 2.84  2011/03/12 00:39:31  vsnyder
! Change len=1 to len=* to avoid Intel checking problem
!
! Revision 2.83  2010/10/14 18:43:02  pwagner
! Can now dump and reset tabs; also can outputlists
!
! Revision 2.82  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.81  2010/01/26 17:49:42  pwagner
! Fixed bug that added space before newlines; simplified Output_Char
!
! Revision 2.80  2009/06/24 22:35:44  pwagner
! Trick to pass places arg into output via format arg
!
! Revision 2.79  2009/06/23 18:25:43  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.78  2009/06/16 17:22:42  pwagner
! With outputOptions may make outputted arrays look like text Climatology file
!
! Revision 2.77  2009/05/14 22:00:28  pwagner
! New optional arg onlyif prints logicals only if true (false)
!
! Revision 2.76  2008/11/24 19:29:43  pwagner
! Added a print to not_used_here
!
! Revision 2.75  2008/10/17 00:04:22  pwagner
! NewLine should not add space at line end when output to named file
!
! Revision 2.74  2008/06/17 00:01:53  pwagner
! Separate options for auto and manual time stamping
!
! Revision 2.73  2008/05/02 00:07:20  pwagner
! Correctly handles some rare cases, newLine wont add extra space
!
! Revision 2.72  2008/04/18 16:34:37  pwagner
! achar(13) among chars by default now triggers newLine
!
! Revision 2.71  2008/03/07 01:34:57  pwagner
! Added f.p. array versions of generic outputNamedValue
!
! Revision 2.70  2008/02/22 21:24:14  pwagner
! Lets NAG-built tools dump PCF, L2CF
!
! Revision 2.69  2008/01/09 20:52:03  pwagner
! call output(NaN) now prints 'NaN'; same with Inf
!
! Revision 2.68  2007/12/19 01:29:05  pwagner
! Removed unused variables
!
! Revision 2.67  2007/11/30 18:19:48  pwagner
! outputCalendar handles yyyy-mm-dd formatted date
!
! Revision 2.66  2007/10/18 23:39:46  pwagner
! Added numToChars and alignToFit intercaes for numeric types
!
! Revision 2.65  2007/09/24 20:22:08  pwagner
! Improved outputCalendar
!
! Revision 2.64  2007/09/20 17:38:09  pwagner
! improved outputCalendar; neverStamp field added to stampOptions
!
! Revision 2.63  2007/09/14 00:15:42  pwagner
! Added alignToFit and outputCalendar
!
! Revision 2.62  2007/09/06 22:27:06  pwagner
! Renamed TAB to blanksToTab to avoid conflict with TOGGLES constant
!
! Revision 2.61  2007/08/27 23:55:01  pwagner
! Added many tabstop-related procedures
!
! Revision 2.60  2007/07/27 00:21:59  vsnyder
! Spiff up printing in DumpSize
!
! Revision 2.59  2007/07/17 00:24:18  pwagner
! Treat certain numbers with default list-directed format
!
! Revision 2.58  2007/06/14 18:40:04  pwagner
! Allow sdFormatDefault to be set at class level
!
! Revision 2.57  2007/04/14 00:37:16  vsnyder
! Correction dumpSize to avoid asterisks in I6 output
!
! Revision 2.56  2007/03/23 00:08:21  pwagner
! Guard against negative args confusing dumpSize
!
! Revision 2.55  2007/01/13 01:49:48  pwagner
! Repaired long-standing bug blighting logged output
!
! Revision 2.54  2007/01/12 00:31:00  pwagner
! May use unbuffered output ;renamed routine outputNamedValue
!
! Revision 2.53  2006/07/28 01:58:53  vsnyder
! Cannonball polishing in dumpSize routines
!
! Revision 2.52  2006/07/19 22:25:14  vsnyder
! Add Dumpsize_Double, plus some cannonball polishing
!
! Revision 2.51  2006/06/27 23:58:01  pwagner
! name_v_value works much better
!
! Revision 2.50  2006/06/24 23:05:07  pwagner
! Added outputNamedValue, special blank fills
!
! Revision 2.49  2006/06/03 00:17:29  vsnyder
! Eliminate trailing blanks sometimes
!
! Revision 2.48  2006/02/21 19:08:36  pwagner
! Removed two unused declarations
!
! Revision 2.47  2006/02/15 18:10:44  pwagner
! Fixed bug preventing CR from being printed sometimes
!
! Revision 2.46  2006/02/15 00:00:07  pwagner
! Added automatic stamping features
!
! Revision 2.45  2006/02/10 21:23:05  pwagner
! Added switchOutput, revertOutput
!
! Revision 2.44  2006/01/04 20:28:51  pwagner
! Added suspend- and resumeOutput procedures
!
! Revision 2.43  2005/12/16 23:25:13  pwagner
! dumpSize moved from dump0 to output_m
!
! Revision 2.42  2005/09/22 23:34:56  pwagner
! date conversion procedures and functions all moved into dates module
!
! Revision 2.41  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.40  2005/03/19 01:14:41  pwagner
! Fixed error in formatting output_date_and_time
!
! Revision 2.39  2005/01/20 23:17:51  pwagner
! Prevent n_char being gt len(my_chars)
!
! Revision 2.38  2005/01/19 01:09:49  pwagner
! New timeStamp interface to certain output procedures
!
! Revision 2.37  2005/01/07 01:26:04  pwagner
! Advance now an optional arg to OUTPUT_DATE_AND_TIME so it can time-stamp
!
! Revision 2.36  2004/12/31 02:39:51  vsnyder
! Simplified computing My_Adv, simplified Output_Char, added Before argument
! to Output_Logical, some cannonball-polishing.
!
! Revision 2.35  2004/12/28 19:29:57  pwagner
! Changes to handle formats like f0.3, en10.2, es8.2
!
! Revision 2.34  2004/12/14 00:00:50  pwagner
! Optional arg insteadofblank added to char outputs
!
! Revision 2.33  2004/12/13 20:30:19  vsnyder
! Cosmetic cannonball polishing
!
! Revision 2.32  2004/09/23 22:57:36  pwagner
! Added output_date_and_time
!
! Revision 2.31  2004/08/04 23:19:02  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.30  2004/06/10 23:59:29  pwagner
! blanks may take optional fillchar
!
! Revision 2.29  2004/02/26 21:51:15  pwagner
! Added output_string--although it is almost useless
!
! Revision 2.28  2003/10/07 01:12:59  vsnyder
! Add NewLine subroutine, and Before and After text args
!
! Revision 2.27  2003/09/15 23:08:44  vsnyder
! Remove five unused local variables
!
! Revision 2.26  2003/09/08 17:43:25  pwagner
! Fixed bug in nCharsinFormat when no 'x' in Format
!
! Revision 2.25  2003/09/06 01:35:55  pwagner
! Can account for (nx,{defg}m.b} in f.p. format
!
! Revision 2.24  2003/08/25 17:48:37  pwagner
! Remembered formats may be gx.y
!
! Revision 2.23  2003/08/25 17:06:50  pwagner
! Remembered that formats may use ex.y as well as [fd]x.y
!
! Revision 2.22  2003/08/23 00:11:46  pwagner
! Tried to fix prob with fix to output_single; also output_double
!
! Revision 2.21  2003/08/21 21:20:35  cvuu
! Change output of format in OUTPUT_SINGLE
!
! Revision 2.20  2003/07/02 01:07:27  vsnyder
! Add complex output
!
! Revision 2.19  2003/03/20 19:20:17  pwagner
! Changes to prevent double-logging when using MLSMessage
!
! Revision 2.18  2003/02/27 18:35:30  pwagner
! Appends trailing spaces to improve appearance with MLSMessage
!
! Revision 2.17  2002/10/08 00:09:13  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.16  2001/10/19 22:31:36  pwagner
! Now can output (small-sized) s.p., d.p. arrays
!
! Revision 2.15  2001/10/08 23:43:28  pwagner
! Allows wider range of advance(s); my_adv implemented uniforml
!
! Revision 2.14  2001/09/26 02:16:22  vsnyder
! Simplify by using Output_Char internally
!
! Revision 2.13  2001/05/24 22:39:07  vsnyder
! Make output_single work like output_double; cosmetic changes
!
! Revision 2.12  2001/05/24 22:22:48  vsnyder
! Add Output_Single to the generic Output interface
!
! Revision 2.11  2001/05/10 22:52:03  vsnyder
! Increase maximum integer width
!
! Revision 2.10  2001/05/10 18:22:00  pwagner
! Added LogFOrmat to output_double
!
! Revision 2.9  2001/05/08 20:27:24  vsnyder
! Added an optional 'format' argument in a few more places
!
! Revision 2.8  2001/04/25 00:08:01  vsnyder
! Add 'fill' argument to 'output_integer'
!
! Revision 2.7  2001/04/18 23:28:10  pwagner
! Added output_integer_array
!
! Revision 2.6  2001/04/07 01:53:28  vsnyder
! Output 0 instead 0.0e+00
!
! Revision 2.5  2001/03/16 23:14:16  vsnyder
! Don't trim off the last nonzero digit
!
! Revision 2.4  2001/02/28 21:35:34  livesey
! Added output logical
!
! Revision 2.3  2001/02/22 23:54:27  vsnyder
! Added optional "from_where" argument to "Output_Char"
!
! Revision 2.2  2001/02/22 23:27:16  vsnyder
! Correct routing of output through MLSMessage
!
! Revision 2.1  2000/10/11 18:33:24  vsnyder
! Move from lib/cf_parser to lib; insert copyright notice
!
! Revision 2.2  2000/10/09 23:29:54  vsnyder
! Must have updated something -- permissions weren't r--r--r--.
!
! Revision 2.1  2000/10/04 18:07:04  vsnyder
! Added capability to output through MLSMessage
!
! Revision 2.0  2000/09/05 17:41:50  dcuddy
! Change revision to 2.0
!
! Revision 1.1  2000/07/06 01:43:12  vsnyder
! Initial check-in
!
@


2.146
log
@Added SetAdvancedOption, new components to OutputOptions, numerous other changes
@
text
@d1179 1
a1179 1
    & Before, After, dont_stamp )
d1188 2
d1369 1
a1369 1
    & Before, After, DONT_STAMP )
d1378 2
d1880 1
a1880 1
       "$Id: output_m.f90,v 2.145 2019/07/22 22:12:43 pwagner Exp $"
d1890 3
@


2.145
log
@Can now setTruthPattern to something other than T and F
@
text
@d100 1
d107 1
a107 1
! char* Advance_is_yes_or_no ( [char* chars] )
d133 1
d176 1
a176 1
    & SetFillPattern, SetOutputStatus, SetTruthPattern, &
d192 6
a197 6
    module procedure output_char, output_char_array, output_complex
    module procedure output_dcomplex, output_double
    module procedure output_integer, output_integer_array
    module procedure output_logical, output_logical_array
    module procedure output_single, output_double_array, output_single_array
    module procedure output_string
d213 1
a213 1
  ! The default values are chosen well; override them at your own risk!
d220 2
d290 1
d329 1
d332 2
a333 1
  logical :: alreadyLogged ! Would we ned to print again?
d344 2
a345 1
  integer, save, private :: WRAPPASTCOLNUM = 0  ! Don't print beyond (if > 0)
d372 7
d400 1
a400 1
    ! All the other patterns require a longer explanation:
d416 1
d422 4
a439 2
    character (len=32)           :: val
    logical                      :: logval
d443 3
d465 3
d470 4
a473 23
    
    ! AdvancedOptions%originalOptions = outputOptions
    ! Now check for changing the advanced options
    call getOption ( str, 'save', logval )
    if ( logval ) then
      advancedOptions%originalOptions = outputOptions
    endif
    call getOption ( str, 'restore', logval )
    if ( logval ) then
      outputOptions = advancedOptions%originalOptions
    endif
    call getOption ( str, 'unit', val )
    if ( len_trim(val) > 0 ) read ( val, * ) outputOptions%prUnit
    call getOption ( str, 'level', val )
    if ( len_trim(val) > 0 ) read ( val, * ) outputOptions%MLSMSG_Level
    call getOption ( str, 'newline', val )
    if ( len_trim(val) > 0 ) read ( val, * ) outputOptions%newLineVal
    call getOption ( str, 'stretch', advancedOptions%stretch )
    call getOption ( str, 'banner', advancedOptions%bannered )
    call getOption ( str, 'header', advancedOptions%headered )
    if ( .not. advancedOptions%pause ) &
      & call getOption ( str, 'pause', advancedOptions%pause )
    ! print *, 'pause: ', advancedOptions%pause
d520 1
a520 1
          call pr_blanks ( n_blanks, advance=advance, dont_stamp=dont_stamp )
d533 1
a533 1
            call pr_blanks ( 1, advance='no' )
d537 1
a537 1
          call pr_blanks ( 1, advance='no' )
d542 1
a542 1
          ! if ( xtraBlanks > 0 ) call pr_blanks ( xtraBlanks, advance='no' )
d546 1
a546 1
        if ( theRest > 0 ) call pr_blanks ( theRest, advance=advance, dont_stamp=dont_stamp )
d550 1
a550 1
    call pr_blanks ( n_blanks, fillChar=fillChar, advance=advance, dont_stamp=dont_stamp )
d577 3
a579 3
  ! ----------------------------------------------  Output_Unit  -----
  ! Flush Output_Unit
  subroutine flushStdout
d583 1
a583 1
  end subroutine flushStdout
d611 4
d680 1
d687 1
a687 1
  ! ------------------------------------------------  OUTPUT_CHAR  -----
d689 1
a689 1
  subroutine Output_char ( Chars, &
d691 1
a691 1
    & newlineval, dont_asciify, format )
d698 3
d715 1
a715 1
    integer :: LineLen ! How many chars tto print
a731 1
    i = index( chars, achar(myNewLineVal) )
d755 2
d758 1
d768 2
d795 4
d836 4
d845 2
a846 2
    ! We have arrived
    ! The workhorse
d858 5
d897 4
d1077 4
d1104 2
a1105 2
  ! ------------------------------------------  OUTPUT_CHAR_ARRAY  -----
  subroutine OUTPUT_CHAR_ARRAY ( CHARS, ADVANCE_AFTER_EACH, ADVANCE, &
d1109 5
a1113 5
    character(len=*), intent(in), optional :: ADVANCE_AFTER_EACH
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: INSTEADOFBLANK ! What to output
    integer, intent(in), optional :: NEWLINEVAL ! What char val to treat as <cr>
    character(len=*), intent(in), optional :: format ! consistent with generic
d1127 1
a1127 1
  end subroutine OUTPUT_CHAR_ARRAY
d1130 1
a1130 1
  subroutine OUTPUT_COMPLEX ( VALUE, Format, ADVANCE, Before, After, dont_stamp )
d1133 1
a1133 1
    character(len=*), intent(in), optional :: ADVANCE
d1135 1
a1135 1
    logical, intent(in), optional :: DONT_STAMP
d1155 1
a1155 1
  subroutine OUTPUT_DCOMPLEX ( VALUE, Format, ADVANCE, Before, After )
d1159 1
a1159 1
    character(len=*), intent(in), optional :: ADVANCE
d1178 1
a1178 1
  subroutine OUTPUT_DOUBLE ( VALUE, Format, LogFormat, ADVANCE, &
d1185 1
a1185 1
    character(len=*), intent(in), optional :: ADVANCE
d1187 1
a1187 1
    logical, intent(in), optional :: DONT_STAMP
d1215 1
a1215 1
    character(len=*), intent(in), optional :: ADVANCE
d1242 1
a1242 1
    character(len=*), intent(in), optional :: ADVANCE
d1246 1
a1246 1
    logical, intent(in), optional :: DONT_STAMP
d1294 1
a1294 1
    character(len=*), intent(in), optional :: ADVANCE
d1308 1
a1308 1
  subroutine OUTPUT_LOGICAL ( LOG, ADVANCE, BEFORE, DONT_STAMP, format )
d1311 1
a1311 1
    character(len=*), intent(in), optional :: ADVANCE
d1327 1
a1327 1
    & ADVANCE, BEFORE, DONT_STAMP, ONLYIF, format )
d1331 1
a1331 1
    character(len=*), intent(in), optional :: ADVANCE
d1373 1
a1373 1
    character(len=*), intent(in), optional :: ADVANCE
d1402 1
a1402 1
    character(len=*), intent(in), optional :: ADVANCE
d1421 1
a1421 1
    character(len=*), intent(in), optional :: ADVANCE
d1518 42
a1559 8
  ! ----------------------------------------------  setTruthPattern  -----
  subroutine SetTruthPattern ( TrueFalse )
  ! Override and set a special Truth pattern that can be used in calls to
  ! output logical-valued scalars and arrays e.g., 
  !  call output( logs, ..)
    character(len=2), dimension(2), intent(in) :: TrueFalse ! (/ 'T ', 'F ' /)
    TruthValues = TrueFalse
  end subroutine SetTruthPattern
d1562 1
a1562 1
  ! Returns certain normally private data
d1582 4
d1589 9
d1673 1
a1673 1
  subroutine getOption_char ( arg, flag, val )
d1675 4
a1678 3
    character(len=*), intent(in)  :: arg
    character(len=*), intent(in)  :: flag
    character(len=*), intent(out) :: val
d1682 1
a1682 1
    val = ' '
d1684 4
d1689 1
d1691 1
d1693 1
a1693 1
    kNext = index( arg(kFlag+flagLen:), ' ' )
d1695 1
a1695 1
      val = arg(kFlag+flagLen:)
d1697 1
a1697 1
      val = arg(kFlag+flagLen:kFlag+flagLen+kNext)
d1699 5
d1706 1
a1706 1
  subroutine getOption_log ( arg, flag, val )
d1708 4
a1711 3
    character(len=*), intent(in) :: arg
    character(len=*), intent(in) :: flag
    logical, intent(out)         :: val
d1715 1
d1717 1
a1717 1
    val = ( kFlag > 0 )
d1728 1
a1728 1
    if ( wrappastcolnum > 0 .and. atcolumnnumber >= wrappastcolnum ) then
d1732 1
a1732 1
    if ( wrappastcolnum == 0 .and. &
d1822 4
d1828 2
a1829 2
  ! -----------------------------------------------------  PR_BLANKS  -----
  subroutine PR_BLANKS ( N_BLANKS, FILLCHAR, ADVANCE, DONT_STAMP )
d1833 1
a1833 1
    character(len=*), intent(in), optional :: ADVANCE
d1866 5
a1870 1
  end subroutine PR_BLANKS
d1876 1
a1876 1
       "$Id: output_m.f90,v 2.144 2019/07/17 20:16:47 pwagner Exp $"
d1886 3
d2079 1
a2079 1
! Fixed bug that added space before newlines; simplified output_char
d2281 1
a2281 1
! Simplify by using output_char internally
d2314 1
a2314 1
! Added optional "from_where" argument to "output_char"
@


2.144
log
@Light housekeping
@
text
@d98 1
d111 1
a111 1
! int getOutputStatus( char* name )
d131 1
d174 2
a175 1
    & SetFillPattern, SetOutputStatus, SuspendOutput, SwitchOutput
d346 5
a350 1

d580 1
a580 1
  ! ---------------------------------------------- getOutputStatus
d586 1
a586 1
  function getOutputStatus( name ) result( status )
d588 3
a590 2
    character(len=*), intent(in) :: name
    integer :: status
d592 2
d606 6
d613 1
a613 1
  end function getOutputStatus
a1277 4
    character(len=2), dimension(2), parameter :: TruthValues = &
      & (/ 'T ', 'F ' /)
    integer, parameter :: true  = 1 ! Index in TruthValues
    integer, parameter :: false = 2
d1307 1
a1307 1
        ifonlyWhat = 'T'
d1309 1
a1309 1
        ifonlyWhat = 'F'
d1464 1
a1464 1
  subroutine setFillPattern ( pattern, fillChar )
d1478 10
a1487 1
  end subroutine setFillPattern
d1495 1
a1495 1
  subroutine setOutputStatus( name, value )
d1511 1
a1511 1
  end subroutine setOutputStatus
d1514 1
a1514 1
  subroutine suspendOutput 
d1518 1
a1518 1
  end subroutine suspendOutput
d1521 1
a1521 1
  subroutine switchOutput ( filename, unit, keepOldUnitOpen )
d1567 1
a1567 1
  end subroutine switchOutput
d1769 1
a1769 1
       "$Id: output_m.f90,v 2.143 2019/04/09 20:30:40 pwagner Exp $"
d1779 3
@


2.143
log
@Moved some procedures from MLSStrings to new MLSStrings_0
@
text
@d25 1
a25 1
  !   (*) direct output to stdout or elsewhere @@
d30 1
a30 1
  !   (*) store up output in a temporary buffer
d35 1
a35 1
  !   (#) Stamping may be applied automatically or at command
d50 2
a51 2
    & PrintItOut, PrUnitName => LogUnitName, &
    & MLSMessageConfig
d62 1
a62 1
!                            holds output until flushed
d78 2
d111 1
a111 1
! log isOutputSuspended ()
d169 2
a170 2
    & FlushOutputLines, FlushStdout, GetOutputStatus, Newline, &
    & Output, Output_Char_NoCR, PrintOutputStatus, PrUnitName, &
d175 4
a178 4
  public :: OutputOptions_t
  public :: PatternOptions_t
  public :: StampOptions_t
  public :: TimestampOptions_t
d186 1
a186 1
  interface OUTPUT
d196 1
a196 1
  interface OUTPUT_
d209 1
a209 1
  type outputOptions_T
d226 2
a227 1
  ! This is the type for advanced formatting options from the advance=..
d231 1
a231 1
  ! advance='.. pause ..'
d233 1
a233 1
  type advancedOptions_T
d238 1
a238 1
    type(outputOptions_T) :: originalOptions
d376 1
a376 1
    ! Returns outputoptions%advanceDefault if the argument is absent.
d378 1
a378 1
    ! All other patterns require a longer explanation:
d384 1
a384 1
    ! outputoptions%advanceDefault (just as if it were missing)
d390 1
a390 1
    ! arg2 and beyond set advancedOptions to the
d394 2
a395 2
    !     save         save original outputOptions to be restored later
    !    restore       restore original outputOptions
d440 1
a440 1
    ! advancedOptions%originalOptions = outputOptions
d476 1
a476 1
  ! -----------------------------------------------------  BLANKS  -----
d478 1
a478 1
  ! Output N_BLANKS blanks to PRUNIT.
d482 5
a486 5
    integer, intent(in) :: N_BLANKS
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: FILLCHAR  ! default is ' '
    logical, intent(in), optional          :: DONT_STAMP ! Prevent double-stamping
    integer :: I    ! Blanks to write in next WRITE statement
d498 1
a498 1
        ! We need to try to fit our called-for pattern into n_blanks
d504 2
a505 2
        ! Now we assume we'll always want the first and blanks of n_blanks to be
        ! purely blank
d539 1
a539 1
  end subroutine BLANKS
d640 2
a641 31
  ! ---------------------------------------------- PrUnitName
  ! Prints certain normally private data
  ! revealing what settings and options are in force
  function PrUnitName_old ( unit ) result ( name )
    ! Args
    integer, intent(in)     :: unit
    character(len=16)       :: name
    ! Internal variables
    ! Executable
    select case ( unit )
    case ( OutputLinesPrunit )
      name = 'lines buffer'
    case ( BothPrunit )
      name = 'stdout+log'
    case ( MsgLogPrunit )
      name = 'msg log'
    case ( StdoutPrunit )
      name = 'stdout'
    case ( InvalidPrunit )
      name = 'invalid'
    case default
      if ( unit > 0 ) then
        write ( name, '(a8, i8) ' ) 'unit', unit
      else
        name = 'illegal unit'
      endif
    end select
  end function PrUnitName_old

  ! ----------------------------------------------  isOutputSuspended  -----
  logical function isOutputSuspended ()
d643 2
a644 2
    isOutputSuspended = silentRunning
  end function isOutputSuspended
d1419 1
a1419 1
  ! Revreses effect of suspendOutput
d1748 1
a1748 1
       "$Id: output_m.f90,v 2.142 2019/03/18 22:05:12 pwagner Exp $"
d1758 3
@


2.142
log
@Dont print again if alreadylogged
@
text
@d40 1
a40 1
  use MLSStrings, only: NCharsInFormat, ReplaceNonAscii, Lowercase, &
d1774 1
a1774 1
       "$Id: output_m.f90,v 2.141 2019/01/24 18:38:05 pwagner Exp $"
d1784 3
@


2.141
log
@Reorganized modules that print to simplify toolkit-free builds
@
text
@d320 1
d853 1
a853 1
    logical :: alreadyLogged
d1706 2
a1707 1
          call printitout( line, severity, line_len )
d1774 1
a1774 1
       "$Id: output_m.f90,v 2.140 2018/10/25 23:25:20 pwagner Exp $"
d1784 3
@


2.140
log
@Uses Pause from Io_Stuff
@
text
@a36 1
  use Dates_Module, only: ReformatDate, ReformatTime
d40 1
a40 2
  use MLSStringLists, only: NCharsInFormat
  use MLSStrings, only: ReplaceNonAscii, Lowercase, &
d697 10
a706 10
    character(len=*), intent(in) :: CHARS
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: FROM_WHERE
    logical, intent(in), optional          :: DONT_LOG ! Prevent double-logging
    character(len=*), intent(in), optional :: LOG_CHARS
    character(len=*), intent(in), optional :: INSTEADOFBLANK ! What to output
    logical, intent(in), optional          :: DONT_STAMP ! Prevent double-stamping
    integer, intent(in), optional :: NEWLINEVAL ! What char val to treat as <cr>
    logical, intent(in), optional          :: DONT_ASCIIFY ! output binary
    character(len=*), intent(in), optional :: format ! consistent with generic
d791 7
a797 7
    character(len=*), intent(in) :: CHARS
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: FROM_WHERE
    logical, intent(in), optional          :: DONT_LOG ! Prevent double-logging
    character(len=*), intent(in), optional :: LOG_CHARS
    character(len=*), intent(in), optional :: INSTEADOFBLANK ! What to output
    logical, intent(in), optional          :: DONT_STAMP ! Prevent double-stamping
d843 8
a850 7
    character(len=*), intent(in) :: CHARS
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: FROM_WHERE
    logical, intent(in), optional          :: DONT_LOG ! Prevent double-logging
    character(len=*), intent(in), optional :: LOG_CHARS
    character(len=*), intent(in), optional :: INSTEADOFBLANK ! What to output
    logical, intent(in), optional          :: DONT_STAMP ! Prevent double-stamping
d930 3
a932 1
        stamped_chars = stamp(chars)
d936 3
a938 1
      stamped_chars = stamp(chars)
d1035 3
a1037 1
        stamped_chars = stamp(' ')
a1767 40
  ! ----------------------------------------------  stamp  -----
  function stamp( chars )
  ! stamp input chars before outputting to PRUNIT.
  ! Args
    character(len=*), intent(in) :: chars
    character(len=len(chars)+64) :: stamp
    character(len=16) :: dateString
    character(len=16) :: timeString
    ! Executable
    stamp = chars
    if ( stampOptions%showTime ) then
      dateString = '' ! Intel 12 and earlier doesn't fill with blanks
      timeString = '' ! Intel 12 and earlier doesn't fill with blanks
      call date_and_time ( date=dateString, time=timeString )
      dateString = reFormatDate(trim(dateString), toForm=stampOptions%dateFormat)
      timeString = reFormatTime(trim(timeString), stampOptions%timeFormat)
      if ( stampOptions%dateFormat /= ' ' ) &
      & stamp = catStrings( stamp, dateString )
      if ( stampOptions%timeFormat /= ' ' ) &
      & stamp = catStrings( stamp, timeString )
    end if
    if ( stampOptions%textCode /= ' ' ) &
        & stamp = catStrings( stamp, stampOptions%textCode )
  contains
    function catStrings(a, b) result(c)
      ! Catenates strings a and b with intervening space
      ! if post then a before b
      ! otherwise b before a
      character(len=*), intent(in) :: a
      character(len=*), intent(in) :: b
      character(len = (len(a)+len(b)+1) ) :: c
      if ( stampOptions%post ) then
        c = trim(a) // ' ' // b
      else
        c = trim(b) // ' ' // a
      end if
    end function catStrings

  end function stamp 

d1772 1
a1772 1
       "$Id: output_m.f90,v 2.139 2018/10/17 23:03:10 pwagner Exp $"
d1782 3
@


2.139
log
@advance=.. can be used to make program pause, e.g. for debugging
@
text
@d54 1
d818 2
a819 2
      print *, '(P a u s e d .. e n t e r   o k   t o   r e s u m e, p   t o   s t e p)'
      read (*,'(a)') my_adv(1:1)
d821 3
d1807 1
a1807 1
       "$Id: output_m.f90,v 2.138 2018/09/13 20:18:20 pwagner Exp $"
d1817 3
@


2.138
log
@Now gets PrUnits from similarly-named units of PrintIt_m; PrUnitname, too
@
text
@d17 19
a35 1
  ! For higher-level procedures, see highOutput
d145 1
a145 2
! (4)
! To understand the codes for dateformat and timeFormat, see the dates_module
d169 1
a169 1
    & Output, Output_Char_Nocr, PrintOutputStatus, PrUnitName, &
d196 1
a196 1
    module procedure OUTPUT_CHAR_NOCR
d226 5
d235 1
d396 1
d456 3
d689 3
a691 3
  subroutine OUTPUT_CHAR ( CHARS, &
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, DONT_STAMP, &
    & NEWLINEVAL, DONT_ASCIIFY, format )
d731 3
a733 3
      call OUTPUT_CHAR_NOCR ( '*', advance='no' )
      call OUTPUT_CHAR_NOCR ( Repeat('-', BannerLen-2 ), advance='no' )
      call OUTPUT_CHAR_NOCR ( '*', advance='yes' )
d756 2
a757 2
        call OUTPUT_CHAR_NOCR ( newChars(:LineLen), &
          & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, DONT_STAMP )
d759 2
a760 2
        call OUTPUT_CHAR_NOCR ( newChars(:LineLen), &
          & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, DONT_STAMP )
d766 4
a769 4
            call OUTPUT_CHAR_NOCR ( ReplaceNonAscii(CHARS(i:i), '@@', exceptions=achar(9)), &
              & ADVANCE='no', FROM_WHERE=FROM_WHERE, DONT_LOG=DONT_LOG, &
              & LOG_CHARS=LOG_CHARS, INSTEADOFBLANK=INSTEADOFBLANK, &
              & DONT_STAMP=DONT_STAMP )
d771 4
a774 4
            call OUTPUT_CHAR_NOCR ( CHARS(i:i), &
              & ADVANCE='no', FROM_WHERE=FROM_WHERE, DONT_LOG=DONT_LOG, &
              & LOG_CHARS=LOG_CHARS, INSTEADOFBLANK=INSTEADOFBLANK, &
              & DONT_STAMP=DONT_STAMP )
d784 3
a786 3
      call OUTPUT_CHAR_NOCR ( '*', advance='no' )
      call OUTPUT_CHAR_NOCR ( Repeat('-', BannerLen-2 ), advance='no' )
      call OUTPUT_CHAR_NOCR ( '*', advance='yes' )
d788 1
a788 1
  end subroutine OUTPUT_CHAR
d790 2
a791 2
  subroutine OUTPUT_CHAR_NOCR ( CHARS, &
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, DONT_STAMP )
d805 1
a805 1
      call output_char_nocr_indented ( repeat( ' ', indentby ) // chars, &
d808 1
a808 1
      call output_char_nocr_indented ( chars, &
d811 12
a822 1
  end subroutine OUTPUT_CHAR_NOCR
d824 2
a825 2
  subroutine OUTPUT_CHAR_NOCR_INDENTED ( CHARS, &
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, DONT_STAMP )
d1064 1
a1064 1
  end subroutine OUTPUT_CHAR_NOCR_INDENTED
d1803 1
a1803 1
       "$Id: output_m.f90,v 2.137 2018/05/11 20:33:05 pwagner Exp $"
d1813 3
d1871 1
a1871 1
! Reordered tests in OUTPUT_CHAR_NOCR_INDENTED more understandably, we hope
@


2.137
log
@make MAXOUTPUTLINESLEN public
@
text
@d12 1
a12 1
module OUTPUT_M
d16 1
a16 1
  ! See also dump_0 and printit_m
d28 7
a34 1
    & MLSMSG_Severity_To_Quit, PrintItOut, &
a66 1
! PrintOutputStatus        prints normally private data
d71 1
d134 5
a138 5
  integer, parameter, public :: INVALIDPRUNIT      = 0
  integer, parameter, public :: STDOUTPRUNIT       = INVALIDPRUNIT - 1
  integer, parameter, public :: MSGLOGPRUNIT       = STDOUTPRUNIT - 1
  integer, parameter, public :: BOTHPRUNIT         = MSGLOGPRUNIT - 1
  integer, parameter, public :: OUTPUTLINESPRUNIT  = BOTHPRUNIT - 1
d141 1
a141 1
  logical, parameter, private :: UseStdout(OUTPUTLINESPRUNIT:INVALIDPRUNIT) = &
d152 1
a152 1
    & Output, Output_Char_Nocr, PrintOutputStatus, &
d185 2
a186 2
  integer, public, parameter :: MAXOUTPUTLINESLEN = 2048 ! How many chars it can hold
  character(len=MAXOUTPUTLINESLEN), public, save     :: OUTPUTLINES = ' '
d192 1
a192 1
    integer :: prUnit = STDOUTPRUNIT    ! Unit for output (see comments above).  
d194 7
a200 7
    integer :: newLineVal          = 10 ! 13 means <cr> becomes new line; -999 means ignore
    integer :: nArrayElmntsPerLine = 7
    integer :: nBlanksBtwnElmnts   = 3
    logical :: buffered            = .true.
    logical :: logParent           = .false. ! Show who called output, not output
    logical :: prUnitLiteral       = .false. ! output to prUnit even if < 0
    logical :: skipMLSMsgLogging   = .false.
d202 4
a205 4
    character(len=3)  :: advanceDefault = 'no' ! if advance=.. missing
    character(len=12) :: sdFormatDefault = '*' ! * means default format spec
    character(len=1)  :: arrayElmntSeparator = ' '
    character(len=27) :: parentName = "$RCSfile: output_m.f90,v $"
d257 4
a260 4
  type(advancedOptions_T), public, save :: advancedOptions
  type(outputOptions_T), public, save   :: outputOptions
  type(patternOptions_T), public, save  :: patternOptions
  type(outputOptions_T), private, save  :: DefaultOutputOptions
d610 29
d796 1
a796 1
    ! (4) append to our accumulated outputLines if we are deferring output
d841 3
a843 3
    if ( outputOptions%prunit ==  OUTPUTLINESPRUNIT ) then
      ! Append to outputLines; maybe print later on
      call append_chars( outputLines, chars )
d845 2
a846 2
        &  call append_chars( outputLines, achar(outputOptions%NewLineVal) )
      ! print *, 'Appending to outputlines; now ', trim(outputLines)
d1765 1
a1765 1
       "$Id: output_m.f90,v 2.136 2018/04/05 16:55:05 pwagner Exp $"
d1772 1
a1772 1
end module OUTPUT_M
d1775 3
@


2.136
log
@Corrected comments; hopefully made them clearer, too
@
text
@d179 1
a179 1
  integer, parameter :: MAXOUTPUTLINESLEN = 2048 ! How many chars it can hold
d1730 1
a1730 1
       "$Id: output_m.f90,v 2.135 2017/12/22 00:23:23 pwagner Exp $"
d1740 3
@


2.135
log
@Move some items from output to new patternOptions; add flushOutputLines
@
text
@d15 1
a15 1

d38 1
a38 1
! outputLines              If PrUnit = OUTPUTLINESPRUNIT, 
d40 1
a40 1
! outputOptions            where to send output and how to format it
d49 3
a51 3
! skipMLSMSGLogging        whether to skip MLSMessage by default
! stampOptions             whether and how to stamp each output automatically
! timeStampOptions         how to stamp when calling timeStamp
d54 2
a55 2
! Advance_is_yes_or_no     parse advance=.. field
! addToIndent              add to the number of blanks indented; subtract if < 0
d57 12
a68 12
! blanks                   print specified number of blanks [or fill chars]
! flushOutputLines         print the current outputLines; then reset to ''
! flushStdout              flush any buffered lines to stdout
! getOutputStatus          returns normally private data
! printOutputStatus        prints normally private data
! isOutputSuspended        returns TRUE if output is suspended
! newline                  print a newline
! output                   print argument
! printOutputStatus        print normally private settings and options
! resetIndent              set indenting back to 0
! restoreSettings          restore default settings for output, stamps, tabs
! revertOutput             revert output to file used before switchOutput
d70 2
a71 2
! resumeOutput             resume suspended output
! setFillPattern           set a special Fill pattern 
d73 3
a75 3
! setOutputStatus          sets normally private data
! suspendOutput            suspend output
! switchOutput             switch output to a new named file, 
d82 3
a84 3
! blanks ( int n_blanks, [char fillChar], [char* advance] )
! flushStdout
! flushOutputLines ( [int prUnit] )
d88 1
a88 1
! output ( char* chars, [char* advance], [char* from_where], 
d91 1
a91 1
! output ( char* chars(:), [char* advance],
d93 1
a93 1
! output ( value, [char* format], [char* advance],
d100 8
a107 8
! printOutputStatus ( [char* keywords] )
! resumeOutput
! revertOutput
! restoreSettings ( [char* settings] )
! setFillPattern ( pattern, [fillChar] )
! setOutputStatus( char* name, int value )
! suspendOutput
! switchOutput ( char* filename, [int unit] )
d127 1
d134 1
d141 1
a141 1
  integer, save, private :: OLDUNIT = -1 ! Previous Unit for output.
d144 5
a148 5
  public :: addToIndent, Advance_is_yes_or_no, Beep, blanks, &
    & flushOutputLines, flushStdout, getOutputStatus, newline, &
    & output, output_char_nocr, printOutputStatus, &
    & resetIndent, restoreSettings, resumeOutput, revertOutput, &
    & setFillPattern, setOutputStatus, suspendOutput, switchOutput
d151 4
a154 4
  public :: outputOptions_t
  public :: patternOptions_t
  public :: stampOptions_t
  public :: timestampOptions_t
d367 1
a367 1
    !    stretch       s t r e t c h  charcaters before printing
d441 1
a441 1
  subroutine BLANKS ( N_BLANKS, FILLCHAR, ADVANCE, DONT_STAMP )
d529 2
a530 3
  ! ----------------------------------------------  flushOutputLines  -----
  ! print or log OutputLines
  ! then reset to ''
d612 2
d1362 1
d1437 2
a1438 1
  ! suspend outputting to PRUNIT.
d1730 1
a1730 1
       "$Id: output_m.f90,v 2.134 2017/11/30 20:50:13 pwagner Exp $"
d1740 3
@


2.134
log
@RestoreSettings may now restore all or just some
@
text
@d59 1
d83 1
d143 1
a143 1
    & flushOutputLines, getOutputStatus, newline, &
d150 1
d193 20
d231 1
a231 1
    ! Here are samples of the special patterns above
a246 13
    character(len=FileNameLen) :: name = 'stdout'
    character(len=3)  :: advanceDefault = 'no' ! if advance=.. missing
    character(len=12) :: sdFormatDefault = '*' ! * means default format spec
    character(len=1)  :: arrayElmntSeparator = ' '
    character(len=27) :: parentName = "$RCSfile: output_m.f90,v $"
  end type

  ! This is the type for advanced formatting options from the advance=..
  type advancedOptions_T
    logical :: stretch             = .false. ! p r i n t  l i k e  t h i s   ?
    logical :: bannered            = .false. ! print as a banner
    logical :: headered            = .false. ! print as a headline
    type(outputOptions_T) :: originalOptions
d251 1
d277 2
a278 2
    logical :: post = .true.      ! Put stamp at end of line?
    logical :: showDate = .false. ! Don't show date unless TRUE
d281 3
a283 3
    character(len=16) :: dateFormat = 'yyyy-mm-dd'
    character(len=16) :: timeFormat = 'hh:mm:ss'
    character(len=8) :: TIMESTAMPSTYLE = 'post' ! 'pre' or 'post'
d458 2
a459 2
      if ( outputOptions%usePatternedBlanks .and. &
        & index(outputOptions%specialFillChars, FILLCHAR) > 0 ) then
d462 2
a463 2
        patternNum = index( outputOptions%specialFillChars, FillChar )
        pattern = outputOptions%patterns(patternNum)
d477 1
a477 1
        lineup = ( outputOptions%lineupFillChars(patternNum:patternNum) == 'y' )
d527 9
d588 1
a588 1
        call output( outputOptions%specialFillChars( i:i ), advance='no' )
d590 1
a590 1
        call blanks( 64, FillChar=outputOptions%specialFillChars( i:i ) )
d1401 2
a1402 2
      & patternNum = index( outputOptions%specialFillChars, fillChar )
    outputOptions%patterns(patternNum) = pattern
d1404 1
a1404 1
      & outputOptions%patterns(patternNum) = '(' // pattern // ')'
d1725 1
a1725 1
       "$Id: output_m.f90,v 2.133 2017/11/15 00:00:17 pwagner Exp $"
d1735 3
@


2.133
log
@Avoid adding unwanted blank lines when stamping
@
text
@d101 1
a101 1
! restoreSettings ( [log useToolkit] )
d250 1
a250 1
    logical :: neverStamp = .false.  ! if true, forget about automatic stamping
d1310 1
a1310 1
  subroutine restoreSettings ( USETOOLKIT )
d1314 18
a1331 7
    logical, optional, intent(in) :: useToolkit
    outputOptions = DefaultOutputOptions

    stampOptions = DefaultStampOptions

    timeStampOptions = DefaultTimeStampOptions
    if ( .not. present(useToolkit) ) return
d1705 1
a1705 1
       "$Id: output_m.f90,v 2.132 2017/10/03 21:42:54 pwagner Exp $"
d1715 3
@


2.132
log
@Added printOutputStatus; improved comments showing patterns
@
text
@a442 1
    character(len=1) :: patternChar
d496 1
a496 1
    use, intrinsic :: ISO_Fortran_Env, only: Output_Unit
d934 1
a934 1
        if ( doIt ) then
d1694 1
a1694 1
       "$Id: output_m.f90,v 2.131 2017/09/29 00:19:01 pwagner Exp $"
d1704 3
@


2.131
log
@Added setOutputStatus
@
text
@d64 1
d69 1
a69 1
! resumeOutput             resume output
d98 1
a98 1
! printOutputStatus
d208 16
d235 1
a235 1
    logical :: headered            = .false. ! print as a header
d241 1
d258 1
a258 1
    character(len=8) :: TIMESTAMPSTYLE = 'post' ! 'pre' or 'post'
d261 2
a262 1
  type(stampOptions_T), public, save :: STAMPOPTIONS ! Could leave this private
d275 2
a276 1
  type(timeStampOptions_T), public, save :: TIMESTAMPOPTIONS ! Could leave this private
d544 3
a546 6
  ! Returns certain normally private data
  ! intended for modules like highOutput and maybe some others
  ! result will be an integer
  ! equal to the value of integer-valued data
  ! or to 1 if the logical-valued data is TRUE, 0 if FALSE
  subroutine printOutputStatus
d548 3
d558 24
d1316 5
a1320 46
    outputOptions%prunit               = stdoutprunit
    outputOptions%prunitLiteral        = .false.
    outputOptions%MLSMSG_Level         = MLSMSG_Info
    outputOptions%newLineVal           = 10 ! 13
    outputOptions%nArrayElmntsPerLine  = 7
    outputOptions%nBlanksBtwnElmnts    = 3
    outputOptions%BUFFERED             = .true.
    outputOptions%SKIPMLSMSGLOGGING    = .false.
    outputOptions%logParent            = .false.
    outputOptions%usePatternedBlanks   = .true. 
    outputOptions%specialFillChars     = '0123456789ABC'
    outputOptions%patterns             = (/ & ! on consecutive lines
                                            &  '                ' , &
                                            &  '(. )            ' , &
                                            &  '(. .)           ' , &
                                            &  '(.  .)          ' , &
                                            &  '(.   .)         ' , &
                                            &  '(.. ..)         ' , &
                                            &  '(- )            ' , &
                                            &  '(- -)           ' , &
                                            &  '(-  -)          ' , &
                                            &  '(- .. )         ' , &
                                            &  '(= )            ' , &
                                            &  '(~ )            ' , &
                                            &  '(= ~)           ' /)
                                            !   12345678901234567890
    outputOptions%name                 = 'stdout'
    outputOptions%advanceDefault       = 'no'
    outputOptions%sdFormatDefault      = '*'
    outputOptions%arrayElmntSeparator  = ' '

    stampOptions%neverStamp            = .false.
    stampOptions%post                  = .true.
    stampOptions%showTime              = .false.
    stampOptions%textCode              = ' '
    stampOptions%dateFormat            = ' '
    stampOptions%timeFormat            = 'hh:mm'
    stampOptions%interval              = 1
    stampOptions%TIMESTAMPSTYLE        = 'post'

    timeStampOptions%post              = .true.
    timeStampOptions%showDate          = .false.
    timeStampOptions%textCode          = ' '
    timeStampOptions%dateFormat        = 'yyyy-mm-dd'
    timeStampOptions%timeFormat        = 'hh:mm:ss'
    timeStampOptions%TIMESTAMPSTYLE    = 'post'
d1362 1
a1362 1
  ! Set a special Fill pattern that can be used in a call to blanks
d1695 1
a1695 1
       "$Id: output_m.f90,v 2.130 2017/09/07 20:58:29 pwagner Exp $"
d1705 3
@


2.130
log
@Added printOutputStatus
@
text
@d71 1
d102 1
d143 1
a143 1
    & setFillPattern, suspendOutput, switchOutput
d1374 24
d1692 1
a1692 1
       "$Id: output_m.f90,v 2.129 2017/07/31 23:01:22 pwagner Exp $"
d1702 3
@


2.129
log
@NewLine can be asked not to make a blank line
@
text
@d60 1
d96 1
d139 1
a139 1
    & output, output_char_nocr, &
d263 1
a263 1
  logical, save, private :: ATLINESTART = .true.  ! Whether to stamp if notpost
d521 17
d1666 1
a1666 1
       "$Id: output_m.f90,v 2.128 2017/01/25 17:13:44 pwagner Exp $"
d1676 3
@


2.128
log
@Output logicals so they line up with integers
@
text
@d82 1
a82 1
! NewLine
d526 9
a534 1
  subroutine NewLine
d1647 1
a1647 1
       "$Id: output_m.f90,v 2.127 2016/10/18 17:46:28 pwagner Exp $"
d1657 3
@


2.127
log
@Added advancedOptions; may insert extra args in advance='..'
@
text
@d19 10
a28 10
  use dates_module, only:reformatDate, reformatTime
  use machine, only: crash_burn, exit_with_status, neverCrash
  use MLSCommon, only: filenamelen, finite_signal, &
    & is_what_ieee
  use MLSStringLists, only: nCharsInFormat
  use MLSStrings, only: replaceNonAscii, lowercase, &
    & readintsfromchars, stretch, trim_safe
  use PrintIt_m, only: assemblefullline, get_config, &
    & MLSMSG_Crash, MLSMSG_Debug, MLSMSG_info, MLSMSG_Error, &
    & MLSMSG_Severity_to_quit, printItOut, &
d1110 4
d1115 1
a1115 1
      line=' T'
d1117 1
a1117 1
      line=' F'
d1124 4
a1127 2
  subroutine OUTPUT_LOGICAL_ARRAY ( logs, ADVANCE, BEFORE, DONT_STAMP, ONLYIF, format )
  ! Output LOG to PRUNIT using at most PLACES (default zero) places
d1159 2
a1160 1
    if ( present(advance) ) call output_ ( '', advance=advance, DONT_STAMP=DONT_STAMP )
d1639 1
a1639 1
       "$Id: output_m.f90,v 2.126 2016/09/22 22:51:48 pwagner Exp $"
d1649 3
@


2.126
log
@optional format arg now in generic output api
@
text
@d25 2
a26 2
    & readintsfromchars, trim_safe
  use printit_m, only: assemblefullline, get_config, &
d103 2
a104 2
! Note:
! By calling appropriate functions and procedures you can adjust aspects of
d108 1
a108 1
! Sometimes there is more than one way to accomplish the same thing
d111 4
a114 1
!
d119 1
a119 1
  ! See also Beep command, and advance='stderr'
d146 1
d161 1
a161 1
  ! Don't filter for <cr>
d210 10
a219 1
  type(outputOptions_T), public, save :: OUTPUTOPTIONS
d303 2
d307 10
a316 6
    ! leaves all other patterns unchanged, but truncated to 4
    ! characters.  Returns 'no' if the argument is absent.
    
    ! 'stderr' or just 'err' is special case--we return it as 'beep'

    ! (The following comments are either untrue or unwise, possibly both)
d318 17
a334 6
    ! composed of multiple space-separated arguments, e.g. 
    ! 'arg1 [arg2] .. [argn]'
    ! (1) the first arg1 is treated as before, basically 'yes' or 'no' or 'beep'
    ! (2) arg2 and beyond will introduce extra options to the
    ! output command, eventually simplifying it to just
    !   call output( something, [advance='arg1 [arg2] .. [argn]' )
d337 1
a337 1
    character (len=4) :: Outstr
d342 4
a345 2
    integer :: kSpace

a349 1

d351 2
a352 1
    kSpace = index( outstr, ' ' )
d358 2
d365 1
a365 1
      outstr = str
d367 22
d406 3
a408 1
  ! (or optionally that many copies of fillChar)
d489 1
a489 1
    flush ( merge ( output_Unit, outputOptions%prUnit, outputOptions%prUnit < 0 ) )
d553 4
d558 2
a559 1
    logical :: myAsciify
d561 2
d567 5
d573 23
d597 3
a599 2
      if ( myAsciify) then
        call OUTPUT_CHAR_NOCR ( ReplaceNonAscii(CHARS, '@@', exceptions=achar(9)), &
d602 1
a602 1
        call OUTPUT_CHAR_NOCR ( CHARS, &
d623 7
a629 1
      if ( Advance_is_yes_or_no(advance) == 'yes' ) call newLine
d701 1
a701 1
    my_adv = Advance_is_yes_or_no(advance)
d1394 8
d1409 3
d1632 1
a1632 1
       "$Id: output_m.f90,v 2.125 2015/09/24 18:52:28 pwagner Exp $"
d1642 3
@


2.125
log
@Expanded special Fill patterns; allow user to set own special pattern '0'
@
text
@d476 1
a476 1
    & NEWLINEVAL, DONT_ASCIIFY )
d492 1
d800 1
a800 1
    & INSTEADOFBLANK, NEWLINEVAL )
d807 1
d1002 1
a1002 1
  subroutine OUTPUT_LOGICAL ( LOG, ADVANCE, BEFORE, DONT_STAMP )
d1008 1
d1020 1
a1020 1
  subroutine OUTPUT_LOGICAL_ARRAY ( logs, ADVANCE, BEFORE, DONT_STAMP, ONLYIF )
d1027 1
d1108 1
a1108 1
  subroutine OUTPUT_STRING ( STRING, LENSTRING, ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS )
d1116 1
d1521 1
a1521 1
       "$Id: output_m.f90,v 2.124 2015/08/26 23:25:11 pwagner Exp $"
d1531 3
@


2.124
log
@Added Beep and advance='stderr' to print to stderr
@
text
@d68 2
d98 1
d136 1
a136 1
    & suspendOutput, switchOutput
d164 1
d182 17
a198 13
    character(len=9) :: specialFillChars = '123456789'
    character(len=9) :: lineupFillChars =  'ynnnnynnn' ! whether they line up
    character(len=16), dimension(9) :: patterns = (/ & ! on consecutive lines
      &  '(. )            ' , &
      &  '(. .)           ' , &
      &  '(.  .)          ' , &
      &  '(.   .)         ' , &
      &  '(.. ..)         ' , &
      &  '(- )            ' , &
      &  '(- -)           ' , &
      &  '(-  -)          ' , &
      &  '(- .. )         ' /)
      !   12345678901234567890
d361 1
d370 1
a370 1
        read(fillChar, *) patternNum
d1141 1
a1141 1
    outputOptions%specialFillChars     = '123456789'
d1143 1
d1152 4
a1155 1
                                            &  '(- .. )         ' /)
d1216 17
d1516 1
a1516 1
       "$Id: output_m.f90,v 2.123 2015/08/25 18:36:56 vsnyder Exp $"
d1526 3
@


2.123
log
@Add a FLUSH statement to FlushOutputLines
@
text
@d54 1
d56 1
d74 2
d89 4
d113 1
d129 2
a130 2
  public :: addToIndent, Advance_is_yes_or_no, blanks, flushOutputLines, &
    & getOutputStatus, newline, &
d280 59
d533 1
a533 1
    character(len=3) :: MY_ADV
d553 6
a558 5
    ! (1) go silent if we are skipping all output
    ! (2) write to a file unit if PrUnit is to be taken literally
    ! (3) append to our accumulated outputLines if we are deferring output
    ! (4) print immediately if we have been switched to stdout
    ! (5) wade through a thicket of sub-choices involving possibly
d581 1
a581 1
    character(len=3) :: MY_ADV
d591 6
a597 1
    my_adv = Advance_is_yes_or_no(advance)
a1258 40
  ! .......................................  Advance_is_yes_or_no  .....
  function Advance_is_yes_or_no ( str ) result ( outstr )
    ! takes '[Yy]...' or '[Nn..] and returns 'yes' or 'no' respectively
    ! also does the same with '[Tt]..' and '[Ff]..'
    ! leaves all other patterns unchanged, but truncated to three
    ! characters.  Returns 'no' if the argument is absent.

    ! We are allowing its argument str to do multiple duties by being
    ! composed of multiple space-separated arguments, e.g. 
    ! 'arg1 [arg2] .. [argn]'
    ! (1) the first arg1 is treated as before, basically 'yes' or 'no'
    ! (2) arg2 and beyond will introduce extra options to the
    ! output command, eventually simplifying it to just
    !   call output( something, [advance='arg1 [arg2] .. [argn]' )
    !--------Argument--------!
    character (len=*), intent(in), optional :: Str
    character (len=3) :: Outstr

    !----------Local vars----------!
    character (len=*), parameter :: yeses = 'YyTt'
    character (len=*), parameter :: nose = 'NnFf'
    integer :: kSpace

    if ( .not. present(str)  ) then
      outstr = outputoptions%advanceDefault ! 'no'
      return
    end if

    outstr = adjustl(str)
    kSpace = index( outstr, ' ' )
    if ( kSpace > 1 ) outstr = outstr(:kSpace) ! To snip off arg2 ..
    if ( index( yeses, outstr(:1)) > 0  ) then
      outstr = 'yes'
    else if ( index( nose, outstr(:1)) > 0  ) then
      outstr = 'no'
    else
      outstr = str
    end if
  end function Advance_is_yes_or_no

d1416 1
a1416 1
    character(len=3) :: MY_ADV
d1486 1
a1486 1
       "$Id: output_m.f90,v 2.122 2015/07/14 23:26:54 pwagner Exp $"
d1496 3
@


2.122
log
@New advance_after_each arg to output of char arry; note that Reverting output now appears in old unit, e.g. stdout
@
text
@d15 1
a15 1
  
d18 1
a18 1
  
d188 1
a188 1
  
d208 1
a208 1
  
d221 1
a221 1
  
d338 1
d347 1
a347 1
    if ( present(prUnit) ) myprUnit = prUnit
d349 1
a349 1
    outputOptions%prUnit = myprUnit
d351 4
a354 9
    if ( kNull < 2 ) then
      ! OutputLines hasn't been defined yet
      return
    elseif ( kNull > len(OutputLines) ) then
      ! Something very wrong
      return
    else
      call output( OutputLines(1:kNull-1) )
    endif
a355 1
    OutputLines = ' '
d357 1
a357 1
  
d383 1
a383 1
    
d649 1
a649 1
    
d1191 1
a1191 1
    
d1295 1
a1295 1
    
d1445 1
a1445 1
    
d1452 1
a1452 1
       "$Id: output_m.f90,v 2.121 2015/05/18 17:40:03 pwagner Exp $"
d1462 3
@


2.121
log
@Made Advance_is_yes_or_no public; reordered where to print
@
text
@d720 2
a721 1
  subroutine OUTPUT_CHAR_ARRAY ( CHARS, ADVANCE, INSTEADOFBLANK, NEWLINEVAL )
d724 1
d733 4
a736 2
        & insteadofblank=insteadofblank, newLineVal=newLineVal )
      if ( len(chars(1)) > 1 ) call SeparateElements( i, size(chars) )
a1121 2
    call output_( 'Reverting output to unit: ', advance='no' )
    call output( OLDUNIT, advance='yes' )
d1129 2
d1457 1
a1457 1
       "$Id: output_m.f90,v 2.120 2015/03/06 21:37:42 pwagner Exp $"
d1467 3
@


2.120
log
@"%n" in output string could trigger unintended new line; fixed
@
text
@d120 5
a124 3
  public :: addToIndent, blanks, flushOutputLines, getOutputStatus, newline, &
    & output, output_char_nocr, resetIndent, restoreSettings, &
    & resumeOutput, revertOutput, suspendOutput, switchOutput
d532 8
a539 1
    if ( outputOptions%prUnitLiteral ) then
a542 6
    elseif ( outputOptions%prunit ==  OUTPUTLINESPRUNIT ) then
      ! Append to outputLines; maybe print later on
      call append_chars( outputLines, chars )
        if ( my_adv == 'yes' ) &
          call append_chars( outputLines, achar(outputOptions%NewLineVal) )
      go to 9
d1453 1
a1453 1
       "$Id: output_m.f90,v 2.119 2015/02/13 00:16:24 pwagner Exp $"
d1463 3
@


2.119
log
@Reordered tests in OUTPUT_CHAR_NOCR_INDENTED more understandably, we hope
@
text
@d94 1
a94 1
! behavior of output, and others can be changed by setting various
d99 1
d155 1
d223 1
d1289 1
a1289 1
    & Advance )
d1293 4
d1303 1
a1307 1
    !                                     If nonzero, do not insert prefix.
d1314 1
d1320 2
d1328 2
a1329 2
        l2 = index(Message(l1+1:),'%n' )
        if ( l2 == 0 ) l2 = index(Message(l1+1:),'%N')
d1450 1
a1450 1
       "$Id: output_m.f90,v 2.118 2015/02/10 00:59:36 pwagner Exp $"
d1460 3
@


2.118
log
@Repaired error introduced by last change
@
text
@d480 13
d522 1
a522 1
    if ( SILENTRUNNING ) go to 9
d526 1
d531 7
a537 2
    end if
    if ( SWITCHTOSTDOUT ) then
a646 13
    elseif ( outputOptions%prunit ==  OUTPUTLINESPRUNIT ) then
      ! Append to outputLines; maybe print later on
      !   if ( len_trim(chars) > 0 ) then
      !     if ( len_trim(outputLines) > 0 ) then
      !       outputLines = trim(outputLines) // trim(chars)
      !     else
      !       outputLines = chars
      !     endif
      call append_chars( outputLines, chars )
        if ( my_adv == 'yes' ) &
          call append_chars( outputLines, achar(outputOptions%NewLineVal) )
      !    & outputLines = trim(outputLines) // achar(outputOptions%NewLineVal) ! add <cr>
      ! endif
d1440 1
a1440 1
       "$Id: output_m.f90,v 2.117 2015/02/06 00:45:54 pwagner Exp $"
d1450 3
@


2.117
log
@Can now print to virtual page indented w.r.t. physical page
@
text
@d28 1
a28 1
    & MLSMSG_Severity_to_quit, MLSMSG_Warning, printItOut, &
d54 1
a54 1
! addToIndent              add this number of blanks indented; subtract if < 0
d120 1
a120 1
    & output, & output_char_nocr, resetIndent, restoreSettings, &
d1434 1
a1434 1
       "$Id: output_m.f90,v 2.116 2015/01/12 22:20:55 pwagner Exp $"
d1444 3
@


2.116
log
@swichOutput can switch to 'stdout'
@
text
@d54 1
d61 1
d119 3
a121 3
  public :: BLANKS, FLUSHOUTPUTLINES, GETOUTPUTSTATUS, NEWLINE, OUTPUT, &
    & OUTPUT_CHAR_NOCR, RESTORESETTINGS, &
    & RESUMEOUTPUT, REVERTOUTPUT, SUSPENDOUTPUT, SWITCHOUTPUT
d124 3
a126 3
  public :: OUTPUTOPTIONS_T
  public :: STAMPOPTIONS_T
  public :: TIMESTAMPOPTIONS_T
d128 2
a129 2
  interface GETOPTION
    module procedure GETOPTION_CHAR, GETOPTION_LOG
d222 1
a222 1
  logical, save, private :: SILENTRUNNING = .false. ! Suspend all further output
d224 2
d248 18
d369 6
a374 2
    if ( index(lowercase(name), 'column' ) > 0 ) then
      status = atColumnNumber
a383 1

d457 23
d705 1
a705 1
  end subroutine OUTPUT_CHAR_NOCR
d1434 1
a1434 1
       "$Id: output_m.f90,v 2.115 2014/09/05 00:28:05 vsnyder Exp $"
d1444 3
@


2.115
log
@Better handling of literal output unit
@
text
@d16 2
a17 1
  ! See also dump_0 and MLSMessageModule
d19 11
a29 11
  use DATES_MODULE, only:REFORMATDATE, REFORMATTIME
  use MACHINE, only: CRASH_BURN, EXIT_WITH_STATUS, NEVERCRASH
  use MLSCOMMON, only: FILENAMELEN, FINITE_SIGNAL, &
    & IS_WHAT_IEEE
  use MLSSTRINGLISTS, only: NCHARSINFORMAT
  use MLSSTRINGS, only: REPLACENONASCII, LOWERCASE, &
    & READINTSFROMCHARS, TRIM_SAFE
  use PRINTIT_M, only: ASSEMBLEFULLLINE, GET_CONFIG, &
    & MLSMSG_CRASH, MLSMSG_DEBUG, MLSMSG_INFO, MLSMSG_ERROR, &
    & MLSMSG_SEVERITY_TO_QUIT, MLSMSG_WARNING, PRINTITOUT, &
    & MLSMESSAGECONFIG
d65 2
a66 1
! switchOutput             switch output to a new named file
d219 1
d470 5
d1045 1
d1049 4
d1079 1
d1090 5
a1230 25
  subroutine myMessage_old ( severity, name, line, advance )
    ! Args
    integer, intent(in)           :: severity
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: line
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    ! Local variables
    integer :: nChars
    character(len=len(line) + len(name) + 3) :: thus
    ! Executable
    nChars = len(line)
    thus = line
    if ( len_trim(name) > 0 ) then
      nChars = len(line) + len(name) + 3
      thus = '(' // trim(name) // ') ' // line
    endif
    if ( severity > MLSMSG_Warning ) then
      call PrintItOut( thus(1:nChars), SEVERITY, exitStatus = 1  )
    else
      call PrintItOut( thus(1:nChars), SEVERITY  )
    endif
  end subroutine myMessage_old

d1386 1
a1386 1
       "$Id: output_m.f90,v 2.114 2014/08/06 19:26:49 pwagner Exp $"
d1396 3
@


2.114
log
@Bugfixes plus one workaround for an ifort v13 bug
@
text
@d439 1
d456 1
d458 1
a458 1
    if ( SILENTRUNNING ) return
d463 1
a463 1
      write( outputOptions%prUnit, '(a)', advance=my_adv ) trim_safe(chars)
d465 2
a466 2
      return
    endif
d482 1
d486 1
a486 2
    if ( (.not. outputOptions%buffered) .and. &
      & theUnit /= 0 .and. &
a506 1
    n_chars = len(chars)
d518 1
a518 1
    if ( theUnit /= 0 .and. n_stamp > RECLMAX ) then
d527 1
a527 1
    elseif ( theUnit /= 0 .and. len(chars) < 1 .and. my_adv == 'yes' ) then
d530 1
a530 1
    elseif ( theUnit /= 0 .and. n_stamp > 0 ) then
d606 1
a606 1
      if ( (.not. outputOptions%buffered) .and. theUnit /= 0 ) then
d615 1
a615 1
        if ( theUnit /= 0 ) then
d625 1
d1392 1
a1392 1
       "$Id: output_m.f90,v 2.113 2014/08/05 18:23:24 pwagner Exp $"
d1402 3
@


2.113
log
@prUnitLiteral field lets prUnit go negative
@
text
@d458 7
d514 2
d528 1
d531 1
d536 1
a536 1
      & .not. my_dont_log  ) then
d586 4
a589 1
    if ( outputOptions%prunit <= 0 .or. alreadyLogged ) then
d600 2
d979 2
a980 1
    outputOptions%PRUNIT               = STDOUTPRUNIT
d1390 1
a1390 1
       "$Id: output_m.f90,v 2.112 2014/07/21 20:56:47 pwagner Exp $"
d1400 3
@


2.112
log
@Should not bomb so easily
@
text
@d151 1
a151 1
    integer :: PRUNIT = STDOUTPRUNIT    ! Unit for output (see comments above).  
d156 4
a159 3
    logical :: BUFFERED            = .true.
    logical :: LOGPARENT           = .false. ! Show who called output, not output
    logical :: SKIPMLSMSGLOGGING   = .false.
d468 1
a468 1
    if ( outputOptions%prUnit > 0 ) then
d1373 1
a1373 1
       "$Id: output_m.f90,v 2.111 2014/01/11 01:41:02 vsnyder Exp $"
d1383 3
@


2.111
log
@Decruftification
@
text
@d774 1
d790 3
a792 1
      write ( line, format ) int
d1372 1
a1372 1
       "$Id: output_m.f90,v 2.110 2014/01/09 00:22:18 pwagner Exp $"
d1382 3
@


2.110
log
@Split output module procedures between it and new highOutput
@
text
@d27 3
a29 3
    & MLSMSG_SEVERITY_TO_QUIT, &
    & MLSMSG_WARNING, &
    & PRINTITOUT, MLSMESSAGECONFIG
d1369 1
a1369 1
       "$Id: output_m.f90,v 2.109 2013/11/21 21:21:41 pwagner Exp $"
d1379 3
@


2.109
log
@Wrap lines at the right-hand border when outputting named arrays with borders
@
text
@d14 1
a14 5
  ! Very high level printing and formatting
  
  ! Should we split off lower-level stuff
  ! (output, blanks, newLine, outputoptions, a few others)
  ! to a new output_0 module?
d18 1
a18 2
  use DATES_MODULE, only:  BUILDCALENDAR, DAYSINMONTH, &
    & REFORMATDATE, REFORMATTIME, UTC_TO_YYYYMMDD
d20 1
a20 1
  use MLSCOMMON, only: FILENAMELEN, FINITE_SIGNAL, MLSDEBUG, MLSVERBOSE, &
d22 3
a24 5
  use MLSFINDS, only: FINDFIRST
  use MLSSTRINGLISTS, only: EXPANDSTRINGRANGE, GETSTRINGELEMENT, &
    & LIST2ARRAY, NUMSTRINGELEMENTS, SWITCHDETAIL, WRAP
  use MLSSTRINGS, only: REPLACENONASCII, LOWERCASE, NCOPIES, &
    & READINTSFROMCHARS, TRIM_SAFE, WRITEINTSTOCHARS
d29 1
a29 2
    & PRINTITOUT, STDOUTLOGUNIT, MLSMESSAGECONFIG
  use TOGGLES, only: SWITCHES
a52 6
! alignToFit               align printed argument to fit column range
! banner                   surround message with stars and stripes; e.g.,
!                            *-----------------------------------------------*
!                            *            Your message here                  *
!                            *-----------------------------------------------*
! BeVerbose                Do extra printing?
a53 5
! blanksToColumn           print blanks [or fill chars] out to specified column
! blanksToTab              print blanks [or fill chars] out to next tab stop
! dump                     dump output or stamp options
! dumpsize                 print a nicely-formatted memory size 
! dumptabs                 print the current tab stop positions
d55 1
a55 3
! getStamp                 get stamp being added to every output
! headLine                 print a line with extra formatting features
!                           e.g., '*-------  Your message here   -------*'
a56 1
! LetsDebug                Do debug printing?
a57 2
! numNeedsFormat           return what format is need to output num
! numToChars               return what would be printed by output
a58 5
! outputCalendar           output nicely-formatted calendar page
! output_date_and_time     print nicely formatted date and time
! outputList               output array as comma-separated list; e.g. '(1,2,..)'
! outputNamedValue         print nicely formatted name and value
! resettabs                restore tab stops to what was in effect at start
a62 2
! setStamp                 set stamp to be added to every output automatically
! setTabs                  set tab stops (to be used by tab)
a64 3
! tab                      move to next tab stop
! timestamp                print argument with a timestamp manually
!                            (both stdout and logged output)
a67 3
! alignToFit ( char* chars, int columnRange(2), char alignment, [int skips] )
! banner ( char* chars, [int columnRange(2)], [char alignment], [int skips] )
! log BeVerbose ( char* switch, threshold )
a68 7
! blanksToColumn ( int column, [char fillChar], [char* advance] )
! blanksToTab ( [int tabn], [char* fillChar] )
! Dump ( options )
! DumpSize ( n, [char* advance], [units] )
!       where n can be an int or a real, and 
!       units is a scalar of the same type, if present
! DumpTabs ( [int tabs(:)] )
d70 1
a70 5
! getStamp ( [char* textCode], [log post], [int interval],
!          [log showTime], [char* dateFormat], [char* timeFormat] )
! headLine ( char* chars, 
!          [char fillChar], [char* Before], [char* After], 
!          [int columnRange(2)], [char alignment], [int skips] )
a71 1
! log LetsDebug ( char* switch, threshold )
a72 2
! char* numNeedsFormat ( value )
! char* numToChars ( value, [char* format] )
a80 10
! output_date_and_time ( [log date], [log time], [char* from_where], 
!          [char* msg], [char* dateFormat], [char* timeFormat], 
!          [double CPU_seconds], [char* advance] )
! outputCalendar ( [char* date], [char* datenote], [char* notes(:)], 
!          [dontwrap] )
! outputList ( values(:), [char* sep], [char* delims] )
! outputNamedValue ( char* name, value, [char* advance],
!          [char colon], [char fillChar], [char* Before], [char* After], 
!          [integer tabn], [integer tabc], [integer taba], log dont_stamp] )
! resetTabs ( [int tabs(:)] )
a83 3
! setStamp ( [char* textCode], [log post], [int interval],
!          [log showTime], [char* dateFormat], [char* timeFormat] )
! setTabs ( [char* Range], [int tabs(:)] )
a85 10
! tab ( [int tabn], [char* fillChar] )
! timeStamp ( char* chars, [char* advance], [char* from_where], 
!          [log dont_log], [char* log_chars], [char* insteadOfBlank],
!          [char*8 style], [log date] )
! timeStamp ( log value, [char* advance], [char* from_where], 
!          [log dont_log], [char* log_chars], [char* insteadOfBlank],
!          [char*8 style], [log date] )
! timeStamp ( int int, [int places], [char* advance],
!          [log fill], [char* format], [char* Before], [char* After],
!          [char*8 style], [log date] )
d115 3
a117 7
  public :: ALIGNTOFIT, BANNER, BEVERBOSE, BLANKS, BLANKSTOCOLUMN, BLANKSTOTAB, &
    & DUMP, DUMPSIZE, DUMPTABS, FLUSHOUTPUTLINES, GETSTAMP, HEADLINE, &
    & LETSDEBUG, NEXTCOLUMN, NEXTTAB, NEWLINE, NUMNEEDSFORMAT, NUMTOCHARS, &
    & OUTPUT, OUTPUT_DATE_AND_TIME, OUTPUTCALENDAR, OUTPUTLIST, &
    & OUTPUTNAMEDVALUE, &
    & RESETTABS, RESTORESETTINGS, RESUMEOUTPUT, REVERTOUTPUT, &
    & SETSTAMP, SETTABS, SUSPENDOUTPUT, SWITCHOUTPUT, TAB, TIMESTAMP
d120 3
a122 21
  public :: outputOptions_T
  public :: stampOptions_T
  public :: timeStampOptions_T

  interface ALIGNTOFIT
    module procedure aligntofit_chars, aligntofit_double, aligntofit_single
    module procedure aligntofit_integer
  end interface

  interface BANNER
    module procedure banner_chars
    module procedure banner_chararray
  end interface

  interface DUMP
    module procedure DUMPOUTPUTOPTIONS, DUMPSTAMPOPTIONS, DUMPTIMESTAMPOPTIONS
  end interface

  interface DUMPSIZE
    module procedure DUMPSIZE_DOUBLE, DUMPSIZE_INTEGER, DUMPSIZE_REAL
  end interface
d125 1
a125 10
    module procedure getOption_char, getOption_log
  end interface

  interface NUMNEEDSFORMAT
    module procedure numNeedsFormat_double, numNeedsFormat_integer, numNeedsFormat_single
    module procedure numNeedsFormat_complex, numNeedsFormat_dcomplx
  end interface

  interface NUMTOCHARS
    module procedure numtochars_double, numtochars_integer, numtochars_single
a142 21
  interface OUTPUTLIST
    module procedure OUTPUTLIST_INTS, OUTPUTLIST_CHARS
  end interface

  interface OUTPUTNAMEDVALUE
    module procedure output_nvp_character
    module procedure output_nvp_complex
    module procedure output_nvp_dbl_array, output_nvp_double
    module procedure output_nvp_int_array, output_nvp_integer
    module procedure output_nvp_log_array, output_nvp_logical
    module procedure output_nvp_sngl_array, output_nvp_single
  end interface

  interface TAB
    module procedure blanksToTab
  end interface
  
  interface TIMESTAMP
    module procedure timestamp_char, timestamp_integer, timestamp_logical
  end interface
  
a220 1
  integer, private, parameter :: MAXNUMTABSTOPS = 24
d223 1
a223 8
  integer, save, private :: OLDWRAPPASTCOLNUM = 0
  ! These next tab stops can be reset using the procedure setTabs
  ! the default values correspond to range coded '5-120+5'
  ! (read as from 5 to 120 in intervals of 5)
  character(len=*), parameter :: INITTABRANGE = '5-120+5'
  integer, dimension(MAXNUMTABSTOPS), save, private :: TABSTOPS = &
    & (/ 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, &
    &   65, 70, 75, 80, 85, 90, 95,100,105,110,115,120 /)
a230 2
  character(len=12), private :: sdNeedsFormat = '(1pg14.6)'
  character(len=12), private :: sdNeedsFragment = '(1pg14'
a239 250
  ! -----------------------------------------------------  ALIGNTOFIT  -----
  ! Align chars to fit within column range
  ! Alignment controls whether the chars are
  ! L    Flushed left
  ! R    Flushed right
  ! C    Centered
  ! J    Justified (padding spaces to any existing spaces)
  subroutine ALIGNTOFIT_CHARS ( CHARS, COLUMNRANGE, ALIGNMENT, SKIPS )
    character(len=*), intent(in)      :: CHARS
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), intent(in) :: COLUMNRANGE
    character(len=1), intent(in)      :: ALIGNMENT ! L, R, C, or J
    integer, optional, intent(in)     :: SKIPS ! How many spaces between chars
    !
    ! Internal variables
    character(len=max(len(chars), abs(columnRange(2)-columnRange(1)))) :: &
      & ALLCHARS
    integer :: char1
    integer :: char2
    integer :: firstSpace
    integer :: m
    integer :: nc
    integer :: padLeft
    integer :: padRight
    integer :: spaces
    ! Executable
    allChars = chars
    if ( present(skips) ) then
      if ( skips > 0 .and. len_trim(chars) > 0 ) then
        allChars = stretch(chars, skips)
      endif
    endif
    if ( columnRange(1) > 0 ) then
      spaces = columnRange(2) - max( columnRange(1), atColumnNumber )
      if ( spaces < 1 ) return
      if ( columnRange(1) > atColumnNumber ) &
        & call blanks( columnRange(1) - atColumnNumber )
    else
      spaces = columnRange(2) - columnRange(1)
    endif
    firstSpace = 0
    nc = max( len_trim(allchars), 1 )
    select case (lowercase(alignment))
    case ('l')
      char1    = 1
      padLeft  = 0
      char2    = min( nc, spaces )
      padRight = spaces - char2
    case ('r')
      char1    = max(1, nc-spaces+1)
      char2    = nc
      padLeft  = spaces - (char2-char1+1)
      padRight = 0
    case ('c', 'j')
      m = (spaces - nc) / 2
      padLeft  = max( m, 0 )
      padRight = max( spaces - nc - m, 0 )
      char1 = max(1-m, 1)
      char2 = min(nc+m, nc)
      if ( lowercase(alignment) == 'j' .and. padRight > 0 ) &
        & firstSpace = index( allChars, ' ' )
    end select
    if ( firstSpace > 1 ) then
      call output_( allChars(char1:firstSpace-1) )
      call blanks( padRight+padLeft+1 )
      if ( firstSpace+1 < char2 ) call output_( allChars(firstSpace+1:char2) )
    else
      call blanks( padLeft )
      call output_( allChars(char1:char2) )
      call blanks( padRight )
    endif
  end subroutine ALIGNTOFIT_CHARS

  subroutine ALIGNTOFIT_DOUBLE ( value, COLUMNRANGE, ALIGNMENT, FORMAT )
    double precision, intent(in)      :: value
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), intent(in) :: COLUMNRANGE
    character(len=1), intent(in)      :: ALIGNMENT ! L, R, C, or J
    character(len=*), optional, intent(in)     :: FORMAT
    !
    ! Internal variables
    character(len=30) :: line
    ! Executable
    line = numToChars( value, format )
    call alignToFit( trim(line), columnRange, alignment )
  end subroutine ALIGNTOFIT_DOUBLE

  subroutine ALIGNTOFIT_INTEGER ( value, COLUMNRANGE, ALIGNMENT, FORMAT )
    integer, intent(in)               :: value
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), intent(in) :: COLUMNRANGE
    character(len=1), intent(in)      :: ALIGNMENT ! L, R, C, or J
    character(len=*), optional, intent(in)     :: FORMAT
    !
    ! Internal variables
    character(len=30) :: line
    ! Executable
    line = numToChars( value, format )
    call alignToFit( trim(line), columnRange, alignment )
  end subroutine ALIGNTOFIT_INTEGER

  subroutine ALIGNTOFIT_SINGLE ( value, COLUMNRANGE, ALIGNMENT, FORMAT )
    real, intent(in)      :: value
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), intent(in) :: COLUMNRANGE
    character(len=1), intent(in)      :: ALIGNMENT ! L, R, C, or J
    character(len=*), optional, intent(in)     :: FORMAT
    !
    ! Internal variables
    character(len=30) :: line
    ! Executable
    line = numToChars( value, format )
    call alignToFit( trim(line), columnRange, alignment )
  end subroutine ALIGNTOFIT_SINGLE

  ! -----------------------------------------------------  BANNER  -----
  ! Surround your message with stars and stripes; e.g.,
  ! *-----------------------------------------------*
  ! *            Your message here                  *
  ! *-----------------------------------------------*
  ! For multiline messages, you may divide them into elements of
  ! a character array, or else a longer character scalar and
  ! supply LineLength for the routine to wrap at word boundaries
  subroutine BANNER_CHARS ( CHARS, COLUMNRANGE, ALIGNMENT, SKIPS, LINELENGTH )
    character(len=*), intent(in)                :: CHARS
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: COLUMNRANGE
    character(len=1), intent(in), optional      :: ALIGNMENT ! L, R, C, or J
    integer, optional, intent(in)               :: SKIPS ! How many spaces between chars
    integer, optional, intent(in)               :: LINELENGTH
    !
    ! Internal variables
    integer :: addedLines
    character(len=1)      :: myAlignment
    integer, dimension(2) :: myColumnRange
    integer :: lineLen, mySkips,  padding
    character(len=2*len(chars))      :: wrappedChars
    character(len=160), dimension(:), pointer :: lines
    logical, parameter :: DEBUG = .false.
    ! Executable
    myAlignment = 'C'
    if ( present(alignment) ) myAlignment = alignment
    mySkips = 0
    if ( present(skips) ) mySkips = skips
    if ( present(LineLength) ) then
      ! We will wrap the input to fit within LineLength, but remembering
      ! the stars and padding
      call wrap( chars, wrappedChars, width=LineLength-4, &
        & inseparator=achar(0), addedLines=addedLines )
      addedLines = addedLines + 1
      allocate(lines(addedLines))
      lines = ' '
      call List2Array( wrappedChars, lines, &
        & countEmpty=.true., inseparator=achar(0) )
      call banner( lines, alignment=alignment )
      deallocate(lines)
      return
    elseif ( present(columnRange) ) then
      myColumnRange = columnRange
    else
      lineLen = max( 80, 4 + len_trim(chars)*(1+mySkips) )
      padding = ( lineLen - len_trim(chars)*(1+mySkips) ) / 2
      myColumnRange(1) = 1 + padding
      myColumnRange(2) = lineLen - padding
    endif
    
    ! define padding as the larger of columnrange(1) and 1
    padding = max( 1, myColumnRange(1) )
    LineLen = padding + myColumnRange(2) - 1
    if ( DEBUG ) then
      call outputnamedValue( 'padding', padding )
      call outputnamedValue( 'LineLen', LineLen )
      call outputnamedValue( 'myColumnRange', myColumnRange )
    endif
    ! Top border
    call output( '*' )
    call blanks ( lineLen-2, FillChar='-' )
    call output( '*', advance = 'yes' )
    ! Left star, then message, then right star
    call output( '*' )
    call alignToFit( chars, myColumnRange, myAlignment, skips )
    call blanksToColumn( lineLen )
    call output( '*', advance = 'yes' )
    ! Bottom border
    call output( '*' )
    call blanks ( lineLen-2, FillChar='-' )
    call output( '*', advance = 'yes' )
  end subroutine BANNER_CHARS

  subroutine BANNER_CHARARRAY ( CHARARRAY, COLUMNRANGE, ALIGNMENT, SKIPS )
    character(len=*), dimension(:), intent(in)  :: CHARARRAY
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: COLUMNRANGE
    character(len=1), intent(in), optional      :: ALIGNMENT ! L, R, C, or J
    integer, optional, intent(in)               :: SKIPS ! How many spaces between chars
    !
    ! Internal variables
    integer :: i
    ! Internal variables
    character(len=1)      :: myAlignment
    integer, dimension(2) :: myColumnRange
    integer :: lineLen, mySkips,  padding
    ! Executable
    myAlignment = 'C'
    if ( present(alignment) ) myAlignment = alignment
    mySkips = 0
    if ( present(skips) ) mySkips = skips
    if ( present(columnRange) ) then
      myColumnRange = columnRange
    else
      lineLen = 80
      padding = LineLen
      do i = 1, size(chararray)
        lineLen = max( lineLen, 4 + len_trim(chararray(i))*(1+mySkips) )
        padding = min( padding, &
          & ( lineLen - len_trim(chararray(i))*(1+mySkips) ) / 2 )
      enddo
      myColumnRange(1) = 1 + padding
      myColumnRange(2) = lineLen - padding
    endif
    
    ! define padding as the larger of columnrange(1) and 1
    padding = max( 1, myColumnRange(1) )
    LineLen = padding + myColumnRange(2) - 1
    ! Top border
    call output( '*' )
    call blanks ( lineLen-2, FillChar='-' )
    call output( '*', advance = 'yes' )
    do i = 1, size(chararray)
      ! Left star, then message, then right star
      call output( '*' )
      call alignToFit( chararray(i), myColumnRange, myAlignment, skips )
      call blanksToColumn( lineLen )
      call output( '*', advance = 'yes' )
    enddo
    ! Bottom border
    call output( '*' )
    call blanks ( lineLen-2, FillChar='-' )
    call output( '*', advance = 'yes' )
  end subroutine BANNER_CHARARRAY

  ! -----------------------------------------------------  BEVERBOSE  -----
  logical function BEVERBOSE ( SWITCH, THRESHOLD )
    ! Args
    character(len=*), intent(in) :: SWITCH
    integer, intent(in)          :: THRESHOLD
    ! Executable
    BeVerbose = switchDetail( switches, switch ) > threshold .or. MLSVerbose
  end function BEVERBOSE

a302 260
  ! -----------------------------------------------------  BLANKSTOCOLUMN  -----
  subroutine BLANKSTOCOLUMN ( COLUMN, FILLCHAR, ADVANCE, DONT_STAMP )
  ! Output N_BLANKS blanks to PRUNIT out to column COLUMN.
  ! (or optionally that many copies of fillChar)
    integer, intent(in) :: COLUMN
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: FILLCHAR  ! default is ' '
    logical, intent(in), optional          :: DONT_STAMP ! Prevent double-stamping
    ! Executable
    if ( ATCOLUMNNUMBER >= COLUMN ) return
    call blanks( COLUMN-ATCOLUMNNUMBER, fillChar, advance, dont_stamp )
  end subroutine BLANKSTOCOLUMN

  ! ------------------------------------------------  blanksToTab  -----
  ! Print blanks out to next tabstop
  ! (or else to tabstop number tabn)
  subroutine blanksToTab ( tabn, fillChar )
    ! Args
    integer, optional, intent(in) :: TABN
    character(len=*), intent(in), optional :: FILLCHAR  ! default is ' '
    ! Internal variables
    integer :: nTab
    ! Executable
    if ( present(tabn) ) then
      if ( tabn < 1 .or. tabn > MAXNUMTABSTOPS ) return
      if ( atColumnNumber < tabStops(tabn) ) &
        & call blanksToColumn( tabStops(tabn), fillChar )
    else
      nTab = findFirst( tabStops > atColumnNumber )
      if ( nTab > 0 ) &
        & call blanksToColumn( tabStops(nTab), fillChar )
    endif
  end subroutine blanksToTab

  ! ---------------------------------------------- DumpOuputOptions -----
  subroutine DumpOutputOptions(options)
    ! Show output options
    type(outputOptions_T), intent(in) :: options
    ! Internal variables
    logical, parameter :: checkingTabbing = .false.
    character(len=10), parameter :: decade = '1234567890'
    character(len=1), parameter :: fillChar = '1' ! fill blanks with '. .'
    integer :: i
    ! Executable
    call blanks(80, fillChar='-', advance='yes')
    call headline( 'Summary of output options', &
      & fillChar='-', before='*', after='*' )
    call outputNamedValue ( 'unit number', options%prUnit, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    if ( options%prUnit < 0 ) then
      call outputNamedValue ( 'meaning', prunitname(options%prUnit), &
        & advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    endif
    call outputNamedValue ( 'file name', trim(options%name), advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'logging level', options%MLSMSG_Level, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'buffered?', options%buffered, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'skip MLSMsg logging?', options%SKIPMLSMSGLOGGING, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'log Parent Name?', options%logParent, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'use patterned blanks?', options%usePatternedBlanks, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'special fills', trim(options%specialFillChars), advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'lineup fills', trim(options%lineupFillChars), advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call outputNamedValue ( 'tab stops', tabstops, advance='yes', &
      & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    do i=1, MAXNUMTABSTOPS
      call tab( fillChar=fillChar )
      call output_( '^', advance='no' )
    enddo
    call newline
    if ( CHECKINGTABBING ) then
      do i=1, MAXNUMTABSTOPS
        call blanksToColumn( tabStops(i), fillChar=fillChar )
        call output_( '^', advance='no' )
      enddo
      call newline
    endif
    do
      call output_( decade, advance='no' )
      if ( atColumnNumber > 132 ) exit
    enddo
    call newline
    call blanks(80, fillChar='-', advance='yes')
  contains
    function PRUnitName( prUnit ) result( name )
      ! Return an appropriate name for the prUnit number
      ! Args
      integer, intent(in) :: prUnit
      character(len=12) :: name
      ! Executable
      select case ( prUnit )
      case ( STDOUTPRUNIT )
        name = 'stdout'
      case ( MSGLOGPRUNIT )
        name = 'mls logfile'
      case ( BOTHPRUNIT )
        name = 'stdout+log'
      case ( OUTPUTLINESPRUNIT )
        name = 'outputLines'
      case ( INVALIDPRUNIT )
        name = 'invalid'
      case default ! > 0
        name = 'Fortran unit'
      end select
    end function PRUnitName
  end subroutine DumpOutputOptions

  ! ---------------------------------------------- DumpStampOptions -----
  subroutine DumpStampOptions(options)
    ! Show output options
    type(StampOptions_T), intent(in) :: options
    character(len=1), parameter :: fillChar = '1' ! fill blanks with '. .'
     call blanks(80, fillChar='-', advance='yes')
    call headline( 'Summary of automatic stamp options', &
      & fillChar='-', before='*', after='*' )
     call outputNamedValue ( 'stamp end of line', options%post, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'show time', options%showTime, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'extra text', trim_safe(options%textCode), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'date format', trim_safe(options%dateFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'time format', trim_safe(options%timeFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'interval', options%interval, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'style of timeStamps', trim_safe(options%timestampstyle), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call blanks(80, fillChar='-', advance='yes')
  end subroutine DumpStampOptions

  ! ---------------------------------------------- DUMPTIMESTAMPOPTIONS -----
  subroutine DUMPTIMESTAMPOPTIONS(options)
    ! Show output options
    type(TimeStampOptions_T), intent(in) :: options
    character(len=1), parameter :: fillChar = '1' ! fill blanks with '. .'
     call blanks(80, fillChar='-', advance='yes')
    call headline( 'Summary of time stamp options', &
      & fillChar='-', before='*', after='*' )
     call outputNamedValue ( 'stamp end of line', options%post, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'show date', options%showDate, advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'extra text', trim_safe(options%textCode), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'date format', trim_safe(options%dateFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'time format', trim_safe(options%timeFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
     call outputNamedValue ( 'style of timeStamps', trim_safe(options%timestampstyle), advance='yes', &
       & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
    call blanks(80, fillChar='-', advance='yes')
  end subroutine DUMPTIMESTAMPOPTIONS

  ! ---------------------------------------------- DumpSize_double -----
  subroutine DumpSize_double ( n, advance, units, Before, After )
    double precision, intent(in) :: N
    character(len=*), intent(in), optional :: ADVANCE
    real, intent(in), optional :: units
    character(len=*), intent(in), optional :: Before, After
    ! Local parameters
    real, parameter :: KB = 1024.0
    real, parameter :: MB = KB * 1024.0
    real, parameter :: GB = MB * 1024.0
    real, parameter :: TB = GB * 1024.0
    double precision :: Amount ! N * MyUnits
    character(len=8) :: HowMuch
    real             :: myUnits
    character(len=6) :: Suffix
    ! Make a 'nice' output
    if ( present(before) ) call output_ ( before )
    myUnits = 1.0
    if ( present(units) ) myUnits = units
    if ( myUnits == 0.0 ) then
      call output ( n, format='(e12.1)' )
      call output_ ( ' (illegal units)', advance=advance )
      return
    end if
    amount = n*myUnits
    if ( abs(n) < kb/myUnits ) then
      suffix = ' bytes'
    else if ( abs(n) < Mb/myUnits ) then
      amount = amount/kb
      suffix = ' kB'
    else if ( abs(n) < Gb/myUnits ) then
      amount = amount/Mb
      suffix = ' MB'
    else if ( abs(n) < Tb/myUnits ) then
      amount = amount/Gb
      suffix = ' GB'
    else
      amount = amount/Tb
      suffix = ' TB'
    end if
    if ( amount < -99999 ) then     ! I6 format limits this
      call output_( '(-HUGE)' )
    elseif ( amount > 999999 ) then ! I6 format limits this
      call output_( '(HUGE)' )
    elseif ( amount == int(amount) ) then
      write ( howMuch, '(i6)' ) int(amount)
    else
      write ( howMuch, '(f8.1)' ) amount
    end if
    call output_ ( trim(adjustl(howMuch)) )
    call output_ ( trim(suffix) )
    if ( present(after) ) call output_ ( after )
    call output_ ( '', advance=advance )
  end subroutine DumpSize_double

  ! --------------------------------------------- DumpSize_integer -----
  subroutine DumpSize_integer ( n, advance, units, Before, After )
    integer, intent(in) :: N
    character(len=*), intent(in), optional :: ADVANCE
    integer, intent(in), optional :: units ! E.g., 1024 for kB
    character(len=*), intent(in), optional :: Before, After
    ! Executable
    if ( present(units) ) then
      call dumpSize ( dble(n), advance=advance, units=real(units), &
        & before=before, after=after )
    else
      call dumpSize ( dble(n), advance=advance, before=before, after=after )
    end if
  end subroutine DumpSize_integer

  ! ------------------------------------------------ DumpSize_real -----
  subroutine DumpSize_real ( n, advance, units, Before, After )
    real, intent(in) :: N
    character(len=*), intent(in), optional :: ADVANCE
    real, intent(in), optional :: units
    character(len=*), intent(in), optional :: Before, After
    ! Make a 'nice' output
    call dumpsize ( dble(n), advance, units, before, after )
  end subroutine DumpSize_real

  ! ----------------------------------------------  dumpTabs  -----
  ! Show tab stops in effect
  ! Optionally returning them as an integer array
  subroutine dumpTabs ( tabs )
    ! Args
    integer, dimension(:), optional, intent(out) :: tabs
    ! Internal variables
    integer :: n
    ! Executable
    call output( 'Current tab stops', advance='yes' )
    call output( TABSTOPS, advance='yes' )
    if ( present(tabs) ) then
      n = min(size(tabs), MAXNUMTABSTOPS)
      tabs = 0
      tabs(1:n) = TABSTOPS(1:n)
    endif
  end subroutine dumpTabs

d331 11
a341 39

  ! ----------------------------------------------  getStamp  -----
  subroutine getStamp ( textCode, showTime, dateFormat, timeFormat, &
    & post, interval )
  ! get stamp being added to every output to PRUNIT.
    character(len=*), optional, intent(out) :: textCode
    logical, optional, intent(out)          :: showTime
    character(len=*), optional, intent(out) :: dateFormat
    character(len=*), optional, intent(out) :: timeFormat
    logical, optional, intent(out)          :: post
    integer, optional, intent(out)          :: interval
    if ( present(showTime) )   showTime   = stampOptions%showTime
    if ( present(textCode) )   textCode   = stampOptions%textCode
    if ( present(dateFormat) ) dateFormat = stampOptions%dateFormat
    if ( present(timeFormat) ) timeFormat = stampOptions%timeFormat
    if ( present(post) )       post       = stampOptions%post
    if ( present(interval) )   interval   = stampOptions%interval
  end subroutine getStamp

  ! -----------------------------------------------------  HEADLINE  -----
  ! Print your message with extra formatting features; e.g.,
  ! *----------------  Your message here   ----------------*
  ! See also banner
  subroutine HEADLINE ( CHARS, fillChar, Before, After, &
    & COLUMNRANGE, ALIGNMENT, SKIPS )
    character(len=*), intent(in)                :: CHARS
    character(len=1), intent(in), optional :: fillChar      ! For padding
    character(len=*), intent(in), optional :: Before, After ! text to print
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: COLUMNRANGE
    character(len=1), intent(in), optional      :: ALIGNMENT ! L, R, C, or J
    integer, optional, intent(in)               :: SKIPS ! How many spaces between chars
    !
    ! Internal variables
    character(len=1)      :: myAlignment
    integer, dimension(2) :: myColumnRange      ! To fit chars
    integer, dimension(2) :: myFullColumnRange  ! Must fit before and after, too
    integer :: mySkips,  rightpadding
    character(len=1) :: myFillChar
d343 8
a350 5
    if ( present(columnRange) ) then
      myFullColumnRange = columnRange
    else
      myFullColumnRange(1) = 1
      myFullColumnRange(2) = 80
d352 2
a353 37
    myColumnRange = myFullColumnRange
    mySkips = 0
    if ( present(skips) ) mySkips = skips
    myFillChar = ' '
    if ( present(fillChar) ) myFillChar = fillChar
    myAlignment = 'C'
    if ( present(alignment) ) myAlignment = alignment
    ! call outputNamedValue ( 'myFullColumnRange', myFullColumnRange )
    ! call outputNamedValue ( 'myColumnRange', myColumnRange )
    ! call outputNamedValue ( 'mySkips', mySkips )
    ! call outputNamedValue ( 'myFillChar', myFillChar )
    ! Adjust for lengths of before, after
    if ( present(before) ) myColumnRange(1) = myFullColumnRange(1) + len(before)
    if ( present(after) ) then
      myColumnRange(2) = myFullColumnRange(2) - len(after)
      rightpadding = len(after) - 1
    endif
    call blanksToColumn( myFullColumnRange(1), advance='no' )
    if ( present(before) ) call output(before, advance='no' )
    if ( mySkips == 0 .and. myAlignment == 'C' .and. myFillChar /= ' ' ) then
      ! OK, final adjustments of myColumnRange
      myColumnRange(1) = &
        & ( myColumnRange(1) + myColumnRange(2) + 1 - len(chars) )/2
      myColumnRange(2) =  myColumnRange(1) - 1 + len(chars)
      ! call outputNamedValue ( 'myColumnRange', myColumnRange )
      call blanksToColumn( myColumnRange(1), fillChar=fillChar, advance='no' )
      call aligntofit( chars, myColumnRange, myAlignment, skips )
      call blanksToColumn( myFullColumnRange(2)-rightpadding, &
        & fillChar=fillChar, advance='no' )
      if ( present(after) ) call output(after, advance='no' )
    else
      call aligntofit( chars, myColumnRange, myAlignment, skips )
      call blanksToColumn(myFullColumnRange(2)-rightpadding, advance='no' )
      if ( present(after) ) call output(after, advance='no' )
    endif
    call newLine
  end subroutine HEADLINE
a360 9
  ! -----------------------------------------------------  LETSDEBUG  -----
  logical function LETSDEBUG ( SWITCH, THRESHOLD )
    ! Args
    character(len=*), intent(in) :: SWITCH
    integer, intent(in)          :: THRESHOLD
    ! Executable
    letsDebug = switchDetail( switches, switch ) > threshold .or. MLSDebug
  end function LETSDEBUG

a365 338
  ! ----------------------------------------------------  NextColumn  -----
  function NextColumn() result(Column)
    ! Args
    integer :: Column
    Column = atColumnNumber
  end function NextColumn

  ! ----------------------------------------------------  NextTab  -----
  function NextTab() result(Column)
    ! Args
    integer :: Column
    ! Internal variables
    integer :: nTab
    ! Executable
    Column = 0
    nTab = findFirst( tabStops > atColumnNumber )
    if ( nTab > 0 ) Column = max( tabStops(nTab), atColumnNumber )
  end function NextTab

  ! ----------------------------------------------------  numNeedsFormat  -----
  ! This family of functions return what format is needed to be printed by output
  function numNeedsFormat_double( value, inFormat ) result ( format )
    ! Args
    double precision, intent(in) :: VALUE
    character(len=*), optional, intent(in)  :: inFormat
    character(len=30) :: format
    ! Internal variables
    character(len=30) :: charValue
    character(len=2)  :: dotm
    character(len=30) :: ndotm
    integer :: I
    ! Executable
    call whatSDNeedsFormat( ndotm, dotm, inFormat )
    charValue = adjustl(numToChars ( value, format=ndotm ))
    ! call outputNamedValue( 'ndotm', ndotm )
    ! call outputNamedValue( 'charValue', charValue )
    i = len_trim(charValue)
    write(charValue, *) i+5
    format = '(1pg' // trim(adjustl(charValue)) // dotm // ')'
  end function numNeedsFormat_double

  function numNeedsFormat_integer( value, inFormat ) result ( format )
    ! Args
    integer, intent(in) :: VALUE
    character(len=*), optional, intent(in)  :: inFormat
    character(len=30) :: format
    ! Internal variables
    character(len=30) :: charValue
    integer :: I
    ! Executable
    charValue = numToChars(value)
    i = len_trim(charValue)
    write(charValue, *) i+5
    format = '(i' // trim(adjustl(charValue)) // ')'
  end function numNeedsFormat_integer

  function numNeedsFormat_single( value, inFormat ) result ( format )
    ! Args
    real, intent(in) :: VALUE
    character(len=*), optional, intent(in)  :: inFormat
    character(len=30) :: format
    ! Internal variables
    character(len=30) :: charValue
    character(len=2)  :: dotm
    character(len=30) :: ndotm
    integer :: I
    ! Executable
    call whatSDNeedsFormat( ndotm, dotm, inFormat )
    charValue = adjustl(numToChars ( value, format=ndotm ))
    i = len_trim(charValue)
    write(charValue, *) i+5
    format = '(1pg' // trim(adjustl(charValue)) // dotm // ')'
  end function numNeedsFormat_single

  function numNeedsFormat_complex( value, inFormat ) result ( format )
    ! Args
    integer, parameter :: RK = kind(0.0e0)
    complex(rk), intent(in) :: VALUE
    character(len=*), optional, intent(in)  :: inFormat
    character(len=45) :: format
    ! Internal variables
    character(len=30) :: charValue
    character(len=2)  :: dotm
    character(len=30) :: ndotm
    integer :: I
    ! Executable
    call whatSDNeedsFormat( ndotm, dotm, inFormat )
    charValue = adjustl(numToChars ( abs(value), format=ndotm ))
    i = len_trim(charValue)
    write(charValue, *) i+5
    format = '(1x,"(",1pg' // trim(adjustl(charValue)) // dotm // ',",",1pg' &
      & // trim(adjustl(charValue)) // dotm // ',")")'
  end function numNeedsFormat_complex

  function numNeedsFormat_dcomplx( value, inFormat ) result ( format )
    ! Args
    integer, parameter :: RK = kind(0.0d0)
    complex(rk), intent(in) :: VALUE
    character(len=*), optional, intent(in)  :: inFormat
    character(len=45) :: format
    ! Internal variables
    character(len=30) :: charValue
    character(len=2)  :: dotm
    character(len=30) :: ndotm
    integer :: I
    ! Executable
    call whatSDNeedsFormat( ndotm, dotm, inFormat )
    charValue = adjustl(numToChars ( abs(value), format=ndotm ))
    i = len_trim(charValue)
    write(charValue, *) i+5
    format = '(1x,"(",1pg' // trim(adjustl(charValue)) // dotm // ',",",1pg' &
      & // trim(adjustl(charValue)) // dotm // ',")")'
  end function numNeedsFormat_dcomplx

  ! ----------------------------------------------------  numToChars  -----
  ! This family of functions return what would otherwise be printed by output
  function numToChars_double( value, format ) result ( line )
    ! Args
    double precision, intent(in) :: VALUE
    character(len=*), intent(in), optional :: Format    ! How to print
    character(len=30) :: line
    ! Internal variables
    character(len=30) :: FormatSpec
    integer :: I, J, K
    ! Executable
    FormatSpec = outputOptions%sdFormatDefault
    if ( any( value == DPREFERDEFAULTFORMAT ) ) FormatSpec = '*'
    if ( present(Format)  ) then
      if ( format /= '*' ) FormatSpec = Format
    endif
    include 'numToChars.f9h'
  end function numToChars_double

  function numToChars_integer( value, format ) result ( line )
    ! Args
    integer, intent(in) :: VALUE
    character(len=*), intent(in), optional :: Format    ! How to print
    character(len=30) :: line
    ! Executable
    if ( present(Format)  ) then
      write( line, Format ) value
    else
      write( line, * ) value
    endif
    line = adjustl(line)
  end function numToChars_integer

  function numToChars_single( value, format ) result ( line )
    ! Args
    real, intent(in) :: VALUE
    character(len=*), intent(in), optional :: Format    ! How to print
    character(len=30) :: line
    ! Internal variables
    character(len=30) :: FormatSpec
    integer :: I, J, K
    ! Executable
    FormatSpec = outputOptions%sdFormatDefault
    if ( any( value == DPREFERDEFAULTFORMAT ) ) FormatSpec = '*'
    if ( present(Format)  ) then
      if ( format /= '*' ) FormatSpec = Format
    endif
    include 'numToChars.f9h'
  end function numToChars_single

  ! ---------------------------------------  OUTPUTCALENDAR  -----
  subroutine OUTPUTCALENDAR ( date, datenote, notes, dontWrap )
    ! output a nicely-formatted calendar of current month with
    ! today's date in "bold"
    ! Args
    character(len=*), intent(in), optional :: date ! date instead of current one
    ! dateNote, (notes), if present, is (an array of)
    ! stringLists, (one per day in the month,)
    character(len=*), optional :: dateNote ! Note for the current date
    ! Each string list contains either a blank for a date, meaning
    ! nothing will be printed in the calendar square for that date,
    ! or else it contains '/'-separated lines of text, each of
    ! which will be printed on a separate line within the square
    character(len=*), dimension(:), optional :: notes
    logical, optional                        :: dontWrap ! Dont wrap notes to fit
    ! Internal variables
    integer, parameter :: MAXNOTELENGTH = 256
    ! This should be modified for internationalization; e.g. with
    ! an include statement or suchlike
    character(len=*), dimension(12), parameter :: MONTHNAME = (/ &
      & 'January  ', 'February ', 'March    ', 'April    ', 'May      ', &
      & 'June     ', 'July     ', 'August   ', 'September', 'October  ', &
      & 'November ', 'December '/)

    character(len=*), dimension(7), parameter :: DAYSOFWEEK = (/ &
      & 'Sunday   ', 'Monday   ', 'Tuesday  ', 'Wednesday', 'Thursday ', &
      & 'Friday   ', 'Saturday '/)
    logical, parameter :: countEmpty = .true.
    character(len=1), parameter :: inseparator = '/'
    character(len=*), parameter :: utcformat = 'yyyy-mm-dd' ! 'yyyy-Doy'
    integer :: aday
    integer :: col1
    integer :: col2
    character(len=16) :: date2, dateString
    integer :: day
    integer, dimension(6,7) :: days, daysOfYear
    integer :: ErrTyp
    integer :: iwk
    integer :: month
    logical :: myDontWrap
    character(len=10) :: noteString
    integer :: numRows
    integer :: numWeeks
    integer :: row
    logical :: today
    integer :: wkdy
    character(len=MAXNOTELENGTH) :: wrappedNote
    integer :: year
    ! Executable
    myDontWrap = .false.
    if ( present(dontWrap) ) myDontWrap = dontWrap
    if ( present(date) ) then
      dateString = date
    else
      dateString = '' ! Intel 12 and earlier doesn't fill with blanks
      call date_and_time ( date=dateString )
    endif
    col1 = index(lowercase(dateString), 't')
    if ( col1 > 0 ) then
      date2 = dateString(1:col1-1)
       if ( nCopies(dateString(:col1-1), '-') < 2 ) &
        & date2 = reformatDate( dateString(1:col1-1), fromForm='yyyy-Doy', toForm=utcformat )
    else
      date2 = reformatDate( dateString, fromForm='*', toForm=utcformat )
    endif
    call utc_to_yyyymmdd( date2, ErrTyp, year, month, day )
    if ( month < 0 ) then
    endif
    call buildCalendar( year, month, days, daysOfYear )
    ! Temporary use of   w i d e  tabstops
    call settabs( '14-210+14' )
    call newline
    call alignToFit( trim(monthName(month)), (/ 1, 100 /), 'c', skips=1 )
    call newline
    col2 = 0
    do wkdy=1, 7
      col1 = col2 + 1
      col2 = tabStops(wkdy)
      call alignToFit( trim(daysOfWeek(wkdy)), (/ col1, col2 /), 'c' )
    enddo
    call newline
    numWeeks = 4
    if ( any( days(5,:) /= 0 ) ) numWeeks = 5
    if ( any( days(6,:) /= 0 ) ) numWeeks = 6
    ! How many rows will we need?
    numRows = 4
    if ( present(dateNote) ) then
      if ( myDontWrap ) then
        wrappedNote = dateNote
      else
        call wrap( dateNote, wrappedNote, 10, '/' )
      endif
      numRows = max( numRows, &
        & NumStringElements( wrappedNote, countEmpty, inseparator ) + 2 &
        & )
    endif
    if ( present(notes) ) then
      do aday=1, min( size(notes), daysInMonth( month, year ) )
        if ( myDontWrap ) then
          wrappedNote = notes(aday)
        else
          call wrap( notes(aday), wrappedNote, 10, '/' )
        endif
        numRows = max( numRows, &
          & NumStringElements( wrappedNote, countEmpty, inseparator ) + 2 &
          & )
      enddo
    endif
    do iwk = 1, numWeeks
      ! Start with horizontal line
      call blanksToTab( 7, fillChar='-' )
      call newline
      do row=1, numRows
        col2 = 0
        do wkdy=1, 7
          col1 = col2 + 1
          col2 = tabStops(wkdy)
          today = ( days(iwk, wkdy) == day )
          if ( today ) then
            call output_('||')
          else
            call output_('|')
          endif
          if ( days(iwk, wkdy) < 1 ) then
            ! Don't write notes or anything else in "empty" days
          elseif ( row == 1 ) then
            call writeIntsToChars( days(iwk, wkdy), dateString )
            dateString = adjustl(dateString)
            call alignToFit( trim(dateString), (/ col1, col2-1 /), 'r' )
          elseif( row == numRows ) then
            call writeIntsToChars( daysOfYear(iwk, wkdy), dateString )
            dateString = adjustl(dateString)
            call alignToFit( 'd' // trim(dateString), (/ col1, col2-1 /), 'r' )
          elseif( present(dateNote) .and. today ) then
            if ( myDontWrap ) then
              wrappedNote = dateNote
            else
              call wrap( dateNote, wrappedNote, 10, '/' )
            endif
            call GetStringElement ( wrappedNote, noteString, &
              & row-1, countEmpty, inseparator )
            if ( noteString == inseparator ) noteString = ' '
            call output_( noteString )
          elseif( present(notes) ) then
            if ( days(iwk, wkdy) <= size(notes) ) then
              if ( myDontWrap ) then
                wrappedNote = notes(days(iwk, wkdy))
              else
                call wrap( notes(days(iwk, wkdy)), wrappedNote, 10, '/' )
              endif
              call GetStringElement ( wrappedNote, noteString, &
                & row-1, countEmpty, inseparator )
              if ( noteString == inseparator ) noteString = ' '
              call output_( noteString )
            endif
          endif
          if ( today ) then
            call blanksToColumn(col2-1)
            call output_('|')
          else
            call blanksToTab
          endif
        enddo ! wkdy
        call output_('|')
        call newline
      enddo ! row
      ! begin with 
    enddo ! week
    call blanksToTab( 7, fillChar='-' )
    call newline
    ! Restore tabstops
    call settabs( '5-120+5' )
  end subroutine OUTPUTCALENDAR

a676 72
  ! ---------------------------------------  OUTPUT_DATE_AND_TIME  -----
  subroutine OUTPUT_DATE_AND_TIME ( date, time, &
    & from_where, msg, dateFormat, timeFormat, CPU_Seconds, advance )
    ! Output nicely-formatted date, time, and extra message
    ! We'll assume we won't want this line stamped with date and time
    ! (for fear of being redundant, which we fear)
    logical, intent(in), optional :: date ! output date as character string
    logical, intent(in), optional :: time ! output time as character string
    character(len=*), intent(in), optional :: FROM_WHERE
    character(len=*), intent(in), optional :: MSG
    character(len=*), intent(in), optional :: DATEFORMAT
    character(len=*), intent(in), optional :: TIMEFORMAT
    double precision, intent(in), optional :: CPU_Seconds
    character(len=*), intent(in), optional :: ADVANCE

    character(len=16) :: dateString
    logical, parameter :: DONT_STAMP = .true. ! Don't double-stamp
    integer :: HH, MM, MS, SS
    logical :: myDate
    logical :: myTime
    character(len=3) :: MY_ADV
    real :: My_CPU, Seconds
    character(len=16) :: timeString

    myDate = .true.
    if ( present(date) ) myDate = date
    myTime = .true.
    if ( present(time) ) myTime = time
    if ( .not. (myDate .or. myTime) ) return ! Why call if won't print?
    my_adv = 'no'
    if ( .not. present(msg) ) then
      my_adv = 'yes'
      if ( present(advance) ) my_adv = advance
    end if
    dateString = '' ! Intel 12 and earlier doesn't fill with blanks
    timeString = '' ! Intel 12 and earlier doesn't fill with blanks
    call date_and_time ( date=dateString, time=timeString )
    dateString = reFormatDate(trim(dateString), toForm=dateFormat)
    timeString = reFormatTime(trim(timeString), timeFormat)
    if ( myDate .and. myTime ) then
      call output_ ( trim(dateString), from_where=from_where, advance='no', &
        & DONT_STAMP=DONT_STAMP )
      call blanks(3)
      call output_ ( trim(timeString), from_where=from_where, advance=my_adv, &
        & DONT_STAMP=DONT_STAMP )
    else if ( myDate ) then
      call output_ ( trim(dateString), from_where=from_where, advance=my_adv, &
        & DONT_STAMP=DONT_STAMP )
    else if ( myTime ) then
      call output_ ( trim(TimeString), from_where=from_where, advance=my_adv, &
        & DONT_STAMP=DONT_STAMP )
    end if
    if ( .not. present(msg) ) return
    my_adv = 'yes'
    if ( present(advance) ) my_adv = advance
    call blanks ( 3 )
    call output_ ( trim(msg), from_where=from_where, &
      & advance=merge ( 'no ', my_adv, present(CPU_seconds) ), &
      & DONT_STAMP=DONT_STAMP )
    if ( present(CPU_seconds) ) then
      hh = CPU_seconds / 3600
      my_cpu = CPU_seconds - hh * 3600
      mm = my_cpu / 60
      seconds = my_cpu - mm * 60
      ss = seconds
      ms = nint(1000 * (seconds-ss))
      write ( timeString, '(2(i2.2,":"),i2.2,".",i3.3)' ) hh, mm, ss, ms
      call output_ ( '   CPU time ' // trim(timeString), from_where=from_where, &
        & advance=my_adv, DONT_STAMP=DONT_STAMP )
    end if
  end subroutine OUTPUT_DATE_AND_TIME

a952 159
  ! ----------------------------------------------  OUTPUTLIST  -----
  ! This family of routines outputs an array as a comma-separated list
  ! E.g., given the array (/ 1, 2, 3, .. /) outputs
  ! '(1, 2, 3, .. )'
  ! optionally using sep instead of ',' and delims instead of '()'
  subroutine OUTPUTLIST_CHARS ( array, sep, delims )
    ! Args
    character(len=*), dimension(:), intent(in)      :: array
    character(len=*), optional, intent(in) :: sep
    character(len=*), optional, intent(in) :: delims
    ! Local variables
    character(len=1) :: comma
    integer          :: i
    character(len=2) :: parens
    ! Executable
    if ( size(array) < 1 ) return
    comma = ','
    if ( present(sep) ) comma = sep
    parens = '()'
    if ( present(delims) ) parens = delims
    call output( parens(1:1) )
    do i=1, size(array)
      call output( trim_safe(array(i)) )
      if ( i < size(array) ) call output( comma )
    enddo
    call output( parens(2:2) )
  end subroutine OUTPUTLIST_CHARS

  subroutine OUTPUTLIST_INTS ( array, sep, delims )
    ! Args
    integer, dimension(:), intent(in)      :: array
    character(len=*), optional, intent(in) :: sep
    character(len=*), optional, intent(in) :: delims
    ! Local variables
    character(len=1) :: comma
    integer          :: i
    character(len=2) :: parens
    ! Executable
    if ( size(array) < 1 ) return
    comma = ','
    if ( present(sep) ) comma = sep
    parens = '()'
    if ( present(delims) ) parens = delims
    call output( parens(1:1) )
    do i=1, size(array)
      call output( array(i) )
      if ( i < size(array) ) call output( comma )
    enddo
    call output( parens(2:2) )
  end subroutine OUTPUTLIST_INTS

  ! ----------------------------------------------  outputNamedValue  -----
  ! This family of routines outputs a paired name and value
  ! (Basically saving you a few lines over the idiom
  !  call output ( trim(name), advance='no' )
  !  call output ( ': ', advance='no' )
  !  call output ( value, advance='yes' )
  
  ! to print following line to stdout
  !  name: value
  ! Optional args control
  ! before: what extra to print at start of each line
  ! after: what extra to print at end of each line
  ! colon: what to print instead of ':'
  ! fillChar: instead of spaces if you use tabs to align name, value
  ! tabn: column number where name begins
  ! tabc: column number where colon occurs
  ! taba: column number where after begins
  ! advance: whether to advance after printing pair (by default we WILL advance)
  ! dont_stamp: override setting to stamp end of each line
  ! By means of optional args you can create a line like
  ! *   name                   value   *
  subroutine output_nvp_character ( name, value, &
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
    character(len=*), intent(in)          :: name
    character(len=*), intent(in)          :: value
    include 'output_name_value_pair.f9h'
  end subroutine output_nvp_character

  subroutine output_nvp_complex ( name, value, &
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
    character(len=*), intent(in)          :: name
    complex, intent(in)                   :: value
    include 'output_name_value_pair.f9h'
  end subroutine output_nvp_complex

  subroutine output_nvp_double ( name, value, &
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
    character(len=*), intent(in)          :: name
    double precision, intent(in)                   :: value
    include 'output_name_value_pair.f9h'
  end subroutine output_nvp_double

  subroutine output_nvp_dbl_array ( name, value, &
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
    character(len=*), intent(in)          :: name
    double precision, dimension(:), intent(in)     :: value
    include 'output_name_value_pair.f9h'
  end subroutine output_nvp_dbl_array

  subroutine output_nvp_int_array ( name, value, &
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
    character(len=*), intent(in)          :: name
    integer, dimension(:), intent(in)     :: value
    include 'output_name_value_pair.f9h'
  end subroutine output_nvp_int_array

  subroutine output_nvp_integer ( name, value, &
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
    character(len=*), intent(in)          :: name
    integer, intent(in)                   :: value
    include 'output_name_value_pair.f9h'
  end subroutine output_nvp_integer

  subroutine output_nvp_log_array ( name, value, &
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
    character(len=*), intent(in)          :: name
    logical, dimension(:), intent(in)     :: value
    include 'output_name_value_pair.f9h'
  end subroutine output_nvp_log_array

  subroutine output_nvp_logical ( name, value, &
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
    character(len=*), intent(in)          :: name
    logical, intent(in)                   :: value
    include 'output_name_value_pair.f9h'
  end subroutine output_nvp_logical

  subroutine output_nvp_single ( name, value, &
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
    character(len=*), intent(in)          :: name
    real, intent(in)                      :: value
    include 'output_name_value_pair.f9h'
  end subroutine output_nvp_single

  subroutine output_nvp_sngl_array ( name, value, &
   & ADVANCE, colon, fillChar, Before, After, TABN, TABC, TABA, DONT_STAMP )
    character(len=*), intent(in)          :: name
    real, dimension(:), intent(in)     :: value
    include 'output_name_value_pair.f9h'
  end subroutine output_nvp_sngl_array

  ! ----------------------------------------------  resetTabs  -----
  ! Restore tab stops to what was in effect at start
  ! Optionally returning them as an integer array
  subroutine resetTabs ( tabs )
    ! Args
    integer, dimension(:), optional, intent(out) :: tabs
    ! Internal variables
    integer :: n
    ! Executable
    call setTabs( range=INITTABRANGE )
    if ( present(tabs) ) then
      n = min(size(tabs), MAXNUMTABSTOPS)
      tabs = 0
      tabs(1:n) = TABSTOPS(1:n)
    endif
  end subroutine resetTabs

a1033 42
  ! ----------------------------------------------  setStamp  -----
  subroutine setStamp ( textCode, showTime, dateFormat, timeFormat, &
    & post, interval )
  ! set stamp to be added to every output to PRUNIT.
    character(len=*), optional, intent(in) :: textCode
    logical, optional, intent(in)          :: showTime
    character(len=*), optional, intent(in) :: dateFormat
    character(len=*), optional, intent(in) :: timeFormat
    logical, optional, intent(in)          :: post
    integer, optional, intent(in)          :: interval
    if ( present(showTime) )   stampOptions%showTime   = showTime  
    if ( present(textCode) )   stampOptions%textCode   = textCode  
    if ( present(dateFormat) ) stampOptions%dateFormat = dateFormat
    if ( present(timeFormat) ) stampOptions%timeFormat = timeFormat
    if ( present(post) )       stampOptions%post       = post
    if ( present(interval) )   stampOptions%interval   = interval
  end subroutine setStamp

  ! ----------------------------------------------  setTabs  -----
  subroutine setTabs ( RANGE, TABS )
    ! Set tabstops
    ! Methods:
    ! (1) a string range; e.g., "8, 32-100+8"
    !     is converterd to "8, 32, 40, 48, 56, 64, 72, 80, 88, 96"
    ! (2) an arrays of ints; e.g., (/ 4, 9, 12, 18, 22, 30, 35, 40 /)
    ! (3) reset back to the defaults (equiv to "5-120+5")
    ! Args
    character(len=*), optional, intent(in)         :: Range
    integer, dimension(:), optional, intent(in)    :: Tabs
    ! Internal variables
    integer :: n
    ! Executable
    if ( present(range) ) then
      call ExpandStringRange ( range, TABSTOPS )
    elseif ( present(tabs) ) then
      n = min( MAXNUMTABSTOPS, size(tabs) )
      tabStops(1:n) = tabs(1:n) 
    else
      call ExpandStringRange ( '5-120+5', TABSTOPS )
    endif
  end subroutine setTabs

a1082 124
  ! ------------------------------------------------  timeStamp  -----
  ! time-stamp output on demand, not automatic:
  ! Either in style pre or post
  ! (pre) '(HH:MM:SS) chars'
  ! (post) 'chars (HH:MM:SS)'
  ! Note that in pre-style, the time will be printed only if ATLINESTART true
  ! in post-style, the time will be printed only if MY_ADV is 'yes'
  subroutine timeStamp_char ( CHARS, &
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, STYLE, DATE )
    character(len=*), intent(in) :: CHARS
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: FROM_WHERE
    logical, intent(in), optional          :: DONT_LOG ! Prevent double-logging
    character(len=*), intent(in), optional :: LOG_CHARS
    character(len=*), intent(in), optional :: INSTEADOFBLANK ! What to output
    character(len=8), intent(in), optional :: STYLE ! pre or post
    logical, intent(in), optional          :: DATE  ! Include date with time
    !
    logical, parameter :: DONT_STAMP = .true. ! Don't double-stamp
    character(len=8) :: my_style
    character(len=3) :: MY_ADV
    logical  ::         myDate
    !
    my_adv = Advance_is_yes_or_no(advance)
    my_style = timeStampOptions%Timestampstyle
    if ( present(style) ) my_style = lowercase(style)
    myDate = timeStampOptions%showDate
    if ( present(date) ) myDate = date
    if ( my_style == 'post' ) then
      call output_( CHARS, &
        & ADVANCE='no', FROM_WHERE=FROM_WHERE, DONT_LOG=DONT_LOG, &
        & LOG_CHARS=LOG_CHARS, INSTEADOFBLANK=INSTEADOFBLANK, DONT_STAMP=DONT_STAMP )
      if ( my_adv=='yes' ) then
        call output_(' (', ADVANCE='no', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
        call OUTPUT_DATE_AND_TIME( date=myDate, &
          & dateFormat=timeStampOptions%dateFormat, &
          & timeFormat=timeStampOptions%timeFormat, &
          & advance='no')
        call output_(')', ADVANCE='yes', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
      end if
    else
      if ( ATLINESTART ) then
        call output_('(', ADVANCE='no', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
        call OUTPUT_DATE_AND_TIME( date=myDate, &
          & dateFormat=timeStampOptions%dateFormat, &
          & timeFormat=timeStampOptions%timeFormat, &
          & advance='no')
        call output_(')', ADVANCE='no', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
      end if
      call output_( CHARS, &
        & ADVANCE, FROM_WHERE, DONT_LOG, &
        & LOG_CHARS, INSTEADOFBLANK, DONT_STAMP=DONT_STAMP )
    end if
  end subroutine timeStamp_char

  subroutine timeStamp_integer ( INT, &
    & PLACES, ADVANCE, FILL, FORMAT, Before, After, style, date )
    integer, intent(in) :: INT
    integer, intent(in), optional :: PLACES
    character(len=*), intent(in), optional :: ADVANCE
    logical, intent(in), optional :: FILL
    character(len=*), intent(in), optional :: FORMAT
    character(len=*), intent(in), optional :: Before, After ! text to print
    character(len=*), intent(in), optional :: style ! pre or post
    logical, intent(in), optional          :: DATE  ! Include date with time
    !
    logical, parameter :: DONT_STAMP = .true. ! Don't double-stamp
    character(len=8) :: my_style
    character(len=3) :: MY_ADV
    logical  ::         myDate
    !
    my_adv = Advance_is_yes_or_no(advance)
    my_style = timeStampOptions%Timestampstyle
    if ( present(style) ) my_style = lowercase(style)
    myDate = timeStampOptions%showDate
    if ( present(date) ) myDate = date
    if ( my_style == 'post' ) then
      call output_integer( INT, PLACES, &
        & ADVANCE='no', FILL=FILL, FORMAT=FORMAT, BEFORE=BEFORE, AFTER=AFTER, &
        & DONT_STAMP=DONT_STAMP )
      if ( my_adv=='yes' ) then
        call output_(' (', ADVANCE='no', DONT_STAMP=DONT_STAMP )
        call OUTPUT_DATE_AND_TIME( date=myDate, &
          & dateFormat=timeStampOptions%dateFormat, &
          & timeFormat=timeStampOptions%timeFormat, &
          & advance='no')
        call output_(')', ADVANCE='yes', DONT_STAMP=DONT_STAMP)
      end if
    else
      if ( ATLINESTART ) then
        call output_('(', ADVANCE='no', DONT_STAMP=DONT_STAMP)
        call OUTPUT_DATE_AND_TIME( date=myDate, &
          & dateFormat=timeStampOptions%dateFormat, &
          & timeFormat=timeStampOptions%timeFormat, &
          & advance='no')
        call output_(')', ADVANCE='no', DONT_STAMP=DONT_STAMP)
      end if
      call output_integer( INT, PLACES, &
        & ADVANCE, FILL, FORMAT, BEFORE, AFTER, DONT_STAMP=DONT_STAMP )
    end if
  end subroutine timeStamp_integer

  subroutine timeStamp_logical ( value, &
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, STYLE, DATE )
    logical, intent(in) ::                    value
    character(len=*), intent(in), optional :: ADVANCE
    character(len=*), intent(in), optional :: FROM_WHERE
    logical, intent(in), optional          :: DONT_LOG ! Prevent double-logging
    character(len=*), intent(in), optional :: LOG_CHARS
    character(len=*), intent(in), optional :: INSTEADOFBLANK ! What to output
    character(len=8), intent(in), optional :: STYLE ! pre or post
    logical, intent(in), optional          :: DATE  ! Include date with time
    ! Internal variables
    character(len=1) :: str
    ! Executable
    if ( value ) then
      str = 'T'
    else
      str = 'F'
    endif
    call timeStamp_char(str, &
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, STYLE, DATE )
  end subroutine timeStamp_logical

a1284 122
  ! .............................................  nCharsinFormat  .....
  function nCharsinFormat ( Format ) result(nplusm)
    ! Utility to calculate how many characters in a format spec:         
    ! [n{xX}][,]{DEFGdefg}m.b                                             
    ! where n, m, and b are digits (we care only about n and m)           
    ! return (n+m)
    ! Tested for specs: sci. format esm.b and eng. format enm.b
    ! Also for min. width spec: 'f0.b' it will silently return 0
    ! (It's up to you to handle that correctly)
    ! Args                                                                
    character(len=*), intent(in) ::  Format                               
    integer :: nplusm                                                     
    ! Local variables                                                     
    character(len=20) :: kChar, myFormat                                  
    integer :: n, m
    ! Executable                                                          
    nplusm = 0                                                            
    kChar=lowerCase(Format)
    call ourReplaceSubString(kChar, myFormat, 'es', 'f')                   
    call ourReplaceSubString(myFormat, kChar, 'en', 'f')                   
    call ourReplaceSubString(kChar, myFormat, 'g', 'f')                   
    call ourReplaceSubString(myFormat, kChar, 'e', 'f')                   
    call ourReplaceSubString(kChar, myFormat, 'd', 'f')                   
    call ourExtractSubString(TRIM(myFormat), kChar, 'f', '.')             
    if ( kChar == '0' ) return ! Special case of e.g. 'f0.3'
    read (kChar, '(i2)') m                                                
    if (m < 1) call myMessage ( MLSMSG_Error, ModuleName, &              
      & 'Bad conversion to m in OUTPUT_xxxLE (format not "{defg}"' )      
    if ( index(TRIM(myFormat), 'x' ) == 0 ) then                          
      n = 0                                                               
    else                                                                  
      call ourExtractSubString(TRIM(myFormat), kChar, '(', 'x')           
      read (kChar, '(i2)') n                                              
      if (n < 1) then                                                     
        print *, trim(kChar)                                              
        print *, trim(myFormat)                                           
        call myMessage ( MLSMSG_Error, ModuleName, &                     
          & 'Bad conversion to n in OUTPUT_xxxLE (format not "{defg}"' )  
      end if                                                              
    end if                                                                 
    nplusm = n + m                                                        
  end function nCharsinFormat

  ! ........................................  whatSDNeedsFormat
  ! parse inFormat which might be
  ! (1) absent, in which case format=sdNeedsFormat and dotm='.6'
  ! (2) '(*)', in which case format=sdNeedsFormat and dotm='.6'
  ! (3) '(*.m)', in which case format=(sdNeedsFragment //'.m') and dotm='.m'
  subroutine whatSDNeedsFormat ( format, dotm, inFormat )
    character(len=*), optional, intent(in)  :: inFormat
    character(len=*), intent(out)           :: format
    character(len=*), intent(out)           :: dotm
    integer :: dot
    if ( .not. present(inFormat) ) then
      format = sdNeedsFormat
      dotm = '.6'
    elseif ( index(inFormat, '.') < 1 ) then
      format = sdNeedsFormat
      dotm = '.6'
    else
      ! Must find integer after '.'
      dot = index( inFormat, '.' )
      dotm = inFormat(dot:dot+1)
      format = trim(sdNeedsFragment) // trim(dotm) // ')'
    endif
  end subroutine whatSDNeedsFormat
  ! ........................................  ourExtractSubString  .....
  subroutine ourExtractSubString ( instr, outstr, sub1, sub2 )
    ! Extract portion of instr between sub1 and sub2 and return as outstr
    ! Args
    character (len=*), intent(in) :: instr
    character (len=*), intent(out) :: outstr
    character (len=1), intent(in) :: sub1
    character (len=1), intent(in) :: sub2
    ! Internal variables
    integer :: pos1
    integer :: pos2
    ! Begin executable
    outstr = ''
    pos1 = index(instr, sub1) 
    if ( pos1 < 1 ) return
    pos2 = index(instr, sub2)
    if ( pos2-1 < pos1+1 ) return
    outstr = instr(pos1+1:pos2-1)
  end subroutine ourExtractSubString

  ! ........................................  ourReplaceSubString  .....
  subroutine ourReplaceSubString ( instr, outstr, sub1, sub2 )
    ! Swap a single instance in instr of sub1 with sub2 and return as outstr
    ! Args
    character (len=*), intent(in) :: instr
    character (len=*), intent(out) :: outstr
    character (len=*), intent(in) :: sub1
    character (len=*), intent(in) :: sub2
    ! Internal variables
    integer :: d
    integer :: pos
    integer :: pos1
    integer :: pos2
    integer :: pose
    ! Begin executable
    outstr = instr
    pos =index(instr, sub1) 
    if ( pos < 1 .or. pos > len_trim(outstr)) return
    pos1 = pos
    if ( len(sub1) == len(sub2) ) then
      pos2 = pos1 + len(sub1) - 1
      outstr(pos1:pos2) = sub2
    elseif ( len(sub1) > len(sub2) ) then
      d = len(sub1) - len(sub2)
      pos2 = pos1 + len(sub2) - 1
      outstr(pos1:pos2) = sub2
      pose = min(len(instr), len(outstr))
      if ( pos2 == pose ) return
      outstr(pos2+1:) = ' '   ! To fill to the end with blanks
      outstr(pos2+1:pose) = instr(pos2+1+d:pose+d)
    else
      call myMessage ( MLSMSG_Error, ModuleName, &              
      & 'Not yet able to replace shorter substring with longer' ) 
    end if
  end subroutine ourReplaceSubString

a1324 20
  ! ----------------------------------------------  stretch  -----
  function stretch( arg, skips ) result(chars)
  ! stretch input arg by inserting skips number of spaces
  ! between each pair of consecutive characters
  ! Args
    character(len=*), intent(in)      :: arg
    integer, intent(in)               :: skips
    character(len=(1+skips)*len(arg)) :: chars
    ! Internal variables
    integer :: i, k
    ! Executable
    chars = ' '
    if ( len_trim(arg) < 1 ) return
    do i=1, len_trim(arg)
      ! E.g., if skips==1, k ~ 1 3 5 7 ..
      k = 1 + (skips+1)*(i-1)
      chars(k:k) = arg(i:i)
    enddo
  end function stretch

d1369 1
a1369 1
       "$Id: output_m.f90,v 2.108 2013/11/04 22:53:51 pwagner Exp $"
d1379 3
@


2.108
log
@Added beVerbose, letsDebug
@
text
@d303 1
a303 1
    character(len=12) :: parentName = "$RCSfile: output_m.f90,v $"
d349 2
d1510 2
d1698 1
d1870 1
a1870 9
      if ( i < size(values) ) then
        if ( len_trim(outputOptions%arrayElmntSeparator) > 0 ) &
          & call output_( outputOptions%arrayElmntSeparator, advance='no' )
        if ( mod(i, outputOptions%nArrayElmntsPerLine) == 0 ) then
          call output_ ( '', advance='yes', DONT_STAMP=.true. )
        else
          call blanks ( outputOptions%nBlanksBtwnElmnts, advance='no' )
        endif
      endif
d1945 1
a1945 9
      if ( i < size(integers) ) then
        if ( len_trim(outputOptions%arrayElmntSeparator) > 0 ) &
          & call output_( outputOptions%arrayElmntSeparator, advance='no' )
        if ( mod(i, outputOptions%nArrayElmntsPerLine) == 0 ) then
          call output_ ( '', advance='yes', DONT_STAMP=.true. )
        else
          call blanks ( outputOptions%nBlanksBtwnElmnts, advance='no' )
        endif
      endif
d1999 1
a1999 9
      if ( i < size(logs) ) then
        if ( len_trim(outputOptions%arrayElmntSeparator) > 0 ) &
          & call output_( outputOptions%arrayElmntSeparator, advance='no' )
        if ( mod(i, outputOptions%nArrayElmntsPerLine) == 0 ) then
          call output_ ( '', advance='yes', DONT_STAMP=.true. )
        else
          call blanks ( outputOptions%nBlanksBtwnElmnts, advance='no' )
        endif
      endif
d2049 1
a2049 9
      if ( i < size(values) ) then
        if ( len_trim(outputOptions%arrayElmntSeparator) > 0 ) &
          & call output_( outputOptions%arrayElmntSeparator, advance='no' )
        if ( mod(i, outputOptions%nArrayElmntsPerLine) == 0 ) then
          call output_ ( '', advance='yes', DONT_STAMP=.true. )
        else
          call blanks ( outputOptions%nBlanksBtwnElmnts, advance='no' )
        endif
      endif
d2142 1
d2148 2
d2533 1
a2533 2
  ! Internal procedures
  
d2614 24
d2961 1
a2961 1
       "$Id: output_m.f90,v 2.107 2013/09/12 01:56:50 vsnyder Exp $"
d2971 3
@


2.107
log
@Change f6.1 format to f8.1 format in DumpSize_Double
@
text
@d25 2
a26 1
  use MLSCOMMON, only: FILENAMELEN, FINITE_SIGNAL, IS_WHAT_IEEE
d29 1
a29 1
    & LIST2ARRAY, NUMSTRINGELEMENTS, WRAP
d37 1
d66 1
d78 1
d104 1
d120 1
d189 1
a189 1
  public :: ALIGNTOFIT, BANNER, BLANKS, BLANKSTOCOLUMN, BLANKSTOTAB, &
d191 1
a191 1
    & NEXTCOLUMN, NEXTTAB, NEWLINE, NUMNEEDSFORMAT, NUMTOCHARS, &
d615 9
d1065 9
d2962 1
a2962 1
       "$Id: output_m.f90,v 2.106 2013/08/28 00:35:39 pwagner Exp $"
d2972 3
@


2.106
log
@Moved more stuff from MLSMessage down to PrintIt module
@
text
@d881 1
a881 1
      write ( howMuch, '(f6.1)' ) amount
d2938 1
a2938 1
       "$Id: output_m.f90,v 2.105 2013/08/23 02:51:04 vsnyder Exp $"
d2948 3
@


2.105
log
@Move PrintItOut to PrintIt_m
@
text
@d24 1
a25 1
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_INFO, MLSMSG_ERROR
d31 5
d1504 3
a1506 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & trim('Unable to flush prUnit ' // outputOptions%name) )
d1570 1
a1570 1
        call MLSMessage ( outputOptions%MLSMSG_Level, from_where, &
d1574 1
a1574 1
        call MLSMessage ( outputOptions%MLSMSG_Level, &
d1579 1
a1579 1
        call MLSMessage ( outputOptions%MLSMSG_Level, &
d1615 1
a1615 1
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d2072 1
a2072 1
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d2615 97
d2738 1
a2738 1
    if (m < 1) call MLSMessage ( MLSMSG_Error, ModuleName, &              
d2748 1
a2748 1
        call MLSMessage ( MLSMSG_Error, ModuleName, &                     
d2829 1
a2829 1
      call MLSMessage ( MLSMSG_Error, ModuleName, &              
d2938 1
a2938 1
       "$Id: output_m.f90,v 2.104 2013/08/12 23:47:25 pwagner Exp $"
d2948 3
@


2.104
log
@FindSomethings moved to MLSFinds module
@
text
@d25 1
a25 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, &
    & DEFAULTLOGUNIT, MLSMESSAGECONFIG, MLSMSG_INFO, MLSMSG_ERROR, STDOUTLOGUNIT
d2235 1
d2279 2
a2280 7
    if ( useToolkit ) then
      mlsmessageConfig%useToolkit   = .true.
      mlsmessageConfig%logFileUnit  = DEFAULTLOGUNIT
    else
      mlsmessageConfig%useToolkit   = .false.
      mlsmessageConfig%logFileUnit  = STDOUTLOGUNIT
    endif
d2835 1
a2835 1
       "$Id: output_m.f90,v 2.103 2013/07/18 22:34:31 pwagner Exp $"
d2845 3
@


2.103
log
@Avoid double-printing when prUnit > 0
@
text
@d27 1
a27 1
  use MLSSETS, only: FINDFIRST
d2840 1
a2840 1
       "$Id: output_m.f90,v 2.102 2013/07/13 00:01:09 vsnyder Exp $"
d2850 3
@


2.102
log
@Remove old comments about how unbuffering was done
@
text
@d1460 1
d1476 2
a1477 1

d1526 1
d1540 2
d1594 1
a1594 1
    if ( outputOptions%prunit <= 0  ) then
d2840 1
a2840 1
       "$Id: output_m.f90,v 2.101 2013/06/28 17:53:44 pwagner Exp $"
d2850 3
@


2.101
log
@logParent, parentName added to show who called output module
@
text
@a1491 10
    ! If so, note the following decision and its effects:
    ! we will close and reopen for append our output file
    ! not at the beginning of a write to a fresh line
    ! but at the end of a write to the previous line.

    ! If, in the middle, we switch output files, say from file1 to file2,
    ! it's possible that a line that should have been the last written
    ! to file1 will instead be written to file2. 
    ! That's the downside.

d2835 1
a2835 1
       "$Id: output_m.f90,v 2.100 2013/06/14 01:26:11 vsnyder Exp $"
d2845 3
@


2.100
log
@Use FLUSH to unbuffer output
@
text
@d273 1
d293 1
a612 2
    character(len=*), parameter :: BLANKSPACE = &
    '                                                                    '
a675 2
    character(len=*), parameter :: BLANKSPACE = &
    '                                                                    '
d730 2
d1570 7
a1576 1
        call MLSMessage ( outputOptions%MLSMSG_Level, from_where, my_chars(1:n_chars), &
d1579 3
a1581 1
        call MLSMessage ( outputOptions%MLSMSG_Level, ModuleName, my_chars(1:n_chars), &
a1837 1
    character(len=3) :: MY_ADV
a1838 1
    my_adv = Advance_is_yes_or_no(advance)
a1920 1
    character(len=3) :: MY_ADV
a1921 1
    my_adv = Advance_is_yes_or_no(advance)
a2041 2
    character(len=3) :: MY_ADV
    my_adv = Advance_is_yes_or_no(advance)
d2249 1
a2431 1
    logical :: my_dont_log
a2436 2
    my_dont_log = outputOptions%skipmlsmsglogging ! .false.
    if ( present(dont_log) ) my_dont_log = dont_log
d2845 1
a2845 1
       "$Id: output_m.f90,v 2.99 2013/04/17 00:03:44 pwagner Exp $"
d2855 3
@


2.99
log
@Removed LINE_WIDTH; comments note possible solution to unwieldy module
@
text
@d170 6
a272 1
    logical :: OPENED              = .false.
d1451 1
d1474 2
a1475 1
    !
d1485 6
d1505 1
a1505 2
      & outputOptions%prUnit > 0 .and. &
      & (.not. outputOptions%opened) .and. &
d1507 1
a1507 2
      open (outputOptions%prUnit, file=trim(outputOptions%name), status='replace', &
        & form='formatted', access='sequential', iostat=status )
d1509 1
a1509 2
        & 'Unable to reopen prUnit for replace ' // trim(outputOptions%name) )
      outputOptions%opened = .true.
d1534 1
a1534 2
    if ( any(outputOptions%prunit == (/STDOUTPRUNIT, BOTHPRUNIT/)) .and. &
      &  n_stamp > RECLMAX ) then
d1540 1
a1540 1
        write ( *, '(a)', advance='no' ) stamped_chars(i1:i2)
d1542 5
a1546 7
      if ( my_adv == 'yes' ) write ( *, '(a)', advance=my_adv ) ' '
    elseif ( any(outputOptions%prunit == (/STDOUTPRUNIT, BOTHPRUNIT/)) .and. &
      &  len(chars) < 1 .and. my_adv == 'yes' ) then
      write ( *, '(a)', advance=my_adv )
    elseif ( any(outputOptions%prunit == (/STDOUTPRUNIT, BOTHPRUNIT/)) .and. &
      &  n_stamp > 0 ) then
      write ( *, '(a)', advance=my_adv ) stamped_chars(1:n_stamp)
d1605 2
a1606 7
      if ( (.not. outputOptions%buffered) .and. &
        & outputOptions%prUnit > 0 .and. &
        & outputOptions%opened ) then
        close(outputOptions%prUnit)
        open (outputOptions%prUnit, file=trim(outputOptions%name), status='old', &
          & position='append', &
          & form='formatted', access='sequential', iostat=status )
d1608 1
a1608 1
          & 'Unable to reopen prUnit for append ' // trim(outputOptions%name) )
d1614 2
a1615 4
        if ( any(outputOptions%prunit == (/STDOUTPRUNIT, BOTHPRUNIT/)) ) then
          write ( *, '(a)', advance='yes' ) trim(stamped_chars)
        elseif( outputOptions%prunit > 0 ) then
          write ( outputOptions%prunit, '(a)', advance='yes' ) trim(stamped_chars)
a2245 1
    outputOptions%OPENED               = .false.
d2845 1
a2845 1
       "$Id: output_m.f90,v 2.98 2013/02/04 21:57:06 pwagner Exp $"
d2855 3
@


2.98
log
@Fixed bug sending invalidPRUnit output to stderr
@
text
@d15 6
a20 1
  ! see also dump_0 and MLSMessageModule
a161 2
  integer, save, public :: LINE_WIDTH = 120 ! Not used here, but a convenient
                                            ! place to store it
d186 1
a186 1
  interface aligntofit
d191 1
a191 1
  interface banner
d204 1
a204 1
  interface getOption
d236 1
a236 1
  interface outputNamedValue
d256 1
a256 1
  character(len=MAXOUTPUTLINESLEN), public, save     :: outputLines = ' '
d289 1
a289 1
  type(outputOptions_T), public, save :: outputOptions
d309 1
a309 1
  type(stampOptions_T), public, save :: stampOptions ! Could leave this private
d311 1
a311 1
  ! This is the type for configuring how timeStamp stamps only individual lines)
d322 1
a322 1
  type(timeStampOptions_T), public, save :: timeStampOptions ! Could leave this private
d2846 1
a2846 1
       "$Id: output_m.f90,v 2.97 2012/09/11 18:52:26 pwagner Exp $"
d2856 3
@


2.97
log
@Added isOutputSuspended
@
text
@d21 1
a21 1
    & MLSMSG_INFO, MLSMSG_ERROR
d34 2
a35 1
! outputLines              If PrUnit = OUTPUTLINESPRUNIT, holds output until flushed
d51 4
a54 1
! banner                   surround message with stars and stripes
d64 2
a65 1
! isOutputSuspended         returns TRUE if output is suspended
d129 1
a129 1
! restoreSettings
d1538 2
a1539 1
    if ( any(outputOptions%prunit == (/MSGLOGPRUNIT, BOTHPRUNIT/)) .and. .not. my_dont_log  ) then
d1581 1
a1581 1
    if ( outputOptions%prunit < 0  ) then
d2233 1
a2233 1
  subroutine restoreSettings 
d2235 2
d2278 8
d2843 1
a2843 1
       "$Id: output_m.f90,v 2.96 2012/08/16 17:36:30 pwagner Exp $"
d2853 3
@


2.96
log
@Removed more unused stuff
@
text
@d60 1
d100 1
d317 1
a317 1
  logical, save, private:: SILENTRUNNING = .false. ! Suspend all further output
d1027 6
d2827 1
a2827 1
       "$Id: output_m.f90,v 2.95 2012/08/07 18:01:22 pwagner Exp $"
d2837 3
@


2.95
log
@output simply prints tab character as is instead of as '@@'
@
text
@d20 1
a20 1
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMESSAGEINTERNALFILE, &
a974 1
    integer :: addedLines
d978 1
a978 1
    integer :: lineLen, mySkips,  rightpadding
d2819 1
a2819 1
       "$Id: output_m.f90,v 2.94 2012/08/02 21:09:53 pwagner Exp $"
d2829 3
@


2.94
log
@Added RestoreSettings
@
text
@d1401 1
a1401 1
        call OUTPUT_CHAR_NOCR ( ReplaceNonAscii(CHARS, '@@'), &
d1411 1
a1411 1
            call OUTPUT_CHAR_NOCR ( ReplaceNonAscii(CHARS(i:i), '@@'), &
d2820 1
a2820 1
       "$Id: output_m.f90,v 2.93 2012/08/01 00:08:21 pwagner Exp $"
d2830 3
@


2.93
log
@Uses same . . pattern in option dumps
@
text
@d69 1
d122 1
d168 1
a168 1
    & RESETTABS, RESUMEOUTPUT, REVERTOUTPUT, &
d251 1
a251 1
    integer :: PRUNIT = -1               ! Unit for output (see comments above).  
d289 2
a290 2
    logical :: post = .true.      ! Put stamp at end of line?
    logical :: showTime = .false. ! Don't show date or time unless TRUE
d2219 46
d2820 1
a2820 1
       "$Id: output_m.f90,v 2.92 2012/07/18 00:33:45 pwagner Exp $"
d2830 3
@


2.92
log
@Fixed bug causing double printing
@
text
@d694 1
a694 1
    character(len=1), parameter :: fillChar = '.' ! fill blanks with '. .'
d2772 1
a2772 1
       "$Id: output_m.f90,v 2.91 2012/07/17 16:38:01 pwagner Exp $"
d2782 3
@


2.91
log
@OutputLines mechanism introduced to defer printing; new HeadLine subroutine
@
text
@d1507 1
a1507 1
    if ( any(outputOptions%prunit == (/STDOUTPRUNIT, MSGLOGPRUNIT/)) .and. &
d1517 1
a1517 1
    elseif ( any(outputOptions%prunit == (/STDOUTPRUNIT, MSGLOGPRUNIT/)) .and. &
d1520 1
a1520 1
    elseif ( any(outputOptions%prunit == (/STDOUTPRUNIT, MSGLOGPRUNIT/)) .and. &
d2772 1
a2772 1
       "$Id: output_m.f90,v 2.90 2012/06/22 00:04:02 pwagner Exp $"
d2782 3
@


2.90
log
@May now change default advance option to 'yes'
@
text
@d34 1
d39 4
a42 3
!                          -2 :: logged via MLSMessage
!                          -1 :: print stdout
!                          < -2 :: both
d57 1
d59 1
d92 1
d95 3
d149 1
a149 1
                                         ! place to store it
d151 7
d162 2
a163 2
    & DUMP, DUMPSIZE, DUMPTABS, &
    & GETSTAMP, NEXTCOLUMN, NEXTTAB, NEWLINE, NUMNEEDSFORMAT, NUMTOCHARS, &
d192 4
d205 1
d241 5
d249 1
a249 5
    integer :: PRUNIT = -1               ! Unit for output.  
                                         ! -1 means "printer" unit, *
                                         ! -2 means MLSMessage if 
                                         ! < -2, both printer and MLSMSG
                                         ! > 0, actual unit number
d272 1
a272 1
    character(len=3)  :: advanceDefault = 'no' ! what to assume if advance=.. missing
d697 3
a699 3
    call blanks(70, fillChar='-', advance='yes')
    call output_(' -------------- Summary of output options'      , advance='no')
    call output_(' -------------- ', advance='yes')
d701 6
a706 1
      & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d708 1
a708 1
      & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d710 1
a710 1
      & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d712 1
a712 1
      & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d714 1
a714 1
      & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d716 1
a716 1
      & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d718 1
a718 1
      & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d720 1
a720 1
      & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d722 1
a722 1
      & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d740 23
a762 1
    call blanks(70, fillChar='-', advance='yes')
d770 3
a772 3
     call blanks(70, fillChar='-', advance='yes')
     call output_(' -------------- Summary of automatic stamp options'      , advance='no')
     call output_(' -------------- ', advance='yes')
d774 1
a774 1
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d776 7
a782 7
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
     call outputNamedValue ( 'extra text', trim(options%textCode), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
     call outputNamedValue ( 'date format', trim(options%dateFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
     call outputNamedValue ( 'time format', trim(options%timeFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d784 4
a787 4
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
     call outputNamedValue ( 'style of timeStamps', trim(options%timestampstyle), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
     call blanks(70, fillChar='-', advance='yes')
d795 3
a797 3
     call blanks(70, fillChar='-', advance='yes')
     call output_(' -------------- Summary of time stamp options'      , advance='no')
     call output_(' -------------- ', advance='yes')
d799 1
a799 1
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d801 10
a810 10
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
     call outputNamedValue ( 'extra text', trim(options%textCode), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
     call outputNamedValue ( 'date format', trim(options%dateFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
     call outputNamedValue ( 'time format', trim(options%timeFormat), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
     call outputNamedValue ( 'style of timeStamps', trim(options%timestampstyle), advance='yes', &
       & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
     call blanks(70, fillChar='-', advance='yes')
d911 29
d958 66
d1507 1
a1507 1
    if ( (outputOptions%prunit == -1 .or. outputOptions%prunit < -2) .and. &
d1517 1
a1517 1
    elseif ( (outputOptions%prunit == -1 .or. outputOptions%prunit < -2) .and. &
d1520 1
a1520 1
    elseif ( (outputOptions%prunit == -1 .or. outputOptions%prunit < -2) .and. &
d1524 2
a1525 1
    if ( outputOptions%prunit < -1 .and. .not. my_dont_log  ) then
d1551 13
d1594 1
a1594 1
        if ( outputOptions%prunit == -1 .or. outputOptions%prunit < -2 ) then
d1608 21
d2472 8
d2487 1
d2495 2
d2506 40
d2772 1
a2772 1
       "$Id: output_m.f90,v 2.89 2012/04/20 01:27:14 vsnyder Exp $"
d2782 3
@


2.89
log
@Add CPU_Seconds to Output_Date_and_Time
@
text
@d251 1
d2303 1
a2303 1
      outstr = 'no'
d2543 1
a2543 1
       "$Id: output_m.f90,v 2.88 2011/08/11 22:24:59 pwagner Exp $"
d2553 3
@


2.88
log
@Added banner to set off message with stars and stripes
@
text
@d102 2
a103 1
!          [char* msg], [char* dateFormat], [char* timeFormat], [char* advance] )
d1498 1
a1498 1
    & from_where, msg, dateFormat, timeFormat, advance )
d1508 1
d1510 1
a1510 1
    !
d1513 1
a1513 1
    character(len=16) :: timeString
d1517 3
a1519 1
    !
d1552 2
a1553 1
    call output_ ( trim(msg), from_where=from_where, advance=my_adv, &
d1555 11
d2542 1
a2542 1
       "$Id: output_m.f90,v 2.87 2011/07/12 00:12:25 pwagner Exp $"
d2552 3
@


2.87
log
@Added numNeedsFormat
@
text
@d24 1
a24 1
    & NUMSTRINGELEMENTS, WRAP
d48 1
d79 1
d145 1
a145 1
  public :: ALIGNTOFIT, BLANKS, BLANKSTOCOLUMN, BLANKSTOTAB, &
d163 5
d437 126
d2526 1
a2526 1
       "$Id: output_m.f90,v 2.86 2011/05/26 20:38:32 pwagner Exp $"
d2536 3
@


2.86
log
@By default, outputting chars substitutes for non-ascii, except for newlines
@
text
@d56 1
d89 1
d145 1
a145 1
    & GETSTAMP, NEXTCOLUMN, NEXTTAB, NEWLINE, NUMTOCHARS, &
d169 5
d304 2
d770 95
d2210 23
d2393 1
a2393 1
       "$Id: output_m.f90,v 2.85 2011/04/29 02:16:32 vsnyder Exp $"
d2403 3
@


2.85
log
@Prefill dateString and timeString with blanks to compensate for Intel bug
@
text
@d17 10
a26 10
  use dates_module, only:  buildCalendar, daysInMonth, &
    & reformatDate, reformatTime, utc_to_yyyymmdd
  use MLSCommon, only: FileNameLen, finite_signal, is_what_ieee
  use MLSMessageModule, only: MLSMessage, MLSMessageInternalFile, &
    & MLSMSG_Info, MLSMSG_Error
  use MLSSets, only: FindFirst
  use MLSStringLists, only: ExpandStringRange, getStringElement, &
    & NumStringElements, wrap
  use MLSStrings, only: lowerCase, nCopies, &
    & readIntsFromChars, trim_safe, writeIntsToChars
d215 1
a215 1
    integer :: newLineVal          = 13 ! 13 means <cr> becomes new line; -999 means ignore
d989 1
a989 1
    & NEWLINEVAL )
d1004 1
d1008 1
d1012 2
d1016 7
a1022 2
      call OUTPUT_CHAR_NOCR ( CHARS, &
        & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, DONT_STAMP )
d1026 11
a1036 4
          call OUTPUT_CHAR_NOCR ( CHARS(i:i), &
        & ADVANCE='no', FROM_WHERE=FROM_WHERE, DONT_LOG=DONT_LOG, &
        & LOG_CHARS=LOG_CHARS, INSTEADOFBLANK=INSTEADOFBLANK, &
        & DONT_STAMP=DONT_STAMP )
d2266 1
a2266 1
       "$Id: output_m.f90,v 2.84 2011/03/12 00:39:31 vsnyder Exp $"
d2276 3
@


2.84
log
@Change len=1 to len=* to avoid Intel checking problem
@
text
@d865 1
d1273 2
d2217 2
d2250 1
a2250 1
       "$Id: output_m.f90,v 2.83 2010/10/14 18:43:02 pwagner Exp $"
d2260 3
@


2.83
log
@Can now dump and reset tabs; also can outputlists
@
text
@d427 1
a427 1
    character(len=1), intent(in), optional :: FILLCHAR  ! default is ' '
d492 1
a492 1
    character(len=1), intent(in), optional :: FILLCHAR  ! default is ' '
d507 1
a507 1
    character(len=1), intent(in), optional :: FILLCHAR  ! default is ' '
d2149 1
a2149 1
    character(len=1), intent(in), optional :: FILLCHAR  ! default is ' '
d2245 1
a2245 1
       "$Id: output_m.f90,v 2.82 2010/02/04 23:08:00 vsnyder Exp $"
d2255 3
@


2.82
log
@Remove USE or declaration for unused names
@
text
@d53 1
d60 1
d62 1
d84 1
d101 1
d105 1
d141 2
a142 1
  public :: ALIGNTOFIT, BLANKS, BLANKSTOCOLUMN, BLANKSTOTAB, DUMP, DUMPSIZE, &
d144 3
a146 2
    & OUTPUT, OUTPUT_DATE_AND_TIME, OUTPUTCALENDAR, OUTPUTNAMEDVALUE, &
    & RESUMEOUTPUT, REVERTOUTPUT, &
d185 4
d286 1
d701 18
d1610 51
d1749 17
d2245 1
a2245 1
       "$Id: output_m.f90,v 2.81 2010/01/26 17:49:42 pwagner Exp $"
d2255 3
@


2.81
log
@Fixed bug that added space before newlines; simplified output_char
@
text
@d22 1
a22 1
  use MLSSets, only: FindAll, FindFirst
d2146 1
a2146 1
       "$Id: output_m.f90,v 2.80 2009/06/24 22:35:44 pwagner Exp $"
d2156 3
@


2.80
log
@Trick to pass places arg into output via format arg
@
text
@d25 2
a26 1
  use MLSStrings, only: lowerCase, nCopies, readIntsFromChars, writeIntsToChars
d48 3
a50 3
! blanks                   "print" specified number of blanks [or fill chars]
! blanksToColumn           "print" blanks [or fill chars] out to specified column
! blanksToTab              "print" blanks [or fill chars] out to next tab stop
a972 1
    integer :: how_many
a973 1
    integer :: lastCR
a974 1
    integer, dimension(len(chars)) :: which
d978 2
a979 4
    call FindAll( chars, achar(myNewLineVal), which, how_many=how_many )
    ! print *, 'how many? ', how_many
    ! print *, 'which? ', (which(i), i=1, how_many)
    if ( how_many < 1 ) then
d983 3
a985 15
      ! Yes, this complicated (more work needed to simplify)
      ! Find which locations are <cr>
      ! Then call output for the stretches of chars in between
      ! Instead of printing <cr>, call newLine
      
      ! A much simpler alternative would simply loop over all the chars, calling
      ! output_char unless the char in question was a <cr> when
      ! we would instead call newLine
      
      ! We may switch to this alternative
      ! One advantage: we would not need the automatic array 'which'
      lastCR = 0
      do i=1, how_many
        if ( which(i) > lastCR+1 .and. which(i) < len(chars)+1 ) then
          call OUTPUT_CHAR_NOCR ( CHARS(lastCR+1:which(i)-1), &
d989 2
a991 2
        call newLine
        lastCR = which(i)
d993 1
a993 5
      if ( lastCR < len(chars) ) &
        & call OUTPUT_CHAR_NOCR ( CHARS(lastCR+1:), &
        & ADVANCE=ADVANCE, FROM_WHERE=FROM_WHERE, DONT_LOG=DONT_LOG, &
        & LOG_CHARS=LOG_CHARS, INSTEADOFBLANK=INSTEADOFBLANK, &
        & DONT_STAMP=DONT_STAMP )
d1125 3
a1127 1
      write ( outputOptions%prunit, '(a)', advance=my_adv ) trim(insteadofblank)
d2146 1
a2146 1
       "$Id: output_m.f90,v 2.79 2009/06/23 18:25:43 pwagner Exp $"
d2156 3
@


2.79
log
@Prevent Intel from optimizing ident string away
@
text
@d25 1
a25 1
  use MLSStrings, only: lowerCase, nCopies, writeIntsToChars
d286 1
a286 1
       "$RCSfile: $"
d1374 5
d1391 1
d1396 8
a1403 1
    if ( present(format)  ) then
d2164 1
a2164 1
       "$Id: read_apriori.f90 is it here $"
d2174 3
@


2.78
log
@With outputOptions may make outputted arrays look like text Climatology file
@
text
@d286 1
a286 1
       "$RCSfile: output_m.f90,v $"
d2148 1
a2149 1
!---------------------------- RCS Ident Info -------------------------------
d2151 2
a2152 3
       "$Id: output_m.f90,v 2.77 2009/05/14 22:00:28 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2154 1
a2154 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d2156 1
d2161 3
@


2.77
log
@New optional arg onlyif prints logicals only if true (false)
@
text
@d201 8
a208 6
    integer :: MLSMSG_Level = MLSMSG_Info ! What level if logging
    integer :: newLineVal = 13 ! 13 means <cr> becomes new line; -999 means ignore
    logical :: BUFFERED = .true.
    logical :: OPENED = .false.
    logical :: SKIPMLSMSGLOGGING = .false.
    logical :: usePatternedBlanks = .true. ! Use patterns for special fillChars
d224 1
d1118 4
a1121 2
        n_chars = len_trim(log_chars) + 1
        the_chars = log_chars(:n_chars-1) // ' '
d1325 1
a1325 1
    log_chars = line
d1353 9
a1361 1
      call blanks ( 3, advance='no' )
d1425 9
a1433 1
      call blanks ( 3, advance='no' )
d1487 9
a1495 1
        call blanks ( 3, advance='no' )
d1520 1
a1520 2

    log_chars = line
d1547 9
a1555 1
      call blanks ( 3, advance='no' )
d2151 1
a2151 1
       "$Id: output_m.f90,v 2.76 2008/11/24 19:29:43 pwagner Exp $"
d2161 3
@


2.76
log
@Added a print to not_used_here
@
text
@d1437 1
a1437 1
  subroutine OUTPUT_LOGICAL_ARRAY ( logs, ADVANCE, BEFORE, DONT_STAMP )
d1443 4
d1448 2
d1451 18
a1468 4
    do i = 1, size(logs)
      call output ( logs(i), advance='no' )
      call blanks ( 3, advance='no' )
    end do
d2115 1
a2115 1
       "$Id: output_m.f90,v 2.75 2008/10/17 00:04:22 pwagner Exp $"
d2125 3
@


2.75
log
@NewLine should not add space at line end when output to named file
@
text
@d2095 1
a2095 1
       "$Id: output_m.f90,v 2.74 2008/06/17 00:01:53 pwagner Exp $"
d2099 1
d2105 3
@


2.74
log
@Separate options for auto and manual time stamping
@
text
@d1141 2
d2095 1
a2095 1
       "$Id: output_m.f90,v 2.73 2008/05/02 00:07:20 pwagner Exp $"
d2104 3
@


2.73
log
@Correctly handles some rare cases, newLine wont add extra space
@
text
@d43 1
a43 3
! (some components)
! timeStampStyle           'pre' (at linestart) or 'post' (at end-of-line)
!                            (only for timeStamp)
d140 1
d143 1
d151 1
a151 1
    module procedure DUMPOUTPUTOPTIONS, DUMPSTAMPOPTIONS
d246 13
d510 2
a512 1
    character(len=10), parameter :: decade = '1234567890'
d541 7
a547 5
    do i=1, MAXNUMTABSTOPS
      call blanksToColumn( tabStops(i), fillChar=fillChar )
      call output_( '^', advance='no' )
    enddo
    call newline
d562 1
a562 1
     call output_(' -------------- Summary of stamp options'      , advance='no')
d581 23
d1735 1
a1735 1
  ! time-stamp output:
d1761 1
a1761 1
    my_style = stampOptions%Timestampstyle
d1763 1
a1763 1
    myDate = .false.
d1771 4
a1774 1
        call OUTPUT_DATE_AND_TIME(date=myDate, advance='no')
d1780 4
a1783 1
        call OUTPUT_DATE_AND_TIME(date=myDate, advance='no')
d1809 1
a1809 1
    my_style = stampOptions%Timestampstyle
d1811 1
a1811 1
    myDate = .false.
d1819 4
a1822 1
        call OUTPUT_DATE_AND_TIME(date=myDate, advance='no')
d1828 4
a1831 1
        call OUTPUT_DATE_AND_TIME(date=myDate, advance='no')
d2093 1
a2093 1
       "$Id: output_m.f90,v 2.72 2008/04/18 16:34:37 pwagner Exp $"
d2102 3
@


2.72
log
@achar(13) among chars by default now triggers newLine
@
text
@d967 5
d1066 3
d2042 1
a2042 1
       "$Id: output_m.f90,v 2.71 2008/03/07 01:34:57 pwagner Exp $"
d2051 3
@


2.71
log
@Added f.p. array versions of generic outputNamedValue
@
text
@d14 3
d22 1
a22 1
  use MLSSets, only: FindFirst
d42 1
a42 1
! stampOptions             whether and how to stamp each output to stdout
d64 1
a64 1
! setStamp                 set stamp to be added to every output
d69 1
a69 1
! timestamp                print argument with a timestamp
d87 2
a88 1
!          [log dont_log], [char* log_chars], [char* insteadOfBlank] )
d90 1
a90 1
!          [char* insteadOfBlank] )
a132 6
!  integer, save, public :: PRUNIT = -1  ! Unit for output.  
                                         ! -1 means "printer" unit, *
                                         ! -2 means MLSMessage if 
                                         ! < -2, both printer and MLSMSG
                                         ! > 0, actual unit number
                                         !
d171 5
d202 1
d339 1
a339 1
      call output( allChars(char1:firstSpace-1) )
d341 1
a341 1
      if ( firstSpace+1 < char2 ) call output( allChars(firstSpace+1:char2) )
d344 1
a344 1
      call output( allChars(char1:char2) )
d444 1
a444 1
          call output ( pattern(2:patternLength+1), advance='no' )
d502 2
a503 2
    call output(' -------------- Summary of output options'      , advance='no')
    call output(' -------------- ', advance='yes')
d524 1
a524 1
      call output( '^', advance='no' )
d529 1
a529 1
      call output( '^', advance='no' )
d533 1
a533 1
      call output( decade, advance='no' )
d546 2
a547 2
     call output(' -------------- Summary of stamp options'      , advance='no')
     call output(' -------------- ', advance='yes')
d581 1
a581 1
    if ( present(before) ) call output ( before )
d586 1
a586 1
      call output ( ' (illegal units)', advance=advance )
d606 1
a606 1
      call output( '(-HUGE)' )
d608 1
a608 1
      call output( '(HUGE)' )
d614 4
a617 4
    call output ( trim(adjustl(howMuch)) )
    call output ( trim(suffix) )
    if ( present(after) ) call output ( after )
    call output ( '', advance=advance )
d665 1
a665 1
    call output ( '', advance='yes' )
d855 1
a855 1
            call output('||')
d857 1
a857 1
            call output('|')
d878 1
a878 1
            call output( noteString )
d889 1
a889 1
              call output( noteString )
d894 1
a894 1
            call output('|')
d899 1
a899 1
        call output('|')
d911 1
d913 58
a971 1
  ! Output CHARS to PRUNIT.
d1128 1
a1128 1
  end subroutine OUTPUT_CHAR
d1131 1
a1131 1
  subroutine OUTPUT_CHAR_ARRAY ( CHARS, ADVANCE, INSTEADOFBLANK )
d1136 2
d1139 1
d1141 2
a1142 1
      call output ( chars(i), insteadofblank=insteadofblank )
d1145 1
a1145 1
      call output ( '', advance=advance )
d1163 1
a1163 1
    if ( present(before) ) call output ( before, dont_log = .true. )
d1165 2
a1166 2
      call output ( trim(line), dont_log = .true. )
      call output ( after, advance=advance, dont_log = .true., &
d1169 1
a1169 1
      call output ( trim(line), advance=advance, dont_log = .true., &
d1209 1
a1209 1
      call output ( trim(dateString), from_where=from_where, advance='no', &
d1212 1
a1212 1
      call output ( trim(timeString), from_where=from_where, advance=my_adv, &
d1215 1
a1215 1
      call output ( trim(dateString), from_where=from_where, advance=my_adv, &
d1218 1
a1218 1
      call output ( trim(TimeString), from_where=from_where, advance=my_adv, &
d1225 1
a1225 1
    call output ( trim(msg), from_where=from_where, advance=my_adv, &
d1243 1
a1243 1
    if ( present(before) ) call output ( before, dont_log = .true. )
d1245 2
a1246 2
      call output ( trim(line), dont_log = .true. )
      call output ( after, advance=advance, dont_log = .true. )
d1248 1
a1248 1
      call output ( trim(line), advance=advance, dont_log = .true. )
d1275 1
a1275 1
    if ( present(before) ) call output ( before )
d1277 2
a1278 2
      call output ( line(:k), log_chars=log_chars )
      call output ( after, advance=advance, dont_stamp=dont_stamp )
d1280 1
a1280 1
      call output ( line(:k), advance=advance, log_chars=log_chars, &
d1302 1
a1302 1
      call output ( '', advance=advance, DONT_STAMP=DONT_STAMP )
d1342 1
a1342 1
    if ( present(before) ) call output ( before )
d1344 2
a1345 2
      call output ( line(i:j), DONT_STAMP=DONT_STAMP )
      call output ( after, advance=advance, DONT_STAMP=DONT_STAMP )
d1347 1
a1347 1
      call output ( line(i:j), advance=advance, DONT_STAMP=DONT_STAMP )
d1366 1
a1366 1
      call output ( '', advance=advance, DONT_STAMP=DONT_STAMP )
d1383 2
a1384 2
    if ( present(before) ) call output ( before, DONT_STAMP=DONT_STAMP )
    call output ( line, advance=advance, DONT_STAMP=DONT_STAMP )
d1395 1
a1395 1
    if ( present(before) ) call output ( before, DONT_STAMP=DONT_STAMP )
d1400 1
a1400 1
    if ( present(advance) ) call output ( '', advance=advance, DONT_STAMP=DONT_STAMP )
d1427 1
a1427 1
    if ( present(before) ) call output ( before, DONT_STAMP=DONT_STAMP )
d1429 2
a1430 2
      call output ( line(:k), log_chars=log_chars, DONT_STAMP=DONT_STAMP )
      call output ( after, advance=advance, DONT_STAMP=DONT_STAMP )
d1432 1
a1432 1
      call output ( line(:k), advance=advance, log_chars=log_chars, &
d1453 1
a1453 1
      call output ( '', advance=advance, DONT_STAMP=DONT_STAMP )
d1473 1
a1473 1
      call output ( '', advance )
d1475 1
a1475 1
      call output ( string(:n_chars), advance, from_where, dont_log, log_chars )
d1581 1
a1581 1
      call output( 'Unable to Revert output--old unit not open', advance='yes' )
d1584 1
a1584 1
    call output( 'Reverting output to unit: ', advance='no' )
d1663 3
a1665 3
      call output('Switching further output to: ', advance='no')
      call output(trim(filename), advance='yes')
      call output('using unit number: ', advance='no')
d1669 2
a1670 2
      call output('Switching further output to: ', advance='no')
      call output(trim(filename), advance='yes')
d1719 1
a1719 1
      call output_char( CHARS, &
d1723 1
a1723 1
        call output_char(' (', ADVANCE='no', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
d1725 1
a1725 1
        call output_char(')', ADVANCE='yes', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
d1729 1
a1729 1
        call output_char('(', ADVANCE='no', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
d1731 1
a1731 1
        call output_char(')', ADVANCE='no', DONT_LOG=DONT_LOG, DONT_STAMP=DONT_STAMP)
d1733 1
a1733 1
      call output_char( CHARS, &
d1765 1
a1765 1
        call output_char(' (', ADVANCE='no', DONT_STAMP=DONT_STAMP )
d1767 1
a1767 1
        call output_char(')', ADVANCE='yes', DONT_STAMP=DONT_STAMP)
d1771 1
a1771 1
        call output_char('(', ADVANCE='no', DONT_STAMP=DONT_STAMP)
d1773 1
a1773 1
        call output_char(')', ADVANCE='no', DONT_STAMP=DONT_STAMP)
d1951 1
a1951 1
        & call output ( '', advance='yes', dont_stamp=dont_stamp )
d1967 1
a1967 1
      call output ( b(:i), advance=adv )
d2034 1
a2034 1
       "$Id: output_m.f90,v 2.70 2008/02/22 21:24:14 pwagner Exp $"
d2043 3
@


2.70
log
@Lets NAG-built tools dump PCF, L2CF
@
text
@d176 4
a179 6
    module procedure output_nvp_double
    module procedure output_nvp_integer
    module procedure output_nvp_int_array
    module procedure output_nvp_logical
    module procedure output_nvp_log_array
    module procedure output_nvp_single
d1452 7
d1494 7
d1968 1
a1968 1
       "$Id: output_m.f90,v 2.69 2008/01/09 20:52:03 pwagner Exp $"
d1977 3
@


2.69
log
@call output(NaN) now prints 'NaN'; same with Inf
@
text
@d251 1
d920 3
d928 1
a929 1
    character(len=3) :: MY_ADV
d931 1
a932 1
    logical :: stamp_header
d990 14
a1003 2
    if ( (outputOptions%prunit == -1 .or. outputOptions%prunit < -2) .and. n_stamp > 0 ) &
      & write ( *, '(a)', advance=my_adv ) stamped_chars(1:n_stamp)
d1956 1
a1956 1
       "$Id: output_m.f90,v 2.68 2007/12/19 01:29:05 pwagner Exp $"
d1965 3
@


2.68
log
@Removed unused variables
@
text
@d16 1
a16 1
  use MLSCommon, only: FileNameLen
d263 1
d1187 2
a1188 1
    if ( any( value == DPREFERDEFAULTFORMAT ) ) FormatSpec = '*'
d1338 2
a1339 1
    if ( any( value == RPREFERDEFAULTFORMAT ) ) FormatSpec = '*'
d1940 1
a1940 1
       "$Id: output_m.f90,v 2.67 2007/11/30 18:19:48 pwagner Exp $"
d1949 3
@


2.67
log
@outputCalendar handles yyyy-mm-dd formatted date
@
text
@a706 2
    ! Internal variables
    integer :: I, J, K
d1937 1
a1937 1
       "$Id: output_m.f90,v 2.66 2007/10/18 23:39:46 pwagner Exp $"
d1946 3
@


2.66
log
@Added numToChars and alignToFit intercaes for numeric types
@
text
@d22 1
a22 1
  use MLSStrings, only: lowerCase, writeIntsToChars
d793 3
a795 1
      date2 = reformatDate( dateString(1:col1-1), fromForm='yyyy-Doy', toForm=utcformat )
d1939 1
a1939 1
       "$Id: output_m.f90,v 2.65 2007/09/24 20:22:08 pwagner Exp $"
d1948 3
@


2.65
log
@Improved outputCalendar
@
text
@d53 1
d82 1
d139 1
a139 1
    & GETSTAMP, NEXTCOLUMN, NEXTTAB, NEWLINE, &
d147 5
d160 4
a272 1
  subroutine ALIGNTOFIT ( CHARS, COLUMNRANGE, ALIGNMENT, SKIPS )
d279 1
d343 43
a385 1
  end subroutine ALIGNTOFIT
d683 52
a1184 1
    line = ' '
d1188 1
a1188 32
    ! if ( .not. present(Format)  ) then
    if ( FormatSpec == '*' ) then
   ! No optional formats: use default char-by-char accretion
      write ( line, * ) value
      if ( scan(line,'123456789') == 0  ) then
        line = '0'
      else
        i = index(line,'.')
        j = scan(line(i:),'DdEe ') + i - 1
        if ( i /= 0  ) then
          if ( j == i ) j = len(line)
          i = i + 1
          k = j
          do while ( j > i )
            j = j - 1
            if ( line(j:j) /= '0' .and. line(j:j) /= ' ') exit
          end do
          line(j+1:) = line(k:)
        end if
        line = adjustl(line)
      end if
      k = len_trim(line)
    ! Use one or both optional formats
    else
      line = ' '
      ! write ( line, Format ) value
      ! k = nCharsinFormat(Format)
      write ( line, FormatSpec ) value
      k = nCharsinFormat(FormatSpec)
      if ( k==0 ) k = len_trim(line)
    end if

a1334 1
    line = ' '
d1338 1
a1338 31
    ! if ( .not. present(Format)  ) then
    if ( FormatSpec == '*' ) then
   ! No optional formats: use default char-by-char accretion
      write ( line, * ) value
      if ( scan(line,'123456789') == 0  ) then
        line = '0'
      else
        i = index(line,'.')
        j = scan(line(i:),'DdEe ') + i - 1
        if ( i /= 0  ) then
          if ( j == i ) j = len(line)
          i = i + 1
          k = j
          do while ( j > i )
            j = j - 1
            if ( line(j:j) /= '0' .and. line(j:j) /= ' ') exit
          end do
          line(j+1:) = line(k:)
        end if
        line = adjustl(line)
      end if
      k = len_trim(line)
    ! Use one or both optional formats
    else
      line = ' '
      ! write ( line, Format ) value
      ! k = nCharsinFormat(Format)
      write ( line, FormatSpec ) value
      k = nCharsinFormat(FormatSpec)
      if ( k==0 ) k = len_trim(line)
    end if
d1937 1
a1937 1
       "$Id: output_m.f90,v 2.64 2007/09/20 17:38:09 pwagner Exp $"
d1946 3
@


2.64
log
@improved outputCalendar; neverStamp field added to stampOptions
@
text
@d686 6
a691 1
    date2 = reformatDate( dateString, fromForm='*', toForm=utcformat )
d693 2
d722 2
a723 1
    elseif ( present(notes) ) then
d1895 1
a1895 1
       "$Id: output_m.f90,v 2.63 2007/09/14 00:15:42 pwagner Exp $"
d1904 3
@


2.63
log
@Added alignToFit and outputCalendar
@
text
@d14 1
a14 1
  use dates_module, only:  buildCalendar, &
d21 1
a21 1
    & NumStringElements
d90 2
a91 1
! outputCalendar ( [char* date], [char* notes(:,:)] )
d220 1
a408 8
    integer :: I    ! Blanks to write in next WRITE statement
    logical :: lineup
    integer :: ntimes
    integer :: numSoFar
    character(len=16) :: pattern
    integer :: patternLength
    integer :: patternNum
    integer :: theRest
d631 1
a631 1
  subroutine OUTPUTCALENDAR ( date, notes )
d636 3
a638 1
    ! Notes, if present, is a 6x7 array of stringLists
d643 2
a644 1
    character(len=*), dimension(:,:), optional :: notes
d646 1
d660 1
d669 1
d676 1
d679 2
d706 19
a724 8
    if ( present(notes) ) then
      do iwk=1, numWeeks
        do wkdy=1, 7
          numRows = max( numRows, &
            & NumStringElements( notes(iwk, wkdy), &
            & countEmpty, inseparator ) &
            & )
        enddo
d742 7
a748 7
          if ( row == 1 ) then
            if ( days(iwk, wkdy) > 0 ) then
              call writeIntsToChars( days(iwk, wkdy), dateString )
              dateString = adjustl(dateString)
              call alignToFit( trim(dateString), (/ col1, col2-1 /), 'r' )
            endif
          elseif( row == 10 ) then
d752 7
a758 2
          elseif( present(notes) ) then
            call GetStringElement ( notes(iwk, wkdy), noteString, &
d762 12
d819 1
a819 1
    my_dont_stamp = .false.
d1887 1
a1887 1
       "$Id: output_m.f90,v 2.62 2007/09/06 22:27:06 pwagner Exp $"
d1896 3
@


2.62
log
@Renamed TAB to blanksToTab to avoid conflict with TOGGLES constant
@
text
@d14 2
a15 1
  use dates_module, only:  reformatDate, reformatTime
d20 3
a22 2
  use MLSStringLists, only: ExpandStringRange
  use MLSStrings, only: lowerCase
d45 1
d54 1
d70 1
d90 1
d135 3
a137 3
  public :: BLANKS, BLANKSTOCOLUMN, BLANKSTOTAB, DUMP, DUMPSIZE, GETSTAMP, &
    & NEXTCOLUMN, NEXTTAB, NEWLINE, &
    & OUTPUT, OUTPUT_DATE_AND_TIME, OUTPUTNAMEDVALUE, &
d259 73
d636 126
d1794 20
d1856 1
a1856 1
       "$Id: output_m.f90,v 2.61 2007/08/27 23:55:01 pwagner Exp $"
d1865 3
@


2.61
log
@Added many tabstop-related procedures
@
text
@d45 1
d68 1
d95 1
a95 1
! tab ( [int tabn] )
d129 1
a129 1
  public :: BLANKS, BLANKSTOCOLUMN, DUMP, DUMPSIZE, GETSTAMP, &
d166 4
d232 3
d341 21
a1303 21
  ! ------------------------------------------------  tab  -----
  ! Print blanks out to next tabstop
  ! (or else to tabstop number tabn)
  subroutine tab ( tabn, fillChar )
    ! Args
    integer, optional, intent(in) :: TABN
    character(len=1), intent(in), optional :: FILLCHAR  ! default is ' '
    ! Internal variables
    integer :: nTab
    ! Executable
    if ( present(tabn) ) then
      if ( tabn < 1 .or. tabn > MAXNUMTABSTOPS ) return
      if ( atColumnNumber < tabStops(tabn) ) &
        & call blanksToColumn( tabStops(tabn), fillChar )
    else
      nTab = findFirst( tabStops > atColumnNumber )
      if ( nTab > 0 ) &
        & call blanksToColumn( tabStops(nTab), fillChar )
    endif
  end subroutine tab

d1631 1
a1631 1
       "$Id: output_m.f90,v 2.60 2007/07/27 00:21:59 vsnyder Exp $"
d1640 3
@


2.60
log
@Spiff up printing in DumpSize
@
text
@d18 2
d21 1
a21 1
  implicit NONE
d44 1
d56 1
d59 1
d66 1
d90 1
d92 2
a93 1
! switchOutput( char* filename, [int unit] )
d118 1
a118 1
!  integer, save, public :: PRUNIT = -1   ! Unit for output.  
d127 5
a131 4
  public :: BLANKS, DUMP, DUMPSIZE, GETSTAMP, NEWLINE, &
    & OUTPUT, OUTPUT_DATE_AND_TIME, outputNamedValue, &
    & RESUMEOUTPUT, revertOutput, &
    & SETSTAMP, SUSPENDOUTPUT, switchOutput, TIMESTAMP
d171 5
a175 1
    integer :: PRUNIT = -1
d225 4
d309 3
a311 3
  ! -----------------------------------------------------  PR_BLANKS  -----
  subroutine PR_BLANKS ( N_BLANKS, FILLCHAR, ADVANCE, DONT_STAMP )
  ! Output N_BLANKS blanks to PRUNIT.
d313 1
a313 1
    integer, intent(in) :: N_BLANKS
a316 1
    character(len=3) :: ADV
a318 1
    character(len=len(BlankSpace)) :: b
d320 7
a326 2
    integer :: N    ! Blanks remaining to write
    character(len=3) :: MY_ADV
d328 3
a330 23
    my_adv = Advance_is_yes_or_no(advance)
    if ( n_blanks < 1 ) then
      if ( my_adv == 'yes' ) &
        & call output ( '', advance='yes', dont_stamp=dont_stamp )
      return
    end if
    n = max(n_blanks, 1)
    if ( present(fillChar)  ) then
      do i=1, min(n, len(BlankSpace))
        b(i:i) = fillChar
      end do
    else
      b = BLANKSPACE
    end if
    adv = 'no'
    do
      i = min(n,len(b))
      n = n - i
      if ( n == 0 ) adv = my_adv
      call output ( b(:i), advance=adv )
      if ( n < 1 ) exit   ! was if n == 0, but this should be safer
    end do
  end subroutine PR_BLANKS
d336 5
a340 1
    character(len=1), parameter :: fillChar = '1' ! fill blanks with '. .'
d360 17
d508 19
d1201 24
d1274 21
d1540 40
d1622 1
a1622 1
       "$Id: output_m.f90,v 2.59 2007/07/17 00:24:18 pwagner Exp $"
d1631 3
@


2.59
log
@Treat certain numbers with default list-directed format
@
text
@d396 1
d429 1
a429 1
      call output ( int(amount), format='(i6)' )
d431 1
a431 1
      call output ( amount, format='(f6.1)' )
d433 1
d1497 1
a1497 1
       "$Id: output_m.f90,v 2.58 2007/06/14 18:40:04 pwagner Exp $"
d1506 3
@


2.58
log
@Allow sdFormatDefault to be set at class level
@
text
@d206 1
a206 1
  ! integer, save, public :: MLSMSG_Level = MLSMSG_Info ! What level if logging
a207 3
  ! logical, save, public :: SKIPMLSMSGLOGGING = .false.
  ! character(len=8), save, public :: TIMESTAMPSTYLE = 'post' ! 'pre' or 'post'
  ! Private parameters
a210 1
  
d212 6
d766 1
d948 1
d1495 1
a1495 1
       "$Id: output_m.f90,v 2.57 2007/04/14 00:37:16 vsnyder Exp $"
d1504 3
@


2.57
log
@Correction dumpSize to avoid asterisks in I6 output
@
text
@d182 1
d760 1
a760 1
    character(len=30) :: LINE, LOG_CHARS
d763 4
a766 1
    if ( .not. present(Format)  ) then
d790 4
a793 2
      write ( line, Format ) value
      k = nCharsinFormat(Format)
d941 1
a941 1
    character(len=30) :: LINE, LOG_CHARS
d944 4
a947 1
    if ( .not. present(Format)  ) then
d971 4
a974 2
      write ( line, Format ) value
      k = nCharsinFormat(Format)
d1491 1
a1491 1
       "$Id: output_m.f90,v 2.56 2007/03/23 00:08:21 pwagner Exp $"
d1500 3
@


2.56
log
@Guard against negative args confusing dumpSize
@
text
@d393 1
a393 2
    integer :: iAmount
    real            :: myUnits
a395 1
    iAmount = 0
d420 1
a420 1
    if ( amount < -1.D0*Huge(iAmount) ) then
d422 1
a422 1
    elseif ( amount > 1.D0*Huge(iAmount) ) then
d1480 1
a1480 1
       "$Id: output_m.f90,v 2.55 2007/01/13 01:49:48 pwagner Exp $"
d1489 3
@


2.55
log
@Repaired long-standing bug blighting logged output
@
text
@d393 1
d397 1
d407 1
a407 1
    if ( n < kb/myUnits ) then
d409 1
a409 1
    else if ( n < Mb/myUnits ) then
d412 1
a412 1
    else if ( n < Gb/myUnits ) then
d415 1
a415 1
    else if ( n < Tb/myUnits ) then
d422 5
a426 1
    if ( amount == int(amount) ) then
d1482 1
a1482 1
       "$Id: output_m.f90,v 2.54 2007/01/12 00:31:00 pwagner Exp $"
d1491 3
@


2.54
log
@May use unbuffered output ;renamed routine outputNamedValue
@
text
@d16 2
a17 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Info, MLSMSG_Error
d213 2
d306 3
a308 4
    if ( n_blanks < 1 .and. my_adv == 'yes' ) then
      ! This does not yet prevent us from printing a space before newline
      ! but someday we may achieve that goal
      call output ( '', advance='yes', dont_stamp=dont_stamp )
d339 1
a339 1
    call outputNamedValue ( 'file name', options%name, advance='yes', &
d349 1
a349 1
    call outputNamedValue ( 'special fills', options%specialFillChars, advance='yes', &
d351 1
a351 1
    call outputNamedValue ( 'lineup fills', options%lineupFillChars, advance='yes', &
d368 1
a368 1
     call outputNamedValue ( 'extra text', options%textCode, advance='yes', &
d370 1
a370 1
     call outputNamedValue ( 'date format', options%dateFormat, advance='yes', &
d372 1
a372 1
     call outputNamedValue ( 'time format', options%timeFormat, advance='yes', &
d376 1
a376 1
     call outputNamedValue ( 'style of timeStamps', options%timestampstyle, advance='yes', &
d548 2
a549 1
    n_chars = max(len(chars), 1)
d561 1
a561 1
      n_chars = max(len(chars), 1)
d568 1
a568 1
        n_chars = max(len(insteadofblank), 1)
d572 1
a572 1
      if ( my_adv == 'no' ) n_chars = n_chars+1
d574 3
a576 1
      if ( present(from_where)  ) then
d1476 1
a1476 1
       "$Id: output_m.f90,v 2.53 2006/07/28 01:58:53 vsnyder Exp $"
d1485 3
@


2.53
log
@Cannonball polishing in dumpSize routines
@
text
@d15 1
d25 2
a27 1
! outputOptions            where to send output and how to format it
d35 1
d41 1
d47 1
a47 1
! output_name_v_pair       print nicely formatted name and value
d60 1
d76 1
a76 1
! output_name_v_pair ( char* name, value, [char* advance],
d87 4
a90 1
!          [char*8 style] )
d93 1
a93 1
!          [char*8 style] )
d118 2
a119 2
  public :: BLANKS, DUMPSIZE, GETSTAMP, NEWLINE, &
    & OUTPUT, OUTPUT_DATE_AND_TIME, OUTPUT_NAME_V_PAIR, &
d126 4
d143 1
a143 1
  interface OUTPUT_NAME_V_PAIR
d155 1
a155 1
    module procedure timestamp_char, timestamp_integer
d163 2
d180 1
d327 52
d498 1
d509 23
d589 11
d798 1
a798 1
  subroutine OUTPUT_DOUBLE_ARRAY ( values, FORMAT, LogFormat, ADVANCE )
d804 1
d813 1
a813 6
      if ( outputOptions%prunit == -1 .or. outputOptions%prunit < -2 ) &
        & write ( *, '(a)', advance=my_adv )
      if ( outputOptions%prunit < -1 ) &
        & call MLSMessage ( outputOptions%MLSMSG_Level, ModuleName, '', advance=my_adv )
      if ( outputOptions%prunit >= 0 ) &
        & write ( outputOptions%prunit, '(a)', advance=my_adv )
a876 9
      ! Why all this needless complication?
      ! if ( outputOptions%prunit == -1 .or. outputOptions%prunit < -2 ) &
      !   & write ( *, '(a)', advance=my_adv )
      ! if ( outputOptions%prunit < -1 ) &
      !   & call MLSMessage ( outputOptions%MLSMSG_Level, ModuleName, '', advance=my_adv )
      ! if ( outputOptions%prunit >= 0 ) &
      !   & write ( outputOptions%prunit, '(a)', advance=my_adv )
      
      ! Just do it the easy way
d973 1
a973 1
  subroutine OUTPUT_SINGLE_ARRAY ( values, FORMAT, LogFormat, ADVANCE )
d979 1
d988 1
a988 6
      if ( outputOptions%prunit == -1 .or. outputOptions%prunit < -2 ) &
        & write ( *, '(a)', advance=my_adv )
      if ( outputOptions%prunit < -1 ) &
        & call MLSMessage ( outputOptions%MLSMSG_Level, ModuleName, '', advance=my_adv )
      if ( outputOptions%prunit >= 0 ) &
        & write ( outputOptions%prunit, '(a)', advance=my_adv )
d1014 1
a1014 1
  ! ----------------------------------------------  OUTPUT_NAME_V_PAIR  -----
d1184 1
a1184 3
  ! ------------------------------------------------  timeStamp_char  -----
  subroutine timeStamp_char ( CHARS, &
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK, STYLE)
d1191 2
a1192 1
  
d1200 1
d1206 1
d1213 2
d1221 1
a1221 1
        call OUTPUT_DATE_AND_TIME(date=.false., advance='no')
d1227 1
a1227 1
        call OUTPUT_DATE_AND_TIME(date=.false., advance='no')
a1235 1
  ! ------------------------------------------------  timeStamp_integer  -----
d1237 1
a1237 8
    & PLACES, ADVANCE, FILL, FORMAT, Before, After, style)
  ! time-stamp output:
  ! Either in style pre or post
  ! (pre) '(HH:MM:SS) int'
  ! (post) 'int (HH:MM:SS)'
  ! Note that in pre-style, the time will be printed only if ATLINESTART true
  ! in post-style, the time will be printed only if MY_ADV is 'yes'
  
d1245 1
d1250 1
d1255 2
d1263 1
a1263 1
        call OUTPUT_DATE_AND_TIME(date=.false., advance='no')
d1269 1
a1269 1
        call OUTPUT_DATE_AND_TIME(date=.false., advance='no')
d1277 22
d1471 1
a1471 1
       "$Id: output_m.f90,v 2.52 2006/07/19 22:25:14 vsnyder Exp $"
d1480 3
d1490 1
a1490 1
! Added output_name_v_pair, special blank fills
@


2.52
log
@Add Dumpsize_Double, plus some cannonball polishing
@
text
@d313 1
a313 1
  subroutine DumpSize_double ( n, advance, units )
d317 1
d323 1
d325 1
d327 1
d335 1
d337 1
a337 2
      call output ( n*myUnits, format='(f6.1)' )
      call output ( ' bytes', advance=advance )
d339 2
a340 2
      call output ( n*myUnits/kb, format='(f6.1)' )
      call output ( ' kb', advance=advance )
d342 2
a343 2
      call output ( n*myUnits/Mb, format='(f6.1)' )
      call output ( ' Mb', advance=advance )
d345 8
a352 2
      call output ( n*myUnits/Gb, format='(f6.1)' )
      call output ( ' Gb', advance=advance )
d354 1
a354 2
      call output ( n*myUnits/Tb, format='(f6.1)' )
      call output ( ' Tb', advance=advance )
d356 3
d362 1
a362 1
  subroutine DumpSize_integer ( n, advance, units )
d366 1
d369 2
a370 1
      call dumpSize ( n*1.0, advance=advance, units=units*1.0 )
d372 1
a372 1
      call dumpSize ( n*1.0, advance=advance )
d377 1
a377 1
  subroutine DumpSize_real ( n, advance, units )
d381 1
a381 6
    ! Local parameters
    real, parameter :: KB = 1024.0
    real, parameter :: MB = KB * 1024.0
    real, parameter :: GB = MB * 1024.0
    real, parameter :: TB = GB * 1024.0
    real            :: myUnits
d383 1
a383 23
    myUnits = 1.0
    if ( present(units) ) myUnits = units
    if ( myUnits == 0.0 ) then
      call output ( n, format='(e12.1)' )
      call output ( ' (illegal units)', advance=advance )
      return
    end if
    if ( n < kb/myUnits ) then
      call output ( n*myUnits, format='(f6.1)' )
      call output ( ' bytes', advance=advance )
    else if ( n < Mb/myUnits ) then
      call output ( n*myUnits/kb, format='(f6.1)' )
      call output ( ' kb', advance=advance )
    else if ( n < Gb/myUnits ) then
      call output ( n*myUnits/Mb, format='(f6.1)' )
      call output ( ' Mb', advance=advance )
    else if ( n < Tb/myUnits ) then
      call output ( n*myUnits/Gb, format='(f6.1)' )
      call output ( ' Gb', advance=advance )
    else
      call output ( n*myUnits/Tb, format='(f6.1)' )
      call output ( ' Tb', advance=advance )
    end if
d1365 1
a1365 1
       "$Id: output_m.f90,v 2.51 2006/06/27 23:58:01 pwagner Exp $"
d1374 3
@


2.51
log
@name_v_value works much better
@
text
@d119 1
a119 1
    module procedure DUMPSIZE_INTEGER, DUMPSIZE_REAL
a213 1
    character(len=3) :: ADV
a215 1
    character(len=len(BlankSpace)) :: b
d240 1
a240 1
        endif
d253 1
a253 1
          endif
d257 1
a257 1
        endif
d266 2
a267 2
      endif
    endif
d293 1
a293 1
    endif
d312 37
d359 1
a359 1
    endif
d380 1
a380 1
    endif
d462 1
a462 1
      endif
d466 1
a466 1
    endif
d519 2
a520 2
        endif
      endif
d525 2
a526 2
      endif
    endif
d601 1
a601 1
    endif
d1032 1
a1032 1
    endif
d1039 2
a1040 2
      endif
    endif
d1097 1
a1097 1
    endif
d1102 1
a1102 1
    endif
d1107 1
a1107 1
    endif
d1148 1
a1148 1
      endif
d1154 1
a1154 1
      endif
d1158 1
a1158 1
    endif
d1194 1
a1194 1
      endif
d1200 1
a1200 1
      endif
d1203 1
a1203 1
    endif
d1276 1
a1276 1
    endif                                                                 
d1333 1
a1333 1
    endif
d1354 1
a1354 1
    endif
d1357 1
a1357 1
    contains
d1369 1
a1369 1
      endif
d1378 1
a1378 1
       "$Id: output_m.f90,v 2.50 2006/06/24 23:05:07 pwagner Exp $"
d1387 3
@


2.50
log
@Added output_name_v_pair, special blank fills
@
text
@d43 1
a43 1
! output_name_value_pair   print nicely formatted name and value
d72 2
a73 2
!          [char colon], [char fillChar], [integer tabn], [integer tabc], 
!          log dont_stamp] )
d125 2
a126 1
    module procedure output_integer, output_integer_array, output_logical
d136 1
d138 1
d154 2
a155 1
    character(len=16), dimension(9) :: patterns = (/ &
d194 1
d207 1
a207 1
  subroutine BLANKS ( N_BLANKS, FILLCHAR, ADVANCE )
d213 1
d219 1
a225 1
    integer :: xtraBlanks
d240 1
a240 1
          call pr_blanks ( n_blanks, advance=advance )
d244 16
a259 7
        ! In case repeating pattern ends with one or more blanks
        ! xtraBlanks = patternLength - len_trim( pattern(2:patternLength+1) )
        ! 1st--print single blank
        ! call output(fillchar // ' ' // trim(pattern), advance='yes')
        ! call output('patternLength: ', advance='yes')
        call pr_blanks ( 1, advance='no' )
        numSoFar = 1
d266 1
a266 1
        if ( theRest > 0 ) call pr_blanks ( theRest, advance=advance )
d270 1
a270 1
    call pr_blanks ( n_blanks, advance=advance )
d274 1
a274 1
  subroutine PR_BLANKS ( N_BLANKS, FILLCHAR, ADVANCE )
d280 1
d290 6
d433 1
d492 2
d743 1
a743 1
  subroutine OUTPUT_INTEGER_ARRAY ( INTEGERS, ADVANCE, FORMAT )
d748 1
d757 10
a766 6
      if ( outputOptions%prunit == -1 .or. outputOptions%prunit < -2 ) &
        & write ( *, '(a)', advance=my_adv )
      if ( outputOptions%prunit < -1 ) &
        & call MLSMessage ( outputOptions%MLSMSG_Level, ModuleName, '', advance=my_adv )
      if ( outputOptions%prunit >= 0 ) &
        & write ( outputOptions%prunit, '(a)', advance=my_adv )
d787 16
d917 3
a919 1
  ! tabc: column number where colon appears (to line up 2 mor more lines)
d921 2
d926 1
a926 1
    & ADVANCE, fillChar, colon, TABN, TABC, DONT_STAMP )
d933 1
a933 1
    & ADVANCE, fillChar, colon, TABN, TABC, DONT_STAMP )
d940 1
a940 1
    & ADVANCE, fillChar, colon, TABN, TABC, DONT_STAMP )
d946 7
d954 1
a954 1
    & ADVANCE, fillChar, colon, TABN, TABC, DONT_STAMP )
d960 7
d968 1
a968 1
    & ADVANCE, fillChar, colon, TABN, TABC, DONT_STAMP )
d975 1
a975 1
    & ADVANCE, fillChar, colon, TABN, TABC, DONT_STAMP )
d1343 1
a1343 1
       "$Id: output_m.f90,v 2.49 2006/06/03 00:17:29 vsnyder Exp $"
d1352 3
@


2.49
log
@Eliminate trailing blanks sometimes
@
text
@d25 1
d43 1
d71 3
d101 1
a101 1
  integer, save, public :: PRUNIT = -1   ! Unit for output.  
d110 2
a111 1
  public :: BLANKS, DUMPSIZE, GETSTAMP, NEWLINE, OUTPUT, OUTPUT_DATE_AND_TIME, &
d115 1
d130 9
d143 23
d180 1
d185 1
a185 1
  integer, save, public :: MLSMSG_Level = MLSMSG_Info ! What level if logging
d187 2
a188 2
  logical, save, public :: SKIPMLSMSGLOGGING = .false.
  character(len=8), save, public :: TIMESTAMPSTYLE = 'post' ! 'pre' or 'post'
d213 57
d290 1
a290 1
  end subroutine BLANKS
d411 1
a411 1
    my_dont_log = SKIPMLSMSGLOGGING ! .false.
d418 1
a418 1
    if ( (prunit == -1 .or. prunit < -2) .and. n_stamp > 0 ) &
d420 1
a420 1
    if ( prunit < -1 .and. .not. my_dont_log  ) then
d436 1
a436 1
        call MLSMessage ( MLSMSG_Level, from_where, my_chars(1:n_chars), &
d439 1
a439 1
        call MLSMessage ( MLSMSG_Level, ModuleName, my_chars(1:n_chars), &
d444 1
a444 1
    if ( prunit < 0  ) then
d447 1
a447 1
      write ( prunit, '(a)', advance=my_adv ) trim(insteadofblank)
d449 1
a449 1
      write ( prunit, '(a)', advance=my_adv ) stamped_chars(1:n_stamp)
d457 1
a457 1
        if ( prunit == -1 .or. prunit < -2 ) then
d459 2
a460 2
        elseif( prUnit > 0 ) then
          write ( prunit, '(a)', advance='yes' ) trim(stamped_chars)
d487 1
a487 1
  subroutine OUTPUT_COMPLEX ( VALUE, Format, ADVANCE, Before, After )
d492 1
d503 2
a504 1
      call output ( after, advance=advance, dont_log = .true. )
d506 2
a507 1
      call output ( trim(line), advance=advance, dont_log = .true. )
d590 2
a591 1
  subroutine OUTPUT_DOUBLE ( VALUE, Format, LogFormat, ADVANCE, Before, After )
d599 1
d640 1
a640 1
      call output ( after, advance=advance )
d642 2
a643 1
      call output ( line(:k), advance=advance, log_chars=log_chars )
d663 1
a663 1
      if ( prunit == -1 .or. prunit < -2 ) &
d665 4
a668 4
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, '', advance=my_adv )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=my_adv )
d731 1
a731 1
      if ( prunit == -1 .or. prunit < -2 ) &
d733 4
a736 4
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, '', advance=my_adv )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=my_adv )
d830 1
a830 1
      if ( prunit == -1 .or. prunit < -2 ) &
d832 4
a835 4
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, '', advance=my_adv )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=my_adv )
d861 56
d936 2
a937 2
    if ( PRUNIT > 0 ) then
      inquire( unit=PRUNIT, opened=itsOpen )
d939 1
a939 1
        close(PRUNIT)
d942 1
a942 1
    PRUNIT = OLDUNIT    
d985 1
a985 1
    oldUnit = prUnit
d999 3
a1001 3
    if ( PRUNIT > 0 .and. .not. dontCloseOldUnit ) then
      close(PRUNIT)
      OLDUNIT = PRUNIT
d1009 1
a1009 1
    PRUNIT = SwitchUnit
d1037 1
a1037 1
    my_dont_log = SKIPMLSMSGLOGGING ! .false.
d1039 1
a1039 1
    my_style = TIMESTAMPSTYLE
d1085 1
a1085 1
    my_style = TIMESTAMPSTYLE
d1279 1
a1279 1
       "$Id: output_m.f90,v 2.48 2006/02/21 19:08:36 pwagner Exp $"
d1288 3
@


2.48
log
@Removed two unused declarations
@
text
@d316 2
a317 1
    n_stamp = len(chars) + len_trim(stamped_chars) - len_trim(chars)
d1120 1
a1120 1
       "$Id: output_m.f90,v 2.47 2006/02/15 18:10:44 pwagner Exp $"
d1129 3
@


2.47
log
@Fixed bug preventing CR from being printed sometimes
@
text
@a873 1
    integer :: n_chars
a921 1
    integer :: n_chars
d1119 1
a1119 1
       "$Id: output_m.f90,v 2.46 2006/02/15 00:00:07 pwagner Exp $"
d1128 3
@


2.46
log
@Added automatic stamping features
@
text
@d317 3
d1121 1
a1121 1
       "$Id: output_m.f90,v 2.45 2006/02/10 21:23:05 pwagner Exp $"
d1130 3
@


2.45
log
@Added switchOutput, revertOutput
@
text
@d31 1
d33 1
d38 1
d43 1
a43 1
!                           if you plan to revert, keepOldUnitOpen when switching
d45 1
d49 1
d57 2
d71 2
d82 11
a92 1
! silentRunning            suspend further output if TRUE (or until FALSE)
d95 1
d105 5
a109 2
  public :: BLANKS, DUMPSIZE, NEWLINE, OUTPUT, OUTPUT_DATE_AND_TIME, &
    & RESUMEOUTPUT, revertOutput, SUSPENDOUTPUT, switchOutput, TIMESTAMP
d126 18
d145 2
a146 2
  integer, save, public :: MLSMSG_Level = MLSMSG_Info
  logical, save, private:: SILENTRUNNING = .false. ! Suspend any further output
d149 3
a151 1
  logical, save, private :: ATLINESTART = .true.  ! Used by timeStamp if notpost
a160 29
  ! .......................................  Advance_is_yes_or_no  .....
  function Advance_is_yes_or_no ( str ) result ( outstr )
    ! takes '[Yy]...' or '[Nn..] and returns 'yes' or 'no' respectively
    ! also does the same with '[Tt]..' and '[Ff]..'
    ! leaves all other patterns unchanged, but truncated to three
    ! characters.  Returns 'no' if the argument is absent.
    !--------Argument--------!
    character (len=*), intent(in), optional :: Str
    character (len=3) :: Outstr

    !----------Local vars----------!
    character (len=*), parameter :: yeses = 'YyTt'
    character (len=*), parameter :: nose = 'NnFf'

    if ( .not. present(str)  ) then
      outstr = 'no'
      return
    end if

    outstr = adjustl(str)
    if ( index( yeses, outstr(:1)) > 0  ) then
      outstr = 'yes'
    else if ( index( nose, outstr(:1)) > 0  ) then
      outstr = 'no'
    else
      outstr = str
    end if
  end function Advance_is_yes_or_no

d245 18
d270 1
a270 1
    & ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS, INSTEADOFBLANK)
d278 2
d281 1
d284 1
d287 3
d293 21
d316 3
a318 2
    if ( prunit == -1 .or. prunit < -2 ) &
      & write ( *, '(a)', advance=my_adv ) chars
d345 1
a345 1
    else if ( chars == ' ' .and. present(insteadofblank)  ) then
d348 1
a348 1
      write ( prunit, '(a)', advance=my_adv ) chars
d350 18
a367 1
    ATLINESTART = (my_adv == 'yes')
d410 3
d420 1
d422 1
d441 3
a443 2
    if ( myDate .and. myTime  ) then
      call output ( trim(dateString), from_where=from_where, advance='no' )
d445 8
a452 5
      call output ( trim(timeString), from_where=from_where, advance=my_adv )
    else if ( myDate  ) then
      call output ( trim(dateString), from_where=from_where, advance=my_adv )
    else if ( myTime  ) then
      call output ( trim(TimeString), from_where=from_where, advance=my_adv )
d458 2
a459 1
    call output ( trim(msg), from_where=from_where, advance=my_adv )
d566 2
a567 1
  subroutine OUTPUT_INTEGER ( INT, PLACES, ADVANCE, FILL, FORMAT, Before, After )
d577 2
d603 2
a604 2
      call output ( line(i:j) )
      call output ( after, advance=advance )
d606 1
a606 1
      call output ( line(i:j), advance=advance )
d634 1
a634 1
  subroutine OUTPUT_LOGICAL ( LOG, ADVANCE, BEFORE )
d639 1
d646 2
a647 2
    if ( present(before) ) call output ( before )
    call output ( line, advance=advance )
d651 2
a652 1
  subroutine OUTPUT_SINGLE ( VALUE, FORMAT, LogFormat, ADVANCE, Before, After )
d660 1
d698 1
a698 1
    if ( present(before) ) call output ( before )
d700 2
a701 2
      call output ( line(:k), log_chars=log_chars )
      call output ( after, advance=advance )
d703 2
a704 1
      call output ( line(:k), advance=advance, log_chars=log_chars )
d783 18
d817 1
d822 1
d834 1
a834 1
      if ( PRUNIT > 0 ) switchUnit = PRUNIT
d841 5
a845 1
    open( unit=switchUnit, file=filename, status='replace' )
d847 1
d867 2
d882 1
a882 1
        & LOG_CHARS=LOG_CHARS, INSTEADOFBLANK=INSTEADOFBLANK )
d884 1
a884 1
        call output_char(' (', ADVANCE='no', DONT_LOG=DONT_LOG)
d886 1
a886 1
        call output_char(')', ADVANCE='yes', DONT_LOG=DONT_LOG)
d890 1
a890 1
        call output_char('(', ADVANCE='no', DONT_LOG=DONT_LOG)
d892 1
a892 1
        call output_char(')', ADVANCE='no', DONT_LOG=DONT_LOG)
d896 1
a896 1
        & LOG_CHARS, INSTEADOFBLANK )
d917 2
d928 2
a929 1
        & ADVANCE='no', FILL=FILL, FORMAT=FORMAT, BEFORE=BEFORE, AFTER=AFTER )
d931 1
a931 1
        call output_char(' (', ADVANCE='no')
d933 1
a933 1
        call output_char(')', ADVANCE='yes')
d937 1
a937 1
        call output_char('(', ADVANCE='no')
d939 1
a939 1
        call output_char(')', ADVANCE='no')
d942 1
a942 1
        & ADVANCE, FILL, FORMAT, BEFORE, AFTER )
d948 29
d1076 38
d1118 1
a1118 1
       "$Id: output_m.f90,v 2.44 2006/01/04 20:28:51 pwagner Exp $"
d1127 3
@


2.44
log
@Added suspend- and resumeOutput procedures
@
text
@d39 2
d43 1
d63 1
d65 1
d75 9
a83 4
                                        ! place to store it
  integer, save, public :: PRUNIT = -1  ! Unit for output.  "printer" unit, *
                                        ! if -1, MLSMessage if -2, both
                                        ! printer and MLSMSG if < -2.
d86 1
a86 1
    & RESUMEOUTPUT, SUSPENDOUTPUT, TIMESTAMP
d665 23
d694 36
d926 1
a926 1
       "$Id: output_m.f90,v 2.43 2005/12/16 23:25:13 pwagner Exp $"
d935 3
@


2.43
log
@dumpSize moved from dump0 to output_m
@
text
@d23 9
d34 8
a41 2
! DUMPSIZE                 print a nicely-formatted memory size 
!                             (should be moved to output_M?)
d45 1
d49 18
d68 1
d75 2
a76 1
  public :: BLANKS, DUMPSIZE, NEWLINE, OUTPUT, OUTPUT_DATE_AND_TIME, TIMESTAMP
d95 1
d242 1
d649 12
d857 1
a857 1
       "$Id: output_m.f90,v 2.42 2005/09/22 23:34:56 pwagner Exp $"
d866 3
@


2.42
log
@date conversion procedures and functions all moved into dates module
@
text
@d20 14
d40 6
a45 1
  public :: BLANKS, NEWLINE, OUTPUT, OUTPUT_DATE_AND_TIME, TIMESTAMP
d53 1
d134 50
d807 1
a807 1
       "$Id: output_m.f90,v 2.41 2005/06/22 17:25:50 pwagner Exp $"
d816 3
@


2.41
log
@Reworded Copyright statement, moved rcs id
@
text
@d14 1
d16 1
a16 1
  use MLSStrings, only:  lowercase, reformatDate, reformatTime
d45 1
a45 1
       "$RCSfile: $"
d737 1
a737 1
       "$Id: $"
d746 3
@


2.40
log
@Fixed error in formatting output_date_and_time
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d42 1
a42 3
!---------------------------- RCS Ident Info -------------------------------
  character (len=256), private :: Id = &
       "$Id: output_m.f90,v 2.39 2005/01/20 23:17:51 pwagner Exp $"
d44 1
a44 1
       "$RCSfile: output_m.f90,v $"
d734 5
d745 3
@


2.39
log
@Prevent n_char being gt len(my_chars)
@
text
@d36 1
a36 1
       "$Id: output_m.f90,v 2.38 2005/01/19 01:09:49 pwagner Exp $"
d231 1
a231 1
    dateString = reFormatDate(trim(dateString), dateFormat)
d734 3
@


2.38
log
@New timeStamp interface to certain output procedures
@
text
@d36 1
a36 1
       "$Id: output_m.f90,v 2.37 2005/01/07 01:26:04 pwagner Exp $"
d147 1
d284 1
d445 1
d734 3
@


2.37
log
@Advance now an optional arg to OUTPUT_DATE_AND_TIME so it can time-stamp
@
text
@d17 1
a17 1
  public :: BLANKS, NEWLINE, OUTPUT, OUTPUT_DATE_AND_TIME
d25 3
d31 2
d36 1
a36 1
       "$Id: output_m.f90,v 2.36 2004/12/31 02:39:51 vsnyder Exp $"
d163 1
d531 93
d731 3
@


2.36
log
@Simplified computing My_Adv, simplified Output_Char, added Before argument
to Output_Logical, some cannonball-polishing.
@
text
@d31 1
a31 1
       "$Id: output_m.f90,v 2.35 2004/12/28 19:29:57 pwagner Exp $"
d199 1
a199 1
    & from_where, msg, dateFormat, timeFormat )
d206 1
d219 4
a222 1
    if ( .not. present(msg) ) my_adv = 'yes'
d236 2
d239 1
a239 1
    call output ( trim(msg), from_where=from_where, advance='yes' )
d632 4
@


2.35
log
@Changes to handle formats like f0.3, en10.2, es8.2
@
text
@a27 2
  ! Private internal variables
  logical :: my_dont_log
d31 1
a31 1
       "$Id: output_m.f90,v 2.34 2004/12/14 00:00:50 pwagner Exp $"
d39 2
a40 1
  function Advance_is_yes_or_no (str) result (outstr)
d43 2
a44 1
    ! leaves all other patterns unchanged
d46 2
a47 2
    character (len=*), intent(iN) :: Str
    character (len=len(str)) :: Outstr
d53 5
d59 1
a59 1
    if ( index( yeses, outstr(:1)) > 0 ) then
d61 1
a61 1
    else if ( index( nose, outstr(:1)) > 0 ) then
a65 1
    return
d68 1
d83 1
a83 3
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    my_adv = Advance_is_yes_or_no(my_adv)
d85 1
a85 1
    if ( present(fillChar) ) then
d88 1
a88 1
      enddo
d91 1
a91 1
    endif
a99 1
    return
d102 1
d107 1
d119 1
d123 1
a123 2
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
a125 11
    my_adv = Advance_is_yes_or_no(my_adv)
    the_chars = chars // ' '
    if (present(log_chars)) my_chars = trim(log_chars) // ' '
    n_chars = max(len(chars), 1)
    if ( the_chars == ' ' .and. present(insteadofblank) ) then
      my_chars = trim(insteadofblank) // ' '
      n_chars = max(len(insteadofblank), 1)
    else
      my_chars = the_chars
    endif
    if ( my_adv == 'no' ) n_chars = n_chars+1
d128 15
a142 2
    if ( prunit < -1 .and. .not. my_dont_log ) then
      if ( present(from_where) ) then
d151 1
a151 1
    if ( prunit < 0 ) then
d153 2
a154 2
    elseif ( chars == ' ' .and. present(insteadofblank) ) then
      write ( prunit, '(a)', advance=my_adv ) insteadofblank
d157 1
a157 1
    endif
d160 1
a165 1
    character(len=3) :: MY_ADV
a166 3
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    my_adv = Advance_is_yes_or_no(my_adv)
d170 2
a171 2
    if ( present(advance) ) then
      call output ( '', advance=my_adv )
d175 1
d183 1
a183 1
    if ( present(Format) ) then
d189 1
a189 1
    if ( present(after) ) then
d197 1
d217 7
a223 7
    MY_ADV = 'no'
    if ( .not. present(msg) ) MY_ADV = 'yes'
    call date_and_time(date=dateString, time=timeString)
    dateString=reFormatDate(trim(dateString), dateFormat)
    timeString=reFormatTime(trim(timeString), timeFormat)
    if( myDate .and. myTime ) then
      call output_char(trim(dateString), from_where=from_where, advance='no')
d225 6
a230 6
      call output_char(trim(timeString), from_where=from_where, advance=MY_ADV)
    elseif( myDate ) then
      call output_char(trim(dateString), from_where=from_where, advance=MY_ADV)
    elseif( myTime ) then
      call output_char(trim(TimeString), from_where=from_where, advance=MY_ADV)
    endif
d232 2
a233 2
    call blanks(3)
    call output_char(trim(msg), from_where=from_where, advance='yes')
d236 1
d245 1
a245 1
    if ( present(Format) ) then
d251 1
a251 1
    if ( present(after) ) then
d259 1
a269 1
    character(len=3) :: MY_ADV
d271 1
a271 5
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    my_adv = Advance_is_yes_or_no(my_adv)

    if ( .not. present(Format) ) then
d274 1
a274 1
      if ( scan(line,'123456789') == 0 ) then
d279 1
a279 1
        if ( i /= 0 ) then
d301 1
a301 1
    if ( present(LogFormat) ) then
d305 1
a305 1
    if ( present(after) ) then
d309 1
a309 1
      call output ( line(:k), advance=my_adv, log_chars=log_chars )
d314 1
d323 1
a323 4
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    my_adv = Advance_is_yes_or_no(my_adv)
    my_dont_log = SKIPMLSMSGLOGGING ! .false.
d328 1
a328 1
    if ( present(advance) ) then
d338 1
a351 1
    character(len=3) :: MY_ADV
a352 3
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    my_adv = Advance_is_yes_or_no(my_adv)
d354 1
a354 1
    if ( present(places) ) then; my_places = places; end if
d357 1
a357 1
    if ( present(format) ) then
d362 1
a362 1
    else if ( my_fill ) then
d372 1
a372 1
    if ( present(after) ) then
d376 1
a376 1
      call output ( line(i:j), advance=my_adv )
a377 1
    return
d380 1
d388 1
a388 4
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    my_adv = Advance_is_yes_or_no(my_adv)
    my_dont_log = SKIPMLSMSGLOGGING ! .false.
d393 1
a393 1
    if ( present(advance) ) then
d403 2
a404 1
  subroutine OUTPUT_LOGICAL ( LOG, ADVANCE )
d408 1
d410 1
a410 5
    character(len=3) :: MY_ADV
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    my_adv = Advance_is_yes_or_no(my_adv)
    if (log) then
d415 2
a416 1
    call output ( line, advance=my_adv )
d419 1
a429 1
    character(len=3) :: MY_ADV
d431 1
a431 5
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    my_adv = Advance_is_yes_or_no(my_adv)

    if ( .not. present(Format) ) then
d434 1
a434 1
      if ( scan(line,'123456789') == 0 ) then
d439 1
a439 1
        if ( i /= 0 ) then
d461 1
a461 1
    if ( present(LogFormat) ) then
d465 1
a465 1
    if ( present(after) ) then
d469 1
a469 1
      call output ( line(:k), advance=my_adv, log_chars=log_chars )
a470 1

d473 1
d482 1
a482 4
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
    my_adv = Advance_is_yes_or_no(my_adv)
    my_dont_log = SKIPMLSMSGLOGGING ! .false.
d487 1
a487 1
    if ( present(advance) ) then
d497 1
d509 1
a509 1
    if ( len(string) < 1 ) then
d512 2
a513 2
    else if( len_trim(string) < 1 .or. LENSTRING < 1 ) then
      call blanks(0, advance)
d515 2
a516 2
      call output_char(string(:n_chars), advance, from_where, dont_log, log_chars )
    endif
d519 3
a521 2
  function nCharsinFormat(Format) result(nplusm)
    ! Utility to calculated how many characters in a format spec:         
d562 2
a563 1
  subroutine ourExtractSubString(instr, outstr, sub1, sub2)
d582 2
a583 1
  subroutine ourReplaceSubString(instr, outstr, sub1, sub2)
d617 2
d626 3
@


2.34
log
@Optional arg insteadofblank added to char outputs
@
text
@d33 1
a33 1
       "$Id: output_m.f90,v 2.33 2004/12/13 20:30:19 vsnyder Exp $"
d295 1
d468 1
d533 39
a571 32
     ! Utility to calculated how many characters in a format spec:
     ! [n{xX}][,]{DEFGdefg}m.b
     ! where n, m, and b are digits (we care only about n and m)
     ! return (n+m)
     ! Args
     character(len=*), intent(in) ::  Format
     integer :: nplusm
     ! Local variables
     character(len=20) :: kChar, myFormat
     integer :: n, m
     ! Executable
      kChar=lowerCase(Format)
      call ourReplaceSubString(kChar, myFormat, 'g', 'f')
      call ourReplaceSubString(myFormat, kChar, 'e', 'f')
      call ourReplaceSubString(kChar, myFormat, 'd', 'f')
      call ourExtractSubString(TRIM(myFormat), kChar, 'f', '.')
      read (kChar, '(i2)') m
      if (m < 1) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Bad conversion to m in OUTPUT_xxxLE (format not "{defg}"' )
      if ( index(TRIM(myFormat), 'x' ) == 0 ) then
        n = 0
      else
        call ourExtractSubString(TRIM(myFormat), kChar, '(', 'x')
        read (kChar, '(i2)') n
        if (n < 1) then
          print *, trim(kChar)
          print *, trim(myFormat)
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Bad conversion to n in OUTPUT_xxxLE (format not "{defg}"' )
        end if
      endif
      nplusm = n + m
d598 2
a599 2
    character (len=1), intent(in) :: sub1
    character (len=1), intent(in) :: sub2
d601 1
d603 3
d610 16
a625 1
    outstr(pos:pos) = sub2
d634 3
@


2.33
log
@Cosmetic cannonball polishing
@
text
@d33 1
a33 1
       "$Id: output_m.f90,v 2.32 2004/09/23 22:57:36 pwagner Exp $"
d104 2
a105 1
  subroutine OUTPUT_CHAR ( CHARS, ADVANCE, FROM_WHERE, DONT_LOG, LOG_CHARS )
d112 3
a114 1
    character(len=len(chars)+1) :: my_chars
d123 1
a123 1
    my_chars = chars // ' '
d126 7
a132 1
    if ( my_adv == 'no' ) n_chars = len(chars)+1
d144 8
a151 2
    if ( prunit >= 0 ) &
      & write ( prunit, '(a)', advance=my_adv ) chars
d154 1
a154 1
  subroutine OUTPUT_CHAR_ARRAY ( CHARS, ADVANCE )
d158 1
d165 1
a165 1
      call output ( chars(i) )
d606 3
@


2.32
log
@Added output_date_and_time
@
text
@d33 1
a33 1
       "$Id: output_m.f90,v 2.31 2004/08/04 23:19:02 pwagner Exp $"
d121 1
a121 3
    if (present(log_chars)) then
	my_chars = trim(log_chars) // ' '
    end if
d506 2
a507 2
		& 'Bad string arg in OUTPUT_STRING' )
    elseif( len_trim(string) < 1 .or. LENSTRING < 1 ) then
d532 2
a533 4
      if (m < 1) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
		  & 'Bad conversion to m in OUTPUT_xxxLE (format not "{defg}"' )
      end if
d543 1
a543 1
		    & 'Bad conversion to n in OUTPUT_xxxLE (format not "{defg}"' )
d590 3
@


2.31
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d7 1
a7 1
  use MLSStrings, only:  lowercase
d17 1
a17 1
  public :: BLANKS, NEWLINE, OUTPUT
d27 3
d33 1
a33 1
       "$Id: output_m.f90,v 2.30 2004/06/10 23:59:29 pwagner Exp $"
a110 1
    character(len=3) :: MY_ADV
d113 1
a113 1
    logical :: my_dont_log
d117 1
a117 1
    my_dont_log = .false.
d145 1
a146 1
    character(len=3) :: MY_ADV
d179 38
d303 1
a304 1
    character(len=3) :: MY_ADV
d308 1
d336 1
a337 1
    character(len=3) :: MY_ADV
d374 1
a375 1
    character(len=3) :: MY_ADV
d379 1
d480 1
a586 1

d594 3
@


2.30
log
@blanks may take optional fillchar
@
text
@d7 1
a7 2
  use MLSStrings, only: ExtractSubString, &
    & lowercase , ReplaceSubString
d30 1
a30 1
       "$Id: output_m.f90,v 2.29 2004/02/26 21:51:15 pwagner Exp $"
d486 4
a489 4
      call ReplaceSubString(kChar, myFormat, 'g', 'f')
      call ReplaceSubString(myFormat, kChar, 'e', 'f')
      call ReplaceSubString(kChar, myFormat, 'd', 'f')
      call ExtractSubString(TRIM(myFormat), kChar, 'f', '.')
d498 1
a498 1
        call ExtractSubString(TRIM(myFormat), kChar, '(', 'x')
d510 35
d552 3
@


2.29
log
@Added output_string--although it is almost useless
@
text
@d31 1
a31 1
       "$Id: output_m.f90,v 2.28 2003/10/07 01:12:59 vsnyder Exp $"
d62 1
a62 1
  subroutine BLANKS ( N_BLANKS, ADVANCE )
d64 1
d67 1
d69 1
a69 1
    character(len=*), parameter :: B = &
d71 1
d75 1
d80 7
d93 1
a93 1
      if ( n == 0 ) exit
d518 3
@


2.28
log
@Add NewLine subroutine, and Before and After text args
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d24 1
d31 1
a31 1
       "$Id: output_m.f90,v 2.27 2003/09/15 23:08:44 vsnyder Exp $"
d75 1
a75 1
    n = n_blanks
d442 21
d507 3
@


2.27
log
@Remove five unused local variables
@
text
@d18 1
a18 1
  public :: BLANKS, OUTPUT
d30 1
a30 1
       "$Id: output_m.f90,v 2.26 2003/09/08 17:43:25 pwagner Exp $"
d86 5
a90 1
  subroutine OUTPUT_CHAR ( CHARS, ADVANCE, FROM_WHERE, DONT_LOG, lOG_CHARS )
d145 1
a145 1
  subroutine OUTPUT_COMPLEX ( VALUE, Format, ADVANCE )
d149 1
d157 7
a163 1
    call output ( trim(line), advance=advance, dont_log = .true. )
d166 1
a166 1
  subroutine OUTPUT_DCOMPLEX ( VALUE, Format, ADVANCE )
d171 1
d179 7
a185 1
    call output ( trim(line), advance=advance, dont_log = .true. )
d188 1
a188 1
  subroutine OUTPUT_DOUBLE ( VALUE, Format, LogFormat, ADVANCE )
d195 1
d236 7
a242 1
    call output ( line(:k), advance=my_adv, log_chars=log_chars )
d271 1
a271 1
  subroutine OUTPUT_INTEGER ( INT, PLACES, ADVANCE, FILL, FORMAT )
d280 1
d307 7
a313 1
    call output ( line(i:j), advance=my_adv )
d358 1
a358 1
  subroutine OUTPUT_SINGLE ( VALUE, FORMAT, LogFormat, ADVANCE )
d365 1
d406 7
a412 1
    call output ( line(:k), advance=my_adv, log_chars=log_chars )
d485 3
@


2.26
log
@Fixed bug in nCharsinFormat when no 'x' in Format
@
text
@d30 1
a30 1
       "$Id: output_m.f90,v 2.25 2003/09/06 01:35:55 pwagner Exp $"
a179 1
    character(len=20) :: kChar, myFormat
a335 2
    character(len=20) :: kChar, myFormat
    logical :: char_by_char               ! Build line char by char?
d446 3
@


2.25
log
@Can account for (nx,{defg}m.b} in f.p. format
@
text
@d30 1
a30 1
       "$Id: output_m.f90,v 2.24 2003/08/25 17:48:37 pwagner Exp $"
a180 1
    logical :: char_by_char               ! Build line char by char?
a184 1
    char_by_char = .not. (present(Format) .and. present(LogFormat))
d186 1
a187 1
    if ( char_by_char ) then
a206 10
!      if ( prunit == -1 .or. prunit < -2 ) &
!        & write ( *, '(a)', advance=my_adv ) line(:k)
!      if ( prunit < -1 ) &
!        & call MLSMessage ( MLSMSG_Level, ModuleName, line(:k), &
!          & advance=my_adv )
!      if ( prunit >= 0 ) &
!        & write ( prunit, '(a)', advance=my_adv ) line(:k)
!      return
    end if

d208 1
a208 9
    if ( present(Format) ) then
      !if ( prunit == -1 .or. prunit < -2 ) then
      !  write ( *, Format, advance=my_adv ) value
      !else if ( prunit >= 0 ) then
      !  write ( prunit, Format, advance=my_adv ) value
      !end if
    !else
      !call output ( line(:k), advance=my_adv, dont_log = .true. )
      ! return   ! But this prevented use of LogFormat
a210 11
      !k = len_trim(Format)
      !kChar=lowerCase(Format)
      !call ReplaceSubString(kChar, myFormat, 'g', 'f')
      !call ReplaceSubString(myFormat, kChar, 'e', 'f')
      !call ReplaceSubString(kChar, myFormat, 'd', 'f')
      !call ExtractSubString(TRIM(myFormat), kChar, 'f', '.')
      !read (kChar, '(i2)') k
      !if (k < 1) then
      !  call MLSMessage ( MLSMSG_Error, ModuleName, &
		!  & 'Bad conversion to k in OUTPUT_DOUBLE (format neither "d" or "f"' )
      !end if
a213 2
    !if ( prunit >= -1 ) return

a215 1
      ! write ( line, LogFormat ) value
a217 7
    !if ( my_adv == 'yes' ) then
    !  call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
    !    & advance=my_adv )
    !else
    !  call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)) // ' ', &
    !    & advance=my_adv )
    !endif
a342 1
    char_by_char = .not. (present(Format) .and. present(LogFormat))
d344 1
a345 1
    if ( char_by_char ) then
a364 10
!      if ( prunit == -1 .or. prunit < -2 ) &
!        & write ( *, '(a)', advance=my_adv ) line(:k)
!      if ( prunit < -1 ) &
!        & call MLSMessage ( MLSMSG_Level, ModuleName, line(:k), &
!          & advance=my_adv )
!      if ( prunit >= 0 ) &
!        & write ( prunit, '(a)', advance=my_adv ) line(:k)
!      return
    end if

d366 1
a366 6
    if ( present(Format) ) then
      !if ( prunit == -1 .or. prunit < -2 ) then
      !  write ( *, Format, advance=my_adv ) value
      !else if ( prunit >= 0 ) then
      !  write ( prunit, Format, advance=my_adv ) value
      !end if
a368 11
      !k = len_trim(Format)
      !kChar=lowerCase(Format)
      !call ReplaceSubString(kChar, myFormat, 'g', 'f')
      !call ReplaceSubString(myFormat, kChar, 'e', 'f')
      !call ReplaceSubString(kChar, myFormat, 'd', 'f')
      !call ExtractSubString(TRIM(myFormat), kChar, 'f', '.')
      !read (kChar, '(i2)') k
      !if (k < 1) then
      !  call MLSMessage ( MLSMSG_Error, ModuleName, &
		!& 'Bad conversion to k in OUTPUT_SINGLE' )
      !end if
a370 3
    !call output ( line(:k), advance=my_adv )

    !if ( prunit >= -1 ) return
a373 1
      !write ( line, LogFormat ) value
a375 7
    !if ( my_adv == 'yes' ) then
    !  call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
    !    & advance=my_adv )
    !else
    !  call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)) // ' ', &
    !    & advance=my_adv )
    !endif
d409 1
a409 1
     ! My plan is to return (n+m)
d427 1
a427 3
      ! call GetStringElement(TRIM(myFormat), kChar, 1, .true., 'x')
      call ExtractSubString(TRIM(myFormat), kChar, '(', 'x')
      if ( trim(kChar) == trim(myFormat )) then
d430 1
d433 2
d449 3
@


2.24
log
@Remembered formats may be gx.y
@
text
@d7 2
a8 1
  use MLSStrings, only: ExtractSubString, lowercase , ReplaceSubString
d30 1
a30 1
       "$Id: output_m.f90,v 2.23 2003/08/25 17:06:50 pwagner Exp $"
d231 12
a242 11
      k = len_trim(Format)
      kChar=lowerCase(Format)
      call ReplaceSubString(kChar, myFormat, 'g', 'f')
      call ReplaceSubString(myFormat, kChar, 'e', 'f')
      call ReplaceSubString(kChar, myFormat, 'd', 'f')
      call ExtractSubString(TRIM(myFormat), kChar, 'f', '.')
      read (kChar, '(i2)') k
      if (k < 1) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
		  & 'Bad conversion to k in OUTPUT_DOUBLE (format neither "d" or "f"' )
      end if
d426 12
a437 11
      k = len_trim(Format)
      kChar=lowerCase(Format)
      call ReplaceSubString(kChar, myFormat, 'g', 'f')
      call ReplaceSubString(myFormat, kChar, 'e', 'f')
      call ReplaceSubString(kChar, myFormat, 'd', 'f')
      call ExtractSubString(TRIM(myFormat), kChar, 'f', '.')
      read (kChar, '(i2)') k
      if (k < 1) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
		& 'Bad conversion to k in OUTPUT_SINGLE' )
      end if
d484 36
d527 3
@


2.23
log
@Remembered that formats may use ex.y as well as [fd]x.y
@
text
@d29 1
a29 1
       "$Id: output_m.f90,v 2.22 2003/08/23 00:11:46 pwagner Exp $"
d231 2
a232 1
      myFormat = lowerCase(Format)
d235 1
a235 1
      call ExtractSubString(TRIM(myFormat), kChar(1:k), 'f', '.')
d425 2
a426 1
      myFormat = lowerCase(Format)
d429 1
a429 1
      call ExtractSubString(TRIM(myFormat), kChar(1:k), 'f', '.')
d488 3
@


2.22
log
@Tried to fix prob with fix to output_single; also output_double
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d7 1
a7 1
  use MLSStrings, only: ExtractSubString, lowercase 
d29 1
a29 1
       "$Id: output_m.f90,v 2.21 2003/08/21 21:20:35 cvuu Exp $"
d179 1
a179 1
    character(len=20) :: kChar
d231 4
a234 1
      call ExtractSubString(TRIM(lowercase(Format)), kChar(1:k), 'f', '.')
d237 1
a237 4
        k = len_trim(Format)
        call ExtractSubString(TRIM(lowercase(Format)), kChar(1:k), 'd', '.')
        read (kChar, '(i2)') k
        if (k < 1) call MLSMessage ( MLSMSG_Error, ModuleName, &
d375 1
a375 1
    character(len=20) :: kChar
d424 4
a427 1
      call ExtractSubString(TRIM(lowercase(Format)), kChar(1:k), 'f', '.')
d486 3
@


2.21
log
@Change output of format in OUTPUT_SINGLE
@
text
@d6 2
a7 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Info
d29 1
a29 1
       "$Id: output_m.f90,v 2.20 2003/07/02 01:07:27 vsnyder Exp $"
d85 1
a85 1
  subroutine OUTPUT_CHAR ( CHARS, ADVANCE, FROM_WHERE, DONT_LOG )
d91 1
d103 3
d177 1
a177 1
    character(len=30) :: LINE
d179 1
d220 19
a238 4
      if ( prunit == -1 .or. prunit < -2 ) then
        write ( *, Format, advance=my_adv ) value
      else if ( prunit >= 0 ) then
        write ( prunit, Format, advance=my_adv ) value
a239 3
    else
      call output ( line(:k), advance=my_adv, dont_log = .true. )
      ! return   ! But this prevented use of LogFormat
d242 1
a242 1
    if ( prunit >= -1 ) return
d244 1
d246 2
a247 1
      write ( line, LogFormat ) value
d249 8
a256 7
    if ( my_adv == 'yes' ) then
      call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
        & advance=my_adv )
    else
      call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)) // ' ', &
        & advance=my_adv )
    endif
d373 1
a373 1
    character(len=30) :: LINE
d375 1
d423 7
a429 2
    else
      call output ( line(:k), advance=my_adv )
d433 1
a433 1
    if ( prunit >= -1 ) return
d435 1
d437 2
a438 1
      write ( line, LogFormat ) value
d440 9
a448 7
    if ( my_adv == 'yes' ) then
      call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
        & advance=my_adv )
    else
      call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)) // ' ', &
        & advance=my_adv )
    endif
d483 3
@


2.20
log
@Add complex output
@
text
@d28 1
a28 1
       "$Id: output_m.f90,v 2.19 2003/03/20 19:20:17 pwagner Exp $"
d394 7
a400 5
      if ( prunit == -1 .or. prunit < -2 ) then
        write ( *, Format, advance=my_adv ) value
      else if ( prunit >= 0 ) then
        write ( prunit, Format, advance=my_adv ) value
      end if
d404 1
d452 3
@


2.19
log
@Changes to prevent double-logging when using MLSMessage
@
text
@d18 2
a19 1
    module procedure output_char, output_char_array, output_double
d28 1
a28 1
       "$Id: output_m.f90,v 2.18 2003/02/27 18:35:30 pwagner Exp $"
d36 1
a36 1
  FUNCTION Advance_is_yes_or_no (str) RESULT (outstr)
d41 2
a42 2
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr
d45 2
a46 2
    CHARACTER (LEN=*), parameter :: yeses = 'YyTt'
    CHARACTER (LEN=*), parameter :: nose = 'NnFf'
d51 1
a51 1
    elseif ( index( nose, outstr(:1)) > 0 ) then
d55 1
a55 1
    endif
d78 1
a78 1
      call output ( b(:i), advance=my_adv )
d135 29
d168 2
a169 2
    character(len=*), intent(in), optional :: Format  ! How to print
    character(len=*), intent(in), optional :: LogFormat     ! How to post to Log
d449 3
@


2.18
log
@Appends trailing spaces to improve appearance with MLSMessage
@
text
@d27 1
a27 1
       "$Id: output_m.f90,v 2.17 2002/10/08 00:09:13 pwagner Exp $"
d83 1
a83 1
  subroutine OUTPUT_CHAR ( CHARS, ADVANCE, FROM_WHERE )
d88 1
d92 1
d96 2
d104 1
a104 1
    if ( prunit < -1 ) then
d190 2
a191 1
      call output ( line(:k), advance=my_adv )
d419 3
@


2.17
log
@Added idents to survive zealous Lahey optimizer
@
text
@d27 1
a27 1
       "$Id: output_m.f90,v 2.16 2001/10/19 22:31:36 pwagner Exp $"
d89 3
d95 3
d102 2
a103 1
        call MLSMessage ( MLSMSG_Level, from_where, chars, advance=my_adv )
d105 2
a106 1
        call MLSMessage ( MLSMSG_Level, ModuleName, chars, advance=my_adv )
d193 2
d198 1
a198 1
      call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
d200 1
a200 1
    end if
d372 2
d377 1
a377 1
      call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
d379 1
a379 1
    end if
d414 3
@


2.16
log
@Now can output (small-sized) s.p., d.p. arrays
@
text
@d27 1
a27 1
       "$Id: output_m.f90,v 2.15 2001/10/08 23:43:28 pwagner Exp $"
d30 1
d395 4
d402 3
@


2.15
log
@Allows wider range of advance(s); my_adv implemented uniforml
@
text
@d20 1
a20 1
    module procedure output_single
d27 1
a27 1
       "$Id: output_m.f90,v 2.14 2001/09/26 02:16:22 vsnyder Exp $"
d193 25
d368 26
d397 3
@


2.14
log
@Simplify by using output_char internally
@
text
@d27 1
a27 1
       "$Id: output_m.f90,v 2.13 2001/05/24 22:39:07 vsnyder Exp $"
d34 23
d69 1
d90 1
d109 4
d117 1
a117 1
      call output ( '', advance=advance )
d135 1
d206 4
d228 1
a228 1
    call output ( line(i:j), advance=advance )
d238 4
d248 1
a248 1
        & write ( *, '(a)', advance=advance )
d250 1
a250 1
        & call MLSMessage ( MLSMSG_Level, ModuleName, '', advance=advance )
d252 1
a252 1
        & write ( prunit, '(a)', advance=advance )
d261 4
d270 1
a270 1
    call output ( line, advance=advance )
d287 1
d329 1
a329 1
      call output ( line(:k), advance=advance )
d346 3
@


2.13
log
@Make output_single work like output_double; cosmetic changes
@
text
@d27 1
a27 1
       "$Id: output_m.f90,v 2.12 2001/05/24 22:22:48 vsnyder Exp $"
d52 1
a52 6
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, '(a)', advance=adv ) b(:i)
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, b(:i), advance=adv )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=adv ) b(:i)
d85 1
a85 6
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, '(a)', advance='no' ) chars(i)
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, chars(i), advance='no' )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance='no' ) chars(i)
d88 1
a88 6
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, '(a)', advance=advance )
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, '', advance=advance )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=advance )
d147 1
a147 5
      if ( prunit == -1 .or. prunit < -2 ) then
        write ( *, '(a)', advance=my_adv ) line(:k)
      else if ( prunit >= 0 ) then
        write ( prunit, '(a)', advance=my_adv ) line(:k)
      end if
d173 1
a173 1
    integer :: I
a174 1
    character(len=3) :: MY_ADV
a177 2
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
d181 1
d183 6
d191 2
d194 1
a194 9
    i = max( 1, min(len(line)+1-my_places, index(line,' ',back=.true.)+1) )
    if ( my_fill ) write ( line, '(i6.6)' ) int
    if ( prunit == -1 .or. prunit < -2 ) &
      & write ( *, '(a)', advance=my_adv ) line(i:)
    if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, line(i:), &
          & advance=my_adv )
    if ( prunit >= 0 ) &
      & write ( prunit, '(a)', advance=my_adv ) line(i:)
a222 3
    character(len=3) :: MY_ADV
    my_adv = 'no'
    if ( present(advance) ) then; my_adv = advance; end if
d228 1
a228 8
    if ( prunit == -1 .or. prunit < -2 ) &
      & write ( *, '(a)', advance=my_adv ) line
    if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, line, &
          & advance=my_adv )
    if ( prunit >= 0 ) &
      & write ( prunit, '(a)', advance=my_adv ) line
    return
d286 1
a286 5
      if ( prunit == -1 .or. prunit < -2 ) then
        write ( *, '(a)', advance=my_adv ) line(:k)
      else if ( prunit >= 0 ) then
        write ( prunit, '(a)', advance=my_adv ) line(:k)
      end if
d303 3
@


2.12
log
@Add Output_Single to the generic Output interface
@
text
@d27 1
a27 1
       "$Id: output_m.f90,v 2.11 2001/05/10 22:52:03 vsnyder Exp $"
d154 2
a155 2
   ! Use one or both optional formats
   if ( present(Format) ) then
d158 1
a158 1
      elseif ( prunit >= 0 ) then
d160 2
a161 2
      endif
   else
d164 1
a164 1
      elseif ( prunit >= 0 ) then
d166 2
a167 2
      endif
   endif
d169 1
a169 1
   if ( prunit >= -1 ) return
d171 4
a174 4
   if ( present(LogFormat) ) then
        write ( line, LogFormat ) value
        call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
          & advance=my_adv )
d176 3
a178 3
        call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
          & advance=my_adv )
    endif
d251 1
a251 1
    endif
d262 1
a262 1
  subroutine OUTPUT_SINGLE ( VALUE, FORMAT, ADVANCE )
d266 2
a267 1
    character(len=*), intent(in), optional :: FORMAT
d272 2
d276 4
a279 11
    if ( present(format) ) then
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, format, advance=my_adv ) value
      if ( prunit < -1 ) then
        write ( line, * ) value
        call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
          & advance=my_adv )
      end if
      if ( prunit >= 0 ) &
        & write ( prunit, format, advance=my_adv ) value
    else
d288 1
a288 1
          i = i + 2
d294 1
a294 1
          line(j:) = line(k:)
d299 34
a332 7
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, '(a)', advance=my_adv ) line(:k)
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, line(:k), &
          & advance=my_adv )
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=my_adv ) line(:k)
d338 3
@


2.11
log
@Increase maximum integer width
@
text
@d19 2
a20 1
    module procedure output_integer, output_logical, output_integer_array
d27 1
a27 1
       "$Id: output_m.f90,v 2.10 2001/05/10 18:22:00 pwagner Exp $"
d315 3
@


2.10
log
@Added LogFOrmat to output_double
@
text
@d26 1
a26 1
       "$Id: output_m.f90,v 2.9 2001/05/08 20:27:24 vsnyder Exp $"
d192 1
a192 1
    character(len=6) :: LINE
d204 1
a204 1
      write ( line, '(i6)' ) int
d314 3
@


2.9
log
@Added an optional 'format' argument in a few more places
@
text
@d26 1
a26 1
       "$Id: output_m.f90,v 2.8 2001/04/25 00:08:01 vsnyder Exp $"
d106 1
a106 1
  subroutine OUTPUT_DOUBLE ( VALUE, FORMAT, ADVANCE )
d110 2
a111 1
    character(len=*), intent(in), optional :: FORMAT
d116 2
d120 4
a123 11
    if ( present(format) ) then
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, format, advance=my_adv ) value
      if ( prunit < -1 ) then
        write ( line, * ) value
        call MLSMessage ( MLSMSG_Level, ModuleName, trim(adjustl(line)), &
          & advance=my_adv )
      end if
      if ( prunit >= 0 ) &
        & write ( prunit, format, advance=my_adv ) value
    else
d143 33
a175 4
      if ( prunit == -1 .or. prunit < -2 ) &
        & write ( *, '(a)', advance=my_adv ) line(:k)
      if ( prunit < -1 ) &
        & call MLSMessage ( MLSMSG_Level, ModuleName, line(:k), &
d177 2
a178 3
      if ( prunit >= 0 ) &
        & write ( prunit, '(a)', advance=my_adv ) line(:k)
    end if
d314 3
@


2.8
log
@Add 'fill' argument to 'output_integer'
@
text
@d26 1
a26 1
       "$Id: output_m.f90,v 2.7 2001/04/18 23:28:10 pwagner Exp $"
d157 1
a157 1
  subroutine OUTPUT_INTEGER ( INT, PLACES, ADVANCE, FILL )
d165 1
d177 5
a181 1
    write ( line, '(i6)' ) int
d194 1
a194 1
  subroutine OUTPUT_INTEGER_ARRAY ( INTEGERS, ADVANCE )
d198 1
d201 2
a202 2
      call output_integer(integers(i), advance='no')
      call blanks(3, advance='no')
d290 3
@


2.7
log
@Added output_integer_array
@
text
@d26 1
a26 1
       "$Id: output_m.f90,v 2.6 2001/04/07 01:53:28 vsnyder Exp $"
d157 1
a157 1
  subroutine OUTPUT_INTEGER ( INT, PLACES, ADVANCE )
d159 2
d164 2
d174 2
d178 1
d284 3
@


2.6
log
@Output 0 instead 0.0e+00
@
text
@d19 1
a19 1
    module procedure output_integer, output_logical
d26 1
a26 1
       "$Id: output_m.f90,v 2.5 2001/03/16 23:14:16 vsnyder Exp $"
d182 19
d277 3
@


2.5
log
@Don't trim off the last nonzero digit
@
text
@d26 1
a26 1
       "$Id: output_m.f90,v 2.4 2001/02/28 21:35:34 livesey Exp $"
d129 16
a144 11
      i = index(line,'.')
      j = scan(line(i:),'DdEe ') + i - 1
      if ( i /= 0 ) then
        if ( j == i ) j = len(line)
        i = i + 1
        k = j
        do while ( j > i )
          j = j - 1
          if ( line(j:j) /= '0' .and. line(j:j) /= ' ') exit
        end do
        line(j+1:) = line(k:)
a145 1
      line = adjustl(line)
d228 16
a243 11
      i = index(line,'.')
      j = scan(line(i:),'DdEe ') + i - 1
      if ( i /= 0 ) then
        if ( j == i ) j = len(line)
        i = i + 2
        k = j
        do while ( j > i )
          j = j - 1
          if ( line(j:j) /= '0' .and. line(j:j) /= ' ') exit
        end do
        line(j:) = line(k:)
a244 1
      line = adjustl(line)
d258 3
@


2.4
log
@Added output logical
@
text
@d26 1
a26 1
       "$Id: output_m.f90,v 2.3 2001/02/22 23:54:27 vsnyder Exp $"
d133 1
a133 1
        i = i + 2
d139 1
a139 1
        line(j:) = line(k:)
d250 3
@


2.3
log
@Added optional "from_where" argument to "output_char"
@
text
@d19 1
a19 1
    module procedure output_integer
d26 1
a26 1
       "$Id: output_m.f90,v 2.2 2001/02/22 23:27:16 vsnyder Exp $"
d178 23
d250 3
@


2.2
log
@Correct routing of output through MLSMessage
@
text
@d26 1
a26 1
       "$Id: output_m.f90,v 2.1 2000/10/11 18:33:24 vsnyder Exp $"
d62 1
a62 1
  subroutine OUTPUT_CHAR ( CHARS, ADVANCE )
d66 1
d72 7
a78 2
    if ( prunit < -1 ) &
      & call MLSMessage ( MLSMSG_Level, ModuleName, chars, advance=my_adv )
d227 3
@


2.1
log
@Move from lib/cf_parser to lib; insert copyright notice
@
text
@d26 1
a26 1
       "$Id: output_m.f90,v 2.2 2000/10/09 23:29:54 vsnyder Exp $"
d117 1
a117 1
          & advance=advance )
d141 1
a141 1
          & advance=advance )
d166 1
a166 1
          & advance=advance )
d189 1
a189 1
          & advance=advance )
d213 1
a213 1
          & advance=advance )
d221 3
@

