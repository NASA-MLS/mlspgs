head	1.6;
access;
symbols
	v5-02-NRT-19:1.6
	v6-00:1.6
	v5-02-NRT-18:1.6
	v5-02:1.6
	v5-01-NRT-17:1.6
	v5-01-NRT-16:1.6
	v5-01-NRT-15:1.6
	v5-01-NRT-14:1.6
	neuralnetworks-1-0:1.6.0.18
	cfm-single-freq-0-1:1.6.0.16
	v5-01:1.6
	v5-00:1.6
	v4-23-TA133:1.6.0.14
	mus-emls-1-70:1.6.0.12
	rel-1-0-englocks-work:1.6.0.10
	VUMLS1-00:1.6
	VPL1-00:1.6
	V4-22-NRT-08:1.6
	VAM1-00:1.6
	V4-21:1.6.0.8
	V4-13:1.6
	V4-12:1.6
	V4-11:1.6
	V4-10:1.6
	V3-43:1.6
	M4-00:1.6
	V3-41:1.6
	V3-40-PlusGM57:1.6.0.6
	V2-24-NRT-04:1.6
	V3-33:1.6
	V2-24:1.6
	V3-31:1.6
	V3-30-NRT-05:1.6
	cfm-01-00:1.6
	V3-30:1.6
	V3-20:1.6
	V3-10:1.6
	V2-23-NRT-02:1.6
	V2-23:1.6
	V2-22-NRT-01:1.6
	V2-22:1.6
	V2-21:1.6
	V2-20:1.6
	V2-11:1.6
	V2-10:1.6
	V2-00:1.6
	V1-51:1.6
	V1-50:1.6
	V1-45:1.6
	V1-44:1.6
	V1-43:1.6
	V1-42:1.6
	V1-41:1.6
	V1-32:1.6
	V1-40:1.6
	V1-31:1.6
	V1-30:1.6
	V1-13:1.6
	V1-12:1.6
	V1-11:1.6
	V1-10:1.6
	newfwm-feb03:1.6.0.4
	V1-04:1.6
	V1-03:1.6
	V1-02:1.6
	V1-00:1.6
	newfwm-sep01:1.6.0.2
	V0-7:1.6
	V0-5-Level2:1.6
	V0-5-SIPS:1.6;
locks; strict;
comment	@# @;


1.6
date	2001.04.11.17.22.59;	author vsnyder;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.01.23.52.31;	author vsnyder;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.30.00.50.15;	author vsnyder;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.30.00.30.44;	author vsnyder;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.30.00.23.35;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.20.23.36.54;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Just to get CVS to quit complaining
@
text
@; $Id: in.test,v 1.5 2001/02/01 23:52:31 vsnyder Exp $
;
; This is the Level 2 Configuration file for version 0.1 of the Level
; 2 software for the EOS Microwave Limb Sounder (MLS).
;
; The task of the Level 2 software is to convert calibrated radiance
; observations (Level 1) data into estimates of geophysical parameters
; such as temperature and constituent abundance.
;
; For more details on the software see:
;    EOS MLS Retrieval Processes Algorithm Theoretical Basis Document
;      JPL D-16159
;    Functional Requirements for the EOS MLS Level 2 software
;      JPL D-18027
;    EOS MLS Level 2 file description document
;      JPL D-18028
;    EOS MLS Level 2 software users' guide
;      JPL D-18029
;    Design of the EOS MLS Level 2 software for version 0.1
;      JPL D-18030.
;
; In the case of version 0.1 the goal of the Level 2 software is
; simply to test the interfaces between the SDP software and the toolkit
; and between the software and the Level 1 software.
;
; -----------------------------------------------------------------------------
;
; This section of the l2cf gives global settings to the software,
; output file comments, file versions etc.  Note that while this
; section must occur first in the l2cf, the ordering of these options
; within the section is not critical
;
BEGIN GlobalSettings
    ;;
    ;; This comment string is placed in the `header' for all the
    ;; output files.

    VersionComment="L2CF Version 0-1-0 for version 0.1 of the MLS software"

    ;; The way the SDP toolkit works, the software cannot control
    ;; filenames, it is given them through the PCF.  This means that
    ;; all the software can do is ensure that it is being asked to
    ;; produce an appropriately named file.
    ;;
    ;; So here we state what version information we expect to see embedded
    ;; the filenames.  If these strings are blank then no limitation
    ;; is applied.  Also the user can override this checking by
    ;; setting the option "IgnoreVersion" to .TRUE. (the default is .FALSE.)
    ;; (Note that this will generate a warning message.)

    InputVersionString="v0-1-0-test"
    OutputVersionString="v0-1-0-test"

    ;; In most cases, an attempt to multiply define a priori
    ;; quantities should cause an error.  For example, if there are
    ;; two climatology files, then they should not both contain a
    ;; definition of temperature.  However, in testing it may be
    ;; useful to try out different a priori fields without having to
    ;; edit the complete `configured' file.  Setting this option
    ;; allows the user to `overload' the definitions of a priori
    ;; quantities by using multiple climatology files.  Values in
    ;; later files supersede those in earlier files.
    ;;
    ;; Note that if this option is set TRUE a warning message is
    ;; generated at the start and each time an overload takes place.

    AllowClimatologyOverloads=FALSE

    l2load, bill=["bill1", "bill2"], $
            zvi="zvi" ;???
END GlobalSettings
;
; -----------------------------------------------------------------------------
;
; This next part of the l2cf instructs the software to read various
; quantities in from the climatology database.

BEGIN ReadApriori
foobar: time
    ;;
    ;; Each line in this file describes one geophysical parameter
    ;; for which a priori information is needed from the
    ;; climatology file(s). 
    ;;
    ;; The label is the name by which the a priori information is to
    ;; be identified throughout the remainder of this file.
    ;;
    ;; The 'source=<name>' field indicates the name by which the
    ;; field is identified in the climatology file.
    ;;
    ;; The 'length=<length>' field indicates the horizontal
    ;; correlation length for the quantity.
    ;;
    ;; The field 'versionRange=..' indicates a range of acceptable
    ;; versions in CCSDS format.  
    ;; The format for the date information is
    ;;  <earliest allowed date> : <latest allowed date>
    ;;
    ;; The ordering of these fields is irrelevant, and all fields
    ;; other than source are optional
    ;;
    ;; So for example

    aprioriTemp: climatology, source=temperature, length=200km, $
       versionRange="1999-01-01T" : "2000-01-01T"
    aprioriTemp_precision: climatology, source=temperature_precision, $
       length=200km, $
       versionRange="1999-01-01T" : "2000-01-01T"

    ;; The quantity is aprioriTemp; information for this (value,
    ;; precision and vertical correlation length) is taken from the
    ;; `temp', 'temp_precision', and 'temp_verticalCorrelation' fields
    ;; in the climatology file(s) respectively.  The horizontal
    ;; smoothing length is 200km, and the data must come from a file
    ;; dated sometime between 1st January 1999 and 1st January 2000.
    ;; So here are the rest of the quantities.  We'll just consider
    ;; the primary products here.

    aprioriGPH: climatology, source=GPH, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriGPH_precision: climatology, source=GPH_precision, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriH2O: climatology, source=H2O, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriHNO3: climatology, source=HNO3, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriO3: climatology, source=O3, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriHCl: climatology, source=HCL, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriClO: climatology, source=ClO, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriN2O: climatology, source=N2O, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriCO: climatology, source=CO, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"

END ReadApriori
;
; -----------------------------------------------------------------------------
;
; Having read some a priori data from the climatology database in the
; previous section, the next task is to possibly merge it with
; NCEP/DAO data.  This is the responsibility of this section of the l2cf
;
BEGIN MergeApriori
    ;;
    ;; Each line describes a seperate merge operation.  The 'apriori=...'
    ;; field gives the name of the apriori field as created in the
    ;; ReadApriori section.  Following that are various fields:
    ;;
    ;; The source field indicates whether NCEP or DAO data is to be
    ;; merged. The species field indicates what species is to be read
    ;; from the NCEP/DAO data. It is also used by the software to
    ;; indicate if this specie is to be treated in a special manner
    ;; (as is the case for GPH).
    ;;
    ;; There are two merging methods, 'weighted' and 'direct'. Weighted
    ;; merges the data using a weighting by error method.  Direct simply
    ;; replaces the data in the field with the NCEP/DAO data.  In each
    ;; case a range is given over which the data is to be merged if
    ;; available. A length scale is also given for the `smoothing' that
    ;; takes place above and below the merge range.
    ;;
    ;; So for example:

    merge, apriori=aprioriTemp,source=NCEP,species=temperature, $
       range=1000.0mb : 1mb, method=weighted, scale=5km
    ;;
    ;; For aprioriTemp merge the NCEP temperature data in over the
    ;; range 1000-1 mb.  The merging is done using a weighting by
    ;; error method. The edges are 'merged' with a length scale of 5km
    ;; (crudely converted into pressure coordinates)

    merge, apriori=aprioriTemp_precision, source=NCEP, $
      species=temperature_precision, range=1000.0mb : 1mb, $
      method=weighted, scale=5km

    ;; This line describes how the precisions are merged also; if
    ;; omitted the orginal aprioriTemp_precision from the climatology
    ;; file is left intact.  This is the case for the
    ;; aprioriTemp_verticalCorrelation field, which as it is not
    ;; mentioned here, is unchanged from the input climatology dataset.
    ;;
    ;; Geopotential height is somewhat similar.

    merge, apriori=aprioriGPH, source=NCEP, species=GPH, $
      height=100.0mb, method=weighted

    ;; Only one surface is needed for GPH, so we give that
    ;; alone. Clearly we don't need scale information for a single
    ;; surface merge.

    merge, apriori=aprioriGPH_precision, source=NCEP, $
      species=GPH_precision, height=100.0mb, method=weighted

    ;; Later methods will be devised for relative humidity.
    ;;
END MergeApriori
;
; -----------------------------------------------------------------------------
;
; This next section of the l2cf defines how the dataset is to be
; broken into `chunks'.  This is done according to a set of rules,
; parameters for which are given below.
;
BEGIN ChunkDivide
    ;;
    ;; The items in this section can occur in any order.
    ;;
    ;; First we specify the length of a chunk that we wish to strive for.

    IdealLength=0.25 orbits

    ;; Here we specify it as a given fraction of an orbit.
    ;; Alternatives are a given number of major frames, or a given
    ;; length of time (speficied in minutes)
    ;;
    ;; Now we specify how many MAFs of overlap are desirable.

    Overlap=5 MAFs

    ;; Again, we could express this in orbits or minutes.
    ;;
    ;; Now we specify a home orbit angle.  This is the orbit angle we
    ;; will try to start at least one chunk at.  Ideally this would be
    ;; the chunk that starts the first `full orbit' in the dataset, but
    ;; data gaps etc. may make this impossible.  The `orbit angle' is
    ;; similar to latitude, being the angle swept out by the spacecraft
    ;; (or tangent point in this case) in the orbital plane.  0 is
    ;; defined to be at the first equator crossing of the day, and the
    ;; angle increments through the day. Thus the second orbit crossing
    ;; of the day is at 360, the third at 720 and so on.

    HomeGeodAngle=0 degrees

    ;; Here we define which of the two MLS module tangent points (THz
    ;; or GHz) this angle is refering to.

    HomeModule=GHz

    ;; Here we define the minimum criteria for even bothering to do a
    ;; retrieval. Long periods of data that do not meet these criteria
    ;; are excluded from consideration.

    ScanLowerLimit= -10 km : 20 km
    ScanUpperLimit=  40 km : 100 km

    CriticalScanningModules=Both

    ;; So here we've defined a valid scan as one running from somewhere
    ;; between -10 and 10 km, up to somewhere between 40 and 100km.
    ;; Both modules must be scanning for data to be useful. Alternatives
    ;; to 'both' are 'THz', 'GHz', 'either' or 'none'. 'none' would
    ;; allow for retrieval from limb tracking data.
    ;;
    ;; Now we list the bands that must be on for data to be considered
    ;; useful. This is a standard boolean expression using the MLS
    ;; standard nomenclature and wildcards.

    CriticalBands="R1A:118.B1:PT or R1B:118.B21:PT and R2:190.B*"

    ;; Now we specify how long a data gap (i.e. one of the above
    ;; criteria not being met) is allowed before we force a chunk
    ;; division. We can specify this in minutes, MAFs or orbits.

    MaxGap=3 minutes

END ChunkDivide
;
; ----------------------------------------------------------------------------
;
; This section describes how all the hierarchy of entities that make up
; vector templates are put together. vGrid,hGrid->quantity template->vector
; template.
;
BEGIN Construct
    ;;
    ;; The syntax of this section is of the form
    ;; <name>:<type of entity>, <definition>
    ;;
    ;; Where <type> is hGrid, vGrid, quantity or vectorTemplate.  The
    ;; 'name' is a unique name to identify the object being created, and
    ;; the remaining information varies depending on what is being
    ;; described.
    ;;
    ;; ----------------------------------------------------------------------
    ;;
    ;; Let's start by creating a few vGrids. These are vertical
    ;; coordinate systems.

    vGridHiRes: vGrid, coordinate=Pressure, type=Logarithmic, $
                start=1000mb, number=60, per_decade=12

    ;; This gives us 60 pressure surfaces at 12 per decade from 1000mb up.

    vGridStandard: vGrid, coordinate=Pressure, type=Logarithmic, $
                   start=1000mb, number=[25, 24], per_decade=[12, 6]

    ;; This one gives 12 per decade from 1000mb to 10mb, with 6 per
    ;; decade above that up to 0.001mb.
    ;;
    ;; The last one is a very simple one for GPH

    vGridGPH: vGrid, coordinate=Pressure, type=Explicit, values=100mb

    ;; ----------------------------------------------------------------------
    ;;
    ;; The next things to define are hGrids.  These define horizontal
    ;; coordinate systems.  This first one is the most basic.

    hGridStandard: hGrid, module=ghz, type=fractional, fraction=0.5

    ;; Here we say that the method hGridStandard has profiles spaced
    ;; at master coordinates (phi) in the center (0.5) of each scan.
    ;; By changing the value from 0.5 to say 0 we can place the
    ;; profiles a the lowest phi in each scan etc.
    ;;
    ;; Here are a few more for illustration purposes only

    hGridTroposphere: hGrid, module=ghz, type=height, height=10km

    ;; This hGrid places the profile at the point where the scans
    ;; cross 10km.  If for some bizarre reason this occurs twice in a
    ;; major frame (some severe spacecraft maneuver for example) the
    ;; earliest is chosen.
    ;;
    ;; Now here are two more ones derived from the first

;?? hGridCoarse: hGrid, module=ghz, type=fractional, fraction=0.5, $
;??                     interpolationfactor=0.5
;?? hGridFine: hGrid, module=ghz, type=fractional, fraction=0.5, $
;??                   interpolationfactor=3

    ;; The first corresponds to every second profile of hGridStandard,
    ;; the second to an interpolation in phi, with two extra profiles
    ;; evenly spaced between each one of hGridStandard.
    ;;
    ;; ---------------------------------------------------------------------
    ;;
    ;; Now we move on to defining the vector quantities.  The
    ;; definitions of these are a little more complex.  The simplest
    ;; way to describe it is by using examples.

    temp: quantity, vGrid=vGridHiRes, hGrid=hGridStandard, type=temperature
    gph: quantity, vGrid=vGridGPH, hGrid=hGridStandard, type=gph

    H2O: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=H2O, unit=ppmv
    HNO3: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=HNO3, unit=ppbv
    O3: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=O3, unit=ppmv
    HCl: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=HCl, unit=ppbv
    ClO: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=ClO, unit=ppbv
    N2O: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=N2O, unit=ppbv
    CO: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=CO, unit=ppmv

    ;; Here we'll introduce a few of the so-called 'diagnostic' products
    ;; -- species from multiple bands etc.  As this is version 0.1 we'll
    ;; only do enough to test the system out, we won't go the whole way
    ;; and include them all.

    O3_190: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=O3
    O3_640: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=O3

    N2O_190: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=N2O
    N2O_640: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=N2O

    ;; Define the tangent pressure quantities

    ptan118: quantity, type=ptan, radiometer=r1a
    ptan2t5h: quantity, type=ptan, radiometer=r5h

    ;; So clearly defining quantities is fairly complex. The fields
    ;; are as follows:
    ;;
    ;; name - Name for quantity
    ;; type - temperature, gph, vmr or ptan. (No doubt others will
    ;;        appear)
    ;; vGrid - name of vGrid for quantity if appropriate
    ;; hGrid - name of hGrid for quantity if appropriate
    ;; molecule - Name of molecule described by quantity for forward
    ;;            model calculation use
    ;; unit - Unit for quantity.
    ;; radiometer - Which radiometer ptan quantity refers to.
    ;;
    ;; The vGrid and hGrid fields may be implicit, for example in minor
    ;; frame quantities such as tangent pressures.  This is the limit
    ;; of the flexibility required for v0.1. Later versions will need
    ;; to consider spectroscopy quantities, isotope ratios, irregular
    ;; quantities etc.
    ;;
    ;; ====================================================================
    ;;
    ;; Now we define our vector templates.  This is simply done by
    ;;
    ;; vectorTemplate, quantities=quantity list

    stateTemplate: vectorTemplate, quantities= [ ptan118, ptan2t5h, temp, gph, $
      h2o, hno3, o3, hcl, clo, n2o, co, o3_190, o3_640, n2o_190, n2o_640 ]

    ;; Having done the state vector template, now we define the measurement
    ;; vectors.  These are typically made up of collections of bands.
    ;; Here is an example:

    MainR1RadiancesTemplate: vectorTemplate, signals=["R1A:118.B1F:PT", $
        "R1A:118.B32W:PT"]

    ;; This defines a measurement vector template containing all the
    ;; radiances in the 25 channel filter bank and wide filters in R1A
    ;; (leave aside the issue of multiple filter bank routing for the
    ;; moment).
    ;;
    ;; Of course, the vector quantities have not been defined with a
    ;; line 'quantity, name=R1A:118.B1F:PT ...' however, as the name
    ;; conforms to the channel nomenclature, it is implicitly
    ;; understood by the software.
    ;;
    ;; As this is version 0.1, and we're not going to do anything
    ;; with these vectors, we'll just define one more

    OtherRadiancesTemplate: vectorTemplate, signals=["R2:190.B2F:H2O", $
        "R2:190.B3F:N2O"]

END Construct
;
; -----------------------------------------------------------------------------
;
; Having created vector templates and the entities that compose them,
; the next stage is to define vectors according to those templates and
; fill them with appropriate values.
;
BEGIN Fill
    ;;
    ;; First we'll create two vectors, state and apriori, which follow
    ;; the state template

    state: Vector, template=stateTemplate
    apriori: Vector, template=stateTemplate

    ;; Now we create the measurement vectors

    MainR1Radiances: Vector, template=MainR1RadiancesTemplate
    OtherRadiances: Vector, template=OtherRadiancesTemplate

;;??? fill, quantity=apriori.hno3, source=aprioriHNO3

    jacobian: matrix, rows=mainR1Radiances, columns=state, type=plain

    aprioriCovariance: matrix, type=SPD, rows=state
;;??? fill, matrix=aprioriCovariance, source="aprioriCovarianceFile"

END Fill
;
; ----------------------------------------------------------------------------
;
; This section of the l2cf defines the join operation where the data
; from the individual chunks are joined together in a continuous
; stream ready to be output.
;
BEGIN Join
    ;;
    ;; Each line in this file lists a quantity to be joined, the
    ;; source of information for it, and whether the overlaps are to
    ;; be compared and/or output.
    ;;
    ;; Here is a simple example

    tempL2gp: l2gp, source=state.temp, /compareOverlaps, /outputOverlaps

    ;; We create an output quantity called tempL2gp, taken from the temp
    ;; quantity in the vector called state.  The overlaps are
    ;; compared, and are to be output as an l2gp quantity.
    ;;
    ;; The rest are similar:

    gphL2gp: l2gp, source=state.gph, /compareOverlaps, /outputOverlaps
    h2oL2gp: l2gp, source=state.h2o, /compareOverlaps, /outputOverlaps
    hno3L2gp: l2gp, source=state.hno3, /compareOverlaps, /outputOverlaps
    o3L2gp: l2gp, source=state.o3, /compareOverlaps, /outputOverlaps
    hclL2gp: l2gp, source=state.hcl, /compareOverlaps, /outputOverlaps
    cloL2gp: l2gp, source=state.clo, /compareOverlaps, /outputOverlaps
    n2oL2gp: l2gp, source=state.n2o, /compareOverlaps, /outputOverlaps
    coL2gp: l2gp, source=state.co, /compareOverlaps, /outputOverlaps

    o3_190L2gp: l2gp, source=state.o3_190, /compareOverlaps, /outputOverlaps
    o3_640L2gp: l2gp, source=state.o3_640, /compareOverlaps, /outputOverlaps

    n2o_190L2gp: l2gp, source=state.n2o_190, /compareOverlaps, /outputOverlaps
    n2o_640L2gp: l2gp, source=state.n2o_640, /compareOverlaps, /outputOverlaps

    ptan118L2gp: l2aux, source=state.ptan118, /outputOverlaps
    ptan2t5hL2gp: l2aux, source=state.ptan2t5h, /outputOverlaps

    ;; In later versions we will also join diagnostic quantities
    ;;
END Join
;
; -----------------------------------------------------------------------------
;
; In this section, we detail how the output data created in the join
; section is sent to the various output files.
;
; This section will also deal with metadata population.  Details of
; this will be considered at the coding/implementation phase of the
; software.
;
BEGIN Output
    ;;
    ;; Each output Level 2 file is described on a separate line, with a
    ;; list of the output quantities (from the Join section) to go in
    ;; it.
    ;;
    ;; First the primary products

    output, type=l2gp, file='l2gp_temp', quantities=tempL2gp
    output, type=l2gp, file='l2gp_gph', quantities=gphL2gp
    output, type=l2gp, file='l2gp_h2o', quantities=h2oL2gp
    output, type=l2gp, file='l2gp_hno3', quantities=hno3L2gp
    output, type=l2gp, file='l2gp_o3', quantities=o3L2gp
    output, type=l2gp, file='l2gp_hcl', quantities=hclL2gp
    output, type=l2gp, file='l2gp_clo', quantities=cloL2gp
    output, type=l2gp, file='l2gp_n2o', quantities=n2oL2gp
    output, type=l2gp, file='l2gp_co', quantities=coL2gp

    ;; Now the l2gp_others file contains the secondary l2gp quantities
    ;; and the overlaps from the primary products.

    output, type=l2gp, file='l2gp_others', $
                                quantities= [ o3_190L2gp, o3_640L2gp, $
                                             n2o_190L2gp, n2o_640L2gp ],  $
                                overlaps= [ tempL2gp, gphL2gp, h2oL2gp, $
                                           hno3L2gp, o3L2gp, hclL2gp, $
                                           cloL2gp, n2oL2gp ]

    ;; Now the l2aux file contains non l2gp data

    output, type=l2gp, file='l2aux_full', $
                               quantities= [ ptan118l2gp, ptan2t5hL2gp ], $
                               overlaps= [ ptan118L2gp, ptan2t5hL2gp ]

    ;; In later versions there may be some lines dealing with metadata
    ;; population.
    ;;
END Output
;
; That's the end.
;
; ----------------------------------------------------------------------------
;
; $Log: in.test,v $
; Revision 1.5  2001/02/01 23:52:31  vsnyder
; Replace "radiometer" fields with radiometer literals instead of strings
;
; Revision 1.4  2000/11/30 00:50:15  vsnyder
; Correct a missing comma
;
; Revision 1.3  2000/11/30 00:30:44  vsnyder
; Juxtapose =[ to make sure it works without a space
;
; Revision 1.2  2000/11/30 00:23:35  vsnyder
; Use [] syntax for arrays.
;
; Revision 1.1  2000/10/20 23:36:54  pwagner
; moved to test directory
;
; Revision 1.1  2000/10/11 20:54:39  vsnyder
; Initial addition
;
; Revision 2.0  2000/09/05 17:41:50  dcuddy
; Change revision to 2.0
;
; Revision 1.2  2000/07/28 18:34:59  vsnyder
; Corrected an inconsistency between vectorTemplate and Join.
;
@


1.5
log
@Replace "radiometer" fields with radiometer literals instead of strings
@
text
@d1 1
a1 1
; $Id: in.test,v 1.4 2000/11/30 00:50:15 vsnyder Exp $
d69 2
d79 1
a79 1
time
d460 1
a460 1
      fill, matrix=aprioriCovariance, source="aprioriCovarianceFile"
d525 9
a533 9
    output, file='l2gp_temp', quantities=tempL2gp
    output, file='l2gp_gph', quantities=gphL2gp
    output, file='l2gp_h2o', quantities=h2oL2gp
    output, file='l2gp_hno3', quantities=hno3L2gp
    output, file='l2gp_o3', quantities=o3L2gp
    output, file='l2gp_hcl', quantities=hclL2gp
    output, file='l2gp_clo', quantities=cloL2gp
    output, file='l2gp_n2o', quantities=n2oL2gp
    output, file='l2gp_co', quantities=coL2gp
d538 2
a539 1
    output, file='l2gp_others', quantities= [ o3_190L2gp, o3_640L2gp, $
d547 2
a548 1
    output, file='l2aux_full', quantities= [ ptan118l2gp, ptan2t5hL2gp ], $
d561 3
@


1.4
log
@Correct a missing comma
@
text
@d1 1
a1 1
; $Id: in.test,v 1.3 2000/11/30 00:30:44 vsnyder Exp $
d37 1
a37 1
    ;;
d39 1
a39 1
    ;;
d50 1
a50 1
    ;;
d53 1
a53 1
    ;;
d66 1
a66 1
    ;;
d68 1
a68 1
    ;;
d83 2
a84 2
    ;; The first part of the line is the name by which the a priori
    ;; information is to be identified throughout the software.
d86 2
a87 2
    ;; Following this a field 'source=<name>' indicates the name by
    ;; which the field is identified in the climatology file.
d94 2
a95 4
    ;; Alternative formats for the date information are:
    ;;  <earliest allowed date> .. <latest allowed date>
    ;;  .. <latest allowed date>   (i.e. dated some time before ..)
    ;;  <earliest allowed date> .. (i.e. dated some time after)
d101 1
a101 1
    ;;
d107 2
a108 2
    ;;
    ;; The quantity is aprioriTemp, information for this (value,
d116 1
a116 1
    ;;
d135 1
a135 1
    ;;
d146 3
a148 3
    ;; Each line describes a seperate merge operation.  The first word
    ;; is the name of the apriori field as created in the ReadApriori
    ;; section.  Following that are various fields:
d156 6
a161 7
    ;; There are two merging methods, 'weighted' and
    ;; 'direct'. Weighted merges the data using a weighting by error
    ;; method.  Direct simply replaces the data in the field with the
    ;; NCEP/DAO data.  In each case a range is given over which the
    ;; data is to be merged if available. A length scale is also given
    ;; for the `smooting' that takes place above and below the merge
    ;; range.
d164 1
a164 1
    ;;
d172 1
a172 1
    ;;
d176 2
a177 2
    ;;
    ;; This line describes how the precisions are merged also, if
d184 1
a184 1
    ;;
d187 1
a187 1
    ;;
d191 1
a191 1
    ;;
d194 1
a194 1
    ;;
d207 1
a207 4
    ;; This items in this section can occur in any order.
    ;;
    ;; First we specify what is the desirable length of a chunk which
    ;; we wish to strive for.
d209 2
d212 1
a212 1
    ;;
d217 2
a218 2
    ;; Now we specify how many MAFs of overlap is desirable.
    ;;
d220 1
a220 1
    ;;
d225 8
a232 9
    ;; the the chunk that starts the first `full orbit' in the
    ;; dataset, but data gaps etc. may make this impossible.  The
    ;; `orbit angle' is similar to latitude, being the angle swept out
    ;; by the spacecraft (or tangent point in this case) in the
    ;; orbital plane.  0 is defined to be at the first equator
    ;; crossing of the day, and the angle increments through the day.
    ;; Thus the second orbit crossing of the day is at 360, the third
    ;; at 720 and so on.
    ;;
d234 1
a234 1
    ;;
d237 1
a237 1
    ;;
d239 1
a239 1
    ;;
d241 1
a241 1
    ;; retrieval. Long periods of data that do not meet this criteria
d243 1
a243 1
    ;;
d246 1
a246 1
    ;;
d248 6
a253 7
    ;;
    ;; So here we've defined a valid scan as one running from
    ;; somewhere between -10 and 10 km, upto somewhere between 40 and
    ;; 100km.  Both modules must be scanning for data to be useful.
    ;; Alternatives to 'both' are 'THz', 'GHz', 'either' or
    ;; 'none'. 'none' would allow for retrieval from limb tracking
    ;; data.
d258 1
a258 1
    ;;
d260 1
a260 4
    ;;
    ;; This field is not dealt with in v0.1 and so it's value is in
    ;; fact irrelevant.
    ;;
d264 1
a264 1
    ;; 
d266 1
a266 1
    ;;
d271 3
a273 4
; This next section of the l2cf is probably the most complicated in
; this version of the software.  It describes how all the hierarchy of
; entities that make up vector templates are put together.
; vGrid,hGrid->quantity template->vector template.
d280 3
a282 3
    ;; Where <type> is hGrid, vGrid, quantity or vectorTemplate.  Name
    ;; is a unique name to identify the object being created, and the
    ;; remaining information varies depending on what is being
d289 1
a289 1
    ;;
d292 1
a292 1
    ;;
d294 4
a297 4
    ;;
    vGridStandard: vGrid, coordinate=Pressure,type=Logarithmic, $
                   start = 1000mb, number =[25, 24], per_decade =[12, 6]
    ;;
d302 1
a302 1
    ;;
d304 1
a304 1
    ;;
d309 1
a309 1
    ;;
d311 1
a311 1
    ;;
d318 1
a318 1
    ;;
d320 1
a320 1
    ;;
d327 1
a327 1
    ;;
d332 1
a332 1
    ;;
d339 1
a339 1
    ;; Now we move onto defining the vector quantities.  The
d342 1
a342 1
    ;;
d345 1
a345 1
    ;;
d360 6
a365 6
    ;;
    ;; Now, here we'll introduce a few of the so-called 'diagnostic'
    ;; products, species from multiple bands etc.  As this is version
    ;; 0.1 we'll only do enough to test the system out, we won't go
    ;; the whole way and include them all.
    ;;
d370 1
a370 1
    ;;
d375 1
a375 1
    ;;
d377 4
a380 4
    ;;
    ptan118: quantity, type=ptan, radiometer="R1A:118"
    ptan2t5h: quantity, type=ptan, radiometer="R5H:2T5"
    ;;
d394 1
a394 1
    ;; The vGrid and hGrid fields may be implicit, For example in minor
d405 1
a405 1
    ;;
d408 1
a408 1
    ;;
d412 4
a415 4
    ;;
;?? MainR1RadiancesTemplate: vectorTemplate, signals="R1A:118.B1F:PT" $
;??     "R1A:118.B32W:PT"
    ;;
d418 1
a418 1
    ;; (leave aside the issue of multiple filterbank routing for the
d428 4
a431 4
    ;;
;?? OtherRadiancesTemplate: vectorTemplate, signals="R2:190.B2F:H2O" $
;??     "R2:190.B3F:N2O"
    ;;
a439 3
; The only option implemented in v0.1 is the creation. Filling is not
; done.
;
d442 1
a442 1
    ;; First we'll create two vectors: state and apriori which follow
d444 1
a444 1
    ;;
d447 1
a447 1
    ;;
d449 11
a459 4
    ;;
;?? MainR1Radiances: Vector, template=MainR1RadiancesTemplate
;?? OtherRadiances: Vector, template=OtherRadiancesTemplate
    ;;
d475 1
a475 1
    ;;
d477 1
a477 1
    ;;
d482 2
a483 2
    ;; The rest are easy:
    ;;
d492 1
a492 1
    ;;
d495 1
a495 1
    ;;
d498 1
a498 1
    ;;
d501 1
a501 1
    ;;
d508 2
a509 2
; In this last section of the l2cf, we detail how the output data
; created in the join section is sent to the various output files.
d517 3
a519 2
    ;; Each output Level 2 file is described on a separate line, with
    ;; a list of the output quantities to go in it.
d522 1
a522 1
    ;;
d532 1
a532 1
    ;;
d535 1
a535 1
    ;;
d539 3
a541 3
                                           hno3L2gp, o3L2gp, hclL2gp, cloL2gp, $
                                           n2oL2gp ]
    ;;
d543 1
a543 1
    ;;
d546 1
a546 1
    ;;
d557 3
@


1.3
log
@Juxtapose =[ to make sure it works without a space
@
text
@d1 1
a1 1
; $Id: in.test,v 1.2 2000/11/30 00:23:35 vsnyder Exp $
a208 1
time
d544 1
a544 1
                                           hno3L2gpo3L2gp, hclL2gp, cloL2gp, $
d562 3
@


1.2
log
@Use [] syntax for arrays.
@
text
@d1 1
a1 1
; $Id: in.test,v 1.1 2000/10/20 23:36:54 pwagner Exp $
d307 1
a307 1
                   start = 1000mb, number = [25, 24], per_decade = [12, 6]
d563 3
@


1.1
log
@moved to test directory
@
text
@d1 1
a1 1
; $Id: in.test,v 1.1 2000/10/11 20:54:39 vsnyder Exp $
d77 1
d209 1
d264 1
a264 1
    ;; standard nomencalture and wildcards.
d307 1
a307 1
                   start = 1000mb, number = 25 24, per_decade = 12 6
d417 2
a418 2
    stateTemplate: vectorTemplate, quantities=ptan118 ptan2t5h temp gph $
      h2o hno3 o3 hcl clo n2o co o3_190 o3_640 n2o_190 n2o_640
d542 5
a546 4
    output, file='l2gp_others', quantities=o3_190L2gp o3_640L2gp n2o_190L2gp $
                                           n2o_640L2gp,  $
                                overlaps=tempL2gp gphL2gp h2oL2gp hno3L2gp $
                                         o3L2gp hclL2gp cloL2gp n2oL2gp
d550 2
a551 2
    output, file='l2aux_full', quantities=ptan118l2gp ptan2t5hL2gp, $
                               overlaps=ptan118L2gp ptan2t5hL2gp
d563 3
@

