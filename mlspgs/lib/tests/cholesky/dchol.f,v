head	1.3;
access;
symbols
	v5-02-NRT-19:1.3
	v6-00:1.3
	v5-02-NRT-18:1.3
	v5-02:1.3
	v5-01-NRT-17:1.3
	v5-01-NRT-16:1.3
	v5-01-NRT-15:1.3
	v5-01-NRT-14:1.3
	neuralnetworks-1-0:1.3.0.16
	cfm-single-freq-0-1:1.3.0.14
	v5-01:1.3
	v5-00:1.3
	v4-23-TA133:1.3.0.12
	mus-emls-1-70:1.3.0.10
	rel-1-0-englocks-work:1.3.0.8
	VUMLS1-00:1.3
	VPL1-00:1.3
	V4-22-NRT-08:1.3
	VAM1-00:1.3
	V4-21:1.3.0.6
	V4-13:1.3
	V4-12:1.3
	V4-11:1.3
	V4-10:1.3
	V3-43:1.3
	M4-00:1.3
	V3-41:1.3
	V3-40-PlusGM57:1.3.0.4
	V2-24-NRT-04:1.3
	V3-33:1.3
	V2-24:1.3
	V3-31:1.3
	V3-30-NRT-05:1.3
	cfm-01-00:1.3
	V3-30:1.3
	V3-20:1.3
	V3-10:1.3
	V2-23-NRT-02:1.3
	V2-23:1.3
	V2-22-NRT-01:1.3
	V2-22:1.3
	V2-21:1.3
	V2-20:1.3
	V2-11:1.3
	V2-10:1.3
	V2-00:1.3
	V1-51:1.3
	V1-50:1.3
	V1-45:1.3
	V1-44:1.3
	V1-43:1.3
	V1-42:1.3
	V1-41:1.3
	V1-32:1.3
	V1-40:1.3
	V1-31:1.3
	V1-30:1.3
	V1-13:1.3
	V1-12:1.3
	V1-11:1.3
	V1-10:1.3
	newfwm-feb03:1.3.0.2
	V1-04:1.3
	V1-03:1.3
	V1-02:1.3
	V1-00:1.3
	newfwm-sep01:1.2.0.2
	V0-7:1.2
	V0-5-Level2:1.2
	V0-5-SIPS:1.2;
locks; strict;
comment	@c @;


1.3
date	2002.02.16.00.52.57;	author vsnyder;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.16.00.59.14;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.11.00.22.16;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Nearly completely revised
@
text
@      SUBROUTINE DCHOL (A, NDA, N, B, S, TOL, IERR)
c>> 2001-05-25 DCHOL Snyder & Krogh Compute inner products using DDOT
c>> 1996-03-30 DCHOL Krogh  Added external statement.
c>> 1994-10-20 DCHOL Krogh  Changes to use M77CON
c>> 1991-06-26 DCHOL Krogh  Initial MATH77 version.

c     C. L. Lawson, JPL, 1970 April 30
c     Extensively modified by F. T. Krogh, JPL, 1991, September 23.

c Solution of positive definite system using Cholesky decomposition.

c Suppose the overdetermined system to be solved in the sense of least
c squares is   C*X = D

c Suppose normal equations are formed and stored as follows.

c                    A = (C**T)*C
c                    B = (C**T)*D
c                    S = (D**T)*D

c Given B and the upper triangle of A this subroutine computes the
c solution vector X, storing it in place of B.

c On input S should either = (D**T)D, or be zero.  If the former, then
c on return it is the euclidean norm of (CX - D).  Else the zero value
c is returned.

c The upper triangle of A is replaced by the upper triangular Cholesky
c matrix, R, satisfying  (R**T)*R = A.

c The value of TOL should be 10**(-k-1) where k is the minimum number of
c significant digits in A and B.   If TOL is < the relative precision in
c the computer's arithmetic, it is effectively replaced by that relative
c precision.  If some R(I,I)**2 is < TOL * (corresponding diagonal of
c A), then IERR is set to the value of I for the algebraically smallest
c value of R(I,I).  If R(I,I)**2 is .le. zero, then everything in the
c I-th row of R is set to zero, as is the I-th component of the
c solution, and IERR is replaced by -IERR to flag that this occured.

c--D replaces "?": ?CHOL ?DOT

c ********************* Variable definitions ***************************

c A      Input matrix, only upper triangle is used.  Replace by factor.
c B      Input right hand side, output solution.
c D1MACH Library routine to get characteristics of floating point
c  numbers.  D1MACH(4) = smallest number, x, such that 1.0 + x .ne. 1.0.
c DDOT   Compute dot products.
c G      Temporary for accumulating sums.
c GMIN   Smallest value seen for G when working on a diagonal entry.
c I      Index used to access matrix entries.
c IERR   Used to return status, see above.
c J      Index used to access matrix entries.
c K      Index used to access matrix entries.
c N      Order of matrix.
c NDA    Declared first dimension for A.
c S      Formal argument, see above.
c TOL    Input value for the tolerance, see above.
c TOLI   Internal value for the tolerance.
c TOLM   Machine tolerance, lower limit for TOLI.
c TSQ    TOLI**2.
c ZERO   Parameter equal to zero.

c ******************** Variable declarations ***************************

      external         D1MACH, DDOT
      integer          NDA, N, IERR
      double precision A(NDA, N), B(N), S, TOL
      integer          I, J, K
      double precision ZERO, G, TSQ, GMIN, TOLI, TOLM
      double precision D1MACH, DDOT
      parameter (ZERO = 0.D0)
      save TOLM
      data TOLM /ZERO/

c ******************** Start of executable code ************************
      if (N .le. 0) return
      if (TOLM .le. ZERO) TOLM = D1MACH(4)
      TOLI = max(TOL, TOLM)
      TSQ = TOLI**2
      GMIN = A(1, 1)
      IERR = 0
      do 50 I = 1, N
         G = A(I, I) - DDOT( I-1, A(1, I), 1, A(1, I), 1 )
         if ( G .lt. TSQ * abs(A(I, I)) ) then
            if (G .le. GMIN) then
               GMIN = G
               IERR = I
               if (G .le. ZERO) IERR = -I
            end if
            if (G .le. ZERO) then
               do 20 K = I, N
                  A(I, K) = ZERO
   20          continue
               B(I) = ZERO
               go to 50
            end if
         end if
         A(I, I) = sqrt(G)
         do 30 J = I + 1, N
            A(I,J) = (A(I,J) - DDOT(I-1, A(1,I), 1, A(1,J), 1)) / A(I,I)
   30    continue
c                        Solve next row of first lower triangular system
         B(I) = (B(I) - DDOT( I-1, A(1, I), 1, B, 1 )) / A(I, I)
   50 continue
c                        Get the solution norm
      if ( S .gt. ZERO ) S = sqrt( max(ZERO,S-DDOT(N,B,1,B,1)) )
c                        Solve the second lower triangular system.
      do 80  I = N, 1, -1
        if (A(I, I) .gt. ZERO) then
          B(I) = (B(I) - DDOT(N-I, A(I,I+1), NDA, B(I+1), 1) ) / A(I, I)
        end if
   80 continue
      end
@


1.2
log
@Do not change S if it is initially not positive.
@
text
@d2 1
d40 1
a40 1
c--D replaces "?": ?CHOL
d48 1
a57 2
c SM     Temporary variable used for accumulating a sum.
c SM1    Temporary variable used for accumulating a sum.
d66 1
a66 1
      external         D1MACH
d70 2
a71 1
      double precision ZERO, SM, SM1, G, TSQ, GMIN, TOLI, TOLM, D1MACH
a76 1

d78 1
a78 1
      if (TOLM .eq. ZERO) TOLM = D1MACH(4)
a80 1
      SM1 = ZERO
d83 14
a96 25
      DO 50 I = 1, N
         DO 30 J = I, N
            SM = ZERO
            DO 10 K = 1, I - 1
               SM = SM + A(K, I) * A(K, J)
   10       continue
            G = A(I, J) - SM
            if ( J .ne. I) then
               A(I, J) = G / A(I, I)
            else
               if ( G .lt. TSQ * abs(A(J, J)) ) then
                  if (G .le. GMIN) then
                     GMIN = G
                     IERR = J
                     if (G .le. ZERO) IERR = -J
                  end if
                  if (G .le. ZERO) then
                     do 20 K = J, N
                        A(I, K) = ZERO
   20                continue
                     B(I) = ZERO
                     go to 50
                  end if
               end if
               A(J, J) = sqrt(G)
d98 4
a102 1

d104 1
a104 6
         SM = ZERO
         DO 40 K = 1, I - 1
            SM = SM + A(K, I) * B(K)
   40    continue
         B(I) = (B(I) - SM) / A(I, I)
         SM1 = SM1 + B(I) * B(I)
d107 1
a107 2
      if ( s > zero ) s = sqrt( max(zero,s-sm1) )

d109 4
a112 8
      DO 80  I = N, 1, -1
         if (A(I, I) .ne. ZERO) then
            SM = ZERO
            DO 70 J = I+1, N
               SM = SM + A(I, J) * B(J)
   70       continue
            B(I) = (B(I) - SM) / A(I, I)
         end if
@


1.1
log
@First commit
@
text
@d5 1
a5 1
c
d8 1
a8 1
c
d10 1
a10 1
c
d13 1
a13 1
c
d15 1
a15 1
c
d19 1
a19 1
c
d22 1
a22 1
c
d26 1
a26 1
c
d29 1
a29 1
c
d38 1
a38 1
c
d40 1
a40 1
c
d42 1
a42 1
c
d63 1
a63 1
c
d65 1
a65 1
c
d74 1
a74 1
c
d76 1
a76 1
c
d111 1
a111 1
c
d121 2
a122 2
      S = sqrt(max(ZERO, S - SM1))
c
@

