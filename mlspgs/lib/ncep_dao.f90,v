head	2.87;
access;
symbols
	v5-02-NRT-19:2.87
	v6-00:2.87
	v5-02-NRT-18:2.87
	v5-02:2.87
	v5-01-NRT-17:2.87
	v5-01-NRT-16:2.87
	v5-01-NRT-15:2.87
	v5-01-NRT-14:2.87
	neuralnetworks-1-0:2.87.0.10
	cfm-single-freq-0-1:2.87.0.8
	v5-01:2.87
	v5-00:2.87
	v4-23-TA133:2.87.0.6
	mus-emls-1-70:2.87.0.4
	rel-1-0-englocks-work:2.87.0.2
	VUMLS1-00:2.85
	VPL1-00:2.82
	V4-22-NRT-08:2.81
	VAM1-00:2.81
	V4-21:2.80.0.2
	V4-13:2.79
	V4-12:2.77
	V4-11:2.77
	V4-10:2.76
	V3-43:2.66.2.1
	M4-00:2.73
	V3-41:2.66.2.1
	V3-40-PlusGM57:2.66.0.2
	V2-24-NRT-04:2.46
	V3-33:2.56
	V2-24:2.46
	V3-31:2.56
	V3-30-NRT-05:2.56
	cfm-01-00:2.56
	V3-30:2.55
	V3-20:2.55
	V3-10:2.51
	V2-23-NRT-02:2.46
	V2-23:2.46
	V2-22-NRT-01:2.46
	V2-22:2.46
	V2-21:2.45
	V2-20:2.45
	V2-11:2.44
	V2-10:2.44
	V2-00:2.44
	V1-51:2.37
	V1-50:2.37
	V1-45:2.37
	V1-44:2.37
	V1-43:2.35
	V1-42:2.33
	V1-41:2.33
	V1-32:2.34
	V1-40:2.33
	V1-31:2.33
	V1-30:2.32
	V1-13:2.28
	V1-12:2.28
	V1-11:2.28
	V1-10:2.21
	newfwm-feb03:2.21.0.2
	V1-04:2.19
	V1-03:2.19
	V1-02:2.19
	V1-00:2.19
	newfwm-sep01:2.14.0.2
	V0-7:2.14
	V0-5-Level2:2.11
	V0-5-SIPS:2.11;
locks; strict;
comment	@# @;


2.87
date	2017.10.17.23.39.48;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2017.07.10.18.22.46;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2017.03.07.21.17.35;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2017.01.13.01.29.47;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2016.09.22.22.22.47;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2016.07.28.01.42.27;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2015.03.28.00.56.14;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2015.02.06.01.10.36;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2014.09.06.00.05.02;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2014.09.05.00.27.11;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2014.06.04.18.29.45;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2014.04.02.23.02.52;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2013.09.24.23.27.14;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2012.07.11.20.01.06;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2012.07.02.20.17.42;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2012.05.15.16.53.06;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2012.05.08.17.46.05;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2012.03.06.19.33.11;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2012.03.01.20.00.35;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2011.11.30.21.28.23;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2011.08.30.22.23.46;	author pwagner;	state Exp;
branches
	2.66.2.1;
next	2.65;

2.65
date	2011.08.03.22.50.03;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2011.08.03.15.36.23;	author honghanh;	state Exp;
branches;
next	2.63;

2.63
date	2011.08.02.17.26.37;	author honghanh;	state Exp;
branches;
next	2.62;

2.62
date	2011.08.02.17.23.59;	author honghanh;	state Exp;
branches;
next	2.61;

2.61
date	2011.08.02.16.48.51;	author honghanh;	state Exp;
branches;
next	2.60;

2.60
date	2011.06.29.21.38.23;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2011.05.05.23.09.22;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2011.04.27.17.36.12;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2011.04.20.16.56.16;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2010.03.31.18.12.10;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2009.11.04.23.16.49;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2009.09.29.23.35.09;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2009.08.17.16.52.19;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2009.06.23.18.25.43;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2009.06.16.17.25.58;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2008.12.02.23.11.13;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2008.09.17.23.21.19;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2008.01.07.21.38.12;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2007.06.21.00.49.52;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2006.11.01.20.30.11;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2006.06.13.22.11.45;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2006.05.19.19.55.07;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2006.05.18.18.39.32;	author cvuu;	state Exp;
branches;
next	2.41;

2.41
date	2006.05.12.21.25.56;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2006.01.25.00.58.44;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2005.06.22.17.24.59;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2005.06.14.20.37.06;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2004.08.04.23.19.01;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2004.08.03.17.59.35;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2004.06.23.17.11.50;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2004.01.23.01.12.27;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2003.10.06.13.30.40;	author cvuu;	state Exp;
branches;
next	2.32;

2.32
date	2003.06.03.20.42.25;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2003.05.06.00.31.45;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2003.04.04.18.34.22;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2003.04.02.00.14.25;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2003.03.01.00.23.27;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2003.02.28.02.27.12;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2003.02.27.21.51.02;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2003.02.27.18.38.49;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2003.02.21.21.01.06;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2003.02.20.21.23.40;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2003.02.19.19.14.16;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2002.11.22.12.57.59;	author mjf;	state Exp;
branches;
next	2.20;

2.20
date	2002.10.08.00.09.13;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2002.02.05.04.13.43;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2002.01.23.22.34.37;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2002.01.09.23.48.40;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2001.10.26.23.14.37;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2001.09.10.23.37.10;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.07.12.22.03.55;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.06.04.23.57.40;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2001.05.09.23.30.13;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.12.22.04.47;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.10.20.05.30;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.03.30.00.26.19;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.29.00.51.03;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.28.00.25.14;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.27.17.28.31;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.24.00.29.32;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.21.00.47.29;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.20.00.42.11;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2001.03.15.21.40.30;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2001.03.15.21.26.57;	author pwagner;	state Exp;
branches;
next	;

2.66.2.1
date	2011.11.16.23.33.51;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.87
log
@Removed unused stuff
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module ncep_dao ! Collections of subroutines to handle DataType GriddedData_T

  ! This module's name is in the running for worst-chosen of all
  ! A better choice might be Read_Gridded_Data_m
  ! use, Intrinsic :: ISO_C_Binding, only: C_Intptr_T, C_Loc
  use GriddedData, only: GriddedData_T, V_Is_Pressure, RGR, &
    & SetupNewGriddedData, NullifyGriddedData
  use HDFeos, only: GDOpen, GDAttach, GDDetach, GDClose, GDFldinfo, &
    & GDInqGrid
  use HDF, only: Dfacc_Rdonly
  use HighOutput, only: OutputNamedValue
  use Intrinsic, only: L_HDFeos
  use MLSCommon, only: LineLen, NameLen, &
    & MLSFile_T
  use MLSFiles, only: FileNotFound, HDFversion_5, InitializeMLSFile, &
    & MLS_HDF_Version
  use MLSMessagemodule, only: MLSMsg_Error, MLSMsg_Warning, &
    & MLSMessage
  use MLSStrings, only: Lowercase
  use MLSStringlists, only: GetStringElement, NumStringElements
  use Output_M, only: Output
  use ReadGriddedUtils, only: Lit_Description, Announce_Error, &
    & Read_Dao, Read_Geos5_Or_Merra, Read_Merra_2, &
    & Read_Geos5_7, Read_Ncep_Gdas, Read_Ncep_Strat, ReadGloriaFile, &
    & Write_Merra

  implicit none
  private

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: ncep_dao.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (subroutines and functions)
! ReadGriddedData      read meteorology file in one of supported desciptions
! WriteGriddedData     write meteorology file in one of supported desciptions
!
! The supported descriptions are
! geos5_7         Geos5.7 +  gmao files in netcdf4/hdf5 format
! geos5           Geos5x.x   gmao files in hdfeos2/hdf4 format
! dao or gmao     Geos4x.x   gmao files in hdfeos2/hdf4 format
! merra           Geos5x.x   gmao reanalysis files in hdfeos2/hdf4 format
! merra_2         merra2     merra2 files in netcdf4/hdf5 format
! ncep            GDAS       ncep files in hdfeos2/hdf4 format
! strat           STRAT      ncep combined in hdfeos5/hdf5 format
! === (end of toc) ===

  public:: ReadGriddedData, ReadGloriaFile
  public:: WriteGriddedData

  ! First we'll define some global parameters and data types.
  logical, parameter :: COUNTEMPTY=.true.
!  character (len=*), parameter :: DEFAULTDAODIMLIST = 'XDim,YDim,Height,Time'
!  character (len=*), parameter :: DEFAULTDAOFIELDNAME = 'TMPU'
!  character (len=*), parameter :: DEFAULTGEOS5FIELDNAME = 'T'
!  character (len=*), parameter :: DEFAULTNCEPDIMLIST = 'YDim,XDim'
!  character (len=*), parameter :: DEFAULTNCEPGRIDNAME = 'TMP_3'
!  character (len=*), parameter :: DEFAULTNCEPSTRATFIELDNAME = 'Temperature'
!  character (len=*), parameter :: GEO_FIELD1 = 'Latitude'
!  character (len=*), parameter :: GEO_FIELD2 = 'Longitude'
!  character (len=*), parameter :: GEO_FIELD3 = 'Height'
!  character (len=*), parameter :: GEO_FIELD4 = 'Time'
!  logical, parameter :: GEOS5MAYBEMERRATOO = .false. ! Causes confusion if true
! 
!  character (len=*), parameter :: lit_dao = 'dao'
!  character (len=*), parameter :: lit_ncep = 'ncep'
!  character (len=*), parameter :: lit_strat = 'strat'
!  character (len=*), parameter :: lit_clim = 'clim'
!  character (len=*), parameter :: lit_geos5 = 'geos5'
! 
! 
  integer, parameter :: MAXLISTLENGTH=Linelen ! Max length list of grid names
  integer, parameter :: NENTRIESMAX=200 ! Max num of entries
! integer, parameter ::          MAXDS = 1024 ! 500
! integer, parameter ::          MAXSDNAMESBUFSIZE = MAXDS*NAMELEN

  interface ReadGRIDDEDDATA
    module procedure ReadGriddedData_MLSFile
    module procedure ReadGriddedData_Name
  end interface

contains

  ! ----------------------------------------------- ReadGriddedData_MLSFile
  ! This family of routines reads a Gridded Data file, returning a filled data
  ! structure and the  appropriate for the description
  ! which may be one of 
  ! 'geos5_7', 'geos5', 'gmao', 'dao', 'merra', 'merra_2', 'ncep', 'strat'

  ! FileName and the_g_data are required args
  ! GeoDimList should be the Dimensions' short names
  ! as a comma-delimited character string in the order:
  ! longitude, latitude, vertical level, time

  ! fieldName should name the rank 3 or higher object
  ! like temperature

  ! date is needed only for background files
  ! or any other case in which different files come with the date geolocations
  ! unset
  subroutine ReadGriddedData_MLSFile( GriddedFile, lcf_where, description, v_type, &
    & the_g_data, returnStatus, &
    & GeoDimList, fieldNames, missingValue, &
    & date, sumDelp, deferReading, litDescription, verbose )

    use MLSStats1, only: MLSMin, MLSMax, MLSMean
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End

    ! Arguments
    type(MLSFile_T)                         :: GriddedFile
    integer, intent(in)                     :: lcf_where    ! node of the lcf that provoked me         
    integer, intent(in)                     :: v_type       ! vertical coordinate; an 'enumerated' type
    type( GriddedData_T )                   :: the_g_data ! Result
    character (len=*), intent(in)           :: description ! e.g., 'dao'
    integer, intent(out)                    :: returnStatus ! E.g., FILENOTFOUND
    character (len=*), intent(in)           :: GeoDimList ! Comma-delimited dim names
    character (len=*), intent(in)           :: fieldNames ! Name of gridded field
    real(rgr), optional, intent(in)         :: missingValue
    character (len=*), optional, intent(in) :: date ! offset
    logical, optional, intent(in)           :: sumDelp ! sum the DELP to make PL
    logical, optional, intent(in)           :: deferReading ! don't read yet
    character(len=*), optional, intent(out) :: litDescription
    logical, optional, intent(in)           :: verbose

    ! Local Variables
    character ( len=len(fieldNames)) :: fieldName   ! In case we supply two
    logical, parameter :: DEEBUG = .false.
    integer            :: Me = -1                   ! String index for trace
    logical            :: myDefer
    logical            :: myVerbose
    ! Executable code
    call trace_begin ( me, "ReadGriddedData_MLSFile", lcf_where, &
      & cond=toggle(gen) .and. levels(gen) > 0 )
    if ( present(litDescription) ) litDescription = 'none'
    myDefer = .false.
    if ( present(deferReading) ) myDefer = deferReading
    myVerbose = deebug
    if ( present(verbose) ) myVerbose = verbose .or. deebug
    
    LIT_DESCRIPTION = lowercase(description)
    if ( myVerbose ) &
      & call output( 'Reading ' // trim(LIT_DESCRIPTION) // ' data', advance='yes' )

    call nullifyGriddedData ( the_g_data ) ! for Sun's still useless compiler
    the_g_data%empty = .true.
    the_g_data%QuantityName = '(none)'
    the_g_data%description  = '(none)'
    the_g_data%units        = '(none)'
    the_g_data%equivalentLatitude = .false.
    the_g_data%noYear = .false.
    returnStatus = mls_hdf_version(GriddedFile%Name)
    if ( returnStatus == FILENOTFOUND ) then
      call SetupNewGriddedData ( the_g_data, empty=.true. )
      go to 9
    else
      returnStatus = 0
    end if
    ! Are we deferring the actual reading until later?
    ! If so, we'll store the dummy args for use later
    if ( myDefer ) then
      the_g_data%sourceFileName     = GriddedFile%Name
      the_g_data%description        = description
      the_g_data%dimList            = GeoDimList
      the_g_data%fieldNames         = fieldNames
      the_g_data%verticalCoordinate = v_type
      the_g_data%empty              = .true.
      the_g_data%equivalentLatitude = .false.
      go to 9
    end if
    
    ! Nope, let's read it!
    call getStringElement(fieldNames, fieldName, 1, COUNTEMPTY)
    ! According to the kinds of gridded data files we can read
    select case ( trim(LIT_DESCRIPTION) )
    case ( 'geos5_7', 'merra_2' ) ! Actually 5.7 or merra_2; netCDF4 format
      ! Check that hdf version is OK
      if ( mls_hdf_version( GriddedFile%Name ) /= HDFVERSION_5 ) then
        the_g_data%empty = .true.
        returnStatus = FILENOTFOUND
        call MLSMessage( MLSMSG_Warning, ModuleName, &
          & 'Not an hdf5 file so could not be geos 5.7.x or merra2' )
        if ( present(litDescription) ) litDescription = LIT_DESCRIPTION
        go to 9
      end if
      if ( trim(LIT_DESCRIPTION) == 'geos5_7' ) then
        call Read_geos5_7( GriddedFile, lcf_where, v_type, &
          & the_g_data, GeoDimList, fieldName, date, sumDelp )
      else
        call Read_merra_2( GriddedFile, lcf_where, v_type, &
          & the_g_data, GeoDimList, fieldName, date, sumDelp )
      endif
      if ( .not. myVerbose ) then
        ! Do nothing -- but some compilers may complain
      else if ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
          call output( 'File appears not to be ' // trim(LIT_DESCRIPTION), advance='yes' )
      else
        call output( '(Returned from read_geos5_7 or merra_2)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', MLSMax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', MLSMin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', MLSMean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue('associated(the_g_data%field)', associated(the_g_data%field))
        call outputNamedValue('NumStringElements', NumStringElements(fieldNames, COUNTEMPTY))
      end if
    case ( 'geos5' )
      call Read_geos5_or_merra( GriddedFile, lcf_where, v_type, &
        & the_g_data, GeoDimList, fieldName, date )
      if ( .not. myVerbose ) then
        ! Do nothing -- but some compilers may complain
      else if ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
          call output( 'File appears not to be ' // trim(LIT_DESCRIPTION), advance='yes' )
      else
        call output( '(Returned from read_geos5)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', MLSMax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', MLSMin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', MLSMean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue('associated(the_g_data%field)', associated(the_g_data%field))
        call outputNamedValue('NumStringElements', NumStringElements(fieldNames, COUNTEMPTY))
      end if
    case ('dao', 'gmao')
      call Read_dao(GriddedFile, lcf_where, v_type, &
        & the_g_data, GeoDimList, fieldName)
      if ( .not. myVerbose ) then
        ! Do nothing -- but some compilers may complain
      else if ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
          call output( 'File appears not to be ' // trim(LIT_DESCRIPTION), advance='yes' )
      else
        call output( '(Returned from read_dao)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', MLSMax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', MLSMin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', MLSMean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue('associated(the_g_data%field)', associated(the_g_data%field))
        call outputNamedValue('NumStringElements', NumStringElements(fieldNames, COUNTEMPTY))
      end if
    case ('merra')
      ! In case we were forced to acknowledge that out GMAO files
      ! are MERRA and not GEOS5
      if ( NumStringElements(fieldNames, COUNTEMPTY) > 1 ) &
        & call getStringElement(fieldNames, fieldName, 2, COUNTEMPTY)
      call Read_geos5_or_merra( GriddedFile, lcf_where, v_type, &
        & the_g_data, GeoDimList, fieldName, date, sumDelp )
      if ( .not. myVerbose ) then
        ! Do nothing -- but some compilers may complain
      else if ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
          call output( 'File appears not to be ' // trim(LIT_DESCRIPTION), advance='yes' )
      else
        call output( '(Returned from read merra)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', MLSMax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', MLSMin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', MLSMean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue('associated(the_g_data%field)', associated(the_g_data%field))
        call outputNamedValue('NumStringElements', NumStringElements(fieldNames, COUNTEMPTY))
      end if
    case ('ncep')
      ! These are ncep global assimilation model data
      ! in hdfeos format
      call Read_ncep_gdas(GriddedFile, lcf_where, v_type, &
        & the_g_data, GeoDimList, fieldName, missingValue)
      if ( .not. myVerbose ) then
        ! Do nothing -- but some compilers may complain
      else if ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
          call output( 'File appears not to be ' // trim(LIT_DESCRIPTION), advance='yes' )
      else
        call output( '(Returned from read_ncep_gdas)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', MLSMax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', MLSMin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', MLSMean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue('associated(the_g_data%field)', associated(the_g_data%field))
        call outputNamedValue('NumStringElements', NumStringElements(fieldNames, COUNTEMPTY))
      end if
    case ('strat')
      ! These are ncep stratospheric analysis combined data
      ! in hdfeos5 format
      call Read_ncep_strat(GriddedFile, lcf_where, v_type, &
        & the_g_data, GeoDimList, fieldName)
      if ( .not. myVerbose ) then
        ! Do nothing -- but some compilers may complain
      else if ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
          call output( 'File appears not to be ' // trim(LIT_DESCRIPTION), advance='yes' )
      else
        call output( '(Returned from read_ncep_strat)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', MLSMax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', MLSMin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', MLSMean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue('associated(the_g_data%field)', associated(the_g_data%field))
        call outputNamedValue('NumStringElements', NumStringElements(fieldNames, COUNTEMPTY))
      end if
    case default
      call announce_error( lcf_where, 'ReadGriddedData_MLSFile called with unknown' &
        & // ' description: ' // trim(LIT_DESCRIPTION) )
    end select
    if ( present(litDescription) ) litDescription = LIT_DESCRIPTION

9   continue
    call trace_end ( "ReadGriddedData_MLSFile", &
      & cond=toggle(gen) .and. levels(gen) > 0 )

  end subroutine ReadGriddedData_MLSFile

  subroutine ReadGriddedData_Name( FileName, lcf_where, description, v_type, &
    & the_g_data, returnStatus, &
    & GeoDimList, fieldNames, missingValue, &
    & date, sumDelp, deferReading, litDescription, verbose )
    ! Arguments
    character (len=*), intent(in)           :: FileName
    integer, intent(in)                     :: lcf_where    ! node of the lcf that provoked me         
    integer, intent(in)                     :: v_type       ! vertical coordinate; an 'enumerated' type
    type( GriddedData_T )                   :: the_g_data ! Result
    character (len=*), intent(in)           :: description ! e.g., 'dao'
    integer, intent(out)                    :: returnStatus ! E.g., FILENOTFOUND
    character (len=*), intent(in)           :: GeoDimList ! Comma-delimited dim names
    character (len=*), intent(in)           :: fieldNames ! Name of gridded field
    real(rgr), optional, intent(in)         :: missingValue
    character (len=*), optional, intent(in) :: date ! offset
    logical, optional, intent(in)           :: sumDelp ! sum the DELP to make PL
    logical, optional, intent(in)           :: deferReading ! don't read yet
    character(len=*), optional, intent(out) :: litDescription
    logical, optional, intent(in)           :: verbose
    ! Internal variables
    type(MLSFile_T)                         :: GriddedFile

    ! Executable
    returnStatus = InitializeMLSFile( GriddedFile, content = 'gridded', &
      & name=FileName, &
      & type=l_hdfeos, access=DFACC_RDONLY )
    call ReadGriddedData_MLSFile( GriddedFile, lcf_where, description, v_type, &
      & the_g_data, returnStatus, &
      & GeoDimList, fieldNames, missingValue, &
      & date, sumDelp, deferReading, litDescription, verbose )

  end subroutine ReadGriddedData_Name

  ! -------------------------------------------  WriteGriddedData  -----
  subroutine WriteGriddedData( GriddedFile, lcf_where, description, v_type, &
    & the_g_data, returnStatus, &
    & GeoDimList, fieldNames, missingValue, date, sumDelp )

    ! This routine Writes a Gridded Data file, based on an array of filled data
    ! structures and the  appropriate for the description
    ! which may be one of 'geos5', 'gmao', 'dao', 'merra', 'ncep', 'strat'
    ! (But see shortc. and lim. below)

    ! FileName and the_g_data are required args
    ! GeoDimList should be the Dimensions' short names
    ! as a comma-delimited character string in the order:
    ! longitude, latitude, vertical level, time

    ! fieldNames should be the data fields' short names
    ! as a comma-delimited character string in the order
    ! of the elements of the_g_data array

    ! fieldName should name the rank 3 or higher object
    ! like temperature
    
    ! ---- Shortcomings and limitations: ----
    ! We have only coded it for description='merra' so far
    ! Any other file description will generate an error
    ! Obviously we should only code what we plan to use
    ! Would it be useful to be able to write a geos5_7 file, perhaps
    ! degrading its resolution thereby?
    
    ! Arguments
    type(MLSFile_T)                         :: GriddedFile
    integer, intent(in)                     :: lcf_where    ! node of the lcf that provoked me         
    integer, intent(in)                     :: v_type       ! vertical coordinate; an 'enumerated' type
    type( GriddedData_T ), dimension(:)     :: the_g_data   ! Result
    character (len=*), intent(in)           :: description ! e.g., 'dao'
    integer, intent(out)                    :: returnStatus ! E.g., FILENOTFOUND
    character (len=*), intent(in)           :: GeoDimList ! Comma-delimited dim names
    character (len=*), intent(in)           :: fieldNames ! Names of gridded field
    real(rgr), optional, intent(in)         :: missingValue
    character (len=*), optional, intent(in) :: date ! offset
    logical, optional, intent(in)           :: sumDelp ! sum the DELP to make PL

    ! Local Variables
    integer :: fieldIndex
    character ( len=len(fieldNames)) :: fieldName   ! In case we supply two
    character ( len=NameLen) :: my_description   ! In case mixed case
    logical, parameter :: DEEBUG = .false.
    ! Executable code
    returnStatus = 0
    my_description = lowercase(description)
    if ( my_description == 'geos5' ) &
      & my_description = GEOS5orMERRA( GriddedFile )
    if ( DEEBUG ) print *, 'Writing ' // trim(my_description) // ' data'

    do fieldIndex=1, size(the_g_data)
      call getStringElement(fieldNames, fieldName, fieldIndex, COUNTEMPTY)
      ! According to the kinds of gridded data files we can Write
      select case ( trim(my_description) )
      case ('geos5')
        call announce_error( lcf_where, 'WriteGriddedData called with illegal' &
          & // ' description: ' // trim(my_description) )
      case ('dao', 'gmao')
        call announce_error( lcf_where, 'WriteGriddedData called with illegal' &
          & // ' description: ' // trim(my_description) )
      case ('merra')
        call Write_merra( (fieldIndex==1), GriddedFile, lcf_where, &
          & the_g_data(fieldIndex), GeoDimList, fieldName )
      case ('ncep')
        call announce_error( lcf_where, 'WriteGriddedData called with illegal' &
          & // ' description: ' // trim(my_description) )
      case ('strat')
        call announce_error( lcf_where, 'WriteGriddedData called with illegal' &
          & // ' description: ' // trim(my_description) )
      case default
        call announce_error( lcf_where, 'WriteGriddedData called with unknown' &
          & // ' description: ' // trim(my_description) )
      end select
    end do
  end subroutine WriteGriddedData

  ! ----- utility procedures ----
  function GEOS5orMERRA( File ) result( fType )
    ! Attempt to identify file as
    ! (1) GEOS5, or
    ! (2) MERRA
    ! based on size of dims(4) of field "T"
    ! Arguments
    type(MLSFile_T)                :: File
    character(len=8)               :: fType
    ! Local Variables
    integer :: file_id, gd_id
    integer :: inq_success
    character (len=MAXLISTLENGTH) :: gridlist
    character (len=MAXLISTLENGTH), dimension(1) :: dimlists
    integer :: ngrids
    integer                        :: our_rank, numberType
    integer :: strbufsize
    integer, parameter :: GRIDORDER=1   ! What order grid written to file
    integer, parameter :: MAXNAMELENGTH=NameLen         ! Max length of grid name
    character (len=MAXNAMELENGTH) :: gridname
    integer, dimension(NENTRIESMAX) :: dims
    integer :: status
    logical, parameter :: DEEBUG = .false.
    ! Executable
    fType = 'geos5'
    gridlist = ''
    inq_success = gdinqgrid(File%Name, gridlist, strbufsize)
    if (inq_success < 0) then
      call announce_error( 0, "Could not inquire gridlist "// &
        & trim(File%Name) )
    else if ( strbufsize > MAXLISTLENGTH ) then
       CALL MLSMessage ( MLSMSG_Error, moduleName,  &
          & 'list size too big in Read_merra ' // trim(File%Name), MLSFile=File )
    else if ( strbufsize < MAXLISTLENGTH .and. strbufsize > 0 ) then
      gridlist = gridlist(1:strbufsize) // ' '
    end if
    file_id = gdopen(File%Name, DFACC_RDONLY)

    if (file_id < 0) then
      call announce_error( 0, "Could not open "// File%Name )
    end if
    ! Find grid name corresponding to the GRIDORDER'th one
    ngrids = NumStringElements(gridlist, COUNTEMPTY)

    if(ngrids <= 0) then
      call announce_error( 0, "NumStringElements of gridlist <= 0" )
    else if(ngrids /= inq_success) then 
      call announce_error( 0, "NumStringElements of gridlist /= inq_success" )
    else if(ngrids < GRIDORDER) then
      call announce_error( 0, "NumStringElements of gridlist < GRIDORDER" )
    end if

    call GetStringElement(gridlist, gridname, GRIDORDER, COUNTEMPTY)

    gd_id = gdattach(file_id, gridname)
    if (gd_id < 0) then
      call announce_error( 0, "Could not attach "//trim(gridname) )
    end if

    ! Now find the rank of our field
    inq_success = gdfldinfo(gd_id, 'T', our_rank, dims, &
      & numbertype, dimlists(1))

    if ( DEEBUG ) then
      print *, 'our_rank ', our_rank
      print *, 'dims ', dims(1:our_rank)
    end if

    if ( dims(4) > 1 ) then
      fType = 'merra'
    else
      fType = 'geos5'
    end if
    status = gddetach(gd_id)
    status = gdclose(file_id)
  end function GEOS5orMERRA
  
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: ncep_dao.f90,v 2.86 2017/07/10 18:22:46 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module ncep_dao

! $Log: ncep_dao.f90,v $
! Revision 2.86  2017/07/10 18:22:46  pwagner
! Correct arg to trace_end; preset noYear
!
! Revision 2.85  2017/03/07 21:17:35  pwagner
! The specific procedures for each origin type moved to a Utils module
!
! Revision 2.84  2017/01/13 01:29:47  pwagner
! Pre-initialize litDescription = 'none' in ReadGriddedData
!
! Revision 2.83  2016/09/22 22:22:47  pwagner
! Change message to acknowledge version may be later than geos5_7
!
! Revision 2.82  2016/07/28 01:42:27  vsnyder
! Refactoring dump and diff
!
! Revision 2.81  2015/03/28 00:56:14  vsnyder
! Stuff to trace allocate/deallocate addresses -- mostly commented out
! because NAG build 1017 doesn't yet allow arrays as arguments to C_LOC.
!
! Revision 2.80  2015/02/06 01:10:36  pwagner
! Added body missing from ReadGriddedData with filename api
!
! Revision 2.79  2014/09/06 00:05:02  pwagner
! Stores geost_7 lats in the_g_data after reading them
!
! Revision 2.78  2014/09/05 00:27:11  vsnyder
! More complete and accurate allocate/deallocate size tracking.  Add some
! tracing.
!
! Revision 2.77  2014/06/04 18:29:45  pwagner
! Account for memory usage accurately; allow deferReading
!
! Revision 2.76  2014/04/02 23:02:52  pwagner
! Removed redundant open_ and close_MLSFile
!
! Revision 2.75  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.74  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.73  2012/07/11 20:01:06  pwagner
! Dont use DEEBUG until after its defined
!
! Revision 2.72  2012/07/02 20:17:42  pwagner
! Protect against bounds error when debugging with NAG
!
! Revision 2.71  2012/05/15 16:53:06  pwagner
! Allocate first, then give values
!
! Revision 2.70  2012/05/08 17:46:05  pwagner
! Fixed bug that caused confusion when geos5 not ffound
!
! Revision 2.69  2012/03/06 19:33:11  pwagner
! Remove more unused things
!
! Revision 2.68  2012/03/01 20:00:35  pwagner
! When verbose, note when file does not fit description
!
! Revision 2.67  2011/11/30 21:28:23  pwagner
! Converted most debugging prints to verbose ones; more robust
!
! Revision 2.66  2011/08/30 22:23:46  pwagner
! Should not try to read as geos5_7 if not hdf5
!
! Revision 2.65  2011/08/03 22:50:03  pwagner
! Repaired syntax of write; removed unused variables; updated toc
!
! Revision 2.64  2011/08/03 15:36:23  honghanh
! Move one line of code around for better readability
!
! Revision 2.63  2011/08/02 17:26:37  honghanh
! Remove code that read time_increment attribute
!
! Revision 2.62  2011/08/02 17:23:59  honghanh
! Make datestarts and dateends the same.
!
! Revision 2.61  2011/08/02 16:48:51  honghanh
! Implement readgeos5_7
!
! Revision 2.60  2011/06/29 21:38:23  pwagner
! Uses output api
!
! Revision 2.59  2011/05/05 23:09:22  pwagner
! verbose when requested via optional arg
!
! Revision 2.58  2011/04/27 17:36:12  pwagner
! Consistently sets grid%empty when not found or wrong description
!
! Revision 2.57  2011/04/20 16:56:16  pwagner
! First steps toward being able to read next GMAO format
!
! Revision 2.56  2010/03/31 18:12:10  pwagner
! Added WriteGriddedData
!
! Revision 2.55  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.54  2009/11/04 23:16:49  pwagner
! Fixed bugs in recognizing and reading merra files
!
! Revision 2.53  2009/09/29 23:35:09  pwagner
! Changes needed by 64-bit build
!
! Revision 2.52  2009/08/17 16:52:19  pwagner
! From MERRA file may read DELP field and perform sum
!
! Revision 2.51  2009/06/23 18:25:43  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.50  2009/06/16 17:25:58  pwagner
! Removed most unused stuff
!
! Revision 2.49  2008/12/02 23:11:13  pwagner
! mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
!
! Revision 2.48  2008/09/17 23:21:19  pwagner
! Allow date string in gridded data to offset gmao background files
!
! Revision 2.47  2008/01/07 21:38:12  pwagner
! Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
!
! Revision 2.46  2007/06/21 00:49:52  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.45  2006/11/01 20:30:11  pwagner
! More unused debugging prints
!
! Revision 2.44  2006/06/13 22:11:45  pwagner
! Correctly sets units, heightsUnits
!
! Revision 2.43  2006/05/19 19:55:07  pwagner
! Corrected a misspelling Lahey missed
!
! Revision 2.42  2006/05/18 18:39:32  cvuu
! Add subroutine Read_geos5
!
! Revision 2.41  2006/05/12 21:25:56  pwagner
! verticalCoordinate now correctly set by read_dao
!
! Revision 2.40  2006/01/25 00:58:44  pwagner
! Cleared out some commented-out stuff
!
! Revision 2.39  2005/06/22 17:24:59  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.38  2005/06/14 20:37:06  pwagner
! Interfaces changed to accept MLSFile_T args
!
! Revision 2.37  2004/08/04 23:19:01  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.36  2004/08/03 17:59:35  pwagner
! Gets DEFAULTUNDEFINEDVALUE from MLSCommon
!
! Revision 2.35  2004/06/23 17:11:50  pwagner
! read_climatology now returns status, e.g. FILENOTFOUND
!
! Revision 2.34  2004/01/23 01:12:27  pwagner
! Some care taken in handling ...inq.. functions
!
! Revision 2.33  2003/10/06 13:30:40  cvuu
! Modified to handle reading the ncep data for origin=strat
!
! Revision 2.32  2003/06/03 20:42:25  pwagner
! Can read strat (ncep) files; untested
!
! Revision 2.31  2003/05/06 00:31:45  vsnyder
! Delete trailing blanks from two too-long-to-be-standard lines
!
! Revision 2.30  2003/04/04 18:34:22  pwagner
! Sets empty field if FILENOTFOUND
!
! Revision 2.29  2003/04/02 00:14:25  pwagner
! The 4th index is now noDates instead of ntime
!
! Revision 2.28  2003/03/01 00:23:27  pwagner
! missingValue an optional arg to reading GriddedData and climatology
!
! Revision 2.27  2003/02/28 02:27:12  livesey
! Now uses missingValue stuff
!
! Revision 2.26  2003/02/27 21:51:02  pwagner
! Commented out the last prints
!
! Revision 2.25  2003/02/27 18:38:49  pwagner
! Removed some intent(out); Lahey takes perverse delight in resetting such to undefined
!
! Revision 2.24  2003/02/21 21:01:06  pwagner
! Actually uses GeoDimList; filters Fill values
!
! Revision 2.23  2003/02/20 21:23:40  pwagner
! More successful; cant read metadata yet
!
! Revision 2.22  2003/02/19 19:14:16  pwagner
! Many changes; not perfect yet
!
! Revision 2.21  2002/11/22 12:57:59  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.20  2002/10/08 00:09:13  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.19  2002/02/05 04:13:43  livesey
! Minor bug fix
!
! Revision 2.18  2002/01/23 22:34:37  livesey
! Added ReadGloriaFile functionality
!
! Revision 2.17  2002/01/09 23:48:40  pwagner
! Added toc; each print became call output
!
! Revision 2.16  2001/10/26 23:14:37  pwagner
! Complies with Gridded data dump
!
! Revision 2.15  2001/09/10 23:37:10  livesey
! Tidied up a bit, moved much stuff to GriddedData.f90
!
! Revision 2.14  2001/07/12 22:03:55  livesey
! Some minor ish changes.  Needs an overhaul at some point.
!
! Revision 2.13  2001/06/04 23:57:40  pwagner
! Splits path from l2cf-defined file name before getPCfromRef
!
! Revision 2.12  2001/05/09 23:30:13  pwagner
! Detachable from toolkit
!
! Revision 2.11  2001/04/12 22:04:47  vsnyder
! Improve an error message
!
! Revision 2.10  2001/04/10 20:05:30  livesey
! Tidied up
!
! Revision 2.9  2001/03/30 00:26:19  pwagner
! Added source_file_already_read
!
! Revision 2.8  2001/03/29 00:51:03  pwagner
! AddGridTemplatetoDatabase now works
!
! Revision 2.7  2001/03/28 00:25:14  pwagner
! More changes, but not perfect yet
!
! Revision 2.6  2001/03/27 17:28:31  pwagner
! Can dump gridded database
!
! Revision 2.5  2001/03/24 00:29:32  pwagner
! Now seems to read climatology files better
!
! Revision 2.4  2001/03/21 00:47:29  pwagner
! Changes to READ_CLIMATOLOGY, announce_error
!
! Revision 2.3  2001/03/20 00:42:11  pwagner
! Improved Read_Climatology
!
! Revision 2.2  2001/03/15 21:40:30  pwagner
! Eliminated unused routines from USE statements
!
! Revision 2.1  2001/03/15 21:26:57  pwagner
! Moved non-l3ascii methods from GriddedData here
!
@


2.86
log
@Correct arg to trace_end; preset noYear
@
text
@d12 1
a12 1
module ncep_dao ! Collections of subroutines to handle Type GriddedData_T
d16 6
a21 12
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Bytes, &
    & Test_Allocate
  use, Intrinsic :: ISO_C_Binding, only: C_Intptr_T, C_Loc
  use Dump_0, Only : Dump
  use GriddedData, only: GriddedData_T, RGR, V_Is_Altitude, V_Is_GPH, &
    & V_Is_Pressure, V_Is_Theta, &
    & AddGriddedDataToDatabase, Dump, SetupNewGriddedData, NullifyGriddedData
  use HDFeos, only: HDFe_NentDim, &
    & GDOpen, GDAttach, GDDetach, GDClose, GDFldinfo, &
    & GDInqGrid, GDNentries, GDInqDims, GDInqFlds
  use HDF, only: Dfacc_Create, Dfacc_Rdonly, Dfacc_Rdwr, &
    & Dfnt_Float32, Dfnt_Float64
d24 5
a28 9
  use L3ASCII, only: L3ASCII_Read_Field
  use Lexer_Core, only: Print_Source
  use MLSCommon, only: LineLen, NameLen, FileNameLen, &
    & UndefinedValue, MLSFile_T
  use MLSFiles, only: FileNotFound, HDFversion_5, Dump, InitializeMLSFile, &
    & GetPCFromRef, MLS_HDF_Version, MLS_OpenFile, MLS_CloseFile, &
    & Split_Path_Name, MLS_OpenFile, MLS_CloseFile
  use MLSKinds, only: R4, R8
  use MLSMessagemodule, only: MLSMsg_Error, MLSMsg_Info, MLSMsg_Warning, &
d30 2
a31 3
  use MLSStrings, only: Capitalize, HHMMSS_Value, Lowercase
  use MLSStringlists, only: GetStringElement, NumStringElements, &
    & List2array, ReplaceSubstring, StringElementNum
d34 1
a34 1
    & Read_Climatology, Read_Dao, Read_Geos5_Or_Merra, Read_Merra_2, &
a36 5
  use SDPtoolkit, only: PGS_S_Success, &
    & PGS_Io_Gen_Closef, PGS_Io_Gen_Openf, PGSd_Io_Gen_Rseqfrm, &
    & PGSd_Gct_Inverse, &
    & UseSDPtoolkit
  use Tree, only: Dump_Tree_Node, Where
a67 3
  integer :: ERROR
  ! character(len=8) :: LIT_DESCRIPTION

d70 19
a88 18
  character (len=*), parameter :: DEFAULTDAODIMLIST = 'XDim,YDim,Height,Time'
  character (len=*), parameter :: DEFAULTDAOFIELDNAME = 'TMPU'
  character (len=*), parameter :: DEFAULTGEOS5FIELDNAME = 'T'
  character (len=*), parameter :: DEFAULTNCEPDIMLIST = 'YDim,XDim'
  character (len=*), parameter :: DEFAULTNCEPGRIDNAME = 'TMP_3'
  character (len=*), parameter :: DEFAULTNCEPSTRATFIELDNAME = 'Temperature'
  character (len=*), parameter :: GEO_FIELD1 = 'Latitude'
  character (len=*), parameter :: GEO_FIELD2 = 'Longitude'
  character (len=*), parameter :: GEO_FIELD3 = 'Height'
  character (len=*), parameter :: GEO_FIELD4 = 'Time'

  logical, parameter :: GEOS5MAYBEMERRATOO = .false. ! Causes confusion if true

  character (len=*), parameter :: lit_dao = 'dao'
  character (len=*), parameter :: lit_ncep = 'ncep'
  character (len=*), parameter :: lit_strat = 'strat'
  character (len=*), parameter :: lit_clim = 'clim'
  character (len=*), parameter :: lit_geos5 = 'geos5'
d91 2
a92 2
  integer, parameter ::          MAXDS = 1024 ! 500
  integer, parameter ::          MAXSDNAMESBUFSIZE = MAXDS*NAMELEN
a476 1
    logical,  parameter       :: CASESENSITIVE = .false.
d540 1
a540 1
       "$Id: ncep_dao.f90,v 2.85 2017/03/07 21:17:35 pwagner Exp $"
d550 3
@


2.85
log
@The specific procedures for each origin type moved to a Utils module
@
text
@d186 1
d360 1
a360 1
    call trace_end ( "rprocessOneAprioriFile", &
d559 1
a559 1
       "$Id: ncep_dao.f90,v 2.84 2017/01/13 01:29:47 pwagner Exp $"
d569 3
@


2.84
log
@Pre-initialize litDescription = 'none' in ReadGriddedData
@
text
@d12 1
a12 1
module ncep_dao ! Collections of subroutines to handle TYPE GriddedData_T
d14 2
d18 4
a21 4
  use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
  use Dump_0, only : Dump
  use GriddedData, only: GriddedData_t, RGR, V_is_Altitude, V_is_GPH, &
    & V_is_Pressure, V_is_Theta, &
d26 2
a27 2
  use HDF, only: dfacc_create, dfacc_rdonly, dfacc_rdwr, &
    & dfnt_float32, dfnt_float64
d29 1
a29 1
  use intrinsic, only: L_HDFeos
d32 2
a33 2
  use MLScommon, only: LineLen, NameLen, FileNameLen, &
    & UndefinedValue, MLSfile_t
d35 4
a38 4
    & GetPCFromRef, MLS_HDF_version, MLS_openfile, MLS_closefile, &
    & Split_Path_Name, MLS_openfile, MLS_closefile
  use MLSkinds, only: R4, R8
  use MLSMessagemodule, only: MLSMsg_error, MLSMsg_info, MLSMsg_warning, &
d40 2
a41 2
  use MLSstrings, only: Capitalize, HHMMSS_Value, Lowercase
  use MLSstringlists, only: GetStringElement, NumStringElements, &
d43 8
a50 4
  use output_m, only: output
  use SDPtoolkit, only: PGS_s_success, &
    & PGS_io_gen_closef, PGS_io_gen_openf, PGSd_io_gen_rseqfrm, &
    & PGSd_gct_inverse, &
d54 1
a54 1
  implicit NONE
a67 1
! read_climatology     read l3ascii-formatted climatology file
a69 1
! ReadGloriaFile       read binary-formatted file designed by G. Manney
d76 1
a80 1
  public:: read_climatology
d85 1
a85 1
  character(len=8) :: LIT_DESCRIPTION
d122 2
a123 1
  ! which may be one of 'geos5_7', 'geos5', 'gmao', 'dao', 'merra', 'ncep', 'strat'
d141 1
a141 1
    use MLSStats1, only: MLSMIN, MLSMAX, MLSMEAN
d143 1
a143 1
    use Trace_m, only: TRACE_BEGIN, TRACE_END
d147 2
a148 2
    integer, intent(IN)                     :: lcf_where    ! node of the lcf that provoked me         
    integer, intent(IN)                     :: v_type       ! vertical coordinate; an 'enumerated' type
d150 1
a150 1
    character (LEN=*), intent(IN)           :: description ! e.g., 'dao'
d152 6
a157 6
    character (LEN=*), intent(IN)           :: GeoDimList ! Comma-delimited dim names
    character (LEN=*), intent(IN)           :: fieldNames ! Name of gridded field
    real(rgr), optional, intent(IN)         :: missingValue
    character (LEN=*), optional, intent(IN) :: date ! offset
    logical, optional, intent(IN)           :: sumDelp ! sum the DELP to make PL
    logical, optional, intent(IN)           :: deferReading ! don't read yet
d159 1
a159 1
    logical, optional, intent(IN)           :: verbose
a176 6
    ! The following once allowed us to describe both geos5-classic and merra
    ! reanalysis with the same griddedorigin field='geos5'
    ! However, we have since seen the light: that trick was a later
    ! source of confusion--we will eventually simply remove litDescription
    if ( LIT_DESCRIPTION == 'geos5' .and. GEOS5MAYBEMERRATOO ) &
      & LIT_DESCRIPTION = GEOS5orMERRA( GriddedFile )
d210 1
a210 1
    case ('geos5_7') ! Actually 5.7 or later; netCDF4 format
d216 1
a216 1
          & 'Not an hdf5 file so could not be geos 5.7.x' )
d220 7
a226 2
      call Read_geos5_7( GriddedFile, lcf_where, v_type, &
        & the_g_data, GeoDimList, fieldName, date, sumDelp )
d232 1
a232 1
        call output( '(Returned from read_geos5_7 or later)', advance='yes' )
d244 1
a244 1
    case ('geos5')
d353 2
a354 2
      call announce_error(lcf_where, 'ReadGriddedData_MLSFile called with unknown' &
        & // ' description: ' // trim(LIT_DESCRIPTION))
d369 3
a371 3
    character (LEN=*), intent(IN)           :: FileName
    integer, intent(IN)                     :: lcf_where    ! node of the lcf that provoked me         
    integer, intent(IN)                     :: v_type       ! vertical coordinate; an 'enumerated' type
d373 1
a373 1
    character (LEN=*), intent(IN)           :: description ! e.g., 'dao'
d375 6
a380 6
    character (LEN=*), intent(IN)           :: GeoDimList ! Comma-delimited dim names
    character (LEN=*), intent(IN)           :: fieldNames ! Name of gridded field
    real(rgr), optional, intent(IN)         :: missingValue
    character (LEN=*), optional, intent(IN) :: date ! offset
    logical, optional, intent(IN)           :: sumDelp ! sum the DELP to make PL
    logical, optional, intent(IN)           :: deferReading ! don't read yet
d382 1
a382 1
    logical, optional, intent(IN)           :: verbose
a396 1933
  ! ----------------------------------------------- Read_GEOS5_7
  subroutine Read_GEOS5_7( GEOS5File, lcf_where, v_type, &
    & the_g_data, GeoDimList, fieldName, date, sumDelp )

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Dates_module, only: UTC2TAI93s
    use Dump_1, only: Dump
    use HDF5, only: Hsize_t
    use MLSHDF5, only: GetAllHDF5DSNames, &
      & GetHDF5DSRank, gethDF5DSDims, LoadFromHDF5DS, &
      & ReadHDF5Attribute
    use MLSStringLists, only: SwitchDetail
    use Toggles, only: Switches

    ! This routine reads a gmao geos5_7 file, named something like
    ! DAS.ops.asm.avg3_3d_Nv.GEOS571.20110930_0300.V01.nc4 (pressure with

    ! This file is formatted in the following way:
    ! At each gridded quantity, e.g. EOSGRID,
    ! a rank 4 field, e.g. T, is given with dimensions
    ! 'Time, Height, YDim, XDim'
    ! We'll simply copy it into a single gridded data type

    ! Arguments
    type(MLSFile_T)                :: GEOS5file
    integer, intent(IN) :: lcf_where    ! node of the lcf that provoked me
    integer, intent(IN) :: v_type       ! vertical coordinate; an 'enumerated' type
    type( GriddedData_T ) :: the_g_data ! Result
    character (LEN=*), optional, intent(IN) :: GeoDimList ! Comma-delimited dim names
    character (LEN=*), optional, intent(IN) :: fieldName ! Name of gridded field
    character (LEN=*), optional, intent(IN) :: date ! date (offset)
    logical, optional, intent(IN)           :: sumDelp ! sum the DELP to make PL
    ! Local variables
    character (len=NAMELEN) :: actual_field_name
    integer(c_intptr_t) :: Addr         ! For tracing
    character(len=19) :: datestring ! will be in the form of yyyy-MM-ddTHH:MM:ss
    logical :: DEEBUG
    integer(kind=hsize_t) :: dim1(1), dim4(4)
    integer :: error, rank
    character(len=256) :: errormsg
    integer :: i1, i2, i3            ! looping indexes
    integer, dimension(4) :: idim4
    character (len=MAXSDNAMESBUFSIZE) :: mySdList
    integer :: S                     ! Size in bytes of an object to deallocate
    real(r8), dimension(:), pointer :: temp1d => null()
    real(r8), dimension(:,:,:,:), pointer :: temp4d => null()
    character(len=16) :: the_units
    real(r4), parameter :: FILLVALUE = 1.e15 !this value might be wrong
    integer :: mydate, mytime, year, month, day, hour, minute, second
    logical :: verbose

    ! Executable
    if(present(fieldName)) then
      actual_field_name=fieldName
    else
      actual_field_name=DEFAULTGEOS5FIELDNAME
    end if
    nullify( temp1d, temp4d )
    DEEBUG = ( index(lowercase(actual_field_name), 'inq') > 0 )
    verbose = ( switchDetail(switches, 'geos5') > -1 ) .or. DEEBUG
    call GetAllHDF5DSNames ( GEOS5File%Name, '/', mysdList )
    if ( verbose ) call dump( mysdList, 'DS names' )

    ! Fill in value
    the_g_data%quantityName = actual_field_name
    the_g_data%description = lit_geos5
    the_g_data%verticalCoordinate = v_type
    the_g_data%nodates = 1
    the_g_data%empty = .true.
    the_g_data%missingvalue = FILLVALUE ! this value might be wrong
    call allocate_test ( the_g_data%lsts, 1, "the_g_data%lsts", moduleName )
    the_g_data%lsts = the_g_data%missingvalue
    the_g_data%nolsts = 1
    the_g_data%noszas = 1
    the_g_data%lsts = the_g_data%missingValue ! Know how to read this yet?
    call allocate_test ( the_g_data%szas, 1, "the_g_data%szas", moduleName )
    the_g_data%szas = the_g_data%missingvalue

    call mls_openfile(geos5File, error)
    if (error .gt. 0) call announce_error(lcf_where, "Could not open "// GEOS5File%Name)

    ! Get lons
    call GetHDF5DSRank (geos5file%fileid%f_id, 'lon', rank)
    if (rank /= 1) call announce_error(lcf_where, "lon must be a 1-dim array: "// GEOS5File%Name)

    call GetHDF5DSDims(geos5file%fileid%f_id, 'lon', dim1)
    the_g_data%noLons = dim1(1)

    call allocate_test ( temp1d, the_g_data%noLons, "temp1d", moduleName )

    call LoadFromHDF5DS (geos5file%fileid%f_id, 'lon', temp1d)
    call allocate_test ( the_g_data%lons, the_g_data%nolons, "the_g_data%nolons", &
      & moduleName )
    the_g_data%lons = temp1d
    s = size(temp1d) * storage_size(temp1d) / 8
    call deallocate_test ( temp1d, "temp1d", moduleName )

    ! Fill dateStart and dateEnd
    mytime = 0. ! In case it's not found
    if (.not. ReadHDF5Attribute(geos5file%fileid%f_id, 'time', &
        & 'begin_time', mytime, error=errormsg)) then
        call announce_error (lcf_where, errormsg // ' in file ' &
        & // geos5file%name)
    end if

    if ( mytime < 0 ) then
      call announce_error (lcf_where, "Invalid 'begin_time' value in " // geos5file%name)
    end if

    !if (.not. ReadHDF5Attribute(geos5file%fileid%f_id, 'time', &
    !    & 'time_increment', timeinc, error=errormsg)) then
    !    call announce_error (lcf_where, errormsg // ' in file ' &
    !    & // geos5file%name)
    !end if

    !if (timeinc <= 0) then
    !    call announce_error (lcf_where, "Invalid 'time_increment' value in " // geos5file%name)
    !end if

    mydate = 10000*2001 + 1*100 + 1 ! In case it's not found
    if (.not. ReadHDF5Attribute(geos5file%fileid%f_id, 'time', &
        & 'begin_date', mydate, error=errormsg)) then
        call announce_error (lcf_where, errormsg // ' in file ' &
        & // geos5file%name)
    end if

    if (mydate < 0) then
        call announce_error (lcf_where, "Invalid 'begin_date' value in " // geos5file%name)
    end if

    year = mydate / 10000
    month = mod(mydate, 10000) / 100
    day = mod(mydate, 100)
    if (year > 9999 .or. month > 12 .or. month < 1 .or. day > 31 .or. day < 1) then
        call announce_error (lcf_where, "Invalid 'begin_date' value in " // geos5file%name)
    end if    
    
    hour = mytime / 10000
    minute = mod (mytime, 10000) / 100
    second = mod(mytime, 100)
    if (hour > 24 .or. minute > 60 .or. second > 60) then
        call announce_error (lcf_where, "Invalid 'begin_time' value in " // geos5file%name)
    end if

    write ( datestring, &
      & '(I4.4, A1,   I2.2,  A1, I2.2,  A1, I2.2, A1,  I2.2,    A1, I2.2)') &
      &   year, '-',  month, '-', day, 'T', hour, ':', minute, ':', second

    call allocate_test ( the_g_data%datestarts, the_g_data%nodates, &
      & "the_g_data%datestarts", moduleName )
    call allocate_test ( the_g_data%dateends, the_g_data%nodates, &
      & "the_g_data%dateends", moduleName )

    the_g_data%datestarts(1) = utc2tai93s(datestring)

    !hour = timeinc / 10000
    !minute = mod(timeinc, 10000) / 100
    !second = mod(timeinc, 100)
    !if (hour > 24 .or. minute > 60 .or. second > 60) then
    !    call announce_error (lcf_where, "Invalid 'time_increment' value in " // geos5file%name)
    !end if

    !the_g_data%dateends(1) = the_g_data%datestarts(1) + hour * 3600 + minute * 60 + second
    the_g_data%dateends(1) = the_g_data%datestarts(1) ! start and end are the same

    ! Get lats
    call GetHDF5DSRank (geos5file%fileid%f_id, 'lat', rank)
    if (rank /= 1) call announce_error(lcf_where, "lat must be a 1-dim array: " // geos5file%name)

    call GetHDF5DSDims(geos5file%fileid%f_id, 'lat', dim1)
    the_g_data%noLats = dim1(1)

    call allocate_test ( temp1d, the_g_data%nolats, "temp1d", moduleName )

    call LoadFromHDF5DS (geos5file%fileid%f_id, 'lat', temp1d)
    call allocate_test ( the_g_data%lats, the_g_data%nolats, "the_g_data%lats", &
      & moduleName )
    the_g_data%lats = temp1d
    call deallocate_test ( temp1d, "temp1d", moduleName )

    ! Get heights
    call GetHDF5DSRank (geos5file%fileid%f_id, 'lev', rank)
    if (rank /= 1) call announce_error(lcf_where, "lev must be a 1-dim array: " // geos5file%name)
    
    call GetHDF5DSDims (geos5file%fileid%f_id, 'lev', dim1)
    the_g_data%noheights = dim1(1)

    call allocate_test ( temp1d, the_g_data%noheights, "temp1d", moduleName )
    
    call LoadFromHDF5DS (geos5file%fileid%f_id, 'lev', temp1d)
    call allocate_test ( the_g_data%heights, the_g_data%noheights, &
      & "the_g_data%heights", moduleName )
    
    ! We cannot load directly into the the_g_data's array because
    ! this is an array of 32-bit float, while the data from file is
    ! 64-bit float
    the_g_data%heights = temp1d
    call deallocate_test ( temp1d, "temp1d", moduleName )

    the_g_data%heightsunits = 'hPa' ! the units is according the file_specification

    ! The following is according to GEOS-5.7.2 file specification
    select case ( lowercase(actual_field_name) )
    case ( 'pl' )
        the_units = 'Pa'
    case ( 't' )
        the_units = 'K'
    case default
        call announce_error(lcf_where, "Unexpected data: " // actual_field_name)
    end select
    
    the_g_data%units = the_units

    ! read the field, field should be either PL or T
    call GetHDF5DSRank (geos5file%fileid%f_id, capitalize(actual_field_name), rank)
    if (rank /= 4) then
        call announce_error (lcf_where, &
        capitalize(actual_field_name) // " must be a 3-dim array: " // geos5file%name)
    end if

    call GetHDF5DSDims (geos5file%fileid%f_id, capitalize(actual_field_name), dim4)
    if (dim4(4) /= 1) then
        call announce_error(geos5file%fileid%f_id, &
        "The fourth dimension of " // actual_field_name // " is not 1 in: " // geos5file%name)
    end if
    idim4 = dim4

    call allocate_test ( temp4d, idim4(1), idim4(2), idim4(3), idim4(4), &
        & 'temp4d', ModuleName // 'Read_geos57' )

    call LoadFromHDF5DS (geos5file%fileid%f_id, capitalize(actual_field_name), temp4d)

    ! call allocate_test ( the_g_data%field(:,:,:,1,1,1), idim4(1:3), &
    !     & 'the_g_data%field', ModuleName // 'Read_geos57' )
    allocate ( the_g_data%field(idim4(3), idim4(2), idim4(1), 1, 1, 1), STAT=error)
    addr = 0
    if ( error == 0 ) then
      if ( size(the_g_data%field) > 0 ) addr = transfer(c_loc( &
        & the_g_data%field(1,1,1,1,1,1)), addr)
    end if
    call test_allocate ( error, moduleName, 'the_g_data%field', (/1,1,1,1,1,1/), &
      & (/ idim4(3), idim4(2), idim4(1), 1, 1, 1 /), bytes(the_g_data%field), &
      & address=addr )
    the_g_data%field(:,:,:,1,1,1) = reshape(temp4d(:,:,:,1), order=(/3,2,1/), &
    shape=(/the_g_data%noheights, the_g_data%nolats, the_g_data%nolons/))
    !  do i1 = 1, idim4(1)
    !    do i2 = 1, idim4(2)
    !      do i3 = 1, idim4(3)
    !        the_g_data%field(i3,i2,i1,1,1,1) = temp4d(i1,i2,i3,1)
    !      end do
    !    end do
    !  end do
    call deallocate_test ( temp4d, 'temp4d', ModuleName // 'Read_geos57' )
    
    ! Read file successful
    the_g_data%empty = .false.
    call mls_closefile(geos5File, error)
    if (error .gt. 0) call announce_error(lcf_where, "Could not close "// GEOS5File%Name)
    if ( verbose ) call dump( the_g_data, details = 1 )
  end subroutine Read_GEOS5_7

  ! ----------------------------------------------- Read_GEOS5_or_Merra
  subroutine Read_GEOS5_or_Merra( GEOS5File, lcf_where, v_type, &
    & the_g_data, GeoDimList, fieldName, date, sumDelp )

    ! This routine reads a gmao GEOS5 or MERRA file, named something like
    ! DAS.ops.asm.tavg3d_prs_v.GEOS500.20060320_0000.V01 (pressure with
    ! fieldname='PL') or 
    ! DAS.ops.asm.tavg3d_dyn_v.GEOS500.20060320_0000.V01 (temperature
    ! with fieldname='T') or
    ! MERRA300.prod.assim.inst6_3d_ana_Nv.20050131.hdf (pressure with
    ! fieldname='DELP' or 'T')
    ! returning a filled data
    ! structure appropriate for older geos5 or newer style gmao merra

    ! FileName and the_g_data are required args
    ! GeoDimList, if present, should be the Dimensions' short names
    ! as a comma-delimited character string in the order:
    ! longitude, latitude, vertical level, time

    ! fieldName, if present, should be the rank 4
    ! like temperature

    ! This file is formatted in the following way:
    ! At each gridded quantity, e.g. EOSGRID,
    ! a rank 4 field, e.g. T, is given with dimensions
    ! 'Time, Height, YDim, XDim'
    ! We'll simply copy it into a single gridded data type
    
    ! Arguments
    type(MLSFile_T)                :: GEOS5file
    integer, intent(IN) :: lcf_where    ! node of the lcf that provoked me
    integer, intent(IN) :: v_type       ! vertical coordinate; an 'enumerated' type
    type( GriddedData_T ) :: the_g_data ! Result
    character (LEN=*), optional, intent(IN) :: GeoDimList ! Comma-delimited dim names
    character (LEN=*), optional, intent(IN) :: fieldName ! Name of gridded field
    character (LEN=*), optional, intent(IN) :: date ! date (offset)
    logical, optional, intent(IN)           :: sumDelp ! sum the DELP to make PL

    ! Local Variables
    integer :: itime, ilat, ilon, ilev
    integer :: file_id, gd_id
    integer :: inq_success
    integer :: nentries, ngrids, ndims, nfields
    integer :: strbufsize
    logical,  parameter       :: CASESENSITIVE = .false.
    integer, parameter :: GRIDORDER=1   ! What order grid written to file
    character (len=MAXLISTLENGTH) :: gridlist
    character (len=MAXLISTLENGTH) :: dimlist, actual_dim_list
    character (len=MAXLISTLENGTH), dimension(1) :: dimlists
    character (len=16), dimension(NENTRIESMAX) :: dimNames
    character (len=MAXLISTLENGTH) :: fieldlist
    integer, parameter :: MAXNAMELENGTH=NameLen         ! Max length of grid name
    character (len=MAXNAMELENGTH) :: gridname, actual_field_name
    integer, dimension(NENTRIESMAX) :: dims, rank, numberTypes
    integer                        :: our_rank, numberType
    logical                        :: mySum

    integer :: start(4), stride(4), edge(4)
    integer :: status
    character(len=16) :: the_units
    integer                        :: timeIndex
    !                                  These start out initialized to one
    integer                        :: nlon=1, nlat=1, nlev=1, ntime=1
    integer, parameter             :: i_longitude=1
    integer, parameter             :: i_latitude=i_longitude+1
    integer, parameter             :: i_vertical=i_latitude+1
    integer, parameter             :: i_time=i_vertical+1
    integer, external :: GDRDFLD
    real(r4), parameter :: FILLVALUE = 1.e15
    real(r4), dimension(:,:,:,:), pointer :: all_the_fields => null()
    real(r8), dimension(:), pointer :: dim_field, pb
    real(r8) :: dateValue
    logical :: DEEBUG
    ! Executable code
    dateValue = 0.
    if ( present(date) ) dateValue = HHMMSS_value( date, status )
    if(present(fieldName)) then
      actual_field_name=fieldName
    else
      actual_field_name=DEFAULTGEOS5FIELDNAME
    end if
    
    DEEBUG = ( index(lowercase(actual_field_name), 'inq') > 0 )
    
    ! We need the timeIndex as an offset for merra files
    timeIndex = int(1.5 + (dateValue - 1.)/(6*60*60)) ! How many quarter-days?
    if ( DEEBUG ) then
      print *, 'date (s) ', dateValue
      print *, 'time index ', timeIndex
    end if
    mySum = .false.
    if ( present(sumDelp) ) mySum = sumDelp
    ! Find list of grid names on this file (This has been core dumping on me)
    if(DEEBUG) print *, 'About to find grid list of file ', trim(GEOS5File%Name)
    gridlist = ''
    inq_success = gdinqgrid(GEOS5File%Name, gridlist, strbufsize)
    if (inq_success < 0) then
      call announce_error(lcf_where, "Could not inquire gridlist "// &
        & trim(GEOS5File%Name))
    else if ( strbufsize > MAXLISTLENGTH ) then
       CALL MLSMessage ( MLSMSG_Error, moduleName,  &
          & 'list size too big in Read_GEOS5_or_Merra ' // trim(GEOS5File%Name), MLSFile=GEOS5File )
    else if ( strbufsize < MAXLISTLENGTH .and. strbufsize > 0 ) then
      gridlist = gridlist(1:strbufsize) // ' '
    end if
    if(DEEBUG) print *, 'grid list ', trim(gridlist)

    error = 0
    file_id = gdopen(GEOS5File%Name, DFACC_RDONLY)

    if (file_id < 0) then
      call announce_error(lcf_where, "Could not open "// GEOS5File%Name)
    end if

    ! Find grid name corresponding to the GRIDORDER'th one
    ngrids = NumStringElements(gridlist, COUNTEMPTY)

    if(ngrids <= 0) then
      call announce_error(lcf_where, "NumStringElements of gridlist <= 0")
    else if(ngrids /= inq_success) then
      call announce_error(lcf_where, "NumStringElements of gridlist /= inq_success")
    else if(ngrids < GRIDORDER) then
      call announce_error(lcf_where, "NumStringElements of gridlist < GRIDORDER")
    end if

    call GetStringElement(gridlist, gridname, GRIDORDER, COUNTEMPTY)

    gd_id = gdattach(file_id, gridname)
    if (gd_id < 0) then
      call announce_error(lcf_where, "Could not attach "//trim(gridname))
    end if

    ! Now find dimsize(), dimname(), etc.
    nentries = gdnentries(gd_id, HDFE_NENTDIM, strbufsize)

    if(nentries <= 0) then
      call announce_error(lcf_where, "nentries of gd_id <= 0")
    else if(nentries > NENTRIESMAX) then
      call announce_error(lcf_where, "nentries of gd_id > NENTRIESMAX")
    end if

    dimlist = ''
    ndims = gdinqdims(gd_id, dimlist, dims)

    if(ndims <= 0) then
      call announce_error(lcf_where, "ndims of gd_id <= 0")
    else if(ndims > NENTRIESMAX) then
      call announce_error(lcf_where, "ndims of gd_id > NENTRIESMAX")
    end if

    fieldlist = ''
    nfields = gdinqflds(gd_id, fieldlist, rank, numberTypes)

    if(nfields <= 0) then
      call announce_error(lcf_where, "nfields of gd_id <= 0")
    else if(nfields > NENTRIESMAX) then
      call announce_error(lcf_where, "nfields of gd_id > NENTRIESMAX")
    end if

    if(.not. CASESENSITIVE) then
      fieldlist = Capitalize(fieldlist)
    end if

    if(DEEBUG) print *, 'nentries ', nentries
    if(DEEBUG) print *, 'ndims ', ndims
    if(DEEBUG) print *, 'dimlist ', dimlist
    if(DEEBUG) print *, 'nfields ', nfields
    if(DEEBUG) print *, 'fieldlist ', fieldlist
    if(DEEBUG) print *, 'actual_field_name ', actual_field_name

    actual_dim_list = ' '
    if(present(GeoDimList)) then
      actual_dim_list=GeoDimList
    end if
    if ( actual_dim_list == ' ' ) then
      actual_dim_list = DEFAULTDAODIMLIST
    end if
    call List2Array (actual_dim_list, dimNames, countEmpty)

    ! Check that our requested field is present
    ! We might, after all, have been doing an 'inq'
    if ( &
      & StringElementNum( fieldlist, trim(actual_field_name), COUNTEMPTY )&
      &  < 1 ) then
      the_g_data%empty = .true.
      call output( trim(actual_field_name) // ' not found in ' // &
        & trim(GEOS5File%Name), advance='yes' )
      call outputNamedValue( 'fieldList', trim(fieldlist) )
      status = gddetach(gd_id)
      if(status /= 0) &
        & call announce_error(lcf_where, "failed to detach from grid " &
        & //trim(gridname))
      status = gdclose(file_id)
      if(status /= 0) &
        & call announce_error(lcf_where, "failed to close file " //trim(GEOS5File%Name))
        return
    end if
    ! Now find the rank of our field
    inq_success = gdfldinfo(gd_id, trim(actual_field_name), our_rank, dims, &
      & numbertype, dimlists(1))

    if ( inq_success /= PGS_S_SUCCESS ) then
      the_g_data%empty = .true.
      CALL MLSMessage ( MLSMSG_Warning, moduleName,  &
        & trim(actual_field_name) // ' was inq_fail ' // trim(GEOS5File%Name) )
      return
    end if
    dimlist = trim(dimlists(1))
    if(DEEBUG) print *, 'our_rank ', our_rank
    if(DEEBUG) print *, 'dims ', dims(1:our_rank)
    if(DEEBUG) print *, 'dimlist ', dimlist

    nlon = dims(1)
    nlat = dims(2)
    nlev = dims(3)
    ntime = dims(4)

    the_g_data%quantityName = actual_field_name
    the_g_data%description = lit_geos5
    the_g_data%verticalCoordinate = v_type

    the_g_data%noLons = nlon
    the_g_data%noLats = nlat
    the_g_data%noHeights = nlev
    ! the_g_data%noLsts = ntime
    if ( LIT_DESCRIPTION == lit_geos5 ) then
      the_g_data%noDates = ntime
      if ( ntime > 1 ) then
        the_g_data%empty = .true.
        CALL MLSMessage ( MLSMSG_Info, moduleName,  &
          & 'Was apparently not geos5 ' // trim(GEOS5File%Name) )
        return
      end if
    else
      the_g_data%noDates = 1
    end if
    ! The following is an awful hack
    ! to prevent me from the having to read the units attribute
    select case ( lowercase(actual_field_name) )
    case ( 'pl', 'delp' )
      the_units = 'Pa'
    case ( 't' )
      the_units = 'K'
    case default
      the_units = 'Pa'
    end select
    if(DEEBUG) print *, 'our quantity name ', the_g_data%quantityName
    if(DEEBUG) print *, 'our description ', the_g_data%description
    if(DEEBUG) print *, 'our units ', the_units
    if(DEEBUG) print *, 'our vertical coord ', the_g_data%verticalCoordinate
    if(DEEBUG) print *, 'v_type ', v_type

    ! Setup the grid
    call SetupNewGriddedData ( the_g_data, noHeights=nlev, noLats=nlat, &
      & noLons=nlon, noLsts=1, noSzas=1, noDates=the_g_data%noDates, &
      & missingValue=FILLVALUE, units=the_units, verticalCoordinate=v_type, &
      & heightsunits='hPa' )
    if(DEEBUG) print *, '(Again) our quantity name ', the_g_data%quantityName
    if(DEEBUG) print *, 'our description ', the_g_data%description
    if(DEEBUG) print *, 'our units ', the_g_data%units
    if(DEEBUG) print *, 'our vertical coord ', the_g_data%verticalCoordinate
    if(DEEBUG) print *, 'v_type ', v_type
    if(DEEBUG) print *, 'About to allocate ', dims(1:4)
    call allocate_test( all_the_fields, dims(1), dims(2), dims(3), dims(4), &
        & 'all_the_fields', ModuleName // 'Read_GEOS5_or_Merra' )
    all_the_fields = the_g_data%missingValue
    start = 0                                                             
    stride = 1                                                               
    edge = dims(1:4)                                                        
    if(DEEBUG) print *, 'About to read ' // trim(actual_field_name)
    if(DEEBUG) print *, 'Start ', Start
    if(DEEBUG) print *, 'Stride ', Stride
    if(DEEBUG) print *, 'Edge ', Edge
    status = gdrdfld(gd_id, trim(actual_field_name), start, stride, edge, &  
      & all_the_fields)                                                          
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to read field " &
      & //trim(actual_field_name))
    if ( mySum ) then
      ! If we are so asked
      ! Sum up all the delps, starting from the top of the atmosphere
      nullify(pb)
      call allocate_test( pb, nlev+1, 'pb', &
        & ModuleName // 'Read_GEOS5_or_Merra' )
      do itime=1, ntime
        do ilat=1, nlat
          do ilon=1, nlon
            pb = 0.0
            ! pb(nlev+1) = 1.0 ! We must assume the topmost level is 1 hPa
            ! do ilev=nlev, 1, -1
            !  pb(ilev) = pb(ilev+1) + all_the_fields(ilon, ilat, ilev, itime)
            pb(1) = 1.0 ! We must assume the topmost level is 1 hPa
            do ilev=1, nlev
              pb(ilev+1) = pb(ilev) + all_the_fields(ilon, ilat, ilev, itime)
            end do
            do ilev=1, nlev
              all_the_fields(ilon, ilat, ilev, itime) = &
                & 0.5*( pb(ilev) + pb(ilev+1) )
            end do
          end do
        end do
      end do
      call deallocate_test( pb, 'pb', &
        & ModuleName // 'Read_GEOS5_or_Merra' )
    end if
    ! The actual dimlist is this                    XDim,YDim,Height,TIME
    ! Need to reshape it so that the order becomes: Height,YDim,XDim,TIME
    if ( DEEBUG) then
      print *, LIT_DESCRIPTION // ' Before reshaping'
      call dump(all_the_fields(:,1,1,1), 'x-slice')
      call dump(all_the_fields(1,:,1,1), 'y-slice')
      call dump(all_the_fields(1,1,:,1), 'p-slice')
      call dump(all_the_fields(1,1,1,:), 't-slice')
    end if
    if ( LIT_DESCRIPTION == lit_geos5 ) then
      ! GEOS5 format
      the_g_data%field(:,:,:,1,1,:) = reshape( all_the_fields, &
        & shape=(/nLev, nlat, nlon, ntime/), order=(/3,2,1,4/) &
        & )
    else if ( size(all_the_fields, 4) < 2 ) then
      ! Claimed to be MERRA (but array size says otherwise)
      the_g_data%empty = .true.
      call output( trim(actual_field_name) // ' had the wrong size (field, 4) ' // &
        & trim(GEOS5File%Name), advance='yes' )
      call deallocate_test( all_the_fields, 'all_the_fields', &
        & ModuleName // 'Read_GEOS5_or_Merra' )
      deallocate(the_g_data%field, STAT=status)
      if ( status /= 0 ) &
        & call announce_error( lcf_where, "failed to deallocate field" )
      return
    else
      ! MERRA format
      the_g_data%field(:,:,:,1,1,1) = reshape( all_the_fields(:,:,:,timeIndex), &
        & shape=(/nLev, nlat, nlon/), order=(/3,2,1/) &
        & )
    end if
    if ( DEEBUG ) then
      print *, LIT_DESCRIPTION // ' After reshaping'
      call dump(the_g_data%field(1,1,:,1,1,1), 'x-slice')
      call dump(the_g_data%field(1,:,1,1,1,1), 'y-slice')
      call dump(the_g_data%field(:,1,1,1,1,1), 'p-slice')
      call dump(the_g_data%field(1,1,1,:,1,1), 't-slice')
    end if
    call deallocate_test( all_the_fields, 'all_the_fields', &
        & ModuleName // 'Read_GEOS5_or_Merra' )
    ! Now read the dims
    nullify(dim_field)
    ! call read_the_dim(gd_id, 'XDim', dims(1), dim_field)
    call read_the_dim(gd_id, trim(dimNames(1)), dims(1), dim_field)
    the_g_data%lons = dim_field
    ! call read_the_dim(gd_id, 'YDim', dims(2), dim_field)
    call read_the_dim(gd_id, trim(dimNames(2)), dims(2), dim_field)
    the_g_data%lats = dim_field
    ! call read_the_dim(gd_id, 'Height', dims(3), dim_field)
    call read_the_dim(gd_id, trim(dimNames(3)), dims(3), dim_field)
    the_g_data%Heights = dim_field
    ! call read_the_dim(gd_id, 'Time', dims(4), dim_field)
    call read_the_dim(gd_id, trim(dimNames(4)), dims(4), dim_field)
    ! the_g_data%lsts = dim_field
    ! Because GMAO background files have no date field
    if ( all(dim_field == 0._r8) ) then
      the_g_data%dateStarts = dateValue
      the_g_data%dateEnds = dateValue
    else if (LIT_DESCRIPTION == lit_geos5 ) then
      the_g_data%dateStarts = dim_field
      the_g_data%dateEnds = dim_field
    else
      the_g_data%dateStarts = dim_field(timeIndex)
      the_g_data%dateEnds = dim_field(timeIndex)
    end if
    if ( DEEBUG ) then
      call dump(the_g_data%dateStarts, 'dateStarts')
      call dump(the_g_data%dateEnds, 'dateEnds')
    end if
    call deallocate_test ( dim_field, "dim_field", moduleName )
    ! Have not yet figured out how to assign these
    ! Probably will have to read metadata
    the_g_data%Szas = the_g_data%missingValue
    ! the_g_data%DateStarts = the_g_data%missingValue
    ! the_g_data%DateEnds = the_g_data%missingValue
    the_g_data%lsts = the_g_data%missingValue
    ! Close grid
    status = gddetach(gd_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to detach from grid " &
      & //trim(gridname))
    status = gdclose(file_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to close file " //trim(GEOS5File%Name))
  contains 
    subroutine read_the_dim(gd_id, field_name, field_size, values)
      ! Arguments
      integer, intent(in) :: gd_id
      character(len=*), intent(in) :: field_name
      integer, intent(in) :: field_size
      real(r8), dimension(:), pointer :: values
      ! Local variables
      integer :: status
      integer, dimension(1) :: start, stride, edge
      ! Executable
      call allocate_test ( values, field_size, "values", moduleName )
      start = 0                                                             
      stride = 1                                                             
      edge = field_size                                                       
      values = the_g_data%missingValue
      status = gdrdfld(gd_id, trim(field_name), start, stride, edge, &
        & values)                                                     
      if ( status /= 0 ) &
        & call announce_error(lcf_where, "failed to read dim field " &
        & // trim(field_name))
    end subroutine read_the_dim
  end subroutine Read_GEOS5_or_Merra

  ! ---------------------------------------------------  Read_DAO  -----
  subroutine Read_DAO(DAOFile, lcf_where, v_type, &
    & the_g_data, GeoDimList, fieldName)

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test

    ! What was once called 'dao' now better known as 'gmao'
    ! This routine reads a gmao file, named something like
    ! DAS.flk.asm.tsyn3d_mis_p.GEOS401.2003011800.2003011818.V01
    ! returning a filled data
    ! structure appropriate for newer style dao
    ! (And just how does it differ from the older style? 
    !  For one thing it holds 4-d, not 3-d fields)

    ! FileName and the_g_data are required args
    ! GeoDimList, if present, should be the Dimensions' short names
    ! as a comma-delimited character string in the order:
    ! longitude, latitude, vertical level, time

    ! fieldName, if present, should be the rank 4
    ! like temperature

    ! This file is formatted in the following way:
    ! At each gridded quantity, e.g. EOSGRID,
    ! a rank 4 field, e.g. TMPU, is given with dimensions
    ! 'Time, Height, YDim, XDim'
    ! We'll simply copy it into a single gridded data type

    ! Arguments
    type(MLSFile_T)                :: DAOFile
    integer, intent(IN) :: lcf_where    ! node of the lcf that provoked me
    integer, intent(IN) :: v_type       ! vertical coordinate; an 'enumerated' type
    type( GriddedData_T ) :: the_g_data ! Result
    character (LEN=*), optional, intent(IN) :: GeoDimList ! Comma-delimited dim names
    character (LEN=*), optional, intent(IN) :: fieldName ! Name of gridded field

    ! Local Variables
    integer :: file_id, gd_id
    integer :: inq_success
    integer :: nentries, ngrids, ndims, nfields
    integer :: strbufsize
    logical,  parameter       :: CASESENSITIVE = .false.
    integer, parameter :: GRIDORDER=1   ! What order grid written to file
    character (len=MAXLISTLENGTH) :: gridlist
    character (len=MAXLISTLENGTH) :: dimlist, actual_dim_list
    character (len=MAXLISTLENGTH), dimension(1) :: dimlists
    character (len=16), dimension(NENTRIESMAX) :: dimNames
    character (len=MAXLISTLENGTH) :: fieldlist
    integer, parameter :: MAXNAMELENGTH=NameLen         ! Max length of grid name
    character (len=MAXNAMELENGTH) :: gridname, actual_field_name
    integer, dimension(NENTRIESMAX) :: dims, rank, numberTypes
    integer                        :: our_rank, numberType

    integer :: start(4), stride(4), edge(4)
    integer :: status
    !                                  These start out initialized to one
    integer                        :: nlon=1, nlat=1, nlev=1, ntime=1
    integer, parameter             :: i_longitude=1
    integer, parameter             :: i_latitude=i_longitude+1
    integer, parameter             :: i_vertical=i_latitude+1
    integer, parameter             :: i_time=i_vertical+1
    integer, external :: GDRDFLD
    real(r4), parameter :: FILLVALUE = 1.e15
    real(r4), dimension(:,:,:,:), pointer :: all_the_fields
    real(r8), dimension(:), pointer :: dim_field
    logical, parameter :: DEEBUG = .false.
    ! Executable code
    ! Find list of grid names on this file (This has been core dumping on me)
    if(DEEBUG) print *, 'About to find grid list of file ', trim(DAOFile%Name)
    gridlist = ''
    inq_success = gdinqgrid(DAOFile%Name, gridlist, strbufsize)
    if (inq_success < 0) then
      call announce_error(lcf_where, "Could not inquire gridlist "// &
        & trim(DAOFile%Name))
    else if ( strbufsize > MAXLISTLENGTH ) then
       CALL MLSMessage ( MLSMSG_Error, moduleName,  &
          & 'list size too big in Read_DAO ' // trim(DAOFile%Name), MLSFile=DAOFile )
    else if ( strbufsize < MAXLISTLENGTH .and. strbufsize > 0 ) then
      gridlist = gridlist(1:strbufsize) // ' '
    end if
    if(DEEBUG) print *, 'grid list ', trim(gridlist)

    error = 0
    file_id = gdopen(DAOFile%Name, DFACC_RDONLY)

    if (file_id < 0) then
      call announce_error(lcf_where, "Could not open "// DAOFile%Name)
    end if

    ! Find grid name corresponding to the GRIDORDER'th one
    ngrids = NumStringElements(gridlist, COUNTEMPTY)

    if(ngrids <= 0) then
      call announce_error(lcf_where, "NumStringElements of gridlist <= 0")
    else if(ngrids /= inq_success) then
      call announce_error(lcf_where, "NumStringElements of gridlist /= inq_success")
    else if(ngrids < GRIDORDER) then
      call announce_error(lcf_where, "NumStringElements of gridlist < GRIDORDER")
    end if

    call GetStringElement(gridlist, gridname, GRIDORDER, COUNTEMPTY)

    gd_id = gdattach(file_id, gridname)
    if (gd_id < 0) then
      call announce_error(lcf_where, "Could not attach "//trim(gridname))
    end if

    ! Now find dimsize(), dimname(), etc.
    nentries = gdnentries(gd_id, HDFE_NENTDIM, strbufsize)

    if(nentries <= 0) then
      call announce_error(lcf_where, "nentries of gd_id <= 0")
    else if(nentries > NENTRIESMAX) then
      call announce_error(lcf_where, "nentries of gd_id > NENTRIESMAX")
    end if

    dimlist = ''
    ndims = gdinqdims(gd_id, dimlist, dims)

    if(ndims <= 0) then
      call announce_error(lcf_where, "ndims of gd_id <= 0")
    else if(ndims > NENTRIESMAX) then
      call announce_error(lcf_where, "ndims of gd_id > NENTRIESMAX")
    end if

    fieldlist = ''
    nfields = gdinqflds(gd_id, fieldlist, rank, numberTypes)

    if(nfields <= 0) then
      call announce_error(lcf_where, "nfields of gd_id <= 0")
    else if(nfields > NENTRIESMAX) then
      call announce_error(lcf_where, "nfields of gd_id > NENTRIESMAX")
    end if

    if(.not. CASESENSITIVE) then
      fieldlist = Capitalize(fieldlist)
    end if

    if(present(fieldName)) then
      actual_field_name=fieldName
    else
      actual_field_name=DEFAULTDAOFIELDNAME
    end if

    actual_dim_list = ' '
    if(present(GeoDimList)) then
      actual_dim_list=GeoDimList
    end if
    if ( actual_dim_list == ' ' ) then
      actual_dim_list = DEFAULTDAODIMLIST
    end if
    call List2Array (actual_dim_list, dimNames, countEmpty)

    ! Now find the rank of our field
    inq_success = gdfldinfo(gd_id, trim(actual_field_name), our_rank, dims, &
      & numbertype, dimlists(1))

    dimlist = trim(dimlists(1))
    if(DEEBUG) print *, 'our_rank ', our_rank
    if(DEEBUG) print *, 'dims ', dims(1:our_rank)
    if(DEEBUG) print *, 'dimlist ', dimlist

    nlon = dims(1)
    nlat = dims(2)
    nlev = dims(3)
    ntime = dims(4)

    the_g_data%quantityName = actual_field_name
    the_g_data%description = lit_dao
    the_g_data%verticalCoordinate = v_type

    the_g_data%noLons = nlon
    the_g_data%noLats = nlat
    the_g_data%noHeights = nlev
    ! the_g_data%noLsts = ntime
    the_g_data%noDates = ntime
    the_g_data%units = 'K'
    if(DEEBUG) print *, 'our quantity name ', the_g_data%quantityName
    if(DEEBUG) print *, 'our description ', the_g_data%description
    if(DEEBUG) print *, 'our units ', the_g_data%units
    if(DEEBUG) print *, 'our vertical coord ', the_g_data%verticalCoordinate
    if(DEEBUG) print *, 'v_type ', v_type

    ! Setup the grid
    call SetupNewGriddedData ( the_g_data, noHeights=nlev, noLats=nlat, &
      & noLons=nlon, noLsts=1, noSzas=1, noDates=ntime, &
      & missingValue=FILLVALUE, units='K', verticalCoordinate=v_type, &
      & heightsunits='hPa' )
      ! & noLons=nlon, noLsts=ntime, noSzas=1, noDates=1, missingValue=FILLVALUE )
    if(DEEBUG) print *, '(Again) our quantity name ', the_g_data%quantityName
    if(DEEBUG) print *, 'our description ', the_g_data%description
    if(DEEBUG) print *, 'our units ', the_g_data%units
    if(DEEBUG) print *, 'our vertical coord ', the_g_data%verticalCoordinate
    if(DEEBUG) print *, 'v_type ', v_type
    nullify ( all_the_fields )
    call allocate_test ( all_the_fields, dims(1), dims(2), dims(3), dims(4), &
      & "all_the_fields", moduleName )
    all_the_fields = the_g_data%missingValue
    start = 0                                                             
    stride = 1                                                               
    edge = dims(1:4)                                                        
    if(DEEBUG) print *, 'About to read ' // trim(actual_field_name)
    if(DEEBUG) print *, 'Start ', Start
    if(DEEBUG) print *, 'Stride ', Stride
    if(DEEBUG) print *, 'Edge ', Edge
    status = gdrdfld(gd_id, trim(actual_field_name), start, stride, edge, &  
      & all_the_fields)                                                          
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to read field " &
      & //trim(actual_field_name))
    ! The actual dimlist is this                    XDim,YDim,Height,TIME
    ! Need to reshape it so that the order becomes: Height,YDim,XDim,TIME
    if ( DEEBUG) then
      print *, 'dao Before reshaping'
      call dump(all_the_fields(:,1,1,1), 'x-slice')
      call dump(all_the_fields(1,:,1,1), 'y-slice')
      call dump(all_the_fields(1,1,:,1), 'p-slice')
      call dump(all_the_fields(1,1,1,:), 't-slice')
    end if
    ! the_g_data%field(:,:,:,:,1,1) = reshape( all_the_fields, &
    the_g_data%field(:,:,:,1,1,:) = reshape( all_the_fields, &
      & shape=(/nLev, nlat, nlon, ntime/), order=(/3,2,1,4/) &
      & )
    if ( DEEBUG ) then
      print *, 'dao After reshaping'
      call dump(the_g_data%field(1,1,:,1,1,1), 'x-slice')
      call dump(the_g_data%field(1,:,1,1,1,1), 'y-slice')
      call dump(the_g_data%field(:,1,1,1,1,1), 'p-slice')
      call dump(the_g_data%field(1,1,1,:,1,1), 't-slice')
    end if
    call deallocate_test ( all_the_fields, "all_the_fields", moduleName )
    ! Now read the dims
    nullify(dim_field)
    ! call read_the_dim(gd_id, 'XDim', dims(1), dim_field)
    call read_the_dim(gd_id, trim(dimNames(1)), dims(1), dim_field)
    the_g_data%lons = dim_field
    ! call read_the_dim(gd_id, 'YDim', dims(2), dim_field)
    call read_the_dim(gd_id, trim(dimNames(2)), dims(2), dim_field)
    the_g_data%lats = dim_field
    ! call read_the_dim(gd_id, 'Height', dims(3), dim_field)
    call read_the_dim(gd_id, trim(dimNames(3)), dims(3), dim_field)
    the_g_data%Heights = dim_field
    ! call read_the_dim(gd_id, 'Time', dims(4), dim_field)
    call read_the_dim(gd_id, trim(dimNames(4)), dims(4), dim_field)
    ! the_g_data%lsts = dim_field
    the_g_data%dateStarts = dim_field
    the_g_data%dateEnds = dim_field
    call deallocate_test ( dim_field, "dim_field", moduleName )
    ! Have not yet figured out how to assign these
    ! Probably will have to read metadata
    the_g_data%Szas = the_g_data%missingValue
    ! the_g_data%DateStarts = the_g_data%missingValue
    ! the_g_data%DateEnds = the_g_data%missingValue
    the_g_data%lsts = the_g_data%missingValue
    ! Close grid
    status = gddetach(gd_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to detach from grid " &
      & //trim(gridname))
    status = gdclose(file_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to close file " //trim(DAOFile%Name))
  contains 
     subroutine read_the_dim(gd_id, field_name, field_size, values)
       ! Arguments
       integer, intent(in) :: gd_id
       character(len=*), intent(in) :: field_name
       integer, intent(in) :: field_size
       real(r8), dimension(:), pointer :: values
       ! Local variables
       integer :: status
       integer, dimension(1) :: start, stride, edge
       ! Executable
       call allocate_test ( values, field_size, "values", moduleName )
       start = 0                                                             
       stride = 1                                                             
       edge = field_size                                                       
       values = the_g_data%missingValue
       status = gdrdfld(gd_id, trim(field_name), start, stride, edge, &
         & values)                                                     
       if ( status /= 0 ) &
         & call announce_error(lcf_where, "failed to read dim field " &
         & // trim(field_name))
     end subroutine read_the_dim
  end subroutine Read_DAO

  ! ---------------------------------------------  Read_NCEP_GDAs  -----
  subroutine Read_NCEP_GDAs ( NCEPFile, lcf_where, v_type, &
    & the_g_data, GeoDimList, gridName, missingValue )

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test

    ! This routine reads a ncep global assimilation model product
    ! (GDAS) file, named something like
    ! 6207ea2e-1dd2-11b2-b61e-ae069991db9a.hdfeos 
    ! returning a filled data structure appropriate for it

    ! FileName and the_g_data are required args
    ! GeoDimList, if present, should be the Dimensions' short names
    ! as a comma-delimited character string in the order:
    ! longitude, latitude, vertical level, time

    ! fieldName, if present, should be the rank 2 object
    ! like temperature
    
    ! This file is formatted in the following way:
    ! At each gridded quantity, e.g. TMP_3,
    ! a series of 2d slices at a fixed pressure surface are
    ! given as fields, with names like "ISOBARIC LEVEL AT 975 (hPa)"
    ! We will read them, stacking them up in a single gridded data type
    
    ! ncep is peculiar in 3 other ways:
    ! (1) It has 0 entries
    ! (2) It has 0 dimensions
    ! (3) (Related to 2) The lats and lons have to be inferred, not read

    ! Arguments
    type(MLSFile_T)                :: NCEPFile
    integer, intent(IN) :: lcf_where    ! node of the lcf that provoked me
    integer, intent(IN) :: v_type       ! vertical coordinate
    type( GriddedData_T ) :: the_g_data ! Result
    character (LEN=*), optional, intent(IN) :: GeoDimList ! E.g., 'X.Y,..'
    character (LEN=*), optional, intent(IN) :: gridName ! Name of grid
    real(rgr), optional, intent(IN) :: missingValue

    ! Local Variables
    integer :: file_id, gd_id
    integer :: inq_success
    integer :: nentries, ndims, nfields
    integer :: strbufsize
    character(len=NameLen) :: my_gridname
    integer, parameter :: MAXLISTLENGTH=10*Linelen ! Max length list grid names
    character (len=MAXLISTLENGTH), dimension(1) :: dimlists
    character (len=MAXLISTLENGTH) :: fieldlist
    character (len=MAXLISTLENGTH) :: gridlist
    character (len=MAXLISTLENGTH) :: dimlist
    integer, parameter :: MAXNAMELENGTH=NameLen         ! Max length of grid name
    character (len=MAXNAMELENGTH) :: actual_field_name
    integer, dimension(NENTRIESMAX) :: dims, rank, numberTypes
    integer                        :: our_rank, numberType

    integer :: start(2), stride(2), edge(2)
    integer :: status
    integer :: field
    !                                  These start out initialized to one
    integer                        :: nlon=1, nlat=1, nlev=1
    integer, parameter             :: i_longitude=1
    integer, parameter             :: i_latitude=i_longitude+1
    integer, parameter             :: i_vertical=i_latitude+1
    integer, parameter             :: i_time=i_vertical+1
    integer, external :: GDRDFLD
    logical, parameter :: USEPROJECTFORDIMS = .false. ! This doesn't work, yet
    real(r4), dimension(:), pointer     :: pressures
    real(r4), dimension(:,:), pointer   :: field_data
    real(r4), dimension(:,:,:), pointer :: all_the_fields, now_the_fields
    real(r8) :: pressure
    integer :: xdimsize, ydimsize
    real(r8), dimension(2) :: upLeft, lowRight
    real(r8), dimension(15) :: projParams
    integer :: projcode, zonecode, spherecode, directioncode
    integer :: i
    integer, external :: gdgridinfo, GDprojinfo, PGS_GCT_Init
    integer, parameter :: Lon_offset = -180  ! Longitude start in degrees
    integer, parameter :: Lat_offset = -90   ! Latitude start in degrees
    real(r4), parameter :: FILLVALUE = 0.e0
    logical, parameter :: CHECKFORDIMSANYWAY = .false.
    logical, parameter :: DEEBUG = .false.
    ! Executable
    projParams = 0.d0
    my_gridname = DEFAULTNCEPGRIDNAME
    if ( present(gridname) ) my_gridname = gridname
    ! Don't find list of grid names on this file --because it dumped core on me
    gridlist = ''
    inq_success = 0 ! inq_success = gdinqgrid(FileName, gridlist, strbufsize)
    error = 0
    file_id = gdopen(NCEPFile%name, DFACC_RDONLY)
    if(DEEBUG) print *, 'fileID: ', file_id

    if (file_id < 0) then
      call announce_error(lcf_where, "Could not open "// NCEPFile%name)
    end if

    gd_id = gdattach(file_id, my_gridname)
    if(DEEBUG) print *, 'gridID: ', gd_id
    if (gd_id < 0) then
      call announce_error(lcf_where, "Could not attach "//trim(my_gridname))
    end if

    if ( USEPROJECTFORDIMS ) then
      ! Projection info
      status = GDprojinfo(gd_id, projcode, zonecode, spherecode, projParams)
      if (status /= 0) then
        call announce_error(lcf_where, "Could not get info on projection")
      end if
      if(DEEBUG) print *, 'projcode: ', projcode
      if(DEEBUG) print *, 'zonecode: ', zonecode
      if(DEEBUG) print *, 'spherecode: ', spherecode
      if(DEEBUG) print *, 'projParams: ', projParams
      directioncode = PGSd_GCT_INVERSE
      status = PGS_GCT_Init(projcode, projParams, directioncode)
      if (status /= 0) then
        call announce_error(lcf_where, "Could not initialize gct")
      end if
    end if
    ! Now find dimsize(), dimname(), etc.
    ! ncep file don't have entries, nor dims
    if ( CHECKFORDIMSANYWAY ) then
      nentries = gdnentries(gd_id, HDFE_NENTDIM, strbufsize)

      if(nentries <= 0) then
        call announce_error(lcf_where, "nentries of gd_id <= 0", &
          & 'nentries:', nentries)
      else if(nentries > NENTRIESMAX) then
        call announce_error(lcf_where, "nentries of gd_id > NENTRIESMAX", &
          & 'nentries:', nentries)
      end if

      dimlist = ''
      ndims = gdinqdims(gd_id, dimlist, dims)

      if(ndims <= 0) then
        call announce_error(lcf_where, "ndims of gd_id <= 0", &
          & 'ndims:', ndims)
      else if(ndims > NENTRIESMAX) then
        call announce_error(lcf_where, "ndims of gd_id > NENTRIESMAX", &
          & 'ndims:', ndims)
      end if
    end if

    status = gdgridinfo(gd_id, xdimsize, ydimsize, &
      & upLeft, lowRight )

    if(status /= 0) then
      call announce_error(lcf_where, "failed to obtain gridinfo", &
        & 'status:', status)
    end if
    if(DEEBUG) print *, 'xdimsize: ', xdimsize
    if(DEEBUG) print *, 'ydimsize: ', ydimsize
    if(DEEBUG) print *, 'upLeft  : ', upLeft
    if(DEEBUG) print *, 'lowRight: ', lowRight

    fieldlist = ''
    nfields = gdinqflds(gd_id, fieldlist, rank, numberTypes)
    if(DEEBUG) print *, 'nfields: ', nfields

    if(nfields <= 0) then
      call announce_error(lcf_where, "nfields of gd_id <= 0", &
        & 'nfields:', nfields)
      return
    else if(nfields > NENTRIESMAX) then
      call announce_error(lcf_where, "nfields of gd_id > NENTRIESMAX", &
        & 'nfields:', nfields)
      return
    end if

    the_g_data%noHeights = 0
    nullify ( pressures )
    call allocate_test ( pressures, nfields, "pressures", moduleName )
    ! Loop over data fields
    nullify ( all_the_fields, now_the_fields )
    do field=1, nfields
      call getStringElement(fieldlist, actual_field_name, field, .false.)
      if(DEEBUG) print *, 'actual_field_name: ', trim(actual_field_name)
      if ( actual_field_name == ' ' ) cycle
      call ncepFieldNameTohPa(trim(actual_field_name), pressure)
      if(DEEBUG) print *, 'inferred pressure: ', pressure
      if ( pressure < 0._r8 ) cycle
      ! Now find the rank of our field
      inq_success = gdfldinfo(gd_id, trim(actual_field_name), our_rank, dims, &
        & numbertype, dimlists(1))

      if ( our_rank /= 2 ) then
        call announce_error(lcf_where, "rank /= 2")
        cycle
      end if
      call allocate_test ( field_data, dims(1), dims(2), "field_data", moduleName )
      
      field_data = the_g_data%missingValue
      dimlist = trim(dimlists(1))

      nlon = dims(1)
      nlat = dims(2)

      the_g_data%quantityName = my_gridname
      the_g_data%description = lit_ncep
      the_g_data%verticalCoordinate = v_type

      the_g_data%noLons = nlon
      the_g_data%noLats = nlat
      the_g_data%noHeights = the_g_data%noHeights + 1
      pressures(the_g_data%noHeights) = pressure
      start(1) = 0
      start(2) = 0
      stride = 1
      edge(1) = dims(1)
      edge(2) = dims(2)
      status = gdrdfld(gd_id, trim(actual_field_name), start, stride, edge, &
        & field_data)
      if(status /= 0) &
        & call announce_error(lcf_where, "failed to read field " &
        & //trim(actual_field_name))
      ! call dump(field_data(1,:), trim(actual_field_name))
      ! Assemble the_fields into 3-d array all_the_fields
      if (the_g_data%noHeights == 1) then
        call allocate_test ( all_the_fields, 1, dims(1), dims(2), "all_the_fields", &
          & moduleName )
        all_the_fields(1, :, :) = field_data
      else
        call allocate_test ( now_the_fields, the_g_data%noHeights, dims(1), dims(2), &
          & "now_the_fields", moduleName )
        now_the_fields(1:the_g_data%noHeights - 1, :, :) = all_the_fields
        now_the_fields(the_g_data%noHeights, :, :) = field_data
        call deallocate_test ( all_the_fields, "all_the_fields", moduleName )
        all_the_fields => now_the_fields
      end if
      call deallocate_test ( field_data, "field_data", moduleName )
    end do
    the_g_data%noLsts = 0
    the_g_data%units = 'K'
    if(DEEBUG) print *, 'our quantity name ', the_g_data%quantityName
    if(DEEBUG) print *, 'our description ', the_g_data%description
    if(DEEBUG) print *, 'our units ', the_g_data%units

    ! Setup the grid
    nLev = the_g_data%noHeights
    if(DEEBUG) print *, 'NoHeights: ', nLev
    if(DEEBUG) print *, 'NoLons   : ', nLon
    if(DEEBUG) print *, 'NoLats   : ', nLat
    call SetupNewGriddedData ( the_g_data, noHeights=nlev, noLats=nlat, &
      & noLons=nlon, noLsts=1, noSzas=1, noDates=1 )
    if(DEEBUG) print *, '(Again) our quantity name ', the_g_data%quantityName
    if(DEEBUG) print *, 'our description ', the_g_data%description
    if(DEEBUG) print *, 'our units ', the_g_data%units
    ! The dimlist as stacked up is this             Height,XDim,YDim
    ! Need to reshape it so that the order becomes: Height,YDim,XDim
    if(DEEBUG) then
      print *, 'Before reshaping'
      call dump(all_the_fields(1,:,1), 'x-slice')
      call dump(all_the_fields(1,1,:), 'y-slice')
      call dump(all_the_fields(:,1,1), 'p-slice')
    end if
    the_g_data%field(:,:,:,1,1,1) = reshape( all_the_fields, &
      & shape=(/nLev, nlat, nlon/), order=(/1, 3, 2/) &
      & )
    if(DEEBUG) then
      print *, 'After reshaping'
      call dump(the_g_data%field(1,1,:,1,1,1), 'x-slice')
      call dump(the_g_data%field(1,:,1,1,1,1), 'y-slice')
      call dump(the_g_data%field(:,1,1,1,1,1), 'p-slice')
    end if
    the_g_data%heights = pressures(1:the_g_data%noHeights)
    call deallocate_test ( all_the_fields, "all_the_fields", moduleName )
    call deallocate_test ( pressures, "pressures", moduleName )

    ! Insert code to transform upLeft and LowRight
    ! info into lats and lons
    if ( USEPROJECTFORDIMS ) then
      call announce_error(lcf_where, "Read_NCEP_GDAs unable to use projection")
    else
    ! Now read the dims
    !  But .. they aren't there!
      do i=1, xdimsize
        the_g_data%lons(i) = i - 1 + Lon_offset
      end do
      do i=1, ydimsize
        the_g_data%lats(i) = i - 1 + Lat_offset
      end do
    end if
    ! Have not yet figured out how to assign these
    ! Probably will have to read metadata
    the_g_data%lsts = the_g_data%missingValue
    the_g_data%Szas = the_g_data%missingValue
    the_g_data%DateStarts = the_g_data%missingValue
    the_g_data%DateEnds = the_g_data%missingValue

    ! Close grid
    status = gddetach(gd_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to detach from grid " // &
      & trim(my_gridname))
    status = gdclose(file_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to close file " //trim(NCEPFile%name))
  contains 
     subroutine read_the_dim ( gd_id, field_name, field_size, values )
       ! Arguments
       integer, intent(in) :: gd_id
       character(len=*), intent(in) :: field_name
       integer, intent(in) :: field_size
       real(r4), dimension(:), pointer :: values
       ! Local variables
       integer :: status
       integer, dimension(1) :: start, stride, edge
       ! Executable
       call allocate_test ( values, field_size, "values", moduleName )
       start = 0                                                             
       stride = 1                                                             
       edge = field_size
       values = the_g_data%missingValue
       status = gdrdfld(gd_id, trim(field_name), start, stride, edge, &
         & values)                                                     
       if ( status /= 0 ) &
         & call announce_error(lcf_where, "failed to read dim field " &
         & // trim(field_name))
     end subroutine read_the_dim
  end subroutine Read_NCEP_GDAs

  ! --------------------------------------------  Read_NCEP_Strat  -----
  subroutine Read_NCEP_Strat(NCEPFile, lcf_where, v_type, &
    & the_g_data, GeoDimList, fieldName)
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use hdfeos5, only: he5_hdfe_nentdim, he5f_acc_rdonly, &
      & he5_gdopen, he5_gdattach, he5_gddetach, he5_gdclose, &
      & he5_gdnentries, he5_gdinqgrid, he5_gdinqdims, he5_gdinqflds, &
      & he5_gdfldinfo, he5_gdgridinfo
    use mlshdfeos, only: hsizes
    use hdf5, only: SIZE_T

    ! This routine reads a ncep stratospheric combined product file,
    ! named something like nmct_030126.he5
    ! returning a filled data structure appropriate for it

    ! FileName and the_g_data are required args
    ! GeoDimList, if present, should be the Dimensions' short names
    ! as a comma-delimited character string in the order:
    ! longitude, latitude, vertical level, time

    ! The file itself determines which data field, e.g., Temperature,
    ! is being defined
    
    ! fieldName, if present, should be a character string matching one of the
    ! fields in the grid: {'Temperature', 'Moisture', 'Height'}
    
    ! gridName, if present, should be a character string matching one of the
    ! grids in the file: {'NorthernHemisphere', 'SouthernHemisphere'}
    
    ! This file is formatted in the following way:
    ! At each gridded quantity, e.g. /NorthernHemisphere/Temperature,
    ! a Polar stereographic projection is defined

    ! Arguments
    type(MLSFile_T)                :: NCEPFile
    integer, intent(IN) :: lcf_where    ! node of the lcf that provoked me
    integer, intent(IN) :: v_type       ! vertical coordinate
    type( GriddedData_T ) :: the_g_data ! Result
    character (LEN=*), optional, intent(IN) :: GeoDimList ! E.g., 'X.Y,..'
    character (LEN=*), optional, intent(IN) :: fieldName  ! Name of grid quant.

    ! Local Variables
    integer :: file_id
    integer :: gd_id(2)
    integer :: inq_success
    integer :: nentries, ngrids, ndims, nfields
    integer(kind=size_t) :: strbufsize
    logical,  parameter       :: CASESENSITIVE = .false.
    integer, parameter :: GRIDORDER=1   ! What order grid written to file
    character (len=MAXLISTLENGTH) :: gridlist
    character (len=MAXLISTLENGTH) :: dimlist, actual_dim_list
    character (len=MAXLISTLENGTH), dimension(1) :: dimlists
    character (len=MAXLISTLENGTH), dimension(1) :: maxdimlists
    character (len=16), dimension(NENTRIESMAX) :: dimNames
    character (len=MAXLISTLENGTH), dimension(2) :: names
    character (len=MAXLISTLENGTH) :: fieldlist
    integer, parameter :: MAXNAMELENGTH=NameLen         ! Max length of grid name
    character (len=MAXNAMELENGTH) :: actual_field_name
    integer, dimension(NENTRIESMAX) :: rank, numberTypes
    integer(kind=size_t), dimension(NENTRIESMAX) :: dims
    integer                        :: our_rank, numberType
    integer, dimension(NENTRIESMAX,NENTRIESMAX) :: dims_temp

    integer :: start(3), stride(3), edge(3)
    integer :: status, j
    !                                  These start out initialized to one
    integer                        :: nlon=0, nlat=0, nlev=0, ntime=1
    integer, parameter             :: i_longitude=1
    integer, parameter             :: i_latitude=i_longitude+1
    integer, parameter             :: i_vertical=i_latitude+1
    integer, parameter             :: i_time=i_vertical+1
    real(r4), parameter :: FILLVALUE = 1.e15
    !real(r4), dimension(:,:,:,:), pointer :: all_the_fields
    real(r4), dimension(:,:,:), pointer :: all_the_fields
    real(r4), dimension(:,:,:), pointer :: t_all_fields
    logical, parameter :: DEEBUG = .false.
    real(r8):: upleftpt(2), lowrightpt(2)
    integer :: i
    integer(kind=size_t) :: xdimsize=1, ydimsize=2
    integer, parameter :: Lon_offset = -180  ! Longitude start in degrees
    integer, parameter :: Lat_offset = -90   ! Latitude start in degrees
    integer :: fdims3, sdims3

    ! Some day we'll get all these from MLSHDFEOS
    integer, external :: he5_gdrdfld
    ! Executable code
    ! Find list of grid names on this file (This has been core dumping on me)
    if(DEEBUG) print *, 'About to find grid list of file ', trim(NCEPFile%name)
    gridlist = ''
    inq_success = he5_gdinqgrid(NCEPFile%name, gridlist, strbufsize)
    if (inq_success < 0) then
      call announce_error(lcf_where, &
        & "Could not inquire gridlist "// trim(NCEPFile%name))
    else if ( strbufsize > MAXLISTLENGTH ) then
       CALL MLSMessage ( MLSMSG_Error, moduleName,  &
          & 'list size too big in Read_ncep ' // trim(NCEPFile%name), MLSFile=NCEPFile )
    else if ( strbufsize < MAXLISTLENGTH .and. strbufsize > 0 ) then
      gridlist = gridlist(1:strbufsize) // ' '
    end if

    if(DEEBUG) print *, 'grid list ', trim(gridlist)
    error = 0

    file_id = he5_gdopen(NCEPFile%name, HE5F_ACC_RDONLY)
    if (file_id < 0) then
      call announce_error(lcf_where, "Could not open "// NCEPFile%name)
    end if

    ! Find grid name corresponding to the GRIDORDER'th one
    ngrids = NumStringElements(gridlist, COUNTEMPTY)
    if(ngrids <= 0) then
      call announce_error(lcf_where, "NumStringElements of gridlist <= 0")
    else if(ngrids /= inq_success) then
      call announce_error(lcf_where, &
        & "NumStringElements of gridlist /= inq_success")
    else if(ngrids < GRIDORDER) then
      call announce_error(lcf_where, &
        & "NumStringElements of gridlist < GRIDORDER")
    end if

    !if ( present(gridName) ) then
    !    mygridname = gridName
    !else
      !call GetStringElement(gridlist, mygridname, GRIDORDER, COUNTEMPTY)
    !end if
    do i=1, ngrids
      call GetStringElement(gridlist, names(i), i, COUNTEMPTY)
      if (DEEBUG) print *,'name = ', trim(names(i))
        gd_id(i) = he5_gdattach(file_id, trim(names(i)))
      if (gd_id(i) < 0) then
          !call announce_error(lcf_where,"Could not attach "//trim(mygridname))
        call MLSMessage (MLSMSG_Warning, ModuleName, & 
          & "Could not attach "//trim(names(i)))
           exit 
      end if
        !Now find dimsize(), dimname(), etc.
        nentries = he5_gdnentries(gd_id(i), HE5_HDFE_NENTDIM, strbufsize)

        if(nentries <= 0) then
          call announce_error(lcf_where, "nentries of gd_id <= 0")
        else if(nentries > NENTRIESMAX) then
           call announce_error(lcf_where, "nentries of gd_id > NENTRIESMAX")
        end if

        dimlist = ''
        ndims = he5_gdinqdims(gd_id(i), dimlist, dims)
        if(ndims <= 0) then
           call announce_error(lcf_where, "ndims of gd_id <= 0")
        else if(ndims > NENTRIESMAX) then
           call announce_error(lcf_where, "ndims of gd_id > NENTRIESMAX")
        end if

        fieldlist = ''
        nfields = he5_gdinqflds(gd_id(i), fieldlist, rank, numberTypes)
        if(nfields <= 0) then
           call announce_error(lcf_where, "nfields of gd_id <= 0")
        else if(nfields > NENTRIESMAX) then
           call announce_error(lcf_where, "nfields of gd_id > NENTRIESMAX")
        end if

        if(.not. CASESENSITIVE) then
           fieldlist = Capitalize(fieldlist)
        end if

        if(present(fieldName)) then
           actual_field_name=fieldName
        else
           actual_field_name=DEFAULTNCEPSTRATFIELDNAME
        end if

        actual_dim_list = ' '
        if(present(GeoDimList)) then
           actual_dim_list=GeoDimList
        end if
        if ( actual_dim_list == ' ' ) then
           actual_dim_list = DEFAULTDAODIMLIST
        end if

        call List2Array (actual_dim_list, dimNames, countEmpty)

        ! Now find the rank of our field
        inq_success = he5_gdfldinfo(gd_id(i), trim(actual_field_name), & 
          & our_rank, dims, numbertype, dimlists(1), maxdimlists(1))

        dimlist = trim(dimlists(1))
        dims_temp(1:our_rank,i) = dims(1:our_rank)

        if(DEEBUG) print *, 'our_rank ', our_rank
        if(DEEBUG) print *, 'dims ', dims(1:our_rank)
        if(DEEBUG) print *, 'dimlist ', dimlist

        nlon = dims(1) 
        nlat = dims(2) 
        nlev = nlev + dims(3)
        if(DEEBUG) print *, 'nlon, nlat, nlev: ',nlon, nlat, nlev
    end do

    the_g_data%quantityName = actual_field_name
    the_g_data%description = lit_strat
    the_g_data%verticalCoordinate = v_type

    the_g_data%noLons = nlon
    the_g_data%noLats = nlat
    the_g_data%noHeights = nlev
    ! the_g_data%noLsts = ntime
    the_g_data%noDates = ntime
    the_g_data%units = 'K'
    if(DEEBUG) print *, 'our quantity name ', the_g_data%quantityName
    if(DEEBUG) print *, 'our description ', the_g_data%description
    if(DEEBUG) print *, 'our units ', the_g_data%units

    ! Setup the grid
    call SetupNewGriddedData ( the_g_data, noHeights=nlev, noLats=nlat, &
      & noLons=nlon, noLsts=1, noSzas=1, noDates=ntime, missingValue=FILLVALUE )
      ! & noLons=nlon, noLsts=ntime, noSzas=1, noDates=1, missingValue=FILLVALUE )
    if(DEEBUG) print *, '(Again) our quantity name ', the_g_data%quantityName
    if(DEEBUG) print *, 'our description ', the_g_data%description
    if(DEEBUG) print *, 'our units ', the_g_data%units
    nullify ( t_all_fields )
    call allocate_test ( t_all_fields, nlon, nlat, nlev, "t_all_fields", &
      & moduleName )
    t_all_fields = the_g_data%missingValue

    nullify ( all_the_fields )
    do i=1, ngrids
       if (gd_id(i) < 0) then
         call MLSMessage (MLSMSG_Warning, ModuleName, & 
           & "Could not attach "//trim(names(i)))
         exit 
       end if

       dims(1) = dims_temp(1,i)
       dims(2) = dims_temp(2,i)
       dims(3) = dims_temp(3,i)
       if (DEEBUG) print *, 'dims1, dims2, dims3: ', dims(1), dims(2), dims(3) 

       call allocate_test ( all_the_fields, int(dims(1)), int(dims(2)), int(dims(3)), &
         & "all_the_fields", moduleName )
       all_the_fields = the_g_data%missingValue

       status = he5_gdgridinfo(gd_id(i), xdimsize, ydimsize, upleftpt, &
          & lowrightpt)
       start = 0
       stride = 1
       !edge = dims(1:3)
       edge(1) = xdimsize 
       edge(2) = ydimsize 
       edge(3) = dims(3)
       if(DEEBUG) print *, 'About to read ' // trim(actual_field_name)
       if(DEEBUG) print *, 'Start ', Start
       if(DEEBUG) print *, 'Stride ', Stride
       if(DEEBUG) print *, 'Edge ', Edge
       if(DEEBUG) print *, 'xdimsize ', xdimsize
       if(DEEBUG) print *, 'ydimsize ', ydimsize

       status = he5_gdrdfld(gd_id(i), trim(actual_field_name), &
         & hsizes(start), hsizes(stride), hsizes(edge), all_the_fields)
       if(status /= 0) &
          & call announce_error(lcf_where, "failed to read field " &
          & //trim(actual_field_name))

       ! The actual dimlist is this                    XDim,YDim,Height
       ! Need to reshape it so that the order becomes: Height,YDim,XDim
       if ( DEEBUG) then
         print *, 'Before reshaping'
          call dump(all_the_fields(:,1,1), 'x-slice')
          call dump(all_the_fields(1,:,1), 'y-slice')
          call dump(all_the_fields(1,1,:), 'p-slice')
       end if

       fdims3 = (dims(3))*(i-1)+1
       sdims3 = (dims(3))*i
       if (DEEBUG) print *, 'fsdims3: ',fdims3, sdims3

       t_all_fields(1:nlon,1:nlat,fdims3:sdims3) = all_the_fields(:,:,:)
       if ( DEEBUG) then
          print *, 't_all_fields '
          call dump(t_all_fields(1:65,1,fdims3), 'x-slice')
          call dump(t_all_fields(1,1:65,fdims3), 'y-slice')
          call dump(t_all_fields(1,1,fdims3:nlev), 'p-slice')
       end if

        ! Close grid
        status = he5_gddetach(gd_id(i))
        if(status /= 0) &
           & call announce_error(lcf_where, "failed to detach from grid " &
           & //trim(names(i)))
        call deallocate_test ( all_the_fields, "all_the_fields", moduleName )
    end do

    the_g_data%field(:,:,:,1,1,1) = reshape( t_all_fields, &
      & shape=(/nlev, nlat, nlon/), order=(/3,2,1/))

    if ( DEEBUG ) then
      print *, 'After reshaping'
      call dump(the_g_data%field(1,1,:,1,1,1), 'x-slice')
      call dump(the_g_data%field(1,:,1,1,1,1), 'y-slice')
      call dump(the_g_data%field(:,1,1,1,1,1), 'p-slice')
    end if

    call deallocate_test ( t_all_fields, "t_all_fields", moduleName )

    ! Now read the dims
    do j=1, nlon
        the_g_data%lons(j) = j - 1 + Lon_offset
    end do
    do j=1, nlat
        the_g_data%lats(j) = j - 1 + Lat_offset
    end do

    ! Have not yet figured out how to assign these
    ! Probably will have to read metadata
    the_g_data%lsts = the_g_data%missingValue
    the_g_data%Szas = the_g_data%missingValue
    the_g_data%DateStarts = the_g_data%missingValue
    the_g_data%DateEnds = the_g_data%missingValue

    status = he5_gdclose(file_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to close file " //trim(NCEPFile%name))

  contains 
     subroutine read_the_dim(gd_id, field_name, field_size, values)
       ! Arguments
       integer, intent(in) :: gd_id
       character(len=*), intent(in) :: field_name
       integer, intent(in) :: field_size
       real(r8), dimension(:), pointer :: values
       ! Local variables
       integer :: status
       integer, dimension(1) :: start, stride, edge
       ! Executable
       call allocate_test ( values, field_size, "values", moduleName )
       start = 0                                                             
       stride = 1                                                             
       edge = field_size                                                       
       values = the_g_data%missingValue
       status = he5_gdrdfld(gd_id, trim(field_name), &
         & hsizes(start), hsizes(stride), hsizes(edge), values)                                                     
       if ( status /= 0 ) &
         & call announce_error(lcf_where, "failed to read dim field " &
         & // trim(field_name))
     end subroutine read_the_dim
  end subroutine Read_NCEP_Strat

  ! ---------------------------------------------  ReadGloriaFile  -----
  type ( GriddedData_T) function ReadGloriaFile ( gloriaFile ) result ( grid )
    type(MLSFile_T)                :: GloriaFile
    ! This function reads data in Gloria's gridded data format into memory
    ! Note that Gloria has a very specific format for her gridded data

    ! Local parameters
    integer, parameter :: NOLATS = 45   ! Number of latitudes
    integer, parameter :: NOLONS = 72   ! Number of longitudes
    integer, parameter :: NOHEIGHTS = 22  ! Number of surfaces
    real(r8), parameter :: DLAT = 4.0   ! Latitude spacing
    integer, parameter :: HEADERLEN = 61
    integer, parameter :: OFFSET = 4    ! Extra 4 byte word in file
    integer, parameter :: BUFFERLEN = &
      & headerLen + offset + noHeights*noLats*noLons*4 ! Size of file

    ! Local variables
    integer :: UARSDAY                  ! UARS day for data
    integer :: I                        ! Loop counter
    integer :: LAT                      ! Loop counter
    integer :: LON                      ! Loop counter
    integer :: SURF                     ! Loop counter
    integer :: LUN                      ! Unit number
    integer :: STATUS                   ! Flag
    character (len=headerLen) :: COMMENT
    logical :: EXIST                    ! Flag
    logical :: OPENED                   ! Flag
    real (r4) :: ONEVALUE               ! One element of the grid
    character (len=1), dimension(4) :: TESTCHAR ! For finding our Endian
    integer :: TESTINT              ! For finding our Endian
    character (len=1), dimension(bufferLen) :: BUFFER
    logical :: NEEDSWAP                 ! Flag for endian
        
    ! Executable code

    ! Setup the grid
    call SetupNewGriddedData ( grid, noHeights=noHeights, noLats=noLats, &
      & noLons=noLons, noLsts=1, noSzas=1, noDates=1 )
    grid%equivalentLatitude = .false.
    grid%description = 'gloria'

    ! Now fill the coordinates
    grid%verticalCoordinate = v_is_pressure
    do i = 1, noHeights
      grid%heights(i) = 10.0**(3.0-(i-1)/6.0)
    end do
    do i = 1, noLats
      grid%lats(i) = dLat * ( i - 2.0*noLats/dLat ) - dLat/2.0
    end do
    do i = 1, noLons
      grid%lons(i) = (i-1)*360.0 / noLons
    end do
    grid%lsts(1) = 0.0
    grid%szas(1) = 0.0

    ! Now read Gloria's data file
    ! Perhaps Paul could make this use MLSFiles later? !?????????
    do lun = 20, 99
      inquire ( unit=lun, exist=exist, opened=opened )
      if ( exist .and. .not. opened ) exit
    end do
    open ( unit=lun, file=gloriaFile%name, status='old', form='unformatted', &
      & access='direct', iostat=status, recl=bufferLen )
    if ( status /= 0 ) then
      call output ( 'IOSTAT value is:' )
      call output ( status, advance='yes' )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Problem opening Gloria format datafile', MLSFile=gloriaFile )
    end if
    ! Read the data
    read ( lun, rec=1 ) buffer
    ! Done with the file
    close ( lun ) 

    ! Get the comment field to work out the day
    write ( comment, '(61A1)' ) buffer ( 1 : headerLen )
    ! Now work out the uars day
    i = index ( comment, 'DAY ' )
    read ( comment(i+4:i+8), * ) uarsDay

    ! Now convert this into TAI time, choose midday for the day
    ! Also ignore leapseconds. uarsDay 1 was 12 Sep 1991.  From
    ! 1 Jan 1993 to 11 Sep 1991 is 478 days, 477.5 puts it at midday
    grid%dateStarts = (uarsDay-477.5) * 60.0 * 60.0 * 24.0
    grid%dateEnds = grid%dateStarts
    ! Now read the field, into a character array first to deal with endian
    ! issues.

    ! Now, what's our endian
    testInt = 1
    testChar = transfer ( testInt, testChar )
    if ( ( ichar(testChar(1)) == 1 ) .and. &
      &  ( ichar(testChar(2)) == 0 ) .and. &
      &  ( ichar(testChar(3)) == 0 ) .and. &
      &  ( ichar(testChar(4)) == 0 ) ) then
      needSwap = .true.
    else if ( ( ichar(testChar(1)) == 0 ) .and. &
      &       ( ichar(testChar(2)) == 0 ) .and. &
      &       ( ichar(testChar(3)) == 0 ) .and. &
      &       ( ichar(testChar(4)) == 1 ) ) then
      needSwap = .false.
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "I'm very confused about the endian of this machine" )
    end if

    ! Put the if statement on the outside to avoid if's in loops
    i = headerLen + offset + 1
    if ( needSwap ) then
      do surf = 1, noHeights
        do lon = 1, noLons
          do lat = 1, noLats
            grid%field ( surf, lat, lon, 1, 1, 1 ) = &
              & transfer ( buffer(i+3:i:-1), oneValue )
            i = i + 4
          end do
        end do
      end do
    else
      ! No byte swapping required, just store it
      do surf = 1, noHeights
        do lon = 1, noLons
          do lat = 1, noLats
            grid%field ( surf, lat, lon, 1, 1, 1 ) = &
              & transfer ( buffer(i:i+3), oneValue )
            i = i + 4
          end do
        end do
      end do
    end if

    ! Patch the missing data
    where ( grid%field(:,:,:,:,:,:) > 0.95e12 )
      grid%field(:,:,:,:,:,:) = grid%missingValue
    end where

  end function ReadGloriaFile

  ! -------------------------------------------  Read_Climatology  -----
  subroutine Read_Climatology ( climFile, root, aprioriData, returnStatus, &
    & mlspcf_l2clim_start, mlspcf_l2clim_end, missingValue, echo_data, &
    & dump_data )
    ! Brief description of program
    ! This subroutine reads a l3ascii file and returns
    ! the data_array to the caller
    use Toggles, only: Gen, Levels, Toggle
    use Trace_m, only: Trace_Begin, Trace_End

    ! Arguments
    type(MLSFile_T)                :: ClimFile
    type (GriddedData_T), dimension(:), pointer :: aprioriData 
    integer, intent(in) :: ROOT        ! Root of the L2CF abstract syntax tree
    integer, intent(out) :: returnStatus ! E.g., FILENOTFOUND
    integer, optional, intent(IN) :: mlspcf_l2clim_start, mlspcf_l2clim_end
    real, optional, intent(IN) :: missingValue
    logical, optional, intent(in) :: echo_data        ! echo climatology quantity name
    logical, optional, intent(in) :: dump_data        ! dump climatology data

    ! Local
    integer, parameter :: version=1
    character (LEN=FileNameLen)            :: fname   ! Physical file name
    character (LEN=FileNameLen)            :: path    ! Physical path

    ! These determine how much extra to output
    logical, parameter :: debug=.false.
    logical, parameter :: ECHO_GRIDDED_QUANTITIES=.false. ! echo_data overrides
    logical, parameter :: DUMP_GRIDDED_QUANTITIES=.false. ! dump_data overrides

    logical :: end_of_file
    type (GriddedData_T)        :: gddata 
    integer :: ErrType
    logical :: echo
    logical :: dump_now
    integer :: Me = -1             ! String index for trace
    integer:: processCli, CliUnit
    logical :: use_PCF

    ! begin
    call trace_begin ( me, "Read_Climatology", root, &
      & cond=toggle(gen) .and. levels(gen) > 1 )
    ErrType= 0
    returnStatus = FILENOTFOUND
    end_of_file=.false.
    if(present(echo_data)) then
      echo = echo_data
    else
      echo = ECHO_GRIDDED_QUANTITIES
    end if

    if(present(dump_data)) then
      dump_now = dump_data
    else
      dump_now = DUMP_GRIDDED_QUANTITIES
    end if

    use_PCF = present(mlspcf_l2clim_start) &
      & .and. present(mlspcf_l2clim_end) &
      & .and. UseSDPToolkit .and. .false.

    ! use PCF

    if ( use_PCF ) then
      call split_path_name(ClimFile%name, path, fname)
      processCli = GetPCFromRef(fname, mlspcf_l2clim_start, mlspcf_l2clim_end, &
        & .true., ErrType, version, debugOption=debug)
      if(ErrType /= 0) then
        call announce_error ( root, &
          &"Climatology file name " // trim(fname) // " unmatched in PCF", &
          & 'error number: ', extra_number=ErrType)
        go to 9
      end if
      ErrType = Pgs_io_gen_openF ( processCli, PGSd_IO_Gen_RSeqFrm, 0, &
        cliUnit, version )
    else
      fname = climFile%name
      ! use Fortran open
      if(debug) call output('opening ' // fname, advance = 'yes')
      call MLS_OpenFile( ClimFile )
      CliUnit = ClimFile%FileID%f_id
      
    end if

    if(debug) then
      if(.not. end_of_file) then
        call output('Not yet eof on io unit', advance = 'yes')
      else
        call output('Starting at eof on io unit', advance = 'yes')
      end if
      call dump( ClimFile )
    end if


    if ( ErrType == PGS_S_SUCCESS ) then
      do while (.not. end_of_file)
        if(debug) call output('reading l3ascii file', advance = 'yes')
        call l3ascii_read_field ( CliUnit, gddata, end_of_file, ErrType)
        select case ( gddata%verticalCoordinate )
        case ( v_is_pressure )
          gddata%heightsUnits = 'hPa'
        case ( v_is_altitude )
          gddata%heightsUnits = 'km'
        case ( v_is_gph )
          gddata%heightsUnits = 'km'
        case ( v_is_theta )
          gddata%heightsUnits = 'K'
        case default
          gddata%heightsUnits = 'hPa'
        end select
        if(ErrType == 0) then
          if(debug) then
            call output('adding to grid database', advance='yes')
            call output('adding grid template to database ', advance='yes')
          end if
          if(echo .or. debug) then
            call output('quantity name ' // gddata%quantityName, advance='yes')
            call output('description ' // gddata%description, advance='yes')
            call output('units ' // gddata%units, advance='yes')
          end if

          if(dump_now) then
            call Dump(gddata, root)
          end if

          ErrType = AddGriddedDataToDatabase(aprioriData, gddata)

          nullify (gddata%heights)
          nullify (gddata%lats)
          nullify (gddata%lons)
          nullify (gddata%lsts)
          nullify (gddata%szas)
          nullify (gddata%dateStarts)
          nullify (gddata%dateEnds)
          nullify (gddata%field)
          if ( present(missingValue) ) then
            if (missingValue /= 0._rgr) &
              & aprioriData(size(aprioriData))%missingValue = missingValue
          end if
          if(debug) call output('Destroying our grid template', advance='yes')
        end if
      end do !(.not. end_of_file)
      ! ok, done with this file and unit number
      if( use_PCF ) then
        ErrType = Pgs_io_gen_CloseF ( CliUnit )
        ! use Fortran close
      else
        if(debug) call output('closing ' // fname, advance = 'yes')
        call MLS_CloseFile( ClimFile )
        ErrType = 0
      end if
      if(ErrType /= 0) then
        call announce_error (ROOT, &
          &"Error closing " // fname, &
          &'error number: ', extra_number=ErrType)
      end if
      returnStatus = ErrType
    else
      call announce_error (ROOT, &
        &"Error opening " // fname, &
        &'error number: ', extra_number=ErrType)
    end if

9   continue
    call trace_end ( "Read_Climatology", root, &
      & cond=toggle(gen) .and. levels(gen) > 1 )

  end subroutine Read_Climatology

d428 2
a429 2
    integer, intent(IN)                     :: lcf_where    ! node of the lcf that provoked me         
    integer, intent(IN)                     :: v_type       ! vertical coordinate; an 'enumerated' type
d431 1
a431 1
    character (LEN=*), intent(IN)           :: description ! e.g., 'dao'
d433 5
a437 5
    character (LEN=*), intent(IN)           :: GeoDimList ! Comma-delimited dim names
    character (LEN=*), intent(IN)           :: fieldNames ! Names of gridded field
    real(rgr), optional, intent(IN)         :: missingValue
    character (LEN=*), optional, intent(IN) :: date ! offset
    logical, optional, intent(IN)           :: sumDelp ! sum the DELP to make PL
d449 1
a449 1
    if ( DEEBUG ) print *, 'Writeing ' // trim(my_description) // ' data'
d456 2
a457 2
        call announce_error(lcf_where, 'WriteGriddedData called with illegal' &
          & // ' description: ' // trim(my_description))
d459 2
a460 2
        call announce_error(lcf_where, 'WriteGriddedData called with illegal' &
          & // ' description: ' // trim(my_description))
d465 2
a466 2
        call announce_error(lcf_where, 'WriteGriddedData called with illegal' &
          & // ' description: ' // trim(my_description))
d468 2
a469 2
        call announce_error(lcf_where, 'WriteGriddedData called with illegal' &
          & // ' description: ' // trim(my_description))
d471 2
a472 2
        call announce_error(lcf_where, 'WriteGriddedData called with unknown' &
          & // ' description: ' // trim(my_description))
a476 102
  ! ------------------------------------------------  Write_Merra  -----
  subroutine Write_Merra( createGrid, GEOS5File, lcf_where, &
    & the_g_data, GeoDimList, fieldName )

    ! This routine Writes a gmao MERRA file, named something like
    ! MERRA300.prod.assim.inst6_3d_ana_Nv.20050131.hdf (pressure with
    ! fieldname='DELP' or 'T')
    ! based on a filled data
    ! structure appropriate for newer style gmao merra
    ! (For one thing it holds 4-d, not 3-d fields)

    ! FileName and the_g_data are required args
    ! GeoDimList, if present, should be the Dimensions' short names
    ! as a comma-delimited character string in the order:
    ! longitude, latitude, vertical level, time

    ! fieldName, if present, should be the rank 4
    ! like temperature

    ! This file is formatted in the following way:
    ! At each gridded quantity, e.g. EOSGRID,
    ! a rank 4 field, e.g. T, is given with dimensions
    ! 'Time, Height, YDim, XDim'
    ! We'll simply copy it into a single gridded data type
    
    ! This is so similar to Write_geos5 that we ought to combine the two into
    ! a single routine, except the extra timeIndex business would need
    ! careful handling

    ! Arguments
    logical, intent(in)                     :: createGrid
    type(MLSFile_T)                         :: GEOS5file
    integer, intent(IN)                     :: lcf_where    ! node of the lcf that provoked me
    type( GriddedData_T )                   :: the_g_data ! Result
    character (LEN=*), optional, intent(IN) :: GeoDimList ! Comma-delimited dim names
    character (LEN=*), optional, intent(IN) :: fieldName ! Name of gridded field

    ! Local Variables
    integer :: file_id, gd_id
    logical,  parameter       :: CASESENSITIVE = .false.
    integer, parameter :: GRIDORDER=1   ! What order grid written to file
    integer, parameter :: MAXNAMELENGTH=NameLen         ! Max length of grid name
    integer, dimension(NENTRIESMAX) :: dims

    integer :: start(4), stride(4), edge(4)
    integer :: status
    integer, parameter             :: i_longitude=1
    integer, parameter             :: i_latitude=i_longitude+1
    integer, parameter             :: i_vertical=i_latitude+1
    integer, parameter             :: i_time=i_vertical+1
    character(len=*), parameter    :: GridName = "EOSGRID"
    integer, parameter :: gctp_geo = 0
    real(r4), parameter :: FILLVALUE = 1.e15
    real(r8) :: uplft(2), lowrgt(2)
    real(r8) :: projparm(13)
    logical, parameter :: DEEBUG = .false.
    integer, external :: gdopen, gdclose, gdcreate, gdattach, &
      & gddefdim, gddeffld, gddefproj, gddetach, gdwrfld
    ! Executable code
    uplft = (/ -180000000.000000 ,90000000.000000 /)
    lowrgt = (/ 180000000.000000,-90000000.000000 /)
    projparm = 0.0
    dims(1) = the_g_data%noLons
    dims(2) = the_g_data%noLats
    dims(3) = the_g_data%noHeights
    dims(4) = the_g_data%noDates
    edge = dims(1:4)                                                        
    start = 0
    stride = 1
    error = 0
    if ( createGrid ) then
      file_id = gdopen(GEOS5File%Name, DFACC_CREATE)
      gd_id = gdcreate(file_id, gridName, the_g_data%noLons, &
           & the_g_data%noLats, uplft, lowrgt)
      status = gddefdim( gd_Id, 'TDim', the_g_data%noDates )
      status = gddefdim( gd_Id, 'ZDim', the_g_data%noHeights )
      status = gddefdim( gd_Id, 'YDim', the_g_data%noLats )
      status = gddefdim( gd_Id, 'XDim', the_g_data%noLons )
      status = gddefproj( gd_Id, GCTP_GEO, 0, 0, projparm )
      status = gddeffld( gd_Id, 'TIME', 'TDim', DFNT_FLOAT64, 0 )
      status = gddeffld( gd_Id, 'Height', 'ZDim', DFNT_FLOAT32, 0 )
      status = gddeffld( gd_Id, 'YDim', 'YDim', DFNT_FLOAT32, 0 )
      status = gddeffld( gd_Id, 'XDim', 'XDim', DFNT_FLOAT32, 0 )
      status = gdwrfld( gd_Id, 'TIME', start(4), stride(4), edge(4), the_g_data%dateStarts )
      status = gdwrfld( gd_Id, 'Height', start(3), stride(3), edge(3), the_g_data%heights )
      status = gdwrfld( gd_Id, 'YDim', start(2), stride(2), edge(2), the_g_data%Lats )
      status = gdwrfld( gd_Id, 'XDim', start(1), stride(1), edge(1), the_g_data%Lons )
    else
      file_id = gdopen(GEOS5File%Name, DFACC_RDWR)
      gd_id = gdattach(file_id, gridname)
    end if

    if (file_id < 0) then
      call announce_error(lcf_where, "Could not open "// GEOS5File%Name)
    end if
    status = gddeffld( gd_Id, fieldName, 'TIME,Height,YDim,XDim', DFNT_FLOAT32, 0 )
    status = gdwrfld( gd_Id, 'XDim', start(1), stride(1), edge(1), the_g_data%Lons )
    status = gddetach( gd_Id )
    status = gdclose( file_id )

  end subroutine Write_Merra

d506 2
a507 2
      call announce_error(0, "Could not inquire gridlist "// &
        & trim(File%Name))
d517 1
a517 1
      call announce_error(0, "Could not open "// File%Name)
d523 3
a525 3
      call announce_error(0, "NumStringElements of gridlist <= 0")
    else if(ngrids /= inq_success) then
      call announce_error(0, "NumStringElements of gridlist /= inq_success")
d527 1
a527 1
      call announce_error(0, "NumStringElements of gridlist < GRIDORDER")
d534 1
a534 1
      call announce_error(0, "Could not attach "//trim(gridname))
a554 95
  ! ------------------------------------------------  ncepFieldNameTohPa  -----
  subroutine ncepFieldNameTohPa ( field_name, pressure )

    ! Snip INTRO and TAIL off field_name
    ! If remainder can be interpreted as a number return that
    ! Otherwise return -999.99
    ! Arguments
    character(len=*), intent(in)    :: field_name
    real(r8), intent(out)           :: pressure
    ! Local variables
    character(len=*), parameter     :: INTRO = 'ISOBARIC LEVEL AT'
    character(len=*), parameter     :: TAIL = '(hPa)'
    character(len=len(field_name))  :: beheaded
    character(len=len(field_name))  :: remainder
    ! Local variables
    integer :: status
    ! Executable
    pressure = undefinedValue !-999.99
    call ReplaceSubString(field_name, beheaded, INTRO, ' ' )
    call ReplaceSubString(beheaded, remainder, TAIL, ' ' )
    ! Now attempt to interpret remainder as a number
    ! print *, 'Attempting to interpret: ', trim(remainder)
    read(remainder, *, iostat=status) pressure
    if ( status /= 0 ) pressure = undefinedValue !-999.99
  end subroutine ncepFieldNameTohPa

  ! ------------------------------------------------  announce_error  -----
  subroutine announce_error ( lcf_where, full_message, &
    & extra_message, extra_number, use_toolkit )

    ! Arguments
    integer, intent(in)    :: lcf_where
    character(LEN=*), intent(in)    :: full_message
    logical, intent(in), optional :: use_toolkit
    character(LEN=*), intent(in), optional    :: extra_message
    integer, intent(in), optional    :: extra_number

    ! Local variables
    logical :: just_print_it
    logical, parameter :: default_output_by_toolkit = .true.

    if(present(use_toolkit)) then
      just_print_it = use_toolkit
    else if(default_output_by_toolkit) then
      just_print_it = .false.
    else
      just_print_it = .true.
    end if

    if(.not. just_print_it) then
      error = max(error,1)
      call output ( '***** At ' )

      if(lcf_where > 0) then
        call print_source ( where(lcf_where) )
      else
        call output ( '(no lcf node available)' )
      end if

      call output ( ': ' )
      call output ( "The " );
      if(lcf_where > 0) then
        call dump_tree_node ( lcf_where, 0 )
      else
        call output ( '(no lcf tree available)' )
      end if

      call output(" Caused the following error:", advance='yes', &
        & from_where=ModuleName)
      call output(trim(full_message), advance='yes', &
        & from_where=ModuleName)
      if(present(extra_message)) then
        call output('error number ', advance='no')
        call output(extra_message, advance='yes')
      end if
      if(present(extra_number)) then
        call output('error number ', advance='no')
        call output(extra_number, places=9, advance='yes')
      end if
    else
      call output ( '***Error in module ' )
      call output ( ModuleName, advance='yes' )
      call output ( trim(full_message), advance='yes' )
      if ( present(extra_message) ) then
        call output ( 'Error number ' )
        call output ( extra_message, advance='yes' )
      end if
      if ( present(extra_number) ) then
        call output ( 'Error number ' )
        call output ( extra_number, advance='yes' )
      end if
    end if

  end subroutine announce_error

d558 1
a558 1
       "$Id: ncep_dao.f90,v 2.83 2016/09/22 22:22:47 pwagner Exp $"
d568 3
@


2.83
log
@Change message to acknowledge version may be later than geos5_7
@
text
@d165 1
d2684 1
a2684 1
       "$Id: ncep_dao.f90,v 2.82 2016/07/28 01:42:27 vsnyder Exp $"
d2694 3
@


2.82
log
@Refactoring dump and diff
@
text
@d68 1
a68 1
! geos5_7         Geos5.7.2  gmao files in netcdf4/hdf5 format
d210 1
a210 1
    case ('geos5_7')
d227 1
a227 1
        call output( '(Returned from read_geos5_7)', advance='yes' )
d2683 1
a2683 1
       "$Id: ncep_dao.f90,v 2.81 2015/03/28 00:56:14 vsnyder Exp $"
d2693 3
@


2.81
log
@Stuff to trace allocate/deallocate addresses -- mostly commented out
because NAG build 1017 doesn't yet allow arrays as arguments to C_LOC.
@
text
@d14 2
a15 2
  use allocate_deallocate, only: allocate_test, deallocate_test, bytes, &
    & test_allocate
d17 7
a23 7
  use dump_0, only : dump
  use griddeddata, only: griddeddata_t, rgr, v_is_altitude, v_is_gph, &
    & v_is_pressure, v_is_theta, &
    & addgriddeddatatodatabase, dump, setupnewgriddeddata, nullifygriddeddata
  use HDFeos, only: HDFe_nentdim, &
    & gdopen, gdattach, gddetach, gdclose, gdfldinfo, &
    & gdinqgrid, gdnentries, gdinqdims, gdinqflds
d26 10
a35 10
  use highoutput, only: outputnamedvalue
  use intrinsic, only: l_hdfeos
  use l3ascii, only: l3ascii_read_field
  use lexer_core, only: print_source
  use MLScommon, only: linelen, namelen, filenamelen, &
    & undefinedvalue, MLSfile_t
  use MLSFiles, only: fileNotFound, HDFversion_5, dump, InitializeMLSFile, &
    & getpcfromref, MLS_HDF_version, MLS_openfile, MLS_closefile, &
    & split_path_name, MLS_openfile, MLS_closefile
  use MLSkinds, only: r4, r8
d38 3
a40 3
  use MLSstrings, only: capitalize, hhmmss_value, lowercase
  use MLSstringlists, only: getstringelement, numstringelements, &
    & list2array, replacesubstring, stringelementnum
d45 2
a46 2
    & useSDPtoolkit
  use tree, only: dump_tree_node, where
d48 1
a48 1
  implicit none
d392 2
a393 2
  ! ----------------------------------------------- Read_geos5_7
  subroutine Read_geos5_7( GEOS5File, lcf_where, v_type, &
d397 8
a404 7
    use dates_module, only: utc2tai93s
    use hdf5, only: hsize_t
    use mlshdf5, only: getallhdf5dsnames, &
      & gethdf5dsrank, gethdf5dsdims, loadfromhdf5ds, &
      & readhdf5attribute
    use mlsstringlists, only: switchdetail
    use toggles, only: switches
d453 1
a453 1
    if ( verbose ) call dump(mysdList, 'DS names')
d651 1
a651 1
  end subroutine Read_geos5_7
d653 2
a654 2
  ! ----------------------------------------------- Read_geos5_or_merra
  subroutine Read_geos5_or_merra( GEOS5File, lcf_where, v_type, &
d754 1
a754 1
          & 'list size too big in Read_geos5_or_merra ' // trim(GEOS5File%Name), MLSFile=GEOS5File )
d917 1
a917 1
        & 'all_the_fields', ModuleName // 'Read_geos5_or_merra' )
d936 1
a936 1
        & ModuleName // 'Read_geos5_or_merra' )
d956 1
a956 1
        & ModuleName // 'Read_geos5_or_merra' )
d978 1
a978 1
        & ModuleName // 'Read_geos5_or_merra' )
d997 1
a997 1
        & ModuleName // 'Read_geos5_or_merra' )
d1064 1
a1064 1
  end subroutine Read_geos5_or_merra
d1066 2
a1067 2
  ! ----------------------------------------------- Read_dao
  subroutine Read_dao(DAOFile, lcf_where, v_type, &
d1142 1
a1142 1
          & 'list size too big in Read_dao ' // trim(DAOFile%Name), MLSFile=DAOFile )
d1350 1
a1350 1
  end subroutine Read_dao
d1352 2
a1353 2
  ! ----------------------------------------------- Read_ncep_gdas
  subroutine Read_ncep_gdas ( NCEPFile, lcf_where, v_type, &
d1623 1
a1623 1
      call announce_error(lcf_where, "Read_ncep_gdas unable to use projection")
d1671 1
a1671 1
  end subroutine Read_ncep_gdas
d1673 2
a1674 2
  ! ----------------------------------------------- Read_ncep_strat
  subroutine Read_ncep_strat(NCEPFile, lcf_where, v_type, &
d2016 1
a2016 1
  end subroutine Read_ncep_strat
d2018 1
a2018 1
  ! --------------------------------------------- ReadGloriaFile -------
d2156 1
a2156 1
  ! --------------------------------------------------  Read_Climatology
d2325 1
a2325 1
  ! ----------------------------------------------- WriteGriddedData
d2405 2
a2406 2
  ! ----------------------------------------------- Write_merra
  subroutine Write_merra( createGrid, GEOS5File, lcf_where, &
d2505 1
a2505 1
  end subroutine Write_merra
d2683 1
a2683 1
       "$Id: ncep_dao.f90,v 2.80 2015/02/06 01:10:36 pwagner Exp $"
d2693 4
@


2.80
log
@Added body missing from ReadGriddedData with filename api
@
text
@d16 1
d380 1
d389 1
d425 1
d626 5
d632 2
a633 1
      & (/ idim4(3), idim4(2), idim4(1), 1, 1, 1 /), bytes(the_g_data%field) )
d2682 1
a2682 1
       "$Id: ncep_dao.f90,v 2.79 2014/09/06 00:05:02 pwagner Exp $"
d2692 3
@


2.79
log
@Stores geost_7 lats in the_g_data after reading them
@
text
@d26 1
d31 2
a32 2
  use MLSfiles, only: filenotfound, HDFversion_5, &
    & dump, getpcfromref, MLS_HDF_version, MLS_openfile, MLS_closefile, &
d35 2
a36 2
  use MLSmessagemodule, only: MLSmsg_error, MLSmsg_info, MLSmsg_warning, &
    & MLSmessage
d114 1
a114 1
  ! ----------------------------------------------- ReadGriddedData
d232 3
a234 3
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
d252 3
a254 3
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
d272 3
a274 3
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
d296 3
a298 3
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
d318 3
a320 3
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
d340 3
a342 3
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
d377 10
d394 7
a400 7
    use DATES_MODULE, only: UTC2TAI93S
    use HDF5, only: HSIZE_T
    use MLSHDF5, only: GETALLHDF5DSNAMES, &
      & GETHDF5DSRANK, GETHDF5DSDIMS, LOADFROMHDF5DS, &
      & READHDF5ATTRIBUTE
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use TOGGLES, only: SWITCHES
d1666 5
a1670 5
    use HDFEOS5, only: HE5_HDFE_NENTDIM, HE5F_ACC_RDONLY, &
      & HE5_GDOPEN, HE5_GDATTACH, HE5_GDDETACH, HE5_GDCLOSE, &
      & HE5_GDNENTRIES, HE5_GDINQGRID, HE5_GDINQDIMS, HE5_GDINQFLDS, &
      & HE5_GDFLDINFO, HE5_GDGRIDINFO
    use MLSHDFEOS, only: HSIZES
d2672 1
a2672 1
       "$Id: ncep_dao.f90,v 2.78 2014/09/05 00:27:11 vsnyder Exp $"
d2682 3
@


2.78
log
@More complete and accurate allocate/deallocate size tracking.  Add some
tracing.
@
text
@d553 1
d2661 1
a2661 1
       "$Id: ncep_dao.f90,v 2.77 2014/06/04 18:29:45 pwagner Exp $"
d2671 4
@


2.77
log
@Account for memory usage accurately; allow deferReading
@
text
@d135 2
d157 1
d161 2
d187 1
a187 1
      return
d190 1
a190 1
    endif
d201 2
a202 2
      return
    endif
d216 2
a217 2
        return
      endif
d222 1
a222 1
      elseif ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
d236 1
a236 1
      endif
d242 1
a242 1
      elseif ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
d256 1
a256 1
      endif
d262 1
a262 1
      elseif ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
d276 1
a276 1
      endif
d286 1
a286 1
      elseif ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
d300 1
a300 1
      endif
d308 1
a308 1
      elseif ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
d322 1
a322 1
      endif
d330 1
a330 1
      elseif ( the_g_data%empty .or. .not. associated(the_g_data%field) ) then
d344 1
a344 1
      endif
d351 4
d381 2
d416 1
a416 1
    integer :: i1, i2, i3                  ! looping indexes
d419 1
d423 1
a423 1
    real(r4), parameter :: FILLVALUE = 1.e15 !this value maybe wrong 
d432 1
a432 1
    endif
d445 2
a446 3
    the_g_data%missingvalue = FILLVALUE ! this value maybe wrong
    allocate(the_g_data%lsts(1), stat=error)
    if (error /= 0) call announce_error(lcf_where, "Out of memory")
d451 1
a451 2
    allocate(the_g_data%szas(1), stat=error)
    if (error /= 0) call announce_error(lcf_where, "Out of memory")
d464 1
a464 2
    allocate(temp1d(the_g_data%noLons), stat=error)
    if (error /= 0) call announce_error(lcf_where, "Out of memory")
d467 2
a468 2
    allocate(the_g_data%lons(the_g_data%nolons), stat=error)
    if (error /= 0) call announce_error(lcf_where, "Out of memory")
d470 2
a471 1
    deallocate(temp1d)
d479 1
a479 1
    endif
d481 3
a483 3
    if (mytime < 0) then
        call announce_error (lcf_where, "Invalid 'begin_time' value in " // geos5file%name)
    endif
d489 1
a489 1
    !endif
d493 1
a493 1
    !endif
d500 1
a500 1
    endif
d504 1
a504 1
    endif
d511 1
a511 1
    endif    
d518 1
a518 1
    endif
d520 1
a520 1
    write(datestring, &
d524 4
a527 4
    allocate(the_g_data%datestarts(the_g_data%nodates), stat=error)
    if (error /= 0) call announce_error (lcf_where, "Out of memory")
    allocate(the_g_data%dateends(the_g_data%nodates), stat=error)
    if (error /= 0) call announce_error (lcf_where, "Out of memory")
d536 1
a536 1
    !endif
d548 2
a549 3
    allocate(temp1d(the_g_data%nolats), stat=error)
    if (error /= 0) call announce_error(lcf_where, "Out of memory")
    
d551 3
a553 4
    allocate(the_g_data%lats(the_g_data%nolats), stat=error)
    if (error /= 0) call announce_error(lcf_where, "Out of memory")
    the_g_data%lats = temp1d
    deallocate(temp1d)
d562 1
a562 2
    allocate(temp1d(the_g_data%noheights), stat=error)
    if (error /= 0) call announce_error(lcf_where, "Out of memory")
d565 2
a566 2
    allocate(the_g_data%heights(the_g_data%noheights), stat=error)
    if (error /= 0) call announce_error(lcf_where, "Out of memory")
d572 1
a572 1
    deallocate(temp1d)
d593 1
a593 1
    endif
d599 1
a599 1
    endif
d618 3
a620 3
    !      enddo
    !    enddo
    !  enddo
d710 1
a710 1
    endif
d719 1
a719 1
    endif
d729 1
a729 1
    elseif ( strbufsize > MAXLISTLENGTH ) then
d732 1
a732 1
    elseif ( strbufsize < MAXLISTLENGTH .and. strbufsize > 0 ) then
d734 1
a734 1
    endif
d749 1
a749 1
    elseif(ngrids /= inq_success) then
d751 1
a751 1
    elseif(ngrids < GRIDORDER) then
d753 1
a753 1
    endif
d767 1
a767 1
    elseif(nentries > NENTRIESMAX) then
d769 1
a769 1
    endif
d776 1
a776 1
    elseif(ndims > NENTRIESMAX) then
d778 1
a778 1
    endif
d785 1
a785 1
    elseif(nfields > NENTRIESMAX) then
d787 1
a787 1
    endif
d791 1
a791 1
    endif
d803 1
a803 1
    endif
d806 1
a806 1
    endif
d826 1
a826 1
    endif
d836 1
a836 1
    endif
d862 1
a862 1
      endif
d865 1
a865 1
    endif
d924 1
a924 1
            enddo
d928 4
a931 4
            enddo
          enddo
        enddo
      enddo
d934 1
a934 1
    endif
d943 1
a943 1
    endif
d949 1
a949 1
    elseif ( size(all_the_fields, 4) < 2 ) then
d965 1
a965 1
    endif
d972 1
a972 1
    endif
d993 1
a993 1
    elseif (LIT_DESCRIPTION == lit_geos5 ) then
d999 1
a999 1
    endif
d1003 2
a1004 2
    endif
    deallocate(dim_field)        ! Before leaving, some light housekeeping
d1019 22
a1040 29
    contains 
       subroutine read_the_dim(gd_id, field_name, field_size, values)
         ! Arguments
         integer, intent(in) :: gd_id
         character(len=*), intent(in) :: field_name
         integer, intent(in) :: field_size
         real(r8), dimension(:), pointer :: values
         ! Local variables
         integer :: status
         integer, dimension(1) :: start, stride, edge
         ! Executable
         if ( associated(values) ) then
           deallocate(values, stat=status)
           if ( status /= 0 ) &
             & call announce_error(lcf_where, "failed to deallocate dim field")
         endif
         allocate(values(field_size), stat=status)
         if ( status /= 0 ) &
           & call announce_error(lcf_where, "failed to allocate dim field")
         start = 0                                                             
         stride = 1                                                             
         edge = field_size                                                       
         values = the_g_data%missingValue
         status = gdrdfld(gd_id, trim(field_name), start, stride, edge, &
           & values)                                                     
         if ( status /= 0 ) &
           & call announce_error(lcf_where, "failed to read dim field " &
           & // trim(field_name))
       end subroutine read_the_dim
d1047 2
d1117 1
a1117 1
    elseif ( strbufsize > MAXLISTLENGTH ) then
d1120 1
a1120 1
    elseif ( strbufsize < MAXLISTLENGTH .and. strbufsize > 0 ) then
d1122 1
a1122 1
    endif
d1137 1
a1137 1
    elseif(ngrids /= inq_success) then
d1139 1
a1139 1
    elseif(ngrids < GRIDORDER) then
d1141 1
a1141 1
    endif
d1155 1
a1155 1
    elseif(nentries > NENTRIESMAX) then
d1157 1
a1157 1
    endif
d1164 1
a1164 1
    elseif(ndims > NENTRIESMAX) then
d1166 1
a1166 1
    endif
d1173 1
a1173 1
    elseif(nfields > NENTRIESMAX) then
d1175 1
a1175 1
    endif
d1179 1
a1179 1
    endif
d1185 1
a1185 1
    endif
d1190 1
a1190 1
    endif
d1193 1
a1193 1
    endif
d1237 3
a1239 1
    allocate(all_the_fields(dims(1), dims(2), dims(3), dims(4)), stat=status)
a1240 2
    if ( status /= 0 ) &
        & call announce_error(lcf_where, "failed to allocate field_data")
d1261 1
a1261 1
    endif
d1272 2
a1273 2
    endif
    deallocate(all_the_fields)
d1290 1
a1290 1
    deallocate(dim_field)        ! Before leaving, some light housekeeping
d1305 22
a1326 29
    contains 
       subroutine read_the_dim(gd_id, field_name, field_size, values)
         ! Arguments
         integer, intent(in) :: gd_id
         character(len=*), intent(in) :: field_name
         integer, intent(in) :: field_size
         real(r8), dimension(:), pointer :: values
         ! Local variables
         integer :: status
         integer, dimension(1) :: start, stride, edge
         ! Executable
         if ( associated(values) ) then
           deallocate(values, stat=status)
           if ( status /= 0 ) &
             & call announce_error(lcf_where, "failed to deallocate dim field")
         endif
         allocate(values(field_size), stat=status)
         if ( status /= 0 ) &
           & call announce_error(lcf_where, "failed to allocate dim field")
         start = 0                                                             
         stride = 1                                                             
         edge = field_size                                                       
         values = the_g_data%missingValue
         status = gdrdfld(gd_id, trim(field_name), start, stride, edge, &
           & values)                                                     
         if ( status /= 0 ) &
           & call announce_error(lcf_where, "failed to read dim field " &
           & // trim(field_name))
       end subroutine read_the_dim
d1330 4
a1333 2
  subroutine Read_ncep_gdas(NCEPFile, lcf_where, v_type, &
    & the_g_data, GeoDimList, gridName, missingValue)
d1455 1
a1455 1
      elseif(nentries > NENTRIESMAX) then
d1466 1
a1466 1
      elseif(ndims > NENTRIESMAX) then
d1469 2
a1470 2
      endif
    endif
d1478 1
a1478 1
    endif
d1492 1
a1492 1
    elseif(nfields > NENTRIESMAX) then
d1496 1
a1496 1
    endif
d1499 2
a1500 3
    allocate(pressures(nfields), stat=status)
    if ( status /= 0 ) &
        & call announce_error(lcf_where, "failed to allocate pressures")
d1502 1
d1517 2
a1518 4
      endif
      allocate(field_data(dims(1), dims(2)), stat=status)
      if ( status /= 0 ) &
        & call announce_error(lcf_where, "failed to allocate field_data")
d1547 2
a1548 1
        allocate(all_the_fields(1, dims(1), dims(2)))
d1551 2
a1552 1
        allocate(now_the_fields(the_g_data%noHeights, dims(1), dims(2)))
d1555 1
a1555 1
        deallocate(all_the_fields)
d1557 3
a1559 3
      endif
      deallocate(field_data)
    enddo
d1583 1
a1583 1
    endif
d1592 1
a1592 1
    endif
d1594 2
a1595 2
    deallocate(all_the_fields)
    deallocate(pressures)
d1606 1
a1606 1
      enddo
d1609 2
a1610 2
      enddo
    endif
d1626 22
a1647 29
    contains 
       subroutine read_the_dim(gd_id, field_name, field_size, values)
         ! Arguments
         integer, intent(in) :: gd_id
         character(len=*), intent(in) :: field_name
         integer, intent(in) :: field_size
         real(r4), dimension(:), pointer :: values
         ! Local variables
         integer :: status
         integer, dimension(1) :: start, stride, edge
         ! Executable
         if ( associated(values) ) then
           deallocate(values, stat=status)
           if ( status /= 0 ) &
             & call announce_error(lcf_where, "failed to deallocate dim field")
         endif
         allocate(values(field_size), stat=status)
         if ( status /= 0 ) &
           & call announce_error(lcf_where, "failed to allocate dim field")
         start = 0                                                             
         stride = 1                                                             
         edge = field_size
         values = the_g_data%missingValue
         status = gdrdfld(gd_id, trim(field_name), start, stride, edge, &
           & values)                                                     
         if ( status /= 0 ) &
           & call announce_error(lcf_where, "failed to read dim field " &
           & // trim(field_name))
       end subroutine read_the_dim
d1653 1
d1743 1
a1743 1
    elseif ( strbufsize > MAXLISTLENGTH ) then
d1746 1
a1746 1
    elseif ( strbufsize < MAXLISTLENGTH .and. strbufsize > 0 ) then
d1748 1
a1748 1
    endif
d1762 1
a1762 1
    elseif(ngrids /= inq_success) then
d1765 1
a1765 1
    elseif(ngrids < GRIDORDER) then
d1768 1
a1768 1
    endif
d1774 1
a1774 1
    !endif
d1784 1
a1784 1
      endif
d1790 1
a1790 1
        elseif(nentries > NENTRIESMAX) then
d1792 1
a1792 1
        endif
d1798 1
a1798 1
        elseif(ndims > NENTRIESMAX) then
d1800 1
a1800 1
        endif
d1806 1
a1806 1
        elseif(nfields > NENTRIESMAX) then
d1808 1
a1808 1
        endif
d1812 1
a1812 1
        endif
d1818 1
a1818 1
        endif
d1823 1
a1823 1
        endif
d1826 1
a1826 1
        endif
d1845 1
a1845 1
    enddo
d1868 3
a1870 1
    allocate(t_all_fields(nlon, nlat, nlev), stat=status)
d1873 1
d1879 1
a1879 1
       endif
d1886 2
a1887 1
       allocate(all_the_fields(dims(1), dims(2), dims(3)), stat=status)
a1889 2
       if ( status /= 0 ) &
          & call announce_error(lcf_where, "failed to allocate field_data")
d1918 1
a1918 1
       endif
d1930 1
a1930 1
       endif
d1937 2
a1938 2
        deallocate(all_the_fields)
    enddo
d1948 1
a1948 1
    endif
d1950 1
a1950 1
    deallocate(t_all_fields)
d1955 1
a1955 1
    enddo
d1958 1
a1958 1
     enddo
d1971 22
a1992 29
    contains 
       subroutine read_the_dim(gd_id, field_name, field_size, values)
         ! Arguments
         integer, intent(in) :: gd_id
         character(len=*), intent(in) :: field_name
         integer, intent(in) :: field_size
         real(r8), dimension(:), pointer :: values
         ! Local variables
         integer :: status
         integer, dimension(1) :: start, stride, edge
         ! Executable
         if ( associated(values) ) then
           deallocate(values, stat=status)
           if ( status /= 0 ) &
             & call announce_error(lcf_where, "failed to deallocate dim field")
         endif
         allocate(values(field_size), stat=status)
         if ( status /= 0 ) &
           & call announce_error(lcf_where, "failed to allocate dim field")
         start = 0                                                             
         stride = 1                                                             
         edge = field_size                                                       
         values = the_g_data%missingValue
         status = he5_gdrdfld(gd_id, trim(field_name), &
           & hsizes(start), hsizes(stride), hsizes(edge), values)                                                     
         if ( status /= 0 ) &
           & call announce_error(lcf_where, "failed to read dim field " &
           & // trim(field_name))
       end subroutine read_the_dim
d2134 1
a2134 1
  subroutine READ_CLIMATOLOGY ( climFile, root, aprioriData, returnStatus, &
d2140 2
d2168 1
d2173 2
d2182 1
a2182 1
    endif
d2188 1
a2188 1
    endif
d2201 1
a2201 1
        call announce_error (ROOT, &
d2204 2
a2205 2
        return
      endif
d2215 1
a2215 1
    endif
d2222 1
a2222 1
      endif
d2224 1
a2224 1
    endif
d2247 1
a2247 1
          endif
d2252 1
a2252 1
          endif
d2256 1
a2256 1
          endif
d2271 1
a2271 1
          endif
d2273 1
a2273 1
        endif
d2283 1
a2283 1
      endif
d2288 1
a2288 1
      endif
d2294 1
a2294 1
    endif
d2296 5
a2300 1
  end subroutine READ_CLIMATOLOGY
d2379 1
a2379 1
    enddo
d2472 1
a2472 1
    endif
d2515 1
a2515 1
    elseif ( strbufsize > MAXLISTLENGTH ) then
d2518 1
a2518 1
    elseif ( strbufsize < MAXLISTLENGTH .and. strbufsize > 0 ) then
d2520 1
a2520 1
    endif
d2531 1
a2531 1
    elseif(ngrids /= inq_success) then
d2533 1
a2533 1
    elseif(ngrids < GRIDORDER) then
d2535 1
a2535 1
    endif
d2551 1
a2551 1
    endif
d2557 1
a2557 1
    endif
d2605 1
a2605 1
    elseif(default_output_by_toolkit) then
d2609 1
a2609 1
    endif
d2619 1
a2619 1
      endif
d2627 1
a2627 1
      endif
d2636 1
a2636 1
      endif
d2640 1
a2640 1
      endif
d2660 1
a2660 1
       "$Id: ncep_dao.f90,v 2.76 2014/04/02 23:02:52 pwagner Exp $"
d2670 3
@


2.76
log
@Removed redundant open_ and close_MLSFile
@
text
@d14 31
a44 30
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only : DUMP
  use GRIDDEDDATA, only: GRIDDEDDATA_T, RGR, V_IS_ALTITUDE, V_IS_GPH, &
    & V_IS_PRESSURE, V_IS_THETA, &
    & ADDGRIDDEDDATATODATABASE, DUMP, SETUPNEWGRIDDEDDATA, NULLIFYGRIDDEDDATA
  use HDFEOS, only: HDFE_NENTDIM, &
    & GDOPEN, GDATTACH, GDDETACH, GDCLOSE, GDFLDINFO, &
    & GDINQGRID, GDNENTRIES, GDINQDIMS, GDINQFLDS
  use HDF, only: DFACC_CREATE, DFACC_RDonly, DFACC_RDWR, &
    & DFNT_FLOAT32, DFNT_FLOAT64
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use L3ASCII, only: L3ASCII_READ_FIELD
  use LEXER_CORE, only: PRINT_SOURCE
  use MLSCOMMON, only: LINELEN, NAMELEN, FILENAMELEN, &
    & UNDEFINEDVALUE, MLSFILE_T
  use MLSFILES, only: FILENOTFOUND, HDFVERSION_5, &
    & DUMP, GETPCFROMREF, MLS_HDF_VERSION, MLS_OpenFile, MLS_CloseFile, &
    & SPLIT_PATH_NAME, MLS_OPENFILE, MLS_CLOSEFILE
  use MLSKINDS, only: R4, R8
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_INFO, MLSMSG_WARNING, &
    & MLSMESSAGE
  use MLSSTRINGS, only: CAPITALIZE, HHMMSS_VALUE, LOWERCASE
  use MLSSTRINGLISTS, only: GETSTRINGELEMENT, NUMSTRINGELEMENTS, &
    & LIST2ARRAY, REPLACESUBSTRING, STRINGELEMENTNUM
  use OUTPUT_M, only: OUTPUT
  use SDPTOOLKIT, only: PGS_S_SUCCESS, &
    & PGS_IO_GEN_CLOSEF, PGS_IO_GEN_OPENF, PGSD_IO_GEN_RSEQFRM, &
    & PGSD_GCT_INVERSE, &
    & USESDPTOOLKIT
  use TREE, only: DUMP_TREE_NODE, WHERE
d74 1
a74 1
  public:: READ_CLIMATOLOGY
d106 5
d114 16
a129 1
  subroutine ReadGriddedData( GriddedFile, lcf_where, description, v_type, &
d132 1
a132 1
    & date, sumDelp, litDescription, verbose )
a134 15
    ! This routine reads a Gridded Data file, returning a filled data
    ! structure and the  appropriate for the description
    ! which may be one of 'geos5_7', 'geos5', 'gmao', 'dao', 'merra', 'ncep', 'strat'

    ! FileName and the_g_data are required args
    ! GeoDimList should be the Dimensions' short names
    ! as a comma-delimited character string in the order:
    ! longitude, latitude, vertical level, time

    ! fieldName should name the rank 3 or higher object
    ! like temperature
    
    ! date is needed only for background files
    ! or any other case in which different files come with the date geolocations
    ! unset
d148 1
d155 1
d158 2
d178 1
d186 14
d341 1
a341 1
      call announce_error(lcf_where, 'READGriddedData called with unknown' &
d346 22
a367 1
  end subroutine ReadGriddedData
d400 1
d402 5
d408 2
a409 4
    integer :: error, rank
    integer(kind=hsize_t) :: dim1(1), dim4(4)
    real(r8), dimension(:), pointer :: temp1d
    real(r8), dimension(:,:,:,:), pointer :: temp4d
a412 2
    character(len=256) :: errormsg
    character(len=19) :: datestring ! will be in the form of yyyy-MM-ddTHH:MM:ss
d421 1
a421 1
    
d593 1
d595 2
a596 2
    allocate(temp4d(dim4(1), dim4(2), dim4(3), dim4(4)), stat=error)
    if (error /= 0) call announce_error(lcf_where, "Out of memory")
d600 5
a604 2
    allocate(the_g_data%field(dim4(3), dim4(2), dim4(1), 1,1,1), stat=error)
    if (error /= 0) call announce_error (lcf_where, "Out of memory")
d607 8
a614 1
    deallocate(temp4d)
d2665 1
a2665 1
       "$Id: ncep_dao.f90,v 2.75 2014/01/09 00:24:29 pwagner Exp $"
d2675 3
@


2.75
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d30 1
a30 1
    & DUMP, GETPCFROMREF, MLS_HDF_VERSION, OPEN_MLSFILE, CLOSE_MLSFILE, &
d2162 1
a2162 1
      call open_MLSFile( ClimFile )
d2231 1
a2231 1
        call close_MLSFile( ClimFile )
d2606 1
a2606 1
       "$Id: ncep_dao.f90,v 2.74 2013/09/24 23:27:14 vsnyder Exp $"
d2616 3
@


2.74
log
@Use Get_Where or Print_Source to start error messages
@
text
@d24 1
d38 1
a38 1
  use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
d2606 1
a2606 1
       "$Id: ncep_dao.f90,v 2.73 2012/07/11 20:01:06 pwagner Exp $"
d2616 3
@


2.73
log
@Dont use DEEBUG until after its defined
@
text
@d42 1
a42 1
  use TREE, only: DUMP_TREE_NODE, SOURCE_REF
d2561 1
a2561 1
        call print_source ( source_ref(lcf_where) )
d2605 1
a2605 1
       "$Id: ncep_dao.f90,v 2.72 2012/07/02 20:17:42 pwagner Exp $"
d2615 3
@


2.72
log
@Protect against bounds error when debugging with NAG
@
text
@a366 1
    verbose = ( switchDetail(switches, 'geos5') > -1 ) .or. DEEBUG
d374 1
a374 1

d2605 1
a2605 1
       "$Id: ncep_dao.f90,v 2.71 2012/05/15 16:53:06 pwagner Exp $"
d2615 3
@


2.71
log
@Allocate first, then give values
@
text
@d26 1
a26 1
  use MLSCOMMON, only: LINELEN, NAMELEN, FILENAMELEN, R8, R4, &
d31 3
a33 1
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
d791 6
d2606 1
a2606 1
       "$Id: ncep_dao.f90,v 2.70 2012/05/08 17:46:05 pwagner Exp $"
d2616 3
@


2.70
log
@Fixed bug that caused confusion when geos5 not ffound
@
text
@d384 2
a387 2
    allocate(the_g_data%lsts(1), stat=error)
    if (error /= 0) call announce_error(lcf_where, "Out of memory")
d2598 1
a2598 1
       "$Id: ncep_dao.f90,v 2.69 2012/03/06 19:33:11 pwagner Exp $"
d2608 3
@


2.69
log
@Remove more unused things
@
text
@d90 2
d151 5
a155 1
    if ( LIT_DESCRIPTION == 'geos5' ) &
d182 1
d2598 1
a2598 1
       "$Id: ncep_dao.f90,v 2.68 2012/03/01 20:00:35 pwagner Exp $"
d2608 3
@


2.68
log
@When verbose, note when file does not fit description
@
text
@d318 1
a318 2
    use MLSHDF5, only: DUMPHDF5ATTRIBUTES, DUMPHDF5DS, &
      & GETALLHDF5ATTRNAMES, GETALLHDF5DSNAMES, &
d352 1
a352 1
    integer :: mydate, mytime, timeinc, year, month, day, hour, minute, second
d2591 1
a2591 1
       "$Id: ncep_dao.f90,v 2.67 2011/11/30 21:28:23 pwagner Exp $"
d2601 3
@


2.67
log
@Converted most debugging prints to verbose ones; more robust
@
text
@d180 5
a184 1
      if ( myVerbose .and. associated(the_g_data%field) ) then
d200 5
a204 1
      if ( myVerbose .and. associated(the_g_data%field) ) then
d220 5
a224 1
      if ( myVerbose .and. associated(the_g_data%field) ) then
d244 5
a248 1
      if ( myVerbose .and. associated(the_g_data%field) ) then
d266 5
a270 1
      if ( myVerbose .and. associated(the_g_data%field) ) then
d288 5
a292 1
      if ( myVerbose .and. associated(the_g_data%field) ) then
d2592 1
a2592 1
       "$Id: ncep_dao.f90,v 2.66 2011/08/30 22:23:46 pwagner Exp $"
d2602 3
@


2.66
log
@Should not try to read as geos5_7 if not hdf5
@
text
@d39 1
a39 1
    & useSDPTOOLKIT
d145 2
a146 2
    myVerbose = .false.
    if ( present(verbose) ) myVerbose = .true.
d156 3
d180 10
a189 9
      if ( DEEBUG ) then
        print *, '(Returned from read_geos5)'
        print *, 'Quantity Name   ' // trim(the_g_data%QuantityName)
        print *, 'Description     ' // trim(the_g_data%description)
        print *, 'Units           ' // trim(the_g_data%units)
        print *, 'Vertical Coord  ', the_g_data%verticalCoordinate, v_type, v_is_pressure
        print *, 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue )
        print *, 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue )
        print *, 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue )
d196 10
a205 9
      if ( DEEBUG ) then
        print *, '(Returned from read_geos5)'
        print *, 'Quantity Name   ' // trim(the_g_data%QuantityName)
        print *, 'Description     ' // trim(the_g_data%description)
        print *, 'Units           ' // trim(the_g_data%units)
        print *, 'Vertical Coord  ', the_g_data%verticalCoordinate, v_type, v_is_pressure
        print *, 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue )
        print *, 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue )
        print *, 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue )
d212 12
a223 6
      if ( DEEBUG ) then
        print *, '(Returned from read_dao)'
        print *, 'Quantity Name   ' // trim(the_g_data%QuantityName)
        print *, 'Description     ' // trim(the_g_data%description)
        print *, 'Units           ' // trim(the_g_data%units)
        print *, 'Vertical Coord  ', the_g_data%verticalCoordinate, v_type, v_is_pressure
d232 13
d250 12
a261 5
      if ( DEEBUG ) then
        print *, '(Returned from Read_ncep_gdas)'
        print *, 'Quantity Name ' // trim(the_g_data%QuantityName)
        print *, 'Description   ' // trim(the_g_data%description)
        print *, 'Units         ' // trim(the_g_data%units)
d268 12
a279 5
      if ( DEEBUG ) then
        print *, '(Returned from read_ncep-strat)'
        print *, 'Quantity Name ' // trim(the_g_data%QuantityName)
        print *, 'Description   ' // trim(the_g_data%description)
        print *, 'Units         ' // trim(the_g_data%units)
d292 2
d298 2
a299 2
    use HDF5, only: HSIZE_T
    use DATES_MODULE, only: UTC2TAI93S
d332 1
d335 1
d345 1
a345 1
    if ( DEEBUG ) call dump(mysdList, 'DS names')
d359 1
d384 1
d405 1
d529 1
d2568 1
a2568 1
       "$Id: ncep_dao.f90,v 2.65 2011/08/03 22:50:03 pwagner Exp $"
d2578 3
@


2.66.2.1
log
@Can Read GEOS5.7.2 meteorology; based on v3.33
@
text
@d39 1
a39 1
    & USESDPTOOLKIT
d145 2
a146 2
    myVerbose = deebug
    if ( present(verbose) ) myVerbose = verbose .or. deebug
a155 3
    the_g_data%QuantityName = '(none)'
    the_g_data%description  = '(none)'
    the_g_data%units        = '(none)'
d177 9
a185 10
      if ( myVerbose ) then
        call output( '(Returned from read_geos5_7)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
d192 9
a200 10
      if ( myVerbose ) then
        call output( '(Returned from read_geos5)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
d207 6
a212 12
      if ( myVerbose ) then
        call output( '(Returned from read_dao)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue('associated(the_g_data%field)', associated(the_g_data%field))
        call outputNamedValue('NumStringElements', NumStringElements(fieldNames, COUNTEMPTY))
a220 13
      if ( myVerbose ) then
        call output( '(Returned from read merra)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue('associated(the_g_data%field)', associated(the_g_data%field))
        call outputNamedValue('NumStringElements', NumStringElements(fieldNames, COUNTEMPTY))
      endif
d226 5
a230 12
      if ( myVerbose ) then
        call output( '(Returned from read_ncep_gdas)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue('associated(the_g_data%field)', associated(the_g_data%field))
        call outputNamedValue('NumStringElements', NumStringElements(fieldNames, COUNTEMPTY))
d237 5
a241 12
      if ( myVerbose ) then
        call output( '(Returned from read_ncep_strat)', advance='yes' )
        call output( 'Quantity Name   ' // trim(the_g_data%QuantityName), advance='yes' )
        call output( 'Description     ' // trim(the_g_data%description), advance='yes' )
        call output( 'Units           ' // trim(the_g_data%units), advance='yes' )
        call outputNamedValue( 'Vertical Coord, type, type(P)  ', &
          & (/ the_g_data%verticalCoordinate, v_type, v_is_pressure /) )
        call outputNamedValue( 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue( 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue ) )
        call outputNamedValue('associated(the_g_data%field)', associated(the_g_data%field))
        call outputNamedValue('NumStringElements', NumStringElements(fieldNames, COUNTEMPTY))
a253 2
    use DATES_MODULE, only: UTC2TAI93S
    use HDF5, only: HSIZE_T
d258 2
a259 2
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use TOGGLES, only: SWITCHES
a291 1
    logical :: verbose
a293 1
    verbose = ( switchDetail(switches, 'geos5') > -1 ) .or. DEEBUG
d303 1
a303 1
    if ( verbose ) call dump(mysdList, 'DS names')
a316 1
    the_g_data%lsts = the_g_data%missingValue ! Know how to read this yet?
a340 1
    mytime = 0. ! In case it's not found
a360 1
    mydate = 10000*2001 + 1*100 + 1 ! In case it's not found
a483 1
    if ( verbose ) call dump( the_g_data, details = 1 )
d2522 1
a2522 1
       "$Id: ncep_dao.f90,v 2.66 2011/08/30 22:23:46 pwagner Exp $"
a2531 3
! Revision 2.66  2011/08/30 22:23:46  pwagner
! Should not try to read as geos5_7 if not hdf5
!
@


2.65
log
@Repaired syntax of write; removed unused variables; updated toc
@
text
@d28 1
a28 1
  use MLSFILES, only: FILENOTFOUND, &
d167 8
d2522 1
a2522 1
       "$Id: ncep_dao.f90,v 2.64 2011/08/03 15:36:23 honghanh Exp $"
d2532 3
@


2.64
log
@Move one line of code around for better readability
@
text
@d14 5
a18 5
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use dump_0, only : dump
  use GriddedData, only: GriddedData_T, rgr, v_is_altitude, v_is_gph, &
    & v_is_pressure, v_is_theta, &
    & AddGriddedDataToDatabase, Dump, SetupNewGriddedData, NullifyGriddedData
d20 3
a22 3
    & gdopen, gdattach, gddetach, gdclose, gdfldinfo, &
    & gdinqgrid, gdnentries, gdinqdims, gdinqflds
  use Hdf, only: DFACC_CREATE, DFACC_RDONLY, DFACC_RDWR, &
d24 1
a24 1
  use l3ascii, only: l3ascii_read_field
d26 9
a34 9
  use MLSCommon, only: LineLen, NameLen, FileNameLen, R8, R4, &
    & undefinedValue, MLSFile_T
  use MLSFiles, only: FILENOTFOUND, &
    & Dump, GetPCFromRef, MLS_HDF_VERSION, open_MLSFile, close_MLSFile, &
    & split_path_name, mls_openFile, mls_closeFile
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
  use MLSStrings, only: Capitalize, HHMMSS_value, LowerCase
  use MLSStringLists, only: GetStringElement, NumStringElements, &
    & List2Array, ReplaceSubString, StringElementNum
d36 1
a36 1
  use SDPToolkit, only: PGS_S_SUCCESS, &
d38 2
a39 2
    & PGSd_GCT_INVERSE, &
    & UseSDPToolkit
d56 12
a67 4
! read_climatology            read l3ascii-formatted climatology file
! ReadGriddedData             read hdfeos-formatted meteorology file
! WriteGriddedData            write hdfeos-formatted meteorology file
! ReadGloriaFile              read binary-formatted file designed by G. Manney
d246 6
a251 6
    use MLSHDF5, only: DumpHDF5Attributes, DumpHDF5DS, &
      & GetAllHDF5AttrNames, GetAllHDF5DSNames, &
      & GetHDF5DSRank, GetHDF5DSDims, LoadFromHDF5DS, &
      & ReadHDF5Attribute
    use HDF5, only: hSize_t
    use dates_module, only: utc2tai93s
d377 3
a379 2
    write(datestring, '(I4.4, A1, I2.2, A1, I2.2, A1, I2.2, A1, I2.2, A1, I2.2)'), &
                    & year, '-',  month, '-', day, 'T', hour, ':', minute, ':', second
d1516 2
a1517 2
    use MLSHDFEOS, only: hsizes
    use hdf5, only: size_t
a2160 1
    use MLSStats1, only: MLSMIN, MLSMAX, MLSMEAN
d2164 1
d2178 7
d2221 1
a2221 1
        call Write_merra( (fieldIndex==1), GriddedFile, lcf_where, v_type, &
d2237 1
a2237 1
  subroutine Write_merra( createGrid, GEOS5File, lcf_where, v_type, &
a2268 1
    integer, intent(IN)                     :: v_type       ! vertical coordinate; an 'enumerated' type
a2273 1
    integer :: itime, ilat, ilon, ilev
a2274 3
    integer :: inq_success
    integer :: nentries, ngrids, ndims, nfields
    integer :: strbufsize
a2276 5
    character (len=MAXLISTLENGTH) :: gridlist
    character (len=MAXLISTLENGTH) :: dimlist, actual_dim_list
    character (len=MAXLISTLENGTH), dimension(1) :: dimlists
    character (len=16), dimension(NENTRIESMAX) :: dimNames
    character (len=MAXLISTLENGTH) :: fieldlist
d2278 1
a2278 3
    integer, dimension(NENTRIESMAX) :: dims, rank, numberTypes
    integer                        :: our_rank, numberType
    logical                        :: mySum
a2281 4
    character(len=16) :: the_units
    integer                        :: timeIndex
    !                                  These start out initialized to one
    integer                        :: nlon=1, nlat=1, nlev=1, ntime=1
a2285 1
    integer, external :: GDRDFLD
a2288 3
    real(r4), dimension(:,:,:,:), pointer :: all_the_fields => null()
    real(r8), dimension(:), pointer :: dim_field, pb
    real(r8) :: dateValue
d2514 1
a2514 1
       "$Id: ncep_dao.f90,v 2.63 2011/08/02 17:26:37 honghanh Exp $"
d2524 3
@


2.63
log
@Remove code that read time_increment attribute
@
text
@d425 2
a436 3
    ! this maybe wrong
    the_g_data%heightsunits = 'hPa'

d2518 1
a2518 1
       "$Id: ncep_dao.f90,v 2.62 2011/08/02 17:23:59 honghanh Exp $"
d2528 3
@


2.62
log
@Make datestarts and dateends the same.
@
text
@d335 5
a339 5
    if (.not. ReadHDF5Attribute(geos5file%fileid%f_id, 'time', &
        & 'time_increment', timeinc, error=errormsg)) then
        call announce_error (lcf_where, errormsg // ' in file ' &
        & // geos5file%name)
    endif
d341 3
a343 3
    if (timeinc <= 0) then
        call announce_error (lcf_where, "Invalid 'time_increment' value in " // geos5file%name)
    endif
d379 6
a384 6
    hour = timeinc / 10000
    minute = mod(timeinc, 10000) / 100
    second = mod(timeinc, 100)
    if (hour > 24 .or. minute > 60 .or. second > 60) then
        call announce_error (lcf_where, "Invalid 'time_increment' value in " // geos5file%name)
    endif
d2519 1
a2519 1
       "$Id: ncep_dao.f90,v 2.61 2011/08/02 16:48:51 honghanh Exp $"
d2529 3
@


2.61
log
@Implement readgeos5_7
@
text
@d386 2
a387 1
    the_g_data%dateends(1) = the_g_data%datestarts(1) + hour * 3600 + minute * 60 + second
d2519 1
a2519 1
       "$Id: ncep_dao.f90,v 2.60 2011/06/29 21:38:23 pwagner Exp $"
d2529 3
@


2.60
log
@Uses output api
@
text
@d30 1
a30 1
    & split_path_name
d239 5
a243 1
      & GetAllHDF5AttrNames, GetAllHDF5DSNames
d267 10
d285 1
d288 179
d2518 1
a2518 1
       "$Id: ncep_dao.f90,v 2.59 2011/05/05 23:09:22 pwagner Exp $"
d2528 3
@


2.59
log
@verbose when requested via optional arg
@
text
@d143 2
a144 1
    if ( myVerbose ) print *, 'Reading ' // trim(LIT_DESCRIPTION) // ' data'
d2324 1
a2324 1
       "$Id: ncep_dao.f90,v 2.58 2011/04/27 17:36:12 pwagner Exp $"
d2334 3
@


2.58
log
@Consistently sets grid%empty when not found or wrong description
@
text
@d98 1
a98 1
    & date, sumDelp, litDescription )
d130 1
d135 1
d137 2
d143 1
a143 1
    if ( DEEBUG ) print *, 'Reading ' // trim(LIT_DESCRIPTION) // ' data'
d2323 1
a2323 1
       "$Id: ncep_dao.f90,v 2.57 2011/04/20 16:56:16 pwagner Exp $"
d2333 3
@


2.57
log
@First steps toward being able to read next GMAO format
@
text
@d97 2
a98 1
    & GeoDimList, fieldNames, missingValue, date, sumDelp )
d129 1
d142 1
d226 1
d451 7
a457 2
    if ( StringElementNum( fieldlist, trim(actual_field_name), COUNTEMPTY ) < 1 ) then
      call output( trim(actual_field_name) // ' not found in geos5 file', advance='yes' )
d472 1
d474 1
a474 1
        & trim(actual_field_name) // ' not found in ' // trim(GEOS5File%Name) )
d579 1
d583 11
d595 1
d2319 1
a2319 1
       "$Id: ncep_dao.f90,v 2.56 2010/03/31 18:12:10 pwagner Exp $"
d2329 3
@


2.56
log
@Added WriteGriddedData
@
text
@d15 1
d67 1
d89 2
d102 1
a102 1
    ! which may be one of 'geos5', 'gmao', 'dao', 'merra', 'ncep', 'strat'
a130 1
    character ( len=NameLen) :: my_description   ! In case mixed case
d134 4
a137 4
    my_description = lowercase(description)
    if ( my_description == 'geos5' ) &
      & my_description = GEOS5orMERRA( GriddedFile )
    if ( DEEBUG ) print *, 'Reading ' // trim(my_description) // ' data'
d149 16
a164 1
    select case ( trim(my_description) )
d166 1
a166 1
      call Read_geos5( GriddedFile, lcf_where, v_type, &
d195 1
a195 1
      call Read_merra( GriddedFile, lcf_where, v_type, &
d221 1
a221 1
        & // ' description: ' // trim(my_description))
d226 5
a230 4
  ! ----------------------------------------------- Read_geos5
  subroutine Read_geos5( GEOS5File, lcf_where, v_type, &
    & the_g_data, GeoDimList, fieldName, date )
    use Dump_0, only: Dump
d232 2
a233 17
    ! This routine reads a gmao geos5 file, named something like
    ! DAS.ops.asm.tavg3d_prs_v.GEOS500.20060320_0000.V01 (pressure with
    ! fieldname='PL') or 
    ! DAS.ops.asm.tavg3d_dyn_v.GEOS500.20060320_0000.V01 (temperature
    ! with fieldname='T') 
    ! returning a filled data
    ! structure appropriate for newer style gmao geos5
    ! (And just how does it differ from the older style? 
    !  For one thing it holds 4-d, not 3-d fields)

    ! FileName and the_g_data are required args
    ! GeoDimList, if present, should be the Dimensions' short names
    ! as a comma-delimited character string in the order:
    ! longitude, latitude, vertical level, time

    ! fieldName, if present, should be the rank 4
    ! like temperature
d249 6
a254 107

    ! Local Variables
    integer :: file_id, gd_id
    integer :: inq_success
    integer :: nentries, ngrids, ndims, nfields
    integer :: strbufsize
    logical,  parameter       :: CASESENSITIVE = .false.
    integer, parameter :: GRIDORDER=1   ! What order grid written to file
    character (len=MAXLISTLENGTH) :: gridlist
    character (len=MAXLISTLENGTH) :: dimlist, actual_dim_list
    character (len=MAXLISTLENGTH), dimension(1) :: dimlists
    character (len=16), dimension(NENTRIESMAX) :: dimNames
    character (len=MAXLISTLENGTH) :: fieldlist
    integer, parameter :: MAXNAMELENGTH=NameLen         ! Max length of grid name
    character (len=MAXNAMELENGTH) :: gridname, actual_field_name
    integer, dimension(NENTRIESMAX) :: dims, rank, numberTypes
    integer                        :: our_rank, numberType

    integer :: start(4), stride(4), edge(4)
    integer :: status
    character(len=16) :: the_units
    !                                  These start out initialized to one
    integer                        :: nlon=1, nlat=1, nlev=1, ntime=1
    integer, parameter             :: i_longitude=1
    integer, parameter             :: i_latitude=i_longitude+1
    integer, parameter             :: i_vertical=i_latitude+1
    integer, parameter             :: i_time=i_vertical+1
    integer, external :: GDRDFLD
    real(r4), parameter :: FILLVALUE = 1.e15
    real(r4), dimension(:,:,:,:), pointer :: all_the_fields
    real(r8), dimension(:), pointer :: dim_field
    real(r8) :: dateValue
    logical, parameter :: DEEBUG = .false.
    ! Executable code
    dateValue = 0.
    if ( present(date) ) dateValue = HHMMSS_value( date, status )
    ! Find list of grid names on this file (This has been core dumping on me)
    if(DEEBUG) print *, 'About to find grid list of file ', trim(GEOS5File%Name)
    gridlist = ''
    inq_success = gdinqgrid(GEOS5File%Name, gridlist, strbufsize)
    if (inq_success < 0) then
      call announce_error(lcf_where, "Could not inquire gridlist "// &
        & trim(GEOS5File%Name))
    elseif ( strbufsize > MAXLISTLENGTH ) then
       CALL MLSMessage ( MLSMSG_Error, moduleName,  &
          & 'list size too big in Read_geos5 ' // trim(GEOS5File%Name), MLSFile=GEOS5File )
    elseif ( strbufsize < MAXLISTLENGTH .and. strbufsize > 0 ) then
      gridlist = gridlist(1:strbufsize) // ' '
    endif
    if(DEEBUG) print *, 'grid list ', trim(gridlist)

    error = 0
    file_id = gdopen(GEOS5File%Name, DFACC_RDONLY)

    if (file_id < 0) then
      call announce_error(lcf_where, "Could not open "// GEOS5File%Name)
    end if

    ! Find grid name corresponding to the GRIDORDER'th one
    ngrids = NumStringElements(gridlist, COUNTEMPTY)

    if(ngrids <= 0) then
      call announce_error(lcf_where, "NumStringElements of gridlist <= 0")
    elseif(ngrids /= inq_success) then
      call announce_error(lcf_where, "NumStringElements of gridlist /= inq_success")
    elseif(ngrids < GRIDORDER) then
      call announce_error(lcf_where, "NumStringElements of gridlist < GRIDORDER")
    endif

    call GetStringElement(gridlist, gridname, GRIDORDER, COUNTEMPTY)

    gd_id = gdattach(file_id, gridname)
    if (gd_id < 0) then
      call announce_error(lcf_where, "Could not attach "//trim(gridname))
    end if

    ! Now find dimsize(), dimname(), etc.
    nentries = gdnentries(gd_id, HDFE_NENTDIM, strbufsize)

    if(nentries <= 0) then
      call announce_error(lcf_where, "nentries of gd_id <= 0")
    elseif(nentries > NENTRIESMAX) then
      call announce_error(lcf_where, "nentries of gd_id > NENTRIESMAX")
    endif

    dimlist = ''
    ndims = gdinqdims(gd_id, dimlist, dims)

    if(ndims <= 0) then
      call announce_error(lcf_where, "ndims of gd_id <= 0")
    elseif(ndims > NENTRIESMAX) then
      call announce_error(lcf_where, "ndims of gd_id > NENTRIESMAX")
    endif

    fieldlist = ''
    nfields = gdinqflds(gd_id, fieldlist, rank, numberTypes)

    if(nfields <= 0) then
      call announce_error(lcf_where, "nfields of gd_id <= 0")
    elseif(nfields > NENTRIESMAX) then
      call announce_error(lcf_where, "nfields of gd_id > NENTRIESMAX")
    endif

    if(.not. CASESENSITIVE) then
      fieldlist = Capitalize(fieldlist)
    endif

a259 16

    if(DEEBUG) print *, 'nentries ', nentries
    if(DEEBUG) print *, 'ndims ', ndims
    if(DEEBUG) print *, 'dimlist ', dimlist
    if(DEEBUG) print *, 'nfields ', nfields
    if(DEEBUG) print *, 'fieldlist ', fieldlist
    if(DEEBUG) print *, 'actual_field_name ', actual_field_name

    actual_dim_list = ' '
    if(present(GeoDimList)) then
      actual_dim_list=GeoDimList
    endif
    if ( actual_dim_list == ' ' ) then
      actual_dim_list = DEFAULTDAODIMLIST
    endif
    call List2Array (actual_dim_list, dimNames, countEmpty)
d261 4
a264 15
    ! Check that our requested field is present
    if ( StringElementNum( fieldlist, trim(actual_field_name), COUNTEMPTY ) < 1 ) then
      call output( trim(actual_field_name) // ' not found in geos5 file', advance='yes' )
      status = gddetach(gd_id)
      if(status /= 0) &
        & call announce_error(lcf_where, "failed to detach from grid " &
        & //trim(gridname))
      status = gdclose(file_id)
      if(status /= 0) &
        & call announce_error(lcf_where, "failed to close file " //trim(GEOS5File%Name))
        return
    endif
    ! Now find the rank of our field
    inq_success = gdfldinfo(gd_id, trim(actual_field_name), our_rank, dims, &
      & numbertype, dimlists(1))
d266 2
a267 153
    dimlist = trim(dimlists(1))
    if(DEEBUG) print *, 'our_rank ', our_rank
    if(DEEBUG) print *, 'dims ', dims(1:our_rank)
    if(DEEBUG) print *, 'dimlist ', dimlist

    nlon = dims(1)
    nlat = dims(2)
    nlev = dims(3)
    ntime = dims(4)

    the_g_data%quantityName = actual_field_name
    the_g_data%description = lit_geos5
    the_g_data%verticalCoordinate = v_type

    the_g_data%noLons = nlon
    the_g_data%noLats = nlat
    the_g_data%noHeights = nlev
    ! the_g_data%noLsts = ntime
    the_g_data%noDates = ntime
    ! The following is an awful hack
    ! to prevent me from the having to read the units attribute
    select case ( lowercase(actual_field_name) )
    case ( 'pl' )
      the_units = 'Pa'
    case ( 't' )
      the_units = 'K'
    case default
      the_units = 'Pa'
    end select
    if(DEEBUG) print *, 'our quantity name ', the_g_data%quantityName
    if(DEEBUG) print *, 'our description ', the_g_data%description
    if(DEEBUG) print *, 'our units ', the_units
    if(DEEBUG) print *, 'our vertical coord ', the_g_data%verticalCoordinate
    if(DEEBUG) print *, 'v_type ', v_type

    ! Setup the grid
    call SetupNewGriddedData ( the_g_data, noHeights=nlev, noLats=nlat, &
      & noLons=nlon, noLsts=1, noSzas=1, noDates=ntime, &
      & missingValue=FILLVALUE, units=the_units, verticalCoordinate=v_type, &
      & heightsunits='hPa' )
      ! & noLons=nlon, noLsts=ntime, noSzas=1, noDates=1, missingValue=FILLVALUE )
    if(DEEBUG) print *, '(Again) our quantity name ', the_g_data%quantityName
    if(DEEBUG) print *, 'our description ', the_g_data%description
    if(DEEBUG) print *, 'our units ', the_g_data%units
    if(DEEBUG) print *, 'our vertical coord ', the_g_data%verticalCoordinate
    if(DEEBUG) print *, 'v_type ', v_type
    allocate(all_the_fields(dims(1), dims(2), dims(3), dims(4)), stat=status)
    all_the_fields = the_g_data%missingValue
    if ( status /= 0 ) &
        & call announce_error(lcf_where, "failed to allocate field_data")
    start = 0                                                             
    stride = 1                                                               
    edge = dims(1:4)                                                        
    if(DEEBUG) print *, 'About to read ' // trim(actual_field_name)
    if(DEEBUG) print *, 'Start ', Start
    if(DEEBUG) print *, 'Stride ', Stride
    if(DEEBUG) print *, 'Edge ', Edge
    status = gdrdfld(gd_id, trim(actual_field_name), start, stride, edge, &  
      & all_the_fields)                                                          
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to read field " &
      & //trim(actual_field_name))
    ! The actual dimlist is this                    XDim,YDim,Height,TIME
    ! Need to reshape it so that the order becomes: Height,YDim,XDim,TIME
    if ( DEEBUG) then
      print *, 'dao Before reshaping'
      call dump(all_the_fields(:,1,1,1), 'x-slice')
      call dump(all_the_fields(1,:,1,1), 'y-slice')
      call dump(all_the_fields(1,1,:,1), 'p-slice')
      call dump(all_the_fields(1,1,1,:), 't-slice')
    endif
    ! the_g_data%field(:,:,:,:,1,1) = reshape( all_the_fields, &
    the_g_data%field(:,:,:,1,1,:) = reshape( all_the_fields, &
      & shape=(/nLev, nlat, nlon, ntime/), order=(/3,2,1,4/) &
      & )
    if ( DEEBUG ) then
      print *, 'dao After reshaping'
      call dump(the_g_data%field(1,1,:,1,1,1), 'x-slice')
      call dump(the_g_data%field(1,:,1,1,1,1), 'y-slice')
      call dump(the_g_data%field(:,1,1,1,1,1), 'p-slice')
      call dump(the_g_data%field(1,1,1,:,1,1), 't-slice')
    endif
    deallocate(all_the_fields)
    ! Now read the dims
    nullify(dim_field)
    ! call read_the_dim(gd_id, 'XDim', dims(1), dim_field)
    call read_the_dim(gd_id, trim(dimNames(1)), dims(1), dim_field)
    the_g_data%lons = dim_field
    ! call read_the_dim(gd_id, 'YDim', dims(2), dim_field)
    call read_the_dim(gd_id, trim(dimNames(2)), dims(2), dim_field)
    the_g_data%lats = dim_field
    ! call read_the_dim(gd_id, 'Height', dims(3), dim_field)
    call read_the_dim(gd_id, trim(dimNames(3)), dims(3), dim_field)
    the_g_data%Heights = dim_field
    ! call read_the_dim(gd_id, 'Time', dims(4), dim_field)
    call read_the_dim(gd_id, trim(dimNames(4)), dims(4), dim_field)
    ! the_g_data%lsts = dim_field
    ! Because GMAO background files have no date field
    if ( all(dim_field == 0._r8) ) then
      the_g_data%dateStarts = dateValue
      the_g_data%dateEnds = dateValue
    else
      the_g_data%dateStarts = dim_field
      the_g_data%dateEnds = dim_field
    endif
    deallocate(dim_field)        ! Before leaving, some light housekeeping
    ! Have not yet figured out how to assign these
    ! Probably will have to read metadata
    the_g_data%Szas = the_g_data%missingValue
    ! the_g_data%DateStarts = the_g_data%missingValue
    ! the_g_data%DateEnds = the_g_data%missingValue
    the_g_data%lsts = the_g_data%missingValue
    ! Close grid
    status = gddetach(gd_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to detach from grid " &
      & //trim(gridname))
    status = gdclose(file_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to close file " //trim(GEOS5File%Name))
    contains 
       subroutine read_the_dim(gd_id, field_name, field_size, values)
         ! Arguments
         integer, intent(in) :: gd_id
         character(len=*), intent(in) :: field_name
         integer, intent(in) :: field_size
         real(r8), dimension(:), pointer :: values
         ! Local variables
         integer :: status
         integer, dimension(1) :: start, stride, edge
         ! Executable
         if ( associated(values) ) then
           deallocate(values, stat=status)
           if ( status /= 0 ) &
             & call announce_error(lcf_where, "failed to deallocate dim field")
         endif
         allocate(values(field_size), stat=status)
         if ( status /= 0 ) &
           & call announce_error(lcf_where, "failed to allocate dim field")
         start = 0                                                             
         stride = 1                                                             
         edge = field_size                                                       
         values = the_g_data%missingValue
         status = gdrdfld(gd_id, trim(field_name), start, stride, edge, &
           & values)                                                     
         if ( status /= 0 ) &
           & call announce_error(lcf_where, "failed to read dim field " &
           & // trim(field_name))
       end subroutine read_the_dim
  end subroutine Read_geos5

  ! ----------------------------------------------- Read_merra
  subroutine Read_merra( GEOS5File, lcf_where, v_type, &
a268 1
    use Dump_0, only: Dump
d270 5
a274 1
    ! This routine reads a gmao MERRA file, named something like
d278 1
a278 2
    ! structure appropriate for newer style gmao merra
    ! (For one thing it holds 4-d, not 3-d fields)
a293 4
    ! This is so similar to read_geos5 that we ought to combine the two into
    ! a single routine, except the extra timeIndex business would need
    ! careful handling

d338 1
a338 1
    logical, parameter :: DEEBUG = .false.
d342 9
d367 1
a367 1
          & 'list size too big in Read_merra ' // trim(GEOS5File%Name), MLSFile=GEOS5File )
a428 6
    if(present(fieldName)) then
      actual_field_name=fieldName
    else
      actual_field_name=DEFAULTGEOS5FIELDNAME
    endif

d445 13
d462 5
d485 5
a489 1
    the_g_data%noDates = 1 ! ntime
d508 1
a508 1
      & noLons=nlon, noLsts=1, noSzas=1, noDates=1, & ! noDates=ntime, &
a510 1
      ! & noLons=nlon, noLsts=ntime, noSzas=1, noDates=1, missingValue=FILLVALUE )
a516 3
    ! allocate(all_the_fields(dims(1), dims(2), dims(3), dims(4)), stat=status)
    ! if ( status /= 0 ) &
    !    & call announce_error(lcf_where, "failed to allocate field_data")
d518 1
a518 1
        & 'all_the_fields', ModuleName // 'Read_merra' )
d537 1
a537 1
        & ModuleName // 'Read_merra' )
d557 1
a557 1
        & ModuleName // 'Read_merra' )
d562 1
a562 1
      print *, 'merra Before reshaping'
d568 9
a576 6
    ! the_g_data%field(:,:,:,:,1,1) = reshape( all_the_fields, &
    the_g_data%field(:,:,:,1,1,1) = reshape( all_the_fields(:,:,:,timeIndex), &
      & shape=(/nLev, nlat, nlon/), order=(/3,2,1/) &
      & )
      ! & shape=(/nLev, nlat, nlon, ntime/), order=(/3,2,1,4/) &
      ! & )
d578 1
a578 1
      print *, 'dao After reshaping'
a583 1
    ! deallocate(all_the_fields)
d585 1
a585 1
        & ModuleName // 'Read_merra' )
d604 3
d659 1
a659 1
  end subroutine Read_merra
a663 1
    use Dump_0, only: Dump
a954 1
    use Dump_0, only: Dump
a1280 1
    use Dump_0, only: Dump
a2000 1
    use Dump_0, only: Dump
d2296 1
a2296 1
       "$Id: ncep_dao.f90,v 2.55 2010/02/04 23:08:00 vsnyder Exp $"
d2306 3
@


2.55
log
@Remove USE or declaration for unused names
@
text
@d21 2
a22 1
  use Hdf, only: DFACC_RDONLY
d57 1
d63 1
d2179 196
d2551 1
a2551 1
       "$Id: ncep_dao.f90,v 2.54 2009/11/04 23:16:49 pwagner Exp $"
d2561 3
@


2.54
log
@Fixed bugs in recognizing and reading merra files
@
text
@a124 1
    integer :: nFieldNames
d1537 1
a1537 1
    use hdf5, only: hsize_t, hssize_t, size_t
d2196 2
a2197 2
    character (len=MAXNAMELENGTH) :: gridname, actual_field_name
    integer, dimension(NENTRIESMAX) :: dims, rank, numberTypes
d2352 1
a2352 1
       "$Id: ncep_dao.f90,v 2.53 2009/09/29 23:35:09 pwagner Exp $"
d2362 3
@


2.53
log
@Changes needed by 64-bit build
@
text
@d106 1
a106 1
    ! or any other case in which different files come with the date gelolocations
d130 2
a159 21
      if ( .not. associated(the_g_data%field) .and. &
        & NumStringElements(fieldNames, COUNTEMPTY) > 1 ) then
        ! we will try again with this file, assuming we were supplied with
        ! a declaration like this:
        ! geos5SumInput: gridded, origin=geos5, field='PL,DELP',  ..
        call getStringElement(fieldNames, fieldName, 2, COUNTEMPTY)
        if ( DEEBUG ) call output( 'trying again with ' // trim(fieldName), advance='yes' )
        call Read_merra( GriddedFile, lcf_where, v_type, &
          & the_g_data, GeoDimList, fieldName, date, sumDelp )
        if ( DEEBUG ) then
          print *, '(Returned from read_merra)'
          print *, 'Quantity Name   ' // trim(the_g_data%QuantityName)
          print *, 'Description     ' // trim(the_g_data%description)
          print *, 'Units           ' // trim(the_g_data%units)
          print *, 'Vertical Coord  ', the_g_data%verticalCoordinate, v_type, v_is_pressure
          if ( .not. associated(the_g_data%field) ) return
          print *, 'max val  ', mlsmax( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue )
          print *, 'min val  ', mlsmin( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue )
          print *, 'meanval  ', mlsmean( the_g_data%field(:,:,:,1,1,1), the_g_data%missingValue )
        endif
      endif
d171 4
d546 1
a546 3
    ! fieldname='DELP') or 
    ! MERRA300.prod.assim.inst3_3d_asm_Cp.20050330.hdf (temperature
    ! with fieldname='T') 
d548 1
a548 1
    ! structure appropriate for newer style gmao geos5
d565 3
a567 2
    ! This is so similar to read_geos5 that we may combine the two into
    ! a single routine
d601 1
d610 1
a610 1
    real(r4), dimension(:,:,:,:), pointer :: all_the_fields
d617 5
d739 1
a739 1
    the_g_data%noDates = ntime
d758 1
a758 1
      & noLons=nlon, noLsts=1, noSzas=1, noDates=ntime, &
d767 6
a772 1
    allocate(all_the_fields(dims(1), dims(2), dims(3), dims(4)), stat=status)
a773 2
    if ( status /= 0 ) &
        & call announce_error(lcf_where, "failed to allocate field_data")
d816 1
a816 1
      print *, 'dao Before reshaping'
d823 2
a824 2
    the_g_data%field(:,:,:,1,1,:) = reshape( all_the_fields, &
      & shape=(/nLev, nlat, nlon, ntime/), order=(/3,2,1,4/) &
d826 2
d835 3
a837 1
    deallocate(all_the_fields)
d857 6
a862 2
      the_g_data%dateStarts = dim_field
      the_g_data%dateEnds = dim_field
d2178 76
d2353 1
a2353 1
       "$Id: ncep_dao.f90,v 2.52 2009/08/17 16:52:19 pwagner Exp $"
d2363 3
@


2.52
log
@From MERRA file may read DELP field and perform sum
@
text
@d29 1
a38 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d1536 2
d1574 1
a1574 1
    integer :: strbufsize
d1586 2
a1587 1
    integer, dimension(NENTRIESMAX) :: dims, rank, numberTypes
d1605 2
a1606 1
    integer :: i, xdimsize=1, ydimsize=2
d1781 2
a1782 2
       status = he5_gdrdfld(gd_id(i), trim(actual_field_name), start, stride, &
         & edge, all_the_fields)
d1870 2
a1871 2
         status = he5_gdrdfld(gd_id, trim(field_name), start, stride, edge, &
           & values)                                                     
d2276 1
a2276 1
       "$Id: ncep_dao.f90,v 2.51 2009/06/23 18:25:43 pwagner Exp $"
d2286 3
@


2.51
log
@Prevent Intel from optimizing ident string away
@
text
@d14 1
d31 2
a32 2
    & List2Array, ReplaceSubString
  use OUTPUT_M, only: OUTPUT
d45 1
a45 1
       "$RCSfile: $"
d49 10
d65 1
d90 1
a90 1
    & GeoDimList, fieldName, missingValue, date )
d94 2
a95 1
    ! structure and the  appropriate for 'ncep' or 'dao'
d98 1
a98 1
    ! GeoDimList, if present, should be the Dimensions' short names
d102 1
a102 1
    ! fieldName, if present, should be the rank 3 or higher object
d110 9
a118 9
    type(MLSFile_T)                :: GriddedFile
    integer, intent(IN) :: lcf_where    ! node of the lcf that provoked me
    integer, intent(IN) :: v_type       ! vertical coordinate; an 'enumerated' type
    type( GriddedData_T ) :: the_g_data ! Result
    character (LEN=*), intent(IN) :: description ! e.g., 'dao'
    integer, intent(out) :: returnStatus ! E.g., FILENOTFOUND
    character (LEN=*), optional, intent(IN) :: GeoDimList ! Comma-delimited dim names
    character (LEN=*), optional, intent(IN) :: fieldName ! Name of gridded field
    real(rgr), optional, intent(IN) :: missingValue
d120 1
d123 1
d125 1
d132 1
d140 1
d147 1
a147 1
        print *, '(Returned from read_dao)'
d155 23
d189 3
a285 1
    logical, parameter :: COUNTEMPTY=.true.
d386 13
a398 1

a437 1
    call nullifyGriddedData ( the_g_data ) ! for Sun's still useless compiler
d554 355
a969 1
    logical, parameter :: COUNTEMPTY=.true.
a1090 1
    call nullifyGriddedData ( the_g_data ) ! for Sun's still useless compiler
a1264 1
    logical, parameter :: COUNTEMPTY = .true.
a1436 1
    call nullifyGriddedData ( the_g_data ) ! for Sun's still useless compiler
a1595 1
    logical, parameter :: COUNTEMPTY=.true.
a1734 1
    call nullifyGriddedData ( the_g_data ) ! for Sun's still useless compiler
a1908 1
    call nullifyGriddedData ( grid ) ! for Sun's still useless compiler
d2272 1
a2272 1
       "$Id: read_apriori.f90 is it here $"
d2282 3
@


2.50
log
@Removed most unused stuff
@
text
@d44 1
a44 1
       "$RCSfile: ncep_dao.f90,v $"
d1867 1
a1868 1
!---------------------------- RCS Ident Info -------------------------------
d1870 2
a1871 3
       "$Id: ncep_dao.f90,v 2.49 2008/12/02 23:11:13 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1873 1
a1873 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1875 1
d1880 3
@


2.49
log
@mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
@
text
@a20 1
  use intrinsic, only: l_ascii
d26 1
a26 1
    & GetPCFromRef, MLS_HDF_VERSION, open_MLSFile, close_MLSFile, &
d835 1
a835 1
    integer :: nentries, ngrids, ndims, nfields
d852 1
a852 1
    integer                        :: nlon=1, nlat=1, nlev=1, ntime=1
a1069 6
      !nullify(dim_field)
      !call read_the_dim(gd_id, 'XDim', dims(1), dim_field)
      !the_g_data%lons = dim_field
      !call read_the_dim(gd_id, 'YDim', dims(2), dim_field)
      !the_g_data%lats = dim_field
      !deallocate(dim_field)        ! Before leaving, some light housekeeping
a1190 1
    integer, external :: GDRDFLD
a1195 1
    real(r8), dimension(:), pointer :: dim_field
a1421 18
    !nullify(dim_field)
    ! call read_the_dim(gd_id, 'XDim', dims(1), dim_field)
    !call read_the_dim(gd_id, trim(dimNames(1)), dims(1), dim_field)
    !the_g_data%lons = dim_field
    ! call read_the_dim(gd_id, 'YDim', dims(2), dim_field)
    !call read_the_dim(gd_id, trim(dimNames(2)), dims(2), dim_field)
    !the_g_data%lats = dim_field
    ! call read_the_dim(gd_id, 'Height', dims(3), dim_field)
    !call read_the_dim(gd_id, trim(dimNames(3)), dims(3), dim_field)
    !the_g_data%Heights = dim_field
    ! call read_the_dim(gd_id, 'Time', dims(4), dim_field)
    !call read_the_dim(gd_id, trim(dimNames(4)), dims(4), dim_field)
    ! the_g_data%lsts = dim_field
    !the_g_data%dateStarts = dim_field
    !the_g_data%dateEnds = dim_field
    !deallocate(dim_field)        ! Before leaving, some light housekeeping
    !end
    ! But .. they aren't there
d1643 1
a1643 1
    integer:: processCli, CliUnit, record_length
a1672 2
        !    CALL MLSMessage (MLSMSG_Error, ModuleName, &
        !              &"Climatology file name unmatched in PCF")
a1683 2
      ! CliUnit = mls_io_gen_openF ( l_ascii, .true., ErrType, &
      !   & record_length, PGSd_IO_Gen_RSeqFrm, FileName=fname)
d1695 1
a1752 1
        ! ErrType = mls_io_gen_CloseF (l_ascii, CliUnit )
d1870 1
a1870 1
       "$Id: ncep_dao.f90,v 2.48 2008/09/17 23:21:19 pwagner Exp $"
d1880 3
@


2.48
log
@Allow date string in gridded data to offset gmao background files
@
text
@d24 1
a24 1
  use MLSCommon, only: LineLen, NameLen, FileNameLen, R8, R4, I4, &
d27 1
a27 1
    & GetPCFromRef, MLS_HDF_VERSION, mls_io_gen_closeF, mls_io_gen_openF, &
d1527 1
a1527 1
    integer(i4) :: TESTINT              ! For finding our Endian
d1674 1
d1713 5
a1717 2
      CliUnit = mls_io_gen_openF ( l_ascii, .true., ErrType, &
        & record_length, PGSd_IO_Gen_RSeqFrm, FileName=fname)
d1783 3
a1785 1
        ErrType = mls_io_gen_CloseF (l_ascii, CliUnit )
d1901 1
a1901 1
       "$Id: ncep_dao.f90,v 2.47 2008/01/07 21:38:12 pwagner Exp $"
d1911 3
@


2.47
log
@Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
@
text
@d29 1
a29 1
  use MLSStrings, only: Capitalize, LowerCase
d77 1
a77 1
  subroutine ReadGriddedData(GriddedFile, lcf_where, description, v_type, &
d79 1
a79 1
    & GeoDimList, fieldName, missingValue)
d92 4
d107 1
d127 2
a128 2
      call Read_geos5(GriddedFile, lcf_where, v_type, &
        & the_g_data, GeoDimList, fieldName)
d179 2
a180 2
  subroutine Read_geos5(GEOS5File, lcf_where, v_type, &
    & the_g_data, GeoDimList, fieldName)
d214 1
d247 1
d250 2
d447 8
a454 2
    the_g_data%dateStarts = dim_field
    the_g_data%dateEnds = dim_field
d1895 1
a1895 1
       "$Id: ncep_dao.f90,v 2.46 2007/06/21 00:49:52 vsnyder Exp $"
d1899 1
d1905 3
@


2.46
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d25 1
a25 1
    & DEFAULTUNDEFINEDVALUE, MLSFile_T
d1799 1
a1799 1
    pressure = DEFAULTUNDEFINEDVALUE !-999.99
d1805 1
a1805 1
    if ( status /= 0 ) pressure = DEFAULTUNDEFINEDVALUE !-999.99
d1880 1
a1880 1
       "$Id: ncep_dao.f90,v 2.45 2006/11/01 20:30:11 pwagner Exp $"
d1889 3
@


2.45
log
@More unused debugging prints
@
text
@d222 1
a222 1
    integer, parameter :: MAXNAMELENGTH=NameLen		! Max length of grid name
d533 1
a533 1
    integer, parameter :: MAXNAMELENGTH=NameLen		! Max length of grid name
d829 1
a829 1
    integer, parameter :: MAXNAMELENGTH=NameLen		! Max length of grid name
d1169 1
a1169 1
    integer, parameter :: MAXNAMELENGTH=NameLen		! Max length of grid name
d1206 1
a1206 1
	     & "Could not inquire gridlist "// trim(NCEPFile%name))
d1228 1
a1228 1
	& "NumStringElements of gridlist /= inq_success")
d1231 1
a1231 1
	& "NumStringElements of gridlist < GRIDORDER")
d1240 2
a1241 2
      	call GetStringElement(gridlist, names(i), i, COUNTEMPTY)
      	if (DEEBUG) print *,'name = ', trim(names(i))
d1243 4
a1246 4
    	if (gd_id(i) < 0) then
      	   !call announce_error(lcf_where,"Could not attach "//trim(mygridname))
      	   call MLSMessage (MLSMSG_Warning, ModuleName, & 
         	& "Could not attach "//trim(names(i)))
d1248 1
a1248 1
	endif
d1253 1
a1253 1
      	   call announce_error(lcf_where, "nentries of gd_id <= 0")
d1296 1
a1296 1
	   & our_rank, dims, numbertype, dimlists(1), maxdimlists(1))
d1338 3
a1340 3
      	   call MLSMessage (MLSMSG_Warning, ModuleName, & 
         	& "Could not attach "//trim(names(i)))
           exit 
d1354 1
a1354 1
		& lowrightpt)
d1369 1
a1369 1
	   & edge, all_the_fields)
d1377 1
a1377 1
      	  print *, 'Before reshaping'
d1393 1
a1393 1
	endif
d1398 1
a1398 1
      	   & call announce_error(lcf_where, "failed to detach from grid " &
d1643 1
a1643 1
    character (LEN=FileNameLen)            :: path	   ! Physical path
d1647 2
a1648 2
    logical, parameter :: ECHO_GRIDDED_QUANTITIES=.false.	! echo_data overrides
    logical, parameter :: DUMP_GRIDDED_QUANTITIES=.false.	! dump_data overrides
d1698 1
a1698 1
	& record_length, PGSd_IO_Gen_RSeqFrm, FileName=fname)
d1761 1
a1761 1
	! use Fortran close
d1880 1
a1880 1
       "$Id: ncep_dao.f90,v 2.44 2006/06/13 22:11:45 pwagner Exp $"
d1889 3
@


2.44
log
@Correctly sets units, heightsUnits
@
text
@d81 1
d130 3
d1880 1
a1880 1
       "$Id: ncep_dao.f90,v 2.43 2006/05/19 19:55:07 pwagner Exp $"
d1889 3
@


2.43
log
@Corrected a misspelling Lahey missed
@
text
@d14 2
a15 1
  use GriddedData, only: GriddedData_T, rgr, v_is_pressure, &
d225 1
d316 7
d355 10
a364 1
    the_g_data%units = 'K'
d367 1
a367 1
    if(DEEBUG) print *, 'our units ', the_g_data%units
d375 1
a375 1
      & missingValue=FILLVALUE, units='K', verticalCoordinate=v_type, &
d1710 12
d1876 1
a1876 1
       "$Id: ncep_dao.f90,v 2.42 2006/05/18 18:39:32 cvuu Exp $"
d1885 3
@


2.42
log
@Add subroutine Read_geos5
@
text
@d198 1
a198 1
    type(MLSFile_T)                :: GEOS5 file
d1846 1
a1846 1
       "$Id: ncep_dao.f90,v 2.41 2006/05/12 21:25:56 pwagner Exp $"
d1855 3
@


2.41
log
@verticalCoordinate now correctly set by read_dao
@
text
@d56 1
d69 1
d119 10
d168 296
d1846 1
a1846 1
       "$Id: ncep_dao.f90,v 2.40 2006/01/25 00:58:44 pwagner Exp $"
d1855 3
@


2.40
log
@Cleared out some commented-out stuff
@
text
@d54 1
a54 1
  character (len=*), parameter :: DEFAULTDAODIMLIST = 'XDim,YDim,Height,TIME'
d102 1
a102 1
    logical, parameter :: DEEBUG = .true.
d122 4
a125 3
        print *, 'Quantity Name ' // trim(the_g_data%QuantityName)
        print *, 'Description   ' // trim(the_g_data%description)
        print *, 'Units         ' // trim(the_g_data%units)
d336 2
d342 3
a344 1
      & noLons=nlon, noLsts=1, noSzas=1, noDates=ntime, missingValue=FILLVALUE )
d349 2
d879 1
a879 1
          & 'list size too big in Read_dao ' // trim(NCEPFile%name), MLSFile=NCEPFile )
d1538 1
a1538 1
       "$Id: ncep_dao.f90,v 2.39 2005/06/22 17:24:59 pwagner Exp $"
d1547 3
@


2.39
log
@Reworded Copyright statement, moved rcs id
@
text
@d44 1
a44 1
       "$RCSfile: $"
a73 1
  ! subroutine ReadGriddedData(FileName, lcf_where, description, v_type, &
a90 1
!    character (LEN=*), intent(IN) :: FileName ! Name of the file containing the grid(s)
a141 3
      !call Read_ncep_strat(FileName, lcf_where, v_type, &
      !  & the_g_data, GeoDimList, fieldName, gridName='SouthernHemisphere', &
      !  & missingValue=missingValue)
a155 1
  ! subroutine Read_dao(FileName, lcf_where, v_type, &
a183 1
!    character (LEN=*), intent(IN) :: FileName ! Name of the file containing the grid(s)
a443 1
  ! subroutine Read_ncep_gdas(FileName, lcf_where, v_type, &
a473 1
!    character (LEN=*), intent(IN) :: FileName ! Name of the file of the grid(s)
a778 1
  ! subroutine Read_ncep_strat(FileName, lcf_where, v_type, &
a810 1
!    character (LEN=*), intent(IN) :: FileName ! Name of the file of the grid(s)
a1146 1
  ! type ( GriddedData_T) function ReadGloriaFile ( filename ) result ( grid )
a1148 1
!    character (len=*), intent(in) :: FILENAME
a1285 1
  ! subroutine READ_CLIMATOLOGY ( input_fname, root, aprioriData, returnStatus, &
a1294 1
    ! character*(*), intent(in) :: input_fname			! Physical file name
a1359 1
      ! CliUnit = mls_io_gen_openF ( 'open', .true., ErrType, &
a1414 1
        ! ErrType = mls_io_gen_CloseF ('close', CliUnit )
d1436 1
a1436 1
    ! Snip INTRO and TAIL off filed_name
d1531 1
a1531 1
       "$Id: $"
d1540 3
@


2.38
log
@Interfaces changed to accept MLSFile_T args
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d42 3
a44 5
  private :: Id,ModuleName
  !------------------------------- RCS Ident Info ------------------------------
  character(LEN=130) :: id = & 
    "$Id: ncep_dao.f90,v 2.37 2004/08/04 23:19:01 pwagner Exp $"
  character(LEN=*), parameter :: ModuleName="$RCSfile: ncep_dao.f90,v $"
d46 1
a46 1
  !-----------------------------------------------------------------------------
d1546 5
d1557 3
@


2.37
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d12 1
d16 1
a16 1
    & DEFAULTUNDEFINEDVALUE
d23 2
a24 2
  use OUTPUT_M, only: BLANKS, OUTPUT
  use SDPToolkit, only: PGS_S_SUCCESS, PGS_PC_GETREFERENCE, &
d37 1
a37 1
    "$Id: ncep_dao.f90,v 2.36 2004/08/03 17:59:35 pwagner Exp $"
a41 1
  public:: source_file_already_read
d68 2
a69 1
  subroutine ReadGriddedData(FileName, lcf_where, description, v_type, &
d85 2
a86 1
    character (LEN=*), intent(IN) :: FileName ! Name of the file containing the grid(s)
d104 1
a104 1
    returnStatus = mls_hdf_version(FileName)
d113 3
a115 6
    case ('clim')
      call announce_error(lcf_where, 'READGriddedData called with climatology' &
        & // ' description; appropriate for ncep/dao only')
    case ('dao')
      call Read_dao(FileName, lcf_where, v_type, &
        & the_g_data, GeoDimList, fieldName, missingValue)
d125 1
a125 1
      call Read_ncep_gdas(FileName, lcf_where, v_type, &
d136 2
a137 2
      call Read_ncep_strat(FileName, lcf_where, v_type, &
        & the_g_data, GeoDimList, fieldName, missingValue=missingValue)
a146 3
    case ('olddao', 'oldncep')
      call Read_old(FileName, lcf_where, my_description(4:), v_type, &
        & the_g_data, GeoDimList, fieldName)
d155 3
a157 2
  subroutine Read_dao(FileName, lcf_where, v_type, &
    & the_g_data, GeoDimList, fieldName, missingValue)
d160 2
a161 2
    ! What was once called 'dao' might be better known as 'gmao'
    ! This routine reads a dao file, named something like
d183 2
a184 1
    character (LEN=*), intent(IN) :: FileName ! Name of the file containing the grid(s)
a189 1
    real(rgr), optional, intent(IN) :: missingValue
d224 1
a224 1
    if(DEEBUG) print *, 'About to find grid list of file ', trim(FileName)
d226 1
a226 1
    inq_success = gdinqgrid(FileName, gridlist, strbufsize)
d228 2
a229 1
      call announce_error(lcf_where, "Could not inquire gridlist "// trim(FileName))
d232 1
a232 1
          & 'list size too big in Read_dao ' // trim(filename) )
d239 1
a239 1
    file_id = gdopen(FileName, DFACC_RDONLY)
d242 1
a242 1
      call announce_error(lcf_where, "Could not open "// FileName)
d412 1
a412 1
      & call announce_error(lcf_where, "failed to close file " //trim(FileName))
d445 2
a446 1
  subroutine Read_ncep_gdas(FileName, lcf_where, v_type, &
d475 2
a476 1
    character (LEN=*), intent(IN) :: FileName ! Name of the file of the grid(s)
a515 1
    real(r4), dimension(:), pointer :: dim_field
d535 1
a535 1
    file_id = gdopen(FileName, DFACC_RDONLY)
d539 1
a539 1
      call announce_error(lcf_where, "Could not open "// FileName)
d749 1
a749 1
      & call announce_error(lcf_where, "failed to close file " //trim(FileName))
d782 3
a784 2
  subroutine Read_ncep_strat(FileName, lcf_where, v_type, &
    & the_g_data, GeoDimList, fieldName, gridName, missingValue)
d814 2
a815 1
    character (LEN=*), intent(IN) :: FileName ! Name of the file of the grid(s)
a820 2
    character (LEN=*), optional, intent(IN) :: gridName   ! Name of grid
    real(rgr), optional, intent(IN) :: missingValue
d838 1
a838 1
    character (len=MAXNAMELENGTH) :: mygridname, actual_field_name
d869 1
a869 1
    if(DEEBUG) print *, 'About to find grid list of file ', trim(FileName)
d871 1
a871 1
    inq_success = he5_gdinqgrid(FileName, gridlist, strbufsize)
d874 1
a874 1
	     & "Could not inquire gridlist "// trim(FileName))
d877 1
a877 1
          & 'list size too big in Read_dao ' // trim(filename) )
d885 1
a885 1
    file_id = he5_gdopen(FileName, HE5F_ACC_RDONLY)
d887 1
a887 1
      call announce_error(lcf_where, "Could not open "// FileName)
d1118 1
a1118 1
      & call announce_error(lcf_where, "failed to close file " //trim(FileName))
a1150 172
  ! ----------------------------------------------- Read_old
  subroutine Read_old(FileName, lcf_where, description, v_type, &
    & the_g_data, GeoDimList, fieldName)

    ! This routine reads a Gridded Data file, returning a filled data
    ! structure appropriate for older style 'ncep' or 'dao'

    ! FileName and the_g_data are required args
    ! GeoDimList, if present, should be the Dimensions' short names
    ! as a comma-delimited character string in the order:
    ! longitude, latitude, vertical level, time

    ! fieldName, if present, should be the rank 3 or higher object
    ! like temperature

    ! Arguments
    character (LEN=*), intent(IN) :: FileName ! Name of the file containing the grid(s)
    integer, intent(IN) :: lcf_where    ! node of the lcf that provoked me
    integer, intent(IN) :: v_type       ! vertical coordinate; an 'enumerated' type
    type( GriddedData_T ) :: the_g_data ! Result
    character (LEN=*), intent(IN) :: description ! e.g., 'dao'
    character (LEN=*), optional, intent(IN) :: GeoDimList ! Comma-delimited dim names
    character (LEN=*), optional, intent(IN) :: fieldName ! Name of gridded field

    ! Local Variables
    integer :: file_id, gd_id
    integer :: inq_success
    integer :: nentries, ngrids, ndims, nfields
    integer :: strbufsize
    logical,  parameter       :: CASESENSITIVE = .false.
    integer, parameter :: GRIDORDER=1   ! What order grid written to file
    integer, parameter :: MAXLISTLENGTH=Linelen ! Max length list of grid names
    integer, parameter :: NENTRIESMAX=20 ! Max num of entries
    character (len=MAXLISTLENGTH) :: gridlist
    character (len=MAXLISTLENGTH) :: dimlist, actual_dim_list
    character (len=MAXLISTLENGTH), dimension(1) :: dimlists
    character (len=MAXLISTLENGTH) :: fieldlist
    integer, parameter :: MAXNAMELENGTH=NameLen		! Max length of grid name
    character (len=MAXNAMELENGTH) :: gridname, actual_field_name
    integer, dimension(NENTRIESMAX) :: dims, rank, numberTypes
    integer                        :: our_rank, numberType

    !                                  These start out initialized to one
    integer                        :: nlon=1, nlat=1, nlev=1, ntime=1
    integer, parameter             :: i_longitude=1
    integer, parameter             :: i_latitude=i_longitude+1
    integer, parameter             :: i_vertical=i_latitude+1
    integer, parameter             :: i_time=i_vertical+1
    integer, external :: GDRDFLD
    logical, parameter :: COUNTEMPTY=.true.
    integer :: status
    logical, parameter :: DEEBUG = .false.
    ! Executable code
    ! Find list of grid names on this file (This has been core dumping on me)
    if(DEEBUG) print *, 'About to find grid list'
    if(DEEBUG) print *, "proceed (yes) or (no)"
    ! read *, gridlist
    ! if ( index(gridlist, 'y') < 1 ) stop
    gridlist = ''
    inq_success = gdinqgrid(FileName, gridlist, strbufsize)
    if (inq_success < 0) then
      call announce_error(lcf_where, "Could not inquire gridlist "// FileName)
    elseif ( strbufsize > MAXLISTLENGTH ) then
       CALL MLSMessage ( MLSMSG_Error, moduleName,  &
          & 'list size too big in Read_dao ' // trim(filename) )
    elseif ( strbufsize < MAXLISTLENGTH .and. strbufsize > 0 ) then
      gridlist = gridlist(1:strbufsize) // ' '
    endif
    if(DEEBUG) print *, 'grid list ', trim(gridlist)

    error = 0
    file_id = gdopen(FileName, DFACC_RDONLY)

    if (file_id < 0) then
      call announce_error(lcf_where, "Could not open "// FileName)
    end if

    ! Find grid name corresponding to the GRIDORDER'th one
    ngrids = NumStringElements(gridlist, COUNTEMPTY)

    if(ngrids <= 0) then
      call announce_error(lcf_where, "NumStringElements of gridlist <= 0")
    elseif(ngrids /= inq_success) then
      call announce_error(lcf_where, "NumStringElements of gridlist /= inq_success")
    elseif(ngrids < GRIDORDER) then
      call announce_error(lcf_where, "NumStringElements of gridlist < GRIDORDER")
    endif

    call GetStringElement(gridlist, gridname, GRIDORDER, COUNTEMPTY)

    gd_id = gdattach(file_id, gridname)
    if (gd_id < 0) then
      call announce_error(lcf_where, "Could not attach "//FileName)
    end if

    ! Now find dimsize(), dimname(), etc.
    nentries = gdnentries(gd_id, HDFE_NENTDIM, strbufsize)

    if(nentries <= 0) then
      call announce_error(lcf_where, "nentries of gd_id <= 0")
    elseif(nentries > NENTRIESMAX) then
      call announce_error(lcf_where, "nentries of gd_id > NENTRIESMAX")
    endif

    dimlist = ''
    ndims = gdinqdims(gd_id, dimlist, dims)

    if(ndims <= 0) then
      call announce_error(lcf_where, "ndims of gd_id <= 0")
    elseif(ndims > NENTRIESMAX) then
      call announce_error(lcf_where, "ndims of gd_id > NENTRIESMAX")
    endif

    fieldlist = ''
    nfields = gdinqflds(gd_id, fieldlist, rank, numberTypes)

    if(nfields <= 0) then
      call announce_error(lcf_where, "nfields of gd_id <= 0")
    elseif(nfields > NENTRIESMAX) then
      call announce_error(lcf_where, "nfields of gd_id > NENTRIESMAX")
    endif

    if(.not. CASESENSITIVE) then
      fieldlist = Capitalize(fieldlist)
    endif

    if(present(fieldName)) then
      actual_field_name=fieldName
    else
      actual_field_name=DEFAULTDAOFIELDNAME
    endif

    if(present(GeoDimList)) then
      actual_dim_list=GeoDimList
    else
      actual_dim_list=GEO_FIELD1 // ',' // &
        & GEO_FIELD2 // ',' // &
        & GEO_FIELD3 // ',' // &
        & GEO_FIELD4
    endif

    ! Now find the rank of our field
    inq_success = gdfldinfo(gd_id, trim(actual_field_name), our_rank, dims, &
      & numbertype, dimlists(1))

    dimlist = trim(dimlists(1))

    nlon = dims(1)
    nlat = dims(2)
    nlev = dims(3)
    ntime = dims(4)

    the_g_data%quantityName = actual_field_name
    the_g_data%description = description
    the_g_data%verticalCoordinate = v_type

    the_g_data%noLons = nlon
    the_g_data%noLats = nlat
    the_g_data%noHeights = nlev
    the_g_data%noLsts = ntime

    ! Close grid
    status = gddetach(gd_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to detach from grid " // &
      & trim(gridname))
    status = gdclose(file_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to close file " // &
      & trim(FileName))
  end subroutine Read_old

d1152 4
a1155 2
  type ( GriddedData_T) function ReadGloriaFile ( filename ) result ( grid )
    character (len=*), intent(in) :: FILENAME
a1176 1
    integer(i4) :: DUMMY                ! For record length words
d1215 1
a1215 1
    open ( unit=lun, file=filename, status='old', form='unformatted', &
d1221 1
a1221 1
      & 'Problem opening Gloria format datafile' )
d1293 2
a1294 1
  subroutine READ_CLIMATOLOGY ( input_fname, root, aprioriData, returnStatus, &
d1302 2
a1303 1
    character*(*), intent(in) :: input_fname			! Physical file name
d1347 1
a1347 1
      & .and. UseSDPToolkit
d1352 1
a1352 1
      call split_path_name(input_fname, path, fname)
d1366 1
a1366 1
      fname = input_fname
d1369 2
a1370 1
      CliUnit = mls_io_gen_openF ( 'open', .true., ErrType, &
d1425 2
a1426 1
        ErrType = mls_io_gen_CloseF ('close', CliUnit )
a1441 62
  ! --------------------------------  source_file_already_read  -----
  function source_file_already_read(GriddedDataBase, source_file, &
    & field_name ) result (already)
    ! check if source file among those already read to form database
    ! returns .TRUE. if already read, .FALSE. if not or if database is empty

    ! optionally checks that field name is also matched for that partcilar
    ! source file

    ! Arguments
    !   
    type (GriddedData_T), dimension(:), pointer :: GriddedDataBase
    character (LEN=*), intent(in) :: source_file
    character (LEN=*), optional, intent(in) :: field_name
    logical :: already

    ! Local
    integer :: i

    ! Begin
    already = .false.

    if(.not. associated(GriddedDataBase)) then
      return
    elseif(len(source_file) == 0) then
      return
    elseif(size(GriddedDataBase) == 0) then
      return
    endif
    
    call output('Database, filenames:', advance='no')
    call blanks(3)
    call output(GriddedDatabase%sourceFilename, advance='yes')
    
    call output('Database, fieldNames:', advance='no')
    call blanks(3)
    call output(GriddedDatabase%quantityName, advance='yes')
    
    call output('Source file:', advance='no')
    call blanks(3)
    call output(source_file, advance='yes')
    
    call output('field_name:', advance='no')
    call blanks(3)
    call output(field_name, advance='yes')
    
    do i=1, size(GriddedDataBase)
      if(trim(adjustl(source_file)) == trim(adjustl(GriddedDataBase(i)%sourceFileName))) then
        already = .true.
        exit
      endif
    enddo

    if(present(field_name) .and. already) then
      if(trim(adjustl(field_name)) == trim(adjustl(GriddedDataBase(i)%quantityName))) then
        already = .true.
      else
        already = .false.
      endif
    endif
  end function source_file_already_read

d1546 3
@


2.36
log
@Gets DEFAULTUNDEFINEDVALUE from MLSCommon
@
text
@d19 3
a21 2
  use MLSStrings, only: GetStringElement, NumStringElements, Capitalize, &
    & List2Array, LowerCase, ReplaceSubString
d36 1
a36 1
    "$Id: ncep_dao.f90,v 2.35 2004/06/23 17:11:50 pwagner Exp $"
d1776 3
@


2.35
log
@read_climatology now returns status, e.g. FILENOTFOUND
@
text
@d14 2
a15 1
  use MLSCommon, only: LineLen, NameLen, FileNameLen, R8, R4, I4
d35 1
a35 1
    "$Id: ncep_dao.f90,v 2.34 2004/01/23 01:12:27 pwagner Exp $"
d1690 1
a1690 1
    pressure = -999.99
d1696 1
a1696 1
    if ( status /= 0 ) pressure = -999.99
d1775 3
@


2.34
log
@Some care taken in handling ...inq.. functions
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d34 1
a34 1
    "$Id: ncep_dao.f90,v 2.33 2003/10/06 13:30:40 cvuu Exp $"
d1463 1
a1463 1
  subroutine READ_CLIMATOLOGY ( input_fname, root, aprioriData, &
d1474 1
d1499 1
d1599 1
d1774 3
@


2.33
log
@Modified to handle reading the ncep data for origin=strat
@
text
@d34 1
a34 1
    "$Id: ncep_dao.f90,v 2.32 2003/06/03 20:42:25 pwagner Exp $"
d226 1
d230 6
a235 1
    end if
d272 1
d281 1
d576 1
d600 1
d869 1
d873 7
a879 2
	& "Could not inquire gridlist "// trim(FileName))
    end if
d925 1
d933 1
d1208 1
d1212 6
a1217 1
    end if
d1254 1
d1263 1
d1771 3
@


2.32
log
@Can read strat (ncep) files; untested
@
text
@d26 1
a26 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d34 1
a34 1
    "$Id: ncep_dao.f90,v 2.31 2003/05/06 00:31:45 vsnyder Exp $"
d58 1
d94 1
a94 1
    logical, parameter :: DEEBUG = .false.
d96 1
d136 4
a139 5
        & the_g_data, GeoDimList, fieldName, gridName='NorthernHemisphere', &
        & missingValue=missingValue)
      call Read_ncep_strat(FileName, lcf_where, v_type, &
        & the_g_data, GeoDimList, fieldName, gridName='SouthernHemisphere', &
        & missingValue=missingValue)
d777 1
a777 1
      & HE5_GDFLDINFO
d812 2
a813 1
    integer :: file_id, gd_id
d824 1
d830 1
d833 1
a833 1
    integer :: status
d835 1
a835 1
    integer                        :: nlon=1, nlat=1, nlev=1, ntime=1
d843 3
a845 1
    real(r4), dimension(:,:,:,:), pointer :: all_the_fields
d848 6
d861 2
a862 1
      call announce_error(lcf_where, "Could not inquire gridlist "// trim(FileName))
d864 1
d866 1
a867 1
    error = 0
a868 1

a874 1

d878 2
a879 1
      call announce_error(lcf_where, "NumStringElements of gridlist /= inq_success")
d881 2
a882 1
      call announce_error(lcf_where, "NumStringElements of gridlist < GRIDORDER")
d885 23
a907 5
    if ( present(gridName) ) then
      myGridName = gridName
    else
      call GetStringElement(gridlist, mygridname, GRIDORDER, COUNTEMPTY)
    endif
d909 6
a914 4
    gd_id = he5_gdattach(file_id, mygridname)
    if (gd_id < 0) then
      call announce_error(lcf_where, "Could not attach "//trim(mygridname))
    end if
d916 6
a921 2
    ! Now find dimsize(), dimname(), etc.
    nentries = he5_gdnentries(gd_id, HE5_HDFE_NENTDIM, strbufsize)
d923 3
a925 5
    if(nentries <= 0) then
      call announce_error(lcf_where, "nentries of gd_id <= 0")
    elseif(nentries > NENTRIESMAX) then
      call announce_error(lcf_where, "nentries of gd_id > NENTRIESMAX")
    endif
d927 5
a931 1
    ndims = he5_gdinqdims(gd_id, dimlist, dims)
d933 7
a939 5
    if(ndims <= 0) then
      call announce_error(lcf_where, "ndims of gd_id <= 0")
    elseif(ndims > NENTRIESMAX) then
      call announce_error(lcf_where, "ndims of gd_id > NENTRIESMAX")
    endif
d941 1
a941 1
    nfields = he5_gdinqflds(gd_id, fieldlist, rank, numberTypes)
d943 16
a958 38
    if(nfields <= 0) then
      call announce_error(lcf_where, "nfields of gd_id <= 0")
    elseif(nfields > NENTRIESMAX) then
      call announce_error(lcf_where, "nfields of gd_id > NENTRIESMAX")
    endif

    if(.not. CASESENSITIVE) then
      fieldlist = Capitalize(fieldlist)
    endif

    if(present(fieldName)) then
      actual_field_name=fieldName
    else
      actual_field_name=DEFAULTNCEPSTRATFIELDNAME
    endif

    actual_dim_list = ' '
    if(present(GeoDimList)) then
      actual_dim_list=GeoDimList
    endif
    if ( actual_dim_list == ' ' ) then
      actual_dim_list = DEFAULTDAODIMLIST
    endif
    call List2Array (actual_dim_list, dimNames, countEmpty)

    ! Now find the rank of our field
    inq_success = he5_gdfldinfo(gd_id, trim(actual_field_name), our_rank, dims, &
      & numbertype, dimlists(1), maxdimlists(1))

    dimlist = trim(dimlists(1))
    if(DEEBUG) print *, 'our_rank ', our_rank
    if(DEEBUG) print *, 'dims ', dims(1:our_rank)
    if(DEEBUG) print *, 'dimlist ', dimlist

    nlon = dims(1)
    nlat = dims(2)
    nlev = dims(3)
    ntime = dims(4)
d961 1
a961 1
    the_g_data%description = lit_dao
d982 73
a1054 29
    allocate(all_the_fields(dims(1), dims(2), dims(3), dims(4)), stat=status)
    all_the_fields = the_g_data%missingValue
    if ( status /= 0 ) &
        & call announce_error(lcf_where, "failed to allocate field_data")
    start = 0                                                             
    stride = 1                                                               
    edge = dims(1:3)                                                        
    if(DEEBUG) print *, 'About to read ' // trim(actual_field_name)
    if(DEEBUG) print *, 'Start ', Start
    if(DEEBUG) print *, 'Stride ', Stride
    if(DEEBUG) print *, 'Edge ', Edge
    status = he5_gdrdfld(gd_id, trim(actual_field_name), start, stride, edge, &  
      & all_the_fields)                                                          
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to read field " &
      & //trim(actual_field_name))
    ! The actual dimlist is this                    XDim,YDim,Height,TIME
    ! Need to reshape it so that the order becomes: Height,YDim,XDim,TIME
    if ( DEEBUG) then
      print *, 'dao Before reshaping'
      call dump(all_the_fields(:,1,1,1), 'x-slice')
      call dump(all_the_fields(1,:,1,1), 'y-slice')
      call dump(all_the_fields(1,1,:,1), 'p-slice')
      call dump(all_the_fields(1,1,1,:), 't-slice')
    endif
    ! the_g_data%field(:,:,:,:,1,1) = reshape( all_the_fields, &
    the_g_data%field(:,:,:,1,1,:) = reshape( all_the_fields, &
      & shape=(/nLev, nlat, nlon, ntime/), order=(/3,2,1,4/) &
      & )
d1056 1
a1056 1
      print *, 'dao After reshaping'
a1059 1
      call dump(the_g_data%field(1,1,1,:,1,1), 't-slice')
d1061 3
a1063 1
    deallocate(all_the_fields)
d1065 1
a1065 1
    nullify(dim_field)
d1067 2
a1068 2
    call read_the_dim(gd_id, trim(dimNames(1)), dims(1), dim_field)
    the_g_data%lons = dim_field
d1070 2
a1071 2
    call read_the_dim(gd_id, trim(dimNames(2)), dims(2), dim_field)
    the_g_data%lats = dim_field
d1073 2
a1074 2
    call read_the_dim(gd_id, trim(dimNames(3)), dims(3), dim_field)
    the_g_data%Heights = dim_field
d1076 1
a1076 1
    call read_the_dim(gd_id, trim(dimNames(4)), dims(4), dim_field)
d1078 12
a1089 3
    the_g_data%dateStarts = dim_field
    the_g_data%dateEnds = dim_field
    deallocate(dim_field)        ! Before leaving, some light housekeeping
d1092 1
d1094 3
a1096 8
    ! the_g_data%DateStarts = the_g_data%missingValue
    ! the_g_data%DateEnds = the_g_data%missingValue
    the_g_data%lsts = the_g_data%missingValue
    ! Close grid
    status = he5_gddetach(gd_id)
    if(status /= 0) &
      & call announce_error(lcf_where, "failed to detach from grid " &
      & //trim(mygridname))
d1100 1
d1745 3
@


2.31
log
@Delete trailing blanks from two too-long-to-be-standard lines
@
text
@d34 1
a34 1
    "$Id: ncep_dao.f90,v 2.30 2003/04/04 18:34:22 pwagner Exp $"
d40 2
a41 2
  public::OBTAIN_CLIM, READ_CLIMATOLOGY, OBTAIN_DAO, Obtain_NCEP
  public::ReadGriddedData, ReadGloriaFile
d50 1
d120 3
a122 1
      call Read_ncep(FileName, lcf_where, v_type, &
d125 16
a140 1
        print *, '(Returned from read_ncep)'
d160 1
d435 2
a436 2
  ! ----------------------------------------------- Read_ncep
  subroutine Read_ncep(FileName, lcf_where, v_type, &
d440 2
a441 1
    ! This routine reads a ncep file, named something like
d443 1
a443 2
    ! returning a filled data
    ! structure appropriate for newer style ncep
d706 1
a706 1
      call announce_error(lcf_where, "read_ncep unable to use projection")
d767 293
a1059 1
  end subroutine Read_ncep
a1364 64
  ! --------------------------------------------- Obtain_Clim ----------
  subroutine OBTAIN_CLIM ( aprioriData, root, &
    & mlspcf_l2clim_start, mlspcf_l2clim_end )

    ! An atavism--
    ! a throwback to when ncep files were opened
    ! independently of being required by the lcf

    !Arguments 
    type (GriddedData_T), dimension(:), pointer :: aprioriData 
    ! Input a priori database
    integer, intent(in) :: root        ! Root of the L2CF abstract syntax tree
    integer, intent(in) :: mlspcf_l2clim_start, mlspcf_l2clim_end

    !Local Variables

    type (GriddedData_T):: qty
    integer:: CliUnit, processCli, returnStatus, version

    logical :: end_of_file = .false.

   error = 0
   
   if( .not. UseSDPToolkit ) then
      call announce_error(root, &
      & 'Detached from toolkit--climatology files must be opened via lcf')
      return
   endif

    do CliUnit = mlspcf_l2clim_start, mlspcf_l2clim_end

      !     Open one Climatology file as a generic file for reading
      version = 1
      returnStatus = Pgs_io_gen_openF ( CliUnit, PGSd_IO_Gen_RSeqFrm, 0, &
        processCli, version )
      if ( returnStatus == PGS_S_SUCCESS ) then

        do while (.not. end_of_file)

          call l3ascii_read_field ( processCli, qty, end_of_file)
          returnStatus = AddGriddedDataToDatabase(aprioriData, qty)

          nullify (qty%lats)
          nullify (qty%lons)
          nullify (qty%lsts)
          nullify (qty%szas)
          nullify (qty%dateStarts)
          nullify (qty%dateEnds)
          nullify (qty%field)
          ! No, this is a bad idea (according to njl)
          !        call DestroyGridTemplateContents ( qty )

        end do !(.not. end_of_file)

        end_of_file = .false.

      end if

    end do ! CliUnit = mlspcf_l2clim_start, mlspcf_l2clim_end

    return

  end subroutine OBTAIN_CLIM

a1507 104
  ! -------------------------------------------------  Obtain_DAO
  subroutine OBTAIN_DAO ( aprioriData, root, &
    & mlspcf_l2dao_start, mlspcf_l2dao_end )

    ! An atavism--
    ! a throwback to when ncep files were opened
    ! independently of being required by the lcf

    type (GriddedData_T), dimension(:), pointer :: aprioriData 
    ! Input a priori database
    integer, intent(in) :: ROOT        ! Root of L2CF abstract syntax tree
    integer, intent(IN) :: mlspcf_l2dao_start, mlspcf_l2dao_end

    ! Local Variables

    !    real(R8) :: data_array(XDIM, YDIM, ZDIM)
    integer :: DAOFileHandle, DAO_Version
    character (LEN=132) :: DAOphysicalFilename
    type (GriddedData_T):: qty
    integer :: returnStatus
    !   integer :: sd_id
    character (LEN=80) :: vname

    !    ALLOCATE (data_array(XDIM, YDIM, ZDIM), stat=returnStatus)

   error = 0
   
   if( .not. UseSDPToolkit ) then
      call announce_error(root, &
      & 'Detached from toolkit--DAO files must be opened via lcf')
      return
   endif

    DAO_Version = 1
    vname = "TMPU" ! for now

    ! Get the DAO file name from the PCF
    do DAOFileHandle = mlspcf_l2dao_start, mlspcf_l2dao_end
      returnStatus = Pgs_pc_getReference ( DAOFileHandle, DAO_Version, &
        DAOphysicalFilename )
      if ( returnStatus == PGS_S_SUCCESS ) then
        ! Open the HDF-EOS file and read gridded data
        returnStatus = AddGriddedDataToDatabase(aprioriData, qty)
        !        call read_dao ( DAOphysicalFilename, vname, data_array )
        if(returnStatus > 0) then
          call ReadGriddedData ( DAOphysicalFilename, root, &
            & 'dao', v_is_pressure, aprioriData(returnStatus), returnStatus )
        endif
      end if
    end do ! DAOFileHandle = mlspcf_l2_dao_start, mlspcf_l2_dao_end
  end subroutine Obtain_DAO

  ! ------------------------------------------------  Obtain_NCEP  -----
  subroutine Obtain_NCEP ( aprioriData, root, &
    & mlspcf_l2ncep_start, mlspcf_l2ncep_end )
    ! An atavism--
    ! a throwback to when ncep files were opened
    ! independently of being required by the lcf
    ! Arguments
    type (GriddedData_T), dimension(:), pointer :: aprioriData 
    ! Input a priori database
    integer, intent(in) :: ROOT        ! Root of the L2CF abstract syntax tree
    integer, intent(IN) :: mlspcf_l2ncep_start, mlspcf_l2ncep_end

    ! Local Variables
    integer :: NCEPFileHandle, NCEP_Version
    character (len=132) :: NCEPphysicalFilename
    type (GriddedData_T):: QTY
    integer :: RETURNSTATUS

   error = 0
   
   if( .not. UseSDPToolkit ) then
      call announce_error(root, &
      & 'Detached from toolkit--ncep files must be opened via lcf')
      return
   endif

    NCEP_Version = 1
    !    vname = "TMP_3" ! for now
    ! Get the NCEP file name from the PCF

    do NCEPFileHandle = mlspcf_l2ncep_start, mlspcf_l2ncep_end

      returnStatus = Pgs_pc_getReference ( NCEPFileHandle, NCEP_Version, &
        NCEPphysicalFilename )

      if ( returnStatus == PGS_S_SUCCESS ) then

        ! Open the HDF-EOS file and read gridded data

        returnStatus = AddGriddedDataToDatabase(aprioriData, qty)

        !        call read_ncep ( NCEPphysicalFilename, data_array )
        if(returnStatus > 0) then
          call ReadGriddedData ( NCEPphysicalFilename, root, &
            & 'ncep', v_is_pressure, aprioriData(returnStatus), returnStatus )
        endif

      end if

    end do ! NCEPFileHandle = mlspcf_l2_ncep_start, mlspcf_l2_ncep_end
  end subroutine Obtain_NCEP

d1674 3
@


2.30
log
@Sets empty field if FILENOTFOUND
@
text
@d34 1
a34 1
    "$Id: ncep_dao.f90,v 2.29 2003/04/02 00:14:25 pwagner Exp $"
d333 1
a333 1
    ! The actual dimlist is this                    XDim,YDim,Height,TIME                                                                                                               
d663 1
a663 1
    ! The dimlist as stacked up is this             Height,XDim,YDim                                                                                                              
d1531 3
@


2.29
log
@The 4th index is now noDates instead of ntime
@
text
@d15 3
a17 2
  use MLSFiles, only: GetPCFromRef, mls_io_gen_closeF, mls_io_gen_openF, &
    &                split_path_name
d34 1
a34 1
    "$Id: ncep_dao.f90,v 2.28 2003/03/01 00:23:27 pwagner Exp $"
d65 2
a66 1
    & the_g_data, GeoDimList, fieldName, missingValue)
d85 1
d97 7
a103 18
! >     descrpt_is_legal = (my_description(:len(lit_dao)) == lit_dao) &
! >       & .or. &
! >       & (my_description(:len(lit_ncep)) == lit_ncep) &
! >       & .or. &
! >       & (my_description(:len(lit_clim)) == lit_clim)
! > 
! >     descrpt_is_misplcd = my_description(:len(lit_clim)) == lit_clim
! > 
! >     if(descrpt_is_misplcd) then
! >       call announce_error(lcf_where, 'READGriddedData called with climatology' &
! >         & // ' description')
! >       return
! >     elseif(.not. descrpt_is_legal) then
! >       call announce_error(lcf_where, 'READGriddedData called with unknown' &
! >         & // ' description: ' // description)
! >       return
! >     endif

d1307 1
a1307 1
            & 'dao', v_is_pressure, aprioriData(returnStatus) )
d1357 1
a1357 1
            & 'ncep', v_is_pressure, aprioriData(returnStatus) )
d1531 3
@


2.28
log
@missingValue an optional arg to reading GriddedData and climatology
@
text
@d33 1
a33 1
    "$Id: ncep_dao.f90,v 2.27 2003/02/28 02:27:12 livesey Exp $"
d310 2
a311 1
    the_g_data%noLsts = ntime
d320 2
a321 1
      & noLons=nlon, noLsts=ntime, noSzas=1, noDates=1, missingValue=FILLVALUE )
d350 2
a351 1
    the_g_data%field(:,:,:,:,1,1) = reshape( all_the_fields, &
d375 3
a377 1
    the_g_data%lsts = dim_field
d382 3
a384 2
    the_g_data%DateStarts = the_g_data%missingValue
    the_g_data%DateEnds = the_g_data%missingValue
d1539 3
@


2.27
log
@Now uses missingValue stuff
@
text
@d33 1
a33 1
    "$Id: ncep_dao.f90,v 2.26 2003/02/27 21:51:02 pwagner Exp $"
d64 1
a64 1
    & the_g_data, GeoDimList, fieldName)
d85 1
d119 1
a119 1
        & the_g_data, GeoDimList, fieldName)
d128 1
a128 1
        & the_g_data, GeoDimList, fieldName)
d147 1
a147 1
    & the_g_data, GeoDimList, fieldName)
d178 1
d420 1
a420 1
    & the_g_data, GeoDimList, gridName)
d454 1
d1122 2
a1123 1
    & mlspcf_l2clim_start, mlspcf_l2clim_end, echo_data, dump_data )
d1133 1
d1235 4
d1533 3
@


2.26
log
@Commented out the last prints
@
text
@d33 1
a33 1
    "$Id: ncep_dao.f90,v 2.25 2003/02/27 18:38:49 pwagner Exp $"
a58 1
  real, parameter    :: UNDEFINED_VALUE = -999.99 ! Same as %template%badvalue
d317 1
a317 1
      & noLons=nlon, noLsts=ntime, noSzas=1, noDates=1 )
d322 1
a322 1
    all_the_fields = UNDEFINED_VALUE
a355 1
    call filter_fill_values(the_g_data%field, FILLVALUE)
d374 3
a376 3
    the_g_data%Szas = UNDEFINED_VALUE
    the_g_data%DateStarts = UNDEFINED_VALUE
    the_g_data%DateEnds = UNDEFINED_VALUE
d407 1
a407 1
         values = UNDEFINED_VALUE
d607 1
a607 1
      field_data = UNDEFINED_VALUE
a678 1
    if ( FILLVALUE /= 0.e0 ) call filter_fill_values(the_g_data%field, FILLVALUE)
d705 4
a708 4
    the_g_data%lsts = UNDEFINED_VALUE
    the_g_data%Szas = UNDEFINED_VALUE
    the_g_data%DateStarts = UNDEFINED_VALUE
    the_g_data%DateEnds = UNDEFINED_VALUE
d740 1
a740 1
         values = UNDEFINED_VALUE
d959 1
a959 1
      grid%heights = 10.0**(3.0-(i-1)/6.0)
d1024 1
a1024 1
      do lat = 1, noLats
d1026 1
a1026 1
          do surf = 1, noHeights
d1035 1
a1035 1
      do lat = 1, noLats
d1037 1
a1037 1
          do surf = 1, noHeights
d1046 5
a1422 34
  subroutine filter_fill_values ( field_values, fill_value )
  ! Replace field_values equal to fill_value with UNDEFINED_VALUE
  ! Note that:
  ! for robustness under f.p. conversions, we actually check that
  ! (a) if fill_value > 0, field_values > fill_value / alpha
  ! (b) if fill_value < 0, field_values < fill_value / alpha
  ! (c) if fill_value = 0, |field_values| < MINVALUE
  ! Args
  real(r4), intent(in)                             :: fill_value
  real(rgr), dimension(:,:,:,:,:,:), intent(inout) :: field_values
  ! Local variables
  integer :: fill_sign
  real(r4), parameter :: MINVALUE = 1.e-14
  real, parameter :: alpha = 1.005
  ! Executable
  if ( abs(fill_value) < MINVALUE ) then
    fill_sign = 0
  else
    fill_sign = int( sign(alpha, fill_value) )
  endif
  select case (fill_sign)
  case (1)
    where ( field_values > fill_value / alpha ) field_values = UNDEFINED_VALUE
  case (-1)
    where ( field_values < fill_value / alpha ) field_values = UNDEFINED_VALUE
  case (0)
    where ( abs(field_values) < MINVALUE ) field_values = UNDEFINED_VALUE
  case default
    call announce_error(0, 'illegal fill_sign in filter_field_values', &
        & 'fill_sign: ', fill_sign)
  end select
  end subroutine filter_fill_values

  ! ------------------------------------------------  ncepFieldNameTohPa  -----
d1524 3
@


2.25
log
@Removed some intent(out); Lahey takes perverse delight in resetting such to undefined
@
text
@d33 1
a33 1
    "$Id: ncep_dao.f90,v 2.24 2003/02/21 21:01:06 pwagner Exp $"
d89 1
a89 1
    logical, parameter :: DEEBUG = .true.
d311 3
a313 3
    print *, 'our quantity name ', the_g_data%quantityName
    print *, 'our description ', the_g_data%description
    print *, 'our units ', the_g_data%units
d319 3
a321 3
    print *, '(Again) our quantity name ', the_g_data%quantityName
    print *, 'our description ', the_g_data%description
    print *, 'our units ', the_g_data%units
d649 3
a651 3
    print *, 'our quantity name ', the_g_data%quantityName
    print *, 'our description ', the_g_data%description
    print *, 'our units ', the_g_data%units
d661 3
a663 3
    print *, '(Again) our quantity name ', the_g_data%quantityName
    print *, 'our description ', the_g_data%description
    print *, 'our units ', the_g_data%units
d1556 3
@


2.24
log
@Actually uses GeoDimList; filters Fill values
@
text
@d33 1
a33 1
    "$Id: ncep_dao.f90,v 2.23 2003/02/20 21:23:40 pwagner Exp $"
d82 1
a82 1
    type( GriddedData_T ), intent(OUT) :: the_g_data ! Result
d89 1
d92 1
d120 6
d129 6
d175 1
a175 1
    type( GriddedData_T ), intent(OUT) :: the_g_data ! Result
d311 3
d319 3
d451 1
a451 1
    type( GriddedData_T ), intent(OUT) :: the_g_data ! Result
d649 3
d661 3
d771 1
a771 1
    type( GriddedData_T ), intent(OUT) :: the_g_data ! Result
d1556 3
@


2.23
log
@More successful; cant read metadata yet
@
text
@d6 1
a6 1
  use GriddedData, only: GriddedData_T, v_is_pressure, &
d18 1
a18 1
    & LowerCase, ReplaceSubString
d33 1
a33 1
    "$Id: ncep_dao.f90,v 2.22 2003/02/19 19:14:16 pwagner Exp $"
d175 1
d192 1
d265 1
a267 5
    else
      actual_dim_list=GEO_FIELD1 // ',' // &
        & GEO_FIELD2 // ',' // &
        & GEO_FIELD3 // ',' // &
        & GEO_FIELD4
d269 4
d337 1
d341 2
a342 1
    call read_the_dim(gd_id, 'XDim', dims(1), dim_field)
d344 2
a345 1
    call read_the_dim(gd_id, 'YDim', dims(2), dim_field)
d347 2
a348 1
    call read_the_dim(gd_id, 'Height', dims(3), dim_field)
d350 2
a351 1
    call read_the_dim(gd_id, 'Time', dims(4), dim_field)
d474 3
d655 1
d674 1
a674 1
        the_g_data%lons(i) = i - 1
d677 1
a677 1
        the_g_data%lats(i) = i - 1
d1395 34
d1530 3
@


2.22
log
@Many changes; not perfect yet
@
text
@d22 1
d33 1
a33 1
    "$Id: ncep_dao.f90,v 2.21 2002/11/22 12:57:59 mjf Exp $"
d45 3
a47 1
  character (len=*), parameter :: DEFAULTFIELDNAME = 'TMPU'
d59 1
d134 1
d193 1
d196 1
a196 4
    print *, 'About to find grid list of file ', trim(FileName)
    print *, "proceed (yes) or (no)"
    ! read *, gridlist
    ! if ( index(gridlist, 'y') < 1 ) stop
d201 1
a201 1
    print *, 'grid list ', trim(gridlist)
d260 1
a260 1
      actual_field_name=DEFAULTFIELDNAME
d277 3
a279 3
    print *, 'our_rank ', our_rank
    print *, 'dims ', dims(1:our_rank)
    print *, 'dimlist ', dimlist
d301 1
d307 4
d318 7
d328 7
d344 1
a344 1
    call read_the_dim(gd_id, 'TIME', dims(4), dim_field)
d347 5
d382 1
d394 1
d414 5
d421 1
a421 1
    character (LEN=*), intent(IN) :: FileName ! Name of the file containing the grid(s)
d423 1
a423 1
    integer, intent(IN) :: v_type       ! vertical coordinate; an 'enumerated' type
d425 1
a425 1
    character (LEN=*), optional, intent(IN) :: GeoDimList ! Comma-delimited dim names
d434 1
a434 1
    integer, parameter :: MAXLISTLENGTH=10*Linelen ! Max length list of grid names
d454 2
a455 1
    logical, parameter :: COUNTEMPTY=.true.
d460 9
d470 1
d473 1
a473 7
      call announce_error(lcf_where, 'Read_ncep' &
        & // ' not yet capable of reading newer file formats')
    ! Find list of grid names on this file (This has been core dumping on me)
    print *, 'About to find grid list of file ', trim(FileName)
    print *, "proceed (yes) or (no)"
    ! read *, gridlist
    ! if ( index(gridlist, 'y') < 1 ) stop
a475 5
    if (inq_success < 0) then
      call announce_error(lcf_where, "Could not inquire gridlist "// FileName)
    end if
    print *, 'grid list ', trim(gridlist)

d478 1
a478 1
    print *, 'fileID: ', file_id
d485 1
a485 1
    print *, 'gridID: ', gd_id
d490 16
d507 13
a519 1
    nentries = gdnentries(gd_id, HDFE_NENTDIM, strbufsize)
d521 8
a528 7
    if(nentries <= 0) then
      call announce_error(lcf_where, "nentries of gd_id <= 0", &
        & 'nentries:', nentries)
    elseif(nentries > NENTRIESMAX) then
      call announce_error(lcf_where, "nentries of gd_id > NENTRIESMAX", &
        & 'nentries:', nentries)
    end if
d530 2
a531 1
    ndims = gdinqdims(gd_id, dimlist, dims)
d533 8
a540 7
    if(ndims <= 0) then
      call announce_error(lcf_where, "ndims of gd_id <= 0", &
        & 'ndims:', ndims)
    elseif(ndims > NENTRIESMAX) then
      call announce_error(lcf_where, "ndims of gd_id > NENTRIESMAX", &
        & 'ndims:', ndims)
    endif
d543 1
a543 1
    print *, 'nfields: ', nfields
d562 1
a562 1
      print *, 'actual_field_name: ', trim(actual_field_name)
d565 1
a565 1
      print *, 'inferred pressure: ', pressure
d579 1
d603 1
d623 3
d630 6
d639 6
d648 28
d684 29
d766 1
d769 2
a770 2
    print *, 'About to find grid list'
    print *, "proceed (yes) or (no)"
d777 1
a777 1
    print *, 'grid list ', trim(gridlist)
d836 1
a836 1
      actual_field_name=DEFAULTFIELDNAME
d1485 3
@


2.21
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d9 1
a9 1
    & gdopen, gdattach, gdfldinfo, &
d18 1
a18 1
    & LowerCase
d32 1
a32 1
    "$Id: ncep_dao.f90,v 2.20 2002/10/08 00:09:13 pwagner Exp $"
d45 1
d54 2
d84 77
a166 2
    integer, parameter :: MAXLISTLENGTH=Linelen ! Max length list of grid names
    integer, parameter :: NENTRIESMAX=20 ! Max num of entries
d176 2
d186 57
a242 2
    logical            :: descrpt_is_legal
    logical            :: descrpt_is_misplcd
d244 5
a248 1
    ! Executable code
d250 3
a252 5
    descrpt_is_legal = (lowercase(description(:len(lit_dao))) == lit_dao) &
      & .or. &
      & (lowercase(description(:len(lit_ncep))) == lit_ncep) &
      & .or. &
      & (lowercase(description(:len(lit_clim))) == lit_clim)
d254 5
a258 1
    descrpt_is_misplcd = lowercase(description(:len(lit_clim))) == lit_clim
d260 7
a266 8
    if(descrpt_is_misplcd) then
      call announce_error(lcf_where, 'READGriddedData called with climatology' &
        & // ' description')
      return
    elseif(.not. descrpt_is_legal) then
      call announce_error(lcf_where, 'READGriddedData called with unknown' &
        & // ' description: ' // description)
      return
d269 173
d444 1
d450 183
a632 1
    ! Find list of grid names on this file
d637 8
d728 10
a737 1
  end subroutine ReadGriddedData
d780 1
d1000 1
a1000 1
          & error_number=ErrType)
d1064 2
a1065 1
          &"Error closing " // fname, error_number=ErrType)
d1069 2
a1070 1
        &"Error opening " // fname, error_number=ErrType)
d1241 28
d1270 2
a1271 2
  subroutine announce_error ( lcf_where, full_message, use_toolkit, &
    & error_number )
d1277 2
a1278 1
    integer, intent(in), optional    :: error_number
d1314 1
a1314 1
      if(present(error_number)) then
d1316 5
a1320 1
        call output(error_number, places=9, advance='yes')
d1326 5
a1330 1
      if ( present(error_number) ) then
d1332 1
a1332 1
        call output ( error_number, advance='yes' )
d1345 4
@


2.20
log
@Added idents to survive zealous Lahey optimizer
@
text
@d7 1
a7 1
    & AddGriddedDataToDatabase, Dump, SetupNewGriddedData
d32 1
a32 1
    "$Id: ncep_dao.f90,v 2.19 2002/02/05 04:13:43 livesey Exp $"
d262 1
d792 3
@


2.19
log
@Minor bug fix
@
text
@d32 1
a32 1
    "$Id: ncep_dao.f90,v 2.18 2002/01/23 22:34:37 livesey Exp $"
d34 1
d784 4
d791 3
@


2.18
log
@Added ReadGloriaFile functionality
@
text
@d32 1
a32 1
    "$Id: ncep_dao.f90,v 2.17 2002/01/09 23:48:40 pwagner Exp $"
d264 1
d786 3
@


2.17
log
@Added toc; each print became call output
@
text
@a3 1
!=============================================================================
a4 2
  !=============================================================================

d7 1
a7 1
    & AddGriddedDataToDatabase, Dump
d14 1
a14 1
  use MLSCommon, only: LineLen, NameLen, FileNameLen
d24 1
d32 1
a32 1
    "$Id: ncep_dao.f90,v 2.16 2001/10/26 23:14:37 pwagner Exp $"
a35 10
!     c o n t e n t s
!     - - - - - - - -

! source_file_already_read   Is source file among those already read?
! obtain_clim                An atavism--should be removed
! read_climatology           Reads a l3ascii file for the data_array
! obtain_dao                 An atavism--should be removed
! obtain_ncep                An atavism--should be removed
! ReadGriddedData            Reads a Gridded Data file appropriate for 'ncep' or 'dao'

d38 1
a38 1
  public::ReadGriddedData
a42 1

a52 7
  ! This datatype stores a single gridded atmospheric quantity.  For example
  ! temperature, if an uncertainty field is also required, this is stored in a
  ! separate quantity.


  ! --------------------------------------------------------------------------

a53 1
  !----------------- Beginning of Paul's code ------------------
d55 1
a55 1
  !---------------------------- ReadGriddedData ---------------------
a57 1
    !------------------------------------------------------------------------
d59 2
a60 2
    ! This routine reads a Gridded Data file, returning a filled data structure and the !
    ! appropriate for 'ncep' or 'dao'
a70 1

d72 1
a72 1
    integer, intent(IN) :: lcf_where			! node of the lcf that provoked me
a79 1

a83 3
    !  character (len=80) :: msg, mnemonic
    !  integer :: status

d96 1
a102 3
    ! External functions
    !  integer, external :: gdopen, gdattach, gdrdfld, gddetach, gdclose
    !  integer, external :: gdinqgrid, gdnentries, gdinqdims, gdinqflds
d108 1
a108 1
    ! - - - begin - - -
a109 1
    ! Check if description is legal
a203 1

a222 1
    !-----------------------------
a223 1
  !-----------------------------
d225 133
a357 2
  ! ------------------------------------------------  OBTAIN_CLIM  -----
  !=====================================================================
a359 1
    !=====================================================================
d418 1
a418 1
    !============================
a419 2
  !============================

d421 1
a421 1
  ! --------------------------------------------------  READ_CLIMATOLOGY  -----
a423 1
    ! --------------------------------------------------
a428 1

a475 1

a477 1

a485 1

a487 1

a490 1

a491 1

a493 1

a505 1

a506 1

a507 1

a508 1

a533 1

a534 1

a535 1

a536 1

a539 1

a541 1

a543 1

a544 1

a548 1

a549 1

d556 1
a556 1
  ! -------------------------------------------------  OBTAIN_DAO  -----
a591 1

a592 1

a593 1

a595 1

a596 1

a598 1

a603 1

a604 1

a605 2

    !===========================
a606 1
  !===========================
a610 1

a613 1

a620 1
    !    character (len=80) :: MSG, MNEMONIC
a624 3
    !    character (len=80) :: VNAME

    !   allocate ( data_array(XDIM, YDIM, ZDIM), stat=returnStatus )
a657 1
    !===========================
a658 1
  !===========================
d661 2
a662 2
  function source_file_already_read(GriddedDataBase, source_file, field_name &
    & ) result (already)
d689 17
a705 21

!    print*,'Database, filenames:',GriddedDatabase%sourceFilename
!    print*,'Database, fieldNames:',GriddedDatabase%quantityName
!    print*,'Source file:',source_file
!    print*,'field_name:',field_name
     call output('Database, filenames:', advance='no')
     call blanks(3)
     call output(GriddedDatabase%sourceFilename, advance='yes')

     call output('Database, fieldNames:', advance='no')
     call blanks(3)
     call output(GriddedDatabase%quantityName, advance='yes')

     call output('Source file:', advance='no')
     call blanks(3)
     call output(source_file, advance='yes')

     call output('field_name:', advance='no')
     call blanks(3)
     call output(field_name, advance='yes')

a706 1

a710 1

a713 1

a718 1

a719 1

a726 1

d731 2
a732 3
    ! Local
    !  character (len=80) :: msg, mnemonic
    !  integer :: status
a744 3
      !    CALL Pgs_smf_getMsg(status, mnemonic, msg)
      !    CALL MLSMessage (level, ModuleName, &
      !              &trim(full_message)//" "//mnemonic//" "//msg)
a779 1
    !===========================
a780 1
  !===========================
a781 1
  !=============================================================================
a782 1
!=============================================================================
d784 3
a787 1
! $Log: ncep_dao.f90,v $
@


2.16
log
@Complies with Gridded data dump
@
text
@d1 1
a1 3


! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d9 6
a14 7
  use Allocate_Deallocate, only: Allocate_test, Deallocate_test
  use GriddedData, only: GriddedData_T, v_is_pressure, v_is_altitude, &
    & v_is_gph, v_is_theta, AddGriddedDataToDatabase, Dump
  use HDFEOS, only: HDFE_NENTDIM, HDFE_NENTDFLD, &
    & gdopen, gdattach, gddetach, gdclose, gdfldinfo, &
    & gdinqgrid, gdnentries, gdinqdims, gdinqflds, gddiminfo
  use Hdf, only: SUCCEED, DFACC_RDONLY
d17 1
a17 1
  use MLSCommon, only: R8, LineLen, NameLen, FileNameLen
a19 2
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Allocate, &
    & MLSMSG_Deallocate, MLSMSG_Warning
d21 2
a22 2
    & GetIntHashElement, LowerCase
  use OUTPUT_M, only: OUTPUT
a25 2
  use Toggles, only: Gen, Levels, Switches, Toggle
  use Trace_M, only: Trace_begin, Trace_end
d34 1
a34 1
    "$Id: ncep_dao.f90,v 2.15 2001/09/10 23:37:10 livesey Exp $"
d38 2
d41 6
a103 1
    integer :: edges(4)
a105 1
    integer :: i
d120 3
a122 3
    character (len=MAXNAMELENGTH) :: gridname, actual_field_name, the_dim
    integer, dimension(NENTRIESMAX) :: dims, rank, numberTypes, start, stride
    integer                        :: our_rank, size, numberType
a276 1
    character (LEN=256) :: msg, mnemonic
a501 1
    character (len=256) :: mnemonic, msg
d637 19
a655 4
    print*,'Database, filenames:',GriddedDatabase%sourceFilename
    print*,'Database, fieldNames:',GriddedDatabase%quantityName
    print*,'Source file:',source_file
    print*,'field_name:',field_name
d732 8
a739 6
      print*, '***Error in module ', ModuleName
      print*, trim(full_message)
      if(present(error_number)) then
        print*, 'error number ', error_number
      endif
    endif
d751 3
@


2.15
log
@Tidied up a bit, moved much stuff to GriddedData.f90
@
text
@d13 1
a13 1
    & v_is_gph, v_is_theta, AddGriddedDataToDatabase, DumpGriddedData
d41 1
a41 1
    "$Id: ncep_dao.f90,v 2.14 2001/07/12 22:03:55 livesey Exp $"
d359 1
a359 1
    logical :: dump
d372 1
a372 1
      dump = dump_data
d374 1
a374 1
      dump = DUMP_GRIDDED_QUANTITIES
d440 2
a441 2
          if(dump) then
            call DumpGriddedData(gddata, root)
d737 3
@


2.14
log
@Some minor ish changes.  Needs an overhaul at some point.
@
text
@d13 1
a13 1
    & v_is_gph, v_is_theta
d36 1
a36 1
  public
d41 1
a41 1
    "$Id: ncep_dao.f90,v 2.13 2001/06/04 23:57:40 pwagner Exp $"
d47 1
a47 3
  public::SetupNewGridTemplate, DestroyGridTemplateContents, &
    &   AddGridTemplateToDatabase, DestroyGridTemplateDatabase, &
    & Dump_Gridded_Database, source_file_already_read
d50 2
a51 4
  private::announce_error
  private::DEFAULTFIELDNAME, GEO_FIELD1, GEO_FIELD2, GEO_FIELD3, GEO_FIELD4
  private::lit_dao, lit_ncep, lit_clim
  integer, private :: ERROR
a72 150

  ! Now we have some subroutines to deal with these quantitites

  ! This first routine sets up a new quantity template according to the user
  ! input.  This may be based on a previously supplied template (with possible
  ! modifications), or created from scratch.

  subroutine SetupNewGridTemplate(qty, source, noHeights, noLats, noLons, noLsts, noSzas, noDates)

    ! Dummy arguments
    type (GriddedData_T), intent(OUT) :: qty ! Result

    type (GriddedData_T), optional, intent(IN) :: source ! Template

    integer, optional, intent(IN) :: noHeights, noLats, noLons, noLsts, noSzas, noDates

    ! Local variables
    integer :: status           ! Status from allocates etc.

    ! Executable code

    ! First, if we have a template setup according to that
    if (present(source)) then
      qty%noHeights=source%noHeights
      qty%noLats=source%noLats
      qty%noLons=source%noLons
      qty%noLsts=source%noLsts
      qty%noSzas=source%noSzas
      qty%noDates=source%noDates


    else ! We have no template, setup a very bare quantity
      qty%noHeights=1
      qty%noLats=1
      qty%noLons=1
      qty%noLsts=1
      qty%noSzas=1
      qty%noDates=1

    endif

    ! Now, see if the user asked for modifications to this
    if (present(noHeights)) qty%noHeights=noHeights
    if (present(noLats)) qty%noLats=noLats
    if (present(noLons)) qty%noLons=noLons
    if (present(noLsts)) qty%noLsts=noLsts
    if (present(noSzas)) qty%noSzas=noSzas
    if (present(noDates)) qty%noDates=noDates

    ! First the vertical/horizontal coordinates
    call Allocate_test ( qty%heights, qty%noHeights, "qty%heights", ModuleName )
    call Allocate_test ( qty%lats, qty%noLats, "qty%lats", ModuleName )
    call Allocate_test ( qty%lons, qty%noLons, "qty%lons", ModuleName )
    call Allocate_test ( qty%lsts, qty%noLsts, "qty%lsts", ModuleName )
    call Allocate_test ( qty%szas, qty%noSzas, "qty%szas", ModuleName )

    ! Now the temporal coordinates
    call Allocate_test ( qty%dateStarts, qty%noDates, "qty%dateStarts", ModuleName )
    call Allocate_test ( qty%dateEnds, qty%noDates, "qty%dateEnds", ModuleName )

    ! Now the data itself
    allocate(qty%field(qty%noHeights, qty%noLats, qty%noLons,  &
      qty%noLsts, qty%noSzas, qty%noDates), STAT=status)

    if (status /= 0) call announce_error(0,  &
      & MLSMSG_Allocate//"field")

  end subroutine SetupNewGridTemplate

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a quantity template

  subroutine DestroyGridTemplateContents(qty)

    ! Dummy argument
    type (GriddedData_T), intent(INOUT) :: qty

    ! Local variables
    integer :: STATUS

    ! Executable code
    call Deallocate_test ( qty%heights, "qty%heights", ModuleName )
    call Deallocate_test ( qty%lats, "qty%lats", ModuleName )
    call Deallocate_test ( qty%lons, "qty%lons", ModuleName )
    call Deallocate_test ( qty%lsts, "qty%lsts", ModuleName )
    call Deallocate_test ( qty%szas, "qty%szas", ModuleName )

    ! Now the temporal coordinates
    call Deallocate_test ( qty%dateStarts, "qty%dateStarts", ModuleName )
    call Deallocate_test ( qty%dateEnds, "qty%dateEnds", ModuleName )

    ! Now the data itself
    deallocate(qty%field, STAT=status)

    if (status /= 0) call announce_error(0,  &
      & MLSMSG_Allocate//"field")

  end subroutine DestroyGridTemplateContents

  ! --------------------------------------------------------------------------

  ! This subroutine adds a quantity template to a database, or creates the
  ! database if it doesn't yet exist

  !  SUBROUTINE AddGridTemplateToDatabase(database,qty)
  integer function AddGridTemplateToDatabase(database,item)

    ! Dummy arguments
    type (GriddedData_T), dimension(:), pointer :: database
    type (GriddedData_T), intent(IN) :: item

    ! Local variables
    type (GriddedData_T), dimension(:), pointer :: tempDatabase

    ! Executable code

    include "addItemToDatabase.f9h"
    AddGridTemplateToDatabase = newSize

  end function AddGridTemplateToDatabase

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a quantity template database

  subroutine DestroyGridTemplateDatabase(database)

    ! Dummy argument
    type (GriddedData_T), dimension(:), pointer :: database

    ! Local variables
    integer :: qtyIndex, status

    if ( toggle(gen) ) call trace_begin ( "DestroyGridTemplateDatabase" )

    if (associated(database)) then
      do qtyIndex=1,size(database)
        call DestroyGridTemplateContents(database(qtyIndex))
      enddo
      deallocate(database, stat=status)
      if (status /= 0) call announce_error(0,  &
        & MLSMSG_DeAllocate//"database")
    endif
    if ( toggle(gen) ) then
      call trace_end ( "DestroyGridTemplateDatabase" )
    end if
  end subroutine DestroyGridTemplateDatabase


d302 1
a302 1
          returnStatus = AddGridTemplateToDatabase(aprioriData, qty)
d441 1
a441 1
            call Dump_Gridded_Data(gddata, root)
d444 1
a444 1
          ErrType = AddGridTemplateToDatabase(aprioriData, gddata)
d534 1
a534 1
        returnStatus = AddGridTemplateToDatabase(aprioriData, qty)
d595 1
a595 1
        returnStatus = AddGridTemplateToDatabase(aprioriData, qty)
a609 97
  ! --------------------------------  Dump_Gridded_Database  -----
  subroutine Dump_Gridded_Database(GriddedData, root)
    use Dump_0, only: Dump

    ! Imitating what dump_pointing_grid_database does, but for gridded data
    ! which may come from climatology, ncep, dao

    type (GriddedData_T), dimension(:), pointer :: GriddedData 

    integer, intent(in) :: ROOT        ! Root of the L2CF abstract syntax tree

    ! Local Variables
    logical, parameter :: MAYDUMPFIELDVALUES = .false.
    integer            :: i

    if ( .not. associated(GriddedData)) then
      call announce_error(ROOT, 'Gridded database still null')
      return
    endif

    call output ( 'database: a priori grids: SIZE = ' )
    call output ( size(GriddedData), advance='yes' )
    do i = 1, size(GriddedData)

      call output ( 'item number ' )
      call output ( i, advance='yes' )

      call Dump_Gridded_Data(GriddedData(i), root)
    end do ! i
  end subroutine Dump_Gridded_Database

  ! --------------------------------  Dump_Gridded_Data  -----
  subroutine Dump_Gridded_Data(GriddedData, root)
    use Dump_0, only: Dump

    ! Imitating what dump_pointing_grid_database does, but for gridded data
    ! which may come from climatology, ncep, dao

    type (GriddedData_T) :: GriddedData 

    integer, intent(in) :: ROOT        ! Root of the L2CF abstract syntax tree

    ! Local Variables
    logical, parameter :: MAYDUMPFIELDVALUES = .false.

    call output('quantity name ' // GriddedData%quantityName, advance='yes')
    call output('description ' // GriddedData%description, advance='yes')
    call output('units ' // GriddedData%units, advance='yes')

    call output ( ' ************ Geometry ********** ' ,advance='yes')

    call output ( ' Vertical coordinate = ' )
    call output ( GriddedData%verticalCoordinate, advance='yes' )
    call output ( ' No. of heights = ' )
    call output ( GriddedData%noHeights, advance='yes' )
    call dump ( GriddedData%heights, &
      & '    Heights =' )

    call output ( ' Equivalent latitude = ' )
    call output ( GriddedData%equivalentLatitude, advance='yes' )
    call output ( ' No. of latitudes = ' )
    call output ( GriddedData%noLats, advance='yes' )
    call dump ( GriddedData%lats, &
      & '    latitudes =' )

    call output ( ' No. of longitudes = ' )
    call output ( GriddedData%noLons, advance='yes' )
    call dump ( GriddedData%lons, &
      & '    longitudes =' )

    call output ( ' No. of local times = ' )
    call output ( GriddedData%noLsts, advance='yes' )
    call dump ( GriddedData%lsts, &
      & '    local times =' )

    call output ( ' No. of solar zenith angles = ' )
    call output ( GriddedData%noSzas, advance='yes' )
    call dump ( GriddedData%szas, &
      & '    solar zenith angles =' )

    call output ( ' No. of dates = ' )
    call output ( GriddedData%noDates, advance='yes' )
    call dump ( GriddedData%dateStarts, &
      & '    starting dates =' )
    call dump ( GriddedData%dateEnds, &
      & '    ending dates =' )

    if(MAYDUMPFIELDVALUES) then
      call output ( ' ************ tabulated field values ********** ' ,advance='yes')

      ! No dump for 6-dimensional double arrays yet, anyway
      !     call dump ( GriddedData%field, &
      !      & '    gridded field values =' )
    endif

  end subroutine Dump_Gridded_Data

d737 3
@


2.13
log
@Splits path from l2cf-defined file name before getPCfromRef
@
text
@d11 1
d41 1
a41 1
    "$Id: ncep_dao.f90,v 2.12 2001/05/09 23:30:13 pwagner Exp $"
a124 1
    ! First the vertical coordinates
d126 10
a135 25
    allocate (qty%heights(qty%noHeights),STAT=status)
    if (status /= 0) call announce_error(0,  &
      & MLSMSG_Allocate//"heights")

    ! Now the geolocation coordinates
    allocate (qty%lats(qty%noLats),STAT=status)
    if (status /= 0) call announce_error(0,  &
      & MLSMSG_Allocate//"lats")

    allocate (qty%lons(qty%noLons),STAT=status)
    if (status /= 0) call announce_error(0,  &
      & MLSMSG_Allocate//"lons")

    allocate (qty%lsts(qty%noLsts),STAT=status)
    if (status /= 0) call announce_error(0,  &
      & MLSMSG_Allocate//"lsts")

    allocate (qty%szas(qty%noSzas),STAT=status)
    if (status /= 0) call announce_error(0,  &
      & MLSMSG_Allocate//"szas")

    !Now the temporal coordinates
    allocate (qty%DateStarts(qty%noDates),STAT=status)
    if (status /= 0) call announce_error(0,  &
      & MLSMSG_Allocate//"DateStarts")
d137 1
a137 5
    allocate (qty%DateEnds(qty%noDates),STAT=status)
    if (status /= 0) call announce_error(0,  &
      & MLSMSG_Allocate//"DateEnds")

    !Now the data itself
a143 1

d154 1
d156 1
a156 1
    integer status
d159 9
d169 2
a170 1
    deallocate (qty%heights, STAT=status)
d173 1
a173 37
      & MLSMSG_DeAllocate//"heights")

    deallocate (qty%lats, STAT=status)

    if (status /= 0) call announce_error(0,  &
      & MLSMSG_DeAllocate//"lats")

    deallocate (qty%lons, STAT=status)

    if (status /= 0) call announce_error(0,  &
      & MLSMSG_DeAllocate//"lons")

    deallocate (qty%lsts, STAT=status)

    if (status /= 0) call announce_error(0,  &
      & MLSMSG_DeAllocate//"lsts")

    deallocate (qty%szas, STAT=status)

    if (status /= 0) call announce_error(0,  &
      & MLSMSG_DeAllocate//"szas")

    deallocate (qty%DateStarts, STAT=status)

    if (status /= 0) call announce_error(0,  &
      & MLSMSG_DeAllocate//"DateStarts")

    deallocate (qty%DateEnds, STAT=status)

    if (status /= 0) call announce_error(0,  &
      & MLSMSG_DeAllocate//"DateEnds")

    deallocate (qty%field, STAT=status)

    if (status /= 0) call announce_error(0,  &
      & MLSMSG_DeAllocate//"field")    

a187 1
    !    TYPE (GriddedData_T), INTENT(IN) :: qty
a190 1
    !    INTEGER :: newSize,status
a193 22
    !    IF (ASSOCIATED(database)) THEN
    ! Check we don't already have one of this name
    !       IF (LinearSearchStringArray(database%quantityName, qty%quantityName, &
    !            & caseInsensitive=.TRUE.)/=0) CALL MLSMessage(MLSMSG_Error,&
    !            & ModuleName,MLSMSG_Duplicate//qty%quantityName)
    !       newSize=SIZE(database)+1
    !    ELSE
    !       newSize=1
    !    ENDIF
    !    ALLOCATE(tempDatabase(newSize),STAT=status)
    !    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
    !         & "Allocation failed for tempDatabase")

    !    IF (newSize>1) tempDatabase(1:newSize-1)=database
    !    tempDatabase(newSize)=qty
    !    IF (ASSOCIATED(database)) THEN
    !       DEALLOCATE(database, STAT=status)
    !       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
    !         & MLSMSG_DeAllocate//"database")
    !    end if
    !    database=>tempDatabase

d531 3
a533 3
  use_PCF = present(mlspcf_l2clim_start) &
  & .and. present(mlspcf_l2clim_end) &
  & .and. UseSDPToolkit
d600 1
a608 1

d988 3
@


2.12
log
@Detachable from toolkit
@
text
@d19 3
a21 2
  use MLSCommon, only: R8, LineLen, NameLen
  use MLSFiles, only: GetPCFromRef, mls_io_gen_closeF, mls_io_gen_openF
d40 1
a40 1
    "$Id: ncep_dao.f90,v 2.11 2001/04/12 22:04:47 vsnyder Exp $"
d552 1
a552 1
  subroutine READ_CLIMATOLOGY ( fname, root, aprioriData, &
d561 1
a561 1
    character*(*), intent(in) :: fname			! Physical file name
d570 2
d607 1
d610 1
a610 1
        & .true., ErrType, version)
d616 2
a617 1
          &"Climatology file name " // trim(fname) // " unmatched in PCF")
d625 1
d1057 3
@


2.11
log
@Improve an error message
@
text
@d27 4
a30 1
    & PGS_IO_GEN_CLOSEF, PGS_IO_GEN_OPENF, PGSD_IO_GEN_RSEQFRM
d39 1
a39 1
    "$Id: ncep_dao.f90,v 2.10 2001/04/10 20:05:30 livesey Exp $"
d279 2
d289 3
d505 8
d581 1
d597 4
d603 1
a603 1
    if (present(mlspcf_l2clim_start) .and. present(mlspcf_l2clim_end)) then
a674 2
        ! No, this a bad idea according to njl--see nullify statements above
        !        call DestroyGridTemplateContents ( gddata )
d679 1
a679 1
      if(present(mlspcf_l2clim_start) .and. present(mlspcf_l2clim_end)) then
d729 8
d791 8
d1051 3
@


2.10
log
@Tidied up
@
text
@d36 1
a36 1
    "$Id: ncep_dao.f90,v 2.9 2001/03/30 00:26:19 pwagner Exp $"
d990 1
a990 1
      call output("Caused the following error:", advance='yes', &
d1016 3
@


2.9
log
@Added source_file_already_read
@
text
@d7 2
a8 2
MODULE ncep_dao ! Collections of subroutines to handle TYPE GriddedData_T
!=============================================================================
d12 1
a12 1
  & v_is_gph, v_is_theta
d14 2
a15 2
  & gdopen, gdattach, gddetach, gdclose, gdfldinfo, &
  & gdinqgrid, gdnentries, gdinqdims, gdinqflds, gddiminfo
d19 6
a24 6
  USE MLSCommon, only: R8, LineLen, NameLen
  USE MLSFiles, only: GetPCFromRef, mls_io_gen_closeF, mls_io_gen_openF
  USE MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Allocate, &
  & MLSMSG_Deallocate, MLSMSG_Warning
  USE MLSStrings, only: GetStringElement, NumStringElements, Capitalize, &
  & GetIntHashElement, LowerCase
d26 2
a27 2
  USE SDPToolkit, only: PGS_S_SUCCESS, PGS_PC_GETREFERENCE, &
  & PGS_IO_GEN_CLOSEF, PGS_IO_GEN_OPENF, PGSD_IO_GEN_RSEQFRM
d30 2
a31 2
  IMPLICIT NONE
  PUBLIC
d33 1
a33 1
  PRIVATE :: Id,ModuleName
d35 3
a37 3
  CHARACTER(LEN=130) :: id = & 
       "$Id: ncep_dao.f90,v 2.8 2001/03/29 00:51:03 pwagner Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: ncep_dao.f90,v $"
d40 1
a40 1
 
d43 2
a44 2
	&   AddGridTemplateToDatabase, DestroyGridTemplateDatabase, &
	& Dump_Gridded_Database, source_file_already_read
d54 13
a66 13
   CHARACTER (len=*), PARAMETER :: DEFAULTFIELDNAME = 'TMPU'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD1 = 'Latitude'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD2 = 'Longitude'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD3 = 'Height'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD4 = 'Time'

   CHARACTER (len=*), PARAMETER :: lit_dao = 'dao'
   CHARACTER (len=*), PARAMETER :: lit_ncep = 'ncep'
   CHARACTER (len=*), PARAMETER :: lit_clim = 'clim'

! This datatype stores a single gridded atmospheric quantity.  For example
! temperature, if an uncertainty field is also required, this is stored in a
! separate quantity.
d71 1
a71 1
  CONTAINS
d79 1
a79 1
  SUBROUTINE SetupNewGridTemplate(qty, source, noHeights, noLats, noLons, noLsts, noSzas, noDates)
d82 1
a82 1
    TYPE (GriddedData_T), INTENT(OUT) :: qty ! Result
d84 1
a84 1
    TYPE (GriddedData_T), OPTIONAL, INTENT(IN) :: source ! Template
d86 1
a86 1
    INTEGER, OPTIONAL, INTENT(IN) :: noHeights, noLats, noLons, noLsts, noSzas, noDates
d89 1
a89 1
    INTEGER :: status           ! Status from allocates etc.
d94 16
a109 16
    IF (PRESENT(source)) THEN
       qty%noHeights=source%noHeights
       qty%noLats=source%noLats
       qty%noLons=source%noLons
       qty%noLsts=source%noLsts
       qty%noSzas=source%noSzas
       qty%noDates=source%noDates

      
    ELSE ! We have no template, setup a very bare quantity
       qty%noHeights=1
       qty%noLats=1
       qty%noLons=1
       qty%noLsts=1
       qty%noSzas=1
       qty%noDates=1
d111 1
a111 1
    ENDIF
d114 6
a119 6
    IF (PRESENT(noHeights)) qty%noHeights=noHeights
    IF (PRESENT(noLats)) qty%noLats=noLats
    IF (PRESENT(noLons)) qty%noLons=noLons
    IF (PRESENT(noLsts)) qty%noLsts=noLsts
    IF (PRESENT(noSzas)) qty%noSzas=noSzas
    IF (PRESENT(noDates)) qty%noDates=noDates
d122 3
a124 3
    ALLOCATE (qty%heights(qty%noHeights),STAT=status)
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_Allocate//"heights")
d127 15
a141 15
    ALLOCATE (qty%lats(qty%noLats),STAT=status)
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_Allocate//"lats")

    ALLOCATE (qty%lons(qty%noLons),STAT=status)
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_Allocate//"lons")

    ALLOCATE (qty%lsts(qty%noLsts),STAT=status)
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_Allocate//"lsts")

    ALLOCATE (qty%szas(qty%noSzas),STAT=status)
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_Allocate//"szas")
d144 7
a150 7
    ALLOCATE (qty%DateStarts(qty%noDates),STAT=status)
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_Allocate//"DateStarts")

    ALLOCATE (qty%DateEnds(qty%noDates),STAT=status)
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_Allocate//"DateEnds")
d153 2
a154 2
    ALLOCATE(qty%field(qty%noHeights, qty%noLats, qty%noLons,  &
             qty%noLsts, qty%noSzas, qty%noDates), STAT=status)
d156 2
a157 2
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_Allocate//"field")
d160 1
a160 1
  END SUBROUTINE SetupNewGridTemplate
d166 1
a166 1
  SUBROUTINE DestroyGridTemplateContents(qty)
d169 1
a169 1
    TYPE (GriddedData_T), INTENT(INOUT) :: qty
d171 1
a171 1
    INTEGER status
d175 1
a175 1
    DEALLOCATE (qty%heights, STAT=status)
d177 2
a178 2
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_DeAllocate//"heights")
d180 1
a180 1
    DEALLOCATE (qty%lats, STAT=status)
d182 2
a183 2
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_DeAllocate//"lats")
d185 1
a185 1
    DEALLOCATE (qty%lons, STAT=status)
d187 2
a188 2
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_DeAllocate//"lons")
d190 1
a190 1
    DEALLOCATE (qty%lsts, STAT=status)
d192 2
a193 2
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_DeAllocate//"lsts")
d195 1
a195 1
    DEALLOCATE (qty%szas, STAT=status)
d197 2
a198 2
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_DeAllocate//"szas")
d200 1
a200 1
    DEALLOCATE (qty%DateStarts, STAT=status)
d202 2
a203 2
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_DeAllocate//"DateStarts")
d205 1
a205 1
    DEALLOCATE (qty%DateEnds, STAT=status)
d207 2
a208 2
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_DeAllocate//"DateEnds")
d210 1
a210 1
    DEALLOCATE (qty%field, STAT=status)
d212 2
a213 2
    IF (status /= 0) call announce_error(0,  &
         & MLSMSG_DeAllocate//"field")    
d216 1
a216 1
  END SUBROUTINE DestroyGridTemplateContents
d223 2
a224 2
!  SUBROUTINE AddGridTemplateToDatabase(database,qty)
  INTEGER FUNCTION AddGridTemplateToDatabase(database,item)
d227 3
a229 3
    TYPE (GriddedData_T), DIMENSION(:), POINTER :: database
    TYPE (GriddedData_T), INTENT(IN) :: item
!    TYPE (GriddedData_T), INTENT(IN) :: qty
d232 2
a233 2
    TYPE (GriddedData_T), DIMENSION(:), POINTER :: tempDatabase
!    INTEGER :: newSize,status
d237 21
a257 21
!    IF (ASSOCIATED(database)) THEN
       ! Check we don't already have one of this name
!       IF (LinearSearchStringArray(database%quantityName, qty%quantityName, &
!            & caseInsensitive=.TRUE.)/=0) CALL MLSMessage(MLSMSG_Error,&
!            & ModuleName,MLSMSG_Duplicate//qty%quantityName)
!       newSize=SIZE(database)+1
!    ELSE
!       newSize=1
!    ENDIF
!    ALLOCATE(tempDatabase(newSize),STAT=status)
!    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
!         & "Allocation failed for tempDatabase")

!    IF (newSize>1) tempDatabase(1:newSize-1)=database
!    tempDatabase(newSize)=qty
!    IF (ASSOCIATED(database)) THEN
!       DEALLOCATE(database, STAT=status)
!       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
!         & MLSMSG_DeAllocate//"database")
!    end if
!    database=>tempDatabase
d262 1
a262 1
  END FUNCTION AddGridTemplateToDatabase
d268 1
a268 1
  SUBROUTINE DestroyGridTemplateDatabase(database)
d271 1
a271 1
    TYPE (GriddedData_T), DIMENSION(:), POINTER :: database
d274 1
a274 1
    INTEGER :: qtyIndex, status
d276 16
a291 16
    IF (ASSOCIATED(database)) THEN
       DO qtyIndex=1,SIZE(database)
          CALL DestroyGridTemplateContents(database(qtyIndex))
       ENDDO
       DEALLOCATE(database, stat=status)
       IF (status /= 0) call announce_error(0,  &
         & MLSMSG_DeAllocate//"database")
    ENDIF
  END SUBROUTINE DestroyGridTemplateDatabase


!----------------- Beginning of Paul's code ------------------

    !---------------------------- ReadGriddedData ---------------------
  SUBROUTINE ReadGriddedData(FileName, lcf_where, description, v_type, &
  & the_g_data, GeoDimList, fieldName)
d295 6
a300 1
	! appropriate for 'ncep' or 'dao'
d302 2
a303 7
	! FileName and the_g_data are required args
	! GeoDimList, if present, should be the Dimensions' short names
	! as a comma-delimited character string in the order:
	! longitude, latitude, vertical level, time
	
	! fieldName, if present, should be the rank 3 or higher object
	! like temperature
d307 7
a313 7
    CHARACTER (LEN=*), INTENT(IN) :: FileName ! Name of the file containing the grid(s)
    INTEGER, INTENT(IN) :: lcf_where			! node of the lcf that provoked me
    INTEGER, INTENT(IN) :: v_type			! vertical coordinate; an 'enumerated' type
     TYPE( GriddedData_T ), INTENT(OUT) :: the_g_data ! Result
    CHARACTER (LEN=*), INTENT(IN) :: description ! e.g., 'dao'
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN) :: GeoDimList ! Comma-delimited dim names
	 CHARACTER (LEN=*), OPTIONAL, INTENT(IN) :: fieldName ! Name of gridded field
d317 56
a372 56
  integer :: edges(4)
  integer :: file_id, gd_id
  integer :: inq_success
  integer :: i
  integer :: nentries, ngrids, ndims, nfields
  integer :: strbufsize
!  character (len=80) :: msg, mnemonic
!  integer :: status

    LOGICAL,  PARAMETER       :: CASESENSITIVE = .FALSE.
  integer, parameter :: GRIDORDER=1				! What order grid written to file
  integer, parameter :: MAXLISTLENGTH=LineLen		! Max length list of grid names
  integer, parameter :: NENTRIESMAX=20		   ! Max num of entries
  character (len=MAXLISTLENGTH) :: gridlist
  character (len=MAXLISTLENGTH) :: dimlist, actual_dim_list
  character (len=MAXLISTLENGTH), DIMENSION(1) :: dimlists
  character (len=MAXLISTLENGTH) :: fieldlist
  integer, parameter :: MAXNAMELENGTH=NameLen		! Max length of grid name
  character (len=MAXNAMELENGTH) :: gridname, actual_field_name, the_dim
  INTEGER, DIMENSION(NENTRIESMAX) :: dims, rank, numberTypes, start, stride
  INTEGER                        :: our_rank, size, numberType
	!                                  These start out initialized to one
  INTEGER                        :: nlon=1, nlat=1, nlev=1, ntime=1
  INTEGER, PARAMETER             :: i_longitude=1
  INTEGER, PARAMETER             :: i_latitude=i_longitude+1
  INTEGER, PARAMETER             :: i_vertical=i_latitude+1
  INTEGER, PARAMETER             :: i_time=i_vertical+1
  ! External functions
!  integer, external :: gdopen, gdattach, gdrdfld, gddetach, gdclose
!  integer, external :: gdinqgrid, gdnentries, gdinqdims, gdinqflds
  INTEGER, EXTERNAL :: GDRDFLD
  logical, parameter :: COUNTEMPTY=.TRUE.
  logical            :: descrpt_is_legal
  logical            :: descrpt_is_misplcd

  ! - - - begin - - -

! Check if description is legal
	descrpt_is_legal = (lowercase(description(:len(lit_dao))) == lit_dao) &
	& .or. &
	& (lowercase(description(:len(lit_ncep))) == lit_ncep) &
	& .or. &
	& (lowercase(description(:len(lit_clim))) == lit_clim)

	descrpt_is_misplcd = lowercase(description(:len(lit_clim))) == lit_clim
	
	if(descrpt_is_misplcd) THEN
		call announce_error(lcf_where, 'READGriddedData called with climatology' &
		& // ' description')
		return
	elseif(.NOT. descrpt_is_legal) then
		call announce_error(lcf_where, 'READGriddedData called with unknown' &
		& // ' description: ' // description)
		return
	endif
	
d374 1
a374 1
  file_id = gdopen(FileName, DFACC_RDONLY)
d376 92
a467 92
  IF (file_id < 0) THEN
	CALL announce_error(lcf_where, "Could not open "// FileName)
  END IF

! Find list of grid names on this file
  inq_success = gdinqgrid(FileName, gridlist, strbufsize)
  IF (inq_success < 0) THEN
	CALL announce_error(lcf_where, "Could not inquire gridlist "// FileName)
  END IF

! Find grid name corresponding to the GRIDORDER'th one
	ngrids = NumStringElements(gridlist, COUNTEMPTY)
	
	IF(ngrids <= 0) THEN
		CALL announce_error(lcf_where, "NumStringElements of gridlist <= 0")
	ELSEIF(ngrids /= inq_success) THEN
		CALL announce_error(lcf_where, "NumStringElements of gridlist /= inq_success")
	ELSEIF(ngrids < GRIDORDER) THEN
		CALL announce_error(lcf_where, "NumStringElements of gridlist < GRIDORDER")
	ENDIF
	
	CALL GetStringElement(gridlist, gridname, GRIDORDER, COUNTEMPTY)

  gd_id = gdattach(file_id, gridname)
  IF (gd_id < 0) THEN
		CALL announce_error(lcf_where, "Could not attach "//FileName)
  END IF

! Now find dimsize(), dimname(), etc.
	nentries = gdnentries(gd_id, HDFE_NENTDIM, strbufsize)

	IF(nentries <= 0) THEN
		CALL announce_error(lcf_where, "nentries of gd_id <= 0")
	ELSEIF(nentries > NENTRIESMAX) THEN
		CALL announce_error(lcf_where, "nentries of gd_id > NENTRIESMAX")
	ENDIF

	ndims = gdinqdims(gd_id, dimlist, dims)

	IF(ndims <= 0) THEN
		CALL announce_error(lcf_where, "ndims of gd_id <= 0")
	ELSEIF(ndims > NENTRIESMAX) THEN
		CALL announce_error(lcf_where, "ndims of gd_id > NENTRIESMAX")
	ENDIF

	nfields = gdinqflds(gd_id, fieldlist, rank, numberTypes)

	IF(nfields <= 0) THEN
		CALL announce_error(lcf_where, "nfields of gd_id <= 0")
	ELSEIF(nfields > NENTRIESMAX) THEN
		CALL announce_error(lcf_where, "nfields of gd_id > NENTRIESMAX")
	ENDIF
	
	IF(.NOT. CASESENSITIVE) THEN
		fieldlist = Capitalize(fieldlist)
	ENDIF

	IF(PRESENT(fieldName)) THEN
		actual_field_name=fieldName
	ELSE
		actual_field_name=DEFAULTFIELDNAME
	ENDIF

	IF(PRESENT(GeoDimList)) THEN
		actual_dim_list=GeoDimList
	ELSE
		actual_dim_list=GEO_FIELD1 // ',' // &
		& GEO_FIELD2 // ',' // &
		& GEO_FIELD3 // ',' // &
		& GEO_FIELD4
	ENDIF

	! Now find the rank of our field
	
	inq_success = gdfldinfo(gd_id, TRIM(actual_field_name), our_rank, dims, &
	& numbertype, dimlists(1))

	dimlist = TRIM(dimlists(1))

	nlon = dims(1)
	nlat = dims(2)
	nlev = dims(3)
	ntime = dims(4)
		  
	the_g_data%quantityName = actual_field_name
	the_g_data%description = description
	the_g_data%verticalCoordinate = v_type
	  
	the_g_data%noLons = nlon
	the_g_data%noLats = nlat
	the_g_data%noHeights = nlev
	the_g_data%noLsts = ntime
d469 2
a470 2
  !-----------------------------
  END SUBROUTINE ReadGriddedData
d476 2
a477 2
  & mlspcf_l2clim_start, mlspcf_l2clim_end )
  !=====================================================================
d479 3
a481 3
	! An atavism--
	! a throwback to when ncep files were opened
	! independently of being required by the lcf
d495 1
a495 1
    logical :: end_of_file = .FALSE.
d499 1
a499 1
!     Open one Climatology file as a generic file for reading
d502 1
a502 1
                                        processCli, version )
d505 4
a508 1
      do while (.NOT. end_of_file)
d510 9
a518 2
        call l3ascii_read_field ( processCli, qty, end_of_file)
        returnStatus = AddGridTemplateToDatabase(aprioriData, qty)
d520 1
a520 9
		  nullify (qty%lats)
		  nullify (qty%lons)
		  nullify (qty%lsts)
		  nullify (qty%szas)
		  nullify (qty%dateStarts)
		  nullify (qty%dateEnds)
		  nullify (qty%field)
! No, this is a bad idea (according to njl)
!        call DestroyGridTemplateContents ( qty )
d522 1
a522 3
      end do !(.not. end_of_file)
		
		end_of_file = .FALSE.
d528 2
a529 2
  return
  !============================
d535 6
a540 6
  SUBROUTINE READ_CLIMATOLOGY ( fname, root, aprioriData, &
  & mlspcf_l2clim_start, mlspcf_l2clim_end, echo_data, dump_data )
  ! --------------------------------------------------
  ! Brief description of program
  ! This subroutine reads a l3ascii file and returns
  ! the data_array to the caller
d542 1
a542 1
  ! Arguments
d544 1
a544 1
  character*(*), intent(in) :: fname			! Physical file name
d547 11
a557 11
	 INTEGER, OPTIONAL, INTENT(IN) :: mlspcf_l2clim_start, mlspcf_l2clim_end
    LOGICAL, OPTIONAL, intent(in) :: echo_data        ! echo climatology quantity name
    LOGICAL, OPTIONAL, intent(in) :: dump_data        ! dump climatology data
	 
	 ! Local
	 INTEGER, PARAMETER :: version=1

	! These determine how much extra to output
	 LOGICAL, PARAMETER :: debug=.FALSE.
	 LOGICAL, PARAMETER :: ECHO_GRIDDED_QUANTITIES=.FALSE.	! echo_data overrides
	 LOGICAL, PARAMETER :: DUMP_GRIDDED_QUANTITIES=.FALSE.	! dump_data overrides
d559 1
a559 1
	 LOGICAL :: end_of_file
d561 3
a563 3
	 INTEGER :: ErrType
	 LOGICAL :: echo
	 LOGICAL :: dump
a564 37
	 
	! begin
	end_of_file=.FALSE.
	if(present(echo_data)) then
		echo = echo_data
	ELSE
		echo = ECHO_GRIDDED_QUANTITIES
	ENDIF
	
	if(present(dump_data)) then
		dump = dump_data
	ELSE
		dump = DUMP_GRIDDED_QUANTITIES
	ENDIF
	
	! use PCF

	if(present(mlspcf_l2clim_start) .and. present(mlspcf_l2clim_end)) then

	 CliUnit = GetPCFromRef(fname, mlspcf_l2clim_start, mlspcf_l2clim_end, &
  & .TRUE., ErrType, version)
  
  IF(ErrType /= 0) THEN
!    CALL MLSMessage (MLSMSG_Error, ModuleName, &
!              &"Climatology file name unmatched in PCF")
    CALL announce_error (ROOT, &
              &"Climatology file name " // fname // " unmatched in PCF")
	RETURN
  ENDIF

      ErrType = Pgs_io_gen_openF ( CliUnit, PGSd_IO_Gen_RSeqFrm, 0, &
                                        processCli, version )

	! use Fortran open
	else
	
		if(debug) call output('opening ' // fname, advance = 'yes')
d566 38
a603 1
		CliUnit = mls_io_gen_openF ( 'open', .true., ErrType, &
a604 2
	
	endif
d606 9
a614 7
	if(debug) then
		if(.NOT. end_of_file) then
			call output('Not yet eof on io unit', advance = 'yes')
		else
			call output('Starting at eof on io unit', advance = 'yes')
		endif
	endif
d617 1
a617 1
      if ( ErrType == PGS_S_SUCCESS ) then
d619 1
a619 1
      do while (.NOT. end_of_file)
d621 1
a621 1
			if(debug) call output('reading l3ascii file', advance = 'yes')
d625 31
a655 31
			if(ErrType == 0) then
		  		if(debug) then
					call output('adding to grid database', advance='yes')
					call output('adding grid template to database ', advance='yes')
				endif
		 	 if(echo .OR. debug) then
				call output('quantity name ' // gddata%quantityName, advance='yes')
				call output('description ' // gddata%description, advance='yes')
				call output('units ' // gddata%units, advance='yes')
			endif

		  if(dump) then
			call Dump_Gridded_Data(gddata, root)
			endif

        ErrType = AddGridTemplateToDatabase(aprioriData, gddata)
		  
		  nullify (gddata%lats)
		  nullify (gddata%lons)
		  nullify (gddata%lsts)
		  nullify (gddata%szas)
		  nullify (gddata%dateStarts)
		  nullify (gddata%dateEnds)
		  nullify (gddata%field)
		  

			if(debug) call output('Destroying our grid template', advance='yes')
			
		endif
! No, this a bad idea according to njl--see nullify statements above
!        call DestroyGridTemplateContents ( gddata )
d658 4
a661 4
		
	! ok, done with this file and unit number
	if(present(mlspcf_l2clim_start) .and. present(mlspcf_l2clim_end)) then
      ErrType = Pgs_io_gen_CloseF ( CliUnit )
d664 4
a667 17
	else
	
		if(debug) call output('closing ' // fname, advance = 'yes')
		ErrType = mls_io_gen_CloseF ('close', CliUnit )
		
	endif

	if(ErrType /= 0) then
    		CALL announce_error (ROOT, &
              &"Error closing " // fname, error_number=ErrType)
	endif
	
		else

    		CALL announce_error (ROOT, &
              &"Error opening " // fname, error_number=ErrType)
		endif
d669 14
a682 1
	END SUBROUTINE READ_CLIMATOLOGY
d686 5
a690 5
  & mlspcf_l2dao_start, mlspcf_l2dao_end )
 
	! An atavism--
	! a throwback to when ncep files were opened
	! independently of being required by the lcf
d695 1
a695 1
	 INTEGER, INTENT(IN) :: mlspcf_l2dao_start, mlspcf_l2dao_end
d697 1
a697 1
! Local Variables
d699 1
a699 1
!    real(R8) :: data_array(XDIM, YDIM, ZDIM)
d705 1
a705 1
!   integer :: sd_id
d708 1
a708 1
!    ALLOCATE (data_array(XDIM, YDIM, ZDIM), stat=returnStatus)
d714 1
a714 1
! Get the DAO file name from the PCF
d719 1
a719 1
                                           DAOphysicalFilename )
d723 1
a723 1
! Open the HDF-EOS file and read gridded data
d726 5
a730 5
!        call read_dao ( DAOphysicalFilename, vname, data_array )
			IF(returnStatus > 0) THEN
				call ReadGriddedData ( DAOphysicalFilename, root, &
				& 'dao', v_is_pressure, aprioriData(returnStatus) )
			ENDIF
d736 1
a736 1
!===========================
d738 1
a738 1
!===========================
d742 1
a742 1
  & mlspcf_l2ncep_start, mlspcf_l2ncep_end )
d744 3
a746 3
	! An atavism--
	! a throwback to when ncep files were opened
	! independently of being required by the lcf
d748 1
a748 1
	    ! Arguments
d752 1
a752 1
	 INTEGER, INTENT(IN) :: mlspcf_l2ncep_start, mlspcf_l2ncep_end
d755 1
a755 1
!    character (len=80) :: MSG, MNEMONIC
d760 1
a760 1
!    character (len=80) :: VNAME
d762 1
a762 1
!   allocate ( data_array(XDIM, YDIM, ZDIM), stat=returnStatus )
d765 2
a766 2
!    vname = "TMP_3" ! for now
! Get the NCEP file name from the PCF
d771 1
a771 1
                                           NCEPphysicalFilename )
d775 1
a775 1
! Open the HDF-EOS file and read gridded data
d779 5
a783 5
!        call read_ncep ( NCEPphysicalFilename, data_array )
			IF(returnStatus > 0) THEN
				call ReadGriddedData ( NCEPphysicalFilename, root, &
				& 'ncep', v_is_pressure, aprioriData(returnStatus) )
			ENDIF
d788 1
a788 1
!===========================
d790 1
a790 1
!===========================
d796 3
a798 3
	! Imitating what dump_pointing_grid_database does, but for gridded data
	! which may come from climatology, ncep, dao
	
d804 2
a805 2
    logical, parameter :: MAYDUMPFIELDVALUES = .FALSE.
	 integer            :: i
d807 4
a810 4
	if ( .NOT. associated(GriddedData)) then
		call announce_error(ROOT, 'Gridded database still null')
		return
	endif
d816 2
a817 2
    call output ( 'item number ' )
    call output ( i, advance='yes' )
d819 1
a819 1
		call Dump_Gridded_Data(GriddedData(i), root)
d827 3
a829 3
	! Imitating what dump_pointing_grid_database does, but for gridded data
	! which may come from climatology, ncep, dao
	
d835 1
a835 1
    logical, parameter :: MAYDUMPFIELDVALUES = .FALSE.
d837 49
a885 49
			call output('quantity name ' // GriddedData%quantityName, advance='yes')
			call output('description ' // GriddedData%description, advance='yes')
			call output('units ' // GriddedData%units, advance='yes')

      call output ( ' ************ Geometry ********** ' ,advance='yes')

      call output ( ' Vertical coordinate = ' )
      call output ( GriddedData%verticalCoordinate, advance='yes' )
      call output ( ' No. of heights = ' )
      call output ( GriddedData%noHeights, advance='yes' )
        call dump ( GriddedData%heights, &
          & '    Heights =' )

      call output ( ' Equivalent latitude = ' )
      call output ( GriddedData%equivalentLatitude, advance='yes' )
      call output ( ' No. of latitudes = ' )
      call output ( GriddedData%noLats, advance='yes' )
        call dump ( GriddedData%lats, &
          & '    latitudes =' )

      call output ( ' No. of longitudes = ' )
      call output ( GriddedData%noLons, advance='yes' )
        call dump ( GriddedData%lons, &
          & '    longitudes =' )

      call output ( ' No. of local times = ' )
      call output ( GriddedData%noLsts, advance='yes' )
        call dump ( GriddedData%lsts, &
          & '    local times =' )

      call output ( ' No. of solar zenith angles = ' )
      call output ( GriddedData%noSzas, advance='yes' )
        call dump ( GriddedData%szas, &
          & '    solar zenith angles =' )

      call output ( ' No. of dates = ' )
      call output ( GriddedData%noDates, advance='yes' )
        call dump ( GriddedData%dateStarts, &
          & '    starting dates =' )
        call dump ( GriddedData%dateEnds, &
          & '    ending dates =' )

		if(MAYDUMPFIELDVALUES) then
     	 call output ( ' ************ tabulated field values ********** ' ,advance='yes')

	! No dump for 6-dimensional double arrays yet, anyway
   !     call dump ( GriddedData%field, &
    !      & '    gridded field values =' )
		endif
d891 9
a899 9
  & ) result (already)
  ! check if source file among those already read to form database
  ! returns .TRUE. if already read, .FALSE. if not or if database is empty
  
  ! optionally checks that field name is also matched for that partcilar
  ! source file
  
  ! Arguments
  !   
d901 39
a939 34
	 character (LEN=*), intent(in) :: source_file
	 character (LEN=*), optional, intent(in) :: field_name
	 logical :: already
	 
	 ! Local
	 integer :: i
	 
	 ! Begin
	 already = .FALSE.

	 if(.NOT. associated(GriddedDataBase)) then
	 	return
	elseif(LEN(source_file) == 0) then
		return
	elseif(SIZE(GriddedDataBase) == 0) then
		return
	endif
	
	do i=1, SIZE(GriddedDataBase)

		if(adjustl(source_file) == adjustl(GriddedDataBase(i)%sourceFileName)) then
			already = .TRUE.
			exit
		endif
		
	enddo
	
	if(present(field_name) .AND. already) then
		
		if(adjustl(field_name) == adjustl(GriddedDataBase(i)%quantityName)) then
			already = .TRUE.
		else
			already = .FALSE.
		endif
d941 1
a941 1
	endif
d947 58
a1004 58
  & error_number )
  
   ! Arguments
	
	integer, intent(in)    :: lcf_where
	character(LEN=*), intent(in)    :: full_message
	logical, intent(in), optional :: use_toolkit
	integer, intent(in), optional    :: error_number
	! Local
!  character (len=80) :: msg, mnemonic
!  integer :: status
  logical :: just_print_it
  logical, parameter :: default_output_by_toolkit = .true.
	
	if(present(use_toolkit)) then
		just_print_it = use_toolkit
	elseif(default_output_by_toolkit) then
		just_print_it = .false.
	else
		just_print_it = .true.
	endif
	
	if(.not. just_print_it) then
!    CALL Pgs_smf_getMsg(status, mnemonic, msg)
!    CALL MLSMessage (level, ModuleName, &
!              &trim(full_message)//" "//mnemonic//" "//msg)
    error = max(error,1)
    call output ( '***** At ' )

	if(lcf_where > 0) then
	    call print_source ( source_ref(lcf_where) )
		else
    call output ( '(no lcf node available)' )
		endif

    call output ( ': ' )
    call output ( "The " );
	if(lcf_where > 0) then
    call dump_tree_node ( lcf_where, 0 )
		else
    call output ( '(no lcf tree available)' )
		endif

		CALL output("Caused the following error:", advance='yes', &
		& from_where=ModuleName)
		CALL output(trim(full_message), advance='yes', &
		& from_where=ModuleName)
		if(present(error_number)) then
			CALL output('error number ', advance='no')
			CALL output(error_number, places=9, advance='yes')
		endif
	else
		print*, '***Error in module ', ModuleName
		print*, trim(full_message)
		if(present(error_number)) then
			print*, 'error number ', error_number
		endif
	endif
d1006 1
a1006 1
!===========================
d1008 1
a1008 1
!===========================
d1010 2
a1011 2
!=============================================================================
END MODULE ncep_dao
d1016 3
@


2.8
log
@AddGridTemplatetoDatabase now works
@
text
@d36 1
a36 1
       "$Id: ncep_dao.f90,v 2.7 2001/03/28 00:25:14 pwagner Exp $"
d44 1
a44 1
	& Dump_Gridded_Database
d552 8
a561 5
	 INTEGER, PARAMETER :: version=1
	 LOGICAL :: end_of_file
	 LOGICAL, PARAMETER :: debug=.FALSE.
	 LOGICAL, PARAMETER :: ECHO_GRIDDED_QUANTITIES=.TRUE.
	 LOGICAL, PARAMETER :: DUMP_GRIDDED_QUANTITIES=.TRUE.
d889 51
d1011 3
@


2.7
log
@More changes, but not perfect yet
@
text
@d36 1
a36 1
       "$Id: ncep_dao.f90,v 2.6 2001/03/27 17:28:31 pwagner Exp $"
d509 10
a518 1
        call DestroyGridTemplateContents ( qty )
d638 9
d651 2
a652 1
        call DestroyGridTemplateContents ( gddata )
d957 3
@


2.6
log
@Can dump gridded database
@
text
@d36 1
a36 1
       "$Id: ncep_dao.f90,v 2.5 2001/03/24 00:29:32 pwagner Exp $"
d527 1
a527 1
  & mlspcf_l2clim_start, mlspcf_l2clim_end, echo_data )
d539 2
a540 1
    LOGICAL, OPTIONAL, intent(in) :: echo_data        ! Root of the L2CF abstract syntax tree
d549 1
d551 1
d562 6
d611 16
a626 10
        call l3ascii_read_field ( CliUnit, gddata, end_of_file)
		  if(debug) then
			call output('adding to grid database', advance='yes')
			call output('adding grid template to database ', advance='yes')
		endif
		  if(echo .OR. debug) then
			call output('quantity name ' // gddata%quantityName, advance='yes')
			call output('description ' // gddata%description, advance='yes')
			call output('units ' // gddata%units, advance='yes')
		endif
d632 1
d783 1
a783 1
    integer :: I, J                ! Subscripts, loop inductors
d785 6
a790 1
    call output ( 'a priori grids: SIZE = ' )
d793 25
a817 3
			call output('quantity name ' // GriddedData(i)%quantityName, advance='yes')
			call output('description ' // GriddedData(i)%description, advance='yes')
			call output('units ' // GriddedData(i)%units, advance='yes')
d822 1
a822 1
      call output ( GriddedData(i)%verticalCoordinate, advance='yes' )
d824 2
a825 2
      call output ( GriddedData(i)%noHeights, advance='yes' )
        call dump ( GriddedData(i)%heights, &
d829 1
a829 1
      call output ( GriddedData(i)%equivalentLatitude, advance='yes' )
d831 2
a832 2
      call output ( GriddedData(i)%noLats, advance='yes' )
        call dump ( GriddedData(i)%lats, &
d836 2
a837 2
      call output ( GriddedData(i)%noLons, advance='yes' )
        call dump ( GriddedData(i)%lons, &
d841 2
a842 2
      call output ( GriddedData(i)%noLsts, advance='yes' )
        call dump ( GriddedData(i)%lsts, &
d846 2
a847 2
      call output ( GriddedData(i)%noSzas, advance='yes' )
        call dump ( GriddedData(i)%szas, &
d851 2
a852 2
      call output ( GriddedData(i)%noDates, advance='yes' )
        call dump ( GriddedData(i)%dateStarts, &
d854 1
a854 1
        call dump ( GriddedData(i)%dateEnds, &
d861 1
a861 1
   !     call dump ( GriddedData(i)%field, &
d865 1
a865 2
    end do ! i
  end subroutine Dump_Gridded_Database
d938 3
@


2.5
log
@Now seems to read climatology files better
@
text
@d20 1
a20 1
  USE MLSFiles, only: GetPCFromRef, mls_io_gen_openF
d27 1
a27 1
  & PGS_IO_GEN_OPENF, PGSD_IO_GEN_RSEQFRM
d36 1
a36 1
       "$Id: ncep_dao.f90,v 2.4 2001/03/21 00:47:29 pwagner Exp $"
d43 2
a44 1
	&   AddGridTemplateToDatabase, DestroyGridTemplateDatabase
d123 1
a123 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d128 1
a128 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d132 1
a132 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d136 1
a136 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d140 1
a140 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d145 1
a145 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d149 1
a149 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d156 1
a156 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d177 1
a177 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d182 1
a182 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d187 1
a187 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d192 1
a192 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d197 1
a197 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d202 1
a202 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d207 1
a207 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d212 1
a212 1
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d281 1
a281 1
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
d527 1
a527 1
  & mlspcf_l2clim_start, mlspcf_l2clim_end )
d539 1
d545 4
a548 1
	 LOGICAL :: end_of_file=.FALSE.
d552 6
d580 1
a580 1
		call output('opening ' // fname)
d587 9
d600 1
a600 1
			call output('reading l3ascii file')
d603 1
d606 2
d611 1
d615 1
a615 1
			call output('Destroying our grid template', advance='yes')
d621 17
d754 71
d896 3
@


2.4
log
@Changes to READ_CLIMATOLOGY, announce_error
@
text
@d36 1
a36 1
       "$Id: ncep_dao.f90,v 2.3 2001/03/20 00:42:11 pwagner Exp $"
d581 8
a588 2
        call l3ascii_read_field ( processCli, gddata, end_of_file)
			call output('adding to grid database')
d590 3
d784 3
@


2.3
log
@Improved Read_Climatology
@
text
@d20 1
a20 1
  USE MLSFiles, only: GetPCFromRef
d36 1
a36 1
       "$Id: ncep_dao.f90,v 2.2 2001/03/15 21:40:30 pwagner Exp $"
d525 1
a525 1
  SUBROUTINE READ_CLIMATOLOGY ( fname, aprioriData, &
d536 2
a537 1
	 INTEGER, INTENT(IN) :: mlspcf_l2clim_start, mlspcf_l2clim_end
d544 1
a544 1
    integer:: processCli, CliUnit
d546 6
d556 4
a559 2
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
              &"Climatology file name unmatched in PCF")
d565 11
d580 1
d582 1
d588 4
d705 2
a706 1
  subroutine announce_error ( lcf_where, full_message, use_toolkit )
d713 1
d753 4
d760 3
d775 3
@


2.2
log
@Eliminated unused routines from USE statements
@
text
@d24 1
a24 1
  & GetIntHashElement
d36 1
a36 1
       "$Id: ncep_dao.f90,v 2.1 2001/03/15 21:26:57 pwagner Exp $"
d47 2
d59 4
d348 2
d353 19
d540 1
a540 1
	 INTEGER :: thePC, ErrType
d545 1
a545 1
	 thePC = GetPCFromRef(fname, mlspcf_l2clim_start, mlspcf_l2clim_end, &
d740 3
@


2.1
log
@Moved non-l3ascii methods from GriddedData here
@
text
@d24 1
a24 1
  & Count_words, ReadCompleteLineWithoutComments, GetIntHashElement
d36 2
a37 2
       "$Id: GriddedData.f90,v 2.8 2001/03/15 00:37:13 pwagner Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: GriddedData.f90,v $"
d712 3
a714 30
! $Log: GriddedData.f90,v $
! Revision 2.8  2001/03/15 00:37:13  pwagner
! Still not complete; missing gdrdfld
!
! Revision 2.7  2001/03/14 00:32:47  pwagner
! More changes--still wrong, though
!
! Revision 2.6  2001/03/10 00:33:16  pwagner
! Some corrections in ReadGriddedData
!
! Revision 2.5  2001/03/09 01:02:55  pwagner
! Fixed announce_error
!
! Revision 2.4  2001/03/08 01:08:35  pwagner
! Added announce_error
!
! Revision 2.3  2001/03/07 01:03:19  pwagner
! ReadGriddedData added
!
! Revision 2.2  2001/02/21 00:36:43  pwagner
! l3ascii_read_field now has eof as intent(out) arg
!
! Revision 2.1  2001/02/20 21:51:39  pwagner
! Functions absorbed from gridded_data_module
!
! Revision 2.0  2000/09/05 17:41:05  dcuddy
! Change revision to 2.0
!
! Revision 1.5  2000/06/20 22:19:22  lungu
! Changed DOUBBLE PRECISION to REAL (r8).
@

