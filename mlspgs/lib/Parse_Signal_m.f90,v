head	2.28;
access;
symbols
	v5-02-NRT-19:2.28
	v6-00:2.28
	v5-02-NRT-18:2.28
	v5-02:2.28
	v5-01-NRT-17:2.28
	v5-01-NRT-16:2.28
	v5-01-NRT-15:2.28
	v5-01-NRT-14:2.28
	neuralnetworks-1-0:2.28.0.10
	cfm-single-freq-0-1:2.28.0.8
	v5-01:2.28
	v5-00:2.28
	v4-23-TA133:2.28.0.6
	mus-emls-1-70:2.28.0.4
	rel-1-0-englocks-work:2.28.0.2
	VUMLS1-00:2.27
	VPL1-00:2.27
	V4-22-NRT-08:2.26
	VAM1-00:2.26
	V4-21:2.26.0.2
	V4-13:2.26
	V4-12:2.26
	V4-11:2.26
	V4-10:2.26
	V3-43:2.25
	M4-00:2.25
	V3-41:2.25
	V3-40-PlusGM57:2.25.0.2
	V2-24-NRT-04:2.24
	V3-33:2.25
	V2-24:2.24
	V3-31:2.25
	V3-30-NRT-05:2.25
	cfm-01-00:2.25
	V3-30:2.25
	V3-20:2.25
	V3-10:2.25
	V2-23-NRT-02:2.24
	V2-23:2.24
	V2-22-NRT-01:2.24
	V2-22:2.24
	V2-21:2.24
	V2-20:2.24
	V2-11:2.24
	V2-10:2.24
	V2-00:2.23
	V1-51:2.17
	V1-50:2.17
	V1-45:2.17
	V1-44:2.17
	V1-43:2.17
	V1-42:2.16
	V1-41:2.16
	V1-32:2.16
	V1-40:2.16
	V1-31:2.16
	V1-30:2.16
	V1-13:2.15
	V1-12:2.15
	V1-11:2.15
	V1-10:2.14
	newfwm-feb03:2.14.0.2
	V1-04:2.11
	V1-03:2.11
	V1-02:2.11
	V1-00:2.11
	newfwm-sep01:2.11.0.2
	V0-7:2.11
	V0-5-Level2:2.10
	V0-5-SIPS:2.9;
locks; strict;
comment	@# @;


2.28
date	2017.07.26.22.19.55;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2016.07.25.23.39.49;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2013.09.24.23.27.14;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2006.07.29.01.36.33;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2005.05.02.22.58.24;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2005.03.24.01.38.36;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2005.02.05.00.05.07;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2005.01.12.23.58.47;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2005.01.12.03.08.38;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2004.03.24.22.45.59;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2003.05.05.23.00.05;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2003.03.07.03.17.28;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2003.01.25.04.14.13;	author vsnyder;	state Exp;
branches
	2.14.2.1;
next	2.13;

2.13
date	2002.11.06.00.13.32;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2002.10.08.00.09.13;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.06.07.21.59.41;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.26.02.33.03;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.04.13.20.58.48;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.04.11.20.19.46;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.04.11.02.10.45;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.04.10.17.59.54;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2001.04.09.20.15.53;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.04.06.20.15.36;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.16.00.34.50;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2001.03.15.23.57.27;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2001.03.15.23.40.22;	author vsnyder;	state Exp;
branches;
next	;

2.14.2.1
date	2003.03.01.02.40.04;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.28
log
@Print the expected band or radiometer suffix if error
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Parse_Signal_M

  implicit NONE
  private
! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

! Expand_Signal_List      Convert subtree to fully described signals
! Get_Individual_Signals  Expand signal array to fully-qualified signals
! Parse_Signal            Return database indices matching signal string
! === (end of toc) ===

! === (start of api) ===
! Expand_Signal_List ( int node, signal_t* theseSignals[], log* error )
! Get_Individual_Signals ( char* outSignals[], int inSignals_ind[] char* inSignals_txt[] )
! Parse_Signal  ( char* Signal_String, int* Signal_Indices(:),
!    [int Tree_Index], [int Sideband],[log* Channels(:)], [int OnlyCountEm] )
! === (end of api) ===

  public :: Parse_Signal, Expand_Signal_List, Get_Individual_Signals

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Parse_Signal_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  ! -----------------------------------------  Expand_signal_list  -----
  subroutine Expand_signal_list ( node, theseSignals, error )
    ! This uses parse_signal below to convert an array of strings
    ! at tree node 'node' into a fully described array of signals
    ! populated with channel flags and everything

    use Allocate_Deallocate, only: allocate_test, deallocate_test
    use MLSSignals_m, only: signals, signal_t, destroySignalDatabase
    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Error
    use Tree, only: subtree, sub_rosa, nsons
    use String_table, only: get_string

    integer, intent(in) :: NODE         ! Tree node
    type ( Signal_T ), pointer, dimension(:) :: THESESIGNALS ! Result
    logical, intent(out) :: ERROR

    ! Local variables
    integer :: J                        ! Loop counter
    integer :: STATUS                   ! Flag from allocate etc.
    character (len=132) :: SIGNALSTRING ! One signal name
    integer, dimension(:), pointer :: SIGNALINDS ! Array of signal indicies
    logical, dimension(:), pointer :: CHANNELS ! Which channels in signal
    integer :: SIDEBAND                 ! One sideband
    integer :: Son                      ! of Node
    integer :: WANTED                   ! Which of the possible matches do we want

    ! Executable code

    ! Make sure the result is deallocated, do some setup
    call DestroySignalDatabase ( theseSignals, justChannels=.true. )
    allocate ( theseSignals (nsons(node)-1), stat = status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, MLSMSG_Allocate // 'theseSignals' )
    nullify ( channels, signalInds )
    error = .false.

    ! Loop over the strings
    do j = 1, nsons(node)-1
      son = subtree(j+1,node)
      call get_string ( sub_rosa(son), signalString, strip=.true.)
      call parse_Signal ( signalString, signalInds, &
        & tree_index=son, sideband=sideband, channels=channels )
      if ( .not. associated(signalInds) ) then ! A parse error occurred
        error = .true.
        ! Could tidy up, but expect to crash anyway
        return
      end if
      ! parse_signal may have returned several signals (e.g. different
      ! switch settings). Later on choose the `right' one from the match
      ! For the moment choose the first !????
      wanted = 1
      theseSignals(j) = signals(signalInds(wanted))
      theseSignals(j)%sideband = sideband
      ! Don't hose channels in database, though shouldn't be an issue
      nullify ( theseSignals(j)%channels ) 
      
      call allocate_Test ( theseSignals(j)%channels, &
        & ubound(theseSignals(j)%frequencies,1), 'signals%channels', &
        & ModuleName, lowBound=lbound(theseSignals(j)%frequencies,1) )
      if ( associated(channels) ) then
        ! The reason that this is so messy is that channels has l/u bounds
        ! of the highest and lowest channels asked for.
        theseSignals(j)%channels(:lbound(channels,1)-1) = .false.
        theseSignals(j)%channels(lbound(channels,1):ubound(channels,1)) = &
          channels
        theseSignals(j)%channels(ubound(channels,1)+1:) = .false.
      else
        theseSignals(j)%channels = .true.
      end if
      call deallocate_test ( channels, 'channels', ModuleName )
      call deallocate_test ( signalInds, 'signalInds', ModuleName )
    end do                          ! End loop over listed signals

    ! Executable code
  end subroutine Expand_signal_list

  ! -------------------------------------  Get_Individual_Signals  -----
  subroutine Get_Individual_Signals ( OutSignals, InSignals_Ind, InSignals_Txt )
  ! Given InSignals_Ind or InSignals_Txt, create OutSignals where each of
  ! OutSignals is a signal denoted in InSignals_*, but describes exactly
  ! one radiometer, band, switch, spectrometer, sideband and channel. 
  ! OutSignals is allocated using Allocate_Test, so don't send in an
  ! undefined pointer! There will be no duplicates in OutSignals. 
  ! Zero-size InSignals_* works.

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSSignals_m, only: GetSignalName, MaxSigLen, Signals
    use Sort_m, only: Sort
    use String_Table, only: Get_String

    character(len=*), pointer :: OutSignals(:)
    integer, intent(in), optional :: InSignals_Ind(:)
    character(len=*), intent(in), optional :: InSignals_Txt(:)

    logical, pointer :: Channels(:)
    integer :: I, J, K, L, N
    character(len=len(outSignals)), pointer :: MySignals(:)
    character(len=maxSigLen) :: OneSignal
    integer :: Sideband
    integer, pointer :: SignalIndices(:)

    nullify ( channels, mySignals, signalIndices )
    ! Determine the size of mySignals
    l = 0
    if ( present(inSignals_ind) ) n = size(inSignals_ind)
    if ( present(inSignals_txt) ) n = size(inSignals_txt)
    do i = 1, n
      if ( present(inSignals_ind) ) &
        & call get_string ( inSignals_ind(i), oneSignal, strip=.true. )
      if ( present(inSignals_txt) ) &
        & oneSignal = inSignals_txt(i)
      call parse_signal ( oneSignal, signalIndices, sideband=sideband, &
        & channels=channels )
      if ( .not. associated(signalIndices) ) call MLSMessage ( MLSMSG_Error, &
        & moduleName, 'Unable to parse signal ' // trim(oneSignal) )
      if ( .not. associated(channels) ) then
        ! All channels are desired.  Assume channels available in all
        ! selected signals are the same.
        k = size(signals(signalIndices(1))%frequencies)
      else
        k = count(channels)
      end if
      l = l + k
      do j = 1, size(signalIndices)
        l = l + k
        if ( sideband == 0 .and. signals(signalIndices(j))%singleSideband == 0 ) &
          & l = l + k ! pick up both sidebands
      end do ! j = 1, size(signalIndices)
    end do ! i = 1, n
    ! Fill mySignals
    call allocate_test ( mySignals, l, 'mySignals', moduleName )
    if ( l /= 0 ) then
      l = 0
      do i = 1, n
        if ( present(inSignals_ind) ) &
          & call get_string ( inSignals_ind(i), oneSignal, strip=.true. )
        if ( present(inSignals_txt) ) &
          & oneSignal = inSignals_txt(i)
        call parse_signal ( oneSignal, signalIndices, sideband=sideband, &
          & channels=channels )
        if ( .not. associated(channels) ) then
          ! All channels are desired.  Assume channels available in all
          ! selected signals are the same.
          call allocate_test ( channels, &
            & ubound(signals(signalIndices(1))%frequencies,1), 'myChannels', &
            & moduleName, &
            & lowBound=lbound(signals(signalIndices(1))%frequencies,1) )
          channels = .true.
        end if
        do j = 1, size(signalIndices)
          do k = lbound(channels,1), ubound(channels,1)
            if ( channels(k) ) then
              l = l + 1
              if ( sideband == 0 .and. signals(signalIndices(j))%singleSideband == 0 ) then
                call getSignalName ( signalIndices(j), mySignals(l), &
                  & channel=k, sideband=-1 )
                l = l + 1
                call getSignalName ( signalIndices(j), mySignals(l), &
                  & channel=k, sideband=+1 )
              else
                call getSignalName ( signalIndices(j), mySignals(l), &
                  & channel=k, sideband=sideband )
              end if
            end if
          end do ! k = lbound(channels), ubound(channels)
        end do ! j = 1, size(signalIndices)
      end do ! i = 1, n
      ! Delete duplicate signals
      call sort ( mySignals, 1, l )
      k = 1
      do i = 2, l
        if ( mySignals(i) /= mySignals(i-1) ) k = k + 1
      end do
    else
      k = 0
    end if
    ! Copy mySignals to outSignals, deleting duplicates
    call allocate_test ( outSignals, k, 'Outsignals', moduleName )
    if ( l /= 0 ) then
      outSignals(1) = mySignals(1)
      k = 1
      do i = 2, l
        if ( mySignals(i) /= mySignals(i-1) ) then
          k = k + 1
          outSignals(k) = mySignals(i)
        end if
      end do
    end if
    ! Clean up
    call deallocate_test ( channels, 'Channels', moduleName )
    call deallocate_test ( mySignals, 'MySignals', moduleName )
    call deallocate_test ( signalIndices, 'SignalIndices', moduleName )
  end subroutine Get_Individual_Signals

  ! -----------------------------------------------  Parse_signal  -----

  subroutine Parse_Signal ( Signal_String, Signal_Indices, &
    & Tree_Index, Sideband, Channels, OnlyCountEm )

  ! Parse a signal string.  Return the indices in the signal database of
  ! signals that match the signal string.

  ! A signal string is of the form:
  ! [Radiometer[:suffix].] [Band[:suffix].] [S switch-number.] [Spectrometer.]
  ! [C channel_number[:|+channel_number]*

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Declaration_Table, only: Decls, Get_Decl, Label
    use Init_MLSSignals_m, only: S_Band, S_Radiometer, S_SpectrometerType
    use Intrinsic, only: Spec_Indices
    use Lexer_Core, only: Print_Source, Token
    use Lexer_m, only: Lex_Signal
    use MLSSignals_m, only: Bands, Radiometers, Signals
    use MLSStringLists, only: SwitchDetail
    use MoreTree, only: Get_Spec_ID
    use Output_m, only: Output
    use String_table, only: Display_string, Get_String
    use Symbol_Table, only: Dump_Symbol_Class, Enter_Terminal
    use Symbol_Types, only: T_Colon, T_Dot, T_End_of_input, T_Identifier, &
      & T_Minus, T_Plus
    use Toggles, only: Switches
    use Tree, only: Decoration, Where_At => Where

    character(len=*), intent(in) :: Signal_String ! Input
    integer, pointer :: Signal_Indices(:)         ! Indices in the signals
    ! database.  Deallocated here using Allocate_Test, so don't start with an
    ! undefined pointer!  Upon return, if Signal_Indices is not associated
    ! (and OnlyCountEm is not present), an error occurred.
    integer, intent(in), optional :: Tree_Index   ! To get line and column
    !                                               numbers for messages
    integer, intent(out), optional :: Sideband    ! Zero if no band is
    ! specified, or if a band is specified but it has none of [UuLl] in it.
    ! +1 if a band is specified and it has [Uu] in it.  -1 if a band is
    ! specified and it has [Ll] in it.
    logical, pointer, dimension(:), optional :: Channels    ! Output: Channel
    ! numbers mentioned after the .C part of the signal specification. They
    ! are allocated here using Allocate_Test, so don't start with an
    ! undefined pointer!
    integer, intent(out), optional :: OnlyCountEm ! If OnlyCountEm is present,
    ! Signal_Indices is NOT touched; instead, OnlyCountEm returns the number
    ! of matching signals.

    integer :: Band_i         ! Database index
    type(decls) :: Decl       ! Declaration of an identifier
    integer :: Error          ! >0 indicates an error
    integer :: I              ! Temporary, loop inductor, subscript
    integer, dimension(len(signal_string)/2,2) :: MyChannelNumbers
    logical, pointer, dimension(:) :: MyChannels
    integer :: MySideBand     ! Index of [UuLl] in band, then 0 or +/- 1.
    integer :: Next           ! One of Saw... parameters below, to indicate
    !                           the category of the next identifier
    integer :: NumChannelNums ! How many elements of MyChannelNumbers are used
    integer :: Radiometer_i   ! Database index
    integer :: SawWhat        ! What has been seen so far.  See Saw... below
    integer :: Spectrometer_i ! Database index
    integer :: Spectrometer_n ! Number after "-", in e.g. FB25-3
    integer :: Status         ! From an internal READ
    integer :: Switch         ! Switch number, from the token text
    character(len=32) :: TestText   ! From a "%suffix" field via sub_rosa
    type(token) :: The_Token  ! that results from lexing the signal string
    character(len=32) :: TokenText  ! Duh
    logical :: Verbose        ! Print debugging stuff
    integer :: Where     ! The current analysis point in the signal string

    ! States.  The pieces of the radiometer specification must be presented
    ! in order, but pieces can be missing.
    integer, parameter :: SawNothing = 0
    integer, parameter :: SawRadiometer = sawNothing + 1
    integer, parameter :: SawBand = sawRadiometer + 1
    integer, parameter :: SawSwitch = sawBand + 1
    integer, parameter :: SawSpectrometerType = sawSwitch + 1
    integer, parameter :: SawChannel = sawSpectrometerType + 1
    integer, parameter :: SawChannelColon = sawChannel + 1
    integer, parameter :: SawChannelPlus = SawChannelColon + 1

    ! Parameters for error message codes
    integer, parameter :: ChannelsDecrease = 1       ! Channel numbers not in order
    integer, parameter :: Invalid = ChannelsDecrease + 1 ! Invalid combination
    integer, parameter :: Malformed = invalid + 1    ! Expected Letter Digits+
    integer, parameter :: OutOfOrder = malformed + 1 ! Identifiers not in order
    integer, parameter :: NoSuffix = outOfOrder + 1  ! Suffix not allowed
    integer, parameter :: NotEnough = noSuffix + 1   ! Not enough info
    integer, parameter :: NotLabel = notEnough + 1   ! Not the label of ...
    integer, parameter :: NotNumber = notLabel + 1   ! Expected a number
    integer, parameter :: Unexpected = notNumber + 1 ! Unexpected token
    integer, parameter :: WrongSuffix = unexpected + 1

    ! Initialize
    band_i = -1
    error = 0
    nullify ( myChannels )
    mySideband = 0
    next = sawNothing
    numChannelNums = 0
    radiometer_i = -1
    sawWhat = sawNothing
    call deallocate_test ( signal_indices, "Signal_Indices", moduleName )
    spectrometer_i = -1
    spectrometer_n = -1
    switch = -1
    verbose = switchDetail(switches,'ParSig') > -1
    where = 0
    if ( verbose ) call output( signal_string, advance='yes' )
    if ( verbose ) call output( 'len(signal_string)', advance='no' )
    if ( verbose ) call output( len_trim(signal_string), advance='yes' )
    ! Get the tokens; verify they are the correct kinds of thing-o's.
o:  do
      call lex_signal ( signal_string, where, the_token )
      if ( the_token%class == t_end_of_input ) &
    exit o
      if ( the_token%class /= t_identifier ) &
        & call announce_error ( unexpected, signal_string, tree_index, &
          & expected = (/ t_identifier /) )
      call get_string ( the_token%string_index, tokenText, strip=.true. )
      if ( verbose ) then
        call output( 'token text ' // trim(tokenText), advance='yes' )
        call output( 'token text(2:) ' // tokenText(2:), advance='yes' )
        call output( '1st char ' // tokenText(1:1), advance='yes' )
        i = len_trim(tokenText)
        call output( 'its length ' , advance='no' )
        call output( i, advance='yes' )
        call output( verify(tokenText(1:1), 'CcSs'), advance='yes' )
      endif
      if ( verify(tokenText(1:1), 'CcSs') == 0 ) then
        if ( verbose ) call output( 'About to read ' //  tokenText(2:), advance='yes' )
        read ( tokenText(2:), *, iostat=status ) i
        if ( verbose ) call output( 'switch or channel: ', advance='no' )
        if ( verbose ) call output( i, advance='yes' )
        if ( status /= 0 ) &
          & call announce_error ( malformed, signal_string, tree_index )
        if ( verify(tokenText(1:1), 'Ss') == 0 ) then
          next = sawSwitch
          switch = i
          if ( verbose ) call output( 'was a switch', advance='yes' )
        else if ( verify(tokenText(1:1), 'Cc') == 0 ) then
          next = sawChannel
          numChannelNums = 1
          MyChannelNumbers(1,:) = i
          ! Process [":"<number>](("+"<number>)+[":"<number>])*
          do
            call lex_signal ( signal_string, where, the_token )
            if ( the_token%class == t_end_of_input ) &
              & exit o
            if ( the_token%class == t_colon ) then
              next = sawChannelColon
            else if ( the_token%class == t_plus ) then
              next = sawChannelPlus
            else
              call announce_error ( unexpected, signal_string, tree_index, &
                & expected = (/ t_colon, t_plus /) )
            end if
            if ( next <= sawWhat ) &
              & call announce_error ( outOfOrder, signal_string, tree_index )
            call lex_signal ( signal_string, where, the_token )
            if ( the_token%class /= t_identifier ) then
              call announce_error ( unexpected, signal_string, tree_index, &
                & expected = (/ t_identifier /) )
          exit
            end if
            call get_string ( the_token%string_index, tokenText, strip=.true. )
            if ( verbose ) call output( 'more token text ' // trim(tokenText), advance='yes' )
            read ( tokenText, *, iostat=status ) i
            if ( status /= 0 ) &
              & call announce_error ( malformed, signal_string, tree_index )
            if ( next == sawChannelColon ) then
              if ( i < myChannelNumbers(numChannelNums,1) ) &
                & call announce_error ( channelsDecrease, signal_string, &
                  & tree_index )
              myChannelNumbers(numChannelNums,2) = i
              sawWhat = sawChannelColon
            else if ( next == sawChannelplus ) then
              if ( i <= myChannelNumbers(numChannelNums,2) ) &
                & call announce_error ( channelsDecrease, signal_string, &
                  & tree_index )
              numChannelNums = numChannelNums + 1
              myChannelNumbers(numChannelNums,:) = i
              sawWhat = sawChannel
            end if
          end do
        else
          call announce_error ( notLabel, signal_string, tree_index, &
            & expected = spec_indices((/ s_band, s_radiometer, &
            &                            s_spectrometerType /)) )
        end if
      else
        if ( verify(tokenText(1:1), 'Bb') == 0 ) then
          ! Maybe we need to splice out the sideband identifier.
          ! First, try it as-is.
          decl = get_decl ( the_token%string_index, type=label )
          if ( decl%type /= label ) then
            mySideband = scan(tokenText,'UuLl')
            if ( mySideband /= 0 ) then
              the_token%string_index = &
                & enter_terminal(tokenText(:mySideband-1) // &
                & trim(tokenText(mySideband+1:)), t_identifier)
              if ( verify(tokenText(mySideband:mySideband),'Uu') == 0 ) then
                mySideband = 1
              else
                mySideband = -1
              end if
            end if
          end if
        end if
        decl = get_decl ( the_token%string_index, type=label )
        if ( decl%type /= label ) then
          call announce_error ( notLabel, signal_string, tree_index, &
            & expected = spec_indices((/ s_band, s_radiometer, &
            &                            s_spectrometerType /)) )
        else
          select case ( get_spec_id(decl%tree) )
          case ( s_band )
            next = sawBand
            band_i = decoration(decl%tree)
          case ( s_radiometer )
            next = sawRadiometer
            radiometer_i = decoration(decl%tree)
          case ( s_spectrometerType )
            next = sawSpectrometerType
            spectrometer_i = decoration(decl%tree)
          case default
            call announce_error ( notLabel, signal_string, tree_index, &
              & expected = spec_indices((/ s_band, s_radiometer, &
              &                            s_spectrometerType /)) )
          end select
        end if
      end if

      ! Verify they've come in the correct order
      if ( error == 0 .and. next <= sawWhat ) &
        & call announce_error ( outOfOrder, signal_string, tree_index )
      sawWhat = next

      ! Check for a suffix; if there is one, verify that it's OK.
      call lex_signal ( signal_string, where, the_token )
      if ( the_token%class == t_colon ) then
        call lex_signal ( signal_string, where, the_token )
        if ( the_token%class /= t_identifier ) then
          call announce_error ( unexpected, signal_string, tree_index, &
            & expected = (/ t_identifier /) )
    exit
        end if
        call get_string ( the_token%string_index, tokenText, .true., .true. )
        if ( verbose ) call output( 'even more token text ' // trim(tokenText), advance='yes' )
        select case ( next )
        case ( sawBand )           ! Band:Suffix
          call get_string ( bands(band_i)%suffix, testText, .true., .true. )
          if ( testText /= tokenText ) &
            & call announce_error ( wrongSuffix, signal_string, tree_index, &
              & expected = (/ bands(band_i)%suffix /) )
        case ( sawRadiometer )     ! Radiometer:Suffix
          call get_string ( radiometers(radiometer_i)%suffix, testText, &
            & .true., .true. )
          if ( testText /= tokenText ) &
            & call announce_error ( wrongSuffix, signal_string, tree_index, &
              & expected = (/ radiometers(radiometer_i)%suffix /) )
        case default
          call announce_error ( noSuffix, signal_string, tree_index )
        end select
        call lex_signal ( signal_string, where, the_token )
      else if ( the_token%class == t_minus ) then
        call lex_signal ( signal_string, where, the_token )
        if ( the_token%class /= t_identifier ) then
          call announce_error ( unexpected, signal_string, tree_index, &
            & expected = (/ t_identifier /) )
        else
          if ( next /= sawSpectrometerType ) &
            & call announce_error ( noSuffix, signal_string, tree_index )
          call get_string ( the_token%string_index, tokenText, strip=.true. )
          read ( tokenText, *, iostat=status ) spectrometer_n
          if ( status /= 0 ) &
            & call announce_error ( notNumber, signal_string, tree_index )
        end if
        call lex_signal ( signal_string, where, the_token )
      end if
      if ( the_token%class == t_end_of_input ) &
    exit
      if ( the_token%class /= t_dot ) &
        & call announce_error ( unexpected, signal_string, tree_index, &
          & expected = (/ t_dot /) )
    end do o

    if ( error == 0 .and. numChannelNums > 0 ) then
      call allocate_test ( myChannels, &
        & maxval(myChannelNumbers(:numChannelNums,:)), &
        & "MyChannels", moduleName, &
        & lowBound=minval(myChannelNumbers(:numChannelNums,:)) )
      myChannels = .false.
      do i = 1, numChannelNums
        myChannels(myChannelNumbers(i,1):myChannelNumbers(i,2)) = .true.
      end do
    end if
    ! Now we have all of the pieces assembled and identified.  Find the
    ! set of signals that satisfies the specified criteria.
    if ( radiometer_i < 0 .and. band_i < 0 .and. spectrometer_i < 0 ) &
      call announce_error ( notEnough, signal_string, tree_index )
    if ( error == 0 ) call scanSignals

    if ( present(sideband) ) sideband = mySideband
    if ( present(channels) ) then
      call deallocate_test ( channels, "Channels", moduleName )
      channels => myChannels
      nullify ( myChannels )
    end if
    call deallocate_test ( myChannels, "MyChannels", moduleName )

  contains

    ! -------------------------------------------  Announce_Error  -----
    subroutine Announce_Error ( code, string, tree, expected )
      integer, intent(in) :: Code         ! Code index for the error
      character(len=*), intent(in) :: String   ! The string being analyzed
      integer, intent(in), optional :: Tree         ! Tree index
      integer, intent(in), optional :: Expected(:)  ! Expected tokens

      integer :: I
      integer :: myTree

      error = max(error,1)
      myTree = 0
      if ( present(tree) ) myTree = tree
      call output ( '***** At ' )
      if ( mytree > 0 ) then
        call print_source ( where_at(mytree) )
      else
        call output ( '(no lcf tree available)' )
      end if
      call output ( ', ' )
      call output ( 'In column ' )
      call output ( where )
      call output ( ' of ' )
      call output ( trim(string) )
      call output ( ', ' )
      select case ( code )
      case ( channelsDecrease )
        call output ( 'the channel numbers are not monotone nondecreasing', &
          & advance='yes' )
      case ( invalid )
        call output ( 'does not specify a valid signal.', advance='yes' )
      case ( malformed )
        call output ( 'expected digits after the first letter.', advance='yes' )
      case ( outOfOrder )
        call output ( 'the token is out-of-order.', advance='yes' )
      case ( noSuffix )
        call output ( 'a suffix is not permitted at this point.', advance='yes' )
      case ( notEnough )
        call output ( 'not enough information given.', advance='yes' )
      case ( notLabel )
        call output ( 'the token is not the label of a ' )
        do i = 1, size(expected)
          call output ( '"' )
          call display_string ( expected(i) )
          call output ( '", ' )
        end do
        call output ( '"switch" or "channel".', advance='yes' )
      case ( notNumber )
        call output ( 'expected a number.', advance='yes' )
      case ( unexpected )
        call output ( 'the input was incorrect.  Expected ' )
        do i = 1, size(expected)
          call dump_symbol_class ( expected(i) )
          if ( size(expected) > 1 ) then
            if ( i < size(expected) - 1 ) call output ( ', ' )
            if ( i == size(expected) - 1 ) call output ( ' or ' )
          end if
        end do
        call output ( '.', advance='yes' )
      case ( wrongSuffix )
        call output ( 'the wrong suffix is specified' )
        if ( present(expected) ) then
          call output ( '.  Expected' )
          do i = 1, size(expected)
            call display_string ( expected(i), before=' ' )
          end do
        end if
        call output ('.', advance='yes' )
      case default
        call output ( 'No code for error code ' )
        call output ( code )
        call output ( ' in Parse_signal_m%Announce_Error', advance='yes' )
      end select
    end subroutine Announce_Error

    ! ----------------------------------------------  ScanSignals  -----
    subroutine ScanSignals
      ! Scan the signals database for entries that satisfy the criteria
      ! given by the tokens in the signal string.
      ! Allocate Signal_Indices and fill the array.

      logical :: BandMatch(size(signals))
      logical :: ChannelMatch(size(signals))
      integer :: HowMany
      integer :: I
      logical :: RadiometerMatch(size(signals))
      integer :: Spectrometer           ! Index from the signals database
      logical :: SpectrometerMatch(size(signals))
      logical :: SpectrometerTypeMatch(size(signals))
      logical :: SwitchMatch(size(signals))

      ! Initialize
      bandMatch = band_i < 0
      channelMatch = numChannelNums <= 0
      radiometerMatch = radiometer_i < 0
      spectrometerMatch = spectrometer_n < 0
      spectrometerTypeMatch = spectrometer_i < 0
      switchMatch = switch < 0

      do i = 1, size(signals)
        spectrometer = signals(i)%spectrometerType
        if ( band_i >= 0 ) bandMatch(i) = band_i == signals(i)%band
        if ( numChannelNums > 0 ) &
          & channelMatch(i) = &
            & lbound(myChannels,1) >= lbound(signals(i)%frequencies,1) .and. &
            & ubound(myChannels,1) <= ubound(signals(i)%frequencies,1)
        if ( radiometer_i >= 0 ) radiometerMatch(i) = &
          & radiometer_i == signals(i)%radiometer
        if ( spectrometer_n >= 0 ) spectrometerMatch(i) = &
          & spectrometer_n ==signals(i)%spectrometer
        if ( spectrometer_i >= 0 ) spectrometerTypeMatch(i) = &
          & spectrometer_i == spectrometer
        if ( switch >= 0 ) switchMatch(i) = switch ==signals(i)%switch
      end do
      howMany = count ( bandMatch .and. channelMatch .and. radiometerMatch &
        & .and. spectrometerMatch .and. SpectrometerTypeMatch .and. &
        & switchMatch )
      if ( present(onlyCountEm) ) onlyCountEm = howMany
      if ( howMany == 0 ) then
        where = 1
        call announce_error ( invalid, signal_string, tree_index )
      else if ( .not. present(onlyCountEm) ) then
        call allocate_test ( signal_indices, howMany, 'Signal_Indices', &
          & moduleName )
        howMany = 0
        do i = 1, size(signals)
          if ( bandMatch(i) .and. channelMatch(i) .and. radiometerMatch(i) &
          & .and. spectrometerMatch(i) .and. SpectrometerTypeMatch(i) .and. &
          & switchMatch(i) ) then
            howMany = howMany + 1
            signal_indices(howMany) = i
          end if
        end do
      end if
    end subroutine ScanSignals

  end subroutine Parse_Signal

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Parse_Signal_m.f90,v 2.27 2016/07/25 23:39:49 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Parse_Signal_M

! $Log: Parse_Signal_m.f90,v $
! Revision 2.27  2016/07/25 23:39:49  pwagner
! Begin allowing extra output in response to verbose setting
!
! Revision 2.26  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.25  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.24  2006/07/29 01:36:33  vsnyder
! Put the arguments to [de]Allocate_Test in the correct order
!
! Revision 2.23  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.22  2005/05/02 22:58:24  vsnyder
! Modify interface for Get_Individual_Signals
!
! Revision 2.21  2005/03/24 01:38:36  vsnyder
! Spiff up an error message
!
! Revision 2.20  2005/02/05 00:05:07  vsnyder
! Correct the low bound for channels in Expand_signal_list.  Handle
! disassociated channels argument from parse_signal correctly in
! Get_Individual_Signals.  Move CVS Id into not_used_here.  Some
! cannonball polishing.
!
! Revision 2.19  2005/01/12 23:58:47  vsnyder
! All in Get_Individual_Sgnals: Detect DSB signals correctly.  Correct an
! indexing error.  Include the channel.
!
! Revision 2.18  2005/01/12 03:08:38  vsnyder
! Add Get_Individual_Signals
!
! Revision 2.17  2004/03/24 22:45:59  livesey
! Increased buffer sizes
!
! Revision 2.16  2003/05/05 23:00:05  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.15  2003/03/07 03:17:28  livesey
! Added Expand_Signal_List
!
! Revision 2.14.2.1  2003/03/01 02:40:04  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.14  2003/01/25 04:14:13  vsnyder
! Get rid of USEs for stuff not actually used
!
! Revision 2.13  2002/11/06 00:13:32  pwagner
! Should not dump core if parse_signal called with tree_index 0
!
! Revision 2.12  2002/10/08 00:09:13  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.11  2001/06/07 21:59:41  pwagner
! Added Copyright statement
!
! Revision 2.10  2001/04/26 02:33:03  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.9  2001/04/13 20:58:48  vsnyder
! Add 'OnlyCountEm' argument
!
! Revision 2.8  2001/04/11 20:19:46  vsnyder
! Look for channels in signals instead of spectrometers
!
! Revision 2.7  2001/04/11 02:10:45  vsnyder
! Fix a typo
!
! Revision 2.6  2001/04/10 17:59:54  vsnyder
! Remove sideband field from signal
!
! Revision 2.5  2001/04/09 20:15:53  vsnyder
! Tighter bound on myChannelNumbers
!
! Revision 2.4  2001/04/06 20:15:36  vsnyder
! Implement syntax for specifying several channels
!
! Revision 2.3  2001/03/16 00:34:50  vsnyder
! Correct handling of the Band database
!
! Revision 2.2  2001/03/15 23:57:27  vsnyder
! OOPS, forgot to put 'Log' at the end
!
@


2.27
log
@Begin allowing extra output in response to verbose setting
@
text
@d256 1
d263 1
d304 1
a328 2
    
    logical, parameter :: verbose = .false.
d343 1
d491 1
a491 1
              & expected = (/ the_token%string_index /) )
d497 1
a497 1
              & expected = (/ the_token%string_index /) )
d610 8
a617 1
        call output ('the wrong suffix is specified.', advance='yes' )
d691 1
a691 1
       "$Id: Parse_Signal_m.f90,v 2.26 2013/09/24 23:27:14 vsnyder Exp $"
d701 3
@


2.26
log
@Use Get_Where or Print_Source to start error messages
@
text
@d48 5
a52 5
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use MLSSignals_m, only: SIGNALS, SIGNAL_T, DESTROYSIGNALDATABASE
    use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ALLOCATE, MLSMSG_ERROR
    use Tree, only: SUBTREE, SUB_ROSA, NSONS
    use String_table, only: GET_STRING
d326 2
d343 3
a345 1

d355 9
d365 1
d367 2
d374 1
d383 1
a383 1
    exit o
d401 1
d483 1
d682 1
a682 1
       "$Id: Parse_Signal_m.f90,v 2.25 2009/06/23 18:25:42 pwagner Exp $"
d692 3
@


2.25
log
@Prevent Intel from optimizing ident string away
@
text
@d36 1
a36 1
       "$RCSfile: $"
d262 1
a262 1
    use Tree, only: Decoration, Source_Ref
d544 1
a544 1
        call print_source ( source_ref(mytree) )
d663 1
a663 1
       "$Id: read_apriori.f90 is it here $"
d673 3
@


2.24
log
@Put the arguments to [de]Allocate_Test in the correct order
@
text
@d36 1
a36 1
       "$RCSfile: Parse_Signal_m.f90,v $"
d660 1
a661 1
!---------------------------- RCS Ident Info -------------------------------
d663 2
a664 3
       "$Id: Parse_Signal_m.f90,v 2.23 2005/06/22 17:25:50 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d666 1
d668 1
d673 3
@


2.23
log
@Reworded Copyright statement, moved rcs id
@
text
@d36 1
a36 1
       "$RCSfile: $"
d336 1
a336 1
    call deallocate_test ( signal_indices, moduleName, "Signal_Indices" )
d644 2
a645 2
        call allocate_test ( signal_indices, howMany, moduleName, &
          & 'signal_indices' )
d663 1
a663 1
       "$Id: $"
d672 3
@


2.22
log
@Modify interface for Get_Individual_Signals
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d34 3
a36 3
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: Parse_Signal_m.f90,v $"
d38 1
a38 1
  !---------------------------------------------------------------------------
d661 5
a665 5
    !---------------------------- RCS Ident Info -------------------------------
    character (len=*), parameter :: IdParm = &
      & "$Id: Parse_Signal_m.f90,v 2.21 2005/03/24 01:38:36 vsnyder Exp $"
    character (len=len(idParm)) :: Id = idParm
    !---------------------------------------------------------------------------
d672 3
@


2.21
log
@Spiff up an error message
@
text
@d19 1
a19 1
! Get_Individual_Signals ( char* inSignals[], char* outSignals[] )
d111 7
a117 6
  subroutine Get_Individual_Signals ( InSignals, OutSignals )
  ! Given InSignals, create OutSignals where each of OutSignals is a
  ! signal denoted in InSignals, but describes exactly one radiometer,
  ! band, switch, spectrometer, sideband and channel.  OutSignals is
  ! allocated using Allocate_Test, so don't send in an undefined pointer!
  ! There will be no duplicates in OutSignals.  Zero-size InSignals works.
d121 1
a121 1
    use MLSSignals_m, only: GetSignalName, Signals
d123 1
a124 1
    character(len=*), intent(in) :: InSignals(:)
d126 2
d130 1
a130 1
    integer :: I, J, K, L
d132 1
d139 8
a146 2
    do i = 1, size(inSignals)
      call parse_signal ( inSignals(i), signalIndices, sideband=sideband, &
d149 1
a149 1
        & moduleName, 'Unable to parse signal ' // trim(inSignals(i)) )
d163 1
a163 1
    end do ! i = 1, size(inSignals)
d168 6
a173 2
      do i = 1, size(inSignals)
        call parse_signal ( inSignals(i), signalIndices, sideband=sideband, &
d201 1
a201 1
      end do ! i = 1, size(inSignals)
d655 1
a655 1
      & "$Id: Parse_Signal_m.f90,v 2.20 2005/02/05 00:05:07 vsnyder Exp $"
d664 3
@


2.20
log
@Correct the low bound for channels in Expand_signal_list.  Handle
disassociated channels argument from parse_signal correctly in
Get_Individual_Signals.  Move CVS Id into not_used_here.  Some
cannonball polishing.
@
text
@d520 1
a520 1
      call output ( 'At ' )
d641 1
a641 1
      & "$Id: Parse_Signal_m.f90,v 2.19 2005/01/12 23:58:47 vsnyder Exp $"
d650 6
@


2.19
log
@All in Get_Individual_Sgnals: Detect DSB signals correctly.  Correct an
indexing error.  Include the channel.
@
text
@d12 3
a14 1
! Parse_Signal                   Return database indices matching signal string
d18 4
a21 2
! Parse_Signal  ( char* Signal_String, *int Signal_Indices(:),
!    [int Tree_Index], [int Sideband],[*log Channels(:)], [int OnlyCountEm] )
d23 1
a26 3
  character (len=*), parameter, private :: IdParm = &
    & "$Id: Parse_Signal_m.f90,v 2.18 2005/01/12 03:08:38 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d57 1
d72 2
a73 2
      call get_string ( sub_rosa(subtree(j+1,node)), signalString, &
        & strip=.true.)
d75 1
a75 1
        & tree_index=node, sideband=sideband, channels=channels )
d84 1
a84 1
      wanted=1
d91 2
a92 2
        & size(theseSignals(j)%frequencies), 'signals%channels', &
        & ModuleName )
d94 1
a94 1
        ! The reason that this is so messy that channels has l/u bounds
d96 1
a96 1
        theseSignals(j)%channels(1:lbound(channels,1)-1) = .false.
d119 1
d138 9
a146 1
      k = count(channels)
d161 9
d499 3
a501 7
      if ( associated(channels) ) &
        & call deallocate_test ( channels, "Channels", moduleName )
      if ( associated(myChannels) ) then
        call allocate_test ( channels, ubound(myChannels,1), "Channels", &
          & moduleName, lowBound=lbound(myChannels,1) )
        channels = myChannels
      end if
d503 1
a503 2
    if ( associated(myChannels) ) &
      & call deallocate_test ( myChannels, "MyChannels", moduleName )
d639 5
d650 4
@


2.18
log
@Add Get_Individual_Signals
@
text
@d23 1
a23 1
    & "$Id: Parse_Signal_m.f90,v 2.17 2004/03/24 22:45:59 livesey Exp $"
d138 1
a138 1
        if ( sideband == 0 .and. signals(signalIndices(j))%singleSideband /= 0 ) &
d145 1
d153 3
a155 2
              if ( sideband == 0 .and. signals(signalIndices(j))%singleSideband /= 0 ) then
                call getSignalName ( signalIndices(j), mySignals(l), sideband=-1 )
d157 2
a158 1
                call getSignalName ( signalIndices(j), mySignals(l), sideband=+1 )
d160 2
a161 1
                call getSignalName ( signalIndices(j), mySignals(l), sideband=sideband )
d629 3
@


2.17
log
@Increased buffer sizes
@
text
@d19 1
a19 1
  public :: Parse_Signal, Expand_Signal_List
d23 1
a23 1
    & "$Id: Parse_Signal_m.f90,v 2.16 2003/05/05 23:00:05 livesey Exp $"
d32 1
a32 1
  ! ----------------------------------------- Expand_signal_list ---
d107 84
a190 1
  ! ------------------------------------------ Parse_signal --------
d625 3
@


2.16
log
@Merged in feb03 newfwm branch
@
text
@d23 1
a23 1
    & "$Id$"
d26 1
a26 1
    & "$RCSfile$"
d169 1
a169 1
    character(len=5) :: TestText   ! From a "%suffix" field via sub_rosa
d171 1
a171 1
    character(len=5) :: TokenText  ! Duh
d541 4
a544 1
! $Log$
@


2.15
log
@Added Expand_Signal_List
@
text
@a5 16
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Declaration_Table, only: Decls, Get_Decl, Label
  use Init_MLSSignals_m, only: S_Band, S_Radiometer, S_SpectrometerType
  use Intrinsic, only: Spec_Indices
  use Lexer_Core, only: Print_Source, Token
  use Lexer_m, only: Lex_Signal
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_ALLOCATE
  use MLSSignals_m, only: Bands, Radiometers, Signals, Signal_T, DESTROYSIGNALDATABASE
  use MoreTree, only: Get_Spec_ID
  use Output_m, only: Output
  use String_table, only: Display_string, Get_String
  use Symbol_Table, only: Dump_Symbol_Class, Enter_Terminal
  use Symbol_Types, only: T_Colon, T_Dot, T_End_of_input, T_Identifier, &
    & T_Minus, T_Plus
  use Tree, only: Decoration, Source_Ref, NSONS, SUBTREE, SUB_ROSA

d23 1
a23 1
    & "$Id: Parse_Signal_m.f90,v 2.14 2003/01/25 04:14:13 vsnyder Exp $"
d26 1
a26 1
    & "$RCSfile: Parse_Signal_m.f90,v $"
d38 6
d119 15
d476 1
a476 1
      ! Allocate Signal_Indices , and fill the array.
d541 7
a547 1
! $Log: Parse_Signal_m.f90,v $
@


2.14
log
@Get rid of USEs for stuff not actually used
@
text
@d12 2
a13 1
  use MLSSignals_m, only: Bands, Radiometers, Signals
d20 1
a20 1
  use Tree, only: Decoration, Source_Ref
d35 1
a35 1
  public :: Parse_Signal
d39 1
a39 1
    & "$Id: Parse_Signal_m.f90,v 2.13 2002/11/06 00:13:32 pwagner Exp $"
d48 71
d537 3
@


2.14.2.1
log
@Move USE statements from module scope to procedure scope
@
text
@d6 15
d38 1
a38 1
    & "$Id: Parse_Signal_m.f90,v 2.14 2003/01/25 04:14:13 vsnyder Exp $"
a56 15
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Declaration_Table, only: Decls, Get_Decl, Label
    use Init_MLSSignals_m, only: S_Band, S_Radiometer, S_SpectrometerType
    use Intrinsic, only: Spec_Indices
    use Lexer_Core, only: Print_Source, Token
    use Lexer_m, only: Lex_Signal
    use MLSSignals_m, only: Bands, Radiometers, Signals
    use MoreTree, only: Get_Spec_ID
    use Output_m, only: Output
    use String_table, only: Display_string, Get_String
    use Symbol_Table, only: Dump_Symbol_Class, Enter_Terminal
    use Symbol_Types, only: T_Colon, T_Dot, T_End_of_input, T_Identifier, &
      & T_Minus, T_Plus
    use Tree, only: Decoration, Source_Ref

d399 1
a399 1
      ! Allocate Signal_Indices and fill the array.
a464 3
! Revision 2.14  2003/01/25 04:14:13  vsnyder
! Get rid of USEs for stuff not actually used
!
@


2.13
log
@Should not dump core if parse_signal called with tree_index 0
@
text
@d8 1
a8 2
  use Init_MLSSignals_m, only: S_Band, S_Module, S_Radiometer, S_Signal, &
    & S_SpectrometerType, Spec_First
d12 1
a12 1
  use MLSSignals_m, only: Bands, Radiometers, Signals, SpectrometerTypes
d38 1
a38 1
    & "$Id: Parse_Signal_m.f90,v 2.12 2002/10/08 00:09:13 pwagner Exp $"
d465 3
@


2.12
log
@Added idents to survive zealous Lahey optimizer
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d24 11
d39 1
a39 1
    & "$Id: Parse_Signal_m.f90,v 2.11 2001/06/07 21:59:41 pwagner Exp $"
d336 1
d339 7
a345 4
      if ( present(tree) ) then
        call output ( 'At ' )
        call print_source ( source_ref(tree) )
        call output ( ', ' )
d347 1
d466 3
@


2.11
log
@Added Copyright statement
@
text
@d28 1
a28 1
    & "$Id: Parse_Signal_m.f90,v 2.10 2001/04/26 02:33:03 vsnyder Exp $"
d32 1
d443 4
d450 3
@


2.10
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d1 3
d28 1
a28 1
    & "$Id: Parse_Signal_m.f90,v 2.9 2001/04/13 20:58:48 vsnyder Exp $"
d445 3
@


2.9
log
@Add 'OnlyCountEm' argument
@
text
@d7 1
d25 1
a25 1
    & "$Id: Parse_Signal_m.f90,v 2.8 2001/04/11 20:19:46 vsnyder Exp $"
d33 1
a33 1
  subroutine Parse_Signal ( Signal_String, Signal_Indices, Spec_indices, &
a47 2
    integer, intent(in) :: Spec_indices(spec_first:)   ! Indices in string
    !                                               table; For error messages
d442 3
@


2.8
log
@Look for channels in signals instead of spectrometers
@
text
@d24 1
a24 1
    & "$Id: Parse_Signal_m.f90,v 2.7 2001/04/11 02:10:45 vsnyder Exp $"
d33 1
a33 1
    & Tree_Index, Sideband, Channels )
d43 4
a46 4
    integer, pointer :: Signal_Indices(:)         ! In the signals database
    ! They are allocated here using Allocate_Test, so don't start with an
    ! undefined pointer!  Upon return, if Signal_Indices is not associated,
    ! an error occurred.
d59 3
d419 1
d423 1
a423 1
      else
d443 3
@


2.7
log
@Fix a typo
@
text
@d24 1
a24 1
    & "$Id: Parse_Signal_m.f90,v 2.6 2001/04/10 17:59:54 vsnyder Exp $"
d402 3
a404 4
          & channelMatch(i) = lbound(myChannels,1) >= &
            & lbound(spectrometerTypes(spectrometer)%frequencies,1) .and. &
            & ubound(myChannels,1) <= &
            & ubound(spectrometerTypes(spectrometer)%frequencies,1)
d439 3
@


2.6
log
@Remove sideband field from signal
@
text
@d24 1
a24 1
    & "$Id: Parse_Signal_m.f90,v 2.5 2001/04/09 20:15:53 vsnyder Exp $"
d404 1
a404 1
            & ubound(myCHannels,1) <= &
d440 3
@


2.5
log
@Tighter bound on myChannelNumbers
@
text
@d24 1
a24 1
    & "$Id: Parse_Signal_m.f90,v 2.4 2001/04/06 20:15:36 vsnyder Exp $"
d291 1
a291 1
    ! set of signals that satisfy the specified criteria.
d298 1
a298 1
      if ( associated(channels ) ) &
d300 5
a304 3
      call allocate_test ( channels, ubound(myChannels,1), "Channels", &
        & moduleName, lowBound=lbound(myChannels,1) )
      channels = myChannels
d440 3
@


2.4
log
@Implement syntax for specifying several channels
@
text
@d24 1
a24 1
    & "$Id: Parse_Signal_m.f90,v 2.3 2001/03/16 00:34:50 vsnyder Exp $"
d64 1
a64 1
    integer, dimension(len(signal_string),2) :: MyChannelNumbers
d438 3
@


2.3
log
@Correct handling of the Band database
@
text
@d13 1
a13 1
  use Symbol_Table, only: Dump_symbol_class
d15 1
a15 1
    & T_Minus
d24 1
a24 1
    & "$Id: Parse_Signal_m.f90,v 2.2 2001/03/15 23:57:27 vsnyder Exp $"
d33 1
a33 1
    & Tree_Index )
d35 6
a40 2
  ! Parse a signal string.  Return the index of the signal in the signal
  ! database.
d51 8
a60 1
    integer :: Channel        ! Channel number, from the token text
d64 3
d69 1
d89 2
d93 2
a94 1
    integer, parameter :: Invalid = 1                ! Invalid combination
a105 1
    channel = -1
d107 2
d110 1
d120 1
a120 1
    do
d123 1
a123 1
    exit
d137 42
a178 1
          channel = i
d185 18
d230 1
d236 2
a237 2
        if ( the_token%class /= t_identifier ) &
          & call announce_error ( unexpected, signal_string, tree_index, &
d239 2
d243 1
a243 1
        case ( sawBand )
d248 1
a248 1
        case ( sawRadiometer )
d278 1
a278 1
    end do
d280 10
d296 11
d330 3
d334 1
a334 1
        call output ( 'does not specify a valid signal.', 'yes' )
d336 1
a336 1
        call output ( 'expected digits after the first letter.', 'yes' )
d338 1
a338 1
        call output ( 'the token is out-of-order.', 'yes' )
d340 1
a340 1
        call output ( 'a suffix is not permitted at this point.', 'yes' )
d342 1
a342 1
        call output ( 'not enough information given.', 'yes' )
d350 1
a350 1
        call output ( '"switch" or "channel".', advance = 'yes' )
d352 1
a352 1
        call output ( 'expected a number.', 'yes' )
d362 7
a368 1
        call output ( '.', advance = 'yes' )
d390 1
a390 1
      channelMatch = channel < 0
d399 5
a403 3
        if ( channel >= 0 ) channelMatch(i) = &
          & channel >= lbound(spectrometerTypes(spectrometer)%frequencies,1) .and. &
          & channel <= ubound(spectrometerTypes(spectrometer)%frequencies,1)
d438 3
@


2.2
log
@OOPS, forgot to put 'Log' at the end
@
text
@d10 1
d16 1
a16 1
  use Tree, only: Decoration, Source_Ref, Subtree
d24 1
a24 1
    & "$Id: Parse_Signal_m.f90,v 2.1 2001/03/15 23:40:22 vsnyder Exp $"
d130 1
a130 1
          select case ( decoration(subtree(1,decoration(subtree(1,decl%tree)))) )
a284 1
!       spectrometer = decoration(decoration(signals(i)%spectrometerType))
d286 1
a286 2
        if ( band_i >= 0 ) bandMatch(i) = &
          & band_i == decoration(decoration(signals(i)%band))
a289 2
!       if ( radiometer_i >= 0 ) radiometerMatch(i) = &
!         & radiometer_i == decoration(decoration(signals(i)%radiometer))
d323 4
a326 1
! $Log: $
@


2.1
log
@Initial commit.
@
text
@d23 1
a23 1
    & "$Id: RetrievalModule.f90,v 2.9 2001/03/09 03:05:05 vsnyder Exp $"
d26 1
a26 1
    & "$RCSfile: RetrievalModule.f90,v $"
d325 2
@

