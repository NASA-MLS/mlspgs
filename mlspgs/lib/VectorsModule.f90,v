head	2.212;
access;
symbols
	v5-02-NRT-19:2.212
	v6-00:2.212
	v5-02-NRT-18:2.212
	v5-02:2.210
	v5-01-NRT-17:2.212
	v5-01-NRT-16:2.212
	v5-01-NRT-15:2.212
	v5-01-NRT-14:2.211
	neuralnetworks-1-0:2.210.0.8
	cfm-single-freq-0-1:2.210.0.6
	v5-01:2.210
	v5-00:2.210
	v4-23-TA133:2.210.0.4
	mus-emls-1-70:2.210.0.2
	rel-1-0-englocks-work:2.209.0.2
	VUMLS1-00:2.207
	VPL1-00:2.206
	V4-22-NRT-08:2.204
	VAM1-00:2.203
	V4-21:2.195.0.2
	V4-13:2.193
	V4-12:2.190
	V4-11:2.189
	V4-10:2.188
	V3-43:2.146
	M4-00:2.175
	V3-41:2.146
	V3-40-PlusGM57:2.146.0.2
	V2-24-NRT-04:2.131
	V3-33:2.150
	V2-24:2.131
	V3-31:2.150
	V3-30-NRT-05:2.150
	cfm-01-00:2.150
	V3-30:2.146
	V3-20:2.146
	V3-10:2.142
	V2-23-NRT-02:2.131
	V2-23:2.131
	V2-22-NRT-01:2.131
	V2-22:2.131
	V2-21:2.126
	V2-20:2.126
	V2-11:2.124
	V2-10:2.124
	V2-00:2.123
	V1-51:2.114
	V1-50:2.114
	V1-45:2.112
	V1-44:2.112
	V1-43:2.109
	V1-42:2.105
	V1-41:2.105
	V1-32:2.105
	V1-40:2.105
	V1-31:2.105
	V1-30:2.103
	V1-13:2.94
	V1-12:2.94
	V1-11:2.94
	V1-10:2.94
	newfwm-feb03:2.94.0.2
	V1-04:2.81
	V1-03:2.81
	V1-02:2.81
	V1-00:2.80
	newfwm-sep01:2.49.0.2
	V0-7:2.49
	V0-5-Level2:2.37
	V0-5-SIPS:2.22
	V0_1:1.11;
locks; strict;
comment	@# @;


2.212
date	2021.08.20.15.56.38;	author pwagner;	state Exp;
branches;
next	2.211;

2.211
date	2021.06.10.23.43.11;	author pwagner;	state Exp;
branches;
next	2.210;

2.210
date	2018.05.11.21.26.27;	author pwagner;	state Exp;
branches;
next	2.209;

2.209
date	2018.02.27.00.50.33;	author livesey;	state Exp;
branches;
next	2.208;

2.208
date	2017.11.03.19.57.59;	author pwagner;	state Exp;
branches;
next	2.207;

2.207
date	2016.11.15.19.29.55;	author pwagner;	state Exp;
branches;
next	2.206;

2.206
date	2016.07.28.01.42.27;	author vsnyder;	state Exp;
branches;
next	2.205;

2.205
date	2016.05.27.00.14.05;	author vsnyder;	state Exp;
branches;
next	2.204;

2.204
date	2016.04.13.00.47.18;	author vsnyder;	state Exp;
branches;
next	2.203;

2.203
date	2015.09.24.18.46.09;	author pwagner;	state Exp;
branches;
next	2.202;

2.202
date	2015.09.17.22.55.23;	author pwagner;	state Exp;
branches;
next	2.201;

2.201
date	2015.07.14.23.20.47;	author pwagner;	state Exp;
branches;
next	2.200;

2.200
date	2015.06.19.00.35.49;	author pwagner;	state Exp;
branches;
next	2.199;

2.199
date	2015.06.04.01.57.16;	author vsnyder;	state Exp;
branches;
next	2.198;

2.198
date	2015.05.01.02.09.28;	author vsnyder;	state Exp;
branches;
next	2.197;

2.197
date	2015.04.29.00.53.56;	author vsnyder;	state Exp;
branches;
next	2.196;

2.196
date	2015.03.28.01.47.29;	author vsnyder;	state Exp;
branches;
next	2.195;

2.195
date	2014.11.08.01.05.15;	author pwagner;	state Exp;
branches;
next	2.194;

2.194
date	2014.10.02.22.08.35;	author vsnyder;	state Exp;
branches;
next	2.193;

2.193
date	2014.09.05.00.20.54;	author vsnyder;	state Exp;
branches;
next	2.192;

2.192
date	2014.09.04.20.23.41;	author pwagner;	state Exp;
branches;
next	2.191;

2.191
date	2014.08.19.00.29.59;	author vsnyder;	state Exp;
branches;
next	2.190;

2.190
date	2014.07.18.23.13.24;	author pwagner;	state Exp;
branches;
next	2.189;

2.189
date	2014.05.20.23.53.19;	author vsnyder;	state Exp;
branches;
next	2.188;

2.188
date	2014.02.01.00.16.43;	author pwagner;	state Exp;
branches;
next	2.187;

2.187
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.186;

2.186
date	2013.10.25.23.05.42;	author pwagner;	state Exp;
branches;
next	2.185;

2.185
date	2013.09.27.00.41.14;	author pwagner;	state Exp;
branches;
next	2.184;

2.184
date	2013.09.25.00.58.15;	author pwagner;	state Exp;
branches;
next	2.183;

2.183
date	2013.09.24.23.27.14;	author vsnyder;	state Exp;
branches;
next	2.182;

2.182
date	2013.08.17.00.17.24;	author pwagner;	state Exp;
branches;
next	2.181;

2.181
date	2013.08.16.02.28.38;	author vsnyder;	state Exp;
branches;
next	2.180;

2.180
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.179;

2.179
date	2013.07.13.00.00.15;	author vsnyder;	state Exp;
branches;
next	2.178;

2.178
date	2013.06.12.02.14.37;	author vsnyder;	state Exp;
branches;
next	2.177;

2.177
date	2013.05.22.20.24.21;	author pwagner;	state Exp;
branches;
next	2.176;

2.176
date	2013.05.16.18.16.58;	author pwagner;	state Exp;
branches;
next	2.175;

2.175
date	2013.03.15.00.01.31;	author pwagner;	state Exp;
branches;
next	2.174;

2.174
date	2013.02.21.21.21.42;	author pwagner;	state Exp;
branches;
next	2.173;

2.173
date	2013.02.01.23.40.55;	author vsnyder;	state Exp;
branches;
next	2.172;

2.172
date	2012.12.04.00.11.55;	author pwagner;	state Exp;
branches;
next	2.171;

2.171
date	2012.11.09.00.59.08;	author pwagner;	state Exp;
branches;
next	2.170;

2.170
date	2012.10.30.22.07.28;	author pwagner;	state Exp;
branches;
next	2.169;

2.169
date	2012.10.29.17.42.31;	author pwagner;	state Exp;
branches;
next	2.168;

2.168
date	2012.10.11.21.01.02;	author pwagner;	state Exp;
branches;
next	2.167;

2.167
date	2012.07.31.00.33.40;	author vsnyder;	state Exp;
branches;
next	2.166;

2.166
date	2012.07.10.03.55.49;	author vsnyder;	state Exp;
branches;
next	2.165;

2.165
date	2012.07.07.02.40.47;	author vsnyder;	state Exp;
branches;
next	2.164;

2.164
date	2012.07.07.02.02.34;	author vsnyder;	state Exp;
branches;
next	2.163;

2.163
date	2012.05.24.20.32.56;	author vsnyder;	state Exp;
branches;
next	2.162;

2.162
date	2012.04.20.01.26.38;	author vsnyder;	state Exp;
branches;
next	2.161;

2.161
date	2012.03.28.00.55.22;	author vsnyder;	state Exp;
branches;
next	2.160;

2.160
date	2012.02.23.00.08.55;	author vsnyder;	state Exp;
branches;
next	2.159;

2.159
date	2012.02.13.23.21.47;	author pwagner;	state Exp;
branches;
next	2.158;

2.158
date	2012.01.09.22.30.42;	author pwagner;	state Exp;
branches;
next	2.157;

2.157
date	2011.12.17.00.37.32;	author vsnyder;	state Exp;
branches;
next	2.156;

2.156
date	2011.11.11.00.32.29;	author vsnyder;	state Exp;
branches;
next	2.155;

2.155
date	2011.11.01.22.55.48;	author honghanh;	state Exp;
branches;
next	2.154;

2.154
date	2011.10.25.18.08.07;	author pwagner;	state Exp;
branches;
next	2.153;

2.153
date	2011.08.02.16.51.40;	author honghanh;	state Exp;
branches;
next	2.152;

2.152
date	2011.03.15.22.49.35;	author pwagner;	state Exp;
branches;
next	2.151;

2.151
date	2011.03.02.02.15.25;	author vsnyder;	state Exp;
branches;
next	2.150;

2.150
date	2010.05.24.14.48.04;	author honghanh;	state Exp;
branches;
next	2.149;

2.149
date	2010.04.28.00.12.20;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2010.04.22.23.38.57;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2010.02.25.18.07.14;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.145;

2.145
date	2009.10.27.23.28.46;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2009.10.27.22.16.38;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2009.10.26.17.08.44;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2009.06.23.18.25.43;	author pwagner;	state Exp;
branches;
next	2.141;

2.141
date	2009.06.16.17.17.55;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2009.05.08.00.39.07;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2009.04.30.22.14.25;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2009.01.16.23.30.58;	author vsnyder;	state Exp;
branches;
next	2.137;

2.137
date	2008.12.17.02.57.28;	author vsnyder;	state Exp;
branches;
next	2.136;

2.136
date	2008.11.24.19.36.57;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2008.11.06.21.51.08;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2008.08.27.19.58.30;	author vsnyder;	state Exp;
branches;
next	2.133;

2.133
date	2008.06.09.20.33.59;	author vsnyder;	state Exp;
branches;
next	2.132;

2.132
date	2008.06.05.02.06.06;	author vsnyder;	state Exp;
branches;
next	2.131;

2.131
date	2007.10.09.16.45.02;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2007.10.09.00.29.42;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2007.10.06.00.01.28;	author vsnyder;	state Exp;
branches;
next	2.128;

2.128
date	2007.10.03.20.51.18;	author vsnyder;	state Exp;
branches;
next	2.127;

2.127
date	2007.04.03.17.41.58;	author vsnyder;	state Exp;
branches;
next	2.126;

2.126
date	2006.08.05.02.11.58;	author vsnyder;	state Exp;
branches;
next	2.125;

2.125
date	2006.08.03.01.10.06;	author vsnyder;	state Exp;
branches;
next	2.124;

2.124
date	2006.07.27.03.55.56;	author vsnyder;	state Exp;
branches;
next	2.123;

2.123
date	2006.06.06.18.54.48;	author vsnyder;	state Exp;
branches;
next	2.122;

2.122
date	2006.05.23.21.43.34;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2006.03.22.02.16.28;	author vsnyder;	state Exp;
branches;
next	2.120;

2.120
date	2006.02.23.00.55.28;	author vsnyder;	state Exp;
branches;
next	2.119;

2.119
date	2006.01.21.00.03.12;	author livesey;	state Exp;
branches;
next	2.118;

2.118
date	2005.09.02.20.33.22;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2005.06.22.17.25.51;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2005.03.03.02.14.01;	author vsnyder;	state Exp;
branches;
next	2.115;

2.115
date	2005.01.07.00.36.51;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2004.10.19.02.21.20;	author livesey;	state Exp;
branches;
next	2.113;

2.113
date	2004.10.07.23.12.19;	author vsnyder;	state Exp;
branches;
next	2.112;

2.112
date	2004.06.16.22.31.28;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2004.06.16.01.18.39;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2004.06.10.00.57.47;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2004.05.01.04.07.44;	author vsnyder;	state Exp;
branches;
next	2.108;

2.108
date	2004.01.30.23.27.59;	author livesey;	state Exp;
branches;
next	2.107;

2.107
date	2004.01.24.01.03.04;	author livesey;	state Exp;
branches;
next	2.106;

2.106
date	2004.01.23.05.36.51;	author livesey;	state Exp;
branches;
next	2.105;

2.105
date	2003.09.15.23.28.50;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2003.09.15.17.45.37;	author livesey;	state Exp;
branches;
next	2.103;

2.103
date	2003.08.27.20.06.42;	author livesey;	state Exp;
branches;
next	2.102;

2.102
date	2003.06.20.19.33.53;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2003.06.03.20.47.05;	author livesey;	state Exp;
branches;
next	2.100;

2.100
date	2003.06.03.19.23.03;	author livesey;	state Exp;
branches;
next	2.99;

2.99
date	2003.05.29.16.36.29;	author livesey;	state Exp;
branches;
next	2.98;

2.98
date	2003.05.13.04.47.18;	author livesey;	state Exp;
branches;
next	2.97;

2.97
date	2003.05.12.02.05.27;	author livesey;	state Exp;
branches;
next	2.96;

2.96
date	2003.05.05.23.00.05;	author livesey;	state Exp;
branches;
next	2.95;

2.95
date	2003.04.04.22.54.58;	author livesey;	state Exp;
branches;
next	2.94;

2.94
date	2002.11.22.12.57.09;	author mjf;	state Exp;
branches
	2.94.2.1;
next	2.93;

2.93
date	2002.10.19.18.53.26;	author livesey;	state Exp;
branches;
next	2.92;

2.92
date	2002.10.17.18.18.25;	author livesey;	state Exp;
branches;
next	2.91;

2.91
date	2002.10.08.00.09.15;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2002.09.26.18.01.08;	author livesey;	state Exp;
branches;
next	2.89;

2.89
date	2002.09.13.18.08.12;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2002.09.11.14.06.12;	author livesey;	state Exp;
branches;
next	2.87;

2.87
date	2002.08.08.22.06.33;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2002.08.04.15.55.56;	author mjf;	state Exp;
branches;
next	2.85;

2.85
date	2002.07.22.03.26.15;	author livesey;	state Exp;
branches;
next	2.84;

2.84
date	2002.07.01.23.51.30;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2002.05.17.17.56.01;	author livesey;	state Exp;
branches;
next	2.82;

2.82
date	2002.05.14.00.28.04;	author livesey;	state Exp;
branches
	2.82.2.1;
next	2.81;

2.81
date	2002.04.22.20.54.29;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2002.03.13.22.00.16;	author livesey;	state Exp;
branches;
next	2.79;

2.79
date	2002.03.08.08.06.32;	author livesey;	state Exp;
branches;
next	2.78;

2.78
date	2002.02.14.23.15.22;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2002.02.08.22.58.14;	author livesey;	state Exp;
branches;
next	2.76;

2.76
date	2002.02.08.22.51.40;	author livesey;	state Exp;
branches;
next	2.75;

2.75
date	2002.02.07.02.53.06;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2002.02.05.02.39.59;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2002.01.18.00.34.53;	author livesey;	state Exp;
branches;
next	2.72;

2.72
date	2001.10.23.16.39.28;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2001.10.18.23.49.46;	author livesey;	state Exp;
branches;
next	2.70;

2.70
date	2001.10.18.23.31.56;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2001.10.15.22.11.54;	author livesey;	state Exp;
branches;
next	2.68;

2.68
date	2001.10.12.23.10.18;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2001.10.09.23.43.42;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2001.10.08.23.40.49;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2001.10.05.17.33.55;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2001.10.04.01.50.33;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2001.10.03.23.05.42;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2001.10.02.23.39.15;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2001.10.02.19.00.50;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2001.10.01.20.32.27;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2001.09.29.00.25.51;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2001.09.25.19.41.07;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2001.09.25.00.47.08;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2001.09.25.00.18.23;	author livesey;	state Exp;
branches;
next	2.55;

2.55
date	2001.09.24.23.01.11;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2001.09.21.17.38.46;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2001.09.20.23.02.31;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2001.09.20.20.56.34;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2001.09.19.23.40.53;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2001.09.17.23.10.49;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2001.07.19.17.57.15;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2001.07.17.17.33.21;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2001.07.06.22.04.02;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2001.06.26.20.32.31;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2001.06.01.01.04.22;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2001.05.25.22.33.07;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2001.05.17.20.17.00;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2001.05.11.23.33.29;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2001.05.11.22.01.00;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2001.05.10.23.29.59;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2001.05.10.23.11.54;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2001.05.08.20.28.34;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2001.05.03.02.12.03;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2001.05.02.20.44.37;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2001.05.02.05.29.44;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2001.04.28.21.01.20;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2001.04.28.20.54.48;	author livesey;	state Exp;
branches;
next	2.32;

2.32
date	2001.04.28.07.04.32;	author livesey;	state Exp;
branches;
next	2.31;

2.31
date	2001.04.28.01.48.52;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2001.04.28.01.27.38;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2001.04.25.21.57.07;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2001.04.25.20.15.23;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2001.04.25.01.35.01;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2001.04.25.01.24.54;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2001.04.24.21.33.53;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2001.04.20.00.07.15;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2001.04.18.23.27.00;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2001.04.12.21.43.19;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.04.10.22.38.20;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2001.03.21.02.14.37;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2001.03.19.17.10.47;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.03.16.18.17.49;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2001.03.05.00.53.59;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2001.03.03.00.07.01;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.02.28.17.34.25;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.02.27.17.18.53;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.02.21.21.50.38;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.02.09.00.38.56;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2001.02.08.00.36.29;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.02.08.00.34.41;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.01.26.19.00.02;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.01.19.23.49.59;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.01.10.21.03.14;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.01.03.02.01.30;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2000.12.04.23.43.59;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2000.11.23.01.10.27;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2000.11.15.01.33.58;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2000.11.10.00.24.24;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.13.00.00.37;	author vsnyder;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.05.17.21.16;	author dcuddy;	state dead;
branches;
next	1.11;

1.11
date	2000.06.19.23.19.43;	author lungu;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.18.00.04.15;	author lungu;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.12.19.46.37;	author lungu;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.14.20.27.43;	author vsnyder;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.13.23.45.33;	author vsnyder;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.20.01.29.59;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.19.18.36.46;	author livesey;	state Exp;
branches;
next	1.4;

1.4
date	99.12.17.21.43.17;	author livesey;	state Exp;
branches;
next	1.3;

1.3
date	99.12.16.18.32.26;	author livesey;	state Exp;
branches;
next	1.2;

1.2
date	99.12.14.01.01.52;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	99.12.04.00.30.18;	author livesey;	state Exp;
branches;
next	;

2.94.2.1
date	2003.03.06.23.25.16;	author vsnyder;	state Exp;
branches;
next	2.94.2.2;

2.94.2.2
date	2003.03.07.23.51.17;	author vsnyder;	state Exp;
branches;
next	2.94.2.3;

2.94.2.3
date	2003.04.15.23.13.38;	author vsnyder;	state Exp;
branches;
next	;

2.82.2.1
date	2002.05.24.21.30.17;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.212
log
@Dont say not allocated when Dumping MAFs, BinNumbers
@
text
@! Copyright 2012, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module VectorsModule            ! Vectors in the MLS PGS suite
!=============================================================================

  ! This module provides the simple functionality for vector quantities in the
  ! MLS Level 2 software, and related programs.

! === (start of toc) ===                                                 
!     c o n t e n t s
!     - - - - - - - -

!         Defined types
! VectorTemplate_T   vector template (contains quantity templates)
! VectorValue_T      values corresponding to a single quantity
! Vector_T           a vector has 1 VectorTemplate_T, many VectorValue_Ts

!         Functions, operations, routines
! AddToVector                  X = X + Y
! AddVectors                   Result Z = X + Y
! AddVectorTemplateToDatabase  Adds a vector template to a database of such templates
! AddVectorToDatabase          Adds a vector to a database of such vectors
! AreEqual                     Check that two vectors are equal valuewise
!                               (assumes the same template, ignores masks)
! AreUnEqual                   Check that two vectors are unequal valuewise
!                               (assumes the same template, ignores masks)
! AssignVector                 Destroy 1st arg, then assign 2nd arg to it
! AxPy                         Result z = A x + y
! CheckIntegrity_Vector
! CheckIntegrity_VectorTemplate
! CheckIntegrity_VectorValue
! CheckNaN
! CheckVectorForNaN
! CheckVectorQuantityForNaN
! ClearMask                    Clear bits of MASK according to TO_CLEAR
! ClearUnderMask               Clear elements of z corresponding to MASK
! ClearVector                  Clear elements of z
! CloneVector                  Destroy 1st arg, then use 2nd arg for a template
! CloneVectorQuantity          Destroy 1st arg, then use 2nd arg for a template
! ConstantXVector              Result z = A x
! ConstructVectorTemplate      Creates a vectorTemplate from a list of quantities
! CopyVector                   z = x, including copying values and mask
! CopyVectorMask               Copy mask for x to z, assuming compatible vectors
! CreateMask                   Allocate the MASK array for a vector quantity
! CreateVector                 Creates an empty vector according to a given template
! CreateVectorValue            Creates an empty vector value according to a given template
! DestroyVectorDatabase        Destroys a vector database
! DestroyVectorInfo            Destroy a vector
! DestroyVectorMask            Destroy the masks stored in the vector
! DestroyVectorQuantityMask    Destroy the MASK stored in one vector quantity
! DestroyVectorQuantityValue   Destroy the VALUES stored in one vector quantity
! DestroyVectorTemplateDatabase Destroys a vector template database
! DestroyVectorTemplateInfo    Destroys a vector template
! DestroyVectorValue           Destroy the "values" field in all of the quantities in a vector
! Diff                         Generic for several diff_...; see the interface
! DivideVectors                Y = A / X if Y is present, else X = A / X
! DotVectors                   z = x . y
! DotVectorsMasked             z = x . y, but only where mask is "off"
! DotVectorsMaybeMasked        z = x . y, maybe masked if optional arg is true
! DumpMask                     Display only the mask information for a vector
! Dump                         Generic for several dump_...; see the interface
! DumpQuantityMask
! DumpVectorMask
! DumpVectorNorms              Dump the vector norm, or its quantity norms
! Dump_vector                  Display how a single vector is made up
! Dump_vectors                 Display how vector database is made up
! Dump_Vector_Quantity         Display a vector quantity
! Dump_vector_templates        Display how vector template database is made up
! GatherVectorQuantity         Returns a new quantity whose values are
!                                the smaller set in the hyperslab described
!                                by start, count, stride, block
! GetVectorQuantity            Returns pointer to quantity by name in vector
! GetVectorQuantityByType      Returns pointer to quantity by type in vector
! GetVectorQtyByTemplateIndex  Returns pointer to quantity by template in vector
! GetVectorQuantityIndexByName Returns index to quantity by name in vector
! GetVectorQuantityIndexByType Returns index to quantity by type in vector
! InflateVectorDatabase
! InflateVectorTemplateDatabase
! IsVectorQtyMasked            Is the mask for VectorQty set for address
! L2Norm                       L2 norm of the vector
! L2Norms                      L2 norms of the vector's quantities
! MaskVectorQty                Set the mask for VectorQty for spec. address
! MoveVectorQuantity           Move VALUES and MASK fields from one qty to another
! MultiplyVectors              Z = X # Y if Z present; else X = X # Y
! NullifyVectorTemplate
! NullifyVectorValue
! NullifyVector
! PowVector                    X = X ** Power element-by-element
! ReciprocateVector            Y = A / X if Y is present, else X = A / X -- scalar A
! RemapVectorMask              Remap MASK1 to MASK, MASK3 and MASK4
! RemapVectorValue             Remap VALUE1 to VALUES, VALUE3, and VALUE4
! ReshapeVectorValue           Reshape source values to fit destination loosely
! ReverseMask                  Reverse bits of MASK according to TO_CLEAR
! RmVectorFromDatabase         Removes a vector from a database of such vectors
! ScaleVector                  Y = A*X if Y is present, else X = A*X.
! SetMask                      Set bits of MASK indexed by elements of TO_SET
! SubtractFromVector           x = x - y
! SubtractVectors              Returns z = x - y
! ValidateVectorQuantity       Test vector quantity for matching components
! VectorMemoryInUse            Returns number of elements in all quantities
! VectorsMemoryInUse           Returns number of elements in all vectors
! === (end of toc) ===

  ! --------------------------------------------------------------------------

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Test_Allocate, &
    & Test_Deallocate
  use HyperSlabs, only: ExtractArray
  use, Intrinsic :: Iso_C_Binding, only: C_Intptr_T, C_Loc
  use BitStuff, only: DumpBitNames, IsBitSet
  use Diff_1, only: Diff
  use Dump_0, only: Dump
  use HighOutput, only: OutputNamedValue
  use Intrinsic, only: Lit_Indices, Phyq_Invalid, L_Vmr
  use Lexer_Core, only: Where_T
  use MLSCommon, only: M_Cloud, M_Fill, M_FullDerivatives, M_Ignore, &
    & M_LinAlg, M_Spare, M_Tikhonov
  use MLSFinds, only: FindFirst, FindUnique
  use MLSKinds, only: R8, Rv
  use MLSMessageModule, only: MLSMessage, MLSMessageConfig, MLSMSG_Error, &
    & MLSMSG_Warning
  use MLSSignals_M, only: Modules, Signals, GetSignalName
  use Output_M, only: Blanks, Newline, Output
  use QuantityTemplates, only: QuantityTemplate_T, CheckIntegrity, &
    & CopyQuantityTemplate, DestroyQuantityTemplateContents, Dump, &
    & NullifyQuantityTemplate
  use String_Table, only: Display_String, Get_String_Rude=>get_String, &
    & IsStringInTable, String_Length
  use Symbol_Table, only: Enter_Terminal
  use Symbol_Types, only: T_Identifier

  implicit none
  private
  ! Generics
  public :: Assignment (=), AreEqual, AreUnEqual, Multiply
  public :: operator (+), operator (-), operator (*)
  public :: operator (==), operator (/=), operator ( .DOT. )
  public :: operator ( .MDOT. )
  public :: DIFF, DUMP
  ! Specifics
  public :: ADDTOVECTOR, ADDVECTORS, ADDVECTORTEMPLATETODATABASE
  public :: ADDVECTORTODATABASE, ASSIGNVECTOR, AXPY
  public :: CHECKINTEGRITY, CHECKNAN, CHECKVECTORFORNAN
  public :: CHECKVECTORQUANTITYFORNAN, CLEARMASK, CLEARUNDERMASK, CLEARVECTOR
  public :: CLONEVECTOR, CLONEVECTORQUANTITY, CONSTANTXVECTOR
  public :: CONSTRUCTVECTORTEMPLATE, COPYVECTOR, COPYVECTORMASK
  public :: CREATEMASK, CREATEVECTOR, CREATEVECTORVALUE, DESTROYVECTORDATABASE
  public :: DESTROYVECTORINFO, DESTROYVECTORMASK, DESTROYVECTORQUANTITYMASK
  public :: DESTROYVECTORQUANTITYVALUE, DESTROYVECTORTEMPLATEDATABASE
  public :: DESTROYVECTORTEMPLATEINFO, DESTROYVECTORVALUE
  public :: DIFFVECTORQUANTITIES
  public :: DIVIDEVECTORS
  public :: DOTVECTORS, DOTVECTORSMASKED, DOTVECTORSMAYBEMASKED
  public :: DOTVECTORQUANTITIES, DOTVECTORQUANTITIESMASKED
  public :: DOTVECTORQUANTITIESMAYBEMASKED
  public :: DUMPNICEMASKSUMMARY, DUMPMASK, DUMPQUANTITYMASK, DUMPVECTORMASK
  public :: DUMPVECTORNORMS
  public :: DUMP_VECTOR, DUMP_VECTORS, DUMP_VECTOR_QUANTITY
  public :: DUMP_VECTOR_TEMPLATE, DUMP_VECTOR_TEMPLATES
  public :: GATHERVECTORQUANTITY, GETVECTORQUANTITY, GETVECTORQUANTITYBYTYPE
  public :: GETVECTORQTYBYTEMPLATEINDEX, GETVECTORQUANTITYINDEXBYNAME
  public :: GETVECTORQUANTITYINDEXBYTYPE, INFLATEVECTORDATABASE
  public :: INFLATEVECTORTEMPLATEDATABASE, ISVECTORQTYMASKED
  public :: L2NORM, L2NORMQ, L2NORMV
  public :: MASKVECTORQTY, MOVEVECTORQUANTITY, MULTIPLYVECTORS
  public :: NULLIFYVECTORTEMPLATE, NULLIFYVECTORVALUE, NULLIFYVECTOR, POWVECTOR
  public :: QUANTITYTEMPLATE_T ! FOR FULL F95 COMPATIBILITY
  public :: RECIPROCATEVECTOR, REMAPVECTORMASK, REMAPVECTORVALUE, REVERSEMASK
  public :: RESHAPEVECTORVALUE, RMVECTORFROMDATABASE
  public :: SCALEVECTOR, SETMASK, SUBTRACTFROMVECTOR
  public :: SUBTRACTVECTORS, VALIDATEVECTORQUANTITY
  public :: VectorMemoryInUse, VectorsMemoryInUse
  ! Types
  public :: VECTORTEMPLATE_T, VECTORVALUE_T, VECTOR_T
  ! Parameters
  public :: M_IGNORE, M_CLOUD, M_FILL, M_FULLDERIVATIVES, M_LINALG, &
    & M_SPARE, M_TIKHONOV, RV

! =====     Defined Operators and Generic Identifiers     ==============

  interface Assignment (=)
    module procedure AssignVector, AssignVectorValue
  end interface

  interface AreEqual
    module procedure AreEqual_Scalar, AreEqual_Vector
  end interface

  interface AreUnEqual
    module procedure AreUnEqual_Scalar, AreUnEqual_Vector
  end interface

  interface CheckIntegrity
    module procedure CheckIntegrity_VectorValue, CheckIntegrity_VectorTemplate, &
      & CheckIntegrity_Vector
  end interface

  interface CheckNaN
    module procedure CheckVectorForNaN, CheckVectorQuantityForNaN
  end interface

  interface CLEARMASK
    module procedure CLEARMASK_1D, CLEARMASK_2D
  end interface

  interface DIFF
    module procedure DIFFVECTORQUANTITIES
  end interface

  interface DUMP
    module procedure DUMP_VECTOR, DUMP_VECTORS, DUMP_VECTOR_QUANTITY
    module procedure DUMP_VECTOR_TEMPLATE, DUMP_VECTOR_TEMPLATES
  end interface

  interface DumpMask
    module procedure DumpQuantityMask, DumpVectorMask
  end interface

  interface GETVECTORQUANTITYINDEXBYNAME
    module procedure GETVECTORQUANTITYINDEXBYNAME_CHAR
    module procedure GETVECTORQUANTITYINDEXBYNAME_SBR
  end interface

  interface L2Norm
    module procedure L2NormQ, L2NormV
  end interface

  interface Multiply
    module procedure MultiplyVectors
  end interface

  interface operator (+)
    module procedure AddVectors
  end interface

  interface operator (-)
    module procedure SubtractVectors
  end interface

  interface operator (*)
    module procedure ConstantXVector ! by a scalar on the left
  end interface

  interface operator (==)
    module procedure AreEqual_Scalar, AreEqual_Vector
  end interface

  interface operator (/=)
    module procedure AreUnEqual_Scalar, AreUnEqual_Vector
  end interface

  interface operator ( .DOT. )
    module procedure DotVectors, DotVectorQuantities
  end interface

  interface operator ( .MDOT. )
    module procedure DotVectorsMasked, DotVectorQuantitiesMasked
  end interface

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: VectorsModule.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! Some introductory remarks:
  ! There is a hierarchy of user-defined types
  ! * At the bottom are the VectorValue_T which correspond to specific
  !   instances of quantities like H2O or Temperature
  ! * One level up are Vector_T, built of as many VectorValue_T
  !   as you please
  ! * In parallel with these are the templates, used for holding
  !   everything each specific instance shares with the others;
  !   e.g., type, signal, geolocations
  ! * At the bottom are the QuantityTemplate_T, holding shared data
  ! * One level up are VectorTemplate_T
  ! The following diagram summarizes these relations

  !   Templates             Specific Instances
  !   ---------             ------------------
  !  VectorTemplate_T          Vector_T
  !        ^                      ^
  !        |                      |
  !  QuantityTemplate_T      VectorValue_T
  
  ! This type describes a vector template

  type :: VectorTemplate_T
     
    ! Administrative stuff
    integer :: Name = 0           ! Sub-rosa index of name, if any, else zero
    type(where_t) :: Where        ! Source_ref for creation if by L2CF

    ! General information about the vector

    integer :: NoQuantities = 0   ! Number of quantities in the vector
    integer :: TotalInstances = 0 ! Number of horizontal instances in the vector
    integer :: TotalElements = 0  ! Total of numbers of elements in the vector
    integer, dimension(:), pointer :: QUANTITIES => NULL() ! Indices of the
    !                            quantity templates in the quantities database
  end type VectorTemplate_T

  ! This type describes the subset of the values of a vector that
  ! correspond to a single quantity. 
  
  ! ---- Should have called this QuantityValue_T. ----

  type VectorValue_T
    type (QuantityTemplate_T) :: TEMPLATE ! Template for this quantity.
    integer :: Index = 0          ! Index of this quantity in the vector database
    real(rv), dimension(:), pointer, contiguous :: VALUE1 => NULL() ! The
    ! dimension of VALUE1 is Frequencies (or 1) * Vertical Coordinates or MIF
    ! (or 1) * Horizontal Instances (scan or profile or 1) * Cross-track
    ! instances.  These are taken from (template%noChans * template%noSurfs *
    ! template%noInstances).  This is the one that's allocated and deallocated.
    real(rv), dimension(:,:), pointer, contiguous :: VALUES => NULL() ! The
    ! dimensions of VALUES are Frequencies (or 1) * Vertical Coordinates or MIF
    ! (or 1), and Horizontal Instances (scan or profile or 1) * Cross-track
    ! instances.  These are taken from (template%noChans * template%noSurfs,
    ! template%noInstances).  This is a rank remapping of VALUE1.
    real(rv), dimension(:,:,:), pointer, contiguous :: VALUE3 => NULL() ! The
    ! dimensions of VALUE3 are Frequencies, Vertical Coordinates or MIF, and
    ! Horizontal Instances (MAF or profile or 1) * Cross-track instances.  These
    ! are taken from template%noChans, template%noSurfs, and
    ! template%noInstances.  This is a rank remapping of VALUE1.
    real(rv), dimension(:,:,:,:), pointer, contiguous :: VALUE4 => NULL() ! The
    ! dimensions of VALUE3 are Frequencies, Vertical Coordinates or MIF,
    ! Horizontal Instances (MAF or profile or 1), and Cross-track instances. 
    ! These are taken from template%noChans, template%noSurfs, and
    ! template%noInstances.  This is a rank remapping of VALUE1.
    character, dimension(:), pointer, contiguous :: MASK1 => NULL() ! MASK1 is
    ! the array that is allocated and deallocated.  MASK and MASK3 are rank
    ! remappings of MASK1.
    character, dimension(:,:), pointer, contiguous :: MASK => NULL() ! MASK is
    ! used to control whether elements of vectors are of interest. If MASK is
    ! not associated, every element is of interest.  Otherwise,the dimensions of
    ! MASK are the same as VALUES.  Bits of MASK(i,j) are used to determine what
    ! is not interesting.  Zero means something about VALUES(i,j) is
    ! interesting, and one means it is not.  The low-order bit is used for
    ! linear algebra.  Other bits can be used for other purposes.
    ! Actually the mask bits are gotten at from the ichar(mask)
    ! Inversely, given the integer representation of the bits, we get the mask
    ! by mask = char(int).  This is a rank remapping of MASK1.
    character, dimension(:,:,:), pointer, contiguous :: MASK3 => NULL() ! This
    ! is used for masking VALUE3, and has the same dimensions.  This is a rank
    ! remapping of MASK1.
    character, dimension(:,:,:,:), pointer, contiguous :: MASK4 => NULL() ! This
    ! is used for masking VALUE4, and has the same dimensions.  This is a rank
    ! remapping of MASK1.
    integer :: Label = 0        ! An optional label for this to be used as for
    ! example a swath name.  Often used in conjunction with the 'batch'
    ! approach to direct writes.
    character(len=40) :: AllocationName = 'None'
    ! These fields apply only to products of a neural network model
    integer, pointer, dimension(:)    :: BinNumber => NULL()
    integer, pointer, dimension(:)    :: MAF => NULL()
  end type VectorValue_T

  character(len=16), dimension(7), parameter :: maskBitNames = (/ &
    & 'linear algebra  ', 'full derivatives', 'fill            ' , &
    & 'Tikhonov        ', 'cloud           ', 'ignore          ' , &
    & 'spare           ' /)

  ! This type describes a vector.

  type Vector_T
    integer :: Name = 0        ! Sub-rosa index of the vector name
    type(where_t) :: Where     ! Source_ref for creation if by L2CF
    integer :: GlobalUnit = PHYQ_Invalid ! Alternative units for whole vector
    type (VectorTemplate_T) :: TEMPLATE ! Template for this vector
    type (VectorValue_T), dimension(:), pointer :: QUANTITIES => NULL() ! The
    ! dimension of QUANTITIES is the same as for the QUANTITIES field of the
    ! vector template.  Each element of QUANTITIES here corresponds to the
    ! one in the same position in the QUANTITIES field of the vector template.
!   contains
!     final :: DestroyVectorInfo
  end type Vector_T

  private :: CreateValues

contains ! =====     Public Procedures     =============================

  ! ------------------------------------------------  AddToVector  -----
  subroutine AddToVector ( X, Y, Scale )  ! X = X + [Scale*] Y
    ! Dummy arguments:
    type(Vector_T), intent(inout) :: X
    type(Vector_T), intent(in) :: Y
    real(r8), intent(in), optional :: Scale
    ! Local Variables:
    integer :: I              ! Subscript and loop inductor
    ! Executable statements:
    if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot add vectors having different templates" )
    if ( present(scale) ) then
      do i = 1, size(x%quantities)
        x%quantities(i)%values = x%quantities(i)%values + &
          & scale * y%quantities(i)%values
      end do
    else
      do i = 1, size(x%quantities)
        x%quantities(i)%values = x%quantities(i)%values + y%quantities(i)%values
      end do
    end if
  end subroutine AddToVector

  ! -------------------------------------------------  AddVectors  -----
  type (Vector_T) function AddVectors ( X, Y ) result (Z)
  ! Add two vectors, producing one having the same template (but no name,
  ! of course).

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyVectorInfo using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignVector.
  ! !!!!! ===== END NOTE ===== !!!!! 

    ! Dummy arguments:
    type(Vector_T), intent(in) :: X, Y
    ! Local Variables:
    integer :: I              ! Subscript and loop inductor
    ! Executable statements:
    if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot add vectors having different templates" )
    call nullifyVector ( z ) ! for Sun's still useless compiler
    call CloneVector ( z, x, vectorNameText='_z' )
    do i = 1, size(x%quantities)
      z%quantities(i)%values = x%quantities(i)%values + y%quantities(i)%values
    end do
  end function AddVectors

  ! --------------------------------  AddVectorTemplateToDatabase  -----
  integer function AddVectorTemplateToDatabase ( DATABASE, ITEM )

  ! This routine adds a vector template to a database of such templates, 
  ! creating the database if necessary.

    ! Dummy arguments
    type (VectorTemplate_T), dimension(:), pointer :: DATABASE
    type (VectorTemplate_T), intent(in) :: ITEM

    ! Local variables
    type (VectorTemplate_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddVectorTemplateToDatabase = newSize
  end function AddVectorTemplateToDatabase

  ! ----------------------------------------  AddVectorToDatabase  -----
  integer function AddVectorToDatabase ( DATABASE, ITEM )

  ! This routine adds a vector to a database of such vectors, 
  ! creating the database if necessary.

    ! Dummy arguments
    type (Vector_T), dimension(:), pointer :: DATABASE
    type (Vector_T), intent(in) ::            ITEM

    ! Local variables
    type (Vector_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddVectorToDatabase = newSize
  end function AddVectorToDatabase

  ! --------------------------------------------  AreEqual_Scalar  -----
  logical function AreEqual_Scalar ( A, C ) result ( Equal )

  ! This routine checks that all associated values in vector A are equal to
  ! scalar C.

    ! Dummy arguments
    type (Vector_T), intent(in)           ::  A
    real(rv), intent(in)                  ::  C

    ! Local variables
    type (VectorValue_T), pointer :: AQ ! a quantity
    integer :: qIndex
    ! Executable
    equal = .true. ! In case there are no quantities
    do qIndex = 1, size ( a%quantities ) 
      aq => a%quantities(qIndex)
      if ( .not. associated(aq) ) cycle
      equal = all(aq%values == c)
      if ( .not. equal ) exit
    end do

  end function AreEqual_Scalar

  ! --------------------------------------------  AreEqual_Vector  -----
  logical function AreEqual_Vector ( A, B ) result ( Equal )

  ! This routine checks that all associated values in vector A are equal
  ! to corresponding values in vector B.

    ! Dummy arguments
    type (Vector_T), intent(in)           ::  A
    type (Vector_T), intent(in)           ::  B

    ! Local variables
    type (VectorValue_T), pointer :: AQ ! a quantity
    type (VectorValue_T), pointer :: BQ ! a quantity
    integer :: qIndex
    ! Executable
    equal = .true. ! In case there are no quantities

    do qIndex = 1, size ( a%quantities ) 
      aq => a%quantities(qIndex)
      bq => b%quantities(qIndex)
      equal = associated(aq) .eqv. associated(bq)
      if ( .not. equal ) exit
      if ( .not. associated(aq) .or. .not. associated(bq) ) cycle
      equal = all(aq%values == bq%values)
      if ( .not. equal ) exit
    end do

  end function AreEqual_Vector

  ! ------------------------------------------  AreUnEqual_Scalar  -----
  logical function AreUnEqual_Scalar ( A, C ) result ( UnEqual )
    ! Dummy arguments
    type (Vector_T), intent(in)           ::  A
    real(rv), intent(in)                  ::  C
    unEqual = .not. ( A == C )
  end function AreUnEqual_Scalar

  ! ------------------------------------------  AreUnEqual_Vector  -----
  logical function AreUnEqual_Vector ( A, B ) result ( UnEqual )
    ! Dummy arguments
    type (Vector_T), intent(in)           ::  A
    type (Vector_T), intent(in)           ::  B
    unEqual = .not. ( A == B )
  end function AreUnEqual_Vector

  ! -----------------------------------------------  AssignVector  -----
  subroutine AssignVector ( Z, X )
  ! Destroy Z, then assign X to it, by using pointer assignment for the
  ! components.  DO NOT DO Z = Z!  Notice that CopyVector uses deep
  ! assignment. Notice that if we have a loop with Z = vector-expr, this
  ! destroys Z at each iteration, so it is necessary to call DestroyVectorInfo
  ! only after the loop, if at all.
    type(Vector_T), intent(inout) :: Z
    type(Vector_T), intent(in) :: X
    call destroyVectorInfo ( z )
    z%name = x%name
    z%globalUnit = x%globalUnit
    z%template = x%template
    z%quantities => x%quantities
  end subroutine AssignVector

  ! ------------------------------------------  AssignVectorValue  -----
  subroutine AssignVectorValue ( Z, X )
  ! Turn off assignment for vector quantities
    use MLSMEssageModule, only: MLSMSG_Crash, MLSMessage
    type(VectorValue_T), intent(inout) :: Z
    type(VectorValue_T), intent(in) :: X
    call MLSMessage ( MLSMSG_Crash, moduleName, "Assigning VectorValue_T is a no-no" )
    z%index = x%index ! to avoid sniveling about unused dummy arguments
  end subroutine AssignVectorValue

  ! -------------------------------------------------------  AXPY  -----
  type (Vector_T) function AXPY ( A, X, Y ) result (Z)
  ! Multiply the vector X by A and add Y to it, producing one having the
  ! same template (but no name, of course).

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyVectorInfo using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignVector.
  ! !!!!! ===== END NOTE ===== !!!!! 

    ! Dummy arguments:
    real, intent(in) :: A
    type(Vector_T), intent(in) :: X, Y
    ! Local variables:
    integer :: I              ! Subscript and loop inductor
    ! Executable statements:
    if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot add vectors having different templates" )
    call nullifyVector ( z ) ! for Sun's still useless compiler
    call CloneVector ( z, x, vectorNameText='_z' )
    do i = 1, size(x%quantities)
      z%quantities(i)%values = &
        & a * x%quantities(i)%values + y%quantities(i)%values
    end do
  end function AXPY

  ! ------------------------------------------ CheckIntegrity_Vector -----------
  logical function CheckIntegrity_Vector ( vector, noError )
    type ( Vector_T ), intent(in) :: VECTOR
    logical, optional, intent(in) :: NOERROR

    ! Local variables
    integer :: MESSAGETYPE
    character (len=132) :: NAME
    integer :: QTY                      ! Loop counter
    integer :: totalInstances
    integer :: totalElements

    ! Executable code
    messageType = MLSMSG_Error
    if ( present ( noError ) ) then
      if ( noError ) messageType = MLSMSG_Warning
    end if

    if ( vector%name /= 0 ) then
      call get_string ( vector%name, name, strip=.true. )
    else
      name = '<no name>'
    end if

    call output ( 'Checking integrity for vector '//trim(name), advance='yes' )
    CheckIntegrity_Vector = CheckIntegrity ( vector%template, .true. )

    if ( .not. associated ( vector%quantities ) .and. &
      & vector%template%noQuantities > 0 ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The vector '//trim(name)//' does not have quantities associated' )
      CheckIntegrity_Vector = .false.
    end if

    totalInstances = 0
    totalElements = 0
    do qty = 1, vector%template%noQuantities
      call output ( 'Checking integrity for quantity ' )
      call display_string ( vector%quantities(qty)%template%name, &
        & strip=.true., advance='yes' )
      CheckIntegrity_Vector = CheckIntegrity_Vector .and. &
        & CheckIntegrity ( vector%quantities(qty), .true. )
      totalInstances = totalInstances + vector%quantities(qty)%template%noInstances
      totalElements = totalElements + vector%quantities(qty)%template%noInstances * &
        & vector%quantities(qty)%template%instanceLen
    end do

    if ( totalElements /= vector%template%totalElements ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The vector '//trim(name)//' does not have the right totalElements' )
      CheckIntegrity_Vector = .false.
    end if
    if ( totalInstances /= vector%template%totalInstances ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The vector '//trim(name)//' does not have the right totalInstances' )
      CheckIntegrity_Vector = .false.
    end if

  end function CheckIntegrity_Vector

  ! ------------------------------------------ CheckIntegrity_VectorTemplate ---
  logical function CheckIntegrity_VectorTemplate ( template, noError )
    type ( VectorTemplate_T), intent(in) :: TEMPLATE
    logical, optional, intent(in) :: NOERROR

    ! Local variables
    integer :: MESSAGETYPE
    character (len=132) :: NAME

    ! Executable code
    CheckIntegrity_VectorTemplate = .true.

    messageType = MLSMSG_Error
    if ( present ( noError ) ) then
      if ( noError ) messageType = MLSMSG_Warning
    end if

    if ( template%name /= 0 ) then
      call get_string ( template%name, name, strip=.true. )
    else
      name = '<no name>'
    end if

    ! Check stuff
    if ( .not. associated ( template%quantities ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The vector template '//trim(name)//' does not have quantities associated' )
      CheckIntegrity_VectorTemplate = .false.
    end if

    if ( lbound ( template%quantities, 1 ) /= 1 ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The vector template '//trim(name)//' has the wrong lbound for quantities' )
      CheckIntegrity_VectorTemplate = .false.
    end if

    if ( ubound ( template%quantities, 1 ) /= template%noQuantities ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The vector template '//trim(name)//' has the wrong ubound for quantities' )
      CheckIntegrity_VectorTemplate = .false.
    end if

    if ( any ( template%quantities < 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The vector template '//trim(name)//' contains a bad quantity index' )
      CheckIntegrity_VectorTemplate = .false.
    end if

  end function CheckIntegrity_VectorTemplate

  ! ------------------------------------------ CheckIntegrity_VectorValue ---
  logical function CheckIntegrity_VectorValue ( value, noError ) 
    type ( VectorValue_T), intent(in) :: VALUE
    logical, optional, intent(in) :: NOERROR

    ! Local variables
    integer :: MESSAGETYPE
    character (len=132) :: NAME

    ! Executable code
    ! Executable code
    messageType = MLSMSG_Error
    if ( present ( noError ) ) then
      if ( noError ) messageType = MLSMSG_Warning
    end if

    ! Check the integrity of the template
    CheckIntegrity_VectorValue = CheckIntegrity ( value%template, .true. )

    if ( value%template%name /= 0 ) then
      call get_string ( value%template%name, name, strip=.true. )
    else
      name = '<no name>'
    end if

    ! Check the integrity of the values
    if ( .not. associated ( value%values ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The vector_value for '//trim(name)//' does not have <values> associated' )
      CheckIntegrity_VectorValue = .false.
    end if

    if ( any ( lbound ( value%values ) /= (/1,1/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The vector_value for '//trim(name)//' has the wrong lbound for values' )
      CheckIntegrity_VectorValue = .false.
    end if
    if ( any ( ubound ( value%values ) /= &
      & (/value%template%instanceLen,value%template%noInstances/) ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'The vector_value for '//trim(name)//' has the wrong ubound for values' )
      CheckIntegrity_VectorValue = .false.
    end if

    if ( associated ( value%mask ) ) then
      if ( any ( lbound ( value%mask ) /= (/1,1/) ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'The vector_value for '//trim(name)//' has the wrong lbound for mask' )
        CheckIntegrity_VectorValue = .false.
      end if
      if ( any ( ubound ( value%mask ) /= &
        & (/value%template%instanceLen,value%template%noInstances/) ) ) then
        call MLSMessage ( messageType, ModuleName, &
          & 'The vector_value for '//trim(name)//' has the wrong ubound for mask' )
        CheckIntegrity_VectorValue = .false.
      end if
    end if

  end function CheckIntegrity_VectorValue

  ! ------------------------------------------  CheckVectorForNaN  -----
  logical function CheckVectorForNaN ( Vector, Print, Name )
  ! Check whether a vector has any NaNs in any of its VALUES, returning
  ! TRUE if so.
  ! This doesn't check the quantity templates.
    type (Vector_t), intent(in) :: Vector
    integer, intent(in) :: Print ! <= 0 => No printing
                                 !  > 0 => Call dump with details = print - 1
                                 !         on offending vector quantities
    character(len=*), intent(in), optional :: Name

    integer :: I

    CheckVectorForNaN = .false.
    if ( .not. associated(vector%quantities) ) return
    do i = 1, size(vector%quantities)
      CheckVectorForNaN = CheckVectorForNaN .or. &
        & checkNaN(vector%quantities(i), print,name,vector)
    end do
  end function CheckVectorForNaN

  ! -----------------------------------  CheckVectorQuantityForNaN  -----
  logical function CheckVectorQuantityForNaN ( VectorQuantity, Print, Name, Vector )
  ! Check whether a vector quantity has any NaNs in any of its VALUES, returning
  ! TRUE if so.
  ! This doesn't check the quantity templates.
    use IEEE_Arithmetic, only: IEEE_Is_Nan
    type (VectorValue_t), intent(in) :: VectorQuantity
    integer, intent(in) :: Print ! <= 0 => No printing
                                 !  > 0 => Call dump with details = print - 1
    character(len=*), intent(in), optional :: Name
    type (Vector_t), intent(in), optional :: Vector ! to get its name in case of dump

    CheckVectorQuantityForNaN = .false.
    if ( .not. associated(vectorQuantity%values) ) return
    CheckVectorQuantityForNaN = any(ieee_is_nan(vectorQuantity%values))
    if ( CheckVectorQuantityForNaN ) then
      if ( print > 0 ) &
        & call dump ( vectorQuantity, details=print-1, name=name, vector=vector )
    end if
  end function CheckVectorQuantityForNaN

  ! --------------------------------------------------  ClearMask  -----
  subroutine ClearMask_1d ( MASK, TO_CLEAR, WHAT )
  ! Clear bits of MASK indexed by elements of TO_CLEAR.  Numbering of mask
  ! elements starts at one, not zero!  If TO_CLEAR is absent, clear all of
  ! the bits of MASK.  If WHAT is absent, clear all bits.  If WHAT is
  ! present, clear only bits of MASK that correspond to "one" bits of WHAT.
    character, intent(inout), dimension(:) :: MASK
    integer, intent(in), dimension(:), optional :: TO_CLEAR
    integer, intent(in), optional :: WHAT
    integer :: MyWhat
    MyWhat = 0
    if ( present(what) ) myWhat = not(what)
    if ( present(to_clear) ) then
      mask(to_clear) = char(iand(ichar(mask(to_clear)),myWhat))
    else
      mask = char(iand(ichar(mask),myWhat))
    end if
  end subroutine ClearMask_1d

  subroutine ClearMask_2d ( MASK, TO_CLEAR, WHAT )
  ! Clear bits of MASK indexed by elements of TO_CLEAR.  Numbering of mask
  ! elements starts at one, not zero!  If TO_CLEAR is absent, clear all of
  ! the bits of MASK.  If WHAT is absent, clear all bits.  If WHAT is
  ! present, clear only bits of MASK that correspond to "one" bits of WHAT.
    character, intent(inout), dimension(:,:) :: MASK
    integer, intent(in), dimension(:), optional :: TO_CLEAR
    integer, intent(in), optional :: WHAT
    integer :: instance
    do instance=1, size(mask, 2)
      call ClearMask ( mask(:, instance), to_clear, what )
    end do
  end subroutine ClearMask_2d

  ! ----------------------------------------------  ClearUnderMask -----
  subroutine ClearUnderMask ( Z, Inst, Quant, What )
  ! Clear elements of Z that correspond to nonzero bits in its mask.
  ! If Inst is present, clear only elements of that instance.
  ! If Quant is present, clear only elements of that quantity.
  ! If What is present, it specifies which bits of the mask indicate which
  ! elements of Z to clear.  If What is absent, the M_LinAlg bit of the
  ! mask is used.
    type(Vector_T),intent(inout) :: Z
    integer, intent(in), optional :: Inst, Quant, What
    integer :: I1, I2    ! Bounds for instances
    integer :: II        ! Index/subscript for instances
    integer :: MyWhat    ! In case What is absent
    integer :: Q1, Q2    ! Bounds for quantities
    integer :: QI        ! Index/subscript for quantities
    integer :: VI        ! Index/subscript for values

    myWhat = m_LinAlg
    if ( present(what) ) myWhat = what
    q1 = 1
    q2 = z%template%noQuantities
    if ( present(quant) ) then
      q1 = quant
      q2 = quant
    end if
    do qi = q1, q2
      if ( associated(z%quantities(qi)%mask) ) then
        i1 = 1
        i2 = z%quantities(qi)%template%noInstances
        if ( present(inst) ) then
          i1 = inst
          i2 = inst
        end if
        do ii = i1, i2
          do vi = 1, size(z%quantities(qi)%values,1)
            if ( iand(ichar(z%quantities(qi)%mask(vi,ii)), myWhat) /= 0 ) &
              & z%quantities(qi)%values(vi,ii) = 0.0_rv
          end do ! vi
        end do ! ii
      end if
    end do ! qi
  end subroutine ClearUnderMask 

  ! ------------------------------------------------  ClearVector  -----
  subroutine ClearVector ( Z, value )
  ! Clear the elements of Z (make them zero).  Don't change its structure
  ! or mask.
    type(Vector_T), intent(inout) :: Z
    real(rv), optional, intent(in) :: VALUE ! Value to set in (default zero)
    real(rv) :: MYVALUE
    integer :: I
    myValue = 0.0_rv
    if ( present ( value ) ) myValue = value
    do i = 1, size(z%quantities)
      z%quantities(i)%values = myValue
    end do
  end subroutine ClearVector

  ! ------------------------------------------------  CloneVector  -----
  subroutine CloneVector ( Z, X, VectorNameText, Database )
  ! Destroy Z, except its name.
  ! Create the characteristics of a vector to be the same template as a
  ! given one (except it has no name).  Values are allocated, but not
  ! filled.  Z's mask is allocated if X's is allocated, but it is not filled.
  ! If Database is present, add Z to it.  The position in the database
  ! isn't returned.

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyVectorInfo using Z after it is no
  ! longer needed. Otherwise, a memory leak will result.  Also see
  ! AssignVector.
  ! !!!!! ===== END NOTE ===== !!!!! 

    ! Dummy arguments:
    type(Vector_T), intent(inout) :: Z
    type(Vector_T), intent(in) :: X
    character(len=*), intent(in), optional :: VectorNameText
    type(Vector_T), dimension(:), pointer, optional :: Database
    ! Local variables:
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: I, Status
    ! Executable statements:
    call destroyVectorInfo ( z )
    if ( present(vectorNameText) ) &
      & z%name = enter_terminal ( vectorNameText, t_identifier )
    z%globalUnit = x%globalUnit
    z%template = x%template
    allocate ( z%quantities(size(x%quantities)), stat=status )
    addr = 0
    if ( status == 0 ) then
      if ( size(z%quantities) > 0 ) addr = transfer(c_loc(z%quantities(1)), addr)
    end if
    call test_allocate ( status, moduleName, "z%quantities", &
      & uBounds=[size(x%quantities)], elementSize=storage_size(z%quantities) / 8, &
      & address=addr )
    z%quantities%index = x%quantities%index
    do i = 1, size(x%quantities)
      z%quantities(i)%template = x%quantities(i)%template
    end do
    call createValues ( z )
    do i = 1, size(x%quantities)
      if ( associated(x%quantities(i)%mask) ) then
        call createMask ( z%quantities(i) )
      end if
    end do
    if ( present(database) ) i = addVectorToDatabase ( database, z )
  end subroutine  CloneVector

  ! ------------------------------------------------  CloneVectorQuantity  -----
  subroutine CloneVectorQuantity ( Z, X, OPTIONS )
  ! Create a vector quantity to be the same template as a
  ! given one.  If the original's values are allocated, allocate the clone's
  ! and fill with the original's. Same with mask.
  
  ! If options is present and contains the string 'd', do a deep copy
  ! of the template. Otherwise, content yourself with a shallow one

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to deallocate Z's values and mask after they are no
  ! longer needed. Otherwise, a memory leak will result.
  ! !!!!! ===== END NOTE ===== !!!!! 

    ! Dummy arguments:
    type(vectorValue_T), intent(inout) :: Z
    type(vectorValue_T), intent(in) :: X
    character(len=*), optional, intent(in) :: OPTIONS
    ! Internal variables
    character(len=8) :: MYOPTIONS
    ! Executable statements:
    myOptions = ' '
    if ( present(options) ) myOptions = options
    call NullifyVectorValue ( z )
    if ( index( myOptions, 'd' ) > 0 ) then
      call CopyQuantityTemplate ( z%template, x%template )
    else
      z%template = x%template
    end if
    z%index = x%index
    if ( associated(x%values) ) then
      call createVectorValue ( z, 'z%values' )
      z%values = x%values
    end if
    if ( associated(x%mask) ) then
      call createMask ( z )
      z%mask = x%mask
    end if
    if ( associated(x%BinNumber) ) then
      allocate ( z%BinNumber(x%template%NoInstances) )
      z%BinNumber = x%BinNumber
    end if
    if ( associated(x%MAF) ) then
      allocate ( z%MAF(x%template%NoInstances) )
      z%MAF = x%MAF
    end if
    z%label = x%label
  end subroutine CloneVectorQuantity

  ! --------------------------------------------  ConstantXVector  -----
  type (Vector_T) function ConstantXVector ( A, X ) result (Z)
  ! Multiply the vector X by A, producing one having the same template
  ! (but no name, of course).

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyVectorInfo using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignVector.
  ! !!!!! ===== END NOTE ===== !!!!! 

    ! Dummy arguments:
    real(r8), intent(in) :: A
    type(Vector_T), intent(in) :: X
    ! Local Variables:
    integer :: I              ! Subscript and loop inductor
    ! Executable statements:
    call nullifyVector ( z ) ! for Sun's still useless compiler
    call CloneVector ( z, x, vectorNameText='_z' )
    do i = 1, size(x%quantities)
      z%quantities(i)%values = a * x%quantities(i)%values
    end do
  end function ConstantXVector

  ! ------------------------------------  ConstructVectorTemplate  -----
  subroutine ConstructVectorTemplate ( name, quantities, selected, &
    & vectorTemplate, where, ForWhom )

  ! This subroutine creates a vectorTemplate from a list of quantities.
  ! The default ordering is currently by quantity.  Later versions may
  ! have optional parameters to request other orderings.

    ! Dummy arguments
    integer, intent(in) :: NAME         ! Sub-rosa of vector template name
    type (QuantityTemplate_T), intent(in) :: quantities(:)
    integer, intent(in) :: selected(:)  ! Which quantities are selected?
    type (VectorTemplate_T), intent(out) :: vectorTemplate
    type(where_t), intent(in), optional :: where ! source_ref if created by L2CF
    character(len=*), intent(in), optional :: ForWhom ! use instead of ModuleName

    ! Executable code
!   Don't do the following.  The caller puts the actual argument into a database
!   using a shallow copy.  Destroying it would clobber a database item.
!   call destroyVectorTemplateInfo ( vectorTemplate ) ! avoid memory leaks

    vectorTemplate%name = name
    vectorTemplate%noQuantities = SIZE(selected)
    vectorTemplate%totalInstances = SUM(quantities(selected)%noInstances)
    vectorTemplate%totalElements = &
      & SUM(quantities(selected)%noInstances*quantities(selected)%instanceLen)
    if ( present(where) ) vectorTemplate%where = where
    
    ! Allocate some arrays
    if ( present(forWhom) ) then
      call allocate_test ( vectorTemplate%quantities, vectorTemplate%noQuantities, &
        & 'vectorTemplate%quantities', forWhom )
    else
      call allocate_test ( vectorTemplate%quantities, vectorTemplate%noQuantities, &
        & 'vectorTemplate%quantities', moduleName )
    end if

    ! Copy quantities over
    vectorTemplate%quantities = selected

  end subroutine ConstructVectorTemplate

  ! -------------------------------------------------  CopyVector  -----
  subroutine CopyVector ( Z, X, CLONE, Quant, Inst, NoValues, NoMask, &
    & VectorNameText, Database, AllowNameMismatch )
  ! If CLONE is present and .true., Destroy Z, deep Z = X, except the
  ! name of Z is not changed.  Otherwise, copy only the values and mask
  ! of X to Z.  If NoValues or NoMask is present and true, don't copy
  ! that part of the vector.  VectorNameText and Database are passed
  ! to CloneVector if Clone is present and true.

    type(Vector_T), intent(inout) :: Z
    type(Vector_T), intent(in) :: X
    logical, intent(in), optional :: CLONE
    integer, intent(in), optional :: Quant, Inst  ! If Quant is present,
    !  only that quantity is copied.  If furthermore Inst is present,
    !  only that instance is copied.  If Inst is present but Quant
    !  is not, the entire vector is copied.
    logical, intent(in), optional :: NoValues, NoMask  ! If present and true,
    !  don't copy the values/mask
    character(len=*), intent(in), optional :: VectorNameText
    type(Vector_T), dimension(:), pointer, optional :: Database
    logical, intent(in), optional :: AllowNameMismatch ! Trust that vectors are compatible
    logical :: DoMask, DoValues
    integer :: I
    logical MyClone
    logical MyAllow
    myclone = .false.
    if ( present(clone) ) myclone = clone
    doMask = .true.
    if ( present(noMask) ) doMask = .not. noMask
    doValues = .true.
    if ( present(noValues) ) doValues = .not. noValues
    myAllow = .false.
    if ( present(allowNameMismatch) ) myAllow = allowNameMismatch
    if ( myclone ) then
      call cloneVector ( Z, X, vectorNameText=vectorNameText, database=database )
    else
      if ( x%template%name /= z%template%name .and. .not. myAllow ) call MLSMessage &
        & ( MLSMSG_Error, ModuleName, 'Incompatible vectors in CopyVector' )
    end if
    if ( present(quant) ) then
      if ( doMask .and. .not. associated ( z%quantities(quant)%mask ) ) &
        & call CreateMask ( z%quantities(quant) )
      if ( present(inst) ) then
        if ( doValues ) z%quantities(quant)%values(:,inst) = &
            & x%quantities(quant)%values(:,inst)
        if ( doMask .and. associated (x%quantities(quant)%mask ) ) &
          & z%quantities(quant)%mask(:,inst) = x%quantities(quant)%mask(:,inst)
      else
        if ( doValues ) &
          & z%quantities(quant)%values = x%quantities(quant)%values
        if ( doMask .and. associated (x%quantities(quant)%mask ) ) &
          & z%quantities(quant)%mask = x%quantities(i)%mask
      end if
    else
      do i = 1, size(x%quantities)
        z%quantities(i)%index = i
        if ( doValues ) z%quantities(i)%values = x%quantities(i)%values
        if ( doMask .and. associated (x%quantities(i)%mask ) ) then
          call CreateMask ( z%quantities(i) )
          z%quantities(i)%mask = x%quantities(i)%mask
        end if
      end do
    end if
  end subroutine CopyVector

  ! --------------------------------------------- CopyVectorMask ---------
  subroutine CopyVectorMask ( Z, X )
    ! Copy vector mask from x to z
    type (Vector_T), intent(inout) :: Z
    type (Vector_T), intent(in) :: X
    ! Local variables
    integer :: Q
    ! Executable code
    if ( x%template%name /= z%template%name ) call MLSMessage ( &
      & MLSMSG_Error, ModuleName, 'Incompatible vectors in CopyMask' )
    do q = 1, size(x%quantities)
      if ( associated ( x%quantities(q)%mask ) ) then
        call CreateMask ( z%quantities(q) )
        z%quantities(q)%mask = x%quantities(q)%mask
      else
        call destroyVectorQuantityMask ( z%quantities(q) )
      end if
    end do
  end subroutine CopyVectorMask

  ! -------------------------------------------------  CreateMask  -----
  subroutine CreateMask ( Value, ForWhom )
  ! Allocate the MASK array for a vector quantity.
    type(VectorValue_T), intent(inout) :: Value
    character(len=*), intent(in), optional :: ForWhom
    if ( present(forWhom) ) then
      call allocate_test ( value%mask1, size(value%values), &
        & trim(forWhom) // "%MASK1", ModuleName, fill=char(0) )
    else
      call allocate_test ( value%mask1, size(value%values), "MASK1", &
        & ModuleName, fill=char(0) )
    end if
    call remapVectorMask ( value )
  end subroutine CreateMask

  ! -----------------------------------------------  CreateVector  -----
  type(Vector_T) function CreateVector &
    & ( vectorName, vectorTemplate, quantities, VectorNameText, globalUnit, &
    & highBound, lowBound, noValues, where ) &
    & result ( vector )

    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End

  ! This routine creates an empty vector according to a given template
  ! Its mask is not allocated.  Use CreateMask if one is needed.

    ! Dummy arguments
    integer, intent(in) :: vectorName   ! Sub_rosa index
    type (VectorTemplate_T), intent(in), target :: VectorTemplate ! For vector
    type (QuantityTemplate_T), dimension(:), intent(in), target :: Quantities
    character(len=*), intent(in), optional :: VectorNameText
    integer, intent(in), optional :: globalUnit
    logical, intent(in), optional :: highBound
    logical, intent(in), optional :: lowBound
    logical, intent(in), optional :: noValues ! Don't create values for it.
    type(where_t), intent(in), optional :: where    ! source_ref

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: QUANTITY                 ! Loop index
    integer :: Me = -1                  ! String index for tracing
    integer :: STATUS                   ! From Allocate
    logical :: MYNOVALUES               ! Copy of novalues

    ! Executable code

    call trace_begin ( me, "CreateVector", &
      & cond=toggle(gen) .and. levels(gen) > 2 )

    vector%name = vectorName
    if ( present(globalUnit) ) vector%globalUnit = globalUnit
    if ( present(vectorNameText) ) &
      & vector%name = enter_terminal ( vectorNameText, t_identifier )
    vector%template = vectorTemplate
    allocate ( vector%quantities(vectorTemplate%noQuantities), STAT=status )
    addr = 0
    if ( status == 0 ) then
      if ( vectorTemplate%noQuantities > 0 ) addr = transfer(c_loc( &
        & vector%quantities(1)), addr)
    end if
    call test_allocate ( status, moduleName, "Vector quantities", &
      & uBounds=[vectorTemplate%noQuantities], &
      & elementSize = storage_size(vector%quantities) / 8, address=addr )
    do quantity = 1, vectorTemplate%noQuantities
      vector%quantities(quantity)%index = quantity
      vector%quantities(quantity)%template = &
        & quantities(vectorTemplate%quantities(quantity))
    end do
    myNoValues = .false.
    if ( present ( noValues ) ) myNoValues = noValues
    if ( .not. myNoValues) &
      & call createValues ( vector, highBound, lowBound )
    if ( present(where) ) vector%where = where

    call trace_end ( "CreateVector", cond=toggle(gen) .and. levels(gen) > 2 )

  end function CreateVector

  ! ------------------------------------------  CreateVectorValue  -----
  subroutine CreateVectorValue ( Value, What, Where )
  ! Allocate the Value1 component of Value and remap it.
  ! The Mask* components are destroyed.  Use CreateMask if you need to.
    type(vectorValue_t) :: Value
    character(len=*), intent(in) :: What
    character(len=*), intent(in), optional :: Where
    ! Local variables
    integer :: valueSize
    ! Executable
    ! In case it is already allocated, must deallocate Value
    ! before changing its allocation name
    call DestroyVectorQuantityValue ( value, &
      & forWhom=trim(moduleName) // '%CreateVectorValue' )
    valueSize = max( 1, value%template%noChans * &
        & value%template%noSurfs * &
        & value%template%noInstances * &
        & value%template%noCrossTrack )
    call destroyVectorQuantityMask ( value )
    if ( present(where) ) then
      value%AllocationName = trim(what) // "%values"
    else
      value%AllocationName = 'VALUE1'
    end if
    call allocate_test ( value%value1, &
      & valueSize, &
      & trim(value%AllocationName), moduleName )
    call remapVectorValue ( value )
  end subroutine CreateVectorValue

  ! --------------------------------------  DestroyVectorDatabase  -----
  subroutine DestroyVectorDatabase ( database )

  ! This subroutine destroys a vector database

    ! Dummy argument
    type (Vector_T),  dimension(:), pointer :: database

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: l2gpIndex, S, Status

    if ( associated(database) ) then
      do l2gpIndex = 1, SIZE(database)
        call DestroyVectorInfo(database(l2gpIndex))
      end do
      s = size(database) * storage_size(database) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(database(1)), addr)
      deallocate ( database, stat=status )
      call test_deallocate ( status, moduleName, 'database', s, address=addr )
    end if
    allocate ( database(0), stat=status )
    call test_allocate ( status, moduleName, "database" )
  end subroutine DestroyVectorDatabase

  ! ------------------------------------------  DestroyVectorInfo  -----
  subroutine DestroyVectorInfo ( Vector )

  ! This routine destroys a vector created above

    ! Dummy arguments
    type (Vector_T), intent(inout) :: VECTOR

    ! Local Variables:
    integer(c_intptr_t) :: Addr         ! For tracing
    character(len=80)   :: nameStr
    integer :: S, STATUS
    logical, parameter :: deeBug = .false.
    ! Executable code
    nameStr = ' '
    if ( vector%name > 0 ) &
      & call get_string ( vector%name, nameStr )
    if ( deeBug .and. len_trim(nameStr) > 0 ) &
      & call output ( 'Destroying Vector ' // trim(nameStr), advance='yes' )
    vector%name = 0
    vector%where = where_t(0,0)

    if ( .not. associated(vector%quantities) ) return
    if ( deeBug ) call output ( 'Destroying VectorValue', advance='yes' )
    call destroyVectorValue ( vector )
    if ( deeBug ) call output ( 'Destroying VectorMask', advance='yes' )
    call destroyVectorMask ( vector )
    s = size(vector%quantities) * storage_size(vector%quantities) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(vector%quantities(1)), addr)
    if ( deeBug ) call output ( 'Deallocating its quantities', advance='yes' )
    deallocate ( vector%quantities, stat=status )
    call test_deallocate ( status, moduleName, 'vector%quantities', s, address=addr )
  end subroutine DestroyVectorInfo

  ! ------------------------------------------  DestroyVectorMask  -----
  subroutine DestroyVectorMask ( Vector )

  ! This routine destroys the masks stored in the vector.

    ! Dummy arguments
    type (Vector_T), intent(inout) :: VECTOR

    ! Local Variables:
    integer :: I
    do i = 1, size(vector%quantities)
      call destroyVectorQuantityMask ( vector%quantities(i) )
    end do
  end subroutine DestroyVectorMask

  ! ----------------------------------  DestroyVectorQuantityMask  -----
  subroutine DestroyVectorQuantityMask ( Value, ForWhom )

    ! This routine destroys the MASK stored in one vector quantity.

    ! Dummy arguments
    type (vectorValue_t), intent(inout) :: Value
    character(len=*), intent(in), optional :: ForWhom
    if ( present(forWhom) ) then
      call deallocate_test ( value%mask1, trim(forWhom) // "%MASK1", moduleName )
    else
      call deallocate_test ( value%mask1, "MASK1", moduleName )
    end if
    nullify ( value%mask, value%mask3 )
  end subroutine DestroyVectorQuantityMask

  ! ---------------------------------  DestroyVectorQuantityValue  -----
  subroutine DestroyVectorQuantityValue ( VALUE, &
    & DESTROYMASK, DESTROYTEMPLATE, FORWHOM )

    ! This routine destroys the VALUES stored in one vector quantity.

    ! Dummy arguments
    type (vectorValue_t), intent(inout)    :: VALUE
    logical, intent(in), optional          :: DESTROYMASK
    logical, intent(in), optional          :: DESTROYTEMPLATE
    character(len=*), intent(in), optional :: FORWHOM
    ! Executable
    call deallocate_test ( value%value1, trim(value%allocationName), moduleName )
    nullify ( value%values, value%value3 )
    if ( present(destroyMask) ) then
      if ( destroyMask ) call destroyVectorQuantityMask ( value, forWhom )
    end if
    if ( present(destroyTemplate) ) then
      if ( destroyTemplate ) call DestroyQuantityTemplateContents ( value%template )
    end if
    if ( associated(value%BinNumber) ) then
      deallocate(value%BinNumber)
      nullify(value%BinNumber)
    endif
    if ( associated(value%MAF) ) then
      deallocate(value%MAF)
      nullify(value%MAF)
    endif
  end subroutine DestroyVectorQuantityValue

  ! ------------------------------  DestroyVectorTemplateDatabase  -----
  subroutine DestroyVectorTemplateDatabase ( database )

  ! This subroutine destroys a vector template database

    ! Dummy argument
    type (VectorTemplate_T), dimension(:), pointer :: database

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: l2gpIndex, S, Status

    if ( associated(database) ) then
      do l2gpIndex = 1, SIZE(database)
         call DestroyVectorTemplateInfo ( database(l2gpIndex) )
      end do
      s = size(database) * storage_size(database) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(database(1)), addr)
      deallocate ( database, stat=status )
      call test_deallocate ( status, moduleName, 'database', s, address=addr )
    end if
  end subroutine DestroyVectorTemplateDatabase

  ! ----------------------------------  DestroyVectorTemplateInfo  -----
  subroutine DestroyVectorTemplateInfo ( VectorTemplate )

  ! This subroutine destroys a vector template created above

    ! Dummy arguments
    type (VectorTemplate_T), intent(inout) :: vectorTemplate

    ! Executable code

    call deallocate_test ( vectorTemplate%quantities, &
      & "vectorTemplate%quantities", ModuleName )

    vectorTemplate%noQuantities = 0
    vectorTemplate%totalInstances = 0
    vectorTemplate%totalElements = 0
    vectorTemplate%name = 0
    vectorTemplate%where = where_t(0,0)
  end subroutine DestroyVectorTemplateInfo

  ! -----------------------------------------  DestroyVectorValue  -----
  subroutine DestroyVectorValue ( Vector )
  ! Destroy the "values" field in all of the quantities in a vector.  This
  ! is useful when forming normal equations little-by-little.
    type(vector_T), intent(inout) :: Vector

    integer :: I

    if ( .not. associated(vector%quantities) ) return
    do i = 1, size(vector%quantities)
      call destroyVectorQuantityValue ( vector%quantities(i) )
    end do
  end subroutine DestroyVectorValue

  ! ---------------------------------------  DiffVectorQuantities  -----
  subroutine DiffVectorQuantities ( Qty1, Qty2, Name, Options )

    type (VectorValue_T), intent(in) :: QTY1, QTY2
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: OPTIONS

    if ( present(name) ) then
      if ( len_trim(name) > 0 ) then
        call output ( name )
        call output ( ', ' )
      end if
    end if
    call output ( ' Qty_Template_Name = ' )
    if ( qty1%template%name /= 0 ) then
      call display_string ( qty1%template%name )
    else
      call output ( '<none given>' )
    end if
    if ( qty1%label /= 0 ) then
      call output ( ', label = ' )
      call display_string ( qty1%label )
    else
      call output ( ' unlabeled ', advance='yes' )
    end if
    call diff ( qty1%values, 'quantity(1) values', &
      &         qty2%values, 'quantity(2) values', options=options )
  end subroutine DiffVectorQuantities

  ! ----------------------------------------------  DivideVectors  -----
  subroutine DivideVectors ( A, X, Y )
  ! Y = A / X if Y is present, else A = A / X, element-by-element.
  ! If the mask field of X's vector value is associated, only do the
  ! divide where the m_linalg bit is zero.

    ! Dummy arguments:
    type(Vector_T), intent(inout), target :: A
    type(Vector_T), intent(in) :: X
    type(Vector_T), intent(inout), optional, target :: Y
    ! Local Variables:
    integer :: I              ! Subscript and loop inductor
    type(Vector_T), pointer :: Z
    ! Executable statements:
    if ( x%template%name /= a%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, 'Numerator vector has different template from denominator' )
    z => a
    if ( present(y) ) then
      if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, 'Quotient vector has different template from original' )
      z => y
    end if
    do i = 1, size(x%quantities)
      if ( associated(x%quantities(i)%mask) ) then
        where ( iand(ichar(x%quantities(i)%mask),m_linalg) == 0 )
          z%quantities(i)%values = a%quantities(i)%values / x%quantities(i)%values
        elsewhere
          z%quantities(i)%values = 0
        end where
      else
        z%quantities(i)%values = a%quantities(i)%values / x%quantities(i)%values
      end if
    end do
  end subroutine DivideVectors

  ! -------------------------------------------------  DotVectors  -----
  real(rv) function DotVectors ( X, Y ) result (Z)
  ! Compute the inner product of two vectors.

    ! Dummy arguments:
    type(Vector_T), intent(in) :: X, Y
    ! Executable statements:
    if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot .DOT. vectors having different templates" )
    z = sum( x%quantities .dot. y%quantities )
  end function DotVectors

  ! -------------------------------------------  DotVectorsMasked  -----
  real(rv) function DotVectorsMasked ( X, Y ) result (Z)
  ! Compute the inner product of two vectors.  Ignore elements masked
  ! by m_linAlg in either X or Y.

    ! Dummy arguments:
    type(Vector_T), intent(in) :: X, Y
    ! Executable statements:
    if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot .MDOT. vectors having different templates" )
    z = sum( x%quantities .mdot. y%quantities )
  end function DotVectorsMasked

  ! --------------------------------------  DotVectorsMaybeMasked  -----
  real(rv) function DotVectorsMaybeMasked ( X, Y, UseMask ) result (Z)
  ! Compute the inner product of two vectors.  If UseMask is present and
  ! true, the masks are respected.
    type(vector_t), intent(in) :: X, Y
    logical, intent(in), optional :: UseMask
    logical MyMask
    myMask = .false.
    if ( present(useMask) ) myMask = useMask
    if ( myMask ) then
      z = x .mdot. y
    else
      z = x .dot. y
    end if
  end function DotVectorsMaybeMasked

  ! ----------------------------------------  DotVectorQuantities  -----
  elemental real(rv) function DotVectorQuantities ( X, Y ) result ( Z )
  ! Compute the inner product of two vector quantities
    type(VectorValue_T), intent(in) :: X, Y
    z = sum( x%values * y%values )
  end function DotVectorQuantities

  ! ----------------------------------  DotVectorQuantitiesMasked  -----
  elemental real(rv) function DotVectorQuantitiesMasked ( X, Y ) result ( Z )
  ! Compute the inner product of two vector quantities, respecting their
  ! masks, if any
    type(VectorValue_T), intent(in) :: X, Y
    if ( associated(x%mask) ) then
      if ( associated(y%mask) ) then
        z = sum( x%values * y%values, &
               & iand(iand(ichar(x%mask), ichar(y%mask)), m_linAlg) == 0 )
      else
        z = sum( x%values * y%values, iand(ichar(x%mask), m_linAlg) == 0 )
      end if
    else if ( associated(y%mask) ) then
      z = sum( x%values * y%values, iand(ichar(y%mask), m_linAlg) == 0 )
    else
      z = sum( x%values * y%values )
    end if
  end function DotVectorQuantitiesMasked

  ! -----------------------------  DotVectorQuantitiesMaybeMasked  -----
  elemental real(rv) function DotVectorQuantitiesMaybeMasked ( X, Y, UseMask ) &
    & result ( Z )
  ! Compute the inner product of two vector quantities, respecting their
  ! masks, if any, if UseMask is present and true
    type(VectorValue_T), intent(in) :: X, Y
    logical, intent(in), optional :: UseMask
    logical :: MyMask
    myMask = .false.
    if ( present(useMask) ) myMask = useMask
    if ( myMask ) then
      z = x .mdot. y
    else
      z = x .dot. y
    end if
  end function DotVectorQuantitiesMaybeMasked

  ! ----------------------------------------  DumpNiceMaskSummary  -----
  ! This routine tries to produce a useful human readable dump of a vector
  ! mask.
  subroutine DumpNiceMaskSummary ( qty, prefix, masksToDump )
    type(VectorValue_T), intent(in) :: qty
    character(len=*), intent(in), optional :: prefix
    integer, dimension(:), intent(in) :: masksToDump
    ! Local variables
    integer :: I, C, M                  ! Loop counters
    integer :: S0, S1                   ! Delimiters
    character, dimension ( qty%template%instanceLen ) :: MERGEDMASK ! Merge of all the masks we have
    character, dimension ( qty%template%noSurfs ) :: EXTRACTEDMASK ! Subset of merged mask for a channel
    logical, dimension ( qty%template%noSurfs ) :: THISMASK ! This particular mask flags
    logical :: VARIES                   ! Masking varies from instance to instance
    logical :: CONTINUOUS               ! Masking is in one continuous block
    character(len=2) :: CHANOFFSET      ! My prefix

    ! Executable code
    if ( .not. associated ( qty%mask ) ) then
      if ( present ( prefix ) ) call output ( prefix )
      call output ( 'This quantity has no subsetting in force.', advance='yes' )
    else
      mergedMask = qty%mask(:,1)
      varies = .false.
      do i = 2, qty%template%noInstances
        if ( any ( qty%mask(:,i) /= mergedMask ) ) then
          varies = .true.
          mergedMask = char ( iand ( ichar ( qty%mask(:,i) ), ichar ( mergedMask ) ) )
        end if
      end do
      if ( present ( prefix ) ) call output ( prefix )
      if ( varies ) then
        call output ( 'Subsetting varies from instance to instance, printing widest', advance='yes' )
      else
        call output ( 'Subsetting is constant for all instances', advance='yes' )
      end if
      do c = 1, qty%template%noChans
        chanOffset = ''
        if ( qty%template%noChans /= 1 ) then
          if ( present ( prefix ) ) call output ( prefix )
          call output ( 'Channel: ' )
          if ( size ( masksToDump ) == 1 ) then
            call output ( c )
            call output ( ' - ' )
          else
            call output ( c, advance='yes' )
            chanOffset = '  '
          end if
        end if
        extractedMask = (/ (mergedMask(c+(i-1)*qty%template%noChans), i=1, qty%template%noSurfs) /)
        ! Now have the flags for this channel, lets describe them in a helpful manner
        do m = 1, size ( masksToDump )
          thisMask = iand ( ichar ( extractedMask ), masksToDump(m) ) == 1
          call output ( chanOffset )
          ! Do a nice name for the mask
          select case ( masksToDump ( m ) )
          case ( m_ignore )
            call output ( 'Ignored: ' )
          case ( m_linAlg )
            call output ( 'Retrieved / used: ' )
          case ( m_tikhonov )
            call output ( 'Smoothed: ' )
          case ( m_fill )
            call output ( 'Fill: ' )
          case ( m_fullDerivatives )
            call output ( 'Full derivatives: ' )
          case ( m_spare )
            call output ( 'Spare mask: ' )
          end select
              
          s0 = FindFirst ( .not. thisMask )
          if ( s0 /= 0 ) then
            s1 = FindFirst ( thisMask(s0:) )
            if ( s1 == 0 ) then
              s1 = qty%template%noSurfs
            else
              s1 = s1 + s0 - 2
            end if
            continuous = count ( .not. thisMask ) == s1 - s0 + 1
            if ( s0 /= 1 .and. s1 /= qty%template%noSurfs ) then
              call outputNiceSurface ( qty%template%surfs(s0,1), qty%template%verticalCoordinate )
              call output ( ' -> ' )
              call outputNiceSurface ( qty%template%surfs(s1,1), qty%template%verticalCoordinate )
            else
              call output ( 'Everywhere' )
            end if
            if ( continuous ) then
              call output ( ' uninterrupted.', advance='yes' )
            else
              call output ( ' with gaps', advance='yes' )
            end if
          else
            call output ( ' Nowhere', advance='yes' )
          end if
        end do

      end do
    end if
  contains
    ! - - - - - - - - - - -  OutputNiceSurface
    subroutine OutputNiceSurface ( value, coordinate )
      use Intrinsic, only: L_Angle, L_Geodaltitude, L_Gph, L_None, &
        & L_Pressure, L_Theta, L_Zeta
      real(r8), intent(in) :: VALUE
      integer, intent(in) :: COORDINATE
      ! Executable code
      real(r8) :: P
      select case ( coordinate )
      case ( l_angle )
        call output ( value, format='(f0.1)' )
        call output ( ' degrees' )
      case ( l_geodAltitude, l_gph )
        call output ( value/1e3, format='(f0.2)' )
        call output ( ' km' )
      case ( l_none )
        call output ( 'No surface' )
      case ( l_pressure, l_zeta )
        if ( coordinate == l_pressure ) then
          p = value
        else
          p = 10.0**(-value)
        end if
        if ( p > 10.0 ) then
          call output ( nint ( p ) )
        else if ( p >= 1.0 ) then
          call output ( p, format='(F0.1)' )
        else if ( p >= 0.1 ) then
          call output ( p, format='(F0.2)' )
        else if ( p >= 0.01 ) then
          call output ( p, format='(F0.3)' )
        else
          call output ( p, format='(F0.5)' )
        end if
        call output ( ' hPa' )
      case ( l_theta )
        call output ( value, format='(i0)' )
        call output ( ' K' )
      end select
    end subroutine OutputNiceSurface

  end subroutine DumpNiceMaskSummary

  ! -----------------------------------------  DumpQuantityMask  -----
  ! Dump a quantity's mask with details and options set by those args:
  ! Details             effect is to print ..
  ! -------             ---------------------
  !   -1        how many locations have their bitnumth bit set 
  !   0         how many unique bitnumbers have been set and their meanings
  !   1         a table of mask bits by location
  
  ! options contain   effect
  ! ---------------   ------
  !    b[n]         set bitnum to n (default was 0)
  !     l           collapse locations to just instances, showing
  !                   only if bitnumth bit set at all heights, channels
  !     L           collapse locations to just instances, showing
  !                   only if bit NOT set at all heights, channels
  !
  subroutine DumpQuantityMask ( VECTORQUANTITY, DETAILS, OPTIONS )
    use MLSStringLists, only: ExpandStringRange, OptionDetail
    use MLSStrings, only: ReadNumsFromChars
    type (VectorValue_T), intent(in)       :: VectorQuantity
    integer, intent(in), optional          :: DETAILS ! if < 0 just dump summary
    character(len=*), optional, intent(in) :: options

    ! Local variables
    character(len=32) :: bitCh
    integer :: bitNum                   ! bit number; e.g., 0 is m_linAlg
    integer, dimension(18) :: bitNums
    integer :: c                        ! Channel index
    integer :: i                        ! Instance index
    integer :: j                        ! Element index
    integer :: k                        ! bitNums index
    integer :: myDetails
    character(len=32) :: myOptions
    integer :: n
    integer :: nBitNums
    integer :: nUnique
    integer :: s                        ! Surface index
    integer, dimension(10000) :: uniqueVals
    integer :: w                        ! Line width used so far
    ! Executable
    nUnique = 0
    uniqueVals = 0
    myDetails = 0
    if ( present(details) ) myDetails = details
    myOptions = ' '
    if ( present(options) ) myOptions = options
    bitNum = 0
    nBitNums = -1
    if ( index(myOptions, 'b') > 0 ) then
      bitCh = optionDetail( myOptions, single_option='b' )
      if ( index( bitCh, ',' ) > 0 .or. index( bitCh, '-' ) > 0 ) then
        call ExpandStringRange ( bitCh, bitNums, nBitNums )
      else
        call readNumsFromChars( bitCh, bitnum )
      end if
    end if
    if ( nBitNums < 0 ) then
      nBitNums = 1
      bitNums(1) = bitNum
    end if
    call output ( 'Quantity ' )
    call display_string ( vectorQuantity%template%name )

    if ( .not. vectorQuantity%template%regular ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName,&
      & 'Unable to dump mask for irregular quantities' )

    if ( .not. associated ( vectorQuantity%mask ) ) then
      call output ( ' has no mask.', advance='yes' )
      return
    else if( myDetails == 0 ) then
      call dump ( ichar(vectorQuantity%mask), name='  Mask =', &
        & format='(z3.2)', width = 20 )
      call FindUnique( &
      & reshape( ichar(vectorQuantity%mask), (/ size(vectorQuantity%mask,1)*size(vectorQuantity%mask,2) /) ), &
      & uniqueVals, nUnique )
      call outputNamedValue(' Number unique values', nUnique )
      do i=1, nUnique
        call DumpBitNames( uniqueVals(i), MaskBitNames )
      end do
      return
    else if ( index(myOptions, 'l') < 1 .and. index(myOptions, 'L') < 1 ) then
      call newLine
      do i = 1, vectorQuantity%template%noInstances
        call output ( 'Instance: ' )
        call output ( i, advance='yes' )
        j = 0
        do s = 1, vectorQuantity%template%noSurfs
          call output ( 'Surface ' )
          call output ( s )
          call output ( ': ' )
          w = 13
          do c = 1, vectorQuantity%template%noChans
            if ( w > 74 ) then
              call newLine
              call output ( '      ' )
              w = 6
            end if
            w = w + 3
            j = j + 1
            call output ( ichar(vectorQuantity%mask(j,i)), &
              & format='(z3.2)' )
          end do
          call newLine
        end do                        ! Surface loop
      end do                          ! Instance loop
      return
    end if
    ! These are the cases where we show results broken down by bit numbers
    do k=1, nBitNums
      nUnique = 0
      uniqueVals = 0
      bitnum = bitNums(k)
      if ( nBitNums > 1 ) then
        call newLine
        call outputnamedvalue( 'bit number', bitnum )
        call DumpBitNames( 2**bitnum, MaskBitNames, oneLine=.true. )
      end if
      if( myDetails < 0 ) then
        n = count( isBitSet( ichar(vectorQuantity%mask), bitNum ) )
        call outputNamedValue( 'Num mask bits set: ', n )
      else if ( index(myOptions, 'l') > 0 ) then
        ! Collapse locations, showing where entirely masked channels and surfaces
        do i = 1, vectorQuantity%template%noInstances
          if ( any( &
            & .not. isBitSet( ichar(vectorQuantity%mask(:,i)), bitNum ) &
            & ) ) cycle
          nUnique = nUnique + 1
          uniqueVals ( nUnique ) = i
        end do
        if ( nUnique > 0 ) then
          call dump( uniqueVals(1:nUnique), ': Locations entirely masked' )
        else
          call output( ': No locations entirely masked', advance = 'yes' )
        end if
      else if ( index(myOptions, 'L') > 0 ) then
        ! Collapse locations, showing where NOT masked
        do i = 1, vectorQuantity%template%noInstances
          if ( all( &
            & isBitSet( ichar(vectorQuantity%mask(:,i)), bitNum ) &
            & ) ) cycle
          nUnique = nUnique + 1
          uniqueVals ( nUnique ) = i
        end do
        if ( nUnique > 0 ) then
          call dump( uniqueVals(1:nUnique), ': Locations not entirely masked' )
        else
          call output( ': All locations entirely masked', advance = 'yes' )
        end if
      end if
    end do
  end subroutine DumpQuantityMask

  ! ---------------------------------------------  DumpVectorMask  -----
  subroutine DumpVectorMask ( VECTOR, DETAILS, OPTIONS )
    type (Vector_T), intent(in) :: VECTOR
    integer, intent(in), optional :: DETAILS ! if < 0 just dump summary
    character(len=*), optional, intent(in) :: options

    ! Local variables
    integer :: q                        ! Quantity index

    ! Executable code
    call output ( 'Dumping mask for vector ' )
    call display_string ( vector%name, advance='yes' )

    do q = 1, size(vector%quantities)
      call dumpMask ( vector%quantities(q), details, options )
    end do                              ! Loop over quantities
  end subroutine DumpVectorMask
  ! --------------------------------------------  DumpVectorNorms  -----
  subroutine DumpVectorNorms ( Vector, Level, Name, UseMask )
    type (Vector_T), intent(in) :: Vector
    integer, intent(in) :: Level ! <=0 => Whole vector norm, 
                                 ! 1 => quantity norms,
                                 ! >= 2 => quantity norms with quantity names
    character(*), intent(in), optional :: Name
    logical, intent(in), optional :: UseMask
    integer :: Q
    select case ( level )
    case ( :0 )
      if ( present(name) ) call output ( name )
      call output ( l2norm ( vector, useMask ) )
    case ( 1 )
      call dump ( l2norm ( vector%quantities, useMask ), name )
    case ( 2 )
      if ( present(name) ) call output ( name, advance='yes' )
      do q = 1, size(vector%quantities)
        call output ( q, format='(i4)', after='# ' )
        call display_string ( vector%quantities(q)%template%name )
        call output ( l2norm(vector%quantities(q),useMask), before=': ', &
          & advance='yes' )
      end do
    end select
  end subroutine DumpVectorNorms

  ! ------------------------------------------------  Dump_Vector  -----
  subroutine Dump_Vector ( VECTOR, DETAILS, OPTIONS, NAME, &
    & QUANTITYTYPES, INSTRUMENTMODULES, SIGNAL_IDS, &
    & COHERENT, STACKED, REGULAR, MINORFRAME, MAJORFRAME, &
    & THENDITCHAFTERDUMP, CLEAN )

    use Lexer_Core, only: Print_Source

    ! dump quantities in vector according to whether they match
    ! all of the optional args: name, ..,majorframe
    ! if thenditchafterdump is present and TRUE,
    ! dump only first matching quantity
    type(Vector_T), intent(in) :: VECTOR
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump quantity values
    !                                        ! -1 Skip quantity details beyond names
    !                                        ! -2 Skip all quantity details but
                                             !    print a size summary
                                             ! <= -3 => no output
    !                                        ! >0 Do dump quantity values
    !                                        ! Default 1
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: OPTIONS
    ! if the following are present, dump only quantities matching them
    integer, intent(in), optional, dimension(:)  :: QUANTITYTYPES
    integer, intent(in), optional, dimension(:)  :: INSTRUMENTMODULES
    integer, intent(in), optional, dimension(:)  :: SIGNAL_IDS
    logical, intent(in), optional                :: COHERENT
    logical, intent(in), optional                :: STACKED
    logical, intent(in), optional                :: REGULAR
    logical, intent(in), optional                :: MINORFRAME
    logical, intent(in), optional                :: MAJORFRAME
    logical, intent(in), optional                :: THENDITCHAFTERDUMP
    logical, intent(in), optional                :: CLEAN

    ! Local parameters
    logical :: dumpThisQty
    integer :: J    ! Loop inductor, subscript
    integer :: MyDetails
    logical :: myditchafterdump
    character(len=8) :: myOptions
    integer :: TotalSize
    
    myDetails = 1
    if ( present(details) ) myDetails = details
    if ( myDetails <= -3 ) return

    if ( present(thenditchafterdump) ) then
      myditchafterdump = thenditchafterdump
    else
      myditchafterdump = .false.
    end if

    totalSize = 0

    if ( present(name) ) then
      call output ( name ); call output ( ', ' )
    end if
    if ( vector%name /= 0 ) then
      call output ( 'Name = ' )
      call display_string ( vector%name )
    end if
    if ( vector%where%source /= 0 ) then
      call output ( ' created at ' )
      call print_source ( vector%where )
    end if
    if ( vector%template%name /= 0 ) then
      call output ( ' Template_Name = ' )
      call display_string ( vector%template%name )
    end if
    call newline
    myoptions = ' '
    if ( present(clean) ) then
      if ( clean ) myoptions = 'c'
    end if
    if ( present(options) ) myOptions = trim(myOptions) // options
    do j = 1, size(vector%quantities)
      dumpThisQty = myDetails > -2
      if ( associated(vector%quantities(j)%values) ) &
        & totalSize = totalSize + size(vector%quantities(j)%values)
      if ( present (quantitytypes) ) dumpThisQty = &
        & any(vector%quantities(j)%template%quantitytype == quantitytypes)
      if ( present (instrumentmodules) ) dumpThisQty = &
        & any(vector%quantities(j)%template%instrumentmodule == instrumentmodules)
      if ( present (signal_ids) ) dumpThisQty = &
        & any(vector%quantities(j)%template%signal == signal_ids)
      if ( present (coherent) ) dumpThisQty = dumpThisQty .and. &
        & (vector%quantities(j)%template%coherent .eqv. coherent)
      if ( present (stacked) ) dumpThisQty = dumpThisQty .and. &
        & (vector%quantities(j)%template%stacked .eqv. stacked)
      if ( present (regular) ) dumpThisQty = dumpThisQty .and. &
        & (vector%quantities(j)%template%regular .eqv. regular)
      if ( present (minorFrame) ) dumpThisQty = dumpThisQty .and. &
        & (vector%quantities(j)%template%minorFrame .eqv. minorFrame)
      if ( present (majorFrame) ) dumpThisQty = dumpThisQty .and. &
        & (vector%quantities(j)%template%majorFrame .eqv. majorFrame)
      if ( dumpThisQty ) then
        call output ( j, 4, after="~" )
        call dump ( vector%quantities(j), details, options=myOptions )
        if ( myditchafterdump ) return
      end if
    end do ! j
    if ( myDetails == -2 ) then
      call output ( size(vector%quantities), before='      having ' )
      call output ( totalSize, before=' quantities and ' )
      call output ( ' elements.', advance='yes' )
    end if
  end subroutine Dump_Vector

  ! -----------------------------------------------  Dump_Vectors  -----
  subroutine Dump_Vectors ( VECTORS, DETAILS, OPTIONS, NAME, &
    & QUANTITYTYPES, INSTRUMENTMODULES, SIGNAL_IDS, &
    & COHERENT, STACKED, REGULAR, MINORFRAME, MAJORFRAME, &
    & THENDITCHAFTERDUMP )
    ! dump all vectors according to whether their quantities match
    ! all of the optional args: name, ..,majorframe
    ! if thenditchafterdump is present and TRUE,
    ! dump only first matching vector
    type(Vector_T), intent(in) :: VECTORS(:)
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump quantity values
    !                                        ! -1 Skip quantity details beyond names
    !                                        ! -2 Skip all quantity details
    !                                        ! -3 Just summarize the database
    !                                        ! >0 Do dump quantity values
    !                                        ! Default 1
    character(len=*), intent(in), optional :: NAME
    character(len=*), intent(in), optional :: OPTIONS
    ! if the following are present, dump only quantities matching them
    integer, intent(in), optional, dimension(:)  :: QUANTITYTYPES
    integer, intent(in), optional, dimension(:)  :: INSTRUMENTMODULES
    integer, intent(in), optional, dimension(:)  :: SIGNAL_IDS
    logical, intent(in), optional                :: COHERENT
    logical, intent(in), optional                :: STACKED
    logical, intent(in), optional                :: REGULAR
    logical, intent(in), optional                :: MINORFRAME
    logical, intent(in), optional                :: MAJORFRAME
    logical, intent(in), optional                :: THENDITCHAFTERDUMP

    ! Local parameters
    integer :: I
    logical :: dumpThisQty
    logical :: dumpThisVector
    integer :: J
    integer :: MyDetails
    logical :: MyDitchAfterDump
    integer :: TotalSize ! of vector quantities

    myDetails = 1
    if ( present(details) ) myDetails = details
    if ( present(thenditchafterdump) ) then
      myditchafterdump = thenditchafterdump
    else
      myditchafterdump = .false.
    end if
    if ( size(vectors) > 1 ) &
      & call output ( size(vectors), before='VECTORS: SIZE = ', advance='yes' )

    totalSize = 0

    do i = 1, size(vectors)
      ! Presume do not need to dump vector; hence preset to FALSE -- 
      ! becomes TRUE if wish to dump one or more quantities
      dumpThisVector = .false.
      if ( .not. associated(vectors(i)%quantities) .and. myDetails > -3 ) then
        call output ( '(entry  ', advance='no' )
        call output ( i, advance='no' )
        call output ( '  in the vector database had been destroyed)  ', &
        & advance='yes' )
        cycle
      end if
      do j=1, size(vectors(i)%quantities)
        if ( associated(vectors(i)%quantities(j)%values) ) &
          totalSize = totalSize + size(vectors(i)%quantities(j)%values)
        ! Presume need to dump quantity; hence preset to TRUE --
        ! becomes FALSE if fails to match a requirement
        dumpThisQty = myDetails > -3
        ! Check on requirements
        if ( present (quantitytypes) ) dumpThisQty = &
          & any(vectors(i)%quantities(j)%template%quantitytype == quantitytypes)
        if ( present (instrumentmodules) ) dumpThisQty = &
          & any(vectors(i)%quantities(j)%template%instrumentmodule == instrumentmodules)
        if ( present (signal_ids) ) dumpThisQty = &
          & any(vectors(i)%quantities(j)%template%signal == signal_ids)
        if ( present (coherent) ) dumpThisQty = dumpThisQty .and. &
          & (vectors(i)%quantities(j)%template%coherent .eqv. coherent)
        if ( present (stacked) ) dumpThisQty = dumpThisQty .and. &
          & (vectors(i)%quantities(j)%template%stacked .eqv. stacked)
        if ( present (regular) ) dumpThisQty = dumpThisQty .and. &
          & (vectors(i)%quantities(j)%template%regular .eqv. regular)
        if ( present (minorFrame) ) dumpThisQty = dumpThisQty .and. &
          & (vectors(i)%quantities(j)%template%minorFrame .eqv. minorFrame)
        if ( present (majorFrame) ) dumpThisQty = dumpThisQty .and. &
          & (vectors(i)%quantities(j)%template%majorFrame .eqv. majorFrame)
        dumpThisVector = dumpThisVector .or. dumpThisQty
      end do
      if ( dumpThisVector ) then
        call output ( i, 4 )
        call output ( ': ' )
        call dump_vector ( vectors(i), details, options, name, &
        & quantitytypes, instrumentmodules, signal_ids, &
        & coherent, stacked, regular, minorframe, majorframe, &
        & thenditchafterdump )
        if ( myditchafterdump ) return
      end if
    end do ! i
    call output ( size(vectors), before='Vectors database has ' )
    call output ( totalSize, before=' vectors with ' )
    call output ( ' elements.', advance='yes' )
  end subroutine Dump_Vectors

  ! ---------------------------------------  Dump_Vector_Quantity  -----
  subroutine Dump_Vector_Quantity ( Qty, Details, Name, Vector, Options )

    use Pointer_Rank_Remapping, only: Remap

    type (VectorValue_T), intent(in) :: Qty
    integer, intent(in), optional :: Details ! <0  => Name only
    !                                        ! <-1 => No newline after name
    !                                        ! =0  => No values
    !                                        ! >0  => Dump quantity values
    !                                        ! >1  => Dump template with details-1
    !                                        ! Default 1
    character(len=*), intent(in), optional :: Name
    type (Vector_T), intent(in), optional  :: Vector ! Only to get its name
    character(len=*), intent(in), optional :: Options ! E.g., '-sb'
    ! If options is present and
    ! contains        dump        but skip
    !    1            values     template data
    !    2            values     most template data
    !    3        values and template data
    ! Internal variables
    logical, parameter :: deeBug = .false.  ! Should this also affect Details?
    logical :: Dot ! Use vector.quantity notation
    integer :: i
    character(len=32) :: oldInfo
    integer :: myDetails
    character(len=8) :: myOptions
    integer :: nUnique
    integer, dimension(1000) :: uniqueVals
    real(rv), pointer :: value4(:,:,:,:) ! Remapping of Qty%values

    ! Executable
    myDetails = 1
    if ( present(details) ) myDetails = details
    myOptions = ' '
    if ( present(options) ) myOptions = options
    oldInfo = MLSMessageConfig%Info
    if ( present(name) ) then
      MLSMessageConfig%Info = name
      call output ( name ); call output ( ', ' )
    else if ( qty%template%name /= 0 ) then
      call get_string ( qty%template%name, MLSMessageConfig%Info )
    end if
    if ( .not. index(myOptions, '1') > 0 ) then
      dot = .false.
      if ( present(vector) ) dot = vector%name /= 0
      if ( dot ) then
        call output ( ' Vector quantity name = ' )
        if ( vector%name /= 0 ) then
          call display_string ( vector%name )
        else
          call output ( '<none given>' )
        end if
        if ( qty%template%name /= 0 ) then
          call display_string ( qty%template%name, before='.' )
        else
          call output ( '.<none given>' )
        end if
      else
        call output ( ' Qty_Template_Name = ' )
        if ( qty%template%name /= 0 ) then
          call display_string ( qty%template%name )
        else
          call output ( '<none given>' )
        end if
      end if
      if ( qty%label /= 0 ) then
        call output ( ', label = ' )
        call display_string ( qty%label )
      else
        call output ( ' unlabeled ', advance='yes' )
      end if
      if ( myDetails < -1 ) then
        MLSMessageConfig%Info = oldInfo
        return
      end if
      call newLine
      if ( myDetails < 0 ) then
        MLSMessageConfig%Info = oldInfo
        return
      end if
    else if ( qty%template%name /= 0 ) then
      call display_string ( qty%template%name, before='.' )
    end if
    if ( .not. index(myOptions, '1') > 0 &
      & .and. .not. index(myOptions, '2') > 0 ) then
      if ( qty%template%quantityType == l_vmr ) then
        call output ( '    molecule: ')
        if ( qty%template%molecule < 1 ) then
          call output ( '    (no database entry for this quantity) ' )
        else
          call display_string ( lit_indices(qty%template%molecule) )
        end if
      else if ( qty%template%quantityType > 0 ) then
        call output( '    Quantity type: ', advance='no' )
        call display_string ( lit_indices(qty%template%quantityType), advance='yes' )
      end if
      call output ( qty%template%noChans, before='    noChans = ' )
      call output ( qty%template%noSurfs, before=' noSurfs = ' )
      call output ( qty%template%noInstances, before=' noInstances = ')
      call output ( qty%template%noCrossTrack, before=' noCrossTrack = ' )
      call output ( qty%template%instanceLen, before=' instanceLen = ', advance='yes')
      call output ( '    signal: ')
      if ( qty%template%signal < 1 ) then
        call output ( '    (no database entry for this quantity) ', advance='yes')
      else if ( signals(qty%template%signal)%name < 1 ) then
        call output ( '    (no name in the database for this quantity) ', advance='yes')
      else
        call display_string ( signals(qty%template%signal)%name, advance='yes' )
      end if
      call output ( '    instrumentmodule: ')
      if ( qty%template%instrumentModule < 1 ) then
        call output ( '    (no database entry for this quantity)', advance='yes' )
      else
        call display_string ( modules(qty%template%instrumentModule)%name, advance='yes' )
      end if
      call output ( '    ' )
      if ( .not. qty%template%coherent ) call output ( 'in' )
      call output ( 'coherent ' )
      if ( .not. qty%template%stacked ) call output ( 'non' )
      call output ( 'stacked ' )
      if ( .not. qty%template%regular ) call output ( 'ir' )
      call output ( 'regular ' )
      if ( qty%template%logBasis ) then
        call output ('log-')
      else
        call output ('linear-')
      end if
      call output ('basis ' )
      call output ( trim(merge('   ','non',qty%template%minorFrame)) // &
        & 'minorFrame' )
      call output ( ' ' // trim(merge('   ','non',qty%template%majorFrame)) // &
      & 'majorFrame', advance='yes' )
      if ( size(qty%values) > 0 ) then
        call output ( '    values array size is ' )
        if ( qty%template%noChans > 1 ) then
          call output ( qty%template%noChans )
          call output ( 'x' )
        end if
        call output ( qty%template%noSurfs )
        call output ( qty%template%noInstances, before='x' )
        if ( qty%template%noCrossTrack > 1 ) &
          & call output ( qty%template%noCrossTrack, before='x' )
        call output ( size(qty%values), before=' = ' )
      else
        call output ( '    values array size is 0' )
      end if
    end if
    if ( .not. associated(qty%values) ) then
      call output( 'values array is not associated', advance='yes' )
    else if ( size(qty%values) < 1 ) then
      call output( 'values is a 0-size array', advance='yes' )
    else if ( myDetails > 0 ) then
      call newLine
      call remap ( qty%values, value4, &
        & [ qty%template%noChans, qty%template%noSurfs, &
        &   qty%template%noInstances, qty%template%noCrossTrack ] )
    ! value4(1:qty%template%noChans,1:qty%template%noSurfs, &
    !       &1:qty%template%noInstances,1:qty%template%noCrossTrack) => qty%values
      call dump ( value4, '  Elements = ', options=options )
      if ( associated(qty%mask) ) then
        call dump ( ichar(qty%mask), name='  Mask(hex) =', &
          & format='(z3.2)', width = 20 )
!           call dumpQuantityMask ( qty )
        call FindUnique( &
        & reshape( ichar(qty%mask), (/ size(qty%mask,1)*size(qty%mask,2) /) ), &
        & uniqueVals, nUnique )
        call outputNamedValue(' Number unique values', nUnique )
        do i=1, nUnique
          call DumpBitNames( uniqueVals(i), MaskBitNames )
        end do
      else
        call output ( '      Without mask', advance='yes' )
      end if
    else
      call output ( ', with' )
      if ( .not. associated(qty%values) ) call output ( 'out' )
      call output ( ' values, with' )
      if ( .not. associated(qty%mask ) ) call output ( 'out' )
      call output ( ' mask', advance='yes' )
    end if
    if ( associated(qty%BinNumber) ) then
      call Dump( qty%BinNumber, 'Bin Numbers' )
    elseif ( deebug ) then
      call output( 'Qty BinNumber not associated', advance='yes' )
    endif
    if ( associated(qty%MAF) ) then
      call Dump( qty%MAF, 'MAFs' )
    elseif ( deebug ) then
      call output( 'Qty MAF not associated', advance='yes' )
    endif
    if ( myDetails > 1 ) call dump ( qty%template, details=myDetails-1 )
    MLSMessageConfig%Info = oldInfo
  end subroutine Dump_Vector_Quantity

  ! ---------------------------------------  Dump_Vector_Template  -----
  subroutine Dump_Vector_Template ( VECTOR_TEMPLATE, DETAILS, QUANTITIES )
    use QuantityTemplates, only: Dump
    type(VectorTemplate_T), intent(in) :: VECTOR_TEMPLATE
    integer, intent(in), optional :: DETAILS ! <= 0 => Don't dump arrays
                                             ! > 0  => Do dump arrays
                                             ! Default 1
    type(quantityTemplate_T), intent(in), optional :: QUANTITIES(:)
                                             ! If DETAILS > 0 and QUANTITIES
                                             ! is present, dump them with level
                                             ! details-1.
    integer :: I, MyDetails
    myDetails = 1
    if ( present(details) ) myDetails = details
    if ( vector_template%name /= 0 ) then
      call output ( ' Name = ' )
      call display_string ( vector_template%name )
    end if
    call output ( ' NoQuantities = ' )
    call output ( vector_template%noQuantities )
    call output ( ' TotalInstances = ' )
    call output ( vector_template%totalInstances )
    call output ( ' TotalElements = ' )
    call output ( vector_template%totalElements, advance='yes' )
    if ( myDetails > 0 ) then
      call dump ( vector_template%quantities, '      Quantities = ' )
      if ( present(quantities) ) then
        do i = 1, size(vector_template%quantities)
          call output ( vector_template%quantities(i), 4 )
          call output ( ':' )
          call dump ( quantities(vector_template%quantities(i)), details-1 )
        end do
      end if
    else if ( .not. associated(vector_template%quantities) ) then
       call output ( 'vector quantities not associated', advance='yes' )
    else
       call outputNamedValue( 'size(vector_template%quantities)', size(vector_template%quantities) )
    end if
  end subroutine Dump_Vector_Template

  ! --------------------------------------  Dump_Vector_Templates  -----
  subroutine Dump_Vector_Templates ( VECTOR_TEMPLATES, DETAILS )
    type(VectorTemplate_T), intent(in) :: VECTOR_TEMPLATES(:)
    integer, intent(in), optional :: DETAILS ! <= 0 => Don't dump arrays
    !                                        ! > 0  => Do dump arrays
    !                                        ! Default 1
    integer :: I
    call output ( 'VECTOR_TEMPLATES: SIZE = ' )
    call output ( size(vector_templates), advance='yes' )
    do i = 1, size(vector_templates)
      call output ( i, 4 )
      call output ( ':' )
      call dump_vector_template ( vector_templates(i), details=details )
    end do
  end subroutine Dump_Vector_Templates

  ! ------------------------------------------  GatherVectorQuantity  -----
  function GatherVectorQuantity ( quantity, start, count, stride, block )

  ! This function returns a pointer to the information about one quantity
  ! within a vector.

    use Pointer_Rank_Remapping, only: Remap

    ! Dummy arguments
    type(VectorValue_T), pointer :: Quantity
    integer, dimension(:), intent(in) :: start
    integer, dimension(:), intent(in) :: count
    integer, dimension(:), intent(in) :: stride
    integer, dimension(:), intent(in) :: block

    ! Result
    type(VectorValue_T) :: GatherVectorQuantity

    ! Internal
    real(rv), pointer :: GV1(:), QV1(:), GV3(:,:,:), QV3(:,:,:)

    ! Executable
    call CloneVectorQuantity( GatherVectorQuantity, quantity )
    call DestroyVectorQuantityValue( GatherVectorQuantity, destroyMask=.true., &
      & destroyTemplate=.false. )
    select case( size(count) )
    case (1)
    ! qv1(1:size(quantity%values)) => quantity%values
      call remap ( quantity%values, qv1, size(quantity%values) )
      call ExtractArray ( gv1, qv1, start, count, stride, block, options='-a' )
      GatherVectorQuantity%values(1:quantity%template%noChans*quantity%template%noSurfs, &
        & 1:quantity%template%noInstances*quantity%template%noCrossTrack) => gv1
    case (2)
      call ExtractArray ( GatherVectorQuantity%values, quantity%values, &
        & start, count, stride, block, options='-a' )
    case (3)
    ! qv3(1:quantity%template%noChans,1:quantity%template%noSurfs, &
    !    &1:quantity%template%noInstances*quantity%template%noCrossTrack) => &
    !    & quantity%values
      call remap ( quantity%values, qv3, [ quantity%template%noChans, &
        & quantity%template%noSurfs, &
        & quantity%template%noInstances*quantity%template%noCrossTrack ] )
      call ExtractArray ( gv3, qv3, start, count, stride, block, options='-a' )
    ! GatherVectorQuantity%values(1:quantity%template%noChans*quantity%template%noSurfs, &
    !  1:quantity%template%noInstances*quantity%template%noCrossTrack) => gv3
      call remap ( gv3, GatherVectorQuantity%values, &
        & [ quantity%template%noChans*quantity%template%noSurfs, &
        &   quantity%template%noInstances*quantity%template%noCrossTrack ] )
    case default
      call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "GatherVectorQuantity can handle only count sized 1, 2, or 3" )
    end select
  end function GatherVectorQuantity

  ! ------------------------------------------  GetVectorQuantity  -----
  function GetVectorQuantity ( vector, quantity )

  ! This function returns a pointer to the information about one quantity
  ! within a vector.

    ! Dummy arguments
    type (Vector_T), intent(in) :: Vector
    integer, intent(in) :: Quantity                 ! Quantity index

    ! Result
    type(VectorValue_T), pointer :: GetVectorQuantity

    if ( quantity < 1 .or. quantity > size(vector%quantities) ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & '"Quantity" is out of range as a subscript for "vector%quantities".' )
    GetVectorQuantity => vector%quantities(quantity)

  end function GetVectorQuantity

  ! ------------------------------------  GetVectorQuantityByType  -----
  function GetVectorQuantityByType ( vector, otherVector, quantityType, &
    & molecule, instrumentModule, supportedInstrumentModule, radiometer, reflector, signal, &
    & sideband, foundInFirst, noError )

    ! Given a quantity type index (l_...), this function returns the first
    ! quantity within the vector that has that type.  If molecule and/or
    ! radiometer are supplied, the quantity that has the specified type, as
    ! well as the specified molecule and/or radiometer index, is returned.
    
    ! If otherVector is present it will look for the quantity there.

    ! Dummy arguments
    type (Vector_T), intent(in) :: VECTOR ! First vector to look in
    type (Vector_T), intent(in), optional :: OTHERVECTOR ! Second vector to look in
    integer, intent(in) :: QUANTITYTYPE ! Quantity type index (l_...)
    integer, intent(in),  optional :: MOLECULE     ! Molecule index (l_...)
    integer, intent(in),  optional :: INSTRUMENTMODULE ! Instrument module index
    integer, intent(in),  optional :: SUPPORTEDINSTRUMENTMODULE ! Another instrument module index
    integer, intent(in),  optional :: RADIOMETER   ! Radiometer index
    integer, intent(in),  optional :: REFLECTOR   ! Reflector literal
    integer, intent(in),  optional :: SIGNAL       ! Signal index
    integer, intent(in),  optional :: SIDEBAND ! -1, 0, +1
    logical, intent(out), optional :: FOUNDINFIRST ! Set if found in first vector
    logical, intent(in),  optional :: NOERROR ! Don't give error if not found
    ! Result
    type (VectorValue_T), pointer :: GetVectorQuantityByType

    ! Local variable
    integer :: index
    logical :: myNoError

    myNoError = .false.
    if ( present(noError)) myNoError = noError

    GetVectorQuantityByType => NULL()

    ! Look in the first vector
    index = GetVectorQuantityIndexByType ( vector, &
      & quantityType, molecule, instrumentModule, supportedInstrumentModule, radiometer, reflector, signal, &
      &   sideband, noError = present(otherVector) .or. myNoError)
    if ( index /= 0 ) then
      if ( present (foundInFirst) ) foundInFirst = .true.
      GetVectorQuantityByType => vector%quantities(index)
    else
      ! Can only get here if not found in first vector and noError or other
      ! vector
      if ( present (otherVector) ) then
        index = GetVectorQuantityIndexByType ( otherVector, &
          &  quantityType, molecule, instrumentModule, supportedInstrumentModule, radiometer, reflector, signal, &
          &  sideband, noError=myNoError )
        if ( present (foundInFirst) ) foundInFirst = .false.
        if ( index /= 0 ) &
          & GetVectorQuantityByType => otherVector%quantities( index )
      end if
    end if
  end function GetVectorQuantityByType

  ! --------------------------------  GetVectorQtyByTemplateIndex  -----
  ! Given a vector and an index into the quantity templates, find quantity
  ! with matching template within vector.
  function GetVectorQtyByTemplateIndex ( vector, quantityIndex, indexInVector )
    ! The vector where the quantity resides
    type (vector_T), intent(in) :: vector
    ! The index of the quantity in the quantity database; this index
    ! is returned by AddQuantityTemplateToDatabase
    integer, intent(in) :: quantityIndex
    integer, intent(out), optional :: indexInVector
    ! Result
    type (VectorValue_T), pointer :: GetVectorQtyByTemplateIndex

    ! Local variables
    integer :: myIndexInVector
    character(len=132) :: MSG           ! An error message

    ! Executable code
    GetVectorQtyByTemplateIndex => NULL()
    if ( .not. associated ( vector%quantities ) ) then
      msg = "Reference to the vector "
      call get_string ( vector%name, msg(len_trim(msg)+2:len(msg)), strip=.true. )
      msg = trim ( msg ) // " which has been destroyed" 
      call MLSMessage ( MLSMSG_Error, ModuleName, trim(msg) )
    end if
    myIndexInVector = FindFirst ( vector%template%quantities, quantityIndex )
    if ( myIndexInVector > 0 .and. &
      & myIndexInVector <= ubound(vector%quantities, 1) ) &
      & GetVectorQtyByTemplateIndex => &
      &   vector%quantities(myIndexInVector)
    if ( myIndexInVector > size(vector%quantities) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'index returned by FindFirst too big' )
    if ( present ( indexInVector ) ) indexInVector = myIndexInVector
  end function GetVectorQtyByTemplateIndex

  ! -------------------------------  GetVectorQuantityIndexByName  -----
  ! This family of subroutines returns a quantity's index within a vector
  ! by its quantity name
  function GetVectorQuantityIndexByName_sbr ( VECTOR, QUANTITYNAME, &
    & NOERR ) result( index )

  ! Given a quantity name's sub-rosa index, this function returns the index
  ! of the quantity within the vector matching that name.

    ! Dummy arguments
    type (Vector_T), intent(in)   :: VECTOR
    integer, intent(in)           :: QUANTITYNAME ! Quantity name sub-rosa index.
    logical, intent(in), optional :: NOERR        ! No error if present and true.
                                                  ! Return -1 if no such quantity.
    integer                       :: INDEX
    ! Local variables
    character(len=127) :: MSG
    integer :: Search

    ! Executable code
    do search = 1, size(vector%quantities)
      if ( quantityName == vector%quantities(search)%template%name ) then
        index = search
        return
      end if
    end do
    if ( present(noErr) ) then
      index = -1
      if ( noErr ) return
    end if
    call get_string ( quantityName, msg )
    msg(string_length(quantityName)+2:) = 'is not a quantity in vector'
    call get_string ( vector%name, msg(len_trim(msg)+2:) )
    call MLSMessage ( MLSMSG_Error, ModuleName, msg(:len_trim(msg)) )

  end function GetVectorQuantityIndexByName_sbr

  function GetVectorQuantityIndexByName_char ( VECTOR, QUANTITYNAME, &
    & NOERR ) result( index )
    use MLSStrings, only: Lowercase

  ! Given a quantity name, this function returns the index
  ! of the quantity within the vector matching that name.

    ! Dummy arguments
    type (Vector_T), intent(in)   :: VECTOR
    character(len=*), intent(in)  :: QUANTITYNAME ! Quantity name 
    logical, intent(in), optional :: NOERR        ! No error if present and true.
                                                  ! Return -1 if no such quantity.
    integer                       :: INDEX

    ! Local variables
    character(len=127) :: MSG
    integer :: Search

    ! Executable code
    ! call output( trim(quantityName), advance='yes' )
    do search = 1, size(vector%quantities)
      call get_string ( vector%quantities(search)%template%name, msg, strip=.true. )
      ! call output( trim(msg), advance='yes' )
      if ( lowercase(quantityName) == lowercase(msg) ) then
        index = search
        return
      end if
    end do
    if ( present(noErr) ) then
      index = -1
      if ( noErr ) return
    end if
    msg = trim(quantityName) // ' is not a quantity in vector'
    call get_string ( vector%name, msg(len_trim(msg)+2:) )
    call MLSMessage ( MLSMSG_Error, ModuleName, msg(:len_trim(msg)) )

  end function GetVectorQuantityIndexByName_char

  ! -------------------------------  GetVectorQuantityIndexByType  -----
  integer function GetVectorQuantityIndexByType ( vector, quantityType, &
    & molecule, instrumentModule, supportedInstrumentModule, radiometer, &
    & reflector, signal, sideband, noError )

  ! Given a quantity type index (l_...), this function returns the index
  ! of the first quantity within the vector that has that type.  If
  ! molecule and/or radiometer are supplied, the quantity that has the
  ! specified type, as well as the specified molecule and/or radiometer
  ! index, is returned.

    use MLSSignals_m, only: GetRadiometerName
    use Molecules, only: IsExtinction

    ! Dummy arguments
    type (Vector_T), intent(in) :: VECTOR
    integer, intent(in) :: QUANTITYTYPE ! Quantity type index (l_...)
    integer, intent(in), optional :: MOLECULE     ! Molecule index (l_...)
    integer, intent(in), optional :: INSTRUMENTMODULE ! Module index
    integer, intent(in), optional :: SUPPORTEDINSTRUMENTMODULE ! Another module index
    integer, intent(in), optional :: RADIOMETER   ! Radiometer index
    integer, intent(in), optional :: REFLECTOR   ! Reflector literal
    integer, intent(in), optional :: SIGNAL       ! Signal Index
    integer, intent(in), optional :: SIDEBAND ! -1, 0, +1
    logical, intent(in), optional :: NOERROR ! Don't give error if not found
    type (QuantityTemplate_T), pointer :: QT

    ! Local variables
    character(len=127) :: MSG
    integer :: SEARCH
    logical :: MYNOERROR

    myNoError = .false.
    if ( present(noError)) myNoError = noError

    ! Executable code
    do search = 1, size(vector%quantities)
      qt => vector%quantities(search)%template
      if ( quantityType == qt%quantityType ) then
        if ( present(molecule) ) then
          if ( qt%molecule /= molecule ) cycle
        end if
        if ( present(instrumentModule) ) then
          if ( qt%instrumentModule /= instrumentModule ) cycle
        end if
        if ( present(supportedInstrumentModule) ) then
          if ( qt%instrumentModule == 0 ) cycle
          if ( modules ( qt%instrumentModule )%supportedModule /= supportedInstrumentModule ) cycle
        end if
        if ( present(radiometer) ) then
          ! Somewhat trickier than one might think this one.  We don't
          ! want to include quantities that have a radiometer purely by virtue
          ! of having a signal
          if ( qt%signal /= 0 ) cycle
          ! We can be a little lenient with vmr here.
          if ( quantityType == l_vmr ) then
            if ( .not. present ( molecule ) ) call MLSMessage ( &
              & MLSMSG_Error, ModuleName, "Requests for vmrs must have molecules" )
            if ( radiometer /= qt%radiometer .and. isExtinction(molecule) ) cycle
          else
            if ( radiometer /= qt%radiometer ) cycle
          end if
        end if
        if ( present(reflector) ) then
          if ( qt%reflector /= reflector ) cycle
        end if
        if ( present(signal) ) then
          if ( qt%signal /= signal ) cycle
        end if
        if ( present(sideband) ) then
          if ( qt%sideband /= sideband ) cycle
        end if
        GetVectorQuantityIndexByType = search
        return
       end if
    end do

    ! Not found, perhaps generate an error
    if ( myNoError ) then
      GetVectorQuantityIndexByType = 0
    else
      msg = 'There is no quantity in vector '
      if ( vector%name /= 0 ) then
        call get_string ( vector%name, msg(len_trim(msg)+2:) )
      else
        msg(len_trim(msg)+2:) = '[unnamed]'
      end if
      msg = trim(msg) // ' that has type'
      call get_string ( lit_indices(quantityType), msg(len_trim(msg)+2:) )

      if ( present ( molecule ) ) then
        msg = trim(msg) // ' for molecule'
        call get_string ( lit_indices(molecule), msg(len_trim(msg)+2:))
      end if

      if ( present ( radiometer ) ) then
        msg = trim(msg) // ' for radiometer'
        call getradiometerName ( radiometer, msg(len_trim(msg)+2:))
      end if

      if ( present ( reflector ) ) then
        msg = trim(msg) // ' for reflector'
        call get_string ( lit_indices(reflector), msg(len_trim(msg)+2:))
      end if

      if ( present ( instrumentModule ) ) then
        msg = trim(msg) // ' for instrument module'
        call get_string ( modules(instrumentModule)%name, msg(len_trim(msg)+2:))
      end if

      if ( present ( signal ) ) then
        msg = trim(msg) // ' for signal'
        call GetSignalName ( signal, msg(len_trim(msg)+2:), sideband=sideband )
      end if

      call dump( vector, details=0 ) ! It's not the values causing us to crash
      call MLSMessage ( MLSMSG_Error, ModuleName, msg(:len_trim(msg)) )
    end if

  end function GetVectorQuantityIndexByType

  ! ---------------------------------------- InflateVectorDatabase -----
  integer function InflateVectorDatabase ( database, extra )
    ! Make a vector database bigger by extra
    ! Return index of first new element

    ! Dummy arguments
    type (Vector_T), dimension(:), pointer :: DATABASE
    integer, intent(in) :: EXTRA

    ! Local variables
    type (Vector_T), dimension(:), pointer :: TEMPDATABASE

    include "inflateDatabase.f9h"
    InflateVectorDatabase = firstNewItem
  end function InflateVectorDatabase

  ! -------------------------------- InflateVectorTemplateDatabase -----
  integer function InflateVectorTemplateDatabase ( database, extra )
    ! Make a vector template database bigger by extra
    ! Return index of first new element

    ! Dummy arguments
    type (VectorTemplate_T), dimension(:), pointer :: DATABASE
    integer, intent(in) :: EXTRA

    ! Local variables
    type (VectorTemplate_T), dimension(:), pointer :: TEMPDATABASE

    include "inflateDatabase.f9h"
    InflateVectorTemplateDatabase = firstNewItem
  end function InflateVectorTemplateDatabase

  ! ------------------------------------------  IsVectorQtyMasked  -----
  logical function IsVectorQtyMasked ( vectorQty, Row, Column, What )

  ! Is the mask for VectorQty set for address (Row, Column) ?
  ! If What is present, look at the bits of the mask specified by the union
  ! of the nonzero bits of What.  Otherwise, look at the M_LinAlg bit.
  
  ! Formal args
    type (VectorValue_T), intent(in) :: vectorQty
    integer, intent(in) ::              ROW
    integer, intent(in) ::              COLUMN
    integer, intent(in) ::              WHAT

    isVectorQtyMasked = .false.
    if ( .not. associated(vectorQty%mask)) return
    isVectorQtyMasked = iand(ichar(vectorQty%mask(row, column)), What) /= 0

  end function IsVectorQtyMasked

  ! ----------------------------------------------------  L2NormQ  -----
  elemental real(rv) function L2NormQ ( Qty, UseMask )
    ! Compute the L2Norm of a vector quantity, respecting its mask if
    ! useMask is present and true.
    type(vectorValue_t), intent(in), optional :: Qty
    logical, intent(in), optional :: UseMask
    l2NormQ = 0.0
    if ( present(qty) ) &
      & l2NormQ = sqrt( dotVectorQuantitiesMaybeMasked ( qty, qty, useMask ) )
  end function L2Normq

  ! ----------------------------------------------------  L2NormV  -----
  real(rv) function L2NormV ( Vector, UseMask )
    ! Compute the L2Norm of a vector, respecting its mask if useMask is
    ! present and true.
    type(vector_t), intent(in) :: Vector
    logical, intent(in), optional :: UseMask
    l2NormV = 0.0
    if ( associated(vector%quantities) ) &
      & l2normV = sqrt( dotVectorsMaybeMasked ( vector, vector, useMask ) )
  end function L2NormV

  ! ----------------------------------------------  MaskVectorQty  -----
  subroutine MaskVectorQty ( vectorQty, Row, Column, What )

  ! Set bits of the mask for VectorQty(Row,Column); meaning
  ! If set, don't use vectorQty%values(Row, Column)
  ! Otherwise, go ahead.  If What is present, set the bits in
  ! mask indicated by What.  Otherwise, set the M_LinAlg bit.
  
  ! Note that 
  ! (1) if mask is not yet it associated, it will be created
  ! (2) If mask already associated, any bits in it will not be reset
  !    (i.e., we will be "or"-ing bits)
  
  ! Formal args
    type (VectorValue_T), intent(inout) :: vectorQty
    integer, intent(in) ::              ROW
    integer, intent(in) ::              COLUMN
    integer, intent(in) ::              WHAT

    if ( .not. associated(vectorQty%mask)) call CreateMask ( vectorQty)
    vectorQty%mask(row, column) = &
      & char(ior( ichar(vectorQty%mask(row, column)), What ) )

  end subroutine MaskVectorQty

  ! -----------------------------------------  MoveVectorQuantity  -----
  subroutine MoveVectorQuantity ( From, To )
    ! Deallocate the Values and Mask fields in To
    ! Move the Values and Mask fields from From to To using pointer assignment.
    ! Nullify the Values and Mask fields in From
    type(vectorValue_t), intent(inout) :: From, To
    if ( from%template%name /= to%template%name ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, 'From and To vectors have different templates' )
    call destroyVectorQuantityValue ( to, destroyMask=.true. )
    to%value1 => from%value1
    to%mask1 => from%mask1
    call remapVectorValue ( to )
    call remapVectorMask ( to )
    nullify ( from%value1, from%mask1 ) ! Don't deallocate during destroy!
    nullify ( from%values, from%mask )  ! Don't deallocate during destroy!
    nullify ( from%value3, from%mask3 ) ! Don't deallocate during destroy!
    nullify ( from%value4, from%mask4 ) ! Don't deallocate during destroy!
    call destroyVectorQuantityValue ( from, destroyMask=.true. )
  end subroutine MoveVectorQuantity

  ! --------------------------------------------  MultiplyVectors  -----
  subroutine MultiplyVectors ( X, Y, Z, Quant, Inst )
  ! If Z is present, destroy Z and clone a new one from X, then
  ! Z = X # Y where # means "element-by-element"; otherwise X = X # Y

    ! Dummy arguments:
    type(Vector_T), intent(inout), target :: X
    type(Vector_T), intent(in) :: Y
    type(Vector_T), intent(inout), optional, target :: Z
    integer, intent(in), optional :: Quant, Inst  ! If Quant is present,
    !  only that quantity is multiplied.  If furthermore Inst is present,
    !  only that instance is multiplied.  If Inst is present but Quant
    !  is not, the entire vector is multiplied.
    ! Local Variables:
    integer :: I                        ! Subscript and loop inductor
    type(Vector_T), pointer :: Result   ! associated to either X or Z
    ! Executable statements:
    if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot multiply vectors having different templates" )
    if ( present(z) ) then
      call CloneVector ( z, x, vectorNameText='_z' )
      result => z
    else
      result => x
    end if
    if ( present(quant) ) then
      if ( present(inst) ) then
        result%quantities(quant)%values(:,inst) = &
          & x%quantities(quant)%values(:,inst) * &
          & y%quantities(quant)%values(:,inst)
      else
        result%quantities(quant)%values = x%quantities(quant)%values * &
          &                               y%quantities(quant)%values
      end if
    else
      do i = 1, size(x%quantities)
        result%quantities(i)%values = &
          & x%quantities(i)%values * y%quantities(i)%values
      end do
    end if
  end subroutine MultiplyVectors

  ! ---------------------------------------- NullifyVectorTemplate -----
  subroutine NullifyVectorTemplate ( V )
    ! Given a vector template, nullify all the pointers associated with it
    type ( VectorTemplate_T ), intent(out) :: V

    ! Executable code
    v%name = 0
    nullify ( v%quantities )
  end subroutine NullifyVectorTemplate

  ! ------------------------------------------- NullifyVectorValue -----
  subroutine NullifyVectorValue ( V )
    ! Given a vector value, nullify all the pointers associated with it
    type ( VectorValue_T ), intent(out) :: V

    ! Executable code
    call nullifyQuantityTemplate ( v%template )
    nullify ( v%values, v%value1, v%value3 )
    nullify ( v%mask, v%mask1, v%mask3 )
  end subroutine NullifyVectorValue

  ! ---------------------------------------------- NullifyVector -----
  subroutine NullifyVector ( V )
    ! Given a vector, nullify all the pointers associated with it
    type ( Vector_T ), intent(out) :: V

    ! Executable code
    v%name = 0
    v%globalUnit = PHYQ_Invalid
    call nullifyVectorTemplate ( v%template )
    nullify ( v%quantities )
  end subroutine NullifyVector

  ! --------------------------------------------------  PowVector  -----
  subroutine PowVector ( X, POWER )
  ! Y = A / X if Y is present, else X = A / X.

    ! Dummy arguments:
    type(Vector_T), intent(inout), target :: X
    real(rv), intent(in) :: POWER
    ! Local Variables:
    integer :: I              ! Subscript and loop inductor
    do i = 1, size(x%quantities)
      x%quantities(i)%values = x%quantities(i)%values ** power
    end do
  end subroutine PowVector

  ! ------------------------------------------  ReciprocateVector  -----
  subroutine ReciprocateVector ( X, A, Y )
  ! Y = A / X if Y is present, else X = A / X.

    ! Dummy arguments:
    type(Vector_T), intent(inout), target :: X
    real(rv), intent(in) :: A
    type(Vector_T), intent(inout), optional, target :: Y
    ! Local Variables:
    integer :: I              ! Subscript and loop inductor
    type(Vector_T), pointer :: Z
    ! Executable statements:
    z => x
    if ( present(y) ) then
      if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, 'Reciprocated vector has different template from original' )
      z => y
    end if
    do i = 1, size(x%quantities)
      z%quantities(i)%values = a / x%quantities(i)%values
    end do
  end subroutine ReciprocateVector

  ! --------------------------------------------  RemapVectorMask  -----
  subroutine RemapVectorMask ( Value )
    use Pointer_Rank_Remapping, only: Remap
    type ( vectorValue_t ) :: Value
    call remap ( value%mask1, value%mask, &
      & (/ value%template%noChans *     &
      &    value%template%noSurfs,      &
      &    value%template%noInstances * &
      &    value%template%noCrossTrack /) )
    call remap ( value%mask1, value%mask3, &
      & (/ value%template%noChans,      &
      &    value%template%noSurfs,      &
      &    value%template%noInstances * &
      &    value%template%noCrossTrack /) )
    call remap ( value%mask1, value%mask4, &
      & (/ value%template%noChans,      &
      &    value%template%noSurfs,      &
      &    value%template%noInstances,  &
      &    value%template%noCrossTrack /) )
  end subroutine RemapVectorMask

  ! -------------------------------------------  RemapVectorValue  -----
  subroutine RemapVectorValue ( Value )
    use Pointer_Rank_Remapping, only: Remap
    type ( vectorValue_t ) :: Value
    call remap ( value%value1, value%values, &
      & (/ value%template%noChans *     &
      &    value%template%noSurfs,      &
      &    value%template%noInstances * &
      &    value%template%noCrossTrack /) )
    call remap ( value%value1, value%value3, &
      & (/ value%template%noChans,      &
      &    value%template%noSurfs,      &
      &    value%template%noInstances * &
      &    value%template%noCrossTrack /) )
    call remap ( value%value1, value%value4, &
      & (/ value%template%noChans,      &
      &    value%template%noSurfs,      &
      &    value%template%noInstances,  &
      &    value%template%noCrossTrack /) )
  end subroutine RemapVectorValue

  ! -----------------------------------------  ReshapeVectorValue  -----
  ! Reshape source values to fit destination loosely
  ! destination must already be allocated
  ! Source values will come from either of
  ! (a) source%values, if present; or
  ! (b) an array of sourceValues
  ! If neither is present, we silently return an unchanged destination
  subroutine ReshapeVectorValue ( DESTINATION, SOURCE, SOURCEVALUES )
    type ( VectorValue_T), intent(out)                      :: DESTINATION
    type ( VectorValue_T), optional, pointer, intent(in)    :: SOURCE
    real(rv), dimension(:,:), optional, pointer, intent(in) :: SOURCEVALUES
    ! Internal variables
    integer :: i, j, k, n
    ! Executable
    if ( .not. associated(destination%values) ) return
    if ( present(source) ) then
      n = min( size(source%values), size(destination%values) )
      destination%value1(:n) = source%value1(:n)
    else if ( present(sourcevalues) ) then
      n = min( size(sourceValues), size(destination%values) )
      k = 0
      do j = 1, size(sourcevalues, 2)
        do i = 1, size(sourcevalues, 1)
          k = k + 1
          if ( k > n ) exit
          destination%value1(k) = sourcevalues(i, j)
        end do
      end do
    end if
  end subroutine ReshapeVectorValue

  ! ------------------------------------------------  ReverseMask  -----
  subroutine ReverseMask ( MASK, TO_Reverse, WHAT )
  ! Reverse bits of MASK indexed by elements of TO_Reverse.  Numbering of mask
  ! elements starts at one, not zero!  If TO_Reverse is absent, Reverse all of
  ! the bits of MASK.  If WHAT is absent, Reverse all bits.  If WHAT is
  ! present, Reverse only bits of MASK that correspond to "one" bits of WHAT.
  !
  ! In case it is not obvious, reverse turns "1" to "0", and "0" to "1"
  ! Effect: say the linAlg bits were set for elements {1,3,8,9} of a 10-element
  ! MASK. When we reverseMask the linAlg bits will be set for {2,4,5,6,7,10}
  ! All other bits and all other elements will be left unset
    character, intent(inout), dimension(:) :: MASK
    integer, intent(in), dimension(:), optional :: TO_Reverse
    integer, intent(in), optional :: WHAT
    integer :: MyWhat
    integer :: test
    logical, parameter :: DeeBug = .false.
    MyWhat = M_linAlg
    if ( present(what) ) myWhat = what
    if ( DeeBug ) then
      call output( 'Illustration: ' )
      test = 0
      call output (' effect on 0 is ')
      call output( ieor(test, myWhat ) )
      call blanks( 3 )
      test = 1
      call output (' effect on 1 is ')
      call output( ieor(test, myWhat ) )
    end if
    if ( present(to_Reverse) ) then
      mask(to_Reverse) = char(ieor(ichar(mask(to_Reverse)), myWhat))
    else
      mask = char(ieor(ichar(mask), myWhat))
    end if
  end subroutine ReverseMask

  ! ----------------------------------------  RmVectorFromDatabase  -----
  integer function RmVectorFromDatabase ( DATABASE, ITEM )

  ! This routine removes a vector from a database of such vectors, 
  ! deallocating the database if necessary.
  ! Alas, doesn't work--we need to know how to undecorate character tree
  ! first before we will be able to make it work; sorry (P. Wagner)

    ! Dummy arguments
    type (Vector_T), dimension(:), pointer :: DATABASE
    type (Vector_T), intent(in) ::            ITEM

    ! Local variables
    type (Vector_T), dimension(:), pointer :: tempDatabase
    logical, parameter                     :: okToDeallocEmptyDB = .FALSE.
    include "rmItemFromDatabase.f9h"
    call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot yet (ever?) rm vector from database" ) 

    rmVectorFromDatabase = newSize
  end function RmVectorFromDatabase

  ! ------------------------------------------------  ScaleVector  -----
  subroutine ScaleVector ( X, A, Y )
  ! Y = A*X if Y is present, else X = A*X.

    ! Dummy arguments:
    type(Vector_T), intent(inout), target :: X
    real(r8), intent(in) :: A
    type(Vector_T), intent(inout), optional, target :: Y
    ! Local Variables:
    integer :: I              ! Subscript and loop inductor
    type(Vector_T), pointer :: Z
    ! Executable statements:
    z => x
    if ( present(y) ) then
      if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, 'Scaled vector has different template from original' )
      z => y
    end if
    do i = 1, size(x%quantities)
      z%quantities(i)%values = a * x%quantities(i)%values
    end do
  end subroutine ScaleVector

  ! ----------------------------------------------------  SetMask  -----
  subroutine SetMask ( MASK, TO_SET, MAXBIT, WHAT )
  ! Set bits of MASK indexed by elements of TO_SET.  Numbering of mask
  ! elements starts at one, not zero!  If TO_SET is absent, set bits of MASK.
  ! for all elements.  If MaxBit is present, do not set bits for any element
  ! after MaxBit.  If WHAT is present, set the bits indicated by WHAT.
  ! Otherwise, set the M_LinAlg bit.
    character, intent(inout), dimension(:) :: MASK
    integer, intent(in), dimension(:), optional :: TO_SET
    integer, intent(in), optional :: MaxBit, What
    integer :: I, MyMaxBit, MyWhat

    myWhat = m_LinAlg
    if ( present(what) ) myWhat = what
    if ( present(to_set) ) then
      myMaxBit = huge(0)
      if ( present(maxBit) ) myMaxBit = maxBit
      do i = 1, size(to_set)
        if ( to_set(i) > 0 .and. to_set(i) <= min(myMaxBit,size(mask)) ) then
          mask(to_set(i)) = char(ior(ichar(mask(to_set(i))),myWhat))
        end if
      end do
    else
      if ( present(maxBit) ) then
        mask(:maxbit) = char(ior(ichar(mask(:maxbit)),myWhat))
      else
        mask = char(ior(ichar(mask),myWhat))
      end if
    end if
  end subroutine SetMask

  ! -----------------------------------------  SubtractFromVector  -----
  subroutine SubtractFromVector ( X, Y, Quant, Inst ) ! X = X - Y.

    ! Dummy arguments:
    type(Vector_T), intent(inout) :: X
    type(Vector_T), intent(in) :: Y
    integer, intent(in), optional :: Quant, Inst  ! If Quant is present,
    !  only that quantity is subtracted.  If furthermore Inst is present,
    !  only that instance is subtracted.  If Inst is present but Quant
    !  is not, the entire vector is subtracted.

    ! Local Variables:
    integer :: I              ! Subscript and loop inductor
    ! Executable statements:
    if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot subtract vectors having different templates" )
    if ( present(quant) ) then
      if ( present(inst) ) then
        x%quantities(quant)%values(:,inst) = &
          & x%quantities(quant)%values(:,inst) - &
          & y%quantities(quant)%values(:,inst)
      else
        x%quantities(quant)%values = x%quantities(quant)%values - &
          &                          y%quantities(quant)%values
      end if
    else
      do i = 1, size(x%quantities)
        x%quantities(i)%values = x%quantities(i)%values - &
          &                      y%quantities(i)%values
      end do
    end if
  end subroutine SubtractFromVector

  ! --------------------------------------------  SubtractVectors  -----
  type (Vector_T) function SubtractVectors ( X, Y ) result (Z)
  ! Subtract Y from X, producing one having the same template (but no name,
  ! of course).

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyVectorInfo using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignVector.
  ! !!!!! ===== END NOTE ===== !!!!! 

    ! Dummy arguments:
    type(Vector_T), intent(in) :: X, Y
    ! Local Variables:
    integer :: I              ! Subscript and loop inductor
    ! Executable statements:
    if ( x%template%name /= y%template%name ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Cannot subtract vectors having different templates" )
    call nullifyVector ( z ) ! for Sun's still useless compiler
    call CloneVector ( z, x, vectorNameText='_z' )
    do i = 1, size(x%quantities)
      z%quantities(i)%values = x%quantities(i)%values - y%quantities(i)%values
    end do
  end function SubtractVectors

  ! ---------------------------------------- ValidateVectorQuantity -------
  
  ! This function performs a series of tests on a quantity to make sure it
  ! matches our requirements
  
  function ValidateVectorQuantity ( quantity, coherent, stacked, regular,&
    & minorFrame, majorFrame, verticalCoordinate, frequencyCoordinate, &
    & noInstances, noSurfs, quantityType, molecule, signal, sideband, sayWhyNot )

    ! Dummy arguments
    type (VectorValue_T), intent(IN) :: QUANTITY ! Test quantity
    logical, optional, intent(IN) :: COHERENT ! .TRUE.,.FALSE. or not present
    logical, optional, intent(IN) :: STACKED  ! .TRUE.,.FALSE. or not present
    logical, optional, intent(IN) :: REGULAR ! .TRUE.,.FALSE. or not present
    logical, optional, intent(IN) :: MINORFRAME ! .TRUE.,.FALSE. or not present
    logical, optional, intent(IN) :: MAJORFRAME ! .TRUE.,.FALSE. or not present

    integer, optional, dimension(:), intent(IN) :: VERTICALCOORDINATE
    integer, optional, dimension(:), intent(IN) :: FREQUENCYCOORDINATE
    integer, optional, dimension(:), intent(IN) :: NOINSTANCES
    integer, optional, dimension(:), intent(IN) :: NOSURFS
    integer, optional, dimension(:), intent(IN) :: QUANTITYTYPE
    integer, optional, dimension(:), intent(IN) :: MOLECULE
    integer, optional, dimension(:), intent(IN) :: SIGNAL
    integer, optional, dimension(:), intent(IN) :: SIDEBAND
    logical, optional, intent(IN)               :: SAYWHYNOT

    ! Result
    logical :: ValidateVectorQuantity

    ! Executable code
    logical :: mySayWhyNot

    mySayWhyNot = .false.
    if ( present(sayWhyNot)) mySayWhyNot = sayWhyNot

    ValidateVectorQuantity = .true.

    if ( present(coherent) ) then
      if ( quantity%template%coherent .neqv. coherent ) then
        ValidateVectorQuantity=.FALSE.
        if ( mySayWhyNot ) then
          call output('Coherent quantity checked with incoherent', advance='yes')
          call output('quantity coherent? ', advance='no')
          call output(quantity%template%coherent, advance='yes')
          call output('check coherent? ', advance='no')
          call output(coherent, advance='yes')
        end if
        return
      end if
    end if

    if ( present(stacked) ) then
      if ( quantity%template%stacked .neqv. stacked ) then
        ValidateVectorQuantity=.FALSE.
        if ( mySayWhyNot ) then
          call output('stacked quantity checked with unstacked', advance='yes')
          call output('quantity stacked? ', advance='no')
          call output(quantity%template%stacked, advance='yes')
          call output('check stacked? ', advance='no')
          call output(stacked, advance='yes')
        end if
        return
      end if
    end if

    if ( present(regular) ) then
      if ( quantity%template%regular .neqv. regular ) then
        ValidateVectorQuantity=.FALSE.
        if ( mySayWhyNot ) then
          call output('Regular quantity checked with irregular', advance='yes')
          call output('quantity regular? ', advance='no')
          call output(quantity%template%regular, advance='yes')
          call output('check regular? ', advance='no')
          call output(regular, advance='yes')
        end if
        return
      end if
    end if

    if ( present(minorFrame) ) then
      if ( quantity%template%minorFrame .neqv. minorFrame ) then
        ValidateVectorQuantity=.FALSE.
        if ( mySayWhyNot ) then
          call output('Minor frame quantity checked with not', advance='yes')
          call output('quantity minor frame? ', advance='no')
          call output(quantity%template%minorFrame, advance='yes')
          call output('check minorFrame? ', advance='no')
          call output(minorFrame, advance='yes')
        end if
        return
      end if
    end if

    if ( present(majorFrame) ) then
      if ( quantity%template%majorFrame .neqv. majorFrame ) then
        ValidateVectorQuantity=.FALSE.
        if ( mySayWhyNot ) then
          call output('Major frame quantity checked with not', advance='yes')
          call output('quantity major frame? ', advance='no')
          call output(quantity%template%majorFrame, advance='yes')
          call output('check majorFrame? ', advance='no')
          call output(majorFrame, advance='yes')
        end if
        return
      end if
    end if

    if ( present(sideband) ) then
      ValidateVectorQuantity = any(quantity%template%sideband == sideband)
      if ( mySayWhyNot .and. .not. ValidateVectorQuantity ) then
        call output('quantity checked with different sideband', advance='yes')
        call output('quantity sideband ', advance='no')
        call output(quantity%template%sideband, advance='yes')
        call output('check sideband ', advance='no')
        call output(sideband, advance='yes')
      end if
      if ( .not. ValidateVectorQuantity) return
    end if

    if ( present(signal) ) then
      ValidateVectorQuantity = any(quantity%template%signal == signal)
      if ( mySayWhyNot .and. .not. ValidateVectorQuantity ) then
        call output('quantity checked with different signal', advance='yes')
        call output('quantity signal ', advance='no')
        call output(quantity%template%signal, advance='yes')
        call output('check signal ', advance='no')
        call output(signal, advance='yes')
      end if
      if ( .not. ValidateVectorQuantity) return
    end if

    if ( present(verticalCoordinate) ) then
      ValidateVectorQuantity=any(quantity%template%verticalCoordinate == verticalCoordinate)
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
        call output('quantity checked with dif vert coord', advance='yes')
        call output('quantity vert coord ', advance='no')
        call output(quantity%template%verticalCoordinate, advance='yes')
        call output('check vert coord ', advance='no')
        call output(verticalCoordinate, advance='yes')
      end if
      if ( .not. ValidateVectorQuantity) return
    end if

    if ( present(frequencyCoordinate) ) then
      ValidateVectorQuantity=any(quantity%template%frequencyCoordinate == &
        & frequencyCoordinate)
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
        call output('quantity checked with dif freq coord', advance='yes')
        call output('quantity freq coord ', advance='no')
        call output(quantity%template%frequencyCoordinate, advance='yes')
        call output('check freq coord ', advance='no')
        call output(frequencyCoordinate, advance='yes')
      end if
      if ( .not. ValidateVectorQuantity) return
    end if

    if ( present(noInstances) ) then
      ValidateVectorQuantity=any(quantity%template%noInstances == noInstances)
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
        call output('quantity checked with dif num insts', advance='yes')
        call output('quantity num insts ', advance='no')
        call output(quantity%template%noInstances, advance='yes')
        call output('check noInstances ', advance='no')
        call output(noInstances, advance='yes')
      end if
      if ( .not. ValidateVectorQuantity) return
    end if

    if ( present(noSurfs) ) then
      ValidateVectorQuantity=any(quantity%template%noSurfs == noSurfs)
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
        call output('quantity checked with dif num surfs', advance='yes')
        call output('quantity num surfs ', advance='no')
        call output(quantity%template%noInstances, advance='yes')
        call output('check noSurfs ', advance='no')
        call output(noSurfs, advance='yes')
      end if
      if ( .not. ValidateVectorQuantity) return
    end if

    if ( present(quantityType) ) then
      ValidateVectorQuantity=any(quantity%template%quantityType == quantityType)
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
        call output('quantity checked with wrong type', advance='yes')
        call output('quantity type ', advance='no')
        call output(quantity%template%quantityType, advance='yes')
        call output('check quantityType ', advance='no')
        call output(quantityType, advance='yes')
      end if
      if ( .not. ValidateVectorQuantity) return
    end if

    if ( present(molecule) ) then
      ValidateVectorQuantity=any(quantity%template%molecule == molecule)
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
        call output('quantity checked with wrong molecule', advance='yes')
        call output('quantity molecule ', advance='no')
        call output(quantity%template%molecule, advance='yes')
        call output('check molecule ', advance='no')
        call output(molecule, advance='yes')
      end if
      if ( .not. ValidateVectorQuantity) return
    end if

  end function ValidateVectorQuantity

  ! ------------------------------------------ VectorMemoryInUse -------
  integer function VectorMemoryInUse ( V )
  ! Report the total number of real(rv) elements in all quantities in vector V.
    type (Vector_T), intent(in) :: V
    integer :: I

    vectorMemoryInUse = 0
    do i = 1, size(v%quantities)
      if ( associated(v%quantities(i)%value1) ) &
        & vectorMemoryInUse = vectorMemoryInUse + size(v%quantities(i)%value1)
    end do

  end function VectorMemoryInUse

  ! ----------------------------------------- VectorsMemoryInUse -------
  integer function VectorsMemoryInUse ( D )
  ! Report the total number of real(rv) elements in all vectors in the
  ! database.
    type (Vector_T),  dimension(:) :: D
    integer :: I

    vectorsMemoryInUse = 0
    do i = 1, size(d)
      vectorsMemoryInUse = vectorsMemoryInUse + vectorMemoryInUse ( d(i) )
    end do

  end function VectorsMemoryInUse

! =====     Private Procedures     =====================================
  subroutine CreateValues ( Vector, highBound, lowBound )
  ! Allocate space for the values of a vector.
    type(Vector_T), intent(inout) :: Vector
    logical, intent(in), optional :: HIGHBOUND
    logical, intent(in), optional :: LOWBOUND
    integer :: QTY
    logical :: MYHIGHBOUND, MYLOWBOUND
    real(rv), parameter :: MYHUGE = 1.0e15
    character(63) :: What1, What2
    if ( vector%name == 0 ) then
      What1 = "Vector%"
    else
      call get_string ( vector%name, what1 )
      what1 = trim(what1) // "."
    end if
    myHighBound = .false.
    myLowBound = .false.
    if ( present ( highBound ) ) myHighBound = highBound
    if ( present ( lowBound ) ) myLowBound = lowBound
    do qty = 1, size(vector%quantities)
      if ( vector%quantities(qty)%template%name == 0 ) then
        what2 = "quantities(qty)"
      else
        call get_string ( vector%quantities(qty)%template%name, what2 )
      end if
      call createVectorValue ( vector%quantities(qty), trim(what1) // trim(what2) )
      if ( myHighBound ) then
        vector%quantities(qty)%values = myHuge
      else if ( myLowBound ) then
        vector%quantities(qty)%values = - myHuge
      else
        vector%quantities(qty)%values = 0.0_rv
      end if
    end do
  end subroutine

  subroutine get_string ( STRING, STRING_TEXT, CAP, STRIP, NOERROR, IERR, &
    & START, END )
  ! because get_string has the pernicious habit of bombing 
  ! if presented with 0 as its arg
  ! Args
    integer, intent(in) :: STRING
    character(len=*), intent(out) :: STRING_TEXT
    logical, intent(in), optional :: CAP
    logical, intent(in), optional :: STRIP
    logical, intent(in), optional :: NOERROR
    integer, intent(out), optional :: IERR
    integer, intent(in), optional :: START
    integer, intent(in), optional :: END
  string_text = 'undefined'
  if ( isStringInTable(string) ) &
    & call get_String_Rude( STRING, STRING_TEXT, CAP, STRIP, NOERROR, IERR, &
    & START, END )
  end subroutine get_string

!=======================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: VectorsModule.f90,v 2.211 2021/06/10 23:43:11 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module VectorsModule
!=======================================================================

!
! $Log: VectorsModule.f90,v $
! Revision 2.211  2021/06/10 23:43:11  pwagner
! Added BinNumber and MAF components to vector qties
!
! Revision 2.210  2018/05/11 21:26:27  pwagner
! Moved M_ mask bit fields to MLSCommon
!
! Revision 2.209  2018/02/27 00:50:33  livesey
! Added the supportedInstrumentModule argument to the various search routines to support A-SMLS
!
! Revision 2.208  2017/11/03 19:57:59  pwagner
! Most array gymnastics moved from MLSFillValues to HyperSlabs module
!
! Revision 2.207  2016/11/15 19:29:55  pwagner
! Prevent error from 0-size arrays when remapping pointer rank
!
! Revision 2.206  2016/07/28 01:42:27  vsnyder
! Refactoring dump and diff
!
! Revision 2.205  2016/05/27 00:14:05  vsnyder
! Publish RV because this seems like a logical place to get it
!
! Revision 2.204  2016/04/13 00:47:18  vsnyder
! Make AreEqual generic.  Add AreUnEqual, operator(==), and operator(/=)
!
! Revision 2.203  2015/09/24 18:46:09  pwagner
! Prevent an obscure cause of crashing when index too big in GetVectorQtyByTemplateIndex
!
! Revision 2.202  2015/09/17 22:55:23  pwagner
! Will now complain, quit in GetVectorQtyByTemplateIndex if index too big
!
! Revision 2.201  2015/07/14 23:20:47  pwagner
! Prevent more crashes due to get_string
!
! Revision 2.200  2015/06/19 00:35:49  pwagner
! Setup quick changes to print when destroying vectors
!
! Revision 2.199  2015/06/04 01:57:16  vsnyder
! Add contiguous attribute, avoid using remapped values
!
! Revision 2.198  2015/05/01 02:09:28  vsnyder
! Spiff a dump
!
! Revision 2.197  2015/04/29 00:53:56  vsnyder
! Spiff the dump
!
! Revision 2.196  2015/03/28 01:47:29  vsnyder
! Added 4-d Values and Mask.  Additional dimension extent is NoCrossTrack.
! Added stuff to trace allocate/deallocate addresses.
!
! Revision 2.195  2014/11/08 01:05:15  pwagner
! CreateVectorValue relies on DestroyVectorQuantityValue to deallocate its values
!
! Revision 2.194  2014/10/02 22:08:35  vsnyder
! Default initialize all components of Vector*_T
!
! Revision 2.193  2014/09/05 00:20:54  vsnyder
! More complete and accurate allocate/deallocate size tracking.  Remove some
! debugging cruft that shouldn't have been checked in.
!
! Revision 2.192  2014/09/04 20:23:41  pwagner
! Turn off all those debugging print statements
!
! Revision 2.191  2014/08/19 00:29:59  vsnyder
! Add VectorMemoryInUse, VectorsMemoryInUse
!
! Revision 2.190  2014/07/18 23:13:24  pwagner
! Aimed for consistency in names passed to allocate_test; added allocationName field to datatype
!
! Revision 2.189  2014/05/20 23:53:19  vsnyder
! Add the POINTER attribute to the SourceValues argument to ReshapeVectorValue
! to work around bugs in compilers that have not properly implemented the
! feature that disassociated pointer actual arguments corresponding to
! optional non-pointer dummy arguments are absent.
!
! Revision 2.188  2014/02/01 00:16:43  pwagner
! Don't dump values for every quantity when failed to find one in GetVectorQuantityIndexByType
!
! Revision 2.187  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.186  2013/10/25 23:05:42  pwagner
! Fixed error that caused dumping hyperslab to segment fault if rank /= 2
!
! Revision 2.185  2013/09/27 00:41:14  pwagner
! Fixed bug in GatherVectorQuantity
!
! Revision 2.184  2013/09/25 00:58:15  pwagner
! Added a gather operation for Vector quantities
!
! Revision 2.183  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.182  2013/08/17 00:17:24  pwagner
! Guard against certain crashes with non-Aura datasets
!
! Revision 2.181  2013/08/16 02:28:38  vsnyder
! Don't reallocate VALUES if it's the right shape
!
! Revision 2.180  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.179  2013/07/13 00:00:15  vsnyder
! Define assignment, producing error message, for vector value
!
! Revision 2.178  2013/06/12 02:14:37  vsnyder
! Cruft removal
!
! Revision 2.177  2013/05/22 20:24:21  pwagner
! Dump procedures accept and obey options arg
!
! Revision 2.176  2013/05/16 18:16:58  pwagner
! Made GetVectorQuantityIndexByName generic--can supply character-valued arg
!
! Revision 2.175  2013/03/15 00:01:31  pwagner
! Added function AreEqual for vectors
!
! Revision 2.174  2013/02/21 21:21:42  pwagner
! Added options arg when dumping quantity or vector masks
!
! Revision 2.173  2013/02/01 23:40:55  vsnyder
! Add Where argument to CreateVectorValue.  Nullify correct pointers in
! DestroyVectorValue.
!
! Revision 2.172  2012/12/04 00:11:55  pwagner
! Improved comments
!
! Revision 2.171  2012/11/09 00:59:08  pwagner
! Added ReshapeVectorValue
!
! Revision 2.170  2012/10/30 22:07:28  pwagner
! Now able to clear full 2d quantity mask
!
! Revision 2.169  2012/10/29 17:42:31  pwagner
! Added optional args to CloneVectorQuantity, DestroyVectorQuantityValue
!
! Revision 2.168  2012/10/11 21:01:02  pwagner
! Print quantityName instead of moduleName during Dump
!
! Revision 2.167  2012/07/31 00:33:40  vsnyder
! Use Test_Allocate instead of explicit testing followed by MLSMessage.
! Add ForWhom argument to DestroyVectorQuantityMask and
! DestroyVectorQuantityValue.
!
! Revision 2.166  2012/07/10 03:55:49  vsnyder
! Improve comments about VALUE
!
! Revision 2.165  2012/07/07 02:40:47  vsnyder
! Add DestroyMask argument to DestroyVectorQuantityValue
!
! Revision 2.164  2012/07/07 02:02:34  vsnyder
! Add MASK1 and MASK3.  Make MASK and MASK3 rank remappings of MASK1.
! Add VALUE1 and VALUE3.  Make VALUES and VALUE3 rank remappings of VALUE1.
! Add low-level abstractions for creating and destroying masks and values
! for a single vector quantity.
!
! Revision 2.163  2012/05/24 20:32:56  vsnyder
! Change details level for dumping vector quantity templates
!
! Revision 2.162  2012/04/20 01:26:38  vsnyder
! Add DotVectorsMaybeMasked, norms, dump quantity norms
!
! Revision 2.161  2012/03/28 00:55:22  vsnyder
! Indicate mask is dumped in hex
!
! Revision 2.160  2012/02/23 00:08:55  vsnyder
! Don't dump molecule names if quantity type is not vmr
!
! Revision 2.159  2012/02/13 23:21:47  pwagner
! Print moleccule when dumping quantity
!
! Revision 2.158  2012/01/09 22:30:42  pwagner
! More info about dumped vector template
!
! Revision 2.157  2011/12/17 00:37:32  vsnyder
! Add MoveVectorQuantity
!
! Revision 2.156  2011/11/11 00:32:29  vsnyder
! Use IsExtinction array from Molecules module
!
! Revision 2.155  2011/11/01 22:55:48  honghanh
! Remove the nullify statement of vector%template%quantities
! from DestroyVectorInfo
!
! Revision 2.154  2011/10/25 18:08:07  pwagner
! Capitalize USEd items
!
! Revision 2.153  2011/08/02 16:51:40  honghanh
! Re-indent 2 lines of code to make indentation correct.
!
! Revision 2.152  2011/03/15 22:49:35  pwagner
! Added reverseMask; changed default dumpMask behavior to use DUMP_2D_INTEGER
!
! Revision 2.151  2011/03/02 02:15:25  vsnyder
! Make QuantityTemplate_t public, for F95 compatibility
!
! Revision 2.150  2010/05/24 14:48:04  honghanh
! Add comment to GetVectorQtyByTemplateIndex
!
! Revision 2.149  2010/04/28 00:12:20  pwagner
! Correct maskBitNames used in dumping mask
!
! Revision 2.148  2010/04/22 23:38:57  pwagner
! Added new Ignore masking bit
!
! Revision 2.147  2010/02/25 18:07:14  pwagner
! Added extra dump when about to bomb
!
! Revision 2.146  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.145  2009/10/27 23:28:46  pwagner
! Generic Diff must be public, too, at least NAG thinks so
!
! Revision 2.144  2009/10/27 22:16:38  pwagner
! New api for dump vector quantity--drops 'clean', adds 'options'
!
! Revision 2.143  2009/10/26 17:08:44  pwagner
! Added DiffVectorQuantities
!
! Revision 2.142  2009/06/23 18:25:43  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.141  2009/06/16 17:17:55  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.140  2009/05/08 00:39:07  pwagner
! Shows MaskBitNames when dumping Mask bits
!
! Revision 2.139  2009/04/30 22:14:25  pwagner
! name of bit in MaskVectorQty and isVectorQtyMasked now mandatory
!
! Revision 2.138  2009/01/16 23:30:58  vsnyder
! Spiff up a dump
!
! Revision 2.137  2008/12/17 02:57:28  vsnyder
! Dump template with vector quantity if details gt 1
!
! Revision 2.136  2008/11/24 19:36:57  pwagner
! Improved comments, dumps; removed unused variables
!
! Revision 2.135  2008/11/06 21:51:08  pwagner
! Fill method swapValues swaps values between two quantities
!
! Revision 2.134  2008/08/27 19:58:30  vsnyder
! Add PRINT to not_used_here
!
! Revision 2.133  2008/06/09 20:33:59  vsnyder
! Repair some broken comments
!
! Revision 2.132  2008/06/05 02:06:06  vsnyder
! Comments about Aux grids
!
! Revision 2.131  2007/10/09 16:45:02  pwagner
! Corrected declaration of myDetails
!
! Revision 2.130  2007/10/09 00:29:42  pwagner
! Added optional DETAILS arg to some dumps
!
! Revision 2.129  2007/10/06 00:01:28  vsnyder
! Remove unnecessary target attribute
!
! Revision 2.128  2007/10/03 20:51:18  vsnyder
! Add CheckVectorQuantityForNaN
!
! Revision 2.127  2007/04/03 17:41:58  vsnyder
! Revise how allocation status is tested.  Reallocate VectorsDatabase with
! zero size after destroying it.
!
! Revision 2.126  2006/08/05 02:11:58  vsnyder
! Add ForWhom argument to ConstructVectorTemplate
!
! Revision 2.125  2006/08/03 01:10:06  vsnyder
! Put l2cf names in leak track database
!
! Revision 2.124  2006/07/27 03:55:56  vsnyder
! Print summaries if negative details levels, for leak detection
!
! Revision 2.123  2006/06/06 18:54:48  vsnyder
! Spiff up a dump
!
! Revision 2.122  2006/05/23 21:43:34  vsnyder
! Add CLEAR option to some dumps
!
! Revision 2.121  2006/03/22 02:16:28  vsnyder
! Add Vector argument to DumpVectorQuantity just to get its name
!
! Revision 2.120  2006/02/23 00:55:28  vsnyder
! Add NoErr optional argument to GetVectorQuantityIndexByName
!
! Revision 2.119  2006/01/21 00:03:12  livesey
! Added DumpNiceMaskSummary
!
! Revision 2.118  2005/09/02 20:33:22  vsnyder
! Correct error messages in GetVectorQuantityIndexByType
!
! Revision 2.117  2005/06/22 17:25:51  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.116  2005/03/03 02:14:01  vsnyder
! Spiff up some dumps
!
! Revision 2.115  2005/01/07 00:36:51  vsnyder
! Remove unused declarations
!
! Revision 2.114  2004/10/19 02:21:20  livesey
! Logical flaw in radiometer/signal vector querying
!
! Revision 2.113  2004/10/07 23:12:19  vsnyder
! Polish up Dump_Vector_Value for use in ForwardModelVectorTools
!
! Revision 2.112  2004/06/16 22:31:28  vsnyder
! Account for mask in DivideVectors, exchange order of first two arguments
!
! Revision 2.111  2004/06/16 01:18:39  vsnyder
! Add DivideVectors, incomplete comments in TOC about other routines
!
! Revision 2.110  2004/06/10 00:57:47  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.109  2004/05/01 04:07:44  vsnyder
! Rearranged some dumping stuff
!
! Revision 2.108  2004/01/30 23:27:59  livesey
! Added ReciprocateVector, PowVector and an optional argument to
! ClearVector
!
! Revision 2.107  2004/01/24 01:03:04  livesey
! Added allowNameMismatch argument to CopyVector
!
! Revision 2.106  2004/01/23 05:36:51  livesey
! Added DoVectors/QuantitiesMatch
!
! Revision 2.105  2003/09/15 23:28:50  vsnyder
! Remove unused private module variable
!
! Revision 2.104  2003/09/15 17:45:37  livesey
! Added target declaration for fussy intel compiler
!
! Revision 2.103  2003/08/27 20:06:42  livesey
! Bug fix in MaskVectorQty
!
! Revision 2.102  2003/06/20 19:33:53  pwagner
! Quanities now share grids stored separately in databses
!
! Revision 2.101  2003/06/03 20:47:05  livesey
! Typo bug fix
!
! Revision 2.100  2003/06/03 19:23:03  livesey
! Added check to see that vector has not been destroyed
!
! Revision 2.99  2003/05/29 16:36:29  livesey
! New reflector argument to some of the GetVectorQuantity....
!
! Revision 2.98  2003/05/13 04:47:18  livesey
! Added noValues argument to CreateVector
!
! Revision 2.97  2003/05/12 02:05:27  livesey
! Added InflateVectorTemplateDatabase and InflateVectorDatabase
!
! Revision 2.96  2003/05/05 23:00:05  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.95  2003/04/04 22:54:58  livesey
! New mask bits
!
! Revision 2.94.2.3  2003/04/15 23:13:38  vsnyder
! Pass 'clean' option through dump_vector_quantity
!
! Revision 2.94.2.2  2003/03/07 23:51:17  vsnyder
! Copy the quantity index in CopyVector
!
! Revision 2.94.2.1  2003/03/06 23:25:16  vsnyder
! Add Dump_Vector_Quantity
!
! Revision 2.94  2002/11/22 12:57:09  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.93  2002/10/19 18:53:26  livesey
! Changed from huge to our own value (temporarily?)
!
! Revision 2.92  2002/10/17 18:18:25  livesey
! Added low/high bound stuff
!
! Revision 2.91  2002/10/08 00:09:15  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.90  2002/09/26 18:01:08  livesey
! Made GetVectorQuantity... more forgiving in the case of l_vmr (can have
! radiometer wrong if molecule is extinction).
!
! Revision 2.89  2002/09/13 18:08:12  pwagner
! May change matrix precision rm from r8
!
! Revision 2.88  2002/09/11 14:06:12  livesey
! Bug fix in CopyVector
!
! Revision 2.87  2002/08/08 22:06:33  vsnyder
! Add M_Tikhonov
!
! Revision 2.86  2002/08/04 15:55:56  mjf
! Added some nullify statements for Sun's rubbish compiler.
!
! Revision 2.85  2002/07/22 03:26:15  livesey
! Added CheckIntegrity
!
! Revision 2.84  2002/07/01 23:51:30  vsnyder
! Plug a memory leak
!
! Revision 2.83  2002/05/17 17:56:01  livesey
! More checks in ValidateVectorQuantity
!
! Revision 2.82  2002/05/14 00:28:04  livesey
! More informative messages in GetVectorQuantityByType
!
! Revision 2.81  2002/04/22 20:54:29  vsnyder
! Add a 'scale' argument to AddToVector
!
! Revision 2.80  2002/03/13 22:00:16  livesey
! Changed m_explicitFill to m_fill
!
! Revision 2.79  2002/03/08 08:06:32  livesey
! Added explicit fill mask
!
! Revision 2.78  2002/02/14 23:15:22  vsnyder
! Add .mdot. operator
!
! Revision 2.77  2002/02/08 22:58:14  livesey
! Made CopyVectorMask public
!
! Revision 2.76  2002/02/08 22:51:40  livesey
! Added CopyVectorMask
!
! Revision 2.75  2002/02/07 02:53:06  vsnyder
! Add parameter for FullDerivatives bit for mask
!
! Revision 2.74  2002/02/05 02:39:59  vsnyder
! Change mask from 1-bit per to 8-bits per (using character)
!
! Revision 2.73  2002/01/18 00:34:53  livesey
! Bug fix, copyVector wasn't ensuring that mask in destination was
! allocated.
!
! Revision 2.72  2001/10/23 16:39:28  pwagner
! Added MaskVectorQty
!
! Revision 2.71  2001/10/18 23:49:46  livesey
! Tidied up a floating comma in dump_vector
!
! Revision 2.70  2001/10/18 23:31:56  pwagner
! Expanded use of details in dump_vectors; stops if try to rmVectorFromDatabase
!
! Revision 2.69  2001/10/15 22:11:54  livesey
! Added globalUnit stuff
!
! Revision 2.68  2001/10/12 23:10:18  pwagner
! Better dumps, fewer bumps
!
! Revision 2.67  2001/10/09 23:43:42  pwagner
! Some further improvements in dumping vectors
!
! Revision 2.66  2001/10/08 23:40:49  pwagner
! Improved dump routines
!
! Revision 2.65  2001/10/05 17:33:55  vsnyder
! Don't set more bits in the mask than there are elements of VALUES
!
! Revision 2.64  2001/10/04 01:50:33  vsnyder
! Add 'database' argument to CloneVector, CopyVector; cosmetic changes
!
! Revision 2.63  2001/10/03 23:05:42  vsnyder
! Added 'VectorNameText' argument to CopyVector
!
! Revision 2.62  2001/10/02 23:39:15  vsnyder
! Add quantity name to error message in GetVectorQuantityIndexByType
!
! Revision 2.61  2001/10/02 19:00:50  vsnyder
! Add ClearVector subroutine
!
! Revision 2.60  2001/10/01 20:32:27  vsnyder
! Handle word and bit indexing in mask consistently
!
! Revision 2.59  2001/09/29 00:25:51  vsnyder
! Correct word indexing for mask operations
!
! Revision 2.58  2001/09/25 19:41:07  livesey
! Added DumpMask
!
! Revision 2.57  2001/09/25 00:47:08  vsnyder
! Add noMask & noValues optional arguments to CopyVector
!
! Revision 2.56  2001/09/25 00:18:23  livesey
! Bug fix
!
! Revision 2.55  2001/09/24 23:01:11  vsnyder
! Make consistent/correct lower bound calculation for MASK array
!
! Revision 2.54  2001/09/21 17:38:46  pwagner
! Added args to dump_vector(s)
!
! Revision 2.53  2001/09/20 23:02:31  vsnyder
! Specified explicitly which entities are public (so as not to re-publish
! everything gotten by USE).  Added ClearUnderMask subroutine.
!
! Revision 2.52  2001/09/20 20:56:34  pwagner
! Added contents list; tweaked some things
!
! Revision 2.51  2001/09/19 23:40:53  pwagner
! Added rmVectorFromDatabase, isVectorQtyMasked functions
!
! Revision 2.50  2001/09/17 23:10:49  pwagner
! New optional arg majorFrame in Validate..
!
! Revision 2.49  2001/07/19 17:57:15  vsnyder
! Added 'Quant' and 'Inst' arguments to CopyVector and MultiplyVectors
!
! Revision 2.48  2001/07/17 17:33:21  livesey
! Added CreateMaskArray
!
! Revision 2.47  2001/07/06 22:04:02  livesey
! Added call to DestroyVectorMask in DestroyVectorInfo
!
! Revision 2.46  2001/06/26 20:32:31  vsnyder
! Simplify mask handling by using zero origin for first dimension
!
! Revision 2.45  2001/06/01 01:04:22  vsnyder
! Add 'Multiply' generic
!
! Revision 2.44  2001/05/25 22:33:07  livesey
! Changed a comment
!
! Revision 2.43  2001/05/17 20:17:00  vsnyder
! Don't clobber Y argument of ScaleVector by making it intent(out) -- we
! need to check its template.
!
! Revision 2.42  2001/05/11 23:33:29  vsnyder
! Get rid of double-printing of 'Without mask'
!
! Revision 2.41  2001/05/11 22:01:00  vsnyder
! Simplify dumping just one vector
!
! Revision 2.40  2001/05/10 23:29:59  livesey
! Added some arguments to ValidateVectorQuantity
!
! Revision 2.39  2001/05/10 23:11:54  vsnyder
! Add a dumper for one vector
!
! Revision 2.38  2001/05/08 20:28:34  vsnyder
! Added stuff to dump masks
!
! Revision 2.37  2001/05/03 02:12:03  vsnyder
! Take out a line of debugging scaffolding
!
! Revision 2.36  2001/05/02 20:44:37  vsnyder
! Provide for text names for vectors that didn't come from CF
!
! Revision 2.35  2001/05/02 05:29:44  livesey
! Added index argument to GetVectorQtyByTemplateIndex
!
! Revision 2.34  2001/04/28 21:01:20  livesey
! Another bug fix in GetVectorQuantityByType
!
! Revision 2.33  2001/04/28 20:54:48  livesey
! Minor bug fix in GetVectorQuantityByType
!
! Revision 2.32  2001/04/28 07:04:32  livesey
! Minor bug fix
!
! Revision 2.31  2001/04/28 01:48:52  vsnyder
! Improve dump
!
! Revision 2.30  2001/04/28 01:27:38  livesey
! Quite an important change here.  Contents of VectorTemplate_T, VectorValue_T
! are now copies of their original entries from databases, not pointers.
!
! Revision 2.29  2001/04/25 21:57:07  livesey
! Removed insulate vector (that didn't last very long :-( )
!
! Revision 2.28  2001/04/25 20:15:23  livesey
! Tidied up InsulateVector
!
! Revision 2.27  2001/04/25 01:35:01  vsnyder
! Assignment should have been pointer assignment in CloneVector
!
! Revision 2.26  2001/04/25 01:24:54  vsnyder
! Give initial values to 'name' fields
!
! Revision 2.25  2001/04/24 21:33:53  livesey
! Added insulate vector
!
! Revision 2.24  2001/04/20 00:07:15  livesey
! Added the index field to vectorvalue_t
!
! Revision 2.23  2001/04/18 23:27:00  pwagner
! Added default .true. to Validate; also optional sayWhyNot
!
! Revision 2.22  2001/04/12 21:43:19  livesey
! Added sideband option to the quantity searches
!
! Revision 2.21  2001/04/10 22:38:20  vsnyder
! Add 'details' argument to dump routines
!
! Revision 2.20  2001/03/21 02:14:37  livesey
! Add noError argument to GetVectorQtyByType
!
! Revision 2.19  2001/03/19 17:10:47  livesey
! Added more options to validate vector quantity
!
! Revision 2.18  2001/03/16 18:17:49  livesey
! Added second vector argument and more conditions to GetVectorQuantityByType
!
! Revision 2.17  2001/03/05 00:53:59  livesey
! Added molecule argument to ValidateVectorQuantity
!
! Revision 2.16  2001/03/03 00:07:01  livesey
! Added GetVectorQtyByTemplateIndex
!
! Revision 2.15  2001/02/28 17:34:25  livesey
! Added minorFrame optional argument to ValidateVectorQuantity
!
! Revision 2.14  2001/02/27 17:18:53  livesey
! Added ValidateVectorQuantity
!
! Revision 2.13  2001/02/21 21:50:38  livesey
! Added a line to zero out a vector on creation.  Kind of like using training
! wheels in a bicycle, but avoids painful core dumps when trying to output
! unfilled vectors.
!
! Revision 2.12  2001/02/09 00:38:56  livesey
! Various changes
!
! Revision 2.11  2001/02/08 00:36:29  vsnyder
! Don't destroy in DestroyVectorValues if vector%quantities is disassociated
!
! Revision 2.10  2001/02/08 00:34:41  vsnyder
! Don't destroy in DestroyVectorInfo if vector%quantities is disassociated
!
! Revision 2.9  2001/01/26 19:00:02  vsnyder
! Periodic commit
!
! Revision 2.8  2001/01/19 23:49:59  vsnyder
! Periodic commit
!
! Revision 2.7  2001/01/10 21:03:14  vsnyder
! Periodic commit
!
! Revision 2.6  2001/01/03 02:01:30  vsnyder
! Add molecule/radiometer functionality to GetVectorQuantityIndexByType
!
! Revision 2.5  2000/12/04 23:43:59  vsnyder
! Move more of addItemToDatabase into the include
!
! Revision 2.4  2000/11/23 01:10:27  vsnyder
! Add "mask" field to specify columns to ignore when vector is row- or
! column-specifier for a matrix.
!
! Revision 2.3  2000/11/15 01:33:58  vsnyder
! Added copyVector, assignment(=)
!
! Revision 2.2  2000/11/10 00:24:24  vsnyder
! Changed VectorValue_t%values from rank-3 to rank-2
!
! Revision 2.1  2000/10/13 00:00:37  vsnyder
! Moved from mlspgs/l2 to mlspgs/lib
!
! Revision 2.0  2000/09/05 18:57:05  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.1  2000/09/02 02:05:04  vsnyder
! Initial entry
!

@


2.211
log
@Added BinNumber and MAF components to vector qties
@
text
@d2141 2
a2142 2
    type (VectorValue_T), intent(in) :: QTY
    integer, intent(in), optional :: DETAILS ! <0  => Name only
d2148 2
a2149 2
    character(len=*), intent(in), optional :: NAME
    type (Vector_T), intent(in), optional :: Vector ! Only to get its name
d2157 1
d2319 1
a2319 1
    else
d2324 1
a2324 1
    else
d3519 1
a3519 1
       "$Id: VectorsModule.f90,v 2.210 2018/05/11 21:26:27 pwagner Exp $"
d3531 3
@


2.210
log
@Moved M_ mask bit fields to MLSCommon
@
text
@d364 3
d990 8
d1373 8
d2316 10
d3518 1
a3518 1
       "$Id: VectorsModule.f90,v 2.209 2018/02/27 00:50:33 livesey Exp $"
d3530 3
@


2.209
log
@Added the supportedInstrumentModule argument to the various search routines to support A-SMLS
@
text
@d126 2
a365 9
  ! Bit of MASK field of VectorValue_T
  integer, parameter :: M_Cloud = 2**4
  integer, parameter :: M_Fill = 2**2
  integer, parameter :: M_FullDerivatives = 2**1
  integer, parameter :: M_Ignore = 2**5
  integer, parameter :: M_LinAlg = 2**0      ! Don't use in linear algebra
  integer, parameter :: M_Spare = 2**6
  integer, parameter :: M_Tikhonov = 2**3    ! Where to do Tikhonov regularization

d3489 1
a3489 1
       "$Id: VectorsModule.f90,v 2.208 2017/11/03 19:57:59 pwagner Exp $"
d3501 3
@


2.208
log
@Most array gymnastics moved from MLSFillValues to HyperSlabs module
@
text
@d2440 1
a2440 1
    & molecule, instrumentModule, radiometer, reflector, signal, &
d2456 1
d2477 1
a2477 1
      & quantityType, molecule, instrumentModule, radiometer, reflector, signal, &
d2487 1
a2487 1
          &  quantityType, molecule, instrumentModule, radiometer, reflector, signal, &
d2609 2
a2610 1
    & molecule, instrumentModule, radiometer, reflector, signal, sideband, noError )
d2626 1
d2652 4
d3496 1
a3496 1
       "$Id: VectorsModule.f90,v 2.207 2016/11/15 19:29:55 pwagner Exp $"
d3508 3
@


2.207
log
@Prevent error from 0-size arrays when remapping pointer rank
@
text
@d116 5
a120 4
  use allocate_deallocate, only: allocate_test, deallocate_test, test_allocate, &
    & test_deallocate
  use, intrinsic :: iso_c_binding, only: c_intptr_t, c_loc
  use bitStuff, only: dumpBitNames, isBitSet
d122 6
a127 7
  use dump_0, only: dump
  use highOutput, only: outputNamedValue
  use intrinsic, only: lit_indices, phyq_invalid, l_vmr
  use lexer_core, only: where_t
  use MLSFillValues, only: extractArray
  use MLSFinds, only: findFirst, findUnique
  use MLSKinds, only: r8, rv
d130 9
a138 9
  use MLSSignals_m, only: modules, signals, getSignalName
  use output_m, only: blanks, newline, output
  use quantityTemplates, only: quantityTemplate_t, checkIntegrity, &
    & copyQuantityTemplate, destroyQuantityTemplateContents, dump, &
    & nullifyQuantityTemplate
  use string_table, only: display_string, get_string_rude=>get_string, &
    & isStringInTable, string_length
  use symbol_table, only: enter_terminal
  use symbol_types, only: t_identifier
d799 1
a799 1
    use ieee_arithmetic, only: ieee_is_nan
d1169 2
a1170 2
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
d1678 2
a1679 2
      use intrinsic, only: l_angle, l_geodaltitude, l_gph, l_none, &
        & l_pressure, l_theta, l_zeta
d1736 2
a1737 2
    use MLSStringLists, only: expandStringRange, optionDetail
    use MLSStrings, only: readNumsFromChars
d1921 1
a1921 1
    use Lexer_Core, only: print_source
d2310 1
a2310 1
    use QuantityTemplates, only: dump
d2570 1
a2570 1
    use MLSStrings, only: lowercase
d2616 2
a2617 2
    use MLSSignals_m, only: getRadiometerName
    use molecules, only: isExtinction
d2953 1
a2953 1
    use Pointer_Rank_Remapping, only: remap
d2974 1
a2974 1
    use Pointer_Rank_Remapping, only: remap
d3489 1
a3489 1
       "$Id: VectorsModule.f90,v 2.206 2016/07/28 01:42:27 vsnyder Exp $"
d3501 3
@


2.206
log
@Refactoring dump and diff
@
text
@d2273 2
d3489 1
a3489 1
       "$Id: VectorsModule.f90,v 2.205 2016/05/27 00:14:05 vsnyder Exp $"
d3501 3
@


2.205
log
@Publish RV because this seems like a logical place to get it
@
text
@d120 2
a121 1
  use dump_0, only: diff, dump
d3487 1
a3487 1
       "$Id: VectorsModule.f90,v 2.204 2016/04/13 00:47:18 vsnyder Exp $"
d3499 3
@


2.204
log
@Make AreEqual generic.  Add AreUnEqual, operator(==), and operator(/=)
@
text
@d184 1
a184 1
    & M_SPARE, M_TIKHONOV
d3486 1
a3486 1
       "$Id: VectorsModule.f90,v 2.203 2015/09/24 18:46:09 pwagner Exp $"
d3498 3
@


2.203
log
@Prevent an obscure cause of crashing when index too big in GetVectorQtyByTemplateIndex
@
text
@d35 2
d142 4
a145 2
  public :: Assignment (=), Multiply, operator (+), operator (-)
  public :: operator (*), operator ( .DOT. ), operator ( .MDOT. )
d149 3
a151 3
  public :: ADDVECTORTODATABASE, AREEQUAL, ASSIGNVECTOR, AXPY, CHECKINTEGRITY
  public :: CHECKNAN, CHECKVECTORFORNAN, CHECKVECTORQUANTITYFORNAN
  public :: CLEARMASK, CLEARUNDERMASK, CLEARVECTOR
d192 8
d251 8
d480 2
a481 2
  ! ----------------------------------------  Areequal  -----
  logical function Areequal ( A, B, C )
d483 2
a484 3
  ! This routine checks that all values in a vector are equal to either:
  ! (1) values in a 2nd vector with matching quantities; or
  ! (2) equal to a supplied scalar
a487 1
    type (Vector_T), intent(in), optional ::  B
d492 24
d519 11
a529 1
    Areequal = .true.
d531 17
a547 17
    if ( present(b) ) then
      do qIndex = 1, size ( a%quantities ) 
        aq => a%quantities(qIndex)
        bq => b%quantities(qIndex)
        if ( .not. associated(aq) .or. .not. associated(bq) ) cycle
        Areequal = Areequal .and. all(aq%values == bq%values)
        if ( .not. Areequal ) exit
      end do
    else
      do qIndex = 1, size ( a%quantities ) 
        aq => a%quantities(qIndex)
        if ( .not. associated(aq) ) cycle
        Areequal = Areequal .and. all(aq%values == c)
        if ( .not. Areequal ) exit
      end do
    end if
  end function Areequal
d3486 1
a3486 1
       "$Id: VectorsModule.f90,v 2.202 2015/09/17 22:55:23 pwagner Exp $"
d3498 3
@


2.202
log
@Will now complain, quit in GetVectorQtyByTemplateIndex if index too big
@
text
@d2466 2
a2467 1
    if ( myIndexInVector /= 0 ) &
d3434 1
a3434 1
       "$Id: VectorsModule.f90,v 2.201 2015/07/14 23:20:47 pwagner Exp $"
d3446 3
@


2.201
log
@Prevent more crashes due to get_string
@
text
@d516 1
a516 1
    use MLSMESSAGEMODULE, only: MLSMSG_CRASH, MLSMESSAGE
d746 1
a746 1
    use IEEE_ARITHMETIC, only: IEEE_IS_NAN
d1116 2
a1117 2
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d1625 2
a1626 2
      use intrinsic, only: L_ANGLE, L_GEODALTITUDE, L_GPH, L_NONE, &
        & L_PRESSURE, L_THETA, L_ZETA
d1683 2
a1684 2
    use MLSSTRINGLISTS, only: EXPANDSTRINGRANGE, OPTIONDETAIL
    use MLSSTRINGS, only: READNUMSFROMCHARS
d1868 1
a1868 1
    use Lexer_Core, only: PRINT_SOURCE
d2255 1
a2255 1
    use QuantityTemplates, only: DUMP
d2469 3
d2514 1
a2514 1
    use MLSSTRINGS, only: LOWERCASE
d2560 2
a2561 2
    use MLSSignals_m, only: GETRADIOMETERNAME
    use MOLECULES, only: ISEXTINCTION
d2897 1
a2897 1
    use Pointer_Rank_Remapping, only: REMAP
d2918 1
a2918 1
    use Pointer_Rank_Remapping, only: REMAP
d3433 1
a3433 1
       "$Id: VectorsModule.f90,v 2.200 2015/06/19 00:35:49 pwagner Exp $"
d3445 3
@


2.200
log
@Setup quick changes to print when destroying vectors
@
text
@d114 22
a135 21
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST, TEST_ALLOCATE, &
    & TEST_DEALLOCATE
  use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
  use BITSTUFF, only: DUMPBITNAMES, ISBITSET
  use DUMP_0, only: DIFF, DUMP
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use INTRINSIC, only: LIT_INDICES, PHYQ_INVALID, L_VMR
  use LEXER_CORE, only: WHERE_T
  use MLSFILLVALUES, only: EXTRACTARRAY
  use MLSFINDS, only: FINDFIRST, FINDUNIQUE
  use MLSKINDS, only: R8, RV
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMESSAGECONFIG, MLSMSG_ERROR, &
    & MLSMSG_WARNING
  use MLSSIGNALS_M, only: MODULES, SIGNALS, GETSIGNALNAME
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT
  use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, CHECKINTEGRITY, &
    & COPYQUANTITYTEMPLATE, DESTROYQUANTITYTEMPLATECONTENTS, DUMP, &
    & NULLIFYQUANTITYTEMPLATE
  use STRING_TABLE, only: DISPLAY_STRING, GET_STRING, STRING_LENGTH
  use SYMBOL_TABLE, only: ENTER_TERMINAL
  use SYMBOL_TYPES, only: T_IDENTIFIER
d2461 1
a2461 1
      call get_string ( vector%name, msg(len_trim(msg):len(msg)), strip=.true. )
d3407 19
d3430 1
a3430 1
       "$Id: VectorsModule.f90,v 2.199 2015/06/04 01:57:16 vsnyder Exp $"
d3442 3
@


2.199
log
@Add contiguous attribute, avoid using remapped values
@
text
@d1239 1
d1241 1
a1241 1

d1243 5
a1247 1

d1252 1
d1254 1
d1259 1
d3410 1
a3410 1
       "$Id: VectorsModule.f90,v 2.198 2015/05/01 02:09:28 vsnyder Exp $"
d3422 3
@


2.198
log
@Spiff a dump
@
text
@d297 9
a305 10
    real(rv), dimension(:), pointer :: VALUE1 => NULL() ! The dimension of
    ! VALUE1 is Frequencies (or 1) * Vertical Coordinates or MIF (or 1) *
    ! Horizontal Instances (scan or profile or 1) * Cross-track instances. 
    ! These are taken from (template%noChans * template%noSurfs *
    ! template%noInstances).  This is the one that's allocated and
    ! deallocated.
    real(rv), dimension(:,:), pointer :: VALUES => NULL() ! The dimensions of
    ! VALUES are Frequencies (or 1) * Vertical Coordinates or MIF (or 1), and
    ! Horizontal Instances (scan or profile or 1) * Cross-track instances. 
    ! These are taken from (template%noChans * template%noSurfs,
d307 4
a310 4
    real(rv), dimension(:,:,:), pointer :: VALUE3 => NULL() ! The dimensions
    ! of VALUE3 are Frequencies, Vertical Coordinates or MIF, and Horizontal
    ! Instances (MAF or profile or 1) * Cross-track instances.  These are
    ! taken from template%noChans, template%noSurfs, and
d312 4
a315 4
    real(rv), dimension(:,:,:,:), pointer :: VALUE4 => NULL() ! The dimensions
    ! of VALUE3 are Frequencies, Vertical Coordinates or MIF, Horizontal
    ! Instances (MAF or profile or 1), and Cross-track instances.  These are
    ! taken from template%noChans, template%noSurfs, and
d317 2
a318 2
    character, dimension(:), pointer :: MASK1 => NULL() ! MASK1 is the
    ! array that is allocated and deallocated.  MASK and MASK3 are rank
d320 5
a324 5
    character, dimension(:,:), pointer :: MASK => NULL() ! MASK is used to
    ! control whether elements of vectors are of interest. If MASK is not
    ! associated, every element is of interest.  Otherwise,the dimensions of
    ! MASK are the same as VALUES.  Bits of MASK(i,j) are used to determine
    ! what is not interesting.  Zero means something about VALUES(i,j) is
d330 2
a331 2
    character, dimension(:,:,:), pointer :: MASK3 => NULL() ! This is used
    ! for masking VALUE3, and has the same dimensions.  This is a rank
d333 2
a334 2
    character, dimension(:,:,:,:), pointer :: MASK4 => NULL() ! This is used
    ! for masking VALUE4, and has the same dimensions.  This is a rank
d2065 2
d2090 2
d2196 2
a2197 2
        if ( size(qty%value3,1) > 1 ) then
          call output ( size(qty%value4,1) )
d2200 5
a2204 4
        call output ( size(qty%value4,2) )
        call output ( size(qty%value4,3), before='x' )
        if ( size(qty%value4,4) > 1 ) call output ( size(qty%value4,4), before='x' )
        call output ( size(qty%value3), before=' = ' )
d2213 6
a2218 1
      call dump ( qty%value4, '  Elements = ', options=options )
d2306 2
d2317 4
d2327 5
a2331 2
      call ExtractArray ( GatherVectorQuantity%value1, quantity%value1, &
        & start, count, stride, block, options='-a' )
d2336 12
a2347 2
      call ExtractArray ( GatherVectorQuantity%value3, quantity%value3, &
        & start, count, stride, block, options='-a' )
d3402 1
a3402 1
       "$Id: VectorsModule.f90,v 2.197 2015/04/29 00:53:56 vsnyder Exp $"
d3414 3
@


2.197
log
@Spiff the dump
@
text
@d2170 1
a2170 1
        call output ( '    (no database entry for this quantity) ' )
d2172 1
a2172 1
        call display_string ( modules(qty%template%instrumentModule)%name )
d2174 17
a2190 5
      call output ( qty%template%instrumentmodule, before=' = ', advance='yes')
      call output ( '    Minor Frame? (t/f): ')
      call output ( qty%template%minorframe )
      call output ( ' Major Frame? (t/f): ')
      call output ( qty%template%majorframe, advance='yes' )
d3374 1
a3374 1
       "$Id: VectorsModule.f90,v 2.196 2015/03/28 01:47:29 vsnyder Exp $"
d3386 3
@


2.196
log
@Added 4-d Values and Mask.  Additional dimension extent is NoCrossTrack.
Added stuff to trace allocate/deallocate addresses.
@
text
@d2144 11
a2167 11
      if ( qty%template%quantityType == l_vmr ) then
        call output ( '    molecule: ')
        if ( qty%template%molecule < 1 ) then
          call output ( '    (no database entry for this quantity) ' )
        else
          call display_string ( lit_indices(qty%template%molecule) )
        end if
      else if ( qty%template%quantityType > 0 ) then
        call output( 'Quantity type: ', advance='no' )
        call display_string ( lit_indices(qty%template%quantityType), advance='yes' )
      end if
d3362 1
a3362 1
       "$Id: VectorsModule.f90,v 2.195 2014/11/08 01:05:15 pwagner Exp $"
d3374 4
@


2.195
log
@CreateVectorValue relies on DestroyVectorQuantityValue to deallocate its values
@
text
@d98 2
a99 2
! RemapVectorMask              Remap MASK1 to MASK and MASK3
! RemapVectorValue             Remap VALUE1 to VALUES and VALUE3
d116 1
d299 4
a302 3
    ! Horizontal Instances (scan or profile or 1).  These are taken from 
    ! (template%noChans * template%noSurfs * template%noInstances).  This is
    ! the one that's allocated and deallocated.
d305 3
a307 3
    ! Horizontal Instances (scan or profile or 1).  These are taken from
    ! (template%noChans * template%noSurfs, template%noInstances).  This is a
    ! rank remapping of VALUE1.
d310 8
a317 3
    ! Instances (MAF or profile or 1).  These are taken from
    ! template%noChans, template%noSurfs, and template%noInstances.  This is
    ! a rank remapping of VALUE1.
d334 3
d486 1
a486 1
      enddo
d493 2
a494 2
      enddo
    endif
d792 1
a792 1
    enddo
d874 1
d883 4
d888 2
a889 1
      & uBounds=[size(x%quantities)], elementSize=storage_size(z%quantities) / 8 )
d1116 3
d1134 1
d1136 1
d1142 3
d1151 5
d1158 1
a1158 1
      & elementSize = storage_size(vector%quantities) / 8 )
d1169 3
d1190 2
a1191 1
        & value%template%noInstances )
d1213 1
d1221 2
d1224 1
a1224 1
      call test_deallocate ( status, moduleName, 'database', s )
d1239 1
d1251 2
d1254 1
a1254 1
    call test_deallocate ( status, moduleName, 'vector%quantities', s )
d1319 1
d1323 8
a1330 6
       do l2gpIndex = 1, SIZE(database)
          call DestroyVectorTemplateInfo ( database(l2gpIndex) )
       end do
       s = size(database) * storage_size(database) / 8
       deallocate ( database, stat=status )
       call test_deallocate ( status, moduleName, 'database', s )
d1712 2
a1713 2
      endif
    endif
d1717 1
a1717 1
    endif
d1728 1
a1728 1
    elseif( myDetails == 0 ) then
d1737 1
a1737 1
      enddo
d1739 1
a1739 1
    elseif ( index(myOptions, 'l') < 1 .and. index(myOptions, 'L') < 1 ) then
d1765 1
a1765 1
    endif
d1775 1
a1775 1
      endif
d1779 1
a1779 1
      elseif ( index(myOptions, 'l') > 0 ) then
d1787 1
a1787 1
        enddo
d1792 2
a1793 2
        endif
      elseif ( index(myOptions, 'L') > 0 ) then
d1801 1
a1801 1
        enddo
d1806 3
a1808 3
        endif
      endif
    enddo
d1927 1
a1927 1
    endif
d2098 1
a2098 1
    elseif ( qty%template%name /= 0 ) then
d2133 1
a2133 1
      endif
d2138 2
a2139 2
      endif
    elseif ( qty%template%name /= 0 ) then
d2141 1
a2141 1
    endif
d2147 2
a2148 1
      call output ( qty%template%instanceLen, before=' instanceLen = ', advance='yse' )
d2164 1
a2164 1
      elseif ( qty%template%quantityType > 0 ) then
d2180 9
a2188 2
        call output ( size(qty%values(:,1)), before='    values array size is ' )
        call output ( size(qty%values(1,:)), before='x' )
d2190 3
a2192 3
        call output ( '    values array size is 0', advance='yes' )
      endif
    endif
d2195 1
a2195 1
    elseif ( myDetails > 0 ) then
d2197 1
a2197 1
      call dump ( qty%values, '  Elements = ', options=options )
d2208 1
a2208 1
        enddo
d2256 1
a2256 1
    elseif ( .not. associated(vector_template%quantities) ) then
d2727 1
d2848 4
a2851 3
      & (/ value%template%noChans * &
      &    value%template%noSurfs,  &
      &    value%template%noInstances /) )
d2853 9
a2861 3
      & (/ value%template%noChans,  &
      &    value%template%noSurfs,  &
      &    value%template%noInstances /) )
d2869 4
a2872 3
      & (/ value%template%noChans * &
      &    value%template%noSurfs,  &
      &    value%template%noInstances /) )
d2874 9
a2882 3
      & (/ value%template%noChans,  &
      &    value%template%noSurfs,  &
      &    value%template%noInstances /) )
d2944 1
a2944 1
    endif
d3362 1
a3362 1
       "$Id: VectorsModule.f90,v 2.194 2014/10/02 22:08:35 vsnyder Exp $"
d3374 3
@


2.194
log
@Default initialize all components of Vector*_T
@
text
@d1154 2
a1155 2
    call deallocate_test ( value%value1, &
      & trim(value%AllocationName), moduleName )
a1159 13
    if ( associated(value%value1) .and. associated(value%values) .and. &
         associated(value%value3) ) then
      if ( size(value%value1) == &
        & value%template%noChans * &
          & value%template%noSurfs * &
          & value%template%noInstances .and. &
        & size(value%values,1) == value%template%noChans * &
          & value%template%noSurfs .and. &
        & size(value%values,2) == value%template%noInstances .and. &
        & size(value%value3,1) == value%template%noChans .and. &
          & size(value%value3,2) == value%template%noSurfs .and. &
          & size(value%value3,3) == value%template%noInstances ) return
    end if
d3297 1
a3297 1
       "$Id: VectorsModule.f90,v 2.193 2014/09/05 00:20:54 vsnyder Exp $"
d3309 3
@


2.193
log
@More complete and accurate allocate/deallocate size tracking.  Remove some
debugging cruft that shouldn't have been checked in.
@
text
@d276 2
a277 2
    integer :: Name = 0        ! Sub-rosa index of name, if any, else zero
    type(where_t) :: Where     ! Source_ref for creation if by L2CF
d281 3
a283 3
    integer :: NoQuantities    ! Number of quantities in the vector
    integer :: TotalInstances  ! Number of horizontal instances in the vector
    integer :: TotalElements   ! Total of numbers of elements in the vector
d295 1
a295 1
    integer :: index            ! Index of this quantity in the vector database
d327 1
a327 1
    integer :: label = 0        ! An optional label for this to be used as for
d330 1
a330 1
    character(len=40)                   :: AllocationName = 'None'
d343 1
a343 1
    & 'linear algebra  ', 'full derivatives', 'fill            ', &
d3310 1
a3310 1
       "$Id: VectorsModule.f90,v 2.192 2014/09/04 20:23:41 pwagner Exp $"
d3322 4
@


2.192
log
@Turn off all those debugging print statements
@
text
@d124 2
a125 2
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_ALLOCATE, MLSMESSAGECONFIG, &
    & MLSMSG_DEALLOCATE, MLSMSG_WARNING, MLSMESSAGE
d872 2
a873 1
    call test_allocate ( status, moduleName, "z%quantities" )
a906 4
integer :: I, J
character, pointer :: C1, C2, C3
! print '(a)', 'CloneVectorQuantity 1'

a910 1
! print '(a)', 'CloneVectorQuantity 2'
a912 1
! print '(a)', 'CloneVectorQuantity 3'
d915 1
a915 2
! print '(a)', 'CloneVectorQuantity 4'
    endif
a918 1
! print '(a)', 'CloneVectorQuantity 5'
a919 1
! print '(a)', 'CloneVectorQuantity 6'
a922 35
! print '(a)', 'CloneVectorQuantity 7'
! call dump ( x, details=2 )
! print '(a)', 'CloneVectorQuantity 7.1'
if ( .not. associated(z%mask) ) then
  print '(a)', 'Why is z%mask not associated?'
else
  if ( .not. associated(z%mask1) ) print '(a)', 'Why is z%mask1 not associated?'
  if ( .not. associated(z%mask3) ) print '(a)', 'Why is z%mask3 not associated?'
  if ( associated(z%mask1) .and. associated(z%mask3) ) then
    c1 => z%mask1(1)
    c2 => z%mask(1,1)
    c3 => z%mask3(1,1,1)
    if ( .not. associated(c1,c2) ) print '(a)', 'Why are C1 and C2 not associated?'
    if ( .not. associated(c3,c2) ) print '(a)', 'Why are C3 and C2 not associated?'
  end if
  ! print '(a)', 'CloneVectorQuantity 7.2'
  ! call dump ( z, details=2, name='ZZZZ' )
! print '(a)', 'CloneVectorQuantity 7.3'
  if ( size(z%mask) /= size(x%mask) ) then
    print '(a)', 'Why do x%mask and z%mask have different sizes?'
  end if
! print '(a)', 'CloneVectorQuantity 7.3.1'
  if ( any(shape(z%mask) /= shape(x%mask)) ) then
    print '(a)', 'Why do x%mask and z%mask have different shapes?'
  end if
end if
! print '(a)', 'CloneVectorQuantity 7.4'
! print '(a,i0)', 'Count(ichar(x%mask)/=0) = ', Count(ichar(x%mask)/=0)
! print '(a,i0)', 'Count(ichar(z%mask)/=0) = ', Count(ichar(z%mask)/=0)
! print '(2(a,2i5))', 'Shape(x%mask) = ', shape(x%mask), ' Shape(z%mask) = ', shape(z%mask)
do i = 1, size(x%mask,1)
do j = 1, size(x%mask,2)
! print '(5(a,i0))', 'Doing z%mask(',i,',',j,') = x%mask(',i,',',j,')'
z%mask(i,j) = x%mask(i,j)
end do; end do
a923 1
! print '(a)', 'CloneVectorQuantity 8'
a925 1
! print '(a)', 'CloneVectorQuantity 9'
d1127 3
a1129 1
    call test_allocate ( status, moduleName, "Vector quantities" )
d1193 1
a1193 1
    integer :: l2gpIndex, Status
d1199 1
d1201 1
a1201 1
      call test_deallocate ( status, moduleName, 'database', 0 )
d1216 1
a1216 1
    integer :: STATUS
d1226 1
d1228 1
a1228 1
    call test_deallocate ( status, moduleName, 'vector%quantities', 0 )
d1293 1
a1293 1
    integer :: l2gpIndex, Status
d1299 1
d1301 1
a1301 1
       call test_deallocate ( status, moduleName, 'database', 0 )
d3310 1
a3310 1
       "$Id: VectorsModule.f90,v 2.191 2014/08/19 00:29:59 vsnyder Exp $"
d3322 3
@


2.191
log
@Add VectorMemoryInUse, VectorsMemoryInUse
@
text
@d908 1
a908 1
print '(a)', 'CloneVectorQuantity 1'
d914 1
a914 1
print '(a)', 'CloneVectorQuantity 2'
d917 1
a917 1
print '(a)', 'CloneVectorQuantity 3'
d920 1
a920 1
print '(a)', 'CloneVectorQuantity 4'
d925 1
a925 1
print '(a)', 'CloneVectorQuantity 5'
d927 1
a927 1
print '(a)', 'CloneVectorQuantity 6'
d931 3
a933 3
print '(a)', 'CloneVectorQuantity 7'
call dump ( x, details=2 )
print '(a)', 'CloneVectorQuantity 7.1'
d946 3
a948 3
  print '(a)', 'CloneVectorQuantity 7.2'
  call dump ( z, details=2, name='ZZZZ' )
print '(a)', 'CloneVectorQuantity 7.3'
d950 1
a950 1
  print '(a)', 'Why do x%mask and z%mask have different sizes?'
d952 1
a952 1
print '(a)', 'CloneVectorQuantity 7.3.1'
d954 1
a954 1
  print '(a)', 'Why do x%mask and z%mask have different shapes?'
d957 4
a960 4
print '(a)', 'CloneVectorQuantity 7.4'
print '(a,i0)', 'Count(ichar(x%mask)/=0) = ', Count(ichar(x%mask)/=0)
print '(a,i0)', 'Count(ichar(z%mask)/=0) = ', Count(ichar(z%mask)/=0)
print '(2(a,2i5))', 'Shape(x%mask) = ', shape(x%mask), ' Shape(z%mask) = ', shape(z%mask)
d963 1
a963 1
print '(5(a,i0))', 'Doing z%mask(',i,',',j,') = x%mask(',i,',',j,')'
d967 1
a967 1
print '(a)', 'CloneVectorQuantity 8'
d970 1
a970 1
print '(a)', 'CloneVectorQuantity 9'
d2610 1
a2610 1
      call dump( vector, details=0 ) ! It's not the values cuasing us to crash
d3350 1
a3350 1
       "$Id: VectorsModule.f90,v 2.190 2014/07/18 23:13:24 pwagner Exp $"
d3362 3
@


2.190
log
@Aimed for consistency in names passed to allocate_test; added allocationName field to datatype
@
text
@d108 2
d173 1
d906 3
d914 1
d917 1
d920 1
d925 1
d927 1
d931 35
d967 1
d970 1
d3281 28
d3350 1
a3350 1
       "$Id: VectorsModule.f90,v 2.189 2014/05/20 23:53:19 vsnyder Exp $"
d3362 3
@


2.189
log
@Add the POINTER attribute to the SourceValues argument to ReshapeVectorValue
to work around bugs in compilers that have not properly implemented the
feature that disassociated pointer actual arguments corresponding to
optional non-pointer dummy arguments are absent.
@
text
@d327 1
d1146 5
d1169 3
a1171 7
      call allocate_test ( value%value1, &
        & valueSize, &
        & trim(what) // "%values", where )
    else
      call allocate_test ( value%value1, &
        & valueSize, &
        & trim(what) // "%values", moduleName )
d1173 3
d1266 2
a1267 5
    if ( present(forWhom) ) then
      call deallocate_test ( value%value1, trim(forWhom) // "%VALUE1", moduleName )
    else
      call deallocate_test ( value%value1, 'VALUE1', moduleName )
    end if
d3274 1
a3274 1
       "$Id: VectorsModule.f90,v 2.188 2014/02/01 00:16:43 pwagner Exp $"
d3286 6
@


2.188
log
@Don't dump values for every quantity when failed to find one in GetVectorQuantityIndexByType
@
text
@d2823 1
a2823 1
  ! ------------------------------------------------  ReshapeVectorValue  -----
d2831 3
a2833 3
    type ( VectorValue_T), optional, intent(in)    :: SOURCE
    type ( VectorValue_T), intent(out)             :: DESTINATION
    real(rv), dimension(:,:), optional, intent(in) :: SOURCEVALUES
d2841 1
a2841 1
    elseif ( present(sourcevalues) ) then
d2844 2
a2845 2
      do j=1, size(sourcevalues, 2)
        do i=1, size(sourcevalues, 1)
d2849 3
a2851 3
        enddo
      enddo
    endif
d3272 1
a3272 1
       "$Id: VectorsModule.f90,v 2.187 2014/01/09 00:24:29 pwagner Exp $"
d3284 3
@


2.187
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d2560 1
a2560 1
      call dump( vector, details=1 )
d3272 1
a3272 1
       "$Id: VectorsModule.f90,v 2.186 2013/10/25 23:05:42 pwagner Exp $"
d3284 3
@


2.186
log
@Fixed error that caused dumping hyperslab to segment fault if rank /= 2
@
text
@d116 1
d125 1
a125 1
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, OUTPUTNAMEDVALUE
d3272 1
a3272 1
       "$Id: VectorsModule.f90,v 2.185 2013/09/27 00:41:14 pwagner Exp $"
d3284 3
@


2.185
log
@Fixed bug in GatherVectorQuantity
@
text
@d2145 3
a2147 1
    if ( myDetails > 0 ) then
a2245 1
    ! Internal variables
d2250 14
a2263 2
    call ExtractArray ( GatherVectorQuantity%values, quantity%values, &
      & start, count, stride, block, options='-a' )
d3271 1
a3271 1
       "$Id: VectorsModule.f90,v 2.184 2013/09/25 00:58:15 pwagner Exp $"
d3283 3
@


2.184
log
@Added a gather operation for Vector quantities
@
text
@d2243 3
a2245 2
    type(VectorValue_T), pointer :: GatherVectorQuantity

d3258 1
a3258 1
       "$Id: VectorsModule.f90,v 2.182 2013/08/17 00:17:24 pwagner Exp $"
d3270 3
@


2.183
log
@Use Get_Where or Print_Source to start error messages
@
text
@d77 3
d117 3
a119 1
  use Lexer_Core, only: Where_T
a122 1
  use MLSFINDS, only: FINDFIRST, FINDUNIQUE
d158 1
a158 1
  public :: GETVECTORQUANTITY, GETVECTORQUANTITYBYTYPE
d2229 23
d3269 3
@


2.182
log
@Guard against certain crashes with non-Aura datasets
@
text
@d114 1
d269 1
a269 1
    integer :: Where = 0       ! Source_ref for creation if by L2CF
d342 1
a342 1
    integer :: Where = 0       ! Source_ref for creation if by L2CF
d956 1
a956 1
    integer, intent(in), optional :: where ! source_ref if created by L2CF
d1103 1
a1103 1
    integer, intent(in), optional :: where    ! source_ref
d1205 1
a1205 1
    vector%where = 0
d1307 1
a1307 1
    vectorTemplate%where = 0
d1871 1
a1871 1
    if ( vector%where /= 0 ) then
d3230 1
a3230 1
       "$Id: VectorsModule.f90,v 2.181 2013/08/16 02:28:38 vsnyder Exp $"
d3242 3
@


2.181
log
@Don't reallocate VALUES if it's the right shape
@
text
@d1137 5
d1158 1
a1158 3
        & value%template%noChans * &
        & value%template%noSurfs * &
        & value%template%noInstances, &
d1162 1
a1162 3
        & value%template%noChans * &
        & value%template%noSurfs * &
        & value%template%noInstances, &
d2118 3
d2133 6
a2138 2
      call output ( size(qty%values(:,1)), before='    values array size is ' )
      call output ( size(qty%values(1,:)), before='x' )
d3229 1
a3229 1
       "$Id: VectorsModule.f90,v 2.180 2013/08/12 23:47:25 pwagner Exp $"
d3241 3
@


2.180
log
@FindSomethings moved to MLSFinds module
@
text
@d1138 13
d3221 1
a3221 1
       "$Id: VectorsModule.f90,v 2.179 2013/07/13 00:00:15 vsnyder Exp $"
d3233 3
@


2.179
log
@Define assignment, producing error message, for vector value
@
text
@d117 1
a117 1
  use MLSSETS, only: FINDFIRST, FINDUNIQUE
d3208 1
a3208 1
       "$Id: VectorsModule.f90,v 2.178 2013/06/12 02:14:37 vsnyder Exp $"
d3220 3
@


2.178
log
@Cruft removal
@
text
@d174 1
a174 1
    module procedure AssignVector
d336 1
a336 1
!      123456789012345678901234567890123456789012345678901234567890
d348 2
d493 10
d896 1
d3208 1
a3208 1
       "$Id: VectorsModule.f90,v 2.177 2013/05/22 20:24:21 pwagner Exp $"
d3220 3
@


2.177
log
@Dump procedures accept and obey options arg
@
text
@a349 3
  integer, parameter, private :: B_sizer = 0
  integer, parameter, private :: B = bit_size(b_sizer) ! can't use bit_size(b)

d3195 1
a3195 1
       "$Id: VectorsModule.f90,v 2.176 2013/05/16 18:16:58 pwagner Exp $"
d3207 3
@


2.176
log
@Made GetVectorQuantityIndexByName generic--can supply character-valued arg
@
text
@d1786 1
a1786 1
  subroutine Dump_Vector ( VECTOR, DETAILS, NAME, &
d1806 1
d1824 1
a1824 1
    character(len=8) :: options
d1855 1
a1855 1
    options = ' '
d1857 1
a1857 1
      if ( clean ) options = 'c'
d1859 1
d1882 1
a1882 1
        call dump ( vector%quantities(j), details, options=options )
d1894 1
a1894 1
  subroutine Dump_Vectors ( VECTORS, DETAILS, NAME, &
d1910 1
d1982 1
a1982 1
        call dump_vector ( vectors(i), details, name, &
a2004 1
    ! logical, intent(in), optional :: CLEAN   ! Passed through to dump_0%dump
d2007 5
d2017 1
d2020 1
a2020 1

d2023 2
a2024 1

d2032 15
a2046 6
    dot = .false.
    if ( present(vector) ) dot = vector%name /= 0
    if ( dot ) then
      call output ( ' Vector quantity name = ' )
      if ( vector%name /= 0 ) then
        call display_string ( vector%name )
d2048 6
a2053 1
        call output ( '<none given>' )
d2055 3
a2057 2
      if ( qty%template%name /= 0 ) then
        call display_string ( qty%template%name, before='.' )
d2059 1
a2059 1
        call output ( '.<none given>' )
d2061 23
a2083 4
    else
      call output ( ' Qty_Template_Name = ' )
      if ( qty%template%name /= 0 ) then
        call display_string ( qty%template%name )
d2085 1
a2085 1
        call output ( '<none given>' )
d2087 10
a2096 31
    end if
    if ( qty%label /= 0 ) then
      call output ( ', label = ' )
      call display_string ( qty%label )
    else
      call output ( ' unlabeled ', advance='yes' )
    end if
    if ( myDetails < -1 ) then
      MLSMessageConfig%Info = oldInfo
      return
    endif
    call newLine
    if ( myDetails < 0 ) then
      MLSMessageConfig%Info = oldInfo
      return
    endif
    call output ( qty%template%noChans, before='    noChans = ' )
    call output ( qty%template%noSurfs, before=' noSurfs = ' )
    call output ( qty%template%noInstances, before=' noInstances = ')
    call output ( qty%template%instanceLen, before=' instanceLen = ', advance='yse' )
    call output ( '    signal: ')
    if ( qty%template%signal < 1 ) then
      call output ( '    (no database entry for this quantity) ', advance='yes')
    else if ( signals(qty%template%signal)%name < 1 ) then
      call output ( '    (no name in the database for this quantity) ', advance='yes')
    else
      call display_string ( signals(qty%template%signal)%name, advance='yes' )
    end if
    if ( qty%template%quantityType == l_vmr ) then
      call output ( '    molecule: ')
      if ( qty%template%molecule < 1 ) then
d2099 1
a2099 1
        call display_string ( lit_indices(qty%template%molecule) )
d2101 8
a2108 14
    end if
    call output ( '    instrumentmodule: ')
    if ( qty%template%instrumentModule < 1 ) then
      call output ( '    (no database entry for this quantity) ' )
    else
      call display_string ( modules(qty%template%instrumentModule)%name )
    end if
    call output ( qty%template%instrumentmodule, before=' = ', advance='yes')
    call output ( '    Minor Frame? (t/f): ')
    call output ( qty%template%minorframe )
    call output ( ' Major Frame? (t/f): ')
    call output ( qty%template%majorframe, advance='yes' )
    call output ( size(qty%values(:,1)), before='    values array size is ' )
    call output ( size(qty%values(1,:)), before='x' )
d3198 1
a3198 1
       "$Id: VectorsModule.f90,v 2.175 2013/03/15 00:01:31 pwagner Exp $"
d3210 3
@


2.175
log
@Added function AreEqual for vectors
@
text
@d203 5
d2287 4
a2290 1
  integer function GetVectorQuantityIndexByName ( vector, quantityName, NoErr )
d2293 1
a2293 1
  ! of the quantity within the vector that has that name.
d2296 5
a2300 5
    type (Vector_T), intent(in) :: Vector
    integer, intent(in) :: QuantityName    ! Quantity name sub-rosa index.
    logical, intent(in), optional :: NoErr ! No error if present and true.
                                           ! Return -1 if no such quantity.

d2308 2
a2309 2
        GetVectorQuantityIndexByName = search
    return
d2313 1
a2313 1
      GetVectorQuantityIndexByName = -1
d2321 39
a2359 1
  end function GetVectorQuantityIndexByName
d3182 1
a3182 1
       "$Id: VectorsModule.f90,v 2.174 2013/02/21 21:21:42 pwagner Exp $"
d3194 3
@


2.174
log
@Added options arg when dumping quantity or vector masks
@
text
@d33 2
d135 1
a135 1
  public :: ADDVECTORTODATABASE, ASSIGNVECTOR, AXPY, CHECKINTEGRITY
d436 37
d3136 1
a3136 1
       "$Id: VectorsModule.f90,v 2.173 2013/02/01 23:40:55 vsnyder Exp $"
d3148 3
@


2.173
log
@Add Where argument to CreateVectorValue.  Nullify correct pointers in
DestroyVectorValue.
@
text
@a1324 2
    ! Local variables:
    integer :: I              ! Subscript and loop inductor
d1546 21
a1566 3
  subroutine DumpQuantityMask ( VectorQuantity, DETAILS )
    type (VectorValue_T), intent(in) :: VectorQuantity
    integer, intent(in), optional :: DETAILS ! if < 0 just dump summary
d1569 1
d1571 1
d1575 1
d1577 1
d1579 1
d1582 1
a1582 1
    integer, dimension(1000) :: uniqueVals
d1585 2
d1589 2
d1592 13
d1614 1
a1614 3
    elseif( myDetails < 0 ) then
      n = count( isBitSet( ichar(vectorQuantity%mask), bitNum ) )
      call outputNamedValue( 'Num mask bits set: ', n )
d1625 2
a1626 1
    else
d1651 45
a1695 1
    end if                            ! Has a mask
d1699 1
a1699 1
  subroutine DumpVectorMask ( VECTOR, DETAILS )
d1701 2
a1702 1
    integer, intent(in), optional :: DETAILS ! if < 0 just dump summar
d1712 1
a1712 1
      call dumpMask ( vector%quantities(q), details )
d3097 1
a3097 1
       "$Id: VectorsModule.f90,v 2.172 2012/12/04 00:11:55 pwagner Exp $"
d3109 4
@


2.172
log
@Improved comments
@
text
@d1077 1
a1077 1
  subroutine CreateVectorValue ( Value, What )
d1082 1
d1084 13
a1096 5
    call allocate_test ( value%value1, &
      & value%template%noChans * &
      & value%template%noSurfs * &
      & value%template%noInstances, &
      & trim(what) // "%values", ModuleName )
d1192 1
a1192 1
    nullify ( value%value1, value%value3 )
d3015 1
a3015 1
       "$Id: VectorsModule.f90,v 2.171 2012/11/09 00:59:08 pwagner Exp $"
d3027 3
@


2.171
log
@Added ReshapeVectorValue
@
text
@d1 1
a1 1

d19 1
d103 1
d2557 7
a2563 1
  ! ------------------------------------------------  ReehapeVectorValue  -----
a2564 1
  ! Reverse bits of MASK indexed by elements of TO_Reverse.  Numbering of mask
d3006 1
a3006 1
       "$Id: VectorsModule.f90,v 2.170 2012/10/30 22:07:28 pwagner Exp $"
d3018 3
@


2.170
log
@Now able to clear full 2d quantity mask
@
text
@d94 1
d158 1
a158 1
  public :: RMVECTORFROMDATABASE
d2555 26
d2999 1
a2999 1
       "$Id: VectorsModule.f90,v 2.169 2012/10/29 17:42:31 pwagner Exp $"
d3011 3
@


2.169
log
@Added optional args to CloneVectorQuantity, DestroyVectorQuantityValue
@
text
@d181 4
d687 1
a687 1
  subroutine ClearMask ( MASK, TO_CLEAR, WHAT )
d703 15
a717 1
  end subroutine ClearMask
d2972 1
a2972 1
       "$Id: VectorsModule.f90,v 2.168 2012/10/11 21:01:02 pwagner Exp $"
d2984 3
@


2.168
log
@Print quantityName instead of moduleName during Dump
@
text
@d115 2
a116 1
  use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, CHECKINTEGRITY, DUMP, &
d803 1
a803 1
  subroutine CloneVectorQuantity ( Z, X )
d807 3
d819 3
d823 2
d826 6
a831 1
    z%template = x%template
d840 1
d1147 2
a1148 1
  subroutine DestroyVectorQuantityValue ( Value, DestroyMask, ForWhom )
d1153 4
a1156 3
    type (vectorValue_t), intent(inout) :: Value
    logical, intent(in), optional :: DestroyMask
    character(len=*), intent(in), optional :: ForWhom
d1166 3
d2954 1
a2954 1
       "$Id: VectorsModule.f90,v 2.167 2012/07/31 00:33:40 vsnyder Exp $"
d2966 3
@


2.167
log
@Use Test_Allocate instead of explicit testing followed by MLSMessage.
Add ForWhom argument to DestroyVectorQuantityMask and
DestroyVectorQuantityValue.
@
text
@d110 2
a111 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_ALLOCATE, &
    & MLSMSG_DEALLOCATE, MLSMSG_WARNING
d126 1
a126 1
  public :: diff, dump
d128 31
a158 31
  public :: AddToVector, AddVectors, AddVectorTemplateToDatabase
  public :: AddVectorToDatabase, AssignVector, AXPY, CheckIntegrity
  public :: CheckNaN, CheckVectorForNaN, CheckVectorQuantityForNaN
  public :: ClearMask, ClearUnderMask, ClearVector
  public :: CloneVector, CloneVectorQuantity, ConstantXVector
  public :: ConstructVectorTemplate, CopyVector, CopyVectorMask
  public :: CreateMask, CreateVector, CreateVectorValue, DestroyVectorDatabase
  public :: DestroyVectorInfo, DestroyVectorMask, DestroyVectorQuantityMask
  public :: DestroyVectorQuantityValue, DestroyVectorTemplateDatabase
  public :: DestroyVectorTemplateInfo, DestroyVectorValue
  public :: DiffVectorQuantities
  public :: DivideVectors
  public :: DotVectors, DotVectorsMasked, DotVectorsMaybeMasked
  public :: DotVectorQuantities, DotVectorQuantitiesMasked
  public :: DotVectorQuantitiesMaybeMasked
  public :: DumpNiceMaskSummary, DumpMask, DumpQuantityMask, DumpVectorMask
  public :: DumpVectorNorms
  public :: Dump_Vector, Dump_Vectors, Dump_Vector_Quantity
  public :: Dump_Vector_Template, Dump_Vector_Templates
  public :: GetVectorQuantity, GetVectorQuantityByType
  public :: GetVectorQtyByTemplateIndex, GetVectorQuantityIndexByName
  public :: GetVectorQuantityIndexByType, InflateVectorDatabase
  public :: InflateVectorTemplateDatabase, IsVectorQtyMasked
  public :: L2Norm, L2NormQ, L2NormV
  public :: MaskVectorQty, MoveVectorQuantity, MultiplyVectors
  public :: NullifyVectorTemplate, NullifyVectorValue, NullifyVector, PowVector
  public :: QuantityTemplate_T ! for full F95 compatibility
  public :: ReciprocateVector, RemapVectorMask, RemapVectorValue, ReverseMask
  public :: RmVectorFromDatabase
  public :: ScaleVector, SetMask, SubtractFromVector
  public :: SubtractVectors, ValidateVectorQuantity
d160 1
a160 1
  public :: VectorTemplate_T, VectorValue_T, Vector_T
d162 2
a163 1
  public :: M_Ignore, M_Cloud, M_Fill, M_FullDerivatives, M_LinAlg, M_Spare, M_Tikhonov
d227 20
d265 3
a267 1
  ! correspond to a single quantity. Should have called this QuantityValue_T.
d1829 2
a1830 1

d1832 1
a1834 1
    logical :: Dot ! Use vector.quantity notation
d1840 1
d1842 1
d1844 2
d1875 4
a1878 1
    if ( myDetails < -1 ) return
d1880 4
a1883 1
    if ( myDetails < 0 ) return
d1942 1
d2155 1
a2155 1
    use MOLECULES, only: IsExtinction
d2490 1
a2490 1
    use Pointer_Rank_Remapping, only: Remap
d2504 1
a2504 1
    use Pointer_Rank_Remapping, only: Remap
d2934 1
a2934 1
       "$Id: VectorsModule.f90,v 2.166 2012/07/10 03:55:49 vsnyder Exp $"
d2946 5
@


2.166
log
@Improve comments about VALUE
@
text
@d104 2
a105 1
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST, TEST_DEALLOCATE
d110 2
a111 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ALLOCATE, &
    & MLSMSG_DEALLOCATE, MLSMSG_ERROR, MLSMSG_WARNING
d764 1
a764 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "z%quantities" )
d957 1
a957 1
  subroutine CreateMask ( Value )
d960 8
a967 2
    call allocate_test ( value%mask1, size(value%values), "MASK1", &
      & ModuleName, fill=char(0) )
d1004 1
a1004 2
    if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "Vector quantities"  )
d1051 1
a1051 2
    if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // 'database' )
d1093 1
a1093 1
  subroutine DestroyVectorQuantityMask ( Value )
d1098 8
a1105 3
    type (vectorValue_t) :: Value
    call deallocate_test ( value%mask, 'MASK', moduleName )
    nullify ( value%mask1, value%mask3 )
d1109 1
a1109 1
  subroutine DestroyVectorQuantityValue ( Value, DestroyMask )
d1114 1
a1114 1
    type (vectorValue_t) :: Value
d1116 6
a1121 1
    call deallocate_test ( value%values, 'VALUE', moduleName )
d1124 1
a1124 1
      if ( destroyMask ) call destroyVectorQuantityMask ( value )
d1159 1
a1159 1
      & MLSMSG_deallocate // "vectorTemplate%quantities", ModuleName )
d2336 2
d2899 1
a2899 1
       "$Id: VectorsModule.f90,v 2.165 2012/07/07 02:40:47 vsnyder Exp $"
d2911 3
@


2.165
log
@Add DestroyMask argument to DestroyVectorQuantityValue
@
text
@d249 2
a250 2
    ! VALUE1 is Frequencies (or 1) * Vertical Coordinates (or 1) * Horizontal
    ! Instances (scan or profile or 1).  These are taken from 
d254 1
a254 1
    ! VALUES are Frequencies (or 1) * Vertical Coordinates (or 1), and
d259 2
a260 2
    ! of VALUE3 are Frequencies, Vertical Coordinates and Horizontal
    ! Instances (scan or profile or 1).  These are taken from
d2883 1
a2883 1
       "$Id: VectorsModule.f90,v 2.164 2012/07/07 02:02:34 vsnyder Exp $"
d2895 3
@


2.164
log
@Add MASK1 and MASK3.  Make MASK and MASK3 rank remappings of MASK1.
Add VALUE1 and VALUE3.  Make VALUES and VALUE3 rank remappings of VALUE1.
Add low-level abstractions for creating and destroying masks and values
for a single vector quantity.
@
text
@d1100 1
a1100 1
  subroutine DestroyVectorQuantityValue ( Value )
d1106 1
d1109 3
d2316 1
a2316 2
    call destroyVectorQuantityValue ( to )
    call destroyVectorQuantityMask ( to )
d2322 1
a2322 2
    call destroyVectorQuantityValue ( from )
    call destroyVectorQuantityMask ( from )
d2883 1
a2883 1
       "$Id: VectorsModule.f90,v 2.163 2012/05/24 20:32:56 vsnyder Exp $"
d2895 6
@


2.163
log
@Change details level for dumping vector quantity templates
@
text
@a48 1
! CreateMaskArray              Allocate a MASK array
d51 1
d54 3
a56 1
! DestroyVectorMask            Destroys the masks stored in the vector
d92 2
d132 4
a135 3
  public :: ConstructVectorTemplate, CopyVector, CopyVectorMask, CreateMaskArray
  public :: CreateMask, CreateVector, DestroyVectorDatabase, DestroyVectorInfo
  public :: DestroyVectorMask, DestroyVectorTemplateDatabase
d154 2
a155 1
  public :: ReciprocateVector, ReverseMask, RmVectorFromDatabase
d247 6
a252 1
    integer :: index            ! Index of this quantity into vector database
d254 12
a265 4
    ! VALUES are Auxiliary coordinates (or 1) * Frequencies (or 1) * Vertical
    ! Coordinates (or 1), and Horizontal Instances (scan or profile or 1). 
    ! These are taken from (template%noAux * template%noChans *
    ! template%noSurfs, template%noInstances).
d275 4
a278 1
    ! by mask = char(int)
d289 1
a289 1
  integer, parameter :: M_LinAlg = 2**0
a791 2
    ! Local variables:
    integer, dimension(2) :: shp
d793 1
a793 1
    call NullifyVectorValue( z )
d796 1
a796 2
      shp = shape(x%values)
      call allocate_test( z%values, shp(1), shp(2), 'z%values', moduleName )
d798 1
a798 1
    endif
d800 1
a800 2
      shp = shape(x%mask)
      call allocate_test( z%mask, shp(1), shp(2), 'z%mask', moduleName )
d802 1
a802 1
    endif
d951 1
a951 3
        if ( associated ( z%quantities(q)%mask ) ) &
          & call Deallocate_test ( z%quantities(q)%mask, &
          & 'z%quantities(?)%mask', ModuleName )
a955 10
  ! ---------------------------------------------  CreateMaskArray  -----
  subroutine CreateMaskArray ( mask, values )
    ! Allocate the MASK array for a vector quantity.
    character, dimension(:,:), pointer :: MASK ! To create
    real(rv), dimension(:,:), pointer :: VALUES ! Template values
    call allocate_test ( mask, (size(values,1)), &
      & size(values,2), "MASK in CreateMaskArray", ModuleName )
    mask = char(0) ! All vector elements are interesting
  end subroutine CreateMaskArray

d957 1
a957 1
  subroutine CreateMask ( VectorValue )
d959 4
a962 2
    type(VectorValue_T), intent(inout) :: VectorValue
    call createMaskArray ( vectorValue%mask, vectorValue%values )
d1012 15
d1084 1
a1084 2
      call deallocate_test ( vector%quantities(i)%mask, &
        & "vector%quantities(i)%mask", ModuleName )
d1088 22
d1160 1
a1160 2
      call deallocate_test ( vector%quantities(i)%values, &
        & "vector%quantities(i)%values", ModuleName )
a2308 1
    use Allocate_Deallocate, only: Deallocate_Test
d2310 11
a2320 5
    call deallocate_test ( to%values, moduleName, 'To%Values' )
    call deallocate_test ( to%mask, moduleName, 'To%Mask' )
    to%values => from%values
    to%mask => from%mask
    nullify ( from%values, from%mask )
d2382 2
a2383 2
    nullify ( v%values )
    nullify ( v%mask )
d2435 29
a2463 1
  ! --------------------------------------------------  ReverseMask  -----
d2866 1
a2866 5
      call allocate_test ( vector%quantities(qty)%values, &
        & vector%quantities(qty)%template%noChans * &
        & vector%quantities(qty)%template%noSurfs, &
        & vector%quantities(qty)%template%noInstances, &
        & trim(what1) // trim(what2) // "%values", ModuleName )
d2876 1
d2881 1
a2881 1
       "$Id: VectorsModule.f90,v 2.162 2012/04/20 01:26:38 vsnyder Exp $"
d2893 3
@


2.162
log
@Add DotVectorsMaybeMasked, norms, dump quantity norms
@
text
@d1858 2
a1859 1
                                             ! is present, dump them.
d1879 1
a1879 1
          call dump ( quantities(vector_template%quantities(i)), details )
d2808 1
a2808 1
       "$Id: VectorsModule.f90,v 2.161 2012/03/28 00:55:22 vsnyder Exp $"
d2820 3
@


2.161
log
@Indicate mask is dumped in hex
@
text
@d62 1
d67 1
d80 2
d134 7
a140 4
  public :: DotVectors, DotVectorsMasked, DumpNiceMaskSummary
  public :: DumpMask, DumpQuantityMask, DumpVectorMask, Dump_Vector
  public :: Dump_Vectors, Dump_Vector_Template, Dump_Vector_Templates
  public :: Dump_Vector_Quantity
d145 1
d185 4
d206 1
a206 1
    module procedure DotVectors
d210 1
a210 1
    module procedure DotVectorsMasked
d1196 1
a1196 4
    z = 0.0_rv
    do i = 1, size(x%quantities)
      z = z + sum( x%quantities(i)%values * y%quantities(i)%values )
    end do
a1205 2
    ! Local variables:
    integer :: I, J, K        ! Subscripts and loop inductors
d1208 36
a1243 30
        & ModuleName, "Cannot .DOT. vectors having different templates" )
    z = 0.0_rv
    do i = 1, size(x%quantities)
      if ( associated(x%quantities(i)%mask) ) then
        if ( associated(y%quantities(i)%mask) ) then
          do j = 1, size(x%quantities(i)%values,1)
            do k = 1, size(x%quantities(i)%values,2)
              if ( iand(ior(ichar(x%quantities(i)%mask(j,k)), &
                &           ichar(y%quantities(i)%mask(j,k))), m_linAlg) == 0 ) &
                & z = z + x%quantities(i)%values(j,k) * &
                  &       y%quantities(i)%values(j,k)
            end do ! k
          end do ! j
        else
          do j = 1, size(x%quantities(i)%values,1)
            do k = 1, size(x%quantities(i)%values,2)
              if ( iand(ichar(x%quantities(i)%mask(j,k)), m_linAlg) == 0 ) &
                & z = z + x%quantities(i)%values(j,k) * &
                  &       y%quantities(i)%values(j,k)
            end do ! k
          end do ! j
        end if
      else if ( associated(y%quantities(i)%mask) ) then
          do j = 1, size(x%quantities(i)%values,1)
            do k = 1, size(x%quantities(i)%values,2)
              if ( iand(ichar(y%quantities(i)%mask(j,k)), m_linAlg) == 0 ) &
                & z = z + x%quantities(i)%values(j,k) * &
                  &       y%quantities(i)%values(j,k)
            end do ! k
          end do ! j
d1245 1
a1245 1
        z = z + sum( x%quantities(i)%values * y%quantities(i)%values )
d1247 23
a1269 2
    end do
  end function DotVectorsMasked
d1271 1
a1271 1
  ! -----------------------------------------  DumpNiceMaskSummary ---
d1499 25
d2213 22
d2807 1
a2807 1
       "$Id: VectorsModule.f90,v 2.160 2012/02/23 00:08:55 vsnyder Exp $"
d2819 3
@


2.160
log
@Don't dump molecule names if quantity type is not vmr
@
text
@d1767 1
a1767 1
        call dump ( ichar(qty%mask), name='  Mask =', &
d2726 1
a2726 1
       "$Id: VectorsModule.f90,v 2.159 2012/02/13 23:21:47 pwagner Exp $"
d2738 3
@


2.159
log
@Print moleccule when dumping quantity
@
text
@d1742 7
a1748 5
    call output ( '    molecule: ')
    if ( qty%template%molecule < 1 ) then
      call output ( '    (no database entry for this quantity) ' )
    else
      call display_string ( lit_indices(qty%template%molecule) )
d2726 1
a2726 1
       "$Id: VectorsModule.f90,v 2.158 2012/01/09 22:30:42 pwagner Exp $"
d2738 3
@


2.158
log
@More info about dumped vector template
@
text
@d1742 6
d2724 1
a2724 1
       "$Id: VectorsModule.f90,v 2.157 2011/12/17 00:37:32 vsnyder Exp $"
d2736 3
@


2.157
log
@Add MoveVectorQuantity
@
text
@d1814 4
d2718 1
a2718 1
       "$Id: VectorsModule.f90,v 2.156 2011/11/11 00:32:29 vsnyder Exp $"
d2730 3
@


2.156
log
@Use IsExtinction array from Molecules module
@
text
@d79 1
d138 1
a138 1
  public :: MaskVectorQty, MultiplyVectors
d242 1
a242 1
    ! Actually the mask bits are got at from the ichar(mask)
d2167 14
d2714 1
a2714 1
       "$Id: VectorsModule.f90,v 2.155 2011/11/01 22:55:48 honghanh Exp $"
d2726 3
@


2.155
log
@Remove the nullify statement of vector%template%quantities
from DestroyVectorInfo
@
text
@a103 1
  use MOLECULES, only: L_EXTINCTION
d1986 1
d2027 1
a2027 1
            if ( radiometer /= qt%radiometer .and. molecule == l_extinction ) cycle
d2699 1
a2699 1
       "$Id: VectorsModule.f90,v 2.154 2011/10/25 18:08:07 pwagner Exp $"
d2711 4
@


2.154
log
@Capitalize USEd items
@
text
@d1030 1
a1030 3
    ! Let the destruction of the vector template take care of
    ! vector%template%quantities
    nullify ( vector%template%quantities )
d2699 1
a2699 1
       "$Id: VectorsModule.f90,v 2.153 2011/08/02 16:51:40 honghanh Exp $"
d2711 3
@


2.153
log
@Re-indent 2 lines of code to make indentation correct.
@
text
@d95 2
a96 2
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Test_Deallocate
  use BitStuff, only: dumpBitNames, IsBitSet
d98 7
a104 7
  use Intrinsic, only: LIT_INDICES, PHYQ_INVALID, L_VMR
  use MLSCommon, only: R8, RV
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, &
    & MLSMSG_DeAllocate, MLSMSG_Error, MLSMSG_Warning
  use MLSSets, only: FINDFIRST, FINDUNIQUE
  use MLSSignals_m, only: MODULES, SIGNALS, GETSIGNALNAME
  use Molecules, only: L_EXTINCTION
d106 2
a107 2
  use QuantityTemplates, only: QuantityTemplate_T, CheckIntegrity, Dump, &
    & NullifyQuantityTemplate
d225 1
a225 1
  ! correspond to a single quantity.
d607 1
a607 1
    use IEEE_Arithmetic, only: IEEE_Is_NaN
d1474 1
a1474 1
    use Lexer_Core, only: Print_Source
d1786 1
a1786 1
    use QuantityTemplates, only: Dump
d1988 1
a1988 1
    use MLSSignals_m, only: GetRadiometerName
d2701 1
a2701 1
       "$Id: VectorsModule.f90,v 2.152 2011/03/15 22:49:35 pwagner Exp $"
d2713 3
@


2.152
log
@Added reverseMask; changed default dumpMask behavior to use DUMP_2D_INTEGER
@
text
@d2044 2
a2045 2
    return
      end if
d2701 1
a2701 1
       "$Id: VectorsModule.f90,v 2.151 2011/03/02 02:15:25 vsnyder Exp $"
d2713 3
@


2.151
log
@Make QuantityTemplate_t public, for F95 compatibility
@
text
@d85 1
d105 1
a105 1
  use OUTPUT_M, only: NEWLINE, OUTPUT, outputNamedValue
d137 2
a138 1
  public :: InflateVectorTemplateDatabase, IsVectorQtyMasked, MultiplyVectors
d141 3
a143 2
  public :: ReciprocateVector, RmVectorFromDatabase, ScaleVector, SetMask, SubtractFromVector
  public :: SubtractVectors, ValidateVectorQuantity, MaskVectorQty
d1393 1
d1395 1
d1413 10
d2280 36
d2701 1
a2701 1
       "$Id: VectorsModule.f90,v 2.150 2010/05/24 14:48:04 honghanh Exp $"
d2713 3
@


2.150
log
@Add comment to GetVectorQtyByTemplateIndex
@
text
@d138 1
d2650 1
a2650 1
       "$Id: VectorsModule.f90,v 2.149 2010/04/28 00:12:20 pwagner Exp $"
d2662 3
@


2.149
log
@Correct maskBitNames used in dumping mask
@
text
@d1897 2
d1900 1
a1900 4
    ! Given a vector and an index into the quantity templates, find quantity
    ! with matching template within vector.

    ! Dummy arguments
d1902 2
d2649 1
a2649 1
       "$Id: VectorsModule.f90,v 2.148 2010/04/22 23:38:57 pwagner Exp $"
d2661 3
@


2.148
log
@Added new Ignore masking bit
@
text
@d255 1
a255 1
  character(len=16), dimension(6), parameter :: maskBitNames = (/ &
d257 2
a258 1
    & 'Tikhanov        ', 'cloud           ', 'spare           ' /)
d2648 1
a2648 1
       "$Id: VectorsModule.f90,v 2.147 2010/02/25 18:07:14 pwagner Exp $"
d2660 3
@


2.147
log
@Added extra dump when about to bomb
@
text
@d143 1
a143 1
  public :: M_Cloud, M_Fill, M_FullDerivatives, M_LinAlg, M_Spare, M_Tikhonov
d250 1
d252 1
a252 1
  integer, parameter :: M_Spare = 2**5
d1290 2
d2133 5
d2647 1
a2647 1
       "$Id: VectorsModule.f90,v 2.146 2010/02/04 23:08:00 vsnyder Exp $"
d2659 3
@


2.146
log
@Remove USE or declaration for unused names
@
text
@d2065 1
d2639 1
a2639 1
       "$Id: VectorsModule.f90,v 2.145 2009/10/27 23:28:46 pwagner Exp $"
d2651 3
@


2.145
log
@Generic Diff must be public, too, at least NAG thinks so
@
text
@a1110 4
    !
    integer :: i
    integer :: nUnique
    integer, dimension(1000) :: uniqueVals
d2638 1
a2638 1
       "$Id: VectorsModule.f90,v 2.144 2009/10/27 22:16:38 pwagner Exp $"
d2650 3
@


2.144
log
@New api for dump vector quantity--drops 'clean', adds 'options'
@
text
@d114 1
a114 1
  public :: Assignment (=), DUMP, Multiply, operator (+), operator (-)
d116 1
d2642 1
a2642 1
       "$Id: VectorsModule.f90,v 2.143 2009/10/26 17:08:44 pwagner Exp $"
d2654 3
@


2.143
log
@Added DiffVectorQuantities
@
text
@d1116 4
a1119 1
      call output ( name ); call output ( ', ' )
d1546 1
a1546 1
        call dump ( vector%quantities(j), details, clean=clean )
d1658 1
a1658 1
  subroutine Dump_Vector_Quantity ( Qty, Details, Name, Clean, Vector )
d1668 1
a1668 1
    logical, intent(in), optional :: CLEAN   ! Passed through to dump_0%dump
d1670 1
a1675 1
    character(len=8) :: options
a1679 4
    options = ' '
    if ( present(clean) ) then
      if ( clean ) options = 'c'
    endif
d2641 1
a2641 1
       "$Id: VectorsModule.f90,v 2.142 2009/06/23 18:25:43 pwagner Exp $"
d2653 3
@


2.142
log
@Prevent Intel from optimizing ident string away
@
text
@d58 1
d96 1
a96 1
  use DUMP_0, only: DUMP
d125 3
a127 1
  public :: DestroyVectorTemplateInfo, DestroyVectorValue, DivideVectors
d159 4
d164 1
a164 1
    module procedure DUMP_VECTOR, DUMP_VECTORS, Dump_Vector_Quantity
d198 1
a198 1
       "$RCSfile: $"
d1104 30
d2642 1
a2642 1
       "$Id: read_apriori.f90 is it here $"
d2654 3
@


2.141
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d191 1
a191 1
       "$RCSfile: VectorsModule.f90,v $"
d2602 1
a2603 1
!---------------------------- RCS Ident Info -------------------------------
d2605 2
a2606 3
       "$Id: VectorsModule.f90,v 2.140 2009/05/08 00:39:07 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2608 1
a2608 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d2610 1
d2617 3
@


2.140
log
@Shows MaskBitNames when dumping Mask bits
@
text
@d247 3
a249 2
    & 'linear algebra ', 'full derivatives', 'fill            ', &
    & 'Tikhanov       ',  'cloud          ', 'spare           ' /)
d1445 1
a1447 1
    logical :: dumpThisQty
d1449 1
d1480 4
d1635 1
d1640 4
d1706 1
a1706 1
      call dump ( qty%values, '  Elements = ', clean=clean )
d2605 1
a2605 1
       "$Id: VectorsModule.f90,v 2.139 2009/04/30 22:14:25 pwagner Exp $"
d2617 3
@


2.139
log
@name of bit in MaskVectorQty and isVectorQtyMasked now mandatory
@
text
@d94 1
a94 1
  use BitStuff, only: IsBitSet
d100 1
a100 1
  use MLSSets, only: FINDFIRST
d230 3
d246 3
d1625 1
d1627 1
d1629 1
d1700 7
d2594 1
a2594 1
       "$Id: VectorsModule.f90,v 2.138 2009/01/16 23:30:58 vsnyder Exp $"
d2606 3
@


2.138
log
@Spiff up a dump
@
text
@d2053 1
a2053 1
    integer, intent(in), optional ::    WHAT
a2054 4
    integer :: MyWhat

    myWhat = m_LinAlg
    if ( present(what) ) myWhat = what
d2057 1
a2057 1
    isVectorQtyMasked = iand(ichar(vectorQty%mask(row, column)), myWhat) /= 0
d2073 1
a2073 3
    integer, intent(in), optional ::    WHAT

    integer :: MyWhat
a2074 2
    myWhat = m_LinAlg
    if ( present(what) ) myWhat = what
d2077 1
a2077 1
      & char(ior( ichar(vectorQty%mask(row, column)), myWhat ) )
d2578 1
a2578 1
       "$Id: VectorsModule.f90,v 2.137 2008/12/17 02:57:28 vsnyder Exp $"
d2590 3
@


2.137
log
@Dump template with vector quantity if details gt 1
@
text
@d1651 1
a1651 1
      call output ( ' Vector quantity label = ' )
d1654 1
a1654 1
      call output ( ' Vector quantity unlabeled ', advance='yes' )
d2586 1
a2586 1
       "$Id: VectorsModule.f90,v 2.136 2008/11/24 19:36:57 pwagner Exp $"
d2598 3
@


2.136
log
@Improved comments, dumps; removed unused variables
@
text
@d104 1
a104 1
  use QuantityTemplates, only: QuantityTemplate_T, CheckIntegrity, &
d1613 1
d1655 1
a1655 1
    endif
d1696 1
a1696 2
      if ( .not. associated(qty%values) ) &
        & call output ( 'out' )
d1698 1
a1698 2
      if ( .not. associated(qty%mask ) ) &
        & call output ( 'out' )
d1701 1
d2586 1
a2586 1
       "$Id: VectorsModule.f90,v 2.135 2008/11/06 21:51:08 pwagner Exp $"
d2598 3
@


2.135
log
@Fill method swapValues swaps values between two quantities
@
text
@d725 3
a727 5
  ! Destroy Z, except its name.
  ! Create the characteristics of a vector quantityto be the same template as a
  ! given one (except it has no name).  Values are allocated, but not
  ! filled.  Z's mask is allocated if X's is allocated, but it is not filled.
  ! isn't returned.
d730 2
a731 3
  ! It is important to invoke DestroyVectorInfo using Z after it is no
  ! longer needed. Otherwise, a memory leak will result.  Also see
  ! AssignVector.
a737 1
    integer :: I, Status
a740 1
    ! nullify (z%values, z%mask)
a741 3
    ! z%values = x%values
    ! z%mask = x%mask
    
d1649 6
d2586 1
a2586 1
       "$Id: VectorsModule.f90,v 2.134 2008/08/27 19:58:30 vsnyder Exp $"
d2598 3
@


2.134
log
@Add PRINT to not_used_here
@
text
@d44 1
d119 2
a120 2
  public :: ClearMask
  public :: ClearUnderMask, ClearVector, CloneVector, ConstantXVector
d723 39
d2588 1
a2588 1
       "$Id: VectorsModule.f90,v 2.133 2008/06/09 20:33:59 vsnyder Exp $"
d2600 3
@


2.133
log
@Repair some broken comments
@
text
@d218 1
a218 1
    ! VALUES are Auxiliar coordinates (or 1) * Frequencies (or 1) * Vertical
d2548 1
a2548 1
       "$Id: VectorsModule.f90,v 2.132 2008/06/05 02:06:06 vsnyder Exp $"
d2552 1
d2560 3
@


2.132
log
@Comments about Aux grids
@
text
@d73 1
a73 1
! InflateQuantityTemplateDatabase
d1972 1
a1972 1
  ! ------------------------------ InflateQuantityTemplateDatabase -----
d2548 1
a2548 1
       "$Id: VectorsModule.f90,v 2.131 2007/10/09 16:45:02 pwagner Exp $"
d2559 3
@


2.131
log
@Corrected declaration of myDetails
@
text
@d216 1
a216 1
    integer :: index                    ! Index of this quantity into vector
d218 4
a221 3
    ! VALUES are Frequencies (or 1) * Vertical Coordinates (or 1), and
    ! Horizontal Instances (scan or profile or 1).  These are taken from
    ! (template%noChans * template%noSurfs, template%noInstances).
d229 2
a230 2
    integer :: label = 0                ! An optional label for this to be used
    ! as for example a swath name.  Often used in conjunction with the 'batch'
d2548 1
a2548 1
       "$Id: VectorsModule.f90,v 2.130 2007/10/09 00:29:42 pwagner Exp $"
d2559 3
@


2.130
log
@Added optional DETAILS arg to some dumps
@
text
@d1306 1
a1306 1
    logical :: myDetails
d2547 1
a2547 1
       "$Id: VectorsModule.f90,v 2.128 2007/10/03 20:51:18 vsnyder Exp $"
d2558 3
@


2.129
log
@Remove unnecessary target attribute
@
text
@d93 1
d102 1
a102 1
  use OUTPUT_M, only: NEWLINE, OUTPUT
d1297 1
a1297 1
  subroutine DumpQuantityMask ( VectorQuantity )
d1299 1
d1302 1
d1306 2
d1310 4
a1313 1

d1323 3
d1355 1
a1355 1
  subroutine DumpVectorMask ( VECTOR )
d1357 1
d1367 1
a1367 1
      call dumpMask ( vector%quantities(q) )
d2558 3
@


2.128
log
@Add CheckVectorQuantityForNaN
@
text
@d1859 1
a1859 1
    type (Vector_T), intent(in), target :: VECTOR
d2535 1
a2535 1
       "$Id: VectorsModule.f90,v 2.127 2007/04/03 17:41:58 vsnyder Exp $"
d2546 3
@


2.127
log
@Revise how allocation status is tested.  Reallocate VectorsDatabase with
zero size after destroying it.
@
text
@d37 3
d115 3
a117 1
  public :: AddVectorToDatabase, AssignVector, AXPY, CheckIntegrity, ClearMask
d150 4
d389 1
a389 1
    type ( Vector_T), intent(in) :: VECTOR
d557 42
d2535 1
a2535 1
       "$Id: VectorsModule.f90,v 2.126 2006/08/05 02:11:58 vsnyder Exp $"
d2546 4
@


2.126
log
@Add ForWhom argument to ConstructVectorTemplate
@
text
@d89 1
a89 1
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d902 1
a902 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & MLSMSG_deallocate // "database" )
d904 3
d931 1
a931 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & MLSMSG_deallocate // "vector%quantities" )
d966 1
a966 2
       if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
         & MLSMSG_deallocate // "database" )
d2484 1
a2484 1
       "$Id: VectorsModule.f90,v 2.125 2006/08/03 01:10:06 vsnyder Exp $"
d2495 3
@


2.125
log
@Put l2cf names in leak track database
@
text
@d695 1
a695 1
    & vectorTemplate, where )
d707 1
a707 3

    ! Local variables
    integer :: status
d722 6
a727 5

    if ( associated(vectorTemplate%quantities) ) then
      deallocate ( vectorTemplate%quantities, STAT=status )
      if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//"Vector quantities" )
a728 4
    allocate ( vectorTemplate%quantities(vectorTemplate%noQuantities), &
      & STAT=status )
    if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//"Vector quantities" )
d2484 1
a2484 1
       "$Id: VectorsModule.f90,v 2.124 2006/07/27 03:55:56 vsnyder Exp $"
d2495 3
@


2.124
log
@Print summaries if negative details levels, for leak detection
@
text
@d2454 7
d2466 5
d2475 1
a2475 1
        & "Vector%quantities(qty)%values", ModuleName )
d2489 1
a2489 1
       "$Id: VectorsModule.f90,v 2.123 2006/06/06 18:54:48 vsnyder Exp $"
d2500 3
@


2.123
log
@Spiff up a dump
@
text
@d190 1
d235 1
d695 1
a695 1
    & vectorTemplate )
d706 1
d721 1
d847 1
a847 1
    & highBound, lowBound, noValues ) &
d862 1
d888 1
d926 1
d992 1
d1319 2
d1328 3
a1330 1
    !                                        ! -2 Skip all quantity details
d1351 1
d1353 4
d1362 3
a1364 2
    myDetails = 1
    if ( present(details) ) myDetails = details
d1372 4
a1380 1
    if ( myDetails < -1 ) return
d1382 3
a1384 1
      dumpThisQty = .true.
d1407 5
d1427 1
d1447 3
a1449 1
    logical :: myditchafterdump
d1451 2
d1458 5
a1462 4
    if ( size(vectors) > 1 ) then
      call output ( 'VECTORS: SIZE = ' )
      call output ( size(vectors), advance='yes' )
    end if
d1467 1
a1467 1
      if ( .not. associated(vectors(i)%quantities) ) then
d1475 2
d1479 1
a1479 1
        dumpThisQty = .true.
d1509 3
d2477 1
a2477 1
       "$Id: VectorsModule.f90,v 2.122 2006/05/23 21:43:34 vsnyder Exp $"
d2488 3
@


2.122
log
@Add CLEAR option to some dumps
@
text
@d1262 1
a1262 1
      call output ( '', advance='yes' )
d1274 1
a1274 1
              call output ( '', advance='yes' )
d1283 1
a1283 1
          call output ( '', advance='yes' )
d1551 1
a1551 1
        call dump ( ichar(qty%mask), name='Mask=', &
d2438 1
a2438 1
       "$Id: VectorsModule.f90,v 2.121 2006/03/22 02:16:28 vsnyder Exp $"
d2449 3
@


2.121
log
@Add Vector argument to DumpVectorQuantity just to get its name
@
text
@d1309 1
a1309 1
    & THENDITCHAFTERDUMP )
d1332 1
d1380 1
a1380 1
        call dump ( vector%quantities(j), details )
d2438 1
a2438 1
       "$Id: VectorsModule.f90,v 2.120 2006/02/23 00:55:28 vsnyder Exp $"
d2449 3
@


2.120
log
@Add NoErr optional argument to GetVectorQuantityIndexByName
@
text
@d1200 1
a1200 1
      use intrinsic, only: L_ANGLE, L_GEODALTITUDE, L_GPH, L_INTEGER, L_NONE, &
d1475 1
a1475 1
  subroutine Dump_Vector_Quantity ( Qty, Details, Name, Clean )
d1485 1
d1488 1
d1496 14
a1509 3
    call output ( ' Qty_Template_Name = ' )
    if ( qty%template%name /= 0 ) then
      call display_string ( qty%template%name )
d1511 6
a1516 1
      call output ( ' <none given>' )
d2437 1
a2437 1
       "$Id: VectorsModule.f90,v 2.119 2006/01/21 00:03:12 livesey Exp $"
d2448 3
@


2.119
log
@Added DumpNiceMaskSummary
@
text
@d1709 1
a1709 1
  integer function GetVectorQuantityIndexByName ( vector, quantityName )
d1716 3
a1718 1
    integer, intent(in) :: QuantityName ! Quantity name sub-rosa index
d1731 4
d2419 1
a2419 1
       "$Id: VectorsModule.f90,v 2.118 2005/09/02 20:33:22 vsnyder Exp $"
d2430 3
@


2.118
log
@Correct error messages in GetVectorQuantityIndexByType
@
text
@d1 1
a1 1
! Copyright 2005, by the California Institute of Technology. ALL
d118 1
a118 1
  public :: DotVectors, DotVectorsMasked
d1101 140
d2413 1
a2413 1
       "$Id: VectorsModule.f90,v 2.117 2005/06/22 17:25:51 pwagner Exp $"
d2424 3
@


2.117
log
@Reworded Copyright statement, moved rcs id
@
text
@d180 1
a180 1
       "$RCSfile: $"
d1606 2
d1686 1
a1686 1
        call get_string ( lit_indices(radiometer), msg(len_trim(msg)+2:))
d1696 1
a1696 1
        call get_string ( lit_indices(instrumentModule), msg(len_trim(msg)+2:))
d2273 1
a2273 1
       "$Id: $"
d2284 3
@


2.116
log
@Spiff up some dumps
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d178 1
a178 4
! --------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: VectorsModule.f90,v 2.115 2005/01/07 00:36:51 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d180 1
a180 1
       "$RCSfile: VectorsModule.f90,v $"
d182 1
a182 1
! --------------------------------------------------------------------------
d2269 5
d2282 3
@


2.115
log
@Remove unused declarations
@
text
@d172 1
a172 1
       "$Id: VectorsModule.f90,v 2.114 2004/10/19 02:21:20 livesey Exp $"
d1212 1
d1233 1
a1233 3
        call newline
        call output ( j, 4 )
        call output ( "~" )
d1358 5
a1362 9
    call output ( ' noChans = ' )
    call output ( qty%template%noChans, advance='no' )
    call output ( ' noSurfs = ' )
    call output ( qty%template%noSurfs, advance='no' )
    call output ( ' noInstances = ' )
    call output ( qty%template%noInstances, advance='no' )
    call output ( ' instanceLen = ' )
    call output ( qty%template%instanceLen, advance='yes' )
    call output ( ' signal: ')
d1365 1
a1365 1
    elseif ( signals(qty%template%signal)%name < 1 ) then
d1372 1
a1372 3
      call output ( '    (no database entry for this quantity) ', advance='yes')
    elseif ( qty%template%instrumentModule < 1 ) then
      call output ( '    (no name in the database for this quantity) ', advance='yes')
d1374 1
a1374 1
      call display_string ( modules(qty%template%instrumentModule)%name, advance='yes' )
d1376 7
a1382 11
    call output ( '    (its index): ')
    call output ( qty%template%instrumentmodule, advance='no')
    call output ( ' ', advance='yes')
    call output ( '  Minor Frame? (t/f): ')
    call output ( qty%template%minorframe, advance='no')
    call output ( '  Major Frame? (t/f): ')
    call output ( qty%template%majorframe, advance='yes')
    call output ( '  values array size is ')
    call output ( size(qty%values(:,1)), advance='no')
    call output ( 'x')
    call output ( size(qty%values(1,:)), advance='yes')
d1384 1
d2272 3
@


2.114
log
@Logical flaw in radiometer/signal vector querying
@
text
@d172 1
a172 1
       "$Id: VectorsModule.f90,v 2.113 2004/10/07 23:12:19 vsnyder Exp $"
d1555 1
a1555 1
    integer :: i, myIndexInVector
d2282 3
@


2.113
log
@Polish up Dump_Vector_Value for use in ForwardModelVectorTools
@
text
@d172 1
a172 1
       "$Id: VectorsModule.f90,v 2.112 2004/06/16 22:31:28 vsnyder Exp $"
d1642 4
d2282 3
@


2.112
log
@Account for mask in DivideVectors, exchange order of first two arguments
@
text
@d172 1
a172 1
       "$Id: VectorsModule.f90,v 2.111 2004/06/16 01:18:39 vsnyder Exp $"
d1334 4
a1337 4
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump quantity values
    !                                        ! -1 Skip quantity details beyond names
    !                                        ! -2 Skip all quantity details
    !                                        ! >0 Do dump quantity values
d1350 1
a1351 1
      call output ( ' Qty_Template_Name = ' )
d1353 2
d1356 3
a1358 4
    if ( myDetails < 0 ) then
      call output(' ', advance='yes')
      return
    end if
d2278 3
@


2.111
log
@Add DivideVectors, incomplete comments in TOC about other routines
@
text
@d172 1
a172 1
       "$Id: VectorsModule.f90,v 2.110 2004/06/10 00:57:47 vsnyder Exp $"
d998 4
a1001 2
  subroutine DivideVectors ( X, A, Y )
  ! Y = A / X if Y is present, else X = A / X, element-by-element.
d1004 2
a1005 2
    type(Vector_T), intent(inout), target :: X
    type(Vector_T), intent(in) :: A
d1013 1
a1013 1
    z => x
d1020 9
a1028 1
      z%quantities(i)%values = a%quantities(i)%values / x%quantities(i)%values
d2277 3
@


2.110
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d26 3
d46 1
d50 5
a54 3
! dump                         Interface for next three
! dump_vector                  Display how a single vector is made up
! dump_vectors                 Display how vector database is made up
d56 1
a56 1
! dump_vector_templates        Display how vector template database is made up
d62 3
a64 1
! isVectorQtyMasked            Is the mask for VectorQty set for address
d67 6
a72 1
! rmVectorFromDatabase         Removes a vector from a database of such vectors
d79 1
a79 1
  !---------------------------------------------------------------------------
d109 2
a110 2
  public :: DestroyVectorTemplateInfo, DestroyVectorValue, DotVectors
  public :: DotVectorsMasked
d170 1
a170 1
!---------------------------- RCS Ident Info -------------------------------
d172 1
a172 1
       "$Id: VectorsModule.f90,v 2.109 2004/05/01 04:07:44 vsnyder Exp $"
d177 1
a177 1
!---------------------------------------------------------------------------
d244 1
a244 1
  !-------------------------------------------------  AddToVector  -----
d267 1
a267 1
  !--------------------------------------------------  AddVectors  -----
d292 1
a292 1
  !---------------------------------  AddVectorTemplateToDatabase  -----
d310 1
a310 1
  !-----------------------------------------  AddVectorToDatabase  -----
d328 1
a328 1
  !------------------------------------------------  AssignVector  -----
d344 1
a344 1
  !--------------------------------------------------------  AXPY  -----
d541 1
a541 1
  !---------------------------------------------------  ClearMask  -----
d560 1
a560 1
  !-----------------------------------------------  ClearUnderMask -----
d603 1
a603 1
  !-------------------------------------------------  ClearVector  -----
d618 1
a618 1
  !-------------------------------------------------  CloneVector  -----
d662 1
a662 1
  !---------------------------------------------  ConstantXVector  -----
d686 1
a686 1
  !-------------------------------------  ConstructVectorTemplate  -----
d963 1
a963 1
  !-----------------------------------  DestroyVectorTemplateInfo  -----
d982 1
a982 1
  !------------------------------------------  DestroyVectorValue  -----
d997 26
a1022 1
  !--------------------------------------------------  DotVectors  -----
d1039 1
a1039 1
  !--------------------------------------------  DotVectorsMasked  -----
d1697 1
a1697 1
  ! ---------------------------------- InflateQuantityTemplateDatabase --
d1713 1
a1713 1
  ! ---------------------------------- InflateQuantityTemplateDatabase --
d1729 1
a1729 1
  ! -------------------------------  IsVectorQtyMasked  -----
d1752 1
a1752 1
  ! -------------------------------  MaskVectorQty  -----
d1776 1
a1776 1
  !---------------------------------------------  MultiplyVectors  -----
d1818 1
a1818 1
  ! ---------------------------------------------- NullifyVectorTemplate -----
d1828 1
a1828 1
  ! ---------------------------------------------- NullifyVectorValue -----
d1851 1
a1851 1
  !-------------------------------------------------  ReciprocateVector  -----
d1865 1
a1865 1
  !-------------------------------------------------  ReciprocateVector  -----
d1888 1
a1888 1
  !-----------------------------------------  RmVectorFromDatabase  -----
d1910 1
a1910 1
  !-------------------------------------------------  ScaleVector  -----
d1933 1
a1933 1
  !-----------------------------------------------------  SetMask  -----
d1964 1
a1964 1
  !------------------------------------------  SubtractFromVector  -----
d1997 1
a1997 1
  !---------------------------------------------  SubtractVectors  -----
d2267 3
@


2.109
log
@Rearranged some dumping stuff
@
text
@d71 1
a71 1
  use MLSCommon, only: R8, RV, FINDFIRST
d74 1
d159 1
a159 1
       "$Id: VectorsModule.f90,v 2.108 2004/01/30 23:27:59 livesey Exp $"
d1493 1
a1493 1
  ! ------------------------------- GetVectorQtyByTemplateIndex --i
d1517 1
a1517 1
    myIndexInVector = FindFirst ( vector%template%quantities == quantityIndex )
d2229 3
@


2.108
log
@Added ReciprocateVector, PowVector and an optional argument to
ClearVector
@
text
@d76 1
a76 1
  use OUTPUT_M, only: OUTPUT
d98 2
a99 1
  public :: Dump_Vectors, Dump_Vector_Templates, Dump_Vector_Quantity
d125 1
a125 1
    module procedure DUMP_VECTOR_TEMPLATES
d158 1
a158 1
       "$Id: VectorsModule.f90,v 2.107 2004/01/24 01:03:04 livesey Exp $"
d1183 1
d1364 35
d1405 1
a1405 3
    integer :: I, MyDetails
    myDetails = 1
    if ( present(details) ) myDetails = details
d1410 2
a1411 12
      if ( vector_templates(i)%name /= 0 ) then
        call output ( ' Name = ' )
        call display_string ( vector_templates(i)%name )
      end if
      call output ( ' NoQuantities = ' )
      call output ( vector_templates(i)%noQuantities )
      call output ( ' TotalInstances = ' )
      call output ( vector_templates(i)%totalInstances )
      call output ( ' TotalElements = ' )
      call output ( vector_templates(i)%totalElements, advance='yes' )
      if ( myDetails > 0 ) &
        & call dump ( vector_templates(i)%quantities, '      Quantities = ' )
d2228 4
@


2.107
log
@Added allowNameMismatch argument to CopyVector
@
text
@d103 2
a104 2
  public :: NullifyVectorTemplate, NullifyVectorValue, NullifyVector
  public :: RmVectorFromDatabase, ScaleVector, SetMask, SubtractFromVector
d157 1
a157 1
       "$Id: VectorsModule.f90,v 2.106 2004/01/23 05:36:51 livesey Exp $"
d589 1
a589 1
  subroutine ClearVector ( Z )
d593 2
d596 2
d599 1
a599 1
      z%quantities(i)%values = 0.0_rv
d1787 37
d2203 3
@


2.106
log
@Added DoVectors/QuantitiesMatch
@
text
@d157 1
a157 1
       "$Id: VectorsModule.f90,v 2.105 2003/09/15 23:28:50 vsnyder Exp $"
d714 1
a714 1
    & VectorNameText, Database )
d732 1
d736 1
d743 2
d748 1
a748 1
      if ( x%template%name /= z%template%name ) call MLSMessage &
d2162 3
@


2.105
log
@Remove unused private module variable
@
text
@d71 1
a71 1
  use MLSCommon, only: R8, RV
d157 1
a157 1
       "$Id: VectorsModule.f90,v 2.104 2003/09/15 17:45:37 livesey Exp $"
a1475 1
    myIndexInVector=0
d1483 1
a1483 6
    do i=1,vector%template%noQuantities
      if ( vector%template%quantities(i) == quantityIndex ) then
        myIndexInVector=i
        exit
      end if
    end do
d2158 3
@


2.104
log
@Added target declaration for fussy intel compiler
@
text
@d157 1
a157 1
       "$Id: VectorsModule.f90,v 2.103 2003/08/27 20:06:42 livesey Exp $"
a221 4
  ! This incrementing counter is used to set the id field for a vector template

  integer, save, private :: vectorTemplateCounter = 0

d2164 3
@


2.103
log
@Bug fix in MaskVectorQty
@
text
@d157 1
a157 1
       "$Id: VectorsModule.f90,v 2.102 2003/06/20 19:33:53 pwagner Exp $"
d1539 1
a1539 1
    type (Vector_T), intent(in) :: VECTOR
d2168 3
@


2.102
log
@Quanities now share grids stored separately in databses
@
text
@d157 1
a157 1
       "$Id: VectorsModule.f90,v 2.101 2003/06/03 20:47:05 livesey Exp $"
d1708 1
a1708 1
    if ( .not. associated(vectorQty%mask)) return
d2168 3
@


2.101
log
@Typo bug fix
@
text
@d157 1
a157 1
       "$Id: VectorsModule.f90,v 2.100 2003/06/03 19:23:03 livesey Exp $"
a168 1
    integer :: Id = 0          ! Id code for vector (for checking purposes)
d197 3
d242 1
a242 1
    if ( x%template%id /= y%template%id ) call MLSMessage ( MLSMSG_Error, &
d272 1
a272 1
    if ( x%template%id /= y%template%id ) call MLSMessage ( MLSMSG_Error, &
d350 1
a350 1
    if ( x%template%id /= y%template%id ) call MLSMessage ( MLSMSG_Error, &
d398 2
a399 1
      call output ( qty, advance='yes' )
a711 1

a713 3
    ! Increment the id counter and set the id field
    vectorTemplateCounter = vectorTemplateCounter + 1
    vectorTemplate%id = vectorTemplateCounter
d748 1
a748 1
      if ( x%template%id /= z%template%id ) call MLSMessage &
a959 1
    vectorTemplate%id = 0
d987 1
a987 1
    if ( x%template%id /= y%template%id ) call MLSMessage ( MLSMSG_Error, &
d1005 1
a1005 1
    if ( x%template%id /= y%template%id ) call MLSMessage ( MLSMSG_Error, &
a1157 2
    call output ( ' Template_ID = ' )
    call output ( vector%template%id, advance='yes' )
d1311 1
a1311 3
    call output ( ' Qty_Template_ID = ' )
    call output ( qty%template%id, advance='yes' )
    call output ( '    signal: ')
a1370 2
      call output ( ': Id = ' )
      call output ( vector_templates(i)%id )
d1731 1
a1731 1
    if ( x%template%id /= y%template%id ) call MLSMessage ( MLSMSG_Error, &
a1761 1
    v%id = 0
d1825 1
a1825 1
      if ( x%template%id /= y%template%id ) call MLSMessage ( MLSMSG_Error, &
d1879 1
a1879 1
    if ( x%template%id /= y%template%id ) call MLSMessage ( MLSMSG_Error, &
d1914 1
a1914 1
    if ( x%template%id /= y%template%id ) call MLSMessage ( MLSMSG_Error, &
d2168 3
@


2.100
log
@Added check to see that vector has not been destroyed
@
text
@d157 1
a157 1
       "$Id: VectorsModule.f90,v 2.99 2003/05/29 16:36:29 livesey Exp $"
a1504 1
    end if
d2177 3
@


2.99
log
@New reflector argument to some of the GetVectorQuantity....
@
text
@d157 1
a157 1
       "$Id: VectorsModule.f90,v 2.98 2003/05/13 04:47:18 livesey Exp $"
d1485 1
d1490 6
d1499 1
d1505 1
d2178 3
@


2.98
log
@Added noValues argument to CreateVector
@
text
@d157 1
a157 1
       "$Id$"
d160 1
a160 1
       "$RCSfile$"
d1416 1
a1416 1
    & molecule, instrumentModule, radiometer, signal, &
d1433 1
d1452 1
a1452 1
      & quantityType, molecule, instrumentModule, radiometer, signal, &
d1462 1
a1462 1
          &  quantityType, molecule, instrumentModule, radiometer, signal, &
d1530 1
a1530 1
    & molecule, instrumentModule, radiometer, signal, sideband, noError )
d1544 1
d1578 3
d1615 5
d2168 4
a2171 1
! $Log$
@


2.97
log
@Added InflateVectorTemplateDatabase and InflateVectorDatabase
@
text
@d385 2
a386 1
    if ( .not. associated ( vector%quantities ) ) then
d820 1
a820 1
    & highBound, lowBound ) &
d834 1
d839 1
d856 4
a859 1
    call createValues ( vector, highBound, lowBound )
d2159 3
@


2.96
log
@Merged in feb03 newfwm branch
@
text
@d101 2
a102 1
  public :: GetVectorQuantityIndexByType, IsVectorQtyMasked, MultiplyVectors
d1619 32
d2153 3
@


2.95
log
@New mask bits
@
text
@d49 1
d98 1
a98 1
  public :: Dump_Vectors, Dump_Vector_Templates
d122 2
a123 1
    module procedure DUMP_VECTOR, DUMP_VECTORS, DUMP_VECTOR_TEMPLATES
d156 1
a156 1
       "$Id: VectorsModule.f90,v 2.94 2002/11/22 12:57:09 mjf Exp $"
d159 1
a159 1
       "$RCSfile: VectorsModule.f90,v $"
d766 1
d1139 1
a1139 1
    endif
d1177 1
a1177 63
        if ( vector%quantities(j)%template%name /= 0 ) then
          call output ( ' Qty_Template_Name = ' )
          call display_string ( vector%quantities(j)%template%name )
        end if
        if ( myDetails < 0 ) then
          call output(' ', advance='yes')
          cycle
        endif
        call output ( ' noChans = ' )
        call output ( vector%quantities(j)%template%noChans, advance='no' )
        call output ( ' noSurfs = ' )
        call output ( vector%quantities(j)%template%noSurfs, advance='no' )
        call output ( ' noInstances = ' )
        call output ( vector%quantities(j)%template%noInstances, advance='no' )
        call output ( ' instanceLen = ' )
        call output ( vector%quantities(j)%template%instanceLen, advance='yes' )
        call output ( ' Qty_Template_ID = ' )
        call output ( vector%quantities(j)%template%id, advance='yes' )
        call output ( '    signal: ')
        if ( vector%quantities(j)%template%signal < 1 ) then
          call output ( '    (no database entry for this quantity) ', advance='yes')
        elseif ( signals(vector%quantities(j)%template%signal)%name < 1 ) then
          call output ( '    (no name in the database for this quantity) ', advance='yes')
        else
          call display_string ( signals(vector%quantities(j)%template%signal)%name, advance='yes' )
        endif
        call output ( '    instrumentmodule: ')
        if ( vector%quantities(j)%template%instrumentModule < 1 ) then
          call output ( '    (no database entry for this quantity) ', advance='yes')
        elseif ( vector%quantities(j)%template%instrumentModule < 1 ) then
          call output ( '    (no name in the database for this quantity) ', advance='yes')
        else
          call display_string ( modules(vector%quantities(j)%template%instrumentModule)%name, advance='yes' )
        endif
        call output ( '    (its index): ')
        call output ( vector%quantities(j)%template%instrumentmodule, advance='no')
        call output ( ' ', advance='yes')
        call output ( '  Minor Frame? (t/f): ')
        call output ( vector%quantities(j)%template%minorframe, advance='no')
        call output ( '  Major Frame? (t/f): ')
        call output ( vector%quantities(j)%template%majorframe, advance='yes')
        call output ( '  values array size is ')
        call output ( size(vector%quantities(j)%values(:,1)), advance='no')
        call output ( 'x')
        call output ( size(vector%quantities(j)%values(1,:)), advance='yes')
        if ( myDetails > 0 ) then
          call dump ( vector%quantities(j)%values, '  Elements = ' )
          if ( associated(vector%quantities(j)%mask) ) then
            call dump ( ichar(vector%quantities(j)%mask), name='Mask=', &
              & format='(z3.2)', width = 20 )
!           call dumpQuantityMask ( vector%quantities(j) )
          else
            call output ( '      Without mask', advance='yes' )
          end if
        else
          call output ( ', with' )
          if ( .not. associated(vector%quantities(j)%values) ) &
            & call output ( 'out' )
          call output ( ' values, with' )
          if ( .not. associated(vector%quantities(j)%mask ) ) &
            & call output ( 'out' )
          call output ( ' mask', advance='yes' )
        end if
d1221 1
a1221 1
    endif
d1236 1
a1236 1
      endif
d1259 1
a1259 1
      enddo
d1268 1
a1268 1
      endif
d1272 85
d1438 1
a1438 1
    if (present(noError)) myNoError = noError
d1482 1
a1482 1
      if ( vector%template%quantities(i) == quantityIndex) then
d1547 1
a1547 1
    if (present(noError)) myNoError = noError
d1581 1
a1581 1
    if (myNoError) then
d1909 1
a1909 1
    if (present(sayWhyNot)) mySayWhyNot = sayWhyNot
d1913 2
a1914 2
    if (present(coherent)) then
      if (quantity%template%coherent .neqv. coherent) then
d1916 1
a1916 1
        if (mySayWhyNot) then
d1927 2
a1928 2
    if (present(stacked)) then
      if (quantity%template%stacked .neqv. stacked) then
d1930 1
a1930 1
        if (mySayWhyNot) then
d1941 2
a1942 2
    if (present(regular)) then
      if (quantity%template%regular .neqv. regular) then
d1944 1
a1944 1
        if (mySayWhyNot) then
d1955 2
a1956 2
    if (present(minorFrame)) then
      if (quantity%template%minorFrame .neqv. minorFrame) then
d1958 1
a1958 1
        if (mySayWhyNot) then
d1969 2
a1970 2
    if (present(majorFrame)) then
      if (quantity%template%majorFrame .neqv. majorFrame) then
d1972 1
a1972 1
        if (mySayWhyNot) then
d1983 1
a1983 1
    if (present(sideband)) then
d1985 1
a1985 1
      if (mySayWhyNot .and. .not. ValidateVectorQuantity) then
d1992 1
a1992 1
      if (.not. ValidateVectorQuantity) return
d1995 1
a1995 1
    if (present(signal)) then
d1997 1
a1997 1
      if (mySayWhyNot .and. .not. ValidateVectorQuantity) then
d2004 1
a2004 1
      if (.not. ValidateVectorQuantity) return
d2007 1
a2007 1
    if (present(verticalCoordinate)) then
d2009 1
a2009 1
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
d2016 1
a2016 1
      if (.not. ValidateVectorQuantity) return
d2019 1
a2019 1
    if (present(frequencyCoordinate)) then
d2022 1
a2022 1
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
d2029 1
a2029 1
      if (.not. ValidateVectorQuantity) return
d2032 1
a2032 1
    if (present(noInstances)) then
d2034 1
a2034 1
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
d2041 1
a2041 1
      if (.not. ValidateVectorQuantity) return
d2044 1
a2044 1
    if (present(noSurfs)) then
d2046 1
a2046 1
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
d2053 1
a2053 1
      if (.not. ValidateVectorQuantity) return
d2056 1
a2056 1
    if (present(quantityType)) then
d2058 1
a2058 1
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
d2065 1
a2065 1
      if (.not. ValidateVectorQuantity) return
d2068 1
a2068 1
    if (present(molecule)) then
d2070 1
a2070 1
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
d2077 1
a2077 1
      if (.not. ValidateVectorQuantity) return
d2119 13
a2131 1
! $Log: VectorsModule.f90,v $
@


2.94
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d107 1
a107 1
  public :: M_Fill, M_FullDerivatives, M_LinAlg, M_Tikhonov
d154 1
a154 1
       "$Id: VectorsModule.f90,v 2.93 2002/10/19 18:53:26 livesey Exp $"
d198 1
d202 1
d2094 4
@


2.94.2.1
log
@Add Dump_Vector_Quantity
@
text
@a48 1
! Dump_Vector_Quantity         Display a vector quantity
d97 1
a97 1
  public :: Dump_Vectors, Dump_Vector_Templates, Dump_Vector_Quantity
d121 1
a121 2
    module procedure DUMP_VECTOR, DUMP_VECTORS, Dump_Vector_Quantity
    module procedure DUMP_VECTOR_TEMPLATES
d154 1
a154 1
       "$Id: VectorsModule.f90,v 2.94 2002/11/22 12:57:09 mjf Exp $"
d1134 1
a1134 1
    end if
d1172 63
a1234 1
        call dump ( vector%quantities(j), details )
d1278 1
a1278 1
    end if
d1293 1
a1293 1
      end if
d1316 1
a1316 1
      end do
d1325 1
a1325 1
      end if
a1328 84
  ! ---------------------------------------  Dump_Vector_Quantity  -----
  subroutine Dump_Vector_Quantity ( Qty, Details, Name )

    type (VectorValue_T), intent(in) :: QTY
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump quantity values
    !                                        ! -1 Skip quantity details beyond names
    !                                        ! -2 Skip all quantity details
    !                                        ! >0 Do dump quantity values
    !                                        ! Default 1
    character(len=*), intent(in), optional :: NAME

    integer :: myDetails

    myDetails = 1
    if ( present(details) ) myDetails = details

    if ( present(name) ) then
      call output ( name ); call output ( ', ' )
    end if
    if ( qty%template%name /= 0 ) then
      call output ( ' Qty_Template_Name = ' )
      call display_string ( qty%template%name )
    end if
    if ( myDetails < 0 ) then
      call output(' ', advance='yes')
      return
    end if
    call output ( ' noChans = ' )
    call output ( qty%template%noChans, advance='no' )
    call output ( ' noSurfs = ' )
    call output ( qty%template%noSurfs, advance='no' )
    call output ( ' noInstances = ' )
    call output ( qty%template%noInstances, advance='no' )
    call output ( ' instanceLen = ' )
    call output ( qty%template%instanceLen, advance='yes' )
    call output ( ' Qty_Template_ID = ' )
    call output ( qty%template%id, advance='yes' )
    call output ( '    signal: ')
    if ( qty%template%signal < 1 ) then
      call output ( '    (no database entry for this quantity) ', advance='yes')
    elseif ( signals(qty%template%signal)%name < 1 ) then
      call output ( '    (no name in the database for this quantity) ', advance='yes')
    else
      call display_string ( signals(qty%template%signal)%name, advance='yes' )
    end if
    call output ( '    instrumentmodule: ')
    if ( qty%template%instrumentModule < 1 ) then
      call output ( '    (no database entry for this quantity) ', advance='yes')
    elseif ( qty%template%instrumentModule < 1 ) then
      call output ( '    (no name in the database for this quantity) ', advance='yes')
    else
      call display_string ( modules(qty%template%instrumentModule)%name, advance='yes' )
    end if
    call output ( '    (its index): ')
    call output ( qty%template%instrumentmodule, advance='no')
    call output ( ' ', advance='yes')
    call output ( '  Minor Frame? (t/f): ')
    call output ( qty%template%minorframe, advance='no')
    call output ( '  Major Frame? (t/f): ')
    call output ( qty%template%majorframe, advance='yes')
    call output ( '  values array size is ')
    call output ( size(qty%values(:,1)), advance='no')
    call output ( 'x')
    call output ( size(qty%values(1,:)), advance='yes')
    if ( myDetails > 0 ) then
      call dump ( qty%values, '  Elements = ' )
      if ( associated(qty%mask) ) then
        call dump ( ichar(qty%mask), name='Mask=', &
          & format='(z3.2)', width = 20 )
!           call dumpQuantityMask ( qty )
      else
        call output ( '      Without mask', advance='yes' )
      end if
    else
      call output ( ', with' )
      if ( .not. associated(qty%values) ) &
        & call output ( 'out' )
      call output ( ' values, with' )
      if ( .not. associated(qty%mask ) ) &
        & call output ( 'out' )
      call output ( ' mask', advance='yes' )
    end if
  end subroutine Dump_Vector_Quantity

d1410 1
a1410 1
    if ( present(noError)) myNoError = noError
d1454 1
a1454 1
      if ( vector%template%quantities(i) == quantityIndex ) then
d1519 1
a1519 1
    if ( present(noError)) myNoError = noError
d1553 1
a1553 1
    if ( myNoError ) then
d1881 1
a1881 1
    if ( present(sayWhyNot)) mySayWhyNot = sayWhyNot
d1885 2
a1886 2
    if ( present(coherent) ) then
      if ( quantity%template%coherent .neqv. coherent ) then
d1888 1
a1888 1
        if ( mySayWhyNot ) then
d1899 2
a1900 2
    if ( present(stacked) ) then
      if ( quantity%template%stacked .neqv. stacked ) then
d1902 1
a1902 1
        if ( mySayWhyNot ) then
d1913 2
a1914 2
    if ( present(regular) ) then
      if ( quantity%template%regular .neqv. regular ) then
d1916 1
a1916 1
        if ( mySayWhyNot ) then
d1927 2
a1928 2
    if ( present(minorFrame) ) then
      if ( quantity%template%minorFrame .neqv. minorFrame ) then
d1930 1
a1930 1
        if ( mySayWhyNot ) then
d1941 2
a1942 2
    if ( present(majorFrame) ) then
      if ( quantity%template%majorFrame .neqv. majorFrame ) then
d1944 1
a1944 1
        if ( mySayWhyNot ) then
d1955 1
a1955 1
    if ( present(sideband) ) then
d1957 1
a1957 1
      if ( mySayWhyNot .and. .not. ValidateVectorQuantity ) then
d1964 1
a1964 1
      if ( .not. ValidateVectorQuantity) return
d1967 1
a1967 1
    if ( present(signal) ) then
d1969 1
a1969 1
      if ( mySayWhyNot .and. .not. ValidateVectorQuantity ) then
d1976 1
a1976 1
      if ( .not. ValidateVectorQuantity) return
d1979 1
a1979 1
    if ( present(verticalCoordinate) ) then
d1981 1
a1981 1
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
d1988 1
a1988 1
      if ( .not. ValidateVectorQuantity) return
d1991 1
a1991 1
    if ( present(frequencyCoordinate) ) then
d1994 1
a1994 1
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
d2001 1
a2001 1
      if ( .not. ValidateVectorQuantity) return
d2004 1
a2004 1
    if ( present(noInstances) ) then
d2006 1
a2006 1
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
d2013 1
a2013 1
      if ( .not. ValidateVectorQuantity) return
d2016 1
a2016 1
    if ( present(noSurfs) ) then
d2018 1
a2018 1
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
d2025 1
a2025 1
      if ( .not. ValidateVectorQuantity) return
d2028 1
a2028 1
    if ( present(quantityType) ) then
d2030 1
a2030 1
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
d2037 1
a2037 1
      if ( .not. ValidateVectorQuantity) return
d2040 1
a2040 1
    if ( present(molecule) ) then
d2042 1
a2042 1
      if ( (mySayWhyNot) .and. .not. ValidateVectorQuantity ) then
d2049 1
a2049 1
      if ( .not. ValidateVectorQuantity) return
a2091 4
! Revision 2.94  2002/11/22 12:57:09  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
@


2.94.2.2
log
@Copy the quantity index in CopyVector
@
text
@d156 1
a156 1
       "$Id: VectorsModule.f90,v 2.94.2.1 2003/03/06 23:25:16 vsnyder Exp $"
a763 1
        z%quantities(i)%index = i
a2115 3
! Revision 2.94.2.1  2003/03/06 23:25:16  vsnyder
! Add Dump_Vector_Quantity
!
@


2.94.2.3
log
@Pass 'clean' option through dump_vector_quantity
@
text
@d156 1
a156 1
       "$Id: VectorsModule.f90,v 2.94.2.2 2003/03/07 23:51:17 vsnyder Exp $"
d1271 1
a1271 1
  subroutine Dump_Vector_Quantity ( Qty, Details, Name, Clean )
a1279 1
    logical, intent(in), optional :: CLEAN   ! Passed through to dump_0%dump
d1335 1
a1335 1
      call dump ( qty%values, '  Elements = ', clean=clean )
a2116 3
! Revision 2.94.2.2  2003/03/07 23:51:17  vsnyder
! Copy the quantity index in CopyVector
!
@


2.93
log
@Changed from huge to our own value (temporarily?)
@
text
@d76 2
a77 1
  use QuantityTemplates, only: QuantityTemplate_T, CheckIntegrity
d101 1
d154 1
a154 1
       "$Id: VectorsModule.f90,v 2.92 2002/10/17 18:18:25 livesey Exp $"
d267 1
d345 1
a632 2
      else
        nullify ( z%quantities(i)%mask ) ! for Sun's rubbish compiler
d655 1
a761 1
        if ( doMask ) nullify ( z%quantities(i)%mask ) ! for Sun's rubbish compiler
a797 1
    nullify ( mask ) ! for Sun's rubbish compiler
d1679 34
d1840 1
d2092 3
@


2.92
log
@Added low/high bound stuff
@
text
@d152 1
a152 1
       "$Id: VectorsModule.f90,v 2.91 2002/10/08 00:09:15 pwagner Exp $"
d2026 1
d2038 1
a2038 1
        vector%quantities(qty)%values = huge ( 0.0_rv )
d2040 1
a2040 1
        vector%quantities(qty)%values = - huge ( 0.0_rv )
d2056 3
@


2.91
log
@Added idents to survive zealous Lahey optimizer
@
text
@d152 1
a152 1
       "$Id: VectorsModule.f90,v 2.90 2002/09/26 18:01:08 livesey Exp $"
d811 2
a812 1
    & ( vectorName, vectorTemplate, quantities, VectorNameText, globalUnit ) &
d824 2
d846 1
a846 1
    call createValues ( vector )
d2019 1
a2019 1
  subroutine CreateValues ( Vector )
d2022 2
d2025 5
d2036 7
a2042 1
      vector%quantities(qty)%values=0.0_rv
d2055 3
@


2.90
log
@Made GetVectorQuantity... more forgiving in the case of l_vmr (can have
radiometer wrong if molecule is extinction).
@
text
@d152 1
a152 1
       "$Id: VectorsModule.f90,v 2.89 2002/09/13 18:08:12 pwagner Exp $"
d156 1
d2030 4
d2039 4
@


2.89
log
@May change matrix precision rm from r8
@
text
@d69 1
a69 1
  use Intrinsic, only: LIT_INDICES, PHYQ_INVALID
d74 1
d152 1
a152 1
       "$Id: VectorsModule.f90,v 2.88 2002/09/11 14:06:12 livesey Exp $"
d1506 1
d1518 2
a1519 1
      if ( quantityType == vector%quantities(search)%template%quantityType ) then
d1521 1
a1521 1
          if ( vector%quantities(search)%template%molecule /= molecule ) cycle
d1524 1
a1524 2
          if ( vector%quantities(search)%template%instrumentModule /= &
            &  instrumentModule ) cycle
d1527 8
a1534 2
          if ( vector%quantities(search)%template%radiometer /= &
            &  radiometer ) cycle
d1537 1
a1537 2
          if ( vector%quantities(search)%template%signal /= &
            &  signal ) cycle
d1540 1
a1540 2
          if ( vector%quantities(search)%template%sideband /= &
            &  sideband ) cycle
d2034 3
@


2.88
log
@Bug fix in CopyVector
@
text
@d70 1
a70 1
  use MLSCommon, only: R8
d151 1
a151 1
       "$Id: VectorsModule.f90,v 2.87 2002/08/08 22:06:33 vsnyder Exp $"
d180 1
a180 1
    real(r8), dimension(:,:), pointer :: VALUES => NULL() ! The dimensions of
d570 1
a570 1
              & z%quantities(qi)%values(vi,ii) = 0.0
d584 1
a584 1
      z%quantities(i)%values = 0.0
d793 1
a793 1
    real(r8), dimension(:,:), pointer :: VALUES ! Template values
d963 1
a963 1
  real(r8) function DotVectors ( X, Y ) result (Z)
d973 1
a973 1
    z = 0.0_r8
d980 1
a980 1
  real(r8) function DotVectorsMasked ( X, Y ) result (Z)
d991 1
a991 1
    z = 0.0_r8
d2019 1
a2019 1
      vector%quantities(qty)%values=0.0
d2028 3
@


2.87
log
@Add M_Tikhonov
@
text
@d151 1
a151 1
       "$Id: VectorsModule.f90,v 2.86 2002/08/04 15:55:56 mjf Exp $"
d742 2
a743 1
      if ( doMask ) nullify ( z%quantities(quant)%mask ) ! for Sun's rubbish compiler
d748 1
a748 1
          z%quantities(quant)%mask(:,inst) = x%quantities(quant)%mask(:,inst)
d753 1
a753 1
        & z%quantities(quant)%mask = x%quantities(i)%mask
d2028 3
@


2.86
log
@Added some nullify statements for Sun's rubbish compiler.
@
text
@d104 1
a104 1
  public :: M_Fill, M_FullDerivatives, M_LinAlg
d151 1
a151 1
       "$Id: VectorsModule.f90,v 2.85 2002/07/22 03:26:15 livesey Exp $"
d197 1
d2027 3
@


2.85
log
@Added CheckIntegrity
@
text
@d151 1
a151 1
       "$Id: VectorsModule.f90,v 2.84 2002/07/01 23:51:30 vsnyder Exp $"
d624 5
a628 2
      if ( associated(x%quantities(i)%mask) ) &
        & call createMask ( z%quantities(i) )
d741 1
d755 1
d792 1
d2026 3
@


2.84
log
@Plug a memory leak
@
text
@d75 1
a75 1
  use QuantityTemplates, only: QuantityTemplate_T
d87 1
a87 1
  public :: AddVectorToDatabase, AssignVector, AXPY, ClearMask
d112 5
d151 1
a151 1
       "$Id: VectorsModule.f90,v 2.83 2002/05/17 17:56:01 livesey Exp $"
d346 168
d2020 3
@


2.83
log
@More checks in ValidateVectorQuantity
@
text
@d146 1
a146 1
       "$Id: VectorsModule.f90,v 2.82 2002/05/14 00:28:04 livesey Exp $"
d498 4
d510 5
d1453 1
a1453 1
    type(Vector_T), intent(out), optional, target :: Z
d1847 3
@


2.82
log
@More informative messages in GetVectorQuantityByType
@
text
@d146 1
a146 1
       "$Id: VectorsModule.f90,v 2.81 2002/04/22 20:54:29 vsnyder Exp $"
d1618 1
a1618 1
    & noInstances, noSurfs, quantityType, molecule, sayWhyNot )
d1634 3
a1636 1
    logical, optional, intent(IN)               :: sayWhyNot
d1642 1
d1644 4
a1647 1
   ValidateVectorQuantity = .true.
d1652 1
a1652 1
        if(present(sayWhyNot)) then
d1666 1
a1666 1
        if(present(sayWhyNot)) then
d1680 1
a1680 1
        if(present(sayWhyNot)) then
d1694 1
a1694 1
        if(present(sayWhyNot)) then
d1708 1
a1708 1
        if(present(sayWhyNot)) then
d1719 24
d1745 7
a1751 7
        if(present(sayWhyNot) .and. .not. ValidateVectorQuantity) then
          call output('quantity checked with dif vert coord', advance='yes')
          call output('quantity vert coord ', advance='no')
          call output(quantity%template%verticalCoordinate, advance='yes')
          call output('check vert coord ', advance='no')
          call output(verticalCoordinate, advance='yes')
        end if
d1756 9
a1764 8
      ValidateVectorQuantity=any(quantity%template%frequencyCoordinate == frequencyCoordinate)
        if(present(sayWhyNot) .and. .not. ValidateVectorQuantity) then
          call output('quantity checked with dif freq coord', advance='yes')
          call output('quantity freq coord ', advance='no')
          call output(quantity%template%frequencyCoordinate, advance='yes')
          call output('check freq coord ', advance='no')
          call output(frequencyCoordinate, advance='yes')
        end if
d1770 7
a1776 7
        if(present(sayWhyNot) .and. .not. ValidateVectorQuantity) then
          call output('quantity checked with dif num insts', advance='yes')
          call output('quantity num insts ', advance='no')
          call output(quantity%template%noInstances, advance='yes')
          call output('check noInstances ', advance='no')
          call output(noInstances, advance='yes')
        end if
d1782 7
a1788 7
        if(present(sayWhyNot) .and. .not. ValidateVectorQuantity) then
          call output('quantity checked with dif num surfs', advance='yes')
          call output('quantity num surfs ', advance='no')
          call output(quantity%template%noInstances, advance='yes')
          call output('check noSurfs ', advance='no')
          call output(noSurfs, advance='yes')
        end if
d1794 7
a1800 7
        if(present(sayWhyNot) .and. .not. ValidateVectorQuantity) then
          call output('quantity checked with wrong type', advance='yes')
          call output('quantity type ', advance='no')
          call output(quantity%template%quantityType, advance='yes')
          call output('check quantityType ', advance='no')
          call output(quantityType, advance='yes')
        end if
d1806 7
a1812 7
        if(present(sayWhyNot) .and. .not. ValidateVectorQuantity) then
          call output('quantity checked with wrong molecule', advance='yes')
          call output('quantity molecule ', advance='no')
          call output(quantity%template%molecule, advance='yes')
          call output('check molecule ', advance='no')
          call output(molecule, advance='yes')
        end if
d1838 3
@


2.82.2.1
log
@*** empty log message ***
@
text
@d146 1
a146 1
       "$Id: VectorsModule.f90,v 2.83 2002/05/17 17:56:01 livesey Exp $"
d1618 1
a1618 1
    & noInstances, noSurfs, quantityType, molecule, signal, sideband, sayWhyNot )
d1634 1
a1634 3
    integer, optional, dimension(:), intent(IN) :: SIGNAL
    integer, optional, dimension(:), intent(IN) :: SIDEBAND
    logical, optional, intent(IN)               :: SAYWHYNOT
a1639 1
    logical :: mySayWhyNot
d1641 1
a1641 4
    mySayWhyNot = .false.
    if (present(sayWhyNot)) mySayWhyNot = sayWhyNot

    ValidateVectorQuantity = .true.
d1646 1
a1646 1
        if (mySayWhyNot) then
d1660 1
a1660 1
        if (mySayWhyNot) then
d1674 1
a1674 1
        if (mySayWhyNot) then
d1688 1
a1688 1
        if (mySayWhyNot) then
d1702 1
a1702 1
        if (mySayWhyNot) then
a1712 24
    if (present(sideband)) then
      ValidateVectorQuantity = any(quantity%template%sideband == sideband)
      if (mySayWhyNot .and. .not. ValidateVectorQuantity) then
        call output('quantity checked with different sideband', advance='yes')
        call output('quantity sideband ', advance='no')
        call output(quantity%template%sideband, advance='yes')
        call output('check sideband ', advance='no')
        call output(sideband, advance='yes')
      end if
      if (.not. ValidateVectorQuantity) return
    end if

    if (present(signal)) then
      ValidateVectorQuantity = any(quantity%template%signal == signal)
      if (mySayWhyNot .and. .not. ValidateVectorQuantity) then
        call output('quantity checked with different signal', advance='yes')
        call output('quantity signal ', advance='no')
        call output(quantity%template%signal, advance='yes')
        call output('check signal ', advance='no')
        call output(signal, advance='yes')
      end if
      if (.not. ValidateVectorQuantity) return
    end if

d1715 7
a1721 7
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
        call output('quantity checked with dif vert coord', advance='yes')
        call output('quantity vert coord ', advance='no')
        call output(quantity%template%verticalCoordinate, advance='yes')
        call output('check vert coord ', advance='no')
        call output(verticalCoordinate, advance='yes')
      end if
d1726 8
a1733 9
      ValidateVectorQuantity=any(quantity%template%frequencyCoordinate == &
        & frequencyCoordinate)
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
        call output('quantity checked with dif freq coord', advance='yes')
        call output('quantity freq coord ', advance='no')
        call output(quantity%template%frequencyCoordinate, advance='yes')
        call output('check freq coord ', advance='no')
        call output(frequencyCoordinate, advance='yes')
      end if
d1739 7
a1745 7
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
        call output('quantity checked with dif num insts', advance='yes')
        call output('quantity num insts ', advance='no')
        call output(quantity%template%noInstances, advance='yes')
        call output('check noInstances ', advance='no')
        call output(noInstances, advance='yes')
      end if
d1751 7
a1757 7
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
        call output('quantity checked with dif num surfs', advance='yes')
        call output('quantity num surfs ', advance='no')
        call output(quantity%template%noInstances, advance='yes')
        call output('check noSurfs ', advance='no')
        call output(noSurfs, advance='yes')
      end if
d1763 7
a1769 7
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
        call output('quantity checked with wrong type', advance='yes')
        call output('quantity type ', advance='no')
        call output(quantity%template%quantityType, advance='yes')
        call output('check quantityType ', advance='no')
        call output(quantityType, advance='yes')
      end if
d1775 7
a1781 7
      if((mySayWhyNot) .and. .not. ValidateVectorQuantity) then
        call output('quantity checked with wrong molecule', advance='yes')
        call output('quantity molecule ', advance='no')
        call output(quantity%template%molecule, advance='yes')
        call output('check molecule ', advance='no')
        call output(molecule, advance='yes')
      end if
a1806 6
! Revision 2.83  2002/05/17 17:56:01  livesey
! More checks in ValidateVectorQuantity
!
! Revision 2.82  2002/05/14 00:28:04  livesey
! More informative messages in GetVectorQuantityByType
!
@


2.81
log
@Add a 'scale' argument to AddToVector
@
text
@d73 1
a73 1
  use MLSSignals_m, only: MODULES, SIGNALS
d146 1
a146 1
       "$Id: VectorsModule.f90,v 2.80 2002/03/13 22:00:16 livesey Exp $"
d1363 21
d1807 3
@


2.80
log
@Changed m_explicitFill to m_fill
@
text
@d146 1
a146 1
       "$Id: VectorsModule.f90,v 2.79 2002/03/08 08:06:32 livesey Exp $"
d217 1
a217 1
  subroutine AddToVector ( X, Y )  ! X = X + Y
d221 1
d227 10
a236 3
    do i = 1, size(x%quantities)
      x%quantities(i)%values = x%quantities(i)%values + y%quantities(i)%values
    end do
d1786 3
@


2.79
log
@Added explicit fill mask
@
text
@d104 1
a104 1
  public :: M_ExplicitFill, M_FullDerivatives, M_LinAlg
d146 1
a146 1
       "$Id: VectorsModule.f90,v 2.78 2002/02/14 23:15:22 vsnyder Exp $"
d189 3
a191 3
  integer, parameter :: M_ExplicitFill = 4
  integer, parameter :: M_FullDerivatives = 2
  integer, parameter :: M_LinAlg = 1
d1778 3
@


2.78
log
@Add .mdot. operator
@
text
@d104 1
a104 1
  public :: M_FullDerivatives, M_LinAlg
d146 1
a146 1
       "$Id: VectorsModule.f90,v 2.77 2002/02/08 22:58:14 livesey Exp $"
d189 1
d1778 3
@


2.77
log
@Made CopyVectorMask public
@
text
@d44 1
d84 1
a84 1
  public :: operator (*), operator ( .DOT. )
d93 1
d140 4
d146 1
a146 1
       "$Id: VectorsModule.f90,v 2.76 2002/02/08 22:51:40 livesey Exp $"
d780 47
d864 2
a867 2
            w = w + 3
            j = j + 1
d1015 3
a1017 1
            call dump ( ichar(vector%quantities(j)%mask), format='(z2.2)' )
d1777 3
@


2.76
log
@Added CopyVectorMask
@
text
@d88 1
a88 1
  public :: ConstructVectorTemplate, CopyVector, CreateMaskArray
d140 1
a140 1
       "$Id: VectorsModule.f90,v 2.75 2002/02/07 02:53:06 vsnyder Exp $"
d1722 3
@


2.75
log
@Add parameter for FullDerivatives bit for mask
@
text
@d33 1
d140 1
a140 1
       "$Id: VectorsModule.f90,v 2.74 2002/02/05 02:39:59 vsnyder Exp $"
d563 22
d1722 3
@


2.74
log
@Change mask from 1-bit per to 8-bits per (using character)
@
text
@d101 1
a101 1
  public :: M_LinAlg
d139 1
a139 1
       "$Id: VectorsModule.f90,v 2.73 2002/01/18 00:34:53 livesey Exp $"
d181 3
a183 1
  integer, parameter :: M_LinAlg = 1    ! Bit of MASK field of VectorValue_T
d1699 3
@


2.73
log
@Bug fix, copyVector wasn't ensuring that mask in destination was
allocated.
@
text
@d91 2
a92 1
  public :: DumpMask, Dump_Vector, Dump_Vectors, Dump_Vector_Templates
d100 2
d113 4
d139 1
a139 1
       "$Id: VectorsModule.f90,v 2.72 2001/10/23 16:39:28 pwagner Exp $"
d172 1
a172 1
    integer, dimension(:,:), pointer :: MASK => NULL() ! MASK is used to
d175 4
a178 4
    ! MASK are (size(values,1)+bit_size(mask)-1)/bit_size(mask) and
    ! size(values,2).  Bits of MASK are used to determine what is not
    ! interesting.  Zero means the corresponding element of VALUES is
    ! interesting, and one means it is not.
d181 2
d324 1
a324 1
  subroutine ClearMask ( MASK, TO_CLEAR )
d327 3
a329 2
  ! the bits of MASK.
    integer, intent(inout), dimension(:) :: MASK
d331 4
a334 1
    integer :: I, W
d336 1
a336 5
      do i = 1, size(to_clear)
        w = (to_clear(i)-1) / b + 1
        if ( w > 0 .and. w <= size(mask) ) &
          & mask(w) = ibclr( mask(w), mod(to_clear(i)-1, b) )
      end do
d338 1
a338 1
      mask = 0
d343 2
a344 2
  subroutine ClearUnderMask ( Z, Inst, Quant )
  ! Clear elements of Z that correspond to a nonzero bit in its mask.
d347 3
d351 1
a351 1
    integer, intent(in), optional :: Inst, Quant
d354 1
d359 2
d377 2
a378 2
            if ( btest(z%quantities(qi)%mask((vi-1)/b + 1,ii), mod(vi-1, b)) ) &
              z%quantities(qi)%values(vi,ii) = 0.0
d563 1
a563 1
    integer, dimension(:,:), pointer :: MASK ! To create
d565 1
a565 1
    call allocate_test ( mask, (size(values,1)+b-1)/b, &
d567 1
a567 1
    mask = 0 ! All vector elements are interesting
d574 1
a574 3
    call allocate_test ( vectorValue%mask, (size(vectorValue%values,1)+b-1)/b, &
      & size(vectorValue%values,2), "MASK in CreateMask", ModuleName )
    vectorValue%mask = 0 ! All vector elements are interesting
d749 3
a751 3
  ! -------------------------------------------------  DumpMask  -----
  subroutine DumpMask ( VECTOR )
    type (Vector_T), intent(in), target :: VECTOR
d754 1
d756 46
a802 3
    integer :: s                        ! Surface index
    integer :: j                        ! Element index
    integer :: c                        ! Channel index
d809 1
a809 32
      call output ( 'Quantity ' )
      call display_string ( vector%quantities(q)%template%name )

      if ( .not. vector%quantities(q)%template%regular ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName,&
        & 'Unable to dump mask for irregular quantities' )

      if ( .not. associated ( vector%quantities(q)%mask ) ) then
        call output ( ' has no mask.', advance='yes' )
      else
        call output ( '', advance='yes' )
        do i = 1, vector%quantities(q)%template%noInstances
          call output ( 'Instance: ' )
          call output ( i, advance='yes' )
          j = 0
          do s = 1, vector%quantities(q)%template%noSurfs
            call output ( 'Surface ' )
            call output ( s )
            call output ( ': ' )
            do c = 1, vector%quantities(q)%template%noChans
              if ( btest(vector%quantities(q)%mask(j/b+1,i), &
                & mod (j,b) ) ) then
                call output ( '1' )
              else
                call output ( '0' )
              end if
              j = j + 1
            end do
            call output ( '', advance='yes' )
          end do                        ! Surface loop
        end do                          ! Instance loop
      end if                            ! Has a mask
d811 1
a811 1
  end subroutine DumpMask
d937 1
a937 1
            call dump ( vector%quantities(j)%mask, format='(z8)' )
d1280 1
a1280 1
  logical function IsVectorQtyMasked ( vectorQty, Row, Column )
d1283 2
a1284 2
  ! If TRUE, don't use vectorQty%values(Row, Column)
  ! Otherwise, go ahead
d1290 1
d1292 4
d1298 1
a1298 2
    isVectorQtyMasked = &
      & btest( vectorQty%mask((row-1)/b + 1, column), mod(row-1, b) )
d1303 1
a1303 1
  subroutine MaskVectorQty ( vectorQty, Row, Column )
d1305 1
a1305 1
  ! Set the mask for VectorQty for address; meaning
d1307 2
a1308 1
  ! Otherwise, go ahead
d1314 3
d1318 2
d1321 2
a1322 2
    vectorQty%mask((row-1)/b + 1, column) = &
      & ibset( vectorQty%mask((row-1)/b + 1, column), mod(row-1, b) )
d1414 1
a1414 1
  subroutine SetMask ( MASK, TO_SET, MAXBIT )
d1416 5
a1420 3
  ! elements starts at one, not zero!  If TO_SET is absent, set all of the
  ! bits of MASK.  If MaxBit is present, do not set any bits after MaxBit.
    integer, intent(inout), dimension(:) :: MASK
d1422 5
a1426 7
    integer, intent(in), optional :: MaxBit
    integer :: I, MyMaxBit, W
    ! Masks for last word, so as not to get the wrong answer for the number
    ! of meaningful elements by subtracting the number of set bits from the
    ! total number of elements.
    integer, parameter :: Masks(1:bit_size(0)-1) = &
      & (/ (ishft(not(0),i-bit_size(0)),i=1,bit_size(0)-1) /)
d1431 2
a1432 4
        if ( to_set(i) <= myMaxBit ) then
          w = (to_set(i)-1) / b + 1
          if ( w > 0 .and. w <= size(mask) ) &
            & mask(w) = ibset(mask(w),mod(to_set(i)-1, b))
a1435 1
      mask = not(0)
d1437 3
a1439 6
        w = max(1, (maxBit + bit_size(0) - 1) / bit_size(0))
        if ( w <= size(mask) ) then
          i = mod(maxBit,bit_size(0))
          if ( i /= 0 ) mask(w) = iand(mask(w),masks(i))
          mask(w+1:) = 0
        end if
d1697 4
@


2.72
log
@Added MaskVectorQty
@
text
@d132 1
a132 1
       "$Id: VectorsModule.f90,v 2.71 2001/10/18 23:49:46 livesey Exp $"
d537 4
a540 2
        if ( doMask .and. associated (x%quantities(i)%mask ) ) &
          & z%quantities(i)%mask = x%quantities(i)%mask
d1667 3
@


2.71
log
@Tidied up a floating comma in dump_vector
@
text
@d54 1
d96 1
a96 1
  public :: SubtractVectors, ValidateVectorQuantity
d132 1
a132 1
       "$Id: VectorsModule.f90,v 2.70 2001/10/18 23:31:56 pwagner Exp $"
d1270 18
d1665 3
@


2.70
log
@Expanded use of details in dump_vectors; stops if try to rmVectorFromDatabase
@
text
@d131 1
a131 1
       "$Id: VectorsModule.f90,v 2.69 2001/10/15 22:11:54 livesey Exp $"
d906 1
a906 1
          call dump ( vector%quantities(j)%values, ', Elements = ' )
d1646 3
@


2.69
log
@Added globalUnit stuff
@
text
@d131 1
a131 1
       "$Id: VectorsModule.f90,v 2.68 2001/10/12 23:10:18 pwagner Exp $"
d796 2
d838 1
d864 4
d937 2
d973 7
d1316 2
d1327 2
d1646 3
@


2.68
log
@Better dumps, fewer bumps
@
text
@d66 1
a66 1
  use Intrinsic, only: Lit_Indices
d131 1
a131 1
       "$Id: VectorsModule.f90,v 2.67 2001/10/09 23:43:42 pwagner Exp $"
d177 1
d282 1
d406 1
d563 1
a563 1
    & ( vectorName, vectorTemplate, quantities, VectorNameText ) &
d574 1
d583 1
d1626 3
@


2.67
log
@Some further improvements in dumping vectors
@
text
@d131 1
a131 1
       "$Id: VectorsModule.f90,v 2.66 2001/10/08 23:40:49 pwagner Exp $"
d782 7
a788 1
    & COHERENT, STACKED, REGULAR, MINORFRAME, MAJORFRAME )
d803 1
d809 7
d868 3
a870 1
          call output ( '    (none for this quantity) ', advance='yes')
d876 3
a878 1
          call output ( '    (none for this quantity) ', advance='yes')
d909 1
d917 6
a922 1
    & COHERENT, STACKED, REGULAR, MINORFRAME, MAJORFRAME )
d937 1
d944 1
d946 5
d987 3
a989 1
        & coherent, stacked, regular, minorframe, majorframe )
d1621 3
@


2.66
log
@Improved dump routines
@
text
@d70 1
a70 1
  use MLSSignals_m, only: MODULES
d131 1
a131 1
       "$Id: VectorsModule.f90,v 2.65 2001/10/05 17:33:55 vsnyder Exp $"
d781 1
a781 1
    & QUANTITYTYPES, INSTRUMENTMODULES, &
d791 1
d823 2
d842 2
a843 2
        call output ( ' noInstances = ' )
        call output ( vector%quantities(j)%template%noInstances, advance='no' )
a845 2
        call output ( ' noChans = ' )
        call output ( vector%quantities(j)%template%noChans, advance='no' )
d852 6
d859 5
a863 1
        call display_string ( modules(vector%quantities(j)%template%instrumentModule)%name, advance='yes' )
d897 1
a897 1
    & QUANTITYTYPES, INSTRUMENTMODULES, &
d907 1
d937 2
d955 1
a955 1
        & quantitytypes, instrumentmodules, &
d1588 3
@


2.65
log
@Don't set more bits in the mask than there are elements of VALUES
@
text
@d70 1
d131 1
a131 1
       "$Id: VectorsModule.f90,v 2.64 2001/10/04 01:50:33 vsnyder Exp $"
d781 2
a782 1
    & QUANTITYTYPES, COHERENT, STACKED, REGULAR, MINORFRAME, MAJORFRAME )
d790 1
d820 2
d839 10
d850 14
a863 1
        call output ( vector%quantities(j)%template%id )
d886 2
a887 1
    & QUANTITYTYPES, COHERENT, STACKED, REGULAR, MINORFRAME, MAJORFRAME )
d895 1
d923 2
d941 2
a942 1
        & quantitytypes, coherent, stacked, regular, minorframe, majorframe )
d1574 3
@


2.64
log
@Add 'database' argument to CloneVector, CopyVector; cosmetic changes
@
text
@d130 1
a130 1
       "$Id: VectorsModule.f90,v 2.63 2001/10/03 23:05:42 vsnyder Exp $"
d321 2
a322 1
        mask(w) = ibclr( mask(w), mod(to_clear(i)-1, b) )
d1252 1
a1252 1
  subroutine SetMask ( MASK, TO_SET )
d1255 1
a1255 1
  ! bits of MASK.
d1258 7
a1264 1
    integer :: I, W
d1266 2
d1269 5
a1273 2
        w = (to_set(i)-1) / b + 1
        mask(w) = ibset(mask(w),mod(to_set(i)-1, b))
d1277 8
d1541 3
@


2.63
log
@Added 'VectorNameText' argument to CopyVector
@
text
@d130 1
a130 1
       "$Id: VectorsModule.f90,v 2.62 2001/10/02 23:39:15 vsnyder Exp $"
d377 1
a377 1
  subroutine CloneVector ( Z, X, VectorNameText )
d382 2
d395 1
d415 1
d483 1
a483 1
    & VectorNameText )
d487 2
a488 1
  ! that part of the vector.
d500 1
d511 1
a511 1
      call cloneVector ( Z, X, vectorNameText=vectorNameText )
d626 2
a627 1
    ! Let the destruction of the vector template take care of vector%template%quantities
d1000 2
a1001 2
      & quantityType, molecule, instrumentModule, radiometer, signal, sideband, &
      &   noError = present(otherVector) .or. myNoError)
d1006 2
a1007 1
      ! Can only get here if not found in first vector and noError or other vector
d1010 2
a1011 2
          &  quantityType, molecule, instrumentModule, radiometer, signal, sideband, &
          &  noError=myNoError )
d1013 2
a1014 1
        if ( index /= 0 ) GetVectorQuantityByType => otherVector%quantities( index )
d1521 3
@


2.62
log
@Add quantity name to error message in GetVectorQuantityIndexByType
@
text
@d130 1
a130 1
       "$Id: VectorsModule.f90,v 2.61 2001/10/02 19:00:50 vsnyder Exp $"
d478 2
a479 1
  subroutine CopyVector ( Z, X, CLONE, Quant, Inst, NoValues, NoMask )
d494 1
d505 1
a505 1
      call cloneVector ( Z, X, vectorNameText='_Z' )
d1512 3
@


2.61
log
@Add ClearVector subroutine
@
text
@d66 1
d130 1
a130 1
       "$Id: VectorsModule.f90,v 2.60 2001/10/01 20:32:27 vsnyder Exp $"
d1130 2
a1131 1
      msg = trim(msg) // ' that has the required type'
d1510 3
@


2.60
log
@Handle word and bit indexing in mask consistently
@
text
@d27 2
d83 1
a83 1
  public :: ClearUnderMask, CloneVector, ConstantXVector
d129 1
a129 1
       "$Id: VectorsModule.f90,v 2.59 2001/09/29 00:25:51 vsnyder Exp $"
d364 11
d1508 3
@


2.59
log
@Correct word indexing for mask operations
@
text
@d86 4
a89 5
  public :: DumpMask
  public :: Dump_Vector, Dump_Vectors, Dump_Vector_Templates, GetVectorQuantity
  public :: GetVectorQuantityByType, GetVectorQtyByTemplateIndex
  public :: GetVectorQuantityIndexByName, GetVectorQuantityIndexByType
  public :: IsVectorQtyMasked, MultiplyVectors
d127 1
a127 1
       "$Id: VectorsModule.f90,v 2.58 2001/09/25 19:41:07 livesey Exp $"
d309 3
a311 2
  ! Clear bits of MASK indexed by elements of TO_CLEAR.  If TO_CLEAR is
  ! absent, clear all of the bits of MASK.
a711 1
    integer :: b                        ! Bit size
d733 1
a733 2
          b = bit_size (vector%quantities(q)%mask)
          j = 1
d1136 2
a1137 1
    isVectorQtyMasked = btest( vectorQty%mask(row/b + 1, column), mod(row, b) )
d1226 3
a1228 2
  ! Set bits of MASK indexed by elements of TO_SET.  If TO_SET is absent,
  ! set all of the bits of MASK.
d1495 3
@


2.58
log
@Added DumpMask
@
text
@d128 1
a128 1
       "$Id: VectorsModule.f90,v 2.57 2001/09/25 00:47:08 vsnyder Exp $"
d317 2
a318 2
        w = to_clear(i) / b + 1
        mask(w) = ibclr( mask(w), mod(to_clear(i), b) )
d354 1
a354 1
            if ( btest(z%quantities(qi)%mask(vi/b + 1,ii), mod(vi, b)) ) &
d1234 2
a1235 2
        w = to_set(i) / b + 1
        mask(w) = ibset(mask(w),mod(to_set(i), b))
d1495 3
@


2.57
log
@Add noMask & noValues optional arguments to CopyVector
@
text
@d41 1
d86 1
d128 1
a128 1
       "$Id: VectorsModule.f90,v 2.56 2001/09/25 00:18:23 livesey Exp $"
d703 53
d1495 3
@


2.56
log
@Bug fix
@
text
@d21 1
a21 1
! AddVectors                   result Z = X + Y
d25 1
a25 1
! AxPy                         result z = A x + y
d28 3
a30 3
! ConstantXVector              result z = A x
! ConstructVectorTemplate      creates a vectorTemplate from a list of quantities
! CopyVector                   z = x
d33 2
a34 2
! CreateVector                 creates an empty vector according to a given template
! DestroyVectorDatabase        destroys a vector database
d36 3
a38 3
! DestroyVectorMask            destroys the masks stored in the vector
! DestroyVectorTemplateDatabase destroys a vector template database
! DestroyVectorTemplateInfo    destroys a vector template
d41 9
a49 9
! dump                         interface for next three
! dump_vector                  display how a single vector is made up
! dump_vectors                 display how vector database is made up
! dump_vector_templates        display how vector template database is made up
! GetVectorQuantity            returns pointer to quantity by name in vector
! GetVectorQuantityByType      returns pointer to quantity by type in vector
! GetVectorQtyByTemplateIndex  returns pointer to quantity by template in vector
! GetVectorQuantityIndexByName returns index to quantity by name in vector
! GetVectorQuantityIndexByType returns index to quantity by type in vector
d55 2
a56 2
! SubtractFromVector           X = X - Y
! SubtractVectors              returns Z = x - y
d126 1
a126 1
       "$Id: VectorsModule.f90,v 2.55 2001/09/24 23:01:11 vsnyder Exp $"
d462 1
a462 1
  subroutine CopyVector ( Z, X, CLONE, Quant, Inst )
d465 2
a466 1
  ! of X to Z.
d475 3
d482 4
d494 3
a496 2
        z%quantities(quant)%values(:,inst) = x%quantities(quant)%values(:,inst)
        if ( associated (x%quantities(quant)%mask ) ) &
d499 3
a501 2
        z%quantities(quant)%values = x%quantities(quant)%values
        if ( associated (x%quantities(quant)%mask ) ) &
d506 2
a507 2
        z%quantities(i)%values = x%quantities(i)%values
        if ( associated (x%quantities(i)%mask ) ) &
d1440 3
@


2.55
log
@Make consistent/correct lower bound calculation for MASK array
@
text
@d126 1
a126 1
       "$Id: VectorsModule.f90,v 2.54 2001/09/21 17:38:46 pwagner Exp $"
d310 1
a310 1
    integer, intent(inout), dimension(0:) :: MASK
d1164 1
a1164 1
    integer, intent(inout), dimension(0:) :: MASK
d1430 3
@


2.54
log
@Added args to dump_vector(s)
@
text
@d126 1
a126 1
       "$Id: VectorsModule.f90,v 2.53 2001/09/20 23:02:31 vsnyder Exp $"
d312 1
a312 1
    integer :: I, W, P
d315 2
a316 3
        w = to_clear(i) / b
        p = mod(to_clear(i), b)
        mask(w) = ibclr(mask(w),p)
a331 2
    integer :: MB        ! Mask bit index within word MW
    integer :: MW        ! Mask word index
d352 1
a352 3
            mw = vi / b
            mb = mod(vi, b)
            if ( btest(z%quantities(qi)%mask(mw,ii), mb) ) &
a1069 3
    
  ! Private
    integer             ::              ROWW, ROWBIT
d1073 1
a1073 5
    roww = row / b               ! will have to add mask starting index
    rowbit = mod(row, b)
    if ( ibits( vectorQty%mask(roww+1, column), rowbit, 1 ) /= 0 ) then
      isVectorQtyMasked = .true.
    endif
d1166 1
a1166 1
    integer :: I, W, P
d1169 2
a1170 3
        w = to_set(i) / b
        p = mod(to_set(i), b)
        mask(w) = ibset(mask(w),p)
d1430 3
@


2.53
log
@Specified explicitly which entities are public (so as not to re-publish
everything gotten by USE).  Added ClearUnderMask subroutine.
@
text
@d41 1
d44 1
d126 1
a126 1
       "$Id: VectorsModule.f90,v 2.52 2001/09/20 20:56:34 pwagner Exp $"
d697 2
a698 1
  subroutine Dump_Vector ( VECTOR, DETAILS, NAME )
d704 9
d715 1
d732 29
a760 12
      call output ( j, 4 )
      call output ( "~" )
      if ( vector%quantities(j)%template%name /= 0 ) then
        call output ( ' Qty_Template_Name = ' )
        call display_string ( vector%quantities(j)%template%name )
      end if
      call output ( ' Qty_Template_ID = ' )
      call output ( vector%quantities(j)%template%id )
      if ( myDetails > 0 ) then
        call dump ( vector%quantities(j)%values, ', Elements = ' )
        if ( associated(vector%quantities(j)%mask) ) then
          call dump ( vector%quantities(j)%mask, format='(z8)' )
d762 7
a768 1
          call output ( '      Without mask', advance='yes' )
a769 8
      else
        call output ( ', with' )
        if ( .not. associated(vector%quantities(j)%values) ) &
          & call output ( 'out' )
        call output ( ' values, with' )
        if ( .not. associated(vector%quantities(j)%mask ) ) &
          & call output ( 'out' )
        call output ( ' mask', advance='yes' )
d775 2
a776 1
  subroutine Dump_Vectors ( VECTORS, DETAILS, NAME )
d782 9
d792 4
d801 28
a828 3
      call output ( i, 4 )
      call output ( ': ' )
      call dump_vector ( vectors(i), details, name )
d1443 4
@


2.52
log
@Added contents list; tweaked some things
@
text
@d71 20
a90 1
  public
d124 1
a124 1
       "$Id: VectorsModule.f90,v 2.51 2001/09/19 23:40:53 pwagner Exp $"
d132 1
a132 1
  type VectorTemplate_T
d322 41
d694 2
a695 2
  ! ------------------------------------------------  DUMP_VECTOR  -----
  subroutine DUMP_VECTOR ( VECTOR, DETAILS, NAME )
d744 1
a744 1
  end subroutine DUMP_VECTOR
d746 2
a747 2
  ! -----------------------------------------------  DUMP_VECTORS  -----
  subroutine DUMP_VECTORS ( VECTORS, DETAILS, NAME )
d763 1
a763 1
  end subroutine DUMP_VECTORS
d765 2
a766 2
  ! --------------------------------------  DUMP_VECTOR_TEMPLATES  -----
  subroutine DUMP_VECTOR_TEMPLATES ( VECTOR_TEMPLATES, DETAILS )
d793 1
a793 1
  end subroutine DUMP_VECTOR_TEMPLATES
d870 1
a870 1
  function GetVectorQtyByTemplateIndex(vector, quantityIndex, indexInVector )
d997 2
a998 2
  ! -------------------------------  isVectorQtyMasked  -----
  logical function isVectorQtyMasked ( vectorQty, Row, Column )
d1020 1
a1020 1
  end function isVectorQtyMasked
d1064 2
a1065 2
  !-----------------------------------------  rmVectorFromDatabase  -----
  integer function rmVectorFromDatabase ( DATABASE, ITEM )
d1080 1
a1080 1
  end function rmVectorFromDatabase
d1185 1
a1185 1
  function ValidateVectorQuantity(quantity, coherent, stacked, regular,&
d1187 1
a1187 1
    & noInstances, noSurfs, quantityType, molecule, sayWhyNot)
d1376 3
@


2.51
log
@Added rmVectorFromDatabase, isVectorQtyMasked functions
@
text
@d11 46
d105 1
a105 1
       "$Id: VectorsModule.f90,v 2.50 2001/09/17 23:10:49 pwagner Exp $"
a243 17
  !-----------------------------------------  rmVectorFromDatabase  -----
  integer function rmVectorFromDatabase ( DATABASE, ITEM )

  ! This routine removes a vector from a database of such vectors, 
  ! deallocating the database if necessary.

    ! Dummy arguments
    type (Vector_T), dimension(:), pointer :: DATABASE
    type (Vector_T), intent(in) ::            ITEM

    ! Local variables
    type (Vector_T), dimension(:), pointer :: tempDatabase
    include "rmItemFromDatabase.f9h"

    rmVectorFromDatabase = newSize
  end function rmVectorFromDatabase

d1004 18
d1122 1
a1122 1
  ! This function performes a series of tests on a quantity to make sure it
d1316 3
@


2.50
log
@New optional arg majorFrame in Validate..
@
text
@d59 1
a59 1
       "$Id: VectorsModule.f90,v 2.49 2001/07/19 17:57:15 vsnyder Exp $"
d183 1
a183 1
  ! This routine adds a vector template to a database of such templates, 
d188 1
a188 1
    type (Vector_T), intent(in) :: ITEM
d198 17
d908 25
d1269 3
@


2.49
log
@Added 'Quant' and 'Inst' arguments to CopyVector and MultiplyVectors
@
text
@d59 1
a59 1
       "$Id: VectorsModule.f90,v 2.48 2001/07/17 17:33:21 livesey Exp $"
d1037 1
a1037 1
    & minorFrame, verticalCoordinate, frequencyCoordinate, &
d1046 1
d1109 1
a1109 1
          call output('Minor fram quantity checked with not', advance='yes')
d1119 14
d1227 3
@


2.48
log
@Added CreateMaskArray
@
text
@d59 1
a59 1
       "$Id: VectorsModule.f90,v 2.47 2001/07/06 22:04:02 livesey Exp $"
d359 4
a362 3
  subroutine CopyVector ( Z, X, CLONE ) ! If CLONE is present and .true.,
  ! Destroy Z, deep Z = X, except the name of Z is not changed.  Otherwise,
  ! copy only the values and mask of X to Z
d367 4
d381 17
a397 5
    do i = 1, size(x%quantities)
      z%quantities(i)%values = x%quantities(i)%values
      if ( associated (x%quantities(i)%mask ) ) &
        & z%quantities(i)%mask = x%quantities(i)%mask
    end do
d892 1
a892 1
  subroutine MultiplyVectors ( X, Y, Z )
d900 4
d916 15
a930 4
    do i = 1, size(x%quantities)
      result%quantities(i)%values = &
        & x%quantities(i)%values * y%quantities(i)%values
    end do
d980 3
a982 3
    integer, intent(in), optional :: Quant, Inst  ! If Quant\ is present,
    !  only that quantity is subtracted.  If furthermore Inst\ is present,
    !  only that instance is subtracted.  If Inst\ is present but Quant\
d1212 3
@


2.47
log
@Added call to DestroyVectorMask in DestroyVectorInfo
@
text
@d59 1
a59 1
       "$Id: VectorsModule.f90,v 2.46 2001/06/26 20:32:31 vsnyder Exp $"
d383 10
d1180 3
@


2.46
log
@Simplify mask handling by using zero origin for first dimension
@
text
@d59 1
a59 1
       "$Id: VectorsModule.f90,v 2.45 2001/06/01 01:04:22 vsnyder Exp $"
d466 1
d1170 3
@


2.45
log
@Add 'Multiply' generic
@
text
@d59 1
a59 1
       "$Id: VectorsModule.f90,v 2.44 2001/05/25 22:33:07 livesey Exp $"
d243 1
a243 1
    integer, intent(inout), dimension(:) :: MASK
d250 1
a250 1
        mask(w+1) = ibclr(mask(w+1),p)
d917 1
a917 1
    integer, intent(inout), dimension(:) :: MASK
d924 1
a924 1
        mask(w+1) = ibset(mask(w+1),p)
d1169 3
@


2.44
log
@Changed a comment
@
text
@d37 4
d59 1
a59 1
       "$Id: VectorsModule.f90,v 2.43 2001/05/17 20:17:00 vsnyder Exp $"
d1169 3
@


2.43
log
@Don't clobber Y argument of ScaleVector by making it intent(out) -- we
need to check its template.
@
text
@d55 1
a55 1
       "$Id: VectorsModule.f90,v 2.42 2001/05/11 23:33:29 vsnyder Exp $"
d458 1
d1165 4
@


2.42
log
@Get rid of double-printing of 'Without mask'
@
text
@d55 1
a55 1
       "$Id: VectorsModule.f90,v 2.41 2001/05/11 22:01:00 vsnyder Exp $"
d892 1
a892 1
    type(Vector_T), intent(out), optional, target :: Y
d1164 3
@


2.41
log
@Simplify dumping just one vector
@
text
@d55 1
a55 1
       "$Id: VectorsModule.f90,v 2.40 2001/05/10 23:29:59 livesey Exp $"
a603 9
      if ( associated(vector%quantities(j)%mask) ) then
        if ( myDetails > 0 ) then
          call dump ( vector%quantities(j)%mask, format='(z8)' )
        else
          call output ( '      With mask', advance='yes' )
        end if
      else
        call output ( '      Without mask', advance='yes' )
      end if
d1164 3
@


2.40
log
@Added some arguments to ValidateVectorQuantity
@
text
@d55 1
a55 1
       "$Id: VectorsModule.f90,v 2.39 2001/05/10 23:11:54 vsnyder Exp $"
d558 3
a560 1
    integer, intent(in), optional :: DETAILS
d562 52
a613 1
    call dump_vectors ( (/ vector /), details, name )
d623 1
a623 3
    integer :: I, J, MyDetails
    myDetails = 1
    if ( present(details) ) myDetails = details
d630 2
a631 49
      call output ( ':' )
      if ( present(name) ) then
        call output ( name ); call output ( ', ' )
      end if
      if ( vectors(i)%name /= 0 ) then
        call output ( ' Name = ' )
        call display_string ( vectors(i)%name )
      end if
      if ( vectors(i)%template%name /= 0 ) then
        call output ( ' Template_Name = ' )
        call display_string ( vectors(i)%template%name )
      end if
      call output ( ' Template_ID = ' )
      call output ( vectors(i)%template%id, advance='yes' )
      do j = 1, size(vectors(i)%quantities)
        call output ( j, 4 )
        call output ( "~" )
        if ( vectors(i)%quantities(j)%template%name /= 0 ) then
          call output ( ' Qty_Template_Name = ' )
          call display_string ( vectors(i)%quantities(j)%template%name )
        end if
        call output ( ' Qty_Template_ID = ' )
        call output ( vectors(i)%quantities(j)%template%id )
        if ( myDetails > 0 ) then
          call dump ( vectors(i)%quantities(j)%values, ', Elements = ' )
          if ( associated(vectors(i)%quantities(j)%mask) ) then
            call dump ( vectors(i)%quantities(j)%mask, format='(z8)' )
          else
            call output ( '      Without mask', advance='yes' )
          end if
        else
          call output ( ', with' )
          if ( .not. associated(vectors(i)%quantities(j)%values) ) &
            & call output ( 'out' )
          call output ( ' values, with' )
          if ( .not. associated(vectors(i)%quantities(j)%mask ) ) &
            & call output ( 'out' )
          call output ( ' mask', advance='yes' )
        end if
        if ( associated(vectors(i)%quantities(j)%mask) ) then
          if ( myDetails > 0 ) then
            call dump ( vectors(i)%quantities(j)%mask, format='(z8)' )
          else
            call output ( '      With mask', advance='yes' )
          end if
        else
          call output ( '      Without mask', advance='yes' )
        end if
      end do ! j
d1173 3
@


2.39
log
@Add a dumper for one vector
@
text
@d55 1
a55 1
       "$Id: VectorsModule.f90,v 2.38 2001/05/08 20:28:34 vsnyder Exp $"
d995 1
a995 1
    & noInstances, quantityType, molecule, sayWhyNot)
d1007 1
d1009 2
a1010 2
    integer, optional ,dimension(:), intent(IN) :: MOLECULE
    logical, optional , intent(IN)              :: sayWhyNot
d1111 12
d1169 3
@


2.38
log
@Added stuff to dump masks
@
text
@d34 1
a34 1
    module procedure DUMP_VECTORS, DUMP_VECTOR_TEMPLATES
d55 1
a55 1
       "$Id: VectorsModule.f90,v 2.37 2001/05/03 02:12:03 vsnyder Exp $"
d555 8
d564 1
a564 1
  subroutine DUMP_VECTORS ( VECTORS, DETAILS )
d569 1
d573 4
a576 2
    call output ( 'VECTORS: SIZE = ' )
    call output ( size(vectors), advance='yes' )
d580 3
d1156 3
@


2.37
log
@Take out a line of debugging scaffolding
@
text
@d55 1
a55 1
       "$Id: VectorsModule.f90,v 2.36 2001/05/02 20:44:37 vsnyder Exp $"
d590 5
d598 14
a611 2
            call output ( 'out' )
          call output ( ' values', advance='yes' )
d1142 3
@


2.36
log
@Provide for text names for vectors that didn't come from CF
@
text
@d55 1
a55 1
       "$Id: VectorsModule.f90,v 2.35 2001/05/02 05:29:44 livesey Exp $"
a276 1
i = size(x%quantities)
d1125 3
@


2.35
log
@Added index argument to GetVectorQtyByTemplateIndex
@
text
@d21 2
d55 1
a55 1
       "$Id: VectorsModule.f90,v 2.34 2001/04/28 21:01:20 livesey Exp $"
d152 1
a152 1
    call CloneVector ( z, x )
d228 1
a228 1
    call CloneVector ( z, x )
d254 1
a254 1
  subroutine CloneVector ( Z, X )
d269 1
d274 2
d277 1
d309 1
a309 1
    call CloneVector ( z, x )
d368 1
a368 1
      call cloneVector ( Z, X )
d391 2
a392 1
    & ( vectorName, vectorTemplate, quantities ) result ( vector )
d401 1
d410 2
d849 1
a849 1
      call CloneVector ( z, x )
d952 1
a952 1
    call CloneVector ( z, x )
d992 6
a997 6
         call output('Coherent quantity checked with incoherent', advance='yes')
         call output('quantity coherent? ', advance='no')
         call output(quantity%template%coherent, advance='yes')
         call output('check coherent? ', advance='no')
         call output(coherent, advance='yes')
        endif
d999 1
a999 1
      endif
d1006 6
a1011 6
         call output('stacked quantity checked with unstacked', advance='yes')
         call output('quantity stacked? ', advance='no')
         call output(quantity%template%stacked, advance='yes')
         call output('check stacked? ', advance='no')
         call output(stacked, advance='yes')
        endif
d1020 6
a1025 6
         call output('Regular quantity checked with irregular', advance='yes')
         call output('quantity regular? ', advance='no')
         call output(quantity%template%regular, advance='yes')
         call output('check regular? ', advance='no')
         call output(regular, advance='yes')
        endif
d1034 6
a1039 6
         call output('Minor fram quantity checked with not', advance='yes')
         call output('quantity minor frame? ', advance='no')
         call output(quantity%template%minorFrame, advance='yes')
         call output('check minorFrame? ', advance='no')
         call output(minorFrame, advance='yes')
        endif
d1047 6
a1052 6
         call output('quantity checked with dif vert coord', advance='yes')
         call output('quantity vert coord ', advance='no')
         call output(quantity%template%verticalCoordinate, advance='yes')
         call output('check vert coord ', advance='no')
         call output(verticalCoordinate, advance='yes')
        endif
d1059 6
a1064 6
         call output('quantity checked with dif freq coord', advance='yes')
         call output('quantity freq coord ', advance='no')
         call output(quantity%template%frequencyCoordinate, advance='yes')
         call output('check freq coord ', advance='no')
         call output(frequencyCoordinate, advance='yes')
        endif
d1071 6
a1076 6
         call output('quantity checked with dif num insts', advance='yes')
         call output('quantity num insts ', advance='no')
         call output(quantity%template%noInstances, advance='yes')
         call output('check noInstances ', advance='no')
         call output(noInstances, advance='yes')
        endif
d1083 6
a1088 6
         call output('quantity checked with wrong type', advance='yes')
         call output('quantity type ', advance='no')
         call output(quantity%template%quantityType, advance='yes')
         call output('check quantityType ', advance='no')
         call output(quantityType, advance='yes')
        endif
d1095 6
a1100 6
         call output('quantity checked with wrong molecule', advance='yes')
         call output('quantity molecule ', advance='no')
         call output(quantity%template%molecule, advance='yes')
         call output('check molecule ', advance='no')
         call output(molecule, advance='yes')
        endif
d1126 3
@


2.34
log
@Another bug fix in GetVectorQuantityByType
@
text
@d53 1
a53 1
       "$Id: VectorsModule.f90,v 2.33 2001/04/28 20:54:48 livesey Exp $"
d696 1
a696 1
  function GetVectorQtyByTemplateIndex(vector, quantityIndex)
d703 1
d708 1
a708 1
    integer :: i, indexWithinQuantity
d711 1
a711 1
    indexWithinQuantity=0
d715 1
a715 1
        indexWithinQuantity=i
d718 1
a718 1
    if ( indexWithinQuantity /= 0 ) &
d720 2
a721 1
      &   vector%quantities(indexWithinQuantity)
d1116 3
@


2.33
log
@Minor bug fix in GetVectorQuantityByType
@
text
@d53 1
a53 1
       "$Id: VectorsModule.f90,v 2.32 2001/04/28 07:04:32 livesey Exp $"
d674 2
d684 7
a690 10
      ! Can only get here if not found in first vector and 
      ! otherVector is present
      index = GetVectorQuantityIndexByType ( otherVector, &
        &  quantityType, molecule, instrumentModule, radiometer, signal, sideband, &
        &  noError=myNoError )
      if ( present (foundInFirst) ) foundInFirst = .false.
      if ( index /= 0 ) then
        GetVectorQuantityByType => otherVector%quantities( index )
      else ! can only get here when myNoError=T
        GetVectorQuantityByType => NULL()
d1114 3
@


2.32
log
@Minor bug fix
@
text
@d53 1
a53 1
       "$Id: VectorsModule.f90,v 2.31 2001/04/28 01:48:52 vsnyder Exp $"
d677 1
a677 1
      &   noError = present(otherVector) )
d1115 3
@


2.31
log
@Improve dump
@
text
@d53 1
a53 1
       "$Id: VectorsModule.f90,v 2.30 2001/04/28 01:27:38 livesey Exp $"
d579 1
a579 1
        if ( details > 0 ) then
d1115 3
@


2.30
log
@Quite an important change here.  Contents of VectorTemplate_T, VectorValue_T
are now copies of their original entries from databases, not pointers.
@
text
@d53 1
a53 1
       "$Id: VectorsModule.f90,v 2.29 2001/04/25 21:57:07 livesey Exp $"
d559 1
a559 1
      call output ( ': ' )
d574 1
a574 1
          call output ( ' Quantity_Template_Name = ' )
d577 10
a586 4
        call output ( ' Quantity_Template_ID = ' )
        call output ( vectors(i)%quantities(j)%template%id, advance='yes' )
        if ( details > 0 ) &
          & call dump ( vectors(i)%quantities(j)%values, '      Elements = ' )
d1115 4
@


2.29
log
@Removed insulate vector (that didn't last very long :-( )
@
text
@d53 1
a53 1
       "$Id: VectorsModule.f90,v 2.28 2001/04/25 20:15:23 livesey Exp $"
d80 1
a80 2
    type (QuantityTemplate_T), pointer :: TEMPLATE => NULL() ! Template for
    ! this quantity.
d99 1
a99 2
    type (VectorTemplate_T), pointer :: TEMPLATE => NULL() ! In the template
    ! database
d203 1
a203 1
    z%template => x%template
d271 1
a271 1
    z%template => x%template
d277 1
a277 1
      z%quantities(i)%template => x%quantities(i)%template
d402 1
a402 1
    vector%template => vectorTemplate
d408 1
a408 1
      vector%quantities(quantity)%template => &
d449 1
a449 1
    nullify ( vector%template )
d1109 3
@


2.28
log
@Tidied up InsulateVector
@
text
@d53 1
a53 1
       "$Id: VectorsModule.f90,v 2.27 2001/04/25 01:35:01 vsnyder Exp $"
a817 151
  !-------------------------------------------- InsulteVector ----------
  subroutine InsulateVector ( vector )
    ! Take all the pointers in vector and ensure they are deep copies
    ! This is useful when filling l2pc_t's and other stuff you want to
    ! survive the destruction of the vector, vectortemplate, and
    ! quantitytemplate databases.

    ! Note that the onus is then on the owner of `vector' to ensure
    ! that it is all tidied up properly

    ! Dummy arguments
    type (Vector_T), intent(inout) :: vector

    ! Local variables
    real (r8), dimension(:), pointer :: r1 ! Temporary 1D real
    real (r8), dimension(:,:), pointer :: r2 ! Temporary 2D real
    real (r8), dimension(:,:,:), pointer :: r3 ! Temporary 3D real
    integer, dimension(:), pointer :: i1 ! Temporary 1D integer
    logical, dimension(:), pointer :: l1 ! Temporary 1D logical

    integer :: NOINSTANCESTOALLOCATE    ! noInstances or 1 if coherent
    integer :: NOSURFSTOALLOCATE        ! noSurfs or 1 if stacked
    integer :: QTYIND                   ! loop counter
    integer :: STATUS                   ! A flag
    
    type (VectorValue_T), pointer :: q,nq ! A quantity in new and old space
    type (VectorValue_T), dimension(:), pointer :: newQuantities ! To be filled
    type (QuantityTemplate_T), pointer :: qt, nqt ! A quantity template in new and old
    type (VectorTemplate_T), pointer :: newTemplate

    ! Executable code

    ! Make a new template and copy old one
    allocate ( newTemplate, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'newTemplate')
    newTemplate = vector%template
    ! Do quantities field in template
    allocate ( newTemplate%quantities(size(vector%quantities)), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'newTemplate%quantities')
    newTemplate%quantities = vector%template%quantities
    vector%template => newTemplate

    ! Make a new quantities, and copy old one
    allocate ( newQuantities(size(vector%quantities)), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'newQuantities')
    if (status /= 0) call MLSMessage(MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'newQuantities')
    ! Go through quantity by quantity
    do qtyInd = 1, size(vector%quantities)
      q => vector%quantities(qtyInd)
      nq => newQuantities(qtyInd)
      allocate( nq%template, STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'nq%template')
      call Allocate_test ( nq%values, &
        & q%template%instanceLen, q%template%noInstances,&
        & 'nq%values', ModuleName)
      nq%values = q%values
      nullify(nq%mask)
      if (associated(q%mask)) then
        call Allocate_test ( nq%mask, &
          & q%template%instanceLen, q%template%noInstances,&
          & 'nq%mask', ModuleName)
        nq%mask = q%mask
      end if
      qt => q%template
      nqt => nq%template
      nqt = qt

      if ( qt%coherent ) then 
        noInstancesToAllocate = 1
      else
        noInstancesToAllocate = qt%noInstances
      end if
      if ( qt%stacked ) then
        noSurfsToAllocate = 1
      else
        noSurfsToAllocate = qt%noSurfs
      end if
      nullify(nqt%surfs)                ! Avoid clobbering parent
      call allocate_test ( nqt%surfs, nqt%noSurfs, noInstancesToAllocate, &
        & "nqt%surfs", ModuleName )
      nqt%surfs = qt%surfs

      nullify ( nqt%phi )               ! Avoid clobbering parent
      ! Now the horizontal coordinates
      call allocate_test ( nqt%phi, noSurfsToAllocate, nqt%noInstances, &
        & "nqt%phi", ModuleName )
      nqt%phi = qt%phi

      nullify ( nqt%geodLat )           ! Avoid clobbering parent
      call allocate_test ( nqt%geodLat, noSurfsToAllocate, nqt%noInstances, &
        & "nqt%geodLat", ModuleName )
      nqt%geodLat= qt%geodLat

      nullify ( nqt%lon)                ! Avoid clobbering parent
      call allocate_test ( nqt%lon, noSurfsToAllocate, nqt%noInstances, &
        & "nqt%lon", ModuleName )
      nqt%lon = qt%lon

      nullify ( nqt%time )           ! Avoid clobbering parent
      call allocate_test ( nqt%time, noSurfsToAllocate, nqt%noInstances, &
        & "nqt%time", ModuleName )
      nqt%time = qt%time

      nullify ( nqt%solarTime )           ! Avoid clobbering parent
      call allocate_test ( nqt%solarTime, noSurfsToAllocate, nqt%noInstances, &
        & "nqt%solarTime", ModuleName )
      nqt%solarTime = qt%solarTime

      nullify ( nqt%solarZenith )           ! Avoid clobbering parent
      call allocate_test ( nqt%solarZenith, noSurfsToAllocate, nqt%noInstances, &
        & "nqt%solarZenith", ModuleName )
      nqt%solarZenith = qt%solarZenith

      nullify ( nqt%losAngle )           ! Avoid clobbering parent
      call allocate_test ( nqt%losAngle, noSurfsToAllocate, nqt%noInstances, &
        & "nqt%losAngle", ModuleName )
      nqt%losAngle = qt%losAngle
      
      ! Now some other stuff to allocate
      if ( nqt%minorFrame ) then
        nullify ( nqt%MAFIndex )           ! Avoid clobbering parent
        call allocate_test ( nqt%MAFIndex, nqt%noInstances, &
          & "nqt%MAFIndex", ModuleName )
        nqt%MAFIndex = qt%mafIndex
        nullify ( nqt%MAFCounter )           ! Avoid clobbering parent
        call allocate_test ( nqt%MAFCounter, nqt%noInstances, &
          & "nqt%MAFCounter", ModuleName )
        nqt%MAFCounter = qt%MAFCounter
      else
        nullify ( nqt%MAFIndex, nqt%MAFCounter )
      end if

      if (.NOT. nqt%regular) then
        call allocate_test ( nqt%surfIndex, nqt%instanceLen, nqt%noInstances, &
          & "nqt%surfIndex", ModuleName )
        nqt%surfIndex = qt%surfIndex
        call allocate_test ( nqt%chanIndex, nqt%instanceLen, nqt%noInstances, &
          & "nqt%chanIndex", ModuleName )
        nqt%chanIndex = qt%chanIndex
      else
        nullify ( nqt%surfIndex, nqt%chanIndex )
      end if
    end do
    vector%quantities => newQuantities
  end subroutine InsulateVector

d1111 3
@


2.27
log
@Assignment should have been pointer assignment in CloneVector
@
text
@d53 1
a53 1
       "$Id: VectorsModule.f90,v 2.26 2001/04/25 01:24:54 vsnyder Exp $"
d866 2
d872 3
a874 1
      
d876 1
a876 1
        & nq%template%instanceLen, nq%template%noInstances,&
d879 1
a879 1

d882 1
a882 1
          & nq%template%instanceLen, nq%template%noInstances,&
a885 1

d888 1
a894 1
      
d900 1
a900 1

d905 1
d910 2
d915 2
d920 2
d925 2
d930 2
d935 2
d943 1
d947 1
d1262 3
@


2.26
log
@Give initial values to 'name' fields
@
text
@d53 1
a53 1
       "$Id: $"
d56 1
a56 1
       "$RCSfile: $"
d273 1
a273 1
    z%template = x%template
d1244 3
@


2.25
log
@Added insulate vector
@
text
@d51 7
a57 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=130), private :: Id = &
    & "$Id: VectorsModule.f90,v 2.24 2001/04/20 00:07:15 livesey Exp $"
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: VectorsModule.f90,v $"
  !---------------------------------------------------------------------------
d64 2
a65 2
    integer :: Id              ! Id code for vector (for checking purposes)
    integer :: Name            ! Sub-rosa index of name, if any, else zero
d99 1
a99 1
    integer :: Name            ! Sub-rosa index of the vector name
d1244 3
@


2.24
log
@Added the index field to vectorvalue_t
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.23 2001/04/18 23:27:00 pwagner Exp $"
d817 133
d1243 3
@


2.23
log
@Added default .true. to Validate; also optional sayWhyNot
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.22 2001/04/12 21:43:19 livesey Exp $"
d81 1
d276 1
d408 1
d652 5
a656 5
    integer, intent(in), optional :: MOLECULE     ! Molecule index (l_...)
    integer, intent(in), optional :: INSTRUMENTMODULE ! Instrument module index
    integer, intent(in), optional :: RADIOMETER   ! Radiometer index
    integer, intent(in), optional :: SIGNAL       ! Signal index
    integer, intent(in), optional :: SIDEBAND ! -1, 0, +1
d658 1
a658 1
    logical, intent(in), optional :: NOERROR ! Don't give error if not found
d1110 3
@


2.22
log
@Added sideband option to the quantity searches
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.21 2001/04/10 22:38:20 vsnyder Exp $"
d946 1
a946 1
    & noInstances, quantityType, molecule)
d960 1
d967 2
d972 7
d986 7
d1000 7
d1014 7
d1027 7
d1039 7
d1051 7
d1063 7
d1075 7
d1107 3
@


2.21
log
@Add 'details' argument to dump routines
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.20 2001/03/21 02:14:37 livesey Exp $"
d635 2
a636 1
    & molecule, instrumentModule, radiometer, signal, foundInFirst, noError )
d653 1
d655 1
a655 1
    logical, intent(in), optional :: noError ! Don't give error if not found
d668 1
a668 1
      & quantityType, molecule, instrumentModule, radiometer, signal, &
d677 1
a677 1
        &  quantityType, molecule, instrumentModule, radiometer, signal,&
d745 1
a745 1
    & molecule, instrumentModule, radiometer, signal, noError )
d760 1
d789 4
d1041 3
@


2.20
log
@Add noError argument to GetVectorQtyByType
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.19 2001/03/19 17:10:47 livesey Exp $"
d545 1
a545 1
  subroutine DUMP_VECTORS ( VECTORS )
d547 6
a552 1
    integer :: I, J
d577 2
a578 1
        call dump ( vectors(i)%quantities(j)%values, '      Elements = ' )
d584 1
a584 1
  subroutine DUMP_VECTOR_TEMPLATES ( VECTOR_TEMPLATES )
d586 6
a591 1
    integer :: I
d608 2
a609 1
      call dump ( vector_templates(i)%quantities, '      Quantities = ' )
d1034 3
@


2.19
log
@Added more options to validate vector quantity
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.18 2001/03/16 18:17:49 livesey Exp $"
d623 1
a623 1
    & molecule, instrumentModule, radiometer, signal, foundInFirst )
d641 1
d647 4
d663 2
a664 1
        &  quantityType, molecule, instrumentModule, radiometer, signal )
d666 5
a670 1
      GetVectorQuantityByType => otherVector%quantities( index )
d1022 3
@


2.18
log
@Added second vector argument and more conditions to GetVectorQuantityByType
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.17 2001/03/05 00:53:59 livesey Exp $"
d916 2
a917 1
    & minorFrame, verticalCoordinate, quantityType, molecule)
d927 2
d970 10
d1012 3
@


2.17
log
@Added molecule argument to ValidateVectorQuantity
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.16 2001/03/03 00:07:01 livesey Exp $"
d622 2
a623 2
  function GetVectorQuantityByType ( vector, quantityType, &
    & molecule, radiometer )
d625 6
a630 4
  ! Given a quantity type index (l_...), this function returns the first
  ! quantity within the vector that has that type.  If molecule and/or
  ! radiometer are supplied, the quantity that has the specified type, as
  ! well as the specified molecule and/or radiometer index, is returned.
d633 8
a640 4
    type (Vector_T), intent(in) :: Vector
    integer, intent(in) :: QuantityType ! Quantity type index (l_...)
    integer, intent(in), optional :: Molecule     ! Molecule index (l_...)
    integer, intent(in), optional :: Radiometer   ! Radiometer index
d644 18
a661 2
    GetVectorQuantityByType => vector%quantities( getVectorQuantityIndexByType &
      & ( vector, quantityType, molecule, radiometer ) )
d721 1
a721 1
    & molecule, radiometer )
d730 7
a736 4
    type (Vector_T), intent(in) :: Vector
    integer, intent(in) :: QuantityType ! Quantity type index (l_...)
    integer, intent(in), optional :: Molecule     ! Molecule index (l_...)
    integer, intent(in), optional :: Radiometer   ! Radiometer index
d740 5
a744 1
    integer :: Search
d752 4
d760 4
d768 4
a771 3
    msg = 'There is no quantity in vector '
    if ( vector%name /= 0 ) then
      call get_string ( vector%name, msg(len_trim(msg)+2:) )
d773 8
a780 1
      msg(len_trim(msg)+2:) = '[unnamed]'
a781 2
    msg = trim(msg) // ' that has the required type'
    call MLSMessage ( MLSMSG_Error, ModuleName, msg(:len_trim(msg)) )
d999 3
@


2.16
log
@Added GetVectorQtyByTemplateIndex
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.15 2001/02/28 17:34:25 livesey Exp $"
d873 1
a873 1
    & minorFrame, verticalCoordinate, quantityType)
d884 1
d929 5
d956 3
@


2.15
log
@Added minorFrame optional argument to ValidateVectorQuantity
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.14 2001/02/27 17:18:53 livesey Exp $"
d642 27
d950 3
@


2.14
log
@Added ValidateVectorQuantity
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.13 2001/02/21 21:50:38 livesey Exp $"
d846 1
a846 1
    & verticalCoordinate, quantityType)
d849 5
a853 4
    type (VectorValue_T), intent(IN) :: quantity ! Test quantity
    logical, optional, intent(IN) :: coherent ! .TRUE.,.FALSE. or not present
    logical, optional, intent(IN) :: stacked  ! .TRUE.,.FALSE. or not present
    logical, optional, intent(IN) :: regular ! .TRUE.,.FALSE. or not present
d855 2
a856 2
    integer, optional, dimension(:), intent(IN) :: verticalCoordinate
    integer, optional, dimension(:), intent(IN) :: quantityType
d884 7
d923 3
@


2.13
log
@Added a line to zero out a vector on creation.  Kind of like using training
wheels in a bicycle, but avoids painful core dumps when trying to output
unfilled vectors.
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.12 2001/02/09 00:38:56 livesey Exp $"
d840 55
d915 5
@


2.12
log
@Various changes
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.11 2001/02/08 00:36:29 vsnyder Exp $"
d851 1
d860 3
@


2.11
log
@Don't destroy in DestroyVectorValues if vector%quantities is disassociated
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.10 2001/02/08 00:34:41 vsnyder Exp $"
d697 1
a697 1
          if ( vector%quantities(search)%template%radiometerIndex /= &
d859 3
@


2.10
log
@Don't destroy in DestroyVectorInfo if vector%quantities is disassociated
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.9 2001/01/26 19:00:02 vsnyder Exp $"
d520 1
d859 3
@


2.9
log
@Periodic commit
@
text
@d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.8 2001/01/19 23:49:59 vsnyder Exp $"
d384 1
a384 1
    & ( vectorName, vectorTemplate, quantities ) result (vector )
d448 1
d704 5
a708 1
    call get_string ( vector%name, msg(len_trim(msg)+2:) )
d858 3
@


2.8
log
@Periodic commit
@
text
@a43 1
    module procedure MultiplyVectors ! element-by-element
d53 1
a53 1
    & "$Id: VectorsModule.f90,v 2.7 2001/01/10 21:03:14 vsnyder Exp $"
d71 2
a72 2
    integer, dimension(:), pointer :: QUANTITIES  ! Indices of the quantity
    !                            templates in the quantities database
d79 11
a89 9
    type (QuantityTemplate_T), pointer :: TEMPLATE ! Template for this quantity
    ! The dimensions of VALUES are Frequencies (or 1) * Vertical Coordinates
    ! (or 1), and Horizontal Instances (scan or profile or 1).  These are
    ! taken from (template%noChans * template%noSurfs, template%noInstances).
    real(r8), dimension(:,:), pointer :: VALUES => NULL()
    ! MASK is used to control whether elements of vectors are of interest.
    ! If MASK is not associated, every element is of interest.  Otherwise,the
    ! dimensions of MASK are (size(values,1)+bit_size(mask)-1)/bit_size(mask)
    ! and size(values,2).  Bits of MASK are used to determine what is not
a91 1
    integer, dimension(:,:), pointer :: MASK => NULL()
d98 6
a103 7
    type (VectorTemplate_T), pointer :: TEMPLATE ! In the template database

    ! The dimension of QUANTITIES is the same as for the QUANTITIES field
    ! of the vector template.  Each element of QUANTITIES here corresponds
    ! to the one in the same position in the QUANTITIES field of the
    ! vector template.
    type (VectorValue_T), dimension(:), pointer :: QUANTITIES
d442 1
a442 1
    integer :: I, STATUS
d448 1
a448 4
    do i = 1, size(vector%quantities)
      call deallocate_test ( vector%quantities(i)%values, &
        & "vector%quantities(i)%values", ModuleName )
    end do
d492 1
a492 1
  subroutine DestroyVectorTemplateInfo ( vectorTemplate )
d511 14
d710 3
a712 9
  type (Vector_T) function MultiplyVectors ( X, Y ) result (Z)
  ! Multiply two vectors element-by-element, producing one having the
  ! same template (but no name, of course).

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyVectorInfo using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignVector.
  ! !!!!! ===== END NOTE ===== !!!!! 
d715 3
a717 1
    type(Vector_T), intent(in) :: X, Y
d719 2
a720 1
    integer :: I              ! Subscript and loop inductor
d724 6
a729 1
    call CloneVector ( z, x )
d731 2
a732 1
      z%quantities(i)%values = x%quantities(i)%values * y%quantities(i)%values
d734 1
a734 1
  end function MultiplyVectors
d778 1
a778 1
  subroutine SubtractFromVector ( X, Y ) ! X = X - Y.
d783 5
d793 15
a807 3
    do i = 1, size(x%quantities)
      x%quantities(i)%values = x%quantities(i)%values - y%quantities(i)%values
    end do
d853 3
@


2.7
log
@Periodic commit
@
text
@d54 1
a54 1
    & "$Id: VectorsModule.f90,v 2.6 2001/01/03 02:01:30 vsnyder Exp $"
d609 1
a609 1
  ! ------------------------------------  GetVectorQuantityByName  -----
d823 3
@


2.6
log
@Add molecule/radiometer functionality to GetVectorQuantityIndexByType
@
text
@d45 1
a45 1
    module procedure ScaleVector     ! by a scalar on the left
d54 1
a54 1
    & "$Id: VectorsModule.f90,v 2.5 2000/12/04 23:43:59 vsnyder Exp $"
d82 2
a83 1
    ! (or 1), and Horizontal Instances (scan or profile or 1).
d114 2
d118 15
d260 3
a262 3
  ! It is important to invoke DestroyVectorInfo using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignVector.
d286 23
d350 4
a353 2
  subroutine CopyVector ( Z, X )   ! Destroy Z, deep Z = X, except the name
  !                                  of Z is not changed
d356 1
d358 9
a366 1
    call cloneVector ( Z, X )
d609 21
d724 2
a725 9
  type (Vector_T) function ScaleVector ( A, X ) result (Z)
  ! Multiply the vector X by A, producing one having the same template
  ! (but no name, of course).

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyVectorInfo using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignVector.
  ! !!!!! ===== END NOTE ===== !!!!! 
d728 1
d730 1
a730 1
    type(Vector_T), intent(in) :: X
d733 1
d735 6
a740 1
    call CloneVector ( z, x )
d744 1
a744 1
  end function ScaleVector
d764 16
d797 1
a797 1
        & ModuleName, "Cannot add vectors having different templates" )
d823 3
@


2.5
log
@Move more of addItemToDatabase into the include
@
text
@d54 1
a54 1
    & "$Id: VectorsModule.f90,v 2.4 2000/11/23 01:10:27 vsnyder Exp $"
d360 1
d406 16
d538 1
a538 1
  function GetVectorQuantity ( vector, quantity, quantityIsName )
d545 1
a545 5
    integer, intent(in) :: Quantity                 ! Quantity index or name
    ! If a Quantity index, it indexes the Quantities field of Vector_T,
    ! not the quantities data base (which we don't have access to here,
    ! anyway).
    logical, intent(in), optional :: quantityIsName ! Quantity is Sub-rosa
d550 17
d572 3
a574 5
    if ( present(quantityIsName) ) then
      if ( quantityIsName ) then
        do search = 1, size(vector%quantities)
          if ( quantity == vector%quantities(search)%template%name ) then
            GetVectorQuantity => vector%quantities(search)
a575 6
          end if
        end do
        call get_string ( quantity, msg )
        msg(string_length(quantity)+2:) = 'is not a quantity in vector'
        call get_string ( vector%name, msg(len_trim(msg)+2:) )
        call MLSMessage ( MLSMSG_Error, ModuleName, msg(:len_trim(msg)) )
d577 27
a603 1
    end if
d605 18
a622 4
    if ( quantity < 1 .or. quantity > size(vector%quantities) ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & '"Quantity" is out of range as a subscript for "vector%quantities".' )
    GetVectorQuantity => vector%quantities(quantity)
d624 1
a624 1
  end function GetVectorQuantity
d734 3
@


2.4
log
@Add "mask" field to specify columns to ignore when vector is row- or
column-specifier for a matrix.
@
text
@d53 2
a54 2
  character (len=256), private :: Id = &
    & "$Id: VectorsModule.f90,v 2.3 2000/11/15 01:33:58 vsnyder Exp $"
a153 1
    database(newSize) = item
a171 1
    database(newSize) = item
d613 2
a614 1
  ! Set bits of MASK indexed by elements of TO_CLEAR.
d616 1
a616 1
    integer, intent(in), dimension(:) :: TO_SET
d618 9
a626 5
    do i = 1, size(to_set)
      w = to_set(i) / b
      p = mod(to_set(i), b)
      mask(w+1) = ibset(mask(w+1),p)
    end do
d672 4
@


2.3
log
@Added copyVector, assignment(=)
@
text
@d54 1
a54 1
    & "$Id: VectorsModule.f90,v 2.2 2000/11/10 00:24:24 vsnyder Exp $"
d84 7
d110 3
d218 18
d241 1
a241 1
  ! filled.
d264 4
d319 2
d324 9
d338 1
d613 13
d652 1
a652 2
  ! Allocate space for the values of a vector.  Create rank-3 views of
  ! the values for each of the quantities.
d669 3
@


2.2
log
@Changed VectorValue_t%values from rank-3 to rank-2
@
text
@d27 4
d54 1
a54 1
    & "$Id: VectorsModule.f90,v 2.1 2000/10/13 00:00:37 vsnyder Exp $"
d113 1
a113 1
  ! result.
d167 15
d190 1
a190 1
  ! result.
d210 1
d218 1
a218 1
  ! result.
d222 1
a222 1
    type(Vector_T), intent(out) :: Z
d227 1
a227 1
    z%name = 0
d278 12
a317 1

d352 2
d394 2
a395 6
    ! Local Variables:
    integer :: STATUS

    deallocate ( vectorTemplate%quantities, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & MLSMSG_deallocate // "vectorTemplate%quantities" )
d530 1
a530 1
  ! result.
d554 1
a554 1
  ! result.
d577 1
a577 1
  ! result.
d613 3
@


2.1
log
@Moved from mlspgs/l2 to mlspgs/lib
@
text
@d35 4
d50 1
a50 1
    & "$Id: VectorsModule.f90,v 2.0 2000/09/05 18:57:05 ahanzel Exp $"
d68 2
a69 6
    integer, dimension(:), pointer :: Starts ! Where the quantities' values
      ! start in the rank-one quantity vector -- see Vector_T below.

    ! Indices of the quantity templates in the quantities database

    integer, dimension(:), pointer :: QUANTITIES
d77 3
a79 5
    ! The dimensions of VALUES are Frequencies (or 1), Vertical Coordinates
    ! (or 1), and Horizontal Instances (scan or profile or 1).  The target of
    ! VALUES is the appropriate piece of the VALUES field of the containing
    ! object of type Vector_T.
    real(r8), dimension(:,:,:), pointer :: VALUES => NULL()
d87 1
a87 10
    ! There is a subterfuge going on here.  We allocate VALUES, and then
    ! take pointers to pieces of it as QUANTITIES%VALUES.  This seems to
    ! be impossible, because VALUES is rank 1, but QUANTITIES%VALUES are
    ! rank 3.  We do this by way of an external subroutine, GET_3D_VIEW,
    ! that is declared here to have a rank-1 first argument, but is declared
    ! within itself to have a rank-3 first argument.  That is WE LIE.  This
    ! is OK, because rank-1 vectors are required to be stored contiguously.
    ! This all worked in Fortran 77.  Hopefully, Fortran will someday have
    ! a straightforward way to take a rank-3 view of a rank-1 vector.
    real(r8), dimension(:), pointer :: VALUES => NULL()
d90 1
a90 1
    ! to the one in the same position of the QUANTITIES field of the
a98 9
  interface 
    subroutine GET_3D_VIEW ( Input, I1, I2, I3, Output )
      use MLSCommon, only: R8
      integer, intent(in) :: I1, I2, I3
      real(r8), intent(in), target :: Input(*)
      real(r8), pointer :: Output(:,:,:)
    end subroutine GET_3D_VIEW
  end interface

d114 2
a115 2
    ! Local variables:
    integer :: I, Status
d120 3
a122 1
    z%values = x%values + y%values
d178 1
a178 1
    integer :: I, Status
d183 4
a186 1
    z%values = a * x%values + y%values
d233 1
a233 1
    integer :: qty, status
a237 8
    call allocate_test ( vectorTemplate%starts, vectorTemplate%noQuantities, &
      & "vectorTemplate%starts", ModuleName )
    vectorTemplate%starts(1) = 1
    do qty = 1, vectorTemplate%noQuantities - 1
      vectorTemplate%starts(qty+1) = vectorTemplate%starts(qty) + &
        & quantities(selected(qty))%noInstances * &
        & quantities(selected(qty))%instanceLen
    end do
d309 1
a309 1
  subroutine DestroyVectorInfo ( vector )
d316 2
a317 2
    ! Local Variables
    integer :: I, Status
d321 4
a324 1
    call deallocate_test ( vector%values, "vector%values", ModuleName )
d359 1
a359 2
    ! Local variables
    integer :: QTY, STATUS
d361 2
a362 1
    ! Executable code
d382 1
a382 1
    integer :: I, K, L
d386 4
a389 1
    z = dot_product(x%values,y%values)
d428 1
a428 1
    integer :: I, J
d476 1
d506 2
a507 2
    ! Local variables:
    integer :: I, Status
d512 3
a514 1
    z%values = x%values * y%values
d531 2
a532 2
    ! Local variables:
    integer :: I, Status
d535 3
a537 1
    z%values = a * x%values
d540 24
a569 2
    call allocate_test ( vector%values, vector%template%totalElements, &
      & "vector%values", ModuleName )
d571 2
a572 2
      call get_3d_view ( vector%values(vector%template%starts(qty):), &
        & vector%quantities(qty)%template%noChans, &
d575 1
a575 1
        & vector%quantities(qty)%values )
d584 3
@


1.12
log
@moved to mlspgs/l2
@
text
@d1 1
a1 1
!Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS  RESERVED.
d5 1
a5 1
MODULE VectorsModule            ! Vectors in the MLS PGS suite
a7 12
  USE MLSMessageModule
  USE QuantityTemplates

  IMPLICIT NONE

  PRIVATE :: Id, ModuleName
  !---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
       "$Id: VectorsModule.f90,v 1.11 2000/06/19 23:19:43 lungu Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: VectorsModule.f90,v $"
  !---------------------------------------------------------------------------

d13 30
a42 2
  ! This datatype describes how the subVectors of a quantity are laid out
  ! within a vector
d44 6
a49 3
  TYPE QuantityLayout_T
     INTEGER, DIMENSION(:), POINTER :: entry ! (quantityTemplate%noSubVectors)
  END TYPE QuantityLayout_T
d51 1
a51 1
  ! This datatype describes a vector template
d53 52
a104 1
  INTEGER, PARAMETER :: VectorNameLen=80
d106 1
a106 5
  TYPE VectorTemplate_T
     
     ! First some administrative stuff
     CHARACTER (LEN=VectorNameLen) :: name ! Name for the vector template
     INTEGER :: id              ! Id code for vector (for checking purposes)
d108 1
a108 1
     ! Now general information about the vector
d110 32
a141 3
     INTEGER :: noQuantities    ! Number of quantities in the vector
     INTEGER :: noSubVectors    ! Number of subvectors in the vector
     INTEGER :: totalElements   ! Total of numbers of elements in the vector
d143 2
a144 1
     ! Now we describe the ordering of the subvectors in the vector
d146 2
a147 4
     INTEGER, DIMENSION(:), POINTER :: subVectorNoElements ! (noSubVectors)
     INTEGER, DIMENSION(:), POINTER :: subVectorFirstElement ! (noSubVectors)
     INTEGER, DIMENSION(:), POINTER :: subVectorQuantityNo ! (noSubVectors)
     INTEGER, DIMENSION(:), POINTER :: subVectorProfileNo ! (noSubVectors)
d149 3
a151 1
     ! Now a `reverse' form of this information for each quantity
d153 2
a154 1
     TYPE (QuantityLayout_T), DIMENSION(:), POINTER :: layout ! (noQuantities)
d156 1
a156 1
     ! Now point to the quantity templates themselves
d158 3
a160 2
     TYPE (QuantityTemplate_T), DIMENSION(:), POINTER :: quantities
  END TYPE VectorTemplate_T
d162 2
a163 1
  ! This datatype is a vector itself
d165 2
a166 5
  TYPE Vector_T
     CHARACTER (LEN=VectorNameLen) :: name ! Name for vector
     TYPE (VectorTemplate_T) :: template ! Copy from template database
     REAL(r8), DIMENSION(:), POINTER :: values
  END TYPE Vector_T
d168 3
a170 1
  ! This incrementing counter is used to set the id field for a vector template
d172 2
a173 1
  INTEGER, PRIVATE :: vectorTemplateCounter=0
d175 1
a175 1
CONTAINS
d177 59
a235 1
  !---------------------------------------------------------------------------
d238 1
a238 1
  ! The default ordering is currently by quantity. Later versions may
a240 2
  SUBROUTINE ConstructVectorTemplate(name,quantities,vectorTemplate)

d242 4
a245 3
    CHARACTER (LEN=*), INTENT(IN) :: name ! Name for vector template
    TYPE (QuantityTemplate_T), DIMENSION(:), INTENT(IN) :: quantities
    TYPE (VectorTemplate_T), INTENT(OUT) :: vectorTemplate
d248 1
a248 2
    INTEGER :: status,qty,subVector,startSubVector
    INTEGER :: accumulatedElements,qtySubVector,subVectorLen
d251 14
a264 5
    vectorTemplate%name=name
    vectorTemplate%noQuantities=SIZE(quantities)
    vectorTemplate%noSubVectors=SUM(quantities%noSubVectors)
    vectorTemplate%totalElements= &
         & SUM(quantities%noSubVectors*quantities%subVectorLen)
d267 4
a270 21
    ALLOCATE(&
         & vectorTemplate%subVectorNoElements(vectorTemplate%noSubVectors), &
         & vectorTemplate%subVectorFirstElement(vectorTemplate%noSubVectors), &
         & vectorTemplate%subVectorQuantityNo(vectorTemplate%noSubVectors), &
         & vectorTemplate%subVectorProfileNo(vectorTemplate%noSubVectors), &
         & vectorTemplate%layout(vectorTemplate%noQuantities), &
         & STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & MLSMSG_Allocate//"Vector information")

    DO qty=1,vectorTemplate%noQuantities
       ALLOCATE(vectorTemplate%layout(qty)%entry(quantities(qty)%noSubVectors),&
            & STAT=status)
       IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
            & MLSMSG_Allocate//"Quantity layout information")
    END DO

    ALLOCATE (vectorTemplate%quantities(vectorTemplate%noQuantities), &
         & STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & MLSMSG_Allocate//"Vector quantities")
d274 1
a274 1
    vectorTemplate%quantities=quantities
d276 8
a283 2
    vectorTemplate%id=vectorTemplateCounter
    vectorTemplateCounter=vectorTemplateCounter+1
d285 1
a285 26
    ! Fill up the mapping information, store by quantity for this version

    startSubVector=0
    accumulatedElements=0
    DO qty=1,vectorTemplate%noQuantities
       subVectorLen=vectorTemplate%quantities(qty)%subVectorLen
       DO qtySubVector=1,vectorTemplate%quantities(qty)%noSubVectors-1
          subVector=qtySubVector+startSubVector

          vectorTemplate%layout(qty)%entry(qtySubVector)=subVector

          vectorTemplate%subVectorNoElements(subVector)=subVectorLen
          vectorTemplate%subVectorFirstElement(subVector)=accumulatedElements
          vectorTemplate%subVectorQuantityNo(subVector)=qty
          vectorTemplate%subVectorProfileNo(subVector)=qtySubVector

          accumulatedElements=accumulatedElements+subVectorLen
       END DO
    END DO
  END SUBROUTINE ConstructVectorTemplate

  !---------------------------------------------------------------------------

  ! This routine destroys a vector template created above

  SUBROUTINE DestroyVectorTemplateInfo(vectorTemplate)
d288 3
a290 1
    TYPE (VectorTemplate_T), INTENT(INOUT) :: vectorTemplate
d293 2
a294 1
    INTEGER :: qty, status
d298 11
a308 31
    DEALLOCATE (&
         & vectorTemplate%subVectorNoElements, &
         & vectorTemplate%subVectorFirstElement, &
         & vectorTemplate%subVectorQuantityNo, &
         & vectorTemplate%subVectorProfileNo, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"vectorTemplate%subVector")

    DO qty=1,vectorTemplate%noQuantities
       DEALLOCATE(vectorTemplate%layout(qty)%entry, STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"vectorTemplate%layout(qty)%entry")
    END DO
    DEALLOCATE(vectorTemplate%layout, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"vectorTemplate%layout")
    DEALLOCATE(vectorTemplate%quantities, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"vectorTemplate%quantities")
    
    vectorTemplate%noQuantities=0
    vectorTemplate%noSubVectors=0
    vectorTemplate%totalElements=0
    vectorTemplate%name=''
    vectorTemplate%id=0
  END SUBROUTINE DestroyVectorTemplateInfo

  !---------------------------------------------------------------------------

  ! This routine adds a vector template to a database of such templates, 
  ! creating the database if necessary.
d310 2
a311 1
  SUBROUTINE AddVectorTemplateToDatabase(database,vectorTemplate)
d313 1
a313 37
    ! Dummy arguments
    TYPE (VectorTemplate_T), DIMENSION(:), POINTER :: database
    TYPE (VectorTemplate_T), INTENT(IN) :: vectorTemplate

    ! Local variables
    TYPE (VectorTemplate_T), DIMENSION(:), POINTER :: tempDatabase
    INTEGER :: newSize,status

    ! Executable code

    IF (ASSOCIATED(database)) THEN
       ! Check we don't already have one of this name
       IF (LinearSearchStringArray(database%name,vectorTemplate%name, &
            & caseInsensitive=.TRUE.)/=0) CALL MLSMessage(MLSMSG_Error,&
            & ModuleName,MLSMSG_Duplicate//vectorTemplate%name)
       newSize=SIZE(database)+1
    ELSE
       newSize=1
    ENDIF

    ALLOCATE(tempDatabase(newSize),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Allocation failed for tempDatabase")

    IF (newSize>1) tempDatabase(1:newSize-1)=database
    tempDatabase(newSize)=vectorTemplate
    IF (ASSOCIATED(database))DEALLOCATE(database, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"database")
    database=>tempDatabase
  END SUBROUTINE AddVectorTemplateToDatabase

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a vector template database

  SUBROUTINE DestroyVectorTemplateDatabase(database)
d316 1
a316 1
    TYPE (VectorTemplate_T), DIMENSION(:), POINTER :: database
d319 1
a319 1
    INTEGER :: l2gpIndex, status
d321 9
a329 9
    IF (ASSOCIATED(database)) THEN
       DO l2gpIndex=1,SIZE(database)
          CALL DestroyVectorTemplateInfo(database(l2gpIndex))
       ENDDO
       DEALLOCATE(database, STAT=status)
       IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"database")
    ENDIF
  END SUBROUTINE DestroyVectorTemplateDatabase
d331 2
a332 1
  ! --------------------------------------------------------------------------
d334 1
a334 4
  ! Now, having dealt with the templates, let's move onto the vectors
  ! This routine creates an empty vector according to a given template

  SUBROUTINE CreateVector(name,vectorTemplate,vector)
d337 1
a337 15
    CHARACTER (LEN=*), INTENT(IN) :: name   ! Name for vector
    TYPE (VectorTemplate_T), INTENT(IN) :: vectorTemplate ! Template for vector
    TYPE (Vector_T), INTENT(OUT) :: vector

    ! Local variables
    INTEGER :: status, i

    ! Executable code

    vector%name=name
    vector%template=vectorTemplate
    ALLOCATE(vector%values(vectorTemplate%totalElements),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & MLSMSG_Allocate//"Vector values")
  END SUBROUTINE CreateVector
a338 8
  ! --------------------------------------------------------------------------
  
  ! This routine destroys a vector created above

  SUBROUTINE DestroyVectorInfo(vector)

    ! Dummy arguments
    TYPE (Vector_T) :: vector
d340 1
a340 22
    INTEGER :: status
    ! Executable code

    DEALLOCATE(vector%values, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"vector%values")
  END SUBROUTINE DestroyVectorInfo

  !---------------------------------------------------------------------------

  ! This routine adds a vector template to a database of such templates, 
  ! creating the database if necessary.

  SUBROUTINE AddVectorToDatabase(database,vector)

    ! Dummy arguments
    TYPE (Vector_T), DIMENSION(:), POINTER :: database
    TYPE (Vector_T), INTENT(IN) :: vector

    ! Local variables
    TYPE (Vector_T), DIMENSION(:), POINTER :: tempDatabase
    INTEGER :: newSize,status
d344 5
a348 21
    IF (ASSOCIATED(database)) THEN
       ! Check we don't already have one of this name
       IF (LinearSearchStringArray(database%name,vector%name, &
            & caseInsensitive=.TRUE.)/=0) CALL MLSMessage(MLSMSG_Error,&
            & ModuleName,MLSMSG_Duplicate//vector%name)
       newSize=SIZE(database)+1
    ELSE
       newSize=1
    ENDIF

    ALLOCATE(tempDatabase(newSize),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Allocation failed for tempDatabase")

    IF (newSize>1) tempDatabase(1:newSize-1)=database
    tempDatabase(newSize)=vector
    IF (ASSOCIATED(database))DEALLOCATE(database, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"database")
    database=>tempDatabase
  END SUBROUTINE AddVectorToDatabase
d350 2
a351 1
  ! --------------------------------------------------------------------------
d353 1
a353 3
  ! This subroutine destroys a vector database

  SUBROUTINE DestroyVectorDatabase(database)
d356 1
a356 1
    TYPE (Vector_T),  DIMENSION(:), POINTER :: database
d359 1
a359 11
    INTEGER :: l2gpIndex, status

    IF (ASSOCIATED(database)) THEN
       DO l2gpIndex=1,SIZE(database)
          CALL DestroyVectorInfo(database(l2gpIndex))
       ENDDO
       DEALLOCATE(database, STAT=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"database")
    ENDIF
  END SUBROUTINE DestroyVectorDatabase
d361 9
a369 1
  ! --------------------------------------------------------------------------
d371 2
a372 1
  ! This subroutine returns a pointer to a subVector within a vector
d374 1
a374 1
  FUNCTION GetSubVectorPointer(vector,quantity,profile,quantityName)
d377 1
a377 7
    TYPE (Vector_T), INTENT(IN) :: vector
    INTEGER, INTENT(IN), OPTIONAL :: quantity
    INTEGER, INTENT(IN), OPTIONAL :: profile
    CHARACTER (LEN=*), INTENT(IN), OPTIONAL :: quantityName

    ! Result
    REAL(r8), DIMENSION(:), POINTER :: GetSubVectorPointer
d380 1
a380 1
    INTEGER :: useQuantity,useProfile,subVector
a382 31
    IF (PRESENT(quantityName)) THEN
       IF (PRESENT(quantity)) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & "Cannot use both quantity and quantityName in GetSubVectorPointer")
       useQuantity=LinearSearchStringArray(vector%template%quantities%name,&
            & quantityName,caseInsensitive=.TRUE.)
    ELSE
       IF (.NOT. PRESENT(quantity)) CALL MLSMessage(MLSMSG_Error,ModuleName,&
        & "Must supply either quantity or quantityName in GetSubVectorPointer")
       useQuantity=quantity
    END IF

    IF (PRESENT(profile)) THEN
       useProfile=profile
    ELSE
       useProfile=1
    ENDIF

    IF ((useQuantity<1).OR.(useQuantity>vector%template%noQuantities)) &
         & CALL MLSMessage(MLSMSG_Error,ModuleName,"Invalid quantity request")

    IF ((useProfile<1).OR.&
         & (useProfile>vector%template%quantities(useQuantity)%noSubVectors)) &
         & CALL MLSMessage(MLSMSG_Error,ModuleName,"Invalid profile request")

    subVector=vector%template%layout(useQuantity)%entry(useProfile)
    GetSubVectorPointer=> &
         & vector%values(vector%template%subVectorFirstElement(subVector): &
         &   vector%template%subVectorFirstElement(subVector)+ &
         &   vector%template%subVectorNoElements(subVector)-1)
    
  END FUNCTION GetSubVectorPointer
d384 84
a467 1
  ! --------------------------------------------------------------------------
d469 2
a470 3
  ! This function uses the one above, and retuns a 2D array for a subVector
  ! The array defaults to (noChans,noSurfs), but if the firstIndexChannel
  ! flag is set .FALSE., the indices are (noSurfs,noChans)
a471 4
  SUBROUTINE GetSubVectorAs2DArray(vector,TwoDArray,quantity,profile,quantityName,&
       & firstIndexChannel)
  
    
d473 6
a478 5
    TYPE (Vector_T), INTENT(IN) :: vector
    INTEGER, INTENT(IN), OPTIONAL :: quantity
    INTEGER, INTENT(IN), OPTIONAL :: profile
    CHARACTER (LEN=*), INTENT(IN), OPTIONAL :: quantityName
    LOGICAL, INTENT(IN), OPTIONAL :: firstIndexChannel
d481 1
a481 1
    REAL(r8), DIMENSION(:,:), POINTER :: TwoDArray
d484 2
a485 6
    LOGICAL :: useFirstIndexChannel
    REAL(r8), DIMENSION(:), POINTER :: values
    REAL(r8), DIMENSION(:,:), POINTER :: tmpResult
    INTEGER :: useQuantity,useProfile,surf,chan,status
    TYPE (QuantityTemplate_T), POINTER :: qty
    REAL(R8), DIMENSION(1000):: pad
d488 83
a570 48

    IF (PRESENT(firstIndexChannel)) THEN
       useFirstIndexChannel=firstIndexChannel
    ELSE
       useFirstIndexChannel=.TRUE.
    END IF

    IF (PRESENT(quantityName)) THEN
       IF (PRESENT(quantity)) CALL MLSMessage(MLSMSG_Error,ModuleName,&
         & "Cannot use both quantity and quantityName in GetSubVectorPointer")
       useQuantity=LinearSearchStringArray(vector%template%quantities%name,&
            & quantityName,caseInsensitive=.TRUE.)
    ELSE
       IF (.NOT. PRESENT(quantity)) CALL MLSMessage(MLSMSG_Error,ModuleName,&
        & "Must supply either quantity or quantityName in GetSubVectorPointer")
       useQuantity=quantity
    END IF

    IF (PRESENT(profile)) THEN
       useProfile=profile
    ELSE
       useProfile=1
    ENDIF
    values=>GetSubVectorPointer(vector,useQuantity,useProfile)
    qty=>vector%template%quantities(useQuantity)
    
    IF (useFirstIndexChannel) THEN
       ALLOCATE(TwoDArray(qty%noChans,qty%noSurfs),STAT=status)
    ELSE
       ALLOCATE(TwoDArray(qty%noSurfs,qty%noChans),STAT=status)
    END IF
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "TwoDArray")
    IF (useFirstIndexChannel.AND.qty%firstIndexChannel) THEN
       TwoDArray=RESHAPE(values,(/qty%noChans,qty%noSurfs/), pad)
    ELSE IF (useFirstIndexChannel.AND.(.NOT. qty%firstIndexChannel)) THEN
       TwoDArray=TRANSPOSE(RESHAPE(values,(/qty%noSurfs,qty%noChans/), pad))
    ELSE IF ((.NOT. useFirstIndexChannel).AND.(qty%firstIndexChannel)) THEN
       TwoDArray=TRANSPOSE(RESHAPE(values,(/qty%noChans,qty%noSurfs/), pad))
    ELSE
       TwoDArray=RESHAPE(values,(/qty%noSurfs,qty%noChans/), pad)
    END IF
  END SUBROUTINE GetSubVectorAs2DArray
       

!=============================================================================
END MODULE VectorsModule
!=============================================================================
d574 2
a575 36
! Revision 1.11  2000/06/19 23:19:43  lungu
! Made GetSubVectorAs2DArray subroutine.
! Added status check for DEALLOCATE.
!
! Revision 1.10  2000/05/18 00:04:15  lungu
! Added check "IF (ASSOCIATED(database))DEALLOCATE(database)".
!
! Revision 1.9  2000/05/12 19:46:37  lungu
! Removed INTENT from declaration of dummy argument database in DestroyVectorDatabase.
!
! Revision 1.8  2000/04/14 20:27:43  vsnyder
! OOPS -- Replaced unspecified INTENT with INTENT(INOUT) -- see previous rev.
!
! Revision 1.7  2000/04/13 23:45:33  vsnyder
! Removed INTENT(IN) for the argument "vector" of DestroyVectorInfo, for
! which a component was deallocated
!
! Revision 1.6  2000/01/20 01:29:59  livesey
! Added GetSubVectorAs2DArray
!
! Revision 1.5  2000/01/19 18:36:46  livesey
! Sorted out the sub vector layout stuff.  Added the layout element of
! the template, and wrote code to deal with it.  Also wrote
! GetSubVectorPointer
!
! Revision 1.4  1999/12/17 21:43:17  livesey
! Added check for duplicate name
!
! Revision 1.3  1999/12/16 18:32:26  livesey
! Changed do to name change from VectorQuantities to QuantityTemplates
!
! Revision 1.2  1999/12/14 01:01:52  livesey
! Changed DOUBLE PRECISION to REAL(r8)
!
! Revision 1.1  1999/12/04 00:30:18  livesey
! First version.
d577 2
d580 1
@


1.11
log
@Made GetSubVectorAs2DArray subroutine.
Added status check for DEALLOCATE.
@
text
@d16 1
a16 1
       "$Id: VectorsModule.f90,v 1.10 2000/05/18 00:04:15 lungu Exp $"
d488 4
@


1.10
log
@Added check "IF (ASSOCIATED(database))DEALLOCATE(database)".
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d16 1
a16 1
       "$Id: VectorsModule.f90,v 1.9 2000/05/12 19:46:37 lungu Exp $"
a100 1
    
d163 1
a163 1
    INTEGER :: qty
d171 3
a173 1
         & vectorTemplate%subVectorProfileNo)
d176 3
a178 1
       DEALLOCATE(vectorTemplate%layout(qty)%entry)
d180 6
a185 2
    DEALLOCATE(vectorTemplate%layout)
    DEALLOCATE(vectorTemplate%quantities)
d227 3
a229 1
    IF (ASSOCIATED(database))DEALLOCATE(database)
d243 1
a243 1
    INTEGER :: l2gpIndex
d249 3
a251 1
       DEALLOCATE(database)
d268 1
a268 1
    INTEGER :: status
d287 2
a288 1

d291 3
a293 1
    DEALLOCATE(vector%values)
d329 3
a331 1
    IF (ASSOCIATED(database))DEALLOCATE(database)
d345 1
a345 1
    INTEGER :: l2gpIndex
d351 3
a353 1
       DEALLOCATE(database)
d414 1
a414 1
  FUNCTION GetSubVectorAs2DArray(vector,quantity,profile,quantityName,&
d416 1
d426 1
a426 1
    REAL(r8), DIMENSION(:,:), POINTER :: GetSubVectorAs2DArray
d434 1
a459 1

d462 1
a462 1

d464 1
a464 1
       ALLOCATE(tmpResult(qty%noChans,qty%noSurfs),STAT=status)
d466 1
a466 1
       ALLOCATE(tmpResult(qty%noSurfs,qty%noChans),STAT=status)
d469 1
a469 2
         & "tmpResult")

d471 1
a471 1
       tmpResult=RESHAPE(values,(/qty%noChans,qty%noSurfs/))
d473 1
a473 1
       tmpResult=TRANSPOSE(RESHAPE(values,(/qty%noSurfs,qty%noChans/)))
d475 1
a475 1
       tmpResult=TRANSPOSE(RESHAPE(values,(/qty%noChans,qty%noSurfs/)))
d477 1
a477 1
       tmpResult=RESHAPE(values,(/qty%noSurfs,qty%noChans/))
d479 1
a479 3

    GetSubVectorAs2DArray=>tmpResult
  END FUNCTION GetSubVectorAs2DArray
d488 3
@


1.9
log
@Removed INTENT from declaration of dummy argument database in DestroyVectorDatabase.
@
text
@d16 1
a16 1
       "$Id: VectorsModule.f90,v 1.8 2000/04/14 20:27:43 vsnyder Exp $"
a95 1

a151 1
    
d220 1
a220 1
    DEALLOCATE(database)
d315 1
a315 1
    DEALLOCATE(database)
d472 3
@


1.8
log
@OOPS -- Replaced unspecified INTENT with INTENT(INOUT) -- see previous rev.
@
text
@d16 1
a16 1
       "$Id: VectorsModule.f90,v 1.7 2000/04/13 23:45:33 vsnyder Exp $"
d328 1
a328 1
    TYPE (Vector_T), INTENT(INOUT), DIMENSION(:), POINTER :: database
d474 3
@


1.7
log
@Removed INTENT(IN) for the argument "vector" of DestroyVectorInfo, for
which a component was deallocated
@
text
@d16 1
a16 1
       "$Id: VectorsModule.f90,v 1.6 2000/01/20 01:29:59 livesey Exp $"
d328 1
a328 1
    TYPE (Vector_T), DIMENSION(:), POINTER :: database
d474 4
@


1.6
log
@Added GetSubVectorAs2DArray
@
text
@d16 1
a16 1
       "$Id: VectorsModule.f90,v 1.5 2000/01/19 18:36:46 livesey Exp $"
d277 1
a277 1
    TYPE (Vector_T), INTENT(IN) :: vector
d474 3
@


1.5
log
@Sorted out the sub vector layout stuff.  Added the layout element of
the template, and wrote code to deal with it.  Also wrote
GetSubVectorPointer
@
text
@d16 1
a16 1
       "$Id: VectorsModule.f90,v 1.4 1999/12/17 21:43:17 livesey Exp $"
d392 76
d474 5
@


1.4
log
@Added check for duplicate name
@
text
@d16 1
a16 1
       "$Id: VectorsModule.f90,v 1.3 1999/12/16 18:32:26 livesey Exp $"
d25 7
d51 1
a51 1
     INTEGER, DIMENSION(:), POINTER :: subVectorFirstElements ! (noSubVectors)
d55 4
d81 2
d92 2
a93 1
    INTEGER :: status
d107 1
a107 1
         & vectorTemplate%subVectorFirstElements(vectorTemplate%noSubVectors), &
d110 1
d113 8
a120 1
         & "Vector information")
d125 3
a127 1
         & "Vector quantities")
d133 20
d165 3
d172 1
a172 1
         & vectorTemplate%subVectorFirstElements, &
d175 5
d181 6
d341 51
d398 3
@


1.3
log
@Changed do to name change from VectorQuantities to QuantityTemplates
@
text
@d16 1
a16 1
       "$Id: VectorsModule.f90,v 1.2 1999/12/14 01:01:52 livesey Exp $"
d149 4
d244 4
d289 3
@


1.2
log
@Changed DOUBLE PRECISION to REAL(r8)
@
text
@d9 1
a9 1
  USE VectorQuantities
d16 1
a16 1
       "$Id: VectorsModule.f90,v 1.1 1999/12/04 00:30:18 livesey Exp $"
d281 3
@


1.1
log
@First version.
@
text
@d16 2
a17 2
       "$Id: $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile$"
d58 1
a58 1
     DOUBLE PRECISION, DIMENSION(:), POINTER :: values
d280 4
a283 1
! $Log$
@

