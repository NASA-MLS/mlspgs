head	2.7;
access;
symbols
	v5-02-NRT-19:2.7
	v6-00:2.7
	v5-02-NRT-18:2.7
	v5-02:2.7
	v5-01-NRT-17:2.7
	v5-01-NRT-16:2.7
	v5-01-NRT-15:2.7
	v5-01-NRT-14:2.7
	neuralnetworks-1-0:2.7.0.10
	cfm-single-freq-0-1:2.7.0.8
	v5-01:2.7
	v5-00:2.7
	v4-23-TA133:2.7.0.6
	mus-emls-1-70:2.7.0.4
	rel-1-0-englocks-work:2.7.0.2
	VUMLS1-00:2.7
	VPL1-00:2.5
	V4-22-NRT-08:2.5;
locks; strict;
comment	@# @;


2.7
date	2016.10.17.23.56.33;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2016.09.23.01.49.58;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2016.03.25.00.45.25;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2016.02.26.02.02.00;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2016.01.26.19.55.21;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2016.01.23.02.47.33;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2015.11.14.18.02.37;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.7
log
@Remove unused USE
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module Geolocation_m
!=============================================================================

  ! Define geolocation representations.  Enquire a geolocation.
  ! Calculate interpolation coefficients.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Test_Allocate, &
    & Test_Deallocate
  use Geolocation_0, only: ECR_t, GeocLat_t, GeodLat_t, Lat_t, Lon_t, H_t, &
    & H_Geoc, H_Geod, H_V_t, H_V_Geoc, H_V_Geod, H_V_Zeta, RG, V_T, V_Geoc, &
    & V_Geod, V_Zeta
  use Generate_QTM_m, only: QTM_Tree_t

  implicit NONE
  private

  ! Types:
  public :: Coeff_t, Geolocation_t
  public :: ECR_t, H_t, H_Geoc, H_Geod
  public :: Lat_t, GeocLat_t, GeodLat_t, Lon_t
  public :: H_V_t, H_V_Geoc, H_V_Geod, H_V_Zeta
  public :: QTM_Tree_t, V_T, V_Geoc, V_Geod, V_Zeta
  ! All the procedures are type bound.  The specific and generic
  ! bindings are public but the "bare" procedures are private.

  public :: RG

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Geolocation_m.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

  type :: Geolocation_t
    ! DO NOT use the components without checking that they're associated!
    ! If you're not sure, use the functions.  If the functions return
    ! -huge(0.0_rg) then nothing was associated, or you asked for zeta when
    ! it wasn't associated, or you asked for height when zeta was associated. 
    ! We don't want to run the hydrostatic model to convert between them
    ! here -- and we don't have temperature anyway, so we can't.

    ! Horizontal coordinates, degrees
    type(lon_t), pointer, contiguous :: Lon1(:)=> null()       ! V*H*H
    type(lon_t), pointer, contiguous :: Lon2(:,:) => null()    ! => Lon1, V x H*H
    type(lon_t), pointer, contiguous :: Lon3(:,:,:) => null()  ! => Lon1, V x H x H
    type(geocLat_t), pointer, contiguous :: GeocLat1(:) => null()     ! V*H*H
    type(geocLat_t), pointer, contiguous :: GeocLat2(:,:) => null()   ! => geocLat1, V x H*H
    type(geocLat_t), pointer, contiguous :: GeocLat3(:,:,:) => null() ! => geocLat1, V x H x H
    type(geodLat_t), pointer, contiguous :: GeodLat1(:) => null()     ! V*H*H
    type(geodLat_t), pointer, contiguous :: GeodLat2(:,:) => null()   ! => geodLat1, V x H*H
    type(geodLat_t), pointer, contiguous :: GeodLat3(:,:,:) => null() ! => geodLat1, V x H x H
    ! Great-circle along-track coordinate, degrees, with origin at the
    ! instrument and increasing in the direction of the tangent.
    real(rg), pointer, contiguous :: Phi1(:) => null()         ! V*H*H
    real(rg), pointer, contiguous :: Phi2(:,:) => null()       ! => Phi1, V x H*H
    real(rg), pointer, contiguous :: Phi3(:,:,:) => null()     ! => Phi1, V x H x H
    ! Vertical coordinates, meters from the Earth center
    type(v_geoc), pointer, contiguous :: GeocV1(:) => null()   ! V*H*H or V*size(QTM_ZOT)
    type(v_geoc), pointer, contiguous :: GeocV2(:,:) => null() ! => GeocV1, V x H*H or
                                                               ! V x size(QTM_ZOT)
    type(v_geoc), pointer, contiguous :: GeocV3(:,:,:) => null() ! => GeocV1, V x H x H
    ! Vertical coordinates, meters above sea level
    type(v_geod), pointer, contiguous :: GeodV1(:) => null()   ! V*H*H or V*size(QTM_ZOT)
    type(v_geod), pointer, contiguous :: GeodV2(:,:) => null() ! => GeodV1, V x H*H or
                                                               ! V x size(QTM_ZOT)
    type(v_geod), pointer, contiguous :: GeodV3(:,:,:) => null() ! => GeodV1, V x H x H
    ! Vertical coordinates, zeta
    type(v_zeta), pointer, contiguous :: Zeta1(:) => null()    ! V*H*H
    type(v_zeta), pointer, contiguous :: Zeta2(:,:) => null()  ! => Zeta1, V x H*H
    type(v_zeta), pointer, contiguous :: Zeta3(:,:,:) => null() ! => Zeta1, V x H x H
    ! ECR coordinates, meters
    type(ecr_t), pointer, contiguous :: P1(:) => null()        ! V*H*H
    type(ecr_t), pointer, contiguous :: P2(:,:) => null()      ! => P1, V x H*H
    type(ecr_t), pointer, contiguous :: P3(:,:,:) => null()    ! => P1, V x H x H
    ! QTM horizontal grids, generated by Generate_QTM
    type(QTM_tree_t) :: QTM_Tree

    logical :: Cartesian = .false.   ! Horizontal lat/lon grid is Cartesian
    logical :: Coherent = .false.    ! Do instances have same sets of vertical
                                     ! coordinates?
    logical :: GreatCircle = .false. ! Are coordinates on a great circle?
    logical :: Stacked = .false.     ! Are instances true vertical profiles?  We
                                     ! assume that if they are, and the
                                     ! horizontal basis is two-dimensional, the
                                     ! instances are still true vertical
                                     ! profiles, not just in vertical planes.

  contains

    ! Create using geocentric lat and height (meters) from the Earth center
    procedure :: Geoc_V_1     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geoc_V_1_1   ! Needs to be told whether it's coherent and stacked
    procedure :: Geoc_V_1_1_1 ! Inherently Cartesian, coherent, and stacked
    procedure :: Geoc_V_1_1_3 ! Inherently Cartesian, incoherent, and stacked
    procedure :: Geoc_V_1_2   ! Stacked but not coherent
    procedure :: Geoc_V_2     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geoc_V_2_1   ! Coherent, maybe stacked
    procedure :: Geoc_V_3     ! Entirely irregular -- neither coherent nor stacked
    ! Create using geocentric lat and height (meters) from the Earth center for
    ! two points on a great circle, and angles along that great circle
    procedure :: Geoc_V_G_0_1 ! One circle, coherent and stacked
    procedure :: Geoc_V_G_1_1 ! Several circles, coherent and stacked
    procedure :: Geoc_V_G_1_2 ! Several circles, incoherent and unstacked
    procedure :: Geoc_V_G_2_3 ! Several families of circles, incoherent and unstacked
    ! Create using geodetic lat and height (meters) from sea lavel for two
    ! points on a great circle, and angles along that great circle
    procedure :: Geod_V_G_0_1 ! One circle, coherent and stacked
    procedure :: Geod_V_G_1_1 ! Several circles, coherent and stacked
    procedure :: Geod_V_G_1_2 ! Several circles, incoherent and unstacked
    procedure :: Geod_V_G_2_3 ! Several families of circles, incoherent and unstacked
    ! Create using geodetic lat and zeta for two points on a great circle, and
    ! angles along that great circle
    procedure :: Geod_Z_G_0_1 ! One circle, coherent and stacked
    procedure :: Geod_Z_G_1_1 ! Several circles, coherent and stacked
    procedure :: Geod_Z_G_1_2 ! Several circles, incoherent and unstacked
    procedure :: Geod_Z_G_2_3 ! Several families of circles, incoherent and unstacked
    ! Create using geodetic lat and height (meters) above sea level
    ! Create using geodetic lat and height (meters) above sea level
    procedure :: Geod_V_1     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geod_V_1_1   ! Needs to be told whether it's coherent and stacked
    procedure :: Geod_V_1_1_1 ! Inherently Cartesian, coherent, and stacked
    procedure :: Geod_V_1_1_3 ! Inherently Cartesian, incoherent, and stacked
    procedure :: Geod_V_1_2   ! Stacked but not coherent
    procedure :: Geod_V_2     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geod_V_2_1   ! Coherent, maybe stacked
    procedure :: Geod_V_3     ! Entirely irregular -- neither coherent nor stacked
    ! Create using geodetic lat and height zeta
    procedure :: Geod_Z_1     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geod_Z_1_1   ! Needs to be told whether it's coherent and stacked
    procedure :: Geod_Z_1_1_1 ! Inherently Cartesian, coherent, and stacked
    procedure :: Geod_Z_1_1_3 ! Inherently Cartesian, incoherent, and stacked
    procedure :: Geod_Z_1_2   ! Stacked but not coherent
    procedure :: Geod_Z_2     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geod_Z_2_1   ! Coherent, maybe stacked
    procedure :: Geod_Z_3     ! Entirely irregular -- neither coherent nor stacked
    ! Create using ECR, meters
    procedure :: Create_P_1   ! Neither coherent nor stacked
    procedure :: Create_P_2   ! Neither coherent nor stacked
    procedure :: Create_P_3   ! Neither coherent nor stacked

    ! Declare Create generic
    ! Entirely irregular -- neither coherent nor stacked:
    generic :: Create => geoc_v_1
    generic :: Create => geod_v_1
    generic :: Create => geod_z_1
    generic :: Create => geoc_v_2
    generic :: Create => geod_v_2
    generic :: Create => geod_z_2
    generic :: Create => geoc_v_3
    generic :: Create => geod_v_3
    generic :: Create => geod_z_3
    generic :: Create => create_p_1
    generic :: Create => create_p_2
    generic :: Create => create_p_3
    ! Needs to be told whether it's coherent and stacked:
    generic :: Create => geoc_v_1_1
    generic :: Create => geod_v_1_1
    generic :: Create => geod_z_1_1
    ! Stacked but not coherent:
    generic :: Create => geoc_v_1_2
    generic :: Create => geod_v_1_2
    generic :: Create => geod_z_1_2
    ! Coherent but not stacked
    generic :: Create => geoc_v_2_1
    generic :: Create => geod_v_2_1
    generic :: Create => geod_z_2_1
    ! On great circles
    generic :: Create => geoc_v_g_0_1 ! One circle, maybe coherent and stacked
    generic :: Create => geoc_v_g_1_1 ! Several circles, maybe coherent and stacked
    generic :: Create => geoc_v_g_1_2 ! Several circles, incoherent and instacked
    generic :: Create => geoc_v_g_2_3 ! Several families of circles, incoherent and instacked
    generic :: Create => geod_v_g_0_1 ! One circle, maybe coherent and stacked
    generic :: Create => geod_v_g_1_1 ! Several circles, maybe coherent and stacked
    generic :: Create => geod_v_g_1_2 ! Several circles, incoherent and instacked
    generic :: Create => geod_v_g_2_3 ! Several families of circles, incoherent and instacked
    generic :: Create => geod_z_g_0_1 ! One circle, maybe coherent and stacked
    generic :: Create => geod_z_g_1_1 ! Several circles, maybe coherent and stacked
    generic :: Create => geod_z_g_1_2 ! Several circles, incoherent and instacked
    generic :: Create => geod_z_g_2_3 ! Several families of circles, incoherent and instacked

    ! Interrogate
    procedure :: Lon        ! Degrees
    procedure :: GeocLat    ! Geocentric latitude, degrees
    procedure :: GeodLat    ! Geodetic latitude, degrees
    procedure :: GeocV      ! Geocentric height, meters from the Earth center
    procedure :: GeodV      ! Geodetic height, meters above sea level
    procedure :: Zeta       ! Zeta
    procedure :: Loc_Geoc   ! Lon degrees, geoc lat degrees, geoc height meters
    procedure :: Loc_Geod   ! Lon degrees, geod lat degrees, geod height meters
    procedure :: Loc_Zeta   ! Lon degrees, geod lat degrees, zeta
    procedure :: ECR        ! ECR coordinates, meters

    ! Fill alternative representations from existant geolocations
    procedure :: Fill_Geoc
    procedure :: Fill_Geod
    ! There is no Fill_Zeta because that would require a temperature field
    ! and access to the hydrostatic model.
    procedure :: Fill_ECR

    ! Insert alternative vertical coordinates
    procedure :: Insert_Geoc_1
    procedure :: Insert_Geoc_2
    procedure :: Insert_Geoc_3
    procedure :: Insert_Geod_1
    procedure :: Insert_Geod_2
    procedure :: Insert_Geod_3
    procedure :: Insert_Zeta_1
    procedure :: Insert_Zeta_2
    procedure :: Insert_Zeta_3

    generic :: Insert => Insert_Geoc_1
    generic :: Insert => Insert_Geoc_2
    generic :: Insert => Insert_Geoc_3
    generic :: Insert => Insert_Geod_1
    generic :: Insert => Insert_Geod_2
    generic :: Insert => Insert_Geod_3
    generic :: Insert => Insert_Zeta_1
    generic :: Insert => Insert_Zeta_2
    generic :: Insert => Insert_Zeta_3

    ! Remove alternative representations
    procedure :: Delete_Geoc
    procedure :: Delete_Geod
    procedure :: Delete_Zeta
    procedure :: Delete_ECR

    ! Destroy
    procedure :: Explicit_Destroy_G
    generic :: Destroy => Explicit_Destroy_G
    procedure :: Destroy_G_P1     ! Because we can't use deallocate_test
    final :: Destroy_G

  end type Geolocation_t

  ! Given a geolocation_t structure, and the geolocation of a point,
  ! interpolation coefficients from the structure to the point are represented
  ! by an object of this type:
  type :: Coeff_t
    integer, allocatable :: I(:)  ! Array element-order indices of points in
                                  ! the geolocation-t structure with nonzero
                                  ! interpolation coefficients.
    real(rg), allocatable :: C(:) ! Nonzero interpolation coefficients.
    ! Size(I) = size(c), typically 3 or 4 in two dimensions depending upon
    ! whether the grid is quadrilateral, or irregular and a Delaunay
    ! triangulation is used, or 6 or 8 in three dimensions depending upon
    ! whether the horizontal grid is quadrilateral, or irregular and a Delaunay
    ! triangulation is used.  If a tetrahedral tessellation is used, there
    ! would be four nonzeros.
  end type Coeff_t

contains

  ! -----  Geolocation_t procedures  -----------------------------------

  ! Entirely irregular, rank 1, e.g., for a line not defined by reference to a
  ! great circle, or for the tangent points or spacecraft locations of all the
  ! MIFs in a MAF.  Coordinates of each point are longitude, geocentric latitude,
  ! and height in meters from the Earth center.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geoc_V_1 ( G, HV )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_v_geoc), intent(in) :: HV(:)
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(hv,1),1:1) => g%lon1
    g%lon3(1:size(hv,1),1:1,1:1) => g%lon1
    g%geocLat2(1:size(hv,1),1:1) => g%geocLat1
    g%geocLat3(1:size(hv,1),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(hv,1),1:1) => g%geocV1
    g%geocV3(1:size(hv,1),1:1,1:1) => g%geocV1
    g%lon1 = hv%lon
    g%geocLat1%d = hv%lat
    g%geocV1%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geoc_V_1

  ! Create using longitude, geocentric latitude, height in meters from the
  ! Earth center.
  ! We can't tell just by the fact that both horizontal and vertical are one
  ! dimensional whether it's coherent and stacked, i.e., an outer product, or
  ! neither, i.e., a line through the atmosphere -- it can't be only stacked or
  ! only coherent.
  ! The order of geolocated values is vertical first, then horizontal.  If
  ! Regular is absent, or present and true, the horizontal order is longitude
  ! first, then latitude.
  ! If Regular is present and false, then
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(h) = size(v)                                 !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_1_1 ( G, H, V, Regular )
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: H(:)         ! Horizontal coordinates (lon, lat)
    type(v_geoc), intent(in) :: V(:)         ! Geocentric height, meters
    logical, intent(in), optional :: Regular ! coherent and stacked, default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geocLat2(1:size(h),1:1) => g%geocLat1
    g%geocLat3(1:size(h),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(v),1:1) => g%geocV1
    g%geocV3(1:size(v),1:1,1:1) => g%geocV1
    g%lon1 = h%lon
    g%geocLat1%d = h%lat
    g%geocV1%v = v%v
    g%cartesian = .false.
    if ( present(regular) ) then
      g%coherent = regular
      g%stacked = regular
    else
      g%coherent = .true.
      g%stacked = .true.
    end if
  end subroutine Geoc_V_1_1

  ! Create using the outer product of longitude, geocentric latitude, and
  ! height in meters from the Earth center.  This is inherently Cartesian,
  ! coherent, and stacked.
  ! The order of geolocated values is vertical, longitude, latitude.
  subroutine Geoc_V_1_1_1 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geocLat_t), intent(in) :: Lat(:)  ! Geocentric latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_geoc), intent(in) :: V(:)       ! Geocentric height, meters
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geocLat2(1:size(lat),1:1) => g%geocLat1
    g%geocLat3(1:size(lat),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(v),1:1) => g%geocV1
    g%geocV3(1:size(v),1:1,1:1) => g%geocV1
    g%lon1= lon
    g%geocLat1 = lat
    g%geocV1 = v
    g%cartesian = .true.
    g%coherent = .true.
    g%stacked = .true.
  end subroutine Geoc_V_1_1_1

  ! Create using the outer product of longitude and geocentric latitude, and
  ! height in meters from the Earth center.  This is inherently Cartesian,
  ! incoherent, and stacked.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(lon) and size(v,3) = size(lat)   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_1_1_3 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geocLat_t), intent(in) :: Lat(:)  ! Geocentric latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_geoc), intent(in) :: V(:,:,:)   ! Geocentric height, meters
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geocLat2(1:size(lat),1:1) => g%geocLat1
    g%geocLat3(1:size(lat),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(v,1),1:size(v,2)*size(v,3)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%geocV1
  end subroutine Geoc_V_1_1_3

  ! Stacked but not coherent, using longitude, geocentric latitude, and
  ! geocentric height in meters from the Earth center.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(h)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_1_2 ( G, H, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: H(:)       ! Horizontal coordinates
    type(v_geoc), intent(in) :: V(:,:)     ! Geocentric heights
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geocLat2(1:size(h),1:1) => g%geocLat1
    g%geocLat3(1:size(h),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(v,1),1:size(v,2)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:1) => g%geocV1
    g%lon1 = h%lon
    g%geocLat1%d = h%lat
    g%geocV2 = v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .true.
  end subroutine Geoc_V_1_2

  ! Entirely irregular, rank 2, e.g., for a plane, using longitude, geocentric
  ! latitude, and geocentric height in meters from the Earth center.
  ! It might actually be coherent and stacked, depending upon values of HV.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geoc_V_2 ( G, HV )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_v_geoc), intent(in) :: HV(:,:)  ! All geocentric coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:1) => g%lon1
    g%geocLat2(1:size(hv,1),1:size(hv,2)) => g%geocLat1
    g%geocLat3(1:size(hv,1),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(hv,1),1:size(hv,2)) => g%geocV1
    g%geocV3(1:size(hv,1),1:size(hv,2),1:1) => g%geocV1
    g%lon2 = hv%lon
    g%geocLat2%d = hv%lat
    g%geocV2%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geoc_V_2

  ! Coherent, maybe stacked.
  ! If it's stacked, H gives coordinates in a horizontal plane.  Otherwise,
  ! H gives coordinates in a vertical plane.
  ! If it's stacked, the order of geolocated values is V, then the
  ! array-element order of H.  If it's not stacked, the order of geolocated
  ! values is the same as the array-element order of H.
  subroutine Geoc_V_2_1 ( G, H, V, Stacked )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: H(:,:)     ! Horizontal coordinates
    type(v_geoc), intent(in) :: V(:)       ! Geocentric heights
    logical, intent(in), optional :: Stacked ! default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(h,1),1:size(h,2)) => g%lon1
    g%lon3(1:size(h,1),1:size(h,2),1:1) => g%lon1
    g%geocLat2(1:size(h,1),1:size(h,2)) => g%geocLat1
    g%geocLat3(1:size(h,1),1:size(h,2),1:1) => g%geocLat1
    g%geocV2(1:size(v,1),1:1) => g%geocV1
    g%geocV3(1:size(v,1),1:1,1:1) => g%geocV1
    g%lon2 = h%lon
    g%geocLat2%d = h%lat
    g%geocV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    if ( present(stacked) ) then
      g%stacked = stacked
    else
      g%stacked = .true.
    end if
  end subroutine Geoc_V_2_1

  ! Entirely irregular, rank 3, using longitude, geocentric latitude, and
  ! geocentric height in meters from the Earth center.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geoc_V_3 ( G, HV )
    class(geolocation_t), intent(out) :: G  ! Intent(out) causes Destroy_G
    type(h_v_geoc), intent(in) :: HV(:,:,:) ! All geocentric coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%lon1
    g%geocLat2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%geocLat1
    g%geocLat3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%geocLat1
    g%geocV2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%geocV1
    g%geocV3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%geocV1
    g%lon3 = hv%lon
    g%geocLat3%d = hv%lat
    g%geocV3%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geoc_V_3

  ! Identify a great circle by two points on it.  If Outer is absent, or present
  ! and true, the grid is coherent and stacked, defined by the outer product of
  ! geocentric height (meters), and angle (degrees) along the great circle.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  ! If outer is present and false, the grid is one-dimensional, and
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(phi) = size(v).                              !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! the order of geolocated values is the same as the array-element order of Phi.
  subroutine Geoc_V_G_0_1 ( G, R1, R2, Phi, V, Outer )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: R1, R2       ! Points on the great circle
    real(rg), intent(in) :: Phi(:)           ! Along-track angles (degrees)
    type(v_geoc), intent(in) :: V(:)         ! Geocentric heights (meters)
    logical, intent(in), optional :: Outer   ! Outer product, default YES
    integer :: Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(phi)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:1) => g%lon1
    g%lon3(1:size(phi),1:1,1:1) => g%lon1
    g%geocLat2(1:size(phi),1:1) => g%geocLat1
    g%geocLat3(1:size(phi),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(v),1:1) => g%geocV1
    g%geocV3(1:size(v),1:1,1:1) => g%geocV1
    g%phi1 = phi
    g%geocV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    if ( present(outer) ) then
      g%coherent = outer
      g%stacked = outer
    end if
    ! Compute Lon and GeocLat for points on the great circle from R1 to R2
    call great_circle_points ( r1%lon%d, r1%lat, r2%lon%d, r2%lat, phi, &
      & g%lon1%d, g%geocLat1%d )
  end subroutine Geoc_V_G_0_1

  ! Identify great circles by two points on each one.  The grid is coherent and
  ! stacked, defined on each circle by the outer product of geocentric height
  ! (meters), and angle (degrees) along each great circle.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_G_1_1 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees) - same
                                           ! on all circles
    type(v_geoc), intent(in) :: V(:)       ! Geocentric heights (meters) - same
                                           ! on all circles
    integer :: I, Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(phi)*size(r1)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(r1)) => g%lon1
    g%lon3(1:size(phi),1:size(r1),1:1) => g%lon1
    g%geocLat2(1:size(phi),1:size(r1)) => g%geocLat1
    g%geocLat3(1:size(phi),1:size(r1),1:1) => g%geocLat1
    g%geocV2(1:size(v),1:1) => g%geocV1
    g%geocV3(1:size(v),1:1,1:1) => g%geocV1
    g%phi1 = phi
    g%geocV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    ! Compute Lon and GeocLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, g%geocLat2(:,i)%d )
    end do
  end subroutine Geoc_V_G_1_1

  ! Identify great circles by two points on each one.  The grid is incoherent and
  ! unstacked, defined on each circle by geocentric height (meters), and angle
  ! (degrees) along each great circle.  The angular spacing of the grid along
  ! each circle is the same, given by Phi.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2), size(phi) = size(v,1), and   !!!!
  !!!! size(v,2) = size(r1) = size(r2)                   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_G_1_2 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_geoc), intent(in) :: V(:,:)     ! Geocentric heights (meters)
    integer :: I, Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(r1)) => g%lon1
    g%lon3(1:size(phi),1:size(r1),1:1) => g%lon1
    g%geocLat2(1:size(phi),1:size(r1)) => g%geocLat1
    g%geocLat3(1:size(phi),1:size(r1),1:1) => g%geocLat1
    g%geocV2(1:size(v,1),1:size(v,2)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:1) => g%geocV1
    g%phi1 = phi
    g%geocV2%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and GeocLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, g%geocLat2(:,i)%d )
    end do
  end subroutine Geoc_V_G_1_2

  ! Identify families of great circles by two points on each one.  The grids are
  ! incoherent and unstacked, defined on each circle by geocentric height
  ! (meters), and angle (degrees) along each great circle.  The angular spacing
  ! of the grid along each circle is the same, given by Phi. The third dimension
  ! of Phi and V can be considered an instance or family index.  This is intended
  ! to create a grid in each ruled surface defined by one vertical scan.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! shape(r1) = shape(r2), size(phi) = size(v,1), and !!!!
  !!!! shape(v)(2:3) = shape(r1) = shape(r2)             !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_G_2_3 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: R1(:,:), R2(:,:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_geoc), intent(in) :: V(:,:,:)   ! Geocentric heights (meters)
    integer :: I, J, Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(v,2)*size(v,3)) => g%lon1
    g%lon3(1:size(phi),1:size(v,2),1:size(v,3)) => g%lon1
    g%geocLat2(1:size(phi),1:size(v,2)*size(v,3)) => g%geocLat1
    g%geocLat3(1:size(phi),1:size(v,2),1:size(v,3)) => g%geocLat1
    g%geocV2(1:size(v,1),1:size(v,2)*size(v,3)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%geocV1
    g%phi1 = phi
    g%geocV3%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and GeocLat for points on the great circles from R1 to R2
    do j = 1, size(r1,2)
      do i = 1, size(r1,1)
        call great_circle_points ( r1(i,j)%lon%d, r1(i,j)%lat, &
          & r2(i,j)%lon%d, r2(i,j)%lat, phi, g%lon3(:,i,j)%d, &
          & g%geocLat3(:,i,j)%d )
      end do
    end do
  end subroutine Geoc_V_G_2_3

  ! Entirely irregular, rank 1, e.g., for a line not defined by reference to a
  ! great circle, or for all the MIFs in a MAF.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_V_1 ( G, HV )
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_v_geod), intent(in) :: HV(:)      ! All geodetic coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(hv,1),1:1) => g%lon1
    g%lon3(1:size(hv,1),1:1,1:1) => g%lon1
    g%geodLat2(1:size(hv,1),1:1) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(hv,1),1:1) => g%geodV1
    g%geodV3(1:size(hv,1),1:1,1:1) => g%geodV1
    g%lon1 = hv%lon
    g%geodLat1%d = hv%lat
    g%geodV1%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_V_1

  ! Create using geodetic latitude and height in meters above sea level.
  ! We can't tell just by the fact that both horizontal and vertical are one
  ! dimensional whether it's coherent and stacked, i.e., an outer product, or
  ! neither, i.e., a line through the atmosphere -- it can't be just one.
  ! The order of geolocated values is vertical first, then horizontal.
  ! If Regular is present and false, then
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(h) = size(v)                                 !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_1_1 ( G, H, V, Regular )
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:)         ! Horizontal coordinates
    type(v_geod), intent(in) :: V(:)         ! Geodetic height in meters
    logical, intent(in), optional :: Regular ! coherent and stacked, default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geodLat2(1:size(h),1:1) => g%geodLat1
    g%geodLat3(1:size(h),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(v),1:1) => g%geodV1
    g%geodV3(1:size(v),1:1,1:1) => g%geodV1
    g%lon1 = h%lon
    g%geodLat1%d = h%lat
    g%geodV1%v = v%v
    g%cartesian = .false.
    if ( present(regular) ) then
      g%coherent = regular
      g%stacked = regular
    else
      g%coherent = .true.
      g%stacked = .true.
    end if
  end subroutine Geod_V_1_1

  ! Create using the outer product of longitude, geodetic latitude, and
  ! height in meters from the Earth center.  This is inherently Cartesian,
  ! coherent, and stacked.
  ! The order of geolocated values is vertical, longitude, latitude.
  subroutine Geod_V_1_1_1 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geodLat_t), intent(in) :: Lat(:)  ! Geodetic latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_geoc), intent(in) :: V(:)       ! Geodetic height, meters
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geodLat2(1:size(lat),1:1) => g%geodLat1
    g%geodLat3(1:size(lat),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(v),1:1) => g%geodV1
    g%geodV3(1:size(v),1:1,1:1) => g%geodV1
    g%lon1 = lon
    g%geocLat1%d = lat%d
    g%geocV1%v = v%v
    g%cartesian = .true.
    g%coherent = .true.
    g%stacked = .true.
  end subroutine Geod_V_1_1_1

  ! Create using the outer product of longitude and geodetic latitude, and
  ! height in meters from the Earth center.  This is inherently Cartesian,
  ! incoherent, and stacked.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(lon) and size(v,3) = size(lat)   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_1_1_3 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geodLat_t), intent(in) :: Lat(:)  ! Geodetic latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_geod), intent(in) :: V(:,:,:)   ! Geodetic height, meters
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geodLat2(1:size(lat),1:1) => g%geodLat1
    g%geodLat3(1:size(lat),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(v,1),1:size(v,2)*size(v,3)) => g%geodV1
    g%geodV3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%geodV1
  end subroutine Geod_V_1_1_3

  ! Stacked but not coherent, using longitude, geodetic latitude, and
  ! geodetic height in meters above sea level.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(h)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_1_2 ( G, H, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:)       ! Horizontal coordinates
    type(v_geod), intent(in) :: V(:,:)     ! Geodetic height, meters
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geodLat2(1:size(h),1:1) => g%geodLat1
    g%geodLat3(1:size(h),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(v,1),1:size(v,2)) => g%geodV1
    g%geodV3(1:size(v,1),1:size(v,2),1:1) => g%geodV1
    g%lon1 = h%lon
    g%geodLat1%d = h%lat
    g%geodV2%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .true.
  end subroutine Geod_V_1_2

  ! Entirely irregular, rank 2, e.g., for a plane, using longitude,
  ! geodetic latitude, and geodetic height in meters above sea level.
  ! It might actually be coherent and stacked, depending upon values of HV.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_V_2 ( G, HV )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_v_geod), intent(in) :: HV(:,:)  ! All coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:1) => g%lon1
    g%geodLat2(1:size(hv,1),1:size(hv,2)) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(hv,1),1:size(hv,2)) => g%geodV1
    g%geodV3(1:size(hv,1),1:size(hv,2),1:1) => g%geodV1
    g%lon2 = hv%lon
    g%geodLat2%d = hv%lat
    g%geodV2%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_V_2

  ! Coherent, maybe stacked.
  ! If it's stacked, H gives coordinates in a horizontal plane.  Otherwise,
  ! H gives coordinates in a vertical plane.
  ! If it's stacked, the order of geolocated values is V, then the
  ! array-element order of H.  If it's not stacked, the order of geolocated
  ! values is the same as the array-element order of H.
  subroutine Geod_V_2_1 ( G, H, V, Stacked )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:,:)     ! Horizontal coordinates
    type(v_geod), intent(in) :: V(:)       ! Geodetic height, meters
    logical, intent(in), optional :: Stacked ! default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(h,1),1:size(h,2)) => g%lon1
    g%lon3(1:size(h,1),1:size(h,2),1:1) => g%lon1
    g%geodLat2(1:size(h,1),1:size(h,2)) => g%geodLat1
    g%geodLat3(1:size(h,1),1:size(h,2),1:1) => g%geodLat1
    g%geodV2(1:size(v,1),1:1) => g%geodV1
    g%geodV3(1:size(v,1),1:1,1:1) => g%geodV1
    g%lon2 = h%lon
    g%geodLat2%d = h%lat
    g%geodV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    if ( present(stacked) ) then
      g%stacked = stacked
    else
      g%stacked = .true.
    end if
  end subroutine Geod_V_2_1

  ! Entirely irregular, rank 3, using longitude, geodetic latitude, and
  ! geodetic height in meters above sea level.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_V_3 ( G, HV )
    class(geolocation_t), intent(out) :: G  ! Intent(out) causes Destroy_G
    type(h_v_geod), intent(in) :: HV(:,:,:) ! All coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%lon1
    g%geodLat2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%geodLat1
    g%geodV2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%geodV1
    g%geodV3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%geodV1
    g%lon3 = hv%lon
    g%geodLat3%d = hv%lat
    g%geodV3%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_V_3

  ! Identify a great circle by two points on it.  If Outer is absent, or present
  ! and true, the grid is coherent and stacked, defined by the outer product of
  ! geodetic height (meters), and angle (degrees) along the great circle.  The
  ! angular spacing of the grid along each circle is the same, given by Phi.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  ! If outer is present and false, the grid is one-dimensional, and
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(phi) = size(v).                              !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! the order of geolocated values is the same as the array-element order of Phi.
  subroutine Geod_V_G_0_1 ( G, R1, R2, Phi, V, Outer )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1, R2     ! Points on the great circle
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_geod), intent(in) :: V(:)       ! Geodetic heights (meters)
    logical, intent(in), optional :: Outer ! Outer product, default YES
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    integer :: Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(phi)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:1) => g%lon1
    g%lon3(1:size(phi),1:1,1:1) => g%lon1
    g%geodLat2(1:size(phi),1:1) => g%geodLat1
    g%geodLat3(1:size(phi),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(v),1:1) => g%geodV1
    g%geodV3(1:size(v),1:1,1:1) => g%geodV1
    g%phi1 = phi
    g%geodV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    if ( present(outer) ) then
      g%coherent = outer
      g%stacked = outer
    end if
    ! Compute Lon and geodLat for points on the great circle from R1 to R2
    ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
    call great_circle_points ( r1%lon%d, r1%lat, r2%lon%d, r2%lat, phi, &
      & g%lon1%d, lat%d )
    g%geodLat1 = lat%geod()
  end subroutine Geod_V_G_0_1

  ! Identify great circles by two points on each one.  The grid is coherent and
  ! stacked, defined on each circle by the outer product of geodetic height
  ! (meters), and angle (degrees) along each great circle.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_G_1_1 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees) - same
                                           ! on all circles
    type(v_geod), intent(in) :: V(:)       ! Geodetic heights (meters) - same
                                           ! on all circles
    integer :: I, Stat
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(phi)*size(r1)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(r1)) => g%lon1
    g%lon3(1:size(phi),1:size(r1),1:1) => g%lon1
    g%geodLat2(1:size(phi),1:size(r1)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(r1),1:1) => g%geodLat1
    g%geodV2(1:size(v),1:1) => g%geodV1
    g%geodV3(1:size(v),1:1,1:1) => g%geodV1
    g%phi1 = phi
    g%geodV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    ! Compute Lon and geodLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, lat%d )
      g%geodLat2(:,i) = lat%geod()
    end do
  end subroutine Geod_V_G_1_1

  ! Identify great circles by two points on each one.  The grid is incoherent and
  ! unstacked, defined on each circle by geodetic height (meters), and angle
  ! (degrees) along each great circle.  The angular spacing
  ! of the grid along each circle is the same, given by Phi.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2), size(phi) = size(v,1), and !!!!
  !!!! size(v,2) = size(r1) = size(r2)                   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_G_1_2 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_geod), intent(in) :: V(:,:)     ! Geodetic heights (meters)
    integer :: I, Stat
    type(geodLat_t) :: Lat(size(phi))      ! geodetic latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(v)*size(r1)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(r1)) => g%lon1
    g%lon3(1:size(phi),1:size(r1),1:1) => g%lon1
    g%geodLat2(1:size(phi),1:size(r1)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(r1),1:1) => g%geodLat1
    g%geodV2(1:size(v,1),1:size(v,2)) => g%geodV1
    g%geodV3(1:size(v,1),1:size(v,2),1:1) => g%geodV1
    g%phi1 = phi
    g%geodV2%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and geodLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, lat%d )
      g%geodLat2(:,i) = lat%geod()
    end do
  end subroutine Geod_V_G_1_2

  ! Identify families of great circles by two points on each one.  The grids are
  ! incoherent and unstacked, defined on each circle by geodetic height (meters),
  ! and angle (degrees) along each great circle.  The angular spacing of the grid
  ! along each circle is the same, given by Phi.  The third dimension of Phi and
  ! V can be considered an instance or family index.  This is intended to create
  ! a grid in each ruled surface defined by one vertical scan.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! shape(r1) = shape(r2), size(phi) = size(v,1), and !!!!
  !!!! shape(v)(2:3) = shape(r1) = shape(r2)             !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_G_2_3 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:,:), R2(:,:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_geod), intent(in) :: V(:,:,:)   ! Geodetic height, meters
    integer :: I, J, Stat
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(v,2)*size(v,3)) => g%lon1
    g%lon3(1:size(phi),1:size(v,2),1:size(v,3)) => g%lon1
    g%geodLat2(1:size(phi),1:size(v,2)*size(v,3)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(v,2),1:size(v,3)) => g%geodLat1
    g%geodV2(1:size(phi),1:size(v,2)*size(v,3)) => g%geodV1
    g%geodV3(1:size(phi),1:size(v,2),1:size(v,3)) => g%geodV1
    g%phi1 = phi
    g%geodV3%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and GeocLat for points on the great circles from R1 to R2
    do j = 1, size(r1,2)
      do i = 1, size(r1,1)
        ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
        call great_circle_points ( r1(i,j)%lon%d, r1(i,j)%lat, &
          & r2(i,j)%lon%d, r2(i,j)%lat, phi, g%lon3(:,i,j)%d, lat%d )
        g%geodLat3(:,i,j) = lat%geod()
      end do
    end do
  end subroutine Geod_V_G_2_3

  ! Entirely irregular, rank 1, e.g., for a line not defined by reference to a
  ! great circle, or for all the MIFs in a MAF.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_Z_1 ( G, HV )
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_v_zeta), intent(in) :: HV(:)      ! All coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(hv)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(hv,1),1:1) => g%lon1
    g%lon3(1:size(hv,1),1:1,1:1) => g%lon1
    g%geodLat2(1:size(hv,1),1:1) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(hv,1),1:1) => g%zeta1
    g%zeta3(1:size(hv,1),1:1,1:1) => g%zeta1
    g%lon1 = hv%lon
    g%geodLat1%d = hv%lat
    g%zeta1%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_Z_1

  ! Create using geodetic latitude and zeta.
  ! We can't tell just by the fact that both horizontal and vertical are one
  ! dimensional whether it's coherent and stacked, i.e., an outer product, or
  ! neither, i.e., a line through the atmosphere -- it can't be just one.
  ! The order of geolocated values is vertical first, then horizontal.
  ! If Regular is present and false, then
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(h) = size(v)                                 !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_1_1 ( G, H, V, Regular )
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:)         ! Horizontal coordinates
    type(v_zeta), intent(in) :: V(:)         ! Geodetic height, meters
    logical, intent(in), optional :: Regular ! coherent and stacked, default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate( stat, 'zeta1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geodLat2(1:size(h),1:1) => g%geodLat1
    g%geodLat3(1:size(h),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(v),1:1) => g%zeta1
    g%zeta3(1:size(v),1:1,1:1) => g%zeta1
    g%lon1 = h%lon
    g%geodLat1%d = h%lat
    g%zeta1 = v
    g%cartesian = .false.
    if ( present(regular) ) then
      g%coherent = regular
      g%stacked = regular
    else
      g%coherent = .true.
      g%stacked = .true.
    end if
  end subroutine Geod_Z_1_1

  ! Create using the outer product of longitude, geodetic latitude, and
  ! zeta.  This is inherently Cartesian, coherent, and stacked.
  ! The order of geolocated values is vertical, longitude, latitude.
  subroutine Geod_Z_1_1_1 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geodLat_t), intent(in) :: Lat(:)  ! Geodetic latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_zeta), intent(in) :: V(:)       ! Zeta
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geodLat2(1:size(lat),1:1) => g%geodLat1
    g%geodLat3(1:size(lat),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(v),1:1) => g%zeta1
    g%zeta3(1:size(v),1:1,1:1) => g%zeta1
    g%lon1%d = lon%d
    g%geocLat1%d = lat%d
    g%geocV1%v = v%v
    g%cartesian = .true.
    g%coherent = .true.
    g%stacked = .true.
  end subroutine Geod_Z_1_1_1

  ! Create using the outer product of longitude and geodetic latitude, and
  ! height in meters from the Earth center.  This is inherently Cartesian,
  ! incoherent, and stacked.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(lon) and size(v,3) = size(lat)   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_1_1_3 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geodLat_t), intent(in) :: Lat(:)  ! Geodetic latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_geod), intent(in) :: V(:,:,:)   ! Geodetic height, meters
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geodLat2(1:size(lat),1:1) => g%geodLat1
    g%geodLat3(1:size(lat),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(v,1),1:size(v,2)*size(v,3)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%zeta1
  end subroutine Geod_Z_1_1_3

  ! Stacked but not coherent, using longitude, geodetic latitude, and zeta.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(h)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_1_2 ( G, H, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:)       ! Horizontal coordinates
    type(v_zeta), intent(in) :: V(:,:)     ! Zeta
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geodLat2(1:size(h),1:1) => g%geodLat1
    g%geodLat3(1:size(h),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(v,1),1:size(v,2)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:1) => g%zeta1
    g%lon1 = h%lon
    g%geodLat1%d = h%lat
    g%geodV2%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .true.
  end subroutine Geod_Z_1_2

  ! Entirely irregular, rank 2, e.g., for a plane, using longitude, geodetic
  ! latitude, and zeta.
  ! It might actually be coherent and stacked, depending upon values of HV.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_Z_2 ( G, HV )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_v_zeta), intent(in) :: HV(:,:)  ! All coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(hv)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:1) => g%lon1
    g%geodLat2(1:size(hv,1),1:size(hv,2)) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(hv,1),1:size(hv,2)) => g%zeta1
    g%zeta3(1:size(hv,1),1:size(hv,2),1:1) => g%zeta1
    g%lon2 = hv%lon
    g%geodLat2%d = hv%lat
    g%zeta2%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_Z_2

  ! Coherent, maybe stacked.
  ! If it's stacked, H gives coordinates in a horizontal plane.  Otherwise,
  ! H gives coordinates in a vertical plane.
  ! If it's stacked, the order of geolocated values is V, then the
  ! array-element order of H.  If it's not stacked, the order of geolocated
  ! values is the same as the array-element order of H.
  subroutine Geod_Z_2_1 ( G, H, V, Stacked )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:,:)     ! Horizontal coordinates
    type(v_zeta), intent(in) :: V(:)       ! Zeta
    logical, intent(in), optional :: Stacked ! default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(h,1),1:size(h,2)) => g%lon1
    g%lon3(1:size(h,1),1:size(h,2),1:1) => g%lon1
    g%geodLat2(1:size(h,1),1:size(h,2)) => g%geodLat1
    g%geodLat3(1:size(h,1),1:size(h,2),1:1) => g%geodLat1
    g%zeta2(1:size(v,1),1:1) => g%zeta1
    g%zeta3(1:size(v,1),1:1,1:1) => g%zeta1
    g%lon2 = h%lon
    g%geodLat2%d = h%lat
    g%zeta1 = v
    g%cartesian = .false.
    g%coherent = .true.
    if ( present(stacked) ) then
      g%stacked = stacked
    else
      g%stacked = .true.
    end if
  end subroutine Geod_Z_2_1

  ! Entirely irregular, rank 3, using longitude, geodetic latitude, and zeta.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_Z_3 ( G, HV )
    class(geolocation_t), intent(out) :: G  ! Intent(out) causes Destroy_G
    type(h_v_zeta), intent(in) :: HV(:,:,:) ! All coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(hv)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%lon1
    g%geodLat2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%geodLat1
    g%zeta2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%zeta1
    g%zeta3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%zeta1
    g%lon3 = hv%lon
    g%geodLat3%d = hv%lat
    g%zeta3%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_Z_3

  ! Identify a great circle by two points on it.  If Outer is absent, or present
  ! and true, the grid is coherent and stacked, defined by the outer product of
  ! zeta, and angle (degrees) along the great circle.  The angular spacing
  ! of the grid along each circle is the same, given by Phi.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  ! If outer is present and false, the grid is one-dimensional, and
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(phi) = size(v).                              !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! the order of geolocated values is the same as the array-element order of Phi.
  subroutine Geod_Z_G_0_1 ( G, R1, R2, Phi, V, Outer )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1, R2     ! Points on the great circle
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_zeta), intent(in) :: V(:)       ! Zeta
    logical, intent(in), optional :: Outer ! Outer product, default YES
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    integer :: Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(phi)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:1) => g%lon1
    g%lon3(1:size(phi),1:1,1:1) => g%lon1
    g%geodLat2(1:size(phi),1:1) => g%geodLat1
    g%geodLat3(1:size(phi),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(v),1:1) => g%zeta1
    g%zeta3(1:size(v),1:1,1:1) => g%zeta1
    g%phi1 = phi
    g%zeta1 = v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    if ( present(outer) ) then
      g%coherent = outer
      g%stacked = outer
    end if
    ! Compute Lon and GeocLat for points on the great circle from R1 to R2
    ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
    call great_circle_points ( r1%lon%d, r1%lat, r2%lon%d, r2%lat, phi, &
      & g%lon1%d, lat%d )
    g%geodLat1 = lat%geod()
  end subroutine Geod_Z_G_0_1

  ! Identify great circles by two points on each one.  The grid is coherent and
  ! stacked, defined on each circle by the outer product of zeta, and angle
  ! (degrees) along each great circle.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_G_1_1 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees) - same
                                           ! on all circles
    type(v_zeta), intent(in) :: V(:)       ! zeta -- same on all circles
    integer :: I, Stat
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(phi)*size(r1)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(r1)) => g%lon1
    g%lon3(1:size(phi),1:size(r1),1:1) => g%lon1
    g%geodLat2(1:size(phi),1:size(r1)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(r1),1:1) => g%geodLat1
    g%zeta2(1:size(v),1:1) => g%zeta1
    g%zeta3(1:size(v),1:1,1:1) => g%zeta1
    g%phi1 = phi
    g%zeta1 = v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    ! Compute Lon and geodLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, lat%d )
      g%geodLat2(:,i) = lat%geod()
    end do
  end subroutine Geod_Z_G_1_1

  ! Identify great circles by two points on each one.  The grid is incoherent and
  ! unstacked, defined on each circle by zeta, and angle
  ! (degrees) along each great circle.  The angular spacing
  ! of the grid along each circle is the same, given by Phi.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2), size(phi) = size(v,1), and !!!!
  !!!! size(v,2) = size(r1) = size(r2)                   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_G_1_2 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_zeta), intent(in) :: V(:,:)     ! Zeta
    integer :: I, Stat
    type(geocLat_t) :: Lat(size(phi))      ! geocentric latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(v,2)) => g%lon1
    g%lon3(1:size(phi),1:size(v,2),1:1) => g%lon1
    g%geodLat2(1:size(phi),1:size(v,2)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(v,2),1:1) => g%geodLat1
    g%zeta2(1:size(v,1),1:size(v,2)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:1) => g%zeta1
    g%phi1 = phi
    g%zeta2 = v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and geodLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, lat%d )
      g%geodLat2(:,i) = lat%geod()
    end do
  end subroutine Geod_Z_G_1_2

  ! Identify families of great circles by two points on each one.  The grids are
  ! incoherent and unstacked, defined on each circle by zeta, and angle (degrees)
  ! along each great circle.  The angular spacing of the grid along each circle
  ! is the same, given by Phi.  The third dimension of Phi and V can be
  ! considered an instance or family index.  This is intended to create a grid in
  ! each ruled surface defined by one vertical scan.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! shape(r1) = shape(r2), size(phi) = size(v,1), and !!!!
  !!!! shape(v)(2:3) = shape(r1) = shape(r2)             !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_G_2_3 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:,:), R2(:,:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_zeta), intent(in) :: V(:,:,:)   ! Zeta
    integer :: I, J, Stat
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(v,2)*size(v,3)) => g%lon1
    g%lon3(1:size(phi),1:size(v,2),1:size(v,3)) => g%lon1
    g%geodLat2(1:size(phi),1:size(v,2)*size(v,3)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(v,2),1:size(v,3)) => g%geodLat1
    g%zeta2(1:size(v,1),1:size(v,2)*size(v,3)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%zeta1
    g%phi1 = phi
    g%zeta3 = v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and GeocLat for points on the great circles from R1 to R2
    do j = 1, size(r1,2)
      do i = 1, size(r1,1)
        ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
        call great_circle_points ( r1(i,j)%lon%d, r1(i,j)%lat, &
          & r2(i,j)%lon%d, r2(i,j)%lat, phi, g%lon3(:,i,j)%d, lat%d )
        g%geodLat3(:,i,j) = lat%geod()
      end do
    end do
  end subroutine Geod_Z_G_2_3

  ! Create using ECR in meters
  ! Entirely irregular, rank 1, e.g., for a line not defined by reference to a
  ! great circle, or for all the MIFs in a MAF.
  ! The order of geolocated values is the same as the array-element order of P.
  subroutine Create_P_1 ( G, P )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(ecr_t), intent(in) :: P(:)        ! All the coordinates, ECR, meters
    integer :: Stat
    allocate ( g%p1, source=p, stat=stat )
    call test_allocate ( stat, moduleName, 'P1', 1, size(p), storage_size(g%p1)/8 )
    g%p2(1:size(p),1:1) => g%p1
    g%p3(1:size(p),1:1,1:1) => g%p1
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Create_P_1

  ! Entirely irregular, rank 2, e.g., for a plane.
  ! The order of geolocated values is the same as the array-element order of P.
  subroutine Create_P_2 ( G, P )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(ecr_t), intent(in) :: P(:,:)      ! All the coordinates, ECR, meters
    integer :: Stat
    allocate ( g%p1, source=reshape(p,[size(p)]), stat=stat )
    call test_allocate ( stat, moduleName, 'P1', 1, size(p), storage_size(g%p1)/8 )
    g%p2(1:size(p,1),1:size(p,2)) => g%p1
    g%p3(1:size(p),1:size(p,2),1:1) => g%p1
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Create_P_2

  ! Entirely irregular, rank 3.
  ! The order of geolocated values is the same as the array-element order of P.
  subroutine Create_P_3 ( G, P )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(ecr_t), intent(in) :: P(:,:,:)    ! All the coordinates, ECR, meters
    integer :: Stat
    allocate ( g%p1, source=reshape(p,[size(p)]), stat=stat )
    call test_allocate ( stat, moduleName, 'P1', 1, size(p), storage_size(g%p1)/8 )
    g%p2(1:size(p,1),1:size(p,2)*size(p,3)) => g%p1
    g%p3(1:size(p),1:size(p,2),1:size(p,3)) => g%p1
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Create_P_3

  ! Longitude
  type(lon_t) function Lon ( G, I, J, K )
    use Constants, only: Rad2Deg
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I            ! Lon index if Cartesian
    integer, intent(in), optional :: J  ! Lat index if Cartesian
    integer, intent(in), optional :: K  ! Height index if not stacked
    real(rg) :: XYZ(3)
    if ( associated(g%lon1) ) then
      if ( present(j) ) then
        if ( present(k) ) then
          lon = g%lon3(i,merge(1,j,g%cartesian),merge(1,k,g%stacked))
        else
          lon = g%lon2(i,merge(1,j,g%cartesian))
        end if
      else if ( present(k) ) then
        lon = g%lon3(i,1,merge(1,k,g%stacked))
      else
        lon = g%lon1(i)
      end if
    else if ( associated(g%p1) ) then
      xyz = g%ecr(i,j,k)
      lon%d = atan2(xyz(2),xyz(1)) * rad2deg
    else ! nothing associated
      lon%d = -huge(0.0_rg)
    end if
  end function Lon

  ! Geocentric latitude
  type(geocLat_t) function GeocLat ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I            ! Lon index if Cartesian, or
                                        ! Lat index if J is not present
    integer, intent(in), optional :: J  ! Lat index if Cartesian
    integer, intent(in), optional :: K  ! Height index if not stacked
    type(geodLat_t) :: Geod
    real(rg) :: XYZ(3)
    if ( associated(g%geocLat1) ) then
      if ( present(j) ) then
        if ( present(k) ) then
          geocLat = g%geocLat3(merge(1,i,g%cartesian),j,merge(1,k,g%stacked))
        else
          geocLat = g%geocLat2(merge(1,i,g%cartesian),j)
        end if
      else if ( present(k) ) then
        geocLat = g%geocLat3(i,1,merge(1,k,g%stacked))
      else
        geocLat = g%geocLat1(i)
      end if
    else if ( associated(g%geodLat1) ) then
      geod = g%geodLat(i,j,k)
      geocLat = geod%geoc()
    else if ( associated(g%p1) ) then
      xyz = g%ecr(i,j,k)
      geocLat%d = asin(xyz(3)/norm2(xyz(1:2)))
    else ! nothing associated
      geocLat%d = -huge(0.0_rg)
    end if
  end function GeocLat

  ! Geodetic latitude
  type(geodLat_t) function GeodLat ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I            ! Lon index if Cartesian, or
                                        ! Lat index if J is not present
    integer, intent(in), optional :: J  ! Lat index if Cartesian
    integer, intent(in), optional :: K  ! Height index if not stacked
    type(geocLat_t) :: Geoc
    if ( associated(g%geodLat1) ) then
      if ( present(j) ) then
        if ( present(k) ) then
          geodLat = g%geodLat3(merge(1,i,g%cartesian),j,merge(1,k,g%stacked))
        else
          geodLat = g%geodLat2(merge(1,i,g%cartesian),j)
        end if
      else if ( present(k) ) then
        geodLat = g%geodLat3(i,1,merge(1,k,g%stacked))
      else
        geodLat = g%geodLat1(i)
      end if
    else if ( associated(g%geocLat1) .or. associated(g%p1) ) then
      geoc = g%geocLat(i,j,k)
      geodLat = geoc%geod()
    else ! nothing associated
      geodLat%d = -huge(0.0_rg)
    end if
  end function GeodLat

  ! Geocentric height, meters from the Earth center
  type(v_geoc) function GeocV ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I
    integer, intent(in), optional :: J
    integer, intent(in), optional :: K
    type(h_v_geoc) :: Geoc
    type(h_v_geod) :: Geod
    type(v_geod) :: GeodV
    type(geodLat_t) :: LatGeod
    type(lon_t) :: Lon
    if ( g%coherent ) then
      if ( associated(g%geocV1) ) then
        GeocV = g%geocV1(k)
      else if ( associated(g%geodV1) ) then
        ! Convert [ longitude, geodetic latitude, geodetic height ] to geocentric.
        geod = h_v_geod ( lon=g%lon1(k), lat=g%geodLat1(k)%d, v=g%geodV1(k)%v )
        geoc = geod%geocV()
        GeocV%v = geoc%v
      else ! must be Zeta
        ! We would need the hydrostatic model to get geodV from Zeta, after
        ! which we could get GeocV from geodV
        GeocV%v = -huge(0.0_rg)
      end if
    else
      if ( associated(g%geocV1) ) then
        if ( present(j) ) then
          if ( present(k) ) then
            GeocV = g%geocV3(i,j,k)
          else
            GeocV = g%geocV2(i,j)
          end if
        else if ( present(k) ) then
          GeocV = g%geocV3(i,1,k)
        else
          GeocV = g%geocV1(i)
        end if
      else if ( associated(g%geodV1) ) then
        ! Convert [ longitude, geodetic latitude, geodetic height ] to geocentric.
        latGeod = g%geodLat(i,j,k)
        geodV = g%geodV(i,j,k)
        lon = g%lon(i,j,k)
        geod = h_v_geod ( lon=lon, lat=latGeod%d, v=geodV%v )
        geoc = geod%geocV()
        GeocV%v = geoc%v
      else if ( associated(g%p1) ) then ! ECR
        GeocV%v = norm2(g%ecr(i,j,k))
      else ! must be Zeta
        ! We would need the hydrostatic model to get geodV from Zeta, after
        ! which we could get GeocV from geodV
        GeocV%v = -huge(0.0_rg)
      end if
    end if
  end function GeocV

  ! Geodetic height, meters above sea level
  type(v_geod) function GeodV ( G, I, J, K )
    use Geometry, only: XYZ_To_Geod
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I
    integer, intent(in), optional :: J
    integer, intent(in), optional :: K
    real(rg) :: Geod(3)
    real(rg) :: XYZ(3)
    if ( associated(g%geodV1) ) then
      if ( g%coherent ) then
        if ( present(k) ) then
          geodV = g%geodV1(k)
        else if ( present(j) ) then
          geodV = g%geodV1(j)
        else
          geodV = g%geodV1(i)
        end if
      else
        if ( present(j) ) then
          if ( present(k) ) then
            geodV = g%geodV3(i,j,k)
          else
            geodV = g%geodV2(i,j)
          end if
        else if ( present(k) ) then
          geodV = g%geodV3(i,1,k)
        else
          geodV = g%geodV1(i)
        end if
      end if
    else if ( associated(g%geocV1) ) then
      xyz = g%ecr(i,j,k)
      geod = xyz_to_geod(xyz)
      geodV%v = geod(3)
    else ! must be Zeta
      ! We would need the hydrostatic model to get geodV from Zeta
      geodV%v = -huge(0.0_rg)
    end if
  end function GeodV

  ! Zeta
  type(v_zeta) function Zeta ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I
    integer, intent(in), optional :: J
    integer, intent(in), optional :: K
    if ( .not. associated(g%zeta1) ) then
      ! We would need the hydrostatic model to get Zeta from geodV
      zeta%v = -huge(0.0_rg)
      return
    end if
    if ( g%coherent ) then
      zeta = g%zeta1(k)
    else
      if ( present(j) ) then
        if ( present(k) ) then
          zeta = g%zeta3(i,j,k)
        else
          zeta = g%zeta2(i,j)
        end if
      else if ( present(k) ) then
        zeta = g%zeta3(i,1,k)
      else
        zeta = g%zeta1(i)
      end if
    end if
  end function Zeta

  ! Geocentric location (lon degrees, geoc lat degrees, geoc height meters)
  type(h_v_geoc) function Loc_Geoc ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I, J, K
    type(v_geoc) :: GeocV
    type(geocLat_t) :: LatGeoc
    loc_geoc%lon = g%lon(i,j,k)
    latGeoc = g%geocLat(i,j,k)
    loc_geoc%lat = latGeoc%d
    geocV = g%geocV(i,j,k)
    loc_geoc%v = geocV%v
  end function Loc_Geoc

  ! Geodetic location (lon degrees, geod lat degrees, geod height meters)
  type(h_v_geod) function Loc_Geod ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I, J, K
    type(v_geod) :: GeodV
    type(geodLat_t) :: LatGeod
    loc_geod%lon = g%lon(i,j,k)
    latGeod = g%geodLat(i,j,k)
    loc_geod%lat = latGeod%d
    geodV = g%geodV(i,j,k)
    loc_geod%v = geodV%v
  end function Loc_Geod

  ! Geodetic/Zeta location (lon degrees, geod lat degrees, zeta)
  type(h_v_zeta) function Loc_Zeta ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I, J, K
    type(geodLat_t) :: LatGeod
    type(v_zeta) :: Zeta
    loc_zeta%lon = g%lon(i,j,k)
    latGeod = g%geodLat(i,j,k)
    loc_zeta%lat = latGeod%d
    zeta = g%zeta(i,j,k)
    loc_zeta%v = zeta%v
  end function Loc_Zeta

  ! ECR coordinates, meters
  function ECR ( G, I, J, K )
    use Geometry, only: GeodToECRm, GeocToECRu
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I            ! Lon index if Cartesian, or
                                        ! Lat index if J is not present
    integer, intent(in), optional :: J  ! Lat index if Cartesian
    integer, intent(in), optional :: K  ! Height index
    real(rg) :: ECR(3)
    type(v_geoc) :: GeocV
    type(v_geod) :: GeodV
    type(geocLat_t) :: LatGeoc
    type(geodLat_t) :: LatGeod
    type(lon_t) :: Lon
    if ( associated(g%p1) ) then
      if ( present(j) ) then
        if ( present(k) ) then
          ecr = g%p3(i,j,k)%xyz
        else
          ecr = g%p2(i,j)%xyz
        end if
      else if ( present(k) ) then
        ecr = g%p3(i,1,k)%xyz
      else
        ecr = g%p1(i)%xyz
      end if
    else if ( associated(g%geodV1) ) then
      ! Convert [ longitude, geodetic latitude, geodetic height] to ECR (meters)
      geodV = g%geodV(i,j,k)
      latGeod = g%geodLat(i,j,k)
      lon = g%lon(i,j,k)
      ecr = geodToECRm ( [ lon%d, latGeod%d, geodV%v ] )
    else if ( associated(g%geocV1) ) then
      ! Convert [ longitude, geocentric latitude, geocentric height] to ECR
      geocV = g%geocV(i,j,k)
      latGeoc = g%geocLat(i,j,k)
      lon = g%lon(i,j,k)
      ecr = GeocToECRu ( latGeoc%d, lon%d ) * geocV%v
    else
      ecr = [-huge(0.0_rg),-huge(0.0_rg),-huge(0.0_rg)]
    end if
  end function ECR

  ! Fill geocentric latitude and height components.
  subroutine Fill_Geoc ( G )
    class(geolocation_t), intent(inout) :: G
    integer :: I, J, K, Stat
    if ( associated(g%geocLat1) ) return ! Already have it
    if ( associated(g%geodLat1) ) then
      if ( .not. associated(g%geodV1) ) return ! must be zeta, can't convert
      allocate ( g%geocLat1(size(g%geodLat1)), stat=stat )
      call test_allocate ( stat, 'geocLat1', moduleName )
      allocate ( g%geocV1(size(g%geodV1)), stat=stat )
      call test_allocate ( stat, 'geocV1', moduleName )
    else if ( associated(g%P1) ) then
      allocate ( g%geocLat1(size(g%p1)), stat=stat )
      call test_allocate ( stat, 'geocLat1', moduleName )
      allocate ( g%geocV1(size(g%p1)), stat=stat )
      call test_allocate ( stat, 'geocV1', moduleName )
    else
      return ! can't do it
    end if
    g%geocLat2(1:size(g%geodLat2,1),1:size(g%geodLat2,2)) => g%geocLat1
    g%geocLat3(1:size(g%geodLat3,1),1:size(g%geodLat3,2),1:size(g%geodLat3,3)) => g%geocLat1
    g%geocV2(1:size(g%geodV2,1),1:size(g%geodV2,2)) => g%geocV1
    g%geocV3(1:size(g%geodV3,1),1:size(g%geodV3,2),1:size(g%geodV3,3)) => g%geocV1
    if ( g%coherent ) then
      do k = 1, size(g%geocV1,1)
        do j = 1, size(g%lon3,2)
          do i = 1, size(g%lon3,1)
            g%geocLat3(i,j,1) = g%geocLat(i,j,1)
            g%lon3(i,j,1) = g%lon(i,j,1)
            g%geocV3(i,j,k) = g%GeocV(i,j,k)
          end do
        end do
      end do
    else
      do k = 1, size(g%geocV3,3)
        do j = 1, size(g%lon3,2)
          do i = 1, size(g%lon3,1)
            g%geocLat3(i,j,k) = g%geocLat(i,j,k)
            g%lon3(i,j,k) = g%lon(i,j,k)
            g%geocV3(i,j,k) = g%GeocV(i,j,k)
          end do
        end do
      end do
    end if
  end subroutine Fill_Geoc

  ! Fill geodetic latitude and height components.
  subroutine Fill_Geod ( G )
    class(geolocation_t), intent(inout) :: G
    integer :: I, J, K, Stat
    if ( associated(g%geodLat1) ) return ! Already have it
    if ( associated(g%geocLat1) ) then
      if ( .not. associated(g%geocV1) ) return ! must be zeta, can't convert
      allocate ( g%geodLat1(size(g%geocLat1)), stat=stat )
      call test_allocate ( stat, 'geodLat1', moduleName )
      allocate ( g%geodV1(size(g%geocV1)), stat=stat )
      call test_allocate ( stat, 'geodV1', moduleName )
    else if ( associated(g%P1) ) then
      allocate ( g%geodLat1(size(g%P1)), stat=stat )
      call test_allocate ( stat, 'geodLat1', moduleName )
      allocate ( g%geodV1(size(g%P1)), stat=stat )
      call test_allocate ( stat, 'geodV1', moduleName )
    else
      return ! can't do it
    end if
    g%geodLat2(1:size(g%geocLat2,1),1:size(g%geocLat2,2)) => g%geodLat1
    g%geodLat3(1:size(g%geocLat3,1),1:size(g%geocLat3,2),1:size(g%geocLat3,3)) => g%geodLat1
    g%geodV2(1:size(g%geocV2,1),1:size(g%geocV2,2)) => g%geodV1
    g%geodV3(1:size(g%geocV3,1),1:size(g%geocV3,2),1:size(g%geocV3,3)) => g%geodV1
    if ( g%coherent ) then
      do k = 1, size(g%geodV1,1)
        do j = 1, size(g%lon3,2)
          do i = 1, size(g%lon3,1)
            g%geodLat3(i,j,1) = g%geodLat(i,j,1)
            g%lon3(i,j,1) = g%lon(i,j,1)
            g%geodV3(i,j,k) = g%geodV(i,j,k)
          end do
        end do
      end do
    else
      do k = 1, size(g%geodV3,3)
        do j = 1, size(g%lon3,2)
          do i = 1, size(g%lon3,1)
            g%geodLat3(i,j,k) = g%geodLat(i,j,k)
            g%lon3(i,j,k) = g%lon(i,j,k)
            g%geodV3(i,j,k) = g%geodV(i,j,k)
          end do
        end do
      end do
    end if
  end subroutine Fill_Geod

  ! Fill ecr coordinates
  subroutine Fill_ECR ( G )
    class(geolocation_t), intent(inout) :: G
    integer :: I, J, K, Stat
    if ( associated(g%P1) ) return ! Already have it
    if ( associated(g%zeta1) ) return ! Can't do it
    if ( associated(g%geocV1) ) then
      k = merge(size(g%geocV1,1),size(g%lon3,3),g%coherent)
    else if ( associated(g%geodv1) ) then
      k = merge(size(g%geodV1,1),size(g%lon3,3),g%coherent)
    end if
    call g%destroy_g_p1
    allocate ( g%p1(size(g%lon3,1)*size(g%lon3,2)*k), stat=stat )
    call test_allocate ( stat, moduleName, 'P1', &
      & 1, size(g%lon3,1)*size(g%lon3,2)*k, storage_size(g%p1)/8 )
    g%p2(1:size(g%lon3,1),1:size(g%lon3,2)) => g%p1
    g%p3(1:size(g%lon3,1),1:size(g%lon3,2),1:k) => g%p1
    do k = 1, size(g%P3,3)
      do j = 1, size(g%P3,2)
        do i = 1, size(g%P3,1)
          g%p3(i,j,k)%xyz = g%ecr(i,j,k)
        end do
      end do
    end do
  end subroutine Fill_ECR

  ! Insert geocentric height, meters from the Earth center.
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geocentric height.
  ! If you already have geodetic height, use Fill_Geoc.
  ! If the grid is stacked and zeta, geocentric height doesn't make sense!
  subroutine Insert_Geoc_1 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geoc), intent(in) :: V(:)
    integer :: Stat
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%GeocV1', moduleName )
    g%geocV2(1:size(v),1:1) => g%geocV1
    g%geocV3(1:size(v),1:1,1:1) => g%geocV1
    g%geocV1%v = v%v
  end subroutine Insert_Geoc_1

  ! Insert geocentric height, meters from the Earth center
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geocentric height.
  ! If you already have geodetic height, use Fill_Geoc.
  ! If the grid is stacked and zeta, geocentric height doesn't make sense!
  subroutine Insert_Geoc_2 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geoc), intent(in) :: V(:,:)
    integer :: Stat
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%GeocV1', moduleName )
    g%geocV2(1:size(v,1),1:size(v,2)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:1) => g%geocV1
    g%geocV2%v = v%v
  end subroutine Insert_Geoc_2

  ! Insert geocentric height, meters from the Earth center
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geocentric height.
  ! If you already have geodetic height, use Fill_Geoc.
  ! If the grid is stacked and zeta, geocentric height doesn't make sense!
  subroutine Insert_Geoc_3 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geoc), intent(in) :: V(:,:,:)
    integer :: Stat
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%GeocV1', moduleName )
    g%geocV2(1:size(v,1),1:size(v,2)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%geocV1
    g%geocV3%v = v%v
  end subroutine Insert_Geoc_3

  ! Insert geodetic height, meters above sea level
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geodetic height.
  ! If you already have geocentric height, use Fill_Geod.
  subroutine Insert_Geod_1 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geod), intent(in) :: V(:)
    integer :: Stat
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%geodV1', moduleName )
    g%geodV2(1:size(v,1),1:1) => g%geodV1
    g%geodV3(1:size(v,1),1:1,1:1) => g%geodV1
    g%geodV1%v = v%v
  end subroutine Insert_Geod_1

  ! Insert geodetic height, meters above sea level
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geodetic height.
  ! If you already have geocentric height, use Fill_Geod.
  subroutine Insert_Geod_2 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geod), intent(in) :: V(:,:)
    integer :: Stat
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%geodV1', moduleName )
    g%geodV2(1:size(v,1),1:size(v,2)) => g%geodV1
    g%geodV3(1:size(v,1),1:size(v,2),1:1) => g%geodV1
    g%geodV2%v = v%v
  end subroutine Insert_Geod_2

  ! Insert geodetic height, meters above sea level
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geodetic height.
  ! If you already have geocentric height, use Fill_Geod.
  subroutine Insert_Geod_3 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geod), intent(in) :: V(:,:,:)
    integer :: Stat
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%geodV1', moduleName )
    g%geodV2(1:size(v,1),1:size(v,2)) => g%geodV1
    g%geodV3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%geodV1
    g%geodV3%v = v%v
  end subroutine Insert_Geod_3

  ! Insert Zeta
  ! This assumes you already have geocentric or geodetic height, and have used
  ! a hydrostatic model to compute zeta.
  ! If the grid is stacked and geocentric, zeta doesn't make sense!
  subroutine Insert_Zeta_1 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_zeta), intent(in) :: V(:)
    integer :: Stat
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%zeta1', moduleName )
    g%zeta2(1:size(v,1),1:1) => g%zeta1
    g%zeta3(1:size(v,1),1:1,1:1) => g%zeta1
    g%zeta1 = v
  end subroutine Insert_Zeta_1

  ! Insert Zeta
  ! This assumes you already have geocentric or geodetic height, and have used
  ! a hydrostatic model to compute zeta.
  ! If the grid is stacked and geocentric, zeta doesn't make sense!
  subroutine Insert_Zeta_2 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_zeta), intent(in) :: V(:,:)
    integer :: Stat
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%zeta1', moduleName )
    g%zeta2(1:size(v,1),1:size(v,2)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:1) => g%zeta1
    g%zeta2 = v
  end subroutine Insert_Zeta_2

  ! Insert Zeta
  ! This assumes you already have geocentric or geodetic height, and have used
  ! a hydrostatic model to compute zeta.
  ! If the grid is stacked and geocentric, zeta doesn't make sense!
  subroutine Insert_Zeta_3 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_zeta), intent(in) :: V(:,:,:)
    integer :: Stat
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%zeta1', moduleName )
    g%zeta2(1:size(v,1),1:size(v,2)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%zeta1
    g%zeta3 = v
  end subroutine Insert_Zeta_3

  ! Delete geocentric latitudes and geocentric vertical coordinates
  subroutine Delete_Geoc ( G )
    class(geolocation_t), intent(inout) :: G
    if ( associated(g%geocLat1) ) deallocate ( g%geocLat1 )
    nullify ( g%geocLat2, g%geocLat3 )
    if ( associated(g%geocV1) ) deallocate ( g%geocV1 )
    nullify ( g%geocV2, g%geocV3 )
  end subroutine Delete_Geoc

  ! Delete geodetic latitudes and geodetic vertical coordinates
  subroutine Delete_Geod ( G )
    class(geolocation_t), intent(inout) :: G
    if ( associated(g%geodV1) ) deallocate ( g%geodV1 )
    nullify ( g%geodV2, g%geodV3 )
    if ( associated(g%zeta1) ) return ! Need to keep lat
    if ( associated(g%geodLat1) ) deallocate ( g%geodLat1 )
    nullify ( g%geodLat2, g%geodLat3 )
  end subroutine Delete_Geod

  ! Delete geodetic latitudes and zeta
  subroutine Delete_Zeta ( G )
    class(geolocation_t), intent(inout) :: G
    if ( associated(g%zeta1) ) deallocate ( g%zeta1 )
    nullify ( g%zeta2, g%zeta3 )
    if ( associated(g%geodV1) ) return ! Need to keep lat
    if ( associated(g%geodLat1) ) deallocate ( g%geodLat1 )
    nullify ( g%geodLat2, g%geodLat3 )
  end subroutine Delete_Zeta

  ! Delete ECR coordinates
  subroutine Delete_ECR ( G )
    class(geolocation_t), intent(inout) :: G
    call g%destroy_g_p1
    nullify ( g%P2, g%P3 )
  end subroutine Delete_ECR

! impure elemental &
  subroutine Destroy_G ( G )
    type(geolocation_t), intent(inout) :: G
    integer :: Stat
    deallocate ( g%lon1, stat=stat )
    call test_deallocate ( stat, 'lon1', moduleName )
    deallocate ( g%geocLat1, stat=stat )
    call test_deallocate ( stat, 'geocLat1', moduleName )
    call deallocate_test ( g%phi1, 'geocLat1', moduleName )
    deallocate ( g%geodLat1, stat=stat )
    call test_deallocate ( stat, 'geodLat1', moduleName )
    deallocate ( g%geocV1, stat=stat )
    call test_deallocate ( stat, 'geocV1', moduleName )
    deallocate ( g%geodV1, stat=stat )
    call test_deallocate ( stat, 'geodV1', moduleName )
    deallocate ( g%zeta1, stat=stat )
    call test_deallocate ( stat, 'zeta1', moduleName )
    call g%destroy_g_p1
    nullify ( g%lon2, g%lon3, g%geocLat2, g%geocLat3, g%geodLat2, g%geodLat3 )
    nullify ( g%phi2, g%phi3, g%geocV2, g%geocV3, g%geodV2, g%geodV3 )
    nullify ( g%zeta2, g%zeta3, g%p2, g%p3 )
  end subroutine Destroy_G

  subroutine Destroy_G_P1 ( G )
    class(geolocation_t), intent(inout) :: G
    integer :: S, Stat
    if ( associated(g%p1) ) then
      s = size(g%p1) * storage_size(g%p1) / 8
      deallocate ( g%p1, stat=stat )
      call test_deallocate ( stat, moduleName, 'P1', s )
    end if
  end subroutine Destroy_G_P1

! impure elemental &
  subroutine Explicit_Destroy_G ( Not_Used )
    class(geolocation_t), intent(out) :: Not_Used ! Intent(out) causes Destroy_G
  end subroutine Explicit_Destroy_G

!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Geolocation_m.f90,v 2.6 2016/09/23 01:49:58 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Geolocation_m

! $Log: Geolocation_m.f90,v $
! Revision 2.6  2016/09/23 01:49:58  vsnyder
! All the QTM stuff is in QTM_Tree instead of here
!
! Revision 2.5  2016/03/25 00:45:25  vsnyder
! Change type of Lon components from real(rg) to type(lon_t).  Change type
! of GeodLat components from real(rg) to type(geodLat_t).  Change type of
! GeocV components from real(rg) to type(v_geoc).  Change type of GeodV
! components from real(rg) to type(v_geod).  Change type of Zeta
! components from real(rg) to type(v_zeta).  Need to allocate these guys
! using an allocate statement, and then use test_allocate, and similarly
! for deallocating them.
!
! Revision 2.4  2016/02/26 02:02:00  vsnyder
! Make Coeff_t and QTM_tree_t public.  Add QTM_Geoc, QTM_Geod and QTM_Lats
! components.  Spiff some comments.
!
! Revision 2.3  2016/01/26 19:55:21  vsnyder
! Attach QTM
!
! Revision 2.2  2016/01/23 02:47:33  vsnyder
! Use geolocation types and type-bound procedures from Geolocation_0
!
! Revision 2.1  2015/11/14 18:02:37  vsnyder
! Initial commit
!
@


2.6
log
@All the QTM stuff is in QTM_Tree instead of here
@
text
@a24 1
  use QTM_m, only: ZOT_t
d2327 1
a2327 1
       "$Id: Geolocation_m.f90,v 2.5 2016/03/25 00:45:25 vsnyder Exp $"
d2337 3
@


2.5
log
@Change type of Lon components from real(rg) to type(lon_t).  Change type
of GeodLat components from real(rg) to type(geodLat_t).  Change type of
GeocV components from real(rg) to type(v_geoc).  Change type of GeodV
components from real(rg) to type(v_geod).  Change type of Zeta
components from real(rg) to type(v_zeta).  Need to allocate these guys
using an allocate statement, and then use test_allocate, and similarly
for deallocating them.
@
text
@a89 8
    type(ZOT_t), allocatable :: QTM_ZOT(:)   ! Horizontal coordinates of QTM.
    type(h_geoc), allocatable :: QTM_Geoc(:) ! Horizontal coordinates of QTM;
                                             ! Same size as QTM_ZOT.
    type(h_geod), allocatable :: QTM_Geod(:) ! Horizontal coordinates of QTM;
                                             ! Same size as QTM_ZOT.
    class(lat_t), allocatable :: QTM_Lats(:) ! Unique geocentric or geodetic
                                             ! latitudes in the QTM, depending
                                             ! upon QTM_Is_Geod.
a94 1
    logical :: QTM_Is_Geod = .false. ! QTM latitudes are geodetic
d2328 1
a2328 1
       "$Id: Geolocation_m.f90,v 2.4 2016/02/26 02:02:00 vsnyder Exp $"
d2338 9
@


2.4
log
@Make Coeff_t and QTM_tree_t public.  Add QTM_Geoc, QTM_Geod and QTM_Lats
components.  Spiff some comments.
@
text
@d19 5
a23 3
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Test_Allocate
  use Geolocation_0, only: ECR_t, H_t, H_Geoc, H_Geod, Lat_t, GeocLat_t, GeodLat_t, &
    & Lon_t, H_V_t, H_V_Geoc, H_V_Geod, H_V_Zeta, V_T, V_Geoc, V_Geod, V_Zeta, RG
d56 9
a64 9
    real(rg), pointer, contiguous :: Lon1(:)=> null()          ! V*H*H
    real(rg), pointer, contiguous :: Lon2(:,:) => null()       ! => Lon1, V x H*H
    real(rg), pointer, contiguous :: Lon3(:,:,:) => null()     ! => Lon1, V x H x H
    real(rg), pointer, contiguous :: GeocLat1(:) => null()     ! V*H*H
    real(rg), pointer, contiguous :: GeocLat2(:,:) => null()   ! => geodLat1, V x H*H
    real(rg), pointer, contiguous :: GeocLat3(:,:,:) => null() ! => geodLat1, V x H x H
    real(rg), pointer, contiguous :: GeodLat1(:) => null()     ! V*H*H
    real(rg), pointer, contiguous :: GeodLat2(:,:) => null()   ! => geocLat1, V x H*H
    real(rg), pointer, contiguous :: GeodLat3(:,:,:) => null() ! => geocLat1, V x H x H
d71 2
a72 2
    real(rg), pointer, contiguous :: GeocV1(:) => null()       ! V*H*H or V*size(QTM_ZOT)
    real(rg), pointer, contiguous :: GeocV2(:,:) => null()     ! => GeocV1, V x H*H or
d74 1
a74 1
    real(rg), pointer, contiguous :: GeocV3(:,:,:) => null()   ! => GeocV1, V x H x H
d76 2
a77 2
    real(rg), pointer, contiguous :: GeodV1(:) => null()       ! V*H*H or V*size(QTM_ZOT)
    real(rg), pointer, contiguous :: GeodV2(:,:) => null()     ! => GeodV1, V x H*H or
d79 1
a79 1
    real(rg), pointer, contiguous :: GeodV3(:,:,:) => null()   ! => GeodV1, V x H x H
d81 3
a83 3
    real(rg), pointer, contiguous :: Zeta1(:) => null()        ! V*H*H
    real(rg), pointer, contiguous :: Zeta2(:,:) => null()      ! => Zeta1, V x H*H
    real(rg), pointer, contiguous :: Zeta3(:,:,:) => null()    ! => Zeta1, V x H x H
d285 7
a291 3
    call allocate_test ( g%lon1, size(hv), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(hv), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(hv), 'geocV1', moduleName )
d299 2
a300 2
    g%geocLat1 = hv%lat
    g%geocV1 = hv%v
d327 7
a333 3
    call allocate_test ( g%lon1, size(h), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(h) , 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(v), 'geocV1', moduleName )
d340 3
a342 3
    g%lon1= h%lon
    g%geocLat1 = h%lat
    g%geocV1 = v%v
d362 7
a368 3
    call allocate_test ( g%lon1, size(lon), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(lat), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(v), 'geocV1', moduleName )
d375 3
a377 3
    g%lon1= lon%d
    g%geocLat1 = lat%d
    g%geocV1 = v%v
d398 7
a404 3
    call allocate_test ( g%lon1, size(lon), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(lat), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(v), 'geocV1', moduleName )
d426 7
a432 3
    call allocate_test ( g%lon1, size(h), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(h), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(v), 'geocV1', moduleName )
d440 2
a441 2
    g%geocLat1 = h%lat
    g%geocV2 = v%v
d454 7
a460 3
    call allocate_test ( g%lon1, size(hv), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(hv), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(hv), 'geocV1', moduleName )
d468 2
a469 2
    g%geocLat2 = hv%lat
    g%geocV2 = hv%v
d486 7
a492 3
    call allocate_test ( g%lon1, size(h), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(h), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(v), 'geocV1', moduleName )
d500 2
a501 2
    g%geocLat2 = h%lat
    g%geocV1 = v%v
d517 7
a523 3
    call allocate_test ( g%lon1, size(hv), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(hv), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(hv), 'geocV1', moduleName )
d531 2
a532 2
    g%geocLat3 = hv%lat
    g%geocV3 = hv%v
d558 1
d560 6
a565 3
    call allocate_test ( g%lon1, size(phi), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(phi), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(v), 'geocV1', moduleName )
d575 1
a575 1
    g%geocV1 = v%v
d585 2
a586 2
    call great_circle_points ( r1%lon, r1%lat, r2%lon, r2%lat, phi, &
      & g%lon1, g%geocLat1 )
d608 1
a608 1
    integer :: I
d610 6
a615 3
    call allocate_test ( g%lon1, size(phi), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(phi)*size(r1), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(v), 'geocV1', moduleName )
d625 1
a625 1
    g%geocV1 = v%v
d632 2
a633 2
      call great_circle_points ( r1(i)%lon, r1(i)%lat, r2(i)%lon, r2(i)%lat, &
        & phi, g%lon2(:,i), g%geocLat2(:,i) )
d655 1
a655 1
    integer :: I
d657 6
a662 3
    call allocate_test ( g%lon1, size(v), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(v), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(v), 'geocV1', moduleName )
d672 1
a672 1
    g%geocV2 = v%v
d679 2
a680 2
      call great_circle_points ( r1(i)%lon, r1(i)%lat, r2(i)%lon, r2(i)%lat, &
        & phi, g%lon2(:,i), g%geocLat2(:,i) )
d704 1
a704 1
    integer :: I, J
d706 6
a711 3
    call allocate_test ( g%lon1, size(v), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(v), 'geocLat1', moduleName )
    call allocate_test ( g%geocV1, size(v), 'geocV1', moduleName )
d721 1
a721 1
    g%geocV3 = v%v
d729 3
a731 2
        call great_circle_points ( r1(i,j)%lon, r1(i,j)%lat, &
          & r2(i,j)%lon, r2(i,j)%lat, phi, g%lon3(:,i,j), g%geocLat3(:,i,j) )
d742 7
a748 3
    call allocate_test ( g%lon1, size(hv), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(hv), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(hv), 'geodV1', moduleName )
d756 2
a757 2
    g%geodLat1 = hv%lat
    g%geodV1 = hv%v
d780 7
a786 3
    call allocate_test ( g%lon1, size(h), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(h), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(v), 'geodV1', moduleName )
d793 3
a795 3
    g%lon1= h%lon
    g%geodLat1 = h%lat
    g%geodV1 = v%v
d815 7
a821 3
    call allocate_test ( g%lon1, size(lon), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(lat), 'geodLat1', moduleName )
    call allocate_test ( g%geocV1, size(v), 'geocV1', moduleName )
d828 3
a830 3
    g%lon1= lon%d
    g%geocLat1 = lat%d
    g%geocV1 = v%v
d851 7
a857 3
    call allocate_test ( g%lon1, size(lon), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(lat), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(v), 'geodV1', moduleName )
d879 7
a885 3
    call allocate_test ( g%lon1, size(h), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(h), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(v), 'geodV1', moduleName )
d893 2
a894 2
    g%geodLat1 = h%lat
    g%geodV2 = v%v
d907 7
a913 3
    call allocate_test ( g%lon1, size(hv), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(hv), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(hv), 'geodV1', moduleName )
d921 2
a922 2
    g%geodLat2 = hv%lat
    g%geodV2 = hv%v
d939 7
a945 3
    call allocate_test ( g%lon1, size(h), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(h), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(v), 'geodV1', moduleName )
d953 2
a954 2
    g%geodLat2 = h%lat
    g%geodV1 = v%v
d970 7
a976 3
    call allocate_test ( g%lon1, size(hv), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(hv), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(hv), 'geodV1', moduleName )
d984 2
a985 2
    g%geodLat3 = hv%lat
    g%geodV3 = hv%v
d1006 1
a1006 1
    use Geometry, only: GeocToGeodLat, Great_Circle_Points
d1012 2
a1013 1
    real(rg) :: Lat(size(phi))             ! Geocentric latitudes
d1015 6
a1020 3
    call allocate_test ( g%lon1, size(phi), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(phi), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(v), 'geodV1', moduleName )
d1030 1
a1030 1
    g%geodV1 = v%v
d1040 4
a1043 3
    call great_circle_points ( r1%lon, r1%lat, r2%lon, r2%lat, phi, &
      & g%lon1, lat )
    g%geodLat1 = geocToGeodLat(lat)
d1058 1
a1058 1
    use Geometry, only: GeocToGeodLat, Great_Circle_Points
d1065 2
a1066 2
    integer :: I
    real(rg) :: Lat(size(phi))             ! Geocentric latitudes
d1068 6
a1073 3
    call allocate_test ( g%lon1, size(phi), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(phi)*size(r1), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(v), 'geodV1', moduleName )
d1083 1
a1083 1
    g%geodV1 = v%v
d1090 4
a1093 3
      call great_circle_points ( r1(i)%lon, r1(i)%lat, r2(i)%lon, r2(i)%lat, &
        & phi, g%lon2(:,i), lat )
      g%geodLat2(:,i) = geocToGeodLat(lat)
d1115 2
a1116 2
    integer :: I
    real(rg) :: Lat(size(phi))             ! geodentric latitudes
d1118 6
a1123 3
    call allocate_test ( g%lon1, size(v), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(v)*size(r1), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(v), 'geodV1', moduleName )
d1133 1
a1133 1
    g%geodV2 = v%v
d1140 4
a1143 3
      call great_circle_points ( r1(i)%lon, r1(i)%lat, r2(i)%lon, r2(i)%lat, &
        & phi, g%lon2(:,i), lat )
      g%geodLat2(:,i) = lat
d1167 2
a1168 2
    integer :: I, J
    real(rg) :: Lat(size(phi))             ! Geocentric latitudes
d1170 6
a1175 3
    call allocate_test ( g%lon1, size(v), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(v), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(v), 'geodV1', moduleName )
d1185 1
a1185 1
    g%geodV3 = v%v
d1193 4
a1196 3
        call great_circle_points ( r1(i,j)%lon, r1(i,j)%lat, &
          & r2(i,j)%lon, r2(i,j)%lat, phi, g%lon3(:,i,j), lat )
        g%geodLat3(:,i,j) = lat
d1207 7
a1213 3
    call allocate_test ( g%lon1, size(hv), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(hv), 'geodLat1', moduleName )
    call allocate_test ( g%zeta1, size(hv), 'zeta1', moduleName )
d1221 2
a1222 2
    g%geodLat1 = hv%lat
    g%zeta1 = hv%v
d1245 7
a1251 3
    call allocate_test ( g%lon1, size(h), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(h), 'geodLat1', moduleName )
    call allocate_test ( g%zeta1, size(v), 'zeta1', moduleName )
d1258 3
a1260 3
    g%lon1= h%lon
    g%geodLat1 = h%lat
    g%zeta1 = v%v
d1279 7
a1285 3
    call allocate_test ( g%lon1, size(lon), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(lat), 'geodLat1', moduleName )
    call allocate_test ( g%zeta1, size(v), 'zeta1', moduleName )
d1292 3
a1294 3
    g%lon1= lon%d
    g%geocLat1 = lat%d
    g%geocV1 = v%v
d1315 7
a1321 3
    call allocate_test ( g%lon1, size(lon), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(lat), 'geodLat1', moduleName )
    call allocate_test ( g%zeta1, size(v), 'zeta1', moduleName )
d1342 7
a1348 3
    call allocate_test ( g%lon1, size(h), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(h), 'geodLat1', moduleName )
    call allocate_test ( g%geodV1, size(v), 'geodV1', moduleName )
d1356 2
a1357 2
    g%geodLat1 = h%lat
    g%geodV2 = v%v
d1370 7
a1376 3
    call allocate_test ( g%lon1, size(hv), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(hv), 'geodLat1', moduleName )
    call allocate_test ( g%zeta1, size(hv), 'zeta1', moduleName )
d1384 2
a1385 2
    g%geodLat2 = hv%lat
    g%zeta2 = hv%v
d1402 7
a1408 3
    call allocate_test ( g%lon1, size(h), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(h), 'geodLat1', moduleName )
    call allocate_test ( g%zeta1, size(v), 'zeta1', moduleName )
d1416 2
a1417 2
    g%geodLat2 = h%lat
    g%zeta1 = v%v
d1432 7
a1438 3
    call allocate_test ( g%lon1, size(hv), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(hv), 'geodLat1', moduleName )
    call allocate_test ( g%zeta1, size(hv), 'zeta1', moduleName )
d1446 2
a1447 2
    g%geodLat3 = hv%lat
    g%zeta3 = hv%v
d1468 1
a1468 1
    use Geometry, only: GeocToGeodLat, Great_Circle_Points
d1474 2
a1475 1
    real(rg) :: Lat(size(phi))             ! Geocentric latitudes
d1477 6
a1482 3
    call allocate_test ( g%lon1, size(phi), 'lon1', moduleName )
    call allocate_test ( g%geocLat1, size(phi), 'geocLat1', moduleName )
    call allocate_test ( g%zeta1, size(v), 'zeta1', moduleName )
d1492 1
a1492 1
    g%zeta1 = v%v
d1502 4
a1505 3
    call great_circle_points ( r1%lon, r1%lat, r2%lon, r2%lat, phi, &
      & g%lon1, lat )
    g%geodLat1 = geocToGeodLat(lat)
d1520 1
a1520 1
    use Geometry, only: GeocToGeodLat, Great_Circle_Points
d1526 2
a1527 2
    integer :: I
    real(rg) :: Lat(size(phi))             ! Geocentric latitudes
d1529 6
a1534 3
    call allocate_test ( g%lon1, size(phi), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(phi)*size(r1), 'geodLat1', moduleName )
    call allocate_test ( g%zeta1, size(v), 'zeta1', moduleName )
d1544 1
a1544 1
    g%zeta1 = v%v
d1551 4
a1554 3
      call great_circle_points ( r1(i)%lon, r1(i)%lat, r2(i)%lon, r2(i)%lat, &
        & phi, g%lon2(:,i), lat )
      g%geodLat2(:,i) = geocToGeodLat(lat)
d1576 2
a1577 2
    integer :: I
    real(rg) :: Lat(size(phi))             ! geodentric latitudes
d1579 6
a1584 3
    call allocate_test ( g%lon1, size(v), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(v), 'geodLat1', moduleName )
    call allocate_test ( g%zeta1, size(v), 'zeta1', moduleName )
d1594 1
a1594 1
    g%zeta2 = v%v
d1601 4
a1604 3
      call great_circle_points ( r1(i)%lon, r1(i)%lat, r2(i)%lon, r2(i)%lat, &
        & phi, g%lon2(:,i), lat )
      g%geodLat2(:,i) = lat
d1628 2
a1629 2
    integer :: I, J
    real(rg) :: Lat(size(phi))             ! Geocentric latitudes
d1631 6
a1636 3
    call allocate_test ( g%lon1, size(v), 'lon1', moduleName )
    call allocate_test ( g%geodLat1, size(v), 'geodLat1', moduleName )
    call allocate_test ( g%zeta1, size(v), 'zeta1', moduleName )
d1646 1
a1646 1
    g%zeta3 = v%v
d1654 4
a1657 3
        call great_circle_points ( r1(i,j)%lon, r1(i,j)%lat, &
          & r2(i,j)%lon, r2(i,j)%lat, phi, g%lon3(:,i,j), lat )
        g%geodLat3(:,i,j) = lat
d1710 1
a1710 1
  real(rg) function Lon ( G, I, J, K )
d1731 1
a1731 1
      lon = atan2(xyz(2),xyz(1)) * rad2deg
d1733 1
a1733 1
      lon = -huge(0.0_rg)
d1738 1
a1738 2
  real(rg) function GeocLat ( G, I, J, K )
    use Geometry, only: GeodToGeocLat
d1744 1
d1759 2
a1760 1
      geocLat = geodToGeocLat(g%geodLat(i,j,k))
d1763 1
a1763 1
      geocLat = asin(xyz(3)/norm2(xyz(1:2)))
d1765 1
a1765 1
      geocLat = -huge(0.0_rg)
d1770 1
a1770 2
  real(rg) function GeodLat ( G, I, J, K )
    use Geometry, only: GeocToGeodLat
d1776 1
d1790 2
a1791 1
      geodLat = geocToGeodLat(g%geocLat(i,j,k))
d1793 1
a1793 1
      geodLat = -huge(0.0_rg)
d1798 1
a1798 1
  real(rg) function GeocV ( G, I, J, K )
d1805 3
d1813 1
a1813 1
        geod = h_v_geod ( lon=g%lon1(k), lat=g%geodLat1(k), v=g%geodV1(k) )
d1815 1
a1815 1
        GeocV = geoc%v
d1819 1
a1819 1
        GeocV = -huge(0.0_rg)
d1836 4
a1839 1
        geod = h_v_geod ( lon=g%lon(i,j,k), lat=g%geodLat(i,j,k), v=g%geodV(i,j,k) )
d1841 1
a1841 1
        GeocV = geoc%v
d1843 1
a1843 1
        GeocV = norm2(g%ecr(i,j,k))
d1847 1
a1847 1
        GeocV = -huge(0.0_rg)
d1853 1
a1853 1
  real(rg) function GeodV ( G, I, J, K )
d1886 1
a1886 1
      geodV = geod(3)
d1889 1
a1889 1
      geodV = -huge(0.0_rg)
d1894 1
a1894 1
  real(rg) function Zeta ( G, I, J, K )
d1901 1
a1901 1
      zeta = -huge(0.0_rg)
d1925 2
d1928 4
a1931 2
    loc_geoc%lat = g%geocLat(i,j,k)
    loc_geoc%v = g%geocV(i,j,k)
d1938 2
d1941 4
a1944 2
    loc_geod%lat = g%geodLat(i,j,k)
    loc_geod%v = g%geodV(i,j,k)
d1951 2
d1954 4
a1957 2
    loc_zeta%lat = g%geodLat(i,j,k)
    loc_zeta%v = g%zeta(i,j,k)
d1969 5
d1988 4
a1991 1
      ecr = geodToECRm ( [ g%lon(i,j,k), g%geodLat(i,j,k), g%geodV(i,j,k) ] )
d1994 4
a1997 1
      ecr = GeocToECRu ( g%geocLat(i,j,k),g%lon(i,j,k) ) * g%geocV(i,j,k)
d2006 1
a2006 1
    integer :: I, J, K
d2010 4
a2013 2
      call allocate_test ( g%geocLat1, size(g%geodLat1), 'geocLat1', moduleName )
      call allocate_test ( g%geocV1, size(g%geodV1), 'geocV1', moduleName )
d2015 4
a2018 2
      call allocate_test ( g%geocLat1, size(g%p1), 'geocLat1', moduleName )
      call allocate_test ( g%geocV1, size(g%p1), 'geocV1', moduleName )
d2052 1
a2052 1
    integer :: I, J, K
d2056 4
a2059 2
      call allocate_test ( g%geodLat1, size(g%geocLat1), 'geodLat1', moduleName )
      call allocate_test ( g%geodV1, size(g%geocV1), 'geodV1', moduleName )
d2061 4
a2064 2
      call allocate_test ( g%geodLat1, size(g%P1), 'geodLat1', moduleName )
      call allocate_test ( g%geodV1, size(g%P1), 'geodV1', moduleName )
d2068 4
a2071 4
    g%geodLat2(1:size(g%geocLat2,1),1:size(g%geocLat2,2)) => g%geocLat1
    g%geodLat3(1:size(g%geocLat3,1),1:size(g%geocLat3,2),1:size(g%geocLat3,3)) => g%geocLat1
    g%geodV2(1:size(g%geocV2,1),1:size(g%geocV2,2)) => g%geocV1
    g%geodV3(1:size(g%geocV3,1),1:size(g%geocV3,2),1:size(g%geocV3,3)) => g%geocV1
d2129 3
a2131 1
    call allocate_test ( g%geocV1, size(v), 'G%GeocV1', moduleName )
d2134 1
a2134 1
    g%geocV1 = v%v
d2145 3
a2147 1
    call allocate_test ( g%geocV1, size(v), 'G%GeocV1', moduleName )
d2150 1
a2150 1
    g%geocV2 = v%v
d2161 3
a2163 1
    call allocate_test ( g%geocV1, size(v), 'G%GeocV1', moduleName )
d2166 1
a2166 1
    g%geocV3 = v%v
d2176 3
a2178 1
    call allocate_test ( g%geodV1, size(v), 'G%geodV1', moduleName )
d2181 1
a2181 1
    g%geodV1 = v%v
d2191 3
a2193 1
    call allocate_test ( g%geodV1, size(v), 'G%geodV1', moduleName )
d2196 1
a2196 1
    g%geodV2 = v%v
d2206 3
a2208 1
    call allocate_test ( g%geodV1, size(v), 'G%geodV1', moduleName )
d2211 1
a2211 1
    g%geodV3 = v%v
d2221 3
a2223 1
    call allocate_test ( g%zeta1, size(v), 'G%zeta1', moduleName )
d2226 1
a2226 1
    g%zeta1 = v%v
d2236 3
a2238 1
    call allocate_test ( g%zeta1, size(v), 'G%zeta1', moduleName )
d2241 1
a2241 1
    g%zeta2 = v%v
d2251 3
a2253 1
    call allocate_test ( g%zeta1, size(v), 'G%zeta1', moduleName )
d2256 1
a2256 1
    g%zeta3 = v%v
d2298 14
a2311 6
    call deallocate_test ( g%lon1, 'lon1', moduleName )
    call deallocate_test ( g%geodLat1, 'geodLat1', moduleName )
    call deallocate_test ( g%geodLat1, 'geodLat1', moduleName )
    call deallocate_test ( g%geocV1, 'geocV1', moduleName )
    call deallocate_test ( g%geodV1, 'geodV1', moduleName )
    call deallocate_test ( g%zeta1, 'zeta1', moduleName )
d2314 1
a2314 1
    nullify ( g%geocV2, g%geocV3, g%geodV2, g%geodV3 )
d2329 1
a2329 1
  subroutine Explicit_Destroy_G (Not_Used )
d2337 1
a2337 1
       "$Id: Geolocation_m.f90,v 2.3 2016/01/26 19:55:21 vsnyder Exp $"
d2347 4
@


2.3
log
@Attach QTM
@
text
@d29 1
a29 1
  public :: Geolocation_t
d33 1
a33 1
  public :: V_T, V_Geoc, V_Geod, V_Zeta
d69 4
a72 3
    real(rg), pointer, contiguous :: GeocV1(:) => null()       ! V*H*H
    real(rg), pointer, contiguous :: GeocV2(:,:) => null()     ! => GeocV, V x H*H
    real(rg), pointer, contiguous :: GeocV3(:,:,:) => null()   ! => GeocV, V x H x H
d74 4
a77 3
    real(rg), pointer, contiguous :: GeodV1(:) => null()       ! V*H*H
    real(rg), pointer, contiguous :: GeodV2(:,:) => null()     ! => GeodV, V x H*H
    real(rg), pointer, contiguous :: GeodV3(:,:,:) => null()   ! => GeodV, V x H x H
d80 2
a81 2
    real(rg), pointer, contiguous :: Zeta2(:,:) => null()      ! => Zeta, V x H*H
    real(rg), pointer, contiguous :: Zeta3(:,:,:) => null()    ! => Zeta, V x H x H
d84 2
a85 2
    type(ecr_t), pointer, contiguous :: P2(:,:) => null()      ! => P, V x H*H
    type(ecr_t), pointer, contiguous :: P3(:,:,:) => null()    ! => P, V x H x H
d88 8
a95 5
    type(ZOT_t), allocatable :: ZOT(:)
    ! H1 is geocentric or geodetic; QTM_tree_t doesn't care because it works
    ! in ZOT coordinates.  Its size is V*size(ZOT) if the grid is incoherent.
    real(rg), pointer, contiguous :: H1(:) => null()           ! V or V*size(ZOT)
    real(rg), pointer, contiguous :: H2(:,:) => null()         ! => H1, V x size(ZOT)
d101 1
d2126 1
a2126 1
       "$Id: Geolocation_m.f90,v 2.2 2016/01/23 02:47:33 vsnyder Exp $"
d2136 3
@


2.2
log
@Use geolocation types and type-bound procedures from Geolocation_0
@
text
@d22 2
d54 1
a54 1
    real(rg), pointer, contiguous :: lon1(:)=> null()          ! V*H*H
d84 7
d2120 1
a2120 1
       "$Id: Geolocation_m.f90,v 2.1 2015/11/14 18:02:37 vsnyder Exp $"
d2130 3
@


2.1
log
@Initial commit
@
text
@d39 1
a39 1
       "$RCSfile: $"
a1635 1
    use Geometry, only: To_Cart
d1640 2
a1641 1
    real(rg) :: Cart(3)
d1646 4
a1649 2
        call to_cart([g%geodLat1(k),g%lon1(k),g%geodV1(k)/1000.0_rg],cart,km=.true.)
        GeocV = norm2(cart) * 1000.0_rg
d1669 4
a1672 4
        ! Convert [ longitude, geodetic latitude, geodetic height] to ECR.
        ! To_Cart wants height in km, not meters.
        call to_cart([g%geodLat(i,j,k),g%lon(i,j,k),g%geodV(i,j,k)/1000.0_rg],cart,km=.true.)
        GeocV = norm2(cart) * 1000.0_rg ! To_Cart provides coordinates in km
d1781 1
a1781 1
    use Geometry, only: To_Cart, To_XYZ
d1801 2
a1802 3
      ! Convert [ longitude, geodetic latitude, geodetic height] to ECR
      call to_cart ( [ g%lon(i,j,k), g%geodLat(i,j,k), g%geodV(i,j,k)/1000.0_rg],ecr,km=.true.)
      ecr = ecr * 1000.0_rg ! to_cart output is in km, not meters
d1805 1
a1805 1
      ecr = to_xyz(g%geocLat(i,j,k),g%lon(i,j,k))*g%geocV(i,j,k)
d2103 2
a2104 2
  subroutine Explicit_Destroy_G ( G )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
d2111 1
a2111 1
       "$Id: $"
d2120 4
a2123 1
! $Log: $
@

