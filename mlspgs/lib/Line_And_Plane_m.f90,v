head	2.5;
access;
symbols
	v5-02-NRT-19:2.5
	v6-00:2.5
	v5-02-NRT-18:2.5
	v5-02:2.4
	v5-01-NRT-17:2.5
	v5-01-NRT-16:2.5
	v5-01-NRT-15:2.5
	v5-01-NRT-14:2.5
	neuralnetworks-1-0:2.5.0.4
	cfm-single-freq-0-1:2.5.0.2
	v5-01:2.4
	v5-00:2.4
	v4-23-TA133:2.4.0.6
	mus-emls-1-70:2.4.0.4
	rel-1-0-englocks-work:2.4.0.2
	VUMLS1-00:2.4
	VPL1-00:2.4
	V4-22-NRT-08:2.4;
locks; strict;
comment	@# @;


2.5
date	2020.04.23.22.57.46;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2016.03.25.00.07.47;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2016.03.03.21.39.38;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2016.03.03.03.05.38;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2016.02.05.03.38.42;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.5
log
@Use C instead of U to compute Z_dot_N. Choose a different p_0 if C == p_0.
@
text
@! Copyright 2015, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module Line_And_Plane_m
!=============================================================================

  private
  public :: Line_And_Plane, Line_Reflection

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Line_And_Plane_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  subroutine Line_And_Plane ( Plane, Line, Intersect, Intersection, S )

    ! Compute the intersections of Line with a Plane.  The plane is defined
    ! by three vertices in ECR coordinates (in any order).
    ! The Line is given by a vector to a point on it (Line(1)) and a vector
    ! along it (Line(2)).  The Intersection is given in ECR coordinates.

    ! See wvs-130 for a derivation.

    use Geolocation_0, only: Cross
    use Geolocation_0, only: ECR_t, RG

    type(ECR_t), intent(in) :: Plane(3) ! Three points in the plane
    type(ECR_t), intent(in) :: Line(2) ! The line is of the form
                                       ! Line(1) + s * Line(2), i.e., Line(1)
                                       ! is a vector to a point on the line,
                                       ! and Line(2) is a vector along the
                                       ! line.
    integer, intent(out) :: Intersect  ! -1 => no intersection,
                                       !  0 => line is in the plane,
                                       ! +1 => one intersection.
    type(ECR_t), intent(out), optional :: Intersection ! ECR coordinates of
                                       ! intersection if Intersect > 0, else
                                       ! undefined.
    real(rg), intent(out), optional :: S ! S-value of intersection if
                                       ! Intersect > 0, else undefined.

    integer :: I
    real(rg) :: L_dot_N                ! L .dot. N
    real(rg) :: MyS
    type(ECR_t) :: N                   ! Normal to the plane
    real(rg) :: Z_dot_N                ! ( P_0 - L_0 ) .dot. N

!     ifort 16.0.2.181 doesn't like .CROSS. to have operands that are both
!     expressions in parentheses.
!     n = ( plane(2) - plane(1) ) .cross. ( plane(3) - plane(1) )
    n = cross( plane(2) - plane(1), plane(3) - plane(1) )
    l_dot_n = line(2) .dot. n
    i = 1
    if ( all(plane(1)%xyz == line(1)%xyz) ) i = 2
    z_dot_n = ( plane(i) - line(1) ) .dot. n
    if ( l_dot_n == 0 ) then   ! Line and plane are parallel
      if ( z_dot_n == 0 ) then ! Line is in the plane
        intersect = 0          ! Caller chooses a point
      else                     ! Line and plane do not intersect
        intersect = -1
      end if
    else                       ! Line and plane intersect in one point
      intersect = 1
      myS = z_dot_n / l_dot_n
      if ( present(intersection) ) intersection = line(1) + myS * line(2)
      if ( present(s) ) s = myS
    end if

  end subroutine Line_And_Plane

  subroutine Line_Reflection ( Line, Normal, Reflection )
    ! Given a vector parallel to a line, and a vector parallel to an unit
    ! normal to a plane, compute a vector parallel to the reflection of
    ! the line from the plane.  For derivation, see wvs-133.
    use Geolocation_0, only: ECR_t
    type(ECR_t), intent(in) :: Line    ! A vector parallel to the line
    type(ECR_t), intent(in) :: Normal  ! An unit normal to the plane
    type(ECR_t), intent(out) :: Reflection ! A vector parallel to the
                                       ! reflection, with the same length
                                       ! as Line
    Reflection = Line - 2 * ( Line .dot. Normal ) * Normal
  end subroutine Line_Reflection

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Line_And_Plane_m.f90,v 2.4 2016/03/25 00:07:47 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Line_And_Plane_m

! $Log: Line_And_Plane_m.f90,v $
! Revision 2.4  2016/03/25 00:07:47  vsnyder
! Remove unused USE name
!
! Revision 2.3  2016/03/03 21:39:38  vsnyder
! Change name of T argument to S (because it's arc length)
!
! Revision 2.2  2016/03/03 03:05:38  vsnyder
! Add Line_Reflection
!
! Revision 2.1  2016/02/05 03:38:42  vsnyder
! Initial commit
!
@


2.4
log
@Remove unused USE name
@
text
@d54 1
d65 3
a67 1
    z_dot_n = ( plane(1) - line(2) ) .dot. n
d99 1
a99 1
       "$Id: Line_And_Plane_m.f90,v 2.3 2016/03/03 21:39:38 vsnyder Exp $"
d109 3
@


2.3
log
@Change name of T argument to S (because it's arc length)
@
text
@d84 1
a84 1
    use Geolocation_0, only: ECR_t, RG
d96 1
a96 1
       "$Id: Line_And_Plane_m.f90,v 2.2 2016/03/03 03:05:38 vsnyder Exp $"
d106 3
@


2.2
log
@Add Line_Reflection
@
text
@d27 1
a27 1
  subroutine Line_And_Plane ( Plane, Line, Intersect, Intersection, T )
d31 2
a32 2
    ! The Line is given by a vector to a point on it and a vector along it.
    ! The Intersection is given in ECR coordinates.
d41 1
a41 1
                                       ! Line(1) + t * Line(2), i.e., Line(1)
d51 1
a51 1
    real(rg), intent(out), optional :: T ! T-value of intersection if
d55 1
a55 1
    real(rg) :: MyT
d73 3
a75 3
      myT = z_dot_n / l_dot_n
      if ( present(intersection) ) intersection = line(1) + myT * line(2)
      if ( present(t) ) t = myT
d96 1
a96 1
       "$Id: Line_And_Plane_m.f90,v 2.1 2016/02/05 03:38:42 vsnyder Exp $"
d106 3
@


2.1
log
@Initial commit
@
text
@d17 1
a17 1
  public :: Line_And_Plane
d21 1
a21 1
       "$RCSfile: HGrid.f90,v $"
d27 1
a27 1
  subroutine Line_And_Plane ( Plane, Line, Intersection, Intersect )
d36 1
a36 1
    use Cross_m, only: Cross
a44 2
    type(ECR_t), intent(out) :: Intersection ! ECR coordinates of intersection
                                       ! if Intersect > 0, else undefined.
d48 5
d55 2
a56 1
    real(rg) :: N(3)                   ! Normal to the plane
d59 6
a64 3
    n = cross ( plane(2)%xyz - plane(1)%xyz, plane(3)%xyz - plane(1)%xyz )
    l_dot_n = dot_product ( line(2)%xyz, n )
    z_dot_n = dot_product ( plane(1)%xyz - line(2)%xyz, n )
a71 1
      intersection = ECR_t(line(1)%xyz + z_dot_n / l_dot_n * line(2)%xyz )
d73 3
d80 13
d96 1
a96 1
       "$Id: HGrid.f90,v 2.127 2015/10/14 23:23:01 pwagner Exp $"
d105 4
a108 1
! $Log: HGrid.f90,v $
@

