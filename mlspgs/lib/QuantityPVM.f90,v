head	2.30;
access;
symbols
	v5-02-NRT-19:2.30
	v6-00:2.30
	v5-02-NRT-18:2.30
	v5-02:2.30
	v5-01-NRT-17:2.30
	v5-01-NRT-16:2.30
	v5-01-NRT-15:2.30
	v5-01-NRT-14:2.30
	neuralnetworks-1-0:2.30.0.10
	cfm-single-freq-0-1:2.30.0.8
	v5-01:2.30
	v5-00:2.30
	v4-23-TA133:2.30.0.6
	mus-emls-1-70:2.30.0.4
	rel-1-0-englocks-work:2.30.0.2
	VUMLS1-00:2.30
	VPL1-00:2.30
	V4-22-NRT-08:2.30
	VAM1-00:2.30
	V4-21:2.25.0.2
	V4-13:2.25
	V4-12:2.25
	V4-11:2.25
	V4-10:2.25
	V3-43:2.23
	M4-00:2.24
	V3-41:2.23
	V3-40-PlusGM57:2.23.0.2
	V2-24-NRT-04:2.22
	V3-33:2.23
	V2-24:2.22
	V3-31:2.23
	V3-30-NRT-05:2.23
	cfm-01-00:2.23
	V3-30:2.23
	V3-20:2.23
	V3-10:2.23
	V2-23-NRT-02:2.22
	V2-23:2.22
	V2-22-NRT-01:2.22
	V2-22:2.22
	V2-21:2.21
	V2-20:2.21
	V2-11:2.20
	V2-10:2.20
	V2-00:2.20
	V1-51:2.18
	V1-50:2.18
	V1-45:2.18
	V1-44:2.18
	V1-43:2.18
	V1-42:2.18
	V1-41:2.18
	V1-32:2.18
	V1-40:2.18
	V1-31:2.18
	V1-30:2.18
	V1-13:2.14
	V1-12:2.14
	V1-11:2.14
	V1-10:2.14
	newfwm-feb03:2.14.0.2
	V1-04:2.8
	V1-03:2.8
	V1-02:2.8
	V1-00:2.8
	newfwm-sep01:2.6.0.2
	V0-7:2.6;
locks; strict;
comment	@# @;


2.30
date	2015.07.29.00.27.28;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2015.06.04.03.13.16;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2015.06.02.23.55.11;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2015.05.29.00.34.47;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2015.03.28.01.48.23;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2013.06.12.02.13.25;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2012.07.07.02.03.57;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2006.11.29.03.05.19;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2006.08.03.01.10.06;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2005.06.22.17.25.50;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2005.03.15.23.48.55;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2003.07.07.20.28.53;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2003.07.07.20.22.00;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2003.06.20.19.31.39;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2003.05.13.04.46.55;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2002.11.27.00.24.01;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2002.10.08.00.09.13;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2002.10.06.01.08.53;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2002.10.05.00.42.52;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2002.08.16.21.41.13;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2002.07.01.23.50.46;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2002.02.05.02.39.59;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2002.02.01.23.50.36;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.07.17.17.33.03;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.05.30.23.52.38;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.05.25.01.04.47;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.05.23.22.00.32;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.05.23.03.29.12;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.05.23.02.45.38;	author livesey;	state Exp;
branches;
next	;


desc
@@


2.30
log
@Convert Phi from pointer to allocated
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module QuantityPVM                      ! Send and receive vector quantities using pvm
  ! This module provides functionality for sending and receiving vectors
  ! through a pvm connection.

  use PVM, only: PVMDATADEFAULT, PVMFINITSEND, PVMFSEND, &
    & PVMFRECV
  use PVMIDL, only: PVMIDLPACK, PVMIDLUNPACK
  use MorePVM, only: PVMPackLitIndex, PVMPackStringIndex, &
    & PVMUnpackLitIndex, PVMUnpackStringIndex
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, PVMERRORMESSAGE

  implicit none
  private

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: QuantityPVM.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  public :: PVMSendQuantity, PVMReceiveQuantity

  ! Local parameters
  integer, parameter :: QTYMSGTAG = 200

contains ! ================================== Module procedures ============

  ! ---------------------------------- PVMSendQuantity ---------------------
  subroutine PVMSendQuantity ( Q, tid, justPack, noValues, noMask, skipMIFGeolocation )
    use Intrinsic, only: LIT_INDICES
    use MLSSignals_m, only: GETSIGNALNAME
    use String_Table, only: GET_STRING
    use VectorsModule, only: VECTORVALUE_T
    type (VectorValue_T), intent(in) :: Q ! Quantity to send
    integer, intent(in), optional :: TID ! Task to send it to
    logical, intent(in), optional :: JUSTPACK ! Just pack it into an existing buffer
    logical, intent(in), optional :: NOVALUES ! Don't send the values
    logical, intent(in), optional :: NOMASK ! Don't send the mask
    logical, intent(in), optional :: SKIPMIFGEOLOCATION ! Skip geolocation if minor frame

    ! Local variables
    integer :: BUFFERID                 ! From pvm
    integer :: INFO                     ! Flag
    logical :: MYJUSTPACK               ! Copy of justPack
    logical :: MYNOVALUES               ! Copy of noValues
    logical :: MYNOMASK                 ! Copy of noMask
    logical :: MYSKIPMIFGEOLOCATION     ! If set, skip geolocation

    character(len=132) :: WORD          ! Result of get_string etc.

    ! Executable code
    myJustPack = .false.
    myNoValues = .false.
    myNoMask = .false.
    mySkipMIFGeolocation = .false.
    if ( present(justPack) ) myJustPack = justPack
    if ( present(noValues) ) myNoValues = noValues
    if ( present(noMask) ) myNoMask = noMask
    if ( present(skipMIFGeolocation) ) mySkipMIFGeolocation = skipMIFGeolocation

    ! Now we simply pack the quantity up and send it down the pvm spigot
    if (.not. myJustPack) call PVMFInitSend ( PvmDataDefault, bufferID )
    
    call PVMIDLPack ( (/ q%template%noInstances, &
      & q%template%noSurfs, q%template%noChans, q%template%instanceLen /), &
      & info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing quantity dimensions." )

    call PVMIDLPack ( (/ q%template%coherent, &
      & q%template%stacked, q%template%regular, q%template%minorFrame, &
      & q%template%majorFrame, q%template%logBasis /), info ) 
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing quantity flags" )

    call PVMIDLPack ( (/ q%template%noInstancesLowerOverlap, &
      & q%template%noInstancesUpperOverlap, q%template%sideband, &
      & q%template%instrumentModule, q%template%radiometer, &
      & q%template%instanceOffset, q%template%grandTotalInstances /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing misc quantity stuff" )

    ! Now pack some strings

    call PVMPackLitIndex ( q%template%quantityType, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing quantityType" )
    call PVMPackLitIndex ( q%template%verticalCoordinate, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing verticalCoordinate" )
    call PVMPackLitIndex ( q%template%frequencyCoordinate, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing frequencyCoordinate" )
    call PVMPackLitIndex ( q%template%reflector, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing reflector" )
    call PVMPackLitIndex ( q%template%unit, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing unit" )
    call PVMPackLitIndex ( q%template%molecule, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing molecule" )
    call PVMPackStringIndex ( q%template%name, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing name" )

    ! Pack signal as a string
    if ( q%template%signal /= 0 ) then
      call GetSignalName( q%template%signal, &
        & word, sideband=q%template%sideband )
    else
      word = ''
    endif
    call PVMIDLPack ( trim(word), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing signal" )

    if ( q%template%molecule >= lbound(lit_indices,1) .and. &
      &  q%template%molecule <= ubound(lit_indices,1) ) then
      call Get_String( lit_indices(q%template%molecule), word, noError=.true. )
    else
      word = ''
    endif
    call PVMIDLPack ( trim(word), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing molecule" )

    ! Now pack the arrays
    if ( .not. (q%template%minorFrame .or. q%template%majorFrame) &
      & .or. .not. mySkipMIFGeolocation ) then
      call PVMIDLPack ( q%template%surfs, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing surfs" )
      
      call PVMIDLPack ( q%template%phi, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing phi" )
      
      call PVMIDLPack ( q%template%geodLat, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing geodLat" )
      
      call PVMIDLPack ( q%template%lon, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing lon" )
      
      call PVMIDLPack ( q%template%time, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing time" )
      
      call PVMIDLPack ( q%template%solarTime, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing solarTime" )
      
      call PVMIDLPack ( q%template%solarZenith, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing solarZenith" )
      
      call PVMIDLPack ( q%template%losAngle, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing losAngle" )
    end if

    if ( associated ( q%template%frequencies ) ) then
      call PVMIDLPack ( (/.true./), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing flag" )
      call PVMIDLPack ( q%template%frequencies, info )
    else
      call PVMIDLPack ( (/ .false. /), info )
    end if
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing frequencies/flag" )

    ! Finally the two arrays for irregular quantities

    if ( .not. q%template%regular ) then
      call PVMIDLPack ( q%template%surfIndex, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing surfIndex" )

      call PVMIDLPack ( q%template%chanIndex, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing chanIndex" )
    end if

    ! Now pack the noValues, noMask flag
    myNoMask = myNoMask .or. ( .not. associated(q%mask) )
    call PVMIDLPack ( (/ myNoValues, myNoMask /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing values/mask flags" )    

    ! Now we're going to send this to the snooper.

    if (.not. myJustPack) then
      call PVMFSend ( tid, QtyMsgTag, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "sending vector template" )
      
      ! Now we're going to send the values in a separate message
      if ( .not. all ( (/myNoValues, myNoMask /) ) ) &
        & call PVMFInitSend ( PVMDataDefault, bufferID)
    end if

    ! Pack the values
    if ( .not. myNoValues ) then 
      call PVMIDLPack ( q%values, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "sending values" )
    endif

    ! Skip the mask for the moment.
    if ( .not. myNoMask ) then
      call PVMIDLPack ( q%mask, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "sending mask" )
    endif

    ! Send this buffer
    if (.not. myJustPack .and. .not. all ((/myNoValues, myNoMask/)) ) then
      call PVMFSend ( tid, QtyMsgTag, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "sending vector values" )
    end if
      
  end subroutine PVMSendQuantity

  ! ---------------------------------- PVMReceiveQuantity ---------------------
  subroutine PVMReceiveQuantity ( QT, values, tid, justUnpack, mifGeolocation )
    use Allocate_Deallocate, only: Allocate_Test
    use QuantityTemplates, only: CreateGeolocationFields, QuantityTemplate_T, &
      & SetupNewQuantityTemplate
    use VectorsModule, only: CreateMask, CreateVectorValue, VectorValue_T
    type (QuantityTemplate_T), intent(out) :: QT ! Template for quantity
    ! It's not inout, because then setupNewQuantityTemplate would deallocate
    ! the pointer components.  But the actual argument is put into a database
    ! using a shallow copy, so cleaning it up would clobber a database item.
    type (VectorValue_T), optional :: VALUES ! Quantity to receive
    integer, intent(in), optional :: TID ! Task to get it from
    logical, intent(in), optional :: JustUnpack ! Just unpack from existing buffer
    type (QuantityTemplate_T), dimension(:), intent(in), optional :: MIFGeolocation

    ! Local variables
    integer :: BufferID                 ! From pvm
    integer :: Info                     ! Flag
    integer :: I4(4)                    ! Unpacked stuff
    integer :: I7(7)                    ! Unpacked stuff
    logical :: L2(2)                    ! Unpacked stuff
    logical :: L6(6)                    ! Unpacked stuff
    logical :: Flag(1)                  ! To unpack
    character(len=132) :: Word          ! Result of PVMIDLUnpack etc.
    logical :: MyJusTunpack             ! Copy of justUnPack
    logical :: NoValues                 ! No values sent
    logical :: NoMask                   ! No mask sent

    ! Executable code

    myJustUnpack = .false.
    if ( present (justUnpack) ) myJustUnPack = justUnpack

    if ( .not. myJustUnpack ) then
      ! Get buffer, we'll wait for it, assume the calling code knows it's coming.
      call PVMFrecv ( tid, QtyMsgTag, bufferID )
    end if

    ! Now we unpack the information

    ! Get dimensions
    call PVMIDLUnpack( i4, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking quantity dimensions." )

    call PVMIDLUnPack ( l6, info ) 
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking quantity flags" )

    call PVMUnpackStringIndex ( qt%name, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking name" )
    call SetupNewQuantityTemplate ( qt, &
      & noInstances  = i4(1), &
      & noSurfs      = i4(2), &
      & noChans      = i4(3), &
      & coherent     = l6(1), &
      & stacked      = l6(2), &
      & regular      = l6(3), &
      & instanceLen  = i4(4), &
      & minorFrame   = l6(4), &
      & majorFrame   = l6(5) )
    qt%logBasis = l6(6)

    call PVMIDLUnPack ( i7, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking misc quantity stuff" )
    qt%noInstancesLowerOverlap = i7(1)
    qt%noInstancesUpperOverlap = i7(2)
    qt%sideband                = i7(3)
    qt%instrumentModule        = i7(4)
    qt%radiometer              = i7(5)
    qt%instanceOffset          = i7(6)
    qt%grandTotalInstances     = i7(7)

    ! Now unpack literals etc.
    call PVMUnpackLitIndex ( qt%quantityType, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking quantityType" )
    call PVMUnpackLitIndex ( qt%verticalCoordinate, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking verticalCoordinate" )
    call PVMUnpackLitIndex ( qt%frequencyCoordinate, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking frequencyCoordiante" )
    call PVMUnpackLitIndex ( qt%unit, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking unit" )
    call PVMUnpackLitIndex ( qt%reflector, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking reflector" )
    call PVMUnpackLitIndex ( qt%molecule, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking molecule" )

    call PVMIDLUnpack ( word, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking signal" )
    ! Just ignore it, we got it as an integer already

    call PVMIDLUnpack ( word, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking molecule" )
    ! Juest ignore it, we got it as an integer already

    ! Now unpack the arrays
    if ( .not. ( qt%minorFrame .or. qt%majorFrame ) .or. &
      & .not. present ( mifGeolocation ) ) then

      call PVMIDLUnpack ( qt%surfs, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking surfs" )

      call PVMIDLUnpack ( qt%phi, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking phi" )

      call PVMIDLUnpack ( qt%geodLat, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking geodLat" )

      call PVMIDLUnpack ( qt%lon, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking lon" )

      call PVMIDLUnpack ( qt%time, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking time" )

      call PVMIDLUnpack ( qt%solarTime, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking solarTime" )

      call PVMIDLUnpack ( qt%solarZenith, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking solarZenith" )

      call PVMIDLUnpack ( qt%losAngle, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking losAngle" )

    else
      call createGeolocationFields ( qt, &
        & mifGeolocation(qt%instrumentModule)%noSurfs, &
        & 'PVMReceiveQuantity' )
      ! If it's minor frame and we've got mif geolocation information just
      ! point to that (except don't share latitude and longitude).
      if ( qt%minorFrame ) then
        qt%surfs = mifGeolocation(qt%instrumentModule)%surfs
        qt%phi = mifGeolocation(qt%instrumentModule)%phi
        qt%geodLat = mifGeolocation(qt%instrumentModule)%geodLat
        qt%lon = mifGeolocation(qt%instrumentModule)%lon
        qt%time => mifGeolocation(qt%instrumentModule)%time
        qt%solarTime => mifGeolocation(qt%instrumentModule)%solarTime
        qt%solarZenith => mifGeolocation(qt%instrumentModule)%solarZenith
      end if
      if ( qt%majorFrame ) then
        qt%phi = mifGeolocation(qt%instrumentModule)%phi(1:1,:)
        qt%geodLat = mifGeolocation(qt%instrumentModule)%geodLat
        qt%lon = mifGeolocation(qt%instrumentModule)%lon
        qt%time => mifGeolocation(qt%instrumentModule)%time(1:1,:)
        qt%solarTime => mifGeolocation(qt%instrumentModule)%solarTime(1:1,:)
        qt%solarZenith => mifGeolocation(qt%instrumentModule)%solarZenith(1:1,:)
      end if
    end if

    call PVMIDLUnpack ( flag, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking flag" )
    if ( flag(1) ) then
      nullify ( qt%frequencies )
      call Allocate_test ( qt%frequencies, qt%noChans, &
        & 'qt%frequencies', ModuleName )
      call PVMIDLUnpack ( qt%frequencies, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking frequencies" )
    end if

    ! Finally the two arrays for irregular quantities
    if ( .not. qt%regular ) then
      call PVMIDLUnpack ( qt%surfIndex, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking surfIndex" )

      call PVMIDLUnpack ( qt%chanIndex, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking chanIndex" )
    end if

    ! Now the value/mask flags
    call PVMIDLUnPack ( l2, info ) 
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking value/mask flags" )
    noValues = l2(1)
    noMask = l2(2)

    ! Setup the values
    if ( .not. noValues .and. .not. present ( values ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Values sent but no place to put them' )

    if ( present ( values ) ) then

     call createVectorValue ( values, 'Values' )

      if ( .not. myJustUnpack .and. .not. all ((/noValues,noMask/)) ) then
        ! Now we're going to receive the values in a separate message
        call PVMFrecv ( tid, QtyMsgTag, bufferID )
      end if

      ! Unpack the values
      if ( .not. noValues ) then
        call PVMIDLUnpack ( values%values, info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking values" )
      endif

      ! Skip the mask for the moment.
      if ( .not. noMask ) then
        call CreateMask ( values )
        call PVMIDLUnpack ( values%mask, info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking mask" )
      end if

    end if

  end subroutine PVMReceiveQuantity

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: QuantityPVM.f90,v 2.29 2015/06/04 03:13:16 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module QuantityPVM

! $Log: QuantityPVM.f90,v $
! Revision 2.29  2015/06/04 03:13:16  vsnyder
! Make Surfs component of quantity template allocatable
!
! Revision 2.28  2015/06/02 23:55:11  vsnyder
! Eliminated pointer rank remapping for lat and lon
!
! Revision 2.27  2015/05/29 00:34:47  vsnyder
! Eliminate shared latitude and longitude fields
!
! Revision 2.26  2015/03/28 01:48:23  vsnyder
! Added support for 1-D and 3-D geolocation arrays
!
! Revision 2.25  2013/06/12 02:13:25  vsnyder
! Cruft removal
!
! Revision 2.24  2012/07/07 02:03:57  vsnyder
! Change type of VALUES argument to PVMReceiveQuantity from REAL to
! VectorValue_t.  Delete MASK argument, which nobody used.  Receive the
! mask into the MASK component of VALUES if it's sent.
!
! Revision 2.23  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.22  2006/11/29 03:05:19  vsnyder
! Remove unused USE names
!
! Revision 2.21  2006/08/03 01:10:06  vsnyder
! Put l2cf names in leak track database
!
! Revision 2.20  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.19  2005/03/15 23:48:55  pwagner
! PVMERRORMESSAGE now part of MLSMessageModule
!
! Revision 2.18  2003/07/07 20:28:53  livesey
! Removed a print statement
!
! Revision 2.17  2003/07/07 20:22:00  livesey
! Transfers additional stuff from quantity template
!
! Revision 2.16  2003/06/20 19:31:39  pwagner
! Changes to allow direct writing of products
!
! Revision 2.15  2003/05/13 04:46:55  livesey
! Changed some integer packing to strings
!
! Revision 2.14  2002/11/27 00:24:01  livesey
! Better handling of major frame quantities
!
! Revision 2.13  2002/10/08 00:09:13  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.12  2002/10/06 01:08:53  livesey
! Put in the skipMIFGeolocation functionality
!
! Revision 2.11  2002/10/05 00:42:52  livesey
! Modified to use stuff from MorePVM
!
! Revision 2.10  2002/08/16 21:41:13  livesey
! Bug fix in frequency transmission
!
! Revision 2.9  2002/07/01 23:50:46  vsnyder
! Add an important comment about memory leakage
!
! Revision 2.8  2002/02/05 02:39:59  vsnyder
! Change mask from 1-bit per to 8-bits per (using character)
!
! Revision 2.7  2002/02/01 23:50:36  livesey
! Added CVS log information
!
@


2.29
log
@Make Surfs component of quantity template allocatable
@
text
@d344 1
a344 1
        qt%phi => mifGeolocation(qt%instrumentModule)%phi
d352 1
a352 1
        qt%phi => mifGeolocation(qt%instrumentModule)%phi(1:1,:)
d421 1
a421 1
       "$Id: QuantityPVM.f90,v 2.28 2015/06/02 23:55:11 vsnyder Exp $"
d431 3
@


2.28
log
@Eliminated pointer rank remapping for lat and lon
@
text
@d343 1
a343 1
        qt%surfs => mifGeolocation(qt%instrumentModule)%surfs
a351 1
        nullify ( qt%surfs )
d421 1
a421 1
       "$Id: QuantityPVM.f90,v 2.27 2015/05/29 00:34:47 vsnyder Exp $"
d431 3
@


2.27
log
@Eliminate shared latitude and longitude fields
@
text
@d341 1
a341 1
      ! point to that (except don't point share latitude and longitude).
d345 2
a346 2
        qt%geodLat1 = mifGeolocation(qt%instrumentModule)%geodLat1
        qt%lon1 = mifGeolocation(qt%instrumentModule)%lon1
d354 2
a355 2
        qt%geodLat1 = mifGeolocation(qt%instrumentModule)%geodLat1
        qt%lon1 = mifGeolocation(qt%instrumentModule)%lon1
d422 1
a422 1
       "$Id: QuantityPVM.f90,v 2.26 2015/03/28 01:48:23 vsnyder Exp $"
d432 3
@


2.26
log
@Added support for 1-D and 3-D geolocation arrays
@
text
@d212 4
a215 3
    use Allocate_Deallocate, only: ALLOCATE_TEST
    use QuantityTemplates, only: QUANTITYTEMPLATE_T, SETUPNEWQUANTITYTEMPLATE
    use VectorsModule, only: CREATEMASK, CreateVectorValue, VectorValue_T
d222 2
a223 2
    logical, intent(in), optional :: JUSTUNPACK ! Just unpack from existing buffer
    type (QuantityTemplate_T), dimension(:), intent(in), optional :: MIFGEOLOCATION
d226 2
a227 2
    integer :: BUFFERID                 ! From pvm
    integer :: INFO                     ! Flag
d232 5
a236 5
    logical :: FLAG(1)                  ! To unpack
    character(len=132) :: WORD          ! Result of PVMIDLUnpack etc.
    logical :: MYJUSTUNPACK             ! Copy of justUnPack
    logical :: NOVALUES                 ! No values sent
    logical :: NOMASK                   ! No mask sent
d337 5
a341 1
      ! If it's minor frame and we've got mif geolocation information just point to that.
d345 2
a346 6
        qt%geodLat1 => mifGeolocation(qt%instrumentModule)%geodLat1
        qt%geodLat => mifGeolocation(qt%instrumentModule)%geodLat
        qt%geodLat3 => mifGeolocation(qt%instrumentModule)%geodLat3
        qt%lon1 => mifGeolocation(qt%instrumentModule)%lon1
        qt%lon => mifGeolocation(qt%instrumentModule)%lon
        qt%lon3 => mifGeolocation(qt%instrumentModule)%lon3
d354 2
a355 6
        qt%geodLat1 => mifGeolocation(qt%instrumentModule)%geodLat1
        qt%geodLat => mifGeolocation(qt%instrumentModule)%geodLat(1:1,:)
        qt%geodLat3 => mifGeolocation(qt%instrumentModule)%geodLat3(1:1,:,:)
        qt%lon1 => mifGeolocation(qt%instrumentModule)%lon1
        qt%lon => mifGeolocation(qt%instrumentModule)%lon(1:1,:)
        qt%lon3 => mifGeolocation(qt%instrumentModule)%lon3(1:1,:,:)
d422 1
a422 1
       "$Id: QuantityPVM.f90,v 2.25 2013/06/12 02:13:25 vsnyder Exp $"
d432 3
@


2.25
log
@Cruft removal
@
text
@d340 1
d342 2
d345 1
d353 1
d355 2
d358 1
d425 1
a425 1
       "$Id: QuantityPVM.f90,v 2.24 2012/07/07 02:03:57 vsnyder Exp $"
d435 3
@


2.24
log
@Change type of VALUES argument to PVMReceiveQuantity from REAL to
VectorValue_t.  Delete MASK argument, which nobody used.  Receive the
mask into the MASK component of VALUES if it's sent.
@
text
@a212 1
    use MLSCommon, only: R8
d417 1
a417 1
       "$Id: QuantityPVM.f90,v 2.23 2009/06/23 18:25:42 pwagner Exp $"
d427 5
@


2.23
log
@Prevent Intel from optimizing ident string away
@
text
@d28 1
a28 1
       "$RCSfile: $"
d176 1
a176 1
    call PVMIDLPAck ( (/ myNoValues, myNoMask /), info )
d211 1
a211 1
  subroutine PVMReceiveQuantity ( QT, values, tid, mask, justUnpack, mifGeolocation )
d215 1
a215 1
    use VectorsModule, only: CREATEMASKARRAY
d220 1
a220 1
    real (r8), dimension(:,:), optional, pointer :: VALUES ! Values for quantity
a221 1
    character, dimension(:,:), optional, pointer :: MASK ! Mask
a389 4
      nullify ( values )
      call Allocate_Test ( values, qt%instanceLen, qt%noInstances, &
        & 'values', ModuleName )
    endif
d391 6
a396 4
    if ( .not. myJustUnpack .and. .not. all ((/noValues,noMask/)) ) then
      ! Now we're going to receive the values in a separate message
      call PVMFrecv ( tid, QtyMsgTag, bufferID )
    end if
d398 5
a402 5
    ! Unpack the values
    if ( .not. noValues ) then
      call PVMIDLUnpack ( values, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking values" )
    endif
d404 1
a404 3
    ! Skip the mask for the moment.
    if ( present(mask) ) then
      nullify ( mask )
d406 2
a407 2
        call CreateMaskArray ( mask, values )
        call PVMIDLUnpack ( mask, info )
d409 2
a410 5
      endif
    else
      if ( .not. noMask ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Mask sent but no place to put it' )
d418 1
a418 1
       "$Id: read_apriori.f90 is it here $"
d428 3
@


2.22
log
@Remove unused USE names
@
text
@d28 1
a28 1
       "$RCSfile: QuantityPVM.f90,v $"
d423 1
a424 1
!---------------------------- RCS Ident Info -------------------------------
d426 2
a427 3
       "$Id: QuantityPVM.f90,v 2.21 2006/08/03 01:10:06 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d429 1
d431 1
d436 3
@


2.21
log
@Put l2cf names in leak track database
@
text
@a15 1
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
a20 5
  use String_Table, only: GET_STRING, DISPLAY_STRING
  use VectorsModule, only: VECTORVALUE_T
  use MLSCommon, only: R8
  use Intrinsic, only: LIT_INDICES
  use MLSSignals_m, only: GETSIGNALNAME
a21 3
  use QuantityTemplates, only: QUANTITYTEMPLATE_T, SETUPNEWQUANTITYTEMPLATE
  use Dump_0, only: DUMP
  use VectorsModule, only: CREATEMASKARRAY
d41 4
d212 4
d234 1
a234 1
    character(len=132) :: WORD          ! Result of get_string etc.
d426 1
a426 1
       "$Id: QuantityPVM.f90,v 2.20 2005/06/22 17:25:50 pwagner Exp $"
d435 3
@


2.20
log
@Reworded Copyright statement, moved rcs id
@
text
@d37 1
a37 1
       "$RCSfile: $"
d261 2
a298 2
    call PVMUnpackStringIndex ( qt%name, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking name" )
d427 1
a427 1
       "$Id: $"
d436 3
@


2.19
log
@PVMERRORMESSAGE now part of MLSMessageModule
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d35 1
a35 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: QuantityPVM.f90,v 2.18 2003/07/07 20:28:53 livesey Exp $"
  character (len=len(idParm)), private :: Id = idParm
d37 1
a37 1
       "$RCSfile: QuantityPVM.f90,v $"
d425 5
d436 3
@


2.18
log
@Removed a print statement
@
text
@d1 2
a2 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d9 1
a9 1
  use PVM, only: PVMDATADEFAULT, PVMFINITSEND, PVMFSEND, PVMERRORMESSAGE, &
d19 1
a19 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d29 1
a29 1
       "$Id: QuantityPVM.f90,v 2.17 2003/07/07 20:22:00 livesey Exp $"
d426 3
@


2.17
log
@Transfers additional stuff from quantity template
@
text
@d29 1
a29 1
       "$Id: QuantityPVM.f90,v 2.16 2003/06/20 19:31:39 pwagner Exp $"
a277 1
    print*,'Got instance offset as:', qt%instanceOffset
d426 3
@


2.16
log
@Changes to allow direct writing of products
@
text
@d29 1
a29 1
       "$Id: QuantityPVM.f90,v 2.15 2003/05/13 04:46:55 livesey Exp $"
d87 2
a88 1
      & q%template%instrumentModule, q%template%radiometer /), info )
d99 2
d226 1
a226 1
    integer :: I5(5)                    ! Unpacked stuff
d268 1
a268 1
    call PVMIDLUnPack ( i5, info )
d271 8
a278 5
    qt%noInstancesLowerOverlap = i5(1)
    qt%noInstancesUpperOverlap = i5(2)
    qt%sideband                = i5(3)
    qt%instrumentModule        = i5(4)
    qt%radiometer              = i5(5)
d289 2
d427 3
@


2.15
log
@Changed some integer packing to strings
@
text
@d29 1
a29 1
       "$Id: QuantityPVM.f90,v 2.14 2002/11/27 00:24:01 livesey Exp $"
d150 1
a150 9
      
      if ( associated ( q%template%mafIndex ) ) then
        call PVMIDLPack ( (/.true./), info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "packing flag" )
        call PVMIDLPack ( q%template%mafIndex, info )
      else
        call PVMIDLPack ( (/ .false. /), info )
      end if
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing mafIndex/flag" )
a151 10
      if ( associated ( q%template%mafCounter ) ) then
        call PVMIDLPack ( (/.true./), info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "packing flag" )
        call PVMIDLPack ( q%template%mafCounter, info )
      else
        call PVMIDLPack ( (/ .false. /), info )
      end if
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing mafCounter/flag" )
    end if
      
a325 14

      call PVMIDLUnpack ( flag, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking flag" )
      if ( flag(1) ) then
        call PVMIDLUnpack ( qt%mafIndex, info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking mafIndex" )
      end if

      call PVMIDLUnpack ( flag, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking flag" )
      if ( flag(1) ) then
        call PVMIDLUnpack ( qt%mafCounter, info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking mafCounter" )
      end if
a345 5
      if ( qt%minorFrame .or. qt%majorFrame ) then
        qt%mafIndex => mifGeolocation(qt%instrumentModule)%mafIndex
        qt%mafCounter => mifGeolocation(qt%instrumentModule)%mafCounter
      end if
      
d419 3
@


2.14
log
@Better handling of major frame quantities
@
text
@a4 1

d29 1
a29 1
       "$Id: QuantityPVM.f90,v 2.13 2002/10/08 00:09:13 pwagner Exp $"
d87 1
a87 4
      & q%template%instrumentModule, q%template%radiometer, &
      & q%template%quantityType, q%template%unit, q%template%frequencyCoordinate, &
      & q%template%molecule, q%template%verticalCoordinate,&
      & q%template%signal, q%template%name /), info )
d96 2
d100 4
a103 2
    call PVMPackLitIndex ( q%template%frequencyCoordinate, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing frequencyCoordinate" )
d241 1
a241 1
    integer :: I12(12)                  ! Unpacked stuff
d283 1
a283 1
    call PVMIDLUnPack ( i12, info )
d286 19
a304 33
    qt%noInstancesLowerOverlap = i12(1)
    qt%noInstancesUpperOverlap = i12(2)
    qt%sideband                = i12(3)
    qt%instrumentModule        = i12(4)
    qt%radiometer              = i12(5)
    qt%quantityType            = i12(6)
    qt%unit                    = i12(7)
    qt%frequencyCoordinate     = i12(8)
    qt%molecule                = i12(9)
    qt%verticalCoordinate      = i12(10)
    qt%signal                  = i12(11)
    qt%name                    = i12(12)

    ! Now unpack some strings
    call PVMIDLUnpack ( word, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking quantityType" )
    ! Just ignore it, we got it as an integer already

    call PVMIDLUnpack ( word, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking verticalCoordinate" )
    ! Just ignore it, we got it as an integer already

    call PVMIDLUnpack ( word, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking unit" )
    ! Just ignore it, we got it as an integer already

    call PVMIDLUnpack ( word, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking frequencyCoordiante" )
    ! Just ignore it, we got it as an integer already
d434 11
a444 4
    if ( .not. noMask .and. present(mask) ) then
      call CreateMaskArray ( mask, values )
      call PVMIDLUnpack ( mask, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking mask" )
d456 3
@


2.13
log
@Added idents to survive zealous Lahey optimizer
@
text
@d30 1
a30 1
       "$Id: QuantityPVM.f90,v 2.12 2002/10/06 01:08:53 livesey Exp $"
d83 1
a83 1
      & q%template%logBasis /), info ) 
d125 2
a126 1
    if ( .not. q%template%minorFrame .or. .not. mySkipMIFGeolocation ) then
d243 1
a243 1
    logical :: L5(5)                    ! Unpacked stuff
d267 1
a267 1
    call PVMIDLUnPack ( l5, info ) 
d275 3
a277 3
      & coherent     = l5(1), &
      & stacked      = l5(2), &
      & regular      = l5(3), &
d279 3
a281 2
      & minorFrame   = l5(4) )
    qt%logBasis = l5(5)
d331 2
a332 1
    if ( .not. qt%minorFrame .or. .not. present ( mifGeolocation ) ) then
d374 23
a396 9
      qt%surfs => mifGeolocation(qt%instrumentModule)%surfs
      qt%phi => mifGeolocation(qt%instrumentModule)%phi
      qt%geodLat => mifGeolocation(qt%instrumentModule)%geodLat
      qt%lon => mifGeolocation(qt%instrumentModule)%lon
      qt%time => mifGeolocation(qt%instrumentModule)%time
      qt%solarTime => mifGeolocation(qt%instrumentModule)%solarTime
      qt%solarZenith => mifGeolocation(qt%instrumentModule)%solarZenith
      qt%mafIndex => mifGeolocation(qt%instrumentModule)%mafIndex
      qt%mafCounter => mifGeolocation(qt%instrumentModule)%mafCounter
d463 3
@


2.12
log
@Put in the skipMIFGeolocation functionality
@
text
@d30 1
a30 1
       "$Id: QuantityPVM.f90,v 2.11 2002/10/05 00:42:52 livesey Exp $"
d34 1
d439 4
d446 3
@


2.11
log
@Modified to use stuff from MorePVM
@
text
@d20 1
d30 1
a30 1
       "$Id: QuantityPVM.f90,v 2.10 2002/08/16 21:41:13 livesey Exp $"
d44 1
a44 1
  subroutine PVMSendQuantity ( Q, tid, justPack, noValues, noMask )
d50 1
d58 1
d66 1
d70 1
d124 42
a165 31

    call PVMIDLPack ( q%template%surfs, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing surfs" )

    call PVMIDLPack ( q%template%phi, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing phi" )

    call PVMIDLPack ( q%template%geodLat, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing geodLat" )

    call PVMIDLPack ( q%template%lon, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing lon" )

    call PVMIDLPack ( q%template%time, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing time" )

    call PVMIDLPack ( q%template%solarTime, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing solarTime" )

    call PVMIDLPack ( q%template%solarZenith, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing solarZenith" )

    call PVMIDLPack ( q%template%losAngle, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing losAngle" )

    if ( associated ( q%template%mafIndex ) ) then
      call PVMIDLPack ( (/.true./), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing flag" )
      call PVMIDLPack ( q%template%mafIndex, info )
    else
      call PVMIDLPack ( (/ .false. /), info )
d167 1
a167 11
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing mafIndex/flag" )

    if ( associated ( q%template%mafCounter ) ) then
      call PVMIDLPack ( (/.true./), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "packing flag" )
      call PVMIDLPack ( q%template%mafCounter, info )
    else
      call PVMIDLPack ( (/ .false. /), info )
    end if
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing mafCounter/flag" )

d224 1
a224 1
  subroutine PVMReceiveQuantity ( QT, values, tid, mask, justUnpack )
d229 1
a229 1
    real (r8), dimension(:,:), pointer :: VALUES ! Values for quantity
d233 1
d301 1
a301 1
    
d328 1
d330 5
a334 5
    call PVMIDLUnpack ( qt%surfs, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking surfs" )
    
    call PVMIDLUnpack ( qt%phi, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking phi" )
d336 2
a337 2
    call PVMIDLUnpack ( qt%geodLat, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking geodLat" )
d339 2
a340 2
    call PVMIDLUnpack ( qt%lon, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking lon" )
d342 2
a343 2
    call PVMIDLUnpack ( qt%time, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking time" )
d345 2
a346 2
    call PVMIDLUnpack ( qt%solarTime, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking solarTime" )
d348 2
a349 2
    call PVMIDLUnpack ( qt%solarZenith, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking solarZenith" )
d351 2
a352 2
    call PVMIDLUnpack ( qt%losAngle, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking losAngle" )
d355 6
a360 6
    call PVMIDLUnpack ( flag, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking flag" )
    if ( flag(1) ) then
      call PVMIDLUnpack ( qt%mafIndex, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking mafIndex" )
    end if
d362 17
a378 5
    call PVMIDLUnpack ( flag, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking flag" )
    if ( flag(1) ) then
      call PVMIDLUnpack ( qt%mafCounter, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking mafCounter" )
d408 9
a416 3
    nullify ( values )
    call Allocate_Test ( values, qt%instanceLen, qt%noInstances, &
      & 'values', ModuleName )
d435 1
a435 1
      
d441 3
@


2.10
log
@Bug fix in frequency transmission
@
text
@d13 2
d29 1
a29 1
       "$Id: QuantityPVM.f90,v 2.9 2002/07/01 23:50:46 vsnyder Exp $"
d90 1
a90 2
    call Get_String( lit_indices(q%template%quantityType), word, noError=.true. )
    call PVMIDLPack ( trim(word), info )
d92 1
a92 3

    call Get_String( lit_indices(q%template%verticalCoordinate), word, noError=.true. )
    call PVMIDLPack ( trim(word), info )
d94 1
a94 3

    call Get_String( lit_indices(q%template%unit), word, noError=.true. )
    call PVMIDLPack ( trim(word), info )
d96 1
a96 3

    call Get_String( lit_indices(q%template%frequencyCoordinate), word, noError=.true. )
    call PVMIDLPack ( trim(word), info )
d415 3
@


2.9
log
@Add an important comment about memory leakage
@
text
@d27 1
a27 1
       "$Id: QuantityPVM.f90,v 2.8 2002/02/05 02:39:59 vsnyder Exp $"
d369 3
d420 3
@


2.8
log
@Change mask from 1-bit per to 8-bits per (using character)
@
text
@d27 1
a27 1
       "$Id: QuantityPVM.f90,v 2.7 2002/02/01 23:50:36 livesey Exp $"
d225 3
d417 3
@


2.7
log
@Added CVS log information
@
text
@d27 1
a27 1
       "$Id: QuantityPVM.f90,v 2.6 2001/07/17 17:33:03 livesey Exp $"
d227 1
a227 1
    integer, dimension(:,:), optional, pointer :: MASK ! Mask
d413 4
a416 1
! $Log$
@


2.6
log
@Added noValues, noMask flags to pack etc.
@
text
@d27 1
a27 1
       "$Id: QuantityPVM.f90,v 2.5 2001/05/30 23:52:38 livesey Exp $"
d413 1
a413 1

@


2.5
log
@Now has optional just(un)pack arguments to send and receive
@
text
@d20 1
d27 1
a27 1
       "$Id: QuantityPVM.f90,v 2.4 2001/05/25 01:04:47 livesey Exp $"
d41 1
a41 1
  subroutine PVMSendQuantity ( Q, tid, justPack )
d45 2
d52 2
d59 2
d62 2
d186 5
d198 2
a199 1
      call PVMFInitSend ( PVMDataDefault, bufferID)
d203 4
a206 2
    call PVMIDLPack ( q%values, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "sending values" )
d209 4
d215 1
a215 1
    if (.not. myJustPack) then
d223 1
a223 1
  subroutine PVMReceiveQuantity ( QT, values, tid, justUnpack )
d227 1
d235 1
d239 3
a241 1
    logical :: MYJUSTUNPACK
d379 7
d391 1
a391 1
    if ( .not. myJustUnpack ) then
d397 4
a400 2
    call PVMIDLUnpack ( values, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "unpacking values" )
d403 5
@


2.4
log
@Added name to stuff sent
@
text
@d26 1
a26 1
       "$Id: QuantityPVM.f90,v 2.3 2001/05/23 22:00:32 livesey Exp $"
d40 1
a40 1
  subroutine PVMSendQuantity ( Q, tid )
d42 2
a43 1
    integer, intent(in) :: TID          ! Task to send it to
d48 1
d53 2
d57 1
a57 1
    call PVMFInitSend ( PvmDataDefault, bufferID )
d179 7
a185 5
    call PVMFSend ( tid, QtyMsgTag, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "sending vector template" )

    ! Now we're going to send the values in a separate message
    call PVMFInitSend ( PVMDataDefault, bufferID)
d194 4
a197 2
    call PVMFSend ( tid, QtyMsgTag, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "sending vector values" )
d202 1
a202 1
  subroutine PVMReceiveQuantity ( QT, values, tid )
d205 2
a206 1
    integer, intent(in) :: TID          ! Task to get it from
d216 1
a218 1
    ! Get buffer, we'll wait for it, assume the calling code knows it's coming.
d220 7
a226 1
    call PVMFrecv ( tid, QtyMsgTag, bufferID )
d359 4
a362 2
    ! Now we're going to receive the values in a separate message
    call PVMFrecv ( tid, QtyMsgTag, bufferID )
@


2.3
log
@Interim version
@
text
@d19 1
d26 1
a26 1
       "$Id: QuantityPVM.f90,v 2.2 2001/05/23 03:29:12 livesey Exp $"
d70 1
a70 1
      & q%template%signal /), info )
a91 1
    
d203 1
a203 1
    integer :: I11(11)                  ! Unpacked stuff
d235 1
a235 1
    call PVMIDLUnPack ( i11, info )
d238 12
a249 11
    qt%noInstancesLowerOverlap = i11(1)
    qt%noInstancesUpperOverlap = i11(2)
    qt%sideband                = i11(3)
    qt%instrumentModule        = i11(4)
    qt%radiometer              = i11(5)
    qt%quantityType            = i11(6)
    qt%unit                    = i11(7)
    qt%frequencyCoordinate     = i11(8)
    qt%molecule                = i11(9)
    qt%verticalCoordinate      = i11(10)
    qt%signal                  = i11(11)
d286 1
a286 1

@


2.2
log
@Updates and bug fixes etc.
@
text
@a9 1
  use Declaration_Table, only: DECLS, ENUM_VALUE, GET_DECL
d13 1
a13 1
  use String_Table, only: GET_STRING
a17 2
  use Symbol_Table, only: ENTER_TERMINAL
  use Symbol_Types, only: T_IDENTIFIER
a18 1
  use Parse_Signal_m, only: PARSE_SIGNAL
d25 1
a25 1
       "$Id: QuantityPVM.f90,v 2.1 2001/05/23 02:45:38 livesey Exp $"
d65 5
a69 1
      & q%template%noInstancesUpperOverlap, q%template%sideband /), info )
d90 2
a100 18
    if ( q%template%instrumentModule >= lbound(lit_indices,1) .and. &
      &  q%template%instrumentModule <= ubound(lit_indices,1) ) then
      call Get_String( lit_indices(q%template%instrumentModule), word, noError=.true. )
    else
      word = ''
    endif
    call PVMIDLPack ( trim(word), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing instrumentModule" )

    if ( q%template%radiometer >= lbound(lit_indices,1) .and. &
      &  q%template%radiometer <= ubound(lit_indices,1) ) then
      call Get_String( lit_indices(q%template%radiometer), word, noError=.true. )
    else
      word = ''
    endif
    call PVMIDLPack ( trim(word), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing radiometer" )

a201 3
    integer :: STRINGINDEX              ! For unpacking strings
    integer, dimension(:), pointer :: SIGINDS ! Result of parse signal
    integer :: I3(4)                    ! Unpacked stuff
d203 1
a206 1
    type (Decls) :: Decl                ! Declaration
d235 1
a235 1
    call PVMIDLUnPack ( i3, info )
d238 11
a248 3
    qt%noInstancesLowerOverlap = i3(1)
    qt%noInstancesUpperOverlap = i3(2)
    qt%sideband                = i3(3)
d254 1
a254 3
    stringIndex = enter_terminal ( trim(word), t_identifier )
    decl = get_decl ( stringIndex, type=enum_value )
    qt%quantityType = decl%units
d259 1
a259 3
    stringIndex = enter_terminal ( trim(word), t_identifier )
    decl = get_decl ( stringIndex, type=enum_value )
    qt%verticalCoordinate = decl%units
d264 1
a264 3
    stringIndex = enter_terminal ( trim(word), t_identifier )
    decl = get_decl ( stringIndex, type=enum_value )
    qt%unit = decl%units
d269 1
a269 3
    stringIndex = enter_terminal ( trim(word), t_identifier )
    decl = get_decl ( stringIndex, type=enum_value )
    qt%frequencyCoordinate = decl%units
d274 1
a274 17
    call Parse_Signal ( word, sigInds )
    qt%signal = sigInds(1)
    call deallocate_test( sigInds, 'sigInds', ModuleName )

    call PVMIDLUnpack ( word, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking instrumentModule" )
    stringIndex = enter_terminal ( trim(word), t_identifier )
    decl = get_decl ( stringIndex, type=enum_value )
    qt%instrumentModule = decl%units

    call PVMIDLUnpack ( word, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking radiometer" )
    stringIndex = enter_terminal ( trim(word), t_identifier )
    decl = get_decl ( stringIndex, type=enum_value )
    qt%radiometer = decl%units
d279 1
a279 3
    stringIndex = enter_terminal ( trim(word), t_identifier )
    decl = get_decl ( stringIndex, type=enum_value )
    qt%molecule = decl%units
@


2.1
log
@First version
@
text
@d29 1
a29 1
       "$Id: VectorsModule.f90,v 2.43 2001/05/17 20:17:00 vsnyder Exp $"
d32 1
a32 1
       "$RCSfile: VectorsModule.f90,v $"
d90 6
a95 2
    call GetSignalName( lit_indices(q%template%signal), &
      & word, sideband=q%template%sideband )
d99 6
a104 1
    call Get_String( lit_indices(q%template%instrumentModule), word, noError=.true. )
d108 6
a113 1
    call Get_String( lit_indices(q%template%radiometer), word, noError=.true. )
d117 6
a122 1
    call Get_String( lit_indices(q%template%molecule), word, noError=.true. )
@

