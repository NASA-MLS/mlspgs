head	2.58;
access;
symbols
	v5-02-NRT-19:2.58
	v6-00:2.58
	v5-02-NRT-18:2.58
	v5-02:2.57
	v5-01-NRT-17:2.58
	v5-01-NRT-16:2.58
	v5-01-NRT-15:2.58
	v5-01-NRT-14:2.58
	neuralnetworks-1-0:2.58.0.4
	cfm-single-freq-0-1:2.58.0.2
	v5-01:2.57
	v5-00:2.57
	v4-23-TA133:2.56.0.4
	mus-emls-1-70:2.56.0.2
	rel-1-0-englocks-work:2.53.0.2
	VUMLS1-00:2.52
	VPL1-00:2.51
	V4-22-NRT-08:2.51
	VAM1-00:2.51
	V4-21:2.48.0.2
	V4-13:2.48
	V4-12:2.46
	V4-11:2.45
	V4-10:2.44
	V3-43:2.36
	M4-00:2.37
	V3-41:2.36
	V3-40-PlusGM57:2.36.0.2
	V2-24-NRT-04:2.33
	V3-33:2.36
	V2-24:2.33
	V3-31:2.36
	V3-30-NRT-05:2.36
	cfm-01-00:2.36
	V3-30:2.36
	V3-20:2.36
	V3-10:2.36
	V2-23-NRT-02:2.33
	V2-23:2.33
	V2-22-NRT-01:2.33
	V2-22:2.33
	V2-21:2.32
	V2-20:2.32
	V2-11:2.30
	V2-10:2.30
	V2-00:2.27
	V1-51:2.19
	V1-50:2.19
	V1-45:2.16
	V1-44:2.16
	V1-43:2.16
	V1-42:2.11
	V1-41:2.11
	V1-32:2.11
	V1-40:2.11
	V1-31:2.11
	V1-30:2.11
	V1-13:2.11
	V1-12:2.11
	V1-11:2.11
	V1-10:2.11
	newfwm-feb03:2.11.0.2
	V1-04:2.9
	V1-03:2.9
	V1-02:2.9
	V1-00:2.9
	newfwm-sep01:2.6.0.2
	V0-7:2.6
	V0-5-Level2:2.5
	V0-5-SIPS:2.5;
locks; strict;
comment	@# @;


2.58
date	2020.04.27.21.29.46;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2019.08.19.21.58.18;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2018.05.15.03.17.36;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2018.04.19.02.00.36;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2018.04.10.22.51.33;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2017.10.31.23.42.57;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2016.09.07.23.54.37;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2015.06.04.01.55.17;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2015.06.02.23.51.40;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2015.03.27.01.10.38;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2014.09.04.23.37.01;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2014.08.06.23.18.04;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2014.06.30.23.24.17;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2014.05.29.18.20.27;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2014.01.09.00.25.06;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2013.10.09.01.02.05;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2013.08.28.00.38.17;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2013.08.16.02.05.34;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2013.08.16.01.06.22;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2013.06.12.02.50.45;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2013.06.12.02.17.03;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2011.03.02.01.59.07;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2008.05.21.21.49.26;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2008.05.20.01.59.28;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2007.07.27.00.19.30;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2006.08.05.02.36.57;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2006.08.04.18.12.56;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2006.07.29.03.01.07;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2006.07.28.01.57.25;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2006.07.19.22.24.18;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2005.12.16.23.25.37;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2005.11.18.21.09.35;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2005.10.03.18.04.51;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2005.09.16.23.38.20;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2005.07.20.16.22.52;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2005.07.20.01.32.55;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2005.06.03.01.53.06;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2005.06.01.02.30.30;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2004.12.28.00.24.39;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2004.10.30.00.23.21;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2004.10.02.02.42.35;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2004.04.06.23.49.59;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2004.04.05.17.47.56;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2004.04.03.05.43.53;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2004.01.30.21.20.35;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2004.01.24.01.01.05;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2002.10.08.00.09.08;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2002.07.01.23.47.08;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2002.02.05.00.42.47;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2002.02.01.01.48.17;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.09.10.21.05.01;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.05.30.23.52.15;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.04.02.20.50.27;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.24.23.25.57;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.22.01.54.41;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2000.10.09.23.03.49;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.09.15.21.50.18;	author livesey;	state Exp;
branches;
next	;


desc
@@


2.58
log
@Separately track allocates/deallocates
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module Allocate_Deallocate
!=============================================================================

! This module contains procedures to allocate, test the allocation,
! and announce an error if it fails, and similarly for deallocation,
! for Real, Double precision, Integer and Character arrays.

! **************************************************
! *****     Important Notice:                  *****
! **************************************************
! *****     All of the specific procedures     *****
! *****     of the Allocate_test generic       *****
! *****     deallocate the object to be        *****
! *****     allocated.  Therefore, it must     *****
! *****     be declared with => NULL() or      *****
! *****     nullified before its first use     *****
! **************************************************

  use HighOutput, only: FinalMemoryReport
  use, Intrinsic :: Ieee_Arithmetic, only: Ieee_Signaling_Nan, Ieee_Value, &
    & Ieee_Support_Datatype
  use Iso_C_Binding, only: C_Intptr_T, C_Loc
  use Machine, only: MLS_Gc_Now
  use MLSCommon, only: NoBlocksAllocated, NoBlocksDeAllocated, &
    & NoBytesAllocated, TotalAllocated, TotalDeAllocated
  use Printit_M, only: MLSMSG_Allocate, MLSMSG_Deallocate, &
    & MLSMSG_Error, MLSMSG_Warning, Printitout, Sniprcsfrom
  use Track_M, only: Trackallocate, Trackdeallocate

  implicit none
!   private

  public :: Byte_Size, Bytes, Allocate_Test, Deallocate_Test, dealloc_status, & 
    & FinalMemoryReport, NoBytesAllocated, Reportallocatedeallocate, &
    & Same_Shape, Set_garbage_collection, Test_Allocate, Test_Deallocate

  interface Allocate_Test
    ! For separate scalar arguments for bounds
    module procedure Allocate_Test_Character_1D, Allocate_Test_Character_2D
    module procedure Allocate_Test_Character_3D
    module procedure Allocate_Test_Complex_1D, Allocate_Test_Complex_2D
    module procedure Allocate_Test_Complex_3D
    module procedure Allocate_Test_DComplex_1D, Allocate_Test_DComplex_2D
    module procedure Allocate_Test_DComplex_3D
    module procedure Allocate_Test_Integer_1D, Allocate_Test_Integer_2D
    module procedure Allocate_Test_Integer_3D, Allocate_Test_Integer_4D
    module procedure Allocate_Test_Logical_1D, Allocate_Test_Logical_2D
    module procedure Allocate_Test_Logical_3D
    module procedure Allocate_Test_RealR4_1D, Allocate_Test_RealR4_2D
    module procedure Allocate_Test_RealR4_3D, Allocate_Test_RealR4_4D
    module procedure Allocate_Test_RealR8_1D, Allocate_Test_RealR8_2D
    module procedure Allocate_Test_RealR8_3D, Allocate_Test_RealR8_4D
    ! For allocatable instead of pointer, with scalar arguments for bounds
    module procedure AllocateA_Test_Character_1D, AllocateA_Test_Character_2D
    module procedure AllocateA_Test_Integer_1D, AllocateA_Test_Integer_2D
    module procedure AllocateA_Test_Integer_3D, AllocateA_Test_Integer_4D
    module procedure AllocateA_Test_Logical_1D, AllocateA_Test_Logical_2D
    module procedure AllocateA_Test_Logical_3D
    module procedure AllocateA_Test_RealR4_1D, AllocateA_Test_RealR4_2D
    module procedure AllocateA_Test_RealR4_3D, AllocateA_Test_RealR4_4D
    module procedure AllocateA_Test_RealR8_1D, AllocateA_Test_RealR8_2D
    module procedure AllocateA_Test_RealR8_3D, AllocateA_Test_RealR8_4D
    ! For array arguments for bounds
    module procedure Allocate_Test_Character_2D_A, Allocate_Test_Character_3D_A
    module procedure Allocate_Test_Complex_2D_A, Allocate_Test_Complex_3D_A
    module procedure Allocate_Test_DComplex_2D_A, Allocate_Test_DComplex_3D_A
    module procedure Allocate_Test_Integer_2D_A
    module procedure Allocate_Test_Integer_3D_A, Allocate_Test_Integer_4D_A
    module procedure Allocate_Test_Logical_2D_A, Allocate_Test_Logical_3D_A
    module procedure Allocate_Test_RealR4_2D_A
    module procedure Allocate_Test_RealR4_3D_A, Allocate_Test_RealR4_4D_A
    module procedure Allocate_Test_RealR8_2D_A
    module procedure Allocate_Test_RealR8_3D_A, Allocate_Test_RealR8_4D_A
    ! For allocatable instead of pointer, with array arguments for bounds
    module procedure AllocateA_Test_Integer_2D_A
    module procedure AllocateA_Test_Integer_3D_A, AllocateA_Test_Integer_4D_A
    module procedure AllocateA_Test_RealR4_2D_A
    module procedure AllocateA_Test_RealR4_3D_A, AllocateA_Test_RealR4_4D_A
    module procedure AllocateA_Test_RealR8_2D_A
    module procedure AllocateA_Test_RealR8_3D_A, AllocateA_Test_RealR8_4D_A
  end interface

  interface Deallocate_Test
    module procedure Deallocate_Test_Character_1D, Deallocate_Test_Character_2D
    module procedure Deallocate_Test_Character_3D
    module procedure Deallocate_Test_Complex_1D, Deallocate_Test_Complex_2D
    module procedure Deallocate_Test_Complex_3D
    module procedure Deallocate_Test_DComplex_1D, Deallocate_Test_DComplex_2D
    module procedure Deallocate_Test_DComplex_3D
    module procedure Deallocate_Test_Integer_1D, Deallocate_Test_Integer_2D
    module procedure Deallocate_Test_Integer_3D, Deallocate_Test_Integer_4D
    module procedure Deallocate_Test_Logical_1D, Deallocate_Test_Logical_2D
    module procedure Deallocate_Test_Logical_3D
    module procedure Deallocate_Test_RealR4_1D, Deallocate_Test_RealR4_2D
    module procedure Deallocate_Test_RealR4_3D, Deallocate_Test_RealR4_4D
    module procedure Deallocate_Test_RealR8_1D, Deallocate_Test_RealR8_2D
    module procedure Deallocate_Test_RealR8_3D, Deallocate_Test_RealR8_4D
    ! For allocatable instead of pointer argument
    module procedure DeallocateA_Test_Character_1D, DeallocateA_Test_Character_2D
    module procedure DeallocateA_Test_Integer_1D, DeallocateA_Test_Integer_2D
    module procedure DeallocateA_Test_Integer_3D, DeallocateA_Test_Integer_4D
    module procedure DeallocateA_Test_Logical_1D, DeallocateA_Test_Logical_2D
    module procedure DeallocateA_Test_Logical_3D
    module procedure DeallocateA_Test_RealR4_1D, DeallocateA_Test_RealR4_2D
    module procedure DeallocateA_Test_RealR4_3D, DeallocateA_Test_RealR4_4D
    module procedure DeallocateA_Test_RealR8_1D, DeallocateA_Test_RealR8_2D
    module procedure DeallocateA_Test_RealR8_3D, DeallocateA_Test_RealR8_4D
  end interface

  ! Size in bytes of an array
  interface Byte_Size
    module procedure Byte_Size_Character_1D, Byte_Size_Character_2D
    module procedure Byte_Size_Character_3D
    module procedure Byte_Size_Complex_1D, Byte_Size_Complex_2D
    module procedure Byte_Size_Complex_3D
    module procedure Byte_Size_DComplex_1D, Byte_Size_DComplex_2D
    module procedure Byte_Size_DComplex_3D
    module procedure Byte_Size_Integer_1D, Byte_Size_Integer_2D
    module procedure Byte_Size_Integer_3D, Byte_Size_Integer_4D
    module procedure Byte_Size_Logical_1D, Byte_Size_Logical_2D
    module procedure Byte_Size_Logical_3D
    module procedure Byte_Size_RealR4_1D, Byte_Size_RealR4_2D
    module procedure Byte_Size_RealR4_3D, Byte_Size_RealR4_4D
    module procedure Byte_Size_RealR4_5D, Byte_Size_RealR4_6D
    module procedure Byte_Size_RealR8_1D, Byte_Size_RealR8_2D
    module procedure Byte_Size_RealR8_3D, Byte_Size_RealR8_4D
    module procedure Byte_Size_RealR8_5D, Byte_Size_RealR8_6D
  end interface

  ! Size in bytes of a scalar; includes character length
  interface BYTES
    module procedure Bytes_Character_1D, Bytes_Character_2D
    module procedure Bytes_Character_3D
    module procedure Bytes_Complex_1D, Bytes_Complex_2D, Bytes_Complex_3D
    module procedure Bytes_DComplex_1D, Bytes_DComplex_2D, Bytes_DComplex_3D
    module procedure Bytes_Integer_1D, Bytes_Integer_2D
    module procedure Bytes_Integer_3D, Bytes_Integer_4D
    module procedure Bytes_Logical_1D, Bytes_Logical_2D, Bytes_Logical_3D
    module procedure Bytes_RealR4_1D, Bytes_RealR4_2D
    module procedure Bytes_RealR4_3D, Bytes_RealR4_4D
    module procedure Bytes_RealR4_5D, Bytes_RealR4_6D
    module procedure Bytes_RealR8_1D, Bytes_RealR8_2D
    module procedure Bytes_RealR8_3D, Bytes_RealR8_4D
    module procedure Bytes_RealR8_5D, Bytes_RealR8_6D
  end interface

  interface ReportAllocateDeallocate
    module procedure ReportAllocateDeallocate_ints
    module procedure ReportAllocateDeallocate_Real
  end interface

  ! subroutine Same_Shape ( Ref, New, ItsName, ModuleName )
  ! If Ref is not associated, deallocate New.  Otherwise, if Ref and New
  ! have the same shape (but not necessarily the same bounds), do nothing.
  ! Otherwise, allocate New with the same bounds as Ref.
  ! subroutine Same_Shape ( New, ItsName, ModuleName, TheShape )
  ! If New is not associated, or if any of its dimensions are different
  ! from TheShape, allocate New with the shape given by TheShape.
  ! The reason to put TheShape at the end is so as not to have a generic
  ! conflict with the integer versions.
  interface Same_Shape
    module procedure Same_Shape_Character_1D, Same_Shape_Character_2D
    module procedure Same_Shape_Character_3D
    module procedure Same_Shape_Complex_1D, Same_Shape_Complex_2D
    module procedure Same_Shape_Complex_3D
    module procedure Same_Shape_DComplex_1D, Same_Shape_DComplex_2D
    module procedure Same_Shape_DComplex_3D
    module procedure Same_Shape_Integer_1D, Same_Shape_Integer_2D
    module procedure Same_Shape_Integer_3D, Same_Shape_Integer_4D
    module procedure Same_Shape_Logical_1D, Same_Shape_Logical_2D
    module procedure Same_Shape_Logical_3D
    module procedure Same_Shape_RealR4_1D, Same_Shape_RealR4_2D
    module procedure Same_Shape_RealR4_3D, Same_Shape_RealR4_4D
    module procedure Same_Shape_RealR8_1D, Same_Shape_RealR8_2D
    module procedure Same_Shape_RealR8_3D, Same_Shape_RealR8_4D
    module procedure Same_Shape_Character_1D_A, Same_Shape_Character_2D_A
    module procedure Same_Shape_Character_3D_A
    module procedure Same_Shape_Complex_1D_A, Same_Shape_Complex_2D_A
    module procedure Same_Shape_Complex_3D_A
    module procedure Same_Shape_DComplex_1D_A, Same_Shape_DComplex_2D_A
    module procedure Same_Shape_DComplex_3D_A
    module procedure Same_Shape_Integer_1D_A, Same_Shape_Integer_2D_A
    module procedure Same_Shape_Integer_3D_A, Same_Shape_Integer_4D_A
    module procedure Same_Shape_Logical_1D_A, Same_Shape_Logical_2D_A
    module procedure Same_Shape_Logical_3D_A
    module procedure Same_Shape_RealR4_1D_A, Same_Shape_RealR4_2D_A
    module procedure Same_Shape_RealR4_3D_A, Same_Shape_RealR4_4D_A
    module procedure Same_Shape_RealR8_1D_A, Same_Shape_RealR8_2D_A
    module procedure Same_Shape_RealR8_3D_A, Same_Shape_RealR8_4D_A
  end interface

  interface Test_Allocate
    module procedure Test_Allocate_nd, Test_Allocate_1d
  end interface

  interface Test_Deallocate
    module procedure Test_Deallocate_int_s
  end interface

  integer, save :: Dealloc_Status = 0

  logical, public :: ClearOnAllocate = .false. ! If true, zero all allocated stuff
  logical, public :: InitRealNaN = .false.     ! If true, and FILL is not present,
                                               ! and IEEE_SupportDataType is true,
                                               ! fill real with signaling NaN.
  integer, public :: TrackAllocates = 0 ! <= 0 => No tracking
                                        ! == 1 => Track using the Track_m module
                                        ! == 2 => Report all transactions
                                        ! == 3 => Both track and report
  integer, public :: AllocateLogUnit = -1 ! If > 0, log allocates to this unit
  real, public ::    AllocateLogLimit = 1. ! Don't log amounts smaller than this

  ! Element sizes (bytes)
  integer, parameter, public :: E_Ch = ( storage_size(' ') + 7 ) / 8 ! Character
    ! Default integer, logical and real:
  integer, parameter, public :: E_Def = (storage_size(0.0) + 7 ) / 8
  integer, parameter, public :: E_DP = 2 * e_def ! DP and Complex

  logical, save, private :: COLLECT_GARBAGE_EACH_TIME = .false.

  double precision, parameter  :: OUTPUT_UNITS = 1.d6 ! output in MB
  logical, parameter :: DEEBUG = .false.

  integer(selected_int_kind(18)) :: Serial_No = 0 ! for logging

  !------------------------------- RCS Ident Info ------------------------------
  character(len=*), parameter, private :: ModuleName = &
    & "$RCSfile: Allocate_Deallocate.f90,v $"
  private :: not_used_here 
  !-----------------------------------------------------------------------------

contains
  ! =====     Public Procedures      ===================================

  !-----------------------------------   ReportAllocateDeallocate_ints  -----
  subroutine ReportAllocateDeallocate_ints ( name, moduleName, noBytes, bounds )
    ! Dummy arguments
    character (len=*), intent(in) :: NAME ! Name of thing allocated
    character (len=*), intent(in) :: MODULENAME ! Module that allocated it
    integer, intent(in) :: noBytes      ! No bytes allocated (or deallocated if -ve)
    character (len=*), intent(in), optional :: Bounds ! for allocation

    call ReportAllocateDeallocate( name, moduleName, real(noBytes), bounds )
  end subroutine ReportAllocateDeallocate_ints

  !-----------------------------------   ReportAllocateDeallocate_Real  -----
  subroutine ReportAllocateDeallocate_Real ( name, moduleName, noBytes, bounds )
    use Output_M, only: Output
    use HighOutput, only: Dumpsize
    ! Dummy arguments
    character (len=*), intent(in) :: NAME ! Name of thing allocated
    character (len=*), intent(in) :: MODULENAME ! Module that allocated it
    real, intent(in) :: noBytes      ! No bytes allocated (or deallocated if -ve)
    character (len=*), intent(in), optional :: Bounds ! for allocation

    ! Executable code
    if ( trackAllocates <= 0 ) return        ! Most probably will not be called anyway
    ! print *, 'noBytes: ', noBytes
    if ( noBytes > 0 ) then
      TotalAllocated = TotalAllocated + noBytes
      NoBlocksAllocated = NoBlocksAllocated + 1
    elseif ( noBytes < 0 ) then
      TotalDeAllocated = TotalDeAllocated - noBytes
      NoBlocksDeAllocated = NoBlocksDeAllocated + 1
    endif
    noBytesAllocated = noBytesAllocated + noBytes
    call output ( 'Tracking: ' )
    if ( noBytes < 0.0 ) then
      call output ( 'Dea' )
    else
      call output ( 'A' )
    end if
    call output ( 'llocated ' )
    call DumpSize ( abs ( noBytes ) )
    call output ( ' for ' // trim ( name ) )
    if ( present(bounds) ) call output ( trim(bounds) )
    call output ( ' in ' )
    if ( moduleName(1:1) == '$' ) then
      ! The moduleNameIn is <dollar>RCSFile: <filename>,v <dollar>
      call output ( moduleName(11:(len_trim(moduleName)-8)) )
    else
      call output ( moduleName )
    end if
    call output ( ' total ' )
    call DumpSize ( noBytesAllocated, advance='yes' )
  end subroutine ReportAllocateDeallocate_Real

  ! -------------------------------------  Set_garbage_collection  -----
  subroutine Set_garbage_collection ( setting )
    logical :: setting
    collect_garbage_each_time = setting
  end subroutine Set_garbage_collection

  ! -------------------------------------------  Test_Allocate_nd  -----
  subroutine Test_Allocate_nd ( Status, ModuleNameIn, ItsName, &
    & lBounds, uBounds, ElementSize, ERMSG, Address )
    use HIGHOUTPUT, only: outputNamedValue
  ! Test the status from an allocate.  If it's nonzero, issue a message.
  ! Track allocations if TrackAllocates is >= 2 and ElementSize is present
  ! and > 0.
    integer, intent(in) :: Status
    character(len=*), intent(in) :: ModuleNameIn, ItsName
    integer, intent(in), optional :: Lbounds(:), Ubounds(:)
    integer, intent(in), optional :: ElementSize ! Bytes, <= 0 for no tracking
    character(*), intent(in), optional :: ERMSG  ! from Allocate statement
    integer(c_intptr_t), intent(in), optional :: Address ! of allocated object
                                                         ! if status == 0
    real :: Amount
    character(127) :: Bounds
    integer :: I, L

    if ( status /= 0 .or. present(ubounds) .and. &
      & present(elementSize) .and. trackAllocates >= 2 ) then
      ! print *, 'status ', status
      if ( present(ubounds) ) then
        if ( present(lbounds) ) then
          write ( bounds, '("(",i0,":",i0, 6(:",",i0,":",i0))' ) &
            & ( lBounds(i), uBounds(i), i = 1, size(lBounds) )
        else
          write ( bounds, '("(",i0,6(:",",i0))' ) ubounds
        end if
        l = len_trim(bounds)+1
        bounds(l:l)= ')'
        write ( bounds(l+1:), '(", status = ", i0)' ) status
        l = len_trim(bounds)
      else
        l = 0
        bounds(1:1) = ''
      end if
      if ( status /= 0 ) then
        if ( present(ermsg) ) then
          bounds(l+2:) = ermsg
          l = len_trim(bounds)
        end if
        call myMessage ( MLSMSG_Error, moduleNameIn, &
          & MLSMSG_Allocate // ItsName  // bounds(:l) )
      end if
    end if
    if ( AllocateLogUnit > 0 ) call LogAllocate( ModuleNameIn, ItsName, &
      & lBounds, uBounds, ElementSize, Address )

    if ( .not. present(elementSize) ) return

    if ( present(ubounds) ) then
      if ( elementSize > 0 ) then
        amount = 0
        if ( present(lbounds) ) then
          amount = memproduct(elementSize, ubounds-lbounds+1)
        else
          amount = memproduct(elementSize, ubounds)
        end if
        if ( trackAllocates >= 2 ) then
          call ReportAllocateDeallocate ( itsName, moduleNameIn, amount, bounds )
        else
          if ( amount > 0 ) then
            TotalAllocated = TotalAllocated + amount
            NoBlocksAllocated = NoBlocksAllocated + 1
          elseif ( amount < 0 ) then
            TotalDeAllocated = TotalDeAllocated - amount
            NoBlocksDeAllocated = NoBlocksDeAllocated + 1
          endif
          noBytesAllocated = noBytesAllocated + amount
          if ( DEEBUG ) &
            & call outputNamedValue( itsname, &
            & (/noBytesAllocated, amount*1.d0/)/OUTPUT_UNITS )
        end if
      end if
    end if

  end subroutine Test_Allocate_nd

  ! -------------------------------------------  Test_Allocate_1d  -----
  subroutine Test_Allocate_1d ( Status, ModuleNameIn, ItsName, &
    & lBounds, uBounds, ElementSize, ERMSG, Address )
  ! Test the status from an allocate.  If it's nonzero, issue a message.
  ! Track allocations if TrackAllocates is >= 2 and ElementSize is present
  ! and > 0.
  ! This is just a handy wrapper so that you don't need to put brackets
  ! around the bounds of a 1-d array just to make the bounds arrays.
    integer, intent(in) :: Status
    character(len=*), intent(in) :: ModuleNameIn, ItsName
    integer, intent(in), optional :: Lbounds
    integer, intent(in)           :: Ubounds
    integer, intent(in), optional :: ElementSize ! Bytes, <= 0 for no tracking
    character(*), intent(in), optional :: ERMSG  ! from Allocate statement
    integer(c_intptr_t), intent(in), optional :: Address ! of allocated object
                                                         ! if status == 0
    integer :: MyLBounds(1)
    integer :: MyUBounds(1)
    myLBounds = 1
    if ( present(lBounds) ) myLBounds = lBounds
    myUBounds = uBounds
    call test_allocate ( status, moduleNameIn, itsName, &
    & myLBounds, myUBounds, elementSize, ERMSG, address )
  end subroutine Test_Allocate_1d

  ! --------------------------------------------  Test_DeAllocate_int_s  -----
  subroutine Test_DeAllocate_int_s ( Status, ModuleNameIn, ItsName, Size, &
    & ERMSG, Address )
  ! Test the status from a deallocate.  If it's nonzero, issue a message.
  ! Do garbage collection if Collect_garbage_each_time is true.
  ! Track deallocations if TrackAllocates >= 2 and Size is present and > 0.
    use HIGHOUTPUT, only: outputNamedValue
    integer, intent(in) :: Status
    character(len=*), intent(in) :: ModuleNameIn, ItsName
    integer, intent(in), optional :: Size ! in Bytes
    character(*), intent(in), optional :: ERMSG ! From ERRMSG= specifier
    integer(c_intptr_t), intent(in), optional :: Address ! of allocated object
                                                         ! before deallocation

    integer :: L
    character(255) :: Line

    if ( status /= 0 ) then
      write ( line, '(", status = ", i0)' ) status
      if ( present(ermsg) ) then
        l = len_trim(line)
        line(l+2:) = ermsg
      end if
      call myMessage ( MLSMSG_Warning, moduleNameIn, &
        & MLSMSG_DeAllocate // itsName // trim(line) )
      dealloc_status = max(dealloc_status, status)
    else if ( collect_garbage_each_time ) then
      call mls_gc_now
    end if
    if ( AllocateLogUnit > 0 ) &
      & call LogDeallocate( ModuleNameIn, ItsName, Size, Address )
    if ( status == 0 .and. present(size) ) then
      if ( size > 0.0 ) then
        if ( trackAllocates >= 2 ) then
          call ReportAllocateDeallocate ( itsName, moduleNameIn, -size )
        else
          TotalDeAllocated = TotalDeAllocated - size
          NoBlocksDeAllocated = NoBlocksDeAllocated + 1
          noBytesAllocated = noBytesAllocated - size
          if ( DEEBUG ) &
            & call outputNamedValue( itsname, &
            & (/noBytesAllocated, size*1.d0/)/OUTPUT_UNITS )
        end if
      end if
    end if

  end subroutine Test_Deallocate_int_s

  ! =====     Private Procedures     ===================================
  ! ---------------------------------  Allocate_Test_Character_1d  -----
  subroutine Allocate_Test_Character_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    character(len=*), pointer, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    character(len=*), intent(in), optional :: Fill
    character(len=1), parameter :: Default = ''
    include "Allocate_Test_1D.f9h"
  end subroutine Allocate_Test_Character_1d
  ! ---------------------------------  Allocate_Test_Character_2d  -----
  subroutine Allocate_Test_Character_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    character(len=*), pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! default 1
    character(len=*), intent(in), optional :: Fill ! To fill allocated array
    character(len=1), parameter :: Default = ''
    include "Allocate_Test_2D.f9h"
  end subroutine Allocate_Test_Character_2d
  ! -------------------------------  Allocate_Test_Character_2d_a  -----
  subroutine Allocate_Test_Character_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    character(len=*), pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)    ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! default 1
    character(len=*), intent(in), optional :: Fill ! To fill allocated array
    character(len=1), parameter :: Default = ''
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_Character_2d_a
  ! ---------------------------------  Allocate_Test_Character_3d  -----
  subroutine Allocate_Test_Character_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    character(len=*), pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! Low bounds for dimensions
    character(len=*), intent(in), optional :: Fill ! To fill allocated array
    character(len=1), parameter :: Default = ''
    include "Allocate_Test_3D.f9h"
  end subroutine Allocate_Test_Character_3d
  ! -------------------------------  Allocate_Test_Character_3d_a  -----
  subroutine Allocate_Test_Character_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    character(len=*), pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)    ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! default 1
    character(len=*), intent(in), optional :: Fill ! To fill allocated array
    character(len=1), parameter :: Default = ''
    include "Allocate_Test_3D_a.f9h"
  end subroutine Allocate_Test_Character_3d_a
  ! -----------------------------------  Allocate_Test_Complex_1d  -----
  subroutine Allocate_Test_Complex_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    complex, pointer, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    complex, intent(in), optional :: Fill
    complex, parameter :: Default = (0.0,0.0)
    include "Allocate_Test_1D.f9h"
  end subroutine Allocate_Test_Complex_1d
  ! -----------------------------------  Allocate_Test_Complex_2d  -----
  subroutine Allocate_Test_Complex_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    complex, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! default 1
    complex, intent(in), optional :: Fill ! To fill allocated array
    complex, parameter :: Default = (0.0,0.0)
    include "Allocate_Test_2D.f9h"
  end subroutine Allocate_Test_Complex_2d
  ! ---------------------------------  Allocate_Test_Complex_2d_a  -----
  subroutine Allocate_Test_Complex_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    complex, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! default 1
    complex, intent(in), optional :: Fill ! To fill allocated array
    complex, parameter :: Default = (0.0,0.0)
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_Complex_2d_a
  ! -----------------------------------  Allocate_Test_Complex_3d  -----
  subroutine Allocate_Test_Complex_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    complex, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! Low bounds for dimensions
    complex, intent(in), optional :: Fill ! To fill allocated array
    complex, parameter :: Default = (0.0,0.0)
    include "Allocate_Test_3D.f9h"
  end subroutine Allocate_Test_Complex_3d
  ! ---------------------------------  Allocate_Test_Complex_3d_a  -----
  subroutine Allocate_Test_Complex_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    complex, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! default 1
    complex, intent(in), optional :: Fill ! To fill allocated array
    complex, parameter :: Default = (0.0,0.0)
    include "Allocate_Test_3D_a.f9h"
  end subroutine Allocate_Test_Complex_3d_a
  ! ----------------------------------  Allocate_Test_DComplex_1d  -----
  subroutine Allocate_Test_DComplex_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    complex(kind(0.0d0)), pointer, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    complex(kind(0.0d0)), intent(in), optional :: Fill
    complex(kind(0.0d0)), parameter :: Default = (0.0d0,0.0d0)
    include "Allocate_Test_1D.f9h"
  end subroutine Allocate_Test_DComplex_1d
  ! ----------------------------------  Allocate_Test_DComplex_2d  -----
  subroutine Allocate_Test_DComplex_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    complex(kind(0.0d0)), pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! default 1
    complex(kind(0.0d0)), intent(in), optional :: Fill ! To fill allocated array
    complex(kind(0.0d0)), parameter :: Default = (0.0d0,0.0d0)
    include "Allocate_Test_2D.f9h"
  end subroutine Allocate_Test_DComplex_2d
  ! --------------------------------  Allocate_Test_DComplex_2d_a  -----
  subroutine Allocate_Test_DComplex_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    complex(kind(0.0d0)), pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! default 1
    complex(kind(0.0d0)), intent(in), optional :: Fill ! To fill allocated array
    complex(kind(0.0d0)), parameter :: Default = (0.0d0,0.0d0)
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_DComplex_2d_a
  ! ----------------------------------  Allocate_Test_DComplex_3d  -----
  subroutine Allocate_Test_DComplex_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    Complex(kind(0.0d0)), pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! Low bounds for dimensions
    Complex(kind(0.0d0)), intent(in), optional :: Fill ! To fill allocated array
    Complex(kind(0.0d0)), parameter :: Default = (0.0d0,0.0d0)
    include "Allocate_Test_3D.f9h"
  end subroutine Allocate_Test_DComplex_3d
  ! --------------------------------  Allocate_Test_DComplex_3d_a  -----
  subroutine Allocate_Test_DComplex_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    complex(kind(0.0d0)), pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! default 1
    complex(kind(0.0d0)), intent(in), optional :: Fill ! To fill allocated array
    complex(kind(0.0d0)), parameter :: Default = (0.0d0,0.0d0)
    include "Allocate_Test_3D_a.f9h"
  end subroutine Allocate_Test_DComplex_3d_a
  ! ------------------------------------  Allocate_Test_RealR8_1d  -----
  subroutine Allocate_Test_RealR8_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    double precision, pointer, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "Allocate_Test_1D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR8_1d
  ! ------------------------------------  Allocate_Test_RealR8_2d  -----
  subroutine Allocate_Test_RealR8_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    double precision, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "Allocate_Test_2D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR8_2d
  ! ----------------------------------  Allocate_Test_RealR8_2d_a  -----
  subroutine Allocate_Test_RealR8_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    double precision, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "Allocate_Test_2D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR8_2d_a
  ! ------------------------------------  Allocate_Test_RealR8_3d  -----
  subroutine Allocate_Test_RealR8_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    double precision, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "Allocate_Test_3D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR8_3d
  ! ----------------------------------  Allocate_Test_RealR8_3d_a  -----
  subroutine Allocate_Test_RealR8_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    double precision, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "Allocate_Test_3D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR8_3d_a
  ! ------------------------------------  Allocate_Test_RealR8_4d  -----
  subroutine Allocate_Test_RealR8_4d ( To_Allocate, Dim1, Dim2, Dim3, Dim4, &
    & ItsName, ModuleName, Low1, Low2, Low3, Low4, Fill )
    double precision, pointer, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    integer, intent(in) :: Dim4    ! Upper bound of fourth dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3, Low4 ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "Allocate_Test_4D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR8_4d
  ! ----------------------------------  Allocate_Test_RealR8_4d_a  -----
  subroutine Allocate_Test_RealR8_4d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    double precision, pointer, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(4)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(4) ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "Allocate_Test_4D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR8_4d_a
  ! -----------------------------------  Allocate_Test_Integer_1d  -----
  subroutine Allocate_Test_Integer_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    integer, pointer, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    integer, intent(in), optional :: Fill ! To fill allocated array
    integer, parameter :: Default = 0
    include "Allocate_Test_1D.f9h"
  end subroutine Allocate_Test_Integer_1d
  ! -----------------------------------  Allocate_Test_Integer_2d  -----
  subroutine Allocate_Test_Integer_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    integer, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! default 1
    integer, intent(in), optional :: Fill ! To fill allocated array
    integer, parameter :: Default = 0
    include "Allocate_Test_2D.f9h"
  end subroutine Allocate_Test_Integer_2d
  ! ---------------------------------  Allocate_Test_Integer_2d_a  -----
  subroutine Allocate_Test_Integer_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    integer, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! default 1
    integer, intent(in), optional :: Fill ! To fill allocated array
    integer, parameter :: Default = 0
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_Integer_2d_a
  ! -----------------------------------  Allocate_Test_Integer_3d  -----
  subroutine Allocate_Test_Integer_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    integer, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! default 1
    integer, intent(in), optional :: Fill ! To fill allocated array
    integer, parameter :: Default = 0
    include "Allocate_Test_3D.f9h"
  end subroutine Allocate_Test_Integer_3d
  ! ---------------------------------  Allocate_Test_Integer_3d_a  -----
  subroutine Allocate_Test_Integer_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    integer, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! default 1
    integer, intent(in), optional :: Fill ! To fill allocated array
    integer, parameter :: Default = 0
    include "Allocate_Test_3D_a.f9h"
  end subroutine Allocate_Test_Integer_3d_a
  ! -----------------------------------  Allocate_Test_Integer_4d  -----
  subroutine Allocate_Test_Integer_4d ( To_Allocate, Dim1, Dim2, Dim3, Dim4, &
    & ItsName, ModuleName, Low1, Low2, Low3, Low4, Fill )
    integer, pointer, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    integer, intent(in) :: Dim4    ! Upper bound of fourth dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3, Low4 ! default 1
    integer, intent(in), optional :: Fill ! To fill allocated array
    integer, parameter :: Default = 0
    include "Allocate_Test_4D.f9h"
  end subroutine Allocate_Test_Integer_4d
  ! ---------------------------------  Allocate_Test_Integer_4d_a  -----
  subroutine Allocate_Test_Integer_4d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    integer, pointer, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(4)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(4) ! default 1
    integer, intent(in), optional :: Fill ! To fill allocated array
    integer, parameter :: Default = 0
    include "Allocate_Test_4D_a.f9h"
  end subroutine Allocate_Test_Integer_4d_a
  ! -----------------------------------  Allocate_Test_Logical_1d  -----
  subroutine Allocate_Test_Logical_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    logical, pointer, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    logical, intent(in), optional :: Fill ! To fill allocated array
    logical, parameter :: Default = .false.
    include "Allocate_Test_1D.f9h"
  end subroutine Allocate_Test_Logical_1d
  ! -------------------------------------  Allocate_Test_Logical_2d  -----
  subroutine Allocate_Test_Logical_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    logical, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! Low bounds for dimensions
    logical, intent(in), optional :: Fill
    logical, parameter :: Default = .false.
    include "Allocate_Test_2D.f9h"
  end subroutine Allocate_Test_Logical_2d
  ! ---------------------------------  Allocate_Test_Logical_2d_a  -----
  subroutine Allocate_Test_Logical_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    logical, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! Lower bounds, default 1
    logical, intent(in), optional :: Fill ! To fill allocated array
    logical, parameter :: Default = .false.
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_Logical_2d_a
  ! -------------------------------------  Allocate_Test_Logical_3d  -----
  subroutine Allocate_Test_Logical_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    logical, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! Low bounds for dimensions
    logical, intent(in), optional :: Fill
    logical, parameter :: Default = .false.
    include "Allocate_Test_3D.f9h"
  end subroutine Allocate_Test_Logical_3d
  ! ---------------------------------  Allocate_Test_Logical_3d_a  -----
  subroutine Allocate_Test_Logical_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    logical, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! Lower bounds, default 1
    logical, intent(in), optional :: Fill ! To fill allocated array
    logical, parameter :: Default = .false.
    include "Allocate_Test_3D_a.f9h"
  end subroutine Allocate_Test_Logical_3d_a
  ! --------------------------------------  Allocate_Test_RealR4_1d  -----
  subroutine Allocate_Test_RealR4_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    real, pointer, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "Allocate_Test_1D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR4_1d
  ! --------------------------------------  Allocate_Test_RealR4_2d  -----
  subroutine Allocate_Test_RealR4_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    real, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! Low bounds for dimensions
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "Allocate_Test_2D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR4_2d
  ! ------------------------------------  Allocate_Test_RealR4_2d_a  -----
  subroutine Allocate_Test_RealR4_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    real, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! Low bounds, default 1
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "Allocate_Test_2D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR4_2d_a
  ! ------------------------------------  Allocate_Test_RealR4_3d  -----
  subroutine Allocate_Test_RealR4_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    real, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! Low bounds for dimensions
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "Allocate_Test_3D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR4_3d
  ! ------------------------------------  Allocate_Test_RealR4_3d_a  -----
  subroutine Allocate_Test_RealR4_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    real, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! Low bounds, default 1
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "Allocate_Test_3D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR4_3d_a
  ! ------------------------------------  Allocate_Test_RealR4_4d  -----
  subroutine Allocate_Test_RealR4_4d ( To_Allocate, Dim1, Dim2, Dim3, Dim4, &
    & ItsName, ModuleName, Low1, Low2, Low3, Low4, Fill )
    real, pointer, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    integer, intent(in) :: Dim4    ! Upper bound of fourth dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3, Low4 ! Low bounds for dimensions
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "Allocate_Test_4D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR4_4d
  ! ------------------------------------  Allocate_Test_RealR4_4d_a  -----
  subroutine Allocate_Test_RealR4_4d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    real, pointer, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(4)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(4) ! Low bounds, default 1
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "Allocate_Test_4D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine Allocate_Test_RealR4_4d_a

  ! For allocatable instead of pointer To_Allocate
  ! ---------------------------------  Allocate_Test_Character_1d  -----
  subroutine AllocateA_Test_Character_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    character(len=*), allocatable, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    character(len=*), intent(in), optional :: Fill
    character(len=1), parameter :: Default = ''
    include "AllocateA_Test_1D.f9h"
  end subroutine AllocateA_Test_Character_1d
  ! ---------------------------------  Allocate_Test_Character_2d  -----
  subroutine AllocateA_Test_Character_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    character(len=*), allocatable, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! default 1
    character(len=*), intent(in), optional :: Fill ! To fill allocated array
    character(len=1), parameter :: Default = ''
    include "AllocateA_Test_2D.f9h"
  end subroutine AllocateA_Test_Character_2d
  ! -----------------------------------  Allocate_Test_Integer_1d  -----
  subroutine AllocateA_Test_Integer_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    integer, allocatable, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    integer, intent(in), optional :: Fill
    integer, parameter :: Default = 0
    include "AllocateA_Test_1D.f9h"
  end subroutine AllocateA_Test_Integer_1d
  ! ----------------------------------  AllocateA_Test_Integer_2d  -----
  subroutine AllocateA_Test_Integer_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    integer, allocatable, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! Low bounds for dimensions
    integer, intent(in), optional :: Fill
    integer, parameter :: Default = 0
    include "AllocateA_Test_2D.f9h"
  end subroutine AllocateA_Test_Integer_2d
  ! --------------------------------  AllocateA_Test_Integer_2d_a  -----
  subroutine AllocateA_Test_Integer_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    integer, allocatable, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! Low bounds for dimensions
    integer, intent(in), optional :: Fill
    integer, parameter :: Default = 0
    include "AllocateA_Test_2D_a.f9h"
  end subroutine AllocateA_Test_Integer_2d_a
  ! ----------------------------------  AllocateA_Test_Integer_3d  -----
  subroutine AllocateA_Test_Integer_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    integer, allocatable, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! Low bounds for dimensions
    integer, intent(in), optional :: Fill
    integer, parameter :: Default = 0
    include "AllocateA_Test_3D.f9h"
  end subroutine AllocateA_Test_Integer_3d
  ! --------------------------------  AllocateA_Test_Integer_3d_a  -----
  subroutine AllocateA_Test_Integer_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    integer, allocatable, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! Low bounds for dimensions
    integer, intent(in), optional :: Fill
    integer, parameter :: Default = 0
    include "AllocateA_Test_3D_a.f9h"
  end subroutine AllocateA_Test_Integer_3d_a
  ! ----------------------------------  AllocateA_Test_Integer_4d  -----
  subroutine AllocateA_Test_Integer_4d ( To_Allocate, Dim1, Dim2, Dim3, Dim4, &
    & ItsName, ModuleName, Low1, Low2, Low3, Low4, Fill )
    integer, allocatable, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    integer, intent(in) :: Dim4    ! Upper bound of fourth dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3, Low4 ! Low bounds for dimensions
    integer, intent(in), optional :: Fill
    integer, parameter :: Default = 0
    include "AllocateA_Test_4D.f9h"
  end subroutine AllocateA_Test_Integer_4d
  ! --------------------------------  AllocateA_Test_Integer_4d_a  -----
  subroutine AllocateA_Test_Integer_4d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    integer, allocatable, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(4)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(4) ! Low bounds for dimensions
    integer, intent(in), optional :: Fill
    integer, parameter :: Default = 0
    include "AllocateA_Test_4D_a.f9h"
  end subroutine AllocateA_Test_Integer_4d_a
  ! -----------------------------------  Allocate_Test_Integer_1d  -----
  subroutine AllocateA_Test_Logical_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    logical, allocatable, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    logical, intent(in), optional :: Fill
    logical, parameter :: Default = .false.
    include "AllocateA_Test_1D.f9h"
  end subroutine AllocateA_Test_Logical_1d
  ! ----------------------------------  AllocateA_Test_Logical_2d  -----
  subroutine AllocateA_Test_Logical_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    logical, allocatable, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! Low bounds for dimensions
    logical, intent(in), optional :: Fill
    logical, parameter :: Default = .false.
    include "AllocateA_Test_2D.f9h"
  end subroutine AllocateA_Test_Logical_2d
  ! --------------------------------  AllocateA_Test_Logical_2d_a  -----
  subroutine AllocateA_Test_Logical_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    logical, allocatable, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! Low bounds for dimensions
    logical, intent(in), optional :: Fill
    logical, parameter :: Default = .false.
    include "AllocateA_Test_2D_a.f9h"
  end subroutine AllocateA_Test_Logical_2d_a
  ! ----------------------------------  AllocateA_Test_Logical_3d  -----
  subroutine AllocateA_Test_Logical_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    logical, allocatable, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! Low bounds for dimensions
    logical, intent(in), optional :: Fill
    logical, parameter :: Default = .false.
    include "AllocateA_Test_3D.f9h"
  end subroutine AllocateA_Test_Logical_3d
  ! --------------------------------  AllocateA_Test_Logical_3d_a  -----
  subroutine AllocateA_Test_Logical_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    logical, allocatable, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! Low bounds for dimensions
    logical, intent(in), optional :: Fill
    logical, parameter :: Default = .false.
    include "AllocateA_Test_3D_a.f9h"
  end subroutine AllocateA_Test_Logical_3d_a
  ! -----------------------------------  AllocateA_Test_RealR8_1d  -----
  subroutine AllocateA_Test_RealR8_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    double precision, allocatable, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "AllocateA_Test_1D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR8_1d
  ! -----------------------------------  AllocateA_Test_RealR8_2d  -----
  subroutine AllocateA_Test_RealR8_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    double precision, allocatable, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "AllocateA_Test_2D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR8_2d
  ! ----------------------------------  AllocateA_Test_RealR8_2d_a  -----
  subroutine AllocateA_Test_RealR8_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    double precision, allocatable, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "AllocateA_Test_2D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR8_2d_a
  ! ------------------------------------  AllocateA_Test_RealR8_3d  -----
  subroutine AllocateA_Test_RealR8_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    double precision, allocatable, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "AllocateA_Test_3D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR8_3d
  ! ----------------------------------  AllocateA_Test_RealR8_3d_a  -----
  subroutine AllocateA_Test_RealR8_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    double precision, allocatable, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "AllocateA_Test_3D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR8_3d_a
  ! ------------------------------------  AllocateA_Test_RealR8_4d  -----
  subroutine AllocateA_Test_RealR8_4d ( To_Allocate, Dim1, Dim2, Dim3, Dim4, &
    & ItsName, ModuleName, Low1, Low2, Low3, Low4, Fill )
    double precision, allocatable, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    integer, intent(in) :: Dim4    ! Upper bound of fourth dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3, Low4 ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "AllocateA_Test_4D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR8_4d
  ! ----------------------------------  AllocateA_Test_RealR8_4d_a  -----
  subroutine AllocateA_Test_RealR8_4d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    double precision, allocatable, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(4)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(4) ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    include "AllocateA_Test_4D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR8_4d_a
  ! -------------------------------------  AllocateA_Test_RealR4_1d  -----
  subroutine AllocateA_Test_RealR4_1d ( To_Allocate, Dim1, &
    & ItsName, ModuleName, LowBound, Fill )
    real, allocatable, dimension(:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: LowBound     ! Lower bound, default 1
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "AllocateA_Test_1D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR4_1d
  ! --------------------------------------  AllocateA_Test_RealR4_2d  -----
  subroutine AllocateA_Test_RealR4_2d ( To_Allocate, Dim1, Dim2, &
    & ItsName, ModuleName, Low1, Low2, Fill )
    real, allocatable, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2 ! Low bounds for dimensions
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "AllocateA_Test_2D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR4_2d
  ! ------------------------------------  AllocateA_Test_RealR4_2d_a  -----
  subroutine AllocateA_Test_RealR4_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    real, allocatable, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! Low bounds, default 1
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "AllocateA_Test_2D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR4_2d_a
  ! ------------------------------------  AllocateA_Test_RealR4_3d  -----
  subroutine AllocateA_Test_RealR4_3d ( To_Allocate, Dim1, Dim2, Dim3, &
    & ItsName, ModuleName, Low1, Low2, Low3, Fill )
    real, allocatable, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3 ! Low bounds for dimensions
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "AllocateA_Test_3D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR4_3d
  ! ------------------------------------  AllocateA_Test_RealR4_3d_a  -----
  subroutine AllocateA_Test_RealR4_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    real, allocatable, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! Low bounds, default 1
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "AllocateA_Test_3D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR4_3d_a
  ! ------------------------------------  AllocateA_Test_RealR4_4d  -----
  subroutine AllocateA_Test_RealR4_4d ( To_Allocate, Dim1, Dim2, Dim3, Dim4, &
    & ItsName, ModuleName, Low1, Low2, Low3, Low4, Fill )
    real, allocatable, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim1    ! Upper bound of first dim. of To_Allocate
    integer, intent(in) :: Dim2    ! Upper bound of second dim. of To_Allocate
    integer, intent(in) :: Dim3    ! Upper bound of third dim. of To_Allocate
    integer, intent(in) :: Dim4    ! Upper bound of fourth dim. of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low1, Low2, Low3, Low4 ! Low bounds for dimensions
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "AllocateA_Test_4D.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR4_4d
  ! ------------------------------------  AllocateA_Test_RealR4_4d_a  -----
  subroutine AllocateA_Test_RealR4_4d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    real, allocatable, dimension(:,:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(4)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(4) ! Low bounds, default 1
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    include "AllocateA_Test_4D_a.f9h"
    if ( InitRealNaN .and. IEEE_Support_DataType(to_allocate) .and. &
       & .not. present(fill) ) &
         & to_allocate = IEEE_Value ( to_allocate, IEEE_Signaling_NaN )
  end subroutine AllocateA_Test_RealR4_4d_a

  ! -------------------------------  Deallocate_Test_Character_1d  -----
  subroutine Deallocate_Test_Character_1d ( To_Deallocate, ItsName, ModuleName )
    character(len=*), pointer, dimension(:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Character_1d
  ! -------------------------------  Deallocate_Test_Character_2d  -----
  subroutine Deallocate_Test_Character_2d ( To_Deallocate, ItsName, ModuleName )
    character(len=*), pointer, dimension(:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Character_2d
  ! -------------------------------  Deallocate_Test_Character_3d  -----
  subroutine Deallocate_Test_Character_3d ( To_Deallocate, ItsName, ModuleName )
    character(len=*), pointer, dimension(:,:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Character_3d
  ! ---------------------------------  Deallocate_Test_Complex_1d  -----
  subroutine Deallocate_Test_Complex_1d ( To_Deallocate, ItsName, ModuleName )
    complex, pointer, dimension(:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Complex_1d
  ! ---------------------------------  Deallocate_Test_Complex_2d  -----
  subroutine Deallocate_Test_Complex_2d ( To_Deallocate, ItsName, ModuleName )
    complex, pointer, dimension(:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Complex_2d
  ! ---------------------------------  Deallocate_Test_Complex_3d  -----
  subroutine Deallocate_Test_Complex_3d ( To_Deallocate, ItsName, ModuleName )
    complex, pointer, dimension(:,:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Complex_3d
  ! --------------------------------  Deallocate_Test_Dcomplex_1d  -----
  subroutine Deallocate_Test_Dcomplex_1d ( To_Deallocate, ItsName, ModuleName )
    complex(kind(0.0d0)), pointer, dimension(:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Dcomplex_1d
  ! --------------------------------  Deallocate_Test_Dcomplex_2d  -----
  subroutine Deallocate_Test_Dcomplex_2d ( To_Deallocate, ItsName, ModuleName )
    complex(kind(0.0d0)), pointer, dimension(:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Dcomplex_2d
  ! --------------------------------  Deallocate_Test_Dcomplex_3d  -----
  subroutine Deallocate_Test_Dcomplex_3d ( To_Deallocate, ItsName, ModuleName )
    complex(kind(0.0d0)), pointer, dimension(:,:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Dcomplex_3d
  ! ----------------------------------  Deallocate_Test_RealR8_1d  -----
  subroutine Deallocate_Test_RealR8_1d ( To_Deallocate, ItsName, ModuleName )
    double precision, pointer, dimension(:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_RealR8_1d
  ! ----------------------------------  Deallocate_Test_RealR8_2d  -----
  subroutine Deallocate_Test_RealR8_2d ( To_Deallocate, ItsName, ModuleName )
    double precision, pointer, dimension(:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_RealR8_2d
  ! ----------------------------------  Deallocate_Test_RealR8_3d  -----
  subroutine Deallocate_Test_RealR8_3d ( To_Deallocate, ItsName, ModuleName )
    double precision, pointer, dimension(:,:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_RealR8_3d
  ! ----------------------------------  Deallocate_Test_RealR8_4d  -----
  subroutine Deallocate_Test_RealR8_4d ( To_Deallocate, ItsName, ModuleName )
    double precision, pointer, dimension(:,:,:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_RealR8_4d
  ! ---------------------------------  Deallocate_Test_Integer_1d  -----
  subroutine Deallocate_Test_Integer_1d ( To_Deallocate, ItsName, ModuleName )
    integer, pointer, dimension(:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Integer_1d
  ! ---------------------------------  Deallocate_Test_Integer_2d  -----
  subroutine Deallocate_Test_Integer_2d ( To_Deallocate, ItsName, ModuleName )
    integer, pointer, dimension(:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Integer_2d
  ! ---------------------------------  Deallocate_Test_Integer_3d  -----
  subroutine Deallocate_Test_Integer_3d ( To_Deallocate, ItsName, ModuleName )
    integer, pointer, dimension(:,:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Integer_3d
  ! ---------------------------------  Deallocate_Test_Integer_4d  -----
  subroutine Deallocate_Test_Integer_4d ( To_Deallocate, ItsName, ModuleName )
    integer, pointer, dimension(:,:,:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Integer_4d
  ! ---------------------------------  Deallocate_Test_Logical_1d  -----
  subroutine Deallocate_Test_Logical_1d ( To_Deallocate, ItsName, ModuleName )
    logical, pointer, dimension(:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Logical_1d
  ! ---------------------------------  Deallocate_Test_Logical_2d  -----
  subroutine Deallocate_Test_Logical_2d ( To_Deallocate, ItsName, ModuleName )
    logical, pointer, dimension(:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Logical_2d
  ! ---------------------------------  Deallocate_Test_Logical_3d  -----
  subroutine Deallocate_Test_Logical_3d ( To_Deallocate, ItsName, ModuleName )
    logical, pointer, dimension(:,:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_Logical_3d
  ! ------------------------------------  Deallocate_Test_RealR4_1d  -----
  subroutine Deallocate_Test_RealR4_1d ( To_Deallocate, ItsName, ModuleName )
    real, pointer, dimension(:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_RealR4_1d
  ! ------------------------------------  Deallocate_Test_RealR4_2d  -----
  subroutine Deallocate_Test_RealR4_2d ( To_Deallocate, ItsName, ModuleName )
    real, pointer, dimension(:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_RealR4_2d
  ! ----------------------------------  Deallocate_Test_RealR4_3d  -----
  subroutine Deallocate_Test_RealR4_3d ( To_Deallocate, ItsName, ModuleName )
    real, pointer, dimension(:,:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_RealR4_3d
  ! ----------------------------------  Deallocate_Test_RealR4_4d  -----
  subroutine Deallocate_Test_RealR4_4d ( To_Deallocate, ItsName, ModuleName )
    real, pointer, dimension(:,:,:,:) :: To_Deallocate
    include "Deallocate_Test.f9h"
  end subroutine Deallocate_Test_RealR4_4d

! For allocatable instead of pointer arguments

  ! -------------------------------  Deallocate_Test_Character_1d  -----
  subroutine DeallocateA_Test_Character_1d ( To_Deallocate, ItsName, ModuleName )
    character(len=*), allocatable, dimension(:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_Character_1d
  ! -------------------------------  Deallocate_Test_Character_2d  -----
  subroutine DeallocateA_Test_Character_2d ( To_Deallocate, ItsName, ModuleName )
    character(len=*), allocatable, dimension(:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_Character_2d
  ! --------------------------------  DeallocateA_Test_Integer_1d  -----
  subroutine DeallocateA_Test_Integer_1d ( To_Deallocate, ItsName, ModuleName )
    integer, allocatable, dimension(:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_Integer_1d
  ! --------------------------------  DeallocateA_Test_Integer_2d  -----
  subroutine DeallocateA_Test_Integer_2d ( To_Deallocate, ItsName, ModuleName )
    integer, allocatable, dimension(:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_Integer_2d
  ! --------------------------------  DeallocateA_Test_Integer_3d  -----
  subroutine DeallocateA_Test_Integer_3d ( To_Deallocate, ItsName, ModuleName )
    integer, allocatable, dimension(:,:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_Integer_3d
  ! --------------------------------  DeallocateA_Test_Integer_4d  -----
  subroutine DeallocateA_Test_Integer_4d ( To_Deallocate, ItsName, ModuleName )
    integer, allocatable, dimension(:,:,:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_Integer_4d
  ! --------------------------------  DeallocateA_Test_Logical_1d  -----
  subroutine DeallocateA_Test_Logical_1d ( To_Deallocate, ItsName, ModuleName )
    logical, allocatable, dimension(:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_Logical_1d
  ! --------------------------------  DeallocateA_Test_Logical_2d  -----
  subroutine DeallocateA_Test_Logical_2d ( To_Deallocate, ItsName, ModuleName )
    logical, allocatable, dimension(:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_Logical_2d
  ! --------------------------------  DeallocateA_Test_Logical_3d  -----
  subroutine DeallocateA_Test_Logical_3d ( To_Deallocate, ItsName, ModuleName )
    logical, allocatable, dimension(:,:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_Logical_3d
  ! ----------------------------------  DeallocateA_Test_RealR8_1d  -----
  subroutine DeallocateA_Test_RealR8_1d ( To_Deallocate, ItsName, ModuleName )
    double precision, allocatable, dimension(:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_RealR8_1d
  ! ----------------------------------  DeallocateA_Test_RealR8_2d  -----
  subroutine DeallocateA_Test_RealR8_2d ( To_Deallocate, ItsName, ModuleName )
    double precision, allocatable, dimension(:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_RealR8_2d
  ! ----------------------------------  DeallocateA_Test_RealR8_3d  -----
  subroutine DeallocateA_Test_RealR8_3d ( To_Deallocate, ItsName, ModuleName )
    double precision, allocatable, dimension(:,:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_RealR8_3d
  ! ----------------------------------  DeallocateA_Test_RealR8_4d  -----
  subroutine DeallocateA_Test_RealR8_4d ( To_Deallocate, ItsName, ModuleName )
    double precision, allocatable, dimension(:,:,:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_RealR8_4d
  ! ------------------------------------  DeallocateA_Test_RealR4_1d  -----
  subroutine DeallocateA_Test_RealR4_1d ( To_Deallocate, ItsName, ModuleName )
    real, allocatable, dimension(:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_RealR4_1d
  ! ------------------------------------  DeallocateA_Test_RealR4_2d  -----
  subroutine DeallocateA_Test_RealR4_2d ( To_Deallocate, ItsName, ModuleName )
    real, allocatable, dimension(:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_RealR4_2d
  ! ----------------------------------  DeallocateA_Test_RealR4_3d  -----
  subroutine DeallocateA_Test_RealR4_3d ( To_Deallocate, ItsName, ModuleName )
    real, allocatable, dimension(:,:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_RealR4_3d
  ! ----------------------------------  DeallocateA_Test_RealR4_4d  -----
  subroutine DeallocateA_Test_RealR4_4d ( To_Deallocate, ItsName, ModuleName )
    real, allocatable, dimension(:,:,:,:) :: To_Deallocate
    include "DeallocateA_Test.f9h"
  end subroutine DeallocateA_Test_RealR4_4d

  ! --------------------------------------------  Bytes functions  -----
  integer function Byte_Size_Character_1D ( A ) result ( Byte_Size )
    character(len=*), intent(in) :: A(:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Character_1D
  integer function Byte_Size_Character_2D ( A ) result ( Byte_Size )
    character(len=*), intent(in) :: A(:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Character_2D
  integer function Byte_Size_Character_3D ( A ) result ( Byte_Size )
    character(*), intent(in) :: A(:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Character_3D
  integer function Byte_Size_Complex_1D ( A ) result ( Byte_Size )
    complex, intent(in) :: A(:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Complex_1D
  integer function Byte_Size_Complex_2D ( A ) result ( Byte_Size )
    complex, intent(in) :: A(:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Complex_2D
  integer function Byte_Size_Complex_3D ( A ) result ( Byte_Size )
    complex, intent(in) :: A(:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Complex_3D
  integer function Byte_Size_DComplex_1D ( A ) result ( Byte_Size )
    complex(kind(0.0d0)), intent(in) :: A(:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_DComplex_1D
  integer function Byte_Size_DComplex_2D ( A ) result ( Byte_Size )
    complex(kind(0.0d0)), intent(in) :: A(:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_DComplex_2D
  integer function Byte_Size_DComplex_3D ( A ) result ( Byte_Size )
    complex(kind(0.0d0)), intent(in) :: A(:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_DComplex_3D
  integer function Byte_Size_Integer_1D ( A ) result ( Byte_Size )
    integer, intent(in) :: A(:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Integer_1D
  integer function Byte_Size_Integer_2D ( A ) result ( Byte_Size )
    integer, intent(in) :: A(:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Integer_2D
  integer function Byte_Size_Integer_3D ( A ) result ( Byte_Size )
    integer, intent(in) :: A(:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Integer_3D
  integer function Byte_Size_Integer_4D ( A ) result ( Byte_Size )
    integer, intent(in) :: A(:,:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Integer_4D
  integer function Byte_Size_Logical_1D ( A ) result ( Byte_Size )
    logical, intent(in) :: A(:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Logical_1D
  integer function Byte_Size_Logical_2D ( A ) result ( Byte_Size )
    logical, intent(in) :: A(:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Logical_2D
  integer function Byte_Size_Logical_3D ( A ) result ( Byte_Size )
    logical, intent(in) :: A(:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_Logical_3D
  integer function Byte_Size_RealR4_1D ( A ) result ( Byte_Size )
    real, intent(in) :: A(:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR4_1D
  integer function Byte_Size_RealR4_2D ( A ) result ( Byte_Size )
    real, intent(in) :: A(:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR4_2D
  integer function Byte_Size_RealR4_3D ( A ) result ( Byte_Size )
    real, intent(in) :: A(:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR4_3D
  integer function Byte_Size_RealR4_4D ( A ) result ( Byte_Size )
    real, intent(in) :: A(:,:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR4_4D
  integer function Byte_Size_RealR4_5D ( A ) result ( Byte_Size )
    real, intent(in) :: A(:,:,:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR4_5D
  integer function Byte_Size_RealR4_6D ( A ) result ( Byte_Size )
    real, intent(in) :: A(:,:,:,:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR4_6D
  integer function Byte_Size_RealR8_1D ( A ) result ( Byte_Size )
    double precision, intent(in) :: A(:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR8_1D
  integer function Byte_Size_RealR8_2D ( A ) result ( Byte_Size )
    double precision, intent(in) :: A(:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR8_2D
  integer function Byte_Size_RealR8_3D ( A ) result ( Byte_Size )
    double precision, intent(in) :: A(:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR8_3D
  integer function Byte_Size_RealR8_4D ( A ) result ( Byte_Size )
    double precision, intent(in) :: A(:,:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR8_4D
  integer function Byte_Size_RealR8_5D ( A ) result ( Byte_Size )
    double precision, intent(in) :: A(:,:,:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR8_5D
  integer function Byte_Size_RealR8_6D ( A ) result ( Byte_Size )
    double precision, intent(in) :: A(:,:,:,:,:,:)
    byte_size = bytes(a) * size(a)
  end function Byte_Size_RealR8_6D

  !??? We'd prefer to use storage_size(a) but Intel 13.0.1 complains ???
  integer function Bytes_Character_1D ( A ) result ( BYTES )
    character(len=*), intent(in) :: A(:)
    character, parameter :: B = '' ! Intel 13.0.1 doesn't like storage_size(a)
    ! When Intel is happy with storage_size(a), DO NOT multiply by len(a)!
    ! Storage_Size includes character length.
    bytes = ( ( storage_size(b) + 7 ) / 8 ) * len(a)
!     bytes = ( ( storage_size(a) + 7 ) / 8 )
  end function Bytes_Character_1D
  integer function Bytes_Character_2D ( A ) result ( BYTES )
    character(len=*), intent(in) :: A(:,:)
    character, parameter :: B = '' ! Intel 13.0.1 doesn't like storage_size(a)
    ! When Intel is happy with storage_size(a), DO NOT multiply by len(a)!
    ! Storage_Size includes character length.
    bytes = ( ( storage_size(b) + 7 ) / 8 ) * len(a)
!     bytes = ( ( storage_size(a) + 7 ) / 8 )
  end function Bytes_Character_2D
  integer function Bytes_Character_3D ( A ) result ( BYTES )
    character(len=*), intent(in) :: A(:,:,:)
    character, parameter :: B = '' ! Intel 13.0.1 doesn't like storage_size(a)
    ! When Intel is happy with storage_size(a), DO NOT multiply by len(a)!
    ! Storage_Size includes character length.
    bytes = ( ( storage_size(b) + 7 ) / 8 ) * len(a)
!     bytes = ( ( storage_size(a) + 7 ) / 8 )
  end function Bytes_Character_3D
  integer function Bytes_Complex_1D ( A ) result ( BYTES )
    complex, intent(in) :: A(:)
    complex, parameter :: B = (0.0,0.0) ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_Complex_1D
  integer function Bytes_Complex_2D ( A ) result ( BYTES )
    complex, intent(in) :: A(:,:)
    complex, parameter :: B = (0.0,0.0) ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_Complex_2D
  integer function Bytes_Complex_3D ( A ) result ( BYTES )
    complex, intent(in) :: A(:,:,:)
    complex, parameter :: B = (0.0,0.0) ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_Complex_3D
  integer function Bytes_DComplex_1D ( A ) result ( BYTES )
    complex(kind(0.0d0)), intent(in) :: A(:)
    complex(kind(0.0d0)), parameter :: B = (0.0d0,0.0d0) ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_DComplex_1D
  integer function Bytes_DComplex_2D ( A ) result ( BYTES )
    complex(kind(0.0d0)), intent(in) :: A(:,:)
    complex(kind(0.0d0)), parameter :: B = (0.0d0,0.0d0) ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_DComplex_2D
  integer function Bytes_DComplex_3D ( A ) result ( BYTES )
    complex(kind(0.0d0)), intent(in) :: A(:,:,:)
    complex(kind(0.0d0)), parameter :: B = (0.0d0,0.0d0) ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_DComplex_3D
  integer function Bytes_Integer_1D ( A ) result ( BYTES )
    integer, intent(in) :: A(:)
    integer, parameter :: B = 0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_Integer_1D
  integer function Bytes_Integer_2D ( A ) result ( BYTES )
    integer, intent(in) :: A(:,:)
    integer, parameter :: B = 0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_Integer_2D
  integer function Bytes_Integer_3D ( A ) result ( BYTES )
    integer, intent(in) :: A(:,:,:)
    integer, parameter :: B = 0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_Integer_3D
  integer function Bytes_Integer_4D ( A ) result ( BYTES )
    integer, intent(in) :: A(:,:,:,:)
    integer, parameter :: B = 0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_Integer_4D
  integer function Bytes_Logical_1D ( A ) result ( BYTES )
    logical, intent(in) :: A(:)
    logical, parameter :: B = .false. ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_Logical_1D
  integer function Bytes_Logical_2D ( A ) result ( BYTES )
    logical, intent(in) :: A(:,:)
    logical, parameter :: B = .false. ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_Logical_2D
  integer function Bytes_Logical_3D ( A ) result ( BYTES )
    logical, intent(in) :: A(:,:,:)
    logical, parameter :: B = .false. ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_Logical_3D
  integer function Bytes_RealR4_1D ( A ) result ( BYTES )
    real, intent(in) :: A(:)
    real, parameter :: B = 0.0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR4_1D
  integer function Bytes_RealR4_2D ( A ) result ( BYTES )
    real, intent(in) :: A(:,:)
    real, parameter :: B = 0.0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR4_2D
  integer function Bytes_RealR4_3D ( A ) result ( BYTES )
    real, intent(in) :: A(:,:,:)
    real, parameter :: B = 0.0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR4_3D
  integer function Bytes_RealR4_4D ( A ) result ( BYTES )
    real, intent(in) :: A(:,:,:,:)
    real, parameter :: B = 0.0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR4_4D
  integer function Bytes_RealR4_5D ( A ) result ( BYTES )
    real, intent(in) :: A(:,:,:,:,:)
    real, parameter :: B = 0.0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR4_5D
  integer function Bytes_RealR4_6D ( A ) result ( BYTES )
    real, intent(in) :: A(:,:,:,:,:,:)
    real, parameter :: B = 0.0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR4_6D
  integer function Bytes_RealR8_1D ( A ) result ( BYTES )
    double precision, intent(in) :: A(:)
    double precision, parameter :: B = 0.0d0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR8_1D
  integer function Bytes_RealR8_2D ( A ) result ( BYTES )
    double precision, intent(in) :: A(:,:)
    double precision, parameter :: B = 0.0d0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR8_2D
  integer function Bytes_RealR8_3D ( A ) result ( BYTES )
    double precision, intent(in) :: A(:,:,:)
    double precision, parameter :: B = 0.0d0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR8_3D
  integer function Bytes_RealR8_4D ( A ) result ( BYTES )
    double precision, intent(in) :: A(:,:,:,:)
    double precision, parameter :: B = 0.0d0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR8_4D
  integer function Bytes_RealR8_5D ( A ) result ( BYTES )
    double precision, intent(in) :: A(:,:,:,:,:)
    double precision, parameter :: B = 0.0d0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR8_5D
  integer function Bytes_RealR8_6D ( A ) result ( BYTES )
    double precision, intent(in) :: A(:,:,:,:,:,:)
    double precision, parameter :: B = 0.0d0 ! Intel 13.0.1 doesn't like storage_size(a)
    bytes = ( ( storage_size(b) + 7 ) / 8 )
  end function Bytes_RealR8_6D

  ! --------------------------------------------------  myMessage  -----
  subroutine myMessage ( severity, name, line )
    use MLSMessageModule, only: MLSMessage
    ! Args
    integer, intent(in)           :: severity
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: line
    call MLSMessage ( severity, ModuleName // '%' &
      & // trim(name), trim(line) )
  end subroutine myMessage

  subroutine myMessage_old ( severity, name, line )
    ! Args
    integer, intent(in)           :: severity
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: line

    ! Local variables
    integer :: nChars
    character(len=len(line) + len(name) + 3) :: thus
    ! Executable
    nChars = len(line)
    thus = line
    if ( len_trim(name) > 0 ) then
      nChars = len(line) + len_trim(snipRCSfrom(name)) + 3
      thus = '(' // trim(snipRCSfrom(name)) // ') ' // line
    end if
    if ( severity > MLSMSG_Warning ) then
      call PrintItOut( thus(1:nChars), SEVERITY, exitStatus = 1  )
    else
      call PrintItOut( thus(1:nChars), SEVERITY  )
    end if
  end subroutine myMessage_old

  ! ------------------------------------  Same_Shape_Character_1d  -----
  subroutine Same_Shape_Character_1d ( Ref, New, ItsName, ModuleName )
    character(len=*), pointer, dimension(:) :: Ref, New
    include "Same_Shape_1d.f9h"
  end subroutine Same_Shape_Character_1d
  ! ------------------------------------  Same_Shape_Character_2d  -----
  subroutine Same_Shape_Character_2d ( Ref, New, ItsName, ModuleName )
    character(len=*), pointer, dimension(:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Character_2d
  ! ------------------------------------  Same_Shape_Character_3d  -----
  subroutine Same_Shape_Character_3d ( Ref, New, ItsName, ModuleName )
    character(len=*), pointer, dimension(:,:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Character_3d
  ! --------------------------------------  Same_Shape_Complex_1d  -----
  subroutine Same_Shape_Complex_1d ( Ref, New, ItsName, ModuleName )
    complex, pointer, dimension(:) :: Ref, New
    include "Same_Shape_1d.f9h"
  end subroutine Same_Shape_Complex_1d
  ! --------------------------------------  Same_Shape_Complex_2d  -----
  subroutine Same_Shape_Complex_2d ( Ref, New, ItsName, ModuleName )
    complex, pointer, dimension(:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Complex_2d
  ! --------------------------------------  Same_Shape_Complex_3d  -----
  subroutine Same_Shape_Complex_3d ( Ref, New, ItsName, ModuleName )
    complex, pointer, dimension(:,:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Complex_3d
  ! -------------------------------------  Same_Shape_Dcomplex_1d  -----
  subroutine Same_Shape_Dcomplex_1d ( Ref, New, ItsName, ModuleName )
    complex(kind(0.0d0)), pointer, dimension(:) :: Ref, New
    include "Same_Shape_1d.f9h"
  end subroutine Same_Shape_Dcomplex_1d
  ! -------------------------------------  Same_Shape_Dcomplex_2d  -----
  subroutine Same_Shape_Dcomplex_2d ( Ref, New, ItsName, ModuleName )
    complex(kind(0.0d0)), pointer, dimension(:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Dcomplex_2d
  ! -------------------------------------  Same_Shape_Dcomplex_3d  -----
  subroutine Same_Shape_Dcomplex_3d ( Ref, New, ItsName, ModuleName )
    complex(kind(0.0d0)), pointer, dimension(:,:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Dcomplex_3d
  ! ---------------------------------------  Same_Shape_RealR8_1d  -----
  subroutine Same_Shape_RealR8_1d ( Ref, New, ItsName, ModuleName )
    double precision, pointer, dimension(:) :: Ref, New
    include "Same_Shape_1d.f9h"
  end subroutine Same_Shape_RealR8_1d
  ! ---------------------------------------  Same_Shape_RealR8_2d  -----
  subroutine Same_Shape_RealR8_2d ( Ref, New, ItsName, ModuleName )
    double precision, pointer, dimension(:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_RealR8_2d
  ! ---------------------------------------  Same_Shape_RealR8_3d  -----
  subroutine Same_Shape_RealR8_3d ( Ref, New, ItsName, ModuleName )
    double precision, pointer, dimension(:,:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_RealR8_3d
  ! ---------------------------------------  Same_Shape_RealR8_4d  -----
  subroutine Same_Shape_RealR8_4d ( Ref, New, ItsName, ModuleName )
    double precision, pointer, dimension(:,:,:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_RealR8_4d
  ! --------------------------------------  Same_Shape_Integer_1d  -----
  subroutine Same_Shape_Integer_1d ( Ref, New, ItsName, ModuleName )
    integer, pointer, dimension(:) :: Ref, New
    include "Same_Shape_1d.f9h"
  end subroutine Same_Shape_Integer_1d
  ! --------------------------------------  Same_Shape_Integer_2d  -----
  subroutine Same_Shape_Integer_2d ( Ref, New, ItsName, ModuleName )
    integer, pointer, dimension(:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Integer_2d
  ! --------------------------------------  Same_Shape_Integer_3d  -----
  subroutine Same_Shape_Integer_3d ( Ref, New, ItsName, ModuleName )
    integer, pointer, dimension(:,:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Integer_3d
  ! --------------------------------------  Same_Shape_Integer_4d  -----
  subroutine Same_Shape_Integer_4d ( Ref, New, ItsName, ModuleName )
    integer, pointer, dimension(:,:,:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Integer_4d
  ! --------------------------------------  Same_Shape_Logical_1d  -----
  subroutine Same_Shape_Logical_1d ( Ref, New, ItsName, ModuleName )
    logical, pointer, dimension(:) :: Ref, New
    include "Same_Shape_1d.f9h"
  end subroutine Same_Shape_Logical_1d
  ! --------------------------------------  Same_Shape_Logical_2d  -----
  subroutine Same_Shape_Logical_2d ( Ref, New, ItsName, ModuleName )
    logical, pointer, dimension(:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Logical_2d
  ! --------------------------------------  Same_Shape_Logical_3d  -----
  subroutine Same_Shape_Logical_3d ( Ref, New, ItsName, ModuleName )
    logical, pointer, dimension(:,:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_Logical_3d
  ! -----------------------------------------  Same_Shape_RealR4_1d  -----
  subroutine Same_Shape_RealR4_1d ( Ref, New, ItsName, ModuleName )
    real, pointer, dimension(:) :: Ref, New
    include "Same_Shape_1d.f9h"
  end subroutine Same_Shape_RealR4_1d
  ! -----------------------------------------  Same_Shape_RealR4_2d  -----
  subroutine Same_Shape_RealR4_2d ( Ref, New, ItsName, ModuleName )
    real, pointer, dimension(:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_RealR4_2d
  ! ---------------------------------------  Same_Shape_RealR4_3d  -----
  subroutine Same_Shape_RealR4_3d ( Ref, New, ItsName, ModuleName )
    real, pointer, dimension(:,:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_RealR4_3d
  ! ---------------------------------------  Same_Shape_RealR4_4d  -----
  subroutine Same_Shape_RealR4_4d ( Ref, New, ItsName, ModuleName )
    real, pointer, dimension(:,:,:,:) :: Ref, New
    include "Same_Shape_md.f9h"
  end subroutine Same_Shape_RealR4_4d
  ! ----------------------------------  Same_Shape_Character_1d_a  -----
  subroutine Same_Shape_Character_1d_a ( New, ItsName, ModuleName, TheShape )
    character(len=*), pointer, dimension(:) :: New
    include "Same_Shape_1d_a.f9h"
  end subroutine Same_Shape_Character_1d_a
  ! ----------------------------------  Same_Shape_Character_2d_a  -----
  subroutine Same_Shape_Character_2d_a ( New, ItsName, ModuleName, TheShape )
    character(len=*), pointer, dimension(:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Character_2d_a
  ! ----------------------------------  Same_Shape_Character_3d_a  -----
  subroutine Same_Shape_Character_3d_a ( New, ItsName, ModuleName, TheShape )
    character(len=*), pointer, dimension(:,:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Character_3d_a
  ! ------------------------------------  Same_Shape_Complex_1d_a  -----
  subroutine Same_Shape_Complex_1d_a ( New, ItsName, ModuleName, TheShape )
    complex, pointer, dimension(:) :: New
    include "Same_Shape_1d_a.f9h"
  end subroutine Same_Shape_Complex_1d_a
  ! ------------------------------------  Same_Shape_Complex_2d_a  -----
  subroutine Same_Shape_Complex_2d_a ( New, ItsName, ModuleName, TheShape )
    complex, pointer, dimension(:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Complex_2d_a
  ! ------------------------------------  Same_Shape_Complex_3d_a  -----
  subroutine Same_Shape_Complex_3d_a ( New, ItsName, ModuleName, TheShape )
    complex, pointer, dimension(:,:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Complex_3d_a
  ! -----------------------------------  Same_Shape_Dcomplex_1d_a  -----
  subroutine Same_Shape_Dcomplex_1d_a ( New, ItsName, ModuleName, TheShape )
    complex(kind(0.0d0)), pointer, dimension(:) :: New
    include "Same_Shape_1d_a.f9h"
  end subroutine Same_Shape_Dcomplex_1d_a
  ! -----------------------------------  Same_Shape_Dcomplex_2d_a  -----
  subroutine Same_Shape_Dcomplex_2d_a ( New, ItsName, ModuleName, TheShape )
    complex(kind(0.0d0)), pointer, dimension(:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Dcomplex_2d_a
  ! -----------------------------------  Same_Shape_Dcomplex_3d_a  -----
  subroutine Same_Shape_Dcomplex_3d_a ( New, ItsName, ModuleName, TheShape )
    complex(kind(0.0d0)), pointer, dimension(:,:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Dcomplex_3d_a
  ! -------------------------------------  Same_Shape_RealR8_1d_a  -----
  subroutine Same_Shape_RealR8_1d_a ( New, ItsName, ModuleName, TheShape )
    double precision, pointer, dimension(:) :: New
    include "Same_Shape_1d_a.f9h"
  end subroutine Same_Shape_RealR8_1d_a
  ! -------------------------------------  Same_Shape_RealR8_2d_a  -----
  subroutine Same_Shape_RealR8_2d_a ( New, ItsName, ModuleName, TheShape )
    double precision, pointer, dimension(:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_RealR8_2d_a
  ! -------------------------------------  Same_Shape_RealR8_3d_a  -----
  subroutine Same_Shape_RealR8_3d_a ( New, ItsName, ModuleName, TheShape )
    double precision, pointer, dimension(:,:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_RealR8_3d_a
  ! -------------------------------------  Same_Shape_RealR8_4d_a  -----
  subroutine Same_Shape_RealR8_4d_a ( New, ItsName, ModuleName, TheShape )
    double precision, pointer, dimension(:,:,:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_RealR8_4d_a
  ! ------------------------------------  Same_Shape_Integer_1d_a  -----
  subroutine Same_Shape_Integer_1d_a ( New, ItsName, ModuleName, TheShape )
    integer, pointer, dimension(:) :: New
    include "Same_Shape_1d_a.f9h"
  end subroutine Same_Shape_Integer_1d_a
  ! ------------------------------------  Same_Shape_Integer_2d_a  -----
  subroutine Same_Shape_Integer_2d_a ( New, ItsName, ModuleName, TheShape )
    integer, pointer, dimension(:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Integer_2d_a
  ! ------------------------------------  Same_Shape_Integer_3d_a  -----
  subroutine Same_Shape_Integer_3d_a ( New, ItsName, ModuleName, TheShape )
    integer, pointer, dimension(:,:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Integer_3d_a
  ! ------------------------------------  Same_Shape_Integer_4d_a  -----
  subroutine Same_Shape_Integer_4d_a ( New, ItsName, ModuleName, TheShape )
    integer, pointer, dimension(:,:,:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Integer_4d_a
  ! ------------------------------------  Same_Shape_Logical_1d_a  -----
  subroutine Same_Shape_Logical_1d_a ( New, ItsName, ModuleName, TheShape )
    logical, pointer, dimension(:) :: New
    include "Same_Shape_1d_a.f9h"
  end subroutine Same_Shape_Logical_1d_a
  ! ------------------------------------  Same_Shape_Logical_2d_a  -----
  subroutine Same_Shape_Logical_2d_a ( New, ItsName, ModuleName, TheShape )
    logical, pointer, dimension(:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Logical_2d_a
  ! ------------------------------------  Same_Shape_Logical_3d_a  -----
  subroutine Same_Shape_Logical_3d_a ( New, ItsName, ModuleName, TheShape )
    logical, pointer, dimension(:,:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_Logical_3d_a
  ! -------------------------------------  Same_Shape_RealR4_1d_a  -----
  subroutine Same_Shape_RealR4_1d_a ( New, ItsName, ModuleName, TheShape )
    real, pointer, dimension(:) :: New
    include "Same_Shape_1d_a.f9h"
  end subroutine Same_Shape_RealR4_1d_a
  ! -------------------------------------  Same_Shape_RealR4_2d_a  -----
  subroutine Same_Shape_RealR4_2d_a ( New, ItsName, ModuleName, TheShape )
    real, pointer, dimension(:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_RealR4_2d_a
  ! -------------------------------------  Same_Shape_RealR4_3d_a  -----
  subroutine Same_Shape_RealR4_3d_a ( New, ItsName, ModuleName, TheShape )
    real, pointer, dimension(:,:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_RealR4_3d_a
  ! -------------------------------------  Same_Shape_RealR4_4d_a  -----
  subroutine Same_Shape_RealR4_4d_a ( New, ItsName, ModuleName, TheShape )
    real, pointer, dimension(:,:,:,:) :: New
    include "Same_Shape_md_a.f9h"
  end subroutine Same_Shape_RealR4_4d_a

  ! ------------------------------=--- LogAllocate
  subroutine LogAllocate ( ModuleNameIn, ItsName, lBounds, uBounds, &
    & ElementSize, Address )
    character(len=*), intent(in)  :: ModuleNameIn, ItsName
    integer, intent(in), optional :: Lbounds(:), Ubounds(:)
    integer, intent(in), optional :: ElementSize
    integer(c_intptr_t), intent(in), optional :: Address ! of allocated object
                                                         ! if status == 0
    integer(c_intptr_t) :: Addr
    integer(c_intptr_t) :: Amount
    amount = 0
    addr = 0
    if ( present(address) ) addr = address
    if ( present(lbounds) .and. present(ubounds) .and. present(elementSize) ) then
      amount = memproduct(elementSize, ubounds-lbounds+1)
    end if
    serial_no = serial_no + 1
    if ( amount >= AllocateLogLimit ) then
      write( AllocateLogUnit, "(2(i0,1x),a,i0,2(1x,a))" ) addr, serial_no, 'A ', &
      & amount, trim(snipRCSfrom(ModuleNameIn)), trim(ItsName)
      flush ( AllocateLogUnit ) ! In case there's a crash soon after...
    end if
  end subroutine LogAllocate

  ! ------------------------------=--- LogDeallocate
  subroutine LogDeallocate ( ModuleNameIn, ItsName, Size, Address )
    character(len=*), intent(in)  :: ModuleNameIn, ItsName
    integer, intent(in), optional :: Size
    integer(c_intptr_t), intent(in), optional :: Address ! of deallocated object

    integer(c_intptr_t) :: Addr
    integer :: mySize
    ! Executable
    mySize = 0.
    addr = 0
    if ( present(address) ) addr = address
    if ( present(Size) ) mySize = Size
    serial_no = serial_no + 1
    if ( mySize >= AllocateLogLimit ) then
      write( AllocateLogUnit, "(2(i0,1x),a,i0,2(1x,a))" ) addr, serial_no, 'D ', &
        & mySize, trim(snipRCSfrom(ModuleNameIn)), trim(ItsName)
      flush ( AllocateLogUnit ) ! In case there's a crash soon after...
    end if
  end subroutine LogDeallocate

  ! ----------------------------------  memproduct  -----
  function memproduct ( elementSize, dimensions ) result( p )
    ! Find how many multiples of MEMORY_UNITS an array
    ! with elementSize and dimensions
    ! Note: we go through all this to forestall integer overflows
    integer, dimension(:), intent(in) :: dimensions
    integer, intent(in)               :: elementSize
    integer(c_intptr_t)               :: p
    !
    p = real(elementSize) * product(real(dimensions))
    ! print *, 'p ', p
  end function memproduct

  ! ------------------------------------------------  Not_Used_Here  -----
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Allocate_Deallocate.f90,v 2.57 2019/08/19 21:58:18 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Allocate_Deallocate

! $Log: Allocate_Deallocate.f90,v $
! Revision 2.57  2019/08/19 21:58:18  pwagner
! Moved NoBytesAllocated to MLSCommon from Allocate_Deallocate; print warnings through MLSMessage
!
! Revision 2.56  2018/05/15 03:17:36  vsnyder
! Add 1D and 2D character allocatable versions
!
! Revision 2.55  2018/04/19 02:00:36  vsnyder
! Compute address for allocate/deallocate tracking.  Remove USE statements for
! unused names.
!
! Revision 2.54  2018/04/10 22:51:33  vsnyder
! Don't leave bounds(1:1) undefined for messages about scalars
!
! Revision 2.53  2017/10/31 23:42:57  vsnyder
! Add allocatable logical array support
!
! Revision 2.52  2016/09/07 23:54:37  vsnyder
! Add support for allocatable integer arrays
!
! Revision 2.51  2015/06/04 01:55:17  vsnyder
! Don't reallocate if bounds are the same
!
! Revision 2.50  2015/06/02 23:51:40  vsnyder
! Routines for allocatable arrays
!
! Revision 2.49  2015/03/27 01:10:38  vsnyder
! Log allocated/deallocated entity's address, if provided
!
! Revision 2.48  2014/09/04 23:37:01  vsnyder
! Change Test_Allocate to Test_Allocate_nd, Add Test_Allocate_1d, add
! generic for them.  Keep track of memory in bytes instead of Memory_Units
! (formerly 1024 bytes), delete Memory_Units.
!
! Revision 2.47  2014/08/06 23:18:04  vsnyder
! Add option controlled by private parameter to fill REAL arrays with sNaN
!
! Revision 2.46  2014/06/30 23:24:17  pwagner
! Can log allocations/deallocations to separate file
!
! Revision 2.45  2014/05/29 18:20:27  pwagner
! Extra debugging possibility
!
! Revision 2.44  2014/01/09 00:25:06  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.43  2013/10/09 01:02:05  vsnyder
! Add SnipRCSFromName to MyMessage
!
! Revision 2.42  2013/08/28 00:38:17  pwagner
! Added a local version of MyMessage to evade possible circular dependency
!
! Revision 2.41  2013/08/16 02:05:34  vsnyder
! Make Same_Shape public (oops), add Same_Shape..._a versions
!
! Revision 2.40  2013/08/16 01:06:22  vsnyder
! Add Same_Shape
!
! Revision 2.39  2013/06/12 02:50:45  vsnyder
! Repair a couple of harmless but ugly blunders
!
! Revision 2.38  2013/06/12 02:17:03  vsnyder
! Add and use BYTES and Byte_Size
!
! Revision 2.37  2011/03/02 01:59:07  vsnyder
! Make lbounds and ubounds arguments of Test_Allocate optional
!
! Revision 2.36  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.35  2008/05/21 21:49:26  vsnyder
! Add allocation routines with arrays for bounds
!
! Revision 2.34  2008/05/20 01:59:28  vsnyder
! Add 4d integer, real, double
!
! Revision 2.33  2007/07/27 00:19:30  vsnyder
! Better printing in Test_[De]Allocate, work on memory tracking
!
! Revision 2.32  2006/08/05 02:36:57  vsnyder
! Pass bounds argument of ReportAllocateDeallocate_ints forward
!
! Revision 2.31  2006/08/04 18:12:56  vsnyder
! Add 'bounds' to ReportAlllocateDeallocate, don't look at ElementSize if it's not present
!
! Revision 2.30  2006/07/29 03:01:07  vsnyder
! Use track_m stuff
!
! Revision 2.29  2006/07/28 01:57:25  vsnyder
! Use real() instead of *1.0 to convert to real
!
! Revision 2.28  2006/07/19 22:24:18  vsnyder
! Track memory usage even if not reporting, for trace_m
!
! Revision 2.27  2005/12/16 23:25:37  pwagner
! dumpSize moved from dump0 to output_m
!
! Revision 2.26  2005/11/18 21:09:35  vsnyder
! Don't print trailing comma after last dimension in allocation failure message
!
! Revision 2.25  2005/10/03 18:04:51  pwagner
! Allocated memory now tracked in units of MEMORY_UNITS
!
! Revision 2.24  2005/09/16 23:38:20  vsnyder
! Add Complex allocators
!
! Revision 2.23  2005/07/20 16:22:52  pwagner
! Declared undeclared variable L; compiles successfully
!
! Revision 2.22  2005/07/20 01:32:55  vsnyder
! Add Test_Allocate and Test_Deallocate.  Regularize routines.  All now have an
! optional Fill argument.  For a given rank, calling sequences are the same
! (modulo types), including argument names.  Add [De]Allocate_Test_Logical_3d.
! Move guts of [De]Allocate_Test* into include files.
!
! Revision 2.21  2005/06/03 01:53:06  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades
!
! Revision 2.20  2005/06/01 02:30:30  vsnyder
! Add optional Fill argument to allocate_test_integer_...
!
! Revision 2.19  2004/12/28 00:24:39  vsnyder
! Use default REAL and DOUBLE PRECISION because R4 and R8 are not guaranteed
! to be different.
!
! Revision 2.18  2004/10/30 00:23:21  vsnyder
! Add low_bound1 to Allocate_Test_Integer_3d
!
! Revision 2.17  2004/10/02 02:42:35  vsnyder
! Add low bounds to Allocate_Test_Integer_2D
!
! Revision 2.16  2004/04/06 23:49:59  livesey
! Added ClearOnAllocate stuff
!
! Revision 2.15  2004/04/05 17:47:56  livesey
! Bug fix in the tracking stuff
!
! Revision 2.14  2004/04/03 05:43:53  livesey
! First attempt at memory tracking
!
! Revision 2.13  2004/01/30 21:20:35  vsnyder
! Add bounds to 'allocation failed' message
!
! Revision 2.12  2004/01/24 01:01:05  livesey
! Nullify all pointers after deallocating.
!
! Revision 2.11  2002/10/08 00:09:08  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.10  2002/07/01 23:47:08  vsnyder
! Add [De]AllocateTest_3d, cosmetic changes
!
! Revision 2.9  2002/02/05 00:42:47  pwagner
! Optionally collects garbage after each deallocate_test
!
! Revision 2.8  2002/02/01 01:48:17  vsnyder
! Add [De]Allocate_Test_Character_2d
!
! Revision 2.7  2001/09/10 21:05:01  livesey
! Added logical 2d stuff
!
! Revision 2.6  2001/05/30 23:52:15  livesey
! Added 3D integer option.
!
! Revision 2.5  2001/04/02 20:50:27  vsnyder
! Add logical 1-D
!
! Revision 2.4  2001/03/24 23:25:57  livesey
! Added real(r4) 3d, and renamed routines
!
! Revision 2.3  2001/02/22 01:54:41  vsnyder
! Periodic commit
!
! Revision 2.2  2000/10/09 23:03:49  vsnyder
! Provide for lower bounds for allocated arrays
!
! Revision 2.0  2000/09/05 18:57:02  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.1  2000/09/02 02:05:03  vsnyder
! Initial entry
!
@


2.57
log
@Moved NoBytesAllocated to MLSCommon from Allocate_Deallocate; print warnings through MLSMessage
@
text
@d31 1
d36 2
a37 1
  use MLSCommon, only: Nobytesallocated
d46 2
a47 2
    & NoBytesAllocated, set_garbage_collection, reportallocatedeallocate, &
    & Same_Shape, Test_Allocate, Test_Deallocate
d260 2
a261 2
    use OUTPUT_M, only: OUTPUT
    use HIGHOUTPUT, only: DUMPSIZE
d271 7
d367 7
d445 2
d2167 1
a2167 1
       "$Id: Allocate_Deallocate.f90,v 2.56 2018/05/15 03:17:36 vsnyder Exp $"
d2177 3
@


2.56
log
@Add 1D and 2D character allocatable versions
@
text
@d31 8
a38 7
  use, intrinsic :: IEEE_Arithmetic, only: IEEE_Signaling_NaN, IEEE_Value, &
    IEEE_Support_DataType
  use ISO_C_Binding, only: C_intptr_t, C_Loc
  use MACHINE, only: MLS_GC_NOW
  use PRINTIT_M, only: MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, &
    & MLSMSG_ERROR, MLSMSG_WARNING, PRINTITOUT, SnipRCSFrom
  use TRACK_M, only: TRACKALLOCATE, TRACKDEALLOCATE
d40 1
a40 1
  implicit NONE
d43 2
a44 2
  public :: Byte_Size, BYTES, Allocate_Test, Deallocate_Test, DEALLOC_STATUS, & 
    & SET_GARBAGE_COLLECTION, REPORTALLOCATEDEALLOCATE, &
a230 4
  ! The next two used for tracking allocated memory
  ! (The 1st is public to enable reporting finer or coarser grains)
!  real, save, public  :: MEMORY_UNITS = 1024. ! Report nothing smaller than KB
  double precision, save, protected, public :: NoBytesAllocated=0.0d0 ! Number of MEMORY_UNITS allocated.
d1814 10
d1844 1
a1844 1
  end subroutine myMessage
d2149 1
a2149 1
       "$Id: Allocate_Deallocate.f90,v 2.55 2018/04/19 02:00:36 vsnyder Exp $"
d2159 3
@


2.55
log
@Compute address for allocate/deallocate tracking.  Remove USE statements for
unused names.
@
text
@d63 1
d108 1
d968 23
d1464 10
d2142 1
a2142 1
       "$Id: Allocate_Deallocate.f90,v 2.54 2018/04/10 22:51:33 vsnyder Exp $"
d2152 4
@


2.54
log
@Don't leave bounds(1:1) undefined for messages about scalars
@
text
@d40 1
a40 1
  private
d2107 1
a2107 1
       "$Id: Allocate_Deallocate.f90,v 2.53 2017/10/31 23:42:57 vsnyder Exp $"
d2117 3
@


2.53
log
@Add allocatable logical array support
@
text
@d332 1
d2107 1
a2107 1
       "$Id: Allocate_Deallocate.f90,v 2.52 2016/09/07 23:54:37 vsnyder Exp $"
d2117 3
@


2.52
log
@Add support for allocatable integer arrays
@
text
@d65 2
d109 2
d1048 58
d1458 15
d2106 1
a2106 1
       "$Id: Allocate_Deallocate.f90,v 2.51 2015/06/04 01:55:17 vsnyder Exp $"
d2116 3
@


2.51
log
@Don't reallocate if bounds are the same
@
text
@d63 2
d81 2
d105 2
d961 84
a1044 1
  ! ------------------------------------  Allocate_Test_RealR8_1d  -----
d1058 1
a1058 1
  ! ------------------------------------  AllocateA_Test_RealR8_2d  -----
d1148 1
a1148 1
  ! --------------------------------------  Allocate_Test_RealR4_1d  -----
d1376 20
d2029 1
a2029 1
       "$Id: Allocate_Deallocate.f90,v 2.50 2015/06/02 23:51:40 vsnyder Exp $"
d2039 3
@


2.50
log
@Routines for allocatable arrays
@
text
@d964 1
a964 1
    include "Allocate_Test_1D.f9h"
d979 1
a979 1
    include "Allocate_Test_2D.f9h"
d993 1
a993 1
    include "Allocate_Test_2D_a.f9h"
d1009 1
a1009 1
    include "Allocate_Test_3D.f9h"
d1023 1
a1023 1
    include "Allocate_Test_3D_a.f9h"
d1040 1
a1040 1
    include "Allocate_Test_4D.f9h"
d1054 1
a1054 1
    include "Allocate_Test_4D_a.f9h"
d1068 1
a1068 1
    include "Allocate_Test_1D.f9h"
d1083 1
a1083 1
    include "Allocate_Test_2D.f9h"
d1097 1
a1097 1
    include "Allocate_Test_2D_a.f9h"
d1113 1
a1113 1
    include "Allocate_Test_3D.f9h"
d1127 1
a1127 1
    include "Allocate_Test_3D_a.f9h"
d1144 1
a1144 1
    include "Allocate_Test_4D.f9h"
d1158 1
a1158 1
    include "Allocate_Test_4D_a.f9h"
d1920 1
a1920 1
       "$Id: Allocate_Deallocate.f90,v 2.49 2015/03/27 01:10:38 vsnyder Exp $"
d1930 3
@


2.49
log
@Log allocated/deallocated entity's address, if provided
@
text
@d42 1
a42 1
  public :: BYTE_SIZE, BYTES, ALLOCATE_TEST, DEALLOCATE_TEST, DEALLOC_STATUS, & 
d46 1
a46 1
  interface ALLOCATE_TEST
d48 19
a66 14
    module procedure ALLOCATE_TEST_CHARACTER_1D, ALLOCATE_TEST_CHARACTER_2D
    module procedure ALLOCATE_TEST_CHARACTER_3D
    module procedure ALLOCATE_TEST_COMPLEX_1D, ALLOCATE_TEST_COMPLEX_2D
    module procedure ALLOCATE_TEST_COMPLEX_3D
    module procedure ALLOCATE_TEST_DCOMPLEX_1D, ALLOCATE_TEST_DCOMPLEX_2D
    module procedure ALLOCATE_TEST_DCOMPLEX_3D
    module procedure ALLOCATE_TEST_INTEGER_1D, ALLOCATE_TEST_INTEGER_2D
    module procedure ALLOCATE_TEST_INTEGER_3D, ALLOCATE_TEST_INTEGER_4D
    module procedure ALLOCATE_TEST_LOGICAL_1D, ALLOCATE_TEST_LOGICAL_2D
    module procedure ALLOCATE_TEST_LOGICAL_3D
    module procedure ALLOCATE_TEST_REALR4_1D, ALLOCATE_TEST_REALR4_2D
    module procedure ALLOCATE_TEST_REALR4_3D, ALLOCATE_TEST_REALR4_4D
    module procedure ALLOCATE_TEST_REALR8_1D, ALLOCATE_TEST_REALR8_2D
    module procedure ALLOCATE_TEST_REALR8_3D, ALLOCATE_TEST_REALR8_4D
d68 15
a82 10
    module procedure ALLOCATE_TEST_CHARACTER_2D_A, ALLOCATE_TEST_CHARACTER_3D_A
    module procedure ALLOCATE_TEST_COMPLEX_2D_A, ALLOCATE_TEST_COMPLEX_3D_A
    module procedure ALLOCATE_TEST_DCOMPLEX_2D_A, ALLOCATE_TEST_DCOMPLEX_3D_A
    module procedure ALLOCATE_TEST_INTEGER_2D_A
    module procedure ALLOCATE_TEST_INTEGER_3D_A, ALLOCATE_TEST_INTEGER_4D_A
    module procedure ALLOCATE_TEST_LOGICAL_2D_A, ALLOCATE_TEST_LOGICAL_3D_A
    module procedure ALLOCATE_TEST_REALR4_2D_A
    module procedure ALLOCATE_TEST_REALR4_3D_A, ALLOCATE_TEST_REALR4_4D_A
    module procedure ALLOCATE_TEST_REALR8_2D_A
    module procedure ALLOCATE_TEST_REALR8_3D_A, ALLOCATE_TEST_REALR8_4D_A
d85 20
a104 15
  interface DEALLOCATE_TEST
    module procedure DEALLOCATE_TEST_CHARACTER_1D, DEALLOCATE_TEST_CHARACTER_2D
    module procedure DEALLOCATE_TEST_CHARACTER_3D
    module procedure DEALLOCATE_TEST_COMPLEX_1D, DEALLOCATE_TEST_COMPLEX_2D
    module procedure DEALLOCATE_TEST_COMPLEX_3D
    module procedure DEALLOCATE_TEST_DCOMPLEX_1D, DEALLOCATE_TEST_DCOMPLEX_2D
    module procedure DEALLOCATE_TEST_DCOMPLEX_3D
    module procedure DEALLOCATE_TEST_INTEGER_1D, DEALLOCATE_TEST_INTEGER_2D
    module procedure DEALLOCATE_TEST_INTEGER_3D, DEALLOCATE_TEST_INTEGER_4D
    module procedure DEALLOCATE_TEST_LOGICAL_1D, DEALLOCATE_TEST_LOGICAL_2D
    module procedure DEALLOCATE_TEST_LOGICAL_3D
    module procedure DEALLOCATE_TEST_REALR4_1D, DEALLOCATE_TEST_REALR4_2D
    module procedure DEALLOCATE_TEST_REALR4_3D, DEALLOCATE_TEST_REALR4_4D
    module procedure DEALLOCATE_TEST_REALR8_1D, DEALLOCATE_TEST_REALR8_2D
    module procedure DEALLOCATE_TEST_REALR8_3D, DEALLOCATE_TEST_REALR8_4D
d108 17
a124 17
  interface BYTE_SIZE
    module procedure BYTE_SIZE_CHARACTER_1D, BYTE_SIZE_CHARACTER_2D
    module procedure BYTE_SIZE_CHARACTER_3D
    module procedure BYTE_SIZE_COMPLEX_1D, BYTE_SIZE_COMPLEX_2D
    module procedure BYTE_SIZE_COMPLEX_3D
    module procedure BYTE_SIZE_DCOMPLEX_1D, BYTE_SIZE_DCOMPLEX_2D
    module procedure BYTE_SIZE_DCOMPLEX_3D
    module procedure BYTE_SIZE_INTEGER_1D, BYTE_SIZE_INTEGER_2D
    module procedure BYTE_SIZE_INTEGER_3D, BYTE_SIZE_INTEGER_4D
    module procedure BYTE_SIZE_LOGICAL_1D, BYTE_SIZE_LOGICAL_2D
    module procedure BYTE_SIZE_LOGICAL_3D
    module procedure BYTE_SIZE_REALR4_1D, BYTE_SIZE_REALR4_2D
    module procedure BYTE_SIZE_REALR4_3D, BYTE_SIZE_REALR4_4D
    module procedure BYTE_SIZE_REALR4_5D, BYTE_SIZE_REALR4_6D
    module procedure BYTE_SIZE_REALR8_1D, BYTE_SIZE_REALR8_2D
    module procedure BYTE_SIZE_REALR8_3D, BYTE_SIZE_REALR8_4D
    module procedure BYTE_SIZE_REALR8_5D, BYTE_SIZE_REALR8_6D
d129 13
a141 13
    module procedure BYTES_CHARACTER_1D, BYTES_CHARACTER_2D
    module procedure BYTES_CHARACTER_3D
    module procedure BYTES_COMPLEX_1D, BYTES_COMPLEX_2D, BYTES_COMPLEX_3D
    module procedure BYTES_DCOMPLEX_1D, BYTES_DCOMPLEX_2D, BYTES_DCOMPLEX_3D
    module procedure BYTES_INTEGER_1D, BYTES_INTEGER_2D
    module procedure BYTES_INTEGER_3D, BYTES_INTEGER_4D
    module procedure BYTES_LOGICAL_1D, BYTES_LOGICAL_2D, BYTES_LOGICAL_3D
    module procedure BYTES_REALR4_1D, BYTES_REALR4_2D
    module procedure BYTES_REALR4_3D, BYTES_REALR4_4D
    module procedure BYTES_REALR4_5D, BYTES_REALR4_6D
    module procedure BYTES_REALR8_1D, BYTES_REALR8_2D
    module procedure BYTES_REALR8_3D, BYTES_REALR8_4D
    module procedure BYTES_REALR8_5D, BYTES_REALR8_6D
d146 1
a146 1
    module procedure ReportAllocateDeallocate_real
d159 28
a186 28
    module procedure Same_Shape_CHARACTER_1D, Same_Shape_CHARACTER_2D
    module procedure Same_Shape_CHARACTER_3D
    module procedure Same_Shape_COMPLEX_1D, Same_Shape_COMPLEX_2D
    module procedure Same_Shape_COMPLEX_3D
    module procedure Same_Shape_DCOMPLEX_1D, Same_Shape_DCOMPLEX_2D
    module procedure Same_Shape_DCOMPLEX_3D
    module procedure Same_Shape_INTEGER_1D, Same_Shape_INTEGER_2D
    module procedure Same_Shape_INTEGER_3D, Same_Shape_INTEGER_4D
    module procedure Same_Shape_LOGICAL_1D, Same_Shape_LOGICAL_2D
    module procedure Same_Shape_LOGICAL_3D
    module procedure Same_Shape_REALR4_1D, Same_Shape_REALR4_2D
    module procedure Same_Shape_REALR4_3D, Same_Shape_REALR4_4D
    module procedure Same_Shape_REALR8_1D, Same_Shape_REALR8_2D
    module procedure Same_Shape_REALR8_3D, Same_Shape_REALR8_4D
    module procedure Same_Shape_CHARACTER_1D_A, Same_Shape_CHARACTER_2D_A
    module procedure Same_Shape_CHARACTER_3D_A
    module procedure Same_Shape_COMPLEX_1D_A, Same_Shape_COMPLEX_2D_A
    module procedure Same_Shape_COMPLEX_3D_A
    module procedure Same_Shape_DCOMPLEX_1D_A, Same_Shape_DCOMPLEX_2D_A
    module procedure Same_Shape_DCOMPLEX_3D_A
    module procedure Same_Shape_INTEGER_1D_A, Same_Shape_INTEGER_2D_A
    module procedure Same_Shape_INTEGER_3D_A, Same_Shape_INTEGER_4D_A
    module procedure Same_Shape_LOGICAL_1D_A, Same_Shape_LOGICAL_2D_A
    module procedure Same_Shape_LOGICAL_3D_A
    module procedure Same_Shape_REALR4_1D_A, Same_Shape_REALR4_2D_A
    module procedure Same_Shape_REALR4_3D_A, Same_Shape_REALR4_4D_A
    module procedure Same_Shape_REALR8_1D_A, Same_Shape_REALR8_2D_A
    module procedure Same_Shape_REALR8_3D_A, Same_Shape_REALR8_4D_A
d247 2
a248 2
  !-----------------------------------   ReportAllocateDeallocate_real  -----
  subroutine ReportAllocateDeallocate_real ( name, moduleName, noBytes, bounds )
d280 1
a280 1
  end subroutine ReportAllocateDeallocate_real
d953 211
d1285 43
d1329 1
a1329 1
  integer function BYTE_SIZE_CHARACTER_1D ( A ) result ( BYTE_SIZE )
d1332 2
a1333 2
  end function BYTE_SIZE_CHARACTER_1D
  integer function BYTE_SIZE_CHARACTER_2D ( A ) result ( BYTE_SIZE )
d1336 2
a1337 2
  end function BYTE_SIZE_CHARACTER_2D
  integer function BYTE_SIZE_CHARACTER_3D ( A ) result ( BYTE_SIZE )
d1340 2
a1341 2
  end function BYTE_SIZE_CHARACTER_3D
  integer function BYTE_SIZE_COMPLEX_1D ( A ) result ( BYTE_SIZE )
d1344 2
a1345 2
  end function BYTE_SIZE_COMPLEX_1D
  integer function BYTE_SIZE_COMPLEX_2D ( A ) result ( BYTE_SIZE )
d1348 2
a1349 2
  end function BYTE_SIZE_COMPLEX_2D
  integer function BYTE_SIZE_COMPLEX_3D ( A ) result ( BYTE_SIZE )
d1352 2
a1353 2
  end function BYTE_SIZE_COMPLEX_3D
  integer function BYTE_SIZE_DCOMPLEX_1D ( A ) result ( BYTE_SIZE )
d1356 2
a1357 2
  end function BYTE_SIZE_DCOMPLEX_1D
  integer function BYTE_SIZE_DCOMPLEX_2D ( A ) result ( BYTE_SIZE )
d1360 2
a1361 2
  end function BYTE_SIZE_DCOMPLEX_2D
  integer function BYTE_SIZE_DCOMPLEX_3D ( A ) result ( BYTE_SIZE )
d1364 2
a1365 2
  end function BYTE_SIZE_DCOMPLEX_3D
  integer function BYTE_SIZE_INTEGER_1D ( A ) result ( BYTE_SIZE )
d1368 2
a1369 2
  end function BYTE_SIZE_INTEGER_1D
  integer function BYTE_SIZE_INTEGER_2D ( A ) result ( BYTE_SIZE )
d1372 2
a1373 2
  end function BYTE_SIZE_INTEGER_2D
  integer function BYTE_SIZE_INTEGER_3D ( A ) result ( BYTE_SIZE )
d1376 2
a1377 2
  end function BYTE_SIZE_INTEGER_3D
  integer function BYTE_SIZE_INTEGER_4D ( A ) result ( BYTE_SIZE )
d1380 2
a1381 2
  end function BYTE_SIZE_INTEGER_4D
  integer function BYTE_SIZE_LOGICAL_1D ( A ) result ( BYTE_SIZE )
d1384 2
a1385 2
  end function BYTE_SIZE_LOGICAL_1D
  integer function BYTE_SIZE_LOGICAL_2D ( A ) result ( BYTE_SIZE )
d1388 2
a1389 2
  end function BYTE_SIZE_LOGICAL_2D
  integer function BYTE_SIZE_LOGICAL_3D ( A ) result ( BYTE_SIZE )
d1392 2
a1393 2
  end function BYTE_SIZE_LOGICAL_3D
  integer function BYTE_SIZE_REALR4_1D ( A ) result ( BYTE_SIZE )
d1396 2
a1397 2
  end function BYTE_SIZE_REALR4_1D
  integer function BYTE_SIZE_REALR4_2D ( A ) result ( BYTE_SIZE )
d1400 2
a1401 2
  end function BYTE_SIZE_REALR4_2D
  integer function BYTE_SIZE_REALR4_3D ( A ) result ( BYTE_SIZE )
d1404 2
a1405 2
  end function BYTE_SIZE_REALR4_3D
  integer function BYTE_SIZE_REALR4_4D ( A ) result ( BYTE_SIZE )
d1408 2
a1409 2
  end function BYTE_SIZE_REALR4_4D
  integer function BYTE_SIZE_REALR4_5D ( A ) result ( BYTE_SIZE )
d1412 2
a1413 2
  end function BYTE_SIZE_REALR4_5D
  integer function BYTE_SIZE_REALR4_6D ( A ) result ( BYTE_SIZE )
d1416 2
a1417 2
  end function BYTE_SIZE_REALR4_6D
  integer function BYTE_SIZE_REALR8_1D ( A ) result ( BYTE_SIZE )
d1420 2
a1421 2
  end function BYTE_SIZE_REALR8_1D
  integer function BYTE_SIZE_REALR8_2D ( A ) result ( BYTE_SIZE )
d1424 2
a1425 2
  end function BYTE_SIZE_REALR8_2D
  integer function BYTE_SIZE_REALR8_3D ( A ) result ( BYTE_SIZE )
d1428 2
a1429 2
  end function BYTE_SIZE_REALR8_3D
  integer function BYTE_SIZE_REALR8_4D ( A ) result ( BYTE_SIZE )
d1432 2
a1433 2
  end function BYTE_SIZE_REALR8_4D
  integer function BYTE_SIZE_REALR8_5D ( A ) result ( BYTE_SIZE )
d1436 2
a1437 2
  end function BYTE_SIZE_REALR8_5D
  integer function BYTE_SIZE_REALR8_6D ( A ) result ( BYTE_SIZE )
d1440 1
a1440 1
  end function BYTE_SIZE_REALR8_6D
d1443 1
a1443 1
  integer function BYTES_CHARACTER_1D ( A ) result ( BYTES )
d1450 2
a1451 2
  end function BYTES_CHARACTER_1D
  integer function BYTES_CHARACTER_2D ( A ) result ( BYTES )
d1458 2
a1459 2
  end function BYTES_CHARACTER_2D
  integer function BYTES_CHARACTER_3D ( A ) result ( BYTES )
d1466 2
a1467 2
  end function BYTES_CHARACTER_3D
  integer function BYTES_COMPLEX_1D ( A ) result ( BYTES )
d1471 2
a1472 2
  end function BYTES_COMPLEX_1D
  integer function BYTES_COMPLEX_2D ( A ) result ( BYTES )
d1476 2
a1477 2
  end function BYTES_COMPLEX_2D
  integer function BYTES_COMPLEX_3D ( A ) result ( BYTES )
d1481 2
a1482 2
  end function BYTES_COMPLEX_3D
  integer function BYTES_DCOMPLEX_1D ( A ) result ( BYTES )
d1486 2
a1487 2
  end function BYTES_DCOMPLEX_1D
  integer function BYTES_DCOMPLEX_2D ( A ) result ( BYTES )
d1491 2
a1492 2
  end function BYTES_DCOMPLEX_2D
  integer function BYTES_DCOMPLEX_3D ( A ) result ( BYTES )
d1496 2
a1497 2
  end function BYTES_DCOMPLEX_3D
  integer function BYTES_INTEGER_1D ( A ) result ( BYTES )
d1501 2
a1502 2
  end function BYTES_INTEGER_1D
  integer function BYTES_INTEGER_2D ( A ) result ( BYTES )
d1506 2
a1507 2
  end function BYTES_INTEGER_2D
  integer function BYTES_INTEGER_3D ( A ) result ( BYTES )
d1511 2
a1512 2
  end function BYTES_INTEGER_3D
  integer function BYTES_INTEGER_4D ( A ) result ( BYTES )
d1516 2
a1517 2
  end function BYTES_INTEGER_4D
  integer function BYTES_LOGICAL_1D ( A ) result ( BYTES )
d1521 2
a1522 2
  end function BYTES_LOGICAL_1D
  integer function BYTES_LOGICAL_2D ( A ) result ( BYTES )
d1526 2
a1527 2
  end function BYTES_LOGICAL_2D
  integer function BYTES_LOGICAL_3D ( A ) result ( BYTES )
d1531 2
a1532 2
  end function BYTES_LOGICAL_3D
  integer function BYTES_REALR4_1D ( A ) result ( BYTES )
d1536 2
a1537 2
  end function BYTES_REALR4_1D
  integer function BYTES_REALR4_2D ( A ) result ( BYTES )
d1541 2
a1542 2
  end function BYTES_REALR4_2D
  integer function BYTES_REALR4_3D ( A ) result ( BYTES )
d1546 2
a1547 2
  end function BYTES_REALR4_3D
  integer function BYTES_REALR4_4D ( A ) result ( BYTES )
d1551 2
a1552 2
  end function BYTES_REALR4_4D
  integer function BYTES_REALR4_5D ( A ) result ( BYTES )
d1556 2
a1557 2
  end function BYTES_REALR4_5D
  integer function BYTES_REALR4_6D ( A ) result ( BYTES )
d1561 2
a1562 2
  end function BYTES_REALR4_6D
  integer function BYTES_REALR8_1D ( A ) result ( BYTES )
d1566 2
a1567 2
  end function BYTES_REALR8_1D
  integer function BYTES_REALR8_2D ( A ) result ( BYTES )
d1571 2
a1572 2
  end function BYTES_REALR8_2D
  integer function BYTES_REALR8_3D ( A ) result ( BYTES )
d1576 2
a1577 2
  end function BYTES_REALR8_3D
  integer function BYTES_REALR8_4D ( A ) result ( BYTES )
d1581 2
a1582 2
  end function BYTES_REALR8_4D
  integer function BYTES_REALR8_5D ( A ) result ( BYTES )
d1586 2
a1587 2
  end function BYTES_REALR8_5D
  integer function BYTES_REALR8_6D ( A ) result ( BYTES )
d1591 1
a1591 1
  end function BYTES_REALR8_6D
d1920 1
a1920 1
       "$Id: Allocate_Deallocate.f90,v 2.48 2014/09/04 23:37:01 vsnyder Exp $"
d1930 3
d1966 1
a1966 1
! Add and use BYTES and BYTE_SIZE
@


2.48
log
@Change Test_Allocate to Test_Allocate_nd, Add Test_Allocate_1d, add
generic for them.  Keep track of memory in bytes instead of Memory_Units
(formerly 1024 bytes), delete Memory_Units.
@
text
@d33 1
d182 1
a182 1
  integer, save :: DEALLOC_STATUS = 0
d184 1
a184 1
  logical, public :: CLEARONALLOCATE = .false. ! If true, zero all allocated stuff
d188 4
a191 3
  integer, public :: TRACKALLOCATES = 0 ! <= 0 => No tracking
                                        ! 1    => Track using the Track_m module
                                        ! >= 2 => 1 + report all transactions
d193 1
a193 1
  real, public ::    AllocateLogLimit = 1. ! Son't log amounts smaller than this
d210 2
d275 1
a275 1
    & lBounds, uBounds, ElementSize, ERMSG )
d285 2
d318 1
a318 1
      & lBounds, uBounds, ElementSize )
d345 1
a345 1
    & lBounds, uBounds, ElementSize, ERMSG )
d357 2
d365 1
a365 1
    & myLBounds, myUBounds, elementSize, ERMSG )
d369 2
a370 1
  subroutine Test_DeAllocate_int_s ( Status, ModuleNameIn, ItsName, Size )
d378 3
d382 2
a383 1
    character(31) :: Line
d387 4
d397 2
a398 1
    if ( AllocateLogUnit > 0 ) call LogDeallocate( ModuleNameIn, ItsName, Size )
d1591 1
a1591 1
    & ElementSize )
d1595 4
a1598 1
    real :: Amount
d1600 2
d1604 7
a1610 4
    endif
    if ( amount >= AllocateLogLimit ) &
      & write( AllocateLogUnit, * ) trim(ItsName), ' _a_ ', &
      & amount, trim(snipRCSfrom(ModuleNameIn))
d1614 1
a1614 1
  subroutine LogDeallocate ( ModuleNameIn, ItsName, Size )
d1617 3
d1623 2
d1626 6
a1631 3
    if ( mySize >= AllocateLogLimit ) &
      write( AllocateLogUnit, * ) trim(ItsName), ' _d_ ', &
        & mySize, trim(snipRCSfrom(ModuleNameIn))
d1641 1
a1641 1
    real                              :: p
d1651 1
a1651 1
       "$Id: Allocate_Deallocate.f90,v 2.47 2014/08/06 23:18:04 vsnyder Exp $"
d1661 5
@


2.47
log
@Add option controlled by private parameter to fill REAL arrays with sNaN
@
text
@d128 5
d173 8
d203 2
a204 2
  real, save, public  :: MEMORY_UNITS = 1024. ! Report nothing smaller than KB
  double precision, save, public :: NoBytesAllocated=0.0d0 ! Number of MEMORY_UNITS allocated.
a213 10
  interface ReportAllocateDeallocate
    module procedure ReportAllocateDeallocate_ints
    module procedure ReportAllocateDeallocate_real
  end interface

  interface Test_Deallocate
    module procedure Test_Deallocate_int_s
    module procedure Test_Deallocate_real_s
  end interface

d249 1
a249 1
    call DumpSize ( abs ( noBytes ), units=MEMORY_UNITS )
d260 1
a260 1
    call DumpSize ( noBytesAllocated, units=MEMORY_UNITS, advance='yes' )
d269 3
a271 3
  ! ----------------------------------------------  Test_Allocate  -----
  subroutine Test_Allocate ( Status, ModuleNameIn, ItsName, lBounds, uBounds, &
    & ElementSize )
d275 1
a275 1
  ! and > 0.  
d280 1
d285 1
a285 1
    if ( status /= 0 .or. present(lbounds) .and. present(ubounds) .and. &
d288 7
a294 3
      if ( present(lbounds) .and. present(ubounds) ) then
        write ( bounds, '("(",i0,":",i0, 6(:",",i0,":",i0))' ) &
          & ( lBounds(i), uBounds(i), i = 1, size(lBounds) )
d302 6
a307 2
      if ( status /= 0 ) &
        & call myMessage ( MLSMSG_Error, moduleNameIn, &
d309 1
d316 1
a316 1
    if ( present(lbounds) .and. present(ubounds) .and. present(elementSize) ) then
d318 6
a323 1
        amount = memproduct(elementSize, ubounds-lbounds+1)
d335 1
a335 1
  end subroutine Test_Allocate
d337 8
a344 3
  ! --------------------------------------------  Test_DeAllocate_int_s  -----
  subroutine Test_DeAllocate_int_s ( Status, ModuleNameIn, ItsName, Size )
  ! Test the status from a deallocate.  If it's nonzero, issue a message.
d347 12
a358 3
    integer, intent(in) :: Size ! in MEMORY_UNITS, <= 0 for no tracking
    call Test_Deallocate( Status, ModuleNameIn, ItsName, real(Size) )
  end subroutine Test_DeAllocate_int_s
d360 2
a361 2
  ! --------------------------------------------  Test_Deallocate_real_s  -----
  subroutine Test_Deallocate_real_s ( Status, ModuleNameIn, ItsName, Size )
d368 1
a368 1
    real, intent(in), optional :: Size ! in MEMORY_UNITS, <= 0 for no tracking
d394 1
a394 1
  end subroutine Test_Deallocate_real_s
d1589 3
a1591 3
    character(len=*), intent(in) :: ModuleNameIn, ItsName
    real, intent(in), optional   :: Size
    real :: mySize
d1609 1
a1609 1
    p = ( real(elementSize) / MEMORY_UNITS ) * product(real(dimensions))
d1617 1
a1617 1
       "$Id: Allocate_Deallocate.f90,v 2.46 2014/06/30 23:24:17 pwagner Exp $"
d1627 3
@


2.46
log
@Can log allocations/deallocations to separate file
@
text
@d31 2
d171 3
d549 3
d564 3
d578 3
d594 3
d608 3
d625 3
d639 3
d794 3
d809 3
d823 3
d839 3
d853 3
d870 3
d884 3
d1585 1
a1585 1
       "$Id: Allocate_Deallocate.f90,v 2.45 2014/05/29 18:20:27 pwagner Exp $"
d1595 3
@


2.45
log
@Extra debugging possibility
@
text
@d172 2
d293 2
d343 1
d1492 29
d1538 1
a1538 1
       "$Id: Allocate_Deallocate.f90,v 2.44 2014/01/09 00:25:06 pwagner Exp $"
d1548 3
@


2.44
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d185 2
a186 1

d262 1
d301 3
d324 1
d345 3
d1504 1
a1504 1
       "$Id: Allocate_Deallocate.f90,v 2.43 2013/10/09 01:02:05 vsnyder Exp $"
d1514 3
@


2.43
log
@Add SnipRCSFromName to MyMessage
@
text
@d34 1
a34 1
  use Track_m, only: TRACKALLOCATE, TRACKDEALLOCATE
d219 2
a220 1
    use Output_m, only: OUTPUT, DUMPSIZE
d1495 1
a1495 1
       "$Id: Allocate_Deallocate.f90,v 2.42 2013/08/28 00:38:17 pwagner Exp $"
d1505 3
@


2.42
log
@Added a local version of MyMessage to evade possible circular dependency
@
text
@d33 1
a33 1
    & MLSMSG_ERROR, MLSMSG_WARNING, PRINTITOUT
d1212 2
a1213 2
  ! ------------------------------------  myMessage  -----
  subroutine myMessage ( severity, name, line, advance )
d1218 1
a1218 3
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
d1226 3
a1228 3
      nChars = len(line) + len(name) + 3
      thus = '(' // trim(name) // ') ' // line
    endif
d1233 1
a1233 1
    endif
d1494 1
a1494 1
       "$Id: Allocate_Deallocate.f90,v 2.41 2013/08/16 02:05:34 vsnyder Exp $"
d1504 3
@


2.41
log
@Make Same_Shape public (oops), add Same_Shape..._a versions
@
text
@d32 3
a34 3
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    & MLSMSG_Error, MLSMSG_Warning
  use Track_m, only: TrackAllocate, TrackDeallocate
d285 1
a285 1
        & call MLSMessage ( MLSMSG_Error, moduleNameIn, &
d326 1
a326 1
      call MLSMessage ( MLSMSG_Warning, moduleNameIn, &
d1212 26
d1496 1
a1496 1
       "$Id: Allocate_Deallocate.f90,v 2.40 2013/08/16 01:06:22 vsnyder Exp $"
d1506 3
@


2.40
log
@Add Same_Shape
@
text
@d41 1
a41 1
    & Test_Allocate, Test_Deallocate
d130 5
d150 14
d1220 1
a1220 1
    include "Same_Shape_2d.f9h"
d1225 1
a1225 1
    include "Same_Shape_3d.f9h"
d1235 1
a1235 1
    include "Same_Shape_2d.f9h"
d1240 1
a1240 1
    include "Same_Shape_3d.f9h"
d1250 1
a1250 1
    include "Same_Shape_2d.f9h"
d1255 1
a1255 1
    include "Same_Shape_3d.f9h"
d1265 1
a1265 1
    include "Same_Shape_2d.f9h"
d1270 1
a1270 1
    include "Same_Shape_3d.f9h"
d1275 1
a1275 1
    include "Same_Shape_4d.f9h"
d1285 1
a1285 1
    include "Same_Shape_2d.f9h"
d1290 1
a1290 1
    include "Same_Shape_3d.f9h"
d1295 1
a1295 1
    include "Same_Shape_4d.f9h"
d1305 1
a1305 1
    include "Same_Shape_2d.f9h"
d1310 1
a1310 1
    include "Same_Shape_3d.f9h"
d1320 1
a1320 1
    include "Same_Shape_2d.f9h"
d1325 1
a1325 1
    include "Same_Shape_3d.f9h"
d1330 1
a1330 1
    include "Same_Shape_4d.f9h"
d1332 120
d1470 1
a1470 1
       "$Id: Allocate_Deallocate.f90,v 2.39 2013/06/12 02:50:45 vsnyder Exp $"
d1480 3
@


2.39
log
@Repair a couple of harmless but ugly blunders
@
text
@d126 21
d1193 121
d1331 1
a1331 1
       "$Id: Allocate_Deallocate.f90,v 2.38 2013/06/12 02:17:03 vsnyder Exp $"
d1341 3
@


2.38
log
@Add and use BYTES and BYTE_SIZE
@
text
@d978 1
a978 2
    real, parameter :: B = 0.0 ! Intel 13.0.1 doesn't like storage_size(a)
    byte_size = ( ( storage_size(b) + 7 ) / 8 ) * size(a)
d1028 1
a1028 1
!     bytes = ( ( storage_size(b) + 7 ) / 8 )
d1036 1
a1036 1
!     bytes = ( ( storage_size(b) + 7 ) / 8 )
d1044 1
a1044 1
!     bytes = ( ( storage_size(b) + 7 ) / 8 )
d1189 1
a1189 1
       "$Id: Allocate_Deallocate.f90,v 2.37 2011/03/02 01:59:07 vsnyder Exp $"
d1199 3
@


2.37
log
@Make lbounds and ubounds arguments of Test_Allocate optional
@
text
@d39 1
a39 1
  public :: ALLOCATE_TEST, DEALLOCATE_TEST, DEALLOC_STATUS, & 
d89 37
d134 1
a134 1
  integer, parameter, public :: E_Ch = 1 ! Character
d136 1
a136 1
  integer, parameter, public :: E_Def = (bit_size(e_ch) + 7 ) / 8
a313 1
    integer, parameter :: ESize = E_ch
a325 1
    integer, parameter :: ESize = E_ch
d328 11
a349 1
    integer, parameter :: ESize = E_ch
a351 12
  ! -------------------------------  Allocate_Test_Character_2d_a  -----
  subroutine Allocate_Test_Character_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    character(len=*), pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)    ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! default 1
    character(len=*), intent(in), optional :: Fill ! To fill allocated array
    character(len=1), parameter :: Default = ''
    integer, parameter :: ESize = E_ch
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_Character_2d_a
a360 1
    integer, parameter :: ESize = E_ch
a371 1
    integer, parameter :: ESize = 2 * e_def
a383 1
    integer, parameter :: ESize = 2 * e_def
d386 11
a407 1
    integer, parameter :: ESize = 2 * e_def
a409 12
  ! ---------------------------------  Allocate_Test_Complex_2d_a  -----
  subroutine Allocate_Test_Complex_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    complex, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! default 1
    complex, intent(in), optional :: Fill ! To fill allocated array
    complex, parameter :: Default = (0.0,0.0)
    integer, parameter :: ESize = 2 * e_def
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_Complex_2d_a
a418 1
    integer, parameter :: ESize = 3 * e_def
a429 1
    integer, parameter :: ESize = 2 * e_dp
a441 1
    integer, parameter :: ESize = 2 * e_dp
d444 11
a465 1
    integer, parameter :: ESize = 2 * e_dp
a467 12
  ! --------------------------------  Allocate_Test_DComplex_2d_a  -----
  subroutine Allocate_Test_DComplex_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    complex(kind(0.0d0)), pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! default 1
    complex(kind(0.0d0)), intent(in), optional :: Fill ! To fill allocated array
    complex(kind(0.0d0)), parameter :: Default = (0.0d0,0.0d0)
    integer, parameter :: ESize = 2 * e_dp
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_DComplex_2d_a
a476 1
    integer, parameter :: ESize = 3 * e_dp
a487 1
    integer, parameter :: ESize = E_dp
a499 1
    integer, parameter :: ESize = E_dp
d502 11
a523 1
    integer, parameter :: ESize = E_dp
d526 11
a548 1
    integer, parameter :: ESize = E_dp
a550 24
  ! ----------------------------------  Allocate_Test_RealR8_2d_a  -----
  subroutine Allocate_Test_RealR8_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    double precision, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    integer, parameter :: ESize = E_dp
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_RealR8_2d_a
  ! ----------------------------------  Allocate_Test_RealR8_3d_a  -----
  subroutine Allocate_Test_RealR8_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    double precision, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! Low bounds for dimensions
    double precision, intent(in), optional :: Fill
    double precision, parameter :: Default = 0.0d0
    integer, parameter :: ESize = E_dp
    include "Allocate_Test_3D_a.f9h"
  end subroutine Allocate_Test_RealR8_3d_a
a559 1
    integer, parameter :: ESize = E_dp
a570 1
    integer, parameter :: ESize = E_def
a582 1
    integer, parameter :: ESize = E_def
d585 11
a606 1
    integer, parameter :: ESize = E_def
d609 11
a631 1
    integer, parameter :: ESize = E_def
a633 24
  ! ---------------------------------  Allocate_Test_Integer_2d_a  -----
  subroutine Allocate_Test_Integer_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    integer, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! default 1
    integer, intent(in), optional :: Fill ! To fill allocated array
    integer, parameter :: Default = 0
    integer, parameter :: ESize = E_def
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_Integer_2d_a
  ! ---------------------------------  Allocate_Test_Integer_3d_a  -----
  subroutine Allocate_Test_Integer_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    integer, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! default 1
    integer, intent(in), optional :: Fill ! To fill allocated array
    integer, parameter :: Default = 0
    integer, parameter :: ESize = E_def
    include "Allocate_Test_3D_a.f9h"
  end subroutine Allocate_Test_Integer_3d_a
a642 1
    integer, parameter :: ESize = E_def
a653 1
    integer, parameter :: ESize = E_def
a665 1
    integer, parameter :: ESize = e_def
d668 11
a689 1
    integer, parameter :: ESize = e_def
a691 12
  ! ---------------------------------  Allocate_Test_Logical_2d_a  -----
  subroutine Allocate_Test_Logical_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    logical, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! Lower bounds, default 1
    logical, intent(in), optional :: Fill ! To fill allocated array
    logical, parameter :: Default = .false.
    integer, parameter :: ESize = E_def
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_Logical_2d_a
a700 1
    integer, parameter :: ESize = E_def
a711 1
    integer, parameter :: ESize = e_def
a723 1
    integer, parameter :: ESize = e_def
d726 11
a747 1
    integer, parameter :: ESize = e_def
d750 11
a772 1
    integer, parameter :: ESize = e_def
a774 24
  ! ------------------------------------  Allocate_Test_RealR4_2d_a  -----
  subroutine Allocate_Test_RealR4_2d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    real, pointer, dimension(:,:) :: To_Allocate
    integer, intent(in) :: Dim(2)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(2) ! Low bounds, default 1
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    integer, parameter :: ESize = e_def
    include "Allocate_Test_2D_a.f9h"
  end subroutine Allocate_Test_RealR4_2d_a
  ! ------------------------------------  Allocate_Test_RealR4_3d_a  -----
  subroutine Allocate_Test_RealR4_3d_a ( To_Allocate, Dim, &
    & ItsName, ModuleName, Low, Fill )
    real, pointer, dimension(:,:,:) :: To_Allocate
    integer, intent(in) :: Dim(3)  ! Upper bounds of To_Allocate
    character(len=*), intent(in) :: ItsName, ModuleName
    integer, intent(in), optional :: Low(3) ! Low bounds, default 1
    real, intent(in), optional :: Fill
    real, parameter :: Default = 0.0
    integer, parameter :: ESize = e_def
    include "Allocate_Test_3D_a.f9h"
  end subroutine Allocate_Test_RealR4_3d_a
a783 1
    integer, parameter :: ESize = e_def
a788 1
    integer, parameter :: ESize = e_ch
a793 1
    integer, parameter :: ESize = e_ch
a798 1
    integer, parameter :: ESize = e_ch
a803 1
    integer, parameter :: ESize = 2 * e_def
a808 1
    integer, parameter :: ESize = 2 * e_def
a813 1
    integer, parameter :: ESize = 2 * e_def
a818 1
    integer, parameter :: ESize = 2 * e_dp
a823 1
    integer, parameter :: ESize = 2 * e_dp
a828 1
    integer, parameter :: ESize = 2 * e_dp
a833 1
    integer, parameter :: ESize = e_dp
a838 1
    integer, parameter :: ESize = e_dp
a843 1
    integer, parameter :: ESize = e_dp
a848 1
    integer, parameter :: ESize = e_dp
a853 1
    integer, parameter :: ESize = e_def
a858 1
    integer, parameter :: ESize = e_def
a863 1
    integer, parameter :: ESize = e_def
a868 1
    integer, parameter :: ESize = e_def
a873 1
    integer, parameter :: ESize = e_def
a878 1
    integer, parameter :: ESize = e_def
a883 1
    integer, parameter :: ESize = e_def
a888 1
    integer, parameter :: ESize = e_def
a893 1
    integer, parameter :: ESize = e_def
a898 1
    integer, parameter :: ESize = e_def
a903 1
    integer, parameter :: ESize = e_def
d907 266
d1190 1
a1190 1
       "$Id: Allocate_Deallocate.f90,v 2.36 2009/06/23 18:25:42 pwagner Exp $"
d1200 3
@


2.36
log
@Prevent Intel from optimizing ident string away
@
text
@d188 1
a188 1
    integer, intent(in) :: Lbounds(:), Ubounds(:)
d194 2
a195 1
    if ( status /= 0 .or. present(elementSize) .and. trackAllocates >= 2 ) then
d197 10
a206 6
      write ( bounds, '("(",i0,":",i0, 6(:",",i0,":",i0))' ) &
        & ( lBounds(i), uBounds(i), i = 1, size(lBounds) )
      l = len_trim(bounds)+1
      bounds(l:l)= ')'
      write ( bounds(l+1:), '(", status = ", i0)' ) status
      l = len_trim(bounds)
d214 1
a214 1
    if ( present(elementSize) ) then
d952 1
a952 1
       "$Id: read_apriori.f90 is it here $"
d962 3
@


2.35
log
@Add allocation routines with arrays for bounds
@
text
@d944 1
d946 3
a948 5
  !------------------------------- RCS Ident Info ------------------------------
  character(len=*), parameter :: Idparm = &
    & "$Id: Allocate_Deallocate.f90,v 2.34 2008/05/20 01:59:28 vsnyder Exp $"
  character(len=len(idparm)) :: Id = idparm
  !-----------------------------------------------------------------------------
d950 1
d952 1
d957 3
@


2.34
log
@Add 4d integer, real, double
@
text
@d44 2
a45 2
    module procedure ALLOCATE_TEST_CHARACTER_1D
    module procedure ALLOCATE_TEST_CHARACTER_2D
d47 1
a47 2
    module procedure ALLOCATE_TEST_COMPLEX_1D
    module procedure ALLOCATE_TEST_COMPLEX_2D
d49 1
a49 2
    module procedure ALLOCATE_TEST_DCOMPLEX_1D
    module procedure ALLOCATE_TEST_DCOMPLEX_2D
d59 11
d73 1
a73 2
    module procedure DEALLOCATE_TEST_CHARACTER_1D
    module procedure DEALLOCATE_TEST_CHARACTER_2D
d75 1
a75 2
    module procedure DEALLOCATE_TEST_COMPLEX_1D
    module procedure DEALLOCATE_TEST_COMPLEX_2D
d77 1
a77 2
    module procedure DEALLOCATE_TEST_DCOMPLEX_1D
    module procedure DEALLOCATE_TEST_DCOMPLEX_2D
d302 24
d329 1
a329 1
    Complex, pointer, dimension(:) :: To_Allocate
d333 2
a334 2
    Complex, intent(in), optional :: Fill
    Complex, parameter :: Default = (0.0,0.0)
d341 1
a341 1
    Complex, pointer, dimension(:,:) :: To_Allocate
d346 2
a347 2
    Complex, intent(in), optional :: Fill ! To fill allocated array
    Complex, parameter :: Default = (0.0,0.0)
d354 1
a354 1
    Complex, pointer, dimension(:,:,:) :: To_Allocate
d360 2
a361 2
    Complex, intent(in), optional :: Fill ! To fill allocated array
    Complex, parameter :: Default = (0.0,0.0)
d365 24
d392 1
a392 1
    Complex(kind(0.0d0)), pointer, dimension(:) :: To_Allocate
d396 2
a397 2
    Complex(kind(0.0d0)), intent(in), optional :: Fill
    Complex(kind(0.0d0)), parameter :: Default = (0.0d0,0.0d0)
d404 1
a404 1
    Complex(kind(0.0d0)), pointer, dimension(:,:) :: To_Allocate
d409 2
a410 2
    Complex(kind(0.0d0)), intent(in), optional :: Fill ! To fill allocated array
    Complex(kind(0.0d0)), parameter :: Default = (0.0d0,0.0d0)
d428 24
d506 36
d596 36
d671 24
d749 36
d947 1
a947 1
    & "$Id: Allocate_Deallocate.f90,v 2.33 2007/07/27 00:19:30 vsnyder Exp $"
d956 3
@


2.33
log
@Better printing in Test_[De]Allocate, work on memory tracking
@
text
@d54 1
a54 1
    module procedure ALLOCATE_TEST_INTEGER_3D
d58 1
a58 1
    module procedure ALLOCATE_TEST_REALR4_3D
d60 1
a60 1
    module procedure ALLOCATE_TEST_REALR8_3D
d74 1
a74 1
    module procedure DEALLOCATE_TEST_INTEGER_3D
d78 1
a78 1
    module procedure DEALLOCATE_TEST_REALR4_3D
d80 1
a80 1
    module procedure DEALLOCATE_TEST_REALR8_3D
d413 15
d467 15
d560 15
d647 6
d671 6
d713 6
d737 1
a737 1
    & "$Id: Allocate_Deallocate.f90,v 2.32 2006/08/05 02:36:57 vsnyder Exp $"
d746 3
@


2.32
log
@Pass bounds argument of ReportAllocateDeallocate_ints forward
@
text
@d190 1
a190 1
      write ( bounds, '("(",i0,":",i0, 2(:",",i0,":",i0))' ) &
d194 2
d234 2
d237 1
d239 1
a239 1
        & MLSMSG_DeAllocate // itsName )
d666 1
a666 1
    p = ( elementSize / MEMORY_UNITS ) * product(real(dimensions))
d674 1
a674 1
    & "$Id: Allocate_Deallocate.f90,v 2.31 2006/08/04 18:12:56 vsnyder Exp $"
d683 3
@


2.31
log
@Add 'bounds' to ReportAlllocateDeallocate, don't look at ElementSize if it's not present
@
text
@d131 1
a131 1
    call ReportAllocateDeallocate( name, moduleName, real(noBytes) )
d669 1
a669 1
    & "$Id: Allocate_Deallocate.f90,v 2.30 2006/07/29 03:01:07 vsnyder Exp $"
d678 3
@


2.30
log
@Use track_m stuff
@
text
@d124 1
a124 1
  subroutine ReportAllocateDeallocate_ints ( name, moduleName, noBytes )
d129 2
a130 1
    !
d135 1
a135 1
  subroutine ReportAllocateDeallocate_real ( name, moduleName, noBytes )
d141 1
d155 3
a157 1
    call output ( ' for ' // trim ( name ) // ' in ' )
d188 1
a188 1
    if ( status /= 0 ) then
d194 3
a196 2
      call MLSMessage ( MLSMSG_Error, moduleNameIn, &
        & MLSMSG_Allocate // ItsName  // bounds(:l) )
d201 8
a208 6
    if ( elementSize > 0 ) then
      amount = memproduct(elementSize, ubounds-lbounds+1)
      if ( trackAllocates >= 2 .and. present(elementSize) ) then
        call ReportAllocateDeallocate ( itsName, moduleNameIn, amount )
      else
        noBytesAllocated = noBytesAllocated + amount
d669 1
a669 1
    & "$Id: Allocate_Deallocate.f90,v 2.29 2006/07/28 01:57:25 vsnyder Exp $"
d678 3
@


2.29
log
@Use real() instead of *1.0 to convert to real
@
text
@d34 1
d86 3
a88 3
  logical, public :: TRACKALLOCATES = .false. ! If true keep track of memory allocated
                                              ! and print every transaction
  ! and report on it.
d142 1
a142 1
    if ( .not. trackAllocates ) return        ! Most probably will not be called anyway
d174 1
a174 1
  ! Track allocations if TrackAllocates is true and ElementSize is present
d198 1
a198 1
      if ( trackAllocates .and. present(elementSize) ) then
a209 2
  ! Do garbage collection if Collect_garbage_each_time is true.
  ! Track deallocations if TrackAllocates is true and Size is present and > 0.
d220 1
a220 1
  ! Track deallocations if TrackAllocates is true and Size is present and > 0.
d234 1
a234 1
        if ( trackAllocates ) then
d662 1
a662 1
    & "$Id: Allocate_Deallocate.f90,v 2.28 2006/07/19 22:24:18 vsnyder Exp $"
d671 3
@


2.28
log
@Track memory usage even if not reporting, for trace_m
@
text
@d129 1
a129 1
    call ReportAllocateDeallocate( name, moduleName, noBytes*1.0 )
d214 1
a214 1
    call Test_Deallocate( Status, ModuleNameIn, ItsName, Size*1.0 )
d655 1
a655 1
    p = ( elementSize / MEMORY_UNITS ) * product(dimensions*1.0)
d663 1
a663 1
    & "$Id: Allocate_Deallocate.f90,v 2.27 2005/12/16 23:25:37 pwagner Exp $"
d672 3
@


2.27
log
@dumpSize moved from dump0 to output_m
@
text
@d84 1
d86 1
a86 1
  logical, public :: CLEARONALLOCATE = .false. ! If true, zero all allocated stuff
d100 1
a100 1
  real, save, private :: NoBytesAllocated=0. ! Number of MEMORY_UNITS allocated.
d145 1
a145 1
    if ( noBytes < 0. ) then
d179 1
d193 9
a201 4
    if ( trackAllocates .and. present(elementSize) ) then
      if ( elementSize > 0 ) &
        & call ReportAllocateDeallocate ( itsName, moduleNameIn, &
          & memproduct(elementSize, ubounds-lbounds+1) )
d233 8
a240 3
    if ( status == 0 .and. trackAllocates .and. present(size) ) then
      if ( size > 0. ) &
        & call ReportAllocateDeallocate ( itsName, moduleNameIn, -size )
d663 1
a663 1
    & "$Id: Allocate_Deallocate.f90,v 2.26 2005/11/18 21:09:35 vsnyder Exp $"
d672 3
@


2.26
log
@Don't print trailing comma after last dimension in allocation failure message
@
text
@d133 1
a133 2
    use Output_m, only: OUTPUT
    use Dump_0, only: DUMPSIZE
d651 1
a651 1
    & "$Id: Allocate_Deallocate.f90,v 2.25 2005/10/03 18:04:51 pwagner Exp $"
d660 3
@


2.25
log
@Allocated memory now tracked in units of MEMORY_UNITS
@
text
@d184 1
a184 1
      write ( bounds, '("(",i0,":",i0, 2(",",i0,":",i0))' ) &
d652 1
a652 1
    & "$Id: Allocate_Deallocate.f90,v 2.24 2005/09/16 23:38:20 vsnyder Exp $"
d661 3
@


2.24
log
@Add Complex allocators
@
text
@d96 6
d108 10
d121 12
a132 2
  !-----------------------------------   ReportAllocateDeallocate  -----
  subroutine ReportAllocateDeallocate ( name, moduleName, noBytes )
d138 1
a138 3
    integer, intent(in) :: noBytes      ! No bytes allocated (or deallocated if -ve)

    integer, save :: NoBytesAllocated=0 ! Number of bytes allocated.
d142 1
d145 1
a145 1
    if ( noBytes < 0 ) then
d151 1
a151 1
    call DumpSize ( abs ( noBytes ) )
d160 2
a161 2
    call DumpSize ( noBytesAllocated, advance='yes' )
  end subroutine ReportAllocateDeallocate
d183 2
a184 1
      write ( bounds, '("(",i0,":",i0:(",",i0,":",i0))' ) &
d195 1
a195 1
          & elementSize*product(ubounds-lbounds+1) )
d200 2
a201 2
  ! --------------------------------------------  Test_DeAllocate  -----
  subroutine Test_DeAllocate ( Status, ModuleNameIn, ItsName, Size )
d207 12
a218 1
    integer, intent(in), optional :: Size ! Bytes, <= 0 for no tracking
d228 1
a228 1
      if ( size > 0 ) &
d232 1
a232 1
  end subroutine Test_DeAllocate
d635 13
d652 1
a652 1
    & "$Id: Allocate_Deallocate.f90,v 2.23 2005/07/20 16:22:52 pwagner Exp $"
d661 3
@


2.23
log
@Declared undeclared variable L; compiles successfully
@
text
@d27 2
a28 1
! *****     be declared with => NULL()         *****
d46 6
d66 6
d237 78
d489 36
d602 1
a602 1
    & "$Id: Allocate_Deallocate.f90,v 2.22 2005/07/20 01:32:55 vsnyder Exp $"
d611 3
@


2.22
log
@Add Test_Allocate and Test_Deallocate.  Regularize routines.  All now have an
optional Fill argument.  For a given rank, calling sequences are the same
(modulo types), including argument names.  Add [De]Allocate_Test_Logical_3d.
Move guts of [De]Allocate_Test* into include files.
@
text
@d142 1
a142 1
    integer :: I
d475 1
a475 1
    & "$Id: Allocate_Deallocate.f90,v 2.21 2005/06/03 01:53:06 vsnyder Exp $"
d484 6
@


2.21
log
@New copyright notice, move Id to not_used_here to avoid cascades
@
text
@d38 2
a39 4
    & SET_GARBAGE_COLLECTION, REPORTALLOCATEDEALLOCATE

  integer, save :: DEALLOC_STATUS = 0
  logical, save :: COLLECT_GARBAGE_EACH_TIME = .false.
d48 1
d62 1
d69 2
d75 7
a81 1
  integer, private, save :: NOWORDSALLOCATED=0 ! Number of 4 byte words allocated.
d90 4
a93 2
  ! =====     Public Procedures      ============================
  subroutine ReportAllocateDeallocate ( name, moduleName, noWords )
d99 4
a102 1
    integer, intent(in) :: NOWORDS      ! No words allocated (or deallocated if -ve)
d105 1
a105 1
    noWordsAllocated = noWordsAllocated + noWords
d107 1
a107 1
    if ( noWords < 0 ) then
d113 1
a113 1
    call DumpSize ( abs ( noWords*4.0 ) )
d122 1
a122 1
    call DumpSize ( noWordsAllocated*4.0, advance='yes' )
d124 61
a184 2
    
  ! =====     Private Procedures     ============================
d186 2
a187 2
  subroutine Allocate_Test_Character_1d ( To_Allocate, Dim1, Its_Name, &
    & ModuleName, LowBound )
d190 1
a190 1
    character(len=*), intent(in) :: Its_Name, ModuleName
d192 4
a195 9
    integer :: MY_LOW, STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    my_low = 1
    if ( present(lowBound) ) my_low = lowBound
    allocate ( To_Allocate(my_low:dim1), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(1,dim1)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = ' '
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, dim1/4+1 )
d198 2
a199 2
  subroutine Allocate_Test_Character_2d ( To_Allocate, Dim1, Dim2, Its_Name, &
    & ModuleName )
d202 7
a208 9
    integer, intent(in) :: Dim2    ! Second dimension of To_Allocate
    character(len=*), intent(in) :: Its_Name, ModuleName
    integer :: STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    allocate ( To_Allocate(dim1,dim2), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(1,dim1,1,dim2)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = ' '
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, (dim1*dim2)/4+1 )
d212 1
a212 1
    & Its_Name, ModuleName )
d215 8
a222 10
    integer, intent(in) :: Dim2    ! Second dimension of To_Allocate
    integer, intent(in) :: Dim3    ! Third dimension of To_Allocate
    character(len=*), intent(in) :: Its_Name, ModuleName
    integer :: STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    allocate ( To_Allocate(dim1,dim2,dim3), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(1,dim1,1,dim2,1,dim3)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = ' '
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, (dim1*dim2*dim3)/4+1 )
d225 2
a226 2
  subroutine Allocate_Test_RealR8_1d ( To_Allocate, Dim1, Its_Name, &
    & ModuleName, LowBound )
d229 1
a229 1
    character(len=*), intent(in) :: Its_Name, ModuleName
d231 4
a234 9
    integer :: MY_LOW, STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    my_low = 1
    if ( present(lowBound) ) my_low = lowBound
    allocate ( To_Allocate(my_low:dim1), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(my_low,dim1)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0d0
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, 2*dim1 )
d237 2
a238 2
  subroutine Allocate_Test_RealR8_2d ( To_Allocate, Dim1, Dim2, Its_Name, &
    & ModuleName, Low1, Low2 )
d240 3
a242 3
    integer, intent(in) :: Dim1    ! First dimension of To_Allocate
    integer, intent(in) :: Dim2    ! Second dimension of To_Allocate
    character(len=*), intent(in) :: Its_Name, ModuleName
d244 4
a247 11
    integer :: MyLow1, MyLow2
    integer :: STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    myLow1 = 1; myLow2 = 1
    if ( present(low1) ) myLow1 = low1
    if ( present(low2) ) myLow2 = low2
    allocate ( To_Allocate(myLow1:dim1,myLow2:dim2), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(myLow1,dim1,myLow2,dim2)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0d0
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, 2*dim1*dim2 )
d251 1
a251 1
    & Its_Name, ModuleName, Low1, Low2, Low3 )
d253 4
a256 4
    integer, intent(in) :: Dim1    ! First dimension of To_Allocate
    integer, intent(in) :: Dim2    ! Second dimension of To_Allocate
    integer, intent(in) :: Dim3    ! Third dimension of To_Allocate
    character(len=*), intent(in) :: Its_Name, ModuleName
d258 4
a261 12
    integer :: MyLow1, MyLow2, MyLow3
    integer :: STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    myLow1 = 1; myLow2 = 1; myLow3 = 1
    if ( present(low1) ) myLow1 = low1
    if ( present(low2) ) myLow2 = low2
    if ( present(low3) ) myLow3 = low3
    allocate ( To_Allocate(myLow1:dim1,myLow2:dim2,myLow3:dim3), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(myLow1,dim1,myLow2,dim2,myLow3,dim3)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0d0
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, 2*dim1*dim2*dim3 )
d264 2
a265 2
  subroutine Allocate_Test_Integer_1d ( To_Allocate, Dim1, Its_Name, &
    & ModuleName, LowBound, Fill )
d268 1
a268 1
    character(len=*), intent(in) :: Its_Name, ModuleName
d271 3
a273 13
    integer :: MY_LOW, STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    my_low = 1
    if ( present(lowBound) ) my_low = lowBound
    allocate ( To_Allocate(my_low:dim1), stat=status )
    if ( status /= 0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate // Its_Name // trim(bounds(lowBound,dim1)) )
    else
      if ( clearOnAllocate ) to_allocate = 0
      if ( present(fill) ) to_allocate = fill
    end if
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, dim1 )
d276 2
a277 2
  subroutine Allocate_Test_Integer_2d ( To_Allocate, Dim1, Dim2, Its_Name, &
    & ModuleName, LowBound_1, LowBound_2, Fill )
d279 4
a282 4
    integer, intent(in) :: Dim1    ! First dimension of To_Allocate
    integer, intent(in) :: Dim2    ! Second dimension of To_Allocate
    character(len=*), intent(in) :: Its_Name, ModuleName
    integer, intent(in), optional :: LowBound_1, LowBound_2 ! default 1
d284 3
a286 15
    integer :: MY_LOW_1, MY_LOW_2, STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    my_low_1 = 1
    if ( present(lowBound_1) ) my_low_1 = lowBound_1
    my_low_2 = 1
    if ( present(lowBound_2) ) my_low_2 = lowBound_2
    allocate ( To_Allocate(my_low_1:dim1,my_low_2:dim2), stat=status )
    if ( status /= 0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate // Its_Name // trim(bounds(my_low_1,dim1,my_low_2,dim2)) )
    else
      if ( clearOnAllocate ) to_allocate = 0
      if ( present(fill) ) to_allocate = fill
    end if
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, dim1*dim2 )
d289 2
a290 2
  subroutine Allocate_Test_Integer_3d ( To_Allocate, Dim1, Dim2, Dim3, Its_Name, &
    & ModuleName, LowBound_1, Fill )
d292 5
a296 5
    integer, intent(in) :: Dim1    ! First dimension of To_Allocate
    integer, intent(in) :: Dim2    ! Second dimension of To_Allocate
    integer, intent(in) :: Dim3    ! Third dimension of To_Allocate
    character(len=*), intent(in) :: Its_Name, ModuleName
    integer, intent(in), optional :: LowBound_1 ! default 1
d298 3
a300 13
    integer :: MY_LOW_1, STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    my_low_1 = 1
    if ( present(lowBound_1) ) my_low_1 = lowBound_1
    allocate ( To_Allocate(my_low_1:dim1,dim2,dim3), stat=status )
    if ( status /= 0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate // Its_Name // trim(bounds(my_low_1,dim1,1,dim2,1,dim3)) )
    else
      if ( clearOnAllocate ) to_allocate = 0
      if ( present(fill) ) to_allocate = fill
    end if
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, dim1*dim2*dim3 )
d303 2
a304 2
  subroutine Allocate_Test_Logical_1d ( To_Allocate, Dim1, Its_Name, &
    & ModuleName, LowBound )
d307 1
a307 1
    character(len=*), intent(in) :: Its_Name, ModuleName
d309 4
a312 9
    integer :: MY_LOW, STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    my_low = 1
    if ( present(lowBound) ) my_low = lowBound
    allocate ( To_Allocate(my_low:dim1), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(lowBound,dim1)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = .false.
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, dim1/4+1 )
d315 2
a316 2
  subroutine Allocate_Test_Logical_2d ( To_Allocate, Dim1, Dim2, Its_Name, &
    & ModuleName, Low1, Low2 )
d318 3
a320 3
    integer, intent(in) :: Dim1    ! First dimension of To_Allocate
    integer, intent(in) :: Dim2    ! Second dimension of To_Allocate
    character(len=*), intent(in) :: Its_Name, ModuleName
d322 4
a325 11
    integer :: MyLow1, MyLow2
    integer :: STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    myLow1 = 1; myLow2 = 1
    if ( present(low1) ) myLow1 = low1
    if ( present(low2) ) myLow2 = low2
    allocate ( To_Allocate(myLow1:dim1,myLow2:dim2), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(myLow1,dim1,myLow2,dim2)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = .false.
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, (dim1*dim2)/4+1 )
d327 14
d342 2
a343 2
  subroutine Allocate_Test_RealR4_1d ( To_Allocate, Dim1, Its_Name, ModuleName, &
    & LowBound )
d346 1
a346 1
    character(len=*), intent(in) :: Its_Name, ModuleName
d348 4
a351 9
    integer :: MY_LOW, STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    my_low = 1
    if ( present(lowBound) ) my_low = lowBound
    allocate ( To_Allocate(my_low:dim1), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(lowBound,dim1)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, dim1 )
d354 2
a355 2
  subroutine Allocate_Test_RealR4_2d ( To_Allocate, Dim1, Dim2, Its_Name, &
    & ModuleName, Low1, Low2 )
d357 3
a359 3
    integer, intent(in) :: Dim1    ! First dimension of To_Allocate
    integer, intent(in) :: Dim2    ! Second dimension of To_Allocate
    character(len=*), intent(in) :: Its_Name, ModuleName
d361 4
a364 11
    integer :: MyLow1, MyLow2
    integer :: STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    myLow1 = 1; myLow2 = 1
    if ( present(low1) ) myLow1 = low1
    if ( present(low2) ) myLow2 = low2
    allocate ( To_Allocate(myLow1:dim1,myLow2:dim2), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(myLow1,dim1,myLow2,dim2)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, dim1*dim2 )
d368 1
a368 1
    & Its_Name, ModuleName, Low1, Low2, Low3 )
d370 4
a373 4
    integer, intent(in) :: Dim1    ! First dimension of To_Allocate
    integer, intent(in) :: Dim2    ! Second dimension of To_Allocate
    integer, intent(in) :: Dim3    ! Third dimension of To_Allocate
    character(len=*), intent(in) :: Its_Name, ModuleName
d375 4
a378 12
    integer :: MyLow1, MyLow2, MyLow3
    integer :: STATUS
    call deallocate_Test ( To_Allocate, Its_Name, ModuleName )
    myLow1 = 1; myLow2 = 1; myLow3 = 1
    if ( present(low1) ) myLow1 = low1
    if ( present(low2) ) myLow2 = low2
    if ( present(low3) ) myLow3 = low3
    allocate ( To_Allocate(myLow1:dim1,myLow2:dim2,myLow3:dim3), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(myLow1,dim1,myLow2,dim2,myLow3,dim3)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0
    if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, dim1*dim2*dim3 )
d381 1
a381 1
  subroutine Deallocate_Test_Character_1d ( To_Deallocate, Its_Name, ModuleName )
d383 2
a384 18
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1/4-1 )
    end if
d387 1
a387 1
  subroutine Deallocate_Test_Character_2d ( To_Deallocate, Its_Name, ModuleName )
d389 2
a390 19
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1, DIM2
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
        dim2 = size ( to_deallocate, 2 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -(dim1*dim2)/4-1 )
    end if
d393 1
a393 1
  subroutine Deallocate_Test_Character_3d ( To_Deallocate, Its_Name, ModuleName )
d395 2
a396 20
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1, DIM2, DIM3
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
        dim2 = size ( to_deallocate, 2 )
        dim3 = size ( to_deallocate, 3 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -(dim1*dim2*dim3)/4-1 )
    end if
d399 1
a399 1
  subroutine Deallocate_Test_RealR8_1d ( To_Deallocate, Its_Name, ModuleName )
d401 2
a402 18
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -2*dim1 )
    end if
d405 1
a405 1
  subroutine Deallocate_Test_RealR8_2d ( To_Deallocate, Its_Name, ModuleName )
d407 2
a408 19
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1, DIM2
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
        dim2 = size ( to_deallocate, 2 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -2*dim1*dim2 )
    end if
d411 1
a411 1
  subroutine Deallocate_Test_RealR8_3d ( To_Deallocate, Its_Name, ModuleName )
d413 2
a414 20
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1, DIM2, DIM3
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
        dim2 = size ( to_deallocate, 2 )
        dim3 = size ( to_deallocate, 3 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -2*dim1*dim2*dim3 )
    end if
d417 1
a417 1
  subroutine Deallocate_Test_Integer_1d ( To_Deallocate, Its_Name, ModuleName )
d419 2
a420 18
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1 )
    end if
d423 1
a423 1
  subroutine Deallocate_Test_Integer_2d ( To_Deallocate, Its_Name, ModuleName )
d425 2
a426 19
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1, DIM2
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
        dim2 = size ( to_deallocate, 2 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2 )
    end if
d429 1
a429 1
  subroutine Deallocate_Test_Integer_3d ( To_Deallocate, Its_Name, ModuleName )
d431 2
a432 20
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1, DIM2, DIM3
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
        dim2 = size ( to_deallocate, 2 )
        dim3 = size ( to_deallocate, 3 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2*dim3 )
    end if
d435 1
a435 1
  subroutine Deallocate_Test_Logical_1d ( To_Deallocate, Its_Name, ModuleName )
d437 2
a438 18
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1/4-1 )
    end if
d440 2
a441 2
  ! ---------------------------------  Deallocate_Test_Logical_1d  -----
  subroutine Deallocate_Test_Logical_2d ( To_Deallocate, Its_Name, ModuleName )
d443 2
a444 19
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1, DIM2
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
        dim2 = size ( to_deallocate, 2 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -(dim1*dim2)/4-1 )
    end if
d446 6
d453 1
a453 1
  subroutine Deallocate_Test_RealR4_1d ( To_Deallocate, Its_Name, ModuleName )
d455 2
a456 18
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1 )
    end if
d459 1
a459 1
  subroutine Deallocate_Test_RealR4_2d ( To_Deallocate, Its_Name, ModuleName )
d461 2
a462 19
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1, DIM2
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
        dim2 = size ( to_deallocate, 2 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2 )
    end if
d465 1
a465 1
  subroutine Deallocate_Test_RealR4_3d ( To_Deallocate, Its_Name, ModuleName )
d467 2
a468 20
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    integer :: DIM1, DIM2, DIM3
    if ( associated(To_Deallocate) ) then
      if ( trackAllocates ) then
        dim1 = size ( to_deallocate, 1 )
        dim2 = size ( to_deallocate, 2 )
        dim3 = size ( to_deallocate, 3 )
      endif
      deallocate ( To_Deallocate, stat=status )
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_DeAllocate // Its_Name )
        dealloc_status = max(dealloc_status, status)
      else if ( collect_garbage_each_time ) then
        call mls_gc_now
      end if
      nullify ( to_Deallocate )
      if ( trackAllocates ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2*dim3 )
    end if
a470 24
  ! ---------------------------------------  Set_garbage_collection  -----
  subroutine Set_garbage_collection ( setting )
    logical :: setting
    collect_garbage_each_time = setting
  end subroutine Set_garbage_collection

  ! =====  Private Procedures  ===========================================
  ! -------------------------------------------------------  Bounds  -----
  character(127) function Bounds ( Low1, High1, Low2, High2, Low3, High3 )
    integer, intent(in) :: Low1, High1
    integer, intent(in), optional :: Low2, High2, Low3, High3
    character(127) :: Temp
    write ( bounds, '("(",i0,":",i0)' ) low1, high1
    if ( present(low2) ) then
      write ( temp, '(",",i0,":",i0)' ) low2, high2
      bounds = trim(bounds) // temp
    end if
    if ( present(low3) ) then
      write ( temp, '(",",i0,":",i0)' ) low3, high3
      bounds = trim(bounds) // temp
    end if
    bounds = trim(bounds) // ')'
  end function Bounds

d475 1
a475 1
    & "$Id: Allocate_Deallocate.f90,v 2.20 2005/06/01 02:30:30 vsnyder Exp $"
d484 3
@


2.20
log
@Add optional Fill argument to allocate_test_integer_...
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology. ALL RIGHTS RESERVED.
! U.S. Government sponsorship under NASA Contract NAS7407 is acknowledged.
d18 1
a18 1
! for Double precision, Integer and Real arrays of one or two dimensions.
a75 2
  character(len=130), private :: id = & 
       "$Id: Allocate_Deallocate.f90,v 2.19 2004/12/28 00:24:39 vsnyder Exp $"
d735 5
d746 3
@


2.19
log
@Use default REAL and DOUBLE PRECISION because R4 and R8 are not guaranteed
to be different.
@
text
@d69 1
a69 1
       "$Id: Allocate_Deallocate.f90,v 2.18 2004/10/30 00:23:21 vsnyder Exp $"
d216 1
a216 1
    & ModuleName, LowBound )
d221 1
d227 7
a233 3
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(lowBound,dim1)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0
d238 1
a238 1
    & ModuleName, LowBound_1, LowBound_2 )
d244 1
d252 7
a258 3
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(my_low_1,dim1,my_low_2,dim2)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0
d263 1
a263 1
    & ModuleName, LowBound_1 )
d270 1
d276 7
a282 3
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // Its_Name // trim(bounds(my_low_1,dim1,1,dim2,1,dim3)) )
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0
d735 4
@


2.18
log
@Add low_bound1 to Allocate_Test_Integer_3d
@
text
@a22 1
  use MLSCommon, only: r4, r8
d69 1
a69 1
       "$Id: Allocate_Deallocate.f90,v 2.17 2004/10/02 02:42:35 vsnyder Exp $"
d158 1
a158 1
    real (r8), pointer, dimension(:) :: To_Allocate
d169 1
a169 1
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0_r8
d175 1
a175 1
    real (r8), pointer, dimension(:,:) :: To_Allocate
d189 1
a189 1
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0_r8
d195 1
a195 1
    real (r8), pointer, dimension(:,:,:) :: To_Allocate
d211 1
a211 1
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0_r8
d310 1
a310 1
    real (r4), pointer, dimension(:) :: To_Allocate
d321 1
a321 1
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0_r4
d327 1
a327 1
    real (r4), pointer, dimension(:,:) :: To_Allocate
d341 1
a341 1
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0_r4
d347 1
a347 1
    real (r4), pointer, dimension(:,:,:) :: To_Allocate
d363 1
a363 1
    if ( status == 0 .and. clearOnAllocate ) to_allocate = 0.0_r4
d437 1
a437 1
    real (r8), pointer, dimension(:) :: To_Deallocate
d459 1
a459 1
    real (r8), pointer, dimension(:,:) :: To_Deallocate
d482 1
a482 1
    real (r8), pointer, dimension(:,:,:) :: To_Deallocate
d620 1
a620 1
    real (r4), pointer, dimension(:) :: To_Deallocate
d642 1
a642 1
    real (r4), pointer, dimension(:,:) :: To_Deallocate
d665 1
a665 1
    real (r4), pointer, dimension(:,:,:) :: To_Deallocate
d720 3
@


2.17
log
@Add low bounds to Allocate_Test_Integer_2D
@
text
@d70 1
a70 1
       "$Id: Allocate_Deallocate.f90,v 2.16 2004/04/06 23:49:59 livesey Exp $"
d254 1
a254 1
    & ModuleName )
d260 2
a261 1
    integer :: STATUS
d263 3
a265 1
    allocate ( To_Allocate(dim1,dim2,dim3), stat=status )
d267 1
a267 1
      & MLSMSG_Allocate // Its_Name // trim(bounds(1,dim1,1,dim2,1,dim3)) )
d721 3
@


2.16
log
@Added ClearOnAllocate stuff
@
text
@d70 1
a70 1
       "$Id: Allocate_Deallocate.f90,v 2.15 2004/04/05 17:47:56 livesey Exp $"
d121 1
a121 1
      & MLSMSG_Allocate // Its_Name // bounds(1,dim1) )
d136 1
a136 1
      & MLSMSG_Allocate // Its_Name // bounds(1,dim1,1,dim2) )
d152 1
a152 1
      & MLSMSG_Allocate // Its_Name // bounds(1,dim1,1,dim2,1,dim3) )
d169 1
a169 1
      & MLSMSG_Allocate // Its_Name // bounds(my_low,dim1) )
d189 1
a189 1
      & MLSMSG_Allocate // Its_Name // bounds(myLow1,dim1,myLow2,dim2) )
d211 1
a211 1
      & MLSMSG_Allocate // Its_Name // bounds(myLow1,dim1,myLow2,dim2,myLow3,dim3) )
d228 1
a228 1
      & MLSMSG_Allocate // Its_Name // bounds(lowBound,dim1) )
d234 1
a234 1
    & ModuleName )
d239 2
a240 1
    integer :: STATUS
d242 5
a246 1
    allocate ( To_Allocate(dim1,dim2), stat=status )
d248 1
a248 1
      & MLSMSG_Allocate // Its_Name // bounds(1,dim1,1,dim2) )
d264 1
a264 1
      & MLSMSG_Allocate // Its_Name // bounds(1,dim1,1,dim2,1,dim3) )
d281 1
a281 1
      & MLSMSG_Allocate // Its_Name // bounds(lowBound,dim1) )
d301 1
a301 1
      & MLSMSG_Allocate // Its_Name // bounds(myLow1,dim1,myLow2,dim2) )
d318 1
a318 1
      & MLSMSG_Allocate // Its_Name // bounds(lowBound,dim1) )
d338 1
a338 1
      & MLSMSG_Allocate // Its_Name // bounds(myLow1,dim1,myLow2,dim2) )
d360 1
a360 1
      & MLSMSG_Allocate // Its_Name // bounds(myLow1,dim1,myLow2,dim2,myLow3,dim3) )
d718 3
@


2.15
log
@Bug fix in the tracking stuff
@
text
@d62 2
a63 1
  logical, public :: TRACKING = .false. ! If true keep track of memory allocated
d70 1
a70 1
       "$Id: Allocate_Deallocate.f90,v 2.14 2004/04/03 05:43:53 livesey Exp $"
d86 1
a86 1
    if ( .not. tracking ) return        ! Most probably will not be called anyway
d95 1
a95 1
    call DumpSize ( noWords*4.0 )
d122 2
a123 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, dim1/4+1 )
d137 2
a138 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, (dim1*dim2)/4+1 )
d153 2
a154 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, (dim1*dim2*dim3)/4+1 )
d170 2
a171 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, 2*dim1 )
d190 2
a191 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, 2*dim1*dim2 )
d212 2
a213 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, 2*dim1*dim2*dim3 )
d229 2
a230 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, dim1 )
d244 2
a245 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, dim1*dim2 )
d260 2
a261 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, dim1*dim2*dim3 )
d277 2
a278 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, dim1/4+1 )
d297 2
a298 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, (dim1*dim2)/4+1 )
d314 2
a315 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, dim1 )
d334 2
a335 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, dim1*dim2 )
d356 2
a357 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, dim1*dim2*dim3 )
d366 1
a366 1
      if ( tracking ) then
d378 1
a378 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1/4-1 )
d388 1
a388 1
      if ( tracking ) then
d401 1
a401 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -(dim1*dim2)/4-1 )
d411 1
a411 1
      if ( tracking ) then
d425 1
a425 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -(dim1*dim2*dim3)/4-1 )
d435 1
a435 1
      if ( tracking ) then
d447 1
a447 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -2*dim1 )
d457 1
a457 1
      if ( tracking ) then
d470 1
a470 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -2*dim1*dim2 )
d480 1
a480 1
      if ( tracking ) then
d494 1
a494 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -2*dim1*dim2*dim3 )
d504 1
a504 1
      if ( tracking ) then
d516 1
a516 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1 )
d526 1
a526 1
      if ( tracking ) then
d539 1
a539 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2 )
d549 1
a549 1
      if ( tracking ) then
d563 1
a563 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2*dim3 )
d573 1
a573 1
      if ( tracking ) then
d585 1
a585 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1/4-1 )
d595 1
a595 1
      if ( tracking ) then
d608 1
a608 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -(dim1*dim2)/4-1 )
d618 1
a618 1
      if ( tracking ) then
d630 1
a630 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1 )
d640 1
a640 1
      if ( tracking ) then
d653 1
a653 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2 )
d663 1
a663 1
      if ( tracking ) then
d677 1
a677 1
      if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2*dim3 )
d713 3
@


2.14
log
@First attempt at memory tracking
@
text
@d69 1
a69 1
       "$Id: Allocate_Deallocate.f90,v 2.13 2004/01/30 21:20:35 vsnyder Exp $"
d94 1
a94 1
    call DumpSize ( noWords*4 )
d103 1
a103 1
    call DumpSize ( noWordsAllocated*4, advance='yes' )
a349 3
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
    endif
d351 3
d357 1
a357 1
        & MLSMSG_DeAllocate // Its_Name )
d363 1
a364 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1/4-1 )
a371 4
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
      dim2 = size ( to_deallocate, 2 )
    endif
d373 4
d380 1
a380 1
        & MLSMSG_DeAllocate // Its_Name )
d386 1
a387 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -(dim1*dim2)/4-1 )
a394 5
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
      dim2 = size ( to_deallocate, 2 )
      dim3 = size ( to_deallocate, 3 )
    endif
d396 5
d404 1
a404 1
        & MLSMSG_DeAllocate // Its_Name )
d410 1
a411 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -(dim1*dim2*dim3)/4-1 )
a418 3
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
    endif
d420 3
d426 1
a426 1
        & MLSMSG_DeAllocate // Its_Name )
d432 1
a433 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -2*dim1 )
a440 4
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
      dim2 = size ( to_deallocate, 2 )
    endif
d442 4
d449 1
a449 1
        & MLSMSG_DeAllocate // Its_Name )
d455 1
a456 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -2*dim1*dim2 )
a463 5
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
      dim2 = size ( to_deallocate, 2 )
      dim3 = size ( to_deallocate, 3 )
    endif
d465 5
d473 1
a473 1
        & MLSMSG_DeAllocate // Its_Name )
d479 1
a480 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -2*dim1*dim2*dim3 )
a487 3
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
    endif
d489 3
d495 1
a495 1
        & MLSMSG_DeAllocate // Its_Name )
d501 1
a502 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1 )
a509 4
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
      dim2 = size ( to_deallocate, 2 )
    endif
d511 4
d518 1
a518 1
        & MLSMSG_DeAllocate // Its_Name )
d524 1
a525 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2 )
a532 5
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
      dim2 = size ( to_deallocate, 2 )
      dim3 = size ( to_deallocate, 3 )
    endif
d534 5
d542 1
a542 1
        & MLSMSG_DeAllocate // Its_Name )
d548 1
a549 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2*dim3 )
a556 3
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
    endif
d558 3
d564 1
a564 1
        & MLSMSG_DeAllocate // Its_Name )
d570 1
a571 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1/4-1 )
a578 4
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
      dim2 = size ( to_deallocate, 2 )
    endif
d580 4
d587 1
a587 1
        & MLSMSG_DeAllocate // Its_Name )
d593 1
a594 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -(dim1*dim2)/4-1 )
a601 3
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
    endif
d603 3
d609 1
a609 1
        & MLSMSG_DeAllocate // Its_Name )
d615 1
a616 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1 )
a623 4
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
      dim2 = size ( to_deallocate, 2 )
    endif
d625 4
d632 1
a632 1
        & MLSMSG_DeAllocate // Its_Name )
d638 1
a639 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2 )
a646 5
    if ( tracking ) then
      dim1 = size ( to_deallocate, 1 )
      dim2 = size ( to_deallocate, 2 )
      dim3 = size ( to_deallocate, 3 )
    endif
d648 5
d656 1
a656 1
        & MLSMSG_DeAllocate // Its_Name )
d662 1
a663 1
    if ( tracking ) call ReportAllocateDeallocate ( its_name, moduleName, -dim1*dim2*dim3 )
d698 3
@


2.13
log
@Add bounds to 'allocation failed' message
@
text
@d31 1
a31 1
    & SET_GARBAGE_COLLECTION
d62 5
d69 1
a69 1
       "$Id: Allocate_Deallocate.f90,v 2.12 2004/01/24 01:01:05 livesey Exp $"
d75 32
a106 1
contains ! =====     Private Procedures     ============================
d121 1
d135 1
d150 1
d166 1
d185 1
d206 1
d222 1
d236 1
d251 1
d267 1
d286 1
d302 1
d321 1
d342 1
d349 4
d364 1
d371 5
d387 1
d394 6
d411 1
d418 4
d433 1
d440 5
d456 1
d463 6
d480 1
d487 4
d502 1
d509 5
d525 1
d532 6
d549 1
d556 4
d571 1
d578 5
d594 1
d601 4
d616 1
d623 5
d639 1
d646 6
d663 1
d698 3
@


2.12
log
@Nullify all pointers after deallocating.
@
text
@d64 1
a64 1
       "$Id: Allocate_Deallocate.f90,v 2.11 2002/10/08 00:09:08 pwagner Exp $"
d84 1
a84 1
      & MLSMSG_Allocate // Its_Name )
d97 1
a97 1
      & MLSMSG_Allocate // Its_Name )
d111 1
a111 1
      & MLSMSG_Allocate // Its_Name )
d126 1
a126 1
      & MLSMSG_Allocate // Its_Name )
d130 1
a130 1
    & ModuleName )
d135 2
d139 4
a142 1
    allocate ( To_Allocate(dim1,dim2), stat=status )
d144 1
a144 1
      & MLSMSG_Allocate // Its_Name )
d148 1
a148 1
    & Its_Name, ModuleName )
d154 2
d158 5
a162 1
    allocate ( To_Allocate(dim1,dim2,dim3), stat=status )
d164 1
a164 1
      & MLSMSG_Allocate // Its_Name )
d179 1
a179 1
      & MLSMSG_Allocate // Its_Name )
d192 1
a192 1
      & MLSMSG_Allocate // Its_Name )
d206 1
a206 1
      & MLSMSG_Allocate // Its_Name )
d221 1
a221 1
      & MLSMSG_Allocate // Its_Name )
d223 1
a223 1
  ! --------------------------------------  Allocate_Test_RealR4_2d  -----
d225 1
a225 1
    & ModuleName )
d230 2
d234 4
a237 1
    allocate ( To_Allocate(dim1,dim2), stat=status )
d239 1
a239 1
      & MLSMSG_Allocate // Its_Name )
d254 1
a254 1
      & MLSMSG_Allocate // Its_Name )
d258 1
a258 1
    & ModuleName )
d263 2
d267 4
a270 1
    allocate ( To_Allocate(dim1,dim2), stat=status )
d272 1
a272 1
      & MLSMSG_Allocate // Its_Name )
d276 1
a276 1
    & Its_Name, ModuleName )
d282 2
d286 5
a290 1
    allocate ( To_Allocate(dim1,dim2,dim3), stat=status )
d292 1
a292 1
      & MLSMSG_Allocate // Its_Name )
d533 1
a533 1
  ! ----------------------------------  Set_garbage_collection  -----
d539 19
d565 3
@


2.11
log
@Added idents to survive zealous Lahey optimizer
@
text
@d64 1
a64 1
       "$Id: Allocate_Deallocate.f90,v 2.10 2002/07/01 23:47:08 vsnyder Exp $"
d281 1
d298 1
d315 1
d332 1
d349 1
d366 1
d383 1
d400 1
d417 1
d434 1
d451 1
d468 1
d485 1
d502 1
d519 3
@


2.10
log
@Add [De]AllocateTest_3d, cosmetic changes
@
text
@d64 1
a64 1
       "$Id: Allocate_Deallocate.f90,v 2.9 2002/02/05 00:42:47 pwagner Exp $"
d67 1
d498 4
d505 3
@


2.9
log
@Optionally collects garbage after each deallocate_test
@
text
@d39 1
d52 1
d64 1
a64 1
       "$Id: Allocate_Deallocate.f90,v 2.8 2002/02/01 01:48:17 vsnyder Exp $"
d98 14
d277 1
a277 1
      elseif ( collect_garbage_each_time ) then
d293 1
a293 1
      elseif ( collect_garbage_each_time ) then
d298 16
d325 1
a325 1
      elseif ( collect_garbage_each_time ) then
d341 1
a341 1
      elseif ( collect_garbage_each_time ) then
d357 1
a357 1
      elseif ( collect_garbage_each_time ) then
d373 1
a373 1
      elseif ( collect_garbage_each_time ) then
d389 1
a389 1
      elseif ( collect_garbage_each_time ) then
d405 1
a405 1
      elseif ( collect_garbage_each_time ) then
d421 1
a421 1
      elseif ( collect_garbage_each_time ) then
d437 1
a437 1
      elseif ( collect_garbage_each_time ) then
d453 1
a453 1
      elseif ( collect_garbage_each_time ) then
d469 1
a469 1
      elseif ( collect_garbage_each_time ) then
d485 1
a485 1
      elseif ( collect_garbage_each_time ) then
d500 3
@


2.8
log
@Add [De]Allocate_Test_Character_2d
@
text
@d22 1
d30 2
a31 1
  public :: ALLOCATE_TEST, DEALLOCATE_TEST, DEALLOC_STATUS
d34 1
d62 1
a62 1
       "$Id: Allocate_Deallocate.f90,v 2.7 2001/09/10 21:05:01 livesey Exp $"
d261 2
d277 2
d293 2
d309 2
d325 2
d341 2
d357 2
d373 2
d389 2
d405 2
d421 2
d437 2
d453 2
d459 6
d468 3
@


2.7
log
@Added logical 2d stuff
@
text
@d35 1
d47 1
d59 1
a59 1
       "$Id: Allocate_Deallocate.f90,v 2.6 2001/05/30 23:52:15 livesey Exp $"
d80 13
a246 1

d261 14
d433 3
@


2.6
log
@Added 3D integer option.
@
text
@d37 1
a37 1
    module procedure ALLOCATE_TEST_LOGICAL_1D
d48 1
a48 1
    module procedure DEALLOCATE_TEST_LOGICAL_1D
d57 1
a57 1
       "$Id: Allocate_Deallocate.f90,v 2.5 2001/04/02 20:50:27 vsnyder Exp $"
d177 13
d345 14
d405 3
@


2.5
log
@Add logical 1-D
@
text
@d36 1
d47 1
d57 1
a57 1
       "$Id: Allocate_Deallocate.f90,v 2.4 2001/03/24 23:25:57 livesey Exp $"
d148 14
d304 14
d378 3
@


2.4
log
@Added real(r4) 3d, and renamed routines
@
text
@a34 2
    module procedure ALLOCATE_TEST_REALR8_1D, ALLOCATE_TEST_REALR8_2D
    module procedure ALLOCATE_TEST_REALR8_3D
d36 1
d39 2
a44 2
    module procedure DEALLOCATE_TEST_REALR8_1D, DEALLOCATE_TEST_REALR8_2D
    module procedure DEALLOCATE_TEST_REALR8_3D
d46 1
d49 2
d55 1
a55 1
       "$Id: Allocate_Deallocate.f90,v 2.3 2001/02/22 01:54:41 vsnyder Exp $"
d146 15
d288 14
d348 3
@


2.3
log
@Periodic commit
@
text
@d22 1
d35 2
a36 2
    module procedure ALLOCATE_TEST_DOUBLE_1D, ALLOCATE_TEST_DOUBLE_2D
    module procedure ALLOCATE_TEST_DOUBLE_3D
d38 2
a39 1
    module procedure ALLOCATE_TEST_REAL_1D, ALLOCATE_TEST_REAL_2D
d44 2
a45 2
    module procedure DEALLOCATE_TEST_DOUBLE_1D, DEALLOCATE_TEST_DOUBLE_2D
    module procedure DEALLOCATE_TEST_DOUBLE_3D
d47 2
a48 1
    module procedure DEALLOCATE_TEST_REAL_1D, DEALLOCATE_TEST_REAL_2D
d53 1
a53 1
       "$Id: Allocate_Deallocate.f90,v 2.2 2000/10/09 23:03:49 vsnyder Exp $"
d74 2
a75 2
  ! ------------------------------------  Allocate_Test_Double_1d  -----
  subroutine Allocate_Test_Double_1d ( To_Allocate, Dim1, Its_Name, &
d77 1
a77 1
    double precision, pointer, dimension(:) :: To_Allocate
d88 3
a90 3
  end subroutine Allocate_Test_Double_1d
  ! ------------------------------------  Allocate_Test_Double_2d  -----
  subroutine Allocate_Test_Double_2d ( To_Allocate, Dim1, Dim2, Its_Name, &
d92 1
a92 1
    double precision, pointer, dimension(:,:) :: To_Allocate
d101 3
a103 3
  end subroutine Allocate_Test_Double_2d
  ! ------------------------------------  Allocate_Test_Double_3d  -----
  subroutine Allocate_Test_Double_3d ( To_Allocate, Dim1, Dim2, Dim3, &
d105 1
a105 1
    double precision, pointer, dimension(:,:,:) :: To_Allocate
d115 1
a115 1
  end subroutine Allocate_Test_Double_3d
d144 2
a145 2
  ! --------------------------------------  Allocate_Test_Real_1d  -----
  subroutine Allocate_Test_Real_1d ( To_Allocate, Dim1, Its_Name, ModuleName, &
d147 1
a147 1
    real, pointer, dimension(:) :: To_Allocate
d158 3
a160 3
  end subroutine Allocate_Test_Real_1d
  ! --------------------------------------  Allocate_Test_Real_2d  -----
  subroutine Allocate_Test_Real_2d ( To_Allocate, Dim1, Dim2, Its_Name, &
d162 1
a162 1
    real, pointer, dimension(:,:) :: To_Allocate
d171 15
a185 1
  end subroutine Allocate_Test_Real_2d
d201 3
a203 3
  ! ----------------------------------  Deallocate_Test_Double_1d  -----
  subroutine Deallocate_Test_Double_1d ( To_Deallocate, Its_Name, ModuleName )
    double precision, pointer, dimension(:) :: To_Deallocate
d214 4
a217 4
  end subroutine Deallocate_Test_Double_1d
  ! ----------------------------------  Deallocate_Test_Double_2d  -----
  subroutine Deallocate_Test_Double_2d ( To_Deallocate, Its_Name, ModuleName )
    double precision, pointer, dimension(:,:) :: To_Deallocate
d228 4
a231 4
  end subroutine Deallocate_Test_Double_2d
  ! ----------------------------------  Deallocate_Test_Double_3d  -----
  subroutine Deallocate_Test_Double_3d ( To_Deallocate, Its_Name, ModuleName )
    double precision, pointer, dimension(:,:,:) :: To_Deallocate
d242 1
a242 1
  end subroutine Deallocate_Test_Double_3d
d271 17
a287 3
  ! ------------------------------------  Deallocate_Test_Real_1d  -----
  subroutine Deallocate_Test_Real_1d ( To_Deallocate, Its_Name, ModuleName )
    real, pointer, dimension(:) :: To_Deallocate
d298 4
a301 4
  end subroutine Deallocate_Test_Real_1d
  ! ------------------------------------  Deallocate_Test_Real_2d  -----
  subroutine Deallocate_Test_Real_2d ( To_Deallocate, Its_Name, ModuleName )
    real, pointer, dimension(:,:) :: To_Deallocate
d312 1
a312 1
  end subroutine Deallocate_Test_Real_2d
d317 3
@


2.2
log
@Provide for lower bounds for allocated arrays
@
text
@d12 10
d50 1
a50 1
       "$Id: Allocate_Deallocate.f90,v 2.0 2000/09/05 18:57:02 ahanzel Exp $"
d64 1
d79 1
d94 1
d108 1
d121 1
d136 1
d149 1
d164 1
d286 3
@


2.1
log
@New version of L2GP data, moved some stuff from l2 to lib
@
text
@d47 2
a48 1
  subroutine Allocate_Test_Character_1d ( To_Allocate, Dim1, Its_Name, ModuleName )
d50 7
a56 4
    integer :: Dim1                ! First dimension of To_Allocate
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    allocate ( To_Allocate(dim1), stat=status )
d61 2
a62 1
  subroutine Allocate_Test_Double_1d ( To_Allocate, Dim1, Its_Name, ModuleName )
d64 7
a70 4
    integer :: Dim1                ! First dimension of To_Allocate
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    allocate ( To_Allocate(dim1), stat=status )
d78 3
a80 3
    integer :: Dim1                ! First dimension of To_Allocate
    integer :: Dim2                ! Second dimension of To_Allocate
    character(len=*) :: Its_Name, ModuleName
d90 4
a93 4
    integer :: Dim1                ! First dimension of To_Allocate
    integer :: Dim2                ! Second dimension of To_Allocate
    integer :: Dim3                ! Third dimension of To_Allocate
    character(len=*) :: Its_Name, ModuleName
d100 2
a101 1
  subroutine Allocate_Test_Integer_1d ( To_Allocate, Dim1, Its_Name, ModuleName )
d103 7
a109 4
    integer :: Dim1                ! First dimension of To_Allocate
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    allocate ( To_Allocate(dim1), stat=status )
d117 3
a119 3
    integer :: Dim1                ! First dimension of To_Allocate
    integer :: Dim2                ! Second dimension of To_Allocate
    character(len=*) :: Its_Name, ModuleName
d126 2
a127 1
  subroutine Allocate_Test_Real_1d ( To_Allocate, Dim1, Its_Name, ModuleName )
d129 7
a135 4
    integer :: Dim1                ! First dimension of To_Allocate
    character(len=*) :: Its_Name, ModuleName
    integer :: STATUS
    allocate ( To_Allocate(dim1), stat=status )
d143 3
a145 3
    integer :: Dim1                ! First dimension of To_Allocate
    integer :: Dim2                ! Second dimension of To_Allocate
    character(len=*) :: Its_Name, ModuleName
@

