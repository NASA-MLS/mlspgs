head	2.146;
access;
symbols
	v5-02-NRT-19:2.146
	v6-00:2.146
	v5-02-NRT-18:2.146
	v5-02:2.146
	v5-01-NRT-17:2.146
	v5-01-NRT-16:2.146
	v5-01-NRT-15:2.146
	v5-01-NRT-14:2.146
	neuralnetworks-1-0:2.146.0.6
	cfm-single-freq-0-1:2.146.0.4
	v5-01:2.146
	v5-00:2.146
	v4-23-TA133:2.146.0.2
	mus-emls-1-70:2.145.0.2
	rel-1-0-englocks-work:2.144.0.2
	VUMLS1-00:2.144
	VPL1-00:2.144
	V4-22-NRT-08:2.142
	VAM1-00:2.142
	V4-21:2.139.0.2
	V4-13:2.137
	V4-12:2.135
	V4-11:2.134
	V4-10:2.134
	V3-43:2.115
	M4-00:2.131
	V3-41:2.115
	V3-40-PlusGM57:2.115.0.2
	V2-24-NRT-04:2.113
	V3-33:2.122
	V2-24:2.113
	V3-31:2.122
	V3-30-NRT-05:2.120
	cfm-01-00:2.118
	V3-30:2.115
	V3-20:2.115
	V3-10:2.115
	V2-23-NRT-02:2.113
	V2-23:2.113
	V2-22-NRT-01:2.113
	V2-22:2.113
	V2-21:2.111
	V2-20:2.111
	V2-11:2.111
	V2-10:2.111
	V2-00:2.107
	V1-51:2.102
	V1-50:2.102
	V1-45:2.101
	V1-44:2.101
	V1-43:2.100
	V1-42:2.93
	V1-41:2.93
	V1-32:2.93
	V1-40:2.93
	V1-31:2.93
	V1-30:2.92
	V1-13:2.89
	V1-12:2.89
	V1-11:2.89
	V1-10:2.87
	newfwm-feb03:2.88.0.2
	V1-04:2.66
	V1-03:2.66
	V1-02:2.66
	V1-00:2.65
	newfwm-sep01:2.50.0.2
	V0-7:2.50
	V0-5-Level2:2.28
	V0-5-SIPS:2.14;
locks; strict;
comment	@# @;


2.146
date	2018.11.01.00.44.48;	author vsnyder;	state Exp;
branches;
next	2.145;

2.145
date	2018.04.19.02.00.36;	author vsnyder;	state Exp;
branches;
next	2.144;

2.144
date	2016.07.27.23.02.42;	author vsnyder;	state Exp;
branches;
next	2.143;

2.143
date	2016.05.27.00.14.55;	author vsnyder;	state Exp;
branches;
next	2.142;

2.142
date	2015.06.02.23.53.36;	author vsnyder;	state Exp;
branches;
next	2.141;

2.141
date	2015.04.29.00.00.43;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2015.03.28.01.20.39;	author vsnyder;	state Exp;
branches;
next	2.139;

2.139
date	2014.10.10.23.56.19;	author vsnyder;	state Exp;
branches;
next	2.138;

2.138
date	2014.10.08.19.28.17;	author vsnyder;	state Exp;
branches;
next	2.137;

2.137
date	2014.09.05.00.14.21;	author vsnyder;	state Exp;
branches;
next	2.136;

2.136
date	2014.08.19.00.29.26;	author vsnyder;	state Exp;
branches;
next	2.135;

2.135
date	2014.07.23.21.58.28;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2013.09.24.23.27.14;	author vsnyder;	state Exp;
branches;
next	2.132;

2.132
date	2013.08.08.02.37.57;	author vsnyder;	state Exp;
branches;
next	2.131;

2.131
date	2012.07.19.19.39.48;	author vsnyder;	state Exp;
branches;
next	2.130;

2.130
date	2012.07.18.22.14.29;	author vsnyder;	state Exp;
branches;
next	2.129;

2.129
date	2012.07.10.03.58.13;	author vsnyder;	state Exp;
branches;
next	2.128;

2.128
date	2012.06.15.23.30.58;	author vsnyder;	state Exp;
branches;
next	2.127;

2.127
date	2012.02.16.22.47.51;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2012.02.10.23.50.12;	author vsnyder;	state Exp;
branches;
next	2.125;

2.125
date	2012.02.02.01.14.49;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2011.12.17.00.34.40;	author vsnyder;	state Exp;
branches;
next	2.123;

2.123
date	2011.06.16.20.17.32;	author vsnyder;	state Exp;
branches;
next	2.122;

2.122
date	2011.01.13.00.23.19;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2010.09.25.01.15.23;	author vsnyder;	state Exp;
branches;
next	2.120;

2.120
date	2010.08.13.22.04.08;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2010.08.06.22.59.53;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2010.04.17.01.41.57;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2010.03.24.20.39.12;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2010.02.25.18.05.21;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2007.11.07.21.33.08;	author vsnyder;	state Exp;
branches;
next	2.113;

2.113
date	2007.10.02.22.48.06;	author vsnyder;	state Exp;
branches;
next	2.112;

2.112
date	2007.09.12.00.16.37;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2006.08.01.03.18.27;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2006.08.01.02.49.08;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2006.07.28.01.58.17;	author vsnyder;	state Exp;
branches;
next	2.108;

2.108
date	2006.07.27.03.55.56;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2006.05.23.21.43.34;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2005.12.16.23.25.58;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2005.06.22.17.25.49;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2005.06.21.23.58.14;	author livesey;	state Exp;
branches;
next	2.103;

2.103
date	2005.05.25.02.14.43;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2004.10.14.04.54.25;	author livesey;	state Exp;
branches;
next	2.101;

2.101
date	2004.07.07.19.34.30;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2004.04.03.05.43.43;	author livesey;	state Exp;
branches;
next	2.99;

2.99
date	2004.01.30.23.24.48;	author livesey;	state Exp;
branches;
next	2.98;

2.98
date	2004.01.29.03.31.58;	author livesey;	state Exp;
branches;
next	2.97;

2.97
date	2004.01.24.03.22.20;	author livesey;	state Exp;
branches;
next	2.96;

2.96
date	2004.01.24.01.02.28;	author livesey;	state Exp;
branches;
next	2.95;

2.95
date	2004.01.23.05.36.24;	author livesey;	state Exp;
branches;
next	2.94;

2.94
date	2004.01.16.23.50.51;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2003.09.15.17.45.18;	author livesey;	state Exp;
branches;
next	2.92;

2.92
date	2003.07.07.20.20.59;	author livesey;	state Exp;
branches;
next	2.91;

2.91
date	2003.06.20.19.31.39;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2003.06.03.19.21.38;	author livesey;	state Exp;
branches;
next	2.89;

2.89
date	2003.02.21.04.06.30;	author livesey;	state Exp;
branches;
next	2.88;

2.88
date	2003.02.12.02.10.52;	author livesey;	state Exp;
branches;
next	2.87;

2.87
date	2003.01.17.22.31.52;	author livesey;	state Exp;
branches;
next	2.86;

2.86
date	2003.01.08.23.51.46;	author livesey;	state Exp;
branches;
next	2.85;

2.85
date	2002.11.22.12.53.59;	author mjf;	state Exp;
branches;
next	2.84;

2.84
date	2002.10.07.23.24.43;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2002.09.21.00.00.51;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2002.09.13.18.08.12;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2002.09.11.17.43.38;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2002.09.10.01.00.00;	author livesey;	state Exp;
branches;
next	2.79;

2.79
date	2002.08.29.04.45.27;	author livesey;	state Exp;
branches;
next	2.78;

2.78
date	2002.08.21.20.38.24;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2002.08.20.19.49.26;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2002.08.19.20.51.26;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2002.08.15.22.13.33;	author livesey;	state Exp;
branches;
next	2.74;

2.74
date	2002.08.06.02.15.20;	author livesey;	state Exp;
branches;
next	2.73;

2.73
date	2002.08.03.20.41.51;	author livesey;	state Exp;
branches;
next	2.72;

2.72
date	2002.07.22.03.26.37;	author livesey;	state Exp;
branches;
next	2.71;

2.71
date	2002.07.17.06.01.10;	author livesey;	state Exp;
branches;
next	2.70;

2.70
date	2002.07.01.23.50.03;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2002.06.22.06.50.25;	author livesey;	state Exp;
branches;
next	2.68;

2.68
date	2002.06.18.01.22.49;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2002.05.21.20.22.19;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2002.04.22.20.53.58;	author vsnyder;	state Exp;
branches
	2.66.2.1;
next	2.65;

2.65
date	2002.03.05.23.31.07;	author livesey;	state Exp;
branches;
next	2.64;

2.64
date	2002.03.05.23.17.03;	author livesey;	state Exp;
branches;
next	2.63;

2.63
date	2002.02.22.01.19.31;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2002.02.05.02.39.59;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2001.11.08.02.06.30;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2001.10.19.22.30.18;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2001.10.18.23.48.23;	author livesey;	state Exp;
branches;
next	2.58;

2.58
date	2001.10.15.23.22.45;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2001.10.04.23.49.57;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2001.10.01.23.57.51;	author livesey;	state Exp;
branches;
next	2.55;

2.55
date	2001.09.28.23.34.20;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2001.09.27.18.41.05;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2001.09.27.00.51.33;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2001.09.25.17.49.24;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2001.09.20.23.03.01;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2001.07.26.20.34.04;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2001.07.19.17.50.42;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2001.07.12.22.12.19;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2001.07.12.21.08.44;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2001.07.11.22.07.57;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2001.06.28.01.06.42;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2001.06.01.01.04.00;	author vsnyder;	state Exp;
branches;
next	2.43;

2.43
date	2001.05.30.20.18.01;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2001.05.22.19.09.33;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2001.05.19.00.20.05;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2001.05.19.00.14.57;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2001.05.19.00.13.23;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2001.05.18.23.48.34;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2001.05.18.22.28.11;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2001.05.17.20.19.20;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2001.05.12.18.58.47;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2001.05.12.01.07.19;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2001.05.10.22.54.34;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2001.05.10.02.14.58;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2001.05.09.19.46.06;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2001.05.09.01.56.15;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2001.05.08.20.29.40;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2001.05.03.02.11.23;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2001.05.01.23.54.13;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2001.05.01.06.56.32;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2001.04.30.23.44.25;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2001.04.28.07.03.59;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2001.04.28.04.42.29;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2001.04.28.01.28.36;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.04.27.22.51.52;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.04.26.23.56.02;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2001.04.25.01.12.39;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2001.04.25.00.50.25;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.04.24.22.35.56;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2001.04.21.02.11.02;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2001.04.20.02.56.18;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.04.11.00.40.25;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.11.00.03.42;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.10.00.19.11;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.09.23.56.17;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.09.23.32.19;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.02.22.02.09.36;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.02.22.01.55.06;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.01.26.19.00.02;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.01.19.23.53.26;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2001.01.10.21.03.14;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2000.11.23.01.09.46;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2000.11.15.00.18.26;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2000.11.10.00.28.13;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.11.09.01.23.23;	author vsnyder;	state Exp;
branches;
next	;

2.66.2.1
date	2002.05.22.23.23.14;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.146
log
@Type-bind some dump routines.  Spiff some comments
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module MatrixModule_1          ! Block Matrices in the MLS PGS suite
!=============================================================================

! This module provides a block matrix type including operations for matrix
! quantities in MLS Level 2 software, and related programs.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Dump_0, only: Dump
  use HighOutput, only: BlanksToColumn, DumpSize, OutputNamedValue
  use Lexer_Core, only: Where_t
  use MatrixModule_0, only: Add_Matrix_Blocks, Assignment(=), CheckIntegrity, &
    & CholeskyFactor, ClearLower, ClearRows, ColumnScale, Col_L1, CopyBlock, &
    & CreateBlock, CyclicJacobi, DenseCyclicJacobi, Densify, &
    & DestroyBlock, Diff, Dump, FrobeniusNorm, &
    & GetDiagonal, GetMatrixElement, GetMatrixKindString, GetVectorFromColumn, &
    & InvertCholesky, M_Absent, M_Column_Sparse, M_Banded, M_Full, M_Unknown, &
    & MatrixElement_t, MaxAbsVal, MinDiag, Multiply, MultiplyMatrix_XTY, &
    & MultiplyMatrix_XY, MultiplyMatrix_XY_T, MultiplyMatrixVectorNoT, &
    & NullifyMatrix, Operator(+), ReflectMatrix, RowScale, ScaleBlock, &
    & SolveCholesky, Sparsify, Spill, TransposeMatrix, UpdateDiagonal
  use MLSKinds, only: RM, RV, R8, R4
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
  use Output_m, only: Blanks, Newline, Output
  use String_Table, only: Display_String, Get_String
  use Symbol_Table, only: Enter_Terminal
  use Symbol_Types, only: T_Identifier
  use VectorsModule, only: ClearUnderMask, CloneVector, CopyVector, Vector_t, &
    & CheckIntegrity, NullifyVector

  implicit none
  private
  public :: AddToMatrixDatabase, AddToMatrix, AllMatricesMemoryInUse
  public :: AssignMatrix, Assignment(=)
  public :: CheckIntegrity, CholeskyFactor, CholeskyFactor_1
  public :: ClearLower, ClearLower_1, ClearMatrix, ClearRows, ClearRows_1
  public :: ColumnScale, ColumnScale_1, CopyMatrix, CopyMatrixValue
  public :: CreateBlock, CreateBlock_1, CreateEmptyMatrix, CyclicJacobi
  public :: DefineRCInfo, DestroyBlock, DestroyBlock_1, DestroyMatrix
  public :: DestroyMatrixInDatabase, DestroyMatrixDatabase, DestroyRCInfo
  public :: Diff, Dump, Dump_Linf, Dump_Layout, Dump_RC, Dump_Struct, FindBlock
  public :: FrobeniusNorm, GetActualMatrixFromDatabase, GetDiagonal
  public :: GetDiagonal_1, GetFromMatrixDatabase, GetFullBlock
  public :: GetKindFromMatrixDatabase, GetMatrixElement, GetMatrixElement_1
  public :: GetVectorFromColumn, GetVectorFromColumn_1, GetVectorFromColumn_1_Q_I
  public :: InvertCholesky, InvertCholesky_1
  public :: K_Cholesky, K_Empty, K_Kronecker, K_Plain, K_SPD
! public :: LevenbergUpdateCholesky
  public :: Matrix_T, Matrix_Cholesky_T, Matrix_Database_T, Matrix_Kronecker_T
  public :: Matrix_SPD_T, MatricesMemoryInUse, MatrixMemoryInUse
  public :: MatrixMemoryUse_t, MaxAbsVal, MaxAbsVal_1, MaxL1
  public :: MinDiag, MinDiag_Cholesky, MinDiag_SPD
  public :: Multiply, MultiplyMatrix_XTY_1, MultiplyMatrix_XTY
  public :: MultiplyMatrix_XY, MultiplyMatrix_XY_1
  public :: MultiplyMatrix_XY_T, MultiplyMatrix_XY_T_1
  public :: MultiplyMatrixVector, MultiplyMatrixVector_1
  public :: MultiplyMatrixVectorNoT, MultiplyMatrixVectorNoT_1
  public :: MultiplyMatrixVectorSPD_1
  public :: Negate, Negate_1, NewMultiplyMatrixVector
  public :: NormalEquations, NullifyRCInfo, NullifyMatrix, NullifyMatrix_1
  public :: Operator(+), ReflectMatrix, RC_Info, RM, RowScale, RowScale_1
  public :: ScaleMatrix, SolveCholesky, SolveCholesky_1, Spill, Spill_1
  public :: Sparsify_1, Sparsify, TransposeMatrix
  public :: UpdateDiagonal, UpdateDiagonal_1, UpdateDiagonalSPD_1, UpdateDiagonalVec_1

! =====     Defined Operators and Generic Identifiers     ==============

  interface AddToMatrixDatabase
    module procedure AddMatrixToDatabase, AddCholeskyToDatabase
    module procedure AddKroneckerToDatabase, AddSPDToDatabase
  end interface

  interface Assignment(=)
    module procedure AssignMatrix
  end interface

  interface CheckIntegrity
    module procedure CheckIntegrity_RC, CheckIntegrity_1
  end interface

  interface CholeskyFactor
    module procedure CholeskyFactor_1
  end interface

  interface ClearLower
    module procedure ClearLower_1
  end interface

  interface ClearRows
    module procedure ClearRows_1
  end interface

  interface ColumnScale
    module procedure ColumnScale_1
  end interface

  interface CreateBlock
    module procedure CreateBlock_1
  end interface

  interface CyclicJacobi
    module procedure CyclicJacobi_1
  end interface

  interface DestroyBlock
    module procedure DestroyBlock_1
  end interface

  interface DestroyMatrix
    module procedure DestroyMatrix
    module procedure DestroyMatrixInDatabase
  end interface

  interface Diff
    module procedure Diff_Matrices
  end interface

  interface Dump
    module procedure Dump_RC
    module procedure Dump_Matrix, Dump_Matrix_Database, Dump_Matrix_in_Database
  end interface

  interface Dump_Layout
    module procedure Dump_Matrix_Layout
  end interface

  interface FrobeniusNorm
    module procedure FrobeniusNorm_1
  end interface

  interface GetDiagonal
    module procedure GetDiagonal_1
  end interface

  interface GetFromMatrixDatabase
    module procedure GetMatrixFromDatabase, GetCholeskyFromDatabase
    module procedure GetKroneckerFromDatabase, GetSPDFromDatabase
  end interface

  interface GetVectorFromColumn
    module procedure GetVectorFromColumn_1, GetVectorFromColumn_1_Q_I
  end interface

  interface MaxAbsVal
    module procedure MaxAbsVal_1
  end interface

  interface MinDiag
    module procedure MinDiag_Cholesky, MinDiag_SPD
  end interface

  interface GetMatrixElement
    module procedure GetMatrixElement_1
  end interface

  interface InvertCholesky
    module procedure InvertCholesky_1
  end interface

  interface Multiply
    module procedure MultiplyMatrixVector_1, MultiplyMatrixVectorSPD_1
  end interface

  interface MultiplyMatrix_XTY
    module procedure MultiplyMatrix_XTY_1
  end interface

  interface MultiplyMatrix_XY
    module procedure MultiplyMatrix_XY_1
  end interface

  interface MultiplyMatrix_XY_T
    module procedure MultiplyMatrix_XY_T_1
  end interface

  interface MultiplyMatrixVector   ! A^T V
    module procedure MultiplyMatrixVector_1, MultiplyMatrixVectorSPD_1
  end interface

  interface MultiplyMatrixVectorNoT   ! A V
    module procedure MultiplyMatrixVectorNoT_1
  end interface

  interface Negate
    module procedure Negate_1
  end interface

  interface NullifyMatrix
    module procedure NullifyMatrix_1
  end interface

  interface ReflectMatrix
    module procedure ReflectMatrix_1
  end interface

  interface RowScale
    module procedure RowScale_1
  end interface

  interface SolveCholesky
    module procedure SolveCholesky_1
  end interface

  interface Sparsify
    module procedure Sparsify_1
  end interface

  interface Spill
    module procedure Spill_1
  end interface

  interface TransposeMatrix
    module procedure TransposeMatrix_1
  end interface

  interface UpdateDiagonal
    module procedure UpdateDiagonal_1, UpdateDiagonalSPD_1, UpdateDiagonalVec_1
  end interface

  integer, parameter :: K_Empty = 0                    ! Empty database element
  integer, parameter :: K_Cholesky = k_Empty + 1
  integer, parameter :: K_Kronecker = k_Cholesky + 1
  integer, parameter :: K_Plain = k_Kronecker  + 1
  integer, parameter :: K_SPD = k_Plain + 1

  type RC_Info
  ! Information about the row or column of a matrix
!     type(Vector_T), pointer :: Vec => NULL() ! Vector used to define the row
    type(Vector_T) :: Vec          ! Vector used to define the row
      ! or column space of the matrix, if any.
    integer :: NB = 0              ! Number of blocks of rows or columns
    logical :: InstFirst = .true.  ! TRUE means horizontal instance is the
      ! major order and quantity is the minor order.
    integer, pointer :: Nelts(:) => NULL()  ! Numbers of rows or columns in
      ! each row or column of blocks.
    integer, pointer :: Inst(:) => NULL()   ! The instance indices for the
      ! rows or columns of blocks.
    integer, pointer :: Quant(:) => NULL()  ! The quantity indices for the
      ! rows or columns of blocks.  These are indices within Vec, not the
      ! quantity template database.
  contains
!     We don't want a final routine for RC_Info because there are shallow
!     copies associated with local matrices, which would get destroyed.
!     In any case, this results in a crash when deallocating the snoop
!     matrix database in Fill.
!     final :: DestroyRCInfo
  end type RC_Info

  type Matrix_T
    integer :: Name = 0  ! Sub-rosa index of matrix name, if any, else zero
    type(where_t) :: Where     ! in input, if created by L2CF
    type(RC_Info) :: Col, Row  ! Column and row info
    type(matrixElement_T), dimension(:,:), pointer :: BLOCK => NULL()
   contains
!     We don't want a final routine for Matrix_T because there are shallow
!     copies associated with local matrices, which would get destroyed.
!     final :: DestroyMatrix
    procedure :: Dump_Layout => Dump_Matrix_Layout
    procedure :: Dump_Matrix
    generic :: Dump => Dump_Matrix
    procedure :: Dump_Struct
  end type Matrix_T

  type Matrix_Cholesky_T ! Cholesky factored matrix.  Only the upper triangle
    type(matrix_T) :: M  ! is stored.
  end type Matrix_Cholesky_T

  type Matrix_Kronecker_T  ! Kronecker product matrix.  Not yet implemented.
    type(matrix_T) :: M
  end type Matrix_Kronecker_T

  type Matrix_SPD_T      ! Symmetric positive-definite matrix.  Only the
    type(matrix_T) :: M  ! upper triangle is stored.
  end type Matrix_SPD_T

  type Matrix_Database_T
    private
    type(Matrix_T), pointer :: Matrix => NULL()
    type(Matrix_Cholesky_T), pointer :: Cholesky => NULL()
    type(Matrix_Kronecker_T), pointer :: Kronecker => NULL()
    type(Matrix_SPD_T), pointer :: SPD => NULL()
  contains
!     final :: DestroyMatrixDatabaseElement
  end type Matrix_Database_T

  type MatrixMemoryUse_t ! Number of real(rm) elements in each matrix
    integer :: Name = 0  ! of the matrix
    integer :: Size = 0  ! Number of real(rm) elements
  end type MatrixMemoryUse_t

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MatrixModule_1.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

contains ! =====     Public Procedures     =============================

  ! --------------------------------------  AddCholeskyToDatabase  -----
  integer function AddCholeskyToDatabase ( Database, CholeskyItem )
  ! Add a Cholesky factor matrix to the matrix database.
  ! This is really "MoveCholeskyToDatabase" because it nullifies CholeskyItem.
  ! This is done because the assignments are shallow copies.  If we didn't
  ! nullify, the RC_Info, which is a shallow copy, would get clobbered by the
  ! finalizer.
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(matrix_Database_T), dimension(:), pointer :: Database
    type(matrix_cholesky_T), intent(in) :: CholeskyItem

    integer(c_intptr_t) :: Addr         ! For tracing
    type(matrix_Database_T) :: Item
    integer :: Status

    allocate ( item%cholesky, stat=status )
    addr = 0
    if ( status == 0 ) addr = transfer(c_loc(item%cholesky), addr)
    call test_allocate ( status, ModuleName, "Matrix database element", &
      & elementSize = storage_size(item%cholesky) / 8, address=addr )
!     call copyMatrix ( item%cholesky%m, choleskyItem%m ) ! Deep copy
!     item%cholesky%m%name = choleskyItem%m%name ! Not done by copyMatrix
    item%cholesky = choleskyItem
    addCholeskyToDatabase = addItemToMatrixDatabase ( database, item )
    ! addItemToMatrixDatabase is a shallow copy, so nullify the temp item
    ! so stuff in the database item is not clobbered by the finalizer
!     The following is probably necessary to make final subroutines for
!     RC_Info and Matrix_T work, else the finalizers deallocate targets
!     out from under pointers in the matrix database... but it causes a
!     crash.  I don't know why.
!     call nullifyMatrix ( item%cholesky%m )
  end function AddCholeskyToDatabase

  ! -------------------------------------  AddKroneckerToDatabase  -----
  integer function AddKroneckerToDatabase ( Database, KroneckerItem )
  ! Add a Kronecker product matrix to the matrix database.
  ! This is really "MoveKroneckerToDatabase" because it nullifies KroneckerItem.
  ! This is done because the assignments are shallow copies.  If we didn't
  ! nullify, the RC_Info, which is a shallow copy, would get clobbered by the
  ! finalizer.
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(matrix_Database_T), dimension(:), pointer :: Database
    type(matrix_kronecker_T), intent(in) :: KroneckerItem

    integer(c_intptr_t) :: Addr         ! For tracing
    type(matrix_Database_T) :: Item
    integer :: Status

    allocate ( item%kronecker, stat=status )
    addr = 0
    if ( status == 0 ) addr = transfer(c_loc(item%kronecker), addr)
    call test_allocate ( status, ModuleName, "Matrix database element", &
      & elementSize = storage_size(item%kronecker) / 8, address=addr )
!     call copyMatrix ( item%kronecker%m, kroneckerItem%m ) ! Deep copy
!     item%kronecker%m%name = kroneckerItem%m%name ! Not done by copyMatrix
    item%kronecker = kroneckerItem
    addKroneckerToDatabase = addItemToMatrixDatabase ( database, item )
    ! addItemToMatrixDatabase is a shallow copy, so nullify the temp item
    ! so stuff in the database item is not clobbered by the finalizer
!     The following is probably necessary to make final subroutines for
!     RC_Info and Matrix_T work, else the finalizers deallocate targets
!     out from under pointers in the matrix database... but it causes a
!     crash.  I don't know why.
!     call nullifyMatrix ( item%kronecker%m )
  end function AddKroneckerToDatabase

  ! ------------------------------------------------  AddMatrices  -----
  function AddMatrices ( X, Y ) result ( Z ) ! Z = X + Y
    type(Matrix_T), intent(in) :: X, Y
    type(Matrix_T) :: Z

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyMatrix using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignMatrix.
  ! !!!!! ===== END NOTE ===== !!!!!

    integer :: I, J      ! Subscripts for [XYZ]%Block

    call nullifyMatrix ( z ) ! for Sun's still useless compiler
    ! Check that the matrices are compatible.
    if ( x%col%vec%template%name /= y%col%vec%template%name &
      & .or. x%row%vec%template%name /= y%row%vec%template%name &
      & .or. (x%col%instFirst .neqv. y%col%instFirst) &
      & .or. (x%row%instFirst .neqv. y%row%instFirst) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Incompatible arrays in AddMatrices" )
    call createEmptyMatrix ( z, 0, x%row%vec, x%col%vec )
    do j = 1, x%col%nb
      do i = 1, x%row%nb
        z%block(i,j) = x%block(i,j) + y%block(i,j)
      end do ! i = 1, x%row%nb
    end do ! j = 1, x%col%nb
  end function AddMatrices

  ! ----------------------------------------  AddMatrixToDatabase  -----
  integer function AddMatrixToDatabase ( Database, MatrixItem )
  ! Add a matrix of unspecified structure to the matrix database.
  ! This is really "MoveMatrixToDatabase" because it nullifies MatrixItem.
  ! This is done because the assignments are shallow copies.  If we didn't
  ! nullify, the RC_Info, which is a shallow copy, would get clobbered by the
  ! finalizer.
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(matrix_Database_T), dimension(:), pointer :: Database
    type(matrix_T), intent(in) :: MatrixItem

    integer(c_intptr_t) :: Addr         ! For tracing
    type(matrix_Database_T) :: Item
    integer :: Status

    allocate ( item%matrix, stat=status )
    addr = 0
    if ( status == 0 ) addr = transfer(c_loc(item%matrix), addr)
    call test_allocate ( status, ModuleName, "Matrix database element", &
      & elementSize = storage_size(item%matrix) / 8, address=addr )
!     call copyMatrix ( item%matrix, matrixItem ) ! Deep copy
!     item%matrix%name = matrixItem%name ! Not done by copyMatrix
    item%matrix = matrixItem
    addMatrixToDatabase = addItemToMatrixDatabase ( database, item )
    ! addItemToMatrixDatabase is a shallow copy, so nullify the temp item
    ! so stuff in the database item is not clobbered by the finalizer
!     The following is probably necessary to make final subroutines for
!     RC_Info and Matrix_T work, else the finalizers deallocate targets
!     out from under pointers in the matrix database... but it causes a
!     crash in Convolve_All.  I don't know why.
!     call nullifyMatrix ( item%matrix )
!     database(addMatrixToDatabase)%matrix%name = matrixItem%name ! Not done by copyMatrix
  end function AddMatrixToDatabase

  ! -------------------------------------------  AddSPDToDatabase  -----
  integer function AddSPDToDatabase ( Database, SPDItem )
  ! Add a symmetric-positive-definite matrix to the matrix database
  ! This is really "MoveSPDToDatabase" because it nullifies SPDItem.
  ! This is done because the assignments are shallow copies.  If we didn't
  ! nullify, the RC_Info, which is a shallow copy, would get clobbered by the
  ! finalizer.
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(matrix_Database_T), dimension(:), pointer :: Database
    type(matrix_spd_T), intent(in) :: SPDItem

    integer(c_intptr_t) :: Addr         ! For tracing
    type(matrix_Database_T) :: Item
    integer :: Status

    allocate ( item%spd, stat=status )
    addr = 0
    if ( status == 0 ) addr = transfer(c_loc(item%spd), addr)
    call test_allocate ( status, ModuleName, "Matrix database element", &
      & elementSize = storage_size(item%spd) / 8, address=addr )
!     call copyMatrix ( item%spd%m, spdItem%m ) ! Deep copy
!     item%spd%m%name = spdItem%m%name ! Not done by copyMatrix
    item%spd = spdItem
    addSPDToDatabase = addItemToMatrixDatabase ( database, item )
    ! addItemToMatrixDatabase is a shallow copy, so nullify the temp item
    ! so stuff in the database item is not clobbered by the finalizer
!     The following is probably necessary to make final subroutines for
!     RC_Info and Matrix_T work, else the finalizers deallocate targets
!     out from under pointers in the matrix database... but it causes a
!     crash.  I don't know why.
!     call nullifyMatrix ( item%spd%m )
  end function AddSPDToDatabase

  ! ------------------------------------------------  AddToMatrix  -----
  subroutine AddToMatrix ( X, Y, Scale ) ! X = X + [Scale*] Y
    type(Matrix_T), intent(inout) :: X
    type(Matrix_T), intent(in) :: Y
    real(r8), intent(in), optional :: Scale

    integer :: I, J      ! Subscripts for [XYZ]%Block

    ! Check that the matrices are compatible.
    if ( x%col%vec%template%name /= y%col%vec%template%name &
      & .or. x%row%vec%template%name /= y%row%vec%template%name &
      & .or. (x%col%instFirst .neqv. y%col%instFirst) &
      & .or. (x%row%instFirst .neqv. y%row%instFirst) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Incompatible arrays in AddMatrices" )
    if ( present(scale) ) then
      do j = 1, x%col%nb
        do i = 1, x%row%nb
          x%block(i,j) = add_Matrix_Blocks ( x%block(i,j), y%block(i,j), scale ) ! Defined =
        end do ! i = 1, x%row%nb
      end do ! j = 1, x%col%nb
    else
      do j = 1, x%col%nb
        do i = 1, x%row%nb
          x%block(i,j) = x%block(i,j) + y%block(i,j) ! Defined =, +
        end do ! i = 1, x%row%nb
      end do ! j = 1, x%col%nb
    end if
  end subroutine AddToMatrix

  ! -------------------------------------  AllMatricesMemoryInUse  -----
  function AllMatricesMemoryInUse ( D ) result ( R )
  ! Report the number of real(rm) elements in all matrices in the
  ! database.
    type(matrix_database_T), dimension(:), pointer :: D
    type(matrixMemoryUse_t), allocatable :: R(:)
    integer :: I

    if ( .not. associated(d) ) return
    allocate ( r(size(d)) )
    do i = 1, size(d)
      if ( associated(d(i)%matrix) ) then
        r(i)%name = d(i)%matrix%name
        r(i)%size = matrixMemoryInUse ( d(i)%matrix )
      end if
      if ( associated(d(i)%cholesky) ) then
        r(i)%name = d(i)%cholesky%m%name
        r(i)%size = matrixMemoryInUse ( d(i)%cholesky%m )
      end if
      if ( associated(d(i)%kronecker) ) then
        r(i)%name = d(i)%kronecker%m%name
        r(i)%size = matrixMemoryInUse ( d(i)%kronecker%m )
      end if
      if ( associated(d(i)%spd) ) then
        r(i)%name = d(i)%spd%m%name
        r(i)%size = matrixMemoryInUse ( d(i)%spd%m )
      end if
    end do

  end function AllMatricesMemoryInUse

  ! -----------------------------------------------  AssignMatrix  -----
  subroutine AssignMatrix ( Z, X )
  ! Destroy Z and then assign X to it, using pointer assignment for pointer
  ! components.  Notice that CopyMatrix does a deep copy.  If one has Z = X
  ! inside a loop, it is only necessary to destroy Z after the loop.
    type(Matrix_T), intent(inout) :: Z
    type(Matrix_T), intent(in) :: X
    call destroyMatrix ( z )
    z%name = x%name
    z%col = x%col
    z%row = x%row
    z%block => x%block
  end subroutine AssignMatrix

  ! ------------------------------------------- CheckIntegrity_RC ------
  logical function CheckIntegrity_RC ( rc, noError )
    type ( RC_Info ), intent(in) :: RC
    logical, optional, intent(in) :: NOERROR

    ! Local variables
    integer :: MESSAGETYPE
    integer :: I                        ! Loop counter

    ! Executable code

    messageType = MLSMSG_Error
    if ( present ( noError ) ) then
      if ( noError ) messageType = MLSMSG_Warning
    end if

    checkIntegrity_RC = CheckIntegrity ( rc%vec, .true. )
    if ( rc%nb /= rc%vec%template%totalInstances ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Row/col info has bad NB' )
      checkIntegrity_RC = .false.
    end if

    ! Check arrays, must give errors here as later code will fail anyway
    if ( .not. associated ( rc%nelts ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has no nelts associated' )
      checkIntegrity_RC = .false.
    end if
    if ( .not. associated ( rc%inst ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has no inst associated' )
      checkIntegrity_RC = .false.
    end if
    if ( .not. associated ( rc%quant ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has no quant associated' )
      checkIntegrity_RC = .false.
    end if
    ! Check lbounds
    if ( lbound ( rc%nelts,1 ) /= 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has bad lbound for nelts' )
      checkIntegrity_RC = .false.
    end if
    if ( lbound ( rc%inst,1 ) /= 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has bad lbound for inst' )
      checkIntegrity_RC = .false.
    end if
    if ( lbound ( rc%quant,1 ) /= 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has bad lbound for quant' )
      checkIntegrity_RC = .false.
    end if
    ! Check ubounds
    if ( ubound ( rc%nelts,1 ) /= rc%nb ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has bad ubound for nelts' )
      checkIntegrity_RC = .false.
    end if
    if ( ubound ( rc%inst,1 ) /= rc%nb ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has bad ubound for inst' )
      checkIntegrity_RC = .false.
    end if
    if ( ubound ( rc%quant,1 ) /= rc%nb ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has bad ubound for quant' )
      checkIntegrity_RC = .false.
    end if
    ! Check arrays min values
    if ( any ( rc%quant < 0 ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has -ve values for quant' )
      checkIntegrity_RC = .false.
    end if
    ! Check arrays max values
    if ( any ( rc%quant > rc%vec%template%noQuantities ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Row/col info has too high values for quant' )
      checkIntegrity_RC = .false.
    end if

    do i = 1, rc%nb
      call output ( 'Checking row/col block ' )
      call output ( i )
      call output ( '/' )
      call output ( rc%nb, advance='yes' )
      if ( rc%inst(i) > rc%vec%quantities(rc%quant(i))%template%noInstances ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Row/col info has too high values for inst' )
        checkIntegrity_RC = .false.
      end if
      if ( rc%nelts(i) /= rc%vec%quantities(rc%quant(i))%template%instanceLen ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Row/col info has bad value for inst' )
        checkIntegrity_RC = .false.
      end if
    end do

  end function CheckIntegrity_RC

  ! ------------------------------------------- CheckIntegrity_1 -------
  logical function CheckIntegrity_1 ( matrix, noError )
    type ( Matrix_T ), intent(in) :: MATRIX
    logical, optional, intent(in) :: NOERROR

    ! Local variables
    integer :: MESSAGETYPE
    character ( len=132 ) :: NAME
    integer :: ROW, COL                 ! Loop counters

    ! Executable code

    messageType = MLSMSG_Error
    if ( present ( noError ) ) then
      if ( noError ) messageType = MLSMSG_Warning
    end if
    if ( matrix%name /= 0 ) then
      call get_string ( matrix%name, name, strip=.true. )
    else
      name = '<no name>'
    end if

    call output ( 'Checking integrity for matrix '//trim(name), advance='yes' )
    call output ( 'Checking row info', advance='yes' )
    checkIntegrity_1 = CheckIntegrity ( matrix%row )
    call output ( 'Checking col info', advance='yes' )
    checkIntegrity_1 = checkIntegrity_1 .and. CheckIntegrity ( matrix%col )
    if ( .not. associated ( matrix%block ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Matrix '//trim(name)//' has no block associated' )
      checkIntegrity_1 = .false.
    end if
    if ( any ( lbound ( matrix%block ) /= 1 ) ) then
      call MLSMessage ( messageType, ModuleName, &
        & 'Matrix '//trim(name)//' has bad lbound on block' )
      checkIntegrity_1 = .false.
    end if

    do row = 1, matrix%row%nb
      do col = 1, matrix%col%nb
        call output ( 'Checking integrity of block ' )
        call DescribeBlock ( matrix, row, col )

        if ( matrix%block(row,col)%nRows /= matrix%row%nelts(row) ) then
          call MLSMessage ( messageType, ModuleName, &
            & 'Matrix '//trim(name)//' has inconsistent block row sizes' )
          checkIntegrity_1 = .false.
        end if
        if ( matrix%block(row,col)%nCols /= matrix%col%nelts(col) ) then
          call MLSMessage ( messageType, ModuleName, &
            & 'Matrix '//trim(name)//' has inconsistent block col sizes' )
          checkIntegrity_1 = .false.
        end if
        checkIntegrity_1 = checkIntegrity_1 .and. &
          & CheckIntegrity ( matrix%block(row,col), .true. )
      end do
    end do

  end function CheckIntegrity_1

  ! -------------------------------------------  CholeskyFactor_1  -----
  subroutine CholeskyFactor_1 ( Z, X, STATUS )
  ! Compute the Cholesky factor Z of the matrix X.  Z%M%Block can be
  ! associated with X%M%Block to save space.
    type(Matrix_Cholesky_T), intent(inout) :: Z   ! Factored matrix.
    type(Matrix_SPD_T), intent(in) :: X ! Matrix to factor.
    integer, dimension(2), intent(out), optional :: STATUS ! Optional status flag

    integer :: I, J, K                  ! Subscripts and loop inductors
    type(MatrixElement_T) :: S          ! Sum, to accumulate "inner product"
    integer :: BLOCKSTATUS              ! Block level status flag
    character (len=132) :: LINE         ! Message

    ! Check that the matrices are compatible.  We don't need to check
    ! Nelts or Nb, because these are deduced from Vec.
    if ( x%m%col%vec%template%name /= z%m%col%vec%template%name &
      & .or. x%m%row%vec%template%name /= z%m%row%vec%template%name &
      & .or. (x%m%col%instFirst .neqv. z%m%col%instFirst) &
      & .or. (x%m%row%instFirst .neqv. z%m%row%instFirst) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Matrices in CholeskyFactor are not compatible" )

!{Suppose $X$ is symmetric and positive definite.  Regard $X = (X_{ij})$
!  and its upper-triangular Cholesky factor $Z = (Z_{ij})$ as $N \times N$
!  matrices with square diagonal blocks.  By equating $(i,j)$ blocks in the
!  equation $X = Z^T Z$ with $i \leq j$, it follows that
!  \begin{equation*}
!   X_{ij} = \sum_{k=1}^i Z_{ki}^T Z_{kj}
!  \end{equation*}
!  Define
!  \begin{equation*}
!  S = X_{ij} - \sum_{k=1}^{i-1} Z_{ki}^T Z_{kj}
!    = X_{ij} - \sum_{k=1}^i Z_{ki}^T Z_{kj} + Z_{ii}^T Z_{ij}
!    = Z_{ii}^T Z_{ij}
!  \end{equation*}
!
!  Rearranging, we have the following algorithm:
!
!  {\bf do} $i = 1, N$\\
!  \hspace*{0.25in} $S= X_{ii} - \sum_{k=1}^{i-1} Z_{ki}^T Z_{ki}$\\
!  \hspace*{0.25in} $Z_{ii} = $ Cholesky factor of $S$\\
!  \hspace*{0.25in} {\bf do} $j = i+1, N$\\
!  \hspace*{0.5in}    $S= X_{ij} - \sum_{k=1}^{i-1} Z_{ki}^T Z_{kj}$\\
!  \hspace*{0.5in}    solve $Z_{ii}^T Z_{ij} = S$ for $Z_{ij}$\\
!  \hspace*{0.25in} {\bf end do} ! j\\
!  {\bf end do} ! i

    ! Handle the first row specially, to avoid a copy followed by no-dot-product
    !{ Get $Z_{11}$, where $Z_{11}^T Z_{11} = X_{11}$
    call choleskyFactor ( z%m%block(1,1), x%m%block(1,1), blockStatus )
    if ( blockStatus /= 0 ) then
      if ( present(status) ) then
        call output ( 'Block is not positive definite: ' )
        call DescribeBlock ( x%m, 1, 1 )
        status = (/ 1, blockStatus /)
        return
      else
        call dump ( x%m%block(1,1), 'Guilty party:' )
        write ( line, '(a, i0, a)') &
          & 'Block (1,1) of matrix is not positive definite (element ', &
          & blockStatus, ')'
        call MLSMessage ( MLSMSG_Error, ModuleName, line )
      end if
    end if
    do j = 2, x%m%row%nb
      !{ Solve $Z_{11}^T Z_{1j} = X_{1j}$ for $Z_{1j}$
      call solveCholesky ( z%m%block(1,1), z%m%block(1,j), x%m%block(1,j), &
        & transpose=.true. )
    end do
    do i = 2, x%m%row%nb
      call copyBlock ( s, x%m%block(i,i) )        ! Destroy s, then s := x...
      do k = 1, i-1
        !{ $S = X_{ii} - \sum_{k=1}^{i-1} Z_{ki}^T Z_{ki}$
        call multiply ( z%m%block(k,i), z%m%block(k,i), s, &
          & update=.true., subtract=.true. )
      end do ! k = 1, i-1
      !{ Get $Z_{ii}$, where $Z_{ii}^T Z_{ii} = S$
      call choleskyFactor ( z%m%block(i,i), s, blockStatus )   ! z%m%block(i,i) = factor of s
      if ( blockStatus /= 0 ) then
        if ( present ( status ) ) then
          call output ( 'Block is not positive definite: ' )
          call DescribeBlock ( x%m, i, i )
          status = (/ i, blockStatus /)
          return
        else
          call dump ( s, name='Guilty party:' )
          write ( line, '(a, i0, a, i0, a, i0, a)') &
            & 'Block (',i,',',i,') of matrix is not positive definite (element ', &
            & blockStatus, ')'
          call MLSMessage ( MLSMSG_Error, ModuleName, line )
        end if
      end if
      do j = i+1, x%m%row%nb
        call copyBlock ( s, x%m%block(i,j) )    ! Destroy s, then s := x...
        do k = 1, i-1
          !{ $S = X_{ij} - \sum_{k=1}^{i-1} Z_{ki}^T Z_{kj}$
          call multiply ( z%m%block(k,i), z%m%block(k,j), s, &
            & update=.true., subtract=.true. )
        end do ! k = 1, i-1
        !{ Solve $Z_{ii}^T Z_{ij} = S$ for $Z_{ij}$
        call solveCholesky ( z%m%block(i,i), z%m%block(i,j), s, &
          & transpose=.true. )
      end do ! j = i+1, x%m%row%nb
      call destroyBlock( s )                      ! Avoid a memory leak
    end do ! i = 2, n
    if ( present ( status ) ) status = 0
  end subroutine CholeskyFactor_1

  ! ------------------------------------------------  ClearLower  ------
  subroutine ClearLower_1 ( X )
    ! Zero out lower triangle of X
    type ( matrix_T ), intent(inout) :: X
    ! Local variables
    integer :: I, J                     ! Subscripts
    ! Executable code
    do i = 1, x%row%nb
      do j = 1, i - 1
        call DestroyBlock ( x%block(i,j) )
      end do
      call ClearLower ( x%block(i,i) )
    end do
  end subroutine ClearLower_1

  ! ------------------------------------------------  ClearMatrix  -----
  subroutine ClearMatrix ( X )     ! Delete all of the blocks, but keep the
                                   ! structural information
    type(matrix_T), intent(inout) :: X
    integer :: I, J                ! Subscripts and row indices
    if (associated(x%block)) then
      do i = 1, x%row%nb
        do j = 1, x%col%nb
          call destroyBlock ( x%block(i,j) )
        end do ! j
      end do ! i
    end if
  end subroutine ClearMatrix

  ! ------------------------------------------------  ClearRows_1  -----
  subroutine ClearRows_1 ( X, RowBlock, Vec )
  ! Clear the rows of X for which the mask in X's row-defining vector has a
  ! nonzero M_LinAlg bit.  If RowBlock is present, it specifies that only the
  ! rows in that row block are to be cleared.  Otherwise, rows in all row
  ! blocks are cleared.  If the vector Vec is present, its elements that
  ! correspond to nonzero bits of its mask are cleared.
    type(Matrix_T), intent(inout) :: X
    integer, intent(in), optional :: RowBlock
    type(Vector_T), intent(inout), optional :: Vec
    integer :: I1, I2              ! Bounds for I
    integer :: I, J                ! Subscripts and row indices
    integer :: NI, NQ              ! Instance and quantity indices
    i1 = 1
    i2 = x%row%nb
    if ( present(rowBlock) ) then
      i1 = rowBlock
      i2 = rowBlock
    end if
    do i = i1, i2
      ni = x%row%inst(i)
      nq = x%row%quant(i)
      if ( associated(x%row%vec%quantities(nq)%mask) ) then
        do j = 1, x%col%nb
          call clearRows ( x%block(i,j), x%row%vec%quantities(nq)%mask(:,ni) )
        end do ! j = 1, x%col%nb
      end if
      if ( present(vec) ) call clearUnderMask ( vec, ni, nq )
    end do ! i = 1, x%row%nb
  end subroutine ClearRows_1

  ! ----------------------------------------------  ColumnScale_1  -----
  subroutine ColumnScale_1 ( X, V, NEWX ) ! Z = X V where V is a diagonal
  !                                matrix represented by a vector and Z is X
  !                                or NEWX.
    type (Matrix_T), intent(inout), target :: X
    type (Vector_T), intent(in) :: V
    type (Matrix_T), intent(inout), target, optional :: NEWX ! intent(inout)
      !                            so that the destroyMatrix in createEmptyMatrix
      !                            gets a chance to clean up surds

    integer :: I, J      ! Subscripts for [XZ]%Block

    if ( present(newx) ) then
      call createEmptyMatrix ( newx, 0, x%row%vec, x%col%vec, &
        & x%row%instFirst, x%col%instFirst )
      do j = 1, x%col%nb
        do i = 1, x%row%nb
          call ColumnScale ( x%block(i,j), &
            & v%quantities(x%col%quant(j))%values(:,x%col%inst(j)), &
            & newx%block(i,j) )
        end do ! i = x%row%nb
      end do ! j = x%col%nb
    else
      do j = 1, x%col%nb
        do i = 1, x%row%nb
          call ColumnScale ( x%block(i,j), &
            & v%quantities(x%col%quant(j))%values(:,x%col%inst(j)) )
        end do ! i = x%row%nb
      end do ! j = x%col%nb
    end if
  end subroutine ColumnScale_1

  ! -------------------------------------------------  CopyMatrix  -----
  subroutine CopyMatrix ( Z, X )        ! Destroy Z, then deep Z = X except
  !                                       the name of Z isn't changed.
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(matrix_T), intent(inout) :: Z
    type(matrix_T), intent(in) :: X
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: I, J      ! Subscripts and loop inductors
    integer :: Status    ! From allocate
    call destroyMatrix ( z )
    call copyRCInfo ( z%col, x%col )
    call copyRCInfo ( z%row, x%row )
    allocate ( z%block(z%row%nb,z%col%nb), stat=status )
    addr = 0
    if ( status == 0 ) then
      if ( size(z%block) > 0 ) addr = transfer(c_loc(z%block(1,1)), addr)
    end if
    call test_allocate ( status, ModuleName, "Z%Block in CreateEmptyMatrix", &
      & uBounds = [z%row%nb,z%col%nb], elementSize = storage_size(z%block) / 8, &
      & address=addr )
    do j = 1, x%col%nb
      do i = 1, x%row%nb
        call createBlock ( z, i, j, m_absent, forWhom="CopyMatrix" ) ! Create block w/correct size
        call copyBlock ( z%block(i,j), x%block(i,j) )
      end do ! i = 1, x%row%nb
    end do ! j = 1, x%col%nb
  end subroutine CopyMatrix

  ! --------------------------------------------  CopyMatrixValue  -----
  subroutine CopyMatrixValue ( Z, X, ALLOWNAMEMISMATCH )   ! Copy the elements of X to Z.
  ! Z and X must have the same template.
    type(matrix_T), intent(inout) :: Z
    type(matrix_T), intent(in) :: X
    logical, intent(in), optional :: ALLOWNAMEMISMATCH
    integer :: I, J ! Subscripts and loop inductors
    logical :: MYALLOW
    myAllow = .false.
    if ( present ( allowNameMismatch ) ) myAllow = allowNameMismatch
    if ( ( ( x%col%vec%template%name /= z%col%vec%template%name  &
      & .or. x%row%vec%template%name /= z%row%vec%template%name ) &
      &   .and. .not. myAllow ) &
      & .or. (x%col%instFirst .neqv. z%col%instFirst) &
      & .or. (x%row%instFirst .neqv. z%row%instFirst) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Incompatible arrays in CopyMatrixValue" )
    do i = 1, min(x%row%nb,z%row%nb)
      do j = 1, min(x%col%nb,z%col%nb)
        call copyBlock ( z%block(i,j), x%block(i,j) )
      end do ! j
    end do ! i
  end subroutine CopyMatrixValue

  ! ----------------------------------------------  CreateBlock_1  -----
  subroutine CreateBlock_1 ( Z, RowNum, ColNum, Kind, NumNonzeros, BandHeight, &
    &                        Init, ForWhom )
  ! Create the matrix block Z%Block(RowNum,ColNum), which sprang into
  ! existence with kind M_Absent.  Create it with the specified Kind.
  ! See MatrixModule_0 for a list of the kinds.  If the Kind is
  ! M_Banded or M_ColumnSparse, the number of nonzeroes is needed.
  ! If Kind == M_Banded and BandHeight is present, the band height is
  ! assumed to be uniform, and the R1 and R2 components are filled to
  ! reflect that assumption.  If Init is present the Values field is
  ! filled from Init.
    integer, intent(in), optional :: BandHeight
    type(matrix_T), intent(inout) :: Z       ! The matrix having the block
    integer, intent(in) :: RowNum, ColNum    ! Row and column of the block
    integer, intent(in) :: Kind         ! Kind of block, see MatrixModule_0
    integer, intent(in), optional :: NumNonzeros  ! Number of nonzeros
    real(rm), intent(in), optional :: Init   ! Initial value
    character(len=*), intent(in), optional :: ForWhom ! for allocation
    call createBlock ( z%block(rowNum,colNum), &
      & z%row%nelts(rowNum), z%col%nelts(colNum), kind, numNonzeros, &
      & bandHeight=bandHeight, init=init, forWhom=forWhom, &
      & nChan=z%row%vec%quantities(z%row%quant(rowNum))%template%noChans )
  end subroutine CreateBlock_1

  ! ------------------------------------------  CreateEmptyMatrix  -----
  subroutine CreateEmptyMatrix ( Z, Name, Row, Col &
    &,                           Row_Quan_First, Col_Quan_First, Text, where )
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(Matrix_T), intent(inout) :: Z  ! The matrix to create -- inout so
      !                                   destroyMatrix makes sense
    integer, intent(in) :: Name         ! Sub-rosa index of its name, or zero
    type(Vector_T), intent(in) :: Row   ! Vector used to define the row
      !                                   space of the matrix.
    type(Vector_T), intent(in) :: Col   ! Vector used to define the column
      !                                   space of the matrix.
    logical, intent(in), optional :: Row_Quan_First    ! True (default false)
      ! means the quantity is the major order of the rows of blocks and the
      ! instance is the minor order.
    logical, intent(in), optional :: Col_Quan_First    ! True (default false)
      ! means the quantity is the major order of the columns of blocks and the
      ! instance is the minor order.
    character(len=*), intent(in), optional :: Text     ! A name to use
      ! instead of "Name."
    type(where_t), intent(in), optional :: Where ! in input, if created if by L2CF

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: I, J      ! Subscripts, loop inductors
    integer :: STATUS    ! From ALLOCATE

    call destroyMatrix ( z )  ! Avoid a memory leak if it isn't freshly minted
    z%name = name
    if ( present(text) ) z%name = enter_terminal ( text, t_identifier )
    call defineRCInfo ( z%row, row, row_Quan_First )
    call defineRCInfo ( z%col, col, col_Quan_First )
    if ( present(where) ) z%where = where
    allocate ( z%block(z%row%nb,z%col%nb), stat=status )
    addr = 0
    if ( status == 0 ) then
      if ( size(z%block) > 0 ) addr = transfer(c_loc(z%block(1,1)), addr)
    end if
    call test_allocate ( status, ModuleName, "Z%Block in CreateEmptyMatrix", &
      & uBounds = [z%row%nb,z%col%nb], elementSize = storage_size(z%block) / 8, &
      & address=addr )
    do i = 1, z%row%nb ! Now create absent blocks with the correct sizes
      do j = 1, z%col%nb
        call createBlock ( z, i, j, m_absent, forWhom="CreateEmptyMatrix" )
      end do
    end do

  end subroutine CreateEmptyMatrix

  ! ----------------------------------------------- CyclicJacobi_1 --------
  subroutine CyclicJacobi_1 ( A, V, eps, tol )
    ! Implements the blockwise cyclic Jacobi algoritm (Golub and VanLoan 3rd ed.
    ! Section 8.4.8).  Note that while the matrix is expected to be
    ! symmetric, we do need to have both halves stored.
    type(Matrix_T), intent(inout) :: A ! Matrix to diagonalize,
              ! returned with eigen values on diagonal, ~0 off diagonal.
    type(Matrix_T), intent(inout) :: V ! Eigen vector matrix output, assumed created
              ! appropriately
    real(rm), optional, intent(in) :: EPS ! Smallest value to go for
    real(rm), optional, intent(in) :: TOL ! Or as fraction of norm
    ! Local variables
    integer :: N                        ! Size of matrix
    integer :: P, Q, J                  ! Loop indices
    integer :: SWEEP                    ! Seep counter
    real(rm) :: MYEPS, MYTOL            ! Potential copies of eps and tol
    real(rm) :: NORM                    ! Norm of matrix
    real(rm), dimension(:,:), pointer :: VBIT ! Part of V matrix returned by CyclicJacobi_1
    type(MatrixElement_T) :: VPP, VQP, VPQ, VQQ ! Bits of V
    type(MatrixElement_T) :: TAU1, TAU2, RESULT1, RESULT2 ! Temporary blocks
    ! Executable code
    ! Do some setup
    if ( present ( eps ) ) then
      myEps = eps
    else
      myTol = epsilon ( 0.0_rm )
      if ( present ( tol ) ) myTol = tol
      myEps = myTol * FrobeniusNorm ( A )
    endif
    call output ( 'Tolerance: ' )
    call output ( myTol )
    call output ( ', ' )
    call output ( myEps, advance='yes' )
    n = A%row%nb
    ! Set V to the identity
    call ClearMatrix ( V )
    call UpdateDiagonal ( V, 1.0_rv )
    ! For 1 block matrices, we just call the low level routine
    if ( n == 1 ) then
      call Densify ( A%block(1,1) )
      call Densify ( V%block(1,1) )
      call DenseCyclicJacobi ( A%block(1,1)%values, V%block(1,1)%values, eps=eps, tol=tol )
      return
    end if
    ! Now loop through the `sweeps'
    sweep = 0
    do
      sweep = sweep + 1
      if ( sweep > 10 ) exit
      norm = FrobeniusNorm ( A, lowerOff=.true. )
      call output ( 'Sweep: ' )
      call output ( norm )
      call output ( ' / ' )
      call output ( myEps, advance='yes' )
      ! Get out if sufficiently diagonal
      if ( norm <= myEps ) exit
      ! Otherwise, walk through matrix
      do p = 1, n-1
        do q = p+1, n
!           call output ( 'Combination: ' )
!           call output ( p )
!           call output ( ', ' )
!           call output ( q, advance='yes' )
          ! Construct a notional J matrix which is the identity
          ! except that it has
          !  Vpp Vpq
          !  Vqp Vqq
          ! embeded in it at block rows/cols p and p
          ! We then rotate A to A = J^T A J, also change V to VJ
          ! Note that this only affects block rows and columns p and q of A and V
          ! So code specially to take advantage of that.
          call CyclicJacobi ( &
            & A%block(p,p), A%block(q,p), A%block(p,q), A%block(q,q), &
            & Vpp, Vqp, Vpq, Vqq, Vbit, tol=tol )
          ! This next bit is sort of taken from section 5.1.9 of Golub and Van Loan
          ! (3rd edition), but expanded to be blockwise
          ! Update A with J^T A J
          ! First do A -> J^T A
          do j = 1, n
            ! tau1 => Mpj
            ! tau2 => Mqj
            tau1 = A%block(p,j)         ! *NOTE* Defined assignment
            tau2 = A%block(q,j)         ! *NOTE* Defined assignement
            ! We're trying to do:
            !  Mpj = Vpp^T * tau1 + Vqp^T * tau2
            !  Mqj = Vpq^T * tau1 + Vqq^T * tau2
            call MultiplyMatrix_XTY ( Vpp, tau1, result1 )
            call MultiplyMatrix_XTY ( Vqp, tau2, result1, update=.true. )

            call MultiplyMatrix_XTY ( Vpq, tau1, result2 )
            call MultiplyMatrix_XTY ( Vqq, tau2, result2, update=.true. )
            ! Assign result.  This uses defined assignment, which destroys the LHS
            ! which in turn destroys tau1 and tau2
            A%block(p,j) = result1      ! *NOTE* Defined assignment
            A%block(q,j) = result2      ! *NOTE* Defined assignment
            ! Nullify result so next operation doesn't destroy it
            call NullifyMatrix ( result1 )
            call NullifyMatrix ( result2 )
            ! Also nullify tau1 and tau2, just to be sure
            call NullifyMatrix ( tau1 )
            call NullifyMatrix ( tau2 )
          end do
          ! Now do A -> A J
          do j = 1, n
            ! tau1 => Ajp
            ! tau2 => Ajq
            tau1 = A%block(j,p)         ! *NOTE* Defined assignment
            tau2 = A%block(j,q)         ! *NOTE* Defined assignment
            ! We're trying to do
            !  Ajp = tau1 * Vpp + tau2 * Vqp
            !  Ajq = tau1 * Vpq + tau2 * Vqq
            call MultiplyMatrix_XY ( tau1, Vpp, result1 )
            call MultiplyMatrix_XY ( tau2, Vqp, result1, update=.true. )

            call MultiplyMatrix_XY ( tau1, Vpq, result2 )
            call MultiplyMatrix_XY ( tau2, Vqq, result2, update=.true. )

            ! Assign result.  This uses defined assignment, which destroys the LHS
            ! which in turn destroys tau1 and tau2
            A%block(j,p) = result1      ! *NOTE* Defined assignment
            A%block(j,q) = result2      ! *NOTE* Defined assignment
            ! Nullify result so next operation doesn't destroy it
            call NullifyMatrix ( result1 )
            call NullifyMatrix ( result2 )
            ! Also nullify tau1 and tau2, just to be sure
            call NullifyMatrix ( tau1 )
            call NullifyMatrix ( tau2 )
          end do
          ! Now update V -> V J
          do j = 1, n
            ! tau1 => Vjp
            ! tau2 => Vjq
            tau1 = V%block(j,p)         ! *NOTE* Defined assignment
            tau2 = V%block(j,q)         ! *NOTE* Defined assignment
            ! We're trying to do (note the somewhat double meaning of V in this comment)
            !  Vjp = tau1 * Vpp + tau2 * Vqp
            !  Vjq = tau1 * Vpq + tau2 * Vqq
            call MultiplyMatrix_XY ( tau1, Vpp, result1 )
            call MultiplyMatrix_XY ( tau2, Vqp, result1, update=.true. )

            call MultiplyMatrix_XY ( tau1, Vpq, result2 )
            call MultiplyMatrix_XY ( tau2, Vqq, result2, update=.true. )

            ! Assign result.  This uses defined assignment, which destroys the LHS
            ! which in turn destroys tau1 and tau2
            V%block(j,p) = result1      ! *NOTE* Defined assignment
            V%block(j,q) = result2      ! *NOTE* Defined assignment
            ! Nullify result so next operation doesn't destroy it
            call NullifyMatrix ( result1 )
            call NullifyMatrix ( result2 )
            ! Also nullify tau1 and tau2, just to be sure
            call NullifyMatrix ( tau1 )
            call NullifyMatrix ( tau2 )
          end do
          ! Get rid of Vbit, which destroys all the Vxxs
          call Deallocate_test ( Vbit, 'Vbit in CyclicJacobi_1', ModuleName )
          ! Let's nullify them anyway to be sure
          call NullifyMatrix ( Vpp )
          call NullifyMatrix ( Vqp )
          call NullifyMatrix ( Vpq )
          call NullifyMatrix ( Vqq )
        end do ! End loop over q
      end do ! End loop over p
    end do ! End sweep loop
  end subroutine CyclicJacobi_1

  ! ----------------------------------------------------- DefineRCInfo -----------------
  subroutine DefineRCInfo ( RC, Vec, QuanFirst )
    type(RC_Info), intent(out) :: RC
!     type(Vector_T), intent(in), target :: Vec
    type(Vector_T), intent(in) :: Vec
    logical, intent(in), optional :: QuanFirst

    integer :: I, J, N      ! Subscripts or loop inductors
    logical :: NEW          ! Was an instance seen?

!     rc%vec => vec
    rc%vec = vec
    rc%instFirst = .true.
    if ( present(quanFirst) ) rc%instFirst = .not. quanFirst
    rc%nb = vec%template%totalInstances
    call allocate_test ( rc%nelts, rc%nb, &
      & "rc%nelts", ModuleName // '%CreateEmptyMatrix' )
    call allocate_test ( rc%inst, rc%nb, "rc%inst", &
      & ModuleName // '%CreateEmptyMatrix' )
    call allocate_test ( rc%quant, rc%nb, "rc%quant", &
      & ModuleName // '%CreateEmptyMatrix' )
    if ( rc%instFirst ) then
      !??? Are rc%nelts etc. different if the vector is not regular?
      n = 0
      j = 0
      do ! ( until .not. new )
        j = j + 1           ! instance number
        new = .false.       ! Instance j not seen for any quantity
        do i = 1, size(vec%quantities)
          if ( size(vec%quantities(i)%values,2) >= j ) then
            n = n + 1
            rc%nelts(n) = size(vec%quantities(i)%values,1)
            rc%inst(n) = j
            rc%quant(n) = i
            new = .true.    ! Instance j seen for some quantity
          end if
        end do ! i
        if ( .not. new ) exit
      end do ! j
    else
      !??? Are rc%nelts etc. different if the vector is not regular?
      n = 0
      do i = 1, size(vec%quantities)
        do j = 1, size(vec%quantities(i)%values,2)
          n = n + 1
          rc%nelts(n) = size(vec%quantities(i)%values,1)
          rc%inst(n) = j
          rc%quant(n) = i
        end do ! j
      end do ! i
    end if
  end subroutine DefineRCInfo

  ! ------------------------------------------ Describe Block -----
  subroutine DescribeBlock ( matrix, row, col )
    ! Print the row and column indices of a block and
    ! identify which quantity/instance they are.
    type(Matrix_T), intent(in) :: MATRIX
    integer, intent(in), optional :: ROW         ! Row index
    integer, intent(in), optional :: COL         ! Column index
    ! Executable code
    call output ( '[ ' )
    if ( present(row) .and. present(col) ) then
      call output ( row )
      call output ( col, before=', ' )
    else if ( present(row) ) then
      call output ( row, before='row ' )
    else if ( present(col) ) then
      call output ( col, before ='col ' )
    else
      call output ( 'row and column not specified' )
    end if
    call output ( ' ] ( ' )
    if ( present(row) .and. present(col) ) then
      call display_string ( matrix%row%vec%quantities ( &
        & matrix%row%quant(row) )%template%name )
      call output ( matrix%row%inst(row), before='[' )
      call display_string ( matrix%col%vec%quantities ( &
        & matrix%col%quant(col) )%template%name, before='], ' )
      call output ( matrix%col%inst(col), before='[' )
    else if ( present(row) ) then
      call display_string ( matrix%row%vec%quantities ( &
        & matrix%row%quant(row) )%template%name, before='row ' )
      call output ( matrix%row%inst(row), before='[' )
      call output ( ']' )
    else if ( present(col) ) then
      call display_string ( matrix%col%vec%quantities ( &
        & matrix%col%quant(col) )%template%name, before='col ' )
      call output ( matrix%col%inst(col), before='[' )
    end if
    call output ( '] )', advance='yes' )
  end subroutine DescribeBlock

  ! ---------------------------------------------  DestroyBlock_1  -----
  subroutine DestroyBlock_1 ( A )
  ! Destroy the "block" component of a matrix.  This leaves its structure
  ! intact, but releases the space for its values.  This is useful when
  ! forming normal equations little-by-little.
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(matrix_T), intent(inout) :: A

    integer(c_intptr_t) :: Addr    ! For tracing
    integer :: S                   ! Size in bytes of object to deallocate
    integer :: STATUS              ! From deallocate

    call clearMatrix ( a )
    if ( associated(a%block) ) then
      s = size(a%block) * storage_size(a%block) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(a%block(1,1)), addr)
      deallocate ( a%block, stat=status )
      call test_deallocate ( status, ModuleName, "A%Block", s, address=addr )
    end if
  end subroutine DestroyBlock_1

  ! ----------------------------------------------  DestroyMatrix  -----
  subroutine DestroyMatrix ( A )
  ! Destroy a matrix -- deallocate its pointer components, don't change the
  ! name
    type(matrix_T), intent(inout) :: A

    call destroyBlock ( a )
    call destroyRCInfo ( a%row )
    call destroyRCInfo ( a%col )
    a%where = where_t(0,0)
  end subroutine DestroyMatrix

  ! ------------------------------------  DestroyMatrixInDatabase  -----
  subroutine DestroyMatrixInDatabase ( Database )
  ! Destroy a matrix in the database -- deallocate its pointer components,
  ! don't change the name
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(matrix_database_T), intent(inout) :: Database
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: Status  ! from deallocate

    if ( associated(database%matrix) ) then
      call destroyMatrix ( database%matrix )
      addr = transfer(c_loc(database%matrix), addr)
      deallocate ( database%matrix, stat=status )
      call test_deallocate ( status, moduleName, 'PlainMatrix', &
        & storage_size(database%matrix) / 8, address=addr )
    else if ( associated(database%cholesky) ) then
      call destroyMatrix ( database%cholesky%m )
      addr = transfer(c_loc(database%cholesky%m), addr)
      deallocate ( database%cholesky, stat=status )
      call test_deallocate ( status, moduleName, 'CholeskyMatrix', &
        & storage_size(database%cholesky%m) / 8, address=addr )
    else if ( associated(database%kronecker) ) then
      call destroyMatrix ( database%kronecker%m )
      addr = transfer(c_loc(database%kronecker%m), addr)
      deallocate ( database%kronecker, stat=status )
      call test_deallocate ( status, moduleName, 'KroneckerMatrix', &
        & storage_size(database%kronecker%m) / 8, address=addr )
    else if ( associated(database%spd) ) then
      call destroyMatrix ( database%spd%m )
      addr = transfer(c_loc(database%spd%m), addr)
      deallocate ( database%spd, stat=status )
      call test_deallocate ( status, moduleName, 'SPDMatrix', &
        & storage_size(database%spd%m) / 8, address=addr )
    end if
  end subroutine DestroyMatrixInDatabase

  ! --------------------------------------  DestroyMatrixDatabase  -----
  subroutine DestroyMatrixDatabase ( D )
  ! Destroy every matrix in the database D, then destroy the database.
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(matrix_database_T), dimension(:), pointer :: D

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: I, S, Status

    if ( .not. associated(d) ) return
    do i = 1, size(d)
      call destroyMatrixDatabaseElement ( d(i) )
    end do
    s = size(d) * storage_size(d) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(d(1)), addr)
    deallocate ( d, stat=status )
    call test_deallocate ( status, ModuleName, "D in DestroyMatrixDatabase", s, &
      & address=addr )
  end subroutine DestroyMatrixDatabase

  ! -------------------------------  DestroyMatrixDatabaseElement  -----
  subroutine DestroyMatrixDatabaseElement ( D )
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(matrix_database_T), intent(inout) :: D
    if ( associated(d%matrix) ) then
      call destroyMatrix ( d%matrix )
      call deallocateMatrix ( d%matrix )
    end if
    if ( associated(d%cholesky) ) then
      call destroyMatrix ( d%cholesky%m )
      call destroyMatrix ( d%cholesky%m )
    end if
    if ( associated(d%kronecker) ) then
      call destroyMatrix ( d%kronecker%m )
      call destroyMatrix ( d%kronecker%m )
    end if
    if ( associated(d%spd) ) then
      call destroyMatrix ( d%spd%m )
      call destroyMatrix ( d%spd%m )
    end if
  contains
    subroutine DeallocateMatrix ( M )
      type(matrix_t), pointer :: M
      integer(c_intptr_t) :: Addr         ! For tracing
      integer :: Status
      addr = transfer(c_loc(m), addr)
      deallocate ( m, stat=status )
      call test_deallocate ( status, ModuleName, &
        & "D%matrix in DestroyMatrixDatabaseElement", storage_size(m) / 8, &
        & address=addr )
    end subroutine DeallocateMatrix
  end subroutine DestroyMatrixDatabaseElement

  ! ----------------------------------------------------  Dump_RC  -----
  subroutine Dump_RC ( RC, R_or_C, Details, Num )
    type(rc_info), intent(in) :: RC
    character(len=*), intent(in) :: R_or_C
    logical, intent(in) :: Details
    integer, intent(in), optional :: Num ! Just for this row or column
    if ( .not. present(num) ) then
      call output ( rc%nb, before='Number of ' // r_or_c // ' blocks = ' )
      call output ( ' Vector that defines ' // r_or_c // 's' )
      if ( rc%vec%name == 0 ) then
        call output ( ' has no name', advance='yes' )
      else
        call output ( ': ' )
        call display_string ( rc%vec%name, advance='yes' )
      end if
      call output ( 'Order of '//r_or_c//' blocks is ' )
      if ( rc%instFirst ) then
        call output ( 'instance, then quantity', advance='yes' )
      else
        call output ( 'quantity, then instance', advance='yes' )
      end if
    end if
    if ( details ) then
      if ( present(num) ) then
        call output ( num, before='Number of ' // r_or_c // 's in ' // &
          & r_or_c // ' block ' )
        if ( .not. associated(rc%nelts) ) then
          call output( ' is not associated', advance='yes' )
        else
          call output ( rc%nelts(num), before=': ', advance='yes' )
        end if
        call output ( num, before='Instance index for ' // r_or_c // ' ' )
        if ( .not. associated(rc%inst) ) then
          call output( ' is not associated', advance='yes' )
        else
          call output ( rc%inst(num), before=': ', advance='yes' )
        end if
        call output ( num, before='Quantity index for ' // r_or_c // ' ' )
        if ( .not. associated(rc%quant) ) then
          call output( ' is not associated', advance='yes' )
        else
          call output ( rc%quant(num), before=': ', advance='yes' )
        end if
      else
        call output ( 'Numbers of ' // r_or_c // 's in each block:', advance='yes' )
        if ( .not. associated(rc%nelts) ) then
          call output( 'numbers not associated', advance='yes' )
        else
          call dump ( rc%nelts )
        end if
        call output ( 'Instance indices for blocks in the ' // r_or_c // 's:', &
          & advance='yes' )
        if ( .not. associated(rc%inst) ) then
          call output( 'indices not associated', advance='yes' )
        else
          call dump ( rc%inst )
        end if
        call output ( 'Quantity indices for blocks in the ' // r_or_c // 's', &
          & advance='yes' )
        if ( .not. associated(rc%quant) ) then
          call output( 'indices not associated', advance='yes' )
        else
          call dump ( rc%quant )
        end if
      end if
    end if
  end subroutine Dump_RC

  ! --------------------------------------------------  FindBlock  -----
  integer function FindBlock ( RC, Quantity, Instance )
  ! Given quantity and instance numbers, find a block index.
  ! This function can be used with either row or column information.
  ! Zero is returned if there is no block having the desired quantity
  ! and instance numbers.
    type(RC_Info), intent(in) :: RC     ! Row or Col component of a Matrix_T
    integer, intent(in) :: Quantity, Instance

    ! We could do something fancier here, e.g. a binary search on rc%quant
    ! or rc%inst, depending on rc%instFirst, but the difference between
    ! that and what's here is sure to be insignificant compared to the
    ! linear algebra.
    do findBlock = 1, rc%nb
      if ( rc%quant(findBlock) == quantity .and. &
        &  rc%inst(findBlock) == instance ) return
    end do
    findBlock = 0
  end function FindBlock

  ! --------------------------------------------------  FrobeniusNorm_1 ---
  real(rm) function FrobeniusNorm_1 ( M, lowerOff )
    ! Compute the Frobenius norm of the matrix (sum of square of all
    ! elements).  Possibly only those below diagonal
    type ( matrix_t ), intent(in) :: M
    logical, optional, intent(in) :: LOWEROFF
    ! Local variables
    logical :: MYLOWEROFF
    integer :: R, C, R1              ! Indicies
    ! Executable code
    myLowerOff = .false.
    if ( present ( lowerOff ) ) myLowerOff = lowerOff
    FrobeniusNorm_1 = 0.0
    r1 = 1
    do c = 1, m%col%nb
      if ( myLowerOff ) then
        FrobeniusNorm_1 = FrobeniusNorm_1 + FrobeniusNorm ( m%block(c,c), lowerOff=.true. )
        r1 = c+1
      end if
      do r = r1, m%row%nb
        FrobeniusNorm_1 = FrobeniusNorm_1 + FrobeniusNorm ( m%block(r,c) )
      end do
    end do
  end function FrobeniusNorm_1

  ! ------------------------------------  GetActualMatrixFromDatabse ---
  subroutine GetActualMatrixFromDatabase ( DatabaseElement, m )
    ! Get POINTER to the actual Matrix_T part of any kind of matrix
    type ( matrix_database_t), intent(in), target :: DatabaseElement
    type ( matrix_t), pointer :: m

    ! Executable code
    if ( associated ( databaseElement%matrix ) ) then
      m => databaseElement%matrix
    else if ( associated ( databaseElement%cholesky ) ) then
      m => databaseElement%cholesky%m
    else if ( associated ( databaseElement%kronecker ) ) then
      m => databaseElement%kronecker%m
    else if ( associated ( databaseElement%spd ) ) then
      m => databaseElement%spd%m
    else
      m => NULL()
    end if
  end subroutine GetActualMatrixFromDatabase

  ! ------------------------------------  GetCholeskyFromDatabase  -----
  subroutine GetCholeskyFromDatabase ( DatabaseElement, Cholesky )
  ! Get a POINTER to a Cholesky object from DatabaseElement.
    type(matrix_Database_T), intent(in) :: DatabaseElement
    type(matrix_cholesky_T), pointer :: Cholesky
    cholesky => databaseElement%cholesky
  end subroutine GetCholeskyFromDatabase

  ! ----------------------------------------------  GetDiagonal_1  -----
  subroutine GetDiagonal_1 ( A, X, SquareRoot, Invert, ZeroOK )
  ! Get X from the diagonal of A.
  ! Destroy X and re-create it by cloning the row-defining vector of A.
  ! Return the square roots of the diagonal elements if SquareRoot is
  ! present and true.
    type(Matrix_T), intent(in) :: A
    type(vector_T), intent(inout) :: X
    logical, intent(in), optional :: SquareRoot
    logical, intent(in), optional :: Invert
    logical, intent(in), optional :: ZeroOK

    integer :: I

    if ( x%template%name /= a%row%vec%template%name ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Vector supplied to GetDiagonal_1 does not have same template as matrix rows')
    do i = 1, min(a%row%nb,a%col%nb)
      call getDiagonal ( a%block(i,i), &
        & x%quantities(a%row%quant(i))%values(:,a%row%inst(i)), squareRoot, invert, zeroOK )
    end do
  end subroutine GetDiagonal_1

  ! -----------------------------------------------  GetFullBlock  -----
  subroutine GetFullBlock ( Jacobian, Row, Col, What )

    type (Matrix_t), intent(inout) :: Jacobian
    integer, intent(in) :: Row, Col
    character(len=*), intent(in) :: What

    character(len=63) :: ForWhom

    select case ( Jacobian%block(row,col)%kind )
      case ( m_absent )
        if ( jacobian%name /= 0 ) then
          call get_string ( jacobian%name, forWhom )
          forWhom = trim(forWhom) // " in GetFullBlock"
        else
          forWhom = "GetFullBlock"
        end if
        call CreateBlock ( Jacobian, row, col, m_full, init=0.0_rm, forWhom=forWhom )
      case ( m_full )
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Wrong matrix block type for ' // what // ' derivative matrix' )
    end select

  end subroutine GetFullBlock

  ! ----------------------------------  GetKindFromMatrixDatabase  -----
  integer function GetKindFromMatrixDatabase ( DatabaseElement )
  ! Return the kind of a matrix database element
    type(matrix_Database_T), intent(in) :: DatabaseElement
    getKindFromMatrixDatabase = k_empty
    if ( associated(databaseElement%cholesky) ) &
      & getKindFromMatrixDatabase = k_cholesky
    if ( associated(databaseElement%kronecker) ) &
      & getKindFromMatrixDatabase = k_kronecker
    if ( associated(databaseElement%matrix) ) &
      & getKindFromMatrixDatabase = k_plain
    if ( associated(databaseElement%spd) ) getKindFromMatrixDatabase = k_spd
  end function GetKindFromMatrixDatabase

  ! -----------------------------------  GetKroneckerFromDatabase  -----
  subroutine GetKroneckerFromDatabase ( DatabaseElement, Kronecker )
  ! Get a POINTER to a Kronecker object from DatabaseElement.
    type(matrix_Database_T), intent(in) :: DatabaseElement
    type(matrix_kronecker_T), pointer :: Kronecker
    kronecker => databaseElement%kronecker
  end subroutine GetKroneckerFromDatabase

  ! -----------------------------------------  GetMatrixElement_1  -----
  real(rm) function GetMatrixElement_1 ( Matrix, Row, Col )
  ! Get the (row,col) element of Matrix
    type(matrix_T), intent(in) :: Matrix
    integer, intent(in) :: Row, Col

    integer :: I, J      ! Block of Matrix
    integer :: II, JJ    ! Element of matrix%block(i,j)
    integer :: MM, NN    ! Number of rows and columns in blocks before (i,j)

    if ( .not. associated(matrix%block) ) call MLSMessage ( MLSMSG_Error, &
      & "Block not associated in GetMatrixElement", moduleName )
    ii = 0
    jj = 0
    mm = 0
    nn = 0
    if ( row > 0 ) then
      do i = 1, matrix%row%nb
        if ( mm + matrix%block(i,1)%nrows >= row ) then
          ii = row - mm
          exit
        end if
        mm = mm + matrix%block(i,1)%nrows
      end do ! i
    end if
    if ( col > 0 ) then
      do j = 1, matrix%col%nb
        if ( nn + matrix%block(1,j)%ncols >= col ) then
          jj = col - nn
          exit
        end if
        nn = nn + matrix%block(1,j)%ncols
      end do
    end if
    if ( ii == 0 .or. jj == 0 ) call MLSMessage ( MLSMSG_Error, &
      & "Row or Column subscript out-of-bounds in GetMatrixElement", &
      & moduleName )
    getMatrixElement_1 = getMatrixElement ( matrix%block(i,j), ii, jj )
  end function GetMatrixElement_1

  ! --------------------------------------  GetMatrixFromDatabase  -----
  subroutine GetMatrixFromDatabase ( DatabaseElement, Matrix, Fail )
  ! Get a POINTER to a matrix object from DatabaseElement.
    use MLSMessageModule, only: MLSMSG_Crash
    type(matrix_Database_T), intent(in) :: DatabaseElement
    type(matrix_T), pointer :: Matrix
    logical, intent(out), optional :: Fail ! "No matrix to get from database"
    if ( present(fail) ) fail = .false.    ! Assume it will work
    matrix => databaseElement%matrix
    if ( associated(matrix) ) return
    if ( associated(databaseElement%Cholesky) ) matrix => databaseElement%Cholesky%m
    if ( associated(matrix) ) return
    if ( associated(databaseElement%Kronecker) ) matrix => databaseElement%Kronecker%m
    if ( associated(matrix) ) return
    if ( associated(databaseElement%SPD) ) matrix => databaseElement%SPD%m
    if ( associated(matrix) ) return
    if ( .not. present(fail) ) call MLSMessage ( MLSMSG_Crash, moduleName, &
      & "No matrix to get from database" )
    fail = .true.
  end subroutine GetMatrixFromDatabase

  ! -----------------------------------------  GetSPDFromDatabase  -----
  subroutine GetSPDFromDatabase ( DatabaseElement, SPD )
  ! Get a POINTER to a SPD object from DatabaseElement.
    type(matrix_Database_T), intent(in) :: DatabaseElement
    type(matrix_SPD_T), pointer :: SPD
    SPD => databaseElement%SPD
  end subroutine GetSPDFromDatabase

  ! --------------------------------------  GetVectorFromColumn_1  -----
  subroutine GetVectorFromColumn_1 ( Matrix, Column, Vector, RowQty )
  ! Fill Vector%quantities(...)%values from the Column of the Matrix.
  ! This routine doesn't copy the geolocation information from the
  ! Matrix to the Vector.  It's assumed already to be in the Vector.
  ! If RowQty is present only get that vector quantity.
    type(matrix_T), intent(in) :: Matrix
    integer, intent(in) :: Column
    type(vector_T), intent(inout) :: Vector  ! Must already be "created"
    integer, intent(in), optional :: RowQty

    integer :: Block          ! Which block of columns contains Column?
    integer :: ColInBlock     ! Which column in Block is column
    integer :: Ncols          ! How many columns in blocks < Block?
    integer :: Row            ! Which row is being extracted?
    integer :: Row1,RowN      ! Range for Row

    if ( column < 1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'In "GetVectorFromColumn_1", "Column" < 1' )
    if ( matrix%row%vec%template%name /= vector%template%name ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Vector incompatible with matrix in GetVectorFromColumn_1" )
    ncols = 0
    row1 = 1
    rowN = matrix%row%nb
    if ( present(rowQty) ) then
      row1 = rowQty; rowN = rowQty
    end if
    do block = 1, matrix%col%nb
      if ( ncols + matrix%col%nelts(block) >= column ) then
        colInBlock = column - ncols
        do row = row1, rowN
          call getVectorFromColumn ( matrix%block(row,block), colInBlock, &
            & vector%quantities(matrix%row%quant(row))% &
            & values(:,matrix%row%inst(row)) )
        end do ! row = 1, matrix%row%nb
        return
      end if
      ncols = ncols + matrix%col%nelts(block)
    end do ! block = 1, matrix%col%nb
    call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'In "GetVectorFromColumn_1", "Column" is greater than number&
      & of columns in "Matrix"')
  end subroutine GetVectorFromColumn_1

  ! ----------------------------------  GetVectorFromColumn_1_Q_I  -----
  subroutine GetVectorFromColumn_1_Q_I ( Matrix, Qty, Inst, Vector, RowQty )
  ! Fill Vector%quantities(...)%values from the Inst column of Qty of
  ! the matrix.  This routine doesn't copy the geolocation information
  ! from the Matrix to the Vector.  It's assumed already to be in the
  ! Vector.
    type(matrix_T), intent(in) :: Matrix
    integer, intent(in) :: Qty, Inst
    type(vector_T), intent(inout) :: Vector  ! Must already be "created"
    integer, intent(in), optional :: RowQty

    integer :: row
    integer :: Row1,RowN      ! Range for Row

    if ( matrix%row%vec%template%name /= vector%template%name ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Vector incompatible with matrix in GetVectorFromColumn_1_Q_I" )
    if ( qty < 1 .or. qty > size(vector%quantities) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'In "GetVectorFromColumn_1_Q_I", "Qty" is out of range' )
    if ( inst < 1 .or. inst > size(vector%quantities(qty)%values) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'In "GetVectorFromColumn_1_Q_I", "Inst" is out of range' )
    row1 = 1
    rowN = matrix%row%nb
    if ( present(rowQty) ) then
      row1 = rowQty; rowN = rowQty
    end if
    do row = row1, rowN
      call getVectorFromColumn ( matrix%block(row,qty), inst, &
        & vector%quantities(matrix%row%quant(row))% &
        & values(:,matrix%row%inst(row)) )
    end do ! row = 1, matrix%row%nb
  end subroutine GetVectorFromColumn_1_Q_I

  ! -------------------------------------------  InvertCholesky_1  -----
  subroutine InvertCholesky_1 ( U, B )
  !{Compute $B = U^{-1}$, where $U$ is the upper-triangular Cholesky factor of
  ! some matrix, i.e. $A = U^T U$.
  !
  ! Let $u_{ij}$ be an element of $\bf U$ and $t_{ij}$ be an element of ${\bf
  ! U}^{-1}$. To invert $\bf U$, solve $\sum_{l=i}^j t_{il} u_{lj} =
  ! \delta_{ij}$ for $t_{ij}$, where $\delta_{ij} = \bf I$ for $i = j$ and zero
  ! otherwise.  (The index of summation $l$ runs from $i$ to $j$ instead of
  ! from $1$ to $n$ because we know that $\bf U$ and ${\bf U}^{-1}$ are
  ! triangular.)  This gives $t_{ii} = u_{ii}^{-1}$ (for $i = j$) and  $t_{ij}
  ! = - \left ( \sum_{l=i}^{j-1} t_{il} u_{lj} \right ) u_{jj}^{-1}$ (for $i <
  ! j$).  We compute the diagonal elements of $U^{-1}$ first, giving the
  ! following algorithm:
  !
  ! \hspace*{0.5in}$t_{ii} := u_{ii}^{-1}~~ i = 1,~ \dots,~ n$\\
  ! \hspace*{0.5in}$\left \{ t_{ij} := -\left ( \sum_{l=i}^{j-1} t_{il} u_{lj}
  !   \right ) t_{jj}~~ j = i+1,~ \dots,~ n \right \}~~ i = 1,~ \dots,~ n-1$

    type(Matrix_Cholesky_T), intent(inout) :: U ! inout because invertCholesky's
                                        ! U argument is inout to allow its UI
                                        ! argument to be the same.  We don't
                                        ! use that feature, so U isn't changed
                                        ! here.
    type(Matrix_T), intent(inout) :: B  ! Assume B has been created

    integer :: I, J, K                  ! Subscripts and loop inductors

    type(matrixElement_T) :: Temp       ! Because we can't do X := X * Y
    logical :: Update

    ! First invert the diagonal blocks
    do j = 1, u%m%row%nb
      call invertCholesky ( u%m%block(j,j), b%block(j,j) )
    end do

    ! Now compute the rest of the blocks of the inverse, a row at a time
    do i = 1, u%m%row%nb-1
      do j = i+1, u%m%row%nb
        update = .false.
        call DestroyBlock ( temp )
        do k = i, j-1
          call multiplyMatrix_XY ( b%block(i,k), u%m%block(k,j), temp, &
            & update=update, subtract=.true. )
          update = .true.
        end do
        call multiplyMatrix_XY ( temp, b%block(j,j), b%block(i,j) )
      end do
    end do
    call destroyBlock ( temp )
  end subroutine InvertCholesky_1

  ! ------------------------------------  LevenbergUpdateCholesky  -----
! subroutine LevenbergUpdateCholesky ( Z, LAMBDA )
! ! Given a Cholesky factor Z of a matrix of normal equations A^T A,
! ! update the Cholesky factor to incorporate Levenberg-Marquardt
! ! stabilization that corresponds to augmenting A with LAMBDA I.
!   type(Matrix_T), intent(inout) :: Z
!   real(rm), intent(in) :: LAMBDA
! end subroutine LevenbergUpdateCholesky

  ! ----------------------------------------  MatricesMemoryInUse  -----
  integer function MatricesMemoryInUse ( D )
  ! Report the number of real(rm) elements in all matrices in the
  ! database.
    type(matrix_database_T), dimension(:), pointer :: D
    integer :: I

    matricesMemoryInUse = 0
    if ( .not. associated(d) ) return
    do i = 1, size(d)
      if ( associated(d(i)%matrix) ) then
        matricesMemoryInUse = matricesMemoryInUse + &
          & matrixMemoryInUse ( d(i)%matrix )
      end if
      if ( associated(d(i)%cholesky) ) then
        matricesMemoryInUse = matricesMemoryInUse + &
          & matrixMemoryInUse ( d(i)%cholesky%m )
      end if
      if ( associated(d(i)%kronecker) ) then
        matricesMemoryInUse = matricesMemoryInUse + &
          & matrixMemoryInUse ( d(i)%kronecker%m )
      end if
      if ( associated(d(i)%spd) ) then
        matricesMemoryInUse = matricesMemoryInUse + &
          & matrixMemoryInUse ( d(i)%spd%m )
      end if
    end do

  end function MatricesMemoryInUse

  ! ------------------------------------------  MatrixMemoryInUse  -----
  integer function MatrixMemoryInUse ( M )
  ! Report the number of real(rm) elements in matrix M
    type(Matrix_T), intent(in) :: M
    integer :: I, J

    matrixMemoryInUse = 0
    do i = 1, m%row%nb
      do j = 1, m%col%nb
        if ( associated(m%block(i,j)%value1) ) &
          & matrixMemoryInUse = matrixMemoryInUse + size(m%block(i,j)%value1)
      end do
    end do

  end function MatrixMemoryInUse

  ! ------------------------------------------------  MaxAbsVal_1  -----
  real(rm) function MaxAbsVal_1 ( A )
  ! Return the magnitude of the element in A that has the largest magnitude.
    type(Matrix_T), intent(in) :: A
    integer :: I, J
    maxAbsVal_1 = 0.0_rm
    do i = 1, a%row%nb
      do j = 1, a%col%nb
        if ( a%block(i,j)%kind /= m_absent ) &
          & maxAbsVal_1 = max(maxAbsVal_1,maxAbsVal(a%block(i,j)))
      end do
    end do
  end function MaxAbsVal_1

  ! ------------------------------------------------------  MaxL1  -----
  real(rm) function MaxL1 ( A )
  ! Return the L1 norm of the column in A that has the largest L1 norm.
    type(Matrix_T), intent(in) :: A
    integer :: I, J, K
    real(rm) :: My_L1
    maxL1 = 0.0_rm
    do j = 1, a%col%nb
      do k = 1, a%block(1,j)%ncols
        my_L1 = 0.0_rm
        do i = 1, a%row%nb
          my_L1 = my_L1 + col_L1(a%block(i,j),k)
        end do
        maxL1 = max(maxL1, my_L1)
      end do
    end do
  end function MaxL1

  ! -------------------------------------------  MinDiag_Cholesky  -----
  real(rm) function MinDiag_Cholesky ( A )
  ! Return the magnitude of the element on the diagonal of A that has the
  ! smallest magnitude.
    type(Matrix_Cholesky_T), intent(in) :: A
    minDiag_Cholesky = minDiag_1 ( a%m )
  end function MinDiag_Cholesky

  ! ------------------------------------------------  MinDiag_SPD  -----
  real(rm) function MinDiag_SPD ( A )
  ! Return the magnitude of the element on the diagonal of A that has the
  ! smallest magnitude.
    type(Matrix_SPD_T), intent(in) :: A
    minDiag_SPD = minDiag_1 ( a%m )
  end function MinDiag_SPD

  ! ---------------------------------------  MultiplyMatrix_XTY_1  -----
  subroutine MultiplyMatrix_XTY_1 ( X, Y, Z, update, useMask, maskX, maskY )
    ! Z = [ Z + ] X^T Y
    type(Matrix_T), intent(in) :: X, Y
    type(Matrix_T), intent(inout) :: Z
    logical, optional, intent(in) :: UPDATE
    logical, optional, intent(in) :: USEMASK
    logical, optional, intent(in) :: MASKX
    logical, optional, intent(in) :: MASKY

    ! Note the masking only applies to the columns of X,Y row masking is not
    ! performed.

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyMatrix using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignMatrix.
  ! !!!!! ===== END NOTE ===== !!!!!

    integer :: I, J, K             ! Subscripts for [XYZ]%Block
    logical :: MYUSEMASK
    logical :: MYMASKX
    logical :: MYMASKY
    logical :: MYUPDATE
    character, dimension(:), pointer :: MI, MJ ! Masks for columns I/J if any

    myusemask = .false.
    myMaskX = .false.
    myMaskY = .false.
    if ( present ( useMask ) ) myUseMask = .true.
    if ( myUseMask ) then
      myMaskX = .true.
      myMaskY = .true.
    end if
    if ( present ( maskX ) ) myMaskX = maskX
    if ( present ( maskY ) ) myMaskY = maskY
    myUpdate = .false.
    if ( present ( update ) ) myUpdate = update

    ! Check that matrices are compatible.  We don't need to check
    ! Nelts or Nb, because these are deduced from Vec.
    if ( (x%row%vec%template%name /= y%row%vec%template%name)  .or. &
      & (x%row%instFirst .neqv. y%row%instFirst) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Incompatible arrays in MultiplyMatrix_XTY_1" )
    if ( myUpdate ) then
    else
      if ( (z%row%vec%template%name /= x%col%vec%template%name) .or. &
        &  (x%row%instFirst .neqv. x%col%instFirst) .or.&
        &  (z%col%vec%template%name /= y%col%vec%template%name) .or. &
        &  (x%col%instFirst .neqv. y%col%instFirst) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Incompatible destination for MultiplyMatrix_XTY_1" )
      call nullifyMatrix ( z ) ! for Sun's still useless compiler
      call createEmptyMatrix ( z, 0, x%col%vec, y%col%vec )
    end if
    do j = 1, y%col%nb
      nullify ( mj )
      if ( associated(y%col%vec%quantities(y%col%quant(j))%mask) .and. myMaskY ) &
        & mj => y%col%vec%quantities(y%col%quant(j))%mask(:,y%col%inst(j))
      !$OMP PARALLEL DO private ( mi, k )
      do i = 1, x%col%nb
        nullify ( mi )
        if ( associated(x%col%vec%quantities(x%col%quant(i))%mask) .and. myMaskX ) &
          & mi => x%col%vec%quantities(x%col%quant(i))%mask(:,x%col%inst(i))
        do k = 1, x%row%nb
          call multiply ( x%block(k,i), y%block(k,j), z%block(i,j), &
            & update=myUpdate .or. k > 1, xMask=mi, yMask=mj )
        end do ! k = 2, x%row%nb
      end do ! i = 1, x%col%nb
      !$OMP END PARALLEL DO
    end do ! j = 1, y%col%nb
  end subroutine MultiplyMatrix_XTY_1

  ! ----------------------------------------  MultiplyMatrix_XY_1  -----
  subroutine MultiplyMatrix_XY_1 ( X, Y, Z ) ! Z = X Y
    type(Matrix_T), intent(in) :: X, Y
    type(Matrix_T), intent(inout) :: Z

    integer :: I, J, K             ! Subscripts for [XYZ]%Block

    ! Check that matrices are compatible.  We don't need to check
    ! Nelts or Nb, because these are deduced from Vec.
    if ( (x%col%vec%template%name /= y%row%vec%template%name)  .or. &
      & (x%col%instFirst .neqv. y%row%instFirst) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Incompatible arrays in MultiplyMatrix_XY_1" )
    call createEmptyMatrix ( z, 0, x%row%vec, y%col%vec )
    do j = 1, y%col%nb
      !$OMP PARALLEL DO private ( k )
      do i = 1, x%row%nb
        call multiplyMatrix_XY ( x%block(i,1), y%block(1,j), z%block(i,j) )
        do k = 2, x%col%nb
          call multiplyMatrix_XY ( x%block(i,k), y%block(k,j), z%block(i,j), &
            & update=.true. )
        end do ! k = 2, x%col%nb
      end do ! i = 1, x%row%nb
      !$OMP END PARALLEL DO
    end do ! j = 1, y%col%nb
  end subroutine MultiplyMatrix_XY_1

  ! --------------------------------------  MultiplyMatrix_XY_T_1  -----
  subroutine MultiplyMatrix_XY_T_1 ( X, Y, Z, diagonalOnly ) ! Z = X Y^T
    type(Matrix_T), intent(in) :: X, Y
    type(Matrix_T), intent(inout) :: Z
    logical, intent(in), optional :: DIAGONALONLY

    integer :: I, J, K                  ! Subscripts for [XYZ]%Block
    integer :: I0, I1                   ! Loop limits
    logical :: MYDIAGONALONLY           ! Copy of diagonal only

    ! Check that matrices are compatible.  We don't need to check
    ! Nelts or Nb, because these are deduced from Vec.
    if ( (x%col%vec%template%name /= y%col%vec%template%name)  .or. &
      & (x%col%instFirst .neqv. y%col%instFirst) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Incompatible arrays in MultiplyMatrix_XY_T_1" )
    myDiagonalOnly = .false.
    if ( present ( diagonalOnly ) ) myDiagonalOnly = diagonalOnly

    call createEmptyMatrix ( z, 0, x%row%vec, y%row%vec )
    !$OMP PARALLEL DO private ( i, i0, i1, k )
    do j = 1, y%row%nb
      if ( myDiagonalOnly ) then
        i0 = j
        i1 = j
      else
        i0 =  1
        i1 = x%row%nb
      end if
      do i = i0, i1
        call multiplyMatrix_XY_T ( x%block(i,1), y%block(j,1), z%block(i,j) )
        do k = 2, x%col%nb
          call multiplyMatrix_XY_T ( x%block(i,k), y%block(j,k), z%block(i,j), &
            & update=.true. )
        end do ! k = 2, x%col%nb
      end do ! i = 1, x%row%nb
    end do ! j = 1, y%row%nb
    !$OMP END PARALLEL DO
  end subroutine MultiplyMatrix_XY_T_1

  ! -------------------------------------  MultiplyMatrixVector_1  -----
  subroutine MultiplyMatrixVector_1 ( A, V, Z, UPDATE, UseMask, Clone )
  ! Z = A^T V if UPDATE is absent or false.  Z is first cloned from V.
  ! Z = Z + A^T V is UPDATE is present and true.

  ! If UseMask is present and true, the column mask of A is used to
  ! suppress columns.  If Clone is present and true and Update is absent
  ! or false, clone Z to be like V.
    type(Matrix_T), intent(in) :: A
    type(Vector_T), intent(in) :: V
    type(Vector_T), intent(inout) :: Z
    logical, intent(in), optional :: UPDATE
    logical, intent(in), optional :: UseMask
    logical, intent(in), optional :: Clone

    logical :: DO_UPDATE      ! Tells MatrixModule_0 % multiplyMatrixVector
    !                           whether to clear an element of Z, or add to it
    integer :: I, J           ! Subscripts and loop inductors
    integer :: K, L, M, N     ! Subscripts
    character, dimension(:), pointer :: MJ ! Mask for column J, if any
    logical :: My_Clone       ! My copy of Clone or false if it's absent
    logical :: My_Mask        ! My copy of UseMask or false if it's absent
    logical :: MY_UPDATE      ! My copy of UPDATE or false if it's absent

    if ( a%row%vec%template%name /= v%template%name ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Matrix and vector not compatible in MultiplyMatrixVector_1" )
    my_update = .false.
    if ( present(update) ) my_update = update
    my_mask = .false.
    if ( present(useMask) ) my_mask = useMask
    my_clone = .false.
    if ( present(clone) ) my_clone = clone
    if ( (my_update .or. .not. my_clone) .and. &
      & a%col%vec%template%name /= z%template%name ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Matrix and result not compatible in MultiplyMatrixVector_1" )
    ! Copy characteristics, allocate values:
    if ( my_clone .and. .not. my_update ) &
      & call cloneVector ( z, v, vectorNameText='_z' )
    do j = 1, a%col%nb
      k = a%col%quant(j)
      l = a%col%inst(j)
      nullify ( mj )
      if ( associated(a%col%vec%quantities(k)%mask) .and. my_mask ) &
        & mj => a%col%vec%quantities(k)%mask(:,l)
      do_update = my_update
      do i = 1, a%row%nb
        m = a%row%quant(i)
        n = a%row%inst(i)
        call multiply ( a%block(i,j), v%quantities(m)%values(:,n), &
          & z%quantities(k)%values(:,l), do_update, mask=mj )
        do_update = .true.
      end do ! i = 1, a%row%nb
    end do ! j = 1, a%col%nb
  end subroutine MultiplyMatrixVector_1

  ! ----------------------------------  MultiplyMatrixVectorNoT_1  -----
  subroutine MultiplyMatrixVectorNoT_1 ( A, V, Z, UPDATE, Clone, Instance, Row )
  ! Z = A V if UPDATE is absent or false.
  ! Z = Z + A V if UPDATE is presend and true.
  ! If Clone is present and true and Update is absent or false, clone Z
  ! to be like A%Row%Vec.
    type(Matrix_T), intent(in) :: A
    type(Vector_T), intent(in) :: V
    type(Vector_T), intent(inout) :: Z
    logical, intent(in), optional :: UPDATE
    logical, intent(in), optional :: Clone
    integer, intent(in), optional :: Instance ! Only do this instance
    integer, intent(in), optional :: Row      ! Only do this row

    logical :: DO_UPDATE      ! Tells MatrixModule_0 % multiplyMatrixVectorNoT
    !                           whether to clear an element of Z, or add to it
    integer :: I, J           ! Subscripts and loop inductors
    integer :: K, L, M, N     ! Subscripts
    logical :: My_Clone       ! My copy of Clone or false if it's absent
    logical :: MY_UPDATE      ! My copy of UPDATE or false if it's absent
    integer :: Row1, RowN

    if ( a%col%vec%template%name /= v%template%name ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Matrix and vector not compatible in MultiplyMatrixVector_1" )
    my_update = .false.
    if ( present(update) ) my_update = update
    my_clone = .false.
    if ( present(clone) ) my_clone = clone
    if ( (my_update .or. .not. my_clone) .and. &
      & a%row%vec%template%name /= z%template%name ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Matrix and result not compatible in MultiplyMatrixVector_1" )
    ! Copy characteristics, allocate values:
    if ( my_clone .and. .not. my_update ) &
      & call cloneVector ( z, a%row%vec, vectorNameText='_z' )
    row1 = 1
    rowN = a%row%nb
    if ( present(row) ) then
      row1 = row
      rowN = row
    end if
    do i = row1, rowN
      m = a%row%quant(i)
      n = a%row%inst(i)
      do_update = my_update
      do j = 1, a%col%nb
        k = a%col%quant(j)
        l = a%col%inst(j)
        if ( present(instance) ) then
          if ( l /= instance ) cycle
        end if
        call multiplyMatrixVectorNoT ( a%block(i,j), &
          & v%quantities(k)%values(:,l), z%quantities(m)%values(:,n), &
          & do_update )
        do_update = .true.
      end do ! i = 1, a%row%nb
    end do ! j = 1, a%col%nb
  end subroutine MultiplyMatrixVectorNoT_1

  ! ----------------------------------  MultiplyMatrixVectorSPD_1  -----
  subroutine MultiplyMatrixVectorSPD_1 ( A, V, Z, UPDATE )
  ! Z = A V if UPDATE is absent or false.
  ! Z = Z + A V is UPDATE is present and true.
  ! Remember that for SPD, only the upper triangle is stored, so we need
  ! Z = A^T V + A V except don't do the diagonal twice.
    type(Matrix_SPD_T), intent(in) :: A
    type(Vector_T), intent(in) :: V
    type(Vector_T), intent(inout) :: Z
    logical, optional, intent(in) :: UPDATE

    integer :: I, J           ! Subscripts and loop inductors
    integer :: K, L, M, N     ! Subscripts

    call multiply ( a%m, v, z, update ) ! A^T V
    do j = 1, a%m%col%nb
      k = a%m%col%quant(j)
      l = a%m%col%inst(j)
      do i = 1, j
        m = a%m%row%quant(i)
        n = a%m%row%inst(i)
        call multiplyMatrixVectorNoT ( a%m%block(i,j), &
          & v%quantities(k)%values(:,l), z%quantities(m)%values(:,n), &
          & update=.true., doDiag = i /= j )
      end do ! i = 1, j
    end do ! j = 1, a%m%col%nb
  end subroutine MultiplyMatrixVectorSPD_1

  ! ---------------------------------------------------  Negate_1  -----
  subroutine Negate_1 ( A ) ! A = -A
    type(Matrix_T), intent(inout) :: A
    integer :: I, J
    do i = 1, a%row%nb
      do j = 1, a%col%nb
        if ( a%block(i,j)%kind /= m_absent ) &
          & a%block(i,j)%values = -a%block(i,j)%values
      end do
    end do
  end subroutine Negate_1

  ! ------------------------------------  NewMultiplyMatrixVector  -----
  function NewMultiplyMatrixVector ( A, V ) result ( Z ) ! Z = A^T V
    type(Matrix_T), intent(in) :: A
    type(Vector_T), intent(in) :: V
    type(Vector_T) :: Z
    call nullifyVector ( z ) ! for Sun's still useless compiler
    call multiply ( a, v, z, .false. )
  end function NewMultiplyMatrixVector

  ! --------------------------------------------  NormalEquations  -----
  subroutine NormalEquations ( A, Z, RHS_IN, RHS_OUT, UPDATE, ROW_BLOCK, &
    & UseMask )
  ! If UPDATE is absent, or present but false, form normal equations of the
  ! least-squares problem A X = RHS_IN. Z = A^T A and RHS_OUT = A^T RHS_IN.
  ! If UPDATE is present and true, update normal equations of the least-
  ! squares problem A X = RHS_IN. Z = Z + A^T A and RHS_OUT = RHS_OUT + A^T
  ! RHS_IN. If ROW_BLOCK is present, it specifies that only that row of
  ! blocks of A is to be accumulated.
  ! Only the upper triangle of A^T A is formed or updated.

  ! If UseMask is present and true, the column mask is used to suppress
  ! columns of the normal equations.

    type(Matrix_T), intent(inout) :: A       ! inout only to allow
    !                                          clearing masked rows
    type(Matrix_SPD_T), intent(inout) :: Z
    type(Vector_T), intent(inout), optional :: RHS_IN ! inout only to allow
    !                                          clearing masked rows
    type(Vector_T), intent(inout), optional :: RHS_OUT
    logical, intent(in), optional :: UPDATE  ! True (default false) means
    !                                          to update Z and RHS_OUT
    integer, intent(in), optional :: ROW_BLOCK
    logical, intent(in), optional :: UseMask

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! If this subroutine is invoked with UPDATE absent, or present and false,
  ! It is important to invoke DestroyMatrix using the Z argument of this
  ! subroutine after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignMatrix.
  ! !!!!! ===== END NOTE ===== !!!!!

    logical :: DO_UPDATE
    integer :: I, J, K             ! Subscripts for [AZ]%Block
    character, dimension(:), pointer :: MI, MJ ! Masks for columns I, J if any
    logical :: My_Mask
    logical :: MY_UPDATE
    integer :: R1, R2              ! Rows upon which to operate

    ! Compute Z = A^T A or Z = Z + A^T A
    my_update = .false.
    if ( present(update) ) my_update = update
    if ( .not. my_update ) &
      & call createEmptyMatrix ( z%m, 0, a%col%vec, a%col%vec )
    my_Mask = .false.
    if ( present(useMask) ) my_Mask = useMask
    if ( my_Mask ) then
      call copyVector ( rhs_in, a%row%vec, noValues=.true.) ! Copy the row mask
      call clearRows ( a, row_block, rhs_in )
    end if
    r1 = 1
    if ( present(row_block) ) r1 = row_block
    do j = 1, a%col%nb
      nullify ( mj )
      if ( associated(a%col%vec%quantities(a%col%quant(j))%mask) .and. my_Mask) &
        & mj => a%col%vec%quantities(a%col%quant(j))%mask(:,a%col%inst(j))
      r2 = j
      if ( present(row_block) ) r2 = min(j,row_block)
      do i = r1, r2
        nullify ( mi )
        if ( associated(a%col%vec%quantities(a%col%quant(i))%mask) .and. my_Mask ) &
          & mi => a%col%vec%quantities(a%col%quant(i))%mask(:,a%col%inst(i))
        do_update = my_update
        do k = 1, a%row%nb
          call multiply ( a%block(k,i), a%block(k,j), z%m%block(i,j), &
            & update=do_update, xmask=mi, ymask=mj, upper = i == j )
          do_update = .true.
        end do ! k = 1, a%row%nb
      end do ! i = r1, r2
    end do ! j = 1, a%col%nb

    if ( present(rhs_in) .and. present(rhs_out) ) &
      & call multiply ( a, rhs_in, rhs_out, my_update, useMask = my_mask )
  end subroutine NormalEquations

  ! ---------------------------------------------- NullifyMatrix_1 -----
  subroutine NullifyMatrix_1 ( M )
    ! Given a matrix, nullify all the pointers associated with it
    type ( Matrix_T ), intent(out) :: M

    ! Executable code
    m%name = 0
    call nullifyRCInfo ( m%col )
    call nullifyRCInfo ( m%row )
    nullify ( m%block )
  end subroutine NullifyMatrix_1

  ! ---------------------------------------------- NullifyRCInfo -----
  subroutine NullifyRCInfo ( R )
    ! Given an RCInfo type, nullify all the pointers associated with it
    type ( RC_Info ), intent(out) :: R

    ! Executable code
!     nullify ( r%vec )
    call nullifyVector ( r%vec )
    r%nb = 0
    r%instFirst = .true.
    nullify ( r%nelts )
    nullify ( r%inst )
    nullify ( r%quant )
  end subroutine NullifyRCInfo

  ! ---------------------------------------------- ReflectMatrix_1 -----
  subroutine ReflectMatrix_1 ( M )
    ! Given a matrix M, copy the upper triangle into the lower
    type ( Matrix_T), intent(inout) :: M
    ! Local variables
    integer :: I, J             ! Loop counters

    ! Executable code
    do i = 1, m%row%nb
      call ReflectMatrix ( m%block ( i,i ) )
      do j = i + 1, m%col%nb
        call TransposeMatrix ( m%block ( j, i ), m%block ( i, j ) )
      end do
    end do
  end subroutine ReflectMatrix_1

  ! -------------------------------------------------  RowScale_1  -----
  subroutine RowScale_1 ( V, X, NEWX, RowBlock )
  ! Z = V X where V is a diagonal matrix represented by a vector and Z
  !   is X or NEWX.
  ! If RowBlock is present, only that block of rows is scaled.

    type (Vector_T), intent(in) :: V
    type (Matrix_T), intent(inout), target :: X
    type (Matrix_T), intent(inout), target, optional :: NEWX ! intent(inout)
      !                            so that the destroyMatrix in createEmptyMatrix
      !                            gets a chance to clean up surds
    integer, intent(in), optional :: RowBlock

    integer :: I, J      ! Subscripts for [XZ]%Block
    integer :: R1, R2    ! First and last rows to scale

    if ( present(rowBlock) ) then
      r1 = rowBlock
      r2 = rowBlock
    else
      r1 = 1
      r2 = x%row%nb
    end if
    if ( present(newx) ) then
      call createEmptyMatrix ( newx, 0, x%row%vec, x%col%vec, &
        & x%row%instFirst, x%col%instFirst )
      do j = 1, x%col%nb
        do i = r1, r2
          call RowScale ( &
            & v%quantities(x%row%quant(i))%values(:,x%row%inst(i)), &
            & x%block(i,j), newx%block(i,j) )
        end do ! i = r1, r2
      end do ! j = x%col%nb
    else
      do j = 1, x%col%nb
        do i = r1, r2
          call RowScale ( &
            & v%quantities(x%row%quant(i))%values(:,x%row%inst(i)), &
            & x%block(i,j) )
        end do ! i = r1, r2
      end do ! j = x%col%nb
    end if
  end subroutine RowScale_1

  ! ------------------------------------------------  ScaleMatrix  -----
  subroutine ScaleMatrix ( Z, A )       ! Z := A * Z, where A is scalar
    type(matrix_T), intent(inout) :: Z
    real(r8), intent(in) :: A
    integer :: I, J                     ! Subscripts and loop inductors
    do i = 1, z%row%nb
      do j = 1, z%col%nb
        call scaleBlock ( z%block(i,j), a )
      end do ! j
    end do ! i
  end subroutine ScaleMatrix

  ! --------------------------------------------  SolveCholesky_1  -----
  subroutine SolveCholesky_1 ( Z, X, RHS, TRANSPOSE, STATUS )
  ! Given the Cholesky-factored normal equations Z and the corresponding
  ! RHS, Solve Z X = RHS for X if TRANSPOSE is absent, or present and
  ! false.  Solve Z^T X = RHS for X if TRANSPOSE is present and true.
  ! RHS may be the same as X.  RHS may be absent, in which case X is
  ! assumed to contain the right-hand side on input, and the solution
  ! replaces it on output.
    type(Matrix_Cholesky_T), intent(in) :: Z
    type(Vector_T), intent(inout), target :: X
    type(Vector_T), intent(in), target, optional :: RHS
    logical, optional, intent(in) :: TRANSPOSE
    integer, dimension(2), optional, intent(out) :: STATUS

    integer :: I, J                ! Subscripts and loop inductors
    integer :: IC, IR, QC, QR      ! Instance and quantity indices
    logical My_transpose           ! TRANSPOSE if present, else .false.
    integer :: BLOCKSTATUS         ! Status for one block
    character(len=132) :: LINE     ! An error message

    my_transpose = .false.
    if ( present(transpose) ) my_transpose = transpose
    if ( present(rhs) ) call copyVector ( x, rhs ) ! X := RHS
    if ( z%m%col%vec%template%name /= x%template%name ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Z and RHS not compatible in SolveCholesky_1" )

    if ( my_transpose ) then       ! Solve Z^T X = RHS for X
      do i = 1, z%m%col%nb
        ic = z%m%col%inst(i)
        qc = z%m%col%quant(i)
        do j = 1, i-1
          ir = z%m%row%inst(j)
          qr = z%m%row%quant(j)
          ! x := x - block^T * x
          call multiply ( z%m%block(j,i), x%quantities(qr)%values(:,ir), &
            & x%quantities(qc)%values(:,ic), update=.true., subtract=.true. )
        end do ! j = 1, i-1
        call solveCholesky ( z%m%block(i,i), x%quantities(qc)%values(:,ic), &
          & transpose=.true., status=blockStatus )
        if ( blockStatus /= 0 ) then
          if ( present ( status ) ) then
            call output ( 'Unable to solve block ' )
            call DescribeBlock ( z%m, i, i )
            status = (/ i, blockStatus /)
            return
          else
            call dump ( z%m%block(i,i), name='Guilty party:' )
            write ( line, '(a, i0, a, i0, a, i0, a)') &
              & 'Block (',i,',',i,') of matrix is not positive definite (element ', &
              & blockStatus, ')'
            call MLSMessage ( MLSMSG_Error, ModuleName, line )
          end if
        end if
      end do ! i = 1, z%m%col%nb
    else                           ! Solve Z X = RHS for X
      do i = z%m%col%nb, 1, -1
        ic = z%m%row%inst(i)
        qc = z%m%row%quant(i)
        do j = i+1, z%m%col%nb
          ir = z%m%col%inst(j)
          qr = z%m%col%quant(j)
          ! x := x - block * x
          call multiplyMatrixVectorNoT ( z%m%block(i,j), &
            & x%quantities(qr)%values(:,ir), x%quantities(qc)%values(:,ic), &
            & update=.true., subtract=.true. )
        end do ! j = i+1, z%m%col%nb
        call solveCholesky ( z%m%block(i,i), x%quantities(qc)%values(:,ic), &
          & transpose=.false., status=blockStatus )
        if ( blockStatus /= 0 ) then
          if ( present ( status ) ) then
            call output ( 'Unable to solve block ' )
            call DescribeBlock ( z%m, i, i )
            status = (/ i, blockStatus /)
            return
          else
            call dump ( z%m%block(i,i), name='Guilty party:' )
            write ( line, '(a, i0, a, i0, a, i0, a)') &
              & 'Block (',i,',',i,') of matrix is not positive definite (element ', &
              & blockStatus, ')'
            call MLSMessage ( MLSMSG_Error, ModuleName, line )
          end if
        end if
      end do ! i = z%m%col%nb, 1, -1
    end if
    if ( present ( status ) ) status = 0
  end subroutine SolveCholesky_1

  ! ----------------------------------------------------  Sparsify_1 ---
  subroutine Sparsify_1 ( M, rowQuantities, colQuantities )
    ! Sparsify the blocks of M (possibly only for blocks associated with
    ! particular quantities?
    type (Matrix_T), intent(inout) :: M
    integer, dimension(:), intent(in), optional :: rowQuantities
    integer, dimension(:), intent(in), optional :: colQuantities
    ! Local variables
    integer :: ROW, COL                 ! Loop counters
    logical :: DOTHIS                   ! Flag
    ! Executable code
    do col = 1, m%col%nb
      doThis = .true.
      if ( present ( colQuantities ) ) doThis = any ( colQuantities == &
        & m%col%vec%template%quantities ( m%col%quant(col) ) )
      if ( doThis ) then
        do row = 1, m%row%nb
          doThis = .true.
          if ( present ( rowQuantities ) ) doThis = any ( rowQuantities == &
            & m%row%vec%template%quantities ( m%row%quant(row) ) )
          if ( doThis ) call Sparsify ( m%block(row,col) )
        end do
      end if
    end do
  end subroutine Sparsify_1

  ! ----------------------------------------------------  Spill_1  -----
  subroutine Spill_1 ( A, Unit, ID, Text )
  ! Spill the matrix A to Fortran Unit, which is presumed to be open
  ! for unformatted output.  The order of output is:
  ! Two integers, giving the number of row blocks and the number of
  ! column blocks, then the blocks in column-major order, as output
  ! by Spill_0.
    type(Matrix_T), intent(in) :: A
    integer, intent(in) :: Unit
    integer, intent(in) :: ID                ! Whatever you like
    character(len=*), intent(in) :: Text     ! Whatever you like

    integer :: I, J                          ! Subscripts and loop inductors

    write ( unit ) id, len(text), text
    write ( unit ) a%row%nb, a%col%nb
    do j = 1, a%col%nb
      do i = 1, a%row%nb
        call spill ( a%block(i,j), unit )
      end do
    end do
  end subroutine Spill_1

  ! ------------------------------------------------ TransposeMatrix_1 -------
  subroutine TransposeMatrix_1 ( Z, A )
    type(Matrix_T), intent(inout) :: Z  ! Output matrix (already created)
    type(Matrix_T), intent(in) :: A     ! Input matrix
    ! Local variables
    integer :: I,J                      ! Loop counters
    ! Executable code
    if ( z%col%vec%template%name /= a%row%vec%template%name .or. &
      &  z%row%vec%template%name /= a%col%vec%template%name .or. &
      &  (z%col%instFirst .neqv. a%col%instFirst) .or. &
      &  (z%row%instFirst .neqv. a%row%instFirst) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Z and A not compatible in TransposeMatrix_1" )
    ! Don't need to clear matrix on Z as the TransposeMatrix_0 calls do that
    do i = 1, z%row%nb
      do j = 1, z%col%nb
        call TransposeMatrix ( z%block(i,j), a%block(j,i) )
      end do
    end do
  end subroutine TransposeMatrix_1

  ! -------------------------------------------  UpdateDiagonal_1  -----
  subroutine UpdateDiagonal_1 ( A, LAMBDA, SQUARE, INVERT )
  ! Add LAMBDA to the diagonal of A.
    type(Matrix_T), intent(inout) :: A
    real(rv), intent(in) :: LAMBDA
    logical, intent(in), optional :: SQUARE ! Update with square of lambda
    logical, intent(in), optional :: INVERT ! Update with inverse of (square
    !                                         of) lambda

    integer :: I
    real(rv) :: MYLAMBDA

    myLambda = lambda
    if ( present(square) ) then
      if (square) myLambda = lambda**2
    end if
    if ( present(invert) ) then
      if ( invert ) then
        if ( abs(myLambda) < tiny(0.0_rm) ) call MLSMessage ( MLSMSG_Error, &
          & ModuleName, "Updating with inverse of near-zero in UpdateDiagonal_1" )
        myLambda = 1.0_rm / myLambda
      end if
    end if

    do i = 1, min(a%row%nb,a%col%nb)
      call updateDiagonal ( a%block(i,i), myLambda )
    end do

  end subroutine UpdateDiagonal_1

  ! ---------------------------------------- UpdateDiagonal_SPD --------
  subroutine UpdateDiagonalSPD_1 ( A, LAMBDA, SQUARE, INVERT )
    ! Add LAMBDA to the diagonal of A.
    type(Matrix_SPD_T), intent(inout) :: A
    real(rv), intent(in) :: LAMBDA
    logical, intent(in), optional :: SQUARE ! Update with square of lambda
    logical, intent(in), optional :: INVERT ! Update with inverse of (square
    call UpdateDiagonal_1 ( A%m, LAMBDA, SQUARE, INVERT )
  end subroutine UpdateDiagonalSPD_1

  ! ----------------------------------------  UpdateDiagonalVec_1  -----
  subroutine UpdateDiagonalVec_1 ( A, X, SUBTRACT, SQUARE, INVERT, FORGIVEZEROS )
  ! Add X to the diagonal of A.
  ! If SUBTRACT is present and true, subtract X from the diagonal.
    type(matrix_SPD_T), intent(inout) :: A
    type(vector_T), intent(in) :: X
    logical, intent(in), optional :: SUBTRACT
    logical, intent(in), optional :: SQUARE ! Update with square of X
    logical, intent(in), optional :: INVERT ! Update with inverse of (square
    !                                         of) X
    logical, intent(in), optional :: FORGIVEZEROS ! Allow zeros in invert case

    integer :: I
    logical :: MYSQUARE

    mySquare = .false.
    if ( present(square) ) mySquare = square

    if ( a%m%col%vec%template%name /= x%template%name ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "A and X not compatible in UpdateDiagonalVec_1" )
    if ( mySquare ) then
      do i = 1, min(a%m%row%nb,a%m%col%nb)
        call updateDiagonal ( a%m%block(i,i), &
          & (x%quantities(a%m%row%quant(i))%values(:,a%m%row%inst(i)))**2, &
          & subtract, invert, forgiveZeros )
      end do
    else
      do i = 1, min(a%m%row%nb,a%m%col%nb)
        call updateDiagonal ( a%m%block(i,i), &
          & x%quantities(a%m%row%quant(i))%values(:,a%m%row%inst(i)), &
          & subtract, invert, forgiveZeros )
      end do
    end if
  end subroutine UpdateDiagonalVec_1

! =====     Private Procedures     =====================================

  ! ------------------------------------  AddItemToMatrixDatabase  -----
  integer function AddItemToMatrixDatabase ( Database, Item )

  ! This routine adds a matrix data base item to the database.  These
  ! items are constructed by AddMatrixToDatabase, AddCholeskyToDatabase,
  ! AddKroneckerToDatabase or AddSPDToDatabase.

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    type(Matrix_Database_T), dimension(:), pointer :: Database
    type(Matrix_Database_T) :: Item

    type(Matrix_Database_T), dimension(:), pointer :: TempDatabase

    include "addItemToDatabase.f9h"

    AddItemToMatrixDatabase = newSize
  end function AddItemToMatrixDatabase

  ! -------------------------------------------------  CopyRCInfo  -----
  subroutine CopyRCInfo ( A, B ) ! A := B
    type(RC_info), intent(inout) :: A
    type(RC_info), intent(in) :: B
    call destroyRCInfo ( a )
!     a%vec => b%vec
    a%vec = b%vec
    a%nb = b%nb
    a%instFirst = b%instFirst
    if ( associated(b%nelts) ) then
      call allocate_test ( a%nelts, size(b%nelts), "a%nelts", &
        & ModuleName // '%CopyRCInfo' )
      a%nelts = b%nelts
    end if
    if ( associated(b%inst) ) then
      call allocate_test ( a%inst, size(b%inst), "a%inst", &
        & ModuleName // '%CopyRCInfo' )
      a%inst = b%inst
    end if
    if ( associated(b%quant) ) then
      call allocate_test ( a%quant, size(b%quant), "a%quant", &
        & ModuleName // '%CopyRCInfo' )
      a%quant = b%quant
    end if
  end subroutine CopyRCInfo

  ! ----------------------------------------------  DestroyRCInfo  -----
  subroutine DestroyRCInfo ( RC )
    type(RC_Info), intent(inout) :: RC
!     nullify ( rc%vec )
    rc%nb = 0
    rc%instFirst = .true.
    call deallocate_test ( rc%nelts, "rc%nelts", ModuleName // '%DestroyRCInfo' )
    call deallocate_test ( rc%inst,  "rc%inst" , ModuleName // '%DestroyRCInfo' )
    call deallocate_test ( rc%quant, "rc%quant", ModuleName // '%DestroyRCInfo' )
  end subroutine DestroyRCInfo

  ! ------------------------------------------------  Diff_Matrices  -----
  subroutine Diff_Matrices ( Matrix1, Matrix2, Details, clean, &
    & options, different )
    use Lexer_core, only: PRINT_SOURCE
    use MLSStringLists, only: optionDetail
    use output_m, only: resumeOutput, suspendOutput
    type(Matrix_T), intent(in) :: Matrix1, Matrix2
    integer, intent(in), optional :: Details   ! Print details, default 1
    character(len=*), intent(in), optional :: options
    logical, intent(inout), optional :: different ! Are matrices different?
    !  <= -3 => no details,
    !  -2..0 => Just the name, size and where created
    !  == -1 => Structure of blocks but not their values
    !  == One => Details of matrix but not its blocks,
    !  >One => Details of the blocks, too.
    logical, intent(in), optional :: Clean     ! Print zeroes, count

    integer :: I, J                ! Subscripts, loop inductors
    integer :: MY_DETAILS          ! True if DETAILS is absent, else DETAILS
    logical :: SKIPPEDSOMEBLOCKS
    logical :: silent
    ! Executable
    my_details = 1
    if ( present(details) ) my_details = details
    if ( my_details <= -3 ) return
    silent = .false.
    if ( present (options) ) then
      silent = (optionDetail(options, 'm' ) == 'yes' )
    endif
    if ( silent ) call suspendOutput
    if ( matrix1%name > 0 .and. matrix2%name > 0 ) then
      call output ( 'Diffing ' )
      call display_string ( matrix1%name )
      call output ( ' and ' )
      call display_string ( matrix2%name )
    end if
    if ( matrix1%where%source > 0 .and. matrix2%where%source > 0 ) then
      call output ( ', created at ' )
      call print_source ( matrix1%where )
      call output ( ' and ' )
      call print_source ( matrix2%where )
    end if
    call newLine
    if ( .not. associated(matrix1%block) .or. .not. associated(matrix2%block) ) then
      call output ( '(the matrices have been destroyed)', advance='yes' )
      return
    end if
    ! Check that the two matrices match somehow
    if ( matrix1%col%nb /= matrix1%col%nb .or. matrix1%row%nb /= matrix2%row%nb ) then
      call output ( 'the matrices have different shapes', advance='yes' )
      if ( present(different) ) different = .true.
      return
    endif
    skippedsomeblocks = .false.
    do j = 1, matrix1%col%nb
      do i = 1, matrix1%row%nb
        if ( matrix1%block(i,j)%kind /= matrix2%block(i,j)%kind ) then
          call output ( 'the matrices at (i,j) ')
          call output( (/ i,j /) )
          call output( 'are of different kinds', advance='yes' )
          if ( present(different) ) different = .true.
          if ( my_details < 1 ) cycle
          call outputNamedValue( 'kind(matrix1)', &
            & GetMatrixKindString(matrix1%block(i,j)%kind) )
          call outputNamedValue( 'kind(matrix2)', &
            & GetMatrixKindString(matrix2%block(i,j)%kind) )
          cycle
        endif
        if ( my_details < 1 ) cycle
        if ( matrix1%block(i,j)%kind == m_absent ) then
          skippedSomeBlocks = .true.
          cycle
        endif
        if ( skippedSomeBlocks ) &
          & call output ( 'Other blocks absent in both matrices', advance='yes' )
        skippedSomeBlocks = .false.
        call output ( i, before='Block at row ' )
        call output ( j, before=' and column ' )
        call output ( ' ( ' )
        if ( matrix1%row%vec%quantities(matrix1%row%quant(i))%template%name /= 0 ) then
          call display_string ( &
            & matrix1%row%vec%quantities(matrix1%row%quant(i))%template%name )
          call output ( ':' )
        else
          call output ( '<No template>' )
        end if
        call output ( matrix1%row%Inst(i) )
        call output (' , ')
        if ( matrix1%col%vec%quantities(matrix1%col%quant(j))%template%name /= 0 ) then
          call display_string ( &
            & matrix1%col%vec%quantities(matrix1%col%quant(j))%template%name )
          call output ( ':' )
        else
          call output ( '<No template>' )
        end if
        call output ( matrix1%col%Inst(j) )
        call output ( ' )' )
        if ( matrix1%block(i,j)%kind == m_absent ) then
          call output ( ' [absent--therefore matrices equal]', advance='yes' )
        else
          call output ( '', advance='yes' )
          call Diff ( matrix1%block(i,j), matrix2%block(i,j), &
            & details=my_details, clean=clean, &
            & options=options, different=different )
        end if
      end do
    end do
    if ( silent ) call resumeOutput
  end subroutine Diff_Matrices

  ! --------------------------------------------------  Dump_Linf  -----
  subroutine Dump_Linf ( Matrix, Name, Upper )
    type(Matrix_T), intent(in) :: Matrix
    character(len=*), intent(in), optional :: Name
    logical, intent(in), optional :: Upper
    ! Dump the L_infty norms of the matrix blocks.  Only dump the upper
    ! triangle if Upper is present and true.

    integer :: I, J, K             ! Subscripts, loop inductors
    logical :: My_upper

    if ( present(name) ) call output ( name )
    if ( matrix%name > 0 ) then
      if ( present(name) ) call output ( ', ' )
      call output ( 'Name = ' )
      call display_string ( matrix%name, advance='yes' )
    else
      if ( present(name) ) call output ( '', advance='yes' )
    end if
    my_upper = .false.
    if ( present(upper) ) my_upper = upper
    do k = 1, matrix%col%nb, 7
      if ( matrix%col%nb > 7 ) then
        call output ( ' ' )
        do i = k, min(matrix%col%nb,k+6)
          call output ( i, places=10 )
        end do
        call output ( '', advance='yes' )
      end if
      do i = 1, matrix%row%nb
        if ( .not. my_upper .or. i <= min(matrix%col%nb,k+6) ) then
          call output ( i, places=4 )
          call output ( ':' )
          do j = k, min(matrix%col%nb,k+6)
            if ( my_upper .and. i > j ) then
              call blanks ( 10 )
            else
              call output ( maxAbsVal(matrix%block(i,j)), format='(1pe10.3)' )
            end if
          end do ! j
          call output ( '', advance='yes' )
        end if
      end do ! i
    end do ! k
  end subroutine Dump_Linf

  ! ------------------------------------------------  Dump_Matrix_Layout  -----
  subroutine Dump_Matrix_Layout ( Matrix, Name )
    class(Matrix_T), intent(in) :: Matrix
    character(len=*), intent(in), optional :: Name

    integer :: I, J                ! Subscripts, loop inductors
    integer :: TotalSize           ! of all blocks
    character(len=1), dimension(:,:), pointer :: layout => null() ! ., s, or f

    if ( present(name) ) call output ( name )
    if ( matrix%name > 0 ) then
      if ( present(name) ) call output ( ', ' )
      call output ( 'Name = ' )
      call display_string ( matrix%name )
    end if
    call allocate_Test( layout, matrix%row%nb, matrix%col%nb, &
      & 'Layout of blocks', moduleName // '%Dump_Matrix_Layout', Fill='.' )
    totalSize = 0
    do j = 1, matrix%col%nb
      do i = 1, matrix%row%nb
        if ( matrix%block(i,j)%kind == m_absent ) cycle
        select case ( matrix%block(i,j)%kind )
        case ( m_banded )
          layout(i, j) = 'B'
          if ( associated(matrix%block(i,j)%values) ) &
            & totalSize = totalSize + size(matrix%block(i,j)%values)
        case ( m_column_sparse )
          layout(i, j) = 'S'
          if ( associated(matrix%block(i,j)%values) ) &
            & totalSize = totalSize + size(matrix%block(i,j)%values)
        case ( m_full )
          layout(i, j) = 'F'
          if ( associated(matrix%block(i,j)%values) ) &
            & totalSize = totalSize + size(matrix%block(i,j)%values)
        end select
      end do
    end do
    call outputNamedValue( 'Total size', TotalSize )
    call dump( layout, 'Layout of blocks in Matrix', width=matrix%col%nb )
    call output( 'Total blocks' )
    call blanksToColumn( 21 )
    call output( 'Absent' )
    call blanksToColumn( 36 )
    call output( 'Banded' )
    call blanksToColumn( 51 )
    call output( 'ColumnSparse' )
    call blanksToColumn( 66 )
    call output( 'Full' )
    call newLine
    call blanks( 6 )
    call output( matrix%col%nb * matrix%row%nb )
    call blanksToColumn( 22 )
    call output( count(layout == '.') )
    call blanksToColumn( 39 )
    call output( count(layout == 'B') )
    call blanksToColumn( 54 )
    call output( count(layout == 'S') )
    call blanksToColumn( 68 )
    call output( count(layout == 'F') )
    call newLine
    call deallocate_test ( layout, moduleName // '%Dump_Hessian', &
      & "layout of Matrix Blocks" )
  end subroutine Dump_Matrix_Layout

  ! ------------------------------------------------  Dump_Matrix  -----
  subroutine Dump_Matrix ( Matrix, Name, Details, Clean, Row, Column, QuantityType )
    use Lexer_core, only: Print_Source
    class(Matrix_T), intent(in) :: Matrix
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: Details   ! Print details, default 1
    !  <= -3 => no details,
    !  -2..0 => Just the name, size and where created
    !  == -1 => Structure of blocks but not their values
    !  == 0  => Layout of blocks but not their values
    !  == One => Add details of matrix but not its blocks,
    !  >One => Details of the blocks, too.
    integer, intent(in), optional :: Row, Column  ! Only do these
    logical, intent(in), optional :: Clean        ! Print zeroes, count
    integer, intent(in), optional :: QuantityType ! Only do this column

    integer :: Col1, ColN
    integer :: I, J                ! Subscripts, loop inductors
    integer :: My_Details          ! True if Details is absent, else Details
    integer :: Row1, RowN
    integer :: TotalSize           ! of all blocks

    my_details = 1
    if ( present(details) ) my_details = details
    if ( my_details <= -3 ) return
    if ( present(name) ) call output ( name )
    if ( matrix%name > 0 ) then
      if ( present(name) ) call output ( ', ' )
      call output ( 'Name = ' )
      call display_string ( matrix%name )
    end if
    if ( matrix%where%source > 0 ) then
      call output ( ', created at ' )
      call print_source ( matrix%where )
    end if
    call newLine
    totalSize = 0
    if ( my_details > 0 ) then
      call dump_rc ( matrix%row, 'row', my_details>0, num=row )
      call dump_rc ( matrix%col, 'column', my_details>0, num=column )
    end if
    if ( .not. associated(matrix%block) ) then
      call output ( '      (the matrix has been destroyed)', advance='yes' )
      return
    end if
    if ( my_details == -1 ) call dump_struct ( matrix )
    if ( my_details == 0  ) call dump_matrix_layout ( matrix )
    if ( present(row) ) then
      row1 = row; rowN = row
    else
      row1 = 1; rowN = matrix%row%nb
    end if
    if ( present(column) ) then
      col1 = column; colN = column
    else
      col1 = 1; colN = matrix%col%nb
    end if
    do j = col1, colN
      if ( present(quantityType) ) then
        if ( matrix%col%vec%quantities(matrix%col%quant(j))%template%quantityType /= &
          quantityType ) cycle
      end if
      do i = row1, rowN
        if ( associated(matrix%block(i,j)%values) ) &
          totalSize = totalSize + size(matrix%block(i,j)%values)
        if ( my_details < 1 ) cycle
        call output ( i, before='Block at row ' )
        call output ( j, before=' and column ' )
        call output ( ' ( ' )
        if ( matrix%row%vec%quantities(matrix%row%quant(i))%template%name /= 0 ) then
          call display_string ( &
            & matrix%row%vec%quantities(matrix%row%quant(i))%template%name )
          call output ( ':' )
        else
          call output ( '<No template>' )
        end if
        call output ( matrix%row%Inst(i) )
        call output (' , ')
        if ( matrix%col%vec%quantities(matrix%col%quant(j))%template%name /= 0 ) then
          call display_string ( &
            & matrix%col%vec%quantities(matrix%col%quant(j))%template%name )
          call output ( ':' )
        else
          call output ( '<No template>' )
        end if
        call output ( matrix%col%Inst(j) )
        call output ( ' )' )
        if ( matrix%block(i,j)%kind == m_absent ) then
          call output ( ' [absent]', advance='yes' )
        else
          call output ( '', advance='yes' )
          call dump ( matrix%block(i,j), details=my_details, clean=clean )
        end if
      end do
    end do
    call output ( matrix%row%nb, before='      having ' )
    call output ( matrix%col%nb, before=' row blocks and ' )
    call output ( totalSize, before=' column blocks with ', &
      & after=' represented elements.', advance='yes' )
  end subroutine Dump_Matrix

  ! ---------------------------------------  Dump_Matrix_Database  -----
  subroutine Dump_Matrix_Database ( MatrixDatabase, Details )
    type(Matrix_Database_T), dimension(:), pointer :: MatrixDatabase
    integer, intent(in), optional :: Details   ! Print details, default 1
    !  <= -4 => no output
    !  <= -3 => no details, just summarize the database
    !  -2..0 => size of each matrix
    !  == -1 => Structure of blocks but not their values
    !  == One => Details of matrix but not its blocks,
    !  >One => Details of the blocks, too.

    integer :: I, MyDetails
    double precision :: TotalSize

    myDetails = 1
    if ( present(details) ) myDetails = details
    if ( myDetails <= -4 ) return
    if ( .not. associated(MatrixDatabase) ) return
    if ( size(matrixDatabase) > 0 ) &
      & call output ( size(matrixDatabase), before='MATRICES: SIZE = ', advance='yes' )
    totalSize = 0.0
    do i = 1, size(MatrixDatabase)
      if ( myDetails > -3 ) call output ( i, 4, after=': ' )
      if ( associated(matrixDatabase(i)%matrix) ) then
        call addSize ( matrixDatabase(i)%matrix )
        call dump ( matrixDatabase(i)%matrix, 'Plain', details )
      else if ( associated(matrixDatabase(i)%cholesky) ) then
        call addSize ( matrixDatabase(i)%cholesky%m )
        call dump ( matrixDatabase(i)%cholesky%m, 'Cholesky', details )
      else if ( associated(matrixDatabase(i)%kronecker) ) then
        call addSize ( matrixDatabase(i)%kronecker%m )
        call dump ( matrixDatabase(i)%kronecker%m, 'Kronecker', details )
      else if ( associated(matrixDatabase(i)%spd) ) then
        call addSize ( matrixDatabase(i)%spd%m )
        call dump ( matrixDatabase(i)%spd%m, 'SPD', details )
      end if
    end do
    call output ( size(matrixDatabase), before='Matrix database has ' )
    if ( totalSize <= huge(1) ) then
      call output ( int(totalSize), before=' matrices with ' )
    else
      call output ( totalSize, before=' matrices with ' )
    end if
    call output ( ' values.', advance='yes' )
  contains
    subroutine AddSize ( TheMatrix )
      type(matrix_t), intent(in) :: TheMatrix
      integer :: J, K
      if ( .not. associated(theMatrix%block) ) return
      do j = 1, size(theMatrix%block,1)
        do k = 1, size(theMatrix%block,2)
          if ( associated(theMatrix%block(j,k)%values) ) &
            totalSize = totalSize + size(theMatrix%block(j,k)%values)
        end do
      end do
    end subroutine AddSize
  end subroutine Dump_Matrix_Database

  ! ---------------------------------------  Dump_Matrix_in_Database  -----
  subroutine Dump_Matrix_in_Database ( MatrixDatabase, Details )
    type(Matrix_Database_T) :: MatrixDatabase
    integer, intent(in), optional :: Details   ! Print details, default 1
    !  <= Zero => no details, == One => Details of matrix but not its blocks,
    !  >One => Details of the blocks, too.

      call output ( 'Matrix d.b. ' )
      if ( associated(matrixDatabase%matrix) ) then
        call dump ( matrixDatabase%matrix, 'Plain', details )
      else if ( associated(matrixDatabase%cholesky) ) then
        call dump ( matrixDatabase%cholesky%m, 'Cholesky', details )
      else if ( associated(matrixDatabase%kronecker) ) then
        call dump ( matrixDatabase%kronecker%m, 'Kronecker', details )
      else if ( associated(matrixDatabase%spd) ) then
        call dump ( matrixDatabase%spd%m, 'SPD', details )
      end if
  end subroutine Dump_Matrix_in_Database

  ! ------------------------------------------------  Dump_Struct  -----
  subroutine Dump_Struct ( Matrix, Name, Upper )
  ! Display the structure of the kinds of the matrix blocks
    class(Matrix_T), intent(in) :: Matrix
    character(len=*), intent(in), optional :: Name
    logical, intent(in), optional :: Upper   ! Only do the upper triangle
    !                                          if present and true.

    !                         Absent Banded Sparse   Full
    character :: CHARS(m_absent:m_unknown) = (/ '-',   'B',   'S',   'F',  '?' /)
    integer :: I, J, N
    logical :: MyUpper

    if ( present(name) ) call output ( name )
    if ( matrix%name > 0 ) then
      if ( present(name) ) call output ( ', ' )
      call display_string ( matrix%name, before='Name = ', advance='yes' )
    else
      if ( present(name) ) call output ( '', advance='yes' )
    end if
    myUpper = .false.
    if ( present(upper) ) myUpper = upper
    n = 0
    do i = 1, matrix%row%nb
      call output ( i, 3 )
      call output ( ':' )
      do j = 1, matrix%col%nb
        if ( matrix%col%nb < 36 ) call output ( ' ' )
        if ( myUpper .and. j < i ) then
          call output ( ' ' )
        else
          call output ( chars(matrix%block(i,j)%kind) )
        end if
        select case ( matrix%block(i,j)%kind )
        case ( M_Full )
          n = n + matrix%block(i,j)%nRows * matrix%block(i,j)%nCols
        case ( M_Banded, M_Column_Sparse )
          n = n + size ( matrix%block(i,j)%values, 1 )
        end select
      end do ! j
      call output ( matrix%row%nelts(i), places=6, advance='yes' )
    end do ! i
    call output ( matrix%row%nb, before='Matrix size: ' )
    call output ( matrix%col%nb, before=' rows, ', after=' columns, ' )
    call output ( sum(matrix%row%nelts), before='Total matrix size: ' )
    call output ( sum(matrix%col%nelts), before=' rows, ', after=' columns, ' )
    ! Convert size to bytes (is there a better way to do this to automatically
    ! deal with the case when we decide to switch to r4?)
    select case ( rm )
    case ( r4 )
      n = n * 4
    case ( r8 )
      n = n * 8
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, 'Unrecognized value for rm' )
    end select

    ! Make a 'nice' output
    call DumpSize ( n, advance='yes' )
  end subroutine Dump_Struct

  ! --------------------------------------------------  MinDiag_1  -----
  real(rm) function MinDiag_1 ( A )
  ! Return the magnitude of the element on the diagonal of A that has the
  ! smallest magnitude.
    type(Matrix_T), intent(in) :: A
    integer :: I
    minDiag_1 = minDiag(a%block(1,1))
    do i = 2, a%col%nb
      minDiag_1 = min(minDiag_1,minDiag(a%block(i,i)))
    end do
  end function MinDiag_1

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MatrixModule_1.f90,v 2.145 2018/04/19 02:00:36 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------
end module MatrixModule_1

! $Log: MatrixModule_1.f90,v $
! Revision 2.145  2018/04/19 02:00:36  vsnyder
! Compute address for allocate/deallocate tracking.  Remove USE statements for
! unused names.
!
! Revision 2.144  2016/07/27 23:02:42  vsnyder
! Add QuantityType argument to Dump_Matrix
!
! Revision 2.143  2016/05/27 00:14:55  vsnyder
! Publish RM because this seems like a logical place to get it
!
! Revision 2.142  2015/06/02 23:53:36  vsnyder
! Remove unreferenced variable
!
! Revision 2.141  2015/04/29 00:00:43  pwagner
! Diffs made more manageable
!
! Revision 2.140  2015/03/28 01:20:39  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.139  2014/10/10 23:56:19  vsnyder
! Undo making RC_Info%Vec a pointer.  It breaks L2PC_m
!
! Revision 2.138  2014/10/08 19:28:17  vsnyder
! Add DestroyMatrixDatabaseElement and use it from DestroyMatrixDatabase.
! Add commented-out code to Add...ToDatabase to try to make final subroutine
! work.  Couldn't make it work, so added comments about why we don't want
! final subroutines for RC_Info and Matrix_T.  Change RC_Info%Vec from copy
! to a pointer, with NULL() initialization.  Add shape to Dump_Struct.  Some
! cannonball polishing.
!
! Revision 2.137  2014/09/05 00:14:21  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.136  2014/08/19 00:29:26  vsnyder
! Add AllMatricesMemoryInUse, MatricesMemoryInUse, MatrixMemoryInUse
!
! Revision 2.135  2014/07/23 21:58:28  pwagner
! Attempted to match names passed to allocate/deallocate
!
! Revision 2.134  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.133  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.132  2013/08/08 02:37:57  vsnyder
! Only dump RC_Info stuff for selected row or column
!
! Revision 2.131  2012/07/19 19:39:48  vsnyder
! No, "inst" should be "quant" in CreateBlock_1.
!
! Revision 2.130  2012/07/18 22:14:29  vsnyder
! 'quant' should be 'inst' in CreateBlock_1
!
! Revision 2.128  2012/06/15 23:30:58  vsnyder
! Explain summary of dump better
!
! Revision 2.127  2012/02/16 22:47:51  pwagner
! Separated Dump_Matrix_Layout from Dump_Matrix
!
! Revision 2.126  2012/02/10 23:50:12  vsnyder
! Cannonball polishing
!
! Revision 2.125  2012/02/02 01:14:49  pwagner
! Diffing matrices skips absent blocks
!
! Revision 2.124  2011/12/17 00:34:40  vsnyder
! Add GetFullBlock (moved from Convolve_All)
!
! Revision 2.123  2011/06/16 20:17:32  vsnyder
! Add row, column arguments to dump
!
! Revision 2.122  2011/01/13 00:23:19  vsnyder
! Add GetVectorFromColumn_1_Q_I
!
! Revision 2.121  2010/09/25 01:15:23  vsnyder
! Add an 'Instance' argument to MultiplyMatrixVectorNoT_1
!
! Revision 2.120  2010/08/13 22:04:08  pwagner
! Added diff
!
! Revision 2.119  2010/08/06 22:59:53  pwagner
! Should crash less easily
!
! Revision 2.118  2010/04/17 01:41:57  vsnyder
! Dump_Matrix calls Dump_Struct if details == -1
!
! Revision 2.117  2010/03/24 20:39:12  vsnyder
! Make Dump_RC public and part of Dump generic
!
! Revision 2.116  2010/02/25 18:05:21  pwagner
! Conforms with changed l2pc structure
!
! Revision 2.115  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.114  2007/11/07 21:33:08  vsnyder
! Get kinds from MLSKinds instead of MLSCommon
!
! Revision 2.113  2007/10/02 22:48:06  vsnyder
! Add a FAIL flag to GetMatrixFromDatabase
!
! Revision 2.112  2007/09/12 00:16:37  vsnyder
! Spiff up DescribeBlock routine
!
! Revision 2.111  2006/08/01 03:18:27  vsnyder
! Add ForWhom argument to CreateBlock for leak checking
!
! Revision 2.110  2006/08/01 02:49:08  vsnyder
! Remove unused .TX. defined operator, which leaks memory anyway
!
! Revision 2.109  2006/07/28 01:58:17  vsnyder
! Correct a bug in size accumulation, plus cannonball polishing
!
! Revision 2.108  2006/07/27 03:55:56  vsnyder
! Print summaries if negative details levels, for leak detection
!
! Revision 2.107  2006/05/23 21:43:34  vsnyder
! Add CLEAR option to some dumps
!
! Revision 2.106  2005/12/16 23:25:58  pwagner
! dumpSize moved from dump0 to output_m
!
! Revision 2.105  2005/06/22 17:25:49  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.104  2005/06/21 23:58:14  livesey
! Added forgiveZeros option to UpdateDiagonal
!
! Revision 2.103  2005/05/25 02:14:43  vsnyder
! Use names for bounds for CHARS in Dump_Struct
!
! Revision 2.102  2004/10/14 04:54:25  livesey
! Added ClearLower_1
!
! Revision 2.101  2004/07/07 19:34:30  vsnyder
! Add Init argument to CreateBlock
!
! Revision 2.100  2004/04/03 05:43:43  livesey
! Moved the DumpSize functionality into Dump_0
!
! Revision 2.99  2004/01/30 23:24:48  livesey
! Bug fixes to FrobeniusNorm and CyclicJacobi stuff
!
! Revision 2.98  2004/01/29 03:31:58  livesey
! Added CyclicJacobi stuff.  Also version of UpdateDiagonal that doesn't
! insist on SPD matrices
!
! Revision 2.97  2004/01/24 03:22:20  livesey
! More checking in multiply
!
! Revision 2.96  2004/01/24 01:02:28  livesey
! Added TransposeMatrix_1
!
! Revision 2.95  2004/01/23 05:36:24  livesey
! Added allowNameMismatch argument to CopyMatrixValues
!
! Revision 2.94  2004/01/16 23:50:51  vsnyder
! Make AssignMatrix public, fix a comment
!
! Revision 2.93  2003/09/15 17:45:18  livesey
! Added target declaration for fussy intel compiler
!
! Revision 2.92  2003/07/07 20:20:59  livesey
! Mainly cosmetic changes
!
! Revision 2.91  2003/06/20 19:31:39  pwagner
! Changes to allow direct writing of products
!
! Revision 2.90  2003/06/03 19:21:38  livesey
! Made CholeskyFactor and SolveCholesky return with status rather than
! crash.  Also added invert option to GetDiagonal
!
! Revision 2.89  2003/02/21 04:06:30  livesey
! Added some OpenMP stuff
!
! Revision 2.88  2003/02/12 02:10:52  livesey
! New code to support extended averaging kernels.  Rewrite of
! MultiplyMatrix_XTY_1.
!
! Revision 2.87  2003/01/17 22:31:52  livesey
! Trivial change to the dump_struct output format.
!
! Revision 2.86  2003/01/08 23:51:46  livesey
! Added sparsify and handling of r4/r8 in dump_struct
!
! Revision 2.85  2002/11/22 12:53:59  mjf
! Didn't add nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.84  2002/10/07 23:24:43  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.83  2002/09/21 00:00:51  vsnyder
! Handle the UseMask flag in NormalEquations completely
!
! Revision 2.82  2002/09/13 18:08:12  pwagner
! May change matrix precision rm from r8
!
! Revision 2.81  2002/09/11 17:43:38  pwagner
! Began changes needed to conform with matrix%values type move to rm from r8
!
! Revision 2.80  2002/09/10 01:00:00  livesey
! Added NullifyMatrix
!
! Revision 2.79  2002/08/29 04:45:27  livesey
! Added diagonalOnly option to MultiplyMatrix_XY_T
!
! Revision 2.78  2002/08/21 20:38:24  vsnyder
! Add 'text' argument to CreateEmptyMatrix
!
! Revision 2.77  2002/08/20 19:49:26  vsnyder
! Embellish dump_struct -- add total rows and columns
!
! Revision 2.76  2002/08/19 20:51:26  vsnyder
! Make AddToMatrix respect it's Scale argument
!
! Revision 2.75  2002/08/15 22:13:33  livesey
! Bug fix in ColumnScale
!
! Revision 2.74  2002/08/06 02:15:20  livesey
! Added ReflectMatrix_1
!
! Revision 2.73  2002/08/03 20:41:51  livesey
! Added GetActualMatrixFromDatabase
!
! Revision 2.72  2002/07/22 03:26:37  livesey
! Added checkIntegrity
!
! Revision 2.71  2002/07/17 06:01:10  livesey
! Added trivial handling of M_Unknown
!
! Revision 2.70  2002/07/01 23:50:03  vsnyder
! Plug memory leaks
!
! Revision 2.69  2002/06/22 06:50:25  livesey
! Added print of matrix size in -Sspa
!
! Revision 2.68  2002/06/18 01:22:49  vsnyder
! Add Spill_1.  Cosmetic changes in LaTeX stuff and elsewhere.
!
! Revision 2.67  2002/05/21 20:22:19  vsnyder
! Remove some commented-out obsolete code and its comments
!
! Revision 2.66  2002/04/22 20:53:58  vsnyder
! Add a 'scale' argument to AddToMatrix
!
! Revision 2.65  2002/03/05 23:31:07  livesey
! Removed a diagnostic print that got left behind
!
! Revision 2.64  2002/03/05 23:17:03  livesey
! Changes adopted from Van
!
! Revision 2.63  2002/02/22 01:19:31  vsnyder
! Added MultiplyMatrix_XY_0, MultiplyMatrix_XY_T_1.  Changed the name of
! MultiplyMatrices to Multiply_Matrix_XTY_1.  Added generics.
!
! Revision 2.62  2002/02/05 02:39:59  vsnyder
! Change mask from 1-bit per to 8-bits per (using character)
!
! Revision 2.61  2001/11/08 02:06:30  vsnyder
! Added #rows to sparsness structure display
!
! Revision 2.60  2001/10/19 22:30:18  pwagner
! Now can dump a single matrixdb
!
! Revision 2.59  2001/10/18 23:48:23  livesey
! Made dump_struct take up less space in the case of large matrices
!
! Revision 2.58  2001/10/15 23:22:45  vsnyder
! Make Z-cloning during MultiplyMatrixVector* optional
!
! Revision 2.57  2001/10/04 23:49:57  livesey
! Added checking code, and temporarily suppressed sparse
!
! Revision 2.56  2001/10/01 23:57:51  livesey
! Removed clone vector call in GetDiagonal_1 to avoid problems with
! snooping.
!
! Revision 2.55  2001/09/28 23:34:20  vsnyder
! Correct looking at row%inst to get column mask in NormalEquations
!
! Revision 2.54  2001/09/27 18:41:05  vsnyder
! Apply mask in forming RHS of normal equations
!
! Revision 2.53  2001/09/27 00:51:33  vsnyder
! Add UseMask argument to NormalEquations
!
! Revision 2.52  2001/09/25 17:49:24  livesey
! Added call to copyvector for row mask in clearrows_1
!
! Revision 2.51  2001/09/20 23:03:01  vsnyder
! Call ClearRows and ClearUnderMask from NormalEquations
!
! Revision 2.50  2001/07/26 20:34:04  vsnyder
! Eliminate the 'extra' field
!
! Revision 2.49  2001/07/19 17:50:42  vsnyder
! Add 'row_block' optional argument to RowScale and NormalEquations
!
! Revision 2.48  2001/07/12 22:12:19  vsnyder
! Forget to get CopyVector
!
! Revision 2.47  2001/07/12 21:08:44  vsnyder
! Repair bug in SolveCholesky in the case that RHS is present
!
! Revision 2.46  2001/07/11 22:07:57  vsnyder
! Interim commit -- may still be broken
!
! Revision 2.45  2001/06/28 01:06:42  vsnyder
! Use generic 'multiply' more ubiquitously
!
! Revision 2.44  2001/06/01 01:04:00  vsnyder
! Add 'sqrt' option to 'GetDiagonal_0'; add 'Multiply' generic
!
! Revision 2.43  2001/05/30 20:18:01  vsnyder
! Add 'invert' argument to 'UpdateDiagonal'
!
! Revision 2.42  2001/05/22 19:09:33  vsnyder
! Implement MaxL1
!
! Revision 2.41  2001/05/19 00:20:05  livesey
! Cosmetic changes from Van.
!
! Revision 2.40  2001/05/19 00:14:57  livesey
! OK that should have been square (idiot!)
!
! Revision 2.39  2001/05/19 00:13:23  livesey
! Added squareRoot option to update diagonal
!
! Revision 2.38  2001/05/18 23:48:34  vsnyder
! Correct Dump_L1 -> Dump_Linf
!
! Revision 2.37  2001/05/18 22:28:11  vsnyder
! Don't look for a mask in the extra column during NormalEquations
!
! Revision 2.36  2001/05/17 20:19:20  vsnyder
! Implement GetMatrixElement.  Change handling of mask in NormalEquations.
! Don't scale the extra column/row if column/row scaling, but do scale
! the extra row/column.
!
! Revision 2.35  2001/05/12 18:58:47  livesey
! Fixed a bug, not sure it's what Van intended but it should compile
!
! Revision 2.34  2001/05/12 01:07:19  vsnyder
! Some repairs in RowScale and ColumnScale
!
! Revision 2.33  2001/05/10 22:54:34  vsnyder
! Get CholeskyFactor_1 to work.  Add Dump_L1 and Dump_Struct.
!
! Revision 2.32  2001/05/10 02:14:58  vsnyder
! Repair CholeskyFactor, MaxAbsVal; add Dump_Struct
!
! Revision 2.31  2001/05/09 19:46:06  vsnyder
! Add BandHeight argument to CreateBlock_1
!
! Revision 2.30  2001/05/09 01:56:15  vsnyder
! periodic commit -- Work on block Cholesky
!
! Revision 2.29  2001/05/08 20:29:40  vsnyder
! Periodic commit -- workong on sparse matrix blunders
!
! Revision 2.28  2001/05/03 02:11:23  vsnyder
! Spiffify dump, add names to cloned vectors
!
! Revision 2.27  2001/05/01 23:54:13  vsnyder
! Create a block for the extra column
!
! Revision 2.26  2001/05/01 06:56:32  livesey
! Bug fix, was using optional argument, not local copy/default.
!
! Revision 2.25  2001/04/30 23:44:25  vsnyder
! Correct/remove some incorrect size tests in MultiplyMatrixVectorNoT
!
! Revision 2.24  2001/04/28 07:03:59  livesey
! Removed print statement
!
! Revision 2.23  2001/04/28 04:42:29  livesey
! Removing some of the unnecessary(?) assertions of square matrices in
! multiplyMatrixVector and its relatives.  Also sorted out some of the
! conditions, and loops for the multiplyMatrixVectorNoT case.
!
! Revision 2.22  2001/04/28 01:28:36  livesey
! Change in rcInfo_T, vec is now a copy of the parent vector, not a pointer.
!
! Revision 2.21  2001/04/27 22:51:52  livesey
! Some changes/improvements to dump
!
! Revision 2.20  2001/04/26 23:56:02  livesey
! Fix to test for MatrixVectorMultiplyNoT
!
! Revision 2.19  2001/04/25 01:12:39  vsnyder
! Improve some comments
!
! Revision 2.18  2001/04/25 00:50:25  vsnyder
! Provide MultiplyMatrixNoT
!
! Revision 2.17  2001/04/24 22:35:56  vsnyder
! Maybe this time elements of matrixDatabase are destroyed coimpletely
!
! Revision 2.16  2001/04/21 02:11:02  vsnyder
! Fix a memory leak
!
! Revision 2.15  2001/04/20 02:56:18  livesey
! Added createblock_1 as public and overloaded.  Also made dump more informative
!
! Revision 2.14  2001/04/11 00:40:25  vsnyder
! Remove some inadventently-left-in debugging print
!
! Revision 2.13  2001/04/11 00:03:42  vsnyder
! Repair matrix creation, improve 'dump'
!
! Revision 2.12  2001/04/10 00:19:11  vsnyder
! Add GetKindFromMatrixDatabase and necessary parameters
!
! Revision 2.11  2001/04/09 23:56:17  vsnyder
! Change some pointer arguments to targets
!
! Revision 2.10  2001/04/09 23:32:19  vsnyder
! Correct typo
!
! Revision 2.9  2001/02/22 02:09:36  vsnyder
! OOPS -- Forgot to make InvertCholesky public
!
! Revision 2.8  2001/02/22 01:55:06  vsnyder
! Add code to invert a Cholesky factor
!
! Revision 2.7  2001/01/26 19:00:02  vsnyder
! Periodic commit
!
! Revision 2.6  2001/01/19 23:53:26  vsnyder
! Add FillExtraCol, GetVectorFromColumn (incomplete); SolveCholesky_1
! still needs work, too.
!
! Revision 2.5  2001/01/10 21:03:14  vsnyder
! Periodic commit
!
! Revision 2.4  2000/11/23 01:09:46  vsnyder
! Add provision to ignore columns during matrix-matrix multiply, finish DUMP.
!
! Revision 2.3  2000/11/15 00:18:26  vsnyder
! Added assignment(=) interface, row scale, column scale
!
! Revision 2.2  2000/11/10 00:28:13  vsnyder
! Added multiply untransposed matrix * vector
!
! Revision 2.1  2000/11/09 01:23:23  vsnyder
! Initial entry -- still under construction
!
@


2.145
log
@Compute address for allocate/deallocate tracking.  Remove USE statements for
unused names.
@
text
@d269 4
d2873 1
a2873 1
    type(Matrix_T), intent(in) :: Matrix
d2938 1
a2938 1
    type(Matrix_T), intent(in) :: Matrix
d3116 1
a3116 1
    type(Matrix_T), intent(in) :: Matrix
d3189 1
a3189 1
       "$Id: MatrixModule_1.f90,v 2.144 2016/07/27 23:02:42 vsnyder Exp $"
d3198 4
@


2.144
log
@Add QuantityType argument to Dump_Matrix
@
text
@a2662 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d3185 1
a3185 1
       "$Id: MatrixModule_1.f90,v 2.143 2016/05/27 00:14:55 vsnyder Exp $"
d3194 3
@


2.143
log
@Publish RM because this seems like a logical place to get it
@
text
@d2933 2
a2934 2
  subroutine Dump_Matrix ( Matrix, Name, Details, Clean, Row, Column )
    use Lexer_core, only: PRINT_SOURCE
d2944 3
a2946 2
    integer, intent(in), optional :: Row, Column ! Only do these
    logical, intent(in), optional :: Clean     ! Print zeroes, count
d2950 1
a2950 1
    integer :: MY_DETAILS          ! True if DETAILS is absent, else DETAILS
d2990 4
d3186 1
a3186 1
       "$Id: MatrixModule_1.f90,v 2.142 2015/06/02 23:53:36 vsnyder Exp $"
d3195 3
@


2.142
log
@Remove unreferenced variable
@
text
@d70 4
a73 4
  public :: Negate, Negate_1
  public :: NewMultiplyMatrixVector, NormalEquations, NullifyRCInfo, NullifyMatrix, NullifyMatrix_1
  public :: Operator(+), ReflectMatrix, RC_Info, RowScale, RowScale_1, ScaleMatrix
  public :: SolveCholesky, SolveCholesky_1, Spill, Spill_1
d3181 1
a3181 1
       "$Id: MatrixModule_1.f90,v 2.141 2015/04/29 00:00:43 pwagner Exp $"
d3190 3
@


2.141
log
@Diffs made more manageable
@
text
@d1337 1
a1337 1
    integer :: S, Status  ! from deallocate
a1340 1
      s = storage_size(database%matrix) / 8
a1346 1
      s = storage_size(database%cholesky%m ) / 8
a1352 1
      s = storage_size(database%kronecker%m ) / 8
a1358 1
      s = storage_size(database%spd%m ) / 8
d3181 1
a3181 1
       "$Id: MatrixModule_1.f90,v 2.140 2015/03/28 01:20:39 vsnyder Exp $"
d3190 3
@


2.140
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d2717 2
a2718 1
  subroutine Diff_Matrices ( Matrix1, Matrix2, Details, clean )
d2720 2
d2724 2
d2736 1
d2741 5
d2766 1
d2776 1
d2818 2
a2819 1
            & details=my_details, clean=clean )
d2823 1
d3185 1
a3185 1
       "$Id: MatrixModule_1.f90,v 2.139 2014/10/10 23:56:19 vsnyder Exp $"
d3194 3
@


2.139
log
@Undo making RC_Info%Vec a pointer.  It breaks L2PC_m
@
text
@d314 1
d318 1
d323 2
d326 1
a326 1
      & elementSize = storage_size(item%cholesky) / 8 )
d348 1
d352 1
d357 2
d360 1
a360 1
      & elementSize = storage_size(item%kronecker) / 8 )
d411 1
d415 1
d420 2
d423 1
a423 1
      & elementSize = storage_size(item%matrix) / 8 )
d446 1
d450 1
d455 2
d458 1
a458 1
      & elementSize = storage_size(item%spd) / 8 )
d914 1
d917 1
d924 4
d929 2
a930 1
      & uBounds = [z%row%nb,z%col%nb], elementSize = storage_size(z%block) / 8 )
d991 1
d1009 1
d1020 4
d1025 2
a1026 1
      & uBounds = [z%row%nb,z%col%nb], elementSize = storage_size(z%block) / 8 )
d1300 1
d1303 1
d1310 2
d1313 1
a1313 1
      call test_deallocate ( status, ModuleName, "A%Block", s )
d1334 1
d1336 2
a1337 1
    integer :: Status  ! from deallocate
d1341 2
d1345 1
a1345 1
        & storage_size(database%matrix) / 8 )
d1348 2
d1352 1
a1352 1
        & storage_size(database%cholesky%m) / 8 )
d1355 2
d1359 1
a1359 1
        & storage_size(database%kronecker%m) / 8 )
d1362 2
d1366 1
a1366 1
        & storage_size(database%spd%m) / 8 )
d1374 1
d1377 1
d1385 2
d1388 2
a1389 1
    call test_deallocate ( status, ModuleName, "D in DestroyMatrixDatabase", s )
d1395 1
d1415 2
d1418 1
a1418 1
      type(matrix_t), pointer :: M
d1421 2
a1422 1
        & "D%matrix in DestroyMatrixDatabaseElement", storage_size(m) / 8 )
d2667 1
d3170 1
a3170 1
       "$Id: MatrixModule_1.f90,v 2.138 2014/10/08 19:28:17 vsnyder Exp $"
d3179 3
@


2.138
log
@Add DestroyMatrixDatabaseElement and use it from DestroyMatrixDatabase.
Add commented-out code to Add...ToDatabase to try to make final subroutine
work.  Couldn't make it work, so added comments about why we don't want
final subroutines for RC_Info and Matrix_T.  Change RC_Info%Vec from copy
to a pointer, with NULL() initialization.  Add shape to Dump_Struct.  Some
cannonball polishing.
@
text
@d239 2
a240 1
    type(Vector_T), pointer :: Vec => NULL() ! Vector used to define the row
d1174 2
a1175 1
    type(Vector_T), intent(in), target :: Vec
d1181 2
a1182 1
    rc%vec => vec
d2289 2
a2290 1
    nullify ( r%vec )
d2630 2
a2631 1
    a%vec => b%vec
d2654 1
a2654 1
    nullify ( rc%vec )
d3116 1
a3116 1
       "$Id: MatrixModule_1.f90,v 2.137 2014/09/05 00:14:21 vsnyder Exp $"
d3125 8
@


2.137
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d19 22
a40 22
  use allocate_deallocate, only: allocate_test, deallocate_test
  use dump_0, only: dump
  use highoutput, only: blankstocolumn, dumpsize, outputnamedvalue
  use lexer_core, only: where_t
  use matrixmodule_0, only: add_matrix_blocks, assignment(=), checkintegrity, &
    & choleskyfactor, clearlower, clearrows, columnscale, col_l1, copyblock, &
    & createblock, cyclicjacobi, densecyclicjacobi, densify, &
    & destroyblock, diff, dump, frobeniusnorm, &
    & getdiagonal, getmatrixelement, getmatrixkindstring, getvectorfromcolumn, &
    & invertcholesky, m_absent, m_column_sparse, m_banded, m_full, m_unknown, &
    & matrixelement_t, maxabsval, mindiag, multiply, multiplymatrix_xty, multiplymatrix_xy, &
    & multiplymatrix_xy_t, multiplymatrixvectornot, nullifymatrix, operator(+), &
    & reflectmatrix, rowscale, scaleblock, solvecholesky, &
    & sparsify, spill, transposematrix, updatediagonal
  use MLSkinds, only: rm, rv, r8, r4
  use MLSmessagemodule, only: MLSmessage, MLSmsg_error, MLSmsg_warning
  use output_m, only: blanks, newline, output
  use string_table, only: display_string, get_string
  use symbol_table, only: enter_terminal
  use symbol_types, only: t_identifier
  use vectorsmodule, only: clearundermask, clonevector, copyvector, vector_t, &
    & checkintegrity, nullifyvector
d72 1
a72 1
  public :: operator(+), ReflectMatrix, RC_Info, RowScale, RowScale_1, ScaleMatrix
d239 1
a239 1
    type(Vector_T) :: Vec               ! Vector used to define the row
d251 6
d261 1
a261 1
    type(where_t) :: Where     ! in input, if created if by L2CF
d264 4
d288 2
d308 4
d322 2
d326 7
d338 4
d352 2
d356 7
d396 5
a400 1
  ! Add a matrix of unspecified structure to the matrix database
d411 2
d415 8
d428 4
d442 2
d446 7
d1173 1
a1173 1
    type(Vector_T), intent(in) :: Vec
d1179 1
a1179 1
    rc%vec = vec
d1333 1
a1333 16
      if ( associated(d(i)%matrix) ) then
        call destroyMatrix ( d(i)%matrix )
        call deallocateMatrix ( d(i)%matrix )
      end if
      if ( associated(d(i)%cholesky) ) then
        call destroyMatrix ( d(i)%cholesky%m )
        call destroyMatrix ( d(i)%cholesky%m )
      end if
      if ( associated(d(i)%kronecker) ) then
        call destroyMatrix ( d(i)%kronecker%m )
        call destroyMatrix ( d(i)%kronecker%m )
      end if
      if ( associated(d(i)%spd) ) then
        call destroyMatrix ( d(i)%spd%m )
        call destroyMatrix ( d(i)%spd%m )
      end if
d1338 22
d1362 1
d1366 1
a1366 1
        & "D%matrix in DestroyMatrixDatabase", storage_size(m) / 8 )
d1368 1
a1368 1
  end subroutine DestroyMatrixDatabase
d2286 1
a2286 1
    call nullifyVector ( r%vec )
d2626 1
a2626 1
    a%vec = b%vec
d2629 15
a2643 9
    call allocate_test ( a%nelts, size(b%nelts), "a%nelts", &
      & ModuleName // '%CopyRCInfo' )
    a%nelts = b%nelts
    call allocate_test ( a%inst, size(b%inst), "a%inst", &
      & ModuleName // '%CopyRCInfo' )
    a%inst = b%inst
    call allocate_test ( a%quant, size(b%quant), "a%quant", &
      & ModuleName // '%CopyRCInfo' )
    a%quant = b%quant
d2649 3
d3077 2
d3111 1
a3111 1
       "$Id: MatrixModule_1.f90,v 2.136 2014/08/19 00:29:26 vsnyder Exp $"
d3120 3
@


2.136
log
@Add AllMatricesMemoryInUse, MatricesMemoryInUse, MatrixMemoryInUse
@
text
@d34 1
a34 2
  use MLSmessagemodule, only: MLSmessage, MLSmsg_allocate, &
    & MLSmsg_deallocate, MLSmsg_error, MLSmsg_warning
d296 1
d304 2
a305 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "Matrix database element" )
d313 1
d321 2
a322 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "Matrix database element" )
d359 1
d367 2
a368 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "Matrix database element" )
d376 1
d384 2
a385 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "Matrix database element" )
d831 1
d840 2
a841 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "Z%Block in CreateEmptyMatrix" )
d901 1
d929 2
a930 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "Z%Block in CreateEmptyMatrix" )
d1201 1
d1204 1
d1209 1
d1211 1
a1211 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & MLSMSG_DeAllocate // "A%Block in DestroyMatrix" )
d1231 1
d1238 2
a1239 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, moduleName, &
        & MLSMSG_Deallocate // 'PlainMatrix' )
d1243 2
a1244 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, moduleName, &
        & MLSMSG_Deallocate // 'CholeskyMatrix' )
d1248 2
a1249 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, moduleName, &
        & MLSMSG_Deallocate // 'KroneckerMatrix' )
d1253 2
a1254 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, moduleName, &
        & MLSMSG_Deallocate // 'SPDMatrix' )
d1261 1
d1264 1
a1264 1
    integer :: I, Status
d1285 1
d1287 1
a1287 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & MLSMSG_DeAllocate // "D in DestroyMatrixDatabase" )
d1292 2
a1293 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & MLSMSG_DeAllocate // "D%matrix in DestroyMatrixDatabase" )
d2536 2
d3027 1
a3027 1
       "$Id: MatrixModule_1.f90,v 2.135 2014/07/23 21:58:28 pwagner Exp $"
d3036 3
@


2.135
log
@Attempted to match names passed to allocate/deallocate
@
text
@d45 3
a47 2
  public :: AddToMatrixDatabase, AddToMatrix, AssignMatrix
  public :: Assignment(=), CheckIntegrity, CholeskyFactor, CholeskyFactor_1
d62 2
a63 1
  public :: Matrix_SPD_T, MaxAbsVal, MaxAbsVal_1, MaxL1
d281 5
d417 31
d1151 40
a1648 40
  ! ------------------------------------------ Describe Block -----
  subroutine DescribeBlock ( matrix, row, col )
    ! Print the row and column indices of a block and
    ! identify which quantity/instance they are.
    type(Matrix_T), intent(in) :: MATRIX
    integer, intent(in), optional :: ROW         ! Row index
    integer, intent(in), optional :: COL         ! Column index
    ! Executable code
    call output ( '[ ' )
    if ( present(row) .and. present(col) ) then
      call output ( row )
      call output ( col, before=', ' )
    else if ( present(row) ) then
      call output ( row, before='row ' )
    else if ( present(col) ) then
      call output ( col, before ='col ' )
    else
      call output ( 'row and column not specified' )
    end if
    call output ( ' ] ( ' )
    if ( present(row) .and. present(col) ) then
      call display_string ( matrix%row%vec%quantities ( &
        & matrix%row%quant(row) )%template%name )
      call output ( matrix%row%inst(row), before='[' )
      call display_string ( matrix%col%vec%quantities ( &
        & matrix%col%quant(col) )%template%name, before='], ' )
      call output ( matrix%col%inst(col), before='[' )
    else if ( present(row) ) then
      call display_string ( matrix%row%vec%quantities ( &
        & matrix%row%quant(row) )%template%name, before='row ' )
      call output ( matrix%row%inst(row), before='[' )
      call output ( ']' )
    else if ( present(col) ) then
      call display_string ( matrix%col%vec%quantities ( &
        & matrix%col%quant(col) )%template%name, before='col ' )
      call output ( matrix%col%inst(col), before='[' )
    end if
    call output ( '] )', advance='yes' )
  end subroutine DescribeBlock

d1710 46
d3016 1
a3016 1
       "$Id: MatrixModule_1.f90,v 2.134 2014/01/09 00:24:29 pwagner Exp $"
d3025 3
@


2.134
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d19 23
a41 23
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only: DUMP
  use HIGHOUTPUT, only: BLANKSTOCOLUMN, DUMPSIZE, OUTPUTNAMEDVALUE
  use LEXER_CORE, only: WHERE_T
  use MATRIXMODULE_0, only: ADD_MATRIX_BLOCKS, ASSIGNMENT(=), CHECKINTEGRITY, &
    & CHOLESKYFACTOR, CLEARLOWER, CLEARROWS, COLUMNSCALE, COL_L1, COPYBLOCK, &
    & CREATEBLOCK, CYCLICJACOBI, DENSECYCLICJACOBI, DENSIFY, &
    & DESTROYBLOCK, DIFF, DUMP, FROBENIUSNORM, &
    & GETDIAGONAL, GETMATRIXELEMENT, GETMATRIXKINDSTRING, GETVECTORFROMCOLUMN, &
    & INVERTCHOLESKY, M_ABSENT, M_COLUMN_SPARSE, M_BANDED, M_FULL, M_UNKNOWN, &
    & MATRIXELEMENT_T, MAXABSVAL, MINDIAG, MULTIPLY, MULTIPLYMATRIX_XTY, MULTIPLYMATRIX_XY, &
    & MULTIPLYMATRIX_XY_T, MULTIPLYMATRIXVECTORNOT, NULLIFYMATRIX, OPERATOR(+), &
    & REFLECTMATRIX, ROWSCALE, SCALEBLOCK, SOLVECHOLESKY, &
    & SPARSIFY, SPILL, TRANSPOSEMATRIX, UPDATEDIAGONAL
  use MLSKINDS, only: RM, RV, R8, R4
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ALLOCATE, &
    & MLSMSG_DEALLOCATE, MLSMSG_ERROR, MLSMSG_WARNING
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT
  use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
  use SYMBOL_TABLE, only: ENTER_TERMINAL
  use SYMBOL_TYPES, only: T_IDENTIFIER
  use VECTORSMODULE, only: CLEARUNDERMASK, CLONEVECTOR, COPYVECTOR, VECTOR_T, &
    & CHECKINTEGRITY, NULLIFYVECTOR
d1076 5
a1080 5
      & "rc%nelts in CreateEmptyMatrix", ModuleName )
    call allocate_test ( rc%inst, rc%nb, "rc%inst in CreateEmptyMatrix", &
      & ModuleName )
    call allocate_test ( rc%quant, rc%nb, "rc%quant in CreateEmptyMatrix", &
      & ModuleName )
d2461 2
a2462 2
    call allocate_test ( a%nelts, size(b%nelts), "a%nelts in CopyRCInfo", &
      & moduleName )
d2464 2
a2465 2
    call allocate_test ( a%inst, size(b%inst), "a%inst in CopyRCInfo", &
      & moduleName )
d2467 2
a2468 2
    call allocate_test ( a%quant, size(b%quant), "a%quant in CopyRCInfo", &
      & moduleName )
d2475 3
a2477 3
    call deallocate_test ( rc%nelts, "rc%nelts in DestroyRCInfo", moduleName )
    call deallocate_test ( rc%inst, "rc%inst in DestroyRCInfo", moduleName )
    call deallocate_test ( rc%quant, "rc%quant in DestroyRCInfo", moduleName )
d2932 1
a2932 1
       "$Id: MatrixModule_1.f90,v 2.133 2013/09/24 23:27:14 vsnyder Exp $"
d2941 3
@


2.133
log
@Use Get_Where or Print_Source to start error messages
@
text
@d21 2
a22 1
  use Lexer_Core, only: Where_T
d36 1
a36 2
  use OUTPUT_M, only: BLANKS, BLANKSTOCOLUMN, DUMPSIZE, NEWLINE, &
    & OUTPUT, OUTPUTNAMEDVALUE
d2932 1
a2932 1
       "$Id: MatrixModule_1.f90,v 2.132 2013/08/08 02:37:57 vsnyder Exp $"
d2941 3
@


2.132
log
@Only dump RC_Info stuff for selected row or column
@
text
@d21 1
d254 1
a254 1
    integer :: Where = 0       ! Source_ref for creation if by L2CF
d874 1
a874 1
    integer, intent(in), optional :: Where             ! source_ref
d1139 1
a1139 1
    a%where = 0
d2505 1
a2505 1
    if ( matrix1%where > 0 .and. matrix2%where > 0 ) then
d2715 1
a2715 1
    if ( matrix%where > 0 ) then
d2932 1
a2932 1
       "$Id: MatrixModule_1.f90,v 2.131 2012/07/19 19:39:48 vsnyder Exp $"
d2941 3
@


2.131
log
@No, "inst" should be "quant" in CreateBlock_1.
@
text
@d1210 1
a1210 1
  subroutine Dump_RC ( RC, R_or_C, Details )
d1214 16
a1229 18
    call output ( 'Number of ' )
    call output ( r_or_c )
    call output ( ' blocks = ' )
    call output ( rc%nb )
    call output ( ' Vector that defines ' )
    call output ( r_or_c )
    call output ( 's' )
    if ( rc%vec%name == 0 ) then
      call output ( ' has no name', advance='yes' )
    else
      call output ( ': ' )
      call display_string ( rc%vec%name, advance='yes' )
    end if
    call output ( 'Order of '//r_or_c//' blocks is ' )
    if ( rc%instFirst ) then
      call output ( 'instance, then quantity', advance='yes' )
    else
      call output ( 'quantity, then instance', advance='yes' )
d1232 20
a1251 6
      call output ( 'Numbers of ' )
      call output ( r_or_c )
      call output ( 's in each block' )
      call output ( ':', advance='yes' )
      if ( .not. associated(rc%nelts) ) then
        call output( 'numbers not associated', advance='yes' )
d1253 21
a1273 20
        call dump ( rc%nelts )
      endif
      call output ( 'Instance indices for blocks in the ' )
      call output ( r_or_c )
      call output ( 's' )
      call output ( ':', advance='yes' )
      if ( .not. associated(rc%inst) ) then
        call output( 'indices not associated', advance='yes' )
      else
        call dump ( rc%inst )
      endif
      call output ( 'Quantity indices for blocks in the ' )
      call output ( r_or_c )
      call output ( 's' )
      call output ( ':', advance='yes' )
      if ( .not. associated(rc%quant) ) then
        call output( 'indices not associated', advance='yes' )
      else
        call dump ( rc%quant )
      endif
d2721 2
a2722 2
      call dump_rc ( matrix%row, 'row', my_details>0 )
      call dump_rc ( matrix%col, 'column', my_details>0 )
d2931 1
a2931 1
       "$Id: MatrixModule_1.f90,v 2.130 2012/07/18 22:14:29 vsnyder Exp $"
d2940 3
@


2.130
log
@'quant' should be 'inst' in CreateBlock_1
@
text
@d852 1
a852 1
      & nChan=z%row%vec%quantities(z%row%inst(rowNum))%template%noChans )
d2918 1
a2918 1
       "$Id: MatrixModule_1.f90,v 2.128 2012/06/15 23:30:58 vsnyder Exp $"
d2927 3
@


2.129
log
@Send the number of channels for a row block into CreateBlock_0 so that
the dimensions of VALUE3 can be set correctly.
@
text
@d852 1
a852 1
      & nChan=z%row%vec%quantities(z%row%quant(rowNum))%template%noChans )
@


2.128
log
@Explain summary of dump better
@
text
@d851 2
a852 1
      & bandHeight=bandHeight, init=init, forWhom=forWhom )
d2918 1
a2918 1
       "$Id: MatrixModule_1.f90,v 2.127 2012/02/16 22:47:51 pwagner Exp $"
d2927 3
@


2.127
log
@Separated Dump_Matrix_Layout from Dump_Matrix
@
text
@d2761 3
a2763 2
    call output ( matrix%col%nb, before=' rows and ' )
    call output ( totalSize, before=' columns with ', after=' elements.', advance='yes' )
d2917 1
a2917 1
       "$Id: MatrixModule_1.f90,v 2.126 2012/02/10 23:50:12 vsnyder Exp $"
d2926 3
@


2.126
log
@Cannonball polishing
@
text
@d34 2
a35 1
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE, DUMPSIZE
d51 1
a51 1
  public :: Diff, Dump, Dump_Linf, Dump_RC, Dump_Struct, FindBlock
d132 4
d2467 1
a2467 2
    use Lexer_core, only: Print_Source
    use Output_m, only: newLine
a2479 1
    character(len=16) :: string
d2606 64
d2672 1
a2672 2
    use Lexer_core, only: Print_Source
    use Output_m, only: newLine
d2679 2
a2680 1
    !  == One => Details of matrix but not its blocks,
d2715 1
d2916 1
a2916 1
       "$Id: MatrixModule_1.f90,v 2.125 2012/02/02 01:14:49 pwagner Exp $"
d2925 3
@


2.125
log
@Diffing matrices skips absent blocks
@
text
@d1354 1
a2609 1
    integer, intent(in), optional :: Row, Column ! Only do these
d2615 1
d2848 1
a2848 1
       "$Id: MatrixModule_1.f90,v 2.124 2011/12/17 00:34:40 vsnyder Exp $"
d2857 3
@


2.124
log
@Add GetFullBlock (moved from Convolve_All)
@
text
@d19 1
a19 1
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d21 19
a39 18
  use MatrixModule_0, only: Add_Matrix_Blocks, Assignment(=), CheckIntegrity, &
    & CholeskyFactor, ClearLower, ClearRows, ColumnScale, Col_L1, CopyBlock, &
    & CreateBlock, CyclicJacobi, DenseCyclicJacobi, Densify, &
    & DestroyBlock, Diff, Dump, FrobeniusNorm, GetDiagonal, GetMatrixElement, GetVectorFromColumn, &
    & InvertCholesky, M_Absent, M_Column_Sparse, M_Banded, M_Full, M_Unknown, &
    & MatrixElement_T, MaxAbsVal, MinDiag, Multiply, MultiplyMatrix_XTY, MultiplyMatrix_XY, &
    & MultiplyMatrix_XY_T, MultiplyMatrixVectorNoT, NullifyMatrix, operator(+), &
    & ReflectMatrix, RowScale, ScaleBlock, SolveCholesky, &
    & Sparsify, Spill, TransposeMatrix, UpdateDiagonal
  use MLSKinds, only: RM, RV, R8, R4
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, &
    & MLSMSG_DeAllocate, MLSMSG_Error, MLSMSG_Warning
  use OUTPUT_M, only: BLANKS, OUTPUT, DUMPSIZE
  use String_Table, only: Display_String, Get_String
  use Symbol_Table, only: Enter_Terminal
  use Symbol_Types, only: T_identifier
  use VectorsModule, only: ClearUnderMask, CloneVector, CopyVector, Vector_T, &
    & CheckIntegrity, NullifyVector
d41 1
a41 1
  implicit NONE
d2474 3
a2476 1

d2502 1
d2509 5
d2517 7
d2847 1
a2847 1
       "$Id: MatrixModule_1.f90,v 2.123 2011/06/16 20:17:32 vsnyder Exp $"
d2856 3
@


2.123
log
@Add row, column arguments to dump
@
text
@d44 10
a53 8
  public :: ClearLower, ClearLower_1, ClearMatrix, ClearRows, ClearRows_1, ColumnScale, ColumnScale_1
  public :: CopyMatrix, CopyMatrixValue, CreateBlock, CreateBlock_1, CreateEmptyMatrix
  public :: CyclicJacobi, DefineRCInfo, DestroyBlock, DestroyBlock_1, DestroyMatrix
  public :: DestroyMatrixInDatabase, DestroyMatrixDatabase, DestroyRCInfo, Diff, Dump, Dump_Linf
  public :: Dump_RC, Dump_Struct, FindBlock, FrobeniusNorm, GetActualMatrixFromDatabase
  public :: GetDiagonal, GetDiagonal_1, GetFromMatrixDatabase, GetKindFromMatrixDatabase
  public :: GetMatrixElement, GetMatrixElement_1, GetVectorFromColumn
  public :: GetVectorFromColumn_1, GetVectorFromColumn_1_Q_I
d1353 25
d2831 1
a2831 1
       "$Id: MatrixModule_1.f90,v 2.122 2011/01/13 00:23:19 vsnyder Exp $"
d2840 3
@


2.122
log
@Add GetVectorFromColumn_1_Q_I
@
text
@d2560 1
a2560 1
  subroutine Dump_Matrix ( Matrix, Name, Details, clean )
d2566 1
d2574 1
d2577 1
d2604 12
a2615 2
    do j = 1, matrix%col%nb
      do i = 1, matrix%row%nb
d2804 1
a2804 1
       "$Id: MatrixModule_1.f90,v 2.121 2010/09/25 01:15:23 vsnyder Exp $"
d2813 3
@


2.121
log
@Add an 'Instance' argument to MultiplyMatrixVectorNoT_1
@
text
@d51 2
a52 1
  public :: GetVectorFromColumn_1, InvertCholesky, InvertCholesky_1
d142 1
a142 1
    module procedure GetVectorFromColumn_1
d1443 5
a1447 2
  subroutine GetVectorFromColumn_1 ( Matrix, Column, Vector )
  ! Fill the Vector from the Column of the Matrix
d1451 1
d1457 1
d1460 2
a1461 2
      & 'In "GetVectorFromColumn", "Column" < 1' )
    if ( matrix%col%vec%template%name /= vector%template%name ) &
d1463 1
a1463 1
      & "Vector incompatible with matrix in GetVectorFromColumn" )
d1465 5
d1473 1
a1473 1
        do row = 1, matrix%row%nb
d1483 1
a1483 1
      & 'In "GetVectorFromColumn", "Column" is greater than number&
d1487 35
d2791 1
a2791 1
       "$Id: MatrixModule_1.f90,v 2.120 2010/08/13 22:04:08 pwagner Exp $"
d2800 3
@


2.120
log
@Added diff
@
text
@d21 1
a21 1
  use MatrixModule_0, only: Add_Matrix_Blocks, Assignment(=), CheckIntegrity, & 
d24 6
a29 6
    & DestroyBlock, Diff, Dump, FrobeniusNorm, GetDiagonal, GetMatrixElement, GetVectorFromColumn, & 
    & InvertCholesky, M_Absent, M_Column_Sparse, M_Banded, M_Full, M_Unknown, &            
    & MatrixElement_T, MaxAbsVal, MinDiag, Multiply, MultiplyMatrix_XTY, MultiplyMatrix_XY, &       
    & MultiplyMatrix_XY_T, MultiplyMatrixVectorNoT, NullifyMatrix, operator(+), &              
    & ReflectMatrix, RowScale, ScaleBlock, SolveCholesky, &     
    & Sparsify, Spill, TransposeMatrix, UpdateDiagonal                                    
d84 1
a84 1
  
d272 1
a272 1
  private :: not_used_here 
d318 1
a318 1
  ! !!!!! ===== END NOTE ===== !!!!! 
d422 1
a422 1
    
d526 1
a526 1
    
d558 1
a558 1
        call DescribeBlock ( matrix, row, col )    
d574 1
a574 1
    
d612 1
a612 1
!  
d614 1
a614 1
!  
d890 1
a890 1
    type(Matrix_T), intent(inout) :: A ! Matrix to diagonalize, 
d973 1
a973 1
            
d1050 1
a1050 1
          
d1056 1
a1056 1
    
d1059 1
a1059 1
    
d1101 1
a1101 1
  
d1276 1
a1276 1
    ! Compute the Frobenius norm of the matrix (sum of square of all 
d1478 1
a1478 1
    ! Print the row and column indices of a block and 
d1513 1
a1513 1
    call output ( '] )', advance='yes' )       
d1642 1
a1642 1
  ! !!!!! ===== END NOTE ===== !!!!! 
d1824 2
a1825 3
  subroutine MultiplyMatrixVectorNoT_1 ( A, V, Z, UPDATE, Clone )
  ! Z = A V if UPDATE is absent or false.  Z is first cloned from the
  !     rows-labeling of A.
d1834 2
d1843 1
d1859 7
a1865 1
    do i = 1, a%row%nb
d1872 3
d1942 1
a1942 1
  
d1962 1
a1962 1
  ! !!!!! ===== END NOTE ===== !!!!! 
d2286 1
a2286 1
    
d2599 1
a2599 1
    !  <= -3 => no details, just summarize the database 
d2745 1
a2745 1
       "$Id: MatrixModule_1.f90,v 2.119 2010/08/06 22:59:53 pwagner Exp $"
d2754 3
@


2.119
log
@Should crash less easily
@
text
@d24 1
a24 1
    & DestroyBlock, Dump, FrobeniusNorm, GetDiagonal, GetMatrixElement, GetVectorFromColumn, & 
d47 1
a47 1
  public :: DestroyMatrixInDatabase, DestroyMatrixDatabase, DestroyRCInfo, Dump, Dump_Linf
d118 4
d2374 82
d2734 1
a2734 1
       "$Id: MatrixModule_1.f90,v 2.118 2010/04/17 01:41:57 vsnyder Exp $"
d2743 3
@


2.118
log
@Dump_Matrix calls Dump_Struct if details == -1
@
text
@d1224 5
a1228 1
      call dump ( rc%nelts )
d1233 5
a1237 1
      call dump ( rc%inst )
d1242 5
a1246 1
      call dump ( rc%quant )
d2648 1
a2648 1
       "$Id: MatrixModule_1.f90,v 2.117 2010/03/24 20:39:12 vsnyder Exp $"
d2657 3
@


2.117
log
@Make Dump_RC public and part of Dump generic
@
text
@d2413 1
d2445 1
d2492 1
d2578 1
a2578 2
      call output ( 'Name = ' )
      call display_string ( matrix%name, advance='yes' )
d2604 2
a2605 5
    call output ( 'Total matrix size: ' )
    call output ( sum(matrix%row%nelts) )
    call output ( ' rows, ' )
    call output ( sum(matrix%col%nelts) )
    call output ( ' columns, ' )
d2636 1
a2636 1
       "$Id: MatrixModule_1.f90,v 2.116 2010/02/25 18:05:21 pwagner Exp $"
d2645 3
@


2.116
log
@Conforms with changed l2pc structure
@
text
@d48 2
a49 2
  public :: Dump_Struct, FindBlock, FrobeniusNorm, GetActualMatrixFromDatabase, GetDiagonal
  public :: GetDiagonal_1, GetFromMatrixDatabase, GetKindFromMatrixDatabase
d119 1
d1195 43
a2558 43
  ! ----------------------------------------------------  Dump_RC  -----
  subroutine Dump_RC ( RC, R_or_C, Details )
    type(rc_info), intent(in) :: RC
    character(len=*), intent(in) :: R_or_C
    logical, intent(in) :: Details
    call output ( 'Number of ' )
    call output ( r_or_c )
    call output ( ' blocks = ' )
    call output ( rc%nb )
    call output ( ' Vector that defines ' )
    call output ( r_or_c )
    call output ( 's' )
    if ( rc%vec%name == 0 ) then
      call output ( ' has no name', advance='yes' )
    else
      call output ( ': ' )
      call display_string ( rc%vec%name, advance='yes' )
    end if
    call output ( 'Order of '//r_or_c//' blocks is ' )
    if ( rc%instFirst ) then
      call output ( 'instance, then quantity', advance='yes' )
    else
      call output ( 'quantity, then instance', advance='yes' )
    end if
    if ( details ) then
      call output ( 'Numbers of ' )
      call output ( r_or_c )
      call output ( 's in each block' )
      call output ( ':', advance='yes' )
      call dump ( rc%nelts )
      call output ( 'Instance indices for blocks in the ' )
      call output ( r_or_c )
      call output ( 's' )
      call output ( ':', advance='yes' )
      call dump ( rc%inst )
      call output ( 'Quantity indices for blocks in the ' )
      call output ( r_or_c )
      call output ( 's' )
      call output ( ':', advance='yes' )
      call dump ( rc%quant )
    end if
  end subroutine Dump_RC

d2637 1
a2637 1
       "$Id: MatrixModule_1.f90,v 2.115 2009/06/23 18:25:42 pwagner Exp $"
d2646 3
@


2.115
log
@Prevent Intel from optimizing ident string away
@
text
@d46 2
a47 2
  public :: CyclicJacobi, DestroyBlock, DestroyBlock_1, DestroyMatrix
  public :: DestroyMatrixInDatabase, DestroyMatrixDatabase, Dump, Dump_Linf
d64 1
a64 1
  public :: NewMultiplyMatrixVector, NormalEquations, NullifyMatrix, NullifyMatrix_1
d266 1
a266 1
       "$RCSfile: $"
d866 2
a867 2
    call defineInfo ( z%row, row, row_Quan_First )
    call defineInfo ( z%col, col, col_Quan_First )
a877 50
  contains
    subroutine DefineInfo ( RC, Vec, QuanFirst )
      type(RC_Info), intent(out) :: RC
      type(Vector_T), intent(in) :: Vec
      logical, intent(in), optional :: QuanFirst

      integer :: I, J, N      ! Subscripts or loop inductors
      logical :: NEW          ! Was an instance seen?

      rc%vec = vec
      rc%instFirst = .true.
      if ( present(quanFirst) ) rc%instFirst = .not. quanFirst
      rc%nb = vec%template%totalInstances
      call allocate_test ( rc%nelts, rc%nb, &
        & "rc%nelts in CreateEmptyMatrix", ModuleName )
      call allocate_test ( rc%inst, rc%nb, "rc%inst in CreateEmptyMatrix", &
        & ModuleName )
      call allocate_test ( rc%quant, rc%nb, "rc%quant in CreateEmptyMatrix", &
        & ModuleName )
      if ( rc%instFirst ) then
!??? Are rc%nelts etc. different if the vector is not regular?
        n = 0
        j = 0
        do ! ( until .not. new )
          j = j + 1           ! instance number
          new = .false.       ! Instance j not seen for any quantity
          do i = 1, size(vec%quantities)
            if ( size(vec%quantities(i)%values,2) >= j ) then
              n = n + 1
              rc%nelts(n) = size(vec%quantities(i)%values,1)
              rc%inst(n) = j
              rc%quant(n) = i
              new = .true.    ! Instance j seen for some quantity
            end if
          end do ! i
          if ( .not. new ) exit
        end do ! j
      else
!??? Are rc%nelts etc. different if the vector is not regular?
        n = 0
        do i = 1, size(vec%quantities)
          do j = 1, size(vec%quantities(i)%values,2)
            n = n + 1
            rc%nelts(n) = size(vec%quantities(i)%values,1)
            rc%inst(n) = j
            rc%quant(n) = i
          end do ! j
        end do ! i
      end if
    end subroutine DefineInfo
d1046 51
d2636 1
a2636 1
       "$Id: read_apriori.f90 is it here $"
d2645 3
@


2.114
log
@Get kinds from MLSKinds instead of MLSCommon
@
text
@d266 1
a266 1
       "$RCSfile: MatrixModule_1.f90,v $"
d2632 1
a2633 1
!---------------------------- RCS Ident Info -------------------------------
d2635 2
a2636 3
       "$Id: MatrixModule_1.f90,v 2.113 2007/10/02 22:48:06 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2638 1
d2640 1
d2644 3
@


2.113
log
@Add a FAIL flag to GetMatrixFromDatabase
@
text
@d30 1
a30 1
  use MLSCommon, only: RM, RV, R8, R4
d2635 1
a2635 1
       "$Id: MatrixModule_1.f90,v 2.112 2007/09/12 00:16:37 vsnyder Exp $"
d2643 3
@


2.112
log
@Spiff up DescribeBlock routine
@
text
@d1352 1
a1352 1
  subroutine GetMatrixFromDatabase ( DatabaseElement, Matrix )
d1357 2
d1367 3
a1369 1
    call MLSMessage ( MLSMSG_Crash, moduleName, "No matrix to get from database" )
d2635 1
a2635 1
       "$Id: MatrixModule_1.f90,v 2.111 2006/08/01 03:18:27 vsnyder Exp $"
d2643 3
@


2.111
log
@Add ForWhom argument to CreateBlock for leak checking
@
text
@d1416 2
a1417 2
    integer,intent(in) :: ROW         ! Row index
    integer,intent(in) :: COL         ! Column index
d1420 10
a1429 3
    call output ( row )
    call output ( ', ' )
    call output ( col )
d1431 17
a1447 9
    call display_string ( matrix%row%vec%quantities ( &
      & matrix%row%quant(row) )%template%name )
    call output ( '[' )
    call output ( matrix%row%inst(row) )
    call output ( '], ' )
    call display_string ( matrix%col%vec%quantities ( &
      & matrix%col%quant(col) )%template%name )
    call output ( '[' )
    call output ( matrix%col%inst(col) )
d2631 1
a2631 1
       "$Id: MatrixModule_1.f90,v 2.110 2006/08/01 02:49:08 vsnyder Exp $"
d2639 3
@


2.110
log
@Remove unused .TX. defined operator, which leaks memory anyway
@
text
@d787 1
a787 1
        call createBlock ( z, i, j, m_absent ) ! Create block w/correct size
d819 1
a819 1
    &                        Init )
d834 1
d837 1
a837 1
      & bandHeight=bandHeight, init=init )
d874 1
a874 1
        call createBlock ( z, i, j, m_absent )
d2616 1
a2616 1
       "$Id: MatrixModule_1.f90,v 2.109 2006/07/28 01:58:17 vsnyder Exp $"
d2624 3
@


2.109
log
@Correct a bug in size accumulation, plus cannonball polishing
@
text
@d28 1
a28 1
    & operator(.TX.), ReflectMatrix, RowScale, ScaleBlock, SolveCholesky, &     
a64 1
  public :: operator(.TX.)
a186 4
  interface operator ( .TX. )      ! A^T B
    module procedure MultiplyMatrix_XTY_1_OP, NewMultiplyMatrixVector
  end interface

a1617 7
  ! ---------------------------------------  MultiplyMatrix_XTY_1_OP  -----
  function MultiplyMatrix_XTY_1_OP ( X, Y ) result ( Z ) ! Z = X^T Y
    type(Matrix_T), intent(in) :: X, Y
    type(Matrix_T) :: Z
    call MultiplyMatrix_XTY_1 ( X, Y, Z )
  end function MultiplyMatrix_XTY_1_OP

d2615 1
a2615 1
       "$Id: MatrixModule_1.f90,v 2.108 2006/07/27 03:55:56 vsnyder Exp $"
d2623 3
@


2.108
log
@Print summaries if negative details levels, for leak detection
@
text
@d2387 4
a2390 1
    if ( .not. associated(matrix%block) ) return
d2440 2
a2441 1
    integer :: I, MyDetails, TotalSize
d2449 1
a2449 1
    totalSize = 0
d2467 5
a2471 1
    call output ( totalSize, before=' matrices with ' )
d2480 2
a2481 2
          if ( associated(theMatrix%block(i,j)%values) ) &
            totalSize = totalSize + size(theMatrix%block(i,j)%values)
d2627 1
a2627 1
       "$Id: MatrixModule_1.f90,v 2.107 2006/05/23 21:43:34 vsnyder Exp $"
d2635 3
@


2.107
log
@Add CLEAR option to some dumps
@
text
@d244 1
d846 1
a846 1
    &,                           Row_Quan_First, Col_Quan_First, Text )
d862 1
d872 1
d1126 1
d2353 2
d2358 3
a2360 1
    !  <= Zero => no details, == One => Details of matrix but not its blocks,
d2366 1
d2370 1
d2375 11
a2385 3
      call display_string ( matrix%name, advance='yes' )
    else
      if ( present(name) ) call output ( '', advance='yes' )
d2387 1
a2387 3
    if ( my_details < 0 ) return
    call dump_rc ( matrix%row, 'row', my_details>0 )
    call dump_rc ( matrix%col, 'column', my_details>0 )
d2390 3
a2392 1
        if ( my_details < 1 .and. matrix%block(i,j)%kind == m_absent ) cycle
d2422 3
d2431 4
a2434 1
    !  <= Zero => no details, == One => Details of matrix but not its blocks,
d2437 1
a2437 1
    integer :: I
d2439 3
d2443 3
d2447 1
a2447 2
      call output ( i, 4 )
      call output ( ': ' )
d2449 1
d2452 1
d2455 1
d2458 1
d2462 15
d2619 1
a2619 1
       "$Id: MatrixModule_1.f90,v 2.106 2005/12/16 23:25:58 pwagner Exp $"
d2627 3
@


2.106
log
@dumpSize moved from dump0 to output_m
@
text
@d1354 1
d1358 8
d2348 1
a2348 1
  subroutine Dump_Matrix ( Matrix, Name, Details )
d2354 1
d2375 2
a2376 4
        call output ( 'Block at row ' )
        call output ( i )
        call output ( ' and column ' )
        call output ( j )
d2378 7
a2384 3
        call display_string ( &
          & matrix%row%vec%quantities(matrix%row%quant(i))%template%name )
        call output ( ':' )
d2387 7
a2393 3
        call display_string ( &
          & matrix%col%vec%quantities(matrix%col%quant(j))%template%name )
        call output ( ':' )
d2400 1
a2400 1
          call dump ( matrix%block(i,j), details=my_details )
d2571 1
a2571 1
       "$Id: MatrixModule_1.f90,v 2.105 2005/06/22 17:25:49 pwagner Exp $"
d2579 3
@


2.105
log
@Reworded Copyright statement, moved rcs id
@
text
@d20 1
a20 1
  use DUMP_0, only: DUMP, DUMPSIZE
d33 1
a33 1
  use OUTPUT_M, only: BLANKS, OUTPUT
d270 1
a270 1
       "$RCSfile: $"
d2555 1
a2555 1
       "$Id: $"
d2563 3
@


2.104
log
@Added forgiveZeros option to UpdateDiagonal
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d268 1
a268 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: MatrixModule_1.f90,v 2.103 2005/05/25 02:14:43 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d270 2
a271 2
       "$RCSfile: MatrixModule_1.f90,v $"
  private not_used_here
d2553 5
d2563 3
@


2.103
log
@Use names for bounds for CHARS in Dump_Struct
@
text
@d262 1
a262 1
       "$Id: MatrixModule_1.f90,v 2.102 2004/10/14 04:54:25 livesey Exp $"
d2206 1
a2206 1
  subroutine UpdateDiagonalVec_1 ( A, X, SUBTRACT, SQUARE, INVERT )
d2215 1
d2230 1
a2230 1
          & subtract, invert )
d2236 1
a2236 1
          & subtract, invert )
d2553 3
@


2.102
log
@Added ClearLower_1
@
text
@d17 1
a17 1
    & InvertCholesky, M_Absent, M_Column_Sparse, M_Banded, M_Full, &            
d262 1
a262 1
       "$Id: MatrixModule_1.f90,v 2.101 2004/07/07 19:34:30 vsnyder Exp $"
d2480 1
a2480 1
    character :: CHARS(0:4) = (/ '-',   'B',   'S',   'F',  '?' /)
d2552 3
@


2.101
log
@Add Init argument to CreateBlock
@
text
@d14 2
a15 2
    & CholeskyFactor, ClearRows, ColumnScale, Col_L1, CopyBlock, CreateBlock, CyclicJacobi, & 
    & DenseCyclicJacobi, Densify, &
d36 1
a36 1
  public :: ClearMatrix, ClearRows, ClearRows_1, ColumnScale, ColumnScale_1
d82 4
d262 1
a262 1
       "$Id: MatrixModule_1.f90,v 2.100 2004/04/03 05:43:43 livesey Exp $"
d679 15
d2552 3
@


2.100
log
@Moved the DumpSize functionality into Dump_0
@
text
@d258 1
a258 1
       "$Id: MatrixModule_1.f90,v 2.99 2004/01/30 23:24:48 livesey Exp $"
d798 2
a799 1
  subroutine CreateBlock_1 ( Z, RowNum, ColNum, Kind, NumNonzeros, BandHeight )
d805 3
a807 2
  !   assumed to be uniform, and the R1 and R2 components are filled to
  !   reflect that assumption.
d813 1
d816 1
a816 1
      & bandHeight=bandHeight )
d2533 3
@


2.99
log
@Bug fixes to FrobeniusNorm and CyclicJacobi stuff
@
text
@d12 1
a12 1
  use DUMP_0, only: DUMP
d258 1
a258 1
       "$Id: MatrixModule_1.f90,v 2.98 2004/01/29 03:31:58 livesey Exp $"
a2456 3
    integer, parameter :: KB = 1024
    integer, parameter :: MB = KB * 1024
    integer, parameter :: GB = MB * 1024
d2507 1
a2507 1
      
d2509 1
a2509 13
    if ( n < kb ) then
      call output ( n*1.0, format='(f5.1)' )
      call output ( ' bytes', advance='yes' )
    else if ( n < Mb ) then
      call output ( n*1.0/kb, format='(f5.1)' )
      call output ( ' kb', advance='yes' )
    else if ( n < Gb ) then
      call output ( n*1.0/Mb, format='(f5.1)' )
      call output ( ' Mb', advance='yes' )
    else
      call output ( n*1.0/Gb, format='(f5.1)' )
      call output ( ' Gb', advance='yes' )
    end if
d2530 3
@


2.98
log
@Added CyclicJacobi stuff.  Also version of UpdateDiagonal that doesn't
insist on SPD matrices
@
text
@d258 1
a258 1
       "$Id: MatrixModule_1.f90,v 2.97 2004/01/24 03:22:20 livesey Exp $"
d929 1
a929 1
      myTol = sqrt ( tiny ( 0.0_rm ) )
d933 4
d977 1
a977 1
            & Vpp, Vqp, Vpq, Vqq, Vbit, tol=1e-9 )
d1206 1
a1206 1
        FrobeniusNorm_1 = FrobeniusNorm_1 + FrobeniusNorm ( m%block(c,c) )
d2545 4
@


2.97
log
@More checking in multiply
@
text
@d14 3
a16 2
    & CholeskyFactor, ClearRows, ColumnScale, Col_L1, CopyBlock, CreateBlock, & 
    & DestroyBlock, Dump, GetDiagonal, GetMatrixElement, GetVectorFromColumn, & 
d18 2
a19 2
    & MatrixElement_T, MaxAbsVal, MinDiag, Multiply, MultiplyMatrix_XY, &       
    & MultiplyMatrix_XY_T, MultiplyMatrixVectorNoT, operator(+), &              
d38 1
a38 1
  public :: DestroyBlock, DestroyBlock_1, DestroyMatrix
d40 1
a40 1
  public :: Dump_Struct, FindBlock, GetActualMatrixFromDatabase, GetDiagonal
d61 1
a61 1
  public :: UpdateDiagonal, UpdateDiagonal_1, UpdateDiagonalVec_1
d94 4
d111 4
d205 1
a205 1
    module procedure UpdateDiagonal_1, UpdateDiagonalVec_1
d258 1
a258 1
       "$Id: MatrixModule_1.f90,v 2.96 2004/01/24 01:02:28 livesey Exp $"
d904 162
d1182 25
d2142 1
a2142 1
    type(Matrix_SPD_T), intent(inout) :: A
d2163 2
a2164 2
    do i = 1, min(a%m%row%nb,a%m%col%nb)
      call updateDiagonal ( a%m%block(i,i), myLambda )
d2169 10
d2541 3
@


2.96
log
@Added TransposeMatrix_1
@
text
@d249 1
a249 1
       "$Id: MatrixModule_1.f90,v 2.95 2004/01/23 05:36:24 livesey Exp $"
d1352 8
d1361 1
a1361 2
          & "Incompatible arrays in MultiplyMatrix_XTY_1" )
    if ( .not. myUpdate ) then
d2335 3
@


2.95
log
@Added allowNameMismatch argument to CopyMatrixValues
@
text
@d59 1
a59 1
  public :: Sparsify_1, Sparsify
d191 4
d249 1
a249 1
       "$Id: MatrixModule_1.f90,v 2.94 2004/01/16 23:50:51 vsnyder Exp $"
d1717 1
a1717 1
        call TransposeMatrix ( m%block ( i, j ), m%block ( j, i ) )
d1915 21
d2328 3
@


2.94
log
@Make AssignMatrix public, fix a comment
@
text
@d245 1
a245 1
       "$Id: MatrixModule_1.f90,v 2.93 2003/09/15 17:45:18 livesey Exp $"
d761 1
a761 1
  subroutine CopyMatrixValue ( Z, X )   ! Copy the elements of X to Z.
d765 1
d767 6
a772 2
    if ( x%col%vec%template%name /= z%col%vec%template%name &
      & .or. x%row%vec%template%name /= z%row%vec%template%name &
d2303 3
@


2.93
log
@Added target declaration for fussy intel compiler
@
text
@d33 1
a33 1
  public :: AddToMatrixDatabase, AddToMatrix
d245 1
a245 1
       "$Id: MatrixModule_1.f90,v 2.92 2003/07/07 20:20:59 livesey Exp $"
d1004 1
a1004 1
    ! Get POINTER to the actuall Matrix_T part of any kind of matrix
d2298 3
@


2.92
log
@Mainly cosmetic changes
@
text
@d245 1
a245 1
       "$Id: MatrixModule_1.f90,v 2.91 2003/06/20 19:31:39 pwagner Exp $"
d1005 1
a1005 1
    type ( matrix_database_t), intent(in) :: DatabaseElement
d2298 3
@


2.91
log
@Changes to allow direct writing of products
@
text
@d245 1
a245 1
       "$Id: MatrixModule_1.f90,v 2.90 2003/06/03 19:21:38 livesey Exp $"
d534 2
a535 15
        call output ( 'Checking integrity of block [ ' )
        call output ( row )
        call output ( ', ' )
        call output ( col )
        call output ( ' ] ( ' )
        call display_string ( matrix%row%vec%quantities ( &
          & matrix%row%quant(row) )%template%name )
        call output ( '[' )
        call output ( matrix%row%inst(row) )
        call output ( '], ' )
        call display_string ( matrix%col%vec%quantities ( &
          & matrix%col%quant(col) )%template%name )
        call output ( '[' )
        call output ( matrix%col%inst(col) )
        call output ( '] )', advance='yes' )       
d606 2
d634 2
d1166 25
d1811 2
d1840 2
d2298 3
@


2.90
log
@Made CholeskyFactor and SolveCholesky return with status rather than
crash.  Also added invert option to GetDiagonal
@
text
@d245 1
a245 1
       "$Id: MatrixModule_1.f90,v 2.89 2003/02/21 04:06:30 livesey Exp $"
d301 2
a302 2
    if ( x%col%vec%template%id /= y%col%vec%template%id &
      & .or. x%row%vec%template%id /= y%row%vec%template%id &
d356 2
a357 2
    if ( x%col%vec%template%id /= y%col%vec%template%id &
      & .or. x%row%vec%template%id /= y%row%vec%template%id &
d582 2
a583 2
    if ( x%m%col%vec%template%id /= z%m%col%vec%template%id &
      & .or. x%m%row%vec%template%id /= z%m%row%vec%template%id &
d775 2
a776 2
    if ( x%col%vec%template%id /= z%col%vec%template%id &
      & .or. x%row%vec%template%id /= z%row%vec%template%id &
d1154 1
a1154 1
    if ( matrix%col%vec%template%id /= vector%template%id ) &
d1325 1
a1325 1
    if ( (x%row%vec%template%id /= y%row%vec%template%id)  .or. &
d1367 1
a1367 1
    if ( (x%col%vec%template%id /= y%row%vec%template%id)  .or. &
d1397 1
a1397 1
    if ( (x%col%vec%template%id /= y%col%vec%template%id)  .or. &
d1449 1
a1449 1
    if ( a%row%vec%template%id /= v%template%id ) &
d1459 1
a1459 1
      & a%col%vec%template%id /= z%template%id ) &
d1502 1
a1502 1
    if ( a%col%vec%template%id /= v%template%id ) &
d1510 1
a1510 1
      & a%row%vec%template%id /= z%template%id ) &
d1776 1
a1776 1
    if ( z%m%col%vec%template%id /= x%template%id ) &
d1933 1
a1933 1
    if ( a%m%col%vec%template%id /= x%template%id ) &
d2278 4
@


2.89
log
@Added some OpenMP stuff
@
text
@d245 1
a245 1
       "$Id: MatrixModule_1.f90,v 2.88 2003/02/12 02:10:52 livesey Exp $"
d568 1
a568 1
  subroutine CholeskyFactor_1 ( Z, X )
d573 1
d577 1
a577 1
    integer :: STATUS                   ! Status flag
d616 12
a627 6
    call choleskyFactor ( z%m%block(1,1), x%m%block(1,1), status )
    if ( status /= 0 ) then
      write ( line, '(a, i0, a)') &
        & 'Block (1,1) of matrix is not positive definite (element ', &
        & status, ')'
      call MLSMessage ( MLSMSG_Error, ModuleName, line )
d642 12
a653 7
      call choleskyFactor ( z%m%block(i,i), s, status )   ! z%m%block(i,i) = factor of s
      if ( status /= 0 ) then
        call dump ( s, name='Guilty party:' )
        write ( line, '(a, i0, a, i0, a, i0, a)') &
          & 'Block (',i,',',i,') of matrix is not positive definite (element ', &
          & status, ')'
        call MLSMessage ( MLSMSG_Error, ModuleName, line )
d668 1
d1040 1
a1040 1
  subroutine GetDiagonal_1 ( A, X, SquareRoot )
d1048 2
d1058 1
a1058 1
        & x%quantities(a%row%quant(i))%values(:,a%row%inst(i)), squareRoot )
d1754 1
a1754 1
  subroutine SolveCholesky_1 ( Z, X, RHS, TRANSPOSE )
d1765 1
d1770 2
d1792 13
a1804 1
          & transpose=.true. )
d1819 13
a1831 1
          & transpose=.false. )
d1834 1
d2278 3
@


2.88
log
@New code to support extended averaging kernels.  Rewrite of
MultiplyMatrix_XTY_1.
@
text
@d245 1
a245 1
       "$Id: MatrixModule_1.f90,v 2.87 2003/01/17 22:31:52 livesey Exp $"
d1322 1
d1332 1
d1358 1
d1366 1
d1390 1
d1407 1
d2235 4
@


2.87
log
@Trivial change to the dump_struct output format.
@
text
@d48 1
a48 1
  public :: Multiply, MultiplyMatrix_XTY_1
d168 1
a168 1
    module procedure MultiplyMatrix_XTY_1, NewMultiplyMatrixVector
d245 1
a245 1
       "$Id: MatrixModule_1.f90,v 2.86 2003/01/08 23:51:46 livesey Exp $"
d1270 2
a1271 1
  function MultiplyMatrix_XTY_1 ( X, Y ) result ( Z ) ! Z = X^T Y
d1273 8
a1280 1
    type(Matrix_T) :: Z
d1289 18
a1307 1
    call nullifyMatrix ( z ) ! for Sun's still useless compiler
d1314 4
a1317 1
    call createEmptyMatrix ( z, 0, x%col%vec, y%col%vec )
d1319 3
d1323 4
a1326 2
        call multiply ( x%block(1,i), y%block(1,j), z%block(i,j) )
        do k = 2, x%row%nb
d1328 1
a1328 1
            & update=.true. )
d1332 8
a1339 1
  end function MultiplyMatrix_XTY_1
d2229 3
@


2.86
log
@Added sparsify and handling of r4/r8 in dump_struct
@
text
@d245 1
a245 1
       "$Id: MatrixModule_1.f90,v 2.85 2002/11/22 12:53:59 mjf Exp $"
d2137 1
a2137 1
      call output ( matrix%row%nelts(i), places=5, advance='yes' )
d2189 3
@


2.85
log
@Didn't add nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d20 2
a21 2
    & Spill, TransposeMatrix, UpdateDiagonal                                    
  use MLSCommon, only: RM, RV, R8
d59 1
d183 4
d245 1
a245 1
       "$Id: MatrixModule_1.f90,v 2.84 2002/10/07 23:24:43 pwagner Exp $"
d1748 26
d2146 9
a2154 1
    n = n * 8
d2189 4
@


2.84
log
@Added idents to survive zealous Lahey optimizer
@
text
@d29 1
a29 1
    & CheckIntegrity
d240 1
a240 1
       "$Id: MatrixModule_1.f90,v 2.83 2002/09/21 00:00:51 vsnyder Exp $"
d294 1
d1277 1
d1510 1
d1592 1
a1592 1
    type ( Matrix_T ), intent(inout) :: M
a1594 5
    nullify ( M%block )
    nullify ( M%row%nelts, M%row%inst, M%row%quant )
    nullify ( M%col%nelts, M%col%inst, M%col%quant )
    m%row%nb = 0
    m%col%nb = 0
d1596 3
d1601 14
d2150 3
@


2.83
log
@Handle the UseMask flag in NormalEquations completely
@
text
@d13 8
a20 8
  use MatrixModule_0, only: Add_Matrix_Blocks, Assignment(=), CheckIntegrity, &
    & CholeskyFactor, ClearRows, ColumnScale, Col_L1, CopyBlock, CreateBlock, &
    & DestroyBlock, Dump, GetDiagonal, GetMatrixElement, GetVectorFromColumn, &
    & InvertCholesky, M_Absent, M_Column_Sparse, M_Banded, M_Full, &
    & MatrixElement_T, MaxAbsVal, MinDiag, Multiply, MultiplyMatrix_XY, &
    & MultiplyMatrix_XY_T, MultiplyMatrixVectorNoT, operator(+), &
    & operator(.TX.), ReflectMatrix, RowScale, ScaleBlock, SolveCholesky, &
    & Spill, TransposeMatrix, UpdateDiagonal
d240 1
a240 1
       "$Id: MatrixModule_1.f90,v 2.82 2002/09/13 18:08:12 pwagner Exp $"
d244 1
d2128 4
d2135 3
@


2.82
log
@May change matrix precision rm from r8
@
text
@d240 1
a240 1
       "$Id: MatrixModule_1.f90,v 2.81 2002/09/11 17:43:38 pwagner Exp $"
d1554 6
a1559 2
    call copyVector ( rhs_in, a%row%vec, noValues=.true.) ! Copy the row mask
    call clearRows ( a, row_block, rhs_in )
a1561 2
    my_Mask = .false.
    if ( present(useMask) ) my_Mask = useMask
d2130 3
@


2.81
log
@Began changes needed to conform with matrix%values type move to rm from r8
@
text
@d21 1
a21 1
  use MLSCommon, only: RM
d240 1
a240 1
       "$Id: MatrixModule_1.f90,v 2.80 2002/09/10 01:00:00 livesey Exp $"
d344 1
a344 1
    real(rm), intent(in), optional :: Scale
d1660 1
a1660 1
    real(rm), intent(in) :: A
d1752 1
a1752 1
    real(rm), intent(in) :: LAMBDA
d1758 1
a1758 1
    real(rm) :: MYLAMBDA
d2128 3
@


2.80
log
@Added NullifyMatrix
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d21 1
a21 1
  use MLSCommon, only: R8
d240 1
a240 1
       "$Id: MatrixModule_1.f90,v 2.79 2002/08/29 04:45:27 livesey Exp $"
d344 1
a344 1
    real(r8), intent(in), optional :: Scale
d1063 1
a1063 1
  real(r8) function GetMatrixElement_1 ( Matrix, Row, Col )
d1211 1
a1211 1
!   real(r8), intent(in) :: LAMBDA
d1215 1
a1215 1
  real(r8) function MaxAbsVal_1 ( A )
d1219 1
a1219 1
    maxAbsVal_1 = 0.0_r8
d1229 1
a1229 1
  real(r8) function MaxL1 ( A )
d1233 2
a1234 2
    real(r8) :: My_L1
    maxL1 = 0.0_r8
d1237 1
a1237 1
        my_L1 = 0.0_r8
d1247 1
a1247 1
  real(r8) function MinDiag_Cholesky ( A )
d1255 1
a1255 1
  real(r8) function MinDiag_SPD ( A )
d1660 1
a1660 1
    real(r8), intent(in) :: A
d1752 1
a1752 1
    real(r8), intent(in) :: LAMBDA
d1758 1
a1758 1
    real(r8) :: MYLAMBDA
d1766 1
a1766 1
        if ( abs(myLambda) < tiny(0.0_r8) ) call MLSMessage ( MLSMSG_Error, &
d1768 1
a1768 1
        myLambda = 1.0_r8 / myLambda
d2115 1
a2115 1
  real(r8) function MinDiag_1 ( A )
d2128 3
@


2.79
log
@Added diagonalOnly option to MultiplyMatrix_XY_T
@
text
@d55 2
a56 1
  public :: NewMultiplyMatrixVector, NormalEquations, operator(.TX.)
d162 4
d240 1
a240 1
       "$Id: MatrixModule_1.f90,v 2.78 2002/08/21 20:38:24 vsnyder Exp $"
d1583 14
d2128 3
@


2.78
log
@Add 'text' argument to CreateEmptyMatrix
@
text
@d235 1
a235 1
       "$Id: MatrixModule_1.f90,v 2.77 2002/08/20 19:49:26 vsnyder Exp $"
d1314 1
a1314 1
  subroutine MultiplyMatrix_XY_T_1 ( X, Y, Z ) ! Z = X Y^T
d1317 1
d1319 3
a1321 1
    integer :: I, J, K             ! Subscripts for [XYZ]%Block
d1329 3
d1334 8
a1341 1
      do i = 1, x%row%nb
d2109 3
@


2.77
log
@Embellish dump_struct -- add total rows and columns
@
text
@d25 3
a27 1
  use String_Table, only: Display_String, get_string
d235 1
a235 1
       "$Id: MatrixModule_1.f90,v 2.76 2002/08/19 20:51:26 vsnyder Exp $"
d784 1
a784 1
    &,                           Row_Quan_First, Col_Quan_First )
d798 2
d806 1
d2096 3
@


2.76
log
@Make AddToMatrix respect it's Scale argument
@
text
@d233 1
a233 1
       "$Id: MatrixModule_1.f90,v 2.75 2002/08/15 22:13:33 livesey Exp $"
d2054 4
d2059 1
a2059 1
    ! deal with the case when we decice to switch to r4)
d2091 3
@


2.75
log
@Bug fix in ColumnScale
@
text
@d13 8
a20 9
  use MatrixModule_0, only: Assignment(=), CheckIntegrity, CholeskyFactor, ClearRows, &
    & ColumnScale, Col_L1, CopyBlock, CreateBlock, DestroyBlock, Dump, &
    & GetDiagonal, GetMatrixElement, GetVectorFromColumn, InvertCholesky, &
    & M_Absent, M_Column_Sparse, M_Banded, M_Full, MatrixElement_T, MaxAbsVal, MinDiag, &
    & Multiply, MultiplyMatrix_XY, MultiplyMatrix_XY_T, &
    & MultiplyMatrixVectorNoT, &
    & operator(+), &
    & operator(.TX.), ReflectMatrix, RowScale, ScaleBlock, SolveCholesky, Spill, &
    & TransposeMatrix, UpdateDiagonal
d233 1
a233 1
       "$Id: MatrixModule_1.f90,v 2.74 2002/08/06 02:15:20 livesey Exp $"
d351 1
a351 1
          x%block(i,j) = x%block(i,j) + y%block(i,j) ! Defined =, +
d2087 3
@


2.74
log
@Added ReflectMatrix_1
@
text
@d234 1
a234 1
       "$Id: MatrixModule_1.f90,v 2.73 2002/08/03 20:41:51 livesey Exp $"
d708 1
a708 1
            & v%quantities(x%row%quant(j))%values(:,x%row%inst(j)), &
d716 1
a716 1
            & v%quantities(x%row%quant(j))%values(:,x%row%inst(j)) )
d2088 3
@


2.73
log
@Added GetActualMatrixFromDatabase
@
text
@d20 2
a21 2
    & operator(.TX.), RowScale, ScaleBlock, SolveCholesky, Spill, &
    & UpdateDiagonal
d55 1
a55 1
  public :: operator(+), RC_Info, RowScale, RowScale_1, ScaleMatrix
d164 4
d234 1
a234 1
       "$Id: MatrixModule_1.f90,v 2.72 2002/07/22 03:26:37 livesey Exp $"
d1561 16
d2088 3
@


2.72
log
@Added checkIntegrity
@
text
@d38 1
a38 1
  public :: Dump_Struct, FindBlock, GetDiagonal
d230 1
a230 1
       "$Id: MatrixModule_1.f90,v 2.71 2002/07/17 06:01:10 livesey Exp $"
d978 20
d2068 3
@


2.71
log
@Added trivial handling of M_Unknown
@
text
@d13 1
a13 1
  use MatrixModule_0, only: Assignment(=), CholeskyFactor, ClearRows, &
d26 3
a28 2
  use String_Table, only: Display_String
  use VectorsModule, only: ClearUnderMask, CloneVector, CopyVector, Vector_T
d33 1
a33 1
  public :: Assignment(=), CholeskyFactor, CholeskyFactor_1
d70 4
d230 1
a230 1
       "$Id: MatrixModule_1.f90,v 2.70 2002/07/01 23:50:03 vsnyder Exp $"
d374 176
d2048 3
@


2.70
log
@Plug memory leaks
@
text
@d225 1
a225 1
       "$Id: MatrixModule_1.f90,v 2.69 2002/06/22 06:50:25 livesey Exp $"
d1799 1
a1799 1
    character :: CHARS(0:3) = (/ '-',   'B',   'S',   'F' /)
d1867 3
@


2.69
log
@Added print of matrix size in -Sspa
@
text
@d225 1
a225 1
       "$Id: MatrixModule_1.f90,v 2.68 2002/06/18 01:22:49 vsnyder Exp $"
d511 3
a513 1
    type (Matrix_T), intent(out), target, optional :: NEWX 
d599 2
a600 1
    type(Matrix_T), intent(out) :: Z    ! The matrix to create
d602 1
a602 1
    type(Vector_T), intent(in) :: Row       ! Vector used to define the row
d604 1
a604 1
    type(Vector_T), intent(in) :: Col       ! Vector used to define the column
d616 1
d1364 3
a1366 1
    type (Matrix_T), intent(out), target, optional :: NEWX 
d1867 3
@


2.68
log
@Add Spill_1.  Cosmetic changes in LaTeX stuff and elsewhere.
@
text
@d16 1
a16 1
    & M_Absent, M_Banded, M_Full, MatrixElement_T, MaxAbsVal, MinDiag, &
d225 1
a225 1
       "$Id: MatrixModule_1.f90,v 2.67 2002/05/21 20:22:19 vsnyder Exp $"
d1789 3
d1794 1
a1794 1
    integer :: I, J
d1807 1
d1818 6
d1827 18
d1861 3
@


2.67
log
@Remove some commented-out obsolete code and its comments
@
text
@d20 1
a20 1
    & operator(.TX.), RowScale, ScaleBlock, SolveCholesky, &
d55 1
a55 1
  public :: SolveCholesky, SolveCholesky_1
d167 4
d225 1
a225 1
       "$Id: MatrixModule_1.f90,v 2.66 2002/04/22 20:53:58 vsnyder Exp $"
d390 2
a391 2
!{Suppose $A$ is symmetric and positive definite.  Regard $A = (A_{ij})$
!  and its upper-triangular Cholesky factor $G = (G_{ij})$ as $N \times N$
d393 1
a393 1
!  equation $A = G^T G$ with $i \leq j$, it follows that
d395 1
a395 1
!   A_{ij} = \sum_{k=1}^i G_{ki}^T G_{kj}
d399 3
a401 3
!  S = A_{ij} - \sum_{k=1}^{i-1} G_{ki}^T G_{kj}
!    = A_{ij} - \sum_{k=1}^i G_{ki}^T G_{kj} + G_{ii}^T G_{ij}
!    = G_{ii}^T G_{ij}
d407 2
a408 2
!  \hspace*{0.25in} $S= A_{ii} - \sum_{k=1}^{i-1} G_{ki}^T G_{ki}$\\
!  \hspace*{0.25in} $G_{ii} = $ Cholesky factor of $S$\\
d410 2
a411 2
!  \hspace*{0.5in}    $S= A_{ij} - \sum_{k=1}^{i-1} G_{ki}^T G_{kj}$\\
!  \hspace*{0.5in}    solve $G_{ii}^T G_{ij} = S$ for $G_{ij}$\\
d416 1
a416 1
    !{ $Z_{11}^T Z_{11} = X_{11}$
d423 1
a423 1
    endif
d430 1
a430 1
      call copyBlock ( s, x%m%block(i,i) )        ! Destroy s, then s := z...
d436 1
a436 1
      !{ $Z_{ii}^T Z_{ii} = S$
d439 1
a439 1
        call dump ( z%m%block(i,i)%values, name='Guilty party:' )
d444 1
a444 1
      endif
d446 9
a454 12
        if ( i == 1 ) then                        ! Avoid a copy
        else
          call copyBlock ( s, x%m%block(i,j) )    ! Destroy s, then s := x...
          do k = 1, i-1
            !{ $S = X_{ij} - \sum_{k=1}^{i-1} Z_{ki}^T Z_{kj}$
            call multiply ( z%m%block(k,i), z%m%block(k,j), s, &
              & update=.true., subtract=.true. )
          end do ! k = 1, i-1
          !{ Solve $Z_{ii}^T Z_{ij} = S$ for $Z_{ij}$
          call solveCholesky ( z%m%block(i,i), z%m%block(i,j), s, &
            & transpose=.true. )
        end if
d457 1
a457 1
    end do ! i = 1, n
d1462 23
d1547 1
a1547 1
    endif
d1833 3
@


2.66
log
@Add a 'scale' argument to AddToMatrix
@
text
@d221 1
a221 1
       "$Id: MatrixModule_1.f90,v 2.65 2002/03/05 23:31:07 livesey Exp $"
d936 4
a939 39
! !{Compute $B = U^{-T} = L^{-1}$, where $U$ is the upper-triangular
! ! Cholesky factor of some matrix, i.e. $A = U^T U$.  We do this by
! ! solving $U^T B = I$.  In algorithmic form, we have $\left \{
! ! \text{solve } u_{ii}^T b_{ik} = \left ( \delta_{ik} -
! ! \sum_{j=k}^{i-1} u_{ji}^T b_{jk} \right ) \text{ for } b_{ik},~~ k =
! ! 1 \dots i \right \},~~i = 1 \dots n$.

    type(Matrix_Cholesky_T), intent(inout) :: U ! inout because invertCholesky's
                                        ! U argument is inout to allow its UI
                                        ! argument to be the same.  We don't
                                        ! use that feature, so U isn't changed
                                        ! here.
    type(Matrix_T), intent(inout) :: B  ! Assume B has been created

    integer :: I, J, K                  ! Subscripts and loop inductors

!   do i = 1, u%m%row%nb
!     do k = 1, i
!       if ( i == k ) then ! start with identity, i.e. \delta_{ik}
!         call createBlock ( b%block(i,i), u%m%block(i,i)%nrows, &
!           & u%m%block(i,i)%nrows, m_banded, u%m%block(i,i)%nrows )
!         do j = 1, u%m%block(i,i)%nrows
!           b%block(i,k)%r1(j) = j
!           b%block(i,k)%r2(j) = j
!           b%block(i,k)%values(j,1) = 1.0_r8
!         end do ! j = 1, u%m%block(i,i)%nrows
!       else ! start with zero
!         call createBlock ( b%block(i,k), u%m%block(i,k)%nrows, &
!           & u%m%block(i,k)%ncols, m_absent )
!       end if
!       do j = k, i-1
!         call multiply ( u%m%block(j,i), b%block(j,k), &
!           & b%block(i,k), update=.true., subtract=.true. )
!       end do ! j = k, i-1
!       call solveCholesky ( u%m%block(i,i), b%block(i,k), transpose=.true. )
!     end do ! k = 1, i
!   end do ! i = 1, u%m%row%nb

  !{Let $u_{ij}$ be an element of $\bf U$ and $t_{ij}$ be an element of ${\bf
d953 9
d1809 3
@


2.66.2.1
log
@*** empty log message ***
@
text
@d221 1
a221 1
       "$Id: MatrixModule_1.f90,v 2.67 2002/05/21 20:22:19 vsnyder Exp $"
d936 39
a974 4
  !{Compute $B = U^{-1}$, where $U$ is the upper-triangular Cholesky factor of
  ! some matrix, i.e. $A = U^T U$.
  !
  ! Let $u_{ij}$ be an element of $\bf U$ and $t_{ij}$ be an element of ${\bf
a987 9
    type(Matrix_Cholesky_T), intent(inout) :: U ! inout because invertCholesky's
                                        ! U argument is inout to allow its UI
                                        ! argument to be the same.  We don't
                                        ! use that feature, so U isn't changed
                                        ! here.
    type(Matrix_T), intent(inout) :: B  ! Assume B has been created

    integer :: I, J, K                  ! Subscripts and loop inductors

a1834 6
! Revision 2.67  2002/05/21 20:22:19  vsnyder
! Remove some commented-out obsolete code and its comments
!
! Revision 2.66  2002/04/22 20:53:58  vsnyder
! Add a 'scale' argument to AddToMatrix
!
@


2.65
log
@Removed a diagnostic print that got left behind
@
text
@d19 2
a20 1
    & operator(+), operator(.TX.), RowScale, ScaleBlock, SolveCholesky, &
d31 1
a31 1
  public :: AddMatrices, AddToMatrixDatabase, AddToMatrix
a154 4
  interface operator (+)
    module procedure AddMatrices
  end interface

d221 1
a221 1
       "$Id: MatrixModule_1.f90,v 2.64 2002/03/05 23:17:03 livesey Exp $"
d322 1
a322 1
  subroutine AddToMatrix ( X, Y ) ! X = X + Y
d325 1
d336 13
a348 5
    do j = 1, x%col%nb
      do i = 1, x%row%nb
        x%block(i,j) = x%block(i,j) + y%block(i,j) ! Defined =, +
      end do ! i = 1, x%row%nb
    end do ! j = 1, x%col%nb
d1835 3
@


2.64
log
@Changes adopted from Van
@
text
@d224 1
a224 1
       "$Id: MatrixModule_1.f90,v 2.63 2002/02/22 01:19:31 vsnyder Exp $"
a995 1
          print*,'IJK',i,j,k
d1829 3
@


2.63
log
@Added MultiplyMatrix_XY_0, MultiplyMatrix_XY_T_1.  Changed the name of
MultiplyMatrices to Multiply_Matrix_XTY_1.  Added generics.
@
text
@d15 4
a18 3
    & GetDiagonal, GetMatrixElement, GetVectorFromColumn, M_Absent, &
    & M_Banded, M_Full, MatrixElement_T, MaxAbsVal, MinDiag, Multiply, &
    & MultiplyMatrix_XY, MultiplyMatrix_XY_T, MultiplyMatrixVectorNoT, &
d224 1
a224 1
       "$Id: MatrixModule_1.f90,v 2.62 2002/02/05 02:39:59 vsnyder Exp $"
d930 12
a941 3
  ! Compute B = U^{-T} = L^{-1}, where U is the upper-triangular
  ! Cholesky factor of some matrix, i.e. A = U^T U.
    type(Matrix_Cholesky_T), intent(in) :: U
d946 59
a1004 21
    do i = 1, u%m%row%nb
      do k = 1, i
        if ( i == k ) then ! start with identity
          call createBlock ( b%block(i,i), u%m%block(i,i)%nrows, &
            & u%m%block(i,i)%nrows, m_banded, u%m%block(i,i)%nrows )
          do j = 1, u%m%block(i,i)%nrows
            b%block(i,k)%r1(j) = j
            b%block(i,k)%r2(j) = j
            b%block(i,k)%values(j,1) = 1.0_r8
          end do ! j = 1, u%m%block(i,i)%nrows
        else ! start with zero
          call createBlock ( b%block(i,k), u%m%block(i,k)%nrows, &
            & u%m%block(i,k)%ncols, m_absent )
        end if
        do j = k, i-1
          call multiply ( b%block(i,k), u%m%block(j,i), &
            & b%block(j,k), update=.true., subtract=.true. )
        end do ! j = k, i-1
        call solveCholesky ( u%m%block(i,i), b%block(i,k), transpose=.true. )
      end do ! k = 1, i
    end do ! i = 1, u%m%row%nb
d1064 31
a1144 31
  ! ---------------------------------------  MultiplyMatrix_XTY_1  -----
  function MultiplyMatrix_XTY_1 ( X, Y ) result ( Z ) ! Z = X^T Y
    type(Matrix_T), intent(in) :: X, Y
    type(Matrix_T) :: Z

  ! !!!!! ===== IMPORTANT NOTE ===== !!!!!
  ! It is important to invoke DestroyMatrix using the result of this
  ! function after it is no longer needed. Otherwise, a memory leak will
  ! result.  Also see AssignMatrix.
  ! !!!!! ===== END NOTE ===== !!!!! 

    integer :: I, J, K             ! Subscripts for [XYZ]%Block

    ! Check that matrices are compatible.  We don't need to check
    ! Nelts or Nb, because these are deduced from Vec.
    if ( (x%row%vec%template%id /= y%row%vec%template%id)  .or. &
      & (x%row%instFirst .neqv. y%row%instFirst) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Incompatible arrays in MultiplyMatrix_XTY_1" )
    call createEmptyMatrix ( z, 0, x%col%vec, y%col%vec )
    do j = 1, y%col%nb
      do i = 1, x%col%nb
        call multiply ( x%block(1,i), y%block(1,j), z%block(i,j) )
        do k = 2, x%row%nb
          call multiply ( x%block(k,i), y%block(k,j), z%block(i,j), &
            & update=.true. )
        end do ! k = 2, x%row%nb
      end do ! i = 1, x%col%nb
    end do ! j = 1, y%col%nb
  end function MultiplyMatrix_XTY_1

d1830 4
@


2.62
log
@Change mask from 1-bit per to 8-bits per (using character)
@
text
@d17 1
a17 1
    & MultiplyMatrixVectorNoT, &
d38 1
a38 1
  public :: GetVectorFromColumn_1, InvertCholesky
d43 4
a46 1
  public :: MinDiag, MinDiag_Cholesky, MinDiag_SPD, Multiply, MultiplyMatrices
d121 4
d129 12
d158 1
a158 1
    module procedure MultiplyMatrices, NewMultiplyMatrixVector
d223 1
a223 1
       "$Id: MatrixModule_1.f90,v 2.61 2001/11/08 02:06:30 vsnyder Exp $"
d927 2
a928 2
  ! ---------------------------------------------  InvertCholesky  -----
  subroutine InvertCholesky ( U, B )
d957 1
a957 1
  end subroutine InvertCholesky
d1016 52
a1067 2
  ! -------------------------------------------  MultiplyMatrices  -----
  function MultiplyMatrices ( X, Y ) result ( Z ) ! Z = X^T Y
d1084 1
a1084 1
          & "Incompatible arrays in MultiplyMatrices" )
d1095 1
a1095 1
  end function MultiplyMatrices
d1782 3
@


2.61
log
@Added #rows to sparsness structure display
@
text
@a164 2
    logical :: Extra = .false.     ! There is an extra row or column that is
      ! not accounted for by vec.
d204 1
a204 1
       "$Id: MatrixModule_1.f90,v 2.60 2001/10/19 22:30:18 pwagner Exp $"
d449 5
a453 5
  ! Clear the rows of X for which the mask in X's row-defining vector
  ! has nonzero bits.  If RowBlock is present, it specifies that only
  ! the rows in that row block are to be cleared.  Otherwise, rows in
  ! all row blocks are cleared.  If the vector Vec is present, its
  ! elements that correspond to nonzero bits of its mask are cleared.
d1047 1
a1047 1
    integer, dimension(:), pointer :: MJ ! Mask for column J, if any
d1216 1
a1216 1
    integer, dimension(:), pointer :: MI, MJ ! Masks for columns I, J if any
d1713 3
@


2.60
log
@Now can dump a single matrixdb
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.59 2001/10/18 23:48:23 livesey Exp $"
d1697 1
a1697 1
      call output ( '', advance='yes' )
d1715 3
@


2.59
log
@Made dump_struct take up less space in the case of large matrices
@
text
@d90 1
a90 1
    module procedure Dump_Matrix, Dump_Matrix_Database
d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.58 2001/10/15 23:22:45 vsnyder Exp $"
d1545 1
d1601 19
d1715 3
@


2.58
log
@Make Z-cloning during MultiplyMatrixVector* optional
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.57 2001/10/04 23:49:57 livesey Exp $"
d1670 1
a1670 1
        call output ( ' ' )
d1695 3
@


2.57
log
@Added checking code, and temporarily suppressed sparse
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.56 2001/10/01 23:57:51 livesey Exp $"
d1031 1
a1031 1
  subroutine MultiplyMatrixVector_1 ( A, V, Z, UPDATE, UseMask )
d1036 2
a1037 1
  ! suppress columns.
d1043 1
d1050 1
d1061 6
a1066 3
    if ( my_update .and. a%col%vec%template%id /= z%template%id ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Matrix and result not compatible in MultiplyMatrixVector_1" )
d1068 2
a1069 1
    if ( .not. my_update ) call cloneVector ( z, v, vectorNameText='_z' )
d1088 1
a1088 1
  subroutine MultiplyMatrixVectorNoT_1 ( A, V, Z, UPDATE )
d1092 2
d1098 1
d1104 1
a1109 3
    if ( a%row%vec%template%id /= z%template%id ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Matrix and result not compatible in MultiplyMatrixVector_1" )
d1112 6
d1119 2
a1120 1
    if ( .not. my_update ) call cloneVector ( z, a%row%vec, vectorNameText='_z' )
d1695 3
@


2.56
log
@Removed clone vector call in GetDiagonal_1 to avoid problems with
snooping.
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.55 2001/09/28 23:34:20 vsnyder Exp $"
d350 2
d389 7
a395 1
    call choleskyFactor ( z%m%block(1,1), x%m%block(1,1) )
d409 8
a416 1
      call choleskyFactor ( z%m%block(i,i), s )   ! z%m%block(i,i) = factor of s
d1680 4
@


2.55
log
@Correct looking at row%inst to get column mask in NormalEquations
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.54 2001/09/27 18:41:05 vsnyder Exp $"
d773 3
a775 1
    call cloneVector ( x, a%row%vec, vectorNameText='_x' )
d1665 3
@


2.54
log
@Apply mask in forming RHS of normal equations
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.53 2001/09/27 00:51:33 vsnyder Exp $"
d1211 1
a1211 1
          & mi => a%col%vec%quantities(a%col%quant(i))%mask(:,a%row%inst(i))
d1663 3
@


2.53
log
@Add UseMask argument to NormalEquations
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.52 2001/09/25 17:49:24 livesey Exp $"
d1014 1
a1014 1
  subroutine MultiplyMatrixVector_1 ( A, V, Z, UPDATE )
d1017 3
d1023 2
a1024 1
    logical, optional, intent(in) :: UPDATE
d1030 2
d1039 2
d1049 3
d1057 1
a1057 1
          & z%quantities(k)%values(:,l), do_update )
d1163 2
a1164 2
  ! If UseMask is present and false, the column mask is not used to
  ! suppress columns of the normal equations.
d1200 1
a1200 1
    my_Mask = .true.
d1205 1
a1205 1
        mj => a%col%vec%quantities(a%col%quant(j))%mask(:,a%col%inst(j))
d1211 1
a1211 1
          mi => a%col%vec%quantities(a%col%quant(i))%mask(:,a%row%inst(i))
d1222 1
a1222 1
      & call multiply ( a, rhs_in, rhs_out, my_update )
d1663 3
@


2.52
log
@Added call to copyvector for row mask in clearrows_1
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.51 2001/09/20 23:03:01 vsnyder Exp $"
d1142 2
a1143 1
  subroutine NormalEquations ( A, Z, RHS_IN, RHS_OUT, UPDATE, ROW_BLOCK )
d1151 4
d1164 1
d1176 1
d1185 1
a1185 1
    call copyVector ( rhs_in, a%row%vec, noValues=.true.)
d1189 2
d1193 1
a1193 1
      if ( associated(a%col%vec%quantities(a%col%quant(j))%mask) ) &
d1199 1
a1199 1
        if ( associated(a%col%vec%quantities(a%col%quant(i))%mask) ) &
d1652 3
@


2.51
log
@Call ClearRows and ClearUnderMask from NormalEquations
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.50 2001/07/26 20:34:04 vsnyder Exp $"
d1178 1
d1643 3
@


2.50
log
@Eliminate the 'extra' field
@
text
@d25 1
a25 1
  use VectorsModule, only: CloneVector, CopyVector, Vector_T
d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.49 2001/07/19 17:50:42 vsnyder Exp $"
d435 1
a435 1
  subroutine ClearRows_1 ( X )
d437 4
a440 1
  ! has nonzero bits.
d442 3
d447 7
a453 1
    do i = 1, x%row%nb
d461 1
d1150 2
a1151 1
    type(Matrix_T), intent(in) :: A
d1153 2
a1154 1
    type(Vector_T), intent(in), optional :: RHS_IN
d1178 1
d1332 2
a1333 2
        if ( myLambda == 0.0_r8 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Updating with inverse of zero in UpdateDiagonal_1" )
d1642 3
@


2.49
log
@Add 'row_block' optional argument to RowScale and NormalEquations
@
text
@d35 1
a35 1
  public :: Dump_Struct, FillExtraCol, FillExtraRow, FindBlock, GetDiagonal
d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.48 2001/07/12 22:12:19 vsnyder Exp $"
d259 1
a259 3
    ! Check that the matrices are compatible.  We also need to check
    ! Nb, because the matrices may have been created with an extra
    ! row or column.
a261 1
      & .or. x%col%nb /= y%col%nb .or. x%row%nb /= y%row%nb &
d313 1
a313 3
    ! Check that the matrices are compatible.  We need to check
    ! Nb, because the matrices may have been created with an extra
    ! row or column.
a315 1
      & .or. x%col%nb /= y%col%nb .or. x%row%nb /= y%row%nb &
d342 1
a342 1
  subroutine CholeskyFactor_1 ( Z, X, NoExtra )
a344 1
  ! Don't factor the extra column if NoExtra is present and true.
a346 1
    logical, intent(in), optional :: NoExtra
a348 2
    logical :: MyNoExtra
    integer :: N                        ! Columns(blocks)
a350 3
    myNoExtra = .false.
    if ( present(noExtra) ) myNoExtra = noExtra

a384 2
    n = x%m%row%nb
    if ( myNoExtra .and. x%m%row%extra ) n = n - 1
d388 1
a388 1
    do j = 2, n
d393 1
a393 1
    do i = 2, n
d402 1
a402 1
      do j = i+1, n
d415 1
a415 1
      end do ! j = 1, n
a455 2
  !                                Any "extra" column is not scaled (but an
  !                                extra row is).
a460 1
    integer :: NC, NR    ! Number of columns and rows
a461 3
    nc = x%col%nb
    if ( x%col%extra ) nc = nc - 1
    nr = x%row%nb
d465 2
a466 2
      do j = 1, nc
        do i = 1, nr
d470 2
a471 2
        end do ! i = nr
      end do ! j = nc
d473 2
a474 2
      do j = 1, nc
        do i = 1, nr
d477 2
a478 2
        end do ! i = nr
      end do ! j = nc
d505 1
a505 3
  ! Z and X must have the same template, but it's OK if they don't both
  ! have row%extra or col%extra.  If Z has extra and X does not, Z's
  ! extra is deleted.
a519 10
    if ( z%col%nb > x%col%nb ) then
      do i = 1, z%row%nb
        call destroyBlock ( z%block(i, z%col%nb) )
      end do ! i
    end if
    if ( z%row%nb > x%row%nb ) then
      do j = 1, z%col%nb
        call destroyBlock ( z%block(z%row%nb, j) )
      end do ! j
    end if
d543 1
a543 2
    &,                           Row_Quan_First, Col_Quan_First &
    &,                           Extra_Row, Extra_Col )
a555 4
    logical, intent(in), optional :: Extra_Row         ! Allocate one extra
      ! row, beyond what's specified by Col, if Extra_Row is present and true.
    logical, intent(in), optional :: Extra_Col         ! Allocate one extra
      ! column, beyond what's specified by Row, if Extra_Col is present and true.
d561 2
a562 2
    call defineInfo ( z%row, row, row_Quan_First, extra_Row )
    call defineInfo ( z%col, col, col_Quan_First, extra_Col )
d573 1
a573 1
    subroutine DefineInfo ( RC, Vec, QuanFirst, extra )
a576 1
      logical, intent(in), optional :: Extra
a580 2
      rc%extra = .false.
      if ( present(extra) ) rc%extra = extra
a584 1
      if ( rc%extra ) rc%nb = rc%nb + 1
a620 5
      if ( rc%extra ) then
        rc%nelts(rc%nb) = 1
        rc%inst(rc%nb) = 0
        rc%quant(rc%nb) = 0
      end if
a719 64
  ! -----------------------------------------------  FillExtraCol  -----
  subroutine FillExtraCol ( A, X, ROW )
  ! Fill the "extra" column of A (see type RC_Info) from the vector X.
  ! Assume it is full -- i.e. don't bother to sparsify it.  If ROW is
  ! specified, it refers to a block-row, and only that row of the extra
  ! column is filled.
    type(Matrix_T), intent(inout) :: A
    type(Vector_T), intent(in) :: X
    integer, intent(in), optional :: ROW

    integer :: I

    ! Check compatibility of X with the row template for A
    if ( a%row%vec%template%id /= x%template%id ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Vector incompatible with matrix in FillExtraCol" )
    if ( .not. a%col%extra ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "No extra column to fill in FillExtraCol" )
    if ( present(row) ) then
      if ( row < 1 .or. row > a%row%nb ) call MLSMessage ( MLSMSG_Error, &
        & moduleName, "Row number out-of-range in FillExtraCol" )
      if ( a%block(row,a%col%nb)%kind /= m_full ) &
        & call destroyBlock ( a%block(row,a%col%nb) )
      if ( .not. associated(a%block(row,a%col%nb)%values) ) &
        & call createBlock ( a%block(row,a%col%nb), a%row%nelts(row), 1, m_full )
      a%block(row,a%col%nb)%values(:,1) = &
          & x%quantities(a%row%quant(row))%values(:,a%row%inst(row))
    else
      do i = 1, a%row%nb
        call destroyBlock ( a%block(i,a%col%nb) )
        call createBlock ( a%block(i,a%col%nb), a%row%nelts(i), 1, m_full )
        if ( a%row%quant(i) /= 0 ) &
          & a%block(i,a%col%nb)%values(:,1) = &
            & x%quantities(a%row%quant(i))%values(:,a%row%inst(i))
      end do ! i
    end if
  end subroutine FillExtraCol

  ! -----------------------------------------------  FillExtraRow  -----
  subroutine FillExtraRow ( A, X )
  ! Fill the "extra" row of A (see type RC_Info) from the vector X.
  ! The extra column in the extra row is not filled.
    type(Matrix_T), intent(inout) :: A
    type(Vector_T), intent(in) :: X

    integer :: J, NB

    ! Check compatibility of X with the column template for A
    if ( a%col%vec%template%id /= x%template%id ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Vector incompatible with matrix in FillExtraRow" )
    if ( .not. a%row%extra ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "No extra row to fill in FillExtraRow" )
    nb = a%col%nb
    if ( a%col%extra ) nb = nb - 1
    do j = 1, nb
      call destroyBlock ( a%block(a%row%nb,j) )
      call createBlock ( a%block(a%row%nb,j), 1, a%col%nelts(j), m_full )
      if ( a%col%quant(j) /= 0 ) &
        & a%block(a%row%nb,j)%values(1,:) = &
          & x%quantities(a%col%quant(j))%values(:,a%col%inst(j))
    end do ! i
  end subroutine FillExtraRow

d750 1
a750 1
  ! Get X from the diagonal of A.  Don't get the extra row or column.
d758 1
a758 1
    integer :: I, N
d761 1
a761 3
    n = max(a%row%nb,a%col%nb)
    if ( a%row%extra .or. a%col%extra ) n = n - 1
    do i = 1, n
d867 3
a869 5
          if ( row <= vector%template%totalinstances ) & ! Don't get the extra
            ! row if the vector doesn't have a place for it.
            & call getVectorFromColumn ( matrix%block(row,block), colInBlock, &
              & vector%quantities(matrix%row%quant(row))% &
              & values(:,matrix%row%inst(row)) )
a923 1
  ! Don't include the extra row or column.
d925 1
a925 1
    integer :: I, J, M, N
d927 2
a928 6
    m = a%row%nb
    if ( a%row%extra ) m = m - 1
    n = a%col%nb
    if ( a%col%extra ) n = n - 1
    do i = 1, m
      do j = 1, n
a937 1
  ! Don't include the extra row or column.
d939 1
a939 1
    integer :: I, J, K, M, N
d942 1
a942 5
    m = a%row%nb
    if ( a%row%extra ) m = m - 1
    n = a%col%nb
    if ( a%col%extra ) n = n - 1
    do j = 1, n
d945 1
a945 1
        do i = 1, m
d956 1
a956 1
  ! smallest magnitude.  If A has an extra column, ignore it.
d964 1
a964 1
  ! smallest magnitude.  If A has an extra column, ignore it.
d995 3
a997 3
        end do ! k = 2, x%nr
      end do ! i = 1, x%nc
    end do ! j = 1, y%nc
a1003 1
  ! The extra row and column are not multiplied, even if present.
a1012 1
    integer :: MB, NB         ! Loop limits
d1025 1
a1025 5
    mb = a%row%nb
    if ( a%row%extra ) mb = mb - 1
    nb = a%col%nb
    if ( a%col%extra ) nb = nb - 1
    do j = 1, nb
d1029 1
a1029 1
      do i = 1, mb
a1085 1
  ! The extra row and column are not multiplied, even if present.
a1092 1
    integer :: NB             ! Loop bound
d1095 1
a1095 3
    nb = a%m%col%nb
    if ( a%m%col%extra ) nb = nb - 1
    do j = 1, nb
d1104 1
a1104 1
      end do ! i = 1, a%m%row%nb
d1162 1
a1162 2
      & call createEmptyMatrix ( z%m, 0, a%col%vec, a%col%vec, &
        &  extra_Row = a%col%extra, extra_Col=a%col%extra )
d1167 2
a1168 4
      if ( .not. ( j == a%col%nb .and. a%col%extra ) ) then
        if ( associated(a%col%vec%quantities(a%col%quant(j))%mask) ) &
          mj => a%col%vec%quantities(a%col%quant(j))%mask(:,a%col%inst(j))
      end if
d1173 2
a1174 4
        if ( .not. ( i == a%col%nb .and. a%col%extra ) ) then
          if ( associated(a%col%vec%quantities(a%col%quant(i))%mask) ) &
            mi => a%col%vec%quantities(a%col%quant(i))%mask(:,a%row%inst(i))
        end if
d1180 2
a1181 2
        end do ! k = 2, a%row%nb
      end do ! i = 1, a%col%nb
d1191 1
a1191 2
  !   is X or NEWX. An "extra" row is not scaled (but an extra column
  !   is).
a1199 1
    integer :: NC, NR    ! Numbers of columns and rows.
a1201 3
    nc = x%col%nb
    nr = x%row%nb
    if ( x%row%extra ) nr = nr - 1
d1207 1
a1207 1
      r2 = nr
d1212 1
a1212 1
      do j = 1, nc
d1217 2
a1218 2
        end do ! i = nr
      end do ! j = nc
d1220 1
a1220 1
      do j = 1, nc
d1225 2
a1226 2
        end do ! i = nr
      end do ! j = nc
a1249 2
  ! If Z has an extra column, extract it into a vector bu using
  ! GetVectorFromColumn, and pass it in as X.
d1255 1
a1255 1
    integer :: I, J, N             ! Subscripts and loop inductors
a1265 2
    n = z%m%col%nb
    if ( z%m%col%extra ) n = n - 1
d1267 1
a1267 1
      do i = 1, n
d1279 1
a1279 1
      end do ! i = 1, n
d1281 1
a1281 1
      do i = n, 1, -1
d1284 1
a1284 1
        do j = i+1, n
d1291 1
a1291 1
        end do ! j = 1, i-1
d1294 1
a1294 1
      end do ! i = n, 1, -1
d1300 1
a1300 1
  ! Add LAMBDA to the diagonal of A.  Don't update the extra row or column.
d1307 1
a1307 1
    integer :: I, N
a1320 3

    n = max(a%m%row%nb,a%m%col%nb)
    if ( a%m%row%extra .or. a%m%col%extra ) n = n - 1
d1322 1
a1322 1
    do i = 1, n
d1330 1
a1330 1
  ! Add X to the diagonal of A.  Don't update the extra row or column.
d1339 1
a1339 1
    integer :: I, N
a1347 2
    n = max(a%m%row%nb,a%m%col%nb)
    if ( a%m%row%extra .or. a%m%col%extra ) n = n - 1
d1349 1
a1349 1
      do i = 1, n
d1355 1
a1355 1
      do i = 1, n
a1388 1
    a%extra = b%extra
d1486 2
a1487 6
        if ( matrix%row%extra .and. i == matrix%row%nb ) then
          call output ( '_extra_' )
        else
          call display_string ( &
            & matrix%row%vec%quantities(matrix%row%quant(i))%template%name )
        end if
d1491 2
a1492 6
        if ( matrix%col%extra .and. j == matrix%col%nb ) then
          call output ( '_extra_' )
        else
          call display_string ( &
            & matrix%col%vec%quantities(matrix%col%quant(j))%template%name )
        end if
a1558 1
      if ( rc%extra ) call output ( ' (including extra)' )
a1563 1
      if ( rc%extra ) call output ( ' (including extra)' )
a1568 1
      if ( rc%extra ) call output ( ' (including extra)' )
d1615 1
a1615 1
  ! smallest magnitude.  If A has an extra column, ignore it.
d1617 1
a1617 3
    integer :: I, N
    n = a%col%nb
    if ( a%col%extra ) n = n - 1
d1619 1
a1619 1
    do i = 2, n
d1626 3
@


2.48
log
@Forget to get CopyVector
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.47 2001/07/12 21:08:44 vsnyder Exp $"
d1264 1
a1264 1
  subroutine NormalEquations ( A, Z, RHS_IN, RHS_OUT, UPDATE )
d1268 3
a1270 2
  ! squares problem A X = RHS_IN. Z = Z + A^T A and RHS_OUT = RHS_OUT +
  ! A^T RHS_IN.
d1278 1
d1291 1
d1299 2
d1307 3
a1309 1
      do i = 1, j
d1329 6
a1334 5
  subroutine RowScale_1 ( V, X, NEWX ) ! Z = V X where V is a diagonal
  !                                matrix represented by a vector and Z is X
  !                                or NEWX.
  !                                An "extra" row is not scaled (but an extra
  !                                column is).
d1338 1
d1342 1
d1347 7
d1358 1
a1358 1
        do i = 1, nr
d1366 1
a1366 1
        do i = 1, nr
d1408 1
a1408 1
    if ( present(rhs) ) call copyVector ( x, rhs )
d1422 1
a1422 1
          ! rhs := rhs - block^T * x
d1436 1
a1436 1
          ! rhs := rhs - block * x
d1794 3
@


2.47
log
@Repair bug in SolveCholesky in the case that RHS is present
@
text
@d25 1
a25 1
  use VectorsModule, only: CloneVector, Vector_T
d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.46 2001/07/11 22:07:57 vsnyder Exp $"
d1777 3
@


2.46
log
@Interim commit -- may still be broken
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.45 2001/06/28 01:06:42 vsnyder Exp $"
a1386 1
    type(Vector_T), pointer :: MY_RHS   ! RHS if present, else X
d1391 2
a1392 8
    my_rhs => x
    if ( present(rhs) ) then
      if ( x%template%id /= rhs%template%id ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "X and RHS not compatible in SolveCholesky_1" )
      my_rhs => rhs
    end if
    if ( z%m%col%vec%template%id /= my_rhs%template%id ) &
d1407 1
a1407 1
            & my_rhs%quantities(qc)%values(:,ic), update=.true., subtract=.true. )
d1410 1
a1410 1
          & my_rhs%quantities(qc)%values(:,ic), transpose=.true. )
d1421 1
a1421 1
            & x%quantities(qr)%values(:,ir), my_rhs%quantities(qc)%values(:,ic), &
d1425 1
a1425 1
          & my_rhs%quantities(qc)%values(:,ic), transpose=.false. )
d1777 3
@


2.45
log
@Use generic 'multiply' more ubiquitously
@
text
@d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.44 2001/06/01 01:04:00 vsnyder Exp $"
d1416 1
a1416 1
        call solveCholesky ( z%m%block(i,i), &
d1431 1
a1431 1
        call solveCholesky ( z%m%block(i,i), &
d1784 3
@


2.44
log
@Add 'sqrt' option to 'GetDiagonal_0'; add 'Multiply' generic
@
text
@d16 2
a17 2
    & M_Banded, M_Full, MatrixElement_T, MaxAbsVal, MinDiag, &
    & MultiplyMatrixBlocks, MultiplyMatrixVector, MultiplyMatrixVectorNoT, &
d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.43 2001/05/30 20:18:01 vsnyder Exp $"
d412 1
a412 1
        call multiplyMatrixBlocks ( z%m%block(k,i), z%m%block(k,i), s, &
d423 1
a423 1
            call multiplyMatrixBlocks ( z%m%block(k,i), z%m%block(k,j), s, &
d1019 1
a1019 1
          call multiplyMatrixBlocks ( b%block(i,k), u%m%block(j,i), &
d1116 1
a1116 1
        call multiplyMatrixBlocks ( x%block(1,i), y%block(1,j), z%block(i,j) )
d1118 2
a1119 2
          call multiplyMatrixBlocks ( &
            & x%block(k,i), y%block(k,j), z%block(i,j), update=.true. )
d1163 2
a1164 3
        call multiplyMatrixVector ( a%block(i,j), &
          & v%quantities(m)%values(:,n), z%quantities(k)%values(:,l), &
          & do_update )
d1227 1
a1227 1
    call MultiplyMatrixVector ( a%m, v, z, update ) ! A^T V
d1260 1
a1260 1
    call multiplyMatrixVector ( a, v, z, .false. )
d1310 2
a1311 3
          call multiplyMatrixBlocks ( &
            & a%block(k,i), a%block(k,j), z%m%block(i,j), update=do_update, &
            & xmask=mi, ymask=mj, upper = i == j )
d1318 1
a1318 1
      & call multiplyMatrixVector ( a, rhs_in, rhs_out, my_update )
d1413 2
a1414 3
          call multiplyMatrixVector ( z%m%block(j,i), &
            & x%quantities(qr)%values(:,ir), my_rhs%quantities(qc)%values(:,ic), &
            & update=.true., subtract=.true. )
d1784 3
@


2.43
log
@Add 'invert' argument to 'UpdateDiagonal'
@
text
@d43 1
a43 1
  public :: MinDiag, MinDiag_Cholesky, MinDiag_SPD, MultiplyMatrices
d118 4
d206 1
a206 1
       "$Id: MatrixModule_1.f90,v 2.42 2001/05/22 19:09:33 vsnyder Exp $"
d348 1
a348 1
  subroutine CholeskyFactor_1 ( Z, X )
d351 1
d354 1
d357 1
d361 3
d399 1
d860 1
a860 1
  subroutine GetDiagonal_1 ( A, X )
d863 3
a865 1
    type(Matrix_SPD_T), intent(in) :: A
d867 1
d871 3
a873 3
    call cloneVector ( x, a%m%row%vec, vectorNameText='_x' )
    n = max(a%m%row%nb,a%m%col%nb)
    if ( a%m%row%extra .or. a%m%col%extra ) n = n - 1
d875 2
a876 2
      call getDiagonal ( a%m%block(i,i), &
        & x%quantities(a%m%row%quant(i))%values(:,a%m%row%inst(i)) )
d1787 3
@


2.42
log
@Implement MaxL1
@
text
@d202 1
a202 1
       "$Id: MatrixModule_1.f90,v 2.41 2001/05/19 00:20:05 livesey Exp $"
a1406 2
        call solveCholesky ( z%m%block(i,i), &
          & my_rhs%quantities(qc)%values(:,ic), transpose=.false. )
a1421 2
        call solveCholesky ( z%m%block(i,i), &
          & my_rhs%quantities(qc)%values(:,ic), transpose=.true. )
d1427 1
a1427 1
  subroutine UpdateDiagonal_1 ( A, LAMBDA, SQUARE )
d1431 3
a1433 1
    logical, intent(in), optional :: SQUARE ! Update with square of value
d1441 8
a1448 1
    endif
d1460 1
a1460 1
  subroutine UpdateDiagonalVec_1 ( A, X, SUBTRACT, SQUARE )
d1466 3
a1468 1
    logical, intent(in), optional :: SQUARE
d1484 2
a1485 1
          & (x%quantities(a%m%row%quant(i))%values(:,a%m%row%inst(i)))**2, subtract )
d1490 2
a1491 1
          & x%quantities(a%m%row%quant(i))%values(:,a%m%row%inst(i)), subtract )
d1773 3
@


2.41
log
@Cosmetic changes from Van.
@
text
@d14 6
a19 5
    & ColumnScale, CopyBlock, CreateBlock, DestroyBlock, Dump, GetDiagonal, &
    & GetMatrixElement, GetVectorFromColumn, M_Absent, M_Banded, M_Full, &
    & MatrixElement_T, MaxAbsVal, MinDiag, MultiplyMatrixBlocks, &
    & MultiplyMatrixVector, MultiplyMatrixVectorNoT, operator(+), &
    & operator(.TX.), RowScale, ScaleBlock, SolveCholesky, UpdateDiagonal
d42 3
a44 3
  public :: Matrix_SPD_T, MaxAbsVal, MaxAbsVal_1, MinDiag, MinDiag_Cholesky
  public :: MinDiag_SPD, MultiplyMatrices, MultiplyMatrixVector
  public :: MultiplyMatrixVector_1
d202 1
a202 1
       "$Id: MatrixModule_1.f90,v 2.40 2001/05/19 00:14:57 livesey Exp $"
d1041 23
d1764 3
@


2.40
log
@OK that should have been square (idiot!)
@
text
@d201 1
a201 1
       "$Id: MatrixModule_1.f90,v 2.39 2001/05/19 00:13:23 livesey Exp $"
d1414 1
a1414 1
    logical :: MYSQUARE
d1416 4
a1419 2
    mySquare = .false.
    if ( present(square) ) mySquare = square
d1424 4
a1427 9
    if ( mySquare ) then
      do i = 1, n
        call updateDiagonal ( a%m%block(i,i), lambda**2 )
      end do
    else
      do i = 1, n
        call updateDiagonal ( a%m%block(i,i), lambda )
      end do
    endif
d1740 3
@


2.39
log
@Added squareRoot option to update diagonal
@
text
@d201 1
a201 1
       "$Id: MatrixModule_1.f90,v 2.38 2001/05/18 23:48:34 vsnyder Exp $"
d1407 1
a1407 1
  subroutine UpdateDiagonal_1 ( A, LAMBDA, SQUAREROOT )
d1411 1
a1411 1
    logical, intent(in), optional :: SQUAREROOT ! Update with square root of value
d1414 1
a1414 1
    logical :: MYSQUAREROOT
d1416 2
a1417 2
    mySquareRoot = .false.
    if ( present(squareRoot) ) mySquareRoot = squareRoot
d1422 1
a1422 1
    if ( mySquareRoot ) then
d1424 1
a1424 1
        call updateDiagonal ( a%m%block(i,i), sqrt(lambda) )
d1434 1
a1434 1
  subroutine UpdateDiagonalVec_1 ( A, X, SUBTRACT, SQUAREROOT )
d1440 1
a1440 1
    logical, intent(in), optional :: SQUAREROOT
d1443 1
a1443 1
    logical :: MYSQUAREROOT
d1445 2
a1446 2
    mySquareRoot = .false.
    if ( present(squareRoot) ) mySquareRoot = squareRoot
d1453 1
a1453 1
    if ( mySquareRoot ) then
d1456 1
a1456 1
          & sqrt(x%quantities(a%m%row%quant(i))%values(:,a%m%row%inst(i))), subtract )
d1743 3
@


2.38
log
@Correct Dump_L1 -> Dump_Linf
@
text
@d201 1
a201 1
       "$Id: MatrixModule_1.f90,v 2.37 2001/05/18 22:28:11 vsnyder Exp $"
d1407 1
a1407 1
  subroutine UpdateDiagonal_1 ( A, LAMBDA )
d1411 1
d1414 4
d1421 10
a1430 3
    do i = 1, n
      call updateDiagonal ( a%m%block(i,i), lambda )
    end do
d1434 1
a1434 1
  subroutine UpdateDiagonalVec_1 ( A, X, SUBTRACT )
d1440 1
d1443 4
d1453 11
a1463 4
    do i = 1, n
      call updateDiagonal ( a%m%block(i,i), &
        & x%quantities(a%m%row%quant(i))%values(:,a%m%row%inst(i)), subtract )
    end do
d1743 3
@


2.37
log
@Don't look for a mask in the extra column during NormalEquations
@
text
@d33 1
a33 1
  public :: DestroyMatrixInDatabase, DestroyMatrixDatabase, Dump, Dump_L1
d201 1
a201 1
       "$Id: MatrixModule_1.f90,v 2.36 2001/05/17 20:19:20 vsnyder Exp $"
d1489 2
a1490 2
  ! ---------------------------------------------------  Dump_L1  -----
  subroutine Dump_L1 ( Matrix, Name, Upper )
d1494 2
a1495 2
    ! Dump the L1 norms of the matrix blocks.  Only dump the upper triangle
    ! if Upper is present and true.
d1533 1
a1533 1
  end subroutine Dump_L1
d1719 3
@


2.36
log
@Implement GetMatrixElement.  Change handling of mask in NormalEquations.
Don't scale the extra column/row if column/row scaling, but do scale
the extra row/column.
@
text
@d201 1
a201 1
       "$Id: MatrixModule_1.f90,v 2.35 2001/05/12 18:58:47 livesey Exp $"
d1261 4
a1264 2
      if ( associated(a%col%vec%quantities(a%col%quant(j))%mask) ) &
        mj => a%col%vec%quantities(a%col%quant(j))%mask(:,a%col%inst(j))
d1267 4
a1270 2
        if ( associated(a%col%vec%quantities(a%col%quant(i))%mask) ) &
          mi => a%col%vec%quantities(a%row%quant(i))%mask(:,a%row%inst(i))
d1719 5
@


2.35
log
@Fixed a bug, not sure it's what Van intended but it should compile
@
text
@d15 4
a18 4
    & GetVectorFromColumn, M_Absent, M_Banded, M_Full, MatrixElement_T, &
    & MaxAbsVal, MinDiag, MultiplyMatrixBlocks, MultiplyMatrixVector, &
    & MultiplyMatrixVectorNoT, operator(+), operator(.TX.), RowScale, &
    & ScaleBlock, SolveCholesky, UpdateDiagonal
d36 2
a37 1
  public :: GetVectorFromColumn, GetVectorFromColumn_1, InvertCholesky
d113 4
d201 1
a201 1
       "$Id: MatrixModule_1.f90,v 2.34 2001/05/12 01:07:19 vsnyder Exp $"
a430 1
          ! if ( associated(x%block(i,j)) )
d459 2
a460 1
  !                                Any "extra" row or column is not scaled.
a470 1
    if ( x%row%extra ) nr = nr - 1
d477 1
a477 1
            & v%quantities(x%row%quant(i))%values(:,x%row%inst(i)), &
d485 1
a485 1
            & v%quantities(x%row%quant(i))%values(:,x%row%inst(i)) )
d887 40
d1024 1
d1026 1
a1026 1
    integer :: I, J
d1028 6
a1033 2
    do i = 1, a%row%nb
      do j = 1, a%col%nb
d1269 3
a1271 20
          if ( associated(mi) ) then
            if ( associated(mj) ) then
              call multiplyMatrixBlocks ( &
                & a%block(k,i), a%block(k,j), z%m%block(i,j), update=do_update, &
                & xmask=mi, ymask=mj )
            else
              call multiplyMatrixBlocks ( &
                & a%block(k,i), a%block(k,j), z%m%block(i,j), update=do_update, &
                & xmask=mi )
            end if
          else
            if ( associated(mj) ) then
              call multiplyMatrixBlocks ( &
                & a%block(k,i), a%block(k,j), z%m%block(i,j), update=do_update, &
                & ymask=mj )
            else
              call multiplyMatrixBlocks ( &
                & a%block(k,i), a%block(k,j), z%m%block(i,j), update=do_update )
            end if
          end if
d1285 2
a1286 1
  !                                An "extra" row or column is not scaled.
a1294 1
    if ( x%col%extra ) nc = nc - 1
d1715 3
@


2.34
log
@Some repairs in RowScale and ColumnScale
@
text
@d196 1
a196 1
       "$Id: MatrixModule_1.f90,v 2.33 2001/05/10 22:54:34 vsnyder Exp $"
d423 8
a430 5
    do i = 1, x%row%nb
      do j = 1, x%col%nb
        if ( associated(x%block(i,j)) ) call destroyBlock ( x%block(i,j) )
      end do ! j
    end do ! i
d1683 3
@


2.33
log
@Get CholeskyFactor_1 to work.  Add Dump_L1 and Dump_Struct.
@
text
@d196 1
a196 1
       "$Id: MatrixModule_1.f90,v 2.32 2001/05/10 02:14:58 vsnyder Exp $"
d425 1
a425 1
        call destroyBlock ( x%block(i,j) )
d452 1
d458 1
d460 4
d467 2
a468 3
      do j = 1, x%col%nb
        do i = 1, x%row%nb
        end do ! i = x%row%nb
d472 2
a473 1
      end do ! j = x%col%nb
d475 2
a476 3
      do j = 1, x%col%nb
        do i = 1, x%row%nb
        end do ! i = x%row%nb
d479 2
a480 1
      end do ! j = x%col%nb
d1250 1
d1256 1
d1258 4
d1265 2
a1266 3
      do j = 1, x%col%nb
        do i = 1, x%row%nb
        end do ! i = x%row%nb
d1270 2
a1271 1
      end do ! j = x%col%nb
d1273 2
a1274 3
      do j = 1, x%col%nb
        do i = 1, x%row%nb
        end do ! i = x%row%nb
d1278 2
a1279 1
      end do ! j = x%col%nb
d1549 1
a1549 1
          call dump ( matrix%block(i,j), details=my_details>1 )
d1680 3
@


2.32
log
@Repair CholeskyFactor, MaxAbsVal; add Dump_Struct
@
text
@d22 1
a22 1
  use OUTPUT_M, only: OUTPUT
d33 3
a35 3
  public :: DestroyMatrixInDatabase, DestroyMatrixDatabase, Dump, Dump_Struct
  public :: FillExtraCol, FillExtraRow, FindBlock, GetDiagonal, GetDiagonal_1
  public :: GetFromMatrixDatabase, GetKindFromMatrixDatabase
d196 1
a196 1
       "$Id: MatrixModule_1.f90,v 2.31 2001/05/09 19:46:06 vsnyder Exp $"
d483 2
a484 1
    integer :: I, J ! Subscripts and loop inductors
d488 3
d493 2
a494 1
        z%block(i,j) = x%block(i,j) ! Defined assignment, from MatrixModule_0
d1325 4
a1328 3
          my_rhs%quantities(qc)%values(:,ic) = &
            & my_rhs%quantities(qc)%values(:,ic) - &
            & ( z%m%block(j,i) .tx. x%quantities(qr)%values(:,ir) )
d1342 4
a1345 3
          my_rhs%quantities(qc)%values(:,ic) = &
            & my_rhs%quantities(qc)%values(:,ic) - &
            & ( z%m%block(i,j) .tx. x%quantities(qr)%values(:,ir) )
d1348 2
a1350 2
        call solveCholesky ( z%m%block(i,i), &
          & my_rhs%quantities(qc)%values(:,ic), transpose=.false. )
d1411 1
a1411 1
  subroutine CopyRCInfo ( A, B )
d1417 2
d1438 46
d1623 1
a1623 1
    character :: CHARS(0:3) = (/ 'A',   'B',   'S',   'F' /)
d1668 3
@


2.31
log
@Add BandHeight argument to CreateBlock_1
@
text
@d33 2
a34 2
  public :: DestroyMatrixInDatabase, DestroyMatrixDatabase, Dump, FillExtraCol
  public :: FillExtraRow, FindBlock, GetDiagonal, GetDiagonal_1
d196 1
a196 1
       "$Id: MatrixModule_1.f90,v 2.30 2001/05/09 01:56:15 vsnyder Exp $"
d338 1
a338 1
  subroutine CholeskyFactor_1 ( X, Z )
d341 1
a342 1
    type(Matrix_Cholesky_T), intent(inout) :: Z   ! Factored matrix.
d356 26
d384 2
a385 1
    call choleskyFactor ( z%m%block(1,1), x%m%block(1,1) )! Factor block on diagonal
d387 3
a389 1
      call solveCholesky ( z%m%block(1,1), z%m%block(1,j), transpose=.true. )
d394 1
d398 2
a399 1
      call choleskyFactor ( z%m%block(i,i), s )   ! Factor block on diagonal
d403 1
a403 1
          call copyBlock ( s, z%m%block(i,j) )    ! Destroy s, then s := z...
d405 1
d409 1
d971 2
a972 1
        maxAbsVal_1 = max(maxAbsVal_1,maxAbsVal(a%block(i,j)))
d1149 2
a1150 1
        a%block(i,j)%values = -a%block(i,j)%values
d1559 38
d1613 3
@


2.30
log
@periodic commit -- Work on block Cholesky
@
text
@d196 1
a196 1
       "$Id: MatrixModule_1.f90,v 2.29 2001/05/08 20:29:40 vsnyder Exp $"
d493 1
a493 1
  subroutine CreateBlock_1 ( Z, RowNum, ColNum, Kind, NumNonzeros )
d498 4
d507 2
a508 1
      & z%row%nelts(rowNum), z%col%nelts(colNum), kind, numNonzeros )
d1540 3
@


2.29
log
@Periodic commit -- workong on sparse matrix blunders
@
text
@d196 1
a196 1
       "$Id: MatrixModule_1.f90,v 2.28 2001/05/03 02:11:23 vsnyder Exp $"
d345 1
a345 1
    integer :: N, N0                    ! Columns(blocks), Columns(0-level)
d357 12
a368 12
    do i = 1, n
      if ( i > 1 ) then
        n0 = x%m%col%nelts(i)
        call createBlock ( s, n0, n0, M_Absent )
        do k = 1, i-1
          call multiplyMatrixBlocks ( z%m%block(k,i), z%m%block(k,i), s, &
            & update=.true. )
        end do ! k = 1, i-1
        call choleskyFactor ( z%m%block(i,i), s ) ! Factor block on diagonal
      else
        call choleskyFactor ( z%m%block(i,i) )
      end if
d370 10
a379 6
        call destroyBlock ( s )    ! Avoid a memory leak
        do k = 1, i-1
          call multiplyMatrixBlocks ( z%m%block(k,i), z%m%block(k,j), s, &
            & update=.true. )
        end do ! k = 1, i-1
        call solveCholesky ( z%m%block(i,i), z%m%block(i,j), s, transpose=.true. )
d381 1
a381 1
      call destroyBlock( s )       ! Avoid a memory leak
d1163 1
a1163 1
          mi => a%col%vec%quantities(a%col%quant(i))%mask(:,a%col%inst(i))
d1535 3
@


2.28
log
@Spiffify dump, add names to cloned vectors
@
text
@d196 1
a196 1
       "$Id: MatrixModule_1.f90,v 2.27 2001/05/01 23:54:13 vsnyder Exp $"
d358 11
a368 7
      n0 = x%m%col%nelts(i)
      call createBlock ( s, n0, n0, M_Absent )
      do k = 1, i-1
        call multiplyMatrixBlocks ( z%m%block(k,i), z%m%block(k,i), s, &
          & update=.true. )
      end do ! k = 1, i-1
      call choleskyFactor ( z%m%block(i,i), s ) ! Factor block on diagonal
d523 1
d532 5
d736 1
d740 1
a740 1
    integer :: J
d747 4
a750 2
      & "No extra column to fill in FillExtraRow" )
    do j = 1, a%row%nb
d754 1
a754 1
        & a%block(a%row%nb,j)%values(:,1) = &
d865 4
a868 2
          call getVectorFromColumn ( matrix%block(row,block), colInBlock, &
            & vector%quantities(matrix%row%quant(row))% &
d873 1
a873 3
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'In "GetVectorFromColumn", "Column" is greater than number&
        & of columns in "Matrix"')
d875 3
d880 1
d985 1
d995 1
d1001 3
a1003 1
    if ( a%col%vec%template%id /= z%template%id ) &
a1005 2
    my_update = .false.
    if ( present(update) ) my_update = update
d1007 6
a1012 2
    if ( .not. update ) call cloneVector ( z, v, vectorNameText='_z' ) 
    do j = 1, a%col%nb
d1016 1
a1016 1
      do i = 1, a%row%nb
d1074 1
d1082 1
d1085 3
a1087 1
    do j = 1, a%m%col%nb
d1150 2
a1151 1
      & call createEmptyMatrix ( z%m, 0, a%col%vec, a%col%vec )
d1323 1
a1323 1
    type(Matrix_SPD_T), intent(inout) :: A
d1329 3
d1410 1
d1433 7
a1439 2
        call output ( ' )', advance='yes' )
        call dump ( matrix%block(i,j), details=my_details>1 )
d1531 3
@


2.27
log
@Create a block for the extra column
@
text
@a0 1

d196 1
a196 1
       "$Id: MatrixModule_1.f90,v 2.26 2001/05/01 06:56:32 livesey Exp $"
d783 1
a783 1
    call cloneVector ( x, a%m%row%vec )
d988 1
a988 1
    if ( .not. update ) call cloneVector ( z, v ) 
d1029 1
a1029 1
    if ( .not. my_update ) call cloneVector ( z, a%row%vec )
d1384 6
a1389 2
        call display_string ( &
          & matrix%row%vec%quantities(matrix%row%quant(i))%template%name )
d1393 6
a1398 2
        call display_string ( &
          & matrix%col%vec%quantities(matrix%col%quant(j))%template%name )
d1459 3
a1461 1
      call output ( 's in each block: ', advance='yes' )
d1465 3
a1467 1
      call output ( 's:', advance='yes' )
d1471 3
a1473 1
      call output ( 's:', advance='yes' )
d1494 3
@


2.26
log
@Bug fix, was using optional argument, not local copy/default.
@
text
@d197 1
a197 1
       "$Id: MatrixModule_1.f90,v 2.25 2001/04/30 23:44:25 vsnyder Exp $"
d707 4
d1481 3
@


2.25
log
@Correct/remove some incorrect size tests in MultiplyMatrixVectorNoT
@
text
@d197 1
a197 1
       "$Id: MatrixModule_1.f90,v 2.24 2001/04/28 07:03:59 livesey Exp $"
d1026 1
a1026 1
    if ( .not. update ) call cloneVector ( z, a%row%vec )
d1477 3
@


2.24
log
@Removed print statement
@
text
@d197 1
a197 1
       "$Id: MatrixModule_1.f90,v 2.23 2001/04/28 04:42:29 livesey Exp $"
d963 1
a963 1
  ! Z = A^T V if UPDATE is absent or false.
d984 5
a988 4
!???? Why is this here! call cloneVector ( z, v ) ! Copy characteristics, allocate values
    do i = 1, a%col%nb
      k = a%col%quant(i)
      l = a%col%inst(i)
d990 3
a992 3
      do j = 1, a%row%nb
        m = a%row%quant(j)
        n = a%row%inst(j)
d1003 2
a1004 1
  ! Z = A V if UPDATE is absent or false.
d1025 2
a1026 1
!??? Why is this here! call cloneVector ( z, v ) ! Copy characteristics, allocate values
d1477 3
@


2.23
log
@Removing some of the unnecessary(?) assertions of square matrices in
multiplyMatrixVector and its relatives.  Also sorted out some of the
conditions, and loops for the multiplyMatrixVectorNoT case.
@
text
@d197 1
a197 1
       "$Id: MatrixModule_1.f90,v 2.22 2001/04/28 01:28:36 livesey Exp $"
a1030 1
        print*,j,k,l,shape(z%quantities(m)%values(:,n))
d1474 5
@


2.22
log
@Change in rcInfo_T, vec is now a copy of the parent vector, not a pointer.
@
text
@d197 1
a197 1
       "$Id: MatrixModule_1.f90,v 2.21 2001/04/27 22:51:52 livesey Exp $"
d979 3
d984 4
a987 4
    call cloneVector ( z, v ) ! Copy characteristics, allocate values
    do j = 1, a%col%nb
      k = a%col%quant(j)
      l = a%col%inst(j)
d989 3
a991 3
      do i = 1, a%row%nb
        m = a%row%quant(i)
        n = a%row%inst(i)
d1018 3
d1023 1
a1023 1
    call cloneVector ( z, v ) ! Copy characteristics, allocate values
d1031 1
d1033 1
a1033 1
          & v%quantities(m)%values(:,n), z%quantities(k)%values(:,l), &
d1475 3
@


2.21
log
@Some changes/improvements to dump
@
text
@d153 1
a153 1
    type(Vector_T), pointer :: Vec => NULL() ! Vector used to define the row
d197 1
a197 1
       "$Id: MatrixModule_1.f90,v 2.20 2001/04/26 23:56:02 livesey Exp $"
d351 2
a352 2
    if ( .not. associated(x%m%col%vec%template,z%m%col%vec%template) &
      & .or. .not. associated(x%m%row%vec%template,z%m%row%vec%template) &
d505 1
a505 1
    type(Vector_T), target :: Row       ! Vector used to define the row
d507 1
a507 1
    type(Vector_T), target :: Col       ! Vector used to define the column
d532 1
a532 1
      type(Vector_T), target :: Vec ! intent(in)
d541 1
a541 1
      rc%vec => vec
d945 1
a945 1
    if ( .not. associated(x%row%vec%template,y%row%vec%template) .or. &
d976 1
a976 1
    if ( .not. associated(a%row%vec%template, v%template) ) &
d1012 1
a1012 1
    if ( .not. associated(a%col%vec%template, v%template) ) &
d1218 1
a1218 1
      if ( .not. associated( x%template, rhs%template ) ) &
d1223 1
a1223 1
    if ( .not. associated( z%m%col%vec%template, my_rhs%template ) ) &
d1321 1
a1321 1
    a%vec => b%vec
d1468 3
@


2.20
log
@Fix to test for MatrixVectorMultiplyNoT
@
text
@d197 1
a197 1
       "$Id: MatrixModule_1.f90,v 2.19 2001/04/25 01:12:39 vsnyder Exp $"
d1421 1
a1421 1
    call output ( 'Vector that defines ' )
d1430 1
a1430 1
    call output ( 'Order of blocks is ' )
d1441 1
a1441 1
      call output ( 'Instance indices for blocks in the' )
d1445 1
a1445 1
      call output ( 'Quantity indices for blocks in the' )
d1468 3
@


2.19
log
@Improve some comments
@
text
@d1 1
d197 1
a197 1
       "$Id: $"
d200 1
a200 1
       "$RCSfile: $"
d1012 1
a1012 1
    if ( .not. associated(a%row%vec%template, v%template) ) &
d1468 3
@


2.18
log
@Provide MultiplyMatrixNoT
@
text
@d194 7
a200 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=256), private :: Id = &
    & "$Id: MatrixModule_1.f90,v 2.17 2001/04/24 22:35:56 vsnyder Exp $"
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: MatrixModule_1.f90,v $"
  !---------------------------------------------------------------------------
d318 1
a318 1
        x%block(i,j) = x%block(i,j) + y%block(i,j)
d448 1
a448 1
        z%block(i,j) = x%block(i,j)
d454 1
a454 1
  subroutine CopyMatrixValue ( Z, X )   ! Copy the elements of X to Z
d1467 3
@


2.17
log
@Maybe this time elements of matrixDatabase are destroyed coimpletely
@
text
@d42 3
a44 1
  public :: MultiplyMatrixVector_1, MultiplyMatrixVectorSPD_1
d116 4
d196 1
a196 1
    & "$Id: MatrixModule_1.f90,v 2.16 2001/04/21 02:11:02 vsnyder Exp $"
d995 36
d1466 3
@


2.16
log
@Fix a memory leak
@
text
@d190 1
a190 1
    & "$Id: MatrixModule_1.f90,v 2.15 2001/04/20 02:56:18 livesey Exp $"
d649 16
a664 4
      if ( associated(d(i)%matrix) ) call destroyMatrix ( d(i)%matrix )
      if ( associated(d(i)%cholesky) ) call destroyMatrix ( d(i)%cholesky%m )
      if ( associated(d(i)%kronecker) ) call destroyMatrix ( d(i)%kronecker%m )
      if ( associated(d(i)%spd) ) call destroyMatrix ( d(i)%spd%m )
d669 7
d1424 3
@


2.15
log
@Added createblock_1 as public and overloaded.  Also made dump more informative
@
text
@d21 1
a21 1
    & MLSMSG_DeAllocate, MLSMSG_Error
d190 1
a190 1
    & "$Id: MatrixModule_1.f90,v 2.14 2001/04/11 00:40:25 vsnyder Exp $"
d594 1
a594 1
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d615 1
d619 3
d624 3
d629 3
d634 3
d655 1
a655 1
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1405 3
@


2.14
log
@Remove some inadventently-left-in debugging print
@
text
@d31 1
a31 1
  public :: CopyMatrix, CopyMatrixValue, CreateEmptyMatrix
d72 4
d190 1
a190 1
    & "$Id: MatrixModule_1.f90,v 2.13 2001/04/11 00:03:42 vsnyder Exp $"
d1294 12
a1305 1
        call output ( j, advance='yes' )
d1392 3
@


2.13
log
@Repair matrix creation, improve 'dump'
@
text
@d186 1
a186 1
    & "$Id: MatrixModule_1.f90,v 2.12 2001/04/10 00:19:11 vsnyder Exp $"
a510 2
print *, 'Row%template%totalinstances =', row%template%totalinstances
print *, 'Col%template%totalinstances =', col%template%totalinstances
a512 1
print *, 'Size(z%block) =', z%row%nb,z%col%nb
d1377 3
@


2.12
log
@Add GetKindFromMatrixDatabase and necessary parameters
@
text
@d82 1
a82 1
    module procedure Dump_Matrix
d142 4
a145 4
    type(Vector_T), pointer :: Vec ! Vector used to define the row or column
      ! space of the matrix, if any.
    integer :: NB                  ! Number of blocks of rows or columns
    logical :: Extra               ! There is an extra row or column that is
d186 1
a186 1
    & "$Id: MatrixModule_1.f90,v 2.11 2001/04/09 23:56:17 vsnyder Exp $"
d511 2
d515 1
d535 1
a535 1
      rc%nb = row%template%totalInstances
d591 5
a595 3
    deallocate ( a%block, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "A%Block in DestroyMatrix" )
d1265 1
a1265 1
  ! -------------------------------------------------  DumpMatrix  -----
d1278 8
a1285 1
    if ( present(name) ) call output ( name, advance='yes' )
d1299 26
d1380 3
@


2.11
log
@Change some pointer arguments to targets
@
text
@d35 3
a37 2
  public :: GetFromMatrixDatabase, GetVectorFromColumn, GetVectorFromColumn_1
  public :: InvertCholesky
d134 5
a138 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=256), private :: Id = &
    & "$Id: MatrixModule_1.f90,v 2.10 2001/04/09 23:32:19 vsnyder Exp $"
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: MatrixModule_1.f90,v $"
  !---------------------------------------------------------------------------
d184 7
d743 14
d1342 3
@


2.10
log
@Correct typo
@
text
@d28 1
a28 1
  public :: AddMatrices, AddMatrixToDatabase, AddToMatrix
d135 1
a135 1
    & "$Id: MatrixModule_1.f90,v 2.9 2001/02/22 02:09:36 vsnyder Exp $"
d486 1
a486 1
    type(Vector_T), pointer :: Row      ! Vector used to define the row
d488 1
a488 1
    type(Vector_T), pointer :: Col      ! Vector used to define the column
d513 1
a513 1
      type(Vector_T), pointer :: Vec ! intent(in)
d1321 3
@


2.9
log
@OOPS -- Forgot to make InvertCholesky public
@
text
@d28 1
a28 1
  public :: AddMatrices, AddToMatrixDatabase, AddToMatrix
d135 1
a135 1
    & "$Id: MatrixModule_1.f90,v 2.8 2001/02/22 01:55:06 vsnyder Exp $"
d1321 3
@


2.8
log
@Add code to invert a Cholesky factor
@
text
@d36 1
d135 1
a135 1
    & "$Id: MatrixModule_1.f90,v 2.7 2001/01/26 19:00:02 vsnyder Exp $"
d1321 3
@


2.7
log
@Periodic commit
@
text
@d15 2
a16 2
    & GetVectorFromColumn, M_Absent, M_Full, MatrixElement_T, MaxAbsVal, &
    & MinDiag, MultiplyMatrixBlocks, MultiplyMatrixVector, &
d39 7
a45 6
  public :: MinDiag_SPD
  public :: MultiplyMatrices, MultiplyMatrixVector, MultiplyMatrixVector_1
  public :: MultiplyMatrixVectorSPD_1, NewMultiplyMatrixVector, NormalEquations
  public :: operator(.TX.), operator(+), RC_Info, RowScale, RowScale_1
  public :: ScaleMatrix, SolveCholesky, SolveCholesky_1
  public :: UpdateDiagonal, UpdateDiagonal_1
d79 2
a80 2
  interface DUMP
    module procedure DUMP_MATRIX
d108 4
d129 1
a129 1
    module procedure UpdateDiagonal_1
d134 1
a134 1
    & "$Id: MatrixModule_1.f90,v 2.6 2001/01/19 23:53:26 vsnyder Exp $"
d793 31
d957 11
d1175 18
d1320 3
@


2.6
log
@Add FillExtraCol, GetVectorFromColumn (incomplete); SolveCholesky_1
still needs work, too.
@
text
@d14 5
a18 4
    & ColumnScale, CreateBlock, DestroyBlock, Dump, M_Absent, M_Full, &
    & MatrixElement_T, MaxAbsVal, MinDiag, MultiplyMatrixBlocks, &
    & MultiplyMatrixVector, MultiplyMatrixVectorNoT, operator(+), &
    & operator(.TX.), RowScale, SolveCholesky, UpdateDiagonal
d28 8
a35 5
  public :: AddMatrices, AddMatrixToDatabase, AddToMatrix, Assignment(=)
  public :: ClearRows, ClearRows_1, CopyMatrix, CreateEmptyMatrix
  public :: CholeskyFactor, CholeskyFactor_1, ColumnScale, ColumnScale_1
  public :: DestroyMatrix, DestroyMatrixDatabase, Dump, FindBlock
  public :: GetFromMatrixDatabase
d38 2
a39 1
  public :: Matrix_SPD_T, MaxAbsVal, MaxAbsVal_1, MinDiag, MinDiag_1
d43 1
a43 1
  public :: SolveCholesky, SolveCholesky_1
d69 9
d82 4
d91 4
d100 1
a100 1
    module procedure MinDiag_1
d129 1
a129 1
    & "$Id: MatrixModule_1.f90,v 2.5 2001/01/10 21:03:14 vsnyder Exp $"
d353 12
d429 31
d565 5
a569 4
  ! ----------------------------------------------  DestroyMatrix  -----
  subroutine DestroyMatrix ( A )
  ! Destroy a matrix -- deallocate its pointer components, don't change the
  ! name
a571 1
    integer :: I, J                ! Subscripts and look inductors
d574 1
a574 5
    do j = 1, a%col%nb
      do i = 1, a%row%nb
        call destroyBlock ( a%block(i,j) )
      end do ! i
    end do ! j
d578 9
d591 17
d628 1
a628 1
  subroutine FillExtraCol ( A, X )
d630 3
a632 1
  ! Assume it is full -- i.e. don't bother to sparsify it.
d635 1
d640 1
a640 1
    if ( a%col%vec%template%id /= x%template%id ) &
d643 1
a643 1
    if ( .not. a%col%extra ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d645 36
a680 5
    do i = 1, a%row%nb
      call destroyBlock ( a%block(i,a%col%nb) )
      call createBlock ( a%block(i,a%col%nb), a%row%nelts(i), 1, m_full )
      a%block(i,a%col%nb)%values(:,i) = &
        & x%quantities(a%row%quant(i))%values(:,a%row%inst(i))
d682 1
a682 1
  end subroutine FillExtraCol
d712 18
d754 2
a755 2
  ! ----------------------------------------  GetVectorFromColumn  -----
  subroutine GetVectorFromColumn ( Matrix, Column, Vector )
d761 7
d771 16
a786 1
  end subroutine GetVectorFromColumn
d810 10
a819 2
  ! --------------------------------------------------  MinDiag_1  -----
  real(r8) function MinDiag_1 ( A )
d821 1
a821 1
  ! smallest magnitude.
d823 2
a824 6
    integer :: I
    minDiag_1 = minDiag(a%m%block(1,1))
    do i = 2, a%m%row%nb
      minDiag_1 = min(minDiag_1,minDiag(a%m%block(i,i)))
    end do
  end function MinDiag_1
d939 2
a940 2
    type(Vector_T), intent(in) :: RHS_IN
    type(Vector_T), intent(inout) :: RHS_OUT
d996 2
a997 1
    call multiplyMatrixVector ( a, rhs_in, rhs_out, my_update )
d1031 12
d1051 2
d1058 1
a1058 1
    integer :: I, J                ! Subscripts and loop inductors
d1076 2
d1079 1
a1079 1
      do i = 1, z%m%col%nb
d1093 1
a1093 1
      end do ! i = 1, z%m%col%nb
d1095 1
a1095 1
      do i = z%m%row%nb, 1, -1
d1098 1
a1098 1
        do j = i+1, z%m%col%nb
d1109 1
a1109 1
      end do ! i = 1, z%m%col%nb
d1115 1
a1115 1
  ! Add LAMBDA to the diagonal of A.
d1119 1
a1119 1
    integer :: I
d1121 3
a1123 1
    do i = 1, a%m%row%nb
d1238 14
d1255 4
@


2.5
log
@Periodic commit
@
text
@d14 4
a17 3
    & ColumnScale, CreateBlock, DestroyBlock, Dump, M_Absent, MatrixElement_T, &
    & MultiplyMatrixBlocks, MultiplyMatrixVector, MultiplyMatrixVectorNoT, &
    & operator(+), operator(.TX.), RowScale, SolveCholesky, UpdateDiagonal
d31 1
d34 3
a36 3
  public :: Matrix_SPD_T, MultiplyMatrices, MultiplyMatrixVector
  public :: MultiplyMatrixVector_1, MultiplyMatrixVectorSPD_1
  public :: NewMultiplyMatrixVector, NormalEquations
d73 8
d107 1
a107 1
    & "$Id: MatrixModule_1.f90,v 2.4 2000/11/23 01:09:46 vsnyder Exp $"
d117 2
d203 6
a208 4
    ! Check that the matrices are compatible.  We don't need to check
    ! Nelts or Nb, because these are deduced from Vec.
    if ( .not. associated(x%col%vec%template,y%col%vec%template) &
      & .or. .not. associated(x%row%vec%template,y%row%vec%template) &
d260 6
a265 4
    ! Check that the matrices are compatible.  We don't need to check
    ! Nelts or Nb, because these are deduced from Vec.
    if ( .not. associated(x%col%vec%template,y%col%vec%template) &
      & .or. .not. associated(x%row%vec%template,y%row%vec%template) &
d411 2
a412 1
    &,                           Row_Quan_First, Col_Quan_First )
d425 4
d433 2
a434 2
    call defineInfo ( z%row, row, row_Quan_First )
    call defineInfo ( z%col, col, col_Quan_First )
d440 1
a440 1
    subroutine DefineInfo ( RC, Vec, QuanFirst )
d444 1
d449 2
d455 1
d492 5
d540 23
d615 12
d636 25
d1057 3
@


2.4
log
@Add provision to ignore columns during matrix-matrix multiply, finish DUMP.
@
text
@d26 4
a29 3
  public :: AddMatrices, AddToMatrix, Assignment(=), ClearRows, ClearRows_1
  public :: CopyMatrix, CreateEmptyMatrix, CholeskyFactor, CholeskyFactor_1
  public :: ColumnScale, ColumnScale_1, Dump, FindBlock
d31 3
a33 3
  public :: Matrix_T, Matrix_Cholesky_T, Matrix_Kronecker_T, Matrix_SPD_T
  public :: MultiplyMatrices, MultiplyMatrixVector, MultiplyMatrixVector_1
  public :: MultiplyMatrixVectorSPD_1
d41 5
d66 5
d97 1
a97 1
    & "$Id: MatrixModule_1.f90,v 2.3 2000/11/15 00:18:26 vsnyder Exp $"
d136 8
d146 32
d207 32
d491 19
d530 32
d856 17
d967 3
@


2.3
log
@Added assignment(=) interface, row scale, column scale
@
text
@d12 5
a16 4
  use MatrixModule_0, only: Assignment(=), CholeskyFactor, ColumnScale, &
    & CreateBlock, DestroyBlock, M_Absent, MatrixElement_T, &
    & MultiplyMatrixVector, MultiplyMatrixVectorNoT, operator(+), &
    & operator(.TX.), RowScale, SolveCholesky, UpdateDiagonal
d19 3
a21 1
    & MLSMSG_DeAllocate, MLSMSG_Error, MLSMSG_Warning
d26 3
a28 3
  public :: AddMatrices, AddToMatrix, Assignment(=), CopyMatrix
  public :: CreateEmptyMatrix, CholeskyFactor, CholeskyFactor_1, ColumnScale
  public :: ColumnScale_1, Dump, FindBlock
d48 4
d86 1
a86 1
    & "$Id: MatrixModule_1.f90,v 2.2 2000/11/10 00:28:13 vsnyder Exp $"
a200 1
    type(MatrixElement_T) :: P          ! Product of two blocks
d216 2
a217 3
        p = z%m%block(k,i) .tx. z%m%block(k,i)
        s = s + p
        call destroyBlock( p )     ! Avoid a memory leak
d223 2
a224 3
          p = z%m%block(k,i) .tx. z%m%block(k,j)
          s = s + p
          call destroyBlock( p )   ! Avoid a memory leak
d232 18
a448 2
    type(MatrixElement_T) :: T     ! So that we can clean up after a
    !                                low-level multiply
d459 1
a459 1
        z%block(i,j) = x%block(1,i) .tx. y%block(1,j)
d461 2
a462 4
          t = x%block(k,i) .tx. y%block(k,j) ! ??? It may be desirable to
          z%block(i,j) = z%block(i,j) + t    ! ??? improve this by having a
                                             ! ??? low-level multiply-add.
          call destroyBlock ( t )       ! Avoid a memory leak
d562 1
d564 1
a565 2
    type(MatrixElement_T) :: T     ! So that we can clean up after a
    !                                low-level multiply
d573 3
d577 26
a602 6
        z%m%block(i,j) = a%block(1,i) .tx. a%block(1,j)
        do k = 2, a%row%nb
          t = a%block(k,i) .tx. a%block(k,j) ! ??? It may be desirable to
          z%m%block(i,j) = z%m%block(i,j) + t    ! ??? improve this by having a
                                             ! ??? low-level multiply-add.
          call destroyBlock ( t )   ! Avoid a memory leak
d752 21
a772 1
    logical, intent(in), optional :: Details
d775 38
d816 3
@


2.2
log
@Added multiply untransposed matrix * vector
@
text
@d12 4
a15 4
  use MatrixModule_0, only: CholeskyFactor, ColumnScale, CreateBlock, &
    & DestroyBlock, M_Absent, MatrixElement_T, MultiplyMatrixVector, &
    & MultiplyMatrixVectorNoT, operator(+), operator(.TX.), &
    & RowScale, SolveCholesky, UpdateDiagonal
d23 3
a25 2
  public :: AddMatrices, CreateEmptyMatrix, CholeskyFactor, CholeskyFactor_1
  public :: ColumnScale, ColumnScale_1, Dump, FindBlock
d37 4
d79 1
a79 1
    & "$Id: MatrixModule_1.f90,v 2.1 2000/11/09 01:23:23 vsnyder Exp $"
d101 1
a101 1
    integer :: Name      ! Sub-rosa index of matrix name, if any, else zero
d128 1
a128 1
  ! result.
d139 1
a139 1
        & call MLSMSG ( MLSMSG_Error, ModuleName, &
d145 2
a146 2
      end do ! i = 1, nr
    end do ! j = 1, nc
d149 36
d203 1
a203 1
        & call MLSMSG ( MLSMSG_Error, ModuleName, &
d229 4
a232 3
  function ColumnScale_1 ( X, V ) result ( Z ) ! Z = X V where V is a
  !                                diagonal matrix represented by a vector.
    type (Matrix_T), intent(in) :: X
d234 1
a234 1
    type (Matrix_T) :: Z
d238 29
a266 2
    call createEmptyMatrix ( z, 0, x%row%vec, x%col%vec, &
      & x%row%instFirst, x%col%instFirst )
d269 4
a272 5
      end do ! i = x%row%nb
        z%block(i,j) = columnScale ( x%block(i,j), &
          & v%quantities(x%col%quant(j))%values(:,x%col%inst(j)) )
    end do ! j = x%col%nb
  end function ColumnScale_1
d310 2
a311 2
    if ( status /= 0 ) call MLSMSG ( MLSMSG_Allocate, ModuleName, &
      & "Z%Block in CreateEmptyMatrix" )
d367 2
a368 1
  ! Destroy a matrix -- deallocate its pointer components
d382 2
a383 13
    call destroyInfo ( a%row )
    call destroyInfo ( a%col )

  contains
    subroutine DestroyInfo ( RC )
      type(RC_Info), intent(out) :: RC
      call deallocate_test ( rc%nelts,  &
        & "rc%nelts in DestroyMatrix", ModuleName )
      call deallocate_test ( rc%inst, "rc%inst in DestroyMatrix", &
        & ModuleName )
      call deallocate_test ( rc%quant, "rc%quant in DestroyMatrix", &
        & ModuleName )
    end subroutine DestroyInfo
d423 1
a423 1
  ! result.
d434 1
a434 1
        & call MLSMSG ( MLSMSG_Error, ModuleName, &
d541 1
a541 1
  ! result.
d570 3
a572 2
  function RowScale_1 ( V, X ) result ( Z ) ! Z = V X where V is a
  !                                diagonal matrix represented by a vector.
d574 2
a575 2
    type (Matrix_T), intent(in) :: X
    type (Matrix_T) :: Z
d579 20
a598 10
    call createEmptyMatrix ( z, 0, x%row%vec, x%col%vec, &
      & x%row%instFirst, x%col%instFirst )
    do j = 1, x%col%nb
      do i = 1, x%row%nb
      end do ! i = x%row%nb
        z%block(i,j) = &
          & RowScale ( v%quantities(x%row%quant(i))%values(:,x%row%inst(i)), &
          & x%block(i,j) )
    end do ! j = x%col%nb
  end function RowScale_1
d623 1
a623 1
        & call MLSMSG ( MLSMSG_Error, ModuleName, &
d628 1
a628 1
      & call MLSMSG ( MLSMSG_Error, ModuleName, &
d681 26
d717 3
@


2.1
log
@Initial entry -- still under construction
@
text
@d11 1
d13 2
a14 1
    & DestroyBlock, M_Absent, MatrixElement_T, operator(+), operator(.TX.), &
d24 1
a24 2
  public :: ColumnScale, ColumnScale_1, Dump
  public :: FindBlock
d26 3
a28 3
  public :: Matrix_T, Matrix_Cholesky_T
  public :: Matrix_Kronecker_T, Matrix_SPD_T, MultiplyMatrices
  public :: MultiplyMatrixVector, MultiplyMatrixVector_1
d49 1
a49 1
    module procedure MultiplyMatrixVector_1
d74 1
a74 1
    & "$Id: MatrixModule_1.f90,v 2.3 2000/10/12 20:10:08 vsnyder Exp $"
d401 2
a402 2
    logical :: DO_UPDATE      ! Tells multiply_Matrix_Vector whether to
    !                           clear an element of Z, or add to it
d420 1
a420 1
        call multiply_Matrix_Vector ( a%block(i,j), &
d428 28
d621 4
a624 1
! $Log: $
@

