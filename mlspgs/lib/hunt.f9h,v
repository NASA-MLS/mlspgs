head	2.3;
access;
symbols
	v5-02-NRT-19:2.3
	v6-00:2.3
	v5-02-NRT-18:2.3
	v5-02:2.3
	v5-01-NRT-17:2.3
	v5-01-NRT-16:2.3
	v5-01-NRT-15:2.3
	v5-01-NRT-14:2.3
	neuralnetworks-1-0:2.3.0.8
	cfm-single-freq-0-1:2.3.0.6
	v5-01:2.3
	v5-00:2.3
	v4-23-TA133:2.3.0.4
	mus-emls-1-70:2.3.0.2
	rel-1-0-englocks-work:2.1.0.4
	VUMLS1-00:2.1
	VPL1-00:2.1
	V4-22-NRT-08:2.1
	VAM1-00:2.1
	V4-21:2.1.0.2
	V4-13:2.1
	V4-12:2.1
	V4-11:2.1
	V4-10:2.1
	M4-00:2.1
	V3-33:2.1;
locks; strict;
comment	@# @;


2.3
date	2018.05.22.03.03.38;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2018.05.17.01.30.42;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2011.08.26.17.51.30;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.3
log
@Intel didn't notice assignment to host-associated variable in pure subroutine
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! subroutine ?_HUNT ( ELEMENT, ARRAY, N, JLO, JHI )

    integer, intent(in) :: N

!   real(rk), intent(in) :: ELEMENT, ARRAY(n)
    real(rk), intent(in) :: ELEMENT
    real(rk), contiguous, intent(in) :: ARRAY(:)

    integer, intent(inout) :: JLO
    integer, intent(out)   :: JHI

    real(rk) :: Delta

    if (n < 2) then
      jlo = 1
      jhi = 1
    else
      delta = array(n) - array(1)
      if ( delta > 0 ) then
        call AscendingHunt ( Array(1:n), jlo, jhi )
        jhi = min(jlo+1,n)
      else if ( delta < 0 ) then
        call AscendingHunt ( Array(n:1:-1), jlo, jhi )
        jhi = n - jlo + 1
        jlo = min(jhi+1,n)
      else ! All the same, first element is as good as any
        jlo = 1
        jhi = 2
      end if
    end if

  contains
    pure subroutine AscendingHunt ( Array, JLO, JHI )
      real(rk), contiguous, intent(in) :: Array(:)
      integer, intent(inout) :: JLO, JHI
      integer :: Inc, JM

      if (jlo <= 0 .or. jlo > n) then ! Start with a secant estimate
        jlo = min(max(int(( ( element - array(1) ) / abs(delta) ) * n),1),n)
        jhi = min(jlo + 1,n)
      end if
      inc = 1                                   

      if ( element >= array(jlo) ) then         
 10     jhi = jlo + inc                         
        if (jhi > n) then                       
          jhi = n                               
          if (jlo == n) jlo = n-1               
        else if ( element >= array(jhi) ) then  
          jlo = jhi                             
          inc = inc + inc                       
          goto 10                               
        end if                                  
      else                                      
        jhi = jlo                               
 20     jlo = jhi - inc                         
        if (jlo < 1) then                       
          jlo = 1                               
          if (jhi == 1) jhi = 2                 
        else if ( element < array(jlo) ) then   
          jhi = jlo                             
          inc = inc + inc                       
          goto 20                               
        end if                                  
      end if                                    

      do while ( jhi-jlo > 1 )
        jm = (jhi + jlo) / 2
        if ( element > array(jm) ) then
          jlo = jm
        else
          jhi = jm
        end if
      end do
    end subroutine AscendingHunt

! end subroutine ?_HUNT
! $Log: hunt.f9h,v $
! Revision 2.2  2018/05/17 01:30:42  vsnyder
! Start hunt with a secant estimate instead of 1:n
!
! Revision 2.1  2011/08/26 17:51:30  pwagner
! Moved here from fwdmdl
!
! Revision 2.7  2009/07/09 23:54:19  vsnyder
! Use default integer instead of I4 kind integer
!
! Revision 2.6  2005/06/22 18:20:14  pwagner
! Cant have access declared outside module scope
!
! Revision 2.5  2005/06/22 18:14:01  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.4  2005/03/29 01:58:17  vsnyder
! Make stuff pure
!
! Revision 2.3  2004/06/25 01:21:44  vsnyder
! JHI is really intent(out)
!
! Revision 2.2  2002/10/04 01:49:04  vsnyder
! Cosmetic changes
!
! Revision 2.1  2002/10/02 15:49:46  bwknosp
! Added Id and RCS info
!
! Revision 2.0  2001/09/17 20:26:27  livesey
! New forward model
!
! Revision 1.6  2001/06/07 23:39:31  pwagner
! Added Copyright statement
!
! Revision 1.5  2001/03/09 00:45:13  vsnyder
! Change Log to $Log
!
@


2.2
log
@Start hunt with a secant estimate instead of 1:n
@
text
@d31 1
a31 1
        call AscendingHunt ( Array(1:n) )
d34 1
a34 1
        call AscendingHunt ( Array(n:1:-1) )
d44 1
a44 1
    pure subroutine AscendingHunt ( Array )
d46 1
d90 3
@


2.1
log
@Moved here from fwdmdl
@
text
@d17 2
a18 1
    real(rk), intent(in) :: ELEMENT, ARRAY(*)
d20 2
a21 2
    integer, intent(in out) :: JLO
    integer, intent(out)    :: JHI
d23 1
a23 2
    integer :: INC, JM
    logical :: ASCND
a27 8
      return
    end if

    ascnd = (array(n) > array(1))

    if (jlo <= 0 .or. jlo > n) then
      jlo = 1
      jhi = n
d29 11
a39 24

      inc = 1

      if ( element >= array(jlo) .eqv. ascnd ) then
 10     jhi = jlo + inc
        if (jhi > n) then
          jhi = n
          if (jlo == n) jlo = n-1
        else if ( element >= array(jhi) .eqv. ascnd ) then
          jlo = jhi
          inc = inc + inc
          goto 10
        end if
      else
        jhi = jlo
 20     jlo = jhi - inc
        if (jlo < 1) then
          jlo = 1
          if (jhi == 1) jhi = 2
        else if ( element < array(jlo) .eqv. ascnd ) then
          jhi = jlo
          inc = inc + inc
          goto 20
        end if
d43 8
a50 6
    do while ( jhi-jlo > 1 )
      jm = (jhi + jlo) / 2
      if ( element > array(jm) .eqv. ascnd ) then
        jlo = jm
      else
        jhi = jm
d52 34
a85 1
    end do
d89 3
@

