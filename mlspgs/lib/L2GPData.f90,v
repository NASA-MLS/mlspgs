head	2.258;
access;
symbols
	v5-02-NRT-19:2.258
	v6-00:2.258
	v5-02-NRT-18:2.257
	v5-02:2.243
	v5-01-NRT-17:2.253
	v5-01-NRT-16:2.253
	v5-01-NRT-15:2.253
	v5-01-NRT-14:2.250
	neuralnetworks-1-0:2.247.0.4
	cfm-single-freq-0-1:2.247.0.2
	v5-01:2.243
	v5-00:2.240
	v4-23-TA133:2.239.0.2
	mus-emls-1-70:2.236.0.2
	rel-1-0-englocks-work:2.232.0.2
	VUMLS1-00:2.226
	VPL1-00:2.223
	V4-22-NRT-08:2.221
	VAM1-00:2.217
	V4-21:2.210.0.2
	V4-13:2.205
	V4-12:2.203
	V4-11:2.201
	V4-10:2.201
	V3-43:2.174
	M4-00:2.192
	V3-41:2.174
	V3-40-PlusGM57:2.174.0.2
	V2-24-NRT-04:2.151
	V3-33:2.179
	V2-24:2.151
	V3-31:2.179
	V3-30-NRT-05:2.176
	cfm-01-00:2.176
	V3-30:2.174
	V3-20:2.174
	V3-10:2.167
	V2-23-NRT-02:2.151
	V2-23:2.151
	V2-22-NRT-01:2.151
	V2-22:2.151
	V2-21:2.146
	V2-20:2.145
	V2-11:2.143
	V2-10:2.143
	V2-00:2.143
	V1-51:2.112
	V1-50:2.112
	V1-45:2.110
	V1-44:2.110
	V1-43:2.105
	V1-42:2.87
	V1-41:2.87
	V1-32:2.96
	V1-40:2.87
	V1-31:2.86
	V1-30:2.80
	V1-13:2.58
	V1-12:2.58
	V1-11:2.58
	V1-10:2.52
	newfwm-feb03:2.55.0.2
	V1-04:2.40
	V1-03:2.40
	V1-02:2.40
	V1-00:2.40
	newfwm-sep01:2.36.0.2
	V0-7:2.36
	V0-5-Level2:2.29
	V0-5-SIPS:2.25
	V0_1:1.13;
locks; strict;
comment	@# @;


2.258
date	2024.02.02.21.30.17;	author pwagner;	state Exp;
branches;
next	2.257;

2.257
date	2023.07.06.18.42.48;	author pwagner;	state Exp;
branches;
next	2.256;

2.256
date	2023.02.02.22.25.11;	author pwagner;	state Exp;
branches;
next	2.255;

2.255
date	2022.11.16.23.12.17;	author pwagner;	state Exp;
branches;
next	2.254;

2.254
date	2022.11.08.23.50.42;	author pwagner;	state Exp;
branches;
next	2.253;

2.253
date	2021.09.30.21.51.21;	author pwagner;	state Exp;
branches;
next	2.252;

2.252
date	2021.09.23.23.02.56;	author pwagner;	state Exp;
branches;
next	2.251;

2.251
date	2021.09.02.22.44.38;	author pwagner;	state Exp;
branches;
next	2.250;

2.250
date	2021.06.10.23.44.09;	author pwagner;	state Exp;
branches;
next	2.249;

2.249
date	2021.05.27.23.39.09;	author pwagner;	state Exp;
branches;
next	2.248;

2.248
date	2021.04.15.22.43.22;	author pwagner;	state Exp;
branches;
next	2.247;

2.247
date	2020.07.17.16.16.14;	author pwagner;	state Exp;
branches;
next	2.246;

2.246
date	2020.06.30.23.20.18;	author pwagner;	state Exp;
branches;
next	2.245;

2.245
date	2020.03.20.23.04.13;	author pwagner;	state Exp;
branches;
next	2.244;

2.244
date	2020.03.04.21.24.48;	author pwagner;	state Exp;
branches;
next	2.243;

2.243
date	2020.02.13.21.27.08;	author pwagner;	state Exp;
branches;
next	2.242;

2.242
date	2019.10.30.20.09.37;	author pwagner;	state Exp;
branches;
next	2.241;

2.241
date	2019.10.21.23.20.14;	author pwagner;	state Exp;
branches;
next	2.240;

2.240
date	2019.05.13.23.32.55;	author pwagner;	state Exp;
branches;
next	2.239;

2.239
date	2019.01.29.21.45.47;	author pwagner;	state Exp;
branches;
next	2.238;

2.238
date	2018.11.12.23.11.12;	author pwagner;	state Exp;
branches;
next	2.237;

2.237
date	2018.08.01.22.14.27;	author pwagner;	state Exp;
branches;
next	2.236;

2.236
date	2018.05.31.22.47.45;	author pwagner;	state Exp;
branches;
next	2.235;

2.235
date	2018.05.22.23.41.14;	author pwagner;	state Exp;
branches;
next	2.234;

2.234
date	2018.04.24.18.25.11;	author pwagner;	state Exp;
branches;
next	2.233;

2.233
date	2018.04.19.00.50.43;	author vsnyder;	state Exp;
branches;
next	2.232;

2.232
date	2018.02.28.19.54.26;	author pwagner;	state Exp;
branches;
next	2.231;

2.231
date	2018.02.03.00.24.49;	author pwagner;	state Exp;
branches;
next	2.230;

2.230
date	2017.12.18.16.41.09;	author mmadatya;	state Exp;
branches;
next	2.229;

2.229
date	2017.11.30.21.15.53;	author pwagner;	state Exp;
branches;
next	2.228;

2.228
date	2017.11.03.19.59.08;	author pwagner;	state Exp;
branches;
next	2.227;

2.227
date	2017.07.19.22.51.50;	author pwagner;	state Exp;
branches;
next	2.226;

2.226
date	2017.03.10.00.40.19;	author vsnyder;	state Exp;
branches;
next	2.225;

2.225
date	2016.11.03.22.39.14;	author pwagner;	state Exp;
branches;
next	2.224;

2.224
date	2016.09.07.22.46.21;	author pwagner;	state Exp;
branches;
next	2.223;

2.223
date	2016.07.28.01.42.27;	author vsnyder;	state Exp;
branches;
next	2.222;

2.222
date	2016.06.13.17.59.16;	author pwagner;	state Exp;
branches;
next	2.221;

2.221
date	2016.03.23.00.20.09;	author pwagner;	state Exp;
branches;
next	2.220;

2.220
date	2015.10.14.23.18.04;	author pwagner;	state Exp;
branches;
next	2.219;

2.219
date	2015.10.13.23.48.28;	author pwagner;	state Exp;
branches;
next	2.218;

2.218
date	2015.10.06.00.20.53;	author pwagner;	state Exp;
branches;
next	2.217;

2.217
date	2015.09.17.22.57.09;	author pwagner;	state Exp;
branches;
next	2.216;

2.216
date	2015.09.03.20.26.59;	author pwagner;	state Exp;
branches;
next	2.215;

2.215
date	2015.08.29.00.42.00;	author vsnyder;	state Exp;
branches;
next	2.214;

2.214
date	2015.07.14.23.13.21;	author pwagner;	state Exp;
branches;
next	2.213;

2.213
date	2015.06.04.17.05.35;	author pwagner;	state Exp;
branches;
next	2.212;

2.212
date	2015.04.28.16.21.11;	author pwagner;	state Exp;
branches;
next	2.211;

2.211
date	2015.03.28.01.09.22;	author vsnyder;	state Exp;
branches;
next	2.210;

2.210
date	2015.02.27.23.57.55;	author pwagner;	state Exp;
branches;
next	2.209;

2.209
date	2015.02.18.00.28.01;	author pwagner;	state Exp;
branches;
next	2.208;

2.208
date	2014.12.11.21.25.57;	author pwagner;	state Exp;
branches;
next	2.207;

2.207
date	2014.12.10.21.27.49;	author pwagner;	state Exp;
branches;
next	2.206;

2.206
date	2014.12.09.01.26.52;	author pwagner;	state Exp;
branches;
next	2.205;

2.205
date	2014.10.01.00.02.06;	author pwagner;	state Exp;
branches;
next	2.204;

2.204
date	2014.09.04.23.47.44;	author vsnyder;	state Exp;
branches;
next	2.203;

2.203
date	2014.07.23.21.59.53;	author pwagner;	state Exp;
branches;
next	2.202;

2.202
date	2014.07.21.21.59.27;	author pwagner;	state Exp;
branches;
next	2.201;

2.201
date	2014.04.07.17.24.33;	author pwagner;	state Exp;
branches;
next	2.200;

2.200
date	2014.04.02.23.03.11;	author pwagner;	state Exp;
branches;
next	2.199;

2.199
date	2014.01.09.00.24.29;	author pwagner;	state Exp;
branches;
next	2.198;

2.198
date	2013.10.15.23.53.40;	author pwagner;	state Exp;
branches;
next	2.197;

2.197
date	2013.09.25.00.45.44;	author pwagner;	state Exp;
branches;
next	2.196;

2.196
date	2013.09.24.00.53.53;	author pwagner;	state Exp;
branches;
next	2.195;

2.195
date	2013.09.17.22.35.40;	author pwagner;	state Exp;
branches;
next	2.194;

2.194
date	2013.08.31.01.24.53;	author vsnyder;	state Exp;
branches;
next	2.193;

2.193
date	2013.08.12.23.47.25;	author pwagner;	state Exp;
branches;
next	2.192;

2.192
date	2013.04.05.23.17.52;	author pwagner;	state Exp;
branches;
next	2.191;

2.191
date	2013.02.26.00.11.49;	author pwagner;	state Exp;
branches;
next	2.190;

2.190
date	2013.02.21.22.22.53;	author pwagner;	state Exp;
branches;
next	2.189;

2.189
date	2013.01.02.21.00.37;	author pwagner;	state Exp;
branches;
next	2.188;

2.188
date	2012.10.09.00.34.52;	author pwagner;	state Exp;
branches;
next	2.187;

2.187
date	2012.09.18.18.50.25;	author pwagner;	state Exp;
branches;
next	2.186;

2.186
date	2012.07.10.15.18.05;	author pwagner;	state Exp;
branches;
next	2.185;

2.185
date	2012.07.05.23.49.04;	author pwagner;	state Exp;
branches;
next	2.184;

2.184
date	2012.05.10.00.45.24;	author pwagner;	state Exp;
branches;
next	2.183;

2.183
date	2012.05.01.23.12.34;	author pwagner;	state Exp;
branches;
next	2.182;

2.182
date	2012.01.11.17.35.20;	author pwagner;	state Exp;
branches;
next	2.181;

2.181
date	2011.12.07.01.18.14;	author pwagner;	state Exp;
branches;
next	2.180;

2.180
date	2011.07.07.00.31.03;	author pwagner;	state Exp;
branches;
next	2.179;

2.179
date	2011.02.05.01.33.44;	author pwagner;	state Exp;
branches;
next	2.178;

2.178
date	2010.11.17.01.19.13;	author pwagner;	state Exp;
branches;
next	2.177;

2.177
date	2010.11.10.02.03.06;	author pwagner;	state Exp;
branches;
next	2.176;

2.176
date	2010.06.22.16.53.15;	author pwagner;	state Exp;
branches;
next	2.175;

2.175
date	2010.06.19.00.11.05;	author pwagner;	state Exp;
branches;
next	2.174;

2.174
date	2010.02.12.00.25.46;	author pwagner;	state Exp;
branches;
next	2.173;

2.173
date	2010.02.04.23.08.00;	author vsnyder;	state Exp;
branches;
next	2.172;

2.172
date	2009.11.04.23.15.53;	author pwagner;	state Exp;
branches;
next	2.171;

2.171
date	2009.10.22.00.52.39;	author pwagner;	state Exp;
branches;
next	2.170;

2.170
date	2009.10.05.23.39.24;	author pwagner;	state Exp;
branches;
next	2.169;

2.169
date	2009.09.29.23.35.43;	author pwagner;	state Exp;
branches;
next	2.168;

2.168
date	2009.08.26.16.45.55;	author pwagner;	state Exp;
branches;
next	2.167;

2.167
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.166;

2.166
date	2009.06.16.17.21.08;	author pwagner;	state Exp;
branches;
next	2.165;

2.165
date	2009.06.02.17.49.17;	author cvuu;	state Exp;
branches;
next	2.164;

2.164
date	2009.05.14.22.01.21;	author pwagner;	state Exp;
branches;
next	2.163;

2.163
date	2009.05.08.00.42.58;	author pwagner;	state Exp;
branches;
next	2.162;

2.162
date	2008.12.02.23.11.41;	author pwagner;	state Exp;
branches;
next	2.161;

2.161
date	2008.09.10.00.44.58;	author pwagner;	state Exp;
branches;
next	2.160;

2.160
date	2008.09.09.00.24.49;	author pwagner;	state Exp;
branches;
next	2.159;

2.159
date	2008.09.03.20.43.09;	author pwagner;	state Exp;
branches;
next	2.158;

2.158
date	2008.07.09.16.36.31;	author pwagner;	state Exp;
branches;
next	2.157;

2.157
date	2008.04.22.18.57.33;	author pwagner;	state Exp;
branches;
next	2.156;

2.156
date	2008.04.18.21.06.59;	author pwagner;	state Exp;
branches;
next	2.155;

2.155
date	2008.02.28.01.27.06;	author pwagner;	state Exp;
branches;
next	2.154;

2.154
date	2008.01.24.23.33.04;	author pwagner;	state Exp;
branches;
next	2.153;

2.153
date	2008.01.07.21.37.23;	author pwagner;	state Exp;
branches;
next	2.152;

2.152
date	2007.12.19.01.29.37;	author pwagner;	state Exp;
branches;
next	2.151;

2.151
date	2007.10.10.00.00.51;	author pwagner;	state Exp;
branches;
next	2.150;

2.150
date	2007.08.13.17.36.38;	author pwagner;	state Exp;
branches;
next	2.149;

2.149
date	2007.06.26.00.20.14;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2007.05.30.22.03.41;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2007.02.26.23.58.48;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2007.02.13.21.57.08;	author pwagner;	state Exp;
branches;
next	2.145;

2.145
date	2006.10.11.00.16.33;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2006.09.29.23.56.49;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2006.04.12.20.49.10;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2006.04.06.23.04.52;	author pwagner;	state Exp;
branches;
next	2.141;

2.141
date	2006.03.13.23.40.28;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2006.02.28.21.44.44;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2006.02.21.19.09.25;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2006.02.16.00.09.23;	author pwagner;	state Exp;
branches;
next	2.137;

2.137
date	2006.02.03.21.25.00;	author pwagner;	state Exp;
branches;
next	2.136;

2.136
date	2006.01.27.01.02.19;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2006.01.26.00.33.09;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2006.01.19.00.29.10;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2006.01.17.17.49.26;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2006.01.14.00.54.08;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2006.01.04.20.31.19;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2005.12.16.00.05.57;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2005.11.04.18.51.19;	author pwagner;	state Exp;
branches;
next	2.128;

2.128
date	2005.10.28.23.12.02;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2005.10.18.23.06.49;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2005.10.11.17.36.55;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2005.09.23.23.38.30;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2005.09.21.23.16.40;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2005.09.14.00.08.15;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2005.08.19.23.37.22;	author pwagner;	state Exp;
branches;
next	2.121;

2.121
date	2005.08.15.10.40.38;	author hcp;	state Exp;
branches;
next	2.120;

2.120
date	2005.08.08.23.55.04;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2005.08.05.20.32.56;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2005.07.12.17.15.47;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2005.07.06.00.31.06;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2005.06.29.00.41.50;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2005.06.22.17.25.49;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2005.06.14.22.33.45;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2005.06.14.20.38.27;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2004.12.14.21.38.59;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2004.10.27.00.32.35;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2004.08.04.23.19.01;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2004.08.03.17.59.35;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2004.07.22.17.07.15;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2004.06.11.19.07.02;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2004.06.09.00.04.51;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2004.06.02.19.37.52;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2004.05.26.23.57.29;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2004.05.26.20.31.29;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2004.05.05.21.29.53;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2004.04.23.01.43.34;	author livesey;	state Exp;
branches;
next	2.100;

2.100
date	2004.04.06.01.17.43;	author livesey;	state Exp;
branches;
next	2.99;

2.99
date	2004.03.29.18.51.18;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2004.03.24.23.53.02;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2004.03.12.00.38.19;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2004.02.26.22.02.36;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2004.02.13.00.18.58;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2004.02.11.23.05.05;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2004.02.11.23.04.38;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2004.02.11.22.59.59;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2004.02.11.17.23.25;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2004.02.10.18.45.43;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2004.02.05.23.33.21;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2004.01.23.01.14.04;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2004.01.09.00.20.56;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2003.12.03.17.51.14;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2003.11.19.22.14.08;	author livesey;	state Exp;
branches;
next	2.84;

2.84
date	2003.11.05.21.44.38;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2003.10.31.12.35.57;	author hcp;	state Exp;
branches;
next	2.82;

2.82
date	2003.10.28.21.41.06;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2003.10.28.00.39.00;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2003.09.09.23.03.46;	author livesey;	state Exp;
branches;
next	2.79;

2.79
date	2003.09.08.22.51.54;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2003.09.04.03.02.53;	author livesey;	state Exp;
branches;
next	2.77;

2.77
date	2003.09.03.22.39.44;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2003.08.28.23.51.03;	author livesey;	state Exp;
branches;
next	2.75;

2.75
date	2003.08.27.20.06.26;	author livesey;	state Exp;
branches;
next	2.74;

2.74
date	2003.07.21.23.32.09;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2003.07.15.23.35.11;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2003.07.10.22.18.49;	author livesey;	state Exp;
branches;
next	2.71;

2.71
date	2003.07.09.21.49.06;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2003.07.08.00.43.17;	author livesey;	state Exp;
branches;
next	2.69;

2.69
date	2003.07.07.21.04.55;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2003.07.02.00.55.27;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2003.06.26.00.04.46;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2003.06.20.19.31.39;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2003.06.09.22.44.09;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2003.04.21.19.34.59;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2003.04.17.23.07.02;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2003.04.15.23.14.50;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2003.04.11.23.35.10;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2003.04.03.22.58.40;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2003.04.02.23.53.56;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2003.03.07.00.40.23;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2003.02.26.17.36.11;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2003.02.21.23.41.53;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2003.02.12.21.50.33;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2003.02.10.22.04.49;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2003.02.08.00.33.32;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2003.02.07.01.05.12;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2003.02.06.00.24.48;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2003.02.04.22.43.29;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2003.02.03.21.33.15;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2002.10.08.00.09.10;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2002.08.22.20.17.47;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2002.08.20.20.10.20;	author livesey;	state Exp;
branches;
next	2.45;

2.45
date	2002.08.20.19.48.29;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2002.07.17.19.02.09;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2002.07.17.18.57.32;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2002.07.11.22.21.00;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2002.07.01.23.48.34;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2002.03.15.23.02.49;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2002.01.23.21.47.12;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2001.10.26.23.13.18;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2001.09.05.22.57.16;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2001.08.16.23.17.42;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2001.08.06.18.39.03;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2001.08.03.23.13.52;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2001.08.03.00.02.26;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2001.08.02.00.17.56;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2001.06.13.20.36.15;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2001.06.06.17.28.13;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2001.05.03.23.59.56;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2001.04.24.16.28.41;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2001.04.20.03.00.59;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2001.04.20.02.05.09;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2001.03.20.01.44.25;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2001.03.12.20.25.04;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2001.03.01.18.37.51;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2001.02.22.21.54.22;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.02.15.18.23.20;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.02.15.18.20.15;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2001.02.14.23.39.40;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.02.13.00.55.35;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2001.02.13.00.51.31;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2001.02.09.18.38.04;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.02.09.17.51.01;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.02.09.17.45.15;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.02.08.01.06.08;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.02.05.23.58.22;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.02.03.00.04.26;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.02.02.17.15.02;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.01.29.18.17.49;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2000.12.04.23.43.59;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2000.09.22.14.29.42;	author pumphrey;	state Exp;
branches;
next	2.6;

2.6
date	2000.09.21.13.48.18;	author pumphrey;	state Exp;
branches;
next	2.5;

2.5
date	2000.09.19.12.42.11;	author pumphrey;	state Exp;
branches;
next	2.4;

2.4
date	2000.09.18.10.19.49;	author pumphrey;	state Exp;
branches;
next	2.3;

2.3
date	2000.09.18.08.55.20;	author pumphrey;	state Exp;
branches;
next	2.2;

2.2
date	2000.09.18.08.50.40;	author pumphrey;	state Exp;
branches;
next	2.1;

2.1
date	2000.09.15.21.50.18;	author livesey;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.05.17.21.15;	author dcuddy;	state dead;
branches;
next	1.13;

1.13
date	2000.06.30.00.43.08;	author lungu;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.19.22.59.16;	author lungu;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.17.23.38.14;	author lungu;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.17.21.18.06;	author livesey;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.12.20.28.20;	author livesey;	state Exp;
branches;
next	1.8;

1.8
date	99.12.21.19.00.10;	author livesey;	state Exp;
branches;
next	1.7;

1.7
date	99.12.21.00.15.15;	author livesey;	state Exp;
branches;
next	1.6;

1.6
date	99.12.18.01.06.28;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	99.12.17.21.41.31;	author livesey;	state Exp;
branches;
next	1.4;

1.4
date	99.12.14.00.53.50;	author livesey;	state Exp;
branches;
next	1.3;

1.3
date	99.12.03.22.24.50;	author livesey;	state Exp;
branches;
next	1.2;

1.2
date	99.12.03.21.28.56;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	99.12.03.19.10.34;	author livesey;	state Exp;
branches;
next	;


desc
@@


2.258
log
@Given CloudTopPressure units hPa
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module L2GPData                 ! Creation, manipulation and I/O for L2GP Data
!=============================================================================
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use HyperSlabs, only: ExtractArray, GatherBloc
  use BitStuff, only: DumpBitNames
  use Constants, only: Deg2Rad
  use Diff_1, only: Diff, Diff_Fun
  use Dump_Options, only: CrashAtBeginning, StatsOnOneLine, NameOnEachLine, &
    & NameHasbeenPrinted
  use Dump_0, only: Dump
  use Dump_1, only: Dump
  use Geometry, only: EarthRadA
  use HDF, only: Dfacc_Rdonly, Dfacc_Read, Dfacc_Create, Dfacc_Rdwr, &
    & Dfnt_Float32, Dfnt_Int32, Dfnt_Float64
  use HighOutput, only: BeVerbose, OutputNamedValue, StyledOutput
  use Intrinsic ! "units" Type Literals, Beginning With L
  use MLSCommon, only: DefaultUndefinedValue, Interval_T, &
    & MLSFile_T, L2MetaData_T, MLS_HyperStart, UndefinedIntegerValue
  use MLSFiles, only: FileNotFound, &
    & HDFVersion_4, HDFversion_5, WildcardHDFversion, &
    & Dump, InitializeMLSFile, MLS_CloseFile, MLS_Exists, MLS_OpenFile, &
    & MLS_HDF_Version, MLS_Inqswath
  use MLSKinds, only: R4, R8, Rt
  use MLSFillValues, only: IsfillValue, ReplacefillValues
  use MLSHDFEOS, only: HSize
  use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, MLSMessage
  use MLSNumerics, only: FindInRange
  use MLSFinds, only: FindFirst, FindLast, FindUnique
  use MLSSets, only: FindIntersection, Intersection
  use MLSStats1, only: MLSMin
  use MLSStrings, only: Capitalize, Lowercase
  use MLSStringLists, only: ExtractSubstring, &
    & GetHashElement, GetStringElement, GetUniqueList, &
    & List2Array, NumStringElements, RemoveListFromList, ReplaceSubstring, &
    & StringElementNum, SwitchDetail
  use Output_M, only: Blanks, Output, ResumeOutput, SuspendOutput
  use String_Table, only: Display_String
  use Time_M, only: SayTime, ConfigureSayTime, Time_Now
  use Trace_M, only: Trace_Begin, Trace_End

  implicit none

  private
  public :: L2GPData_T
  public :: AddL2GPToDatabase, AppendL2GPData, &
    & CompactL2GPRecord, ContractL2GPRecord, ConvertL2GPToQuantity, &
    & CpHE5GlobalAttrs, CpL2GPData, CpL2GPDataToAttribute, &
    & DestroyL2GPContents, DestroyL2GPDatabase, &
    & Diff, DiffRange, Dump, DumpRange, &
    & ExpandL2GPDataInPlace, ExtractL2GPRecord, FilterL2GP, &
    & IsL2GPSetup, OutputL2GP_Attributes, &
    & ReadL2GPData, RepairL2GP, SetupNewL2GPRecord, WriteL2GPData

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: L2GPData.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  interface ContractL2GPRecord
    module procedure ContractL2GPRecord_opt, ContractL2GPRecord_names
  end interface

  interface Diff
    module procedure DiffL2GPData
    module procedure DiffL2GPData_Chunks
    module procedure DiffL2GPData_Levels
    module procedure DiffL2GPFiles_MLSFile
    module procedure DiffL2GPFiles_Name
  end interface

  interface Diffrange
    module procedure DiffL2GPData_RANGES
  end interface

  interface Diffstats
    module procedure DiffStatsInt
  end interface

  interface Dump
    module procedure Dump_L2GP
    module procedure Dump_L2GP_Chunks
    module procedure Dump_L2GP_DataBase
    module procedure DumpL2GP_attributes_hdf5
  end interface

  interface DumpRange
    module procedure DumpL2GPData_Ranges
  end interface

  interface ExtractL2GPRecord
    module procedure ExtractL2GPRecord_range, ExtractL2GPRecord_which
  end interface

  interface ReadL2GPData
    module procedure ReadL2GPData_fileID
    module procedure ReadL2GPData_fileName
    module procedure ReadL2GPData_MLSFile
  end interface

  interface AppendL2GPData
    module procedure AppendL2GPData_fileName
    module procedure AppendL2GPData_MLSFile
  end interface

  interface CpL2GPData
    module procedure CpL2GPData_fileID
    module procedure CpL2GPData_fileName
    module procedure CpL2GPData_MLSFile
  end interface
  
  interface OutputL2GP_Attributes
    module procedure OutputL2GP_Attributes_MF
  end interface

  interface RepairL2GP
    module procedure RepairL2GP_L2GP
    module procedure RepairL2GP_HGrid
  end interface

  interface WriteL2GPData
    module procedure WriteL2GPData_fileID
    module procedure WriteL2GPData_MLSFile
  end interface

  ! This module defines datatypes and gives basic routines for storing and
  ! manipulating L2GP data.
  ! It is prepared to handle io for both file versions: hdfeos2 and hdfeos5
  ! For NetCDF4 interfaces, see NCL2GP.f90

!     c o n t e n t s
!     - - - - - - - -

! L2GPData_T              The l2gp data type; holds all data for one swath

! AddL2GPToDatabase       Adds an l2gp data type to a database
! AppendL2GPData          Appends L2GP onto end of existing swath file
! CompactL2GPRecord       Reduce a L2GP from an existing L2GP
!                           to just the non-Fill instances
! ContractL2GPRecord      Subsample an existing L2GP using geolocation ranges
! ConvertL2GPToQuantity   Convert an L2GP data type into a Vector Quantity
! CpHE5GlobalAttrs        Copies global attributes from one l2gp file to another
! CpL2GPData              Copies swaths from one l2gp file to another
! CpL2GPDataToAttribute   Copies swathvalues from one l2gp file to another's
!                           file-level attributes
! DestroyL2GPContents     Deallocates all the arrays allocated for an L2GP
! DestroyL2GPDatabase     Destroys an L2GP database
! Diff                    Shows differences between two swaths
! Dump                    Reveals info about an L2GP or a database of L2GP
!                            to any desired level of detail
! ExpandL2GPDataInPlace   Adds more profiles to an existing L2GP
! ExtractL2GPRecord       Subsample an existing L2GP using index ranges
! FilterL2GP              Set Status to Crash wherever Geolocations contain
!                            FillValues
! IsL2GPSetUp             Returns TRUE if all L2GP arrays allocated
! OutputL2GP_Attributes   Write all attributes relevant to an L2GP Data type
! ReadL2GPData            Reads L2GP from existing swath file
! RepairL2GP              Replaces fillValues in one L2GP with either
!                         (1) corresponding values from another L2GP; or
!                         (2) corresponding values from an HGrid
! SetupNewL2GPRecord      Allocates arrays for a new L2GP
! WriteL2GPData           Writes an L2GP into a swath file

! The meaning of options has replaced the older logical arguments
! if the options is present and contains the following characters:
!   character         meaning
!      ---            -------
!       c              repair geolcations of bad chunks
!       d              treat differing geolcations as bad chunks
!       f              filter profiles with FillValues by marking as crashed
!       g              skip diff or dump of geolcations
!       i              ignore bad chunks
!       m              silent (mute)
!       r              rms (or repair where appropriate)
!       s              stats
!       v              verbose
  ! Assume L2GP files w/o explicit hdfVersion field are this
  ! 4 corresponds to hdf4, 5 to hdf5 in L2GP, L2AUX, etc. 
  integer, parameter :: L2GPDefault_HDFVersion = HDFVersion_5
  integer, parameter :: DangerWillRobinson = 513 ! status for a crashed profile

  ! r4 corresponds to sing. prec. :: same as stored in files
  integer, public, parameter :: rgp = r4

  integer, public, parameter :: MAXCHUNKTIMES = 120
  integer, public, parameter :: MAXNUMSWATHPERFILE = 300
  ! How long may the list of swath names grow (~80 x max num. of swaths/file)
  integer, public, parameter :: MAXSWATHNAMESBUFSIZE = 80*MAXNUMSWATHPERFILE

  ! TRUE means we can avoid using unlimited dimension and its time penalty
  logical, public            :: AVOIDUNLIMITEDDIMS         = .true.
  logical, public            :: MUSTGUARDAGIANSTHDFEOSBUG  = .false.
  logical, public            :: WRITEMASTERSFILEATTRIBUTES = .true.

  integer, parameter, public :: CHARATTRLEN = 255   ! was GA_VALUE_LENGTH
  integer, parameter, public :: L2GPNameLen = 80    ! may need to be longer
  integer, parameter, public :: NumDataFields = 5
  integer, parameter, public :: NumGeolocFields = 10
  integer, parameter, public :: MAXFNFIELDS = NumGeolocFields + NumDataFields + 4
  integer, parameter, public :: MAXNLEVELS = 100
  integer, parameter, public :: MAXNUMTIMES = 10000

   ! The following are the current data fields
   character (len=*), parameter, public :: DATA_FIELD1 = 'L2gpValue'
   character (len=*), parameter, public :: DATA_FIELD2 = 'L2gpPrecision'
   ! character (len=*), parameter, public :: DATA_FIELD3 = 'Status'
   ! character (len=*), parameter, public :: DATA_FIELD4 = 'Quality'
   ! character (len=*), parameter, public :: DATA_FIELD5 = 'Convergence'
   character (len=*), parameter, public :: DATA_FIELDS = &
     & 'L2gpValue,L2gpPrecision,Quality,Status,Convergence'

   ! The following are the current geolocation fields
   ! character (len=*), parameter, public :: GEO_FIELD1 = 'Latitude'
   ! character (len=*), parameter, public :: GEO_FIELD2 = 'Longitude'
   ! character (len=*), parameter, public :: GEO_FIELD3 = 'Time'
   ! character (len=*), parameter, public :: GEO_FIELD4 = 'LocalSolarTime'
   ! character (len=*), parameter, public :: GEO_FIELD5 = 'SolarZenithAngle'
   ! character (len=*), parameter, public :: GEO_FIELD6 = 'LineOfSightAngle'
   ! character (len=*), parameter, public :: GEO_FIELD7 = 'OrbitGeodeticAngle'
   ! character (len=*), parameter, public :: GEO_FIELD8 = 'ChunkNumber'
   ! character (len=*), parameter, public :: GEO_FIELD9 = 'Pressure'
   ! character (len=*), parameter, public :: GEO_FIELD10= 'Frequency'
   character (len=*), parameter, public :: GEO_FIELDS = &
     & 'Latitude,Longitude,LocalSolarTime,SolarZenithAngle,LineOfSightAngle' // &
     & ',OrbitGeodeticAngle,Pressure,Time,Frequency,ChunkNumber'
   ! The following are HIRDLS geolocation fields
   ! character (len=*), parameter, public :: HGEO_FIELDS = &
   !  & 'Latitude,Longitude,LocalSolarTime,SolarZenithAngle,LineOfSightAngle' // &
   !  & ',OrbitGeodeticAngle,Time'

   ! The following are the dimension names according to the mls spec
   character (len=*), parameter, public :: DIM_NAME1 = 'nTimes'
   ! character (len=*), parameter, public :: DIM_NAME2 = 'nLevels'
   ! character (len=*), parameter, public :: DIM_NAME3 = 'nFreqs'
   ! An alternate name for DIM_NAME3 used by HIRDLS
   ! character (len=*), parameter, public :: HRD_DIM_NAME3 = 'nChans'
   character (len=*), parameter, public :: DIM_NAME12 = 'nLevels,nTimes'
   character (len=*), parameter, public :: DIM_NAME123 = 'nFreqs,nLevels,nTimes'
   ! These are for the new max_dimlist parameter added to  SWdefgfld.
   ! this one is for non-extendible dimensions
   character (len=*), parameter, public :: MAX_DIML = ' '
   character (len=*), parameter, public :: UNLIM = 'Unlim'
   ! This is for cases where the time dimension is extendible
   character (len=*), parameter, public :: MAX_DIML1 = UNLIM
   character (len=*), parameter, public :: MAX_DIML12 = 'nLevels,Unlim'
   character (len=*), parameter, public :: MAX_DIML123 = 'nFreqs,nLevels,Unlim'

!   INTEGER,PARAMETER::CHUNKFREQS=13,CHUNKLEVELS=17,CHUNKTIMES=9,CHUNK4=1
   
   ! character (len=*), parameter, public :: DEFAULTMAXDIM = UNLIM
   ! integer, parameter, public :: DEFAULT_CHUNKRANK = 1
   ! integer, dimension(7), parameter, public :: DEFAULT_CHUNKDIMS = (/ 1,1,1,1,1,1,1 /)
   integer, parameter, public :: HDFE_NOMERGE = 0       ! don't merge
  
  ! So far, the nameIndex component of the main data type is never set
  logical, parameter, public :: NAMEINDEXEVERSET = .false.  
  
  ! Do you want to write file and swath attributes when you append values
  logical, parameter, public :: APPENDSWRITEATTRIBUTES = .true.  
  
  ! In what range of orbit angles do we set the mode to "descending"
  type(interval_T), public, parameter :: DescendingRange = interval_T( 90._rt, 270._rt )

  ! Do you want to pre-fill arrays with MissingValue by default?
  logical, parameter :: ALWAYSFILLWITHMISSINGVALUE = .true.  
  
  ! Deprecated, demoted, doomed
  logical, parameter, public :: AscDescModeIsField = .false.  

  ! The following pair, keys and hash, tell what value the units attribute
  ! will be given when writing column abundances in hdfeos5-formatted files
  ! You should override these if you need to do so
  character(len=255), public, save :: COL_SPECIES_KEYS = &
    & 'h2o,hno3,o3,hcl,clo,co,n2o,oh,rhi,so2,' &
    & // &
    & 'ho2,bro,hocl,hcn,iwc,ch3cn'
  character(len=255), public, save :: COL_SPECIES_HASH = &
    & 'molcm2,molcm2,DU,molcm2,molcm2,molcm2,molcm2,molcm2,molcm2,molcm2,' &
    & // &
    & 'molcm2,molcm2,molcm2,molcm2,molcm2,molcm2'
  character(len=16), dimension(10), parameter :: StatusBitNames = (/ &
    & 'do not use      ', 'beware          ', 'inform          ', &
    & 'post-processed  ', 'high clouds     ', 'low clouds      ', &
    & 'no meteorology  ', 'abandoned chunk ', 'too few radiance', &
    & 'mlsl2 crashed   ' /)
!      123456789012345678901234567890123456789012345678901234567890

  ! This datatype is the main one, it simply defines one l2gp swath
  ! It is used for 
  ! (1) normal swaths, which have geolocations along nTimes
  !     vertical coordinates called "surfaces" dimensioned by pressures
  !     and at nTimes horizontal "instances" dimensioned by 
  !     latitudes and longitudes
  ! (2) column abundances which are  integrated amounts and therefore 
  !     the vertical coordinate is suppressed; instead we set nLevels=1
  !     and store the tropopause in pressures(1)
  type L2GPData_T

     ! First some variables we use for book keeping

     character (len=L2GPNameLen) :: name ! Typically the swath name.
     integer :: nameIndex       ! Used by the parser to keep track of the data
     ! integer :: QUANTITYTYPE = 0   ! E.g., l_temperature; (Where is this used?)

     ! Now the dimensions of the data

     integer :: nTimes          ! Number of profiles in this slave
     integer :: nTimesTotal     ! Total number of profiles
     integer :: nLevels         ! Total number of surfaces (==1 for col. abund)
     integer :: nFreqs          ! Number of frequencies in breakdown

     ! Now we store the geolocation fields, first the vertical one:
     ! (The following has the tropopause if the swath is a column abundance)
     real (rgp), pointer, dimension(:) :: pressures=>NULL() ! Vertical coords (nLevels)

     ! Now the horizontal geolocation information. Dimensioned (nTimes)
     real (rgp), pointer, dimension(:) :: latitude => NULL()
     real (rgp), pointer, dimension(:) :: longitude => NULL()
     real (rgp), pointer, dimension(:) :: solarTime => NULL()
     real (rgp), pointer, dimension(:) :: solarZenith => NULL()
     real (rgp), pointer, dimension(:) :: losAngle => NULL()
     real (rgp), pointer, dimension(:) :: geodAngle => NULL()
     real (r8 ), pointer, dimension(:) :: time => NULL()   ! dble prec.

     integer, pointer, dimension(:) :: chunkNumber=>NULL()

     ! Now we store the `frequency' geolocation field

     real (rgp), pointer, dimension(:) :: frequency=>NULL()
     !        dimensioned (nFreqs)

     ! Finally we store the data fields

     real (rgp), pointer, dimension(:,:,:) :: l2gpValue=>NULL()
     real (rgp), pointer, dimension(:,:,:) :: l2gpPrecision=>NULL()
     ! dimensioned (nFreqs, nLevels, nTimes)

     ! Now we've changed our minds: status will be a 4-byte integer
     integer, pointer, dimension(:)    :: status=>NULL()
     !                (status is a reserved word in F90)
     real (rgp), pointer, dimension(:) :: quality=>NULL()
     real (rgp), pointer, dimension(:) :: convergence=>NULL()
     
     ! These fields applies only to products of a neural network model
     integer, pointer, dimension(:)    :: BinNumber=>NULL()
     integer, pointer, dimension(:)    :: MAF=>NULL()
     ! We have deprecated this field
     integer, pointer, dimension(:)    :: AscDescMode=>NULL()
     ! All the above dimensioned (nTimes)

     ! These are the fill/missing values for l2gpValue
     real (rgp)                        :: MissingL2GP  = DefaultUndefinedValue
     ! These are the fill/missing values for all other arrays except status
     real (rgp)                        :: MissingValue = DefaultUndefinedValue
     integer                           :: MissingStatus = DangerWillRobinson
    ! Vertical coordinate
    character(len=8) :: verticalCoordinate ! E.g. 'Pressure', or 'Theta'
  ! The following final method caused the sids tests
  ! in the nightly gold brick to bomb. A symptom of a deeper problem?
  ! contains
    ! final :: DestroyL2GPContents
  end type L2GPData_T

  ! Print debugging stuff?
  logical, parameter :: DEEBUG = .false.  
  logical, parameter ::SWATHLEVELMISSINGVALUE = .false. ! Make it swath attr?
  real :: t2

contains ! =====     Public Procedures     =============================

  !-------------------------------------------------------------

  ! ---------------------- AppendL2GPData_fileName  ---------------------------

  subroutine AppendL2GPData_fileName( l2gp, fileName, &
    & swathname, offset, lastProfile, TotNumProfs, hdfVersion, &
    & createSwath, maxchunksize )
    !------------------------------------------------------------------------

    ! Given a file name,
    ! This routine does an append operation (see AppendL2GPData_fileID).
    ! If the file doesn't exist yet, hopefully, it'll create it.
    ! So, far, that hope as been realized.

    ! Arguments

    character (len=*), intent(in) :: fileName ! Name of file to append to
    type( l2GPData_T ), intent(inout) :: l2gp ! What to append
    character (len=*), optional, intent(in) ::swathName!default->l2gp%swathName
    integer,intent(in),optional   :: offset
    integer, intent(in), optional ::lastProfile
    integer,intent(in),optional   :: TotNumProfs
    integer, optional, intent(in) :: hdfVersion
    logical, intent(in), optional :: createSwath
    integer, optional, intent(in) :: maxchunksize
    ! logical, optional, intent(in) :: clean   ! Not implemented yet

    ! Local
    integer                       :: file_access    
    logical                       :: file_exists    
    type(MLSFile_T)               :: MLSFile        
    logical                       :: myClean        
    integer                       :: status         
    integer                       :: the_hdfVersion 
    
    ! Executable code
    myClean = .false.
    ! if ( present(clean) ) myClean = clean
    file_exists = ( mls_exists(trim(FileName)) == 0 )
    the_hdfVersion = L2GPDEFAULT_HDFVERSION
    if ( present(hdfVersion) ) the_hdfVersion = hdfVersion
    if ( the_hdfVersion == WILDCARDHDFVERSION ) then


      ! Does the file exist, yet?
      if ( .not. file_exists ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File not found; make sure the name and path are correct' &
          & // trim(fileName) )
      endif
      the_hdfVersion = mls_hdf_version(FileName, hdfVersion)
      if ( the_hdfVersion == FILENOTFOUND ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File not found; make sure the name and path are correct' &
          & // trim(fileName) )
    endif
    if ( file_exists ) then
      file_access = DFACC_RDWR
    else
      file_access = DFACC_CREATE
    endif
    status = InitializeMLSFile ( MLSFile, type=l_swath, access=file_access, &
     & name=trim(fileName), content = 'l2gp', HDFVersion=the_hdfVersion )
    ! call MLS_OpenFile( MLSFile )
    ! L2FileHandle = MLSFile%FileID%f_id
    call AppendL2GPData_MLSfile( l2gp, MLSFile, swathname, &
      & offset, lastProfile=lastProfile, totNumProfs=totNumProfs, &
      & createSwath=createSwath, &
      & maxchunksize=maxchunksize )
    ! call MLS_CloseFile( MLSFile )
  end subroutine AppendL2GPData_fileName
  ! ---------------------- AppendL2GPData_MLSFile  ---------------------------

  subroutine AppendL2GPData_MLSfile( l2gp, l2gpFile, &
    & swathName, offset, lastProfile, TotNumProfs, &
    & createSwath, maxchunksize )
    ! sticks l2gp into the swath swathName in the file pointed at by
    ! l2FileHandle,starting at the profile number "offset" (First profile
    ! in the file has offset==0). If this runs off the end of the swath, 
    ! it is lengthened automagically. 
    ! This call has been altered recently, so that it can be used to create
    ! a swath as well as adding to one. 

    use MLSHDFEOS, only: MLS_Swath_In_File

    ! Arguments

    type(MLSFile_T)                :: L2GPFile

    ! This is a L2GPData_T structure containing all the data to be written
    type (L2GPData_T), intent(INOUT) :: l2gp
    ! This is the name the swath is given in the file. By default it is
    ! the name contained in l2gp
    character (len=*), optional, intent(in) ::swathName!default->l2gp%swathName
    ! This (offset) is the point in the swath at which the data is written. 
    ! First profile in the file has offset==0. If the swath in the file is 
    ! shorter than offset + ( num of profiles in l2gp) then it grows by magic
    integer, intent(in), optional::offset
    ! TotNumProfs is a new argument. It seems only to be used if we are 
    ! creating a swath, rather than adding to one. In that case I guess
    ! it is the total number of profiles in the swath created. I also 
    ! guess that this is done so that we can avoid growing and re-growing 
    ! the swath.
    integer, intent(in), optional ::TotNumProfs
    integer, intent(in), optional ::lastProfile
    logical, intent(in), optional :: createSwath
    integer, optional, intent(in) :: maxchunksize
    ! Local
    integer :: actual_ntimes
    logical :: alreadyOpen
    type (L2GPData_T) :: largerl2gp
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: myLastProfile
    character (len=L2GPNameLen) :: myswathName
    logical :: notUnlimited
    integer :: numProfs
    integer :: status
    logical :: swath_exists
    logical :: timing
    real :: tFile ! How long have we been fooling with this file?
    type (L2GPData_T) :: totall2gp
    ! logical, parameter :: DEEBUG = .false.

    ! Executable code
    call trace_begin ( me, 'AppendL2GPData_MLSFile', cond=.false. )
    ! call Dump ( l2gp%chunkNumber, 'Appending l2gp%chunkNumber' )
    call time_now ( tFile )
    call configureSayTime ( tFile )
    status = 0
    timing = DEEBUG .or. BeVerbose( 'l2gp', 2 )

    if (present(lastProfile)) then
      myLastProfile = lastProfile 
    elseif (present(TotNumProfs)) then
      myLastProfile = TotNumProfs 
    else
      myLastProfile = L2GP%nTimesTotal
    endif
    alreadyOpen = L2GPFile%stillOpen
    if ( .not. alreadyOpen ) then
      if ( DEEBUG ) print *, 'Needed to open file ', trim(L2GPFile%name)
      call mls_openFile(L2GPFile, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l2gp file', MLSFile=L2GPFile)
    endif
    if ( timing ) then
      call sayTime( 'Opening file ' // trim(L2GPFile%name), tFile, t2 )
      tFile = t2
    endif
    if ( L2GPFile%access == DFACC_RDONLY )  &
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'l2gp file is rdonly', MLSFile=L2GPFile)
    myswathName = l2gp%name
    if ( present(swathName) ) myswathName = swathName
    
    swath_exists = mls_swath_in_file( L2GPFile%name, myswathName, &
      & L2GPFile%HdfVersion )

    ! if ( timing ) call outputNamedValue( 'tFile', tFile )
    if ( timing ) then
      call sayTime( 'Checking that swath exists', tFile, t2 )
      tFile = t2
    endif
    if ( swath_exists .and. &
      & ( MUSTGUARDAGIANSTHDFEOSBUG .or. .not. present(maxChunkSize) ) &
      & ) then
      if(DEEBUG) print *, 'Swath already exists--guarding against hdfeos bug'
      ! We must guard against a bug in HDF-EOS that prevents appending more
      ! profiles to a swath than already exist
      call ReadL2GPData( L2GPFile, myswathName, totall2gp, numProfs, &
        & ReadData=.false. )
      if ( l2gp%nTimes > numProfs ) then
        if(DEEBUG) call outputNamedValue( 'current', totall2gp%nTimes )
        if(DEEBUG) call outputNamedValue( 'needed', l2gp%nTimes )
        call DestroyL2GPContents ( totall2gp )
        call ReadL2GPData( L2GPFile, myswathName, totall2gp, numProfs )
        call ExpandL2GPDataInPlace( totall2gp, l2gp%nTimes )
        if(DEEBUG) call outputNamedValue( 'expanded', totall2gp%nTimes )
        call ExpandL2GPDataInFile( L2GPFile, myswathName, totall2gp )
        if(DEEBUG) call outputNamedValue( 'AppendL2GPData expanded', totall2gp%nTimes )
      elseif(DEEBUG) then
         print *, 'Swath already has enough profiles'
      endif
      call DestroyL2GPContents ( totall2gp )
      if ( timing ) then
        call sayTime( 'Guarding against HDFEOS error', tFile, t2 )
        tFile = t2
      endif
    elseif ( swath_exists ) then
      if(DEEBUG) print *, 'OK, swath already exists, but HDFEOS bug no longer scares us'
    else
      ! Must create swath in file w/o disturbing other swaths
      if(DEEBUG) print *, 'Must create swath'
      if(DEEBUG) print *, 'Will have ', myLastProfile, ' profiles'
      if(DEEBUG) print *, 'instead of ', l2gp%nTimes, ' profiles'
      actual_ntimes = l2gp%nTimes
      ! if ( present(TotNumProfs) ) l2gp%nTimes = TotNumProfs
      select case (L2GPFile%hdfVersion)
      case (HDFVERSION_4)
        ! Currently force unlimited, remove the .false. .and. to allow limited
        if ( present(TotNumProfs) ) l2gp%nTimes = TotNumProfs
        call OutputL2GP_createFile_MF (l2gp, L2GPFile, &
          & myswathName, notUnlimited=.false. .and. present(totNumProfs))
        l2gp%nTimes = actual_ntimes
      case (HDFVERSION_5)
        ! By default allow limited; 
        ! may force unlimited by setting avoidUnlimitedDims to FALSE
        notUnlimited = ( avoidUnlimitedDims .and. present(totNumProfs) )
        ! if ( present(TotNumProfs) ) l2gp%nTimes = TotNumProfs
        if ( present(maxchunksize) ) then
          if ( maxchunksize > l2gp%nTimes ) then
            call SetupNewL2GPRecord ( largerl2gp, proto=l2gp, &
              & nTimes=maxchunksize )
            call OutputL2GP_createFile_MF ( largerl2gp, L2GPFile, &
              & myswathName, notUnlimited=notUnlimited )
            call DestroyL2GPContents ( largerl2gp )
          else
            call OutputL2GP_createFile_MF ( l2gp, L2GPFile, &
              & myswathName, notUnlimited=notUnlimited )
          endif
        else
          call OutputL2GP_createFile_MF ( l2gp, L2GPFile, &
            & myswathName, notUnlimited=notUnlimited )
        endif
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
         & 'Illegal hdf version in AppendL2GPData_fileID', MLSFile=L2GPFile)
      end select
      ! l2gp%nTimes = actual_ntimes
    endif

    if(DEEBUG) then
      if ( present(offset) ) then
        print*,"offset=",offset,"myLastProfile=",myLastProfile,&
        "size(l2gp%l2gpValue,3)=",size(l2gp%l2gpValue,3)
      else
        print*,"no offset; myLastProfile=",myLastProfile,&
        "size(l2gp%l2gpValue,3)=",size(l2gp%l2gpValue,3)
      endif
    endif
    if ( size(l2gp%l2gpValue,3) == 0 ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & "No profiles in this chunk", MLSFile=L2GPFile )

    else
      ! actual_ntimes = l2gp%nTimes
      ! l2gp%nTimes = max(myLastProfile - offset + 1, 1)
      if ( all(l2gp%chunkNumber == -999) ) &
        & call output( 'all chunk numbers are -999', advance='yes' )
      call OutputL2GP_writeGeo_MF (l2gp, l2GPFile, &
        & myswathName, offset)
      if ( timing ) then
        call sayTime( 'Writing geolocations', tFile, t2 )
        tFile = t2
      endif
      call OutputL2GP_writeData_MF (l2gp, l2GPFile, &
        & myswathName, offset)
      if ( timing ) then
        call sayTime( 'Writing data', tFile, t2 )
        tFile = t2
      endif
      select case ( L2GPFile%HDFVersion )
      case ( HDFVERSION_4 )
      case ( HDFVERSION_5 )
        if ( .not. swath_exists .and. APPENDSWRITEATTRIBUTES) then
          call OutputL2GP_Attributes_MF (l2gp, l2GPFile, swathName)
          call SetL2GP_aliases_MF (l2gp, l2GPFile, swathName)
          if ( timing ) then
            call sayTime( 'Writing attributes', tFile, t2 )
            tFile = t2
          endif
        end if
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Unrecognized hdfVersion passed to AppendL2GPData", MLSFile=L2GPFile )
      end select
      ! l2gp%nTimes = actual_ntimes
    end if

    if ( .not. alreadyOpen )  call mls_closeFile(L2GPFile, Status)
    L2GPFile%errorCode = status
    L2GPFile%lastOperation = 'append'
    call trace_end ( 'AppendL2GPData_MLSFile', cond=.false. )
  end subroutine AppendL2GPData_MLSFile

  !------------------------------------------  CompactL2GPRecord  -----
  ! Trim all the flabby FillValues from an L2GP record producing a slim
  ! athletic record suitable for Olympic tryouts

  subroutine CompactL2GPRecord ( ol2gp, l2gp )
    ! Dummy arguments
    type (L2GPData_T), intent(in)   ::     ol2gp
    type (L2GPData_T), intent(out)  ::     l2gp
    ! Local variables
    integer, parameter              :: MaxFreqs  = 150
    integer, parameter              :: MaxLevels = 150
    integer, parameter              :: MaxTimes  = 7200
    integer, dimension(MaxFreqs )   :: whichFreqs  ! which freqs        
    integer, dimension(MaxLevels)   :: whichLevels ! which levels       
    integer, dimension(MaxTimes )   :: whichTimes  ! which times        
    integer                         :: useFreqs  ! how many freqs
    integer                         :: useLevels ! how many levels
    integer                         :: useTimes  ! how many times
    integer                         :: k
    ! Executable
    useFreqs  = 0
    useLevels = 0
    useTimes  = 0
    ! Discover which values are non-Fill
    if (associated(ol2gp%frequency) ) then
      do k=1, size(ol2gp%frequency)
        if ( .not. isFillValue( ol2gp%frequency(k) ) ) then
          useFreqs = useFreqs + 1
          whichFreqs(useFreqs) = k
        endif
      enddo
    endif
    if (associated(ol2gp%pressures) ) then
      do k=1, size(ol2gp%pressures)
        if ( .not. isFillValue( ol2gp%pressures(k) ) ) then
          useLevels = useLevels + 1
          whichLevels(useLevels) = k
        endif
      enddo
    endif
    if (associated(ol2gp%time) ) then
      do k=1, size(ol2gp%time)
        if ( .not. isFillValue( ol2gp%time(k) ) ) then
          useTimes = useTimes + 1
          whichTimes(useTimes) = k
        endif
      enddo
    endif
    if ( DeeBug ) then
      call outputnamedValue ( 'useFreqs ', useFreqs  )
      call outputnamedValue ( 'useLevels', useLevels )
      call outputnamedValue ( 'useTimes ', useTimes  )
    endif
    call ExtractL2GPRecord ( ol2gp, l2gp, &
      & whichFreqs, whichLevels, whichTimes, &
      & useFreqs, useLevels, useTimes )
  end subroutine CompactL2GPRecord

  !------------------------------------------  ContractL2GPRecord  -----
  ! Gather a reduced copy of an original l2gp record
  ! picking out a set of subscripts for freqs, level2, times
  ! based on input range(s) for latitude, pressure, etc.

  ! A trick: if the lowBound > hiBound then the sense is reversed
  ! i.e. find subscripts outside corresponding range

  ! Note that this does not do the more useful task:
  ! Reposition an l2gp record onto a new set of geolocations
  ! via multi-dimensional or repeated interpolation

  subroutine ContractL2GPRecord_names ( ol2gp, l2gp, &
    & geoBoxNames, geoBoxLowBound, geoBoxHiBound )
    ! Dummy arguments
    type (L2GPData_T), intent(in)   ::     ol2gp
    type (L2GPData_T), intent(out)  ::     l2gp
    character(len=*), intent(in)  ::       geoBoxNames
    real(rgp), dimension(:), intent(in) :: geoBoxLowBound  ! range
    real(rgp), dimension(:), intent(in) :: geoBoxHiBound  ! range
    ! Internal variables
    logical, parameter :: countEmpty = .true.
    integer :: elem
    real(rgp), dimension(2) :: pressures  ! range
    real(rgp), dimension(2) :: latitudes  ! range
    real(rgp), dimension(2) :: longitudes  ! range
    real(r8), dimension(2) :: times  ! range
    ! Executable
    pressures(1)  = ol2gp%MissingValue
    latitudes(1)  = ol2gp%MissingValue
    longitudes(1) = ol2gp%MissingValue
    times(1)      = ol2gp%MissingValue
    pressures(2)  = ol2gp%MissingValue
    latitudes(2)  = ol2gp%MissingValue
    longitudes(2) = ol2gp%MissingValue
    times(2)      = ol2gp%MissingValue
    elem = stringElementNum( lowerCase(geoBoxNames), 'pressure', countEmpty )
    if ( elem > 0 ) then
      pressures(1)   = geoBoxLowBound(elem)
      pressures(2)   = geoBoxHiBound(elem)
    endif
    elem = stringElementNum( lowerCase(geoBoxNames), 'latitude', countEmpty )
    if ( elem > 0 ) then
      latitudes(1)   = geoBoxLowBound(elem)
      latitudes(2)   = geoBoxHiBound(elem)
    endif
    elem = stringElementNum( lowerCase(geoBoxNames), 'longitude', countEmpty )
    if ( elem > 0 ) then
      longitudes(1)   = geoBoxLowBound(elem)
      longitudes(2)   = geoBoxHiBound(elem)
    endif
    elem = stringElementNum( lowerCase(geoBoxNames), 'time', countEmpty )
    if ( elem > 0 ) then
      times(1)   = geoBoxLowBound(elem)
      times(2)   = geoBoxHiBound(elem)
    endif
    call ContractL2GPRecord( ol2gp, l2gp, pressures, latitudes, &
    & longitudes, times )
  end subroutine ContractL2GPRecord_names

  subroutine ContractL2GPRecord_opt ( ol2gp, l2gp, pressures, latitudes, &
    & longitudes, intimes, hoursInDay, chunks )
    ! Dummy arguments
    type (L2GPData_T), intent(in)   :: ol2gp
    type (L2GPData_T), intent(out)  :: l2gp
    real(rgp), dimension(2), intent(in), optional :: pressures  ! range
    real(rgp), dimension(2), intent(in), optional :: latitudes  ! range
    real(rgp), dimension(2), intent(in), optional :: longitudes ! range
    real(r8), dimension(2), intent(in), optional  :: intimes    ! range
    real(rgp), dimension(2), intent(in), optional :: hoursInDay ! range
    integer, dimension(2), intent(in), optional   :: chunks     ! range
    ! Local variables
    integer :: i, n
    integer, dimension(:), allocatable :: intrsctn
    integer, dimension(4000) :: tempTimes  ! subscripts
    real(r8), dimension(2)  :: times
    integer :: useFreqs  
    integer :: useLevels 
    integer :: useTimes  
    integer, dimension(300) :: whichFreqs ! subscripts
    integer, dimension(60) :: whichLevels ! subscripts
    integer, dimension(4000) :: whichTimes  ! subscripts

    ! logical, parameter :: DEEBug = .true.
    
    ! Executable
    do i=1, max( ol2gp%nFreqs, 1 )
      whichFreqs(i)=i
    enddo
    do i=1, max( ol2gp%nTimes, 1 )
      whichTimes(i)=i
    enddo
    do i=1, max( ol2gp%nLevels, 1 )
      whichLevels(i)=i
    enddo
    useFreqs = max( ol2gp%nFreqs, 1 )
    useTimes = ol2gp%nTimes
    useLevels = max(ol2gp%nLevels, 1)
    if ( present(pressures) ) then
      if ( any(IsFillValue(pressures, ol2gp%MissingValue)) ) then
        ! we do nothing
      elseif ( pressures(2) >= pressures(1) ) then
        call FindInRange( ol2gp%pressures, pressures, whichLevels, useLevels )
      else
        ! Reverse sense (i.e., find outside of range)
        call FindInRange( ol2gp%pressures, pressures, whichLevels, useLevels, options='-r' )
      endif
    endif
    if ( present(latitudes) ) then
      if ( any(IsFillValue(latitudes, ol2gp%MissingValue)) ) then
        ! we do nothing
      else
        if ( latitudes(2) >= latitudes(1) ) then
          call FindInRange( ol2gp%latitude, latitudes, tempTimes, n )
        else
          ! Reverse sense (i.e., find outside of range)
          call FindInRange( ol2gp%latitude, latitudes, tempTimes, n, options='-r' )
        endif
        intrsctn = Intersection( whichTimes(1:useTimes), tempTimes(1:n) )
        useTimes = size(intrsctn)
        whichTimes(1:useTimes) = intrsctn
        if ( DeeBug ) then
          call dump( latitudes, 'latitudes' )
          call outputNamedValue( 'n', n )
          call dump( tempTimes(1:n), 'tempTimes' )
          call dump( intrsctn(1:useTimes), 'intrsctn' )
        endif
        call deallocate_test( intrsctn, 'intersection with lats', ModuleName )
      endif
    endif
    if ( present(longitudes) ) then
      if ( any(IsFillValue(longitudes, ol2gp%MissingValue)) ) then
        ! we do nothing
      else
        if ( longitudes(2) >= longitudes(1) ) then
          call FindInRange( ol2gp%longitude, longitudes, tempTimes, n )
        else
          ! Reverse sense (i.e., find outside of range)
          call FindInRange( ol2gp%longitude, longitudes, tempTimes, n, options='-r' )
        endif
        intrsctn = Intersection( whichTimes(1:useTimes), tempTimes(1:n) )
        useTimes = size(intrsctn)
        whichTimes(1:useTimes) = intrsctn
        if ( DeeBug ) then
          call dump( longitudes, 'longitudes' )
          call outputNamedValue( 'n', n )
          call dump( tempTimes(1:n), 'tempTimes' )
          call dump( intrsctn(1:useTimes), 'intrsctn' )
        endif
        call deallocate_test( intrsctn, 'intersection with lons', ModuleName )
      endif
    endif
    ! Time may be represented as either TAI (s after midnight Jan 1 1993)
    if ( present(intimes) ) then
      times = intimes
    elseif ( present(hoursInDay) ) then
      times = hoursInDayToTime( hoursInDay, ol2gp )
    endif
    n = 0 ! We may need to further reduce useTimes
    if ( present(intimes) .or. present(hoursInDay) ) then
      if ( any(IsFillValue(times, real(ol2gp%MissingValue, r8))) ) then
        ! we do nothing
      else
        if ( times(2) >= times(1) ) then
          call FindInRange( ol2gp%time, times, tempTimes, n )
        else
          ! Reverse sense (i.e., find outside of range)
          call FindInRange( ol2gp%time, times, tempTimes, n, options='-r' )
        endif
      endif
    elseif ( present(chunks) ) then
      call FindInRange( ol2gp%chunkNumber, chunks, tempTimes, n )
    endif
    if ( &
      & ( n > 0 ) &
      & .and. &
      & ( present(intimes) .or. present(hoursInDay) .or. present(chunks) ) &
      & ) then
      intrsctn = Intersection( whichTimes(1:useTimes), tempTimes(1:n) )
      useTimes = size(intrsctn)
      whichTimes(1:useTimes) = intrsctn
      if ( DeeBug ) then
        call dump( times, 'times' )
        call outputNamedValue( 'n', n )
        call dump( tempTimes(1:n), 'tempTimes' )
        call dump( intrsctn(1:useTimes), 'intrsctn' )
      endif
      call deallocate_test( intrsctn, 'intersection with times', ModuleName )
    endif
    call ExtractL2GPRecord ( ol2gp, l2gp, whichFreqs, whichLevels, whichTimes, &
    & useFreqs, useLevels, useTimes )
  end subroutine ContractL2GPRecord_opt

  !------------------------------------------  ConvertL2GPToQuantity  -----
  ! Convert an existing l2gp data type to an equivalent
  ! vector quantity

  subroutine ConvertL2GPToQuantity ( l2gp, Quantity )
    use QuantityTemplates, only: SetUpNewQuantityTemplate
    use VectorsModule, only: VectorValue_T, CreateVectorValue
    ! Dummy arguments
    type (L2GPData_T), intent(in)   ::     l2gp
    type (VectorValue_T), intent(out)  ::  Quantity
    ! Internal variables
    ! Executable
    call SetupNewQuantityTemplate ( Quantity%template, l2gp%nTimes, l2gp%nLevels, &
      & 1, .true., .true., .true. )
    call CreateVectorValue ( Quantity, 'L2GP'  )
    if ( associated(l2gp%l2gpValue) ) Quantity%values = l2gp%l2gpValue(1,:,:)
    ! Don't bother copying any of the gelocations if l2gp%latitudes not associated
    if ( .not. associated(l2gp%latitude) ) return
    Quantity%template%geodLat(1,:)        = l2gp%latitude
    Quantity%template%lon(1,:)            = l2gp%longitude
    Quantity%template%time(1,:)           = l2gp%time
    Quantity%template%losAngle(1,:)       = l2gp%losAngle
    Quantity%template%solarTime(1,:)      = l2gp%solarTime
    Quantity%template%solarZenith(1,:)    = l2gp%solarZenith
    ! If SetupNewQuantityTemplate edxplained clearly and accurately
    ! about the 2 indexes of the surfs array, this if bloc wouldn't be needed.
    ! However, all the chaff about regular, coherent, and stacked
    ! possibilities, with no effort at explaining them,
    ! leaves us no recourse but what might be called
    !   d e f e n s i v e   p r o g r a m m i n g
    if ( size(Quantity%template%surfs,1) == l2gp%nLevels ) then
      Quantity%template%surfs(:,1)          = l2gp%pressures
    elseif ( size(Quantity%template%surfs,2) == l2gp%nLevels ) then
      Quantity%template%surfs(1,:)          = l2gp%pressures
    ! else
      ! call MLSMessage ( MLSMSG_Error, ModuleName, &
      !   & 'ConvertL2GPToQuantity failed to cope with l2gp pressures' )
    endif
  end subroutine ConvertL2GPToQuantity

  ! ---------------------- cpHE5GlobalAttrs  ---------------------------

  subroutine cpHE5GlobalAttrs( File1Handle, File2Handle, status )
  ! Copy global attributes from file 1 to file 2
    use PCfhdr, only: GlobalAttributes_T, GlobalAttributes, &
      & DumpGlobalAttributes, HE5_Readglobalattr, HE5_Writeglobalattr
    ! Args
    integer, intent(in)                          :: File1Handle
    integer, intent(in)                          :: File2Handle
    integer, intent(out)                         :: status
    ! Internal variables
    type(GlobalAttributes_T)                     :: gAttributes        
    type(GlobalAttributes_T)                     :: gAttributesOriginal
    character(len=40)                            :: ProcessLevel       
    double precision                             :: TAI93At0zOfGranule 
    integer                                      :: DayofYear          
    ! Executable
    if ( DEEBUG ) then
      call output( 'Before reading global attributes', advance='yes' )
      call outputNamedValue( 'StartUTC', trim(GlobalAttributes%StartUTC) )
    endif
    call he5_readglobalattr ( File1Handle, gAttributes, &
      & ProcessLevel, DayofYear, TAI93At0zOfGranule, returnStatus=status )
    if ( status == 0 ) then
      if ( DEEBUG ) then
        call output ( '(Global Attributes read) ', advance='yes')
        call dumpGlobalAttributes
      endif
      if ( DEEBUG ) then
        call output( 'After reading global attributes', advance='yes' )
        call outputNamedValue( 'StartUTC', trim(GlobalAttributes%StartUTC) )
      endif
      ! Unfortunately, he5_writeglobalattr writes class-level data
      ! so must save original version so can copy new data into it 
      gAttributes%HostName = GlobalAttributes%HostName
      gAttributes%ProductionLoc = GlobalAttributes%ProductionLoc
      gAttributesOriginal = GlobalAttributes
      GlobalAttributes = gAttributes
      ! Why must we do this? Why do things not simply work out properly?
      GlobalAttributes%TAI93At0zOfGranule = TAI93At0zOfGranule
      if ( DEEBUG ) then
        call outputNamedValue('Misc Notes (written) ', trim(GlobalAttributes%MiscNotes) )
        call dumpGlobalAttributes
      endif
      call he5_writeglobalattr (File2Handle)
      ! Before leaving must restore original data back
      GlobalAttributes = gAttributesOriginal
    endif
  end subroutine cpHE5GlobalAttrs

  ! ---------------------- cpL2GPData_fileID  ---------------------------

  subroutine cpL2GPData_fileID( l2metaData, file1, file2, swathList, &
    & hdfVersion1, hdfVersion2, notUnlimited, rename, ReadData, &
    & HGrid, rFreqs, rLevels, rTimes, options )
    !------------------------------------------------------------------------

    ! Given file names file1 and file2,
    ! This routine copies swathList from 1 to 2
    ! and, depending on options, makes some repairs or applies a sanity filter
    ! which guarantees that any profiles with Fill values among the
    ! geolocations are marked with MissingStatus status

    use HGridsDatabase, only: HGrid_T
    ! Arguments

    type (L2Metadata_T) :: l2metaData
    integer, intent(in)           :: file1 ! handle of file 1
    integer, intent(in)           :: file2 ! handle of file 2
    character (len=*), intent(in) :: swathList ! copy only these; no wildcard
    integer, intent(in)           :: hdfVersion1
    integer, intent(in)           :: hdfVersion2
    logical, optional, intent(in) :: notUnlimited
    logical, optional, intent(in) :: ReadData
    character (len=*), optional, intent(in) :: rename
    type (HGrid_T), optional, intent(in)    :: HGrid
    integer, dimension(2), intent(in), optional :: rFreqs  ! subscript range
    integer, dimension(2), intent(in), optional :: rLevels ! subscript range
    integer, dimension(2), intent(in), optional :: rTimes  ! subscript range
    character (len=*), optional, intent(in) :: options ! E.g., '-v'

    ! Local variables
!     integer :: chunk
    logical, parameter            :: countEmpty = .true.
    logical :: filter
    integer :: i
    type (L2GPData_T) :: l2gp
    type (L2GPData_T) :: reducedl2gp
    integer, dimension(2) :: myFreqs  ! subscript range
    integer, dimension(2) :: myLevels ! subscript range
    integer, dimension(2) :: myTimes  ! subscript range
    character (len=8) :: myOptions
    integer :: noSwaths
    logical :: renameSwaths
    logical :: repair
    character (len=L2GPNameLen) :: swath
    character (len=L2GPNameLen) :: swath2
    logical :: verbose
    
    ! Executable code
    myOptions = ' '
    if ( present(options) ) myOptions = options
    verbose = ( index(myOptions, 'v') > 0 )
    repair  = ( index(myOptions, 'r') > 0 )
    filter  = ( index(myOptions, 'f') > 0 )
    renameSwaths  = present(rename)
    if ( renameSwaths ) renameSwaths = ( rename /= ' ' )
    if ( repair .and. .not. present(HGrid) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'cpL2GPFile must be given HGrid to repair L2GPData' )
    if ( .not. repair .and. present(HGrid) ) &
      & call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'cpL2GPFile was given HGrid but no order to repair L2GPData' )
    noSwaths = NumStringElements( trim(swathList), countEmpty )
    if ( noSwaths < 1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'No swaths to cp to file--unable to count swaths in ' // trim(swathList) )
    endif
    if ( verbose ) call dump(swathlist, 'swath names')
    if ( renameSwaths ) then
      noSwaths = min(noSwaths, NumStringElements(trim(rename), countEmpty))
      if ( verbose ) call dump(rename, 'swath names (copied)')
    endif
    if ( noSwaths < 1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'No swaths cp to file--unable to count swaths in ' // trim(rename) )
    endif
    ! Loop over swaths in file 1
    do i = 1, noSwaths
      call GetStringElement (trim(swathList), swath, i, countEmpty )
      if ( renameSwaths ) then
        call GetStringElement (trim(rename), swath2, i, countEmpty )
      else
        swath2 = swath
      endif
      ! Allocate and fill l2gp
      if ( DEEBUG ) print *, 'Reading swath from file: ', trim(swath)
      call ReadL2GPData ( file1, trim(swath), l2gp, &
           & hdfVersion=hdfVersion1, ReadData=ReadData )
      if ( all(l2gp%chunkNumber == -999) ) &
        & call output( 'all chunk numbers are -999', advance='yes' )
      if ( DEEBUG ) then
        print *, 'Writing swath to file: ', trim(swath)
        print *, 'l2gp%nFreqs:  ', l2gp%nFreqs
        print *, 'l2gp%nLevels: ', l2gp%nLevels
        print *, 'l2gp%nTimes:  ', l2gp%nTimes
        print *, 'shape(l2gp%l2gpvalue):  ', shape(l2gp%l2gpvalue)
        print *, 'l2gp%MissingL2GP:  ', l2gp%MissingL2GP
        print *, 'l2gp%Missingvalue:  ', l2gp%Missingvalue
      endif
      ! call dump ( l2gp%chunkNumber, 'chunkNumber as Read' )
      ! chunk = FindFirst( l2gp%chunkNumber /= -999 )
      ! call outputNamedValue ( 'index of non-Fill chunkNumber', chunk )
      ! Possibly repair or filter l2gp
      if ( repair ) call RepairL2GP( l2gp, HGrid, options=options )
      if ( filter ) call FilterL2GP( l2gp )
      if ( all(l2gp%chunkNumber == -999) ) &
        & call output( 'After repair and filtering, all chunk numbers are -999', advance='yes' )
      ! Possibly extract a reduced l2pg
      if ( present(rFreqs) .or. present(rLevels) .or. present(rTimes) ) then
        if ( present(rFreqs) ) then
          myFreqs = rFreqs
        else
          myFreqs(1) = 1
          myFreqs(2) = l2gp%nFreqs
        endif
        if ( present(rLevels) ) then
          myLevels = rLevels
        else
          myLevels(1) = 1
          myLevels(2) = l2gp%nLevels
        endif
        if ( present(rTimes) ) then
          myTimes = rTimes
        else
          myTimes(1) = 1
          myTimes(2) = l2gp%nTimes
        endif
        if ( DEEBUG ) call Dump( l2gp%BinNumber, 'Full l2gp BinNumber' )
        if ( DEEBUG ) call Dump( l2gp%MAF      , 'Full l2gp MAF' )
        call ExtractL2GPRecord ( l2gp, reducedl2gp, myFreqs, myLevels, myTimes )
        if ( DEEBUG ) call Dump( reducedl2gp%BinNumber, 'Reduced BinNumber' )
        if ( DEEBUG ) call Dump( reducedl2gp%MAF      , 'Reduced l2gp MAF' )
        call WriteL2GPData(reducedl2gp, file2, trim(swath2), &
          & hdfVersion=hdfVersion2, &
          & notUnlimited=notUnlimited)
        call DestroyL2GPContents ( reducedl2gp )
      else
      ! Write the filled l2gp to file2
        ! call dump ( l2gp%chunkNumber, 'chunkNumber as Written' )
        ! chunk = FindFirst( l2gp%chunkNumber /= -999 )
        ! call outputNamedValue ( 'index of non-Fill chunkNumber', chunk )
        call WriteL2GPData(l2gp, file2, trim(swath2), hdfVersion=hdfVersion2, &
          & notUnlimited=notUnlimited)
      endif

      l2metaData%minLat = mlsmin( l2gp%latitude, l2gp%MissingValue )
      l2metaData%maxLat = maxval(l2gp%latitude)
      l2metaData%minLon = mlsmin( l2gp%longitude, l2gp%MissingValue )
      l2metaData%maxLon = maxval(l2gp%longitude)

      call DestroyL2GPContents ( l2gp )
    enddo
       
  end subroutine cpL2GPData_fileID

  ! ---------------------- cpL2GPData_fileName  ---------------------------

  subroutine cpL2GPData_fileName(l2metaData, file1, file2, &
    & create2, hdfVersion1, hdfVersion2, swathList, rename, exclude, &
    & notUnlimited, andGlAttributes, ReadData, HGrid, &
    & rFreqs, rLevels, rTimes, options)
    !------------------------------------------------------------------------

    ! Given file names file1 and file2,
    ! This routine copies all the l2gpdata from 1 to 2
    ! (see cpL2GPData_fileID)
    ! If file2 doesn't exist yet, or if create2 is TRUE, it'll create it
    ! Optionally repairs l2gpdata

    use HGridsDatabase, only: HGrid_T
    ! Arguments

    type (L2Metadata_T) :: l2metaData
    character (len=*), intent(in) :: file1 ! Name of file 1
    character (len=*), intent(in) :: file2 ! Name of file 2
    logical, optional, intent(in) :: create2
    logical, optional, intent(in) :: andGlAttributes
    integer, optional, intent(in) :: hdfVersion1
    integer, optional, intent(in) :: hdfVersion2         !              is wild
    character (len=*), optional, intent(in) :: swathList ! Copy only these; '*'
    character (len=*), optional, intent(in) :: rename ! But rename them these
    character (len=*), optional, intent(in) :: exclude ! Don't copy these
    logical, optional, intent(in)           :: notUnlimited
    logical, optional, intent(in)           :: ReadData
    type (HGrid_T), optional, intent(in)    :: HGrid
    integer, dimension(2), intent(in), optional :: rFreqs  ! subscript range
    integer, dimension(2), intent(in), optional :: rLevels ! subscript range
    integer, dimension(2), intent(in), optional :: rTimes  ! subscript range
    character (len=*), optional, intent(in) :: options ! E.g., '-v'

    ! Local
    logical :: allSwaths
    logical, parameter            :: countEmpty = .true.
    ! logical, parameter :: DEEBUG = .TRUE.
    integer :: File1Handle
    integer :: File2Handle
    logical :: file_exists
    integer :: file_access
    integer :: listsize
    type(MLSFile_T)                :: MLSFile1, MLSFile2
    logical :: myandGlAttributes
    character (len=MAXSWATHNAMESBUFSIZE) :: mySwathList
    character (len=MAXSWATHNAMESBUFSIZE) :: myrename
    integer :: noSwaths
    integer :: status
    integer :: the_hdfVersion1
    integer :: the_hdfVersion2
    
    ! Executable code
    the_hdfVersion1 = L2GPDEFAULT_HDFVERSION
    if ( present(hdfVersion1) ) the_hdfVersion1 = hdfVersion1
    file_exists = ( mls_exists(trim(File1)) == 0 )
    if ( .not. file_exists ) then
      call MLSMessage ( MLSMSG_Error, trim(ModuleName) // '/cpL2GPData', &
        & 'File 1 not found; make sure the name and path are correct' &
        & // trim(file1) )
    endif
    if ( the_hdfVersion1 == WILDCARDHDFVERSION ) then
      the_hdfVersion1 = mls_hdf_version(File1, the_hdfVersion1)
      if ( the_hdfVersion1 == FILENOTFOUND ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File 1 not found; make sure the name and path are correct' &
          & // trim(file1) )
    endif
    the_hdfVersion2 = the_hdfVersion1  ! Defaults to same hdf version as file 1
    if ( present(hdfVersion2) ) the_hdfVersion2 = hdfVersion2

    allSwaths = .not. present(swathList)
    if ( present(swathList) ) allSwaths = (swathList == '*')
    ! if ( present(swathList) ) then
    if ( .not. allSwaths ) then
      if ( DEEBUG ) then
        noSwaths = mls_InqSwath ( file1, mySwathList, listSize, &
           & hdfVersion=the_hdfVersion1)
        print *, 'swathList you requested to cp: ', trim(swathList)
        print *, 'mls_InqSwath finds: ', trim(mySwathList)
      endif
      mySwathList = swathList
    else
      noSwaths = mls_InqSwath ( file1, mySwathList, listSize, &
           & hdfVersion=the_hdfVersion1)
    endif
    status = InitializeMLSFile ( MLSFile1, type=l_swath, access=DFACC_READ, &
     & name=trim(file1), HDFVersion=the_hdfVersion1 )
    call MLS_OpenFile( MLSFile1 )
    File1Handle = MLSFile1%FileID%f_id

    file_exists = ( mls_exists(trim(File2)) == 0 )
    if ( file_exists ) then
      file_access = DFACC_RDWR
    else
      file_access = DFACC_CREATE
    endif
    if ( present(create2) ) then
      if ( create2 ) then
        file_access = DFACC_CREATE
      elseif ( .not. file_exists ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
         & "L2gp file: " // trim(File2) // ' for cp-ing not yet existing')
        file_access = DFACC_RDWR
      else
        file_access = DFACC_RDWR
      endif
    endif
    if ( DEEBUG ) then
      print *, 'About to open file2: ', trim(file2)
      print *, 'file_access: ', file_access
      print *, 'hdfVersion: ', the_hdfVersion2
    endif
    myandGlAttributes = (file_access == DFACC_CREATE)
    if ( present(andGlAttributes) ) &
      & myandGlAttributes = myandGlAttributes .and. andGlAttributes
    myandGlAttributes = myandGlAttributes .and. &
      & (the_hdfVersion1 == HDFVERSION_5) .and. (the_hdfVersion2 == HDFVERSION_5)
    status = InitializeMLSFile ( MLSFile2, type=l_swath, access=file_access, &
     & name=trim(file2), HDFVersion=the_hdfVersion2 )
    call MLS_OpenFile( MLSFile2 )
    File2Handle = MLSFile2%FileID%f_id
    if ( DEEBUG ) then
      print *, 'About to cp from file1 to file2: ', trim(file1), trim(file2)
      print *, trim(mySwathList)
    endif
    ! Maybe copy global attributes, too
    if ( myandGlAttributes ) then
      call cpHE5GlobalAttrs ( File1Handle, File2Handle, status )
      if ( status /= 0 ) &
        & call output ( '(Global Attributes missing) ' // trim(file1), advance='yes')
    endif

    if ( present(exclude) ) then
      call RemoveListFromList( mySwathList, myrename, exclude )
      noSwaths = NumStringElements( trim(myrename), countEmpty )
      if ( noSwaths < 1 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'No swaths after excluding ' )
        call dump( trim(exclude) , 'exclude these' )
        call dump( trim(mySwathList) , 'original SwathList' )
        call dump( trim(myrename) , 'remaining' )
        if ( DEEBUG ) then
          call output( 'Lets do it elem-by-elm', advance='yes' )
          call RemoveListFromList( mySwathList, myrename, exclude, options='-v' )
        endif
        call MLS_CloseFile( MLSFile1 )
        call MLS_CloseFile( MLSFile2 )
        return
      endif
      mySwathList = myrename
    endif
    call cpL2GPData_fileID(l2metaData, File1Handle, File2Handle, &
      & mySwathList, the_hdfVersion1, the_hdfVersion2, &
      & notUnlimited=notUnlimited, rename=rename, &
      & ReadData=ReadData, HGrid=HGrid, &
      & rFreqs=rFreqs, rLevels=rlevels, rTimes=rTimes, options=options )
    if ( DEEBUG ) print *, 'About to close File1Handle: ', File1Handle
    call MLS_CloseFile( MLSFile1 )
    if ( DEEBUG ) print *, 'About to close File2Handle: ', File2Handle
    call MLS_CloseFile( MLSFile2 )
  end subroutine cpL2GPData_fileName

  ! ---------------------- cpL2GPData_MLSFile  ---------------------------


  subroutine cpL2GPData_MLSFile(l2metaData, L2GPfile1, L2GPfile2, &
    & create2, swathList, rename, exclude, &
    & notUnlimited, andGlAttributes, ReadData, HGrid, &
    & rFreqs, rLevels, rTimes, options)
    !------------------------------------------------------------------------

    ! Given MLSFiles L2GPfile1 and L2GPfile2,
    ! This routine copies all the l2gpdata from 1 to 2
    ! (see cpL2GPData_fileID)
    ! If L2GPfile2 doesn't exist yet, or if create2 is TRUE, it'll create it
    ! Optionally repairs l2gpdata
    use HGridsDatabase, only: HGrid_T
    ! Arguments

    type (L2Metadata_T) :: l2metaData
    type(MLSFile_T)               :: L2GPfile1 ! file 1
    type(MLSFile_T)               :: L2GPfile2 ! file 2
    logical, optional, intent(in) :: create2
    logical, optional, intent(in) :: andGlAttributes
    character (len=*), optional, intent(in) :: swathList ! Copy only these; '*'
    character (len=*), optional, intent(in) :: rename ! But rename them these
    character (len=*), optional, intent(in) :: exclude ! Don't copy these
    logical, optional, intent(in)           :: notUnlimited
    logical, optional, intent(in)           :: ReadData
    type (HGrid_T), optional, intent(in)    :: HGrid
    integer, dimension(2), intent(in), optional :: rFreqs  ! subscript range
    integer, dimension(2), intent(in), optional :: rLevels ! subscript range
    integer, dimension(2), intent(in), optional :: rTimes  ! subscript range
    character (len=*), optional, intent(in) :: options ! E.g., '-v'
    ! Local
    logical :: L1alreadyOpen
    logical :: L2alreadyOpen
    logical :: myCreate2
    character(len=MAXSWATHNAMESBUFSIZE) :: mySwathList
    integer :: originalAccess
    integer :: status
    !
    myCreate2 = .false.
    if ( present(create2) ) myCreate2 = create2
    mySwathList = '*'
    if ( present(swathList) ) mySwathList = swathList
    originalAccess = L2GPFile2%access
    status = 0
    L1alreadyOpen = L2GPFile1%stillOpen
    if ( L1alreadyOpen ) then
      call mls_closeFile(L2GPFile1, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to close l2gp file to cp from', MLSFile=L2GPFile1)
    endif

    status = 0
    L2alreadyOpen = L2GPFile2%stillOpen
    if ( L2alreadyOpen ) then
      if ( myCreate2 ) L2GPFile2%access = DFACC_CREATE
      call mls_closeFile(L2GPFile2, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to close l2gp file to cp to', MLSFile=L2GPFile2)
    endif
    
    call cpL2GPData_fileName(l2metaData, L2GPFile1%Name, L2GPFile2%Name, &
      & create2, L2GPFile1%hdfVersion, L2GPFile2%hdfVersion, &
      & SwathList, rename, exclude, &
      & notUnlimited, andGLAttributes, ReadData, HGrid, &
      & rFreqs, rLevels, rTimes, options)

    if ( L1alreadyOpen )  call mls_openFile(L2GPFile1, Status)
    L2GPFile1%errorCode = status
    L2GPFile1%lastOperation = 'read'

    if ( L2alreadyOpen )  call mls_openFile(L2GPFile2, Status)
    L2GPFile2%errorCode = status
    L2GPFile2%lastOperation = 'write'
    L2GPFile2%access = originalAccess

  end subroutine cpL2GPData_MLSFile

  ! ---------------------- cpL2GPDataToAttribute  ---------------------------

  subroutine cpL2GPDataToAttribute( L2GPfile1, L2GPfile2, &
    & swathname, attrname )
    !------------------------------------------------------------------------
    use HDFEOS5, only: HE5T_Native_Real
    use MLSHDFEOS, only: HE5_EhwrGlAtt, HSize

    ! Given MLSFiles L2GPfile1 and L2GPfile2,
    ! This routine copies the l2gpdata named swathname from 1 to the
    ! file level attribute named attrname in 2
    ! Arguments

    type (L2Metadata_T) :: l2metaData
    type(MLSFile_T)               :: L2GPfile1 ! file 1
    type(MLSFile_T)               :: L2GPfile2 ! file 2
    character (len=*), optional, intent(in) :: swathname ! Name to copy
    character (len=*), optional, intent(in) :: attrname ! But rename it this
    ! Local
    type (L2GPData_T) :: l2gp
    integer :: status
    !
    call ReadL2GPData ( L2GPfile1, trim(swathname), l2gp )
    if ( .not. L2GPfile2%stillOpen ) call MLS_OpenFile( L2GPfile2 )
    status = he5_ehwrglatt( L2GPfile2%fileID%f_id, &
            & trim(attrname), HE5T_NATIVE_REAL, hsize(l2gp%nTimes), &
            &  l2gp%l2gpValue(1,1,:) )
    call MLS_CloseFile( L2GPfile2 )
  end subroutine cpL2GPDataToAttribute

  ! ------------------------------------------ DiffL2GPData_CHUNKS ------------

  subroutine DiffL2GPData_CHUNKS ( fullL2gp1, fullL2gp2, Chunks, &
    & Details, options, fields, numDiffs )
    ! Diff selected chunks of an l2gp
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          FULLL2GP1
    type (l2gpData_T), intent(in) ::          FULLL2GP2
    integer, intent(in), dimension(:) :: Chunks ! Which chunks to diff
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: fields  ! diff only these fields
    integer, intent(out), optional :: numDiffs  ! how many diffs

    ! Local variables
    integer :: chunk
    ! logical, parameter :: DEEBUG = .true.
    integer :: i
    integer, dimension(2) :: irange
    type (l2gpData_T) ::          L2GP1, L2gp2
    logical :: mySilent
    ! Executable
    mySilent = .false.
    if ( present(options) ) mySilent = index(options, 'm') > 0
    if ( DEEBUG ) then
      call output( 'mySilent: ', advance='no' )
      call output( mySilent, advance='yes' )
      call output( 'size(chunks): ', advance='no' )
      call output( size(chunks), advance='yes' )
      call output( chunks, advance='yes' )
      call output( 'fullL2gp1%chunkNumber: ', advance='no' )
      call output( fullL2gp1%chunkNumber, advance='yes' )
    endif
    do i=1, size(Chunks)
      chunk = Chunks(i)
      irange(1) = FindFirst( fullL2gp1%chunkNumber, chunk )
      irange(2) = Findlast( fullL2gp1%chunkNumber, chunk )
      ! HuntRange does not work correctly when any chunk Numbers are -999
      ! (Missing Value)
      if ( any( irange == 0 ) ) cycle
      if ( .not. mySilent ) then
        call output ( ' - - - Chunk number:', advance='no')
        call output ( chunk, advance='no')
        call output ( ' - - -', advance='yes')
      endif
      call ExtractL2GPRecord ( fullL2gp1, l2gp1, rTimes=irange )
      call ExtractL2GPRecord ( fullL2gp2, l2gp2, rTimes=irange )
      call Diff ( L2gp1, L2gp2, &
         & Details, options, fields, &
         & numDiffs=numDiffs )
      call DestroyL2GPContents( l2gp1 )
      call DestroyL2GPContents( l2gp2 )
    enddo
  end subroutine DiffL2GPData_CHUNKS

  ! ------------------------------------------ DiffL2GPData_LEVELS ------------

  subroutine DiffL2GPData_LEVELS ( fullL2gp1, fullL2gp2, Pressures, Chunks, &
    & Details, options, fields, numDiffs )
    ! DDiff selected levels of an l2gp
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          FULLL2GP1
    type (l2gpData_T), intent(in) ::          FULLL2GP2
    real(rgp), intent(in), dimension(:) :: pressures ! Which levels to diff
    integer, intent(in), optional, dimension(:) :: Chunks ! Which chunks to diff
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: fields  ! diff only these fields
    integer, intent(out), optional :: numDiffs  ! how many diffs

    ! Local variables
    real(rgp) :: pressure
    ! logical, parameter :: DEEBUG = .true.
    integer :: i
    integer, dimension(2) :: irange
    type (l2gpData_T) ::          L2GP1, L2gp2
    logical :: mySilent
    ! Executable
    mySilent = .false.
    if ( present(options) ) mySilent = index(options, 'm') > 0
    if ( DEEBUG ) then
      call output( 'mySilent: ', advance='no' )
      call output( mySilent, advance='yes' )
      call output( 'size(pressures): ', advance='no' )
      call output( size(pressures), advance='yes' )
      call output( pressures, advance='yes' )
      call output( 'fullL2gp1%pressures: ', advance='no' )
      call output( fullL2gp1%pressures, advance='yes' )
    endif
    do i=1, size(pressures)
      pressure = pressures(i)
      ! The dubious "1.005" factor is to prevent missing a desired level
      ! due to unlucky roundoff
      irange(1) = FindFirst( fullL2gp1%pressures <= pressure*1.005 )
      irange(2) = irange(1)
      if ( any( irange == 0 ) ) cycle
      if ( .not. mySilent ) then
        call output ( ' - - - pressure:', advance='no')
        call output ( fullL2gp1%pressures(irange(1)), advance='no')
        call output ( ' - - -', advance='yes')
      endif
      call ExtractL2GPRecord ( fullL2gp1, l2gp1, rLevels=irange )
      call ExtractL2GPRecord ( fullL2gp2, l2gp2, rLevels=irange )
      if ( present(chunks) ) then
        call DiffL2GPData_Chunks ( L2gp1, L2gp2, chunks, &
          & Details, options, fields, numDiffs=numDiffs )
      else
        call Diff ( L2gp1, L2gp2, &
          & Details, options, fields, numDiffs=numDiffs )
      endif
      call DestroyL2GPContents( l2gp1 )
      call DestroyL2GPContents( l2gp2 )
    enddo
  end subroutine DiffL2GPData_LEVELS

  ! ------------------------------------------ DiffL2GPData_RANGES ------------

  subroutine DiffL2GPData_RANGES ( fullL2gp1, fullL2gp2, &
    & geoBoxNames, geoBoxLowBound, geoBoxHiBound, &
    & Pressures, Latitudes, Longitudes, Times, Chunks, &
    & Details, options, fields, numDiffs )
    ! Diff 2 l2gps according to prescribed ranges of pressure, longitude, etc.
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          FULLL2GP1
    type (l2gpData_T), intent(in) ::          FULLL2GP2
    character(len=*), intent(in) , optional ::       geoBoxNames
    real(rgp), dimension(:), intent(in), optional :: geoBoxLowBound  ! range
    real(rgp), dimension(:), intent(in), optional :: geoBoxHiBound  ! range
    real(rgp), intent(in), dimension(2), optional :: pressures ! range
    real(rgp), intent(in), dimension(2), optional :: latitudes ! range
    real(rgp), intent(in), dimension(2), optional :: longitudes ! range
    real(r8), intent(in), dimension(2), optional :: times ! range
    integer, intent(in), optional, dimension(:) :: Chunks ! Which chunks to diff
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: fields  ! diff only these fields
    integer, intent(out), optional :: numDiffs  ! how many diffs

    ! Local variables
    ! logical, parameter :: DEEBUG = .true.
    type (l2gpData_T) ::          L2GP1, L2gp2
    logical :: mySilent
    ! Executable
    mySilent = .false.
    if ( present(options) ) mySilent = index(options, 'm') > 0
    if ( DEEBUG ) then
      call output( 'mySilent: ', advance='no' )
      call output( mySilent, advance='yes' )
      if ( present(pressures) ) &
        & call dump( pressures, 'pressures' )
      if ( present(latitudes) ) &
        & call dump( latitudes, 'latitudes' )
      if ( present(longitudes) ) &
        & call dump( longitudes, 'longitudes' )
      call output( 'fullL2gp1%pressures: ', advance='no' )
      call output( fullL2gp1%pressures, advance='yes' )
    endif
    if ( present(geoBoxNames) ) then
      call ContractL2GPRecord ( fullL2gp1, l2gp1, &
        & geoBoxNames, geoBoxLowBound, geoBoxHiBound )
      call ContractL2GPRecord ( fullL2gp2, l2gp2, &
        & geoBoxNames, geoBoxLowBound, geoBoxHiBound )
    else
      call ContractL2GPRecord ( fullL2gp1, l2gp1, pressures=pressures, &
        & latitudes=latitudes, longitudes=longitudes, intimes=times )
      call ContractL2GPRecord ( fullL2gp2, l2gp2, pressures=pressures, &
        & latitudes=latitudes, longitudes=longitudes, intimes=times )
    endif
    if ( present(chunks) ) then
      call DiffL2GPData_Chunks ( L2gp1, L2gp2, chunks, &
        & Details, options, fields, numDiffs=numDiffs )
    else
      call Diff ( L2gp1, L2gp2, &
        & Details, options, fields, numDiffs=numDiffs )
    endif
    call DestroyL2GPContents( l2gp1 )
    call DestroyL2GPContents( l2gp2 )
  end subroutine DiffL2GPData_RANGES

  ! ---------------------- DiffL2GPData  ---------------------------
  subroutine DiffL2GPData ( L2gp1, L2gp2, &
    & Details, options, fields, matchTimes, numDiffs )
    ! Show diff between l2gp1 and l2gp2 down to level of Details
    
    ! Note:
    ! by default, print arrays of diffs, but not stats nor rms
    ! If either stats or rms, just print those, but not arrays
    ! To print stats and arrays, both, turn on wholeArrays and stats
    ! To print stats, rms, and arrays, both, turn on wholeArrays, rms, stats
    
    ! (Is this too complicated? Should we make wholeArrays always on
    !  by default unless explicitly turned off?)
    ! Dummy arguments
    type (l2gpData_T), intent(inout) ::          L2GP1
    type (l2gpData_T), intent(inout) ::          L2GP2
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: fields  ! diff only these fields
    logical, intent(in), optional :: matchTimes
    integer, intent(out), optional :: numDiffs  ! how many diffs
    ! Local variables
    integer :: how_many
    logical :: myMatchTimes
    logical :: mySilent
    type (L2GPData_T) :: cl2gp1, cl2gp2 ! Compacted l2gps
    type (L2GPData_T) :: tl2gp1, tl2gp2 ! Synchronized l2gps
    integer, dimension(MAXNUMTIMES) :: which1, which2
    integer :: i
    ! Executable
    myMatchTimes = .false.
    if ( present(matchTimes) ) mymatchTimes = matchTimes
    mySilent = .false.
    if ( present(options) ) mySilent = index(options, 'm') > 0
    if ( present(numDiffs) ) numDiffs = 0
    if ( DEEBUG ) call outputNamedValue( 'match times?', myMatchTimes )
    if ( myMatchTimes .or. L2gp1%nTimes /= L2gp2%nTimes ) then
      call CompactL2GPRecord ( L2gp1, cL2gp1 )
      call CompactL2GPRecord ( L2gp2, cL2gp2 )
      ! 1st, find which profile times match (to within 0.1 s)
      call FindIntersection( cl2gp1%time, cl2gp2%time, which1, which2, how_many, &
        & tol=1.d-1 )
      if ( .not. mySilent ) then
        ! call dump( cl2gp1 )
        ! call dump( cl2gp2 )
        call OutputNamedValue ( 'how many times matched', how_many )
        call dump( which1(1:how_many), 'which1' )
        call dump( which2(1:how_many), 'which2' )
        do i = 1, how_many
          write(*,*) timeToHoursInDay ( cl2gp1%time(which1(i)) ), &
            & timeToHoursInDay ( cl2gp2%time(which2(i)) )
        enddo
      endif
      if ( how_many == 0 ) then
        ! 2nd chance--try to match Geod. Ang. to within 1/2 deg.
        if ( .not. mySilent ) call output( &
          & 'No matching times found in l2gp1, l2gp2', advance='yes' )
        call FindIntersection( cl2gp1%GeodAngle, cl2gp2%GeodAngle, which1, which2, how_many, &
          & tol=0.5 )
        if ( how_many == 0 ) then
          if ( .not. mySilent ) call output( &
            & 'No matching geod. angs found in l2gp1, l2gp2', advance='yes' )
          return
        endif
      endif
      call SetupNewL2GPRecord ( tl2gp1, proto=cl2gp1, which=which1(1:how_many) )
      call SetupNewL2GPRecord ( tl2gp2, proto=cl2gp2, which=which2(1:how_many) )
      if ( DEEBUG ) print *, 'About to enter ..atLast having matched times'
      call DiffThis ( tL2gp1, tL2gp2, &
      & Details, options, fields, numDiffs )
      call DestroyL2GPContents( cL2gp1 )
      call DestroyL2GPContents( cL2gp2 )
      call DestroyL2GPContents( tL2gp1 )
      call DestroyL2GPContents( tL2gp2 )
    else
      if ( DEEBUG ) print *, 'Diffing as we found them'
      call DiffThis ( L2gp1, L2gp2, &
      & Details, options, fields, numDiffs )
    endif
  end subroutine DiffL2GPData

  ! ---------------------- DiffThis  ---------------------------
  subroutine DiffThis ( L2gp1, L2gp2, &
    & Details, options, fields, numDiffs )
    ! Show diff between l2gp1 and l2gp2 down to level of Details
    
    ! Note:
    ! by default, print arrays of diffs, but not stats nor rms
    ! If either stats or rms, just print those, but not arrays
    ! To print stats and arrays, both, turn on wholeArrays and stats
    ! To print stats, rms, and arrays, both, turn on wholeArrays, rms, stats
    
    ! (Is this too complicated? Should we make wholeArrays always on
    !  by default unless explicitly turned off?)
    ! Dummy arguments
    type (l2gpData_T), intent(inout) ::          L2GP1
    type (l2gpData_T), intent(inout) ::          L2GP2
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: fields  ! diff only these fields
    integer, intent(out), optional :: numDiffs  ! how many diffs
    ! Local variables
    logical :: badChunks              ! Are any chunks bad?
    logical :: badChunksDifferent     ! Are any chunks bad in one l2gp not bad in the other?
    integer :: badInstances
    character(len=*), parameter :: DEFAULTFIELDS = &
      & 'pressure, lat, lon, solarTime, solarZenith,' // &
      & 'losAngle, geodAngle, time, chunkNumber, freq,'  // &
      & 'l2gpvalue, l2gpPrecision, status, quality, convergence, AscDescMode '
    ! logical, parameter :: DEEBUG = .true.
    logical :: diffGeosMeanBadChunks
    logical :: fillsInL2GP1
    logical :: fillsInL2GP2
    logical :: goldbrick
    integer :: instance
    type (l2gpData_T) ::          L2GP2Temp
    integer :: MYDETAILS
    character(len=len(DEFAULTFIELDS)) :: myFields
    integer :: myNumDiffs
    logical :: mySilent
    logical :: myVerbose
    logical :: ShapesDontMatch
    logical :: skipGeos
    logical :: ForceThrough
    ! Executable code
    nameOnEachLine = ' '
    if ( .not. isL2GPSetUp(l2gp1) ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, & 
        'l2gp1 not yet allocated in diff')
      return
    elseif ( .not. isL2GPSetUp(l2gp2) ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, & 
        'l2gp2 not yet allocated in diff')
      return
    endif
    myDetails = 1
    if ( present(details) ) myDetails = details
    mySilent = .false.
    if ( present(options) ) mySilent = index(options, 'm') > 0
    if ( mySilent ) call suspendOutput
    myVerbose = .false.
    if ( present(options) ) myVerbose = index(options, 'v') > 0
    goldbrick = .false.
    if ( present(options) ) goldbrick = index(options, '@@') > 0
    ForceThrough = .false.
    if ( present(options) ) ForceThrough = index(options, 'F') > 0

    myNumDiffs = 0

    ShapesDontMatch = .false.
    badChunks = .false.
    badInstances = 0
    diffGeosMeanBadChunks = .false.
    myFields = DEFAULTFIELDS
    skipGeos = .false.
    if ( present(fields) ) myFields = fields
                                                                              
    if ( present ( options ) ) then                                           
      if ( DEEBUG ) call output( 'options: ' // trim(options), advance='yes' )
      badChunks = (index(options, 'i' ) > 0) .and. badChunks                  
      diffGeosMeanBadChunks = ( index(options, 'd') > 0 )                     
      skipGeos = ( index(options, 'g') > 0 )                                  
    else                                                                      
      badChunks = .false.                                                     
    endif                                                                     

    if ( DEEBUG ) then                                                        
      call output( 'myDetails: ', advance='no' )
      call output( myDetails, advance='yes' )
      call output( 'mySilent: ', advance='no' )
      call output( mySilent, advance='yes' )
      call output( 'myFields: ', advance='no' )
      call output( myFields, advance='yes' )   
      call output( 'skipGeos: ', advance='no' )
      call output( skipGeos, advance='yes' )   
      call output( 'myVerbose: ', advance='no' )
      call output( myVerbose, advance='yes' )   
    endif
    if ( myFields == '*' .or. lowercase(myFields) == 'all' ) &
      & myFields = DEFAULTFIELDS
    if ( DEEBUG ) then
      call output( 'myFields: ', advance='no' )
      call output( myFields, advance='yes' )
    endif
    if ( trim(l2gp1%name) /= trim(l2gp2%name) ) then
      call output('(1) name: ' // trim(l2gp1%name), advance='yes')
      call output('(2) name: ' // trim(l2gp2%name), advance='yes')
      myNumDiffs = myNumDiffs + 1
    endif
    if ( myDetails < -1 ) then
      call doneHere
      return
    endif
    if ( L2gp1%MissingL2GP /= L2gp2%MissingL2GP ) then
      call output(' (1) MissingL2GP = ', advance='no')
      call output(L2gp1%Missingl2GP, advance='yes')
      call output(' (2) Missingl2GP = ', advance='no')
      call output(L2gp2%MissingL2GP, advance='yes')
      myNumDiffs = myNumDiffs + 1
    endif
    if ( L2gp1%MissingValue /= L2gp2%MissingValue ) then
      call output(' (1) MissingValue = ', advance='no')
      call output(L2gp1%MissingValue, advance='yes')
      call output(' (2) MissingValue = ', advance='no')
      call output(L2gp2%MissingValue, advance='yes')
      myNumDiffs = myNumDiffs + 1
    endif
    if ( L2gp1%nTimes /= L2gp2%nTimes ) then
      call output(' (1) nTimes = ', advance='no')
      call output(L2gp1%nTimes, advance='yes')
      call output(' (2) nTimes = ', advance='no')
      call output(L2gp2%nTimes, advance='yes')
      ShapesDontMatch = .true.
      myNumDiffs = myNumDiffs + 1
    endif
    if ( L2gp1%nLevels /= L2gp2%nLevels ) then
      call output(' (1) nLevels = ', advance='no')
      call output(L2gp1%nLevels, advance='yes')
      call output(' (2) nLevels = ', advance='no')
      call output(L2gp2%nLevels, advance='yes')
      ShapesDontMatch = .true.
      myNumDiffs = myNumDiffs + 1
    endif
    if ( L2gp1%nFreqs /= L2gp2%nFreqs ) then
      call output(' (1) nFreqs = ', advance='no')
      call output(L2gp1%nFreqs, advance='yes')
      call output(' (2) nFreqs = ', advance='no')
      call output(L2gp2%nFreqs, advance='yes')
      ShapesDontMatch = .true.
      myNumDiffs = myNumDiffs + 1
    endif
    if ( myDetails < 0 )  then
      if ( myVerbose ) &
        & call output ( '(Data shapes and swath names match)', advance='yes' )
      call doneHere
      return
    endif
    if ( ShapesDontMatch  ) then
      if ( ForceThrough ) then
        call output('Some fields wont be diffed because shapes dont match',&
          & advance='yes')
      else
        call output('Skipping further details because shapes dont match',&
          & advance='yes')
        call doneHere
        return
      endif
    endif

    badChunks = badChunks .or. &
      & ( &
      & any( mod ( l2gp1%status, 2 ) == 1 ) &
      & .or. &
      & any( mod ( l2gp2%status, 2 ) == 1 ) &
      & .or. &
      & any( IsFillValue ( l2gp1%l2gpValue, l2gp1%MissingL2GP ) ) &
      & .or. &
      & any( IsFillValue ( l2gp2%l2gpValue, l2gp2%MissingL2GP ) ) &
      & )
    ! OK, we'll try what you suggest
    call SetupNewL2GPRecord ( l2gp2Temp, proto=l2gp2 )
    l2gp2Temp%status = l2gp2%status
    if ( diffGeosMeanBadChunks ) then
      do instance=1, L2gp1%nTimes
        if ( l2gp1%geodAngle(instance) /= l2gp2%geodAngle(instance) &
          & .or. &
          & l2gp1%solarZenith(instance) /= l2gp2%solarZenith(instance) &
          & .or. &
          & l2gp1%time(instance) /= l2gp2%time(instance) ) &
          & l2gp2Temp%status(instance) = -1
      enddo
    endif
    badChunksDifferent = .false.
    if ( badChunks ) then
      do instance=1, L2gp1%nTimes
        fillsInL2GP1 = any( &
          & IsFillValue ( l2gp1%l2gpValue(:,:,instance), l2gp1%MissingL2GP ) &
          & )
        fillsInL2GP2 = any( &
          & IsFillValue ( l2gp2%l2gpValue(:,:,instance), l2gp2%MissingL2GP ) &
          & )
        if  ( l2gp2Temp%status(instance) < 0 &
          & .or. &
          & mod(l2gp1%status(instance), 2) == 1 &
          & .or. &
          & mod(l2gp2%status(instance), 2) == 1 &
          & .or. &
          & fillsInL2GP1 &
          & .or. &
          & fillsInL2GP2 &
          & ) then
          badChunksDifferent = badChunksDifferent .or. &
            mod(l2gp1%status(instance), 2) /= mod(l2gp2%status(instance), 2) &
            & .or. &
            & fillsInL2GP1 .neqv. fillsInL2GP2
          l2gp2Temp%l2gpValue(:,:,instance) = l2gp1%l2gpValue(:,:,instance)
          l2gp2Temp%l2gpPrecision(:,:,instance) = l2gp1%l2gpPrecision(:,:,instance)
          l2gp2Temp%status(instance) = l2gp1%status(instance)
          l2gp2Temp%quality(instance) = l2gp1%quality(instance)
          l2gp2Temp%convergence(instance) = l2gp1%convergence(instance)
          if ( AscDescModeIsField ) &
            & l2gp2Temp%AscDescMode(instance) = l2gp1%AscDescMode(instance)
          ! Also geolocations will be reset to avoid displaying bogus diffs
          l2gp2Temp%latitude(instance) = l2gp1%latitude(instance)
          l2gp2Temp%longitude(instance) = l2gp1%longitude(instance)
          l2gp2Temp%solarTime(instance) = l2gp1%solarTime(instance)
          l2gp2Temp%chunkNumber(instance) = l2gp1%chunkNumber(instance)
          l2gp2Temp%geodAngle(instance) = l2gp1%geodAngle(instance)
          l2gp2Temp%solarZenith(instance) = l2gp1%solarZenith(instance)
          l2gp2Temp%time(instance) = l2gp1%time(instance)
          l2gp2Temp%losAngle(instance) = l2gp1%losAngle(instance)
          badInstances = badInstances + 1
        endif
      enddo
      if ( badChunksDifferent ) then
        call output('Number of bad instances of l2gp2 reset to l2gp1 ', advance='no')
        call output(badInstances, advance='yes')
      endif
    endif

    if ( .not. skipGeos ) then
      ! call output( 'calling diffGeoLocations', advance='yes' )
      ! call outputNamedValue( 'nameOnEachLine', trim(nameOnEachLine) )
      call diffGeoLocations( l2gp1, l2gp2Temp )
      ! call Dump ( l2gp1%pressures, 'l2gp1 pressures' )
      ! call Dump ( l2gp2Temp%pressures, 'l2gp2 pressures' )
    endif
    if ( myDetails < 1 .or. ShapesDontMatch )  then
      call doneHere
      return
    endif

    NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%values', ' ', statsOnOneLine )
    if ( any(l2gp1%l2gpValue /= l2gp2Temp%l2gpValue) .and. &
      & SwitchDetail(lowercase(myFields), 'l2gpvalue', '-fc') > -1 ) then
      call diff ( l2gp1%l2gpValue, 'l2gp%l2gpValue', &
        &         l2gp2Temp%l2gpValue, ' ', &
        & options=options, fillValue=l2gp1%MissingL2GP )
      myNumDiffs = myNumDiffs + count( l2gp1%l2gpValue /= l2gp2Temp%l2gpValue )
    elseif ( all(l2gp1%l2gpValue == l2gp2Temp%l2gpValue) .and. &
      & SwitchDetail(lowercase(myFields), 'l2gpvalue', '-fc') > -1 .and. myVerbose ) then
      call output('(values fields equal)', advance='yes')
    endif
!     print *, '(lowercase(myFields): ', trim(lowercase(myFields))
!     print *, SwitchDetail(lowercase(myFields), 'l2gpprecision', '-fc')
!     print *, SwitchDetail(lowercase(myFields), 'status', '-fc')
!     print *, SwitchDetail(lowercase(myFields), 'quality', '-fc')
!     print *, SwitchDetail(lowercase(myFields), 'convergence', '-fc')
    NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%Precisions', ' ', statsOnOneLine )
    if ( any(l2gp1%l2gpPrecision /= l2gp2Temp%l2gpPrecision) .and. &
      & SwitchDetail(lowercase(myFields), 'l2gpprecision', '-fc') > -1 ) then
      call diff ( l2gp1%l2gpPrecision, 'l2gpPrecision', &
        &         l2gp2Temp%l2gpPrecision, ' ', &
        & options=options, fillValue=l2gp1%MissingValue )
      myNumDiffs = myNumDiffs + count( l2gp1%l2gpPrecision /= l2gp2Temp%l2gpPrecision )
    elseif ( all(l2gp1%l2gpPrecision == l2gp2Temp%l2gpPrecision) .and. &
      & SwitchDetail(lowercase(myFields), 'l2gpprecision', '-fc') > -1 .and. myVerbose ) then
      call output('(precision fields equal)', advance='yes')
    endif

    NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%status', ' ', statsOnOneLine )
    if ( any(l2gp1%status /= l2gp2Temp%status) .and. &
      & SwitchDetail(lowercase(myFields), 'status', '-fc') > -1 ) then
      call diff ( l2gp1%status, 'status', &
        &         l2gp2Temp%status, ' ', &
        & options=options )
      myNumDiffs = myNumDiffs + count( l2gp1%status /= l2gp2Temp%status )
    elseif ( all(l2gp1%status == l2gp2Temp%status) .and. &
      & SwitchDetail(lowercase(myFields), 'status', '-fc') > -1 .and. myVerbose ) then
      call output('(status fields equal)', advance='yes')
    endif

    NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%quality', ' ', statsOnOneLine )
    if ( any(l2gp1%quality /= l2gp2Temp%quality) .and. &
      & SwitchDetail(lowercase(myFields), 'quality', '-fc') > -1 ) then
      call diff ( l2gp1%quality, 'quality', &
        &         l2gp2Temp%quality, ' ', &
        & options=options )
      myNumDiffs = myNumDiffs + count( l2gp1%quality /= l2gp2Temp%quality )
    elseif ( all(l2gp1%quality == l2gp2Temp%quality) .and. &
      & SwitchDetail(lowercase(myFields), 'quality', '-fc') > -1 .and. myVerbose ) then
      call output('(quality fields equal)', advance='yes')
    endif

    NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%convergence', ' ', statsOnOneLine )
    if ( any(l2gp1%convergence /= l2gp2Temp%convergence) .and. &
      & SwitchDetail(lowercase(myFields), 'convergence', '-fc') > -1 ) then
      call diff ( l2gp1%convergence, 'convergence', &
        &         l2gp2Temp%convergence, ' ', &
        & options=options )
      myNumDiffs = myNumDiffs + count( l2gp1%convergence /= l2gp2Temp%convergence )
    elseif ( all(l2gp1%convergence == l2gp2Temp%convergence) .and. &
      & SwitchDetail(lowercase(myFields), 'convergence', '-fc') > -1 .and. myVerbose ) then
      call output('(convergence fields equal)', advance='yes')
    endif
    call doneHere
    return

  contains
    subroutine diffGeoLocations( l2gp1, l2gp2 )
      ! Args
      type(L2GPData_T)            :: l2gp1
      type(L2GPData_T)            :: l2gp2
      logical                     :: AnyDiffs
      logical                     :: DiffUs
      logical, parameter          :: NoteWhenEqual = .true.
      ! Executable
!       print *, 'In diffGeoLocations'
!       print *, SwitchDetail(lowercase(myFields), 'pressure', '-fc') > -1
!       print *, SwitchDetail(lowercase(myFields), 'lat', '-fc') > -1
!       print *, SwitchDetail(lowercase(myFields), 'lon', '-fc') > -1
!       print *, SwitchDetail(lowercase(myFields), 'solarTime', '-fc') > -1
!       print *, SwitchDetail(lowercase(myFields), 'solarZenith', '-fc') > -1
!       print *, SwitchDetail(lowercase(myFields), 'losAngle', '-fc') > -1
!       print *, SwitchDetail(lowercase(myFields), 'geodAngle', '-fc') > -1
!       print *, SwitchDetail(lowercase(myFields), 'time', '-fc') > -1
      AnyDiffs = .false.
      if ( all(shape(l2gp1%pressures) == shape(l2gp2%pressures)) ) then
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%pressure', ' ', statsOnOneLine )
        DiffUs = SwitchDetail(lowercase(myFields), 'pressure', '-fc') > -1
        if ( any(l2gp1%pressures /= l2gp2%pressures) ) &
          & then
            if ( DiffUs ) call diff ( l2gp1%pressures, 'l2gp%pressures', &
              &         l2gp2%pressures, ' ', &
              & options=options )
          myNumDiffs = myNumDiffs + count( l2gp1%pressures /= l2gp2%pressures )
          AnyDiffs = .true.
        elseif( NoteWhenEqual .and. DiffUs ) then
          call output('(pressure fields equal)', advance='yes')
        endif
      endif
      if ( all(shape(l2gp1%latitude) == shape(l2gp2%latitude)) ) then
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%latitude', ' ', statsOnOneLine )
        DiffUs = SwitchDetail(lowercase(myFields), 'lat', '-fc') > -1
        if ( any(l2gp1%latitude /= l2gp2%latitude) ) &
          & then
            if ( DiffUs ) call diff ( l2gp1%latitude, 'l2gp%latitude', &
              &         l2gp2%latitude, ' ', &
              & options=options )
          myNumDiffs = myNumDiffs + count( l2gp1%latitude /= l2gp2%latitude )
          AnyDiffs = .true.
        elseif( NoteWhenEqual .and. DiffUs ) then
          call output('(latitude fields equal)', advance='yes')
        endif
      endif
      if ( all(shape(l2gp1%longitude) == shape(l2gp2%longitude)) ) then
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%longitude', ' ', statsOnOneLine )
        DiffUs = SwitchDetail(lowercase(myFields), 'lon', '-fc') > -1
        if ( any(l2gp1%longitude /= l2gp2%longitude) ) &
          & then
            if ( DiffUs ) call diff ( l2gp1%longitude, 'l2gp%longitude', &
              &         l2gp2%longitude, ' ', &
              & options=options )
          myNumDiffs = myNumDiffs + count( l2gp1%longitude /= l2gp2%longitude )
          AnyDiffs = .true.
        elseif( NoteWhenEqual .and. DiffUs ) then
          call output('(longitude fields equal)', advance='yes')
        endif
      endif
      if ( all(shape(l2gp1%solarTime) == shape(l2gp2%solarTime)) ) then
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%solarTime', ' ', statsOnOneLine )
        DiffUs = SwitchDetail(lowercase(myFields), 'solartime', '-fc') > -1
        if ( any(l2gp1%solarTime /= l2gp2%solarTime) ) &
          & then
            if ( DiffUs ) call diff ( l2gp1%solarTime, 'l2gp%solarTime', &
              &         l2gp2%solarTime, ' ', &
              & options=options )
          myNumDiffs = myNumDiffs + count( l2gp1%solarTime /= l2gp2%solarTime )
          AnyDiffs = .true.
        elseif( NoteWhenEqual .and. DiffUs ) then
          call output('(solarTime fields equal)', advance='yes')
        endif
      endif
      if ( all(shape(l2gp1%solarZenith) == shape(l2gp2%solarZenith)) ) then
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%solarZenith', ' ', statsOnOneLine )
        DiffUs = SwitchDetail(lowercase(myFields), 'solarzenith', '-fc') > -1
        if ( any(l2gp1%solarZenith /= l2gp2%solarZenith) ) &
          & then
            if ( DiffUs ) call diff ( l2gp1%solarZenith, 'l2gp%solarZenith', &
              &         l2gp2%solarZenith, ' ', &
              & options=options )
          myNumDiffs = myNumDiffs + count( l2gp1%solarZenith /= l2gp2%solarZenith )
          AnyDiffs = .true.
        elseif( NoteWhenEqual .and. DiffUs ) then
          call output('(solarZenith fields equal)', advance='yes')
        endif
      endif
      if ( all(shape(l2gp1%losAngle) == shape(l2gp2%losAngle)) ) then
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%losAngle', ' ', statsOnOneLine )
        DiffUs = SwitchDetail(lowercase(myFields), 'losangle', '-fc') > -1
        if ( any(l2gp1%losAngle /= l2gp2%losAngle) ) &
          & then
            if ( DiffUs ) call diff ( l2gp1%losAngle, 'l2gp%losAngle', &
              &         l2gp2%losAngle, ' ', &
              & options=options )
          myNumDiffs = myNumDiffs + count( l2gp1%losAngle /= l2gp2%losAngle )
          AnyDiffs = .true.
        elseif( NoteWhenEqual .and. DiffUs ) then
          call output('(losAngle fields equal)', advance='yes')
        endif
      endif
      if ( all(shape(l2gp1%geodAngle) == shape(l2gp2%geodAngle)) ) then
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%geodAngle', ' ', statsOnOneLine )
        DiffUs = SwitchDetail(lowercase(myFields), 'geodangle', '-fc') > -1
        if ( any(l2gp1%geodAngle /= l2gp2%geodAngle) ) &
          & then
            if ( DiffUs ) call diff ( l2gp1%geodAngle, 'l2gp%geodAngle', &
              &         l2gp2%geodAngle, ' ', &
              & options=options )
          myNumDiffs = myNumDiffs + count( l2gp1%geodAngle /= l2gp2%geodAngle )
          AnyDiffs = .true.
        elseif( NoteWhenEqual .and. DiffUs ) then
          call output('(geodAngle fields equal)', advance='yes')
        endif
      endif
      if ( all(shape(l2gp1%time) == shape(l2gp2%time)) ) then
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%time', ' ', statsOnOneLine )
        DiffUs = SwitchDetail(lowercase(myFields), 'time', '-fc') > -1
        if ( any(l2gp1%time /= l2gp2%time) ) &
          & then
            if ( DiffUs ) call diff ( l2gp1%time, 'l2gp%time', &
              &         l2gp2%time, ' ', &
              & options=options )
          myNumDiffs = myNumDiffs + count( l2gp1%time /= l2gp2%time )
          AnyDiffs = .true.
        elseif( NoteWhenEqual .and. DiffUs ) then
          call output('(time fields equal)', advance='yes')
        endif
      endif
      if ( all(shape(l2gp1%chunkNumber) == shape(l2gp2%chunkNumber)) ) then
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%chunkNumber', ' ', statsOnOneLine )
        DiffUs = SwitchDetail(lowercase(myFields), 'chunkNumber', '-fc') > -1
        if ( any(l2gp1%chunkNumber /= l2gp2%chunkNumber) ) &
          & then
            if ( DiffUs ) call diff ( l2gp1%chunkNumber, 'l2gp%chunkNumber', &
              &         l2gp2%chunkNumber, ' ', &
              & options=options )
          myNumDiffs = myNumDiffs + count( l2gp1%chunkNumber /= l2gp2%chunkNumber )
          AnyDiffs = .true.
        elseif( NoteWhenEqual .and. DiffUs ) then
          call output('(chunkNumber fields equal)', advance='yes')
        endif
      endif
      
      if ( associated(l2gp1%frequency) .and.  associated(l2gp2%frequency)) then
      if ( all(shape(l2gp1%frequency) == shape(l2gp2%frequency)) ) then
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%frequency', ' ', statsOnOneLine )
        DiffUs = SwitchDetail(lowercase(myFields), 'freq', '-fc') > -1
        if ( any(l2gp1%frequency /= l2gp2%frequency) ) &
          & then
            if ( DiffUs ) call diff ( l2gp1%frequency, 'l2gp%frequency', &
              &         l2gp2%frequency, ' ', &
              & options=options )
          myNumDiffs = myNumDiffs + count( l2gp1%frequency /= l2gp2%frequency )
          AnyDiffs = .true.
        elseif( NoteWhenEqual .and. DiffUs ) then
          call output('(frequency fields equal)', advance='yes')
        endif
      endif
      endif

      DiffUs = SwitchDetail(lowercase(myFields), 'geoloc', '-fc') > -1
      if ( NoteWhenEqual .and. DiffUs .and. .not. AnyDiffs ) &
        & call output('(all geolocation fields equal)', advance='yes')

    end subroutine diffGeoLocations

    subroutine doneHere
      ! Housekeeping
      ! Done with the temporary, so deallocate it before returning
      call DestroyL2GPContents ( L2GP2Temp )
      
      call resumeOutput
      if ( present(numDiffs) ) numDiffs = myNumDiffs
      nameOnEachLine = ' '
    end subroutine doneHere
    
    function AddOntoOptions( addOn, options) result(newOptions)
      character(len=*), intent(in)           :: AddOn
      character(len=*), optional, intent(in) :: options
      character(len=16)                      :: newOptions
      newOptions = AddOn
      if ( .not. present(options) ) return
      if ( len_trim(options) < 1 ) return
      newOptions = trim(options) // addOn
    end function AddOntoOptions
  end subroutine DiffThis
    
  ! ------------------------------------------ DiffL2GPFiles_MLSFile ------------
  subroutine DiffL2GPFiles_MLSFile ( L2GPFile1, L2GPFile2, &
    & geoBoxNames, geoBoxLowBound, geoBoxHiBound, pressures, chunks, &
    & Details, options, &
    & swList, showMissing, fields, force, swaths1, swaths2, &
    & matchTimes, numDiffs )
    ! Show diff between swaths in file1 and file2 down to level of Details
    ! Dummy arguments
    type(MLSFile_T)               :: L2GPfile1 ! file 1
    type(MLSFile_T)               :: L2GPfile2 ! file 2
    real, intent(in), dimension(:), optional :: pressures ! Which heights to dump
    integer, intent(in), dimension(:), optional :: Chunks ! Which chunks to dump
    character(len=*), intent(in) , optional ::       geoBoxNames
    real(rgp), dimension(:), intent(in), optional :: geoBoxLowBound  ! range
    real(rgp), dimension(:), intent(in), optional :: geoBoxHiBound  ! range
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    !
    ! The following parameters, if present, will override Details
    character(len=*), intent(in), optional :: options
    ! swList currently used only if showMissing is TRUE
    character (len=*), optional, intent(in) :: swList
    logical, intent(in), optional :: showMissing   ! if TRUE, just show which
    character(len=*), intent(in), optional :: fields  ! only these fields
    character(len=*), intent(in), optional :: swaths1  ! only these swaths
    character(len=*), intent(in), optional :: swaths2  ! only these swaths
    logical, intent(in), optional :: FORCE ! Force diff even if swathnames differ
    logical, intent(in), optional :: matchTimes  ! only matching profile times
    integer, intent(out), optional :: numDiffs  ! how many diffs
    ! Local                                         swaths are missing from other
    logical :: L1alreadyOpen
    logical :: L2alreadyOpen
    integer :: status
    !
    L1alreadyOpen = L2GPFile1%stillOpen
    if ( L1alreadyOpen ) then
      call mls_closeFile(L2GPFile1, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to close l2gp file to diff between', MLSFile=L2GPFile1)
    endif
    !
    L2alreadyOpen = L2GPFile2%stillOpen
    if ( L2alreadyOpen ) then
      call mls_closeFile(L2GPFile2, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to close l2gp file to diff between', MLSFile=L2GPFile2)
    endif
    
    if ( present(geoBoxNames) ) then
      call DiffL2GPFiles_Name ( L2GPFile1%Name, L2GPFile2%Name, &
      & geoBoxNames=geoBoxNames, &
      & geoBoxLowBound=geoBoxLowBound, geoBoxHiBound=geoBoxHiBound, &
      & Details=Details, options=options, &
      & swList=swList, showMissing=showMissing, &
      & fields=fields, force=force, swaths1=swaths1, swaths2=swaths2, &
      & matchTimes=matchTimes, &
      & numDiffs=numDiffs )
    elseif ( present(chunks) .and. present(pressures) ) then
      call DiffL2GPFiles_Name ( L2GPFile1%Name, L2GPFile2%Name, &
      & pressures=pressures, &
      & chunks=chunks, Details=Details, options=options, &
      & swList=swList, showMissing=showMissing, &
      & fields=fields, force=force, swaths1=swaths1, swaths2=swaths2, &
      & matchTimes=matchTimes, &
      & numDiffs=numDiffs )
    elseif ( present(chunks) ) then
      call DiffL2GPFiles_Name ( L2GPFile1%Name, L2GPFile2%Name, &
      & chunks=chunks, Details=Details, options=options, &
      & swList=swList, showMissing=showMissing, &
      & fields=fields, force=force, swaths1=swaths1, swaths2=swaths2, &
      & matchTimes=matchTimes, &
      & numDiffs=numDiffs )
    elseif ( present(pressures) ) then
      call DiffL2GPFiles_Name ( L2GPFile1%Name, L2GPFile2%Name, &
      & pressures=pressures, Details=Details, options=options, &
      & swList=swList, showMissing=showMissing, &
      & fields=fields, force=force, swaths1=swaths1, swaths2=swaths2, &
      & matchTimes=matchTimes, &
      & numDiffs=numDiffs )
    else
      call DiffL2GPFiles_Name ( L2GPFile1%Name, L2GPFile2%Name, &
      & Details=Details, options=options, &
      & swList=swList, showMissing=showMissing, &
      & fields=fields, force=force, swaths1=swaths1, swaths2=swaths2, &
      & matchTimes=matchTimes, &
      & numDiffs=numDiffs )
    endif

    if ( L1alreadyOpen )  call mls_openFile(L2GPFile1, Status)
    L2GPFile1%errorCode = status
    L2GPFile1%lastOperation = 'read'

    if ( L2alreadyOpen )  call mls_openFile(L2GPFile2, Status)
    L2GPFile2%errorCode = status
    L2GPFile2%lastOperation = 'read'

  end subroutine DiffL2GPFiles_MLSFile
    
  ! ------------------------------------------ DiffL2GPFiles_Name ------------
  subroutine DiffL2GPFiles_Name ( file1, file2, &
    & geoBoxNames, geoBoxLowBound, geoBoxHiBound, pressures, chunks, &
    & Details, options, &
    & swList, showMissing, fields, force, swaths1, swaths2, matchTimes, &
    &  numDiffs )
    ! Show diff between swaths in file1 and file2 down to level of Details
    ! Dummy arguments
    character (len=*), intent(in) :: file1 ! Name of file 1
    character (len=*), intent(in) :: file2 ! Name of file 2
    real, intent(in), dimension(:), optional :: pressures ! Which heights to diff
    integer, intent(in), dimension(:), optional :: Chunks ! Which chunks to diff
    character(len=*), intent(in) , optional ::       geoBoxNames
    real(rgp), dimension(:), intent(in), optional :: geoBoxLowBound  ! range
    real(rgp), dimension(:), intent(in), optional :: geoBoxHiBound  ! range
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    !
    ! The following parameters, if present, will override Details
    character(len=*), intent(in), optional :: options
    ! swList currently used only if showMissing is TRUE
    character (len=*), optional, intent(in) :: swList
    logical, intent(in), optional :: showMissing   ! if TRUE, just show which
    character(len=*), intent(in), optional :: fields  ! only these fields
    character(len=*), intent(in), optional :: swaths1  ! only these swaths
    character(len=*), intent(in), optional :: swaths2  ! only these swaths
    logical, intent(in), optional :: FORCE ! Force diff even if swathnames differ
    logical, intent(in), optional :: matchTimes  ! only matching profile times
    integer, intent(out), optional :: numDiffs  ! how many diffs
    ! Local                                         swaths are missing from other
    logical, parameter            :: countEmpty = .true.
    logical :: file_exists
    integer :: File1Handle
    integer :: File2Handle
    integer :: i
    type (L2GPData_T) :: l2gp1
    type (L2GPData_T) :: l2gp2
    integer :: listsize
    type(MLSFile_T)                :: MLSFile1, MLSFile2
    logical :: myForce
    integer :: myNumDiffs
    logical :: myShowMissing
    logical :: mySilent
    integer :: noSwaths
    integer :: noSwaths2
    integer :: noUnique
    integer :: status
    character (len=L2GPNameLen) :: swath
    character (len=L2GPNameLen) :: swath2
    character (len=MAXSWATHNAMESBUFSIZE) :: swathList1
    character (len=MAXSWATHNAMESBUFSIZE) :: swathList2
    character (len=MAXSWATHNAMESBUFSIZE) :: swathUnique
    integer :: the_hdfVersion1
    integer :: the_hdfVersion2
    ! Executable code
    myNumDiffs = 0
    myShowMissing = .false.
    if ( present(showMissing) ) myShowMissing=showMissing
    file_exists = ( mls_exists(trim(File1)) == 0 )
    if ( .not. file_exists ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'File 1 not found; make sure the name and path are correct' &
        & // trim(file1) )
    endif
    myForce = .false.
    if ( present(force) ) myForce = force
    mySilent = .false.
    if ( present(options) ) mySilent = index(options, 'm') > 0

    the_hdfVersion1 = mls_hdf_version(File1)
    the_hdfVersion2 = mls_hdf_version(File2)
    file_exists = ( mls_exists(trim(File2)) == 0 )
    if ( .not. file_exists ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'File 2 not found; make sure the name and path are correct' &
        & // trim(file1) )
    endif
    the_hdfVersion2 = mls_hdf_version(File2)
    noSwaths = mls_InqSwath ( file1, swathList1, listSize, &
         & hdfVersion=the_hdfVersion1)
    noSwaths2 = mls_InqSwath ( file2, swathList2, listSize, &
         & hdfVersion=the_hdfVersion2)
    if ( present(swaths1) ) then
      if ( swaths1 /= 'all' .and. swaths1 /= '*' ) then
        swathList1 = swaths1
        noSwaths = NumStringElements( swaths1, countEmpty=.true. )
        swathList2 = swathList1
      endif
    endif
    if ( present(swaths2) ) then
      if ( swaths2 /= 'all' .and. swaths2 /= '*' ) then
        swathList2 = swaths2
        noSwaths2 = NumStringElements( swaths2, countEmpty=.true. )
      endif
    endif
    ! Are we merely to point out which swaths are missing from the other file?
    if ( myShowMissing ) then
      if ( present(swList) ) then
        call GetUniqueList( swList, swathUnique, noUnique, &
          & str2=trim(swathList1), options='-e' )
        if ( noUnique > 0 ) then
          call output('swaths missing from ' // trim(File1), advance='yes')
          call output(trim(swathUnique), advance='yes')
        else
          call output('All swaths in ' // trim(File1), advance='yes')
        endif
        call GetUniqueList( swList, swathUnique, noUnique, &
          & str2=trim(swathList2), options='-e' )
        if ( noUnique > 0 ) then
          call output('swaths missing from ' // trim(File2), advance='yes')
          call output(trim(swathUnique), advance='yes')
        else
          call output('All swaths in ' // trim(File2), advance='yes')
        endif
      else
        call output('Comparing swaths in ' // trim(File1), advance='no')
        call output(' with ' // trim(File2), advance='yes')
        call GetUniqueList( trim(swathList1), swathUnique, noUnique, &
          & str2=trim(swathList2), options='-e' )
        if ( noUnique > 0 ) then
          call output('swaths only in ' // trim(File1), advance='yes')
          call output(trim(swathUnique), advance='yes')
        endif
        call GetUniqueList(trim(swathList2), swathUnique, noUnique, &
          & str2=trim(swathList1), options='-e' )
        if ( noUnique > 0 ) then
          call output('swaths only in ' // trim(File2), advance='yes')
          call output(trim(swathUnique), advance='yes')
        endif
      endif
      return
    endif
    status = InitializeMLSFile ( MLSFile1, type=l_swath, access=DFACC_READ, &
     & name=trim(file1), HDFVersion=the_hdfVersion1 )
    call MLS_OpenFile( MLSFile1 )
    File1Handle = MLSFile1%FileID%f_id
    status = InitializeMLSFile ( MLSFile2, type=l_swath, access=DFACC_READ, &
     & name=trim(file2), HDFVersion=the_hdfVersion2 )
    call MLS_OpenFile( MLSFile2 )
    File2Handle = MLSFile2%FileID%f_id

    ! Loop over swaths in file 1

    do i = 1, noSwaths
      call GetStringElement (trim(swathList1), swath, i, countEmpty )
      if ( len_trim(swath) < 1 ) then
        if ( .not. mySilent ) call output('(Ignoring blank swath name in ' // &
          &  trim(File1), advance='yes')
        cycle
      endif
      if ( swathList2 /= swathList1 ) then
        call GetStringElement (trim(swathList2), swath2, i, countEmpty )
      else
        swath2 = swath
      endif
      status = stringElementNum(swathList2, trim(swath2), countEmpty)
      if ( status < 1 ) then
        if ( .not. myForce ) then
          if ( .not. mySilent ) call output('Swath ' // trim(swath) // ' not found in ' // &
            & trim(File2), advance='yes')
          cycle
        elseif ( .not. mySilent) then
          call GetStringElement (trim(swathList2), swath2, i, countEmpty )
          call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
          call output( '---- swath(1) name: ' // trim(swath) // ' ----', advance='yes')
          call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
          call output( '     swath(2) name: ' // trim(swath2)// '     ', advance='yes')
          call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
        endif
      elseif( .not. mySilent ) then
        call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
        call output( '---- swath name: ' // trim(swath) // ' ----', advance='yes')
        call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
      endif
      call ReadL2GPData ( File1Handle, trim(swath), l2gp1, &
           & hdfVersion=the_hdfVersion1 )
      call ReadL2GPData ( File2Handle, trim(swath2), l2gp2, &
           & hdfVersion=the_hdfVersion2 )
      if ( present(geoBoxNames) ) then
        call DiffL2GPData_RANGES( l2gp1, l2gp2, &
        & geoBoxNames, geoBoxLowBound, geoBoxHiBound, chunks=chunks, &
        & details=details, options=options, fields=fields, &
        & numDiffs=numDiffs )
      elseif ( present(chunks) .and. present(pressures) ) then
        call Diff( l2gp1, l2gp2, pressures=pressures, chunks=chunks, &
        & details=details, options=options, fields=fields, &
        & numDiffs=numDiffs )
      elseif ( present(chunks) ) then
        call Diff( l2gp1, l2gp2, chunks=chunks, &
        & details=details, options=options, fields=fields, &
        & numDiffs=numDiffs )
      elseif ( present(pressures) ) then
        call Diff( l2gp1, l2gp2, pressures=pressures, &
        & details=details, options=options, fields=fields, &
        & numDiffs=numDiffs )
      else
        call Diff( l2gp1, l2gp2, &
        & details=details, options=options, fields=fields, &
        & numDiffs=numDiffs )
      endif

      if ( present(numDiffs) ) myNumDiffs = myNumDiffs + numDiffs
      call DestroyL2GPContents ( l2gp1 )
      call DestroyL2GPContents ( l2gp2 )
    enddo
    call MLS_CloseFile( MLSFile1 )
    call MLS_CloseFile( MLSFile2 )
    if ( present(numDiffs) ) numDiffs = myNumDiffs
  end subroutine DiffL2GPFiles_Name
    
  ! ------------------------------------------ DiffStatsInt ------------
  subroutine DiffStatsInt ( array1, array2, arrayName )
    ! Show diff between arrays 1 and 2: num diff num same, pctages
    integer, dimension(:), intent(in) :: array1
    integer, dimension(:), intent(in) :: array2
    character(len=*), intent(in) :: arrayName
    ! Internal variables
    integer :: numSame
    integer :: numDiff
    real :: pctSame
    real :: pctDiff
    ! Executable
    call output('Differences between (1) and (2) integer arrays ' &
      & // trim(arrayName), advance='yes')
    if ( size(array1) /= size(array2) ) then
      call output('(arrays (1) and (2) different lengths)', advance='yes')
      return
    endif
    numDiff = count(array1 /= array2)
    numSame = size(array1) - numDiff
    pctDiff = 100*numDiff/(0.+numDiff+numSame)
    pctSame = 100. - pctDiff
    call output(numSame, advance = 'no')
    call blanks(2, advance='no')
    call output('same', advance = 'no')
    call blanks(4, advance='no')
    call output(numDiff, advance = 'no')
    call blanks(2, advance='no')
    call output('different', advance = 'no')
    call blanks(4, advance='no')
    call output(pctSame, advance = 'no')
    call output('%  same', advance = 'no')
    call blanks(4, advance='no')
    call output(pctDiff, advance = 'no')
    call output('%  different', advance = 'yes')
  end subroutine DiffStatsInt

  ! ------------------------------------------ DUMP_L2GP ------------
  ! This family of routines Dumps l2gp datatype(s) according to
  ! their number (singly or an array of them)
  ! whole or subsetted
  ! the data or its metadata (i.e., attributes)
  ! ------------------------------------------ DUMP_L2GP_DATABASE ------------
  subroutine DUMP_L2GP_DATABASE ( L2gp, &
    & Name, ColumnsOnly, Details, Fields, options )

    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          L2GP(:)
    character(len=*), intent(in), optional :: Name
    logical, intent(in), optional ::          ColumnsOnly ! if true, dump only with columns
    integer, intent(in), optional :: DETAILS
    character(len=*), intent(in), optional :: fields ! ,-separated list of names
    character(len=*), intent(in), optional :: options ! Passed dumping arrays

    ! Local variables
    integer :: i
    call output ( '============ L2GP Data Base ============', advance='yes' )
    call output ( ' ', advance='yes' )
    if ( present(name) ) then
      call StyledOutput ( 'L2GP Database name: ' // trim(Name), options )
    endif
    if ( size(l2gp) < 1 ) then
      call output ( '**** L2GP Database empty ****', advance='yes' )
      return
    endif
    do i = 1, size(l2gp)
      call dump( l2gp(i), ColumnsOnly, Details, Fields, options=options )
    end do
      
  end subroutine DUMP_L2GP_DATABASE

  ! ------------------------------------------ DUMP_L2GP_CHUNKS ------------
  subroutine DUMP_L2GP_CHUNKS ( fullL2gp, Chunks, &
    & ColumnsOnly, Details, Fields, Width, options )
    ! Dump selected chunks of an l2gp
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          FULLL2GP
    integer, intent(in), dimension(:) :: Chunks ! Which chunks to dump
    logical, intent(in), optional ::          ColumnsOnly ! if true, dump only with columns
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but name
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 1
    character(len=*), intent(in), optional :: fields ! ,-separated list of names
    integer, intent(in), optional :: width   ! width of each dumped line
    character(len=*), intent(in), optional :: options ! Passed dumping arrays
    ! Local variables
    integer :: chunk
    integer :: i
    integer, dimension(2) :: irange
    type (l2gpData_T) ::          L2GP
    ! Executable
    do i=1, size(Chunks)
      chunk = Chunks(i)
      irange(1) = FindFirst( fullL2gp%chunkNumber, chunk )
      irange(2) = Findlast( fullL2gp%chunkNumber, chunk )
      ! HuntRange does not work correctly when any chunk Numbers are -999
      ! (Missing Value)
      ! call HuntRange( fullL2gp%chunkNumber, (/ chunk, chunk /), irange )
      if ( any( irange == 0 ) ) cycle
      call output ( ' - - - Chunk number:', advance='no' )
      call output ( chunk, advance='no' )
      call output ( ' - - -', advance='yes' )
      call ExtractL2GPRecord ( fullL2gp, l2gp, rTimes=irange )
      call Dump ( L2gp, ColumnsOnly, Details, Fields, width, options )
      call DestroyL2GPContents( l2gp )
    enddo
  end subroutine DUMP_L2GP_CHUNKS

  ! ------------------------------------------ DUMPL2GPData_RANGES ------------
  subroutine DUMPL2GPData_RANGES ( fullL2gp, &
    & geoBoxNames, geoBoxLowBound, geoBoxHiBound, &
    & Pressures, Latitudes, Longitudes, Times, Chunks, ColumnsOnly, &
    & Details, fields, Width, options )
    ! DUMP an l2gp according to prescribed ranges of pressure, longitude, etc.
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          FULLL2GP
    character(len=*), intent(in) , optional ::       geoBoxNames
    real(rgp), dimension(:), intent(in), optional :: geoBoxLowBound  ! range
    real(rgp), dimension(:), intent(in), optional :: geoBoxHiBound  ! range
    real(rgp), intent(in), dimension(2), optional :: pressures ! range
    real(rgp), intent(in), dimension(2), optional :: latitudes ! range
    real(rgp), intent(in), dimension(2), optional :: longitudes ! range
    real(r8), intent(in), dimension(2), optional :: times ! range
    integer, intent(in), optional, dimension(:) :: Chunks ! Which chunks to dump
    logical, intent(in), optional ::          ColumnsOnly ! if true, dump only with columns
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but name
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 1
    character(len=*), intent(in), optional :: fields ! ,-separated list of names
    integer, intent(in), optional :: width   ! width of each dumped line
    character(len=*), intent(in), optional :: options ! Passed dumping arrays
    ! Local variables
    ! logical, parameter :: DEEBUG = .true.
    type (l2gpData_T) ::          L2GP
    ! Executable
    if ( DEEBUG ) then
      if ( present(pressures) ) &
        & call dump( pressures, 'pressures' )
      if ( present(latitudes) ) &
        & call dump( latitudes, 'latitudes' )
      if ( present(longitudes) ) &
        & call dump( longitudes, 'longitudes' )
      call output( 'fullL2gp%pressures: ', advance='no' )
      call output( fullL2gp%pressures, advance='yes' )
    endif
    if ( present(geoBoxNames) ) then
      call ContractL2GPRecord ( fullL2gp, l2gp, &
        & geoBoxNames, geoBoxLowBound, geoBoxHiBound )
    else
      call ContractL2GPRecord ( fullL2gp, l2gp, pressures=pressures, &
        & latitudes=latitudes, longitudes=longitudes, intimes=times )
    endif
    if ( present(chunks) ) then
      call DUMP_L2GP_Chunks ( L2gp, Chunks, &
        & ColumnsOnly, Details, Fields, width, options )
    else
      call DUMP ( L2gp, ColumnsOnly, Details, Fields, width, options )
    endif
    call DestroyL2GPContents( l2gp )
  end subroutine DUMPL2GPData_RANGES

  ! ------------------------------------------ DUMP_L2GP ------------
  subroutine Dump_L2GP ( L2gp, ColumnsOnly, Details, Fields, Width, options )
    ! Dump an l2gp
    ! Either according to level of detail set by Details
    ! or else just those fields named in Fields
    ! Note: 'solarTime' among Fields will also provoke dumping 'time'
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          L2GP
    logical, intent(in), optional ::          ColumnsOnly ! if true, dump only with columns
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but name
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 1
    character(len=*), intent(in), optional :: fields ! ,-separated list of names
    integer, intent(in), optional :: width   ! width of each dumped line
    character(len=*), intent(in), optional :: options ! Passed dumping arrays

    ! Local variables
    real(r8) :: FillValue
    real(rgp) :: FillValueGP
    real(rgp), dimension(:), pointer :: hoursInDay
    integer :: i
    integer :: ierr
    integer :: lastChunk
    real(rgp) :: LastValue
    logical :: myColumnsOnly
    integer :: MYDETAILS
    character(len=Len(DATA_FIELDS)+Len(GEO_FIELDS)) :: myFields
    integer :: nUnique
    logical :: skipGeos
    real(rgp), dimension(:), pointer :: spacing
    integer, dimension(MAXNUMTIMES) :: FirstProfInChunk
    integer, dimension(MAXNUMTIMES) :: FirstProfInUnique
    integer, dimension(MAXNUMTIMES) :: uniqueVals

    ! Executable code
    myDetails = 1
    if ( present(details) ) myDetails = details
    myFields = ' '
    if ( present(fields) ) then
      myFields = fields
      if ( .not. present(details) ) myDetails = 2
    endif
    
    if( present(ColumnsOnly)) then
      myColumnsOnly = ColumnsOnly
    else
      myColumnsOnly = .false.
    endif

    if ( myColumnsOnly .and. l2gp%nLevels > 1 ) return
    skipGeos = .false.
    if ( present(options) ) skipGeos = ( index(options, 'g') > 0 )
    FillValue = real(l2gp%MissingValue, r8)
    FillValueGP = l2gp%MissingValue
    if ( showMe(.true., myFields, 'swathname') ) then
      call StyledOutput ( 'L2GP Data: (swath name) ' // trim(l2gp%name), &
        & options='--Banner' )
      if ( NAMEINDEXEVERSET ) then
        call output ( ', (parser name) ' )
        if(l2gp%nameIndex > 0) then
          call display_string ( l2gp%nameIndex, advance='yes', IERR=ierr)
          if ( ierr /= 0 ) call output ( '(not found in string table)', &
           & advance='yes' )
        else
          call output ( '(the nameIndex was 0) ', advance='yes' )
        endif
      else
        call output ( ' ', advance='yes' )
      endif
    endif

    if ( showMe(myDetails > -2, myFields, 'ntimes') ) then
      call output ( 'nTimes: ' )
      call output ( l2gp%nTimes, 5 )
      call output ( '  nTimesTotal: ' )
      call output ( l2gp%nTimesTotal, 5 )
      call output ( '  nLevels: ' )
      call output ( l2gp%nLevels, 3 )
      call output ( '  nFreqs: ' )
      call output ( l2gp%nFreqs, 3, advance='yes' )
      call output ( 'Fill/Missing L2GP Values: ' )
      call output ( l2gp%MissingL2GP, advance='yes' )
      call output ( 'Fill/Missing Values (Others): ')
      call output ( l2gp%MissingValue, advance='yes' )
      call output ( 'Fill/Missing Status Field: ' )
      call output ( l2gp%MissingStatus, advance='yes' )
     endif
    
    if ( .not. skipGeos ) then
      if ( showMe(myDetails > -1, myFields, 'pressure') ) &
        & call dump ( l2gp%pressures, trim(l2gp%verticalCoordinate) // 's:', &
        & FillValue=FillValueGP, width=width, options=options )

      if ( showMe(myDetails > -1, myFields, 'latitude') ) &
        & call dump ( l2gp%latitude, 'Latitude:', FillValue=FillValueGP, &
        & width=width, options=options )

      if ( showMe(myDetails > -1, myFields, 'longitude') ) &
        & call dump ( l2gp%longitude, 'Longitude:', FillValue=FillValueGP, &
        & width=width, options=options )

      if ( showMe(myDetails > -1, myFields, 'solartime') ) &
        & call dump ( l2gp%solarTime, 'SolarTime:', FillValue=FillValueGP, &
        & width=width, options=options )

      if ( showMe(myDetails > -1, myFields, 'solarzenith') ) &
        & call dump ( l2gp%solarZenith, 'SolarZenith:', FillValue=FillValueGP, &
        & width=width, options=options )

      if ( showMe(myDetails > -1, myFields, 'LOSAngle') ) &
        & call dump ( l2gp%losAngle, 'LOSAngle:', FillValue=FillValueGP, &
        & width=width, options=options )

      if ( showMe(myDetails > -1, myFields, 'geodAngle') ) &
        & call dump ( l2gp%geodAngle, 'geodAngle:', FillValue=FillValueGP, &
        & width=width, options=options )

      if ( showMe(myDetails > -1, myFields, 'time') ) then
        nullify( hoursInDay )
        call dump ( l2gp%time, 'Time:', FillValue=FillValue, &
          & width=width, options=options )
        call allocate_test ( hoursInDay, l2gp%nTimes, 'hoursInDay', ModuleName )
        where ( l2gp%time /= FillValue )
          hoursInDay = timeToHoursInDay ( l2gp%time )
        elsewhere
          hoursInDay = FillValueGP
        end where
        call dump ( hoursInDay, 'Hours In Day:', FillValue=FillValueGP, &
          & width=width, options=options )
        call deallocate_test ( hoursInDay, 'hoursInDay', ModuleName )
      endif

      if ( showMe(myDetails > -1, myFields, 'spacing') ) then
        nullify( spacing )
        call allocate_test ( spacing, l2gp%nTimes-1, 'spacing', ModuleName )
        spacing = 0.
        do i=1, l2gp%nTimes - 1
          spacing(i) = EarthRadA * sqrt ( &
            & (sin(Deg2Rad*l2gp%latitude(i+1)) - sin(Deg2Rad*l2gp%latitude(i)))**2 &
            & + &
            & (cos(Deg2Rad*l2gp%latitude(i+1))*cos(Deg2Rad*l2gp%longitude(i+1)) &
            & - cos(Deg2Rad*l2gp%latitude(i))*cos(Deg2Rad*l2gp%longitude(i)))**2 &
            & + &
            & (cos(Deg2Rad*l2gp%latitude(i+1))*sin(Deg2Rad*l2gp%longitude(i+1)) &
            & - cos(Deg2Rad*l2gp%latitude(i))*sin(Deg2Rad*l2gp%longitude(i)))**2 &
            & )
        enddo
        call dump ( spacing, 'spacing (in m):', FillValue=FillValueGP, &
          & width=width, options=options )
        call deallocate_test ( spacing, &
          & 'spacing', ModuleName )
      endif

      if ( showMe(myDetails > -1, myFields, 'chunkNumber') ) &
        & call dump ( l2gp%chunkNumber, 'ChunkNumber:', &
        & width=width, options=options )

      if ( showMe(myDetails > -1, myFields, 'FirstProfileNumber') ) then
        ! Compute the first profile number in each chunk
        call FindUnique ( l2gp%chunkNumber, uniqueVals, nUnique )
        lastChunk = 0
        do i = 1, nUnique
          FirstProfInChunk(i) = FindFirst( l2gp%chunkNumber > lastChunk )
          if ( FirstProfInChunk(i) > 0 ) &
            & lastChunk = l2gp%chunkNumber( FirstProfInChunk(i) )
        enddo
        call dump ( FirstProfInChunk(1:nUnique), '1st profile in chunk:', &
          & width=width, options=options )
          
        nUnique = 0
        lastValue = l2gp%MissingValue
        do i = 1, l2gp%NTimes
          if ( abs( l2gp%l2gpValue(1,1,i)-lastValue ) > 1.d-12 ) then
            nUnique = nUnique + 1
            FirstProfInUnique(nUnique) = i
            lastValue = l2gp%l2gpValue(1,1,i)
          endif
        enddo
        call dump ( FirstProfInUnique(1:nUnique), '1st profile with next l2gpvalue:', &
          & width=width, options=options )
        call output ( 'Check if computing 1st profile agree', advance='yes' )
        if ( all(FirstProfInChunk(1:nUnique) == FirstProfInUnique(1:nUnique) ) ) then
          call output ( 'Both ways of computing 1st profile agree', advance='yes' )
        else
          call dump ( FirstProfInChunk(1:nUnique) - FirstProfInUnique(1:nUnique), &
            & 'Their diff', width=width, options=options )
        endif
      endif

      if ( showMe(myDetails > -1, myFields, 'pressure') .and. &
        & associated(l2gp%frequency) ) &
        & call dump ( l2gp%frequency, 'Frequencies:', FillValue=FillValueGP, &
        & width=width, options=options )

    endif      

    if ( showMe(myDetails > 0, myFields, 'l2gpvalue') ) then
      if ( l2gp%nFreqs < 2 ) then
        call dump ( l2gp%l2gpValue(1,:,:), 'L2GPValue:', &
          & FillValue=l2gp%MissingL2GP, options=options )
      else
        call dump ( l2gp%l2gpValue, 'L2GPValue:', &
          & FillValue=l2gp%MissingL2GP, options=options )
      endif
    endif
      
    if ( showMe(myDetails > 0, myFields, 'l2gpprecision') ) then
      if ( l2gp%nFreqs < 2 ) then
        call dump ( real(l2gp%l2gpprecision(1,:,:), r8), 'L2GPPrecision:', &
          & FillValue=FillValue, options=options )
      else
        call dump ( real(l2gp%l2gpprecision, r8), 'L2GPprecision:', &
          & FillValue=FillValue, options=options )
      endif
    endif
      
    if ( showMe(myDetails > 0, myFields, 'status') ) then
      call dump ( l2gp%status, 'Status:', options=options )
      call FindUnique( l2gp%status, uniqueVals, nUnique )
      call outputNamedValue(' Number unique values', nUnique )
      do i=1, nUnique
        call DumpBitNames( uniqueVals(i), StatusBitNames )
      enddo
      
    endif      
    if ( showMe(myDetails > 0, myFields, 'quality') ) &
      & call dump ( l2gp%quality, 'Quality:', &
        & FillValue=FillValueGP, options=options )
      
    if ( showMe(myDetails > 0, myFields, 'convergence') ) &
      & call dump ( l2gp%convergence, 'Convergence:', &
        & FillValue=FillValueGP, options=options )
      
    if ( showMe(myDetails > 0, myFields, 'AscDescMode ') .and. AscDescModeIsField ) &
      & call dump ( l2gp%AscDescMode, 'AscDescMode :', &
        & width=width, options=options )
      
    if ( showMe(myDetails > 0, myFields, 'BinNumber') .and. associated(l2gp%BinNumber) ) &
      & call dump ( l2gp%BinNumber, 'BinNumber:', &
        & options=options )
      
    if ( showMe(myDetails > 0, myFields, 'MAF') .and. associated(l2gp%MAF) ) &
      & call dump ( l2gp%MAF, 'MAF:', &
        & options=options )
      
  contains
    logical function showMe(detailsOK, fields, field)
      ! Determine whether this field should be dumped or not
      ! depending on whether you're going by details or by picking fields
      logical, intent(in) :: detailsOK
      character(len=*), intent(in) :: fields
      character(len=*), intent(in) :: field
      !
      if ( len_trim(fields) < 1 ) then
        showMe = detailsOK
      else
        showMe = ( &
          & switchDetail(LowerCase(fields), LowerCase(trim(field)), '-fc' ) &
          & > -1 )
      endif
    end function showMe
  end subroutine Dump_L2GP
    
  !----------------------------------------  DumpL2GP_attributes_hdf5  -----
  subroutine DumpL2GP_attributes_hdf5( l2FileHandle, l2gp, swathName )
  use HE5_SWAPI, only: HE5_SWRdattr, HE5_SWRdlattr
  use MLSHDFEOS, only: MLS_SWAttach, MLS_SWDetach, HE5_EHRdglatt
  use PCFHdr, only:  GlobalAttributes_T, HE5_ReadGlobalAttr, &
    & DumpGlobalAttributes
    ! Brief description of subroutine
    ! This subroutine dumps the attributes for an l2gp
    ! These include
    ! Global attributes which are file level
    ! Swath level
    ! Geolocation field attributes
    ! Data field attributes
    ! Arguments

    integer, intent(in) :: l2FileHandle ! From swopen
    type( L2GPData_T ), intent(inout) :: l2gp
    character (len=*), optional, intent(in) :: swathName ! Defaults->l2gp%name

    ! Variables
    type (GlobalAttributes_T)         :: gAttributes
    character(len=255)                :: ProcessLevel
    integer                           :: DayofYear
    double precision                  :: TAI93At0zOfGranule
    real(rgp), dimension(MAXNLEVELS)  :: pressures

    character (len=132) :: name     ! Either swathName or l2gp%name
    ! The following pair of string list encode the Units attribute
    ! corresponding to each Title attribute; e.g., the Units for Latitude is deg
    character (len=*), parameter :: GeolocationTitles = &
      & 'Latitude,Longitude,Time,LocalSolarTime,SolarZenithAngle,' // &
      & 'LineOfSightAngle,OrbitGeodeticAngle,ChunkNumber,Pressure,Frequency'
    character (len=*), parameter :: GeolocationUnits = &
      & 'deg,deg,s,h,deg,' // &
      & 'deg,deg,NoUnits,hPa,GHz'
    character (len=*), parameter :: GeoUniqueFieldDefinition = &
      & 'HMT,HMT,AS,HMT,HMT,' // &
      & 'M,M,M,AS,M'   ! These are abbreviated values
    character (len=*), parameter :: UniqueFieldDefKeys = &
      & 'HM,HMT,MT,AS,M'
    character (len=*), parameter :: UniqueFieldDefValues = &
      & 'HIRDLS-MLS-Shared,HIRDLS-MLS-TES-Shared,MLS-TES-Shared,' // &
      & 'Aura-Shared,MLS-Specific'  ! Expanded values
    ! The following associate UniqueFieldDefs with species names
    character (len=*), parameter :: Species = &
      & 'Temperature,BrO,CH3CN,CO,ClO,GPH,HCl,HCN,H2O,H2O2,' // &
      & 'HNO3,HOCl,HO2,N2,N2O,OH,O2,O3,RHI,SO2'
    character (len=*), parameter :: SpUniqueFieldDefinition = &
      & 'HMT,M,M,MT,M,M,M,M,HMT,M,' // &
      & 'HMT,M,M,M,HM,M,M,HMT,M,M'   ! These are abbreviated values

    integer :: field
    logical :: isColumnAmt
    integer :: status
    integer :: swid
    character(len=CHARATTRLEN), dimension(NumGeolocFields) :: theTitles
    character(len=CHARATTRLEN), dimension(NumGeolocFields) :: theUnits
    character(len=CHARATTRLEN) :: field_name
    character(len=CHARATTRLEN) :: units_name
    character(len=CHARATTRLEN) :: uniqueness
    character(len=CHARATTRLEN) :: species_name
    character(len=CHARATTRLEN) :: abbr_uniq_fdef
    character(len=CHARATTRLEN) :: expnd_uniq_fdef
    real(rgp), dimension(1) :: MissingValue
    ! Begin
    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
    endif
    call outputNamedValue ( 'L2GP Attributes: (swath name) ', trim(name), &
      & options = '-H' )
    if ( .not. any( rgp /= (/ r4, r8 /) ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & 'Attributes have unrecognized numeric data type; should be r4 or r8' )
    endif
    call List2Array(GeolocationTitles, theTitles, .true.)
    call List2Array(GeolocationUnits, theUnits, .true.)

    ! - -   G l o b a l   A t t r i b u t e s   - -
    call output ( '(Global Attributes) ', advance='yes' )
    call he5_readglobalattr( l2FileHandle, gAttributes, &
     & ProcessLevel, DayofYear, TAI93At0zOfGranule, returnStatus=status )
    if ( status /= 0 ) then
      call output ('No global attributes found in file', advance='yes')
    else
      ! We stopped reading MiscNotes in the PCFHdr module to avoid
      ! letting the master task step on the value each slave had carefully
      ! written there
      ! Therefore, we must read it here , now
      ! (Sigh)
      status = he5_EHrdglatt( l2FileHandle, &
      & 'MiscNotes', &
      &  gAttributes%MiscNotes )
      status = he5_EHrdglatt( l2FileHandle, &
      & 'ProductionLocation', &
      &  gAttributes%ProductionLoc )
      status = he5_EHrdglatt( l2FileHandle, &
      & 'HostName', &
      &  gAttributes%HostName )
      status = he5_EHrdglatt( l2FileHandle, &
      & 'identifier_product_doi', &
      &  gAttributes%DOI )
      call dumpGlobalAttributes ( gAttributes ) 
      call dump_int ( DayOfYear, 'Granule day of year:' )
      call dump_r8 ( TAI93At0zOfGranule, 'Equator crossing time (tai93):' )
    endif
    swid = mls_SWattach (l2FileHandle, name, hdfVersion=HDFVERSION_5)
    if ( swid == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to attach swath ' // trim(name))
    end if
    
    !   - -   S w a t h   A t t r i b u t e s   - -
    call output ( '(Swath Attributes) ', advance='yes')
    if ( l2gp%nLevels > 3 ) then
      status = he5_swrdattr(swid, 'Pressure', pressures)
      call dump ( pressures, 'Vertical coordinates:' )
      status = he5_swrdattr(swid, 'VerticalCoordinate', field_name)
      call dump_chars ( field_name, 'Vertical coordinates type:' )
    endif
    status = he5_swrdlattr( swid, 'L2gpValue', 'MissingValue', MissingValue )
    call dump ( MissingValue, 'MissingValues (L2GPValues only):' )
    status = he5_swrdlattr( swid, 'L2gpPrecision', 'MissingValue', MissingValue )
    call dump ( MissingValue, 'MissingValues (other fields):' )
    
    !   - -   G e o l o c a t i o n   A t t r i b u t e s   - -
    call output ( '(Geolocation Attributes) ', advance='yes')
    do field=1, NumGeolocFields
      ! Take care not to write attributes to "missing fields"
      if ( trim(theTitles(field)) == 'Frequency' &
        & .and. l2gp%nFreqs < 1 ) then
        field_name = ''
      elseif ( trim(theTitles(field)) == 'Pressure' &
        & .and. l2gp%nLevels == 3 ) then
        call dump_chars ( 'DYNTpVals', 'Field title:' )
      elseif ( trim(theTitles(field)) == 'Pressure' &
        & .and. l2gp%nLevels < 1 ) then
        field_name = ''
      else
        call GetHashElement (GeolocationTitles, &
          & GeoUniqueFieldDefinition, trim(theTitles(field)), &
          & abbr_uniq_fdef, .false.)
        call GetHashElement (UniqueFieldDefKeys, &
          & UniqueFieldDefValues, trim(abbr_uniq_fdef), &
          & expnd_uniq_fdef, .false.)
        status = he5_swrdlattr(swid, trim(theTitles(field)), 'Title', field_name)
        status = he5_swrdlattr(swid, trim(theTitles(field)), 'Units', units_name)
        call dump_chars ( field_name, 'Field title:' )
        call dump_chars ( units_name, 'Units:' )

        status = he5_swrdlattr(swid, trim(theTitles(field)), &
          & 'UniqueFieldDefinition', uniqueness)
        call dump_chars ( uniqueness, 'Unique field definition:' )
      endif
    enddo
    !   - -   D a t a   A t t r i b u t e s   - -
    call output ( '(Data Attributes) ', advance='yes')
    field_name = Name
    species_name = name
    isColumnAmt = ( index(species_name, 'Column') > 0 )
    if ( isColumnAmt ) then
      call ExtractSubString(Name, species_name, 'Column', 'wmo')
    endif
    call GetHashElement (lowercase(Species), &
      & SpUniqueFieldDefinition, trim(lowercase(species_name)), &
      & abbr_uniq_fdef, .false.)
    call GetHashElement (UniqueFieldDefKeys, &
      & UniqueFieldDefValues, trim(abbr_uniq_fdef), &
      & expnd_uniq_fdef, .false.)
    select case (trim(lowercase(species_name)))
    case ('temperature')
      units_name = 'K'
    case ('gph')
      units_name = 'm'
    case ('rhi')
      units_name = '%rhi'
    case default
      units_name = 'vmr'
    end select
    if ( isColumnAmt ) units_name = 'DU'
    status = he5_swrdlattr(swid, 'L2gpValue', 'Title', field_name)
    status = he5_swrdlattr(swid, 'L2gpValue', 'Units',  units_name)
    status = he5_swrdlattr(swid, 'L2gpValue', &
      & 'UniqueFieldDefinition', uniqueness)
    call dump_chars ( field_name, 'Field title:' )
    call dump_chars ( units_name, 'Units:' )
    call dump_chars ( uniqueness, 'Unique field definition:' )
    status = he5_swrdlattr(swid, 'L2gpPrecision', 'Title', field_name)
    status = he5_swrdlattr(swid, 'L2gpPrecision', 'Units', units_name)
    status = he5_swrdlattr(swid, 'L2gpPrecision', &
      & 'UniqueFieldDefinition', uniqueness)
    call dump_chars ( field_name, 'Field title:' )
    call dump_chars ( units_name, 'Units:' )
    call dump_chars ( uniqueness, 'Unique field definition:' )

    ! ('Status' data field newly written)
    status = he5_swrdlattr(swid, 'Status', 'Title', field_name)
    status = he5_swrdlattr(swid, 'Status', 'Units', units_name)
    status = he5_swrdlattr(swid, 'Status', &
      & 'UniqueFieldDefinition', uniqueness)
    call dump_chars ( field_name, 'Field title:' )
    call dump_chars ( units_name, 'Units:' )
    call dump_chars ( uniqueness, 'Unique field definition:' )
    
    status = he5_swrdlattr(swid, 'Quality', 'Title', field_name)
    status = he5_swrdlattr(swid, 'Quality', 'Units', units_name)
    status = he5_swrdlattr(swid, 'Quality', &
      & 'UniqueFieldDefinition', uniqueness)
    call dump_chars ( field_name, 'Field title:' )
    call dump_chars ( units_name, 'Units:' )
    call dump_chars ( uniqueness, 'Unique field definition:' )
    
    status = mls_SWdetach(swid, hdfVersion=HDFVERSION_5)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach  from swath interface' )
    end if
    contains
    subroutine dump_chars(value, name)
      ! arguments
      character(len=*), intent(in) :: value
      character(len=*), intent(in) :: name
      ! Executable
      call output(trim(name) // ' ', advance='no')
      call output(trim(value), advance='yes')
    end subroutine dump_chars
    subroutine dump_int(value, name)
      ! arguments
      integer, intent(in) :: value
      character(len=*), intent(in) :: name
      ! Executable
      call output(trim(name) // ' ', advance='no')
      call output(value, advance='yes')
    end subroutine dump_int
    subroutine dump_r8(value, name)
      ! arguments
      real(r8), intent(in) :: value
      character(len=*), intent(in) :: name
      ! Executable
      call output(trim(name) // ' ', advance='no')
      call output(value, advance='yes')
    end subroutine dump_r8

  !-------------------------------------
  end subroutine DumpL2GP_attributes_hdf5
  !-------------------------------------

  !------------------------------------------  ExtractL2GPRecord  -----
  ! Extract a reduced copy of an original l2gp record
  ! picking out a range of subscripts for freqs, level2, times
  ! Omitted ranges will be same range as original l2gp

  ! Note that this does not do the more useful task:
  ! Reposition an l2gp record onto a new set of geolocations
  ! via multi-dimensional or repeated interpolation

  ! Nor does it (yet) do another potentially useful task:
  ! Extract the range of profiles within a box of times, lats, lons
  ! and a range of levels within a range of pressures

  ! These last tasks aren't too difficult, since we could define
  ! myTimes and myLevels based on HuntRange.

  ! A tricky point: invalid ranges (i.e. upper limit < 1) will
  ! be treated as if they were omitted

  subroutine ExtractL2GPRecord_range ( ol2gp, l2gp, rFreqs, rLevels, rTimes )
    ! Dummy arguments
    type (L2GPData_T), intent(in)   :: ol2gp
    type (L2GPData_T), intent(out)  :: l2gp
    integer, dimension(2), intent(in), optional :: rFreqs  ! subscript range
    integer, dimension(2), intent(in), optional :: rLevels ! subscript range
    integer, dimension(2), intent(in), optional :: rTimes  ! subscript range
    ! Local variables
    integer :: i
    integer, dimension(2) :: myFreqs  ! subscript range
    integer, dimension(2) :: myLevels ! subscript range
    integer, dimension(2) :: myTimes  ! subscript range

    integer, dimension(3) :: start
    integer, dimension(3) :: count
    integer, dimension(3) :: block
    integer, dimension(3) :: stride
    logical :: useFreqs  
    logical :: useLevels 
    logical :: useTimes  
    
    ! Executable
    block = 1
    stride = 1
    useFreqs   = .false.
    useLevels  = .false.
    useTimes   = .false.
    if ( present(rFreqs) ) then
      useFreqs = rFreqs(2) > 0
    endif
    if ( present(rLevels) ) then
      useLevels = rLevels(2) > 0
    endif
    if ( present(rTimes) ) then
      useTimes = rTimes(2) > 0
    endif
    if ( useFreqs ) then
      myFreqs = rFreqs
    else
      myFreqs(1) = 1
      myFreqs(2) = ol2gp%nFreqs
    endif
    if ( useLevels ) then
      myLevels = rLevels
    else
      myLevels(1) = 1
      myLevels(2) = ol2gp%nLevels
    endif
    if ( useTimes ) then
      myTimes = rTimes
    else
      myTimes(1) = 1
      myTimes(2) = ol2gp%nTimes
    endif
    
    call SetupNewL2GPRecord ( l2gp, &
      & ( myFreqs(2) - myFreqs(1) + 1 ), &
      & ( myLevels(2) - myLevels(1) + 1 ), &
      & ( myTimes(2) - myTimes(1) + 1 ) )

    l2gp%name               = ol2gp%name    
    l2gp%nameIndex          = ol2gp%nameIndex    
    ! l2gp%quantitytype       = ol2gp%quantitytype 
    l2gp%MissingL2GP        = ol2gp%MissingL2GP
    l2gp%MissingValue       = ol2gp%MissingValue 
    l2gp%MissingStatus      = ol2gp%MissingStatus
    l2gp%verticalCoordinate = ol2gp%verticalCoordinate    
    ! Now fill the actual arrays
    ! We'll need to have sane ranges for freqs and levels even if the
    ! we supplied 0 originally
    myFreqs(2) = max( myFreqs(2), myFreqs(1) )
    myLevels(2) = max( myLevels(2), myLevels(1) )
    ! convert to hyperslab params start, count, stride, block
    start(1) = myFreqs(1) + MLS_HyperStart -1 
    start(2) = mylevels(1) + MLS_HyperStart -1 
    start(3) = myTimes(1) + MLS_HyperStart -1 
    count(1) = myFreqs(2) - myFreqs(1) + 1
    count(2) = mylevels(2) - mylevels(1) + 1
    count(3) = myTimes(2) - myTimes(1) + 1
    if ( ol2gp%nFreqs < 1 ) then
      start(1) = MLS_HyperStart
      count(1) = 1
    endif
    call ExtractArray ( l2gp%pressures    , ol2gp%pressures    , start(2:2), count(2:2), stride(2:2), block(2:2) )
    call ExtractArray ( l2gp%frequency    , ol2gp%frequency    , start(1:1), count(1:1), stride(1:1), block(1:1) )
    call ExtractArray ( l2gp%latitude     , ol2gp%latitude     , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%longitude    , ol2gp%longitude    , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%solarTime    , ol2gp%solarTime    , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%solarZenith  , ol2gp%solarZenith  , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%losAngle     , ol2gp%losAngle     , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%geodAngle    , ol2gp%geodAngle    , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%time         , ol2gp%time         , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%chunkNumber  , ol2gp%chunkNumber  , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%l2gpValue    , ol2gp%l2gpValue    , start, count, stride, block )
    call ExtractArray ( l2gp%l2gpPrecision, ol2gp%l2gpPrecision, start, count, stride, block )
    call ExtractArray ( l2gp%status       , ol2gp%status       , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%quality      , ol2gp%quality      , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%convergence  , ol2gp%convergence  , start(3:3), count(3:3), stride(3:3), block(3:3) )
    ! We may implement this field as either an integer or a char
    ! call ExtractArray ( l2gp%AscDescMode    , ol2gp%AscDescMode    , start(2:2), count(2:2), stride(2:2), block(2:2) )
    if ( AscDescModeIsField ) then
      do i=1, count(3)
        l2gp%AscDescMode(i) = ol2gp%AscDescMode(myTimes(1) + i - 1)
      enddo
    endif
    if ( associated(ol2gp%BinNumber) ) then
      allocate(l2gp%BinNumber(1:count(3)))
      do i=1, count(3)
        l2gp%BinNumber(i) = ol2gp%BinNumber(myTimes(1) + i - 1)
      enddo
    endif
    if ( associated(ol2gp%MAF) ) then
      allocate(l2gp%MAF(1:count(3)))
      do i=1, count(3)
        l2gp%MAF(i) = ol2gp%MAF(myTimes(1) + i - 1)
      enddo
    endif
  end subroutine ExtractL2GPRecord_range

  subroutine ExtractL2GPRecord_which ( ol2gp, l2gp, &
    & whichFreqsIn, whichLevels, whichTimes, &
    & useFreqs, useLevels, useTimes )
    ! Like the above but with sets of which indexes to choose
    ! instead of their ranges
    ! Dummy arguments
    type (L2GPData_T), intent(in)   :: ol2gp
    type (L2GPData_T), intent(out)  :: l2gp
    integer, dimension(:), intent(in), target :: whichFreqsIn! which freqs
    integer, dimension(:), intent(in) :: whichLevels ! which levels
    integer, dimension(:), intent(in) :: whichTimes  ! which times
    integer, intent(in)               :: useFreqs    ! how many freqs
    integer, intent(in)               :: useLevels   ! how many levels
    integer, intent(in)               :: useTimes    ! how many times
    ! Local variables
    integer :: i

    integer, dimension(3) :: start
    integer, dimension(3) :: count
    integer, dimension(3) :: block
    integer, dimension(3) :: stride
    integer               :: numFreqs  ! how many freqs
    integer               :: numLevels ! how many levels
    integer               :: numTimes  ! how many times
    integer, dimension(:), pointer :: whichFreqs
    
    ! Executable
    call SetupNewL2GPRecord ( l2gp, &
      & ol2gp%nFreqs, &
      & useLevels, &
      & useTimes )
    
    numFreqs                = max ( useFreqs , 1 )
    numLevels               = max ( useLevels, 1 )
    numTimes                = max ( useTimes , 1 )
    l2gp%name               = ol2gp%name    
    l2gp%nameIndex          = ol2gp%nameIndex    
    ! l2gp%quantitytype       = ol2gp%quantitytype 
    l2gp%MissingL2GP        = ol2gp%MissingL2GP
    l2gp%MissingValue       = ol2gp%MissingValue 
    l2gp%MissingStatus      = ol2gp%MissingStatus
    l2gp%verticalCoordinate = ol2gp%verticalCoordinate    
    if ( usefreqs > 0 ) then
      whichFreqs => whichFreqsIn
    else
      allocate( whichFreqs(1) )
      whichFreqs = 1
    endif
    ! Now fill the actual arrays
    if ( DeeBug ) then
      call outputNamedValue( 'UseFreqs', useFreqs )
      call outputNamedValue( 'UseLevels', useLevels )
      call outputNamedValue( 'UseTimes', useTimes )
      call dump( whichFreqs(1:useFreqs), 'whichFreqs' )
      call dump( whichLevels(1:useLevels), 'whichLevels' )
      call dump( whichTimes(1:useTimes), 'whichTimes' )
    endif
    call GatherBloc ( l2gp%pressures    , ol2gp%pressures    , &
      & whichLevels(1:numLevels) )
    call GatherBloc ( l2gp%frequency    , ol2gp%frequency    , &
      & whichFreqs(1:numFreqs) )
    call GatherBloc ( l2gp%latitude     , ol2gp%latitude     , &
      & whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%longitude    , ol2gp%longitude    , &
      & whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%solarTime    , ol2gp%solarTime    , &
      & whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%solarZenith  , ol2gp%solarZenith  , &
      & whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%losAngle     , ol2gp%losAngle     , &
      & whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%geodAngle    , ol2gp%geodAngle    , &
      & whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%time         , ol2gp%time         , &
      & whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%chunkNumber  , ol2gp%chunkNumber  , &
      & whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%l2gpValue    , ol2gp%l2gpValue    , &
      & whichFreqs(1:numFreqs), whichLevels(1:numLevels), whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%l2gpPrecision, ol2gp%l2gpPrecision, &
      & whichFreqs(1:numFreqs), whichLevels(1:numLevels), whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%status       , ol2gp%status       , &
      & whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%quality      , ol2gp%quality      , &
      & whichTimes(1:numTimes) )
    call GatherBloc ( l2gp%convergence  , ol2gp%convergence  , &
      & whichTimes(1:numTimes) )
    if ( AscDescModeIsField ) then
      do i=1, numTimes
        l2gp%AscDescMode(i) = ol2gp%AscDescMode(whichTimes(i))
      enddo
    endif
    if ( associated(ol2gp%BinNumber) ) then
      allocate(l2gp%BinNumber(1:count(3)))
      do i=1, numTimes
        l2gp%BinNumber(i) = ol2gp%BinNumber(whichTimes(i))
      enddo
    endif
    if ( associated(ol2gp%MAF) ) then
      allocate(l2gp%MAF(1:numTimes))
      do i=1, numTimes
        l2gp%MAF(i) = ol2gp%MAF(whichTimes(i))
      enddo
    endif
    if ( usefreqs == 0 ) then
      deallocate( whichFreqs )
    endif
  end subroutine ExtractL2GPRecord_which

  !------------------------------------------  IsL2GPSetUp  -----
  function IsL2GPSetUp ( l2gp ) result( sooDesu )

    ! return TRUE only if all arrays allocated

    ! Dummy arguments
    type (L2GPData_T), intent(in)  :: l2gp
    logical :: sooDesu
    ! Executable
    sooDesu = .true.
    sooDesu = sooDesu .and. ( size(l2gp%pressures       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%frequency       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%latitude        )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%longitude       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%solarTime       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%solarZenith     )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%losAngle        )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%geodAngle       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%time            )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%chunkNumber     )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%l2gpValue       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%l2gpPrecision   )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%status          )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%quality         )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%convergence     )     > 0 )
    if ( AscDescModeIsField ) &
      & sooDesu = sooDesu .and. ( size(l2gp%AscDescMode       )     > 0 )
  end function IsL2GPSetUp

  !------------------------------------------  SetupNewL2GPRecord  -----
  subroutine SetupNewL2GPRecord ( l2gp, nFreqs, nLevels, nTimes, nTimesTotal, &
    & FillIn, proto, which )

    ! This routine sets up the arrays for an l2gp datatype.
    ! It preassigns their values to MissingValue (if FillIn is TRUE)
    ! or to proptype's values (if supplied)

    ! Dummy arguments
    type (L2GPData_T), intent(inout)  :: l2gp
    integer, intent(in), optional :: nFreqs              ! Dimensions
    integer, intent(in), optional :: nLevels             ! Dimensions
    integer, intent(in), optional :: nTimes              ! Dimensions
    integer, intent(in), optional :: nTimesTotal         ! Dimensions
    logical, intent(in), optional :: FillIn    ! Fill with MissingValue
    type (L2GPData_T), intent(in), optional  :: proto    ! prototype
    integer, dimension(:), optional, intent(in) :: which ! which profiles to fill from

    ! Local variables
    logical :: myFillIn
    integer :: nn
    integer :: useNFreqs, useNLevels, useNTimes, useNTimesTotal

    if ( present(nFreqs) ) then
       useNFreqs=nFreqs
    elseif ( present(proto) ) then
       useNFreqs=proto%nFreqs
    else
       useNFreqs=0
    end if

    if ( present(nLevels) ) then
       useNLevels=nLevels
    elseif ( present(proto) ) then
       useNLevels=proto%nLevels
    else
       useNLevels=0
    end if

    if ( present(nTimes) ) then
       useNTimes=nTimes
    elseif ( present(proto) ) then
      if ( present(which) ) then
       useNTimes=size(which)
      else
       useNTimes=proto%nTimes
      endif
    else
       useNTimes=0              ! Default to empty l2gp
    end if

    if ( present(nTimesTotal) ) then
       useNTimesTotal=nTimesTotal
    elseif ( present(proto) ) then
       useNTimesTotal=proto%nTimesTotal
    else
       useNTimesTotal=0              ! Default to empty l2gp
    end if

    if ( present(FillIn) ) then
      myFillIn = FillIn
    elseif ( present(proto) ) then
     myFillIn=.FALSE. ! fill in with values of proto
    else
      myFillIn = ALWAYSFILLWITHMISSINGVALUE
    endif

    ! Sanity
    useNTimesTotal = max(useNTimesTotal, useNTimes)
    if ( useNLevels > MAXNLEVELS ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & 'Too many levels in SetUpNewL2GPRecord')
    ! Store the dimensionality

    l2gp%nTimes = useNTimes
    l2gp%nTimesTotal = useNTimesTotal
    l2gp%nLevels = useNLevels
    l2gp%nFreqs = useNFreqs

    ! But allocate to at least one for times, freqs
 
    useNLevels=MAX(useNLevels,1)
    useNFreqs=MAX(useNFreqs,1)    

    ! Allocate the vertical coordinate
    l2gp%verticalCoordinate = 'Pressure'
    call allocate_test ( l2gp%pressures, useNLevels, "l2gp%pressures", &
         & ModuleName )

    ! Allocate the frequency coordinate
    
    call allocate_test ( l2gp%frequency, useNFreqs, "l2gp%frequency", ModuleName)

    ! Allocate the horizontal coordinates

    call allocate_test(l2gp%latitude,   useNTimes, "l2gp%latitude",   ModuleName)
    call allocate_test(l2gp%longitude,  useNTimes, "l2gp%longitude",  ModuleName)
    call allocate_test(l2gp%solarTime,  useNTimes, "l2gp%solarTime",  ModuleName)
    call allocate_test(l2gp%solarZenith,useNTimes, "l2gp%solarZenith",ModuleName)
    call allocate_test(l2gp%losAngle,   useNTimes, "l2gp%losAngle",   ModuleName)
    call allocate_test(l2gp%geodAngle,  useNTimes, "l2gp%geodAngle",  ModuleName)
    call allocate_test(l2gp%time,       useNTimes, "l2gp%time",       ModuleName)
    call allocate_test(l2gp%chunkNumber,useNTimes, "l2gp%chunkNumber",ModuleName)

    ! Allocate the data fields

    call allocate_test(l2gp%l2gpValue,useNFreqs,useNLevels,&
      & useNTimes,"l2gp%l2gpValue", ModuleName)
    call allocate_test(l2gp%l2gpPrecision,useNFreqs,useNLevels,&
      & useNTimes,"l2gp%l2gpPrecision", ModuleName)

    call allocate_test(l2gp%status, useNTimes,"l2gp%status", ModuleName)
    call allocate_test(l2gp%quality,useNTimes,"l2gp%quality",ModuleName)
    call allocate_test(l2gp%convergence,useNTimes,"l2gp%convergence",ModuleName)
    call allocate_test(l2gp%AscDescMode,useNTimes,"l2gp%AscDescMode",ModuleName)
    if ( myFillIn ) then
      l2gp%pressures    = l2gp%MissingValue
      l2gp%frequency    = l2gp%MissingValue
      l2gp%latitude     = l2gp%MissingValue
      l2gp%longitude    = l2gp%MissingValue
      l2gp%solarTime    = l2gp%MissingValue
      l2gp%solarZenith  = l2gp%MissingValue
      l2gp%losAngle     = l2gp%MissingValue
      l2gp%geodAngle    = l2gp%MissingValue
      l2gp%time         = l2gp%MissingValue
      l2gp%chunkNumber  = UndefinedIntegerValue
      l2gp%l2gpValue    = l2gp%MissingL2GP
      l2gp%l2gpPrecision= l2gp%MissingValue
      l2gp%status       = l2gp%MissingStatus ! l2gp%MissingValue
      l2gp%quality      = l2gp%MissingValue
      l2gp%convergence  = l2gp%MissingValue
      if ( AscDescModeIsField ) &
        & l2gp%AscDescMode    = 0
    elseif ( present(proto) ) then
      nn                = proto%nTimes
      l2gp%name         = proto%name
      l2gp%nameIndex    = proto%nameIndex
      ! l2gp%QUANTITYTYPE = proto%QUANTITYTYPE
      l2gp%MissingStatus= proto%MissingStatus
      l2gp%MissingL2GP  = proto%MissingL2GP
      l2gp%MissingValue = proto%MissingValue
      l2gp%pressures    = proto%pressures    
      l2gp%frequency    = proto%frequency
      if ( useNTimes > proto%nTimes ) then
        l2gp%latitude       (1:nn) = proto%latitude     
        l2gp%longitude      (1:nn) = proto%longitude    
        l2gp%solarTime      (1:nn) = proto%solarTime    
        l2gp%solarZenith    (1:nn) = proto%solarZenith  
        l2gp%losAngle       (1:nn) = proto%losAngle     
        l2gp%geodAngle      (1:nn) = proto%geodAngle    
        l2gp%time           (1:nn) = proto%time         
        l2gp%chunkNumber    (1:nn) = proto%chunkNumber  
        l2gp%l2gpValue      (:,:,1:nn) = proto%l2gpValue    
        l2gp%l2gpPrecision  (:,:,1:nn) = proto%l2gpPrecision
        l2gp%status         (1:nn) = proto%status       
        l2gp%quality        (1:nn) = proto%quality      
        l2gp%convergence    (1:nn) = proto%convergence  
        if ( AscDescModeIsField ) &
          & l2gp%AscDescMode      (1:nn) = proto%AscDescMode  
        if ( associated(proto%BinNumber) ) then
          allocate( l2gp%BinNumber(useNTimes) )
          l2gp%BinNumber    (1:nn) = proto%BinNumber 
        endif
        if ( associated(proto%MAF) ) then
          allocate( l2gp%MAF(useNTimes) )
          l2gp%MAF    (1:nn) = proto%MAF 
        endif
      elseif ( present( which ) ) then
        l2gp%latitude     = proto%latitude     (which)
        l2gp%longitude    = proto%longitude    (which)
        l2gp%solarTime    = proto%solarTime    (which)
        l2gp%solarZenith  = proto%solarZenith  (which)
        l2gp%losAngle     = proto%losAngle     (which) 
        l2gp%geodAngle    = proto%geodAngle    (which) 
        l2gp%time         = proto%time         (which) 
        l2gp%chunkNumber  = proto%chunkNumber  (which) 
        l2gp%l2gpValue    = proto%l2gpValue    (:,:,which)
        l2gp%l2gpPrecision= proto%l2gpPrecision(:,:,which)
        l2gp%status       = proto%status       (which)
        l2gp%quality      = proto%quality      (which)
        l2gp%convergence  = proto%convergence  (which)
        if ( AscDescModeIsField ) &
          & l2gp%AscDescMode    = proto%AscDescMode  (which)
      else
        l2gp%latitude     = proto%latitude     
        l2gp%longitude    = proto%longitude    
        l2gp%solarTime    = proto%solarTime    
        l2gp%solarZenith  = proto%solarZenith
        l2gp%losAngle     = proto%losAngle     
        l2gp%geodAngle    = proto%geodAngle    
        l2gp%time         = proto%time         
        l2gp%chunkNumber  = proto%chunkNumber  
        l2gp%l2gpValue    = proto%l2gpValue    
        l2gp%l2gpPrecision= proto%l2gpPrecision
        l2gp%status       = proto%status       
        l2gp%quality      = proto%quality      
        l2gp%convergence  = proto%convergence  
        if ( AscDescModeIsField ) &
          & l2gp%AscDescMode    = proto%AscDescMode  
        if ( associated(proto%BinNumber) ) then
          allocate( l2gp%BinNumber(useNTimes) )
          l2gp%BinNumber  = proto%BinNumber 
        endif
        if ( associated(proto%MAF) ) then
          allocate( l2gp%MAF(useNTimes) )
          l2gp%MAF        = proto%MAF 
        endif
      endif
    endif
  end subroutine SetupNewL2GPRecord

  !-----------------------------------------  DestroyL2GPContents  -----
  subroutine DestroyL2GPContents ( L2GP )

    ! This routine deallocates all the arrays allocated above.

    ! Dummy arguments
    type (L2GPData_T), intent(inout) :: L2GP

    ! Executable code

    call deallocate_test ( l2gp%pressures,     "l2gp%pressures",     ModuleName )
    call deallocate_test ( l2gp%latitude,      "l2gp%latitude",      ModuleName )
    call deallocate_test ( l2gp%longitude,     "l2gp%longitude",     ModuleName )
    call deallocate_test ( l2gp%solarTime,     "l2gp%solarTime",     ModuleName )
    call deallocate_test ( l2gp%solarZenith,   "l2gp%solarZenith",   ModuleName )
    call deallocate_test ( l2gp%losAngle,      "l2gp%losAngle",      ModuleName )
    call deallocate_test ( l2gp%geodAngle,     "l2gp%geodAngle",     ModuleName )
    call deallocate_test ( l2gp%chunkNumber,   "l2gp%chunkNumber",   ModuleName )
    call deallocate_test ( l2gp%time,          "l2gp%time",          ModuleName )
    call deallocate_test ( l2gp%frequency,     "l2gp%frequency",     ModuleName )
    call deallocate_test ( l2gp%l2gpValue,     "l2gp%l2gpValue",     ModuleName )
    call deallocate_test ( l2gp%l2gpPrecision, "l2gp%l2gpPrecision", ModuleName )
    call deallocate_test ( l2gp%status,        "l2gp%status",        ModuleName )
    call deallocate_test ( l2gp%quality,       "l2gp%quality",       ModuleName )
    call deallocate_test ( l2gp%convergence,   "l2gp%convergence",   ModuleName )
    call deallocate_test ( l2gp%AscDescMode,   "l2gp%AscDescMode",   ModuleName )
    call deallocate_test ( l2gp%BinNumber,     "l2gp%BinNumber",     ModuleName )
    call deallocate_test ( l2gp%MAF,           "l2gp%MAF        ",   ModuleName )
    l2gp%nTimes = 0
    l2gp%nTimesTotal = 0
    l2gp%nLevels = 0
    l2gp%nFreqs = 0

  end subroutine DestroyL2GPContents

  !-------------------------------------- ExpandL2GPDataInFile ---
  
  subroutine ExpandL2GPDataInFile( L2GPFile, swathName, l2gp )
    ! Repeated rewrite swathname until its numProfs >= l2gp%nTimes
    ! Args
    type(MLSFile_T) :: L2GPFile
    character(len=*), intent(in) :: swathName
    type (L2GPData_T), intent(inout) :: l2gp
    ! Internal variables
    logical :: done
    integer :: M
    integer :: ReadM
    integer, parameter :: MAXPASSES = 40
    integer, parameter :: METHOD = 1
    integer :: numProfs
    integer :: passes
    type (L2GPData_T) :: smallerl2gp, readl2gp
    ! Executable
    if ( L2GPFile%hdfVersion /= HDFVERSION_5 ) return
    M = l2gp%nTimes
    if ( M < 2 ) return
    if ( method == 1 ) then
      call ReadL2GPData( L2GPFile, swathName, readl2gp, numProfs, &
        & readData=.false. )
      ReadM = readl2gp%nTimes
      if(DEEBUG) call outputNamedValue( 'numProfs', numProfs )
      if(DEEBUG) call outputNamedValue( 'readl2gp%nTimes', readl2gp%nTimes )
      call DestroyL2GPContents ( readl2gp )
      if ( ReadM >= M ) return
      call ExtractL2GPRecord ( l2gp, smallerl2gp, rTimes=(/ M, M /) )
      call OutputL2GP_writeGeo_MF ( smallerl2gp, l2GPFile, &
        & swathName, offset=M-1 )
      call OutputL2GP_writeData_MF ( smallerl2gp, l2GPFile, &
        & swathName, offset=M-1 )
      call DestroyL2GPContents ( smallerl2gp )
      return
    endif
    done = .false.
    do passes=1, MAXPASSES
      call ReadL2GPData( L2GPFile, swathName, readl2gp, numProfs )
      ReadM = readl2gp%nTimes
      if(DEEBUG) call outputNamedValue( 'numProfs', numProfs )
      if(DEEBUG) call outputNamedValue( 'readl2gp%nTimes', readl2gp%nTimes )
      done = ( ReadM >= M )
      call DestroyL2GPContents ( readl2gp )
      if ( done ) return
      call ExtractL2GPRecord ( l2gp, smallerl2gp, rTimes=(/ ReadM+1, M /) )
      call OutputL2GP_writeGeo_MF ( smallerl2gp, l2GPFile, &
        & swathName, offset=ReadM )
      call OutputL2GP_writeData_MF ( smallerl2gp, l2GPFile, &
        & swathName, offset=ReadM )
      call DestroyL2GPContents ( smallerl2gp )
    enddo
    call MLSMessage ( MLSMSG_Error, ModuleName // '/ExpandL2GPDataInFile', &
      & "Failed to fit l2gp in file", MLSFile=L2GPFile )
  end subroutine ExpandL2GPDataInFile
  
  !---------------------------------------  ExpandL2GPDataInPlace  -----
  
  subroutine ExpandL2GPDataInPlace ( l2gp, newNTimes )

    ! This subroutine expands an L2GPData_T in place allowing the user to 
    ! (1) add more profiles to it; or
    ! 

    ! Dummy arguments
    type (L2GPData_T), intent(inout) :: l2gp
    integer, optional, intent(in)    :: newNTimes

    ! Local variables
    type (L2GPData_T) :: tempL2gp       ! For copying data around
    integer :: myNTimes
    integer :: tmpNFreqs, tmpNLevels

    ! Executable code

   if(present(newNTimes)) then
      myNTimes = newNTimes
   else
      myNTimes = l2gp%nTimes
   endif

    ! First do a sanity check


    if ( myNTimes<l2gp%nTimes ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
         & "The number of profiles requested is fewer than those already present" )
    endif

    tempL2gp = l2gp ! Copy the pointers to the old information

    ! Now recreate l2gp with the new size.
    ! First, nullify all of the pointers in l2gp, so that a deallocate_test
    ! won't delete them.  After all, we just went to the trouble to preserve
    ! them in TempL2GP!
    nullify ( l2gp%pressures, l2gp%latitude, l2gp%longitude, l2gp%solarTime, &
      & l2gp%solarZenith, l2gp%losAngle, l2gp%losAngle, l2gp%geodAngle, &
      & l2gp%chunkNumber, l2gp%time, l2gp%frequency, l2gp%l2gpValue, &
      & l2gp%l2gpPrecision, l2gp%status, l2gp%quality, l2gp%convergence, &
      & l2gp%AscDescMode )
    
    tmpNFreqs = l2gp%nFreqs
    tmpNLevels = l2gp%nLevels
    call SetupNewL2GPRecord( l2gp, nFreqs=tmpNFreqs, nLevels=tmpNLevels, &
      & nTimes=myNTimes, FillIn = .true. )

    ! Don't forget the `global' stuff
    l2gp%pressures=templ2gp%pressures
    l2gp%frequency=templ2gp%frequency
    l2gp%verticalCoordinate = templ2gp%verticalCoordinate

    ! Now go through the parameters one by one, and copy the previous contents
    l2gp%latitude(1:templ2gp%nTimes) = templ2gp%latitude(1:templ2gp%nTimes)
    l2gp%longitude(1:templ2gp%nTimes) = templ2gp%longitude(1:templ2gp%nTimes)
    l2gp%solarTime(1:templ2gp%nTimes) = templ2gp%solarTime(1:templ2gp%nTimes)
    l2gp%solarZenith(1:templ2gp%nTimes) = templ2gp%solarZenith(1:templ2gp%nTimes)
    l2gp%losAngle(1:templ2gp%nTimes) = templ2gp%losAngle(1:templ2gp%nTimes)
    l2gp%geodAngle(1:templ2gp%nTimes) = templ2gp%geodAngle(1:templ2gp%nTimes)
    l2gp%time(1:templ2gp%nTimes) = templ2gp%time(1:templ2gp%nTimes)
    l2gp%chunkNumber(1:templ2gp%nTimes) = templ2gp%chunkNumber(1:templ2gp%nTimes)

    l2gp%l2gpValue(:,:,1:templ2gp%nTimes) = templ2gp%l2gpValue(:,:,1:templ2gp%nTimes)
    l2gp%l2gpPrecision(:,:,1:templ2gp%nTimes) = &
         templ2gp%l2gpPrecision(:,:,1:templ2gp%nTimes)
    
    l2gp%status(1:templ2gp%nTimes) = templ2gp%status(1:templ2gp%nTimes)
    l2gp%quality(1:templ2gp%nTimes) = templ2gp%quality(1:templ2gp%nTimes)
    l2gp%convergence(1:templ2gp%nTimes) = templ2gp%convergence(1:templ2gp%nTimes)
    if ( AscDescModeIsField ) &
      & l2gp%AscDescMode(1:templ2gp%nTimes) = templ2gp%AscDescMode(1:templ2gp%nTimes)
    
    ! Deallocate the old arrays
    call DestroyL2GPContents(templ2gp)

  end subroutine ExpandL2GPDataInPlace

  !-------------------------------------------  AddL2GPToDatabase  -----
  integer function AddL2GPToDatabase( DATABASE, ITEM )

    ! This function adds an l2gp data type to a database of said types,
    ! creating a new database if it doesn't exist.  The result value is
    ! the size -- where L2gp is put.

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type (l2gpdata_t), dimension(:), pointer :: DATABASE
    type (l2gpdata_t), intent(in) :: ITEM

    ! Local variables
    type (l2GPData_T), dimension(:), pointer :: tempDatabase
    !This include causes real trouble if you are compiling in a different 
    !directory.
    include "addItemToDatabase.f9h" 

    AddL2GPToDatabase = newSize
  end function AddL2GPToDatabase

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a quantity template database

  subroutine DestroyL2GPDatabase ( DATABASE )

    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use Toggles, only: Gen, Toggle
    use Trace_m, only: Trace_Begin, Trace_End
    ! Dummy argument
    type (l2GPData_T), dimension(:), pointer :: DATABASE

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: l2gpIndex, s, status
    integer :: Me = -1       ! String index for trace

    call trace_begin ( me, "DestroyL2GPDatabase", cond=toggle(gen) )

    if ( associated(database) ) then
       do l2gpIndex = 1, SIZE(database)
          call DestroyL2GPContents ( database(l2gpIndex) )
       end do
       s = size(database) * storage_size(database) / 8
       addr = 0
       if ( s > 0 ) addr = transfer(c_loc(database(1)), addr)
       deallocate ( database, stat=status )
       call test_deallocate ( status, ModuleName, "database", s, Address=addr )
    end if
    call trace_end ( "DestroyL2GPDatabase", cond=toggle(gen) )
  end subroutine DestroyL2GPDatabase

  ! ---------------------- ReadL2GPData_fileID  -----------------------------

  subroutine ReadL2GPData_fileID(L2FileHandle, swathname, l2gp, numProfs, &
       firstProf, lastProf, hdfVersion, HMOT, ReadData)
    !------------------------------------------------------------------------

    ! Given a file handle,
    ! This routine reads an L2GP file, in either hdfVersion,
    ! returning a filled data structure and the !
    ! number of profiles read.
    ! if present, hdfVersion must be one of HDFVERSION_4, HDFVERSION_5

    ! Arguments

    character (len=*), intent(in) :: swathname ! Name of swath
    integer, intent(in) :: L2FileHandle ! Returned by swopen
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: l2gp ! Result
    integer, intent(out), optional :: numProfs ! Number actually read
    integer, optional, intent(in) :: hdfVersion
    character, optional, intent(in) :: hmot   ! 'H' 'M'(def) 'O' 'T'
    logical, optional, intent(in) :: ReadData

    ! Local
    integer :: myhdfVersion
    integer :: status
    type( MLSFile_T ) :: l2gpFile
    
    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L2GPDEFAULT_HDFVERSION
    endif
    status = InitializeMLSFile(l2gpFile, type=l_swath, access=DFACC_RDONLY, &
      & content='l2gp', name='unknown', hdfVersion=myhdfVersion)
    l2gpFile%FileID%f_id = l2FileHandle
    l2gpFile%stillOpen = .true.
    call ReadL2GPData(l2gpFile, swathname, l2gp, numProfs, &
       firstProf, lastProf, HMOT, ReadData)
  end subroutine ReadL2GPData_fileID

  ! ---------------------- ReadL2GPData_fileName  -----------------------------

  subroutine ReadL2GPData_fileName(fileName, swathname, l2gp, numProfs, &
       firstProf, lastProf, hdfVersion, HMOT, ReadData)
    !------------------------------------------------------------------------

    ! Given a file name,
    ! This routine reads an L2GP file, in either hdfVersion,
    ! returning a filled data structure and the !
    ! number of profiles read.
    ! hdfVersion may be WILDCARDHDFVERSION

    ! Arguments

    character (len=*), intent(in) :: swathname ! Name of swath
    character (len=*), intent(in) :: fileName ! Name of swath
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: l2gp ! Result
    integer, intent(out), optional :: numProfs ! Number actually read
    integer, optional, intent(in) :: hdfVersion
    character, optional, intent(in) :: hmot   ! 'H' 'M'(def) 'O' 'T'
    logical, optional, intent(in) :: ReadData

    ! Local
    integer :: L2FileHandle
    type(MLSFile_T)                :: MLSFile
    integer :: status
    integer :: the_hdfVersion
    
    ! Executable code
    the_hdfVersion = mls_hdf_version(FileName, hdfVersion)
    if ( the_hdfVersion == FILENOTFOUND ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'File not found; make sure the name and path are correct' &
        & // trim(fileName) )

    status = InitializeMLSFile ( MLSFile, type=l_swath, access=DFACC_READ, &
     & name=trim(fileName), HDFVersion=the_hdfVersion )
    call MLS_OpenFile( MLSFile )
    L2FileHandle = MLSFile%FileID%f_id
    call ReadL2GPData_fileID(L2FileHandle, swathname, l2gp, numProfs=numProfs, &
       & firstProf=firstProf, lastProf=lastProf, hdfVersion=the_hdfVersion, &
       & hmot=hmot, ReadData=ReadData)
    call MLS_CloseFile( MLSFile )
  end subroutine ReadL2GPData_fileName

  ! ---------------------- ReadL2GPData_MLSFile  -----------------------------

  subroutine ReadL2GPData_MLSFile(L2GPFile, swathname, l2gp, numProfs, &
       firstProf, lastProf, HMOT, ReadData)
    !------------------------------------------------------------------------

    ! Given a file,
    ! This routine reads an L2GP structure, in either hdfVersion,
    ! returning a filled data structure and the !
    ! number of profiles read.
    ! if present, hdfVersion must be one of HDFVERSION_4, HDFVERSION_5

    ! Arguments

    character (len=*), intent(in) :: swathname ! Name of swath
    type(MLSFile_T)                :: L2GPFile
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: l2gp ! Result
    integer, intent(out), optional :: numProfs ! Number actually read
    character, optional, intent(in) :: hmot   ! 'H' 'M'(def) 'O' 'T'
    logical, optional, intent(in) :: ReadData

    ! Local
    logical :: alreadyOpen
    character :: my_hmot
    integer :: status
    
    ! Executable code
    my_hmot = 'M'
    if ( present(hmot)) my_hmot = Capitalize(hmot)
    ! Check for valid hmot
    select case (my_hmot)
    case ('H')
    case ('M')
    case ('O')
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unable to Read OMI L2GPData", MLSFile=L2GPFile )
    case ('T')
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unable to Read TES L2GPData", MLSFile=L2GPFile )
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unrecognized instrument key passed to ReadL2GPData: "// my_hmot, &
      & MLSFile=L2GPFile )
    end select
    status = 0
    alreadyOpen = L2GPFile%stillOpen
    if ( .not. alreadyOpen ) then
      call mls_openFile(L2GPFile, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l2gp file', MLSFile=L2GPFile)
    endif
    if (L2GPFile%hdfVersion == HDFVERSION_4) then
      call ReadL2GPData_MF_hdf(L2GPFile, swathname, l2gp, my_hmot,&
        & numProfs, firstProf, lastProf, ReadData)
    elseif (L2GPFile%hdfVersion /= HDFVERSION_5) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unrecognized hdfVersion passed to ReadL2GPData", MLSFile=L2GPFile )
    else
      call ReadL2GPData_MF_hdf(L2GPFile, swathname, l2gp, my_hmot,&
        & numProfs, firstProf, lastProf, ReadData)
    endif
    if ( .not. alreadyOpen )  call mls_closeFile(L2GPFile, Status)
    L2GPFile%errorCode = status
    L2GPFile%lastOperation = 'read'
  end subroutine ReadL2GPData_MLSFile

  ! ------------------- ReadL2GPData_MF_hdf ----------------

  subroutine ReadL2GPData_MF_hdf(L2GPFile, swathname, l2gp, HMOT, &
    & numProfs, firstProf, lastProf, ReadData)
  use HDFEOS, only: SWInqdims
  use HDFEOS5, only: HE5_SWInqdims, HE5_SWInqdflds, HE5_SWFldinfo
  use HE5_SWAPI, only: HE5_SWRdlattr
  use MLSHDFEOS, only: MLS_SWAttach, MLS_SWDetach, MLS_SWDiminfo, MLS_SWRdfld
  use MLSStringLists, only: IsInList
  use HDF5, only: Size_T
    !------------------------------------------------------------------------

    ! This routine reads an L2GP file, returning a filled data structure and the !
    ! number of profiles read.

    ! All the ReadConvergence harrumphing is because convergence is newly added
    ! (Some older files won't have this field)
    ! Arguments

    character (len=*), intent(in) :: swathname ! Name of swath
    type(MLSFile_T)                :: L2GPFile
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( L2GPData_T ), intent(out) :: l2gp ! Result
    character, intent(in) :: HMOT   ! 'H' 'M'(def) 'O' 'T'
    integer, intent(out),optional :: numProfs ! Number actually read
    logical, optional, intent(in) :: ReadData

    ! Local Parameters
    character (len=*), parameter :: MLSMSG_INPUT = 'Error in input argument '
    integer, parameter           :: MAXDIMSIZE = 4
    ! Local Variables
    character (len=80) :: DF_Name
    character (len=80) :: DF_Precision
    character (len=80) :: dimlist
    character (len=80) :: fieldlist
    character (len=80) :: list
    character (len=80) :: maxdimlist
    character (len=8)  :: maxdimName
    integer :: hdfVersion
    integer :: rank
    integer, dimension(MAXFNFIELDS) :: ranks
    integer, dimension(MAXFNFIELDS) :: types
    integer, dimension(7) :: numberType
    integer, dimension(7) :: flddims
    integer(kind=size_t), dimension(7) :: hflddims
    character (len=480) :: msr

    integer, dimension(MAXDIMSIZE) :: dims
    integer :: first, freq, lev, nDims, nFlds, size, swid, status
    integer(kind=size_t), dimension(MAXDIMSIZE) :: hdims
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: nFreqs, nLevels, nTimes, nFreqsOr1, nLevelsOr1, myNumProfs
    integer, dimension(3) :: start, stride, edge
    logical :: firstCheck, lastCheck

    real(r4), pointer, dimension(:) :: REALFREQ
    real(r4), pointer, dimension(:) :: REALSURF
    real(r4), pointer, dimension(:) :: REALPROF
    real(r4), pointer, dimension(:,:,:) :: REAL3
    logical :: deeBugHere
    logical :: dontfail
    logical :: ReadingConvergence
    logical :: ReadingAscDescMode
    logical :: ReadingData
    logical :: ReadingBinNumber
    logical :: ReadingMAF
    real(rgp), dimension(1) :: MissingValue
    ! Executable code
    call trace_begin ( me,  'ReadL2GPData_MF_hdf', cond=.false. )
    deeBugHere = DEEBUG ! .or. .true.
    nullify ( realFreq, realSurf, realProf, real3 )
    hdfVersion = L2GPFile%hdfVersion
    flddims = 0
    ! Don't fail when trying to read an mls-specific field 
    ! if the file is from another Aura instrument
    dontfail = (HMOT /= 'M')
    ReadingData = .true.
    if ( present(ReadData) ) ReadingData = ReadData
    ReadingConvergence = .false.
    ReadingAscDescMode = .false.
    ReadingBinNumber   = .false.
    ReadingMAF         = .false.
    ! Attach to the swath for reading
    l2gp%Name = swathname
    ! We have suffered surprises when hefeos character fields 
    ! were not initialized
    dimlist = ' '
    fieldlist = ' '
    list = ' '
    
    select case (HMOT)
    case ('H')
      swid = mls_SWattach( L2GPFile, 'HIRDLS' )
      DF_Name = TRIM(l2gp%Name)
      DF_Precision = TRIM(l2gp%Name) // 'Precision'
      l2gp%MissingL2GP = -999.  ! This is a HIRDLS-specific setting
    case ('M')
      swid = mls_SWattach( L2GPFile, l2gp%Name )
      DF_Name = DATA_FIELD1
      DF_Precision = DATA_FIELD2
      if ( deeBugHere ) print *, 'DF_NAME: ',DF_NAME
      if ( deeBugHere ) print *, 'DF_Precision: ',DF_Precision
      ! Here we read the MissingValue attribute
      ! If we can't for any reason, it retains its default value
      if ( hdfVersion == HDFVERSION_5 ) then
        status = &
          & he5_swrdlattr( swid, 'L2gpValue', 'MissingValue', MissingValue )
        if ( status /= 0 ) then
          call MLSMessage( MLSMSG_Warning, ModuleName, &
         &'Failed to read Missing Value attribute for ' &
         & // trim(swathname), MLSFile=L2GPFile )
        else
          l2gp%MissingL2GP = MissingValue(1)
        endif
      endif
    case default
    end select
    if (swid == -1) call MLSMessage(MLSMSG_Error, ModuleName, &
         &'Failed to attach to hdfeos2/5 swath interface for reading' &
         & // trim(swathname), MLSFile=L2GPFile)

    ! Get dimension information

    lev = 0
    freq = 0

    if( hdfVersion == HDFVERSION_4 ) then
      nDims = swinqdims(swid, list, dims)
    else
      nDims = HE5_SWinqdims(swid, list, hdims)
      nDims = min( nDims, MAXDIMSIZE )
      dims(1:nDims) = hdims(1:nDims)                                  
      if ( nDims < MAXDIMSIZE ) dims(nDims+1:) = 0 ! Just to make sure they're defined, not junk
      nFlds = HE5_SWinqdflds( swid, fieldlist, ranks, types )
      ReadingConvergence = isInList( lowerCase(fieldList), 'convergence', '-fc' )
      ReadingAscDescMode = isInList( lowerCase(fieldList), 'AscDescMode', '-fc' )
      ReadingBinNumber   = isInList( lowerCase(fieldList), 'BinNumber'  , '-fc' )
      ReadingMAF         = isInList( lowerCase(fieldList), 'MAF'        , '-fc' )
    endif
    if ( deeBugHere ) print *, 'HMOT: ', HMOT
    if ( deeBugHere ) print *, 'swathName: ', l2gp%name
    if ( deeBugHere ) print *, 'dimlist: ', trim(list)
    if ( deeBugHere ) print *, 'ndims: ', ndims
    if ( deeBugHere ) print *, 'DF_NAME: ',DF_NAME
    if ( deeBugHere ) print *, 'DF_Precision: ',DF_Precision
    if ( deeBugHere ) print *, 'DATA_FIELD1: ', DATA_FIELD1
    if ( deeBugHere ) print *, 'dims: ', dims
    if ( deeBugHere ) print *, 'swathName: ', l2gp%name
    if ( deeBugHere ) print *, 'fieldlist: ', trim(fieldlist)
    if ( deeBugHere ) print *, 'ReadBin:   ', ReadingBinNumber
    if ( deeBugHere ) print *, 'ReadMAF:   ', ReadingMAF      
    if (nDims == -1) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed to get dimension information on hdfeos5 swath ' // &
      & trim(swathname), MLSFile=L2GPFile)
    if ( index(list,'nLevels') /= 0 ) lev = 1
    if ( index(list,'Freq') /= 0 ) freq = 1

    size = mls_swdiminfo(swid, 'nTimes', hdfVersion=hdfVersion)
    if ( deeBugHere ) print *, 'size--1st try: ', size
    if ( hdfVersion == HDFVERSION_5 ) then
      ! This will be wrong if timeIsUnlim .eq. .TRUE. . 
      ! HE5_SWdiminfo returns 1 instead of the right answer.
      status = HE5_swfldinfo(swid, trim(DF_Name), rank, hflddims, &
        & numberType, dimlist, maxdimlist)
      call GetHashElement (dimlist, &
       & maxdimlist, 'nTimes', &
       & maxDimName, .false.)
      if ( deeBugHere ) print *, 'flddims: ', flddims
      if ( deeBugHere ) print *, 'dimlist: ', trim(dimlist)
      if ( deeBugHere ) print *, 'maxdimlist: ', trim(maxdimlist)
      if ( maxDimName == 'Unlim' ) then
        status = StringElementNum(dimlist, 'nTimes', .false.)
        if ( status > 0 .and. status <= rank ) then
          flddims(1:rank) = hflddims(1:rank)
          size = max(size, flddims(status))
        endif
      endif
    endif
    l2gp%nTimes = size
    l2gp%nTimesTotal = size
    nTimes=size

    if (lev == 0) then
       nLevels = 0
    else
      size = mls_swdiminfo(swid, 'nLevels', hdfVersion=hdfVersion)
       nLevels = size

    endif

    if ( freq == 1 .and. HMOT == 'M') then
      size = mls_swdiminfo(swid, 'nFreqs', hdfVersion=hdfVersion)
       nFreqs = size
    elseif ( freq == 1 .and. HMOT == 'H') then
      size = mls_swdiminfo(swid, 'nChans', hdfVersion=hdfVersion)
      nFreqs = size
    else
       nFreqs = 0
    endif

    ! Check optional input arguments

    firstCheck = present(firstProf)
    lastCheck = present(lastProf)

    if (firstCheck) then
      ! Note that if time is an umlimited dimension, HDF-EOS won't 
      ! nTimes is wrong.
       if ( (firstProf >= l2gp%nTimes) &
         .or. (firstProf < 0) ) then
          msr = MLSMSG_INPUT // 'firstProf'
          call MLSMessage(MLSMSG_Error, ModuleName, msr, MLSFile=L2GPFile)
       else
          first = firstProf
       endif

    else

       first = 0

    endif

    if (lastCheck) then

       if (lastProf < first) then
          msr = MLSMSG_INPUT // 'lastProf'
          call MLSMessage(MLSMSG_Error, ModuleName, msr, MLSFile=L2GPFile)
       endif

       ! If user has supplied "last" _and_ time is unlimited, we have
       ! to believe the user about how many profiles there are.
       ! This is _crap_ and is a temporary workaround. 
!       if(timeIsUnlim) then
!         myNumProfs = lastProf - first + 1
!         nTimes=lastprof-first+1
!         l2gp%nTimes=nTimes
!       endif
       if (lastProf >= nTimes) then
          myNumProfs = nTimes - first
       else
          myNumProfs = lastProf - first + 1
       endif

    else

       myNumProfs = l2gp%nTimes - first

    endif

    ! Allocate result
    if ( deeBugHere ) then
      print *, 'nFreqs: ', nFreqs
      print *, 'nLevels: ', nLevels
      print *, 'mynumProfs: ', mynumProfs
    endif
    call SetupNewL2GPRecord (l2gp, nFreqs=nFreqs, nLevels=nLevels, &
      &  nTimes=mynumProfs, FillIn = .true.)

    ! Skip reading any of the data?
    if ( .not. readingData ) then
      status = mls_SWdetach(swid, hdfVersion=hdfVersion)
      if (status == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
           &detach from swath interface after reading.', MLSFile=L2GPFile)
      if (present(numProfs)) numProfs=myNumProfs
      call trace_end (  'ReadL2GPData_MF_hdf', cond=.false. )
      if(DEEBUG) call outputNamedValue( 'no data read; nTimes', myNumProfs )
      return
    endif
    ! Allocate temporary arrays

    nFreqsOr1=max(nFreqs,1)
    nLevelsOr1=max(nLevels, 1)

    call Allocate_test ( realProf, myNumProfs, 'realProf', ModuleName )
    call Allocate_test ( realSurf, l2gp%nLevels, 'realSurf', ModuleName )
    call Allocate_test ( realFreq, l2gp%nFreqs, 'realFreq', ModuleName )
    call Allocate_test ( real3, nFreqsOr1, nLevelsOr1, myNumProfs, 'real3', ModuleName )

    ! Read the horizontal geolocation fields

    start(1) = 0
    start(2) = 0
    start(3) = first
    stride = 1
    edge(1) = nFreqsOr1
    edge(2) = nLevelsOr1
    edge(3) = myNumProfs
    status=0

    status = mls_SWrdfld(swid, 'Latitude', start(3:3), stride(3:3), &
      edge(3:3), realProf, hdfVersion=hdfVersion)
    l2gp%latitude = realProf

    status = mls_SWrdfld(swid, 'Longitude', start(3:3), stride(3:3), edge(3:3),&
      &    realProf, hdfVersion=hdfVersion)
    l2gp%longitude = realProf

    status = mls_SWrdfld(swid, 'Time', start(3:3), stride(3:3), edge(3:3),&
      &    l2gp%time, hdfVersion=hdfVersion)

    status = mls_SWrdfld(swid, 'LocalSolarTime', start(3:3), stride(3:3), edge(3:3),&
      &    realProf, hdfVersion=hdfVersion)
    l2gp%solarTime = realProf

    status = mls_SWrdfld(swid, 'SolarZenithAngle', start(3:3), stride(3:3), edge(3:3),&
      &    realProf, hdfVersion=hdfVersion)
    l2gp%solarZenith = realProf

    ! These next 3 are MLS-specific
    if ( HMOT == 'M' ) then
    status = mls_SWrdfld(swid, 'LineOfSightAngle', start(3:3), stride(3:3), edge(3:3),&
      &    realProf, hdfVersion=hdfVersion, dontfail=dontfail)
    l2gp%losAngle = realProf

    status = mls_SWrdfld(swid, 'OrbitGeodeticAngle', start(3:3), stride(3:3), edge(3:3),&
      &   realProf, hdfVersion=hdfVersion, dontfail=dontfail)
    l2gp%geodAngle = realProf

    status = mls_SWrdfld(swid, 'ChunkNumber', start(3:3), stride(3:3), edge(3:3),&
      &    l2gp%chunkNumber, hdfVersion=hdfVersion, dontfail=dontfail)

    endif
    ! Read the pressures vertical geolocation field, if it exists

    if (lev /= 0) then
       status = mls_SWrdfld(swid,'Pressure',start(2:2),stride(2:2), edge(2:2),&
         & realSurf, hdfVersion=hdfVersion, dontfail=dontfail)
       l2gp%pressures = realSurf
    endif

    ! Read the frequency geolocation field, if it exists

    if (freq == 1) then

       edge(1) = l2gp%nFreqs

       status = mls_SWrdfld(swid,'Frequency',start(1:1),stride(1:1),edge(1:1),&
         & realFreq, hdfVersion=hdfVersion, dontfail=dontfail)
       l2gp%frequency = realFreq

    endif

    ! Read the data fields that may have 1-3 dimensions

    if ( freq == 1) then

       status = mls_SWrdfld(swid, trim(DF_Name), start, stride, edge, real3, &
         & hdfVersion=hdfVersion)
       l2gp%l2gpValue = real3

       status = mls_SWrdfld(swid, trim(DF_Precision), start, stride, edge, real3, &
         & hdfVersion=hdfVersion)
       l2gp%l2gpPrecision = real3

    else if ( lev == 1) then

       status = mls_SWrdfld( swid, trim(DF_Name), start(2:3), stride(2:3), &
            edge(2:3), real3(1,:,:), hdfVersion=hdfVersion )
       l2gp%l2gpValue = real3

       status = mls_SWrdfld( swid, trim(DF_Precision), start(2:3), stride(2:3), &
            edge(2:3), real3(1,:,:), hdfVersion=hdfVersion )
       l2gp%l2gpPrecision = real3

    else

       status = mls_SWrdfld(swid,trim(DF_Name),start(3:3),stride(3:3),edge(3:3),&
         &   real3(1,1,:), hdfVersion=hdfVersion )
       l2gp%l2gpValue = real3

       status = mls_SWrdfld( swid, trim(DF_Precision), start(3:3), stride(3:3), edge(3:3), &
            real3(1,1,:), hdfVersion=hdfVersion )
       l2gp%l2gpPrecision = real3

    endif
    
    ! Read the data fields that are 1-dimensional

    l2gp%status = l2gp%MissingStatus ! l2gp%MissingValue ! So it has a value.
    status = mls_swrdfld( swid, 'Status',start(3:3),stride(3:3),edge(3:3),&
      & l2gp%status, hdfVersion=hdfVersion, dontfail=.true. )

    if ( HMOT == 'M' ) then
      status = mls_SWrdfld(swid, 'Quality', start(3:3), stride(3:3),&
        edge(3:3),realProf, hdfVersion=hdfVersion, dontfail=dontfail)
      l2gp%quality = realProf
    endif

    l2gp%Convergence = l2gp%MissingValue ! l2gp%MissingValue ! So it has a value.
    if ( ReadingConvergence ) &
      & status = mls_swrdfld( swid, 'Convergence',start(3:3),stride(3:3),edge(3:3),&
      & l2gp%convergence, hdfVersion=hdfVersion, dontfail=.true. )

    if ( AscDescModeIsField ) then
      l2gp%AscDescMode = 0 ! l2gp%MissingValue ! So it has a value.
      if ( ReadingAscDescMode ) &
        & status = mls_swrdfld( swid, 'AscDescMode ',start(3:3),stride(3:3),edge(3:3),&
        & l2gp%AscDescMode, hdfVersion=hdfVersion, dontfail=.true. )
    endif

    if ( ReadingBinNumber ) then
      allocate( l2gp%BinNumber(myNumProfs) )
      status = mls_swrdfld( swid, 'BinNumber',start(3:3),stride(3:3),edge(3:3),&
      & l2gp%BinNumber, hdfVersion=hdfVersion, dontfail=.true. )
    endif

    if ( ReadingMAF ) then
      allocate( l2gp%MAF(myNumProfs) )
      status = mls_swrdfld( swid, 'MAF',start(3:3),stride(3:3),edge(3:3),&
      & l2gp%MAF, hdfVersion=hdfVersion, dontfail=.true. )
    endif

    ! Deallocate local variables
    call Deallocate_test ( realProf, 'realProf', ModuleName )
    call Deallocate_test ( realSurf, 'realSurf', ModuleName )
    call Deallocate_test ( realFreq, 'realFreq', ModuleName )
    call Deallocate_test ( real3, 'real3', ModuleName )

    !  After reading, detach from HE5_SWath interface
    status = mls_SWdetach(swid, hdfVersion=hdfVersion)
    if (status == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &detach from swath interface after reading.', MLSFile=L2GPFile)
    !print*," leaving ReadL2GPData_hdf: first/last/read=",&
    !  firstprof,lastprof,myNumProfs
    ! Set numProfs if wanted
    if (present(numProfs)) numProfs=myNumProfs
    call trace_end (  'ReadL2GPData_MF_hdf', cond=.false. )

  end subroutine ReadL2GPData_MF_hdf

  !----------------------------------------  writeL2GPData_fileID  -----
  ! This subroutine is an amalgamation of the last three
  ! Should be renamed CreateAndWriteL2GPData
  subroutine writeL2GPData_fileID(l2gp, l2FileHandle, swathName, hdfVersion, &
    & notUnlimited)

    ! Arguments

    integer, intent(in) :: l2FileHandle ! From swopen
    type (L2GPData_T), intent(INOUT) :: l2gp
    character (len=*), optional, intent(in) ::swathName!default->l2gp%swathName
    integer, optional, intent(in) :: hdfVersion
    logical, optional, intent(in) :: notUnlimited
    ! Exectuable code

    ! Local
    integer :: myhdfVersion
    integer :: status
    type( MLSFile_T ) :: l2gpFile

    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L2GPDEFAULT_HDFVERSION
    endif

    status = InitializeMLSFile(l2gpFile, type=l_swath, access=DFACC_RDWR, &
      & content='l2gp', name='unknown', hdfVersion=myhdfVersion)
    l2gpFile%FileID%f_id = l2FileHandle
    l2gpFile%stillOpen = .true.
    call WriteL2GPData( l2gp, l2gpFile, swathName, notUnlimited )

  end subroutine writeL2GPData_fileID

  ! --------------------------------------  OutputL2GP_createFile_MF  -----
  subroutine OutputL2GP_createFile_MF (l2gp, L2GPFile, &
    & swathName, nLevels, notUnlimited, compressTimes)

  use HDFEOS5, only: HE5S_Unlimited_F
  use MLSHDFEOS, only: MLS_SWDetach, &
    & MLS_Swcreate, MLS_DFldsetup, MLS_GFldsetup, MLS_SWDefdim
    ! Brief description of subroutine
    ! This subroutine sets up the structural definitions in an empty L2GP file.

    ! Arguments
    type(MLSFile_T)                :: L2GPFile
    type( L2GPData_T ), intent(inout) :: l2gp
    character (len=*), optional, intent(in) :: swathName ! Defaults to l2gp%swathName
    integer, optional, intent(in) :: nLevels
    logical, optional, intent(in) :: notUnlimited   !               as nTimes
    logical, optional, intent(in) :: compressTimes  ! don't store nTimesTotal

    ! Variables

    character (len=132) :: NAME   ! From l2gp%name
    character (len=32) :: MYDIM1, MYDIM12, MYDIM123

    ! THESE ARE HDF5 CHUNKS, _NOT_ MLS ALONG-TRACK PROCESSING CHUNKS 
    integer,dimension(7)::CHUNK_DIMS
    integer::CHUNK_RANK
    integer::CHUNKTIMES,CHUNKFREQS,CHUNKLEVELS
    integer :: hdfVersion

    integer :: SWID, STATUS
    logical :: myNotUnlimited
    logical :: mycompressTimes
    logical :: deebughere
    ! Executable
    deebughere = DEEBUG ! .or. .TRUE.
    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
    endif
    myNotUnlimited = .false.
    if ( present ( notUnlimited ) ) myNotUnlimited = notUnlimited
    mycompressTimes = .false.
    if ( present (compressTimes ) ) mycompressTimes = compressTimes
    hdfVersion = L2GPFile%hdfVersion
    
    ! Work out the chunking
    if ( myNotUnlimited ) then
      chunkTimes = max ( min ( MAXCHUNKTIMES, l2gp%nTimes ), 1 )
    else
      chunktimes = MAXCHUNKTIMES      ! was 1
    endif
    chunkfreqs = max ( l2gp%nFreqs, 1)
    if(present(nLevels))then
       chunklevels = nLevels
    else
      chunklevels = min(l2gp%nLevels, 500)     ! was .., 5)
      chunklevels = max(chunklevels, 1)
    endif
    
    ! Create the swath within the file

    if ( deebughere )  print *, 'About to sw_create ', TRIM(name)
    if ( deebughere )  print *, 'myNotUnlimited ', myNotUnlimited
    if ( deebughere )  print *, 'l2gp%MissingL2GP ', l2gp%MissingL2GP
    if ( deebughere )  print *, 'l2gp%MissingValue ', l2gp%MissingValue
    ! swid = mls_SWcreate(L2GPFile%FileID%f_id, trim(name), &
    swid = mls_SWcreate(L2GPFile, trim(name) )
    if ( swid == -1 ) then
       call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Failed to create swath ' // TRIM(name) &
        & // ' (maybe has the same name as another swath in this file?)', &
            & MLSFile=L2GPFile )
    end if

    ! Define dimensions

    if ( L2GPFile%hdfVersion == HDFVERSION_5 .and. .not. myNotUnlimited ) then
      ! Defining special "unlimited dimension called UNLIM
      ! print*,"Defined Unlim with size", HE5S_UNLIMITED_f
      status = mls_swdefdim(swid, UNLIM, HE5S_UNLIMITED_F, &
        & hdfVersion=hdfVersion)
    endif

    if ( myNotUnlimited ) then
      myDim1 = DIM_NAME1
      myDim12 = DIM_NAME12
      myDim123 = DIM_NAME123
    else
      myDim1 = MAX_DIML1
      myDim12 = MAX_DIML12
      myDim123 = MAX_DIML123
    endif
    if ( deebughere ) then
      print *, 'myDim1 ', myDim1
      print *, 'myDim12 ', myDim12
      print *, 'myDim123 ', myDim123
      print *, 'nTimes ', l2gp%nTimes
      print *, 'nTimesTotal ', l2gp%nTimesTotal
      print *, 'nLevels ', l2gp%nLevels
      print *, 'nFreqs ', l2gp%nFreqs
    endif
    if ( mycompressTimes ) then
      if ( deebughere ) call outputNamedValue ('nTimes',  max(l2gp%nTimes,1) )
      status = mls_swdefdim(swid, 'nTimes', max(l2gp%nTimes,1), &
        & hdfVersion=hdfVersion)
    else
      if ( deebughere ) call outputNamedValue ('nTimes',  max(l2gp%nTimesTotal,1) )
      status = mls_swdefdim(swid, 'nTimes', max(l2gp%nTimesTotal,1), &
        & hdfVersion=hdfVersion)
    endif
    status = mls_swdefdim(swid, 'nTimesTotal', max(l2gp%nTimesTotal,1), &
      & hdfVersion=hdfVersion)

    if ( l2gp%nLevels > 0 ) then
      status = mls_swdefdim(swid, 'nLevels', l2gp%nLevels, &
        & hdfVersion=hdfVersion)
    end if

    if ( l2gp%nFreqs > 0 ) then
      status = mls_swdefdim(swid, 'nFreqs', l2gp%nFreqs, &
        & hdfVersion=hdfVersion)
    end if

    ! Define horizontal geolocation fields using above dimensions

    chunk_rank=1
    chunk_dims=1
    chunk_dims(1)=CHUNKTIMES
    if ( deebughere )  print *, 'chunk_dims ', chunk_dims(1:chunk_rank)
    status = mls_gfldsetup(swid, 'Latitude', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)

    status = mls_gfldsetup(swid, 'Longitude', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)

    status = mls_gfldsetup(swid, 'Time', 'nTimes', MYDIM1, &
      & DFNT_FLOAT64, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, dFill=real(l2gp%MissingValue, r8))

    status = mls_gfldsetup(swid, 'LocalSolarTime', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)

    status = mls_gfldsetup(swid, 'SolarZenithAngle', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)

    status = mls_gfldsetup(swid, 'LineOfSightAngle', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)

    status = mls_gfldsetup(swid, 'OrbitGeodeticAngle', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)

    status = mls_gfldsetup(swid, 'ChunkNumber', 'nTimes', MYDIM1, &
      & DFNT_INT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, iFill=UndefinedIntegerValue)

    if ( l2gp%nLevels > 0 ) then

      chunk_rank=1
      chunk_dims(1)=CHUNKLEVELS
      status = mls_gfldsetup(swid, 'Pressure', 'nLevels', MAX_DIML, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
    end if

    if ( l2gp%nFreqs > 0 ) then

      chunk_rank=1
      chunk_dims(1)=CHUNKFREQS
      status = mls_gfldsetup(swid, 'Frequency', 'nFreqs', MAX_DIML, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
    end if

    ! Define data fields using above dimensions

    if ( (l2gp%nFreqs > 0) .and. (l2gp%nLevels > 0) ) then
       chunk_rank=3
       chunk_dims(1:3)=(/ CHUNKFREQS,CHUNKLEVELS,CHUNKTIMES /)

      status = mls_dfldsetup(swid, 'L2gpValue', 'nFreqs,nLevels,nTimes', &
      & MYDIM123, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingL2GP)

      status = mls_dfldsetup(swid, 'L2gpPrecision', 'nFreqs,nLevels,nTimes', &
      & MYDIM123, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)

    else if ( l2gp%nLevels > 0 ) then
       chunk_rank=2
       chunk_dims(1:7)=(/ CHUNKLEVELS,CHUNKTIMES,37,38,39,47,49/)

      status = mls_dfldsetup(swid, 'L2gpValue', 'nLevels,nTimes', &
      & MYDIM12, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingL2GP)

      status = mls_dfldsetup(swid, 'L2gpPrecision', 'nLevels,nTimes', &
      & MYDIM12, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)

    else
       chunk_rank=1
       chunk_dims(1)=CHUNKTIMES

      status = mls_dfldsetup(swid, 'L2gpValue', 'nTimes', &
      & MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingL2GP)

      status = mls_dfldsetup(swid, 'L2gpPrecision', 'nTimes', &
      & MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)

    end if

    if ( deebughere )  print *, 'chunk_dims ', chunk_dims(1:chunk_rank)
    chunk_rank=1
    chunk_dims(1)=CHUNKTIMES
    if ( deebughere )  print *, 'chunk_dims ', chunk_dims(1:chunk_rank)
    status = mls_dfldsetup(swid, 'Status', 'nTimes', &
    & MYDIM1, &
    & DFNT_INT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
    & hdfVersion=hdfVersion, iFill=l2gp%MissingStatus)

    chunk_rank=1
    chunk_dims(1)=CHUNKTIMES
    if ( deebughere )  print *, 'chunk_dims ', chunk_dims(1:chunk_rank)
    status = mls_dfldsetup(swid, 'Quality', 'nTimes', &
    & MYDIM1, &
    & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
    & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)

    chunk_rank=1
    chunk_dims(1)=CHUNKTIMES
    status = mls_dfldsetup(swid, 'Convergence', 'nTimes', &
    & MYDIM1, &
    & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
    & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
    if ( AscDescModeIsField ) then
      chunk_rank=1
      chunk_dims(1)=CHUNKTIMES
      status = mls_dfldsetup(swid, 'AscDescMode ', 'nTimes', &
      & MYDIM1, &
      & DFNT_INT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, iFill=int(l2gp%MissingValue) )
    endif

    if ( associated(l2gp%BinNumber) ) then
      chunk_rank=1
      chunk_dims(1)=CHUNKTIMES
      status = mls_dfldsetup(swid, 'BinNumber ', 'nTimes', &
      & MYDIM1, &
      & DFNT_INT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, iFill=int(l2gp%MissingValue) )
    endif

    if ( associated(l2gp%MAF) ) then
      chunk_rank=1
      chunk_dims(1)=CHUNKTIMES
      status = mls_dfldsetup(swid, 'MAF ', 'nTimes', &
      & MYDIM1, &
      & DFNT_INT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, iFill=int(l2gp%MissingValue) )
    endif

    ! Detach from the HE5_SWath interface.This stores the swath info within the
    ! file and must be done before writing or reading data to or from the
    ! swath. (May be un-necessary for HDF5 -- test program works OK without.)
    ! 
    status = mls_SWdetach(swid, hdfVersion=hdfVersion)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Failed to detach from swath interface after definition.', &
            & MLSFile=L2GPFile )
    end if

  !--------------------------------------
  end subroutine OutputL2GP_createFile_MF
  !--------------------------------------

  !-----------------------------------------  OutputL2GP_writeGeo_MF  -----
  subroutine OutputL2GP_writeGeo_MF (l2gp, L2GPFile, &
    & swathName,offset)

  use MLSHDFEOS, only: MLS_SWAttach, MLS_SWDetach, MLS_SWWrfld
    ! Brief description of subroutine
    ! This subroutine writes the geolocation fields to an L2GP output file.

    ! Arguments

    type( L2GPData_T ), intent(inout) :: l2gp
    type(MLSFile_T)                :: L2GPFile
    character (len=*), intent(in), optional :: swathName ! Defaults->l2gp%name
    integer,intent(in),optional::offset

    ! Variables

    character (len=132) :: name ! Either swathName or l2gp%name
!     integer :: chunk
    integer :: status, swid,myOffset
    integer :: start(2), stride(2), edge(2)
    integer :: hdfVersion

    ! Begin
    if (present(offset)) then
       myOffset=offset
    else
       myOffset=0
    endif

    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
    endif
    hdfVersion = L2GPFile%hdfVersion

    swid = mls_SWattach (L2GPFile, name)

    ! Write data to the fields
    edge = 0
    stride = 1
    start = myOffset ! Please do not set to zero
    edge(1) = l2gp%nTimes

    if (DEEBUG) then
      call output( 'Writing geolocations', advance='yes' )
      call outputNamedValue( 'stride, start, edge', (/ stride(1), start(1), edge(1) /) )
      call outputNamedValue( 'shape(Geod. Angle', shape(l2gp%geodAngle) )
    endif

    status = mls_SWwrfld(swid, 'Latitude', start, stride, edge, &
         real(l2gp%latitude), hdfVersion=hdfVersion)

    status = mls_SWwrfld(swid, 'Longitude', start, stride, edge, &
         real(l2gp%longitude), hdfVersion=hdfVersion)

    status = mls_SWwrfld(swid, 'Time', start, stride, edge, &
         l2gp%time, hdfVersion=hdfVersion)

    status = mls_SWwrfld(swid, 'LocalSolarTime', start, stride, edge, &
        real(l2gp%solarTime), hdfVersion=hdfVersion)

    status = mls_SWwrfld(swid, 'SolarZenithAngle', start, stride, edge, &
         real(l2gp%solarZenith), hdfVersion=hdfVersion)

    status = mls_SWwrfld(swid, 'LineOfSightAngle', start, stride, edge, &
         real(l2gp%losAngle), hdfVersion=hdfVersion)

    status = mls_SWwrfld(swid, 'OrbitGeodeticAngle', start, stride, edge, &
         real(l2gp%geodAngle), hdfVersion=hdfVersion)

    ! call outputNamedValue ( 'Writing chunk number ', l2gp%chunkNumber )
    ! chunk = FindFirst( l2gp%chunkNumber /= -999 )
    ! call outputNamedValue ( 'index of non-Fill chunkNumber', chunk )
    status = mls_SWwrfld(swid, 'ChunkNumber', start, stride, edge, &
         l2gp%chunkNumber, hdfVersion=hdfVersion)

    if ( l2gp%nLevels > 0 ) then
       edge(1) = l2gp%nLevels
       start(1)=0 ! needed because offset may have made this /=0
       status = mls_SWwrfld(swid, 'Pressure', start(1:1), stride(1:1), edge(1:1), &
            real(l2gp%pressures), hdfVersion=hdfVersion)
    end if

    if ( l2gp%nFreqs > 0 ) then
       edge(1) = l2gp%nFreqs
       start(1)=0 ! needed because offset may have made this /=0
       status = mls_SWwrfld(swid, 'Frequency', start, stride, edge, &
            real(l2gp%frequency), hdfVersion=hdfVersion)
    end if

    ! Detach from the swath interface.  

    status = mls_SWdetach(swid, hdfVersion=hdfVersion)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach from swath interface', MLSFile=L2GPFile )
    end if

  !------------------------------------
  end subroutine OutputL2GP_writeGeo_MF
  !------------------------------------

  !----------------------------------------  OutputL2GP_writeData_MF  -----
  subroutine OutputL2GP_writeData_MF(l2gp, L2GPFile, &
    & swathName,offset)

  use MLSHDFEOS, only: MLS_SWAttach, MLS_SWDetach, MLS_SWWrfld
    ! Brief description of subroutine
    ! This subroutine writes the data fields to an L2GP output file.
    ! For now, you have to write all of l2gp, but you can choose to write
    ! it at some offset into the file
    ! Arguments

    type( L2GPData_T ), intent(inout) :: l2gp
    type(MLSFile_T)                :: L2GPFile
    character (len=*), intent(in), optional :: swathName ! Defaults->l2gp%name
    integer,intent(in),optional::offset
    ! Parameters
    ! logical, parameter :: DEEBUG = .false.

    ! Variables

    character (len=132) :: name     ! Either swathName or l2gp%name

    integer :: status,myOffset
    integer :: start(3), stride(3), edge(3)
    integer :: swid
    integer :: hdfVersion
    real :: tFile ! How long have we been fooling with this file?
    

    ! Begin
    if (present(offset)) then
       myOffset=offset
    else
       myOffset=0
    endif

    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
    endif
    hdfVersion = L2GPFile%hdfVersion

    start = 0
    stride = 1
    start(3)= myOffset ! Please do not set to zero
    edge(1) = l2gp%nFreqs
    edge(2) = l2gp%nLevels
    edge(3) = l2gp%nTimes
    call time_now ( tFile )
    if (DEEBUG) then
      call output( 'Writing data now ' // trim(name), advance='yes' )
      call outputNamedValue( 'stride, start, edge', (/ stride(3), start(3), edge(3) /) )
      call outputNamedValue( 'shape(Geod. Angle', shape(l2gp%geodAngle) )
    endif
    swid = mls_SWattach (L2GPFile, name)
    if ( DEEBUG ) then
      call sayTime( 'Attaching swath ' // trim(name), tFile, t2 )
      tFile = t2
    endif
    if ( l2gp%nFreqs > 0 ) then
       ! Value and Precision are 3-D fields
       if (DEEBUG) print *, 'start, stride, edge ', start, stride, edge
       ! What the devil???
       ! Why aren't we writing a 3-d array here??
       status = mls_SWwrfld(swid, 'L2gpValue', start, stride, edge, &
            & reshape(l2gp%l2gpValue, edge), &
            & hdfVersion=hdfVersion )
       status = mls_SWwrfld(swid, 'L2gpPrecision', start, stride, edge, &
            & reshape(l2gp%l2gpPrecision, edge), &
            & hdfVersion=hdfVersion )

       if ( DEEBUG ) then
         call sayTime( 'Witing 3d values and precision', tFile, t2 )
         tFile = t2
       endif
    else if ( l2gp%nLevels > 0 ) then
       ! Value and Precision are 2-D fields
      
       if (DEEBUG) print *, 'start, stride, edge: ', start(2:3), stride(2:3), edge(2:3)
       status = mls_SWwrfld( swid, 'L2gpValue', start(2:3), stride(2:3), &
            edge(2:3), l2gp%l2gpValue(1,:,:), hdfVersion=hdfVersion)
       if ( DEEBUG ) then
         call sayTime( 'Witing 2d values', tFile, t2 )
         tFile = t2
       endif
       status = mls_SWwrfld( swid, 'L2gpPrecision', start(2:3), stride(2:3), &
            edge(2:3), l2gp%l2gpPrecision(1,:,:), hdfVersion=hdfVersion)
       if ( DEEBUG ) then
         call sayTime( 'Witing 2d precision', tFile, t2 )
         tFile = t2
       endif
    else

       ! Value and Precision are 1-D fields
       if (DEEBUG) print *, 'start, stride, edge: ', start(3), stride(3), edge(3)
       status = mls_SWwrfld( swid, 'L2gpValue', start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpValue(1,1,:) ), hdfVersion=hdfVersion)
       if ( DEEBUG ) then
         call sayTime( 'Witing 1d values', tFile, t2 )
         tFile = t2
       endif
       status = mls_SWwrfld( swid, 'L2gpPrecision', start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpPrecision(1,1,:) ), hdfVersion=hdfVersion)
       if ( DEEBUG ) then
         call sayTime( 'Witing 1d precision', tFile, t2 )
         tFile = t2
       endif
    end if

    ! 1-D status & quality fields

    status = mls_swwrfld(swid, 'Status', start(3:3), stride(3:3), edge(3:3), &
       &   l2gp%status, hdfVersion=hdfVersion, dontfail=.true.)

    status = mls_SWwrfld(swid, 'Quality', start(3:3), stride(3:3), edge(3:3), &
         real(l2gp%quality), hdfVersion=hdfVersion)

    status = mls_SWwrfld(swid, 'Convergence', start(3:3), stride(3:3), edge(3:3), &
         real(l2gp%convergence), hdfVersion=hdfVersion)

    if ( AscDescModeIsField ) then
      status = mls_SWwrfld(swid, 'AscDescMode ', start(3:3), stride(3:3), edge(3:3), &
         l2gp%AscDescMode, hdfVersion=hdfVersion)
    endif

    if ( associated(l2gp%BinNumber) ) then
      status = mls_SWwrfld(swid, 'BinNumber ', start(3:3), stride(3:3), edge(3:3), &
         l2gp%BinNumber, hdfVersion=hdfVersion)
    endif

    if ( associated(l2gp%MAF) ) then
      status = mls_SWwrfld(swid, 'MAF ', start(3:3), stride(3:3), edge(3:3), &
         l2gp%MAF, hdfVersion=hdfVersion)
    endif

    if ( DEEBUG ) then
      call sayTime( 'Witing 1d status, Quality, Asc/Desc', tFile, t2 )
      tFile = t2
    endif
    !     Detach from the swath interface.
    status = mls_SWdetach(swid, hdfVersion=hdfVersion)
    if(DEEBUG) print *, 'Detached from swid ', swid
    if(DEEBUG) print *, 'file handle ', L2GPFile%FileID%f_id
    if(DEEBUG) print *, 'status ', status
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach from swath interface', MLSFile=L2GPFile )
    end if


  !-------------------------------------
  end subroutine OutputL2GP_writeData_MF
  !-------------------------------------

  !----------------------------------------  OutputL2GP_attributes_MF  -----
  subroutine OutputL2GP_attributes_MF(l2gp, L2GPFile, swathName)

  use HDFEOS5, only: HE5T_Native_Int, HE5T_Native_Real, HE5T_Native_Double, &
    & MLS_Chartype
  use HE5_SWAPI, only: HE5_SWWrattr, HE5_SWWrlattr
  use MLSHDFEOS, only: MLS_ISGlatt, &
    & MLS_SWAttach, MLS_SWDetach, MLS_SWWrattr, MLS_SWWrlattr
  use PCFHDR, only:  HE5_Writeglobalattr
    ! Brief description of subroutine
    ! This subroutine writes the attributes for an l2gp
    ! These include
    ! Global attributes which are file level
    ! Swath level
    ! Geolocation field attributes
    ! Data field attributes
    ! Arguments

    type( L2GPData_T ), intent(inout) :: l2gp
    type(MLSFile_T)                :: L2GPFile
    character (len=*), intent(in), optional :: swathName ! Defaults->l2gp%name

    ! Parameters
    character (len=*), parameter :: NOUNITS = 'NoUnits'

    ! The following pair of string list encode the Units attribute
    ! corresponding to each Title attribute; e.g., the Units for Latitude is deg
    character (len=*), parameter :: GeolocationTitles = &
      & 'Latitude,Longitude,Time,LocalSolarTime,SolarZenithAngle,' // &
      & 'LineOfSightAngle,OrbitGeodeticAngle,ChunkNumber,Pressure,Frequency'
    character (len=*), parameter :: GeolocationUnits = &
      & 'deg,deg,s,h,deg,' // &
      & 'deg,deg,NoUnits,hPa,GHz'
    character (len=*), parameter :: GeoUniqueFieldDefinition = &
      & 'HMT,HMT,AS,HMT,HMT,' // &
      & 'M,M,M,AS,M'   ! These are abbreviated values
    character (len=*), parameter :: UniqueFieldDefKeys = &
      & 'HM,HMT,MT,AS,M'
    character (len=*), parameter :: UniqueFieldDefValues = &
      & 'HIRDLS-MLS-Shared,HIRDLS-MLS-TES-Shared,MLS-TES-Shared,' // &
      & 'Aura-Shared,MLS-Specific'  ! Expanded values
    ! The following associate UniqueFieldDefs with species names
    character (len=*), parameter :: Species = &
      & 'Temperature,BrO,CH3CN,CO,ClO,GPH,HCl,HCN,H2O,H2O2,' // &
      & 'HNO3,HOCl,HO2,N2,N2O,OH,O2,O3,RHI,SO2'
    character (len=*), parameter :: SpUniqueFieldDefinition = &
      & 'HMT,M,M,MT,M,M,M,M,HMT,M,' // &
      & 'HMT,M,M,M,HM,M,M,HMT,M,M'   ! These are abbreviated values
    ! logical, parameter :: DEEBUG = .true.

    ! Variables
    character (len=132) :: name     ! Either swathName or l2gp%name
    character(len=CHARATTRLEN) :: abbr_uniq_fdef
    character(len=CHARATTRLEN) :: expnd_uniq_fdef
    integer :: field
    character(len=CHARATTRLEN) :: field_name
    logical :: isColumnAmt
    logical :: isTPPressure
    integer :: rgp_type
    character(len=CHARATTRLEN) :: species_name ! Always lower case
    integer :: status
    integer :: swid
    character(len=CHARATTRLEN) :: temp_name
    character(len=CHARATTRLEN), dimension(NumGeolocFields) :: theTitles
    character(len=CHARATTRLEN), dimension(NumGeolocFields) :: theUnits
    character(len=CHARATTRLEN) :: units_name
    ! Begin
    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
    endif
    if ( DEEBUG ) print *, 'About to wr attrs to: ', trim(name)
    if ( rgp == r4 ) then
      rgp_type = HE5T_NATIVE_REAL
    elseif ( rgp == r8 ) then
      rgp_type = HE5T_NATIVE_DOUBLE
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & 'Attributes have unrecognized numeric data type; should be r4 or r8', &
        & MLSFile=L2GPFile)
    endif
    call List2Array(GeolocationTitles, theTitles, .true.)
    call List2Array(GeolocationUnits, theUnits, .true.)

    ! - -   G l o b a l   A t t r i b u t e s   - -
    if ( WRITEMASTERSFILEATTRIBUTES .and. &
      & .not. MLS_ISGLATT(L2GPFile%fileID%f_id, 'StartUTC') ) &
      & call he5_writeglobalattr(L2GPFile%fileID%f_id)

    swid = mls_SWattach (L2GPFile, name)
    
    !   - -   S w a t h   A t t r i b u t e s   - -
    status = he5_swwrattr(swid, trim(l2gp%verticalCoordinate), &
      & rgp_type, hsize(size(l2gp%pressures)), &
      & l2gp%pressures)
    field_name = l2gp%verticalCoordinate ! 'Pressure'
    status = mls_swwrattr(swid, 'VerticalCoordinate', MLS_CHARTYPE, 1, &
      & field_name)
    if ( DeeBug ) print *, 'Missing L2GP: ', real(l2gp%MissingL2GP)
    if ( DeeBug ) print *, 'Missing value: ', real(l2gp%MissingValue)
    if ( SWATHLEVELMISSINGVALUE ) &
      & status = he5_swwrattr(swid, 'MissingValue', rgp_type, hsize(1), &
      & (/ real(l2gp%MissingL2GP, rgp) /) )
    
    !   - -   G e o l o c a t i o n   A t t r i b u t e s   - -
    if ( DEEBUG ) print *, 'About to wr loc attrs to: ', trim(name)
    do field=1, NumGeolocFields
      ! Take care not to write attributes to "missing fields"
      if ( trim(theTitles(field)) == 'Frequency' &
        & .and. l2gp%nFreqs < 1 ) then
        field_name = ''
      elseif ( trim(theTitles(field)) == 'Pressure' &
        & .and. l2gp%nLevels == 3 ) then
        field_name = 'DYNTpVals'
        status = mls_swwrlattr(swid, trim(theTitles(field)), 'Title', &
          & MLS_CHARTYPE, 1, field_name)
      elseif ( trim(theTitles(field)) == 'Pressure' &
        & .and. l2gp%nLevels < 1 ) then
        field_name = ''
      else
        field_name = theTitles(field)
        if ( trim(theTitles(field)) == 'Pressure' ) &
          & field_name = l2gp%verticalCoordinate
        call GetHashElement (GeolocationTitles, &
          & GeoUniqueFieldDefinition, trim(theTitles(field)), &
          & abbr_uniq_fdef, .false.)
        call GetHashElement (UniqueFieldDefKeys, &
          & UniqueFieldDefValues, trim(abbr_uniq_fdef), &
          & expnd_uniq_fdef, .false.)
        if ( DEEBUG ) print *, 'Field Title ', trim(theTitles(field))
        status = mls_swwrlattr(swid, trim(theTitles(field)), 'Title', &
          & MLS_CHARTYPE, 1, theTitles(field))
        if ( DEEBUG ) print *, 'Units ', trim(theUnits(field))
        status = mls_swwrlattr(swid, trim(theTitles(field)), 'Units', &
          & MLS_CHARTYPE, 1, theUnits(field))

        if ( trim(theTitles(field)) == 'Time' ) then
          status = he5_swwrlattr(swid, trim(theTitles(field)), &
            & 'MissingValue', &
            & HE5T_NATIVE_DOUBLE, hsize(1), (/ real(l2gp%MissingValue, r8) /) )
        elseif ( trim(theTitles(field)) == 'ChunkNumber' ) then
          status = he5_swwrlattr(swid, trim(theTitles(field)), &
            & 'MissingValue', &
            & HE5T_NATIVE_INT, hsize(1), (/ UndefinedIntegerValue /) )
        else
          status = he5_swwrlattr(swid, trim(theTitles(field)), &
            & 'MissingValue', &
            & rgp_type, hsize(1), (/ real(l2gp%MissingValue, rgp) /) )
        endif
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
         & "Unable to write local attribute to " // trim(theTitles(field)) )
        if ( DEEBUG ) print *, 'Uniquefielddef ', trim(expnd_uniq_fdef)
        status = mls_swwrlattr(swid, trim(theTitles(field)), &
          & 'UniqueFieldDefinition', &
          & MLS_CHARTYPE, 1, expnd_uniq_fdef)
        ! print *, 'status : ', status
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
         & "Unable to write local attribute to " // trim(theTitles(field)) )
      endif
    enddo
    if ( DEEBUG ) print *, 'Data'
    !   - -   D a t a   A t t r i b u t e s   - -
    ! call GetQuantityAttributes ( l2gp%quantityType, &
    !  & units_name, expnd_uniq_fdef)
    field_name = Name
    species_name = lowercase(name)
    ! The following special cases are handled by crude, despicable hacks
    ! It would be better to check on the quantity type, but paw hasn't
    ! succeeded in getting that to work properly and reliably
    isColumnAmt = ( index(species_name, 'column') > 0 )
    isTPPressure = ( index(species_name, 'tpp') > 0 )
    if ( isColumnAmt ) then
      ! This next failed sometimes
      temp_name = species_name
      call ExtractSubString(Name, species_name, 'column', 'wmo')
      if ( species_name == ' ' ) species_name=temp_name
      ! So we'll try another tack:
      temp_name = species_name
      call ReplaceSubString ( temp_name, species_name, 'column', '' )
      if ( species_name == ' ' ) species_name=temp_name
      temp_name = species_name
      call GetStringElement( temp_name, species_name, &
        & 1, countEmpty=.true., inseparator='-' )
      if ( species_name == ' ' ) species_name=temp_name
    else
      temp_name = species_name
      call GetStringElement( temp_name, species_name, &
        & 1, countEmpty=.true., inseparator='-' )
      if ( species_name == ' ' ) species_name=temp_name
    endif
    ! Hopefully by now we've turned species_name into one of the species
    if ( DEEBUG ) &
      & print *, 'full name: ', trim(name), ' Species: ', trim(species_name)
    call GetHashElement (lowercase(Species), &
      & SpUniqueFieldDefinition, trim(species_name), &
      & abbr_uniq_fdef, .false.)
    call GetHashElement (UniqueFieldDefKeys, &
      & UniqueFieldDefValues, trim(abbr_uniq_fdef), &
      & expnd_uniq_fdef, .false.)
    if ( expnd_uniq_fdef == '' .or. expnd_uniq_fdef == ',' ) &
      & expnd_uniq_fdef = 'MLS-Specific'
    select case (trim(lowercase(species_name)))
    case ('temperature')
      units_name = 'K'
    case ('gph')
      units_name = 'm'
    case ('geoheight')
      units_name = 'km'
    case ('rhi')
      units_name = '%rhi'
    case ('iwc', 'iwp')
      units_name = 'g/m^3'
    case ('cloudtoppressure')
      units_name = 'hPa'
    case default
      units_name = 'vmr'
    end select
    if ( isColumnAmt ) then
      ! units_name = 'DU'
      if ( DEEBUG ) &
        & call dump( .true., col_species_keys, col_species_hash, &
        & 'column species units' )
      call GetHashElement (col_species_keys, &
      & col_species_hash, trim(lowercase(species_name)), &
      & units_name, .true.)
      if ( DEEBUG ) &
      & print *, 'units_name: ', trim(units_name)
      if ( units_name == ',' ) units_name = 'molcm2'
    endif
    if ( isTPPressure ) units_name = 'hPa'
    if ( DEEBUG ) print *, 'Title ', trim(field_name)
    status = mls_swwrlattr(swid, 'L2gpValue', 'Title', &
      & MLS_CHARTYPE, 1, field_name)
    if ( DEEBUG ) print *, 'Units ', trim(units_name)
    status = mls_swwrlattr(swid, 'L2gpValue', 'Units', &
      & MLS_CHARTYPE, 1, units_name)
    status = he5_swwrlattr(swid, 'L2gpValue', 'MissingValue', &
      & rgp_type, hsize(1), (/ real(l2gp%MissingL2GP, rgp) /) )
    if ( DEEBUG ) print *, 'Title ', trim(expnd_uniq_fdef)
    status = mls_swwrlattr(swid, 'L2gpValue', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, expnd_uniq_fdef)
    status = mls_swwrlattr(swid, 'L2gpPrecision', 'Title', &
      & MLS_CHARTYPE, 1, trim(field_name)//'Precision')
    status = mls_swwrlattr(swid, 'L2gpPrecision', 'Units', &
      & MLS_CHARTYPE, 1, units_name)
    status = he5_swwrlattr(swid, 'L2gpPrecision', 'MissingValue', &
      & rgp_type, hsize(1), (/ real(l2gp%MissingValue, rgp) /) )
    status = mls_swwrlattr(swid, 'L2gpPrecision', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, expnd_uniq_fdef)

    ! ('Status' data field newly written)
    status = mls_swwrlattr(swid, 'Status', 'Title', &
      & MLS_CHARTYPE, 1, trim(field_name)//'Status')
    status = mls_swwrlattr(swid, 'Status', 'Units', &
      & MLS_CHARTYPE, 1, NOUNITS)
    status = he5_swwrlattr(swid, 'Status', 'MissingValue', &
      & HE5T_NATIVE_INT, hsize(1), (/ l2gp%MissingStatus /) )
    status = mls_swwrlattr(swid, 'Status', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, 'MLS-Specific')
    
    status = mls_swwrlattr(swid, 'Quality', 'Title', &
      & MLS_CHARTYPE, 1, trim(field_name)//'Quality')
    status = mls_swwrlattr(swid, 'Quality', 'Units', &
      & MLS_CHARTYPE, 1, NOUNITS)
    status = he5_swwrlattr(swid, 'Quality', 'MissingValue', &
      & rgp_type, hsize(1), (/ real(l2gp%MissingValue, rgp) /) )
    status = mls_swwrlattr(swid, 'Quality', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, 'MLS-Specific')
    
    status = mls_swwrlattr(swid, 'Convergence', 'Title', &
      & MLS_CHARTYPE, 1, trim(field_name)//'Convergence')
    status = mls_swwrlattr(swid, 'Convergence', 'Units', &
      & MLS_CHARTYPE, 1, NOUNITS)
    status = he5_swwrlattr(swid, 'Convergence', 'MissingValue', &
      & rgp_type, hsize(1), (/ real(l2gp%MissingValue, rgp) /) )
    status = mls_swwrlattr(swid, 'Convergence', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, 'MLS-Specific')
    if ( AscDescModeIsField ) then
      status = mls_swwrlattr(swid, 'AscDescMode', 'Title', &
        & MLS_CHARTYPE, 1, trim(field_name)//'AscDescMode ')
      status = mls_swwrlattr(swid, 'AscDescMode', 'Units', &
        & MLS_CHARTYPE, 1, NOUNITS)
      status = he5_swwrlattr(swid, 'AscDescMode', 'MissingValue', &
        & HE5T_NATIVE_INT, hsize(1), (/ 0 /) )
      status = mls_swwrlattr(swid, 'AscDescMode', &
        & 'UniqueFieldDefinition', &
        & MLS_CHARTYPE, 1, 'MLS-Specific')
      endif
    
    status = mls_SWdetach(swid, hdfVersion=HDFVERSION_5)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach  from swath interface', MLSFile=L2GPFile )
    end if


  !-------------------------------------
  end subroutine OutputL2GP_attributes_MF
  !-------------------------------------

  !-----------------------------------------  FilterL2GP  -----
  subroutine FilterL2GP ( L2GP, fields, options )

    ! This routine filters an  l2gp by setting its status to crashed
    ! wherever the gelolocations contain fillvalues
    
    ! Thew optional arg fields will dtermine which fields this applies to:
    ! value                  fields
    ! -----                  ------
    ! '*' (or missing)    all
    ! 'latitude,time'     latitude, time
    ! 'l2gpvalue'         l2gpvalue
    ! 'value'             l2gpvalue, l2gpPrecision, status, quality
    ! 'geolocation'       geolocations (all except 'value')

    ! Dummy arguments
    type (L2GPData_T), intent(inout) :: L2GP
    character(len=*), optional, intent(in) :: fields
    character(len=*), optional, intent(in) :: options ! E.g., '-v'
    
    ! Internal variables
    character(len=128) :: myFields
    character (len=8) :: myOptions

    ! Executable code
    myFields = GEO_FIELDS ! '*' ! would mean values or geolocations
    if ( present(fields) ) myFields = lowercase(fields)
    myOptions = ' '
    if ( present(options) ) myOptions = options
    ! verbose = ( index(myOptions, 'v') > 0 )
    select case (trim(myFields))
    case ('value')
      myFields = lowercase(DATA_FIELDS) ! 'l2gpvalue, l2gpPrecision, status, quality'
    case ('geolocation')
      myFields = lowercase(GEO_FIELDS) ! // ',pressure,time,frequency,chunknumber'
    case default
      ! Not a special case
    end select

    if ( SwitchDetail(myFields, 'latitude', '-wfc') > -1 ) then
      where ( isFillValue(l2gp%latitude) )
         l2gp%status = l2gp%MissingStatus  !DANGERWILLROBINSON
      endwhere
    endif
    if ( SwitchDetail(myFields, 'longitude', '-wfc') > -1 ) then
      where ( isFillValue(l2gp%longitude) )
         l2gp%status = l2gp%MissingStatus  !DANGERWILLROBINSON
      endwhere
    endif
    if ( SwitchDetail(myFields, 'solartime', '-wfc') > -1 ) then
      where ( isFillValue(l2gp%solartime) )
         l2gp%status = l2gp%MissingStatus  !DANGERWILLROBINSON
      endwhere
    endif
    if ( SwitchDetail(myFields, 'solarzenith', '-wfc') > -1 ) then
      where ( isFillValue(l2gp%solarzenith) )
         l2gp%status = l2gp%MissingStatus  !DANGERWILLROBINSON
      endwhere
    endif
    if ( SwitchDetail(myFields, 'losangle', '-wfc') > -1 ) then
      where ( isFillValue(l2gp%losangle) )
         l2gp%status = l2gp%MissingStatus  !DANGERWILLROBINSON
      endwhere
    endif
    if ( SwitchDetail(myFields, 'geodangle', '-wfc') > -1 ) then
      where ( isFillValue(l2gp%geodangle) )
         l2gp%status = l2gp%MissingStatus  !DANGERWILLROBINSON
      endwhere
    endif
    if ( SwitchDetail(myFields, 'time', '-wfc') > -1 ) then
      where ( isFillValue(l2gp%time) )
         l2gp%status = l2gp%MissingStatus  !DANGERWILLROBINSON
      endwhere
    endif
    if ( SwitchDetail(myFields, 'l2gpvalue', '-wfc') > -1 ) then
      where ( isFillValue(l2gp%l2gpvalue(1,1,:)) )
         l2gp%status = l2gp%MissingStatus  !DANGERWILLROBINSON
      endwhere
    endif
    if ( SwitchDetail(myFields, 'l2gpprecision', '-wfc') > -1 ) then
      where ( isFillValue(l2gp%l2gpprecision(1,1,:)) )
         l2gp%status = l2gp%MissingStatus  !DANGERWILLROBINSON
      endwhere
    endif

  end subroutine FilterL2GP
    
  !-----------------------------------------  RepairL2GP_L2GP  -----
  subroutine RepairL2GP_L2GP ( L2GP1, L2GP2, fields, options )

    ! This routine repairs l2gp1 using values from l2gp2
    ! wherever the first has fillvalues
    
    ! Thew optional arg fields will dtermine which fields this applies to:
    ! value                  fields
    ! -----                  ------
    ! '*' (or missing)    all
    ! 'latitude,time'     latitude, time
    ! 'l2gpvalue'         l2gpvalue
    ! 'value'             l2gpvalue, l2gpPrecision, status, quality
    ! 'geolocation'       geolocations (all except 'value')

    ! Dummy arguments
    type (L2GPData_T), intent(inout) :: L2GP1
    type (L2GPData_T), intent(in)    :: L2GP2
    character(len=*), optional, intent(in) :: fields
    character(len=*), optional, intent(in) :: options ! E.g., '-v'
    
    ! Internal variables
    character(len=128) :: myFields
    character (len=8) :: myOptions

    ! Executable code
    myFields = '*'
    if ( present(fields) ) myFields = lowercase(fields)
    myOptions = ' '
    if ( present(options) ) myOptions = options
    ! verbose = ( index(myOptions, 'v') > 0 )
    select case (trim(myFields))
    case ('value')
      myFields = lowercase(DATA_FIELDS) ! 'l2gpvalue, l2gpPrecision, status, quality'
    case ('geolocation')
      myFields = lowercase(GEO_FIELDS) ! // ',pressure,time,frequency,chunknumber'
    case default
      ! Not a special case
    end select

    if ( SwitchDetail(myFields, 'pressure', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%pressures, l2gp1%MissingValue, l2gp2%pressures )
    endif
    if ( SwitchDetail(myFields, 'latitude', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%latitude, l2gp1%MissingValue, l2gp2%latitude )
    endif
    if ( SwitchDetail(myFields, 'longitude', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%longitude, l2gp1%MissingValue, l2gp2%longitude )
    endif
    if ( SwitchDetail(myFields, 'solartime', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%solartime, l2gp1%MissingValue, l2gp2%solartime )
    endif
    if ( SwitchDetail(myFields, 'solarzenith', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%solarzenith, l2gp1%MissingValue, l2gp2%solarzenith )
    endif
    if ( SwitchDetail(myFields, 'LineOfSightAngle', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%losangle, l2gp1%MissingValue, l2gp2%losangle )
    endif
    if ( SwitchDetail(myFields, 'OrbitGeodeticAngle', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%geodangle, l2gp1%MissingValue, l2gp2%geodangle )
    endif
    if ( SwitchDetail(myFields, 'time', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%time, real(l2gp1%MissingValue, r8), &
        & l2gp2%time )
    endif
    if ( SwitchDetail(myFields, 'chunknumber', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%chunknumber, UndefinedIntegerValue, &
        & l2gp2%chunknumber )
    endif
    if ( SwitchDetail(myFields, 'frequency', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%frequency, l2gp1%MissingValue, l2gp2%frequency )
    endif
    if ( SwitchDetail(myFields, 'l2gpvalue', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%l2gpvalue, l2gp1%MissingL2GP, l2gp2%l2gpvalue )
    endif
    if ( SwitchDetail(myFields, 'l2gpprecision', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%l2gpprecision, l2gp1%MissingValue, l2gp2%l2gpprecision )
    endif
    if ( SwitchDetail(myFields, 'status', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%status, l2gp1%MissingStatus, l2gp2%status )
    endif
    if ( SwitchDetail(myFields, 'quality', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%quality, l2gp1%MissingValue, l2gp2%quality )
    endif
    if ( SwitchDetail(myFields, 'convergence', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp1%convergence, l2gp1%MissingValue, l2gp2%convergence )
    endif

  end subroutine RepairL2GP_L2GP

  !-----------------------------------------  RepairL2GP_HGrid  -----
  subroutine RepairL2GP_HGrid ( L2GP, HGrid, fields, offset, options )
    use HGridsDatabase, only: HGrid_T
    ! This routine repairs l2gp1 using values from HGrid
    ! wherever the first has fillvalues
    
    ! The optional arg fields will determine which fields this applies to:
    ! value                  fields
    ! -----                  ------
    ! '*' (or missing)    all
    ! 'latitude,time'     latitude, time
    ! 'geolocation'       geolocations (all)
    
    ! If the optional arg options contains
    ! value       effect
    ! -----       ------
    !   v        verbose
    !   d        DEEBUG
    !   c        forcibly repair any geolocations whose chunk number is -999

    ! Dummy arguments
    type (L2GPData_T), intent(inout) :: L2GP
    type (HGrid_T), intent(in)       :: HGrid
    character(len=*), optional, intent(in) :: fields
    integer, optional, intent(in) :: offset ! If HGrid profs offset from l2gp    
    character (len=*), optional, intent(in) :: options ! E.g., '-v'
    ! Internal variables
    ! logical, parameter :: DEEBUG = .false.
    logical            :: force
    integer            :: HGp1 ! Effective starting HGrid profile
    integer            :: HGpn ! Effective ending HGrid profile
    character(len=128) :: myFields
    character (len=8)  :: myOptions
    logical            :: verbose
    ! Executable code
    myFields = '*'
    if ( present(fields) ) myFields = lowercase(fields)
    myOptions = ' '
    if ( present(options) ) myOptions = options
    verbose = ( index(myOptions, 'v') > 0 ) .or. DEEBUG
    if ( present(offset) ) then
      HGp1 = offset
    else
      HGp1 = 1 + HGrid%noProfsLowerOverlap ! 2  ! No longer assume we're not offset; was 1
    endif
    force = ( index(myOptions, 'c') > 0 )
    ! Check that we've calculated array sizes correectly
    ! In particular, useable profiles matched HGrid and l2gp
    if ( size(hgrid%geodLat(1,HGp1:)) < size(l2gp%latitude) ) then
      call output('shape l2gp%latitude: ')
      call output(shape(l2gp%latitude), advance='yes')
      call output('shape HGrid%geodLat: ')
      call output(shape(HGrid%geodLat), advance='yes')
      call output('HGp1: ')
      call output(HGp1, advance='yes')
      call dump(hgrid%geodLat(1,HGp1:), 'hgrid%geodLat(1,HGp1:)')
      call dump(l2gp%latitude, 'l2gp%latitude')
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & 'HGrid and l2gp size mismatch: HGrid too small')
    elseif ( size(hgrid%geodLat(1,HGp1:)) > size(l2gp%latitude) ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, & 
        & 'HGrid and l2gp size mismatch: HGrid needed to be trimmed; done')
      call output('shape l2gp%latitude: ')
      call output(shape(l2gp%latitude), advance='yes')
      call output('shape HGrid%geodLat: ')
      call output(shape(HGrid%geodLat), advance='yes')
      verbose = .true.
    endif
    HGpn = size(l2gp%latitude) + HGp1 - 1
    if ( verbose ) then
      call output('1st HGrid angle: ')
      call output(hgrid%phi(1,HGp1), advance='yes')
      call output('1st l2gp angle: ')
      call output(l2gp%geodAngle(1), advance='yes')
      call output('last HGrid angle: ')
      call output(hgrid%phi(1,HGpn), advance='yes')
      call output('last l2gp angle: ')
      call output( l2gp%geodAngle( size(l2gp%geodAngle) ), advance='yes' )
      call output('HGp1: ')
      call output(HGp1, advance='yes')
      call output('HGpn: ')
      call output(HGpn, advance='yes')
      call output('shape l2gp%latitude: ')
      call output(shape(l2gp%latitude), advance='yes')
      call output('shape HGrid%phi(1,HGp1:HGpn): ')
      call output(shape(HGrid%phi(1,HGp1:HGpn)), advance='yes')
    endif
    
    if ( force ) then
      where ( l2gp%chunkNumber == -999 )
        l2gp%latitude      = l2gp%MissingValue
        l2gp%longitude     = l2gp%MissingValue
        l2gp%solartime     = l2gp%MissingValue
        l2gp%solarzenith   = l2gp%MissingValue
        l2gp%losangle      = l2gp%MissingValue
        l2gp%geodAngle     = l2gp%MissingValue
        l2gp%time          = l2gp%MissingValue
      endwhere
    endif

    select case (trim(myFields))
    case ('geolocation')
      myFields = lowercase(GEO_FIELDS) ! // ',pressure,time,frequency,chunknumber'
    case default
      ! Not a special case
    end select

    if ( DEEBUG ) print *, 'shape l2gp%latitude: ', shape(l2gp%latitude)
    if ( DEEBUG ) print *, 'shape HGrid%geodLat: ', shape(HGrid%geodLat)
    
    if ( SwitchDetail(myFields, 'latitude', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp%latitude, l2gp%MissingValue, &
        & real(hgrid%geodLat(1,HGp1:HGpn), rgp) )
    endif
    if ( DEEBUG ) print *, 'shape l2gp%longitude: ', shape(l2gp%longitude)
    if ( DEEBUG ) print *, 'shape HGrid%lon: ', shape(HGrid%lon)
    if ( SwitchDetail(myFields, 'longitude', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp%longitude, l2gp%MissingValue, &
        & real(hgrid%lon(1,HGp1:HGpn), rgp) )
    endif
    if ( SwitchDetail(myFields, 'solartime', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp%solartime, l2gp%MissingValue, &
        & real(hgrid%solartime(1,HGp1:HGpn), rgp) )
    endif
    if ( SwitchDetail(myFields, 'solarzenith', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp%solarzenith, l2gp%MissingValue, &
        & real(hgrid%solarzenith(1,HGp1:HGpn), rgp) )
    endif
    if ( SwitchDetail(myFields, 'LineOfSightAngle', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp%losangle, l2gp%MissingValue, &
        & real(hgrid%losangle(1,HGp1:HGpn), rgp) )
    endif
    if ( SwitchDetail(myFields, 'OrbitGeodeticAngle', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp%geodAngle, l2gp%MissingValue, &
        & real(hgrid%phi(1,HGp1:HGpn), rgp) )
    endif
    if ( SwitchDetail(myFields, 'time', '-wfc') > -1 ) then
      call ReplaceFillValues ( l2gp%time, real(l2gp%MissingValue, r8), &
        & hgrid%time(1,HGp1:HGpn) )
    endif

  end subroutine RepairL2GP_HGrid

  !----------------------------------------  SetL2GP_aliases_MF  -----
  subroutine SetL2GP_aliases_MF(l2gp, L2GPFile, swathName)

  use HDFEOS5, only: HE5_SWSetalias
  use MLSHDFEOS, only: MLS_SWAttach, MLS_SWDetach
  use SDPToolkit, only: PGS_S_Success
    ! Arguments
    type(MLSFile_T)                :: L2GPFile
    type (L2GPData_T), intent(INOUT) :: l2gp
    character (len=*), optional, intent(in) ::swathName!default->l2gp%swathName
    
    ! Brief description of subroutine
    ! This subroutine creates an alias for each of the two data fields
    ! TYPE2FIELDNAME and TYPE2PRECISIONNAME
    ! Local variables
    character (len=132) :: name     ! Either swathName or l2gp%name
    character(len=*), parameter :: TYPE2FIELDNAME = 'L2gpValue'
    character(len=*), parameter :: TYPE2PRECISIONNAME = 'L2gpPrecision'
    integer :: returnStatus
    integer :: sw_id
    ! Executable
    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
    endif
    sw_id = mls_swattach(L2GPFile, trim(name))
    if ( sw_id < 1 ) then 
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & "Error in attaching swath for setting alias.", MLSFile=L2GPFile )
    end if
    returnStatus = he5_SWsetalias(sw_id, TYPE2FIELDNAME, trim(name))
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & "Error in setting alias from " // TYPE2FIELDNAME // &
          & ' to ' // trim(name), MLSFile=L2GPFile )
    end if
    returnStatus = he5_SWsetalias(sw_id, TYPE2PRECISIONNAME, &
     & trim(name) // 'Precision')
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & "Error in setting alias from " // TYPE2PRECISIONNAME // &
          & ' to ' // trim(name) // 'Precision', MLSFile=L2GPFile )
    end if
    returnStatus = mls_SWdetach(sw_id, hdfVersion=HDFVERSION_5)
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & "Error in detaching swath for setting alias.", MLSFile=L2GPFile )
    end if
  !-------------------------------------
  end subroutine SetL2GP_aliases_MF
  !-------------------------------------

  !----------------------------------------  writeL2GPData_MLSFile  -----
  ! This subroutine is an amalgamation of the last three
  ! Should be renamed CreateAndWriteL2GPData
  subroutine writeL2GPData_MLSFile(l2gp, L2GPFile, swathName, &
    & notUnlimited)

    ! Arguments

    type(MLSFile_T)                :: L2GPFile
    type (L2GPData_T), intent(INOUT) :: l2gp
    character (len=*), optional, intent(in) ::swathName!default->l2gp%swathName
    logical, optional, intent(in) :: notUnlimited
    ! Local
    logical :: alreadyOpen
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: status
    ! Executable code

    call trace_begin ( me, 'writeL2GPData_MLSFile', cond=.false. )
    status = 0
    alreadyOpen = L2GPFile%stillOpen
    if ( .not. alreadyOpen ) then
      call mls_openFile(L2GPFile, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l2gp file', MLSFile=L2GPFile)
    endif
    if ( L2GPFile%access == DFACC_RDONLY )  &
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'l2gp file is rdonly', MLSFile=L2GPFile)
    call OutputL2GP_createFile_MF (l2gp, L2GPFile, &
      & swathName, notUnlimited=notUnlimited)
    call OutputL2GP_writeGeo_MF (l2gp, L2GPFile, &
      & swathName)
    call OutputL2GP_writeData_MF (l2gp, L2GPFile, &
      & swathName)
    if (L2GPFile%hdfVersion == HDFVERSION_5) then
      if ( DEEBUG ) print *, 'Outputting attributes'
      call OutputL2GP_attributes_MF (l2gp, L2GPFile, swathName)
      if ( DEEBUG ) print *, 'Setting aliases'
      call SetL2GP_aliases_MF (l2gp, L2GPFile, swathName)
    endif

    if ( .not. alreadyOpen )  call mls_closeFile(L2GPFile, Status)
    L2GPFile%errorCode = status
    L2GPFile%lastOperation = 'write'
    call trace_end ( 'writeL2GPData_MLSFile', cond=.false. )
  end subroutine writeL2GPData_MLSFile
  
 ! The next two functions ignore leap seconds
  elemental function hoursInDayToTime( hid, l2gp ) result( time )
    ! Given rgp hid, return r8 time as tai(s)
    ! Args:
    real(rgp), intent(in)            :: hid ! hours in day
    type (L2GPData_T), intent(in)   :: l2gp
    real(r8)                        :: time
    ! Executable
    time = 3600._r8*hid + l2gp%time(1)
  end function hoursInDayToTime

  elemental function TimeToHoursInDay( time, l2gp ) result( hid )
    ! Given r8 time as tai(s), return rgp hid
    use Dates_Module, only: TAI93S2HID
    ! Args:
    real(r8), intent(in)                      :: time
    type (L2GPData_T), optional, intent(in)   :: l2gp
    real(rgp)                                 :: hid ! hours in day
    ! Local variables
    ! Executable
    if ( present(l2gp) ) then
      hid = (time - l2gp%time(1)) / 3600
    else
      hid = tai93s2hid( time )
    endif
  end function TimeToHoursInDay

!------------------------- SayTimeHere ---------------------
  subroutine SayTimeHere ( What, startTime )
    character(len=*), intent(in) :: What
    real, intent(in)             :: startTime
    call time_now ( t2 )
    call output ( "Timing for " // what // " = " )
    call output ( dble(t2 - startTime), advance = 'yes' )
  end subroutine SayTimeHere

!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: L2GPData.f90,v 2.257 2023/07/06 18:42:48 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

!=============================================================================
end module L2GPData
!=============================================================================

!
! $Log: L2GPData.f90,v $
! Revision 2.257  2023/07/06 18:42:48  pwagner
! Added flexibility to read swaths of derived products
!
! Revision 2.256  2023/02/02 22:25:11  pwagner
! Light housekeeping
!
! Revision 2.255  2022/11/16 23:12:17  pwagner
! Fixed various bugs in diffing geolocations
!
! Revision 2.254  2022/11/08 23:50:42  pwagner
! Array bounds were too small in Dump_L2GP; fixed
!
! Revision 2.253  2021/09/30 21:51:21  pwagner
! Add check for agreement to DumpL2GPData%1st pprofiles
!
! Revision 2.252  2021/09/23 23:02:56  pwagner
! Added FirstProfileNumber to fields that can be Dumped
!
! Revision 2.251  2021/09/02 22:44:38  pwagner
! Fixed error in ContractL2GPRecord_opt
!
! Revision 2.250  2021/06/10 23:44:09  pwagner
! Added BinNumber and MAF components to the l2gp type
!
! Revision 2.249  2021/05/27 23:39:09  pwagner
! Added 'F' option to print diffs for compatible datasets
!
! Revision 2.248  2021/04/15 22:43:22  pwagner
! Now uses MLS_HyperStart
!
! Revision 2.247  2020/07/17 16:16:14  pwagner
! Avoid reading hdf5 MissingValue attribute from hdf4 files
!
! Revision 2.246  2020/06/30 23:20:18  pwagner
! ConvertL2GPToQuantity copies pressures, hopefulyy w/o crashing
!
! Revision 2.245  2020/03/20 23:04:13  pwagner
! Made consistent with new he5_readglobalattr api
!
! Revision 2.244  2020/03/04 21:24:48  pwagner
! Make stuff public needed by NCL2GPData; preFill status with l2gp%MissingStatus
!
! Revision 2.243  2020/02/13 21:27:08  pwagner
! Fix errors relating to separate MissingValue for GPH
!
! Revision 2.242  2019/10/30 20:09:37  pwagner
! Prevents an array bounds error caught by NAG
!
! Revision 2.241  2019/10/21 23:20:14  pwagner
! Converts l2gp to quantity even if geolocations not associated
!
! Revision 2.240  2019/05/13 23:32:55  pwagner
! Use UndefinedIntegerValue to prevent failure taking an int of -1.e15 in case of GPH
!
! Revision 2.239  2019/01/29 21:45:47  pwagner
! Initializes some hdfeos character fields to prevent bleed-thru
!
! Revision 2.238  2018/11/12 23:11:12  pwagner
! Deprecated AscDescMode
!
! Revision 2.237  2018/08/01 22:14:27  pwagner
! Added CompactL2GPRecord; corrected errors in ExtractL2GPRecord and Diff-ing with matchTimes
!
! Revision 2.236  2018/05/31 22:47:45  pwagner
! Read ProductionLocation, HostName, identifier_product_doi when dumping global attrs
!
! Revision 2.235  2018/05/22 23:41:14  pwagner
! Use dumpGlobalAttributes when Dumping L2GP Attributes
!
! Revision 2.234  2018/04/24 18:25:11  pwagner
! Commented out the final method; it caused gold brick crashes
!
! Revision 2.233  2018/04/19 00:50:43  vsnyder
! Remove USE statements for unused names, add final subroutine
!
! Revision 2.232  2018/02/28 19:54:26  pwagner
! Tries to prevent unwanted names on each line
!
! Revision 2.231  2018/02/03 00:24:49  pwagner
! Correct Status Bit names; add post-processed
!
! Revision 2.230  2017/12/18 16:41:09  mmadatya
! Added unit for new quantity geoHeight
!
! Revision 2.229  2017/11/30 21:15:53  pwagner
! Avoid writing MissingValue to metadata
!
! Revision 2.228  2017/11/03 19:59:08  pwagner
! Most array gymnastics moved from MLSFillValues to HyperSlabs module
!
! Revision 2.227  2017/07/19 22:51:50  pwagner
! Improved appearance and consistency when Diffing L2GPData types; esp. if gold brick
!
! Revision 2.226  2017/03/10 00:40:19  vsnyder
! Make intrsctn allocatable
!
! Revision 2.225  2016/11/03 22:39:14  pwagner
! Begin transition to the Time_m implmentation of sayTime
!
! Revision 2.224  2016/09/07 22:46:21  pwagner
! Removed unused QuantityType component from L2GPData type
!
! Revision 2.223  2016/07/28 01:42:27  vsnyder
! Refactoring dump and diff
!
! Revision 2.222  2016/06/13 17:59:16  pwagner
! Added cpHE5GlobalAttrs
!
! Revision 2.221  2016/03/23 00:20:09  pwagner
! DiffL2GPData now able to print name on each line
!
! Revision 2.220  2015/10/14 23:18:04  pwagner
! RepairL2GP may optionally repair any geolocations whose chunk number is -999
!
! Revision 2.219  2015/10/13 23:48:28  pwagner
! Warn if all chunkNumbers are FillValues; exit with error if asked to create a swath with preexisting name
!
! Revision 2.218  2015/10/06 00:20:53  pwagner
! Removed unused code
!
! Revision 2.217  2015/09/17 22:57:09  pwagner
! Guards against hdfeos bug in AppendL2GPData only if max chunk size not present
!
! Revision 2.216  2015/09/03 20:26:59  pwagner
! verbose shows timings in AppendL2GPData
!
! Revision 2.215  2015/08/29 00:42:00  vsnyder
! Don't copy undefined data, even if it won't be used
!
! Revision 2.214  2015/07/14 23:13:21  pwagner
! Added computation of interprofile geolocation spacings
!
! Revision 2.213  2015/06/04 17:05:35  pwagner
! Fixed bug causing integer overflow in integer type conversion
!
! Revision 2.212  2015/04/28 16:21:11  pwagner
! Fixed some things in Diffing
!
! Revision 2.211  2015/03/28 01:09:22  vsnyder
! Made DescendingRange a parameter.
! Added stuff to trace allocate/deallocate addresses.
!
! Revision 2.210  2015/02/27 23:57:55  pwagner
! Take pains to ensure HostName is not blank
!
! Revision 2.209  2015/02/18 00:28:01  pwagner
! Corrected DumpL2GP_attributes_hdf5 to include linefeeds, MiscNotes
!
! Revision 2.208  2014/12/11 21:25:57  pwagner
! Make Asc/Desc Mode -999 for crashed chunks
!
! Revision 2.207  2014/12/10 21:27:49  pwagner
! Commented-out unused stuff
!
! Revision 2.206  2014/12/09 01:26:52  pwagner
! Define and initialize orbit angle range for Descending mode
!
! Revision 2.205  2014/10/01 00:02:06  pwagner
! Fixed another bug in ExtractL2GPRecord
!
! Revision 2.204  2014/09/04 23:47:44  vsnyder
! More complete and accurate allocate/deallocate size tracking.
! Add some tracing.
!
! Revision 2.203  2014/07/23 21:59:53  pwagner
! Fixed bugs in ExtractL2GPRecord
!
! Revision 2.202  2014/07/21 21:59:27  pwagner
! Respect options when dumping AscDescMode
!
! Revision 2.201  2014/04/07 17:24:33  pwagner
! Added new l2gp data field AscDescMode
!
! Revision 2.200  2014/04/02 23:03:11  pwagner
! Removed redundant open_ and close_MLSFile
!
! Revision 2.199  2014/01/09 00:24:29  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.198  2013/10/15 23:53:40  pwagner
! May copy quantity values to a file global attribute
!
! Revision 2.197  2013/09/25 00:45:44  pwagner
! Convert must set quantity geolocations, too
!
! Revision 2.196  2013/09/24 00:53:53  pwagner
! Can now convert an l2gpData type to a vector quantity
!
! Revision 2.195  2013/09/17 22:35:40  pwagner
! Changed api of Embed, Extract arrays to match hyperslab
!
! Revision 2.194  2013/08/31 01:24:53  vsnyder
! Replace MLSMessageCalls with trace_begin and trace_end
!
! Revision 2.193  2013/08/12 23:47:25  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.192  2013/04/05 23:17:52  pwagner
! Uses function from dates_module
!
! Revision 2.191  2013/02/26 00:11:49  pwagner
! Dumps times both as tai and hoursInDay
!
! Revision 2.190  2013/02/21 22:22:53  pwagner
! New optional args ti ContractL2GPRecord
!
! Revision 2.189  2013/01/02 21:00:37  pwagner
! Warn instead dying if no swaths to copy
!
! Revision 2.188  2012/10/09 00:34:52  pwagner
! Fixed bugs in OutputL2GP_attributes_MF, AppendL2GPData
!
! Revision 2.187  2012/09/18 18:50:25  pwagner
! Dont write over already-there global attributes
!
! Revision 2.186  2012/07/10 15:18:05  pwagner
! Adapted to new api for GetUniqueList
!
! Revision 2.185  2012/07/05 23:49:04  pwagner
! Sets swath Status field to "crashed" if cpl2gpdata options contains "f" and geolocations contain Fills
!
! Revision 2.184  2012/05/10 00:45:24  pwagner
! Better way for AppendL2GPData to know it must create swath
!
! Revision 2.183  2012/05/01 23:12:34  pwagner
! Maneuver around an unnecessary and sometimes unfortunate if
!
! Revision 2.182  2012/01/11 17:35:20  pwagner
! Turn off extra debugging; snip commented-out lines
!
! Revision 2.181  2011/12/07 01:18:14  pwagner
! Added new 'd' and 'g' options to diff
!
! Revision 2.180  2011/07/07 00:31:03  pwagner
! Treats diffs of geolocation fields with periods
!
! Revision 2.179  2011/02/05 01:33:44  pwagner
! Automatically sheds rank when nFreqs=1; passes options to dump routines
!
! Revision 2.178  2010/11/17 01:19:13  pwagner
! Fixed bug when diffing files with different swathnames; units_name for iwc now 'g/m^3'
!
! Revision 2.177  2010/11/10 02:03:06  pwagner
! Copies correct TAI93At0zOfGranule global attribute
!
! Revision 2.176  2010/06/22 16:53:15  pwagner
! Consistent with new behavior of switchDetail: must include 'f' if override default options
!
! Revision 2.175  2010/06/19 00:11:05  pwagner
! Diffs were checking wrong default field names; fixed
!
! Revision 2.174  2010/02/12 00:25:46  pwagner
! Fixed bug when number of dims is 4 (but what if 5 or more?)
!
! Revision 2.173  2010/02/04 23:08:00  vsnyder
! Remove USE or declaration for unused names
!
! Revision 2.172  2009/11/04 23:15:53  pwagner
! Restored MAXCHUNKTIMES to 120; at 1 DGG file became enormous (who could have guessed)
!
! Revision 2.171  2009/10/22 00:52:39  pwagner
! Second try at fixing hdfeos5 bug; still no luck
!
! Revision 2.170  2009/10/05 23:39:24  pwagner
! Moved use hdf5 statements from module scope to speedup Lahey; this is the last time we do that
!
! Revision 2.169  2009/09/29 23:35:43  pwagner
! Changes needed by 64-bit build
!
! Revision 2.168  2009/08/26 16:45:55  pwagner
! Public global flag WRITEMASTERSFILEATTRIBUTES determines whether to overwrite slave file attributes with masters
!
! Revision 2.167  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.166  2009/06/16 17:21:08  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.165  2009/06/02 17:49:17  cvuu
! Write NRT Lat and Lon to L2Metadata
!
! Revision 2.164  2009/05/14 22:01:21  pwagner
! dumps now take width optional arg
!
! Revision 2.163  2009/05/08 00:42:58  pwagner
! Shows StatusBitNames when dumping Status bits
!
! Revision 2.162  2008/12/02 23:11:41  pwagner
! mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
!
! Revision 2.161  2008/09/10 00:44:58  pwagner
! diffing files can now subset according to geolocation boxes
!
! Revision 2.160  2008/09/09 00:24:49  pwagner
! Fix bug in dumpRange
!
! Revision 2.159  2008/09/03 20:43:09  pwagner
! Added ContractL2GPRecord, diffRange, dumpRange
!
! Revision 2.158  2008/07/09 16:36:31  pwagner
! Fixed "sleepy chunk" syndrome
!
! Revision 2.157  2008/04/22 18:57:33  pwagner
! Fixed bug in ExtractL2GPData that left quality undefined
!
! Revision 2.156  2008/04/18 21:06:59  pwagner
! Fixed error introduced last time
!
! Revision 2.155  2008/02/28 01:27:06  pwagner
! Worked around an apparent bug in HDFEOS5 when adding to swath fields
!
! Revision 2.154  2008/01/24 23:33:04  pwagner
! when diffing, matchtimes will try to match either times or geod. angle
!
! Revision 2.153  2008/01/07 21:37:23  pwagner
! Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
!
! Revision 2.152  2007/12/19 01:29:37  pwagner
! Removed unused args
!
! Revision 2.151  2007/10/10 00:00:51  pwagner
! DumpL2GPData ought not to override optional parameter details if supplied
!
! Revision 2.150  2007/08/13 17:36:38  pwagner
! Push some procedures onto new MLSCallStack
!
! Revision 2.149  2007/06/26 00:20:14  pwagner
! May specify pressure levels on which to show diffs
!
! Revision 2.148  2007/05/30 22:03:41  pwagner
! HuntRange does not work correctly when list has missing values; workaround employed
!
! Revision 2.147  2007/02/26 23:58:48  pwagner
! New optional arg diffs only at matching profile times
!
! Revision 2.146  2007/02/13 21:57:08  pwagner
! Added convergence to defaultfields
!
! Revision 2.145  2006/10/11 00:16:33  pwagner
! Added new data field to hold convergence ratio
!
! Revision 2.144  2006/09/29 23:56:49  pwagner
! Got rid of unused GetGeolocUnits function
!
! Revision 2.143  2006/04/12 20:49:10  pwagner
! nTimesTotal component now dumped, too
!
! Revision 2.142  2006/04/06 23:04:52  pwagner
! Optionally cp only ranges of freq, level, profile
!
! Revision 2.141  2006/03/13 23:40:28  pwagner
! verbose now an optional arg to diff
!
! Revision 2.140  2006/02/28 21:44:44  pwagner
! Diff works better, added IsL2GPSetUp
!
! Revision 2.139  2006/02/21 19:09:25  pwagner
! GetHashElement is now a generic
!
! Revision 2.138  2006/02/16 00:09:23  pwagner
! Show how l2gp, Hgrid shapes differ
!
! Revision 2.137  2006/02/03 21:25:00  pwagner
! Finally ended unnecessary debug printing
!
! Revision 2.136  2006/01/27 01:02:19  pwagner
! Does better at picking units name for column abundances
!
! Revision 2.135  2006/01/26 00:33:09  pwagner
! demoted more use statements from module level to speed Lahey compiles
!
! Revision 2.134  2006/01/19 00:29:10  pwagner
! Units attribute for column abundances corrected
!
! Revision 2.133  2006/01/17 17:49:26  pwagner
! Fixed bug in call to HuntRange
!
! Revision 2.132  2006/01/14 00:54:08  pwagner
! May diff, dump specified chunks only
!
! Revision 2.131  2006/01/04 20:31:19  pwagner
! Diff procedures may keep silent, returning num of diffs only
!
! Revision 2.130  2005/12/16 00:05:57  pwagner
! Changes to reflect new MLSFillValues module; diff from dump0
!
! Revision 2.129  2005/11/04 18:51:19  pwagner
! Non-substantial stylistic tweaks of GEO, DATA_FIELDS
!
! Revision 2.128  2005/10/28 23:12:02  pwagner
! Removed unnecessary HGridField from repairL2GPData
!
! Revision 2.127  2005/10/18 23:06:49  pwagner
! Belated yet crude hack to insure Tropopause units_name is hPa
!
! Revision 2.126  2005/10/11 17:36:55  pwagner
! Added MLSFile interface to cpL2GPData, diff procedures
!
! Revision 2.125  2005/09/23 23:38:30  pwagner
! rename only effective if non-blank
!
! Revision 2.124  2005/09/21 23:16:40  pwagner
! Improvements to RepairL2GP_HGrid; they may even be correct
!
! Revision 2.123  2005/09/14 00:08:15  pwagner
! Dispense with some debug prints; observe HGRid%noProfsLowerOverlap
!
! Revision 2.122  2005/08/19 23:37:22  pwagner
! May use HGrid to repair l2gp geolocations
!
! Revision 2.121  2005/08/15 10:40:38  hcp
! in AppendL2GPData_fileID, mls_swdetach was called with an undefined
! variable as hdfVersion, causing failures. Now fixed.
!
! Revision 2.120  2005/08/08 23:55:04  pwagner
! Never leave status undefined if L2GPFile%errorCode assigned to it
!
! Revision 2.119  2005/08/05 20:32:56  pwagner
! Added RepairL2GP
!
! Revision 2.118  2005/07/12 17:15:47  pwagner
! Dropped global attribute InputVersion
!
! Revision 2.117  2005/07/06 00:31:06  pwagner
! More robust determination of column swaths; quality data field has no units
!
! Revision 2.116  2005/06/29 00:41:50  pwagner
! Passes MLSFiles to mls_swattach,create
!
! Revision 2.115  2005/06/22 17:25:49  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.114  2005/06/14 22:33:45  pwagner
! Moved rdonly error check from read procedure to write
!
! Revision 2.113  2005/06/14 20:38:27  pwagner
! Interfaces changed to accept MLSFile_T args
!
! Revision 2.112  2004/12/14 21:38:59  pwagner
! New verticalCoordinate component, attribute
!
! Revision 2.111  2004/10/27 00:32:35  pwagner
! Missing/Fill value for l2gp%status changed to 513
!
! Revision 2.110  2004/08/04 23:19:01  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.109  2004/08/03 17:59:35  pwagner
! Gets DEFAULTUNDEFINEDVALUE from MLSCommon
!
! Revision 2.108  2004/07/22 17:07:15  pwagner
! Fixed set fill values
!
! Revision 2.107  2004/06/11 19:07:02  pwagner
! Fixed small bug in diffl2gpfiles
!
! Revision 2.106  2004/06/09 00:04:51  pwagner
! New optional args to diff
!
! Revision 2.105  2004/06/02 19:37:52  pwagner
! Added stats option to diff
!
! Revision 2.104  2004/05/26 23:57:29  pwagner
! Added new diff routines
!
! Revision 2.103  2004/05/26 20:31:29  pwagner
! Raised MAXNUMSWATHPERFILE to 250
!
! Revision 2.102  2004/05/05 21:29:53  pwagner
! May change copied swath names with optional arg swathlist2
!
! Revision 2.101  2004/04/23 01:43:34  livesey
! Added Paul's fix for reading status
!
! Revision 2.100  2004/04/06 01:17:43  livesey
! Changed some allocatables to pointers.
!
! Revision 2.99  2004/03/29 18:51:18  pwagner
! Remembered to tell hdf5 status was int, not char
!
! Revision 2.98  2004/03/24 23:53:02  pwagner
! Switched from HE5T_NATIVE_SCHAR to MLS_CHARTYPE
!
! Revision 2.97  2004/03/12 00:38:19  pwagner
! cpL2GPData can convert hdfVersions; hdf version default increased to 5
!
! Revision 2.96  2004/02/26 22:02:36  pwagner
! Acts more gracefully if l2gp file lacks global attributes
!
! Revision 2.95  2004/02/13 00:18:58  pwagner
! Added DumpL2GP_attributes_hdf5 which doesnt work yet
!
! Revision 2.94  2004/02/11 23:05:05  pwagner
! Undid effect of 2nd-to-last fix; seems to have been wrong
!
! Revision 2.93  2004/02/11 23:04:38  pwagner
! Undid effect of 2nd-to-last fix; seems to have been wrong
!
! Revision 2.92  2004/02/11 22:59:59  pwagner
! Undid effect of 2nd-to-last fix; seems to have been wrong
!
! Revision 2.91  2004/02/11 17:23:25  pwagner
! l2gp status an integer, not a char
!
! Revision 2.90  2004/02/10 18:45:43  pwagner
! lastProfile among optional args to AppendL2GPData
!
! Revision 2.89  2004/02/05 23:33:21  pwagner
! Some bug fixes in cpL2GPData and its relatives
!
! Revision 2.88  2004/01/23 01:14:04  pwagner
! Can cp l2gps from one file to another
!
! Revision 2.87  2004/01/09 00:20:56  pwagner
! Added avoidUnlimitedDims to allow bypassing bug directWriting range of chunks
!
! Revision 2.86  2003/12/03 17:51:14  pwagner
! L2GP tracks both nTimes (for this slave) and nTimesTotal (done by all)
!
! Revision 2.85  2003/11/19 22:14:08  livesey
! Added option (not invoked at the moment) for 'limited' dimensions in
! AppendL2GP
!
! Revision 2.84  2003/11/05 21:44:38  pwagner
! Skips trying to read 4 mls-specific fields from non-mls files
!
! Revision 2.83  2003/10/31 12:35:57  hcp
! HCP made some small fixes to AppendL2GPData_fileID so that it doesn't
! crash if optional arg TotNumProfs is not present
!
! Revision 2.82  2003/10/28 21:41:06  pwagner
! Removed swath-level MissingValue attribute; renamed -Precision softlink
!
! Revision 2.81  2003/10/28 00:39:00  pwagner
! Fixed bug where character-vlaued attributes were only 1 char long
!
! Revision 2.80  2003/09/09 23:03:46  livesey
! More rigorous 'empty l2gp' check in append.
!
! Revision 2.79  2003/09/08 22:51:54  pwagner
! Simplified and unified read/write of hdfVersions
!
! Revision 2.78  2003/09/04 03:02:53  livesey
! Removed some print statements
!
! Revision 2.77  2003/09/03 22:39:44  pwagner
! Uses actual num of profiles for nTimes even if Unlim
!
! Revision 2.76  2003/08/28 23:51:03  livesey
! Various bug fixes to the AppendL2GP stuff
!
! Revision 2.75  2003/08/27 20:06:26  livesey
! Removed some print statements
!
! Revision 2.74  2003/07/21 23:32:09  pwagner
! Will write attributes, create alias when appending hdfeos5 if mustcreate
!
! Revision 2.73  2003/07/15 23:35:11  pwagner
! Disabled most printing; uses mls_SWdetach
!
! Revision 2.72  2003/07/10 22:18:49  livesey
! More minor bug fixes, but lots of print statements.
!
! Revision 2.71  2003/07/09 21:49:06  pwagner
! Wont try swattaching just to see if swath already there
!
! Revision 2.70  2003/07/08 00:43:17  livesey
! Bug fix in zero length chunk test
!
! Revision 2.69  2003/07/07 21:04:55  pwagner
! Tries to deal sensibly with profile-less chunks
!
! Revision 2.68  2003/07/02 00:55:27  pwagner
! Some improvements in DirectWrites of l2aux, l2gp
!
! Revision 2.67  2003/06/26 00:04:46  pwagner
! Added optional DONTFAIL arg to MLS_SWATTACH
!
! Revision 2.66  2003/06/20 19:31:39  pwagner
! Changes to allow direct writing of products
!
! Revision 2.65  2003/06/09 22:44:09  pwagner
! Uses mls_swcreate
!
! Revision 2.64  2003/04/21 19:34:59  pwagner
! Restored reading/writing char-valued Status datafield
!
! Revision 2.63  2003/04/17 23:07:02  pwagner
! Now uses MLSHDFEOS more thoroughly; can read HIRDLS L2GP files
!
! Revision 2.62  2003/04/15 23:14:50  pwagner
! New chunking so hdfeos5 files dont balloon; some swsetfill tweaking
!
! Revision 2.61  2003/04/11 23:35:10  pwagner
! Added new UniqueFieldDefinition attribute; sets fill and MissingValue 
! attributes for all fields
!
! Revision 2.60  2003/04/03 22:58:40  pwagner
! Alias now set in lib/L2GPData instead of l2/write_meta
!
! Revision 2.59  2003/04/02 23:53:56  pwagner
! Checks for FILENOTFOUND
!
! Revision 2.58  2003/03/07 00:40:23  pwagner
! Call HE5_SWsetfill; removed some spaces from attribute names
!
! Revision 2.57  2003/02/26 17:36:11  pwagner
! Repaired ReadL2GPData to close swath when given WILDCARDHDFVERSION
!
! Revision 2.56  2003/02/21 23:41:53  pwagner
! Also writes Fill Value attribute
!
! Revision 2.55  2003/02/12 21:50:33  pwagner
! New api for ReadL2GPData lets you supply fileName and hdfversion, which can be wildcard
!
! Revision 2.54  2003/02/10 22:04:49  pwagner
! ChunkNumber correctly HE5_SWdefgfld-ed as an int
!
! Revision 2.53  2003/02/08 00:33:32  pwagner
! Writes he5 attributes w/o bombing
!
! Revision 2.52  2003/02/07 01:05:12  pwagner
! rgp now public
!
! Revision 2.512003/02/06 00:24:48  pwagner
! Squashed a (last?) bug in hdfeos2 stuff
!
! Revision 2.50  2003/02/04 22:43:29  pwagner
! Fixed another serious bug
!
! Revision 2.49  2003/02/03 21:33:15  pwagner
! Having fixed (most)bugs, brought back from he5lib
!
! Revision 1.28  2003/01/30 00:58:53  pwagner
! Writing first attributes for hdfeos5
!
! Revision 1.27  2003/01/15 23:23:34  pwagner
! data types for L2GPData_T now adjustable
!
! Revision 1.26  2003/01/15 19:13:30  pwagner
! Smane no monkeying fix, but for hdf5
!
! Revision 1.25  2003/01/15 00:05:34  pwagner
! Now can write L2GPData w/o monkeying around
!
! Revision 1.24  2003/01/09 01:02:27  pwagner
! Moved some use statements in attempt to work around Lahey long compile time bug
!
! Revision 1.23  2002/10/25 15:21:05  hcp
! Nasty hack for unlimited swaths removed. Local requirement for this worked
! around in a different way. HDF-EOS5 team admit that problem is really
! caused by a bug in HDF-EOS5 so it should get fixed sometime anyway.
!
! Revision 1.22  2002/10/23 16:59:14  hcp
! Added _VERY_ cheesy work-around for reading files where the time
! dimension is unlimited.  This should not have any effect on files where
! the time dimension is not an unlimited dimension.  This is a
! work-around for some pathetically poor behaviour in HDF-EOS5.
!
! Revision 1.21  2002/10/09 14:05:30  hcp
! replaced HE5S_UNLIMITED with   HE5S_UNLIMITED_F
!
! Revision 1.20  2002/08/15 22:26:22  pwagner
! Added he5_swdefchunk to .._createFile_hdf5
!
! Revision 1.19  2002/06/10 12:00:43  hcp
! Removed use hdf5_params as hdf-eos5 now has an include file with the
! parameters you need ready-defined. References to various types changed
! to be consistent with that.
!
! Revision 1.18  2002/05/01 13:05:53  hcp
! Changed a warning to a debug so I didn't have to see it
!
! Revision 1.17  2002/05/01 09:28:10  hcp
! Some print statements commented
!
! Revision 1.16  2002/03/15 23:02:29  pwagner
! Gets HDFVERSION_4 and 5 from MLSFiles; checks for illegal hdfversions
!
! Revision 1.15  2002/02/01 21:32:34  pwagner
! offset treated properly for appendl2gp for hdf4; untested
!
! Revision 1.14  2002/01/29 23:47:21  pwagner
! Repaired bugs relating to hdf4 compatibility
!
! Revision 1.13  2002/01/29 00:48:43  pwagner
! Now should handle both hdfVersions; not tested yet
!
! Revision 1.12  2002/01/26 00:18:05  pwagner
! (Read)(Write)L2GPData accepts optional hdfVersion arg
!
! Revision 1.11  2001/11/29 10:07:13  pumphrey
! L2GPData (HDF-EOS5 version) brought up to date with HDF-EOS4 version
!
! Revision 1.10  2001/11/28 17:46:28  pumphrey
! In the middle of syncing up l2gpdata with HDF4 version in lib.
! Compiles, but not tested. Hack to write char swaths cut-n-pasted but not
! examined for sanity
!
! Revision 1.9  2001/11/28 16:17:16  pumphrey
! Syncing prior to major re-sync with HDF4 version.
!
! Revision 1.8  2001/07/31 11:26:19  archie
! Corrected case for ChunkNumber
! .
!
! Revision 1.7  2001/07/11 19:01:16  pumphrey
! quality->Quality, status->Status.
!
! Revision 1.6  2001/04/27 07:48:54  pumphrey
! Many nested loops in l3ascii replaced with array ops. Small fixes
! (e.g. spelling mistakes) in other modules.
!
! Revision 1.5  2001/04/06 20:16:38  pumphrey
! Not much, just keeping in sync
!
! Revision 1.4  2001/03/29 17:33:27  pumphrey
! Huge changes to L2GPData to sync with the HDF4 version and add unlimited
! dimension along the track
!
! Revision 1.3  2001/03/20 14:00:30  pumphrey
! fixing inconsistencies -- nothing important
!
! Revision 1.2  2001/02/23 13:33:14  pumphrey
! Fixed type definition for L2GPData_T so all the pointers are => NULL()
! This error was detected by nagf95 on Solaris but not on Linux. Odd.
!
! Revision 1.1  2000/12/22 15:55:53  pumphrey
! Initial commit of HDF-EOS5 versions of L2GP interface.
!
! Revision 2.8  2000/12/04 23:43:59  vsnyder
! Move more of addItemToDatabase into the include
!
! Revision 2.7  2000/09/22 14:29:42  pumphrey
! OutputL2GP_createFile was setting LocalSolarTime as byte (should be
! REAL)  and Time as REAL (should be Double prec.). Fixed.
!
! Revision 2.6  2000/09/21 13:48:18  pumphrey
! fixed a bug in the write routine.
!
! Revision 2.5  2000/09/19 12:42:11  pumphrey
! added chunkNumber to SetupNewL2GPRecord and other bug fixes
!
! Revision 2.4  2000/09/18 10:19:49  pumphrey
! Removed some debugging statements.
!
! Revision 2.1  2000/09/15 21:50:18  livesey
! New version of L2GP data, moved some stuff from l2 to lib
!
! Revision 2.0  2000/09/05 18:57:03  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.1  2000/09/02 02:05:04  vsnyder
! Initial entry
!
@


2.257
log
@Added flexibility to read swaths of derived products
@
text
@d5320 2
d5875 1
a5875 1
       "$Id: L2GPData.f90,v 2.256 2023/02/02 22:25:11 pwagner Exp $"
d5888 3
@


2.256
log
@Light housekeeping
@
text
@d3089 6
a3094 4
    status = he5_swrdattr(swid, 'Pressure', pressures)
    call dump ( pressures, 'Vertical coordinates:' )
    status = he5_swrdattr(swid, 'VerticalCoordinate', field_name)
    call dump_chars ( field_name, 'Vertical coordinates type:' )
d3108 3
d5220 5
d5873 1
a5873 1
       "$Id: L2GPData.f90,v 2.255 2022/11/16 23:12:17 pwagner Exp $"
d5886 3
@


2.255
log
@Fixed various bugs in diffing geolocations
@
text
@d208 1
a208 1
  integer, parameter, public :: L2GPNameLen = 80
a369 3
    ! integer :: verticalCoordinate ! The vertical coordinate used.  These
                                  ! are l_lits of the type t_VGridCoord
                                  ! defined in Init_Tables_Module.
d393 3
a395 2
    ! This routine does an append operation (see AppendL2GPData_fileID)
    ! If the file doesn't exist yet, hopefully, it'll create it
d2645 3
a2647 3
      call output ( ' - - - Chunk number:', advance='no')
      call output ( chunk, advance='no')
      call output ( ' - - -', advance='yes')
d2769 1
a2769 1
        call output ( ', (parser name) ')
d2773 1
a2773 1
           & advance='yes')
d2775 1
a2775 1
          call output ( '(the nameIndex was 0) ', advance='yes')
d2778 1
a2778 1
        call output ( ' ', advance='yes')
d2783 10
a2792 10
      call output ( 'nTimes: ')
      call output ( l2gp%nTimes, 5)
      call output ( '  nTimesTotal: ')
      call output ( l2gp%nTimesTotal, 5)
      call output ( '  nLevels: ')
      call output ( l2gp%nLevels, 3)
      call output ( '  nFreqs: ')
      call output ( l2gp%nFreqs, 3, advance='yes')
      call output ( 'Fill/Missing L2GP Values: ')
      call output ( l2gp%MissingL2GP, advance='yes')
d2794 3
a2796 3
      call output ( l2gp%MissingValue, advance='yes')
      call output ( 'Fill/Missing Status Field: ')
      call output ( l2gp%MissingStatus, advance='yes')
d5863 1
a5863 1
       "$Id: L2GPData.f90,v 2.254 2022/11/08 23:50:42 pwagner Exp $"
d5876 3
@


2.254
log
@Array bounds were too small in Dump_L2GP; fixed
@
text
@d1748 2
a1749 2
      & 'pressures, latitude, longitude, solarTime, solarZenith,' // &
      & 'losAngle, geodAngle, time, chunkNumber, frequency,'  // &
d1817 2
d1966 2
d1985 5
a1989 1

d2043 5
a2047 2
      type(L2GPData_T) :: l2gp1
      type(L2GPData_T) :: l2gp2
d2049 10
d2061 4
a2064 3
        if ( any(l2gp1%pressures /= l2gp2%pressures) .and. &
          & SwitchDetail(lowercase(myFields), 'pressure', '-fc') > -1 ) then
            call diff ( l2gp1%pressures, 'l2gp%pressures', &
d2068 3
d2075 4
a2078 3
        if ( any(l2gp1%latitude /= l2gp2%latitude) .and. &
          & SwitchDetail(lowercase(myFields), 'lat', '-fc') > -1 ) then
            call diff ( l2gp1%latitude, 'latitude', &
d2082 3
d2089 4
a2092 4
        if ( any(l2gp1%longitude /= l2gp2%longitude) .and. &
          & SwitchDetail(lowercase(myFields), 'lon', '-fc') > -1 ) then
          if ( goldbrick ) then
            call diff ( l2gp1%longitude, 'longitude', &
a2094 8
          else
            call dump ( &
              & diff_fun( l2gp1%longitude, l2gp2%longitude, &
              &         auxvalue=360._rgp, &
              &         options=AddOntoOptions('p',options) ), &
              & 'longitude', &
              & options=options )
          endif
d2096 3
d2102 5
a2106 5
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%solartime', ' ', statsOnOneLine )
        if ( any(l2gp1%solarTime /= l2gp2%solarTime) .and. &
          & SwitchDetail(lowercase(myFields), 'solartime', '-fc') > -1 ) then
          if ( goldbrick ) then
            call diff ( l2gp1%solarTime, 'solarTime', &
a2108 8
          else
            call dump ( &
              & diff_fun( l2gp1%solarTime, l2gp2%solarTime, &
              &         auxvalue=24._rgp, &
              &         options=AddOntoOptions('p',options) ), &
              & 'solarTime', &
              & options=options )
          endif
d2110 3
d2116 5
a2120 5
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%solarzenith', ' ', statsOnOneLine )
        CrashAtBeginning = .true.
        if ( any(l2gp1%solarZenith /= l2gp2%solarZenith) .and. &
          & SwitchDetail(lowercase(myFields), 'solarzenith', '-fc') > -1 ) then
            call diff ( l2gp1%solarZenith, 'solarZenith', &
d2122 1
a2122 2
              & options=trim(options) )
          badChunks = .true.
d2124 3
d2130 5
a2134 4
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%losangle', ' ', statsOnOneLine )
        if ( any(l2gp1%losAngle /= l2gp2%losAngle) .and. &
          & SwitchDetail(lowercase(myFields), 'losangle', '-fc') > -1 ) then
            call diff ( l2gp1%losAngle, 'losAngle', &
d2138 3
d2144 5
a2148 4
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%geodangle', ' ', statsOnOneLine )
        if ( any(l2gp1%geodAngle /= l2gp2%geodAngle) .and. &
          & SwitchDetail(lowercase(myFields), 'geodangle', '-fc') > -1 ) then
            call diff ( l2gp1%geodAngle, 'geodAngle', &
a2150 1
          ! badChunks = .true.
d2152 3
d2159 4
a2162 3
        if ( any(l2gp1%time /= l2gp2%time) .and. &
          & SwitchDetail(lowercase(myFields), 'time', '-fc') > -1 ) then
            call diff ( l2gp1%time, ' time', &
a2164 1
          ! badChunks = .true.
d2166 3
d2172 6
a2177 5
        NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%chunknumber', ' ', statsOnOneLine )
        if ( any(l2gp1%chunkNumber /= l2gp2%chunkNumber) .and. &
          & SwitchDetail(lowercase(myFields), 'chunknumber', '-fc') > -1 ) then
          call diff ( l2gp1%chunkNumber, 'chunkNumber', &
            &         l2gp2%chunkNumber, ' ', &
d2180 3
d2187 6
a2192 4
        if ( all(shape(l2gp1%frequency) == shape(l2gp2%frequency)) ) then
          if ( any(l2gp1%frequency /= l2gp2%frequency) .and. &
            & SwitchDetail(lowercase(myFields), 'freq', '-fc') > -1 ) then
            call diff ( l2gp1%frequency, 'frequency', &
d2196 3
a2198 1
          endif
d2201 6
d5865 1
a5865 1
       "$Id: L2GPData.f90,v 2.253 2021/09/30 21:51:21 pwagner Exp $"
d5878 3
@


2.253
log
@Add check for agreement to DumpL2GPData%1st pprofiles
@
text
@d2698 3
a2700 3
    integer, dimension(1000) :: FirstProfInChunk
    integer, dimension(1000) :: FirstProfInUnique
    integer, dimension(1000) :: uniqueVals
d5820 1
a5820 1
       "$Id: L2GPData.f90,v 2.252 2021/09/23 23:02:56 pwagner Exp $"
d5833 3
@


2.252
log
@Added FirstProfileNumber to fields that can be Dumped
@
text
@d2699 1
d2842 1
a2842 1
            FirstProfInChunk(nUnique) = i
d2846 1
a2846 1
        call dump ( FirstProfInChunk(1:nUnique), '1st profile with next l2gpvalue:', &
d2848 7
d5820 1
a5820 1
       "$Id: L2GPData.f90,v 2.251 2021/09/02 22:44:38 pwagner Exp $"
d5833 3
@


2.251
log
@Fixed error in ContractL2GPRecord_opt
@
text
@d2690 2
d2698 1
d2824 25
d5812 1
a5812 1
       "$Id: L2GPData.f90,v 2.250 2021/06/10 23:44:09 pwagner Exp $"
d5825 3
@


2.250
log
@Added BinNumber and MAF components to the l2gp type
@
text
@d887 1
d902 5
a906 1
    if ( present(intimes) .or. present(hoursInDay) .or. present(chunks) ) then
d5784 1
a5784 1
       "$Id: L2GPData.f90,v 2.249 2021/05/27 23:39:09 pwagner Exp $"
d5797 3
@


2.249
log
@Added 'F' option to print diffs for compatible datasets
@
text
@d356 3
d373 1
a373 1
  ! The following final method caused he sids tests
d1135 2
d1138 2
d2864 8
d3257 12
d3363 12
d3553 23
a3575 15
      l2gp%latitude       (1:nn) = proto%latitude     
      l2gp%longitude      (1:nn) = proto%longitude    
      l2gp%solarTime      (1:nn) = proto%solarTime    
      l2gp%solarZenith    (1:nn) = proto%solarZenith  
      l2gp%losAngle       (1:nn) = proto%losAngle     
      l2gp%geodAngle      (1:nn) = proto%geodAngle    
      l2gp%time           (1:nn) = proto%time         
      l2gp%chunkNumber    (1:nn) = proto%chunkNumber  
      l2gp%l2gpValue      (:,:,1:nn) = proto%l2gpValue    
      l2gp%l2gpPrecision  (:,:,1:nn) = proto%l2gpPrecision
      l2gp%status         (1:nn) = proto%status       
      l2gp%quality        (1:nn) = proto%quality      
      l2gp%convergence    (1:nn) = proto%convergence  
      if ( AscDescModeIsField ) &
        & l2gp%AscDescMode      (1:nn) = proto%AscDescMode  
d3577 15
a3591 15
      l2gp%latitude     = proto%latitude     (which)
      l2gp%longitude    = proto%longitude    (which)
      l2gp%solarTime    = proto%solarTime    (which)
      l2gp%solarZenith  = proto%solarZenith  (which)
      l2gp%losAngle     = proto%losAngle     (which) 
      l2gp%geodAngle    = proto%geodAngle    (which) 
      l2gp%time         = proto%time         (which) 
      l2gp%chunkNumber  = proto%chunkNumber  (which) 
      l2gp%l2gpValue    = proto%l2gpValue    (:,:,which)
      l2gp%l2gpPrecision= proto%l2gpPrecision(:,:,which)
      l2gp%status       = proto%status       (which)
      l2gp%quality      = proto%quality      (which)
      l2gp%convergence  = proto%convergence  (which)
      if ( AscDescModeIsField ) &
        & l2gp%AscDescMode    = proto%AscDescMode  (which)
d3593 23
a3615 15
      l2gp%latitude     = proto%latitude     
      l2gp%longitude    = proto%longitude    
      l2gp%solarTime    = proto%solarTime    
      l2gp%solarZenith  = proto%solarZenith
      l2gp%losAngle     = proto%losAngle     
      l2gp%geodAngle    = proto%geodAngle    
      l2gp%time         = proto%time         
      l2gp%chunkNumber  = proto%chunkNumber  
      l2gp%l2gpValue    = proto%l2gpValue    
      l2gp%l2gpPrecision= proto%l2gpPrecision
      l2gp%status       = proto%status       
      l2gp%quality      = proto%quality      
      l2gp%convergence  = proto%convergence  
      if ( AscDescModeIsField ) &
        & l2gp%AscDescMode    = proto%AscDescMode  
d3646 2
d4062 1
d4067 2
a4068 1
    logical :: deeBugHere
d4083 2
d4138 3
a4140 1
      ReadingAscDescMode = isInList( lowerCase(fieldList), 'AscDescMode ', '-fc' )
d4150 4
d4403 12
d4726 18
d4989 10
d5779 1
a5779 1
       "$Id: L2GPData.f90,v 2.248 2021/04/15 22:43:22 pwagner Exp $"
d5792 3
@


2.248
log
@Now uses MLS_HyperStart
@
text
@d1753 1
d1774 2
d1865 10
a1874 5
    if ( ShapesDontMatch ) then
      call output('Skipping further details because shapes dont match',&
        & advance='yes')
      call doneHere
      return
d1953 1
a1953 1
    if ( myDetails < 1 )  then
d2026 9
a2034 7
      NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%pressure', ' ', statsOnOneLine )
      if ( any(l2gp1%pressures /= l2gp2%pressures) .and. &
        & SwitchDetail(lowercase(myFields), 'pressure', '-fc') > -1 ) then
          call diff ( l2gp1%pressures, 'l2gp%pressures', &
            &         l2gp2%pressures, ' ', &
            & options=options )
        myNumDiffs = myNumDiffs + count( l2gp1%pressures /= l2gp2%pressures )
d2036 9
a2044 7
      NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%latitude', ' ', statsOnOneLine )
      if ( any(l2gp1%latitude /= l2gp2%latitude) .and. &
        & SwitchDetail(lowercase(myFields), 'lat', '-fc') > -1 ) then
          call diff ( l2gp1%latitude, 'latitude', &
            &         l2gp2%latitude, ' ', &
            & options=options )
        myNumDiffs = myNumDiffs + count( l2gp1%latitude /= l2gp2%latitude )
d2046 17
a2062 14
      NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%longitude', ' ', statsOnOneLine )
      if ( any(l2gp1%longitude /= l2gp2%longitude) .and. &
        & SwitchDetail(lowercase(myFields), 'lon', '-fc') > -1 ) then
        if ( goldbrick ) then
          call diff ( l2gp1%longitude, 'longitude', &
            &         l2gp2%longitude, ' ', &
            & options=options )
        else
          call dump ( &
            & diff_fun( l2gp1%longitude, l2gp2%longitude, &
            &         auxvalue=360._rgp, &
            &         options=AddOntoOptions('p',options) ), &
            & 'longitude', &
            & options=options )
a2063 1
        myNumDiffs = myNumDiffs + count( l2gp1%longitude /= l2gp2%longitude )
d2065 17
a2081 14
      NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%solartime', ' ', statsOnOneLine )
      if ( any(l2gp1%solarTime /= l2gp2%solarTime) .and. &
        & SwitchDetail(lowercase(myFields), 'solartime', '-fc') > -1 ) then
        if ( goldbrick ) then
          call diff ( l2gp1%solarTime, 'solarTime', &
            &         l2gp2%solarTime, ' ', &
            & options=options )
        else
          call dump ( &
            & diff_fun( l2gp1%solarTime, l2gp2%solarTime, &
            &         auxvalue=24._rgp, &
            &         options=AddOntoOptions('p',options) ), &
            & 'solarTime', &
            & options=options )
a2082 1
        myNumDiffs = myNumDiffs + count( l2gp1%solarTime /= l2gp2%solarTime )
d2084 11
a2094 9
      NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%solarzenith', ' ', statsOnOneLine )
      CrashAtBeginning = .true.
      if ( any(l2gp1%solarZenith /= l2gp2%solarZenith) .and. &
        & SwitchDetail(lowercase(myFields), 'solarzenith', '-fc') > -1 ) then
          call diff ( l2gp1%solarZenith, 'solarZenith', &
            &         l2gp2%solarZenith, ' ', &
            & options=trim(options) )
        badChunks = .true.
        myNumDiffs = myNumDiffs + count( l2gp1%solarZenith /= l2gp2%solarZenith )
d2096 9
a2104 7
      NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%losangle', ' ', statsOnOneLine )
      if ( any(l2gp1%losAngle /= l2gp2%losAngle) .and. &
        & SwitchDetail(lowercase(myFields), 'losangle', '-fc') > -1 ) then
          call diff ( l2gp1%losAngle, 'losAngle', &
            &         l2gp2%losAngle, ' ', &
            & options=options )
        myNumDiffs = myNumDiffs + count( l2gp1%losAngle /= l2gp2%losAngle )
d2106 10
a2115 8
      NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%geodangle', ' ', statsOnOneLine )
      if ( any(l2gp1%geodAngle /= l2gp2%geodAngle) .and. &
        & SwitchDetail(lowercase(myFields), 'geodangle', '-fc') > -1 ) then
          call diff ( l2gp1%geodAngle, 'geodAngle', &
            &         l2gp2%geodAngle, ' ', &
            & options=options )
        ! badChunks = .true.
        myNumDiffs = myNumDiffs + count( l2gp1%geodAngle /= l2gp2%geodAngle )
d2117 10
a2126 8
      NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%time', ' ', statsOnOneLine )
      if ( any(l2gp1%time /= l2gp2%time) .and. &
        & SwitchDetail(lowercase(myFields), 'time', '-fc') > -1 ) then
          call diff ( l2gp1%time, ' time', &
            &         l2gp2%time, ' ', &
            & options=options )
        ! badChunks = .true.
        myNumDiffs = myNumDiffs + count( l2gp1%time /= l2gp2%time )
d2128 9
a2136 7
      NameOnEachLine = merge( trim(trim(l2gp1%name)) // '%chunknumber', ' ', statsOnOneLine )
      if ( any(l2gp1%chunkNumber /= l2gp2%chunkNumber) .and. &
        & SwitchDetail(lowercase(myFields), 'chunknumber', '-fc') > -1 ) then
        call diff ( l2gp1%chunkNumber, 'chunkNumber', &
          &         l2gp2%chunkNumber, ' ', &
            & options=options )
        myNumDiffs = myNumDiffs + count( l2gp1%chunkNumber /= l2gp2%chunkNumber )
d2140 8
a2147 6
        if ( any(l2gp1%frequency /= l2gp2%frequency) .and. &
          & SwitchDetail(lowercase(myFields), 'freq', '-fc') > -1 ) then
          call diff ( l2gp1%frequency, 'frequency', &
            &         l2gp2%frequency, ' ', &
            & options=options )
        myNumDiffs = myNumDiffs + count( l2gp1%frequency /= l2gp2%frequency )
d5672 1
a5672 1
       "$Id: L2GPData.f90,v 2.247 2020/07/17 16:16:14 pwagner Exp $"
d5685 3
@


2.247
log
@Avoid reading hdf5 MissingValue attribute from hdf4 files
@
text
@d30 1
a30 1
    & MLSFile_T, L2MetaData_T, UndefinedIntegerValue
d3182 3
a3184 3
    start(1) = myFreqs(1)
    start(2) = mylevels(1)
    start(3) = myTimes(1)
d3189 1
a3189 1
      start(1) = 1
d5644 1
a5644 1
       "$Id: L2GPData.f90,v 2.246 2020/06/30 23:20:18 pwagner Exp $"
d5657 3
@


2.246
log
@ConvertL2GPToQuantity copies pressures, hopefulyy w/o crashing
@
text
@d400 4
a403 4
    character (len=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    integer,intent(IN),optional   :: offset
    integer, intent(IN), optional ::lastProfile
    integer,intent(IN),optional   :: TotNumProfs
d475 1
a475 1
    character (len=*), optional, intent(IN) ::swathName!default->l2gp%swathName
d479 1
a479 1
    integer, intent(IN), optional::offset
d485 2
a486 2
    integer, intent(IN), optional ::TotNumProfs
    integer, intent(IN), optional ::lastProfile
d2864 1
a2864 1
    character (len=*), optional, intent(IN) :: swathName ! Defaults->l2gp%name
d3937 1
a3937 1
    character (len=*), intent(IN) :: swathname ! Name of swath
d3939 2
a3940 2
    integer, intent(IN), optional :: firstProf, lastProf ! Defaults to first and last
    type( L2GPData_T ), intent(OUT) :: l2gp ! Result
d3942 1
a3942 1
    integer, intent(OUT),optional :: numProfs ! Number actually read
d4016 7
a4022 4
      ! Here we read the Missing Value attribute
      status = he5_swrdlattr( swid, 'L2gpValue', 'MissingValue', MissingValue )
      if ( status /= 0 ) then
        call MLSMessage( MLSMSG_Warning, ModuleName, &
d4025 3
a4027 2
      else
        l2gp%MissingL2GP = MissingValue(1)
d4334 1
a4334 1
    integer, intent(IN) :: l2FileHandle ! From swopen
d4336 1
a4336 1
    character (len=*), optional, intent(IN) ::swathName!default->l2gp%swathName
d4374 1
a4374 1
    character (len=*), optional, intent(IN) :: swathName ! Defaults to l2gp%swathName
d4646 2
a4647 2
    character (len=*), intent(IN), optional :: swathName ! Defaults->l2gp%name
    integer,intent(IN),optional::offset
d4751 2
a4752 2
    character (len=*), intent(IN), optional :: swathName ! Defaults->l2gp%name
    integer,intent(IN),optional::offset
d4903 1
a4903 1
    character (len=*), intent(IN), optional :: swathName ! Defaults->l2gp%name
d5511 1
a5511 1
    character (len=*), optional, intent(IN) ::swathName!default->l2gp%swathName
d5565 1
a5565 1
    character (len=*), optional, intent(IN) ::swathName!default->l2gp%swathName
d5644 1
a5644 1
       "$Id: L2GPData.f90,v 2.245 2020/03/20 23:04:13 pwagner Exp $"
d5657 3
@


2.245
log
@Made consistent with new he5_readglobalattr api
@
text
@d938 14
d5640 1
a5640 1
       "$Id: L2GPData.f90,v 2.244 2020/03/04 21:24:48 pwagner Exp $"
d5653 3
@


2.244
log
@Make stuff public needed by NCL2GPData; preFill status with l2gp%MissingStatus
@
text
@d962 1
a962 1
      & ProcessLevel, DayofYear, TAI93At0zOfGranule, status )
d2915 1
a2915 1
     & ProcessLevel, DayofYear, TAI93At0zOfGranule, status )
d5626 1
a5626 1
       "$Id: L2GPData.f90,v 2.243 2020/02/13 21:27:08 pwagner Exp $"
d5639 3
@


2.243
log
@Fix errors relating to separate MissingValue for GPH
@
text
@d56 1
a56 2
  public :: L2GPdata_t
  public :: L2GPnamelen
d62 2
a63 1
    & ExpandL2GPDataInPlace, ExtractL2GPRecord, IsL2GPSetup, &
d118 1
a118 1
  interface cpL2GPData
d123 4
d133 1
a133 1
  interface writeL2GPData
d141 1
d154 3
a156 3
! cpHE5GlobalAttrs        Copies global attributes from one l2gp file to another
! cpL2GPData              Copies swaths from one l2gp file to another
! cpL2GPDataToAttribute   Copies swathvalues from one l2gp file to another's
d165 4
a168 1
! isL2GPSetUp             Returns TRUE if all L2GP arrays allocated
d191 2
a192 2
  integer, parameter :: L2GPDEFAULT_HDFVERSION = HDFVERSION_5
  integer, parameter :: DANGERWILLROBINSON = 513 ! status for a crashed profile
d197 1
a197 1
  integer, private, parameter :: MAXCHUNKTIMES = 120
d207 7
a213 7
  integer, parameter :: CHARATTRLEN = 255   ! was GA_VALUE_LENGTH
  integer, parameter :: L2GPNameLen = 80
  integer, parameter :: NumDataFields = 5
  integer, parameter :: NumGeolocFields = 10
  integer, parameter :: MAXFNFIELDS = NumGeolocFields + NumDataFields + 4
  integer, parameter :: MAXNLEVELS = 100
  integer, parameter :: MAXNUMTIMES = 10000
d216 6
a221 6
   character (len=*), parameter :: DATA_FIELD1 = 'L2gpValue'
   character (len=*), parameter :: DATA_FIELD2 = 'L2gpPrecision'
   ! character (len=*), parameter :: DATA_FIELD3 = 'Status'
   ! character (len=*), parameter :: DATA_FIELD4 = 'Quality'
   ! character (len=*), parameter :: DATA_FIELD5 = 'Convergence'
   character (len=*), parameter :: DATA_FIELDS = &
d225 11
a235 11
   ! character (len=*), parameter :: GEO_FIELD1 = 'Latitude'
   ! character (len=*), parameter :: GEO_FIELD2 = 'Longitude'
   ! character (len=*), parameter :: GEO_FIELD3 = 'Time'
   ! character (len=*), parameter :: GEO_FIELD4 = 'LocalSolarTime'
   ! character (len=*), parameter :: GEO_FIELD5 = 'SolarZenithAngle'
   ! character (len=*), parameter :: GEO_FIELD6 = 'LineOfSightAngle'
   ! character (len=*), parameter :: GEO_FIELD7 = 'OrbitGeodeticAngle'
   ! character (len=*), parameter :: GEO_FIELD8 = 'ChunkNumber'
   ! character (len=*), parameter :: GEO_FIELD9 = 'Pressure'
   ! character (len=*), parameter :: GEO_FIELD10= 'Frequency'
   character (len=*), parameter :: GEO_FIELDS = &
d239 1
a239 1
   ! character (len=*), parameter :: HGEO_FIELDS = &
d244 3
a246 3
   character (len=*), parameter :: DIM_NAME1 = 'nTimes'
   ! character (len=*), parameter :: DIM_NAME2 = 'nLevels'
   ! character (len=*), parameter :: DIM_NAME3 = 'nFreqs'
d248 3
a250 3
   ! character (len=*), parameter :: HRD_DIM_NAME3 = 'nChans'
   character (len=*), parameter :: DIM_NAME12 = 'nLevels,nTimes'
   character (len=*), parameter :: DIM_NAME123 = 'nFreqs,nLevels,nTimes'
d253 2
a254 2
   character (len=*), parameter :: MAX_DIML = ' '
   character (len=*), parameter :: UNLIM = 'Unlim'
d256 3
a258 3
   character (len=*), parameter :: MAX_DIML1 = UNLIM
   character (len=*), parameter :: MAX_DIML12 = 'nLevels,Unlim'
   character (len=*), parameter :: MAX_DIML123 = 'nFreqs,nLevels,Unlim'
d262 4
a265 4
   ! character (len=*), parameter :: DEFAULTMAXDIM = UNLIM
   ! integer, parameter :: DEFAULT_CHUNKRANK = 1
   ! integer, dimension(7), parameter :: DEFAULT_CHUNKDIMS = (/ 1,1,1,1,1,1,1 /)
   integer, parameter :: HDFE_NOMERGE = 0       ! don't merge
d268 1
a268 1
  logical, parameter :: NAMEINDEXEVERSET = .false.  
d271 1
a271 1
  logical, parameter :: APPENDSWRITEATTRIBUTES = .true.  
d351 1
a351 1
     integer, pointer, dimension(:) :: status=>NULL()
d364 1
a364 1
     integer                           :: MissingStatus = 513 ! 512 + 1
d648 1
a648 1
          call OutputL2GP_attributes_MF (l2gp, l2GPFile, swathName)
d1001 1
a1001 1
    ! geolocations are marked with DANGERWILLROBINSON status
d5205 1
a5205 1
         l2gp%status = DANGERWILLROBINSON
d5210 1
a5210 1
         l2gp%status = DANGERWILLROBINSON
d5215 1
a5215 1
         l2gp%status = DANGERWILLROBINSON
d5220 1
a5220 1
         l2gp%status = DANGERWILLROBINSON
d5225 1
a5225 1
         l2gp%status = DANGERWILLROBINSON
d5230 1
a5230 1
         l2gp%status = DANGERWILLROBINSON
d5235 1
a5235 1
         l2gp%status = DANGERWILLROBINSON
d5240 1
a5240 1
         l2gp%status = DANGERWILLROBINSON
d5245 1
a5245 1
         l2gp%status = DANGERWILLROBINSON
d5626 1
a5626 1
       "$Id: L2GPData.f90,v 2.242 2019/10/30 20:09:37 pwagner Exp $"
d5639 3
@


2.242
log
@Prevents an array bounds error caught by NAG
@
text
@d352 3
a354 1
     ! These are the fill/missing values for all arrays except status
d356 1
a356 1
     integer                       :: MissingStatus = 513 ! 512 + 1
d1079 2
d1796 7
d1805 1
a1805 1
      call output(L2gp1%nTimes, advance='yes')
d1807 1
a1807 1
      call output(L2gp2%nTimes, advance='yes')
d1853 1
a1853 1
      & any( IsFillValue ( l2gp1%l2gpValue, l2gp1%MissingValue ) ) &
d1855 1
a1855 1
      & any( IsFillValue ( l2gp2%l2gpValue, l2gp2%MissingValue ) ) &
d1873 6
a1878 2
        fillsInL2GP1 = any( IsFillValue ( l2gp1%l2gpValue(:,:,instance), l2gp1%MissingValue ) )
        fillsInL2GP2 = any( IsFillValue ( l2gp2%l2gpValue(:,:,instance), l2gp2%MissingValue ) )
d1933 1
a1933 1
        & options=options, fillValue=l2gp1%MissingValue )
d2682 3
a2684 1
      call output ( 'Fill/Missing Values: ')
d2722 7
a2728 4
        & width=width, options=options )
        call allocate_test ( hoursInDay, l2gp%nTimes, &
          & 'hoursInDay', ModuleName )
        hoursInDay = timeToHoursInDay ( l2gp%time )
d2730 2
a2731 3
        & width=width, options=options )
        call deallocate_test ( hoursInDay, &
          & 'hoursInDay', ModuleName )
d2736 1
a2736 2
        call allocate_test ( spacing, l2gp%nTimes-1, &
          & 'spacing', ModuleName )
d2750 1
a2750 1
        & width=width, options=options )
d2768 2
a2769 2
        call dump ( real(l2gp%l2gpValue(1,:,:), r8), 'L2GPValue:', &
          & FillValue=FillValue, options=options )
d2771 2
a2772 2
        call dump ( real(l2gp%l2gpValue, r8), 'L2GPValue:', &
          & FillValue=FillValue, options=options )
d2888 1
a2888 1
    
d2944 4
d3150 1
d3232 1
d3446 1
a3446 1
      l2gp%l2gpValue    = l2gp%MissingValue
d3459 1
d3902 1
d3960 1
d3984 1
a3984 1
      swid = mls_SWattach(L2GPFile, 'HIRDLS')
d3987 1
a3987 1
      l2gp%MissingValue = -999.  ! This is a HIRDLS-specific setting
d3989 1
a3989 1
      swid = mls_SWattach(L2GPFile, l2gp%Name)
d3994 9
d4399 2
d4524 1
a4524 1
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d4538 1
a4538 1
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d4552 1
a4552 1
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d4905 1
a4905 1
    ! logical, parameter :: DEEBUG = .false.
d4956 2
d4960 1
a4960 1
      & (/ real(l2gp%MissingValue, rgp) /) )
d5088 1
a5088 1
      & rgp_type, hsize(1), (/ real(l2gp%MissingValue, rgp) /) )
d5316 1
a5316 1
      call ReplaceFillValues ( l2gp1%l2gpvalue, l2gp1%MissingValue, l2gp2%l2gpvalue )
d5618 1
a5618 1
       "$Id: L2GPData.f90,v 2.241 2019/10/21 23:20:14 pwagner Exp $"
d5631 3
@


2.241
log
@Converts l2gp to quantity even if geolocations not associated
@
text
@d3982 1
d5578 1
a5578 1
       "$Id: L2GPData.f90,v 2.240 2019/05/13 23:32:55 pwagner Exp $"
d5591 3
@


2.240
log
@Use UndefinedIntegerValue to prevent failure taking an int of -1.e15 in case of GPH
@
text
@d919 1
a927 1
    if ( associated(l2gp%l2gpValue) ) Quantity%values = l2gp%l2gpValue(1,:,:)
d5577 1
a5577 1
       "$Id: L2GPData.f90,v 2.239 2019/01/29 21:45:47 pwagner Exp $"
d5590 3
@


2.239
log
@Initializes some hdfeos character fields to prevent bleed-thru
@
text
@d30 1
a30 1
    & MLSFile_T, L2MetaData_T
d3421 1
a3421 1
      l2gp%chunkNumber  = l2gp%MissingValue
d4456 1
a4456 1
      & hdfVersion=hdfVersion, iFill=int(l2gp%MissingValue))
d4955 1
a4955 1
            & HE5T_NATIVE_INT, hsize(1), (/ int(l2gp%MissingValue) /) )
d5268 1
a5268 1
      call ReplaceFillValues ( l2gp1%chunknumber, int(l2gp1%MissingValue), &
d5577 1
a5577 1
       "$Id: L2GPData.f90,v 2.238 2018/11/12 23:11:12 pwagner Exp $"
d5590 3
@


2.238
log
@Deprecated AscDescMode
@
text
@d3949 5
d5577 1
a5577 1
       "$Id: L2GPData.f90,v 2.237 2018/08/01 22:14:27 pwagner Exp $"
d5590 3
@


2.237
log
@Added CompactL2GPRecord; corrected errors in ExtractL2GPRecord and Diff-ing with matchTimes
@
text
@d270 3
d347 2
d1883 2
a1884 1
          l2gp2Temp%AscDescMode(instance) = l2gp1%AscDescMode(instance)
d2785 1
a2785 1
    if ( showMe(myDetails > 0, myFields, 'AscDescMode ') ) &
d3164 5
a3168 3
    do i=1, count(3)
      l2gp%AscDescMode(i) = ol2gp%AscDescMode(myTimes(1) + i - 1)
    enddo
d3257 5
a3261 3
    do i=1, numTimes
      l2gp%AscDescMode(i) = ol2gp%AscDescMode(whichTimes(i))
    enddo
d3292 2
a3293 1
    sooDesu = sooDesu .and. ( size(l2gp%AscDescMode       )     > 0 )
d3427 2
a3428 1
      l2gp%AscDescMode    = 0
d3452 2
a3453 1
      l2gp%AscDescMode      (1:nn) = proto%AscDescMode  
d3468 2
a3469 1
      l2gp%AscDescMode    = proto%AscDescMode  (which)
d3484 2
a3485 1
      l2gp%AscDescMode    = proto%AscDescMode  
d3652 2
a3653 1
    l2gp%AscDescMode(1:templ2gp%nTimes) = templ2gp%AscDescMode(1:templ2gp%nTimes)
d4233 6
a4238 4
    l2gp%AscDescMode = 0 ! l2gp%MissingValue ! So it has a value.
    if ( ReadingAscDescMode ) &
      & status = mls_swrdfld( swid, 'AscDescMode ',start(3:3),stride(3:3),edge(3:3),&
      & l2gp%AscDescMode, hdfVersion=hdfVersion, dontfail=.true. )
d4540 8
a4547 7

    chunk_rank=1
    chunk_dims(1)=CHUNKTIMES
    status = mls_dfldsetup(swid, 'AscDescMode ', 'nTimes', &
    & MYDIM1, &
    & DFNT_INT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
    & hdfVersion=hdfVersion, iFill=int(l2gp%MissingValue) )
d4789 2
a4790 1
    status = mls_SWwrfld(swid, 'AscDescMode ', start(3:3), stride(3:3), edge(3:3), &
d4792 1
d5087 11
a5097 10
    
    status = mls_swwrlattr(swid, 'AscDescMode', 'Title', &
      & MLS_CHARTYPE, 1, trim(field_name)//'AscDescMode ')
    status = mls_swwrlattr(swid, 'AscDescMode', 'Units', &
      & MLS_CHARTYPE, 1, NOUNITS)
    status = he5_swwrlattr(swid, 'AscDescMode', 'MissingValue', &
      & HE5T_NATIVE_INT, hsize(1), (/ 0 /) )
    status = mls_swwrlattr(swid, 'AscDescMode', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, 'MLS-Specific')
d5572 1
a5572 1
       "$Id: L2GPData.f90,v 2.236 2018/05/31 22:47:45 pwagner Exp $"
d5585 3
@


2.236
log
@Read ProductionLocation, HostName, identifier_product_doi when dumping global attrs
@
text
@d59 1
a59 1
    & ContractL2GPRecord, ConvertL2GPToQuantity, &
d103 4
d145 3
a147 1
! ContractL2GPRecord      Gather a reduced L2GP from an existing L2GP
d159 1
a159 1
! ExtractL2GPRecord       Extract a reduced L2GP from an existing L2GP
d653 58
d895 2
a896 55
    call SetupNewL2GPRecord ( l2gp, &
      & ol2gp%nFreqs, &
      & useLevels, &
      & useTimes )

    l2gp%name               = ol2gp%name    
    l2gp%nameIndex          = ol2gp%nameIndex    
    ! l2gp%quantitytype       = ol2gp%quantitytype 
    l2gp%MissingValue       = ol2gp%MissingValue 
    l2gp%MissingStatus      = ol2gp%MissingStatus
    l2gp%verticalCoordinate = ol2gp%verticalCoordinate    
    ! Now fill the actual arrays
    if ( DeeBug ) then
      call outputNamedValue( 'UseFreqs', useFreqs )
      call outputNamedValue( 'UseLevels', useLevels )
      call outputNamedValue( 'UseTimes', useTimes )
      call dump( whichFreqs(1:useFreqs), 'whichFreqs' )
      call dump( whichLevels(1:useLevels), 'whichLevels' )
      call dump( whichTimes(1:useTimes), 'whichTimes' )
    endif
    call GatherBloc ( l2gp%pressures    , ol2gp%pressures    , &
      & whichLevels(1:useLevels) )
    call GatherBloc ( l2gp%frequency    , ol2gp%frequency    , &
      & whichFreqs(1:useFreqs) )
    call GatherBloc ( l2gp%latitude     , ol2gp%latitude     , &
      & whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%longitude    , ol2gp%longitude    , &
      & whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%solarTime    , ol2gp%solarTime    , &
      & whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%solarZenith  , ol2gp%solarZenith  , &
      & whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%losAngle     , ol2gp%losAngle     , &
      & whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%geodAngle    , ol2gp%geodAngle    , &
      & whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%time         , ol2gp%time         , &
      & whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%chunkNumber  , ol2gp%chunkNumber  , &
      & whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%l2gpValue    , ol2gp%l2gpValue    , &
      & whichFreqs(1:useFreqs), whichLevels(1:useLevels), whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%l2gpPrecision, ol2gp%l2gpPrecision, &
      & whichFreqs(1:useFreqs), whichLevels(1:useLevels), whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%status       , ol2gp%status       , &
      & whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%quality      , ol2gp%quality      , &
      & whichTimes(1:useTimes) )
    call GatherBloc ( l2gp%convergence  , ol2gp%convergence  , &
      & whichTimes(1:useTimes) )
    ! call GatherBloc ( l2gp%AscDescMode    , ol2gp%AscDescMode    , &
    !   & whichTimes(1:useTimes) )
    do i=1, useTimes
      l2gp%AscDescMode(i) = ol2gp%AscDescMode(whichTimes(i))
    enddo
d1620 2
a1621 1
    type (L2GPData_T) :: tl2gp1, tl2gp2
d1623 1
d1632 2
d1635 1
a1635 1
      call FindIntersection( l2gp1%time, l2gp2%time, which1, which2, how_many, &
d1637 11
d1652 1
a1652 1
        call FindIntersection( l2gp1%GeodAngle, l2gp2%GeodAngle, which1, which2, how_many, &
d1660 2
a1661 2
      call SetupNewL2GPRecord ( tl2gp1, proto=l2gp1, which=which1(1:how_many) )
      call SetupNewL2GPRecord ( tl2gp2, proto=l2gp2, which=which2(1:how_many) )
d1665 2
d3041 14
a3054 15
  subroutine ExtractL2GPRecord ( ol2gp, l2gp, rFreqs, rLevels, rTimes )
    ! Extract a reduced copy of an original l2gp record
    ! picking out a range of subscripts for freqs, level2, times
    ! Omitted ranges will be same range as original l2gp
    
    ! Note that this does not do the more useful task:
    ! Reposition an l2gp record onto a new set of geolocations
    ! via multi-dimensional or repeated interpolation

    ! Nor does it (yet) do another potentially useful task:
    ! Extract the range of profiles within a box of times, lats, lons
    ! and a range of levels within a range of pressures
    
    ! These last tasks aren't too difficult, since we could define
    ! myTimes and myLevels based on HuntRange.
d3056 2
a3057 2
    ! A tricky point: invalid ranges (i.e. upper limit < 1) will
    ! be treated as if they were omitted
d3059 1
d3161 95
a3255 1
  end subroutine ExtractL2GPRecord
d5550 1
a5550 1
       "$Id: L2GPData.f90,v 2.235 2018/05/22 23:41:14 pwagner Exp $"
d5563 3
@


2.235
log
@Use dumpGlobalAttributes when Dumping L2GP Attributes
@
text
@d2867 9
d5428 1
a5428 1
       "$Id: L2GPData.f90,v 2.234 2018/04/24 18:25:11 pwagner Exp $"
d5441 3
@


2.234
log
@Commented out the final method; it caused gold brick crashes
@
text
@d2777 2
a2778 1
  use PCFHdr, only:  GlobalAttributes_T, HE5_ReadGlobalAttr
d2867 1
a2867 17
      call dump(gAttributes%orbNum, 'Orbit numbers')
      call dump(gAttributes%orbPeriod, 'Orbit Periods')
      call output ('InstrumentName: ' // trim( gAttributes%InstrumentName  ), &
        & advance='yes' )
      call output ('Process level: ' // trim(  gAttributes%ProcessLevel    ), &
        & advance='yes' )
      call output ('PGE version: ' // trim(    gAttributes%PGEVersion      ), &
        & advance='yes' )
      call output ('Misc Notes: ' // trim(     gAttributes%MiscNotes      ), &
        & advance='yes' )
      call output ('Start UTC: ' // trim(      gAttributes%StartUTC        ), &
        & advance='yes' )
      call output ('End UTC: ' // trim(        gAttributes%EndUTC          ), &
        & advance='yes' )
      call dump_int ( gAttributes%GranuleMonth, 'Granule month:' )
      call dump_int ( gAttributes%GranuleDay, 'Granule day:' )
      call dump_int ( gAttributes%GranuleYear, 'Granule year:' )
d5419 1
a5419 1
       "$Id: L2GPData.f90,v 2.233 2018/04/19 00:50:43 vsnyder Exp $"
d5432 3
@


2.233
log
@Remove USE statements for unused names, add final subroutine
@
text
@d349 4
a352 2
  contains
    final :: DestroyL2GPContents
d5434 1
a5434 1
       "$Id: L2GPData.f90,v 2.232 2018/02/28 19:54:26 pwagner Exp $"
d5447 3
@


2.232
log
@Tries to prevent unwanted names on each line
@
text
@d349 2
d3367 16
a3382 16
    call deallocate_test ( l2gp%pressures,         "l2gp%pressures",         ModuleName )
    call deallocate_test ( l2gp%latitude,          "l2gp%latitude",          ModuleName )
    call deallocate_test ( l2gp%longitude,         "l2gp%longitude",         ModuleName )
    call deallocate_test ( l2gp%solarTime,         "l2gp%solarTime",         ModuleName )
    call deallocate_test ( l2gp%solarZenith,       "l2gp%solarZenith",       ModuleName )
    call deallocate_test ( l2gp%losAngle,          "l2gp%losAngle",          ModuleName )
    call deallocate_test ( l2gp%geodAngle,         "l2gp%geodAngle",         ModuleName )
    call deallocate_test ( l2gp%chunkNumber,       "l2gp%chunkNumber",       ModuleName )
    call deallocate_test ( l2gp%time,              "l2gp%time",              ModuleName )
    call deallocate_test ( l2gp%frequency,         "l2gp%frequency",         ModuleName )
    call deallocate_test ( l2gp%l2gpValue,         "l2gp%l2gpValue",         ModuleName )
    call deallocate_test ( l2gp%l2gpPrecision,     "l2gp%l2gpPrecision",     ModuleName )
    call deallocate_test ( l2gp%status,            "l2gp%status",            ModuleName )
    call deallocate_test ( l2gp%quality,           "l2gp%quality",           ModuleName )
    call deallocate_test ( l2gp%convergence,       "l2gp%convergence",       ModuleName )
    call deallocate_test ( l2gp%AscDescMode,         "l2gp%AscDescMode",       ModuleName )
a3533 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d5432 1
a5432 1
       "$Id: L2GPData.f90,v 2.231 2018/02/03 00:24:49 pwagner Exp $"
d5445 3
@


2.231
log
@Correct Status Bit names; add post-processed
@
text
@d20 2
a21 1
  use Dump_Options, only: StatsOnOneLine, NameOnEachLine
d174 1
a174 1
!       v              verbose  ! First some local parameters
d296 1
a296 1
     character (LEN=L2GPNameLen) :: name ! Typically the swath name.
d375 1
a375 1
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
d450 1
a450 1
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
d1875 1
a1875 1
    if ( statsOnOneLine ) NameOnEachLine = trim(trim(l2gp1%name)) // '%values'
d1887 1
a1887 1
    if ( statsOnOneLine ) NameOnEachLine = trim(trim(l2gp1%name)) // '%Precisions'
d1899 1
a1899 1
    if ( statsOnOneLine ) NameOnEachLine = trim(trim(l2gp1%name)) // '%status'
d1911 1
a1911 1
    if ( statsOnOneLine ) NameOnEachLine = trim(trim(l2gp1%name)) // '%quality'
d1923 1
a1923 1
    if ( statsOnOneLine ) NameOnEachLine = trim(trim(l2gp1%name)) // '%convergence'
d1943 1
d1951 1
d1959 1
d1976 1
d1993 2
d1999 1
a1999 1
            & options=options )
d2003 1
d2011 1
d2020 1
d2029 1
d2840 1
a2840 1
    if ( any( rgp /= (/ r4, r8 /) ) ) then
d3754 1
a3754 1
    character (LEN=*), intent(IN) :: swathname ! Name of swath
d3763 1
a3763 1
    character (LEN=*), parameter :: MLSMSG_INPUT = 'Error in input argument '
d3768 5
a3772 5
    character (LEN=80) :: dimlist
    character (LEN=80) :: fieldlist
    character (LEN=80) :: list
    character (LEN=80) :: maxdimlist
    character (LEN=8)  :: maxdimName
d3780 1
a3780 1
    character (LEN=480) :: msr
d4131 1
a4131 1
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
d4169 1
a4169 1
    character (LEN=*), optional, intent(IN) :: swathName ! Defaults to l2gp%swathName
d5298 1
a5298 1
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
d5352 1
a5352 1
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
d5431 1
a5431 1
       "$Id: L2GPData.f90,v 2.230 2017/12/18 16:41:09 mmadatya Exp $"
d5444 3
@


2.230
log
@Added unit for new quantity geoHeight
@
text
@d57 4
a60 4
  public :: addL2GPToDatabase, appendL2GPData, &
    & contractL2GPRecord, convertL2GPToQuantity, &
    & cpHE5GlobalAttrs, cpL2GPdata, cpL2GPDataToAttribute, &
    & destroyL2GPContents, destroyL2GPDatabase, &
d62 2
a63 2
    & expandL2GPDataInPlace, extractL2GPRecord, isL2GPSetup, &
    & readL2GPData, repairL2GP, setupNewL2GPRecord, writeL2GPData
d75 1
a75 1
  interface DIFF
d83 1
a83 1
  interface DIFFRANGE
d87 1
a87 1
  interface DIFFSTATS
d114 3
a116 3
    module procedure cpL2GPData_fileID
    module procedure cpL2GPData_fileName
    module procedure cpL2GPData_MLSFile
d125 2
a126 2
    module procedure writeL2GPData_fileID
    module procedure writeL2GPData_MLSFile
d276 2
a277 2
    & 'do not use      ', 'beware          ', '(unused)        ', &
    & 'inform          ', 'high clouds     ', 'low clouds      ', &
d5420 1
a5420 1
       "$Id: L2GPData.f90,v 2.229 2017/11/30 21:15:53 pwagner Exp $"
d5433 3
@


2.229
log
@Avoid writing MissingValue to metadata
@
text
@d4862 2
d5420 1
a5420 1
       "$Id: L2GPData.f90,v 2.228 2017/11/03 19:59:08 pwagner Exp $"
d5433 3
@


2.228
log
@Most array gymnastics moved from MLSFillValues to HyperSlabs module
@
text
@d41 1
d1099 4
a1102 4
      l2metaData%minLat= minval(l2gp%latitude)
      l2metaData%maxLat= maxval(l2gp%latitude)
      l2metaData%minLon= minval(l2gp%longitude)
      l2metaData%maxLon= maxval(l2gp%longitude)
d5418 1
a5418 1
       "$Id: L2GPData.f90,v 2.227 2017/07/19 22:51:50 pwagner Exp $"
d5431 3
@


2.227
log
@Improved appearance and consistency when Diffing L2GPData types; esp. if gold brick
@
text
@d16 1
d19 1
a19 1
  use Diff_1, only: diff, diff_fun
d24 6
a29 6
  use HDF, only: dfacc_rdonly, dfacc_read, dfacc_create, dfacc_rdwr, &
    & Dfnt_float32, dfnt_int32, dfnt_float64
  use HighOutput, only: beVerbose, outputNamedValue
  use Intrinsic ! "units" type literals, beginning with l_
  use MLSCommon, only: defaultUndefinedValue, interval_T, &
    & MLSFile_t, L2Metadata_t
d31 5
a35 6
    & HDFVersion_4, HDFversion_5, wildcardHDFversion, &
    & Dump, initializeMLSFile, MLS_closeFile, MLS_exists, MLS_openFile, &
    & MLS_HDF_version, MLS_inqswath
  use MLSKinds, only: r4, r8, rt
  use MLSFillValues, only: extractArray, gatherArray, &
    & IsfillValue, replacefillValues
d38 12
a49 12
  use MLSNumerics, only: findInRange
  use MLSFinds, only: findFirst, findLast, findUnique
  use MLSSets, only: findIntersection, intersection
  use MLSStrings, only: capitalize, lowercase
  use MLSStringLists, only: extractSubstring, &
    & GetHashElement, getStringElement, getUniqueList, &
    & List2Array, numStringElements, removeListFromList, replaceSubstring, &
    & StringElementNum, switchDetail
  use Output_m, only: blanks, output, resumeOutput, suspendOutput
  use String_table, only: display_string
  use Time_M, only: SayTime, configureSayTime, Time_Now
  use Trace_m, only: trace_begin, trace_end
d438 1
a438 1
    use MLSHDFEOS, only: MLS_swath_in_file
d845 1
a845 1
    call GatherArray ( l2gp%pressures    , ol2gp%pressures    , &
d847 1
a847 1
    call GatherArray ( l2gp%frequency    , ol2gp%frequency    , &
d849 1
a849 1
    call GatherArray ( l2gp%latitude     , ol2gp%latitude     , &
d851 1
a851 1
    call GatherArray ( l2gp%longitude    , ol2gp%longitude    , &
d853 1
a853 1
    call GatherArray ( l2gp%solarTime    , ol2gp%solarTime    , &
d855 1
a855 1
    call GatherArray ( l2gp%solarZenith  , ol2gp%solarZenith  , &
d857 1
a857 1
    call GatherArray ( l2gp%losAngle     , ol2gp%losAngle     , &
d859 1
a859 1
    call GatherArray ( l2gp%geodAngle    , ol2gp%geodAngle    , &
d861 1
a861 1
    call GatherArray ( l2gp%time         , ol2gp%time         , &
d863 1
a863 1
    call GatherArray ( l2gp%chunkNumber  , ol2gp%chunkNumber  , &
d865 1
a865 1
    call GatherArray ( l2gp%l2gpValue    , ol2gp%l2gpValue    , &
d867 1
a867 1
    call GatherArray ( l2gp%l2gpPrecision, ol2gp%l2gpPrecision, &
d869 1
a869 1
    call GatherArray ( l2gp%status       , ol2gp%status       , &
d871 1
a871 1
    call GatherArray ( l2gp%quality      , ol2gp%quality      , &
d873 1
a873 1
    call GatherArray ( l2gp%convergence  , ol2gp%convergence  , &
d875 1
a875 1
    ! call GatherArray ( l2gp%AscDescMode    , ol2gp%AscDescMode    , &
d887 2
a888 2
    use quantityTemplates, only: setUpNewQuantityTemplate
    use vectorsModule, only: vectorValue_t, createVectorValue
d912 2
a913 2
    use PCfhdr, only: globalAttributes_t, globalAttributes, &
      & dumpGlobalAttributes, HE5_Readglobalattr, HE5_Writeglobalattr
d971 1
a971 1
    use HGridsDatabase, only: HGrid_t
d1122 1
a1122 1
    use HGridsDatabase, only: hgrid_t
d1286 1
a1286 1
    use HGridsDatabase, only: HGrid_t
d1358 2
a1359 2
    use HDFEOS5, only: HE5T_native_real
    use MLSHDFEOS, only: HE5_ehwrglatt, hsize
d2433 1
a2433 2
      call output ( 'L2GP Database name: ', advance='no' )
      call output ( name, advance='yes' )
d2592 2
a2593 2
      call output ( 'L2GP Data: (swath name) ')
      call output ( trim(l2gp%name) )
a2606 9
!     if ( showMe(.true., myFields, 'quantitytype') ) then
!       call output ( 'Quantity type: ')
!       if ( l2gp%QuantityType > 0 ) then
!         call display_string ( lit_indices(l2gp%QuantityType), &
!           &             strip=.true., advance='yes' )
!       else
!         call output ( '(the QType Index was 0) ', advance='yes')
!       endif
!     endif
d2761 1
a2761 1
  use PCFHdr, only:  globalAttributes_t, HE5_ReadGlobalAttr
d2826 2
a2827 2
    call output ( 'L2GP Attributes: (swath name) ')
    call output ( trim(name), advance='yes' )
d2830 1
a2830 1
        & 'Attributes have unrecognized numeric data type; should be r4 or r8')
d3731 2
a3732 2
  use MLSStringLists, only: isInList
  use HDF5, only: size_t
d4148 1
a4148 1
  use HDFEOS5, only: HE5S_Unlimited_f
d4664 1
a4664 1
  use HDFEOS5, only: HE5T_Native_int, HE5T_Native_real, HE5T_Native_double, &
d5134 1
a5134 1
    use HGridsDatabase, only: HGrid_t
d5390 1
a5390 1
    use Dates_module, only: TAI93S2HID
d5417 1
a5417 1
       "$Id: L2GPData.f90,v 2.226 2017/03/10 00:40:19 vsnyder Exp $"
d5430 3
@


2.226
log
@Make intrsctn allocatable
@
text
@d1678 1
d1706 2
d1863 5
a1867 1
    if ( .not. skipGeos ) call diffGeoLocations( l2gp1, l2gp2Temp )
d1888 1
a1888 1
      call diff ( l2gp1%l2gpPrecision, 'l2gp%l2gpPrecision', &
d1900 1
a1900 1
      call diff ( l2gp1%status, 'l2gp%status', &
d1912 1
a1912 1
      call diff ( l2gp1%quality, 'l2gp%quality', &
d1924 1
a1924 1
      call diff ( l2gp1%convergence, 'l2gp%convergence', &
d1950 1
a1950 1
          call diff ( l2gp1%latitude, 'l2gp%latitude', &
d1957 5
d1966 1
a1966 1
            & 'l2gp%longitude', &
d1968 1
d1973 5
d1982 1
a1982 1
            & 'l2gp%solarTime', &
d1984 1
d1989 1
a1989 1
          call diff ( l2gp1%solarZenith, 'l2gp%solarZenith', &
d1997 1
a1997 1
          call diff ( l2gp1%losAngle, 'l2gp%losAngle', &
d2004 1
a2004 1
          call diff ( l2gp1%geodAngle, 'l2gp%geodAngle', &
d2012 1
a2012 1
          call diff ( l2gp1%time, 'l2gp%time', &
d2020 2
a2021 2
        call diff ( l2gp1%chunkNumber, 'l2gp1%chunkNumber', &
          &         l2gp2%chunkNumber, 'l2gp2%chunkNumber', &
d2029 1
a2029 1
          call diff ( l2gp1%frequency, 'l2gp%frequency', &
d5427 1
a5427 1
       "$Id: L2GPData.f90,v 2.225 2016/11/03 22:39:14 pwagner Exp $"
d5440 3
@


2.225
log
@Begin transition to the Time_m implmentation of sayTime
@
text
@d714 1
a714 1
    integer, dimension(:), pointer :: intrsctn
d759 1
a759 1
        intrsctn => Intersection( whichTimes(1:useTimes), tempTimes(1:n) )
d781 1
a781 1
        intrsctn => Intersection( whichTimes(1:useTimes), tempTimes(1:n) )
d814 1
a814 1
      intrsctn => Intersection( whichTimes(1:useTimes), tempTimes(1:n) )
d5408 1
a5408 1
       "$Id: L2GPData.f90,v 2.224 2016/09/07 22:46:21 pwagner Exp $"
d5421 3
@


2.224
log
@Removed unused QuantityType component from L2GPData type
@
text
@d48 1
a48 1
  use Time_M, only: Time_Now
d482 1
d501 4
a504 2
    if ( timing ) call sayTime( 'Opening file ' // trim(L2GPFile%name), tFile )
    tFile = t2
d514 5
a518 2
    if ( timing ) call sayTime( 'Checking that swath exists', tFile )
    tFile = t2
d540 4
a543 2
      if ( timing ) call sayTime( 'Guarding against HDFEOS error', tFile )
      tFile = t2
d607 4
a610 2
      if ( timing ) call sayTime( 'Writing geolocations', tFile )
      tFile = t2
d613 4
a616 2
      if ( timing ) call sayTime( 'Writing data', tFile )
      tFile = t2
d623 4
a626 2
          if ( timing ) call sayTime( 'Writing attributes', tFile )
          tFile = t2
d4565 4
a4568 2
    if ( DEEBUG ) call sayTime( 'Attaching swath ' // trim(name), tFile )
    tFile = t2
d4581 4
a4584 2
       if ( DEEBUG ) call sayTime( 'Witing 3d values and precision', tFile )
       tFile = t2
d4591 4
a4594 2
       if ( DEEBUG ) call sayTime( 'Witing 2d values', tFile )
       tFile = t2
d4597 4
a4600 2
       if ( DEEBUG ) call sayTime( 'Witing 2d precision', tFile )
       tFile = t2
d4607 4
a4610 2
       if ( DEEBUG ) call sayTime( 'Witing 1d values', tFile )
       tFile = t2
d4613 4
a4616 2
       if ( DEEBUG ) call sayTime( 'Witing 1d precision', tFile )
       tFile = t2
d4633 4
a4636 2
    if ( DEEBUG ) call sayTime( 'Witing 1d status, Quality, Asc/Desc', tFile )
    tFile = t2
d5395 2
a5396 2
!------------------------- SayTime ---------------------
  subroutine SayTime ( What, startTime )
d5402 1
a5402 1
  end subroutine SayTime
d5408 1
a5408 1
       "$Id: L2GPData.f90,v 2.223 2016/07/28 01:42:27 vsnyder Exp $"
d5421 3
@


2.223
log
@Refactoring dump and diff
@
text
@d296 1
a296 1
     integer :: QUANTITYTYPE = 0   ! E.g., l_temperature; (Where is this used?)
d818 1
a818 1
    l2gp%quantitytype       = ol2gp%quantitytype 
d1653 2
a1654 1
    logical :: badChunks
d1662 2
a1663 1
    logical :: skipGeos
d1672 1
d1803 1
d1806 2
d1814 1
a1814 1
          & any( IsFillValue ( l2gp1%l2gpValue(:,:,instance), l2gp1%MissingValue ) ) &
d1816 1
a1816 1
          & any( IsFillValue ( l2gp2%l2gpValue(:,:,instance), l2gp2%MissingValue ) ) &
d1818 4
d1840 4
a1843 2
      call output('Number of bad instances of l2gp2 reset to l2gp1 ', advance='no')
      call output(badInstances, advance='yes')
d2575 9
a2583 9
    if ( showMe(.true., myFields, 'quantitytype') ) then
      call output ( 'Quantity type: ')
      if ( l2gp%QuantityType > 0 ) then
        call display_string ( lit_indices(l2gp%QuantityType), &
          &             strip=.true., advance='yes' )
      else
        call output ( '(the QType Index was 0) ', advance='yes')
      endif
    endif
d3060 1
a3060 1
    l2gp%quantitytype       = ol2gp%quantitytype 
d3266 1
a3266 1
      l2gp%QUANTITYTYPE = proto%QUANTITYTYPE
d5380 1
a5380 1
       "$Id: L2GPData.f90,v 2.222 2016/06/13 17:59:16 pwagner Exp $"
d5393 3
@


2.222
log
@Added cpHE5GlobalAttrs
@
text
@d18 4
a21 1
  use Dump_0, only: statsOnOneLine, nameOnEachLine, diff, diff_fun, dump
d60 1
a60 1
    & diff, diffRange, dump, dumpRange, &
d90 4
a93 4
  interface DUMP
    module procedure DUMP_L2GP
    module procedure DUMP_L2GP_CHUNKS
    module procedure DUMP_L2GP_DataBase
d97 2
a98 2
  interface DUMPRANGE
    module procedure DUMPL2GPData_RANGES
a248 1
   integer, parameter :: HDFE_AUTOMERGE = 1     ! MERGE FIELDS WITH SHARE DIM
d976 1
a976 1
    integer :: chunk
d4397 1
a4397 1
    integer :: chunk
d5368 1
a5368 1
       "$Id: L2GPData.f90,v 2.221 2016/03/23 00:20:09 pwagner Exp $"
d5381 3
@


2.221
log
@DiffL2GPData now able to print name on each line
@
text
@d51 9
a59 9
  public :: l2gpdata_t
  public :: l2gpnamelen
  public :: addl2gptodatabase, appendl2gpdata, &
    & contractl2gprecord, convertl2gptoquantity, &
    & cpl2gpdata, cpl2gpdatatoattribute, &
    & destroyl2gpcontents, destroyl2gpdatabase, &
    & diff, diffrange, dump, dumprange, &
    & expandl2gpdatainplace, extractl2gprecord, isl2gpsetup, &
    & readl2gpdata, repairl2gp, setupnewl2gprecord, writel2gpdata
d138 1
d892 50
a1106 2
    use PCfhdr, only: globalAttributes_t, globalAttributes, &
      & dumpGlobalAttributes, HE5_Readglobalattr, HE5_Writeglobalattr
a1129 1
    integer :: DayofYear
a1134 2
    type(GlobalAttributes_T) :: gAttributes
    type(GlobalAttributes_T) :: gAttributesOriginal
a1140 1
    character(len=40)        :: ProcessLevel
a1141 1
    double precision         :: TAI93At0zOfGranule
d1221 3
a1223 33
      if ( DEEBUG ) then
        call output( 'Before reading global attributes', advance='yes' )
        call outputNamedValue( 'StartUTC', trim(GlobalAttributes%StartUTC) )
      endif
      call he5_readglobalattr ( File1Handle, gAttributes, &
        & ProcessLevel, DayofYear, TAI93At0zOfGranule, status )
      if ( status == 0 ) then
        if ( DEEBUG ) then
          call output ( '(Global Attributes read) ', advance='yes')
          call dumpGlobalAttributes
        endif
        if ( DEEBUG ) then
          call output( 'After reading global attributes', advance='yes' )
          call outputNamedValue( 'StartUTC', trim(GlobalAttributes%StartUTC) )
        endif
        ! Unfortunately, he5_writeglobalattr writes class-level data
        ! so must save original version so can copy new data into it 
        gAttributes%HostName = GlobalAttributes%HostName
        gAttributes%ProductionLoc = GlobalAttributes%ProductionLoc
        gAttributesOriginal = GlobalAttributes
        GlobalAttributes = gAttributes
        ! Why must we do this? Why do things not simply work out properly?
        GlobalAttributes%TAI93At0zOfGranule = TAI93At0zOfGranule
        if ( DEEBUG ) then
          call outputNamedValue('Misc Notes (written) ', trim(GlobalAttributes%MiscNotes) )
          call dumpGlobalAttributes
        endif
        call he5_writeglobalattr (File2Handle)
        ! Before leaving must restore original data back
        GlobalAttributes = gAttributesOriginal
      else
        call output ( '(Global Attributes missing) ' // trim(file1), advance='yes')
      endif
d1258 1
a2721 2

  use HDFEOS5, only: HE5T_Native_real, HE5T_Native_double
d5366 1
a5366 1
       "$Id: L2GPData.f90,v 2.220 2015/10/14 23:18:04 pwagner Exp $"
d5379 3
@


2.220
log
@RepairL2GP may optionally repair any geolocations whose chunk number is -999
@
text
@d18 1
a18 1
  use Dump_0, only: diff, diff_fun, dump
d1654 1
d1823 1
d1834 2
d1847 1
d1858 2
d1870 2
d1982 1
d5353 1
a5353 1
       "$Id: L2GPData.f90,v 2.219 2015/10/13 23:48:28 pwagner Exp $"
d5366 3
@


2.219
log
@Warn if all chunkNumbers are FillValues; exit with error if asked to create a swath with preexisting name
@
text
@d160 1
d5064 1
a5064 1
    ! Thew optional arg fields will determine which fields this applies to:
d5070 7
d5086 3
a5088 2
    integer :: HGp1 ! Effective starting HGrid profile
    integer :: HGpn ! Effective ending HGrid profile
d5090 2
a5091 2
    character (len=8) :: myOptions
    logical :: verbose
d5103 1
d5145 12
d5343 1
a5343 1
       "$Id: L2GPData.f90,v 2.218 2015/10/06 00:20:53 pwagner Exp $"
d5356 3
@


2.218
log
@Removed unused code
@
text
@d476 1
d591 2
d869 2
a870 2
    use quantitytemplates, only: setupnewquantitytemplate
    use vectorsmodule, only: vectorvalue_t, createvectorvalue
d922 1
d979 2
d988 3
d994 2
d1023 3
d1054 3
a1056 3
    use hgridsdatabase, only: hgrid_t
    use pcfhdr, only: globalattributes_t, globalattributes, &
      & dumpglobalattributes, he5_readglobalattr, he5_writeglobalattr
a2485 1
    integer :: ChunkFillValue
a2518 1
    ChunkFillValue = int(l2gp%MissingValue)
d2697 4
a2700 4
  use HDFEOS5, only: he5t_native_real, he5t_native_double
  use HE5_SWAPI, only: he5_swrdattr, he5_swrdlattr
  use MLSHDFEOS, only: mls_swattach, mls_swdetach, he5_ehrdglatt
  use PCFHdr, only:  globalAttributes_t, he5_readGlobalAttr
a2747 1
    integer :: rgp_type
d2767 1
a2767 5
    if ( rgp == r4 ) then
      rgp_type = HE5T_NATIVE_REAL
    elseif ( rgp == r8 ) then
      rgp_type = HE5T_NATIVE_DOUBLE
    else
a3531 1
    character :: my_hmot
a3540 1
    my_hmot = 'M'
d3667 4
a3670 4
  use HDFeos, only: swinqdims
  use HDFeos5, only: he5_swinqdims, he5_swinqdflds, he5_swfldinfo
  use MLSHDFeos, only: MLS_swattach, MLS_swdetach, MLS_swdiminfo, MLS_swrdfld
  use MLSstringlists, only: isinlist
d4079 1
a4079 2
    call WriteL2GPData(l2gp, l2gpFile, &
    & swathName, notUnlimited)
d4087 3
a4089 3
  use HDFEOS5, only: HE5S_UNLIMITED_F
  use MLSHDFEOS, only: MLS_SWDETACH, &
    & MLS_SWCREATE, MLS_DFLDSETUP, MLS_GFLDSETUP, MLS_SWDEFDIM
a4102 1
    character (len=480) :: MSR
d4150 4
a4153 2
       msr = 'Failed to create swath ' // TRIM(name) &
        & // ' (maybe has the same name as another swath in this file?)'
d4357 1
a4357 1
  use MLSHDFEOS, only: MLS_SWATTACH, MLS_SWDETACH, MLS_SWWRFLD
d4371 1
a4371 1
    
d4425 3
d4461 1
a4461 1
  use MLSHDFEOS, only: MLS_SWATTACH, MLS_SWDETACH, MLS_SWWRFLD
d4589 6
a4594 6
  use HDFEOS5, only: HE5T_NATIVE_INT, HE5T_NATIVE_REAL, HE5T_NATIVE_DOUBLE, &
    & MLS_CHARTYPE
  use HE5_SWAPI, only: HE5_SWWRATTR, HE5_SWWRLATTR
  use MLSHDFEOS, only: MLS_ISGLATT, &
    & MLS_SWATTACH, MLS_SWDETACH, MLS_SWWRATTR, MLS_SWWRLATTR
  use PCFHDR, only:  HE5_WRITEGLOBALATTR
a4902 1
    logical :: verbose
d4909 1
a4909 1
    verbose = ( index(myOptions, 'v') > 0 )
a4990 1
    logical :: verbose
d4997 1
a4997 1
    verbose = ( index(myOptions, 'v') > 0 )
d5321 1
a5321 1
       "$Id: L2GPData.f90,v 2.217 2015/09/17 22:57:09 pwagner Exp $"
d5334 3
@


2.217
log
@Guards against hdfeos bug in AppendL2GPData only if max chunk size not present
@
text
@d348 1
a348 1
  real :: t1, t2
d5305 1
a5305 7
    real, intent(in), optional :: startTime
    real :: myt1
    if ( present(startTime) ) then
      myt1 = startTime
    else
      myt1 = t1
    endif
d5308 1
a5308 1
    call output ( dble(t2 - myt1), advance = 'yes' )
d5315 1
a5315 1
       "$Id: L2GPData.f90,v 2.216 2015/09/03 20:26:59 pwagner Exp $"
d5328 3
@


2.216
log
@verbose shows timings in AppendL2GPData
@
text
@d183 1
a183 1
  logical, public            :: MUSTGUARDAGIANSTHDFEOSBUG  = .true.
d508 4
a511 2
    if ( swath_exists .and. MUSTGUARDAGIANSTHDFEOSBUG ) then
      if(DEEBUG) print *, 'OK, swath already exists'
d525 2
d5321 1
a5321 1
       "$Id: L2GPData.f90,v 2.214 2015/07/14 23:13:21 pwagner Exp $"
d5334 3
@


2.215
log
@Don't copy undefined data, even if it won't be used
@
text
@d22 1
a22 1
  use Highoutput, only: outputnamedvalue
d24 3
a26 3
  use MLSCommon, only: defaultundefinedvalue, interval_T, &
    & MLSFile_t, l2metadata_t
  use MLSFiles, only: filenotfound, &
d28 2
a29 2
    & Dump, initializeMLSfile, MLS_closefile, MLS_exists, MLS_openfile, &
    & MLS_HDF_version, MLS_inqswath, MLS_openfile, MLS_closefile
d31 3
a33 3
  use MLSFillvalues, only: extractarray, gatherarray, &
    & Isfillvalue, replacefillvalues
  use MLSHDFeos, only: hsize
d35 3
a37 3
  use MLSNumerics, only: findinrange
  use MLSFinds, only: findfirst, findlast, findunique
  use MLSSets, only: findintersection, intersection
d39 5
a43 5
  use MLSStringLists, only: extractsubstring, &
    & Gethashelement, getstringelement, getuniquelist, &
    & List2array, numstringelements, removelistfromlist, replacesubstring, &
    & Stringelementnum, switchdetail
  use Output_m, only: blanks, output, resumeoutput, suspendoutput
d45 1
d348 1
d469 2
d476 1
d478 1
d495 2
d506 2
d525 2
d588 2
d592 2
d600 2
d1199 7
a1205 2
        call outputNamedValue( 'exclude', trim(exclude) )
        call outputNamedValue( 'mySwathList', trim(mySwathList) )
d3682 1
d3700 1
a3700 1
    integer, dimension(4) :: dims
d3702 1
a3702 1
    integer(kind=size_t), dimension(4) :: hdims
d3760 2
a3761 2
      dims(1:nDims) = hdims(1:nDims)
      dims(nDims+1:) = 0 ! Just to make sure they're defined, not junk
d4471 1
d4494 1
d4501 2
d4515 2
d4523 2
d4527 2
d4535 2
d4539 2
d4557 2
d5298 15
d5330 3
@


2.214
log
@Added computation of interprofile geolocation spacings
@
text
@d3736 2
a3737 1
      dims = hdims
d5262 1
a5262 1
       "$Id: L2GPData.f90,v 2.213 2015/06/04 17:05:35 pwagner Exp $"
d5275 3
@


2.213
log
@Fixed bug causing integer overflow in integer type conversion
@
text
@d17 1
d19 1
d2456 1
d2563 22
d5261 1
a5261 1
       "$Id: L2GPData.f90,v 2.212 2015/04/28 16:21:11 pwagner Exp $"
d5274 3
@


2.212
log
@Fixed some things in Diffing
@
text
@d3673 1
a3736 1
      flddims = hflddims
d3745 4
a3748 1
        if ( status > 0 .and. status <= rank ) size = max(size, flddims(status))
d5236 1
a5236 1
       "$Id: L2GPData.f90,v 2.211 2015/03/28 01:09:22 vsnyder Exp $"
d5249 3
@


2.211
log
@Made DescendingRange a parameter.
Added stuff to trace allocate/deallocate addresses.
@
text
@d1636 11
a1646 1
    if ( DEEBUG ) then
d1652 3
a1654 1
      call output( myFields, advance='yes' )
a1724 7
    if ( present ( options ) ) then
      badChunks = (index(options, 'i' ) > 0) .and. badChunks
      diffGeosMeanBadChunks = ( index(options, 'd') > 0 )
      skipGeos = ( index(options, 'g') > 0 )
    else
      badChunks = .false.
    endif
d5233 1
a5233 1
       "$Id: L2GPData.f90,v 2.210 2015/02/27 23:57:55 pwagner Exp $"
d5246 4
@


2.210
log
@Take pains to ensure HostName is not blank
@
text
@d15 3
a17 3
  use allocate_deallocate, only: allocate_test, deallocate_test
  use bitstuff, only: dumpbitnames
  use dump_0, only: diff, diff_fun, dump
d19 3
a21 3
    & dfnt_float32, dfnt_int32, dfnt_float64
  use highoutput, only: outputnamedvalue
  use intrinsic ! "units" type literals, beginning with l_
d26 1
a26 1
    & dump, initializeMLSfile, MLS_closefile, MLS_exists, MLS_openfile, &
d30 1
a30 1
    & isfillvalue, replacefillvalues
d38 6
a43 6
    & gethashelement, getstringelement, getuniquelist, &
    & list2array, numstringelements, removelistfromlist, replacesubstring, &
    & stringelementnum, switchdetail
  use output_m, only: blanks, output, resumeoutput, suspendoutput
  use string_table, only: display_string
  use trace_m, only: trace_begin, trace_end
d251 1
a251 1
  type(interval_T), public :: DescendingRange = interval_T( 90._rt, 270._rt )
d3395 1
d3417 1
d3424 1
d3435 2
d3438 1
a3438 1
       call test_deallocate ( status, ModuleName, "database", s )
d5228 1
a5228 1
       "$Id: L2GPData.f90,v 2.209 2015/02/18 00:28:01 pwagner Exp $"
d5241 3
@


2.209
log
@Corrected DumpL2GP_attributes_hdf5 to include linefeeds, MiscNotes
@
text
@d1142 2
a1143 2
      call he5_readglobalattr (File1Handle, gAttributes, &
        & ProcessLevel, DayofYear, TAI93At0zOfGranule, status)
d1149 4
a1152 4
      if ( DEEBUG ) then
        call output( 'After reading global attributes', advance='yes' )
        call outputNamedValue( 'StartUTC', trim(GlobalAttributes%StartUTC) )
      endif
d1155 2
d5223 1
a5223 1
       "$Id: L2GPData.f90,v 2.208 2014/12/11 21:25:57 pwagner Exp $"
d5236 3
@


2.208
log
@Make Asc/Desc Mode -999 for crashed chunks
@
text
@d32 1
a32 1
  use MLSMessagemodule, only: MLSmsg_error, MLSmsg_warning, MLSmessage
d2288 5
a2293 1

a2323 2


a2362 1

a2417 2


d2624 1
a2624 1
  subroutine DumpL2GP_attributes_hdf5(l2FileHandle, l2gp, swathName)
d2626 4
a2629 4
  use hdfeos5, only: he5t_native_real, he5t_native_double
  use he5_swapi, only: he5_swrdattr, he5_swrdlattr
  use mlshdfeos, only: mls_swattach, mls_swdetach
  use pcfhdr, only:  globalattributes_t, he5_readglobalattr
d2639 1
a2640 1
    integer, intent(in) :: l2FileHandle ! From swopen
d2709 3
a2711 3
    call output ( '(Global Attributes) ', advance='yes')
    call he5_readglobalattr(l2FileHandle, gAttributes, &
     & ProcessLevel, DayofYear, TAI93At0zOfGranule, status)
d2715 8
d2725 12
a2736 7
      call output ('InstrumentName: ' // trim( gAttributes%InstrumentName  ))
      call output ('Process level: ' // trim(  gAttributes%ProcessLevel    ))
      ! call output ('Input version: ' // trim(  gAttributes%inputVersion    ))
      call output ('PGE version: ' // trim(    gAttributes%PGEVersion      ))
      call output ('Misc Notes: ' // trim(     gAttributes%MiscNotes      ))
      call output ('Start UTC: ' // trim(      gAttributes%StartUTC        ))
      call output ('End UTC: ' // trim(        gAttributes%EndUTC          ))
d5221 1
a5221 1
       "$Id: L2GPData.f90,v 2.207 2014/12/10 21:27:49 pwagner Exp $"
d5234 3
@


2.207
log
@Commented-out unused stuff
@
text
@d4250 1
a4250 1
    & hdfVersion=hdfVersion )
d5209 1
a5209 1
       "$Id: L2GPData.f90,v 2.206 2014/12/09 01:26:52 pwagner Exp $"
d5222 3
@


2.206
log
@Define and initialize orbit angle range for Descending mode
@
text
@d19 1
a19 1
    & dfnt_char8, dfnt_float32, dfnt_int32, dfnt_float64
d37 1
a37 1
  use MLSStringlists, only: extractsubstring, &
d194 3
a196 3
   character (len=*), parameter :: DATA_FIELD3 = 'Status'
   character (len=*), parameter :: DATA_FIELD4 = 'Quality'
   character (len=*), parameter :: DATA_FIELD5 = 'Convergence'
d201 10
a210 10
   character (len=*), parameter :: GEO_FIELD1 = 'Latitude'
   character (len=*), parameter :: GEO_FIELD2 = 'Longitude'
   character (len=*), parameter :: GEO_FIELD3 = 'Time'
   character (len=*), parameter :: GEO_FIELD4 = 'LocalSolarTime'
   character (len=*), parameter :: GEO_FIELD5 = 'SolarZenithAngle'
   character (len=*), parameter :: GEO_FIELD6 = 'LineOfSightAngle'
   character (len=*), parameter :: GEO_FIELD7 = 'OrbitGeodeticAngle'
   character (len=*), parameter :: GEO_FIELD8 = 'ChunkNumber'
   character (len=*), parameter :: GEO_FIELD9 = 'Pressure'
   character (len=*), parameter :: GEO_FIELD10= 'Frequency'
d214 4
a217 3
   character (len=*), parameter :: HGEO_FIELDS = &
     & 'Latitude,Longitude,LocalSolarTime,SolarZenithAngle,LineOfSightAngle' // &
     & ',OrbitGeodeticAngle,Time'
d221 2
a222 2
   character (len=*), parameter :: DIM_NAME2 = 'nLevels'
   character (len=*), parameter :: DIM_NAME3 = 'nFreqs'
d224 1
a224 1
   character (len=*), parameter :: HRD_DIM_NAME3 = 'nChans'
d238 3
a240 3
   character (len=*), parameter :: DEFAULTMAXDIM = UNLIM
   integer, parameter :: DEFAULT_CHUNKRANK = 1
   integer, dimension(7), parameter :: DEFAULT_CHUNKDIMS = (/ 1,1,1,1,1,1,1 /)
a3608 2
    character (LEN=*), parameter :: SZ_ERR = 'Failed to get size of &
         &dimension '
a3609 2
    character (LEN=*), parameter :: MLSMSG_L2GPRead = 'Unable to read L2GP &
                                                     &field:'
a4008 1

a4014 6
    ! Parameters

    character (len=*), parameter :: DIM_ERR = 'Failed to define dimension '
    character (len=*), parameter :: GEO_ERR = &
         & 'Failed to define geolocation field '
    character (len=*), parameter :: DAT_ERR = 'Failed to define data field '
a4280 1
    ! Parameters
a4281 3
    character (len=*), parameter :: WR_ERR = &
         & 'Failed to write geolocation field '
    
a4384 1
    character (len=*), parameter :: WR_ERR = 'Failed to write data field '
d4502 1
a4503 2

    character (len=*), parameter :: WR_ERR = 'Failed to write attribute field '
a4504 1
    ! Variables
a4505 1
    character (len=132) :: name     ! Either swathName or l2gp%name
d4529 1
d4531 2
a4533 1
    ! logical, parameter :: DEEBUG = .false.
d5209 1
a5209 1
       "$Id: L2GPData.f90,v 2.205 2014/10/01 00:02:06 pwagner Exp $"
d5222 3
@


2.205
log
@Fixed another bug in ExtractL2GPRecord
@
text
@d22 4
a25 3
  use MLScommon, only: defaultundefinedvalue, MLSfile_t, l2metadata_t
  use MLSfiles, only: filenotfound, &
    & HDFversion_4, HDFversion_5, wildcardHDFversion, &
d28 2
a29 2
  use MLSkinds, only: r4, r8
  use MLSfillvalues, only: extractarray, gatherarray, &
d32 6
a37 6
  use MLSmessagemodule, only: MLSmsg_error, MLSmsg_warning, MLSmessage
  use MLSnumerics, only: findinrange
  use MLSfinds, only: findfirst, findlast, findunique
  use MLSsets, only: findintersection, intersection
  use MLSstrings, only: capitalize, lowercase
  use MLSstringlists, only: extractsubstring, &
d248 3
d5225 1
a5225 1
       "$Id: L2GPData.f90,v 2.204 2014/09/04 23:47:44 vsnyder Exp $"
d5238 3
@


2.204
log
@More complete and accurate allocate/deallocate size tracking.
Add some tracing.
@
text
@d2959 1
a2959 1
    call ExtractArray ( l2gp%pressures    , ol2gp%pressures    , start, count, stride, block )
a3869 1

a3872 1

d4317 1
a4317 1

d4355 1
a4355 1
       status = mls_SWwrfld(swid, 'Pressure', start, stride, edge, &
d5221 1
a5221 1
       "$Id: L2GPData.f90,v 2.203 2014/07/23 21:59:53 pwagner Exp $"
d5234 4
@


2.203
log
@Fixed bugs in ExtractL2GPRecord
@
text
@d31 1
a31 2
  use MLSmessagemodule, only: MLSmsg_allocate, MLSmsg_deallocate, MLSmsg_error, &
    & MLSmsg_warning, MLSmessage
d3375 2
d3396 3
d3403 4
a3406 1
    integer :: l2gpIndex, status
d3412 1
d3414 1
a3414 2
       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_deallocate // "database" )
d3416 1
d5223 1
a5223 1
       "$Id: L2GPData.f90,v 2.202 2014/07/21 21:59:27 pwagner Exp $"
d5236 3
@


2.202
log
@Respect options when dumping AscDescMode
@
text
@d15 29
a43 29
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use BITSTUFF, only: DUMPBITNAMES
  use DUMP_0, only: DIFF, DIFF_FUN, DUMP
  use HDF, only: DFACC_RDONLY, DFACC_READ, DFACC_CREATE, DFACC_RDWR, &
    & DFNT_CHAR8, DFNT_FLOAT32, DFNT_INT32, DFNT_FLOAT64
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use INTRINSIC ! "UNITS" TYPE LITERALS, BEGINNING WITH L_
  use MLSCOMMON, only: DEFAULTUNDEFINEDVALUE, MLSFILE_T, L2METADATA_T
  use MLSFILES, only: FILENOTFOUND, &
    & HDFVERSION_4, HDFVERSION_5, WILDCARDHDFVERSION, &
    & DUMP, INITIALIZEMLSFILE, MLS_CLOSEFILE, MLS_EXISTS, MLS_OPENFILE, &
    & MLS_HDF_VERSION, MLS_INQSWATH, MLS_OpenFile, MLS_CloseFile
  use MLSKINDS, only: R4, R8
  use MLSFILLVALUES, only: EXTRACTARRAY, GATHERARRAY, &
    & ISFILLVALUE, REPLACEFILLVALUES
  use MLSHDFEOS, only: HSIZE
  use MLSMESSAGEMODULE, only: MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMSG_ERROR, &
    & MLSMSG_WARNING, MLSMESSAGE
  use MLSNUMERICS, only: FINDINRANGE
  use MLSFINDS, only: FINDFIRST, FINDLAST, FINDUNIQUE
  use MLSSETS, only: FINDINTERSECTION, INTERSECTION
  use MLSSTRINGS, only: CAPITALIZE, LOWERCASE
  use MLSSTRINGLISTS, only: EXTRACTSUBSTRING, &
    & GETHASHELEMENT, GETSTRINGELEMENT, GETUNIQUELIST, &
    & LIST2ARRAY, NUMSTRINGELEMENTS, REMOVELISTFROMLIST, REPLACESUBSTRING, &
    & STRINGELEMENTNUM, SWITCHDETAIL
  use OUTPUT_M, only: BLANKS, OUTPUT, RESUMEOUTPUT, SUSPENDOUTPUT
  use STRING_TABLE, only: DISPLAY_STRING
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
d48 9
a56 9
  public :: L2GPDATA_T
  public :: L2GPNAMELEN
  public :: ADDL2GPTODATABASE, APPENDL2GPDATA, &
    & CONTRACTL2GPRECORD, CONVERTL2GPTOQUANTITY, &
    & CPL2GPDATA, CPL2GPDATATOATTRIBUTE, &
    & DESTROYL2GPCONTENTS, DESTROYL2GPDATABASE, &
    & DIFF, DIFFRANGE, DUMP, DUMPRANGE, &
    & EXPANDL2GPDATAINPLACE, EXTRACTL2GPRECORD, ISL2GPSETUP, &
    & READL2GPDATA, REPAIRL2GP, SETUPNEWL2GPRECORD, WRITEL2GPDATA
d405 1
a405 1
     & name=trim(fileName), HDFVersion=the_hdfVersion )
d426 1
a426 1
    use MLSHDFEOS, only: MLS_SWATH_IN_FILE
d838 2
a839 2
    use QUANTITYTEMPLATES, only: SETUPNEWQUANTITYTEMPLATE
    use VECTORSMODULE, only: VECTORVALUE_T, CREATEVECTORVALUE
d872 1
a872 1
    use HGridsDatabase, only: HGRID_T
d1012 3
a1014 3
    use HGRIDSDATABASE, only: HGRID_T
    use PCFHDR, only: GLOBALATTRIBUTES_T, GLOBALATTRIBUTES, &
      & DUMPGLOBALATTRIBUTES, HE5_READGLOBALATTR, HE5_WRITEGLOBALATTR
d1205 1
a1205 1
    use HGridsDatabase, only: HGRID_T
d1277 2
a1278 2
    use HDFEOS5, only: HE5T_NATIVE_REAL
    use MLSHDFEOS, only: HE5_EHWRGLATT, HSIZE
d2623 4
a2626 4
  use HDFEOS5, only: HE5T_NATIVE_REAL, HE5T_NATIVE_DOUBLE
  use HE5_SWAPI, only: HE5_SWRDATTR, HE5_SWRDLATTR
  use MLSHDFEOS, only: MLS_SWATTACH, MLS_SWDETACH
  use PCFHDR, only:  GLOBALATTRIBUTES_T, HE5_READGLOBALATTR
d2950 10
a2959 6
    start(1) = mylevels(1)
    start(2) = myTimes(1)
    start(3) = myFreqs(1)
    count(1) = mylevels(2) - mylevels(1) + 1
    count(2) = myTimes(2) - myTimes(1) + 1
    count(3) = myFreqs(2) - myFreqs(1) + 1
d2961 9
a2969 9
    call ExtractArray ( l2gp%frequency    , ol2gp%frequency    , start(3:3), count(3:3), stride(3:3), block(3:3) )
    call ExtractArray ( l2gp%latitude     , ol2gp%latitude     , start(2:2), count(2:2), stride(2:2), block(2:2) )
    call ExtractArray ( l2gp%longitude    , ol2gp%longitude    , start(2:2), count(2:2), stride(2:2), block(2:2) )
    call ExtractArray ( l2gp%solarTime    , ol2gp%solarTime    , start(2:2), count(2:2), stride(2:2), block(2:2) )
    call ExtractArray ( l2gp%solarZenith  , ol2gp%solarZenith  , start(2:2), count(2:2), stride(2:2), block(2:2) )
    call ExtractArray ( l2gp%losAngle     , ol2gp%losAngle     , start(2:2), count(2:2), stride(2:2), block(2:2) )
    call ExtractArray ( l2gp%geodAngle    , ol2gp%geodAngle    , start(2:2), count(2:2), stride(2:2), block(2:2) )
    call ExtractArray ( l2gp%time         , ol2gp%time         , start(2:2), count(2:2), stride(2:2), block(2:2) )
    call ExtractArray ( l2gp%chunkNumber  , ol2gp%chunkNumber  , start(2:2), count(2:2), stride(2:2), block(2:2) )
d2972 4
a2975 3
    call ExtractArray ( l2gp%status       , ol2gp%status       , start(2:2), count(2:2), stride(2:2), block(2:2) )
    call ExtractArray ( l2gp%quality      , ol2gp%quality      , start(2:2), count(2:2), stride(2:2), block(2:2) )
    call ExtractArray ( l2gp%convergence  , ol2gp%convergence  , start(2:2), count(2:2), stride(2:2), block(2:2) )
d2977 1
a2977 1
    do i=1, count(2)
d3573 5
a3577 5
  use HDFEOS, only: SWINQDIMS
  use HDFEOS5, only: HE5_SWINQDIMS, HE5_SWINQDFLDS, HE5_SWFLDINFO
  use MLSHDFEOS, only: MLS_SWATTACH, MLS_SWDETACH, MLS_SWDIMINFO, MLS_SWRDFLD
  use MLSSTRINGLISTS, only: ISINLIST
  use HDF5, only: SIZE_T
d4962 1
a4962 1
    use HGridsDatabase, only: HGRID_T
d5085 3
a5087 3
  use HDFEOS5, only: HE5_SWSETALIAS
  use MLSHDFEOS, only: MLS_SWATTACH, MLS_SWDETACH
  use SDPToolkit, only: PGS_S_SUCCESS
d5197 1
a5197 1
    use DATES_MODULE, only: TAI93S2HID
d5215 1
a5215 1
       "$Id: L2GPData.f90,v 2.201 2014/04/07 17:24:33 pwagner Exp $"
d5228 3
@


2.201
log
@Added new l2gp data field AscDescMode
@
text
@d2599 2
a2600 1
      & call dump ( l2gp%AscDescMode, 'AscDescMode :' )
d5210 1
a5210 1
       "$Id: L2GPData.f90,v 2.200 2014/04/02 23:03:11 pwagner Exp $"
d5223 3
@


2.200
log
@Removed redundant open_ and close_MLSFile
@
text
@d19 1
a19 1
    & DFNT_FLOAT32, DFNT_INT32, DFNT_FLOAT64
d325 1
d826 5
d1591 1
a1591 1
      & 'l2gpvalue, l2gpPrecision, status, quality, convergence'
d1744 1
d2598 3
d2885 1
d2970 4
d3001 1
d3118 1
d3135 1
d3159 1
d3174 1
d3189 1
d3219 1
d3326 2
a3327 1
      & l2gp%l2gpPrecision, l2gp%status, l2gp%quality, l2gp%convergence )
d3356 1
d3626 1
d3640 1
d3674 1
d3926 5
a4233 1
    if ( deebughere )  print *, 'chunk_dims ', chunk_dims(1:chunk_rank)
d4239 7
d4462 3
a4729 1

d4754 10
d5209 1
a5209 1
       "$Id: L2GPData.f90,v 2.199 2014/01/09 00:24:29 pwagner Exp $"
d5222 3
@


2.199
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d26 1
a26 1
    & MLS_HDF_VERSION, MLS_INQSWATH, OPEN_MLSFILE, CLOSE_MLSFILE
d405 1
a405 1
    ! call open_MLSFile( MLSFile )
d411 1
a411 1
    ! call close_MLSFile( MLSFile )
d1088 1
a1088 1
    call open_MLSFile( MLSFile1 )
d1120 1
a1120 1
    call open_MLSFile( MLSFile2 )
d1169 2
a1170 2
        call close_MLSFile( MLSFile1 )
        call close_MLSFile( MLSFile2 )
d1181 1
a1181 1
    call close_MLSFile( MLSFile1 )
d1183 1
a1183 1
    call close_MLSFile( MLSFile2 )
d1289 1
a1289 1
    if ( .not. L2GPfile2%stillOpen ) call open_MLSFile( L2GPfile2 )
d1293 1
a1293 1
    call close_MLSFile( L2GPfile2 )
d2164 1
a2164 1
    call open_MLSFile( MLSFile1 )
d2168 1
a2168 1
    call open_MLSFile( MLSFile2 )
d2235 2
a2236 2
    call close_MLSFile( MLSFile1 )
    call close_MLSFile( MLSFile2 )
d3463 1
a3463 1
    call open_MLSFile( MLSFile )
d3468 1
a3468 1
    call close_MLSFile( MLSFile )
d5159 1
a5159 1
       "$Id: L2GPData.f90,v 2.198 2013/10/15 23:53:40 pwagner Exp $"
d5172 3
@


2.198
log
@May copy quantity values to a file global attribute
@
text
@d20 1
d41 1
a41 2
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE, &
    & RESUMEOUTPUT, SUSPENDOUTPUT
d1300 1
a1300 1
    ! Dump selected chunks of an l2gp
d1304 1
a1304 1
    integer, intent(in), dimension(:) :: Chunks ! Which chunks to dump
d1359 1
a1359 1
    ! Dump selected levels of an l2gp
d1363 2
a1364 2
    real(rgp), intent(in), dimension(:) :: pressures ! Which levels to dump
    integer, intent(in), optional, dimension(:) :: Chunks ! Which chunks to dump
d1436 1
a1436 1
    integer, intent(in), optional, dimension(:) :: Chunks ! Which chunks to dump
d5159 1
a5159 1
       "$Id: L2GPData.f90,v 2.197 2013/09/25 00:45:44 pwagner Exp $"
d5172 3
@


2.197
log
@Convert must set quantity geolocations, too
@
text
@d51 2
a52 1
    & CONTRACTL2GPRECORD, CONVERTL2GPTOQUANTITY, CPL2GPDATA, &
d136 2
d1266 30
d5159 1
a5159 1
       "$Id: L2GPData.f90,v 2.196 2013/09/24 00:53:53 pwagner Exp $"
d5172 3
@


2.196
log
@Can now convert an l2gpData type to a vector quantity
@
text
@d839 8
d5126 1
a5126 1
       "$Id: L2GPData.f90,v 2.195 2013/09/17 22:35:40 pwagner Exp $"
d5139 3
@


2.195
log
@Changed api of Embed, Extract arrays to match hyperslab
@
text
@d48 8
a55 7
  public :: L2GPData_T
  public :: L2GPNameLen
  public :: AddL2GPToDatabase, AppendL2GPData, ContractL2GPRecord, cpL2GPData, &
    & DestroyL2GPContents, DestroyL2GPDatabase, &
    & diff, diffRange, Dump, dumpRange, &
    & ExpandL2GPDataInPlace, ExtractL2GPRecord, isL2GPSetUp, &
    & ReadL2GPData, RepairL2GP, SetupNewL2GPRecord, WriteL2GPData
d133 1
d824 18
d5118 1
a5118 1
       "$Id: L2GPData.f90,v 2.194 2013/08/31 01:24:53 vsnyder Exp $"
d5131 3
@


2.194
log
@Replace MLSMessageCalls with trace_begin and trace_end
@
text
@d2818 4
d2827 2
d2876 22
a2897 15
    call ExtractArray ( l2gp%pressures    , ol2gp%pressures    , myLevels )
    call ExtractArray ( l2gp%frequency    , ol2gp%frequency    , myFreqs )
    call ExtractArray ( l2gp%latitude     , ol2gp%latitude     , myTimes )
    call ExtractArray ( l2gp%longitude    , ol2gp%longitude    , myTimes )
    call ExtractArray ( l2gp%solarTime    , ol2gp%solarTime    , myTimes )
    call ExtractArray ( l2gp%solarZenith  , ol2gp%solarZenith  , myTimes )
    call ExtractArray ( l2gp%losAngle     , ol2gp%losAngle     , myTimes )
    call ExtractArray ( l2gp%geodAngle    , ol2gp%geodAngle    , myTimes )
    call ExtractArray ( l2gp%time         , ol2gp%time         , myTimes )
    call ExtractArray ( l2gp%chunkNumber  , ol2gp%chunkNumber  , myTimes )
    call ExtractArray ( l2gp%l2gpValue    , ol2gp%l2gpValue    , myFreqs, myLevels, myTimes )
    call ExtractArray ( l2gp%l2gpPrecision, ol2gp%l2gpPrecision, myFreqs, myLevels, myTimes )
    call ExtractArray ( l2gp%status       , ol2gp%status       , myTimes )
    call ExtractArray ( l2gp%quality      , ol2gp%quality      , myTimes )
    call ExtractArray ( l2gp%convergence  , ol2gp%convergence  , myTimes )
d5098 1
a5098 1
       "$Id: L2GPData.f90,v 2.193 2013/08/12 23:47:25 pwagner Exp $"
d5111 3
@


2.193
log
@FindSomethings moved to MLSFinds module
@
text
@d31 1
a31 1
    & MLSMSG_WARNING, MLSMESSAGE, MLSMESSAGECALLS
d43 1
d420 2
a421 1
  use MLSHDFEOS, only: MLS_SWATH_IN_FILE
d448 1
d459 1
a459 1
    call MLSMessageCalls( 'push', constantName='AppendL2GPData_MLSFile' )
d583 1
a583 1
    call MLSMessageCalls( 'pop' )
d3514 1
a3515 2
    integer, dimension(3) :: start, stride, edge
    integer, dimension(4) :: dims
d3517 1
d3519 1
d3531 1
a3531 1
    call MLSMessageCalls( 'push', constantName= 'ReadL2GPData_MF_hdf' )
d3694 1
a3694 1
      call MLSMessageCalls( 'pop' )
d3839 2
a3840 2
    call MLSMessageCalls( 'pop' )
    !-----------------------------
a3841 1
  !-----------------------------
d3876 1
a3877 1
  !-------------------------------------------------------------
d5019 1
d5023 1
a5023 1
    call MLSMessageCalls( 'push', constantName='writeL2GPData_MLSFile' )
d5051 1
a5051 1
    call MLSMessageCalls( 'pop' )
d5085 1
a5085 1
       "$Id: L2GPData.f90,v 2.192 2013/04/05 23:17:52 pwagner Exp $"
d5098 3
@


2.192
log
@Uses function from dates_module
@
text
@d33 2
a34 2
  use MLSSETS, only: FINDFIRST, FINDINTERSECTION, FINDLAST, FINDUNIQUE, &
    & INTERSECTION
d5081 1
a5081 1
       "$Id: L2GPData.f90,v 2.191 2013/02/26 00:11:49 pwagner Exp $"
d5094 3
@


2.191
log
@Dumps times both as tai and hoursInDay
@
text
@d5050 1
d5062 2
a5063 1
    ! Given rgp hid, return r8 time as tai(s)
a5068 1
    integer :: theday
d5073 1
a5073 2
      theDay = (time+10._r8) / (24*3600._r8)
      hid = (time - theDay*24*3600._r8) / 3600
d5081 1
a5081 1
       "$Id: L2GPData.f90,v 2.190 2013/02/21 22:22:53 pwagner Exp $"
d5094 3
@


2.190
log
@New optional args ti ContractL2GPRecord
@
text
@d2365 1
d2466 3
a2468 2
      if ( showMe(myDetails > -1, myFields, 'time') ) &
        & call dump ( l2gp%time, 'Time:', FillValue=FillValue, &
d2470 8
d5060 17
d5081 1
a5081 1
       "$Id: L2GPData.f90,v 2.189 2013/01/02 21:00:37 pwagner Exp $"
d5094 3
@


2.189
log
@Warn instead dying if no swaths to copy
@
text
@d644 1
a644 1
    & longitudes, times )
d650 4
a653 2
    real(rgp), dimension(2), intent(in), optional :: longitudes  ! range
    real(r8), dimension(2), intent(in), optional :: times  ! range
d657 5
a664 1
    integer, dimension(4000) :: tempTimes  ! subscripts
a665 3
    integer :: useFreqs  
    integer :: useLevels 
    integer :: useTimes  
d680 1
a680 1
    useLevels = ol2gp%nLevels
d735 7
a741 1
    if ( present(times) ) then
a750 10
        intrsctn => Intersection( whichTimes(1:useTimes), tempTimes(1:n) )
        useTimes = size(intrsctn)
        whichTimes(1:useTimes) = intrsctn
        if ( DeeBug ) then
          call dump( times, 'times' )
          call outputNamedValue( 'n', n )
          call dump( tempTimes(1:n), 'tempTimes' )
          call dump( intrsctn(1:useTimes), 'intrsctn' )
        endif
        call deallocate_test( intrsctn, 'intersection with times', ModuleName )
d752 14
d1408 1
a1408 1
        & latitudes=latitudes, longitudes=longitudes, times=times )
d1410 1
a1410 1
        & latitudes=latitudes, longitudes=longitudes, times=times )
d2330 1
a2330 1
        & latitudes=latitudes, longitudes=longitudes, times=times )
d5039 10
d5054 1
a5054 1
       "$Id: L2GPData.f90,v 2.188 2012/10/09 00:34:52 pwagner Exp $"
d5067 3
@


2.188
log
@Fixed bugs in OutputL2GP_attributes_MF, AppendL2GPData
@
text
@d868 1
a868 1
    noSwaths = NumStringElements(trim(swathList), countEmpty)
d871 1
a871 1
            & 'No swaths cp to file--unable to count swaths in ' // trim(swathList) )
d984 1
d1115 11
a1125 1
      call RemoveListFromList(mySwathList, myrename, exclude)
d5031 1
a5031 1
       "$Id: L2GPData.f90,v 2.187 2012/09/18 18:50:25 pwagner Exp $"
d5044 3
@


2.187
log
@Dont write over already-there global attributes
@
text
@a98 1
    module procedure AppendL2GPData_fileID
d352 2
a353 2
    character (len=*), intent(in) :: fileName ! Name of swath
    type( l2GPData_T ), intent(inout) :: l2gp ! Result
d355 3
a357 3
    integer,intent(IN),optional :: offset
    integer, intent(IN), optional::lastProfile
    integer,intent(IN),optional :: TotNumProfs
d364 6
a369 7
    logical :: file_exists
    integer :: file_access
    integer :: L2FileHandle
    type(MLSFile_T)                :: MLSFile
    logical :: myClean
    integer :: status
    integer :: the_hdfVersion
d399 5
a403 5
    call open_MLSFile( MLSFile )
    L2FileHandle = MLSFile%FileID%f_id
    call AppendL2GPData_fileID( l2gp, L2FileHandle, swathname, &
      & FileName, offset, lastProfile=lastProfile, totNumProfs=totNumProfs, &
      & hdfVersion=the_hdfVersion, createSwath=createSwath, &
d405 1
a405 1
    call close_MLSFile( MLSFile )
a406 55

  subroutine AppendL2GPData_fileID( l2gp, l2FileHandle, &
    & swathName, filename, offset, lastProfile, TotNumProfs, hdfVersion, &
    & createSwath, maxchunksize )
    ! sticks l2gp into the swath swathName in the file pointed at by
    ! l2FileHandle,starting at the profile number "offset" (First profile
    ! in the file has offset==0). If this runs off the end of the swath, 
    ! it is lengthened automagically. 
    ! This call has been altered recently, so that it can be used to create
    ! a swath as well as adding to one. 

    ! Arguments

    integer, intent(IN) :: l2FileHandle ! From swopen

    ! This is a L2GPData_T structure containing all the data to be written
    type (L2GPData_T), intent(INOUT) :: l2gp
    ! This is the name the swath is given in the file. By default it is
    ! the name contained in l2gp
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    character (LEN=*), optional, intent(IN) ::fileName
    ! This (offset) is the point in the swath at which the data is written. 
    ! First profile in the file has offset==0. If the swath in the file is 
    ! shorter than offset + ( num of profiles in l2gp) then it grows by magic
    integer, intent(IN), optional::offset
    ! TotNumProfs is a new argument. It seems only to be used if we are 
    ! creating a swath, rather than adding to one. In that case I guess
    ! it is the total number of profiles in the swath created. I also 
    ! guess that this is done so that we can avoid growing and re-growing 
    ! the swath.
    integer, intent(IN), optional::TotNumProfs
    integer, intent(IN), optional::lastProfile
    integer, optional, intent(in) :: hdfVersion ! better be 4 or 5!
    logical, intent(in), optional :: createSwath
    integer, optional, intent(in) :: maxchunksize
    ! Local
    integer :: myhdfVersion
    integer :: status
    type( MLSFile_T ) :: l2gpFile

    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L2GPDEFAULT_HDFVERSION
    endif
    status = InitializeMLSFile( l2gpFile, type=l_swath, access=DFACC_RDWR, &
      & content='l2gp', name='unknown', hdfVersion=myhdfVersion )
    l2gpFile%FileID%f_id = l2FileHandle
    l2gpFile%stillOpen = .true.
    
    call AppendL2GPData( l2gp, l2gpFile, &
    & swathName, offset, lastProfile, TotNumProfs, createSwath, maxchunksize )
  end subroutine AppendL2GPData_fileID

d438 2
a439 2
    integer, intent(IN), optional::TotNumProfs
    integer, intent(IN), optional::lastProfile
d4507 5
a4511 1
      ! Hopefully by now we've turned species_name into one of the species
d4513 1
d5020 1
a5020 1
       "$Id: L2GPData.f90,v 2.186 2012/07/10 15:18:05 pwagner Exp $"
d5033 3
@


2.186
log
@Adapted to new api for GetUniqueList
@
text
@d1137 4
d1148 4
d4391 2
a4392 1
  use MLSHDFEOS, only: MLS_SWATTACH, MLS_SWDETACH, MLS_SWWRATTR, MLS_SWWRLATTR
d4472 2
a4473 1
    if ( WRITEMASTERSFILEATTRIBUTES ) &
d5072 1
a5072 1
       "$Id: L2GPData.f90,v 2.185 2012/07/05 23:49:04 pwagner Exp $"
d5085 3
@


2.185
log
@Sets swath Status field to "crashed" if cpl2gpdata options contains "f" and geolocations contain Fills
@
text
@d2089 2
a2090 2
        call GetUniqueList(swList, swathUnique, noUnique, countEmpty, &
          & str2=trim(swathList1))
d2097 2
a2098 2
        call GetUniqueList(swList, swathUnique, noUnique, countEmpty, &
          & str2=trim(swathList2))
d2108 2
a2109 2
        call GetUniqueList(trim(swathList1), swathUnique, noUnique, countEmpty, &
          & str2=trim(swathList2))
d2114 2
a2115 2
        call GetUniqueList(trim(swathList2), swathUnique, noUnique, countEmpty, &
          & str2=trim(swathList1))
d5062 1
a5062 1
       "$Id: L2GPData.f90,v 2.184 2012/05/10 00:45:24 pwagner Exp $"
d5075 3
@


2.184
log
@Better way for AppendL2GPData to know it must create swath
@
text
@d153 1
d163 1
d209 3
d865 1
a865 1
  subroutine cpL2GPData_fileID(l2metaData, file1, file2, swathList, &
d867 1
a867 1
    & HGrid, rFreqs, rLevels, rTimes, options)
d872 3
a874 1
    ! and, depending on options, makes some repairs
d896 1
d916 1
d958 3
a960 2
      ! Possibly repair l2gp
      if ( repair ) call RepairL2GP(l2gp, HGrid, options=options)
d4656 88
d5062 1
a5062 1
       "$Id: L2GPData.f90,v 2.183 2012/05/01 23:12:34 pwagner Exp $"
d5075 3
@


2.183
log
@Maneuver around an unnecessary and sometimes unfortunate if
@
text
@d471 1
a471 1
  use MLSHDFEOS, only: MLS_SWATTACH, MLS_SWDETACH
a503 1
    integer :: swathid
d532 2
a533 13
    if ( present(createSwath) .and. .false. ) then
      swath_exists = .not. createSwath
    else
      swathid = mls_swattach(L2GPFile, trim(myswathName), &
        & DONTFAIL=.true.)
      swath_exists = ( swathid > 0 )
      if ( swath_exists ) then
        status = mls_swdetach(swathid, hdfVersion=l2gpfile%hdfVersion)
        if ( status /= 0 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, & 
          & 'Failed to detach from swath in AppendL2GPData_fileID', MLSFile=L2GPFile)
      endif
    endif
d4964 1
a4964 1
       "$Id: L2GPData.f90,v 2.182 2012/01/11 17:35:20 pwagner Exp $"
d4977 3
@


2.182
log
@Turn off extra debugging; snip commented-out lines
@
text
@d533 1
a533 1
    if ( present(createSwath) ) then
d4976 1
a4976 1
       "$Id: L2GPData.f90,v 2.181 2011/12/07 01:18:14 pwagner Exp $"
d4989 3
@


2.181
log
@Added new 'd' and 'g' options to diff
@
text
@d23 1
a23 1
    & HDFVERSION_4, HDFVERSION_5, WILDCARDHDFVERSION, WRONGHDFVERSION, &
d1044 1
a1044 1
    logical, parameter :: DEEBUG = .TRUE.
a1174 5
    ! status = mls_io_gen_closeF(l_swath, File1Handle, FileName=File1, &
    !  & hdfVersion=the_hdfVersion1, debugOption=.false.)
    !if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to close L2gp file: " // trim(File1) // ' after cping')
a1176 8
    !status = mls_io_gen_closeF(l_swath, File2Handle, &
     ! & hdfVersion=the_hdfVersion2, debugOption=.false.)
    !if ( status /= 0 ) then
    !  print *, 'status returned from mls_io_gen_closeF: ', status
    !  print *, 'WRONGHDFVERSION: ', WRONGHDFVERSION
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to close L2gp file: " // trim(File2) // ' after cping')
    !endif
a1301 3
      ! call output( 'First, Last == chunk number ', advance='no' )
      ! call output( irange, advance='yes' )
      ! call HuntRange( fullL2gp1%chunkNumber, (/ chunk, chunk /), irange )
a1307 2
      ! call output( 'irange: ', advance='no' )
      ! call output( irange, advance='yes' )
a1309 2
      ! call output( 'nTimes: ', advance='no' )
      ! call output( l2gp1%nTimes, advance='yes' )
a1367 2
      ! call output( 'irange: ', advance='no' )
      ! call output( irange, advance='yes' )
a1369 2
      ! call output( 'nTimes: ', advance='no' )
      ! call output( l2gp1%nTimes, advance='yes' )
a1438 2
    ! call output( 'nTimes: ', advance='no' )
    ! call output( l2gp1%nTimes, advance='yes' )
a1852 2
        ! call dump ( l2gp1%chunkNumber - l2gp2%chunkNumber, &
        !  & 'l2gp%chunkNumber (diff)', stats=stats, rms=rms )
a1873 1
      ! print *, 'myNumDiffs: ', myNumDiffs
a2199 10
    ! status = mls_io_gen_closeF(l_swath, File1Handle, FileName=File1, &
    !  & hdfVersion=the_hdfVersion1, debugOption=.false.)
    !if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to close L2gp file: " // trim(File1) // ' after diff')
    !status = mls_io_gen_closeF(l_swath, File2Handle, FileName=File2, &
    !  & hdfVersion=the_hdfVersion1, debugOption=.false.)
    !if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to close L2gp file: " // trim(File2) // ' after diff')
a2358 2
    ! call output( 'nTimes: ', advance='no' )
    ! call output( l2gp1%nTimes, advance='yes' )
d4827 1
a4827 1
    !    & ModuleName )
d4976 1
a4976 1
       "$Id: L2GPData.f90,v 2.180 2011/07/07 00:31:03 pwagner Exp $"
d4989 3
@


2.180
log
@Treats diffs of geolocation fields with periods
@
text
@d152 2
d1532 1
a1532 1
      print *, 'About to enter ..atLast having matched times'
d1538 1
d1576 2
d1609 1
d1611 1
d1692 2
d1699 2
a1700 1
    if ( badChunks ) then
d1706 7
a1712 1
          & l2gp1%time(instance) /= l2gp2%time(instance) &
d1743 1
a1743 1
    call diffGeoLocations( l2gp1, l2gp2Temp )
d2439 1
d2458 2
a2459 1
    
d2504 44
a2547 42
     ! if ( myDetails < 0 ) return
    if ( showMe(myDetails > -1, myFields, 'pressure') ) &
      & call dump ( l2gp%pressures, trim(l2gp%verticalCoordinate) // 's:', &
      & FillValue=FillValueGP, width=width, options=options )
      
    if ( showMe(myDetails > -1, myFields, 'latitude') ) &
      & call dump ( l2gp%latitude, 'Latitude:', FillValue=FillValueGP, &
      & width=width, options=options )
      
    if ( showMe(myDetails > -1, myFields, 'longitude') ) &
      & call dump ( l2gp%longitude, 'Longitude:', FillValue=FillValueGP, &
      & width=width, options=options )
      
    if ( showMe(myDetails > -1, myFields, 'solartime') ) &
      & call dump ( l2gp%solarTime, 'SolarTime:', FillValue=FillValueGP, &
      & width=width, options=options )
      
    if ( showMe(myDetails > -1, myFields, 'solarzenith') ) &
      & call dump ( l2gp%solarZenith, 'SolarZenith:', FillValue=FillValueGP, &
      & width=width, options=options )
      
    if ( showMe(myDetails > -1, myFields, 'LOSAngle') ) &
      & call dump ( l2gp%losAngle, 'LOSAngle:', FillValue=FillValueGP, &
      & width=width, options=options )
      
    if ( showMe(myDetails > -1, myFields, 'geodAngle') ) &
      & call dump ( l2gp%geodAngle, 'geodAngle:', FillValue=FillValueGP, &
      & width=width, options=options )
      
    if ( showMe(myDetails > -1, myFields, 'time') ) &
      & call dump ( l2gp%time, 'Time:', FillValue=FillValue, &
      & width=width, options=options )
      
    if ( showMe(myDetails > -1, myFields, 'chunkNumber') ) &
      & call dump ( l2gp%chunkNumber, 'ChunkNumber:', &
      & width=width, options=options )
      
    if ( showMe(myDetails > -1, myFields, 'pressure') .and. &
      & associated(l2gp%frequency) ) &
      & call dump ( l2gp%frequency, 'Frequencies:', FillValue=FillValueGP, &
      & width=width, options=options )
      
d5017 1
a5017 1
       "$Id: L2GPData.f90,v 2.179 2011/02/05 01:33:44 pwagner Exp $"
d5030 3
@


2.179
log
@Automatically sheds rank when nFreqs=1; passes options to dump routines
@
text
@d15 4
a18 4
  use Allocate_Deallocate, only: Allocate_test, Deallocate_test
  use BitStuff, only: dumpBitNames
  use DUMP_0, only: DIFF, DUMP
  use Hdf, only: DFACC_RDONLY, DFACC_READ, DFACC_CREATE, DFACC_RDWR, &
d20 3
a22 3
  use Intrinsic ! "units" type literals, beginning with L_
  use MLSCommon, only: defaultUndefinedValue, MLSFile_T, L2Metadata_T
  use MLSFiles, only: FILENOTFOUND, &
d24 5
a28 5
    & DUMP, INITIALIZEMLSFILE, MLS_closeFile, MLS_EXISTS, mls_openFile, &
    & MLS_HDF_VERSION, MLS_INQSWATH, open_MLSFile, close_MLSFile
  use MLSKinds, only: R4, R8
  use MLSFillValues, only: ExtractArray, GatherArray, &
    & IsFillValue, ReplaceFillValues
d30 12
a41 12
  use MLSMessageModule, only: MLSMSG_Allocate, MLSMSG_DeAllocate, MLSMSG_Error, &
    & MLSMSG_Warning, MLSMessage, MLSMessageCalls
  use MLSNumerics, only: FindInRange
  use MLSSets, only: FindFirst, FindIntersection, FindLast, FindUnique, &
    & Intersection
  use MLSStrings, only: Capitalize, lowercase
  use MLSStringLists, only: ExtractSubString, &
    & GetHashElement, GetStringElement, GetUniqueList, &
    & list2array, NumStringElements, RemoveListFromList, ReplaceSubString, &
    & StringElementNum, SwitchDetail
  use Output_M, only: blanks, Output, outputNamedValue, &
    & resumeOutput, suspendOutput
d469 1
a469 1
  use MLSHDFEOS, only: mls_swattach, mls_swdetach
d879 1
a879 1
    use HGridsDatabase, only: HGrid_T
d1016 3
a1018 3
    use HGridsDatabase, only: HGrid_T
    use PCFHdr, only: GlobalAttributes_T, GlobalAttributes, &
      & dumpGlobalAttributes, he5_readglobalattr, he5_writeglobalattr
d1203 1
a1203 1
    use HGridsDatabase, only: HGrid_T
d1531 1
a1531 1
      call DiffL2GPData_atlast ( tL2gp1, tL2gp2, &
d1536 1
a1536 1
      call DiffL2GPData_atlast ( L2gp1, L2gp2, &
d1541 2
a1542 2
  ! ---------------------- DiffL2GPData_atlast  ---------------------------
  subroutine DiffL2GPData_atlast ( L2gp1, L2gp2, &
d1809 5
a1813 2
          call diff ( l2gp1%longitude, 'l2gp%longitude', &
            &         l2gp2%longitude, ' ', &
d1819 5
a1823 2
          call diff ( l2gp1%solarTime, 'l2gp%solarTime', &
            &         l2gp2%solarTime, ' ', &
d1888 11
a1898 1
  end subroutine DiffL2GPData_atlast
d2576 3
a2578 1
        showMe = ( index(LowerCase(fields), LowerCase(trim(field))) > 0 )
d2587 3
a2589 3
  use he5_swapi, only: he5_swrdattr, he5_swrdlattr
  use MLSHDFEOS, only: mls_swattach, mls_swdetach
  use PCFHdr, only:  GlobalAttributes_T, he5_readglobalattr
d3081 3
d3505 4
a3508 4
  use HDFEOS5, only: HE5_SWINQDIMS, HE5_SWINQDFLDS, HE5_swfldinfo
  use MLSHDFEOS, only: mls_swattach, mls_swdetach, mls_swdiminfo, mls_swrdfld
  use MLSStringLists, only: isInList
  use HDF5, only: size_t
d3919 2
a3920 2
  use MLSHDFEOS, only: mls_swdetach, &
    & mls_swcreate, mls_dfldsetup, mls_gfldsetup, mls_swdefdim
d4188 1
a4188 1
  use MLSHDFEOS, only: mls_swattach, mls_swdetach, mls_swwrfld
d4293 1
a4293 1
  use MLSHDFEOS, only: mls_swattach, mls_swdetach, mls_swwrfld
d4404 4
a4407 4
    & MLS_charType
  use he5_swapi, only: he5_swwrattr, he5_swwrlattr
  use MLSHDFEOS, only: mls_swattach, mls_swdetach, mls_swwrattr, mls_swwrlattr
  use PCFHdr, only:  he5_writeglobalattr
d4772 1
a4772 1
    use HGridsDatabase, only: HGrid_T
d4896 1
a4896 1
  use MLSHDFEOS, only: mls_swattach, mls_swdetach
d4997 1
a4997 1
       "$Id: L2GPData.f90,v 2.178 2010/11/17 01:19:13 pwagner Exp $"
d5010 3
@


2.178
log
@Fixed bug when diffing files with different swathnames; units_name for iwc now 'g/m^3'
@
text
@d1511 2
a1512 1
    if ( myMatchTimes ) then
d2249 2
a2250 1
  subroutine DUMP_L2GP_DATABASE ( L2gp, Name, ColumnsOnly, Details, Fields )
d2258 1
d2273 1
a2273 1
      call dump(l2gp(i), ColumnsOnly, Details, Fields)
d2281 2
a2282 1
  subroutine DUMP_L2GP_CHUNKS ( fullL2gp, Chunks, ColumnsOnly, Details, Fields, Width )
d2295 1
d2314 1
a2314 1
      call Dump ( L2gp, ColumnsOnly, Details, Fields, width )
d2324 1
a2324 1
    & Details, fields, Width )
d2344 1
d2369 2
a2370 1
      call DUMP_L2GP_Chunks ( L2gp, Chunks, ColumnsOnly, Details, Fields, width )
d2372 1
a2372 1
      call DUMP ( L2gp, ColumnsOnly, Details, Fields, width )
d2380 1
a2380 1
  subroutine Dump_L2GP ( L2gp, ColumnsOnly, Details, Fields, Width )
d2395 1
d2454 1
a2454 1
    !  if ( myDetails < -1 ) return
d2472 2
a2473 1
      & call dump ( l2gp%pressures, trim(l2gp%verticalCoordinate) // 's:', FillValue=FillValueGP, width=width )
d2476 2
a2477 1
      & call dump ( l2gp%latitude, 'Latitude:', FillValue=FillValueGP, width=width )
d2480 2
a2481 1
      & call dump ( l2gp%longitude, 'Longitude:', FillValue=FillValueGP, width=width )
d2484 2
a2485 1
      & call dump ( l2gp%solarTime, 'SolarTime:', FillValue=FillValueGP, width=width )
d2488 2
a2489 1
      & call dump ( l2gp%solarZenith, 'SolarZenith:', FillValue=FillValueGP, width=width )
d2492 2
a2493 1
      & call dump ( l2gp%losAngle, 'LOSAngle:', FillValue=FillValueGP, width=width )
d2496 2
a2497 1
      & call dump ( l2gp%geodAngle, 'geodAngle:', FillValue=FillValueGP, width=width )
d2500 2
a2501 1
      & call dump ( l2gp%time, 'Time:', FillValue=FillValue, width=width )
d2504 2
a2505 1
      & call dump ( l2gp%chunkNumber, 'ChunkNumber:', width=width )
d2507 4
a2510 3
      if ( showMe(myDetails > -1, myFields, 'pressure') .and. &
        & associated(l2gp%frequency) ) &
        & call dump ( l2gp%frequency, 'Frequencies:', FillValue=FillValueGP, width=width )
d2512 9
a2520 4
      ! if ( myDetails < 1 ) return
    if ( showMe(myDetails > 0, myFields, 'l2gpvalue') ) &
      & call dump ( real(l2gp%l2gpValue, r8), 'L2GPValue:', &
        & FillValue=FillValue )
d2522 9
a2530 3
    if ( showMe(myDetails > 0, myFields, 'l2gpprecision') ) &
      & call dump ( real(l2gp%l2gpPrecision, r8), 'L2GPPrecision:', &
        & FillValue=FillValue )
d2533 1
a2533 1
      call dump ( l2gp%status, 'Status:' )
d2542 2
a2543 1
      & call dump ( l2gp%quality, 'Quality:', FillValue=FillValueGP )
d2546 2
a2547 1
      & call dump ( l2gp%convergence, 'Convergence:', FillValue=FillValueGP )
d4976 1
a4976 1
       "$Id: L2GPData.f90,v 2.177 2010/11/10 02:03:06 pwagner Exp $"
d4989 3
@


2.177
log
@Copies correct TAI93At0zOfGranule global attribute
@
text
@a2034 1
    character (len=MAXSWATHNAMESBUFSIZE) :: rename
d2039 1
d2069 2
d2075 1
a2077 2
    noSwaths2 = mls_InqSwath ( file2, rename, listSize, &
         & hdfVersion=the_hdfVersion2)
d2080 1
a2080 1
        rename = swaths2
d2096 1
a2096 1
          & str2=trim(rename))
d2107 1
a2107 1
          & str2=trim(rename))
d2112 1
a2112 1
        call GetUniqueList(trim(rename), swathUnique, noUnique, countEmpty, &
d2139 6
a2144 2
      swath2 = swath
      status = stringElementNum(rename, trim(swath), countEmpty)
d2151 1
a2151 1
          call GetStringElement (trim(rename), swath2, i, countEmpty )
d4544 2
d4945 1
a4945 1
       "$Id: L2GPData.f90,v 2.176 2010/06/22 16:53:15 pwagner Exp $"
d4958 3
@


2.176
log
@Consistent with new behavior of switchDetail: must include 'f' if override default options
@
text
@d21 1
a21 1
  use MLSCommon, only: R4, R8, defaultUndefinedValue, MLSFile_T, L2Metadata_T
d26 1
d1018 1
a1018 1
      & he5_readglobalattr, he5_writeglobalattr
d1042 1
d1140 4
a1143 1
        if ( DEEBUG ) call output ( '(Global Attributes read) ', advance='yes')
d1145 1
a1145 1
        ! so must store original version so can copy new data into it 
d1148 6
a1153 1
        if ( DEEBUG ) call outputNamedValue('Misc Notes (written) ', trim(GlobalAttributes%MiscNotes) )
d1155 1
a1155 1
        ! Before leaving must copy original data back
d4938 1
a4938 1
       "$Id: L2GPData.f90,v 2.175 2010/06/19 00:11:05 pwagner Exp $"
d4951 3
@


2.175
log
@Diffs were checking wrong default field names; fixed
@
text
@d1605 113
a1717 164
      if ( trim(l2gp1%name) /= trim(l2gp2%name) ) then
        call output('(1) name: ' // trim(l2gp1%name), advance='yes')
        call output('(2) name: ' // trim(l2gp2%name), advance='yes')
        myNumDiffs = myNumDiffs + 1
      endif
      if ( myDetails < -1 ) then
        call doneHere
        return
      endif
      if ( L2gp1%MissingValue /= L2gp2%MissingValue ) then
        call output(' (1) MissingValue = ', advance='no')
        call output(L2gp1%nTimes, advance='yes')
        call output(' (2) MissingValue = ', advance='no')
        call output(L2gp2%nTimes, advance='yes')
        myNumDiffs = myNumDiffs + 1
      endif
      if ( L2gp1%nTimes /= L2gp2%nTimes ) then
        call output(' (1) nTimes = ', advance='no')
        call output(L2gp1%nTimes, advance='yes')
        call output(' (2) nTimes = ', advance='no')
        call output(L2gp2%nTimes, advance='yes')
        ShapesDontMatch = .true.
        myNumDiffs = myNumDiffs + 1
      endif
      if ( L2gp1%nLevels /= L2gp2%nLevels ) then
        call output(' (1) nLevels = ', advance='no')
        call output(L2gp1%nLevels, advance='yes')
        call output(' (2) nLevels = ', advance='no')
        call output(L2gp2%nLevels, advance='yes')
        ShapesDontMatch = .true.
        myNumDiffs = myNumDiffs + 1
      endif
      if ( L2gp1%nFreqs /= L2gp2%nFreqs ) then
        call output(' (1) nFreqs = ', advance='no')
        call output(L2gp1%nFreqs, advance='yes')
        call output(' (2) nFreqs = ', advance='no')
        call output(L2gp2%nFreqs, advance='yes')
        ShapesDontMatch = .true.
        myNumDiffs = myNumDiffs + 1
      endif
      if ( myDetails < 0 )  then
        if ( myVerbose ) &
          & call output ( '(Data shapes and swath names match)', advance='yes' )
        call doneHere
        return
      endif
      if ( ShapesDontMatch ) then
        call output('Skipping further details because shapes dont match',&
          & advance='yes')
        call doneHere
        return
      endif
      
      badChunks = badChunks .or. &
        & ( &
        & any( mod ( l2gp1%status, 2 ) == 1 ) &
        & .or. &
        & any( mod ( l2gp2%status, 2 ) == 1 ) &
        & .or. &
        & any( IsFillValue ( l2gp1%l2gpValue, l2gp1%MissingValue ) ) &
        & .or. &
        & any( IsFillValue ( l2gp2%l2gpValue, l2gp2%MissingValue ) ) &
        & )
      if ( present ( options ) ) then
        badChunks = (index(options, 'i' ) > 0) .and. badChunks
      else
        badChunks = .false.
      endif
      ! OK, we'll try what you suggest
      call SetupNewL2GPRecord ( l2gp2Temp, proto=l2gp2 )
      if ( badChunks ) then
        do instance=1, L2gp1%nTimes
          if ( l2gp1%geodAngle(instance) /= l2gp2%geodAngle(instance) &
            & .or. &
            & l2gp1%solarZenith(instance) /= l2gp2%solarZenith(instance) &
            & .or. &
            & l2gp1%time(instance) /= l2gp2%time(instance) &
            & .or. &
            & mod(l2gp1%status(instance), 2) == 1 &
            & .or. &
            & mod(l2gp2%status(instance), 2) == 1 &
            & .or. &
            & any( IsFillValue ( l2gp1%l2gpValue(:,:,instance), l2gp1%MissingValue ) ) &
            & .or. &
            & any( IsFillValue ( l2gp2%l2gpValue(:,:,instance), l2gp2%MissingValue ) ) &
            & ) then
            l2gp2Temp%l2gpValue(:,:,instance) = l2gp1%l2gpValue(:,:,instance)
            l2gp2Temp%l2gpPrecision(:,:,instance) = l2gp1%l2gpPrecision(:,:,instance)
            l2gp2Temp%status(instance) = l2gp1%status(instance)
            l2gp2Temp%quality(instance) = l2gp1%quality(instance)
            l2gp2Temp%convergence(instance) = l2gp1%convergence(instance)
            ! Also geolocations will be reset to avoid displaying bogus diffs
            l2gp2Temp%latitude(instance) = l2gp1%latitude(instance)
            l2gp2Temp%longitude(instance) = l2gp1%longitude(instance)
            l2gp2Temp%solarTime(instance) = l2gp1%solarTime(instance)
            l2gp2Temp%chunkNumber(instance) = l2gp1%chunkNumber(instance)
            l2gp2Temp%geodAngle(instance) = l2gp1%geodAngle(instance)
            l2gp2Temp%solarZenith(instance) = l2gp1%solarZenith(instance)
            l2gp2Temp%time(instance) = l2gp1%time(instance)
            l2gp2Temp%losAngle(instance) = l2gp1%losAngle(instance)
            badInstances = badInstances + 1
          endif
        enddo
        call output('Number of bad instances of l2gp2 reset to l2gp1 ', advance='no')
        call output(badInstances, advance='yes')
      endif

      call diffGeoLocations( l2gp1, l2gp2Temp )
      if ( myDetails < 1 )  then
        call doneHere
        return
      endif

      if ( any(l2gp1%l2gpValue /= l2gp2Temp%l2gpValue) .and. &
        & SwitchDetail(lowercase(myFields), 'l2gpvalue', '-c') > -1 ) then
        call diff ( l2gp1%l2gpValue, 'l2gp%l2gpValue', &
          &         l2gp2Temp%l2gpValue, ' ', &
          & options=options, fillValue=l2gp1%MissingValue )
        myNumDiffs = myNumDiffs + count( l2gp1%l2gpValue /= l2gp2Temp%l2gpValue )
      elseif ( all(l2gp1%l2gpValue == l2gp2Temp%l2gpValue) .and. &
        & SwitchDetail(lowercase(myFields), 'l2gpvalue', '-c') > -1 .and. myVerbose ) then
        call output('(values fields equal)', advance='yes')
      endif
      if ( any(l2gp1%l2gpPrecision /= l2gp2Temp%l2gpPrecision) .and. &
        & SwitchDetail(lowercase(myFields), 'l2gpprecision', '-c') > -1 ) then
        call diff ( l2gp1%l2gpPrecision, 'l2gp%l2gpPrecision', &
          &         l2gp2Temp%l2gpPrecision, ' ', &
          & options=options, fillValue=l2gp1%MissingValue )
        myNumDiffs = myNumDiffs + count( l2gp1%l2gpPrecision /= l2gp2Temp%l2gpPrecision )
      elseif ( all(l2gp1%l2gpPrecision == l2gp2Temp%l2gpPrecision) .and. &
        & SwitchDetail(lowercase(myFields), 'l2gpprecision', '-c') > -1 .and. myVerbose ) then
        call output('(precision fields equal)', advance='yes')
      endif
      
      if ( any(l2gp1%status /= l2gp2Temp%status) .and. &
        & SwitchDetail(lowercase(myFields), 'status', '-c') > -1 ) then
        call diff ( l2gp1%status, 'l2gp%status', &
          &         l2gp2Temp%status, ' ', &
          & options=options )
        myNumDiffs = myNumDiffs + count( l2gp1%status /= l2gp2Temp%status )
      elseif ( all(l2gp1%status == l2gp2Temp%status) .and. &
        & SwitchDetail(lowercase(myFields), 'status', '-c') > -1 .and. myVerbose ) then
        call output('(status fields equal)', advance='yes')
      endif
      if ( any(l2gp1%quality /= l2gp2Temp%quality) .and. &
        & SwitchDetail(lowercase(myFields), 'quality', '-c') > -1 ) then
        call diff ( l2gp1%quality, 'l2gp%quality', &
          &         l2gp2Temp%quality, ' ', &
          & options=options )
        myNumDiffs = myNumDiffs + count( l2gp1%quality /= l2gp2Temp%quality )
      elseif ( all(l2gp1%quality == l2gp2Temp%quality) .and. &
        & SwitchDetail(lowercase(myFields), 'quality', '-c') > -1 .and. myVerbose ) then
        call output('(quality fields equal)', advance='yes')
      endif
      if ( any(l2gp1%convergence /= l2gp2Temp%convergence) .and. &
        & SwitchDetail(lowercase(myFields), 'convergence', '-c') > -1 ) then
        call diff ( l2gp1%convergence, 'l2gp%convergence', &
          &         l2gp2Temp%convergence, ' ', &
          & options=options )
        myNumDiffs = myNumDiffs + count( l2gp1%convergence /= l2gp2Temp%convergence )
      elseif ( all(l2gp1%convergence == l2gp2Temp%convergence) .and. &
        & SwitchDetail(lowercase(myFields), 'convergence', '-c') > -1 .and. myVerbose ) then
        call output('(convergence fields equal)', advance='yes')
      endif
d1720 1
d1722 55
a1776 1
contains
d1783 1
a1783 1
        & SwitchDetail(lowercase(myFields), 'pressure', '-c') > -1 ) then
d1790 1
a1790 1
        & SwitchDetail(lowercase(myFields), 'lat', '-c') > -1 ) then
d1797 1
a1797 1
        & SwitchDetail(lowercase(myFields), 'lon', '-c') > -1 ) then
d1804 1
a1804 1
        & SwitchDetail(lowercase(myFields), 'solartime', '-c') > -1 ) then
d1811 1
a1811 1
        & SwitchDetail(lowercase(myFields), 'solarzenith', '-c') > -1 ) then
d1819 1
a1819 1
        & SwitchDetail(lowercase(myFields), 'losangle', '-c') > -1 ) then
d1826 1
a1826 1
        & SwitchDetail(lowercase(myFields), 'geodangle', '-c') > -1 ) then
d1834 1
a1834 1
        & SwitchDetail(lowercase(myFields), 'time', '-c') > -1 ) then
d1842 1
a1842 1
        & SwitchDetail(lowercase(myFields), 'chunknumber', '-c') > -1 ) then
d1853 1
a1853 1
          & SwitchDetail(lowercase(myFields), 'freq', '-c') > -1 ) then
d4651 1
a4651 1
    if ( SwitchDetail(myFields, 'pressure', '-wc') > -1 ) then
d4654 1
a4654 1
    if ( SwitchDetail(myFields, 'latitude', '-wc') > -1 ) then
d4657 1
a4657 1
    if ( SwitchDetail(myFields, 'longitude', '-wc') > -1 ) then
d4660 1
a4660 1
    if ( SwitchDetail(myFields, 'solartime', '-wc') > -1 ) then
d4663 1
a4663 1
    if ( SwitchDetail(myFields, 'solarzenith', '-wc') > -1 ) then
d4666 1
a4666 1
    if ( SwitchDetail(myFields, 'LineOfSightAngle', '-wc') > -1 ) then
d4669 1
a4669 1
    if ( SwitchDetail(myFields, 'OrbitGeodeticAngle', '-wc') > -1 ) then
d4672 1
a4672 1
    if ( SwitchDetail(myFields, 'time', '-wc') > -1 ) then
d4676 1
a4676 1
    if ( SwitchDetail(myFields, 'chunknumber', '-wc') > -1 ) then
d4680 1
a4680 1
    if ( SwitchDetail(myFields, 'frequency', '-wc') > -1 ) then
d4683 1
a4683 1
    if ( SwitchDetail(myFields, 'l2gpvalue', '-wc') > -1 ) then
d4686 1
a4686 1
    if ( SwitchDetail(myFields, 'l2gpprecision', '-wc') > -1 ) then
d4689 1
a4689 1
    if ( SwitchDetail(myFields, 'status', '-wc') > -1 ) then
d4692 1
a4692 1
    if ( SwitchDetail(myFields, 'quality', '-wc') > -1 ) then
d4695 1
a4695 1
    if ( SwitchDetail(myFields, 'convergence', '-wc') > -1 ) then
d4790 1
a4790 1
    if ( SwitchDetail(myFields, 'latitude', '-wc') > -1 ) then
d4796 1
a4796 1
    if ( SwitchDetail(myFields, 'longitude', '-wc') > -1 ) then
d4800 1
a4800 1
    if ( SwitchDetail(myFields, 'solartime', '-wc') > -1 ) then
d4804 1
a4804 1
    if ( SwitchDetail(myFields, 'solarzenith', '-wc') > -1 ) then
d4808 1
a4808 1
    if ( SwitchDetail(myFields, 'LineOfSightAngle', '-wc') > -1 ) then
d4812 1
a4812 1
    if ( SwitchDetail(myFields, 'OrbitGeodeticAngle', '-wc') > -1 ) then
d4816 1
a4816 1
    if ( SwitchDetail(myFields, 'time', '-wc') > -1 ) then
d4928 1
a4928 1
       "$Id: L2GPData.f90,v 2.174 2010/02/12 00:25:46 pwagner Exp $"
d4941 3
@


2.174
log
@Fixed bug when number of dims is 4 (but what if 5 or more?)
@
text
@d1519 1
d1719 1
a1719 1
        & SwitchDetail(lowercase(myFields), 'value', '-c') > -1 ) then
d1725 1
a1725 1
        & SwitchDetail(lowercase(myFields), 'value', '-c') > -1 .and. myVerbose ) then
d1729 1
a1729 1
        & SwitchDetail(lowercase(myFields), 'precision', '-c') > -1 ) then
d1735 1
a1735 1
        & SwitchDetail(lowercase(myFields), 'precision', '-c') > -1 .and. myVerbose ) then
d1769 2
d1865 1
d4924 1
a4924 1
       "$Id: L2GPData.f90,v 2.173 2010/02/04 23:08:00 vsnyder Exp $"
d4937 3
@


2.173
log
@Remove USE or declaration for unused names
@
text
@d3475 3
a3477 2
    integer, dimension(3) :: start, stride, edge, dims
    integer(kind=size_t), dimension(3) :: hdims
d3491 1
a3491 1
    deeBugHere = DEEBUG     ! .or. .true.
d3513 2
d3538 3
d4920 1
a4920 1
       "$Id: L2GPData.f90,v 2.172 2009/11/04 23:15:53 pwagner Exp $"
d4933 3
@


2.172
log
@Restored MAXCHUNKTIMES to 120; at 1 DGG file became enormous (who could have guessed)
@
text
@a361 1
    integer :: record_length
a1053 1
    integer :: record_length
a2016 1
    integer :: record_length
a2318 1
    logical :: mySilent
a3336 1
    integer :: record_length
d4914 1
a4914 1
       "$Id: L2GPData.f90,v 2.171 2009/10/22 00:52:39 pwagner Exp $"
d4927 3
@


2.171
log
@Second try at fixing hdfeos5 bug; still no luck
@
text
@d163 1
a163 1
  integer, private, parameter :: MAXCHUNKTIMES = 1 ! 120
d4919 1
a4919 1
       "$Id: L2GPData.f90,v 2.170 2009/10/05 23:39:24 pwagner Exp $"
d4932 3
@


2.170
log
@Moved use hdf5 statements from module scope to speedup Lahey; this is the last time we do that
@
text
@d163 2
a165 2
  integer, private, parameter :: MAXCHUNKTIMES = 120
  integer, public, parameter :: MAXNUMSWATHPERFILE = 300
d169 2
a170 1
  logical, public            :: AVOIDUNLIMITEDDIMS = .true.
d504 1
a504 1
    logical, parameter :: DEEBUG = .false.
d545 1
a545 1
    if ( swath_exists ) then
d562 2
a3921 1
      ! status = HE5_SWdefdim(swid, UNLIM, HE5S_UNLIMITED_F)
d3935 1
a3935 1
    if ( DEEBUG ) then
d3945 1
d3949 1
d4006 2
d4009 1
a4009 1
      & DFNT_FLOAT32, HDFE_NOMERGE, 0, chunk_dims, &
d4015 2
d4018 1
a4018 1
      & DFNT_FLOAT32, HDFE_NOMERGE, 0, chunk_dims, &
d4229 1
a4229 1
    logical, parameter :: DEEBUG = .false.
d4919 1
a4919 1
       "$Id: L2GPData.f90,v 2.169 2009/09/29 23:35:43 pwagner Exp $"
d4932 3
@


2.169
log
@Changes needed by 64-bit build
@
text
@a41 1
  use HDF5, only: size_t
d3435 1
d4911 1
a4911 1
       "$Id: L2GPData.f90,v 2.168 2009/08/26 16:45:55 pwagner Exp $"
d4924 3
@


2.168
log
@Public global flag WRITEMASTERSFILEATTRIBUTES determines whether to overwrite slave file attributes with masters
@
text
@d28 1
d42 1
d504 1
d3473 1
d3477 2
a3478 1
    integer :: start(3), stride(3), edge(3), dims(3)
d3528 2
a3529 1
      nDims = HE5_SWinqdims(swid, list, dims)
d3549 1
a3549 1
      status = HE5_swfldinfo(swid, trim(DF_Name), rank, flddims, &
d3551 1
d4221 1
a4221 1

d4255 1
a4255 1
      call output( 'Writing data now', advance='yes' )
d4263 2
d4266 1
a4266 1
            & reshape(real(l2gp%l2gpValue), (/size(l2gp%l2gpValue)/)), &
d4269 1
a4269 1
            & reshape(real(l2gp%l2gpPrecision), (/size(l2gp%l2gpPrecision)/)), &
d4277 1
a4277 1
            edge(2:3), real(l2gp%l2gpValue(1,:,:) ), hdfVersion=hdfVersion)
d4279 1
a4279 1
            edge(2:3), real(l2gp%l2gpPrecision(1,:,:) ), hdfVersion=hdfVersion)
d4409 1
a4409 1
      & rgp_type, size(l2gp%pressures), &
d4415 1
a4415 1
      & status = he5_swwrattr(swid, 'MissingValue', rgp_type, 1, &
d4448 1
a4448 1
            & HE5T_NATIVE_DOUBLE, 1, (/ real(l2gp%MissingValue, r8) /) )
d4452 1
a4452 1
            & HE5T_NATIVE_INT, 1, (/ int(l2gp%MissingValue) /) )
d4456 1
a4456 1
            & rgp_type, 1, (/ real(l2gp%MissingValue, rgp) /) )
d4535 1
a4535 1
      & rgp_type, 1, (/ real(l2gp%MissingValue, rgp) /) )
d4545 1
a4545 1
      & rgp_type, 1, (/ real(l2gp%MissingValue, rgp) /) )
d4556 1
a4556 1
      & HE5T_NATIVE_INT, 1, (/ l2gp%MissingStatus /) )
d4567 1
a4567 1
      & rgp_type, 1, (/ real(l2gp%MissingValue, rgp) /) )
d4577 1
a4577 1
      & rgp_type, 1, (/ real(l2gp%MissingValue, rgp) /) )
d4911 1
a4911 1
       "$Id: L2GPData.f90,v 2.167 2009/06/23 18:25:42 pwagner Exp $"
d4924 3
@


2.167
log
@Prevent Intel from optimizing ident string away
@
text
@d55 1
a55 1
       "$RCSfile: $"
d169 1
a393 6
    ! L2FileHandle = mls_io_gen_openF(l_swath, .TRUE., status, &
    !   & record_length, file_access, FileName=FileName, &
    !   & hdfVersion=the_hdfVersion, debugOption=.false. )
    !if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to open L2gp file: " // trim(FileName) // ' for appending')
a398 5
    ! status = mls_io_gen_closeF(l_swath, L2FileHandle, FileName=FileName, &
    !  & hdfVersion=the_hdfVersion)
    ! if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to close L2gp file: " // trim(FileName) // ' after appending')
a1093 6
    ! File1Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
    !   & record_length, DFACC_READ, FileName=File1, &
    !   & hdfVersion=the_hdfVersion1, debugOption=.false. )
    !if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to open L2gp file: " // trim(File1) // ' for cp-ing')
a1125 6
    ! File2Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
    !   & record_length, file_access, FileName=File2, &
    !   & hdfVersion=the_hdfVersion2, debugOption=.false. )
    !if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to open L2gp file: " // trim(File2) // ' for cping')
d1127 1
a1127 1
      print *, 'About to cp from file1 to file2: ', File1Handle, File2Handle
d1135 1
d1140 1
d1144 2
d2608 1
a3350 6
    ! L2FileHandle = mls_io_gen_openF(l_swath, .TRUE., status, &
    !   & record_length, DFACC_READ, FileName=FileName, &
    !   & hdfVersion=hdfVersion, debugOption=.false. )
    !if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to open L2gp file: " // trim(FileName) // ' for reading')
a3354 5
    ! status = mls_io_gen_closeF(l_swath, L2FileHandle, FileName=FileName, &
    !  & hdfVersion=hdfVersion)
    !if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to close L2gp file: " // trim(FileName) // ' after reading')
d4393 2
a4394 1
    call he5_writeglobalattr(L2GPFile%fileID%f_id)
d4902 1
a4902 1
       "$Id: read_apriori.f90 is it here $"
d4915 3
@


2.166
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d55 1
a55 1
       "$RCSfile: L2GPData.f90,v $"
d4926 1
a4927 1
!---------------------------- RCS Ident Info -------------------------------
d4929 2
a4930 3
       "$Id: L2GPData.f90,v 2.165 2009/06/02 17:49:17 cvuu Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d4932 1
a4932 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d4934 1
d4942 3
@


2.165
log
@Write NRT Lat and Lon to L2Metadata
@
text
@d146 9
a154 1
  ! First some local parameters
d248 3
a250 3
    & 'do not use      ', 'beware           ', '(unused)        ', &
    & 'inform          ', 'high clouds      ', 'low clouds      ', &
    & 'no meteorology  ', 'abandoned chunk  ', 'too few radiance', &
d252 1
d1278 1
a1278 2
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, &
    & verbose, numDiffs )
d1289 1
a1289 5
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: RMS     ! if TRUE, just print mean, rms
    logical, intent(in), optional :: WHOLEARRAY   ! if TRUE, print anyway
    logical, intent(in), optional :: IGNOREBADCHUNKS   ! if TRUE, ignore
                                                     ! instances where geod bad
a1290 2
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
d1302 1
a1302 1
    if ( present(silent) ) mySilent = silent
d1334 2
a1335 2
        & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
        & silent=silent, verbose=verbose, numDiffs=numDiffs )
d1344 1
a1344 2
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, &
    & verbose, numDiffs )
d1356 1
a1356 5
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: RMS     ! if TRUE, just print mean, rms
    logical, intent(in), optional :: WHOLEARRAY   ! if TRUE, print anyway
    logical, intent(in), optional :: IGNOREBADCHUNKS   ! if TRUE, ignore
                                                     ! instances where geod bad
a1357 2
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
d1369 1
a1369 1
    if ( present(silent) ) mySilent = silent
d1399 1
a1399 2
          & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
          & silent=silent, verbose=verbose, numDiffs=numDiffs )
d1402 1
a1402 2
          & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
          & silent=silent, verbose=verbose, numDiffs=numDiffs )
d1414 1
a1414 2
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, &
    & verbose, numDiffs )
d1432 1
a1432 5
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: RMS     ! if TRUE, just print mean, rms
    logical, intent(in), optional :: WHOLEARRAY   ! if TRUE, print anyway
    logical, intent(in), optional :: IGNOREBADCHUNKS   ! if TRUE, ignore
                                                     ! instances where geod bad
a1433 2
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
d1442 1
a1442 1
    if ( present(silent) ) mySilent = silent
d1470 1
a1470 2
        & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
        & silent=silent, verbose=verbose, numDiffs=numDiffs )
d1473 1
a1473 2
        & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
        & silent=silent, verbose=verbose, numDiffs=numDiffs )
d1481 1
a1481 2
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, matchTimes, &
    & silent, verbose, numDiffs )
d1500 1
a1500 5
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: RMS     ! if TRUE, just print mean, rms
    logical, intent(in), optional :: WHOLEARRAY   ! if TRUE, print anyway
    logical, intent(in), optional :: IGNOREBADCHUNKS   ! if TRUE, ignore
                                                     ! instances where geod bad
a1502 2
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
d1514 1
a1514 1
    if ( present(silent) ) mySilent = silent
d1535 1
a1535 2
      & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
      & silent, verbose, numDiffs )
d1540 1
a1540 2
      & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
      & silent, verbose, numDiffs )
d1546 1
a1546 2
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, &
    & verbose, numDiffs )
d1565 1
a1565 5
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: RMS     ! if TRUE, just print mean, rms
    logical, intent(in), optional :: WHOLEARRAY   ! if TRUE, print anyway
    logical, intent(in), optional :: IGNOREBADCHUNKS   ! if TRUE, ignore
                                                     ! instances where geod bad
a1566 2
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
d1597 1
a1597 1
    if ( present(silent) ) mySilent = silent
d1600 1
a1600 1
    if ( present(verbose) ) myVerbose = verbose
d1682 2
a1683 2
      if ( present ( ignoreBadChunks ) ) then
        badChunks = ignoreBadChunks .and. badChunks
d1736 1
a1736 1
          & wholearray=wholearray, stats=stats, rms=rms, fillValue=l2gp1%MissingValue )
d1746 1
a1746 1
          & wholearray=wholearray, stats=stats, rms=rms, fillValue=l2gp1%MissingValue )
d1757 1
a1757 1
          & wholearray=wholearray, stats=stats, rms=rms )
d1767 1
a1767 1
          & wholearray=wholearray, stats=stats, rms=rms )
d1777 1
a1777 1
          & wholearray=wholearray, stats=stats, rms=rms )
d1794 1
a1794 1
            & wholearray=wholearray, stats=stats, rms=rms )
d1801 1
a1801 1
            & wholearray=wholearray, stats=stats, rms=rms )
d1808 1
a1808 1
            & wholearray=wholearray, stats=stats, rms=rms )
d1815 1
a1815 1
            & wholearray=wholearray, stats=stats, rms=rms )
d1822 1
a1822 1
            & wholearray=wholearray, stats=stats, rms=rms )
d1830 1
a1830 1
            & wholearray=wholearray, stats=stats, rms=rms )
d1837 1
a1837 1
            & wholearray=wholearray, stats=stats, rms=rms )
d1845 1
a1845 1
            & wholearray=wholearray, stats=stats, rms=rms )
d1853 1
a1853 1
          & wholearray=wholearray, stats=stats, rms=rms )
d1864 1
a1864 1
            & wholearray=wholearray, stats=stats, rms=rms )
d1883 1
a1883 1
    & Details, wholeArray, stats, rms, ignoreBadChunks, &
d1885 1
a1885 1
    & matchTimes, silent, verbose, numDiffs )
d1902 1
a1902 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: RMS   ! if TRUE, just print mean, rms
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: IGNOREBADCHUNKS
a1910 2
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
d1937 1
a1937 2
      & Details=Details, wholeArray=wholeArray, &
      & stats=stats, rms=rms, ignoreBadChunks=ignoreBadChunks, &
d1940 1
a1940 1
      & matchTimes=matchTimes, silent=silent, verbose=verbose, &
d1945 1
a1945 2
      & chunks=chunks, Details=Details, wholeArray=wholeArray, &
      & stats=stats, rms=rms, ignoreBadChunks=ignoreBadChunks, &
d1948 1
a1948 1
      & matchTimes=matchTimes, silent=silent, verbose=verbose, &
d1952 1
a1952 2
      & chunks=chunks, Details=Details, wholeArray=wholeArray, &
      & stats=stats, rms=rms, ignoreBadChunks=ignoreBadChunks, &
d1955 1
a1955 1
      & matchTimes=matchTimes, silent=silent, verbose=verbose, &
d1959 1
a1959 2
      & pressures=pressures, Details=Details, wholeArray=wholeArray, &
      & stats=stats, rms=rms, ignoreBadChunks=ignoreBadChunks, &
d1962 1
a1962 1
      & matchTimes=matchTimes, silent=silent, verbose=verbose, &
d1966 1
a1966 2
      & Details=Details, wholeArray=wholeArray, &
      & stats=stats, rms=rms, ignoreBadChunks=ignoreBadChunks, &
d1969 1
a1969 1
      & matchTimes=matchTimes, silent=silent, verbose=verbose, &
d1986 1
a1986 1
    & Details, wholeArray, stats, rms, ignoreBadChunks, &
d1988 1
a1988 1
    & silent, verbose, numDiffs )
d2005 1
a2005 4
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: RMS   ! if TRUE, just print mean, rms
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: IGNOREBADCHUNKS
a2013 2
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
d2054 1
a2054 1
    if ( present(silent) ) mySilent = silent
a2121 6
    ! File1Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
    !   & record_length, DFACC_READ, FileName=File1, &
    !   & hdfVersion=the_hdfVersion1, debugOption=.false. )
    !if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to open L2gp file: " // trim(File1) // ' for diff')
a2125 6
    ! File2Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
    !   & record_length, DFACC_READ, FileName=File2, &
    !   & hdfVersion=the_hdfVersion2, debugOption=.false. )
    !if ( status /= 0 ) &
    !  call MLSMessage ( MLSMSG_Error, ModuleName, &
    !   & "Unable to open L2gp file: " // trim(File2) // ' for diff')
d2163 1
a2163 3
        & details=details, wholeArray=wholeArray, rms=rms, stats=stats, &
        & ignoreBadChunks=ignoreBadChunks, fields=fields, &
        & silent=silent, verbose=verbose, &
d2167 1
a2167 3
        & details=details, wholeArray=wholeArray, rms=rms, stats=stats, &
        & ignoreBadChunks=ignoreBadChunks, fields=fields, &
        & silent=silent, verbose=verbose, &
d2171 1
a2171 3
        & details=details, wholeArray=wholeArray, rms=rms, stats=stats, &
        & ignoreBadChunks=ignoreBadChunks, fields=fields, &
        & silent=silent, verbose=verbose, &
d2175 1
a2175 3
        & details=details, wholeArray=wholeArray, rms=rms, stats=stats, &
        & ignoreBadChunks=ignoreBadChunks, fields=fields, &
        & silent=silent, verbose=verbose, &
d2179 1
a2179 3
        & details=details, wholeArray=wholeArray, rms=rms, stats=stats, &
        & ignoreBadChunks=ignoreBadChunks, fields=fields, &
        & matchTimes=matchTimes, silent=silent, verbose=verbose, &
d4929 1
a4929 1
       "$Id: L2GPData.f90,v 2.164 2009/05/14 22:01:21 pwagner Exp $"
d4942 3
@


2.164
log
@dumps now take width optional arg
@
text
@d21 1
a21 1
  use MLSCommon, only: R4, R8, defaultUndefinedValue, MLSFile_T
d866 1
a866 1
  subroutine cpL2GPData_fileID(file1, file2, swathList, &
d878 1
d987 6
d1000 1
a1000 1
  subroutine cpL2GPData_fileName(file1, file2, &
d1017 1
d1162 1
a1162 1
    call cpL2GPData_fileID(File1Handle, File2Handle, &
d1188 1
a1188 1
  subroutine cpL2GPData_MLSFile(L2GPfile1, L2GPfile2, &
d1202 1
d1249 1
a1249 1
    call cpL2GPData_fileName(L2GPFile1%Name, L2GPFile2%Name, &
d4998 1
a4998 1
       "$Id: L2GPData.f90,v 2.163 2009/05/08 00:42:58 pwagner Exp $"
d5011 3
@


2.163
log
@Shows StatusBitNames when dumping Status bits
@
text
@d2331 1
a2331 1
  subroutine DUMP_L2GP_CHUNKS ( fullL2gp, Chunks, ColumnsOnly, Details, Fields )
d2343 1
a2343 1

d2362 1
a2362 1
      call Dump ( L2gp, ColumnsOnly, Details, Fields )
d2372 1
a2372 1
    & Details, fields )
d2391 1
a2391 1

d2417 1
a2417 1
      call DUMP_L2GP_Chunks ( L2gp, Chunks, ColumnsOnly, Details, Fields )
d2419 1
a2419 1
      call DUMP ( L2gp, ColumnsOnly, Details, Fields )
d2427 1
a2427 1
  subroutine Dump_L2GP ( L2gp, ColumnsOnly, Details, Fields )
d2441 1
d2446 1
d2473 1
d2518 1
a2518 1
      & call dump ( l2gp%pressures, trim(l2gp%verticalCoordinate) // 's:' )
d2521 1
a2521 1
      & call dump ( l2gp%latitude, 'Latitude:' )
d2524 1
a2524 1
      & call dump ( l2gp%longitude, 'Longitude:' )
d2527 1
a2527 1
      & call dump ( l2gp%solarTime, 'SolarTime:' )
d2530 1
a2530 1
      & call dump ( l2gp%solarZenith, 'SolarZenith:' )
d2533 1
a2533 1
      & call dump ( l2gp%losAngle, 'LOSAngle:' )
d2536 1
a2536 1
      & call dump ( l2gp%geodAngle, 'geodAngle:' )
d2539 1
a2539 1
      & call dump ( l2gp%time, 'Time:' )
d2542 1
a2542 1
      & call dump ( l2gp%chunkNumber, 'ChunkNumber:' )
d2546 1
a2546 1
        & call dump ( l2gp%frequency, 'Frequencies:' )
d2567 1
a2567 1
      & call dump ( l2gp%quality, 'Quality:' )
d2570 1
a2570 1
      & call dump ( l2gp%convergence, 'Convergence:' )
d4989 1
a4989 1
       "$Id: L2GPData.f90,v 2.162 2008/12/02 23:11:41 pwagner Exp $"
d5002 3
@


2.162
log
@mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
@
text
@d16 1
d31 2
a32 1
  use MLSSets, only: FindFirst, FindIntersection, FindLast, Intersection
d239 5
d2373 1
a2373 1
    ! DUMP 2 l2gps according to prescribed ranges of pressure, longitude, etc.
d2443 3
a2448 2
    real(r8) :: FillValue
    integer :: ChunkFillValue
d2450 2
d2554 7
a2560 2
    if ( showMe(myDetails > 0, myFields, 'status') ) &
      & call dump ( l2gp%status, 'Status:' )
d2562 1
d4986 1
a4986 1
       "$Id: L2GPData.f90,v 2.161 2008/09/10 00:44:58 pwagner Exp $"
d4999 3
@


2.161
log
@diffing files can now subset according to geolocation boxes
@
text
@d20 1
a20 1
  use MLSCommon, only: I4, R4, R8, defaultUndefinedValue, MLSFile_T
d24 1
a24 1
    & MLS_HDF_VERSION, MLS_INQSWATH, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF
d289 1
a289 1
     integer(i4), pointer, dimension(:) :: status=>NULL()
d297 1
a297 1
     integer(i4)                       :: MissingStatus = 513 ! 512 + 1
d338 2
d341 2
a345 3
    logical :: myClean
    logical :: file_exists
    integer :: file_access
d373 10
a382 6
    L2FileHandle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, file_access, FileName=FileName, &
       & hdfVersion=the_hdfVersion, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(FileName) // ' for appending')
d387 6
a392 5
    status = mls_io_gen_closeF(l_swath, L2FileHandle, FileName=FileName, &
      & hdfVersion=the_hdfVersion)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(FileName) // ' after appending')
d1030 1
d1076 10
a1085 6
    File1Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, DFACC_READ, FileName=File1, &
       & hdfVersion=the_hdfVersion1, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(File1) // ' for cp-ing')
d1114 10
a1123 6
    File2Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, file_access, FileName=File2, &
       & hdfVersion=the_hdfVersion2, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(File2) // ' for cping')
d1153 6
a1158 5
    status = mls_io_gen_closeF(l_swath, File1Handle, FileName=File1, &
      & hdfVersion=the_hdfVersion1, debugOption=.false.)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(File1) // ' after cping')
d1160 9
a1168 10
    ! status = mls_io_gen_closeF('swclose', File2Handle, FileName=File2, &
    !  & hdfVersion=the_hdfVersion, debugOption=.true.)
    status = mls_io_gen_closeF(l_swath, File2Handle, &
      & hdfVersion=the_hdfVersion2, debugOption=.false.)
    if ( status /= 0 ) then
      print *, 'status returned from mls_io_gen_closeF: ', status
      print *, 'WRONGHDFVERSION: ', WRONGHDFVERSION
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(File2) // ' after cping')
    endif
d2055 1
d2057 1
a2059 1
    integer :: myNumDiffs
d2149 20
a2168 12
    File1Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, DFACC_READ, FileName=File1, &
       & hdfVersion=the_hdfVersion1, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(File1) // ' for diff')
    File2Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, DFACC_READ, FileName=File2, &
       & hdfVersion=the_hdfVersion2, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(File2) // ' for diff')
d2240 12
a2251 10
    status = mls_io_gen_closeF(l_swath, File1Handle, FileName=File1, &
      & hdfVersion=the_hdfVersion1, debugOption=.false.)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(File1) // ' after diff')
    status = mls_io_gen_closeF(l_swath, File2Handle, FileName=File2, &
      & hdfVersion=the_hdfVersion1, debugOption=.false.)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(File2) // ' after diff')
d3393 1
d3405 10
a3414 6
    L2FileHandle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, DFACC_READ, FileName=FileName, &
       & hdfVersion=hdfVersion, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(FileName) // ' for reading')
d3418 6
a3423 5
    status = mls_io_gen_closeF(l_swath, L2FileHandle, FileName=FileName, &
      & hdfVersion=hdfVersion)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(FileName) // ' after reading')
d4970 1
a4970 1
       "$Id: L2GPData.f90,v 2.160 2008/09/09 00:24:49 pwagner Exp $"
d4983 3
@


2.160
log
@Fix bug in dumpRange
@
text
@d1882 2
a1883 1
  subroutine DiffL2GPFiles_MLSFile ( L2GPFile1, L2GPFile2, pressures, chunks, &
d1893 3
d1939 11
a1949 1
    if ( present(chunks) .and. present(pressures) ) then
d1995 2
a1996 1
  subroutine DiffL2GPFiles_Name ( file1, file2, pressures, chunks, &
d2006 3
d2179 8
a2186 1
      if ( present(chunks) .and. present(pressures) ) then
d4938 1
a4938 1
       "$Id: L2GPData.f90,v 2.159 2008/09/03 20:43:09 pwagner Exp $"
d4951 3
@


2.159
log
@Added ContractL2GPRecord, diffRange, dumpRange
@
text
@d633 3
d656 9
a664 9
    pressures(1)  = 0.
    latitudes(1)  = 0.
    longitudes(1) = 0.
    times(1)      = 0.
    pressures(2)  = -100.
    latitudes(2)  = -100.
    longitudes(2) = -100.
    times(2)      = -100.
    elem = stringElementNum( lowerCase(geoBoxNames), 'pressures', countEmpty )
d669 1
a669 1
    elem = stringElementNum( lowerCase(geoBoxNames), 'latitudes', countEmpty )
d674 1
a674 1
    elem = stringElementNum( lowerCase(geoBoxNames), 'longitudes', countEmpty )
d679 1
a679 1
    elem = stringElementNum( lowerCase(geoBoxNames), 'times', countEmpty )
d708 1
d720 1
a720 1
    useFreqs = ol2gp%nFreqs
d724 8
a731 1
      if ( pressures(2) >= pressures(1) ) call FindInRange( ol2gp%pressures, pressures, whichLevels, useLevels )
d734 10
a743 3
      if ( latitudes(2) >= latitudes(1) ) then
        call FindInRange( ol2gp%latitude, latitudes, tempTimes, n )
        intrsctn => Intersection( whichTimes, tempTimes )
d746 6
d756 10
a765 3
      if ( longitudes(2) >= longitudes(1) ) then
        call FindInRange( ol2gp%longitude, longitudes, tempTimes, n )
        intrsctn => Intersection( whichTimes, tempTimes )
d768 7
a774 1
        call deallocate_test( intrsctn, 'intersection with longs', ModuleName )
d778 10
a787 3
      if ( times(2) >= times(1) ) then
        call FindInRange( ol2gp%time, times, tempTimes, n )
        intrsctn => Intersection( whichTimes, tempTimes )
d790 6
d811 38
a848 15
    call GatherArray ( l2gp%pressures    , ol2gp%pressures    , whichLevels )
    call GatherArray ( l2gp%frequency    , ol2gp%frequency    , whichFreqs )
    call GatherArray ( l2gp%latitude     , ol2gp%latitude     , whichTimes )
    call GatherArray ( l2gp%longitude    , ol2gp%longitude    , whichTimes )
    call GatherArray ( l2gp%solarTime    , ol2gp%solarTime    , whichTimes )
    call GatherArray ( l2gp%solarZenith  , ol2gp%solarZenith  , whichTimes )
    call GatherArray ( l2gp%losAngle     , ol2gp%losAngle     , whichTimes )
    call GatherArray ( l2gp%geodAngle    , ol2gp%geodAngle    , whichTimes )
    call GatherArray ( l2gp%time         , ol2gp%time         , whichTimes )
    call GatherArray ( l2gp%chunkNumber  , ol2gp%chunkNumber  , whichTimes )
    call GatherArray ( l2gp%l2gpValue    , ol2gp%l2gpValue    , whichFreqs, whichLevels, whichTimes )
    call GatherArray ( l2gp%l2gpPrecision, ol2gp%l2gpPrecision, whichFreqs, whichLevels, whichTimes )
    call GatherArray ( l2gp%status       , ol2gp%status       , whichTimes )
    call GatherArray ( l2gp%quality      , ol2gp%quality      , whichTimes )
    call GatherArray ( l2gp%convergence  , ol2gp%convergence  , whichTimes )
d4913 1
a4913 1
       "$Id: L2GPData.f90,v 2.158 2008/07/09 16:36:31 pwagner Exp $"
d4917 1
d4926 3
@


2.158
log
@Fixed "sleepy chunk" syndrome
@
text
@d25 2
a26 1
  use MLSFillValues, only: ExtractArray, IsFillValue, ReplaceFillValues
d29 2
a30 1
  use MLSSets, only: FindFirst, FindIntersection, FindLast
d45 3
a47 2
  public :: AddL2GPToDatabase, AppendL2GPData, cpL2GPData, &
    & DestroyL2GPContents, DestroyL2GPDatabase, diff, Dump, &
d57 4
d69 4
d84 4
d127 1
d628 150
d1312 79
d2236 57
d4840 1
a4840 1
       "$Id: L2GPData.f90,v 2.157 2008/04/22 18:57:33 pwagner Exp $"
d4852 3
@


2.157
log
@Fixed bug in ExtractL2GPData that left quality undefined
@
text
@a291 1
  logical, parameter ::READINGSTATUSBYDEFAULT = .true.  ! Change if bombing
a296 52
  subroutine AppendL2GPData_fileID(l2gp, l2FileHandle, &
    & swathName, offset, lastProfile, TotNumProfs, hdfVersion, &
    & createSwath)
    ! sticks l2gp into the swath swathName in the file pointed at by
    ! l2FileHandle,starting at the profile number "offset" (First profile
    ! in the file has offset==0). If this runs off the end of the swath, 
    ! it is lengthened automagically. 
    ! This call has been altered recently, so that it can be used to create
    ! a swath as well as adding to one. 

    ! Arguments

    integer, intent(IN) :: l2FileHandle ! From swopen

    ! This is a L2GPData_T structure containing all the data to be written
    type (L2GPData_T), intent(INOUT) :: l2gp
    ! This is the name the swath is given in the file. By default it is
    ! the name contained in l2gp
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    ! This (offset) is the point in the swath at which the data is written. 
    ! First profile in the file has offset==0. If the swath in the file is 
    ! shorter than offset + ( num of profiles in l2gp) then it grows by magic
    integer, intent(IN), optional::offset
    ! TotNumProfs is a new argument. It seems only to be used if we are 
    ! creating a swath, rather than adding to one. In that case I guess
    ! it is the total number of profiles in the swath created. I also 
    ! guess that this is done so that we can avoid growing and re-growing 
    ! the swath.
    integer, intent(IN), optional::TotNumProfs
    integer, intent(IN), optional::lastProfile
    integer, optional, intent(in) :: hdfVersion ! better be 4 or 5!
    logical, intent(in), optional :: createSwath
    ! Local
    integer :: myhdfVersion
    integer :: status
    type( MLSFile_T ) :: l2gpFile

    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L2GPDEFAULT_HDFVERSION
    endif
    status = InitializeMLSFile(l2gpFile, type=l_swath, access=DFACC_RDWR, &
      & content='l2gp', name='unknown', hdfVersion=myhdfVersion)
    l2gpFile%FileID%f_id = l2FileHandle
    l2gpFile%stillOpen = .true.
    
    call AppendL2GPData(l2gp, l2gpFile, &
    & swathName, offset, lastProfile, TotNumProfs, createSwath)
  end subroutine AppendL2GPData_fileID

d299 3
a301 2
  subroutine AppendL2GPData_fileName(l2gp, fileName, &
    & swathname, offset, lastProfile, TotNumProfs, hdfVersion)
d317 2
d362 4
a365 3
    call AppendL2GPData_fileID(l2gp, L2FileHandle, swathname, &
      & offset, lastProfile=lastProfile, totNumProfs=totNumProfs, &
      & hdfVersion=the_hdfVersion)
d373 54
d429 1
a429 1
  subroutine AppendL2GPData_MLSfile(l2gp, l2gpFile, &
d431 1
a431 1
    & createSwath)
d461 1
d465 4
a472 2
    integer :: myLastProfile
    character (len=L2GPNameLen) :: myswathName
d518 2
a519 1
      call ReadL2GPData( L2GPFile, myswathName, totall2gp, numProfs )
d523 2
d528 1
d548 1
d550 15
a564 3
        call OutputL2GP_createFile_MF (l2gp, L2GPFile, &
          & myswathName,&
          & notUnlimited=(avoidUnlimitedDims .and. present(totNumProfs)) )
d567 1
a567 1
         & 'Illegal hdf version in AppendL2GPData_MLSFile', MLSFile=L2GPFile)
d586 2
a604 7
    
    if (DEEBUG) then
      call ReadL2GPData( L2GPFile, myswathName, totall2gp, numProfs )
      call outputNamedValue( 'numProfs', numProfs )
      call outputNamedValue( 'total numProfs', totall2gp%nTimes )
      call DestroyL2GPContents ( totall2gp )
    endif
d615 1
a615 1
    & hdfVersion1, hdfVersion2, notUnlimited, rename, ReadStatus, &
d632 1
a632 1
    logical, optional, intent(in) :: ReadStatus
d694 1
a694 1
           & hdfVersion=hdfVersion1, ReadStatus=ReadStatus )
d743 1
a743 1
    & notUnlimited, andGlAttributes, ReadStatus, HGrid, &
d768 1
a768 1
    logical, optional, intent(in)           :: ReadStatus
d896 1
a896 1
      & ReadStatus=ReadStatus, HGrid=HGrid, &
d921 1
a921 1
    & notUnlimited, andGlAttributes, ReadStatus, HGrid, &
d941 1
a941 1
    logical, optional, intent(in)           :: ReadStatus
d982 1
a982 1
      & notUnlimited, andGLAttributes, ReadStatus, HGrid, &
d2527 2
a2529 1
    logical :: myFillIn
d2639 1
d2644 15
a2658 1
      if ( present( which ) ) then
d2744 2
a2745 1
      call ReadL2GPData( L2GPFile, swathName, readl2gp, numProfs )
d2901 1
a2901 1
       firstProf, lastProf, hdfVersion, HMOT, ReadStatus)
d2919 1
a2919 1
    logical, optional, intent(in) :: ReadStatus
d2939 1
a2939 1
       firstProf, lastProf, HMOT, ReadStatus)
d2945 1
a2945 1
       firstProf, lastProf, hdfVersion, HMOT, ReadStatus)
d2963 1
a2963 1
    logical, optional, intent(in) :: ReadStatus
d2986 1
a2986 1
       & hmot=hmot, ReadStatus=ReadStatus)
d2997 1
a2997 1
       firstProf, lastProf, HMOT, ReadStatus)
d3014 1
a3014 1
    logical, optional, intent(in) :: ReadStatus
d3049 1
a3049 1
        & numProfs, firstProf, lastProf, ReadStatus)
d3055 1
a3055 1
        & numProfs, firstProf, lastProf, ReadStatus)
d3065 1
a3065 1
    & numProfs, firstProf, lastProf, ReadStatus)
a3074 1
    ! All the ReadStatus harrumphing is on its way out
d3085 1
a3085 1
    logical, optional, intent(in) :: ReadStatus
d3120 1
a3120 1
    logical :: ReadingStatus
d3130 2
a3131 2
    ReadingStatus = READINGSTATUSBYDEFAULT ! was .false.
    if ( present(ReadStatus) ) ReadingStatus = ReadStatus
d3273 10
d3396 1
a3396 2
    if ( ReadingStatus ) &
      & status = mls_swrdfld( swid, 'Status',start(3:3),stride(3:3),edge(3:3),&
d4538 1
a4538 1
       "$Id: L2GPData.f90,v 2.156 2008/04/18 21:06:59 pwagner Exp $"
d4550 3
@


2.156
log
@Fixed error introduced last time
@
text
@d296 11
a306 9
  !------------------------------------------  ExtractL2GPRecord  -----
  subroutine ExtractL2GPRecord ( ol2gp, l2gp, rFreqs, rLevels, rTimes )
    ! Extract a reduced copy of an original l2gp record
    ! picking out a range of subscripts for freqs, level2, times
    ! Omitted ranges will be same range as original l2gp
    
    ! Note that this does not do the more useful task:
    ! Reposition an l2gp record onto a new set of geolocations
    ! via multi-dimensional or repeated interpolation
d308 1
a308 6
    ! Nor does it (yet) do another potentially useful task:
    ! Extract the range of profiles within a box of times, lats, lons
    ! and a range of levels within a range of pressures
    
    ! These last tasks aren't too difficult, since we could define
    ! myTimes and myLevels based on HuntRange.
d310 1
a310 2
    ! A tricky point: invalid ranges (i.e. upper limit < 1) will
    ! be treated as if they were omitted
d312 22
a333 10
    ! Dummy arguments
    type (L2GPData_T), intent(in)   :: ol2gp
    type (L2GPData_T), intent(out)  :: l2gp
    integer, dimension(2), intent(in), optional :: rFreqs  ! subscript range
    integer, dimension(2), intent(in), optional :: rLevels ! subscript range
    integer, dimension(2), intent(in), optional :: rTimes  ! subscript range
    ! Local variables
    integer, dimension(2) :: myFreqs  ! subscript range
    integer, dimension(2) :: myLevels ! subscript range
    integer, dimension(2) :: myTimes  ! subscript range
d335 3
a337 19
    logical :: useFreqs  
    logical :: useLevels 
    logical :: useTimes  
    
    ! Executable
    useFreqs   = .false.
    useLevels  = .false.
    useTimes   = .false.
    if ( present(rFreqs) ) then
      useFreqs = rFreqs(2) > 0
    endif
    if ( present(rLevels) ) then
      useLevels = rLevels(2) > 0
    endif
    if ( present(rTimes) ) then
      useTimes = rTimes(2) > 0
    endif
    if ( useFreqs ) then
      myFreqs = rFreqs
d339 1
a339 14
      myFreqs(1) = 1
      myFreqs(2) = ol2gp%nFreqs
    endif
    if ( useLevels ) then
      myLevels = rLevels
    else
      myLevels(1) = 1
      myLevels(2) = ol2gp%nLevels
    endif
    if ( useTimes ) then
      myTimes = rTimes
    else
      myTimes(1) = 1
      myTimes(2) = ol2gp%nTimes
d341 4
d346 3
a348 4
    call SetupNewL2GPRecord ( l2gp, &
      & ( myFreqs(2) - myFreqs(1) + 1 ), &
      & ( myLevels(2) - myLevels(1) + 1 ), &
      & ( myTimes(2) - myTimes(1) + 1 ) )
d350 1
a350 26
    l2gp%name               = ol2gp%name    
    l2gp%nameIndex          = ol2gp%nameIndex    
    l2gp%quantitytype       = ol2gp%quantitytype 
    l2gp%MissingValue       = ol2gp%MissingValue 
    l2gp%MissingStatus      = ol2gp%MissingStatus
    l2gp%verticalCoordinate = ol2gp%verticalCoordinate    
    ! Now fill the actual arrays
    ! We'll need to have sane ranges for freqs and levels even if the
    ! we supplied 0 originally
    myFreqs(2) = max( myFreqs(2), myFreqs(1) )
    myLevels(2) = max( myLevels(2), myLevels(1) )
    call ExtractArray ( l2gp%pressures    , ol2gp%pressures    , myLevels )
    call ExtractArray ( l2gp%frequency    , ol2gp%frequency    , myFreqs )
    call ExtractArray ( l2gp%latitude     , ol2gp%latitude     , myTimes )
    call ExtractArray ( l2gp%longitude    , ol2gp%longitude    , myTimes )
    call ExtractArray ( l2gp%solarTime    , ol2gp%solarTime    , myTimes )
    call ExtractArray ( l2gp%solarZenith  , ol2gp%solarZenith  , myTimes )
    call ExtractArray ( l2gp%losAngle     , ol2gp%losAngle     , myTimes )
    call ExtractArray ( l2gp%geodAngle    , ol2gp%geodAngle    , myTimes )
    call ExtractArray ( l2gp%time         , ol2gp%time         , myTimes )
    call ExtractArray ( l2gp%chunkNumber  , ol2gp%chunkNumber  , myTimes )
    call ExtractArray ( l2gp%l2gpValue    , ol2gp%l2gpValue    , myFreqs, myLevels, myTimes )
    call ExtractArray ( l2gp%l2gpPrecision, ol2gp%l2gpPrecision, myFreqs, myLevels, myTimes )
    call ExtractArray ( l2gp%status       , ol2gp%status       , myTimes )
    call ExtractArray ( l2gp%convergence  , ol2gp%convergence  , myTimes )
  end subroutine ExtractL2GPRecord
d352 3
a354 2
  !------------------------------------------  IsL2GPSetUp  -----
  function IsL2GPSetUp ( l2gp ) result( sooDesu )
d356 3
a358 1
    ! return TRUE only if all arrays allocated
d360 1
a360 20
    ! Dummy arguments
    type (L2GPData_T), intent(in)  :: l2gp
    logical :: sooDesu
    ! Executable
    sooDesu = .true.
    sooDesu = sooDesu .and. ( size(l2gp%pressures       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%frequency       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%latitude        )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%longitude       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%solarTime       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%solarZenith     )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%losAngle        )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%geodAngle       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%time            )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%chunkNumber     )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%l2gpValue       )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%l2gpPrecision   )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%status          )     > 0 )
    sooDesu = sooDesu .and. ( size(l2gp%convergence     )     > 0 )
  end function IsL2GPSetUp
d362 8
a369 3
  !------------------------------------------  SetupNewL2GPRecord  -----
  subroutine SetupNewL2GPRecord ( l2gp, nFreqs, nLevels, nTimes, nTimesTotal, &
    & FillIn, proto, which )
d371 16
a386 3
    ! This routine sets up the arrays for an l2gp datatype.
    ! It preassigns their values to MissingValue (if FillIn is TRUE)
    ! or to proptype's values (if supplied)
a387 9
    ! Dummy arguments
    type (L2GPData_T), intent(inout)  :: l2gp
    integer, intent(in), optional :: nFreqs              ! Dimensions
    integer, intent(in), optional :: nLevels             ! Dimensions
    integer, intent(in), optional :: nTimes              ! Dimensions
    integer, intent(in), optional :: nTimesTotal         ! Dimensions
    logical, intent(in), optional :: FillIn    ! Fill with MissingValue
    type (L2GPData_T), intent(in), optional  :: proto    ! prototype
    integer, dimension(:), optional, intent(in) :: which ! which profiles to fill from
d389 14
a402 8
    ! Local variables
    integer :: useNFreqs, useNLevels, useNTimes, useNTimesTotal
    logical :: myFillIn

    if ( present(nFreqs) ) then
       useNFreqs=nFreqs
    elseif ( present(proto) ) then
       useNFreqs=proto%nFreqs
d404 17
a420 2
       useNFreqs=0
    end if
d422 1
a422 7
    if ( present(nLevels) ) then
       useNLevels=nLevels
    elseif ( present(proto) ) then
       useNLevels=proto%nLevels
    else
       useNLevels=0
    end if
d424 51
a474 8
    if ( present(nTimes) ) then
       useNTimes=nTimes
    elseif ( present(proto) ) then
      if ( present(which) ) then
       useNTimes=size(which)
      else
       useNTimes=proto%nTimes
      endif
d476 18
a493 7
       useNTimes=0              ! Default to empty l2gp
    end if

    if ( present(nTimesTotal) ) then
       useNTimesTotal=nTimesTotal
    elseif ( present(proto) ) then
       useNTimesTotal=proto%nTimesTotal
d495 10
a504 2
       useNTimesTotal=0              ! Default to empty l2gp
    end if
d506 13
a518 4
    if ( present(FillIn) ) then
      myFillIn = FillIn
    elseif ( present(proto) ) then
     myFillIn=.FALSE. ! fill in with values of proto
d520 25
a544 1
      myFillIn = ALWAYSFILLWITHMISSINGVALUE
d547 12
a558 6
    ! Sanity
    useNTimesTotal = max(useNTimesTotal, useNTimes)
    if ( useNLevels > MAXNLEVELS ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & 'Too many levels in SetUpNewL2GPRecord')
    ! Store the dimensionality
d560 25
a584 4
    l2gp%nTimes = useNTimes
    l2gp%nTimesTotal = useNTimesTotal
    l2gp%nLevels = useNLevels
    l2gp%nFreqs = useNFreqs
d586 5
a590 4
    ! But allocate to at least one for times, freqs
 
    useNLevels=MAX(useNLevels,1)
    useNFreqs=MAX(useNFreqs,1)    
d592 1
a592 4
    ! Allocate the vertical coordinate
    l2gp%verticalCoordinate = 'Pressure'
    call allocate_test ( l2gp%pressures, useNLevels, "l2gp%pressures", &
         & ModuleName )
d594 4
a597 3
    ! Allocate the frequency coordinate
    
    call allocate_test ( l2gp%frequency, useNFreqs, "l2gp%frequency", ModuleName)
d599 3
a601 1
    ! Allocate the horizontal coordinates
d603 2
a604 8
    call allocate_test(l2gp%latitude,   useNTimes, "l2gp%latitude",   ModuleName)
    call allocate_test(l2gp%longitude,  useNTimes, "l2gp%longitude",  ModuleName)
    call allocate_test(l2gp%solarTime,  useNTimes, "l2gp%solarTime",  ModuleName)
    call allocate_test(l2gp%solarZenith,useNTimes, "l2gp%solarZenith",ModuleName)
    call allocate_test(l2gp%losAngle,   useNTimes, "l2gp%losAngle",   ModuleName)
    call allocate_test(l2gp%geodAngle,  useNTimes, "l2gp%geodAngle",  ModuleName)
    call allocate_test(l2gp%time,       useNTimes, "l2gp%time",       ModuleName)
    call allocate_test(l2gp%chunkNumber,useNTimes, "l2gp%chunkNumber",ModuleName)
d606 13
a618 1
    ! Allocate the data fields
d620 89
a708 43
    call allocate_test(l2gp%l2gpValue,useNFreqs,useNLevels,&
      & useNTimes,"l2gp%l2gpValue", ModuleName)
    call allocate_test(l2gp%l2gpPrecision,useNFreqs,useNLevels,&
      & useNTimes,"l2gp%l2gpPrecision", ModuleName)

    call allocate_test(l2gp%status, useNTimes,"l2gp%status", ModuleName)
    call allocate_test(l2gp%quality,useNTimes,"l2gp%quality",ModuleName)
    call allocate_test(l2gp%convergence,useNTimes,"l2gp%convergence",ModuleName)
    if ( myFillIn ) then
      l2gp%pressures    = l2gp%MissingValue
      l2gp%frequency    = l2gp%MissingValue
      l2gp%latitude     = l2gp%MissingValue
      l2gp%longitude    = l2gp%MissingValue
      l2gp%solarTime    = l2gp%MissingValue
      l2gp%solarZenith  = l2gp%MissingValue
      l2gp%losAngle     = l2gp%MissingValue
      l2gp%geodAngle    = l2gp%MissingValue
      l2gp%time         = l2gp%MissingValue
      l2gp%chunkNumber  = l2gp%MissingValue
      l2gp%l2gpValue    = l2gp%MissingValue
      l2gp%l2gpPrecision= l2gp%MissingValue
      l2gp%status       = l2gp%MissingStatus ! l2gp%MissingValue
      l2gp%quality      = l2gp%MissingValue
      l2gp%convergence  = l2gp%MissingValue
    elseif ( present(proto) ) then
      l2gp%MissingStatus= proto%MissingStatus
      l2gp%MissingValue = proto%MissingValue
      l2gp%pressures    = proto%pressures    
      l2gp%frequency    = proto%frequency
      if ( present( which ) ) then
      l2gp%latitude     = proto%latitude     (which)
      l2gp%longitude    = proto%longitude    (which)
      l2gp%solarTime    = proto%solarTime    (which)
      l2gp%solarZenith  = proto%solarZenith  (which)
      l2gp%losAngle     = proto%losAngle     (which) 
      l2gp%geodAngle    = proto%geodAngle    (which) 
      l2gp%time         = proto%time         (which) 
      l2gp%chunkNumber  = proto%chunkNumber  (which) 
      l2gp%l2gpValue    = proto%l2gpValue    (:,:,which)
      l2gp%l2gpPrecision= proto%l2gpPrecision(:,:,which)
      l2gp%status       = proto%status       (which)
      l2gp%quality      = proto%quality      (which)
      l2gp%convergence  = proto%convergence  (which)
d710 3
a712 13
      l2gp%latitude     = proto%latitude     
      l2gp%longitude    = proto%longitude    
      l2gp%solarTime    = proto%solarTime    
      l2gp%solarZenith  = proto%solarZenith
      l2gp%losAngle     = proto%losAngle     
      l2gp%geodAngle    = proto%geodAngle    
      l2gp%time         = proto%time         
      l2gp%chunkNumber  = proto%chunkNumber  
      l2gp%l2gpValue    = proto%l2gpValue    
      l2gp%l2gpPrecision= proto%l2gpPrecision
      l2gp%status       = proto%status       
      l2gp%quality      = proto%quality      
      l2gp%convergence  = proto%convergence  
d714 12
a725 2
    endif
  end subroutine SetupNewL2GPRecord
d727 5
a731 2
  !-----------------------------------------  DestroyL2GPContents  -----
  subroutine DestroyL2GPContents ( L2GP )
d733 4
a736 1
    ! This routine deallocates all the arrays allocated above.
d738 16
a753 2
    ! Dummy arguments
    type (L2GPData_T), intent(inout) :: L2GP
d755 21
d777 17
d795 21
a815 19
    call deallocate_test ( l2gp%pressures,         "l2gp%pressures",         ModuleName )
    call deallocate_test ( l2gp%latitude,          "l2gp%latitude",          ModuleName )
    call deallocate_test ( l2gp%longitude,         "l2gp%longitude",         ModuleName )
    call deallocate_test ( l2gp%solarTime,         "l2gp%solarTime",         ModuleName )
    call deallocate_test ( l2gp%solarZenith,       "l2gp%solarZenith",       ModuleName )
    call deallocate_test ( l2gp%losAngle,          "l2gp%losAngle",          ModuleName )
    call deallocate_test ( l2gp%geodAngle,         "l2gp%geodAngle",         ModuleName )
    call deallocate_test ( l2gp%chunkNumber,       "l2gp%chunkNumber",       ModuleName )
    call deallocate_test ( l2gp%time,              "l2gp%time",              ModuleName )
    call deallocate_test ( l2gp%frequency,         "l2gp%frequency",         ModuleName )
    call deallocate_test ( l2gp%l2gpValue,         "l2gp%l2gpValue",         ModuleName )
    call deallocate_test ( l2gp%l2gpPrecision,     "l2gp%l2gpPrecision",     ModuleName )
    call deallocate_test ( l2gp%status,            "l2gp%status",            ModuleName )
    call deallocate_test ( l2gp%quality,           "l2gp%quality",           ModuleName )
    call deallocate_test ( l2gp%convergence,       "l2gp%convergence",       ModuleName )
    l2gp%nTimes = 0
    l2gp%nTimesTotal = 0
    l2gp%nLevels = 0
    l2gp%nFreqs = 0
d817 51
a867 1
  end subroutine DestroyL2GPContents
d869 25
a893 35
  !-------------------------------------- ExpandL2GPDataInFile ---
  
  subroutine ExpandL2GPDataInFile( L2GPFile, swathName, l2gp )
    ! Repeated rewrite swathname until its numProfs >= l2gp%nTimes
    ! Args
    type(MLSFile_T) :: L2GPFile
    character(len=*), intent(in) :: swathName
    type (L2GPData_T), intent(inout) :: l2gp
    ! Internal variables
    logical :: done
    integer :: M
    integer :: ReadM
    integer, parameter :: MAXPASSES = 40
    integer, parameter :: METHOD = 1
    integer :: numProfs
    integer :: passes
    type (L2GPData_T) :: smallerl2gp, readl2gp
    ! Executable
    if ( L2GPFile%hdfVersion /= HDFVERSION_5 ) return
    M = l2gp%nTimes
    if ( M < 2 ) return
    if ( method == 1 ) then
      call ReadL2GPData( L2GPFile, swathName, readl2gp, numProfs )
      ReadM = readl2gp%nTimes
      if(DEEBUG) call outputNamedValue( 'numProfs', numProfs )
      if(DEEBUG) call outputNamedValue( 'readl2gp%nTimes', readl2gp%nTimes )
      call DestroyL2GPContents ( readl2gp )
      if ( ReadM >= M ) return
      call ExtractL2GPRecord ( l2gp, smallerl2gp, rTimes=(/ M, M /) )
      call OutputL2GP_writeGeo_MF ( smallerl2gp, l2GPFile, &
        & swathName, offset=M-1 )
      call OutputL2GP_writeData_MF ( smallerl2gp, l2GPFile, &
        & swathName, offset=M-1 )
      call DestroyL2GPContents ( smallerl2gp )
      return
d895 1
a895 23
    done = .false.
    do passes=1, MAXPASSES
      call ReadL2GPData( L2GPFile, swathName, readl2gp, numProfs )
      ReadM = readl2gp%nTimes
      if(DEEBUG) call outputNamedValue( 'numProfs', numProfs )
      if(DEEBUG) call outputNamedValue( 'readl2gp%nTimes', readl2gp%nTimes )
      done = ( ReadM >= M )
      call DestroyL2GPContents ( readl2gp )
      if ( done ) return
      call ExtractL2GPRecord ( l2gp, smallerl2gp, rTimes=(/ ReadM+1, M /) )
      call OutputL2GP_writeGeo_MF ( smallerl2gp, l2GPFile, &
        & swathName, offset=ReadM )
      call OutputL2GP_writeData_MF ( smallerl2gp, l2GPFile, &
        & swathName, offset=ReadM )
      call DestroyL2GPContents ( smallerl2gp )
    enddo
    call MLSMessage ( MLSMSG_Error, ModuleName // '/ExpandL2GPDataInFile', &
      & "Failed to fit l2gp in file", MLSFile=L2GPFile )
  end subroutine ExpandL2GPDataInFile
  
  !---------------------------------------  ExpandL2GPDataInPlace  -----
  
  subroutine ExpandL2GPDataInPlace ( l2gp, newNTimes )
d897 1
a897 3
    ! This subroutine expands an L2GPData_T in place allowing the user to 
    ! (1) add more profiles to it; or
    ! 
d899 5
a903 3
    ! Dummy arguments
    type (L2GPData_T), intent(inout) :: l2gp
    integer, optional, intent(in)    :: newNTimes
d905 7
a911 4
    ! Local variables
    type (L2GPData_T) :: tempL2gp       ! For copying data around
    integer :: myNTimes
    integer :: tmpNFreqs, tmpNLevels
d913 35
a947 1
    ! Executable code
d949 8
a956 12
   if(present(newNTimes)) then
      myNTimes = newNTimes
   else
      myNTimes = l2gp%nTimes
   endif

    ! First do a sanity check


    if ( myNTimes<l2gp%nTimes ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
         & "The number of profiles requested is fewer than those already present" )
d958 6
d965 3
a967 1
    tempL2gp = l2gp ! Copy the pointers to the old information
d969 4
a972 13
    ! Now recreate l2gp with the new size.
    ! First, nullify all of the pointers in l2gp, so that a deallocate_test
    ! won't delete them.  After all, we just went to the trouble to preserve
    ! them in TempL2GP!
    nullify ( l2gp%pressures, l2gp%latitude, l2gp%longitude, l2gp%solarTime, &
      & l2gp%solarZenith, l2gp%losAngle, l2gp%losAngle, l2gp%geodAngle, &
      & l2gp%chunkNumber, l2gp%time, l2gp%frequency, l2gp%l2gpValue, &
      & l2gp%l2gpPrecision, l2gp%status, l2gp%quality, l2gp%convergence )
    
    tmpNFreqs = l2gp%nFreqs
    tmpNLevels = l2gp%nLevels
    call SetupNewL2GPRecord( l2gp, nFreqs=tmpNFreqs, nLevels=tmpNLevels, &
      & nTimes=myNTimes, FillIn = .true. )
d974 1
a974 4
    ! Don't forget the `global' stuff
    l2gp%pressures=templ2gp%pressures
    l2gp%frequency=templ2gp%frequency
    l2gp%verticalCoordinate = templ2gp%verticalCoordinate
d976 1
a976 9
    ! Now go through the parameters one by one, and copy the previous contents
    l2gp%latitude(1:templ2gp%nTimes) = templ2gp%latitude(1:templ2gp%nTimes)
    l2gp%longitude(1:templ2gp%nTimes) = templ2gp%longitude(1:templ2gp%nTimes)
    l2gp%solarTime(1:templ2gp%nTimes) = templ2gp%solarTime(1:templ2gp%nTimes)
    l2gp%solarZenith(1:templ2gp%nTimes) = templ2gp%solarZenith(1:templ2gp%nTimes)
    l2gp%losAngle(1:templ2gp%nTimes) = templ2gp%losAngle(1:templ2gp%nTimes)
    l2gp%geodAngle(1:templ2gp%nTimes) = templ2gp%geodAngle(1:templ2gp%nTimes)
    l2gp%time(1:templ2gp%nTimes) = templ2gp%time(1:templ2gp%nTimes)
    l2gp%chunkNumber(1:templ2gp%nTimes) = templ2gp%chunkNumber(1:templ2gp%nTimes)
d978 22
a999 10
    l2gp%l2gpValue(:,:,1:templ2gp%nTimes) = templ2gp%l2gpValue(:,:,1:templ2gp%nTimes)
    l2gp%l2gpPrecision(:,:,1:templ2gp%nTimes) = &
         templ2gp%l2gpPrecision(:,:,1:templ2gp%nTimes)
    
    l2gp%status(1:templ2gp%nTimes) = templ2gp%status(1:templ2gp%nTimes)
    l2gp%quality(1:templ2gp%nTimes) = templ2gp%quality(1:templ2gp%nTimes)
    l2gp%convergence(1:templ2gp%nTimes) = templ2gp%convergence(1:templ2gp%nTimes)
    
    ! Deallocate the old arrays
    call DestroyL2GPContents(templ2gp)
d1001 47
a1047 1
  end subroutine ExpandL2GPDataInPlace
d1049 1
a1049 6
  !-------------------------------------------  AddL2GPToDatabase  -----
  integer function AddL2GPToDatabase( DATABASE, ITEM )

    ! This function adds an l2gp data type to a database of said types,
    ! creating a new database if it doesn't exist.  The result value is
    ! the size -- where L2gp is put.
d1051 4
d1056 18
a1073 2
    type (l2gpdata_t), dimension(:), pointer :: DATABASE
    type (l2gpdata_t), intent(in) :: ITEM
d1076 49
a1124 16
    type (l2GPData_T), dimension(:), pointer :: tempDatabase
    !This include causes real trouble if you are compiling in a different 
    !directory.
    include "addItemToDatabase.f9h" 

    AddL2GPToDatabase = newSize
  end function AddL2GPToDatabase

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a quantity template database

  subroutine DestroyL2GPDatabase ( DATABASE )

    ! Dummy argument
    type (l2GPData_T), dimension(:), pointer :: DATABASE
d1126 32
d1159 40
a1198 1
    integer :: l2gpIndex, status
d1200 47
a1246 39
    if ( associated(database) ) then
       do l2gpIndex = 1, SIZE(database)
          call DestroyL2GPContents ( database(l2gpIndex) )
       end do
       deallocate ( database, stat=status )
       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_deallocate // "database" )
    end if
  end subroutine DestroyL2GPDatabase

  ! ---------------------- ReadL2GPData_fileID  -----------------------------

  subroutine ReadL2GPData_fileID(L2FileHandle, swathname, l2gp, numProfs, &
       firstProf, lastProf, hdfVersion, HMOT, ReadStatus)
    !------------------------------------------------------------------------

    ! Given a file handle,
    ! This routine reads an L2GP file, in either hdfVersion,
    ! returning a filled data structure and the !
    ! number of profiles read.
    ! if present, hdfVersion must be one of HDFVERSION_4, HDFVERSION_5

    ! Arguments

    character (len=*), intent(in) :: swathname ! Name of swath
    integer, intent(in) :: L2FileHandle ! Returned by swopen
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: l2gp ! Result
    integer, intent(out), optional :: numProfs ! Number actually read
    integer, optional, intent(in) :: hdfVersion
    character, optional, intent(in) :: hmot   ! 'H' 'M'(def) 'O' 'T'
    logical, optional, intent(in) :: ReadStatus

    ! Local
    integer :: myhdfVersion
    character :: my_hmot
    integer :: status
    type( MLSFile_T ) :: l2gpFile
    
d1248 8
a1255 4
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L2GPDEFAULT_HDFVERSION
d1257 7
a1263 8
    my_hmot = 'M'
    status = InitializeMLSFile(l2gpFile, type=l_swath, access=DFACC_RDONLY, &
      & content='l2gp', name='unknown', hdfVersion=myhdfVersion)
    l2gpFile%FileID%f_id = l2FileHandle
    l2gpFile%stillOpen = .true.
    call ReadL2GPData(l2gpFile, swathname, l2gp, numProfs, &
       firstProf, lastProf, HMOT, ReadStatus)
  end subroutine ReadL2GPData_fileID
d1265 1
a1265 1
  ! ---------------------- ReadL2GPData_fileName  -----------------------------
d1267 121
a1387 3
  subroutine ReadL2GPData_fileName(fileName, swathname, l2gp, numProfs, &
       firstProf, lastProf, hdfVersion, HMOT, ReadStatus)
    !------------------------------------------------------------------------
d1389 5
a1393 5
    ! Given a file name,
    ! This routine reads an L2GP file, in either hdfVersion,
    ! returning a filled data structure and the !
    ! number of profiles read.
    ! hdfVersion may be WILDCARDHDFVERSION
d1395 51
a1445 1
    ! Arguments
d1447 85
a1531 8
    character (len=*), intent(in) :: swathname ! Name of swath
    character (len=*), intent(in) :: fileName ! Name of swath
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: l2gp ! Result
    integer, intent(out), optional :: numProfs ! Number actually read
    integer, optional, intent(in) :: hdfVersion
    character, optional, intent(in) :: hmot   ! 'H' 'M'(def) 'O' 'T'
    logical, optional, intent(in) :: ReadStatus
d1533 46
a1578 3
    ! Local
    integer :: L2FileHandle
    integer :: record_length
d1580 16
a1595 1
    integer :: the_hdfVersion
d1597 34
a1630 6
    ! Executable code
    the_hdfVersion = mls_hdf_version(FileName, hdfVersion)
    if ( the_hdfVersion == FILENOTFOUND ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'File not found; make sure the name and path are correct' &
        & // trim(fileName) )
d1632 3
a1634 15
    L2FileHandle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, DFACC_READ, FileName=FileName, &
       & hdfVersion=hdfVersion, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(FileName) // ' for reading')
    call ReadL2GPData_fileID(L2FileHandle, swathname, l2gp, numProfs=numProfs, &
       & firstProf=firstProf, lastProf=lastProf, hdfVersion=the_hdfVersion, &
       & hmot=hmot, ReadStatus=ReadStatus)
    status = mls_io_gen_closeF(l_swath, L2FileHandle, FileName=FileName, &
      & hdfVersion=hdfVersion)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(FileName) // ' after reading')
  end subroutine ReadL2GPData_fileName
d1636 3
a1638 1
  ! ---------------------- ReadL2GPData_MLSFile  -----------------------------
d1640 53
a1692 23
  subroutine ReadL2GPData_MLSFile(L2GPFile, swathname, l2gp, numProfs, &
       firstProf, lastProf, HMOT, ReadStatus)
    !------------------------------------------------------------------------

    ! Given a file,
    ! This routine reads an L2GP structure, in either hdfVersion,
    ! returning a filled data structure and the !
    ! number of profiles read.
    ! if present, hdfVersion must be one of HDFVERSION_4, HDFVERSION_5

    ! Arguments

    character (len=*), intent(in) :: swathname ! Name of swath
    type(MLSFile_T)                :: L2GPFile
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: l2gp ! Result
    integer, intent(out), optional :: numProfs ! Number actually read
    character, optional, intent(in) :: hmot   ! 'H' 'M'(def) 'O' 'T'
    logical, optional, intent(in) :: ReadStatus

    ! Local
    logical :: alreadyOpen
    character :: my_hmot
d1694 6
a1699 1
    
d1701 5
a1705 7
    my_hmot = 'M'
    if ( present(hmot)) my_hmot = Capitalize(hmot)
    ! Check for valid hmot
    select case (my_hmot)
    case ('H')
    case ('M')
    case ('O')
d1707 12
a1718 2
      & "Unable to Read OMI L2GPData", MLSFile=L2GPFile )
    case ('T')
d1720 61
a1780 2
      & "Unable to Read TES L2GPData", MLSFile=L2GPFile )
    case default
d1782 5
a1786 15
      & "Unrecognized instrument key passed to ReadL2GPData: "// my_hmot, &
      & MLSFile=L2GPFile )
    end select
    status = 0
    alreadyOpen = L2GPFile%stillOpen
    if ( .not. alreadyOpen ) then
      call mls_openFile(L2GPFile, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l2gp file', MLSFile=L2GPFile)
    endif
    if (L2GPFile%hdfVersion == HDFVERSION_4) then
      call ReadL2GPData_MF_hdf(L2GPFile, swathname, l2gp, my_hmot,&
        & numProfs, firstProf, lastProf, ReadStatus)
    elseif (L2GPFile%hdfVersion /= HDFVERSION_5) then
d1788 1
a1788 9
      & "Unrecognized hdfVersion passed to ReadL2GPData", MLSFile=L2GPFile )
    else
      call ReadL2GPData_MF_hdf(L2GPFile, swathname, l2gp, my_hmot,&
        & numProfs, firstProf, lastProf, ReadStatus)
    endif
    if ( .not. alreadyOpen )  call mls_closeFile(L2GPFile, Status)
    L2GPFile%errorCode = status
    L2GPFile%lastOperation = 'read'
  end subroutine ReadL2GPData_MLSFile
d1790 1
a1790 1
  ! ------------------- ReadL2GPData_MF_hdf ----------------
d1792 56
a1847 7
  subroutine ReadL2GPData_MF_hdf(L2GPFile, swathname, l2gp, HMOT, &
    & numProfs, firstProf, lastProf, ReadStatus)
  use HDFEOS, only: SWINQDIMS
  use HDFEOS5, only: HE5_SWINQDIMS, HE5_SWINQDFLDS, HE5_swfldinfo
  use MLSHDFEOS, only: mls_swattach, mls_swdetach, mls_swdiminfo, mls_swrdfld
  use MLSStringLists, only: isInList
    !------------------------------------------------------------------------
d1849 53
a1901 2
    ! This routine reads an L2GP file, returning a filled data structure and the !
    ! number of profiles read.
d1903 1
a1903 4
    ! All the ReadStatus harrumphing is on its way out
    ! All the ReadConvergence harrumphing is because convergence is newly added
    ! (Some older files won't have this field)
    ! Arguments
d1905 1
a1905 7
    character (LEN=*), intent(IN) :: swathname ! Name of swath
    type(MLSFile_T)                :: L2GPFile
    integer, intent(IN), optional :: firstProf, lastProf ! Defaults to first and last
    type( L2GPData_T ), intent(OUT) :: l2gp ! Result
    character, intent(in) :: HMOT   ! 'H' 'M'(def) 'O' 'T'
    integer, intent(OUT),optional :: numProfs ! Number actually read
    logical, optional, intent(in) :: ReadStatus
d1907 6
a1912 21
    ! Local Parameters
    character (LEN=*), parameter :: SZ_ERR = 'Failed to get size of &
         &dimension '
    character (LEN=*), parameter :: MLSMSG_INPUT = 'Error in input argument '
    character (LEN=*), parameter :: MLSMSG_L2GPRead = 'Unable to read L2GP &
                                                     &field:'
    ! Local Variables
    character (len=80) :: DF_Name
    character (len=80) :: DF_Precision
    character (LEN=80) :: dimlist
    character (LEN=80) :: fieldlist
    character (LEN=80) :: list
    character (LEN=80) :: maxdimlist
    character (LEN=8)  :: maxdimName
    integer :: hdfVersion
    integer :: rank
    integer, dimension(MAXFNFIELDS) :: ranks
    integer, dimension(MAXFNFIELDS) :: types
    integer, dimension(7) :: numberType
    integer, dimension(7) :: flddims
    character (LEN=480) :: msr
d1914 7
a1920 54
    integer :: first, freq, lev, nDims, nFlds, size, swid, status
    integer :: start(3), stride(3), edge(3), dims(3)
    integer :: nFreqs, nLevels, nTimes, nFreqsOr1, nLevelsOr1, myNumProfs
    logical :: firstCheck, lastCheck

    real(r4), pointer, dimension(:) :: REALFREQ
    real(r4), pointer, dimension(:) :: REALSURF
    real(r4), pointer, dimension(:) :: REALPROF
    real(r4), pointer, dimension(:,:,:) :: REAL3
    logical :: dontfail
    logical :: ReadingConvergence
    logical :: ReadingStatus
    logical :: deeBugHere
    ! Executable code
    call MLSMessageCalls( 'push', constantName= 'ReadL2GPData_MF_hdf' )
    deeBugHere = DEEBUG     ! .or. .true.
    nullify ( realFreq, realSurf, realProf, real3 )
    hdfVersion = L2GPFile%hdfVersion
    ! Don't fail when trying to read an mls-specific field 
    ! if the file is from another Aura instrument
    dontfail = (HMOT /= 'M')
    ReadingStatus = READINGSTATUSBYDEFAULT ! was .false.
    if ( present(ReadStatus) ) ReadingStatus = ReadStatus
    ReadingConvergence = .false.
    ! Attach to the swath for reading
    l2gp%Name = swathname
    
    select case (HMOT)
    case ('H')
      swid = mls_SWattach(L2GPFile, 'HIRDLS')
      DF_Name = TRIM(l2gp%Name)
      DF_Precision = TRIM(l2gp%Name) // 'Precision'
      l2gp%MissingValue = -999.  ! This is a HIRDLS-specific setting
    case ('M')
      swid = mls_SWattach(L2GPFile, l2gp%Name)
      DF_Name = DATA_FIELD1
      DF_Precision = DATA_FIELD2
    case default
    end select
    if (swid == -1) call MLSMessage(MLSMSG_Error, ModuleName, &
         &'Failed to attach to hdfeos2/5 swath interface for reading' &
         & // trim(swathname), MLSFile=L2GPFile)

    ! Get dimension information

    lev = 0
    freq = 0

    if( hdfVersion == HDFVERSION_4 ) then
      nDims = swinqdims(swid, list, dims)
    else
      nDims = HE5_SWinqdims(swid, list, dims)
      nFlds = HE5_SWinqdflds( swid, fieldlist, ranks, types )
      ReadingConvergence = isInList( lowerCase(fieldList), 'convergence', '-fc' )
d1922 3
a1924 28
    if ( deeBugHere ) print *, 'HMOT: ', HMOT
    if ( deeBugHere ) print *, 'swathName: ', l2gp%name
    if ( deeBugHere ) print *, 'dimlist: ', trim(list)
    if ( deeBugHere ) print *, 'ndims: ', ndims
    if ( deeBugHere ) print *, 'dims: ', dims
    if (nDims == -1) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed to get dimension information on hdfeos5 swath ' // &
      & trim(swathname), MLSFile=L2GPFile)
    if ( index(list,'nLevels') /= 0 ) lev = 1
    if ( index(list,'Freq') /= 0 ) freq = 1

    size = mls_swdiminfo(swid, 'nTimes', hdfVersion=hdfVersion)
    if ( deeBugHere ) print *, 'size--1st try: ', size
    if ( hdfVersion == HDFVERSION_5 ) then
      ! This will be wrong if timeIsUnlim .eq. .TRUE. . 
      ! HE5_SWdiminfo returns 1 instead of the right answer.
      status = HE5_swfldinfo(swid, trim(DF_Name), rank, flddims, &
        & numberType, dimlist, maxdimlist)
      call GetHashElement (dimlist, &
       & maxdimlist, 'nTimes', &
       & maxDimName, .false.)
      if ( deeBugHere ) print *, 'flddims: ', flddims
      if ( deeBugHere ) print *, 'dimlist: ', trim(dimlist)
      if ( deeBugHere ) print *, 'maxdimlist: ', trim(maxdimlist)
      if ( maxDimName == 'Unlim' ) then
        status = StringElementNum(dimlist, 'nTimes', .false.)
        if ( status > 0 .and. status <= rank ) size = max(size, flddims(status))
      endif
d1926 5
a1930 3
    l2gp%nTimes = size
    l2gp%nTimesTotal = size
    nTimes=size
d1932 1
a1932 5
    if (lev == 0) then
       nLevels = 0
    else
      size = mls_swdiminfo(swid, 'nLevels', hdfVersion=hdfVersion)
       nLevels = size
a1933 1
    endif
d1935 12
a1946 9
    if ( freq == 1 .and. HMOT == 'M') then
      size = mls_swdiminfo(swid, 'nFreqs', hdfVersion=hdfVersion)
       nFreqs = size
    elseif ( freq == 1 .and. HMOT == 'H') then
      size = mls_swdiminfo(swid, 'nChans', hdfVersion=hdfVersion)
      nFreqs = size
    else
       nFreqs = 0
    endif
d1948 22
a1969 1
    ! Check optional input arguments
d1971 1
a1971 2
    firstCheck = present(firstProf)
    lastCheck = present(lastProf)
a1972 10
    if (firstCheck) then
      ! Note that if time is an umlimited dimension, HDF-EOS won't 
      ! nTimes is wrong.
       if ( (firstProf >= l2gp%nTimes) &
         .or. (firstProf < 0) ) then
          msr = MLSMSG_INPUT // 'firstProf'
          call MLSMessage(MLSMSG_Error, ModuleName, msr, MLSFile=L2GPFile)
       else
          first = firstProf
       endif
d1974 14
a1987 1
    else
d1989 7
a1995 1
       first = 0
d1997 7
d2005 3
a2007 22

    if (lastCheck) then

       if (lastProf < first) then
          msr = MLSMSG_INPUT // 'lastProf'
          call MLSMessage(MLSMSG_Error, ModuleName, msr, MLSFile=L2GPFile)
       endif

       ! If user has supplied "last" _and_ time is unlimited, we have
       ! to believe the user about how many profiles there are.
       ! This is _crap_ and is a temporary workaround. 
!       if(timeIsUnlim) then
!         myNumProfs = lastProf - first + 1
!         nTimes=lastprof-first+1
!         l2gp%nTimes=nTimes
!       endif
       if (lastProf >= nTimes) then
          myNumProfs = nTimes - first
       else
          myNumProfs = lastProf - first + 1
       endif

d2009 2
d2012 19
a2030 2
       myNumProfs = l2gp%nTimes - first

d2032 8
a2039 6

    ! Allocate result
    if ( deeBugHere ) then
      print *, 'nFreqs: ', nFreqs
      print *, 'nLevels: ', nLevels
      print *, 'mynumProfs: ', mynumProfs
d2041 84
a2124 2
    call SetupNewL2GPRecord (l2gp, nFreqs=nFreqs, nLevels=nLevels, &
      &  nTimes=mynumProfs, FillIn = .true.)
d2126 12
a2137 1
    ! Allocate temporary arrays
d2139 3
a2141 2
    nFreqsOr1=max(nFreqs,1)
    nLevelsOr1=max(nLevels, 1)
d2143 6
a2148 4
    call Allocate_test ( realProf, myNumProfs, 'realProf', ModuleName )
    call Allocate_test ( realSurf, l2gp%nLevels, 'realSurf', ModuleName )
    call Allocate_test ( realFreq, l2gp%nFreqs, 'realFreq', ModuleName )
    call Allocate_test ( real3, nFreqsOr1, nLevelsOr1, myNumProfs, 'real3', ModuleName )
d2150 24
a2173 1
    ! Read the horizontal geolocation fields
d2175 32
a2206 8
    start(1) = 0
    start(2) = 0
    start(3) = first
    stride = 1
    edge(1) = nFreqsOr1
    edge(2) = nLevelsOr1
    edge(3) = myNumProfs
    status=0
d2208 55
a2262 3
    status = mls_SWrdfld(swid, 'Latitude', start(3:3), stride(3:3), &
      edge(3:3), realProf, hdfVersion=hdfVersion)
    l2gp%latitude = realProf
d2264 44
a2307 3
    status = mls_SWrdfld(swid, 'Longitude', start(3:3), stride(3:3), edge(3:3),&
      &    realProf, hdfVersion=hdfVersion)
    l2gp%longitude = realProf
d2309 47
a2355 2
    status = mls_SWrdfld(swid, 'Time', start(3:3), stride(3:3), edge(3:3),&
      &    l2gp%time, hdfVersion=hdfVersion)
d2357 3
a2359 3
    status = mls_SWrdfld(swid, 'LocalSolarTime', start(3:3), stride(3:3), edge(3:3),&
      &    realProf, hdfVersion=hdfVersion)
    l2gp%solarTime = realProf
d2361 9
a2369 3
    status = mls_SWrdfld(swid, 'SolarZenithAngle', start(3:3), stride(3:3), edge(3:3),&
      &    realProf, hdfVersion=hdfVersion)
    l2gp%solarZenith = realProf
d2371 6
a2376 5
    ! These next 3 are MLS-specific
    if ( HMOT == 'M' ) then
    status = mls_SWrdfld(swid, 'LineOfSightAngle', start(3:3), stride(3:3), edge(3:3),&
      &    realProf, hdfVersion=hdfVersion, dontfail=dontfail)
    l2gp%losAngle = realProf
d2378 2
a2379 3
    status = mls_SWrdfld(swid, 'OrbitGeodeticAngle', start(3:3), stride(3:3), edge(3:3),&
      &   realProf, hdfVersion=hdfVersion, dontfail=dontfail)
    l2gp%geodAngle = realProf
d2381 10
a2390 2
    status = mls_SWrdfld(swid, 'ChunkNumber', start(3:3), stride(3:3), edge(3:3),&
      &    l2gp%chunkNumber, hdfVersion=hdfVersion, dontfail=dontfail)
d2392 16
d2409 5
a2413 8
    ! Read the pressures vertical geolocation field, if it exists

    if (lev /= 0) then

       status = mls_SWrdfld(swid,'Pressure',start(2:2),stride(2:2), edge(2:2),&
         & realSurf, hdfVersion=hdfVersion, dontfail=dontfail)
       l2gp%pressures = realSurf

d2415 17
d2433 27
a2459 1
    ! Read the frequency geolocation field, if it exists
d2461 2
a2462 1
    if (freq == 1) then
d2464 1
a2464 1
       edge(1) = l2gp%nFreqs
d2466 21
a2486 3
       status = mls_SWrdfld(swid,'Frequency',start(1:1),stride(1:1),edge(1:1),&
         & realFreq, hdfVersion=hdfVersion, dontfail=dontfail)
       l2gp%frequency = realFreq
d2488 3
a2490 1
    endif
d2492 3
a2494 1
    ! Read the data fields that may have 1-3 dimensions
d2496 9
a2504 1
    if ( freq == 1) then
d2506 3
a2508 3
       status = mls_SWrdfld(swid, trim(DF_Name), start, stride, edge, real3, &
         & hdfVersion=hdfVersion)
       l2gp%l2gpValue = real3
d2510 7
a2516 3
       status = mls_SWrdfld(swid, trim(DF_Precision), start, stride, edge, real3, &
         & hdfVersion=hdfVersion)
       l2gp%l2gpPrecision = real3
d2518 7
a2524 1
    else if ( lev == 1) then
d2526 11
a2536 3
       status = mls_SWrdfld( swid, trim(DF_Name), start(2:3), stride(2:3), &
            edge(2:3), real3(1,:,:), hdfVersion=hdfVersion )
       l2gp%l2gpValue = real3
d2538 7
a2544 3
       status = mls_SWrdfld( swid, trim(DF_Precision), start(2:3), stride(2:3), &
            edge(2:3), real3(1,:,:), hdfVersion=hdfVersion )
       l2gp%l2gpPrecision = real3
d2546 4
d2551 1
a2551 9

       status = mls_SWrdfld(swid,trim(DF_Name),start(3:3),stride(3:3),edge(3:3),&
         &   real3(1,1,:), hdfVersion=hdfVersion )
       l2gp%l2gpValue = real3

       status = mls_SWrdfld( swid, trim(DF_Precision), start(3:3), stride(3:3), edge(3:3), &
            real3(1,1,:), hdfVersion=hdfVersion )
       l2gp%l2gpPrecision = real3

a2552 2
    
    ! Read the data fields that are 1-dimensional
d2554 6
a2559 4
    l2gp%status = l2gp%MissingStatus ! l2gp%MissingValue ! So it has a value.
    if ( ReadingStatus ) &
      & status = mls_swrdfld( swid, 'Status',start(3:3),stride(3:3),edge(3:3),&
      & l2gp%status, hdfVersion=hdfVersion, dontfail=.true. )
d2561 4
a2564 5
    if ( HMOT == 'M' ) then
      status = mls_SWrdfld(swid, 'Quality', start(3:3), stride(3:3),&
        edge(3:3),realProf, hdfVersion=hdfVersion, dontfail=dontfail)
      l2gp%quality = realProf
    endif
d2566 4
a2569 4
    l2gp%Convergence = l2gp%MissingValue ! l2gp%MissingValue ! So it has a value.
    if ( ReadingConvergence ) &
      & status = mls_swrdfld( swid, 'Convergence',start(3:3),stride(3:3),edge(3:3),&
      & l2gp%convergence, hdfVersion=hdfVersion, dontfail=.true. )
d2571 4
a2574 5
    ! Deallocate local variables
    call Deallocate_test ( realProf, 'realProf', ModuleName )
    call Deallocate_test ( realSurf, 'realSurf', ModuleName )
    call Deallocate_test ( realFreq, 'realFreq', ModuleName )
    call Deallocate_test ( real3, 'real3', ModuleName )
d2576 3
a2578 12
    !  After reading, detach from HE5_SWath interface
    status = mls_SWdetach(swid, hdfVersion=hdfVersion)
    if (status == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &detach from swath interface after reading.', MLSFile=L2GPFile)
    !print*," leaving ReadL2GPData_hdf: first/last/read=",&
    !  firstprof,lastprof,myNumProfs
    ! Set numProfs if wanted
    if (present(numProfs)) numProfs=myNumProfs
    call MLSMessageCalls( 'pop' )
    !-----------------------------
  end subroutine ReadL2GPData_MF_hdf
  !-----------------------------
d2580 1
a2580 5
  !----------------------------------------  writeL2GPData_fileID  -----
  ! This subroutine is an amalgamation of the last three
  ! Should be renamed CreateAndWriteL2GPData
  subroutine writeL2GPData_fileID(l2gp, l2FileHandle, swathName, hdfVersion, &
    & notUnlimited)
d2582 8
a2589 1
    ! Arguments
d2591 1
a2591 6
    integer, intent(IN) :: l2FileHandle ! From swopen
    type (L2GPData_T), intent(INOUT) :: l2gp
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    integer, optional, intent(in) :: hdfVersion
    logical, optional, intent(in) :: notUnlimited
    ! Exectuable code
d2593 4
a2596 4
    ! Local
    integer :: myhdfVersion
    integer :: status
    type( MLSFile_T ) :: l2gpFile
d2598 53
a2650 5
    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L2GPDEFAULT_HDFVERSION
d2652 6
d2659 2
a2660 8
    status = InitializeMLSFile(l2gpFile, type=l_swath, access=DFACC_RDWR, &
      & content='l2gp', name='unknown', hdfVersion=myhdfVersion)
    l2gpFile%FileID%f_id = l2FileHandle
    l2gpFile%stillOpen = .true.
    call WriteL2GPData(l2gp, l2gpFile, &
    & swathName, notUnlimited)
  end subroutine writeL2GPData_fileID
  !-------------------------------------------------------------
d2662 1
a2662 3
  ! --------------------------------------  OutputL2GP_createFile_MF  -----
  subroutine OutputL2GP_createFile_MF (l2gp, L2GPFile, &
    & swathName, nLevels, notUnlimited, compressTimes)
d2664 19
a2682 5
  use HDFEOS5, only: HE5S_UNLIMITED_F
  use MLSHDFEOS, only: mls_swdetach, &
    & mls_swcreate, mls_dfldsetup, mls_gfldsetup, mls_swdefdim
    ! Brief description of subroutine
    ! This subroutine sets up the structural definitions in an empty L2GP file.
d2684 1
a2684 1
    ! Arguments
d2686 59
a2744 7
    type(MLSFile_T)                :: L2GPFile
    type( L2GPData_T ), intent(inout) :: l2gp
    character (LEN=*), optional, intent(IN) :: swathName ! Defaults to l2gp%swathName
    integer, optional, intent(in) :: nLevels
    logical, optional, intent(in) :: notUnlimited   !               as nTimes
    logical, optional, intent(in) :: compressTimes  ! don't store nTimesTotal
    ! Parameters
d2746 3
a2748 4
    character (len=*), parameter :: DIM_ERR = 'Failed to define dimension '
    character (len=*), parameter :: GEO_ERR = &
         & 'Failed to define geolocation field '
    character (len=*), parameter :: DAT_ERR = 'Failed to define data field '
d2750 3
a2752 1
    ! Variables
d2754 4
a2757 3
    character (len=480) :: MSR
    character (len=132) :: NAME   ! From l2gp%name
    character (len=32) :: MYDIM1, MYDIM12, MYDIM123
d2759 1
a2759 5
    ! THESE ARE HDF5 CHUNKS, _NOT_ MLS ALONG-TRACK PROCESSING CHUNKS 
    integer,dimension(7)::CHUNK_DIMS
    integer::CHUNK_RANK
    integer::CHUNKTIMES,CHUNKFREQS,CHUNKLEVELS
    integer :: hdfVersion
d2761 5
a2765 32
    integer :: SWID, STATUS
    logical :: myNotUnlimited
    logical :: mycompressTimes
    logical :: deebughere
    ! Executable
    deebughere = DEEBUG ! .or. .TRUE.
    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
    endif
    myNotUnlimited = .false.
    if ( present ( notUnlimited ) ) myNotUnlimited = notUnlimited
    mycompressTimes = .false.
    if ( present (compressTimes ) ) mycompressTimes = compressTimes
    hdfVersion = L2GPFile%hdfVersion
    
    ! Work out the chunking
    if ( myNotUnlimited ) then
      chunkTimes = max ( min ( MAXCHUNKTIMES, l2gp%nTimes ), 1 )
    else
      chunktimes = MAXCHUNKTIMES      ! was 1
    endif
    chunkfreqs = max ( l2gp%nFreqs, 1)
    if(present(nLevels))then
       chunklevels = nLevels
    else
      chunklevels = min(l2gp%nLevels, 500)     ! was .., 5)
      chunklevels = max(chunklevels, 1)
    endif
    
    ! Create the swath within the file
d2767 1
a2767 8
    if ( deebughere )  print *, 'About to sw_create ', TRIM(name)
    if ( deebughere )  print *, 'myNotUnlimited ', myNotUnlimited
    ! swid = mls_SWcreate(L2GPFile%FileID%f_id, trim(name), &
    swid = mls_SWcreate(L2GPFile, trim(name) )
    if ( swid == -1 ) then
       msr = 'Failed to create swath ' // TRIM(name) &
        & // ' (maybe has the same name as another swath in this file?)'
    end if
a2768 1
    ! Define dimensions
d2770 3
a2772 6
    if ( L2GPFile%hdfVersion == HDFVERSION_5 .and. .not. myNotUnlimited ) then
      ! Defining special "unlimited dimension called UNLIM
      ! print*,"Defined Unlim with size", HE5S_UNLIMITED_f
      ! status = HE5_SWdefdim(swid, UNLIM, HE5S_UNLIMITED_F)
      status = mls_swdefdim(swid, UNLIM, HE5S_UNLIMITED_F, &
        & hdfVersion=hdfVersion)
d2775 1
a2775 27
    if ( myNotUnlimited ) then
      myDim1 = DIM_NAME1
      myDim12 = DIM_NAME12
      myDim123 = DIM_NAME123
    else
      myDim1 = MAX_DIML1
      myDim12 = MAX_DIML12
      myDim123 = MAX_DIML123
    endif
    if ( DEEBUG ) then
      print *, 'myDim1 ', myDim1
      print *, 'myDim12 ', myDim12
      print *, 'myDim123 ', myDim123
      print *, 'nTimes ', l2gp%nTimes
      print *, 'nTimesTotal ', l2gp%nTimesTotal
      print *, 'nLevels ', l2gp%nLevels
      print *, 'nFreqs ', l2gp%nFreqs
    endif
    if ( mycompressTimes ) then
      status = mls_swdefdim(swid, 'nTimes', max(l2gp%nTimes,1), &
        & hdfVersion=hdfVersion)
    else
      status = mls_swdefdim(swid, 'nTimes', max(l2gp%nTimesTotal,1), &
        & hdfVersion=hdfVersion)
    endif
    status = mls_swdefdim(swid, 'nTimesTotal', max(l2gp%nTimesTotal,1), &
      & hdfVersion=hdfVersion)
d2777 18
a2794 4
    if ( l2gp%nLevels > 0 ) then
      status = mls_swdefdim(swid, 'nLevels', l2gp%nLevels, &
        & hdfVersion=hdfVersion)
    end if
d2796 9
a2804 4
    if ( l2gp%nFreqs > 0 ) then
      status = mls_swdefdim(swid, 'nFreqs', l2gp%nFreqs, &
        & hdfVersion=hdfVersion)
    end if
d2806 10
a2815 1
    ! Define horizontal geolocation fields using above dimensions
d2817 1
a2817 7
    chunk_rank=1
    chunk_dims=1
    chunk_dims(1)=CHUNKTIMES
    if ( deebughere )  print *, 'chunk_dims ', chunk_dims(1:chunk_rank)
    status = mls_gfldsetup(swid, 'Latitude', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2819 2
a2820 3
    status = mls_gfldsetup(swid, 'Longitude', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2822 3
a2824 3
    status = mls_gfldsetup(swid, 'Time', 'nTimes', MYDIM1, &
      & DFNT_FLOAT64, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, dFill=real(l2gp%MissingValue, r8))
d2826 3
a2828 3
    status = mls_gfldsetup(swid, 'LocalSolarTime', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2830 5
a2834 3
    status = mls_gfldsetup(swid, 'SolarZenithAngle', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2836 2
a2837 3
    status = mls_gfldsetup(swid, 'LineOfSightAngle', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2839 1
a2839 3
    status = mls_gfldsetup(swid, 'OrbitGeodeticAngle', 'nTimes', MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2841 1
a2841 3
    status = mls_gfldsetup(swid, 'ChunkNumber', 'nTimes', MYDIM1, &
      & DFNT_INT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, iFill=int(l2gp%MissingValue))
d2843 1
a2843 1
    if ( l2gp%nLevels > 0 ) then
d2845 2
a2846 4
      status = mls_gfldsetup(swid, 'Pressure', 'nLevels', MAX_DIML, &
      & DFNT_FLOAT32, HDFE_NOMERGE, 0, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
    end if
d2848 2
a2849 1
    if ( l2gp%nFreqs > 0 ) then
d2851 7
a2857 3
      status = mls_gfldsetup(swid, 'Frequency', 'nFreqs', MAX_DIML, &
      & DFNT_FLOAT32, HDFE_NOMERGE, 0, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2859 1
d2861 1
a2861 1
    ! Define data fields using above dimensions
d2863 3
a2865 3
    if ( (l2gp%nFreqs > 0) .and. (l2gp%nLevels > 0) ) then
       chunk_rank=3
       chunk_dims(1:3)=(/ CHUNKFREQS,CHUNKLEVELS,CHUNKTIMES /)
d2867 5
a2871 4
      status = mls_dfldsetup(swid, 'L2gpValue', 'nFreqs,nLevels,nTimes', &
      & MYDIM123, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2873 1
a2873 4
      status = mls_dfldsetup(swid, 'L2gpPrecision', 'nFreqs,nLevels,nTimes', &
      & MYDIM123, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2875 8
a2882 3
    else if ( l2gp%nLevels > 0 ) then
       chunk_rank=2
       chunk_dims(1:7)=(/ CHUNKLEVELS,CHUNKTIMES,37,38,39,47,49/)
d2884 20
a2903 4
      status = mls_dfldsetup(swid, 'L2gpValue', 'nLevels,nTimes', &
      & MYDIM12, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2905 1
a2905 4
      status = mls_dfldsetup(swid, 'L2gpPrecision', 'nLevels,nTimes', &
      & MYDIM12, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2907 3
a2909 3
    else
       chunk_rank=1
       chunk_dims(1)=CHUNKTIMES
d2911 5
a2915 4
      status = mls_dfldsetup(swid, 'L2gpValue', 'nTimes', &
      & MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2917 1
a2917 4
      status = mls_dfldsetup(swid, 'L2gpPrecision', 'nTimes', &
      & MYDIM1, &
      & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2919 8
a2926 1
    end if
d2928 12
a2939 8
    if ( deebughere )  print *, 'chunk_dims ', chunk_dims(1:chunk_rank)
    chunk_rank=1
    chunk_dims(1)=CHUNKTIMES
    if ( deebughere )  print *, 'chunk_dims ', chunk_dims(1:chunk_rank)
    status = mls_dfldsetup(swid, 'Status', 'nTimes', &
    & MYDIM1, &
    & DFNT_INT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
    & hdfVersion=hdfVersion, iFill=l2gp%MissingStatus)
d2941 15
a2955 7
    chunk_rank=1
    chunk_dims(1)=CHUNKTIMES
    if ( deebughere )  print *, 'chunk_dims ', chunk_dims(1:chunk_rank)
    status = mls_dfldsetup(swid, 'Quality', 'nTimes', &
    & MYDIM1, &
    & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
    & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2957 1
a2957 7
    chunk_rank=1
    chunk_dims(1)=CHUNKTIMES
    if ( deebughere )  print *, 'chunk_dims ', chunk_dims(1:chunk_rank)
    status = mls_dfldsetup(swid, 'Convergence', 'nTimes', &
    & MYDIM1, &
    & DFNT_FLOAT32, HDFE_NOMERGE, chunk_rank, chunk_dims, &
    & hdfVersion=hdfVersion, rFill=l2gp%MissingValue)
d2959 3
a2961 10
    ! Detach from the HE5_SWath interface.This stores the swath info within the
    ! file and must be done before writing or reading data to or from the
    ! swath. (May be un-necessary for HDF5 -- test program works OK without.)
    ! 
    status = mls_SWdetach(swid, hdfVersion=hdfVersion)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Failed to detach from swath interface after definition.', &
            & MLSFile=L2GPFile )
    end if
d2963 5
a2967 11
  !--------------------------------------
  end subroutine OutputL2GP_createFile_MF
  !--------------------------------------

  !-----------------------------------------  OutputL2GP_writeGeo_MF  -----
  subroutine OutputL2GP_writeGeo_MF (l2gp, L2GPFile, &
    & swathName,offset)

  use MLSHDFEOS, only: mls_swattach, mls_swdetach, mls_swwrfld
    ! Brief description of subroutine
    ! This subroutine writes the geolocation fields to an L2GP output file.
d2971 1
a2971 1
    type( L2GPData_T ), intent(inout) :: l2gp
d2973 5
a2977 3
    character (len=*), intent(IN), optional :: swathName ! Defaults->l2gp%name
    integer,intent(IN),optional::offset
    ! Parameters
d2979 4
a2982 2
    character (len=*), parameter :: WR_ERR = &
         & 'Failed to write geolocation field '
d2984 32
a3015 11
    ! Variables

    character (len=132) :: name ! Either swathName or l2gp%name
    
    integer :: status, swid,myOffset
    integer :: start(2), stride(2), edge(2)
    integer :: hdfVersion

    ! Begin
    if (present(offset)) then
       myOffset=offset
d3017 2
a3018 1
       myOffset=0
d3020 6
d3027 7
a3033 6
    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
    endif
    hdfVersion = L2GPFile%hdfVersion
d3035 2
a3036 1
    swid = mls_SWattach (L2GPFile, name)
d3038 4
a3041 1
    ! Write data to the fields
d3043 7
a3049 3
    stride = 1
    start = myOffset ! Please do not set to zero
    edge(1) = l2gp%nTimes
d3051 21
a3071 5
    if (DEEBUG) then
      call output( 'Writing geolocations', advance='yes' )
      call outputNamedValue( 'stride, start, edge', (/ stride(1), start(1), edge(1) /) )
      call outputNamedValue( 'shape(Geod. Angle', shape(l2gp%geodAngle) )
    endif
d3073 4
a3076 2
    status = mls_SWwrfld(swid, 'Latitude', start, stride, edge, &
         real(l2gp%latitude), hdfVersion=hdfVersion)
d3078 37
a3114 2
    status = mls_SWwrfld(swid, 'Longitude', start, stride, edge, &
         real(l2gp%longitude), hdfVersion=hdfVersion)
d3116 1
a3116 2
    status = mls_SWwrfld(swid, 'Time', start, stride, edge, &
         l2gp%time, hdfVersion=hdfVersion)
d3118 2
a3119 2
    status = mls_SWwrfld(swid, 'LocalSolarTime', start, stride, edge, &
        real(l2gp%solarTime), hdfVersion=hdfVersion)
d3121 17
a3137 2
    status = mls_SWwrfld(swid, 'SolarZenithAngle', start, stride, edge, &
         real(l2gp%solarZenith), hdfVersion=hdfVersion)
d3139 21
a3159 2
    status = mls_SWwrfld(swid, 'LineOfSightAngle', start, stride, edge, &
         real(l2gp%losAngle), hdfVersion=hdfVersion)
d3161 5
a3165 2
    status = mls_SWwrfld(swid, 'OrbitGeodeticAngle', start, stride, edge, &
         real(l2gp%geodAngle), hdfVersion=hdfVersion)
d3167 1
a3167 2
    status = mls_SWwrfld(swid, 'ChunkNumber', start, stride, edge, &
         l2gp%chunkNumber, hdfVersion=hdfVersion)
d3169 9
a3177 6
    if ( l2gp%nLevels > 0 ) then
       edge(1) = l2gp%nLevels
       start(1)=0 ! needed because offset may have made this /=0
       status = mls_SWwrfld(swid, 'Pressure', start, stride, edge, &
            real(l2gp%pressures), hdfVersion=hdfVersion)
    end if
d3179 1
a3179 6
    if ( l2gp%nFreqs > 0 ) then
       edge(1) = l2gp%nFreqs
       start(1)=0 ! needed because offset may have made this /=0
       status = mls_SWwrfld(swid, 'Frequency', start, stride, edge, &
            real(l2gp%frequency), hdfVersion=hdfVersion)
    end if
d3181 2
a3182 1
    ! Detach from the swath interface.  
d3184 10
a3193 5
    status = mls_SWdetach(swid, hdfVersion=hdfVersion)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach from swath interface', MLSFile=L2GPFile )
    end if
d3195 1
a3195 3
  !------------------------------------
  end subroutine OutputL2GP_writeGeo_MF
  !------------------------------------
d3197 1
a3197 3
  !----------------------------------------  OutputL2GP_writeData_MF  -----
  subroutine OutputL2GP_writeData_MF(l2gp, L2GPFile, &
    & swathName,offset)
d3199 1
a3199 6
  use MLSHDFEOS, only: mls_swattach, mls_swdetach, mls_swwrfld
    ! Brief description of subroutine
    ! This subroutine writes the data fields to an L2GP output file.
    ! For now, you have to write all of l2gp, but you can choose to write
    ! it at some offset into the file
    ! Arguments
d3201 1
a3201 5
    type( L2GPData_T ), intent(inout) :: l2gp
    type(MLSFile_T)                :: L2GPFile
    character (len=*), intent(IN), optional :: swathName ! Defaults->l2gp%name
    integer,intent(IN),optional::offset
    ! Parameters
d3203 4
a3206 1
    character (len=*), parameter :: WR_ERR = 'Failed to write data field '
d3208 13
a3220 1
    ! Variables
d3222 1
a3222 1
    character (len=132) :: name     ! Either swathName or l2gp%name
d3224 1
a3224 5
    integer :: status,myOffset
    integer :: start(3), stride(3), edge(3)
    integer :: swid
    integer :: hdfVersion
    
a3225 5
    ! Begin
    if (present(offset)) then
       myOffset=offset
    else
       myOffset=0
d3228 5
a3232 4
    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
d3234 14
a3247 1
    hdfVersion = L2GPFile%hdfVersion
d3249 3
a3251 1
    start = 0
d3253 37
a3289 8
    start(3)= myOffset ! Please do not set to zero
    edge(1) = l2gp%nFreqs
    edge(2) = l2gp%nLevels
    edge(3) = l2gp%nTimes
    if (DEEBUG) then
      call output( 'Writing data now', advance='yes' )
      call outputNamedValue( 'stride, start, edge', (/ stride(3), start(3), edge(3) /) )
      call outputNamedValue( 'shape(Geod. Angle', shape(l2gp%geodAngle) )
d3291 1
a3291 10
    swid = mls_SWattach (L2GPFile, name)
    if ( l2gp%nFreqs > 0 ) then
       ! Value and Precision are 3-D fields
       if (DEEBUG) print *, 'start, stride, edge ', start, stride, edge
       status = mls_SWwrfld(swid, 'L2gpValue', start, stride, edge, &
            & reshape(real(l2gp%l2gpValue), (/size(l2gp%l2gpValue)/)), &
            & hdfVersion=hdfVersion )
       status = mls_SWwrfld(swid, 'L2gpPrecision', start, stride, edge, &
            & reshape(real(l2gp%l2gpPrecision), (/size(l2gp%l2gpPrecision)/)), &
            & hdfVersion=hdfVersion )
d3293 1
a3293 9
    else if ( l2gp%nLevels > 0 ) then
       ! Value and Precision are 2-D fields
      
       if (DEEBUG) print *, 'start, stride, edge: ', start(2:3), stride(2:3), edge(2:3)
       status = mls_SWwrfld( swid, 'L2gpValue', start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpValue(1,:,:) ), hdfVersion=hdfVersion)
       status = mls_SWwrfld( swid, 'L2gpPrecision', start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpPrecision(1,:,:) ), hdfVersion=hdfVersion)
    else
d3295 3
a3297 7
       ! Value and Precision are 1-D fields
       if (DEEBUG) print *, 'start, stride, edge: ', start(3), stride(3), edge(3)
       status = mls_SWwrfld( swid, 'L2gpValue', start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpValue(1,1,:) ), hdfVersion=hdfVersion)
       status = mls_SWwrfld( swid, 'L2gpPrecision', start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpPrecision(1,1,:) ), hdfVersion=hdfVersion)
    end if
d3299 1
a3299 1
    ! 1-D status & quality fields
d3301 1
a3301 2
    status = mls_swwrfld(swid, 'Status', start(3:3), stride(3:3), edge(3:3), &
       &   l2gp%status, hdfVersion=hdfVersion, dontfail=.true.)
d3303 1
a3303 2
    status = mls_SWwrfld(swid, 'Quality', start(3:3), stride(3:3), edge(3:3), &
         real(l2gp%quality), hdfVersion=hdfVersion)
d3305 1
a3305 2
    status = mls_SWwrfld(swid, 'Convergence', start(3:3), stride(3:3), edge(3:3), &
         real(l2gp%convergence), hdfVersion=hdfVersion)
d3307 3
a3309 9
    !     Detach from the swath interface.
    status = mls_SWdetach(swid, hdfVersion=hdfVersion)
    if(DEEBUG) print *, 'Detached from swid ', swid
    if(DEEBUG) print *, 'file handle ', L2GPFile%FileID%f_id
    if(DEEBUG) print *, 'status ', status
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach from swath interface', MLSFile=L2GPFile )
    end if
d3311 1
d3313 1
a3313 3
  !-------------------------------------
  end subroutine OutputL2GP_writeData_MF
  !-------------------------------------
d3315 1
a3315 2
  !----------------------------------------  OutputL2GP_attributes_MF  -----
  subroutine OutputL2GP_attributes_MF(l2gp, L2GPFile, swathName)
d3317 3
a3319 13
  use HDFEOS5, only: HE5T_NATIVE_INT, HE5T_NATIVE_REAL, HE5T_NATIVE_DOUBLE, &
    & MLS_charType
  use he5_swapi, only: he5_swwrattr, he5_swwrlattr
  use MLSHDFEOS, only: mls_swattach, mls_swdetach, mls_swwrattr, mls_swwrlattr
  use PCFHdr, only:  he5_writeglobalattr
    ! Brief description of subroutine
    ! This subroutine writes the attributes for an l2gp
    ! These include
    ! Global attributes which are file level
    ! Swath level
    ! Geolocation field attributes
    ! Data field attributes
    ! Arguments
d3321 3
a3323 4
    type( L2GPData_T ), intent(inout) :: l2gp
    type(MLSFile_T)                :: L2GPFile
    character (len=*), intent(IN), optional :: swathName ! Defaults->l2gp%name
    ! Parameters
d3325 1
a3325 3
    character (len=*), parameter :: WR_ERR = 'Failed to write attribute field '
    character (len=*), parameter :: NOUNITS = 'NoUnits'
    ! Variables
d3327 71
a3397 24
    character (len=132) :: name     ! Either swathName or l2gp%name
    ! The following pair of string list encode the Units attribute
    ! corresponding to each Title attribute; e.g., the Units for Latitude is deg
    character (len=*), parameter :: GeolocationTitles = &
      & 'Latitude,Longitude,Time,LocalSolarTime,SolarZenithAngle,' // &
      & 'LineOfSightAngle,OrbitGeodeticAngle,ChunkNumber,Pressure,Frequency'
    character (len=*), parameter :: GeolocationUnits = &
      & 'deg,deg,s,h,deg,' // &
      & 'deg,deg,NoUnits,hPa,GHz'
    character (len=*), parameter :: GeoUniqueFieldDefinition = &
      & 'HMT,HMT,AS,HMT,HMT,' // &
      & 'M,M,M,AS,M'   ! These are abbreviated values
    character (len=*), parameter :: UniqueFieldDefKeys = &
      & 'HM,HMT,MT,AS,M'
    character (len=*), parameter :: UniqueFieldDefValues = &
      & 'HIRDLS-MLS-Shared,HIRDLS-MLS-TES-Shared,MLS-TES-Shared,' // &
      & 'Aura-Shared,MLS-Specific'  ! Expanded values
    ! The following associate UniqueFieldDefs with species names
    character (len=*), parameter :: Species = &
      & 'Temperature,BrO,CH3CN,CO,ClO,GPH,HCl,HCN,H2O,H2O2,' // &
      & 'HNO3,HOCl,HO2,N2,N2O,OH,O2,O3,RHI,SO2'
    character (len=*), parameter :: SpUniqueFieldDefinition = &
      & 'HMT,M,M,MT,M,M,M,M,HMT,M,' // &
      & 'HMT,M,M,M,HM,M,M,HMT,M,M'   ! These are abbreviated values
d3399 2
a3400 9
    character(len=CHARATTRLEN) :: abbr_uniq_fdef
    ! logical, parameter :: DEEBUG = .false.
    character(len=CHARATTRLEN) :: expnd_uniq_fdef
    integer :: field
    character(len=CHARATTRLEN) :: field_name
    logical :: isColumnAmt
    logical :: isTPPressure
    integer :: rgp_type
    character(len=CHARATTRLEN) :: species_name ! Always lower case
d3402 61
a3462 6
    integer :: swid
    character(len=CHARATTRLEN) :: temp_name
    character(len=CHARATTRLEN), dimension(NumGeolocFields) :: theTitles
    character(len=CHARATTRLEN), dimension(NumGeolocFields) :: theUnits
    character(len=CHARATTRLEN) :: units_name
    ! Begin
d3468 15
a3482 5
    if ( DEEBUG ) print *, 'About to wr attrs to: ', trim(name)
    if ( rgp == r4 ) then
      rgp_type = HE5T_NATIVE_REAL
    elseif ( rgp == r8 ) then
      rgp_type = HE5T_NATIVE_DOUBLE
d3484 2
a3485 3
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & 'Attributes have unrecognized numeric data type; should be r4 or r8', &
        & MLSFile=L2GPFile)
d3487 2
a3488 2
    call List2Array(GeolocationTitles, theTitles, .true.)
    call List2Array(GeolocationUnits, theUnits, .true.)
d3490 8
a3497 2
    ! - -   G l o b a l   A t t r i b u t e s   - -
    call he5_writeglobalattr(L2GPFile%fileID%f_id)
d3499 1
a3499 39
    swid = mls_SWattach (L2GPFile, name)
    
    !   - -   S w a t h   A t t r i b u t e s   - -
    status = he5_swwrattr(swid, trim(l2gp%verticalCoordinate), &
      & rgp_type, size(l2gp%pressures), &
      & l2gp%pressures)
    field_name = l2gp%verticalCoordinate ! 'Pressure'
    status = mls_swwrattr(swid, 'VerticalCoordinate', MLS_CHARTYPE, 1, &
      & field_name)
    if ( SWATHLEVELMISSINGVALUE ) &
      & status = he5_swwrattr(swid, 'MissingValue', rgp_type, 1, &
      & (/ real(l2gp%MissingValue, rgp) /) )
    
    !   - -   G e o l o c a t i o n   A t t r i b u t e s   - -
    if ( DEEBUG ) print *, 'About to wr loc attrs to: ', trim(name)
    do field=1, NumGeolocFields
      ! Take care not to write attributes to "missing fields"
      if ( trim(theTitles(field)) == 'Frequency' &
        & .and. l2gp%nFreqs < 1 ) then
        field_name = ''
      elseif ( trim(theTitles(field)) == 'Pressure' &
        & .and. l2gp%nLevels < 1 ) then
        field_name = ''
      else
        field_name = theTitles(field)
        if ( trim(theTitles(field)) == 'Pressure' ) &
          & field_name = l2gp%verticalCoordinate
        call GetHashElement (GeolocationTitles, &
          & GeoUniqueFieldDefinition, trim(theTitles(field)), &
          & abbr_uniq_fdef, .false.)
        call GetHashElement (UniqueFieldDefKeys, &
          & UniqueFieldDefValues, trim(abbr_uniq_fdef), &
          & expnd_uniq_fdef, .false.)
        if ( DEEBUG ) print *, 'Field Title ', trim(theTitles(field))
        status = mls_swwrlattr(swid, trim(theTitles(field)), 'Title', &
          & MLS_CHARTYPE, 1, theTitles(field))
        if ( DEEBUG ) print *, 'Units ', trim(theUnits(field))
        status = mls_swwrlattr(swid, trim(theTitles(field)), 'Units', &
          & MLS_CHARTYPE, 1, theUnits(field))
d3501 25
a3525 49
        if ( trim(theTitles(field)) == 'Time' ) then
          status = he5_swwrlattr(swid, trim(theTitles(field)), &
            & 'MissingValue', &
            & HE5T_NATIVE_DOUBLE, 1, (/ real(l2gp%MissingValue, r8) /) )
        elseif ( trim(theTitles(field)) == 'ChunkNumber' ) then
          status = he5_swwrlattr(swid, trim(theTitles(field)), &
            & 'MissingValue', &
            & HE5T_NATIVE_INT, 1, (/ int(l2gp%MissingValue) /) )
        else
          status = he5_swwrlattr(swid, trim(theTitles(field)), &
            & 'MissingValue', &
            & rgp_type, 1, (/ real(l2gp%MissingValue, rgp) /) )
        endif
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
         & "Unable to write local attribute to " // trim(theTitles(field)) )
        if ( DEEBUG ) print *, 'Uniquefielddef ', trim(expnd_uniq_fdef)
        status = mls_swwrlattr(swid, trim(theTitles(field)), &
          & 'UniqueFieldDefinition', &
          & MLS_CHARTYPE, 1, expnd_uniq_fdef)
        ! print *, 'status : ', status
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
         & "Unable to write local attribute to " // trim(theTitles(field)) )
      endif
    enddo
    if ( DEEBUG ) print *, 'Data'
    !   - -   D a t a   A t t r i b u t e s   - -
    ! call GetQuantityAttributes ( l2gp%quantityType, &
    !  & units_name, expnd_uniq_fdef)
    field_name = Name
    species_name = lowercase(name)
    ! The following special cases are handled by crude, despicable hacks
    ! It would be better to check on the quantity type, but paw hasn't
    ! succeeded in getting that to work properly and reliably
    isColumnAmt = ( index(species_name, 'column') > 0 )
    isTPPressure = ( index(species_name, 'tpp') > 0 )
    if ( isColumnAmt ) then
      ! This next failed sometimes
      temp_name = species_name
      call ExtractSubString(Name, species_name, 'column', 'wmo')
      if ( species_name == ' ' ) species_name=temp_name
      ! So we'll try another tack:
      temp_name = species_name
      call ReplaceSubString ( temp_name, species_name, 'column', '' )
      if ( species_name == ' ' ) species_name=temp_name
      temp_name = species_name
      call GetStringElement( temp_name, species_name, &
        & 1, countEmpty=.true., inseparator='-' )
      if ( species_name == ' ' ) species_name=temp_name
      ! Hopefully by now we've turned species_name into one of the species
d3527 6
a3532 31
    if ( DEEBUG ) &
      & print *, 'full name: ', trim(name), ' Species: ', trim(species_name)
    call GetHashElement (lowercase(Species), &
      & SpUniqueFieldDefinition, trim(species_name), &
      & abbr_uniq_fdef, .false.)
    call GetHashElement (UniqueFieldDefKeys, &
      & UniqueFieldDefValues, trim(abbr_uniq_fdef), &
      & expnd_uniq_fdef, .false.)
    if ( expnd_uniq_fdef == '' .or. expnd_uniq_fdef == ',' ) &
      & expnd_uniq_fdef = 'MLS-Specific'
    select case (trim(lowercase(species_name)))
    case ('temperature')
      units_name = 'K'
    case ('gph')
      units_name = 'm'
    case ('rhi')
      units_name = '%rhi'
    case default
      units_name = 'vmr'
    end select
    if ( isColumnAmt ) then
      ! units_name = 'DU'
      if ( DEEBUG ) &
        & call dump( .true., col_species_keys, col_species_hash, &
        & 'column species units' )
      call GetHashElement (col_species_keys, &
      & col_species_hash, trim(lowercase(species_name)), &
      & units_name, .true.)
      if ( DEEBUG ) &
      & print *, 'units_name: ', trim(units_name)
      if ( units_name == ',' ) units_name = 'molcm2'
d3534 2
a3535 22
    if ( isTPPressure ) units_name = 'hPa'
    if ( DEEBUG ) print *, 'Title ', trim(field_name)
    status = mls_swwrlattr(swid, 'L2gpValue', 'Title', &
      & MLS_CHARTYPE, 1, field_name)
    if ( DEEBUG ) print *, 'Units ', trim(units_name)
    status = mls_swwrlattr(swid, 'L2gpValue', 'Units', &
      & MLS_CHARTYPE, 1, units_name)
    status = he5_swwrlattr(swid, 'L2gpValue', 'MissingValue', &
      & rgp_type, 1, (/ real(l2gp%MissingValue, rgp) /) )
    if ( DEEBUG ) print *, 'Title ', trim(expnd_uniq_fdef)
    status = mls_swwrlattr(swid, 'L2gpValue', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, expnd_uniq_fdef)
    status = mls_swwrlattr(swid, 'L2gpPrecision', 'Title', &
      & MLS_CHARTYPE, 1, trim(field_name)//'Precision')
    status = mls_swwrlattr(swid, 'L2gpPrecision', 'Units', &
      & MLS_CHARTYPE, 1, units_name)
    status = he5_swwrlattr(swid, 'L2gpPrecision', 'MissingValue', &
      & rgp_type, 1, (/ real(l2gp%MissingValue, rgp) /) )
    status = mls_swwrlattr(swid, 'L2gpPrecision', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, expnd_uniq_fdef)
d3537 4
a3540 7
    ! ('Status' data field newly written)
    status = mls_swwrlattr(swid, 'Status', 'Title', &
      & MLS_CHARTYPE, 1, trim(field_name)//'Status')
    status = mls_swwrlattr(swid, 'Status', 'Units', &
      & MLS_CHARTYPE, 1, NOUNITS)
    status = he5_swwrlattr(swid, 'Status', 'MissingValue', &
      & HE5T_NATIVE_INT, 1, (/ l2gp%MissingStatus /) )
d3542 3
a3544 28
    status = mls_swwrlattr(swid, 'Status', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, 'MLS-Specific')
    
    status = mls_swwrlattr(swid, 'Quality', 'Title', &
      & MLS_CHARTYPE, 1, trim(field_name)//'Quality')
    status = mls_swwrlattr(swid, 'Quality', 'Units', &
      & MLS_CHARTYPE, 1, NOUNITS)
    status = he5_swwrlattr(swid, 'Quality', 'MissingValue', &
      & rgp_type, 1, (/ real(l2gp%MissingValue, rgp) /) )
    status = mls_swwrlattr(swid, 'Quality', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, 'MLS-Specific')
    
    status = mls_swwrlattr(swid, 'Convergence', 'Title', &
      & MLS_CHARTYPE, 1, trim(field_name)//'Convergence')
    status = mls_swwrlattr(swid, 'Convergence', 'Units', &
      & MLS_CHARTYPE, 1, NOUNITS)
    status = he5_swwrlattr(swid, 'Convergence', 'MissingValue', &
      & rgp_type, 1, (/ real(l2gp%MissingValue, rgp) /) )
    status = mls_swwrlattr(swid, 'Convergence', &
      & 'UniqueFieldDefinition', &
      & MLS_CHARTYPE, 1, 'MLS-Specific')
    
    status = mls_SWdetach(swid, hdfVersion=HDFVERSION_5)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach  from swath interface', MLSFile=L2GPFile )
d3547 9
d3557 3
a3559 3
  !-------------------------------------
  end subroutine OutputL2GP_attributes_MF
  !-------------------------------------
d3561 3
a3563 2
  !----------------------------------------  SetL2GP_aliases_MF  -----
  subroutine SetL2GP_aliases_MF(l2gp, L2GPFile, swathName)
d3565 3
a3567 49
  use HDFEOS5, only: HE5_SWSETALIAS
  use MLSHDFEOS, only: mls_swattach, mls_swdetach
  use SDPToolkit, only: PGS_S_SUCCESS
    ! Arguments
    type(MLSFile_T)                :: L2GPFile
    type (L2GPData_T), intent(INOUT) :: l2gp
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    
    ! Brief description of subroutine
    ! This subroutine creates an alias for each of the two data fields
    ! TYPE2FIELDNAME and TYPE2PRECISIONNAME
    ! Local variables
    character (len=132) :: name     ! Either swathName or l2gp%name
    character(len=*), parameter :: TYPE2FIELDNAME = 'L2gpValue'
    character(len=*), parameter :: TYPE2PRECISIONNAME = 'L2gpPrecision'
    integer :: returnStatus
    integer :: sw_id
    ! Executable
    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
    endif
    sw_id = mls_swattach(L2GPFile, trim(name))
    if ( sw_id < 1 ) then 
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & "Error in attaching swath for setting alias.", MLSFile=L2GPFile )
    end if
    returnStatus = he5_SWsetalias(sw_id, TYPE2FIELDNAME, trim(name))
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & "Error in setting alias from " // TYPE2FIELDNAME // &
          & ' to ' // trim(name), MLSFile=L2GPFile )
    end if
    returnStatus = he5_SWsetalias(sw_id, TYPE2PRECISIONNAME, &
     & trim(name) // 'Precision')
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & "Error in setting alias from " // TYPE2PRECISIONNAME // &
          & ' to ' // trim(name) // 'Precision', MLSFile=L2GPFile )
    end if
    returnStatus = mls_SWdetach(sw_id, hdfVersion=HDFVERSION_5)
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & "Error in detaching swath for setting alias.", MLSFile=L2GPFile )
    end if
  !-------------------------------------
  end subroutine SetL2GP_aliases_MF
  !-------------------------------------
d3569 3
a3571 5
  !----------------------------------------  writeL2GPData_MLSFile  -----
  ! This subroutine is an amalgamation of the last three
  ! Should be renamed CreateAndWriteL2GPData
  subroutine writeL2GPData_MLSFile(l2gp, L2GPFile, swathName, &
    & notUnlimited)
d3573 3
a3575 1
    ! Arguments
d3577 14
a3590 8
    type(MLSFile_T)                :: L2GPFile
    type (L2GPData_T), intent(INOUT) :: l2gp
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    logical, optional, intent(in) :: notUnlimited
    ! Local
    logical :: alreadyOpen
    integer :: status
    ! Executable code
d3592 1
a3592 24
    call MLSMessageCalls( 'push', constantName='writeL2GPData_MLSFile' )
    status = 0
    alreadyOpen = L2GPFile%stillOpen
    if ( .not. alreadyOpen ) then
      call mls_openFile(L2GPFile, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l2gp file', MLSFile=L2GPFile)
    endif
    if ( L2GPFile%access == DFACC_RDONLY )  &
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'l2gp file is rdonly', MLSFile=L2GPFile)
    call OutputL2GP_createFile_MF (l2gp, L2GPFile, &
      & swathName, notUnlimited=notUnlimited)
    call OutputL2GP_writeGeo_MF (l2gp, L2GPFile, &
      & swathName)
    call OutputL2GP_writeData_MF (l2gp, L2GPFile, &
      & swathName)
    if (L2GPFile%hdfVersion == HDFVERSION_5) then
      if ( DEEBUG ) print *, 'Outputting attributes'
      call OutputL2GP_attributes_MF (l2gp, L2GPFile, swathName)
      if ( DEEBUG ) print *, 'Setting aliases'
      call SetL2GP_aliases_MF (l2gp, L2GPFile, swathName)
    endif
d3594 4
a3597 6
    if ( .not. alreadyOpen )  call mls_closeFile(L2GPFile, Status)
    L2GPFile%errorCode = status
    L2GPFile%lastOperation = 'write'
    call MLSMessageCalls( 'pop' )
  end subroutine writeL2GPData_MLSFile
  !-------------------------------------------------------------
d3599 1
a3599 9
  subroutine AppendL2GPData_fileID(l2gp, l2FileHandle, &
    & swathName, offset, lastProfile, TotNumProfs, hdfVersion, &
    & createSwath)
    ! sticks l2gp into the swath swathName in the file pointed at by
    ! l2FileHandle,starting at the profile number "offset" (First profile
    ! in the file has offset==0). If this runs off the end of the swath, 
    ! it is lengthened automagically. 
    ! This call has been altered recently, so that it can be used to create
    ! a swath as well as adding to one. 
d3601 3
a3603 1
    ! Arguments
d3605 4
a3608 1
    integer, intent(IN) :: l2FileHandle ! From swopen
d3610 4
a3613 22
    ! This is a L2GPData_T structure containing all the data to be written
    type (L2GPData_T), intent(INOUT) :: l2gp
    ! This is the name the swath is given in the file. By default it is
    ! the name contained in l2gp
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    ! This (offset) is the point in the swath at which the data is written. 
    ! First profile in the file has offset==0. If the swath in the file is 
    ! shorter than offset + ( num of profiles in l2gp) then it grows by magic
    integer, intent(IN), optional::offset
    ! TotNumProfs is a new argument. It seems only to be used if we are 
    ! creating a swath, rather than adding to one. In that case I guess
    ! it is the total number of profiles in the swath created. I also 
    ! guess that this is done so that we can avoid growing and re-growing 
    ! the swath.
    integer, intent(IN), optional::TotNumProfs
    integer, intent(IN), optional::lastProfile
    integer, optional, intent(in) :: hdfVersion ! better be 4 or 5!
    logical, intent(in), optional :: createSwath
    ! Local
    integer :: myhdfVersion
    integer :: status
    type( MLSFile_T ) :: l2gpFile
d3615 3
a3617 14
    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L2GPDEFAULT_HDFVERSION
    endif
    status = InitializeMLSFile(l2gpFile, type=l_swath, access=DFACC_RDWR, &
      & content='l2gp', name='unknown', hdfVersion=myhdfVersion)
    l2gpFile%FileID%f_id = l2FileHandle
    l2gpFile%stillOpen = .true.
    
    call AppendL2GPData(l2gp, l2gpFile, &
    & swathName, offset, lastProfile, TotNumProfs, createSwath)
  end subroutine AppendL2GPData_fileID
d3619 4
a3622 1
  ! ---------------------- AppendL2GPData_fileName  ---------------------------
d3624 4
a3627 3
  subroutine AppendL2GPData_fileName(l2gp, fileName, &
    & swathname, offset, lastProfile, TotNumProfs, hdfVersion)
    !------------------------------------------------------------------------
d3629 3
a3631 3
    ! Given a file name,
    ! This routine does an append operation (see AppendL2GPData_fileID)
    ! If the file doesn't exist yet, hopefully, it'll create it
d3633 4
a3636 1
    ! Arguments
d3638 4
a3641 8
    character (len=*), intent(in) :: fileName ! Name of swath
    type( l2GPData_T ), intent(inout) :: l2gp ! Result
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    integer,intent(IN),optional :: offset
    integer, intent(IN), optional::lastProfile
    integer,intent(IN),optional :: TotNumProfs
    integer, optional, intent(in) :: hdfVersion
    ! logical, optional, intent(in) :: clean   ! Not implemented yet
d3643 1
a3643 16
    ! Local
    integer :: L2FileHandle
    integer :: record_length
    integer :: status
    integer :: the_hdfVersion
    logical :: myClean
    logical :: file_exists
    integer :: file_access
    
    ! Executable code
    myClean = .false.
    ! if ( present(clean) ) myClean = clean
    file_exists = ( mls_exists(trim(FileName)) == 0 )
    the_hdfVersion = L2GPDEFAULT_HDFVERSION
    if ( present(hdfVersion) ) the_hdfVersion = hdfVersion
    if ( the_hdfVersion == WILDCARDHDFVERSION ) then
d3645 8
d3654 7
a3660 32
      ! Does the file exist, yet?
      if ( .not. file_exists ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File not found; make sure the name and path are correct' &
          & // trim(fileName) )
      endif
      the_hdfVersion = mls_hdf_version(FileName, hdfVersion)
      if ( the_hdfVersion == FILENOTFOUND ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File not found; make sure the name and path are correct' &
          & // trim(fileName) )
    endif
    if ( file_exists ) then
      file_access = DFACC_RDWR
    else
      file_access = DFACC_CREATE
    endif
    L2FileHandle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, file_access, FileName=FileName, &
       & hdfVersion=the_hdfVersion, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(FileName) // ' for appending')
    call AppendL2GPData_fileID(l2gp, L2FileHandle, swathname, &
      & offset, lastProfile=lastProfile, totNumProfs=totNumProfs, &
      & hdfVersion=the_hdfVersion)
    status = mls_io_gen_closeF(l_swath, L2FileHandle, FileName=FileName, &
      & hdfVersion=the_hdfVersion)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(FileName) // ' after appending')
  end subroutine AppendL2GPData_fileName
d3662 7
a3668 1
  ! ---------------------- AppendL2GPData_MLSFile  ---------------------------
d3670 10
a3679 9
  subroutine AppendL2GPData_MLSfile(l2gp, l2gpFile, &
    & swathName, offset, lastProfile, TotNumProfs, &
    & createSwath)
    ! sticks l2gp into the swath swathName in the file pointed at by
    ! l2FileHandle,starting at the profile number "offset" (First profile
    ! in the file has offset==0). If this runs off the end of the swath, 
    ! it is lengthened automagically. 
    ! This call has been altered recently, so that it can be used to create
    ! a swath as well as adding to one. 
d3681 3
a3683 2
  use MLSHDFEOS, only: mls_swattach, mls_swdetach
    ! Arguments
d3685 3
a3687 1
    type(MLSFile_T)                :: L2GPFile
d3689 3
a3691 949
    ! This is a L2GPData_T structure containing all the data to be written
    type (L2GPData_T), intent(INOUT) :: l2gp
    ! This is the name the swath is given in the file. By default it is
    ! the name contained in l2gp
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    ! This (offset) is the point in the swath at which the data is written. 
    ! First profile in the file has offset==0. If the swath in the file is 
    ! shorter than offset + ( num of profiles in l2gp) then it grows by magic
    integer, intent(IN), optional::offset
    ! TotNumProfs is a new argument. It seems only to be used if we are 
    ! creating a swath, rather than adding to one. In that case I guess
    ! it is the total number of profiles in the swath created. I also 
    ! guess that this is done so that we can avoid growing and re-growing 
    ! the swath.
    integer, intent(IN), optional::TotNumProfs
    integer, intent(IN), optional::lastProfile
    logical, intent(in), optional :: createSwath
    ! Local
    integer :: actual_ntimes
    logical :: alreadyOpen
    integer :: numProfs
    integer :: status
    logical :: swath_exists
    integer :: swathid
    integer :: myLastProfile
    character (len=L2GPNameLen) :: myswathName
    type (L2GPData_T) :: totall2gp

    ! Executable code
    call MLSMessageCalls( 'push', constantName='AppendL2GPData_MLSFile' )
    status = 0

    if (present(lastProfile)) then
      myLastProfile = lastProfile 
    elseif (present(TotNumProfs)) then
      myLastProfile = TotNumProfs 
    else
      myLastProfile = L2GP%nTimesTotal
    endif
    alreadyOpen = L2GPFile%stillOpen
    if ( .not. alreadyOpen ) then
      if ( DEEBUG ) print *, 'Needed to open file ', trim(L2GPFile%name)
      call mls_openFile(L2GPFile, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l2gp file', MLSFile=L2GPFile)
    endif
    if ( L2GPFile%access == DFACC_RDONLY )  &
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'l2gp file is rdonly', MLSFile=L2GPFile)
    myswathName = l2gp%name
    if ( present(swathName) ) myswathName = swathName
    
    if ( present(createSwath) ) then
      swath_exists = .not. createSwath
    else
      swathid = mls_swattach(L2GPFile, trim(myswathName), &
        & DONTFAIL=.true.)
      swath_exists = ( swathid > 0 )
      if ( swath_exists ) then
        status = mls_swdetach(swathid, hdfVersion=l2gpfile%hdfVersion)
        if ( status /= 0 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, & 
          & 'Failed to detach from swath in AppendL2GPData_fileID', MLSFile=L2GPFile)
      endif
    endif

    if ( swath_exists ) then
      if(DEEBUG) print *, 'OK, swath already exists'
      ! We must guard against a bug in HDF-EOS that prevents appending more
      ! profiles to a swath than already exist
      call ReadL2GPData( L2GPFile, myswathName, totall2gp, numProfs )
      if ( l2gp%nTimes > numProfs ) then
        if(DEEBUG) call outputNamedValue( 'current', totall2gp%nTimes )
        if(DEEBUG) call outputNamedValue( 'needed', l2gp%nTimes )
        call ExpandL2GPDataInPlace( totall2gp, l2gp%nTimes )
        if(DEEBUG) call outputNamedValue( 'expanded', totall2gp%nTimes )
        call ExpandL2GPDataInFile( L2GPFile, myswathName, totall2gp )
      endif
      call DestroyL2GPContents ( totall2gp )
    else
      ! Must create swath in file w/o disturbing other swaths
      if(DEEBUG) print *, 'Must create swath'
      if(DEEBUG) print *, 'Will have ', myLastProfile, ' profiles'
      if(DEEBUG) print *, 'instead of ', l2gp%nTimes, ' profiles'
      actual_ntimes = l2gp%nTimes
      ! if ( present(TotNumProfs) ) l2gp%nTimes = TotNumProfs
      select case (L2GPFile%hdfVersion)
      case (HDFVERSION_4)
        ! Currently force unlimited, remove the .false. .and. to allow limited
        if ( present(TotNumProfs) ) l2gp%nTimes = TotNumProfs
        call OutputL2GP_createFile_MF (l2gp, L2GPFile, &
          & myswathName, notUnlimited=.false. .and. present(totNumProfs))
        l2gp%nTimes = actual_ntimes
      case (HDFVERSION_5)
        ! By default allow limited; 
        ! may force unlimited by setting avoidUnlimitedDims to FALSE
        ! if ( present(TotNumProfs) ) l2gp%nTimes = TotNumProfs
        call OutputL2GP_createFile_MF (l2gp, L2GPFile, &
          & myswathName,&
          & notUnlimited=(avoidUnlimitedDims .and. present(totNumProfs)) )
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
         & 'Illegal hdf version in AppendL2GPData_MLSFile', MLSFile=L2GPFile)
      end select
      ! l2gp%nTimes = actual_ntimes
    endif

    if(DEEBUG) then
      if ( present(offset) ) then
        print*,"offset=",offset,"myLastProfile=",myLastProfile,&
        "size(l2gp%l2gpValue,3)=",size(l2gp%l2gpValue,3)
      else
        print*,"no offset; myLastProfile=",myLastProfile,&
        "size(l2gp%l2gpValue,3)=",size(l2gp%l2gpValue,3)
      endif
    endif
    if ( size(l2gp%l2gpValue,3) == 0 ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & "No profiles in this chunk", MLSFile=L2GPFile )

    else
      call OutputL2GP_writeGeo_MF (l2gp, l2GPFile, &
        & myswathName, offset)
      call OutputL2GP_writeData_MF (l2gp, l2GPFile, &
        & myswathName, offset)
      select case ( L2GPFile%HDFVersion )
      case ( HDFVERSION_4 )
      case ( HDFVERSION_5 )
        if ( .not. swath_exists .and. APPENDSWRITEATTRIBUTES) then
          call OutputL2GP_attributes_MF (l2gp, l2GPFile, swathName)
          call SetL2GP_aliases_MF (l2gp, l2GPFile, swathName)
        end if
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Unrecognized hdfVersion passed to AppendL2GPData", MLSFile=L2GPFile )
      end select
      ! l2gp%nTimes = actual_ntimes
    end if
    
    if (DEEBUG) then
      call ReadL2GPData( L2GPFile, myswathName, totall2gp, numProfs )
      call outputNamedValue( 'numProfs', numProfs )
      call outputNamedValue( 'total numProfs', totall2gp%nTimes )
      call DestroyL2GPContents ( totall2gp )
    endif

    if ( .not. alreadyOpen )  call mls_closeFile(L2GPFile, Status)
    L2GPFile%errorCode = status
    L2GPFile%lastOperation = 'append'
    call MLSMessageCalls( 'pop' )
  end subroutine AppendL2GPData_MLSFile

  ! ---------------------- cpL2GPData_fileID  ---------------------------

  subroutine cpL2GPData_fileID(file1, file2, swathList, &
    & hdfVersion1, hdfVersion2, notUnlimited, rename, ReadStatus, &
    & HGrid, rFreqs, rLevels, rTimes, options)
    !------------------------------------------------------------------------

    ! Given file names file1 and file2,
    ! This routine copies swathList from 1 to 2
    ! and, depending on options, makes some repairs

    use HGridsDatabase, only: HGrid_T
    ! Arguments

    integer, intent(in)           :: file1 ! handle of file 1
    integer, intent(in)           :: file2 ! handle of file 2
    character (len=*), intent(in) :: swathList ! copy only these; no wildcard
    integer, intent(in)           :: hdfVersion1
    integer, intent(in)           :: hdfVersion2
    logical, optional, intent(in) :: notUnlimited
    logical, optional, intent(in) :: ReadStatus
    character (len=*), optional, intent(in) :: rename
    type (HGrid_T), optional, intent(in)    :: HGrid
    integer, dimension(2), intent(in), optional :: rFreqs  ! subscript range
    integer, dimension(2), intent(in), optional :: rLevels ! subscript range
    integer, dimension(2), intent(in), optional :: rTimes  ! subscript range
    character (len=*), optional, intent(in) :: options ! E.g., '-v'

    ! Local variables
    logical, parameter            :: countEmpty = .true.
    integer :: i
    type (L2GPData_T) :: l2gp
    type (L2GPData_T) :: reducedl2gp
    integer, dimension(2) :: myFreqs  ! subscript range
    integer, dimension(2) :: myLevels ! subscript range
    integer, dimension(2) :: myTimes  ! subscript range
    character (len=8) :: myOptions
    integer :: noSwaths
    logical :: renameSwaths
    logical :: repair
    character (len=L2GPNameLen) :: swath
    character (len=L2GPNameLen) :: swath2
    logical :: verbose
    
    ! Executable code
    myOptions = ' '
    if ( present(options) ) myOptions = options
    verbose = ( index(myOptions, 'v') > 0 )
    repair  = ( index(myOptions, 'r') > 0 )
    renameSwaths  = present(rename)
    if ( renameSwaths ) renameSwaths = ( rename /= ' ' )
    if ( repair .and. .not. present(HGrid) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'cpL2GPFile must be given HGrid to repair L2GPData' )
    if ( .not. repair .and. present(HGrid) ) &
      & call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'cpL2GPFile was given HGrid but no order to repair L2GPData' )
    noSwaths = NumStringElements(trim(swathList), countEmpty)
    if ( noSwaths < 1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'No swaths cp to file--unable to count swaths in ' // trim(swathList) )
    endif
    if ( verbose ) call dump(swathlist, 'swath names')
    if ( renameSwaths ) then
      noSwaths = min(noSwaths, NumStringElements(trim(rename), countEmpty))
      if ( verbose ) call dump(rename, 'swath names (copied)')
    endif
    if ( noSwaths < 1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'No swaths cp to file--unable to count swaths in ' // trim(rename) )
    endif
    ! Loop over swaths in file 1
    do i = 1, noSwaths
      call GetStringElement (trim(swathList), swath, i, countEmpty )
      if ( renameSwaths ) then
        call GetStringElement (trim(rename), swath2, i, countEmpty )
      else
        swath2 = swath
      endif
      ! Allocate and fill l2gp
      if ( DEEBUG ) print *, 'Reading swath from file: ', trim(swath)
      call ReadL2GPData ( file1, trim(swath), l2gp, &
           & hdfVersion=hdfVersion1, ReadStatus=ReadStatus )
      if ( DEEBUG ) then
        print *, 'Writing swath to file: ', trim(swath)
        print *, 'l2gp%nFreqs:  ', l2gp%nFreqs
        print *, 'l2gp%nLevels: ', l2gp%nLevels
        print *, 'l2gp%nTimes:  ', l2gp%nTimes
        print *, 'shape(l2gp%l2gpvalue):  ', shape(l2gp%l2gpvalue)
      endif
      ! Possibly repair l2gp
      if ( repair ) call RepairL2GP(l2gp, HGrid, options=options)
      ! Possibly extract a reduced l2pg
      if ( present(rFreqs) .or. present(rLevels) .or. present(rTimes) ) then
        if ( present(rFreqs) ) then
          myFreqs = rFreqs
        else
          myFreqs(1) = 1
          myFreqs(2) = l2gp%nFreqs
        endif
        if ( present(rLevels) ) then
          myLevels = rLevels
        else
          myLevels(1) = 1
          myLevels(2) = l2gp%nLevels
        endif
        if ( present(rTimes) ) then
          myTimes = rTimes
        else
          myTimes(1) = 1
          myTimes(2) = l2gp%nTimes
        endif
        call ExtractL2GPRecord ( l2gp, reducedl2gp, myFreqs, myLevels, myTimes )
        call WriteL2GPData(reducedl2gp, file2, trim(swath2), &
          & hdfVersion=hdfVersion2, &
          & notUnlimited=notUnlimited)
        call DestroyL2GPContents ( reducedl2gp )
      else
      ! Write the filled l2gp to file2
        call WriteL2GPData(l2gp, file2, trim(swath2), hdfVersion=hdfVersion2, &
          & notUnlimited=notUnlimited)
      endif
      call DestroyL2GPContents ( l2gp )
    enddo
       
  end subroutine cpL2GPData_fileID

  ! ---------------------- cpL2GPData_fileName  ---------------------------

  subroutine cpL2GPData_fileName(file1, file2, &
    & create2, hdfVersion1, hdfVersion2, swathList, rename, exclude, &
    & notUnlimited, andGlAttributes, ReadStatus, HGrid, &
    & rFreqs, rLevels, rTimes, options)
    !------------------------------------------------------------------------

    ! Given file names file1 and file2,
    ! This routine copies all the l2gpdata from 1 to 2
    ! (see cpL2GPData_fileID)
    ! If file2 doesn't exist yet, or if create2 is TRUE, it'll create it
    ! Optionally repairs l2gpdata

    use HGridsDatabase, only: HGrid_T
    use PCFHdr, only: GlobalAttributes_T, GlobalAttributes, &
      & he5_readglobalattr, he5_writeglobalattr
    ! Arguments

    character (len=*), intent(in) :: file1 ! Name of file 1
    character (len=*), intent(in) :: file2 ! Name of file 2
    logical, optional, intent(in) :: create2
    logical, optional, intent(in) :: andGlAttributes
    integer, optional, intent(in) :: hdfVersion1
    integer, optional, intent(in) :: hdfVersion2         !              is wild
    character (len=*), optional, intent(in) :: swathList ! Copy only these; '*'
    character (len=*), optional, intent(in) :: rename ! But rename them these
    character (len=*), optional, intent(in) :: exclude ! Don't copy these
    logical, optional, intent(in)           :: notUnlimited
    logical, optional, intent(in)           :: ReadStatus
    type (HGrid_T), optional, intent(in)    :: HGrid
    integer, dimension(2), intent(in), optional :: rFreqs  ! subscript range
    integer, dimension(2), intent(in), optional :: rLevels ! subscript range
    integer, dimension(2), intent(in), optional :: rTimes  ! subscript range
    character (len=*), optional, intent(in) :: options ! E.g., '-v'

    ! Local
    logical :: allSwaths
    integer :: DayofYear
    integer :: File1Handle
    integer :: File2Handle
    logical :: file_exists
    integer :: file_access
    type(GlobalAttributes_T) :: gAttributes
    type(GlobalAttributes_T) :: gAttributesOriginal
    integer :: listsize
    logical :: myandGlAttributes
    character (len=MAXSWATHNAMESBUFSIZE) :: mySwathList
    character (len=MAXSWATHNAMESBUFSIZE) :: myrename
    integer :: noSwaths
    character(len=40)        :: ProcessLevel
    integer :: record_length
    integer :: status
    double precision         :: TAI93At0zOfGranule
    integer :: the_hdfVersion1
    integer :: the_hdfVersion2
    
    ! Executable code
    the_hdfVersion1 = L2GPDEFAULT_HDFVERSION
    if ( present(hdfVersion1) ) the_hdfVersion1 = hdfVersion1
    file_exists = ( mls_exists(trim(File1)) == 0 )
    if ( .not. file_exists ) then
      call MLSMessage ( MLSMSG_Error, trim(ModuleName) // '/cpL2GPData', &
        & 'File 1 not found; make sure the name and path are correct' &
        & // trim(file1) )
    endif
    if ( the_hdfVersion1 == WILDCARDHDFVERSION ) then
      the_hdfVersion1 = mls_hdf_version(File1, the_hdfVersion1)
      if ( the_hdfVersion1 == FILENOTFOUND ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File 1 not found; make sure the name and path are correct' &
          & // trim(file1) )
    endif
    the_hdfVersion2 = the_hdfVersion1  ! Defaults to same hdf version as file 1
    if ( present(hdfVersion2) ) the_hdfVersion2 = hdfVersion2

    allSwaths = .not. present(swathList)
    if ( present(swathList) ) allSwaths = (swathList == '*')
    ! if ( present(swathList) ) then
    if ( .not. allSwaths ) then
      if ( DEEBUG ) then
        noSwaths = mls_InqSwath ( file1, mySwathList, listSize, &
           & hdfVersion=the_hdfVersion1)
        print *, 'swathList you requested to cp: ', trim(swathList)
        print *, 'mls_InqSwath finds: ', trim(mySwathList)
      endif
      mySwathList = swathList
    else
      noSwaths = mls_InqSwath ( file1, mySwathList, listSize, &
           & hdfVersion=the_hdfVersion1)
    endif
    File1Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, DFACC_READ, FileName=File1, &
       & hdfVersion=the_hdfVersion1, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(File1) // ' for cp-ing')

    file_exists = ( mls_exists(trim(File2)) == 0 )
    if ( file_exists ) then
      file_access = DFACC_RDWR
    else
      file_access = DFACC_CREATE
    endif
    if ( present(create2) ) then
      if ( create2 ) then
        file_access = DFACC_CREATE
      elseif ( .not. file_exists ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
         & "L2gp file: " // trim(File2) // ' for cp-ing not yet existing')
        file_access = DFACC_RDWR
      else
        file_access = DFACC_RDWR
      endif
    endif
    if ( DEEBUG ) then
      print *, 'About to open file2: ', trim(file2)
      print *, 'file_access: ', file_access
      print *, 'hdfVersion: ', the_hdfVersion2
    endif
    myandGlAttributes = (file_access == DFACC_CREATE)
    if ( present(andGlAttributes) ) &
      & myandGlAttributes = myandGlAttributes .and. andGlAttributes
    myandGlAttributes = myandGlAttributes .and. &
      & (the_hdfVersion1 == HDFVERSION_5) .and. (the_hdfVersion2 == HDFVERSION_5)
    File2Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, file_access, FileName=File2, &
       & hdfVersion=the_hdfVersion2, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(File2) // ' for cping')
    if ( DEEBUG ) then
      print *, 'About to cp from file1 to file2: ', File1Handle, File2Handle
      print *, trim(mySwathList)
    endif
    ! Maybe copy global attributes, too
    if ( myandGlAttributes ) then
      call he5_readglobalattr (File1Handle, gAttributes, &
        & ProcessLevel, DayofYear, TAI93At0zOfGranule, status)
      if ( status == 0 ) then
        ! Unfortunately, he5_writeglobalattr writes class-level data
        ! so must store original version so can copy new data into it 
        gAttributesOriginal = GlobalAttributes
        GlobalAttributes = gAttributes
        call he5_writeglobalattr (File2Handle)
        ! Before leaving must copy original data back
        GlobalAttributes = gAttributesOriginal
      endif
    endif

    if ( present(exclude) ) then
      call RemoveListFromList(mySwathList, myrename, exclude)
      mySwathList = myrename
    endif
    call cpL2GPData_fileID(File1Handle, File2Handle, &
      & mySwathList, the_hdfVersion1, the_hdfVersion2, &
      & notUnlimited=notUnlimited, rename=rename, &
      & ReadStatus=ReadStatus, HGrid=HGrid, &
      & rFreqs=rFreqs, rLevels=rlevels, rTimes=rTimes, options=options )
    if ( DEEBUG ) print *, 'About to close File1Handle: ', File1Handle
    status = mls_io_gen_closeF(l_swath, File1Handle, FileName=File1, &
      & hdfVersion=the_hdfVersion1, debugOption=.false.)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(File1) // ' after cping')
    if ( DEEBUG ) print *, 'About to close File2Handle: ', File2Handle
    ! status = mls_io_gen_closeF('swclose', File2Handle, FileName=File2, &
    !  & hdfVersion=the_hdfVersion, debugOption=.true.)
    status = mls_io_gen_closeF(l_swath, File2Handle, &
      & hdfVersion=the_hdfVersion2, debugOption=.false.)
    if ( status /= 0 ) then
      print *, 'status returned from mls_io_gen_closeF: ', status
      print *, 'WRONGHDFVERSION: ', WRONGHDFVERSION
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(File2) // ' after cping')
    endif
  end subroutine cpL2GPData_fileName

  ! ---------------------- cpL2GPData_MLSFile  ---------------------------

  subroutine cpL2GPData_MLSFile(L2GPfile1, L2GPfile2, &
    & create2, swathList, rename, exclude, &
    & notUnlimited, andGlAttributes, ReadStatus, HGrid, &
    & rFreqs, rLevels, rTimes, options)
    !------------------------------------------------------------------------

    ! Given MLSFiles L2GPfile1 and L2GPfile2,
    ! This routine copies all the l2gpdata from 1 to 2
    ! (see cpL2GPData_fileID)
    ! If L2GPfile2 doesn't exist yet, or if create2 is TRUE, it'll create it
    ! Optionally repairs l2gpdata
    use HGridsDatabase, only: HGrid_T
    ! Arguments

    type(MLSFile_T)               :: L2GPfile1 ! file 1
    type(MLSFile_T)               :: L2GPfile2 ! file 2
    logical, optional, intent(in) :: create2
    logical, optional, intent(in) :: andGlAttributes
    character (len=*), optional, intent(in) :: swathList ! Copy only these; '*'
    character (len=*), optional, intent(in) :: rename ! But rename them these
    character (len=*), optional, intent(in) :: exclude ! Don't copy these
    logical, optional, intent(in)           :: notUnlimited
    logical, optional, intent(in)           :: ReadStatus
    type (HGrid_T), optional, intent(in)    :: HGrid
    integer, dimension(2), intent(in), optional :: rFreqs  ! subscript range
    integer, dimension(2), intent(in), optional :: rLevels ! subscript range
    integer, dimension(2), intent(in), optional :: rTimes  ! subscript range
    character (len=*), optional, intent(in) :: options ! E.g., '-v'
    ! Local
    logical :: L1alreadyOpen
    logical :: L2alreadyOpen
    logical :: myCreate2
    character(len=MAXSWATHNAMESBUFSIZE) :: mySwathList
    integer :: originalAccess
    integer :: status
    !
    myCreate2 = .false.
    if ( present(create2) ) myCreate2 = create2
    mySwathList = '*'
    if ( present(swathList) ) mySwathList = swathList
    originalAccess = L2GPFile2%access
    status = 0
    L1alreadyOpen = L2GPFile1%stillOpen
    if ( L1alreadyOpen ) then
      call mls_closeFile(L2GPFile1, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to close l2gp file to cp from', MLSFile=L2GPFile1)
    endif

    status = 0
    L2alreadyOpen = L2GPFile2%stillOpen
    if ( L2alreadyOpen ) then
      if ( myCreate2 ) L2GPFile2%access = DFACC_CREATE
      call mls_closeFile(L2GPFile2, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to close l2gp file to cp to', MLSFile=L2GPFile2)
    endif
    
    call cpL2GPData_fileName(L2GPFile1%Name, L2GPFile2%Name, &
      & create2, L2GPFile1%hdfVersion, L2GPFile2%hdfVersion, &
      & SwathList, rename, exclude, &
      & notUnlimited, andGLAttributes, ReadStatus, HGrid, &
      & rFreqs, rLevels, rTimes, options)

    if ( L1alreadyOpen )  call mls_openFile(L2GPFile1, Status)
    L2GPFile1%errorCode = status
    L2GPFile1%lastOperation = 'read'

    if ( L2alreadyOpen )  call mls_openFile(L2GPFile2, Status)
    L2GPFile2%errorCode = status
    L2GPFile2%lastOperation = 'write'
    L2GPFile2%access = originalAccess

  end subroutine cpL2GPData_MLSFile

  ! ------------------------------------------ DiffL2GPData_CHUNKS ------------

  subroutine DiffL2GPData_CHUNKS ( fullL2gp1, fullL2gp2, Chunks, &
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, &
    & verbose, numDiffs )
    ! Dump selected chunks of an l2gp
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          FULLL2GP1
    type (l2gpData_T), intent(in) ::          FULLL2GP2
    integer, intent(in), dimension(:) :: Chunks ! Which chunks to dump
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: RMS     ! if TRUE, just print mean, rms
    logical, intent(in), optional :: WHOLEARRAY   ! if TRUE, print anyway
    logical, intent(in), optional :: IGNOREBADCHUNKS   ! if TRUE, ignore
                                                     ! instances where geod bad
    character(len=*), intent(in), optional :: fields  ! diff only these fields
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
    integer, intent(out), optional :: numDiffs  ! how many diffs

    ! Local variables
    integer :: chunk
    ! logical, parameter :: DEEBUG = .true.
    integer :: i
    integer, dimension(2) :: irange
    type (l2gpData_T) ::          L2GP1, L2gp2
    logical :: mySilent
    ! Executable
    mySilent = .false.
    if ( present(silent) ) mySilent = silent
    if ( DEEBUG ) then
      call output( 'mySilent: ', advance='no' )
      call output( mySilent, advance='yes' )
      call output( 'size(chunks): ', advance='no' )
      call output( size(chunks), advance='yes' )
      call output( chunks, advance='yes' )
      call output( 'fullL2gp1%chunkNumber: ', advance='no' )
      call output( fullL2gp1%chunkNumber, advance='yes' )
    endif
    do i=1, size(Chunks)
      chunk = Chunks(i)
      irange(1) = FindFirst( fullL2gp1%chunkNumber, chunk )
      irange(2) = Findlast( fullL2gp1%chunkNumber, chunk )
      ! HuntRange does not work correctly when any chunk Numbers are -999
      ! (Missing Value)
      ! call output( 'First, Last == chunk number ', advance='no' )
      ! call output( irange, advance='yes' )
      ! call HuntRange( fullL2gp1%chunkNumber, (/ chunk, chunk /), irange )
      if ( any( irange == 0 ) ) cycle
      if ( .not. mySilent ) then
        call output ( ' - - - Chunk number:', advance='no')
        call output ( chunk, advance='no')
        call output ( ' - - -', advance='yes')
      endif
      ! call output( 'irange: ', advance='no' )
      ! call output( irange, advance='yes' )
      call ExtractL2GPRecord ( fullL2gp1, l2gp1, rTimes=irange )
      call ExtractL2GPRecord ( fullL2gp2, l2gp2, rTimes=irange )
      ! call output( 'nTimes: ', advance='no' )
      ! call output( l2gp1%nTimes, advance='yes' )
      call Diff ( L2gp1, L2gp2, &
        & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
        & silent=silent, verbose=verbose, numDiffs=numDiffs )
      call DestroyL2GPContents( l2gp1 )
      call DestroyL2GPContents( l2gp2 )
    enddo
  end subroutine DiffL2GPData_CHUNKS

  ! ------------------------------------------ DiffL2GPData_LEVELS ------------

  subroutine DiffL2GPData_LEVELS ( fullL2gp1, fullL2gp2, Pressures, Chunks, &
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, &
    & verbose, numDiffs )
    ! Dump selected levels of an l2gp
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          FULLL2GP1
    type (l2gpData_T), intent(in) ::          FULLL2GP2
    real(rgp), intent(in), dimension(:) :: pressures ! Which levels to dump
    integer, intent(in), optional, dimension(:) :: Chunks ! Which chunks to dump
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: RMS     ! if TRUE, just print mean, rms
    logical, intent(in), optional :: WHOLEARRAY   ! if TRUE, print anyway
    logical, intent(in), optional :: IGNOREBADCHUNKS   ! if TRUE, ignore
                                                     ! instances where geod bad
    character(len=*), intent(in), optional :: fields  ! diff only these fields
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
    integer, intent(out), optional :: numDiffs  ! how many diffs

    ! Local variables
    real(rgp) :: pressure
    ! logical, parameter :: DEEBUG = .true.
    integer :: i
    integer, dimension(2) :: irange
    type (l2gpData_T) ::          L2GP1, L2gp2
    logical :: mySilent
    ! Executable
    mySilent = .false.
    if ( present(silent) ) mySilent = silent
    if ( DEEBUG ) then
      call output( 'mySilent: ', advance='no' )
      call output( mySilent, advance='yes' )
      call output( 'size(pressures): ', advance='no' )
      call output( size(pressures), advance='yes' )
      call output( pressures, advance='yes' )
      call output( 'fullL2gp1%pressures: ', advance='no' )
      call output( fullL2gp1%pressures, advance='yes' )
    endif
    do i=1, size(pressures)
      pressure = pressures(i)
      ! The dubious "1.005" factor is to prevent missing a desired level
      ! due to unlucky roundoff
      irange(1) = FindFirst( fullL2gp1%pressures <= pressure*1.005 )
      irange(2) = irange(1)
      if ( any( irange == 0 ) ) cycle
      if ( .not. mySilent ) then
        call output ( ' - - - pressure:', advance='no')
        call output ( fullL2gp1%pressures(irange(1)), advance='no')
        call output ( ' - - -', advance='yes')
      endif
      ! call output( 'irange: ', advance='no' )
      ! call output( irange, advance='yes' )
      call ExtractL2GPRecord ( fullL2gp1, l2gp1, rLevels=irange )
      call ExtractL2GPRecord ( fullL2gp2, l2gp2, rLevels=irange )
      ! call output( 'nTimes: ', advance='no' )
      ! call output( l2gp1%nTimes, advance='yes' )
      if ( present(chunks) ) then
        call DiffL2GPData_Chunks ( L2gp1, L2gp2, chunks, &
          & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
          & silent=silent, verbose=verbose, numDiffs=numDiffs )
      else
        call Diff ( L2gp1, L2gp2, &
          & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
          & silent=silent, verbose=verbose, numDiffs=numDiffs )
      endif
      call DestroyL2GPContents( l2gp1 )
      call DestroyL2GPContents( l2gp2 )
    enddo
  end subroutine DiffL2GPData_LEVELS

  ! ---------------------- DiffL2GPData  ---------------------------
  subroutine DiffL2GPData ( L2gp1, L2gp2, &
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, matchTimes, &
    & silent, verbose, numDiffs )
    ! Show diff between l2gp1 and l2gp2 down to level of Details
    
    ! Note:
    ! by default, print arrays of diffs, but not stats nor rms
    ! If either stats or rms, just print those, but not arrays
    ! To print stats and arrays, both, turn on wholeArrays and stats
    ! To print stats, rms, and arrays, both, turn on wholeArrays, rms, stats
    
    ! (Is this too complicated? Should we make wholeArrays always on
    !  by default unless explicitly turned off?)
    ! Dummy arguments
    type (l2gpData_T), intent(inout) ::          L2GP1
    type (l2gpData_T), intent(inout) ::          L2GP2
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: RMS     ! if TRUE, just print mean, rms
    logical, intent(in), optional :: WHOLEARRAY   ! if TRUE, print anyway
    logical, intent(in), optional :: IGNOREBADCHUNKS   ! if TRUE, ignore
                                                     ! instances where geod bad
    character(len=*), intent(in), optional :: fields  ! diff only these fields
    logical, intent(in), optional :: matchTimes
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
    integer, intent(out), optional :: numDiffs  ! how many diffs
    ! Local variables
    integer :: how_many
    logical :: myMatchTimes
    logical :: mySilent
    type (L2GPData_T) :: tl2gp1, tl2gp2
    integer, dimension(MAXNUMTIMES) :: which1, which2
    ! Executable
    myMatchTimes = .false.
    if ( present(matchTimes) ) mymatchTimes = matchTimes
    mySilent = .false.
    if ( present(silent) ) mySilent = silent
    if ( present(numDiffs) ) numDiffs = 0
    if ( myMatchTimes ) then
      ! 1st, find which profile times match (to within 0.1 s)
      call FindIntersection( l2gp1%time, l2gp2%time, which1, which2, how_many, &
        & tol=1.d-1 )
      if ( how_many == 0 ) then
        ! 2nd chance--try to match Geod. Ang. to within 1/2 deg.
        if ( .not. mySilent ) call output( &
          & 'No matching times found in l2gp1, l2gp2', advance='yes' )
        call FindIntersection( l2gp1%GeodAngle, l2gp2%GeodAngle, which1, which2, how_many, &
          & tol=0.5 )
        if ( how_many == 0 ) then
          if ( .not. mySilent ) call output( &
            & 'No matching geod. angs found in l2gp1, l2gp2', advance='yes' )
          return
        endif
      endif
      call SetupNewL2GPRecord ( tl2gp1, proto=l2gp1, which=which1(1:how_many) )
      call SetupNewL2GPRecord ( tl2gp2, proto=l2gp2, which=which2(1:how_many) )
      call DiffL2GPData_atlast ( tL2gp1, tL2gp2, &
      & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
      & silent, verbose, numDiffs )
      call DestroyL2GPContents( tL2gp1 )
      call DestroyL2GPContents( tL2gp2 )
    else
      call DiffL2GPData_atlast ( L2gp1, L2gp2, &
      & Details, wholeArray, stats, rms, ignoreBadChunks, fields, &
      & silent, verbose, numDiffs )
    endif
  end subroutine DiffL2GPData

  ! ---------------------- DiffL2GPData_atlast  ---------------------------
  subroutine DiffL2GPData_atlast ( L2gp1, L2gp2, &
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, &
    & verbose, numDiffs )
    ! Show diff between l2gp1 and l2gp2 down to level of Details
    
    ! Note:
    ! by default, print arrays of diffs, but not stats nor rms
    ! If either stats or rms, just print those, but not arrays
    ! To print stats and arrays, both, turn on wholeArrays and stats
    ! To print stats, rms, and arrays, both, turn on wholeArrays, rms, stats
    
    ! (Is this too complicated? Should we make wholeArrays always on
    !  by default unless explicitly turned off?)
    ! Dummy arguments
    type (l2gpData_T), intent(inout) ::          L2GP1
    type (l2gpData_T), intent(inout) ::          L2GP2
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: RMS     ! if TRUE, just print mean, rms
    logical, intent(in), optional :: WHOLEARRAY   ! if TRUE, print anyway
    logical, intent(in), optional :: IGNOREBADCHUNKS   ! if TRUE, ignore
                                                     ! instances where geod bad
    character(len=*), intent(in), optional :: fields  ! diff only these fields
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
    integer, intent(out), optional :: numDiffs  ! how many diffs
    ! Local variables
    logical :: badChunks
    integer :: badInstances
    character(len=*), parameter :: DEFAULTFIELDS = &
      & 'pressures, latitude, longitude, solarTime, solarZenith,' // &
      & 'losAngle, geodAngle, time, chunkNumber, frequency,'  // &
      & 'l2gpvalue, l2gpPrecision, status, quality, convergence'
    ! logical, parameter :: DEEBUG = .true.
    integer :: instance
    type (l2gpData_T) ::          L2GP2Temp
    integer :: MYDETAILS
    character(len=len(DEFAULTFIELDS)) :: myFields
    integer :: myNumDiffs
    logical :: mySilent
    logical :: myVerbose
    logical :: ShapesDontMatch
    ! Executable code
    if ( .not. isL2GPSetUp(l2gp1) ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, & 
        'l2gp1 not yet allocated in diff')
      return
    elseif ( .not. isL2GPSetUp(l2gp2) ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, & 
        'l2gp2 not yet allocated in diff')
      return
    endif
    myDetails = 1
    if ( present(details) ) myDetails = details
    mySilent = .false.
    if ( present(silent) ) mySilent = silent
    if ( mySilent ) call suspendOutput
    myVerbose = .false.
    if ( present(verbose) ) myVerbose = verbose

    myNumDiffs = 0

    ShapesDontMatch = .false.
    badChunks = .false.
    badInstances = 0
    myFields = DEFAULTFIELDS
    if ( present(fields) ) myFields = fields
    if ( DEEBUG ) then
      call output( 'myDetails: ', advance='no' )
      call output( myDetails, advance='yes' )
      call output( 'mySilent: ', advance='no' )
      call output( mySilent, advance='yes' )
      call output( 'myFields: ', advance='no' )
      call output( myFields, advance='yes' )
    endif
    if ( myFields == '*' .or. lowercase(myFields) == 'all' ) &
      & myFields = DEFAULTFIELDS
      if ( trim(l2gp1%name) /= trim(l2gp2%name) ) then
        call output('(1) name: ' // trim(l2gp1%name), advance='yes')
        call output('(2) name: ' // trim(l2gp2%name), advance='yes')
        myNumDiffs = myNumDiffs + 1
      endif
      if ( myDetails < -1 ) then
        call doneHere
        return
      endif
      if ( L2gp1%MissingValue /= L2gp2%MissingValue ) then
        call output(' (1) MissingValue = ', advance='no')
        call output(L2gp1%nTimes, advance='yes')
        call output(' (2) MissingValue = ', advance='no')
        call output(L2gp2%nTimes, advance='yes')
        myNumDiffs = myNumDiffs + 1
      endif
      if ( L2gp1%nTimes /= L2gp2%nTimes ) then
        call output(' (1) nTimes = ', advance='no')
        call output(L2gp1%nTimes, advance='yes')
        call output(' (2) nTimes = ', advance='no')
        call output(L2gp2%nTimes, advance='yes')
        ShapesDontMatch = .true.
        myNumDiffs = myNumDiffs + 1
      endif
      if ( L2gp1%nLevels /= L2gp2%nLevels ) then
        call output(' (1) nLevels = ', advance='no')
        call output(L2gp1%nLevels, advance='yes')
        call output(' (2) nLevels = ', advance='no')
        call output(L2gp2%nLevels, advance='yes')
        ShapesDontMatch = .true.
        myNumDiffs = myNumDiffs + 1
      endif
      if ( L2gp1%nFreqs /= L2gp2%nFreqs ) then
        call output(' (1) nFreqs = ', advance='no')
        call output(L2gp1%nFreqs, advance='yes')
        call output(' (2) nFreqs = ', advance='no')
        call output(L2gp2%nFreqs, advance='yes')
        ShapesDontMatch = .true.
        myNumDiffs = myNumDiffs + 1
      endif
      if ( myDetails < 0 )  then
        if ( myVerbose ) &
          & call output ( '(Data shapes and swath names match)', advance='yes' )
        call doneHere
        return
      endif
      if ( ShapesDontMatch ) then
        call output('Skipping further details because shapes dont match',&
          & advance='yes')
        call doneHere
        return
      endif
      
      badChunks = badChunks .or. &
        & ( &
        & any( mod ( l2gp1%status, 2 ) == 1 ) &
        & .or. &
        & any( mod ( l2gp2%status, 2 ) == 1 ) &
        & .or. &
        & any( IsFillValue ( l2gp1%l2gpValue, l2gp1%MissingValue ) ) &
        & .or. &
        & any( IsFillValue ( l2gp2%l2gpValue, l2gp2%MissingValue ) ) &
        & )
      if ( present ( ignoreBadChunks ) ) then
        badChunks = ignoreBadChunks .and. badChunks
      else
        badChunks = .false.
      endif
      ! OK, we'll try what you suggest
      call SetupNewL2GPRecord ( l2gp2Temp, proto=l2gp2 )
      if ( badChunks ) then
        do instance=1, L2gp1%nTimes
          if ( l2gp1%geodAngle(instance) /= l2gp2%geodAngle(instance) &
            & .or. &
            & l2gp1%solarZenith(instance) /= l2gp2%solarZenith(instance) &
            & .or. &
            & l2gp1%time(instance) /= l2gp2%time(instance) &
            & .or. &
            & mod(l2gp1%status(instance), 2) == 1 &
            & .or. &
            & mod(l2gp2%status(instance), 2) == 1 &
            & .or. &
            & any( IsFillValue ( l2gp1%l2gpValue(:,:,instance), l2gp1%MissingValue ) ) &
            & .or. &
            & any( IsFillValue ( l2gp2%l2gpValue(:,:,instance), l2gp2%MissingValue ) ) &
            & ) then
            l2gp2Temp%l2gpValue(:,:,instance) = l2gp1%l2gpValue(:,:,instance)
            l2gp2Temp%l2gpPrecision(:,:,instance) = l2gp1%l2gpPrecision(:,:,instance)
            l2gp2Temp%status(instance) = l2gp1%status(instance)
            l2gp2Temp%quality(instance) = l2gp1%quality(instance)
            l2gp2Temp%convergence(instance) = l2gp1%convergence(instance)
            ! Also geolocations will be reset to avoid displaying bogus diffs
            l2gp2Temp%latitude(instance) = l2gp1%latitude(instance)
            l2gp2Temp%longitude(instance) = l2gp1%longitude(instance)
            l2gp2Temp%solarTime(instance) = l2gp1%solarTime(instance)
            l2gp2Temp%chunkNumber(instance) = l2gp1%chunkNumber(instance)
            l2gp2Temp%geodAngle(instance) = l2gp1%geodAngle(instance)
            l2gp2Temp%solarZenith(instance) = l2gp1%solarZenith(instance)
            l2gp2Temp%time(instance) = l2gp1%time(instance)
            l2gp2Temp%losAngle(instance) = l2gp1%losAngle(instance)
            badInstances = badInstances + 1
          endif
        enddo
        call output('Number of bad instances of l2gp2 reset to l2gp1 ', advance='no')
        call output(badInstances, advance='yes')
      endif
d3693 1
a3693 5
      call diffGeoLocations( l2gp1, l2gp2Temp )
      if ( myDetails < 1 )  then
        call doneHere
        return
      endif
d3695 5
a3699 51
      if ( any(l2gp1%l2gpValue /= l2gp2Temp%l2gpValue) .and. &
        & SwitchDetail(lowercase(myFields), 'value', '-c') > -1 ) then
        call diff ( l2gp1%l2gpValue, 'l2gp%l2gpValue', &
          &         l2gp2Temp%l2gpValue, ' ', &
          & wholearray=wholearray, stats=stats, rms=rms, fillValue=l2gp1%MissingValue )
        myNumDiffs = myNumDiffs + count( l2gp1%l2gpValue /= l2gp2Temp%l2gpValue )
      elseif ( all(l2gp1%l2gpValue == l2gp2Temp%l2gpValue) .and. &
        & SwitchDetail(lowercase(myFields), 'value', '-c') > -1 .and. myVerbose ) then
        call output('(values fields equal)', advance='yes')
      endif
      if ( any(l2gp1%l2gpPrecision /= l2gp2Temp%l2gpPrecision) .and. &
        & SwitchDetail(lowercase(myFields), 'precision', '-c') > -1 ) then
        call diff ( l2gp1%l2gpPrecision, 'l2gp%l2gpPrecision', &
          &         l2gp2Temp%l2gpPrecision, ' ', &
          & wholearray=wholearray, stats=stats, rms=rms, fillValue=l2gp1%MissingValue )
        myNumDiffs = myNumDiffs + count( l2gp1%l2gpPrecision /= l2gp2Temp%l2gpPrecision )
      elseif ( all(l2gp1%l2gpPrecision == l2gp2Temp%l2gpPrecision) .and. &
        & SwitchDetail(lowercase(myFields), 'precision', '-c') > -1 .and. myVerbose ) then
        call output('(precision fields equal)', advance='yes')
      endif
      
      if ( any(l2gp1%status /= l2gp2Temp%status) .and. &
        & SwitchDetail(lowercase(myFields), 'status', '-c') > -1 ) then
        call diff ( l2gp1%status, 'l2gp%status', &
          &         l2gp2Temp%status, ' ', &
          & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%status /= l2gp2Temp%status )
      elseif ( all(l2gp1%status == l2gp2Temp%status) .and. &
        & SwitchDetail(lowercase(myFields), 'status', '-c') > -1 .and. myVerbose ) then
        call output('(status fields equal)', advance='yes')
      endif
      if ( any(l2gp1%quality /= l2gp2Temp%quality) .and. &
        & SwitchDetail(lowercase(myFields), 'quality', '-c') > -1 ) then
        call diff ( l2gp1%quality, 'l2gp%quality', &
          &         l2gp2Temp%quality, ' ', &
          & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%quality /= l2gp2Temp%quality )
      elseif ( all(l2gp1%quality == l2gp2Temp%quality) .and. &
        & SwitchDetail(lowercase(myFields), 'quality', '-c') > -1 .and. myVerbose ) then
        call output('(quality fields equal)', advance='yes')
      endif
      if ( any(l2gp1%convergence /= l2gp2Temp%convergence) .and. &
        & SwitchDetail(lowercase(myFields), 'convergence', '-c') > -1 ) then
        call diff ( l2gp1%convergence, 'l2gp%convergence', &
          &         l2gp2Temp%convergence, ' ', &
          & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%convergence /= l2gp2Temp%convergence )
      elseif ( all(l2gp1%convergence == l2gp2Temp%convergence) .and. &
        & SwitchDetail(lowercase(myFields), 'convergence', '-c') > -1 .and. myVerbose ) then
        call output('(convergence fields equal)', advance='yes')
      endif
d3701 4
a3704 85
contains
    subroutine diffGeoLocations( l2gp1, l2gp2 )
      ! Args
      type(L2GPData_T) :: l2gp1
      type(L2GPData_T) :: l2gp2
      ! Executable
      if ( any(l2gp1%pressures /= l2gp2%pressures) .and. &
        & SwitchDetail(lowercase(myFields), 'pressure', '-c') > -1 ) then
          call diff ( l2gp1%pressures, 'l2gp%pressures', &
            &         l2gp2%pressures, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%pressures /= l2gp2%pressures )
      endif
      if ( any(l2gp1%latitude /= l2gp2%latitude) .and. &
        & SwitchDetail(lowercase(myFields), 'lat', '-c') > -1 ) then
          call diff ( l2gp1%latitude, 'l2gp%latitude', &
            &         l2gp2%latitude, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%latitude /= l2gp2%latitude )
      endif
      if ( any(l2gp1%longitude /= l2gp2%longitude) .and. &
        & SwitchDetail(lowercase(myFields), 'lon', '-c') > -1 ) then
          call diff ( l2gp1%longitude, 'l2gp%longitude', &
            &         l2gp2%longitude, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%longitude /= l2gp2%longitude )
      endif
      if ( any(l2gp1%solarTime /= l2gp2%solarTime) .and. &
        & SwitchDetail(lowercase(myFields), 'solartime', '-c') > -1 ) then
          call diff ( l2gp1%solarTime, 'l2gp%solarTime', &
            &         l2gp2%solarTime, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%solarTime /= l2gp2%solarTime )
      endif
      if ( any(l2gp1%solarZenith /= l2gp2%solarZenith) .and. &
        & SwitchDetail(lowercase(myFields), 'solarzenith', '-c') > -1 ) then
          call diff ( l2gp1%solarZenith, 'l2gp%solarZenith', &
            &         l2gp2%solarZenith, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        badChunks = .true.
        myNumDiffs = myNumDiffs + count( l2gp1%solarZenith /= l2gp2%solarZenith )
      endif
      if ( any(l2gp1%losAngle /= l2gp2%losAngle) .and. &
        & SwitchDetail(lowercase(myFields), 'losangle', '-c') > -1 ) then
          call diff ( l2gp1%losAngle, 'l2gp%losAngle', &
            &         l2gp2%losAngle, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%losAngle /= l2gp2%losAngle )
      endif
      if ( any(l2gp1%geodAngle /= l2gp2%geodAngle) .and. &
        & SwitchDetail(lowercase(myFields), 'geodangle', '-c') > -1 ) then
          call diff ( l2gp1%geodAngle, 'l2gp%geodAngle', &
            &         l2gp2%geodAngle, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        ! badChunks = .true.
        myNumDiffs = myNumDiffs + count( l2gp1%geodAngle /= l2gp2%geodAngle )
      endif
      if ( any(l2gp1%time /= l2gp2%time) .and. &
        & SwitchDetail(lowercase(myFields), 'time', '-c') > -1 ) then
          call diff ( l2gp1%time, 'l2gp%time', &
            &         l2gp2%time, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        ! badChunks = .true.
        myNumDiffs = myNumDiffs + count( l2gp1%time /= l2gp2%time )
      endif
      if ( any(l2gp1%chunkNumber /= l2gp2%chunkNumber) .and. &
        & SwitchDetail(lowercase(myFields), 'chunknumber', '-c') > -1 ) then
        call diff ( l2gp1%chunkNumber, 'l2gp1%chunkNumber', &
          &         l2gp2%chunkNumber, 'l2gp2%chunkNumber', &
          & wholearray=wholearray, stats=stats, rms=rms )
        ! call dump ( l2gp1%chunkNumber - l2gp2%chunkNumber, &
        !  & 'l2gp%chunkNumber (diff)', stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%chunkNumber /= l2gp2%chunkNumber )
      endif
      
      if ( associated(l2gp1%frequency) .and.  associated(l2gp2%frequency)) then
        if ( any(l2gp1%frequency /= l2gp2%frequency) .and. &
          & SwitchDetail(lowercase(myFields), 'freq', '-c') > -1 ) then
          call diff ( l2gp1%frequency, 'l2gp%frequency', &
            &         l2gp2%frequency, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%frequency /= l2gp2%frequency )
        endif
      endif
    end subroutine diffGeoLocations
d3706 1
a3706 9
    subroutine doneHere
      ! Housekeeping
      ! Done with the temporary, so deallocate it before returning
      call DestroyL2GPContents ( L2GP2Temp )
      
      call resumeOutput
      if ( present(numDiffs) ) numDiffs = myNumDiffs
    end subroutine doneHere
  end subroutine DiffL2GPData_atlast
d3708 9
a3716 44
  ! ------------------------------------------ DiffL2GPFiles_MLSFile ------------
  subroutine DiffL2GPFiles_MLSFile ( L2GPFile1, L2GPFile2, pressures, chunks, &
    & Details, wholeArray, stats, rms, ignoreBadChunks, &
    & swList, showMissing, fields, force, swaths1, swaths2, &
    & matchTimes, silent, verbose, numDiffs )
    ! Show diff between swaths in file1 and file2 down to level of Details
    ! Dummy arguments
    type(MLSFile_T)               :: L2GPfile1 ! file 1
    type(MLSFile_T)               :: L2GPfile2 ! file 2
    real, intent(in), dimension(:), optional :: pressures ! Which heights to dump
    integer, intent(in), dimension(:), optional :: Chunks ! Which chunks to dump
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    !
    ! The following parameters, if present, will override Details
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: RMS   ! if TRUE, just print mean, rms
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: IGNOREBADCHUNKS
    ! swList currently used only if showMissing is TRUE
    character (len=*), optional, intent(in) :: swList
    logical, intent(in), optional :: showMissing   ! if TRUE, just show which
    character(len=*), intent(in), optional :: fields  ! only these fields
    character(len=*), intent(in), optional :: swaths1  ! only these swaths
    character(len=*), intent(in), optional :: swaths2  ! only these swaths
    logical, intent(in), optional :: FORCE ! Force diff even if swathnames differ
    logical, intent(in), optional :: matchTimes  ! only matching profile times
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
    integer, intent(out), optional :: numDiffs  ! how many diffs
    ! Local                                         swaths are missing from other
    logical :: L1alreadyOpen
    logical :: L2alreadyOpen
    integer :: status
    !
    L1alreadyOpen = L2GPFile1%stillOpen
    if ( L1alreadyOpen ) then
      call mls_closeFile(L2GPFile1, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to close l2gp file to diff between', MLSFile=L2GPFile1)
d3718 3
a3720 34
    !
    L2alreadyOpen = L2GPFile2%stillOpen
    if ( L2alreadyOpen ) then
      call mls_closeFile(L2GPFile2, Status)
      if ( Status /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to close l2gp file to diff between', MLSFile=L2GPFile2)
    endif
    
    if ( present(chunks) .and. present(pressures) ) then
      call DiffL2GPFiles_Name ( L2GPFile1%Name, L2GPFile2%Name, &
      & pressures=pressures, &
      & chunks=chunks, Details=Details, wholeArray=wholeArray, &
      & stats=stats, rms=rms, ignoreBadChunks=ignoreBadChunks, &
      & swList=swList, showMissing=showMissing, &
      & fields=fields, force=force, swaths1=swaths1, swaths2=swaths2, &
      & matchTimes=matchTimes, silent=silent, verbose=verbose, &
      & numDiffs=numDiffs )
    elseif ( present(chunks) ) then
      call DiffL2GPFiles_Name ( L2GPFile1%Name, L2GPFile2%Name, &
      & chunks=chunks, Details=Details, wholeArray=wholeArray, &
      & stats=stats, rms=rms, ignoreBadChunks=ignoreBadChunks, &
      & swList=swList, showMissing=showMissing, &
      & fields=fields, force=force, swaths1=swaths1, swaths2=swaths2, &
      & matchTimes=matchTimes, silent=silent, verbose=verbose, &
      & numDiffs=numDiffs )
    elseif ( present(pressures) ) then
      call DiffL2GPFiles_Name ( L2GPFile1%Name, L2GPFile2%Name, &
      & pressures=pressures, Details=Details, wholeArray=wholeArray, &
      & stats=stats, rms=rms, ignoreBadChunks=ignoreBadChunks, &
      & swList=swList, showMissing=showMissing, &
      & fields=fields, force=force, swaths1=swaths1, swaths2=swaths2, &
      & matchTimes=matchTimes, silent=silent, verbose=verbose, &
      & numDiffs=numDiffs )
d3722 1
a3722 7
      call DiffL2GPFiles_Name ( L2GPFile1%Name, L2GPFile2%Name, &
      & Details=Details, wholeArray=wholeArray, &
      & stats=stats, rms=rms, ignoreBadChunks=ignoreBadChunks, &
      & swList=swList, showMissing=showMissing, &
      & fields=fields, force=force, swaths1=swaths1, swaths2=swaths2, &
      & matchTimes=matchTimes, silent=silent, verbose=verbose, &
      & numDiffs=numDiffs )
d3724 3
d3728 1
a3728 3
    if ( L1alreadyOpen )  call mls_openFile(L2GPFile1, Status)
    L2GPFile1%errorCode = status
    L2GPFile1%lastOperation = 'read'
d3730 3
a3732 3
    if ( L2alreadyOpen )  call mls_openFile(L2GPFile2, Status)
    L2GPFile2%errorCode = status
    L2GPFile2%lastOperation = 'read'
d3734 4
a3737 69
  end subroutine DiffL2GPFiles_MLSFile
    
  ! ------------------------------------------ DiffL2GPFiles_Name ------------
  subroutine DiffL2GPFiles_Name ( file1, file2, pressures, chunks, &
    & Details, wholeArray, stats, rms, ignoreBadChunks, &
    & swList, showMissing, fields, force, swaths1, swaths2, matchTimes, &
    & silent, verbose, numDiffs )
    ! Show diff between swaths in file1 and file2 down to level of Details
    ! Dummy arguments
    character (len=*), intent(in) :: file1 ! Name of file 1
    character (len=*), intent(in) :: file2 ! Name of file 2
    real, intent(in), dimension(:), optional :: pressures ! Which heights to diff
    integer, intent(in), dimension(:), optional :: Chunks ! Which chunks to diff
    integer, intent(in), optional :: DETAILS ! <=0 => Don't diff data fields
    !                                        ! -1 Skip even geolocation fields
    !                                        ! -2 Skip all but name
    !                                        ! >0 Diff even data fields
    !                                        ! Default 1
    !
    ! The following parameters, if present, will override Details
    logical, intent(in), optional :: WHOLEARRAY
    logical, intent(in), optional :: RMS   ! if TRUE, just print mean, rms
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
    logical, intent(in), optional :: IGNOREBADCHUNKS
    ! swList currently used only if showMissing is TRUE
    character (len=*), optional, intent(in) :: swList
    logical, intent(in), optional :: showMissing   ! if TRUE, just show which
    character(len=*), intent(in), optional :: fields  ! only these fields
    character(len=*), intent(in), optional :: swaths1  ! only these swaths
    character(len=*), intent(in), optional :: swaths2  ! only these swaths
    logical, intent(in), optional :: FORCE ! Force diff even if swathnames differ
    logical, intent(in), optional :: matchTimes  ! only matching profile times
    logical, intent(in), optional :: silent  ! don't print anything
    logical, intent(in), optional :: verbose  ! print something no matter what
    integer, intent(out), optional :: numDiffs  ! how many diffs
    ! Local                                         swaths are missing from other
    logical, parameter            :: countEmpty = .true.
    logical :: file_exists
    integer :: File1Handle
    integer :: File2Handle
    integer :: i
    type (L2GPData_T) :: l2gp1
    type (L2GPData_T) :: l2gp2
    integer :: listsize
    logical :: myForce
    logical :: myShowMissing
    logical :: mySilent
    integer :: myNumDiffs
    integer :: noSwaths
    integer :: noSwaths2
    integer :: noUnique
    integer :: record_length
    character (len=MAXSWATHNAMESBUFSIZE) :: rename
    integer :: status
    character (len=L2GPNameLen) :: swath
    character (len=L2GPNameLen) :: swath2
    character (len=MAXSWATHNAMESBUFSIZE) :: swathList1
    character (len=MAXSWATHNAMESBUFSIZE) :: swathUnique
    integer :: the_hdfVersion1
    integer :: the_hdfVersion2
    ! Executable code
    myNumDiffs = 0
    myShowMissing = .false.
    if ( present(showMissing) ) myShowMissing=showMissing
    file_exists = ( mls_exists(trim(File1)) == 0 )
    if ( .not. file_exists ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'File 1 not found; make sure the name and path are correct' &
        & // trim(file1) )
a3738 4
    myForce = .false.
    if ( present(force) ) myForce = force
    mySilent = .false.
    if ( present(silent) ) mySilent = silent
d3740 60
a3799 74
    the_hdfVersion1 = mls_hdf_version(File1)
    the_hdfVersion2 = mls_hdf_version(File2)
    file_exists = ( mls_exists(trim(File2)) == 0 )
    if ( .not. file_exists ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'File 2 not found; make sure the name and path are correct' &
        & // trim(file1) )
    endif
    the_hdfVersion2 = mls_hdf_version(File2)
    noSwaths = mls_InqSwath ( file1, swathList1, listSize, &
         & hdfVersion=the_hdfVersion1)
    if ( present(swaths1) ) then
      if ( swaths1 /= 'all' .and. swaths1 /= '*' ) then
        swathList1 = swaths1
        noSwaths = NumStringElements( swaths1, countEmpty=.true. )
      endif
    endif
    noSwaths2 = mls_InqSwath ( file2, rename, listSize, &
         & hdfVersion=the_hdfVersion2)
    if ( present(swaths2) ) then
      if ( swaths2 /= 'all' .and. swaths2 /= '*' ) then
        rename = swaths2
        noSwaths2 = NumStringElements( swaths2, countEmpty=.true. )
      endif
    endif
    ! Are we merely to point out which swaths are missing from the other file?
    if ( myShowMissing ) then
      if ( present(swList) ) then
        call GetUniqueList(swList, swathUnique, noUnique, countEmpty, &
          & str2=trim(swathList1))
        if ( noUnique > 0 ) then
          call output('swaths missing from ' // trim(File1), advance='yes')
          call output(trim(swathUnique), advance='yes')
        else
          call output('All swaths in ' // trim(File1), advance='yes')
        endif
        call GetUniqueList(swList, swathUnique, noUnique, countEmpty, &
          & str2=trim(rename))
        if ( noUnique > 0 ) then
          call output('swaths missing from ' // trim(File2), advance='yes')
          call output(trim(swathUnique), advance='yes')
        else
          call output('All swaths in ' // trim(File2), advance='yes')
        endif
      else
        call output('Comparing swaths in ' // trim(File1), advance='no')
        call output(' with ' // trim(File2), advance='yes')
        call GetUniqueList(trim(swathList1), swathUnique, noUnique, countEmpty, &
          & str2=trim(rename))
        if ( noUnique > 0 ) then
          call output('swaths only in ' // trim(File1), advance='yes')
          call output(trim(swathUnique), advance='yes')
        endif
        call GetUniqueList(trim(rename), swathUnique, noUnique, countEmpty, &
          & str2=trim(swathList1))
        if ( noUnique > 0 ) then
          call output('swaths only in ' // trim(File2), advance='yes')
          call output(trim(swathUnique), advance='yes')
        endif
      endif
      return
    endif
    File1Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, DFACC_READ, FileName=File1, &
       & hdfVersion=the_hdfVersion1, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(File1) // ' for diff')
    File2Handle = mls_io_gen_openF(l_swath, .TRUE., status, &
       & record_length, DFACC_READ, FileName=File2, &
       & hdfVersion=the_hdfVersion2, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(File2) // ' for diff')
d3801 5
a3805 1
    ! Loop over swaths in file 1
d3807 1
a3807 56
    do i = 1, noSwaths
      call GetStringElement (trim(swathList1), swath, i, countEmpty )
      if ( len_trim(swath) < 1 ) then
        if ( .not. mySilent ) call output('(Ignoring blank swath name in ' // &
          &  trim(File1), advance='yes')
        cycle
      endif
      swath2 = swath
      status = stringElementNum(rename, trim(swath), countEmpty)
      if ( status < 1 ) then
        if ( .not. myForce ) then
          if ( .not. mySilent ) call output('Swath ' // trim(swath) // ' not found in ' // &
            & trim(File2), advance='yes')
          cycle
        elseif ( .not. mySilent) then
          call GetStringElement (trim(rename), swath2, i, countEmpty )
          call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
          call output( '---- swath(1) name: ' // trim(swath) // ' ----', advance='yes')
          call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
          call output( '     swath(2) name: ' // trim(swath2)// '     ', advance='yes')
          call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
        endif
      elseif( .not. mySilent ) then
        call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
        call output( '---- swath name: ' // trim(swath) // ' ----', advance='yes')
        call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
      endif
      call ReadL2GPData ( File1Handle, trim(swath), l2gp1, &
           & hdfVersion=the_hdfVersion1 )
      call ReadL2GPData ( File2Handle, trim(swath2), l2gp2, &
           & hdfVersion=the_hdfVersion2 )
      if ( present(chunks) .and. present(pressures) ) then
        call Diff( l2gp1, l2gp2, pressures=pressures, chunks=chunks, &
        & details=details, wholeArray=wholeArray, rms=rms, stats=stats, &
        & ignoreBadChunks=ignoreBadChunks, fields=fields, &
        & silent=silent, verbose=verbose, &
        & numDiffs=numDiffs )
      elseif ( present(chunks) ) then
        call Diff( l2gp1, l2gp2, chunks=chunks, &
        & details=details, wholeArray=wholeArray, rms=rms, stats=stats, &
        & ignoreBadChunks=ignoreBadChunks, fields=fields, &
        & silent=silent, verbose=verbose, &
        & numDiffs=numDiffs )
      elseif ( present(pressures) ) then
        call Diff( l2gp1, l2gp2, pressures=pressures, &
        & details=details, wholeArray=wholeArray, rms=rms, stats=stats, &
        & ignoreBadChunks=ignoreBadChunks, fields=fields, &
        & silent=silent, verbose=verbose, &
        & numDiffs=numDiffs )
      else
        call Diff( l2gp1, l2gp2, &
        & details=details, wholeArray=wholeArray, rms=rms, stats=stats, &
        & ignoreBadChunks=ignoreBadChunks, fields=fields, &
        & matchTimes=matchTimes, silent=silent, verbose=verbose, &
        & numDiffs=numDiffs )
      endif
d3809 1
a3809 53
      if ( present(numDiffs) ) myNumDiffs = myNumDiffs + numDiffs
      call DestroyL2GPContents ( l2gp1 )
      call DestroyL2GPContents ( l2gp2 )
    enddo
    status = mls_io_gen_closeF(l_swath, File1Handle, FileName=File1, &
      & hdfVersion=the_hdfVersion1, debugOption=.false.)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(File1) // ' after diff')
    status = mls_io_gen_closeF(l_swath, File2Handle, FileName=File2, &
      & hdfVersion=the_hdfVersion1, debugOption=.false.)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(File2) // ' after diff')
    if ( present(numDiffs) ) numDiffs = myNumDiffs
  end subroutine DiffL2GPFiles_Name
    
  ! ------------------------------------------ DiffStatsInt ------------
  subroutine DiffStatsInt ( array1, array2, arrayName )
    ! Show diff between arrays 1 and 2: num diff num same, pctages
    integer, dimension(:), intent(in) :: array1
    integer, dimension(:), intent(in) :: array2
    character(len=*), intent(in) :: arrayName
    ! Internal variables
    integer :: numSame
    integer :: numDiff
    real :: pctSame
    real :: pctDiff
    ! Executable
    call output('Differences between (1) and (2) integer arrays ' &
      & // trim(arrayName), advance='yes')
    if ( size(array1) /= size(array2) ) then
      call output('(arrays (1) and (2) different lengths)', advance='yes')
      return
    endif
    numDiff = count(array1 /= array2)
    numSame = size(array1) - numDiff
    pctDiff = 100*numDiff/(0.+numDiff+numSame)
    pctSame = 100. - pctDiff
    call output(numSame, advance = 'no')
    call blanks(2, advance='no')
    call output('same', advance = 'no')
    call blanks(4, advance='no')
    call output(numDiff, advance = 'no')
    call blanks(2, advance='no')
    call output('different', advance = 'no')
    call blanks(4, advance='no')
    call output(pctSame, advance = 'no')
    call output('%  same', advance = 'no')
    call blanks(4, advance='no')
    call output(pctDiff, advance = 'no')
    call output('%  different', advance = 'yes')
  end subroutine DiffStatsInt
d3811 1
a3811 1
  ! ------------------------------------------ DUMP_L2GP_DATABASE ------------
d3813 5
a3817 1
  subroutine DUMP_L2GP_DATABASE ( L2gp, Name, ColumnsOnly, Details, Fields )
d3819 6
a3824 6
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          L2GP(:)
    character(len=*), intent(in), optional :: Name
    logical, intent(in), optional ::          ColumnsOnly ! if true, dump only with columns
    integer, intent(in), optional :: DETAILS
    character(len=*), intent(in), optional :: fields ! ,-separated list of names
d3826 4
a3829 7
    ! Local variables
    integer :: i
    call output ( '============ L2GP Data Base ============', advance='yes' )
    call output ( ' ', advance='yes' )
    if ( present(name) ) then
      call output ( 'L2GP Database name: ', advance='no' )
      call output ( name, advance='yes' )
d3831 12
a3842 3
    if ( size(l2gp) < 1 ) then
      call output ( '**** L2GP Database empty ****', advance='yes' )
      return
d3844 13
a3856 3
    do i = 1, size(l2gp)
      call dump(l2gp(i), ColumnsOnly, Details, Fields)
    end do
d3858 6
a3863 1
  end subroutine DUMP_L2GP_DATABASE
d3865 7
a3871 1
  ! ------------------------------------------ DUMP_L2GP_CHUNKS ------------
d3873 1
d3875 2
a3876 12
  subroutine DUMP_L2GP_CHUNKS ( fullL2gp, Chunks, ColumnsOnly, Details, Fields )
    ! Dump selected chunks of an l2gp
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          FULLL2GP
    integer, intent(in), dimension(:) :: Chunks ! Which chunks to dump
    logical, intent(in), optional ::          ColumnsOnly ! if true, dump only with columns
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but name
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 1
    character(len=*), intent(in), optional :: fields ! ,-separated list of names
d3878 2
a3879 22
    ! Local variables
    integer :: chunk
    integer :: i
    integer, dimension(2) :: irange
    type (l2gpData_T) ::          L2GP
    ! Executable
    do i=1, size(Chunks)
      chunk = Chunks(i)
      irange(1) = FindFirst( fullL2gp%chunkNumber, chunk )
      irange(2) = Findlast( fullL2gp%chunkNumber, chunk )
      ! HuntRange does not work correctly when any chunk Numbers are -999
      ! (Missing Value)
      ! call HuntRange( fullL2gp%chunkNumber, (/ chunk, chunk /), irange )
      if ( any( irange == 0 ) ) cycle
      call output ( ' - - - Chunk number:', advance='no')
      call output ( chunk, advance='no')
      call output ( ' - - -', advance='yes')
      call ExtractL2GPRecord ( fullL2gp, l2gp, rTimes=irange )
      call Dump ( L2gp, ColumnsOnly, Details, Fields )
      call DestroyL2GPContents( l2gp )
    enddo
  end subroutine DUMP_L2GP_CHUNKS
d3881 2
a3882 1
  ! ------------------------------------------ DUMP_L2GP ------------
d3884 9
a3893 22
  subroutine Dump_L2GP ( L2gp, ColumnsOnly, Details, Fields )
    ! Dump an l2gp
    ! Either according to level of detail set by Details
    ! or else just those fields named in Fields
    ! Note: 'solarTime' among Fields will also provoke dumping 'time'
    ! Dummy arguments
    type (l2gpData_T), intent(in) ::          L2GP
    logical, intent(in), optional ::          ColumnsOnly ! if true, dump only with columns
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but name
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 1
    character(len=*), intent(in), optional :: fields ! ,-separated list of names

    ! Local variables
    integer :: ierr
    logical :: myColumnsOnly
    integer :: MYDETAILS
    real(r8) :: FillValue
    integer :: ChunkFillValue
    character(len=Len(DATA_FIELDS)+Len(GEO_FIELDS)) :: myFields
d3895 3
a3897 14
    ! Executable code
    myDetails = 1
    if ( present(details) ) myDetails = details
    myFields = ' '
    if ( present(fields) ) then
      myFields = fields
      if ( .not. present(details) ) myDetails = 2
    endif
    
    if( present(ColumnsOnly)) then
      myColumnsOnly = ColumnsOnly
    else
      myColumnsOnly = .false.
    endif
d3899 2
a3900 113
    if ( myColumnsOnly .and. l2gp%nLevels > 1 ) return
    
    FillValue = real(l2gp%MissingValue, r8)
    ChunkFillValue = int(l2gp%MissingValue)
    if ( showMe(.true., myFields, 'swathname') ) then
      call output ( 'L2GP Data: (swath name) ')
      call output ( trim(l2gp%name) )
      if ( NAMEINDEXEVERSET ) then
        call output ( ', (parser name) ')
        if(l2gp%nameIndex > 0) then
          call display_string ( l2gp%nameIndex, advance='yes', IERR=ierr)
          if ( ierr /= 0 ) call output ( '(not found in string table)', &
           & advance='yes')
        else
          call output ( '(the nameIndex was 0) ', advance='yes')
        endif
      else
        call output ( ' ', advance='yes')
      endif
    endif
    if ( showMe(.true., myFields, 'quantitytype') ) then
      call output ( 'Quantity type: ')
      if ( l2gp%QuantityType > 0 ) then
        call display_string ( lit_indices(l2gp%QuantityType), &
          &             strip=.true., advance='yes' )
      else
        call output ( '(the QType Index was 0) ', advance='yes')
      endif
    endif
    !  if ( myDetails < -1 ) return
    if ( showMe(myDetails > -2, myFields, 'ntimes') ) then
      call output ( 'nTimes: ')
      call output ( l2gp%nTimes, 5)
      call output ( '  nTimesTotal: ')
      call output ( l2gp%nTimesTotal, 5)
      call output ( '  nLevels: ')
      call output ( l2gp%nLevels, 3)
      call output ( '  nFreqs: ')
      call output ( l2gp%nFreqs, 3, advance='yes')
      call output ( 'Fill/Missing Values: ')
      call output ( l2gp%MissingValue, advance='yes')
      call output ( 'Fill/Missing Status Field: ')
      call output ( l2gp%MissingStatus, advance='yes')
     endif
    
     ! if ( myDetails < 0 ) return
    if ( showMe(myDetails > -1, myFields, 'pressure') ) &
      & call dump ( l2gp%pressures, trim(l2gp%verticalCoordinate) // 's:' )
      
    if ( showMe(myDetails > -1, myFields, 'latitude') ) &
      & call dump ( l2gp%latitude, 'Latitude:' )
      
    if ( showMe(myDetails > -1, myFields, 'longitude') ) &
      & call dump ( l2gp%longitude, 'Longitude:' )
      
    if ( showMe(myDetails > -1, myFields, 'solartime') ) &
      & call dump ( l2gp%solarTime, 'SolarTime:' )
      
    if ( showMe(myDetails > -1, myFields, 'solarzenith') ) &
      & call dump ( l2gp%solarZenith, 'SolarZenith:' )
      
    if ( showMe(myDetails > -1, myFields, 'LOSAngle') ) &
      & call dump ( l2gp%losAngle, 'LOSAngle:' )
      
    if ( showMe(myDetails > -1, myFields, 'geodAngle') ) &
      & call dump ( l2gp%geodAngle, 'geodAngle:' )
      
    if ( showMe(myDetails > -1, myFields, 'time') ) &
      & call dump ( l2gp%time, 'Time:' )
      
    if ( showMe(myDetails > -1, myFields, 'chunkNumber') ) &
      & call dump ( l2gp%chunkNumber, 'ChunkNumber:' )
      
      if ( showMe(myDetails > -1, myFields, 'pressure') .and. &
        & associated(l2gp%frequency) ) &
        & call dump ( l2gp%frequency, 'Frequencies:' )
      
      ! if ( myDetails < 1 ) return
    if ( showMe(myDetails > 0, myFields, 'l2gpvalue') ) &
      & call dump ( real(l2gp%l2gpValue, r8), 'L2GPValue:', &
        & FillValue=FillValue )
      
    if ( showMe(myDetails > 0, myFields, 'l2gpprecision') ) &
      & call dump ( real(l2gp%l2gpPrecision, r8), 'L2GPPrecision:', &
        & FillValue=FillValue )
      
    if ( showMe(myDetails > 0, myFields, 'status') ) &
      & call dump ( l2gp%status, 'Status:' )
      
    if ( showMe(myDetails > 0, myFields, 'quality') ) &
      & call dump ( l2gp%quality, 'Quality:' )
      
    if ( showMe(myDetails > 0, myFields, 'convergence') ) &
      & call dump ( l2gp%convergence, 'Convergence:' )
      
  contains
    logical function showMe(detailsOK, fields, field)
      ! Determine whether this field should be dumped or not
      ! depending on whether you're going by details or by picking fields
      logical, intent(in) :: detailsOK
      character(len=*), intent(in) :: fields
      character(len=*), intent(in) :: field
      !
      if ( len_trim(fields) < 1 ) then
        showMe = detailsOK
      else
        showMe = ( index(LowerCase(fields), LowerCase(trim(field))) > 0 )
      endif
    end function showMe
  end subroutine Dump_L2GP
    
  !----------------------------------------  DumpL2GP_attributes_hdf5  -----
  subroutine DumpL2GP_attributes_hdf5(l2FileHandle, l2gp, swathName)
d3902 5
a3906 4
  use HDFEOS5, only: HE5T_NATIVE_REAL, HE5T_NATIVE_DOUBLE
  use he5_swapi, only: he5_swrdattr, he5_swrdlattr
  use MLSHDFEOS, only: mls_swattach, mls_swdetach
  use PCFHdr, only:  GlobalAttributes_T, he5_readglobalattr
d3908 1
a3908 1
    ! This subroutine dumps the attributes for an l2gp
d3917 3
a3919 2
    integer, intent(in) :: l2FileHandle ! From swopen
    character (len=*), optional, intent(IN) :: swathName ! Defaults->l2gp%name
d3921 2
a3923 5
    type (GlobalAttributes_T)         :: gAttributes
    character(len=255)                :: ProcessLevel
    integer                           :: DayofYear
    double precision                  :: TAI93At0zOfGranule
    real(rgp), dimension(MAXNLEVELS)  :: pressures
d3950 3
d3954 1
d3956 1
d3958 1
d3961 1
a3963 1
    character(len=CHARATTRLEN) :: field_name
a3964 5
    character(len=CHARATTRLEN) :: uniqueness
    character(len=CHARATTRLEN) :: species_name
    character(len=CHARATTRLEN) :: abbr_uniq_fdef
    character(len=CHARATTRLEN) :: expnd_uniq_fdef
    
d3971 1
a3971 2
    call output ( 'L2GP Attributes: (swath name) ')
    call output ( trim(name), advance='yes' )
d3978 2
a3979 1
        & 'Attributes have unrecognized numeric data type; should be r4 or r8')
d3985 3
a3987 25
    call output ( '(Global Attributes) ', advance='yes')
    call he5_readglobalattr(l2FileHandle, gAttributes, &
     & ProcessLevel, DayofYear, TAI93At0zOfGranule, status)
    if ( status /= 0 ) then
      call output ('No global attributes found in file', advance='yes')
    else
      call dump(gAttributes%orbNum, 'Orbit numbers')
      call dump(gAttributes%orbPeriod, 'Orbit Periods')
      call output ('InstrumentName: ' // trim( gAttributes%InstrumentName  ))
      call output ('Process level: ' // trim(  gAttributes%ProcessLevel    ))
      ! call output ('Input version: ' // trim(  gAttributes%inputVersion    ))
      call output ('PGE version: ' // trim(    gAttributes%PGEVersion      ))
      call output ('Start UTC: ' // trim(      gAttributes%StartUTC        ))
      call output ('End UTC: ' // trim(        gAttributes%EndUTC          ))
      call dump_int ( gAttributes%GranuleMonth, 'Granule month:' )
      call dump_int ( gAttributes%GranuleDay, 'Granule day:' )
      call dump_int ( gAttributes%GranuleYear, 'Granule year:' )
      call dump_int ( DayOfYear, 'Granule day of year:' )
      call dump_r8 ( TAI93At0zOfGranule, 'Equator crossing time (tai93):' )
    endif
    swid = mls_SWattach (l2FileHandle, name, hdfVersion=HDFVERSION_5)
    if ( swid == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to attach swath ' // trim(name))
    end if
d3990 9
a3998 5
    call output ( '(Swath Attributes) ', advance='yes')
    status = he5_swrdattr(swid, 'Pressure', pressures)
    call dump ( pressures, 'Vertical coordinates:' )
    status = he5_swrdattr(swid, 'VerticalCoordinate', field_name)
    call dump_chars ( field_name, 'Vertical coordinates type:' )
d4001 1
a4001 1
    call output ( '(Geolocation Attributes) ', advance='yes')
d4011 3
d4020 6
a4025 4
        status = he5_swrdlattr(swid, trim(theTitles(field)), 'Title', field_name)
        status = he5_swrdlattr(swid, trim(theTitles(field)), 'Units', units_name)
        call dump_chars ( field_name, 'Field title:' )
        call dump_chars ( units_name, 'Units:' )
d4027 22
a4048 3
        status = he5_swrdlattr(swid, trim(theTitles(field)), &
          & 'UniqueFieldDefinition', uniqueness)
        call dump_chars ( uniqueness, 'Unique field definition:' )
d4051 1
d4053 2
a4054 1
    call output ( '(Data Attributes) ', advance='yes')
d4056 6
a4061 2
    species_name = name
    isColumnAmt = ( index(species_name, 'Column') > 0 )
d4063 13
a4075 1
      call ExtractSubString(Name, species_name, 'Column', 'wmo')
d4077 2
d4080 1
a4080 1
      & SpUniqueFieldDefinition, trim(lowercase(species_name)), &
d4085 2
d4097 34
a4130 15
    if ( isColumnAmt ) units_name = 'DU'
    status = he5_swrdlattr(swid, 'L2gpValue', 'Title', field_name)
    status = he5_swrdlattr(swid, 'L2gpValue', 'Units',  units_name)
    status = he5_swrdlattr(swid, 'L2gpValue', &
      & 'UniqueFieldDefinition', uniqueness)
    call dump_chars ( field_name, 'Field title:' )
    call dump_chars ( units_name, 'Units:' )
    call dump_chars ( uniqueness, 'Unique field definition:' )
    status = he5_swrdlattr(swid, 'L2gpPrecision', 'Title', field_name)
    status = he5_swrdlattr(swid, 'L2gpPrecision', 'Units', units_name)
    status = he5_swrdlattr(swid, 'L2gpPrecision', &
      & 'UniqueFieldDefinition', uniqueness)
    call dump_chars ( field_name, 'Field title:' )
    call dump_chars ( units_name, 'Units:' )
    call dump_chars ( uniqueness, 'Unique field definition:' )
d4133 20
a4152 7
    status = he5_swrdlattr(swid, 'Status', 'Title', field_name)
    status = he5_swrdlattr(swid, 'Status', 'Units', units_name)
    status = he5_swrdlattr(swid, 'Status', &
      & 'UniqueFieldDefinition', uniqueness)
    call dump_chars ( field_name, 'Field title:' )
    call dump_chars ( units_name, 'Units:' )
    call dump_chars ( uniqueness, 'Unique field definition:' )
d4154 9
a4162 7
    status = he5_swrdlattr(swid, 'Quality', 'Title', field_name)
    status = he5_swrdlattr(swid, 'Quality', 'Units', units_name)
    status = he5_swrdlattr(swid, 'Quality', &
      & 'UniqueFieldDefinition', uniqueness)
    call dump_chars ( field_name, 'Field title:' )
    call dump_chars ( units_name, 'Units:' )
    call dump_chars ( uniqueness, 'Unique field definition:' )
d4167 1
a4167 1
            & 'Failed to detach  from swath interface' )
d4169 1
a4169 25
    contains
    subroutine dump_chars(value, name)
      ! arguments
      character(len=*), intent(in) :: value
      character(len=*), intent(in) :: name
      ! Executable
      call output(trim(name) // ' ', advance='no')
      call output(trim(value), advance='yes')
    end subroutine dump_chars
    subroutine dump_int(value, name)
      ! arguments
      integer, intent(in) :: value
      character(len=*), intent(in) :: name
      ! Executable
      call output(trim(name) // ' ', advance='no')
      call output(value, advance='yes')
    end subroutine dump_int
    subroutine dump_r8(value, name)
      ! arguments
      real(r8), intent(in) :: value
      character(len=*), intent(in) :: name
      ! Executable
      call output(trim(name) // ' ', advance='no')
      call output(value, advance='yes')
    end subroutine dump_r8
d4172 1
a4172 1
  end subroutine DumpL2GP_attributes_hdf5
d4388 101
d4493 1
a4493 1
       "$Id: L2GPData.f90,v 2.155 2008/02/28 01:27:06 pwagner Exp $"
d4505 3
@


2.155
log
@Worked around an apparent bug in HDFEOS5 when adding to swath fields
@
text
@d2473 4
a2476 19
      ! actual_ntimes = l2gp%nTimes
      ! l2gp%nTimes = max(myLastProfile - offset + 1, 1)
      if ( .not. swath_exists ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & "You already wrote when you created a swath in AppendL2GPData" )
      else
        call OutputL2GP_writeGeo_MF (l2gp, l2GPFile, &
          & myswathName, offset)
        call OutputL2GP_writeData_MF (l2gp, l2GPFile, &
          & myswathName, offset)
        ! Write the swath all over again if we
        ! expect the HDFEOS bug to take effect
        !if ( l2gp%nTimes > numProfs ) then
        !  call OutputL2GP_writeGeo_MF (l2gp, l2GPFile, &
        !    & myswathName, offset)
        !  call OutputL2GP_writeData_MF (l2gp, l2GPFile, &
        !    & myswathName, offset)
        !endif
      endif
d4490 1
a4490 1
       "$Id: L2GPData.f90,v 2.154 2008/01/24 23:33:04 pwagner Exp $"
d4502 3
@


2.154
log
@when diffing, matchtimes will try to match either times or geod. angle
@
text
@d34 2
a35 1
  use Output_M, only: blanks, Output, resumeOutput, suspendOutput
d137 1
d619 56
d676 1
a1070 5
!    if ( index(list,'Unlim') /= 0 ) then 
!      timeIsUnlim = .TRUE.
!    else
!      timeIsUnlim = .FALSE.
!    endif
d1073 1
d1082 3
d1393 3
a1395 1

d1409 1
a1409 1
      chunkTimes = max ( min ( 120, l2gp%nTimes ), 1 )
d1411 1
a1411 1
      chunktimes = 120      ! was 1
d1423 2
a1424 1
    if ( DEEBUG )  print *, 'About to sw_create ', TRIM(name)
d1485 1
d1578 1
d1581 1
d1589 1
d1597 1
d1667 6
d1772 5
d2371 1
d2377 1
d2420 11
d2475 17
a2491 4
      call OutputL2GP_writeGeo_MF (l2gp, l2GPFile, &
        & myswathName, offset)
      call OutputL2GP_writeData_MF (l2gp, l2GPFile, &
        & myswathName, offset)
d2505 7
d4505 1
a4505 1
       "$Id: L2GPData.f90,v 2.153 2008/01/07 21:37:23 pwagner Exp $"
d4517 3
@


2.153
log
@Replace DEFAULTUNDEFINEDVALUE with user-settable undefinedValue
@
text
@d2992 1
d2995 7
a3001 1
        return
d4395 1
a4395 1
       "$Id: L2GPData.f90,v 2.152 2007/12/19 01:29:37 pwagner Exp $"
d4407 3
@


2.152
log
@Removed unused args
@
text
@d20 1
a20 1
  use MLSCommon, only: I4, R4, R8, DEFAULTUNDEFINEDVALUE, MLSFile_T
a142 1
  real, parameter    :: UNDEFINED_VALUE = DEFAULTUNDEFINEDVALUE !-999.99 ! Same as %template%badvalue
d278 1
a278 1
     real (rgp)                        :: MissingValue = UNDEFINED_VALUE
d4388 1
a4388 1
       "$Id: L2GPData.f90,v 2.151 2007/10/10 00:00:51 pwagner Exp $"
d4400 3
@


2.151
log
@DumpL2GPData ought not to override optional parameter details if supplied
@
text
@d27 1
a27 3
    & MLSMSG_L1BREAD, MLSMSG_Warning, &
    & MLSMessage, MLSMessageCalls
  use MLSNumerics, only: HuntRange
d824 1
a824 1
       & hmot=hmot)
d1263 1
a1263 1
  subroutine writeL2GPData_fileID(l2gp, l2FileHandle, swathName, filename, hdfVersion, &
a1270 1
    character (LEN=*), optional, intent(IN) ::fileName
d1301 1
a1301 1
  use MLSHDFEOS, only: mls_swattach, mls_swdetach, &
a1335 2
    integer, external :: he5_SWgetfill
    ! integer, external :: he5_swsetfill
d2135 1
a2135 1
    & swathName, filename, offset, lastProfile, TotNumProfs, hdfVersion, &
a2152 1
    character (LEN=*), optional, intent(IN) ::fileName
d2249 1
a2249 1
      & FileName, offset, lastProfile=lastProfile, totNumProfs=totNumProfs, &
d2365 1
a2365 1
         & 'Illegal hdf version in AppendL2GPData_fileID', MLSFile=L2GPFile)
d4389 1
a4389 1
       "$Id: L2GPData.f90,v 2.150 2007/08/13 17:36:38 pwagner Exp $"
d4401 3
@


2.150
log
@Push some procedures onto new MLSCallStack
@
text
@d3820 1
a3820 1
      myDetails = 2
d4395 1
a4395 1
       "$Id: L2GPData.f90,v 2.149 2007/06/26 00:20:14 pwagner Exp $"
d4407 3
@


2.149
log
@May specify pressure levels on which to show diffs
@
text
@d26 3
a28 2
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    & MLSMSG_Error, MLSMSG_Warning
d963 2
a964 1

d1257 1
a1257 2


d2107 1
d2135 1
d2308 1
d2413 1
d4395 1
a4395 1
       "$Id: L2GPData.f90,v 2.148 2007/05/30 22:03:41 pwagner Exp $"
d4407 3
@


2.148
log
@HuntRange does not work correctly when list has missing values; workaround employed
@
text
@d57 1
a2796 1

d2854 2
a2855 2
      call output( 'irange: ', advance='no' )
      call output( irange, advance='yes' )
d2858 2
a2859 2
      call output( 'nTimes: ', advance='no' )
      call output( l2gp1%nTimes, advance='yes' )
d2868 77
d3356 1
a3356 1
  subroutine DiffL2GPFiles_MLSFile ( L2GPFile1, L2GPFile2, chunks, &
d3364 1
d3409 1
a3409 1
    if ( present(chunks) ) then
d3411 1
d3418 16
d3455 1
a3455 1
  subroutine DiffL2GPFiles_Name ( file1, file2, chunks, &
d3463 1
d3635 7
a3641 1
      if ( present(chunks) ) then
d3647 6
d4390 1
a4390 1
       "$Id: L2GPData.f90,v 2.147 2007/02/26 23:58:48 pwagner Exp $"
d4402 3
@


2.147
log
@New optional arg diffs only at matching profile times
@
text
@d29 1
a29 1
  use MLSSets, only: FindIntersection
d2841 7
a2847 1
      call HuntRange( fullL2gp1%chunkNumber, (/ chunk, chunk /), irange )
d2854 2
d2858 2
d3660 5
a3664 1
      call HuntRange( fullL2gp%chunkNumber, (/ chunk, chunk /), irange )
d4282 1
a4282 1
       "$Id: L2GPData.f90,v 2.146 2007/02/13 21:57:08 pwagner Exp $"
d4294 3
@


2.146
log
@Added convergence to defaultfields
@
text
@d29 1
d148 2
a149 1
  integer, parameter :: MAXNLEVELS = 1000
d422 1
a422 1
    & FillIn )
d425 2
d430 4
a433 4
    integer, intent(in), optional :: nFreqs            ! Dimensions
    integer, intent(in), optional :: nLevels           ! Dimensions
    integer, intent(in), optional :: nTimes            ! Dimensions
    integer, intent(in), optional :: nTimesTotal       ! Dimensions
d435 2
d444 2
d452 2
d460 6
d472 2
d480 2
d533 51
a583 16
    if ( .not. myFillIn ) return
    l2gp%pressures    = l2gp%MissingValue
    l2gp%frequency    = l2gp%MissingValue
    l2gp%latitude     = l2gp%MissingValue
    l2gp%longitude    = l2gp%MissingValue
    l2gp%solarTime    = l2gp%MissingValue
    l2gp%losAngle     = l2gp%MissingValue
    l2gp%geodAngle    = l2gp%MissingValue
    l2gp%time         = l2gp%MissingValue
    l2gp%chunkNumber  = l2gp%MissingValue
    l2gp%l2gpValue    = l2gp%MissingValue
    l2gp%l2gpPrecision= l2gp%MissingValue
    l2gp%status       = l2gp%MissingStatus ! l2gp%MissingValue
    l2gp%quality      = l2gp%MissingValue
    l2gp%convergence  = l2gp%MissingValue

d2851 2
a2852 2
        & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, &
        & verbose, numDiffs )
d2860 67
a3058 78
      if ( any(l2gp1%pressures /= l2gp2%pressures) .and. &
        & SwitchDetail(lowercase(myFields), 'pressure', '-c') > -1 ) then
          call diff ( l2gp1%pressures, 'l2gp%pressures', &
            &         l2gp2%pressures, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%pressures /= l2gp2%pressures )
      endif
      if ( any(l2gp1%latitude /= l2gp2%latitude) .and. &
        & SwitchDetail(lowercase(myFields), 'lat', '-c') > -1 ) then
          call diff ( l2gp1%latitude, 'l2gp%latitude', &
            &         l2gp2%latitude, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%latitude /= l2gp2%latitude )
      endif
      if ( any(l2gp1%longitude /= l2gp2%longitude) .and. &
        & SwitchDetail(lowercase(myFields), 'lon', '-c') > -1 ) then
          call diff ( l2gp1%longitude, 'l2gp%longitude', &
            &         l2gp2%longitude, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%longitude /= l2gp2%longitude )
      endif
      if ( any(l2gp1%solarTime /= l2gp2%solarTime) .and. &
        & SwitchDetail(lowercase(myFields), 'solartime', '-c') > -1 ) then
          call diff ( l2gp1%solarTime, 'l2gp%solarTime', &
            &         l2gp2%solarTime, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%solarTime /= l2gp2%solarTime )
      endif
      if ( any(l2gp1%solarZenith /= l2gp2%solarZenith) .and. &
        & SwitchDetail(lowercase(myFields), 'solarzenith', '-c') > -1 ) then
          call diff ( l2gp1%solarZenith, 'l2gp%solarZenith', &
            &         l2gp2%solarZenith, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        badChunks = .true.
        myNumDiffs = myNumDiffs + count( l2gp1%solarZenith /= l2gp2%solarZenith )
      endif
      if ( any(l2gp1%losAngle /= l2gp2%losAngle) .and. &
        & SwitchDetail(lowercase(myFields), 'losangle', '-c') > -1 ) then
          call diff ( l2gp1%losAngle, 'l2gp%losAngle', &
            &         l2gp2%losAngle, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%losAngle /= l2gp2%losAngle )
      endif
      if ( any(l2gp1%geodAngle /= l2gp2%geodAngle) .and. &
        & SwitchDetail(lowercase(myFields), 'geodangle', '-c') > -1 ) then
          call diff ( l2gp1%geodAngle, 'l2gp%geodAngle', &
            &         l2gp2%geodAngle, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        badChunks = .true.
        myNumDiffs = myNumDiffs + count( l2gp1%geodAngle /= l2gp2%geodAngle )
      endif
      if ( any(l2gp1%time /= l2gp2%time) .and. &
        & SwitchDetail(lowercase(myFields), 'time', '-c') > -1 ) then
          call diff ( l2gp1%time, 'l2gp%time', &
            &         l2gp2%time, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        badChunks = .true.
        myNumDiffs = myNumDiffs + count( l2gp1%time /= l2gp2%time )
      endif
      if ( any(l2gp1%chunkNumber /= l2gp2%chunkNumber) .and. &
        & SwitchDetail(lowercase(myFields), 'chunknumber', '-c') > -1 ) then
        call diff ( l2gp1%chunkNumber, 'l2gp1%chunkNumber', &
          &         l2gp2%chunkNumber, 'l2gp2%chunkNumber', &
          & wholearray=wholearray, stats=stats, rms=rms )
        ! call dump ( l2gp1%chunkNumber - l2gp2%chunkNumber, &
        !  & 'l2gp%chunkNumber (diff)', stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%chunkNumber /= l2gp2%chunkNumber )
      endif
      
      if ( associated(l2gp1%frequency) .and.  associated(l2gp2%frequency)) then
        if ( any(l2gp1%frequency /= l2gp2%frequency) .and. &
          & SwitchDetail(lowercase(myFields), 'freq', '-c') > -1 ) then
          call diff ( l2gp1%frequency, 'l2gp%frequency', &
            &         l2gp2%frequency, ' ', &
            & wholearray=wholearray, stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%frequency /= l2gp2%frequency )
        endif
      endif
d3062 4
a3074 9
      if ( myDetails < 1 )  then
        call doneHere
        return
      endif
      ! This is a very bad idea--to redefine arrays in a procedure
      ! whose ostensible purpose is merely to dump them
      ! It would be smarter to allocate a temp array and use
      ! that, remembering to deallocate it before returning
      
d3076 1
a3076 8
      call SetupNewL2GPRecord ( l2gp2Temp, l2gp2%nFreqs, l2gp2%nLevels, &
        & l2gp2%nTimes )
      ! Transfer values to new temporary
      l2gp2Temp%l2gpValue       = l2gp2%l2gpValue
      l2gp2Temp%l2gpPrecision   = l2gp2%l2gpPrecision
      l2gp2Temp%status          = l2gp2%status
      l2gp2Temp%quality         = l2gp2%quality
      l2gp2Temp%convergence     = l2gp2%convergence
d3085 4
d3097 10
d3113 7
d3172 88
a3262 3
contains
    subroutine doneHere
      ! Housekeeping
d3266 1
a3266 1
  end subroutine DiffL2GPData
d3271 2
a3272 2
    & swList, showMissing, fields, force, swaths1, swaths2, silent, &
    & verbose, numDiffs )
d3296 1
d3327 2
a3328 1
      & silent=silent, verbose=verbose, numDiffs=numDiffs )
d3335 2
a3336 1
      & silent=silent, verbose=verbose, numDiffs=numDiffs )
d3352 2
a3353 2
    & swList, showMissing, fields, force, swaths1, swaths2, silent, &
    & verbose, numDiffs )
d3377 1
d3533 2
a3534 1
        & silent=silent, verbose=verbose, numDiffs=numDiffs )
d3539 2
a3540 1
        & silent=silent, verbose=verbose, numDiffs=numDiffs )
d4268 1
a4268 1
       "$Id: L2GPData.f90,v 2.145 2006/10/11 00:16:33 pwagner Exp $"
d4280 3
@


2.145
log
@Added new data field to hold convergence ratio
@
text
@d2840 1
a2840 1
      & 'l2gpvalue, l2gpPrecision, status, quality'
d4124 1
a4124 1
       "$Id: L2GPData.f90,v 2.144 2006/09/29 23:56:49 pwagner Exp $"
d4136 3
@


2.144
log
@Got rid of unused GetGeolocUnits function
@
text
@d144 1
d146 1
d154 1
a154 1
   ! This is the above except for Status which has proved troublesome
d156 1
a156 1
     & 'L2gpValue,L2gpPrecision,Quality,Status'
a268 4
     ! We always write this data field
     ! However, because some l2gp files were created incorrectly,
     ! It takes a special forcing option to read it
     ! character (len=1), pointer, dimension(:) :: status=>NULL()
d273 2
a274 1
     ! Both the above dimensioned (nTimes)
a275 4
     ! The dimensions for the quantity (if, e.g., coming from l2cf)
     ! character(len=CHARATTRLEN)        :: DIM_Names = '' ! ','-separated
     ! character(len=CHARATTRLEN)        :: DIM_Units = '' ! ','-separated
     ! character(len=CHARATTRLEN)        :: VALUE_Units = '' 
d389 1
d415 1
d512 1
d526 2
a527 2
    ! l2gp%status = ' '
    l2gp%quality = l2gp%MissingValue
d555 1
d604 1
a604 1
      & l2gp%l2gpPrecision, l2gp%status, l2gp%quality )
d632 1
d850 1
a850 1
  use HDFEOS5, only: HE5_SWINQDIMS, HE5_swfldinfo
d852 1
d858 3
a860 7
    ! All the ReadStatus harrumphing is because
    ! (1) An earlier version always core dumped
    ! (2) Even this version dumps core while reading l2gp files which stored
    !     the 'Status' field as 32-bit floats instead of chars
    ! Therefore, unless you supply the optional arg ReadStatus=.true.,
    ! it will skip reading the troublesome datafield
    ! Naturally, you would do that only for correctly-formatted l2gp files
d880 2
a882 1
    character (LEN=80) :: dimlist
d887 2
d893 1
a893 1
    integer :: first, freq, lev, nDims, size, swid, status
d903 1
d915 1
d944 2
d1170 1
a1170 2
    ! l2gp%status = ' ' ! So it has a value.
    if ( ReadingStatus) &
d1180 5
a1470 2
    ! & hdfVersion=hdfVersion, iFill=int(l2gp%MissingValue))
    ! & DFNT_CHAR8, HDFE_NOMERGE, chunk_rank, chunk_dims, &
d1479 7
d1686 3
a1943 1
      ! & HE5T_NATIVE_INT, 1, (/ int(l2gp%MissingValue) /) )
a1944 2
    ! status = mls_swwrlattr(swid, 'Status', 'MissingValue', &
    !   & MLS_CHARTYPE, 1, ' ' )
a1952 1
      ! & MLS_CHARTYPE, 1, units_name)
d1959 10
d3044 1
a3092 2
        ! call dump (l2gp1%status - l2gp2%status, &
        !  & 'l2gp%status (diff)', stats=stats, rms=rms )
d3108 10
d3650 3
d3992 3
d4124 1
a4124 1
       "$Id: L2GPData.f90,v 2.143 2006/04/12 20:49:10 pwagner Exp $"
d4136 3
@


2.143
log
@nTimesTotal component now dumped, too
@
text
@a4082 39
  ! ----------------------------------  GetGeolocUnits  -----
  function GetGeolocUnits ( Title ) result( dim_string )

  ! Given a dim name type, e.g. l_vmr,
  ! returns corresponding units as a character string

    ! Dummy arguments
    character(len=*), intent(in)        :: Title
    character(len=CHARATTRLEN)                   :: dim_string

    ! Executable code
    dim_string = 'none'
    select case (Title)                                       
    case ( 'Latitude' )  
      dim_string = 'degrees'
    case ( 'Longitude' )  
      dim_string = 'degrees'
    case ( 'SolarZenithAngle' )  
      dim_string = 'degrees'
    case ( 'Time' )  
      dim_string = 'seconds'
    case ( 'LocalSolarTime' )  
      dim_string = 'seconds'
    case ( 'LineOfSightAngle' )  
      dim_string = 'degrees'
    case ( 'OrbitGeodeticAngle' )  
      dim_string = 'degrees'
    case ( 'ChunkNumber' )
      ! No units for this dimension
    case ( 'Pressure' )  
      dim_string = 'hPa'
    case ( 'Frequency' )  
      dim_string = 'GHz'

    end select                                                       

  end function GetGeolocUnits


d4087 1
a4087 1
       "$Id: L2GPData.f90,v 2.142 2006/04/06 23:04:52 pwagner Exp $"
d4099 3
@


2.142
log
@Optionally cp only ranges of freq, level, profile
@
text
@a2219 1
    ! integer :: myhdfVersion !Not used in this function
d2228 1
a2228 5
    ! Optional args should _ONLY_ appear like this, inside an IF 
    ! block that checks if they are present. HCP replaced one occurance
    ! of TotNumProfs with myLastProfile as they are equal if TotNumProfs
    ! is present and cause a crash if it is not. Another occurrance seemed 
    ! wrong anyway, so I commented it out.
a2286 1
          ! & myswathName, filename, notUnlimited=present(totNumProfs))
a2302 3
    ! This line caused an error because TotNumProfs is optional and 
    ! is not here checked for present-ness. 
    ! if ( offset == TotNumProfs .or. size(l2gp%l2gpValue,3) == 0 ) then
d3560 2
d4126 1
a4126 1
       "$Id: L2GPData.f90,v 2.141 2006/03/13 23:40:28 pwagner Exp $"
d4138 3
@


2.141
log
@verbose now an optional arg to diff
@
text
@d315 3
d328 4
d334 3
d338 9
d352 1
a352 1
    if ( present(rLevels) ) then
d358 1
a358 1
    if ( present(rTimes) ) then
d2346 1
a2346 1
    & HGrid, options)
d2365 3
d2374 4
d2434 26
d2461 3
a2463 2
      call WriteL2GPData(l2gp, file2, trim(swath2), hdfVersion=hdfVersion2, &
        & notUnlimited=notUnlimited)
d2473 2
a2474 1
    & notUnlimited, andGlAttributes, ReadStatus, HGrid, options)
d2500 3
d2626 2
a2627 1
      & ReadStatus=ReadStatus, HGrid=HGrid, options=options )
d2651 2
a2652 1
    & notUnlimited, andGlAttributes, ReadStatus, HGrid, options)
d2673 3
d2712 2
a2713 1
      & notUnlimited, andGLAttributes, ReadStatus, HGrid, options)
d4133 1
a4133 1
       "$Id: L2GPData.f90,v 2.140 2006/02/28 21:44:44 pwagner Exp $"
d4145 3
@


2.140
log
@Diff works better, added IsL2GPSetUp
@
text
@d2667 2
a2668 1
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, numDiffs )
d2686 1
d2720 2
a2721 1
        & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, numDiffs )
d2729 2
a2730 1
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields, silent, numDiffs )
d2756 1
d2772 1
d2789 2
d2850 2
d2865 1
a2865 1
            & stats=stats, rms=rms )
d2872 1
a2872 1
            & stats=stats, rms=rms )
d2879 1
a2879 1
            & stats=stats, rms=rms )
d2886 1
a2886 1
            & stats=stats, rms=rms )
d2893 1
a2893 1
            & stats=stats, rms=rms )
d2901 1
a2901 1
            & stats=stats, rms=rms )
d2908 1
a2908 1
            & stats=stats, rms=rms )
d2916 1
a2916 1
            & stats=stats, rms=rms )
d2924 1
a2924 1
          & stats=stats, rms=rms )
d2935 1
a2935 1
            & stats=stats, rms=rms )
d2994 1
a2994 1
          & stats=stats, rms=rms, fillValue=l2gp1%MissingValue )
d2996 3
d3004 1
a3004 1
          & stats=stats, rms=rms, fillValue=l2gp1%MissingValue )
d3006 3
d3015 1
a3015 1
          & stats=stats, rms=rms )
d3019 3
d3027 1
a3027 1
          & stats=stats, rms=rms )
d3029 3
d3048 2
a3049 1
    & swList, showMissing, fields, force, swaths1, swaths2, silent, numDiffs )
d3074 1
d3103 1
a3103 1
      & silent=silent, numDiffs=numDiffs )
d3110 1
a3110 1
      & silent=silent, numDiffs=numDiffs )
d3126 2
a3127 1
    & swList, showMissing, fields, force, swaths1, swaths2, silent, numDiffs )
d3152 1
d3306 1
a3306 1
        & silent=silent, numDiffs=numDiffs )
d3311 1
a3311 1
        & silent=silent, numDiffs=numDiffs )
d4070 1
a4070 1
       "$Id: L2GPData.f90,v 2.139 2006/02/21 19:09:25 pwagner Exp $"
d4082 3
@


2.139
log
@GetHashElement is now a generic
@
text
@a18 1
  use HDFEOS, only: SWINQDIMS
d25 1
a25 1
  use MLSFillValues, only: ExtractArray, ReplaceFillValues
d44 1
a44 1
    & ExpandL2GPDataInPlace, ExtractL2GPRecord, &
d118 1
d377 25
d830 1
d2689 1
d2697 9
a2727 3
    ! Assumes fields of each already allocated
    ! (If not, then why are you trying to show differences?)
    ! (Couldn't you at least print warning and return if not?)
d2760 1
d2762 1
d2769 9
d2791 8
d2930 6
d2949 9
d2965 4
d2970 4
a2973 4
            l2gp2%l2gpValue(:,:,instance) = l2gp1%l2gpValue(:,:,instance)
            l2gp2%l2gpPrecision(:,:,instance) = l2gp1%l2gpPrecision(:,:,instance)
            l2gp2%status(instance) = l2gp1%status(instance)
            l2gp2%quality(instance) = l2gp1%quality(instance)
d2980 1
a2980 1
      if ( any(l2gp1%l2gpValue /= l2gp2%l2gpValue) .and. &
d2983 3
a2985 3
          &         l2gp2%l2gpValue, ' ', &
          & stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%l2gpValue /= l2gp2%l2gpValue )
d2987 1
a2987 1
      if ( any(l2gp1%l2gpPrecision /= l2gp2%l2gpPrecision) .and. &
d2990 3
a2992 3
          &         l2gp2%l2gpPrecision, ' ', &
          & stats=stats, rms=rms )
        myNumDiffs = myNumDiffs + count( l2gp1%l2gpPrecision /= l2gp2%l2gpPrecision )
d2995 1
a2995 1
      if ( any(l2gp1%status /= l2gp2%status) .and. &
d2998 1
a2998 1
          &         l2gp2%status, ' ', &
d3002 1
a3002 1
        myNumDiffs = myNumDiffs + count( l2gp1%status /= l2gp2%status )
d3004 1
a3004 1
      if ( any(l2gp1%quality /= l2gp2%quality) .and. &
d3007 1
a3007 1
          &         l2gp2%quality, ' ', &
d3009 1
a3009 1
        myNumDiffs = myNumDiffs + count( l2gp1%quality /= l2gp2%quality )
d3011 3
d3031 1
a3031 1
    integer, intent(in), dimension(:) :: Chunks ! Which chunks to dump
d3073 2
a3074 1
    call DiffL2GPFiles_Name ( L2GPFile1%Name, L2GPFile2%Name, &
d3080 8
d3276 2
a3277 1
      call Diff( l2gp1, l2gp2, chunks=chunks, &
d3281 7
d4044 1
a4044 1
       "$Id: L2GPData.f90,v 2.138 2006/02/16 00:09:23 pwagner Exp $"
d4056 3
@


2.138
log
@Show how l2gp, Hgrid shapes differ
@
text
@d32 1
a32 1
    & GetStringHashElement, GetStringElement, GetUniqueList, &
d920 1
a920 1
      call GetStringHashElement (dimlist, &
d1758 1
a1758 1
        call GetStringHashElement (GeolocationTitles, &
d1761 1
a1761 1
        call GetStringHashElement (UniqueFieldDefKeys, &
d1823 1
a1823 1
    call GetStringHashElement (lowercase(Species), &
d1826 1
a1826 1
    call GetStringHashElement (UniqueFieldDefKeys, &
d1846 1
a1846 1
      call GetStringHashElement (col_species_keys, &
d3592 1
a3592 1
        call GetStringHashElement (GeolocationTitles, &
d3595 1
a3595 1
        call GetStringHashElement (UniqueFieldDefKeys, &
d3616 1
a3616 1
    call GetStringHashElement (lowercase(Species), &
d3619 1
a3619 1
    call GetStringHashElement (UniqueFieldDefKeys, &
d3953 1
a3953 1
       "$Id: L2GPData.f90,v 2.137 2006/02/03 21:25:00 pwagner Exp $"
d3965 3
@


2.137
log
@Finally ended unnecessary debug printing
@
text
@d3841 4
d3953 1
a3953 1
       "$Id: L2GPData.f90,v 2.136 2006/01/27 01:02:19 pwagner Exp $"
d3965 3
@


2.136
log
@Does better at picking units name for column abundances
@
text
@d1695 1
a1695 1
    logical, parameter :: DEEBUG = .true.
d3949 1
a3949 1
       "$Id: L2GPData.f90,v 2.135 2006/01/26 00:33:09 pwagner Exp $"
d3961 3
@


2.135
log
@demoted more use statements from module level to speed Lahey compiles
@
text
@d33 1
a33 1
    & list2array, NumStringElements, RemoveListFromList, &
d213 1
a213 1
    & 'molcm2,molcm2,molcm2,molcm2,molcm2,molcm2,molcm2,molcm2,molcm2,molcm2,' &
d1695 1
d1705 1
d1807 2
d1810 10
d1821 2
d1843 3
d1849 2
d3949 1
a3949 1
       "$Id: L2GPData.f90,v 2.134 2006/01/19 00:29:10 pwagner Exp $"
d3961 3
@


2.134
log
@Units attribute for column abundances corrected
@
text
@a26 1
  use MLSHDFEOS, only: mls_swattach, mls_swdetach
a35 2
  use PCFHdr, only: GlobalAttributes_T, GlobalAttributes, &
    & he5_readglobalattr, he5_writeglobalattr
d806 1
a806 1
  use MLSHDFEOS, only: mls_swdiminfo, mls_swrdfld
a873 1
      ! swid = mls_SWattach(L2GPFile%FileID%f_id, 'HIRDLS', hdfVersion=hdfVersion)
a878 1
      ! swid = mls_SWattach(L2GPFile%FileID%f_id, l2gp%Name, hdfVersion=hdfVersion)
d1194 2
a1195 2
  use MLSHDFEOS, ONLY : mls_swcreate, mls_dfldsetup, mls_gfldsetup, &
    & mls_swdefdim
d1447 1
a1447 1
  use MLSHDFEOS, only: mls_swwrfld
a1483 1
    ! swid = mls_SWattach (L2GPFile%fileID%f_id, name, hdfVersion=hdfVersion)
d1546 1
a1546 1
  use MLSHDFEOS, only: mls_swwrfld
a1590 1
    ! swid = mls_SWattach (L2GPFile%fileID%f_id, name, hdfVersion=hdfVersion)
d1649 1
a1649 1
  use MLSHDFEOS, only: mls_swwrattr, mls_swwrlattr
a1728 1
    ! swid = mls_SWattach (L2GPFile%fileID%f_id, name, hdfVersion=HDFVERSION_5)
d1896 1
a1917 1
    ! sw_id = mls_swattach(L2GPFile%FileID%f_id, trim(name), hdfVersion=HDFVERSION_5)
d2129 1
a2191 1
      ! swathid = mls_swattach(L2GPFile%FileID%f_id, trim(myswathName), &
d2383 2
d3446 1
d3928 1
a3928 1
       "$Id: L2GPData.f90,v 2.133 2006/01/17 17:49:26 pwagner Exp $"
d3940 3
@


2.133
log
@Fixed bug in call to HuntRange
@
text
@d208 12
d1833 7
a1839 1
    if ( isColumnAmt ) units_name = 'DU'
d3933 1
a3933 1
       "$Id: L2GPData.f90,v 2.132 2006/01/14 00:54:08 pwagner Exp $"
d3945 3
@


2.132
log
@May diff, dump specified chunks only
@
text
@d2639 1
a2639 1
      call HuntRange( fullL2gp1%chunkNumber, (/ chunk /), irange )
d3271 1
a3271 1
      call HuntRange( fullL2gp%chunkNumber, (/ chunk /), irange )
d3915 1
a3915 1
       "$Id: L2GPData.f90,v 2.131 2006/01/04 20:31:19 pwagner Exp $"
d3927 3
@


2.131
log
@Diff procedures may keep silent, returning num of diffs only
@
text
@d26 1
a26 1
  use MLSFillValues, only: ReplaceFillValues
d30 1
d48 1
a48 1
    & ExpandL2GPDataInPlace, &
d59 1
d70 1
d121 1
d289 79
d370 1
a370 1
    & FillIn)
d463 12
a474 12
    l2gp%pressures = l2gp%MissingValue
    l2gp%frequency = l2gp%MissingValue
    l2gp%latitude = l2gp%MissingValue
    l2gp%longitude = l2gp%MissingValue
    l2gp%solarTime = l2gp%MissingValue
    l2gp%losAngle = l2gp%MissingValue
    l2gp%geodAngle = l2gp%MissingValue
    l2gp%time = l2gp%MissingValue
    l2gp%chunkNumber = l2gp%MissingValue
    l2gp%l2gpValue = l2gp%MissingValue
    l2gp%l2gpPrecision = l2gp%MissingValue
    l2gp%status = l2gp%MissingStatus ! l2gp%MissingValue
d2604 51
d2917 1
a2917 1
  subroutine DiffL2GPFiles_MLSFile ( L2GPFile1, L2GPFile2, &
d2924 1
d2967 5
a2971 2
      & Details, wholeArray, stats, rms, ignoreBadChunks, &
      & swList, showMissing, fields, force, swaths1, swaths2, silent, numDiffs )
d2984 1
a2984 1
  subroutine DiffL2GPFiles_Name ( file1, file2, &
d2991 1
d3160 1
a3160 1
      call DiffL2GPData( l2gp1, l2gp2, &
d3247 35
d3915 1
a3915 1
       "$Id: L2GPData.f90,v 2.130 2005/12/16 00:05:57 pwagner Exp $"
d3927 3
@


2.130
log
@Changes to reflect new MLSFillValues module; diff from dump0
@
text
@d35 1
a35 1
  use OUTPUT_M, only: BLANKS, OUTPUT
d2523 1
a2523 1
    & Details, wholeArray, stats, rms, ignoreBadChunks, fields )
d2551 2
d2563 2
d2569 6
d2585 5
a2590 1
      if ( myDetails < -1 ) return
d2596 1
d2604 1
d2612 1
d2620 5
a2625 1
      if ( myDetails < 0 ) return
d2629 1
d2637 1
d2644 1
d2651 1
d2658 1
d2666 1
d2673 1
d2681 1
d2689 1
d2698 1
d2707 1
d2716 4
a2719 1
      if ( myDetails < 1 ) return
d2747 1
d2754 1
d2764 1
d2771 1
d2774 6
d2785 1
a2785 1
    & swList, showMissing, fields, force, swaths1, swaths2 )
d2808 2
d2833 1
a2833 1
      & swList, showMissing, fields, force, swaths1, swaths2 )
d2848 1
a2848 1
    & swList, showMissing, fields, force, swaths1, swaths2 )
d2871 2
d2884 2
d2899 1
d2910 3
d2993 1
a2993 1
        call output('(Ignoring blank swath name in ' // &
d3001 1
a3001 1
          call output('Swath ' // trim(swath) // ' not found in ' // &
d3004 1
a3004 1
        else
d3012 1
a3012 1
      else
d3023 3
a3025 1
        & ignoreBadChunks=ignoreBadChunks, fields=fields )
d3039 1
d3741 1
a3741 1
       "$Id: L2GPData.f90,v 2.129 2005/11/04 18:51:19 pwagner Exp $"
d3753 3
@


2.129
log
@Non-substantial stylistic tweaks of GEO, DATA_FIELDS
@
text
@d16 1
a16 1
  use DUMP_0, only: DUMP
d26 1
a29 1
  use MLSNumerics, only: ReplaceFillValues
d2612 3
a2614 2
          call dump ( l2gp1%pressures - l2gp2%pressures, &
            & 'l2gp%pressures (diff)', stats=stats, rms=rms )
d2618 3
a2620 2
          call dump ( l2gp1%latitude - l2gp2%latitude, &
            & 'l2gp%latitude (diff)', stats=stats, rms=rms )
d2624 3
a2626 2
          call dump ( l2gp1%longitude - l2gp2%longitude, &
            & 'l2gp%longitude (diff)', stats=stats, rms=rms )
d2630 3
a2632 2
        call dump ( l2gp1%solarTime - l2gp2%solarTime, &
          & 'l2gp%solarTime (diff)', stats=stats, rms=rms )
d2636 3
a2638 2
        call dump ( l2gp1%solarZenith - l2gp2%solarZenith, &
          & 'l2gp%solarZenith (diff)', stats=stats, rms=rms )
d2643 3
a2645 2
        call dump ( l2gp1%losAngle - l2gp2%losAngle, &
          & 'l2gp%losAngle (diff)', stats=stats, rms=rms )
d2649 3
a2651 2
        call dump ( l2gp1%geodAngle - l2gp2%geodAngle, &
          & 'l2gp%geodAngle (diff)', stats=stats, rms=rms )
d2656 3
a2658 2
        call dump ( l2gp1%time - l2gp2%time, &
          & 'l2gp%time (diff)', stats=stats, rms=rms )
d2663 5
a2667 2
        call dump ( l2gp1%chunkNumber - l2gp2%chunkNumber, &
          & 'l2gp%chunkNumber (diff)', stats=stats, rms=rms )
d2673 3
a2675 2
          call dump ( l2gp1%frequency - l2gp2%frequency, &
            & 'l2gp%frequency (diff)', stats=stats, rms=rms )
d2709 3
a2711 3
        call dump ( real(l2gp1%l2gpValue - l2gp2%l2gpValue, r8), &
          & 'l2gp%l2gpValue (diff)', stats=stats, rms=rms )
          !& 'l2gp%l2gpValue (diff)', FillValue=FillValue )
d2715 3
a2717 2
        call dump ( real(l2gp1%l2gpPrecision - l2gp2%l2gpPrecision, r8), &
          & 'l2gp%l2gpPrecision (diff)', stats=stats, rms=rms )
d2722 5
a2726 2
        call dump (l2gp1%status - l2gp2%status, &
          & 'l2gp%status (diff)', stats=stats, rms=rms )
d2730 3
a2732 2
        call dump ( l2gp1%quality - l2gp2%quality, &
          & 'l2gp%quality (diff)', stats=stats, rms=rms )
d3683 1
a3683 1
       "$Id: L2GPData.f90,v 2.128 2005/10/28 23:12:02 pwagner Exp $"
d3695 3
@


2.128
log
@Removed unnecessary HGridField from repairL2GPData
@
text
@d153 1
a153 1
     & 'L2gpValue,L2gpPrecision,Quality'
a165 1
   ! These are the above except for 8,9,10 which have special attributes
d168 1
a168 1
     & ',OrbitGeodeticAngle'
d3451 1
a3451 1
      myFields = 'l2gpvalue, l2gpPrecision, status, quality'
d3453 1
a3453 1
      myFields = lowercase(GEO_FIELDS) // ',pressure,time,frequency,chunknumber'
d3582 1
a3582 1
      myFields = lowercase(GEO_FIELDS) // ',pressure,time,frequency,chunknumber'
d3666 1
a3666 1
       "$Id: L2GPData.f90,v 2.127 2005/10/18 23:06:49 pwagner Exp $"
d3678 3
@


2.127
log
@Belated yet crude hack to insure Tropopause units_name is hPa
@
text
@a3528 1
    real(rgp), dimension(:), pointer :: HGridField => null()
a3532 1
    nullify(HGridField)
a3579 1
    ! call allocate_test(HGridField, l2gp%nTimes, 'HGridField', &
a3591 1
      ! HGridField = hgrid%geodLat(1,HGp1:)
a3597 1
      ! HGridField = hgrid%lon(1,HGp1:HGpn)
a3620 2
    ! call deallocate_test(HGridField, 'HGridField', &
    !      & ModuleName )
d3667 1
a3667 1
       "$Id: L2GPData.f90,v 2.126 2005/10/11 17:36:55 pwagner Exp $"
d3679 3
@


2.126
log
@Added MLSFile interface to cpL2GPData, diff procedures
@
text
@d1607 2
d1610 1
d1612 1
d1614 1
a1618 2
    character(len=CHARATTRLEN) :: field_name
    character(len=CHARATTRLEN) :: species_name ! Always lower case
a1619 2
    character(len=CHARATTRLEN) :: abbr_uniq_fdef
    character(len=CHARATTRLEN) :: expnd_uniq_fdef
d1713 3
d1717 1
d1740 1
d3674 1
a3674 1
       "$Id: L2GPData.f90,v 2.125 2005/09/23 23:38:30 pwagner Exp $"
d3686 3
@


2.125
log
@rename only effective if non-blank
@
text
@d58 2
a59 1
    module procedure DiffL2GPFiles
d87 1
d110 2
d114 1
a117 1
! AppendL2GPData          Appends L2GP onto end of existing swath file
d119 3
a121 1
! RepairL2GP              Replaces fillValues in one L2GP with a another's values
d134 1
a134 1
  integer, public, parameter :: MAXNUMSWATHPERFILE = 250
d2442 75
a2516 1
  ! ------------------------------------------ DiffL2GPData ------------
d2715 63
a2777 2
  ! ------------------------------------------ DiffL2GPFiles ------------
  subroutine DiffL2GPFiles ( file1, file2, &
d2960 1
a2960 1
  end subroutine DiffL2GPFiles
d3668 1
a3668 1
       "$Id: L2GPData.f90,v 2.124 2005/09/21 23:16:40 pwagner Exp $"
d3680 3
@


2.124
log
@Improvements to RepairL2GP_HGrid; they may even be correct
@
text
@d2203 1
d2214 2
d2228 1
a2228 1
    if ( present(rename) ) then
d2239 1
a2239 1
      if ( present(rename) ) then
d3527 1
a3527 1
       "$Id: L2GPData.f90,v 2.123 2005/09/14 00:08:15 pwagner Exp $"
d3539 3
@


2.123
log
@Dispense with some debug prints; observe HGRid%noProfsLowerOverlap
@
text
@d2211 2
a2212 2
    verbose = ( index(myOptions, '-v') > 0 )
    repair  = ( index(myOptions, '-r') > 0 )
d2253 1
a2253 1
      if ( repair ) call RepairL2GP(l2gp, HGrid)
d3269 1
a3269 1
  subroutine RepairL2GP_L2GP ( L2GP1, L2GP2, fields )
d3287 1
d3291 2
d3297 3
d3357 1
a3357 1
  subroutine RepairL2GP_HGrid ( L2GP, HGrid, fields, offset )
d3374 1
d3376 1
a3376 1
    logical, parameter :: DEEBUG = .false.
d3378 1
d3381 2
d3387 3
a3391 2
    ! elseif ( HGrid%allowPriorOverlaps ) then
    !  HGp1 = 1
d3397 35
a3431 3
    if ( size(hgrid%geodLat(1,HGp1:)) /= size(l2gp%longitude) ) &
     & call MLSMessage ( MLSMSG_Error, ModuleName, & 
        & 'HGrid and l2gp size mismatch')
d3447 1
a3447 1
        & real(hgrid%geodLat(1,HGp1:), rgp) )
d3452 1
a3452 1
      ! HGridField = hgrid%lon(1,HGp1:)
d3454 1
a3454 1
        & real(hgrid%lon(1,HGp1:), rgp) )
d3458 1
a3458 1
        & real(hgrid%solartime(1,HGp1:), rgp) )
d3462 1
a3462 1
        & real(hgrid%solarzenith(1,HGp1:), rgp) )
d3466 1
a3466 1
        & real(hgrid%losangle(1,HGp1:), rgp) )
d3470 1
a3470 1
        & real(hgrid%phi(1,HGp1:), rgp) )
d3474 1
a3474 1
        & hgrid%time(1,HGp1:) )
d3524 1
a3524 1
       "$Id: L2GPData.f90,v 2.122 2005/08/19 23:37:22 pwagner Exp $"
d3536 3
@


2.122
log
@May use HGrid to repair l2gp geolocations
@
text
@d2188 1
a2188 1
    character (len=*), intent(in) :: swathList
d2283 2
a2284 2
    integer, optional, intent(in) :: hdfVersion2
    character (len=*), optional, intent(in) :: swathList ! Copy only these
d3353 1
a3353 1
    ! This routine repairs l2gp1 using values from l2gp2
d3369 1
a3369 1
    character(len=128) :: myFields
d3372 1
d3377 14
a3390 4
    HGp1 = 1 ! 2  ! No longer assume we're not offset; was 1
    if ( present(offset) ) HGp1 = offset
    call allocate_test(HGridField, l2gp%nTimes, 'HGridField', &
         & ModuleName )
d3398 2
a3399 2
    print *, 'shape l2gp%latitude: ', shape(l2gp%latitude)
    print *, 'shape HGrid%geodLat: ', shape(HGrid%geodLat)
d3402 1
a3402 1
      HGridField = hgrid%geodLat(1,HGp1:)
d3404 1
a3404 1
        & HGridField )
d3406 2
a3407 2
    print *, 'shape l2gp%longitude: ', shape(l2gp%longitude)
    print *, 'shape HGrid%lon: ', shape(HGrid%lon)
d3409 1
a3409 1
      HGridField = hgrid%lon(1,HGp1:)
d3411 1
a3411 1
        & HGridField )
d3433 2
a3434 2
    call deallocate_test(HGridField, 'HGridField', &
         & ModuleName )
d3481 1
a3481 1
       "$Id: L2GPData.f90,v 2.121 2005/08/15 10:40:38 hcp Exp $"
d3493 3
@


2.121
log
@in AppendL2GPData_fileID, mls_swdetach was called with an undefined
variable as hdfVersion, causing failures. Now fixed.
@
text
@d88 5
d2175 2
a2176 1
    & hdfVersion1, hdfVersion2, notUnlimited, rename, ReadStatus, options)
d2181 1
d2183 1
d2194 1
d2203 1
d2211 8
a2218 1
    verbose = ( index(myOptions, 'v') > 0 )
d2252 2
d2266 1
a2266 1
    & notUnlimited, andGlAttributes, ReadStatus, options)
d2273 1
d2275 1
d2287 3
a2289 2
    logical, optional, intent(in) :: notUnlimited
    logical, optional, intent(in) :: ReadStatus
d2293 1
d2318 1
a2318 1
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d2331 5
a2335 1
    if ( present(swathList) ) then
d2413 1
a2413 1
      & ReadStatus=ReadStatus, options=options )
d3268 2
a3269 2
  !-----------------------------------------  RepairL2GP  -----
  subroutine RepairL2GP ( L2GP1, L2GP2, fields )
d3348 78
a3425 1
  end subroutine RepairL2GP
d3470 1
a3470 1
       "$Id: L2GPData.f90,v 2.120 2005/08/08 23:55:04 pwagner Exp $"
d3482 4
@


2.120
log
@Never leave status undefined if L2GPFile%errorCode assigned to it
@
text
@a1530 1

d1931 1
d1973 2
d2044 1
a2044 1
    integer :: myhdfVersion
d2087 1
a2087 1
        status = mls_swdetach(swathid, hdfVersion=myhdfVersion)
d3366 1
a3366 1
       "$Id: L2GPData.f90,v 2.119 2005/08/05 20:32:56 pwagner Exp $"
d3378 3
@


2.119
log
@Added RepairL2GP
@
text
@d676 1
d1854 1
d2050 1
d3364 1
a3364 1
       "$Id: L2GPData.f90,v 2.118 2005/07/12 17:15:47 pwagner Exp $"
d3376 3
@


2.118
log
@Dropped global attribute InputVersion
@
text
@d29 1
d33 2
a34 2
    & list2array, NumStringElements, &
    & StringElementNum
d48 1
a48 1
    & ReadL2GPData, SetupNewL2GPRecord, WriteL2GPData
d110 1
d2165 1
a2165 1
    & hdfVersion1, hdfVersion2, notUnlimited, swathList2, ReadStatus, options)
d2180 1
a2180 1
    character (len=*), optional, intent(in) :: swathList2
d2203 3
a2205 3
    if ( present(swathList2) ) then
      noSwaths = min(noSwaths, NumStringElements(trim(swathList2), countEmpty))
      if ( verbose ) call dump(swathlist2, 'swath names (copied)')
d2209 1
a2209 1
            & 'No swaths cp to file--unable to count swaths in ' // trim(swathList2) )
d2214 2
a2215 2
      if ( present(swathList2) ) then
        call GetStringElement (trim(swathList2), swath2, i, countEmpty )
d2241 1
a2241 1
    & create2, hdfVersion1,  hdfVersion2, swathList, swathList2, &
d2258 3
a2260 2
    character (len=*), optional, intent(in) :: swathList
    character (len=*), optional, intent(in) :: swathList2
d2276 1
d2373 5
d2380 1
a2380 1
      & notUnlimited=notUnlimited, swathList2=swathList2, &
d2403 1
a2403 1
    & Details, wholeArray, stats, rms, ignoreBadChunks )
d2430 1
d2432 7
d2440 1
a2441 3
    logical :: badChunks
    integer :: instance
    integer :: badInstances
d2448 4
a2451 3
      !FillValue = real(l2gp1%MissingValue, r8)
      !ChunkFillValue = int(l2gp1%MissingValue)

d2490 2
a2491 1
      if ( any(l2gp1%pressures /= l2gp2%pressures)) then
d2495 2
a2496 1
      if ( any(l2gp1%latitude /= l2gp2%latitude)) then
d2500 2
a2501 1
      if ( any(l2gp1%longitude /= l2gp2%longitude)) then
d2505 2
a2506 1
      if ( any(l2gp1%solarTime /= l2gp2%solarTime)) then
d2510 2
a2511 1
      if ( any(l2gp1%solarZenith /= l2gp2%solarZenith)) then
d2516 2
a2517 1
      if ( any(l2gp1%losAngle /= l2gp2%losAngle)) then
d2521 2
a2522 1
      if ( any(l2gp1%geodAngle /= l2gp2%geodAngle)) then
d2527 2
a2528 1
      if ( any(l2gp1%time /= l2gp2%time)) then
d2533 2
a2534 1
      if ( any(l2gp1%chunkNumber /= l2gp2%chunkNumber)) then
d2540 2
a2541 1
        if ( any(l2gp1%frequency /= l2gp2%frequency)) then
d2575 2
a2576 1
      if ( any(l2gp1%l2gpValue /= l2gp2%l2gpValue)) then
d2581 2
a2582 1
      if ( any(l2gp1%l2gpPrecision /= l2gp2%l2gpPrecision)) then
d2587 2
a2588 1
      if ( any(l2gp1%status /= l2gp2%status)) then
d2592 2
a2593 1
      if ( any(l2gp1%quality /= l2gp2%quality)) then
d2602 2
a2603 1
    & Details, wholeArray, stats, rms, ignoreBadChunks, swList, showMissing )
d2622 4
d2628 1
a2630 1
    integer :: record_length
d2632 2
a2633 4
    integer :: status
    integer :: the_hdfVersion1
    integer :: the_hdfVersion2
    logical :: file_exists
d2635 2
d2640 5
a2644 1
    logical :: myShowMissing
a2645 1
    character (len=MAXSWATHNAMESBUFSIZE) :: swathList2
d2647 2
a2648 3
    character (len=L2GPNameLen) :: swath
    type (L2GPData_T) :: l2gp1
    type (L2GPData_T) :: l2gp2
d2658 2
d2671 7
a2677 1
    noSwaths2 = mls_InqSwath ( file2, swathList2, listSize, &
d2679 6
d2697 1
a2697 1
          & str2=trim(swathList2))
d2708 1
a2708 1
          & str2=trim(swathList2))
d2713 1
a2713 1
        call GetUniqueList(trim(swathList2), swathUnique, noUnique, countEmpty, &
d2744 2
a2745 1
      status = stringElementNum(swathList2, trim(swath), countEmpty)
d2747 16
a2762 3
        call output('Swath ' // trim(swath) // ' not found in ' // &
          & trim(File2), advance='yes')
        cycle
a2763 3
      call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
      call output( '---- swath name: ' // trim(swath) // ' ----', advance='yes')
      call blanks( 22+len_trim(swath), fillChar='-', advance='yes')
d2766 1
a2766 1
      call ReadL2GPData ( File2Handle, trim(swath), l2gp2, &
d2768 1
a2768 1
      call DiffL2GPData(l2gp1, l2gp2, &
d2770 1
a2770 1
        & ignoreBadChunks=ignoreBadChunks)
d3236 82
d3361 1
a3361 1
       "$Id: L2GPData.f90,v 2.117 2005/07/06 00:31:06 pwagner Exp $"
d3373 3
@


2.117
log
@More robust determination of column swaths; quality data field has no units
@
text
@d3032 1
a3032 1
      call output ('Input version: ' // trim(  gAttributes%inputVersion    ))
d3217 1
a3217 1
       "$Id: L2GPData.f90,v 2.116 2005/06/29 00:41:50 pwagner Exp $"
d3229 3
@


2.116
log
@Passes MLSFiles to mls_swattach,create
@
text
@d1566 1
a1566 1

d1602 1
a1602 1
    character(len=CHARATTRLEN) :: species_name
d1698 2
a1699 2
    species_name = name
    isColumnAmt = ( index(species_name, 'Column') > 0 )
d1701 1
a1701 1
      call ExtractSubString(Name, species_name, 'Column', 'wmo')
d1704 1
a1704 1
      & SpUniqueFieldDefinition, trim(lowercase(species_name)), &
d1748 1
a1748 1
      & MLS_CHARTYPE, 1, 'NoUnits')
d1762 2
a1763 1
      & MLS_CHARTYPE, 1, units_name)
d2163 1
a2163 1
    & hdfVersion1, hdfVersion2, notUnlimited, swathList2, ReadStatus)
d2179 1
d2183 1
d2185 1
a2185 1
    integer :: i
d2189 1
d2192 3
d2200 5
a2204 2
    if ( present(swathList2) ) &
      & noSwaths = min(noSwaths, NumStringElements(trim(swathList2), countEmpty))
d2240 1
a2240 1
    & notUnlimited, andGlAttributes, ReadStatus)
d2260 1
d2263 1
a2265 4
    integer :: record_length
    integer :: status
    integer :: the_hdfVersion1
    integer :: the_hdfVersion2
d2268 2
d2271 2
a2273 3
    character (len=MAXSWATHNAMESBUFSIZE) :: mySwathList
    type(GlobalAttributes_T) :: gAttributes
    type(GlobalAttributes_T) :: gAttributesOriginal
d2275 2
a2276 1
    integer                  :: DayofYear
d2278 2
a2279 1
    logical                  :: myandGlAttributes
d2372 1
a2372 1
      & ReadStatus=ReadStatus )
d3217 1
a3217 1
       "$Id: L2GPData.f90,v 2.115 2005/06/22 17:25:49 pwagner Exp $"
d3229 3
@


2.115
log
@Reworded Copyright statement, moved rcs id
@
text
@d45 1
a45 1
    & DestroyL2GPContents,  DestroyL2GPDatabase, diff, Dump, &
d51 1
a51 1
       "$RCSfile: $"
a181 4
  ! The following, if true, says to encode strings as ints
  ! before swapi write; also decode ints to strings after read
  ! otherwise, try swapi read, write directly with strings
  ! logical, parameter :: USEINTS4STRINGS = .false.  
a754 6
!  How to deal with status and columnTypes? swrfld fails
!  with char data on Linux with HDF4. With HDF5 we may or may not need to
!  Have recourse to ints2Strings and strings2Ints if USEINTS4STRINGS
!    character (LEN=8), allocatable :: the_status_buffer(:)
!    character (LEN=L2GPNameLen), allocatable :: the_status_buffer(:)
!    integer, allocatable, dimension(:,:) :: string_buffer
d769 2
a770 1
      swid = mls_SWattach(L2GPFile%FileID%f_id, 'HIRDLS', hdfVersion=hdfVersion)
d775 2
a776 1
      swid = mls_SWattach(L2GPFile%FileID%f_id, l2gp%Name, hdfVersion=hdfVersion)
d1157 2
a1158 2
    swid = mls_SWcreate(L2GPFile%FileID%f_id, trim(name), &
      & filename=L2GPFile%name, hdfVersion=hdfVersion)
d1381 2
a1382 1
    swid = mls_SWattach (L2GPFile%fileID%f_id, name, hdfVersion=hdfVersion)
d1489 2
a1490 1
    swid = mls_SWattach (L2GPFile%fileID%f_id, name, hdfVersion=hdfVersion)
d1628 2
a1629 1
    swid = mls_SWattach (L2GPFile%fileID%f_id, name, hdfVersion=HDFVERSION_5)
d1805 2
a1806 1
    sw_id = mls_swattach(L2GPFile%FileID%f_id, trim(name), hdfVersion=HDFVERSION_5)
d2074 3
a2076 2
      swathid = mls_swattach(L2GPFile%FileID%f_id, trim(myswathName), &
        & hdfVersion=L2GPFile%hdfVersion, DONTFAIL=.true.)
d3206 1
a3206 1
       "$Id: $"
d3218 3
@


2.114
log
@Moved rdonly error check from read procedure to write
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d49 3
a51 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       & "$Id: L2GPData.f90,v 2.113 2005/06/14 20:38:27 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
  character(len=*), parameter, private :: ModuleName = &
       & "$RCSfile: L2GPData.f90,v $"
d53 1
a53 1
  !---------------------------------------------------------------------------
d3207 5
d3221 3
@


2.113
log
@Interfaces changed to accept MLSFile_T args
@
text
@d43 1
a43 1
       & "$Id: L2GPData.f90,v 2.112 2004/12/14 21:38:59 pwagner Exp $"
a679 3
    if ( L2GPFile%access == DFACC_RDONLY )  &
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'l2gp file is rdonly', MLSFile=L2GPFile)
d1856 3
d3211 3
@


2.112
log
@New verticalCoordinate component, attribute
@
text
@d9 3
a11 3
  use Hdf, only: DFACC_READ, DFACC_CREATE, DFACC_RDWR, &
    & DFNT_CHAR8, DFNT_FLOAT32, DFNT_INT32, DFNT_FLOAT64
  use HDFEOS, only: SWATTACH, SWDETACH, SWINQDIMS
d13 1
a13 1
  use MLSCommon, only: I4, R4, R8, DEFAULTUNDEFINEDVALUE
d16 2
a17 2
    & MLS_HDF_VERSION, MLS_INQSWATH, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, &
    & MLS_EXISTS
d20 2
a21 3
    & MLSMSG_Error, MLSMSG_Warning, MLSMSG_Debug
  use MLSStrings, only: Capitalize,  ints2Strings, lowercase, &
    & strings2Ints
d27 1
a27 1
  use PCFHdr, only: GA_VALUE_LENGTH, GlobalAttributes_T, GlobalAttributes, &
d43 1
a43 1
       & "$Id: L2GPData.f90,v 2.111 2004/10/27 00:32:35 pwagner Exp $"
a56 2
    !module procedure DiffStatsSingle
    !module procedure DiffStatsDouble
d68 1
d74 1
d82 5
d558 2
d568 6
a573 28
    if ( present(hmot)) my_hmot = Capitalize(hmot)
    ! Check for valid hmot
    select case (my_hmot)
    case ('H')
    case ('M')
    case ('O')
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unable to Read OMI L2GPData" )
    case ('T')
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unable to Read TES L2GPData" )
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unrecognized instrument key passed to ReadL2GPData: "// my_hmot )
    end select
    !print*,"In readl2gpdata: first/last prof=",firstProf, lastProf
    if (myhdfVersion == HDFVERSION_4) then
      call ReadL2GPData_hdf(L2FileHandle, swathname, l2gp, my_hmot, myhdfVersion,&
        & numProfs, firstProf, lastProf, ReadStatus)
    elseif (myhdfVersion /= HDFVERSION_5) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unrecognized hdfVersion passed to ReadL2GPData" )
    else
      call ReadL2GPData_hdf(L2FileHandle, swathname, l2gp, my_hmot, myhdfVersion,&
        & numProfs, firstProf, lastProf, ReadStatus)
    endif
    !print*,"In readl2gpdata: first/last/read prof=",firstProf,&
    !  lastProf,numProfs
d612 1
a612 1
    L2FileHandle = mls_io_gen_openF('swopen', .TRUE., status, &
d621 1
a621 1
    status = mls_io_gen_closeF('swclose', L2FileHandle, FileName=FileName, &
d628 1
a628 1
  ! ------------------- ReadL2GPData_hdf ----------------
d630 71
a700 1
  subroutine ReadL2GPData_hdf(L2FileHandle, swathname, l2gp, HMOT, hdfVersion,&
d702 1
a702 1
  use HDFEOS5, only: HE5_swattach, HE5_swdetach, HE5_SWINQDIMS, HE5_swfldinfo
d719 1
a719 2
    integer, intent(IN) :: L2FileHandle ! Returned by HE5_swopen
    integer, intent(IN) :: hdfVersion ! Returned by HE5_swopen
d739 1
d745 1
a745 1
    integer :: alloc_err, first, freq, lev, nDims, size, swid, status
d748 1
a748 1
    logical :: firstCheck, lastCheck, timeIsUnlim
d766 1
a766 1
    
a772 1
    ! print*," in ReadL2GPData_hdf: first/last=",firstprof,lastprof
a774 1
    ! print *, 'Trying to read he5_swattach to read'
d777 1
a777 1
      swid = mls_SWattach(L2FileHandle, 'HIRDLS', hdfVersion=hdfVersion)
d782 1
a782 1
      swid = mls_SWattach(L2FileHandle, l2gp%Name, hdfVersion=hdfVersion)
d787 3
a789 2
    if (swid == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &attach to hdfeos2/5 swath interface for reading' // trim(swathname))
d807 2
a808 1
      & 'Failed to get dimension information on hdfeos5 swath ' // trim(swathname))
a820 1
      ! print *,"just called mls_swdiminfo(nTimes) : ", size
a822 5
      ! print *, 'rank: ', rank
      ! print *, 'flddims: ', flddims(1:rank)
      ! print *, 'numberType: ', numberType(1:rank)
      ! print *, 'dimlist: ', dimlist
      ! print *, 'maxdimlist: ', maxdimlist
a825 1
   !   print *, 'maxdimName: ', maxdimName
a827 1
       ! print *, 'elem num: ', status
d864 1
a864 1
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
d879 1
a879 1
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
d1044 1
a1044 1
         &detach from swath interface after reading.')
d1052 1
a1052 1
  end subroutine ReadL2GPData_hdf
d1055 42
a1096 7
  ! --------------------------------------  OutputL2GP_createFile_hdf  -----
  subroutine OutputL2GP_createFile_hdf (l2gp, L2FileHandle, hdfVersion, &
    & swathName, fileName, nLevels, notUnlimited, compressTimes)

  use HDFEOS5, only: HE5_SWdetach, &
    & HE5S_UNLIMITED_F, &
    & HE5T_NATIVE_CHAR, HE5T_NATIVE_DOUBLE, HE5T_NATIVE_INT, HE5T_NATIVE_FLOAT
d1104 1
a1104 1
    integer, intent(in) :: L2FileHandle ! From swopen
a1105 1
    integer, intent(in) :: hdfVersion
a1106 1
    character (LEN=*), optional, intent(IN) :: fileName
d1127 1
a1132 1
    real :: fillValue
d1144 1
a1160 1
    ! print*,"Creating swath called ",name
d1163 2
a1164 4
    if ( present(filename) .and. DEEBUG ) print *, 'file name ', TRIM(filename)
    swid = mls_SWcreate(L2FileHandle, trim(name), &
      & filename=filename, hdfVersion=hdfVersion)
    !print*,"Swath ",name,"has SW id :",swid
d1172 1
a1172 1
    if ( hdfVersion == HDFVERSION_5 .and. .not. myNotUnlimited ) then
d1338 2
a1339 1
            & 'Failed to detach from swath interface after definition.' )
d1342 2
a1343 2
    !--------------------------------------
  end subroutine OutputL2GP_createFile_hdf
d1346 2
a1347 2
  !-----------------------------------------  OutputL2GP_writeGeo_hdf  -----
  subroutine OutputL2GP_writeGeo_hdf (l2gp, l2FileHandle, hdfVersion, &
a1349 1
  use HDFEOS5, only: HE5_swattach, HE5_swdetach
d1357 1
a1357 2
    integer, intent(in) :: l2FileHandle ! From swopen
    integer, intent(in) :: hdfVersion
d1371 1
d1385 1
d1387 1
a1387 2
    ! print *, 'Trying to he5_swattach to write geo'
    swid = mls_SWattach (l2FileHandle, name, hdfVersion=hdfVersion)
a1393 5
    ! print *, 'Writing geolocation fields'
    ! print *, 'start', start
    ! print *, 'stride', stride
    ! print *, 'edge', edge
    ! print *, 'shape(Latitude)', shape(l2gp%latitude)
d1438 1
a1438 1
            & 'Failed to detach from swath interface' )
d1441 2
a1442 2
    !------------------------------------
  end subroutine OutputL2GP_writeGeo_hdf
d1445 2
a1446 2
  !----------------------------------------  OutputL2GP_writeData_hdf  -----
  subroutine OutputL2GP_writeData_hdf(l2gp, l2FileHandle, hdfVersion, &
a1448 1
  use HDFEOS5, only: HE5_swattach, HE5_swdetach
d1457 1
a1457 2
    integer, intent(in) :: l2FileHandle ! From swopen
    integer, intent(in) :: hdfVersion
a1465 1
    character (len=480) :: msr
d1471 1
a1472 6
!  How to deal with status and columnTypes? swrfld fails
!  with char data on Linux
!  Have recourse to ints2Strings and strings2Ints if USEINTS4STRINGS
!    character (LEN=8), allocatable :: the_status_buffer(:)
!    character (LEN=L2GPNameLen), allocatable :: the_status_buffer(:)
!    integer, allocatable, dimension(:,:) :: string_buffer
d1486 1
d1494 1
a1494 2
    ! print *, 'Trying to he5_swattach to write data'
    swid = mls_SWattach (l2FileHandle, name, hdfVersion=hdfVersion)
d1535 1
a1535 1
    if(DEEBUG) print *, 'file handle ', l2FileHandle
d1539 1
a1539 1
            & 'Failed to detach from swath interface' )
d1544 1
a1544 1
  end subroutine OutputL2GP_writeData_hdf
d1547 2
a1548 2
  !----------------------------------------  OutputL2GP_attributes_hdf5  -----
  subroutine OutputL2GP_attributes_hdf5(l2gp, l2FileHandle, swathName)
d1551 1
a1551 1
    & HE5_SWattach, HE5_SWdetach, MLS_charType
d1565 1
a1565 1
    integer, intent(in) :: l2FileHandle ! From swopen
a1609 1
    
d1616 1
d1623 2
a1624 1
        & 'Attributes have unrecognized numeric data type; should be r4 or r8')
d1630 1
a1630 1
    call he5_writeglobalattr(l2FileHandle)
d1632 1
a1632 1
    swid = mls_SWattach (l2FileHandle, name, hdfVersion=HDFVERSION_5)
d1646 1
d1665 1
d1668 1
d1685 3
d1690 4
a1693 1
          & MLS_CHARTYPE, 1, trim(expnd_uniq_fdef))
d1696 1
d1725 1
d1728 1
d1733 1
d1736 1
a1736 1
      & MLS_CHARTYPE, 1, trim(expnd_uniq_fdef))
d1745 1
a1745 1
      & MLS_CHARTYPE, 1, trim(expnd_uniq_fdef))
d1775 1
a1775 1
            & 'Failed to detach  from swath interface' )
d1780 1
a1780 1
  end subroutine OutputL2GP_attributes_hdf5
d1783 2
a1784 2
  !----------------------------------------  SetL2GP_aliases  -----
  subroutine SetL2GP_aliases(l2gp, l2FileHandle, swathName)
d1786 1
a1786 1
  use HDFEOS5, only: HE5_SWATTACH, HE5_SWSETALIAS, HE5_SWDETACH
d1789 1
a1789 1
    integer, intent(IN) :: l2FileHandle ! From swopen
d1808 1
a1808 2
    ! print *, 'Trying to he5_swattach to set alias'
    sw_id = mls_swattach(l2FileHandle, trim(name), hdfVersion=HDFVERSION_5)
d1811 1
a1811 1
        & "Error in attaching swath for setting alias." )
d1817 1
a1817 1
          & ' to ' // trim(name) )
d1824 1
a1824 1
          & ' to ' // trim(name) // 'Precision' )
d1829 1
a1829 1
        & "Error in detaching swath for setting alias." )
d1832 1
a1832 1
  end subroutine SetL2GP_aliases
d1835 1
a1835 1

d1838 1
a1838 1
  subroutine WriteL2GPData(l2gp, l2FileHandle, swathName, filename, hdfVersion, &
d1843 1
a1843 1
    integer, intent(IN) :: l2FileHandle ! From swopen
a1845 2
    character (LEN=*), optional, intent(IN) ::fileName
    integer, optional, intent(in) :: hdfVersion
a1846 2
    ! Exectuable code

d1848 2
a1849 2
    integer :: myhdfVersion

a1850 5
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L2GPDEFAULT_HDFVERSION
    endif
d1852 10
a1861 3
    call OutputL2GP_createFile_hdf (l2gp, l2FileHandle, myhdfVersion, &
      & swathName, filename, notUnlimited=notUnlimited)
    call OutputL2GP_writeGeo_hdf (l2gp, l2FileHandle, myhdfVersion, &
d1863 1
a1863 1
    call OutputL2GP_writeData_hdf (l2gp, l2FileHandle, myhdfVersion, &
d1865 1
a1865 1
    if (myhdfVersion == HDFVERSION_5) then
d1867 1
a1867 1
      call OutputL2GP_attributes_hdf5 (l2gp, l2FileHandle, swathName)
d1869 1
a1869 1
      call SetL2GP_aliases (l2gp, l2FileHandle, swathName)
d1872 4
a1875 1
  end subroutine WriteL2GPData
d1912 122
d2035 1
a2043 5
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L2GPDEFAULT_HDFVERSION
    endif
d2056 11
a2071 1
      ! print *, 'createSwath: ', createSwath
d2073 2
a2074 3
      ! print *, 'Uh-oh, calling mls_swattach'
      swathid = mls_swattach(L2FileHandle, trim(myswathName), &
        & hdfVersion=myhdfVersion, DONTFAIL=.true.)
d2080 1
a2080 1
          & 'Failed to detach from swath in AppendL2GPData_fileID')
d2093 1
a2093 1
      select case (myhdfVersion)
d2097 2
a2098 2
        call OutputL2GP_createFile_hdf (l2gp, L2FileHandle, myhdfVersion, &
          & myswathName, filename, notUnlimited=.false. .and. present(totNumProfs))
d2104 2
a2105 2
        call OutputL2GP_createFile_hdf (l2gp, L2FileHandle, myhdfVersion, &
          & myswathName, filename,&
d2110 1
a2110 1
         & 'Illegal hdf version in AppendL2GPData_fileName')
d2129 1
a2129 1
        & "No profiles in this chunk" )
d2134 1
a2134 1
      call OutputL2GP_writeGeo_hdf (l2gp, l2FileHandle, myHDFVersion, &
d2136 1
a2136 1
      call OutputL2GP_writeData_hdf (l2gp, l2FileHandle, myHDFVersion, &
d2138 1
a2138 1
      select case ( myHDFVersion )
d2142 2
a2143 2
          call OutputL2GP_attributes_hdf5 (l2gp, l2FileHandle, swathName)
          call SetL2GP_aliases (l2gp, l2FileHandle, swathName)
d2147 1
a2147 1
          & "Unrecognized hdfVersion passed to AppendL2GPData" )
d2152 4
a2155 72
  end subroutine AppendL2GPData_fileID

  ! ---------------------- AppendL2GPData_fileName  ---------------------------

  subroutine AppendL2GPData_fileName(l2gp, fileName, &
    & swathname, offset, lastProfile, TotNumProfs, hdfVersion)
    !------------------------------------------------------------------------

    ! Given a file name,
    ! This routine does an append operation (see AppendL2GPData_fileID)
    ! If the file doesn't exist yet, hopefully, it'll create it

    ! Arguments

    character (len=*), intent(in) :: fileName ! Name of swath
    type( l2GPData_T ), intent(inout) :: l2gp ! Result
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    integer,intent(IN),optional :: offset
    integer, intent(IN), optional::lastProfile
    integer,intent(IN),optional :: TotNumProfs
    integer, optional, intent(in) :: hdfVersion
    ! logical, optional, intent(in) :: clean   ! Not implemented yet

    ! Local
    integer :: L2FileHandle
    integer :: record_length
    integer :: status
    integer :: the_hdfVersion
    logical :: myClean
    logical :: file_exists
    integer :: file_access
    integer :: actual_ntimes
    
    ! Executable code
    myClean = .false.
    ! if ( present(clean) ) myClean = clean
    file_exists = ( mls_exists(trim(FileName)) == 0 )
    the_hdfVersion = L2GPDEFAULT_HDFVERSION
    if ( present(hdfVersion) ) the_hdfVersion = hdfVersion
    if ( the_hdfVersion == WILDCARDHDFVERSION ) then
      ! Does the file exist, yet?
      if ( .not. file_exists ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File not found; make sure the name and path are correct' &
          & // trim(fileName) )
      endif
      the_hdfVersion = mls_hdf_version(FileName, hdfVersion)
      if ( the_hdfVersion == FILENOTFOUND ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File not found; make sure the name and path are correct' &
          & // trim(fileName) )
    endif
    if ( file_exists ) then
      file_access = DFACC_RDWR
    else
      file_access = DFACC_CREATE
    endif
    L2FileHandle = mls_io_gen_openF('swopen', .TRUE., status, &
       & record_length, file_access, FileName=FileName, &
       & hdfVersion=the_hdfVersion, debugOption=.false. )
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to open L2gp file: " // trim(FileName) // ' for appending')
    call AppendL2GPData_fileID(l2gp, L2FileHandle, swathname, &
      & FileName, offset, lastProfile=lastProfile, totNumProfs=totNumProfs, &
      & hdfVersion=the_hdfVersion)
    status = mls_io_gen_closeF('swclose', L2FileHandle, FileName=FileName, &
      & hdfVersion=the_hdfVersion)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(FileName) // ' after appending')
  end subroutine AppendL2GPData_fileName
d2298 1
a2298 1
    File1Handle = mls_io_gen_openF('swopen', .TRUE., status, &
d2332 1
a2332 1
    File2Handle = mls_io_gen_openF('swopen', .TRUE., status, &
d2361 1
a2361 1
    status = mls_io_gen_closeF('swclose', File1Handle, FileName=File1, &
d2369 1
a2369 1
    status = mls_io_gen_closeF('swclose', File2Handle, &
a2408 1
    integer :: ierr
a2409 2
    real(r8) :: FillValue
    integer :: ChunkFillValue
a2587 1
    integer :: file_access
a2644 3
         ! print *, 'swathList1: ', trim(swathList1)
         ! print *, 'swathList2: ', trim(swathList2)
         ! print *, 'list1 not in list2 : ', noUnique
a2650 1
        ! print *, 'list2 not in list1 : ', noUnique
d2658 1
a2658 1
    File1Handle = mls_io_gen_openF('swopen', .TRUE., status, &
d2664 1
a2664 1
    File2Handle = mls_io_gen_openF('swopen', .TRUE., status, &
a2672 1
    ! print *, 'swathList1: ', trim(swathList1)
d2699 1
a2699 1
    status = mls_io_gen_closeF('swclose', File1Handle, FileName=File1, &
d2704 1
a2704 1
    status = mls_io_gen_closeF('swclose', File2Handle, FileName=File2, &
a2801 1
    logical :: show
d2927 1
a2927 2
  use HDFEOS5, only: HE5T_NATIVE_INT, HE5T_NATIVE_REAL, HE5T_NATIVE_DOUBLE, &
    & HE5_SWattach, HE5_SWdetach, MLS_charType
a2948 1
    integer, dimension(1)             :: ibuf
d3211 3
@


2.111
log
@Missing/Fill value for l2gp%status changed to 513
@
text
@d44 1
a44 1
       & "$Id: L2GPData.f90,v 2.110 2004/08/04 23:19:01 pwagner Exp $"
d254 5
d334 1
a334 1

d462 1
d1570 2
a1571 1
    status = he5_swwrattr(swid, 'Pressure', rgp_type, size(l2gp%pressures), &
d1573 1
a1573 1
    field_name = 'Pressure'
d1590 3
d2736 1
a2736 1
      & call dump ( l2gp%pressures, 'Pressures:' )
d3086 3
@


2.110
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d44 1
a44 1
       & "$Id: L2GPData.f90,v 2.109 2004/08/03 17:59:35 pwagner Exp $"
d202 1
a202 1
     integer :: QUANTITYTYPE = 0         ! E.g., l_temperature
d251 1
d253 1
d369 1
a369 1
    l2gp%status = l2gp%MissingValue
d971 1
a971 1
    l2gp%status = l2gp%MissingValue ! So it has a value.
d1237 2
a1238 1
    & hdfVersion=hdfVersion, iFill=int(l2gp%MissingValue))
d1665 3
a1667 1
      & HE5T_NATIVE_INT, 1, (/ int(l2gp%MissingValue) /) )
d2612 1
a2612 1
  subroutine DUMP_L2GP_DATABASE ( L2gp, Name, ColumnsOnly, Details )
d2619 1
d2634 1
a2634 1
      call dump(l2gp(i), ColumnsOnly, Details)
d2642 5
a2646 2
  subroutine Dump_L2GP ( L2gp, ColumnsOnly, Details )

d2655 1
d2663 2
d2669 5
d2681 5
a2685 5
      if ( myColumnsOnly .and. l2gp%nLevels > 1 ) return
      
      FillValue = real(l2gp%MissingValue, r8)
      ChunkFillValue = int(l2gp%MissingValue)

d2700 12
a2711 1
      if ( myDetails < -1 ) return
d2718 9
a2726 2
      if ( myDetails < 0 ) return
      call dump ( l2gp%pressures, 'Pressures:' )
d2728 2
a2729 1
      call dump ( l2gp%latitude, 'Latitude:' )
d2731 2
a2732 1
      call dump ( l2gp%longitude, 'Longitude:' )
d2734 2
a2735 1
      call dump ( l2gp%solarTime, 'SolarTime:' )
d2737 2
a2738 1
      call dump ( l2gp%solarZenith, 'SolarZenith:' )
d2740 2
a2741 1
      call dump ( l2gp%losAngle, 'LOSAngle:' )
d2743 2
a2744 1
      call dump ( l2gp%geodAngle, 'geodAngle:' )
d2746 2
a2747 1
      call dump ( l2gp%time, 'Time:' )
d2749 2
a2750 1
      call dump ( l2gp%chunkNumber, 'ChunkNumber:' )
d2752 2
a2753 1
      if ( associated(l2gp%frequency) ) &
d2756 3
a2758 2
      if ( myDetails < 1 ) return
      call dump ( real(l2gp%l2gpValue, r8), 'L2GPValue:', &
d2761 2
a2762 1
      call dump ( real(l2gp%l2gpPrecision, r8), 'L2GPPrecision:', &
d2765 2
a2766 1
      call dump ( l2gp%status, 'Status:' )
d2768 2
a2769 1
      call dump ( l2gp%quality, 'Quality:' )
d2771 14
d3076 3
@


2.109
log
@Gets DEFAULTUNDEFINEDVALUE from MLSCommon
@
text
@d21 3
a23 1
  use MLSStrings, only: Capitalize, ExtractSubString, &
d25 2
a26 2
    & ints2Strings, list2array, lowercase, NumStringElements, &
    & strings2Ints, StringElementNum
d44 1
a44 1
       & "$Id: L2GPData.f90,v 2.108 2004/07/22 17:07:15 pwagner Exp $"
d3014 3
@


2.108
log
@Fixed set fill values
@
text
@d13 1
a13 1
  use MLSCommon, only: I4, R4, R8
d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.107 2004/06/11 19:07:02 pwagner Exp $"
d117 1
a117 1
  real, parameter    :: UNDEFINED_VALUE = -999.99 ! Same as %template%badvalue
d718 1
a718 1
      l2gp%MissingValue = -999.
d3012 3
@


2.107
log
@Fixed small bug in diffl2gpfiles
@
text
@d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.106 2004/06/09 00:04:51 pwagner Exp $"
d1007 1
a1007 1
    & mls_swdefdim, MLS_SWSETFILL
d1138 1
a1138 1
      & hdfVersion=hdfVersion)
d1142 1
a1142 1
      & hdfVersion=hdfVersion)
d1146 1
a1146 1
      & hdfVersion=hdfVersion)
d1150 1
a1150 1
      & hdfVersion=hdfVersion)
d1154 1
a1154 1
      & hdfVersion=hdfVersion)
d1158 1
a1158 1
      & hdfVersion=hdfVersion)
d1162 1
a1162 1
      & hdfVersion=hdfVersion)
d1166 1
a1166 1
      & hdfVersion=hdfVersion)
d1172 1
a1172 1
      & hdfVersion=hdfVersion)
d1179 1
a1179 1
      & hdfVersion=hdfVersion)
d1191 1
a1191 1
      & hdfVersion=hdfVersion)
d1196 1
a1196 1
      & hdfVersion=hdfVersion)
d1205 1
a1205 1
      & hdfVersion=hdfVersion)
d1210 1
a1210 1
      & hdfVersion=hdfVersion)
d1219 1
a1219 1
      & hdfVersion=hdfVersion)
d1224 1
a1224 1
      & hdfVersion=hdfVersion)
d1233 1
a1233 1
    & hdfVersion=hdfVersion)
d1241 1
a1241 45
    & hdfVersion=hdfVersion)

    if ( hdfVersion == HDFVERSION_5 ) then
      ! Set Fill Values
      status =  mls_swsetfill(swid, DATA_FIELDS, HE5T_NATIVE_FLOAT, &
       & l2gp%MissingValue)
      if ( status == -1 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
           & 'Cant set fill for ' // DATA_FIELDS )
      status =  mls_swsetfill(swid, GEO_FIELDS, HE5T_NATIVE_FLOAT, &
       & l2gp%MissingValue)
      if ( status == -1 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
           & 'Cant set fill for ' // GEO_FIELDS )
      status =  mls_swsetfill(swid, 'Time', HE5T_NATIVE_DOUBLE, &
       & real(l2gp%MissingValue, r8) )
      if ( status == -1 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
           & 'Cant set fill for ' // 'Time' )
      status =  mls_swsetfill(swid, 'ChunkNumber', HE5T_NATIVE_INT, &
       & int(l2gp%MissingValue) )
      if ( status == -1 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
           & 'Cant set fill for ' // 'ChunkNumber' )
      if ( l2gp%nLevels > 0 ) then
        status =  mls_swsetfill(swid, 'Pressure', HE5T_NATIVE_FLOAT, &
         & l2gp%MissingValue)
        if ( status == -1 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
             & 'Cant set fill for ' // 'Pressure' )
      endif

      if ( l2gp%nFreqs > 0 ) then
        status =  mls_swsetfill(swid, 'Frequency', HE5T_NATIVE_FLOAT, &
         & l2gp%MissingValue)
        if ( status == -1 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
             & 'Cant set fill for ' // 'Frequency' )
      endif
      ! Get fill value
      if ( DEEBUG ) then
        status = HE5_SWgetfill(swID, 'L2gpValue', fillValue)
        print *, 'status, fillValue: ', status, fillValue
      endif
    endif
d2226 2
a2227 1
  subroutine DiffL2GPData ( L2gp1, L2gp2, Details, stats )
d2229 1
a2229 1
    ! Assumes fields of each already allocated and have same shape
d2231 10
d2242 2
a2243 2
    type (l2gpData_T), intent(in) ::          L2GP1
    type (l2gpData_T), intent(in) ::          L2GP2
d2250 4
a2253 1

d2259 4
a2262 1
    logical :: myStats
d2266 3
a2268 2
    myStats = .false.
    if ( present(stats) ) myStats = stats    
d2288 1
d2295 1
d2302 1
d2305 5
d2312 1
a2312 1
            & 'l2gp%pressures (diff)', stats=stats )
d2316 1
a2316 1
            & 'l2gp%latitude (diff)', stats=stats )
d2320 1
a2320 1
            & 'l2gp%longitude (diff)', stats=stats )
d2324 1
a2324 1
          & 'l2gp%solarTime (diff)', stats=stats )
d2328 2
a2329 1
          & 'l2gp%solarZenith (diff)', stats=stats )
d2333 1
a2333 1
          & 'l2gp%losAngle (diff)', stats=stats )
d2337 2
a2338 1
          & 'l2gp%geodAngle (diff)', stats=stats )
d2342 2
a2343 1
          & 'l2gp%time (diff)', stats=stats )
d2347 1
a2347 1
          & 'l2gp%chunkNumber (diff)', stats=stats )
d2353 1
a2353 1
            & 'l2gp%frequency (diff)', stats=stats )
d2357 5
d2363 22
d2387 1
a2387 1
          & 'l2gp%l2gpValue (diff)', stats=stats )
d2392 1
a2392 1
          & 'l2gp%l2gpPrecision (diff)', stats=stats )
d2397 1
a2397 1
          & 'l2gp%status (diff)', stats=stats )
d2401 1
a2401 1
          & 'l2gp%quality (diff)', stats=stats )
d2407 2
a2408 1
  subroutine DiffL2GPFiles ( file1, file2, Details, stats, swList, showMissing )
d2420 2
d2423 1
d2548 3
a2550 1
      call DiffL2GPData(l2gp1, l2gp2, details, stats)
d3012 3
@


2.106
log
@New optional args to diff
@
text
@d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.105 2004/06/02 19:37:52 pwagner Exp $"
d2395 1
a2395 1
  subroutine DiffL2GPFiles ( file1, file2, Details, swList, stats, showMissing )
d2405 4
a2409 1
    logical, intent(in), optional :: STATS   ! if TRUE, just print stats
d2424 1
d2453 1
a2453 1
    noSwaths = mls_InqSwath ( file2, swathList2, listSize, &
d2514 5
d2525 3
a2527 1
      ! print *, 'swath name: ', trim(swath)
d2994 3
@


2.105
log
@Added stats option to diff
@
text
@d22 1
a22 1
    & GetStringHashElement, GetStringElement, &
d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.104 2004/05/26 23:57:29 pwagner Exp $"
d692 1
d700 1
d738 5
a742 3
    if ( DEEBUG ) print *, 'dimlist: ', trim(list)
    if ( DEEBUG ) print *, 'ndims: ', ndims
    if ( DEEBUG ) print *, 'dims: ', dims
d847 1
a847 1
    if ( DEEBUG ) then
a2328 3
        if ( myStats ) then
          !call diffStats(l2gp1%pressures, l2gp2%pressures, 'Pressures')
        else
d2330 1
a2330 2
            & 'l2gp%pressures (diff)' )
        endif
a2332 3
        if ( myStats ) then
          !call diffStats(l2gp1%latitude, l2gp2%latitude, 'Latitudes')
        else
d2334 1
a2334 2
            & 'l2gp%latitude (diff)' )
        endif
a2336 3
        if ( myStats ) then
          !call diffStats(l2gp1%longitudes, l2gp2%longitudes, 'Longitudes')
        else
d2338 1
a2338 2
            & 'l2gp%longitude (diff)' )
        endif
d2342 1
a2342 1
          & 'l2gp%solarTime (diff)' )
d2346 1
a2346 1
          & 'l2gp%solarZenith (diff)' )
d2350 1
a2350 1
          & 'l2gp%losAngle (diff)' )
d2354 1
a2354 1
          & 'l2gp%geodAngle (diff)' )
d2358 1
a2358 1
          & 'l2gp%time (diff)' )
d2362 1
a2362 1
          & 'l2gp%chunkNumber (diff)' )
d2368 1
a2368 1
            & 'l2gp%frequency (diff)' )
d2375 1
a2375 1
          & 'l2gp%l2gpValue (diff)')
d2380 1
a2380 1
          & 'l2gp%l2gpPrecision (diff)' )
d2385 1
a2385 1
          & 'l2gp%status (diff)' )
d2389 1
a2389 1
          & 'l2gp%quality (diff)' )
d2395 1
a2395 1
  subroutine DiffL2GPFiles ( file1, file2, Details )
d2405 4
a2408 1
    ! Local
d2421 2
d2425 1
d2430 2
d2451 41
d2504 1
d2507 1
a2507 1
    print *, 'swathList1: ', trim(swathList1)
d2516 1
a2516 1
      print *, 'swath name: ', trim(swath)
d2521 1
a2521 1
      call DiffL2GPData(l2gp1, l2gp2, details)
d2983 3
@


2.104
log
@Added new diff routines
@
text
@d25 1
a25 1
  use OUTPUT_M, only: OUTPUT
d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.103 2004/05/26 20:31:29 pwagner Exp $"
d54 6
d2266 1
a2266 1
  subroutine DiffL2GPData ( L2gp1, L2gp2, Details )
d2278 1
d2285 1
a2285 1

d2289 4
a2292 3
    
      FillValue = real(l2gp1%MissingValue, r8)
      ChunkFillValue = int(l2gp1%MissingValue)
d2325 6
a2330 2
        call dump ( l2gp1%pressures - l2gp2%pressures, &
          & 'l2gp%pressures (diff)' )
d2333 6
a2338 2
        call dump ( l2gp1%latitude - l2gp2%latitude, &
          & 'l2gp%latitude (diff)' )
d2341 6
a2346 2
        call dump ( l2gp1%longitude - l2gp2%longitude, &
          & 'l2gp%longitude (diff)' )
d2383 2
a2384 1
          & 'l2gp%l2gpValue (diff)', FillValue=FillValue )
d2388 1
a2388 1
          & 'l2gp%l2gpPrecision (diff)', FillValue=FillValue )
d2438 1
d2464 2
d2474 1
d2495 37
d2941 3
@


2.103
log
@Raised MAXNUMSWATHPERFILE to 250
@
text
@d36 1
a36 1
    & DestroyL2GPContents,  DestroyL2GPDatabase, Dump, &
d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.102 2004/05/05 21:29:53 pwagner Exp $"
d49 5
d2259 211
d2879 3
@


2.102
log
@May change copied swath names with optional arg swathlist2
@
text
@d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.101 2004/04/23 01:43:34 livesey Exp $"
d99 1
a99 1
  integer, public, parameter :: MAXNUMSWATHPERFILE = 200
d2663 3
@


2.101
log
@Added Paul's fix for reading status
@
text
@d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.100 2004/04/06 01:17:43 livesey Exp $"
d171 3
d264 1
d290 6
d342 1
a342 2
    if ( .not. present(FillIn) ) return
    if ( .not. FillIn ) return
d1027 2
d1265 5
d2035 1
a2035 1
    & hdfVersion1, hdfVersion2, notUnlimited, ReadStatus)
d2043 2
a2044 2
    integer, intent(in) :: file1 ! handle of file 1
    integer, intent(in) :: file2 ! handle of file 1
d2046 2
a2047 2
    integer, intent(in) :: hdfVersion1
    integer, intent(in) :: hdfVersion2
d2050 1
d2058 1
d2066 6
d2075 5
d2092 1
a2092 1
      call WriteL2GPData(l2gp, file2, trim(swath), hdfVersion=hdfVersion2, &
d2102 1
a2102 1
    & create2, hdfVersion1,  hdfVersion2, swathList, &
d2120 1
d2233 2
a2234 1
      & notUnlimited=notUnlimited, ReadStatus=ReadStatus )
d2663 3
@


2.100
log
@Changed some allocatables to pointers.
@
text
@d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.99 2004/03/29 18:51:18 pwagner Exp $"
d241 1
d684 1
a684 1
    ReadingStatus = .false.
d2019 1
a2019 1
    & hdfVersion1, hdfVersion2, notUnlimited)
d2033 1
d2054 1
a2054 1
           & hdfVersion=hdfVersion1 )
d2074 1
a2074 1
    & notUnlimited, andGlAttributes)
d2092 1
d2203 1
a2203 1
      & notUnlimited=notUnlimited)
d2632 3
@


2.99
log
@Remembered to tell hdf5 status was int, not char
@
text
@d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.98 2004/03/24 23:53:02 pwagner Exp $"
d665 4
a668 1
    real, allocatable :: realFreq(:), realSurf(:), realProf(:), real3(:,:,:)
d677 2
d834 5
a838 6
    allocate(realProf(myNumProfs), realSurf(l2gp%nLevels), &
      &   realFreq(l2gp%nFreqs), &
      &   real3(nFreqsOr1,nLevelsOr1,myNumProfs), STAT=alloc_err)
    !   &   string_buffer(1,myNumProfs), &
    if ( alloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//' various things in ReadL2GPData' )
d955 4
a958 8

    deallocate(realFreq, realSurf, realProf, real3, STAT=alloc_err)
    if ( alloc_err /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
         'Failed deallocation of local real variables.')

    ! deallocate ( string_buffer, STAT=alloc_err )
    if ( alloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
         'Failed deallocation of status buffer.' )
a960 1

d2629 3
@


2.98
log
@Switched from HE5T_NATIVE_SCHAR to MLS_CHARTYPE
@
text
@d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.97 2004/03/12 00:38:19 pwagner Exp $"
d1206 1
a1206 1
    & DFNT_CHAR8, HDFE_NOMERGE, chunk_rank, chunk_dims, &
d1208 1
d2630 3
@


2.97
log
@cpL2GPData can convert hdfVersions; hdf version default increased to 5
@
text
@d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.96 2004/02/26 22:02:36 pwagner Exp $"
d1488 1
a1488 2
    & HE5T_NATIVE_SCHAR, &
    & HE5_SWattach, HE5_SWdetach
d1574 1
a1574 1
    status = mls_swwrattr(swid, 'VerticalCoordinate', HE5T_NATIVE_SCHAR, 1, &
d1597 1
a1597 1
          & HE5T_NATIVE_SCHAR, 1, theTitles(field))
d1599 1
a1599 1
          & HE5T_NATIVE_SCHAR, 1, theUnits(field))
d1616 1
a1616 1
          & HE5T_NATIVE_SCHAR, 1, trim(expnd_uniq_fdef))
d1648 1
a1648 1
      & HE5T_NATIVE_SCHAR, 1, field_name)
d1650 1
a1650 1
      & HE5T_NATIVE_SCHAR, 1, units_name)
d1655 1
a1655 1
      & HE5T_NATIVE_SCHAR, 1, trim(expnd_uniq_fdef))
d1657 1
a1657 1
      & HE5T_NATIVE_SCHAR, 1, trim(field_name)//'Precision')
d1659 1
a1659 1
      & HE5T_NATIVE_SCHAR, 1, units_name)
d1664 1
a1664 1
      & HE5T_NATIVE_SCHAR, 1, trim(expnd_uniq_fdef))
d1668 1
a1668 1
      & HE5T_NATIVE_SCHAR, 1, trim(field_name)//'Status')
d1670 1
a1670 1
      & HE5T_NATIVE_SCHAR, 1, 'NoUnits')
d1674 1
a1674 1
    !   & HE5T_NATIVE_SCHAR, 1, ' ' )
d1677 1
a1677 1
      & HE5T_NATIVE_SCHAR, 1, 'MLS-Specific')
d1680 1
a1680 1
      & HE5T_NATIVE_SCHAR, 1, trim(field_name)//'Quality')
d1682 1
a1682 1
      & HE5T_NATIVE_SCHAR, 1, units_name)
d1687 1
a1687 1
      & HE5T_NATIVE_SCHAR, 1, 'MLS-Specific')
d2344 1
a2344 2
    & HE5T_NATIVE_SCHAR, &
    & HE5_SWattach, HE5_SWdetach
a2345 1
  ! use MLSHDFEOS, only: he5_swwrattr, he5_swwrlattr
d2629 3
@


2.96
log
@Acts more gracefully if l2gp file lacks global attributes
@
text
@d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.95 2004/02/13 00:18:58 pwagner Exp $"
d93 1
a93 1
  integer, parameter :: L2GPDEFAULT_HDFVERSION = HDFVERSION_4
d2018 2
a2019 2
  subroutine cpL2GPData_fileID(file1, file2, swathList, hdfVersion, &
    & notUnlimited)
d2030 2
a2031 1
    integer, optional, intent(in) :: hdfVersion
d2053 1
a2053 1
           & hdfVersion=hdfVersion )
d2062 1
a2062 1
      call WriteL2GPData(l2gp, file2, trim(swath), hdfVersion=hdfVersion, &
d2071 2
a2072 1
  subroutine cpL2GPData_fileName(file1, file2, create2, hdfVersion, swathList, &
d2087 2
a2088 1
    integer, optional, intent(in) :: hdfVersion
d2097 2
a2098 1
    integer :: the_hdfVersion
d2112 2
a2113 2
    the_hdfVersion = L2GPDEFAULT_HDFVERSION
    if ( present(hdfVersion) ) the_hdfVersion = hdfVersion
d2120 3
a2122 3
    if ( the_hdfVersion == WILDCARDHDFVERSION ) then
      the_hdfVersion = mls_hdf_version(File1, hdfVersion)
      if ( the_hdfVersion == FILENOTFOUND ) &
d2127 2
d2132 1
a2132 1
           & hdfVersion=the_hdfVersion)
d2139 1
a2139 1
           & hdfVersion=the_hdfVersion)
d2143 1
a2143 1
       & hdfVersion=the_hdfVersion, debugOption=.false. )
d2168 1
a2168 1
      print *, 'hdfVersion: ', the_hdfVersion
d2173 2
d2177 1
a2177 1
       & hdfVersion=the_hdfVersion, debugOption=.false. )
d2200 2
a2201 1
      & mySwathList, hdfVersion=the_hdfVersion, notUnlimited=notUnlimited)
d2204 1
a2204 1
      & hdfVersion=the_hdfVersion, debugOption=.false.)
d2212 1
a2212 1
      & hdfVersion=the_hdfVersion, debugOption=.false.)
d2632 3
@


2.95
log
@Added DumpL2GP_attributes_hdf5 which doesnt work yet
@
text
@d26 2
a27 1
  use PCFHdr, only: GA_VALUE_LENGTH
d42 1
a42 1
       & "$Id: L2GPData.f90,v 2.94 2004/02/11 23:05:05 pwagner Exp $"
d105 1
a105 1
  integer, parameter :: CHARATTRLEN = GA_VALUE_LENGTH
d1635 2
d2071 1
a2071 1
    & notUnlimited)
d2084 1
d2100 6
d2164 3
d2177 14
d2423 18
a2440 15
     & ProcessLevel, DayofYear, TAI93At0zOfGranule)
    call dump(gAttributes%orbNum, 'Orbit numbers')
    call dump(gAttributes%orbPeriod, 'Orbit Periods')
    call output ('InstrumentName: ' // trim( gAttributes%InstrumentName  ))
    call output ('Process level: ' // trim(  gAttributes%ProcessLevel    ))
    call output ('Input version: ' // trim(  gAttributes%inputVersion    ))
    call output ('PGE version: ' // trim(    gAttributes%PGEVersion      ))
    call output ('Start UTC: ' // trim(      gAttributes%StartUTC        ))
    call output ('End UTC: ' // trim(        gAttributes%EndUTC          ))
    call dump_int ( gAttributes%GranuleMonth, 'Granule month:' )
    call dump_int ( gAttributes%GranuleDay, 'Granule day:' )
    call dump_int ( gAttributes%GranuleYear, 'Granule year:' )
    call dump_int ( DayOfYear, 'Granule day of year:' )
    call dump_r8 ( TAI93At0zOfGranule, 'Equator crossing time (tai93):' )

d2442 4
d2623 3
@


2.94
log
@Undid effect of 2nd-to-last fix; seems to have been wrong
@
text
@d41 1
a41 1
       & "$Id: L2GPData.f90,v 2.93 2004/02/11 23:04:38 pwagner Exp $"
d51 1
d108 1
d286 3
d2305 234
d2589 3
@


2.93
log
@Undid effect of 2nd-to-last fix; seems to have been wrong
@
text
@d41 1
a41 1
       & "$Id: L2GPData.f90,v 2.92 2004/02/11 22:59:59 pwagner Exp $"
d236 1
a236 1
  logical, parameter :: DEEBUG = .true.  
d2350 3
@


2.92
log
@Undid effect of 2nd-to-last fix; seems to have been wrong
@
text
@d41 1
a41 1
       & "$Id: L2GPData.f90,v 2.91 2004/02/11 17:23:25 pwagner Exp $"
d236 1
a236 1
  logical, parameter :: DEEBUG = .false.  
d2350 3
@


2.91
log
@l2gp status an integer, not a char
@
text
@d41 1
a41 1
       & "$Id: L2GPData.f90,v 2.90 2004/02/10 18:45:43 pwagner Exp $"
d1915 2
a1916 2
      actual_ntimes = l2gp%nTimes
      l2gp%nTimes = max(myLastProfile - offset + 1, 1)
d1932 1
a1932 1
      l2gp%nTimes = actual_ntimes
d2350 3
@


2.90
log
@lastProfile among optional args to AppendL2GPData
@
text
@d13 1
a13 1
  use MLSCommon, only: R4, R8
d41 1
a41 1
       & "$Id: L2GPData.f90,v 2.89 2004/02/05 23:33:21 pwagner Exp $"
d221 3
a223 1
     character (len=1), pointer, dimension(:) :: status=>NULL()
d338 2
a339 1
    l2gp%status = ' '
d932 2
a933 1
    l2gp%status = ' ' ! So it has a value.
d1664 4
a1667 2
    status = mls_swwrlattr(swid, 'Status', 'MissingValue', &
      & HE5T_NATIVE_SCHAR, 1, ' ' )
d2294 1
a2294 1
      !    call dump ( l2gp%status, 'Status:' )
d2350 3
@


2.89
log
@Some bug fixes in cpL2GPData and its relatives
@
text
@d41 1
a41 1
       & "$Id: L2GPData.f90,v 2.88 2004/01/23 01:14:04 pwagner Exp $"
d1424 1
d1435 1
d1443 1
d1783 2
a1784 1
    & swathName, filename, offset, TotNumProfs, hdfVersion, createSwath)
d1805 1
a1805 1
    integer,intent(IN),optional::offset
d1811 2
a1812 1
    integer,intent(IN),optional::TotNumProfs
d1835 3
a1837 1
    if (present(TotNumProfs)) then
d1909 2
d1926 1
d1934 1
a1934 1
    & swathname, offset, TotNumProfs, hdfVersion)
d1947 1
d1993 2
a1994 1
      & FileName, offset, totNumProfs=totNumProfs, hdfVersion=the_hdfVersion)
a2048 3
      ! call AppendL2GPData(l2gp, file2, trim(swath), hdfVersion=hdfVersion, &
      !   & TotNumProfs=l2gp%nTimesTotal, createSwath=.true.)
      ! Deallocate memory used by the l2gp
d2344 3
@


2.88
log
@Can cp l2gps from one file to another
@
text
@d15 1
a15 1
    & HDFVERSION_4, HDFVERSION_5, WILDCARDHDFVERSION, &
d41 1
a41 1
       & "$Id: L2GPData.f90,v 2.87 2004/01/09 00:20:56 pwagner Exp $"
d240 1
a240 1
  subroutine SetupNewL2GPRecord ( l2gp, nFreqs, nLevels, nTimes, &
d250 1
d254 1
a254 1
    integer :: useNFreqs, useNLevels, useNTimes
d274 8
d285 1
a285 1
    l2gp%nTimesTotal = useNTimes
d701 3
d803 1
a803 1
       myNumProfs = nTimes - first
d808 5
a812 1

d967 1
a967 1
    & swathName, fileName, nLevels, notUnlimited)
d985 2
a986 1
    logical, optional, intent(in) :: notUnlimited
d1007 1
d1017 2
d1075 8
a1082 1
    status = mls_swdefdim(swid, 'nTimes', max(l2gp%nTimesTotal,1), &
d1740 2
a1741 1
  subroutine WriteL2GPData(l2gp, l2FileHandle, swathName, filename, hdfVersion)
d1750 1
d1764 1
a1764 1
      & swathName, filename)
d1770 1
d1772 1
d1886 2
a1887 1
      print*,"offset=",offset,"myLastProfile=",myLastProfile,&
d1889 4
d1992 2
a1993 1
  subroutine cpL2GPData_fileID(file1, file2, swathList, hdfVersion)
d2005 1
d2024 1
d2027 7
d2035 4
a2038 1
      call WriteL2GPData(l2gp, file2, trim(swath), hdfVersion=hdfVersion)
d2047 2
a2048 1
  subroutine cpL2GPData_fileName(file1, file2, create2, hdfVersion, swathList)
d2063 1
d2094 6
d2106 1
a2106 1
       & record_length, file_access, FileName=File1, &
d2119 14
a2132 1
      if ( create2 ) file_access = DFACC_CREATE
d2140 4
d2145 2
a2146 1
      & mySwathList, hdfVersion=the_hdfVersion)
d2148 1
a2148 1
      & hdfVersion=the_hdfVersion)
d2152 8
a2159 3
    status = mls_io_gen_closeF('swclose', File2Handle, FileName=File2, &
      & hdfVersion=the_hdfVersion)
    if ( status /= 0 ) &
d2162 1
d2335 3
@


2.87
log
@Added avoidUnlimitedDims to allow bypassing bug directWriting range of chunks
@
text
@d16 2
a17 1
    & MLS_HDF_VERSION, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, MLS_EXISTS
d21 4
a24 2
  use MLSStrings, only: Capitalize, ExtractSubString, GetStringHashElement, &
    & ints2Strings, list2array, lowercase, strings2Ints, StringElementNum
d34 4
a37 3
  public :: AddL2GPToDatabase,  DestroyL2GPContents,  DestroyL2GPDatabase, &
    & Dump, ExpandL2GPDataInPlace, AppendL2GPData, &
    & ReadL2GPData, SetupNewL2GPRecord,  WriteL2GPData
d41 1
a41 1
       & "$Id: L2GPData.f90,v 2.86 2003/12/03 17:51:14 pwagner Exp $"
d63 5
d96 4
d1885 1
a1885 1
  ! ---------------------- AppendL2GPData_fileName  -----------------------------
d1954 130
d2254 3
@


2.86
log
@L2GP tracks both nTimes (for this slave) and nTimesTotal (done by all)
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.85 2003/11/19 22:14:08 livesey Exp $"
d87 3
d1827 2
a1828 1
        ! Currently force unlimited, remove the .false. .and. to allow limited
d1831 3
a1833 2
          & myswathName, filename, notUnlimited=present(totNumProfs))
          ! & myswathName, filename, notUnlimited=.false. .and. present(totNumProfs))
d2111 3
@


2.85
log
@Added option (not invoked at the moment) for 'limited' dimensions in
AppendL2GP
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.84 2003/11/05 21:44:38 pwagner Exp $"
d171 2
a172 1
     integer :: nTimes          ! Total number of profiles
d260 1
d341 1
d709 1
d1001 2
a1002 2
    ! print *, 'About to sw_create ', TRIM(name)
    ! if ( present(filename) ) print *, 'file name ', TRIM(filename)
d1030 10
a1039 2

    status = mls_swdefdim(swid, 'nTimes', max(l2gp%nTimes,1), &
d1786 1
a1786 1
      myLastProfile = L2GP%nTimes
d1827 2
a1828 1
          & myswathName, filename, notUnlimited=.false. .and. present(totNumProfs))
d2106 4
@


2.84
log
@Skips trying to read 4 mls-specific fields from non-mls files
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.83 2003/10/31 12:35:57 hcp Exp $"
d931 1
a931 1
    & swathName, fileName, nLevels)
d948 2
a949 1
    integer,optional::nLevels
d961 1
d969 1
d977 10
a986 2
    chunktimes=120      ! was 1
    chunkfreqs=1 ! better as nFreqs, but I have yet to see a case with nfreqs>1
d990 2
a991 2
       chunklevels = min(l2gp%nLevels, 500)     ! was .., 5)
       chunklevels = max(chunklevels, 1)
d1009 1
a1009 1
    if ( hdfVersion == HDFVERSION_5 ) then
d1017 10
d1045 1
a1045 1
    status = mls_gfldsetup(swid, 'Latitude', 'nTimes', MAX_DIML1, &
d1049 1
a1049 1
    status = mls_gfldsetup(swid, 'Longitude', 'nTimes', MAX_DIML1, &
d1053 1
a1053 1
    status = mls_gfldsetup(swid, 'Time', 'nTimes', MAX_DIML1, &
d1057 1
a1057 1
    status = mls_gfldsetup(swid, 'LocalSolarTime', 'nTimes', MAX_DIML1, &
d1061 1
a1061 1
    status = mls_gfldsetup(swid, 'SolarZenithAngle', 'nTimes', MAX_DIML1, &
d1065 1
a1065 1
    status = mls_gfldsetup(swid, 'LineOfSightAngle', 'nTimes', MAX_DIML1, &
d1069 1
a1069 1
    status = mls_gfldsetup(swid, 'OrbitGeodeticAngle', 'nTimes', MAX_DIML1, &
d1073 1
a1073 1
    status = mls_gfldsetup(swid, 'ChunkNumber', 'nTimes', MAX_DIML1, &
d1098 1
a1098 1
      & MAX_DIML123, &
d1103 1
a1103 1
      & MAX_DIML123, &
d1112 1
a1112 1
      & MAX_DIML12, &
d1117 1
a1117 1
      & MAX_DIML12, &
d1126 1
a1126 1
      & MAX_DIML1, &
d1131 1
a1131 1
      & MAX_DIML1, &
d1140 1
a1140 1
    & MAX_DIML1, &
d1147 1
a1147 1
    & MAX_DIML1, &
d1806 1
d1809 1
a1809 1
          & myswathName, filename)
d1812 2
d1815 1
a1815 1
          & myswathName, filename)
d1915 1
a1915 1
      & FileName, offset, hdfVersion=the_hdfVersion)
d2093 3
@


2.83
log
@HCP made some small fixes to AppendL2GPData_fileID so that it doesn't
crash if optional arg TotNumProfs is not present
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.82 2003/10/28 21:41:06 pwagner Exp $"
a58 5
! interface my_swwrattr 
!   module procedure my_swwrattr_snglarray
!   module procedure my_swwrattr_char
! end interface

d217 1
a217 1
  logical, parameter :: DEEBUG = .true.  
d821 2
d834 1
d898 5
a902 3
    status = mls_SWrdfld(swid, 'Quality', start(3:3), stride(3:3),&
      edge(3:3),realProf, hdfVersion=hdfVersion, dontfail=dontfail)
    l2gp%quality = realProf
a1477 1
    ! if(DEEBUG) print *, 'Writing global attributes'
a1479 1
    ! print *, 'Trying to he5_swattach to write attributes'
a1482 1
    ! if(DEEBUG) print *, 'Writing swath attributes'
a1492 1
    ! if(DEEBUG) print *, 'Writing geolocation attributes'
a1501 3
        ! if(DEEBUG) print *, 'field ', field
        ! if(DEEBUG) print *, 'title ', trim(theTitles(field))
        ! if(DEEBUG) print *, 'units ', trim(theUnits(field))
a1556 3
    ! if(DEEBUG) print *, 'Writing data attributes'
    ! if(DEEBUG) print *, 'title ', trim(field_name)
    ! if(DEEBUG) print *, 'units ', trim(units_name)
a1691 1
      ! if(DEEBUG) print *, 'Writing attributes'
d2069 4
@


2.82
log
@Removed swath-level MissingValue attribute; renamed -Precision softlink
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.81 2003/10/28 00:39:00 pwagner Exp $"
d222 1
a222 1
  logical, parameter :: DEEBUG = .false.  
d1716 3
d1722 2
d1725 2
d1729 3
d1733 5
d1739 1
a1739 1
    integer, optional, intent(in) :: hdfVersion
d1756 5
d1762 1
a1762 1
      myLastProfile = TotNumProfs
d1790 1
a1790 1
      if(DEEBUG) print *, 'Will have ', TotNumProfs, ' profiles'
d1810 8
a1817 1
    if ( offset == totNumProfs .or. size(l2gp%l2gpValue,3) == 0 ) then
d1819 2
a1820 1
      & "No profiles in this chunk" )
d2080 3
@


2.81
log
@Fixed bug where character-vlaued attributes were only 1 char long
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.80 2003/09/09 23:03:46 livesey Exp $"
d223 1
a1477 9
    ! swid = HE5_SWattach (l2FileHandle, name)
    !print*," attached swath with swid=",swid," filehandle=",l2FileHandle
    !status = he5_swwrattr(swid, 'Instrument Name', H5T_NATIVE_CHARACTER, &
    !  & 1, 'MLS Aura')
    ! if ( status == -1 ) then
    !   call MLSMessage ( MLSMSG_Warning, ModuleName, &
    !        & 'Failed to write swath attribute' )
    !     Detach from the swath interface.
    ! call sw_writeglobalattr(swid)
d1491 2
a1492 1
    status = he5_swwrattr(swid, 'MissingValue', rgp_type, 1, &
d1656 1
a1656 1
     & trim(name) // ' Precision')
d1660 1
a1660 1
          & ' to ' // trim(name) // ' Precision' )
d2052 3
@


2.80
log
@More rigorous 'empty l2gp' check in append.
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.79 2003/09/08 22:51:54 pwagner Exp $"
d1401 1
d1497 1
a1497 1
    status = he5_swwrattr(swid, 'VerticalCoordinate', HE5T_NATIVE_SCHAR, 1, &
d1522 1
a1522 1
        status = he5_swwrlattr(swid, trim(theTitles(field)), 'Title', &
d1524 1
a1524 1
        status = he5_swwrlattr(swid, trim(theTitles(field)), 'Units', &
d1540 1
a1540 1
        status = he5_swwrlattr(swid, trim(theTitles(field)), &
d1574 1
a1574 1
    status = he5_swwrlattr(swid, 'L2gpValue', 'Title', &
d1576 1
a1576 1
    status = he5_swwrlattr(swid, 'L2gpValue', 'Units', &
d1580 1
a1580 1
    status = he5_swwrlattr(swid, 'L2gpValue', &
d1583 1
a1583 1
    status = he5_swwrlattr(swid, 'L2gpPrecision', 'Title', &
d1585 1
a1585 1
    status = he5_swwrlattr(swid, 'L2gpPrecision', 'Units', &
d1589 1
a1589 1
    status = he5_swwrlattr(swid, 'L2gpPrecision', &
d1594 1
a1594 1
    status = he5_swwrlattr(swid, 'Status', 'Title', &
d1596 1
a1596 1
    status = he5_swwrlattr(swid, 'Status', 'Units', &
d1598 1
a1598 1
    status = he5_swwrlattr(swid, 'Status', 'MissingValue', &
d1600 1
a1600 1
    status = he5_swwrlattr(swid, 'Status', &
d1604 1
a1604 1
    status = he5_swwrlattr(swid, 'Quality', 'Title', &
d1606 1
a1606 1
    status = he5_swwrlattr(swid, 'Quality', 'Units', &
d1610 1
a1610 1
    status = he5_swwrlattr(swid, 'Quality', &
d2059 3
@


2.79
log
@Simplified and unified read/write of hdfVersions
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.78 2003/09/04 03:02:53 livesey Exp $"
d1796 1
a1796 1
    if ( offset == totNumProfs ) then
d2058 3
@


2.78
log
@Removed some print statements
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.77 2003/09/03 22:39:44 pwagner Exp $"
d515 1
a515 1
      call ReadL2GPData_hdf4(L2FileHandle, swathname, l2gp, my_hmot, &
d521 1
a521 1
      call ReadL2GPData_hdf5(L2FileHandle, swathname, l2gp, my_hmot, &
d580 1
a580 1
  ! ---------------------- ReadL2GPData_hdf4  -----------------------------
d582 1
a582 306
  subroutine ReadL2GPData_hdf4(L2FileHandle, swathname, l2gp, HMOT, &
    & numProfs, firstProf, lastProf, ReadStatus)
  use MLSHDFEOS, only: mls_swdiminfo, mls_swrdfld
    !------------------------------------------------------------------------

    ! This routine reads an L2GP file, assuming it is hdfeos2 format
    ! (i.e. hdf4) returning a filled data structure and the
    ! number of profiles read.

    ! All the ReadStatus harrumphing is because
    ! (1) An earlier version always core dumped
    ! (2) Even this version dumps core while reading l2gp files which stored
    !     the 'Status' field as 32-bit floats instead of chars
    ! Therefore, unless you supply the optional arg ReadStatus=.true.,
    ! it will skip reading the troublesome datafield
    ! Naturally, you would do that only for correctly-formatted l2gp files
    ! Arguments

    character (len=*), intent(in) :: swathname ! Name of swath
    integer, intent(in) :: L2FileHandle ! Returned by swopen
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: l2gp ! Result
    character, intent(in) :: HMOT   ! 'H' 'M'(def) 'O' 'T'
    integer, intent(out), optional :: numProfs ! Number actually read
    logical, optional, intent(in) :: ReadStatus

    ! Local Parameters
    character (len=*), parameter :: SZ_ERR = 'Failed to get size of &
         &dimension '
    character (len=*), parameter :: MLSMSG_INPUT = 'Error in input argument '
    character (len=*), parameter :: MLSMSG_L2GPRead = 'Unable to read L2GP &
                                                     &field:'

    ! Local Variables
    character (len=80) :: DF_Name
    character (len=80) :: DF_Precision
    character (len=80) :: list
    character (len=480) :: msr
    integer :: alloc_err, first, freq, lev, nDims, size, swid, status
    integer :: start(3), stride(3), edge(3), dims(3)
    integer :: nFreqs, nLevels, nTimes, nFreqsOr1, nLevelsOr1, myNumProfs
    logical :: firstCheck, lastCheck

    real, allocatable :: realSurf(:), realProf(:), real3(:,:,:)
    logical :: dontfail
    logical :: ReadingStatus
!  How to deal with status and columnTypes? swrfld fails
!  with char data on Linux
!  Have recourse to ints2Strings and strings2Ints if USEINTS4STRINGS
!    character (LEN=8), allocatable :: the_status_buffer(:)
!    character (LEN=L2GPNameLen), allocatable :: the_status_buffer(:)
!    integer, allocatable, dimension(:,:) :: string_buffer

    ! Don't fail when trying to read an mls-specific field 
    ! if the file is from another Aura instrument
    dontfail = (HMOT /= 'M')
    ReadingStatus = .false.
    if ( present(ReadStatus) ) ReadingStatus = ReadStatus

    ! Attach to the swath for reading

    l2gp%Name = swathname

    select case (HMOT)
    case ('H')
      swid = mls_swattach(L2FileHandle, 'HIRDLS', hdfVersion=HDFVERSION_4)
      DF_Name = TRIM(l2gp%Name)
      DF_Precision = TRIM(l2gp%Name) // 'Precision'
      l2gp%MissingValue = -999.
    case ('M')
      swid = mls_swattach(L2FileHandle, TRIM(l2gp%Name), hdfVersion=HDFVERSION_4)
      DF_Name = DATA_FIELD1
      DF_Precision = DATA_FIELD2
    case default
    end select

    if ( swid == -1) call MLSMessage ( MLSMSG_Error, ModuleName, 'Failed to &
         &attach to hdfeos2 swath interface for reading: ' // trim(swathname))

    ! Get dimension information

    lev = 0
    freq = 0

    nDims = swinqdims(swid, list, dims)
    if ( nDims == -1) call MLSMessage ( MLSMSG_Error, ModuleName, 'Failed to &
         &get dimension information on hdfeos2 swath ' // trim(swathname))
    if ( INDEX(list,'nLevels') /= 0 ) lev = 1

    select case (HMOT)
    case ('H')
      if ( INDEX(list,'Chan') /= 0 ) freq = 1
    case ('M')
      if ( INDEX(list,'Freq') /= 0 ) freq = 1
    case default
    end select

    size = mls_swdiminfo(swid, 'nTimes', hdfVersion=HDFVERSION_4)
    l2gp%nTimes = size
    nTimes=size
    if ( lev == 0 ) then
       nLevels = 0
    else
      size = mls_swdiminfo(swid, 'nLevels', hdfVersion=HDFVERSION_4)
      nLevels = size

    end if

    if ( freq == 1 .and. HMOT == 'M') then
      size = mls_swdiminfo(swid, 'nFreqs', hdfVersion=HDFVERSION_4)
      nFreqs = size
    elseif ( freq == 1 .and. HMOT == 'H') then
      size = mls_swdiminfo(swid, 'nChans', hdfVersion=HDFVERSION_4)
      nFreqs = size
    else
      nFreqs = 0
    end if

    ! Check optional input arguments

    firstCheck = present(firstProf)
    lastCheck = present(lastProf)

    if ( firstCheck ) then

       if ( (firstProf >= l2gp%nTimes) .OR. (firstProf < 0) ) then
          msr = MLSMSG_INPUT // 'firstProf ' // trim(swathname)
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       else
          first = firstProf
       end if

    else

       first = 0

    end if

    if ( lastCheck ) then

       if ( lastProf < first ) then
          msr = MLSMSG_INPUT // 'lastProf ' // trim(swathname)
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

       if ( lastProf >= nTimes ) then
          myNumProfs = nTimes - first
       else
          myNumProfs = lastProf - first + 1
       end if

    else

       myNumProfs = nTimes - first

    end if

    ! Allocate result

    call SetupNewL2GPRecord ( l2gp, nFreqs=nFreqs, nLevels=nLevels, &
    & nTimes=myNumProfs, FillIn = .true. )

    ! Allocate temporary arrays

    nFreqsOr1=MAX(nFreqs,1)
    nLevelsOr1=MAX(nLevels, 1)
    allocate ( realProf(myNumProfs), realSurf(l2gp%nLevels), &
      &   real3(nFreqsOr1,nLevelsOr1,myNumProfs), STAT=alloc_err )
      ! &   string_buffer(1,myNumProfs), &
    if ( alloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//' various things in ReadL2GPData' )

    ! Read the horizontal geolocation fields

    start(1) = 0
    start(2) = 0
    start(3) = first
    stride = 1
    edge(1) = nFreqsOr1
    edge(2) = nLevelsOr1
    edge(3) = myNumProfs
    status=0

    status = mls_swrdfld(swid, 'Latitude', start(3:3), stride(3:3), edge(3:3), &
      &    realProf, hdfVersion=HDFVERSION_4)
    l2gp%latitude = realProf

    status = mls_swrdfld(swid, 'Longitude', start(3:3), stride(3:3), edge(3:3), &
      &    realProf, hdfVersion=HDFVERSION_4)
    l2gp%longitude = realProf

    status = mls_swrdfld(swid, 'Time', start(3:3), stride(3:3), edge(3:3), &
      &    l2gp%time, hdfVersion=HDFVERSION_4)

    status = mls_swrdfld(swid, 'LocalSolarTime', start(3:3), stride(3:3), edge(3:3), &
      &    realProf, hdfVersion=HDFVERSION_4)
    l2gp%solarTime = realProf

    status = mls_swrdfld(swid, 'SolarZenithAngle', start(3:3), stride(3:3), edge(3:3), &
      &    realProf, hdfVersion=HDFVERSION_4)
    l2gp%solarZenith = realProf

    status = mls_swrdfld(swid, 'LineOfSightAngle', start(3:3), stride(3:3), edge(3:3), &
      &    realProf, hdfVersion=HDFVERSION_4, dontfail=dontfail)
    l2gp%losAngle = realProf

    status = mls_swrdfld(swid, 'OrbitGeodeticAngle', start(3:3), stride(3:3), edge(3:3), &
      &    realProf, hdfVersion=HDFVERSION_4, dontfail=dontfail)
    l2gp%geodAngle = realProf

    status = mls_swrdfld(swid, 'ChunkNumber', start(3:3), stride(3:3), edge(3:3), &
      &    l2gp%chunkNumber, hdfVersion=HDFVERSION_4, dontfail=dontfail)

    ! Read the pressures vertical geolocation field, if it exists

    if ( lev /= 0 ) then

       status = mls_swrdfld(swid, 'Pressure', start(2:2), stride(2:2), edge(2:2), &
         & realSurf, hdfVersion=HDFVERSION_4, dontfail=dontfail)
       l2gp%pressures = realSurf

    end if

    ! Read the frequency geolocation field, if it exists

    if ( freq == 1 ) then

       edge(1) = l2gp%nFreqs

       status = mls_swrdfld(swid, 'Frequency', start(1:1), stride(1:1), edge(1:1), &
         & l2gp%frequency, hdfVersion=HDFVERSION_4)

    end if

    ! Read the data fields that may have 1-3 dimensions

    if ( freq == 1 ) then

       status = mls_swrdfld(swid, trim(DF_Name), start, stride, edge, real3, &
         & hdfVersion=HDFVERSION_4)
       l2gp%l2gpValue = real3

       status = mls_swrdfld(swid, trim(DF_Precision), start, stride, edge, real3, &
         & hdfVersion=HDFVERSION_4)
       l2gp%l2gpPrecision = real3

    else if ( lev == 1 ) then

      status = mls_swrdfld( swid, trim(DF_Name), start(2:3), stride(2:3), &
        &   edge(2:3), real3(1,:,:), hdfVersion=HDFVERSION_4 )
      l2gp%l2gpValue = real3
      
      status = mls_swrdfld( swid, trim(DF_Precision), start(2:3), stride(2:3), &
        & edge(2:3), real3(1,:,:), hdfVersion=HDFVERSION_4 )
      l2gp%l2gpPrecision = real3
      
    else

       status = mls_swrdfld( swid, trim(DF_Name), start(3:3), stride(3:3), edge(3:3), &
         &   real3(1,1,:), hdfVersion=HDFVERSION_4 )
       l2gp%l2gpValue = real3

       status = mls_swrdfld( swid, trim(DF_Precision), start(3:3), stride(3:3), edge(3:3), &
            real3(1,1,:), hdfVersion=HDFVERSION_4 )
       l2gp%l2gpPrecision = real3

    end if

    ! Read the data fields that are 1-dimensional


    l2gp%status = ' ' ! So it has a value.
    if ( ReadingStatus) &
      & status = mls_swrdfld( swid, 'Status',start(3:3),stride(3:3),edge(3:3),&
      & l2gp%status, hdfVersion=HDFVERSION_4, dontfail=.true. )

    status = mls_swrdfld(swid, 'Quality', start(3:3), stride(3:3), edge(3:3), &
      &   realProf, hdfVersion=HDFVERSION_4, dontfail=dontfail)
    l2gp%quality = realProf

    ! Deallocate local variables

    deallocate ( realSurf, realProf, real3, STAT=alloc_err )
    if ( alloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
         'Failed deallocation of local real variables.' )

    ! deallocate ( string_buffer, STAT=alloc_err )
    if ( alloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
         'Failed deallocation of status buffer.' )

    !  After reading, detach from swath interface

    status = mls_swdetach(swid, hdfVersion=HDFVERSION_4)
    if ( status == -1) call MLSMessage ( MLSMSG_Error, ModuleName, &
         & 'Failed to detach from swath interface after reading.' )

    ! Set numProfs if wanted
    if ( present(numProfs) ) numProfs=myNumProfs

    !-----------------------------
  end subroutine ReadL2GPData_hdf4
  !-----------------------------

  ! ------------------- ReadL2GPData_hdf5 ----------------

  subroutine ReadL2GPData_hdf5(L2FileHandle, swathname, l2gp, HMOT, &
d602 1
d648 1
a648 1
    ! print*," in readl2gpdata_hdf5: first/last=",firstprof,lastprof
d654 1
a654 1
      swid = mls_SWattach(L2FileHandle, 'HIRDLS', hdfVersion=HDFVERSION_5)
d659 1
a659 1
      swid = mls_SWattach(L2FileHandle, l2gp%Name, hdfVersion=HDFVERSION_5)
d665 1
a665 1
         &attach to hdfeos5 swath interface for reading' // trim(swathname))
d672 5
a676 1
    nDims = HE5_SWinqdims(swid, list, dims)
d687 21
a707 19
    size = mls_swdiminfo(swid, 'nTimes', hdfVersion=HDFVERSION_5)
    ! This will be wrong if timeIsUnlim .eq. .TRUE. . 
    ! HE5_SWdiminfo returns 1 instead of the right answer.
    ! print *,"just called mls_swdiminfo(nTimes) : ", size
    status = HE5_swfldinfo(swid, trim(DF_Name), rank, flddims, &
      & numberType, dimlist, maxdimlist)
   ! print *, 'rank: ', rank
   ! print *, 'flddims: ', flddims(1:rank)
   ! print *, 'numberType: ', numberType(1:rank)
   ! print *, 'dimlist: ', dimlist
   ! print *, 'maxdimlist: ', maxdimlist
    call GetStringHashElement (dimlist, &
     & maxdimlist, 'nTimes', &
     & maxDimName, .false.)
   ! print *, 'maxdimName: ', maxdimName
    if ( maxDimName == 'Unlim' ) then
      status = StringElementNum(dimlist, 'nTimes', .false.)
     ! print *, 'elem num: ', status
      if ( status > 0 .and. status <= rank ) size = max(size, flddims(status))
d715 1
a715 1
      size = mls_swdiminfo(swid, 'nLevels', hdfVersion=HDFVERSION_5)
d721 1
a721 1
      size = mls_swdiminfo(swid, 'nFreqs', hdfVersion=HDFVERSION_5)
d724 1
a724 1
      size = mls_swdiminfo(swid, 'nChans', hdfVersion=HDFVERSION_5)
d807 1
a807 1
      edge(3:3), realProf, hdfVersion=HDFVERSION_5)
d811 1
a811 1
      &    realProf, hdfVersion=HDFVERSION_5)
d815 1
a815 1
      &    l2gp%time, hdfVersion=HDFVERSION_5)
d818 1
a818 1
      &    realProf, hdfVersion=HDFVERSION_5)
d822 1
a822 1
      &    realProf, hdfVersion=HDFVERSION_5)
d826 1
a826 1
      &    realProf, hdfVersion=HDFVERSION_5, dontfail=dontfail)
d830 1
a830 1
      &   realProf, hdfVersion=HDFVERSION_5, dontfail=dontfail)
d834 1
a834 1
      &    l2gp%chunkNumber, hdfVersion=HDFVERSION_5, dontfail=dontfail)
d841 1
a841 1
         & realSurf, hdfVersion=HDFVERSION_5, dontfail=dontfail)
d853 1
a853 1
         & realFreq, hdfVersion=HDFVERSION_5, dontfail=dontfail)
d863 1
a863 1
         & hdfVersion=HDFVERSION_5)
d867 1
a867 1
         & hdfVersion=HDFVERSION_5)
d873 1
a873 1
            edge(2:3), real3(1,:,:), hdfVersion=HDFVERSION_5 )
d877 1
a877 1
            edge(2:3), real3(1,:,:), hdfVersion=HDFVERSION_5 )
d883 1
a883 1
         &   real3(1,1,:), hdfVersion=HDFVERSION_5 )
d887 1
a887 1
            real3(1,1,:), hdfVersion=HDFVERSION_5 )
d897 1
a897 1
      & l2gp%status, hdfVersion=HDFVERSION_5, dontfail=.true. )
d900 1
a900 1
      edge(3:3),realProf, hdfVersion=HDFVERSION_5, dontfail=dontfail)
d915 1
a915 1
    status = mls_SWdetach(swid, hdfVersion=HDFVERSION_5)
d918 1
a918 1
    !print*," leaving readl2gpdata_hdf5: first/last/read=",&
d925 1
a925 1
  end subroutine ReadL2GPData_hdf5
d928 2
a929 403
  ! --------------------------------------  OutputL2GP_createFile_hdf4  -----
  subroutine OutputL2GP_createFile_hdf4 (l2gp, L2FileHandle, &
    & swathName, filename)
  use MLSHDFEOS, only: mls_swcreate, mls_dfldsetup, mls_gfldsetup, mls_swdefdim

    ! Brief description of subroutine
    ! This subroutine sets up the structural definitions in an empty L2GP file.

    ! Arguments

    integer, intent(in) :: L2FileHandle ! From swopen
    type( l2GPData_T ), intent(inout) :: l2gp
    character (len=*), optional, intent(in) :: swathName ! Defaults to l2gp%swathName
    character (len=*), optional, intent(in) :: fileName

    ! Parameters

    character (len=*), parameter :: DIM_ERR = 'Failed to define dimension '
    character (len=*), parameter :: GEO_ERR = &
         & 'failed to define geolocation field '
    character (len=*), parameter :: DAT_ERR = 'Failed to define data field '

    ! Variables

    character (len=480) :: MSR
    character (len=132) :: NAME   ! From l2gp%name

    integer :: SWID, STATUS

    if ( present(swathName) ) then
       name=swathName
    else
       name=l2gp%name
    end if

    if ( DEEBUG ) then
      print *, 'Creating a swath named ', TRIM(name)
      print *, 'nTimes ', l2gp%nTimes
      print *, 'nLevels ', l2gp%nLevels
      print *, 'nFreqs ', l2gp%nFreqs
    endif
    ! Create the swath within the file

    ! print *, 'About to sw_create ', TRIM(name)
    ! if ( present(filename)) print *, 'file name ', TRIM(filename)
    swid = mls_swcreate(L2FileHandle, TRIM(name), &
      & filename=filename, hdfVersion=HDFVERSION_4)
    if ( swid == -1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Failed to create swath ' // trim(name) &
        & // ' (maybe has the same name as another swath in this file?)' )
    end if

    ! Define dimensions

    status = mls_swdefdim(swid, 'nTimes', l2gp%nTimes, &
      & hdfVersion=HDFVERSION_4)

    if ( l2gp%nLevels > 0 ) then
      status = mls_swdefdim(swid, 'nLevels', l2gp%nLevels, &
        & hdfVersion=HDFVERSION_4)
    end if

    if ( l2gp%nFreqs > 0 ) then
      status = mls_swdefdim(swid, 'nFreqs', l2gp%nFreqs, &
        & hdfVersion=HDFVERSION_4)
    end if

    ! Define horizontal geolocation fields using above dimensions

    status = mls_gfldsetup(swid, 'Latitude', 'nTimes', DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)
         
    status = mls_gfldsetup(swid, 'Longitude', 'nTimes', DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

    status = mls_gfldsetup(swid, 'Time', 'nTimes', DEFAULTMAXDIM, &
      & DFNT_FLOAT64, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

    status = mls_gfldsetup(swid, 'LocalSolarTime', 'nTimes', DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

    status = mls_gfldsetup(swid, 'SolarZenithAngle', 'nTimes', DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

    status = mls_gfldsetup(swid, 'LineOfSightAngle', 'nTimes', DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

    status = mls_gfldsetup(swid, 'OrbitGeodeticAngle', 'nTimes', DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

    status = mls_gfldsetup(swid, 'ChunkNumber', 'nTimes', DEFAULTMAXDIM, &
      & DFNT_INT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

    if ( l2gp%nLevels > 0 ) then
      status = mls_gfldsetup(swid, 'Pressure', 'nLevels', DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)
    end if

    if ( l2gp%nFreqs > 0 ) then
      status = mls_gfldsetup(swid, 'Frequency', 'nFreqs', DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)
    end if

    ! Define data fields using above dimensions

    if ( (l2gp%nFreqs > 0) .AND. (l2gp%nLevels > 0) ) then

      status = mls_dfldsetup(swid, 'L2gpValue', 'nFreqs,nLevels,nTimes', &
      & DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

      status = mls_dfldsetup(swid, 'L2gpPrecision', 'nFreqs,nLevels,nTimes', &
      & DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

    else if ( l2gp%nLevels > 0 ) then

      status = mls_dfldsetup(swid, 'L2gpValue', 'nLevels,nTimes', &
      & DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

      status = mls_dfldsetup(swid, 'L2gpPrecision', 'nLevels,nTimes', &
      & DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

    else

      status = mls_dfldsetup(swid, 'L2gpValue', 'nTimes', &
      & DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

      status = mls_dfldsetup(swid, 'L2gpPrecision', 'nTimes', &
      & DEFAULTMAXDIM, &
      & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
      & hdfVersion=HDFVERSION_4)

    end if

    status = mls_dfldsetup(swid, 'Status', 'nTimes', &
    & DEFAULTMAXDIM, &
    & DFNT_CHAR8, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
    & hdfVersion=HDFVERSION_4)

    status = mls_dfldsetup(swid, 'Quality', 'nTimes', &
    & DEFAULTMAXDIM, &
    & DFNT_FLOAT32, HDFE_NOMERGE, DEFAULT_CHUNKRANK, DEFAULT_CHUNKDIMS, &
    & hdfVersion=HDFVERSION_4)

    ! Detach from the swath interface.  This stores the swath info within the
    ! file and must be done before writing or reading data to or from the
    ! swath.

    status = mls_swdetach(swid, hdfVersion=HDFVERSION_4)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Failed to detach from swath interface after definition.' )
    end if

    !--------------------------------------
  end subroutine OutputL2GP_createFile_hdf4
  !--------------------------------------

  !-----------------------------------------  OutputL2GP_writeGeo_hdf4  -----
  subroutine OutputL2GP_writeGeo_hdf4 (l2gp, l2FileHandle, swathName, offset)
  use MLSHDFEOS, only: mls_swwrfld
  use dump_0, only: DUMP

    ! Brief description of subroutine
    ! This subroutine writes the geolocation fields to an L2GP output file.

    ! Arguments

    type( l2GPData_T ), intent(inout) :: l2gp
    integer, intent(in) :: l2FileHandle ! From swopen
    character (len=*), intent(in), optional :: swathName ! Defaults to l2gp%name
    integer,intent(IN),optional::offset

    ! Parameters

    character (len=*), parameter :: WR_ERR = &
         & 'Failed to write geolocation field '

    ! Variables

    character (len=132) :: name ! Either swathName or l2gp%name

    integer :: status, swid,myOffset
    integer :: start(1), stride(1), edge(1)

    ! Begin
    if (present(offset)) then
       myOffset=offset
    else
       myOffset=0
    endif

    if ( present(swathName) ) then
       name=swathName
    else
       name=l2gp%name
    end if

    ! print *, 'Trying to swattach to write'
    ! print *, l2FileHandle, trim(name)
    swid = mls_swattach (l2FileHandle, trim(name), hdfVersion=HDFVERSION_4)

    ! Write data to the fields

    stride(1) = 1
    start(1) = myOffset
    edge(1) = l2gp%nTimes

    ! print *, 'Writing geolocation fields'
    ! print *, 'start', start
    ! print *, 'stride', stride
    ! print *, 'edge', edge
    ! print *, 'shape(Latitude)', shape(l2gp%latitude)

    status = mls_swwrfld(swid, 'Latitude', start, stride, edge, &
         real(l2gp%latitude), hdfVersion=HDFVERSION_4)

    status = mls_swwrfld(swid, 'Longitude', start, stride, edge, &
         real(l2gp%longitude), hdfVersion=HDFVERSION_4)

    status = mls_swwrfld(swid, 'Time', start, stride, edge, &
         l2gp%time, hdfVersion=HDFVERSION_4)

    status = mls_swwrfld(swid, 'LocalSolarTime', start, stride, edge, &
        real(l2gp%solarTime), hdfVersion=HDFVERSION_4)

    status = mls_swwrfld(swid, 'SolarZenithAngle', start, stride, edge, &
         real(l2gp%solarZenith), hdfVersion=HDFVERSION_4)

    status = mls_swwrfld(swid, 'LineOfSightAngle', start, stride, edge, &
         real(l2gp%losAngle), hdfVersion=HDFVERSION_4)

    status = mls_swwrfld(swid, 'OrbitGeodeticAngle', start, stride, edge, &
         real(l2gp%geodAngle), hdfVersion=HDFVERSION_4)

    status = mls_swwrfld(swid, 'ChunkNumber', start, stride, edge, &
         l2gp%chunkNumber, hdfVersion=HDFVERSION_4)

    if ( l2gp%nLevels > 0 ) then
       edge(1) = l2gp%nLevels
       start(1)=0 ! needed because offset may have made this /=0
       status = mls_swwrfld(swid, 'Pressure', start, stride, edge, &
            real(l2gp%pressures), hdfVersion=HDFVERSION_4)
    end if

    if ( l2gp%nFreqs > 0 ) then
       edge(1) = l2gp%nFreqs
       start(1)=0 ! needed because offset may have made this /=0
       status = mls_swwrfld(swid, 'Frequency', start, stride, edge, &
            real(l2gp%frequency), hdfVersion=HDFVERSION_4)
    end if

    ! Detach from the swath interface.  

    status = mls_swdetach(swid, hdfVersion=HDFVERSION_4)

    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach from swath interface' )
    end if

    !------------------------------------
  end subroutine OutputL2GP_writeGeo_hdf4
  !------------------------------------

  !----------------------------------------  OutputL2GP_writeData_hdf4  -----
  subroutine OutputL2GP_writeData_hdf4(l2gp, l2FileHandle, swathName, offset)
  use MLSHDFEOS, only: mls_swwrfld

    ! Brief description of subroutine
    ! This subroutine writes the data fields to an L2GP output file.

    ! Arguments

    type( l2GPData_T ), intent(inout) :: l2gp
    integer, intent(in) :: l2FileHandle ! From swopen
    character (len=*), intent(in), optional :: swathName ! Defaults to l2gp%name
    integer,intent(IN),optional::offset

    ! Parameters

    character (len=*), parameter :: WR_ERR = 'Failed to write data field '

    ! Variables

    character (len=132) :: name     ! Either swathName or l2gp%name

    integer :: status, myOffset
    integer :: start(3), stride(3), edge(3)
    integer :: swid

!  How to deal with status and columnTypes? swrfld fails
!  with char data on Linux
!  Have recourse to ints2Strings and strings2Ints if USEINTS4STRINGS
!    character (LEN=8), allocatable :: the_status_buffer(:)
!    character (LEN=L2GPNameLen), allocatable :: the_status_buffer(:)
!    integer, allocatable, dimension(:,:) :: string_buffer

    ! Begin
    if (present(offset)) then
       myOffset=offset
    else
       myOffset=0
    endif
    if ( present(swathName) ) then
       name=swathName
    else
       name=l2gp%name
    end if
    ! Write data to the fields

    start = 0
    stride = 1
    start(3)= myOffset
    edge(1) = l2gp%nFreqs
    edge(2) = l2gp%nLevels
    edge(3) = l2gp%nTimes
    ! print *, 'Trying to swattach to write data'
    swid = mls_swattach (l2FileHandle, name, hdfVersion=HDFVERSION_4)
    if(DEEBUG) print *, 'swath name: ', trim(name)
    if(DEEBUG) print *, 'swath id: ', swid
    if(DEEBUG) print *, 'shape(L2gpValue): ', shape(l2gp%l2gpValue)
    if ( l2gp%nFreqs > 0 ) then
       ! Value and Precision are 3-D fields

       if(DEEBUG) print *, 'about to write 3-d real field: L2gpValue'
       if(DEEBUG) print *, 'start: ', start
       if(DEEBUG) print *, 'stride: ', stride
       if(DEEBUG) print *, 'edge: ', edge
       status = mls_swwrfld(swid, 'L2gpValue', start, stride, edge, &
            & RESHAPE(real(l2gp%l2gpValue), (/SIZE(l2gp%l2gpValue)/)), &
            & hdfVersion=HDFVERSION_4 )
       status = mls_swwrfld(swid, 'L2gpPrecision', start, stride, edge, &
            & RESHAPE(real(l2gp%l2gpPrecision), (/SIZE(l2gp%l2gpPrecision)/)), &
            & hdfVersion=HDFVERSION_4 )

    else if ( l2gp%nLevels > 0 ) then
       ! Value and Precision are 2-D fields

       if(DEEBUG) print *, 'about to write 2-d real field: L2gpValue'
       if(DEEBUG) print *, 'start: ', start(2:3)
       if(DEEBUG) print *, 'stride: ', stride(2:3)
       if(DEEBUG) print *, 'edge: ', edge(2:3)
       status = mls_swwrfld( swid, 'L2gpValue', start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpValue(1,:,:)), hdfVersion=HDFVERSION_4 )

       status = mls_swwrfld( swid, 'L2gpPrecision', start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpPrecision(1,:,:) ), hdfVersion=HDFVERSION_4)
    else

       if(DEEBUG) print *, 'about to write 1-d real field: L2gpValue'
       if(DEEBUG) print *, 'start: ', start(3:3)
       if(DEEBUG) print *, 'stride: ', stride(3:3)
       if(DEEBUG) print *, 'edge: ', edge(3:3)
       ! Value and Precision are 1-D fields
       status = mls_swwrfld( swid, 'L2gpValue', start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpValue(1,1,:) ), hdfVersion=HDFVERSION_4)
       status = mls_swwrfld( swid, 'L2gpPrecision', start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpPrecision(1,1,:) ), hdfVersion=HDFVERSION_4)
    end if

    ! 1-D status & quality fields

    status = mls_swwrfld(swid, 'Status', start(3:3), stride(3:3), edge(3:3), &
       &   l2gp%status, hdfVersion=HDFVERSION_4, dontfail=.true.)
    !  l2gp%quality = 0 !??????? Why was this here !??? NJL
    status = mls_swwrfld(swid, 'Quality', start(3:3), stride(3:3), edge(3:3), &
         real(l2gp%quality), hdfVersion=HDFVERSION_4)

    !     Detach from the swath interface.

    status = mls_swdetach(swid, hdfVersion=HDFVERSION_4)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach  from swath interface' )
    end if

  !-------------------------------------
  end subroutine OutputL2GP_writeData_hdf4
  !-------------------------------------

  ! --------------------------------------  OutputL2GP_createFile_hdf5  -----
  subroutine OutputL2GP_createFile_hdf5 (l2gp, L2FileHandle, &
d944 1
d988 1
a988 1
      & filename=filename, hdfVersion=HDFVERSION_5)
d997 7
a1003 5
    ! Defining special "unlimited dimension called UNLIM
    ! print*,"Defined Unlim with size", HE5S_UNLIMITED_f
    ! status = HE5_SWdefdim(swid, UNLIM, HE5S_UNLIMITED_F)
    status = mls_swdefdim(swid, UNLIM, HE5S_UNLIMITED_F, &
      & hdfVersion=HDFVERSION_5)
d1006 1
a1006 1
      & hdfVersion=HDFVERSION_5)
d1010 1
a1010 1
        & hdfVersion=HDFVERSION_5)
d1015 1
a1015 1
        & hdfVersion=HDFVERSION_5)
a1019 2
!    print*,"Defining geolocation field ",GEO_FIELD1," of dim. ", DIM_NAME1
!    print*,"... and of type ",HE5T_NATIVE_FLOAT
d1024 2
a1025 5
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)

!    print*,"Defined geolocation field ",GEO_FIELD1,"of dim.", DIM_NAME1
!    print*,"... and of type ",HE5T_NATIVE_FLOAT
d1028 2
a1029 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1032 2
a1033 2
      & HE5T_NATIVE_DOUBLE, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1036 2
a1037 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1040 2
a1041 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1044 2
a1045 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1048 2
a1049 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1052 2
a1053 2
      & HE5T_NATIVE_INT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1058 2
a1059 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, 0, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1065 2
a1066 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, 0, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1077 2
a1078 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1082 2
a1083 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1091 2
a1092 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1096 2
a1097 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1105 2
a1106 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1110 2
a1111 2
      & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
      & hdfVersion=HDFVERSION_5)
d1120 1
a1120 1
    & hdfVersion=HDFVERSION_5)
d1126 2
a1127 2
    & HE5T_NATIVE_FLOAT, HDFE_NOMERGE, chunk_rank, chunk_dims, &
    & hdfVersion=HDFVERSION_5)
d1129 3
a1131 23
    ! Set Fill Values
    status =  mls_swsetfill(swid, DATA_FIELDS, HE5T_NATIVE_FLOAT, &
     & l2gp%MissingValue)
    if ( status == -1 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
         & 'Cant set fill for ' // DATA_FIELDS )
    status =  mls_swsetfill(swid, GEO_FIELDS, HE5T_NATIVE_FLOAT, &
     & l2gp%MissingValue)
    if ( status == -1 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
         & 'Cant set fill for ' // GEO_FIELDS )
    status =  mls_swsetfill(swid, 'Time', HE5T_NATIVE_DOUBLE, &
     & real(l2gp%MissingValue, r8) )
    if ( status == -1 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
         & 'Cant set fill for ' // 'Time' )
    status =  mls_swsetfill(swid, 'ChunkNumber', HE5T_NATIVE_INT, &
     & int(l2gp%MissingValue) )
    if ( status == -1 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
         & 'Cant set fill for ' // 'ChunkNumber' )
    if ( l2gp%nLevels > 0 ) then
      status =  mls_swsetfill(swid, 'Pressure', HE5T_NATIVE_FLOAT, &
d1135 2
a1136 5
           & 'Cant set fill for ' // 'Pressure' )
    endif

    if ( l2gp%nFreqs > 0 ) then
      status =  mls_swsetfill(swid, 'Frequency', HE5T_NATIVE_FLOAT, &
d1140 26
a1165 1
           & 'Cant set fill for ' // 'Frequency' )
d1172 1
a1172 1
    status = mls_SWdetach(swid, hdfVersion=HDFVERSION_5)
d1179 1
a1179 1
  end subroutine OutputL2GP_createFile_hdf5
d1182 3
a1184 2
  !-----------------------------------------  OutputL2GP_writeGeo_hdf5  -----
  subroutine OutputL2GP_writeGeo_hdf5 (l2gp, l2FileHandle, swathName,offset)
d1195 1
d1224 1
a1224 1
    swid = mls_SWattach (l2FileHandle, name, hdfVersion=HDFVERSION_5)
d1238 1
a1238 1
         real(l2gp%latitude), hdfVersion=HDFVERSION_5)
d1241 1
a1241 1
         real(l2gp%longitude), hdfVersion=HDFVERSION_5)
d1244 1
a1244 1
         l2gp%time, hdfVersion=HDFVERSION_5)
d1247 1
a1247 1
        real(l2gp%solarTime), hdfVersion=HDFVERSION_5)
d1250 1
a1250 1
         real(l2gp%solarZenith), hdfVersion=HDFVERSION_5)
d1253 1
a1253 1
         real(l2gp%losAngle), hdfVersion=HDFVERSION_5)
d1256 1
a1256 1
         real(l2gp%geodAngle), hdfVersion=HDFVERSION_5)
d1259 1
a1259 1
         l2gp%chunkNumber, hdfVersion=HDFVERSION_5)
d1265 1
a1265 1
            real(l2gp%pressures), hdfVersion=HDFVERSION_5)
d1272 1
a1272 1
            real(l2gp%frequency), hdfVersion=HDFVERSION_5)
d1277 1
a1277 1
    status = mls_SWdetach(swid, hdfVersion=HDFVERSION_5)
d1284 1
a1284 1
  end subroutine OutputL2GP_writeGeo_hdf5
d1287 3
a1289 2
  !----------------------------------------  OutputL2GP_writeData_hdf5  -----
  subroutine OutputL2GP_writeData_hdf5(l2gp, l2FileHandle, swathName,offset)
d1301 1
d1344 1
a1344 1
    swid = mls_SWattach (l2FileHandle, name, hdfVersion=HDFVERSION_5)
d1349 1
a1349 1
            & hdfVersion=HDFVERSION_5 )
d1352 1
a1352 1
            & hdfVersion=HDFVERSION_5 )
d1358 1
a1358 1
            edge(2:3), real(l2gp%l2gpValue(1,:,:) ), hdfVersion=HDFVERSION_5)
d1360 1
a1360 1
            edge(2:3), real(l2gp%l2gpPrecision(1,:,:) ), hdfVersion=HDFVERSION_5)
d1365 1
a1365 1
            real(l2gp%l2gpValue(1,1,:) ), hdfVersion=HDFVERSION_5)
d1367 1
a1367 1
            real(l2gp%l2gpPrecision(1,1,:) ), hdfVersion=HDFVERSION_5)
d1373 1
a1373 1
       &   l2gp%status, hdfVersion=HDFVERSION_5, dontfail=.true.)
d1376 1
a1376 1
         real(l2gp%quality), hdfVersion=HDFVERSION_5)
d1380 1
a1380 1
    status = mls_SWdetach(swid, hdfVersion=HDFVERSION_5)
d1391 1
a1391 1
  end subroutine OutputL2GP_writeData_hdf5
d1701 7
a1707 14
    if (myhdfVersion == HDFVERSION_4) then
      call OutputL2GP_createFile_hdf4 (l2gp, l2FileHandle, swathName, filename)
      call OutputL2GP_writeGeo_hdf4 (l2gp, l2FileHandle, swathName)
      call OutputL2GP_writeData_hdf4 (l2gp, l2FileHandle, swathName)
    elseif (myhdfVersion /= HDFVERSION_5) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unrecognized hdfVersion passed to WriteL2GPData" )
    else
      ! if(DEEBUG) print *, 'Creating hdfeos5 file'
      call OutputL2GP_createFile_hdf5 (l2gp, l2FileHandle, swathName, filename)
      ! if(DEEBUG) print *, 'Writing geolocation data'
      call OutputL2GP_writeGeo_hdf5 (l2gp, l2FileHandle, swathName)
      ! if(DEEBUG) print *, 'Writing values, precision'
      call OutputL2GP_writeData_hdf5 (l2gp, l2FileHandle, swathName)
d1783 2
a1784 2
        call OutputL2GP_createFile_hdf4 (l2gp, L2FileHandle, myswathName, &
          & filename)
d1787 2
a1788 2
        call OutputL2GP_createFile_hdf5 (l2gp, L2FileHandle, myswathName, &
          & filename)
d1800 4
a1805 2
        call OutputL2GP_writeGeo_hdf4 (l2gp, l2FileHandle, myswathName, offset)
        call OutputL2GP_writeData_hdf4 (l2gp, l2FileHandle, myswathName, offset)
a1806 2
        call OutputL2GP_writeGeo_hdf5 (l2gp, l2FileHandle, myswathName, offset)
        call OutputL2GP_writeData_hdf5 (l2gp, l2FileHandle, myswathName, offset)
d2058 3
@


2.77
log
@Uses actual num of profiles for nTimes even if Unlim
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.76 2003/08/28 23:51:03 livesey Exp $"
d977 2
a978 3
    print*,"just called inqdims: nDims=",ndims,"list=",list,"dims=",dims
    if (nDims == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &get dimension information on hdfeos5 swath ' // trim(swathname))
a1008 1
    print*,"Now nTimes : ", size
d2760 3
@


2.76
log
@Various bug fixes to the AppendL2GP stuff
@
text
@d21 1
a21 1
    & ints2Strings, list2array, lowercase, strings2Ints
d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.75 2003/08/27 20:06:26 livesey Exp $"
d889 1
a889 1
  use HDFEOS5, only: HE5_swattach, HE5_swdetach, HE5_SWINQDIMS
d923 6
d952 1
a952 1
    !print*," in readl2gpdata_hdf5: first/last=",firstprof,lastprof
d977 1
a977 1
    !print*,"just called inqdims: nDims=",ndims,"list=",list,"dims=",dims
d991 17
a1007 1
      
d1010 1
d2762 3
@


2.75
log
@Removed some print statements
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.74 2003/07/21 23:32:09 pwagner Exp $"
a267 1
    useNTimes=MAX(useNTimes,1)
d1680 1
a1680 1
    status = mls_swdefdim(swid, 'nTimes', l2gp%nTimes, &
d1703 1
d1837 1
d2451 1
d2477 1
a2477 1
    if (myLastProfile <= 0) then
a2479 8
    elseif (myhdfVersion == HDFVERSION_4) then
      if(DEEBUG) print *, 'Writing geolocation data'
      call OutputL2GP_writeGeo_hdf4 (l2gp, l2FileHandle, myswathName, offset)
      if(DEEBUG) print *, 'Writing swath data'
      call OutputL2GP_writeData_hdf4 (l2gp, l2FileHandle, myswathName, offset)
    elseif (myhdfVersion /= HDFVERSION_5) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unrecognized hdfVersion passed to AppendL2GPData" )
d2481 16
a2496 7
      call OutputL2GP_writeGeo_hdf5 (l2gp, l2FileHandle, myswathName, offset)
      call OutputL2GP_writeData_hdf5 (l2gp, l2FileHandle, myswathName, offset)
      if ( .not. swath_exists .and. APPENDSWRITEATTRIBUTES) then
        call OutputL2GP_attributes_hdf5 (l2gp, l2FileHandle, swathName)
        call SetL2GP_aliases (l2gp, l2FileHandle, swathName)
      endif
    endif
d2739 3
@


2.74
log
@Will write attributes, create alias when appending hdfeos5 if mustcreate
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.73 2003/07/15 23:35:11 pwagner Exp $"
a1379 2
    print*,'Detached from swath sucessfully'

a1438 1
    call dump ( l2gp%latitude, 'latitude' )
d2736 3
@


2.73
log
@Disabled most printing; uses mls_SWdetach
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.72 2003/07/10 22:18:49 livesey Exp $"
d149 1
a149 1
  logical, parameter :: USEINTS4STRINGS = .false.  
d153 4
d634 1
a634 1
    integer, allocatable, dimension(:,:) :: string_buffer
a749 1
      &   string_buffer(1,myNumProfs), &
d751 1
d869 1
a869 1
    deallocate ( string_buffer, STAT=alloc_err )
d939 1
a939 1
    integer, allocatable, dimension(:,:) :: string_buffer
a1067 1
      &   string_buffer(1,myNumProfs), &
d1069 1
d1187 1
a1187 1
    deallocate ( string_buffer, STAT=alloc_err )
d1525 1
a1525 1
    integer, allocatable, dimension(:,:) :: string_buffer
d1998 1
a1998 1
    integer, allocatable, dimension(:,:) :: string_buffer
d2492 4
d2739 3
@


2.72
log
@More minor bug fixes, but lots of print statements.
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.71 2003/07/09 21:49:06 pwagner Exp $"
d218 1
a218 1
  logical, parameter :: DEEBUG = .true.  
d871 1
a871 1
    status = swdetach(swid)
d946 1
a946 1
    print *, 'Trying to read he5_swattach to read'
d1189 1
a1189 1
    status = HE5_SWdetach(swid)
d1245 2
a1246 2
    print *, 'About to sw_create ', TRIM(name)
    if ( present(filename)) print *, 'file name ', TRIM(filename)
d1370 1
a1370 1
    status = swdetach(swid)
d1422 2
a1423 2
    print *, 'Trying to swattach to write'
    print *, l2FileHandle, trim(name)
d1432 5
a1436 5
    print *, 'Writing geolocation fields'
    print *, 'start', start
    print *, 'stride', stride
    print *, 'edge', edge
    print *, 'shape(Latitude)', shape(l2gp%latitude)
d1479 1
a1479 1
    status = swdetach(swid)
d1542 1
a1542 1
    print *, 'Trying to swattach to write data'
d1596 1
a1596 1
    status = swdetach(swid)
d1662 2
a1663 2
    print *, 'About to sw_create ', TRIM(name)
    if ( present(filename) ) print *, 'file name ', TRIM(filename)
d1848 1
a1848 1
    status = HE5_SWdetach(swid)
d1897 1
a1897 1
    print *, 'Trying to he5_swattach to write geo'
d1905 5
a1909 5
    print *, 'Writing geolocation fields'
    print *, 'start', start
    print *, 'stride', stride
    print *, 'edge', edge
    print *, 'shape(Latitude)', shape(l2gp%latitude)
d1951 1
a1951 1
    status = HE5_SWdetach(swid)
d2015 1
a2015 1
    print *, 'Trying to he5_swattach to write data'
d2052 1
a2052 1
    status = HE5_SWdetach(swid)
d2160 1
a2160 1
    print *, 'Trying to he5_swattach to write attributes'
d2285 1
a2285 1
    status = HE5_SWdetach(swid)
d2321 1
a2321 1
    print *, 'Trying to he5_swattach to set alias'
d2340 1
a2340 1
    returnStatus = he5_SWdetach(sw_id)
d2436 1
a2436 1
      print *, 'createSwath: ', createSwath
d2438 1
a2438 1
      print *, 'Uh-oh, calling mls_swattach'
d2731 3
@


2.71
log
@Wont try swattaching just to see if swath already there
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.70 2003/07/08 00:43:17 livesey Exp $"
d1250 3
a1252 2
       msr = 'Failed to create swath ' // TRIM(name) &
        & // ' (maybe has the same name as another swath in this file?)'
d1376 2
d1385 1
d1407 1
a1407 1
    integer :: start(2), stride(2), edge(2)
d1423 2
a1424 1
    swid = mls_swattach (l2FileHandle, name, hdfVersion=HDFVERSION_4)
d1437 1
d2731 3
@


2.70
log
@Bug fix in zero length chunk test
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.69 2003/07/07 21:04:55 pwagner Exp $"
d644 1
a644 1
      swid = swattach(L2FileHandle, 'HIRDLS')
d649 1
a649 1
      swid = swattach(L2FileHandle, TRIM(l2gp%Name))
d946 1
d949 1
a949 1
      swid = HE5_SWattach(L2FileHandle, 'HIRDLS')
d954 1
a954 1
      swid = HE5_SWattach(L2FileHandle, l2gp%Name)
d1203 2
a1204 1
  subroutine OutputL2GP_createFile_hdf4 (l2gp, L2FileHandle, swathName)
d1215 1
d1245 4
a1248 1
    swid = mls_swcreate(L2FileHandle, TRIM(name), hdfVersion=HDFVERSION_4)
d1418 2
a1419 1
    swid = swattach (l2FileHandle, name)
d1427 6
d1536 2
a1537 1
    swid = swattach (l2FileHandle, name)
d1601 2
a1602 1
  subroutine OutputL2GP_createFile_hdf5 (l2gp, L2FileHandle, swathName,nLevels)
d1617 1
d1655 5
a1659 1
    swid = mls_SWcreate(L2FileHandle, trim(name), hdfVersion=HDFVERSION_5)
d1891 2
a1892 1
    swid = HE5_SWattach (l2FileHandle, name)
d1899 6
d2009 2
a2010 1
    swid = HE5_SWattach (l2FileHandle, name)
d2154 2
a2155 1
    swid = HE5_SWattach (l2FileHandle, name)
d2315 2
a2316 1
    sw_id = he5_swattach(l2FileHandle, trim(name))
d2346 1
a2346 1
  subroutine WriteL2GPData(l2gp, l2FileHandle, swathName, hdfVersion)
d2353 1
d2368 1
a2368 1
      call OutputL2GP_createFile_hdf4 (l2gp, l2FileHandle, swathName)
d2376 1
a2376 1
      call OutputL2GP_createFile_hdf5 (l2gp, l2FileHandle, swathName)
d2390 1
a2390 1
    & swathName, offset, TotNumProfs, hdfVersion)
d2400 1
d2404 1
d2427 16
a2442 4

    swathid = mls_swattach(L2FileHandle, trim(myswathName), &
      & hdfVersion=myhdfVersion, DONTFAIL=.true.)
    swath_exists = ( swathid > 0 )
a2444 1
      status = mls_swdetach(swathid, hdfVersion=myhdfVersion)
d2455 2
a2456 1
        call OutputL2GP_createFile_hdf4 (l2gp, L2FileHandle, myswathName)
d2459 2
a2460 1
        call OutputL2GP_createFile_hdf5 (l2gp, L2FileHandle, myswathName)
d2546 2
a2547 2
    call AppendL2GPData_fileID(l2gp, L2FileHandle, swathname, offset, &
      & hdfVersion=the_hdfVersion)
d2725 3
@


2.69
log
@Tries to deal sensibly with profile-less chunks
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.68 2003/07/02 00:55:27 pwagner Exp $"
d2422 1
a2422 1
    if (myLastProfile > 0) then
d2679 3
@


2.68
log
@Some improvements in DirectWrites of l2aux, l2gp
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.67 2003/06/26 00:04:46 pwagner Exp $"
d2378 1
d2387 5
d2422 4
a2425 1
    if (myhdfVersion == HDFVERSION_4) then
d2679 3
@


2.67
log
@Added optional DONTFAIL arg to MLS_SWATTACH
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.66 2003/06/20 19:31:39 pwagner Exp $"
d217 3
d1234 6
d1524 3
d1530 4
d1544 4
d1555 4
d2019 3
d2024 1
a2024 1
            & 'Failed to detach  from swath interface' )
d2123 1
a2123 1
    ! print *, 'Writing global attributes'
d2129 1
a2129 1
    ! print *, 'Writing swath attributes'
d2139 1
a2139 1
    ! print *, 'Writing geolocation attributes'
d2149 3
a2151 3
        ! print *, 'field ', field
        ! print *, 'title ', trim(theTitles(field))
        ! print *, 'units ', trim(theUnits(field))
d2207 3
a2209 3
    ! print *, 'Writing data attributes'
    ! print *, 'title ', trim(field_name)
    ! print *, 'units ', trim(units_name)
d2344 1
a2344 1
      ! print *, 'Creating hdfeos5 file'
d2346 1
a2346 1
      ! print *, 'Writing geolocation data'
d2348 1
a2348 1
      ! print *, 'Writing values, precision'
d2350 1
a2350 1
      ! print *, 'Writing attributes'
d2393 2
a2394 1
      status = mls_swdetach(swathid)
d2397 3
d2401 1
a2401 1
      if ( present(TotNumProfs) ) l2gp%nTimes = TotNumProfs
d2404 1
d2406 1
d2413 1
a2413 1
      l2gp%nTimes = actual_ntimes
d2417 1
d2419 1
d2670 3
@


2.66
log
@Changes to allow direct writing of products
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.65 2003/06/09 22:44:09 pwagner Exp $"
d2363 1
a2363 1
      & hdfVersion=myhdfVersion)
d2635 3
@


2.65
log
@Uses mls_swcreate
@
text
@d9 2
a10 1
  use Hdf, only: DFACC_READ, DFNT_CHAR8, DFNT_FLOAT32, DFNT_INT32, DFNT_FLOAT64
d14 4
a17 2
  use MLSFiles, only: FILENOTFOUND, HDFVERSION_4, HDFVERSION_5, &
    & MLS_HDF_VERSION, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF
d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.64 2003/04/21 19:34:59 pwagner Exp $"
d54 5
d1408 1
a1408 1
    start(1) = 0     ! myOffset
d1437 1
a1437 1
       ! start(1)=0 ! needed because offset may have made this /=0
d1444 1
a1444 1
       ! start(1)=0 ! needed because offset may have made this /=0
d1510 1
a1510 1
    ! start(3)= myOffset
d1558 1
a1558 1
    !-------------------------------------
d2001 1
a2001 1
    !-------------------------------------
d2331 2
a2332 2

  subroutine AppendL2GPData(l2gp,l2FileHandle,swathName,offset, hdfVersion)
d2343 1
d2346 1
d2348 4
d2359 23
d2384 2
a2385 2
      call OutputL2GP_writeGeo_hdf4 (l2gp, l2FileHandle, swathName, offset)
      call OutputL2GP_writeData_hdf4 (l2gp, l2FileHandle, swathName, offset)
d2390 2
a2391 2
      call OutputL2GP_writeGeo_hdf5 (l2gp, l2FileHandle, swathName, offset)
      call OutputL2GP_writeData_hdf5 (l2gp, l2FileHandle, swathName, offset)
d2394 70
a2463 1
  end subroutine AppendL2GPData
d2635 3
@


2.64
log
@Restored reading/writing char-valued Status datafield
@
text
@d10 1
a10 1
  use HDFEOS, only: SWATTACH, SWCREATE, SWDETACH, SWINQDIMS
d34 1
a34 1
       & "$Id: L2GPData.f90,v 2.63 2003/04/17 23:07:02 pwagner Exp $"
d1192 1
a1192 1
  use MLSHDFEOS, only: mls_dfldsetup, mls_gfldsetup, mls_swdefdim
d1225 1
a1225 1
    swid = swcreate(L2FileHandle, TRIM(name))
d1557 1
a1557 1
  use HDFEOS5, only: HE5_SWcreate, HE5_SWdetach, &
d1560 2
a1561 2
  use MLSHDFEOS, ONLY : mls_dfldsetup, mls_gfldsetup, mls_swdefdim, &
    & MLS_SWSETFILL
d1607 1
a1607 1
    swid = HE5_SWcreate(L2FileHandle, trim(name))
d2529 3
@


2.63
log
@Now uses MLSHDFEOS more thoroughly; can read HIRDLS L2GP files
@
text
@d34 1
a34 1
       & "$Id: L2GPData.f90,v 2.62 2003/04/15 23:14:50 pwagner Exp $"
d194 3
a196 12
     ! Unfortunately, currently we are neither reading nor writing this field
     ! As explained in several places below, the cwrappers beneath have failed
     ! to observe the right number of memory places required to represent
     ! the fortran data.
     ! paw has an idea of how to do it eventually:
     ! it will require writing a separate module in which to read/write
     ! character-valued swath data fields, named something like 
     ! char_swdata_m.f90
     ! In this new module, he5_swrdfld and he5_swwrfld will simply
     ! be integer externals, preventing any type conversion
     ! before it gives their start addresses to the c-wrappers beneath
     ! Then just make sure that the right number of bytes get transferred
d453 1
a453 1
       firstProf, lastProf, hdfVersion, HMOT)
d471 1
d502 1
a502 1
        & numProfs, firstProf, lastProf)
d508 1
a508 1
        & numProfs, firstProf, lastProf)
d517 1
a517 1
       firstProf, lastProf, hdfVersion, HMOT)
d535 1
d569 1
a569 1
    & numProfs, firstProf, lastProf)
d577 7
d592 1
d613 1
d624 2
a837 19
!??? There appears to be a problem with reading character data using
!??? HDF-EOS.  HDF_EOS's swrdfld expects a C void* pointer, no matter what
!??? the type of object.  Burkhard Burow's cfortran macros need to be told
!??? whether the argument is character, because compilers represent character
!??? arguments in various ways, usually different from non-character arguments.
!??? I.e., never the twain shall meet.
!    status = swrdfld(swid, DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
!      l2gp%status)
!    status = swrdfld(swid, DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
!      the_status_buffer)
! These lines commented out as they make NAG core dump on the deallocate statement.
! below.
!    if ( status == -1 ) then
!      msr = MLSMSG_L2GPRead // DATA_FIELD3
!      call MLSMessage ( MLSMSG_Error, ModuleName, msr )
!    end if
!    l2gp%status = the_status_buffer(:)(1:1)

    ! (   see note above concerning char_swdata_m.f90   )
d840 3
a842 6

!   if(USEINTS4STRINGS) then
!       status = mls_swrdfld(swid, DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
!         string_buffer, hdfVersion=HDFVERSION_4)
!       call ints2Strings(string_buffer, l2gp%status)
!    end if
d874 1
a874 1
    & numProfs, firstProf, lastProf)
d882 7
d897 1
d918 1
d929 2
a930 1

a1155 25
!??? There appears to be a problem with reading character data using
!??? HDF-EOS.  HDF_EOS's swrdfld expects a C void* pointer, no matter what
!??? the type of object.  Burkhard Burow's cfortran macros need to be told
!??? whether the argument is character, because compilers represent character
!??? arguments in various ways, usually different from non-character arguments.
!??? I.e., never the twain shall meet.
!    status = swrdfld(swid, DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
!      l2gp%status)
!    status = swrdfld(swid, DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
!      the_status_buffer)
! These lines commented out as they make NAG core dump on the deallocate statement.
! below.
!    if ( status == -1 ) then
!      msr = MLSMSG_L2GPRead // DATA_FIELD3
!      call MLSMessage ( MLSMSG_Error, ModuleName, msr )
!    end if
!    l2gp%status = the_status_buffer(:)(1:1)
    
    !   The above note was copied direct from the HDF4 version. The HDF5
    ! version has similar problems so these lines are commented too.
    !         status = HE5_SWrdfld(swid, DATA_FIELD3,start(3:3),&
    !    stride(3:3),edge(3:3), l2gp%status)
    !
    ! (   see note above concerning char_swdata_m.f90   )

d1157 3
a1159 10

   if(USEINTS4STRINGS) then
!       status = mls_swrdfld(swid,DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
!         string_buffer, hdfVersion=HDFVERSION_5)
!       call ints2Strings(string_buffer, l2gp%status)
    else
      call MLSMessage(MLSMSG_Debug, ModuleName, &
        "reading of status field disabled")
      status=0
    end if
d1536 2
a1537 10
   if(USEINTS4STRINGS) then
!      allocate(string_buffer(1,l2gp%nTimes))
!      call strings2Ints(l2gp%status, string_buffer)
!      status = mls_swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
!           string_buffer, hdfVersion=HDFVERSION_4)
!      deallocate(string_buffer)
   else
!      status = mls_swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
!           l2gp%status, hdfVersion=HDFVERSION_4)
   end if
a1735 3
!    print*,"Defining data field ",DATA_FIELD3,"of dim.", DIM_NAME1
!    print*,"... and of type ",HE5T_NATIVE_CHAR

d1740 1
a1740 1
    & HE5T_NATIVE_CHAR, HDFE_NOMERGE, chunk_rank, chunk_dims, &
a1741 6
!    status = HE5_SWdefdfld(swid, DATA_FIELD3, DIM_NAME1,MAX_DIML1,&
!         HE5T_NATIVE_CHAR, HDFE_NOMERGE)
!    IF ( status == -1 ) THEN
!       msr = DAT_ERR // DATA_FIELD3
!       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
!    END IF
a1742 1
!    print*,"Defined data field ",DATA_FIELD3,"of dim.", DIM_NAME1
d1978 2
a1979 1
    !HDF-EOS5 won't write a dataset of chars from FORTRAN
a1980 18
   if(USEINTS4STRINGS) then
!      allocate(string_buffer(1,l2gp%nTimes))
!      call strings2Ints(l2gp%status, string_buffer)
!      status = mls_swwrfld(swid,DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
!           string_buffer, hdfVersion=HDFVERSION_5)
!      deallocate(string_buffer)
    else
      !    status = HE5_SWwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3),&
      !        edge(3:3), l2gp%status) ! 
      status=0
      call MLSMessage(MLSMSG_Debug, ModuleName, &
        "writing of status field disabled")

      if ( status == -1 ) then
         msr = WR_ERR // DATA_FIELD3
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if
    end if
d2027 2
a2028 1
      & 'Latitude,Longitude,Time,LocalSolarTime,SolarZenithAngle,LineOfSightAngle,OrbitGeodeticAngle,ChunkNumber,Pressure,Frequency'
d2030 2
a2031 1
      & 'deg,deg,s,h,deg,deg,deg,NoUnits,hPa,GHz'
d2033 2
a2034 1
      & 'HMT,HMT,AS,HMT,HMT,M,M,M,AS,M'   ! These are abbreviated values
d2038 3
a2040 1
      & 'HIRDLS-MLS-Shared,HIRDLS-MLS-TES-Shared,MLS-TES-Shared,Aura-Shared,MLS-Specific'  ! Expanded values
d2042 2
a2043 1
      & 'Temperature,BrO,CH3CN,CO,ClO,GPH,HCl,HCN,H2O,H2O2,HNO3,HOCl,HO2,N2,N2O,OH,O2,O3,RHI,SO2'
d2045 2
a2046 1
      & 'HMT,M,M,MT,M,M,M,M,HMT,M,HMT,M,M,M,HM,M,M,HMT,M,M'   ! These are abbreviated values
d2194 10
a2203 1
    ! ('Status' data field not yet written)
d2529 3
d2536 2
a2537 1
! Added new UniqueFieldDefinition attribute; sets fill and MissingValue attributes for all fields
@


2.62
log
@New chunking so hdfeos5 files dont balloon; some swsetfill tweaking
@
text
@d10 1
a10 2
  use HDFEOS!, only: SWATTACH, SWCREATE, SWDEFDFLD, SWDEFDIM, SWDEFGFLD, &
     !& SWDETACH
a13 1
    & WILDCARDHDFVERSION, &
d17 2
a18 2
  use MLSStrings, only: ExtractSubString, GetStringHashElement, ints2Strings, &
    & list2array, lowercase, strings2Ints
a21 1
  use SWAPI, only: SWWRFLD, SWRDFLD
d34 1
a34 1
       & "$Id: L2GPData.f90,v 2.61 2003/04/11 23:35:10 pwagner Exp $"
a76 4
  ! (This 1st one enables some changes *not* made by paw zeroing out frequency)
  logical, private, parameter :: MONKEYAROUND = .FALSE. ! If true, then ???


d89 1
d94 1
d98 1
a98 1
   ! The old names of the following lacked "MLS.."
d109 1
d114 1
d118 2
d132 4
a135 1

d215 1
d221 2
a222 1
  subroutine SetupNewL2GPRecord ( l2gp, nFreqs, nLevels, nTimes)
d231 1
d295 15
d389 1
a389 1
      & nTimes=myNTimes )
d462 1
a462 1
       firstProf, lastProf, hdfVersion)
d479 1
d483 1
d491 16
d509 2
a510 2
      call ReadL2GPData_hdf4(L2FileHandle, swathname, l2gp, numProfs, &
       firstProf, lastProf)
d515 2
a516 4
      call ReadL2GPData_hdf5(L2FileHandle, swathname, l2gp, numProfs, &
       firstProf, lastProf)
!       call MLSMessage ( MLSMSG_Error, ModuleName, &
!            & 'This version of L2GPData not yet ready for hdf5' )
d525 1
a525 1
       firstProf, lastProf, hdfVersion)
d542 1
d556 1
d564 2
a565 1
       & firstProf=firstProf, lastProf=lastProf, hdfVersion=the_hdfVersion)
d575 3
a577 2
  subroutine ReadL2GPData_hdf4(L2FileHandle, swathname, l2gp, numProfs, &
       firstProf, lastProf)
d590 1
d601 2
d611 1
d619 4
d627 13
a639 1
    swid = swattach(L2FileHandle, TRIM(l2gp%Name))
a651 1
    if ( INDEX(list,'Freq') /= 0 ) freq = 1
d653 9
a661 5
    size = swdiminfo(swid, DIM_NAME1)
    if ( size == -1 ) then
       msr = SZ_ERR // DIM_NAME1 // ' '  // trim(swathname)
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d667 2
a668 6
       size = swdiminfo(swid, DIM_NAME2)
       if ( size == -1 ) then
          msr = SZ_ERR // DIM_NAME2 // ' '  // trim(swathname)
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       nLevels = size
d672 6
a677 7
    if ( freq == 1 ) then
       size = swdiminfo(swid, DIM_NAME3)
       if ( size == -1 ) then
          msr = SZ_ERR // DIM_NAME3 // ' ' // trim(swathname)
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       nFreqs = size
d679 1
a679 1
       nFreqs = 0
d724 1
a724 1
    & nTimes=myNumProfs )
d747 2
a748 6
    status = swrdfld(swid, GEO_FIELD1, start(3:3), stride(3:3), edge(3:3), &
      &    realProf)
    if ( status == -1 ) then
       msr = MLSMSG_L2GPRead // GEO_FIELD1 // ' ' // trim(swathname)
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d751 2
a752 6
    status = swrdfld(swid, GEO_FIELD2, start(3:3), stride(3:3), edge(3:3), &
      &    realProf)
    if ( status == -1 ) then
       msr = MLSMSG_L2GPRead // GEO_FIELD2 // ' ' // trim(swathname)
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d755 2
a756 6
    status = swrdfld(swid, GEO_FIELD3, start(3:3), stride(3:3), edge(3:3), &
      &    l2gp%time)
    if ( status == -1 ) then
       msr = MLSMSG_L2GPRead // GEO_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d758 2
a759 6
    status = swrdfld(swid, GEO_FIELD4, start(3:3), stride(3:3), edge(3:3), &
      &    realProf)
    if ( status == -1 ) then
       msr = MLSMSG_L2GPRead // GEO_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d762 2
a763 6
    status = swrdfld(swid, GEO_FIELD5, start(3:3), stride(3:3), edge(3:3), &
      &    realProf)
    if ( status == -1 ) then
       msr = MLSMSG_L2GPRead // GEO_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d766 2
a767 6
    status = swrdfld(swid, GEO_FIELD6, start(3:3), stride(3:3), edge(3:3), &
      &    realProf)
    if ( status == -1 ) then
       msr = MLSMSG_L2GPRead // GEO_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d770 2
a771 12
    status = swrdfld(swid, GEO_FIELD7, start(3:3), stride(3:3), edge(3:3), &
      &    realProf)
    ! Give it a 2nd chance--perhaps saved under old name
    if ( status == -1 .and. GEO_FIELD7 /= 'OrbitGeodeticAngle' ) then
        status = swrdfld(swid, 'OrbitGeodeticAngle', &
         & start(3:3), stride(3:3), edge(3:3), &
         &    realProf)
    end if
    if ( status == -1 ) then
       msr = MLSMSG_L2GPRead // GEO_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d774 2
a775 12
    status = swrdfld(swid, GEO_FIELD8, start(3:3), stride(3:3), edge(3:3), &
      &    l2gp%chunkNumber)
    ! Give it a 2nd chance--perhaps it was saved under an old name
    if ( status == -1 .and. GEO_FIELD8 /= 'ChunkNumber' ) then
      status = swrdfld(swid, 'ChunkNumber', &
        & start(3:3), stride(3:3), edge(3:3), &
        &    l2gp%chunkNumber)
    end if
    if ( status == -1 ) then
       msr = MLSMSG_L2GPRead // GEO_FIELD8
       call MLSMessage ( MLSMSG_Warning, ModuleName, msr )
    end if
d781 2
a782 7
       status = swrdfld(swid, GEO_FIELD9, start(2:2), stride(2:2), edge(2:2), &
         & realSurf)
       if ( status == -1 ) then
          msr = MLSMSG_L2GPRead // GEO_FIELD9
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

d793 2
a794 12
       status = swrdfld(swid, GEO_FIELD10, start(1:1), stride(1:1), edge(1:1), &
         & l2gp%frequency)
       ! Give it a 2nd chance--perhaps saved under old name
       if ( status == -1 .and. GEO_FIELD10 /= 'Frequency' ) then
         status = swrdfld(swid, 'Frequency', start(1:1), stride(1:1), &
           & edge(1:1), &
           & l2gp%frequency)
       end if
       if ( status == -1 ) then
          msr = MLSMSG_L2GPRead // GEO_FIELD10
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d802 2
a803 5
       status = swrdfld(swid, DATA_FIELD1, start, stride, edge, real3)
       if ( status == -1 ) then
          msr = MLSMSG_L2GPRead // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d806 2
a807 5
       status = swrdfld(swid, DATA_FIELD2, start, stride, edge, real3)
       if ( status == -1 ) then
          msr = MLSMSG_L2GPRead // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d812 2
a813 6
      status = swrdfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
        &   edge(2:3), real3(1,:,:) )
      if ( status == -1 ) then
        msr = MLSMSG_L2GPRead // DATA_FIELD1
        call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if
d816 2
a817 6
      status = swrdfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
        & edge(2:3), real3(1,:,:) )
      if ( status == -1 ) then
        msr = MLSMSG_L2GPRead // DATA_FIELD2
        call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if
d822 2
a823 6
       status = swrdfld( swid, DATA_FIELD1, start(3:3), stride(3:3), edge(3:3), &
         &   real3(1,1,:) )
       if ( status == -1 ) then
          msr = MLSMSG_L2GPRead // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d826 2
a827 6
       status = swrdfld( swid, DATA_FIELD2, start(3:3), stride(3:3), edge(3:3), &
            real3(1,1,:) )
       if ( status == -1 ) then
          msr = MLSMSG_L2GPRead // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d856 5
a860 9
   if(USEINTS4STRINGS) then
       status = swrdfld(swid, DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
         string_buffer)
       if ( status == -1 ) then
         msr = MLSMSG_L2GPRead // DATA_FIELD3
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       call ints2Strings(string_buffer, l2gp%status)
    end if
d862 2
a863 6
    status = swrdfld(swid, DATA_FIELD4, start(3:3), stride(3:3), edge(3:3), &
      &   realProf)
    if ( status == -1 ) then
       msr = MLSMSG_L2GPRead // DATA_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d891 4
a894 4
  subroutine ReadL2GPData_hdf5(L2FileHandle, swathname, l2gp, numProfs, &
       firstProf, lastProf)
  use HDFEOS5
  use HE5_SWAPI 
d903 1
a903 1
    integer, intent(IN) :: L2FileHandle ! Returned by swopen
d906 1
d916 2
d921 1
a921 1
    integer :: alloc_err, first, freq, lev, nDims, size, ulsize, swid, status
d927 1
d934 4
d943 12
a954 1
    swid = HE5_SWattach(L2FileHandle, l2gp%Name)
d975 1
a975 6
    size = HE5_SWdiminfo(swid, DIM_NAME1)
    !print*,"Got dims for ",DIM_NAME1," it was",size
    if (size == -1) then
       msr = SZ_ERR // DIM_NAME1
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d985 1
a985 7
      size = HE5_SWdiminfo(swid, DIM_NAME2)
      !print*,"Got dims for ",DIM_NAME2," it was",size
       size = HE5_SWdiminfo(swid, DIM_NAME2)
       if (size == -1) then
          msr = SZ_ERR // DIM_NAME2
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d990 2
a991 8
    if (freq == 1) then
      size = HE5_SWdiminfo(swid, DIM_NAME3)
      !print*,"Got dims for ",DIM_NAME3," it was",size
       size = HE5_SWdiminfo(swid, DIM_NAME3)
       if (size == -1) then
          msr = SZ_ERR // DIM_NAME3
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d993 3
d1052 1
a1052 1
      &  nTimes=mynumProfs)
d1076 2
a1077 6
    status = HE5_SWrdfld(swid, GEO_FIELD1, start(3:3), stride(3:3), &
      edge(3:3), realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD1
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d1080 2
a1081 6
    status = HE5_SWrdfld(swid, GEO_FIELD2, start(3:3), stride(3:3), edge(3:3),&
      &    realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD2
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d1084 2
a1085 6
    status = HE5_SWrdfld(swid, GEO_FIELD3, start(3:3), stride(3:3), edge(3:3),&
      &    l2gp%time)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD3
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d1087 2
a1088 6
    status = HE5_SWrdfld(swid, GEO_FIELD4, start(3:3), stride(3:3), edge(3:3),&
      &    realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD4
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d1091 2
a1092 6
    status = HE5_SWrdfld(swid, GEO_FIELD5, start(3:3), stride(3:3), edge(3:3),&
      &    realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD5
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d1095 2
a1096 6
    status = HE5_SWrdfld(swid, GEO_FIELD6, start(3:3), stride(3:3), edge(3:3),&
      &    realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD6
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d1099 2
a1100 12
    status = HE5_SWrdfld(swid, GEO_FIELD7, start(3:3), stride(3:3), edge(3:3),&
      &   realProf)
    ! Give it a 2nd chance--perhaps saved under old name
    if ( status == -1 .and. GEO_FIELD7 /= 'OrbitGeodeticAngle' ) then
    status = HE5_SWrdfld(swid, 'OrbitGeodeticAngle', &
      & start(3:3), stride(3:3), edge(3:3),&
      &   realProf)
    endif
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD7
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d1103 2
a1104 12
    status = HE5_SWrdfld(swid, GEO_FIELD8, start(3:3), stride(3:3), edge(3:3),&
      &    l2gp%chunkNumber)
    ! Give it a 2nd chance--perhaps saved under old name
    if ( status == -1 .and. GEO_FIELD8 /= 'ChunkNumber' ) then
      status = HE5_SWrdfld(swid, 'ChunkNumber', &
        &  start(3:3), stride(3:3), edge(3:3),&
        &    l2gp%chunkNumber)
    endif
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD8
       call MLSMessage(MLSMSG_Warning, ModuleName, msr)
    endif
d1110 2
a1111 7
       status = HE5_SWrdfld(swid,GEO_FIELD9,start(2:2),stride(2:2), edge(2:2),&
         & realSurf)
       if (status == -1) then
          msr = MLSMSG_L2GPRead // GEO_FIELD9
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

d1122 2
a1123 12
       status = HE5_SWrdfld(swid,GEO_FIELD10,start(1:1),stride(1:1),edge(1:1),&
         & realFreq)
       ! Give it a 2nd chance--perhaps saved under old name
       if ( status == -1 .and. GEO_FIELD10 /= 'Frequency' ) then
         status = HE5_SWrdfld(swid, 'Frequency', &
           & start(1:1), stride(1:1), edge(1:1),&
           & realFreq)
       endif
       if (status == -1) then
          msr = MLSMSG_L2GPRead // GEO_FIELD10
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d1132 2
a1133 5
       status = HE5_SWrdfld(swid, DATA_FIELD1, start, stride, edge, real3)
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD1
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d1136 2
a1137 5
       status = HE5_SWrdfld(swid, DATA_FIELD2, start, stride, edge, real3)
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD2
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d1142 2
a1143 7
       status = HE5_SWrdfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
            edge(2:3), real3 )
!            edge(2:3), real3(1,:,:) )
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD1
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d1146 2
a1147 6
       status = HE5_SWrdfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
            edge(2:3), real3(1,:,:) )
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD2
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d1152 2
a1153 6
       status = HE5_SWrdfld(swid,DATA_FIELD1,start(3:3),stride(3:3),edge(3:3),&
         &   real3(1,1,:) )
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD1
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d1156 2
a1157 6
       status = HE5_SWrdfld( swid, DATA_FIELD2, start(3:3), stride(3:3), edge(3:3), &
            real3(1,1,:) )
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD2
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d1192 3
a1194 7
       status = HE5_swrdfld(swid,DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
         string_buffer)
       if ( status == -1 ) then
         msr = MLSMSG_L2GPRead // DATA_FIELD3
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       call ints2Strings(string_buffer, l2gp%status)
d1201 2
a1202 6
    status = HE5_SWrdfld(swid, DATA_FIELD4, start(3:3), stride(3:3),&
      edge(3:3),realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // DATA_FIELD4
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d1232 1
d1273 2
a1274 5
    status = swdefdim(swid, DIM_NAME1, l2gp%nTimes)
    if ( status == -1 ) then
       msr = DIM_ERR // DIM_NAME1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1277 2
a1278 5
       status = swdefdim(swid, DIM_NAME2, l2gp%nLevels)
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1282 2
a1283 5
       status = swdefdim(swid, DIM_NAME3, l2gp%nFreqs)
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME3
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1288 31
a1318 55
    status = swdefgfld(swid, GEO_FIELD1, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD2, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD2
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD3, DIM_NAME1, DFNT_FLOAT64, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD4, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD5, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD6, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD7, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD8, DIM_NAME1, DFNT_INT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD8
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1321 3
a1323 6
       status = swdefgfld(swid, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, &
            HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD9
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1327 3
a1329 6
       status = swdefgfld(swid, GEO_FIELD10, DIM_NAME3, DFNT_FLOAT32, &
            HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD10
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1336 9
a1344 17
       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME123, DFNT_FLOAT32, &
            HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if


       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME123, DFNT_FLOAT32, &
            HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

d1348 4
a1351 2
       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME12, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d1353 4
a1356 12
       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 //  ' for 2D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME12, DFNT_FLOAT32, &
            HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 //  ' for 2D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1360 4
a1363 2
       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME1, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d1365 4
a1368 12
       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 // ' for 1D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME1, DFNT_FLOAT32, &
            HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 // ' for 1D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1372 4
a1375 6
    status = swdefdfld(swid, DATA_FIELD3, DIM_NAME1, DFNT_CHAR8, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = DAT_ERR // DATA_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1377 4
a1380 6
    status = swdefdfld(swid, DATA_FIELD4, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = DAT_ERR // DATA_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1398 1
a1416 1
    character (len=480) :: msr
d1443 2
a1444 6
    status = swwrfld(swid, GEO_FIELD1, start, stride, edge, &
         real(l2gp%latitude))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1446 2
a1447 6
    status = swwrfld(swid, GEO_FIELD2, start, stride, edge, &
         real(l2gp%longitude))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD2
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1449 2
a1450 6
    status = swwrfld(swid, GEO_FIELD3, start, stride, edge, &
         l2gp%time)
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1452 2
a1453 6
    status = swwrfld(swid, GEO_FIELD4, start, stride, edge, &
        real(l2gp%solarTime))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1455 2
a1456 6
    status = swwrfld(swid, GEO_FIELD5, start, stride, edge, &
         real(l2gp%solarZenith))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1458 2
a1459 6
    status = swwrfld(swid, GEO_FIELD6, start, stride, edge, &
         real(l2gp%losAngle))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1461 2
a1462 6
    status = swwrfld(swid, GEO_FIELD7, start, stride, edge, &
         real(l2gp%geodAngle))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1464 2
a1465 6
    status = swwrfld(swid, GEO_FIELD8, start, stride, edge, &
         l2gp%chunkNumber)
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD8
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1470 2
a1471 6
       status = swwrfld(swid, GEO_FIELD9, start, stride, edge, &
            real(l2gp%pressures))
       if ( status == -1 ) then
          msr = WR_ERR // GEO_FIELD9
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1477 2
a1478 9
       if (MONKEYAROUND) then
         l2gp%frequency = 0
       endif
       status = swwrfld(swid, GEO_FIELD10, start, stride, edge, &
            real(l2gp%frequency))
       if ( status == -1 ) then
          msr = WR_ERR // GEO_FIELD10
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1496 1
a1513 1
    character (len=480) :: msr
d1550 6
a1555 12
       status = swwrfld(swid, DATA_FIELD1, start, stride, edge, &
            & RESHAPE(real(l2gp%l2gpValue), (/SIZE(l2gp%l2gpValue)/)) )
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       status = swwrfld(swid, DATA_FIELD2, start, stride, edge, &
            & RESHAPE(real(l2gp%l2gpPrecision), (/SIZE(l2gp%l2gpPrecision)/)) )
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1560 2
a1561 2
       status = swwrfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpValue(1,:,:)) )
d1563 2
a1564 10
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       status = swwrfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpPrecision(1,:,:) ))
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1568 4
a1571 12
       status = swwrfld( swid, DATA_FIELD1, start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpValue(1,1,:) ))
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       status = swwrfld( swid, DATA_FIELD2, start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpPrecision(1,1,:) ))
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1577 5
a1581 9
      allocate(string_buffer(1,l2gp%nTimes))
      call strings2Ints(l2gp%status, string_buffer)
      status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
           string_buffer)
      if ( status == -1 ) then
         msr = WR_ERR // DATA_FIELD3
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if
      deallocate(string_buffer)
d1583 2
a1584 6
      status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
           l2gp%status)
      if ( status == -1 ) then
         msr = WR_ERR // DATA_FIELD3
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if
d1587 2
a1588 6
    status = swwrfld(swid, DATA_FIELD4, start(3:3), stride(3:3), edge(3:3), &
         real(l2gp%quality))
    if ( status == -1 ) then
       msr = WR_ERR // DATA_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1605 5
a1609 6
  use HDFEOS5, only: HE5_SWdefchunk, HE5_SWcreate, HE5_SWdefdfld, &
    & HE5_SWdefdim, HE5_SWdetach, &
    & HE5_SWdefgfld, &
    & HE5S_UNLIMITED_F, HE5T_NATIVE_DOUBLE, HE5T_NATIVE_INT, HE5T_NATIVE_FLOAT
  ! use HE5_SWAPI
  use MLSHDFEOS, only : mls_swsetfill
d1666 3
a1668 1
    status = HE5_SWdefdim(swid, UNLIM, HE5S_UNLIMITED_F)
d1670 2
a1671 6
    ! print*,"Defining dimension ", DIM_NAME1," with size",l2gp%nTimes
    status = HE5_SWdefdim(swid, DIM_NAME1, l2gp%nTimes)
    if ( status == -1 ) then
       msr = DIM_ERR // DIM_NAME1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1674 2
a1675 6
      ! print*,"Defining dimension ", DIM_NAME2," with size",l2gp%nLevels
       status = HE5_SWdefdim(swid, DIM_NAME2, l2gp%nLevels)
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1679 2
a1680 6
       ! print*,"Defining dimension ", DIM_NAME3," with size",l2gp%nFreqs
       status = HE5_SWdefdim(swid, DIM_NAME3, l2gp%nFreqs)
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME3
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1690 3
a1692 8
    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
!    print*,"Set chunking -- status=",status
    status = HE5_SWdefgfld(swid, GEO_FIELD1, DIM_NAME1,MAX_DIML1,&
         HE5T_NATIVE_FLOAT , 0)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1696 27
a1722 58
    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)

    status = HE5_SWdefgfld(swid, GEO_FIELD2, DIM_NAME1, MAX_DIML1,&
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD2
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD3, DIM_NAME1, MAX_DIML1, &
    HE5T_NATIVE_DOUBLE, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD4, DIM_NAME1,MAX_DIML1,&
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD5, DIM_NAME1, MAX_DIML1, &
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD6, DIM_NAME1,MAX_DIML1,&
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD7, DIM_NAME1, MAX_DIML1,&
    HE5T_NATIVE_FLOAT,   HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    ! status = HE5_SWdefgfld(swid, GEO_FIELD8, DIM_NAME1, MAX_DIML1,&
    !     HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
    status = HE5_SWdefgfld(swid, GEO_FIELD8, DIM_NAME1, MAX_DIML1,&
         HE5T_NATIVE_INT, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD8
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1726 3
a1728 6
       status = HE5_SWdefgfld(swid, GEO_FIELD9, DIM_NAME2,MAX_DIML,&
            HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD9
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1733 3
a1735 6
       status = HE5_SWdefgfld(swid, GEO_FIELD10, DIM_NAME3,MAX_DIML,&
            HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD10
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
a1742 20
       status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)

       status = HE5_SWdefdfld(swid, DATA_FIELD1, DIM_NAME123, MAX_DIML123,&
       HE5T_NATIVE_FLOAT,HDFE_NOMERGE)
       ! status = HE5_SWsetfill(swid, DATA_FIELD1, HE5T_NATIVE_FLOAT, &
       !  & UNDEFINED_VALUE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

       status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
       status = HE5_SWdefdfld(swid, DATA_FIELD2, DIM_NAME123, MAX_DIML123,&
            HE5T_NATIVE_FLOAT, HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1744 9
a1756 17
       status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
       ! print*,"Set chunking with status=",status
       ! print*,"chunking=",chunk_dims
       ! print*,"About to define 2-D extendible field"

       ! print*,"Calling SWdefdfld with args ",swid, DATA_FIELD1, &
       !      DIM_NAME12, MAX_DIML12, HE5T_NATIVE_FLOAT, HDFE_NOMERGE
       status = HE5_SWdefdfld(swid, DATA_FIELD1, DIM_NAME12, MAX_DIML12, &
            HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
       ! status = HE5_SWsetfill(swid, DATA_FIELD1, HE5T_NATIVE_FLOAT, &
       !  & UNDEFINED_VALUE)
       ! print*,"Defined 2-D extendible field"

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 //  ' for 2D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1758 9
a1766 8
       status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
       status = HE5_SWdefdfld(swid, DATA_FIELD2, DIM_NAME12, MAX_DIML12,&
        HE5T_NATIVE_FLOAT,HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 //  ' for 2D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
a1770 4
       status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    
       status = HE5_SWdefdfld(swid, DATA_FIELD1, DIM_NAME1,MAX_DIML1,&
            HE5T_NATIVE_FLOAT,HDFE_NOMERGE)
d1772 9
a1780 15
       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 // ' for 1D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

       ! status = HE5_SWsetfill(swid, DATA_FIELD1, HE5T_NATIVE_FLOAT, &
       !  & UNDEFINED_VALUE)
       status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
       status = HE5_SWdefdfld(swid, DATA_FIELD2, DIM_NAME1, MAX_DIML1,&
       HE5T_NATIVE_FLOAT, HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 // ' for 1D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1787 6
d1803 4
a1806 8
    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)

    status = HE5_SWdefdfld(swid, DATA_FIELD4, DIM_NAME1,MAX_DIML1,&
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = DAT_ERR // DATA_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1810 1
a1810 1
     & UNDEFINED_VALUE)
d1815 1
a1815 1
     & UNDEFINED_VALUE)
d1819 2
a1820 2
    status =  mls_swsetfill(swid, GEO_FIELD3, HE5T_NATIVE_DOUBLE, &
     & real(UNDEFINED_VALUE, r8) )
d1823 3
a1825 3
         & 'Cant set fill for ' // GEO_FIELD3 )
    status =  mls_swsetfill(swid, GEO_FIELD8, HE5T_NATIVE_INT, &
     & int(UNDEFINED_VALUE) )
d1828 1
a1828 1
         & 'Cant set fill for ' // GEO_FIELD8 )
d1830 2
a1831 2
      status =  mls_swsetfill(swid, GEO_FIELD9, HE5T_NATIVE_FLOAT, &
       & UNDEFINED_VALUE)
d1834 1
a1834 1
           & 'Cant set fill for ' // GEO_FIELD9 )
d1837 2
a1838 2
      status =  mls_swsetfill(swid, GEO_FIELD10, HE5T_NATIVE_FLOAT, &
       & UNDEFINED_VALUE)
d1841 1
a1841 1
           & 'Cant set fill for ' // GEO_FIELD10 )
d1861 2
a1862 2
  use HDFEOS5
  use HE5_SWAPI 
a1878 1
    character (len=480) :: msr
d1904 2
a1905 6
    status = HE5_SWwrfld(swid, GEO_FIELD1, start, stride, edge, &
         real(l2gp%latitude))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1907 2
a1908 6
    status = HE5_SWwrfld(swid, GEO_FIELD2, start, stride, edge, &
         real(l2gp%longitude))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD2
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1910 2
a1911 6
    status = HE5_SWwrfld(swid, GEO_FIELD3, start, stride, edge, &
         l2gp%time)
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1913 2
d1916 2
a1917 6
    status = HE5_SWwrfld(swid, GEO_FIELD5, start, stride, edge, &
         real(l2gp%solarZenith))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1919 2
a1920 14
    status = HE5_SWwrfld(swid, GEO_FIELD4, start, stride, edge, &
        real(l2gp%solarTime))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if


    status = HE5_SWwrfld(swid, GEO_FIELD6, start, stride, edge, &
         real(l2gp%losAngle))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1922 2
a1923 6
    status = HE5_SWwrfld(swid, GEO_FIELD7, start, stride, edge, &
         real(l2gp%geodAngle))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1925 2
a1926 6
    status = HE5_SWwrfld(swid, GEO_FIELD8, start, stride, edge, &
         l2gp%chunkNumber)
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD8
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1931 2
a1932 6
       status = HE5_SWwrfld(swid, GEO_FIELD9, start, stride, edge, &
            real(l2gp%pressures))
       if ( status == -1 ) then
          msr = WR_ERR // GEO_FIELD9
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1938 2
a1939 7
       if (MONKEYAROUND) l2gp%frequency = 0
       status = HE5_SWwrfld(swid, GEO_FIELD10, start, stride, edge, &
            real(l2gp%frequency))
       if ( status == -1 ) then
          msr = WR_ERR // GEO_FIELD10
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1957 2
a1958 2
  use HDFEOS5
  use HE5_SWAPI 
d2011 6
a2016 12
       status = HE5_SWwrfld(swid, DATA_FIELD1, start, stride, edge, &
            & reshape(real(l2gp%l2gpValue), (/size(l2gp%l2gpValue)/)) )
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       status = HE5_SWwrfld(swid, DATA_FIELD2, start, stride, edge, &
            & reshape(real(l2gp%l2gpPrecision), (/size(l2gp%l2gpPrecision)/)) )
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d2021 4
a2024 12
       status = HE5_SWwrfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpValue(1,:,:) ))
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       status = HE5_SWwrfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpPrecision(1,:,:) ))
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d2028 4
a2031 12
       status = HE5_SWwrfld( swid, DATA_FIELD1, start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpValue(1,1,:) ))
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       status = HE5_SWwrfld( swid, DATA_FIELD2, start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpPrecision(1,1,:) ))
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d2039 5
a2043 9
      allocate(string_buffer(1,l2gp%nTimes))
      call strings2Ints(l2gp%status, string_buffer)
      status = HE5_swwrfld(swid,DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
           string_buffer)
      if ( status == -1 ) then
         msr = WR_ERR // DATA_FIELD3
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if
      deallocate(string_buffer)
d2056 2
a2057 6
    status = HE5_SWwrfld(swid, DATA_FIELD4, start(3:3), stride(3:3), edge(3:3), &
         real(l2gp%quality))
    if ( status == -1 ) then
       msr = WR_ERR // DATA_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d2169 1
a2169 1
      & (/ real(UNDEFINED_VALUE, rgp) /) )
d2199 1
a2199 1
            & HE5T_NATIVE_DOUBLE, 1, (/ real(UNDEFINED_VALUE, r8) /) )
d2203 1
a2203 1
            & HE5T_NATIVE_INT, 1, (/ int(UNDEFINED_VALUE) /) )
d2207 1
a2207 1
            & rgp_type, 1, (/ real(UNDEFINED_VALUE, rgp) /) )
d2243 1
a2243 1
    status = he5_swwrlattr(swid, DATA_FIELD1, 'Title', &
d2245 1
a2245 1
    status = he5_swwrlattr(swid, DATA_FIELD1, 'Units', &
d2247 3
a2249 3
    status = he5_swwrlattr(swid, DATA_FIELD1, 'MissingValue', &
      & rgp_type, 1, (/ real(UNDEFINED_VALUE, rgp) /) )
    status = he5_swwrlattr(swid, DATA_FIELD1, &
d2252 1
a2252 1
    status = he5_swwrlattr(swid, DATA_FIELD2, 'Title', &
d2254 1
a2254 1
    status = he5_swwrlattr(swid, DATA_FIELD2, 'Units', &
d2256 3
a2258 3
    status = he5_swwrlattr(swid, DATA_FIELD2, 'MissingValue', &
      & rgp_type, 1, (/ real(UNDEFINED_VALUE, rgp) /) )
    status = he5_swwrlattr(swid, DATA_FIELD2, &
d2261 13
d2464 2
d2478 3
d2526 2
a2527 1
      call dump ( real(l2gp%l2gpValue, r8), 'L2GPValue:' )
d2529 2
a2530 1
      call dump ( real(l2gp%l2gpPrecision, r8), 'L2GPPrecision:' )
d2588 3
@


2.61
log
@Added new UniqueFieldDefinition attribute; sets fill and MissingValue attributes for all fields
@
text
@d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.60 2003/04/03 22:58:40 pwagner Exp $"
d116 1
a116 1
     & ',OrbitGeodeticAngle,Pressure,Frequency'
d1860 5
a1864 2
  use HDFEOS5
  use HE5_SWAPI
d1893 1
d1900 1
a1900 1
    chunktimes=1
d1905 1
a1905 1
       chunklevels = min(l2gp%nLevels, 5)
d2055 2
d2085 2
d2116 2
d2153 4
a2156 1
      & UNDEFINED_VALUE)
d2158 4
a2161 1
      & UNDEFINED_VALUE)
d2163 4
a2166 1
      & real(UNDEFINED_VALUE, r8) )
d2168 19
a2186 1
      & int(UNDEFINED_VALUE) )
d2985 3
@


2.60
log
@Alias now set in lib/L2GPData instead of l2/write_meta
@
text
@d19 2
a20 1
  use MLSStrings, only: ints2Strings, list2array, strings2Ints
d37 1
a37 1
       & "$Id: L2GPData.f90,v 2.59 2003/04/02 23:53:56 pwagner Exp $"
d100 2
a111 2
   ! character (len=*), parameter :: GEO_FIELD7 = 'MLSOrbitGeodeticAngle'
   ! character (len=*), parameter :: GEO_FIELD8 = 'MLSChunkNumber'
d114 3
a116 1
   ! character (len=*), parameter :: GEO_FIELD10= 'MLSFrequency'
d1861 2
a1862 1
  use HE5_SWAPI 
a2055 7
       ! Set Fill Value
       status = HE5_SWsetfill(swid, DATA_FIELD1, HE5T_NATIVE_FLOAT, &
         & UNDEFINED_VALUE)
       if ( status == -1 ) then
          call MLSMessage ( MLSMSG_Error, ModuleName,&
            & 'Unable to set Fill Value for data field '// DATA_FIELD1)
       end if
a2085 3
       ! Set Fill Value
       status = HE5_SWsetfill(swid, DATA_FIELD1, HE5T_NATIVE_FLOAT, &
         & UNDEFINED_VALUE)
a2107 3
       ! Set Fill Value
       status = HE5_SWsetfill(swid, DATA_FIELD1, HE5T_NATIVE_FLOAT, &
         & UNDEFINED_VALUE)
d2141 9
a2210 2
    !print*,"writeGeo Attached swath ",name," with SW ID=",swid
    !print*,"About to write latitude with offset=",myoffset
a2212 1
    !print*,"wrote latitude, maybe"
a2232 1
    !print*,"writing ", REAL(l2gp%solarZenith)," as SZA"
a2234 1
    !print*,"just wrote ", REAL(l2gp%solarZenith)," as SZA"
a2294 1
    !print*,"Detatched from swath -- error=",status
a2351 3
    !print*,"OutputL2GP_writeData -- name=",name
    ! Write data to the fields

a2358 1
    !print*," attached swath with swid=",swid," filehandle=",l2FileHandle
a2359 1
       !print*,"Writing 3D field"
a2374 1
       !Print*,"Writing 2-d field"
a2375 1
     ! print*,"About to write data with offset=",myOffset
a2378 1
       !print*,"Status of write was ",status
a2391 1
       !Print*,"Writing 1-D field"
a2431 2
    !  l2gp%quality = 0 !??????? Why was this here !??? NJL
    !                   ! Beats me. Evil bug gnomes, probably. HCP 
a2441 1
    !print*,"Detatched from swath -- error=",status
d2455 2
a2456 1
  use HDFEOS5, only: HE5T_NATIVE_REAL, HE5T_NATIVE_DOUBLE, HE5T_NATIVE_SCHAR, &
d2485 10
a2494 1
    ! & 'degrees,degrees,seconds,hours,degrees,degrees,degrees,none,hPa,GHz'
d2497 1
d2504 1
d2506 2
d2565 6
d2575 17
a2591 2
        status = he5_swwrlattr(swid, trim(theTitles(field)), 'FillValue', &
          & rgp_type, 1, (/ real(UNDEFINED_VALUE, rgp) /) )
d2595 2
a2596 2
    call GetQuantityAttributes ( l2gp%quantityType, &
      & units_name)
d2598 22
d2627 14
a2935 176
  ! ----------------------------------  GetQuantityAttributes  -----
  subroutine GetQuantityAttributes ( quantityType, &
   & units_name)
!  & framing, units_name, dim_names)

  ! Given a quantity type, e.g. l_vmr,
  ! returns major/minor/neither framing distinction, default unit name,
  ! and the 3 dimension names, e.g. (/l_channel, l_MIF, l_MAF/)

    ! Dummy arguments
    integer, intent(in)                :: quantityType
    character(len=*), intent(out)      :: units_name
    ! Local variables
    character(len=8)                   :: framing
    integer, dimension(3)              :: dim_names

    ! Executable code
    units_name = ' '
    select case (quantityType)                                       
    case ( l_channel )  
      framing = 'major'
      units_name = 'channel'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_chunk )  
      framing = 'major'
      units_name = 'chunk'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_cloudIce )  
      framing = 'major'
      units_name = 'g/m3'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_columnAbundance )  
      framing = 'major'
      units_name = 'DU'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_effectiveOpticalDepth )  
      framing = 'minor'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_elevOffset )  
      framing = 'neither'
      units_name = 'degrees'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_frequency )  
      framing = 'major'
      units_name = 'frequency'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_geodAngle )  
      framing = 'neither'
      units_name = 'degrees'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_gph )  
      framing = 'neither'
      units_name = 'meters'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_heightOffset )  
      framing = 'minor'
      units_name = 'degrees'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_iteration )  
      framing = 'major'
      units_name = 'iteration'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_losTransFunc )  
      framing = 'neither'
      dim_names = (/ l_frequency, l_MIF, l_MAF /)                  
    case ( l_losVel )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_MAF )  
      framing = 'major'
      units_name = 'MAF'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_massMeanDiameterIce )  
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_massMeanDiameterWater )  
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_MIF )  
      framing = 'major'
      units_name = 'MIF'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_noiseBandwidth )  
      framing = 'neither'
      units_name = 'MHz'
      dim_names = (/ l_channel, l_none, l_none /)                  
    case ( l_opticalDepth )  
      framing = 'minor'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_orbitInclination )  
      framing = 'minor'
      units_name = 'degrees'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_phiTan )  
      framing = 'minor'
      units_name = 'degrees'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_ptan )  
      framing = 'minor'
      units_name = 'log10(hPa)'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_radiance )  
      framing = 'minor'
      units_name = 'K'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_rhi )  
      framing = 'minor'
      units_name = '%rhi'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_scanResidual )  
      framing = 'minor'
      units_name = 'meter'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_scECI )  
      framing = 'minor'
      units_name = 'meter'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_sidebandRatio )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_none /)                  
    case ( l_spaceRadiance )  
      framing = 'neither'
      units_name = 'K'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_surfacetype )  
      framing = 'neither'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_systemTemperature )  
      framing = 'neither'
      units_name = 'K'
      dim_names = (/ l_channel, l_none, l_none /)                  
    case ( l_Temperature )  
      framing = 'neither'
      units_name = 'K'
      dim_names = (/ l_channel, l_none, l_none /)                  
    case ( l_totalExtinction )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_vmr )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
      units_name = 'vmr'
    case default                                                     
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    end select                                                       

  end subroutine GetQuantityAttributes

!> >   subroutine my_swwrattr_snglarray(swid, attr_name, attr_type, attr_size, &
!> >       & value)
!> >   ! Arguments
!> >   integer, intent(in)                            :: swid
!> >   character(len=*)                               :: attr_name
!> >   integer, intent(in)                            :: attr_type
!> >   integer, intent(in)                            :: attr_size
!> >   real(r4), dimension(*), intent(in)             :: value
!> >   
!> >   external :: he5_swwrattr
!> >   call he5_swwrattr(swid, attr_name, attr_type, attr_size, &
!> >       & value)
!> >   end subroutine my_swwrattr_snglarray
!> > 
!> >   subroutine my_swwrattr_char(swid, attr_name, attr_type, attr_size, &
!> >       & value)
!> >   ! Arguments
!> >   integer, intent(in)                            :: swid
!> >   character(len=*)                               :: attr_name
!> >   integer, intent(in)                            :: attr_type
!> >   integer, intent(in)                            :: attr_size
!> >   character(len=*), intent(in)                   :: value
!> >   
!> >   external :: he5_swwrattr
!> >   call he5_swwrattr(swid, attr_name, attr_type, attr_size, &
!> >       & value)
!> >   end subroutine my_swwrattr_char
d2948 3
@


2.59
log
@Checks for FILENOTFOUND
@
text
@d36 1
a36 1
       & "$Id: L2GPData.f90,v 2.58 2003/03/07 00:40:23 pwagner Exp $"
d2599 52
a2650 1
  ! --------------------------------------------------------------------------
d2690 1
d3071 3
@


2.58
log
@Call HE5_SWsetfill; removed some spaces from attribute names
@
text
@d14 2
a15 1
  use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, WILDCARDHDFVERSION, &
d36 1
a36 1
       & "$Id: L2GPData.f90,v 2.57 2003/02/26 17:36:11 pwagner Exp $"
d511 5
a515 1
    the_hdfVersion = MLS_HDF_VERSION(FileName, hdfVersion)
d3019 3
@


2.57
log
@Repaired ReadL2GPData to close swath when given WILDCARDHDFVERSION
@
text
@d35 1
a35 1
       & "$Id: L2GPData.f90,v 2.56 2003/02/21 23:41:53 pwagner Exp $"
d42 1
a42 1
  interface DUMP !And this does WTF? On-the-fly dumps; see l2/tree_walker.f90
d47 1
a47 1
  interface ReadL2GPData !And this does WTF? On-the-fly dumps; see l2/tree_walker.f90
d99 1
d108 2
d112 1
d188 12
d730 6
d744 6
d778 6
d867 1
d1143 6
d1157 6
d1191 6
d1286 2
d2047 7
a2053 1

d2084 6
a2089 3
           status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
           status = HE5_SWdefdfld(swid, DATA_FIELD2, DIM_NAME12, MAX_DIML12,&
            HE5T_NATIVE_FLOAT,HDFE_NOMERGE)
d2109 3
a2489 1
    character (len=480) :: msr
d2491 2
d2496 2
a2497 1
      & 'degrees,degrees,seconds,seconds,degrees,degrees,degrees,none,hPa,GHz'
d2545 1
a2545 1
    status = he5_swwrattr(swid, 'Vertical Coordinate', HE5T_NATIVE_SCHAR, 1, &
d2547 1
a2547 1
    status = he5_swwrattr(swid, 'Fill Value', rgp_type, 1, &
d2568 1
a2568 1
        status = he5_swwrlattr(swid, trim(theTitles(field)), 'Fill Value', &
d2853 8
d3014 3
@


2.56
log
@Also writes Fill Value attribute
@
text
@d35 1
a35 1
       & "$Id: L2GPData.f90,v 2.55 2003/02/12 21:50:33 pwagner Exp $"
d503 1
a503 1
    status = mls_io_gen_closeF('swclose', L2FileHandle, &
d557 1
a557 1
         &attach to swath interface for reading.')
d566 1
a566 1
         &get dimension information.')
d572 1
a572 1
       msr = SZ_ERR // DIM_NAME1
d582 1
a582 1
          msr = SZ_ERR // DIM_NAME2
d592 1
a592 1
          msr = SZ_ERR // DIM_NAME3
d608 1
a608 1
          msr = MLSMSG_INPUT // 'firstProf'
d623 1
a623 1
          msr = MLSMSG_INPUT // 'lastProf'
d668 1
a668 1
       msr = MLSMSG_L2GPRead // GEO_FIELD1
d676 1
a676 1
       msr = MLSMSG_L2GPRead // GEO_FIELD2
d925 1
a925 1
         &attach to swath interface for reading.')
d935 1
a935 1
         &get dimension information.')
d2937 3
@


2.55
log
@New api for ReadL2GPData lets you supply fileName and hdfversion, which can be wildcard
@
text
@d35 1
a35 1
       & "$Id: L2GPData.f90,v 2.54 2003/02/10 22:04:49 pwagner Exp $"
d2475 1
a2475 1
        field_name = 'Pressure'
d2478 2
d2499 2
d2937 3
@


2.54
log
@ChunkNumber correctly HE5_SWdefgfld-ed as an int
@
text
@d9 1
a9 1
  use Hdf, only: DFNT_CHAR8, DFNT_FLOAT32, DFNT_INT32, DFNT_FLOAT64
d14 2
a15 1
  use MLSFiles, only: HDFVERSION_4, HDFVERSION_5
d17 1
a17 1
       & MLSMSG_Error, MLSMSG_Warning, MLSMSG_Debug
d35 1
a35 1
       & "$Id: L2GPData.f90,v 2.53 2003/02/08 00:33:32 pwagner Exp $"
d47 5
d419 1
a419 1
  ! ---------------------- ReadL2GPData  -----------------------------
d421 1
a421 1
  subroutine ReadL2GPData(L2FileHandle, swathname, l2gp, numProfs, &
d425 1
d429 1
d464 45
a508 1
  end subroutine ReadL2GPData
d2933 3
@


2.53
log
@Writes he5 attributes w/o bombing
@
text
@d34 1
a34 1
       & "$Id: L2GPData.f90,v 2.50 2003/02/04 22:43:29 pwagner Exp $"
d1790 1
a1790 1
    !print*,"Creating swath called ",name
d1801 1
a1801 1
    print*,"Defined Unlim with size", HE5S_UNLIMITED_f
d1804 1
a1804 1
    print*,"Defining dimension ", DIM_NAME1," with size",l2gp%nTimes
d1812 1
a1812 1
      print*,"Defining dimension ", DIM_NAME2," with size",l2gp%nLevels
d1821 1
a1821 1
       print*,"Defining dimension ", DIM_NAME3," with size",l2gp%nFreqs
d1897 2
d1900 1
a1900 1
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
d1956 3
a1958 3
       print*,"Set chunking with status=",status
       print*,"chunking=",chunk_dims
       print*,"About to define 2-D extendible field"
d1960 2
a1961 2
       print*,"Calling SWdefdfld with args ",swid, DATA_FIELD1, &
             DIM_NAME12, MAX_DIML12, HE5T_NATIVE_FLOAT, HDFE_NOMERGE
d1964 1
a1964 1
       print*,"Defined 2-D extendible field"
d2881 3
@


2.52
log
@rgp now public
@
text
@d34 1
a34 1
       & "$Id: L2GPData.f90,v 2.51 2003/02/06 00:24:48 pwagner Exp $"
d46 5
d1783 1
a1783 1
       chunklevels=nLevels
d1785 2
a1786 1
       chunklevels=5
d1801 1
a1801 1
    !print*,"Defined Unlim with size", HE5S_UNLIMITED
d1804 1
a1804 1
    !print*,"Defining dimension ", DIM_NAME1," with size",l2gp%nTimes
d1812 1
a1812 1
      !print*,"Defining dimension ", DIM_NAME2," with size",l2gp%nLevels
d1821 1
a1821 1
       !print*,"Defining dimension ", DIM_NAME3," with size",l2gp%nFreqs
d1954 3
a1956 3
       !print*,"Set chunking with status=",status
       !print*,"chunking=",chunk_dims
       !print*,"About to define 2-D extendible field"
d1958 2
a1959 2
       !print*,"Calling SWdefdfld with args ",swid, DATA_FIELD1, &
       !      DIM_NAME12, MAX_DIML12, HE5T_NATIVE_FLOAT, HDFE_NOMERGE
d1962 1
a1962 1
       !print*,"Defined 2-D extendible field"
d2083 1
a2083 1
    start = 0  ! myOffset
d2150 1
a2150 1
       ! start(1)=0 ! needed because offset may have made this /=0
d2161 1
a2161 1
       ! start(1)=0 ! needed because offset may have made this /=0
d2237 1
a2237 1
    ! start(3)= 0 ! myOffset
d2349 1
d2412 1
a2412 1
    print *, 'Writing global attributes'
d2418 2
a2419 2
    print *, 'Writing swath attributes'
    call he5_swwrattr(swid, 'Pressure', rgp_type, size(l2gp%pressures), &
d2421 3
d2426 1
a2426 1
    print *, 'Writing geolocation attributes'
d2428 16
a2443 7
      print *, 'field ', field
      print *, 'title ', trim(theTitles(field))
      print *, 'units ', trim(theUnits(field))
      call he5_swwrlattr(swid, trim(theTitles(field)), 'Title', &
        & HE5T_NATIVE_SCHAR, 1, theTitles(field))
      call he5_swwrlattr(swid, trim(theTitles(field)), 'Units', &
        & HE5T_NATIVE_SCHAR, 1, theUnits(field))
d2448 5
a2452 5
    field_name = swathName
    print *, 'Writing data attributes'
    print *, 'title ', trim(swathName)
    print *, 'units ', trim(units_name)
    call he5_swwrlattr(swid, DATA_FIELD1, 'Title', &
d2454 1
a2454 1
    call he5_swwrlattr(swid, DATA_FIELD1, 'Units', &
d2471 1
a2471 1
  subroutine WriteL2GPData(l2gp,l2FileHandle,swathName, hdfVersion)
d2499 1
d2501 1
d2503 1
d2505 1
d2840 28
d2879 4
a2882 1
! Revision 2.51  2003/02/06 00:24:48  pwagner
@


2.51
log
@Squashed a (last?) bug in hdfeos2 stuff
@
text
@d34 1
a34 1
       & "$Id: L2GPData.f90,v 2.50 2003/02/04 22:43:29 pwagner Exp $"
d76 1
a76 1
  integer, parameter :: rgp = r4
d2828 3
@


2.50
log
@Fixed another serious bug
@
text
@a9 1
!  use HDF5_params
d12 1
a12 2
!  use HDFEOS5
!  use HE5_SWAPI 
d17 1
a17 1
  use MLSStrings, only: ints2Strings, strings2Ints
d19 1
d33 3
a35 2
  character(len=256), private :: Id = &
       & "$Id: L2GPData.f90,v 2.49 2003/02/03 21:33:15 pwagner Exp $"
d38 1
d78 2
d81 1
d139 1
d178 4
d192 1
a192 1
    type (L2GPData_T), intent(out)  :: l2gp
d200 1
a200 1
    if (present(nFreqs)) then
d204 1
a204 1
    endif
d206 1
a206 1
    if (present(nLevels)) then
d210 1
a210 1
    endif
d212 1
a212 1
    if (present(nTimes)) then
d216 1
a216 1
    endif
d225 4
d230 1
a230 5
    useNTimes=max(useNTimes,1)
    useNLevels=max(useNLevels,1)
    useNFreqs=max(useNFreqs,1)    

    ! Allocate the frequency coordinate
d235 2
a236 2
    ! Allocate the vertical coordinate

d272 14
a285 15
    call deallocate_test ( l2gp%pressures,    "l2gp%pressures",    ModuleName )
    call deallocate_test ( l2gp%latitude,     "l2gp%latitude",     ModuleName )
    call deallocate_test ( l2gp%longitude,    "l2gp%longitude",    ModuleName )
    call deallocate_test ( l2gp%solarTime,    "l2gp%solarTime",    ModuleName )
    call deallocate_test ( l2gp%solarZenith,  "l2gp%solarZenith",  ModuleName )
    call deallocate_test ( l2gp%losAngle,     "l2gp%losAngle",     ModuleName )
    call deallocate_test ( l2gp%losAngle,     "l2gp%losAngle",     ModuleName )
    call deallocate_test ( l2gp%geodAngle,    "l2gp%geodAngle",    ModuleName )
    call deallocate_test ( l2gp%chunkNumber,  "l2gp%chunkNumber",  ModuleName )
    call deallocate_test ( l2gp%time,         "l2gp%time",         ModuleName )
    call deallocate_test ( l2gp%frequency,    "l2gp%frequency",    ModuleName )
    call deallocate_test ( l2gp%l2gpValue,    "l2gp%l2gpValue",    ModuleName )
    call deallocate_test ( l2gp%l2gpPrecision,"l2gp%l2gpPrecision",ModuleName )
    call deallocate_test ( l2gp%status,       "l2gp%status",       ModuleName )
    call deallocate_test ( l2gp%quality,      "l2gp%quality",      ModuleName )
d289 1
d295 3
a297 2
    ! This subroutine expands an L2GPData_T in place allowing the user to
    ! (1) add more profiles to it; or [or? or WTF?]
d301 1
a301 1
    integer, optional, intent(in) :: newNTimes
d306 2
d319 2
a320 2
    if ( myNTimes<l2gp%nTimes ) &
         & call MLSMessage ( MLSMSG_Error, ModuleName, &
d322 1
d334 5
a338 2
    call SetupNewL2GPRecord( l2gp, nFreqs=l2gp%nFreqs, nLevels=l2gp%nLevels, &
      & nTimes=myNTimes)
d342 1
d360 1
a360 1

d378 1
a378 1
    type (L2GPData_T), dimension(:), pointer :: tempDatabase
d388 1
a388 1
  ! This subroutine destroys an L2GP database
d393 1
a393 1
    type (L2GPData_T), dimension(:), pointer :: DATABASE
d398 2
a399 2
    if ( associated(database)) then
       do l2gpIndex = 1, size(database)
a480 1

d486 1
a486 1
    real, allocatable :: realFreq(:), realSurf(:), realProf(:), real3(:,:,:)
a592 1
      &   realFreq(l2gp%nFreqs), &
d692 1
a692 1
         & realFreq)
a696 1
       l2gp%frequency = realFreq
d799 1
a799 1
    deallocate ( realFreq, realSurf, realProf, real3, STAT=alloc_err )
d2341 3
a2343 2
  use HDFEOS5, only: HE5_SWattach, HE5_SWdetach
  use PCFHdr, only:  sw_writeglobalattr
d2345 6
a2350 3
    ! This subroutine writes the data fields to an L2GP output file.
    ! For now, you have to write all of l2gp, but you can choose to write
    ! it at some offset into the file
d2364 4
d2369 2
d2373 4
d2384 10
d2395 2
a2396 1
    swid = HE5_SWattach (l2FileHandle, name)
d2404 3
a2406 1
    call sw_writeglobalattr(swid)
d2408 29
a2437 1
    !print*,"Detatched from swath -- error=",status
d2444 1
a2444 1
    !-------------------------------------
d2638 46
d2685 138
a2822 1
  !=============================================================================
d2828 3
@


2.49
log
@Having fixed (most)bugs, brought back from he5lib
@
text
@d35 1
a35 1
       & "$Id: L2GPData.f90,v 1.28 2003/01/30 00:58:53 pwagner Exp $"
d1268 1
a1268 1
    if ( l2gp%nFreqs > 1 ) then
d1483 2
a1484 2
    stride = 1
    start = myOffset
d1545 1
a1545 1
       start(1)=0 ! needed because offset may have made this /=0
d1556 1
a1556 1
       start(1)=0 ! needed because offset may have made this /=0
d1629 1
a1629 1
    start(3)= myOffset
d2063 1
a2063 1
    start = myOffset
d2130 1
a2130 1
       start(1)=0 ! needed because offset may have made this /=0
d2141 1
a2141 1
       start(1)=0 ! needed because offset may have made this /=0
d2217 1
a2217 1
    start(3)= myOffset
d2576 3
@


2.48
log
@Added idents to survive zealous Lahey optimizer
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d6 1
a6 2
  !=============================================================================

d10 1
d13 3
a15 1
  use MLSCommon, only: R8
d18 1
a18 1
       & MLSMSG_Error, MLSMSG_Warning
d23 1
a23 1
 
d30 3
a32 5
    & Dump, ExpandL2GPDataInPlace,  &
    & ReadL2GPData, SetupNewL2GPRecord,  WriteL2GPData !, &
!    & OutputL2GP_createFile, OutputL2GP_writeData,  OutputL2GP_writeGeo
!  INTEGER :: SWRDFLD
!  EXTERNAL SWRDFLD !Should USE SWAPI
d34 3
a36 4
  character(len=*), private, parameter :: IdParm = &
    & "$Id: L2GPData.f90,v 2.47 2002/08/22 20:17:47 livesey Exp $"
  character(len=len(idparm)), private :: Id = idParm
  character(len=*), private, parameter :: ModuleName = &
a37 1
  private :: not_used_here 
d40 1
a40 1
  interface DUMP
a44 9
  ! ((( Not yet ready for hdfeos5 versions of files )))
  !       The latter will incorporate the
  !       routines rewritten by H. Pumphrey in he5lib
  !       Perhaps in non-public retitled subroutines:
  !       ReadL2GPData_hdf5
  !       OutputL2GP_createFile_hdf5
  !       OutputL2GP_writeGeo_hdf5
  !       OutputL2GP_writeData_hdf5

d47 17
d66 3
d74 3
d79 29
a107 19
  character (len=*), parameter :: DATA_FIELD1 = 'L2gpValue'
  character (len=*), parameter :: DATA_FIELD2 = 'L2gpPrecision'
  character (len=*), parameter :: DATA_FIELD3 = 'Status'
  character (len=*), parameter :: DATA_FIELD4 = 'Quality'

  character (len=*), parameter :: GEO_FIELD1 = 'Latitude'
  character (len=*), parameter :: GEO_FIELD2 = 'Longitude'
  character (len=*), parameter :: GEO_FIELD3 = 'Time'
  character (len=*), parameter :: GEO_FIELD4 = 'LocalSolarTime'
  character (len=*), parameter :: GEO_FIELD5 = 'SolarZenithAngle'
  character (len=*), parameter :: GEO_FIELD6 = 'LineOfSightAngle'
  character (len=*), parameter :: GEO_FIELD7 = 'OrbitGeodeticAngle'
  character (len=*), parameter :: GEO_FIELD8 = 'ChunkNumber'
  character (len=*), parameter :: GEO_FIELD9 = 'Pressure'
  character (len=*), parameter :: GEO_FIELD10= 'Frequency'

  character (len=*), parameter :: DIM_NAME1 = 'nTimes'
  character (len=*), parameter :: DIM_NAME2 = 'nLevels'
  character (len=*), parameter :: DIM_NAME3 = 'nFreqs'
d109 1
a109 2
  character (len=*), parameter :: DIM_NAME12 = 'nLevels,nTimes' ! In Fortran order?!!
  character (len=*), parameter :: DIM_NAME123 = 'nFreqs,nLevels,nTimes' ! as above
d111 2
a112 2
  integer, parameter :: HDFE_AUTOMERGE = 1     ! MERGE FIELDS WITH SHARE DIM
  integer, parameter :: HDFE_NOMERGE = 0       ! don't merge
a119 1
  
a128 1

d133 1
a133 1
     character (len=l2gpnamelen) :: name ! Typically the swath name.
d139 1
a139 1
     integer :: nLevels         ! Total number of surfaces (=1 for column abundances)
d144 1
a144 1
     real (r8), pointer, dimension(:) :: pressures => NULL() ! Vertical coords (nLevels)
d147 7
a153 7
     real (r8), pointer, dimension(:) :: latitude => NULL()
     real (r8), pointer, dimension(:) :: longitude => NULL()
     real (r8), pointer, dimension(:) :: solarTime => NULL()
     real (r8), pointer, dimension(:) :: solarZenith => NULL()
     real (r8), pointer, dimension(:) :: losAngle => NULL()
     real (r8), pointer, dimension(:) :: geodAngle => NULL()
     real (r8), pointer, dimension(:) :: time => NULL()
d155 1
a155 1
     integer, pointer, dimension(:) :: chunkNumber => NULL()
d159 1
a159 1
     real (r8), pointer, dimension(:) :: frequency => NULL()
d164 2
a165 2
     real (r8), pointer, dimension(:,:,:) :: l2gpValue => NULL()
     real (r8), pointer, dimension(:,:,:) :: l2gpPrecision => NULL()
d168 3
a170 2
     character (len=1), pointer, dimension(:) :: status => NULL()
     real (r8), pointer, dimension(:) :: quality => NULL()
d183 1
a183 1
    type (L2GPData_T), intent(inout)  :: l2gp
d191 1
a191 1
    if ( present(nFreqs) ) then
d195 1
a195 1
    end if
d197 1
a197 1
    if ( present(nLevels) ) then
d201 1
a201 1
    end if
d203 1
a203 1
    if ( present(nTimes) ) then
d207 1
a207 1
    end if
a215 4
 
    useNTimes=MAX(useNTimes,1)
    useNLevels=MAX(useNLevels,1)
    useNFreqs=MAX(useNFreqs,1)    
d217 5
a221 1
    ! Allocate the vertical coordinate
d226 2
a227 2
    ! Allocate the frequency coordinate
    
d263 15
a277 14
    call deallocate_test ( l2gp%pressures,         "l2gp%pressures",         ModuleName )
    call deallocate_test ( l2gp%latitude,          "l2gp%latitude",          ModuleName )
    call deallocate_test ( l2gp%longitude,         "l2gp%longitude",         ModuleName )
    call deallocate_test ( l2gp%solarTime,         "l2gp%solarTime",         ModuleName )
    call deallocate_test ( l2gp%solarZenith,       "l2gp%solarZenith",       ModuleName )
    call deallocate_test ( l2gp%losAngle,          "l2gp%losAngle",          ModuleName )
    call deallocate_test ( l2gp%geodAngle,         "l2gp%geodAngle",         ModuleName )
    call deallocate_test ( l2gp%chunkNumber,       "l2gp%chunkNumber",       ModuleName )
    call deallocate_test ( l2gp%time,              "l2gp%time",              ModuleName )
    call deallocate_test ( l2gp%frequency,         "l2gp%frequency",         ModuleName )
    call deallocate_test ( l2gp%l2gpValue,         "l2gp%l2gpValue",         ModuleName )
    call deallocate_test ( l2gp%l2gpPrecision,     "l2gp%l2gpPrecision",     ModuleName )
    call deallocate_test ( l2gp%status,            "l2gp%status",            ModuleName )
    call deallocate_test ( l2gp%quality,           "l2gp%quality",           ModuleName )
a280 1

d286 2
a287 3
    ! This subroutine expands an L2GPData_T in place allowing the user to 
    ! (1) add more profiles to it; or
    ! 
d291 1
a291 1
    integer, optional, intent(in)    :: newNTimes
a295 2
    integer :: tmpNFreqs, tmpNLevels

d307 2
a308 2
    if ( myNTimes<l2gp%nTimes ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
a309 1
    endif
d321 2
a322 5
    
    tmpNFreqs = l2gp%nFreqs
    tmpNLevels = l2gp%nLevels
    call SetupNewL2GPRecord( l2gp, nFreqs=tmpNFreqs, nLevels=tmpNLevels, &
      & nTimes=myNTimes )
a325 1
    l2gp%frequency=templ2gp%frequency
d343 1
a343 1
    
d361 1
a361 1
    type (l2GPData_T), dimension(:), pointer :: tempDatabase
d371 1
a371 1
  ! This subroutine destroys a quantity template database
d376 1
a376 1
    type (l2GPData_T), dimension(:), pointer :: DATABASE
d381 2
a382 2
    if ( associated(database) ) then
       do l2gpIndex = 1, SIZE(database)
d412 1
a412 1

d419 1
a419 1

d427 4
a430 2
       call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'This version of L2GPData not yet ready for hdf5' )
d432 2
a433 1

d464 1
d470 1
a470 1
    real, allocatable :: realSurf(:), realProf(:), real3(:,:,:)
d577 1
d677 1
a677 1
         & l2gp%frequency)
d682 1
d785 1
a785 1
    deallocate ( realSurf, realProf, real3, STAT=alloc_err )
d806 7
a812 2
  ! --------------------------------------  OutputL2GP_createFile_hdf4  -----
  subroutine OutputL2GP_createFile_hdf4 (l2gp, L2FileHandle, swathName)
d814 2
a815 2
    ! Brief description of subroutine
    ! This subroutine sets up the structural definitions in an empty L2GP file.
d819 5
a823 3
    integer, intent(in) :: L2FileHandle ! From swopen
    type( l2GPData_T ), intent(inout) :: l2gp
    character (len=*), optional, intent(in) :: swathName ! Defaults to l2gp%swathName
d825 9
a833 1
    ! Parameters
d835 4
a838 4
    character (len=*), parameter :: DIM_ERR = 'Failed to define dimension '
    character (len=*), parameter :: GEO_ERR = &
         & 'failed to define geolocation field '
    character (len=*), parameter :: DAT_ERR = 'Failed to define data field '
d840 7
a846 1
    ! Variables
d848 7
a854 2
    character (len=480) :: MSR
    character (len=132) :: NAME   ! From l2gp%name
d856 1
a856 1
    integer :: SWID, STATUS
d858 2
a859 5
    if ( present(swathName) ) then
       name=swathName
    else
       name=l2gp%name
    end if
d861 23
a883 1
    ! Create the swath within the file
d885 11
a895 6
    swid = swcreate(L2FileHandle, TRIM(name))
    if ( swid == -1 ) then
       msr = 'Failed to create swath ' // TRIM(name) &
        & // ' (maybe has the same name as another swath in this file?)'
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d897 1
a897 1
    ! Define dimensions
d899 12
a910 5
    status = swdefdim(swid, DIM_NAME1, l2gp%nTimes)
    if ( status == -1 ) then
       msr = DIM_ERR // DIM_NAME1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d912 1
a912 7
    if ( l2gp%nLevels > 0 ) then
       status = swdefdim(swid, DIM_NAME2, l2gp%nLevels)
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if
d914 2
a915 7
    if ( l2gp%nFreqs > 0 ) then
       status = swdefdim(swid, DIM_NAME3, l2gp%nFreqs)
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME3
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if
d917 10
a926 1
    ! Define horizontal geolocation fields using above dimensions
d928 1
a928 6
    status = swdefgfld(swid, GEO_FIELD1, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d930 1
a930 6
    status = swdefgfld(swid, GEO_FIELD2, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD2
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d932 1
a932 6
    status = swdefgfld(swid, GEO_FIELD3, DIM_NAME1, DFNT_FLOAT64, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d934 1
a934 6
    status = swdefgfld(swid, GEO_FIELD4, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d936 4
a939 6
    status = swdefgfld(swid, GEO_FIELD5, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d941 13
a953 6
    status = swdefgfld(swid, GEO_FIELD6, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d955 1
a955 6
    status = swdefgfld(swid, GEO_FIELD7, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d957 1
a957 6
    status = swdefgfld(swid, GEO_FIELD8, DIM_NAME1, DFNT_INT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD8
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d959 1
a959 8
    if ( l2gp%nLevels > 0 ) then
       status = swdefgfld(swid, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, &
            HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD9
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if
d961 1
a961 8
    if ( l2gp%nFreqs > 0 ) then
       status = swdefgfld(swid, GEO_FIELD10, DIM_NAME3, DFNT_FLOAT64, &
            HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD10
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if
d963 2
a964 1
    ! Define data fields using above dimensions
d966 1
a966 1
    if ( (l2gp%nFreqs > 0) .AND. (l2gp%nLevels > 0) ) then
d968 8
a975 2
       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME123, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d977 1
a977 4
       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d979 8
d988 7
a994 2
       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME123, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d996 7
a1002 4
       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d1004 6
d1011 7
a1017 1
    else if ( l2gp%nLevels > 0 ) then
d1019 924
a1942 2
       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME12, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d1949 3
a1951 2
       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME12, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d1959 6
a1964 3

       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME1, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d1971 3
a1973 2
       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME1, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d1982 14
a1995 6
    status = swdefdfld(swid, DATA_FIELD3, DIM_NAME1, DFNT_CHAR8, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = DAT_ERR // DATA_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1997 2
a1998 2
    status = swdefdfld(swid, DATA_FIELD4, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
d2004 1
a2004 1
    ! Detach from the swath interface.  This stores the swath info within the
d2006 3
a2008 3
    ! swath.

    status = swdetach(swid)
d2015 1
a2015 1
  end subroutine OutputL2GP_createFile_hdf4
d2018 2
a2019 2
  !-----------------------------------------  OutputL2GP_writeGeo_hdf4  -----
  subroutine OutputL2GP_writeGeo_hdf4 (l2gp, l2FileHandle, swathName)
d2021 2
d2028 1
a2028 1
    type( l2GPData_T ), intent(inout) :: l2gp
d2030 2
a2031 2
    character (len=*), intent(in), optional :: swathName ! Defaults to l2gp%name

d2036 1
a2036 1

d2041 3
d2045 6
a2050 2
    integer :: status, swid
    integer :: start(2), stride(2), edge(2)
d2052 1
a2052 1
    if ( present(swathName) ) then
d2056 1
a2056 1
    end if
d2058 1
a2058 1
    swid = swattach (l2FileHandle, name)
d2062 2
a2063 2
    stride(1) = 1
    start(1) = 0
d2065 3
a2067 2

    status = swwrfld(swid, GEO_FIELD1, start, stride, edge, &
d2069 1
d2075 1
a2075 1
    status = swwrfld(swid, GEO_FIELD2, start, stride, edge, &
d2082 1
a2082 1
    status = swwrfld(swid, GEO_FIELD3, start, stride, edge, &
d2089 5
a2093 2
    status = swwrfld(swid, GEO_FIELD4, start, stride, edge, &
        real(l2gp%solarTime))
d2095 1
a2095 1
       msr = WR_ERR // GEO_FIELD4
d2099 2
a2100 2
    status = swwrfld(swid, GEO_FIELD5, start, stride, edge, &
         real(l2gp%solarZenith))
d2102 1
a2102 1
       msr = WR_ERR // GEO_FIELD5
d2106 2
a2107 1
    status = swwrfld(swid, GEO_FIELD6, start, stride, edge, &
d2114 1
a2114 1
    status = swwrfld(swid, GEO_FIELD7, start, stride, edge, &
d2121 1
a2121 1
    status = swwrfld(swid, GEO_FIELD8, start, stride, edge, &
d2130 2
a2131 1
       status = swwrfld(swid, GEO_FIELD9, start, stride, edge, &
d2141 4
a2144 2
       status = swwrfld(swid, GEO_FIELD10, start, stride, edge, &
         l2gp%frequency )
d2153 2
a2154 2
    status = swdetach(swid)

d2161 1
a2161 1
  end subroutine OutputL2GP_writeGeo_hdf4
d2164 2
a2165 2
  !----------------------------------------  OutputL2GP_writeData_hdf4  -----
  subroutine OutputL2GP_writeData_hdf4(l2gp, l2FileHandle, swathName)
d2167 2
d2171 2
a2172 1

d2175 1
a2175 1
    type( l2GPData_T ), intent(inout) :: l2gp
d2177 2
a2178 2
    character (len=*), intent(in), optional :: swathName ! Defaults to l2gp%name

d2188 1
a2188 1
    integer :: status
d2191 1
a2191 1

d2199 8
a2206 1
    if ( present(swathName) ) then
d2210 3
a2212 1
    end if
d2217 1
d2221 2
a2222 1
    swid = swattach (l2FileHandle, name)
d2224 1
d2226 2
a2227 3

       status = swwrfld(swid, DATA_FIELD1, start, stride, edge, &
            & RESHAPE(real(l2gp%l2gpValue), (/SIZE(l2gp%l2gpValue)/)) )
d2232 2
a2233 2
       status = swwrfld(swid, DATA_FIELD2, start, stride, edge, &
            & RESHAPE(real(l2gp%l2gpPrecision), (/SIZE(l2gp%l2gpPrecision)/)) )
d2240 1
d2242 5
a2246 4

       status = swwrfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpValue(1,:,:)) )

d2251 1
a2251 1
       status = swwrfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
d2260 2
a2261 1
       status = swwrfld( swid, DATA_FIELD1, start(3:3), stride(3:3), edge(3:3), &
d2267 1
a2267 1
       status = swwrfld( swid, DATA_FIELD2, start(3:3), stride(3:3), edge(3:3), &
d2277 2
d2282 1
a2282 1
      status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
d2289 7
a2295 3
   else
      status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
           l2gp%status)
d2300 1
a2300 1
   end if
d2302 2
a2303 1
    status = swwrfld(swid, DATA_FIELD4, start(3:3), stride(3:3), edge(3:3), &
d2312 57
a2368 1
    status = swdetach(swid)
d2374 1
d2376 1
a2376 1
  end subroutine OutputL2GP_writeData_hdf4
d2382 1
a2382 1

d2387 3
a2389 3
    integer, intent(in) :: l2FileHandle ! From swopen
    type (l2GPData_T), intent(inout) :: l2gp
    character (len=*), optional, intent(in) :: swathName ! (defaults to l2gp%swathName)
d2391 1
d2411 4
a2414 2
       call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'This version of L2GPData not yet ready for hdf5' )
d2418 37
d2458 1
a2458 1
  subroutine Dump_L2GP_DATABASE ( L2gp, Name, ColumnsOnly, Details )
d2482 1
a2482 1
  end subroutine Dump_L2GP_DATABASE
d2486 1
d2559 1
a2559 1
      call dump ( l2gp%l2gpValue, 'L2GPValue:' )
d2561 1
a2561 1
      call dump ( l2gp%l2gpPrecision, 'L2GPPrecision:' )
d2569 1
a2570 4
  logical function not_used_here()
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here

d2576 2
a2577 5
! Revision 2.47  2002/08/22 20:17:47  livesey
! Bug fix in writing 3D l2gps
!
! Revision 2.46  2002/08/20 20:10:20  livesey
! Dealt with frequency in expand l2gp in place.
d2579 2
a2580 2
! Revision 2.45  2002/08/20 19:48:29  livesey
! Bug fix in handling of frequencies.
d2582 2
a2583 2
! Revision 2.44  2002/07/17 19:02:09  livesey
! Put in bug fix associated with expand in place (lf only?)
d2585 2
a2586 2
! Revision 2.43  2002/07/17 18:57:32  livesey
! Gone back to 2.40, 2.42 didn't work, no time to investigate now
d2588 2
a2589 2
! Revision 2.40  2002/03/15 23:02:49  pwagner
! Gets HDFVERSION_4 and 5 from MLSFiles; checks for illegal hdfversions
d2591 4
a2594 2
! Revision 2.39  2002/01/23 21:47:12  pwagner
! Begun to make hdf5-capable; not yet, though
d2596 5
a2600 2
! Revision 2.38  2001/10/26 23:13:18  pwagner
! Provides a single dump module interface and details
d2602 2
a2603 2
! Revision 2.37  2001/09/05 22:57:16  pwagner
! Removed Columns from L2GPData_T
d2605 2
a2606 2
! Revision 2.36  2001/08/16 23:17:42  vsnyder
! Remove continuation ampersands within two lines
d2608 4
a2611 2
! Revision 2.35  2001/08/06 18:39:03  pwagner
! Now dumps column-related components, too
d2613 2
a2614 2
! Revision 2.34  2001/08/03 23:13:52  pwagner
! Began testing; at least now exits normally again
d2616 2
a2617 2
! Revision 2.33  2001/08/03 00:02:26  pwagner
! Ncolumns now a component of data type; swapi via ints not strings
d2619 2
a2620 29
! Revision 2.32  2001/08/02 00:17:56  pwagner
! Added column components; untested
!
! Revision 2.31  2001/06/13 20:36:15  vsnyder
! Commented out reading l2gp%status.  It appears that reading characters from
! HDF can't be made to work, due to fundamental design flaws in HDF.
!
! Revision 2.30  2001/06/06 17:28:13  pwagner
! the_status_buffer allows reading l2gp%status
!
! Revision 2.29  2001/05/03 23:59:56  vsnyder
! Trying to find out why realProf is undefined
!
! Revision 2.28  2001/04/24 16:28:41  livesey
! Cosmetic changes only, except comment out dubious l2gp%quality = 0 statement.
!
! Revision 2.27  2001/04/20 03:00:59  livesey
! Made L2GPNameLen public
!
! Revision 2.26  2001/04/20 02:05:09  vsnyder
! Cosmetic changes: Default visibility is now private
!
! Revision 2.25  2001/03/20 01:44:25  livesey
! Fixed bug, was outputting chunkNumber as real!
!
! Revision 2.24  2001/03/12 20:25:04  vsnyder
! Improve dump_l2gp.  Nullify components of l2gp before calling
! SetupNewL2GPRecord from ExpandL2GPDataInPlace, so as not to clobber the
! component pointers carefully copied to tempL2gp.
d2622 2
a2623 2
! Revision 2.23  2001/03/01 18:37:51  livesey
! Added dumper routine
d2625 2
a2626 2
! Revision 2.22  2001/02/22 21:54:22  livesey
! Added initialisation to NULL() for pointer components of L2GPData_T
d2628 2
a2629 2
! Revision 2.21  2001/02/15 18:23:20  livesey
! Got it right this time!
d2631 2
a2632 2
! Revision 2.20  2001/02/15 18:20:15  livesey
! Had to comment out reading of status in ReadL2GPData to make it work, logged PR.
d2634 2
a2635 2
! Revision 2.19  2001/02/14 23:39:40  livesey
! Made numProfs argument optional(intent out) for ReadL2GPData
d2637 4
a2640 2
! Revision 2.18  2001/02/13 00:55:35  livesey
! Removed another print statement!
d2642 2
a2643 2
! Revision 2.17  2001/02/13 00:51:31  livesey
! Fixed bug, copy pressure information in ExpandL2GPDataInPlace
d2645 3
a2647 2
! Revision 2.16  2001/02/09 18:38:04  livesey
! Even more print statemets removed!
d2649 2
a2650 2
! Revision 2.15  2001/02/09 17:51:01  livesey
! Removed some print statements.
d2652 3
a2654 2
! Revision 2.14  2001/02/09 17:45:15  livesey
! Another fix to dimension ordering.
d2656 2
a2657 2
! Revision 2.13  2001/02/08 01:06:08  livesey
! Bug fix in ExpandL2GPDataInPlace
d2659 3
a2661 2
! Revision 2.12  2001/02/05 23:58:22  pwagner
! Uses swrdfld from swapi
d2663 2
a2664 2
! Revision 2.11  2001/02/03 00:04:26  pwagner
! Uncommented EXTERNAL SWRDFLD until swapi done
d2666 3
a2668 2
! Revision 2.10  2001/02/02 17:15:02  livesey
! Changed order of DIM_NAME12 and DIM_NAME123, this should be right now!
d2670 2
a2671 2
! Revision 2.9  2001/01/29 18:17:49  livesey
! Changed status, quality and frequency to upper case first character.
@


2.47
log
@Bug fix in writing 3D l2gps
@
text
@d35 1
a35 1
    & "$Id: L2GPData.f90,v 2.46 2002/08/20 20:10:20 livesey Exp $"
d39 1
d1429 4
d1438 3
@


2.46
log
@Dealt with frequency in expand l2gp in place.
@
text
@d35 1
a35 1
    & "$Id: L2GPData.f90,v 2.45 2002/08/20 19:48:29 livesey Exp $"
d1193 1
a1193 1
            & RESHAPE(l2gp%l2gpValue, (/SIZE(l2gp%l2gpValue)/)) )
d1433 3
@


2.45
log
@Bug fix in handling of frequencies.
@
text
@d35 1
a35 1
    & "$Id: L2GPData.f90,v 2.44 2002/07/17 19:02:09 livesey Exp $"
d206 1
a206 1

d312 1
d1433 3
@


2.44
log
@Put in bug fix associated with expand in place (lf only?)
@
text
@d35 1
a35 1
    & "$Id: L2GPData.f90,v 2.43 2002/07/17 18:57:32 livesey Exp $"
d200 1
a200 1
    ! Allocate the frequency coordinate
d205 1
a205 1
    ! Allocate the vertical coordinate
d452 1
a452 1
    real, allocatable :: realFreq(:), realSurf(:), realProf(:), real3(:,:,:)
a558 1
      &   realFreq(l2gp%nFreqs), &
d658 1
a658 1
         & realFreq)
a662 1
       l2gp%frequency = realFreq
d765 1
a765 1
    deallocate ( realFreq, realSurf, realProf, real3, STAT=alloc_err )
d843 1
a843 1
    if ( l2gp%nFreqs > 1 ) then
d919 1
a919 1
       status = swdefgfld(swid, GEO_FIELD10, DIM_NAME3, DFNT_FLOAT32, &
a1121 1
       l2gp%frequency = 0
d1123 1
a1123 1
            real(l2gp%frequency))
d1432 3
@


2.43
log
@Gone back to 2.40, 2.42 didn't work, no time to investigate now
@
text
@d35 1
a35 1
    & "$Id: L2GPData.f90,v 2.40 2002/03/15 23:02:49 pwagner Exp $"
d276 1
d304 4
a307 1
    call SetupNewL2GPRecord( l2gp, nFreqs=l2gp%nFreqs, nLevels=l2gp%nLevels, &
d1435 3
@


2.42
log
@These hdf5-savvy versions transferred from he5lib
@
text
@d6 2
a7 1
!=============================================================================
a10 1
!  use HDF5_params
a12 2
  use HDFEOS5
  use HE5_SWAPI 
d16 1
a16 1
       & MLSMSG_Error, MLSMSG_Warning, MLSMSG_Debug
d21 1
a21 1

d28 5
a32 3
    & Dump, ExpandL2GPDataInPlace, AppendL2GPData, &
    & ReadL2GPData, SetupNewL2GPRecord,  WriteL2GPData

d34 4
a37 3
  character(len=256), private :: Id = &
       & "$Id: L2GPData.f90,v 1.19 2002/06/10 12:00:43 hcp Exp $"
  character(len=*), parameter, private :: ModuleName = &
d41 1
a41 1
  interface DUMP !And this does WTF? On-the-fly dumps; see l2/tree_walker.f90
d46 9
a56 17
  ! It is prepared to handle io for both file versions: hdfeos2 and hdfeos5

!     c o n t e n t s
!     - - - - - - - -

! L2GPData_T              The l2gp data type; holds all data for one swath

! AddL2GPToDatabase       Adds an l2gp data type to a database
! DestroyL2GPContents     Deallocates all the arrays allocated for an L2GP
! DestroyL2GPDatabase     Destroys an L2GP database
! Dump                    Reveals info about an L2GP or a database of L2GP
!                            to any desired level of detail
! ExpandL2GPDataInPlace   Adds more profiles to an existing L2GP
! AppendL2GPData          Appends L2GP onto end of existing swath file
! ReadL2GPData            Reads L2GP from existing swath file
! SetupNewL2GPRecord      Allocates arrays for a new L2GP
! WriteL2GPData           Writes an L2GP into a swath file
d66 19
a84 29
   character (len=*), parameter :: DATA_FIELD1 = 'L2gpValue'
   character (len=*), parameter :: DATA_FIELD2 = 'L2gpPrecision'
   character (len=*), parameter :: DATA_FIELD3 = 'Status'
   character (len=*), parameter :: DATA_FIELD4 = 'Quality'

   character (len=*), parameter :: GEO_FIELD1 = 'Latitude'
   character (len=*), parameter :: GEO_FIELD2 = 'Longitude'
   character (len=*), parameter :: GEO_FIELD3 = 'Time'
   character (len=*), parameter :: GEO_FIELD4 = 'LocalSolarTime'
   character (len=*), parameter :: GEO_FIELD5 = 'SolarZenithAngle'
   character (len=*), parameter :: GEO_FIELD6 = 'LineOfSightAngle'
   character (len=*), parameter :: GEO_FIELD7 = 'OrbitGeodeticAngle'
   character (len=*), parameter :: GEO_FIELD8 = 'ChunkNumber'
   character (len=*), parameter :: GEO_FIELD9 = 'Pressure'
   character (len=*), parameter :: GEO_FIELD10= 'Frequency'

   character (len=*), parameter :: DIM_NAME1 = 'nTimes'
   character (len=*), parameter :: DIM_NAME2 = 'nLevels'
   character (len=*), parameter :: DIM_NAME3 = 'nFreqs'
   character (len=*), parameter :: DIM_NAME12 = 'nLevels,nTimes'
   character (len=*), parameter :: DIM_NAME123 = 'nFreqs,nLevels,nTimes'
   ! These are for the new max_dimlist parameter added to  SWdefgfld.
   ! this one is for non-extendible dimensions
   character (len=*), parameter :: MAX_DIML = ' '
   character (len=*), parameter :: UNLIM = 'Unlim'
   ! This is for cases where the time dimension is extendible
   character (len=*), parameter :: MAX_DIML1 = UNLIM
   character (len=*), parameter :: MAX_DIML12 = 'nLevels,Unlim'
   character (len=*), parameter :: MAX_DIML123 = 'nFreqs,nLevels,Unlim'
d86 2
a87 1
!   INTEGER,PARAMETER::CHUNKFREQS=13,CHUNKLEVELS=17,CHUNKTIMES=9,CHUNK4=1
d89 2
a90 2
   integer, parameter :: HDFE_AUTOMERGE = 1     ! MERGE FIELDS WITH SHARE DIM
   integer, parameter :: HDFE_NOMERGE = 0       ! don't merge
d98 1
d108 1
d113 1
a113 1
     character (LEN=L2GPNameLen) :: name ! Typically the swath name.
d119 1
a119 1
     integer :: nLevels         ! Total number of surfaces (==1 for col. abund)
d124 1
a124 1
     real (r8), pointer, dimension(:) :: pressures=>NULL() ! Vertical coords (nLevels)
d135 1
a135 1
     integer, pointer, dimension(:) :: chunkNumber=>NULL()
d139 1
a139 1
     real (r8), pointer, dimension(:) :: frequency=>NULL()
d144 2
a145 2
     real (r8), pointer, dimension(:,:,:) :: l2gpValue=>NULL()
     real (r8), pointer, dimension(:,:,:) :: l2gpPrecision=>NULL()
d148 2
a149 3
     character (len=1), pointer, dimension(:) :: status=>NULL()
     !                (status is a reserved word in F90)
     real (r8), pointer, dimension(:) :: quality=>NULL()
d162 1
a162 1
    type (L2GPData_T), intent(out)  :: l2gp
d170 1
a170 1
    if (present(nFreqs)) then
d174 1
a174 1
    endif
d176 1
a176 1
    if (present(nLevels)) then
d180 1
a180 1
    endif
d182 1
a182 1
    if (present(nTimes)) then
d186 1
a186 1
    endif
d195 4
a198 4

    useNTimes=max(useNTimes,1)
    useNLevels=max(useNLevels,1)
    useNFreqs=max(useNFreqs,1)    
d242 14
a255 15
    call deallocate_test ( l2gp%pressures,    "l2gp%pressures",    ModuleName )
    call deallocate_test ( l2gp%latitude,     "l2gp%latitude",     ModuleName )
    call deallocate_test ( l2gp%longitude,    "l2gp%longitude",    ModuleName )
    call deallocate_test ( l2gp%solarTime,    "l2gp%solarTime",    ModuleName )
    call deallocate_test ( l2gp%solarZenith,  "l2gp%solarZenith",  ModuleName )
    call deallocate_test ( l2gp%losAngle,     "l2gp%losAngle",     ModuleName )
    call deallocate_test ( l2gp%losAngle,     "l2gp%losAngle",     ModuleName )
    call deallocate_test ( l2gp%geodAngle,    "l2gp%geodAngle",    ModuleName )
    call deallocate_test ( l2gp%chunkNumber,  "l2gp%chunkNumber",  ModuleName )
    call deallocate_test ( l2gp%time,         "l2gp%time",         ModuleName )
    call deallocate_test ( l2gp%frequency,    "l2gp%frequency",    ModuleName )
    call deallocate_test ( l2gp%l2gpValue,    "l2gp%l2gpValue",    ModuleName )
    call deallocate_test ( l2gp%l2gpPrecision,"l2gp%l2gpPrecision",ModuleName )
    call deallocate_test ( l2gp%status,       "l2gp%status",       ModuleName )
    call deallocate_test ( l2gp%quality,      "l2gp%quality",      ModuleName )
d259 1
d265 3
a267 2
    ! This subroutine expands an L2GPData_T in place allowing the user to
    ! (1) add more profiles to it; or [or? or WTF?]
d271 1
a271 1
    integer, optional, intent(in) :: newNTimes
d276 1
d288 2
a289 2
    if ( myNTimes<l2gp%nTimes ) &
         & call MLSMessage ( MLSMSG_Error, ModuleName, &
d291 1
d304 1
a304 1
      & nTimes=myNTimes)
d325 1
a325 1

d343 1
a343 1
    type (L2GPData_T), dimension(:), pointer :: tempDatabase
d353 1
a353 1
  ! This subroutine destroys an L2GP database
d358 1
a358 1
    type (L2GPData_T), dimension(:), pointer :: DATABASE
d363 2
a364 2
    if ( associated(database)) then
       do l2gpIndex = 1, size(database)
d409 2
a410 4
      call ReadL2GPData_hdf5(L2FileHandle, swathname, l2gp, numProfs, &
       firstProf, lastProf)
!       call MLSMessage ( MLSMSG_Error, ModuleName, &
!            & 'This version of L2GPData not yet ready for hdf5' )
a442 1

d784 2
a785 1
  ! ------------------- ReadL2GPData_hdf5 ----------------
d787 2
a788 6
  subroutine ReadL2GPData_hdf5(L2FileHandle, swathname, l2gp, numProfs, &
       firstProf, lastProf)
    !------------------------------------------------------------------------

    ! This routine reads an L2GP file, returning a filled data structure and the !
    ! number of profiles read.
d792 3
a794 5
    character (LEN=*), intent(IN) :: swathname ! Name of swath
    integer, intent(IN) :: L2FileHandle ! Returned by swopen
    integer, intent(IN), optional :: firstProf, lastProf ! Defaults to first and last
    type( L2GPData_T ), intent(OUT) :: l2gp ! Result
    integer, intent(OUT),optional :: numProfs ! Number actually read
d796 1
a796 9
    ! Local Parameters
    character (LEN=*), parameter :: SZ_ERR = 'Failed to get size of &
         &dimension '
    character (LEN=*), parameter :: MLSMSG_INPUT = 'Error in input argument '
    character (LEN=*), parameter :: MLSMSG_L2GPRead = 'Unable to read L2GP &
                                                     &field:'
    ! Local Variables
    character (LEN=80) :: list
    character (LEN=480) :: msr
d798 4
a801 4
    integer :: alloc_err, first, freq, lev, nDims, size, swid, status
    integer :: start(3), stride(3), edge(3), dims(3)
    integer :: nFreqs, nLevels, nTimes, nFreqsOr1, nLevelsOr1, myNumProfs
    logical :: firstCheck, lastCheck
d803 1
a803 7
    real, allocatable :: realFreq(:), realSurf(:), realProf(:), real3(:,:,:)
!  How to deal with status and columnTypes? swrfld fails
!  with char data on Linux with HDF4. With HDF5 we may or may not need to
!  Have recourse to ints2Strings and strings2Ints if USEINTS4STRINGS
!    character (LEN=8), allocatable :: the_status_buffer(:)
!    character (LEN=L2GPNameLen), allocatable :: the_status_buffer(:)
    integer, allocatable, dimension(:,:) :: string_buffer
d805 2
a806 1
    ! Attach to the swath for reading
d808 1
a808 5
    l2gp%Name = swathname
    
    swid = HE5_SWattach(L2FileHandle, l2gp%Name)
    if (swid == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &attach to swath interface for reading.')
d810 5
a814 1
    ! Get dimension information
d816 1
a816 2
    lev = 0
    freq = 0
d818 6
a823 5
    nDims = HE5_SWinqdims(swid, list, dims)
    if (nDims == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &get dimension information.')
    if ( index(list,'nLevels') /= 0 ) lev = 1
    if ( index(list,'Freq') /= 0 ) freq = 1
d825 1
a825 16
    size = HE5_SWdiminfo(swid, DIM_NAME1)
    if (size == -1) then
       msr = SZ_ERR // DIM_NAME1
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
    l2gp%nTimes = size
    nTimes=size
    if (lev == 0) then
       nLevels = 0
    else
       size = HE5_SWdiminfo(swid, DIM_NAME2)
       if (size == -1) then
          msr = SZ_ERR // DIM_NAME2
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
       nLevels = size
d827 5
a831 1
    endif
d833 7
a839 10
    if (freq == 1) then
       size = HE5_SWdiminfo(swid, DIM_NAME3)
       if (size == -1) then
          msr = SZ_ERR // DIM_NAME3
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
       nFreqs = size
    else
       nFreqs = 0
    endif
d841 7
a847 1
    ! Check optional input arguments
d849 1
a849 2
    firstCheck = present(firstProf)
    lastCheck = present(lastProf)
d851 6
a856 1
    if (firstCheck) then
d858 6
a863 6
       if ( (firstProf >= l2gp%nTimes) .or. (firstProf < 0) ) then
          msr = MLSMSG_INPUT // 'firstProf'
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       else
          first = firstProf
       endif
d865 6
a870 1
    else
d872 6
a877 1
       first = 0
d879 6
a884 1
    endif
d886 6
a891 1
    if (lastCheck) then
d893 6
a898 4
       if (lastProf < first) then
          msr = MLSMSG_INPUT // 'lastProf'
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
d900 6
a905 5
       if (lastProf >= nTimes) then
          myNumProfs = nTimes - first
       else
          myNumProfs = lastProf - first + 1
       endif
d907 8
a914 1
    else
d916 8
a923 1
       myNumProfs = nTimes - first
d925 1
a925 1
    endif
d927 1
a927 1
    ! Allocate result
d929 2
a930 2
    call SetupNewL2GPRecord (l2gp, nFreqs=nFreqs, nLevels=nLevels, &
      &  nTimes=mynumProfs)
d932 4
a935 1
    ! Allocate temporary arrays
a936 8
    nFreqsOr1=max(nFreqs,1)
    nLevelsOr1=max(nLevels, 1)
    allocate(realProf(myNumProfs), realSurf(l2gp%nLevels), &
      &   realFreq(l2gp%nFreqs), &
      &   string_buffer(1,myNumProfs), &
      &   real3(nFreqsOr1,nLevelsOr1,myNumProfs), STAT=alloc_err)
    if ( alloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//' various things in ReadL2GPData' )
d938 2
a939 1
    ! Read the horizontal geolocation fields
d941 4
a944 8
    start(1) = 0
    start(2) = 0
    start(3) = first
    stride = 1
    edge(1) = nFreqsOr1
    edge(2) = nLevelsOr1
    edge(3) = myNumProfs
    status=0
a945 7
    status = HE5_SWrdfld(swid, GEO_FIELD1, start(3:3), stride(3:3), &
      edge(3:3), realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD1
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
    l2gp%latitude = realProf
d947 1
a947 7
    status = HE5_SWrdfld(swid, GEO_FIELD2, start(3:3), stride(3:3), edge(3:3),&
      &    realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD2
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
    l2gp%longitude = realProf
d949 2
a950 6
    status = HE5_SWrdfld(swid, GEO_FIELD3, start(3:3), stride(3:3), edge(3:3),&
      &    l2gp%time)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD3
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
d952 4
a955 7
    status = HE5_SWrdfld(swid, GEO_FIELD4, start(3:3), stride(3:3), edge(3:3),&
      &    realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD4
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
    l2gp%solarTime = realProf
d957 2
a958 7
    status = HE5_SWrdfld(swid, GEO_FIELD5, start(3:3), stride(3:3), edge(3:3),&
      &    realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD5
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
    l2gp%solarZenith = realProf
d960 4
a963 744
    status = HE5_SWrdfld(swid, GEO_FIELD6, start(3:3), stride(3:3), edge(3:3),&
      &    realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD6
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
    l2gp%losAngle = realProf

    status = HE5_SWrdfld(swid, GEO_FIELD7, start(3:3), stride(3:3), edge(3:3),&
      &   realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD7
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
    l2gp%geodAngle = realProf

    status = HE5_SWrdfld(swid, GEO_FIELD8, start(3:3), stride(3:3), edge(3:3),&
      &    l2gp%chunkNumber)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // GEO_FIELD8
       call MLSMessage(MLSMSG_Warning, ModuleName, msr)
    endif

    ! Read the pressures vertical geolocation field, if it exists

    if (lev /= 0) then

       status = HE5_SWrdfld(swid,GEO_FIELD9,start(2:2),stride(2:2), edge(2:2),&
         & realSurf)
       if (status == -1) then
          msr = MLSMSG_L2GPRead // GEO_FIELD9
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif

       l2gp%pressures = realSurf

    endif

    ! Read the frequency geolocation field, if it exists

    if (freq == 1) then

       edge(1) = l2gp%nFreqs

       status = HE5_SWrdfld(swid,GEO_FIELD10,start(1:1),stride(1:1),edge(1:1),&
         & realFreq)
       if (status == -1) then
          msr = MLSMSG_L2GPRead // GEO_FIELD10
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
       l2gp%frequency = realFreq

    endif

    ! Read the data fields that may have 1-3 dimensions

    if ( freq == 1) then

       status = HE5_SWrdfld(swid, DATA_FIELD1, start, stride, edge, real3)
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD1
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
       l2gp%l2gpValue = real3

       status = HE5_SWrdfld(swid, DATA_FIELD2, start, stride, edge, real3)
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD2
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
       l2gp%l2gpPrecision = real3

    else if ( lev == 1) then

       status = HE5_SWrdfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
            edge(2:3), real3 )
!            edge(2:3), real3(1,:,:) )
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD1
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
       l2gp%l2gpValue = real3

       status = HE5_SWrdfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
            edge(2:3), real3(1,:,:) )
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD2
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
       l2gp%l2gpPrecision = real3

    else

       status = HE5_SWrdfld(swid,DATA_FIELD1,start(3:3),stride(3:3),edge(3:3),&
         &   real3(1,1,:) )
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD1
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
       l2gp%l2gpValue = real3

       status = HE5_SWrdfld( swid, DATA_FIELD2, start(3:3), stride(3:3), edge(3:3), &
            real3(1,1,:) )
       if (status == -1) then
          msr = MLSMSG_L2GPRead // DATA_FIELD2
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
       endif
       l2gp%l2gpPrecision = real3

    endif
    
    ! Read the data fields that are 1-dimensional

!??? There appears to be a problem with reading character data using
!??? HDF-EOS.  HDF_EOS's swrdfld expects a C void* pointer, no matter what
!??? the type of object.  Burkhard Burow's cfortran macros need to be told
!??? whether the argument is character, because compilers represent character
!??? arguments in various ways, usually different from non-character arguments.
!??? I.e., never the twain shall meet.
!    status = swrdfld(swid, DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
!      l2gp%status)
!    status = swrdfld(swid, DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
!      the_status_buffer)
! These lines commented out as they make NAG core dump on the deallocate statement.
! below.
!    if ( status == -1 ) then
!      msr = MLSMSG_L2GPRead // DATA_FIELD3
!      call MLSMessage ( MLSMSG_Error, ModuleName, msr )
!    end if
!    l2gp%status = the_status_buffer(:)(1:1)
    
    !   The above note was copied direct from the HDF4 version. The HDF5
    ! version has similar problems so these lines are commented too.
    !         status = HE5_SWrdfld(swid, DATA_FIELD3,start(3:3),&
    !    stride(3:3),edge(3:3), l2gp%status)

    l2gp%status = ' ' ! So it has a value.

   if(USEINTS4STRINGS) then
       status = HE5_swrdfld(swid,DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
         string_buffer)
       if ( status == -1 ) then
         msr = MLSMSG_L2GPRead // DATA_FIELD3
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       call ints2Strings(string_buffer, l2gp%status)
    else
      call MLSMessage(MLSMSG_Debug, ModuleName, &
        "reading of status field disabled")
      status=0
    end if

    status = HE5_SWrdfld(swid, DATA_FIELD4, start(3:3), stride(3:3),&
      edge(3:3),realProf)
    if (status == -1) then
       msr = MLSMSG_L2GPRead // DATA_FIELD4
       call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif
    l2gp%quality = realProf

    ! Deallocate local variables

    deallocate(realFreq, realSurf, realProf, real3, STAT=alloc_err)
    if ( alloc_err /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
         'Failed deallocation of local real variables.')

    deallocate ( string_buffer, STAT=alloc_err )
    if ( alloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
         'Failed deallocation of status buffer.' )

    !  After reading, detach from HE5_SWath interface

    status = HE5_SWdetach(swid)
    if (status == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &detach from swath interface after reading.')

    ! Set numProfs if wanted
    if (present(numProfs)) numProfs=myNumProfs

    !-----------------------------
  end subroutine ReadL2GPData_hdf5
  !-----------------------------

  ! --------------------------------------  OutputL2GP_createFile_hdf4  -----
  subroutine OutputL2GP_createFile_hdf4 (l2gp, L2FileHandle, swathName)

    ! Brief description of subroutine
    ! This subroutine sets up the structural definitions in an empty L2GP file.

    ! Arguments

    integer, intent(in) :: L2FileHandle ! From swopen
    type( l2GPData_T ), intent(inout) :: l2gp
    character (len=*), optional, intent(in) :: swathName ! Defaults to l2gp%swathName

    ! Parameters

    character (len=*), parameter :: DIM_ERR = 'Failed to define dimension '
    character (len=*), parameter :: GEO_ERR = &
         & 'failed to define geolocation field '
    character (len=*), parameter :: DAT_ERR = 'Failed to define data field '

    ! Variables

    character (len=480) :: MSR
    character (len=132) :: NAME   ! From l2gp%name

    integer :: SWID, STATUS

    if ( present(swathName) ) then
       name=swathName
    else
       name=l2gp%name
    end if

    ! Create the swath within the file

    swid = swcreate(L2FileHandle, TRIM(name))
    if ( swid == -1 ) then
       msr = 'Failed to create swath ' // TRIM(name) &
        & // ' (maybe has the same name as another swath in this file?)'
    end if

    ! Define dimensions

    status = swdefdim(swid, DIM_NAME1, l2gp%nTimes)
    if ( status == -1 ) then
       msr = DIM_ERR // DIM_NAME1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    if ( l2gp%nLevels > 0 ) then
       status = swdefdim(swid, DIM_NAME2, l2gp%nLevels)
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if

    if ( l2gp%nFreqs > 1 ) then
       status = swdefdim(swid, DIM_NAME3, l2gp%nFreqs)
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME3
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if

    ! Define horizontal geolocation fields using above dimensions

    status = swdefgfld(swid, GEO_FIELD1, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD2, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD2
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD3, DIM_NAME1, DFNT_FLOAT64, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD4, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD5, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD6, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD7, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefgfld(swid, GEO_FIELD8, DIM_NAME1, DFNT_INT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD8
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    if ( l2gp%nLevels > 0 ) then
       status = swdefgfld(swid, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, &
            HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD9
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if

    if ( l2gp%nFreqs > 0 ) then
       status = swdefgfld(swid, GEO_FIELD10, DIM_NAME3, DFNT_FLOAT32, &
            HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD10
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if

    ! Define data fields using above dimensions

    if ( (l2gp%nFreqs > 0) .AND. (l2gp%nLevels > 0) ) then

       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME123, DFNT_FLOAT32, &
            HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if


       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME123, DFNT_FLOAT32, &
            HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if


    else if ( l2gp%nLevels > 0 ) then

       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME12, DFNT_FLOAT32, &
            HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 //  ' for 2D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME12, DFNT_FLOAT32, &
            HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 //  ' for 2D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

    else

       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME1, DFNT_FLOAT32, &
            HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 // ' for 1D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME1, DFNT_FLOAT32, &
            HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 // ' for 1D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

    end if

    status = swdefdfld(swid, DATA_FIELD3, DIM_NAME1, DFNT_CHAR8, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = DAT_ERR // DATA_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefdfld(swid, DATA_FIELD4, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = DAT_ERR // DATA_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    ! Detach from the swath interface.  This stores the swath info within the
    ! file and must be done before writing or reading data to or from the
    ! swath.

    status = swdetach(swid)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Failed to detach from swath interface after definition.' )
    end if

    !--------------------------------------
  end subroutine OutputL2GP_createFile_hdf4
  !--------------------------------------

  !-----------------------------------------  OutputL2GP_writeGeo_hdf4  -----
  subroutine OutputL2GP_writeGeo_hdf4 (l2gp, l2FileHandle, swathName, offset)

    ! Brief description of subroutine
    ! This subroutine writes the geolocation fields to an L2GP output file.

    ! Arguments

    type( l2GPData_T ), intent(inout) :: l2gp
    integer, intent(in) :: l2FileHandle ! From swopen
    character (len=*), intent(in), optional :: swathName ! Defaults to l2gp%name
    integer,intent(IN),optional::offset

    ! Parameters

    character (len=*), parameter :: WR_ERR = &
         & 'Failed to write geolocation field '

    ! Variables

    character (len=480) :: msr
    character (len=132) :: name ! Either swathName or l2gp%name

    integer :: status, swid,myOffset
    integer :: start(2), stride(2), edge(2)

    ! Begin
    if (present(offset)) then
       myOffset=offset
    else
       myOffset=0
    endif

    if ( present(swathName) ) then
       name=swathName
    else
       name=l2gp%name
    end if

    swid = swattach (l2FileHandle, name)

    ! Write data to the fields

    stride = 1
    start = myOffset
    edge(1) = l2gp%nTimes

    status = swwrfld(swid, GEO_FIELD1, start, stride, edge, &
         real(l2gp%latitude))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swwrfld(swid, GEO_FIELD2, start, stride, edge, &
         real(l2gp%longitude))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD2
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swwrfld(swid, GEO_FIELD3, start, stride, edge, &
         l2gp%time)
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swwrfld(swid, GEO_FIELD4, start, stride, edge, &
        real(l2gp%solarTime))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swwrfld(swid, GEO_FIELD5, start, stride, edge, &
         real(l2gp%solarZenith))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swwrfld(swid, GEO_FIELD6, start, stride, edge, &
         real(l2gp%losAngle))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swwrfld(swid, GEO_FIELD7, start, stride, edge, &
         real(l2gp%geodAngle))
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swwrfld(swid, GEO_FIELD8, start, stride, edge, &
         l2gp%chunkNumber)
    if ( status == -1 ) then
       msr = WR_ERR // GEO_FIELD8
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    if ( l2gp%nLevels > 0 ) then
       edge(1) = l2gp%nLevels
       start(1)=0 ! needed because offset may have made this /=0
       status = swwrfld(swid, GEO_FIELD9, start, stride, edge, &
            real(l2gp%pressures))
       if ( status == -1 ) then
          msr = WR_ERR // GEO_FIELD9
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if

    if ( l2gp%nFreqs > 0 ) then
       edge(1) = l2gp%nFreqs
       start(1)=0 ! needed because offset may have made this /=0
       l2gp%frequency = 0
       status = swwrfld(swid, GEO_FIELD10, start, stride, edge, &
            real(l2gp%frequency))
       if ( status == -1 ) then
          msr = WR_ERR // GEO_FIELD10
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if

    ! Detach from the swath interface.  

    status = swdetach(swid)

    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach from swath interface' )
    end if

    !------------------------------------
  end subroutine OutputL2GP_writeGeo_hdf4
  !------------------------------------

  !----------------------------------------  OutputL2GP_writeData_hdf4  -----
  subroutine OutputL2GP_writeData_hdf4(l2gp, l2FileHandle, swathName, offset)

    ! Brief description of subroutine
    ! This subroutine writes the data fields to an L2GP output file.

    ! Arguments

    type( l2GPData_T ), intent(inout) :: l2gp
    integer, intent(in) :: l2FileHandle ! From swopen
    character (len=*), intent(in), optional :: swathName ! Defaults to l2gp%name
    integer,intent(IN),optional::offset

    ! Parameters

    character (len=*), parameter :: WR_ERR = 'Failed to write data field '

    ! Variables

    character (len=480) :: msr
    character (len=132) :: name     ! Either swathName or l2gp%name

    integer :: status, myOffset
    integer :: start(3), stride(3), edge(3)
    integer :: swid

!  How to deal with status and columnTypes? swrfld fails
!  with char data on Linux
!  Have recourse to ints2Strings and strings2Ints if USEINTS4STRINGS
!    character (LEN=8), allocatable :: the_status_buffer(:)
!    character (LEN=L2GPNameLen), allocatable :: the_status_buffer(:)
    integer, allocatable, dimension(:,:) :: string_buffer

    ! Begin
    if (present(offset)) then
       myOffset=offset
    else
       myOffset=0
    endif
    if ( present(swathName) ) then
       name=swathName
    else
       name=l2gp%name
    end if
    ! Write data to the fields

    start = 0
    stride = 1
    start(3)= myOffset
    edge(1) = l2gp%nFreqs
    edge(2) = l2gp%nLevels
    edge(3) = l2gp%nTimes
    swid = swattach (l2FileHandle, name)
    if ( l2gp%nFreqs > 0 ) then
       ! Value and Precision are 3-D fields

       status = swwrfld(swid, DATA_FIELD1, start, stride, edge, &
            & RESHAPE(l2gp%l2gpValue, (/SIZE(l2gp%l2gpValue)/)) )
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       status = swwrfld(swid, DATA_FIELD2, start, stride, edge, &
            & RESHAPE(real(l2gp%l2gpPrecision), (/SIZE(l2gp%l2gpPrecision)/)) )
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

    else if ( l2gp%nLevels > 0 ) then
       ! Value and Precision are 2-D fields

       status = swwrfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpValue(1,:,:)) )

       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       status = swwrfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpPrecision(1,:,:) ))
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    else

       ! Value and Precision are 1-D fields
       status = swwrfld( swid, DATA_FIELD1, start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpValue(1,1,:) ))
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       status = swwrfld( swid, DATA_FIELD2, start(3:3), stride(3:3), edge(3:3), &
            real(l2gp%l2gpPrecision(1,1,:) ))
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if

    ! 1-D status & quality fields

   if(USEINTS4STRINGS) then
      allocate(string_buffer(1,l2gp%nTimes))
      call strings2Ints(l2gp%status, string_buffer)
      status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
           string_buffer)
      if ( status == -1 ) then
         msr = WR_ERR // DATA_FIELD3
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if
      deallocate(string_buffer)
   else
      status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
           l2gp%status)
      if ( status == -1 ) then
         msr = WR_ERR // DATA_FIELD3
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if
   end if
    !  l2gp%quality = 0 !??????? Why was this here !??? NJL
    status = swwrfld(swid, DATA_FIELD4, start(3:3), stride(3:3), edge(3:3), &
         real(l2gp%quality))
    if ( status == -1 ) then
       msr = WR_ERR // DATA_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    !     Detach from the swath interface.

    status = swdetach(swid)
    if ( status == -1 ) then
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Failed to detach  from swath interface' )
    end if

    !-------------------------------------
  end subroutine OutputL2GP_writeData_hdf4
  !-------------------------------------

  ! --------------------------------------  OutputL2GP_createFile_hdf5  -----
  subroutine OutputL2GP_createFile_hdf5 (l2gp, L2FileHandle, swathName,nLevels)

    ! Brief description of subroutine
    ! This subroutine sets up the structural definitions in an empty L2GP file.

    ! Arguments

    integer, intent(in) :: L2FileHandle ! From swopen
    type( L2GPData_T ), intent(inout) :: l2gp
    character (LEN=*), optional, intent(IN) :: swathName ! Defaults to l2gp%swathName
    integer,optional::nLevels
    ! Parameters

    character (len=*), parameter :: DIM_ERR = 'Failed to define dimension '
    character (len=*), parameter :: GEO_ERR = &
         & 'Failed to define geolocation field '
    character (len=*), parameter :: DAT_ERR = 'Failed to define data field '

    ! Variables

    character (len=480) :: MSR
    character (len=132) :: NAME   ! From l2gp%name

    ! THESE ARE HDF5 CHUNKS, _NOT_ MLS ALONG-TRACK PROCESSING CHUNKS 
    integer,dimension(7)::CHUNK_DIMS
    integer::CHUNK_RANK
    integer::CHUNKTIMES,CHUNKFREQS,CHUNKLEVELS

    integer :: SWID, STATUS

    if (present(swathName)) then
       name=swathName
    else
       name=l2gp%name
    endif
    chunktimes=1
    chunkfreqs=1 ! better as nFreqs, but I have yet to see a case with nfreqs>1
    if(present(nLevels))then
       chunklevels=nLevels
    else
       chunklevels=5
    endif
    
    ! Create the swath within the file
    !print*,"Creating swath called ",name
    swid = HE5_SWcreate(L2FileHandle, trim(name))
    !print*,"Swath ",name,"has SW id :",swid
    if ( swid == -1 ) then
       msr = 'Failed to create swath ' // TRIM(name) &
        & // ' (maybe has the same name as another swath in this file?)'
    end if
d965 1
a965 1
    ! Define dimensions
d967 2
a968 10
    ! Defining special "unlimited dimension called UNLIM
    !print*,"Defined Unlim with size", HE5S_UNLIMITED
    status = HE5_SWdefdim(swid, UNLIM, HE5S_UNLIMITED_F)

    !print*,"Defining dimension ", DIM_NAME1," with size",l2gp%nTimes
    status = HE5_SWdefdim(swid, DIM_NAME1, l2gp%nTimes)
    if ( status == -1 ) then
       msr = DIM_ERR // DIM_NAME1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
a969 3
    if ( l2gp%nLevels > 0 ) then
      !print*,"Defining dimension ", DIM_NAME2," with size",l2gp%nLevels
       status = HE5_SWdefdim(swid, DIM_NAME2, l2gp%nLevels)
d971 1
a971 1
          msr = DIM_ERR // DIM_NAME2
a973 1
    end if
d975 3
a977 3
    if ( l2gp%nFreqs > 0 ) then
       print*,"Defining dimension ", DIM_NAME3," with size",l2gp%nFreqs
       status = HE5_SWdefdim(swid, DIM_NAME3, l2gp%nFreqs)
d979 1
a979 1
          msr = DIM_ERR // DIM_NAME3
a981 3
    end if

    ! Define horizontal geolocation fields using above dimensions
a982 12
!    print*,"Defining geolocation field ",GEO_FIELD1," of dim. ", DIM_NAME1
!    print*,"... and of type ",HE5T_NATIVE_FLOAT
    chunk_rank=1
    chunk_dims=1
    chunk_dims(1)=CHUNKTIMES
    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
!    print*,"Set chunking -- status=",status
    status = HE5_SWdefgfld(swid, GEO_FIELD1, DIM_NAME1,MAX_DIML1,&
         HE5T_NATIVE_FLOAT , 0)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
a983 2
!    print*,"Defined geolocation field ",GEO_FIELD1,"of dim.", DIM_NAME1
!    print*,"... and of type ",HE5T_NATIVE_FLOAT
d985 2
a986 4
    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)

    status = HE5_SWdefgfld(swid, GEO_FIELD2, DIM_NAME1, MAX_DIML1,&
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
d988 1
a988 1
       msr = GEO_ERR // GEO_FIELD2
d992 2
a993 162
    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD3, DIM_NAME1, MAX_DIML1, &
    HE5T_NATIVE_DOUBLE, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD4, DIM_NAME1,MAX_DIML1,&
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD5, DIM_NAME1, MAX_DIML1, &
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD6, DIM_NAME1,MAX_DIML1,&
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD7, DIM_NAME1, MAX_DIML1,&
    HE5T_NATIVE_FLOAT,   HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    status = HE5_SWdefgfld(swid, GEO_FIELD8, DIM_NAME1, MAX_DIML1,&
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD8
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    if ( l2gp%nLevels > 0 ) then

       status = HE5_SWdefgfld(swid, GEO_FIELD9, DIM_NAME2,MAX_DIML,&
            HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD9
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if

    if ( l2gp%nFreqs > 0 ) then

       status = HE5_SWdefgfld(swid, GEO_FIELD10, DIM_NAME3,MAX_DIML,&
            HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD10
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if

    ! Define data fields using above dimensions

    if ( (l2gp%nFreqs > 0) .and. (l2gp%nLevels > 0) ) then
       chunk_rank=3
       chunk_dims(1:3)=(/ CHUNKFREQS,CHUNKLEVELS,CHUNKTIMES /)
       status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)

       status = HE5_SWdefdfld(swid, DATA_FIELD1, DIM_NAME123, MAX_DIML123,&
       HE5T_NATIVE_FLOAT,HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if


       status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
       status = HE5_SWdefdfld(swid, DATA_FIELD2, DIM_NAME123, MAX_DIML123,&
            HE5T_NATIVE_FLOAT, HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if


    else if ( l2gp%nLevels > 0 ) then
       chunk_rank=2
       chunk_dims(1:7)=(/ CHUNKLEVELS,CHUNKTIMES,37,38,39,47,49/)
       status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
       !print*,"Set chunking with status=",status
       !print*,"chunking=",chunk_dims
       !print*,"About to define 2-D extendible field"

       !print*,"Calling SWdefdfld with args ",swid, DATA_FIELD1, &
       !      DIM_NAME12, MAX_DIML12, HE5T_NATIVE_FLOAT, HDFE_NOMERGE
       status = HE5_SWdefdfld(swid, DATA_FIELD1, DIM_NAME12, MAX_DIML12, &
            HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
       !print*,"Defined 2-D extendible field"

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 //  ' for 2D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

           status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
           status = HE5_SWdefdfld(swid, DATA_FIELD2, DIM_NAME12, MAX_DIML12,&
            HE5T_NATIVE_FLOAT,HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 //  ' for 2D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

    else
       chunk_rank=1
       chunk_dims(1)=CHUNKTIMES
       status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)
    
       status = HE5_SWdefdfld(swid, DATA_FIELD1, DIM_NAME1,MAX_DIML1,&
            HE5T_NATIVE_FLOAT,HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 // ' for 1D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

       status = HE5_SWdefdfld(swid, DATA_FIELD2, DIM_NAME1, MAX_DIML1,&
       HE5T_NATIVE_FLOAT, HDFE_NOMERGE)

       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 // ' for 1D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if

    end if

!    print*,"Defining data field ",DATA_FIELD3,"of dim.", DIM_NAME1
!    print*,"... and of type ",HE5T_NATIVE_CHAR

!    status = HE5_SWdefdfld(swid, DATA_FIELD3, DIM_NAME1,MAX_DIML1,&
!         HE5T_NATIVE_CHAR, HDFE_NOMERGE)
!    IF ( status == -1 ) THEN
!       msr = DAT_ERR // DATA_FIELD3
!       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
!    END IF

!    print*,"Defined data field ",DATA_FIELD3,"of dim.", DIM_NAME1
    chunk_rank=1
    chunk_dims(1)=CHUNKTIMES
    status=HE5_SWdefchunk(swid,chunk_rank,chunk_dims)

    status = HE5_SWdefdfld(swid, DATA_FIELD4, DIM_NAME1,MAX_DIML1,&
         HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
d999 1
a999 1
    ! Detach from the HE5_SWath interface.This stores the swath info within the
d1001 3
a1003 3
    ! swath. (May be un-necessary for HDF5 -- test program works OK without.)
    ! 
    status = HE5_SWdetach(swid)
d1010 1
a1010 1
  end subroutine OutputL2GP_createFile_hdf5
d1013 2
a1014 2
  !-----------------------------------------  OutputL2GP_writeGeo_hdf5  -----
  subroutine OutputL2GP_writeGeo_hdf5 (l2gp, l2FileHandle, swathName,offset)
d1021 1
a1021 1
    type( L2GPData_T ), intent(inout) :: l2gp
d1023 2
a1024 2
    character (len=*), intent(IN), optional :: swathName ! Defaults->l2gp%name
    integer,intent(IN),optional::offset
d1029 1
a1029 1
    
d1034 2
a1035 2
    
    integer :: status, swid,myOffset
d1038 1
a1038 8
    ! Begin
    if (present(offset)) then
       myOffset=offset
    else
       myOffset=0
    endif

    if (present(swathName)) then
d1042 1
a1042 1
    endif
d1044 1
a1044 1
    swid = HE5_SWattach (l2FileHandle, name)
d1048 2
a1049 2
    stride = 1
    start = myOffset
d1051 2
a1052 3
    !print*,"writeGeo Attached swath ",name," with SW ID=",swid
    !print*,"About to write latitude with offset=",myoffset
    status = HE5_SWwrfld(swid, GEO_FIELD1, start, stride, edge, &
a1053 1
    !print*,"wrote latitude, maybe"
d1059 1
a1059 1
    status = HE5_SWwrfld(swid, GEO_FIELD2, start, stride, edge, &
d1066 1
a1066 1
    status = HE5_SWwrfld(swid, GEO_FIELD3, start, stride, edge, &
d1073 2
a1074 5

    !print*,"writing ", REAL(l2gp%solarZenith)," as SZA"
    status = HE5_SWwrfld(swid, GEO_FIELD5, start, stride, edge, &
         real(l2gp%solarZenith))
    !print*,"just wrote ", REAL(l2gp%solarZenith)," as SZA"
d1076 1
a1076 1
       msr = WR_ERR // GEO_FIELD5
d1080 2
a1081 2
    status = HE5_SWwrfld(swid, GEO_FIELD4, start, stride, edge, &
        real(l2gp%solarTime))
d1083 1
a1083 1
       msr = WR_ERR // GEO_FIELD4
d1087 1
a1087 2

    status = HE5_SWwrfld(swid, GEO_FIELD6, start, stride, edge, &
d1094 1
a1094 1
    status = HE5_SWwrfld(swid, GEO_FIELD7, start, stride, edge, &
d1101 1
a1101 1
    status = HE5_SWwrfld(swid, GEO_FIELD8, start, stride, edge, &
d1110 1
a1110 2
       start(1)=0 ! needed because offset may have made this /=0
       status = HE5_SWwrfld(swid, GEO_FIELD9, start, stride, edge, &
a1119 1
       start(1)=0 ! needed because offset may have made this /=0
d1121 1
a1121 1
       status = HE5_SWwrfld(swid, GEO_FIELD10, start, stride, edge, &
d1131 2
a1132 2
    status = HE5_SWdetach(swid)
    !print*,"Detatched from swath -- error=",status
d1139 1
a1139 1
  end subroutine OutputL2GP_writeGeo_hdf5
d1142 2
a1143 2
  !----------------------------------------  OutputL2GP_writeData_hdf5  -----
  subroutine OutputL2GP_writeData_hdf5(l2gp, l2FileHandle, swathName,offset)
d1147 1
a1147 2
    ! For now, you have to write all of l2gp, but you can choose to write
    ! it at some offset into the file
d1150 1
a1150 1
    type( L2GPData_T ), intent(inout) :: l2gp
d1152 2
a1153 2
    character (len=*), intent(IN), optional :: swathName ! Defaults->l2gp%name
    integer,intent(IN),optional::offset
d1163 1
a1163 1
    integer :: status,myOffset
d1166 1
a1166 1
    
d1174 1
a1174 8
    ! Begin
    if (present(offset)) then
       myOffset=offset
    else
       myOffset=0
    endif

    if (present(swathName)) then
d1178 1
a1178 3
    endif

    !print*,"OutputL2GP_writeData -- name=",name
a1182 1
    start(3)= myOffset
d1186 1
a1186 2
    swid = HE5_SWattach (l2FileHandle, name)
    !print*," attached swath with swid=",swid," filehandle=",l2FileHandle
a1187 1
       !print*,"Writing 3D field"
d1189 3
a1191 2
       status = HE5_SWwrfld(swid, DATA_FIELD1, start, stride, edge, &
            & reshape(l2gp%l2gpValue, (/size(l2gp%l2gpValue)/)) )
d1196 2
a1197 2
       status = HE5_SWwrfld(swid, DATA_FIELD2, start, stride, edge, &
            & reshape(real(l2gp%l2gpPrecision), (/size(l2gp%l2gpPrecision)/)) )
a1203 1
       !Print*,"Writing 2-d field"
d1205 4
a1208 5
     ! print*,"About to write data with offset=",myOffset
      
       status = HE5_SWwrfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpValue(1,:,:) ))
       !print*,"Status of write was ",status
d1213 1
a1213 1
       status = HE5_SWwrfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
d1222 1
a1222 2
       !Print*,"Writing 1-D field"
       status = HE5_SWwrfld( swid, DATA_FIELD1, start(3:3), stride(3:3), edge(3:3), &
d1228 1
a1228 1
       status = HE5_SWwrfld( swid, DATA_FIELD2, start(3:3), stride(3:3), edge(3:3), &
a1237 2
    !HDF-EOS5 won't write a dataset of chars from FORTRAN

d1241 1
a1241 1
      status = HE5_swwrfld(swid,DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
d1248 3
a1250 7
    else
      !    status = HE5_SWwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3),&
      !        edge(3:3), l2gp%status) ! 
      status=0
      call MLSMessage(MLSMSG_Debug, ModuleName, &
        "writing of status field disabled")

d1255 1
a1255 1
    end if
d1257 1
a1257 2
    !                   ! Beats me. Evil bug gnomes, probably. HCP 
    status = HE5_SWwrfld(swid, DATA_FIELD4, start(3:3), stride(3:3), edge(3:3), &
d1266 1
a1266 2
    status = HE5_SWdetach(swid)
    !print*,"Detatched from swath -- error=",status
a1271 1

d1273 1
a1273 1
  end subroutine OutputL2GP_writeData_hdf5
d1279 1
a1279 1
  ! Should be renamed CreateAndWriteL2GPData
d1284 3
a1286 3
    integer, intent(IN) :: l2FileHandle ! From swopen
    type (L2GPData_T), intent(INOUT) :: l2gp
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
a1287 1
    ! Exectuable code
d1307 2
a1308 3
      call OutputL2GP_createFile_hdf5 (l2gp, l2FileHandle, swathName)
      call OutputL2GP_writeGeo_hdf5 (l2gp, l2FileHandle, swathName)
      call OutputL2GP_writeData_hdf5 (l2gp, l2FileHandle, swathName)
a1311 37
  !-------------------------------------------------------------


  subroutine AppendL2GPData(l2gp,l2FileHandle,swathName,offset, hdfVersion)
    ! sticks l2gp into the swath swathName in the file pointed at by
    ! l2FileHandle,starting at the profile number "offset" (First profile
    ! in the file has offset==0). If this runs off the end of the swath, 
    ! it is lengthend automagically. 
    ! Arguments

    integer, intent(IN) :: l2FileHandle ! From swopen
    type (L2GPData_T), intent(INOUT) :: l2gp
    character (LEN=*), optional, intent(IN) ::swathName!default->l2gp%swathName
    integer,intent(IN),optional::offset
    integer, optional, intent(in) :: hdfVersion
    ! Local
    integer :: myhdfVersion

    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = L2GPDEFAULT_HDFVERSION
    endif

    if (myhdfVersion == HDFVERSION_4) then
      call OutputL2GP_writeGeo_hdf4 (l2gp, l2FileHandle, swathName, offset)
      call OutputL2GP_writeData_hdf4 (l2gp, l2FileHandle, swathName, offset)
    elseif (myhdfVersion /= HDFVERSION_5) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unrecognized hdfVersion passed to AppendL2GPData" )
    else
      call OutputL2GP_writeGeo_hdf5 (l2gp, l2FileHandle, swathName, offset)
      call OutputL2GP_writeData_hdf5 (l2gp, l2FileHandle, swathName, offset)
    endif

  end subroutine AppendL2GPData
d1315 1
a1315 1
  subroutine DUMP_L2GP_DATABASE ( L2gp, Name, ColumnsOnly, Details )
d1339 1
a1339 1
  end subroutine DUMP_L2GP_DATABASE
a1342 1

a1424 1

d1431 20
a1450 4
! Revision 1.19  2002/06/10 12:00:43  hcp
! Removed use hdf5_params as hdf-eos5 now has an include file with the
! parameters you need ready-defined. References to various types changed
! to be consistent with that.
d1452 2
a1453 2
! Revision 1.18  2002/05/01 13:05:53  hcp
! Changed a warning to a debug so I didn't have to see it
d1455 2
a1456 2
! Revision 1.17  2002/05/01 09:28:10  hcp
! Some print statements commented
d1458 26
a1483 2
! Revision 1.16  2002/03/15 23:02:29  pwagner
! Gets HDFVERSION_4 and 5 from MLSFiles; checks for illegal hdfversions
d1485 2
a1486 2
! Revision 1.15  2002/02/01 21:32:34  pwagner
! offset treated properly for appendl2gp for hdf4; untested
d1488 2
a1489 2
! Revision 1.14  2002/01/29 23:47:21  pwagner
! Repaired bugs relating to hdf4 compatibility
d1491 2
a1492 2
! Revision 1.13  2002/01/29 00:48:43  pwagner
! Now should handle both hdfVersions; not tested yet
d1494 2
a1495 2
! Revision 1.12  2002/01/26 00:18:05  pwagner
! (Read)(Write)L2GPData accepts optional hdfVersion arg
d1497 2
a1498 2
! Revision 1.11  2001/11/29 10:07:13  pumphrey
! L2GPData (HDF-EOS5 version) brought up to date with HDF-EOS4 version
d1500 2
a1501 4
! Revision 1.10  2001/11/28 17:46:28  pumphrey
! In the middle of syncing up l2gpdata with HDF4 version in lib.
! Compiles, but not tested. Hack to write char swaths cut-n-pasted but not
! examined for sanity
d1503 2
a1504 2
! Revision 1.9  2001/11/28 16:17:16  pumphrey
! Syncing prior to major re-sync with HDF4 version.
d1506 2
a1507 3
! Revision 1.8  2001/07/31 11:26:19  archie
! Corrected case for ChunkNumber
! .
d1509 2
a1510 2
! Revision 1.7  2001/07/11 19:01:16  pumphrey
! quality->Quality, status->Status.
d1512 2
a1513 3
! Revision 1.6  2001/04/27 07:48:54  pumphrey
! Many nested loops in l3ascii replaced with array ops. Small fixes
! (e.g. spelling mistakes) in other modules.
d1515 2
a1516 2
! Revision 1.5  2001/04/06 20:16:38  pumphrey
! Not much, just keeping in sync
d1518 2
a1519 3
! Revision 1.4  2001/03/29 17:33:27  pumphrey
! Huge changes to L2GPData to sync with the HDF4 version and add unlimited
! dimension along the track
d1521 2
a1522 2
! Revision 1.3  2001/03/20 14:00:30  pumphrey
! fixing inconsistencies -- nothing important
d1524 2
a1525 3
! Revision 1.2  2001/02/23 13:33:14  pumphrey
! Fixed type definition for L2GPData_T so all the pointers are => NULL()
! This error was detected by nagf95 on Solaris but not on Linux. Odd.
d1527 2
a1528 2
! Revision 1.1  2000/12/22 15:55:53  pumphrey
! Initial commit of HDF-EOS5 versions of L2GP interface.
@


2.41
log
@Plug memory leaks, cosmetic changes
@
text
@d6 1
a6 2
  !=============================================================================

d10 1
d13 2
d18 1
a18 1
       & MLSMSG_Error, MLSMSG_Warning
d23 1
a23 1
 
d30 3
a32 5
    & Dump, ExpandL2GPDataInPlace,  &
    & ReadL2GPData, SetupNewL2GPRecord,  WriteL2GPData !, &
!    & OutputL2GP_createFile, OutputL2GP_writeData,  OutputL2GP_writeGeo
!  INTEGER :: SWRDFLD
!  EXTERNAL SWRDFLD !Should USE SWAPI
d34 3
a36 4
  character(len=*), private, parameter :: IdParm = &
    & "$Id: L2GPData.f90,v 2.40 2002/03/15 23:02:49 pwagner Exp $"
  character(len=len(idparm)), private :: Id = idParm
  character(len=*), private, parameter :: ModuleName = &
d40 1
a40 1
  interface DUMP
a44 9
  ! ((( Not yet ready for hdfeos5 versions of files )))
  !       The latter will incorporate the
  !       routines rewritten by H. Pumphrey in he5lib
  !       Perhaps in non-public retitled subroutines:
  !       ReadL2GPData_hdf5
  !       OutputL2GP_createFile_hdf5
  !       OutputL2GP_writeGeo_hdf5
  !       OutputL2GP_writeData_hdf5

d47 17
d73 29
a101 19
  character (len=*), parameter :: DATA_FIELD1 = 'L2gpValue'
  character (len=*), parameter :: DATA_FIELD2 = 'L2gpPrecision'
  character (len=*), parameter :: DATA_FIELD3 = 'Status'
  character (len=*), parameter :: DATA_FIELD4 = 'Quality'

  character (len=*), parameter :: GEO_FIELD1 = 'Latitude'
  character (len=*), parameter :: GEO_FIELD2 = 'Longitude'
  character (len=*), parameter :: GEO_FIELD3 = 'Time'
  character (len=*), parameter :: GEO_FIELD4 = 'LocalSolarTime'
  character (len=*), parameter :: GEO_FIELD5 = 'SolarZenithAngle'
  character (len=*), parameter :: GEO_FIELD6 = 'LineOfSightAngle'
  character (len=*), parameter :: GEO_FIELD7 = 'OrbitGeodeticAngle'
  character (len=*), parameter :: GEO_FIELD8 = 'ChunkNumber'
  character (len=*), parameter :: GEO_FIELD9 = 'Pressure'
  character (len=*), parameter :: GEO_FIELD10= 'Frequency'

  character (len=*), parameter :: DIM_NAME1 = 'nTimes'
  character (len=*), parameter :: DIM_NAME2 = 'nLevels'
  character (len=*), parameter :: DIM_NAME3 = 'nFreqs'
d103 1
a103 2
  character (len=*), parameter :: DIM_NAME12 = 'nLevels,nTimes' ! In Fortran order?!!
  character (len=*), parameter :: DIM_NAME123 = 'nFreqs,nLevels,nTimes' ! as above
d105 2
a106 2
  integer, parameter :: HDFE_AUTOMERGE = 1     ! MERGE FIELDS WITH SHARE DIM
  integer, parameter :: HDFE_NOMERGE = 0       ! don't merge
a113 1
  
a122 1

d127 1
a127 1
     character (len=l2gpnamelen) :: name ! Typically the swath name.
d133 1
a133 1
     integer :: nLevels         ! Total number of surfaces (=1 for column abundances)
d138 1
a138 1
     real (r8), pointer, dimension(:) :: pressures => NULL() ! Vertical coords (nLevels)
d149 1
a149 1
     integer, pointer, dimension(:) :: chunkNumber => NULL()
d153 1
a153 1
     real (r8), pointer, dimension(:) :: frequency => NULL()
d158 2
a159 2
     real (r8), pointer, dimension(:,:,:) :: l2gpValue => NULL()
     real (r8), pointer, dimension(:,:,:) :: l2gpPrecision => NULL()
d162 3
a164 2
     character (len=1), pointer, dimension(:) :: status => NULL()
     real (r8), pointer, dimension(:) :: quality => NULL()
d177 1
a177 1
    type (L2GPData_T), intent(inout)  :: l2gp
d185 1
a185 1
    if ( present(nFreqs) ) then
d189 1
a189 1
    end if
d191 1
a191 1
    if ( present(nLevels) ) then
d195 1
a195 1
    end if
d197 1
a197 1
    if ( present(nTimes) ) then
d201 1
a201 1
    end if
d210 4
a213 4
 
    useNTimes=MAX(useNTimes,1)
    useNLevels=MAX(useNLevels,1)
    useNFreqs=MAX(useNFreqs,1)    
d257 15
a271 14
    call deallocate_test ( l2gp%pressures,     "l2gp%pressures",     ModuleName )
    call deallocate_test ( l2gp%latitude,      "l2gp%latitude",      ModuleName )
    call deallocate_test ( l2gp%longitude,     "l2gp%longitude",     ModuleName )
    call deallocate_test ( l2gp%solarTime,     "l2gp%solarTime",     ModuleName )
    call deallocate_test ( l2gp%solarZenith,   "l2gp%solarZenith",   ModuleName )
    call deallocate_test ( l2gp%losAngle,      "l2gp%losAngle",      ModuleName )
    call deallocate_test ( l2gp%geodAngle,     "l2gp%geodAngle",     ModuleName )
    call deallocate_test ( l2gp%chunkNumber,   "l2gp%chunkNumber",   ModuleName )
    call deallocate_test ( l2gp%time,          "l2gp%time",          ModuleName )
    call deallocate_test ( l2gp%frequency,     "l2gp%frequency",     ModuleName )
    call deallocate_test ( l2gp%l2gpValue,     "l2gp%l2gpValue",     ModuleName )
    call deallocate_test ( l2gp%l2gpPrecision, "l2gp%l2gpPrecision", ModuleName )
    call deallocate_test ( l2gp%status,        "l2gp%status",        ModuleName )
    call deallocate_test ( l2gp%quality,       "l2gp%quality",       ModuleName )
a274 1

d280 2
a281 3
    ! This subroutine expands an L2GPData_T in place allowing the user to 
    ! (1) add more profiles to it; or
    ! 
d285 1
a285 1
    integer, optional, intent(in)    :: newNTimes
a289 1

d301 2
a302 2
    if ( myNTimes<l2gp%nTimes ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
a303 1
    endif
d316 1
a316 1
      & nTimes=myNTimes )
d337 1
a337 1
    
d339 1
a339 1
    call DestroyL2GPContents ( templ2gp )
d355 1
a355 1
    type (l2GPData_T), dimension(:), pointer :: tempDatabase
d365 1
a365 1
  ! This subroutine destroys a quantity template database
d370 1
a370 1
    type (l2GPData_T), dimension(:), pointer :: DATABASE
d375 2
a376 2
    if ( associated(database) ) then
       do l2gpIndex = 1, SIZE(database)
d397 1
a397 1
    character (len=*), intent(in) :: SwathName ! Name of swath
d399 4
a402 4
    integer, intent(in), optional :: FirstProf, LastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: L2gp ! Result
    integer, intent(out), optional :: NumProfs ! Number actually read
    integer, optional, intent(in) :: HDFVersion
a407 4
!   Don't do the following, as callers put the result into a database using
!   a shallow copy.  Destroying the argument will destroy a database item.    
!   call destroyL2GPContents ( l2gp ) ! Avoid memory leaks

d421 4
a424 2
       call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'This version of L2GPData not yet ready for hdf5' )
d441 1
a441 1
    character (len=*), intent(in) :: SwathName ! Name of swath
d443 3
a445 3
    integer, intent(in), optional :: FirstProf, LastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: L2gp ! Result
    integer, intent(out), optional :: NumProfs ! Number actually read
d457 1
a470 4
!   Don't do the following, as callers put the result into a database using
!   a shallow copy.  Destroying the argument will destroy a database item.    
!   call destroyL2GPContents ( l2gp ) ! Avoid memory leaks

d799 5
a803 2
  ! --------------------------------------  OutputL2GP_createFile_hdf4  -----
  subroutine OutputL2GP_createFile_hdf4 (l2gp, L2FileHandle, swathName)
d805 2
a806 2
    ! Brief description of subroutine
    ! This subroutine sets up the structural definitions in an empty L2GP file.
d810 5
a814 3
    integer, intent(in) :: L2FileHandle ! From swopen
    type( l2GPData_T ), intent(inout) :: l2gp
    character (len=*), optional, intent(in) :: swathName ! Defaults to l2gp%swathName
d816 9
a824 1
    ! Parameters
d826 4
a829 4
    character (len=*), parameter :: DIM_ERR = 'Failed to define dimension '
    character (len=*), parameter :: GEO_ERR = &
         & 'failed to define geolocation field '
    character (len=*), parameter :: DAT_ERR = 'Failed to define data field '
d831 7
a837 1
    ! Variables
d839 1
a839 2
    character (len=480) :: MSR
    character (len=132) :: NAME   ! From l2gp%name
d841 5
a845 1
    integer :: SWID, STATUS
d847 1
a847 5
    if ( present(swathName) ) then
       name=swathName
    else
       name=l2gp%name
    end if
d849 2
a850 1
    ! Create the swath within the file
d852 5
a856 6
    swid = swcreate(L2FileHandle, TRIM(name))
    if ( swid == -1 ) then
       msr = 'Failed to create swath ' // TRIM(name) &
        & // ' (maybe has the same name as another swath in this file?)'
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d858 16
a873 1
    ! Define dimensions
d875 1
a875 5
    status = swdefdim(swid, DIM_NAME1, l2gp%nTimes)
    if ( status == -1 ) then
       msr = DIM_ERR // DIM_NAME1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d877 10
a886 7
    if ( l2gp%nLevels > 0 ) then
       status = swdefdim(swid, DIM_NAME2, l2gp%nLevels)
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME2
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if
d888 1
a888 7
    if ( l2gp%nFreqs > 1 ) then
       status = swdefdim(swid, DIM_NAME3, l2gp%nFreqs)
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME3
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if
d890 2
a891 1
    ! Define horizontal geolocation fields using above dimensions
d893 1
a893 6
    status = swdefgfld(swid, GEO_FIELD1, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD1
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d895 6
a900 6
    status = swdefgfld(swid, GEO_FIELD2, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD2
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d902 1
a902 6
    status = swdefgfld(swid, GEO_FIELD3, DIM_NAME1, DFNT_FLOAT64, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d904 1
a904 6
    status = swdefgfld(swid, GEO_FIELD4, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD4
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d906 1
a906 6
    status = swdefgfld(swid, GEO_FIELD5, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d908 1
a908 6
    status = swdefgfld(swid, GEO_FIELD6, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d910 4
a913 6
    status = swdefgfld(swid, GEO_FIELD7, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d915 5
a919 6
    status = swdefgfld(swid, GEO_FIELD8, DIM_NAME1, DFNT_INT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = GEO_ERR // GEO_FIELD8
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d921 1
a921 8
    if ( l2gp%nLevels > 0 ) then
       status = swdefgfld(swid, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, &
            HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD9
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if
d923 1
a923 8
    if ( l2gp%nFreqs > 0 ) then
       status = swdefgfld(swid, GEO_FIELD10, DIM_NAME3, DFNT_FLOAT32, &
            HDFE_NOMERGE)
       if ( status == -1 ) then
          msr = GEO_ERR // GEO_FIELD10
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
    end if
d925 1
a925 1
    ! Define data fields using above dimensions
d927 1
a927 1
    if ( (l2gp%nFreqs > 0) .AND. (l2gp%nLevels > 0) ) then
d929 2
a930 2
       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME123, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d932 1
a932 4
       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d934 8
d943 1
a943 2
       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME123, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d945 8
a952 4
       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD2 // ' for 3D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d954 7
d962 7
a968 1
    else if ( l2gp%nLevels > 0 ) then
d970 6
a975 2
       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME12, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d977 7
a983 4
       if ( status == -1 ) then
          msr = DAT_ERR // DATA_FIELD1 //  ' for 2D quantity.'
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
d985 927
a1911 2
       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME12, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d1919 6
a1924 3

       status = swdefdfld(swid, DATA_FIELD1, DIM_NAME1, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d1931 2
a1932 2
       status = swdefdfld(swid, DATA_FIELD2, DIM_NAME1, DFNT_FLOAT32, &
            HDFE_NOMERGE)
d1941 14
a1954 6
    status = swdefdfld(swid, DATA_FIELD3, DIM_NAME1, DFNT_CHAR8, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = DAT_ERR // DATA_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1956 2
a1957 2
    status = swdefdfld(swid, DATA_FIELD4, DIM_NAME1, DFNT_FLOAT32, &
         HDFE_NOMERGE)
d1963 1
a1963 1
    ! Detach from the swath interface.  This stores the swath info within the
d1965 3
a1967 3
    ! swath.

    status = swdetach(swid)
d1974 1
a1974 1
  end subroutine OutputL2GP_createFile_hdf4
d1977 2
a1978 2
  !-----------------------------------------  OutputL2GP_writeGeo_hdf4  -----
  subroutine OutputL2GP_writeGeo_hdf4 (l2gp, l2FileHandle, swathName)
d1985 1
a1985 1
    type( l2GPData_T ), intent(inout) :: l2gp
d1987 2
a1988 2
    character (len=*), intent(in), optional :: swathName ! Defaults to l2gp%name

d1993 1
a1993 1

d1998 3
d2002 6
a2007 2
    integer :: status, swid
    integer :: start(2), stride(2), edge(2)
d2009 1
a2009 1
    if ( present(swathName) ) then
d2013 1
a2013 1
    end if
d2015 1
a2015 1
    swid = swattach (l2FileHandle, name)
d2019 2
a2020 2
    stride(1) = 1
    start(1) = 0
d2022 3
a2024 2

    status = swwrfld(swid, GEO_FIELD1, start, stride, edge, &
d2026 1
d2032 1
a2032 1
    status = swwrfld(swid, GEO_FIELD2, start, stride, edge, &
d2039 1
a2039 1
    status = swwrfld(swid, GEO_FIELD3, start, stride, edge, &
d2046 5
a2050 2
    status = swwrfld(swid, GEO_FIELD4, start, stride, edge, &
        real(l2gp%solarTime))
d2052 1
a2052 1
       msr = WR_ERR // GEO_FIELD4
d2056 2
a2057 2
    status = swwrfld(swid, GEO_FIELD5, start, stride, edge, &
         real(l2gp%solarZenith))
d2059 1
a2059 1
       msr = WR_ERR // GEO_FIELD5
d2063 2
a2064 1
    status = swwrfld(swid, GEO_FIELD6, start, stride, edge, &
d2071 1
a2071 1
    status = swwrfld(swid, GEO_FIELD7, start, stride, edge, &
d2078 1
a2078 1
    status = swwrfld(swid, GEO_FIELD8, start, stride, edge, &
d2087 2
a2088 1
       status = swwrfld(swid, GEO_FIELD9, start, stride, edge, &
d2098 1
d2100 1
a2100 1
       status = swwrfld(swid, GEO_FIELD10, start, stride, edge, &
d2110 2
a2111 2
    status = swdetach(swid)

d2118 1
a2118 1
  end subroutine OutputL2GP_writeGeo_hdf4
d2121 2
a2122 2
  !----------------------------------------  OutputL2GP_writeData_hdf4  -----
  subroutine OutputL2GP_writeData_hdf4(l2gp, l2FileHandle, swathName)
d2126 2
a2127 1

d2130 1
a2130 1
    type( l2GPData_T ), intent(inout) :: l2gp
d2132 2
a2133 2
    character (len=*), intent(in), optional :: swathName ! Defaults to l2gp%name

d2143 1
a2143 1
    integer :: status
d2146 1
a2146 1

d2154 8
a2161 1
    if ( present(swathName) ) then
d2165 3
a2167 1
    end if
d2172 1
d2176 2
a2177 1
    swid = swattach (l2FileHandle, name)
d2179 1
d2181 2
a2182 3

       status = swwrfld(swid, DATA_FIELD1, start, stride, edge, &
            & RESHAPE(l2gp%l2gpValue, (/SIZE(l2gp%l2gpValue)/)) )
d2187 2
a2188 2
       status = swwrfld(swid, DATA_FIELD2, start, stride, edge, &
            & RESHAPE(real(l2gp%l2gpPrecision), (/SIZE(l2gp%l2gpPrecision)/)) )
d2195 1
d2197 5
a2201 4

       status = swwrfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
            edge(2:3), real(l2gp%l2gpValue(1,:,:)) )

d2206 1
a2206 1
       status = swwrfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
d2215 2
a2216 1
       status = swwrfld( swid, DATA_FIELD1, start(3:3), stride(3:3), edge(3:3), &
d2222 1
a2222 1
       status = swwrfld( swid, DATA_FIELD2, start(3:3), stride(3:3), edge(3:3), &
d2232 2
d2237 1
a2237 1
      status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
d2244 7
a2250 3
   else
      status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
           l2gp%status)
d2255 1
a2255 1
   end if
d2257 2
a2258 1
    status = swwrfld(swid, DATA_FIELD4, start(3:3), stride(3:3), edge(3:3), &
d2267 2
a2268 1
    status = swdetach(swid)
d2274 1
d2276 1
a2276 1
  end subroutine OutputL2GP_writeData_hdf4
d2282 1
a2282 1

d2287 3
a2289 3
    integer, intent(in) :: l2FileHandle ! From swopen
    type (l2GPData_T), intent(inout) :: l2gp
    character (len=*), optional, intent(in) :: swathName ! (defaults to l2gp%swathName)
d2291 1
d2311 3
a2313 2
       call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'This version of L2GPData not yet ready for hdf5' )
d2317 37
d2357 1
a2357 1
  subroutine Dump_L2GP_DATABASE ( L2gp, Name, ColumnsOnly, Details )
d2381 1
a2381 1
  end subroutine Dump_L2GP_DATABASE
d2385 1
d2468 1
d2475 4
a2478 2
! Revision 2.40  2002/03/15 23:02:49  pwagner
! Gets HDFVERSION_4 and 5 from MLSFiles; checks for illegal hdfversions
d2480 2
a2481 2
! Revision 2.39  2002/01/23 21:47:12  pwagner
! Begun to make hdf5-capable; not yet, though
d2483 2
a2484 2
! Revision 2.38  2001/10/26 23:13:18  pwagner
! Provides a single dump module interface and details
d2486 2
a2487 44
! Revision 2.37  2001/09/05 22:57:16  pwagner
! Removed Columns from L2GPData_T
!
! Revision 2.36  2001/08/16 23:17:42  vsnyder
! Remove continuation ampersands within two lines
!
! Revision 2.35  2001/08/06 18:39:03  pwagner
! Now dumps column-related components, too
!
! Revision 2.34  2001/08/03 23:13:52  pwagner
! Began testing; at least now exits normally again
!
! Revision 2.33  2001/08/03 00:02:26  pwagner
! Ncolumns now a component of data type; swapi via ints not strings
!
! Revision 2.32  2001/08/02 00:17:56  pwagner
! Added column components; untested
!
! Revision 2.31  2001/06/13 20:36:15  vsnyder
! Commented out reading l2gp%status.  It appears that reading characters from
! HDF can't be made to work, due to fundamental design flaws in HDF.
!
! Revision 2.30  2001/06/06 17:28:13  pwagner
! the_status_buffer allows reading l2gp%status
!
! Revision 2.29  2001/05/03 23:59:56  vsnyder
! Trying to find out why realProf is undefined
!
! Revision 2.28  2001/04/24 16:28:41  livesey
! Cosmetic changes only, except comment out dubious l2gp%quality = 0 statement.
!
! Revision 2.27  2001/04/20 03:00:59  livesey
! Made L2GPNameLen public
!
! Revision 2.26  2001/04/20 02:05:09  vsnyder
! Cosmetic changes: Default visibility is now private
!
! Revision 2.25  2001/03/20 01:44:25  livesey
! Fixed bug, was outputting chunkNumber as real!
!
! Revision 2.24  2001/03/12 20:25:04  vsnyder
! Improve dump_l2gp.  Nullify components of l2gp before calling
! SetupNewL2GPRecord from ExpandL2GPDataInPlace, so as not to clobber the
! component pointers carefully copied to tempL2gp.
d2489 2
a2490 2
! Revision 2.23  2001/03/01 18:37:51  livesey
! Added dumper routine
d2492 2
a2493 2
! Revision 2.22  2001/02/22 21:54:22  livesey
! Added initialisation to NULL() for pointer components of L2GPData_T
d2495 2
a2496 2
! Revision 2.21  2001/02/15 18:23:20  livesey
! Got it right this time!
d2498 2
a2499 2
! Revision 2.20  2001/02/15 18:20:15  livesey
! Had to comment out reading of status in ReadL2GPData to make it work, logged PR.
d2501 2
a2502 2
! Revision 2.19  2001/02/14 23:39:40  livesey
! Made numProfs argument optional(intent out) for ReadL2GPData
d2504 4
a2507 2
! Revision 2.18  2001/02/13 00:55:35  livesey
! Removed another print statement!
d2509 2
a2510 2
! Revision 2.17  2001/02/13 00:51:31  livesey
! Fixed bug, copy pressure information in ExpandL2GPDataInPlace
d2512 3
a2514 2
! Revision 2.16  2001/02/09 18:38:04  livesey
! Even more print statemets removed!
d2516 2
a2517 2
! Revision 2.15  2001/02/09 17:51:01  livesey
! Removed some print statements.
d2519 3
a2521 2
! Revision 2.14  2001/02/09 17:45:15  livesey
! Another fix to dimension ordering.
d2523 2
a2524 2
! Revision 2.13  2001/02/08 01:06:08  livesey
! Bug fix in ExpandL2GPDataInPlace
d2526 3
a2528 2
! Revision 2.12  2001/02/05 23:58:22  pwagner
! Uses swrdfld from swapi
d2530 2
a2531 2
! Revision 2.11  2001/02/03 00:04:26  pwagner
! Uncommented EXTERNAL SWRDFLD until swapi done
d2533 3
a2535 2
! Revision 2.10  2001/02/02 17:15:02  livesey
! Changed order of DIM_NAME12 and DIM_NAME123, this should be right now!
d2537 2
a2538 2
! Revision 2.9  2001/01/29 18:17:49  livesey
! Changed status, quality and frequency to upper case first character.
@


2.40
log
@Gets HDFVERSION_4 and 5 from MLSFiles; checks for illegal hdfversions
@
text
@d35 1
a35 1
    & "$Id: L2GPData.f90,v 2.39 2002/01/23 21:47:12 pwagner Exp $"
d242 14
a255 14
    call deallocate_test ( l2gp%pressures,         "l2gp%pressures",         ModuleName )
    call deallocate_test ( l2gp%latitude,          "l2gp%latitude",          ModuleName )
    call deallocate_test ( l2gp%longitude,         "l2gp%longitude",         ModuleName )
    call deallocate_test ( l2gp%solarTime,         "l2gp%solarTime",         ModuleName )
    call deallocate_test ( l2gp%solarZenith,       "l2gp%solarZenith",       ModuleName )
    call deallocate_test ( l2gp%losAngle,          "l2gp%losAngle",          ModuleName )
    call deallocate_test ( l2gp%geodAngle,         "l2gp%geodAngle",         ModuleName )
    call deallocate_test ( l2gp%chunkNumber,       "l2gp%chunkNumber",       ModuleName )
    call deallocate_test ( l2gp%time,              "l2gp%time",              ModuleName )
    call deallocate_test ( l2gp%frequency,         "l2gp%frequency",         ModuleName )
    call deallocate_test ( l2gp%l2gpValue,         "l2gp%l2gpValue",         ModuleName )
    call deallocate_test ( l2gp%l2gpPrecision,     "l2gp%l2gpPrecision",     ModuleName )
    call deallocate_test ( l2gp%status,            "l2gp%status",            ModuleName )
    call deallocate_test ( l2gp%quality,           "l2gp%quality",           ModuleName )
d327 1
a327 1
    call DestroyL2GPContents(templ2gp)
d385 1
a385 1
    character (len=*), intent(in) :: swathname ! Name of swath
d387 4
a390 4
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: l2gp ! Result
    integer, intent(out), optional :: numProfs ! Number actually read
    integer, optional, intent(in) :: hdfVersion
d396 4
d431 1
a431 1
    character (len=*), intent(in) :: swathname ! Name of swath
d433 3
a435 3
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( l2GPData_T ), intent(out) :: l2gp ! Result
    integer, intent(out), optional :: numProfs ! Number actually read
d460 4
d1439 3
@


2.39
log
@Begun to make hdf5-capable; not yet, though
@
text
@d10 5
a16 1
  use MLSCommon, only: R8
a17 3
  use Hdf, only: DFNT_CHAR8, DFNT_FLOAT32, DFNT_INT32, DFNT_FLOAT64
  use HDFEOS!, only: SWATTACH, SWCREATE, SWDEFDFLD, SWDEFDIM, SWDEFGFLD, &
     !& SWDETACH
d19 1
a20 1
  use STRING_TABLE, only: DISPLAY_STRING
d35 1
a35 1
    & "$Id: L2GPData.f90,v 2.38 2001/10/26 23:13:18 pwagner Exp $"
d62 1
a62 1
  integer, parameter :: L2GPDEFAULT_HDFVERSION = 4            
d109 1
a109 1
  typE L2GPData_T
a167 1
    integer :: freqsArrayLen, status, surfsArrayLen
a238 3
    ! Local variables

    integer status
a273 1
    integer :: status                   ! From ALLOCATE
d275 1
a275 1
    integer :: myNTimes, myNColms
d402 1
a402 1
    if (myhdfVersion == 4) then
d405 3
a442 1

a445 3
    integer :: nColumns
    integer :: col_start(2), col_stride(2), col_edge(2)

d820 2
a821 1
       msr = 'Failed to create swath ' // TRIM(name)
d1299 1
a1299 1
    if (myhdfVersion == 4) then
d1303 3
d1355 1
a1355 1
    integer :: i, ierr
d1431 3
@


2.38
log
@Provides a single dump module interface and details
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d28 2
a29 2
    & OutputL2GP_createFile, OutputL2GP_writeData,  OutputL2GP_writeGeo, &
    & ReadL2GPData, SetupNewL2GPRecord,  WriteL2GPData
d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.37 2001/09/05 22:57:16 pwagner Exp $"
d45 8
d59 4
d377 1
a377 1
  ! -------------------------------------------------------------------------
d380 39
d422 2
a423 1
    ! This routine reads an L2GP file, returning a filled data structure and the !
d786 1
a786 1
  end subroutine ReadL2GPData
d789 2
a790 2
  ! --------------------------------------  OutputL2GP_createFile  -----
  subroutine OutputL2GP_createFile (l2gp, L2FileHandle, swathName)
d1014 1
a1014 1
  end subroutine OutputL2GP_createFile
d1017 2
a1018 2
  !-----------------------------------------  OutputL2GP_writeGeo  -----
  subroutine OutputL2GP_writeGeo (l2gp, l2FileHandle, swathName)
d1143 1
a1143 1
  end subroutine OutputL2GP_writeGeo
d1146 2
a1147 2
  !----------------------------------------  OutputL2GP_writeData  -----
  subroutine OutputL2GP_writeData(l2gp, l2FileHandle, swathName)
d1277 1
a1277 1
  end subroutine OutputL2GP_writeData
d1284 1
a1284 1
  subroutine WriteL2GPData(l2gp,l2FileHandle,swathName)
d1291 1
d1293 2
a1294 1
    ! Exectuable code
d1296 15
a1310 3
    call OutputL2GP_createFile (l2gp, l2FileHandle, swathName)
    call OutputL2GP_writeGeo (l2gp, l2FileHandle, swathName)
    call OutputL2GP_writeData (l2gp, l2FileHandle, swathName)
d1432 3
@


2.37
log
@Removed Columns from L2GPData_T
@
text
@d27 3
a29 3
    & Dump, Dump_L2GP,  ExpandL2GPDataInPlace,  OutputL2GP_createFile, &
    & OutputL2GP_writeData,  OutputL2GP_writeGeo,  ReadL2GPData, &
    & SetupNewL2GPRecord,  WriteL2GPData
d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.36 2001/08/16 23:17:42 vsnyder Exp $"
d42 1
d83 3
d1248 1
a1248 1
  ! ------------------------------------------ DUMP_L2GP ------------
d1250 1
a1250 1
  subroutine Dump_L2GP ( L2gp, Name, ColumnsOnly )
d1256 1
d1260 31
d1292 5
d1304 13
a1316 5
    if ( present(name) ) call output ( name, advance='yes' )
    do i = 1, size(l2gp)
      call output ( 'L2GP Data: ')
      if(l2gp(i)%nameIndex > 0) then
        call display_string ( l2gp(i)%nameIndex, advance='yes' )
d1318 1
a1318 1
        call output ( '(the nameIndex is 0) ', advance='yes')
d1320 1
d1322 1
a1322 1
      call output ( l2gp(i)%nTimes, 5)
d1324 1
a1324 1
      call output ( l2gp(i)%nLevels, 3)
d1326 3
a1328 3
      call output ( l2gp(i)%nFreqs, 3, advance='yes')
      if(myColumnsOnly .and. l2gp(i)%nLevels>1) CYCLE
      call dump ( l2gp(i)%pressures, 'Pressures:' )
d1330 1
a1330 1
      call dump ( l2gp(i)%latitude, 'Latitude:' )
d1332 1
a1332 1
      call dump ( l2gp(i)%longitude, 'Longitude:' )
d1334 1
a1334 1
      call dump ( l2gp(i)%solarTime, 'SolarTime:' )
d1336 1
a1336 1
      call dump ( l2gp(i)%solarZenith, 'SolarZenith:' )
d1338 1
a1338 1
      call dump ( l2gp(i)%losAngle, 'LOSAngle:' )
d1340 1
a1340 1
      call dump ( l2gp(i)%geodAngle, 'geodAngle:' )
d1342 1
a1342 1
      call dump ( l2gp(i)%time, 'Time:' )
d1344 1
a1344 1
      call dump ( l2gp(i)%chunkNumber, 'ChunkNumber:' )
d1346 2
a1347 2
      if ( associated(l2gp(i)%frequency) ) &
        & call dump ( l2gp(i)%frequency, 'Frequencies:' )
d1349 2
a1350 1
      call dump ( l2gp(i)%l2gpValue, 'L2GPValue:' )
d1352 1
a1352 1
      call dump ( l2gp(i)%l2gpPrecision, 'L2GPPrecision:' )
d1354 1
a1354 1
      !    call dump ( l2gp(i)%status, 'Status:' )
d1356 1
a1356 1
      call dump ( l2gp(i)%quality, 'Quality:' )
a1357 1
    end do
d1366 3
@


2.36
log
@Remove continuation ampersands within two lines
@
text
@d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.35 2001/08/06 18:39:03 pwagner Exp $"
a55 3
  character (len=*), parameter :: DATA_FIELD5 = 'ColumnTypes'
  character (len=*), parameter :: DATA_FIELD6 = 'ColumnValues'
  character (len=*), parameter :: DATA_FIELD7 = 'PressureBoundary'
a66 1
!  character (len=*), parameter :: GEO_FIELD11= 'PressureBoundary'
a71 3
   ! More precisely, the following is num. of press. boundaries
  character (len=*), parameter :: DIM_NAME4 = 'nColumns'

a73 1
  character (len=*), parameter :: DIM_NAME34 = 'nTimes,nColumns' ! In Fortran order?!!
d83 8
d102 1
a102 1
     integer :: nLevels         ! Total number of surfaces
a103 1
     integer :: nColumns        ! Number of diff. tropopause definitions
d106 1
a134 6
     character (len=L2GPNameLen), pointer, &
     &                     dimension(:) :: columnTypes => NULL()
     real (r8), pointer, dimension(:,:) :: columnValues => NULL()
     real (r8), pointer, dimension(:,:) :: boundaryPressures => NULL()
     ! The above dimensioned ([nTimes],nColumns)

d140 1
a140 1
  subroutine SetupNewL2GPRecord ( l2gp, nFreqs, nLevels, nTimes, nColumns)
a148 1
    integer, intent(in), optional :: nColumns          ! Dimensions
d152 1
a152 1
    integer :: useNFreqs, useNLevels, useNTimes, useNCOLUMNS
a171 6
    if ( present(nColumns) ) then
       useNColumns=nColumns
    else
       useNColumns=0              ! Defaults to no columns
    end if

a176 1
    l2gp%nColumns = useNColumns
a213 4
   ! Leave column* unallocated until they are called for by Join command
   ! When they will be allocated during ExpandL2GPDataInPlace
   ! or else during ReadL2GPData

a246 5
    if(associated(l2gp%columnTypes)) then
    call deallocate_test ( l2gp%columnTypes,       "l2gp%columnTypes",       ModuleName )
    call deallocate_test ( l2gp%columnValues,      "l2gp%columnValues",      ModuleName )
    call deallocate_test ( l2gp%boundaryPressures, "l2gp%boundaryPressures", ModuleName )
    endif
d250 1
a250 1
  subroutine ExpandL2GPDataInPlace ( l2gp, newNTimes, newNColumns )
a253 1
    ! (2) add more columns (or a 1st one)
a258 1
    integer, optional, intent(in)    :: newNColumns
d263 1
a263 1
    integer :: NumColumns, myNTimes, myNColms
a272 6
   if(present(newNColumns)) then
      myNColms = newNColumns
   else
      myNColms = l2gp%nColumns
   endif

a278 3
    elseif ( myNColms<l2gp%nColumns ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
         & "The number of columns requested is fewer than those already present" )
d290 1
a290 2
      & l2gp%l2gpPrecision, l2gp%status, l2gp%quality, &
      & l2gp%columnTypes, l2gp%columnValues, l2gp%boundaryPressures )
d292 1
a292 1
      & nTimes=myNTimes, nColumns=myNColms)
a313 23
    if(associated(templ2gp%columnTypes)) then
      numColumns = size(templ2gp%columnTypes)
    else
      numColumns = 0
    endif
    
    if(myNColms > 0) then
       call allocate_test ( l2gp%columnTypes, myNColms, &
       & "l2gp%columnTypes", ModuleName )
       call allocate_test ( l2gp%columnValues, myNTimes, myNColms, &
       & "l2gp%columnValues", ModuleName )
       call allocate_test ( l2gp%boundaryPressures, myNTimes, myNColms, &
       & "l2gp%boundaryPressures", ModuleName )
    endif

    if(associated(templ2gp%columnTypes)) then
      l2gp%columnTypes(1:numColumns) = templ2gp%columnTypes(1:numColumns)
      l2gp%columnValues(1:templ2gp%nTimes, 1:numColumns) = &
      &              templ2gp%columnValues(1:templ2gp%nTimes, 1:numColumns)
      l2gp%boundaryPressures(1:templ2gp%nTimes, 1:numColumns) = &
      &              templ2gp%boundaryPressures(1:templ2gp%nTimes, 1:numColumns)
    endif

a492 9
   ! Column data
    size = swdiminfo(swid, DIM_NAME4)
    if ( size == -1 ) then
   ! Don't die--you may just have an older l2gp file--pre column-bian
       size = 0
    end if
    l2gp%nColumns = size
    nColumns=size

d495 2
a496 2
    call SetupNewL2GPRecord (l2gp, nFreqs=nFreqs, nLevels=nLevels, &
    & nTimes=myNumProfs, nColumns=nColumns)
a719 67
   ! Column data
   if(nColumns > 0) then
    allocate ( string_buffer(L2GPNameLen,nColumns), &
      &   real3(myNumProfs,nColumns,1), STAT=alloc_err )
    if ( alloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//' column-related things in ReadL2GPData' )

       call allocate_test ( l2gp%columnTypes, nColumns, &
       & "l2gp%columnTypes", ModuleName )
       call allocate_test ( l2gp%columnValues, myNumProfs, nColumns, &
       & "l2gp%columnValues", ModuleName )
       call allocate_test ( l2gp%boundaryPressures, myNumProfs, nColumns, &
       & "l2gp%boundaryPressures", ModuleName )

      ! These are good only for column data
       col_start(1) = first
       col_start(2) = 0
       stride = 1
       col_edge(1) = myNumProfs
       col_edge(2) = nColumns
!       status = swrdfld(swid, DATA_FIELD5, &
!       & col_start(2:2),col_stride(2:2),col_edge(2:2), the_status_buffer)
!    if ( status == -1 ) then
!      msr = MLSMSG_L2GPRead // DATA_FIELD5
!      call MLSMessage ( MLSMSG_Error, ModuleName, msr )
!    end if
!    l2gp%columnTypes = the_status_buffer(:)

   l2gp%columnTypes = ' '   ! So it has some value
   if(USEINTS4STRINGS) then
      ! Need these temporarily
       col_start(1) = 0
       col_edge(1) = L2GPNameLen
       status = swrdfld(swid, DATA_FIELD3, col_start, col_stride, col_edge, &
         string_buffer)
       if ( status == -1 ) then
         msr = MLSMSG_L2GPRead // DATA_FIELD3
         call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       call ints2Strings(string_buffer, l2gp%columnTypes)
       col_start(1) = first
       col_edge(1) = myNumProfs
    end if

      status = swrdfld( swid, DATA_FIELD6, col_start, col_stride, &
        &   col_edge, real3(:,:,1) )
      if ( status == -1 ) then
        msr = MLSMSG_L2GPRead // DATA_FIELD6
        call MLSMessage ( MLSMSG_Error, ModuleName, msr )
      end if
      l2gp%columnValues = real3(:,:,1)
      
       status = swrdfld( swid, DATA_FIELD7, &
       & col_start, col_stride, col_edge, real3(:,:,1) )
       if ( status == -1 ) then
          msr = MLSMSG_L2GPRead // DATA_FIELD1
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       l2gp%boundaryPressures = real3(:,:,1)

    deallocate ( string_buffer, real3, STAT=alloc_err )
!    deallocate ( the_status_buffer, real3, STAT=alloc_err )
    if ( alloc_err /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
         'Failed deallocation of local column-related variables.' )

   endif

a796 10
!     Let's at least define the dimensions anyway
!    if ( associated(l2gp%columnTypes) ) then
       status = swdefdim(swid, DIM_NAME4, l2gp%nColumns)
!       status = swdefdim(swid, DIM_NAME4, size(l2gp%columnTypes))
       if ( status == -1 ) then
          msr = DIM_ERR // DIM_NAME4
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
!    end if

a946 21
    status = swdefdfld(swid, DATA_FIELD5, DIM_NAME4, DFNT_CHAR8, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = DAT_ERR // DATA_FIELD5
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefdfld(swid, DATA_FIELD6, DIM_NAME34, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = DAT_ERR // DATA_FIELD6
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

    status = swdefdfld(swid, DATA_FIELD7, DIM_NAME34, DFNT_FLOAT32, &
         HDFE_NOMERGE)
    if ( status == -1 ) then
       msr = DAT_ERR // DATA_FIELD7
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if

a1110 2
    integer :: col_start(2), col_stride(2), col_edge(2)
    integer :: nColumns
a1211 44
   ! Column data
   if(l2gp%nColumns > 0) then
      ! These are good only for column data
       nColumns = l2gp%nColumns
       col_start(1) = 0
       col_start(2) = 0
       col_stride = 1
       col_edge(1) = l2gp%nTimes
       col_edge(2) = nColumns
       
      if(USEINTS4STRINGS) then
         allocate ( string_buffer(L2GPNameLen,nColumns) )
        ! Need these temporarily
         col_edge(1) = L2GPNameLen
         call strings2Ints(l2gp%columnTypes, string_buffer)
         status = swwrfld(swid, DATA_FIELD5, &
         & col_start, col_stride, col_edge, string_buffer)
         col_edge(1) = l2gp%nTimes
         deallocate(string_buffer)
      else
         status = swwrfld(swid, DATA_FIELD5, &
         & col_start(2:2), col_stride(2:2), col_edge(2:2), l2gp%columnTypes)
      endif
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD5
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       
       status = swwrfld(swid, DATA_FIELD6, &
       & col_start, col_stride, col_edge, l2gp%columnValues)
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD6
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       
       status = swwrfld(swid, DATA_FIELD7, &
       & col_start, col_stride, col_edge, l2gp%boundaryPressures)
       if ( status == -1 ) then
          msr = WR_ERR // DATA_FIELD7
          call MLSMessage ( MLSMSG_Error, ModuleName, msr )
       end if
       
   endif

a1219 1

d1254 1
a1254 1
    integer :: i, Colm
d1277 1
a1277 2
      if(myColumnsOnly .and. l2gp(i)%nColumns==0) CYCLE
      
a1306 10
      if( l2gp(i)%nColumns <= 0 ) CYCLE
      call output ( 'nColumnAbundances: ')
      call output ( l2gp(i)%nColumns, 5, advance='yes')
      do Colm=1, l2gp(i)%nColumns
          call output ( 'Column Type:' )
          call output ( l2gp(i)%columnTypes(Colm), advance='yes' )
          call dump ( l2gp(i)%columnValues(:, Colm), 'Column Values:' )
          call dump ( l2gp(i)%boundaryPressures(:, Colm), 'Tropopause values:' )
      enddo

d1316 3
@


2.35
log
@Now dumps column-related components, too
@
text
@d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.34 2001/08/03 23:13:52 pwagner Exp $"
d357 1
a357 1
       & "l2gp%columnTypes", & ModuleName )
d795 1
a795 1
       & "l2gp%columnTypes", & ModuleName )
d1539 3
@


2.34
log
@Began testing; at least now exits normally again
@
text
@d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.33 2001/08/03 00:02:26 pwagner Exp $"
d1458 1
a1458 1
  subroutine Dump_L2GP ( L2gp, Name )
d1461 3
a1463 2
    type (l2gpData_T), intent(in) :: L2GP(:)
    character(len=*), optional :: Name
d1466 8
a1473 1
    integer :: i
d1478 5
a1482 1
      call display_string ( l2gp(i)%nameIndex, advance='yes' )
d1489 1
d1519 10
a1532 1

d1539 3
@


2.33
log
@Ncolumns now a component of data type; swapi via ints not strings
@
text
@d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.32 2001/08/02 00:17:56 pwagner Exp $"
d931 2
a932 1
    if ( associated(l2gp%columnTypes) ) then
d939 1
a939 1
    end if
d1385 1
a1385 1
       stride = 1
d1517 3
@


2.32
log
@Added column components; untested
@
text
@d13 1
a13 1

d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.31 2001/06/13 20:36:15 vsnyder Exp $"
d85 5
a89 1

d104 1
d146 1
a146 1
  subroutine SetupNewL2GPRecord ( l2gp, nFreqs, nLevels, nTimes)
d152 4
a155 1
    integer, intent(in), optional :: nFreqs, nLevels, nTimes ! Dimensions
d159 1
a159 1
    integer :: useNFreqs, useNLevels, useNTimes
d179 6
d190 1
d273 1
a273 1
  subroutine ExpandL2GPDataInPlace ( l2gp, newNTimes, newColumn )
d277 1
a277 1
    ! (2) add another column (or a 1st one)
d283 1
a283 1
    logical, optional, intent(in)    :: newColumn
a288 1
    logical :: myNewColumn
d298 2
a299 2
   if(present(newColumn)) then
      myNewColumn = newColumn
d301 1
a301 1
      myNewColumn = .false.
d307 2
a308 2
    if ( myNTimes<l2gp%nTimes ) &
         & call MLSMessage ( MLSMSG_Error, ModuleName, &
d310 4
d327 1
a327 1
      & nTimes=myNTimes)
a354 6
    if(myNewColumn) then
      myNColms = numColumns+1
    else
      myNColms = numColumns
    endif
    
d456 6
a461 1
    character (LEN=8), allocatable :: the_status_buffer(:)
d557 1
a557 1
!    l2gp%nColumns = size
d562 2
a563 1
    call SetupNewL2GPRecord (l2gp, nFreqs=nFreqs, nLevels=nLevels, nTimes=myNumProfs)
d570 1
a570 1
      &   the_status_buffer(myNumProfs), &
d755 2
d759 10
d783 1
a783 1
    deallocate ( the_status_buffer, STAT=alloc_err )
d789 1
a789 1
    allocate ( the_status_buffer(nColumns), &
d814 17
d847 2
a848 1
    deallocate ( the_status_buffer, real3, STAT=alloc_err )
d932 2
a933 1
       status = swdefdim(swid, DIM_NAME4, size(l2gp%columnTypes))
d1281 7
d1352 18
a1369 6
    status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
         l2gp%status)  
    if ( status == -1 ) then
       msr = WR_ERR // DATA_FIELD3
       call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
d1379 1
a1379 1
   if(associated(l2gp%columnTypes)) then
d1381 1
a1381 1
       nColumns = size(l2gp%columnTypes)
d1388 13
a1400 2
       status = swwrfld(swid, DATA_FIELD5, &
       & col_start(2:2), col_stride(2:2), col_edge(2:2), l2gp%columnTypes)
d1516 3
@


2.31
log
@Commented out reading l2gp%status.  It appears that reading characters from
HDF can't be made to work, due to fundamental design flaws in HDF.
@
text
@d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.30 2001/06/06 17:28:13 pwagner Exp $"
d56 3
d70 1
d75 4
d81 1
d130 6
d213 4
d232 14
a245 14
    call deallocate_test ( l2gp%pressures,    "l2gp%pressures",    ModuleName )
    call deallocate_test ( l2gp%latitude,     "l2gp%latitude",     ModuleName )
    call deallocate_test ( l2gp%longitude,    "l2gp%longitude",    ModuleName )
    call deallocate_test ( l2gp%solarTime,    "l2gp%solarTime",    ModuleName )
    call deallocate_test ( l2gp%solarZenith,  "l2gp%solarZenith",  ModuleName )
    call deallocate_test ( l2gp%losAngle,     "l2gp%losAngle",     ModuleName )
    call deallocate_test ( l2gp%geodAngle,    "l2gp%geodAngle",    ModuleName )
    call deallocate_test ( l2gp%chunkNumber,  "l2gp%chunkNumber",  ModuleName )
    call deallocate_test ( l2gp%time,         "l2gp%time",         ModuleName )
    call deallocate_test ( l2gp%frequency,    "l2gp%frequency",    ModuleName )
    call deallocate_test ( l2gp%l2gpValue,    "l2gp%l2gpValue",    ModuleName )
    call deallocate_test ( l2gp%l2gpPrecision,"l2gp%l2gpPrecision",ModuleName )
    call deallocate_test ( l2gp%status,       "l2gp%status",       ModuleName )
    call deallocate_test ( l2gp%quality,      "l2gp%quality",      ModuleName )
d249 6
d258 1
a258 1
  subroutine ExpandL2GPDataInPlace ( l2gp, newNTimes )
d260 4
a263 2
    ! This subroutine expands an L2GPData_T in place allowing the user to add
    ! more profiles to it.
d267 2
a268 1
    integer, intent(in) :: newNTimes
d273 2
d277 13
d292 2
a293 1
    if ( newNTimes<l2gp%nTimes ) &
d306 2
a307 1
      & l2gp%l2gpPrecision, l2gp%status, l2gp%quality )
d309 1
a309 1
      & nTimes=newNTimes)
d330 29
d438 2
d534 9
a746 1

d757 49
d883 8
d1041 21
d1226 2
d1310 33
d1437 4
@


2.30
log
@the_status_buffer allows reading l2gp%status
@
text
@d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.29 2001/05/03 23:59:56 vsnyder Exp $"
d635 6
d643 2
a644 2
    status = swrdfld(swid, DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
      the_status_buffer)
d647 6
a652 5
    if ( status == -1 ) then
      msr = MLSMSG_L2GPRead // DATA_FIELD3
      call MLSMessage ( MLSMSG_Error, ModuleName, msr )
    end if
    l2gp%status = the_status_buffer(:)(1:1)
d1240 3
@


2.29
log
@Trying to find out why realProf is undefined
@
text
@d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.28 2001/04/24 16:28:41 livesey Exp $"
d368 1
d467 1
d637 2
d645 1
d662 4
d1233 3
@


2.28
log
@Cosmetic changes only, except comment out dubious l2gp%quality = 0 statement.
@
text
@d5 1
a5 1
MODULE L2GPData                 ! Creation, manipulation and I/O for L2GP Data
d8 3
a10 3
  USE Allocate_Deallocate, ONLY: Allocate_test, Deallocate_test
  USE DUMP_0, only: DUMP
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
d12 1
a12 1
  USE MLSCommon, ONLY: R8
d14 2
a15 2
  USE Hdf, ONLY: DFNT_CHAR8, DFNT_FLOAT32, DFNT_INT32, DFNT_FLOAT64
  USE HDFEOS!, ONLY: SWATTACH, SWCREATE, SWDEFDFLD, SWDEFDIM, SWDEFGFLD, &
d17 5
a21 5
  USE OUTPUT_M, only: OUTPUT
  USE SWAPI, only: SWWRFLD, SWRDFLD
  USE STRING_TABLE, only: DISPLAY_STRING
  
  IMPLICIT NONE
d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.27 2001/04/20 03:00:59 livesey Exp $"
d50 1
a50 1
  INTEGER, PARAMETER :: L2GPNameLen = 80
d52 21
a72 21
   CHARACTER (len=*), PARAMETER :: DATA_FIELD1 = 'L2gpValue'
   CHARACTER (len=*), PARAMETER :: DATA_FIELD2 = 'L2gpPrecision'
   CHARACTER (len=*), PARAMETER :: DATA_FIELD3 = 'Status'
   CHARACTER (len=*), PARAMETER :: DATA_FIELD4 = 'Quality'

   CHARACTER (len=*), PARAMETER :: GEO_FIELD1 = 'Latitude'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD2 = 'Longitude'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD3 = 'Time'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD4 = 'LocalSolarTime'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD5 = 'SolarZenithAngle'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD6 = 'LineOfSightAngle'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD7 = 'OrbitGeodeticAngle'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD8 = 'ChunkNumber'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD9 = 'Pressure'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD10= 'Frequency'

   CHARACTER (len=*), PARAMETER :: DIM_NAME1 = 'nTimes'
   CHARACTER (len=*), PARAMETER :: DIM_NAME2 = 'nLevels'
   CHARACTER (len=*), PARAMETER :: DIM_NAME3 = 'nFreqs'
   CHARACTER (len=*), PARAMETER :: DIM_NAME12 = 'nLevels,nTimes' ! In Fortran order?!!
   CHARACTER (len=*), PARAMETER :: DIM_NAME123 = 'nFreqs,nLevels,nTimes' ! as above
d74 2
a75 2
   INTEGER, PARAMETER :: HDFE_AUTOMERGE = 1     ! MERGE FIELDS WITH SHARE DIM
   INTEGER, PARAMETER :: HDFE_NOMERGE = 0       ! don't merge
d79 1
a79 1
  TYPE L2GPData_T
d83 2
a84 2
     CHARACTER (LEN=L2GPNameLen) :: name ! Typically the swath name.
     INTEGER :: nameIndex       ! Used by the parser to keep track of the data
d88 3
a90 3
     INTEGER :: nTimes          ! Total number of profiles
     INTEGER :: nLevels         ! Total number of surfaces
     INTEGER :: nFreqs          ! Number of frequencies in breakdown
d93 1
a93 1
     REAL (r8), POINTER, DIMENSION(:) :: pressures => NULL() ! Vertical coords (nLevels)
d96 7
a102 7
     REAL (r8), POINTER, DIMENSION(:) :: latitude => NULL()
     REAL (r8), POINTER, DIMENSION(:) :: longitude => NULL()
     REAL (r8), POINTER, DIMENSION(:) :: solarTime => NULL()
     REAL (r8), POINTER, DIMENSION(:) :: solarZenith => NULL()
     REAL (r8), POINTER, DIMENSION(:) :: losAngle => NULL()
     REAL (r8), POINTER, DIMENSION(:) :: geodAngle => NULL()
     REAL (r8), POINTER, DIMENSION(:) :: time => NULL()
d104 1
a104 1
     INTEGER, POINTER, DIMENSION(:) :: chunkNumber => NULL()
d108 1
a108 1
     REAL (r8), POINTER, DIMENSION(:) :: frequency => NULL()
d113 2
a114 2
     REAL (r8), POINTER, DIMENSION(:,:,:) :: l2gpValue => NULL()
     REAL (r8), POINTER, DIMENSION(:,:,:) :: l2gpPrecision => NULL()
d117 2
a118 2
     CHARACTER (len=1), POINTER, DIMENSION(:) :: status => NULL()
     REAL (r8), POINTER, DIMENSION(:) :: quality => NULL()
d121 1
a121 1
  END TYPE L2GPData_T
d123 1
a123 1
CONTAINS ! =====     Public Procedures     =============================
d126 1
a126 1
  SUBROUTINE SetupNewL2GPRecord ( l2gp, nFreqs, nLevels, nTimes)
d131 2
a132 2
    TYPE (L2GPData_T), INTENT(inout)  :: l2gp
    INTEGER, INTENT(in), OPTIONAL :: nFreqs, nLevels, nTimes ! Dimensions
d135 2
a136 2
    INTEGER :: freqsArrayLen, status, surfsArrayLen
    INTEGER :: useNFreqs, useNLevels, useNTimes
d138 1
a138 1
    IF (PRESENT(nFreqs)) THEN
d140 1
a140 1
    ELSE
d142 1
a142 1
    ENDIF
d144 1
a144 1
    IF (PRESENT(nLevels)) THEN
d146 1
a146 1
    ELSE
d148 1
a148 1
    ENDIF
d150 1
a150 1
    IF (PRESENT(nTimes)) THEN
d152 1
a152 1
    ELSE
d154 1
a154 1
    ENDIF
d170 1
a170 1
    CALL allocate_test ( l2gp%pressures, useNLevels, "l2gp%pressures", &
d175 1
a175 1
    CALL allocate_test ( l2gp%frequency, useNFreqs, "l2gp%frequency", ModuleName)
d179 8
a186 8
    CALL allocate_test(l2gp%latitude,   useNTimes, "l2gp%latitude",   ModuleName)
    CALL allocate_test(l2gp%longitude,  useNTimes, "l2gp%longitude",  ModuleName)
    CALL allocate_test(l2gp%solarTime,  useNTimes, "l2gp%solarTime",  ModuleName)
    CALL allocate_test(l2gp%solarZenith,useNTimes, "l2gp%solarZenith",ModuleName)
    CALL allocate_test(l2gp%losAngle,   useNTimes, "l2gp%losAngle",   ModuleName)
    CALL allocate_test(l2gp%geodAngle,  useNTimes, "l2gp%geodAngle",  ModuleName)
    CALL allocate_test(l2gp%time,       useNTimes, "l2gp%time",       ModuleName)
    CALL allocate_test(l2gp%chunkNumber,useNTimes, "l2gp%chunkNumber",ModuleName)
d190 1
a190 1
    CALL allocate_test(l2gp%l2gpValue,useNFreqs,useNLevels,&
d192 1
a192 1
    CALL allocate_test(l2gp%l2gpPrecision,useNFreqs,useNLevels,&
d195 2
a196 2
    CALL allocate_test(l2gp%status, useNTimes,"l2gp%status", ModuleName)
    CALL allocate_test(l2gp%quality,useNTimes,"l2gp%quality",ModuleName)
d198 1
a198 1
  END SUBROUTINE SetupNewL2GPRecord
d201 1
a201 1
  SUBROUTINE DestroyL2GPContents ( L2GP )
d206 1
a206 1
    TYPE (L2GPData_T), INTENT(inout) :: L2GP
d209 1
a209 1
    INTEGER status
d213 14
a226 14
    CALL deallocate_test ( l2gp%pressures,    "l2gp%pressures",    ModuleName )
    CALL deallocate_test ( l2gp%latitude,     "l2gp%latitude",     ModuleName )
    CALL deallocate_test ( l2gp%longitude,    "l2gp%longitude",    ModuleName )
    CALL deallocate_test ( l2gp%solarTime,    "l2gp%solarTime",    ModuleName )
    CALL deallocate_test ( l2gp%solarZenith,  "l2gp%solarZenith",  ModuleName )
    CALL deallocate_test ( l2gp%losAngle,     "l2gp%losAngle",     ModuleName )
    CALL deallocate_test ( l2gp%geodAngle,    "l2gp%geodAngle",    ModuleName )
    CALL deallocate_test ( l2gp%chunkNumber,  "l2gp%chunkNumber",  ModuleName )
    CALL deallocate_test ( l2gp%time,         "l2gp%time",         ModuleName )
    CALL deallocate_test ( l2gp%frequency,    "l2gp%frequency",    ModuleName )
    CALL deallocate_test ( l2gp%l2gpValue,    "l2gp%l2gpValue",    ModuleName )
    CALL deallocate_test ( l2gp%l2gpPrecision,"l2gp%l2gpPrecision",ModuleName )
    CALL deallocate_test ( l2gp%status,       "l2gp%status",       ModuleName )
    CALL deallocate_test ( l2gp%quality,      "l2gp%quality",      ModuleName )
d230 1
a230 1
  END SUBROUTINE DestroyL2GPContents
d233 1
a233 1
  SUBROUTINE ExpandL2GPDataInPlace ( l2gp, newNTimes )
d239 2
a240 2
    TYPE (L2GPData_T), INTENT(inout) :: l2gp
    INTEGER, INTENT(in) :: newNTimes
d243 2
a244 2
    INTEGER :: status                   ! From ALLOCATE
    TYPE (L2GPData_T) :: tempL2gp       ! For copying data around
d249 2
a250 2
    IF ( newNTimes<l2gp%nTimes ) &
         & CALL MLSMessage ( MLSMSG_Error, ModuleName, &
d263 1
a263 1
    CALL SetupNewL2GPRecord( l2gp, nFreqs=l2gp%nFreqs, nLevels=l2gp%nLevels, &
d287 1
a287 1
    CALL DestroyL2GPContents(templ2gp)
d289 1
a289 1
  END SUBROUTINE ExpandL2GPDataInPlace
d292 1
a292 1
  INTEGER FUNCTION AddL2GPToDatabase( DATABASE, ITEM )
d299 2
a300 2
    TYPE (l2gpdata_t), DIMENSION(:), POINTER :: DATABASE
    TYPE (l2gpdata_t), INTENT(in) :: ITEM
d303 1
a303 1
    TYPE (L2GPData_T), DIMENSION(:), POINTER :: tempDatabase
d306 1
a306 1
    INCLUDE "addItemToDatabase.f9h" 
d309 1
a309 1
  END FUNCTION AddL2GPToDatabase
d315 1
a315 1
  SUBROUTINE DestroyL2GPDatabase ( DATABASE )
d318 1
a318 1
    TYPE (L2GPData_T), DIMENSION(:), POINTER :: DATABASE
d321 1
a321 1
    INTEGER :: l2gpIndex, status
d323 6
a328 6
    IF ( ASSOCIATED(database)) THEN
       DO l2gpIndex = 1, SIZE(database)
          CALL DestroyL2GPContents ( database(l2gpIndex) )
       END DO
       DEALLOCATE ( database, stat=status )
       IF ( status /= 0 ) CALL MLSMessage ( MLSMSG_Error, ModuleName, &
d330 2
a331 2
    END IF
  END SUBROUTINE DestroyL2GPDatabase
d335 1
a335 1
  SUBROUTINE ReadL2GPData(L2FileHandle, swathname, l2gp, numProfs, &
d344 5
a348 5
    CHARACTER (LEN=*), INTENT(IN) :: swathname ! Name of swath
    INTEGER, INTENT(IN) :: L2FileHandle ! Returned by swopen
    INTEGER, INTENT(IN), OPTIONAL :: firstProf, lastProf ! Defaults to first and last
    TYPE( L2GPData_T ), INTENT(OUT) :: l2gp ! Result
    INTEGER, INTENT(OUT), OPTIONAL :: numProfs ! Number actually read
d351 1
a351 1
    CHARACTER (LEN=*), PARAMETER :: SZ_ERR = 'Failed to get size of &
d353 2
a354 2
    CHARACTER (LEN=*), PARAMETER :: MLSMSG_INPUT = 'Error in input argument '
    CHARACTER (LEN=*), PARAMETER :: MLSMSG_L2GPRead = 'Unable to read L2GP &
d358 2
a359 2
    CHARACTER (LEN=80) :: list
    CHARACTER (LEN=480) :: msr
d361 3
a363 3
    INTEGER :: alloc_err, first, freq, lev, nDims, size, swid, status
    INTEGER :: start(3), stride(3), edge(3), dims(3)
    INTEGER :: nFreqs, nLevels, nTimes, nFreqsOr1, nLevelsOr1, myNumProfs
d365 1
a365 1
    LOGICAL :: firstCheck, lastCheck
d367 1
a367 1
    REAL, ALLOCATABLE :: realFreq(:), realSurf(:), realProf(:), real3(:,:,:)
d374 1
a374 1
    IF (swid == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d383 1
a383 1
    IF (nDims == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d385 2
a386 2
    IF ( INDEX(list,'nLevels') /= 0 ) lev = 1
    IF ( INDEX(list,'Freq') /= 0 ) freq = 1
d389 1
a389 1
    IF (size == -1) THEN
d391 2
a392 2
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
d395 1
a395 1
    IF (lev == 0) THEN
d397 1
a397 1
    ELSE
d399 1
a399 1
       IF (size == -1) THEN
d401 2
a402 2
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
d405 1
a405 1
    ENDIF
d407 1
a407 1
    IF (freq == 1) THEN
d409 1
a409 1
       IF (size == -1) THEN
d411 2
a412 2
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
d414 1
a414 1
    ELSE
d416 1
a416 1
    ENDIF
d420 2
a421 2
    firstCheck = PRESENT(firstProf)
    lastCheck = PRESENT(lastProf)
d423 1
a423 1
    IF (firstCheck) THEN
d425 1
a425 1
       IF ( (firstProf >= l2gp%nTimes) .OR. (firstProf < 0) ) THEN
d427 2
a428 2
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ELSE
d430 1
a430 1
       ENDIF
d432 1
a432 1
    ELSE
d436 1
a436 1
    ENDIF
d438 1
a438 1
    IF (lastCheck) THEN
d440 1
a440 1
       IF (lastProf < first) THEN
d442 2
a443 2
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
d445 1
a445 1
       IF (lastProf >= nTimes) THEN
d447 1
a447 1
       ELSE
d449 1
a449 1
       ENDIF
d451 1
a451 1
    ELSE
d455 1
a455 1
    ENDIF
d459 1
a459 1
    CALL SetupNewL2GPRecord (l2gp, nFreqs=nFreqs, nLevels=nLevels, nTimes=myNumProfs)
d465 5
a469 5
    ALLOCATE(realProf(myNumProfs), realSurf(l2gp%nLevels), &
         realFreq(l2gp%nFreqs), &
         real3(nFreqsOr1,nLevelsOr1,myNumProfs), STAT=alloc_err)
    IF (alloc_err /= 0) call MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
      & ' various things in ReadL2GPData')
d482 3
a484 3
     status = swrdfld(swid, GEO_FIELD1, start(3:3), stride(3:3), edge(3:3), &
          realProf)
    IF (status == -1) THEN
d486 7
a492 7
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
    l2gp%latitude = DBLE(realProf)

     status = swrdfld(swid, GEO_FIELD2, start(3:3), stride(3:3), edge(3:3), &
          realProf)
    IF (status == -1) THEN
d494 7
a500 7
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
    l2gp%longitude = DBLE(realProf)

     status = swrdfld(swid, GEO_FIELD3, start(3:3), stride(3:3), edge(3:3), &
          l2gp%time)
    IF (status == -1) THEN
d502 2
a503 2
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
d505 3
a507 3
     status = swrdfld(swid, GEO_FIELD4, start(3:3), stride(3:3), edge(3:3), &
          realProf)
    IF (status == -1) THEN
d509 7
a515 7
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
    l2gp%solarTime = DBLE(realProf)

     status = swrdfld(swid, GEO_FIELD5, start(3:3), stride(3:3), edge(3:3), &
          realProf)
    IF (status == -1) THEN
d517 7
a523 7
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
    l2gp%solarZenith = DBLE(realProf)

     status = swrdfld(swid, GEO_FIELD6, start(3:3), stride(3:3), edge(3:3), &
          realProf)
    IF (status == -1) THEN
d525 7
a531 7
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
    l2gp%losAngle = DBLE(realProf)

     status = swrdfld(swid, GEO_FIELD7, start(3:3), stride(3:3), edge(3:3), &
          realProf)
    IF (status == -1) THEN
d533 7
a539 7
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
    l2gp%geodAngle = DBLE(realProf)

     status = swrdfld(swid, GEO_FIELD8, start(3:3), stride(3:3), edge(3:3), &
          l2gp%chunkNumber)
    IF (status == -1) THEN
d541 2
a542 2
       CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
    ENDIF
d546 1
a546 1
    IF (lev /= 0) THEN
d549 2
a550 2
         realSurf)
       IF (status == -1) THEN
d552 2
a553 2
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
d555 1
a555 1
       l2gp%pressures = DBLE(realSurf)
d557 1
a557 1
    ENDIF
d561 1
a561 1
    IF (freq == 1) THEN
d566 2
a567 2
         realFreq)
       IF (status == -1) THEN
d569 3
a571 3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
       l2gp%frequency = DBLE(realFreq)
d573 1
a573 1
    ENDIF
d577 1
a577 1
    IF ( freq == 1) THEN
d580 1
a580 1
       IF (status == -1) THEN
d582 3
a584 3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
       l2gp%l2gpValue = DBLE(real3)
d587 1
a587 1
       IF (status == -1) THEN
d589 3
a591 3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
       l2gp%l2gpPrecision = DBLE(real3)
d593 1
a593 1
    ELSE IF ( lev == 1) THEN
d596 2
a597 2
           edge(2:3), real3(1,:,:) )
      IF (status == -1) THEN
d599 3
a601 3
        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      l2gp%l2gpValue = DBLE(real3)
d604 2
a605 2
        edge(2:3), real3(1,:,:) )
      IF (status == -1) THEN
d607 3
a609 3
        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      l2gp%l2gpPrecision = DBLE(real3)
d611 1
a611 1
    ELSE
d614 2
a615 2
            real3(1,1,:) )
       IF (status == -1) THEN
d617 3
a619 3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
       l2gp%l2gpValue = DBLE(real3)
d623 1
a623 1
       IF (status == -1) THEN
d625 3
a627 3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
       l2gp%l2gpPrecision = DBLE(real3)
d629 1
a629 1
    ENDIF
d637 1
a637 1
    IF (status == -1) THEN
d639 2
a640 2
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
d643 2
a644 2
         realProf)
    IF (status == -1) THEN
d646 3
a648 3
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
    l2gp%quality = DBLE(realProf)
d653 3
a655 3
    DEALLOCATE(realFreq, realSurf, realProf, real3, STAT=alloc_err)
    IF ( alloc_err /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, &
         'Failed deallocation of local real variables.')
d660 2
a661 2
    IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &detach from swath interface after reading.')
d664 1
a664 1
    IF (PRESENT(numProfs)) numProfs=myNumProfs
d667 1
a667 1
  END SUBROUTINE ReadL2GPData
d671 1
a671 1
  SUBROUTINE OutputL2GP_createFile (l2gp, L2FileHandle, swathName)
d678 3
a680 3
    INTEGER, INTENT(in) :: L2FileHandle ! From swopen
    TYPE( L2GPData_T ), INTENT(inout) :: l2gp
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN) :: swathName ! Defaults to l2gp%swathName
d684 4
a687 4
    CHARACTER (len=*), PARAMETER :: DIM_ERR = 'Failed to define dimension '
    CHARACTER (len=*), PARAMETER :: GEO_ERR = &
         & 'Failed to define geolocation field '
    CHARACTER (len=*), PARAMETER :: DAT_ERR = 'Failed to define data field '
d691 2
a692 2
    CHARACTER (len=480) :: MSR
    CHARACTER (len=132) :: NAME   ! From l2gp%name
d694 1
a694 1
    INTEGER :: SWID, STATUS
d696 1
a696 1
    IF (PRESENT(swathName)) THEN
d698 1
a698 1
    ELSE
d700 1
a700 1
    ENDIF
d705 1
a705 1
    IF ( swid == -1 ) THEN
d707 2
a708 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d713 1
a713 1
    IF ( status == -1 ) THEN
d715 2
a716 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d718 1
a718 1
    IF ( l2gp%nLevels > 0 ) THEN
d720 1
a720 1
       IF ( status == -1 ) THEN
d722 3
a724 3
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
    END IF
d726 1
a726 1
    IF ( l2gp%nFreqs > 1 ) THEN
d728 1
a728 1
       IF ( status == -1 ) THEN
d730 3
a732 3
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
    END IF
d738 1
a738 1
    IF ( status == -1 ) THEN
d740 2
a741 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d745 1
a745 1
    IF ( status == -1 ) THEN
d747 2
a748 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d752 1
a752 1
    IF ( status == -1 ) THEN
d754 2
a755 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d759 1
a759 1
    IF ( status == -1 ) THEN
d761 2
a762 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d766 1
a766 1
    IF ( status == -1 ) THEN
d768 2
a769 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d773 1
a773 1
    IF ( status == -1 ) THEN
d775 2
a776 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d780 1
a780 1
    IF ( status == -1 ) THEN
d782 2
a783 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d787 1
a787 1
    IF ( status == -1 ) THEN
d789 2
a790 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d792 1
a792 1
    IF ( l2gp%nLevels > 0 ) THEN
d795 1
a795 1
       IF ( status == -1 ) THEN
d797 3
a799 3
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
    END IF
d801 1
a801 1
    IF ( l2gp%nFreqs > 0 ) THEN
d804 1
a804 1
       IF ( status == -1 ) THEN
d806 3
a808 3
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
    END IF
d812 1
a812 1
    IF ( (l2gp%nFreqs > 0) .AND. (l2gp%nLevels > 0) ) THEN
d817 1
a817 1
       IF ( status == -1 ) THEN
d819 2
a820 2
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
d826 1
a826 1
       IF ( status == -1 ) THEN
d828 2
a829 2
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
d832 1
a832 1
    ELSE IF ( l2gp%nLevels > 0 ) THEN
d837 1
a837 1
       IF ( status == -1 ) THEN
d839 2
a840 2
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
d845 1
a845 1
       IF ( status == -1 ) THEN
d847 2
a848 2
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
d850 1
a850 1
    ELSE
d855 1
a855 1
       IF ( status == -1 ) THEN
d857 2
a858 2
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
d863 1
a863 1
       IF ( status == -1 ) THEN
d865 2
a866 2
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
d868 1
a868 1
    END IF
d872 1
a872 1
    IF ( status == -1 ) THEN
d874 2
a875 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d879 1
a879 1
    IF ( status == -1 ) THEN
d881 2
a882 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d889 2
a890 2
    IF ( status == -1 ) THEN
       CALL MLSMessage ( MLSMSG_Error, ModuleName, &
d892 1
a892 1
    END IF
d895 1
a895 1
  END SUBROUTINE OutputL2GP_createFile
d899 1
a899 1
  SUBROUTINE OutputL2GP_writeGeo (l2gp, l2FileHandle, swathName)
d906 3
a908 3
    TYPE( L2GPData_T ), INTENT(inout) :: l2gp
    INTEGER, INTENT(in) :: l2FileHandle ! From swopen
    CHARACTER (len=*), INTENT(IN), OPTIONAL :: swathName ! Defaults to l2gp%name
d912 1
a912 1
    CHARACTER (len=*), PARAMETER :: WR_ERR = &
d917 2
a918 2
    CHARACTER (len=480) :: msr
    CHARACTER (len=132) :: name ! Either swathName or l2gp%name
d920 2
a921 2
    INTEGER :: status, swid
    INTEGER :: start(2), stride(2), edge(2)
d923 1
a923 1
    IF (PRESENT(swathName)) THEN
d925 1
a925 1
    ELSE
d927 1
a927 1
    ENDIF
d938 2
a939 2
         REAL(l2gp%latitude))
    IF ( status == -1 ) THEN
d941 2
a942 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d945 2
a946 2
         REAL(l2gp%longitude))
    IF ( status == -1 ) THEN
d948 2
a949 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d953 1
a953 1
    IF ( status == -1 ) THEN
d955 2
a956 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d959 2
a960 2
        REAL(l2gp%solarTime))
    IF ( status == -1 ) THEN
d962 2
a963 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d966 2
a967 2
         REAL(l2gp%solarZenith))
    IF ( status == -1 ) THEN
d969 2
a970 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d973 2
a974 2
         REAL(l2gp%losAngle))
    IF ( status == -1 ) THEN
d976 2
a977 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d980 2
a981 2
         REAL(l2gp%geodAngle))
    IF ( status == -1 ) THEN
d983 2
a984 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d988 1
a988 1
    IF ( status == -1 ) THEN
d990 2
a991 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d993 1
a993 1
    IF ( l2gp%nLevels > 0 ) THEN
d996 2
a997 2
            REAL(l2gp%pressures))
       IF ( status == -1 ) THEN
d999 3
a1001 3
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
    END IF
d1003 1
a1003 1
    IF ( l2gp%nFreqs > 0 ) THEN
d1007 2
a1008 2
            REAL(l2gp%frequency))
       IF ( status == -1 ) THEN
d1010 3
a1012 3
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
    END IF
d1018 2
a1019 2
    IF ( status == -1 ) THEN
       CALL MLSMessage ( MLSMSG_Warning, ModuleName, &
d1021 1
a1021 1
    END IF
d1024 1
a1024 1
  END SUBROUTINE OutputL2GP_writeGeo
d1028 1
a1028 1
  SUBROUTINE OutputL2GP_writeData(l2gp, l2FileHandle, swathName)
d1035 3
a1037 3
    TYPE( L2GPData_T ), INTENT(inout) :: l2gp
    INTEGER, INTENT(in) :: l2FileHandle ! From swopen
    CHARACTER (len=*), INTENT(IN), OPTIONAL :: swathName ! Defaults to l2gp%name
d1041 1
a1041 1
    CHARACTER (len=*), PARAMETER :: WR_ERR = 'Failed to write data field '
d1045 2
a1046 2
    CHARACTER (len=480) :: msr
    CHARACTER (len=132) :: name     ! Either swathName or l2gp%name
d1048 3
a1050 3
    INTEGER :: status
    INTEGER :: start(3), stride(3), edge(3)
    INTEGER :: swid
d1052 1
a1052 1
    IF (PRESENT(swathName)) THEN
d1054 1
a1054 1
    ELSE
d1056 1
a1056 1
    ENDIF
d1065 1
a1065 1
    IF ( l2gp%nFreqs > 0 ) THEN
d1070 1
a1070 1
       IF ( status == -1 ) THEN
d1072 2
a1073 2
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
d1075 2
a1076 2
            & RESHAPE(REAL(l2gp%l2gpPrecision), (/SIZE(l2gp%l2gpPrecision)/)) )
       IF ( status == -1 ) THEN
d1078 2
a1079 2
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
d1081 1
a1081 1
    ELSE IF ( l2gp%nLevels > 0 ) THEN
d1085 1
a1085 1
            edge(2:3), REAL(l2gp%l2gpValue(1,:,:)) )
d1087 1
a1087 1
       IF ( status == -1 ) THEN
d1089 2
a1090 2
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
d1092 2
a1093 2
            edge(2:3), REAL(l2gp%l2gpPrecision(1,:,:) ))
       IF ( status == -1 ) THEN
d1095 3
a1097 3
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
    ELSE
d1101 2
a1102 2
            REAL(l2gp%l2gpValue(1,1,:) ))
       IF ( status == -1 ) THEN
d1104 2
a1105 2
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
d1107 2
a1108 2
            REAL(l2gp%l2gpPrecision(1,1,:) ))
       IF ( status == -1 ) THEN
d1110 3
a1112 3
          CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
       END IF
    END IF
d1118 1
a1118 1
    IF ( status == -1 ) THEN
d1120 2
a1121 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d1124 2
a1125 2
         REAL(l2gp%quality))
    IF ( status == -1 ) THEN
d1127 2
a1128 2
       CALL MLSMessage ( MLSMSG_Error, ModuleName, msr )
    END IF
d1133 2
a1134 2
    IF ( status == -1 ) THEN
       CALL MLSMessage ( MLSMSG_Warning, ModuleName, &
d1136 1
a1136 1
    END IF
d1140 1
a1140 1
  END SUBROUTINE OutputL2GP_writeData
d1147 1
a1147 1
  SUBROUTINE WriteL2GPData(l2gp,l2FileHandle,swathName)
d1151 3
a1153 3
    INTEGER, INTENT(IN) :: l2FileHandle ! From swopen
    TYPE (L2GPData_T), INTENT(INOUT) :: l2gp
    CHARACTER (LEN=*), OPTIONAL, INTENT(IN) :: swathName ! (defaults to l2gp%swathName)
d1157 3
a1159 3
    CALL OutputL2GP_createFile (l2gp, l2FileHandle, swathName)
    CALL OutputL2GP_writeGeo (l2gp, l2FileHandle, swathName)
    CALL OutputL2GP_writeData (l2gp, l2FileHandle, swathName)
d1161 1
a1161 1
  END SUBROUTINE WriteL2GPData
d1219 1
a1219 1
END MODULE L2GPData
d1224 3
@


2.27
log
@Made L2GPNameLen public
@
text
@d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.26 2001/04/20 02:05:09 vsnyder Exp $"
d190 4
a193 2
    CALL allocate_test(l2gp%l2gpValue,useNFreqs,useNLevels,useNTimes,"l2gp%l2gpValue", ModuleName)
    CALL allocate_test(l2gp%l2gpPrecision,useNFreqs,useNLevels,useNTimes,"l2gp%l2gpPrecision", ModuleName)
a218 1
    CALL deallocate_test ( l2gp%losAngle,     "l2gp%losAngle",     ModuleName )
d1122 1
a1122 1
    l2gp%quality = 0
d1224 3
@


2.26
log
@Cosmetic changes: Default visibility is now private
@
text
@d25 1
d34 1
a34 1
    & "$Id: L2GPData.f90,v 2.25 2001/03/20 01:44:25 livesey Exp $"
d1223 3
@


2.25
log
@Fixed bug, was outputting chunkNumber as real!
@
text
@d22 7
d32 4
a35 3
  CHARACTER(len=256), PRIVATE :: Id = &
       & "$Id: L2GPData.f90,v 2.24 2001/03/12 20:25:04 vsnyder Exp $"
  CHARACTER(len=*), PARAMETER, PRIVATE :: ModuleName = &
d1222 3
@


2.24
log
@Improve dump_l2gp.  Nullify components of l2gp before calling
SetupNewL2GPRecord from ExpandL2GPDataInPlace, so as not to clobber the
component pointers carefully copied to tempL2gp.
@
text
@d26 1
a26 1
       & "$Id: L2GPData.f90,v 2.23 2001/03/01 18:37:51 livesey Exp $"
d775 1
a775 1
    status = swdefgfld(swid, GEO_FIELD8, DIM_NAME1, DFNT_FLOAT32, &
d1214 5
@


2.23
log
@Added dumper routine
@
text
@d26 1
a26 1
       & "$Id: L2GPData.f90,v 2.22 2001/02/22 21:54:22 livesey Exp $"
d122 1
a122 1
    TYPE (L2GPData_T), INTENT(out)  :: l2gp
d246 9
a254 2

    CALL SetupNewL2GPRecord( l2gp, nFreqs=l2gp%nFreqs, nLevels=l2gp%nLevels, nTimes=newNTimes)
a276 1

d1155 1
a1155 1
  subroutine Dump_L2GP(l2gp)
d1159 1
d1164 2
a1165 1
    do i=1,size(l2gp)
d1175 1
a1175 2
      call output ( 'Pressures:', advance='yes' )
      call dump ( l2gp(i)%pressures )
d1177 1
a1177 2
      call output ( 'Latitude:' , advance='yes' )
      call dump (l2gp(i)%latitude )
d1179 1
a1179 2
      call output ( 'Longitude:' , advance='yes' )
      call dump (l2gp(i)%longitude )
d1181 1
a1181 2
      call output ( 'SolarTime:' , advance='yes' )
      call dump (l2gp(i)%solarTime )
d1183 1
a1183 2
      call output ( 'SolarZenith:' , advance='yes' )
      call dump (l2gp(i)%solarZenith )
d1185 1
a1185 2
      call output ( 'LOSAngle:' , advance='yes' )
      call dump (l2gp(i)%losAngle )
d1187 1
a1187 2
      call output ( 'geodAngle:' , advance='yes' )
      call dump (l2gp(i)%geodAngle )
d1189 1
a1189 2
      call output ( 'Time:' , advance='yes' )
      call dump (l2gp(i)%time )
d1191 1
a1191 2
      call output ( 'ChunkNumber:' , advance='yes' )
      call dump (l2gp(i)%chunkNumber )
d1193 2
a1194 4
      if ( associated(l2gp(i)%frequency) ) then
        call output ( 'Frequencies:', advance='yes' )
        call dump ( l2gp(i)%frequency )
      end if
d1196 1
a1196 2
      call output ( 'L2GPValue:', advance='yes' )
      call dump(l2gp(i)%l2gpValue)
d1198 1
a1198 2
      call output ( 'L2GPPrecision:', advance='yes' )
      call dump(l2gp(i)%l2gpPrecision)
d1200 1
a1200 2
      !    call output ( 'Status:', advance='yes' )
      !    call dump( l2gp(i)%status )
d1202 1
a1202 2
      call output ( 'Quality:', advance='yes' )
      call dump(l2gp(i)%quality)
d1214 3
@


2.22
log
@Added initialisation to NULL() for pointer components of L2GPData_T
@
text
@d9 1
d17 3
a19 1
  USE SWAPI, ONLY: SWWRFLD, SWRDFLD
d26 1
a26 1
       & "$Id: L2GPData.f90,v 2.21 2001/02/15 18:23:20 livesey Exp $"
d31 4
d1147 68
d1221 3
@


2.21
log
@Got it right this time!
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.20 2001/02/15 18:20:15 livesey Exp $"
d77 1
a77 1
     REAL (r8), POINTER, DIMENSION(:) :: pressures ! Vertical coords (nLevels)
d80 9
a88 4
     REAL (r8), POINTER, DIMENSION(:) :: latitude, longitude, solarTime, &
          & solarZenith, losAngle, geodAngle
     REAL (r8), POINTER, DIMENSION(:) :: time
     INTEGER, POINTER, DIMENSION(:) :: chunkNumber !
d92 1
a92 1
     REAL (r8), POINTER, DIMENSION(:) :: frequency
d97 2
a98 2
     REAL (r8), POINTER, DIMENSION(:,:,:) :: l2gpValue
     REAL (r8), POINTER, DIMENSION(:,:,:) :: l2gpPrecision
d101 2
a102 2
     CHARACTER (len=1), POINTER, DIMENSION(:) :: status
     REAL (r8), POINTER, DIMENSION(:) :: quality
d1146 3
@


2.20
log
@Had to comment out reading of status in ReadL2GPData to make it work, logged PR.
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.19 2001/02/14 23:39:40 livesey Exp $"
d607 2
d1088 2
a1089 4
!     status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
!          l2gp%status)  
! These lines commented out, as they make NAG core dump, NJL.
!
d1141 3
@


2.19
log
@Made numProfs argument optional(intent out) for ReadL2GPData
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.18 2001/02/13 00:55:35 livesey Exp $"
d440 2
d452 1
d454 2
a455 2
    status = swrdfld(swid, GEO_FIELD1, start(3:3), stride(3:3), edge(3:3), &
         realProf)
d462 2
a463 2
    status = swrdfld(swid, GEO_FIELD2, start(3:3), stride(3:3), edge(3:3), &
         realProf)
d470 2
a471 2
    status = swrdfld(swid, GEO_FIELD3, start(3:3), stride(3:3), edge(3:3), &
         l2gp%time)
d477 2
a478 2
    status = swrdfld(swid, GEO_FIELD4, start(3:3), stride(3:3), edge(3:3), &
         realProf)
d485 2
a486 2
    status = swrdfld(swid, GEO_FIELD5, start(3:3), stride(3:3), edge(3:3), &
         realProf)
d493 2
a494 2
    status = swrdfld(swid, GEO_FIELD6, start(3:3), stride(3:3), edge(3:3), &
         realProf)
d501 2
a502 2
    status = swrdfld(swid, GEO_FIELD7, start(3:3), stride(3:3), edge(3:3), &
         realProf)
d509 2
a510 2
    status = swrdfld(swid, GEO_FIELD8, start(3:3), stride(3:3), edge(3:3), &
         l2gp%chunkNumber)
d521 1
a521 1
            realSurf)
d538 1
a538 1
            realFreq)
d567 16
a582 16
       status = swrdfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
            edge(2:3), real3(1,:,:) )
       IF (status == -1) THEN
          msr = MLSMSG_L2GPRead // DATA_FIELD1
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
       l2gp%l2gpValue = DBLE(real3)

       status = swrdfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
            edge(2:3), real3(1,:,:) )
       IF (status == -1) THEN
          msr = MLSMSG_L2GPRead // DATA_FIELD2
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
       l2gp%l2gpPrecision = DBLE(real3)

d605 6
a610 6
         status = swrdfld(swid, DATA_FIELD3,start(3:3),stride(3:3),edge(3:3),&
              l2gp%status)
         IF (status == -1) THEN
            msr = MLSMSG_L2GPRead // DATA_FIELD3
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
d620 1
d1086 4
a1089 2
    status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
         l2gp%status)
d1141 3
@


2.18
log
@Removed another print statement!
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.17 2001/02/13 00:51:31 livesey Exp $"
d320 1
a320 3
    INTEGER, INTENT(OUT) :: numProfs ! Number actually read

    ! Parameters
d322 1
d329 1
a329 6
    ! Functions

    !INTEGER, EXTERNAL :: swattach, swdetach, swdiminfo, swinqdims, swrdfld

    ! Variables

d335 1
a335 1
    INTEGER :: nFreqs, nLevels, nTimes, nFreqsOr1, nLevelsOr1
d418 1
a418 1
          numProfs = nTimes - first
d420 1
a420 1
          numProfs = lastProf - first + 1
d425 1
a425 1
       numProfs = nTimes - first
d431 1
a431 1
    CALL SetupNewL2GPRecord (l2gp, nFreqs=nFreqs, nLevels=nLevels, nTimes=numProfs)
d437 1
a437 1
    ALLOCATE(realProf(numProfs), realSurf(l2gp%nLevels), &
d439 1
a439 1
         real3(nFreqsOr1,nLevelsOr1,numProfs), STAT=alloc_err)
d449 1
a449 1
    edge(3) = numProfs
d629 3
d1135 3
@


2.17
log
@Fixed bug, copy pressure information in ExpandL2GPDataInPlace
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.16 2001/02/09 18:38:04 livesey Exp $"
a963 1
       PRINT*,l2gp%pressures
d1138 3
@


2.16
log
@Even more print statemets removed!
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.15 2001/02/09 17:51:01 livesey Exp $"
d237 3
d964 1
d1139 3
@


2.15
log
@Removed some print statements.
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.14 2001/02/09 17:45:15 livesey Exp $"
a96 1
     !                (status is a reserved word in F90)
d1083 1
a1083 3
         l2gp%status) ! absoft f90 barfs here
    !status=0 
    print*,"Warning. Writing of status field disabled"
a1122 1
    PRINT*,'Calling create'
a1123 1
    PRINT*,'Calling write geo'
a1124 1
    PRINT*,'Calling write data'
a1125 1
    PRINT*,'Done'
d1135 3
@


2.14
log
@Another fix to dimension ordering.
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.13 2001/02/08 01:06:08 livesey Exp $"
a800 1
       PRINT*,'2d'
a1023 1
    print*,"OutputL2GP_writeData -- name=",name
a1031 1
    print*," attached swath with swid=",swid," filehandle=",l2FileHandle
a1032 1
       print*,"Writing 3D field"
a1037 1
          PRINT*,'Status is:',status
a1048 1
       Print*,"Writing 2-d field"
a1050 1
       PRINT*,'swid=',swid
d1053 1
a1053 6
       PRINT*,'Start:',start(2:3)
       PRINT*,'Stride:',stride(2:3)
       PRINT*,'Edge:',edge(2:3)
       PRINT*,'Raw shape:',SHAPE(l2gp%l2gpValue)
       PRINT*,'Shape:',SHAPE(l2gp%l2gpValue(1,:,:))
       print*,"Status of write was ",status
a1066 1
       Print*,"Writing 1-D field"
d1142 3
@


2.13
log
@Bug fix in ExpandL2GPDataInPlace
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.12 2001/02/05 23:58:22 pwagner Exp $"
d55 2
a56 2
   CHARACTER (len=*), PARAMETER :: DIM_NAME12 = 'nTimes,nLevels' ! Note C order!!!!
   CHARACTER (len=*), PARAMETER :: DIM_NAME123 = 'nTimes,nLevels,nFreqs' ! Note C order!!!!
d144 1
d239 15
a253 15

    l2gp%latitude(1:templ2gp%nTimes) = templ2gp%latitude
    l2gp%longitude(1:templ2gp%nTimes) = templ2gp%longitude
    l2gp%solarTime(1:templ2gp%nTimes) = templ2gp%solarTime
    l2gp%solarZenith(1:templ2gp%nTimes) = templ2gp%solarZenith
    l2gp%losAngle(1:templ2gp%nTimes) = templ2gp%losAngle
    l2gp%geodAngle(1:templ2gp%nTimes) = templ2gp%geodAngle
    l2gp%time(1:templ2gp%nTimes) = templ2gp%time
    l2gp%chunkNumber(1:templ2gp%nTimes) = templ2gp%chunkNumber

    l2gp%l2gpValue(:,:,1:templ2gp%nTimes) = templ2gp%l2gpValue
    l2gp%l2gpPrecision(:,:,1:templ2gp%nTimes) = templ2gp%l2gpPrecision

    l2gp%status(1:templ2gp%nTimes) = templ2gp%status
    l2gp%quality(1:templ2gp%nTimes) = templ2gp%quality
d349 1
a349 1
    swid = swattach(L2FileHandle, l2gp%Name)
d671 1
a671 1
    swid = swcreate(L2FileHandle, name)
d673 1
a673 1
       msr = 'Failed to create swath ' // name
d693 1
a693 1
    IF ( l2gp%nFreqs > 0 ) THEN
d801 1
d1025 1
a1025 1
    !print*,"OutputL2GP_writeData -- name=",name
d1034 1
a1034 1
    !print*," attached swath with swid=",swid," filehandle=",l2FileHandle
d1036 1
a1036 1
       !print*,"Writing 3D field"
d1042 1
d1054 1
a1054 1
       !Print*,"Writing 2-d field"
d1057 1
d1059 7
a1065 2
            edge(2:3), REAL(l2gp%l2gpValue(1,:,:) ))
       !print*,"Status of write was ",status
d1079 1
a1079 1
       !Print*,"Writing 1-D field"
d1099 1
a1099 1
    !print*,"Warning. Writing of status field disabled"
d1139 1
d1141 1
d1143 1
d1145 1
d1155 3
@


2.12
log
@Uses swrdfld from swapi
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.11 2001/02/03 00:04:26 pwagner Exp $"
d239 8
a246 8
    l2gp%latitude(1:l2gp%nTimes) = templ2gp%latitude
    l2gp%longitude(1:l2gp%nTimes) = templ2gp%longitude
    l2gp%solarTime(1:l2gp%nTimes) = templ2gp%solarTime
    l2gp%solarZenith(1:l2gp%nTimes) = templ2gp%solarZenith
    l2gp%losAngle(1:l2gp%nTimes) = templ2gp%losAngle
    l2gp%geodAngle(1:l2gp%nTimes) = templ2gp%geodAngle
    l2gp%time(1:l2gp%nTimes) = templ2gp%time
    l2gp%chunkNumber(1:l2gp%nTimes) = templ2gp%chunkNumber
d248 2
a249 2
    l2gp%l2gpValue(:,:,1:l2gp%nTimes) = templ2gp%l2gpValue
    l2gp%l2gpPrecision(:,:,1:l2gp%nTimes) = templ2gp%l2gpPrecision
d251 2
a252 4
    l2gp%status(1:l2gp%nTimes) = templ2gp%status
    l2gp%quality(1:l2gp%nTimes) = templ2gp%quality

    l2gp%nTimes=newNTimes
d1142 3
@


2.11
log
@Uncommented EXTERNAL SWRDFLD until swapi done
@
text
@d16 1
a16 1
  USE SWAPI, ONLY: SWWRFLD!,SWRDFLD
d19 2
a20 2
  INTEGER :: SWRDFLD
  EXTERNAL SWRDFLD !Should USE SWAPI
d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.10 2001/02/02 17:15:02 livesey Exp $"
d1144 3
@


2.10
log
@Changed order of DIM_NAME12 and DIM_NAME123, this should be right now!
@
text
@d19 2
a20 2
  INTEGER:: SWRDFLD
!  EXTERNAL SWRDFLD !Should USE SWAPI
d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.9 2001/01/29 18:17:49 livesey Exp $"
d1144 3
@


2.9
log
@Changed status, quality and frequency to upper case first character.
@
text
@d20 1
a20 1
  EXTERNAL SWRDFLD !Should USE SWAPI
d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.8 2000/12/04 23:43:59 vsnyder Exp $"
d55 2
a56 2
   CHARACTER (len=*), PARAMETER :: DIM_NAME12 = 'nLevels,nTimes'
   CHARACTER (len=*), PARAMETER :: DIM_NAME123 = 'nFreqs,nLevels,nTimes'
d1144 3
@


2.8
log
@Move more of addItemToDatabase into the include
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.7 2000/09/22 14:29:42 pumphrey Exp $"
d38 2
a39 2
   CHARACTER (len=*), PARAMETER :: DATA_FIELD3 = 'status'
   CHARACTER (len=*), PARAMETER :: DATA_FIELD4 = 'quality'
d48 1
a48 1
   CHARACTER (len=*), PARAMETER :: GEO_FIELD8 = 'chunkNumber'
d50 1
a50 1
   CHARACTER (len=*), PARAMETER :: GEO_FIELD10= 'frequency'
d1144 3
@


2.7
log
@OutputL2GP_createFile was setting LocalSolarTime as byte (should be
REAL)  and Time as REAL (should be Double prec.). Fixed.
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.6 2000/09/21 13:48:18 pumphrey Exp $"
a278 1
    database(newSize) = item
d1144 4
@


2.6
log
@fixed a bug in the write routine.
@
text
@d13 1
a13 1
  USE Hdf, ONLY: DFNT_CHAR8, DFNT_FLOAT32, DFNT_INT32
d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.5 2000/09/19 12:42:11 pumphrey Exp $"
d719 1
a719 1
    status = swdefgfld(swid, GEO_FIELD3, DIM_NAME1, DFNT_FLOAT32, &
d726 1
a726 1
    status = swdefgfld(swid, GEO_FIELD4, DIM_NAME1, DFNT_CHAR8, &
d921 1
a921 1
         REAL(l2gp%time))
d1145 3
@


2.5
log
@added chunkNumber to SetupNewL2GPRecord and other bug fixes
@
text
@d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.4 2000/09/18 10:19:49 pumphrey Exp $"
d608 6
a613 6
    !     status = swrdfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
    !                      l2gp%l2gpStatus)
    !     IF (status == -1) THEN
    !        msr = MLSMSG_L2GPRead // DATA_FIELD3
    !        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    !     ENDIF
d1026 1
a1026 1

d1034 2
a1035 1
    swid = swattach (l2FileHandle, l2gp%name)
d1037 1
a1037 1

d1054 1
a1054 1

d1059 1
d1073 1
a1073 1

d1090 4
a1093 3
    !status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
    !     l2gp%status) ! absoft f90 barfs here
    status=-1
d1145 3
@


2.4
log
@Removed some debugging statements.
@
text
@d20 1
a20 1
  EXTERNAL::SWRDFLD !Should USE SWAPI
d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.1 2000/09/15 21:50:18 livesey Exp $"
d165 1
d352 1
a352 1
    IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d1142 3
@


2.3
log
@Made sure SWRDFLD was declared external (for the moment)
@
text
@d274 3
a276 2

    INCLUDE "../mlspgs/lib/addItemToDatabase.f9h" !remove path before commit
d381 1
a381 1
       print*,"nLevels =", size
a441 1
    print*,"l2gp%nLevels=",l2gp%nLevels
d455 1
a455 3
    print*,"Start=",start
    print*,"Edge=",edge
    print*,"stride=",stride
a527 5
       print*,"realSurf=",realsurf
       print*,"Status=",status
       print*,"Start=",start
       print*,"Edge=",edge
       print*,"stride=",stride
a528 1
       print*,"L2GP%PRssures=",l2gp%pressures
a529 1
       print*,"L2GP%PRssures=",l2gp%pressures
@


2.2
log
@corrected a number of bugs so it now compiles links and runs OK
@
text
@d16 1
a16 1
  USE SWAPI, ONLY: SWWRFLD,SWRDFLD
d19 2
a20 2
!  INTEGER:: SWRDFLD
!  EXTERNAL::SWRDFLD !Should USE SWAPI
@


2.1
log
@New version of L2GP data, moved some stuff from l2 to lib
@
text
@d14 4
a17 4
  USE HDFEOS, ONLY: SWATTACH, SWCREATE, SWDEFDFLD, SWDEFDIM, SWDEFGFLD, &
     & SWDETACH
  USE SWAPI, ONLY: SWWRFLD

d19 2
a20 1

d23 1
a23 1
       & "$Id: L2GPData.f90,v 2.0 2000/09/05 18:57:03 ahanzel Exp $"
d36 2
a37 2
   CHARACTER (len=*), PARAMETER :: DATA_FIELD1 = 'l2gpValue'
   CHARACTER (len=*), PARAMETER :: DATA_FIELD2 = 'l2gpPrecision'
d41 7
a47 7
   CHARACTER (len=*), PARAMETER :: GEO_FIELD1 = 'latitude'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD2 = 'longitude'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD3 = 'time'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD4 = 'solarTime'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD5 = 'solarZenith'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD6 = 'losAngle'
   CHARACTER (len=*), PARAMETER :: GEO_FIELD7 = 'geodAngle'
d49 1
a49 1
   CHARACTER (len=*), PARAMETER :: GEO_FIELD9 = 'pressures'
d143 3
a145 3

    useNLevels=MIN(useNLevels,1)
    useNFreqs=MIN(useNFreqs,1)    
d275 1
a275 1
    INCLUDE "addItemToDatabase.f9h"
d330 1
a330 1
    INTEGER, EXTERNAL :: swattach, swdetach, swdiminfo, swinqdims, swrdfld
d370 1
a370 1

d380 1
d439 3
a441 3
    nFreqsOr1=MIN(nFreqs,1)
    nLevelsOr1=MIN(nLevelsOr1)

d455 4
a458 2

    status = swrdfld(swid, GEO_FIELD1, start(3), stride(3), edge(3), &
d466 1
a466 1
    status = swrdfld(swid, GEO_FIELD2, start(3), stride(3), edge(3), &
d474 1
a474 1
    status = swrdfld(swid, GEO_FIELD3, start(3), stride(3), edge(3), &
d481 1
a481 1
    status = swrdfld(swid, GEO_FIELD4, start(3), stride(3), edge(3), &
d489 1
a489 1
    status = swrdfld(swid, GEO_FIELD5, start(3), stride(3), edge(3), &
d497 1
a497 1
    status = swrdfld(swid, GEO_FIELD6, start(3), stride(3), edge(3), &
d505 1
a505 1
    status = swrdfld(swid, GEO_FIELD7, start(3), stride(3), edge(3), &
d513 1
a513 1
    status = swrdfld(swid, GEO_FIELD8, start(3), stride(3), edge(3), &
d524 1
a524 1
       status = swrdfld(swid, GEO_FIELD9, start(2), stride(2), edge(2), &
d530 7
d538 1
d548 1
a548 1
       status = swrdfld(swid, GEO_FIELD10, start(1), stride(1), edge(1), &
d596 1
a596 1
       status = swrdfld( swid, DATA_FIELD1, start(3), stride(3), edge(3), &
d604 1
a604 1
       status = swrdfld( swid, DATA_FIELD2, start(3), stride(3), edge(3), &
d616 1
a616 1
    !     status = swrdfld(swid, DATA_FIELD3, start(3), stride(3), edge(3), &
d623 1
a623 1
    status = swrdfld(swid, DATA_FIELD4, start(3), stride(3), edge(3), &
d867 1
a867 1
       CALL MLSMessage ( MLSMSG, Error, ModuleName, &
d1042 1
a1042 2
    CALL get_string ( l2gp%name, name )
    swid = swattach (l2FileHandle, name)
d1096 3
a1098 2
    status = swwrfld(swid, DATA_FIELD3, start(3:3), stride(3:3), edge(3:3), &
         l2gp%status)
d1133 1
a1133 1
    TYPE (L2GPData_T), INTENT(IN) :: l2gp
d1150 3
@


1.14
log
@moved to mlspgs/l2
@
text
@d5 2
a6 2
MODULE L2GPData                 ! Data types for storing L2GP data internally
!=============================================================================
d8 9
a16 3
  USE MLSMessageModule
  USE MLSCommon
  USE MLSStrings
a19 1
  PRIVATE :: Id, ModuleName
d21 4
a24 3
  CHARACTER (LEN=256) :: Id = &
       "$Id: L2GPData.f90,v 1.13 2000/06/30 00:43:08 lungu Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: L2GPData.f90,v $"
d31 28
a58 2
  INTEGER, PARAMETER :: L2GPNameLen=80
  INTEGER, PARAMETER, PRIVATE :: CCSDSLen=32
d64 4
a67 1
    CHARACTER (LEN=L2GPNameLen) :: Name ! Name for quantity to be output
d69 1
a69 3
    INTEGER :: noProfs           ! Total number of profiles
    INTEGER :: noSurfs           ! Total number of surfaces
    INTEGER :: noFreqs           ! Number of frequencies in breakdown
d71 3
a73 2
    ! Now we store the geolocation fields, first the vertical one:
    REAL (R8), POINTER, DIMENSION(:) :: pressures ! Vertical coords (noSurfs)
d75 2
a76 6
    ! Now the horizontal geolocation information. Dimensioned (noProfs)
    REAL (R8), POINTER, DIMENSION(:) :: latitude,longitude,solarTime, &
         & solarZenith, losAngle, geodAngle
    REAL (R8), POINTER, DIMENSION(:) :: time
    INTEGER, POINTER, DIMENSION(:) :: chunkNumber
    CHARACTER (LEN=CCSDSLen), POINTER, DIMENSION(:) :: ccsdsTime
d78 5
a82 1
    ! Now we store the `frequency' geolocation field
d84 1
a84 2
    REAL (R8), POINTER, DIMENSION(:) :: frequency
    !        dimensioned (noFreqs)
d86 2
a87 1
    ! Finally we store the data fields
d89 1
a89 3
    REAL (R8), POINTER, DIMENSION(:,:,:) :: l2gpValue
    REAL (R8), POINTER, DIMENSION(:,:,:) :: l2gpPrecision
    ! dimensioned (noFreqs, noSurfs, noProfs)
d91 8
a98 4
    CHARACTER (LEN=1), POINTER, DIMENSION(:) :: l2gpStatus
    !                (status is a reserved word in F90)
    REAL (R8), POINTER, DIMENSION(:) :: quality
    ! Both the above dimensioned (noProfs)
d102 1
a102 3
CONTAINS

  !---------------------------------------------------------------------------
d104 2
a105 1
  ! This first routine sets up the arrays for an l2gp datatype.
d107 1
a107 1
  SUBROUTINE SetupNewL2GPRecord(noProfs,noSurfs,noFreqs,l2gp)
d110 2
a111 2
    INTEGER, INTENT(IN) :: noProfs,noSurfs,noFreqs ! Dimensions
    TYPE (L2GPData_T), INTENT(OUT)  :: l2gp
d114 58
a171 1
    INTEGER :: status,surfsArrayLen
a172 36
    IF (noSurfs/=0) THEN
       surfsArrayLen=noSurfs
       ALLOCATE (l2gp%pressures(noSurfs),STAT=status)
       IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//"l2gp%pressure")
    ELSE
       surfsArrayLen=1          ! For allocating the data
    ENDIF

    ALLOCATE (l2gp%latitude(noProfs), l2gp%longitude(noProfs), &
         & l2gp%solarTime(noProfs), l2gp%solarZenith(noProfs), &
         & l2gp%losAngle(noProfs), l2gp%geodAngle(noProfs), &
         & l2gp%chunkNumber(noProfs), l2gp%ccsdsTime(noProfs), &
         & l2gp%time(noProfs), STAT=status)
    IF (status /=0) CALL MLSMessage(MLSMSG_error,ModuleName, &
         & MLSMSG_Allocate//"l2gp horizontal coordinates")

    IF (noFreqs/=0) THEN
       ALLOCATE (l2gp%frequency(noFreqs),STAT=status)
       IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
            & MLSMSG_Allocate//"l2gp%frequency")
    END IF

    ALLOCATE (l2gp%l2gpValue(MAX(1,noFreqs),surfsArrayLen,noProfs), &
         & l2gp%l2gpPrecision(MAX(1,noFreqs),surfsArrayLen,noProfs), &
         & STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"l2gp data/precision fields")

    ALLOCATE (l2gp%l2gpStatus(noProfs),l2gp%quality(noProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"l2gp status/quality fields")

    l2gp%noProfs=noProfs
    l2gp%noSurfs=noSurfs
    l2gp%noFreqs=noFreqs
a173 2
    
  !---------------------------------------------------------------------------
d175 2
a176 1
  ! This routine deallocates all the arrays allocated above.
d178 1
a178 1
  SUBROUTINE DestroyL2GPContents(l2gp)
d181 1
a181 1
    TYPE (L2GPData_T), INTENT(INOUT) :: l2gp
d184 1
a184 1
    integer status
d188 18
a205 49
    IF (ASSOCIATED(l2gp%pressures)) DEALLOCATE(l2gp%pressures, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /pressures")

    IF (ASSOCIATED(l2gp%latitude))DEALLOCATE(l2gp%latitude, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /latitude")
    IF (ASSOCIATED(l2gp%longitude))DEALLOCATE( l2gp%longitude, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /longitude") 
    IF (ASSOCIATED(l2gp%solarTime))DEALLOCATE(l2gp%solarTime, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /solarTime")
    IF (ASSOCIATED(l2gp%solarZenith))DEALLOCATE(l2gp%solarZenith, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /solarZenith") 
    IF (ASSOCIATED(l2gp%losAngle))DEALLOCATE(l2gp%losAngle, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /pressures")
    IF (ASSOCIATED(l2gp%geodAngle))DEALLOCATE(l2gp%geodAngle, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /geodAngle")
    IF (ASSOCIATED(l2gp%chunkNumber))DEALLOCATE(l2gp%chunkNumber, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /chunkNumber") 
    IF (ASSOCIATED(l2gp%ccsdsTime))DEALLOCATE(l2gp%ccsdsTime, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /ccsdsTime")
    IF (ASSOCIATED(l2gp%time))DEALLOCATE(l2gp%time, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /time")
    IF (ASSOCIATED(l2gp%frequency))DEALLOCATE(l2gp%frequency, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /frequency")
    IF (ASSOCIATED(l2gp%l2gpValue))DEALLOCATE(l2gp%l2gpValue, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /l2gpValue")
    IF (ASSOCIATED(l2gp%l2gpPrecision))DEALLOCATE(l2gp%l2gpPrecision, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /l2gpPrecision")
    IF (ASSOCIATED(l2gp%l2gpStatus))DEALLOCATE(l2gp%l2gpStatus, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /l2gpStatus")
    IF (ASSOCIATED(l2gp%quality))DEALLOCATE(l2gp%quality, STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"l2gp /quality")
    l2gp%noProfs=0
    l2gp%noSurfs=0
    l2gp%noFreqs=0
d208 2
a209 1
  !---------------------------------------------------------------------------
d211 2
a212 4
  ! This subroutine expands an L2GPData_T in place allowing the user to add
  ! more profiles to it.

  SUBROUTINE ExpandL2GPDataInPlace(l2gp,newNoProfs)
d215 2
a216 2
    TYPE (L2GPData_T), INTENT(INOUT) :: l2gp
    INTEGER, INTENT(IN) :: newNoProfs
d219 3
a221 7
    INTEGER :: status           ! From ALLOCATE
    ! The following are temporary arrays for copying data around.
    REAL (r8), DIMENSION(:), POINTER :: temp1D
    REAL (r8), DIMENSION(:,:,:), POINTER :: temp3D
    INTEGER, DIMENSION(:), POINTER :: 	tempInt1D
    CHARACTER (LEN=1), DIMENSION(:), POINTER :: tempChar1D
    CHARACTER (LEN=CCSDSLen), DIMENSION(:), POINTER :: tempCCSDS
d223 9
d233 1
a233 1
    NULLIFY (temp1D, temp3D, tempChar1D, tempCCSDS)
d235 20
a254 1
    ! First do a sanity check
d256 1
a256 124
    IF (newNoProfs<l2gp%noProfs) CALL MLSMessage(MLSMSG_Error,ModuleName, &
      & "The number of profiles requested is fewer than those already present")
    
    ! Now go through the parameters one by one, allocate new space, copy
    ! the previous contents, and remove the old information.
    temp1D=>l2gp%latitude
    ALLOCATE(l2gp%latitude(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%latitude")
    l2gp%latitude(1:l2gp%noProfs)=temp1D
    DEALLOCATE(temp1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp1D")
    temp1D=>l2gp%longitude
    ALLOCATE(l2gp%longitude(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%longitude")
    l2gp%longitude(1:l2gp%noProfs)=temp1D
    DEALLOCATE(temp1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp1D")
    temp1D=>l2gp%solarTime
    ALLOCATE(l2gp%solarTime(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%solarTime")
    l2gp%solarTime(1:l2gp%noProfs)=temp1D
    DEALLOCATE(temp1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp1D")
    temp1D=>l2gp%solarZenith
    ALLOCATE(l2gp%solarZenith(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%solarZenith")
    l2gp%solarZenith(1:l2gp%noProfs)=temp1D
    DEALLOCATE(temp1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp1D")
    temp1D=>l2gp%losAngle
    ALLOCATE(l2gp%losAngle(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%losAngle")
    l2gp%losAngle(1:l2gp%noProfs)=temp1D
    DEALLOCATE(temp1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp1D")
    temp1D=>l2gp%geodAngle
    ALLOCATE(l2gp%geodAngle(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%geodAngle")
    l2gp%geodAngle(1:l2gp%noProfs)=temp1D
    DEALLOCATE(temp1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp1D")
    temp1D=>l2gp%time
    ALLOCATE(l2gp%time(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%time")
    l2gp%time(1:l2gp%noProfs)=temp1D
    DEALLOCATE(temp1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp1D")

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

    tempInt1D=>l2gp%chunkNumber
    ALLOCATE(l2gp%chunkNumber(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%chunkNumber")
    l2gp%chunkNumber(1:l2gp%noProfs)=tempInt1D
    DEALLOCATE(tempInt1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"tempInt1D")

    
    tempCCSDS=>l2gp%ccsdsTime
    ALLOCATE(l2gp%ccsdsTime(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%ccsdsTime")
    l2gp%ccsdsTime(1:l2gp%noProfs)=tempCCSDS
    DEALLOCATE(tempCCSDS, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"tempCCSDS")

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

    temp3D=>l2gp%l2gpValue

  
 
    ALLOCATE(l2gp%l2gpValue(l2gp%noFreqs,l2gp%noSurfs,newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%l2gpValue")
    l2gp%l2gpValue(:,:,1:l2gp%noProfs)=temp3D
    DEALLOCATE(temp3D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp3D")

    temp3D=>l2gp%l2gpPrecision
    ALLOCATE(l2gp%l2gpPrecision(l2gp%noFreqs,l2gp%noSurfs,newNoProfs), &
         & STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%l2gpPrecision")
    l2gp%l2gpPrecision(:,:,1:l2gp%noProfs)=temp3D
    DEALLOCATE(temp3D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp3D")

    tempChar1D=>l2gp%l2gpStatus
    ALLOCATE(l2gp%l2gpStatus(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%l2gpStatus")
    l2gp%l2gpStatus(1:l2gp%noProfs)=tempChar1D
    DEALLOCATE(tempChar1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp3D")

    temp1D=>l2gp%quality
    ALLOCATE(l2gp%quality(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%quality")
    l2gp%quality(1:l2gp%noProfs)=temp1D
    DEALLOCATE(temp1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp1D")
a257 1
    l2gp%noProfs=newNoProfs
d260 2
a261 4
  !---------------------------------------------------------------------------

  ! This subroutine adds an l2gp data type to a database of said types,
  ! creating a new database if it doesn't exist
d263 3
a265 1
  SUBROUTINE AddL2GPToDatabase(database,l2gp)
d268 2
a269 2
    TYPE (L2GPData_T), DIMENSION(:), POINTER :: database
    TYPE (L2GPData_T), INTENT(IN) :: l2gp
a272 1
    INTEGER :: newSize,status
d274 1
a274 1
    ! Executable code
d276 3
a278 21
    IF (ASSOCIATED(database)) THEN
       ! Check we don't already have one of this name
       IF (LinearSearchStringArray(database%name,l2gp%name, &
            & caseInsensitive=.TRUE.)/=0) CALL MLSMessage(MLSMSG_Error,&
            & ModuleName,MLSMSG_Duplicate//l2gp%name)
       newSize=SIZE(database)+1
    ELSE
       newSize=1
    ENDIF

    ALLOCATE(tempDatabase(newSize),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & "Allocation failed for tempDatabase")

    IF (newSize>1) tempDatabase(1:newSize-1)=database
    tempDatabase(newSize)=l2gp
    IF (ASSOCIATED(database))DEALLOCATE(database, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"database")
    database=>tempDatabase
  END SUBROUTINE AddL2GPToDatabase
d284 1
a284 1
  SUBROUTINE DestroyL2GPDatabase(database)
d287 1
a287 1
    TYPE (L2GPData_T), DIMENSION(:), POINTER :: database
d292 373
a664 7
    IF (ASSOCIATED(database)) THEN
       DO l2gpIndex=1,SIZE(database)
          CALL DestroyL2GPContents(database(l2gpIndex))
       ENDDO
       DEALLOCATE(database, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"database")
a665 1
  END SUBROUTINE DestroyL2GPDatabase
d667 464
d1132 1
a1132 1
!=============================================================================
d1138 2
a1139 40
! Revision 1.13  2000/06/30 00:43:08  lungu
! Removed duplicate code for l2gptime and chunknumber
! which caused allocation problems.
!
! Revision 1.12  2000/06/19 22:59:16  lungu
! Added status check after DEALLOCATE.
!
! Revision 1.11  2000/05/17 23:38:14  lungu
! Added check "IF (ASSOCIATED(database))DEALLOCATE(database)" so it doesn't chrash trying to dealocate
! an "empty" database.
!
! Revision 1.10  2000/01/17 21:18:06  livesey
! Added the ExpandL2GPDataInPlace routine and removed accumulated profiles
!
! Revision 1.9  2000/01/12 20:28:20  livesey
! Modified to allow for noSurfs=0 quantitites
!
! Revision 1.8  1999/12/21 19:00:10  livesey
! Typo in accumulatedProfiles
!
! Revision 1.7  1999/12/21 00:15:15  livesey
! Added accumulatedProfiles to L2GPData_T for Join
!
! Revision 1.6  1999/12/18 01:06:28  livesey
! Added USE of MLSStrings
!
! Revision 1.5  1999/12/17 21:41:31  livesey
! Added check for duplicate name
!
! Revision 1.4  1999/12/14 00:53:50  livesey
! Changed DOUBLE PRECISION to REAL(r8)
!
! Revision 1.3  1999/12/03 22:24:50  livesey
! Tidied up some of the INTENT stuff
!
! Revision 1.2  1999/12/03 21:28:56  livesey
! Renamed L2GP_T to L2GPData_T
!
! Revision 1.1  1999/12/03 19:10:34  livesey
! First version
d1141 2
@


1.13
log
@Removed duplicate code for l2gptime and chunknumber
which caused allocation problems.
@
text
@d17 1
a17 1
       "$Id: L2GPData.f90,v 1.12 2000/06/19 22:59:16 lungu Exp $"
d405 4
@


1.12
log
@Added status check after DEALLOCATE.
@
text
@d17 1
a17 1
       "$Id: L2GPData.f90,v 1.11 2000/05/17 23:38:14 lungu Exp $"
d39 1
a39 1
    DOUBLE PRECISION, POINTER, DIMENSION(:) :: pressures ! Vertical coords (noSurfs)
d42 1
a42 1
    DOUBLE PRECISION, POINTER, DIMENSION(:) :: latitude,longitude,solarTime, &
d44 1
a44 1
    DOUBLE PRECISION, POINTER, DIMENSION(:) :: time
d50 1
a50 1
    DOUBLE PRECISION, POINTER, DIMENSION(:) :: frequency
d55 2
a56 2
    DOUBLE PRECISION, POINTER, DIMENSION(:,:,:) :: l2gpValue
    DOUBLE PRECISION, POINTER, DIMENSION(:,:,:) :: l2gpPrecision
d61 1
a61 1
    DOUBLE PRECISION, POINTER, DIMENSION(:) :: quality
d200 1
a200 1
    INTEGER, DIMENSION(:), POINTER :: tempInt1D
a202 1
!    print *, 'newNoProfs ', newNoProfs
d205 2
a213 1

a221 1

a229 1

a237 1

a245 1

a253 1

a261 10

    temp1D=>l2gp%time
    ALLOCATE(l2gp%time(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%time")
    l2gp%time(1:l2gp%noProfs)=temp1D
    DEALLOCATE(temp1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"temp1D")

a281 8
    tempInt1D=>l2gp%chunkNumber
    ALLOCATE(l2gp%chunkNumber(newNoProfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         & "l2gp%chunkNumber")
    l2gp%chunkNumber(1:l2gp%noProfs)=tempInt1D
    DEALLOCATE(tempInt1D, stat=status)
    IF (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_DeAllocate//"tempInt1D")
a334 1
!    print *, ' l2gp%noProfs ', l2gp%noProfs
d405 3
@


1.11
log
@Added check "IF (ASSOCIATED(database))DEALLOCATE(database)" so it doesn't chrash trying to dealocate
an "empty" database.
@
text
@d17 1
a17 1
       "$Id: L2GPData.f90,v 1.10 2000/01/17 21:18:06 livesey Exp $"
d26 1
a26 1
  INTEGER, PARAMETER, PRIVATE :: CCSDSLen=27
d39 1
a39 1
    REAL(r8), POINTER, DIMENSION(:) :: pressures ! Vertical coords (noSurfs)
d42 1
a42 1
    REAL(r8), POINTER, DIMENSION(:) :: latitude,longitude,solarTime, &
d44 1
a44 1
    REAL(r8), POINTER, DIMENSION(:) :: time
d50 1
a50 1
    REAL(r8), POINTER, DIMENSION(:) :: frequency
d55 2
a56 2
    REAL(r8), POINTER, DIMENSION(:,:,:) :: l2gpValue
    REAL(r8), POINTER, DIMENSION(:,:,:) :: l2gpPrecision
d61 1
a61 1
    REAL(r8), POINTER, DIMENSION(:) :: quality
d94 1
a94 1
         & STAT=status)
d127 3
d133 46
a178 7
    IF (ASSOCIATED(l2gp%pressures)) DEALLOCATE(l2gp%pressures)
    DEALLOCATE(l2gp%latitude, l2gp%longitude, l2gp%solarTime, &
         & l2gp%solarZenith, l2gp%losAngle, l2gp%geodAngle, &
         & l2gp%chunkNumber, l2gp%ccsdsTime)
    DEALLOCATE(l2gp%frequency)
    DEALLOCATE(l2gp%l2gpValue,l2gp%l2gpPrecision)
    DEALLOCATE(l2gp%l2gpStatus,l2gp%quality)
d203 1
a203 1

d219 3
a221 1
    DEALLOCATE(temp1D)
d228 3
a230 1
    DEALLOCATE(temp1D)
d237 3
a239 1
    DEALLOCATE(temp1D)
d246 3
a248 1
    DEALLOCATE(temp1D)
d255 3
a257 1
    DEALLOCATE(temp1D)
d264 3
a266 1
    DEALLOCATE(temp1D)
d273 3
a275 1
    DEALLOCATE(temp1D)
d282 3
a284 1
    DEALLOCATE(temp1D)
d293 3
a295 1
    DEALLOCATE(tempInt1D)
d302 3
a304 1
    DEALLOCATE(tempInt1D)
d311 3
a313 1
    DEALLOCATE(tempCCSDS)
d318 4
a321 1
    ALLOCATE(l2gp%l2gpValue(newNoProfs,l2gp%noSurfs,l2gp%noFreqs),STAT=status)
d324 4
a327 2
    l2gp%l2gpValue(1:l2gp%noProfs,:,:)=temp3D
    DEALLOCATE(temp3D)
d330 1
a330 1
    ALLOCATE(l2gp%l2gpPrecision(newNoProfs,l2gp%noSurfs,l2gp%noFreqs), &
d334 4
a337 2
    l2gp%l2gpPrecision(1:l2gp%noProfs,:,:)=temp3D
    DEALLOCATE(temp3D)
d344 3
a346 1
    DEALLOCATE(tempChar1D)
d353 3
a355 1
    DEALLOCATE(temp1D)
d358 1
a358 1

d394 3
a396 1
    IF (ASSOCIATED(database))DEALLOCATE(database)
d410 1
a410 1
    INTEGER :: l2gpIndex
d416 3
a418 1
       DEALLOCATE(database)
d429 4
@


1.10
log
@Added the ExpandL2GPDataInPlace routine and removed accumulated profiles
@
text
@d17 1
a17 1
       "$Id: L2GPData.f90,v 1.9 2000/01/12 20:28:20 livesey Exp $"
d319 1
a319 1
    DEALLOCATE(database)
d350 3
@


1.9
log
@Modified to allow for noSurfs=0 quantitites
@
text
@d17 1
a17 1
       "$Id: L2GPData.f90,v 1.8 1999/12/21 19:00:10 livesey Exp $"
d39 1
a39 1
    REAL, POINTER, DIMENSION(:) :: pressures ! Vertical coordinates (noSurfs)
d42 1
a42 1
    REAL, POINTER, DIMENSION(:) :: latitude,longitude,solarTime, &
d55 2
a56 2
    REAL, POINTER, DIMENSION(:,:,:) :: l2gpValue
    REAL, POINTER, DIMENSION(:,:,:) :: l2gpPrecision
d61 1
a61 1
    REAL, POINTER, DIMENSION(:) :: quality
a63 4
    INTEGER :: accumulatedProfiles
    ! This last one is needed by Join to keep track of which profiles
    ! have been output so far.

d144 144
d350 3
@


1.8
log
@Typo in accumulatedProfiles
@
text
@d17 1
a17 1
       "$Id: L2GPData.f90,v 1.7 1999/12/21 00:15:15 livesey Exp $"
d83 1
a83 1
    INTEGER :: status
d85 8
a92 3
    ALLOCATE (l2gp%pressures(noSurfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
         & MLSMSG_Allocate//"l2gp%pressure")
d108 3
a110 2
    ALLOCATE (l2gp%l2gpValue(MAX(1,noFreqs),noSurfs,noProfs), &
         & l2gp%l2gpPrecision(MAX(1,noFreqs),noSurfs,noProfs), STAT=status)
d134 1
a134 1
    DEALLOCATE(l2gp%pressures)
d210 3
@


1.7
log
@Added accumulatedProfiles to L2GPData_T for Join
@
text
@d17 1
a17 1
       "$Id: L2GPData.f90,v 1.6 1999/12/18 01:06:28 livesey Exp $"
d64 1
a64 1
    INTEGER :: accumulatdProfiles
d204 3
@


1.6
log
@Added USE of MLSStrings
@
text
@d17 1
a17 1
       "$Id: L2GPData.f90,v 1.5 1999/12/17 21:41:31 livesey Exp $"
d64 4
d204 3
@


1.5
log
@Added check for duplicate name
@
text
@d10 1
d17 1
a17 1
       "$Id: L2GPData.f90,v 1.4 1999/12/14 00:53:50 livesey Exp $"
d200 3
@


1.4
log
@Changed DOUBLE PRECISION to REAL(r8)
@
text
@d16 1
a16 1
       "$Id: L2GPData.f90,v 1.3 1999/12/03 22:24:50 livesey Exp $"
d153 4
d199 3
@


1.3
log
@Tidied up some of the INTENT stuff
@
text
@d9 1
d16 1
a16 1
       "$Id: L2GPData.f90,v 1.2 1999/12/03 21:28:56 livesey Exp $"
d43 1
a43 1
    DOUBLE PRECISION, POINTER, DIMENSION(:) :: time
d49 1
a49 1
    DOUBLE PRECISION, POINTER, DIMENSION(:) :: frequency
d195 3
@


1.2
log
@Renamed L2GP_T to L2GPData_T
@
text
@d15 1
a15 1
       "$Id: L2GPData.f90,v 1.1 1999/12/03 19:10:34 livesey Exp $"
d74 1
a74 1
    TYPE (L2GPData_T) :: l2gp
d118 1
a118 1
    TYPE (L2GPData_T) :: l2gp
d143 1
a143 1
    TYPE (L2GPData_T) :: l2gp
d194 3
@


1.1
log
@First version
@
text
@d15 2
a16 2
       "$Id: $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile$"
d28 1
a28 1
  TYPE L2GP_T
d62 1
a62 1
  END TYPE L2GP_T
d74 1
a74 1
    TYPE (L2GP_T) :: l2gp
d118 1
a118 1
    TYPE (L2GP_T) :: l2gp
d142 2
a143 2
    TYPE (L2GP_T), DIMENSION(:), POINTER :: database
    TYPE (L2GP_T) :: l2gp
d146 1
a146 1
    TYPE (L2GP_T), DIMENSION(:), POINTER :: tempDatabase
d174 1
a174 1
    TYPE (L2GP_T), DIMENSION(:), POINTER :: database
d193 4
a196 1
! $Log$
@

