head	2.63;
access;
symbols
	v5-02-NRT-19:2.63
	v6-00:2.61
	v5-02-NRT-18:2.61
	v5-02:2.56
	v5-01-NRT-17:2.60
	v5-01-NRT-16:2.60
	v5-01-NRT-15:2.60
	v5-01-NRT-14:2.60
	neuralnetworks-1-0:2.58.0.4
	cfm-single-freq-0-1:2.58.0.2
	v5-01:2.56
	v5-00:2.56
	v4-23-TA133:2.54.0.2
	mus-emls-1-70:2.48.0.2
	rel-1-0-englocks-work:2.47.0.2
	VUMLS1-00:2.46
	VPL1-00:2.46
	V4-22-NRT-08:2.46
	VAM1-00:2.46
	V4-21:2.44.0.2
	V4-13:2.43
	V4-12:2.41
	V4-11:2.41
	V4-10:2.41
	V3-43:2.34
	M4-00:2.37
	V3-41:2.34
	V3-40-PlusGM57:2.34.0.2
	V2-24-NRT-04:2.29
	V3-33:2.35
	V2-24:2.29
	V3-31:2.35
	V3-30-NRT-05:2.34
	cfm-01-00:2.34
	V3-30:2.34
	V3-20:2.34
	V3-10:2.33
	V2-23-NRT-02:2.29
	V2-23:2.29
	V2-22-NRT-01:2.29
	V2-22:2.29
	V2-21:2.28
	V2-20:2.28
	V2-11:2.27
	V2-10:2.27
	V2-00:2.27
	V1-51:2.21
	V1-50:2.21
	V1-45:2.21
	V1-44:2.21
	V1-43:2.18
	V1-42:2.18
	V1-41:2.18
	V1-32:2.18
	V1-40:2.18
	V1-31:2.17
	V1-30:2.17
	V1-13:2.16
	V1-12:2.16
	V1-11:2.16
	V1-10:2.15
	newfwm-feb03:2.15.0.2
	V1-04:2.10
	V1-03:2.10
	V1-02:2.10
	V1-00:2.10
	newfwm-sep01:2.6.0.2
	V0-7:2.6
	V0-5-Level2:2.6
	V0-5-SIPS:2.5
	V0_1:1.13;
locks; strict;
comment	@# @;


2.63
date	2024.08.14.22.51.54;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2024.08.08.20.37.33;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2023.09.28.20.57.28;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2021.04.29.22.51.07;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2021.04.15.22.42.28;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2020.07.09.23.51.12;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2020.04.27.21.28.55;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2019.08.19.21.56.39;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2019.05.13.23.31.15;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2019.04.09.20.30.59;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2018.12.11.16.46.30;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2018.12.11.01.19.01;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2018.08.17.23.51.41;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2018.08.13.22.31.28;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2018.08.03.23.18.56;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2018.05.11.21.23.27;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2018.02.08.23.18.00;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2015.06.30.18.39.10;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2015.06.19.00.32.38;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2014.12.10.19.11.11;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2014.09.05.00.00.27;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2014.08.05.00.17.07;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2014.03.26.17.42.52;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2014.03.07.19.11.33;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2013.11.18.21.41.51;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2013.08.30.23.12.21;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2011.12.13.01.06.03;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2011.08.26.00.27.48;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2010.11.30.00.33.27;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2010.01.11.18.32.44;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2009.06.23.18.25.42;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2009.06.02.17.47.26;	author cvuu;	state Exp;
branches;
next	2.31;

2.31
date	2008.01.09.20.50.01;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2008.01.07.21.33.19;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2007.01.12.00.24.38;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2006.11.01.20.31.38;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2005.12.16.00.02.05;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2005.10.19.22.53.01;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2005.06.22.17.25.49;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2005.06.14.20.31.10;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2005.05.31.17.49.15;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2005.05.12.20.46.46;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2004.08.03.17.58.25;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2004.06.10.01.00.50;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2004.05.19.19.16.40;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2004.01.09.00.38.04;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2003.06.20.19.31.39;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2003.02.17.03.52.49;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2002.12.05.19.44.24;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2002.11.06.00.16.48;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2002.10.08.00.09.11;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2002.09.13.18.08.12;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2002.08.28.22.16.18;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2002.02.19.23.10.54;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2002.01.09.23.51.27;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2001.11.14.18.03.32;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.09.09.02.47.58;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.04.20.23.10.53;	author livesey;	state Exp;
branches
	2.6.2.1;
next	2.5;

2.5
date	2001.03.10.18.48.17;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.10.07.06.46;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.09.00.38.55;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.01.26.23.46.35;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2001.01.25.19.52.51;	author perun;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.17.41.06;	author dcuddy;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.19.23.07.46;	author lungu;	state Exp;
branches;
next	1.1;

1.1
date	99.12.14.00.45.37;	author livesey;	state Exp;
branches;
next	;

2.6.2.1
date	2001.09.08.22.32.24;	author livesey;	state Exp;
branches;
next	2.6.2.2;

2.6.2.2
date	2001.09.09.01.35.46;	author livesey;	state Exp;
branches;
next	2.6.2.3;

2.6.2.3
date	2001.09.09.01.53.27;	author livesey;	state Exp;
branches;
next	;


desc
@@


2.63
log
@Added optional arg to inRange_range
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module MLSCommon                ! Common definitions for the MLS software
!=============================================================================

  use IEEE_Arithmetic, only: IEEE_Is_Finite, IEEE_Is_Nan
  !   This doesn't result in a circular dependence.
  use Lexer_Types, only: Where_T ! Where is something in the L2CF
  use MLSKinds ! everything
  use MLSStrings_0,  only: Lowercase

  implicit none
  private

! Keep common parameters, flags, datatypes, and procedures here so
! that they may be shared by many higher-level modules
! === (start of toc) ===                                                 
!     c o n t e n t s                                                    
!     - - - - - - - -                                                    

!     (data types and parameters)

! i1, i2, i4       integer types
! r4, r8           floating point types
! ip, rp           integer, floating point types used in forward model
! rv               floating point type used in vector quantity values
! rm               floating point type used in matrix values
! rt               floating point type used in topo-set values
! LineLen          character-length of most input
! FileNameLen      character-length of path/filenames
! BareFNLen        character-length of filenames
! namelen          Max length of hdf sds array name
! fill_signal      signal to is_what_ieee to check for undefined (fill) values
! finite_signal    signal to is_what_ieee to check for finite
! inf_signal       signal to is_what_ieee to check for inf
! nan_signal       signal to is_what_ieee to check for NaN
! ShortNameLen     character-length of short names (e.g., 'H2O')
! DefaultUndefinedValue 
!                  default fill values, e.g. when creating hdf arrays
! UndefinedValue    
!                  value to check for by is_what_ieee
! HDF_Acc_Create   signal to create the hdf file
! HDF_Acc_Rdonly   signal to open the hdf file for reading only
! HDF_Acc_RdWr     signal to open the hdf file for both reading and writing
!            Bits of MASK field as used in VectorValue_T
! M_Cloud = 2**4
! M_Fill = 2**2
! M_FullDerivatives = 2**1
! M_Ignore = 2**5
! M_LinAlg = 2**0      ! Don't use in linear algebra
! M_Spare = 2**6
! M_Tikhonov = 2**3    ! Where to do Tikhonov regularization
!
!     (severity levels)
! MLS_S_Success            if status not this, then something went wrong
! MLSMSG_Success           status returned when all went well
! MLSMSG_Pause             pause execution waiting for user input
! MLSMSG_Debug             should print only if debugging turned on
! MLSMSG_Info              fyi only
! MLSMSG_Testwarning       test to see if we would print this warning
! MLSMSG_Warning           not fatal, but deserving of attention
! MLSMSG_Error             quits after printing
! MLSMSG_Crash             should give traceback before quitting
!            Derived Types
! FileIDs_T        id numbers for file, group, swath or dataset
! L1BInfo_T        L1B data file names, etc. 
!                   (Should we replace these with FileIDs?)
! L2Metadata_T     Coords of (lon,lat) box to write as metadata
! MLSChunk_T       Chunk of level 1 data for level 2 to process independently
! MLSFile_T        File name, type, id, etc.
! MLSFill_T        Fill value data type
! MLSFills         database of MLSFill values
! Range_T          Bottom, Top of PCFID range
! Interval_T       Bottom, Top of a real interval (open)
! TAI93_Range_T    start, end times in TAI93 formatted r8
!       State-defining flags
! MLSVerbose       Should we print extra stuff?
! MLSDebug         Should we print even more stuff?
! MLSVerboseSticky
!                  Retain value of MLSVerbose thoughout phase
! MLSDebugSticky
!                  Retain value of MLSDebug thoughout phase

!     (subroutines and functions)
! accessType       Converts DFACC_* <-> {l_create, l_rdwr, l_rdonly}
! DontCrashHere    May we skip otherwise obligatory crash in named modules?
! inRange          Does an argument lie within a specified range or interval
! is_what_ieee     Is an argument a specified ieee type
! split_name_extension  
!                  Splits the input name.ext into name and exxt
! split_path_name  Splits the input path/name into path and name
! === (end of toc) ===                                                   
! === (start of api) ===
! char* accessType ( int dfacc )
! int accessType ( char* str )
! log DontCrashHere( char* arge )
! log inRange( int arg, Range_T range )
! log inRange( real arg, Interval_T range )
! log is_what_ieee( type_signal what, num arg )
! split_name_extension ( char* full_file_name, char* name, char* extension,
!  [char dot] )
! split_path_name ( char* full_file_name, char* path, char* name, [char slash] )
! === (end of api) ===

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSCommon.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! This module contains simple definitions that are common to all the MLS PGS
  ! f90 software.
  
  ! We also put in these functions.
  ! Should they be relocated to other modules? Where?

  public :: AccessType
  public :: DontCrashHere
  public :: InRange
  public :: Is_what_ieee
  public :: Split_name_extension
  public :: Split_path_name
  
  ! User-defined datatypes
  public :: FileIDs_T
  public :: MLSChunk_T
  public :: MLSFile_T
  public :: MLSFill_T
  public :: L1BInfo_T
  public :: Range_T
  public :: TAI93_Range_T
  public :: L2Metadata_T
  public :: Interval_T

  ! Make parameters gotten from MLSKinds public

  public :: i1
  public :: i2
  public :: i4
  public :: r4
  public :: r8
  public :: rm
  public :: rp
  public :: ip
  public :: rt
  public :: rv
  
  ! The following are integer flags 'signalling' what kind of ieee number
  ! we would want to test for, e.g. in a multi-purpose procedure
  ! Their principal use is as args to is_what_ieee
  ! Note that the same test value can be finite and a Fill value
  ! simultaneously
  integer, public, parameter :: Finite_Signal = 0
  integer, public, parameter :: Inf_Signal    = Finite_Signal + 1
  integer, public, parameter :: Nan_Signal    = Inf_Signal + 1
  integer, public, parameter :: Fill_Signal   = Nan_Signal + 1
  integer, public, parameter :: Oldfill_Signal= Fill_Signal + 1

  ! The following are integer flags that should be consistent
  ! with hdf settings; e.g. /software/toolkit/ifc17/hdf/include/hdf.inc
  ! You may overwrite them if you wish (and have a good reason to do so)
  integer, public, parameter :: HDF_Acc_Create = 4
  integer, public, parameter :: HDF_Acc_Rdonly = 1
  integer, public, parameter :: HDF_Acc_RdWr   = 3

  ! Bit of MASK field of VectorValue_T
  integer, public, parameter :: M_Cloud = 2**4
  integer, public, parameter :: M_Fill = 2**2
  integer, public, parameter :: M_FullDerivatives = 2**1
  integer, public, parameter :: M_Ignore = 2**5
  integer, public, parameter :: M_LinAlg = 2**0      ! Don't use in linear algebra
  integer, public, parameter :: M_Spare = 2**6
  integer, public, parameter :: M_Tikhonov = 2**3    ! Where to do Tikhonov regularization

  ! Define some low level parameters.  These are used by the calling code to
  ! indicate the severity or otherwise of the messages.
  ! Normally, we treat any severity of Error or worse as reason to stop.
  ! Any Warning is worth recording, and suppressed when too numerous.
  ! Info may be customized to show, phase name, chunk number, etc.
  ! Be advised, Crash may not properly close files opened by your run.
  ! Use it only for specific debugging where you need a walkback.
  ! See also MLSMessageConfig%crashOnAnyError

  integer, public, parameter :: MLS_S_Success = 0
  integer, public, parameter :: MLSMSG_Success     = MLS_S_Success ! == 0
  integer, public, parameter :: MLSMSG_Pause       = MLSMSG_Success + 1
  integer, public, parameter :: MLSMSG_Debug       = MLSMSG_Pause + 1
  integer, public, parameter :: MLSMSG_Info        = MLSMSG_Debug + 1
  integer, public, parameter :: MLSMSG_TestWarning = MLSMSG_Info + 1
  ! The next 3 should always be the highest, i.e. most sevre
  integer, public, parameter :: MLSMSG_Warning     = MLSMSG_TestWarning + 1
  integer, public, parameter :: MLSMSG_Error       = MLSMSG_Warning + 1
  integer, public, parameter :: MLSMSG_Crash       = MLSMSG_Error + 1

  ! Unless you fill the string table with l_ quantities from intrinsic
  ! make sure the next entry is .false. 
  ! (or else it will segment fault in get_string)
  ! MLSL2 does fill the string table, but many tools do not
  logical, save, public :: FILESTRINGTABLE = .FALSE.

  interface accessType
    module procedure accessDFACCToStr
    module procedure accessStrToDFACC
  end interface

  ! Not just "is" but "=", because "is" may satisfy looser conditions
  interface equalsFillValue
    module procedure equalsFillValue_r4, equalsFillValue_r8, equalsFillValue_int
  end interface

  interface inRange
    module procedure inRange_r4, inRange_r8, inRange_int, inRange_range
  end interface

  interface is_a_fill_value
    module procedure is_a_fill_value_r4, is_a_fill_value_r8, is_a_fill_value_int
  end interface

  interface is_what_ieee
    module procedure is_what_ieee_r4, is_what_ieee_r8, is_what_ieee_integer
    module procedure is_what_ieee_character
  end interface
  
  !-----------------------------------------------------------
  !   P a r a m e t e r s   a n d    D a t a t y p e s
  !-----------------------------------------------------------
  logical, public :: MLSVerbose = .false. ! Should we print extra stuff?
  logical, public :: MLSDebug =   .false. ! Should we print even more stuff?
  logical, public :: MLSVerboseSticky = .false. ! Always, not just by module
  logical, public :: MLSDebugSticky =   .false. ! Always, not just by module
  integer, parameter :: DEBUGNAMESLEN = 256
  character(len=DEBUGNAMESLEN), public, save :: MLSNamesAreDebug   = ' '
  character(len=DEBUGNAMESLEN), public, save :: MLSNamesAreVerbose = ' '
  character(len=DEBUGNAMESLEN), public, save :: MLSNamesDontCrash = ' '
  ! Because we'd like not to always drag the SDPToolkit with us
  ! everywhere we go
  integer, private, parameter :: PGSd_PC_FILE_PATH_MAX = 1024

  ! Now we have the lengths for various strings

  integer, public, parameter :: ShortNameLen = 32
  integer, public, parameter :: NameLen      = 64  ! Max len of SDS array name
  integer, public, parameter :: LineLen      = 132
  integer, public, parameter :: FileNameLen  = max(PGSd_PC_FILE_PATH_MAX, 132) ! was 132
  integer, public, parameter :: BareFNLen    = 64  ! Bare file name length (w/o path)

  ! The next are used for tracking allocated memory
  ! (The 1st is public to enable reporting finer or coarser grains)
  !  real, save, public  :: MEMORY_UNITS = 1024. ! Report nothing smaller than KB
  integer, save, public          :: NoBlocksAllocated = 0 ! Num allocate calls
  integer, save, public          :: NoBlocksDeAllocated = 0 ! Num deallocate calls
  double precision, save, public :: NoBytesAllocated = 0.0d0 ! Net MEMORY_UNITS allocated.
  double precision, save, public :: TotalAllocated = 0.0d0 ! Total allocated.
  double precision, save, public :: TotalDeAllocated = 0.0d0 ! Total deallocated.

  !----------------------------------------------------------------------
  !         Undefined value
  ! This can be set to a different value if that would be more convenient
  ! Undefined value has two possible uses:
  ! (1) on output, it may be pre-assigned to every numerically-valued
  ! entry. If any persist after the algorithm completes, that would
  ! be a sign the algorithm failed to calculate a valid result for that
  ! entry; e.g., it may have encountered input data outside its range of validity

  ! (2) on input, entries may be checked against it for a signal that the data
  ! should be ignored or that it is a Fill value
  
  ! On the other hand, we may phase (2) out in favor of the MLSFills
  ! mechanism; see below
  real(r4), public, parameter :: DefaultUndefinedValue = -999.99 ! Try to use in lib, l2
  integer, public, parameter  :: UndefinedIntegerValue = -999 ! Use for int fields
  real(r4), public, parameter :: UndefinedTolerance    = 0.2 ! Poss. could make it 1

  real(r4), public, save      :: UndefinedValue        = DefaultUnDefinedValue
  ! --------------------------------------------------------------------------

  !----------------------------------------------------------------------
  !         What do we mean by the start array?
  ! The hdf library, and any libraries based on hdf, were written with
  ! the c language in mind. So they treat the first element of an array
  ! as index number "0" instead of "1". Therefore, start[k]=0
  ! means the first element. To a Fortran mentality, start functions not like
  ! an array of first indexes but like an array of offsets. We have then two
  ! choices of how to treat the start array when not calling an hdf procedure:
  ! (1) Fort_Indx: treat start as the first element
  ! (2) Offset:    adopt the hdf convention, and treat it as an offset
  ! The choice we make is set by the MLS_HyperStart parameter below.
  integer, parameter             :: Fort_Indx            = 1
  integer, parameter             :: Offset               = 0
  integer, parameter, public     :: MLS_HyperStart       = Offset
  ! When used in a procedure that interfaces directly with hdf, nothing
  ! changes. Just remember that start[k]=0 means the first element.
  !
  ! When used with an mls procedure out of Hyperslabs.f90, or when used with
  ! L2GPData/ExtractL2GPRecord, the following hold
  ! MLS_HyperStart                 start[k]=this 
  !                                means the first element
  ! ----------                 ---------------------------
  ! Fort_Indx                             1
  ! Offset                                0
  !
  ! Up to the time of this writing (2021-04-02) we have allowed
  ! MLS_HyperStart == Fort_Index
  ! While intuitive for a Fortran user, it is inconsistent with the usage
  ! in the hdf library. Therefore, we may someday switch to 
  ! MLS_HyperStart == Offset
  !----------------------------------------------------------------------

  !----------------------------------------------------------------------
  ! A type to hold the hdf file ids
  ! (Should we make it recursive in case dataset path something like
  ! "/grp_1/grp_2/../grp_n/sd"?)

  type FileIds_T
    integer :: f_id     = 0 ! File id, handle, or io unit
    integer :: grp_id   = 0 ! group id
    integer :: sd_id    = 0 ! sd or swath id
  end type Fileids_T

  ! A PCFid range
  ! Also could be a ranges of MAFs
  ! Should we put one inside the MLSChunk_T?
  ! Or should we create a type-limited function inside the MLSChunk_T?
  type Range_T
    integer :: Bottom   = 0
    integer :: Top      = 0
  end type Range_T

  ! An open real interval (But see inRange below)
  type Interval_T
    real(rt) :: Bottom   = 0._rt
    real(rt) :: Top      = 0._rt
  end type Interval_T

  ! --------------------------------------------------------------------------

  ! This datatype defines the `chunks' into which the input dataset is split

  ! Moved here from Chunks_m module
  type MLSChunk_T
    logical :: abandoned = .false. ! Did we abandon this chunk's retrieval?
    integer :: firstMAFIndex = -1  ! Index of first MAF in the chunk
    integer :: lastMAFIndex = -1   ! Index of last MAF in the chunk
    integer :: noMAFsLowerOverlap = 0 ! Number of MAFs in the lower overlap region
    integer :: noMAFsUpperOverlap = 0 ! Number of MAFs in the upper overlap region
    integer :: chunkNumber        = -1             ! Index of this chunk
    integer, dimension(:), pointer :: HGridOffsets => NULL()
    ! This for each chunk is the index of the first non-overlapped profile in 
    ! each hGrid into the relevant output (l2gp?) file.
    integer, dimension(:), pointer :: HGridTotals => NULL()
    ! This is somewhat repetitive.  It's the total number of profiles in
    ! the output hGrid.  It's only really used in parallel runs.
    real(rp) :: phiStart = 0. ! for use by regular HGrid
    real(rp) :: phiEnd   = 0.
    double precision :: StartTime = 0. ! for use by readGriddedData
    double precision :: EndTime   = 0.
  end type MLSChunk_T

  ! Information describing the files used by the mls software
  ! Instead of passing file handles or names back & forth between routines
  ! -- pass one of these instead
  type MLSFile_T
    character (len=16) :: content=""  ! e.g., 'l1brad', 'l2gp', 'l2aux', ..
    character (len=8) :: lastOperation=""  ! 'open','close','read','write'
    character (len=FileNameLen) :: Name=""  ! its name (usu. w/path)
    character (len=ShortNameLen) :: ShortName=""  ! its short name; e.g. 'H2O'
    character (len=8) :: typeStr=""  ! one of {'swath', 'hdf', ..}
    integer :: type=0  ! one of {l_swath, l_hdf, ..}
    integer :: access=0  ! one of {DFACC_RDONLY, DFACC_CREATE, ..}
    integer :: HDFVersion=0  ! its hdf version if hdf(eos)
    integer :: PCFId=0      ! its PCF ID (ref), if any
    integer :: recordLength=0! its max record_length, if any
    integer :: errorCode=0  ! non-zero usu. means trouble
    logical :: StillOpen=.false.
    type(Range_T) :: PCFidRange = Range_T()
    type(Fileids_T) :: FileID = FileIDs_T()
    type(where_t) :: Where  ! in l2cf, using Where function in Tree module
    ! Until MLSFile_T is moved out of MLSCommon, get these from a tree node
    ! using Source_Ref and The_File from the Tree module.
    integer :: L2CF = 0       ! String index of L2CF
    integer :: Source = 0     ! 256*line + column, in L2CF
  end type MLSFile_T

  ! This datatype describes the information on the L1B data files in use
  type L1BInfo_T
    integer :: L1BOAId=0     ! The HDF ID (handle) for the L1BOA file
    ! Id(s) for the L1BRAD file(s)
    integer, dimension(:), pointer :: L1BRADIds=>NULL()
    character (len=FileNameLen) :: L1BOAFileName=""  ! L1BOA file name
    character (len=FileNameLen), dimension(:), pointer :: &
         & L1BRADFileNames=>NULL()
  end type L1BInfo_T

  ! --------------------------------------------------------------------------

  ! The TAI93 time range
  ! Must be r8 because otherwise seconds since 1993 will be truncated
  type TAI93_Range_T
    real(r8) :: startTime ! TAI93 format
    real(r8) :: endTime   ! TAI93 format
  end type TAI93_Range_T
  ! --------------------------------------------------------------------------

  ! Datatype for the metadata files supplemental data
  type L2Metadata_T
    real :: minLat = -90.0       ! min Latitude
    real :: maxLat = 90.0      ! max Latitude
    real :: minLon = -180.0      ! min Longitude
    real :: maxLon = 180.0     ! max Longitude
    character(len=NameLen) :: doiIdentifier = ' '
  end type L2Metadata_T

  ! --------------------------------------------------------------------------
  ! Datatype for the Fill or undefined value
  ! (its value(s), whether Fills
  ! mean a value greater than or equal to, etc.)
  ! We will be migrating older is-Fill tests to use this instead
  ! to handle multiple Fill values and idea of range
  
  ! The idea is that a tested value is a fill value if it satisfies any
  ! of a set of conditions with respect to reference values
  ! This is an obvious generalization of the older test where we
  ! tested only whether it equaled one specified reference value
  
  ! Why do this? We use -999.99, both in mls level 1 and level 2
  ! Gloria uses 10^12
  ! GMAO uses 10^15

  type MLSFill_T
    real(r8)             :: value
    ! The condition for each value; possibilities are (testing a value "it")
    ! id   condition(i)      meaning (i.e., it is a Fill value if ..
    !  0    =              it = values(i)
    !  1    >              it > values(i)
    !  2    <              it < values(i)
    !  3    >=             it > or = values(i)
    
    !  4    <=             it < or = values(i)
    ! In addition, if '||' are found in the condition(i), we
    ! take its absolute value before applying the test
    ! (We also add 10 to its id--YACH "yet another crude hack")
    real(r8)             :: tol ! its tolerance, if any
    character(len=4) :: condition
  end type MLSFill_T
  
  type(MLSFill_T), public, save, dimension(:), pointer :: MLSFills => null()

contains
  ! Now any public procedures and functions
  ! Should we keep procedures and ffunctions here, or
  ! keep break them out to a separate module?
  !--------------------------------------------  accessType  -----
  function accessDFACCToStr ( dfacc ) result(str)

  ! This routine converts an hdf access type
  ! like DFACC_RDONLY into a string like 'rdonly'
  ! If access type is unrecognized, returns 'unknown'
  ! Args
  integer, intent(in)           :: dfacc
  character(len=8)              :: str
  ! Executable
  select case (dfacc)
  case (HDF_Acc_Create)
    str = 'create'
  case (HDF_Acc_Rdonly)
    str = 'rdonly'
  case (HDF_Acc_RdWr)
    str = 'rdwrite'
  case default
    str = 'unknown' ! Why not ' '? Or '?'
  end select
  end function accessDFACCToStr

  function accessStrToDFACC ( str ) result(dfacc)

  ! This routine converts a string like 'rdonly' into an hdf access type
  ! like DFACC_RDONLY
  ! If string is unrecognized, returns -999
  ! Args
  character(len=*), intent(in) :: str
  integer                      :: dfacc
  ! Executable
  select case (lowercase(str(1:4)))
  case ('crea')
    dfacc = HDF_Acc_Create
  case ('rdon')
    dfacc = HDF_Acc_Rdonly
  case ('rdwr')
    dfacc = HDF_Acc_RdWr
  case default
    dfacc = -999 ! why not DFACC_RDWR?
  end select
  end function accessStrToDFACC

  !--------------------------------------------  DontCrashHere  -----
  ! May we skip otherwise obligatory crashes in named modules?
  ! We decide on the basis of whether the module
  logical function DontCrashHere( arg )
    character(len=8), intent(in) :: arg
    ! Executable
    DontCrashHere = .false.
    if ( len_trim(MLSNamesDontCrash ) < 1 ) return
    if ( len_trim(arg) < 1 ) return
    DontCrashHere = index( lowercase(MLSNamesDontCrash), lowercase(trim(arg)) ) > 0
  end function DontCrashHere

  !--------------------------------------------  InRange  -----
  ! This family of functions returns TRUE for arg(s) within the given range
  ! Like FindInRange, the range includes its endpoints;
  ! e.g. if arg = range%Bottom = range%Top, returns TRUE
  ! Note:
  ! This runs counter to the spirit that the interval_t is an open interval
  elemental function inRange_int(arg, range) result(relation)
    ! Is arg in range?
    integer, intent(in)       :: arg
    type(Range_T), intent(in) :: range
    logical                   :: relation
    relation = (arg < (range%top + 1)) .and. (arg > (range%bottom - 1))
  end function inRange_int

  elemental function inRange_range(arg, range, butNotEqual) result(relation)
    ! Is arg wholly contained in range?
    type(Range_T), intent(in)       :: arg
    type(Range_T), intent(in)       :: range
    logical, optional, intent(in)   :: butNotEqual
    logical                         :: relation
    logical                         :: myButNot
    myButNot = .false.
    if ( present(butNotEqual) ) myButNot = butNotEqual
    relation = (arg%top < (range%top + 1)) .and. (arg%bottom > (range%bottom - 1))
    if ( myButNot .and. relation ) &
      & relation = .not. ( arg%top == range%top .and. arg%Bottom == range%Bottom )
  end function inRange_range

  elemental function inRange_r4(arg, range) result(relation)
    ! Is arg in range?
    real(r4), intent(in)       :: arg
    type(Interval_T), intent(in) :: range
    logical                   :: relation
    relation = (arg <= range%top) .and. (arg >= range%bottom)
  end function inRange_r4

  elemental function inRange_r8(arg, range) result(relation)
    ! Is arg in range?
    real(r8), intent(in)       :: arg
    type(Interval_T), intent(in) :: range
    logical                   :: relation
    relation = (arg <= range%top) .and. (arg >= range%bottom)
  end function inRange_r8

  !--------------------------------------------  Is_What_IEEE  -----
  elemental function is_what_ieee_r8( what, arg ) result( itIs )
    ! Args
    integer, intent(in)                       :: what ! a signal flag
    real(r8), intent(in)                      :: arg
    logical                                   :: itIs
    ! Executable
    select case (what)
    case (finite_signal)
      itIs = ieee_is_finite(arg)
    case (inf_signal)
      itIs = .not. ( ieee_is_finite(arg) .or. ieee_is_nan(arg) )
    case (nan_signal)
      itIs = ieee_is_nan(arg)
    case (oldfill_signal)
      itIs = abs(arg - UndefinedValue) < &
        & max( Real(undefinedTolerance, r8), abs(UndefinedValue/100000._r8) )
    case (fill_signal)
      itIs = is_a_fill_value( arg )
    case default
      itIs = .false. ! what signal flag did you mean? not recognized
    end select
  end function is_what_ieee_r8

  elemental function is_what_ieee_r4( what, arg ) result( itIs )
    ! Args
    integer, intent(in)                       :: what ! a signal flag
    real(r4), intent(in)                      :: arg
    logical                                   :: itIs
    ! Executable
    select case (what)
    case (finite_signal)
      itIs = ieee_is_finite(arg)
    case (inf_signal)
      itIs = .not. ( ieee_is_finite(arg) .or. ieee_is_nan(arg) )
    case (nan_signal)
      itIs = ieee_is_nan(arg)
    case (oldfill_signal)
      itIs = ( abs(arg-int(UndefinedValue)) < &
        & max(undefinedTolerance, abs(UndefinedValue/100000)) )
    case (fill_signal)
      itIs = is_a_fill_value( arg )
    case default
      itIs = .false. ! what signal flag did you mean? not recognized
    end select
  end function is_what_ieee_r4

  elemental function is_what_ieee_integer( what, arg ) result( itIs )
    ! Args
    integer, intent(in)                       :: what ! a signal flag
    integer, intent(in)                       :: arg
    logical                                   :: itIs
    ! Executable
    select case (what)
    case (finite_signal)
      itIs = .true. ! ieee_is_finite(arg)
    case (inf_signal)
      itIs = .false. ! .not. ( ieee_is_finite(arg) .or. ieee_is_nan(arg) )
    case (nan_signal)
      itIs = .false. ! ieee_is_nan(arg)
    case (oldfill_signal)
      itIs = ( abs(arg-int(UndefinedValue)) < 1 )
    case (fill_signal)
      itIs = is_a_fill_value( arg )
    case default
      itIs = .false. ! what signal flag did you mean? not recognized
    end select
  end function is_what_ieee_integer

  elemental function is_what_ieee_character( what, arg ) result( itIs )
    ! Args
    integer, intent(in)                       :: what ! a signal flag
    character(len=*), intent(in)              :: arg
    logical                                   :: itIs
    ! Executable
    select case (what)
    case (finite_signal)
      itIs = .false. ! ieee_is_finite(arg)
    case (inf_signal)
      itIs = .false. ! .not. ( ieee_is_finite(arg) .or. ieee_is_nan(arg) )
    case (nan_signal)
      itIs = .false. ! ieee_is_nan(arg)
    case (fill_signal)
      itIs = .false.
    case default
      itIs = .false. ! what signal flag did you mean? not recognized
    end select
  end function is_what_ieee_character
  
  !--------------------------------------------  Is_A_Fill_Value  -----
  elemental function is_a_fill_value_int( arg ) result ( itIs )
    integer, intent(in) :: arg
    logical :: itIs
    integer :: k
    integer :: x
    ! We can't use the standard real-valued undefined values because
    ! we may wish them to have values (like -1.e15) so big
    ! that the int function will fail
    ! include 'isafillvalue.f9h'
    itIs = ( abs(arg-UndefinedIntegerValue) < 1 )
  end function is_a_fill_value_int
  
  elemental function is_a_fill_value_r4( arg ) result ( itIs )
    real(r4), intent(in) :: arg
    logical :: itIs
    integer :: k
    real(r4) :: x
    include 'isafillvalue.f9h'
  end function is_a_fill_value_r4
  
  elemental function is_a_fill_value_r8( arg ) result ( itIs )
    real(r8), intent(in) :: arg
    logical :: itIs
    integer :: k
    real(r8) :: x
    include 'isafillvalue.f9h'
  end function is_a_fill_value_r8
  
  !--------------------------------------------  WhatCondition  -----
  elemental function whatCondition ( c ) result ( what )
    ! Returns what condition id
    character(len=*), intent(in) :: c
    integer :: what
    if ( index(c, '<=') > 0 ) then
      what = 4
    elseif ( index(c, '>=') > 0 ) then
      what = 3
    elseif ( index(c, '<') > 0 ) then
      what = 2
    elseif ( index(c, '>') > 0 ) then
      what = 1
    else
      what = 0
    endif
    if ( index(c, '|') > 0 ) what = what + 10
  end function whatCondition
  
  !--------------------------------------------  equalsFillValue  -----
  elemental function equalsFillValue_int( arg, theFillValue ) result( itsafill )
    integer, intent(in) :: arg
    real(r8), intent(in) :: theFillValue
    logical :: itsafill
    itsafill = ( abs(arg-int(theFillValue)) < 1 )
  end function equalsFillValue_int

  elemental function equalsFillValue_r4( arg, theFillValue ) result( itsafill )
    real(r4), intent(in) :: arg
    real(r8), intent(in) :: theFillValue
    logical :: itsafill
    itsafill = ( abs(arg-theFillValue) < &
    & max(real(undefinedTolerance, r8), abs(theFillValue*1.d-6)) )
  end function equalsFillValue_r4

  elemental function equalsFillValue_r8( arg, theFillValue ) result( itsafill )
    real(r8), intent(in) :: arg
    real(r8), intent(in) :: theFillValue
    logical :: itsafill
    itsafill = ( abs(arg-theFillValue) < &
    & max(real(undefinedTolerance, r8), abs(theFillValue*1.d-6)) )
  end function equalsFillValue_r8

  ! --------------------------------------------  split_name_extension  -----

  ! This routine splits the input full_file_name
  ! E.g. 'name.txt' -> 'name' + 'txt'

  ! Optionally you may supply the '.'
  ! which must be a single character

  elemental subroutine split_name_extension ( full_file_name, name, extension, &
    & dot )

    ! Arguments

    character (len=*), intent(in) :: full_file_name
    character (len=*), intent(out) :: name
    character (len=*), intent(out) :: extension
    character (len=1), optional, intent(in) :: dot

    ! Local

    character (len=1) :: myDot
    integer :: loc, n
!   logical, parameter :: DEBUG = .false.

    ! Begin
    myDot = '.'
    if ( present(dot) ) myDot = dot
    call split_path_name ( full_file_name, name, extension, slash=myDot )
    ! Now 
    ! (1) Typically name will end with '.', so snip that off
    ! (2) If the file name had no extension, its name has been returned
    !     in the extension arg, so that must be dealt with
    ! (3) If the file name was e.g., '.ext', the name has been returned as '.'
    if ( len_trim(name) < 1 ) then
      ! case (2)
      name = extension
      extension = ' '
    elseif ( name == myDot ) then
      ! case (3)
      name = ' '
    else
      ! Now check for case (1)
      loc = len_trim(name)
      if ( name(loc:loc) == myDot ) name(loc:loc) = ' '
    endif
      
  end subroutine split_name_extension

  ! --------------------------------------------  split_path_name  -----

  ! This routine splits the input full_file_name
  ! into its components path and name
  ! where path may include one or more "/" or slash elements
  ! (but one must be the terminating one; e.g., 'System/')
  ! while name must have none (actually "/" comes from Machine%filsep).
  ! special cases by example: full_file_name -> (path, name)
  ! look.ma.no.slash -> (' ', 'look.ma.no.slash')
  ! Luke/I/am/your/father/ -> ('Luke/I/am/your/father/', ' ')

  ! optionally you may supply the slash divider
  ! which must be a single character

  elemental subroutine split_path_name ( full_file_name, path, name, slash )

    ! Arguments

    use Machine, only: Filsep ! / or :\

    character (len=*), intent(in) :: full_file_name
    character (len=*), intent(out) :: path
    character (len=*), intent(out) :: name
    character (len=1), optional, intent(in) :: slash

    ! Local

    character (len=1) :: mySlash
    integer :: loc, n
!   logical, parameter :: DEBUG = .false.

    ! Begin

    n = len_trim(full_file_name)

    if ( n <= 0 ) then
      path = ' '
      name = ' '
      return
    end if

    if ( present(slash) ) then
      mySlash = slash
    else
      mySlash = filsep
    end if

    loc = scan(full_file_name(:n), mySlash, back=.true.)

    if ( loc <= 0 ) then
      path = ' '
      name = adjustl(full_file_name)
    else if ( loc == n ) then
      path = adjustl(full_file_name)
      name = ' '
    else
      path = adjustl(full_file_name(:loc))
      name = adjustl(full_file_name(loc+1:))
    end if

  end subroutine split_path_name

!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSCommon.f90,v 2.62 2024/08/08 20:37:33 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MLSCommon
!=============================================================================

!
! $Log: MLSCommon.f90,v $
! Revision 2.62  2024/08/08 20:37:33  pwagner
! inRange now works with arg that is a range,  too
!
! Revision 2.61  2023/09/28 20:57:28  pwagner
! Added split_name_extension
!
! Revision 2.60  2021/04/29 22:51:07  pwagner
! Makes MLS_HyperStart conform with hdf
!
! Revision 2.59  2021/04/15 22:42:28  pwagner
! Added MLS_HyperStart; should it be here?
!
! Revision 2.58  2020/07/09 23:51:12  pwagner
! Added Start,EndTime components to MLSChunk_T
!
! Revision 2.57  2020/04/27 21:28:55  pwagner
! Separately track allocates/deallocates
!
! Revision 2.56  2019/08/19 21:56:39  pwagner
! Moved NoBytesAllocated to MLSCommon from Allocate_Deallocate
!
! Revision 2.55  2019/05/13 23:31:15  pwagner
! Introduced UndefinedIntegerValue
!
! Revision 2.54  2019/04/09 20:30:59  pwagner
! Moved some procedures from MLSStrings to new MLSStrings_0
!
! Revision 2.53  2018/12/11 16:46:30  pwagner
! Changed parameter name to MLS_S_Success to avoid conflict in level 1
!
! Revision 2.52  2018/12/11 01:19:01  pwagner
! moved MLSMSG_sevrity parameters here
!
! Revision 2.51  2018/08/17 23:51:41  pwagner
! May use Where component in MLSFile_T
!
! Revision 2.50  2018/08/13 22:31:28  pwagner
! Add MLSChunk_T to toc; correct spelling error in comments
!
! Revision 2.49  2018/08/03 23:18:56  vsnyder
! Add L2CF and Source components to MLSFile_t
!
! Revision 2.48  2018/05/11 21:23:27  pwagner
! Stop Use-ing HDF; Moved M_ mask bit fields here
!
! Revision 2.47  2018/02/08 23:18:00  pwagner
! moved accessType and split_path_name here from MLSFiles
!
! Revision 2.46  2015/06/30 18:39:10  pwagner
! May keep list of module names to exempt from annoying crashes
!
! Revision 2.45  2015/06/19 00:32:38  pwagner
! Moved MLSChunk_T here
!
! Revision 2.44  2014/12/10 19:11:11  pwagner
! f.p. inRange now includes its endpoints like integer interface
!
! Revision 2.43  2014/09/05 00:00:27  vsnyder
! Remove ProcessID
!
! Revision 2.42  2014/08/05 00:17:07  pwagner
! Add --pId and --uId to set id_strings for slave task
!
! Revision 2.41  2014/03/26 17:42:52  pwagner
! Added ProductionLocation, identifier_product_DOI to metadata
!
! Revision 2.40  2014/03/07 19:11:33  pwagner
! Distinguish between ShortNameLen and NameLen
!
! Revision 2.39  2013/11/18 21:41:51  pwagner
! Sticky versions of verbose, debug available
!
! Revision 2.38  2013/08/30 23:12:21  pwagner
! Default values for all MLSFile_T fields
!
! Revision 2.37  2011/12/13 01:06:03  pwagner
! Generalized Fill by MLSFill type; added MLSVerbose and MLSDebug
!
! Revision 2.36  2011/08/26 00:27:48  pwagner
! Added Interval_T
!
! Revision 2.35  2010/11/30 00:33:27  pwagner
! Added instance for character arg to is_what_ieee
!
! Revision 2.34  2010/01/11 18:32:44  pwagner
! Completed toc; generic is_what_ieee_ now use r4, r8
!
! Revision 2.33  2009/06/23 18:25:42  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.32  2009/06/02 17:47:26  cvuu
! Add L2Metadata structure
!
! Revision 2.31  2008/01/09 20:50:01  pwagner
! is_what_ieee supports integer args
!
! Revision 2.30  2008/01/07 21:33:19  pwagner
! Added ieee signal defs and id-ing functions
!
! Revision 2.29  2007/01/12 00:24:38  pwagner
! Tore ourselves loose from SDPToolkit, hoping we left no shreds of flesh
!
! Revision 2.28  2006/11/01 20:31:38  pwagner
! House-cleaning
!
! Revision 2.27  2005/12/16 00:02:05  pwagner
! FillValue-related stuff moved to new MLSFillValues module
!
! Revision 2.26  2005/10/19 22:53:01  vsnyder
! Move kinds to MLSKinds
!
! Revision 2.25  2005/06/22 17:25:49  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.24  2005/06/14 20:31:10  pwagner
! Added and changed some fields of MLSFile_T
!
! Revision 2.23  2005/05/31 17:49:15  pwagner
! Added new fields to MLSFile_T
!
! Revision 2.22  2005/05/12 20:46:46  pwagner
! Added filterValues and isFinite procedures (Should they be elsewhere?)
!
! Revision 2.21  2004/08/03 17:58:25  pwagner
! Now holds DEFAULTUNDEFINEDVALUE to be used elsewhere
!
! Revision 2.20  2004/06/10 01:00:50  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.19  2004/05/19 19:16:40  vsnyder
! Move MLSChunks_t to Chunks_m
!
! Revision 2.18  2004/01/09 00:38:04  pwagner
! Added FindNext function
!
! Revision 2.17  2003/06/20 19:31:39  pwagner
! Changes to allow direct writing of products
!
! Revision 2.16  2003/02/17 03:52:49  livesey
! Bit the bullet and changed rm to r4.
!
! Revision 2.15  2002/12/05 19:44:24  pwagner
! Moved MLSFile_T from MLSFiles to MLSCommon
!
! Revision 2.14  2002/11/06 00:16:48  pwagner
! Added toc/api blocks
!
! Revision 2.13  2002/10/08 00:09:11  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.12  2002/09/13 18:08:12  pwagner
! May change matrix precision rm from r8
!
! Revision 2.11  2002/08/28 22:16:18  pwagner
! Added rm, rv types
!
! Revision 2.10  2002/02/19 23:10:54  pwagner
! Added BareFNLen
!
! Revision 2.9  2002/01/09 23:51:27  pwagner
! Connected FileNameLen with PGSd_PC_FILE_PATH_MAX
!
! Revision 2.8  2001/11/14 18:03:32  livesey
! Changed FindFirst to return 0 not -1 if not found
!
! Revision 2.7  2001/09/09 02:47:58  livesey
! Moved FindFirst into MLSCommon
!
! Revision 2.6.2.3  2001/09/09 01:53:27  livesey
! Bug fix
!
! Revision 2.6.2.2  2001/09/09 01:35:46  livesey
! Moved FindFirst in from MLSL2Common
!
! Revision 2.6.2.1  2001/09/08 22:32:24  livesey
! Added RP and IP
!
! Revision 2.6  2001/04/20 23:10:53  livesey
! Initialised parameters in L1BINFO
!
! Revision 2.5  2001/03/10 18:48:17  livesey
! Really nullified the pointer!
!
! Revision 2.4  2001/03/10 07:06:46  livesey
! Nullified L1BRadfileNames in L1BInfo
!
! Revision 2.3  2001/02/09 00:38:55  livesey
! Various changes
!
! Revision 2.2  2001/01/26 23:46:35  pwagner
! Restored L1BInfo from l1/MLSL1Common back to lib/MLSCommon
!
! Revision 2.0  2000/09/05 17:41:06  dcuddy
! Change revision to 2.0
!
! Revision 1.14  2000/09/02 01:58:30  vsnyder
! Cosmetic changes
!
@


2.62
log
@inRange now works with arg that is a range,  too
@
text
@d531 1
a531 1
  elemental function inRange_range(arg, range) result(relation)
d533 7
a539 3
    type(Range_T), intent(in) :: arg
    type(Range_T), intent(in) :: range
    logical                   :: relation
d541 2
d836 1
a836 1
       "$Id: MLSCommon.f90,v 2.61 2023/09/28 20:57:28 pwagner Exp $"
d848 3
@


2.61
log
@Added split_name_extension
@
text
@d222 1
a222 1
    module procedure inRange_r4, inRange_r8, inRange_int
d331 3
d531 8
d830 1
a830 1
       "$Id: MLSCommon.f90,v 2.60 2021/04/29 22:51:07 pwagner Exp $"
d842 3
@


2.60
log
@Makes MLS_HyperStart conform with hdf
@
text
@d97 5
a101 3
! inRange          does an argument lie within a specified range or interval
! is_what_ieee     is an argument a specified ieee type
! split_path_name  splits the input path/name into path and name
d110 2
d131 1
d705 48
d819 1
a819 1
       "$Id: MLSCommon.f90,v 2.59 2021/04/15 22:42:28 pwagner Exp $"
d831 3
@


2.59
log
@Added MLS_HyperStart; should it be here?
@
text
@d295 1
a295 1
  integer, parameter, public     :: MLS_HyperStart       = Fort_Indx
d766 1
a766 1
       "$Id: MLSCommon.f90,v 2.58 2020/07/09 23:51:12 pwagner Exp $"
d778 3
@


2.58
log
@Added Start,EndTime components to MLSChunk_T
@
text
@d282 33
d766 1
a766 1
       "$Id: MLSCommon.f90,v 2.57 2020/04/27 21:28:55 pwagner Exp $"
d778 3
@


2.57
log
@Separately track allocates/deallocates
@
text
@d320 1
a320 1
    ! This is somewhat repetetive.  It's the total number of profiles in
d324 2
d733 1
a733 1
       "$Id: MLSCommon.f90,v 2.56 2019/08/19 21:56:39 pwagner Exp $"
d745 3
@


2.56
log
@Moved NoBytesAllocated to MLSCommon from Allocate_Deallocate
@
text
@d252 1
a252 1
  ! The next two used for tracking allocated memory
d255 5
a259 1
  double precision, save, public :: NoBytesAllocated = 0.0d0 ! Number of MEMORY_UNITS allocated.
d731 1
a731 1
       "$Id: MLSCommon.f90,v 2.55 2019/05/13 23:31:15 pwagner Exp $"
d743 3
@


2.55
log
@Introduced UndefinedIntegerValue
@
text
@d96 1
a96 1
! dontCrashHere    May we skip otherwise obligatory crash in named modules?
d104 1
a104 1
! log dontCrashHere( char* arge )
d252 5
d461 1
a461 1
  logical function dontCrashHere( arg )
d464 1
a464 1
    dontCrashHere = .false.
d467 2
a468 2
    dontCrashHere = index( lowercase(MLSNamesDontCrash), lowercase(trim(arg)) ) > 0
  end function dontCrashHere
d727 1
a727 1
       "$Id: MLSCommon.f90,v 2.54 2019/04/09 20:30:59 pwagner Exp $"
d739 3
@


2.54
log
@Moved some procedures from MLSStrings to new MLSStrings_0
@
text
@d17 1
a17 1
  !   This doesn't results in a circular dependence.
d48 1
a48 1
! DEFAULTUNDEFINEDVALUE 
d50 1
a50 1
! UNDEFINEDVALUE    
d158 5
a162 5
  integer, public, parameter :: FINITE_SIGNAL = 0
  integer, public, parameter :: INF_SIGNAL    = FINITE_SIGNAL + 1
  integer, public, parameter :: NAN_SIGNAL    = INF_SIGNAL + 1
  integer, public, parameter :: FILL_SIGNAL   = NAN_SIGNAL + 1
  integer, public, parameter :: OLDFILL_SIGNAL= FILL_SIGNAL + 1
d266 3
a268 2
  real(r4), public, parameter :: DEFAULTUNDEFINEDVALUE = -999.99 ! Try to use in lib, l2
  real(r4), public, parameter :: UNDEFINEDTOLERANCE = 0.2 ! Poss. could make it 1
d270 1
a270 1
  real(r4), public, save      ::    UNDEFINEDVALUE = DEFAULTUNDEFINEDVALUE
d510 2
a511 2
      itIs = abs(arg - undefinedValue) < &
        & max( Real(undefinedTolerance, r8), abs(undefinedValue/100000._r8) )
d533 2
a534 2
      itIs = ( abs(arg-int(undefinedvalue)) < &
        & max(undefinedTolerance, abs(undefinedvalue/100000)) )
d556 1
a556 1
      itIs = ( abs(arg-int(undefinedvalue)) < 1 )
d590 5
a594 1
    include 'isafillvalue.f9h'
d722 1
a722 1
       "$Id: MLSCommon.f90,v 2.53 2018/12/11 16:46:30 pwagner Exp $"
d734 3
@


2.53
log
@Changed parameter name to MLS_S_Success to avoid conflict in level 1
@
text
@d20 1
a20 1
  use MLSStrings,  only: Lowercase
d717 1
a717 1
       "$Id: MLSCommon.f90,v 2.52 2018/12/11 01:19:01 pwagner Exp $"
d729 3
@


2.52
log
@moved MLSMSG_sevrity parameters here
@
text
@d65 1
a65 1
! PGS_S_Success            if status not this, then something went wrong
d189 2
a190 2
  integer, public, parameter :: PGS_S_SUCCESS = 0
  integer, public, parameter :: MLSMSG_Success     = PGS_S_SUCCESS ! == 0
d717 1
a717 1
       "$Id: MLSCommon.f90,v 2.51 2018/08/17 23:51:41 pwagner Exp $"
d729 3
@


2.51
log
@May use Where component in MLSFile_T
@
text
@d63 11
d180 20
d717 1
a717 1
       "$Id: MLSCommon.f90,v 2.50 2018/08/13 22:31:28 pwagner Exp $"
d729 3
@


2.50
log
@Add MLSChunk_T to toc; correct spelling error in comments
@
text
@d17 2
a18 5
!   This results in a circular dependence.  The type MLSFile_T ought to be
!   defined in a different module.
!   use Lexer_Core, only: Where_T ! Where is something in the L2CF
!   ** MLSCommon is about as common as our lib modules get              **
!   ** only machine, IEEE_Aritmetic, MLSKinds, and MLSStrings are lower **
d303 1
a303 1
!     type(where_t) :: Where  ! in l2cf, using Where function in Tree module
d686 1
a686 1
       "$Id: MLSCommon.f90,v 2.49 2018/08/03 23:18:56 vsnyder Exp $"
d698 3
@


2.49
log
@Add L2CF and Source components to MLSFile_t
@
text
@d20 2
d71 1
d426 1
a426 1
  ! We decide on the basis of whether the mocule
d689 1
a689 1
       "$Id: MLSCommon.f90,v 2.48 2018/05/11 21:23:27 pwagner Exp $"
d701 3
@


2.48
log
@Stop Use-ing HDF; Moved M_ mask bit fields here
@
text
@d17 3
d303 5
d686 1
a686 1
       "$Id: MLSCommon.f90,v 2.47 2018/02/08 23:18:00 pwagner Exp $"
d698 3
@


2.47
log
@moved accessType and split_path_name here from MLSFiles
@
text
@a15 1
  use HDF, only: Dfacc_Create, Dfacc_Rdonly, Dfacc_Rdwr
d23 2
d31 15
a45 15
! i1, i2, i4    integer types
! r4, r8        floating point types
! ip, rp        integer, floating point types used in forward model
! rv            floating point type used in vector quantity values
! rm            floating point type used in matrix values
! rt            floating point type used in topo-set values
! LineLen       character-length of most input
! FileNameLen   character-length of path/filenames
! BareFNLen     character-length of filenames
! namelen       Max length of hdf sds array name
! fill_signal   signal to is_what_ieee to check for undefined (fill) values
! finite_signal signal to is_what_ieee to check for finite
! inf_signal    signal to is_what_ieee to check for inf
! nan_signal    signal to is_what_ieee to check for NaN
! ShortNameLen  character-length of short names (e.g., 'H2O')
d47 28
a74 15
!               default fill values, e.g. when creating hdf arrays
! UNDEFINEDVALUE 
!               value to check for by is_what_ieee
! FileIDs_T     id numbers for file, group, swath or dataset
! L1BInfo_T     L1B data file names, etc. 
!                (Should we replace these with FileIDs?)
! L2Metadata_T  Coords of (lon,lat) box to write as metadata
! MLSFile_T     File name, type, id, etc.
! MLSFill_T     Fill value data type
! MLSFills      database of MLSFill values
! Range_T       Bottom, Top of PCFID range
! Interval_T    Bottom, Top of a real interval (open)
! TAI93_Range_T start, end times in TAI93 formatted r8
! MLSVerbose    Should we print extra stuff?
! MLSDebug      Should we print even more stuff?
d76 1
a76 1
!               Retain value of MLSVerbose thoughout pahse
d78 1
a78 1
!               Retain value of MLSDebug thoughout pahse
d88 3
d94 1
a94 1
! split_path_name (char* full_file_name, char* path, char* name, [char slash])
d150 16
a281 1
  ! Moved here from MLSFiles module
d283 1
a283 1
  ! Stop passing file handles or names back & forth between routines
d302 1
a302 2
  ! The next datatype describes the information on the L1B data files in use

d332 1
a332 1
  ! Datatype for the Fill 
d343 1
a343 1
  ! Why do this? We use -999.99, both in level 1 and level 2
d368 2
d381 1
a381 1
  case (DFACC_CREATE)
d383 1
a383 1
  case (DFACC_RDONLY)
d385 1
a385 1
  case (DFACC_RDWR)
d403 1
a403 1
    dfacc = DFACC_CREATE
d405 1
a405 1
    dfacc = DFACC_RDONLY
d407 1
a407 1
    dfacc = DFACC_RDWR
d678 1
a678 1
       "$Id: MLSCommon.f90,v 2.46 2015/06/30 18:39:10 pwagner Exp $"
d690 3
@


2.46
log
@May keep list of module names to exempt from annoying crashes
@
text
@d16 2
a17 1
  use ieee_arithmetic, only: ieee_is_finite, ieee_is_nan
d19 1
a19 1
  use MLSStrings,  only: lowercase
d67 5
a71 3
! dontCrashHere May we skip otherwise obligatory crash in named modules?
! inRange       does an argument lie within a specified range or interval
! is_what_ieee  is an argument a specified ieee type
d77 1
d92 5
a96 3
  public :: dontCrashHere
  public :: inRange
  public :: is_what_ieee
d133 11
d254 5
a258 5
    character (LEN=16) :: content=""  ! e.g., 'l1brad', 'l2gp', 'l2aux', ..
    character (LEN=8) :: lastOperation=""  ! 'open','close','read','write'
    character (LEN=FileNameLen) :: Name=""  ! its name (usu. w/path)
    character (LEN=ShortNameLen) :: ShortName=""  ! its short name; e.g. 'H2O'
    character (LEN=8) :: typeStr=""  ! one of {'swath', 'hdf', ..}
d276 2
a277 2
    character (LEN=FileNameLen) :: L1BOAFileName=""  ! L1BOA file name
    character (LEN=FileNameLen), dimension(:), pointer :: &
d335 44
a378 1
  contains
d380 1
d392 1
d422 1
d511 1
d536 1
d555 1
d579 62
d645 1
a645 1
       "$Id: MLSCommon.f90,v 2.45 2015/06/19 00:32:38 pwagner Exp $"
d657 3
@


2.45
log
@Moved MLSChunk_T here
@
text
@d18 1
d66 1
d88 1
d155 1
d320 11
d517 1
a517 1
       "$Id: MLSCommon.f90,v 2.44 2014/12/10 19:11:11 pwagner Exp $"
d529 3
@


2.44
log
@f.p. inRange now includes its endpoints like integer interface
@
text
@d91 1
d208 20
d502 1
a502 1
       "$Id: MLSCommon.f90,v 2.43 2014/09/05 00:00:27 vsnyder Exp $"
d514 3
@


2.43
log
@Remove ProcessID
@
text
@d16 2
a17 2
  use IEEE_ARITHMETIC, only: IEEE_IS_FINITE, IEEE_IS_NAN
  use MLSKINDS ! EVERYTHING
d65 1
a65 1
! inRange       does an argument lie with a specified range or interval
d82 3
d86 2
a87 2
  public :: INRANGE
  public :: IS_WHAT_IEEE
d90 8
a97 8
  public :: FILEIDS_T
  public :: MLSFILE_T
  public :: MLSFILL_T
  public :: L1BINFO_T
  public :: RANGE_T
  public :: TAI93_RANGE_T
  public :: L2METADATA_T
  public :: INTERVAL_T
d123 1
a123 1
  ! Not just "is" but "=", because "is" may accept under broader conditions
d158 1
a158 1
  integer, public, parameter :: namelen      = 64  ! Max len of SDS array name
d184 2
a185 2
  ! (Should make it recursive in case dataset path something like
  ! "/grp_1/grp_2/../grp_n/sd")
d199 1
a199 1
  ! An open real interval
d295 5
d313 1
a313 1
    relation = (arg < range%top) .and. (arg > range%bottom)
d321 1
a321 1
    relation = (arg < range%top) .and. (arg > range%bottom)
d481 1
a481 1
       "$Id: MLSCommon.f90,v 2.42 2014/08/05 00:17:07 pwagner Exp $"
d493 3
@


2.42
log
@Add --pId and --uId to set id_strings for slave task
@
text
@a27 1
! processID     our own process id (used in discovering how much memory we use)
a84 3

  ! Do we know our own process id?
  character(len=32), public    :: processID                   = ' '
d473 1
a473 1
       "$Id: MLSCommon.f90,v 2.41 2014/03/26 17:42:52 pwagner Exp $"
d485 3
@


2.41
log
@Added ProductionLocation, identifier_product_DOI to metadata
@
text
@d28 1
d87 4
d183 1
a183 1
  
d477 1
a477 1
       "$Id: MLSCommon.f90,v 2.40 2014/03/07 19:11:33 pwagner Exp $"
d489 3
@


2.40
log
@Distinguish between ShortNameLen and NameLen
@
text
@d245 1
a245 2
  ! Datatype for the metadata files

d251 1
d472 1
a472 1
       "$Id: MLSCommon.f90,v 2.39 2013/11/18 21:41:51 pwagner Exp $"
d484 3
@


2.39
log
@Sticky versions of verbose, debug available
@
text
@a33 1
! NameLen       character-length of quantity names
d37 1
d42 1
d83 2
a84 2
  public :: InRange
  public :: is_what_ieee
d86 8
a93 8
  public :: FileIDs_T
  public :: MLSFile_T
  public :: MLSFill_T
  public :: L1BInfo_T
  public :: Range_T
  public :: TAI93_Range_T
  public :: L2Metadata_T
  public :: Interval_T
d153 5
a157 4
  integer, public, parameter :: NameLen=32
  integer, public, parameter :: LineLen=132
  integer, public, parameter :: FileNameLen=max(PGSd_PC_FILE_PATH_MAX, 132) ! was 132
  integer, public, parameter :: BareFNLen=64      ! Bare file name length (w/o path)
d211 1
a211 1
    character (LEN=NameLen) :: ShortName=""  ! its short name; e.g. 'H2O'
d472 1
a472 1
       "$Id: MLSCommon.f90,v 2.38 2013/08/30 23:12:21 pwagner Exp $"
d484 3
@


2.38
log
@Default values for all MLSFile_T fields
@
text
@d58 4
d141 2
d470 1
a470 1
       "$Id: MLSCommon.f90,v 2.37 2011/12/13 01:06:03 pwagner Exp $"
d482 3
@


2.37
log
@Generalized Fill by MLSFill type; added MLSVerbose and MLSDebug
@
text
@d212 2
a213 2
    type(Range_T) :: PCFidRange
    type(Fileids_T) :: FileID
d464 1
a464 1
       "$Id: MLSCommon.f90,v 2.36 2011/08/26 00:27:48 pwagner Exp $"
d476 3
@


2.36
log
@Added Interval_T
@
text
@d51 2
d56 2
d66 1
a66 1
! log is_what_ieee( int what, num arg )
d83 1
d105 3
d112 6
d123 4
d132 8
d151 16
a166 2
  real(r4), public, parameter ::    DEFAULTUNDEFINEDVALUE = -999.99 ! Try to use in lib, l2
  real(r4), public, parameter ::    UNDEFINEDTOLERANCE = 0.2 ! Poss. could make it 1
a167 1
  ! This can be set to a different value if that would be more convenient
d246 35
d320 1
a320 1
    case (fill_signal)
d323 2
d343 1
a343 1
    case (fill_signal)
d346 2
d366 2
d369 1
a369 1
      itIs = ( abs(arg-int(undefinedvalue)) < 1 )
d395 65
d464 1
a464 1
       "$Id: MLSCommon.f90,v 2.35 2010/11/30 00:33:27 pwagner Exp $"
d476 3
@


2.35
log
@Added instance for character arg to is_what_ieee
@
text
@d16 2
a17 2
  use ieee_arithmetic, only: ieee_is_finite, ieee_is_nan
  use MLSKinds ! Everything
d33 1
d52 1
d56 1
a56 1
! inRange       does an argument lie with a specified range
d61 1
d83 1
d95 1
d105 4
d110 1
a110 1
    module procedure is_what_ieee_r4, is_what_ieee_r8, is_what_ieee_INTEGER
a140 1
  ! --------------------------------------------------------------------------
a142 1

d147 7
d191 1
a191 1

d209 1
a209 1
  elemental function inRange(arg, range) result(relation)
d215 17
a231 1
  end function inRange
d314 1
a314 1

d319 1
a319 1
       "$Id: MLSCommon.f90,v 2.34 2010/01/11 18:32:44 pwagner Exp $"
d331 3
@


2.34
log
@Completed toc; generic is_what_ieee_ now use r4, r8
@
text
@d102 1
d265 20
d289 1
a289 1
       "$Id: MLSCommon.f90,v 2.33 2009/06/23 18:25:42 pwagner Exp $"
d301 3
@


2.33
log
@Prevent Intel from optimizing ident string away
@
text
@d37 15
a51 1
! L1BInfo_T     L1B data file names, etc.
d64 1
a64 1
       "$RCSfile: $"
d101 1
a101 1
    module procedure is_what_ieee_REAL, is_what_ieee_DOUBLE, is_what_ieee_INTEGER
d115 2
a116 2
  real, public, parameter ::    DEFAULTUNDEFINEDVALUE = -999.99 ! Try to use in lib, l2
  real, public, parameter ::    UNDEFINEDTOLERANCE = 0.2 ! Poss. could make it 1
d119 1
a119 1
  real, public, save      ::    UNDEFINEDVALUE = DEFAULTUNDEFINEDVALUE
d122 3
a124 1
  ! A type to hold the hdf ids
d143 1
a143 1
  ! Stop passing file handles back & forth between routines
a144 1
  ! (Not used yet; maybe someday)
d202 1
a202 1
  elemental function is_what_ieee_DOUBLE( what, arg ) result( itIs )
d205 1
a205 1
    double precision, intent(in)              :: arg
d221 1
a221 1
  end function is_what_ieee_DOUBLE
d223 1
a223 1
  elemental function is_what_ieee_REAL( what, arg ) result( itIs )
d226 1
a226 1
    real, intent(in)                          :: arg
d242 1
a242 1
  end function is_what_ieee_REAL
d268 1
a268 1
       "$Id: read_apriori.f90 is it here $"
d280 3
@


2.32
log
@Add L2Metadata structure
@
text
@d50 1
a50 1
       "$RCSfile: MLSCommon.f90,v $"
d250 1
a251 1
!---------------------------- RCS Ident Info -------------------------------
d253 2
a254 3
       "$Id: MLSCommon.f90,v 2.31 2008/01/09 20:50:01 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d256 1
d258 1
d265 3
@


2.31
log
@is_what_ieee supports integer args
@
text
@d65 1
d168 9
d253 1
a253 1
       "$Id: MLSCommon.f90,v 2.30 2008/01/07 21:33:19 pwagner Exp $"
d264 3
@


2.30
log
@Added ieee signal defs and id-ing functions
@
text
@d86 1
a86 1
    module procedure is_what_ieee_REAL, is_what_ieee_DOUBLE
d243 1
a243 1
       "$Id: MLSCommon.f90,v 2.29 2007/01/12 00:24:38 pwagner Exp $"
d254 3
@


2.29
log
@Tore ourselves loose from SDPToolkit, hoping we left no shreds of flesh
@
text
@d16 1
d40 2
d44 2
d57 3
a60 1
  public :: InRange
d77 12
a88 1

d101 4
d177 62
d243 1
a243 1
       "$Id: MLSCommon.f90,v 2.28 2006/11/01 20:31:38 pwagner Exp $"
d254 3
@


2.28
log
@House-cleaning
@
text
@a16 1
  use SDPTOOLKIT, only: PGSd_PC_FILE_PATH_MAX
d71 4
d159 1
a159 1
       "$Id: MLSCommon.f90,v 2.27 2005/12/16 00:02:05 pwagner Exp $"
d170 3
@


2.27
log
@FillValue-related stuff moved to new MLSFillValues module
@
text
@a79 1
! real, parameter, private :: FILLVALUETOLERANCE = 0.2 ! Poss. could make it 1
d156 1
a156 1
       "$Id: MLSCommon.f90,v 2.26 2005/10/19 22:53:01 vsnyder Exp $"
d167 3
@


2.26
log
@Move kinds to MLSKinds
@
text
@a15 1
  use ieee_arithmetic, only: ieee_is_finite
a53 1
  public :: FilterValues
a54 1
  public :: IsFinite
d80 1
a80 1
  real, parameter, private :: FILLVALUETOLERANCE = 0.2 ! Poss. could make it 1
a142 16
  interface FilterValues
    module procedure FilterValues_REAL, FilterValues_DOUBLE
    module procedure FilterValues_REAL_2d, FilterValues_DOUBLE_2d
    module procedure FilterValues_REAL_3d, FilterValues_DOUBLE_3d
  end interface
  
  interface IsFillValue
    module procedure IsFillValue_REAL, IsFillValue_DOUBLE
  end interface
  
  interface IsFinite
    module procedure IsFinite_REAL, IsFinite_DOUBLE, IsFinite_INTEGER
  end interface
  
  logical, parameter ::   DEEBUG = .false.

a144 266
! ------------------------------------------------- FilterValues ---
  subroutine filterValues_REAL(a, ATAB, b, BTAB, warn, fillValue, precision)
      ! Return arrays filtered of any fillValues
      ! or where corresponding precision array < 0
      ! or whose values are not finite
      ! "Filter" means offending elements set to 0.
      ! Returned arrays are allocated and assigned values as appropriate
      ! Args
      real, dimension(:), intent(in)             :: a
      real, dimension(:), intent(in)             :: b
      real, dimension(:), intent(out)            :: atab
      real, dimension(:), intent(out)            :: btab
      logical, intent(out)                           :: warn
      real, optional, intent(in)                 :: fillValue
      real, dimension(:), optional, intent(in)   :: precision
      ! Internal variables
      integer                                        :: i
      real                                       :: myFillValue
      integer                                        :: n
      ! Executable
      myFillValue = 0.
      if ( present(FillValue) ) myFillValue = FillValue
      warn = .false.
      n=size(a)
      if ( n /= size(b) ) then
        call announce_error('a and b different sizes', n, size(b))
      elseif ( n /= size(atab) ) then
        call announce_error('a and atab different sizes', n, size(b))
      elseif ( n /= size(btab) ) then
        call announce_error('a and btab different sizes', n, size(b))
      elseif ( DEEBUG ) then
        call output('Filtering 1-d reals ', advance='yes')
        !call dump_name_v_pairs( (/n, size(b), size(atab), size(btab) /), &
        !  & 'size(a), size(b), size(atab), size(btab)', width=4)
      endif
      atab = a
      btab = b
      do i=1, N
        if ( .not. ieee_is_finite(a(i)) .or. .not. ieee_is_finite(b(i)) ) then
          atab(i) = myFillValue
          btab(i) = myFillValue
          warn = warn .or. ieee_is_finite(a(i)) .or. ieee_is_finite(b(i))
        endif
      enddo
      if ( present(fillValue) ) then
        do i=1, N
          if ( isFillValue(a(i), FillValue) .or. isFillValue(b(i), FillValue) ) then
            atab(i) = myFillValue
            btab(i) = myFillValue
          endif
        enddo
      endif
      if ( present(precision) ) then
        do i=1, N
          if ( (precision(i) < 0.) ) then
            atab(i) = myFillValue
            btab(i) = myFillValue
          endif
        enddo
      endif
  end subroutine filterValues_REAL

  subroutine filterValues_DOUBLE(a, ATAB, b, BTAB, warn, fillValue, precision)
      ! Return arrays filtered etc.
      ! Args
      double precision, dimension(:), intent(in)             :: a
      double precision, dimension(:), intent(in)             :: b
      double precision, dimension(:), intent(out)            :: atab
      double precision, dimension(:), intent(out)            :: btab
      logical, intent(out)                           :: warn
      double precision, optional, intent(in)                 :: fillValue
      double precision, dimension(:), optional, intent(in)   :: precision
      ! Internal variables
      integer                                        :: i
      double precision                                       :: myFillValue
      integer                                        :: n
      ! Executable
      myFillValue = 0.d0
      if ( present(FillValue) ) myFillValue = FillValue
      n=size(a)
      if ( n /= size(b) ) then
        call announce_error('a and b different sizes', n, size(b))
      elseif ( n /= size(atab) ) then
        call announce_error('a and atab different sizes', n, size(b))
      elseif ( n /= size(btab) ) then
        call announce_error('a and btab different sizes', n, size(b))
      elseif ( DEEBUG ) then
        call output('Filtering 1-d double precision ', advance='yes')
        !call dump_name_v_pairs( (/n, size(b), size(atab), size(btab)/) , &
        !  & 'size(a), size(b), size(atab), size(btab)', width=4)
      endif
      atab = a
      btab = b
      do i=1, N
        if ( .not. ieee_is_finite(a(i)) .or. .not. ieee_is_finite(b(i)) ) then
          atab(i) = myFillValue
          btab(i) = myFillValue
          warn = warn .or. ieee_is_finite(a(i)) .or. ieee_is_finite(b(i))
        endif
      enddo
      if ( present(fillValue) ) then
        do i=1, N
          if ( isFillValue(a(i), FillValue) .or. isFillValue(b(i), FillValue) ) then
            atab(i) = myFillValue
            btab(i) = myFillValue
          endif
        enddo
      endif
      if ( present(precision) ) then
        do i=1, N
          if ( (precision(i) < 0.d0) ) then
            atab(i) = myFillValue
            btab(i) = myFillValue
          endif
        enddo
      endif
  end subroutine filterValues_DOUBLE

  subroutine filterValues_REAL_2d(a, ATAB, b, BTAB, warn, fillValue, precision)
      ! Return arrays filtered etc.
      ! Args
      real, dimension(:,:), intent(in)             :: a
      real, dimension(:,:), intent(in)             :: b
      real, dimension(:,:), intent(out)            :: atab
      real, dimension(:,:), intent(out)            :: btab
      logical, intent(out)                           :: warn
      real, optional, intent(in)                 :: fillValue
      real, dimension(:,:), optional, intent(in)   :: precision
      ! Internal variables
      integer, dimension(2)                          :: shp
      real, dimension(size(a,1)*size(a,2))       :: a1
      real, dimension(size(b,1)*size(b,2))       :: b1
      ! Executable
      shp = shape(a)
      if ( DEEBUG ) then
        call dump_name_v_pairs(shp, width=4)
        call dump_name_v_pairs(shape(b), width=4)
      endif
      if ( present(precision) ) then
        call filterValues(reshape(a, (/shp(1)*shp(2)/)), &
        & a1, &
        & reshape(b, (/shp(1)*shp(2)/)), &
        & b1, &
        & warn, fillValue, reshape(precision, (/shp(1)*shp(2)/)) )
      else
        call filterValues(reshape(a, (/shp(1)*shp(2)/)), &
        & a1, &
        & reshape(b, (/shp(1)*shp(2)/)), &
        & b1, &
        & warn, fillValue)
      endif
      atab = reshape(a1, shp)
      btab = reshape(b1, shp)
  end subroutine filterValues_REAL_2d

  subroutine filterValues_DOUBLE_2d(a, ATAB, b, BTAB, warn, fillValue, precision)
      ! Return arrays filtered etc.
      ! Args
      double precision, dimension(:,:), intent(in)             :: a
      double precision, dimension(:,:), intent(in)             :: b
      double precision, dimension(:,:), intent(out)            :: atab
      double precision, dimension(:,:), intent(out)            :: btab
      logical, intent(out)                           :: warn
      double precision, optional, intent(in)                 :: fillValue
      double precision, dimension(:,:), optional, intent(in)   :: precision
      ! Internal variables
      integer, dimension(2)                          :: shp
      double precision, dimension(size(a,1)*size(a,2))       :: a1
      double precision, dimension(size(b,1)*size(b,2))       :: b1
      ! Executable
      shp = shape(a)
      if ( DEEBUG ) then
        call dump_name_v_pairs(shp, width=4)
        call dump_name_v_pairs(shape(b), width=4)
      endif
      if ( present(precision) ) then
        call filterValues(reshape(a, (/shp(1)*shp(2)/)), &
        & a1, &
        & reshape(b, (/shp(1)*shp(2)/)), &
        & b1, &
        & warn, fillValue, reshape(precision, (/shp(1)*shp(2)/)) )
      else
        call filterValues(reshape(a, (/shp(1)*shp(2)/)), &
        & a1, &
        & reshape(b, (/shp(1)*shp(2)/)), &
        & b1, &
        & warn, fillValue)
      endif
      atab = reshape(a1, shp)
      btab = reshape(b1, shp)
  end subroutine filterValues_DOUBLE_2d

  subroutine filterValues_REAL_3d(a, ATAB, b, BTAB, warn, fillValue, precision)
      ! Return arrays filtered etc.
      ! Args
      real, dimension(:,:,:), intent(in)             :: a
      real, dimension(:,:,:), intent(in)             :: b
      real, dimension(:,:,:), intent(out)            :: atab
      real, dimension(:,:,:), intent(out)            :: btab
      logical, intent(out)                           :: warn
      real, optional, intent(in)                 :: fillValue
      real, dimension(:,:,:), optional, intent(in)   :: precision
      ! Internal variables
      integer, dimension(3)                          :: shp
      real, dimension(size(a,1)*size(a,2)*size(a,3))       :: a1
      real, dimension(size(b,1)*size(b,2)*size(b,3))       :: b1
      ! Executable
      shp = shape(a)
      if ( DEEBUG ) then
        call dump_name_v_pairs(shp, width=4)
        call dump_name_v_pairs(shape(b), width=4)
      endif
      if ( present(precision) ) then
        call filterValues(reshape(a, (/shp(1)*shp(2)*shp(3)/)), &
        & a1, &
        & reshape(b, (/shp(1)*shp(2)*shp(3)/)), &
        & b1, &
        & warn, fillValue, reshape(precision, (/shp(1)*shp(2)*shp(3)/)) )
      else
        call filterValues(reshape(a, (/shp(1)*shp(2)*shp(3)/)), &
        & a1, &
        & reshape(b, (/shp(1)*shp(2)*shp(3)/)), &
        & b1, &
        & warn, fillValue)
      endif
      atab = reshape(a1, shp)
      btab = reshape(b1, shp)
  end subroutine filterValues_REAL_3d

  subroutine filterValues_DOUBLE_3d(a, ATAB, b, BTAB, warn, fillValue, precision)
      ! Return arrays filtered etc.
      ! Args
      double precision, dimension(:,:,:), intent(in)             :: a
      double precision, dimension(:,:,:), intent(in)             :: b
      double precision, dimension(:,:,:), intent(out)            :: atab
      double precision, dimension(:,:,:), intent(out)            :: btab
      logical, intent(out)                           :: warn
      double precision, optional, intent(in)                 :: fillValue
      double precision, dimension(:,:,:), optional, intent(in)   :: precision
      ! Internal variables
      integer, dimension(3)                          :: shp
      double precision, dimension(size(a,1)*size(a,2)*size(a,3))       :: a1
      double precision, dimension(size(b,1)*size(b,2)*size(b,3))       :: b1
      ! Executable
      shp = shape(a)
      if ( DEEBUG ) then
        call dump_name_v_pairs(shp, width=4)
        call dump_name_v_pairs(shape(b), width=4)
      endif
      if ( present(precision) ) then
        call filterValues(reshape(a, (/shp(1)*shp(2)*shp(3)/)), &
        & a1, &
        & reshape(b, (/shp(1)*shp(2)*shp(3)/)), &
        & b1, &
        & warn, fillValue, reshape(precision, (/shp(1)*shp(2)*shp(3)/)) )
      else
        call filterValues(reshape(a, (/shp(1)*shp(2)*shp(3)/)), &
        & a1, &
        & reshape(b, (/shp(1)*shp(2)*shp(3)/)), &
        & b1, &
        & warn, fillValue)
      endif
      atab = reshape(a1, shp)
      btab = reshape(b1, shp)
  end subroutine filterValues_DOUBLE_3d

d152 1
a153 107
  subroutine announce_error(message, int1, int2, dontstop)
    character(len=*), intent(in) :: message
    integer, optional, intent(in) :: int1
    integer, optional, intent(in) :: int2
    logical, optional, intent(in) :: dontstop
    logical :: keepgoing
    !
    keepgoing = .false.
    if ( present(dontstop) ) keepgoing=dontstop
    if ( .not. keepgoing ) then
      call output('*** Error in MLSCommon module ***', advance='yes')
    endif
    call output(trim(message), advance='no')
    call blanks(3)
    if ( present(int1) ) write(*,'(i4)',advance='no') int1
    call blanks(3)
    if ( present(int2) ) write(*,'(i4)', advance='no') int2
    if ( .not. keepgoing ) stop
  end subroutine announce_error

  subroutine blanks(num, advance)
    integer, intent(in) :: num
    character(len=*), optional, intent(in) :: advance
    integer :: i
    character(len=3) :: myAdvance
    myAdvance = 'no'
    if ( present(advance) ) myAdvance = advance
    do i=1, num
      write(*, '(a1)', advance='no') ' '
    enddo
    if ( myAdvance == 'yes' ) write(*, '(a1)', advance='yes') ''
    
  end subroutine blanks

  subroutine output(str, advance)
    character(len=*), intent(in) :: str
    character(len=*), optional, intent(in) :: advance
    write(*, '(a1)', advance=advance) trim(str)
    
  end subroutine output

  ! ----------------------------------  DUMP_NAME_V_PAIRS  -----
  subroutine DUMP_NAME_V_PAIRS ( VALUES, WIDTH )
    integer, intent(in)                         :: values(:)
    integer, intent(in), optional :: WIDTH ! How many pairs per line (1)?
    
    integer :: J, K, L
    integer :: MyWidth
    character(len=24) :: myName
    MyWidth = 1
    if ( present(width) ) myWidth = max(width, 1)
    if ( size(values) < 1 ) return
    l = 0
    do j=1, size(values), MyWidth
      do k=1, MyWidth
        call blanks(3, advance='no')
        l = l + 1
        if ( l <= size(values) ) then
          write(myName, *) 'integer # ', l, ': '
          call output(myName,  advance='no')
          call blanks(3, advance='no')
          write(*,'(i4)', advance='no') values(l)
        end if
      end do
      call output(' ', advance='yes')
    end do

  end subroutine DUMP_NAME_V_PAIRS
! ------------------------------------------------- IsFillValue ---

  ! This family of routines checks to see if an arg is a fillValue
  elemental logical function IsFillValue_REAL ( A, FILLVALUE )
    real, intent(in) :: A
    real ,intent(in), optional :: FILLVALUE
    real  :: MYFILLVALUE
    myFillValue = DEFAULTUNDEFINEDVALUE
    if ( present(fillValue) ) myFillValue = fillValue
    IsFillValue_REAL = &
      & abs(a - myFillValue) < FILLVALUETOLERANCE
  end function IsFillValue_REAL

  elemental logical function IsFillValue_DOUBLE ( A, FILLVALUE )
    double precision, intent(in) :: A
    double precision ,intent(in), optional :: FILLVALUE
    double precision  :: MYFILLVALUE
    myFillValue = DEFAULTUNDEFINEDVALUE
    if ( present(fillValue) ) myFillValue = fillValue
    IsFillValue_DOUBLE = &
      & abs(a - myFillValue) < Real(FILLVALUETOLERANCE, kind(A))
  end function IsFillValue_DOUBLE

! ------------------------------------------------- IsFinite ---

  ! This family of routines checks to see if an arg is finite
  elemental logical function IsFinite_REAL ( A ) result( finite )
    real, intent(in) :: A
    finite = ieee_is_finite(a)
  end function isfinite_real
  elemental logical function IsFinite_DOUBLE ( A ) result( finite )
    double precision, intent(in) :: A
    finite = ieee_is_finite(a)
  end function isfinite_DOUBLE
  elemental logical function IsFinite_INTEGER ( A ) result( finite )
    integer, intent(in) :: A
    finite = .true.
  end function isfinite_INTEGER

d157 1
a157 1
       "$Id: MLSCommon.f90,v 2.25 2005/06/22 17:25:49 pwagner Exp $"
d168 3
@


2.25
log
@Reworded Copyright statement, moved rcs id
@
text
@d17 1
d47 1
a47 1
       "$RCSfile: $"
d63 1
a63 2
  ! Firstly, these are standard numerical types, copied from HCP
  ! (again with my change in case, sorry Hugh!)
d65 9
a73 18
  integer, public, parameter:: i1=selected_int_kind(2)
  integer, public, parameter:: i2=selected_int_kind(4)
  integer, public, parameter:: i4=selected_int_kind(7)
  integer, public, parameter:: r4=selected_real_kind(5)
  integer, public, parameter:: r8=selected_real_kind(13)

  ! Now choose the precision we want by preference (may automate this through
  ! make later on, with perl or m4 or something).
  ! These are used according to the final letter in the two-letter name:
  ! Final Letter          Context           Suggested Value
  !    ----               -------           ---------------
  !     m                 Matrix            r8  (r4 to save memory)
  !     p                 Forward Model     r8
  !     v                 Vector            r8
  integer, public, parameter:: rm=r4
  integer, public, parameter:: rp=r8
  integer, public, parameter:: ip=i4
  integer, public, parameter:: rv=r8
d548 1
a548 1
       "$Id: $"
d559 3
@


2.24
log
@Added and changed some fields of MLSFile_T
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d44 3
a46 5
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: MLSCommon.f90,v 2.23 2005/05/31 17:49:15 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
  character (len=*), parameter :: ModuleName= "$RCSfile: MLSCommon.f90,v $"
d48 1
a48 1
  !---------------------------------------------------------------------------
d555 5
d568 3
@


2.23
log
@Added new fields to MLSFile_T
@
text
@d38 1
a38 1
       "$Id: MLSCommon.f90,v 2.22 2005/05/12 20:46:46 pwagner Exp $"
d112 2
a113 3
    character (LEN=8) :: type=""  ! e.g., 'ascii', 'hdf', 'swath', 'binary'
    character (LEN=8) :: access=""  ! e.g., 'rdonly', 'write', 'rdwrite'
    character (LEN=8) :: content=""  ! e.g., 'l1brad', 'l2gp', 'l2aux'
d115 4
a118 1
    ! integer :: File_Id=0     ! its HDF ID (handle) or io unit
d122 1
d557 3
@


2.22
log
@Added filterValues and isFinite procedures (Should they be elsewhere?)
@
text
@d38 1
a38 1
       "$Id: MLSCommon.f90,v 2.21 2004/08/03 17:58:25 pwagner Exp $"
d47 1
d49 1
d53 1
d89 17
d116 4
a119 3
    integer :: File_Id=0     ! The HDF ID (handle) or io unit for the file
    integer :: PCF_Id=0      ! The PCF ID (ref), if any,  for the file
    integer :: HDFVersion=0  ! Which hdf version is the file if hdf(eos)
d121 2
d430 7
a436 1

a484 1
    logical :: MyClean
d554 3
@


2.21
log
@Now holds DEFAULTUNDEFINEDVALUE to be used elsewhere
@
text
@d1 2
a2 2
 ! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d8 1
d12 1
a12 1
  public
d35 1
a35 1
 private :: Id, ModuleName
d37 3
a39 2
  character (len=256) :: Id = &
       "$Id: MLSCommon.f90,v 2.20 2004/06/10 01:00:50 vsnyder Exp $"
d47 6
d56 5
a60 5
  integer, parameter:: i1=selected_int_kind(2)
  integer, parameter:: i2=selected_int_kind(4)
  integer, parameter:: i4=selected_int_kind(7)
  integer, parameter:: r4=selected_real_kind(5)
  integer, parameter:: r8=selected_real_kind(13)
d70 4
a73 4
  integer, parameter:: rm=r4
  integer, parameter:: rp=r8
  integer, parameter:: ip=i4
  integer, parameter:: rv=r8
d77 4
a80 4
  integer, parameter :: NameLen=32
  integer, parameter :: LineLen=132
  integer, parameter :: FileNameLen=max(PGSd_PC_FILE_PATH_MAX, 132) ! was 132
  integer, parameter :: BareFNLen=64      ! Bare file name length (w/o path)
d82 2
a83 1
  real, parameter ::    DEFAULTUNDEFINEDVALUE = -999.99 ! Try to use in lib, l2
d123 16
d141 267
d409 108
d526 3
@


2.20
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d37 1
a37 1
       "$Id: MLSCommon.f90,v 2.19 2004/05/19 19:16:40 vsnyder Exp $"
a70 2

! Shouldn't this be PGSd_PC_FILE_PATH_MAX ?
d74 1
d79 1
a79 1
  ! Stop passing file handles back & forth bewteen routines
d81 1
d126 3
@


2.19
log
@Move MLSChunks_t to Chunks_m
@
text
@d13 1
a13 1
 ! === (start of toc) ===                                                 
a30 2
! FindFirst     Find the first logical in the array that is true
! FindNext      Find the next logical in the array that is true
a32 2
! int FindFirst (log condition(:))      
! int FindNext (log condition(:), int current, {log wrap}, {log repeat})      
d36 3
a38 3
  character (LEN=256) :: Id = &
       "$Id: MLSCommon.f90,v 2.18 2004/01/09 00:38:04 pwagner Exp $"
  character (LEN=*), parameter :: ModuleName= "$RCSfile: MLSCommon.f90,v $"
d42 1
a42 1
  ! This module contains simple definitions which are common to all the MLS PGS
a115 62
  ! -------------------------------------------- FindFirst --------------
  integer function FindFirst ( condition )
    ! Find the first logical in the array that is true
    logical, dimension(:), intent(in) :: CONDITION

    ! Local variables
    integer :: I                        ! Loop counter

    ! Executable code
    FindFirst = 0
    do i = 1, size(condition)
      if ( condition(i) ) then
        FindFirst = i
        return
      end if
    end do
  end function FindFirst

  ! -------------------------------------------- FindNext --------------
  integer function FindNext ( condition, current, wrap, repeat )
    ! Find the next logical in the array that is true after the current one
    ! May optionally wrap or repeat
    ! e.g., if repeat is true and current is also last true, return current
    ! e.g., if wrap is true and current is last true, return first true
    logical, dimension(:), intent(in) :: CONDITION
    integer, intent(in) :: CURRENT
    logical, optional, intent(in) :: WRAP
    logical, optional, intent(in) :: REPEAT

    ! Local variables
    integer :: I                        ! Loop counter
    logical :: myWrap
    logical :: myRepeat

    ! Executable code
    myWrap = .false.
    if ( present(wrap) ) myWrap = wrap
    myRepeat = .false.
    if ( present(repeat) ) myRepeat = repeat
    FindNext = 0
    ! We'll assume you gave us valid args; otherwise return 0
    if ( current < 1 .or. current > size(condition)) return
    if ( .not. condition(current)) return
    ! Now check for current already at end of array
    if ( current < size(condition) ) then
      do i = current+1, size(condition)
        if ( condition(i) ) then
          FindNext = i
          return
        end if
      end do
    endif
    ! Uh-oh, this means current is last true
    if ( myWrap ) then
      FindNext = FindFirst(condition)
    elseif ( myRepeat ) then
      FindNext = current
    endif
    return
  end function FindNext


d126 3
@


2.18
log
@Added FindNext function
@
text
@d41 1
a41 1
       "$Id: MLSCommon.f90,v 2.17 2003/06/20 19:31:39 pwagner Exp $"
a109 18
  ! This datatype defines the `chunks' into which the input dataset is split

  type MLSChunk_T
    integer :: firstMAFIndex   ! Index of first MAF in the chunk
    integer :: lastMAFIndex    ! Index of last MAF in the chunk
    integer :: noMAFsLowerOverlap ! Number of MAFs in the lower overlap region
    integer :: noMAFsUpperOverlap ! Number of MAFs in the upper overlap region
    integer :: chunkNumber              ! Index of this chunk
    integer, dimension(:), pointer :: HGridOffsets => NULL()
    ! This for each chunk is the index of the first non-overlapped profile in 
    ! each hGrid into the relevant output (l2gp?) file.
    integer, dimension(:), pointer :: HGridTotals => NULL()
    ! This is somewhat repetetive.  It's the total number of profiles in
    ! the output hGrid.  It's only really used in parallel runs.
  end type MLSChunk_T

  ! --------------------------------------------------------------------------

d192 3
@


2.17
log
@Changes to allow direct writing of products
@
text
@d1 1
a1 1
 ! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d32 1
d36 1
d41 1
a41 1
       "$Id: MLSCommon.f90,v 2.16 2003/02/17 03:52:49 livesey Exp $"
d156 43
d210 3
@


2.16
log
@Bit the bullet and changed rm to r4.
@
text
@d5 1
a5 1
MODULE MLSCommon                ! Common definitions for the MLS software
d8 1
a8 1
  USE SDPTOOLKIT, only: PGSd_PC_FILE_PATH_MAX
d10 2
a11 2
  IMPLICIT NONE
  PUBLIC
d36 1
a36 1
 PRIVATE :: Id, ModuleName
d38 3
a40 3
  CHARACTER (LEN=256) :: Id = &
       "$Id: MLSCommon.f90,v 2.15 2002/12/05 19:44:24 pwagner Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: MLSCommon.f90,v $"
d50 5
a54 5
  INTEGER, PARAMETER:: i1=SELECTED_INT_KIND(2)
  INTEGER, PARAMETER:: i2=SELECTED_INT_KIND(4)
  INTEGER, PARAMETER:: i4=SELECTED_INT_KIND(7)
  INTEGER, PARAMETER:: r4=SELECTED_REAL_KIND(5)
  INTEGER, PARAMETER:: r8=SELECTED_REAL_KIND(13)
d64 4
a67 4
  INTEGER, PARAMETER:: rm=r4
  INTEGER, PARAMETER:: rp=r8
  INTEGER, PARAMETER:: ip=i4
  INTEGER, PARAMETER:: rv=r8
d71 2
a72 2
  INTEGER, PARAMETER :: NameLen=32
  INTEGER, PARAMETER :: LineLen=132
d75 2
a76 2
  INTEGER, PARAMETER :: FileNameLen=max(PGSd_PC_FILE_PATH_MAX, 132) ! was 132
  INTEGER, PARAMETER :: BareFNLen=64      ! Bare file name length (w/o path)
d84 10
a93 10
  TYPE MLSFile_T
    CHARACTER (LEN=8) :: Type=""  ! e.g., 'ascii', 'hdf', 'swath', 'binary'
    CHARACTER (LEN=8) :: access=""  ! e.g., 'rdonly', 'write', 'rdwrite'
    CHARACTER (LEN=8) :: content=""  ! e.g., 'l1brad', 'l2gp', 'l2aux'
    CHARACTER (LEN=FileNameLen) :: Name=""  ! its name (usu. w/path)
    INTEGER :: File_Id=0     ! The HDF ID (handle) or io unit for the file
    INTEGER :: PCF_Id=0      ! The PCF ID (ref), if any,  for the file
    INTEGER :: HDFVersion=0  ! Which hdf version is the file if hdf(eos)
    LOGICAL :: StillOpen=.false.
  END TYPE MLSFile_T
d97 2
a98 2
  TYPE L1BInfo_T
    INTEGER :: L1BOAId=0     ! The HDF ID (handle) for the L1BOA file
d100 3
a102 3
    INTEGER, DIMENSION(:), POINTER :: L1BRADIds=>NULL()
    CHARACTER (LEN=FileNameLen) :: L1BOAFileName=""  ! L1BOA file name
    CHARACTER (LEN=FileNameLen), DIMENSION(:), POINTER :: &
d104 1
a104 1
  END TYPE L1BInfo_T
d110 13
a122 7
  TYPE MLSChunk_T
    INTEGER :: firstMAFIndex   ! Index of first MAF in the chunk
    INTEGER :: lastMAFIndex    ! Index of last MAF in the chunk
    INTEGER :: noMAFsLowerOverlap ! Number of MAFs in the lower overlap region
    INTEGER :: noMAFsUpperOverlap ! Number of MAFs in the upper overlap region
    INTEGER :: accumulatedMAFs ! Number of non overlapped MAFs before this.
  END TYPE MLSChunk_T
d128 4
a131 4
  TYPE TAI93_Range_T
    REAL(r8) :: startTime ! TAI93 format
    REAL(r8) :: endTime   ! TAI93 format
  END TYPE TAI93_Range_T
d165 3
@


2.15
log
@Moved MLSFile_T from MLSFiles to MLSCommon
@
text
@d39 1
a39 1
       "$Id: MLSCommon.f90,v 2.14 2002/11/06 00:16:48 pwagner Exp $"
d64 1
a64 1
  INTEGER, PARAMETER:: rm=r8
d159 3
@


2.14
log
@Added toc/api blocks
@
text
@d39 1
a39 1
       "$Id: MLSCommon.f90,v 2.13 2002/10/08 00:09:11 pwagner Exp $"
d80 15
d159 3
@


2.13
log
@Added idents to survive zealous Lahey optimizer
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d13 24
a36 1
  PRIVATE :: Id, ModuleName
d39 1
a39 1
       "$Id: MLSCommon.f90,v 2.12 2002/09/13 18:08:12 pwagner Exp $"
d144 3
@


2.12
log
@May change matrix precision rm from r8
@
text
@d16 1
a16 1
       "$Id: MLSCommon.f90,v 2.11 2002/08/28 22:16:18 pwagner Exp $"
d18 1
d112 5
a116 1
END MODULE MLSCommon
d121 3
@


2.11
log
@Added rm, rv types
@
text
@d16 1
a16 1
       "$Id: MLSCommon.f90,v 2.10 2002/02/19 23:10:54 pwagner Exp $"
d35 5
a39 5
  ! Final Letter          Context
  !    ----               -------
  !     m                 Matrix
  !     p                 Forward Model
  !     v                 Vector
d116 3
@


2.10
log
@Added BareFNLen
@
text
@d16 1
a16 1
       "$Id: MLSCommon.f90,v 2.9 2002/01/09 23:51:27 pwagner Exp $"
d34 7
d43 1
d116 3
@


2.9
log
@Connected FileNameLen with PGSd_PC_FILE_PATH_MAX
@
text
@d16 1
a16 1
       "$Id: MLSCommon.f90,v 2.8 2001/11/14 18:03:32 livesey Exp $"
d44 1
d108 3
@


2.8
log
@Changed FindFirst to return 0 not -1 if not found
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d8 2
d16 1
a16 1
       "$Id: MLSCommon.f90,v 2.7 2001/09/09 02:47:58 livesey Exp $"
d41 3
a43 1
  INTEGER, PARAMETER :: FileNameLen=132
d107 3
@


2.7
log
@Moved FindFirst into MLSCommon
@
text
@d14 1
a14 1
       "$Id: MLSCommon.f90,v 2.6.2.3 2001/09/09 01:53:27 livesey Exp $"
d87 1
a87 1
    FindFirst = -1
d103 3
@


2.6
log
@Initialised parameters in L1BINFO
@
text
@d14 1
a14 1
       "$Id: MLSCommon.f90,v 2.5 2001/03/10 18:48:17 livesey Exp $"
d30 5
d76 21
d103 12
@


2.6.2.1
log
@Added RP and IP
@
text
@d14 1
a14 1
       "$Id: MLSCommon.f90,v 2.6 2001/04/20 23:10:53 livesey Exp $"
a29 5
  ! Now choose the precision we want by preference (may automate this through
  ! make later on, with perl or m4 or something).
  INTEGER, PARAMETER:: rp=r8
  INTEGER, PARAMETER:: ip=i4

a76 3
! Revision 2.6  2001/04/20 23:10:53  livesey
! Initialised parameters in L1BINFO
!
@


2.6.2.2
log
@Moved FindFirst in from MLSL2Common
@
text
@d14 1
a14 1
       "$Id: MLSCommon.f90,v 2.6.2.1 2001/09/08 22:32:24 livesey Exp $"
a75 19
  ! -------------------------------------------- FindFirst --------------
  integer function FindFirst ( condition )
    ! Find the first logical in the array that is true
    logical, dimension(:), intent(in) :: CONDITION

    ! Local variables
    integer :: I                        ! Loop counter

    ! Executable code
    FindFirst = -1
    do i = 1, size(condition)
      if ( condition(i) ) then
        FindFirst = i
        return
      end if
    end do
  end function FindFirst


a81 3
! Revision 2.6.2.1  2001/09/08 22:32:24  livesey
! Added RP and IP
!
@


2.6.2.3
log
@Bug fix
@
text
@d14 1
a14 1
       "$Id: MLSCommon.f90,v 2.6.2.2 2001/09/09 01:35:46 livesey Exp $"
a75 2
  contains

a100 3
! Revision 2.6.2.2  2001/09/09 01:35:46  livesey
! Moved FindFirst in from MLSL2Common
!
@


2.5
log
@Really nullified the pointer!
@
text
@d14 1
a14 1
       "$Id: MLSCommon.f90,v 2.4 2001/03/10 07:06:46 livesey Exp $"
d41 1
a41 1
    INTEGER :: L1BOAId     ! The HDF ID (handle) for the L1BOA file
d44 1
a44 1
    CHARACTER (LEN=FileNameLen) :: L1BOAFileName  ! L1BOA file name
d77 3
@


2.4
log
@Nullified L1BRadfileNames in L1BInfo
@
text
@d14 1
a14 1
       "$Id: MLSCommon.f90,v 2.3 2001/02/09 00:38:55 livesey Exp $"
d42 2
a43 1
    INTEGER, DIMENSION(:), POINTER :: L1BRADIds ! Id(s) for the L1BRAD file(s)
d77 3
@


2.3
log
@Various changes
@
text
@d14 1
a14 1
       "$Id: MLSCommon.f90,v 2.2 2001/01/26 23:46:35 pwagner Exp $"
d44 2
a45 1
    CHARACTER (LEN=FileNameLen), DIMENSION(:), POINTER :: L1BRADFileNames
d76 3
@


2.2
log
@Restored L1BInfo from l1/MLSL1Common back to lib/MLSCommon
@
text
@d14 1
a14 1
       "$Id: MLSCommon.f90,v 2.0 2000/09/05 17:41:06 dcuddy Exp $"
a35 13
  ! This enumerated type defines the `modules' in the MLS instrument

  INTEGER, PARAMETER :: MLSInstrumentModule_Invalid=0
  INTEGER, PARAMETER :: MLSInstrumentModule_GHz=1
  INTEGER, PARAMETER :: MLSInstrumentModule_THz=2
  INTEGER, PARAMETER :: MLSInstrumentNoModules=2
  CHARACTER(LEN=3), PARAMETER, DIMENSION(MLSInstrumentNoModules) :: &
       & MLSInstrumentModuleNames = (/ &
       & "GHz", &
       & "THz" /)
  CHARACTER (LEN=3), PARAMETER, DIMENSION(MLSInstrumentNoModules) :: &
       & MLSInstrumentModuleNamesUC=(/"GHZ","THZ"/)

d75 3
@


2.1
log
@Moved L1BInfo to MLSL1Common
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d48 11
@


2.0
log
@Change revision to 2.0
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d14 1
a14 1
       "$Id: MLSCommon.f90,v 1.14 2000/09/02 01:58:30 vsnyder Exp $"
a49 11
  
  ! The next datatype describes the information on the L1B data files in use

  TYPE L1BInfo_T
    INTEGER :: L1BOAId     ! The HDF ID (handle) for the L1BOA file
    INTEGER, DIMENSION(:), POINTER :: L1BRADIds ! Id(s) for the L1BRAD file(s)
    CHARACTER (LEN=FileNameLen) :: L1BOAFileName  ! L1BOA file name
    CHARACTER (LEN=FileNameLen), DIMENSION(:), POINTER :: L1BRADFileNames
  END TYPE L1BInfo_T

  ! --------------------------------------------------------------------------
d77 3
@


1.13
log
@Taken our "parameter" from MLSInstrumentModuleNames.
@
text
@d14 1
a14 1
       "$Id: MLSCommon.f90,v 1.13 2000/06/19 23:07:46 lungu Exp $"
d24 5
a28 5
  INTEGER,PARAMETER:: i1=SELECTED_INT_KIND(2)
  INTEGER,PARAMETER:: i2=SELECTED_INT_KIND(4)
  INTEGER,PARAMETER:: i4=SELECTED_INT_KIND(7)
  INTEGER,PARAMETER:: r4=SELECTED_REAL_KIND(5)
  INTEGER,PARAMETER:: r8=SELECTED_REAL_KIND(13)
d32 3
a34 3
  INTEGER,PARAMETER :: NameLen=32
  INTEGER,PARAMETER :: LineLen=132
  INTEGER,PARAMETER :: FileNameLen=132
d42 2
a43 2
  CHARACTER (LEN=3),  DIMENSION(MLSInstrumentNoModules) :: &
       & MLSInstrumentModuleNames= (/ &
d45 1
a45 1
       & "THz"/)
d54 4
a57 4
     INTEGER :: L1BOAId     ! The HDF ID (handle) for the L1BOA file
     INTEGER, DIMENSION(:), POINTER :: L1BRADIds ! Id(s) for the L1BRAD file(s)
     CHARACTER (LEN=FileNameLen) :: L1BOAFileName  ! L1BOA file name
     CHARACTER (LEN=FileNameLen), DIMENSION(:), POINTER :: L1BRADFileNames
d65 5
a69 5
     INTEGER :: firstMAFIndex   ! Index of first MAF in the chunk
     INTEGER :: lastMAFIndex    ! Index of last MAF in the chunk
     INTEGER :: noMAFsLowerOverlap ! Number of MAFs in the lower overlap region
     INTEGER :: noMAFsUpperOverlap ! Number of MAFs in the upper overlap region
     INTEGER :: accumulatedMAFs ! Number of non overlapped MAFs before this.
d77 2
a78 2
     REAL(r8) :: startTime ! TAI93 format
     REAL(r8) :: endTime   ! TAI93 format
d88 2
a89 40
! Revision 1.13  2000/06/19 23:07:46  lungu
! Taken our "parameter" from MLSInstrumentModuleNames.
!
! Revision 1.12  2000/02/08 19:54:57  nakamura
! Moved TAI93_Range_T here from MLSL1Common.
!
! Revision 1.11  2000/02/02 14:59:53  perun
! Add filenames to L1BInfo Type
!
! Revision 1.10  1999/12/21 18:43:56  livesey
! Reinstated accumulatedMAFs
!
! Revision 1.9  1999/12/21 00:15:57  livesey
! Removed accumulatedMAFs from MLSChunk_T.  This functionality is now served by
! accumulatedProfiles in L2GPData_T
!
! Revision 1.8  1999/12/18 01:04:11  livesey
! Changed name to MLSInstrumentNoModules
!
! Revision 1.7  1999/12/17 21:33:45  livesey
! Still have a problem with MLSInstrumentModuleNames here.  It just doesn't
! seem to behave correctly.
!
! Revision 1.6  1999/12/17 00:59:31  livesey
! Nightly checkin
!
! Revision 1.5  1999/12/16 17:46:31  livesey
! Made the InstrumentModuleNames fixed dimensions.
!
! Revision 1.4  1999/12/16 01:27:28  livesey
! Added instrument module stuff
!
! Revision 1.3  1999/12/15 23:59:54  livesey
! Moved L1BInfo_T and MLSChunk_T in from MLSL2Common
!
! Revision 1.2  1999/12/14 01:01:14  livesey
! Whoops, didn't compile!
!
! Revision 1.1  1999/12/14 00:45:37  livesey
! First version, basically just the old `kinds' module.
d91 2
@


1.1
log
@First version, basically just the old `kinds' module.
@
text
@d9 1
d14 1
a14 1
       "$Id: MLSCommon.f90,v 1.1 1999/12/14 00:45:37 livesey Exp $"
d30 52
d83 1
a83 1
END MODULE module_name
d88 38
@


