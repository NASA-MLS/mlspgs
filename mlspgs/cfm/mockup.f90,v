head	1.62;
access;
symbols
	v5-02-NRT-19:1.62
	v6-00:1.62
	v5-02-NRT-18:1.62
	v5-02:1.60
	v5-01-NRT-17:1.62
	v5-01-NRT-16:1.62
	v5-01-NRT-15:1.62
	v5-01-NRT-14:1.62
	neuralnetworks-1-0:1.62.0.4
	cfm-single-freq-0-2:1.62.2.2.0.2
	cfm-single-freq-0-1:1.62.0.2
	TES-MLuo-01:1.62
	TES-UNKNOWN:1.61
	v5-01:1.60
	v5-00:1.60
	v4-23-TA133:1.60.0.6
	mus-emls-1-70:1.60.0.4
	rel-1-0-englocks-work:1.60.0.2
	VUMLS1-00:1.60
	VPL1-00:1.60
	V4-22-NRT-08:1.60
	VAM1-00:1.59
	V4-21:1.57.0.2
	V4-13:1.57
	V4-12:1.57
	V4-11:1.57
	V4-10:1.57
	V3-43:1.4
	M4-00:1.57
	V3-41:1.4
	V3-40-PlusGM57:1.4.0.2
	V3-33:1.47
	V3-31:1.47
	V3-30-NRT-05:1.41
	cfm-01-00:1.35
	V3-30:1.4
	V3-20:1.4;
locks; strict;
comment	@# @;


1.62
date	2020.07.15.20.46.51;	author pwagner;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2020.03.30.22.41.48;	author pwagner;	state Exp;
branches;
next	1.60;

1.60
date	2016.03.29.18.40.07;	author pwagner;	state Exp;
branches;
next	1.59;

1.59
date	2015.08.05.20.21.29;	author pwagner;	state Exp;
branches;
next	1.58;

1.58
date	2015.08.05.20.19.24;	author pwagner;	state Exp;
branches;
next	1.57;

1.57
date	2011.12.24.18.39.13;	author honghanh;	state Exp;
branches;
next	1.56;

1.56
date	2011.12.23.22.56.12;	author honghanh;	state Exp;
branches;
next	1.55;

1.55
date	2011.12.15.16.53.24;	author honghanh;	state Exp;
branches;
next	1.54;

1.54
date	2011.12.14.22.54.18;	author honghanh;	state Exp;
branches;
next	1.53;

1.53
date	2011.11.10.17.07.07;	author honghanh;	state Exp;
branches;
next	1.52;

1.52
date	2011.11.08.16.13.57;	author honghanh;	state Exp;
branches;
next	1.51;

1.51
date	2011.11.03.17.44.32;	author honghanh;	state Exp;
branches;
next	1.50;

1.50
date	2011.11.02.04.20.16;	author honghanh;	state Exp;
branches;
next	1.49;

1.49
date	2011.11.02.04.19.28;	author honghanh;	state Exp;
branches;
next	1.48;

1.48
date	2011.03.24.15.16.46;	author honghanh;	state Exp;
branches;
next	1.47;

1.47
date	2010.11.22.17.02.45;	author honghanh;	state Exp;
branches;
next	1.46;

1.46
date	2010.11.19.17.16.08;	author honghanh;	state Exp;
branches;
next	1.45;

1.45
date	2010.11.18.19.04.13;	author honghanh;	state Exp;
branches;
next	1.44;

1.44
date	2010.11.03.20.17.01;	author honghanh;	state Exp;
branches;
next	1.43;

1.43
date	2010.11.03.18.34.46;	author honghanh;	state Exp;
branches;
next	1.42;

1.42
date	2010.09.28.14.42.42;	author honghanh;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.21.16.19.11;	author honghanh;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.21.15.06.49;	author honghanh;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.06.14.15.06;	author honghanh;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.05.16.23.03;	author honghanh;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.12.16.28.15;	author honghanh;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.08.21.39.16;	author honghanh;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.29.18.49.32;	author honghanh;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.29.17.02.47;	author honghanh;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.29.15.29.33;	author honghanh;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.29.02.28.17;	author honghanh;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.29.00.20.13;	author honghanh;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.28.22.25.08;	author honghanh;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.28.18.49.53;	author honghanh;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.28.17.29.47;	author honghanh;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.16.18.42.35;	author honghanh;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.01.20.41.14;	author honghanh;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.25.18.02.11;	author honghanh;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.24.18.03.02;	author honghanh;	state Exp;
branches;
next	1.23;

1.23
date	2010.05.23.02.10.06;	author honghanh;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.23.01.23.40;	author honghanh;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.23.00.07.32;	author honghanh;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.22.21.18.39;	author honghanh;	state Exp;
branches;
next	1.19;

1.19
date	2010.03.24.17.44.48;	author honghanh;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.24.16.26.17;	author honghanh;	state Exp;
branches;
next	1.17;

1.17
date	2010.03.18.23.17.37;	author honghanh;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.18.22.51.33;	author honghanh;	state Exp;
branches;
next	1.15;

1.15
date	2010.03.18.22.16.46;	author honghanh;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.18.20.42.05;	author honghanh;	state Exp;
branches;
next	1.13;

1.13
date	2010.03.16.22.20.53;	author honghanh;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.15.22.07.38;	author honghanh;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.15.22.06.56;	author honghanh;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.14.19.24.26;	author honghanh;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.09.22.39.38;	author honghanh;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.02.23.51.47;	author honghanh;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.02.22.46.04;	author honghanh;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.02.22.10.23;	author honghanh;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.02.21.09.57;	author honghanh;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.17.22.25.33;	author honghanh;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.17.20.29.39;	author honghanh;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.17.19.15.01;	author honghanh;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.17.16.41.33;	author honghanh;	state Exp;
branches;
next	;

1.62.2.1
date	2020.09.15.23.26.36;	author whdaffer;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2020.09.30.19.34.13;	author whdaffer;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Copied from MLuo
@
text
@! Copyright 2010, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! This program is meant to serve as an example, and proof that the CFM library
! is working. Consequently, the design of this program does not follow good
! software design principles. This program should not be used as a part in
! any programs or software suite meant for long-term use.

program mockup

    use CFM
    use highOutput, only: outputNamedValue
    use input
    use machine, only: getarg

    ! To convert MAF to Profile, Pranjit Saha 
    use global_settings, only: L1MAFToL2Profile, L2ProfileToL1MAF
    use MLSL2Options, only: Toolkit
    use MLSHDF5, only: MLS_H5OPEN, MLS_H5CLOSE

    implicit none

!---------------------------- RCS Ident Info ------------------------------
    character (len=*), parameter :: ModuleName= &
        "$RCSfile: mockup.f90,v $"
    character (len=*), parameter :: IdParm = &
        "$Id: mockup.f90,v 1.51 2011/11/03 17:44:32 honghanh Exp $"
    character (len=len(idParm)) :: Id = idParm
!---------------------------------------------------------------------------

    integer :: i

    ! To write values in file, read MLS L1BOA and L2GP files, Pranjit Saha
    CHARACTER(LEN=20), PARAMETER :: FMT1 = "(F16.5)"
    CHARACTER(LEN=20), PARAMETER :: FMT2 = "(E18.8)"
    integer :: FileIndex2
    type (MLSFile_T), dimension(:), pointer :: FileDatabase2 => null()
    type (MLSFile_T) :: L1BFile2, L2GPFile2
    integer :: startL1Maf_new
    integer :: endL1Maf_new
    ! For reading ptan Values from L2AUX-DGM file, Pranjit Saha
    real(r8), dimension(125) :: ptanValuesRead

    type(ForwardModelConfig_T), dimension(:), pointer :: forwardModelConfigDatabase
    type(MLSFile_T), dimension(:), pointer :: filedatabase
    type(MLSFile_T) :: l1bfile
    type(VGrid_T) :: vGridStandard55, vGridStandard37, vGridTESCO, vGridRefGPH
    type(VGrid_T) :: vGridExtinction
    type(HGrid_T) :: hGridStandard
    type(FGrid_T) :: fGridExtinctionConstant
    type(QuantityTemplate_T) :: qtemp, qCO, qso2, qhno3, qo3, qextinctionv2r3
    type(QuantityTemplate_T) :: qphitanGhz, qrefGPH, qgph, qisotoperatioO_18_O
    type(QuantityTemplate_T) :: qisotoperatioO3_ASYM_O_18, qisotoperatioO3_V2
    type(QuantityTemplate_T) :: qisotoperatioHNO3, qisotoperatioCO, qband7
    type(QuantityTemplate_T) :: qisotoperatioO3, qisotoperatioS_32_O2, newer_qptanGHz
    type(QuantityTemplate_T) :: qisotoperatioO3_SYM_O_18, qbaseline7
    type(Vector_T) :: state, stateExtra
    type(Vector_T) :: radiance, diffVector
    type(Vector_T) :: observed, obsPrecision
    type(Vector_T) :: corrections, correctionNoise
    character(len=3) :: GHz = "GHz"
    character(len=2) :: sc = "sc"
    type(VectorValue_T) :: temperature, co, o2, so2, hno3, o3, extinctionv2r3, newer_ptanGHz 
    type(VectorValue_T) :: phitanGhz, refGPH, gph, isotoperatioO_18_O, isotoperatioO3
    type(VectorValue_T) :: isotoperatioO3_ASYM_O_18, isotoperatioO3_V2, isotoperatioS_32_O2
    type(VectorValue_T) :: isotoperatioHNO3, isotoperatioCO, limbSidebandFraction7L
    type(VectorValue_T) :: limbSidebandFraction7U, elev7L, elev7U, earthReflectivity
    type(VectorValue_T) :: orbitInclination, spaceRadiance, scGeocAlt, tngtGeocAltGHz
    type(VectorValue_T) :: losVelGHz, band7, isotoperatioO3_SYM_O_18, precision7
    type(VectorValue_T) :: correction7, noise7
    character(len=256) :: signalFileName, configFileName
    type(Matrix_T) :: jacobian
    integer :: error

    call getarg(1, signalFileName)
    call getarg(2, configFileName)
    Toolkit = .false.

    nullify(filedatabase)

    call CFM_MLSSetup(signalFileName, configFileName, forwardModelConfigDatabase)

    ! Convert profile to MAF (Major Frame) number, Pranjit Saha
    FileIndex2 = InitializeMLSFile( L1BFile2, content = 'l1boa', &
      & name=trim(l1boa), shortName='L1BOA', type=l_hdf, access=DFACC_RDONLY )
    FileIndex2 = AddFileToDataBase( FileDatabase2, L1BFile2 ) 

    FileIndex2 = InitializeMLSFile( L2GPFile2, content = 'l2gp', &
      & name=trim(L2GP), shortName='L2GP', &
      & type=l_hdfeos, access=DFACC_RDONLY )
    FileIndex2 = AddFileToDataBase( FileDatabase2, L2GPFile2 )

    startL1Maf_new = L2ProfileToL1MAF( startProfile, FileDatabase2 )
    endL1Maf_new = L2ProfileToL1MAF( endProfile, FileDatabase2 )

    ! Read ptanGHz values from  MLS *DGM* file, Pranjit Saha
    call Read_ptan(l2dgm, 'HDF5', startL1Maf_new, ptanValuesRead)    

    !========================= Run the forward model ==========================

    ! Read L1BOA file
    error = InitializeMLSFile (l1bfile, content='l1boa', name=trim(l1boa), &
    shortName='L1BOA', type=l_hdf, access=DFACC_RDONLY)
    if (error /= 0) call MLSMessage (MLSMSG_Error, moduleName, &
    "Error initializing " // trim(l1boa))
    call mls_openfile (l1bfile, error)
    if (error /= 0) call MLSMessage (MLSMSG_Error, moduleName, &
    "Error opening " // trim(l1boa))
    ! don't care about return value of the following function
    i = AddFileToDatabase(filedatabase, l1bfile)

   ! Create necessary template and vector for ptanGHz already read from file, Pranjit Saha
   newer_qptanGHz = CreateQtyTemplate(l_ptan, startL1Maf_new, endL1Maf_new, &
     & filedatabase=filedatabase, qInstModule='Ghz')
   newer_ptanGHz  = CreateValue4AgileVector(newer_qptanGHz, value=ptanValuesRead)

    ! Ming: Haley assumes 0-based indexing for L1Maf
    startL1Maf_new = startL1Maf_new - 1
    endL1Maf_new = endL1Maf_new - 1

    ! read MLS input data file
    call Read_Spectroscopy (spectroscopy, 'HDF5')
    call ReadAntennaPatterns (antennaPatterns)
    call ReadFilterShapes(filterShapes)
    call ReadDACSFilterShapes (DACSFilterShapes)
    call ReadPointingGrids (pointingGrids)

    do i = 1, size(pfaFiles)
        call ReadPFAFile (pfaFiles(i))

    end do
    do i = 1, size(l2pc)
        call ReadHDF5L2PC (l2pc(i))
    end do

    vGridStandard37 = CreateVGrid (l_zeta, phyq_pressure, l_logarithmic, &
                                   start=1000.0d0, formula="37:6")

    vGridRefGPH = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
                               values=(/100.0_r8/))
    vGridStandard55 = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
    values=(/1000.00_r8,  825.404_r8,  681.292_r8,  562.341_r8,  464.159_r8,  &
             383.119_r8,  316.228_r8,  261.016_r8,  215.443_r8,  177.828_r8,  &
             146.780_r8,  121.153_r8,  100.000_r8,  82.5404_r8,  68.1292_r8,  &
             56.2341_r8,  46.4159_r8,  38.3119_r8,  31.6228_r8, 26.1016_r8,  &
             21.5443_r8,  17.7828_r8,  14.6780_r8,  12.1153_r8,  10.0000_r8, &
             8.25404_r8,  6.81292_r8,  5.62341_r8,  4.64159_r8,  3.83119_r8,  &
             3.16228_r8,  2.61016_r8,  2.15443_r8,  1.77828_r8,  1.46780_r8,  &
             1.21153_r8,  1.00000_r8,  0.681292_r8, 0.464159_r8,  0.316228_r8, &
             0.215443_r8, 0.146780_r8,  0.100000_r8,  0.0464159_r8, 0.0215443_r8, &
             0.01000_r8,  0.00464159_r8, 0.00215443_r8, 0.00100_r8, 0.000464159_r8,&
             0.000215443_r8, 0.000100_r8, 4.64159e-05_r8, 2.15443e-05_r8, 1.00000e-05_r8 /))

    vGridTESCO = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
   values= (/   1.00829E+03_r8,   1.00000E+03_r8,   9.08514E+02_r8,   8.25402E+02_r8,   7.49893E+02_r8, &
            6.81291E+02_r8,   6.18966E+02_r8,   5.62342E+02_r8,   5.10898E+02_r8,   4.64160E+02_r8, &
            4.21698E+02_r8,   3.83117E+02_r8,   3.48069E+02_r8,   3.16227E+02_r8,   2.87298E+02_r8, &
            2.61016E+02_r8,   2.37137E+02_r8,   2.15444E+02_r8,   1.95735E+02_r8,   1.77829E+02_r8, &
            1.61561E+02_r8,   1.46779E+02_r8,   1.33352E+02_r8,   1.21152E+02_r8,   1.10069E+02_r8, &
            1.00000E+02_r8,   9.08518E+01_r8,   8.25406E+01_r8,   7.49896E+01_r8,   6.81295E+01_r8, &
            6.18963E+01_r8,   5.62339E+01_r8,   5.10896E+01_r8,   4.64158E+01_r8,   4.21696E+01_r8, &
            3.83119E+01_r8,   3.48071E+01_r8,   3.16229E+01_r8,   2.87299E+01_r8,   2.61017E+01_r8, &
            2.37136E+01_r8,   2.15443E+01_r8,   1.95734E+01_r8,   1.77828E+01_r8,   1.61560E+01_r8, &
            1.46780E+01_r8,   1.33352E+01_r8,   1.21153E+01_r8,   1.10070E+01_r8,   1.00000E+01_r8, &
            9.08514E+00_r8,   8.25402E+00_r8,   6.81291E+00_r8,   5.10898E+00_r8,   4.64160E+00_r8, &
            3.16227E+00_r8,   2.61016E+00_r8,   2.15443E+00_r8,   1.61560E+00_r8,   1.33352E+00_r8, &
            1.00000E+00_r8,   6.81292E-01_r8,   3.83118E-01_r8,   2.15443E-01_r8,   1.00000E-01_r8 /))

    vGridExtinction = CreateVGrid (l_zeta, phyq_pressure, l_logarithmic, &
    start=1000.0d0, formula="21:12,14:6,12:3")

    ! Have insetoverlaps, and not single
    hGridStandard = CreateRegularHGrid(GHz, 0.0_r8, 1.5_r8, .true., &
                                       filedatabase, startL1Maf_new, endL1Maf_new)

    fGridExtinctionConstant = CreateFGrid(L_IntermediateFrequency, (/0.0_r8/))

    ! Construct state vector
    state = CreateAgileVector(name='state')

    qtemp = CreateQtyTemplate(l_temperature, qName='temperature', &
                              avgrid=vGridStandard55, ahgrid=hGridStandard)
    temperature = CreateValue4AgileVector(qtemp, value=TemperatureInput)
    ! call outputNamedValue ( 'is T qtyTemplate%crossAngles associated?', &
    !   & associated(qtemp%crossAngles) )
    ! call outputNamedValue ( 'is T%qtyTemplate%crossAngles associated?', &
    !   & associated(temperature%template%crossAngles) )
    call AddValue2Vector(state, temperature)

    qCO = CreateQtyTemplate(l_vmr, avgrid=vGridTESCO, ahgrid=hGridStandard, &
    qMolecule=l_co, qName='CO')
    !co = CreateValue4AgileVector(qco, value=COInput)
    !call AddValue2Vector(state, co)

    o2 = CreateMLSValue_O2 (vGridStandard37, hGridStandard)
    call AddValue2Vector(state, o2)

    qSO2 = CreateQtyTemplate(l_vmr, avgrid=vGridStandard37, ahgrid=hGridStandard, &
    qMolecule=l_so2, qName='SO2')
    so2 = CreateValue4AgileVector(qSO2, value=SO2Input)
    call AddValue2Vector(state, so2)

    qHNO3 = CreateQtyTemplate(l_vmr, avgrid=vGridStandard37, ahgrid=hGridStandard, &
    qMolecule=l_hno3, qName='HNO3')
    hno3 = CreateValue4AgileVector(qhno3, value=HNO3Input)
    call AddValue2Vector(state, hno3)

    qO3 = CreateQtyTemplate(l_vmr, avgrid=vGridTESCO, ahgrid=hGridStandard, &
    ! qO3 = CreateQtyTemplate(l_vmr, avgrid=vGridStandard55, ahgrid=hGridStandard, &
    qMolecule=l_o3, qName='O3')
    o3 = CreateValue4AgileVector(qo3, value=O3Input)
    call AddValue2Vector(state, o3)

    qExtinctionv2r3 = CreateQtyTemplate(l_vmr, avgrid=vGridStandard55, &
    ! qExtinctionv2r3 = CreateQtyTemplate(l_vmr, avgrid=vGridExtinction, &
    ahgrid=hGridStandard, afgrid=fgridExtinctionConstant, qRadiometer="R3", &
    qMolecule=l_extinctionv2)
    extinctionv2r3 = CreateValue4AgileVector(qExtinctionv2r3, value=extinctionV2R3Input)
    call AddValue2Vector(state, extinctionv2r3)
    call outputnamedValue( 'size(state)', size(state%quantities) )
    call Dump( state, details=-1 )

    stateExtra = CreateAgileVector(name='stateExtra')

    qPhitanGHz = CreateQtyTemplate(l_phitan, startL1Maf_new, endL1Maf_new, qInstModule=GHz, &
    filedatabase=filedatabase, qName='phitanGHz')
    phitanGhz = CreateValue4AgileVector(qPhitanGhz)
    call FillPhitanQuantity(phitanGhz)
    call AddValue2Vector(stateExtra, phitanGhz)

    qRefGPH = CreateQtyTemplate(l_refGPH, avgrid=vGridRefGPH, &
    ahgrid=hGridStandard, qName='refGPH')
    refGPH = CreateValue4AgileVector(qRefGPH, spreadvalue=refGPHInput) ! unit is meter
    call AddValue2Vector(stateExtra, refGPH)

    qGPH = CreateQtyTemplate(l_gph, avgrid=vGridStandard55, ahgrid=hGridStandard, &
                             qName='GPH')
    gph = CreateValue4AgileVector(qGPH)
    call AddValue2Vector(stateExtra, gph)

    qIsotoperatioO_18_O = CreateQtyTemplate(l_isotoperatio, &
    qName='isotoperatioO_18_O', qmolecule=l_o_18_o)
    isotoperatioO_18_O = CreateValue4AgileVector(qIsotoperatioO_18_O, &
    spreadvalue=0.00409000_r8)
    call AddValue2Vector(stateExtra, isotoperatioO_18_O)

    qIsotoperatioO3 = CreateQtyTemplate(l_isotoperatio, qName='isotoperatioO3', &
    qmolecule=l_o3)
    isotoperatioO3 = CreateValue4AgileVector(qIsotoperatioO3, &
    spreadvalue=0.99290103_r8)
    call AddValue2Vector(stateExtra, isotoperatioO3)

    qIsotoperatioO3_ASYM_O_18 = CreateQtyTemplate(l_isotoperatio, &
    qmolecule=l_o3_asym_o_18, qName='isotoperatioO3_ASYM_O_18')
    isotoperatioO3_ASYM_O_18 = CreateValue4AgileVector(qIsotoperatioO3_ASYM_O_18, &
    spreadvalue=0.00398194_r8)
    call AddValue2Vector(stateExtra, isotoperatioO3_ASYM_O_18)

    qIsotoperatioO3_SYM_O_18 = CreateQtyTemplate(l_isotoperatio, &
    qmolecule=l_o3_sym_o_18, qName='isotoperatioO3_SYM_O_18')
    isotoperatioO3_SYM_O_18 = CreateValue4AgileVector(qIsotoperatioO3_SYM_O_18, &
    spreadvalue=0.00199097_r8)
    call AddValue2Vector(stateExtra, isotoperatioO3_SYM_O_18)

    qIsotoperatioO3_V2 = CreateQtyTemplate(l_isotoperatio, qmolecule=l_o3_v2, &
    qName='isotoperatioO3_V2')
    isotoperatioO3_V2 = CreateValue4AgileVector(qIsotoperatioO3_V2, &
    spreadvalue=0.99290103_r8)
    call AddValue2Vector(stateExtra, isotoperatioO3_V2)

    qIsotoperatioS_32_O2 = CreateQtyTemplate(l_isotoperatio, qmolecule=l_s_32_o2, &
    qName='isotoperatioS_32_O2')
    isotoperatioS_32_O2 = CreateValue4AgileVector(qIsotoperatioS_32_O2, &
    spreadvalue=0.94568002_r8)
    call AddValue2Vector(stateExtra, isotoperatioS_32_O2)

    qIsotoperatioHNO3 = CreateQtyTemplate(l_isotoperatio, qmolecule=l_hno3, &
    qName='isotoperatioHNO3')
    isotoperatioHNO3 = CreateValue4AgileVector(qIsotoperatioHNO3, &
    spreadvalue=0.98910999_r8)
    call AddValue2Vector(stateExtra, isotoperatioHNO3)

    qIsotoperatioCO = CreateQtyTemplate(l_isotoperatio, qmolecule=l_co, &
    qName='isotoperatioCO')
    isotoperatioCO = CreateValue4AgileVector(qIsotoperatioCO, &
    spreadvalue=0.98654002_r8)
    call AddValue2Vector(stateExtra, isotoperatioCO)

    ! Fill orbit inclination, tangent geocentric altitude with
    ! data from MLS L1B file, and use them, along with other
    ! quantities to calculate ptan
    limbSidebandFraction7L = CreateMLSValue_LSF(7, .false.)
    call AddValue2Vector(stateExtra, limbSidebandFraction7L)

    limbSidebandFraction7U = CreateMLSValue_LSF(7, .true.)
    call AddValue2Vector(stateExtra, limbSidebandFraction7U)

    elev7L = CreateMLSValue_ElevationOffset(7, .false.)
    call AddValue2Vector(stateExtra, elev7L)

    elev7U = CreateMLSValue_ElevationOffset(7, .true.)
    call AddValue2Vector(stateExtra, elev7U)

    earthReflectivity = CreateMLSValue_EarthReflectivity()
    call AddValue2Vector(stateExtra, earthReflectivity)

    orbitInclination = CreateMLSValue_FromL1BOA (l_orbitInclination, sc, &
    filedatabase, startL1Maf_new, endL1Maf_new)
    call AddValue2Vector(stateExtra, orbitInclination)

    spaceRadiance = CreateMLSValue_SpaceRadiance()
    call AddValue2Vector(stateExtra, spaceRadiance)

    scGeocAlt = CreateMLSValue_FromL1BOA(l_scgeocalt, sc, filedatabase, &
    startL1Maf_new, endL1Maf_new)
    call AddValue2Vector(stateExtra, scGeocAlt)

    tngtGeocAltGHz = CreateMLSValue_FromL1BOA (l_tngtgeocalt, GHz, &
    filedatabase, startL1Maf_new, endL1Maf_new)
    call AddValue2Vector(stateExtra, tngtGeocAltGHz)

    losVelGHz = CreateMLSValue_FromL1BOA(l_losVel, GHz, filedatabase, &
    startL1Maf_new, endL1Maf_new)
    call AddValue2Vector(stateExtra, losVelGHz)

    radiance = CreateAgileVector(name='simulatedRadiance')

    qband7 = CreateQtyTemplate(l_radiance, startL1Maf_new, endL1Maf_new, filedatabase, &
                               qSignal="R3:240.B7F:O3", qName='band7')
    band7 = CreateValue4AgileVector(qband7)
    call AddValue2Vector(radiance, band7)

    ! Add ptan_GHz values read from file in the stateExtra, Pranjit Saha
    call AddValue2Vector(stateExtra, newer_ptanGHz)

    ! We no longer need vGrid because the quantity templates have copied it
    call DestroyVGridContents(vGridStandard55)
    call DestroyVGridContents(vGridStandard37)
    call DestroyVGridContents(vGridTESCO)
    ! No long need hGrid, fGrid either
    call DestroyHGridContents(hGridStandard)
    call DestroyFGridContents(fGridExtinctionConstant)

    ! GPH is filled by the forward model

    ! Create jacobian
    jacobian = CreatePlainMatrix(radiance, state)

    ! Call the forward model
    call ForwardModel2 (0, forwardModelConfigDatabase, state, &
                        stateExtra, radiance, jacobian)

    ! Write 'state', 'radiance', 'jacobian', 'ptanGHz' in separate files, Pranjit Saha
    call Write_To_File1 (state, radiance, jacobian, newer_ptanGHz)

    !=================== Finish running the forward model =====================

    !== Clean up anything that is not related to reading observed radiance ====
    call DestroyMatrix(jacobian)
    call DestroyAgileVectorContent (state)
    call DestroyAgileVectorContent (stateExtra)
    call Destroy_DACS_Filter_Database
    call Destroy_Filter_Shapes_Database
    call Destroy_Ant_Patterns_Database
    call Destroy_SpectCat_Database
    call Destroy_Line_Database
    call Destroy_Pointing_Grid_Database
    call DestroyL2PCDatabase
    call Destroy_PFADataBase

    ! Destroy all quantity templates that goes in state and stateExtra
    if ( .false. ) then
    call DestroyQuantityTemplateContents(qtemp)
    call DestroyQuantityTemplateContents(qCO)
    call DestroyQuantityTemplateContents(qSO2)
    call DestroyQuantityTemplateContents(qHNO3)
    call DestroyQuantityTemplateContents(qO3)
    call DestroyQuantityTemplateContents(qExtinctionv2r3)
    call DestroyQuantityTemplateContents(newer_qPtanGHz)
    call DestroyQuantityTemplateContents(qPhitanGHz)
    call DestroyQuantityTemplateContents(qRefGPH)
    call DestroyQuantityTemplateContents(qGPH)
    call DestroyQuantityTemplateContents(qIsotoperatioO_18_O)
    call DestroyQuantityTemplateContents(qIsotoperatioO3)
    call DestroyQuantityTemplateContents(qIsotoperatioO3_ASYM_O_18)
    call DestroyQuantityTemplateContents(qIsotoperatioO3_SYM_O_18)
    call DestroyQuantityTemplateContents(qIsotoperatioO3_V2)
    call DestroyQuantityTemplateContents(qIsotoperatioS_32_O2)
    call DestroyQuantityTemplateContents(qIsotoperatioHNO3)
    call DestroyQuantityTemplateContents(qIsotoperatioCO)
    ! even quantities created by CFM subroutines has templates
    call DestroyQuantityTemplateContents(o2%template)
    call DestroyQuantityTemplateContents(limbSidebandFraction7L%template)
    call DestroyQuantityTemplateContents(limbSidebandFraction7U%template)
    call DestroyQuantityTemplateContents(elev7L%template)
    call DestroyQuantityTemplateContents(elev7U%template)
    call DestroyQuantityTemplateContents(earthReflectivity%template)
    call DestroyQuantityTemplateContents(orbitInclination%template)
    call DestroyQuantityTemplateContents(spaceRadiance%template)
    call DestroyQuantityTemplateContents(scGeocAlt%template)
    call DestroyQuantityTemplateContents(tngtGeocAltGHz%template)
    call DestroyQuantityTemplateContents(losVelGHz%template)
    endif
    ! stop
    !========================== finish cleaning ===============================

    !====================== Read observed radiance ============================
    ! Open l1brad
    error = InitializeMLSFile(l1bfile, content='l1brad', &
    name=trim(l1brad), shortName='L1BRAD', type=l_hdf, access=DFACC_RDONLY)
    if (error /= 0) call MLSMessage (MLSMSG_Error, moduleName, &
    "Error initializing " // trim(l1brad))

    call mls_openFile(l1bfile, error)
    if (error /= 0 ) call MLSMessage (MLSMSG_Error, moduleName, &
    "Error opening " // trim(l1brad))

    ! Add it to the filedatabase
    ! AddFileToDatabase doesn't return an error.
    ! I don't care about the return value of AddFileToDatabase,
    ! but Fortran dictate that the return value has to be captured,
    ! so error is being used as a dummy variable.
    error = AddFileToDatabase(filedatabase, l1bfile)

    observed = CreateAgileVector(name='observedRadiance')
    obsPrecision = CreateAgileVector(name='observedRadiancePrecision')

    ! need to read precision before reading quantity
    band7 = CreateValue4AgileVector(qband7)
    call AddValue2Vector(observed, band7)
    ! precision of a quantity has the same template as the quantity
    precision7 = CreateValue4AgileVector(qband7)
    call AddValue2Vector(obsPrecision, precision7)

    ! need to fill precision first
    call FillVectorQuantityFromL1B(precision7, startL1Maf_new, endL1Maf_new, &
    filedatabase, .true.)
    ! then fill the quantity and setting precision at the same time
    call FillVectorQuantityFromL1B(band7, startL1Maf_new, endL1Maf_new, &
    filedatabase, .false., precisionQuantity=precision7)

    ! then we need to get the baseline correction and noise
    qbaseline7 = CreateQtyTemplate(l_l1bmafbaseline, startL1Maf_new, endL1Maf_new, &
    filedatabase, qSignal="R3:240.B7F:O3", qname='baseline 7')

    correction7 = CreateValue4AgileVector (qbaseline7)
    ! the space in ' Baseline' is very important
    call FillVectorQuantityFromL1B(correction7, startL1Maf_new, endL1Maf_new, &
    filedatabase, .false., suffix=' Baseline')

    ! apply correction to the quantity
    call ApplyBaseline (band7, correction7, .false., .false.)

    ! get the noise
    noise7 = CreateValue4AgileVector(qbaseline7) ! same template as baseline
    ! again, the string must match exactly
    call FillVectorQuantityFromL1B(noise7, startL1Maf_new, endL1Maf_new, &
    filedatabase, .false., suffix=' Baseline precision')

    ! apply the noise to the precision
    call ApplyBaseline (precision7, noise7, .true., .false.)

    ! Write 'band7' and 'precision7' in separate text files, Pranjit Saha
    call Write_To_File2 (band7, precision7)

    !==================== Finish reading observed radiance ====================

    !============= At this point we don't need L1B file anymore ===============
    do i = 1, size(filedatabase)
        call mls_closefile(filedatabase(i))
    end do

    deallocate(filedatabase)
    nullify(filedatabase)
    !================== Done closing and clean up file objects ================

    diffVector = observed - radiance

    !===== Clean up calculated and observed radiance and related vectors ======
    call DestroyAgileVectorContent (radiance)
    call DestroyAgileVectorContent (observed)
    call DestroyAgileVectorContent (diffVector)
    call DestroyAgileVectorContent (obsPrecision)

    call DestroyVectorValueContent (noise7)
    call DestroyVectorValueContent (correction7)

    call DestroyQuantityTemplateContents(qband7)
    call DestroyQuantityTemplateContents(qbaseline7)
    !========================== Done cleaning up ==============================

    call CFM_MLSCleanup(forwardModelConfigDatabase)

end program

! $Log: mockup.f90,v $
! Revision 1.51  2011/11/03 17:44:32  honghanh
! Bug fix in mockup
!
! Revision 1.50  2011/11/02 04:20:16  honghanh
! Mockup for new CFM API.
!
! Revision 1.48  2011/03/24 15:16:46  honghanh
! Add new interfaces for creating vector and vector values without going through quantity template databases
!
! Revision 1.44  2010/11/03 20:17:01  honghanh
! Add name as an optional argument to CreateVector.
!
! Revision 1.42  2010/09/28 14:42:42  honghanh
! Add call to forwardModel with jacobian
!
! Revision 1.39  2010/08/06 14:15:06  honghanh
! Call dump on diff vector instead of measurement vector.
!
! Revision 1.38  2010/08/05 16:23:03  honghanh
! Added Jacobian to forwardModel subroutine
!
! Revision 1.36  2010/07/08 21:39:16  honghanh
! Add ApplyBaseline to cfm_fill_m
!
! Revision 1.34  2010/06/29 17:02:47  honghanh
! Change the identifier 'fakeChunk' to 'chunk' because
! since it is created with ChunkDivide, it's as real as a chunk
! can get.
!
! Revision 1.33  2010/06/29 15:29:33  honghanh
! Develop FillPtanQuantity to compute ptan, instead of using
! Get2DHydrostaticTangentPressure
!
! Revision 1.32  2010/06/29 02:28:17  honghanh
! Change mockup to import functions and literals from CFM module
@


1.62.2.1
log
@Intermediate checking, just to capture the state of work. Most of
these changes come from Paul Wagner
@
text
@d22 1
a22 2
    USE machine, ONLY: getarg, NEVERCRASH
    USE MLSMessageModule, ONLY: MLSMessageConfig
a28 8
    !! Added singleSideband and Elevation stuff per PW. Starting at test21 2020/08/31

    use CFM_Vector_m, only: CreateValue4AgileVector
    use CFM_Constants_m
    use CFM_QuantityTemplate_m, only: CreateQtyTemplate
    use INIT_TABLES_MODULE, only: l_elevOffset, l_limbsidebandFraction


d35 1
a35 1
        "$Id: mockup.f90,v 1.62 2020/07/15 20:46:51 pwagner Exp $"
a39 1
    integer :: nQtys
d79 1
a79 2
    CHARACTER(len=256) :: signalFileName, configFileName
    CHARACTER(len=*),parameter :: radiometer = "R3"
a82 17
    !! test17. Add the following declarations (from Paul)
    TYPE(QuantityTemplate_T) :: qband1000
    TYPE(VectorValue_T) :: band1000

    !! starting at test21, added sideband and elevation declarations as per PW: 2020/08/31
    type(VectorValue_T) :: limbSidebandFraction1000L
    type(VectorValue_T) :: limbSidebandFraction1000U
    type(VectorValue_T) :: elev1000L
    type(VectorValue_T) :: elev1000U
     type(QuantityTemplate_T) :: template
     ! Set the following to TRUE if signal is Band7, FALSE otherwise
     logical, parameter :: Original = .FALSE.
     ! Executable

    MLSMessageConfig%crashOnAnyError = .true.
    neverCrash = .false.

d178 1
a178 1
         start=1000.0d0, formula="21:12,14:6,12:3")
d224 1
a224 1
    ahgrid=hGridStandard, afgrid=fgridExtinctionConstant, qRadiometer=Radiometer, &
a227 1
    PRINT*,'print state'
d336 85
a420 248
   !! original
   if ( Original ) then
     qband7 = CreateQtyTemplate(l_radiance, startL1Maf_new, endL1Maf_new, filedatabase, &
          qSignal="R3:240.B7F:O3", qName='band7')
     band7 = CreateValue4AgileVector(qband7)
     call AddValue2Vector(radiance, band7)
   else
      !! test17 and up. Add the following declarations (from Paul)
     qband1000 = CreateQtyTemplate(l_radiance, &
          startL1Maf_new, &
          endL1Maf_new, &
          filedatabase, &
          qSignal="R1000Custom:dummy.B1000F:dummy", &
          qName='band1000F')
     band1000 = CreateValue4AgileVector(qband1000)
     CALL AddValue2Vector(radiance, band1000)
   endif

   !! starting at test21, added sideband and elevation stuff as per PW 2020/08/31


   ! <note from Paul>
   ! Every radiance must be accompanied by corresponding side band
   ! fractions and elevation offsets
   !
   ! in most cases split according to lower 'L' or upper 'U' sidebands
   ! Note that we might have used the wrong value, 7, instead of 1000.
   ! However, that wrong signal would have become deeply embedded
   ! So we'll try doing by hand what CreateMLSValue_ does automatically
   ! <end note from Paul>

   ! limbSidebandFraction1000L = CreateMLSValue_LSF(7, .false.)
   TEMPLATE = CreateQtyTemplate (l_limbsidebandFraction, &
        qSignal='R1000Custom:dummy.B1000LF:dummy')
   limbSidebandFraction1000L = CreateValue4AgileVector(TEMPLATE, &
        VALUE=vlimbSidebandFraction7L)
   CALL AddValue2Vector(stateExtra, limbSidebandFraction1000L)
   
   ! limbSidebandFraction1000U = CreateMLSValue_LSF(7, .true.)
   TEMPLATE = CreateQtyTemplate (l_limbsidebandFraction, &
        qSignal='R1000Custom:dummy.B1000UF:dummy')
   limbSidebandFraction1000U = CreateValue4AgileVector(TEMPLATE, &
        VALUE=vlimbSidebandFraction7U)
   CALL AddValue2Vector(stateExtra, limbSidebandFraction1000U)
   
   ! elev1000L = CreateMLSValue_ElevationOffset(7, .false.)
   TEMPLATE = CreateQtyTemplate (l_elevOffset, &
        qSignal='R1000Custom:dummy.B1000LF:dummy')
   elev1000L  = CreateValue4AgileVector(TEMPLATE, spreadvalue=velev7L)
   CALL AddValue2Vector(stateExtra, elev1000L)
   nQtys = SIZE(stateExtra%quantities)
   PRINT *, 'After adding elev1000L, n is ', nQtys
   CALL Dump( stateextra%Quantities(nQtys), details=1 )
   
   ! elev1000U = CreateMLSValue_ElevationOffset(7, .true.)
   TEMPLATE = CreateQtyTemplate (l_elevOffset, &
        qSignal='R1000Custom:dummy.B1000UF:dummy')
   elev1000U  = CreateValue4AgileVector(TEMPLATE, spreadvalue=velev7U)
   CALL AddValue2Vector(stateExtra, elev1000U)
   nQtys = SIZE(stateExtra%quantities)
   PRINT *, 'After adding elev1000U, n is ', nQtys
   CALL Dump( stateextra%Quantities(nQtys), details=1 )
   
   
   !! end add for 2020/08/30 sideband and elevation offset
   
   ! Add ptan_GHz values read from file in the stateExtra, Pranjit Saha
   CALL AddValue2Vector(stateExtra, newer_ptanGHz)
   nQtys = SIZE(stateExtra%quantities)
   PRINT *, 'After adding ptanGHz, n is ', nQtys
   CALL Dump( stateextra%Quantities(nQtys), details=1 )
   
   ! test 25. Print some stuff
   PRINT *,'printing stateExtra'
   CALL outputnamedValue( 'size(stateExtra)', &
        SIZE(stateExtra%quantities) )
   CALL Dump( stateExtra, details=1 )
   
   PRINT *,'printing radiance (before forward model)'
   CALL outputnamedValue( 'size(radiance)', &
        SIZE(radiance%quantities) )
   CALL Dump( radiance, details=0 )
   
   ! We no longer need vGrid because the quantity templates have copied it
   CALL DestroyVGridContents(vGridStandard55)
   CALL DestroyVGridContents(vGridStandard37)
   CALL DestroyVGridContents(vGridTESCO)
   ! No long need hGrid, fGrid either
   CALL DestroyHGridContents(hGridStandard)
   CALL DestroyFGridContents(fGridExtinctionConstant)
   
   ! GPH is filled by the forward model
   
   ! Create jacobian
   jacobian = CreatePlainMatrix(radiance, state)
   
   ! Call the forward model
   CALL ForwardModel2 (0, forwardModelConfigDatabase, state, &
        stateExtra, radiance, jacobian)
   
   
   PRINT *,'printing radiance (after forward model)'
   CALL outputnamedValue( 'size(radiance)', &
        SIZE(radiance%quantities) )
   CALL Dump( radiance, details=0 )
   
   
   PRINT *,'shape(Jacobian)'
   CALL Dump( SHAPE(Jacobian%BLOCK), '2d shape' )
   
   ! Write 'state', 'radiance', 'jacobian', 'ptanGHz' in separate files, Pranjit Saha
   CALL Write_To_File1 (state, radiance, jacobian, newer_ptanGHz)
   
   !=================== Finish running the forward model =====================
   
   !== Clean up anything that is not related to reading observed radiance ====
   CALL DestroyMatrix(jacobian)
   CALL DestroyAgileVectorContent (state)
   CALL DestroyAgileVectorContent (stateExtra)
   CALL Destroy_DACS_Filter_Database
   CALL Destroy_Filter_Shapes_Database
   CALL Destroy_Ant_Patterns_Database
   CALL Destroy_SpectCat_Database
   CALL Destroy_Line_Database
   CALL Destroy_Pointing_Grid_Database
   CALL DestroyL2PCDatabase
   CALL Destroy_PFADataBase
   
   ! Destroy all quantity templates that goes in state and stateExtra
   IF ( .FALSE. ) THEN
     CALL DestroyQuantityTemplateContents(qtemp)
     CALL DestroyQuantityTemplateContents(qCO)
     CALL DestroyQuantityTemplateContents(qSO2)
     CALL DestroyQuantityTemplateContents(qHNO3)
     CALL DestroyQuantityTemplateContents(qO3)
     CALL DestroyQuantityTemplateContents(qExtinctionv2r3)
     CALL DestroyQuantityTemplateContents(newer_qPtanGHz)
     CALL DestroyQuantityTemplateContents(qPhitanGHz)
     CALL DestroyQuantityTemplateContents(qRefGPH)
     CALL DestroyQuantityTemplateContents(qGPH)
     CALL DestroyQuantityTemplateContents(qIsotoperatioO_18_O)
     CALL DestroyQuantityTemplateContents(qIsotoperatioO3)
     CALL DestroyQuantityTemplateContents(qIsotoperatioO3_ASYM_O_18)
     CALL DestroyQuantityTemplateContents(qIsotoperatioO3_SYM_O_18)
     CALL DestroyQuantityTemplateContents(qIsotoperatioO3_V2)
     CALL DestroyQuantityTemplateContents(qIsotoperatioS_32_O2)
     CALL DestroyQuantityTemplateContents(qIsotoperatioHNO3)
     CALL DestroyQuantityTemplateContents(qIsotoperatioCO)
     ! even quantities created by CFM subroutines has templates
     CALL DestroyQuantityTemplateContents(o2%TEMPLATE)
     CALL DestroyQuantityTemplateContents(limbSidebandFraction7L%TEMPLATE)
     CALL DestroyQuantityTemplateContents(limbSidebandFraction7U%TEMPLATE)
     CALL DestroyQuantityTemplateContents(elev7L%TEMPLATE)
     CALL DestroyQuantityTemplateContents(elev7U%TEMPLATE)
     CALL DestroyQuantityTemplateContents(earthReflectivity%TEMPLATE)
     CALL DestroyQuantityTemplateContents(orbitInclination%TEMPLATE)
     CALL DestroyQuantityTemplateContents(spaceRadiance%TEMPLATE)
     CALL DestroyQuantityTemplateContents(scGeocAlt%TEMPLATE)
     CALL DestroyQuantityTemplateContents(tngtGeocAltGHz%TEMPLATE)
     CALL DestroyQuantityTemplateContents(losVelGHz%TEMPLATE)
   ENDIF
   ! stop
   !========================== finish cleaning ===============================
   
   !====================== Read observed radiance ============================
   ! Open l1brad
   error = InitializeMLSFile(l1bfile, content='l1brad', &
        name=TRIM(l1brad), shortName='L1BRAD', TYPE=l_hdf, access=DFACC_RDONLY)
   IF (error /= 0) CALL MLSMessage (MLSMSG_Error, moduleName, &
        "Error initializing " // TRIM(l1brad))
   
   CALL mls_openFile(l1bfile, error)
   IF (error /= 0 ) CALL MLSMessage (MLSMSG_Error, moduleName, &
        "Error opening " // TRIM(l1brad))
   
   ! Add it to the filedatabase
   ! AddFileToDatabase doesn't return an error.
   ! I don't care about the return value of AddFileToDatabase,
   ! but Fortran dictate that the return value has to be captured,
   ! so error is being used as a dummy variable.
   error = AddFileToDatabase(filedatabase, l1bfile)
   
   observed = CreateAgileVector(name='observedRadiance')
   obsPrecision = CreateAgileVector(name='observedRadiancePrecision')
   
   ! need to read precision before reading quantity
   band7 = CreateValue4AgileVector(qband7)
   CALL AddValue2Vector(observed, band7)
   ! precision of a quantity has the same template as the quantity
   precision7 = CreateValue4AgileVector(qband7)
   CALL AddValue2Vector(obsPrecision, precision7)
   
   ! need to fill precision first
   CALL FillVectorQuantityFromL1B(precision7, startL1Maf_new, endL1Maf_new, &
        filedatabase, .TRUE.)
   ! then fill the quantity and setting precision at the same time
   CALL FillVectorQuantityFromL1B(band7, startL1Maf_new, endL1Maf_new, &
        filedatabase, .FALSE., precisionQuantity=precision7)
   
   ! then we need to get the baseline correction and noise
   qbaseline7 = CreateQtyTemplate(l_l1bmafbaseline, startL1Maf_new, endL1Maf_new, &
        filedatabase, qSignal="R3:240.B7F:O3", qname='baseline 7')
   
   correction7 = CreateValue4AgileVector (qbaseline7)
   ! the space in ' Baseline' is very important
   CALL FillVectorQuantityFromL1B(correction7, startL1Maf_new, endL1Maf_new, &
        filedatabase, .FALSE., suffix=' Baseline')
   
   ! apply correction to the quantity
   CALL ApplyBaseline (band7, correction7, .FALSE., .FALSE.)
   
   ! get the noise
   noise7 = CreateValue4AgileVector(qbaseline7) ! same template as baseline
   ! again, the string must match exactly
   CALL FillVectorQuantityFromL1B(noise7, startL1Maf_new, endL1Maf_new, &
        filedatabase, .FALSE., suffix=' Baseline precision')
   
   ! apply the noise to the precision
   CALL ApplyBaseline (precision7, noise7, .TRUE., .FALSE.)
   
   ! Write 'band7' and 'precision7' in separate text files, Pranjit Saha
   CALL Write_To_File2 (band7, precision7)
   
   !==================== Finish reading observed radiance ====================
   
   !============= At this point we don't need L1B file anymore ===============
   DO i = 1, SIZE(filedatabase)
     CALL mls_closefile(filedatabase(i))
   END DO
   
   DEALLOCATE(filedatabase)
   NULLIFY(filedatabase)
   !================== Done closing and clean up file objects ================
   
   diffVector = observed - radiance
   
   !===== Clean up calculated and observed radiance and related vectors ======
   CALL DestroyAgileVectorContent (radiance)
   CALL DestroyAgileVectorContent (observed)
   call DestroyAgileVectorContent (diffVector)
   call DestroyAgileVectorContent (obsPrecision)

   call DestroyVectorValueContent (noise7)
   call DestroyVectorValueContent (correction7)

   call DestroyQuantityTemplateContents(qband7)
   call DestroyQuantityTemplateContents(qbaseline7)
   !========================== Done cleaning up ==============================
d422 58
a479 1
   call CFM_MLSCleanup(forwardModelConfigDatabase)
d481 22
a502 1
 end program
a504 3
! Revision 1.62  2020/07/15 20:46:51  pwagner
! Copied from MLuo
!
@


1.62.2.2
log
@code current up To test test49
@
text
@d44 1
a44 1
        "$Id: mockup.f90,v 1.62.2.1 2020/09/15 23:26:36 whdaffer Exp $"
d87 1
a87 1
    TYPE(VectorValue_T) :: losVelGHz, band7, isotoperatioO3_SYM_O_18, precision7, precision1000
d365 2
a366 15
   !! ORIGINAL == TRUE => running band7; original == false => band1000

    ! Add ptan_GHz values read from file in the stateExtra, Pranjit Saha
    CALL AddValue2Vector(stateExtra, newer_ptanGHz)
    nQtys = SIZE(stateExtra%quantities)
    PRINT *, 'After adding ptanGHz, n is ', nQtys
    CALL Dump( stateextra%Quantities(nQtys), details=1 )


    PRINT *,'printing radiance (before forward model)'
    CALL outputnamedValue( 'size(radiance)', &
         SIZE(radiance%quantities) )
    CALL Dump( radiance, details=0 )

   IF ( Original ) THEN
a369 4
     ! need to read precision before reading quantity
     band7 = CreateValue4AgileVector(qband7)
     precision7 = CreateValue4AgileVector(qband7)

d371 1
a371 33
     CALL AddValue2Vector(observed, band7)
     ! precision of a quantity has the same template as the quantity
     CALL AddValue2Vector(obsPrecision, precision7)

     ! need to fill precision first
     CALL FillVectorQuantityFromL1B(precision7, startL1Maf_new, endL1Maf_new, &
          filedatabase, .TRUE.)
     ! then fill the quantity and setting precision at the same time
     CALL FillVectorQuantityFromL1B(band7, startL1Maf_new, endL1Maf_new, &
          filedatabase, .FALSE., precisionQuantity=precision7)

     ! then we need to get the baseline correction and noise
     qbaseline7 = CreateQtyTemplate(l_l1bmafbaseline, startL1Maf_new, endL1Maf_new, &
          filedatabase, qSignal="R3:240.B7F:O3", qname='baseline 7')

     correction7 = CreateValue4AgileVector (qbaseline7)
     ! the space in ' Baseline' is very important
     CALL FillVectorQuantityFromL1B(correction7, startL1Maf_new, endL1Maf_new, &
          filedatabase, .FALSE., suffix=' Baseline')

     ! apply correction to the quantity
     CALL ApplyBaseline (band7, correction7, .FALSE., .FALSE.)

     ! get the noise
     noise7 = CreateValue4AgileVector(qbaseline7) ! same template as baseline
     ! again, the string must match exactly
     CALL FillVectorQuantityFromL1B(noise7, startL1Maf_new, endL1Maf_new, &
          filedatabase, .FALSE., suffix=' Baseline precision')

     ! apply the noise to the precision
     CALL ApplyBaseline (precision7, noise7, .TRUE., .FALSE.)

   ELSE
a379 1
     precision1000 = CreateValue4AgileVector(qband1000)
d381 1
a381 1
     CALL AddValue2Vector(observed, band1000)
d383 1
a384 80
     ! <note from Paul>
     ! Every radiance must be accompanied by corresponding side band
     ! fractions and elevation offsets
     !
     ! in most cases split according to lower 'L' or upper 'U' sidebands
     ! Note that we might have used the wrong value, 7, instead of 1000.
     ! However, that wrong signal would have become deeply embedded
     ! So we'll try doing by hand what CreateMLSValue_ does automatically
     ! <end note from Paul>
     
     ! limbSidebandFraction1000L = CreateMLSValue_LSF(7, .false.)
     TEMPLATE = CreateQtyTemplate (l_limbsidebandFraction, &
          qSignal='R1000Custom:dummy.B1000LF:dummy')
     limbSidebandFraction1000L = CreateValue4AgileVector(TEMPLATE, &
          VALUE=vlimbSidebandFraction7L)
     CALL AddValue2Vector(stateExtra, limbSidebandFraction1000L)

     ! limbSidebandFraction1000U = CreateMLSValue_LSF(7, .true.)
     TEMPLATE = CreateQtyTemplate (l_limbsidebandFraction, &
          qSignal='R1000Custom:dummy.B1000UF:dummy')
     limbSidebandFraction1000U = CreateValue4AgileVector(TEMPLATE, &
          VALUE=vlimbSidebandFraction7U)
     CALL AddValue2Vector(stateExtra, limbSidebandFraction1000U)

     ! elev1000L = CreateMLSValue_ElevationOffset(7, .false.)
     TEMPLATE = CreateQtyTemplate (l_elevOffset, &
          qSignal='R1000Custom:dummy.B1000LF:dummy')
     elev1000L  = CreateValue4AgileVector(TEMPLATE, spreadvalue=velev7L)
     CALL AddValue2Vector(stateExtra, elev1000L)
     nQtys = SIZE(stateExtra%quantities)
     PRINT *, 'After adding elev1000L, n is ', nQtys
     CALL Dump( stateextra%Quantities(nQtys), details=1 )

     ! elev1000U = CreateMLSValue_ElevationOffset(7, .true.)
     TEMPLATE = CreateQtyTemplate (l_elevOffset, &
          qSignal='R1000Custom:dummy.B1000UF:dummy')
     elev1000U  = CreateValue4AgileVector(TEMPLATE, spreadvalue=velev7U)
     CALL AddValue2Vector(stateExtra, elev1000U)
     nQtys = SIZE(stateExtra%quantities)
     PRINT *, 'After adding elev1000U, n is ', nQtys
     CALL Dump( stateextra%Quantities(nQtys), details=1 )

     ! need to fill precision first
     CALL FillVectorQuantityFromL1B(precision1000, startL1Maf_new, endL1Maf_new, &
          filedatabase, .TRUE.)
     ! then fill the quantity and setting precision at the same time
     CALL FillVectorQuantityFromL1B(band1000, startL1Maf_new, endL1Maf_new, &
          filedatabase, .FALSE., precisionQuantity=precision1000)

     ! then we need to get the baseline correction and noise (commented out by whd)
     ! qbaseline1000 = CreateQtyTemplate(l_l1bmafbaseline, startL1Maf_new, endL1Maf_new, &
     !      filedatabase, qSignal='R1000Custom:dummy.B1000F:dummy', qname='baseline 1000')

     ! correction1000 = CreateValue4AgileVector (qbaseline1000)
     ! ! the space in ' Baseline' is very important
     ! CALL FillVectorQuantityFromL1B(correction1000, startL1Maf_new, endL1Maf_new, &
     !      filedatabase, .FALSE., suffix=' Baseline')

     ! ! apply correction to the quantity
     ! CALL ApplyBaseline (band1000, correction1000, .FALSE., .FALSE.)

     ! get the noise (commented out by whd)
     ! noise1000 = CreateValue4AgileVector(qbaseline1000) ! same template as baseline
     ! ! again, the string must match exactly
     ! CALL FillVectorQuantityFromL1B(noise1000, startL1Maf_new, endL1Maf_new, &
     !      filedatabase, .FALSE., suffix=' Baseline precision')

     ! ! apply the noise to the precision
     ! CALL ApplyBaseline (precision1000, noise1000, .TRUE., .FALSE.)

     !! end add for 2020/08/30 sideband and elevation offset



     PRINT *,'printing radiance (before forward model)'
     CALL outputnamedValue( 'size(radiance)', &
          SIZE(radiance%quantities) )
     CALL Dump( radiance, details=0 )

   ENDIF !! band1000 block
d386 51
d442 5
a446 4

   !! starting at test21, added sideband and elevation stuff as per PW 2020/08/31


d550 34
d586 1
a586 5
   IF (Original) THEN
     CALL Write_To_File2 (band7, precision7)
   ELSE 
     CALL Write_To_File2 (band1000, band1000)
   ENDIF
d599 1
a599 13
     PRINT *,'printing observed, radiance vectors'
     PRINT *,'*** observed ***'
     CALL outputnamedValue( 'size(observed)', &
          SIZE(observed%quantities) )
     CALL Dump( observed, details=0 )

     PRINT *,'*** radiance ***'
     CALL outputnamedValue( 'size(radiance)', &
          SIZE(radiance%quantities) )
     CALL Dump( radiance, details=0 )


   !diffVector = observed - radiance
a618 4
! Revision 1.62.2.1  2020/09/15 23:26:36  whdaffer
! Intermediate checking, just to capture the state of work. Most of
! these changes come from Paul Wagner
!
@


1.61
log
@Fixes; no longer remember why
@
text
@d10 1
a10 1
! foreign countries or proVersionIding access to foreign persons.
a15 1
program MLS_CFM_Main
d17 1
a17 10
       use Allocate_Deallocate, only: Allocate_Test, DeAllocate_Test
       use CFM
       use global_settings, only: L1MAFToL2Profile, L2ProfileToL1MAF
       use HDF5, only:  h5open_f, h5close_f
       use input
       use machine, only: getarg, execute, is_a_directory, nevercrash
       use MLSHDF5, only: MLS_H5OPEN, MLS_H5CLOSE
       use MLSL2Options, only: Toolkit
       use MLSMEssageModule, only: MLSMessageConfig
       use output_m, only: switchOutput
d19 11
a29 1
       implicit none
d32 5
a36 6
       character (len=*), parameter :: ModuleName= &
           "$RCSfile: mockup.f90,v $"
       character (len=*), parameter :: IdParm = &
           "$Id: mockup.f90,v 1.60 2016/03/29 18:40:07 pwagner Exp $"
       character (len=len(idParm)) :: Id = idParm
       character (len=*) , parameter :: VersionId = 'MLSCFM1.57_001' ! version  ID for this executable
d39 80
a118 291
       integer :: i, j ,ierr
       ! To write values in file, read MLS L1BOA and L2GP files, Pranjit Saha
       CHARACTER(LEN=20), PARAMETER :: FMT1 = "(F16.5)"
       CHARACTER(LEN=20), PARAMETER :: FMT2 = "(E18.8)"
       CHARACTER(LEN=256) :: string_buffer
       
       integer :: FileIndex2
       type (MLSFile_T), dimension(:), pointer :: FileDatabase2 => null()
       type (MLSFile_T) :: L1BFile2, L2GPFile2
       integer :: startL1Maf_new
       integer :: endL1Maf_new
       ! For reading ptan Values from L2AUX-DGM file, Pranjit Saha
       real(r8), dimension(125) :: ptanValuesRead
       
       type(ForwardModelConfig_T), dimension(:), pointer :: forwardModelConfigDatabase
       type(MLSFile_T), dimension(:), pointer :: filedatabase
       type(MLSFile_T) :: l1bfile
       type(VGrid_T) :: vGridStandard55, vGridStandard37, vGridTESCO, vGridRefGPH
       type(VGrid_T) :: vGridExtinction
       type(HGrid_T) :: hGridStandard
       type(FGrid_T) :: fGridExtinctionConstant
       type(QuantityTemplate_T) :: qtemp, qCO, qso2, qhno3, qo3, qextinctionv2r3
       type(QuantityTemplate_T) :: qphitanGhz, qrefGPH, qgph, qh2o, newer_qptanGHz
       type(QuantityTemplate_T) :: qband9
       type(QuantityTemplate_T) :: qptanGHz
       type(QuantityTemplate_T) :: qbaseline9
       type(Vector_T) :: state, stateExtra
       type(Vector_T) :: radiance, diffVector
       type(Vector_T) :: observed, obsPrecision
       character(len=3) :: GHz = "GHz"
       character(len=2) :: sc = "sc"
       type(VectorValue_T) :: temperature, co, o2, so2, hno3, o3, extinctionv2r3, ptanGHz
       type(VectorValue_T) :: phitanGhz, refGPH, gph, h2o, newer_ptanGHz 
       type(VectorValue_T) :: limbSidebandFraction9L
       type(VectorValue_T) :: limbSidebandFraction9U, elev9L, elev9U, earthReflectivity
       type(VectorValue_T) :: orbitInclination, spaceRadiance, scGeocAlt, tngtGeocAltGHz
       type(VectorValue_T) :: losVelGHz, band9, precision9
       type(VectorValue_T) :: correction9, noise9
       ! configuration file name
       integer, parameter :: strlen = 256
       character(len=strlen) :: signalFileName, configFileName
       
       ! Input file stored in an HDF5 file datafile name in inputlst, Zheng Qu
       character(len=strlen) ::  inputlst='mlscfm_osp.lst', inputH5fileName
       character(len=strlen) ::  outputH5fileName, chbuff, &
        logProcess, logError
       character(len=strlen) :: MLS_CFM_OSP_PATH, MLS_CFM_OUTPUT_PATH, &
        MLS_INPUT_FILE_PATH, TES_MLS_OSP_PATH

       type(Matrix_T) :: jacobian ! stores intermediate Jacobians matrices for CO, O3, Extinction etc. , Zheng Qu 
       integer :: error
       character(len=1024) cbuff

       LOGICAL :: exists ! for testing file/dir existance

!=========== Customized initialization, added by Zheng Qu =====>    
       Toolkit = .false.  
       nevercrash = .false.
       MLSMessageConfig%crashOnAnyError = .true.
       call switchOutput ( 'stdout' )
        
       !Get command line arguement for stateVector file path , Zheng Qu
       call getarg(1, inputH5fileName)

        ! now construct log file name from stateVector file name and open them
        ! if stateVector file (inputH5fileName) is like 
        ! '/[path]/TES_0000010310_0767_004_MLS_1679_2009d041_Version_1_StateVector.hdf'
        ! then log file should be:
        ! TES_0000010310_0767_004_MLS_1679_2009d041_[VersionId]_run.log
        ! TES_0000010310_0767_004_MLS_1679_2009d041_[VersionId]_error.log
        ![VersionId] is CFM version number
        
       call  openLogFiles(trim(adjustl(inputH5fileName)), VersionId, strlen, logProcess, logError)
       
       call runlog(VersionId, 'MLS CFM starts.')
       call runlog(VersionId, 'Preparing for input, output and log files.')
       
       !CALL GET_ENVIRONMENT_VARIABLE('MLS_CFM_OSP_PATH', MLS_CFM_OSP_PATH)
       CALL GET_ENVIRONMENT_VARIABLE('TES_MLS_OSP_PATH', TES_MLS_OSP_PATH)
       MLS_CFM_OSP_PATH = path_join(TES_MLS_OSP_PATH,'MLS_CFM')
       CALL GET_ENVIRONMENT_VARIABLE('MLS_CFM_OUTPUT_PATH', MLS_CFM_OUTPUT_PATH)
       CALL GET_ENVIRONMENT_VARIABLE('MLS_INPUT_FILE_PATH', MLS_INPUT_FILE_PATH )

       ! Testing if directory MLS_CFM_OSP_PATH exists -- please note this is IFORT implementation only
       !inquire( DIRECTORY=trim(MLS_CFM_OSP_PATH), exist=exists )
       exists = is_a_directory( MLS_CFM_OSP_PATH )
       if (.NOT. exists) then
            call errlog ( moduleName, &
         &(/'Environment variable TES_MLS_OSP_PATH was not properly set?',&
            '$TES_MLS_OSP_PATH/MLS_CFM not found!                       '/)) 
       endif
       
       
       ! inquire( DIRECTORY=trim(MLS_CFM_OUTPUT_PATH), exist=exists )
       exists = is_a_directory( MLS_CFM_OUTPUT_PATH )
       if (.NOT. exists) then
            call errlog ( moduleName, &
           & (/'Environment variable MLS_CFM_OUTPUT_PATH was not properly set.'/) ) 
       endif

       
       !inquire( DIRECTORY=trim(MLS_INPUT_FILE_PATH ), exist=exists )
       exists = is_a_directory( MLS_INPUT_FILE_PATH )
       if (.NOT. exists) then
            call errlog ( moduleName, &
           & (/'Environment variable MLS_INPUT_FILE_PATH  was not properly set.'/) ) 
       endif
       
       nullify(filedatabase)

       ! initialize hdf5 fortran interface
       CALL h5open_f(error)
       if (error /=0) call errlog ( ModuleName, &
            & (/'Unable to initialize hdf5 fortran interface.'/) )

       call runlog(VersionId, 'Reading OSP files.')
       call read_txtinputdata(MLS_CFM_OSP_PATH, inputlst, spectroscopy, &
        leapsecFile,  antennaPatterns, filterShapes, &
        DACSFilterShapes, pointingGrids, pfaFiles, l2pc , &
            signalFileName, configFileName, &
            vGridStandard37Start ,&
            vGridExtinctionStart ,& 
            hGridStandardVal1 , &
            hGridStandardVal2 , &
            qH2OMinValue , &
            vGridStandard37formula , &
            vGridExtinctionFormula, &
            outputTxtFile, &
            H2O_Sample_Vals)
               
       call runlog(VersionId, 'CFM_MLSSetup -- CFM initialization.')
       call CFM_MLSSetup(signalFileName, configFileName, forwardModelConfigDatabase)

       
       call MLSMessageSetup ( SuppressDebugs=.TRUE., &
        LogFileUnit=errorLogFileUnit, &
        & CrashOnAnyError=.FALSE.  )
       

         
       ! Reading state vector file, it also constructs H2OInput using 
       call runlog(VersionId, 'Reading stateVector file: ' &
          //trim(inputH5fileName))
       call read_H5inputdata (MLS_INPUT_FILE_PATH , trim(inputH5fileName), &
        TemperatureInput, H2OInput , &
        O3Input, SO2Input, HNO3Input, COInput, extinctionV2R3Input, &
        PressureCOInput, PressureStandardInput, &
        REFGPHINPUT, VGRIDREFGPHVALS, MLS_Year, MLS_Day, &
        MLS_ProfileNumber, Tes_run, Tes_scan, TES_sequnce, &
        l1boa, l1brad, l2GP,l2dgm, H2O_Sample_Vals)
   
       !write(*,*)  'TemperatureInput = &   ' 
       !write(*,'(5(E14.7, ",")," &")')  TemperatureInput
       
       !H2OInput = H2OInput*2.
       !write(*,*)  ' H2OInput = & ' 
       !write(*,'(5(E14.7, ",")," &")')  H2OInput  
       
       
       !write(*,*)  'SO2Input= & '
       !write(*,'(5(E14.7, ",")," &")')  SO2Input
       
       !write(*,*)  'HNO3Input= & '
       !write(*,'(5(E14.7, ",")," &")')  HNO3Input
       
       
       !write(*,*)  ' COInput = &  '
       !write(*,'(5(E14.7, ",")," &")')  COInput 
       
       
       !write(*,*)  ' extinctionV2R3Input = &'
       !write(*,'(5(E14.7, ",")," &")')  extinctionV2R3Input 
       

       !write(*,*) 'O3Input= &'
       !write(*,'(5(E14.7, ",")," &")') O3Input 
       
       !write(*,*)  ' PressureCOInput = &'
       !write(*,'(5(E14.7, ",")," &")')  PressureCOInput 
       
       !write(*,*)  'PressureStandardInput = &'
       !write(*,'(5(E14.7, ",")," &")')  PressureStandardInput 
       
       !TemperatureInput = &
       !    (/   299.456_r8,       289.667_r8,       280.912_r8,       272.268_r8,       263.273_r8, &
       !         253.692_r8,       245.674_r8,       231.690_r8,       219.471_r8,       210.275_r8, &
       !         205.069_r8,       201.019_r8,       197.023_r8,       192.212_r8,       192.879_r8, &
       !         196.030_r8,       201.309_r8,       206.541_r8,       208.083_r8,       208.639_r8, &
       !         210.903_r8,       215.163_r8,       219.846_r8,       223.787_r8,       227.240_r8, &
       !         231.812_r8,       237.576_r8,       242.384_r8,       244.396_r8,       243.992_r8, &
       !         242.964_r8,       244.642_r8,       248.765_r8,       255.249_r8,       263.369_r8, &
       !         271.624_r8,       274.746_r8,       271.979_r8,       260.006_r8,       247.311_r8, &
       !         239.643_r8,       239.779_r8,       239.759_r8,       213.600_r8,       201.630_r8, &
       !         190.568_r8,       182.280_r8,       177.571_r8,       175.984_r8,       177.844_r8, &
       !         183.204_r8,       201.225_r8,       264.396_r8,       368.598_r8,       368.598_r8 /)

                
        ! MLS Profile number read from statevector is 0 based
        ! Now we change this number to 1 based.
        ! Reasons:
        ! (From Ming's email 10/8/2012) The reason for me to use '1' based is because in 'mockup.f90', 
        !  all codes created by Paul Wagner and Pranjit assume that 'profile number' starts from '1', 
        !  and all Haley's codes assume the 'MAF number' starts from '0'.  
        
        startProfile = MLS_ProfileNumber + 1 
        endProfile = MLS_ProfileNumber + 1
       

        !File name pattern (for log and output files): 'TES_0000010310_0768_003_MLS_1681_2009d041_'
        
       write(chbuff, "('TES_',I10.10,'_',I4.4,'_',I3.3," // &
          "'_MLS_',I4.4,'_',I4.4,'d',I3.3, '_')") &
          Tes_run, TES_sequnce, &
          Tes_scan, MLS_ProfileNumber, MLS_Year, MLS_Day
          
          
       if (index(trim(inputH5fileName), trim(chbuff)) .le. 0 ) then

           call errlog ( ModuleName, &
               & (/ 'StateVector file' // &
               trim(inputH5fileName) // &
               'does NOT have the pattern' // &
               trim(chbuff) // &
               'which was derived from TES run-seq-scan and MLS profile#, year and day'// & 
               'read from the stateVector file itself!' /))
       endif
       
       
       outputH5fileName = trim(chbuff)//VersionId//'_RadianceJacobians.h5'

       
       !log input variables
       call log_inputdata( TES_MLS_OSP_PATH, MLS_CFM_OUTPUT_PATH, &
            MLS_INPUT_FILE_PATH , inputlst, &
            trim(inputH5fileName),spectroscopy, &
            leapsecFile,  antennaPatterns, filterShapes, &
            DACSFilterShapes, pointingGrids, pfaFiles, l2pc , &
            signalFileName, configFileName, &
            vGridStandard37Start ,&
            vGridExtinctionStart ,& 
            hGridStandardVal1 , &
            hGridStandardVal2 , &
            qH2OMinValue , &
            vGridStandard37formula , &
            vGridExtinctionFormula, &
            outputTxtFile, &
            H2O_Sample_Vals, &
            REFGPHINPUT, VGRIDREFGPHVALS, MLS_Year, MLS_Day, &
            MLS_ProfileNumber, Tes_run, Tes_scan, TES_sequnce, &
            l1boa, l1brad, l2GP,l2dgm)

!==========================Start doing the real job!=====================================================
        ! Convert profile to MAF (Major Frame) number, Pranjit Saha
       call runlog(VersionId, 'Converting profile to MAF (Major Frame) number.')
       FileIndex2 = InitializeMLSFile( L1BFile2, content = 'l1boa', &
         & name=trim(l1boa), shortName='L1BOA', type=l_hdf, access=DFACC_RDONLY )
       FileIndex2 = AddFileToDataBase( FileDatabase2, L1BFile2 ) 

       FileIndex2 = InitializeMLSFile( L2GPFile2, content = 'l2gp', &
         & name=trim(L2GP), shortName='L2GP', &
         & type=l_hdfeos, access=DFACC_RDONLY )
       FileIndex2 = AddFileToDataBase( FileDatabase2, L2GPFile2 )

       startL1Maf_new = L2ProfileToL1MAF( startProfile, FileDatabase2 )
       endL1Maf_new = L2ProfileToL1MAF( endProfile, FileDatabase2 )
       
       
       ! Read ptanGHz values from  MLS *DGM* file, Pranjit Saha
       call runlog(VersionId, 'Reading ptanGHz values from  MLS *DGM* file')
       call Read_ptan(trim(l2dgm), 'HDF5', startL1Maf_new, ptanValuesRead)    

       if (minval(ptanValuesRead) .LT. -3.3) then
            write(cbuff, '(F10.3)') minval(ptanValuesRead)
            call MLSMessage ( MLSMSG_Error, moduleName, &
                & 'min(ptanGHZ)='//trim(cbuff)//', <-3.3, MLSCFM failed.' )
       endif
    ! Check ptanGHZ values for -999 for bad cases 
    !  call check_patanGHZ(newer_ptanGHz)
       !========================= Run the forward model ==========================
       call runlog(VersionId, 'Starting running forward model.')
       call runlog(VersionId, 'CFM Initialization--prepare database, vector & templates')
       ! Read L1BOA file
       error = InitializeMLSFile (l1bfile, content='l1boa', name=trim(l1boa), &
       shortName='L1BOA', type=l_hdf, access=DFACC_RDONLY)
       if (error /= 0) call MLSMessage (MLSMSG_Error, moduleName, &
         "Error initializing " // trim(l1boa))
       call mls_openfile (l1bfile, error)
       if (error /= 0) call MLSMessage (MLSMSG_Error, moduleName, &
         "Error opening " // trim(l1boa))
       ! don't care about return value of the following function
       i = AddFileToDatabase(filedatabase, l1bfile)
d121 380
a500 460
       newer_qptanGHz = CreateQtyTemplate(l_ptan, startL1Maf_new, endL1Maf_new, &
            & filedatabase=filedatabase, qInstModule='Ghz')
       newer_ptanGHz  = CreateValue4AgileVector(newer_qptanGHz, value=ptanValuesRead)


    ! From Ming: Haley assumes 0-based indexing for L1Maf
       startL1Maf_new = startL1Maf_new - 1
       endL1Maf_new = endL1Maf_new - 1

       ! read MLS input data files
       call runlog(VersionId, 'Reading MLS input data files.')
       
       call Read_Spectroscopy (spectroscopy, 'HDF5')
       call ReadAntennaPatterns (antennaPatterns)
       call ReadFilterShapes(filterShapes)
       call ReadDACSFilterShapes (DACSFilterShapes)
       call ReadPointingGrids (pointingGrids)

       do i = 1, size(pfaFiles)
           call ReadPFAFile (pfaFiles(i))
       end do

       do i = 1, size(l2pc)
           call ReadHDF5L2PC (l2pc(i))
       end do

       vGridStandard37 = CreateVGrid (l_zeta, phyq_pressure, l_logarithmic, &
                                      start=vGridStandard37Start, &
                                      formula=trim(vGridStandard37formula))
       !!vGridStandard37Start = 1000.0d0
       !!vGridStandard37formula = "37:6"
       
       vGridRefGPH = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
                                  values=vGridRefGPHVals)
       !! vGridRefGPHVals = (/100.0_r8/)
       vGridStandard55 = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
       values= PressureStandardInput)

       vGridTESCO = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
       values = PressureCOInput)

       vGridExtinction = CreateVGrid (l_zeta, phyq_pressure, l_logarithmic, &
       start=vGridExtinctionStart, formula=trim(vGridExtinctionFormula))
       !!vGridExtinctionStart=1000.0d0
       !!vGridExtinctionFormula="21:12,14:6,12:3"
       ! Have insetoverlaps, and not single
       hGridStandard = CreateRegularHGrid(GHz, hGridStandardVal1, hGridStandardVal2, &
                                          .true., &
                                          filedatabase, startL1Maf_new, endL1Maf_new)
       !!hGridStandardVal1 = 0.0_r8
       !!hGridStandardVal2 = 1.5_r8
       fGridExtinctionConstant = CreateFGrid(L_IntermediateFrequency, (/0.0_r8/))

       ! Construct state vector
       call runlog(VersionId, 'Constructing the state vector.')
       state = CreateAgileVector(name='state')

       qtemp = CreateQtyTemplate(l_temperature, qName='temperature', &
                                 avgrid=vGridStandard55, ahgrid=hGridStandard)
       temperature = CreateValue4AgileVector(qtemp, value=TemperatureInput)
       call AddValue2Vector(state, temperature)

       qCO = CreateQtyTemplate(l_vmr, avgrid=vGridTESCO, ahgrid=hGridStandard, &
       qMolecule=l_co, qName='CO')
       co = CreateValue4AgileVector(qco, value=COInput)
       call AddValue2Vector(state, co)

       o2 = CreateMLSValue_O2 (vGridStandard37, hGridStandard, qname='O2')
       call AddValue2Vector(state, o2)

       qSO2 = CreateQtyTemplate(l_vmr, avgrid=vGridStandard37, ahgrid=hGridStandard, &
       qMolecule=l_so2, qName='SO2')
       so2 = CreateValue4AgileVector(qSO2, value=SO2Input)
       call AddValue2Vector(state, so2)

       qHNO3 = CreateQtyTemplate(l_vmr, avgrid=vGridStandard37, ahgrid=hGridStandard, &
       qMolecule=l_hno3, qName='HNO3')
       hno3 = CreateValue4AgileVector(qhno3, value=HNO3Input)
       call AddValue2Vector(state, hno3)

       qO3 = CreateQtyTemplate(l_vmr, avgrid=vGridStandard55, ahgrid=hGridStandard, &
       qMolecule=l_o3, qName='O3')
       o3 = CreateValue4AgileVector(qo3, value=O3Input)
       call AddValue2Vector(state, o3)

       qExtinctionv2r3 = CreateQtyTemplate(l_vmr, avgrid=vGridExtinction, &
       ahgrid=hGridStandard, afgrid=fgridExtinctionConstant, qRadiometer="R3", &
       qMolecule=l_extinctionv2)
       extinctionv2r3 = CreateValue4AgileVector(qExtinctionv2r3, value=extinctionV2R3Input)
       call AddValue2Vector(state, extinctionv2r3)

       !Construct stateExtra vector.
       call runlog(VersionId, 'Constructing the stateExtra vector.')
       stateExtra = CreateAgileVector(name='stateExtra')

       ! qPtanGHz = CreateQtyTemplate(l_ptan, startL1Maf_new, endL1Maf_new, filedatabase, &
       ! qInstModule=GHz, qName='ptanGHz')
       ! ptanGHz = CreateValue4AgileVector(qPtanGhz)

       qPhitanGHz = CreateQtyTemplate(l_phitan, startL1Maf_new, endL1Maf_new, qInstModule=GHz, &
       filedatabase=filedatabase, qName='phitanGHz')
       phitanGhz = CreateValue4AgileVector(qPhitanGhz)
       call FillPhitanQuantity(phitanGhz)
       call AddValue2Vector(stateExtra, phitanGhz)

       qRefGPH = CreateQtyTemplate(l_refGPH, avgrid=vGridRefGPH, &
       ahgrid=hGridStandard, qName='refGPH')
       refGPH = CreateValue4AgileVector(qRefGPH, spreadvalue=refGPHInput) ! unit is meter
       call AddValue2Vector(stateExtra, refGPH)

       qGPH = CreateQtyTemplate(l_gph, avgrid=vGridStandard55, ahgrid=hGridStandard, &
                                qName='GPH')
       gph = CreateValue4AgileVector(qGPH)
       call AddValue2Vector(stateExtra, gph)

       qH2O = CreateQtyTemplate(l_vmr, avgrid=vGridStandard55, ahgrid=hGridStandard, &
       qMolecule=l_h2o, qLogBasis=.true., qMinValue=qH2OMinValue, qName='H2O')
       !!qH2OMinValue = 0.1E-6_r8
       h2o = CreateValue4AgileVector(qH2O, value=H2OInput)
       call AddValue2Vector(stateExtra, H2O)

       ! Fill orbit inclination, tangent geocentric altitude with
       ! data from MLS L1B file, and use them, along with other
       ! quantities to calculate ptan
       
       call runlog(VersionId, 'Computing ptan.')
       limbSidebandFraction9L = CreateMLSValue_LSF(9, .false., qname='lsf9L')
       call AddValue2Vector(stateExtra, limbSidebandFraction9L)

       limbSidebandFraction9U = CreateMLSValue_LSF(9, .true., qname='lsf9U')
       call AddValue2Vector(stateExtra, limbSidebandFraction9U)

       elev9L = CreateMLSValue_ElevationOffset(9, .false.)
       call AddValue2Vector(stateExtra, elev9L)

       elev9U = CreateMLSValue_ElevationOffset(9, .true.)
       call AddValue2Vector(stateExtra, elev9U)

       earthReflectivity = CreateMLSValue_EarthReflectivity()
       call AddValue2Vector(stateExtra, earthReflectivity)

       orbitInclination = CreateMLSValue_FromL1BOA (l_orbitInclination, sc, &
       filedatabase, startL1Maf_new, endL1Maf_new)
       call AddValue2Vector(stateExtra, orbitInclination)

       spaceRadiance = CreateMLSValue_SpaceRadiance()
       call AddValue2Vector(stateExtra, spaceRadiance)

       scGeocAlt = CreateMLSValue_FromL1BOA(l_scgeocalt, sc, filedatabase, &
       startL1Maf_new, endL1Maf_new)
       call AddValue2Vector(stateExtra, scGeocAlt)

       tngtGeocAltGHz = CreateMLSValue_FromL1BOA (l_tngtgeocalt, GHz, &
       filedatabase, startL1Maf_new, endL1Maf_new)
       call AddValue2Vector(stateExtra, tngtGeocAltGHz)

       losVelGHz = CreateMLSValue_FromL1BOA(l_losVel, GHz, filedatabase, &
       startL1Maf_new, endL1Maf_new)
       call AddValue2Vector(stateExtra, losVelGHz)

       
       call runlog(VersionId, 'Constructing Radiance vector.')
       radiance = CreateAgileVector(name='simulatedRadiance')

       qband9 = CreateQtyTemplate(l_radiance, startL1Maf_new, endL1Maf_new, filedatabase, &
                                  qSignal="R3:240.B9F:CO", qName='band9')
       band9 = CreateValue4AgileVector(qband9)
       call AddValue2Vector(radiance, band9)

       ! calculate ptan
       !call FillPtanQuantity (ptanGHz, temperature, refGPH, h2o, &
       !orbitInclination, phitanGhz, tngtGeocAltGHz)
       !call AddValue2Vector(stateExtra, ptanGhz)

       ! Add ptan_GHz values read from file in the stateExtra, Pranjit Saha
       
       call runlog(VersionId, 'Adding ptan_GHz values read from file to stateExtra.')
       call AddValue2Vector(stateExtra, newer_ptanGHz)

       ! We no longer need vGrid because the quantity templates have copied it
       call DestroyVGridContents(vGridStandard55)
       call DestroyVGridContents(vGridStandard37)
       call DestroyVGridContents(vGridTESCO)
       ! No long need hGrid, fGrid either
       call DestroyHGridContents(hGridStandard)
       call DestroyFGridContents(fGridExtinctionConstant)

       ! GPH is filled by the forward model

       ! Create jacobian
       jacobian = CreatePlainMatrix(radiance, state)
       
       ! Call the forward model
       print *, 'Actually calling the Forward Model'
       call runlog(VersionId, 'Calling the forward model')
       call ForwardModel2 (0, forwardModelConfigDatabase, state, &
                           stateExtra, radiance, jacobian)

       print *, 'Done with the Forward Model'
       ! Write 'state', 'radiance', 'jacobian', 'ptanGHz' in separate files, Pranjit Saha
       call runlog(VersionId, 'Writing state, radiance, ptanGHz etc. to file and concatenate Jacobians.')
       if (outputTxtFile) call Write_To_File1 (state, radiance, jacobian, newer_ptanGHz)

       ! from radiance (template) and Jacobian (template),copy Radiance_Calculated and concatenate Jacobians. Zheng Qu

       !call Write_To_HDF5('mlscfm.old_out.h5', state, radiance, jacobian, newer_ptanGHz)
       call Copy_RadianceJacobian ( radiance, jacobian, newer_ptanGHz, &
        Radiance_Calculated, Jacobian_Concatenated, ptanGHz_save)
        

       !=================== Finish running the forward model =====================
        call runlog(VersionId, 'Finishing running the forward model and doing cleaning up.')
       !== Clean up anything that is not related to reading observed radiance ====
       call DestroyMatrix(jacobian)
       call DestroyAgileVectorContent (state)
       call DestroyAgileVectorContent (stateExtra)
       call Destroy_DACS_Filter_Database
       call Destroy_Filter_Shapes_Database
       call Destroy_Ant_Patterns_Database
       call Destroy_SpectCat_Database
       call Destroy_Line_Database
       call Destroy_Pointing_Grid_Database
       call DestroyL2PCDatabase
       call Destroy_PFADataBase

       ! Destroy all quantity templates that goes in state and stateExtra
       ! Except that this step often generates a double-free error
       if ( .false. ) then
       call DestroyQuantityTemplateContents(qtemp)
       call DestroyQuantityTemplateContents(qCO)
       call DestroyQuantityTemplateContents(qSO2)
       call DestroyQuantityTemplateContents(qHNO3)
       call DestroyQuantityTemplateContents(qO3)
       call DestroyQuantityTemplateContents(qExtinctionv2r3)
       call DestroyQuantityTemplateContents(qPtanGHz)
       call DestroyQuantityTemplateContents(qPhitanGHz)
       call DestroyQuantityTemplateContents(qRefGPH)
       call DestroyQuantityTemplateContents(qGPH)
       call DestroyQuantityTemplateContents(qH2O)
       ! even quantities created by CFM subroutines has templates
       call DestroyQuantityTemplateContents(o2%template)
       call DestroyQuantityTemplateContents(limbSidebandFraction9L%template)
       call DestroyQuantityTemplateContents(limbSidebandFraction9U%template)
       call DestroyQuantityTemplateContents(elev9L%template)
       call DestroyQuantityTemplateContents(elev9U%template)
       call DestroyQuantityTemplateContents(earthReflectivity%template)
       call DestroyQuantityTemplateContents(orbitInclination%template)
       call DestroyQuantityTemplateContents(spaceRadiance%template)
       call DestroyQuantityTemplateContents(scGeocAlt%template)
       call DestroyQuantityTemplateContents(tngtGeocAltGHz%template)
       call DestroyQuantityTemplateContents(losVelGHz%template)
       endif
       !========================== finish cleaning ===============================

       !====================== Read observed radiance ============================
       print *, 'Reading the observed radiance/noise.'
       ! Open l1brad
       call runlog(VersionId, 'Reading the observed radiance/noise.')
       error = InitializeMLSFile(l1bfile, content='l1brad', &
       name=trim(l1brad), shortName='L1BRAD', type=l_hdf, access=DFACC_RDONLY)
       if (error /= 0) call MLSMessage (MLSMSG_Error, moduleName, &
       "Error initializing " // trim(l1brad))

       call mls_openFile(l1bfile, error)
       if (error /= 0 ) call MLSMessage (MLSMSG_Error, moduleName, &
       "Error opening " // trim(l1brad))

       ! Add it to the filedatabase
       ! AddFileToDatabase doesn't return an error.
       ! I don't care about the return value of AddFileToDatabase,
       ! but Fortran dictate that the return value has to be captured,
       ! so error is being used as a dummy variable.
       error = AddFileToDatabase(filedatabase, l1bfile)

       observed = CreateAgileVector(name='observedRadiance')
       obsPrecision = CreateAgileVector(name='observedRadiancePrecision')

       ! need to read precision before reading quantity
       band9 = CreateValue4AgileVector(qband9)
       call AddValue2Vector(observed, band9)
       ! precision of a quantity has the same template as the quantity
       precision9 = CreateValue4AgileVector(qband9)
       call AddValue2Vector(obsPrecision, precision9)

       ! need to fill precision first
       call FillVectorQuantityFromL1B(precision9, startL1Maf_new, endL1Maf_new, &
       filedatabase, .true.)
       ! then fill the quantity and setting precision at the same time
       call FillVectorQuantityFromL1B(band9, startL1Maf_new, endL1Maf_new, &
       filedatabase, .false., precisionQuantity=precision9)

       ! then we need to get the baseline correction and noise
       qbaseline9 = CreateQtyTemplate(l_l1bmafbaseline, startL1Maf_new, endL1Maf_new, &
       filedatabase, qSignal="R3:240.B9F:CO", qname='baseline 9')

       correction9 = CreateValue4AgileVector (qbaseline9)
       ! the space in ' Baseline' is very important
       call FillVectorQuantityFromL1B(correction9, startL1Maf_new, endL1Maf_new, &
       filedatabase, .false., suffix=' Baseline')

       ! apply correction to the quantity
       call ApplyBaseline (band9, correction9, .false., .false.)

       ! get the noise
       noise9 = CreateValue4AgileVector(qbaseline9) ! same template as baseline
       ! again, the string must match exactly
       call FillVectorQuantityFromL1B(noise9, startL1Maf_new, endL1Maf_new, &
       filedatabase, .false., suffix=' Baseline precision')

       ! apply the noise to the precision
       call ApplyBaseline (precision9, noise9, .true., .false.)
       !call dump(observed, details=1)
       
       !  Filter Radiance and Jacobians using ptanGHz and noise mask values, Zheng Qu
       ! 
       call runlog(VersionId, 'Filtering Radiance and Jacobians using ptanGHz and noise mask values.') 
       call Filter_RadianceJacobian(band9, precision9, ptanGHz_save,&
            Radiance_Calculated, &
            Jacobian_Concatenated , &
            Radiance_Noise, &
            Radiance_Observed, &
            Radiance_Calculated_out, &
            Jacobian_Concatenated_out , &
            Radiance_Noise_out, &
            Radiance_Observed_out)
       ! Write Jacobians and Radiances in HDF5 output file, Zheng Qu
       !call Write2HDF5_old('mlscfm.old_out.h5',band9, precision9)

       ! band9 -> Radiance_Observed , Radiance -> Radiance_Calculated, Presision9 -> Radiance_Noise
       print *, 'Writing radiance+Jacobians to output file.'
       call runlog(VersionId, 'Writing radiance+Jacobians to output file.')
       call Write2HDF5(path_join(MLS_CFM_OUTPUT_PATH,outputH5fileName, novalidation=.TRUE.),&
            Radiance_Calculated_out, &
            Jacobian_Concatenated_out , &
            Radiance_Noise_out, &
            Radiance_Observed_out)
       ! Write 'band9' and 'precision9' in separate text files, Pranjit Saha
       print *, 'Writing radiance+Jacobians to output file.'
       call runlog(VersionId, 'Writing radiance+Jacobians to output file.')
       if (outputTxtFile) call Write_To_File2 (band9, precision9)
       ! read output H5 file for validation

       !if (outputTxtFile) call read_H5outputdata(trim(outputH5fileName))
       !==================== Finish reading observed radiance ====================
       call runlog(VersionId, 'Final cleaning up.')
       !============= At this point we don't need L1B file anymore ===============
       do i = 1, size(filedatabase)
           call mls_closefile(filedatabase(i))
       end do


       deallocate(filedatabase)
       
       deallocate( filedatabase2)
       

       !================== Done closing and clean up file objects ================

       diffVector = observed - radiance
       !call dump(diffVector, details=1)

       !===== Clean up calculated and observed radiance and related vectors ======
       call DestroyAgileVectorContent (radiance)

       call DestroyAgileVectorContent (observed) !band9 also destroyed
       call DestroyAgileVectorContent (diffVector)
       call DestroyAgileVectorContent (obsPrecision) !precision9 also destroyed


       call DestroyVectorValueContent (noise9)
       call DestroyVectorValueContent (correction9)
       if ( .false. ) then
       call DestroyQuantityTemplateContents(qband9)
       call DestroyQuantityTemplateContents(qbaseline9)
       endif


       !========================================================
       print *, 'Cleaning up forward model config'
       call CFM_MLSCleanup(forwardModelConfigDatabase)

       
       ! clean up other variables/ vectors/ templates
       print *, 'Cleaning up remaining arrays'
       
       if ( .false. ) call DestroyQuantityTemplateContents(newer_qPtanGHz)
       
       call Deallocate_test ( TemperatureInput, &
                & 'Unable to deallocate array for TemperatureInput', ModuleName )

       
       call Deallocate_test ( H2OInput, &
                & 'Unable to deallocate array for H2OInput', ModuleName )

         
         
       call Deallocate_test ( O3Input, &
                & 'Unable to deallocate array for O3Input', ModuleName )
  
         
       call Deallocate_test ( SO2Input, &
                & 'Unable to deallocate array for SO2Input', ModuleName )

                
         
       call Deallocate_test ( HNO3Input, &
                & 'Unable to deallocate array for HNO3Input', ModuleName )

       call Deallocate_test ( COInput, &
                & 'Unable to deallocate array for COInput', ModuleName )

       call Deallocate_test ( extinctionV2R3Input, &
                & 'Unable to deallocate array for extinctionV2R3Input', ModuleName )

       call Deallocate_test ( PressureCOInput, &
                & 'Unable to deallocate array for PressureCOInput', ModuleName )

       call Deallocate_test ( PressureStandardInput, &
                & 'Unable to deallocate array for PressureStandardInput', ModuleName )
         
       call Deallocate_test ( Radiance_Calculated, &
                & 'Unable to deallocate array for Radiance_Calculated', ModuleName )

       call Deallocate_test ( Radiance_Observed, &
                & 'Unable to deallocate array for Radiance_Observed', ModuleName )
  
       call Deallocate_test ( Radiance_Noise, &
                & 'Unable to deallocate array for Radiance_Noise', ModuleName )

  
       call Deallocate_test ( Jacobian_Concatenated, &
                & 'Unable to deallocate array for Jacobian_Concatenated', ModuleName )
      
       call Deallocate_test ( Radiance_Calculated_out, &
                & 'Unable to deallocate array for Radiance_Calculated_out', ModuleName )
  
       call Deallocate_test ( Radiance_Observed_out, &
                & 'Unable to deallocate array for Radiance_Observed_out', ModuleName )
  
       call Deallocate_test ( Radiance_Noise_out, &
                & 'Unable to deallocate array for Radiance_Noise_out', ModuleName )
  
       call Deallocate_test ( Jacobian_Concatenated_out, &
                & 'Unable to deallocate array for Jacobian_Concatenated_out', ModuleName )

       call Deallocate_test ( ptanGHz_save, &
                & 'Unable to deallocate array for ptanGHz_save', ModuleName )

       write(*, '("outputfile=",A)') trim(path_join(MLS_CFM_OUTPUT_PATH, &
            outputH5fileName, novalidation=.TRUE.))
       call runlog(VersionId, 'MLSCFM complated successfully.')
       call runlog(VersionId, "outputfile="// &
            trim(path_join(MLS_CFM_OUTPUT_PATH,outputH5fileName,&
            novalidation=.TRUE.)))
       close(runLogFileUnit) 
       
       close(errorLogFileUnit)
       ! delete errorLog file if empty
       cbuff = '/bin/rm `/usr/bin/find '//trim(logError)// &
        ' -size 0` > /dev/null 2>&1'
a501 2
       call execute( trim(cbuff), error )
       
d504 36
a539 63
        ! $Log: mockup.f90,v $
        ! Revision 1.60  2016/03/29 18:40:07  pwagner
        ! replaced non-standard 'inquire( DIRECTORY=' syntax and tab characters
        !
        ! Revision 1.59  2015/08/05 20:21:29  pwagner
        ! Modified to compile properly with v4
        !
        ! Revision 1.57  2011/12/24 18:39:13  honghanh
        ! Clean up unused imports and variables
        !
        ! Revision 1.56  2011/12/23 22:56:12  honghanh
        ! Add AutoFillVector call to ForwardModel2 subroutine,
        ! to automatically add and fill isotope ratio in beta group
        ! (according to L2CF configuration file)
        !
        ! Revision 1.55  2011/12/15 16:53:24  honghanh
        ! Correct the name of CreateMLSValue_EarthReflectivity
        !
        ! Revision 1.54  2011/12/14 22:54:18  honghanh
        ! Add timeRange2MafRange method in CFM.
        !
        ! Revision 1.53  2011/11/10 17:07:07  honghanh
        ! Add 'qname' optional argument to a few CreateMLSValue_*
        ! subroutines.
        !
        ! Revision 1.52  2011/11/08 16:13:57  honghanh
        ! Add 'qname' parameter to CreateMLSValue_O2 subroutine.
        !
        ! Revision 1.51  2011/11/03 17:44:32  honghanh
        ! Bug fix in mockup
        !
        ! Revision 1.50  2011/11/02 04:20:16  honghanh
        ! Mockup for new CFM API.
        !
        ! Revision 1.48  2011/03/24 15:16:46  honghanh
        ! Add new interfaces for creating vector and vector values without going through quantity template databases
        !
        ! Revision 1.44  2010/11/03 20:17:01  honghanh
        ! Add name as an optional argument to CreateVector.
        !
        ! Revision 1.42  2010/09/28 14:42:42  honghanh
        ! Add call to forwardModel with jacobian
        !
        ! Revision 1.39  2010/08/06 14:15:06  honghanh
        ! Call dump on diff vector instead of measurement vector.
        !
        ! Revision 1.38  2010/08/05 16:23:03  honghanh
        ! Added Jacobian to forwardModel subroutine
        !
        ! Revision 1.36  2010/07/08 21:39:16  honghanh
        ! Add ApplyBaseline to cfm_fill_m
        !
        ! Revision 1.34  2010/06/29 17:02:47  honghanh
        ! Change the identifier 'fakeChunk' to 'chunk' because
        ! since it is created with ChunkDiVersionIde, it's as real as a chunk
        ! can get.
        !
        ! Revision 1.33  2010/06/29 15:29:33  honghanh
        ! Develop FillPtanQuantity to compute ptan, instead of using
        ! Get2DHydrostaticTangentPressure
        !
        ! Revision 1.32  2010/06/29 02:28:17  honghanh
        ! Change mockup to import functions and literals from CFM module
@


1.60
log
@replaced non-standard 'inquire( DIRECTORY=' syntax and tab characters
@
text
@d18 1
d20 2
d23 1
a23 5
       use machine, only: getarg, execute, is_a_directory


       ! To convert MAF to Profile, Pranjit Saha 
       use global_settings, only: L1MAFToL2Profile, L2ProfileToL1MAF
d25 3
a27 4
       use HDF5, only:  h5open_f, h5close_f
       use Allocate_Deallocate, only: Allocate_Test, DeAllocate_Test
       
       
a30 1

d35 1
a35 1
           "$Id: mockup.f90,v 1.59 2015/08/05 20:21:29 pwagner Exp $"
a45 1
       
a52 1
 
d95 5
a99 1
!=========== Customized initialization, added by Zheng Qu =====>      
d526 1
d531 1
d559 2
d584 1
d588 1
d662 1
d670 2
d704 1
a704 1

d707 1
d711 1
a711 1

d716 1
d718 1
a718 1
       call DestroyQuantityTemplateContents(newer_qPtanGHz)
d799 3
@


1.59
log
@Modified to compile properly with v4
@
text
@d20 1
a20 1
       use machine, only: getarg
d38 1
a38 1
           "$Id: mockup.f90,v 1.57 2011/12/24 18:39:13 honghanh Exp $"
d106 2
a107 1
        ! if stateVector file (inputH5fileName) is like '/[path]/TES_0000010310_0767_004_MLS_1679_2009d041_Version_1_StateVector.hdf'
d125 2
a126 1
       inquire( DIRECTORY=trim(MLS_CFM_OSP_PATH), exist=exists )
d130 1
a130 1
            '$TES_MLS_OSP_PATH/MLS_CFM not found!'/)) 
d134 2
a135 1
       inquire( DIRECTORY=trim(MLS_CFM_OUTPUT_PATH), exist=exists )
d142 2
a143 1
       inquire( DIRECTORY=trim(MLS_INPUT_FILE_PATH ), exist=exists )
d260 5
a264 5
               & (/ 'StateVector file', &
               trim(inputH5fileName), &
               'does NOT have the pattern', &
               trim(chbuff) , &
               'which was derived from TES run-seq-scan and MLS profile#, year and day', & 
d530 1
a530 1
						
d784 1
a784 1
       call system(trim(cbuff))
d789 3
@


1.58
log
@Copied from /users/akopyan/mlspgs-0403/cfm
@
text
@@


1.57
log
@Clean up unused imports and variables
@
text
@d10 1
a10 1
! foreign countries or providing access to foreign persons.
d16 1
a16 1
program mockup
d18 14
a31 4
    use CFM
    use CFM, only: ForwardModelConfig_T 
    use input
    use machine, only: getarg
a32 1
    implicit none
d35 6
a40 5
    character (len=*), parameter :: ModuleName= &
        "$RCSfile: mockup.f90,v $"
    character (len=*), parameter :: IdParm = &
        "$Id: mockup.f90,v 1.56 2011/12/23 22:56:12 honghanh Exp $"
    character (len=len(idParm)) :: Id = idParm
d43 736
a778 363
    integer :: i
    type(ForwardModelConfig_T), dimension(:), pointer :: forwardModelConfigDatabase
    type(MLSFile_T), dimension(:), pointer :: filedatabase
    type(MLSFile_T) :: l1bfile
    type(VGrid_T) :: vGridStandard55, vGridStandard37, vGridTESCO, vGridRefGPH
    type(VGrid_T) :: vGridExtinction
    type(HGrid_T) :: hGridStandard
    type(FGrid_T) :: fGridExtinctionConstant
    type(QuantityTemplate_T) :: qtemp, qCO, qso2, qhno3, qo3, qextinctionv2r3
    type(QuantityTemplate_T) :: qphitanGhz, qrefGPH, qgph, qh2o
    type(QuantityTemplate_T) :: qband9
    type(QuantityTemplate_T) :: qptanGHz
    type(QuantityTemplate_T) :: qbaseline9
    type(Vector_T) :: state, stateExtra
    type(Vector_T) :: radiance, diffVector
    type(Vector_T) :: observed, obsPrecision
    character(len=3) :: GHz = "GHz"
    character(len=2) :: sc = "sc"
    type(VectorValue_T) :: temperature, co, o2, so2, hno3, o3, extinctionv2r3, ptanGHz
    type(VectorValue_T) :: phitanGhz, refGPH, gph, h2o
    type(VectorValue_T) :: limbSidebandFraction9L
    type(VectorValue_T) :: limbSidebandFraction9U, elev9L, elev9U, earthReflectivity
    type(VectorValue_T) :: orbitInclination, spaceRadiance, scGeocAlt, tngtGeocAltGHz
    type(VectorValue_T) :: losVelGHz, band9, precision9
    type(VectorValue_T) :: correction9, noise9
    character(len=256) :: signalFileName, configFileName
    type(Matrix_T) :: jacobian
    integer :: error

    call getarg(1, signalFileName)
    call getarg(2, configFileName)

    nullify(filedatabase)

    call CFM_MLSSetup(signalFileName, configFileName, forwardModelConfigDatabase)

    !========================= Run the forward model ==========================

    ! Read L1BOA file
    error = InitializeMLSFile (l1bfile, content='l1boa', name=trim(l1boa), &
    shortName='L1BOA', type=l_hdf, access=DFACC_RDONLY)
    if (error /= 0) call MLSMessage (MLSMSG_Error, moduleName, &
    "Error initializing " // trim(l1boa))
    call mls_openfile (l1bfile, error)
    if (error /= 0) call MLSMessage (MLSMSG_Error, moduleName, &
    "Error opening " // trim(l1boa))
    ! don't care about return value of the following function
    i = AddFileToDatabase(filedatabase, l1bfile)

    ! read MLS input data file
    call Read_Spectroscopy (spectroscopy, 'HDF5')
    call ReadAntennaPatterns (antennaPatterns)
    call ReadFilterShapes(filterShapes)
    call ReadDACSFilterShapes (DACSFilterShapes)
    call ReadPointingGrids (pointingGrids)

    do i = 1, size(pfaFiles)
        call ReadPFAFile (pfaFiles(i))
    end do

    do i = 1, size(l2pc)
        call ReadHDF5L2PC (l2pc(i))
    end do

    vGridStandard37 = CreateVGrid (l_zeta, phyq_pressure, l_logarithmic, &
                                   start=1000.0d0, formula="37:6")

    vGridRefGPH = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
                               values=(/100.0_r8/))
    vGridStandard55 = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
    values=(/1000.00_r8,  825.404_r8,  681.292_r8,  562.341_r8,  464.159_r8,  &
             383.119_r8,  316.228_r8,  261.016_r8,  215.443_r8,  177.828_r8,  &
             146.780_r8,  121.153_r8,  100.000_r8,  82.5404_r8,  68.1292_r8,  &
             56.2341_r8,  46.4159_r8,  38.3119_r8,  31.6228_r8, 26.1016_r8,  &
             21.5443_r8,  17.7828_r8,  14.6780_r8,  12.1153_r8,  10.0000_r8, &
             8.25404_r8,  6.81292_r8,  5.62341_r8,  4.64159_r8,  3.83119_r8,  &
             3.16228_r8,  2.61016_r8,  2.15443_r8,  1.77828_r8,  1.46780_r8,  &
             1.21153_r8,  1.00000_r8,  0.681292_r8, 0.464159_r8,  0.316228_r8, &
             0.215443_r8, 0.146780_r8,  0.100000_r8,  0.0464159_r8, 0.0215443_r8, &
             0.01000_r8,  0.00464159_r8, 0.00215443_r8, 0.00100_r8, 0.000464159_r8,&
             0.000215443_r8, 0.000100_r8, 4.64159e-05_r8, 2.15443e-05_r8, 1.00000e-05_r8 /))

    vGridTESCO = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
    values=(/1012.93_r8,  1000.00_r8,  908.514_r8,  825.402_r8,  749.893_r8,  &
             681.291_r8,  618.966_r8,  562.342_r8, 510.898_r8,  464.160_r8,  421.698_r8, &
             383.117_r8,  348.069_r8,  316.227_r8,  287.298_r8,  261.016_r8, 237.137_r8, &
             215.444_r8,  195.735_r8,  177.829_r8,  161.561_r8,  146.779_r8,  133.352_r8, &
             121.152_r8, 110.069_r8,  100.000_r8,  90.8518_r8,  82.5406_r8,  74.9896_r8, &
             68.1295_r8,  61.8963_r8,  56.2339_r8, 51.0896_r8,  46.4158_r8,  42.1696_r8, &
             38.3119_r8,  34.8071_r8,  31.6229_r8,  28.7299_r8,  26.1017_r8, 23.7136_r8, &
             21.5443_r8,  19.5734_r8,  17.7828_r8,  16.1560_r8,  14.6780_r8,  13.3352_r8, &
             12.1153_r8, 11.0070_r8,  10.0000_r8,  9.08514_r8,  8.25402_r8,  6.81291_r8, &
             5.10898_r8,  4.64160_r8,  3.16227_r8, 2.61016_r8,  2.15443_r8,  1.61560_r8, &
             1.33352_r8,  1.00000_r8,  0.681292_r8,  0.383118_r8,  0.215443_r8, 0.100000_r8 /))

    vGridExtinction = CreateVGrid (l_zeta, phyq_pressure, l_logarithmic, &
    start=1000.0d0, formula="21:12,14:6,12:3")

    ! Have insetoverlaps, and not single
    hGridStandard = CreateRegularHGrid(GHz, 0.0_r8, 1.5_r8, .true., &
                                       filedatabase, startL1Maf, endL1Maf)

    fGridExtinctionConstant = CreateFGrid(L_IntermediateFrequency, (/0.0_r8/))

    ! Construct state vector
    state = CreateAgileVector(name='state')

    qtemp = CreateQtyTemplate(l_temperature, qName='temperature', &
                              avgrid=vGridStandard55, ahgrid=hGridStandard)
    temperature = CreateValue4AgileVector(qtemp, value=TemperatureInput)
    call AddValue2Vector(state, temperature)

    qCO = CreateQtyTemplate(l_vmr, avgrid=vGridTESCO, ahgrid=hGridStandard, &
    qMolecule=l_co, qName='CO')
    co = CreateValue4AgileVector(qco, value=COInput)
    call AddValue2Vector(state, co)

    o2 = CreateMLSValue_O2 (vGridStandard37, hGridStandard, qname='O2')
    call AddValue2Vector(state, o2)

    qSO2 = CreateQtyTemplate(l_vmr, avgrid=vGridStandard37, ahgrid=hGridStandard, &
    qMolecule=l_so2, qName='SO2')
    so2 = CreateValue4AgileVector(qSO2, value=SO2Input)
    call AddValue2Vector(state, so2)

    qHNO3 = CreateQtyTemplate(l_vmr, avgrid=vGridStandard37, ahgrid=hGridStandard, &
    qMolecule=l_hno3, qName='HNO3')
    hno3 = CreateValue4AgileVector(qhno3, value=HNO3Input)
    call AddValue2Vector(state, hno3)

    qO3 = CreateQtyTemplate(l_vmr, avgrid=vGridStandard55, ahgrid=hGridStandard, &
    qMolecule=l_o3, qName='O3')
    o3 = CreateValue4AgileVector(qo3, value=O3Input)
    call AddValue2Vector(state, o3)

    qExtinctionv2r3 = CreateQtyTemplate(l_vmr, avgrid=vGridExtinction, &
    ahgrid=hGridStandard, afgrid=fgridExtinctionConstant, qRadiometer="R3", &
    qMolecule=l_extinctionv2)
    extinctionv2r3 = CreateValue4AgileVector(qExtinctionv2r3, value=extinctionV2R3Input)
    call AddValue2Vector(state, extinctionv2r3)

    stateExtra = CreateAgileVector(name='stateExtra')

    qPtanGHz = CreateQtyTemplate(l_ptan, startL1Maf, endL1Maf, filedatabase, &
    qInstModule=GHz, qName='ptanGHz')
    ptanGHz = CreateValue4AgileVector(qPtanGhz)

    qPhitanGHz = CreateQtyTemplate(l_phitan, startL1Maf, endL1Maf, qInstModule=GHz, &
    filedatabase=filedatabase, qName='phitanGHz')
    phitanGhz = CreateValue4AgileVector(qPhitanGhz)
    call FillPhitanQuantity(phitanGhz)
    call AddValue2Vector(stateExtra, phitanGhz)

    qRefGPH = CreateQtyTemplate(l_refGPH, avgrid=vGridRefGPH, &
    ahgrid=hGridStandard, qName='refGPH')
    refGPH = CreateValue4AgileVector(qRefGPH, spreadvalue=refGPHInput) ! unit is meter
    call AddValue2Vector(stateExtra, refGPH)

    qGPH = CreateQtyTemplate(l_gph, avgrid=vGridStandard55, ahgrid=hGridStandard, &
                             qName='GPH')
    gph = CreateValue4AgileVector(qGPH)
    call AddValue2Vector(stateExtra, gph)

    qH2O = CreateQtyTemplate(l_vmr, avgrid=vGridStandard55, ahgrid=hGridStandard, &
    qMolecule=l_h2o, qLogBasis=.true., qMinValue=0.1E-6_r8, qName='H2O')
    h2o = CreateValue4AgileVector(qH2O, value=H2OInput)
    call AddValue2Vector(stateExtra, H2O)

    ! Fill orbit inclination, tangent geocentric altitude with
    ! data from MLS L1B file, and use them, along with other
    ! quantities to calculate ptan
    limbSidebandFraction9L = CreateMLSValue_LSF(9, .false., qname='lsf9L')
    call AddValue2Vector(stateExtra, limbSidebandFraction9L)

    limbSidebandFraction9U = CreateMLSValue_LSF(9, .true., qname='lsf9U')
    call AddValue2Vector(stateExtra, limbSidebandFraction9U)

    elev9L = CreateMLSValue_ElevationOffset(9, .false.)
    call AddValue2Vector(stateExtra, elev9L)

    elev9U = CreateMLSValue_ElevationOffset(9, .true.)
    call AddValue2Vector(stateExtra, elev9U)

    earthReflectivity = CreateMLSValue_EarthReflectivity()
    call AddValue2Vector(stateExtra, earthReflectivity)

    orbitInclination = CreateMLSValue_FromL1BOA (l_orbitInclination, sc, &
    filedatabase, startL1Maf, endL1Maf)
    call AddValue2Vector(stateExtra, orbitInclination)

    spaceRadiance = CreateMLSValue_SpaceRadiance()
    call AddValue2Vector(stateExtra, spaceRadiance)

    scGeocAlt = CreateMLSValue_FromL1BOA(l_scgeocalt, sc, filedatabase, &
    startL1Maf, endL1Maf)
    call AddValue2Vector(stateExtra, scGeocAlt)

    tngtGeocAltGHz = CreateMLSValue_FromL1BOA (l_tngtgeocalt, GHz, &
    filedatabase, startL1Maf, endL1Maf)
    call AddValue2Vector(stateExtra, tngtGeocAltGHz)

    losVelGHz = CreateMLSValue_FromL1BOA(l_losVel, GHz, filedatabase, &
    startL1Maf, endL1Maf)
    call AddValue2Vector(stateExtra, losVelGHz)

    radiance = CreateAgileVector(name='simulatedRadiance')

    qband9 = CreateQtyTemplate(l_radiance, startL1Maf, endL1Maf, filedatabase, &
                               qSignal="R3:240.B9F:CO", qName='band9')
    band9 = CreateValue4AgileVector(qband9)
    call AddValue2Vector(radiance, band9)

    ! calculate ptan
    call FillPtanQuantity (ptanGHz, temperature, refGPH, h2o, &
    orbitInclination, phitanGhz, tngtGeocAltGHz)
    call AddValue2Vector(stateExtra, ptanGhz)

    ! We no longer need vGrid because the quantity templates have copied it
    call DestroyVGridContents(vGridStandard55)
    call DestroyVGridContents(vGridStandard37)
    call DestroyVGridContents(vGridTESCO)
    ! No long need hGrid, fGrid either
    call DestroyHGridContents(hGridStandard)
    call DestroyFGridContents(fGridExtinctionConstant)

    ! GPH is filled by the forward model

    ! Create jacobian
    jacobian = CreatePlainMatrix(radiance, state)

    ! Call the forward model
    call ForwardModel2 (0, forwardModelConfigDatabase, state, &
                        stateExtra, radiance, jacobian)
    call dump(radiance, details=1)

    !call dump(jacobian, details=3)

    !=================== Finish running the forward model =====================

    !== Clean up anything that is not related to reading observed radiance ====
    call DestroyMatrix(jacobian)
    call DestroyAgileVectorContent (state)
    call DestroyAgileVectorContent (stateExtra)
    call Destroy_DACS_Filter_Database
    call Destroy_Filter_Shapes_Database
    call Destroy_Ant_Patterns_Database
    call Destroy_SpectCat_Database
    call Destroy_Line_Database
    call Destroy_Pointing_Grid_Database
    call DestroyL2PCDatabase
    call Destroy_PFADataBase

    ! Destroy all quantity templates that goes in state and stateExtra
    call DestroyQuantityTemplateContents(qtemp)
    call DestroyQuantityTemplateContents(qCO)
    call DestroyQuantityTemplateContents(qSO2)
    call DestroyQuantityTemplateContents(qHNO3)
    call DestroyQuantityTemplateContents(qO3)
    call DestroyQuantityTemplateContents(qExtinctionv2r3)
    call DestroyQuantityTemplateContents(qPtanGHz)
    call DestroyQuantityTemplateContents(qPhitanGHz)
    call DestroyQuantityTemplateContents(qRefGPH)
    call DestroyQuantityTemplateContents(qGPH)
    call DestroyQuantityTemplateContents(qH2O)
    ! even quantities created by CFM subroutines has templates
    call DestroyQuantityTemplateContents(o2%template)
    call DestroyQuantityTemplateContents(limbSidebandFraction9L%template)
    call DestroyQuantityTemplateContents(limbSidebandFraction9U%template)
    call DestroyQuantityTemplateContents(elev9L%template)
    call DestroyQuantityTemplateContents(elev9U%template)
    call DestroyQuantityTemplateContents(earthReflectivity%template)
    call DestroyQuantityTemplateContents(orbitInclination%template)
    call DestroyQuantityTemplateContents(spaceRadiance%template)
    call DestroyQuantityTemplateContents(scGeocAlt%template)
    call DestroyQuantityTemplateContents(tngtGeocAltGHz%template)
    call DestroyQuantityTemplateContents(losVelGHz%template)
    !========================== finish cleaning ===============================

    !====================== Read observed radiance ============================
    ! Open l1brad
    error = InitializeMLSFile(l1bfile, content='l1brad', &
    name=trim(l1brad), shortName='L1BRAD', type=l_hdf, access=DFACC_RDONLY)
    if (error /= 0) call MLSMessage (MLSMSG_Error, moduleName, &
    "Error initializing " // trim(l1brad))

    call mls_openFile(l1bfile, error)
    if (error /= 0 ) call MLSMessage (MLSMSG_Error, moduleName, &
    "Error opening " // trim(l1brad))

    ! Add it to the filedatabase
    ! AddFileToDatabase doesn't return an error.
    ! I don't care about the return value of AddFileToDatabase,
    ! but Fortran dictate that the return value has to be captured,
    ! so error is being used as a dummy variable.
    error = AddFileToDatabase(filedatabase, l1bfile)

    observed = CreateAgileVector(name='observedRadiance')
    obsPrecision = CreateAgileVector(name='observedRadiancePrecision')

    ! need to read precision before reading quantity
    band9 = CreateValue4AgileVector(qband9)
    call AddValue2Vector(observed, band9)
    ! precision of a quantity has the same template as the quantity
    precision9 = CreateValue4AgileVector(qband9)
    call AddValue2Vector(obsPrecision, precision9)

    ! need to fill precision first
    call FillVectorQuantityFromL1B(precision9, startL1Maf, endL1Maf, &
    filedatabase, .true.)
    ! then fill the quantity and setting precision at the same time
    call FillVectorQuantityFromL1B(band9, startL1Maf, endL1Maf, &
    filedatabase, .false., precisionQuantity=precision9)

    ! then we need to get the baseline correction and noise
    qbaseline9 = CreateQtyTemplate(l_l1bmafbaseline, startL1Maf, endL1Maf, &
    filedatabase, qSignal="R3:240.B9F:CO", qname='baseline 9')

    correction9 = CreateValue4AgileVector (qbaseline9)
    ! the space in ' Baseline' is very important
    call FillVectorQuantityFromL1B(correction9, startL1Maf, endL1Maf, &
    filedatabase, .false., suffix=' Baseline')

    ! apply correction to the quantity
    call ApplyBaseline (band9, correction9, .false., .false.)

    ! get the noise
    noise9 = CreateValue4AgileVector(qbaseline9) ! same template as baseline
    ! again, the string must match exactly
    call FillVectorQuantityFromL1B(noise9, startL1Maf, endL1Maf, &
    filedatabase, .false., suffix=' Baseline precision')

    ! apply the noise to the precision
    call ApplyBaseline (precision9, noise9, .true., .false.)
    call dump(observed, details=1)

    !==================== Finish reading observed radiance ====================

    !============= At this point we don't need L1B file anymore ===============
    do i = 1, size(filedatabase)
        call mls_closefile(filedatabase(i))
    end do

    deallocate(filedatabase)
    nullify(filedatabase)
    !================== Done closing and clean up file objects ================

    diffVector = observed - radiance
    !call dump(diffVector, details=1)

    !===== Clean up calculated and observed radiance and related vectors ======
    call DestroyAgileVectorContent (radiance)
    call DestroyAgileVectorContent (observed)
    call DestroyAgileVectorContent (diffVector)
    call DestroyAgileVectorContent (obsPrecision)

    call DestroyVectorValueContent (noise9)
    call DestroyVectorValueContent (correction9)

    call DestroyQuantityTemplateContents(qband9)
    call DestroyQuantityTemplateContents(qbaseline9)
    !========================== Done cleaning up ==============================

    call CFM_MLSCleanup(forwardModelConfigDatabase)
d780 2
d784 57
a840 54
! $Log: mockup.f90,v $
! Revision 1.56  2011/12/23 22:56:12  honghanh
! Add AutoFillVector call to ForwardModel2 subroutine,
! to automatically add and fill isotope ratio in beta group
! (according to L2CF configuration file)
!
! Revision 1.55  2011/12/15 16:53:24  honghanh
! Correct the name of CreateMLSValue_EarthReflectivity
!
! Revision 1.54  2011/12/14 22:54:18  honghanh
! Add timeRange2MafRange method in CFM.
!
! Revision 1.53  2011/11/10 17:07:07  honghanh
! Add 'qname' optional argument to a few CreateMLSValue_*
! subroutines.
!
! Revision 1.52  2011/11/08 16:13:57  honghanh
! Add 'qname' parameter to CreateMLSValue_O2 subroutine.
!
! Revision 1.51  2011/11/03 17:44:32  honghanh
! Bug fix in mockup
!
! Revision 1.50  2011/11/02 04:20:16  honghanh
! Mockup for new CFM API.
!
! Revision 1.48  2011/03/24 15:16:46  honghanh
! Add new interfaces for creating vector and vector values without going through quantity template databases
!
! Revision 1.44  2010/11/03 20:17:01  honghanh
! Add name as an optional argument to CreateVector.
!
! Revision 1.42  2010/09/28 14:42:42  honghanh
! Add call to forwardModel with jacobian
!
! Revision 1.39  2010/08/06 14:15:06  honghanh
! Call dump on diff vector instead of measurement vector.
!
! Revision 1.38  2010/08/05 16:23:03  honghanh
! Added Jacobian to forwardModel subroutine
!
! Revision 1.36  2010/07/08 21:39:16  honghanh
! Add ApplyBaseline to cfm_fill_m
!
! Revision 1.34  2010/06/29 17:02:47  honghanh
! Change the identifier 'fakeChunk' to 'chunk' because
! since it is created with ChunkDivide, it's as real as a chunk
! can get.
!
! Revision 1.33  2010/06/29 15:29:33  honghanh
! Develop FillPtanQuantity to compute ptan, instead of using
! Get2DHydrostaticTangentPressure
!
! Revision 1.32  2010/06/29 02:28:17  honghanh
! Change mockup to import functions and literals from CFM module
@


1.56
log
@Add AutoFillVector call to ForwardModel2 subroutine,
to automatically add and fill isotope ratio in beta group
(according to L2CF configuration file)
@
text
@d29 1
a29 1
        "$Id: mockup.f90,v 1.55 2011/12/15 16:53:24 honghanh Exp $"
d42 4
a45 5
    type(QuantityTemplate_T) :: qphitanGhz, qrefGPH, qgph, qh2o, qisotoperatioO_18_O
    type(QuantityTemplate_T) :: qisotoperatioO3_ASYM_O_18, qisotoperatioO3_V2
    type(QuantityTemplate_T) :: qisotoperatioHNO3, qisotoperatioCO, qband9
    type(QuantityTemplate_T) :: qptanGHz, qisotoperatioO3, qisotoperatioS_32_O2
    type(QuantityTemplate_T) :: qisotoperatioO3_SYM_O_18, qbaseline9
a48 1
    type(Vector_T) :: corrections, correctionNoise
d52 2
a53 3
    type(VectorValue_T) :: phitanGhz, refGPH, gph, h2o, isotoperatioO_18_O, isotoperatioO3
    type(VectorValue_T) :: isotoperatioO3_ASYM_O_18, isotoperatioO3_V2, isotoperatioS_32_O2
    type(VectorValue_T) :: isotoperatioHNO3, isotoperatioCO, limbSidebandFraction9L
d56 1
a56 1
    type(VectorValue_T) :: losVelGHz, band9, isotoperatioO3_SYM_O_18, precision9
a200 48
    !qIsotoperatioO_18_O = CreateQtyTemplate(l_isotoperatio, &
    !qName='isotoperatioO_18_O', qmolecule=l_o_18_o)
    !isotoperatioO_18_O = CreateValue4AgileVector(qIsotoperatioO_18_O)
    !spreadvalue=0.00409000_r8)
    !call AddValue2Vector(stateExtra, isotoperatioO_18_O)

    !qIsotoperatioO3 = CreateQtyTemplate(l_isotoperatio, qName='isotoperatioO3', &
    !qmolecule=l_o3)
    !isotoperatioO3 = CreateValue4AgileVector(qIsotoperatioO3)
    !spreadvalue=0.99290103_r8)
    !call AddValue2Vector(stateExtra, isotoperatioO3)

    !qIsotoperatioO3_ASYM_O_18 = CreateQtyTemplate(l_isotoperatio, &
    !qmolecule=l_o3_asym_o_18, qName='isotoperatioO3_ASYM_O_18')
    !isotoperatioO3_ASYM_O_18 = CreateValue4AgileVector(qIsotoperatioO3_ASYM_O_18)
    !spreadvalue=0.00398194_r8)
    !call AddValue2Vector(stateExtra, isotoperatioO3_ASYM_O_18)

    !qIsotoperatioO3_SYM_O_18 = CreateQtyTemplate(l_isotoperatio, &
    !qmolecule=l_o3_sym_o_18, qName='isotoperatioO3_SYM_O_18')
    !isotoperatioO3_SYM_O_18 = CreateValue4AgileVector(qIsotoperatioO3_SYM_O_18)
    !spreadvalue=0.00199097_r8)
    !call AddValue2Vector(stateExtra, isotoperatioO3_SYM_O_18)

    !qIsotoperatioO3_V2 = CreateQtyTemplate(l_isotoperatio, qmolecule=l_o3_v2, &
    !qName='isotoperatioO3_V2')
    !isotoperatioO3_V2 = CreateValue4AgileVector(qIsotoperatioO3_V2)
    !spreadvalue=0.99290103_r8)
    !call AddValue2Vector(stateExtra, isotoperatioO3_V2)

    !qIsotoperatioS_32_O2 = CreateQtyTemplate(l_isotoperatio, qmolecule=l_s_32_o2, &
    !qName='isotoperatioS_32_O2')
    !isotoperatioS_32_O2 = CreateValue4AgileVector(qIsotoperatioS_32_O2, &
    !spreadvalue=0.94568002_r8)
    !call AddValue2Vector(stateExtra, isotoperatioS_32_O2)

    !qIsotoperatioHNO3 = CreateQtyTemplate(l_isotoperatio, qmolecule=l_hno3, &
    !qName='isotoperatioHNO3')
    !isotoperatioHNO3 = CreateValue4AgileVector(qIsotoperatioHNO3, &
    !spreadvalue=0.98910999_r8)
    !call AddValue2Vector(stateExtra, isotoperatioHNO3)

    !qIsotoperatioCO = CreateQtyTemplate(l_isotoperatio, qmolecule=l_co, &
    !qName='isotoperatioCO')
    !isotoperatioCO = CreateValue4AgileVector(qIsotoperatioCO, &
    !spreadvalue=0.98654002_r8)
    !call AddValue2Vector(stateExtra, isotoperatioCO)

a296 8
    call DestroyQuantityTemplateContents(qIsotoperatioO_18_O)
    call DestroyQuantityTemplateContents(qIsotoperatioO3)
    call DestroyQuantityTemplateContents(qIsotoperatioO3_ASYM_O_18)
    call DestroyQuantityTemplateContents(qIsotoperatioO3_SYM_O_18)
    call DestroyQuantityTemplateContents(qIsotoperatioO3_V2)
    call DestroyQuantityTemplateContents(qIsotoperatioS_32_O2)
    call DestroyQuantityTemplateContents(qIsotoperatioHNO3)
    call DestroyQuantityTemplateContents(qIsotoperatioCO)
d400 5
@


1.55
log
@Correct the name of CreateMLSValue_EarthReflectivity
@
text
@d29 1
a29 1
        "$Id: mockup.f90,v 1.54 2011/12/14 22:54:18 honghanh Exp $"
d204 47
a250 47
    qIsotoperatioO_18_O = CreateQtyTemplate(l_isotoperatio, &
    qName='isotoperatioO_18_O', qmolecule=l_o_18_o)
    isotoperatioO_18_O = CreateValue4AgileVector(qIsotoperatioO_18_O, &
    spreadvalue=0.00409000_r8)
    call AddValue2Vector(stateExtra, isotoperatioO_18_O)

    qIsotoperatioO3 = CreateQtyTemplate(l_isotoperatio, qName='isotoperatioO3', &
    qmolecule=l_o3)
    isotoperatioO3 = CreateValue4AgileVector(qIsotoperatioO3, &
    spreadvalue=0.99290103_r8)
    call AddValue2Vector(stateExtra, isotoperatioO3)

    qIsotoperatioO3_ASYM_O_18 = CreateQtyTemplate(l_isotoperatio, &
    qmolecule=l_o3_asym_o_18, qName='isotoperatioO3_ASYM_O_18')
    isotoperatioO3_ASYM_O_18 = CreateValue4AgileVector(qIsotoperatioO3_ASYM_O_18, &
    spreadvalue=0.00398194_r8)
    call AddValue2Vector(stateExtra, isotoperatioO3_ASYM_O_18)

    qIsotoperatioO3_SYM_O_18 = CreateQtyTemplate(l_isotoperatio, &
    qmolecule=l_o3_sym_o_18, qName='isotoperatioO3_SYM_O_18')
    isotoperatioO3_SYM_O_18 = CreateValue4AgileVector(qIsotoperatioO3_SYM_O_18, &
    spreadvalue=0.00199097_r8)
    call AddValue2Vector(stateExtra, isotoperatioO3_SYM_O_18)

    qIsotoperatioO3_V2 = CreateQtyTemplate(l_isotoperatio, qmolecule=l_o3_v2, &
    qName='isotoperatioO3_V2')
    isotoperatioO3_V2 = CreateValue4AgileVector(qIsotoperatioO3_V2, &
    spreadvalue=0.99290103_r8)
    call AddValue2Vector(stateExtra, isotoperatioO3_V2)

    qIsotoperatioS_32_O2 = CreateQtyTemplate(l_isotoperatio, qmolecule=l_s_32_o2, &
    qName='isotoperatioS_32_O2')
    isotoperatioS_32_O2 = CreateValue4AgileVector(qIsotoperatioS_32_O2, &
    spreadvalue=0.94568002_r8)
    call AddValue2Vector(stateExtra, isotoperatioS_32_O2)

    qIsotoperatioHNO3 = CreateQtyTemplate(l_isotoperatio, qmolecule=l_hno3, &
    qName='isotoperatioHNO3')
    isotoperatioHNO3 = CreateValue4AgileVector(qIsotoperatioHNO3, &
    spreadvalue=0.98910999_r8)
    call AddValue2Vector(stateExtra, isotoperatioHNO3)

    qIsotoperatioCO = CreateQtyTemplate(l_isotoperatio, qmolecule=l_co, &
    qName='isotoperatioCO')
    isotoperatioCO = CreateValue4AgileVector(qIsotoperatioCO, &
    spreadvalue=0.98654002_r8)
    call AddValue2Vector(stateExtra, isotoperatioCO)
d315 3
a317 3
!    call ForwardModel2 (0, forwardModelConfigDatabase, state, &
!                        stateExtra, radiance, jacobian)
!    call dump(radiance, details=1)
d459 3
@


1.54
log
@Add timeRange2MafRange method in CFM.
@
text
@d29 1
a29 1
        "$Id: mockup.f90,v 1.53 2011/11/10 17:07:07 honghanh Exp $"
d267 1
a267 1
    earthReflectivity = CreateMLSValue_EarthReflectiviy()
d459 3
@


1.53
log
@Add 'qname' optional argument to a few CreateMLSValue_*
subroutines.
@
text
@d19 1
d29 1
a29 1
        "$Id: mockup.f90,v 1.52 2011/11/08 16:13:57 honghanh Exp $"
d459 4
@


1.52
log
@Add 'qname' parameter to CreateMLSValue_O2 subroutine.
@
text
@d28 1
a28 1
        "$Id: mockup.f90,v 1.51 2011/11/03 17:44:32 honghanh Exp $"
d254 1
a254 1
    limbSidebandFraction9L = CreateMLSValue_LSF(9, .false.)
d257 1
a257 1
    limbSidebandFraction9U = CreateMLSValue_LSF(9, .true.)
d458 3
@


1.51
log
@Bug fix in mockup
@
text
@d28 1
a28 1
        "$Id: mockup.f90,v 1.50 2011/11/02 04:20:16 honghanh Exp $"
d152 1
a152 1
    o2 = CreateMLSValue_O2 (vGridStandard37, hGridStandard)
d438 1
a438 1
    call dump(diffVector, details=1)
d458 3
@


1.50
log
@Mockup for new CFM API.
@
text
@d28 1
a28 1
        "$Id: mockup.f90,v 1.48 2011/03/24 15:16:46 honghanh Exp $"
d314 3
a316 3
    call ForwardModel2 (0, forwardModelConfigDatabase, state, &
                        stateExtra, radiance, jacobian)
    call dump(radiance, details=1)
d391 1
d458 3
@


1.49
log
@Mockup for new CFM API
@
text
@d316 1
a316 1
    !call dump(radiance, details=1)
d370 81
a450 81
!    ! Open l1brad
!    error = InitializeMLSFile(l1bfile, content='l1brad', &
!    name=trim(l1brad), shortName='L1BRAD', type=l_hdf, access=DFACC_RDONLY)
!    if (error /= 0) call MLSMessage (MLSMSG_Error, moduleName, &
!    "Error initializing " // trim(l1brad))
!
!    call mls_openFile(l1bfile, error)
!    if (error /= 0 ) call MLSMessage (MLSMSG_Error, moduleName, &
!    "Error opening " // trim(l1brad))
!
!    ! Add it to the filedatabase
!    ! AddFileToDatabase doesn't return an error.
!    ! I don't care about the return value of AddFileToDatabase,
!    ! but Fortran dictate that the return value has to be captured,
!    ! so error is being used as a dummy variable.
!    error = AddFileToDatabase(filedatabase, l1bfile)
!
!    observed = CreateAgileVector(name='observedRadiance')
!    obsPrecision = CreateAgileVector(name='observedRadiancePrecision')
!
!    ! need to read precision before reading quantity
!    call AddValue2Vector(observed, band9)
!    ! precision of a quantity has the same template as the quantity
!    precision9 = CreateValue4AgileVector(qband9)
!    call AddValue2Vector(obsPrecision, precision9)
!
!    ! need to fill precision first
!    call FillVectorQuantityFromL1B(precision9, startL1Maf, endL1Maf, &
!    filedatabase, .true.)
!    ! then fill the quantity and setting precision at the same time
!    call FillVectorQuantityFromL1B(band9, startL1Maf, endL1Maf, &
!    filedatabase, .false., precisionQuantity=precision9)
!
!    ! then we need to get the baseline correction and noise
!    qbaseline9 = CreateQtyTemplate(l_l1bmafbaseline, startL1Maf, endL1Maf, &
!    filedatabase, qSignal="R3:240.B9F:CO", qname='baseline 9')
!
!    correction9 = CreateValue4AgileVector (qbaseline9)
!    ! the space in ' Baseline' is very important
!    call FillVectorQuantityFromL1B(correction9, startL1Maf, endL1Maf, &
!    filedatabase, .false., suffix=' Baseline')
!
!    ! apply correction to the quantity
!    call ApplyBaseline (band9, correction9, .false., .false.)
!
!    ! get the noise
!    noise9 = CreateValue4AgileVector(qbaseline9) ! same template as baseline
!    ! again, the string must match exactly
!    call FillVectorQuantityFromL1B(noise9, startL1Maf, endL1Maf, &
!    filedatabase, .false., suffix=' Baseline precision')
!
!    ! apply the noise to the precision
!    call ApplyBaseline (precision9, noise9, .true., .false.)
!    call dump(observed, details=1)
!
!    !==================== Finish reading observed radiance ====================
!
!    !============= At this point we don't need L1B file anymore ===============
!    do i = 1, size(filedatabase)
!        call mls_closefile(filedatabase(i))
!    end do
!
!    deallocate(filedatabase)
!    nullify(filedatabase)
!    !================== Done closing and clean up file objects ================
!
!    diffVector = observed - radiance
!    call dump(diffVector, details=1)
!
!    !===== Clean up calculated and observed radiance and related vectors ======
!    call DestroyAgileVectorContent (radiance)
!    call DestroyAgileVectorContent (observed)
!    call DestroyAgileVectorContent (diffVector)
!    call DestroyAgileVectorContent (obsPrecision)
!
!    call DestroyVectorValueContent (noise9)
!    call DestroyVectorValueContent (correction9)
!
!    call DestroyQuantityTemplateContents(qband9)
!    call DestroyQuantityTemplateContents(qbaseline9)
!    !========================== Done cleaning up ==============================
@


1.48
log
@Add new interfaces for creating vector and vector values without going through quantity template databases
@
text
@d18 3
a20 3
   use CFM
   use input
   use machine, only: getarg
d22 1
a22 1
   implicit none
d25 5
a29 5
   character (len=*), parameter :: ModuleName= &
       "$RCSfile: mockup.f90,v $"
   character (len=*), parameter :: IdParm = &
       "$Id: mockup.f90,v 1.44 2010/11/03 20:17:01 honghanh Exp $"
   character (len=len(idParm)) :: Id = idParm
d32 66
a97 2
   type(Vector_T), target :: measurement, observed, obsPrecision
   type(Vector_T), pointer :: pMeasurement, pObserved, pObsPrecision
d99 1
a99 69
   pMeasurement => measurement
   pObserved => observed
   pObsPrecision => obsPrecision

   call forwardModelWithSingleMAFExample(pMeasurement)
   !call getObservedRadiancesExample (pObserved, pObsPrecision)

   ! if the measurement vector and the observed vector is calculated/read
   ! between the same pair of CFM_MLSSetup and CFM_MLSCleanup
   ! then you can compute the difference by doing
   ! diffVector = observed - measurement
   ! Don't forget to
   ! call DestroyVectorInfo(diffVector)
   ! at the end

   contains
   subroutine forwardModelExample (measurement)
      integer :: i
      type(ForwardModelConfig_T), dimension(:), pointer :: forwardModelConfigDatabase
      type(MLSFile_T), dimension(:), pointer :: filedatabase
      type(MLSChunk_T) :: chunk
      type(VGrid_T) :: vGridStandard, vGridRefGPH
      type(HGrid_T) :: hGridStandard
      type(FGrid_T) :: fGridStandard
      type(QuantityTemplate_T) :: temperature, GPH, H2O, O3, ptanGHz, band7, &
                                  geodAltitude, orbincl, geocAlt, refGPH, band2, &
                                  band8, phitanGHz
      type(QuantityTemplate_T), dimension(:), pointer :: qtyTemplates
      type(VectorTemplate_T) :: stateTemplate, measurementTemplate
      type(Vector_T) :: state, stateExtra
      type(Vector_T), pointer :: measurement
      character(len=3) :: GHz = "GHz"
      character(len=2) :: sc = "sc"
      integer :: stateSelected(10), measurementSelected(3)
      type(VectorValue_T), pointer :: quantity, h2o_vv, orbincl_vv, geocAlt_vv, &
                                      ptanG_vv, temperature_vv, refGPH_vv, &
                                      phitan_vv
      integer :: temperature_index, h2o_index, band2_index
      integer :: o3_index, ptanGHz_index, band7_index, phitanGHz_index
      integer :: geodAlt_index, orbincl_index, gph_index
      integer :: geocAlt_index, band8_index, refGPH_index
      character(len=256) :: signalFileName, configFileName
      type(Matrix_T) :: jacobian

      call getarg(1, signalFileName)
      call getarg(2, configFileName)

      nullify(qtyTemplates)

      call CFM_MLSSetup(startTime, endTime, l1boa, leapsecFile, signalFileName, &
      configFileName, filedatabase, qtyTemplates, chunk, &
      forwardModelConfigDatabase, stateExtra)

      ! read MLS input data file
      call Read_Spectroscopy (spectroscopy, 'HDF5')
      call ReadAntennaPatterns (antennaPatterns)
      call ReadFilterShapes(filterShapes)
      call ReadDACSFilterShapes (DACSFilterShapes)
      call ReadPointingGrids (pointingGrids)

      do i = 1, size(pfaFiles)
         call ReadPFAFile (pfaFiles(i))
      end do

      do i = 1, size(l2pc)
         call ReadHDF5L2PC (l2pc(i))
      end do

      vGridStandard = CreateVGrid (l_zeta, phyq_pressure, l_logarithmic, &
d102 349
a450 2
      vGridRefGPH = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
                                 values=(/100.0_r8/))
d452 1
a452 520
      ! Have insetoverlaps, and not single
      hGridStandard = CreateRegularHGrid(GHz, 0.0_r8, 1.5_r8, .true., &
                                         filedatabase, chunk)

      fGridStandard = CreateFGrid(L_IntermediateFrequency, (/0.0_r8/))

      temperature = CreateQtyTemplate(l_temperature, filedatabase=filedatabase, &
                                      chunk=chunk, qName='temperature', &
                                      avgrid=vGridStandard, ahgrid=hGridStandard)
      GPH = CreateQtyTemplate(l_gph, filedatabase=filedatabase, chunk=chunk, &
                              avgrid=vGridStandard, ahgrid=hGridStandard, qName='GPH')
      O3 = CreateQtyTemplate(l_vmr, filedatabase=filedatabase, chunk=chunk, &
                             avgrid=vGridStandard, ahgrid=hGridStandard, qMolecule=l_o3, &
                             qName='O3')
      H2O = CreateQtyTemplate(l_vmr, filedatabase=filedatabase, chunk=chunk, &
                              avgrid=vGridStandard, ahgrid=hGridStandard, qMolecule=l_h2o, &
                              qLogBasis=.true., qMinValue=0.1E-6_r8, qName='H2O')
      ptanGHz = CreateQtyTemplate(l_ptan, filedatabase=filedatabase, &
                                  chunk=chunk, qInstModule=GHz, qName='ptanGHz')
      ! band 2,7,8 is the band whose radiances are to be computed
      ! see CFM document for a list of signals corresponding to bands
      band7 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                                qSignal="R3:240.B7F:O3", qName='band7')
      band2 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                                qSignal="R2:190.B2F:H2O", qName='band2')
      band8 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                                qSignal="R3:240.B8F:PT", qName='band8')
      geodAltitude = CreateQtyTemplate(l_tngtgeodalt, filedatabase=filedatabase, &
                                       chunk=chunk, qInstModule=GHz, qName='geodAltitude')
      geocAlt = CreateQtyTemplate(l_tngtgeocalt, filedatabase=filedatabase, &
                                  chunk=chunk, qInstModule=GHz, qName='geocAlt')
      orbincl = CreateQtyTemplate(l_orbitInclination, filedatabase=filedatabase, &
                                  chunk=chunk, qInstModule=sc, qName='orbincl')
      refGPH = CreateQtyTemplate(l_refGPH, avgrid=vGridRefGPH, ahgrid=hGridStandard, qName='refGPH')
      phitanGHz = CreateQtyTemplate(l_phitan, qInstModule="GHz", filedatabase=filedatabase, &
                                    chunk=chunk, qName='phitanGHz')

      ! We no longer need vGrid because the quantity templates have copied it
      call DestroyVGridContents(vGridStandard)
      ! No long need hGrid, fGrid either
      call DestroyHGridContents(hGridStandard)
      call DestroyFGridContents(fGridStandard)

      temperature_index = AddQuantityTemplateToDatabase(qtyTemplates, temperature)
      gph_index = AddQuantityTemplateToDatabase(qtyTemplates, GPH)
      o3_index = AddQuantityTemplateToDatabase(qtyTemplates, O3)
      h2o_index = AddQuantityTemplateToDatabase(qtyTemplates, H2O)
      ptanGHz_index = AddQuantityTemplateToDatabase(qtyTemplates, ptanGHz)
      geodAlt_index = AddQuantityTemplateToDatabase(qtyTemplates, geodAltitude)
      geocAlt_index = AddQuantityTemplatetoDatabase(qtyTemplates, geocAlt)
      orbincl_index = AddQuantityTemplateToDatabase(qtyTemplates, orbIncl)
      refGPH_index = AddQuantityTemplateToDatabase(qtyTemplates, refGPH)
      phitanGHz_index = AddQuantityTemplateToDatabase(qtyTemplates, phitanGHz)
      band7_index = AddQuantityTemplateToDatabase(qtyTemplates, band7)
      band2_index = AddQuantityTemplateToDatabase(qtyTemplates, band2)
      band8_index = AddQuantityTemplateToDatabase(qtyTemplates, band8)

      ! The numbers are the order that quantities template were added
      stateSelected = (/temperature_index,o3_index,h2o_index, phitanGHz_index, &
                        ptanGHz_index,geodAlt_index, geocAlt_index, &
                        orbincl_index, gph_index, refGPH_index/)
      stateTemplate = CreateVectorTemplate(qtyTemplates, stateSelected)

      measurementSelected = (/band7_index, band2_index, band8_index/)
      measurementTemplate = CreateVectorTemplate(qtyTemplates, measurementSelected)

      state = CreateVector(stateTemplate, qtyTemplates, name='state')
      measurement = CreateVector(measurementTemplate, qtyTemplates, name='measurement')

      refGPH_vv => GetVectorQtyByTemplateIndex (state, refGPH_index) ! refGPH
      call SpreadFillVectorQuantity (refGPH_vv, refGPHInput) ! unit is meter

      ! supply temperature, GPH, H2O, and O3 data
      temperature_vv => GetVectorQtyByTemplateIndex(state, temperature_index)
      call ExplicitFillVectorQuantity(temperature_vv, TemperatureInput)

      h2o_vv => GetVectorQtyByTemplateIndex(state, h2o_index)
      call ExplicitFillVectorQuantity(h2o_vv, H2OInput)

      quantity => GetVectorQtyByTemplateIndex(state, o3_index)
      call ExplicitFillVectorQuantity(quantity, O3Input)

      quantity => GetVectorQtyByTemplateIndex(state, geodAlt_index)
      call FillVectorQuantityFromL1B(quantity, chunk, filedatabase, .false.)

      ! Fill orbit inclination, tangent geocentric altitude with
      ! data from MLS L1B file, and use them, along with other
      ! quantities to calculate ptan
      orbincl_vv => GetVectorQtyByTemplateIndex (state, orbincl_index)
      call FillVectorQuantityFromL1B(orbincl_vv, chunk, filedatabase, .false.)

      geocAlt_vv => GetVectorQtyByTemplateIndex (state, geocAlt_index)
      call FillVectorQuantityFromL1B(geocAlt_vv, chunk, filedatabase, .false.)

      ptanG_vv => GetVectorQtyByTemplateIndex (state, ptanGHz_index)

      phitan_vv => GetVectorQtyByTemplateIndex (state, phitanGHz_index)
      call FillPhitanQuantity(phitan_vv)

      ! calculate ptan
      !call dump(temperature_vv, details=3)
      call FillPtanQuantity (ptanG_vv, temperature_vv, refGPH_vv, &
                             h2o_vv, orbincl_vv, phitan_vv, geocAlt_vv)

      !call dump(state, details=3)

      ! GPH is filled by the forward model

      !call ForwardModel (chunk, forwardModelConfigDatabase, state, &
      !                   stateExtra, measurement)

      ! Create jacobian
      jacobian = CreatePlainMatrix(measurement, state)

      ! Call the forward model
      call ForwardModel (chunk, forwardModelConfigDatabase, state, &
                         stateExtra, measurement, jacobian)

      !call dump(measurement, details=3)
      !call dump(jacobian, details=3)

      ! Re-supply temperature, GPH, H2O, and O3 data
      call ExplicitFillVectorQuantity(temperature_vv, TemperatureInput2)
      call ExplicitFillVectorQuantity(h2o_vv, H2OInput2)
      quantity => GetVectorQtyByTemplateIndex(state, o3_index)
      call ExplicitFillVectorQuantity(quantity, O3Input2)

      ! Re-calculate ptan
      call FillPtanQuantity (ptanG_vv, temperature_vv, refGPH_vv, &
                             h2o_vv, orbincl_vv, phitan_vv, geocAlt_vv)

      ! call the forward model the second time
      call ForwardModel (chunk, forwardModelConfigDatabase, state, &
                         stateExtra, measurement)
      call dump(measurement, details=3)

      call DestroyMatrix(jacobian)
      call DestroyVectorInfo (state)
      call DestroyVectorInfo (measurement)
      call DestroyVectorTemplateInfo(stateTemplate)
      call DestroyVectorTemplateInfo(measurementTemplate)
      call Destroy_DACS_Filter_Database
      call Destroy_Filter_Shapes_Database
      call Destroy_Ant_Patterns_Database
      call Destroy_SpectCat_Database
      call Destroy_Line_Database
      call Destroy_Pointing_Grid_Database
      call DestroyL2PCDatabase
      call Destroy_PFADataBase

      call CFM_MLSCleanup(filedatabase, qtyTemplates, &
      forwardModelConfigDatabase, stateExtra)
   end subroutine

   subroutine forwardModelWithSingleMAFExample (measurement)
      integer :: i
      type(ForwardModelConfig_T), dimension(:), pointer :: forwardModelConfigDatabase
      type(MLSFile_T), dimension(:), pointer :: filedatabase
      type(MLSChunk_T) :: chunk
      type(VGrid_T) :: vGridStandard, vGridRefGPH
      type(HGrid_T) :: hGridStandard
      type(FGrid_T) :: fGridStandard
      type(QuantityTemplate_T) :: temperature, GPH, H2O, O3, ptanGHz, band7, &
                                  geodAltitude, orbincl, geocAlt, refGPH, band2, &
                                  band8, phitanGHz
      type(QuantityTemplate_T), dimension(:), pointer :: qtyTemplates
      type(VectorTemplate_T) :: stateTemplate, measurementTemplate
      type(Vector_T) :: state, stateExtra
      type(Vector_T), pointer :: measurement
      character(len=3) :: GHz = "GHz"
      character(len=2) :: sc = "sc"
      integer :: stateSelected(10), measurementSelected(3)
      type(VectorValue_T) :: quantity, h2o_vv, orbincl_vv, geocAlt_vv, &
                             ptanG_vv, temperature_vv, refGPH_vv, &
                             phitan_vv
      integer :: temperature_index, h2o_index, band2_index
      integer :: o3_index, ptanGHz_index, band7_index, phitanGHz_index
      integer :: geodAlt_index, orbincl_index, gph_index
      integer :: geocAlt_index, band8_index, refGPH_index
      character(len=256) :: signalFileName, configFileName
      type(Matrix_T) :: jacobian

      call getarg(1, signalFileName)
      call getarg(2, configFileName)

      nullify(qtyTemplates)

      call CFM_MLSSetup(startTime, endTime, l1boa, leapsecFile, signalFileName, &
      configFileName, filedatabase, qtyTemplates, chunk, &
      forwardModelConfigDatabase, stateExtra)

      ! read MLS input data file
      call Read_Spectroscopy (spectroscopy, 'HDF5')
      call ReadAntennaPatterns (antennaPatterns)
      call ReadFilterShapes(filterShapes)
      call ReadDACSFilterShapes (DACSFilterShapes)
      call ReadPointingGrids (pointingGrids)

      do i = 1, size(pfaFiles)
         call ReadPFAFile (pfaFiles(i))
      end do

      do i = 1, size(l2pc)
         call ReadHDF5L2PC (l2pc(i))
      end do

      vGridStandard = CreateVGrid (l_zeta, phyq_pressure, l_logarithmic, &
                                   start=1000.0d0, formula="37:6")

      vGridRefGPH = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
                                 values=(/100.0_r8/))

      ! Have insetoverlaps, and not single
      hGridStandard = CreateRegularHGrid(GHz, 0.0_r8, 1.5_r8, .true., &
                                         filedatabase, chunk)

      fGridStandard = CreateFGrid(L_IntermediateFrequency, (/0.0_r8/))

      temperature = CreateQtyTemplate(l_temperature, filedatabase=filedatabase, &
                                      chunk=chunk, qName='temperature', &
                                      avgrid=vGridStandard, ahgrid=hGridStandard)
      GPH = CreateQtyTemplate(l_gph, filedatabase=filedatabase, chunk=chunk, &
                              avgrid=vGridStandard, ahgrid=hGridStandard, qName='GPH')
      O3 = CreateQtyTemplate(l_vmr, filedatabase=filedatabase, chunk=chunk, &
                             avgrid=vGridStandard, ahgrid=hGridStandard, qMolecule=l_o3, &
                             qName='O3')
      H2O = CreateQtyTemplate(l_vmr, filedatabase=filedatabase, chunk=chunk, &
                              avgrid=vGridStandard, ahgrid=hGridStandard, qMolecule=l_h2o, &
                              qLogBasis=.true., qMinValue=0.1E-6_r8, qName='H2O')
      ptanGHz = CreateQtyTemplate(l_ptan, filedatabase=filedatabase, &
                                  chunk=chunk, qInstModule=GHz, qName='ptanGHz')
      ! band 2,7,8 is the band whose radiances are to be computed
      ! see CFM document for a list of signals corresponding to bands
      band7 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                                qSignal="R3:240.B7F:O3", qName='band7')
      band2 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                                qSignal="R2:190.B2F:H2O", qName='band2')
      band8 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                                qSignal="R3:240.B8F:PT", qName='band8')
      geodAltitude = CreateQtyTemplate(l_tngtgeodalt, filedatabase=filedatabase, &
                                       chunk=chunk, qInstModule=GHz, qName='geodAltitude')
      geocAlt = CreateQtyTemplate(l_tngtgeocalt, filedatabase=filedatabase, &
                                  chunk=chunk, qInstModule=GHz, qName='geocAlt')
      orbincl = CreateQtyTemplate(l_orbitInclination, filedatabase=filedatabase, &
                                  chunk=chunk, qInstModule=sc, qName='orbincl')
      refGPH = CreateQtyTemplate(l_refGPH, avgrid=vGridRefGPH, ahgrid=hGridStandard, qName='refGPH')
      phitanGHz = CreateQtyTemplate(l_phitan, qInstModule="GHz", filedatabase=filedatabase, &
                                    chunk=chunk, qName='phitanGHz')

      ! We no longer need vGrid because the quantity templates have copied it
      call DestroyVGridContents(vGridStandard)
      ! No long need hGrid, fGrid either
      call DestroyHGridContents(hGridStandard)
      call DestroyFGridContents(fGridStandard)

!      temperature_index = AddQuantityTemplateToDatabase(qtyTemplates, temperature)
!      gph_index = AddQuantityTemplateToDatabase(qtyTemplates, GPH)
!      o3_index = AddQuantityTemplateToDatabase(qtyTemplates, O3)
!      h2o_index = AddQuantityTemplateToDatabase(qtyTemplates, H2O)
!      ptanGHz_index = AddQuantityTemplateToDatabase(qtyTemplates, ptanGHz)
!      geodAlt_index = AddQuantityTemplateToDatabase(qtyTemplates, geodAltitude)
!      geocAlt_index = AddQuantityTemplatetoDatabase(qtyTemplates, geocAlt)
!      orbincl_index = AddQuantityTemplateToDatabase(qtyTemplates, orbIncl)
!      refGPH_index = AddQuantityTemplateToDatabase(qtyTemplates, refGPH)
!      phitanGHz_index = AddQuantityTemplateToDatabase(qtyTemplates, phitanGHz)
      band7_index = AddQuantityTemplateToDatabase(qtyTemplates, band7)
      band2_index = AddQuantityTemplateToDatabase(qtyTemplates, band2)
      band8_index = AddQuantityTemplateToDatabase(qtyTemplates, band8)

      ! The numbers are the order that quantities template were added
!      stateSelected = (/temperature_index,o3_index,h2o_index, phitanGHz_index, &
!                        ptanGHz_index,geodAlt_index, geocAlt_index, &
!                        orbincl_index, gph_index, refGPH_index/)
!      stateTemplate = CreateVectorTemplate(qtyTemplates, stateSelected)
!
      measurementSelected = (/band7_index, band2_index, band8_index/)
      measurementTemplate = CreateVectorTemplate(qtyTemplates, measurementSelected)

      state = CreateAgileVector(name='state')
      measurement = CreateVector(measurementTemplate, qtyTemplates, name='measurement')

      refGPH_vv = CreateValue4AgileVector (refGPH, spreadvalue=refGPHInput) ! unit is meter
      call AddValue2Vector(state, refgph_vv)

      quantity = CreateValue4AgileVector (gph)
      call AddValue2Vector(state, quantity)

      ! supply temperature, GPH, H2O, and O3 data
      temperature_vv = CreateValue4AgileVector(temperature, value=TemperatureInput)
      call AddValue2Vector(state, temperature_vv)

      h2o_vv = CreateValue4AgileVector(h2o, value=H2OInput)
      call AddValue2Vector(state, h2o_vv)

      quantity = CreateValue4AgileVector(o3, value=O3Input)
      call AddValue2Vector(state, quantity)

      quantity = CreateValue4AgileVector(geodAltitude)
      call FillVectorQuantityFromL1B(quantity, chunk, filedatabase, .false.)
      call AddValue2Vector(state, quantity)

      ! Fill orbit inclination, tangent geocentric altitude with
      ! data from MLS L1B file, and use them, along with other
      ! quantities to calculate ptan
      orbincl_vv = CreateValue4AgileVector (orbincl)
      call FillVectorQuantityFromL1B(orbincl_vv, chunk, filedatabase, .false.)
      call AddValue2Vector(state, orbincl_vv)

      geocAlt_vv = CreateValue4AgileVector (geocAlt)
      call FillVectorQuantityFromL1B(geocAlt_vv, chunk, filedatabase, .false.)
      call AddValue2Vector(state, geocAlt_vv)

      ptanG_vv = CreateValue4AgileVector (ptanGHz)
      call AddValue2Vector(state, ptanG_vv)

      phitan_vv = CreateValue4AgileVector (phitanGHz)
      call FillPhitanQuantity(phitan_vv)
      call AddValue2Vector(state, phitan_vv)

      ! calculate ptan
      !call dump(temperature_vv, details=3)
      call FillPtanQuantity (ptanG_vv, temperature_vv, refGPH_vv, &
                             h2o_vv, orbincl_vv, phitan_vv, geocAlt_vv)

      !call dump(state, details=3)

      ! GPH is filled by the forward model

      !call ForwardModel (chunk, forwardModelConfigDatabase, state, &
      !                   stateExtra, measurement)

      ! Create jacobian
      jacobian = CreatePlainMatrix(measurement, state)

      ! Call the forward model
      do i = chunk%firstMAFIndex, chunk%lastMAFIndex
         call ForwardModel (chunk, forwardModelConfigDatabase, state, &
                            stateExtra, measurement, jacobian, requestedMAF=(i-chunk%firstMAFIndex))
         call dump(measurement, details=2)
      end do

      !call dump(jacobian, details=3)

      call DestroyMatrix(jacobian)
      call DestroyVectorInfo (state)
      call DestroyVectorInfo (measurement)
      call DestroyVectorTemplateInfo(stateTemplate)
      call DestroyVectorTemplateInfo(measurementTemplate)
      call Destroy_DACS_Filter_Database
      call Destroy_Filter_Shapes_Database
      call Destroy_Ant_Patterns_Database
      call Destroy_SpectCat_Database
      call Destroy_Line_Database
      call Destroy_Pointing_Grid_Database
      call DestroyL2PCDatabase
      call Destroy_PFADataBase

      call CFM_MLSCleanup(filedatabase, qtyTemplates, &
      forwardModelConfigDatabase, stateExtra)

   end subroutine

   subroutine getObservedRadiancesExample (observed, obsPrecision)

      type(Vector_T), pointer :: observed, obsPrecision
      type(Vector_T) :: corrections, correctionNoise, stateExtra
      type(VectorTemplate_T) :: measurementTemplate, correctionTemplate
      integer :: measurementSelected(3), baselineSelected(3)
      integer :: band7_index, band2_index, band8_index
      integer :: baseline7_index, baseline2_index, baseline8_index
      type(QuantityTemplate_T), dimension(:), pointer :: qtyTemplates
      character(len=256) :: signalFileName, configFileName
      type(QuantityTemplate_T) :: band2, band7, band8, baseline2, baseline7, baseline8
      integer :: error
      type(VectorValue_T), pointer :: band2L1BMAFBaseline, band7L1BMAFBaseline, &
                                      band8L1BMAFBaseline, quantity, precQty
      type(ForwardModelConfig_T), dimension(:), pointer :: forwardModelConfigDatabase
      type(MLSFile_T), dimension(:), pointer :: filedatabase
      type(MLSChunk_T) :: chunk
      type(MLSFile_T) :: l1bfile

      call getarg(1, signalFileName)
      call getarg(2, configFileName)

      nullify(qtyTemplates)

      call CFM_MLSSetup(startTime, endTime, l1boa, leapsecFile, signalFileName, &
      configFileName, filedatabase, qtyTemplates, chunk, &
      forwardModelConfigDatabase, stateExtra)

      ! band 2,7,8 is the band whose radiances are to be computed
      ! see CFM document for a list of signals corresponding to bands
      band7 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                                qSignal="R3:240.B7F:O3")
      band2 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                                qSignal="R2:190.B2F:H2O")
      band8 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                                qSignal="R3:240.B8F:PT")

      band7_index = AddQuantityTemplateToDatabase(qtyTemplates, band7)
      band2_index = AddQuantityTemplateToDatabase(qtyTemplates, band2)
      band8_index = AddQuantityTemplateToDatabase(qtyTemplates, band8)

      measurementSelected = (/band7_index, band2_index, band8_index/)
      measurementTemplate = CreateVectorTemplate(qtyTemplates, measurementSelected)

      ! Create an identical vector as simulated radiance vector for observed radiances
      observed = CreateVector(measurementTemplate, qtyTemplates, name='observedRadiance')
      obsPrecision = CreateVector(measurementTemplate, qtyTemplates, name='observedRadiancePrecision')

      ! Open l1brad
      error = InitializeMLSFile(l1bfile, content='l1brad', &
      name=trim(l1brad), shortName='L1BRAD', type=l_hdf, access=DFACC_RDONLY)
      if (error /= 0) &
         call MLSMessage (MLSMSG_Error, moduleName, &
         "Error initializing " // trim(l1brad))

      call mls_openFile(l1bfile, error)
      if (error /= 0 ) &
         call MLSMessage (MLSMSG_Error, moduleName, &
         "Error opening " // trim(l1brad))

      ! Add it to the filedatabase
      error = AddFileToDatabase(filedatabase, l1bfile)

      ! Fill band 2,7,8
      quantity => GetVectorQtyByTemplateIndex(observed, band2_index)
      precQty => GetVectorQtyByTemplateIndex(obsPrecision, band2_index)

      ! However, only band 9 and 25 have BOMask=1
      ! Because these bands have bright object status read from L1BOA file,
      ! we always have to have L1BOA file in the filedatabase.
      ! You have to fill the precision quantity first
      call FillVectorQuantityFromL1B(precQty, chunk, filedatabase, &
      .true.)
      call FillVectorQuantityFromL1B(quantity, chunk, filedatabase, &
      .false., precisionQuantity=precQty)

      quantity => GetVectorQtyByTemplateIndex(observed, band7_index)
      precQty => GetVectorQtyByTemplateIndex(obsPrecision, band7_index)
      call FillVectorQuantityFromL1B(precQty, chunk, filedatabase, &
      .true.)
      call FillVectorQuantityFromL1B(quantity, chunk, filedatabase, &
      .false., precisionQuantity=precQty)

      quantity => GetVectorQtyByTemplateIndex(observed, band8_index)
      precQty => GetVectorQtyByTemplateIndex(obsPrecision, band8_index)
      call FillVectorQuantityFromL1B(precQty, chunk, filedatabase, &
      .true.)
      call FillVectorQuantityFromL1B(quantity, chunk, filedatabase, &
      .false., precisionQuantity=precQty)

      ! For applying baseline corrections
      baseline2 = CreateQtyTemplate(l_L1BMAFBaseline, filedatabase=filedatabase, &
                                    chunk=chunk, qSignal="R2:190.B2F:H2O")
      baseline7 = CreateQtyTemplate(l_L1BMAFBaseline, filedatabase=filedatabase, &
                                    chunk=chunk, qSignal="R3:240.B7F:O3")
      baseline8 = CreateQtyTemplate(l_L1BMAFBaseline, filedatabase=filedatabase, &
                                    chunk=chunk, qSignal="R3:240.B8F:PT")
      baseline2_index = AddQuantityTemplateToDatabase(qtyTemplates, baseline2)
      baseline7_index = AddQuantityTemplateToDatabase(qtyTemplates, baseline7)
      baseline8_index = AddQuantityTemplateToDatabase(qtyTemplates, baseline8)

      baselineSelected = (/baseline2_index, baseline7_index, baseline8_index/)
      correctionTemplate = CreateVectorTemplate(qtyTemplates, baselineSelected)
      corrections = CreateVector(correctionTemplate, qtyTemplates, name='corrections')
      correctionNoise = CreateVector(correctionTemplate, qtyTemplates, name='correctionNoise')

      band2L1BMAFBaseline => GetVectorQtyByTemplateIndex(corrections, baseline2_index)
      band7L1BMAFBaseline => GetVectorQtyByTemplateIndex(corrections, baseline7_index)
      band8L1BMAFBaseline => GetVectorQtyByTemplateIndex(corrections, baseline8_index)
      call FillVectorQuantityFromL1B(band2L1BMAFBaseline, chunk, filedatabase, &
      .false., suffix=' Baseline')
      call FillVectorQuantityFromL1B(band7L1BMAFBaseline, chunk, filedatabase, &
      .false., suffix=' Baseline')
      call FillVectorQuantityFromL1B(band8L1BMAFBaseline, chunk, filedatabase, &
      .false., suffix=' Baseline')

      quantity => GetVectorQtyByTemplateIndex(observed, band2_index)
      call ApplyBaseline(quantity, band2L1BMAFBaseline, .false., .false.)
      quantity => GetVectorQtyByTemplateIndex(observed, band7_index)
      call ApplyBaseline(quantity, band7L1BMAFBaseline, .false., .false.)
      quantity => GetVectorQtyByTemplateIndex(observed, band8_index)
      call ApplyBaseline(quantity, band8L1BMAFBaseline, .false., .false.)

      band2L1BMAFBaseline => GetVectorQtyByTemplateIndex(correctionNoise, baseline2_index)
      band7L1BMAFBaseline => GetVectorQtyByTemplateIndex(correctionNoise, baseline7_index)
      band8L1BMAFBaseline => GetVectorQtyByTemplateIndex(correctionNoise, baseline8_index)
      call FillVectorQuantityFromL1B(band2L1BMAFBaseline, chunk, filedatabase, &
      .false., suffix=' Baseline precision')
      call FillVectorQuantityFromL1B(band7L1BMAFBaseline, chunk, filedatabase, &
      .false., suffix=' Baseline precision')
      call FillVectorQuantityFromL1B(band8L1BMAFBaseline, chunk, filedatabase, &
      .false., suffix=' Baseline precision')

      ! quadrature is true because this is precision
      quantity => GetVectorQtyByTemplateIndex(obsPrecision, band2_index)
      call ApplyBaseline(quantity, band2L1BMAFBaseline, .true., .false.)
      quantity => GetVectorQtyByTemplateIndex(obsPrecision, band7_index)
      call ApplyBaseline(quantity, band7L1BMAFBaseline, .true., .false.)
      quantity => GetVectorQtyByTemplateIndex(obsPrecision, band8_index)
      call ApplyBaseline(quantity, band8L1BMAFBaseline, .true., .false.)

      !call dump(observed, details=3)
      !call dump(obsPrecision, details=3)

      ! Clean up allocated memory for creating observed radiance vector
      call DestroyVectorInfo(observed)
      call DestroyVectorInfo(obsPrecision)
      call DestroyVectorTemplateInfo(measurementTemplate)

      ! Clean up For baseline
      call DestroyVectorInfo(corrections)
      call DestroyVectorInfo(correctionNoise)
      call DestroyVectorTemplateInfo(correctionTemplate)

      ! This subroutine will close all open file in filedatabase
      call CFM_MLSCleanup(filedatabase, qtyTemplates, &
      forwardModelConfigDatabase, stateExtra)
   end subroutine
d457 3
@


1.47
log
@Fix bug in the example
@
text
@d28 1
a28 1
       "$Id: mockup.f90,v 1.46 2010/11/19 17:16:08 honghanh Exp $"
d281 3
a283 3
      type(VectorValue_T), pointer :: quantity, h2o_vv, orbincl_vv, geocAlt_vv, &
                                      ptanG_vv, temperature_vv, refGPH_vv, &
                                      phitan_vv
d364 10
a373 10
      temperature_index = AddQuantityTemplateToDatabase(qtyTemplates, temperature)
      gph_index = AddQuantityTemplateToDatabase(qtyTemplates, GPH)
      o3_index = AddQuantityTemplateToDatabase(qtyTemplates, O3)
      h2o_index = AddQuantityTemplateToDatabase(qtyTemplates, H2O)
      ptanGHz_index = AddQuantityTemplateToDatabase(qtyTemplates, ptanGHz)
      geodAlt_index = AddQuantityTemplateToDatabase(qtyTemplates, geodAltitude)
      geocAlt_index = AddQuantityTemplatetoDatabase(qtyTemplates, geocAlt)
      orbincl_index = AddQuantityTemplateToDatabase(qtyTemplates, orbIncl)
      refGPH_index = AddQuantityTemplateToDatabase(qtyTemplates, refGPH)
      phitanGHz_index = AddQuantityTemplateToDatabase(qtyTemplates, phitanGHz)
d379 5
a383 5
      stateSelected = (/temperature_index,o3_index,h2o_index, phitanGHz_index, &
                        ptanGHz_index,geodAlt_index, geocAlt_index, &
                        orbincl_index, gph_index, refGPH_index/)
      stateTemplate = CreateVectorTemplate(qtyTemplates, stateSelected)

d387 1
a387 1
      state = CreateVector(stateTemplate, qtyTemplates, name='state')
d390 5
a394 2
      refGPH_vv => GetVectorQtyByTemplateIndex (state, refGPH_index) ! refGPH
      call SpreadFillVectorQuantity (refGPH_vv, refGPHInput) ! unit is meter
d397 2
a398 2
      temperature_vv => GetVectorQtyByTemplateIndex(state, temperature_index)
      call ExplicitFillVectorQuantity(temperature_vv, TemperatureInput)
d400 2
a401 2
      h2o_vv => GetVectorQtyByTemplateIndex(state, h2o_index)
      call ExplicitFillVectorQuantity(h2o_vv, H2OInput)
d403 2
a404 2
      quantity => GetVectorQtyByTemplateIndex(state, o3_index)
      call ExplicitFillVectorQuantity(quantity, O3Input)
d406 1
a406 1
      quantity => GetVectorQtyByTemplateIndex(state, geodAlt_index)
d408 1
d413 1
a413 1
      orbincl_vv => GetVectorQtyByTemplateIndex (state, orbincl_index)
d415 1
d417 1
a417 1
      geocAlt_vv => GetVectorQtyByTemplateIndex (state, geocAlt_index)
d419 1
d421 2
a422 1
      ptanG_vv => GetVectorQtyByTemplateIndex (state, ptanGHz_index)
d424 1
a424 1
      phitan_vv => GetVectorQtyByTemplateIndex (state, phitanGHz_index)
d426 1
a632 3
! Revision 1.46  2010/11/19 17:16:08  honghanh
! Add example to use the requestedMAF feature in forward model
!
@


1.46
log
@Add example to use the requestedMAF feature in forward model
@
text
@d28 1
a28 1
       "$Id: mockup.f90,v 1.44 2010/11/03 20:17:01 honghanh Exp $"
d436 1
a436 1
      do i = chunk%firstMAFIndex, chunk%lastMAFIndex + 1
d625 3
@


1.45
log
@New example to run forward model with a single maf
@
text
@d267 1
a267 1
      type(MLSChunk_T) :: chunk, cSingle
a314 2
      cSingle = chunk

d321 4
d327 37
a363 1
      ! Place dummy quantities in the database
d382 2
d385 1
d387 29
a415 3
      do i = chunk%firstMAFIndex, chunk%lastMAFIndex + 1
         cSingle%firstMAFIndex = i
         cSingle%lastMAFIndex = i
d417 2
a418 91
         ! Have insetoverlaps, and not single
         hGridStandard = CreateRegularHGrid(GHz, 0.0_r8, 1.5_r8, .true., &
                                            filedatabase, cSingle)
         temperature = CreateQtyTemplate(l_temperature, filedatabase=filedatabase, &
                                         chunk=cSingle, qName='temperature', &
                                         avgrid=vGridStandard, ahgrid=hGridStandard)
         GPH = CreateQtyTemplate(l_gph, filedatabase=filedatabase, chunk=cSingle, &
                                 avgrid=vGridStandard, ahgrid=hGridStandard, qName='GPH')
         O3 = CreateQtyTemplate(l_vmr, filedatabase=filedatabase, chunk=cSingle, &
                                avgrid=vGridStandard, ahgrid=hGridStandard, qMolecule=l_o3, &
                                qName='O3')
         H2O = CreateQtyTemplate(l_vmr, filedatabase=filedatabase, chunk=cSingle, &
                                 avgrid=vGridStandard, ahgrid=hGridStandard, qMolecule=l_h2o, &
                                 qLogBasis=.true., qMinValue=0.1E-6_r8, qName='H2O')
         ptanGHz = CreateQtyTemplate(l_ptan, filedatabase=filedatabase, &
                                     chunk=cSingle, qInstModule=GHz, qName='ptanGHz')
         ! band 2,7,8 is the band whose radiances are to be computed
         ! see CFM document for a list of signals corresponding to bands
         band7 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=cSingle, &
                                   qSignal="R3:240.B7F:O3", qName='band7')
         band2 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=cSingle, &
                                   qSignal="R2:190.B2F:H2O", qName='band2')
         band8 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=cSingle, &
                                   qSignal="R3:240.B8F:PT", qName='band8')
         geodAltitude = CreateQtyTemplate(l_tngtgeodalt, filedatabase=filedatabase, &
                                          chunk=cSingle, qInstModule=GHz, qName='geodAltitude')
         geocAlt = CreateQtyTemplate(l_tngtgeocalt, filedatabase=filedatabase, &
                                     chunk=cSingle, qInstModule=GHz, qName='geocAlt')
         orbincl = CreateQtyTemplate(l_orbitInclination, filedatabase=filedatabase, &
                                     chunk=cSingle, qInstModule=sc, qName='orbincl')
         refGPH = CreateQtyTemplate(l_refGPH, avgrid=vGridRefGPH, ahgrid=hGridStandard, qName='refGPH')
         phitanGHz = CreateQtyTemplate(l_phitan, qInstModule="GHz", filedatabase=filedatabase, &
                                       chunk=cSingle, qName='phitanGHz')

         ! No long need hGrid, fGrid either
         call DestroyHGridContents(hGridStandard)

         ! replace dummy with actual, new quantities
         qtyTemplates(temperature_index) = temperature
         qtyTemplates(gph_index) = GPH
         qtyTemplates(o3_index) = O3
         qtyTemplates(h2o_index) = H2O
         qtyTemplates(ptanGHz_index) = ptanGHz
         qtyTemplates(geodAlt_index) = geodAltitude
         qtyTemplates(geocAlt_index) = geocAlt
         qtyTemplates(orbincl_index) = orbIncl
         qtyTemplates(refGPH_index) = refGPH
         qtyTemplates(phitanGHz_index) = phitanGHz
         qtyTemplates(band7_index) = band7
         qtyTemplates(band2_index) = band2
         qtyTemplates(band8_index) = band8

         stateTemplate = CreateVectorTemplate(qtyTemplates, stateSelected)
         measurementTemplate = CreateVectorTemplate(qtyTemplates, measurementSelected)
         state = CreateVector(stateTemplate, qtyTemplates, name='state')
         measurement = CreateVector(measurementTemplate, qtyTemplates, name='measurement')

         refGPH_vv => GetVectorQtyByTemplateIndex (state, refGPH_index) ! refGPH
         call SpreadFillVectorQuantity (refGPH_vv, refGPHInput) ! unit is meter

         ! supply temperature, GPH, H2O, and O3 data
         temperature_vv => GetVectorQtyByTemplateIndex(state, temperature_index)
         call ExplicitFillVectorQuantity(temperature_vv, TemperatureInput)

         h2o_vv => GetVectorQtyByTemplateIndex(state, h2o_index)
         call ExplicitFillVectorQuantity(h2o_vv, H2OInput)

         quantity => GetVectorQtyByTemplateIndex(state, o3_index)
         call ExplicitFillVectorQuantity(quantity, O3Input)

         quantity => GetVectorQtyByTemplateIndex(state, geodAlt_index)
         call FillVectorQuantityFromL1B(quantity, cSingle, filedatabase, .false.)

         ! Fill orbit inclination, tangent geocentric altitude with
         ! data from MLS L1B file, and use them, along with other
         ! quantities to calculate ptan
         orbincl_vv => GetVectorQtyByTemplateIndex (state, orbincl_index)
         call FillVectorQuantityFromL1B(orbincl_vv, cSingle, filedatabase, .false.)

         geocAlt_vv => GetVectorQtyByTemplateIndex (state, geocAlt_index)
         call FillVectorQuantityFromL1B(geocAlt_vv, cSingle, filedatabase, .false.)

         ptanG_vv => GetVectorQtyByTemplateIndex (state, ptanGHz_index)

         phitan_vv => GetVectorQtyByTemplateIndex (state, phitanGHz_index)
         call FillPhitanQuantity(phitan_vv)

         ! calculate ptan
         !call dump(temperature_vv, details=3)
         call FillPtanQuantity (ptanG_vv, temperature_vv, refGPH_vv, &
                                h2o_vv, orbincl_vv, phitan_vv, geocAlt_vv)
d420 4
a423 1
         !call dump(state, details=3)
d425 1
a425 1
         ! GPH is filled by the forward model
d427 1
a427 2
         ! Create jacobian
         jacobian = CreatePlainMatrix(measurement, state)
d429 2
a430 3
         ! Call the forward model
         call ForwardModel (chunk, forwardModelConfigDatabase, state, &
                            stateExtra, measurement, jacobian)
d432 2
a433 2
         call dump(measurement, details=3)
         !call dump(jacobian, details=3)
d435 5
a439 3
         call DestroyMatrix(jacobian)
         call DestroyVectorInfo (state)
         call DestroyVectorInfo (measurement)
d442 1
a442 3
      ! We no longer need vGrid because the quantity templates have copied it
      call DestroyVGridContents(vGridStandard)
      call DestroyFGridContents(fGridStandard)
d444 3
@


1.44
log
@Add name as an optional argument to CreateVector.
@
text
@d28 1
a28 1
       "$Id: mockup.f90,v 1.42 2010/09/28 14:42:42 honghanh Exp $"
d39 2
a40 2
   call forwardModelExample(pMeasurement)
   call getObservedRadiancesExample (pObserved, pObsPrecision)
d82 2
d245 1
d263 218
d503 2
d643 3
@


1.43
log
@Add qName as an optional argument to CreateQtyTemplate.
This is to help debugging process.
@
text
@d173 2
a174 2
      state = CreateVector(stateTemplate, qtyTemplates)
      measurement = CreateVector(measurementTemplate, qtyTemplates)
d303 2
a304 2
      observed = CreateVector(measurementTemplate, qtyTemplates)
      obsPrecision = CreateVector(measurementTemplate, qtyTemplates)
d361 2
a362 2
      corrections = CreateVector(correctionTemplate, qtyTemplates)
      correctionNoise = CreateVector(correctionTemplate, qtyTemplates)
@


1.42
log
@Add call to forwardModel with jacobian
@
text
@d28 1
a28 1
       "$Id: mockup.f90,v 1.39 2010/08/06 14:15:06 honghanh Exp $"
d114 1
a114 1
                                      chunk=chunk, &
d117 1
a117 1
                              avgrid=vGridStandard, ahgrid=hGridStandard)
d119 2
a120 1
                             avgrid=vGridStandard, ahgrid=hGridStandard, qMolecule=l_o3)
d123 1
a123 1
                              qLogBasis=.true., qMinValue=0.1E-6_r8)
d125 1
a125 1
                                  chunk=chunk, qInstModule=GHz)
d129 1
a129 1
                                qSignal="R3:240.B7F:O3")
d131 1
a131 1
                                qSignal="R2:190.B2F:H2O")
d133 1
a133 1
                                qSignal="R3:240.B8F:PT")
d135 1
a135 1
                                       chunk=chunk, qInstModule=GHz)
d137 1
a137 1
                                  chunk=chunk, qInstModule=GHz)
d139 2
a140 2
                                  chunk=chunk, qInstModule=sc)
      refGPH = CreateQtyTemplate(l_refGPH, avgrid=vGridRefGPH, ahgrid=hGridStandard)
d142 1
a142 1
                                    chunk=chunk)
d211 2
d226 1
a226 1
      call dump(jacobian, details=3)
d241 1
a241 1
      !call dump(measurement, details=3)
d420 3
@


1.41
log
@Give an example of calling the forward model multiple times
@
text
@d212 2
a213 2
      call ForwardModel (chunk, forwardModelConfigDatabase, state, &
                         stateExtra, measurement)
d216 1
a216 1
      !jacobian = CreatePlainMatrix(measurement, state)
d219 2
a220 2
      !call ForwardModel (chunk, forwardModelConfigDatabase, state, &
      !                   stateExtra, measurement, jacobian)
d222 2
a223 1
      call dump(measurement, details=3)
d238 1
a238 1
      call dump(measurement, details=3)
d396 2
a397 2
      call dump(observed, details=3)
      call dump(obsPrecision, details=3)
@


1.40
log
@Separate the running forward model example and reading observed radiance example
@
text
@d70 2
a71 1
                                      ptanG_vv, temperature_vv, refGPH_vv
d202 2
a203 2
      quantity => GetVectorQtyByTemplateIndex (state, phitanGHz_index)
      call FillPhitanQuantity(quantity)
d208 1
a208 1
                             h2o_vv, orbincl_vv, quantity, geocAlt_vv)
d224 15
@


1.39
log
@Call dump on diff vector instead of measurement vector.
@
text
@a16 1
   use input   ! Provides hard-coded input for testing purposes only
d18 2
a19 32
   use CFM, only: & ! Alphabetized, case-insensitive list (underscores are ignored though)
      AddFileToDatabase, AddQuantityTemplateToDatabase, ApplyBaseline, &
      CFM_MLSCleanup, CFM_MLSSetup, CreateFGrid, CreatePlainMatrix, &
      CreateQtyTemplate, CreateRegularHGrid, CreateVector, &
      CreateVectorTemplate, CreateVGrid, &
      Destroy_Ant_Patterns_Database, DestroyFGridContents, &
      Destroy_DACS_Filter_Database, Destroy_Filter_Shapes_Database, &
      DestroyHGridContents, DestroyL2PCDatabase, Destroy_Line_Database, &
      Destroy_PFADataBase, Destroy_Pointing_Grid_Database, &
      DestroyQuantityTemplateDatabase, Destroy_SpectCat_Database, &
      DestroyVectorInfo, DestroyVectorTemplateInfo, DestroyVGridContents, &
      DFACC_RDONLY, Dump, &
      ExplicitFillVectorQuantity, &
      FGrid_T, FillPhitanQuantity, FillPtanQuantity, &
      FillVectorQuantityFromL1B, ForwardModel, ForwardModelConfig_T, &
      FORWARDMODELSTATUS_T, &
      GetMLSFileByType, GetVectorQtyByTemplateIndex, &
      HGrid_T, &
      InitializeMLSFile, &
      l_explicit, l_gph, l_h2o, l_hdf, L_IntermediateFrequency, &
      l_logarithmic, l_o3, l_orbitInclination, l_phitan, l_ptan, &
      l_radiance, l_refGPH, l_temperature, l_tngtgeocalt, &
      l_tngtgeodalt, l_vmr, l_zeta, l_l1bMAFBaseline, &
      Matrix_T, MLSChunk_T, MLSFile_T, MLSMessage, MLSMSG_Error, &
      mls_openFile, &
      operator(+), operator(-), &
      phyq_angle, phyq_pressure, &
      QuantityTemplate_T, &
      r8, ReadAntennaPatterns, ReadDACSFilterShapes, ReadFilterShapes, &
      ReadHDF5L2PC, ReadPFAFile, ReadPointingGrids, Read_Spectroscopy, &
      SpreadFillVectorQuantity, &
      Vector_T, VectorTemplate_T, VectorValue_T, VGrid_T
d28 1
a28 1
       "$Id: mockup.f90,v 1.38 2010/08/05 16:23:03 honghanh Exp $"
d32 2
a33 315
   integer :: error, i
   type(ForwardModelConfig_T), dimension(:), pointer :: forwardModelConfigDatabase
   type(MLSFile_T), dimension(:), pointer :: filedatabase
   type(MLSChunk_T) :: chunk
   type(VGrid_T) :: vGridStandard, vGridRefGPH
   type(HGrid_T) :: hGridStandard
   type(FGrid_T) :: fGridStandard
   type(QuantityTemplate_T) :: temperature, GPH, H2O, O3, ptanGHz, band7, &
                               geodAltitude, orbincl, geocAlt, refGPH, band2, &
                               band8, phitanGHz, baseline7, baseline2, baseline8
   type(QuantityTemplate_T), dimension(:), pointer :: qtyTemplates
   type(VectorTemplate_T) :: stateTemplate, measurementTemplate, correctionTemplate
   type(Vector_T) :: state, measurement, stateExtra, observed, obsPrecision
   type(Vector_T) :: diffVector, corrections, correctionNoise
   character(len=3) :: GHz = "GHz"
   character(len=2) :: sc = "sc"
   integer :: stateSelected(10), measurementSelected(3), baselineSelected(3)
   type(VectorValue_T), pointer :: quantity, h2o_vv, orbincl_vv, geocAlt_vv, &
                          ptanG_vv, temperature_vv, refGPH_vv, precQty
   type(VectorValue_T), pointer :: band2L1BMAFBaseline, band7L1BMAFBaseline, band8L1BMAFBaseline
   integer :: temperature_index, h2o_index, band2_index
   integer :: o3_index, ptanGHz_index, band7_index, phitanGHz_index
   integer :: geodAlt_index, orbincl_index, gph_index
   integer :: geocAlt_index, band8_index, refGPH_index
   integer :: baseline7_index, baseline2_index, baseline8_index
   character(len=256) :: signalFileName, configFileName
   type (MLSFile_T) :: l1bfile
   type(Matrix_T) :: jacobian

   call getarg(1, signalFileName)
   call getarg(2, configFileName)

   call CFM_MLSSetup(startTime, endTime, l1boa, leapsecFile, signalFileName, &
   configFileName, filedatabase, qtyTemplates, chunk, &
   forwardModelConfigDatabase, stateExtra)

   ! read MLS input data file
   call Read_Spectroscopy (spectroscopy, 'HDF5')
   call ReadAntennaPatterns (antennaPatterns)
   call ReadFilterShapes(filterShapes)
   call ReadDACSFilterShapes (DACSFilterShapes)
   call ReadPointingGrids (pointingGrids)

   do i = 1, size(pfaFiles)
      call ReadPFAFile (pfaFiles(i))
   end do

   do i = 1, size(l2pc)
      call ReadHDF5L2PC (l2pc(i))
   end do

   vGridStandard = CreateVGrid (l_zeta, phyq_pressure, l_logarithmic, &
                                start=1000.0d0, formula="37:6")
   !call dump(vGridStandard, details=2)

   vGridRefGPH = CreateVGrid (l_zeta, phyq_pressure, l_explicit, &
                              values=(/100.0_r8/))

   ! Have insetoverlaps, and not single
   hGridStandard = CreateRegularHGrid(GHz, 0.0_r8, 1.5_r8, .true., &
        filedatabase, chunk)
   !call dump(hGridStandard)

   fGridStandard = CreateFGrid(L_IntermediateFrequency, (/0.0_r8/))
   !call dump(fGridStandard)

   temperature = CreateQtyTemplate(l_temperature, filedatabase=filedatabase, &
                                   chunk=chunk, &
                                   avgrid=vGridStandard, ahgrid=hGridStandard)
   GPH = CreateQtyTemplate(l_gph, filedatabase=filedatabase, chunk=chunk, &
                           avgrid=vGridStandard, ahgrid=hGridStandard)
   O3 = CreateQtyTemplate(l_vmr, filedatabase=filedatabase, chunk=chunk, &
                          avgrid=vGridStandard, ahgrid=hGridStandard, qMolecule=l_o3)
   H2O = CreateQtyTemplate(l_vmr, filedatabase=filedatabase, chunk=chunk, &
                           avgrid=vGridStandard, ahgrid=hGridStandard, qMolecule=l_h2o, &
                           qLogBasis=.true., qMinValue=0.1E-6_r8)
   ptanGHz = CreateQtyTemplate(l_ptan, filedatabase=filedatabase, &
                               chunk=chunk, qInstModule=GHz)
   ! band 2,7,8 is the band whose radiances are to be computed
   ! see CFM document for a list of signals corresponding to bands
   band7 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                             qSignal="R3:240.B7F:O3")
   band2 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                             qSignal="R2:190.B2F:H2O")
   band8 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=chunk, &
                             qSignal="R3:240.B8F:PT")
   geodAltitude = CreateQtyTemplate(l_tngtgeodalt, filedatabase=filedatabase, &
                                    chunk=chunk, qInstModule=GHz)
   geocAlt = CreateQtyTemplate(l_tngtgeocalt, filedatabase=filedatabase, &
                               chunk=chunk, qInstModule=GHz)
   orbincl = CreateQtyTemplate(l_orbitInclination, filedatabase=filedatabase, &
                               chunk=chunk, qInstModule=sc)
   refGPH = CreateQtyTemplate(l_refGPH, avgrid=vGridRefGPH, ahgrid=hGridStandard)
   phitanGHz = CreateQtyTemplate(l_phitan, qInstModule="GHz", filedatabase=filedatabase, &
                                 chunk=chunk)

   temperature_index = AddQuantityTemplateToDatabase(qtyTemplates, temperature)
   gph_index = AddQuantityTemplateToDatabase(qtyTemplates, GPH)
   o3_index = AddQuantityTemplateToDatabase(qtyTemplates, O3)
   h2o_index = AddQuantityTemplateToDatabase(qtyTemplates, H2O)
   ptanGHz_index = AddQuantityTemplateToDatabase(qtyTemplates, ptanGHz)
   geodAlt_index = AddQuantityTemplateToDatabase(qtyTemplates, geodAltitude)
   geocAlt_index = AddQuantityTemplatetoDatabase(qtyTemplates, geocAlt)
   orbincl_index = AddQuantityTemplateToDatabase(qtyTemplates, orbIncl)
   refGPH_index = AddQuantityTemplateToDatabase(qtyTemplates, refGPH)
   phitanGHz_index = AddQuantityTemplateToDatabase(qtyTemplates, phitanGHz)
   band7_index = AddQuantityTemplateToDatabase(qtyTemplates, band7)
   band2_index = AddQuantityTemplateToDatabase(qtyTemplates, band2)
   band8_index = AddQuantityTemplateToDatabase(qtyTemplates, band8)

   ! We no longer need vGrid because the quantity templates have copied it
   call DestroyVGridContents(vGridStandard)
   ! No long need hGrid, fGrid either
   call DestroyHGridContents(hGridStandard)
   call DestroyFGridContents(fGridStandard)

!   call dump(ptanGHz, details=2)
!   call dump(ptanTHz, details=2)
!   call dump(temperature, details=2)
!   call dump(GPH, details=2)
!   call dump(O3, details=2)
!   call dump(H2O, details=2)
!   call dump(band7, details=2)
!   call dump(geodAltitude, details=2)

   ! The numbers are the order that quantities template were added
   stateSelected = (/temperature_index,o3_index,h2o_index, phitanGHz_index, &
                     ptanGHz_index,geodAlt_index, geocAlt_index, &
                     orbincl_index, gph_index, refGPH_index/)
   stateTemplate = CreateVectorTemplate(qtyTemplates, stateSelected)
!   call dump(stateTemplate, details=2, quantities=qtyTemplates)

   measurementSelected = (/band7_index, band2_index, band8_index/)
   measurementTemplate = CreateVectorTemplate(qtyTemplates, measurementSelected)
!   call dump(measurementTemplate, details=2, quantities=qtyTemplates)

   state = CreateVector(stateTemplate, qtyTemplates)
   measurement = CreateVector(measurementTemplate, qtyTemplates)

   refGPH_vv => GetVectorQtyByTemplateIndex (state, refGPH_index) ! refGPH
   call SpreadFillVectorQuantity (refGPH_vv, refGPHInput) ! unit is meter

   ! supply temperature, GPH, H2O, and O3 data
   temperature_vv => GetVectorQtyByTemplateIndex(state, temperature_index)
   call ExplicitFillVectorQuantity(temperature_vv, TemperatureInput)

   h2o_vv => GetVectorQtyByTemplateIndex(state, h2o_index)
   call ExplicitFillVectorQuantity(h2o_vv, H2OInput)

   quantity => GetVectorQtyByTemplateIndex(state, o3_index)
   call ExplicitFillVectorQuantity(quantity, O3Input)

   quantity => GetVectorQtyByTemplateIndex(state, geodAlt_index)
   call FillVectorQuantityFromL1B(quantity, chunk, filedatabase, &
      .false.)

   ! Fill orbit inclination, tangent geocentric altitude with
   ! data from MLS L1B file, and use them, along with other
   ! quantities to calculate ptan
   orbincl_vv => GetVectorQtyByTemplateIndex (state, orbincl_index)
   call FillVectorQuantityFromL1B(orbincl_vv, chunk, filedatabase, &
      .false.)

   geocAlt_vv => GetVectorQtyByTemplateIndex (state, geocAlt_index)
   call FillVectorQuantityFromL1B(geocAlt_vv, chunk, filedatabase, &
      .false.)

   ptanG_vv => GetVectorQtyByTemplateIndex (state, ptanGHz_index)

   quantity => GetVectorQtyByTemplateIndex (state, phitanGHz_index)
   call FillPhitanQuantity(quantity)

   ! calculate ptan
   !call dump(temperature_vv, details=3)
   call FillPtanQuantity (ptanG_vv, temperature_vv, refGPH_vv, &
                          h2o_vv, orbincl_vv, quantity, geocAlt_vv)

   ! GPH is filled by the forward model

   ! Create jacobian
   jacobian = CreatePlainMatrix(measurement, state)

   ! Call the forward model
   call ForwardModel (chunk, forwardModelConfigDatabase, state, &
                      stateExtra, measurement, jacobian)

   !call dump(measurement, details=3)

   ! Create an identical vector as simulated radiance vector for observed radiances
   observed = CreateVector(measurementTemplate, qtyTemplates)
   obsPrecision = CreateVector(measurementTemplate, qtyTemplates)

   ! Open l1brad
   error = InitializeMLSFile(l1bfile, content='l1brad', &
   name=trim(l1brad), shortName='L1BRAD', type=l_hdf, access=DFACC_RDONLY)
   if (error /= 0) &
      call MLSMessage (MLSMSG_Error, moduleName, &
      "Error initializing " // trim(l1brad))

   call mls_openFile(l1bfile, error)
   if (error /= 0 ) &
      call MLSMessage (MLSMSG_Error, moduleName, &
      "Error opening " // trim(l1brad))

   ! Add it to the filedatabase
   error = AddFileToDatabase(filedatabase, l1bfile)

   ! Fill band 2,7,8
   quantity => GetVectorQtyByTemplateIndex(observed, band2_index)
   precQty => GetVectorQtyByTemplateIndex(obsPrecision, band2_index)

   ! However, only band 9 and 25 have BOMask=1
   ! Because these bands have bright object status read from L1BOA file,
   ! we always have to have L1BOA file in the filedatabase.
   ! You have to fill the precision quantity first
   call FillVectorQuantityFromL1B(precQty, chunk, filedatabase, &
   .true.)
   call FillVectorQuantityFromL1B(quantity, chunk, filedatabase, &
   .false., precisionQuantity=precQty)

   quantity => GetVectorQtyByTemplateIndex(observed, band7_index)
   precQty => GetVectorQtyByTemplateIndex(obsPrecision, band7_index)
   call FillVectorQuantityFromL1B(precQty, chunk, filedatabase, &
   .true.)
   call FillVectorQuantityFromL1B(quantity, chunk, filedatabase, &
   .false., precisionQuantity=precQty)

   quantity => GetVectorQtyByTemplateIndex(observed, band8_index)
   precQty => GetVectorQtyByTemplateIndex(obsPrecision, band8_index)
   call FillVectorQuantityFromL1B(precQty, chunk, filedatabase, &
   .true.)
   call FillVectorQuantityFromL1B(quantity, chunk, filedatabase, &
   .false., precisionQuantity=precQty)

   ! For applying baseline corrections
   baseline2 = CreateQtyTemplate(l_L1BMAFBaseline, filedatabase=filedatabase, &
                                 chunk=chunk, qSignal="R2:190.B2F:H2O")
   baseline7 = CreateQtyTemplate(l_L1BMAFBaseline, filedatabase=filedatabase, &
                                 chunk=chunk, qSignal="R3:240.B7F:O3")
   baseline8 = CreateQtyTemplate(l_L1BMAFBaseline, filedatabase=filedatabase, &
                                 chunk=chunk, qSignal="R3:240.B8F:PT")
   baseline2_index = AddQuantityTemplateToDatabase(qtyTemplates, baseline2)
   baseline7_index = AddQuantityTemplateToDatabase(qtyTemplates, baseline7)
   baseline8_index = AddQuantityTemplateToDatabase(qtyTemplates, baseline8)
   baselineSelected = (/baseline2_index, baseline7_index, baseline8_index/)
   correctionTemplate = CreateVectorTemplate(qtyTemplates, baselineSelected)
   corrections = CreateVector(correctionTemplate, qtyTemplates)
   correctionNoise = CreateVector(correctionTemplate, qtyTemplates)

   band2L1BMAFBaseline => GetVectorQtyByTemplateIndex(corrections, baseline2_index)
   band7L1BMAFBaseline => GetVectorQtyByTemplateIndex(corrections, baseline7_index)
   band8L1BMAFBaseline => GetVectorQtyByTemplateIndex(corrections, baseline8_index)
   call FillVectorQuantityFromL1B(band2L1BMAFBaseline, chunk, filedatabase, &
   .false., suffix=' Baseline')
   call FillVectorQuantityFromL1B(band7L1BMAFBaseline, chunk, filedatabase, &
   .false., suffix=' Baseline')
   call FillVectorQuantityFromL1B(band8L1BMAFBaseline, chunk, filedatabase, &
   .false., suffix=' Baseline')

   quantity => GetVectorQtyByTemplateIndex(observed, band2_index)
   call ApplyBaseline(quantity, band2L1BMAFBaseline, .false., .false.)
   quantity => GetVectorQtyByTemplateIndex(observed, band7_index)
   call ApplyBaseline(quantity, band7L1BMAFBaseline, .false., .false.)
   quantity => GetVectorQtyByTemplateIndex(observed, band8_index)
   call ApplyBaseline(quantity, band8L1BMAFBaseline, .false., .false.)

   band2L1BMAFBaseline => GetVectorQtyByTemplateIndex(correctionNoise, baseline2_index)
   band7L1BMAFBaseline => GetVectorQtyByTemplateIndex(correctionNoise, baseline7_index)
   band8L1BMAFBaseline => GetVectorQtyByTemplateIndex(correctionNoise, baseline8_index)
   call FillVectorQuantityFromL1B(band2L1BMAFBaseline, chunk, filedatabase, &
   .false., suffix=' Baseline precision')
   call FillVectorQuantityFromL1B(band7L1BMAFBaseline, chunk, filedatabase, &
   .false., suffix=' Baseline precision')
   call FillVectorQuantityFromL1B(band8L1BMAFBaseline, chunk, filedatabase, &
   .false., suffix=' Baseline precision')

   ! quadrature is true because this is precision
   quantity => GetVectorQtyByTemplateIndex(obsPrecision, band2_index)
   call ApplyBaseline(quantity, band2L1BMAFBaseline, .true., .false.)
   quantity => GetVectorQtyByTemplateIndex(obsPrecision, band7_index)
   call ApplyBaseline(quantity, band7L1BMAFBaseline, .true., .false.)
   quantity => GetVectorQtyByTemplateIndex(obsPrecision, band8_index)
   call ApplyBaseline(quantity, band8L1BMAFBaseline, .true., .false.)

   ! CFM_MLSCleanup will close all files in the filedatabase

   diffVector = observed - measurement

   call dump(diffVector, details=3)

   ! Clean up allocated memory for creating observed radiance vector
   call DestroyVectorInfo(observed)
   call DestroyVectorInfo(obsPrecision)
   ! the subtraction create internal field for diffVector
   ! and we need to clean that up
   call DestroyVectorInfo(diffVector)

   ! Clean up For baseline
   call DestroyVectorInfo(corrections)
   call DestroyVectorInfo(correctionNoise)
   call DestroyVectorTemplateInfo(correctionTemplate)

   ! Clean up memory
   call DestroyVectorInfo (state)
   call DestroyVectorInfo (measurement)
   call DestroyVectorTemplateInfo(stateTemplate)
   call DestroyVectorTemplateInfo(measurementTemplate)
   call Destroy_DACS_Filter_Database
   call Destroy_Filter_Shapes_Database
   call Destroy_Ant_Patterns_Database
   call Destroy_SpectCat_Database
   call Destroy_Line_Database
   call Destroy_Pointing_Grid_Database
   call DestroyL2PCDatabase
   call Destroy_PFADataBase
d35 361
a395 2
   call CFM_MLSCleanup(filedatabase, qtyTemplates, &
   forwardModelConfigDatabase, stateExtra)
d400 3
a419 1
!
@


1.38
log
@Added Jacobian to forwardModel subroutine
@
text
@d59 1
a59 1
       "$Id: mockup.f90,v 1.36 2010/07/08 21:39:16 honghanh Exp $"
d249 1
a249 1
   call dump(measurement, details=3)
d351 1
a351 1
   !call dump(diffVector, details=3)
d385 3
@


1.37
log
@Print diffVector instead of obsPrecision vector
@
text
@d21 3
a23 2
      CFM_MLSCleanup, CFM_MLSSetup, CreateFGrid, CreateQtyTemplate, &
      CreateRegularHGrid, CreateVector, CreateVectorTemplate, CreateVGrid, &
d42 2
a43 1
      MLSChunk_T, MLSFile_T, MLSMessage, MLSMSG_Error, mls_openFile, &
d90 1
d242 3
d247 1
a247 1
                      stateExtra, measurement)
d249 1
a249 1
   !call dump(measurement, details=3)
d351 1
a351 1
   call dump(diffVector, details=3)
@


1.36
log
@Add ApplyBaseline to cfm_fill_m
@
text
@d57 1
a57 1
       "$Id: mockup.f90,v 1.34 2010/06/29 17:02:47 honghanh Exp $"
a342 2
   call dump(obsPrecision, details=3)

d345 1
a345 1
    !call dump(diffVector, details=3)
d379 3
@


1.35
log
@Add vector subtraction interface to subtract simulated radiance from
observed radiance
@
text
@d20 1
a20 1
      AddFileToDatabase, AddQuantityTemplateToDatabase, &
d40 1
a40 1
      l_tngtgeodalt, l_vmr, l_zeta, &
d70 1
a70 1
                               band8, phitanGHz
d72 1
a72 1
   type(VectorTemplate_T) :: stateTemplate, measurementTemplate
d74 1
a74 1
   type(Vector_T) :: diffVector
d77 1
a77 1
   integer :: stateSelected(10), measurementSelected(3)
d80 1
d85 1
d243 1
a243 1
!   call dump(measurement, details=3)
d291 50
d343 1
a343 1
!   call dump(observed, details=3)
d345 1
a345 1
    diffVector = observed - measurement
d347 1
a347 1
    call dump(diffVector, details=3)
d356 5
@


1.34
log
@Change the identifier 'fakeChunk' to 'chunk' because
since it is created with ChunkDivide, it's as real as a chunk
can get.
@
text
@d42 1
d57 1
a57 1
       "$Id: mockup.f90,v 1.33 2010/06/29 15:29:33 honghanh Exp $"
d74 1
d241 1
a241 1
   call dump(measurement, details=3)
d293 4
d300 3
d324 5
@


1.33
log
@Develop FillPtanQuantity to compute ptan, instead of using
Get2DHydrostaticTangentPressure
@
text
@d56 1
a56 1
       "$Id: mockup.f90,v 1.32 2010/06/29 02:28:17 honghanh Exp $"
d63 1
a63 1
   type(MLSChunk_T) :: fakeChunk
d89 1
a89 1
   configFileName, filedatabase, qtyTemplates, fakeChunk, &
d116 1
a116 1
        filedatabase, fakeChunk)
d123 1
a123 1
                                   chunk=fakeChunk, &
d125 1
a125 1
   GPH = CreateQtyTemplate(l_gph, filedatabase=filedatabase, chunk=fakeChunk, &
d127 1
a127 1
   O3 = CreateQtyTemplate(l_vmr, filedatabase=filedatabase, chunk=fakeChunk, &
d129 1
a129 1
   H2O = CreateQtyTemplate(l_vmr, filedatabase=filedatabase, chunk=fakeChunk, &
d133 1
a133 1
                               chunk=fakeChunk, qInstModule=GHz)
d136 1
a136 1
   band7 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=fakeChunk, &
d138 1
a138 1
   band2 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=fakeChunk, &
d140 1
a140 1
   band8 = CreateQtyTemplate(l_radiance, filedatabase=filedatabase, chunk=fakeChunk, &
d143 1
a143 1
                                    chunk=fakeChunk, qInstModule=GHz)
d145 1
a145 1
                               chunk=fakeChunk, qInstModule=GHz)
d147 1
a147 1
                               chunk=fakeChunk, qInstModule=sc)
d150 1
a150 1
                                 chunk=fakeChunk)
d209 1
a209 1
   call FillVectorQuantityFromL1B(quantity, fakeChunk, filedatabase, &
d216 1
a216 1
   call FillVectorQuantityFromL1B(orbincl_vv, fakeChunk, filedatabase, &
d220 1
a220 1
   call FillVectorQuantityFromL1B(geocAlt_vv, fakeChunk, filedatabase, &
d236 1
a236 1
   call ForwardModel (fakeChunk, forwardModelConfigDatabase, state, &
d268 1
a268 1
   call FillVectorQuantityFromL1B(precQty, fakeChunk, filedatabase, &
d270 1
a270 1
   call FillVectorQuantityFromL1B(quantity, fakeChunk, filedatabase, &
d275 1
a275 1
   call FillVectorQuantityFromL1B(precQty, fakeChunk, filedatabase, &
d277 1
a277 1
   call FillVectorQuantityFromL1B(quantity, fakeChunk, filedatabase, &
d282 1
a282 1
   call FillVectorQuantityFromL1B(precQty, fakeChunk, filedatabase, &
d284 1
a284 1
   call FillVectorQuantityFromL1B(quantity, fakeChunk, filedatabase, &
d315 4
@


1.32
log
@Change mockup to import functions and literals from CFM module
@
text
@d31 4
a34 4
      FGrid_T, FillPhitanQuantity, FillVectorQuantityFromL1B, &
      ForwardModel, ForwardModelConfig_T, FORWARDMODELSTATUS_T, &
      Get2DHydrostaticTangentPressure, GetMLSFileByType, &
      GetVectorQtyByTemplateIndex, &
d56 1
a56 1
       "$Id: mockup.f90,v 1.27 2010/06/16 18:42:35 honghanh Exp $"
d230 2
a231 2
   call Get2DHydrostaticTangentPressure(ptanG_vv, temperature_vv, refGPH_vv, &
             h2o_vv, orbincl_vv, quantity, geocAlt_vv, 4, 0.0_r8, phyq_angle)
d315 3
@


1.31
log
@Move Phitan to state vector instead of stateExtraVector
@
text
@d1 15
d19 29
a47 40
   use CFM_MLSSetup_m, only: CFM_MLSCleanup, MLSChunk_T, CFM_MLSSetup
   use CFM_IO_M, only: Read_Spectroscopy, ReadDACSFilterShapes, &
                     ReadAntennaPatterns, ReadFilterShapes, &
                     ReadPointingGrids, ReadPFAFile, ReadHDF5L2PC, &
                     Destroy_DACS_Filter_Database, &
                     Destroy_Filter_Shapes_Database, &
                     Destroy_Ant_Patterns_Database, &
                     Destroy_SpectCat_Database, &
                     Destroy_Line_Database, ReadObservedRadiances, &
                     Destroy_Pointing_Grid_Database, &
                     DestroyL2PCDatabase, Destroy_PFADataBase
   use CFM_VGrid_m, only: CreateVGrid, DestroyVGridContents, &
                        VGrid_T, Dump
   use CFM_HGrid_m, only: CreateRegularHGrid, HGrid_T, &
                        DestroyHGridContents, Dump
   use CFM_FGrid_m, only: CreateFGrid, FGrid_T, DestroyFGridContents, &
                        Dump
   use CFM_QuantityTemplate_m, only: CreateQtyTemplate, Dump, &
                        AddQuantityTemplateToDatabase, &
                        DestroyQuantityTemplateDatabase, &
                        QuantityTemplate_T
   use CFM_VectorTemplate_m, only: CreateVectorTemplate, Dump, &
                        VectorTemplate_T, DestroyVectorTemplateInfo
   use CFM_Vector_m, only: CreateVector, Dump, &
                         Vector_T, VectorValue_T, &
                         DestroyVectorInfo, GetVectorQtyByTemplateIndex
   use CFM_Fill_m, only: ExplicitFillVectorQuantity, FillPhitanQuantity, &
                         FillVectorQuantityFromL1B, SpreadFillVectorQuantity
   use CFM_FWDMDL_M, only: ForwardModel, FORWARDMODELSTATUS_T, &
                         ForwardModelConfig_T
   use MLSCommon, only: MLSFile_T, r8
   use Init_tables_module, only: l_logarithmic, l_zeta, l_temperature, &
                                 L_IntermediateFrequency, l_vmr, l_gph, &
                                 l_ptan, l_radiance, l_orbitInclination, &
                                 l_tngtgeodalt, l_tngtgeocalt, l_o3, l_refGPH, &
                                 phyq_pressure, phyq_angle, l_h2o, l_explicit, &
                                 l_phitan
   use MLSFiles, only: GetMLSFileByType, InitializeMLSFile, mls_openFile, &
                       AddFileToDatabase
   use ScanModelModule, only: Get2DHydrostaticTangentPressure
a48 3
   use Hdf, only: DFACC_RDONLY
   use Intrinsic, only: l_hdf
   use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d241 48
a288 48
!   ! Create an identical vector as simulated radiance vector for observed radiances
!   observed = CreateVector(measurementTemplate, qtyTemplates)
!   obsPrecision = CreateVector(measurementTemplate, qtyTemplates)
!
!   ! Open l1brad
!   error = InitializeMLSFile(l1bfile, content='l1brad', &
!   name=trim(l1brad), shortName='L1BRAD', type=l_hdf, access=DFACC_RDONLY)
!   if (error /= 0) &
!      call MLSMessage (MLSMSG_Error, moduleName, &
!      "Error initializing " // trim(l1brad))
!
!   call mls_openFile(l1bfile, error)
!   if (error /= 0 ) &
!      call MLSMessage (MLSMSG_Error, moduleName, &
!      "Error opening " // trim(l1brad))
!
!   ! Add it to the filedatabase
!   error = AddFileToDatabase(filedatabase, l1bfile)
!
!   ! Fill band 2,7,8
!   quantity => GetVectorQtyByTemplateIndex(observed, band2_index)
!   precQty => GetVectorQtyByTemplateIndex(obsPrecision, band2_index)
!
!   ! However, only band 9 and 25 have BOMask=1
!   ! Because these bands have bright object status read from L1BOA file,
!   ! we always have to have L1BOA file in the filedatabase.
!   ! You have to fill the precision quantity first
!   call FillVectorQuantityFromL1B(precQty, fakeChunk, filedatabase, &
!   .true.)
!   call FillVectorQuantityFromL1B(quantity, fakeChunk, filedatabase, &
!   .false., precisionQuantity=precQty)
!
!   quantity => GetVectorQtyByTemplateIndex(observed, band7_index)
!   precQty => GetVectorQtyByTemplateIndex(obsPrecision, band7_index)
!   call FillVectorQuantityFromL1B(precQty, fakeChunk, filedatabase, &
!   .true.)
!   call FillVectorQuantityFromL1B(quantity, fakeChunk, filedatabase, &
!   .false., precisionQuantity=precQty)
!
!   quantity => GetVectorQtyByTemplateIndex(observed, band8_index)
!   precQty => GetVectorQtyByTemplateIndex(obsPrecision, band8_index)
!   call FillVectorQuantityFromL1B(precQty, fakeChunk, filedatabase, &
!   .true.)
!   call FillVectorQuantityFromL1B(quantity, fakeChunk, filedatabase, &
!   .false., precisionQuantity=precQty)
!
!   ! CFM_MLSCleanup will close all files in the filedatabase
!
d290 4
a293 4
!
!   ! Clean up allocated memory for creating observed radiance vector
!   call DestroyVectorInfo(observed)
!   call DestroyVectorInfo(obsPrecision)
d313 2
@


1.30
log
@Make refGPH an user-input
@
text
@d4 1
a4 3
   use CFM_MLSSetup_m, only: CFM_MLSCleanup, MLSChunk_T, CFM_MLSSetup, &
                             GetRefGPHIndexInStateExtra, &
                             GetPhitanGHzIndexInStateExtra
d30 1
a30 1
   use CFM_Fill_m, only: ExplicitFillVectorQuantity, &
d39 2
a40 1
                                 phyq_pressure, phyq_angle, l_h2o, l_explicit
d68 1
a68 1
                               band8
d74 1
a74 1
   integer :: stateSelected(9), measurementSelected(3)
d78 1
a78 1
   integer :: o3_index, ptanGHz_index, band7_index
d148 2
d160 1
d181 1
a181 1
   stateSelected = (/temperature_index,o3_index,h2o_index, &
d224 2
a225 1
   quantity => GetVectorQtyByTemplateIndex (stateExtra, GetPhitanGHzIndexInStateExtra())
@


1.29
log
@Reading observed radiance
@
text
@d33 1
a33 1
                         FillVectorQuantityFromL1B
d40 2
a41 2
                                 l_tngtgeodalt, l_tngtgeocalt, l_o3, &
                                 phyq_pressure, phyq_angle, l_h2o
d64 1
a64 1
   type(VGrid_T) :: vGridStandard
d75 1
a75 1
   integer :: stateSelected(8), measurementSelected(3)
d81 1
a81 1
   integer :: geocAlt_index, band8_index
d111 3
d148 1
a154 1
   band7_index = AddQuantityTemplateToDatabase(qtyTemplates, band7)
d158 2
d180 2
a181 2
                     ptanGHz_index,geodAlt_index, &
                     geocAlt_index,orbincl_index, gph_index/)
d192 2
a193 1
   !call dump(measurement, details=3)
a219 2
   refGPH_vv => GetVectorQtyByTemplateIndex(stateExtra, GetRefGPHIndexInStateExtra())

d235 1
a235 51
   !call dump(measurement, details=3)

   ! Create an identical vector as simulated radiance vector for observed radiances
   observed = CreateVector(measurementTemplate, qtyTemplates)
   obsPrecision = CreateVector(measurementTemplate, qtyTemplates)

   ! Open l1brad
   error = InitializeMLSFile(l1bfile, content='l1brad', &
   name=trim(l1brad), shortName='L1BRAD', type=l_hdf, access=DFACC_RDONLY)
   if (error /= 0) &
      call MLSMessage (MLSMSG_Error, moduleName, &
      "Error initializing " // trim(l1brad))

   call mls_openFile(l1bfile, error)
   if (error /= 0 ) &
      call MLSMessage (MLSMSG_Error, moduleName, &
      "Error opening " // trim(l1brad))

   ! Add it to the filedatabase
   error = AddFileToDatabase(filedatabase, l1bfile)

   ! Fill band 2,7,8
   quantity => GetVectorQtyByTemplateIndex(observed, band2_index)
   precQty => GetVectorQtyByTemplateIndex(obsPrecision, band2_index)

   ! However, only band 9 and 25 have BOMask=1
   ! Because these bands have bright object status read from L1BOA file,
   ! we always have to have L1BOA file in the filedatabase.
   ! You have to fill the precision quantity first
   call FillVectorQuantityFromL1B(precQty, fakeChunk, filedatabase, &
   .true.)
   call FillVectorQuantityFromL1B(quantity, fakeChunk, filedatabase, &
   .false., precisionQuantity=precQty)

   quantity => GetVectorQtyByTemplateIndex(observed, band7_index)
   precQty => GetVectorQtyByTemplateIndex(obsPrecision, band7_index)
   call FillVectorQuantityFromL1B(precQty, fakeChunk, filedatabase, &
   .true.)
   call FillVectorQuantityFromL1B(quantity, fakeChunk, filedatabase, &
   .false., precisionQuantity=precQty)

   quantity => GetVectorQtyByTemplateIndex(observed, band8_index)
   precQty => GetVectorQtyByTemplateIndex(obsPrecision, band8_index)
   call FillVectorQuantityFromL1B(precQty, fakeChunk, filedatabase, &
   .true.)
   call FillVectorQuantityFromL1B(quantity, fakeChunk, filedatabase, &
   .false., precisionQuantity=precQty)

   ! CFM_MLSCleanup will close all files in the filedatabase

   call dump(observed, details=3)
d237 53
a289 3
   ! Clean up allocated memory for creating observed radiance vector
   call DestroyVectorInfo(observed)
   call DestroyVectorInfo(obsPrecision)
@


1.28
log
@Using a pointer variable to get the result of GetVectorValueByTemplateIndex
@
text
@d283 4
@


1.27
log
@Remove Fill for GPH, since the forward model will fill GPH
Add band 2 and band 8 in the measurement vector
Change ForwardModel to handle an array of config objects instead of just 1
@
text
@d14 1
a14 1
                     Destroy_Line_Database, &
d42 2
a43 1
   use MLSFiles, only: GetMLSFileByType
d46 3
d56 1
a56 1
       "$Id: mockup.f90,v 1.23 2010/05/23 02:10:06 honghanh Exp $"
d72 1
a72 1
   type(Vector_T) :: state, measurement, stateExtra
d76 2
a77 2
   type(VectorValue_T) :: quantity, h2o_vv, orbincl_vv, geocAlt_vv, &
                          ptanG_vv, temperature_vv, refGPH_vv
d83 1
d190 1
a190 1
   temperature_vv = GetVectorQtyByTemplateIndex(state, temperature_index)
d193 1
a193 1
   h2o_vv = GetVectorQtyByTemplateIndex(state, h2o_index)
d196 1
a196 1
   quantity = GetVectorQtyByTemplateIndex(state, o3_index)
d199 1
a199 1
   quantity = GetVectorQtyByTemplateIndex(state, geodAlt_index)
d206 1
a206 1
   orbincl_vv = GetVectorQtyByTemplateIndex (state, orbincl_index)
d210 1
a210 1
   geocAlt_vv = GetVectorQtyByTemplateIndex (state, geocAlt_index)
d214 1
a214 1
   refGPH_vv = GetVectorQtyByTemplateIndex(stateExtra, GetRefGPHIndexInStateExtra())
d216 1
a216 1
   ptanG_vv = GetVectorQtyByTemplateIndex (state, ptanGHz_index)
d218 1
a218 1
   quantity = GetVectorQtyByTemplateIndex (stateExtra, GetPhitanGHzIndexInStateExtra())
d231 49
a279 1
   call dump(measurement, details=3)
d281 1
a281 2
   ! MLS radiances are stored in measurement vector
   ! do what you want with it
@


1.26
log
@Correct value for H2O's minValue
@
text
@d34 1
a34 1
   use CFM_FWDMDL, only: ForwardModel, FORWARDMODELSTATUS_T, &
d64 2
a65 1
                               geodAltitude, orbincl, geocAlt, refGPH
d71 1
a71 1
   integer :: stateSelected(8), measurementSelected(1)
d74 1
a74 1
   integer :: temperature_index, h2o_index
d77 1
a77 1
   integer :: geocAlt_index
d126 1
a126 1
   ! band 7 is the band whose radiances are to be computed
d130 4
d150 2
d169 1
a169 1
   stateSelected = (/temperature_index,gph_index,o3_index,h2o_index, &
d171 1
a171 1
                     geocAlt_index,orbincl_index/)
d175 1
a175 1
   measurementSelected = (/band7_index/)
a187 3
   quantity = GetVectorQtyByTemplateIndex(state, gph_index)
   call ExplicitFillVectorQuantity(quantity, GPHInput)

d216 1
d220 2
d223 1
a223 1
   call ForwardModel (fakeChunk, forwardModelConfigDatabase(1), state, &
@


1.25
log
@Fill elevation offsets and limb sideband fractions
@
text
@d122 1
a122 1
                           qLogBasis=.true., qMinValue=0.1_r8)
d175 1
a175 2
!   call dump(state, details=2)
!   call dump(measurement, details=2)
a214 3
   !call dump(stateExtra, details=2)
   !call dump(state, details=2)

@


1.24
log
@Deallocate PFA Database
@
text
@d223 2
@


1.23
log
@Call DestroyL2PCDatabase
@
text
@d16 1
a16 1
                     DestroyL2PCDatabase
d52 1
a52 1
       "$Id: mockup.f90,v 1.15 2010/03/18 22:16:46 honghanh Exp $"
d238 1
@


1.22
log
@Adapted to the modified interface of the forward model
@
text
@d15 2
a16 1
                     Destroy_Pointing_Grid_Database
d237 1
@


1.21
log
@Use ForwardModelConfig_T, ForwardModelStatus_T
@
text
@a76 1
   type (ForwardModelStatus_T) :: FmStat ! Status for forward model
d220 1
a220 1
                      stateExtra, measurement, fmStat)
@


1.20
log
@Remove ptanTHz
Add OrbitIncl, phitan, tngtgeocalt, fill-from-l1b subroutines
Change CFM_MLSSetup
Read other data files
Read input from file instead of from stdin
Invoke forward model
@
text
@d33 2
a34 1
   use CFM_FWDMDL, only: ForwardModel
a35 2
   use ForwardModelConfig, only: ForwardModelConfig_T
   use ForwardModelIntermediate, only: FORWARDMODELSTATUS_T
@


1.19
log
@Conformed all module names to end with _m, changed file names to all
lowercase, add comments
@
text
@d4 12
a15 1
   use CFM_MLSSetup_m, only: CFM_MLSSetup, CFM_MLSCleanup, MLSChunk_T
d25 1
a25 2
                        QuantityTemplate_T, InitQuantityTemplates, &
                        ConstructMIFGeolocation
d31 3
a33 1
   use CFM_Fill_m, only: ExplicitFillVectorQuantity
a34 1

d36 9
a44 2
   use Init_tables_module, only: l_logarithmic, l_zeta, &
                                 phyq_pressure, L_IntermediateFrequency
d49 1
a49 1
  character (len=*), parameter :: ModuleName= &
d51 1
a51 1
  character (len=*), parameter :: IdParm = &
d53 1
a53 1
  character (len=len(idParm)) :: Id = idParm
d56 1
a56 1
   integer :: error, i, numQty
d63 2
a64 3
   type(QuantityTemplate_T) :: temperature, GPH, H2O, O3, ptanGHz, ptanTHz, band7, &
                               geodAltitude
   type(QuantityTemplate_T), dimension(:), pointer :: mifGeoLocation => NULL()
d67 1
a67 1
   type(Vector_T) :: state, measurement
d69 32
a100 9
   character(len=3) :: THz = "THz"
   integer :: stateSelected(7), measurementSelected(1)
   type(VectorValue_T) :: quantity

   ! Reads L2CF from standard input, populates ForwardModelConfigDatabase, filedatabase,
   ! and fakeChunk
   call CFM_MLSSetup(startTime, endTime, l1boa, error, filedatabase, fakeChunk, &
                     ForwardModelConfigDatabase)
   if (error /= 0 ) stop
d102 2
a103 1
   vGridStandard = CreateVGrid (l_zeta, l_logarithmic, 1000.0d0, "37:6", phyq_pressure)
d114 38
a151 31
   ! Have to initialize before we start creating quantity templates
   call InitQuantityTemplates
   ! Reading mifGeolocation from L1BOA file
   call ConstructMIFGeolocation(mifGeoLocation, filedatabase, fakeChunk)
   temperature = CreateQtyTemplate("temperature", filedatabase=filedatabase, &
                                   avgrid=vGridStandard, ahgrid=hGridStandard, &
                                   mifGeolocation=mifGeolocation)
   GPH = CreateQtyTemplate("GPH", filedatabase=filedatabase, avgrid=vGridStandard, &
                           ahgrid=hGridStandard, mifGeolocation=mifGeolocation)
   O3 = CreateQtyTemplate("vmr", filedatabase=filedatabase, avgrid=vGridStandard, &
                          ahgrid=hGridStandard, qMolecule="O3", mifGeolocation=mifGeolocation)
   H2O = CreateQtyTemplate("vmr", filedatabase=filedatabase, avgrid=vGridStandard, &
                           ahgrid=hGridStandard, qMolecule="H2O", &
                           qLogBasis=.true., qMinValue=0.1_r8, mifGeolocation=mifGeolocation)
   ptanGHz = CreateQtyTemplate("ptan", filedatabase=filedatabase, qInstModule=GHz, &
                               mifGeoLocation=mifGeolocation)
   ptanTHz = CreateQtyTemplate("ptan", filedatabase=filedatabase, qInstModule=THz, &
                               mifGeolocation=mifGeolocation)
   band7 = CreateQtyTemplate("radiance", filedatabase=filedatabase, chunk=fakeChunk, &
                             qSignal="R3:240.B7F:O3", mifGeolocation=mifGeolocation)
   geodAltitude = CreateQtyTemplate("geodAltitude", filedatabase=filedatabase, &
                                    qInstModule=GHz, mifGeolocation=mifGeolocation)

   numQty = AddQuantityTemplateToDatabase(qtyTemplates, temperature)
   numQty = AddQuantityTemplateToDatabase(qtyTemplates, GPH)
   numQty = AddQuantityTemplateToDatabase(qtyTemplates, O3)
   numQty = AddQuantityTemplateToDatabase(qtyTemplates, H2O)
   numQty = AddQuantityTemplateToDatabase(qtyTemplates, ptanGHz)
   numQty = AddQuantityTemplateToDatabase(qtyTemplates, ptanTHz)
   numQty = AddQuantityTemplateToDatabase(qtyTemplates, band7)
   numQty = AddQuantityTemplateToDatabase(qtyTemplates, geodAltitude)
d162 4
a165 2
   stateSelected = (/5,6,1,2,4,3,8/)   ! The numbers are the order that
                                       ! quantities template were added
d169 1
a169 1
   measurementSelected = (/7/)
d179 3
a181 2
   quantity = GetVectorQtyByTemplateIndex(state, 1)
   call ExplicitFillVectorQuantity(quantity, TemperatureInput)
d183 1
a183 1
   quantity = GetVectorQtyByTemplateIndex(state, 2)
d186 2
a187 2
   quantity = GetVectorQtyByTemplateIndex(state, 4)
   call ExplicitFillVectorQuantity(quantity, H2OInput)
d189 1
a189 1
   quantity = GetVectorQtyByTemplateIndex(state, 3)
d192 34
a225 1
   call dump(state, details=2)
d232 10
a241 5
   call DestroyQuantityTemplateDatabase (qtyTemplates)
   call DestroyHGridContents(hGridStandard)
   call DestroyVGridContents(vGridStandard)
   call DestroyFGridContents(fGridStandard)
   call CFM_MLSCleanup
@


1.18
log
@Adjustments made to add startTime and endTime as inputs to CFM_MLSSetup.
Tested successfully
@
text
@d5 1
a5 1
   use CFM_VGrid, only: CreateVGrid, DestroyVGridContents, &
d7 1
a7 1
   use CFM_HGrid, only: CreateRegularHGrid, HGrid_T, &
d9 1
a9 1
   use CFM_FGrid, only: CreateFGrid, FGrid_T, DestroyFGridContents, &
d11 1
a11 1
   use CFM_QuantityTemplate, only: CreateQtyTemplate, Dump, &
d16 1
a16 1
   use CFM_VectorTemplate, only: CreateVectorTemplate, Dump, &
d18 1
a18 1
   use CFM_Vector, only: CreateVector, Dump, &
d21 1
a21 1
   use CFM_Fill, only: ExplicitFillVectorQuantity
d58 1
a58 1
   call CFM_MLSSetup(startTime, endTime, error, filedatabase, fakeChunk, &
d66 1
a66 1
   hGridStandard = CreateRegularHGrid(GHz, 0.0_r8, 1.5_r8, .true., .false., &
@


1.17
log
@Tested filling vector's quantities. Test is a success.
@
text
@d2 19
a20 8
   use input
   use CFM_MLSSetup_m, only: CFM_MLSSetup, CFM_MLSCleanup
   use CFM_VGrid, only: CreateVGrid
   use CFM_HGrid, only: CreateRegularHGrid
   use CFM_FGrid, only: CreateFGrid
   use CFM_QuantityTemplate, only: CreateQtyTemplate
   use CFM_VectorTemplate, only: CreateVectorTemplate
   use CFM_Vector, only: CreateVector
d22 1
a23 1
   use Chunks_m, only: MLSChunk_T
a24 7
   use MLSCommon, only: MLSFile_T, r8
   use VGridsDatabase, only: VGrid_T, DestroyVGridContents
   use HGridsDatabase, only: HGrid_T, DestroyHGridContents
   use Intrinsic, only: L_IntermediateFrequency
   use FGrid, only: FGrid_T, DestroyFGridContents, Dump
   use QuantityTemplates, only: QuantityTemplate_T, &
         AddQuantityTemplateToDatabase, DestroyQuantityTemplateDatabase
d26 1
a26 6
                                 phyq_pressure
   use VectorsModule, only: VectorTemplate_T, Vector_T, VectorValue_T, &
                            DestroyVectorTemplateInfo, DestroyVectorInfo, &
                            GetVectorQtyByTemplateIndex, Dump
   use Construct, only: ConstructMIFGeolocation
   use ConstructQuantityTemplates, only: InitQuantityTemplates
d34 1
a34 1
       "$Id: mockup.f90,v 1.16 2010/03/18 22:51:33 honghanh Exp $"
d56 5
a60 2
   call CFM_MLSSetup(error, ForwardModelConfigDatabase, filedatabase, fakeChunk)
   if (error /=0) stop
d62 2
a63 2
   vGridStandard = CreateVGrid(l_zeta, l_logarithmic, &
                               1000.0d0, "37:6", phyq_pressure)
d65 2
a66 2
   ! Have insetoverlaps, and single
   hGridStandard = CreateRegularHGrid(GHz, 0.0_r8, 1.5_r8, .true., .true., &
d68 1
d74 2
a76 1
   call InitQuantityTemplates
d105 11
a115 1
   stateSelected = (/5,6,1,2,4,3,8/)
d117 1
d121 1
d126 3
d141 1
a141 1
   call dump(state)
d143 1
@


1.16
log
@Tested creating a vector with unfilled quantities. Test is a success.
@
text
@d35 1
a35 1
       "$Id: mockup.f90,v 1.15 2010/03/18 22:16:46 honghanh Exp $"
a109 3
   call dump(state)
   call dump(measurement)

d122 2
@


1.15
log
@Adjusted the order of quantities entered in vector templates to be the same as l2cf.
Tested vector template creation.
@
text
@d35 1
a35 1
       "$Id: mockup.f90,v 1.13 2010/03/16 22:20:53 honghanh Exp $"
a106 3
   call dump(stateTemplate, details=1, quantities=qtyTemplates)
   call dump(measurementTemplate, details=1, quantities=qtyTemplates)

d110 3
@


1.14
log
@Correction and test for creating a quantity template
@
text
@d19 1
a19 1
   use QuantityTemplates, only: QuantityTemplate_T, Dump, &
d25 1
a25 1
                            GetVectorQtyByTemplateIndex
a91 9
   call dump(ptanGHz, details=2)
   call dump(ptanTHz, details=2)
   call dump(temperature, details=2)
   call dump(GPH, details=2)
   call dump(O3, details=2)
   call dump(H2O, details=2)
   call dump(band7, details=2)
   call dump(geodAltitude, details=2)

d101 1
a101 1
   stateSelected = (/1,2,3,4,5,6,8/)
d107 3
@


1.13
log
@Fixed, and tested for HGrid creation
@
text
@d16 1
a16 1
   use HGridsDatabase, only: HGrid_T, DestroyHGridContents, Dump
d18 2
a19 2
   use FGrid, only: FGrid_T, DestroyFGridContents
   use QuantityTemplates, only: QuantityTemplate_T, &
d35 1
a35 1
       "$Id: mockup.f90,v 1.12 2010/03/15 22:07:38 honghanh Exp $"
d66 1
a66 1
   call dump(hGridStandard)
d68 1
d92 9
d120 1
a120 1
   call ExplicitFillVectorQuantity(quantity, TemperatureInput)   
@


1.12
log
@Mockup without cfm_io
@
text
@d35 1
a35 1
       "$Id: mockup.f90,v 1.11 2010/03/15 22:06:56 honghanh Exp $"
d62 4
a65 1
   hGridStandard = CreateRegularHGrid(GHz, 0.0_r8, 1.5_r8, filedatabase, fakeChunk)
@


1.11
log
@Mockup with cfm_io
@
text
@a10 1
   use CFM_IO, only: Read_Spectroscopy
d35 1
a35 1
       "$Id: mockup.f90,v 1.10 2010/03/14 19:24:26 honghanh Exp $"
@


1.10
log
@Fix bugs in cfm_vgrid.f90, and added testing receipt for vgrid creation
@
text
@d16 2
a17 2
   use VGridsDatabase, only: VGrid_T, DestroyVGridContents, Dump
   use HGridsDatabase, only: HGrid_T, DestroyHGridContents
d36 1
a36 1
       "$Id: mockup.f90,v 1.9 2010/03/09 22:39:38 honghanh Exp $"
a62 1
   call dump(vGridStandard)
d64 1
@


1.9
log
@Example for filling vector
@
text
@d11 1
d16 1
a16 1
   use VGridsDatabase, only: VGrid_T, DestroyVGridContents
d18 1
a18 1
   use Intrinsic, only: phyq_pressure, l_zeta, L_IntermediateFrequency
d22 2
a23 1
   use Init_tables_module, only: l_logarithmic
d26 1
a26 1
                            GetVectorQtyByTemplateIndex, Dump
d36 1
a36 1
       "$Id: mockup.f90,v 1.8 2010/03/02 23:51:47 honghanh Exp $"
d63 1
a118 5
   print *, "Dumping state"
   call dump(state)
   print *, "Dumping measurement"
   call dump(measurement)

@


1.8
log
@Example of creating vectors
@
text
@d2 1
d7 1
a7 1
   use CFM_QuantityTemplate, only: CreateQtyTemplate, InitQuantityTemplates
d10 1
d22 1
a22 1
   use VectorsModule, only: VectorTemplate_T, Vector_T, &
d24 3
a26 1
                            Dump
d34 1
a34 1
       "$Id: mockup.f90,v 1.7 2010/03/02 22:46:04 honghanh Exp $"
d47 1
d54 1
d65 1
d67 8
a74 5
   temperature = CreateQtyTemplate("temperature", avgrid=vGridStandard, ahgrid=hGridStandard)
   GPH = CreateQtyTemplate("GPH", avgrid=vGridStandard, ahgrid=hGridStandard)
   O3 = CreateQtyTemplate("vmr", avgrid=vGridStandard, &
                          ahgrid=hGridStandard, qMolecule="O3")
   H2O = CreateQtyTemplate("vmr", avgrid=vGridStandard, &
d76 9
a84 5
                           qLogBasis=.true., qMinValue=0.1_r8)
   ptanGHz = CreateQtyTemplate("ptan", qInstModule=GHz)
   ptanTHz = CreateQtyTemplate("ptan", qInstModule=THz)
   band7 = CreateQtyTemplate("radiance", filedatabase, fakeChunk, qSignal="R3:240.B7F:O3")
   geodAltitude = CreateQtyTemplate("geodAltitude", qInstModule=GHz)
d104 13
d118 1
@


1.7
log
@Complete example of creating vector template, with memory cleanup
@
text
@d8 1
d21 2
a22 1
                            DestroyVectorTemplateInfo, Dump
d30 1
a30 1
       "$Id: mockup.f90,v 1.6 2010/03/02 22:10:23 honghanh Exp $"
d45 1
a45 1
   type(Vector_T) :: state
d87 2
a88 2
   call dump(stateTemplate, quantities=qtyTemplates)
   call dump(measurementTemplate, quantities=qtyTemplates)
d90 5
@


1.6
log
@Example of creating vector template
@
text
@d19 2
a20 1
   use VectorsModule, only: VectorTemplate_T, Dump
d28 1
a28 1
       "$Id: mockup.f90,v 1.5 2010/03/02 21:09:57 honghanh Exp $"
d43 1
d88 2
@


1.5
log
@Complete example for creating quantity templates
@
text
@d16 1
a16 1
   use QuantityTemplates, only: QuantityTemplate_T, Dump, &
d19 1
a19 1
   use VectorsModule, only: VectorTemplate_T
d27 1
a27 1
       "$Id: mockup.f90,v 1.4 2010/02/17 22:25:33 honghanh Exp $"
d41 1
a41 1
   type(VectorTemplate_T) :: stateTemplate
d44 1
d77 8
a84 3
   do i = 1, size(qtyTemplates)
      call dump(qtyTemplates(i), details=2)
   end do
@


1.4
log
@A mockup with example to create quantity templates
@
text
@d7 1
d12 2
a13 2
   use VGridsDatabase, only: VGrid_T
   use HGridsDatabase, only: HGrid_T
d15 5
a19 3
   use Init_Tables_Module, only: l_logarithmic, l_temperature, l_gph, l_vmr
   use FGrid, only: FGrid_T
   use QuantityTemplates, only: QuantityTemplate_T, Dump
d27 1
a27 1
       "$Id: mockup.f90,v 1.3 2010/02/17 20:29:39 honghanh Exp $"
d31 1
a31 1
   integer :: error, i
d38 4
a41 2
   type(QuantityTemplate_T) :: temperature, GPH, H2O, O3
   type(QuantityTemplate_T) :: qtyTemplates(4)
d43 1
d55 6
a60 5

   temperature = CreateQtyTemplate(l_temperature, vGridStandard, hGridStandard)
   GPH = CreateQtyTemplate(l_gph, vGridStandard, hGridStandard)
   O3 = CreateQtyTemplate(l_vmr, vGridStandard, hGridStandard, qMolecule="O3")
   H2O = CreateQtyTemplate(l_vmr, vGridStandard, hGridStandard, qMolecule="H2O", &
d62 13
a74 4
   qtyTemplates(1) = temperature
   qtyTemplates(2) = GPH
   qtyTemplates(3) = O3
   qtyTemplates(4) = H2O
d80 4
@


1.3
log
@Mockup with example to create a usual FGrid
@
text
@d6 2
d14 3
a16 2
   use Init_Tables_Module, only: l_logarithmic
   use FGrid, only: FGrid_T, Dump
d24 1
a24 1
       "$Id: mockup.f90,v 1.2 2010/02/17 19:15:01 honghanh Exp $"
d28 1
a28 1
   integer :: error
d35 2
d46 17
a62 1
   call dump(fGridStandard)
@


1.2
log
@Mockup with an example to create HGrid
@
text
@d5 1
d10 2
a11 2
   use HGridsDatabase, only: HGrid_T, Dump
   use Intrinsic, only: phyq_pressure, l_zeta
d13 1
d21 1
a21 1
       "$Id: mockup.f90,v 1.1 2010/02/17 16:41:33 honghanh Exp $"
d31 1
d40 2
a41 1
   call dump(hGridStandard)
@


1.1
log
@An example of using CFM_MLSSetup and creating a VGrid
@
text
@d4 1
d7 3
a9 2
   use MLSCommon, only: MLSFile_T
   use VGridsDatabase, only: VGrid_T, Dump
d19 1
a19 1
       "$Id: mockup.f90,v 0.1 2010/1/16 18:39:10 honghanh Exp $"
d28 2
d36 2
a37 2

   call dump(vGridStandard)
@

