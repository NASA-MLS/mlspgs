head	1.28;
access;
symbols
	v5-02-NRT-19:1.28
	v6-00:1.28
	v5-02-NRT-18:1.28
	v5-02:1.28
	v5-01-NRT-17:1.28
	v5-01-NRT-16:1.28
	v5-01-NRT-15:1.28
	v5-01-NRT-14:1.28
	neuralnetworks-1-0:1.28.0.10
	cfm-single-freq-0-1:1.28.0.8
	TES-MLuo-01:1.28
	TES-UNKNOWN:1.28
	v5-01:1.28
	v5-00:1.28
	v4-23-TA133:1.28.0.6
	mus-emls-1-70:1.28.0.4
	rel-1-0-englocks-work:1.28.0.2
	VUMLS1-00:1.28
	VPL1-00:1.28
	V4-22-NRT-08:1.27
	VAM1-00:1.25
	V4-21:1.24.0.2
	V4-13:1.24
	V4-12:1.24
	V4-11:1.24
	V4-10:1.24
	V3-43:1.1
	M4-00:1.23
	V3-41:1.1
	V3-40-PlusGM57:1.1.0.2
	V3-33:1.19
	V3-31:1.19
	V3-30-NRT-05:1.17
	cfm-01-00:1.16
	V3-30:1.1
	V3-20:1.1;
locks; strict;
comment	@# @;


1.28
date	2016.07.06.22.13.46;	author pwagner;	state Exp;
branches;
next	1.27;

1.27
date	2016.05.12.18.17.22;	author pwagner;	state Exp;
branches;
next	1.26;

1.26
date	2016.01.07.17.54.02;	author pwagner;	state Exp;
branches;
next	1.25;

1.25
date	2015.08.05.20.21.29;	author pwagner;	state Exp;
branches;
next	1.24;

1.24
date	2013.07.26.16.48.15;	author pwagner;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.23.22.56.12;	author honghanh;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.16.00.25.31;	author honghanh;	state Exp;
branches;
next	1.21;

1.21
date	2011.10.19.17.39.25;	author honghanh;	state Exp;
branches;
next	1.20;

1.20
date	2011.03.24.21.13.20;	author honghanh;	state Exp;
branches;
next	1.19;

1.19
date	2010.11.18.19.04.13;	author honghanh;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.03.18.34.46;	author honghanh;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.07.21.02.05;	author honghanh;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.30.17.45.12;	author pwagner;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.30.08.11.25;	author honghanh;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.29.16.40.23;	author honghanh;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.29.15.53.45;	author honghanh;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.25.18.02.11;	author honghanh;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.24.14.30.38;	author honghanh;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.23.01.54.26;	author honghanh;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.23.01.43.05;	author honghanh;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.05.17.40.31;	author honghanh;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.26.15.35.18;	author honghanh;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.24.17.44.48;	author honghanh;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.24.16.26.17;	author honghanh;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.18.20.42.04;	author honghanh;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.09.22.39.38;	author honghanh;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.02.21.09.57;	author honghanh;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.17.22.25.33;	author honghanh;	state Exp;
branches;
next	;


desc
@@


1.28
log
@CreateQtyTemplate now properly allocate crossAngles
@
text
@! Copyright 2010, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.
module CFM_QuantityTemplate_m
   use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Test_Allocate
   use FGrid, only: fGrid_T
   use HGridsDatabase, only: hGrid_T
   use highOutput, only: outputNamedValue
   use VGridsDatabase, only: VGrids, VGrid_T
   use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning, MLSMSG_L1BRead
   use QuantityTemplates, only: QuantityTemplate_T, NullifyQuantityTemplate, &
                                DestroyQuantityTemplateDatabase, &
                                PointQuantityToHGrid
   use Init_Tables_Module, only: FIRST_LIT, LAST_LIT, L_ADOPTED, &
      L_BASELINE, L_BOUNDARYPRESSURE, L_CALSIDEBANDFRACTION, &
      L_CHISQBINNED, L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, L_CLOUDICE, &
      L_CLOUDINDUCEDRADIANCE, L_CLOUDEXTINCTION, L_CLOUDMINMAX, L_CLOUDRADSENSITIVITY, &
      L_CLOUDTEMPERATURE, L_CLOUDWATER, L_COLUMNABUNDANCE, &
      L_DNWT_ABANDONED, L_DNWT_AJN, L_DNWT_AXMAX, L_DNWT_CAIT, &
      L_DNWT_CHISQMINNORM, L_DNWT_CHISQNORM, L_DNWT_CHISQRATIO, &
      L_DNWT_COUNT, L_DNWT_DIAG, L_DNWT_DXDX, L_DNWT_DXDXL, &
      L_DNWT_DXN, L_DNWT_DXNL, L_DNWT_FLAG, L_DNWT_FNMIN, &
      L_DNWT_FNORM, L_DNWT_GDX, L_DNWT_GFAC, &
      L_DNWT_GRADN, L_DNWT_SQ, L_DNWT_SQT,&
      L_EARTHRADIUS, L_EARTHREFL, L_ECRTOFOV, L_EFFECTIVEOPTICALDEPTH, &
      L_ELEVOFFSET, L_EXTINCTION, L_EXTINCTIONV2, &
      L_FIELDAZIMUTH, L_FIELDELEVATION, L_FIELDSTRENGTH, &
      L_GEODALTITUDE, L_GEOLOCATION, L_GPH, L_HEIGHTOFFSET, L_ISOTOPERATIO, L_IWC, &
      L_JACOBIAN_COLS, L_JACOBIAN_ROWS, &
      L_L1BMAFBASELINE, L_L1BMIF_TAI, L_LIMBSIDEBANDFRACTION, &
      L_LineCenter, L_LineWidth, L_LineWidth_TDep, &
      L_LOSTRANSFUNC, L_LOSVEL, &
      L_MASSMEANDIAMETERICE, L_MASSMEANDIAMETERWATER, L_MAGNETICFIELD, &
      L_MIFDEADTIME, L_ZETA, L_XYZ, L_MATRIX3X3, L_Channel, &
      L_NOISEBANDWIDTH, L_NORADSPERMIF, L_NORADSBINNED, &
      L_NUMGRAD, L_NUMJ, L_NUMNEWT, L_OPTICALDEPTH, L_ORBITINCLINATION, &
      L_PHASETIMING, L_PHITAN, L_PTAN, L_QUALITY, L_RADIANCE, &
      L_REFGPH, L_REFLTEMP, L_REFLTRANS, L_REFLREFL, L_REFLSPILL, &
      L_RHI, L_SINGLECHANNELRADIANCE, L_SIZEDISTRIBUTION, &
      L_SCANRESIDUAL, L_SCATTERINGANGLE, L_SCECI, L_SCVELECI, &
      L_SCVELECR, L_SCGEOCALT, L_SPACERADIANCE, L_STATUS, &
      L_STRAYRADIANCE, L_SurfaceHeight, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
      L_TEMPERATURE, L_TNGTECI, L_TNGTGEODALT, L_TNGTGEOCALT, &
      L_TOTALPOWERWEIGHT, L_TSCAT, L_VMR, L_NONE, &
      PHYQ_ANGLE, PHYQ_COLMABUNDANCE, &
      PHYQ_DIMENSIONLESS, PHYQ_EXTINCTION, PHYQ_FREQUENCY,&
      PHYQ_GAUSS, PHYQ_IceDensity, PHYQ_LENGTH, &
      PHYQ_PRESSURE, PHYQ_TEMPERATURE, PHYQ_TIME, PHYQ_VELOCITY, &
      PHYQ_VMR, PHYQ_ZETA, l_ghz
    use Output_M, only: OUTPUT
    use String_Table, only: DISPLAY_STRING, CREATE_STRING
    use MLSCommon, only: r8, NameLen, MLSFile_T
    use MLSSignals_m, only: GetModuleIndex
    use Molecules, only: GetMoleculeIndex
    use Chunks_m, only: MLSChunk_T
    use ConstructQuantityTemplates, only : AnyGoodSignalData, &
            ConstructMinorFrameQuantity, &
            InitQuantityTemplates, unitstable, propertyTable, &
            p_majorFrame, p_minorFrame, p_mustBeZeta, p_fGrid, p_hGrid, &
            p_vgrid, p_radiometer, p_radiometerOptional, p_scModule, &
            p_signal, p_signalOptional, p_xyz, p_matrix3x3, p_flexibleVHGrid, &
            p_suppressChannels, p_module, p_molecule, p_fGridOptional, &
            firstProperty, lastProperty
    use Construct, only: ConstructMIFGeolocation
    use Parse_Signal_m, only: PARSE_SIGNAL
    use MLSSignals_m, only: GetModuleFromSignal, GetRadiometerFromSignal, &
                            GetSignal, Signal_T, IsModuleSpacecraft, &
                            GetRadiometerIndex, GetModuleFromRadiometer

   implicit none

   public :: CreateQtyTemplate

   private

   interface CreateQtyTemplate
       module procedure CreateQtyTemplate_maf, CreateQtyTemplate_chunk
   end interface

!---------------------------- RCS Ident Info -------------------------------
   character(len=*), private, parameter :: ModuleName= &
       "$RCSfile: cfm_qtytemplate.f90,v $"
   private :: not_used_here
!---------------------------------------------------------------------------

   contains

   type(QuantityTemplate_T) function CreateQtyTemplate_maf (quantityType, firstL1Maf, lastL1Maf, &
        filedatabase, avgrid, ahgrid, afgrid, qInstModule, qMolecule, qLogBasis, &
        qMinValue, qSignal, qRadiometer, qBadValue, qName) result(qty)

      ! an integer representing a quantity type, see CFM documentation appendix
      integer, intent(in) :: quantityType
      ! firstL1Maf and last1Maf describe the maf range in
      ! L1BOA file for major frame quantities and minor frame
      ! quantities that need information from L1BOA file.
      ! If this quantity is neither a major frame quantity
      ! nor a minor frame quantity, then firstL1Maf
      ! and lastL1Maf can be any number as long as its 
      ! difference is equal to the number of instances
      ! of this quantity (the VectorValue_T object that
      ! owns this QuantityTemplate_T).
      integer, intent(in) :: firstL1Maf
      integer, intent(in) :: lastL1Maf
      ! is an array of open files (see CFM_MLSSetup)
      type (MLSFile_T), dimension(:), pointer, optional ::     FILEDATABASE
      ! The z-coordinate samples of the spacecraft's path.
      ! Information in this grid will be copied over.
      type(VGrid_T), intent(in), optional :: avgrid
      ! the (x,y) coordinate samples of the spacecraft's path
      ! Information in this grid will be copied over.
      type(HGrid_T), intent(in), optional :: ahgrid
      ! the frequency in which the data is gathered
      ! Information in this grid will be copied over.
      type(FGrid_T), intent(in), optional :: afgrid
      ! instrument module, a case-insensitive string, either "THz" or "GHz"
      character(len=*), optional :: qInstModule
      ! an integer representing one of the molecules listed in the CFM document.
      integer, optional :: qMolecule
      ! if type is "radiance", then a qSignal must be provided
      character(len=*), optional :: qSignal
      ! tells whether the value of avgrid and ahgrid
      ! is on logarithmic scale. The default value is .false..
      logical, optional :: qLogBasis
      ! is used only qLogBasis is .true., in which case
      ! it is the threshold to which greater or equal coordinate values are recorded
      ! as their logarithmic equivalent. The default value is 1.0.
      real(r8), optional :: qMinValue
      ! If the quantity only associates with a radiometer
      ! and not a signal, then use qRadiometer instead of 
      ! qSignal.
      character(len=*), optional :: qRadiometer
      ! a number to indicate that a data point shouldn't be used. Default
      ! is -huge(0.0_r8)
      real(r8), optional :: qBadValue
      ! name of the quantity as string
      character(len=*), optional :: qName

      type (MLSChunk_T) :: Chunk

      chunk%firstMafIndex = firstL1Maf
      chunk%lastMafIndex = lastL1Maf
      qty = CreateQtyTemplate_chunk (quantityType, filedatabase, chunk, &
      avgrid, ahgrid, afgrid, qInstModule, qMolecule, qLogBasis, qMinValue, qSignal, &
      qRadiometer, qBadValue, qName)
   end function CreateQtyTemplate_maf

   ! Creating a quantity based on the optional inputs this subroutine is provided with.
   type(QuantityTemplate_T) function CreateQtyTemplate_chunk &
     & (quantityType, filedatabase, chunk, &
        avgrid, ahgrid, afgrid, qInstModule, qMolecule, qLogBasis, qMinValue, qSignal, &
        qRadiometer, qBadValue, qName) result(qty)
      ! an integer representing a quantity type, see CFM documentation appendix
      integer, intent(in) :: quantityType
      ! is an array of open files (see CFM_MLSSetup)
      type (MLSFile_T), dimension(:), pointer, optional ::     FILEDATABASE
      ! an input holder, storing the time range of the data to be read
      ! (see CFM_MLSSetup)
      type (MLSChunk_T), intent(in), optional :: Chunk
      ! The z-coordinate samples of the spacecraft's path.
      ! Information in this grid will be copied over.
      type(VGrid_T), intent(in), optional :: avgrid
      ! the (x,y) coordinate samples of the spacecraft's path
      ! Information in this grid will be copied over.
      type(HGrid_T), intent(in), target, optional :: ahgrid
      ! the frequency in which the data is gathered
      ! Information in this grid will be copied over.
      type(FGrid_T), intent(in), optional :: afgrid
      ! instrument module, a case-insensitive string, either "THz" or "GHz"
      character(len=*), optional :: qInstModule
      ! an integer representing one of the molecules listed in the CFM document.
      integer, optional :: qMolecule
      ! if type is "radiance", then a qSignal must be provided
      character(len=*), optional :: qSignal
      ! tells whether the value of avgrid and ahgrid
      ! is on logarithmic scale. The default value is .false..
      logical, optional :: qLogBasis
      ! is used only qLogBasis is .true., in which case
      ! it is the threshold to which greater or equal coordinate values are recorded
      ! as their logarithmic equivalent. The default value is 1.0.
      real(r8), optional :: qMinValue
      character(len=*), optional :: qRadiometer
      ! a number to indicate that a data point shouldn't be used. Default
      ! is -huge(0.0_r8)
      real(r8), optional :: qBadValue
      ! name of the quantity as string
      character(len=*), optional :: qName

      logical :: PROPERTIES(firstProperty : lastProperty) ! Properties for this quantity type
      character(len=127) :: signalString
      integer, dimension(:), pointer :: SignalInds ! From parse signal
      logical, pointer :: Channels(:)     ! From Parse_Signal
      integer :: s_index, temp
      type(Signal_T) :: signalInfo
      integer :: noChans, sideband, signal, radiometer, instrumentModule
      logical :: isMinorFrame
      character(len=256) :: haha = ' '

    character(63) :: What

    ! Executable code
    if ( qty%name > 0 ) then
      call mygetString ( qty%name, what )
    else
      what = "qty"
    end if
      call NullifyQuantityTemplate(qty)
      instrumentModule = 0
      qty%fGridIndex = 0 ! we're not getting fgrid from fgridDatabase
      qty%hGridIndex = 0 ! we're not getting hgrid from hgridDatabase
      qty%vGridIndex = 0 ! we're not getting vgrid from vgridDatabase
      qty%xGridIndex = 0
      qty%logBasis = .false.
      qty%minValue = -huge(0.0_r8)
      qty%molecule = 0
      qty%horizontalCoordinate = l_phiTan
      noChans = 1
      qty%frequencyCoordinate = l_none
      radiometer = 0
      qty%reflector = 0
      sideband = 0
      signal = 0
      qty%vGridIndex = 0
      qty%noInstances = 1
      qty%noSurfs = 1
      qty%regular = .true. ! irregular quantity not supported
      qty%coherent = .true.
      qty%stacked = .true.
      qty%minorFrame = .false.
      qty%majorFrame = .false.
      ! Because some quantities are provided by MLS, and some are supplied
      ! by GMAO, right now for simplicity, let's not share the grids
      qty%sharedVGrid = .false.
      qty%sharedFGrid = .false.
      qty%badValue = huge(0.0_r8)   !Default bad value
      ! These field are not used in cfm
      qty%verticalCoordinate = l_zeta
      qty%noInstancesLowerOverlap = 0
      qty%noInstancesUpperOverlap = 0

      properties = propertyTable(:, quantityType)

      !Sanity check
      if (.not. properties (p_flexibleVHGrid)) then
         if ( present ( ahGrid ) .neqv. properties ( p_hGrid ) ) &
           & call Announce_error ( trim ( merge ( 'unexpected', 'need      ', &
           & present(ahGrid) ) ) // ' hGrid for quantity type ', quantityType, &
           & severity='nonfatal' )
         if ( present ( avGrid ) .neqv. properties ( p_vGrid ) ) &
           & call Announce_error ( trim ( merge ( 'unexpected', 'need      ', &
           & present(avGrid) ) ) // ' vGrid for quantity type ', quantityType )
         isMinorFrame = properties(p_minorFrame)
      else
         if (present(ahGrid) .neqv. present(avgrid)) &
            call Announce_Error ( 'Must supply both or neither vGrid and hGrid ' &
            // 'for quantity type ', quantityType, severity='fatal' )
         isMinorFrame = .not. present(ahgrid)
      end if
      if ( present ( qMolecule ) .neqv. properties ( p_Molecule ) ) &
         & call Announce_error ( trim ( merge ( 'unexpected', 'need      ', &
         & present(qMolecule) ) ) // ' molecule for quantity type ', quantityType )
      if ( present ( qInstModule ) .neqv. ( properties ( p_Module ) .or. properties ( p_scModule) ) ) then
         call Announce_error ( trim ( merge ( 'unexpected', 'need      ', &
         & present(qInstModule) ) ) // ' module for quantity type ', quantityType )
      end if
      if ( .not. properties ( p_signalOptional ) ) then
         if ( present ( qSignal ) .neqv. properties ( p_Signal ) ) &
            & call Announce_error ( trim ( merge ( 'unexpected', 'need      ', &
            & present(qSignal) ) ) // ' signal for quantity type ', quantityType )
      end if
      if ( properties ( p_mustBeZeta ) .and. present(avGrid) ) then
         if ( avGrid%verticalCoordinate /= l_zeta ) &
           & call Announce_error ( 'Expecting log pressure coordinates for', &
           & quantityType )
      end if
      if (.not. properties(p_fGridOptional)) then
         if ( present ( aFGrid ) .neqv. properties ( p_fGrid ) ) &
           & call Announce_error ( trim ( merge ( 'unexpected', 'need      ', &
           & present(aFGrid) ) ) // ' fGrid for quantity type ', quantityType )
      end if
      if ( .not. properties ( p_radiometerOptional ) ) then
         if ( present ( qRadiometer ) .neqv. properties ( p_Radiometer ) ) &
           & call Announce_error ( trim ( merge ( 'unexpected', 'need      ', &
           & present(qRadiometer) ) ) // ' radiometer for quantity type ', quantityType )
      end if

      if (present(qInstModule)) then
         call GetModuleIndex (qInstModule, instrumentModule)
      end if
      if (present (qRadiometer)) then
         call GetRadiometerIndex(qRadiometer, radiometer)
         ! Every radiometer pairs with only one instrument module
         instrumentModule = GetModuleFromRadiometer(radiometer)
         ! If the user happen to pass in the wrong instrumentModule,
         ! silently correct it, for simplicity
      end if

      if (present(qLogBasis)) qty%logBasis = qLogBasis

      if (present(qMinValue)) qty%minValue = qMinValue

      if (present(qSignal)) then
         nullify ( channels, signalInds )
         signalString = qSignal
         call parse_Signal ( signalString, signalInds, &
            & sideband=sideband, channels=channels )
         if ( .not. associated(signalInds) .or. size(signalInds) == 0) then ! A parse error occurred
            call MLSMessage ( MLSMSG_Error, ModuleName,&
              & 'Unable to parse signal string' )
         end if
         if (present(filedatabase)) then
             if (associated(filedatabase) .and. size(signalInds) .gt. 1) then
                 ! Seek a signal with any precision values !< 0
                 do s_index=1, size(signalInds)
                     if ( AnyGoodSignalData ( signalInds(s_index), sideband, &
                     filedatabase, chunk) ) exit
                 end do
                 if ( s_index > size(signalInds) ) then
                     signal = signalInds(1)
                 else
                     signal = signalInds(s_index)
                 end if
             else
                 signal = signalInds(1)
             end if
         else
             signal = signalInds(1)
         end if

         call deallocate_test ( signalInds, 'signalInds', ModuleName )
         ! if the user has pass in the wrong instrumentModule or radiometer
         ! just silently correct it, for simplicity.
         instrumentModule = GetModuleFromSignal(signal)
         radiometer = GetRadiometerFromSignal(signal)
      end if

      ! After all the possible places where instrumentModule can be set
      if ( properties ( p_scModule ) ) then
         if ( .not. IsModuleSpacecraft ( instrumentModule ) ) &
           & call Announce_error ( 'Module must be spacecraft' )
      end if

      ! Now establish the frequency coordinate system
      if (present(afgrid)) then
         qty%frequencyCoordinate = afgrid%frequencyCoordinate
         call allocate_test(qty%frequencies, size(afgrid%values), &
         "qty%frequencies", moduleName)
         qty%frequencies = afgrid%values
         noChans = afgrid%noChans
      else if (properties(p_xyz)) then
         ! XYZ quantity (e.g. ECI/ECR stuff)
         qty%frequencyCoordinate = l_xyz
         noChans = 3
      else if (properties(p_matrix3x3)) then
         ! XYZ^2 quantity (e.g. rotation matrix)
         qty%frequencyCoordinate = l_matrix3x3
         noChans = 9
      else if (present(qSignal) .and. .not. properties(p_suppressChannels)) then
         ! This is a channel based quantity
         signalInfo = GetSignal(signal)
         qty%frequencyCoordinate = l_channel
         noChans = size(signalInfo%frequencies)
      end if

      ! Now do the setup for the different families of quantities
      if (isMinorFrame) then
         if (.not. (present(filedatabase) .and. present(chunk))) &
            call MLSMessage(MLSMSG_Error, ModuleName, &
            'Need either mifGeolocation or both filedatabase and ' &
            // 'chunk to create minor frame quantity')
         call ConstructMinorFrameQuantity (instrumentModule, &
              qty, noChans=noChans, regular=qty%regular, &
              filedatabase=filedatabase, chunk=chunk)
      else if (properties(p_majorFrame)) then
         if (.not. present(chunk) .or. .not. present(filedatabase)) &
           & call MLSMessage(MLSMSG_Error, moduleName, &
           & "Need both chunk and filedatabase to create major frame quantity")
         ! Setup a major frame quantity
         call ConstructMajorFrameQuantity (instrumentModule, qty, &
              noChans, filedatabase, chunk)
      else
         ! Setup the quantity template for an HGrid
         if (present(ahgrid)) then
            ! call output( 'We have an HGrid', advance='yes' )
            qty%noInstances = ahgrid%noprofs
            qty%the_hGrid => aHGrid
            call PointQuantityToHGrid ( qty )
         else
            ! call output( 'We do not have an HGrid', advance='yes' )
            call SetupEmptyHGridForQuantity(qty)
         end if
         ! call outputNamedValue ( 'is crossAngles associated?', &
         !   & associated(qty%crossAngles) )

         if (present(avGrid)) then
            qty%verticalCoordinate = avGrid%verticalCoordinate
            call allocate_test(qty%surfs, size(avGrid%surfs,1), &
            size(avGrid%surfs,2), "qty%surfs", moduleName)
            qty%surfs = avGrid%surfs
            qty%noSurfs = avgrid%noSurfs
         else
            call SetupEmptyVGridForQuantity(qty)
         end if

         qty%instanceLen = qty%noSurfs * noChans
     end if

     if (present(qBadValue)) qty%badValue = qBadValue

     if (present(qMolecule)) then
         qty%molecule = qMolecule
     end if

     if (present(qName)) then
         qty%name = create_string(qName)
     else
         qty%name = 0
     end if

     qty%quantityType = quantityType
     qty%unit = unitsTable(quantityType)
     qty%noChans = noChans
     qty%sideband = sideband
     qty%signal = signal
     qty%radiometer = radiometer
     qty%instrumentModule = instrumentModule
     qty%minorFrame = isMinorFrame

     ! Now think about instanceLen
     if ( .not. qty%regular ) then
       qty%instanceLen = 0
     else
       qty%instanceLen = qty%noSurfs * qty%noChans * qty%noCrossTrack
     end if

     ! Now the horizontal coordinates

     call allocate_test ( qty%crossAngles, qty%noCrossTrack, &
       & trim(what) // "%crossAngles", ModuleName )
     qty%crossAngles = 0.0 ! In case there actually is no xGrid

   end function CreateQtyTemplate_chunk

  ! ----------------------------------  myPointQuantityToHGrid  -----
  subroutine myPointQuantityToHGrid ( hGrid, qty )

  ! This routine copies HGrid information into an already defined quantity

    ! Dummy arguments
    type (hGrid_T), intent(in) :: HGRID
    type (QuantityTemplate_T), intent(inout) :: QTY

    ! Executable code
    if ( qty%noInstances/=hGrid%noProfs ) call MLSMessage ( MLSMSG_Error,&
      & ModuleName, "Size of HGrid not compatible with size of quantity" )
    if ( .not. qty%stacked ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Cannot copy hGrids into unstacked quantities")

    call allocate_test(qty%phi, size(hGrid%phi,1), size(hGrid%phi,2), &
    "qty%phi", moduleName)
    call allocate_test(qty%crossAngles, 1, &
    "qty%crossAngles", moduleName)
    call allocate_test(qty%geodLat, size(hGrid%geodLat,1), size(hGrid%geodLat,2), &
    "qty%geodLat", moduleName)
    call allocate_test(qty%lon, size(hGrid%lon,1), size(hGrid%lon,2), &
    "qty%lon", moduleName)
    call allocate_test(qty%time, size(hGrid%time,1), size(hGrid%time,2), &
    "qty%time", moduleName)
    call allocate_test(qty%solarTime, size(hGrid%solarTime,1), &
    size(hGrid%solarTime,2), "qty%solarTime", moduleName)
    call allocate_test(qty%solarZenith, size(hGrid%solarZenith,1), &
    size(hGrid%solarZenith,2), "qty%solarZenith", moduleName)
    call allocate_test(qty%losAngle, size(hGrid%losAngle,1), &
    size(hGrid%losAngle,2), "qty%losAngle", moduleName)
    qty%phi = hGrid%phi
    qty%crossAngles = 0.
    qty%geodLat = hGrid%geodLat
    qty%lon = hGrid%lon
    qty%time = hGrid%time
    qty%solarTime = hGrid%solarTime
    qty%solarZenith = hGrid%solarZenith
    qty%losAngle = hGrid%losAngle
    qty%noInstancesLowerOverlap = hGrid%noProfsLowerOverlap
    qty%noInstancesUpperOverlap = hGrid%noProfsUpperOverlap
    qty%noCrossTrack = 1

  end subroutine myPointQuantityToHGrid

  ! ---------------------------------- SetupEmptyHGridForQuantity
  subroutine SetupEmptyHGridForQuantity ( qty )
    ! Dummy arguments
    type ( QuantityTemplate_T ), intent(inout) :: QTY
    ! Executable code
    qty%hGridIndex = 0
    qty%xGridIndex = 0
    ! Lest we deallocate a database entry:
    nullify( qty%frequencies, qty%time, qty%solarTime, &
      & qty%solarZenith, qty%losAngle, qty%crossAngles, qty%the_hGrid )
    call allocate_test ( qty%phi, 1, 1, 'qty%phi(1,1)', ModuleName )
    call allocate_test ( qty%geodLat, 1, 1, 'qty%geodLat(1,1)', ModuleName )
    call allocate_test ( qty%lon, 1, 1, 'qty%lon1(1,1)', ModuleName )
    call allocate_test ( qty%time, 1, 1, 'qty%time(1,1)', ModuleName )
    call allocate_test ( qty%solarTime, 1, 1, 'qty%solarTime(1,1)', ModuleName )
    call allocate_test ( qty%solarZenith, 1, 1, 'qty%solarZenith(1,1)', ModuleName )
    call allocate_test ( qty%losAngle, 1, 1, 'qty%losAngle(1,1)', ModuleName )
    call allocate_test ( qty%crossAngles, 1, 'qty%crossAngles(1)', ModuleName )
    qty%phi = 0.0
    qty%geodLat = 0.0
    qty%lon = 0.0
    qty%time = 0.0
    qty%solarTime = 0.0
    qty%solarZenith = 0.0
    qty%losAngle = 0.0
    qty%crossAngles = 0.0
  end subroutine SetupEmptyHGridForQuantity

  ! ---------------------------------- SetupEmptyVGridForQuantity
  subroutine SetupEmptyVGridForQuantity ( qty )
    ! Dummy arguments
    type ( QuantityTemplate_T ), intent(inout) :: QTY
    ! Executable code
    qty%sharedVGrid = .false.
    qty%vGridIndex = 0
    qty%verticalCoordinate = l_none
    call Allocate_test ( qty%surfs, 1, 1, 'qty%surfs(1,1)', ModuleName )
    qty%surfs = 0. ! We used to have impossible values for bnd. prs.
  end subroutine SetupEmptyVGridForQuantity

  subroutine ConstructMajorFrameQuantity (instrumentModule, qty, noChans, filedatabase, chunk)
     use L1BData, only: L1BData_T, READL1BDATA, DEALLOCATEL1BDATA, AssembleL1BQtyName
     use QuantityTemplates, only: SetupNewQuantityTemplate
     use MLSFiles, only: GetMLSFileByType
     use MLSSignals_m, only: GetModuleName

     type (MLSChunk_T), intent(in) :: CHUNK
     integer, intent(in) :: INSTRUMENTMODULE
     type (QuantityTemplate_T), intent(out) :: QTY
     integer, intent(in) :: NOCHANS
     type (MLSFile_T), dimension(:), pointer, optional ::     FILEDATABASE

     type (L1BData_T) :: l1bField
     type (MLSFile_T), pointer :: L1BFile
     character (len=NameLen) :: l1bItemName, moduleName
     integer :: hdfVersion, noMafs, l1bFlag, mafIndex

     ! Executables
     L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
     hdfversion = L1BFile%HDFVersion

     ! Read NoMafs
     if ( IsModuleSpacecraft(instrumentModule) ) then
        l1bItemName = 'scGeocAlt'
     else
        call GetModuleName ( instrumentModule, moduleName)
        l1bItemName = TRIM(moduleName) // ".tpGeodAlt"
     end if
     l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )

     ! find noMafs
     call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
                        l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
     if ( l1bFlag==-1 ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, MLSMSG_L1BRead//l1bItemName )
     call DeallocateL1BData ( l1bField )

     call SetupNewQuantityTemplate ( qty, noInstances=noMafs, &
      & noSurfs=1, coherent=.true., stacked=.true., regular=.true., &
      & noChans=noChans, sharedVGrid=.false. )
     call SetupEmptyVGridForQuantity(qty)

     qty%majorFrame = .true.
     qty%minorFrame = .false.
     qty%instanceOffset = chunk%firstMAFIndex + chunk%noMAFsLowerOverlap
     qty%instrumentModule = instrumentModule
     qty%noInstancesLowerOverlap = chunk%noMAFsLowerOverlap
     qty%noInstancesUpperOverlap = chunk%noMAFsUpperOverlap

     if ( IsModuleSpacecraft(instrumentModule) ) then
        ! just zero stuff out.
        qty%phi = 0.0
        qty%geodLat = 0.0
        qty%lon = 0.0
        qty%time = 0.0
        qty%solarTime = 0.0
        qty%solarZenith = 0.0
        qty%losAngle = 0.0
     else
        l1bItemName = TRIM(moduleName) // '.tpGeodLat'
        l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
        call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
                           l1bFlag, firstMAF=chunk%firstMafIndex, &
                           lastMAF=chunk%lastMafIndex )
        if ( l1bFlag == -1 ) &
           call MLSMessage ( MLSMSG_Error, ModuleName, MLSMSG_L1BRead//l1bItemName )
        qty%geodLat = l1bField%dpField(1,1:1,:)
        call DeallocateL1BData ( l1bField )

        l1bItemName = TRIM(moduleName) // '.tpLon'
        l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
        call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
                           l1bFlag, firstMAF=chunk%firstMafIndex, &
                           lastMAF=chunk%lastMafIndex )
        if ( l1bFlag == -1 ) &
           call MLSMessage ( MLSMSG_Error, ModuleName, MLSMSG_L1BRead//l1bItemName )
        qty%lon = l1bField%dpField(1,1:1,:)
        call DeallocateL1BData ( l1bField )

        l1bItemName = TRIM(moduleName) // '.tpGeodAngle'
        l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
        call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
                           l1bFlag, firstMAF=chunk%firstMafIndex, &
                           lastMAF=chunk%lastMafIndex )
        if ( l1bFlag == -1 ) &
           call MLSMessage ( MLSMSG_Error, ModuleName, MLSMSG_L1BRead//l1bItemName )
        qty%phi = l1bField%dpField(1,1:1,:)
        call DeallocateL1BData ( l1bField )

        l1bItemName = TRIM(moduleName) // '.tpSolarZenith'
        l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
        call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
                           l1bFlag, firstMAF=chunk%firstMafIndex, &
                           lastMAF=chunk%lastMafIndex )
        if ( l1bFlag == -1 ) &
           call MLSMessage ( MLSMSG_Error, ModuleName, MLSMSG_L1BRead//l1bItemName )
        qty%solarZenith = l1bField%dpField(1,1:1,:)
        call DeallocateL1BData ( l1bField )

        l1bItemName = TRIM(moduleName) // '.tpSolarTime'
        l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
        call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
                           l1bFlag, firstMAF=chunk%firstMafIndex, &
                           lastMAF=chunk%lastMafIndex )
        if ( l1bFlag == -1 ) &
           call MLSMessage ( MLSMSG_Error, ModuleName, MLSMSG_L1BRead//l1bItemName )
        qty%solarTime = l1bField%dpField(1,1:1,:)
        call DeallocateL1BData ( l1bField )

        l1bItemName = TRIM(moduleName) // '.tpLosAngle'
        l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
        call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
                           l1bFlag, firstMAF=chunk%firstMafIndex, &
                           lastMAF=chunk%lastMafIndex )
        if ( l1bFlag == -1 ) &
           call MLSMessage ( MLSMSG_Error, ModuleName, MLSMSG_L1BRead//l1bItemName )
        qty%losAngle = l1bField%dpField(1,1:1,:)
        call DeallocateL1BData ( l1bField )

        l1bItemName = "MAFStartTimeTAI"
        l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
        call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
                           l1bFlag, firstMAF=chunk%firstMafIndex, &
                           lastMAF=chunk%lastMafIndex )
        if ( l1bFlag == -1 ) &
           call MLSMessage ( MLSMSG_Error, ModuleName, MLSMSG_L1BRead//l1bItemName )
        do mafIndex = 1, noMAFs
           qty%time(1,mafIndex) = l1bField%dpField(1,1,mafIndex)
        end do
        call DeallocateL1BData ( l1bField )

     end if
  end subroutine ConstructMajorFrameQuantity

  ! ------------------------------------------------  myGetString  -----
  subroutine myGetString ( index, what, strip )
    ! Given a string index, Get the string or an error message
    use MLSStrings, only: writeIntsToChars
    use string_table, only: get_string, how_many_strings
    integer, intent(in)           :: index
    character(len=*), intent(out) :: what
    logical, intent(in), optional :: strip

    ! Executable code
    if ( index < 1 ) then
      what = '(string index < 1)'
    else if ( index > how_many_strings() ) then
      call writeIntsToChars( how_many_strings(), what )
      what = '(string index >' // trim(what) // ')'
    else
      call get_string ( index, what, strip )
    end if
  end subroutine myGetString


   ! -----------------------------------------------  Announce_Error  -----
   subroutine Announce_Error ( message, extra, severity )

      use LEXER_CORE, only: PRINT_SOURCE
      use OUTPUT_M, only: BLANKS, OUTPUT
      use TREE, only: SOURCE_REF
      use Intrinsic, only: LIT_INDICES
      use String_Table, only: DISPLAY_STRING
      use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR

      character (LEN=*), intent(in) :: MESSAGE
      integer, intent(in), optional :: EXTRA
      character(len=*), intent(in), optional :: SEVERITY ! 'nonfatal' or 'fatal'
      character(len=8) :: mySeverity

      mySeverity = 'fatal'
      if ( present(severity) ) then
         if (index('WwNn', severity(1:1)) > 0 ) mySeverity='warning'
      end if
      if ( mySeverity /= 'fatal' ) then
         call blanks(5)
         call output ( ' (warning) ' )
      else
         call blanks(5, fillChar='*')
         call output ( ' (fatal) ' )
      end if
      call output ( 'At ' )
      call output ( '(no lcf tree available)' )
      call output ( ': ' )
      call output ( message )
      if ( present ( extra ) ) &
         call display_string ( lit_indices ( extra ), strip=.true. )
      call output ( '', advance='yes' )
      if ( mySeverity == 'fatal') &
         call MLSMessage ( MLSMSG_Error, ModuleName, 'Problem in creating quantity' )
   end subroutine Announce_Error

!--------------------------- end bloc --------------------------------------
   logical function not_used_here()
   character (len=*), parameter :: IdParm = &
       "$Id: cfm_qtytemplate.f90,v 1.27 2016/05/12 18:17:22 pwagner Exp $"
   character (len=len(idParm)) :: Id = idParm
      not_used_here = (id(1:1) == ModuleName(1:1))
      print *, Id ! .mod files sometimes change if PRINT is added
   end function not_used_here
!---------------------------------------------------------------------------

end module

! $Log: cfm_qtytemplate.f90,v $
! Revision 1.27  2016/05/12 18:17:22  pwagner
! Use PointQuantityToHGrid from QuantityTemplates
!
! Revision 1.26  2016/01/07 17:54:02  pwagner
! Allocates crossAngles
!
! Revision 1.25  2015/08/05 20:21:29  pwagner
! Modified to compile properly with v4
!
! Revision 1.24  2013/07/26 16:48:15  pwagner
! Consistent with removal of SCVEL
!
! Revision 1.23  2011/12/23 22:56:12  honghanh
! Add AutoFillVector call to ForwardModel2 subroutine,
! to automatically add and fill isotope ratio in beta group
! (according to L2CF configuration file)
!
! Revision 1.22  2011/12/16 00:25:31  honghanh
! Improve documentation of CreateQtyTemplate
!
! Revision 1.21  2011/10/19 17:39:25  honghanh
! New CreateQtyTemplate API to use L1 maf instead of chunk.
!
! Revision 1.20  2011/03/24 21:13:20  honghanh
! Stop forcing caller of CreateQtyTemplate to give a filedatabase for quantities with signal
!
! Revision 1.19  2010/11/18 19:04:13  honghanh
! New example to run forward model with a single maf
!
! Revision 1.18  2010/11/03 18:34:46  honghanh
! Add qName as an optional argument to CreateQtyTemplate.
! This is to help debugging process.
!
! Revision 1.17  2010/07/07 21:02:05  honghanh
! Bug fix in ConstructQuantityTemplate
!
! Revision 1.16  2010/06/30 17:45:12  pwagner
! NAG happy only if continued comment begins with ampsnd
!
! Revision 1.15  2010/06/30 08:11:25  honghanh
! Fix bug for creating major frame quantity
!
! Revision 1.14  2010/06/29 16:40:23  honghanh
! Remove all function/subroutine and user type forwarding from
! all CFM modules except for from cfm.f90
!
! Revision 1.13  2010/06/29 15:53:45  honghanh
! Add copyright comments and support for CVS log in the file
!
@


1.27
log
@Use PointQuantityToHGrid from QuantityTemplates
@
text
@d15 1
d153 1
a153 1
   end function
d156 2
a157 1
   type(QuantityTemplate_T) function CreateQtyTemplate_chunk (quantityType, filedatabase, chunk, &
d206 8
a213 1
      ! Executables
d244 1
d389 1
a389 1
         ! Setup the quantity template
d391 1
d396 1
d399 2
d436 14
a449 1
   end function
d668 22
a689 1
  end subroutine
d731 1
a731 1
       "$Id: cfm_qtytemplate.f90,v 1.26 2016/01/07 17:54:02 pwagner Exp $"
d741 3
@


1.26
log
@Allocates crossAngles
@
text
@d18 2
a19 1
                                DestroyQuantityTemplateDatabase
d170 1
a170 1
      type(HGrid_T), intent(in), optional :: ahgrid
d382 2
a383 1
            call PointQuantityToHGrid (ahgrid, qty)
d424 2
a425 2
  ! ----------------------------------  PointQuantityToHGrid  -----
  subroutine PointQuantityToHGrid ( hGrid, qty )
d467 1
a467 1
  end subroutine PointQuantityToHGrid
d683 1
a683 1
       "$Id: cfm_qtytemplate.f90,v 1.25 2015/08/05 20:21:29 pwagner Exp $"
d693 3
@


1.25
log
@Modified to compile properly with v4
@
text
@d439 2
d454 1
d463 1
d681 1
a681 1
       "$Id: cfm_qtytemplate.f90,v 1.24 2013/07/26 16:48:15 pwagner Exp $"
d691 3
@


1.24
log
@Consistent with removal of SCVEL
@
text
@d209 1
d213 1
a230 1
      qty%sharedHGrid = .false.
a467 1
    qty%sharedHGrid = .false.
d469 12
a480 9
    nullify( qty%frequencies, qty%geodLat, qty%lon, qty%time, qty%solarTime, &
      & qty%solarZenith, qty%losAngle ) ! Lest we deallocate a database entry
    call Allocate_test ( qty%phi, 1, 1, 'qty%phi(1,1)', ModuleName )
    call Allocate_test ( qty%geodLat, 1, 1, 'qty%geodLat(1,1)', ModuleName )
    call Allocate_test ( qty%lon, 1, 1, 'qty%lon(1,1)', ModuleName )
    call Allocate_test ( qty%time, 1, 1, 'qty%time(1,1)', ModuleName )
    call Allocate_test ( qty%solarTime, 1, 1, 'qty%solarTime(1,1)', ModuleName )
    call Allocate_test ( qty%solarZenith, 1, 1, 'qty%solarZenith(1,1)', ModuleName )
    call Allocate_test ( qty%losAngle, 1, 1, 'qty%losAngle(1,1)', ModuleName )
d488 1
a498 1
    nullify(qty%surfs) ! Lest we deallocate a database entry
d542 1
a542 1
      & noChans=noChans, sharedHGrid=.false., sharedVGrid=.false. )
d677 1
a677 1
       "$Id: cfm_qtytemplate.f90,v 1.23 2011/12/23 22:56:12 honghanh Exp $"
d687 3
@


1.23
log
@Add AutoFillVector call to ForwardModel2 subroutine,
to automatically add and fill isotope ratio in beta group
(according to L2CF configuration file)
@
text
@d45 1
a45 1
      L_SCANRESIDUAL, L_SCATTERINGANGLE, L_SCECI, L_SCVEL, L_SCVELECI, &
d674 1
a674 1
       "$Id: cfm_qtytemplate.f90,v 1.22 2011/12/16 00:25:31 honghanh Exp $"
d684 5
@


1.22
log
@Improve documentation of CreateQtyTemplate
@
text
@d63 1
a63 1
            InitQuantityTemplates, unitstable, propertyTable, noProperties, &
d67 2
a68 1
            p_suppressChannels, p_module, p_molecule, p_fGridOptional
d193 1
a193 1
      logical, dimension(noProperties) :: PROPERTIES ! Properties for this quantity type
d674 1
a674 1
       "$Id: cfm_qtytemplate.f90,v 1.21 2011/10/19 17:39:25 honghanh Exp $"
d684 3
@


1.21
log
@New CreateQtyTemplate API to use L1 maf instead of chunk.
@
text
@d98 9
d133 3
d673 1
a673 1
       "$Id: cfm_qtytemplate.f90,v 1.20 2011/03/24 21:13:20 honghanh Exp $"
d683 3
@


1.20
log
@Stop forcing caller of CreateQtyTemplate to give a filedatabase for quantities with signal
@
text
@d80 4
d92 48
d141 1
a141 1
   type(QuantityTemplate_T) function CreateQtyTemplate (quantityType, filedatabase, chunk, &
d661 1
a661 1
       "$Id: cfm_qtytemplate.f90,v 1.19 2010/11/18 19:04:13 honghanh Exp $"
d671 3
@


1.19
log
@New example to run forward model with a single maf
@
text
@a232 3
         if (.not. (present(filedatabase) .and. present(chunk))) &
            call MLSMessage(MLSMSG_Error, ModuleName, &
            'Need filedatabase and chunk to check for good signal data')
a234 2
         !??? Here we would do intelligent stuff to work out which bands
         !??? are present, for the moment choose the first
d237 1
a237 1
         if ( .not. associated(signalInds) ) then ! A parse error occurred
d241 15
a255 2
         if ( size(signalInds) == 1 .or. .not. associated(filedatabase) ) then
            signal = signalInds(1)
d257 1
a257 10
            ! Seek a signal with any precision values !< 0
            do s_index=1, size(signalInds)
              if ( AnyGoodSignalData ( signalInds(s_index), sideband, &
                & filedatabase, chunk) ) exit
            end do
            if ( s_index > size(signalInds) ) then
              signal = signalInds(1)
            else
              signal = signalInds(s_index)
            end if
d259 1
d609 1
a609 1
       "$Id: cfm_qtytemplate.f90,v 1.18 2010/11/03 18:34:46 honghanh Exp $"
d619 3
@


1.18
log
@Add qName as an optional argument to CreateQtyTemplate.
This is to help debugging process.
@
text
@d136 1
a150 1
      qty%regular = .true.
d609 1
a609 1
       "$Id: cfm_qtytemplate.f90,v 1.17 2010/07/07 21:02:05 honghanh Exp $"
d619 4
@


1.17
log
@Bug fix in ConstructQuantityTemplate
@
text
@d56 1
a56 1
    use String_Table, only: DISPLAY_STRING
d91 1
a91 1
        qRadiometer, qBadValue) result(qty)
d125 2
a139 1
      qty%name = 0
d339 6
d609 1
a609 1
       "$Id: cfm_qtytemplate.f90,v 1.16 2010/06/30 17:45:12 pwagner Exp $"
d619 3
@


1.16
log
@NAG happy only if continued comment begins with ampsnd
@
text
@d443 1
a443 2
     integer :: hdfVersion, noMafs, l1bFlag, mafIndex, mifIndex, noSurfs
     real(r8), parameter :: SIXTH = 1.0_r8 / 6.0_r8
d458 1
a462 1
     noSurfs=l1bField%maxMIFs
d555 1
a555 4
           do mifIndex = 1, noSurfs
              qty%time(mifIndex,mafIndex) = &
              l1bField%dpField(1,1,mafIndex) + (mifIndex-1) * sixth
           end do
d602 1
a602 1
       "$Id: cfm_qtytemplate.f90,v 1.15 2010/06/30 08:11:25 honghanh Exp $"
d612 3
@


1.15
log
@Fix bug for creating major frame quantity
@
text
@d305 2
a306 2
            call MLSMessage(MLSMSG_Error, moduleName, "Need both chunk and filedatabase &
            to create major frame quantity")
d606 1
a606 1
       "$Id: cfm_qtytemplate.f90,v 1.14 2010/06/29 16:40:23 honghanh Exp $"
d616 3
@


1.14
log
@Remove all function/subroutine and user type forwarding from
all CFM modules except for from cfm.f90
@
text
@d16 1
a16 1
   use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d57 1
a57 1
    use MLSCommon, only: r8
a60 1
    use MLSCommon, only: MLSFile_T
d62 1
a62 1
            ConstructMajorFrameQuantity, ConstructMinorFrameQuantity, &
a125 1
      type (QuantityTemplate_T), dimension(:), pointer :: MifGeolocation
d231 2
a232 2
     if (present(qSignal)) then
          if (.not. (present(filedatabase) .and. present(chunk))) &
d235 5
a239 5
          nullify ( channels, signalInds )
          signalString = qSignal
          !??? Here we would do intelligent stuff to work out which bands
          !??? are present, for the moment choose the first
          call parse_Signal ( signalString, signalInds, &
d241 1
a241 1
          if ( .not. associated(signalInds) ) then ! A parse error occurred
d244 2
a245 2
          end if
          if ( size(signalInds) == 1 .or. .not. associated(filedatabase) ) then
d247 1
a247 1
          else
d258 7
a264 7
          end if
          call deallocate_test ( signalInds, 'signalInds', ModuleName )
          ! if the user has pass in the wrong instrumentModule or radiometer
          ! just silently correct it, for simplicity.
          instrumentModule = GetModuleFromSignal(signal)
          radiometer = GetRadiometerFromSignal(signal)
     end if
a306 4
         ! We have to construct this because ConstructMajorFrameQuantity
         ! doesn't work with mifGeolocation. The proper fix should be
         ! ConstructMajorFrameQuantity, but I've got no time to test that.
         call ConstructMIFGeolocation (mifGeoLocation, filedatabase, chunk)
d308 2
a309 3
         call ConstructMajorFrameQuantity (chunk, instrumentModule, qty, &
              noChans, mifGeoLocation)
         call DestroyQuantityTemplateDatabase (mifGeoLocation)
d428 49
a476 2
  ! -----------------------------------------------  Announce_Error  -----
  subroutine Announce_Error ( message, extra, severity )
d478 90
a567 6
    use LEXER_CORE, only: PRINT_SOURCE
    use OUTPUT_M, only: BLANKS, OUTPUT
    use TREE, only: SOURCE_REF
    use Intrinsic, only: LIT_INDICES
    use String_Table, only: DISPLAY_STRING
    use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
d569 33
a601 26
    character (LEN=*), intent(in) :: MESSAGE
    integer, intent(in), optional :: EXTRA
    character(len=*), intent(in), optional :: SEVERITY ! 'nonfatal' or 'fatal'
    character(len=8) :: mySeverity

    mySeverity = 'fatal'
    if ( present(severity) ) then
      if (index('WwNn', severity(1:1)) > 0 ) mySeverity='warning'
    end if
    if ( mySeverity /= 'fatal' ) then
      call blanks(5)
      call output ( ' (warning) ' )
    else
      call blanks(5, fillChar='*')
      call output ( ' (fatal) ' )
    end if
    call output ( 'At ' )
    call output ( '(no lcf tree available)' )
    call output ( ': ' )
    call output ( message )
    if ( present ( extra ) ) &
       call display_string ( lit_indices ( extra ), strip=.true. )
    call output ( '', advance='yes' )
    if ( mySeverity == 'fatal') &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Problem in creating quantity' )
  end subroutine Announce_Error
d603 1
a603 1
  !--------------------------- end bloc --------------------------------------
d606 1
a606 1
       "$Id: cfm_qtytemplate.f90,v 1.13 2010/06/29 15:53:45 honghanh Exp $"
d616 4
@


1.13
log
@Add copyright comments and support for CVS log in the file
@
text
@d18 1
a18 2
                                DestroyQuantityTemplateDatabase, &
                                AddQuantityTemplateToDatabase, Dump
d77 1
a77 4
   public :: CreateQtyTemplate, DestroyQuantityTemplateDatabase
   public :: AddQuantityTemplateToDatabase
   public :: QuantityTemplate_T, Dump
   public :: InitQuantityTemplates, ConstructMIFGeolocation
d475 1
a475 1
       "$Id: cfm_qtytemplate.f90,v 1.1 2010/05/22 18:53:33 honghanh Exp $"
d485 3
@


1.12
log
@Fill elevation offsets and limb sideband fractions
@
text
@d1 10
d487 2
@


1.11
log
@Delete an unnecessary comment
@
text
@d94 2
a95 1
      ! the z-coordinate samples of the spacecraft's path
d98 1
d101 1
@


1.10
log
@Add RCS info
@
text
@a82 2
   ! This subroutine design is prone to bugs, I'll fix it when I got some time. -haley

@


1.9
log
@Change type of quantityType and molecule to integer
Fix Announce_error
Remove mifGeolocation from dummy argument list
Assign instrument module, and minorFrame value to the quantity at the end of the subroutine
@
text
@d75 5
a79 1
   character(len=20) :: ModuleName = "CFM_QuantityTemplate"
d465 10
@


1.8
log
@ConstructMinorFrameQuantity accepts filedatabase and chunk as optional argument
@
text
@d45 1
a45 2
      PHYQ_VMR, PHYQ_ZETA
    use Intrinsic, only: LIT_INDICES
d53 1
a53 1
    use ConstructQuantityTemplates, only : AnyGoodSignalData, GetQtyTypeIndex, &
d55 1
a55 2
            InitQuantityTemplates, &
            unitstable, propertyTable, noProperties, &
d82 1
a82 1
   type(QuantityTemplate_T) function CreateQtyTemplate (type, filedatabase, chunk, &
d84 3
a86 5
        qRadiometer, qBadValue, mifGeolocation) result(qty)
      ! a case-insensitive string, one of the allowable strings for type
      ! listed in the "Callable Forward Model Interface Requirements Document" (from
      ! now on will be called CFM document).
      character(len=*), intent(in) :: type
d100 2
a101 2
      ! a case-insensitive string, one of the molecules listed in the CFM document.
      character(len=*), optional :: qMolecule
a114 4
      type (QuantityTemplate_T), dimension(:), intent(in), optional, target :: &
      & MifGeolocation ! TARGET attribute needed so pointers to MifGeolocation
                       ! created at lower levels in the call tree don't become
                       ! undefined when those procedures return.
d116 1
d123 2
a124 1
      integer :: quantityType, noChans, sideband, signal, radiometer
d128 1
a128 2
      qty%instrumentModule = 0
      call GetQtyTypeIndex(type, quantityType)
d151 5
a155 3
      qty%sharedVGrid = .true.
      qty%sharedHGrid = .true.
      qty%sharedFGrid = .true.
d166 1
a166 1
           & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
d170 1
a170 1
           & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
d172 6
d180 1
a180 1
         & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
d183 1
a183 1
         call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
d188 1
a188 1
            & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
d193 2
a194 2
           & call Announce_error ( 0, 'Expecting log pressure coordinates for', &
           & qty%quantityType )
d198 1
a198 1
           & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
d203 1
a203 1
           & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
a206 3
     ! Set up a non major/minor frame quantity
      qty%minorFrame = .not. present(ahgrid)

d208 1
a208 1
         call GetModuleIndex (qInstModule, qty%instrumentModule)
d213 1
a213 1
         qty%instrumentModule = GetModuleFromRadiometer(radiometer)
d253 1
a253 1
          qty%instrumentModule = GetModuleFromSignal(signal)
d259 2
a260 2
         if ( .not. IsModuleSpacecraft ( qty%instrumentModule ) ) &
           & call Announce_error ( 0, 'Module must be spacecraft' )
d266 3
a268 1
         qty%frequencies => afgrid%values
d286 2
a287 3
      if (qty%minorFrame) then
      if (.not. present(mifGeoLocation) .and. &
          .not. (present(filedatabase) .and. present(chunk))) &
d291 1
a291 1
         call ConstructMinorFrameQuantity (qty%instrumentModule, &
d293 1
a293 2
              filedatabase=filedatabase, chunk=chunk, &
              mifGeoLocation=mifGeoLocation)
d295 7
a301 4
         if (.not. present(mifGeoLocation)) &
            call MLSMessage(MLSMSG_Error, moduleName, "Missing needed mifGeoLocation")
         if (.not. present(chunk)) &
            call MLSMessage(MLSMSG_Error, moduleName, "Need chunk to create major frame quantity")
d303 1
a303 1
         call ConstructMajorFrameQuantity (chunk, qty%instrumentModule, qty, &
d305 1
d317 3
a319 1
            qty%surfs => avGrid%surfs
d331 1
a331 1
         call GetMoleculeIndex(qMolecule, qty%molecule)
d340 2
d360 21
a380 7
    qty%phi => hGrid%phi
    qty%geodLat => hGrid%geodLat
    qty%lon => hGrid%lon
    qty%time => hGrid%time
    qty%solarTime => hGrid%solarTime
    qty%solarZenith => hGrid%solarZenith
    qty%losAngle => hGrid%losAngle
d425 1
a425 1
  subroutine Announce_Error ( where, message, extra, severity )
a433 1
    integer, intent(in) :: WHERE   ! Tree node where error was noticed
d451 1
a451 5
    if ( where > 0 ) then
      call print_source ( source_ref(where) )
    else
      call output ( '(no lcf tree available)' )
    end if
d454 2
a455 1
    if ( present ( extra ) ) call display_string ( lit_indices ( extra ), strip=.true. )
@


1.7
log
@Add more comments to everything
@
text
@d292 4
a295 2
         call ConstructMinorFrameQuantity (filedatabase, chunk, qty%instrumentModule, &
              qty, noChans=noChans, regular=qty%regular, mifGeoLocation=mifGeoLocation)
@


1.6
log
@Conformed all module names to end with _m, changed file names to all
lowercase, add comments
@
text
@d83 1
a83 1
   ! Creating a quantity based on the optional input this subroutine is provided with.
d87 3
d91 1
d93 2
d96 1
d98 1
d100 1
d102 1
d104 1
d106 1
d108 2
d111 3
d116 2
@


1.5
log
@Adjustments made to add startTime and endTime as inputs to CFM_MLSSetup.
Tested successfully
@
text
@d1 1
a1 1
module CFM_QuantityTemplate
d82 2
d113 1
d268 5
d278 2
d421 1
a421 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Problem in Construct' )
@


1.4
log
@Correction and test for creating a quantity template
@
text
@d7 3
a9 1
   use QuantityTemplates, only: QuantityTemplate_T, NullifyQuantityTemplate
d55 8
a62 1
            ConstructMajorFrameQuantity, ConstructMinorFrameQuantity
a66 5
    use ConstructQuantityTemplates, only: unitstable, propertyTable, noProperties, &
          p_majorFrame, p_minorFrame, p_mustBeZeta, p_fGrid, p_hGrid, &
          p_vgrid, p_radiometer, p_radiometerOptional, p_scModule, &
          p_signal, p_signalOptional, p_xyz, p_matrix3x3, p_flexibleVHGrid, &
          p_suppressChannels, p_module, p_molecule, p_fGridOptional
d70 5
a74 1
   public :: CreateQtyTemplate
a263 3
      if ((qty%minorFrame .or. properties(p_majorFrame)) .and. &
         .not. present(mifGeoLocation)) &
         call MLSMessage(MLSMSG_Error, moduleName, "Missing needed mifGeoLocation")
d268 2
@


1.3
log
@Example for filling vector
@
text
@d73 1
d76 1
a76 1
        qRadiometer, mifGeolocation) result(qty)
d89 1
d101 1
d105 1
a105 1
      call GetQtyTypeIndex(type, qty%quantityType)
d113 1
a113 1
      qty%noChans = 1
d115 1
a115 1
      qty%radiometer = 0
d118 2
a119 2
      qty%sideband = 0
      qty%signal = 0
d131 1
d136 1
a136 1
      properties = propertyTable(:, qty%quantityType)
d142 1
a142 1
           & present(ahGrid) ) ) // ' hGrid for quantity type ', qty%quantityType, &
d146 1
a146 1
           & present(avGrid) ) ) // ' vGrid for quantity type ', qty%quantityType )
d150 1
a150 1
         & present(qMolecule) ) ) // ' molecule for quantity type ', qty%quantityType )
d153 1
a153 1
         & present(qInstModule) ) ) // ' module for quantity type ', qty%quantityType )
d158 1
a158 1
            & present(qSignal) ) ) // ' signal for quantity type ', qty%quantityType )
d168 1
a168 1
           & present(aFGrid) ) ) // ' fGrid for quantity type ', qty%quantityType )
d173 1
a173 1
           & present(qRadiometer) ) ) // ' radiometer for quantity type ', qty%quantityType )
a178 2
      qty%unit = unitsTable(qty%quantityType)

d183 1
a183 1
         call GetRadiometerIndex(qRadiometer, qty%radiometer)
d185 1
a185 1
         qty%instrumentModule = GetModuleFromRadiometer(qty%radiometer)
a189 4
      if (present(qMolecule)) then
         call GetMoleculeIndex(qMolecule, qty%molecule)
      end if

d193 2
a194 2
   
      if (present(qSignal)) then
d203 1
a203 1
            & sideband=qty%sideband, channels=channels )
d209 1
a209 1
            qty%signal = signalInds(1)
d213 1
a213 1
              if ( AnyGoodSignalData ( signalInds(s_index), qty%sideband, &
d217 1
a217 1
              qty%signal = signalInds(1)
d219 1
a219 1
              qty%signal = signalInds(s_index)
d225 3
a227 3
          qty%instrumentModule = GetModuleFromSignal(qty%signal)
          qty%radiometer = GetRadiometerFromSignal(qty%signal)
      end if
d239 1
a239 1
         qty%noChans = afgrid%noChans
d243 1
a243 1
         qty%noChans = 3
d247 1
a247 1
         qty%noChans = 9
d250 1
a250 1
         signalInfo = GetSignal(qty%signal)
d252 1
a252 1
         qty%noChans = size(signalInfo%frequencies)
d261 1
a261 1
              qty, noChans=qty%noChans, regular=qty%regular, mifGeoLocation=mifGeoLocation)
d265 1
a265 1
              qty%noChans, mifGeoLocation)
a267 5
         nullify(qty%surfs) ! sharedVGrid = .true.
         nullify(qty%phi, qty%geodLat, qty%lon, qty%time, qty%solarTime, &
                 qty%solarZenith, qty%losAngle) ! sharedHGrid=.true.
         nullify(qty%surfIndex, qty%chanIndex) ! regular=.true.

d283 7
a289 1
         qty%instanceLen = qty%noSurfs * qty%noChans
d292 7
@


1.2
log
@Complete example for creating quantity templates
@
text
@d28 1
a28 1
      L_MIFDEADTIME, &
d52 2
a53 1
    use ConstructQuantityTemplates, only : AnyGoodSignalData
d55 9
a63 2
    use MLSSignals_m, only: GetModuleFromSignal, GetRadiometerFromSignal
 
d66 1
a66 1
   public :: CreateQtyTemplate, InitQuantityTemplates
a68 27
  ! The various properties has/can have
  integer, parameter :: NEXT = -1
  integer, parameter :: P_CHUNKED            = 1
  integer, parameter :: P_MAJORFRAME         = P_CHUNKED + 1
  integer, parameter :: P_MINORFRAME         = P_MAJORFRAME + 1
  integer, parameter :: P_MUSTBEZETA         = P_MINORFRAME + 1
  integer, parameter :: P_FGRID              = P_MUSTBEZETA + 1
  integer, parameter :: P_FGRIDOPTIONAL      = P_FGRID + 1
  integer, parameter :: P_FLEXIBLEVHGRID     = P_FGRIDOPTIONAL + 1
  integer, parameter :: P_HGRID              = P_FLEXIBLEVHGRID + 1
  integer, parameter :: P_MODULE             = P_HGRID + 1
  integer, parameter :: P_MOLECULE           = P_MODULE + 1
  integer, parameter :: P_SGRID              = P_MOLECULE + 1
  integer, parameter :: P_VGRID              = P_SGRID + 1
  integer, parameter :: P_RADIOMETER         = P_VGRID + 1
  integer, parameter :: P_RADIOMETEROPTIONAL = P_RADIOMETER + 1
  integer, parameter :: P_REFLECTOR          = P_RADIOMETEROPTIONAL + 1
  integer, parameter :: P_SCMODULE           = P_REFLECTOR + 1
  integer, parameter :: P_SIGNAL             = P_SCMODULE + 1
  integer, parameter :: P_SIGNALOPTIONAL     = P_SIGNAL + 1
  integer, parameter :: P_SUPPRESSCHANNELS   = P_SIGNALOPTIONAL + 1
  integer, parameter :: P_XYZ                = P_SUPPRESSCHANNELS + 1
  integer, parameter :: P_MATRIX3X3          = P_XYZ + 1

  integer, parameter :: NOPROPERTIES = P_MATRIX3X3


a69 2
   integer, save, dimension (first_lit : last_lit) :: unitsTable
   logical, dimension(noProperties, first_lit : last_lit), save :: propertyTable
d74 2
a75 2
        avgrid, ahgrid, qInstModule, qMolecule, qLogBasis, qMinValue, qSignal) &
        & result(qty)
d81 1
d87 5
d97 2
a98 1
      integer :: s_index
d104 1
a104 1
      qty%fGridIndex = 0
d156 14
a169 15

    ! Set up a non major/minor frame quantity
      if (present(avGrid)) then
         qty%verticalCoordinate = avGrid%verticalCoordinate
         qty%surfs => avGrid%surfs
         qty%noSurfs = avgrid%noSurfs
      else
         call SetupEmptyVGridForQuantity(qty)
      end if 

      if (present(ahgrid)) then
         qty%noInstances = ahgrid%noprofs
         call PointQuantityToHGrid (ahgrid, qty)
      else
         call SetupEmptyHGridForQuantity(qty)
d172 1
d180 7
d225 2
a229 1
   end function
d231 58
a288 32
  ! ----------------------------------------------  GetQtyTypeIndex  -----
  subroutine GetQtyTypeIndex(string_text, QtyType)
    use Intrinsic, only: LIT_INDICES
    use MLSStrings, only: LowerCase
    use STRING_TABLE, only: GET_STRING, DISPLAY_STRING
    ! Returns the lit index,  given QtyType name in mixed case
    ! Returns 0 if QtyType name not found
    ! (inverse function: GetQtyTypeName)
    integer, intent(out) :: QtyType
    character (len=*), intent(in) :: string_text
    ! Local variables
    character (len=len(string_text))             :: string_test
    do QtyType=first_lit, last_lit
      ! Skip if not quantity type
      if ( .not. any(PROPERTYTABLE(:, QtyType) ) ) cycle
      call get_string ( lit_indices(QtyType), string_test, strip=.true. )
      if ( LowerCase(trim(string_text)) == LowerCase(trim(string_test))) &
        & return
    end do
    QtyType = 0
  end subroutine GetQtyTypeIndex

  ! ----------------------------------------------- InitQuantityTemplates ----
  subroutine InitQuantityTemplates
    ! This routine initializes the quantity template properties
    ! This is the routine one needs to update when one introduces a new quantity type.

    ! Local variables
    integer :: I                        ! Loop counter
    integer, dimension(0), parameter :: NONE = (/ ( 0, i=1,0 ) /)
    logical :: VALID                    ! Flag
    character(len=132) :: MESSAGE       ! An error message
d290 2
a291 2
    ! Executable code
    ! Basically here, we're going to go through and populate the various tables
d293 1
a293 193
    propertyTable = .false.
    unitsTable = 0

    call DefineQtyTypes ( (/ &
      l_adopted, phyq_dimensionless, none, next, &
      l_baseline, phyq_temperature, p_flexibleVHGrid, p_fGrid, p_radiometerOptional, &
                  p_signalOptional, p_suppressChannels, p_mustBeZeta, next, &
      l_boundaryPressure, phyq_pressure, p_hGrid, next, &
      l_calSidebandFraction, phyq_dimensionless, p_signal, next, &
      l_chisqBinned, phyq_dimensionless, p_hGrid, p_vGrid, &
                     p_signal, p_suppressChannels, p_mustBeZeta, next, &
      l_chisqChan, phyq_dimensionless, p_majorFrame, p_signal, next, &
      l_chisqMMAF, phyq_dimensionless, p_majorFrame, p_signal, &
                   p_suppressChannels, next, &
      l_chisqMMIF, phyq_dimensionless, p_minorFrame, p_signal, &
                   p_suppressChannels, next, &
      l_cloudExtinction, phyq_dimensionless, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_cloudIce, phyq_IceDensity, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_cloudInducedRadiance, phyq_temperature, p_minorFrame, p_signal, next, &
      l_cloudMinMax, phyq_temperature, p_hGrid, p_vGrid, p_mustbezeta, &
                     p_signal, p_suppressChannels, next, &
      l_cloudRadSensitivity, phyq_temperature, p_minorFrame, p_signal, next, &
      l_cloudTemperature, phyq_temperature, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_cloudWater, phyq_dimensionless, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_columnAbundance, phyq_colmabundance, p_hGrid, p_molecule, next, &
      l_dnwt_abandoned, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_ajn, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_axmax, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_cait, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_chisqminnorm, phyq_dimensionless, p_vGrid /) )

    call DefineQtyTypes ( (/ &
      l_dnwt_chisqnorm, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_chisqratio, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_count, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_diag, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_dxdx, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_dxdxl, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_dxn, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_dxnl, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_flag, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_fnmin, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_fnorm, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_gdx, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_gfac, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_gradn, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_sq, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_sqt, phyq_dimensionless, p_vGrid, next, &
      l_geolocation, phyq_dimensionless, p_majorframe, p_module, next, &
      l_earthRadius, phyq_length, p_hGrid, next, &
      l_earthRefl, phyq_dimensionless, none /) )

    call DefineQtyTypes ( (/ &
      l_ecrToFOV, phyq_dimensionless, p_minorFrame, p_module, p_matrix3x3, next, &
      l_effectiveOpticalDepth, phyq_dimensionless, p_minorFrame, p_signal, next, &
      l_elevOffset, phyq_angle, p_signal, next, &
      l_extinction, phyq_extinction, p_hGrid, p_vGrid, p_fGrid, p_radiometer, &
                    p_mustBeZeta, next, &
      l_extinctionv2, phyq_extinction, p_hGrid, p_vGrid, p_fGrid, p_radiometer, &
                      p_mustBeZeta, next, &
      l_fieldAzimuth, phyq_angle, p_hGrid, p_vGrid, next, &
      l_fieldElevation, phyq_angle, p_hGrid, p_vGrid, next, &
      l_fieldStrength, phyq_gauss, p_hGrid, p_vGrid, next, &
      l_geodAltitude, phyq_length, p_minorFrame, p_module, next, &
      l_gph, phyq_length, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_heightOffset, phyq_length, p_hGrid, p_vGrid, next, &
      l_isotopeRatio, phyq_dimensionless, p_molecule, next, &
      l_iwc, phyq_icedensity, p_hGrid, p_vGrid, next, &
      l_jacobian_cols, phyq_dimensionless, p_vGrid, next, &
      l_jacobian_rows, phyq_dimensionless, p_vGrid, next /) )

    call DefineQtyTypes ( (/ &
      l_l1bMAFBaseline, phyq_temperature, p_majorFrame, p_signal, next, &
      l_l1bMIF_TAI, phyq_time, p_minorFrame, p_scmodule, next, &
      l_limbSidebandFraction, phyq_dimensionless, p_signal, next, &
      l_lineCenter, phyq_frequency, p_hGrid, p_vGrid, p_molecule, next, &
      l_lineWidth,  phyq_frequency, p_hGrid, p_vGrid, p_molecule, next, &
      l_lineWidth_TDep, phyq_dimensionless, p_hGrid, p_vGrid, p_molecule, next, &
      p_hGrid, p_vGrid, next, &
      l_losTransFunc, phyq_dimensionless, p_minorFrame, p_sGrid, p_module, next, &
      l_losVel, phyq_dimensionless, p_minorFrame, p_module, next, &
      l_magneticField, phyq_gauss, p_vGrid, p_hGrid, p_xyz, p_mustBeZeta, next, &
      l_massMeanDiameterIce, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_massMeanDiameterWater, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_mifDeadTime, phyq_time, next, &
      l_noRadsBinned, phyq_dimensionless, p_vGrid, p_hGrid, &
                      p_signal, p_suppressChannels, p_mustBeZeta, next, &
      l_noRadsPerMIF, phyq_dimensionless, p_minorFrame, p_signal, &
                      p_suppressChannels, next, &
      l_noiseBandwidth, phyq_frequency, p_signal, next, &
      l_numGrad, phyq_dimensionless, p_vGrid, next, &
      l_numJ, phyq_dimensionless, p_vGrid, next, &
      l_numNewt, phyq_dimensionless, p_vGrid, next /) )

    call DefineQtyTypes ( (/ &
      l_opticalDepth, phyq_dimensionless, p_minorFrame, p_signal, next, &
      l_orbitInclination, phyq_angle, p_minorFrame, p_scModule, next, &
      l_phaseTiming, phyq_dimensionless, p_vGrid, next, &
      l_phiTan, phyq_angle, p_minorFrame, p_module, next, &
      l_ptan, phyq_zeta, p_minorFrame, p_module, next, &
      l_quality, phyq_dimensionless, p_hGrid, next, &
      l_radiance, phyq_temperature, p_minorFrame, p_signal, next, &
      l_refltemp, phyq_temperature, p_majorFrame, p_reflector, p_module, next, &
      l_refltrans, phyq_dimensionless, p_signal, p_reflector, next, &
      l_reflrefl, phyq_dimensionless, p_signal, p_reflector, next, &
      l_reflspill, phyq_temperature, p_signal, p_majorframe, p_reflector, next, &
      l_refGPH, phyq_length, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_rhi, phyq_dimensionless, p_hGrid, p_vGrid, p_molecule, p_mustBeZeta, next, &
      l_scECI, phyq_length, p_minorFrame, p_scModule, p_xyz, next, &
      l_scGeocAlt, phyq_length, p_minorFrame, p_scModule, next, &
      l_scVel, phyq_velocity, p_minorFrame, p_scModule, p_xyz, next, &
      l_scVelECI, phyq_velocity, p_minorFrame, p_scModule, p_xyz, next, &
      l_scVelECR, phyq_velocity, p_minorFrame, p_scModule, p_xyz, next, &
      l_scanResidual, phyq_length, p_minorFrame, p_module, next, &
      l_scatteringAngle, phyq_angle, p_vGrid, next, &
      l_singleChannelRadiance, phyq_temperature, p_minorFrame, p_signal, &
                               p_suppressChannels, next, &
      l_sizeDistribution, phyq_dimensionless, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_spaceRadiance, phyq_temperature, none, next, &
      l_status, phyq_dimensionless, p_hGrid, next, &
      l_strayRadiance, phyq_temperature, p_signal, p_majorFrame, next, &
      l_surfaceHeight, phyq_length, p_hGrid, next, &
      l_surfaceType, phyq_dimensionless, p_hGrid, next, &
      l_systemTemperature, phyq_temperature, p_signal, next, &
      l_temperature, phyq_temperature, p_hGrid, p_vGrid, p_mustbezeta, next, &
      l_totalPowerWeight, phyq_dimensionless, p_signal, next, &
      l_tngtECI, phyq_length, p_minorFrame, p_module, p_xyz, next, &
      l_tngtGeocAlt, phyq_length, p_minorFrame, p_module, next, &
      l_tngtGeodAlt, phyq_length, p_minorFrame, p_module, next, &
      l_TScat, phyq_temperature, p_hGrid, p_signal, p_vGrid, next, &
      l_vmr, phyq_vmr, p_hGrid, p_vGrid, p_fGridOptional, &
             p_molecule, p_radiometerOptional, p_mustbezeta, next /) )

    ! Do a bit of checking
    do i = first_lit, last_lit
      valid = .true.
      message =  ''
      ! Check it's not both major and minor frame
      if ( count ( propertyTable ( (/ p_minorFrame, p_majorFrame /), i ) ) > 1 ) then
        valid = .false.
        message = "Quantity cannot be both major and minor frame"
      end if
      ! Check that we can identify the module for major/minor frame
      if ( ( propertyTable ( p_minorFrame, i ) .or. &
        &    propertyTable ( p_majorFrame, i ) ) .and. &
        & .not. any ( propertyTable ( &
        & (/ p_radiometer, p_module, p_scModule, p_signal /), i ) ) ) then
        valid = .false.
        message = "Badly defined major/minor frame quantity"
      end if
      ! Check that mustBeZeta quantities have a vGrid
      if ( propertyTable ( p_mustBeZeta, i ) .and. .not. &
        & ( propertyTable ( p_vGrid, i ) .or. propertyTable ( p_flexibleVHGrid, i ) ) ) then
        valid = .false.
        message = "Quantity must have vGrid if it must be on log-pressure"
      end if
      ! Print out any message
      if ( .not. valid ) then
        call output ( "Offending quantity: " )
        call display_string ( lit_indices ( i ), strip=.true., advance='yes' )
        call MLSMessage ( MLSMSG_Error, ModuleName, message )
      end if
    end do
  contains
    ! --------------------------- Internal subroutine
    subroutine DefineQtyTypes ( info )
      integer, dimension(:), intent(in) :: INFO
      ! Local variables
      integer :: I                      ! Location
      integer :: QTYTYPE                ! Index
      ! Executable code
      qtyType = 0
      i = 1
      do while ( i <= size(info) )
        if ( qtyType == 0 ) then
          qtyType = info ( i )
          propertyTable ( :, qtyType ) = .false.
          i = i + 1
          if ( i > size(info) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Malformed call to DefineQtyTypes' )
          unitsTable ( qtyType ) = info ( i )
        else
          if ( info(i) /= next ) then
            propertyTable ( info(i), qtyType ) = .true.
          else
            qtyType = 0
          end if
        end if
        i = i + 1
      end do
    end subroutine DefineQtyTypes

  end subroutine InitQuantityTemplates
@


1.1
log
@A mockup with example to create quantity templates
@
text
@a1 1
   use Init_tables_module, only: FIRST_LIT, LAST_LIT
d8 2
a9 2
   use Init_Tables_Module, only:  L_ADOPTED, L_ADOPTED, L_BASELINE, L_BOUNDARYPRESSURE, &
      L_CALSIDEBANDFRACTION, &
d22 1
a22 1
      L_GEOLOCATION, L_GPH, L_HEIGHTOFFSET, L_ISOTOPERATIO, L_IWC, &
d50 5
d90 1
d94 2
a95 2
   type(QuantityTemplate_T) function CreateQtyTemplate (type, avgrid, &
        ahgrid, qInstModule, qMolecule, qLogBasis, qMinValue) &
d97 3
a99 1
      integer, intent(in) :: type
d104 1
d108 6
d116 1
a116 1
      qty%quantityType = type
d146 26
a171 1
      ! Set up a non major/minor frame quantity
d187 3
a189 1
      qty%unit = unitsTable(type)
d202 33
d237 22
d273 1
a273 1
    !propertyTable = .false.
d336 1
d407 29
a435 29
    !do i = first_lit, last_lit
    !  valid = .true.
    !  message =  ''
    !  ! Check it's not both major and minor frame
    !  if ( count ( propertyTable ( (/ p_minorFrame, p_majorFrame /), i ) ) > 1 ) then
    !    valid = .false.
    !    message = "Quantity cannot be both major and minor frame"
    !  end if
    !  ! Check that we can identify the module for major/minor frame
    !  if ( ( propertyTable ( p_minorFrame, i ) .or. &
    !    &    propertyTable ( p_majorFrame, i ) ) .and. &
    !    & .not. any ( propertyTable ( &
    !    & (/ p_radiometer, p_module, p_scModule, p_signal /), i ) ) ) then
    !    valid = .false.
    !    message = "Badly defined major/minor frame quantity"
    !  end if
    !  ! Check that mustBeZeta quantities have a vGrid
    !  if ( propertyTable ( p_mustBeZeta, i ) .and. .not. &
    !    & ( propertyTable ( p_vGrid, i ) .or. propertyTable ( p_flexibleVHGrid, i ) ) ) then
    !    valid = .false.
    !    message = "Quantity must have vGrid if it must be on log-pressure"
    !  end if
    !  ! Print out any message
    !  if ( .not. valid ) then
    !    call output ( "Offending quantity: " )
    !    call display_string ( lit_indices ( i ), strip=.true., advance='yes' )
    !    call MLSMessage ( MLSMSG_Error, ModuleName, message )
    !  end if
    !end do
d449 1
a449 1
          !propertyTable ( :, qtyType ) = .false.
d456 1
a456 1
            !propertyTable ( info(i), qtyType ) = .true.
d532 41
@

