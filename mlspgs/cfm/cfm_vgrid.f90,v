head	1.11;
access;
symbols
	v5-02-NRT-19:1.11
	v6-00:1.11
	v5-02-NRT-18:1.11
	v5-02:1.11
	v5-01-NRT-17:1.11
	v5-01-NRT-16:1.11
	v5-01-NRT-15:1.11
	v5-01-NRT-14:1.11
	neuralnetworks-1-0:1.11.0.12
	cfm-single-freq-0-1:1.11.0.10
	TES-MLuo-01:1.11
	TES-UNKNOWN:1.11
	v5-01:1.11
	v5-00:1.11
	v4-23-TA133:1.11.0.8
	mus-emls-1-70:1.11.0.6
	rel-1-0-englocks-work:1.11.0.4
	VUMLS1-00:1.11
	VPL1-00:1.11
	V4-22-NRT-08:1.11
	VAM1-00:1.11
	V4-21:1.11.0.2
	V4-13:1.11
	V4-12:1.11
	V4-11:1.11
	V4-10:1.11
	V3-43:1.1
	M4-00:1.11
	V3-41:1.1
	V3-40-PlusGM57:1.1.0.2
	V3-33:1.10
	V3-31:1.10
	V3-30-NRT-05:1.10
	cfm-01-00:1.10
	V3-30:1.1
	V3-20:1.1;
locks; strict;
comment	@# @;


1.11
date	2011.12.15.18.27.45;	author honghanh;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.29.16.40.23;	author honghanh;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.29.15.53.45;	author honghanh;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.24.18.00.35;	author honghanh;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.24.15.05.58;	author honghanh;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.23.02.59.08;	author honghanh;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.26.15.35.18;	author honghanh;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.24.17.44.48;	author honghanh;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.24.16.26.17;	author honghanh;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.14.19.24.26;	author honghanh;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.17.16.41.33;	author honghanh;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Documentation and code clean up, including removing unused and broken
subroutines.
@
text
@! Copyright 2010, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.
module CFM_VGrid_m
   use VGridsDatabase, only: VGrid_T, NullifyVGrid
   use MLSCommon, only: r8
   use MLSStrings, only: ReadIntsFromChars
   use MLSStringLists, only: List2Array, NumStringElements
   use Intrinsic, only: l_zeta, &
                        phyq_dimensionless, phyq_pressure
   use Init_tables_module, only: l_logarithmic, l_explicit
   use Allocate_Deallocate, only: allocate_test, deallocate_test
   use MLSMessageModule, only: MLSMessage, MLSMSG_Error

   implicit none
   public :: CreateVGrid

   private

!---------------------------- RCS Ident Info -------------------------------
   character(len=*), private, parameter :: ModuleName= &
       "$RCSfile: cfm_vgrid.f90,v $"
   private :: not_used_here
!---------------------------------------------------------------------------

   contains

   ! Create a VGrid, from a given formula, a starting value, a type
   ! (currently only supported logarithmic type)
   type(VGrid_T) function CreateVGrid (coordinate, unit, type, start, &
                 formula, values) result (vGrid)
      ! Currently only support l_zeta
      integer, intent(in) :: coordinate
      ! Must be either phyq_dimensionless or phyq_pressure
      integer, intent(in) :: unit
      ! Currently only support l_logarithmic (log-based vgrid)
      integer, intent(in) :: type

      ! If type is l_logarithmic, then start and formula
      ! should be provided
      ! The first value of surfaces
      real(r8), intent(in), optional :: start
      ! The format of formula is
      ! "number_of_surfaces:num_decades_between_surfaces".
      ! For example, "37:6" or "25:8,12:6".
      character(len=*), intent(in), optional :: formula
      ! If type is l_explicit, this must be present
      real(r8), dimension(:), intent(in), optional :: values

      call nullifyVGrid(vGrid) ! for sun's still useless compiler
      vgrid%name = 0
      vGrid%verticalCoordinate = coordinate

      if (type == l_logarithmic) then
         call LogarithmicFormula(vgrid, -1.0d0, formula, start)
      else if (type == l_explicit) then
         if (.not. present(values)) &
            call MLSMessage(MLSMSG_Error, ModuleName, &
            "Need values to create explicit VGrid")
         call CreateExplicitVGrid(vgrid, values)
      else
         call MLSMessage (MLSMSG_Error, ModuleName, "VGrid's type not supported")
      end if

      if (coordinate == l_zeta .and. &
         (unit == phyq_pressure .or. unit == phyq_dimensionless)) then
         vgrid%surfs = -Log10(vgrid%surfs)
      end if
   end function

   subroutine LogarithmicFormula (vgrid, stepSign, formula, start)
      real(r8), intent(in) :: stepSign
      type(VGrid_T) :: vgrid
      character(len=*), intent(in) :: formula
      real(r8), intent(in) :: start

      real(r8) :: step
      character(len=10) :: pair(2)
      character(len=20), dimension(:), pointer :: tokens => NULL()
      integer :: temp, numTokens
      integer :: i,j,k,n

      vgrid%noSurfs = 0
      numTokens = NumStringElements(formula, .false., ',')
      call allocate_test(tokens, numTokens, "tokens", ModuleName)
      call List2Array(formula, tokens, .false., ',', .true.)

      ! get the number of surfaces
      do i = 1, size(tokens)
         call List2Array (tokens(i), pair, .false., ':', .true.)
         call ReadIntsFromChars(pair(1), temp)
         vgrid%nosurfs = vgrid%nosurfs + temp
      end do
      call allocate_test(vgrid%surfs, vgrid%nosurfs, 1, "vgrid%surfs", &
            ModuleName)

      k = 1
      n = 1 ! One less surface the first time, since we have one at the start.
      vgrid%surfs(1,1) = start
      do i = 1, size(tokens)
         call List2Array (tokens(i), pair, .false., ':', .true.)
         call ReadIntsFromChars(pair(2), temp)
         step = 10.0 ** (stepSign / temp)
         call ReadIntsFromChars(pair(1), temp)
         do j = 1, temp - n
            k = k+1
            vgrid%surfs(k,1) = vgrid%surfs(k-1,1) * step
         end do
         n = 0
      end do

      call deallocate_test(tokens, "tokens", ModuleName)

   end subroutine

   ! Fill the given vgrid with the given values
   subroutine CreateExplicitVGrid (vgrid, values)
      ! The vgrid to be filled
      type(VGrid_T) :: vgrid
      ! The values to fill
      real(r8), dimension(:), intent(in) :: values

      integer :: i

      vgrid%noSurfs = size(values)
      call allocate_test(vgrid%surfs, vgrid%nosurfs, 1, "vgrid%surfs", &
            ModuleName)

      do i = 1, vgrid%nosurfs
         vgrid%surfs(i,1) = values(i)
      end do
      vGrid%surfs = 10.0**( nint ( log10(vGrid%surfs) * values(1)) / values(1))

   end subroutine

!--------------------------- end bloc --------------------------------------
   logical function not_used_here()
   character (len=*), parameter :: IdParm = &
       "$Id: cfm_vgrid.f90,v 1.10 2010/06/29 16:40:23 honghanh Exp $"
   character (len=len(idParm)) :: Id = idParm
      not_used_here = (id(1:1) == ModuleName(1:1))
      print *, Id ! .mod files sometimes change if PRINT is added
   end function not_used_here
!---------------------------------------------------------------------------

end module

! $Log: cfm_vgrid.f90,v $
! Revision 1.10  2010/06/29 16:40:23  honghanh
! Remove all function/subroutine and user type forwarding from
! all CFM modules except for from cfm.f90
!
! Revision 1.9  2010/06/29 15:53:45  honghanh
! Add copyright comments and support for CVS log in the file
!
@


1.10
log
@Remove all function/subroutine and user type forwarding from
all CFM modules except for from cfm.f90
@
text
@a77 37
   ! not working right now
   subroutine LinearFormula (vgrid, stepSign, formula, start)
      real(r8), intent(in) :: stepSign
      type(VGrid_T) :: vgrid
      character(len=*), intent(in) :: formula
      real(r8), intent(in) :: start

      real(r8) :: step
      character(len=10) :: pair(2)
      character(len=20), dimension(:), pointer :: tokens => NULL()
      integer :: temp, numTokens
      integer :: i,j,k,n

      vgrid%noSurfs = 0
      numTokens = NumStringElements(formula, .false., ',')
      call allocate_test(tokens, numTokens, "tokens", ModuleName)
      call List2Array(formula, tokens, .false., ',', .true.)

      ! get the number of surfaces
      do i = 1, size(tokens)
         call List2Array (tokens(i), pair, .false., ':', .true.)
         call ReadIntsFromChars(pair(1), temp)
         vgrid%nosurfs = vgrid%nosurfs + temp
      end do
      call allocate_test(vgrid%surfs, vgrid%nosurfs, 1, "vgrid%surfs", &
            ModuleName)

      n = 0
      do i = 1, numTokens
         call List2Array (tokens(i), pair, .false., ':', .true.)
         call ReadIntsFromChars(pair(2), temp)
         n = n + 1
         vgrid%surfs(n,1) = temp

      end do
   end subroutine

d146 1
a146 1
       "$Id: cfm_vgrid.f90,v 1.9 2010/06/29 15:53:45 honghanh Exp $"
d156 4
@


1.9
log
@Add copyright comments and support for CVS log in the file
@
text
@d12 1
a12 2
   use VGridsDatabase, only: VGrid_T, NullifyVGrid, &
                             DestroyVGridContents, Dump
d23 1
a23 2
   public :: CreateVGrid, DestroyVGridContents, Dump
   public :: VGrid_T
d183 1
a183 1
       "$Id: cfm_vgrid.f90,v 1.1 2010/05/24 8:05:33 honghanh Exp $"
d193 3
@


1.8
log
@Rename moduleId to moduleName
@
text
@d1 10
d193 2
@


1.7
log
@Add RCS info
@
text
@d57 1
a57 1
            call MLSMessage(MLSMSG_Error, moduleId, &
d61 1
a61 1
         call MLSMessage (MLSMSG_Error, moduleId, "VGrid's type not supported")
d85 1
a85 1
      call allocate_test(tokens, numTokens, "tokens", moduleId)
d95 1
a95 1
            moduleId)
d121 1
a121 1
      call allocate_test(tokens, numTokens, "tokens", moduleId)
d131 1
a131 1
            moduleId)
d148 1
a148 1
      call deallocate_test(tokens, "tokens", moduleId)
d163 1
a163 1
            moduleId)
@


1.6
log
@Add CreateExplicitVGrid
@
text
@d18 6
a23 1
   character(len=20) :: moduleId = "CFM_VGrid.f90"
d172 10
@


1.5
log
@Add more comments to everything
@
text
@d9 1
a9 1
   use Init_tables_module, only: l_logarithmic
d24 2
a25 7
   type(VGrid_T) function CreateVGrid (coordinate, type, start, &
                 formula, unit) result (vGrid)
      real(r8), intent(in) :: start
      ! The format of formula is
      ! "number_of_surfaces:num_decades_between_surfaces".
      ! For example, "37:6" or "25:8,12:6".
      character(len=*), intent(in) :: formula
d28 2
d32 11
a42 2
      ! Must be either phyq_dimensionless or phyq_pressure
      integer, intent(in) :: unit
d50 5
d147 20
@


1.4
log
@Conformed all module names to end with _m, changed file names to all
lowercase, add comments
@
text
@a23 2
   ! The format of formula is "number_of_surfaces:num_decades_between_surfaces".
   ! For example, "37:6" or "25:8,12:6".
a25 1

d27 3
d31 1
d33 1
d35 1
@


1.3
log
@Adjustments made to add startTime and endTime as inputs to CFM_MLSSetup.
Tested successfully
@
text
@d1 1
a1 1
module CFM_VGrid
d22 4
@


1.2
log
@Fix bugs in cfm_vgrid.f90, and added testing receipt for vgrid creation
@
text
@d2 2
a3 1
   use VGridsDatabase, only: VGrid_T, NullifyVGrid
d14 2
a15 1
   public :: CreateVGrid
d80 1
a80 1
         
@


1.1
log
@An example of using CFM_MLSSetup and creating a VGrid
@
text
@a3 1
   use Intrinsic, only: l_zeta, phyq_pressure
d6 2
d10 1
d29 24
d55 33
a87 2
      integer :: temp, currentsurf, numTokens
      integer :: i,j
d89 4
a93 2
      call nullifyVGrid(vGrid) ! for sun's still useless compiler
      vgrid%name = 0
a94 2
      vGrid%verticalCoordinate = coordinate

d98 21
a118 6
      if (type == l_logarithmic) then
         ! get the number of surfaces
         do i = 1, size(tokens)
            call List2Array (tokens(i), pair, .false., ':', .true.)
            call ReadIntsFromChars(pair(1), temp)
            vgrid%nosurfs = vgrid%nosurfs + temp
d120 3
a122 18
         call allocate_test(vgrid%surfs, vgrid%nosurfs, 1, "vgrid%surfs", &
               moduleId)
         currentSurf = 1
         vgrid%surfs(1,1) = start
         do i = 1, size(tokens)
            call List2Array (tokens(i), pair, .false., ':', .true.)
            call ReadIntsFromChars(pair(2), temp)
            step = 10.0 ** 1.0d0 / temp
            call ReadIntsFromChars(pair(1), temp)
            do j = currentSurf, (currentSurf + temp - 1)
               vgrid%surfs(j,1) = vgrid%surfs(j-1,1) * step
            end do
            currentSurf = currentSurf + temp
         end do
      end if
      if (coordinate == l_zeta .and. unit == phyq_pressure) then
         vgrid%surfs = -Log10(vgrid%surfs)
      end if
d125 1
a125 1
   end function
@

