head	1.25;
access;
symbols
	v5-02-NRT-19:1.25
	v6-00:1.25
	v5-02-NRT-18:1.25
	v5-02:1.25
	v5-01-NRT-17:1.25
	v5-01-NRT-16:1.25
	v5-01-NRT-15:1.25
	v5-01-NRT-14:1.25
	neuralnetworks-1-0:1.25.0.12
	cfm-single-freq-0-1:1.25.0.10
	v5-01:1.25
	v5-00:1.25
	v4-23-TA133:1.25.0.8
	mus-emls-1-70:1.25.0.6
	rel-1-0-englocks-work:1.25.0.4
	VUMLS1-00:1.25
	VPL1-00:1.25
	V4-22-NRT-08:1.25
	VAM1-00:1.25
	V4-21:1.25.0.2
	V4-13:1.25
	V4-12:1.25
	V4-11:1.25
	V4-10:1.25
	V3-43:1.24
	M4-00:1.24
	V3-41:1.24
	V3-40-PlusGM57:1.24.0.2
	V2-24-NRT-04:1.23
	V3-33:1.24
	V2-24:1.23
	V3-31:1.24
	V3-30-NRT-05:1.24
	cfm-01-00:1.24
	V3-30:1.24
	V3-20:1.24
	V3-10:1.24
	V2-23-NRT-02:1.23
	V2-23:1.23
	V2-22-NRT-01:1.23
	V2-22:1.23
	V2-21:1.22
	V2-20:1.22
	V2-11:1.22
	V2-10:1.22
	V2-00:1.22
	V1-51:1.16
	V1-50:1.16
	V1-45:1.16
	V1-44:1.16
	V1-43:1.15
	V1-42:1.14
	V1-41:1.14
	V1-32:1.13
	V1-40:1.14
	V1-31:1.13
	V1-30:1.13
	V1-13:1.10
	V1-12:1.10
	V1-11:1.10
	V1-10:1.10
	newfwm-feb03:1.10.0.2
	V1-04:1.10
	V1-03:1.10
	V1-02:1.10
	V1-00:1.7
	newfwm-sep01:1.6.0.2
	V0-7:1.6
	V0-5-Level2:1.5
	V0-5-SIPS:1.4;
locks; strict;
comment	@# @;


1.25
date	2014.04.02.23.08.35;	author pwagner;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.02.23.13.56;	author pwagner;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.26.19.06.26;	author cvuu;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.31.21.05.35;	author cvuu;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.24.19.14.30;	author cvuu;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.17.15.43.04;	author cvuu;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.28.17.56.56;	author cvuu;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.23.19.07.38;	author pwagner;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.14.20.46.42;	author pwagner;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.22.16.55.47;	author cvuu;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.04.15.33.15;	author cvuu;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.07.21.43.18;	author cvuu;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.15.18.30.48;	author cvuu;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.30.18.15.48;	author pwagner;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.22.02.41.32;	author jdone;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.15.22.25.00;	author jdone;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.11.22.29.47;	author jdone;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.10.21.54.05;	author jdone;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.20.19.21.15;	author ybj;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.18.15.50.59;	author nakamura;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.24.19.37.30;	author nakamura;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.21.20.37.18;	author nakamura;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.29.20.40.04;	author nakamura;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.07.19.28.27;	author nakamura;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.15.20.56.51;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Removed redundant open_ and close_MLSFile
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!==============================================================================
MODULE L2Interface
!==============================================================================

  USE intrinsic, ONLY: l_swath
  USE L2GPData, ONLY: L2GPData_T, ReadL2GPData, WriteL2GPData, SetupNewL2GPRecord, &
       & DestroyL2GPContents
  USE MLSCommon, ONLY: r8, MLSFile_T
  USE MLSFiles, ONLY: InitializeMLSFile, mls_openFile, mls_closeFile, & 
       & mls_hdf_version, mls_inqswath, MLS_CloseFile, MLS_OpenFile
  USE MLSL3Common, ONLY: DATE_LEN, CCSDS_LEN, FILENAMELEN, maxWindow, & 
       & GRIDNAMELEN, maxMisDays
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_Allocate, &
       & MLSMSG_WARNING, MLSMSG_INFO, MLSMSG_FILEOPEN
  USE MLSPCF3, ONLY: mlspcf_l2gp_start, mlspcf_l2gp_end, &
       & mlspcf_l3dm_start, mlspcf_l3dm_end
  USE output_m, only: output
  USE PCFModule, ONLY: FindFileDay, ExpandFileTemplate
  USE Dump_0, only: DUMP

  IMPLICIT NONE
  private
  PUBLIC :: GetL2GPfromPCF, ReadL2GP, ReadL2GPProd, ResidualOutput, &
	& ReadL2DGData, ReadL2GPAttribute, SetupL2GPProd
  
  
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: L2Interface.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
  
  ! Contents:
  
  ! Subroutines -- GetL2GPfromPCF
  !                ReadL2GP
  !                ReadL2GPProd
  !                ResidualOutput
  !                ReadL2DGData
  !                ReadL2GPAttribute
  
  ! Remarks:  This module contains subroutines involving the interface between
  !           Level 3 and L2.
  
  ! Parameters
  
CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELD1 = 'L2gpValue'
CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELD2 = 'L2gpPrecision'
CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELD3 = 'Status'
CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELD4 = 'Quality'
CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELD5 = 'L3Residual'
  
CONTAINS
  
  !----------------------------------------------------------------------------
  SUBROUTINE GetL2GPfromPCF(mlspcf_start, mlspcf_end, template, startDOY, &
       & endDOY, numFiles, pcfNames, mis_numFiles, mis_Days)
  !----------------------------------------------------------------------------
  USE SDPToolkit, ONLY: PGS_S_SUCCESS, Pgs_pc_getReference
    
    ! Brief description of subroutine
    ! This routine searches the PCF for l2gp files for a desired species.  It
    ! returns an array of names and the number of the files found.
    
    ! Arguments
    
    CHARACTER (LEN=8), INTENT(IN) :: endDOY, startDOY
    CHARACTER (LEN=*), INTENT(IN) :: template
    INTEGER, INTENT(IN) :: mlspcf_end, mlspcf_start
    INTEGER, INTENT(OUT) :: numFiles, mis_numFiles
    INTEGER, INTENT(OUT) :: mis_Days(:)
    CHARACTER (LEN=FileNameLen) :: pcfNames(:)
   
    ! Parameters
    
    ! Functions
    
    ! Variables
    
    CHARACTER (LEN=FileNameLen) :: physicalFilename, type
    CHARACTER (LEN=8) :: date
    CHARACTER (LEN=7) :: dateChar
    CHARACTER (LEN=3) :: startChar, endChar, dayChar
    
    INTEGER :: i, j, indx, returnStatus, version, err
    INTEGER :: startInt, endInt, dateInt, dayInt
    INTEGER :: doy_current, doy_prev, day_diff
    LOGICAL, parameter :: DEBUG = .false. 
  
    ! Expand the level/species template
    
    CALL ExpandFileTemplate(template, type, 'L2GP')

    if (DEBUG) then
       call output('type= ', advance='no')   
       call output(trim(type), advance='yes')   
    end if

    numFiles = 0
    mis_numFiles = 0
    mis_Days = 0
    doy_current = 0 
    doy_prev = 0 
    day_diff = 0 

    ! Loop through all the PCF numbers for L2GP files
   
    do i = mlspcf_start, mlspcf_end
       version = 1
       returnStatus = Pgs_pc_getReference(i, version, physicalFilename)

       if (i == mlspcf_start) then
           indx = INDEX(physicalFilename, '.', .TRUE.)
           read(physicalFilename(indx-3:indx-1),'(i3)') doy_current
	   doy_prev = doy_current
       endif 
       if (DEBUG) then
         call output( 'physicalFilename = ', advance='no')
         call output( trim(physicalFilename), advance='yes')
         call output( 'returnStatus = ', advance='no')
         call output( returnStatus, advance='yes')
       end if

       ! If no file name was returned, go on to the next PCF number
    
       if(returnStatus /= PGS_S_SUCCESS) THEN
          if ( INDEX(physicalFilename, TRIM(type)) /= 0 ) THEN
                ! Extract the date from the file name
                indx = INDEX(physicalFilename, '.', .TRUE.)
                date = physicalFilename(indx-8:indx-5)//'-'//physicalFilename(indx-3:indx-1)
                ! Check that the date is within the desired boundaries for reading
             
                if ( (date .GE. startDOY) .AND. (date .LE. endDOY) ) THEN
	           startChar = startDOY(6:8)
                   read (startChar, '(i3)') startInt
	           endChar = endDOY(6:8)
                   read (endChar, '(i3)') endInt
		   
		   if (numFiles <= (endInt - startInt)) then 
               
                   ! Save the name in an array of files for the species
                       mis_numFiles = mis_numFiles + 1
                
		   ! convert from char to int. There was problem using charstring 
		   ! with tk 5.2.10 (hdfeos5.1.6.2) 3/2004                         
	              dateChar = date(1:4) // date(6:8) 
                      read (dateChar, '(i7)') dateInt
		      dateInt = dateInt + 1
                      mis_Days(mis_numFiles) = dateInt
		   endif
                endif
          endif
          CYCLE
       endif 
       
       ! Check that the returned file name is for the proper species
       if ( INDEX(physicalFilename, TRIM(type)) /= 0 ) THEN
          ! Extract the date from the file name
          indx = INDEX(physicalFilename, '.', .TRUE.)
          date = physicalFilename(indx-8:indx-5)//'-'//physicalFilename(indx-3:indx-1)
          
          ! Check that the date is within the desired boundaries for reading
	  if (DEBUG) then
             call output('date=', advance='no')
	     call output( date, advance='yes')
	  end if

          if ( (date .GE. startDOY) .AND. (date .LE. endDOY) ) THEN
             ! Save the name in an array of files for the species
             numFiles = numFiles + 1
             pcfNames(numFiles) = physicalFilename
	     if (DEBUG) then
   	     	call output('numFiles = ', advance ='no')          
   	     	call output(numFiles, advance ='yes')          
   	     	call output('pcfNames = ', advance ='no')          
   	     	call output(pcfNames(numFiles), advance ='yes')          
	     endif
          endif
       
	  ! Check missing days that are not in the PCF

          read(physicalFilename(indx-3:indx-1),'(i3)') doy_current
	  if (DEBUG) then
             print *,' doy_current: ', doy_current
             print *,' filename here: ', trim(physicalFilename)
             print *,' type: ', trim(type)
             print *,' i: ',i 
	  endif
	  day_diff = doy_current - doy_prev
	  if (day_diff > 1) then
	     do j = 1, day_diff - 1 
		mis_numFiles = mis_numFiles + 1
	        mis_Days(mis_numFiles) = doy_prev + j
	     enddo
	  endif
          doy_prev = doy_current
       endif
    enddo
   
  !-------------------------------
  END SUBROUTINE GetL2GPfromPCF
  !-------------------------------
  
  !--------------------------------------------------------
  SUBROUTINE ReadL2GPAttribute(l3StartDay, l3EndDay, tempfile, nDays, L3MFlag)
  !--------------------------------------------------------
    
    ! Brief description of subroutine
    ! This routine reads an L2GP file, returning a filled data structure.

    USE HDF, only: DFACC_READ 
    !USE MLSHDFEOS, only: he5_EHrdglatt
    USE SDPToolkit, only: max_orbits
    USE Allocate_Deallocate, only: ALLOCATE_TEST
    USE PCFHdr, only: GlobalAttributes

    ! Arguments

    character (LEN=*), INTENT(IN) :: l3StartDay, l3EndDay, tempfile
    Integer, intent(out) :: nDays
    integer, intent(in), optional :: L3MFlag
    
    ! Local variables

    type(MLSFile_T)                :: MLSFile
    character (LEN=FileNameLen) :: pcfNames(40)
    integer :: mis_Days(maxMisDays), misDInt
    integer :: numDays, mis_numDay, the_hdfVersion, file_id
    integer :: record_length, i, status, mis_numDays, n=1 
    integer :: indx, j, k, l3DayInt, m=1
    integer, external :: HE5_EHrdglatt
    character (len=20) :: name
    character (len=3) :: date, misD 
    character (len=7) :: misDchar 
    character (LEN=FileNameLen) :: pcfFileNames

    call GetL2GPfromPCF(mlspcf_l2gp_start,mlspcf_l2gp_end, tempfile, &
	& l3StartDay, l3EndDay, numDays, pcfNames, mis_numDays, mis_Days)

    if (present(L3MFlag)) then
	numDays = numDays + 1
        call Allocate_test (GlobalAttributes%OrbNumDays, max_orbits, &
	   & numDays,'GlobalAttributes%OrbNumDays', ModuleName)
        call Allocate_test (GlobalAttributes%OrbPeriodDays, max_orbits, &
	   & numDays,'GlobalAttributes%OrbPeriodDays', ModuleName)
        do i = 1, numDays-1
           the_hdfVersion = mls_hdf_version(trim(pcfNames(i)))
           status = InitializeMLSFile ( MLSFile, type=l_swath, access=DFACC_READ, &
            & name=trim(pcfNames(i)), HDFVersion=the_hdfVersion )
           call MLS_OpenFile( MLSFile )
           file_ID = MLSFile%FileID%f_id
           ! file_id = mls_io_gen_openF(l_swath, .TRUE., status, &
           !   & record_length, DFACC_READ, pcfNames(i), &
           !   & hdfVersion=the_hdfVersion, debugOption=.false. )
           !if ( status /= 0 ) &
           !   call MLSMessage ( MLSMSG_Error, ModuleName, &
           !     & "Unable to open L2gp file: " &
           !     & // trim(pcfNames(i))//' for reading')
              status = HE5_EHrdglatt(file_id, 'OrbitNumber', &
                & GlobalAttributes%OrbNumDays(:,i))
              if (status /= 0) then
                call MLSMessage ( MLSMSG_Warning, ModuleName, &
                  & "Unable to read attribute OrbitNumber for " &
                  & //trim(pcfNames(i)))
                GlobalAttributes%OrbNumDays(:,i) = -1
              end if

              status = HE5_EHrdglatt(file_id, 'OrbitPeriod', &
                & GlobalAttributes%OrbPeriodDays(:,i))
              if (status /= 0) then
                call MLSMessage ( MLSMSG_Warning, ModuleName, &
                   & "Unable to read attribute OrbitPeriod for "&
                   & //trim(pcfNames(i)))
                GlobalAttributes%OrbPeriodDays(:,i) = -1.0
              end if
         enddo

         GlobalAttributes%OrbNumDays(:,numDays) = -1
         GlobalAttributes%OrbNumDays(1:1,numDays) = &
	      &	GlobalAttributes%OrbNumDays(1:1,1)
         GlobalAttributes%OrbNumDays(2:2,numDays) = &
	      &	maxval(GlobalAttributes%OrbNumDays(:,numDays-1))
!        call output('OrbNum_last =', advance='no')
!        call output(GlobalAttributes%OrbNumDays(:,numDays), advance='yes')
         GlobalAttributes%OrbPeriodDays(:,numDays) = -1.0
         GlobalAttributes%OrbPeriodDays(1:1,numDays) = &
	      &	GlobalAttributes%OrbPeriodDays(1:1,1)
         GlobalAttributes%OrbPeriodDays(2:2,numDays) = &
	      &	maxval(GlobalAttributes%OrbPeriodDays(:,numDays-1))
!       call output('OrbNum_last =', advance='no')
!       call output(GlobalAttributes%OrbPeriodDays(:,numDays), advance='yes')
    else 
        call Allocate_test (GlobalAttributes%OrbNumDays, max_orbits, &
	   & numDays+mis_numDays,'GlobalAttributes%OrbNumDays', ModuleName)
        call Allocate_test (GlobalAttributes%OrbPeriodDays, max_orbits, &
	   & numDays+mis_numDays,'GlobalAttributes%OrbPeriodDays', ModuleName)

        DO i = 1, numDays
       	   m = n
           the_hdfVersion = mls_hdf_version(trim(pcfNames(i)))
           pcfFileNames = trim(pcfNames(i))
           indx = INDEX(pcfFileNames, '.', .TRUE.)
           date = pcfFileNames(indx-3:indx-1)
           read(date, '(i3)')l3DayInt 
           l3DayInt = l3DayInt - 1
       
           do j = 1, mis_numDays
	      write(misDchar, '(I7)') mis_Days(j)
	      misD = misDchar(5:7)
              read(misD, '(i3)')misDInt 
	      if (l3DayInt == misDInt) then
	         do k = 1, 16
	           GlobalAttributes%OrbNumDays(k,m) = &
		     & GlobalAttributes%OrbNumDays(15,m-1)+k
	           GlobalAttributes%OrbPeriodDays(k,m) = 5930.5056 
	         enddo  
	         n = n+1
	         m = m+1
	      endif
          enddo

           status = InitializeMLSFile ( MLSFile, type=l_swath, access=DFACC_READ, &
            & name=trim(pcfNames(i)), HDFVersion=the_hdfVersion )
           call MLS_OpenFile( MLSFile )
           file_ID = MLSFile%FileID%f_id
          ! file_id = mls_io_gen_openF('swopen', .TRUE., status, &
          ! file_id = mls_io_gen_openF(l_swath, .TRUE., status, &
          !  & record_length, DFACC_READ, pcfNames(i), &
          !  & hdfVersion=the_hdfVersion, debugOption=.false. )
          !if ( status /= 0 ) &
          !  call MLSMessage ( MLSMSG_Error, ModuleName, &
		    !& "Unable to open L2gp file: " &
		    !& // trim(pcfNames(i))//' for reading')
            status = HE5_EHrdglatt(file_id, 'OrbitNumber', &
		& GlobalAttributes%OrbNumDays(:,m))
	    n = n+1
      	    if (status /= 0) then 
               call MLSMessage ( MLSMSG_Warning, ModuleName, &
       	    	  & "Unable to read attribute OrbitNumber, calculate "  &
		  & //trim(pcfNames(i)))
	       do j = 1, 16
	          GlobalAttributes%OrbNumDays(j,m) = &
		     & GlobalAttributes%OrbNumDays(15,m-1)+j
	       enddo  
            end if

!            call output(GlobalAttributes%OrbNumDays(:,m), advance='yes')

            status = HE5_EHrdglatt(file_id, 'OrbitPeriod', & 
		& GlobalAttributes%OrbPeriodDays(:,m))
            if (status /= 0) then
         	call MLSMessage ( MLSMSG_Warning, ModuleName, &
       	    	   & "Unable to read attribute OrbitPeriod for "&
		   & //trim(pcfNames(i)))
	       do j = 1, 16
	          GlobalAttributes%OrbPeriodDays(j,m) = &
		     & GlobalAttributes%OrbPeriodDays(15,m-1)
	       enddo  
	  !	GlobalAttributes%OrbPeriodDays(:,m) = -1.0
		
            end if

!            call output(GlobalAttributes%OrbPeriodDays(:,m), advance='yes')

            status = HE5_EHrdglatt(file_id, 'FirstMAF', &
                & GlobalAttributes%FirstMAFCtr)
            if (status /= 0) then
                call MLSMessage ( MLSMSG_Warning, ModuleName, &
                   & "Unable to read attribute FirstMAF for "&
                   & //trim(pcfNames(i)))
            end if
            call output(GlobalAttributes%FirstMAFCtr, advance='yes')
                                                                            
            status = HE5_EHrdglatt(file_id, 'LastMAF', &
                & GlobalAttributes%LastMAFCtr)
            if (status /= 0) then
                call MLSMessage ( MLSMSG_Warning, ModuleName, &
                   & "Unable to read attribute LastMAF for "&
                   & //trim(pcfNames(i)))
            end if
            call output(GlobalAttributes%LastMAFCtr, advance='yes')

            call MLS_CloseFile( MLSFile )
            ! status = mls_io_gen_closeF('swclose', file_id, pcfNames(i), & 
            ! status = mls_io_gen_closeF(l_swath, file_id, pcfNames(i), & 
           	!& hdfVersion=the_hdfVersion)
            !if ( status /= 0 ) &
           	!call MLSMessage ( MLSMSG_Error, ModuleName, &
       	   !   	   & "Unable to close L2gp file:"//trim(pcfNames(i)))
        END DO
    end if

  !-------------------------------
  END SUBROUTINE ReadL2GPAttribute
  !-------------------------------

  !--------------------------------------------------------
  SUBROUTINE ReadL2GP(L2FileName, swathname, l2gpData)
  !--------------------------------------------------------
    
    ! Brief description of subroutine
    ! This routine reads an L2GP file, returning a filled data structure.
    
    ! Arguments

    CHARACTER (LEN=*), INTENT(IN) :: swathname
    CHARACTER (LEN=FileNameLen), INTENT(IN) :: L2FileName
        
    TYPE( L2GPData_T ), INTENT(OUT) :: l2gpData
   
    call ReadL2GPData(trim(L2FileName), swathname, l2gpData)
      
  !-------------------------
  END SUBROUTINE ReadL2GP
  !-------------------------
    
  !--------------------------------------------------------------------------
  SUBROUTINE SetupL2GPProd (numDays, totalIndex, l3rtemp, l3Res)
  !--------------------------------------------------------------------------
    ! Brief description of subroutine
    ! This subroutine setup l2gp Records files for a quantity over a range of days.  
    ! It returns an array of L2GPData_T structures, 
    ! with one structure per day.

    ! Arguments
      
    INTEGER, INTENT(IN) :: numDays, totalIndex
      
    TYPE( L2GPData_T ), POINTER :: l3Res(:), l3rtemp(:)
      
    ! Parameters
            
    ! Variables
      
    CHARACTER (LEN=480) :: msr

    INTEGER :: err, i, nTimes, nTimesTotal, nFreqs, nLevels

    LOGICAL :: Fillin

    IF (numDays == 0) THEN
         
       ! If not, issue a warning
         
       msr = 'No L2GP data found for '
       CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
       NULLIFY(l3Res)
         
       ! If so, open, read, & close the files for this quantity
         
    ELSE
         
       ALLOCATE( l3Res(numDays), STAT=err )
       IF ( err /= 0 ) THEN
          msr = MLSMSG_Allocate // ' l2gp array for '
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
        
       DO i = 1, numDays
          ! Read information from the L2GP file
          CALL SetupNewL2GPRecord(l3Res(i), nFreqs=1, nLevels=totalIndex, &
	     & nTimes=l3rtemp(i)%nTimes)
          l3Res(i)%chunkNumber = l3rtemp(i)%chunkNumber
          l3Res(i)%solarTime = l3rtemp(i)%solarTime
          l3Res(i)%solarZenith = l3rtemp(i)%solarZenith
          l3Res(i)%losAngle = l3rtemp(i)%losAngle
          l3Res(i)%geodAngle = l3rtemp(i)%geodAngle
          l3Res(i)%latitude = l3rtemp(i)%latitude
          l3Res(i)%longitude = l3rtemp(i)%longitude
          l3Res(i)%time = l3rtemp(i)%time
          l3Res(i)%quality = l3rtemp(i)%quality
          l3Res(i)%status = l3rtemp(i)%status
          l3Res(i)%frequency = l3rtemp(i)%frequency
          l3Res(i)%nTimes = l3rtemp(i)%nTimes
          l3Res(i)%nTimesTotal = l3rtemp(i)%nTimesTotal
          l3Res(i)%nLevels = totalIndex
          l3Res(i)%nFreqs = 0
          l3Res(i)%verticalCoordinate = 'Pressures'
       ENDDO
            
    ENDIF
      
    !-----------------------------
    END SUBROUTINE SetupL2GPProd
    !-----------------------------
  !--------------------------------------------------------------------------
  SUBROUTINE ReadL2GPProd (product, template, startDOY, endDOY, numDays, & 
       & mis_numDays, mis_Days, prodL2GP)
  !--------------------------------------------------------------------------
      
    ! Brief description of subroutine
    ! This subroutine reads l2gp files for a quantity over a range of days.  
    ! It returns an array of L2GPData_T structures, 
    ! with one structure per day.

    ! Arguments
      
    CHARACTER (LEN=*), INTENT(IN) :: product, template
      
    CHARACTER (LEN=8), INTENT(IN) :: endDOY, startDOY
      
    INTEGER, INTENT(OUT) :: numDays, mis_numDays
      
    TYPE( L2GPData_T ), POINTER :: prodL2GP(:)
      
    !CHARACTER (LEN=DATE_LEN), INTENT(OUT) :: mis_Days(:)
    INTEGER, INTENT(OUT) :: mis_Days(:)
      
    ! Parameters
            
    ! Variables
    CHARACTER (LEN=480) :: msr
    CHARACTER (LEN=FileNameLen) :: pcfNames(40)
    CHARACTER (LEN=8) :: date

    INTEGER :: err, i
    
    mis_Days = 0
    mis_numDays = 0        
    ! Search the PCF for L2GP files for this species
      
    CALL GetL2GPfromPCF(mlspcf_l2gp_start, mlspcf_l2gp_end, template, & 
         & startDOY, endDOY, numDays, pcfNames, mis_numDays, mis_Days)
      
    ! Check that numDays is at least 1, so pointer allocation is possible
      
    IF (numDays == 0) THEN
         
       ! If not, issue a warning
         
       msr = 'No L2GP data found for ' // product
       CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
       NULLIFY(prodL2GP)
         
       ! If so, open, read, & close the files for this quantity
         
    ELSE
         
       ALLOCATE( prodL2GP(numDays), STAT=err )
       IF ( err /= 0 ) THEN
          msr = MLSMSG_Allocate // ' l2gp array for ' // product
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF

       DO i = 1, numDays
          ! Read information from the L2GP file
          CALL ReadL2GP(pcfNames(i), product, prodL2GP(i) )
       ENDDO
            
    ENDIF
      
    !-----------------------------
    END SUBROUTINE ReadL2GPProd
    !-----------------------------
 
 !---------------------------------------
 SUBROUTINE ResidualOutput (type, l3r)
 !---------------------------------------
  USE HDF, ONLY: DFACC_RDWR
   
   ! Brief description of subroutine
   ! This program creates & writes the L3Residual swaths in an l3 map file.
   
   ! Arguments
   
   CHARACTER (LEN=*), INTENT(IN) :: type
   
   TYPE( L2GPData_T ), INTENT(INOUT) :: l3r(:)

   ! Functions
         
   ! Parameters
   
   ! Variables
   
   type(MLSFile_T)                :: MLSFile
   CHARACTER (LEN=480) :: msr
   CHARACTER (LEN=FileNameLen) :: l3File
   CHARACTER (LEN=8) :: date
   REAL(r8) :: validTime
   INTEGER :: i, j, match, numDays, file_id, hdfVersion, record_length, status 
   LOGICAL :: notUnlimited 

   ! For each element of the database,
   
   numDays = SIZE(l3r)
   
   DO i = 1, numDays
      
      ! Find the l3dm file for the proper day
   
      DO j = 1, l3r(i)%ntimes
         validTime = l3r(i)%time(j)
         IF (validTime /= 0.0) Exit
      ENDDO
  
      CALL FindFileDay(type, validTime, mlspcf_l3dm_start, &
           & mlspcf_l3dm_end, match, l3File, date)
      IF (match == -1) THEN
         msr = 'No ' // TRIM(type) // ' file for day ' // date & 
              & // ' found for appending ' // TRIM(l3r(i)%name) // 'swath.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      ! Re-open the l3dm grid file for the creation of swaths
      ! Create the L3Residual swath in this day's file
      ! Re-attach to the swath for writing
      ! Write to the geolocation & data fields

      hdfVersion = mls_hdf_version(trim(l3File))

      status = InitializeMLSFile ( MLSFile, type=l_swath, access=DFACC_RDWR, &
       & name=l3File, HDFVersion=hdfVersion )
      call MLS_OpenFile( MLSFile )
      file_ID = MLSFile%FileID%f_id
      ! file_id = mls_io_gen_openF('swopen', .TRUE., status, &
      ! file_id = mls_io_gen_openF(l_swath, .TRUE., status, &
      !     & record_length, DFACC_RDWR, l3File, &
      !     & hdfVersion=hdfVersion, debugOption=.false. )

      ! call dump (real(l3r(i)%l2gpValue, r8), 'l2gpValue: ')
      call WriteL2GPData(l3r(i), file_id, l3r(i)%name, & 
           & hdfVersion=hdfVersion,notUnlimited=.true.)

      ! status = mls_io_gen_closeF(l_swath, file_id, l3File, & 
      !     & hdfVersion=hdfVersion)
      call MLS_CloseFile ( MLSFile )

   ENDDO
      
 !-------------------------------
 END SUBROUTINE ResidualOutput
 !-------------------------------

 !-----------------------------------------------------------------------
 SUBROUTINE ReadL2DGData (product, numFiles, files, numDays, prodL2DG)
   !-----------------------------------------------------------------------
      
   ! Brief description of subroutine
   ! This subroutine reads l2gp dg files for a quantity over range of days.
   ! It returns an array of L2GPData_T structures, 
   ! with one structure per day.
   
   ! Arguments
      
   CHARACTER (LEN=*), INTENT(IN) :: product
   
   CHARACTER (LEN=FileNameLen), INTENT(IN) :: files(:)
      
   INTEGER, INTENT(IN) :: numFiles
   
   INTEGER, INTENT(OUT) :: numDays
      
   TYPE( L2GPData_T ), POINTER :: prodL2DG(:)

   ! Functions
   INTEGER, EXTERNAL :: he5_swattach, he5_swclose, &
           & he5_swdetach, he5_swopen, he5_swinqswath
                                                                            
   ! Parameters
   
   ! Variables
      
   CHARACTER (LEN=12000) :: list, templist
   CHARACTER (LEN=480) :: msr
   CHARACTER (LEN=FileNameLen) :: prodFiles(numFiles)
   CHARACTER (LEN=GridNameLen) :: swath
      
   INTEGER :: err, i, j, indx, len, ns, hdfversion
   
   ! Check for the product in the input files
      
   numDays = 0
  
   ns = he5_swinqswath( trim(files(1)), templist, len)
                                                                            
   IF (ns == -1) THEN
         msr = 'Failed to read swath list from ' // files(1)
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
         !CYCLE
   ENDIF

   DO i = 1, numFiles
      list = templist 
      DO j = 1, ns
            
         indx = INDEX(list, ',')
         
         IF (indx == 0) THEN
            swath = list
         ELSE
            swath = list(:indx-1)
            list  = list(indx+1:)

         ENDIF
            
         IF ( TRIM(swath) == TRIM(product) ) THEN
            numDays = numDays + 1
            prodFiles(numDays) = files(i)
            EXIT
         ENDIF
      ENDDO
   ENDDO
      
   ! Check that numDays is at least 1, so pointer allocation is possible

   IF (numDays == 0) THEN
         
      ! If not, issue a warning
      
      msr = 'No L2GP data found for ' // product
      CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
      NULLIFY(prodL2DG)
         
      ! If so, open, read, & close the files for this quantity
         
   ELSE

      ALLOCATE( prodL2DG(numDays), STAT=err )
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' l2gp array for ' // product
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
         
      DO i = 1, numDays
         
         ! Read information from the L2GP file
         
         CALL ReadL2GP( prodFiles(i), product, prodL2DG(i) )
                        
      ENDDO
         
   ENDIF

   !-----------------------------
 END SUBROUTINE ReadL2DGData
 !-----------------------------

 !=====================
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: L2Interface.f90,v 1.24 2008/12/02 23:13:56 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
END MODULE L2Interface
!=====================

!# $Log: L2Interface.f90,v $
!# Revision 1.24  2008/12/02 23:13:56  pwagner
!# mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
!#
!# Revision 1.23  2007/06/26 19:06:26  cvuu
!# fix bug
!#
!# Revision 1.22  2006/05/31 21:05:35  cvuu
!# Check missing dates that are not in the PCF; Fix orbit number and orbit period for L3DZ
!#
!# Revision 1.21  2006/05/24 19:14:30  cvuu
!# Fix the deallocate problem
!#
!# Revision 1.20  2006/04/17 15:43:04  cvuu
!# Remove the print statements
!#
!# Revision 1.19  2006/02/28 17:56:56  cvuu
!# V2.00 commit
!#
!# Revision 1.18  2005/06/23 19:07:38  pwagner
!# Reworded Copyright statement, moved rcs id
!#
!# Revision 1.17  2005/06/14 20:46:42  pwagner
!# Changed interface to mls_io_gen functions
!#
!# Revision 1.16  2004/06/22 16:55:47  cvuu
!# Using SetupNewL2GPRecord for L3 Residual based on the nLevels from L3 not L2
!#
!# Revision 1.15  2004/05/04 15:33:15  cvuu
!# v1.4.3: Use int array for Date in Data Field
!#
!# Revision 1.14  2004/01/07 21:43:18  cvuu
!# version 1.4 commit
!#
!# Revision 1.13  2003/09/15 18:30:48  cvuu
!# Read OrbitNumber and OrbitPeriod from L2GP files
!#
!# Revision 1.12  2003/04/30 18:15:48  pwagner
!# Work-around for LF95 infinite compile-time bug
!#
!# Revision 1.11  2003/03/22 02:41:32  jdone
!# implemented L2GPData library routines
!#
!# Revision 1.10  2002/04/15 22:25:00  jdone
!#  swid checked
!#
!# Revision 1.9  2002/04/11 22:29:47  jdone
!# swid checked
!#
!# Revision 1.8  2002/04/10 21:54:05  jdone
!# error checking on allocated statements
!#
!# Revision 1.7  2002/02/20 19:21:15  ybj
!# *** empty log message ***
!#
!# Revision 1.6  2001/07/18 15:50:59  nakamura
!# Generalized to work with L3M as well.
!#
!# Revision 1.5  2001/04/24 19:37:30  nakamura
!# Changes for privatization of L2GPData.
!#
!# Revision 1.4  2001/02/21 20:37:18  nakamura
!# Changed MLSPCF to MLSPCF3.
!#
!# Revision 1.3  2000/12/29 20:40:04  nakamura
!# Changed ReadL2GPProd to take start & end days as input; modified ResidualOutput for the one-product/all-days paradigm.
!#
!# Revision 1.2  2000/12/07 19:28:27  nakamura
!# Updated for level becoming an expandable template field.
!#
!# Revision 1.1  2000/11/15 20:56:51  nakamura
!# Module containing subroutines related to L2GP data.
!#
@


1.24
log
@mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
@
text
@d21 1
a21 1
       & mls_hdf_version, mls_inqswath, close_MLSFile, open_MLSFile
d261 1
a261 1
           call open_MLSFile( MLSFile )
d335 1
a335 1
           call open_MLSFile( MLSFile )
d394 1
a394 1
            call close_MLSFile( MLSFile )
d625 1
a625 1
      call open_MLSFile( MLSFile )
d638 1
a638 1
      call close_MLSFile ( MLSFile )
d754 1
a754 1
       "$Id: L2Interface.f90,v 1.23 2007/06/26 19:06:26 cvuu Exp $"
d763 3
@


1.23
log
@fix bug
@
text
@d19 3
a21 3
  USE MLSCommon, ONLY: r8
  USE MLSFiles, ONLY: mls_openFile, mls_closeFile, & 
       & mls_hdf_version, mls_inqswath, mls_io_gen_openF, mls_io_gen_closeF
d125 1
a125 1
           read((physicalFilename(indx-3:indx-1)),'(i3)') doy_current
d193 1
a193 1
          read((physicalFilename(indx-3:indx-1)),'(i3)') doy_current
d236 1
d259 11
a269 7
           file_id = mls_io_gen_openF(l_swath, .TRUE., status, &
              & record_length, DFACC_READ, pcfNames(i), &
              & hdfVersion=the_hdfVersion, debugOption=.false. )
           if ( status /= 0 ) &
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & "Unable to open L2gp file: " &
                & // trim(pcfNames(i))//' for reading')
d333 4
d338 7
a344 7
          file_id = mls_io_gen_openF(l_swath, .TRUE., status, &
            & record_length, DFACC_READ, pcfNames(i), &
            & hdfVersion=the_hdfVersion, debugOption=.false. )
          if ( status /= 0 ) &
            call MLSMessage ( MLSMSG_Error, ModuleName, &
		& "Unable to open L2gp file: " &
		& // trim(pcfNames(i))//' for reading')
d394 1
d396 5
a400 5
            status = mls_io_gen_closeF(l_swath, file_id, pcfNames(i), & 
           	& hdfVersion=the_hdfVersion)
            if ( status /= 0 ) &
           	call MLSMessage ( MLSMSG_Error, ModuleName, &
       	      	   & "Unable to close L2gp file:"//trim(pcfNames(i)))
d587 1
d623 4
d628 3
a630 3
      file_id = mls_io_gen_openF(l_swath, .TRUE., status, &
           & record_length, DFACC_RDWR, l3File, &
           & hdfVersion=hdfVersion, debugOption=.false. )
d636 3
a638 2
      status = mls_io_gen_closeF(l_swath, file_id, l3File, & 
           & hdfVersion=hdfVersion)
d754 1
a754 1
       "$Id: L2Interface.f90,v 1.22 2006/05/31 21:05:35 cvuu Exp $"
d763 3
@


1.22
log
@Check missing dates that are not in the PCF; Fix orbit number and orbit period for L3DZ
@
text
@d659 1
a659 1
   CHARACTER (LEN=8000) :: list, templist
d677 1
a677 1
 
d689 1
d738 1
a738 1
       "$Id: L2Interface.f90,v 1.21 2006/05/24 19:14:30 cvuu Exp $"
d747 3
@


1.21
log
@Fix the deallocate problem
@
text
@a78 1
    
a79 1
    
a80 1
    
a81 1
    
a83 1
!    CHARACTER (LEN=DATE_LEN), INTENT(OUT) :: mis_Days(:)
d96 1
a96 1
    INTEGER :: i, indx, returnStatus, version, size, err
d98 1
d113 4
a116 1
 
d119 1
a119 2
    DO i = mlspcf_start, mlspcf_end
       
d122 6
a127 1
      
d137 2
a138 4
       IF(returnStatus /= PGS_S_SUCCESS) THEN
          
          IF ( INDEX(physicalFilename, TRIM(type)) /= 0 ) THEN
       
a139 1
             
d144 1
a144 1
                IF ( (date .GE. startDOY) .AND. (date .LE. endDOY) ) THEN
d150 1
a150 1
		   IF (numFiles <= (endInt - startInt)) then 
d161 3
a163 6
		   ENDIF
                
                ENDIF
             
          ENDIF
          
d165 1
a165 2
          
       ENDIF
d168 1
a168 3
      
       IF ( INDEX(physicalFilename, TRIM(type)) /= 0 ) THEN
          
a169 1
           
d179 1
a179 2
          IF ( (date .GE. startDOY) .AND. (date .LE. endDOY) ) THEN
             
a180 1
            
d188 2
a189 4
	     end if
          ENDIF
          
       ENDIF
d191 20
a210 2
    ENDDO
    
d230 1
a230 1
    CHARACTER (LEN=*), INTENT(IN) :: l3StartDay, l3EndDay, tempfile
d232 1
a232 1
    Integer, intent(in), optional :: L3MFlag
d236 6
a241 7
    CHARACTER (LEN=FileNameLen) :: pcfNames(40)
    !CHARACTER (LEN=DATE_LEN) :: mis_Days(maxMisDays)
    INTEGER :: mis_Days(maxMisDays), misDInt
    INTEGER :: numDays, mis_numDay, the_hdfVersion, file_id
    INTEGER :: record_length, i, status, aID, mis_numDays, n=1 
    INTEGER :: Flag = 0, size, err=0, indx, j, k, l3DayInt, m=1
    INTEGER, external :: HE5_EHrdglatt
d252 31
a282 1
    endif
d284 28
a311 16
    call Allocate_test (GlobalAttributes%OrbNumDays, max_orbits, &
	& numDays+mis_numDays,'GlobalAttributes%OrbNumDays', ModuleName)
    call Allocate_test (GlobalAttributes%OrbPeriodDays, max_orbits, &
	& numDays+mis_numDays,'GlobalAttributes%OrbPeriodDays', ModuleName)

    DO i = 1, numDays

       m = n
       if (present(L3MFLag) .and. i==numDays ) exit

       the_hdfVersion = mls_hdf_version(trim(pcfNames(i)))
       pcfFileNames = trim(pcfNames(i))
       indx = INDEX(pcfFileNames, '.', .TRUE.)
       date = pcfFileNames(indx-3:indx-1)
       read(date, '(i3)')l3DayInt 
       l3DayInt = l3DayInt - 1
d313 7
a319 7
       do j = 1, mis_numDays
	   write(misDchar, '(I7)') mis_Days(j)
	   misD = misDchar(5:7)
           read(misD, '(i3)')misDInt 
	   if (l3DayInt == misDInt) then
	       do k = 1, 16
	          GlobalAttributes%OrbNumDays(k,m) = &
d321 6
a326 6
	          GlobalAttributes%OrbPeriodDays(k,m) = 5930.5056 
	       enddo  
	       n = n+1
	       m = m+1
	    endif
       enddo
d328 2
a329 2
       ! file_id = mls_io_gen_openF('swopen', .TRUE., status, &
       file_id = mls_io_gen_openF(l_swath, .TRUE., status, &
d332 1
a332 1
       if ( status /= 0 ) &
d391 1
a391 17
    END DO

    if (present(L3MFlag)) then
       GlobalAttributes%OrbNumDays(:,numDays+mis_numDays) = -1
       GlobalAttributes%OrbNumDays(1:1,numDays+mis_numDays) = &
	      &	GlobalAttributes%OrbNumDays(1:1,1)
       GlobalAttributes%OrbNumDays(2:2,numDays+mis_numDays) = &
	      &	maxval(GlobalAttributes%OrbNumDays(:,numDays+mis_numDays-1))
!       call output('OrbNum_last =', advance='no')
!       call output(GlobalAttributes%OrbNumDays(:,numDays+mis_numDays), advance='yes')
       GlobalAttributes%OrbPeriodDays(:,numDays+mis_numDays) = -1.0
       GlobalAttributes%OrbPeriodDays(1:1,numDays+mis_numDays) = &
	      &	GlobalAttributes%OrbPeriodDays(1:1,1)
       GlobalAttributes%OrbPeriodDays(2:2,numDays+mis_numDays) = &
	      &	maxval(GlobalAttributes%OrbPeriodDays(:,numDays+mis_numDays-1))
!       call output('OrbNum_last =', advance='no')
!       call output(GlobalAttributes%OrbPeriodDays(:,numDays+mis_numDays), advance='yes')
a544 1
         
d737 1
a737 1
       "$Id: L2Interface.f90,v 1.20 2006/04/17 15:43:04 cvuu Exp $"
d746 3
@


1.20
log
@Remove the print statements
@
text
@d430 1
a430 1
          CALL SetupNewL2GPRecord(l3Res(i), nFreqs=0, nLevels=totalIndex, &
d551 1
d588 1
a588 1
           & hdfVersion=hdfVersion)
d706 1
a706 1
       "$Id: L2Interface.f90,v 1.19 2006/02/28 17:56:56 cvuu Exp $"
d715 3
@


1.19
log
@V2.00 commit
@
text
@d351 2
a352 2
       call output('OrbNum_last =', advance='no')
       call output(GlobalAttributes%OrbNumDays(:,numDays+mis_numDays), advance='yes')
d358 2
a359 2
       call output('OrbNum_last =', advance='no')
       call output(GlobalAttributes%OrbPeriodDays(:,numDays+mis_numDays), advance='yes')
d705 1
a705 1
       "$Id: L2Interface.f90,v 1.18 2005/06/23 19:07:38 pwagner Exp $"
d714 3
@


1.18
log
@Reworded Copyright statement, moved rcs id
@
text
@d17 2
a18 1
  USE L2GPData, ONLY: L2GPData_T, ReadL2GPData, WriteL2GPData, SetupNewL2GPRecord
d40 1
a40 1
       "$RCSfile: $"
d99 1
a99 1
    CHARACTER (LEN=3) :: startChar, endChar
d102 1
a102 1
    INTEGER :: startInt, endInt, dateInt
a103 1
 
d116 2
a117 1
    
d153 1
a153 2
                
                    mis_numFiles = mis_numFiles + 1
d157 1
a157 1
	              dateChar = date(1:4) // date(6:8)
d159 1
a183 2
             print *, startDOY 
             print *, endDOY 
d209 1
a209 1
  SUBROUTINE ReadL2GPAttribute(l3StartDay, l3EndDay, tempfile, L3MFlag)
d224 1
d231 1
a231 1
    INTEGER :: mis_Days(maxMisDays)
d233 2
a234 2
    INTEGER :: record_length, i, status, aID, mis_numDays
    INTEGER :: Flag = 0, size, err=0
d236 4
a239 1
    character  (len=20) :: name
d244 3
a246 1
    if (present(L3MFlag)) numDays = numDays + 1
d249 1
a249 1
	& numDays,'GlobalAttributes%OrbNumDays', ModuleName)
d251 1
a251 1
	& numDays,'GlobalAttributes%OrbPeriodDays', ModuleName)
d255 1
d259 20
d280 2
a281 6
      if (the_hdfVersion == 4) then
	 GlobalAttributes%OrbNumDays(:,i) = -1
	 GlobalAttributes%OrbPeriodDays(:,i) = -1.0
      else 
         ! file_id = mls_io_gen_openF('swopen', .TRUE., status, &
         file_id = mls_io_gen_openF(l_swath, .TRUE., status, &
d284 1
a284 1
         if ( status /= 0 ) &
d289 2
a290 1
		& GlobalAttributes%OrbNumDays(:,i))
d293 1
a293 1
       	    	  & "Unable to read attribute OrbitNumber for " &
d295 4
a298 1
	       GlobalAttributes%OrbNumDays(:,i) = -1
d301 1
a301 1
!            call output(GlobalAttributes%OrbNumDays(:,i), advance='yes')
d304 1
a304 1
		& GlobalAttributes%OrbPeriodDays(:,i))
d309 6
a314 1
	  	GlobalAttributes%OrbPeriodDays(:,i) = -1.0
d317 19
a335 1
!            call output(GlobalAttributes%OrbPeriodDays(:,i), advance='yes')
a342 1
	end if
d346 2
a347 2
       GlobalAttributes%OrbNumDays(:,numDays) = -1
       GlobalAttributes%OrbNumDays(1:1,numDays) = &
d349 6
a354 6
       GlobalAttributes%OrbNumDays(2:2,numDays) = &
	      &	maxval(GlobalAttributes%OrbNumDays(:,numDays-1))
!       call output('OrbNum_last =', advance='no')
!       call output(GlobalAttributes%OrbNumDays(:,numDays), advance='yes')
       GlobalAttributes%OrbPeriodDays(:,numDays) = -1.0
       GlobalAttributes%OrbPeriodDays(1:1,numDays) = &
d356 4
a359 4
       GlobalAttributes%OrbPeriodDays(2:2,numDays) = &
	      &	maxval(GlobalAttributes%OrbPeriodDays(:,numDays-1))
!       call output('OrbNum_last =', advance='no')
!       call output(GlobalAttributes%OrbPeriodDays(:,numDays), advance='yes')
d387 1
a387 1
  SUBROUTINE SetupL2GPProd (numDays, totalIndex, totalTimes, prodL2GP)
d396 1
a396 1
    INTEGER, INTENT(IN) :: numDays, totalIndex, totalTimes
d398 1
a398 1
    TYPE( L2GPData_T ), POINTER :: prodL2GP(:)
d416 1
a416 1
       NULLIFY(prodL2GP)
d422 1
a422 1
       ALLOCATE( prodL2GP(numDays), STAT=err )
d427 1
a427 1
         
a428 1
                        
d430 18
a447 3
          CALL SetupNewL2GPRecord(prodL2GP(i), nFreqs=0, nLevels=totalIndex, &
	     & nTimes=totalTimes, nTimesTotal=totalTimes, Fillin=.false. )
                        
a480 1
      
d483 2
a484 1
      
a515 1
                        
a517 1
                        
d549 2
a550 2
   
   INTEGER :: i, match, numDays, file_id, hdfVersion, record_length, status 
d559 7
a565 2
      
      CALL FindFileDay(type, l3r(i)%time(1), mlspcf_l3dm_start, &
d585 1
a585 1
      !call dump (real(l3r(i)%l2gpValue, r8), 'l2gpValue: ')
d599 1
a599 1
 SUBROUTINE ReadL2DGData (product, numFiles, files, numDays, prodL2GP)
d617 1
a617 1
   TYPE( L2GPData_T ), POINTER :: prodL2GP(:)
d620 3
a622 1
            
d627 1
a627 1
   CHARACTER (LEN=6000) :: list
d637 9
a645 1
   
d647 1
a647 9
         
      ns = mls_inqswath( files(i), list, len, hdfversion=5 )

      IF (ns == -1) THEN
         msr = 'Failed to read swath list from ' // files(i)
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
         CYCLE
      ENDIF
         
a663 1
            
a664 1
         
d675 1
a675 1
      NULLIFY(prodL2GP)
d681 1
a681 1
      ALLOCATE( prodL2GP(numDays), STAT=err )
d691 1
a691 1
         CALL ReadL2GP( prodFiles(i), product, prodL2GP(i) )
d705 1
a705 1
       "$Id: $"
d714 3
@


1.17
log
@Changed interface to mls_io_gen functions
@
text
@d1 10
a10 2
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a35 1
  PRIVATE :: ID, ModuleName
d37 5
a41 5
  !------------------- RCS Ident Info -----------------------
  CHARACTER(LEN=130) :: Id = &
       "$Id: L2Interface.f90,v 1.16 2004/06/22 16:55:47 cvuu Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: L2Interface.f90,v $"
  !----------------------------------------------------------
d637 8
d649 3
@


1.16
log
@Using SetupNewL2GPRecord for L3 Residual based on the nLevels from L3 not L2
@
text
@d8 1
d32 1
a32 1
       "$Id: L2Interface.f90,v 1.15 2004/05/04 15:33:15 cvuu Exp $"
d251 2
a252 1
         file_id = mls_io_gen_openF('swopen', .TRUE., status, &
d281 2
a282 1
            status = mls_io_gen_closeF('swclose', file_id, pcfNames(i), & 
d508 2
a509 1
      file_id = mls_io_gen_openF('swopen', .TRUE., status, &
d517 1
a517 1
      status = mls_io_gen_closeF('swclose', file_id, l3File, & 
d634 3
@


1.15
log
@v1.4.3: Use int array for Date in Data Field
@
text
@d8 1
a8 1
  USE L2GPData, ONLY: L2GPData_T, ReadL2GPData, WriteL2GPData
d20 2
d25 1
a25 1
	& ReadL2DGData, ReadL2GPAttribute
d31 1
a31 1
       "$Id: L2Interface.f90,v 1.14 2004/01/07 21:43:18 cvuu Exp $"
d329 55
d509 1
d592 1
a592 1
   
d630 3
@


1.14
log
@version 1.4 commit
@
text
@d29 1
a29 1
       "$Id: L2Interface.f90,v 1.13 2003/09/15 18:30:48 cvuu Exp $"
d75 1
d77 1
a77 1
    CHARACTER (LEN=DATE_LEN), INTENT(OUT) :: mis_Days(:)
d87 2
d91 1
a107 1
     !  call output( PGS_S_SUCCESS, advance='yes')
d122 1
a122 1
      
d126 2
d129 3
a131 14
             ! Extract the date from the file name
             
             indx = INDEX(physicalFilename, '.', .TRUE.)
             !date = physicalFilename(indx-8:indx-1)
             date = physicalFilename(indx-8:indx-5)//'-'//physicalFilename(indx-3:indx-1)

             if (DEBUG) then
          	call output('date=', advance='no')
	  	call output( date, advance='yes')
          	print *, startDOY 
          	print *, endDOY 
	     end if

             ! Check that the date is within the desired boundaries for reading
d133 9
a141 1
             IF ( (date .GE. startDOY) .AND. (date .LE. endDOY) ) THEN
d143 1
a143 1
                ! Save the name in an array of files for the species
d145 6
a150 2
                mis_numFiles = mis_numFiles + 1
                mis_Days(mis_numFiles) = date
d152 1
a152 1
             ENDIF
a166 1
          !date = physicalFilename(indx-8:indx-1)
d220 2
a221 1
    CHARACTER (LEN=DATE_LEN) :: mis_Days(maxMisDays)
a227 3
  !  call output('filetemplate= ', advance='no')
  !  call output(tempfile, advance='yes')

a230 2
!    call output('subroutine ReadL2GPAttribute', advance='yes')

a242 4
!      call output('the_hdfVersion= ', advance='no')
!      call output(the_hdfVersion, advance='yes')
!      call output('pcfNames= ', advance='no')
!      call output(trim(pcfNames(i)), advance='yes')
a250 2
  !      call output('file_id= ', advance='no')
  !      call output(file_id, advance='yes')
a263 3
!            call output('ok reading orbitNumber', advance='yes')
!            call output(status, advance='yes')
!            call output('OrbitNumber =', advance='no')
a274 3
!      	    call output('ok reading orbitPeriod', advance='yes')
!            call output(status, advance='yes')
!            call output('OrbitPeriod =', advance='no')
a275 1
!            call output(GlobalAttributes%OrbPeriodDays(2:2,i), advance='yes')
d346 2
a347 1
    CHARACTER (LEN=DATE_LEN), INTENT(OUT) :: mis_Days(:)
d357 3
a359 1
            
a496 1

a505 5
      !call output('files= '//trim(files(i)), advance='yes')
      !call output('list= '//trim(list), advance='yes')
      !call output('ns= ', advance='no')
      !call output(ns, advance='yes')

d572 3
@


1.13
log
@Read OrbitNumber and OrbitPeriod from L2GP files
@
text
@a0 1

d13 1
a13 1
       & GRIDNAMELEN
d29 1
a29 1
       "$Id: L2Interface.f90,v 1.12 2003/04/30 18:15:48 pwagner Exp $"
d77 1
a77 1
    
d87 4
a90 2
    INTEGER :: i, indx, returnStatus, version
    
d94 6
a99 1
   
d104 2
a105 1
    
d111 6
a116 4
   !    call output( 'physicalFilename = ', advance='no')
   !    call output( trim(physicalFilename), advance='yes')
   !    call output( 'returnStatus = ', advance='no')
   !    call output( returnStatus, advance='yes')
d119 1
a119 1
       
d127 9
a135 1
             date = physicalFilename(indx-8:indx-1)
a158 1
   !       call output('test here', advance='yes')
d161 2
a162 1
          date = physicalFilename(indx-8:indx-1)
d165 6
a170 4
   !       call output('date=', advance='no')
!	  call output( date, advance='yes')
!          print *, startDOY 
!          print *, endDOY 
d178 6
a183 4
!   	     call output('numFiles = ', advance ='no')          
!   	     call output(numFiles, advance ='yes')          
!   	     call output('pcfNames = ', advance ='no')          
!   	     call output(trim(pcfNames(numFiles)), advance ='yes')          
d215 1
a215 1
    CHARACTER (LEN=DATE_LEN) :: mis_Days(maxWindow)
d218 1
a218 1
    INTEGER :: Flag = 0
d228 1
a228 1
    call output('subroutine ReadL2GPAttribute', advance='yes')
d237 3
a239 1
    DO i = 1, numDays-1
d241 5
a245 5
      the_hdfVersion = mls_hdf_version(trim(pcfNames(i)))
      call output('the_hdfVersion= ', advance='no')
      call output(the_hdfVersion, advance='yes')
      call output('pcfNames= ', advance='no')
      call output(trim(pcfNames(i)), advance='yes')
d269 4
a272 4
            call output('ok reading orbitNumber', advance='yes')
            call output(status, advance='yes')
            call output('OrbitNumber =', advance='no')
            call output(GlobalAttributes%OrbNumDays(:,i), advance='yes')
d274 1
a274 1
            status = HE5_EHrdglatt(file_id, 'OrbitNumber', & 
d280 1
a280 1
	  	GlobalAttributes%OrbPeriodDays(:,i) = -1
d283 5
a287 9
      	    call output('ok reading orbitPeriod', advance='yes')
            call output(status, advance='yes')
            call output('OrbitPeriod =', advance='no')
            call output(GlobalAttributes%OrbPeriodDays(:,i), advance='yes')
    !        call output(GlobalAttributes%OrbPeriodDays(2:2,i), advance='yes')

            !status = HE5_EHrdglatt(file_id, 'InstrumentName', name)
            !call output('name= ', advance='no')
            !call output(name, advance='yes')
d303 3
a305 3
       call output('OrbNum_last =', advance='no')
       call output(GlobalAttributes%OrbNumDays(:,numDays), advance='yes')
       GlobalAttributes%OrbPeriodDays(:,numDays) = -1
d310 2
a311 2
       call output('OrbNum_last =', advance='no')
       call output(GlobalAttributes%OrbPeriodDays(:,numDays), advance='yes')
d331 2
a332 2
    
    call ReadL2GPData(L2FileName, swathname, l2gpData)
d358 1
a358 1
    CHARACTER (LEN=DATE_LEN), INTENT(OUT) :: mis_Days(maxWindow)
d394 1
a397 1

d505 1
a505 1
   INTEGER :: err, i, j, indx, len, ns
d514 6
a519 1
      ns = mls_inqswath( files(i), list, len )
d587 3
@


1.12
log
@Work-around for LF95 infinite compile-time bug
@
text
@d19 1
d23 2
a24 1
  PUBLIC :: GetL2GPfromPCF, ReadL2GP, ReadL2GPProd, ResidualOutput, ReadL2DGData
d30 1
a30 1
       "$Id: L2Interface.f90,v 1.11 2003/03/22 02:41:32 jdone Exp $"
d41 1
d93 1
a93 1
    
d103 6
a108 1
       
d119 1
a119 1
             
d138 1
a138 1
       
d142 2
a143 1
          
d148 5
a152 1
          
d156 1
a156 1
             
d159 4
a162 1
             
d174 126
d378 1
a378 1
            
d563 3
@


1.11
log
@implemented L2GPData library routines
@
text
@a8 1
  USE HDF, ONLY: DFACC_RDWR
a19 1
  USE SDPToolkit, ONLY: PGS_S_SUCCESS, Pgs_pc_getReference
d21 2
a22 1
  PUBLIC
d28 1
a28 1
       "$Id: L2Interface.f90,v 1.10 2002/04/15 22:25:00 jdone Exp $"
a36 2
  !                ResidualCreate
  !                ResidualWrite
d45 5
a49 5
  CHARACTER (LEN=*), PARAMETER :: DATA_FIELD1 = 'L2gpValue'
  CHARACTER (LEN=*), PARAMETER :: DATA_FIELD2 = 'L2gpPrecision'
  CHARACTER (LEN=*), PARAMETER :: DATA_FIELD3 = 'Status'
  CHARACTER (LEN=*), PARAMETER :: DATA_FIELD4 = 'Quality'
  CHARACTER (LEN=*), PARAMETER :: DATA_FIELD5 = 'L3Residual'
d57 1
d250 1
d421 3
@


1.10
log
@ swid checked
@
text
@d5 1
a5 1
!===============================================================================
d7 1
a7 42
!===============================================================================

   USE Hdf
   USE L2GPData, ONLY: L2GPData_T
   USE MLSCommon
   USE MLSL3Common
   USE MLSMessageModule
   USE MLSPCF3
   USE MLSStrings
   USE OpenInit
   USE SDPToolkit
   IMPLICIT NONE
   PUBLIC

   PRIVATE :: ID, ModuleName

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &
   "$Id: L2Interface.f90,v 1.9 2002/04/11 22:29:47 jdone Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: L2Interface.f90,v $"
!----------------------------------------------------------

! Contents:

! Subroutines -- GetL2GPfromPCF
!                ReadL2GP
!                ReadL2GPProd
!                ResidualCreate
!                ResidualWrite
!                ResidualOutput
!                ReadL2DGData

! Remarks:  This module contains subroutines involving the interface between
!           Level 3 and L2.

! Parameters

   CHARACTER (LEN=*), PARAMETER :: DATA_FIELD1 = 'L2gpValue'
   CHARACTER (LEN=*), PARAMETER :: DATA_FIELD2 = 'L2gpPrecision'
   CHARACTER (LEN=*), PARAMETER :: DATA_FIELD3 = 'Status'
   CHARACTER (LEN=*), PARAMETER :: DATA_FIELD4 = 'Quality'
   CHARACTER (LEN=*), PARAMETER :: DATA_FIELD5 = 'L3Residual'
d9 45
d55 300
d356 2
a357 368
!----------------------------------------------------------------------------
   SUBROUTINE GetL2GPfromPCF (mlspcf_start, mlspcf_end, template, startDOY, &
                              endDOY, numFiles, pcfNames, mis_numFiles, mis_Days)
!----------------------------------------------------------------------------

! Brief description of subroutine
! This routine searches the PCF for l2gp files for a desired species.  It
! returns an array of names and the number of the files found.

! Arguments

      CHARACTER (LEN=8), INTENT(IN) :: endDOY, startDOY

      CHARACTER (LEN=*), INTENT(IN) :: template

      INTEGER, INTENT(IN) :: mlspcf_end, mlspcf_start

      INTEGER, INTENT(OUT) :: numFiles, mis_numFiles

      CHARACTER (LEN=FileNameLen) :: pcfNames(:)
      CHARACTER (LEN=DATE_LEN), INTENT(OUT) :: mis_Days(:)

! Parameters

! Functions

! Variables

      CHARACTER (LEN=8) :: date
      CHARACTER (LEN=FileNameLen) :: physicalFilename, type

      INTEGER :: i, indx, returnStatus, version

! Expand the level/species template

      CALL ExpandFileTemplate(template, type, 'L2GP')

      numFiles = 0
      mis_numFiles = 0

! Loop through all the PCF numbers for L2GP files

      DO i = mlspcf_start, mlspcf_end

         version = 1
         returnStatus = Pgs_pc_getReference(i, version, physicalFilename)

! If no file name was returned, go on to the next PCF number

	 IF(returnStatus /= PGS_S_SUCCESS) THEN

            IF ( INDEX(physicalFilename, TRIM(type)) /= 0 ) THEN

! Extract the date from the file name

            	indx = INDEX(physicalFilename, '.', .TRUE.)
            	date = physicalFilename(indx-8:indx-1)

! Check that the date is within the desired boundaries for reading

            	IF ( (date .GE. startDOY) .AND. (date .LE. endDOY) ) THEN

! Save the name in an array of files for the species

               		mis_numFiles = mis_numFiles + 1
               		mis_Days(mis_numFiles) = date

            	ENDIF

            ENDIF

	    CYCLE

         ENDIF

! Check that the returned file name is for the proper species

         IF ( INDEX(physicalFilename, TRIM(type)) /= 0 ) THEN

! Extract the date from the file name

            indx = INDEX(physicalFilename, '.', .TRUE.)
            date = physicalFilename(indx-8:indx-1)

! Check that the date is within the desired boundaries for reading

            IF ( (date .GE. startDOY) .AND. (date .LE. endDOY) ) THEN

! Save the name in an array of files for the species

               numFiles = numFiles + 1
               pcfNames(numFiles) = physicalFilename

            ENDIF

         ENDIF

      ENDDO

!-------------------------------
   END SUBROUTINE GetL2GPfromPCF
!-------------------------------

!--------------------------------------------------------
   SUBROUTINE ReadL2GP(L2FileHandle, swathname, l2gpData)
!--------------------------------------------------------

! Brief description of subroutine
! This routine reads an L2GP file, returning a filled data structure.

! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: swathname

      INTEGER, INTENT(IN) :: L2FileHandle

      TYPE( L2GPData_T ), INTENT(OUT) :: l2gpData

! Parameters

      CHARACTER (LEN=*), PARAMETER :: MLSMSG_L2GPRead = 'Unable to read L2GP field:'

! Functions

      INTEGER, EXTERNAL :: swattach, swdetach, swdiminfo, swinqdims, swrdfld

! Variables

      CHARACTER (LEN=80) :: list
      CHARACTER (LEN=480) :: msr

      INTEGER :: alloc_err, freq, lev, nDims, numFreq, numLev, numProfs, size, swid
      INTEGER :: status
      INTEGER :: start(3), stride(3), edge(3), dims(3)

      REAL, ALLOCATABLE :: realFreq(:), realSurf(:), realProf(:), real3(:,:,:)

! Attach to the swath for reading

      l2gpData%name = swathname

      swid = swattach(L2FileHandle, l2gpData%name)

      IF (swid == -1) THEN
        CALL MLSMessage(MLSMSG_Error, ModuleName, & 
        'Failed to attach to swath interface for reading.')
      ENDIF

! Get dimension information

      lev = 0
      freq = 0

      nDims = swinqdims(swid, list, dims)
      IF (nDims == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
                                               &get dimension information.')
      IF ( INDEX(list,'nLevels') /= 0 ) lev = 1
      IF ( INDEX(list,'nFreqs') /= 0 ) freq = 1

      size = swdiminfo(swid, DIM_NAME1)
      IF (size == -1) THEN
         msr = SZ_ERR // DIM_NAME1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      l2gpData%nTimes = size
      numProfs = size

      IF (lev == 0) THEN
         l2gpData%nLevels = 0
         numLev = 1
      ELSE
         size = swdiminfo(swid, DIM_NAME2)
         IF (size == -1) THEN
            msr = SZ_ERR // DIM_NAME2
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         l2gpData%nLevels = size
         numLev = size
      ENDIF

      IF (freq == 1) THEN
         size = swdiminfo(swid, DIM_NAME3)
         IF (size == -1) THEN
            msr = SZ_ERR // DIM_NAME3
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         l2gpData%nFreqs = size
         numFreq = size
      ELSE
         l2gpData%nFreqs = 0
         numFreq = 1
      ENDIF

! Allocate output pointers for fields that are always present

      if (numProfs.gt.0) then 

      ALLOCATE (l2gpData%latitude(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  latitude pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (l2gpData%longitude(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  longitude pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (l2gpData%time(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  time pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (l2gpData%solarTime(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  solarTime pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (l2gpData%solarZenith(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  solarZenith pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (l2gpData%losAngle(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  losAngle pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (l2gpData%geodAngle(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  geodAngle pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (l2gpData%chunkNumber(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  chunkNumber pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (l2gpData%status(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  status pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (l2gpData%quality(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  quality pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (realProf(numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  realProf array.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      endif

      if (numLev.gt.0) then 

      ALLOCATE (realSurf(numLev), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  realSurf array.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      endif

      if (numFreq.gt.0) then 

      ALLOCATE (realFreq(numFreq), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  realFreq array.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      endif

      if ((numFreq.gt.0).and.(numLev.gt.0).and.(numProfs.gt.0)) then 

      ALLOCATE (l2gpData%l2gpValue(numFreq,numLev,numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  l2gpValue pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (l2gpData%l2gpPrecision(numFreq,numLev,numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  l2gpPrecision pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE (real3(numFreq,numLev,numProfs), STAT=alloc_err)
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  real3 array.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      endif

! Read the horizontal geolocation fields

      start = 0
      stride = 1
      edge(1) = numFreq
      edge(2) = numLev
      edge(3) = numProfs

      if (numProfs .gt. 0) then

      status = swrdfld(swid, GEO_FIELD1, start(3), stride(3), edge(3), realProf)
      IF (status == -1) THEN
         msr = MLSMSG_L2GPRead // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      l2gpData%latitude = DBLE(realProf)

      status = swrdfld(swid, GEO_FIELD2, start(3), stride(3), edge(3), realProf)
      IF (status == -1) THEN
         msr = MLSMSG_L2GPRead // GEO_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      l2gpData%longitude = DBLE(realProf)

      status = swrdfld(swid, GEO_FIELD3, start(3), stride(3), edge(3), l2gpData%time)
      IF (status == -1) THEN
         msr = MLSMSG_L2GPRead // GEO_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swrdfld(swid, GEO_FIELD4, start(3), stride(3), edge(3), realProf)
      IF (status == -1) THEN
         msr = MLSMSG_L2GPRead // GEO_FIELD4
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      l2gpData%solarTime = DBLE(realProf)

      status = swrdfld(swid, GEO_FIELD5, start(3), stride(3), edge(3), realProf)
      IF (status == -1) THEN
         msr = MLSMSG_L2GPRead // GEO_FIELD5
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      l2gpData%solarZenith = DBLE(realProf)

      status = swrdfld(swid, GEO_FIELD6, start(3), stride(3), edge(3), realProf)
      IF (status == -1) THEN
         msr = MLSMSG_L2GPRead // GEO_FIELD6
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      l2gpData%losAngle = DBLE(realProf)

      status = swrdfld(swid, GEO_FIELD7, start(3), stride(3), edge(3), realProf)
      IF (status == -1) THEN
         msr = MLSMSG_L2GPRead // GEO_FIELD7
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      l2gpData%geodAngle = DBLE(realProf)

      status = swrdfld(swid, GEO_FIELD8, start(3), stride(3), edge(3), l2gpData%chunkNumber)
      IF (status == -1) THEN
         msr = MLSMSG_L2GPRead // GEO_FIELD8
d359 1
d361 16
a376 11

      endif

! Read the pressures vertical geolocation field, if it exists

      IF (lev /= 0) THEN

         ALLOCATE (l2gpData%pressures(l2gpData%nLevels), STAT=alloc_err)
         IF ( alloc_err /= 0 ) THEN
            msr = MLSMSG_Allocate // '  l2gp pressure pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d378 22
a399 99

         status = swrdfld(swid, GEO_FIELD9, start(2), stride(2), edge(2), realSurf)
         IF (status == -1) THEN
            msr = MLSMSG_L2GPRead // GEO_FIELD9
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         l2gpData%pressures = DBLE(realSurf)
     ENDIF

! Read the frequency geolocation field, if it exists

      IF (freq == 1) THEN

         ALLOCATE (l2gpData%frequency(l2gpData%nFreqs), STAT=alloc_err)
         IF ( alloc_err /= 0 ) THEN
            msr = MLSMSG_Allocate // '  l2gp frequency pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         edge(1) = l2gpData%nFreqs

         status = swrdfld(swid, GEO_FIELD10, start(1), stride(1), edge(1), realFreq)
         IF (status == -1) THEN
             msr = MLSMSG_L2GPRead // GEO_FIELD10
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         l2gpData%frequency = DBLE(realFreq)

      ENDIF

! Read the data fields that may have 1-3 dimensions

      IF ( freq == 1) THEN

         status = swrdfld(swid, DATA_FIELD1, start, stride, edge, real3)
         IF (status == -1) THEN
            msr = MLSMSG_L2GPRead // DATA_FIELD1
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         l2gpData%l2gpValue = DBLE(real3)

         status = swrdfld(swid, DATA_FIELD2, start, stride, edge, real3)
         IF (status == -1) THEN
            msr = MLSMSG_L2GPRead // DATA_FIELD2
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         l2gpData%l2gpPrecision = DBLE(real3)

      ELSE IF ( lev == 1) THEN

         status = swrdfld( swid, DATA_FIELD1, start(2:3), stride(2:3), &
                           edge(2:3), real3(1,:,:) )
         IF (status == -1) THEN
            msr = MLSMSG_L2GPRead // DATA_FIELD1
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         l2gpData%l2gpValue = DBLE(real3)

         status = swrdfld( swid, DATA_FIELD2, start(2:3), stride(2:3), &
                           edge(2:3), real3(1,:,:) )
         IF (status == -1) THEN
            msr = MLSMSG_L2GPRead // DATA_FIELD2
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         l2gpData%l2gpPrecision = DBLE(real3)

      ELSE

         status = swrdfld( swid, DATA_FIELD1, start(3), stride(3), edge(3), &
                           real3(1,1,:) )
         IF (status == -1) THEN
            msr = MLSMSG_L2GPRead // DATA_FIELD1
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         l2gpData%l2gpValue = DBLE(real3)

         status = swrdfld( swid, DATA_FIELD2, start(3), stride(3), edge(3), &
                           real3(1,1,:) )
         IF (status == -1) THEN
            msr = MLSMSG_L2GPRead // DATA_FIELD2
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         l2gpData%l2gpPrecision = DBLE(real3)

      ENDIF

! Read the data fields that are 1-dimensional

      if (numProfs .gt. 0) then

      status = swrdfld(swid, DATA_FIELD3, start(3), stride(3), edge(3), l2gpData%status)
      IF (status == -1) THEN
         msr = MLSMSG_L2GPRead // DATA_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swrdfld(swid, DATA_FIELD4, start(3), stride(3), edge(3), realProf)
      IF (status == -1) THEN
         msr = MLSMSG_L2GPRead // DATA_FIELD4
d402 1
a402 500
      l2gpData%quality = DBLE(realProf)

      endif

! Deallocate local variables

      DEALLOCATE(realFreq, STAT=alloc_err)
      IF ( alloc_err /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, &
                                'Failed deallocation of local realFreq array.')

      DEALLOCATE(realSurf, STAT=alloc_err)
      IF ( alloc_err /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, &
                                'Failed deallocation of local realSurf array.')

      DEALLOCATE(realProf, STAT=alloc_err)
      IF ( alloc_err /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, &
                                'Failed deallocation of local realProf array.')

      DEALLOCATE(real3, STAT=alloc_err)
      IF ( alloc_err /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, &
                                'Failed deallocation of local real3 array.')

!  After reading, detach from swath interface

      status = swdetach(swid)
      IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
                                 &detach from swath interface after reading.')

!-------------------------
   END SUBROUTINE ReadL2GP
!-------------------------

!----------------------------------------------------------------------------------
   SUBROUTINE ReadL2GPProd (product, template, startDOY, endDOY, numDays, mis_numDays, mis_Days, prodL2GP)
!----------------------------------------------------------------------------------

! Brief description of subroutine
! This subroutine reads l2gp files for a quantity over a range of days.  It
! returns an array of L2GPData_T structures, with one structure per day.

! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: product, template

      CHARACTER (LEN=8), INTENT(IN) :: endDOY, startDOY

      INTEGER, INTENT(OUT) :: numDays, mis_numDays

      TYPE( L2GPData_T ), POINTER :: prodL2GP(:)

      CHARACTER (LEN=DATE_LEN), INTENT(OUT) :: mis_Days(maxWindow)

! Parameters

! Functions

      INTEGER, EXTERNAL :: swclose, swopen

! Variables

      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=FileNameLen) :: pcfNames(40)

      INTEGER :: err, i, l2id, status

! Search the PCF for L2GP files for this species

      CALL GetL2GPfromPCF(mlspcf_l2gp_start, mlspcf_l2gp_end, template, startDOY, &
                          endDOY, numDays, pcfNames, mis_numDays, mis_Days)

! Check that numDays is at least 1, so pointer allocation is possible

      IF (numDays == 0) THEN

! If not, issue a warning

         msr = 'No L2GP data found for ' // product
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
         NULLIFY(prodL2GP)

! If so, open, read, & close the files for this quantity

      ELSE

         ALLOCATE( prodL2GP(numDays), STAT=err )
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' l2gp array for ' // product
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         DO i = 1, numDays

            l2id = swopen(pcfNames(i), DFACC_READ)
            IF (l2id == -1) THEN
               msr = MLSMSG_Fileopen // pcfNames(i)
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

! Read information from the L2GP file

            CALL ReadL2GP( l2id, product, prodL2GP(i) )

! Close the L2GP file

            status = swclose(l2id)

            IF (status == -1) THEN
               msr = 'Failed to close file ' // pcfNames(i)
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

         ENDDO


      ENDIF

!-----------------------------
   END SUBROUTINE ReadL2GPProd
!-----------------------------

!------------------------------------------------
   SUBROUTINE ResidualCreate (L3FileHandle, l2gp)
!------------------------------------------------

! Brief description of subroutine
! This subroutine creates the L3Residual diagnostic swath in L3 map files.

! Arguments

      INTEGER, INTENT(IN) :: L3FileHandle

      TYPE( L2GPData_T ), INTENT(IN) :: l2gp

! Parameters

! Functions

      INTEGER, EXTERNAL :: swcreate, swdefdfld, swdefdim, swdefgfld, swdetach

! Variables

      CHARACTER (LEN=480) :: msr
  
      INTEGER :: swid, status

! Create the swath within the file

      swid = swcreate(L3FileHandle, l2gp%name)
      IF (swid == -1) THEN
         msr = 'Failed to create swath ' // l2gp%name
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Define dimensions

      status = swdefdim(swid, DIM_NAME1, l2gp%nTimes)
      IF (status == -1) THEN
         msr = DIM_ERR // DIM_NAME1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      IF (l2gp%nLevels > 0) THEN
         status = swdefdim(swid, DIM_NAME2, l2gp%nLevels)
         IF (status == -1) THEN
            msr = DIM_ERR // DIM_NAME2
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

      IF (l2gp%nFreqs > 0) THEN
         status = swdefdim(swid, DIM_NAME3, l2gp%nFreqs)
         IF (status == -1) THEN
            msr = DIM_ERR // DIM_NAME3
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

! Define horizontal geolocation fields using above dimensions

      status = swdefgfld(swid, GEO_FIELD1, DIM_NAME1, DFNT_FLOAT32, &
                         HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swid, GEO_FIELD2, DIM_NAME1, DFNT_FLOAT32, &
                         HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swid, GEO_FIELD3, DIM_NAME1, DFNT_FLOAT64, &
                         HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swid, GEO_FIELD4, DIM_NAME1, DFNT_FLOAT32, &
                         HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD4
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swid, GEO_FIELD5, DIM_NAME1, DFNT_FLOAT32, &
                         HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD5
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swid, GEO_FIELD6, DIM_NAME1, DFNT_FLOAT32, &
                         HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD6
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swid, GEO_FIELD7, DIM_NAME1, DFNT_FLOAT32, &
                         HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD7
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefgfld(swid, GEO_FIELD8, DIM_NAME1, DFNT_INT32, HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = GEO_ERR // GEO_FIELD8
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      IF (l2gp%nLevels > 0) THEN
         status = swdefgfld(swid, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, &
                            HDFE_NOMERGE)
         IF (status == -1) THEN
            msr = GEO_ERR // GEO_FIELD9
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

      IF (l2gp%nFreqs > 0) THEN
         status = swdefgfld(swid, GEO_FIELD10, DIM_NAME3, DFNT_FLOAT32, &
                            HDFE_NOMERGE)
         IF (status == -1) THEN
            msr = GEO_ERR // GEO_FIELD10
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

! Define data fields using above dimensions

      IF (l2gp%nFreqs > 0) THEN

         status = swdefdfld(swid, DATA_FIELD5, DIM_NAME123, DFNT_FLOAT32, &
                            HDFE_NOMERGE)
         IF (status == -1) THEN
            msr = DAT_ERR // DATA_FIELD5 // ' for 3D quantity.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      ELSE IF (l2gp%nLevels > 0) THEN

         status = swdefdfld(swid, DATA_FIELD5, DIM_NAME12, DFNT_FLOAT32, &
                            HDFE_NOMERGE)
         IF (status == -1) THEN
            msr = DAT_ERR // DATA_FIELD5 // ' for 2D quantity.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      ELSE

         status = swdefdfld(swid, DATA_FIELD5, DIM_NAME1, DFNT_FLOAT32, &
                            HDFE_NOMERGE)
         IF (status == -1) THEN
            msr = DAT_ERR // DATA_FIELD5 // ' for 1D quantity.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      ENDIF

      status = swdefdfld(swid, DATA_FIELD3, DIM_NAME1, DFNT_CHAR8, &
                         HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = DAT_ERR // DATA_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swdefdfld(swid, DATA_FIELD4, DIM_NAME1, DFNT_FLOAT32, &
                         HDFE_NOMERGE)
      IF (status == -1) THEN
         msr = DAT_ERR // DATA_FIELD4
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Detach from the swath interface.  This stores the swath info within the file
! and must be done before writing or reading data to or from the swath.

      status = swdetach(swid)
      IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
                    &detach from swath interface after L3Residual definition.')

!-------------------------------
   END SUBROUTINE ResidualCreate
!-------------------------------

!---------------------------------------
   SUBROUTINE ResidualWrite (l2gp, swid)
!---------------------------------------

! Brief description of subroutine
! This subroutine writes the data fields to the L3Residual swath.

! Arguments

      TYPE( L2GPData_T ), INTENT(IN) :: l2gp

      INTEGER, INTENT(IN) :: swid

! Parameters

! Functions

      INTEGER, EXTERNAL :: swwrfld

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: status
      INTEGER :: start(3), stride(3), edge(3)

! Write to the geolocation fields

      start = 0
      stride = 1
      edge(1) = l2gp%nFreqs
      edge(2) = l2gp%nLevels
      edge(3) = l2gp%nTimes

      if (l2gp%nTimes .gt. 0) then

      status = swwrfld( swid, GEO_FIELD1, start(3), stride(3), edge(3), real(l2gp%latitude) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swid, GEO_FIELD2, start(3), stride(3), edge(3), real(l2gp%longitude) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld(swid, GEO_FIELD3, start(3), stride(3), edge(3), l2gp%time)
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swid, GEO_FIELD4, start(3), stride(3), edge(3), real(l2gp%solarTime) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD4
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swid, GEO_FIELD5, start(3), stride(3), edge(3), real(l2gp%solarZenith) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD5
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swid, GEO_FIELD6, start(3), stride(3), edge(3), real(l2gp%losAngle) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD6
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swid, GEO_FIELD7, start(3), stride(3), edge(3), real(l2gp%geodAngle) )
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD7
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld(swid, GEO_FIELD8, start(3), stride(3), edge(3), l2gp%chunkNumber)
      IF (status == -1) THEN
         msr = WR_ERR // GEO_FIELD8
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      endif

      IF (l2gp%nLevels > 0) THEN

         status = swwrfld( swid, GEO_FIELD9, start(2), stride(2), edge(2), real(l2gp%pressures) )
         IF (status == -1) THEN
            msr = WR_ERR // GEO_FIELD9
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      ENDIF

      IF (l2gp%nFreqs > 0) THEN

         status = swwrfld( swid, GEO_FIELD10, start(1), stride(1), edge(1), real(l2gp%frequency) )
         IF (status == -1) THEN
            msr = WR_ERR // GEO_FIELD10
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      ENDIF

! Write to the data fields

      IF (l2gp%nFreqs > 0) THEN

! L3Residual value is a 3-D field

         status = swwrfld( swid, DATA_FIELD5, start, stride, edge, real(l2gp%l2gpValue) )
         IF (status == -1) THEN
            msr = WR_ERR // DATA_FIELD5
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      ELSE IF (l2gp%nLevels > 0) THEN

! L3Residual is 2-D

         status = swwrfld( swid, DATA_FIELD5, start(2:3), stride(2:3), edge(2:3), real(l2gp%l2gpValue(1,:,:)) )
         IF (status == -1) THEN
            msr = WR_ERR // DATA_FIELD5
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      ELSE

! 1-D residual
      if (l2gp%nTimes .gt. 0) then

         status = swwrfld( swid, DATA_FIELD5, start(3), stride(3), edge(3), real(l2gp%l2gpValue(1,1,:)) )
         IF (status == -1) THEN
            msr = WR_ERR // DATA_FIELD5
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      endif

      ENDIF

! 1-D status & quality fields

      status = swwrfld( swid, DATA_FIELD3, start(3), stride(3), edge(3), l2gp%status)
      IF (status == -1) THEN
         msr = WR_ERR // DATA_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = swwrfld( swid, DATA_FIELD4, start(3), stride(3), edge(3), real(l2gp%quality) )
      IF (status == -1) THEN
         msr = WR_ERR // DATA_FIELD4
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

!------------------------------
   END SUBROUTINE ResidualWrite
!------------------------------

!---------------------------------------
   SUBROUTINE ResidualOutput (type, l3r)
!---------------------------------------

! Brief description of subroutine
! This program creates & writes the L3Residual swaths in an l3 map file.

! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: type

      TYPE( L2GPData_T ), INTENT(IN) :: l3r(:)

! Parameters

! Functions

      INTEGER, EXTERNAL :: swattach, swclose, swdetach, swopen

! Variables

      CHARACTER (LEN=8) :: date
      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=FileNameLen) :: l3File

      INTEGER :: i, l3id, match, numDays, status, swid

! For each element of the database,

      numDays = SIZE(l3r)

d404 5
a408 56

! Find the l3dm file for the proper day

         CALL FindFileDay(type, l3r(i)%time(1), mlspcf_l3dm_start, &
                          mlspcf_l3dm_end, match, l3File, date)
         IF (match == -1) THEN
            msr = 'No ' // TRIM(type) // ' file for day ' // date // ' found &
                  &for appending ' // TRIM(l3r(i)%name) // 'swath.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Re-open the l3dm grid file for the creation of swaths

         l3id = swopen(l3File, DFACC_RDWR)
         IF (l3id == -1) THEN
            msr = MLSMSG_Fileopen // l3File
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Create the L3Residual swath in this day's file

         CALL ResidualCreate( l3id, l3r(i) )

! Re-attach to the swath for writing

         swid = swattach(l3id, l3r(i)%name)
         IF (swid == -1) THEN
            msr = 'Failed to re-attach to swath interface for writing to ' // &
                   l3r(i)%name
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Write to the geolocation & data fields

         CALL ResidualWrite(l3r(i), swid)
         msr = TRIM(l3r(i)%name) // ' swath successfully written to file ' // &
               l3File
         CALL MLSMessage(MLSMSG_Info, ModuleName, msr)

! After writing, detach from swath interface

         status = swdetach(swid)
         IF (status == -1) THEN
            msr = 'Failed to detach from swath interface after writing to ' &
                  // l3r(i)%name
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Close the file

         status = swclose(l3id)
         IF (status == -1) THEN
            msr = 'Failed to close file ' // l3File // ' after writing.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

d410 2
d413 3
a415 42
!-------------------------------
   END SUBROUTINE ResidualOutput
!-------------------------------

!-----------------------------------------------------------------------
   SUBROUTINE ReadL2DGData (product, numFiles, files, numDays, prodL2GP)
!-----------------------------------------------------------------------

! Brief description of subroutine
! This subroutine reads l2gp dg files for a quantity over a range of days.  It
! returns an array of L2GPData_T structures, with one structure per day.

! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: product

      CHARACTER (LEN=FileNameLen), INTENT(IN) :: files(:)

      INTEGER, INTENT(IN) :: numFiles

      INTEGER, INTENT(OUT) :: numDays

      TYPE( L2GPData_T ), POINTER :: prodL2GP(:)

! Parameters

! Functions

      INTEGER, EXTERNAL :: swclose, swinqswath, swopen

! Variables

      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=6000) :: list
      CHARACTER (LEN=GridNameLen) :: swath
      CHARACTER (LEN=FileNameLen) :: prodFiles(numFiles)

      INTEGER :: err, i, indx, j, l2id, len, ns, status

! Check for the product in the input files

      numDays = 0
d417 1
a417 79
      DO i = 1, numFiles

         ns = swinqswath(files(i), list, len)
         IF (ns == -1) THEN
            msr = 'Failed to read swath list from ' // files(i)
            CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
            CYCLE
         ENDIF

         DO j = 1, ns

            indx = INDEX(list, ',')

            IF (indx == 0) THEN
               swath = list
            ELSE
               swath = list(:indx-1)
               list = list(indx+1:)
            ENDIF

            IF ( TRIM(swath) == TRIM(product) ) THEN
               numDays = numDays + 1
               prodFiles(numDays) = files(i)
               EXIT
            ENDIF

         ENDDO

      ENDDO

! Check that numDays is at least 1, so pointer allocation is possible

      IF (numDays == 0) THEN

! If not, issue a warning

         msr = 'No L2GP data found for ' // product
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
         NULLIFY(prodL2GP)

! If so, open, read, & close the files for this quantity

      ELSE

         ALLOCATE( prodL2GP(numDays), STAT=err )
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' l2gp array for ' // product
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         DO i = 1, numDays

            l2id = swopen(prodFiles(i), DFACC_READ)
            IF (l2id == -1) THEN
               msr = MLSMSG_Fileopen // prodFiles(i)
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

! Read information from the L2GP file

            CALL ReadL2GP( l2id, product, prodL2GP(i) )

! Close the L2GP file

            status = swclose(l2id)
            IF (status == -1) THEN
               msr = 'Failed to close file ' // prodFiles(i)
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

         ENDDO

      ENDIF

!-----------------------------
   END SUBROUTINE ReadL2DGData
!-----------------------------

!=====================
d422 3
@


1.9
log
@swid checked
@
text
@d25 1
a25 1
   "$Id: L2Interface.f90,v 1.8 2002/04/10 21:54:05 jdone Exp $"
d194 5
a198 2
      IF (swid == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
                                     &attach to swath interface for reading.')
d383 1
a383 2
      status = swrdfld(swid, GEO_FIELD3, start(3), stride(3), edge(3), &
        l2gpData%time)
d417 1
a417 2
      status = swrdfld(swid, GEO_FIELD8, start(3), stride(3), edge(3), &
                       l2gpData%chunkNumber)
d524 1
a524 2
      status = swrdfld(swid, DATA_FIELD3, start(3), stride(3), edge(3), &
                       l2gpData%status)
d640 1
d879 1
a879 2
      status = swwrfld( swid, GEO_FIELD1, start(3), stride(3), edge(3), &
                        REAL(l2gp%latitude) )
d885 1
a885 2
      status = swwrfld( swid, GEO_FIELD2, start(3), stride(3), edge(3), &
                        REAL(l2gp%longitude) )
d891 1
a891 2
      status = swwrfld(swid, GEO_FIELD3, start(3), stride(3), edge(3), &
                       l2gp%time)
d897 1
a897 2
      status = swwrfld( swid, GEO_FIELD4, start(3), stride(3), edge(3), &
                        REAL(l2gp%solarTime) )
d903 1
a903 2
      status = swwrfld( swid, GEO_FIELD5, start(3), stride(3), edge(3), &
                        REAL(l2gp%solarZenith) )
d909 1
a909 2
      status = swwrfld( swid, GEO_FIELD6, start(3), stride(3), edge(3), &
                        REAL(l2gp%losAngle) )
d915 1
a915 2
      status = swwrfld( swid, GEO_FIELD7, start(3), stride(3), edge(3), &
                        REAL(l2gp%geodAngle) )
d921 1
a921 2
      status = swwrfld(swid, GEO_FIELD8, start(3), stride(3), edge(3), &
                       l2gp%chunkNumber)
d931 1
a931 2
         status = swwrfld( swid, GEO_FIELD9, start(2), stride(2), edge(2), &
                           REAL(l2gp%pressures) )
d941 1
a941 2
         status = swwrfld( swid, GEO_FIELD10, start(1), stride(1), edge(1), &
                           REAL(l2gp%frequency) )
d955 1
a955 2
         status = swwrfld( swid, DATA_FIELD5, start, stride, edge, &
                           REAL(l2gp%l2gpValue) )
d965 1
a965 2
         status = swwrfld( swid, DATA_FIELD5, start(2:3), stride(2:3), &
                           edge(2:3), REAL(l2gp%l2gpValue(1,:,:)) )
d976 1
a976 2
         status = swwrfld( swid, DATA_FIELD5, start(3), stride(3), edge(3), &
                           REAL(l2gp%l2gpValue(1,1,:)) )
d988 1
a988 2
      status = swwrfld(swid, DATA_FIELD3, start(3), stride(3), edge(3), &
                       l2gp%status)
d994 1
a994 2
      status = swwrfld( swid, DATA_FIELD4, start(3), stride(3), edge(3), &
                        REAL(l2gp%quality) )
d1062 1
a1062 1
         IF (status == -1) THEN
d1220 3
@


1.8
log
@error checking on allocated statements
@
text
@d25 1
a25 1
   "$Id: L2Interface.f90,v 1.7 2002/02/20 19:21:15 ybj Exp $"
d194 1
a194 1
      IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d1234 3
@


1.7
log
@*** empty log message ***
@
text
@d25 1
a25 1
   "$Id: L2Interface.f90,v 1.6 2001/07/18 15:50:59 nakamura Exp $"
a100 3
         !IF (physicalFilename == '/data/emls/l2gp/v0.5/1996/MLS-Aura_L2GP_ClO_V0-05-C01_WV_1996-038.dat' &
         !   .or. physicalFilename == '/data/emls/l2gp/v0.5/1996/MLS-Aura_L2GP_ClO_V0-05-C01_WV_1996-045.dat' &
	 !		.or. returnStatus /= PGS_S_SUCCESS) THEN
d244 63
a306 9
      ALLOCATE (l2gpData%latitude(numProfs), l2gpData%longitude(numProfs), &
                l2gpData%time(numProfs), l2gpData%solarTime(numProfs), &
                l2gpData%solarZenith(numProfs), l2gpData%losAngle(numProfs), &
                l2gpData%geodAngle(numProfs), l2gpData%chunkNumber(numProfs), &
                l2gpData%l2gpValue(numFreq,numLev,numProfs), &
                l2gpData%l2gpPrecision(numFreq,numLev,numProfs), &
                l2gpData%status(numProfs), l2gpData%quality(numProfs), &
                realProf(numProfs), realSurf(numLev), realFreq(numFreq), &
                real3(numFreq,numLev,numProfs), STAT=alloc_err)
d308 1
a308 1
         msr = MLSMSG_Allocate // '  output pointers.'
d312 44
d364 2
d381 1
a381 1
                       l2gpData%time)
d422 2
d521 2
d537 2
d541 9
a549 1
      DEALLOCATE(realFreq, realSurf, realProf, real3, STAT=alloc_err)
d551 5
a555 1
                                'Failed deallocation of local real variables.')
d876 2
d934 2
d985 1
d994 2
d1234 3
@


1.6
log
@Generalized to work with L3M as well.
@
text
@d25 1
a25 1
   "$Id: L2Interface.f90,v 1.9 2001/05/09 17:38:25 nakamura Exp nakamura $"
d54 1
a54 1
                              endDOY, numFiles, pcfNames)
d69 1
a69 1
      INTEGER, INTENT(OUT) :: numFiles
d72 1
d90 1
d101 28
a128 1
         IF (returnStatus /= PGS_S_SUCCESS) CYCLE
d453 1
a453 1
   SUBROUTINE ReadL2GPProd (product, template, startDOY, endDOY, numDays, prodL2GP)
d466 1
a466 1
      INTEGER, INTENT(OUT) :: numDays
d470 2
d488 1
a488 1
                          endDOY, numDays, pcfNames)
d532 1
d1112 3
@


1.5
log
@Changes for privatization of L2GPData.
@
text
@d9 2
a10 2
   USE SDPToolkit
   USE MLSMessageModule
d13 1
a13 2
   USE L2GPData, ONLY: L2GPData_T, ReadL2GPData
   USE Hdf
d17 1
d25 1
a25 1
   "$Id: L2Interface.f90,v 1.4 2001/02/21 20:37:18 nakamura Exp $"
d32 1
d37 1
d53 2
a54 1
   SUBROUTINE GetL2GPfromPCF (template, startDOY, endDOY, numFiles, pcfNames)
d67 2
d92 1
a92 1
      DO i = mlspcf_l2gp_start, mlspcf_l2gp_end
d129 297
a425 3
!-----------------------------------------------------------------------
   SUBROUTINE ReadL2GPProd (cfProd, startDOY, endDOY, numDays, prodL2GP)
!-----------------------------------------------------------------------
d433 1
a433 1
      TYPE( L3CFProd_T ), INTENT(IN) :: cfProd
d452 1
a452 1
      INTEGER :: err, i, l2id, numProfs, status
d456 2
a457 2
      CALL GetL2GPfromPCF(cfProd%fileTemplate, startDOY, endDOY, numDays, &
                          pcfNames)
d465 1
a465 1
         msr = 'No L2GP data found for ' // cfProd%l3prodNameD
d475 1
a475 1
            msr = MLSMSG_Allocate // ' l2gp array for ' // cfProd%l3prodNameD
d489 1
a489 1
            CALL ReadL2GPData(l2id, cfProd%l3prodNameD, prodL2GP(i), numProfs)
d958 117
d1080 3
@


1.4
log
@Changed MLSPCF to MLSPCF3.
@
text
@d13 1
a13 1
   USE L2GPData
d25 1
a25 1
   "$Id: L2Interface.f90,v 1.3 2000/12/29 20:40:04 nakamura Exp $"
d42 4
d664 3
@


1.3
log
@Changed ReadL2GPProd to take start & end days as input; modified ResidualOutput for the one-product/all-days paradigm.
@
text
@d15 1
a15 1
   USE MLSPCF
d25 1
a25 1
   "$Id: L2Interface.f90,v 1.7 2000/12/28 20:41:46 nakamura Exp nakamura $"
d660 3
@


1.2
log
@Updated for level becoming an expandable template field.
@
text
@d12 1
a12 1
   USE L3DMData
d25 1
a25 1
   "$Id: L2Interface.f90,v 1.3 2000/11/30 20:55:45 nakamura Exp nakamura $"
d46 3
a48 3
!----------------------------------------------------------
   SUBROUTINE GetL2GPfromPCF (template, numFiles, pcfNames)
!----------------------------------------------------------
d56 3
a58 1
      CHARACTER (LEN=*), INTENT(IN) :: template 
d70 2
a71 4
      CHARACTER (LEN=5) :: aNum
      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=FileNameLen) :: capName, capString, cmpString
      CHARACTER (LEN=FileNameLen) :: physicalFilename
d75 1
a75 1
! Extract the species name from the file template
d77 1
a77 4
      indx = INDEX(template, 'level')
      cmpString = template(indx+5:)
      indx = INDEX(cmpString(2:), '_')
      capString = Capitalize(cmpString(:indx+1))
d86 1
d88 3
a90 1
         returnStatus = Pgs_pc_getReference(i, version, physicalFilename)
d92 1
a92 1
         IF (returnStatus /= PGS_S_SUCCESS) THEN
d94 1
a94 3
            WRITE(aNum, '(I5)') i
            msr = MLSMSG_Fileopen // 'PCF number ' // aNum
            CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
d96 1
a96 1
         ELSE
d98 2
a99 1
! Check that the file is for the proper species
d101 1
a101 1
            capName = Capitalize(physicalFilename)
d103 1
a103 1
            IF ( INDEX(capName, TRIM(capString)) /= 0 ) THEN
d105 1
a105 1
! If so, save the name in an array of files for the species
d120 3
a122 3
!----------------------------------------------------------
   SUBROUTINE ReadL2GPProd (cfProd, pcf, numDays, prodL2GP)
!----------------------------------------------------------
d132 1
a132 1
      TYPE( PCFData_T ), INTENT(IN) :: pcf
d153 2
a154 1
      CALL GetL2GPfromPCF(cfProd%fileTemplate, numDays, pcfNames)
d156 1
a156 1
! Decide whether there are enough input data to process the quantity
d158 1
a158 1
      IF (numDays < pcf%minDays) THEN
d162 1
a162 2
         msr = 'Not enough input data to process quantity:  ' // &
               cfProd%l3prodNameD
d561 3
a563 3
!----------------------------------------------------------------
   SUBROUTINE ResidualOutput (l3File, numGrids, iGrid, l3dm, l3r)
!----------------------------------------------------------------
d570 1
a570 5
      CHARACTER (LEN=*), INTENT(IN) :: l3File

      INTEGER, INTENT(IN) :: numGrids, iGrid(:)

      TYPE( L3DMData_T ), INTENT(IN) :: l3dm(:)
d578 1
a578 1
      INTEGER, EXTERNAL :: swattach, swclose, swdetach, swopen,swwrfld
d582 1
a582 1
      CHARACTER (LEN=GridNameLen) :: swathName
d584 1
d586 1
a586 2
      INTEGER :: i, indx, l3id, numSwaths, status, swid
      INTEGER :: iSwath(4)
d588 1
a588 1
! Find the elements of the l3r database for swaths in this output file
d590 1
a590 2
      numSwaths = 0
      iSwath = 0
d592 1
a592 12
      DO i = 1, numGrids

         swathName = TRIM(l3dm(iGrid(i))%name) // 'Residuals'
         indx = LinearSearchStringArray( l3r%name, TRIM(swathName) )
         IF (indx == 0) THEN
            msr = 'No residual swath found in database for:  ' // &
                   l3dm(iGrid(i))%name
            CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
         ELSE
            numSwaths = numSwaths + 1
            iSwath(numSwaths) = indx
         ENDIF
d594 1
a594 1
      ENDDO
d596 7
a602 5
      IF (numSwaths == 0) THEN
         msr = 'No l3r data found for file ' // l3File
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
         RETURN
      ENDIF
d606 5
a610 5
      l3id = swopen(l3File, DFACC_RDWR)
      IF (l3id == -1) THEN
         msr = MLSMSG_Fileopen // l3File
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d612 1
a612 1
! For all swaths in this output file
d614 1
a614 5
      DO i = 1, numSwaths

! Create L3Residual swath

         CALL ResidualCreate( l3id, l3r(iSwath(i)) )
d618 1
a618 1
         swid = swattach(l3id, l3r(iSwath(i))%name)
d621 1
a621 1
                   l3r(iSwath(i))%name
d627 4
a630 1
         CALL ResidualWrite(l3r(iSwath(i)), swid)
d637 1
a637 1
                  // l3r(iSwath(i))%name
d641 1
a641 1
      ENDDO
d643 5
a647 1
! Close the file
d649 1
a649 5
      status = swclose(l3id)
      IF (status == -1) THEN
         msr = 'Failed to close file ' // l3File // ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d660 3
@


1.1
log
@Module containing subroutines related to L2GP data.
@
text
@d25 1
a25 1
   "$Id: L2Interface.f90,v 1.1 2000/11/15 20:52:47 nakamura Exp nakamura $"
d77 2
a78 2
      indx = INDEX(template, 'l3dm')
      cmpString = template(indx+4:)
d80 1
a80 1
      capString = Capitalize(cmpString(:indx))
d386 2
a387 4
      IF (status == -1) THEN
         CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to detach from &
                                         &swath interface after definition.')
      ENDIF
a407 2
      CHARACTER (LEN=*), PARAMETER :: WR_ERR = 'Failed to write field '

d562 3
a564 3
!---------------------------------------------------
   SUBROUTINE ResidualOutput (l3File, gridName, l3r)
!---------------------------------------------------
d571 5
a575 1
      CHARACTER (LEN=*), INTENT(IN) :: gridName, l3File
d577 1
a577 1
      TYPE( L2GPData_T ), INTENT(INOUT) :: l3r(:)
d587 1
d590 2
a591 2
      INTEGER :: allSwaths, i, l3id, numSwaths, status, swid
      INTEGER :: indx(4)
d596 1
a596 1
      indx = 0
d598 1
a598 1
      allSwaths = SIZE(l3r)
d600 7
a606 2
      DO i = 1, allSwaths
         IF ( INDEX(l3r(i)%name, TRIM(gridName)) == 1 ) THEN
d608 1
a608 1
            indx(numSwaths) = i
d610 1
d614 3
a616 2
         msr = 'No grids found in the l3r database matching ' // gridName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d633 1
a633 1
         CALL ResidualCreate( l3id, l3r(indx(i)) )
d637 1
a637 1
         swid = swattach(l3id, l3r(indx(i))%name)
d640 1
a640 1
                   l3r(indx(i))%name
d646 1
a646 1
         CALL ResidualWrite(l3r(indx(i)), swid)
d650 1
a650 1
        status = swdetach(swid)
d653 1
a653 1
                  // l3r(indx(i))%name
d676 2
a677 3
!# Revision 1.1  2000/11/15 20:52:47  nakamura
!# Initial revision
!#
@

