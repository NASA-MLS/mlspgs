head	1.47;
access;
symbols
	v5-02-NRT-19:1.47
	v6-00:1.47
	v5-02-NRT-18:1.47
	v5-02:1.47
	v5-01-NRT-17:1.47
	v5-01-NRT-16:1.47
	v5-01-NRT-15:1.47
	v5-01-NRT-14:1.47
	neuralnetworks-1-0:1.47.0.12
	cfm-single-freq-0-1:1.47.0.10
	v5-01:1.47
	v5-00:1.47
	v4-23-TA133:1.47.0.8
	mus-emls-1-70:1.47.0.6
	rel-1-0-englocks-work:1.47.0.4
	VUMLS1-00:1.47
	VPL1-00:1.47
	V4-22-NRT-08:1.47
	VAM1-00:1.47
	V4-21:1.47.0.2
	V4-13:1.47
	V4-12:1.47
	V4-11:1.47
	V4-10:1.47
	V3-43:1.46
	M4-00:1.47
	V3-41:1.46
	V3-40-PlusGM57:1.46.0.2
	V2-24-NRT-04:1.46
	V3-33:1.46
	V2-24:1.46
	V3-31:1.46
	V3-30-NRT-05:1.46
	cfm-01-00:1.46
	V3-30:1.46
	V3-20:1.46
	V3-10:1.46
	V2-23-NRT-02:1.46
	V2-23:1.46
	V2-22-NRT-01:1.46
	V2-22:1.46
	V2-21:1.46
	V2-20:1.46
	V2-11:1.45
	V2-10:1.45
	V2-00:1.45
	V1-51:1.40
	V1-50:1.39
	V1-45:1.37
	V1-44:1.37
	V1-43:1.36
	V1-42:1.35
	V1-41:1.35
	V1-32:1.32
	V1-40:1.34
	V1-31:1.32
	V1-30:1.32
	V1-13:1.21
	V1-12:1.21
	V1-11:1.21
	V1-10:1.20
	newfwm-feb03:1.20.0.2
	V1-04:1.20
	V1-03:1.20
	V1-02:1.20
	V1-00:1.19
	newfwm-sep01:1.13.0.2
	V0-7:1.13
	V0-5-Level2:1.11
	V0-5-SIPS:1.10;
locks; strict;
comment	@# @;


1.47
date	2011.07.12.22.37.47;	author honghanh;	state Exp;
branches;
next	1.46;

1.46
date	2006.09.26.15.04.44;	author cvuu;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.19.15.19.55;	author cvuu;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.17.15.42.06;	author cvuu;	state Exp;
branches;
next	1.43;

1.43
date	2006.02.28.17.56.56;	author cvuu;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.22.23.40.49;	author pwagner;	state Exp;
branches;
next	1.41;

1.41
date	2005.06.23.19.07.38;	author pwagner;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.27.00.35.06;	author pwagner;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.16.15.01.54;	author cvuu;	state Exp;
branches;
next	1.38;

1.38
date	2004.12.13.17.40.56;	author cvuu;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.04.23.20.55;	author pwagner;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.04.15.33.15;	author cvuu;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.19.14.25.26;	author cvuu;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.08.21.25.44;	author cvuu;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.07.21.43.18;	author cvuu;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.15.18.29.41;	author cvuu;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.21.20.22.46;	author cvuu;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.18.17.03.59;	author cvuu;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.11.23.29.09;	author cvuu;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.08.00.18.09;	author pwagner;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.03.20.45.29;	author pwagner;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.45.15;	author pwagner;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.30.23.52.42;	author pwagner;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.30.18.15.48;	author pwagner;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.08.20.26.46;	author pwagner;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.22.02.13.20;	author jdone;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.15.00.16.38;	author pwagner;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.10.22.00.34;	author jdone;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.01.21.58.49;	author jdone;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.27.21.33.32;	author jdone;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.13.20.47.50;	author nakamura;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.26.19.24.20;	author nakamura;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.12.20.22.05;	author nakamura;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.05.20.16.25;	author nakamura;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.18.15.54.37;	author nakamura;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.04.18.30.01;	author nakamura;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.24.19.38.23;	author nakamura;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.27.19.28.15;	author nakamura;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.21.20.57.12;	author nakamura;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.09.19.18.05;	author nakamura;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.16.17.44.00;	author nakamura;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.29.20.50.33;	author nakamura;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.07.19.34.42;	author nakamura;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.15.21.00.26;	author nakamura;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.24.19.21.08;	author nakamura;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.17.20.17.09;	author nakamura;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.05.19.11.07;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Change l_grid to l_hdfeos
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!==============================================================================
MODULE L3DMData
!==============================================================================

  USE L3CF, ONLY: L3CFDef_T, L3CFProd_T
  USE MLSCommon, ONLY: r8, FileNameLen
  USE MLSL3Common, ONLY: OutputFiles_T, DIM_ERR, GEO_ERR, DAT_ERR, WR_ERR, &
       & GD_ERR, METAWR_ERR, TAI2A_ERR, &
       & GEO_FIELD1, GEO_FIELD2, GEO_FIELD3, GEO_FIELD4, GEO_FIELD5, &
       & GEO_FIELD6, GEO_FIELD7, GEO_FIELD8, GEO_FIELD9, GEO_FIELD10, & 
       & DIM_NAME1, DIM_NAME2, DIM_NAME3, DIM_NAME12, DIM_NAME123, &
       & DIMX_NAME, DIMY_NAME, DIMZ_NAME, DIMT_NAME, &
       & DIML_NAME, DIMN_NAME, DIMR_NAME, DIMLL_NAME, DIMRL_NAME, &
       & MDT_FIELD, MD_FIELD, DG_FIELD, DG_FIELD1, DG_FIELD2, &
       & GCTP_GEO, CCSDS_LEN, GridNameLen, DIMXYZ_NAME, &
       & HDFE_NOMERGE, INVENTORYMETADATA, PROJ_NAME, FILEATTR_ERR, &
       & GRID_ORIGIN, GRID_NAME, NAMEPROJ, HE5_HDFE_NOMERGE, &
       & GRID_SPACING, GSPACING_VALUE, GRID_SPACING_UNIT, GSPACING_UNIT, &
       & GRID_SPAN, GSPAN_VALUE, GRID_SPAN_UNIT, GSPAN_UNIT, &
       & DIMZYX_NAME, maxWindow
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_Info, & 
       & MLSMSG_DEALLOCATE, MLSMSG_FILEOPEN, MLSMSG_ALLOCATE, MLSMSG_WARNING
  USE dates_module, only: utc_to_yyyymmdd
  IMPLICIT NONE
  private
  PUBLIC :: L3DMData_T, ConvertDeg2DMS, OutputGrids, &
    & WriteMetaL3DM, AllocateL3DM, DeallocateL3DM, DestroyL3DMDatabase


!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: L3DMData.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! Contents:

! Definition -- L3DMData_T
! Subroutines -- ConvertDeg2DMS
!                OutputGrids
!                OutputGrids_HE5
!                OutputDiags_HE5
!                WriteMetaL3DM
!                AllocateL3DM
!                DeallocateL3DM
!                DestroyL3DMDatabase
!                WriteAttributeGrid_HE5
!                WriteAttributeSwath_HE5
!                SetAliasGrid_HE5
                                                                            
! Remarks:  This module contains the definition of the L3DMData type, as well
!           as any routines pertaining to it.

! Parameters

   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELDV = 'L3dmValue'
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELDP = 'L3dmPrecision'

! This data type is used to store the l3 daily map data.

   TYPE L3DMData_T

     CHARACTER (LEN=GridNameLen) :: name	! name for the output quantity

     ! Now the data fields:

     REAL(r8), DIMENSION(:,:,:), POINTER :: l3dmValue=>NULL()	  ! Field value
     REAL(r8), DIMENSION(:,:,:), POINTER :: l3dmPrecision=>NULL() ! Field precision
	! dimensioned as (nLevels, nLats, nLons)

     REAL(r8), DIMENSION(:,:), POINTER :: latRss=>NULL()
	! Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)

     REAL(r8), DIMENSION(:,:), POINTER :: maxDiff=>NULL()
	! Maximum difference, dimensioned (N, nLevels)

     REAL(r8), DIMENSION(:,:), POINTER :: maxDiffTime=>NULL()
	! Time of maximum differences, dimensioned (N, nLevels)

     ! Now we store the geolocation fields.  First, the vertical one:

     REAL(r8), DIMENSION(:), POINTER :: pressure=>NULL()	! dimensioned (nLevels)

     ! Now the horizontal geolocation information and time:

     REAL(r8), DIMENSION(:), POINTER :: latitude=>NULL()	! dimensioned (nLats)
     REAL(r8), DIMENSION(:), POINTER :: longitude=>NULL()	! dimensioned (nLons)

     REAL(r8) :: time	! Synoptic time

     ! Now the diagnostic fields

     REAL(r8), DIMENSION(:), POINTER :: gRss=>NULL()
	! Global Root-Sum_Square, dimensioned (nLevels)

     INTEGER, DIMENSION(:), POINTER :: perMisPoints=>NULL()
	! Missing points (percentage), dimensioned (nLevels)

     INTEGER :: nLevels		! Total number of surfaces
     INTEGER :: nLats		! Total number of latitudes
     INTEGER :: nLons		! Total number of longitudes
     INTEGER :: N		! number for "largest differences" diagnostics
     !INTEGER :: dateMis(maxWindow) ! missing date 

   END TYPE L3DMData_T

CONTAINS

!--------------------------------------
   SUBROUTINE ConvertDeg2DMS (deg, dms)
!--------------------------------------

! Brief description of subroutine
! This subroutine converts degrees in "decimal format" (DDD.ddd) to "packed
! degree format" (DDDMMMSSS.ss)

! Arguments

      REAL, INTENT(IN) :: deg
 
      REAL(r8), INTENT(OUT) :: dms

! Parameters

! Functions

! Variables

      REAL(r8) :: decDeg, decMin, d, dm, intDeg, intMin, min, sec

! Convert DDD.ddd to DDD000000.00

      intDeg = AINT(deg)

      d = intDeg * 1000000.00

! Convert .ddd to MM.mmm

      decDeg = deg - intDeg

      min = decDeg * 60.0

! Truncate MM.mmm

      intMin = AINT(min)

! Add 0MM000.00 to DDD000000.00

      dm = intMin * 1000.0 + d

! Convert .mmm to SS.sss

      decMin = min - intMin

      sec = decMin * 60.0

! Add to get DDD0MM0SS.ss

      dms = dm + sec

!-------------------------------
   END SUBROUTINE ConvertDeg2DMS
!-------------------------------

  !---------------------------------------------------
  SUBROUTINE OutputGrids(type, l3dmData, l3dmFiles, hdfVersion, createFile)
  !---------------------------------------------------
  USE MLSFiles, ONLY: HDFVERSION_5, HDFVERSION_4

    ! Brief description of subroutine
    ! This subroutine creates and writes to the grid portion of the l3dm files.
    
    ! Arguments

    TYPE (L3DMData_T), INTENT(IN) :: l3dmData(:)
    
    TYPE (OutputFiles_T), INTENT(INOUT) :: l3dmFiles
    
    CHARACTER (LEN=*), INTENT(IN) :: type
    
    INTEGER, INTENT(IN) :: hdfVersion
   
    LOGICAL, INTENT(INOUT) :: createFile

    if (hdfVersion == HDFVERSION_5) then 
       CALL OutputGrids_HE5(type, l3dmData, l3dmFiles, createFile)
    else 
       CALL MLSMessage(MLSMSG_Error, ModuleName, 'Wrong hdfVersion')
    endif
    
!----------------------------
  END SUBROUTINE OutputGrids
!----------------------------

 !---------------------------------------------------
 SUBROUTINE OutputGrids_HE5(type, l3dmData, l3dmFiles, createFile)
 !---------------------------------------------------
   
  USE HDF5, ONLY: HID_T
  USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC, MLS_CHARTYPE
  USE MLSPCF3, ONLY: mlspcf_l3dm_start, mlspcf_l3dm_end
  USE MLSStrings, ONLY: LinearSearchStringArray
  USE PCFModule, ONLY: ExpandFileTemplate, FindFileDay 
   ! Brief description of subroutine
   ! This subroutine creates and writes to the grid portion of the l3dm files.

   ! Arguments
   
   CHARACTER (LEN=*), INTENT(IN) :: type
   
   TYPE (L3DMData_T), INTENT(IN) :: l3dmData(:)
   
   TYPE (OutputFiles_T), INTENT(INOUT) :: l3dmFiles
  
   LOGICAL, INTENT(INOUT) :: createFile 

   ! Parameters
   
   ! Variables
   
   CHARACTER (LEN=480) :: msr
   CHARACTER (LEN=FileNameLen) :: physicalFilename
   CHARACTER (LEN=8) :: date
   
   REAL(r8) :: projparm(13)
   REAL(r8) :: uplft(2), lowrgt(2)
   REAL :: maxLat, maxLon, minLat, minLon
   REAL(r8), DIMENSION(:,:,:), POINTER :: tempL3Value=>NULL()   
   REAL(r8), DIMENSION(:,:,:), POINTER :: tempL3Prec=>NULL()   

   INTEGER :: start(3), stride(3), edge(3)
   INTEGER(HID_T) :: gdfID, gdId
   INTEGER :: i, match, status, err
   INTEGER :: x, y, z 

   ! Functions

   INTEGER, EXTERNAL :: & 
        & he5_gdattach, he5_gdclose, he5_gdcreate, he5_gddefdim,& 
        & he5_gddeffld, he5_gddefproj, he5_gddetach, he5_gdopen, he5_gdwrfld, &
        & he5_gdwrattr, he5_gdwrlattr 
   ! For each day in the l3dm database,

   DO i = 1, SIZE(l3dmData)
     
      ! Find the output file for the level/species/day in the PCF
     
      CALL FindFileDay(type, l3dmData(i)%time, mlspcf_l3dm_start, &
           & mlspcf_l3dm_end, match, physicalFilename, date)
      IF (match == -1) THEN
         msr = 'No ' // TRIM(type) // ' file found in the PCF for day ' // &
              & date
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      ! Check whether the name is distinct; if so, save it in l3dmFiles
     
      IF (LinearSearchStringArray(l3dmFiles%name,physicalFilename) == 0) THEN
         l3dmFiles%nFiles = l3dmFiles%nFiles+1
         l3dmFiles%name(l3dmFiles%nFiles) = physicalFilename
         l3dmFiles%date(l3dmFiles%nFiles) = date
      ENDIF
      
      ! Open the output file

      IF (createFile) THEN  
          gdfID = he5_gdopen(physicalFilename, HE5F_ACC_TRUNC)
      ELSE
          gdfID = he5_gdopen(physicalFilename, HE5F_ACC_RDWR)
      ENDIF

      IF (gdfID == -1) THEN
         msr = MLSMSG_Fileopen // trim(physicalFilename) //' for writing grid.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      ! Set up the grid.  The region is bounded by 180.0W to 176.0E longitude &
      ! varying latitude.  
      ! Grid into 90 bins along the x-axis, by nLats bins along the y-axis 
      ! (4x2 bins).  
      ! Upper Left & Lower Right corners in DDDMMMSSS.ss.
      
      projparm = 0.0
      
      ! Find boundaries of measured latitude, upper bound of measure longitude
      
      maxLat = MAXVAL( l3dmData(i)%latitude  )
      minLat = MINVAL( l3dmData(i)%latitude  )
      maxLon = MAXVAL( l3dmData(i)%longitude )
      minLon = MINVAL( l3dmData(i)%longitude )
      
      ! Convert to "packed degree format"
      
      CALL ConvertDeg2DMS(maxLat, uplft(2) )
      CALL ConvertDeg2DMS(minLat, lowrgt(2))
      CALL ConvertDeg2DMS(maxLon, lowrgt(1))
      CALL ConvertDeg2DMS(minLon, uplft(1) )
      
      ! Create the grid

      gdId = he5_gdcreate(gdfID, trim(l3dmData(i)%name), l3dmData(i)%nLons, &
           & l3dmData(i)%nLats, uplft, lowrgt)
      IF (gdId == -1) THEN
         msr = 'Failed to create grid ' // trim(l3dmData(i)%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      ! Define the dimensions

      status = he5_gddefdim(gdId, DIMZ_NAME, l3dmData(i)%nLevels)
      IF (status /= 0) THEN
         msr = DIM_ERR // DIMZ_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_gddefdim(gdId, DIMT_NAME, 1)
      IF (status /= 0) THEN
         msr = DIM_ERR // DIMT_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Define a "Geographic projection," using defaults in all unneeded fields
      
      status = he5_gddefproj(gdId, GCTP_GEO, 0, 0, projparm)
      IF (status /= 0) THEN
         msr = 'Failed to define projection for grid '// trim(l3dmData(i)%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
     
      ! Write Grid level Attribute
                                                                          
      status = he5_gdwrattr(gdId, PROJ_NAME, MLS_CHARTYPE, &
         & len_trim(NAMEPROJ), NAMEPROJ)
      IF (status /= 0) THEN
         msr = FILEATTR_ERR // PROJ_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_gdwrattr(gdId, GRID_ORIGIN, MLS_CHARTYPE, len_trim(GRID_NAME), GRID_NAME)
      IF (status /= 0) THEN
         msr = FILEATTR_ERR // GRID_ORIGIN
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
      status = he5_gdwrattr(gdId, GRID_SPACING, MLS_CHARTYPE, &
         & len_trim(GSPACING_VALUE), GSPACING_VALUE)
      IF (status /= 0) THEN
         msr = FILEATTR_ERR // GRID_SPACING
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_gdwrattr(gdId, GRID_SPACING_UNIT, MLS_CHARTYPE, &
         & len_trim(GSPACING_UNIT), GSPACING_UNIT)
      IF (status /= 0) THEN
         msr = FILEATTR_ERR // GRID_SPACING_UNIT
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_gdwrattr(gdId, GRID_SPAN, MLS_CHARTYPE, &
         & len_trim(GSPAN_VALUE), GSPAN_VALUE)
      IF (status /= 0) THEN
         msr = FILEATTR_ERR // GRID_SPAN
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_gdwrattr(gdId, GRID_SPAN_UNIT, MLS_CHARTYPE, &
         & len_trim(GSPAN_UNIT), GSPAN_UNIT)
      IF (status /= 0) THEN
         msr = FILEATTR_ERR // GRID_SPAN_UNIT
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Define the "grid (geolocation)" fields
                                                                            
      status = he5_gddeffld(gdId, GEO_FIELD3, DIMT_NAME, "", &
           & HE5T_NATIVE_DOUBLE, HE5_HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_gddeffld(gdId, GEO_FIELD9, DIMZ_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HE5_HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD9
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_gddeffld(gdId, GEO_FIELD1, DIMY_NAME, "", &
           & HE5T_NATIVE_FLOAT, HE5_HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_gddeffld(gdId, GEO_FIELD2, DIMX_NAME, "", &
           & HE5T_NATIVE_FLOAT, HE5_HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      
      ! Define the "data" fields
      
      status = he5_gddeffld(gdId, DATA_FIELDV, DIMZYX_NAME, "", &
           & HE5T_NATIVE_FLOAT, HE5_HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = DAT_ERR // DATA_FIELDV
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_gddeffld(gdId, DATA_FIELDP, DIMZYX_NAME, "", &
           & HE5T_NATIVE_FLOAT, HE5_HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = DAT_ERR // DATA_FIELDP
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Detach from and close the grid interface.
      ! This step is necessary to store
      ! properly the grid information within the file and must be done
      ! before writing or reading data to or from the grid.
                                                                                           
      status = he5_gddetach(gdId)
      IF (status /= 0) THEN
         msr = GD_ERR // TRIM( l3dmData(i)%name ) // ' after definition.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Re-attach to the grid for writing

      gdId = he5_gdattach(gdfID, l3dmData(i)%name)
      IF (gdId == -1) THEN
         msr = 'Failed to attach to grid ' // trim(l3dmData(i)%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

           
      ! Write to fields
      
      start = 0
      stride = 1
      !edge = 1
      edge(1) = l3dmData(i)%nLons
      edge(2) = l3dmData(i)%nLats
      edge(3) = l3dmData(i)%nLevels

! Swap the order of data (Value & Precision) 

      ALLOCATE(tempL3Value(l3dmData(i)%nLons,l3dmData(i)%nLats, &
          & l3dmData(i)%nLevels), STAT=err)
      IF ( err /= 0 ) THEN
          msr = MLSMSG_Allocate // ' value pointer.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE(tempL3Prec(l3dmData(i)%nLons,l3dmData(i)%nLats, &
          & l3dmData(i)%nLevels), STAT=err)
      IF ( err /= 0 ) THEN
          msr = MLSMSG_Allocate // ' value pointer.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      tempL3Value(:,:,:) = reshape(l3dmData(i)%l3dmValue,&
	& shape=(/l3dmData(i)%nLons,l3dmData(i)%nLats,l3dmData(i)%nLevels/), &
	& order=(/3,2,1/))
      tempL3Prec(:,:,:) = reshape(l3dmData(i)%l3dmPrecision,&
	& shape=(/l3dmData(i)%nLons,l3dmData(i)%nLats,l3dmData(i)%nLevels/), &
	& order=(/3,2,1/))

      status = he5_gdwrfld(gdId, GEO_FIELD3, start(1), stride(1), edge(1), &
           & l3dmData(i)%time)
      IF (status /=0) THEN
         msr = 'Failed to write field ' //  GEO_FIELD3 // ' to grid ' &
              & // trim(l3dmData(i)%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
 
      if (l3dmData(i)%nLevels.gt.0) then
         
         status = he5_gdwrfld( gdId, GEO_FIELD9, start(3), stride(3), edge(3),&
              & REAL(l3dmData(i)%pressure) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  GEO_FIELD9 // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      if (l3dmData(i)%nLats.gt.0) then
         
         status = he5_gdwrfld( gdId, GEO_FIELD1, start(2), stride(2), edge(2),&
              & REAL(l3dmData(i)%latitude) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  GEO_FIELD1 // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      if (l3dmData(i)%nLons.gt.0) then
         status = he5_gdwrfld( gdId, GEO_FIELD2, start(1), stride(1), edge(1),&
              & REAL(l3dmData(i)%longitude) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  GEO_FIELD2 // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      if ((l3dmData(i)%nLons.gt.0).and.(l3dmData(i)%nLats.gt.0).and. & 
           & (l3dmData(i)%nLevels.gt.0)) then
      
         status = he5_gdwrfld( gdId, DATA_FIELDV, start, stride, edge, &
              & REAL(tempL3Value) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  DATA_FIELDV // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         status = he5_gdwrfld( gdId, DATA_FIELDP, start, stride, edge, &
              & REAL(tempL3Prec) )
              !& REAL(l3dmData(i)%l3dmPrecision) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  DATA_FIELDP // ' to grid ' &
                  & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      endif
         
! Detach from the grid after writing
         
         status = he5_gddetach(gdId)
         IF (status /= 0) THEN
            msr = GD_ERR // TRIM( l3dmData(i)%name ) // ' after writing.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
! Close the file after writing
         
         status = he5_gdclose(gdfID)
         IF (status /= 0) THEN
            msr = 'Failed to close file ' // TRIM(physicalFilename) // &
                 & ' after writing.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         msr = 'Grid ' // TRIM(l3dmData(i)%name) // & 
              & ' successfully written to file ' // trim(physicalFilename)
         CALL MLSMessage(MLSMSG_Info, ModuleName, msr)
                                                                                    
         CALL WriteAttributeGrid_HE5( trim(physicalFilename), l3dmData(i) )
         CALL setAliasGrid_HE5( trim(physicalFilename), l3dmData(i) )
                                                                            
         ! Create & write to diagnostic swath
         
         CALL OutputDiags_HE5( trim(physicalFilename), l3dmData(i) )

         DEALLOCATE (tempL3Value, STAT=err)
         IF ( err /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  tempL3Value pointer'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         DEALLOCATE (tempL3Prec, STAT=err)
         IF ( err /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  tempL3Prec'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      ENDDO
      createFile = .false. 

    !----------------------------
    END SUBROUTINE OutputGrids_HE5
    !----------------------------
    
    !----------------------------------------------
    SUBROUTINE OutputDiags_HE5(physicalFilename, dg)
    !----------------------------------------------
  USE HDF5, ONLY: HID_T
  USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC 

      ! Brief description of subroutine
      ! This subroutine creates and writes to 
      ! the diagnostic portion of the l3dm files.

      ! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: physicalFilename
      
      TYPE (L3DMData_T), INTENT(IN) :: dg

      ! Parameters
      
      CHARACTER (LEN=*), PARAMETER :: DIMNL_NAME = 'N,nLevels'
            
      ! Variables

      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=GridNameLen) :: dgName
      
      INTEGER :: start(2), stride(2), edge(2)
      INTEGER (HID_T) :: swfID, swId
      INTEGER :: status, n, m
      
      ! Functions

      INTEGER, EXTERNAL :: he5_swattach, he5_swclose, he5_swcreate, & 
           & he5_swdefdfld, he5_swdefdim, &
           & he5_swdefgfld, he5_swdetach, he5_swopen, he5_swwrfld
 
      ! Re-open the file for the creation of diagnostic swaths
      
      swfID = he5_swopen(trim(physicalFilename), HE5F_ACC_RDWR)
      
      IF (swfID == -1) THEN
         msr = MLSMSG_Fileopen // trim(physicalFilename) //' for writing swath'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Create the swath
      
      dgName = TRIM(dg%name) // 'Diagnostics'

      swId = he5_swcreate(swfID, dgName)
      IF (swId == -1) THEN
         msr = 'Failed to create swath ' // dgName
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Define the dimensions

      status = he5_swdefdim(swId, DIMN_NAME, dg%N)
      IF (status /= 0) THEN
         msr = DIM_ERR // DIMN_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_swdefdim(swId, DIML_NAME, dg%nLats)
      IF (status /= 0) THEN
         msr = DIM_ERR // DIML_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_swdefdim(swId, DIM_NAME2, dg%nLevels)
      IF (status /= 0) THEN
         msr = DIM_ERR // DIM_NAME2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_swdefdim(swId, DIMT_NAME, 1)
      IF (status /= 0) THEN
         msr = DIM_ERR // DIMT_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      ! Define the "geolocation" fields using the above dimensions
      
      status = he5_swdefgfld(swId, GEO_FIELD3, DIMT_NAME, "", & 
           & HE5T_NATIVE_DOUBLE, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_swdefgfld(swId, GEO_FIELD9, DIM_NAME2, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD9
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_swdefgfld(swId, GEO_FIELD1, DIML_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      ! Define the "data" fields

      status = he5_swdefdfld(swId, DG_FIELD, DIM_NAME2, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = DAT_ERR // DG_FIELD
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF      
      
      status = he5_swdefdfld(swId, DG_FIELD1, DIMLL_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = DAT_ERR // DG_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_swdefdfld(swId, MD_FIELD, DIMNL_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = DAT_ERR // MD_FIELD
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_swdefdfld(swId, MDT_FIELD, DIMNL_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = DAT_ERR // MDT_FIELD
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      status = he5_swdefdfld(swId, DG_FIELD2, DIM_NAME2, "", & 
           & HE5T_NATIVE_INT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = DAT_ERR // DG_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Write to fields

      start  = 0
      stride = 1
      edge   = 1
      
      ! Geolocation

      status = he5_swwrfld(swId, GEO_FIELD3, start(1), stride(1), edge(1), & 
           & dg%time)
      IF (status /=0) THEN
         msr = WR_ERR //  GEO_FIELD3 // ' to swath ' // trim(dgName)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      edge(1) = dg%nLevels
      edge(2) = dg%nLats
      
      if (dg%nLevels.gt.0) then
         
         status = he5_swwrfld( swId, GEO_FIELD9, start(1), stride(1), edge(1),&
              & REAL(dg%pressure) )
         IF (status /= 0) THEN
            msr = WR_ERR //  GEO_FIELD9 // ' to swath ' // trim(dgName)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      if (dg%nLats.gt.0) then
         
         status = he5_swwrfld( swId, GEO_FIELD1, start(2), stride(2), edge(2),&
              & REAL(dg%latitude) )
         IF (status /= 0) THEN
            msr = WR_ERR //  GEO_FIELD1 // ' to swath ' // trim(dgName)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif

      ! One-dimensional data fields

      if (dg%nLevels.gt.0) then

         status = he5_swwrfld( swId, DG_FIELD, start(1), stride(1), edge(1), &
              & REAL(dg%gRss) )
         IF (status /= 0) THEN
            msr = WR_ERR //  DG_FIELD // ' to swath ' // trim(dgName)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         status = he5_swwrfld(swId, DG_FIELD2, start(1), stride(1), edge(1), &
              & dg%perMisPoints )
         IF (status /= 0) THEN
            msr = WR_ERR //  DG_FIELD2 // ' to swath ' // trim(dgName)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      endif
      
      ! Two-dimensional data fields

      if ((dg%nLevels.gt.0).and.(dg%nLats.gt.0)) then
      
         status = he5_swwrfld( swId, DG_FIELD1, start, stride, edge, & 
              & real(dg%latRss) )
         IF (status /= 0) THEN
            msr = WR_ERR //  DG_FIELD1 // ' to swath ' // trim(dgName)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      edge(1) = dg%N
      edge(2) = dg%nLevels
      
      if ( (dg%N.gt.0).and.(dg%nLevels.gt.0) )  then
         
         status = he5_swwrfld( swId, MD_FIELD, start, stride, edge, & 
              & real(dg%maxDiff) )
         IF (status /= 0) THEN
            msr = WR_ERR //  MD_FIELD // ' to swath ' // trim(dgName)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         status = he5_swwrfld( swId, MDT_FIELD, start, stride, edge, & 
              & dg%maxDiffTime )
              !& real(dg%maxDiffTime) )
         
         IF (status /= 0) THEN
            msr = WR_ERR //  MDT_FIELD // ' to swath ' // trim(dgName)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      ! Detach from the swath after writing
      
      status = he5_swdetach(swId)
      IF (status /= 0) THEN
         msr = GD_ERR // TRIM(dgName) // ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      ! Close the file after writing
      
      status = he5_swclose(swfID)
      IF (status /= 0) THEN
         msr = 'Failed to close file ' // TRIM(physicalFilename) // &
              & ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
    
      ! Write Attribute 
      CALL WriteAttributeSwath_HE5( trim(physicalFilename), dg) 

      msr = 'Swath ' // TRIM(dgName) // ' successfully written to file ' // &
           & trim(physicalFilename)
      CALL MLSMessage(MLSMSG_Info, ModuleName, msr)
      
    !----------------------------
    END SUBROUTINE OutputDiags_HE5
    !----------------------------
  
    !----------------------------------------------
    SUBROUTINE SetAliasGrid_HE5(physicalFilename, dg)
    !----------------------------------------------
    USE HDF5, ONLY: HID_T
    USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC, MLS_charType
    USE SDPToolkit, ONLY: PGS_S_SUCCESS
                                                                            
    ! Brief description of subroutine
    ! This subroutine writes attributes to each grid field
                                                                            
    ! Arguments
                                                                            
      CHARACTER (LEN=*), INTENT(IN) :: physicalFilename
                                                                            
      TYPE (L3DMData_T), INTENT(IN) :: dg
                                                                            
    ! Functions
                                                                            
      INTEGER, EXTERNAL :: &
        & he5_gdattach, he5_gdclose, he5_gddetach, he5_gdopen, &
        & he5_gdsetalias
                                                                            
    ! Parameters
                                                                            
      CHARACTER (len=*), parameter :: L3VALUE = 'L3dmValue'
      CHARACTER (len=*), parameter :: L3PRECISION = 'L3dmPrecision'
      CHARACTER (LEN=480) :: msr
      INTEGER (HID_T) :: gdfID, gdId
      INTEGER :: status, n, m, field
                                                                            
      gdfID = he5_gdopen(trim(physicalFilename), HE5F_ACC_RDWR)
                                                                            
      IF (gdfID == -1) THEN
         msr = MLSMSG_Fileopen // trim(physicalFilename) //' for writing swath'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
      gdId = he5_gdattach(gdfID, dg%name)
      IF (gdId == -1) THEN
         msr = 'Failed to attach to grid ' // trim(dg%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
      status = he5_gdsetalias(gdId, L3VALUE, trim(dg%name))
      if (status /= PGS_S_SUCCESS) then
         msr = 'Failed to alias l3Value' // trim(dg%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      endif
 
      status = he5_gdsetalias(gdId, L3PRECISION, trim(dg%name//'Precision')) 
      if (status /= PGS_S_SUCCESS) then
         msr = 'Failed to alias l3Precision' // trim(dg%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      endif
                                                                            
      status = he5_gddetach(gdID)
      IF (status == -1) THEN
         msr = 'Failed to deattach to grid ' // trim(dg%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
      status = he5_gdclose(gdfID)
      IF (status == -1) THEN
         msr = 'Failed to close grid ' // trim(dg%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
    !----------------------------
    END SUBROUTINE SetAliasGrid_HE5
    !----------------------------
                                                                            
    !----------------------------------------------
    SUBROUTINE WriteAttributeGrid_HE5(physicalFilename, dg)
    !----------------------------------------------
    USE HDF5, ONLY: HID_T
    USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC, MLS_charType
    USE MLSStrings, only: lowercase
    USE MLSStringLists, only: list2array
                                                                            
    ! Brief description of subroutine
    ! This subroutine writes attributes to each grid field
                                                                            
    ! Arguments
                                                                            
      CHARACTER (LEN=*), INTENT(IN) :: physicalFilename
                                                                            
      TYPE (L3DMData_T), INTENT(IN) :: dg
                                                                            
      ! Parameters
                                                                            
      integer, parameter :: CHARATTRLEN = 255
      integer, parameter :: NumOfGridFields = 4
      integer, parameter :: NumOfDataFields = 2
      character (len=*), parameter :: GridFieldTitles = &
        & 'Latitude,Longitude,Pressure,Time'
      character (len=*), parameter :: GridDataTitles = &
        & 'L3dmPrecision,L3dmValue'       
      character(len=CHARATTRLEN), dimension(NumOfGridFields) :: theTitles
      character(len=CHARATTRLEN), dimension(NumOfDataFields) :: dataTitles
      character(len=CHARATTRLEN) :: units_name, field_name
      real, parameter    :: UNDEFINED_VALUE =  -999.999
                                                                            
      ! Variables
                                                                            
      CHARACTER (LEN=480) :: msr
      CHARACTER (len=*), parameter :: AURA_FIELD = 'Aura-shared '
      CHARACTER (len=*), parameter :: MLS_SHARED_FIELD = 'HIRDL-MLS-TES-shared '
      CHARACTER (len=*), parameter :: MLS_FIELD = 'MLS-Specific '
      INTEGER (HID_T) :: gdfID, gdId
      INTEGER :: status, n, m, field
                                                                            
      ! Functions
                                                                            
      INTEGER, EXTERNAL :: &
        & he5_gdattach, he5_gdclose, he5_gddefproj, he5_gddetach, &
        & he5_gdopen, he5_gdwrattr, he5_gdwrlattr
                                                                            
      call List2Array(GridFieldTitles, theTitles, .true.)
      call List2Array(GridDataTitles, dataTitles, .true.)
                                                                            
      gdfID = he5_gdopen(trim(physicalFilename), HE5F_ACC_RDWR)
                                                                            
      IF (gdfID == -1) THEN          
	 msr = MLSMSG_Fileopen // trim(physicalFilename) //' for writing swath'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
      gdId = he5_gdattach(gdfID, dg%name)
      IF (gdId == -1) THEN
         msr = 'Failed to attach to grid ' // trim(dg%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
      ! Write attributes for grid (geolocation) fields
                                                                            
      do field=1, NumOfGridFields
        status = he5_gdwrlattr(gdId, theTitles(field), 'Missing Value', &
           & HE5T_NATIVE_FLOAT, 1, UNDEFINED_VALUE)
        status = he5_gdwrlattr(gdId, theTitles(field), 'Title', &
           & MLS_CHARTYPE, len_trim(theTitles(field)), theTitles(field))
        if (theTitles(field) == 'Pressure') then
           status = he5_gdwrlattr(gdId, theTitles(field), 'Unit', &
             & MLS_CHARTYPE, 3, 'hPa')
           status = he5_gdwrlattr(gdId, theTitles(field), &
             & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(AURA_FIELD), &
             & AURA_FIELD)
        else if (theTitles(field) == 'Time') then
           status = he5_gdwrlattr(gdId, theTitles(field), 'Unit', &
             & MLS_CHARTYPE, 1, 's')
           status = he5_gdwrlattr(gdId, theTitles(field), &
             & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(MLS_FIELD), &
             & MLS_FIELD)
        else
           status = he5_gdwrlattr(gdId, theTitles(field), 'Unit', &
             & MLS_CHARTYPE, 3, 'deg')
           status = he5_gdwrlattr(gdId, theTitles(field), &
             & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(MLS_SHARED_FIELD), &
             & MLS_SHARED_FIELD)
        endif
      enddo
                                                                            
      ! Write attributes for data fields
                                                                            
        select case (trim(lowercase(dg%name)))
        case ('temperature')
           units_name = 'K'
        case ('gph')
           units_name = 'm'
        case ('rhi')
           units_name = '%rhi'
        case default
           units_name = 'vmr'
        end select
                                                                            
      do field=1, NumOfDataFields
        field_name = trim(dg%name)//'-'//dataTitles(field)
        status = he5_gdwrlattr(gdId, dataTitles(field), 'Missing Value', &
           & HE5T_NATIVE_FLOAT, 1, UNDEFINED_VALUE)
        status = he5_gdwrlattr(gdId, dataTitles(field), 'Title', &
           & MLS_CHARTYPE, len_trim(field_name), field_name)
        status = he5_gdwrlattr(gdId, dataTitles(field), 'Unit', &
           & MLS_CHARTYPE, len_trim(units_name), units_name )
        status = he5_gdwrlattr(gdId, dataTitles(field), &
           & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(MLS_FIELD), &
             & MLS_FIELD)
      enddo
                                                                            
      status = he5_gddetach(gdID)
      IF (status == -1) THEN
         msr = 'Failed to deattach to grid ' // trim(dg%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
      status = he5_gdclose(gdfID)
      IF (status == -1) THEN
         msr = 'Failed to close grid ' // trim(dg%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF                                                               
                                                                            
    !----------------------------------------------
    END SUBROUTINE WriteAttributeGrid_HE5
    !----------------------------------------------
                                                                            
    !----------------------------------------------
    SUBROUTINE WriteAttributeSwath_HE5(physicalFilename, dg)
    !----------------------------------------------
    USE HDF5, ONLY: HID_T
    USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC, MLS_charType
    USE MLSStrings, only: lowercase
    USE MLSStringLists, only: list2array
                                                                            
    ! Brief description of subroutine
    ! This subroutine writes attributes to each swath field
                                                                            
    ! Arguments
                                                                            
      CHARACTER (LEN=*), INTENT(IN) :: physicalFilename
                                                                            
      TYPE (L3DMData_T), INTENT(IN) :: dg
                                                                            
      ! Parameters
                                                                            
      integer, parameter :: CHARATTRLEN = 255
      integer, parameter :: NumOfSwathFields = 3
      integer, parameter :: NumOfDataFields = 5
      character (len=GridNameLen) :: dgName
      character (len=*), parameter :: SwathFieldTitles = &
        & 'Latitude,Pressure,Time'
      character (len=*), parameter :: SwathDataTitles = &
        & 'GRss,LatRss,MaxDiff,MaxDiffTime,PerMisPoints'       
      character (len=*), parameter :: NoUnits = 'NoUnits' 
      character(len=CHARATTRLEN), dimension(NumOfSwathFields) :: theTitles
      character(len=CHARATTRLEN), dimension(NumOfDataFields) :: dataTitles
      character(len=CHARATTRLEN) :: units_name, field_name
      real, parameter    :: UNDEFINED_VALUE =  -999.999
                                                                            
      ! Variables
                                                                            
      CHARACTER (LEN=480) :: msr
      CHARACTER (len=*), parameter :: AURA_FIELD = 'Aura-shared '
      CHARACTER (len=*), parameter :: MLS_SHARED_FIELD = 'HIRDL-MLS-TES-shared '
      CHARACTER (len=*), parameter :: MLS_FIELD = 'MLS-Specific '
      INTEGER (HID_T) :: swfID, swId
      INTEGER :: status, n, m, field
                                                                            
      ! Functions
                                                                            
      INTEGER, EXTERNAL :: he5_swattach, he5_swclose, he5_swwrattr, &
           & he5_swwrlattr, he5_swdetach, he5_swopen

      dgName = TRIM(dg%name) // 'Diagnostics'

      call List2Array(SwathFieldTitles, theTitles, .true.)
      call List2Array(SwathDataTitles, dataTitles, .true.)
                                                                            
      swfID = he5_swopen(trim(physicalFilename), HE5F_ACC_RDWR)
                                                                            
      IF (swfID == -1) THEN          
	 msr = MLSMSG_Fileopen // trim(physicalFilename) //' for writing swath'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
      swId = he5_swattach(swfID, dgName)
      IF (swId == -1) THEN
         msr = 'Failed to attach to swath ' // trim(dgName)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
      ! Write attributes for swath (geolocation) fields
                                                                            
      do field=1, NumOfSwathFields
        status = he5_swwrlattr(swId, theTitles(field), 'Missing Value', &
           & HE5T_NATIVE_FLOAT, 1, UNDEFINED_VALUE)
        status = he5_swwrlattr(swId, theTitles(field), 'Title', &
           & MLS_CHARTYPE, len_trim(theTitles(field)), theTitles(field))
        if (theTitles(field) == 'Pressure') then
           status = he5_swwrlattr(swId, theTitles(field), 'Unit', &
             & MLS_CHARTYPE, 3, 'hPa')
           status = he5_swwrlattr(swId, theTitles(field), &
             & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(AURA_FIELD), &
             & AURA_FIELD)
        else if (theTitles(field) == 'Time') then
           status = he5_swwrlattr(swId, theTitles(field), 'Unit', &
             & MLS_CHARTYPE, 1, 's')
           status = he5_swwrlattr(swId, theTitles(field), &
             & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(MLS_FIELD), &
             & MLS_FIELD)
        else
           status = he5_swwrlattr(swId, theTitles(field), 'Unit', &
             & MLS_CHARTYPE, 3, 'deg')
           status = he5_swwrlattr(swId, theTitles(field), &
             & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(MLS_SHARED_FIELD), &
             & MLS_SHARED_FIELD)
        endif
      enddo
                                                                            
      ! Write attributes for data fields
                                                                            
        select case (trim(lowercase(dgName)))
        case ('temperature')
           units_name = 'K'
        case ('gph')
           units_name = 'm'
        case ('rhi')
           units_name = '%rhi'
        case default
           units_name = 'vmr'
        end select
                                                                            
      do field=1, NumOfDataFields
        field_name = trim(dgName)//dataTitles(field)
        status = he5_swwrlattr(swId, dataTitles(field), 'Missing Value', &
           & HE5T_NATIVE_FLOAT, 1, UNDEFINED_VALUE)
        status = he5_swwrlattr(swId, dataTitles(field), 'Title', &
           & MLS_CHARTYPE, len_trim(field_name), field_name)
        if ((dataTitles(field) == 'PerMisPoints') .OR. &
          (dataTitles(field) == 'MaxDiffTime') .OR. & 
          & (dataTitles(field) == 'MaxDiff')) then
           status = he5_swwrlattr(swId, dataTitles(field), 'Unit', &
              & MLS_CHARTYPE, len_trim(NoUnits), NoUnits )
	else
           status = he5_swwrlattr(swId, dataTitles(field), 'Unit', &
              & MLS_CHARTYPE, len_trim(units_name), units_name )
	endif
        status = he5_swwrlattr(swId, dataTitles(field), &
           & 'UniqueFieldDefinition', MLS_CHARTYPE, len_trim(MLS_FIELD), &
           & MLS_FIELD)
      enddo
                                                                            
      status = he5_swdetach(swID)
      IF (status == -1) THEN
         msr = 'Failed to deattach to swath ' // trim(dgName)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
                                                                            
      status = he5_swclose(swfID)
      IF (status == -1) THEN
         msr = 'Failed to close swath ' // trim(dgName)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF                                                               
                                                                            
    !----------------------------------------------
    END SUBROUTINE WriteAttributeSwath_HE5
    !----------------------------------------------
                                                                            
    !-----------------------------------------------------
    SUBROUTINE WriteMetaL3DM (pcf, l3cf, files, anText, hdfVersion)
    !-----------------------------------------------------

  USE HDF, ONLY: DFACC_RDWR, DFNT_FLOAT64, DFNT_FLOAT32, DFNT_INT32, & 
       & DFACC_WRITE
  USE HDFEOS5, ONLY: HE5F_ACC_RDWR, HE5_GDCLOSE, HE5_GDOPEN
  USE Intrinsic, ONLY: l_hdfeos
  USE MLSFiles, ONLY: HDFVERSION_5, HDFVERSION_4, mls_sfstart, mls_sfend
  USE OpenInit, ONLY: PCFData_T
  USE PCFHdr, ONLY: WritePCF2Hdr, WriteInputPointer, he5_writeglobalattr, &
     & GlobalAttributes
  USE PCFModule, ONLY: ExpandFileTemplate, FindFileDay 
  USE SDPToolkit, ONLY: PGSd_MET_NUM_OF_GROUPS, PGSd_MET_GROUP_NAME_L, & 
     & PGS_S_SUCCESS, PGSMET_E_MAND_NOT_SET, WARNIFCANTPGSMETREMOVE, &
     & max_orbits

      ! Brief description of subroutine
      ! This routine writes the metadata for an l3dm file, 
      ! and annotates it with the PCF.

      ! Arguments
      
      TYPE( L3CFProd_T ), INTENT(IN) :: l3cf
      
      TYPE (OutputFiles_T), INTENT(IN) :: files
      
      TYPE( PCFData_T ), INTENT(IN) :: pcf
      
      CHARACTER (LEN=1), POINTER :: anText(:)

      CHARACTER (LEN=8) :: rangeDate 

      INTEGER, INTENT(IN), OPTIONAL :: hdfVersion
      
      ! Parameters
      
      ! Functions

      INTEGER, EXTERNAL :: pgs_met_init, pgs_met_remove, pgs_met_setAttr_d, & 
           & pgs_met_setAttr_i, pgs_met_setAttr_s, pgs_met_write, & 
           & pgs_td_taiToUTC, gdinqgrid, he5_gdinqgrid

      ! Variables

      CHARACTER (LEN=PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
      CHARACTER (LEN=GridNameLen)           :: gridName
      CHARACTER (LEN=FileNameLen)           :: sval
      CHARACTER (LEN=CCSDS_LEN)             :: timeA
      CHARACTER (LEN=480)                   :: msr
      CHARACTER (LEN=132)                   :: list,gridlist
      CHARACTER (LEN=45)                    :: attrName
      ! CHARACTER (LEN=2)                     :: fileType
      integer ::                             fileType
      CHARACTER (LEN=1)                     :: cNum
      
      REAL(r8) :: dval

      INTEGER :: hdfReturn, i, j, indx, numGrids, result, sdid, &  
           & returnStatus, MyHDFVersion, len=0, maxNumOrb, k

      ! Initialize MyHDFVersion and use HDFEOS2 as default.

      IF (PRESENT(hdfVersion)) THEN 
         MyHDFVersion = hdfVersion
      ELSE 
         MyHDFVersion = HDFVERSION_4
      ENDIF

      ! Initialize the MCF file

      result = pgs_met_init(l3cf%mcfNum, groups)
      IF (result /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, ModuleName, &
           & 'Initialization error.  See LogStatus for details.')
      
      ! set the file type

      fileType = l_hdfeos

      ! For each l3dm file successfully created,
     
      DO i = 1, files%nFiles
         
         ! Open the HDF file and initialize the SD interface

         sdid = mls_sfstart(trim(files%name(i)), DFACC_RDWR, & 
              & hdfVersion=MyHDFVersion, addingMetaData=.true.)
         IF (sdid == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, & 
              & 'Failed to open the HDF file for metadata writing.')
         
         ! Set PGE values -- ECSDataGranule
         
         attrName = 'ReprocessingPlanned'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & 'further update anticipated using enhanced PGE')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'LocalGranuleID'
         indx = INDEX(files%name(i), '/', .TRUE.)
         sval = files%name(i)(indx+1:)
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, sval)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'DayNightFlag'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName,'Both')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'LocalVersionID'
         CALL ExpandFileTemplate('$cycle', sval, cycle=pcf%cycle)
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, sval)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         ! MeasuredParameterContainer -- find the number of grids in the file

         IF (MyHDFVersion==HDFVERSION_4) THEN 
            numGrids = gdinqgrid(files%name(i), list, len)
         ELSE IF (MyHDFVersion==HDFVERSION_5) THEN
            numGrids = he5_gdinqgrid(trim(files%name(i)), gridlist, len)
         ENDIF

         IF (numGrids .LE. 0) THEN
            msr = 'No grids found in file ' // TRIM( files%name(i) ) // &
                 & ' while attempting to write its metadata.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         ! For each grid in the file
        
         list = gridlist(:len) 
      
         DO j = 1, numGrids
            
            ! Extract its name
            
            indx = INDEX(list, ',')
            IF (indx /= 0) THEN
               gridName = list(:indx-1)
               list = list(indx+1:)
            ELSE
               !gridName = gridlist
               gridName = trim(list)
            ENDIF
           
            ! Append a class suffix to ParameterName, 
            ! and write the grid name as its value
            
            WRITE( cNum, '(I1)' ) j
            
            attrName = 'ParameterName' // '.' // cNum
            result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
                 & gridName)
            IF (result /= PGS_S_SUCCESS) THEN
               msr = METAWR_ERR // attrName
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
            
            ! QAStats Group
            
            attrName = 'QAPercentInterpolatedData' // '.' // cNum
            result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 0)
            IF (result /= PGS_S_SUCCESS) THEN
               msr = METAWR_ERR // attrName
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
            
            attrName = 'QAPercentMissingData' // '.' // cNum
            result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 0)
            IF (result /= PGS_S_SUCCESS) THEN
               msr = METAWR_ERR // attrName
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

            attrName = 'QAPercentOutofBoundsData' // '.' // cNum
            result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 0)
            IF (result /= PGS_S_SUCCESS) THEN
               msr = METAWR_ERR // attrName
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
            
         ENDDO
         
         ! OrbitCalculatedSpatialDomainContainer
        
         attrName = 'StartOrbitNumber' // '.1'

         IF (GlobalAttributes%OrbNumDays(1,i) == -1) THEN
           result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), &
		& attrName, 99999)
	 ELSE 
           result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), &
		& attrName, GlobalAttributes%OrbNumDays(1,i))
         ENDIF 

         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'StopOrbitNumber' // '.1'
         if (maxval(GlobalAttributes%OrbNumDays(:,i)) == -1) then
           result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), &
		& attrName, 99999)
	 else
           result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), &
		& attrName, maxval(GlobalAttributes%OrbNumDays(:,i)))
         end if
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         attrName = 'EquatorCrossingLongitude' // '.1'
         dval = 0.0
         result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), attrName, dval)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'EquatorCrossingTime' // '.1'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & '00:00:00')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'EquatorCrossingDate' // '.1'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & files%date(i) )
              ! & '1899-04-29')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         ! InputPointer
         
         attrName = 'InputPointer'
         ! result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
         !     & 'See the PCF annotation to this file.')
         result = WriteInputPointer(groups(INVENTORYMETADATA), attrName, &
           & fileType=l_hdfeos)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         ! Locality Value

         attrName = 'LocalityValue'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & 'Limb')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         ! VerticalSpatialDomain Product-Specific Attribute
         
         attrName = 'VerticalSpatialDomainType' // '.1'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & 'Atmosphere Layer')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'VerticalSpatialDomainValue' // '.1'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & 'Atmosphere Profile')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         ! HorizontalSpatialDomainContainer
         
         attrName = 'ZoneIdentifier'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & 'Other Grid System')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'WestBoundingCoordinate'
         dval = -180.0
         result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), attrName, dval)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'NorthBoundingCoordinate'
         dval = 90.0
         result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), attrName, dval)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'EastBoundingCoordinate'
         dval = 180.0
         result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), attrName, dval)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'SouthBoundingCoordinate'
         dval = -90.0
         result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), attrName, dval)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         ! RangeDateTime Group
         
         attrName = 'RangeBeginningDate'
         result = pgs_met_setAttr_s( groups(INVENTORYMETADATA), attrName, &
              & files%date(i) )
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'RangeBeginningTime'
         !returnStatus = pgs_td_taiToUTC(l3cf%timeD(1), timeA)
         !IF (returnStatus /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, &
         !     & ModuleName, TAI2A_ERR)
         !sval = timeA(12:26)
         sval = '00:00:00.000000'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, sval)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'RangeEndingDate'
         result = pgs_met_setAttr_s( groups(INVENTORYMETADATA), attrName, &
              & files%date(i) )
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         attrName = 'RangeEndingTime'
         sval = '23:59:59.999999'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, sval)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         ! PGEVersion
         
         attrName = 'PGEVersion'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & pcf%outputVersion)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         ! Write the metadata and their values to HDF attributes
         
         result = pgs_met_write(groups(INVENTORYMETADATA), "coremetadata", &
              & sdid)
         IF (result /= PGS_S_SUCCESS) THEN
            IF (result == PGSMET_E_MAND_NOT_SET) THEN
               CALL MLSMessage(MLSMSG_Error, ModuleName, & 
                    &'Some of the mandatory metadata parameters were not set.')
            ELSE
               CALL MLSMessage(MLSMSG_Error, ModuleName, & 
                    &'Metadata write failed.')
            ENDIF
         ENDIF
         
         ! Terminate access to the SD interface and close the file

         hdfReturn = mls_sfend(sdid, hdfVersion=MyHDFVersion, & 
              & addingMetaData=.true.)
         IF (hdfReturn /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Error closing HDF file after writing metadata.')
        
	! Set global attributes of Granule for each day of L3 Daily output file 
        rangeDate = files%date(i)
        GlobalAttributes%StartUTC = rangeDate(1:4)//'-'//rangeDate(6:8) &
	  & // 'T00:00:00.000000Z'
        GlobalAttributes%EndUTC = rangeDate(1:4)//'-'//rangeDate(6:8) &
	  & // 'T23:59:59.999999Z'
        call utc_to_yyyymmdd(GlobalAttributes%StartUTC, returnStatus, &
          & GlobalAttributes%GranuleYear, GlobalAttributes%GranuleMonth, &
          & GlobalAttributes%GranuleDay)
          
        ! Write global attributes
        if ( MyHDFVersion == HDFVERSION_5 ) then
          sdid = he5_gdopen (files%name(i), HE5F_ACC_RDWR)
          call he5_writeglobalattr(sdid,i)
          result = he5_gdclose (sdid)
        endif

        ! Annotate the file with the PCF
        CALL WritePCF2Hdr(files%name(i), anText, & 
              & hdfVersion=MyHDFVersion, fileType=fileType)
      ENDDO

      result = pgs_met_remove()
!      if (result /= PGS_S_SUCCESS .and. WARNIFCANTPGSMETREMOVE) THEN 
!         write(msr, *) result
!         CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!              & "Calling pgs_met_remove() failed with value " // trim(msr) )
!      endif
      

!------------------------------
   END SUBROUTINE WriteMetaL3DM
!------------------------------

!-----------------------------------------------------
   SUBROUTINE AllocateL3DM (nlev, nlat, nlon, N, l3dm)
!-----------------------------------------------------

! Brief description of subroutine
! This subroutine allocates the internal field pointers of the L3DMData_T
! derived type.

! Arguments

      INTEGER, INTENT(IN) :: nlev, nlat, nlon, N

      TYPE( L3DMData_T ), INTENT(INOUT) :: l3dm

! Parameters

! Functions

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: err

! Store the sizes of the dimensions

      l3dm%nLevels = nlev
      l3dm%nLats = nlat
      l3dm%nLons = nlon
      l3dm%N = N

! Horizontal geolocation fields

      if (l3dm%nLats .gt. 0) then

         ALLOCATE(l3dm%latitude(l3dm%nLats), STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' latitude pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      endif

      if (l3dm%nLons .gt. 0) then

         ALLOCATE(l3dm%longitude(l3dm%nLons), STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' longitude pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      endif

! Vertical geolocation field

      if (l3dm%nLevels .gt. 0) then

         ALLOCATE(l3dm%pressure(l3dm%nLevels), STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' pressure pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      endif

! Data fields

      if ((l3dm%nLevels.gt.0).and.(l3dm%nLats.gt.0).and. & 
           & (l3dm%nLons.gt.0)) then 

         ALLOCATE(l3dm%l3dmValue(l3dm%nLevels,l3dm%nLats,l3dm%nLons), STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' value pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         ALLOCATE(l3dm%l3dmPrecision(l3dm%nLevels,l3dm%nLats,l3dm%nLons), & 
              & STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' precision pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      endif

! Diagnostic fields

      if (l3dm%nLevels.gt.0) then 

         ALLOCATE(l3dm%gRss(l3dm%nLevels), STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' gRss pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      endif

      if ((l3dm%nLevels.gt.0).and.(l3dm%nLats.gt.0)) then
 
         ALLOCATE(l3dm%latRss(l3dm%nLevels,l3dm%nLats),STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' latRss pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      endif

      if ((l3dm%nLevels.gt.0).and.(l3dm%N.gt.0)) then

         ALLOCATE(l3dm%maxDiff(l3dm%N,l3dm%nLevels),STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' maxDiff pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         ALLOCATE(l3dm%maxDiffTime(l3dm%N,l3dm%nLevels),STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' maxDiffTime pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      endif

      if (l3dm%nLevels .gt. 0) then 
         
         ALLOCATE(l3dm%perMisPoints(l3dm%nLevels), STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' perMisPoints pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      endif

!-----------------------------
   END SUBROUTINE AllocateL3DM
!-----------------------------

!----------------------------------
   SUBROUTINE DeallocateL3DM (l3dm)
!----------------------------------

! Brief description of subroutine
! This subroutine deallocates the internal field pointers of the L3DMData_T
! derived type, after the calling program has finished with the data.

! Arguments

      TYPE( L3DMData_T ), INTENT(INOUT) :: l3dm

! Parameters

! Functions

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: err

! Horizontal geolocation fields

      if (l3dm%nLats .gt. 0) then

         IF ( ASSOCIATED(l3dm%latitude) ) THEN
            DEALLOCATE (l3dm%latitude, STAT=err)
            IF ( err /= 0 ) THEN
               msr = MLSMSG_DeAllocate // '  latitude pointer'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDIF

      endif

      if (l3dm%nLons .gt. 0) then

         IF ( ASSOCIATED(l3dm%longitude) ) THEN
            DEALLOCATE (l3dm%longitude, STAT=err)
            IF ( err /= 0 ) THEN
               msr = MLSMSG_DeAllocate // '  longitude pointer'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDIF

      endif

      ! Vertical geolocation field

      if (l3dm%nLevels .gt. 0) then

         IF ( ASSOCIATED(l3dm%pressure) ) THEN
            DEALLOCATE (l3dm%pressure, STAT=err)
            IF ( err /= 0 ) THEN
               msr = MLSMSG_DeAllocate // '  pressure pointer'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDIF

      endif

      ! Data fields
      
      if ((l3dm%nLevels.gt.0).and.(l3dm%nLats.gt.0).and.& 
           & (l3dm%nLons.gt.0)) then 

         IF ( ASSOCIATED(l3dm%l3dmValue) ) THEN
            DEALLOCATE (l3dm%l3dmValue, STAT=err)
            IF ( err /= 0 ) THEN
               msr = MLSMSG_DeAllocate // '  l3dmValue pointer'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDIF

         IF ( ASSOCIATED(l3dm%l3dmPrecision) ) THEN
            DEALLOCATE (l3dm%l3dmPrecision, STAT=err)
            IF ( err /= 0 ) THEN
               msr = MLSMSG_DeAllocate // '  l3dmPrecision'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDIF

      endif

      ! Diagnostic fields
      
      if (l3dm%nLevels.gt.0) then 

         IF ( ASSOCIATED(l3dm%gRss) ) THEN
            DEALLOCATE (l3dm%gRss, STAT=err)
            IF ( err /= 0 ) THEN
               msr = MLSMSG_DeAllocate // '  gRss pointer'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDIF

      endif

      if ((l3dm%nLevels.gt.0).and.(l3dm%nLats.gt.0)) then
         
         IF ( ASSOCIATED(l3dm%latRss) ) THEN
            DEALLOCATE (l3dm%latRss, STAT=err)
            IF ( err /= 0 ) THEN
               msr = MLSMSG_DeAllocate // '  latRss pointer'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDIF

      endif

      if ((l3dm%nLevels.gt.0).and.(l3dm%N.gt.0)) then

         IF ( ASSOCIATED(l3dm%maxDiff) ) THEN
            DEALLOCATE (l3dm%maxDiff, STAT=err)
            IF ( err /= 0 ) THEN
               msr = MLSMSG_DeAllocate // '  maxDiff pointer'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDIF

         IF ( ASSOCIATED(l3dm%maxDiffTime) ) THEN
            DEALLOCATE (l3dm%maxDiffTime, STAT=err)
            IF ( err /= 0 ) THEN
               msr = MLSMSG_DeAllocate // '  maxDiffTime pointer'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDIF

      endif

      if (l3dm%nLevels .gt. 0) then 

         IF ( ASSOCIATED(l3dm%perMisPoints) ) THEN
            DEALLOCATE (l3dm%perMisPoints, STAT=err)
            IF ( err /= 0 ) THEN
               msr = MLSMSG_DeAllocate // '  perMisPoints'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
         ENDIF

      endif

!-------------------------------
    END SUBROUTINE DeallocateL3DM
!-------------------------------

!-----------------------------------------
    SUBROUTINE DestroyL3DMDatabase (l3dmdb)
!-----------------------------------------

! Brief description of subroutine
! This subroutine deallocates the internal structures of an l3dm database, and
! then database itself


! Arguments

      TYPE (L3DMData_T), DIMENSION(:), POINTER :: l3dmdb

! Parameters

! Functions

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: err, i

! Check the status of the input pointer

      IF ( ASSOCIATED(l3dmdb) ) THEN

! If it's associated, then deallocate the internal structures

         DO i = 1, SIZE(l3dmdb)
            CALL DeallocateL3DM( l3dmdb(i) )
         ENDDO

! Deallocate the database itself

         DEALLOCATE (l3dmdb, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3dm database'
            CALL MLSMessage ( MLSMSG_Error, ModuleName, msr)
         ENDIF

      ENDIF

!------------------------------------
    END SUBROUTINE DestroyL3DMDatabase
!------------------------------------

!==================
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: L3DMData.f90,v 1.46 2006/09/26 15:04:44 cvuu Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
  END MODULE L3DMData
!==================

!# $Log: L3DMData.f90,v $
!# Revision 1.46  2006/09/26 15:04:44  cvuu
!# Remove spaces in soft link, add dashes in title
!#
!# Revision 1.45  2006/05/19 15:19:55  cvuu
!# Use reshape to reordering the array
!#
!# Revision 1.44  2006/04/17 15:42:06  cvuu
!# Add the local attributes to the diagnostic swath fields
!#
!# Revision 1.43  2006/02/28 17:56:56  cvuu
!# V2.00 commit
!#
!# Revision 1.42  2005/09/22 23:40:49  pwagner
!# date conversion procedures and functions all moved into dates module
!#
!# Revision 1.41  2005/06/23 19:07:38  pwagner
!# Reworded Copyright statement, moved rcs id
!#
!# Revision 1.40  2005/01/27 00:35:06  pwagner
!# ReprocessingActual field dropped from product metadata
!#
!# Revision 1.39  2004/12/16 15:01:54  cvuu
!# v1.5: Change value of ReprocessingActual to unknown in metadata file
!#
!# Revision 1.38  2004/12/13 17:40:56  cvuu
!# remove writing QA flags to meta file, use the ones in MCF v1.5
!#
!# Revision 1.37  2004/08/04 23:20:55  pwagner
!# Much moved from MLSStrings to MLSStringLists
!#
!# Revision 1.36  2004/05/04 15:33:15  cvuu
!# v1.4.3: Use int array for Date in Data Field
!#
!# Revision 1.35  2004/03/19 14:25:26  cvuu
!# Fix the RangeBeginningTime in metadata file
!#
!# Revision 1.34  2004/01/08 21:25:44  cvuu
!# Correct the day, month and doy in the global attribute
!#
!# Revision 1.33  2004/01/07 21:43:18  cvuu
!# version 1.4 commit
!#
!# Revision 1.32  2003/09/15 18:29:41  cvuu
!# Add OrbitNumber and OrbitPeriod to global attribute
!#
!# Revision 1.31  2003/08/21 20:22:46  cvuu
!# Remove testing print statements
!#
!# Revision 1.30  2003/08/18 17:03:59  cvuu
!# Add close and open in outputDiags_he5
!#
!# Revision 1.29  2003/08/11 23:29:09  cvuu
!# brought closer to James Johnson want to
!#
!# Revision 1.28  2003/07/08 00:18:09  pwagner
!# fileType now a lit_name instead of a char string
!#
!# Revision 1.27  2003/06/03 20:45:29  pwagner
!# Writes global attributes
!#
!# Revision 1.26  2003/06/02 23:45:15  pwagner
!# metadata chnages: OrbitNumber now -1; equatorCrossingDate now utc start date
!#
!# Revision 1.25  2003/05/30 23:52:42  pwagner
!# Relies on lib/PCFHdr to WriteInputPointer
!#
!# Revision 1.24  2003/04/30 18:15:48  pwagner
!# Work-around for LF95 infinite compile-time bug
!#
!# Revision 1.23  2003/04/08 20:26:46  pwagner
!# Snipped intraline continuation character to appease Lahey
!#
!# Revision 1.22  2003/03/22 02:13:20  jdone
!# added HDFEOS5/HDFEOS2 capability
!#
!# Revision 1.21  2003/03/15 00:16:38  pwagner
!# May warn if pgs_met_remove returns non-zero value
!#
!# Revision 1.20  2002/04/10 22:00:34  jdone
!# swwrfld edge values for time
!#
!# Revision 1.19  2002/04/01 21:58:49  jdone
!# check if array sizes are larger than 0
!#
!# Revision 1.18  2002/03/27 21:33:32  jdone
!# allocate statements checked and maxDiff is initialized
!#
!# Revision 1.17  2001/12/13 20:47:50  nakamura
!# Removed unused subroutine ReadL3DMData; merged dg fields into L3DMData_T.
!#
!# Revision 1.16  2001/11/26 19:24:20  nakamura
!# Moved L3DMDiag_T to its own module.
!#
!# Revision 1.15  2001/11/12 20:22:05  nakamura
!# Added pressure & lat to L3DMDiag_T.
!#
!# Revision 1.14  2001/10/05 20:16:25  nakamura
!# Added L3DMDiag_T.
!#
!# Revision 1.13  2001/07/18 15:54:37  nakamura
!# Gets metadata time from l3cf, rather than hard-coded to noon.
!#
!# Revision 1.12  2001/05/04 18:30:01  nakamura
!# Removed L3DMFiles_T and used generic OutputFiles_T.
!#
!# Revision 1.11  2001/04/24 19:38:23  nakamura
!# Removed references to private L2 parameters.
!#
!# Revision 1.10  2001/03/27 19:28:15  nakamura
!# Moved some parameters to MLSL3Common; updated metadata; fixed err checks on deallocate.
!#
!# Revision 1.9  2001/02/21 20:57:12  nakamura
!# Changed MLSPCF to MLSPCF3; made some parameters global; added ReadL3DMData; changed InputPointer.
!#
!# Revision 1.8  2001/02/09 19:18:05  nakamura
!# Moved DIMT to MLSL3Common; changed LocalGranuleID to file - .dat
!#
!# Revision 1.7  2001/01/16 17:44:00  nakamura
!# Made lowrgt corner of the grid variable; updated WriteMetaL3DM for new MCF and added writing of annotation.
!#
!# Revision 1.6  2000/12/29 20:50:33  nakamura
!# Moved global parameters to MLSL3Common; added L3DMFiles_T; switched to one-product/all-days paradigm.
!#
!# Revision 1.5  2000/12/07 19:34:42  nakamura
!# Added ONLY to USE L2GPData; replaced local error msgs with MLSMSG_DeAllocate.
!#
!# Revision 1.4  2000/11/15 21:00:26  nakamura
!# Added parameter GridNameLen.
!#
!# Revision 1.3  2000/10/24 19:21:08  nakamura
!# Removed dependence on OutputL2GP.
!#
!# Revision 1.2  2000/10/17 20:17:09  nakamura
!# Added parameters used globally by L3; updated WriteMetaL3DM for new input.
!#
!# Revision 1.1  2000/10/05 19:11:07  nakamura
!# Module for the L3DM data type.
!#
@


1.46
log
@Remove spaces in soft link, add dashes in title
@
text
@d1214 1
a1214 1
  USE Intrinsic, ONLY: l_grid, l_hdfeos
d1284 1
a1284 1
      fileType = l_grid
d1975 1
a1975 1
       "$Id: L3DMData.f90,v 1.45 2006/05/19 15:19:55 cvuu Exp $"
d1984 3
@


1.45
log
@Use reshape to reordering the array
@
text
@d1036 1
a1036 1
        field_name = trim(dg%name)//dataTitles(field)
d1975 1
a1975 1
       "$Id: L3DMData.f90,v 1.44 2006/04/17 15:42:06 cvuu Exp $"
d1984 3
@


1.44
log
@Add the local attributes to the diagnostic swath fields
@
text
@d477 7
a483 9
      DO x=1,l3dmData(i)%nLons
         DO y=1,l3dmData(i)%nLats
            DO z=1,l3dmData(i)%nLevels
                tempL3Value(x,y,z)=l3dmData(i)%l3dmValue(z,y,x)
                tempL3Prec(x,y,z)=l3dmData(i)%l3dmPrecision(z,y,x)
            ENDDO
         ENDDO
      ENDDO
                                                                          
d1975 1
a1975 1
       "$Id: L3DMData.f90,v 1.43 2006/02/28 17:56:56 cvuu Exp $"
d1984 3
@


1.43
log
@V2.00 commit
@
text
@d59 1
d849 4
a852 1
      
d954 1
a954 1
      integer, parameter :: NumOfGridFields = 3
d957 1
a957 1
        & 'Latitude,Longitude,Pressure'
d1009 6
d1066 143
d1977 1
a1977 1
       "$Id: L3DMData.f90,v 1.42 2005/09/22 23:40:49 pwagner Exp $"
d1986 3
@


1.42
log
@date conversion procedures and functions all moved into dates module
@
text
@d27 5
a31 1
       & HDFE_NOMERGE, INVENTORYMETADATA
d52 2
d58 3
a60 1

d113 1
d196 3
a198 3
       call OutputGrids_HE5(type, l3dmData, l3dmFiles, createFile)
    else if (hdfVersion == HDFVERSION_4) then
       call OutputGrids_HE2(type, l3dmData, l3dmFiles)
a204 325
  !---------------------------------------------------
  SUBROUTINE OutputGrids_HE2(type, l3dmData, l3dmFiles)
  !---------------------------------------------------
  USE HDF, ONLY: DFACC_RDWR, DFNT_FLOAT64, DFNT_FLOAT32, DFNT_INT32, & 
       & DFACC_WRITE
  USE MLSPCF3, ONLY: mlspcf_l3dm_start, mlspcf_l3dm_end
  USE MLSStrings, ONLY: LinearSearchStringArray
  USE PCFModule, ONLY: ExpandFileTemplate, FindFileDay 

    ! Brief description of subroutine
    ! This subroutine creates and writes to the grid portion of l3dm files.

    ! Arguments
     
    CHARACTER (LEN=*), INTENT(IN) :: type
     
    TYPE (L3DMData_T), INTENT(IN) :: l3dmData(:)
     
    TYPE (OutputFiles_T), INTENT(INOUT) :: l3dmFiles
   
    ! Parameters

    ! Variables

    CHARACTER (LEN=480) :: msr
    CHARACTER (LEN=FileNameLen) :: physicalFilename
    CHARACTER (LEN=8) :: date

    REAL(r8) :: projparm(13)
    REAL(r8) :: uplft(2), lowrgt(2)
    REAL :: maxLat, maxLon, minLat, minLon

    INTEGER :: start(3), stride(3), edge(3)
    INTEGER :: gdfID, gdId, i, match, status

    ! Functions

    INTEGER, EXTERNAL :: gdattach, gdclose, gdcreate, gddefdim, gddeffld, &
         & gddefproj, gddetach, gdopen, gdwrfld
     
    ! For each day in the l3dm database,
     
    DO i = 1, SIZE(l3dmData)

       ! Find the output file for the level/species/day in the PCF
        
       CALL FindFileDay(type, l3dmData(i)%time, mlspcf_l3dm_start, &
            & mlspcf_l3dm_end, match, physicalFilename, date)
       IF (match == -1) THEN
          msr = 'No ' // TRIM(type) // ' file found in the PCF for day ' // &
               & date
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       ! Check whether the name is distinct; if so, save it in l3dmFiles

       IF (LinearSearchStringArray(l3dmFiles%name,physicalFilename)== 0) THEN
          l3dmFiles%nFiles = l3dmFiles%nFiles+1
          l3dmFiles%name(l3dmFiles%nFiles) = physicalFilename
          l3dmFiles%date(l3dmFiles%nFiles) = date
       ENDIF
         
       ! Open the output file
         
       gdfID = gdopen(trim(physicalFilename), DFACC_RDWR)
       IF (gdfID == -1) THEN
          msr = MLSMSG_Fileopen//trim(physicalFilename)//' for writing grid.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF

       ! Set up the grid.  
       ! The region is bounded by 180W to 176E longitude varying latitude. 
       ! Grid into 90 bins along the x-axis, by nLats bins along
       ! the y-axis (4x2 bins).  
       ! Upper Left & Lower Right corners in DDDMMMSSS.ss.
         
       projparm = 0.0
         
       ! Find boundaries of measured latitude
       ! and upper bound of measure longitude

       maxLat = MAXVAL( l3dmData(i)%latitude )
       minLat = MINVAL( l3dmData(i)%latitude )
       maxLon = MAXVAL( l3dmData(i)%longitude)
       minLon = MINVAL( l3dmData(i)%longitude)

       ! Convert to "packed degree format"
         
       CALL ConvertDeg2DMS(maxLat, uplft(2) )
       CALL ConvertDeg2DMS(minLat, lowrgt(2))
       CALL ConvertDeg2DMS(maxLon, lowrgt(1))
       CALL ConvertDeg2DMS(minLon, uplft(1) )
         
       ! Create the grid

       gdId = gdcreate(gdfID, trim(l3dmData(i)%name), l3dmData(i)%nLons, &
            & l3dmData(i)%nLats, uplft, lowrgt)
       IF (gdId == -1) THEN
          msr = 'Failed to create grid ' // trim(l3dmData(i)%name)
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF

       ! Define the dimensions

       status = gddefdim(gdId, DIMX_NAME, l3dmData(i)%nLons)
       IF (status /= 0) THEN
          msr = DIM_ERR // DIMX_NAME
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       status = gddefdim(gdId, DIMY_NAME, l3dmData(i)%nLats)
       IF (status /= 0) THEN
          msr = DIM_ERR // DIMY_NAME
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       status = gddefdim(gdId, DIMZ_NAME, l3dmData(i)%nLevels)
       IF (status /= 0) THEN
          msr = DIM_ERR // DIMZ_NAME
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       status = gddefdim(gdId, DIMT_NAME, 1)
       IF (status /= 0) THEN
          msr = DIM_ERR // DIMT_NAME
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       ! Define a "Geographic projection," 
       ! using defaults in all unneeded fields

       status = gddefproj(gdId, GCTP_GEO, 0, 0, projparm)
       IF (status /= 0) THEN
          msr = 'Failed to define projection for grid '//trim(l3dmData(i)%name)
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       ! Define the "geolocation" fields
         
       status = gddeffld(gdId, GEO_FIELD3, DIMT_NAME, DFNT_FLOAT32, &
            & HDFE_NOMERGE)
       IF (status /= 0) THEN
          msr = GEO_ERR // GEO_FIELD3
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       status = gddeffld(gdId, GEO_FIELD9, DIMZ_NAME, DFNT_FLOAT32, &
            & HDFE_NOMERGE)
       IF (status /= 0) THEN
          msr = GEO_ERR // GEO_FIELD9
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       status = gddeffld(gdId, GEO_FIELD1, DIMY_NAME, DFNT_FLOAT32, &
            & HDFE_NOMERGE)
       IF (status /= 0) THEN
          msr = GEO_ERR // GEO_FIELD1
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       status = gddeffld(gdId, GEO_FIELD2, DIMX_NAME, DFNT_FLOAT32, &
            & HDFE_NOMERGE)
       IF (status /= 0) THEN
          msr = GEO_ERR // GEO_FIELD2
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       ! Define the "data" fields
         
       status = gddeffld(gdId, DATA_FIELDV, DIMXYZ_NAME, DFNT_FLOAT32, &
            & HDFE_NOMERGE)
       IF (status /= 0) THEN
          msr = DAT_ERR // DATA_FIELDV
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       status = gddeffld(gdId, DATA_FIELDP, DIMXYZ_NAME, DFNT_FLOAT32, &
            & HDFE_NOMERGE)
       IF (status /= 0) THEN
          msr = DAT_ERR // DATA_FIELDP
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       ! Detach from and close the grid interface.  
       ! This step is necessary to store
       ! properly the grid information within the file and must be done 
       ! before writing or reading data to or from the grid.
         
       status = gddetach(gdId)
       IF (status /= 0) THEN
          msr = GD_ERR // TRIM( l3dmData(i)%name ) // ' after definition.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       status = gdclose(gdfID)
       IF (status /= 0) THEN
          msr = 'Failed to close file ' // TRIM(physicalFilename) // &
               & ' after definition.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       ! Re-open the file for writing
         
       gdfID = gdopen(trim(physicalFilename), DFACC_RDWR)
       IF (gdfID == -1) THEN
          msr = MLSMSG_Fileopen // TRIM(physicalFilename) & 
               & // ' for writing grid data.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       ! Re-attach to the grid for writing
       
       gdId = gdattach(gdfID, trim(l3dmData(i)%name))
       IF (gdId == -1) THEN
          msr = 'Failed to attach to grid ' // trim(l3dmData(i)%name)
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       ! Write to fields
         
       start  = 0
       stride = 1
       edge   = 1
         
       status = gdwrfld(gdId, GEO_FIELD3, start(1), stride(1), edge(1), &
            & l3dmData(i)%time)
         
       IF (status /=0) THEN
          msr = 'Failed to write field ' //  GEO_FIELD3 // ' to grid ' &
               & // trim(l3dmData(i)%name)
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
         
       edge(1) = l3dmData(i)%nLevels
       edge(2) = l3dmData(i)%nLats
       edge(3) = l3dmData(i)%nLons
         
       if (l3dmData(i)%nLevels.gt.0) then
            
          status = gdwrfld( gdId, GEO_FIELD9, start(1), stride(1), edge(1),&
               & REAL(l3dmData(i)%pressure) )
          IF (status /= 0) THEN
             msr = 'Failed to write field ' //  GEO_FIELD9 // ' to grid ' &
                  & // trim(l3dmData(i)%name)
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
         
      endif
      
      if (l3dmData(i)%nLats.gt.0) then
         
         status = gdwrfld( gdId, GEO_FIELD1, start(2), stride(2), edge(2), &
              & REAL(l3dmData(i)%latitude) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  GEO_FIELD1 // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      if (l3dmData(i)%nLons.gt.0) then
         status = gdwrfld( gdId, GEO_FIELD2, start(3), stride(3), edge(3), &
              & REAL(l3dmData(i)%longitude) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  GEO_FIELD2 // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      if ((l3dmData(i)%nLons.gt.0).and.(l3dmData(i)%nLats.gt.0).and. & 
           & (l3dmData(i)%nLevels.gt.0)) then
         
         status = gdwrfld( gdId, DATA_FIELDV, start, stride, edge, &
              & REAL(l3dmData(i)%l3dmValue) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  DATA_FIELDV // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         status = gdwrfld( gdId, DATA_FIELDP, start, stride, edge, &
              & REAL(l3dmData(i)%l3dmPrecision) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  DATA_FIELDP // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      ! Detach from the grid after writing

      status = gddetach(gdId)
      IF (status /= 0) THEN
         msr = GD_ERR // TRIM( l3dmData(i)%name ) // ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      ! Close the file after writing
      
      status = gdclose(gdfID)
      IF (status /= 0) THEN
         msr = 'Failed to close file ' // TRIM(physicalFilename) // &
              & ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      msr = 'Grid ' // TRIM(l3dmData(i)%name) // & 
           & ' successfully written to file ' // trim(physicalFilename)
      CALL MLSMessage(MLSMSG_Info, ModuleName, msr)
      
! Create & write to diagnostic swath
      
      CALL OutputDiags_HE2( trim(physicalFilename), l3dmData(i) )
      
   ENDDO
   
 !----------------------------
 END SUBROUTINE OutputGrids_HE2
 !----------------------------

 
d211 1
a211 1
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC 
d239 3
a241 1
   
d244 2
a245 1
   INTEGER :: i, match, status
d251 2
a252 2
        & he5_gddeffld, he5_gddefproj, he5_gddetach, he5_gdopen, he5_gdwrfld
      
d254 1
a254 1
   
d256 1
a256 1
      
d258 1
a258 1
      
a320 12
      status = he5_gddefdim(gdId, DIMX_NAME, l3dmData(i)%nLons)
      IF (status /= 0) THEN
         msr = DIM_ERR // DIMX_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_gddefdim(gdId, DIMY_NAME, l3dmData(i)%nLats)
      IF (status /= 0) THEN
         msr = DIM_ERR // DIMY_NAME
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
d326 1
a326 1
      
d332 1
a332 1
      
d340 5
a344 43
      
      ! Define the "geolocation" fields
      
      status = he5_gddeffld(gdId, GEO_FIELD3, DIMT_NAME, "", & 
           & HE5T_NATIVE_DOUBLE, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD3
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_gddeffld(gdId, GEO_FIELD9, DIMZ_NAME, "", & 
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD9
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_gddeffld(gdId, GEO_FIELD1, DIMY_NAME, "", &
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_gddeffld(gdId, GEO_FIELD2, DIMX_NAME, "", &
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = GEO_ERR // GEO_FIELD2
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      
      ! Define the "data" fields
      
      status = he5_gddeffld(gdId, DATA_FIELDV, DIMXYZ_NAME, "", &
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = DAT_ERR // DATA_FIELDV
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      status = he5_gddeffld(gdId, DATA_FIELDP, DIMXYZ_NAME, "", &
           & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
d346 1
a346 168
         msr = DAT_ERR // DATA_FIELDP
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Detach from and close the grid interface.
      ! This step is necessary to store
      ! properly the grid information within the file and must be done
      ! before writing or reading data to or from the grid.
                                                                                           
      status = he5_gddetach(gdId)
      IF (status /= 0) THEN
         msr = GD_ERR // TRIM( l3dmData(i)%name ) // ' after definition.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ! Re-attach to the grid for writing
                                                                                           
      gdId = he5_gdattach(gdfID, l3dmData(i)%name)
      IF (gdId == -1) THEN
         msr = 'Failed to attach to grid ' // trim(l3dmData(i)%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      ! Write to fields
      
      start = 0
      stride = 1
      edge = 1
      
      status = he5_gdwrfld(gdId, GEO_FIELD3, start(1), stride(1), edge(1), &
           & l3dmData(i)%time)

      IF (status /=0) THEN
         msr = 'Failed to write field ' //  GEO_FIELD3 // ' to grid ' &
              & // trim(l3dmData(i)%name)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      edge(1) = l3dmData(i)%nLevels
      edge(2) = l3dmData(i)%nLats
      edge(3) = l3dmData(i)%nLons
      
      if (l3dmData(i)%nLevels.gt.0) then
         
         status = he5_gdwrfld( gdId, GEO_FIELD9, start(1), stride(1), edge(1),&
              & REAL(l3dmData(i)%pressure) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  GEO_FIELD9 // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      if (l3dmData(i)%nLats.gt.0) then
         
         status = he5_gdwrfld( gdId, GEO_FIELD1, start(2), stride(2), edge(2),&
              & REAL(l3dmData(i)%latitude) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  GEO_FIELD1 // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      if (l3dmData(i)%nLons.gt.0) then
         status = he5_gdwrfld( gdId, GEO_FIELD2, start(3), stride(3), edge(3),&
              & REAL(l3dmData(i)%longitude) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  GEO_FIELD2 // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
      endif
      
      if ((l3dmData(i)%nLons.gt.0).and.(l3dmData(i)%nLats.gt.0).and. & 
           & (l3dmData(i)%nLevels.gt.0)) then
         
         status = he5_gdwrfld( gdId, DATA_FIELDV, start, stride, edge, &
              & REAL(l3dmData(i)%l3dmValue) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  DATA_FIELDV // ' to grid ' &
                 & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         status = he5_gdwrfld( gdId, DATA_FIELDP, start, stride, edge, &
              & REAL(l3dmData(i)%l3dmPrecision) )
         IF (status /= 0) THEN
            msr = 'Failed to write field ' //  DATA_FIELDP // ' to grid ' &
                  & // trim(l3dmData(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         endif
         
! Detach from the grid after writing
         
         status = he5_gddetach(gdId)
         IF (status /= 0) THEN
            msr = GD_ERR // TRIM( l3dmData(i)%name ) // ' after writing.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
! Close the file after writing
         
         status = he5_gdclose(gdfID)
         IF (status /= 0) THEN
            msr = 'Failed to close file ' // TRIM(physicalFilename) // &
                 & ' after writing.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
         msr = 'Grid ' // TRIM(l3dmData(i)%name) // & 
              & ' successfully written to file ' // trim(physicalFilename)
         CALL MLSMessage(MLSMSG_Info, ModuleName, msr)
         
         ! Create & write to diagnostic swath
         
         CALL OutputDiags_HE5( trim(physicalFilename), l3dmData(i) )
         
      ENDDO
      
      createFile = .false. 
    !----------------------------
    END SUBROUTINE OutputGrids_HE5
    !----------------------------
    
   !----------------------------------------------
    SUBROUTINE OutputDiags_HE2(physicalFilename, dg)
    !----------------------------------------------
  USE HDF, ONLY: DFACC_RDWR, DFNT_FLOAT64, DFNT_FLOAT32, DFNT_INT32, & 
       & DFACC_WRITE

      ! Brief description of subroutine
      ! This subroutine creates and writes to 
      ! the diagnostic portion of the l3dm files.

      ! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: physicalFilename
      
      TYPE (L3DMData_T), INTENT(IN) :: dg
      
      ! Parameters
      
      CHARACTER (LEN=*), PARAMETER :: DIMNL_NAME = 'N,nLevels'
            
      ! Variables
      
      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=GridNameLen) :: dgName
      
      INTEGER :: start(2), stride(2), edge(2)
      INTEGER :: swfID, swId, status, n, m

      ! Functions
      
      INTEGER, EXTERNAL :: swattach, swclose, swcreate, swdefdfld, swdefdim, &
           & swdefgfld, swdetach, swopen, swwrfld
      
      ! Re-open the file for the creation of diagnostic swaths
      
      swfID = swopen(trim(physicalFilename), DFACC_RDWR)
      IF (swfID == -1) THEN
         msr = MLSMSG_Fileopen // trim(physicalFilename)
d349 4
a352 8
      
      ! Create the swath
      
      dgName = TRIM(dg%name) // 'Diagnostics'
      
      swId = swcreate(swfID, dgName)
      IF (swId == -1) THEN
         msr = 'Failed to create swath ' // trim(dgName)
d355 3
a357 4
      
      ! Define the dimensions
      
      status = swdefdim(swId, DIMN_NAME, dg%N)
d359 1
a359 1
         msr = DIM_ERR // DIMN_NAME
d362 3
a364 2
      
      status = swdefdim(swId, DIML_NAME, dg%nLats)
d366 1
a366 1
         msr = DIM_ERR // DIML_NAME
d369 3
a371 2
      
      status = swdefdim(swId, DIM_NAME2, dg%nLevels)
d373 1
a373 1
         msr = DIM_ERR // DIM_NAME2
d376 3
a378 2
      
      status = swdefdim(swId, DIMT_NAME, 1)
d380 1
a380 1
         msr = DIM_ERR // DIMT_NAME
d383 5
a387 5
      
      ! Define the "geolocation" fields using the above dimensions
      
      status = swdefgfld(swId, GEO_FIELD3, DIMT_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
d393 2
a394 2
      status = swdefgfld(swId, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
d400 2
a401 2
      status = swdefgfld(swId, GEO_FIELD1, DIML_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
d407 2
a408 3
      ! Define the "data" fields
      
      status = swdefdfld(swId, DG_FIELD, DIM_NAME2, DFNT_FLOAT32, HDFE_NOMERGE)
d410 1
a410 1
         msr = DAT_ERR // DG_FIELD
a413 6
      status = swdefdfld(swId, DG_FIELD1, DIMLL_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
      IF (status /= 0) THEN
         msr = DAT_ERR // DG_FIELD1
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d415 4
a418 1
      status = swdefdfld(swId, MD_FIELD, DIMNL_NAME, DFNT_FLOAT32,HDFE_NOMERGE)
d420 1
a420 1
         msr = DAT_ERR // MD_FIELD
d424 2
a425 2
      status = swdefdfld(swId, MDT_FIELD, DIMNL_NAME, DFNT_FLOAT32, & 
           & HDFE_NOMERGE)
d427 1
a427 1
         msr = DAT_ERR // MDT_FIELD
d430 7
a436 2
      
      status = swdefdfld(swId, DG_FIELD2, DIM_NAME2, DFNT_INT32, HDFE_NOMERGE)
d438 1
a438 1
         msr = DAT_ERR // DG_FIELD2
d441 6
a446 7
      
      ! Detach from the swath interface after definition
      
      status = swdetach(swId)
      IF (status /= 0) THEN
         msr = 'Failed to detach from swath ' // TRIM(dgName) // &
              & ' after definition.'
d450 2
a451 1
      ! Re-attach to the swath for writing
d453 14
a466 5
      swId = swattach(swfID, dgName)
      IF (swId == -1) THEN
         msr = 'Failed to re-attach to swath ' // TRIM(dgName) & 
              & //' for writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a467 2
      
      ! Write to fields
d469 6
a474 5
      start  = 0
      stride = 1
      edge   = 1
      
      ! Geolocation
d476 11
a486 1
      status = swwrfld(swId, GEO_FIELD3, start(1), stride(1), edge(1), dg%time)
d488 2
a489 1
         msr = WR_ERR //  GEO_FIELD3 // ' to swath ' // trim(dgName)
d492 2
a493 5

      edge(1) = dg%nLevels
      edge(2) = dg%nLats

      if (dg%nLevels.gt.0) then
d495 2
a496 2
         status = swwrfld( swId, GEO_FIELD9, start(1), stride(1), edge(1), &
              & REAL(dg%pressure) )
d498 2
a499 1
            msr = WR_ERR //  GEO_FIELD9 // ' to swath ' // trim(dgName)
d505 9
a513 1
      if (dg%nLats.gt.0) then
d515 5
a519 2
         status = swwrfld( swId, GEO_FIELD1, start(2), stride(2), edge(2), &
              & REAL(dg%latitude) )
d521 2
a522 1
            msr = WR_ERR //  GEO_FIELD1 // ' to swath ' // trim(dgName)
d528 2
a529 1
! One-dimensional data fields
d531 2
a532 4
      if (dg%nLevels.gt.0) then
         
         status = swwrfld( swId, DG_FIELD, start(1), stride(1), edge(1), &
              & REAL(dg%gRss) )
d534 2
a535 1
            msr = WR_ERR //  DG_FIELD // ' to swath ' // trim(dgName)
d539 3
a541 2
         status = swwrfld(swId, DG_FIELD2, start(1), stride(1), edge(1), &
              & dg%perMisPoints )
d543 2
a544 1
            msr = WR_ERR //  DG_FIELD2 // ' to swath ' // trim(dgName)
a547 4
      
      ! Two-dimensional data fields

      if ((dg%nLevels.gt.0).and.(dg%nLats.gt.0)) then
d549 3
a551 2
         status = swwrfld( swId, DG_FIELD1, start, stride, edge, & 
              & real(dg%latRss) )
d553 1
a553 1
            msr = WR_ERR //  DG_FIELD1 // ' to swath ' // trim(dgName)
d557 1
a557 6
      endif
      
      edge(1) = dg%N
      edge(2) = dg%nLevels
      
      if ( (dg%N.gt.0).and.(dg%nLevels.gt.0) )  then
d559 1
a559 2
         status = swwrfld( swId, MD_FIELD, start, stride, edge, & 
              & real(dg%maxDiff) )
d561 2
a562 1
            msr = WR_ERR //  MD_FIELD // ' to swath ' // trim(dgName)
d565 17
d583 4
a586 5
         status = swwrfld( swId, MDT_FIELD, start, stride, edge, & 
              & real(dg%maxDiffTime) )
         IF (status /= 0) THEN
            msr = WR_ERR //  MDT_FIELD // ' to swath ' // trim(dgName)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d588 4
a591 24
         
      endif
      
      ! Detach from the swath after writing
      
      status = swdetach(swId)
      IF (status /= 0) THEN
         msr = GD_ERR // TRIM(dgName) // ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      ! Close the file after writing
      
      status = swclose(swfID)
      IF (status /= 0) THEN
         msr = 'Failed to close file ' // TRIM(physicalFilename) // &
              & ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      msr = 'Swath ' // TRIM(dgName) // ' successfully written to file ' // &
           & trim(physicalFilename)
      CALL MLSMessage(MLSMSG_Info, ModuleName, msr)
      
d593 1
a593 1
    END SUBROUTINE OutputDiags_HE2
d856 200
a1055 1
   
d1059 1
d1115 1
a1115 1
           & returnStatus, MyHDFVersion, len=0
d1136 1
a1136 1
      
d1251 1
a1251 2
	 ! This changes confirm James Johnson suggestion on 6/12/03 
	 ! use 99999 for invalid value for now
a1252 10
         !attrName = 'OrbitNumber' // '.1'
         !result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
         !IF (result /= PGS_S_SUCCESS) THEN
         !  msr = METAWR_ERR // attrName
         !   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         !ENDIF
        
         attrName = 'StartOrbitNumber' // '.1'
         !result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
         !result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 99999)
a1266 2
         !result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
         !result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 99999)
a1453 5
         
         ! Annotate the file with the PCF
  
         CALL WritePCF2Hdr(files%name(i), anText, & 
              & hdfVersion=MyHDFVersion, fileType=fileType)
d1471 4
d1824 1
a1824 1
       "$Id: L3DMData.f90,v 1.41 2005/06/23 19:07:38 pwagner Exp $"
d1833 3
@


1.41
log
@Reworded Copyright statement, moved rcs id
@
text
@d30 1
a30 1
  USE MLSStringLists, only: utc_to_yyyymmdd
d39 1
a39 1
       "$RCSfile: $"
d2150 1
a2150 1
       "$Id: $"
d2159 3
@


1.40
log
@ReprocessingActual field dropped from product metadata
@
text
@d1 10
a10 2
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a35 1
  PRIVATE :: ID, ModuleName
d37 5
a41 5
!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &
   "$Id: L3DMData.f90,v 1.39 2004/12/16 15:01:54 cvuu Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: L3DMData.f90,v $"
!----------------------------------------------------------
d2147 8
d2159 3
@


1.39
log
@v1.5: Change value of ReprocessingActual to unknown in metadata file
@
text
@d32 1
a32 1
   "$Id: L3DMData.f90,v 1.38 2004/12/13 17:40:56 cvuu Exp $"
a1460 8
         attrName = 'ReprocessingActual'
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & 'unknown')
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
         
d2144 3
@


1.38
log
@remove writing QA flags to meta file, use the ones in MCF v1.5
@
text
@d32 1
a32 1
   "$Id: L3DMData.f90,v 1.37 2004/08/04 23:20:55 pwagner Exp $"
d1463 1
a1463 1
              & 'processed once')
d2152 3
@


1.37
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d32 1
a32 1
   "$Id: L3DMData.f90,v 1.36 2004/05/04 15:33:15 cvuu Exp $"
a1536 34
            ! QAFlags Group
            
            attrName = 'AutomaticQualityFlag' // '.' // cNum
            result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
                 & 'Passed')
            IF (result /= PGS_S_SUCCESS) THEN
               msr = METAWR_ERR // attrName
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
            
            attrName = 'AutomaticQualityFlagExplanation' // '.' // cNum
            result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
                 & 'pending algorithm update')
            IF (result /= PGS_S_SUCCESS) THEN
               msr = METAWR_ERR // attrName
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
            
            attrName = 'OperationalQualityFlag' // '.' // cNum
            result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
                 & 'Not Investigated')
            IF (result /= PGS_S_SUCCESS) THEN
               msr = METAWR_ERR // attrName
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

            attrName = 'OperationalQualityFlagExplanation' // '.' // cNum
            result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
                 & 'Not Investigated')
            IF (result /= PGS_S_SUCCESS) THEN
               msr = METAWR_ERR // attrName
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
            
d2152 3
@


1.36
log
@v1.4.3: Use int array for Date in Data Field
@
text
@d22 1
a22 1
  USE MLSStrings, only: utc_to_yyyymmdd
d32 1
a32 1
   "$Id: L3DMData.f90,v 1.35 2004/03/19 14:25:26 cvuu Exp $"
d2186 3
@


1.35
log
@Fix the RangeBeginningTime in metadata file
@
text
@d32 1
a32 1
   "$Id: L3DMData.f90,v 1.34 2004/01/08 21:25:44 cvuu Exp $"
d62 2
a63 2
     REAL(r8), DIMENSION(:,:,:), POINTER :: l3dmValue	  ! Field value
     REAL(r8), DIMENSION(:,:,:), POINTER :: l3dmPrecision ! Field precision
d66 1
a66 1
     REAL(r8), DIMENSION(:,:), POINTER :: latRss
d69 1
a69 1
     REAL(r8), DIMENSION(:,:), POINTER :: maxDiff
d72 1
a72 1
     REAL(r8), DIMENSION(:,:), POINTER :: maxDiffTime
d77 1
a77 1
     REAL(r8), DIMENSION(:), POINTER :: pressure	! dimensioned (nLevels)
d81 2
a82 2
     REAL(r8), DIMENSION(:), POINTER :: latitude	! dimensioned (nLats)
     REAL(r8), DIMENSION(:), POINTER :: longitude	! dimensioned (nLons)
d88 1
a88 1
     REAL(r8), DIMENSION(:), POINTER :: gRss
d91 1
a91 1
     INTEGER, DIMENSION(:), POINTER :: perMisPoints
d705 2
a706 2
      
      ! Detach from and close the grid interface.  
d708 1
a708 1
      ! properly the grid information within the file and must be done 
d710 1
a710 1
      
d716 1
a716 18
      
!      status = he5_gdclose(gdfID)
!      IF (status /= 0) THEN
!         msr = 'Failed to close file ' // TRIM(physicalFilename) // &
!              & ' after definition.'
!         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
!      ENDIF
      
      
      ! Re-open the file for writing
      
!      gdfID = he5_gdopen(trim(physicalFilename), HE5F_ACC_RDWR)
!      IF (gdfID == -1) THEN
!         msr = MLSMSG_Fileopen // TRIM(physicalFilename) // & 
!              & ' for writing grid data.'
!         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
!      ENDIF
      
d718 1
a718 1
      
a778 1

a1241 33
      ! Detach from the swath interface after definition

      status = he5_swdetach(swId)
      IF (status /= 0) THEN
         msr = 'Failed to detach from swath ' // TRIM(dgName) // &
              & ' after definition.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

!      status = he5_swclose(swfID)
!      IF (status /= 0) THEN
!         msr = 'Failed to close file ' // TRIM(physicalFilename) // &
!              & ' after writing.'
!         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
!      ENDIF
!      CALL MLSMessage(MLSMSG_Info, ModuleName, 'pass swclose')
                                                                                
!      swfID = he5_swopen(trim(physicalFilename), HE5F_ACC_RDWR)
                                                                                
!      IF (swfID == -1) THEN
!!jj         msr = MLSMSG_Fileopen // trim(physicalFilename) //' for writing swath'
!         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
!      ENDIF
 
      ! Re-attach to the swath for writing
      
      swId = he5_swattach(swfID, dgName)
      IF (swId == -1) THEN
         msr = 'Failed to re-attach to swath ' // TRIM(dgName) // & 
              & ' for writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
d1820 1
a1820 1
	! Set global attributes 
d1839 5
a1843 5
      if (result /= PGS_S_SUCCESS .and. WARNIFCANTPGSMETREMOVE) THEN 
         write(msr, *) result
         CALL MLSMessage (MLSMSG_Warning, ModuleName, &
              & "Calling pgs_met_remove() failed with value " // trim(msr) )
      endif
d2186 3
@


1.34
log
@Correct the day, month and doy in the global attribute
@
text
@d32 1
a32 1
   "$Id: L3DMData.f90,v 1.33 2004/01/07 21:43:18 cvuu Exp $"
d1808 5
a1812 4
         returnStatus = pgs_td_taiToUTC(l3cf%timeD(1), timeA)
         IF (returnStatus /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, &
              & ModuleName, TAI2A_ERR)
         sval = timeA(12:26)
d2237 3
@


1.33
log
@version 1.4 commit
@
text
@d22 1
d32 1
a32 1
   "$Id: L3DMData.f90,v 1.32 2003/09/15 18:29:41 cvuu Exp $"
d1443 2
d1827 1
d1869 11
a1879 1
                  
d2236 3
@


1.32
log
@Add OrbitNumber and OrbitPeriod to global attribute
@
text
@d31 1
a31 1
   "$Id: L3DMData.f90,v 1.31 2003/08/21 20:22:46 cvuu Exp $"
d159 1
a159 1
  SUBROUTINE OutputGrids(type, l3dmData, l3dmFiles, hdfVersion)
d176 2
d179 1
a179 1
       call OutputGrids_HE5(type, l3dmData, l3dmFiles)
d327 1
a327 1
       status = gddeffld(gdId, GEO_FIELD3, DIMT_NAME, DFNT_FLOAT64, &
d514 1
a514 1
 SUBROUTINE OutputGrids_HE5(type, l3dmData, l3dmFiles)
d533 3
a535 1
   
d573 1
a573 1
      
d581 7
a587 2
      
      gdfID = he5_gdopen(physicalFilename, HE5F_ACC_TRUNC)
d716 6
a721 6
      status = he5_gdclose(gdfID)
      IF (status /= 0) THEN
         msr = 'Failed to close file ' // TRIM(physicalFilename) // &
              & ' after definition.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d726 6
a731 6
      gdfID = he5_gdopen(trim(physicalFilename), HE5F_ACC_RDWR)
      IF (gdfID == -1) THEN
         msr = MLSMSG_Fileopen // TRIM(physicalFilename) // & 
              & ' for writing grid data.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d844 1
d875 1
a875 1
      INTEGER :: swfID, swId, status
d928 1
a928 1
      status = swdefgfld(swId, GEO_FIELD3, DIMT_NAME, DFNT_FLOAT64, & 
d970 1
a970 1
      status = swdefdfld(swId, MDT_FIELD, DIMNL_NAME, DFNT_FLOAT64, & 
a1085 1
         
d1146 1
a1146 1
      INTEGER :: status
d1246 1
a1246 1
           & HE5T_NATIVE_DOUBLE, HDFE_NOMERGE)
d1268 7
a1274 7
      status = he5_swclose(swfID)
      IF (status /= 0) THEN
         msr = 'Failed to close file ' // TRIM(physicalFilename) // &
              & ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      CALL MLSMessage(MLSMSG_Info, ModuleName, 'pass swclose')
d1276 1
a1276 1
      swfID = he5_swopen(trim(physicalFilename), HE5F_ACC_RDWR)
d1278 4
a1281 4
      IF (swfID == -1) THEN
         msr = MLSMSG_Fileopen // trim(physicalFilename) //' for writing swath'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1354 1
a1354 1
         
d1377 2
a1378 1
              & real(dg%maxDiffTime) )
d1459 1
a1459 1
      CHARACTER (LEN=132)                   :: list
d1467 2
a1468 2
      INTEGER :: hdfReturn, i, j, indx, len, numGrids, result, sdid, &  
           & returnStatus, MyHDFVersion
d1546 1
a1546 1
            numGrids = he5_gdinqgrid(files%name(i), list, len)
d1556 3
a1558 1
         
d1568 2
a1569 1
               gridName = list
d1571 1
a1571 1
            
d2222 3
@


1.31
log
@Remove testing print statements
@
text
@d31 1
a31 1
   "$Id: L3DMData.f90,v 1.30 2003/08/18 17:03:59 cvuu Exp $"
d1411 2
a1412 1
  USE PCFHdr, ONLY: WritePCF2Hdr, WriteInputPointer, he5_writeglobalattr
d1415 2
a1416 1
     & PGS_S_SUCCESS, PGSMET_E_MAND_NOT_SET, WARNIFCANTPGSMETREMOVE
d1642 1
a1642 1
         
d1645 9
a1653 1
         result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 99999)
d1661 8
a1668 1
         result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 99999)
d1856 1
a1856 1
          call he5_writeglobalattr(sdid)
d2209 3
@


1.30
log
@Add close and open in outputDiags_he5
@
text
@d31 1
a31 1
   "$Id: L3DMData.f90,v 1.29 2003/08/11 23:29:09 cvuu Exp $"
d1136 1
a1136 1
      INTEGER (HID_T) :: swfID, swId, status
a1267 2
      msr = msr1 //'swopen'
      CALL MLSMessage(MLSMSG_Info, ModuleName, msr)
a1272 1
      CALL MLSMessage(MLSMSG_Info, ModuleName, 'pass open here')
d2192 3
@


1.29
log
@brought closer to James Johnson want to
@
text
@d31 1
a31 1
   "$Id: L3DMData.f90,v 1.28 2003/07/08 00:18:09 pwagner Exp $"
d1136 2
a1137 1
      INTEGER :: swfID, swId, status
d1258 19
a1276 1
      
d2195 3
@


1.28
log
@fileType now a lit_name instead of a char string
@
text
@d31 1
a31 1
   "$Id: L3DMData.f90,v 1.27 2003/06/03 20:45:29 pwagner Exp $"
d1614 10
a1623 7
         
         attrName = 'OrbitNumber' // '.1'
         result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
         IF (result /= PGS_S_SUCCESS) THEN
            msr = METAWR_ERR // attrName
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
d1626 2
a1627 1
         result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
d1634 2
a1635 1
         result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, -1)
d2176 3
@


1.27
log
@Writes global attributes
@
text
@d31 1
a31 1
   "$Id: L3DMData.f90,v 1.26 2003/06/02 23:45:15 pwagner Exp $"
d1392 1
d1433 2
a1434 1
      CHARACTER (LEN=2)                     :: fileType
d1458 1
a1458 1
      fileType = 'gd'
d1667 1
a1667 1
           & fileType='hdfeos')
d2171 3
@


1.26
log
@metadata chnages: OrbitNumber now -1; equatorCrossingDate now utc start date
@
text
@d31 1
a31 1
   "$Id: L3DMData.f90,v 1.25 2003/05/30 23:52:42 pwagner Exp $"
d1391 1
d1394 1
a1394 1
  USE PCFHdr, ONLY: WritePCF2Hdr, WriteInputPointer
d1813 6
d1827 1
d2169 3
@


1.25
log
@Relies on lib/PCFHdr to WriteInputPointer
@
text
@d31 1
a31 1
   "$Id: L3DMData.f90,v 1.24 2003/04/30 18:15:48 pwagner Exp $"
d1613 1
a1613 1
         result = pgs_met_setAttr_i(groups(INVENTORYMETADATA), attrName, 999)
d1651 2
a1652 1
              & '1899-04-29')
d2161 3
@


1.24
log
@Work-around for LF95 infinite compile-time bug
@
text
@d1 1
a1 2

! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
d31 1
a31 1
   "$Id: L3DMData.f90,v 1.23 2003/04/08 20:26:46 pwagner Exp $"
d1393 1
a1393 1
  USE PCFHdr, ONLY: WritePCF2Hdr
d1660 4
a1663 2
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, &
              & 'See the PCF annotation to this file.')
d2160 3
@


1.23
log
@Snipped intraline continuation character to appease Lahey
@
text
@a8 6
  USE HDF, ONLY: DFACC_RDWR, DFNT_FLOAT64, DFNT_FLOAT32, DFNT_INT32, & 
       & DFACC_WRITE
  USE HDF5, ONLY: HID_T
  USE HDFEOS5, ONLY: HE5T_NATIVE_FLOAT, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE, &
       & HE5F_ACC_RDWR, HE5F_ACC_TRUNC 
  USE HE5_SWAPI
a10 1
  USE MLSFiles, ONLY: HDFVERSION_5, HDFVERSION_4, mls_sfstart, mls_sfend
a22 9
  USE MLSPCF3, ONLY: mlspcf_l3dm_start, mlspcf_l3dm_end
  USE MLSStrings, ONLY: LinearSearchStringArray
  USE OpenInit, ONLY: PCFData_T
  USE PCFHdr, ONLY: WritePCF2Hdr
  USE PCFModule, ONLY: ExpandFileTemplate, FindFileDay 
  USE SDPToolkit, ONLY: PGSd_MET_NUM_OF_GROUPS, PGSd_MET_GROUP_NAME_L, & 
       & PGS_S_SUCCESS, PGSMET_E_MAND_NOT_SET, pgs_td_taiToUTC, &
       & WARNIFCANTPGSMETREMOVE
  USE SWAPI
d24 3
a26 1
  PUBLIC
d32 1
a32 1
   "$Id: L3DMData.f90,v 1.22 2003/03/22 02:13:20 jdone Exp $"
a40 1
!                OutputDiags
d51 2
a52 2
   CHARACTER (LEN=*), PARAMETER :: DATA_FIELDV = 'L3dmValue'
   CHARACTER (LEN=*), PARAMETER :: DATA_FIELDP = 'L3dmPrecision'
d162 1
d190 5
d516 6
d843 2
d1113 3
d1390 8
d2159 3
@


1.22
log
@added HDFEOS5/HDFEOS2 capability
@
text
@d46 1
a46 1
   "$Id: L3DMData.f90,v 1.21 2003/03/15 00:16:38 pwagner Exp $"
d1198 1
a1198 1
           & HE5T_NATIVE_FLOAT, & HDFE_NOMERGE)
d2149 3
@


1.21
log
@May warn if pgs_met_remove returns non-zero value
@
text
@d5 1
a5 1
!===============================================================================
d7 1
a7 1
!===============================================================================
d9 32
a40 12
   USE Hdf
   USE MLSCommon
   USE MLSL3Common
   USE MLSMessageModule
   USE MLSPCF3
   USE MLSStrings
   USE OpenInit
   USE PCFHdr
   USE PCFModule
   USE SDPToolkit, only: WARNIFCANTPGSMETREMOVE
   IMPLICIT NONE
   PUBLIC
d42 1
a42 1
   PRIVATE :: ID, ModuleName
d46 1
a46 1
   "$Id: L3DMData.f90,v 1.20 2002/04/10 22:00:34 jdone Exp $"
d75 14
a88 4
     INTEGER :: nLevels			! Total number of surfaces
     INTEGER :: nLats			! Total number of latitudes
     INTEGER :: nLons			! Total number of longitudes
     INTEGER :: N			! number for "largest differences" diagnostics
a100 6
     ! Now the data fields:

     REAL(r8), DIMENSION(:,:,:), POINTER :: l3dmValue	  ! Field value
     REAL(r8), DIMENSION(:,:,:), POINTER :: l3dmPrecision ! Field precision
	! dimensioned as (nLevels, nLats, nLons)

a105 9
     REAL(r8), DIMENSION(:,:), POINTER :: latRss
	! Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)

     REAL(r8), DIMENSION(:,:), POINTER :: maxDiff
	! Maximum difference, dimensioned (N, nLevels)

     REAL(r8), DIMENSION(:,:), POINTER :: maxDiffTime
	! Time of maximum differences, dimensioned (N, nLevels)

d109 5
d174 26
a199 12
!---------------------------------------------------
   SUBROUTINE OutputGrids(type, l3dmData, l3dmFiles)
!---------------------------------------------------

! Brief description of subroutine
! This subroutine creates and writes to the grid portion of the l3dm files.

! Arguments

      CHARACTER (LEN=*), INTENT(IN) :: type

      TYPE (L3DMData_T), INTENT(IN) :: l3dmData(:)
d201 14
a214 1
      TYPE (OutputFiles_T), INTENT(INOUT) :: l3dmFiles
d216 1
a216 1
! Parameters
d218 1
a218 1
! Functions
d220 229
a448 83
      INTEGER, EXTERNAL :: gdattach, gdclose, gdcreate, gddefdim, gddeffld
      INTEGER, EXTERNAL :: gddefproj, gddetach, gdopen, gdwrfld

! Variables

      CHARACTER (LEN=8) :: date
      CHARACTER (LEN=FileNameLen) :: physicalFilename
      CHARACTER (LEN=480) :: msr

      INTEGER :: gdfID, gdId, i, match, status
      INTEGER :: start(3), stride(3), edge(3)

      REAL :: maxLat, maxLon, minLat, minLon

      REAL(r8) :: uplft(2), lowrgt(2)
      REAL(r8) :: projparm(13)

! For each day in the l3dm database,

      DO i = 1, SIZE(l3dmData)

! Find the output file for the level/species/day in the PCF

         CALL FindFileDay(type, l3dmData(i)%time, mlspcf_l3dm_start, &
                          mlspcf_l3dm_end, match, physicalFilename, date)
         IF (match == -1) THEN
            msr = 'No ' // TRIM(type) // ' file found in the PCF for day ' // &
                  date
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF


! Check whether the name is distinct; if so, save it in l3dmFiles

         IF (LinearSearchStringArray(l3dmFiles%name,physicalFilename) == 0) THEN
            l3dmFiles%nFiles = l3dmFiles%nFiles+1
            l3dmFiles%name(l3dmFiles%nFiles) = physicalFilename
            l3dmFiles%date(l3dmFiles%nFiles) = date
         ENDIF

! Open the output file

         gdfID = gdopen(physicalFilename, DFACC_RDWR)
         IF (gdfID == -1) THEN
            msr = MLSMSG_Fileopen // physicalFilename
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF


! Set up the grid.  The region is bounded by 180.0W to 176.0E longitude &
! varying latitude.  Grid into 90 bins along the x-axis, by nLats bins along
! the y-axis (4x2 bins).  Upper Left & Lower Right corners in DDDMMMSSS.ss.

         projparm = 0.0

! Find boundaries of measured latitude, upper bound of measure longitude

         maxLat = MAXVAL( l3dmData(i)%latitude )
         minLat = MINVAL( l3dmData(i)%latitude )
         maxLon = MAXVAL( l3dmData(i)%longitude )
         minLon = MINVAL( l3dmData(i)%longitude )

! Convert to "packed degree format"

         CALL ConvertDeg2DMS(maxLat, uplft(2))
         CALL ConvertDeg2DMS(minLat, lowrgt(2))
         CALL ConvertDeg2DMS(maxLon, lowrgt(1))
         CALL ConvertDeg2DMS(minLon, uplft(1))

! Create the grid


         gdId = gdcreate(gdfID, l3dmData(i)%name, l3dmData(i)%nLons, &
                         l3dmData(i)%nLats, uplft, lowrgt)
         IF (gdId == -1) THEN
            msr = 'Failed to create grid ' // l3dmData(i)%name
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the dimensions


         status = gddefdim(gdId, DIMX_NAME, l3dmData(i)%nLons)
d450 2
a451 1
            msr = DIM_ERR // DIMX_NAME
d454 6
a459 3


         status = gddefdim(gdId, DIMY_NAME, l3dmData(i)%nLats)
d461 2
a462 1
            msr = DIM_ERR // DIMY_NAME
d465 8
a472 3


         status = gddefdim(gdId, DIMZ_NAME, l3dmData(i)%nLevels)
d474 2
a475 1
            msr = DIM_ERR // DIMZ_NAME
d478 3
a480 3


         status = gddefdim(gdId, DIMT_NAME, 1)
d482 2
a483 1
            msr = DIM_ERR // DIMT_NAME
d486 4
d491 28
d520 7
a526 1
! Define a "Geographic projection," using defaults in all unneeded fields
d528 83
d612 8
a619 5
         status = gddefproj(gdId, GCTP_GEO, 0, 0, projparm)
         IF (status /= 0) THEN
            msr = 'Failed to define projection for grid ' // l3dmData(i)%name
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
d621 123
a743 1
! Define the "geolocation" fields
d745 14
a758 104
         status = gddeffld(gdId, GEO_FIELD3, DIMT_NAME, DFNT_FLOAT64, &
                           HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELD3
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = gddeffld(gdId, GEO_FIELD9, DIMZ_NAME, DFNT_FLOAT32, &
                           HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELD9
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = gddeffld(gdId, GEO_FIELD1, DIMY_NAME, DFNT_FLOAT32, &
                           HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELD1
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = gddeffld(gdId, GEO_FIELD2, DIMX_NAME, DFNT_FLOAT32, &
                           HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELD2
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF


! Define the "data" fields

         status = gddeffld(gdId, DATA_FIELDV, DIMXYZ_NAME, DFNT_FLOAT32, &
                           HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = DAT_ERR // DATA_FIELDV
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = gddeffld(gdId, DATA_FIELDP, DIMXYZ_NAME, DFNT_FLOAT32, &
                           HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = DAT_ERR // DATA_FIELDP
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Detach from and close the grid interface.  This step is necessary to store
! properly the grid information within the file and must be done before writing
! or reading data to or from the grid.

         status = gddetach(gdId)
         IF (status /= 0) THEN
            msr = GD_ERR // TRIM( l3dmData(i)%name ) // ' after definition.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = gdclose(gdfID)
         IF (status /= 0) THEN
            msr = 'Failed to close file ' // TRIM(physicalFilename) // &
                  ' after definition.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF


! Re-open the file for writing

         gdfID = gdopen(physicalFilename, DFACC_RDWR)
         IF (gdfID == -1) THEN
            msr = MLSMSG_Fileopen // TRIM(physicalFilename) // ' for writing.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Re-attach to the grid for writing

         gdId = gdattach(gdfID, l3dmData(i)%name)
         IF (gdId == -1) THEN
            msr = 'Failed to attach to grid ' // l3dmData(i)%name
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Write to fields

         start = 0
         stride = 1
         edge = 1


         status = gdwrfld(gdId, GEO_FIELD3, start(1), stride(1), edge(1), &
                          l3dmData(i)%time)

         IF (status /=0) THEN
            msr = 'Failed to write field ' //  GEO_FIELD3 // ' to grid ' &
                   // l3dmData(i)%name
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF


         edge(1) = l3dmData(i)%nLevels
         edge(2) = l3dmData(i)%nLats
         edge(3) = l3dmData(i)%nLons

         if (l3dmData(i)%nLevels.gt.0) then

         status = gdwrfld( gdId, GEO_FIELD9, start(1), stride(1), edge(1), &
                           REAL(l3dmData(i)%pressure) )
d761 1
a761 1
                  // l3dmData(i)%name
d764 7
a770 7

         endif

         if (l3dmData(i)%nLats.gt.0) then

         status = gdwrfld( gdId, GEO_FIELD1, start(2), stride(2), edge(2), &
                           REAL(l3dmData(i)%latitude) )
d773 1
a773 1
                  // l3dmData(i)%name
d776 6
a781 6

         endif

         if (l3dmData(i)%nLons.gt.0) then
         status = gdwrfld( gdId, GEO_FIELD2, start(3), stride(3), edge(3), &
                           REAL(l3dmData(i)%longitude) )
d784 1
a784 1
                   // l3dmData(i)%name
d787 3
d791 5
a795 7
         endif


         if ((l3dmData(i)%nLons.gt.0).and.(l3dmData(i)%nLats.gt.0).and.(l3dmData(i)%nLevels.gt.0)) then

         status = gdwrfld( gdId, DATA_FIELDV, start, stride, edge, &
                           REAL(l3dmData(i)%l3dmValue) )
d798 1
a798 1
                  // l3dmData(i)%name
d801 3
a803 3

         status = gdwrfld( gdId, DATA_FIELDP, start, stride, edge, &
                           REAL(l3dmData(i)%l3dmPrecision) )
d806 1
a806 1
                  // l3dmData(i)%name
d809 1
a809 1

d811 1
a811 1

d813 2
a814 2

         status = gddetach(gdId)
d819 1
a819 1

d821 2
a822 2

         status = gdclose(gdfID)
d825 1
a825 1
                  ' after writing.'
d828 3
a830 4


         msr = 'Grid ' // TRIM(l3dmData(i)%name) // ' successfully written to &
               &file ' // physicalFilename
d832 5
a836 7

! Create & write to diagnostic swath


         CALL OutputDiags( physicalFilename, l3dmData(i) )


d838 12
d851 1
a851 12
!----------------------------
   END SUBROUTINE OutputGrids
!----------------------------

!----------------------------------------------
   SUBROUTINE OutputDiags(physicalFilename, dg)
!----------------------------------------------

! Brief description of subroutine
! This subroutine creates and writes to the diagnostic portion of the l3dm files.

! Arguments
d854 1
a854 1

d856 3
a858 3

! Parameters

d860 3
a862 8

! Functions

      INTEGER, EXTERNAL :: swattach, swclose, swcreate, swdefdfld, swdefdim
      INTEGER, EXTERNAL :: swdefgfld, swdetach, swopen, swwrfld

! Variables

d865 1
a865 2

      INTEGER :: swfID, swId, status, i, j
d867 1
d869 8
a876 3
! Re-open the file for the creation of diagnostic swaths

      swfID = swopen(physicalFilename, DFACC_RDWR)
d878 1
a878 1
         msr = MLSMSG_Fileopen // physicalFilename
d881 3
a883 3

! Create the swath

d885 1
a885 1

d888 1
a888 1
         msr = 'Failed to create swath ' // dgName
d891 3
a893 3

! Define the dimensions

d899 1
a899 1

d905 1
a905 1

d911 1
a911 1

d917 5
a921 4

! Define the "geolocation" fields using the above dimensions

      status = swdefgfld(swId, GEO_FIELD3, DIMT_NAME, DFNT_FLOAT64, HDFE_NOMERGE)
d926 3
a928 2

      status = swdefgfld(swId, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, HDFE_NOMERGE)
d933 3
a935 2

      status = swdefgfld(swId, GEO_FIELD1, DIML_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d940 3
a942 3

! Define the "data" fields

d948 3
a950 3


      status = swdefdfld(swId, DG_FIELD1, DIMLL_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d955 2
a956 2

      status = swdefdfld(swId, MD_FIELD, DIMNL_NAME, DFNT_FLOAT32, HDFE_NOMERGE)
d961 3
a963 2

      status = swdefdfld(swId, MDT_FIELD, DIMNL_NAME, DFNT_FLOAT64, HDFE_NOMERGE)
d968 1
a968 1

d974 3
a976 3

! Detach from the swath interface after definition

d980 1
a980 1
               ' after definition.'
d984 2
a985 2
! Re-attach to the swath for writing

d988 2
a989 1
         msr = 'Failed to re-attach to swath ' // TRIM(dgName) // ' for writing.'
d992 2
d995 1
a995 3
! Write to fields

      start = 0
d997 3
a999 3
      edge = 1

! Geolocation
d1001 1
a1001 2

       status = swwrfld(swId, GEO_FIELD3, start(1), stride(1), edge(1), dg%time)
d1003 1
a1003 1
         msr = WR_ERR //  GEO_FIELD3 // ' to swath ' // dgName
d1011 64
d1076 21
a1096 2
      status = swwrfld( swId, GEO_FIELD9, start(1), stride(1), edge(1), &
                        REAL(dg%pressure) )
d1098 2
a1099 1
         msr = WR_ERR //  GEO_FIELD9 // ' to swath ' // dgName
d1102 22
d1125 5
a1129 1
      endif 
d1131 7
a1137 1
      if (dg%nLats.gt.0) then
d1139 10
a1148 4
      status = swwrfld( swId, GEO_FIELD1, start(2), stride(2), edge(2), &
                        REAL(dg%latitude) )
      IF (status /= 0) THEN
         msr = WR_ERR //  GEO_FIELD1 // ' to swath ' // dgName
d1152 3
a1154 1
      endif
d1156 5
a1160 1
! One-dimensional data fields
d1162 1
a1162 1
      if (dg%nLevels.gt.0) then
d1164 19
a1182 3

      status = swwrfld( swId, DG_FIELD, start(1), stride(1), edge(1), &
                        REAL(dg%gRss) )
d1184 1
a1184 1
         msr = WR_ERR //  DG_FIELD // ' to swath ' // dgName
d1188 4
a1191 2
      status = swwrfld(swId, DG_FIELD2, start(1), stride(1), edge(1), &
                       dg%perMisPoints )
d1193 1
a1193 1
         msr = WR_ERR //  DG_FIELD2 // ' to swath ' // dgName
a1195 1
      endif
d1197 6
a1202 1
! Two-dimensional data fields
d1204 8
a1211 1
      if ((dg%nLevels.gt.0).and.(dg%nLats.gt.0)) then
d1213 23
a1235 1
      status = swwrfld( swId, DG_FIELD1, start, stride, edge, real(dg%latRss) )
d1237 1
a1237 1
         msr = WR_ERR //  DG_FIELD1 // ' to swath ' // dgName
d1241 6
a1246 4
      endif 

      edge(1) = dg%N
      edge(2) = dg%nLevels
d1248 1
a1248 1
      if ( (dg%N.gt.0).and.(dg%nLevels.gt.0) )  then
d1250 1
a1250 1
      status = swwrfld( swId, MD_FIELD, start, stride, edge, real(dg%maxDiff) )
d1252 11
a1262 1
         msr = WR_ERR //  MD_FIELD // ' to swath ' // dgName
d1265 2
d1268 5
a1272 1
      status = swwrfld( swId, MDT_FIELD, start, stride, edge, real(dg%maxDiffTime) )
d1274 4
a1277 2
      IF (status /= 0) THEN
         msr = WR_ERR //  MDT_FIELD // ' to swath ' // dgName
d1280 25
d1306 1
a1306 1
      endif
d1308 1
d1310 16
a1325 1
! Detach from the swath after writing
d1327 36
a1362 1
      status = swdetach(swId)
d1367 4
a1370 4

! Close the file after writing

      status = swclose(swfID)
d1373 1
a1373 1
               ' after writing.'
d1376 1
a1376 1

d1378 1
a1378 1
             physicalFilename
d1380 12
d1393 2
a1394 14
!----------------------------
   END SUBROUTINE OutputDiags
!----------------------------

!-----------------------------------------------------
   SUBROUTINE WriteMetaL3DM (pcf, l3cf, files, anText)
!-----------------------------------------------------

! Brief description of subroutine
! This routine writes the metadata for an l3dm file, and annotates it with the
! PCF.

! Arguments

d1396 1
a1396 1

d1398 1
a1398 1

d1400 1
a1400 1

d1403 5
a1407 1
! Parameters
d1409 3
a1411 1
! Functions
d1413 1
a1413 3
      INTEGER, EXTERNAL :: pgs_met_init, pgs_met_remove, pgs_met_setAttr_d
      INTEGER, EXTERNAL :: pgs_met_setAttr_i,pgs_met_setAttr_s, pgs_met_write
      INTEGER, EXTERNAL :: pgs_td_taiToUTC, gdinqgrid
d1415 11
a1425 1
! Variables
d1427 2
a1428 8
      CHARACTER (LEN=1) :: cNum
      CHARACTER (LEN=45) :: attrName
      CHARACTER (LEN=132) :: list
      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=CCSDS_LEN) :: timeA
      CHARACTER (LEN=FileNameLen) :: sval
      CHARACTER (LEN=GridNameLen) :: gridName
      CHARACTER (LEN=PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
d1430 1
a1430 1
      INTEGER :: hdfReturn, i, j, indx, len, numGrids, result, sdid, returnStatus
d1432 5
a1436 1
      REAL(r8) :: dval
d1438 1
a1438 1
! Initialize the MCF file
d1442 3
a1444 1
                           'Initialization error.  See LogStatus for details.')
d1446 1
a1446 1
! For each l3dm file successfully created,
d1448 2
d1451 2
d1454 7
a1460 8
! Open the HDF file and initialize the SD interface

         sdid = sfstart(files%name(i), DFACC_WRITE)
         IF (sdid == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
                                     &open the HDF file for metadata writing.')
 
! Set PGE values -- ECSDataGranule

d1463 1
a1463 1
                           'further update anticipated using enhanced PGE')
d1468 1
a1468 1

d1471 1
a1471 1
                                    'processed once')
d1476 1
a1476 1

d1485 1
a1485 1

d1487 1
a1487 1
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, 'Both')
d1492 1
a1492 1

d1500 2
d1503 5
a1507 1
! MeasuredParameterContainer -- find the number of grids in the file
d1509 1
a1509 2
         numGrids = gdinqgrid(files%name(i), list, len)
         IF (numGrids == -1) THEN
d1511 1
a1511 1
                  ' while attempting to write its metadata.'
d1514 3
a1516 3

! For each grid in the file

d1518 3
a1520 3

! Extract its name

d1528 4
a1531 3

! Append a class suffix to ParameterName, and write the grid name as its value

d1533 1
a1533 1

d1536 1
a1536 1
                                       gridName)
d1541 3
a1543 3

! QAFlags Group

d1546 1
a1546 1
                                       'Passed')
d1551 1
a1551 1

d1554 1
a1554 1
                                       'pending algorithm update')
d1559 1
a1559 1

d1562 1
a1562 1
                                       'Not Investigated')
d1570 1
a1570 1
                                              'Not Investigated')
d1575 3
a1577 3

! QAStats Group

d1584 1
a1584 1

d1598 1
a1598 1

d1600 3
a1602 3

! OrbitCalculatedSpatialDomainContainer

d1609 1
a1609 1

d1616 1
a1616 1

d1631 1
a1631 1

d1634 1
a1634 1
                                    '00:00:00')
d1639 1
a1639 1

d1642 1
a1642 1
                                    '1899-04-29')
d1648 2
a1649 2
! InputPointer

d1652 1
a1652 1
                                   'See the PCF annotation to this file.')
d1657 2
a1658 2

! Locality Value
d1662 1
a1662 1
                                    'Limb')
d1667 3
a1669 3

! VerticalSpatialDomain Product-Specific Attribute

d1672 1
a1672 1
                                    'Atmosphere Layer')
d1677 1
a1677 1

d1680 1
a1680 1
                                    'Atmosphere Profile')
d1685 3
a1687 3

! HorizontalSpatialDomainContainer

d1690 1
a1690 1
                                    'Other Grid System')
d1695 1
a1695 1

d1703 1
a1703 1

d1711 1
a1711 1

d1719 1
a1719 1

d1727 3
a1729 3

! RangeDateTime Group

d1732 1
a1732 1
                                     files%date(i) )
d1737 1
a1737 1

d1741 1
a1741 1
                                                            ModuleName, TAI2A_ERR)
d1748 1
a1748 1

d1751 1
a1751 1
                                     files%date(i) )
d1756 1
a1756 1

d1763 3
a1765 3

! PGEVersion

d1768 1
a1768 1
                                    pcf%outputVersion)
d1773 3
a1775 3

! Write the metadata and their values to HDF attributes

d1777 1
a1777 1
                                sdid)
d1780 2
a1781 2
               CALL MLSMessage(MLSMSG_Error, ModuleName, 'Some of the &
                               &mandatory metadata parameters were not set.')
d1783 2
a1784 2
              CALL MLSMessage(MLSMSG_Error, ModuleName, 'Metadata write &
                              &failed.')
d1787 2
d1790 2
a1791 3
! Terminate access to the SD interface and close the file

         hdfReturn = sfend(sdid)
d1793 7
a1799 8
                              'Error closing HDF file after writing metadata.')

! Annotate the file with the PCF


         CALL WritePCF2Hdr(files%name(i), anText)


d1804 4
a1807 4
        write(msr, *) result
        CALL MLSMessage (MLSMSG_Warning, ModuleName, &
              "Calling pgs_met_remove() failed with value " // trim(msr) )
      endif          
d1848 5
a1852 5
      ALLOCATE(l3dm%latitude(l3dm%nLats), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' latitude pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1858 5
a1862 5
      ALLOCATE(l3dm%longitude(l3dm%nLons), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' longitude pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1870 5
a1874 5
      ALLOCATE(l3dm%pressure(l3dm%nLevels), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' pressure pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1880 2
a1881 1
      if ((l3dm%nLevels.gt.0).and.(l3dm%nLats.gt.0).and.(l3dm%nLons.gt.0)) then 
d1883 5
a1887 5
      ALLOCATE(l3dm%l3dmValue(l3dm%nLevels,l3dm%nLats,l3dm%nLons), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' value pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1889 6
a1894 5
      ALLOCATE(l3dm%l3dmPrecision(l3dm%nLevels,l3dm%nLats,l3dm%nLons),STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' precision pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1902 5
a1906 5
      ALLOCATE(l3dm%gRss(l3dm%nLevels), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' gRss pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1912 5
a1916 5
      ALLOCATE(l3dm%latRss(l3dm%nLevels,l3dm%nLats),STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' latRss pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1922 5
a1926 5
      ALLOCATE(l3dm%maxDiff(l3dm%N,l3dm%nLevels),STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' maxDiff pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1928 5
a1932 5
      ALLOCATE(l3dm%maxDiffTime(l3dm%N,l3dm%nLevels),STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' maxDiffTime pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1937 6
a1942 6

      ALLOCATE(l3dm%perMisPoints(l3dm%nLevels), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' perMisPoints pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d1976 6
a1981 5
      IF ( ASSOCIATED(l3dm%latitude) ) THEN
         DEALLOCATE (l3dm%latitude, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  latitude pointer'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a1982 1
      ENDIF
d1988 6
a1993 5
      IF ( ASSOCIATED(l3dm%longitude) ) THEN
         DEALLOCATE (l3dm%longitude, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  longitude pointer'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a1994 1
      ENDIF
d1998 1
a1998 1
! Vertical geolocation field
d2002 6
a2007 5
      IF ( ASSOCIATED(l3dm%pressure) ) THEN
         DEALLOCATE (l3dm%pressure, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  pressure pointer'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a2008 1
      ENDIF
d2012 4
a2015 1
! Data fields
d2017 6
a2022 7
      if ((l3dm%nLevels.gt.0).and.(l3dm%nLats.gt.0).and.(l3dm%nLons.gt.0)) then 

      IF ( ASSOCIATED(l3dm%l3dmValue) ) THEN
         DEALLOCATE (l3dm%l3dmValue, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3dmValue pointer'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a2023 1
      ENDIF
d2025 6
a2030 5
      IF ( ASSOCIATED(l3dm%l3dmPrecision) ) THEN
         DEALLOCATE (l3dm%l3dmPrecision, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3dmPrecision'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a2031 1
      ENDIF
d2035 2
a2036 2
! Diagnostic fields

d2039 6
a2044 5
      IF ( ASSOCIATED(l3dm%gRss) ) THEN
         DEALLOCATE (l3dm%gRss, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  gRss pointer'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a2045 1
      ENDIF
d2050 7
a2056 6

      IF ( ASSOCIATED(l3dm%latRss) ) THEN
         DEALLOCATE (l3dm%latRss, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  latRss pointer'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a2057 1
      ENDIF
d2063 6
a2068 5
      IF ( ASSOCIATED(l3dm%maxDiff) ) THEN
         DEALLOCATE (l3dm%maxDiff, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  maxDiff pointer'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a2069 1
      ENDIF
d2071 6
a2076 5
      IF ( ASSOCIATED(l3dm%maxDiffTime) ) THEN
         DEALLOCATE (l3dm%maxDiffTime, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  maxDiffTime pointer'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a2077 1
      ENDIF
d2083 6
a2088 5
      IF ( ASSOCIATED(l3dm%perMisPoints) ) THEN
         DEALLOCATE (l3dm%perMisPoints, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  perMisPoints'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a2089 1
      ENDIF
d2094 1
a2094 1
   END SUBROUTINE DeallocateL3DM
d2098 1
a2098 1
   SUBROUTINE DestroyL3DMDatabase (l3dmdb)
d2141 1
a2141 1
   END SUBROUTINE DestroyL3DMDatabase
d2145 1
a2145 1
END MODULE L3DMData
d2149 3
@


1.20
log
@swwrfld edge values for time
@
text
@d18 1
a18 1
   USE SDPToolkit
d26 1
a26 1
   "$Id: L3DMData.f90,v 1.19 2002/04/01 21:58:49 jdone Exp $"
d1141 5
d1484 3
@


1.19
log
@check if array sizes are larger than 0
@
text
@d26 1
a26 1
   "$Id: L3DMData.f90,v 1.18 2002/03/27 21:33:32 jdone Exp $"
d204 1
d221 1
d244 1
d254 1
d261 1
d268 1
d275 1
d282 1
d285 1
d322 1
d356 1
d377 2
a378 3
         edge(1) = l3dmData(i)%nLevels
         edge(2) = l3dmData(i)%nLats
         edge(3) = l3dmData(i)%nLons
d380 1
a380 1
         status = gdwrfld(gdId, GEO_FIELD3, start(1), stride(1), stride(1), &
d382 1
d389 5
d429 1
d439 1
a439 1
 
d467 1
d474 1
d477 1
d586 1
d632 1
a632 2
      edge(1) = dg%nLevels
      edge(2) = dg%nLats
d636 2
a637 2
        
      status = swwrfld(swId, GEO_FIELD3, start(1), stride(1), stride(1), dg%time)
d643 3
d672 1
a685 1

d712 1
a712 1
!
d1179 2
d1187 4
d1197 2
d1201 2
d1209 2
d1213 2
d1227 2
d1231 2
d1239 4
d1249 4
d1265 4
d1275 2
d1305 2
d1315 4
d1327 2
d1331 2
d1341 2
d1345 2
d1363 2
d1367 2
d1377 4
d1389 4
d1409 4
d1421 2
d1479 3
@


1.18
log
@allocate statements checked and maxDiff is initialized
@
text
@d26 1
a26 1
   "$Id: L3DMData.f90,v 1.17 2001/12/13 20:47:50 nakamura Exp $"
d378 1
a378 1
         if ((associated(l3dmData(i)%pressure) ).and.(l3dmData(i)%nLevels.gt.0)) then
d390 1
a390 1
         if ((associated(l3dmData(i)%latitude) ).and.(l3dmData(i)%nLats.gt.0)) then
d402 1
a402 1
         if ((associated(l3dmData(i)%longitude) ).and.(l3dmData(i)%nLons.gt.0)) then
a414 1
         if (associated (l3dmData(i)%l3dmValue) ) then
a421 2

         endif
a422 2

         if (associated(l3dmData(i)%l3dmPrecision) ) then
a432 2
         endif

a493 1
	print *, 'OutputDiags'
d623 2
a624 1
      if ( associated(dg%pressure) ) then
d632 1
a632 1
      endif
d634 1
a634 1
      if ( associated(dg%latitude) ) then 
d647 1
a647 2

      if ( associated(dg%gRss) ) then
a655 4
      endif

      if ( associated(dg%perMisPoints) ) then

d667 1
a667 2

      if ( associated(dg%latRss) ) then
d675 1
a675 1
      endif
d680 1
a680 1
      if (( associated (dg%maxDiff) ).and.(dg%N.gt.0).and.(dg%nLevels.gt.0) )  then
a687 4
      endif

      if (( associated(dg%maxDiffTime) ).and.(dg%N.gt.0).and.(dg%nLevels.gt.0) ) then 

d689 1
a689 1

a1110 1
         if (associated (anText) ) then
a1113 1
         endif
d1392 3
@


1.17
log
@Removed unused subroutine ReadL3DMData; merged dg fields into L3DMData_T.
@
text
@d26 1
a26 1
   "$Id: L3DMData.f90,v 1.16 2001/11/26 19:24:20 nakamura Exp $"
d378 2
d388 4
d400 3
d411 5
d424 4
d436 4
d498 1
a498 1
      INTEGER :: swfID, swId, status
d501 1
d513 1
d624 1
d631 1
d639 4
d650 2
d654 3
d663 4
d675 2
d679 4
a682 1
      status = swwrfld( swId, DG_FIELD1, start, stride, edge, REAL(dg%latRss) )
d688 2
d692 4
a695 1
      status = swwrfld( swId, MD_FIELD, start, stride, edge, REAL(dg%maxDiff) )
d701 6
a706 1
      status = swwrfld( swId, MDT_FIELD, start, stride, edge, REAL(dg%maxDiffTime) )
d712 3
d1128 2
d1132 2
d1411 3
@


1.16
log
@Moved L3DMDiag_T to its own module.
@
text
@d26 1
a26 1
   "$Id: L3DMData.f90,v 1.15 2001/11/12 20:22:05 nakamura Exp $"
d35 1
a35 1
!                ReadL3DMData
d55 4
a58 3
     INTEGER :: nLevels				! Total number of surfaces
     INTEGER :: nLats				! Total number of latitudes
     INTEGER :: nLons				! Total number of longitudes
d77 17
d439 4
d449 3
a451 3
!-------------------------------------------------
   SUBROUTINE ReadL3DMData (gdfid, gridName, l3dm)
!-------------------------------------------------
d454 1
a454 1
! This  subroutine reads a grid from a file into the L3DMData structure.
d458 1
a458 1
      CHARACTER (LEN=*), INTENT(IN) :: gridName
d460 1
a460 3
      INTEGER, INTENT(IN) :: gdfid  

      TYPE( L3DMData_T ), INTENT(OUT) :: l3dm
d464 1
a464 1
      CHARACTER (LEN=*), PARAMETER :: RDGD_ERR = 'Failed to read grid field '
d468 2
a469 1
      INTEGER :: gdattach, gddetach, gddiminfo, gdrdfld
d474 41
d516 19
a534 2
      INTEGER :: err, gdid, nlev, nlat, nlon, size, status
      INTEGER :: start(3), stride(3), edge(3)
d536 5
a540 2
      REAL, ALLOCATABLE :: rp(:), rlat(:), rlon(:)
      REAL, ALLOCATABLE :: r3(:,:,:)
d542 1
a542 1
! Attach to the grid
d544 3
a546 3
      gdid = gdattach(gdfid, gridName)
      IF (gdId == -1) THEN
         msr = 'Failed to attach to grid ' // gridName
d550 5
a554 1
! Get dimension names, sizes
d556 3
a558 3
      size = gddiminfo(gdid, DIMX_NAME)
      IF (size == -1) THEN
         msr = SZ_ERR // DIMX_NAME
a560 1
      nlon = size
d562 3
a564 3
      size = gddiminfo(gdid, DIMY_NAME)
      IF (size == -1) THEN
         msr = SZ_ERR // DIMY_NAME
d567 4
a570 5
      nlat = size
      
      size = gddiminfo(gdid, DIMZ_NAME)
      IF (size == -1) THEN
         msr = SZ_ERR // DIMZ_NAME
a572 1
      nlev = size
d574 1
a574 1
! Allocate the local REAL variables & the output structure pointers
d576 4
a579 3
      ALLOCATE(rp(nlev), rlat(nlat), rlon(nlon), r3(nlev,nlat,nlon), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' local REAL variables.'
d583 1
a583 1
      CALL AllocateL3DM(nlev, nlat, nlon, l3dm)
d585 5
a589 1
! Read data into the output structure 
d591 1
a591 1
      l3dm%name = gridName
d595 4
a598 3
      edge(1) = l3dm%nLevels
      edge(2) = l3dm%nLats
      edge(3) = l3dm%nLons
d600 3
a602 4
      status = gdrdfld(gdid, GEO_FIELD3, start(1), stride(1), stride(1), &
                       l3dm%time)
      IF (status == -1) THEN
         msr = RDGD_ERR // GEO_FIELD3
d606 20
a625 3
      status = gdrdfld(gdid, GEO_FIELD9, start(1), stride(1), edge(1), rp)
      IF (status == -1) THEN
         msr = RDGD_ERR // GEO_FIELD9
a627 1
      l3dm%pressure = DBLE(rp)
d629 4
a632 3
      status = gdrdfld(gdid, GEO_FIELD1, start(2), stride(2), edge(2), rlat)
      IF (status == -1) THEN
         msr = RDGD_ERR // GEO_FIELD1
a634 1
      l3dm%latitude = DBLE(rlat)
d636 5
a640 3
      status = gdrdfld(gdid, GEO_FIELD2, start(3), stride(3), edge(3), rlon)
      IF (status == -1) THEN
         msr = RDGD_ERR // GEO_FIELD2
a642 1
      l3dm%longitude = DBLE(rlon)
d644 5
a648 3
      status = gdrdfld(gdid, DATA_FIELDV, start, stride, edge, r3)
      IF (status == -1) THEN
         msr = RDGD_ERR // DATA_FIELDV
a650 1
      l3dm%l3dmValue = DBLE(r3)
d652 3
a654 3
      status = gdrdfld(gdid, DATA_FIELDP, start, stride, edge, r3)
      IF (status == -1) THEN
         msr = RDGD_ERR // DATA_FIELDP
a656 1
      l3dm%l3dmPrecision = DBLE(r3)
d658 1
a658 1
! Detach from and close the grid interface
d660 3
a662 3
      status = gddetach(gdid)
      IF (status == -1) THEN
         msr = GD_ERR // TRIM(gridName) // ' after reading.'
d666 1
a666 1
! Deallocate the local variables
d668 4
a671 3
      DEALLOCATE (rp, rlat, rlon, r3, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  local REAL variables.'
d675 7
a681 3
!-----------------------------
   END SUBROUTINE ReadL3DMData
!-----------------------------
d1081 3
a1083 3
!--------------------------------------------------
   SUBROUTINE AllocateL3DM (nlev, nlat, nlon, l3dm)
!--------------------------------------------------
d1091 1
a1091 1
      INTEGER, INTENT(IN) :: nlev, nlat, nlon
d1110 1
d1116 1
a1116 1
         msr = MLSMSG_Allocate // ' L3DMData_T latitude pointer.'
d1122 1
a1122 1
         msr = MLSMSG_Allocate // ' L3DMData_T longitude pointer.'
d1130 1
a1130 1
         msr = MLSMSG_Allocate // ' L3DMData_T pressure pointer.'
d1138 1
a1138 1
         msr = MLSMSG_Allocate // ' L3DMData_T value pointer.'
d1144 33
a1176 1
         msr = MLSMSG_Allocate // ' L3DMData_T precision pointer.'
d1211 1
a1211 1
            msr = MLSMSG_DeAllocate // '  l3dm latitude pointer'
d1219 1
a1219 1
            msr = MLSMSG_DeAllocate // '  l3dm longitude pointer'
d1229 1
a1229 1
            msr = MLSMSG_DeAllocate // '  l3dm pressure pointer'
d1252 42
d1350 3
@


1.15
log
@Added pressure & lat to L3DMDiag_T.
@
text
@d26 1
a26 1
   "$Id: L3DMData.f90,v 1.14 2001/10/05 20:16:25 nakamura Exp $"
d32 1
a32 2
! Definitions -- L3DMData_T
!                L3DMDiag_T
a77 36
! This data type is used to store the l3 daily map diagnostics.

   TYPE L3DMDiag_T

     CHARACTER (LEN=GridNameLen) :: name        ! name for the output quantity

     INTEGER :: N		! number for "largest differences" diagnostics
     INTEGER :: nLevels		! Total number of surfaces
     INTEGER :: nLats		! Total number of latitudes

     ! Now we store the geolocation fields.  First, the vertical one:

     REAL(r8), DIMENSION(:), POINTER :: pressure	! dimensioned (nLevels)

     ! Now the horizontal geolocation information:

     REAL(r8), DIMENSION(:), POINTER :: latitude	! dimensioned (nLats)

     ! Global Root-Sum_Square, dimensioned (nLevels)

     REAL(r8), DIMENSION(:), POINTER :: gRss

     ! Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)

     REAL(r8), DIMENSION(:,:), POINTER :: latRss

     ! Maximum difference, dimensioned (N, nLevels)

     REAL(r8), DIMENSION(:,:), POINTER :: maxDiff

     ! Missing points (percentage), dimensioned (nLevels)

     INTEGER, DIMENSION(:), POINTER :: perMisPoints

   END TYPE L3DMDiag_T

d1165 3
@


1.14
log
@Added L3DMDiag_T.
@
text
@d26 1
a26 1
   "$Id: L3DMData.f90,v 1.13 2001/07/18 15:54:37 nakamura Exp $"
d89 8
d1202 3
@


1.13
log
@Gets metadata time from l3cf, rather than hard-coded to noon.
@
text
@d26 1
a26 1
   "$Id: L3DMData.f90,v 1.12 2001/05/04 18:30:01 nakamura Exp $"
d32 2
a33 1
! Definition -- L3DMData_T
d79 28
d935 1
a935 1
                                                     ModuleName, TAI2A_ERR)
d1194 3
@


1.12
log
@Removed L3DMFiles_T and used generic OutputFiles_T.
@
text
@d26 1
a26 1
   "$Id: L3DMData.f90,v 1.11 2001/04/24 19:38:23 nakamura Exp $"
d597 1
a597 1
      INTEGER, EXTERNAL :: gdinqgrid
d605 1
d610 1
a610 1
      INTEGER :: hdfReturn, i, j, indx, len, numGrids, result, sdid
d904 4
a907 1
         sval = '12:00:00.000000'
d1165 3
@


1.11
log
@Removed references to private L2 parameters.
@
text
@d26 1
a26 1
   "$Id: L3DMData.f90,v 1.10 2001/03/27 19:28:15 nakamura Exp $"
d32 1
a32 2
! Definitions -- L3DMData_T
!                L3DMFiles_T 
a77 13
! This data type is used to store the names of l3dm files actually created.

   TYPE L3DMFiles_T

     INTEGER :: nFiles		! number of distinct l3dm output files created

     CHARACTER (LEN=FileNameLen) :: name(maxwindow)
	! array of names of the created files

     CHARACTER (LEN=8) :: date(maxWindow)	! CCSDS B format dates of files

   END TYPE L3DMFiles_T

d149 1
a149 1
      TYPE (L3DMFiles_T), INTENT(INOUT) :: l3dmFiles
d186 1
a186 1
! Check whether the name is distinct; if so, save it in L3DMFiles_T
d585 1
a585 1
      TYPE (L3DMFiles_T), INTENT(IN) :: files
d1161 3
@


1.10
log
@Moved some parameters to MLSL3Common; updated metadata; fixed err checks on deallocate.
@
text
@a9 2
   USE L2GPData, ONLY: L2GPNameLen, GEO_FIELD1, GEO_FIELD2, GEO_FIELD3, &
                       GEO_FIELD9, HDFE_NOMERGE
d26 1
a26 1
   "$Id: L3DMData.f90,v 1.9 2001/02/21 20:57:12 nakamura Exp $"
d54 1
a54 1
     CHARACTER (LEN=L2GPNameLen) :: name	! name for the output quantity
d1175 3
@


1.9
log
@Changed MLSPCF to MLSPCF3; made some parameters global; added ReadL3DMData; changed InputPointer.
@
text
@d18 1
d28 1
a28 1
   "$Id: L3DMData.f90,v 1.12 2001/02/14 21:26:45 nakamura Exp nakamura $"
a48 3
   CHARACTER (LEN=*), PARAMETER :: DIMX_NAME = 'XDim'
   CHARACTER (LEN=*), PARAMETER :: DIMY_NAME = 'YDim'
   CHARACTER (LEN=*), PARAMETER :: DIMZ_NAME = 'ZDim'
a50 1
   CHARACTER (LEN=*), PARAMETER :: GD_ERR = 'Failed to detach from grid '
a168 4
      CHARACTER (LEN=*), PARAMETER :: DIMXYZ_NAME = 'ZDim,YDim,XDim'

      INTEGER, PARAMETER :: GCTP_GEO = 0

a665 2
         indx = INDEX(sval, '.', .TRUE.)
         sval = sval(:indx-1)
d680 1
a680 2
         CALL ExpandFileTemplate('$version-$cycle', sval, &
                                 version=pcf%outputVersion, cycle=pcf%cycle)
d734 1
a734 1
                                       'TBD')
d750 1
a750 1
                                              'TBD')
d1077 6
a1082 4
      IF ( ASSOCIATED(l3dm%latitude) ) DEALLOCATE (l3dm%latitude, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3dm latitude pointer'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1085 6
a1090 4
      IF ( ASSOCIATED(l3dm%longitude) ) DEALLOCATE (l3dm%longitude, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3dm longitude pointer'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1095 6
a1100 4
      IF ( ASSOCIATED(l3dm%pressure) ) DEALLOCATE (l3dm%pressure, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3dm pressure pointer'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1105 6
a1110 4
      IF ( ASSOCIATED(l3dm%l3dmValue) ) DEALLOCATE (l3dm%l3dmValue, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3dmValue pointer'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1113 6
a1118 5
      IF ( ASSOCIATED(l3dm%l3dmPrecision) ) DEALLOCATE (l3dm%l3dmPrecision, &
                                                        STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3dmPrecision'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1177 3
@


1.8
log
@Moved DIMT to MLSL3Common; changed LocalGranuleID to file - .dat
@
text
@d15 1
a15 1
   USE MLSPCF
d27 1
a27 1
   "$Id: L3DMData.f90,v 1.7 2001/01/16 17:44:00 nakamura Exp $"
d37 1
d48 7
a81 3
!    REAL(r8), DIMENSION(:,:), POINTER :: l3dmColumn	! Column data
	! dimensioned as (nLats, nLons)

a171 3
      CHARACTER (LEN=*), PARAMETER :: DIMX_NAME = 'XDim'
      CHARACTER (LEN=*), PARAMETER :: DIMY_NAME = 'YDim'
      CHARACTER (LEN=*), PARAMETER :: DIMZ_NAME = 'ZDim'
a172 4
      CHARACTER (LEN=*), PARAMETER :: DATA_FIELDV = 'L3dmValue'
      CHARACTER (LEN=*), PARAMETER :: DATA_FIELDP = 'L3dmPrecision'

      CHARACTER (LEN=*), PARAMETER :: GD_ERR = 'Failed to detach from grid '
d190 1
a190 1
      REAL :: maxLat, maxLon, minLat
a228 2
         uplft(1) = -180000000.00

d236 1
d243 1
d450 146
d625 1
a625 3
      CHARACTER (LEN=12) :: shortName
      CHARACTER (LEN=45) :: attrName, sval
      CHARACTER (LEN=80) :: identifier
d628 1
a628 1
      CHARACTER (LEN=FileNameLen) :: type
a839 7
         indx = INDEX(l3cf%mcfName, '.', .TRUE.)
         shortName = l3cf%mcfName(:indx-1)
         indx = INDEX(shortName, '.')
         shortName = shortName(:indx-1) // ':' // shortName(indx+1:)
         CALL ExpandFileTemplate(l3cf%fileTemplate, type, 'L2GP')
         identifier = TRIM(type) // files%date(i)
         sval = 'LGID:' // TRIM(shortName) // ':' // TRIM(identifier)
d841 2
a842 1
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), attrName, sval)
d1157 1
a1157 1
         END DO
d1178 3
@


1.7
log
@Made lowrgt corner of the grid variable; updated WriteMetaL3DM for new MCF and added writing of annotation.
@
text
@d27 1
a27 1
   "$Id: L3DMData.f90,v 1.9 2001/01/12 17:57:53 nakamura Exp nakamura $"
a169 1
      CHARACTER (LEN=*), PARAMETER :: DIMT_NAME = 'TDim'
d529 4
a532 2
         CALL ExpandFileTemplate(l3cf%fileTemplate, type, 'L3DM')
         sval = TRIM(type) // files%date(i)
d1042 3
@


1.6
log
@Moved global parameters to MLSL3Common; added L3DMFiles_T; switched to one-product/all-days paradigm.
@
text
@d17 1
d27 1
a27 1
   "$Id: L3DMData.f90,v 1.8 2000/12/28 21:26:50 nakamura Exp nakamura $"
d88 1
a88 1
     CHARACTER (LEN=8) :: date(maxWindow)	! CCSDS B format date of files
d193 1
a193 1
      REAL :: maxLat, minLat
d228 2
a229 2
! Set up the grid.  The region is bounded by 180.0W to 180.0E longitude &
! varying latitude.  Grid into 91 bins along the x-axis, by nLats bins along
a232 1
         lowrgt(1) = 180000000.00
d236 1
a236 1
! Find boundaries of measured latitude
d240 1
d246 1
d453 3
a455 3
!----------------------------------------------
   SUBROUTINE WriteMetaL3DM (files, mlspcf_mcf)
!----------------------------------------------
d458 2
a459 1
! This routine writes the metadata for an l3dm file.
d463 2
d467 3
a469 1
      INTEGER, INTENT(IN) :: mlspcf_mcf
d476 2
a477 1
      INTEGER, EXTERNAL :: pgs_met_setAttr_s, pgs_met_write
d481 8
a488 5
      CHARACTER (LEN=10) :: date
      CHARACTER (LEN=15) :: time
      CHARACTER (LEN=21) :: sType, zoneID
      CHARACTER (LEN=32) :: mnemonic
      CHARACTER (LEN=480) :: msg, msr
d491 1
a491 1
      INTEGER :: hdfReturn, i, result, sdid
d493 1
a493 1
      REAL(r8) :: maxLat, maxLon, minLat, minLon
d497 1
a497 1
      result = pgs_met_init(mlspcf_mcf, groups)
a500 10
! Set nominal values for the overall file

      sType = 'Horizontal & Vertical'
      time = '12:00:00.000000'
      zoneID = 'Other Grid System'
      minLon = -180.0
      maxLat = 82.0
      maxLon = 180.0
      minLat = -82.0

d511 1
a511 1
! Set PGE values
d513 3
a515 2
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                   "GranuleSpatialDomainType", sType)
d517 1
a517 2
            call Pgs_smf_getMsg(result, mnemonic, msg)
            msr = mnemonic // ':  ' // msg
d521 3
a523 3
         date = files%date(i)
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                   "RangeBeginningDate", date)
d525 1
a525 2
            call Pgs_smf_getMsg(result, mnemonic, msg)
            msr = mnemonic // ':  ' // msg
d529 4
a532 2
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                   "RangeBeginningTime", time)
d534 1
a534 2
            call Pgs_smf_getMsg(result, mnemonic, msg)
            msr = mnemonic // ':  ' // msg
d538 2
a539 2
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                   "RangeEndingDate", date)
d541 1
a541 2
            call Pgs_smf_getMsg(result, mnemonic, msg)
            msr = mnemonic // ':  ' // msg
d545 4
a548 2
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                   "RangeEndingTime", time)
d550 10
a559 2
            call Pgs_smf_getMsg(result, mnemonic, msg)
            msr = mnemonic // ':  ' // msg
d563 96
a658 2
         result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                   "ZoneIdentifier", zoneID)
d660 1
a660 2
            call Pgs_smf_getMsg(result, mnemonic, msg)
            msr = mnemonic // ':  ' // msg
d664 2
a665 2
         result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                   "WestBoundingCoordinate", minLon)
d667 1
a667 2
            call Pgs_smf_getMsg(result, mnemonic, msg)
            msr = mnemonic // ':  ' // msg
d671 3
a673 2
         result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                   "NorthBoundingCoordinate", maxLat)
d675 1
a675 2
            call Pgs_smf_getMsg(result, mnemonic, msg)
            msr = mnemonic // ':  ' // msg
d679 3
a681 2
         result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                   "EastBoundingCoordinate", maxLon)
d683 1
a683 2
            call Pgs_smf_getMsg(result, mnemonic, msg)
            msr = mnemonic // ':  ' // msg
d687 3
a689 2
         result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                   "SouthBoundingCoordinate", minLat)
d691 130
a820 2
            call Pgs_smf_getMsg(result, mnemonic, msg)
            msr = mnemonic // ':  ' // msg
d844 4
d1041 3
@


1.5
log
@Added ONLY to USE L2GPData; replaced local error msgs with MLSMSG_DeAllocate.
@
text
@d9 1
a9 3
   USE SDPToolkit
   USE MLSMessageModule
   USE MLSCommon
d12 3
a14 1
   USE Hdf
d16 3
d26 1
a26 1
   "$Id: L3DMData.f90,v 1.5 2000/11/22 21:42:26 nakamura Exp $"
d33 1
a45 15
   CHARACTER (LEN=*), PARAMETER :: DAT_ERR = 'Failed to define data field '
   CHARACTER (LEN=*), PARAMETER :: DIM_ERR = 'Failed to define dimension '
   CHARACTER (LEN=*), PARAMETER :: GEO_ERR = 'Failed to define geolocation &
                                             &field '
   CHARACTER (LEN=*), PARAMETER :: TAI2A_ERR = 'Error converting time from &
                                               &TAI to UTC.'
   CHARACTER (LEN=*), PARAMETER :: WR_ERR = 'Failed to write field '

   INTEGER, PARAMETER :: CCSDS_LEN = 27
   INTEGER, PARAMETER :: CCSDSB_LEN = 25
   INTEGER, PARAMETER :: INVENTORYMETADATA = 2
   INTEGER, PARAMETER :: GridNameLen = 64
   INTEGER, PARAMETER :: maxNumGrids = 100
   INTEGER, PARAMETER :: maxWindow = 30

d78 13
d149 3
a151 3
!--------------------------------------------------------------------
   SUBROUTINE OutputGrids(physicalFilename, numGrids, indx, l3dmData)
!--------------------------------------------------------------------
d158 1
a158 1
      CHARACTER (LEN=*), INTENT(IN) :: physicalFilename
d160 1
a160 1
      INTEGER, INTENT(IN) :: numGrids 
d162 1
a162 3
      INTEGER, INTENT(IN) :: indx(numGrids)

      TYPE (L3DMData_T), INTENT(IN) :: l3dmData(:)
d185 2
d189 1
a189 1
      INTEGER :: gdfID, gdId, i, status
d197 22
d221 5
a225 5
      gdfID = gdopen(physicalFilename, DFACC_CREATE)
      IF (gdfID == -1) THEN
         msr = MLSMSG_Fileopen // physicalFilename
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d227 1
a227 1
! Set up the grids.  The region is bounded by 180.0W to 180.0E longitude &
d231 2
a232 2
      uplft(1) = -180000000.00
      lowrgt(1) = 180000000.00
d234 1
a234 5
      projparm = 0.0

! For each grid belonging in this file,

      DO i = 1, numGrids
d238 2
a239 2
         maxLat = MAXVAL( l3dmData(indx(i))%latitude )
         minLat = MINVAL( l3dmData(indx(i))%latitude )
d246 1
a246 1
! Create the grids
d248 2
a249 2
         gdId = gdcreate(gdfID, l3dmData(indx(i))%name, &
             l3dmData(indx(i))%nLons, l3dmData(indx(i))%nLats, uplft, lowrgt)
d251 1
a251 1
            msr = 'Failed to create grid ' // l3dmData(indx(i))%name
d257 1
a257 1
         status = gddefdim(gdId, DIMX_NAME, l3dmData(indx(i))%nLons)
d263 1
a263 1
         status = gddefdim(gdId, DIMY_NAME, l3dmData(indx(i))%nLats)
d269 1
a269 1
         status = gddefdim(gdId, DIMZ_NAME, l3dmData(indx(i))%nLevels)
d285 1
a285 2
            msr = 'Failed to define projection for grid ' // &
                   l3dmData(indx(i))%name
d345 6
a350 1
      ENDDO
d352 1
a352 6
      status = gdclose(gdfID)
      IF (status /= 0) THEN
         msr = 'Failed to close file ' // TRIM(physicalFilename) // &
               ' after definition.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d354 5
a358 20
! Re-open file for writing

      gdfID = gdopen(physicalFilename, DFACC_RDWR)
      IF (gdfID == -1) THEN
         msr = MLSMSG_Fileopen // TRIM(physicalFilename) // ' for writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Initialize values outside of grid loop

      start = 0
      stride = 1

! For each grid belonging in the file,

      DO i = 1, numGrids

         edge(1) = l3dmData(indx(i))%nLevels
         edge(2) = l3dmData(indx(i))%nLats
         edge(3) = l3dmData(indx(i))%nLons
d362 1
a362 1
         gdId = gdattach(gdfID, l3dmData(indx(i))%name)
d364 1
a364 1
            msr = 'Failed to attach to grid ' // l3dmData(indx(i))%name
d370 6
d377 1
a377 1
                          l3dmData(indx(i))%time)
d380 1
a380 1
                   // l3dmData(indx(i))%name
d385 1
a385 1
                           REAL(l3dmData(indx(i))%pressure) )
d388 1
a388 1
                  // l3dmData(indx(i))%name
d393 1
a393 1
                           REAL(l3dmData(indx(i))%latitude) )
d396 1
a396 1
                  // l3dmData(indx(i))%name
d401 1
a401 1
                           REAL(l3dmData(indx(i))%longitude) )
d404 1
a404 1
                   // l3dmData(indx(i))%name
d409 1
a409 1
                           REAL(l3dmData(indx(i))%l3dmValue) )
d412 1
a412 1
                  // l3dmData(indx(i))%name
d417 1
a417 1
                           REAL(l3dmData(indx(i))%l3dmPrecision) )
d420 1
a420 1
                  // l3dmData(indx(i))%name
d424 1
a424 1
! Detach from each grid after writing
d428 9
a436 1
            msr = GD_ERR // TRIM( l3dmData(indx(i))%name ) // &
d441 4
a446 9
! Close the file after writing

      status = gdclose(gdfID)
      IF (status /= 0) THEN
         msr = 'Failed to close file ' // TRIM(physicalFilename) // &
               ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

d451 3
a453 3
!----------------------------------------------------------------------------
   SUBROUTINE WriteMetaL3DM (l3File, mlspcf_mcf, numGrids, indx, l3dm, timeA)
!----------------------------------------------------------------------------
d460 1
a460 1
      CHARACTER (LEN=*), INTENT(IN) :: l3File
a463 8
      INTEGER, INTENT(IN) :: numGrids

      INTEGER, INTENT(IN) :: indx(:)

      TYPE (L3DMData_T), INTENT(IN) :: l3dm(:)

      CHARACTER (LEN=CCSDS_LEN), INTENT(IN) :: timeA 

d475 1
a475 1
      CHARACTER (LEN=21) :: sval
d480 1
a480 1
      INTEGER :: allGrids, hdfReturn, i, result, sdid
d482 1
a482 1
      REAL(r8) :: dval, maxGrid, maxLat, minGrid, minLat
d490 14
d506 2
a507 2
      sdid = sfstart(l3File, DFACC_WRITE)
      IF (sdid == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d510 26
a535 1
! Find the time, max & min lat over all grids for this product
d537 7
a543 1
      allGrids = SIZE(l3dm)
d545 7
a551 2
      maxLat = 0.0
      minLat = 0.0
d553 15
a567 6
      DO i = 1, numGrids
         maxGrid = MAXVAL(l3dm(indx(i))%latitude)
         minGrid = MINVAL(l3dm(indx(i))%latitude)
         maxLat = MAX(maxGrid,maxLat)
         minLat = MIN(minGrid,minLat)
      ENDDO
d569 7
a575 2
      date = timeA(1:10)
      time = timeA(12:26)
d577 7
a583 1
! Set PGE values
d585 7
a591 34
      sval = 'Horizontal & Vertical'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                "GranuleSpatialDomainType", sval)

      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                "RangeBeginningDate", date)
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                "RangeBeginningTime", time)

      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "RangeEndingDate", date)
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "RangeEndingTime", time)

      sval = 'Other Grid System'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "ZoneIdentifier", &
                                 sval)

      dval = -180.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                "WestBoundingCoordinate", dval)
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                "NorthBoundingCoordinate", maxLat)
      dval = 180.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                "EastBoundingCoordinate", dval)
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                "SouthBoundingCoordinate", minLat)

      IF (result /= PGS_S_SUCCESS) THEN
         call Pgs_smf_getMsg(result, mnemonic, msg)
         msr = mnemonic // ':  ' // msg
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d595 10
a604 8
      result = pgs_met_write(groups(INVENTORYMETADATA), "coremetadata", sdid)

      IF (result /= PGS_S_SUCCESS) THEN
         IF (result == PGSMET_E_MAND_NOT_SET) THEN
            CALL MLSMessage(MLSMSG_Error, ModuleName, 'Some of the mandatory &
                                           &metadata parameters were not set.')
         ELSE
           CALL MLSMessage(MLSMSG_Error, ModuleName, 'Metadata write failed.')
a605 1
      ENDIF
d609 5
a613 3
      hdfReturn = sfend(sdid)
      IF (hdfReturn /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Error &
                                    &closing HDF file after writing metadata.')
d806 3
a819 1
!#
@


1.4
log
@Added parameter GridNameLen.
@
text
@d12 2
a13 1
   USE L2GPData
d23 1
a23 1
   "$Id: L3DMData.f90,v 1.3 2000/10/24 19:21:08 nakamura Exp $"
d48 1
a653 3
      CHARACTER (LEN=*), PARAMETER :: DE_ERR = 'Deallocation failed for l3dm &
                                               &pointer:  '

d660 1
a660 1
      INTEGER :: dealloc_err
d664 3
a666 4
      IF ( ASSOCIATED(l3dm%latitude) ) DEALLOCATE (l3dm%latitude, &
                                                   STAT=dealloc_err)
      IF ( dealloc_err /= 0 ) THEN
         msr = DE_ERR // 'latitude'
d670 3
a672 4
      IF ( ASSOCIATED(l3dm%longitude) ) DEALLOCATE (l3dm%longitude, &
                                                    STAT=dealloc_err)
      IF ( dealloc_err /= 0 ) THEN
         msr = DE_ERR // 'longitude'
d678 3
a680 4
      IF ( ASSOCIATED(l3dm%pressure) ) DEALLOCATE (l3dm%pressure, &
                                                   STAT=dealloc_err)
      IF ( dealloc_err /= 0 ) THEN
         msr = DE_ERR // 'pressure'
d686 3
a688 4
      IF ( ASSOCIATED(l3dm%l3dmValue) ) DEALLOCATE (l3dm%l3dmValue, &
                                                    STAT=dealloc_err)
      IF ( dealloc_err /= 0 ) THEN
         msr = DE_ERR // 'l3dmValue'
d693 3
a695 3
                                                        STAT=dealloc_err)
      IF ( dealloc_err /= 0 ) THEN
         msr = DE_ERR // 'l3dmPrecision'
d722 2
d739 4
a742 2
         IF ( err /= 0 ) CALL MLSMessage ( MLSMSG_Error, ModuleName, 'Failed &
                                                &to deallocate l3dm database.')
d755 3
d766 1
@


1.3
log
@Removed dependence on OutputL2GP.
@
text
@d22 1
a22 1
   "$Id: L3DMData.f90,v 1.3 2000/10/17 19:50:36 nakamura Exp nakamura $"
d51 1
d756 3
@


1.2
log
@Added parameters used globally by L3; updated WriteMetaL3DM for new input.
@
text
@a13 1
   USE OutputL2GP
d41 4
d755 3
@


1.1
log
@Module for the L3DM data type.
@
text
@d23 1
a23 1
   "$Id: L3DMData.f90,v 1.23 2000/09/20 20:23:14 nakamura Exp nakamura $"
d42 9
d53 1
a53 1
  TYPE L3DMData_T
d432 3
a434 3
!---------------------------------------------------------------------
   SUBROUTINE WriteMetaL3DM (l3File, gridName, mlspcf_mcf, l3dm, date)
!---------------------------------------------------------------------
d441 1
a441 1
      CHARACTER (LEN=*), INTENT(IN) :: gridName, l3File
d445 4
d451 1
a451 1
      CHARACTER (LEN=*), INTENT(OUT) :: date
a454 2
      INTEGER, PARAMETER :: INVENTORYMETADATA = 2

d457 2
a458 2
      INTEGER :: pgs_met_init, pgs_met_remove, pgs_met_setAttr_d
      INTEGER :: pgs_met_setAttr_s, pgs_met_write
d462 2
a463 1
      CHARACTER (LEN=25) :: time
a464 1
      CHARACTER (LEN=27) :: timeUTC
d469 1
a469 1
      INTEGER :: allGrids, hdfReturn, i, result, returnStatus, sdid
d471 1
a471 1
      REAL(r8) :: dval, maxGrid, maxLat, minGrid, minLat, timeTAI
d492 5
a496 8
      DO i = 1, allGrids
         IF ( INDEX(l3dm(i)%name,TRIM(gridName)) == 1 ) THEN
            timeTAI = l3dm(i)%time
            maxGrid = MAXVAL(l3dm(i)%latitude)
            minGrid = MINVAL(l3dm(i)%latitude)
            maxLat = MAX(maxGrid,maxLat)
            minLat = MIN(minGrid,minLat)
         ENDIF
d499 2
a500 8
! Convert date/time to CCSDS format

      returnStatus = Pgs_td_taiToUTC(timeTAI, timeUTC)
      IF (returnStatus /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, &
                      ModuleName,'Error converting file time from TAI to UTC.')

      date = timeUTC(1:10)
      time = timeUTC(12:26)
d751 4
a754 1
!# $Log: $
@

