head	1.14;
access;
symbols
	V0-5-Level2:1.12
	V0-5-SIPS:1.11;
locks; strict;
comment	@# @;


1.14
date	2001.07.18.15.57.30;	author nakamura;	state dead;
branches;
next	1.13;

1.13
date	2001.05.04.18.36.56;	author nakamura;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.24.19.40.23;	author nakamura;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.11.18.50.45;	author nakamura;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.28.18.00.07;	author nakamura;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.28.17.25.01;	author nakamura;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.18.16.51.50;	author nakamura;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.16.17.45.38;	author nakamura;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.29.21.40.52;	author nakamura;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.28.17.33.06;	author nakamura;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.17.25.23;	author nakamura;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.22.17.24.45;	author nakamura;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.22.17.24.30;	author nakamura;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.22.17.02.39;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Changed name to MLSL3D.
@
text
@
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

!===================================
PROGRAM MLSL3 ! MLS Level 3 software
!===================================

   USE L2GPData, ONLY: L2GPData_T, DestroyL2GPDatabase
   USE L2Interface
   USE L3CF
   USE L3DMData
   USE L3DZData
   USE L3SPData
   USE MLSCF
   USE MLSL3Common
   USE MLSMessageModule
   USE OpenInit
   USE OutputClose
   USE Synoptic

   IMPLICIT NONE

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &                                                    
   "$Id: MLSL3.f90,v 1.13 2001/05/04 18:36:56 nakamura Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: MLSL3.f90,v $"
!----------------------------------------------------------

! Brief description of program
! This is the MLS Level 3 program.

! Parameters

! Functions

! Variables

   TYPE( L3CFDef_T ) :: cfDef
   TYPE( Mlscf_T ) :: cf
   TYPE( OutputFiles_T ) :: dFiles, sFiles
   TYPE( OutputFlags_T ) :: flags
   TYPE( PCFData_T ) :: pcf
   TYPE( L2GPData_T ), POINTER :: l2gp(:), l3r(:), residA(:), residD(:)
   TYPE( L3CFProd_T ), POINTER :: cfProd(:)
   TYPE( L3DMData_T ), POINTER :: l3dm(:), dmA(:), dmD(:)
   TYPE( L3DZData_T ), POINTER :: dzs(:), dza(:), dzd(:)
   TYPE( L3SPData_T ), POINTER :: l3sp(:)

   CHARACTER (LEN=480) :: msr
   CHARACTER (LEN=1), POINTER :: anText(:)

   INTEGER :: i, l2Days

   REAL(r8), POINTER :: avgPer(:)

! Initializations

   sFiles%nFiles = 0
   dFiles%nFiles = 0
   sFiles%name = ''
   dFiles%name = ''
   sFiles%date = ''
   dFiles%date = ''

   CALL MLSMessage (MLSMSG_Info, ModuleName, 'EOS MLS Level 3 data processing &
                                             &started')

! Fill structures with input data from the PCF and L3CF.

   CALL OpenAndInitialize(pcf, cf, cfProd, cfDef, anText, avgPer)

! For each product in the DailyMap section of the cf,

   DO i = 1, SIZE(cfProd)
 
! Read all the l2gp data which exists in the input window for that product

      CALL ReadL2GPProd(cfProd(i), pcf%l2StartDay, pcf%l2EndDay, l2Days, l2gp)

! If insufficient data found, go on to the next product

      IF (l2Days < 1) THEN
         msr = 'No data found for ' // TRIM(cfProd(i)%l3prodNameD) &
            // '.  Skipping CORE processing and moving on to the next product.'
         CALL MLSMessage (MLSMSG_Warning, ModuleName, msr)
         CYCLE
      ELSE
         msr = 'Input data successfully read for ' //  &
                TRIM(cfProd(i)%l3prodNameD) // '; CORE processing started ...'
         CALL MLSMessage (MLSMSG_Info, ModuleName, msr)
      ENDIF

! CORE processing
 
      CALL DailyCoreProcessing(cfProd(i), pcf, l2Days, l2gp, avgPer, l3sp, &
                     l3dm, dmA, dmD, dzs, dza, dzd, l3r, residA, residD, flags)

! Check the output data and place them into the appropriate files.  Write the
! l3dm metadata.  Perform any deallocations needed within the product loop.

      msr = 'CORE processing completed for ' // TRIM(cfProd(i)%l3prodNameD) &
            // '; starting Output task ...'
      CALL MLSMessage (MLSMSG_Info, ModuleName, msr)

      CALL OutputProd(pcf, cfProd(i), cfDef, anText, l3sp, l3dm, dmA, dmD, &
                      l3r, residA, residD, dzs, dza, dzd, flags, sFiles)

! Deallocate the databases

      CALL DestroyL2GPDatabase(l3r)
      CALL DestroyL2GPDatabase(residA)
      CALL DestroyL2GPDatabase(residD)

      CALL DestroyL3DMDatabase(l3dm)
      CALL DestroyL3DMDatabase(dmA)
      CALL DestroyL3DMDatabase(dmD)

      CALL DestroyL3SPDatabase(l3sp)

      CALL DestroyL3DZDatabase(dzs)
      CALL DestroyL3DZDatabase(dza)
      CALL DestroyL3DZDatabase(dzd)

      CALL DestroyL2GPDatabase(l2gp)

   ENDDO

   msr = 'Product loop processing completed; beginning Output/Close task ... '
   CALL MLSMessage (MLSMSG_Info, ModuleName, msr)

! Perform final Output & Close tasks outside of the product processing loop.

   CALL OutputAndClose(cf, pcf, cfProd, cfDef, avgPer, anText, sFiles, dFiles)

   CALL MLSMessage (MLSMSG_Info, ModuleName, 'EOS MLS Level 3 data processing &
                                                     &successfully completed!')

! Detailed description of program
! The program is a prototype for the MLS Level 3 software.

!================
END PROGRAM MLSL3
!================

! $Log: MLSL3.f90,v $
! Revision 1.13  2001/05/04 18:36:56  nakamura
! Replaced L3DZFiles_T with OutputFiles_T; changed check of minDays to check of data existence.
!
! Revision 1.12  2001/04/24 19:40:23  nakamura
! Added ONLY to USE L2GPData statement.
!
! Revision 1.11  2001/04/11 18:50:45  nakamura
! Moved deallocations for pointers passed between CORE & I/O up to this level.
!
! Revision 1.10  2001/02/28 18:00:07  nakamura
! Fixed line-break in log comment.
!
! Revision 1.9  2001/02/28 17:25:01  nakamura
! Integrated CORE module; changed name of loop routine to OutputProd & added terminal OutputAndClose.
!
! Revision 1.8  2001/01/18 16:51:50  nakamura
! Moved minDays from PCF to cf.
!
! Revision 1.7  2001/01/16 17:45:38  nakamura
! Updated for new MCFs and added annotation.
!
! Revision 1.6  2000/12/29 21:40:52  nakamura
! Added avgPer, more simulated data; revised argument list for ReadL2GPProd; switched to one-product/all-days paradigm.
!
! Revision 1.5  2000/11/28 17:33:06  nakamura
! Added code to put non-zero values in simulated L3DM output.
!
! Revision 1.4  2000/11/22 17:25:23  nakamura
! Required to go back to 1.2 -- same as 1.1
!
! Revision 1.3  2000/11/22 17:24:45  nakamura
! Required to go back to 1.2 -- same as 1.1
!
! Revision 1.2  2000/11/22 17:24:30  nakamura
! Required to go back to 1.2 -- same as 1.1
!
! Revision 1.1  2000/11/22 17:02:39  nakamura
! MLS Level 3 program
!
@


1.13
log
@Replaced L3DZFiles_T with OutputFiles_T; changed check of minDays to check of data existence.
@
text
@d26 1
a26 1
   "$Id: MLSL3.f90,v 1.12 2001/04/24 19:40:23 nakamura Exp $"
d147 3
@


1.12
log
@Added ONLY to USE L2GPData statement.
@
text
@d16 1
d26 1
a26 1
   "$Id: MLSL3.f90,v 1.11 2001/04/11 18:50:45 nakamura Exp $"
d39 1
d41 1
a41 1
   TYPE( L3CFDef_T ) :: cfDef
d44 1
a44 2
   TYPE( L2GPData_T ), POINTER :: l2gp(:)
   TYPE( L2GPData_T ), POINTER :: l3r(:), residA(:), residD(:)
a47 1
   TYPE( L3DZFiles_T ) :: zFiles
d59 6
a64 6
   zFiles%nStd = 0
   zFiles%nDg = 0
   zFiles%stdNames = ''
   zFiles%dgNames = ''
   zFiles%stdDates = ''
   zFiles%dgDates = ''
d83 3
a85 3
      IF (l2Days < cfDef%minDays) THEN
         msr = 'Skipping CORE processing for ' // TRIM(cfProd(i)%l3prodNameD) &
            // ' and moving on to the next product.'
d107 1
a107 1
                      l3r, residA, residD, dzs, dza, dzd, flags, zFiles)
d134 1
a134 1
   CALL OutputAndClose(cf, pcf, cfProd, cfDef, avgPer, anText, zFiles)
d147 3
@


1.11
log
@Moved deallocations for pointers passed between CORE & I/O up to this level.
@
text
@d9 1
a9 1
   USE L2GPData
d25 1
a25 1
   "$Id: MLSL3.f90,v 1.10 2001/02/28 18:00:07 nakamura Exp $"
d147 3
@


1.10
log
@Fixed line-break in log comment.
@
text
@d25 1
a25 1
   "$Id: MLSL3.f90,v 1.9 2001/02/28 17:25:01 nakamura Exp $"
d109 15
a123 1
! Deallocate the l2gp database for the product
d147 3
@


1.9
log
@Integrated CORE module; changed name of loop routine to OutputProd & added terminal OutputAndClose.
@
text
@d25 1
a25 1
   "$Id: MLSL3.f90,v 1.13 2001/02/22 20:31:01 nakamura Exp nakamura $"
d133 3
d143 1
a143 2
! Added avgPer, more simulated data; revised argument list for ReadL2GPProd; swi
tched to one-product/all-days paradigm.
@


1.8
log
@Moved minDays from PCF to cf.
@
text
@d13 1
d19 1
d25 1
a25 1
   "$Id: MLSL3.f90,v 1.7 2001/01/16 17:45:38 nakamura Exp $"
d46 2
d53 1
a53 2
   INTEGER :: count, err, i, j, k, l, l2Days, nlev, nf, nwv, numDays, numSwaths
   INTEGER :: rDays
d57 9
d86 1
a86 1
         CALL MLSMessage (MLSMSG_Info, ModuleName, msr)
a87 23
      ENDIF

! -----------------------------------------------------------------------------
!
! CORE processing --
!
! A example of a call to subroutine which performs this task could be:
!
!   CALL DailyCoreProcessing(pcf, cfProd, avgPer, l3sp, l3dm, dmA, dmD, l3r, &
!                            residA, residD, flags)
!
! where the arguments are defined in the list of variables above.
!
! -----------------------------------------------------------------------------

! Simulated CORE output for one product

      nlev = 24
      nwv = 10
      nf = 15

      IF (cfProd(i)%mode == 'all') THEN
         numSwaths = 3
d89 3
a91 1
         numSwaths = 1
d94 4
a97 121
      ALLOCATE( l3sp(numSwaths), STAT=err )
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' l3sp array.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      l3sp(1)%name = cfProd(i)%l3prodNameD
      l3sp(2)%name = TRIM(cfProd(i)%l3prodNameD) // 'Ascending'
      l3sp(3)%name = TRIM(cfProd(i)%l3prodNameD) // 'Descending'

      l3sp%startTime = l2gp(1)%time(1)
      l3sp%endTime = l2gp(l2Days)%time(l2gp(l2Days)%nTimes)

      DO j = 1, numSwaths

         CALL AllocateL3SP( nlev, cfProd(i)%nLats, nwv, nf, l3sp(j) )
         l3sp(j)%pressure = l2gp(1)%pressures(:nlev)
         l3sp(j)%latitude = cfProd(i)%latGridMap(:l3sp(j)%nLats)

         DO k = 1, l3sp(j)%nWaveNum
            l3sp(j)%waveNumber(k) = k * 1.0
         ENDDO

         DO k = 1, l3sp(j)%nFreqs
            l3sp(j)%frequency(k) = k * 1.0
         ENDDO

         l3sp(j)%l3spRelValue = 0.0
         l3sp(j)%l3spRelPrecision = -1.0
         l3sp(j)%l3spImgValue = 0.0
         l3sp(j)%l3spImgPrecision = -1.0

      ENDDO

      numDays = cfProd(i)%nDays
      ALLOCATE( l3dm(numDays), dmA(numDays), dmD(numDays), l3r(numDays), &
                residA(numDays), residD(numDays), STAT=err )
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' l3dm, l3r arrays.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      l3dm%name = cfProd(i)%l3prodNameD
      dmA%name = TRIM(cfProd(i)%l3prodNameD) // 'Ascending'
      dmD%name = TRIM(cfProd(i)%l3prodNameD) // 'Descending'

      DO j = 1, numDays

         l3dm(j)%time = cfProd(i)%timeD(j)
         dmA(j)%time = cfProd(i)%timeD(j)
         dmD(j)%time = cfProd(i)%timeD(j)

         CALL AllocateL3DM( nlev, cfProd(i)%nLats, cfProd(i)%nLons, l3dm(j) )
         CALL AllocateL3DM( nlev, cfProd(i)%nLats, cfProd(i)%nLons, dmA(j) )
         CALL AllocateL3DM( nlev, cfProd(i)%nLats, cfProd(i)%nLons, dmD(j) )

         l3dm(j)%pressure = l2gp(1)%pressures(:nlev)
         dmA(j)%pressure = l2gp(1)%pressures(:nlev)
         dmD(j)%pressure = l2gp(1)%pressures(:nlev)

         l3dm(j)%latitude = cfProd(i)%latGridMap(:l3dm(j)%nLats)
         dmA(j)%latitude = cfProd(i)%latGridMap(:dmA(j)%nLats)
         dmD(j)%latitude = cfProd(i)%latGridMap(:dmD(j)%nLats)
     
         l3dm(j)%longitude = cfProd(i)%longGrid(:l3dm(j)%nLons)
         dmA(j)%longitude = cfProd(i)%longGrid(:dmA(j)%nLons)
         dmD(j)%longitude = cfProd(i)%longGrid(:dmD(j)%nLons)

         l3dm(j)%l3dmValue = 0.0
         dmA(j)%l3dmValue = 0.0
         dmD(j)%l3dmValue = 0.0

         l3dm(j)%l3dmPrecision = -1.0
         dmA(j)%l3dmPrecision = -1.0
         dmD(j)%l3dmPrecision = -1.0

      ENDDO

!  DO i = 1, numDays

!     DO j = 1, l3dm(i)%nLevels

!        count = 1
!        DO k = 1, l3dm(i)%nLons
!           DO l = 1, l3dm(i)%nLats
!              IF (count > SIZE(l2gp(20)%l2gpValue,3)) THEN
!                 l3dm(i)%l3dmValue(j,l,k) = 0.0
!              ELSE
!                 l3dm(i)%l3dmValue(j,l,k) = l2gp(20)%l2gpValue(1,j,count)
!              ENDIF
!              count = l + 1
!           ENDDO
!        ENDDO

!     ENDDO

!  ENDDO

      CALL ReadL2GPProd(cfProd(i), pcf%l3StartDay, pcf%l3EndDay, rDays, l3r)
      CALL ReadL2GPProd(cfProd(i), pcf%l3StartDay, pcf%l3EndDay, rDays, residA)
      CALL ReadL2GPProd(cfProd(i), pcf%l3StartDay, pcf%l3EndDay, rDays, residD)

      l3r%name = TRIM(cfProd(i)%l3prodNameD) // 'Residuals'
      residA%name = TRIM(cfProd(i)%l3prodNameD) // 'AscendingResiduals'
      residD%name = TRIM(cfProd(i)%l3prodNameD) // 'DescendingResiduals'

      DO j = 1, rDays
         l3r(j)%l2gpValue = 1.0
         residA(j)%l2gpValue = 2.0
         residD(j)%l2gpValue = 3.0
      ENDDO

      flags%writel3sp    = .TRUE.
      flags%writel3dmCom = .TRUE.
      flags%writel3dmAsc = .TRUE.
      flags%writel3dmDes = .TRUE.
      flags%writel3rCom  = .TRUE.
      flags%writel3rAsc  = .TRUE.
      flags%writel3rDes  = .TRUE.

!------------------------------------------------------------------------------
d102 6
a107 2
      CALL OutputAndClose(pcf, cfProd(i), anText, l3sp, l3dm, dmA, dmD, l3r, &
                          residA, residD, flags)
d115 2
a116 1
! Write the log file metadata
d118 1
a118 1
   CALL WriteMetaLog(pcf, cfDef%logType)
d120 1
a120 13
! Final deallocations
 
   DEALLOCATE(cfProd, anText, avgPer, STAT=err)
   IF ( err /= 0 ) THEN
      msr = MLSMSG_DeAllocate // '  Open/Init quantities.'
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF

   DEALLOCATE (cf%Sections, STAT=err)
   IF ( err /= 0 ) THEN
      msr = MLSMSG_DeAllocate // '  cf section pointers.'
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF
d133 3
d140 2
a141 1
! Added avgPer, more simulated data; revised argument list for ReadL2GPProd; switched to one-product/all-days paradigm.
@


1.7
log
@Updated for new MCFs and added annotation.
@
text
@d23 1
a23 1
   "$Id: MLSL3.f90,v 1.6 2000/12/29 21:40:52 nakamura Exp $"
d37 2
a39 1
   TYPE( OutputFlags_T ) :: flags
a46 1
   CHARACTER (LEN=FileNameLen) :: logType
d59 1
a59 1
   CALL OpenAndInitialize(pcf, cf, cfProd, logType, anText, avgPer)
d71 1
a71 1
      IF (l2Days < pcf%minDays) THEN
d239 1
a239 1
   CALL WriteMetaLog(pcf, logType)
d266 3
@


1.6
log
@Added avgPer, more simulated data; revised argument list for ReadL2GPProd; switched to one-product/all-days paradigm.
@
text
@d23 1
a23 1
   "$Id: MLSL3.f90,v 1.7 2000/12/29 19:15:51 nakamura Exp nakamura $"
d46 2
d59 1
a59 1
   CALL OpenAndInitialize(pcf, cf, cfProd, avgPer)
d228 2
a229 2
      CALL OutputAndClose(cfProd(i), l3sp, l3dm, dmA, dmD, l3r, residA, &
                          residD, flags)
d239 1
a239 1
   CALL WriteMetaLog(pcf)
d243 1
a243 1
   DEALLOCATE(cfProd, avgPer, STAT=err)
d245 1
a245 1
      msr = MLSMSG_DeAllocate // '  l3cf pointer.'
d266 3
@


1.5
log
@Added code to put non-zero values in simulated L3DM output.
@
text
@d9 2
a10 2
   USE OpenInit
   USE MLSCF
d13 2
d16 1
a16 2
   USE L2Interface
   USE L2GPData
d23 1
a23 1
   "$Id: MLSL3.f90,v 1.4 2000/11/22 17:25:23 nakamura Exp $"
d36 1
d38 1
a38 1
   TYPE( Mlscf_T ) :: cf
d40 1
d42 2
a43 1
   TYPE( L3DMData_T ), POINTER :: l3dm(:)
d47 4
a50 2
   INTEGER :: allGrids, count, err, i, j, k, l, l2Days
   INTEGER, ALLOCATABLE :: nlev(:)
d57 3
a59 1
   CALL OpenAndInitialize(pcf, cf, cfProd)
d61 1
a61 1
! Code for the CORE processing is expected here.
d63 13
d78 1
a78 4
! The currently agreed-upon interface between this module and the I/O shell
! is -- INPUT l2gp data will be read into an array for a PRODUCT, where each
! element of the array is for one DAY; OUTPUT l3dm data will be returned in an
! array for a DAY, where each element of the array is for one PRODUCT.
d82 2
a83 1
!   CALL DailyCoreProcessing(pcf, cfProd, l3dm)
a86 2
! More code that simulates some aspects of this task follows:
!
a87 3
 
! Read the l2gp data for ClO, the first product listed in the cf (and the only
! one for which simulated input files currently exist)
d89 1
a89 1
   CALL ReadL2GPProd(cfProd(1), pcf, l2Days, l2gp)
d91 28
a118 4
   IF (l2Days < pcf%minDays) THEN
      msr = 'Insufficient input data to process ' // cfProd(1)%l3prodNameD
      CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
   ENDIF
d120 3
a122 1
! Simulated CORE output
d124 3
a126 1
   allGrids = 16
d128 4
a131 5
   ALLOCATE( nlev(allGrids), l3dm(allGrids), STAT=err )
   IF ( err /= 0 ) THEN
      msr = MLSMSG_Allocate // ' l3dm arrays.'
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF
d133 1
a133 38
   l3dm(1:3)%name = cfProd(1)%quantities(1:3)
   l3dm(4)%name = cfProd(2)%quantities(1)
   l3dm(5)%name = cfProd(3)%quantities(1)
   l3dm(6)%name = cfProd(4)%quantities(1)
   l3dm(7)%name = cfProd(5)%quantities(1)
   l3dm(8)%name = cfProd(6)%quantities(1)
   l3dm(9)%name = cfProd(7)%quantities(1)
   l3dm(10:12)%name = cfProd(8)%quantities(1:3)
   l3dm(13:15)%name = cfProd(9)%quantities(1:3)
   l3dm(16)%name = cfProd(10)%quantities(1)

   l3dm(1:3)%time = cfProd(1)%timeD(1)
   l3dm(4)%time = cfProd(2)%timeD(1)
   l3dm(5)%time = cfProd(3)%timeD(1)
   l3dm(6)%time = cfProd(4)%timeD(1)
   l3dm(7)%time = cfProd(5)%timeD(1)
   l3dm(8)%time = cfProd(6)%timeD(1)
   l3dm(9)%time = cfProd(7)%timeD(1)
   l3dm(10:12)%time = cfProd(8)%timeD(1)
   l3dm(13:15)%time = cfProd(9)%timeD(1)
   l3dm(16)%time = cfProd(10)%timeD(1)

   nlev(1:3) = 24
   nlev(4:5) = 56
   nlev(6) = 36
   nlev(7) = 12
   nlev(8) = 24
   nlev(9) = 28
   nlev(10) = 36
   nlev(11:12) = 30
   nlev(13:15) = 24
   nlev(16) = 56

   DO i = 1, 3
      CALL AllocateL3DM( nlev(i), cfProd(1)%nLats, cfProd(1)%nLons, l3dm(i) )
      l3dm(i)%latitude = cfProd(1)%latGridMap(1:cfProd(1)%nLats)
      l3dm(i)%longitude = cfProd(1)%longGrid(1:cfProd(1)%nLons)
   ENDDO
d135 41
a175 5
   DO i = 4, 9
      CALL AllocateL3DM(nlev(i), cfProd(i-2)%nLats, cfProd(i-2)%nLons, l3dm(i))
      l3dm(i)%latitude = cfProd(i-2)%latGridMap(1:cfProd(i-2)%nLats)
      l3dm(i)%longitude = cfProd(i-2)%longGrid(1:cfProd(i-2)%nLons)
   ENDDO
d177 1
a177 5
   DO i = 10, 12
      CALL AllocateL3DM( nlev(i), cfProd(8)%nLats, cfProd(8)%nLons, l3dm(i) )
      l3dm(i)%latitude = cfProd(8)%latGridMap(1:cfProd(8)%nLats)
      l3dm(i)%longitude = cfProd(8)%longGrid(1:cfProd(8)%nLons)
   ENDDO
d179 1
a179 5
   DO i = 13, 15
      CALL AllocateL3DM( nlev(i), cfProd(9)%nLats, cfProd(9)%nLons, l3dm(i) )
      l3dm(i)%latitude = cfProd(9)%latGridMap(1:cfProd(9)%nLats)
      l3dm(i)%longitude = cfProd(9)%longGrid(1:cfProd(9)%nLons)
   ENDDO
d181 1
a181 21
   CALL AllocateL3DM( nlev(16), cfProd(10)%nLats, cfProd(10)%nLons, l3dm(16) )
   l3dm(16)%latitude = cfProd(10)%latGridMap(1:cfProd(10)%nLats)
   l3dm(16)%longitude = cfProd(10)%longGrid(1:cfProd(10)%nLons)

   DO i = 1, allGrids

      DO j = 1, l3dm(i)%nLevels

         l3dm(i)%pressure(j) = l2gp(1)%pressures(j)

         count = 1
         DO k = 1, l3dm(i)%nLons
            DO l = 1, l3dm(i)%nLats
               IF (count > SIZE(l2gp(1)%l2gpValue,3)) THEN
                  l3dm(i)%l3dmValue(j,l,k) = 0.0
               ELSE
                  l3dm(i)%l3dmValue(j,l,k) = l2gp(1)%l2gpValue(1,j,count)
               ENDIF
               count = l + 1
            ENDDO
         ENDDO
d183 28
d213 19
a231 1
      l3dm(i)%l3dmPrecision = -1.0
d235 1
a235 2
! Check the output data and place them to the appropriate files. Write the
! metadata.  Perform any outstanding deallocations.
d237 1
a237 1
   CALL OutputAndClose(pcf, cf, cfProd, l3dm)
d239 7
a245 1
! Deallocate the l2gp database, when finished
d247 5
a251 1
   CALL DestroyL2GPDatabase(l2gp)
d264 3
a268 1
!
@


1.4
log
@Required to go back to 1.2 -- same as 1.1
@
text
@d22 1
a22 1
   "$Id: MLSL3.f90,v 1.3 2000/11/22 17:24:45 nakamura Exp $"
d43 1
a43 1
   INTEGER :: allGrids, err, i, j, l2Days
a81 10
! Deallocate the array, and its internal pointers, when finished

   DO i = 1, l2Days
      CALL DestroyL2GPContents(l2gp(i))
   ENDDO

   DEALLOCATE(l2gp, STAT=err )
   IF ( err /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
                                          &deallocate l2gp product array.')

d156 15
a170 1
         l3dm(i)%pressure(j) = j*1.0
a172 1
      l3dm(i)%l3dmValue = 0.0
d182 4
d197 3
@


1.3
log
@Required to go back to 1.2 -- same as 1.1
@
text
@d22 1
a22 1
   "$Id: MLSL3.f90,v 1.2 2000/11/22 17:24:30 nakamura Exp $"
d190 4
@


1.2
log
@Required to go back to 1.2 -- same as 1.1
@
text
@d22 1
a22 1
   "$Id: MLSL3.f90,v 1.1 2000/11/22 17:02:39 nakamura Exp $"
d190 3
a194 1
!
@


1.1
log
@MLS Level 3 program
@
text
@@


